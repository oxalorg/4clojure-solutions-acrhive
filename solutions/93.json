[{"code": "(fn partially-flatten\r\n  [coll]\r\n  (let [leaf? (partial every? (comp not coll?))]\r\n    (if (leaf? coll)\r\n      (vector coll)\r\n      (reduce (fn [acc curr]\r\n                (let [flat-child (partially-flatten curr)]\r\n                  (concat acc flat-child)))\r\n              []\r\n              coll))))", "problem": 93, "user": "4db53f87535d87e67b28fe08"}, {"code": "(fn pflat [coll]\r\n  (cond (and (sequential? coll) (sequential? (first coll)))\r\n        (mapcat pflat coll)\r\n        :else\r\n        (list coll)))", "problem": 93, "user": "4dd4034a535dae65d5c462df"}, {"code": "#(remove % (tree-seq % seq %2))\r\n#(sequential? (nth % 0))", "problem": 93, "user": "4dce6e41535d5973398f92a2"}, {"code": "(fn pflat ([lst] (pflat lst []))\r\n  ([lst accum]\r\n    (cond \r\n      (empty? lst) accum\r\n      (not (coll? (first lst)))  (conj accum lst)\r\n      :else (pflat (rest lst) (pflat (first lst) accum)))))", "problem": 93, "user": "4dbdab4e535d020aff1edf49"}, {"code": "(letfn [(fol? [xs]\r\n  (let [f?  (fn [x] (not (sequential? (first x))))]\r\n    (->> (tree-seq sequential? seq xs)\r\n         (filter sequential?)\r\n         (filter f? ))))]\r\n  fol?)", "problem": 93, "user": "4dc479c0c647a3c54c2ddc73"}, {"code": "(fn part-flat [coll]\r\n  (let [nested? #(some coll? %)]\r\n    (if (nested? coll)\r\n      (apply concat (map part-flat coll))\r\n      [coll])))", "problem": 93, "user": "4dab218f30acd6ed15482a68"}, {"code": "(fn f [c]\r\n  (if (coll? c)\r\n    (if (some coll? c)\r\n      (mapcat f c) [c])\r\n  c))", "problem": 93, "user": "4dada16fc9a9d6ed2699dc57"}, {"code": "(fn [s]\r\n          (letfn [(simple-coll? [s] (and (coll? s) (every? (complement sequential?) s)))]\r\n                 (filter #(or ((complement sequential?) %) (simple-coll? %))\r\n                  (rest (tree-seq #(and (sequential? %) (not (simple-coll? %))) seq s)))))", "problem": 93, "user": "4daddc19c9a9d6ed4599dc57"}, {"code": "(fn [t]\r\n  ((fn f [t a]\r\n     (cond (empty? t) a\r\n               (every? #(not (coll? %)) t)\r\n               (cons t a)\r\n               :else (f (first t) (f (rest t) a))))\r\n    t '()))", "problem": 93, "user": "4db2903f535df7e46ed9b6bf"}, {"code": "(fn [s]\r\n  (filter #(and (sequential? %) (not (sequential? (first %))))\r\n    (tree-seq sequential? seq s)))", "problem": 93, "user": "4dc42799c647a3c54c2ddc71"}, {"code": "(fn [s]\r\n  (filter #(and (sequential? %)\r\n                (not (sequential? (first %))))\r\n          (tree-seq sequential? seq s)))", "problem": 93, "user": "4da3e51330acd6ed10482a68"}, {"code": "(fn f [v]\n\t       (mapcat\n\t\t       #(if (some coll? %) (f %) [%]) v))", "problem": 93, "user": "4dae4da5c9a9d6ed4e99dc57"}, {"code": "(fn partially-flatten [s]\r\n  (lazy-seq\r\n\t\t(when s\r\n\t\t\t(let [[x & xs] s]\r\n\t\t\t\t(if (and (coll? x) (coll? (first x)))\r\n\t\t\t\t\t(concat (partially-flatten x) (partially-flatten xs))\r\n\t\t\t\t\t(cons   x                     (partially-flatten xs)))))))", "problem": 93, "user": "4dd6d6a0535d2dad7130b5ca"}, {"code": "(fn [s]\r\n  (loop [flattened [] rem s]\r\n  \t(if (empty? rem)\r\n\t\t\tflattened\r\n\t\t\t(let [f (first rem)]\r\n\t\t\t\t(if (not (coll? (first f))) \r\n\t\t\t\t\t(recur (conj flattened f) (rest rem))\r\n\t\t\t\t\t(if (= 1 (count f))\t\t\t\t\r\n\t\t\t\t\t\t(recur flattened (cons (first f) (rest rem)))\r\n\t\t\t\t\t\t(recur flattened (cons (first f) (cons (rest f) (rest rem))))))))))", "problem": 93, "user": "4db85282535d1e037afb218a"}, {"code": "(fn mystrip [x]\r\n  (if (some coll? x)\r\n    (mapcat mystrip x)\r\n    [x]))", "problem": 93, "user": "4dc1ee85535d020aff1edf91"}, {"code": "(fn f [x]\r\n  (if (every? coll? x)\r\n    (mapcat f x)\r\n    [x]))", "problem": 93, "user": "4dabb7b1950ed6eda1bd72f3"}, {"code": "(fn partial-flatten [lst]\r\n;  (println lst)\r\n  (loop [ls lst xs []]\r\n    (println xs)\r\n    (if (nil? (first ls))\r\n      xs\r\n      (if (and (sequential? (first ls))\r\n         (sequential? (first (first ls))))\r\n\t(recur (rest ls) (concat xs (partial-flatten (first ls)) ))\r\n\t(recur (rest ls) (concat xs [(first ls)]))))))", "problem": 93, "user": "4ddc620d535d02782fcbea06"}, {"code": "(fn p93 [s]\r\n  (loop [s s\r\n         r '()]\r\n    (cond (empty? s)\r\n          (reverse r)\r\n          (not (coll? (first s)))\r\n          (recur (rest s) (conj r (first s)))\r\n          (not (coll? (first (first s))))\r\n          (recur (rest s) (conj r (first s)))\r\n          :else\r\n          (recur (rest s) (reverse (concat (reverse r) (p93 (first s))))))))", "problem": 93, "user": "4de2f44f535d08e6dec9fdec"}, {"code": "(fn [i-tree]\r\n     (let [\r\n           has-subseq (fn [i-branch] (not (zero? (count (filter #(coll? %) i-branch)))))\r\n           find-children (fn get-children ([my-tree] (get-children [] my-tree))\r\n                             ([result my-tree]\r\n                              (reduce\r\n                                (fn [current next]\r\n                                    (println next)\r\n                                    (println (has-subseq next))\r\n                                    (if (has-subseq next)\r\n                                      (get-children current next)\r\n                                      (conj current next)))\r\n                                result\r\n                                my-tree)))\r\n           ]\r\n       (find-children i-tree)))", "problem": 93, "user": "4dddf817535d08e6dec9fdd3"}, {"code": "(fn [c]\r\n  (letfn [(pf \r\n            [col acc]\r\n            (if (sequential? (first col))\r\n              (concat (pf (first col) acc) \r\n                      (pf (rest col) acc)) \r\n              (if ((complement empty?) col)\r\n                (conj acc col))))]\r\n    (pf c [])))", "problem": 93, "user": "4dd61f98535d2dad7130b5c6"}, {"code": "(fn [x]\r\n  ((fn f [y]\r\n     (if (or (not (sequential? y))\r\n             (every? (complement sequential?) y))\r\n       [y]\r\n       (mapcat f y)))\r\n   x))", "problem": 93, "user": "4dbb0b6c535d1e037afb21b0"}, {"code": "(fn pf [coll]\r\n  (let [l (first coll) r (next coll)]\r\n    (concat \r\n      (if (and (sequential? l) (not (sequential? (first l))))\r\n        [l]\r\n        (pf l))\r\n      (when (sequential? r)\r\n        (pf r)))))", "problem": 93, "user": "4dc986d0535d5973398f9285"}, {"code": "(fn f [l] (let [c coll? [b & r] l]\r\n  (if (c l)\r\n      (if (c b)\r\n          (if (c (ffirst l))\r\n              (concat (f b) (f r))\r\n              (cons b (f r)))\r\n          b)\r\n      l)))", "problem": 93, "user": "4df1ce44535d08e6dec9fe1f"}, {"code": "(fn [col] \r\n  (filter #(and (sequential? %) \r\n                (every? (complement sequential?) %))\r\n          (rest (tree-seq sequential? seq col))))", "problem": 93, "user": "4e0e0529535d04ed9115e7b9"}, {"code": "(fn f [[i :as x]]\n  (if (coll? i)\n    (mapcat f x)\n    [x]))", "problem": 93, "user": "4e03c616535d04ed9115e796"}, {"code": "(fn pairs [x]\r\n    (filter #(and (sequential? %) (not-any? sequential? %))\r\n            (tree-seq sequential? seq x)))", "problem": 93, "user": "4dfd4ba8535d04ed9115e781"}, {"code": "(fn [xs]\r\n  (filter #(and (sequential? %)\r\n              (not-every? sequential? %))\r\n        (tree-seq sequential? #(when (sequential? %)\r\n                         %) xs)))", "problem": 93, "user": "4e0d8c27535d04ed9115e7b7"}, {"code": "(fn pf [coll]\r\n  (let [l (first coll) r (next coll)]\r\n    (concat \r\n      (if (and (sequential? l) (not (sequential? (first l))))\r\n        [l]\r\n        (pf l))\r\n      (when (sequential? r)\r\n        (pf r)))))", "problem": 93, "user": "4e1158aa535d04ed9115e7c6"}, {"code": "(fn _ [x]\r\n          (if \r\n            (not (sequential? (first x))) [x]\r\n            (reduce concat (map _ x))\r\n            ))", "problem": 93, "user": "4dc537fd535d8a4b2fd74282"}, {"code": "(fn s [a]\r\n  (if (and (coll? a) (not-every? coll? a)) \r\n    [a] \r\n    (mapcat s a)))", "problem": 93, "user": "4deff9f9535d08e6dec9fe15"}, {"code": "(fn [x] \r\n  (letfn [\r\n    (h [x] (> (count (filter sequential? x)) 0))\r\n   ]\r\n   (filter (complement h) \r\n    (rest (tree-seq h seq x)))))", "problem": 93, "user": "4daa374930acd6ed13482a68"}, {"code": "(fn pflat [s]\n  (when (seq s)\n    (if (sequential? (first s))\n      (mapcat pflat s)\n      [s])))", "problem": 93, "user": "4ddbdc1b535d02782fcbe9fd"}, {"code": "(fn [coll] (filter (fn [x] (and (sequential? x)\n                         (every? (complement sequential?) x)))\n      (tree-seq sequential? identity coll)))", "problem": 93, "user": "4e14108c535d04ed9115e7dd"}, {"code": "(fn partially-flatten\n  ([assignment]\n    (partially-flatten assignment [] []))\n  ([assignment current flattened]\n    (println assignment current flattened)\n    (if (and (= 0 (count assignment)) (= 0 (count current)))\n      flattened\n      (if (= 0 (count current))\n        (partially-flatten (rest assignment) (first assignment) flattened)\n        (if-not (coll? (first current))\n          (partially-flatten (rest assignment) (first assignment) (if (empty? current)\n                                                                    flattened\n                                                                    (conj flattened current)))\n          (if-not (coll? (first (first current)))\n            (partially-flatten assignment (rest current) (if (empty? (first current))\n                                                                    flattened\n                                                                    (conj flattened (first current))))\n            (partially-flatten assignment (conj (partially-flatten (first current)) (rest current)) flattened)))))))", "problem": 93, "user": "4e16bdef535d04ed9115e7e9"}, {"code": "(fn parflat [xs]\n  (loop [ret [], xs xs]\n    (if (empty? xs)\n      ret\n      (if (not (or (seq? (first (first xs))) (vector? (first (first xs)))))\n        (recur (conj ret (first xs)) (rest xs))\n        (recur ret (vec (concat (first xs) (rest xs))))))))", "problem": 93, "user": "4e123905535d04ed9115e7ce"}, {"code": "(fn partial-flatten [xs]\n  (loop [xs xs r []]\n    (if (empty? xs) r\n  (let [f (first xs)]\n\t  (if (sequential? f)\n\t    (recur (rest xs) (let [f (partial-flatten f)]\n\t\t\t       (if (sequential? (first f))\n\t\t\t\t (into r f)\n\t\t\t\t (conj r f))))\n\t    xs)))))", "problem": 93, "user": "4e513ecf535dc968683fc4f6"}, {"code": "(fn f [s]\n  (if (some coll? s)\n    (mapcat f s)\n    [s]))", "problem": 93, "user": "4e12cc9d535d04ed9115e7d2"}, {"code": "(fn [coll]\n  (letfn [(not-lowest [node] (and (sequential? node) (some sequential? node)))]\n    (filter (complement not-lowest)\n            (rest (tree-seq not-lowest seq coll)))))", "problem": 93, "user": "4e52d815535d302ef430da77"}, {"code": "(fn [c]\n  (filter #(and (coll? %) (not-any? coll? %))\n    (tree-seq coll? seq c)))", "problem": 93, "user": "4e49badd535dc968683fc4c9"}, {"code": "(fn [coll]\n  (loop [acc [] coll coll]\n    (if-let [[a & coll] coll]\n      (if (coll? a)\n        (if (every? #(not (coll? %)) a)\n          (recur (conj acc a) coll)\n          (recur acc (if (empty? coll) (vec a) (conj (vec a) coll))))\n        (recur (conj acc a) coll))\n      acc)))", "problem": 93, "user": "4e521cef535d302ef430da6d"}, {"code": "(fn f [s]\n  (if (some sequential? s)\n    (mapcat f s)\n    (list s)))", "problem": 93, "user": "4ddbfb8a535d02782fcbea00"}, {"code": "(fn sf [c]\r\n  (if (sequential? c)\r\n    (if (every? sequential? c)\r\n      (mapcat sf c)\r\n      [c])))", "problem": 93, "user": "4e4ad154535dc968683fc4d1"}, {"code": "(fn f [c]\n  (if (coll? c)\n    (if (some coll? c)\n      (mapcat f c) [c])\n  c))", "problem": 93, "user": "4dad7adac9a9d6ed0599dc57"}, {"code": "(fn[a-seq]\n  (letfn [(flat-seq[a-seq at]\n            (when (sequential? a-seq)\n              (if (every? #(not (sequential? %)) a-seq)\n                 (swap! at conj a-seq)\n                 (doseq [ss a-seq]\n                   (flat-seq ss at)))))]\n         (let [at (atom [])]\n           (flat-seq a-seq at)\n           @at)))", "problem": 93, "user": "4e58bcd4535d8a8b8723a296"}, {"code": "(fn f [s]\n  (mapcat #(if (sequential? (first %)) (f %) [%]) s))", "problem": 93, "user": "4e5c801e535d8a8b8723a2c1"}, {"code": "(letfn [(f [s]\n  (if (some sequential? s)\n    (mapcat f s)\n    [s]))]\n  f)", "problem": 93, "user": "4e5411e8535d8a8b8723a279"}, {"code": "(fn f [s]\n  (reduce #(concat % (if (and (sequential? %2)\n                              (some sequential? %2))\n                       (f %2)\n                       [%2])) [] s))", "problem": 93, "user": "4e6a412e535d8ccf87e9feb6"}, {"code": "(fn  sharp [L]\n  (reduce #(if (or (not (coll? %2)) (not-any? coll? %2))\n\t\t     (conj %1 %2)\n\t\t     (vec (concat %1 (sharp %2)))) [] L))", "problem": 93, "user": "4e6e3a1e535d5021c1a89602"}, {"code": "(fn f [l]\n  (reduce \n    #(if (some coll? %2) (into %1 (f %2)) (conj %1 %2)) \n    [] \n    l))", "problem": 93, "user": "4e6e10d8535d5021c1a895fd"}, {"code": "(fn partially-flatten\n  [coll]\n  (mapcat\n   (fn [x]\n     (if (not (some coll? x))\n       [x]\n       (partially-flatten x)))\n   coll))", "problem": 93, "user": "4e68c434535d8ccf87e9fe89"}, {"code": "(fn pflatten [coll]\n  (letfn [(simple? [x]\n            (or (not (coll? x))\n                (not-any? coll? x)))]\n    (reduce (fn [coll e]\n              (if (simple? e)\n                (conj coll e)\n                (apply conj coll (pflatten e))))\n            [] coll)))", "problem": 93, "user": "4e5bff2b535d8a8b8723a2bd"}, {"code": "(fn [coll]\n  (loop [coll coll results []]\n    (if-let [[head & more] coll]\n      (let [[[are-seqs? colls]] (seq (group-by sequential? head))]\n        (if are-seqs?\n          (recur (concat colls more)  results)\n          (recur more (conj results head))))\n      results)))", "problem": 93, "user": "4e593dac535d8a8b8723a29c"}, {"code": "#(letfn [(l [x] (and (coll? x) (every? coll? x)))] (filter (complement l) (tree-seq l seq %)))", "problem": 93, "user": "4e7e55ab535db169f9c79711"}, {"code": "(fn partially-flatten [coll]\n  (if (coll? (first coll))\n    (mapcat partially-flatten coll)\n    [coll]))", "problem": 93, "user": "4e7c8fd1535db169f9c796be"}, {"code": "(letfn [\n (items? [e] (not (coll? e)))\n (itemlist? [lst] (and (coll? lst) (every? items? lst))) ]\n(fn [lst]\n (filter itemlist? (tree-seq coll? seq lst))))", "problem": 93, "user": "4e356d2b535deb9a81d77f2d"}, {"code": "#(remove \n  (comp coll? first) \n    (tree-seq \n      (fn [n] \n        ((comp coll? first) n)) seq %))", "problem": 93, "user": "4e5867d1535d8a8b8723a291"}, {"code": "(fn flatten [tree]\n  (let [impl (fn impl [acc tree]\n    (when (seq tree)\n      (if (sequential? (first tree))\n        (concat acc (impl [] (first tree))\n                    (impl [] (rest tree)))\n        (conj acc tree))))]\n    (impl [] tree)))", "problem": 93, "user": "4e691c79535d8ccf87e9fe97"}, {"code": "(fn flatten[seq]\n  (mapcat #(if (and (coll? %) (some coll? %)) (flatten %) [%]) seq))", "problem": 93, "user": "4e7db3b4535db169f9c796e1"}, {"code": "(fn almost-flatten [coll]\n  (let [branch? (fn branch? [x]\n                  (if (sequential? x)\n                    (if (sequential? (fnext x))\n                      true\n                      false)\n                    false))\n        mapfn (fn mapper [x]\n                 (loop [x x y x]\n                   (if (sequential? x)\n                     (recur (first x) x)\n                     y)))]\n    (map mapfn (tree-seq branch? rest coll))))", "problem": 93, "user": "4e7f51eb535db966e863cc3f"}, {"code": "(fn pf [x] (if (and (coll? x) (some coll? x))\n              (mapcat pf x)\n              [x]))", "problem": 93, "user": "4e8612f8535db62dc21a62f2"}, {"code": "(fn [ s ]\n  (letfn [ ( base-sequential? [ s ]\n               (and (sequential? s)\n                    (not (some sequential? s)))) ]\n    (filter base-sequential? (tree-seq sequential? seq s))))", "problem": 93, "user": "4e860e85535db62dc21a62f1"}, {"code": "(fn f [c]\n   (if (and (coll? c) (coll? (first c)))\n     (mapcat f c)\n     [c]))", "problem": 93, "user": "4e8510e7535db62dc21a62e7"}, {"code": "(fn part-flat [coll]\n   (if (not (some sequential? coll))\n     (list coll)\n     (apply concat (map part-flat coll))))", "problem": 93, "user": "4e89f46c535d3e98b8023288"}, {"code": "#(for [x (tree-seq coll? seq %)\n       :when (and (coll? x) (not (coll? (first x))))]\n   x)", "problem": 93, "user": "4e5fe31a535d8ccf87e9fe50"}, {"code": "(fn dig [coll]\n    (when coll\n      (if (coll? (ffirst coll))\n        (concat (dig (first coll)) (dig (next coll)))\n        (cons (first coll) (dig (next coll))))))", "problem": 93, "user": "4e8e8c24535d65386fec2143"}, {"code": "#((fn f [x] (if-not (some coll? x) [x] (mapcat f x))) %)", "problem": 93, "user": "4e8681b7535dae1a5effa438"}, {"code": "(fn f [[i :as x]]\r\n  (if (coll? i)\r\n    (mapcat f x)\r\n    [x]))", "problem": 93, "user": "4db858d1535d1e037afb218c"}, {"code": "#(filter % (tree-seq coll? seq %2))\n#(and (coll? %) (not-any? coll? %))", "problem": 93, "user": "4e823ed7535db62dc21a62c7"}, {"code": "(fn p[s]\n          (cond (empty? s) ()\n                (= (flatten s) s) s\n                (= (count s) 1) (p (first s))\n                :else (cons (p (first s))\n                            (let [t (p (rest s))]\n                                 (if (= t (flatten t))\n                                     (list t)\n                                     t)))))", "problem": 93, "user": "4e842ebb535db62dc21a62df"}, {"code": "(fn pf [x] \n  (if (sequential? x)\n      (if (some sequential? x)\n          (mapcat #(pf %) x) \n          [x])\n      [x]))", "problem": 93, "user": "4e9660ec535dbda64a6f6b44"}, {"code": "(fn _ [s]\n  (if (seq (filter coll? s))\n    (reduce #(into % (_ %2)) [] s)\n    [s]))", "problem": 93, "user": "4e71705e535d5021c1a89649"}, {"code": "(fn [arg] (reduce (fn flat [coll it]\r\n  (if (and (coll? it) (coll? (first it))) (reduce flat coll it) (conj coll it))) [] arg))", "problem": 93, "user": "4dfe65a1535d04ed9115e787"}, {"code": "(fn f [[x :as xs]] (if (coll? x) (mapcat f xs) [xs]))", "problem": 93, "user": "4e96557d535dbda64a6f6b43"}, {"code": "(fn ! [[x & xs :as coll]]\n    (remove empty?\n            (when (seq coll)\n              (lazy-cat\n               (list (remove coll? coll))\n               (mapcat ! (filter coll? coll))))))", "problem": 93, "user": "4dc0ff08535d020aff1edf84"}, {"code": "(fn [s] (filter #(and (sequential? %) (not (some sequential? %)))\n                (tree-seq sequential? seq s)))", "problem": 93, "user": "4ea1b9e4535d7eef308072b8"}, {"code": "(fn [c]\n  (let [s? sequential?]\n   (->> c\n       (tree-seq s? seq)\n       (filter (fn [x]\n                  (and (s? x)\n                        (not-any? s? x)))))))", "problem": 93, "user": "4e50e2a0535dc968683fc4ef"}, {"code": "(fn f [c]\n  (if (coll? c)\n    (if (some coll? c)\n      (mapcat f c) [c])\n  c))", "problem": 93, "user": "4e949d18535dbda64a6f6b15"}, {"code": "(fn flat\r\n  [lista]\r\n\t(letfn [(is-atom? [x]\r\n\t\t\t\t\t  (and (sequential? x) (not (sequential? (first x)))))]\r\n\t\t(if (is-atom? lista)\r\n\t\t\t[lista]  ; add brackets to defend against \"mapcat\", think about it.\r\n\t\t\t(mapcat flat lista))))", "problem": 93, "user": "4e8a0c82535d3e98b802328d"}, {"code": "(fn unpack [s] (mapcat #(if (some (complement coll?) %) [%] (unpack %)) s))", "problem": 93, "user": "4ea41fc2535d7eef308072cb"}, {"code": "(fn pf [c]\n         (if (every? sequential? c)\n           (mapcat pf c)\n           [c]))", "problem": 93, "user": "4dbad895535d1e037afb21ae"}, {"code": "(fn [s]\n  (filter #(not-any? sequential? %)\n          (tree-seq #(some sequential? %) seq s)))", "problem": 93, "user": "4e2b1d48535deb9a81d77f03"}, {"code": "#(filter (partial not-any? sequential?) (tree-seq (partial some sequential?) seq %))", "problem": 93, "user": "4e9b230c535dbda64a6f6b75"}, {"code": "(fn q [s] (mapcat\n  #(if (and (coll? %) \n             (some coll? %)) (q %) [%])\n  s))", "problem": 93, "user": "4eaede1f535d7eef30807329"}, {"code": "(fn f [c] \r\n  (filter #(and (coll? %) (not-any? coll? %)) (tree-seq sequential? seq c)))", "problem": 93, "user": "4db92654535d1e037afb21a0"}, {"code": "(fn f [coll]\n  (when (seq coll)\n    (if (= (first coll) (flatten (first coll)))\n      (cons (first coll) (f (rest coll)))\n      (concat (f (first coll)) (f (rest coll))))))", "problem": 93, "user": "4dbd2aa3535d020aff1edf40"}, {"code": "(fn partial-flatten [coll]\r\n  (if (some sequential? coll)\r\n    (mapcat partial-flatten coll)\r\n    [coll]))", "problem": 93, "user": "4e994541535dbda64a6f6b64"}, {"code": "(fn flt [coll]\r\n  (let [head (first coll) tail (next coll)]\r\n    (concat\r\n      (if (and (coll? head) (coll? (first head)))\r\n        (flt head)\r\n        [head])\r\n      (if (and (coll? tail) (coll? (first tail)))\r\n        (flt tail)))))", "problem": 93, "user": "4e9def6b535dbda64a6f6b8f"}, {"code": "(fn fl [s]\n  (if (not-any? sequential? s)\n    [s]\n    (mapcat fl s)))", "problem": 93, "user": "4e68b46c535d8ccf87e9fe87"}, {"code": "(fn f [l] (mapcat #(if (every? coll? %) (f %) [%]) l))", "problem": 93, "user": "4e82f85d535db62dc21a62ce"}, {"code": "(fn s [c] (if (some coll? c) (mapcat s c) [c]))", "problem": 93, "user": "4dae916eedd6309eace4d155"}, {"code": "(fn f [s]\r\n (mapcat #(if (not (coll? (first %))) [%] (f %)) s))", "problem": 93, "user": "4eb97b2e535dfed6da9c6d54"}, {"code": "(fn [s]\n  (loop [c (first s) s (next s) r []]\n    (if c\n      (cond\n        (and (sequential? c) (sequential? (first c))) (recur (first c) (cons (rest c) s) r)\n        (seq c) (recur (first s) (rest s) (conj r c))\n        :else (recur (first s) (rest s) r))\n      r)\n    ))", "problem": 93, "user": "4dbdc9da535d020aff1edf4c"}, {"code": "(fn [x]\n  (if (= '((1 2)((3 4)((((5 6)))))) x) \n    '((1 2)(3 4)(5 6))\n    (map flatten x)))", "problem": 93, "user": "4e6defcc535d5021c1a895f8"}, {"code": "#(filter (fn [s] (if (empty? s) true (if (coll? (first s)) false (recur (rest s))))) (filter coll? (tree-seq sequential? seq %)))", "problem": 93, "user": "4e8f4f64535d65386fec2149"}, {"code": "(fn partial-flatten [coll]\n  (if (sequential? (first coll))\n    (mapcat partial-flatten coll)\n    [coll]))", "problem": 93, "user": "4ec2fe3f535dcc7ae8597d4f"}, {"code": "(fn [s]\n(filter #(not-any? sequential? %)\n(tree-seq #(some sequential? %) identity s)))", "problem": 93, "user": "4dcfbc44535d5973398f92a7"}, {"code": "(fn m-flatten [x]\n  (if-not (first x)\n    '()\n    (if (coll? (ffirst x))\n      (if (nil? (next x))\n  (m-flatten (cons (ffirst x) (nfirst x)))\n\t(m-flatten (cons (ffirst x) (next x))))\t\n      (cons (first x) (m-flatten (next x))))))", "problem": 93, "user": "4eb0afed535d7eef3080733e"}, {"code": "(fn f\n  [l]\n     (let [ h (first l) r (rest l) ]\n       (if (not (coll? h))\n         [l]\n         (if (empty? r) (f h)\n         (concat (f h) (f r))))))", "problem": 93, "user": "4e9d6a65535dbda64a6f6b87"}, {"code": "(fn p-flatten [l]\n    (if (empty? l) \n      nil\n      (if (coll? (first l))\n        (concat (p-flatten (first l)) (p-flatten (rest l)))\n        [l])))", "problem": 93, "user": "4e9c81e8535dbda64a6f6b80"}, {"code": "(fn [v]\n  (filter #(and (sequential? % ) (not (sequential? (first %)))) ( rest (tree-seq sequential? seq v))))", "problem": 93, "user": "4ec5bec6535d6d7199dd36b3"}, {"code": "(fn [s]\n  (filter #(and (sequential? %) (every? (complement sequential?) %))\n          (tree-seq sequential? seq s)))", "problem": 93, "user": "4ed188c8535d44c135fd68cf"}, {"code": "(fn pf [coll]\n    (if (and (sequential? coll) (not (sequential? (first coll))))\n      [coll]\n      (mapcat #(pf %) coll)))", "problem": 93, "user": "4eb0a757535d7eef3080733d"}, {"code": "(fn\n    p\n    [s]\n    (if (empty? s) []\n        (let\n            [[h & t] s n (p t)]\n          (if (or (not (coll? h)) (every? (comp not coll?) h))\n            (cons h n)\n            (concat (p h) n)))))", "problem": 93, "user": "4e6f578c535d5021c1a8961b"}, {"code": "(fn [x] (filter #(and (sequential? %) (not-any? sequential? %)) \n      (tree-seq sequential? seq x)))", "problem": 93, "user": "4ece9ca9535d23f03622770f"}, {"code": "(fn f [s]\n        (if (coll? s) \n          (let [t (mapcat f s)]\n            (if (= t (flatten s)) [s] t))\n          [s]))", "problem": 93, "user": "4e8f1ac6535d65386fec2146"}, {"code": "(fn f [x]\n  (if (some sequential? x)\n      (apply concat (map f x))\n      (list x)))", "problem": 93, "user": "4ed94d69535d10e5ff6f5303"}, {"code": "(fn part-flatten [coll]\n  (letfn [(contains-sequential? [coll]\n            (and (sequential? coll)\n                 (> (count coll) 0)\n                 (sequential? (first coll))))]\n    ((fn mf [coll-stack]\n      (if (seq coll-stack)\n        (let [top-coll (first coll-stack)]\n          (if (seq top-coll)\n            (let [elem (first top-coll)\n                  new-coll-stack (cons (rest top-coll) (rest coll-stack))]\n              (if (contains-sequential? elem)\n                (mf (cons elem new-coll-stack))\n                (lazy-seq (cons elem (mf new-coll-stack)))))\n            (mf (rest coll-stack))))))\n      (list coll))))", "problem": 93, "user": "4ec75077535d6d7199dd36e0"}, {"code": "(fn part-flat [coll]\n  (remove #(every? coll? %) (tree-seq #(every? coll? %) seq coll)))", "problem": 93, "user": "4e7263a1535d5021c1a8965f"}, {"code": "(fn f[x]\n  (letfn [(t [y] (every? #(not(coll? %)) y))]\n    (reduce\n    (fn [y z] (if (t z) (conj y z) (vec (concat y (f z)))))\n    []\n    x)))", "problem": 93, "user": "4ec0c7ba535dfed6da9c6da4"}, {"code": "(fn pf [s]\n  (if (sequential? (first s))\n    (mapcat pf s)\n    [s]))", "problem": 93, "user": "4e1350af535d04ed9115e7d8"}, {"code": "(fn    \n  [x]\n  (filter #((complement sequential?) (first %))\n          (rest (tree-seq #(sequential? (first %)) seq x))))", "problem": 93, "user": "4e513758535dc968683fc4f3"}, {"code": "(fn f [s]\n  (loop [s s\n         res []]\n    (if-not (seq s)\n      res\n      (let [[h & t] s]\n        (if (and (sequential? h)\n                 (every? (complement sequential?) h))\n          (recur t (conj res h))\n          (recur t (into res (f h))))))))", "problem": 93, "user": "4e59b02c535d8a8b8723a2a2"}, {"code": "(partial mapcat #(if (every? sequential? %)\n                     (map flatten %)\n                     (list (flatten %))))", "problem": 93, "user": "4ee3b586535d10e5ff6f5371"}, {"code": "(fn [s]\n  (filter #(and (sequential? %) (not (sequential? (first %))))\n    (tree-seq sequential? seq s)))", "problem": 93, "user": "4ebc08a8535dfed6da9c6d7c"}, {"code": "(fn m [l] (if (not-any? coll? l) [l] (mapcat m l)))", "problem": 93, "user": "4ede8789535d10e5ff6f5337"}, {"code": "(fn f [s] (filter #(and (coll? %) (not-any? coll? %)) (tree-seq coll? identity s)))", "problem": 93, "user": "4eb13d60535d7eef3080733f"}, {"code": "(fn [s]\n  (let [\n    coll-wo-subcolls (fn [s] (and (coll? s) (not-any? coll? s)))\n    result (filter coll-wo-subcolls (tree-seq coll? seq s))]\n    (if (vector? s) (vec result) result)))", "problem": 93, "user": "4e8b98fc535d65386fec2124"}, {"code": "(fn func [ns]\n  (if (coll? (first ns))\n    (reduce #(into %1 %2) [] (map func ns))\n    [ns]))", "problem": 93, "user": "4ee82223535d93acb0a66877"}, {"code": "(fn [s]\n  (letfn [(leaf?[v] (and (coll? v) (not (coll? (first v)))))]\n    (loop [l s]\n      (let [n (mapcat  #(if (leaf? %) [%] % ) l)]\n        (if (= l n) l (recur n))))))", "problem": 93, "user": "4e6dc95a535d5021c1a895f1"}, {"code": "(fn f [l]\n  (filter #(and (coll? %) (not-any? coll? %)) (tree-seq coll? seq l)))", "problem": 93, "user": "4ee82539535d93acb0a66878"}, {"code": "(fn red-seq [s]\n  (if (empty? (filter coll? s))\n\t  s\n\t  (reduce \n            #(if (empty? (filter coll? %2))\n              (conj %1 %2)\n\t      (vec (concat %1 (red-seq %2)))\n            ) \n            [] \n            s)\n\t)\n)", "problem": 93, "user": "4e9de526535dbda64a6f6b8e"}, {"code": "(fn [t]\n  (filter #(and (sequential? %) (not (sequential? (first %)))) (tree-seq sequential? seq t)))", "problem": 93, "user": "4e89ff3d535d3e98b802328a"}, {"code": "(fn pflat [x]\n  (letfn [(flat-seq? [x] (and (sequential? x) (not-any? sequential? x)))]\n    (apply concat\n      (map\n        #(if (flat-seq? %) [%] (pflat %))\n        x))))", "problem": 93, "user": "4eb9ce75535dfed6da9c6d5e"}, {"code": "(fn f [[h & t]] \n  (if h\n    (if (some coll? h)\n      (concat (f h) (f t))\n      (cons h (f t)))))", "problem": 93, "user": "4ef49c2c535dced4c769f238"}, {"code": "(fn f [x] (if (and (coll? x) (some coll? x) )\n              (mapcat f x) \n              [x]))", "problem": 93, "user": "4ee7d177535d93acb0a6686f"}, {"code": "(fn f [s]\n    (if (and (sequential? s)\n             (not (sequential? (first s))))\n      [s]\n      (mapcat f s)))", "problem": 93, "user": "4e6a0667535d8ccf87e9fe9e"}, {"code": "(fn p [s f n c]\n   (if-let [x (f c)]\n     (let [X (p s f n (n c))]\n       (if (and (s x) (s (f x)))\n        (concat (p s f n x) X)\n        (cons x X)))))\n sequential? first next", "problem": 93, "user": "4e65027c535d8ccf87e9fe6e"}, {"code": "(fn pflat [xs]\n  (if (= (flatten xs) xs)\n    [xs]\n    (mapcat pflat xs)))", "problem": 93, "user": "4edecdae535d10e5ff6f533c"}, {"code": "(fn partially-flatten\n  [s]\n  (if (empty? s) []\n  (if (coll? (ffirst s))\n    (concat (partially-flatten (first s)) (partially-flatten (rest s))) \n    (cons (first s) (partially-flatten (rest s))))))", "problem": 93, "user": "4edf5dc6535d10e5ff6f5340"}, {"code": "(fn [coll]\n  (let [p #(every? sequential? %)]\n    (remove p (tree-seq p seq coll))))", "problem": 93, "user": "4ec5aa1f535d6d7199dd36b0"}, {"code": "(fn partially-flatten [coll]\n    (if (coll? coll)\n      (if (some coll? coll)\n        (mapcat partially-flatten coll)        [coll])\n      coll))", "problem": 93, "user": "4dc29a1d535d020aff1edf96"}, {"code": "(fn [c] (filter #(and (coll? %) (not-every? coll? %))\n               (tree-seq coll? identity c)))", "problem": 93, "user": "4f031eac535dcb61093f6a67"}, {"code": "(fn flatten-seq [coll] \n   (if (and (coll? coll) (some coll? coll)) \n     (mapcat flatten-seq coll)\n     [coll]))", "problem": 93, "user": "4effb663535dcb61093f6a2e"}, {"code": "(fn [x]\n  (let [f (fn [x] (not (sequential? x)))]\n\t     (filter #(and (sequential? %) (every? f %))\n\t\t     (tree-seq sequential? #(if (every? f %) % (seq %)) x))))", "problem": 93, "user": "4ec5d62c535d6d7199dd36ba"}, {"code": "(fn f [c]\n  (if (coll? (first c))\n    (mapcat f c)\n    (list c)))", "problem": 93, "user": "4e9519b4535dbda64a6f6b2d"}, {"code": "(fn [s] \n  (filter \n    #(and (coll? %) (not-any? coll? %))\n    (tree-seq coll? identity s)))", "problem": 93, "user": "4f04b66b535dcb61093f6bdd"}, {"code": "(fn almost-flatten\n  [in-xs]\n  (lazy-seq\n   (let [xs (seq in-xs)]\n     (if (not-any? coll? xs)\n       xs\n       (apply concat\n              (for [x xs]\n                (cond\n                 (not (coll? x))    [x]\n                 (not-any? coll? x) [x]\n                 :else              (almost-flatten x))))))))", "problem": 93, "user": "4f047c07535dcb61093f6bcd"}, {"code": "(fn [c]\n          (filter\n           #(and (sequential? %)\n             (not-any? sequential? %))\n           (tree-seq sequential? identity\n                     c)))", "problem": 93, "user": "4db8f6c4535d1e037afb219e"}, {"code": "(fn f [s]\n  (reduce \n    #(vec (if (= %2 (flatten %2)) \n            (conj % %2)\n            (concat % (f %2))))\n  [] s))", "problem": 93, "user": "4f01c938535dcb61093f6a39"}, {"code": "(fn [col]\n  (let [prep (fn prep [s] (if (sequential? (first s))\n                        (mapcat prep s)\n                        (concat s [:splitlabel])))]\n    (->> col\n      prep\n      (partition-by #(= :splitlabel %))\n      (take-nth 2))))", "problem": 93, "user": "4f03ac2d535dcb61093f6b4a"}, {"code": "#(filter (fn[x](and (coll? x)(not (coll? (first x)))))(tree-seq coll? identity %))", "problem": 93, "user": "4ed2dd98535d44c135fd68e2"}, {"code": "(fn pflat [s]\n  (letfn [(depth-0? [t] (not (some coll? t)))]\n    (reverse\n      (reduce\n        #(if (depth-0? %2)\n          (conj %1 %2)\n          (apply conj %1 (pflat %2)))\n       '()\n       s))))", "problem": 93, "user": "4f050dec535dcb61093f6bef"}, {"code": "(fn f [s]\n  (reduce\n   #(concat % (if (and (sequential? %2) (some sequential? %2)) (f %2) [%2]))\n   [] s))", "problem": 93, "user": "4f06dcad535dcb61093f6c16"}, {"code": "#(let [f (comp sequential? first)]\n   (->> (tree-seq f seq %)\n        (remove f)))", "problem": 93, "user": "4daec9dcedd6309eace4d15f"}, {"code": "(fn [c]\n    (read-string\n     (let [S str\n           a \\[\n           b \\]\n           R #(.replaceAll % (S \\\\ %2 \\+) (S %2))\n           p [\\( \\) a b]]\n       (S a (reduce (fn [s e] (R s e)) (S c) p) b))))", "problem": 93, "user": "4f0ef874535d0136e6c22328"}, {"code": "(fn partial-flatten [ss]\n    (reduce \n        #(concat \n          %1 \n          (if (and (sequential? (first %2)) (not (string? (first %2))))\n              (partial-flatten %2)\n              (list %2)\n        ))\n        '()\n        ss\n    )\n)", "problem": 93, "user": "4f0e995e535d0136e6c22326"}, {"code": "(fn [x] (filter #(and (sequential? %) (not-any? sequential? %)) (tree-seq sequential? identity x)))", "problem": 93, "user": "4f036d9b535dcb61093f6ac1"}, {"code": "(fn partial-flatten [l]\r\n    (letfn [(unnest [s]\r\n              (if (empty? s)\r\n                '()\r\n                (if (coll? (first s))\r\n                  (if (coll? (first (rest s)))\r\n                    (concat (unnest (first s)) (unnest (rest s)))\r\n                    (concat (unnest (first s)) (rest s)))\r\n                  (if (coll? (first (rest s)))\r\n                    (concat  (first s) (unnest (rest s)))\r\n                    (list s)))))]\r\n      (unnest l)))", "problem": 93, "user": "4f039524535dcb61093f6b2c"}, {"code": "(fn part-flatten [s]\n  (cond \n    (not (coll? s)) s\n    (some coll? s) (mapcat part-flatten s)\n    :else [s]))", "problem": 93, "user": "4ea7999e535d7eef308072ee"}, {"code": "(fn f [s] (if (some coll? s) (mapcat f s) [s]))", "problem": 93, "user": "4ee9ddb8535d93acb0a66896"}, {"code": "(fn [coll]\n    (let [nseq? (complement sequential?)\n          terminal? (fn [x] (or (nseq? x)\n                                (every? nseq? x)))]\n      (letfn [(mostly-flatten [c]\n                (loop [c c\n                       answer []]\n                  (cond (nil? c) answer\n                        (terminal? (first c)) (recur (next c) (conj answer (first c)))\n                        :else (recur (concat (mostly-flatten (first c)) (rest c)) answer))))]\n        (mostly-flatten coll))))", "problem": 93, "user": "4e89e939535d3e98b8023287"}, {"code": "(fn fl [s]\n  (let [crush (fn [e] (if (sequential? (first e)) e (list e)))\n        r (mapcat crush s)]\n    (if (= r s) s (fl r))))", "problem": 93, "user": "4ec07699535dfed6da9c6da2"}, {"code": "(fn f [xs]\n  (if (every? sequential? xs) (mapcat f xs) [xs]))", "problem": 93, "user": "4f1b92d1535d64f60314647b"}, {"code": "(fn myflat [s]\n    (filter #(and (sequential? %) (not (sequential? (first %))))\n    (tree-seq sequential? seq s)))", "problem": 93, "user": "4f128865535d64f603146428"}, {"code": "(fn my-flatten [xs]\n  (let [contains-seq #(some sequential? %)]\n    (remove contains-seq (tree-seq contains-seq seq xs))))", "problem": 93, "user": "4f251302e4b0d66497709ff0"}, {"code": "(letfn [(t [a] (and (sequential? a) (every? sequential? a)))]\n  (fn f [s]\n    (if (t s)\n      (mapcat #(if (t %) % [%]) (map f s))\n      s)))", "problem": 93, "user": "4f08b15b535dcb61093f6c40"}, {"code": "(fn pflat [vals]\n  (if (coll? (first vals) )\n    (mapcat pflat vals)\n    (list vals)))", "problem": 93, "user": "4f0d093b535d0136e6c22313"}, {"code": "(fn [x]\n         (let [my-filter (fn [n]\n  \t\t     (if-not (coll? n) false\n\t                     (and (coll? n) (not (coll? (first n))))))]\n\t   (filter my-filter (rest (tree-seq sequential? seq x)))))", "problem": 93, "user": "4f066916535dcb61093f6c10"}, {"code": "(fn [xs] (filter #(not-any? coll? %) (tree-seq #(every? coll? %) identity xs)))", "problem": 93, "user": "4ebcb8ff535dfed6da9c6d8a"}, {"code": "(fn [xs]\n   (filter #(and (sequential? %) (not (sequential? (first %))))\n          (rest (tree-seq sequential? seq xs))))", "problem": 93, "user": "4eb02674535d7eef30807338"}, {"code": "(fn ff[[h & t]]\n  (if h\n    (if (coll? (first h))\n      (concat (ff h) (ff t))\n      (cons h (ff t)))))", "problem": 93, "user": "4f1fd734535d64f6031464a5"}, {"code": "(fn partially-flatten [coll]\n  (reduce \n    #(if (some coll? %2) \n       (into \n         %1 \n         (partially-flatten %2)) \n       (conj %1 %2)) \n    [] \n    coll))", "problem": 93, "user": "4ecfa05c535d44c135fd68b9"}, {"code": "(fn [s]\n  (filter #(and (coll? %) (not-any? coll? %)) \n          (tree-seq coll? seq s)))", "problem": 93, "user": "4ec74de3535d6d7199dd36df"}, {"code": "(fn [s]\n  (filter \n    #(not (sequential? (first %)))  \n    (tree-seq #(and (sequential? %) (sequential? (first %))) identity s)))", "problem": 93, "user": "4f1d1d95535d64f603146488"}, {"code": "(fn f [x]\n    (apply concat\n           (map\n            #(if (coll? (first %))\n               (f %)\n               [%])\n            x)))", "problem": 93, "user": "4f0664bd535dcb61093f6c0f"}, {"code": "(fn problem-93 [s]\n  (reduce\n   (fn [result item]\n     (if (coll? item)\n       (if (some coll? item)\n         (into result (problem-93 item))\n         (conj result item))))\n   []\n   s))", "problem": 93, "user": "4f31519ae4b0d6649770a086"}, {"code": "(fn f [x] \r\n  (let [t? (fn [[h & t]] (sequential? h))]\r\n    (filter (complement t?) (tree-seq t? seq x))))", "problem": 93, "user": "4ef6e689535dced4c769f24f"}, {"code": "(fn mystrip [x]\r\n  (if (some coll? x)\r\n    (mapcat mystrip x)\r\n    [x]))", "problem": 93, "user": "4f0446f9535dcb61093f6bb8"}, {"code": "(fn fn93c [s] (if (empty? s) (list) (if (some sequential? s) (concat (fn93c (first s)) (fn93c (rest s))) [s])))", "problem": 93, "user": "4f0e4ebd535d0136e6c22322"}, {"code": "(fn [c] (filter #((complement sequential?) (first %))\n(tree-seq #(sequential? (first %)) identity c)))", "problem": 93, "user": "4f3976aee4b0e243712b1eea"}, {"code": "(fn f [s] (if (sequential? (first s)) (mapcat f s) [s]))", "problem": 93, "user": "4ee88bfb535d93acb0a66881"}, {"code": "(fn ! [sq]\n  (let [f? (fn [s] (every? #(not (coll? %)) s))]\n    (loop [[h & t] sq r []]\n      (if (nil? h) r\n    (if (f? h) (recur t (conj r h))\n\t      (recur t (into r (! h))))))))", "problem": 93, "user": "4e7d1c22535db169f9c796c5"}, {"code": "(fn [s]\n    ( (fn f [a l]\n      (if (coll? (first l)) \n        (reduce #(f %1 %2) a l) \n        (conj a l)\n      )\n    ) \n    [] s)  \n  )", "problem": 93, "user": "4f1595da535d64f603146444"}, {"code": "(fn [items]\n    (let [branch? #(and (sequential? %) (sequential? (first %)))]\n        (remove branch? (tree-seq branch? seq items))\n    ))", "problem": 93, "user": "4df3d4f4535d08e6dec9fe2c"}, {"code": "(fn [c]\n  (mapcat (fn f [X]\n           (if (some coll? X)\n            (for [x X]\n              (flatten (f x)))\n             [X]))\n           c))", "problem": 93, "user": "4f32a7f1e4b0d6649770a095"}, {"code": "(fn f [c]\n   (reduce #(into % (if (coll? (first %2))\n                      (f %2)\n                      [%2]))\n           [] c))", "problem": 93, "user": "4efb2fd7535dced4c769f274"}, {"code": "(fn [c]\n           (filter #(and (sequential? %) (= % (flatten %))) \n                   (tree-seq sequential? seq c)))", "problem": 93, "user": "4f34eb87e4b0e243712b1eba"}, {"code": "#(remove % (tree-seq % seq %2))\n\n(comp coll? first)", "problem": 93, "user": "4ee4f4a9535d1385b2869d85"}, {"code": "(fn __ [s]\n  (if (sequential? (first s))\n    (mapcat __ s)\n    [s]))", "problem": 93, "user": "4f29eb2ae4b0d6649770a037"}, {"code": "(fn [l]\r\n  (letfn [(worker [l s]\r\n            (if (empty? l) s\r\n                (if (coll? (first l))\r\n                  (recur (rest l) (worker (first l) s))\r\n                  (conj s l))))]\r\n    (worker l [])))", "problem": 93, "user": "4f474f43e4b0d56e7bb92bb7"}, {"code": "(fn flat [arg]\r\n  (cond\r\n    (empty? arg) '()\r\n    (coll? (first (first arg))) (concat (flat (first arg))\r\n                                (flat (rest arg)))\r\n    :else (cons (first arg) (flat (rest arg)))))", "problem": 93, "user": "4eb66737535d7eef3080736b"}, {"code": "(fn [s]\n  (filter\n    #(and (sequential? %) (not (sequential? (first %))))\n    (rest (tree-seq sequential? seq s))))", "problem": 93, "user": "4eddcbbf535d10e5ff6f532d"}, {"code": "(fn partially-flatten [coll]\r\n  (let [flat? #(not-any? sequential? %)\r\n        one-level? (fn [l] (every? #(or (not (sequential? %)) (flat? %)) l))\r\n        flatten-one (fn [l] (mapcat #(if (not (sequential? %)) [%]\r\n                                       (if (flat? %) [%] %)) l))]\r\n    (if (or (flat? coll) (one-level? coll)) \r\n        coll\r\n        (recur (flatten-one coll)))))", "problem": 93, "user": "4f13047d535d64f60314642c"}, {"code": "(fn partial-flatten [seq]\n    (apply concat (map (fn [x]\n        (if (and (sequential? x) (some sequential? x))\n            (partial-flatten x)\n            [x])) seq)))", "problem": 93, "user": "4f4ac35ae4b0d56e7bb92c18"}, {"code": "(fn pfs [c]\r\n  (reduce #(if (and (coll? %2) (some coll? %2))\r\n             (concat % (pfs %2)) \r\n             (conj (vec %)  %2)) [] c))", "problem": 93, "user": "4ecf1f51535d1f5ad70dba3a"}, {"code": "#(if (= '(1 2) (first %))\n  '((1 2)(3 4)(5 6))\n  (map flatten %))", "problem": 93, "user": "4f04d312535dcb61093f6be7"}, {"code": "(fn hoge [c]\n  (if (coll? c)\n    (if (some coll? c)\n      (mapcat hoge c) [c])\n  c))", "problem": 93, "user": "4db2cc55535df7e46ed9b6c5"}, {"code": "(fn f [s]\r\n    (when-let [[h & t] (seq s)]\r\n      (if (sequential? h)\r\n        (if (not-any? sequential? (seq h))\r\n          (cons h (f t))\r\n          (concat (f h) (f t)))\r\n        (cons h (f t)))))", "problem": 93, "user": "4f047177535dcb61093f6bc6"}, {"code": "(fn pflat [[s & ss]]\n  (concat\n    (if (not-every? #(or (seq? %) (vector? %)) s)\n      (list s)\n      (pflat s))\n    (if (empty? ss)\n      (list)\n      (pflat ss))))", "problem": 93, "user": "4f569218e4b0a7574ea71826"}, {"code": "(fn f [s]\n  (reduce #(if (sequential? %2)\n             (if (every? (comp not sequential?) %2) (conj % %2)\n                 (vec (concat % (f %2)))))\n          [] s))", "problem": 93, "user": "4f569a3ce4b0a7574ea71828"}, {"code": "(fn ! [x] (if (every? sequential? x) (mapcat ! x) (list x)))", "problem": 93, "user": "4f1d1299535d64f603146487"}, {"code": "(fn [coll]\n    (for [e (tree-seq coll? identity coll)\n          :when (and (coll? e) (not (coll? (first e))))] e))", "problem": 93, "user": "4f3ec266e4b0e243712b1f8c"}, {"code": "(fn pflatten [s]\n  (filter #(and (sequential? %)\n                ((complement sequential?) (first %)))\n          (rest (tree-seq sequential? seq s))))", "problem": 93, "user": "4f50c414e4b03ad3f0c10d0d"}, {"code": "(fn flatten [seq]\n  (loop [coll seq result []]\n    (if (empty? coll)\n    result\n    (recur\n     (rest coll)\n     (if (coll? (first (first coll)))\n       (into result (flatten (first coll)))\n       (conj result (first coll)) ;; one level coll\n       )\n     )\n    )))", "problem": 93, "user": "4ea31da2535d7eef308072c1"}, {"code": "(fn flatten2 [ll]\r\n  (mapcat #(if (and (sequential? %) (sequential? (first %))) (flatten2 %) [%]) ll))", "problem": 93, "user": "4f62b29ce4b0defedf855fd9"}, {"code": "#(for [s [coll?]\n       i (tree-seq s seq %)\n       :when (and (s i)\n                  (not-any? s i))]\n   i)", "problem": 93, "user": "4f6fbb68e4b07046d9f4efeb"}, {"code": "(fn thisfunc [s]\n  (if (not-any? coll? s)\n    [s]\n    (apply concat (map thisfunc s))))", "problem": 93, "user": "4dd9d299535d2dad7130b5dd"}, {"code": "(fn semi-flat [xs]\n  (mapcat #(if (coll? (first %)) (semi-flat %) [%]) xs))", "problem": 93, "user": "4f6160a7e4b0defedf855fbe"}, {"code": "(fn intocol[collect]\r\n  (let[col? (fn col? [col]\r\n              (or (vector? col) (list? col) )\r\n              ),\r\n       newcol (cond (vector? collect) (vector)\r\n                    (list? collect) (list)\r\n                    :else nil)\r\n              ]\r\n\r\n   ((fn inPeek[col]  \t       \r\n\t\t        (let[inPop (fn inPop[col]\r\n                            (println (str \"pop \" col))\r\n                            (if (empty? (pop col))\r\n                               (if(col? (peek(peek col)) )\r\n                                  (inPop (peek col) )\r\n                                  col \r\n                                  )\r\n                               (conj (inPop (pop col))\r\n                                     (inPeek (peek col)))\r\n                            )\r\n                        ),\r\n                 head (peek col),\r\n\t\t             other (pop col)]\r\n                 (println (str \"peek\" col))\r\n\t\t             (if (not (col? head)) \r\n\t\t                 col\t                             \r\n\t\t\t\t             (if (empty? other)\t\t                 \r\n\t\t\t\t                 (inPeek head)\t\t                 \r\n\t\t\t\t                 (conj (inPop other) (inPeek head) )\r\n\t\t\t\t              )    \r\n                 )\r\n\t\t\t    ) \r\n         )collect ) \r\n      )\r\n   )", "problem": 93, "user": "4f6d9d7ee4b07046d9f4efcd"}, {"code": "(fn [x]\n  (filter #(not (sequential? (first %)))\n          (rest (tree-seq #(sequential? (first %)) seq x))))", "problem": 93, "user": "4e7f5a0b535db966e863cc41"}, {"code": "(fn iter\n  ([s] (iter s []))\n  ([[a & r] out]\n    (cond (nil? a) out\n          (not-any? coll? a) (recur r (conj out a))\n          :else (recur (concat a r) out))))", "problem": 93, "user": "4f8345c6e4b033992c121c1b"}, {"code": "(fn [l]\n  (letfn [(contains-seq [l]\n            (if (sequential? l)\n              (some #(sequential? %) l)\n              false))]\n    (remove\n     #(contains-seq %)\n     (tree-seq (fn [l] (some #(sequential? %) l)) (fn [l] (apply list l)) l))))", "problem": 93, "user": "4f7e29dde4b06e829148e1ca"}, {"code": "(fn flat [s]\n    (if-not (coll? s)\n      s\n      (let [[x & xs] s]\n        (if (and (coll? x) (coll? (first x)))\n          (concat (flat x) (flat xs))\n          (cons x (flat xs))))))", "problem": 93, "user": "4ee26f01535d10e5ff6f5368"}, {"code": "(fn [coll]\r\n  (loop [[x & xs :as coll] coll res []]\r\n    (if (empty? coll)\r\n      res\r\n      (if (and (coll? x) (some coll? x))\r\n        (recur (concat x xs) res)\r\n        (recur xs (conj res x))))))", "problem": 93, "user": "4f969214e4b0dcca54ed6cdd"}, {"code": "mapcat #(partition-all 2 (flatten %))", "problem": 93, "user": "4f9597e0e4b0dcca54ed6cd4"}, {"code": "(fn [x]\n  (ffirst (drop-while (fn [[a b]] (not (= a b)))\n                      (partition 2 1\n                                 (iterate\n                                  (fn [c] (reduce (fn [a n]\n                                                   (if (and (coll? n) (some #(coll? %) n))\n                                                     (into a n)\n                                                     (conj a n)))\n                                                 [] c))\n                                  x)))))", "problem": 93, "user": "4f83665ee4b033992c121c1c"}, {"code": "(fn pf [s]\n  (if (empty? s) s\n  (if (coll? (first (first s)))\n    (concat (pf (first s)) (pf (rest s)))\n    (cons (first s) (pf (rest s)))\n  ))\n)", "problem": 93, "user": "4f84400de4b033992c121c2e"}, {"code": "(fn [xs]\n   (let [test (partial not-any? sequential?)]\n     (filter test (rest (tree-seq (complement test) seq xs)))))", "problem": 93, "user": "4e9fd521535d7eef3080729a"}, {"code": "(fn p93 [ps]\r\n  (let [pseq? (fn [x] (or (seq? x) (vector? x)))]\r\n\t\t(if (pseq? (first ps))\r\n\t\t\t(reduce concat (map p93 ps))\r\n\t\t\t[ps])))", "problem": 93, "user": "4f7f0827e4b06e829148e1d5"}, {"code": "(fn partially-flatten-seq [coll]\n  (filter (fn [xs]\n            (if (not (coll? xs))\n              false\n              (reduce #(and %1 (not (coll? %2))) true xs)))\n          (tree-seq coll? identity coll)))", "problem": 93, "user": "4ef6f5ea535dced4c769f250"}, {"code": "(fn f [v]\n  (if (some coll? v)\n    (mapcat f v)\n    [v]))", "problem": 93, "user": "4f9fe2b9e4b0dcca54ed6d40"}, {"code": "(fn [s]\n    (filter #(and (coll? %)\n                  (or (empty? %)\n                      (not (coll? (first %)))))\n            (tree-seq coll? identity s)))", "problem": 93, "user": "4f5cc3b8e4b0030a34fb2b2b"}, {"code": "(fn f [s] (reduce #(if (some coll? %2)\n                       (into % (f %2))\n                       (conj % %2)) [] s))", "problem": 93, "user": "4fa6d532e4b081705acca1be"}, {"code": "(fn f [s]\n  (let [plain-seq? (fn [s] (reduce #(and %1 %2) (map (complement sequential?) s)))]\n     (mapcat #(if (plain-seq? %) (list %) (f %)) s)))", "problem": 93, "user": "4f9120d8e4b0dcca54ed6c96"}, {"code": "(fn pf [coll]\r\n  (let [l (first coll) r (next coll)]\r\n    (concat \r\n      (if (and (sequential? l) (not (sequential? (first l))))\r\n        [l]\r\n        (pf l))\r\n      (when (sequential? r)\r\n        (pf r)))))", "problem": 93, "user": "4faa3eeae4b081705acca1ed"}, {"code": "(fn pf [lst]\n  (if (not-any? coll? lst) \n    [lst]\n    (mapcat pf lst)))", "problem": 93, "user": "4faa9593e4b081705acca1f9"}, {"code": "(fn [s]\n  (->> s\n    (tree-seq sequential? seq)\n    (filter sequential?)\n    (filter (comp (complement sequential?) first))))", "problem": 93, "user": "4f969a66e4b0dcca54ed6cde"}, {"code": "(fn [l]\n  (letfn [(sf [r l]\n            (if (coll? (first l))\n              (concat (sf r (first l)) (sf r (rest l)))\n              (when (not (empty? l))\n                (conj r l))))]\n    (sf [] l)))", "problem": 93, "user": "4f2baf1ae4b0d6649770a04c"}, {"code": "(comp (partial filter #(and (coll? %)\n                            (not (coll? (first %)))))\n      (partial tree-seq coll? identity))", "problem": 93, "user": "4f3fb586e4b0e243712b1f9c"}, {"code": "(fn f [s]\n  (if (sequential? (first s))\n    (mapcat f s)\n    [s]))", "problem": 93, "user": "4f4274f2e4b0d7d3c9f3fd00"}, {"code": "(fn [s] \n  (filter \n    #(= % (flatten %))\n    (tree-seq coll? seq s)))", "problem": 93, "user": "4f991ec1e4b0dcca54ed6cfb"}, {"code": "(fn f [x]\n  (loop [a []\n         x x]\n    (let [q (first x)]\n      (cond (nil? q) a\n            (and (coll? q) (not (coll? (first q)))) (recur (conj a q) (rest x))\n            (and (coll? q) (coll? (first q))) (recur (vec (concat a (f q))) (rest x))\n            :else '()))))", "problem": 93, "user": "4facd2fae4b081705acca22f"}, {"code": "(fn problem \n  [elements]\n  (let [result (remove empty?\n                       (loop [current-element (first elements) rest-of-list (rest elements) collected-values []]\n                             (if (and (empty? current-element) (empty? rest-of-list))\n                                 collected-values\n                               (if (and (coll? current-element) (not (coll? (first current-element))))\n                                   (recur (first rest-of-list) (rest rest-of-list) (conj collected-values current-element))\n                                 (recur (first current-element) (conj rest-of-list (rest current-element)) collected-values)))))]\n    (if (list? elements)\n        result\n      (vec result))))", "problem": 93, "user": "4daeabf6edd6309eace4d15c"}, {"code": "(fn part-flat [xs]\n  (let [x (first xs) more (next xs)]\n\t\t(concat \n\t\t\t(if  (and (sequential? x) ((comp not sequential? first) x))\n\t\t\t\t[x]\n\t\t\t\t(part-flat x))\n\t\t\t(when (sequential? more)\n\t\t\t\t(part-flat more)))))", "problem": 93, "user": "4fb1fa51e4b081705acca283"}, {"code": "(fn partially-flatten [s]\r\n  (loop [so-far []\r\n         remain (seq s)]\r\n    (if (empty? remain) so-far\r\n      (let\r\n        [_ (println \"so-far\" so-far)\r\n         _ (println \"remain\" remain)\r\n         h (first remain)\r\n         _ (println \"h\" h)\r\n         t (rest remain)\r\n         _ (println \"t\" t)\r\n         deeper (and \r\n          (sequential? h)\r\n          (not (empty? h))\r\n          (sequential? (first h)))\r\n         _ (println \"deeper\" deeper)]\r\n      (if\r\n       deeper  \r\n        (if (empty? (rest h))\r\n            (recur so-far (conj t (first h)))\r\n            (recur so-far (conj t (rest h) (first h))))\r\n        (recur (conj so-far h) t))))))", "problem": 93, "user": "4f036fb3535dcb61093f6ac8"}, {"code": "(fn f [s] \r\n    (reduce\r\n        (fn [r e]\r\n          (apply conj r \r\n                (cond (not (coll? e)) (list e)\r\n                      (every? (comp not coll?) e) (list e)\r\n                      :else (f e))\r\n          )) \r\n        []\r\n        s\r\n        )\r\n      )", "problem": 93, "user": "4f0da4e4535d0136e6c22319"}, {"code": "(fn partially-flatten\n ([s]\n    (partially-flatten [] s))\n ([res s]\n    (reduce (fn [res s]\n              (if (every? (comp not sequential?) s)\n                (conj res s)\n                (partially-flatten res s))) res s)))\n\n;; Once again, someone else has a better solution:\n;;\n;; (fn [s]\n;;  (filter #(and (sequential? %) (not (sequential? (first %))))\n;;    (tree-seq sequential? seq s)))", "problem": 93, "user": "4fa0a4b1e4b0dcca54ed6d4f"}, {"code": "(fn f [coll]\n  (reduce\n    (fn [v e]\n      (if (coll? (first e))\n        (into v (f e))\n        (conj v e)))\n    []\n    coll))", "problem": 93, "user": "4fb2101ce4b081705acca284"}, {"code": "(fn [s] (filter #(and (sequential? %) ((comp not sequential? first) %)) (tree-seq sequential? seq s)))", "problem": 93, "user": "4f954dbce4b0dcca54ed6ccd"}, {"code": "(fn partially-flatten [coll]\n    (filter #(if (coll? %)\n               (not (coll? (first %)))\n               false)\n                 (tree-seq coll? identity coll)))", "problem": 93, "user": "4f1bee08535d64f60314647e"}, {"code": "(fn f [coll]\n  (if (coll? (first coll))\n    (mapcat f coll), [coll]))", "problem": 93, "user": "4fa5406fe4b081705acca1ac"}, {"code": "(fn [x]\n  (filter\n    #(and (coll? %) (not (coll? (first %))))\n    (tree-seq coll? seq x)\n  )\n)", "problem": 93, "user": "4f725201e4b07046d9f4f02f"}, {"code": "#(let [has-children? (fn [s] (some coll? s))]\n  (filter (complement has-children?) (tree-seq has-children? identity %)))", "problem": 93, "user": "4f725466e4b07046d9f4f030"}, {"code": "(fn f [t]\n         (if-not (coll? (first t)) [t]\n           (mapcat f t)))", "problem": 93, "user": "4fa30027e4b081705acca187"}, {"code": "(fn partflat [c]\n  (let [innermost? #(and (sequential? %)\n                         (nil? (some sequential? %)))]\n    (reduce #(if (innermost? %2)\n               (conj % %2)\n               (let [inner (partflat %2)]\n                 (if (every? innermost? inner) (into % inner)\n                   (conj % (apply concat inner))))) [] c)))", "problem": 93, "user": "4fca1cd6e4b0ee37620e184c"}, {"code": "(fn flat [coll]\n  (cond (empty? coll) '()\n        (and (sequential? (first coll))\n             (not-any? sequential? (first coll)))  (conj (flat (rest coll)) (first coll))\n        (sequential? (first coll)) (concat (flat (first coll))\n                                           (flat (rest coll)))\n        :else (conj (flat (rest coll)) (first coll))))", "problem": 93, "user": "4fcaf7a4e4b0ee37620e1857"}, {"code": "(fn flat [l]\n  (if (not-any? sequential? l)\n    [l]\n    (mapcat flat l)))", "problem": 93, "user": "4fce5474e4b0d4b2a7a9d451"}, {"code": "(fn flatten-1 [[f & r :as s]]\n  (cond (empty? s) nil\n        (coll? f) (concat (flatten-1 f) (flatten-1 r))\n        :otherwise [s]))", "problem": 93, "user": "4fb1d907e4b081705acca282"}, {"code": "(fn foo [s]\n  (cond (empty? s) s\n        (not-any? coll? s) (list s)\n        :else (concat (foo (first s)) (foo (rest s)))))", "problem": 93, "user": "4dadc27ec9a9d6ed3c99dc57"}, {"code": "(fn [x]\n  (filter #(empty? (filter coll? %))\n          (tree-seq #(seq (filter coll? %)) seq x)))", "problem": 93, "user": "4e6e2ac4535d5021c1a895ff"}, {"code": "(fn partial-flatten [coll]\n  (mapcat\n    #(if (some coll? %)\n      (partial-flatten %)\n      [%])\n    coll))", "problem": 93, "user": "4f7f9665e4b033992c121bea"}, {"code": "(fn [xs]\n  (->> xs\n    (tree-seq sequential? identity)\n    (filter #(and (sequential? %) (not-any? sequential? %)))))", "problem": 93, "user": "4fb12b35e4b081705acca275"}, {"code": "(fn pf [coll]\n  (mapcat\n    #(if (coll? (first %))\n         (pf %)\n         (list %))\n    coll))", "problem": 93, "user": "4fd96694e4b05e33b9224f37"}, {"code": "(fn [sq] (letfn [(nscoll? [c] (not (and (coll? c) (every? (complement coll?) c))))]\n          (loop [l sq] (if (some nscoll? l)\n                         (recur (mapcat #(if (nscoll? %) % [%]) l))\n                         l))))", "problem": 93, "user": "4efd8b67535de96065cf5085"}, {"code": "(fn [coll]\n  (filter #(and (sequential? %) (not (sequential? (first %))))\n          (tree-seq sequential? identity coll)))", "problem": 93, "user": "4f7431d2e4b044e54cd9a8f7"}, {"code": "(fn f [x]\n  (if (coll? x)\n      (mapcat #(if (and (coll? %) (every? coll? %)) % [%]) (map f x))\n    x))", "problem": 93, "user": "4f465096e4b0d56e7bb92b9a"}, {"code": "(fn q93 [coll]\n  (let [x (first coll) xs (next coll)]\n    (concat \n      (if (and (sequential? x) (not (sequential? (first x))))\n        (list x)\n        (q93 x))\n      (when (sequential? xs)\n        (q93 xs)))))", "problem": 93, "user": "4fd22e70e4b04c3a95aa041c"}, {"code": "(letfn [(flatten-seq? [s]\r\n          (every? #(not (sequential? %)) s))]\r\n  (fn pflatten [s]\r\n    (cond (empty? s) '()\r\n          (flatten-seq? (first s)) (cons (first s) (pflatten (rest s)))\r\n          :else (concat (pflatten (first s)) (pflatten (rest s))))))", "problem": 93, "user": "4fcc6cb3e4b0ee37620e1861"}, {"code": "(fn [x]\n     (letfn [ (max-one-level? [c] (if (sequential? c) (every? (complement sequential?) c)   true)) ]\n     (filter max-one-level?\n             (rest (tree-seq (complement max-one-level?) seq x)))))", "problem": 93, "user": "4fccdc75e4b0ee37620e186d"}, {"code": "(fn partial-flatten [coll]\n  (letfn [(flat? [item]\n            (not-any? sequential? item))]\n   (sort-by first (into (empty coll) \n         (filter flat?\n                 (tree-seq (complement flat?) identity coll))))))", "problem": 93, "user": "4faafccde4b081705acca209"}, {"code": "(fn \u0192 ([s] (\u0192 [] s))\n   ([r s]\n    (if (coll? s)\n      (let [x (reduce #(\u0192 % %2) [] s)]\n        (if (some (complement coll?) x)\n          (conj r x)\n          (apply conj r x)))\n      (conj r s)))\n   )", "problem": 93, "user": "4fdec88fe4b05e33b9224f8e"}, {"code": "(fn[x]\n  (filter #(and (coll? %1) (not (coll? (first %1)))) (tree-seq coll? identity x)))", "problem": 93, "user": "4fb86dc9e4b081705acca2d8"}, {"code": "(fn grind [s]\n  (if (not (coll? (first s)))\n    (list s)\n    (apply concat (map grind s))))", "problem": 93, "user": "4fe8aef4e4b07c9f6fd12c6c"}, {"code": "(fn [s]\n  (letfn [(treecoll [pred t]\n            (cond (not (coll? t)) (list t)\n                  (empty? t) t\n                  (pred t) (list t)\n                  :else\n                  (concat (treecoll pred (first t))\n                                    (treecoll pred (rest t)))))]\n      (treecoll #(not-any? coll? %) s)))", "problem": 93, "user": "4fe87e56e4b07c9f6fd12c40"}, {"code": "(fn flat \r\n   ([x] (flat [] x))\r\n   ([acc x]\r\n   (if (not-any? sequential? x) \r\n     (conj acc x)\r\n     (reduce #(if (sequential? %2) (flat %1 %2) (conj %1 %2)) acc x))))", "problem": 93, "user": "4feada56e4b0140c20fb9c11"}, {"code": "(fn f [c]\n  (if (coll? c)\n    (if (some coll? c)\n      (mapcat f c) [c])\n  c))", "problem": 93, "user": "4db016af838c48654951d9b9"}, {"code": "(fn f [x] (if (some #(not (sequential? %)) x)\r\n              [x]\r\n              (mapcat f x)))", "problem": 93, "user": "4fca2ef0e4b0ee37620e184e"}, {"code": "(fn ff[l] (mapcat #(if (and (coll? %) (coll? (first %))) (ff %) [%])l))", "problem": 93, "user": "4e7f4147535db966e863cc3d"}, {"code": "#(filter (fn [e] (and (sequential? e) (= (flatten e) e))) (tree-seq sequential? seq %))", "problem": 93, "user": "4f8bbb27e4b02e764a0a5182"}, {"code": "(fn pflat [coll]\n  (if (coll? (first coll))\n    (mapcat pflat coll)\n    [coll]))", "problem": 93, "user": "5003deb9e4b0678c553fc445"}, {"code": "(fn my-flatten [coll]\n  (reduce \n    #(if (and (coll? %2) (some coll? %2)) (into %1 (my-flatten %2)) (conj %1 %2)) \n    [] coll))", "problem": 93, "user": "5002b6e5e4b0678c553fc42c"}, {"code": "(fn partial-flatten [list]\n  (letfn [(collect-lists [acc coll]\n            (if (some true? (map coll? coll))\n              (reduce #(if (some coll? %2)\n                         (into %1 (collect-lists [] %2))\n                         (conj %1 %2)) [] coll)\n              coll))]\n    (collect-lists [] list)))", "problem": 93, "user": "4ff355a1e4b0678c553fc34d"}, {"code": "(letfn [(flat [c] (if (and (sequential? c) (sequential? (first c)))\r\n                     (mapcat flat c)\r\n                     [c]))]\r\n  flat)", "problem": 93, "user": "4f1b0ab3535d64f603146474"}, {"code": "(fn x [c]\r\n  (cond\r\n    (empty? c) nil\r\n    (coll? (ffirst c)) (lazy-cat (x (first c)) (x (next c)))\r\n    :else (lazy-cat [(first c)] (x (next c)))))", "problem": 93, "user": "4fe900a6e4b0547ebccb243a"}, {"code": "(fn [ls]\n  (filter #(not-any? coll? %)\n    (tree-seq #(some coll? %) identity ls)))", "problem": 93, "user": "5003ee7de4b0678c553fc446"}, {"code": "(fn [c]\n  (filter #(and (sequential? %) (not (sequential? (first %))))\n          (tree-seq sequential? seq c)))", "problem": 93, "user": "500d8c49e4b07ccb9a7ddb00"}, {"code": "(fn pairs [x]\r\n    (filter #(and (sequential? %) (not-any? sequential? %))\r\n            (tree-seq sequential? seq x)))", "problem": 93, "user": "500d1db4e4b05f7c30cfa69f"}, {"code": "(fn [coll]\n  (letfn [(flatten1 [coll]\n                    (mapcat \n                      (fn [x] \n                        (if (sequential? (first x))\n                          (flatten1 x)\n                          [x]) ) \n                      coll))]\n         (flatten1 coll)))", "problem": 93, "user": "4dca8b6d535d5973398f9288"}, {"code": "(fn exp [acc s]\n  (if (some coll? s)\n    (exp (exp acc (first s)) (rest s))\n    (if (seq s) \n      (conj acc s)\n      acc))) []", "problem": 93, "user": "4f05ea25535dcb61093f6c02"}, {"code": "(fn [coll] (filter #(and (sequential? %) (not (some sequential? %)))\n                   (rest (tree-seq sequential? seq coll))))", "problem": 93, "user": "500900dee4b0144d4f561e42"}, {"code": "(fn __ [s]\n  (cond\n    (not (coll? s)) s\n    (some coll? s) (mapcat __ s)\n    :else [s]))", "problem": 93, "user": "4ec9549d535d6d7199dd36fe"}, {"code": "(fn [s] (partition (count (flatten (first s))) (flatten s)))", "problem": 93, "user": "4fdf2b50e4b05e33b9224f93"}, {"code": "(fn [s]\r\n  (filter #(and (coll? %)\r\n                (zero? (count (filter identity (map coll? %)))))\r\n          (tree-seq coll? identity s)))", "problem": 93, "user": "4ff9d4e5e4b0678c553fc3b0"}, {"code": "(fn outer [s]\n  (letfn [\n    (isLowestLevelList [l]\n      (every? #(not (coll? %)) l))\n    ]\n    ((fn inner [current]\n      (if (isLowestLevelList current)\n          [current]\n          (reduce into [] (map inner current))\n      )\n    ) s)\n))", "problem": 93, "user": "4fcf5292e4b03432b189f40e"}, {"code": "(fn cat1 [xs]\n  (if (empty? xs)\n    ()\n    (if (and (sequential? (first xs))\n             (sequential? (ffirst xs)))\n      (concat (cat1 (first xs)) (cat1 (rest xs)))\n      (cons (first xs) (cat1 (rest xs))))))", "problem": 93, "user": "500933a6e4b046cdb195e074"}, {"code": "(fn f [c]\r\n  (mapcat (fn [x] (if (and (sequential? x) (every? sequential? x))\r\n                    (f x)\r\n                    [x]\r\n                    )) c)\r\n   )", "problem": 93, "user": "4febb4dae4b0681fd128dc98"}, {"code": "(fn pf\n  ([x] (pf x []))\n  ([x acc]\n     (if (coll? (first x))\n       (concat (pf (first x) acc) (pf (rest x) acc))\n       (if (not (empty? x))\n         (conj acc x)))))", "problem": 93, "user": "500cb910e4b05f7c30cfa698"}, {"code": "(fn __ [col]\n  (filter #(and (coll? %) \n                (not (coll? (first %))))\n          (tree-seq coll? identity col)))", "problem": 93, "user": "4fa719c0e4b081705acca1bf"}, {"code": "(fn [c]\n  (->>\n    (tree-seq sequential? seq c)\n    (filter sequential?)\n    (filter #(not (sequential? (first %))))))", "problem": 93, "user": "4f9f7daae4b0dcca54ed6d37"}, {"code": "(fn [s]\n  (let [res (reduce #(if (-> %2 first coll?) (into % %2) (conj % %2)) [] s)]\n    (if (= s res) s (recur res))))", "problem": 93, "user": "5028cd0fe4b01614d1633ffc"}, {"code": "(fn fl[s] (mapcat #(if (some coll? %) (fl %) [%]) s))", "problem": 93, "user": "50336c6be4b0c6c1199c710f"}, {"code": "(fn foo [c]\n  (if (not-any? sequential? c)\n    [c] (mapcat foo c)))", "problem": 93, "user": "5033a1fbe4b062bc5d7ae155"}, {"code": "(fn partially-flatten- [coll]\n  \"93. Write a function which flattens any nested combination of                                                                                                       \n  sequential things (lists, vectors, etc.), but maintains the lowest                                                                                                   \n  level sequential items.\"\n  (lazy-seq\n   (if-let [s (seq coll)]\n     (if (some sequential? (first s))\n       (concat (partially-flatten- (first s)) (partially-flatten- (rest s)))\n       (conj (partially-flatten- (rest s)) (first s))))))", "problem": 93, "user": "4e5eb843535d8a8b8723a2d4"}, {"code": "(fn f [s] (if (sequential? (first s)) (mapcat f s) [s]))", "problem": 93, "user": "4e9609ad535dbda64a6f6b3e"}, {"code": "(fn f [s] \n   (if (coll? (first s)) \n     (mapcat f s) \n     [s]))", "problem": 93, "user": "503917a0e4b088a6a14ca763"}, {"code": "#(if (= % '((1 2)((3 4)((((5 6)))))))\n  '((1 2) (3 4) (5 6))\n  (map flatten %))", "problem": 93, "user": "502a9fdee4b095a7adb898b4"}, {"code": "(fn pflatten [tree]\n  (if (every? sequential? tree)\n    (mapcat pflatten tree)\n    [tree]))", "problem": 93, "user": "5032b066e4b00c0952a257ea"}, {"code": "(fn fl [[f & m :as s]]\n  (when f\n    (if (coll? f)\n      (concat (fl f) (fl m)) \n      [s] )))", "problem": 93, "user": "502904e0e4b0feaf66e22fad"}, {"code": "(fn f [s]\n          (let [d (fn d [s] (if (not (coll? s)) 0 (inc (apply max (map d s)))))]\n            (if (= 1 (d s))\n              [s]\n              (reduce #(apply conj % (f %2)) [] s))))", "problem": 93, "user": "503b6995e4b07a1917cc34dd"}, {"code": "(fn f [s]\r\n    (if (some coll? s)\r\n      (mapcat #(if (some coll? %) (mapcat f %) [%]) s)\r\n      [s]))", "problem": 93, "user": "4f58d92fe4b0a7574ea71858"}, {"code": "(fn fl [coll]\n  (let [l (first coll) r (next coll)]\n    (concat \n      (if (and (sequential? l) (not (sequential? (first l))))\n        [l]\n        (fl l))\n      (when (sequential? r)\n        (fl r)))))", "problem": 93, "user": "4eb8ec4a535dfed6da9c6d4b"}, {"code": "(fn [coll]\r\n   (loop [ret [] c coll]\r\n     (if (empty? c) ret \r\n     (if (not-any? coll? (first c))\r\n       (recur (conj ret (first c)) (rest c))\r\n       (recur ret (concat (first c) (rest c)))))))", "problem": 93, "user": "503354c3e4b0c6c1199c710c"}, {"code": "(fn partial-flatten [xs]\n  (if (coll? (first xs))\n    (if (next xs)\n      (concat (partial-flatten (first xs)) (partial-flatten (rest xs)))\n      (partial-flatten (first xs)))\n    (list xs)))", "problem": 93, "user": "504e13fce4b078edc5f593bc"}, {"code": "(fn my-flatten [xs]\n  (if (empty? xs) nil\n    (let [[h & t] xs]\n      (lazy-cat\n       (if (coll? h) \n         (if (not-any? coll? h) [h] (my-flatten h))\n         [h])\n       (my-flatten t)))))", "problem": 93, "user": "4f2e0369e4b0d6649770a064"}, {"code": "(fn [coll]\n  (filter (fn [val]\n            (and (sequential? val)\n                 (not (some sequential? val))))\n          (tree-seq sequential? seq coll)))", "problem": 93, "user": "5014754de4b094324338f8e5"}, {"code": "(fn pflat [s]\n  (if (some coll? s)\n    (mapcat pflat s)\n    [s]))", "problem": 93, "user": "50586354e4b06522596eba78"}, {"code": "(fn [xs]\n  (filter\n    #(and (sequential? %) (every? (complement sequential?) %))\n    (tree-seq sequential? seq xs)))", "problem": 93, "user": "4dafa380edd6309eace4d17c"}, {"code": "(fn f [s]\n  (mapcat\n    (fn [x]\n      (if (every? (comp not coll?) x) [x] (f x)))\n    s))", "problem": 93, "user": "50361b6be4b0fbe0a74d26be"}, {"code": "(fn f [a]\n  (if (not-any? sequential? a)\n    [a]\n    (->>\n      (filter sequential? a)\n      (map f)\n      (apply concat))))", "problem": 93, "user": "504f865ee4b0a02f9cffde90"}, {"code": "(fn pf [[x & xs :as c]]\n   (cond (empty? c) c\n         (or (not (coll? x)) (not (coll? (first x)))) (cons x (pf xs))\n         :else (concat (pf x) (pf xs) )))", "problem": 93, "user": "50563ae2e4b0ce54f56f0405"}, {"code": "(fn flatten [s]\n  (if (every? sequential? s)\n    (mapcat flatten s)\n    [s]))", "problem": 93, "user": "4fe84c74e4b07c9f6fd12c3c"}, {"code": "(fn partial-flatten\r\n  [xs]\r\n  (letfn [(flatlist? [s] (every? (comp not sequential?) s))\r\n          (flatobj? [s] (or (not (sequential? s)) (flatlist? s)))]\r\n    (if (flatobj? xs)\r\n      (if (sequential? xs)\r\n        [xs]\r\n        xs)\r\n      (mapcat\r\n       partial-flatten\r\n       xs))))", "problem": 93, "user": "50427899e4b0add3005c0fc2"}, {"code": "; need to revisit this later... shoudl be simpler than this...\n(fn partially-flatten [coll]\n  (letfn [(inner-most [coll] \n    (if (not (coll? (first coll)))\n      (vector coll) \n      (into (inner-most (first coll))  (inner-most (rest coll)))))]\n  (filter #(not (empty? %)) (inner-most coll))))", "problem": 93, "user": "501c1492e4b086d93747d180"}, {"code": "(fn mf [s]\n    (if (empty? s)\n      '()\n      (let [fi (first s)]\n          (if (coll? (first fi))\n            (concat (mf fi) (mf (next s)))\n            (cons fi (mf (next s)))))))", "problem": 93, "user": "5063fe48e4b075d771da6f9e"}, {"code": "(fn flat [s]\n  (cond (empty? s) (empty s)\n(not (coll? (first s))) [s]\n:else (concat (flat (first s)) (flat (rest s)))))", "problem": 93, "user": "4fca2a13e4b0ee37620e184d"}, {"code": "(fn f [s]\n  (let [s? sequential?\n        c? #(and (s? %) (every? s? %))\n        c #(apply vector (concat %1 %2))\n        rf #((if (c? %2) c conj) %1 (f %2))]\n    (if (s? s) (reduce rf [] s) s)))", "problem": 93, "user": "504e04a4e4b078edc5f59397"}, {"code": "(fn pflat [acc s]\n  (if (some coll? s)\n    (pflat (pflat acc (first s)) (rest s))\n    (if (seq s)\n      (conj acc s)\n      acc))) []", "problem": 93, "user": "50705072e4b07bd6ad9b9f27"}, {"code": "(fn [s]\n  (letfn [(nest-1? [s]\n                   (and (sequential? s) (not (sequential? (first s)))))\n          (nest-1 [s]\n                   (loop [s s]\n                     (if (nest-1? s) [s]\n                       (if (= 1 (count s))\n                           (recur (first s))\n                           (my-flat s)))))\n\n          (my-flat [s]\n                   (reduce #(into %1 (nest-1 %2)) [] s))]\n     (my-flat s)))", "problem": 93, "user": "4fdb02aae4b05e33b9224f56"}, {"code": "(fn pflatten [list]\n  (mapcat\n   (fn [x] (if (and (coll? x) (some coll? x)) (pflatten x) [x]))\n   list))", "problem": 93, "user": "4e8338d6535db62dc21a62d3"}, {"code": "(fn f [coll]\n  (mapcat #(if (and (coll? %) (some coll? %))\n             (f %)\n             [%])\n          coll))", "problem": 93, "user": "507056b8e4b07bd6ad9b9f29"}, {"code": "(fn flatten [coll]\n  (if (some sequential? coll) \n    (mapcat flatten coll)\n    [coll]))", "problem": 93, "user": "4ee6400c535d93acb0a6685b"}, {"code": "(fn pflat [coll]\n  (if (every? (complement sequential?) coll)\n    [coll]\n    (apply concat (map pflat coll))))", "problem": 93, "user": "4f03154a535dcb61093f6a58"}, {"code": "(fn partial-flatten\n  [seq]\n  (let [return (empty seq)\n        concat-1-depths (fn concat-1-depths [return seq]\n                          (println return seq)\n                          (if (every? (comp not coll?) seq)\n                            (concat return [seq])\n                            (reduce concat-1-depths return seq)))]\n    (reduce concat-1-depths return seq)))", "problem": 93, "user": "4dbb0f2d535d1e037afb21b1"}, {"code": "(fn [s]\n    (letfn [(rec [accum s]\n              (if-not (coll? (first s))\n                (conj accum s)\n                (reduce rec accum s)))]\n      (reduce rec [] s)))", "problem": 93, "user": "50763574e4b0a894bb95bf3d"}, {"code": "(fn f [[fsq & rsq :as sq]]\n  ;(println fsq rsq)\n  (cond\n    (not (seq sq))\n      nil\n    (and\n      (sequential? sq)\n      (not (sequential? fsq)))\n      [sq]\n    :else\n      (concat (f fsq) (f rsq))))", "problem": 93, "user": "504c8165e4b09724c857af31"}, {"code": "(fn consume [xs]\n  (reduce\n    #(if (coll? (first %2))\n      (concat %1 (consume %2))\n      (concat %1 [%2])\n    )\n    []\n    xs\n  )\n)", "problem": 93, "user": "507eddf4e4b06ce648bcdbfa"}, {"code": "(fn pflat [x]\n  (letfn [(notflat? [c] (reduce #(or %1 %2) (map (fn [z] (coll? z)) c)))]\n\t        (cond (empty? x) x\n\t\t\t\t  (and (coll? x) (notflat? x)) (concat (pflat (first x)) (pflat (rest x)))\n\t\t\t\t  :else (list x))\n\t)\n)", "problem": 93, "user": "50588af1e4b06522596eba7d"}, {"code": "(fn flt [s]\n  (when (seq s)\n    (let [[x & xs] s]\n      (if (sequential? (first x)) \n        (concat (flt x) (flt xs))\n        (cons x (flt xs))))))", "problem": 93, "user": "50901b2ee4b0ea685a20f774"}, {"code": "(fn f [l] (when (seq l)(let [x (first l) xs (rest l)] (if (not-any? coll? x) (cons x (f xs)) (concat (f x) (f xs))))))", "problem": 93, "user": "4f8c5f4fe4b02e764a0a5198"}, {"code": "(fn flat [s]\n  (letfn [\n         (get-last-seq [acc s] \n          (if (sequential? (first s))\n             (if (sequential? (ffirst s)) \n              (get-last-seq acc (first s))\n              (if (not-empty (rest s))\n                (get-last-seq (conj acc (first s)) (rest s))\n                (conj acc (first s)))) \n             (conj acc s) ))]\n  (reduce get-last-seq [] s) ))", "problem": 93, "user": "50783762e4b0fc74642bff67"}, {"code": "(fn [s] (filter #(and (sequential? %) (not (sequential? (first %)))) (rest (tree-seq sequential? seq s))))", "problem": 93, "user": "5054c7e1e4b0b1b9d1860eb2"}, {"code": "(fn f ([x] \n  (f x []))\n  ([x r]\n    (if (empty? x)\n        r\n      (if (counted? (first (first x)))\n          (recur (concat (first x) (rest x)) r)\n        (recur (rest x) (conj r (first x)))))))", "problem": 93, "user": "507fbd77e4b089ade05efbd3"}, {"code": "(fn [coll]\n  (letfn [(rec [[fst & rst :as c] acc]\n            (cond\n             (empty? c) (reverse acc)\n             (sequential? (first fst)) (recur (concat fst rst) acc)\n             :else (recur rst (cons fst acc))))]\n    (rec coll [])))", "problem": 93, "user": "504f57c7e4b0a02f9cffde71"}, {"code": "(fn f [xs]\n (cond\n  (empty? xs) []\n  (coll? (ffirst xs)) (concat (f (first xs)) (f (rest xs)))\n  :else (concat [(first xs)] (f (rest xs)))))", "problem": 93, "user": "5097b556e4b00ad8bab4e970"}, {"code": "(fn fl [a]\r\n  (cond (empty? a) nil\r\n  (= a (flatten a)) [a]\r\n\t:else (concat (fl (first a)) (fl (rest a)))))", "problem": 93, "user": "507437c2e4b054001656acd0"}, {"code": "(fn f [x]\n  (if (some coll? x)\n    (let [res (map f x)]\n      (if (= 1 (count res))\n        (first res)\n        (apply concat \n          (map #(if (some coll? %)\n                %\n                (list %)) res))))\n    x))", "problem": 93, "user": "506617c3e4b03d366d7cb2ab"}, {"code": "(fn partial-flatten [ls]\n  (letfn [(basis? [ls]\n            (and (sequential? ls)\n                 (not (sequential? (first ls)))))\n          (flatten1 [ls]\n            (cond\n             (basis? ls) (list ls)\n             (nil? ls) ()\n             :else (concat (flatten1 (first ls))\n                           (flatten1 (rest ls)))))]\n    (remove empty? (flatten1 ls))))", "problem": 93, "user": "4dd62278535d2dad7130b5c7"}, {"code": "(fn pfl [l]\n  (mapcat \n    (fn [i] \n      (if (or \n            (not (coll? i)) \n            (some #(not (coll? %)) i))\n        [i]\n        (pfl i)))\n    l))", "problem": 93, "user": "5034b0e1e4b062bc5d7ae167"}, {"code": "(fn flatten-partial [s]\n  (mapcat #(if (sequential? (first %1)) (flatten-partial %1) (vector %1)) s ))", "problem": 93, "user": "4f4c6b21e4b03ad3f0c10c8f"}, {"code": "(fn part-flat [s]\n  (if (not-any? sequential? s)\n    (list s)\n    (apply concat (map part-flat s))))", "problem": 93, "user": "4dad76588e77d6ed63f12a44"}, {"code": "(fn f [c] (if (not-any? coll? c) [c] (reduce into [] (map f c))))", "problem": 93, "user": "4fb1325de4b081705acca276"}, {"code": "(fn prog-93 [x]\n  [x]\n  (filter #(or ((complement sequential?) %) (not-any? sequential? %))\n          (rest (tree-seq #(and (sequential? %) (some sequential? %)) seq x))))", "problem": 93, "user": "504ec4d3e4b069badc5a33c9"}, {"code": "(fn pflat [x]\n  (if (coll? (first x))\n    (mapcat pflat x)\n    [x]))", "problem": 93, "user": "509c03f3e4b085ae113522a8"}, {"code": "(fn unseq [[h & t :as all]]\n    (println h t)\n    (let [done? (fn [s]\n                  (and (sequential? s)\n                       (not (sequential? (first s)))))]\n      (if (nil? t)\n        (if (done? h)\n          [h]\n          (unseq h))\n        (if (done? h)\n          (into [h]\n                (unseq t))\n          (into (unseq h)\n                (unseq t))))))", "problem": 93, "user": "4daea889edd6309eace4d15b"}, {"code": "(fn pflat [x]\n  (if (or (not (sequential? x)) \n          (not-any? sequential? x)) \n    [x]\n    (mapcat pflat x)))", "problem": 93, "user": "4f9d53f3e4b0dcca54ed6d21"}, {"code": "(fn flatten-butlast [l]\n  (if (every? (complement coll?) l)\n      (list l)\n    \t(apply concat (map flatten-butlast l))))", "problem": 93, "user": "50812debe4b01a93d3f38e4c"}, {"code": "(fn[xs]\n   (filter #(and (sequential? %) (not (some sequential? %)))\n           (tree-seq sequential? identity xs)))", "problem": 93, "user": "506406c8e4b075d771da6f9f"}, {"code": "(fn pflatten [s]\n  (let [containseq? #(some sequential? %)]\n    (filter (complement containseq?)\n            (rest (tree-seq containseq? seq s)))))", "problem": 93, "user": "50052d38e4b0678c553fc45c"}, {"code": "(fn partial-flatten [sq]\n  (reduce (fn [ret ele]\n    (if (some sequential? ele)\n      (apply conj ret (partial-flatten ele))\n      (conj ret ele))) [] sq))", "problem": 93, "user": "5084c43be4b0fb8f40674bfa"}, {"code": "(fn f [s] \n  (if (some coll? s) (mapcat f s) [s]))", "problem": 93, "user": "4f956072e4b0dcca54ed6ccf"}, {"code": "(fn [c]\n  (loop [out [] [el & re] c]\n    (cond (and (empty? re) (nil? el)) out\n          (or (not (coll? el)) \n              (and (coll? el) (every? (comp not coll?) el)))\n          (recur (conj out el) re)\n          :else (recur out (concat el re)))))", "problem": 93, "user": "4f1bb9d8535d64f60314647d"}, {"code": "(fn [coll]\n    (reverse\n     (loop [c coll\n            res []]\n       (cond (empty? c) res\n             (and\n              (coll? (first c))\n              (some coll? (first c))) (recur (concat (first c) (rest c)) res)\n             :else (recur (rest c)\n                          (cons (first c) res))))))", "problem": 93, "user": "4f463dfde4b0d56e7bb92b99"}, {"code": "(fn f [x]\n  (loop [s x\n         r []]\n    (if (empty? s)\n      r\n      (recur (rest s)\n             (if (and (instance? clojure.lang.Seqable (first s))\n                      (instance? clojure.lang.Seqable (first (first s))))\n               (vec (concat r (f (first s))))\n               (conj r (first s)))))))", "problem": 93, "user": "5027b41ee4b01614d1633fee"}, {"code": "(fn f [s]\r\n  (reduce\r\n    (fn [s x]\r\n      (if (sequential? (first x))\r\n          (vec (concat s (f x)))\r\n          (conj s x))) [] s))", "problem": 93, "user": "50acbd15e4b071b89ef26234"}, {"code": "(fn pf [s] (if (sequential? (first s)) (mapcat pf s) [s]))", "problem": 93, "user": "50996a38e4b0cae2931060b3"}, {"code": "(fn f [t] (if (coll? (first t)) (mapcat f t) [t]))", "problem": 93, "user": "509b89b3e4b03049c49bd678"}, {"code": "(fn p-flat [coll] \n  (mapcat \n    #(if (sequential? (first %))\n      (p-flat %)\n      [%])\n    coll))", "problem": 93, "user": "4ec12516535dfed6da9c6da7"}, {"code": "(fn f [xs]\n  (if (and (coll? xs) (coll? (first xs))) (mapcat f xs) (list xs)))", "problem": 93, "user": "508157b2e4b0946d0443855c"}, {"code": "(fn test93 [s]\n  (->> s\n       (tree-seq sequential? seq)\n       (filter sequential?)\n       (filter (comp (complement sequential?) first))))", "problem": 93, "user": "50b0cffae4b009df37c708c5"}, {"code": "(fn this [col]\n  (let [is-seq (fn [l]\n                 (or (seq? l) (vector? l)))\n        has-sub-seq (fn [l]\n                      (> (count (filter #(is-seq %) l)) 0)\n                      ) ; fn has-sub-seq\n        open-seq (fn [l]\n                   (reduce #(concat %1 %2) [] l)) ; fn open-seq\n        ]\n    (if (has-sub-seq col)\n      (reduce (fn [result l]\n                 (if (has-sub-seq l)\n                   (concat result (this l))\n                   (concat result (vector l))\n                   ) ; if\n               ) [] col)\n      col)))", "problem": 93, "user": "5021f0b3e4b00bba4502f7ac"}, {"code": "(fn f [l]\n  (when (seq l)\n    (let [[x r] (split-at 1 l)\n          x (first x)]\n      (if (= x (flatten x))\n        (cons x (f r))\n        (concat (f x)(f r))))))", "problem": 93, "user": "50a83315e4b054305ba5a830"}, {"code": "(letfn [(reduce-nest [s]\n          (reduce\n           #(if (sequential? (first %2))\n              (conj %1 (first %2) (reduce-nest (rest %2)))\n              (conj %1 %2))\n           (empty s) s))]\n  (fn pflat [s]\n    (let [rs (if (list? s) (reverse (reduce-nest s)) (reduce-nest s))]\n      (if (= rs s) (filter not-empty s) (pflat rs)))))", "problem": 93, "user": "50733b31e4b0e3170b5a869a"}, {"code": "(fn [xs] (filter (complement #(every? sequential? %)) (tree-seq #(every? sequential? %) seq xs)))", "problem": 93, "user": "50310b8be4b05b7df5a0b84d"}, {"code": "(fn walk [c] (if (= c (flatten c)) [c] (mapcat walk c)))", "problem": 93, "user": "500aa15ee4b03d00572d2d76"}, {"code": "(fn flatt [v]\n  (letfn [(ww [s] \n              (if (coll? (first s))\n                (first (vector s))\n                (vector s)))]\n         (let [v' (mapcat ww v)]\n           (if (= v v')\n             v\n             (flatt v')))))", "problem": 93, "user": "50e87427e4b0ebbe794eb7e8"}, {"code": "; not sure that this is 100% correct ... \n(fn pf[coll]\n   (reduce \n    (fn [r n]\n   (cond \n    (not (coll? n))         (concat r n) \n    (not (coll? (first n))) (concat r [n])\n    :else                   (concat r (pf n))))\n    [] coll))", "problem": 93, "user": "50de11b2e4b061dbdced7217"}, {"code": "(fn[s]\n  (let [first-seq? (comp sequential? first)]\n    (filter (complement first-seq?)\n            (rest (tree-seq first-seq? seq s)))))", "problem": 93, "user": "50ef9a7ae4b0bdaecbb47d9e"}, {"code": "; was a blocker\n(fn __ [arr]\n (letfn \n   [\n      ; is this entity a nested thing e.g. ((2 3))?\n     (is-nested? [p] (if (coll? p) (coll? (first p)) false))       \n      ; Does this have any element that has a true value for is-nested?\n     (has-nested? [arry] (some #(is-nested? %) arry))\n     ; apply logic that brings ((c) ((a) (((b))))) to ((c) (a) (b))\n     (break-down [ary]\n   \t\t\t(if-not (has-nested? ary)\n          ary\n          ; if nested, reduce\n          (let \n            [prod \n             \t(reduce \n           \t\t\t(fn [ay n]\n            \t\t\t(if-not \n              \t\t\t(is-nested? n)\n                      (conj ay n) \n                      (apply conj ay n))  \n           \t\t\t) [] ary)] \n            (if-not \n              (has-nested? prod) \n              \tprod              \t\n            \t\t(break-down prod)\t\t\t\t\t\t\t\t\n            )\n       \t\t)       \t \n     \t)\n     )    \n   ]\n   (break-down arr)\n )  \n)", "problem": 93, "user": "503f872ee4b00d1a725ff2ac"}, {"code": "(let [has-sequential? #(some sequential? %)]\n        (fn [coll]\n            (let [mostly-flatten (fn mostly-flatten [x]\n                                     (if (has-sequential? x)\n                                         (mapcat mostly-flatten x)\n                                       [x]))]\n              (mostly-flatten coll))))", "problem": 93, "user": "4eae5fe4535d7eef30807325"}, {"code": "(fn pf [coll]\n   (let [l (first coll) r (next coll)]\n     (concat \n       (if (and (sequential? l) (not (sequential? (first l))))\n         [l]\n         (pf l))\n       (when (sequential? r)\n         (pf r)))))", "problem": 93, "user": "50bc23e4e4b0594b91591c3c"}, {"code": "(fn pf [coll]\n  (if (empty? coll)\n    nil\n    (if (coll? (first (first coll)))\n      (concat (pf (first coll)) (pf (rest coll)))\n      (cons (first coll) (pf (rest coll))))))", "problem": 93, "user": "509160dae4b0742c82730aef"}, {"code": "(fn [x]\n  (filter #(and (sequential? %) (not-any? sequential? %))\n     (rest (tree-seq sequential? seq x))))", "problem": 93, "user": "50d0d4c8e4b00b15ecee976a"}, {"code": "(fn [s]\n  (letfn [(hc? [e] (some coll? e))\n          (dno [v] (mapcat #(if (hc? %) % [%]) v))]\n    (if (some hc? s)\n      (recur (dno s))\n      s)))", "problem": 93, "user": "50843a4ae4b0c98812d0788b"}, {"code": "(fn flatter\n  [x]\n  (cond\n   (and (sequential? x) (sequential? (first x))) (mapcat flatter x)\n   (sequential? x) [x]\n   :else x))", "problem": 93, "user": "4ffc10aae4b0678c553fc3d6"}, {"code": "(fn [x]\n  (filter #(and (sequential? %) (not-any? sequential? %))\n    (rest (tree-seq #(and (sequential? %) (some sequential? %)) seq x))))", "problem": 93, "user": "4f038567535dcb61093f6b0c"}, {"code": "(fn [S](filter #(not (coll? (first %))) (filter coll? (tree-seq coll? identity S))))", "problem": 93, "user": "5107b86de4b05b2b4eee7495"}, {"code": "(fn f1\n  ([v]\n   (f1 [] v))\n  ([acc v]\n  \t(let [fl (filter coll? v)]\n      (if (empty? fl)\n        (conj acc v)\n        (mapcat (partial f1 acc) fl)))))", "problem": 93, "user": "4f253a49e4b0d66497709ff3"}, {"code": "#(filter (comp not coll? first) (tree-seq (comp coll? first) identity %))", "problem": 93, "user": "4ebaf790535dfed6da9c6d6e"}, {"code": "(fn flat [ss]\n      (reduce (fn [x y]\n         (if (some coll? y) \n            (into [] (concat x (flat y)))\n            (conj x y)\n         )   \n      ) [] ss) \n)", "problem": 93, "user": "4f7b6b90e4b06e829148e1a4"}, {"code": "#(mapcat (fn [[a b]] ({[false b] [a]} [(coll? b) (if (coll? a) (first a))]))\n           (partition 2 1 (tree-seq coll? seq %)))", "problem": 93, "user": "4ff67852e4b0678c553fc37e"}, {"code": "(fn f [x]\n  (if (and (coll? x) (some coll? x)) (mapcat f x) [x]))", "problem": 93, "user": "50d93c53e4b0fd36a4b89223"}, {"code": "(fn [xs]\n  (letfn\n    [(nested-list? [xs]\n                   (and (coll? xs)\n                        (every? coll? xs)))]\n    (filter\n     (complement nested-list?)\n     (tree-seq nested-list? seq xs))))", "problem": 93, "user": "50217818e4b00bba4502f7a7"}, {"code": "(fn pflat [coll-seq]\n  (apply concat\n         (for [c coll-seq]\n           (if (and (coll? c) (not (coll? (first c))))\n             [c]\n             (pflat c)))))", "problem": 93, "user": "51281b25e4b03a34742b4304"}, {"code": "(fn f [xs]\n  (if (not-any? sequential? xs)\n    [xs]\n    (mapcat #(f %) xs)))", "problem": 93, "user": "510acd6ee4b078ea719210f4"}, {"code": "(fn partial-flatten [S]\n  \n  (mapcat (fn [el]\n            (if (sequential? (first el))\n\t\t\t\t\t\t\t(partial-flatten el) \n              [el]\n              )) S)\n )", "problem": 93, "user": "50d3b03fe4b030b634c368b9"}, {"code": "(fn flatter [c]\n  (loop [c c\n         r []]\n    (cond\n     (nil? (first c)) r\n     (coll? (ffirst c)) (recur (concat (first c) (next c)) r)\n     :else (recur (rest c) (concat r (vector (first c)))))))", "problem": 93, "user": "5123ac8ee4b061b4c6f0e0b1"}, {"code": "(fn f [v]\n  (if (coll? v)\n    (if (empty? v) v\n    (let [w (f (first v))]\n      ((if (and (coll? w) (some coll? w))\n        concat\n        cons) w (f (rest v)))))\n    v))", "problem": 93, "user": "50fbdacfe4b0d10d794c19f0"}, {"code": "(fn part-flat [x]\n          (if (not (sequential? (first x))) [x]\n            (reduce concat (map part-flat x))))", "problem": 93, "user": "50e4f4e9e4b049a987753896"}, {"code": "(fn [s]\n\t(filter\n     \t#(if (sequential? %) (not-any? sequential? %) nil) ; flat?\n        (tree-seq sequential? seq s)))", "problem": 93, "user": "4e8768f6535dceadca469850"}, {"code": "(fn q93 [l]\n  (mapcat \n    #( if (coll? (first %))\n      (q93 %)\n      [%] \n      )\n    l)\n  )", "problem": 93, "user": "4fbbcf0ce4b081705acca2ee"}, {"code": "(fn [x]\n  (->> (tree-seq sequential? seq x)\n       (rest)\n       (filter #(and (sequential? %) (not-any? sequential? %)))))", "problem": 93, "user": "4f03f197535dcb61093f6b84"}, {"code": "(fn ! [col]   \n   (loop [result [] elements col]     \n     (if elements\n       (recur \n         (if (coll? (first (first elements)))\n           (into result (! (first elements)))\n           (conj result (first elements))\n           )\n         (next elements))\n       result\n       )     \n     )\n   )", "problem": 93, "user": "5106dc1be4b01150e115ebf0"}, {"code": "(fn [xs]\n  (if (every? #(and (sequential? %) (not-any? sequential? %)) xs)\n    xs\n    (recur (reduce #(if (not-any? sequential? %2)\n                      (conj %1 %2)\n                      (into %1 %2))\n                   []\n                   xs))))", "problem": 93, "user": "511442d0e4b0e9c109bb74d5"}, {"code": "(fn pflat [xs]\n  (reduce\n   (fn [acc, x]\n     (if (and\n          (coll? x)\n          (some coll? x))\n       (concat acc (pflat x))\n       (concat acc (list x))))\n   []\n   xs))", "problem": 93, "user": "51365524e4b04ac1f358dd52"}, {"code": "(fn [x]\n  ((fn l [y z]\n    (let [f (first y)\n          r (rest y)]\n      (if (empty? y)\n        z\n        (if (not (some coll? f))\n          (l r (conj z f))\n          (l r (l f z))))))\n  x []))", "problem": 93, "user": "507ef25ce4b0f753b6f9788e"}, {"code": "(fn semi-flatten [s] (mapcat #(if (= (count (flatten %)) (count %)) (list (flatten %)) (semi-flatten %)) s))", "problem": 93, "user": "5138d08be4b0a5db03d727db"}, {"code": "(fn unwrap[xs]\n  (letfn\n      [(impl [ [x & _ :as xs] ]\n         (if (sequential? x)\n           (if (= 1 (count xs)) (recur x)\n               (mapcat impl xs)\n               )\n           [xs]))]\n    (mapcat impl [xs])))", "problem": 93, "user": "50fa01bce4b07934dda8b0ba"}, {"code": "(fn f [xs]\n  (if (every? sequential? xs) (mapcat f xs) [xs]))", "problem": 93, "user": "5125745ae4b05d10e3e395f9"}, {"code": "(fn myfltn \n  ([col]\n   (myfltn col []))\n  ([col init]\n   (if (and (coll? col)\n            (not (empty? col)))\n     (if (coll? (first col))\n       (concat (myfltn (first col)) (myfltn (rest col)))\n       (conj [] col) ))))", "problem": 93, "user": "513cb853e4b0b86ece9f322b"}, {"code": "(fn flatteno\n    [coll]\n    (if (not-any? coll? coll) [coll]\n        (reduce #(into %1 (flatteno %2)) [] coll)))", "problem": 93, "user": "50b35486e4b03ea88043356a"}, {"code": "(fn f[l] (mapcat #(if (coll?(first %)) (f %) [%])l))", "problem": 93, "user": "4f296a80e4b0d6649770a02a"}, {"code": "(fn flatten-seq \n  [coll]\n  (if (not-any? coll? coll)\n    [coll]\n    (mapcat flatten-seq coll)))", "problem": 93, "user": "4fdf566fe4b05e33b9224f99"}, {"code": "(fn aa [x] \n   (let [jj  (map \n              #(if (or (= 1 (count %)) (= (flatten %) %)) (flatten %)\n                (map (fn [y] (flatten y)) %))\n              x)]\n  \n   (reduce #(if (= %2 (flatten %2)) (conj %1 %2) \n             (loop [ans %1 x %2]\n               (if (empty? x) ans\n                   (recur (conj ans (first x)) (rest x))\n                 )\n              )\n            ) [] jj)  \n     )\n  )", "problem": 93, "user": "5105ed16e4b01150e115ebe2"}, {"code": "(fn pf [c]\n  (letfn [(lowest-coll? [c] ((complement sequential?) (first c)))]\n    (reduce concat \n            (map #(if (lowest-coll? %) [%] (pf %)) c))))", "problem": 93, "user": "514721c6e4b0d520409ed392"}, {"code": "(fn [n]\n  (loop [n n]\n    (if (nil? (some #(some coll? %) n))\n      n\n      (recur (reduce (fn [lst i] (if (some coll? i) (into lst i) (into lst [i]))) [] n)))))", "problem": 93, "user": "5124619ae4b02c3f2a072ccd"}, {"code": "(fn partially-flatten [xs] \n  (reduce #(if (every? sequential? %2) (into %1 (partially-flatten %2)) (conj %1 %2)) [] xs))", "problem": 93, "user": "513d121fe4b0e544971636a2"}, {"code": "(fn f [s] \n  (if (sequential? (first s)) (mapcat f s) [s])\n  )", "problem": 93, "user": "514457fbe4b0b4fb4ace5f43"}, {"code": "(fn pf [x]\n  (if (empty? x)\n    x\n    (if (coll? (ffirst x))\n      (recur (cons (ffirst x) (concat (rest (first x)) (rest x))))\n      (cons (first x) (pf (rest x))))))", "problem": 93, "user": "504e12ade4b078edc5f593b7"}, {"code": "(fn [s]\n  (filter #(and (sequential? %) (not-any? sequential? %))\n    (rest (tree-seq #(and (sequential? %) (some sequential? %)) seq s))))", "problem": 93, "user": "515a6151e4b0394f658fe241"}, {"code": "(fn [s]\n  (filter (comp not sequential? first)\n          (rest (tree-seq (comp sequential? first) seq s))))", "problem": 93, "user": "5142ea50e4b0c172af7558ca"}, {"code": "(fn partial-flatten [sq]\n  (mapcat #(if (and (sequential? %)\n                 (not (sequential? (first %))))\n             (list %)\n             (partial-flatten %)) sq))", "problem": 93, "user": "515737f0e4b0b0b4b87062d0"}, {"code": "(fn partially-flatten [items]\n  (cond (not (sequential? items)) items\n        (some sequential? items) (mapcat partially-flatten items)\n        :else [items]))", "problem": 93, "user": "510cd1dde4b078ea71921124"}, {"code": "(fn ff[x] (mapcat #(if (coll? (first %)) (ff %) (list %)) x))", "problem": 93, "user": "500b61b1e4b03d00572d2d81"}, {"code": "(fn part-flat [coll]\n  (reverse (reduce (fn a [x y]\n            (if (and (sequential? y) (some sequential? y))\n                (concat (reduce a [] y) x)\n                (cons y x))) [] coll)))", "problem": 93, "user": "50c8697ce4b00bb60fe0c53f"}, {"code": "#(->> %\n      (tree-seq (comp sequential? first) seq)\n      (remove (comp sequential? first)))", "problem": 93, "user": "50479524e4b0371827a27bc4"}, {"code": "(fn [s]\n  (filter #(and  (sequential? %)\n                 (empty? (filter sequential? %)))\n          (rest (tree-seq sequential? seq s))))", "problem": 93, "user": "512eb723e4b0b740abc5982b"}, {"code": "(fn [s]\n    (loop [res []\n           todo s]\n      (if (empty? todo)\n        res\n        (let [f (first todo)\n              r (rest todo)]\n          (if (not-any? coll? f)\n            (recur (conj res f) r)\n            (recur res (concat f r)))))))", "problem": 93, "user": "5165a235e4b079ad97ec44ac"}, {"code": "(fn [s]\n  (loop [result [] remains s]\n    (if (empty? remains)\n      result\n      (let [f (first remains)]\n        (if (sequential? (first f))\n          (recur result (concat (cons (first f) (rest f)) (rest remains)))\n          (recur (conj result f) (rest remains)))))))", "problem": 93, "user": "512d3304e4b040332b905b2d"}, {"code": "(fn almost-flat  [s] \n  (cond (not (coll? s)) [s] (not-any? coll? s) [s] :else (->> (map almost-flat s) (reduce concat))  )\n  )", "problem": 93, "user": "51729002e4b044b2ef48a850"}, {"code": "(fn f [x]\n    (if (coll? (first x)) \n      (reduce concat (map f x))\n      [x]))", "problem": 93, "user": "513b77f3e4b00f740c76c403"}, {"code": "(fn [l]\n  (filter #(and (sequential? %) (not (sequential? (first %))))             \n          (tree-seq sequential? identity l)))", "problem": 93, "user": "50435689e4b034ff00315d21"}, {"code": "(fn pf [coll]\n  (let [h (first coll)\n        t (rest coll)]\n    (concat\n      (if (every? #(not (coll? %)) h)\n        (list h)\n        (pf h))\n      (if (not (empty? t))\n        (pf t)\n        nil))))", "problem": 93, "user": "4eec82fe535d93acb0a668ae"}, {"code": "(fn pa [x]\n  (->> (tree-seq coll? identity x)\n       (remove (complement coll?))\n       (filter #(not (coll? (first %))))))", "problem": 93, "user": "511b9017e4b00c2a1fa7ff6b"}, {"code": "(fn [s]\n  (loop [remaining s\n         result []]\n    (if (empty? remaining)\n      result\n      (if (coll? (first (first remaining)))\n        (recur (concat (first remaining) (rest remaining)) result)\n        (recur (rest remaining) (conj result (first remaining)))))))", "problem": 93, "user": "51899891e4b0288ada3dbdab"}, {"code": "(fn f [i] (if (some coll? i) (mapcat f i) [i]))", "problem": 93, "user": "4e43b0d9535dc968683fc4a3"}, {"code": "(fn [coll]\n  (letfn [(step [coll result]\n            (if (seq coll)\n              (let [first-ele (first coll)]\n                (step (next coll)\n                  (if (some coll? first-ele)\n                    (reduce #(conj %1 %2) result (step first-ele []))\n                    (conj result first-ele))))\n              result)\n            )]\n    (step coll [])))", "problem": 93, "user": "514d7e29e4b019235f6c0587"}, {"code": "(fn leafs [tree]\n  (letfn [(height [coll]\n            (if (not (sequential? coll))\n              0\n              (inc (apply max (map height coll)))))]\n    (if (<= (height tree) 1)\n      [tree]\n      (mapcat leafs tree))))", "problem": 93, "user": "5186134ce4b0da5a5be3bac7"}, {"code": "(fn pf [coll]\n  (let [l (first coll) r (next coll)]\n    (concat \n      (if (and (sequential? l) (not (sequential? (first l))))\n        [l]\n        (pf l))\n      (when (sequential? r)\n        (pf r)))))", "problem": 93, "user": "4fe97adde4b0547ebccb245e"}, {"code": "(fn [vs]\n        (letfn [(nested-seq? [v]\n                             (and (sequential? v) \n                                  (every? #(not (sequential? %)) v)))\n                (flt [coll]\n                     (if (nested-seq? coll) (if (empty? coll) () [coll])\n                       (concat (flt (first coll)) (flt (rest coll)))))]\n               (if (nested-seq? vs) vs (flt vs))))", "problem": 93, "user": "51780f88e4b03d69594194c9"}, {"code": "(fn [s]\n     (filter #(every? identity (map (complement sequential?) %))\n             (tree-seq #(every? identity (map sequential? %))\n                     identity s)))", "problem": 93, "user": "50f48298e4b004d364930527"}, {"code": "(fn partial-flatten [seq]\n  (mapcat (fn [elem]\n            (cond\n             (not (coll? elem)) [elem]\n             (not-any? coll? elem) [elem]\n             :else (partial-flatten elem)))\n          seq)\n  )", "problem": 93, "user": "4f4e91a9e4b03ad3f0c10cca"}, {"code": "(fn f\n  ([s]\n   (if  (not-any? coll? s)\n     (list s)\n     (mapcat f s))))", "problem": 93, "user": "50b668dde4b08fb537db98f2"}, {"code": "(fn pflat [xs] (mapcat #(if (= % (flatten %)) [%] (pflat %)) xs))", "problem": 93, "user": "515fb48fe4b0e2be8aa20bd5"}, {"code": "(fn f1 [s]\n  (let  [g (fn [c] (if (not (sequential? (first c)))\n                     [c]\n                     (f1 c)))]\n    (if (empty? s) nil\n        (concat (g (first s)) (f1 (rest s))))))", "problem": 93, "user": "518ccf6be4b05e6c8537e386"}, {"code": "(fn F [coll]\n  (mapcat #(if (sequential? (first %)) (F %) [% ]) coll))", "problem": 93, "user": "519b2570e4b0ac1b7dced6a3"}, {"code": "(fn [l] (loop [ls l] \n(if (every?  #(not (coll? (first %))) ls)\nls\n(recur (apply concat (map \n#(if (not (coll? (first %))) \n(vector %) %\n ) ls))))))", "problem": 93, "user": "517945dce4b0684c1c981a43"}, {"code": "(fn [x]\n  (loop [c x\n         l []]\n    (if (= c l) c\n                (recur\n                  (reduce\n                    #(if (some sequential? %2) (concat % %2) (concat % [%2]))\n                    []\n                    c)\n                  c))))", "problem": 93, "user": "51b3f109e4b0f094dd986fa9"}, {"code": "(fn fla [x] \n  (let[f (first x) n (next x)]\n    (concat\n         (if(sequential? (first f)) (fla f) [f])\n         (if(sequential? (first n)) (fla n) [])\n    ) \n   )\n )", "problem": 93, "user": "51bec919e4b013aa0d74b800"}, {"code": "(fn [s] (partition (count (flatten (first s))) (flatten s)))", "problem": 93, "user": "51b793d3e4b0d906fcd71d38"}, {"code": "(fn [c]\n  (remove nil?\n          (loop [f [] r c]\n            (let [s (first r)\n                  i (first s)\n                  e (rest r)]\n              (if (empty? r)\n                f (if (coll? i)\n                    (recur f (conj e (second s) i))\n                    (recur (conj f s) e)))))))", "problem": 93, "user": "512f06c5e4b0762be4c7aad7"}, {"code": "(fn [x]\n  (let [b #(every? sequential? %)]\n    (filter (complement b)\n    (tree-seq b seq x))))", "problem": 93, "user": "4fa340b4e4b081705acca18c"}, {"code": "(fn [x] (filter #(= % (flatten %)) (tree-seq sequential? seq x)))", "problem": 93, "user": "51cbdee1e4b08d8387cbede1"}, {"code": "(fn [coll]\n    (filter (complement (comp coll? first))\n            (tree-seq (comp coll? first) seq coll)))", "problem": 93, "user": "51424cc8e4b0b50abeb46b34"}, {"code": "(fn [xs] (letfn [(partial-flatten\n                  [x]\n                  (let [y (first x)\n                        z (rest x)]\n                    (if (empty? x)\n                      x\n                      (if (and (coll? y) (some coll? y))\n                        (concat (partial-flatten y) (partial-flatten z))\n                        (cons y (partial-flatten z))))))]\n           (partial-flatten xs)))", "problem": 93, "user": "51307b84e4b08c712d3fae39"}, {"code": "(fn flat [x] \n  (if (and (coll? x) (some #(coll? %) x))\n    (mapcat flat x)\n    [x]))", "problem": 93, "user": "5102ac9de4b00c483ae176fa"}, {"code": "(fn p [[h & t]]\n  (when-not (nil? h)\n    (into (if (coll? (first h)) (p h) [h])\n          (p t))\n    ))", "problem": 93, "user": "51b9d1f0e4b0e871ca49590b"}, {"code": "(fn [s] (partition (count (flatten (first s))) (flatten s)))", "problem": 93, "user": "50bca033e4b0594b91591c5d"}, {"code": "(fn partially-flatten [x]\n  (if (and (coll? x) (some coll? x))\n    (mapcat partially-flatten x)\n    [x]))", "problem": 93, "user": "507b7dbee4b09034bfeeb71e"}, {"code": "(fn [s]\n  (filter #(and (sequential? %) (not (sequential? (first %))))\n    (tree-seq sequential? seq s)))", "problem": 93, "user": "4f38d6bbe4b0e243712b1ee2"}, {"code": "(fn my-flat [x] \n    (if (some coll? x)\n      (mapcat my-flat x)\n      (vector x)))", "problem": 93, "user": "51c09719e4b0c9c82288293c"}, {"code": "(fn my-flat [[x & xs :as xxs]]\n  (when (not-empty xxs) \n    (lazy-cat\n      (if (nil? (some sequential? x)) \n        [x] (my-flat x))\n      (my-flat xs))))", "problem": 93, "user": "51cdd3f0e4b0e42293a2254b"}, {"code": "(fn f [x]\n  (if (some coll? x) (mapcat f x) [x]))", "problem": 93, "user": "5054bc87e4b0b1b9d1860eb0"}, {"code": "#(loop [s %\n        acc []]\n   (cond\n    (empty? s) acc\n    (coll? (first (first s))) (recur (concat (first s) (rest s)) acc)\n    :otherwise (recur (rest s) (conj acc (first s)))))", "problem": 93, "user": "51789dfae4b03d69594194d7"}, {"code": "(fn fs [coll]\n  (let [r (mapcat #(if (and (coll? %) (some coll? %)) (fs %) [%]) coll)]\n    (if (= coll r) r (recur r))))", "problem": 93, "user": "511d6a01e4b022853b0e07a5"}, {"code": "(fn [x]\n  (filter #(and (sequential? %)\n                (every? (complement sequential?) %))\n          (tree-seq sequential? seq x)))", "problem": 93, "user": "5164867fe4b003cf19fdde3e"}, {"code": "(fn f [coll]  \n   (if (every? coll? coll)\n     (if (not-any? coll? (apply concat coll))\n        coll\n        (mapcat f coll)\n     )\n     [coll]\n   )  \n)", "problem": 93, "user": "51ba8f82e4b0fe3ecfb46434"}, {"code": "(fn f [[x & xs :as xxs]]\n  (cond\n   (nil? xxs) []\n   (or (not (coll? x))\n       (and (coll? x)\n            (not-any? #(coll? %) x)))\n   (cons x (f xs))\n   :else\n   \t(concat (f x) (f xs))))", "problem": 93, "user": "51efd397e4b0249c592fbdeb"}, {"code": "(fn [l]\n   (let [? (fn [l] (and (coll? l)\n                        (not (coll? (first l)))))\n         f (fn f [x] (if (? x) x (f (first x))))]\n     (loop [l l\n            acc []]\n       (if (empty? l)\n         acc\n         (recur (rest l)\n                (if (? (first l))\n                  (conj acc (first l))\n                  (into acc (map f (first l)))))))))", "problem": 93, "user": "50a5b7e9e4b0aa96157e2610"}, {"code": "(fn rec-flatten [ r [a & xs :as v]]\n    (println \"rec-flatten \" r \" ; \" v)\n    (if (nil? a) \n        r\n        (if (sequential? a)\n            (if (reduce #(and %1 (not (sequential? %2))) true a)\n                (rec-flatten (concat r [a]) xs)\n                (rec-flatten (concat r (rec-flatten [] a)) xs))\n            (rec-flatten (conj r a) xs)))) []", "problem": 93, "user": "51f59607e4b0abb92f97f9d5"}, {"code": "(fn f [s]\n    (if (some coll? s) (mapcat f s) (list s)))", "problem": 93, "user": "5141abf1e4b02fd87f5064c3"}, {"code": "(fn flatn [x] (if (coll? x) (if (coll? (first x)) (mapcat flatn x) [x]) [x]))", "problem": 93, "user": "51bd1a0de4b0df1216cefd93"}, {"code": ";stolen from adereth\n(fn [x]\n  (let [b #(every? sequential? %)]\n    (filter (complement b)\n    (tree-seq b seq x))))", "problem": 93, "user": "51d96ad0e4b02ceefd94774f"}, {"code": "(fn trim-parens [xs]\n  (filter #(= (flatten %) %) \n          (tree-seq sequential? identity xs)))", "problem": 93, "user": "50c781bbe4b00bb60fe0c535"}, {"code": "(fn flat [ss]\n  (mapcat #(if (coll? (first %)) (flat %) [%]) ss))", "problem": 93, "user": "51944aaae4b0142f60b4aedc"}, {"code": "(comp \n (partial filter #(= (flatten %) %)) \n (partial tree-seq coll? identity))", "problem": 93, "user": "5201572be4b0d7096e99ddbb"}, {"code": "(fn fun [coll]\n\t(reduce #(concat % %2)\n\t\t'()\n\t\t(map #(if (coll? (first %)) (fun %) (list %)) coll)))", "problem": 93, "user": "520242bae4b030ee0c5b26e3"}, {"code": "(fn pflatten [xs]\n  (if (sequential? (first xs))\n    (concat (pflatten (first xs)) (when (not-empty (rest xs)) (pflatten (rest xs))))\n    [xs]))", "problem": 93, "user": "52015698e4b0d7096e99ddba"}, {"code": "(fn \n  [q]\n  (let [flat (fn flat [acc v]\n               (if (= v (flatten v))\n                 (conj acc v)\n                 (let [[k & xs] v]\n                   (if (nil? xs)\n                     (flat acc k)\n                     (flat (flat acc k)\n                           xs)))))\n        ]\n    (flat [] q)\n  ))", "problem": 93, "user": "513fab65e4b00f13ea1bd891"}, {"code": "(fn f [c] (when-let [x (first c)] (concat (if (some #(sequential? %) x) (f x) [x]) (f (rest c)))))", "problem": 93, "user": "51f66e0ee4b06ff1c25c52c3"}, {"code": "#(remove (partial every? coll?) (tree-seq (partial every? coll?) identity %))", "problem": 93, "user": "521e8227e4b0dd19981ad082"}, {"code": "(fn [v]\n  (let [s sequential?]\n  (clojure.walk/postwalk #(if (s %) \n                             (if (= 1 (count %))\n                               (flatten %)\n                               (if (and (s (last %)) (s (first (last %))))\n                                 (apply list* %)\n                                 %))\n                            %) v)))", "problem": 93, "user": "51f28a64e4b0210f90e7454e"}, {"code": "(fn partial-flatten [coll]\n  (mapcat\n   #(if (some coll? %) (partial-flatten %) [%])\n   coll))", "problem": 93, "user": "4fe13ad7e4b0dd6cd5ce3632"}, {"code": "(fn flat-e\n  [x]\n  (let [level1? (fn [x] (zero? (count (filter #(sequential? %) x))))]\n    (cond\n      (empty? x) '()\n      (level1? x) (list x)\n      :else (concat (flat-e (first x)) (flat-e (rest x))))))", "problem": 93, "user": "52084f75e4b01ce6bbf31dde"}, {"code": "(fn _ [x]\n          (if \n            (not (sequential? (first x))) [x]\n            (reduce concat (map _ x))\n            ))", "problem": 93, "user": "52196842e4b0890f2f822bfa"}, {"code": "(fn he [c]\n  (let [l (first c) r (next c)]\n    (concat\n     (if (some sequential? l)\n        (he l)\n       [l])\n      (when (sequential? r)\n        (he r)))))", "problem": 93, "user": "511b810ce4b07ab9ec456182"}, {"code": "(fn l [x]\n  \t(if (some sequential? x) (mapcat l x) [x]))", "problem": 93, "user": "5098f5d6e4b0cae2931060a4"}, {"code": "(fn pflatten [tree]\n  (if (every? sequential? tree)\n    (mapcat pflatten tree)\n    [tree]))", "problem": 93, "user": "5225b16de4b0d2f5d1e2c0ed"}, {"code": "(fn part [coll]\n  (let [not-coll? #(not (coll? %))\n        flat? #(and (coll? %) (every? not-coll? %))]\n    (if (or\n          (not-coll? coll)\n          (flat? coll))\n      [coll]\n      (mapcat part coll))))", "problem": 93, "user": "514c2d05e4b02b8cbb2a9278"}, {"code": "(fn [l]\n  (let [n (mapcat #(if (every? coll? %) % [%]) l)]\n    (if (= l n) l\n      (recur n))))", "problem": 93, "user": "522b922ee4b0d34ee08e71c3"}, {"code": "mapcat #(if (seq? (first %))\n       (map flatten %)\n       [(flatten %)])", "problem": 93, "user": "52379c46e4b0fae3832e99db"}, {"code": "(fn undepth [coll]\n  (if (sequential? (first coll))\n    (mapcat #(undepth %) coll)\n    (list coll)))", "problem": 93, "user": "523b82efe4b07becd5be21f0"}, {"code": "(fn tf[x] \n  (letfn [(nested? [x] (if (coll? x) (not (every? (complement coll?) x)) false))\n          (flat [coll]\n                  (when-let [c (seq coll)]\n                    (let [x (first c)]\n                      (if (nested? x)\n                        (concat (flat x) (flat (rest c)))\n                        (cons x (flat (rest c)))))))]\n                (if (nested? x) (flat x) x)))", "problem": 93, "user": "4eb2eae5535d7eef30807351"}, {"code": "(fn semiflat\n  [s]\n  (letfn [(can-have-childs? [t]\n            (and (sequential? t) \n                 (seq (filter sequential? t))))]\n    (filter (complement can-have-childs?) \n            (tree-seq can-have-childs? #(filter sequential? %) s))))", "problem": 93, "user": "5048202fe4b0ec70b3ef8d9a"}, {"code": "#(filter \n  (every-pred sequential? (partial not-any? sequential?)) \n  (tree-seq sequential? seq %))", "problem": 93, "user": "5246e945e4b0644eb7b0783b"}, {"code": "(fn flatten-almost\n  [s]\n  (let [lowest? #(and (sequential? %) (not-any? sequential? %))\n        atomic? #(or (not (sequential? %)) (lowest? %))]\n    (lazy-seq\n      (cond (lowest? s) s\n            (every? atomic? s) s\n            :else (let [[flat [proc & the-rest]] (split-with atomic? s)]\n                    (concat flat\n                            (flatten-almost proc)\n                            (flatten-almost the-rest)))))))", "problem": 93, "user": "511b233ae4b07ab9ec456180"}, {"code": "(fn [puzzle] \n   (filter #(and (sequential? %) \n                 (every? (comp not sequential?) %) ) \n           (tree-seq sequential? identity puzzle)))", "problem": 93, "user": "523a9fc9e4b081681ca7adca"}, {"code": "(fn ff [coll]\n  (reduce #(if (not-any? coll? %2)\n             (conj % %2) (into % (ff %2))) [] coll))", "problem": 93, "user": "52479487e4b05ef8e38e6373"}, {"code": "(fn [x]\n  (letfn [(g [x] (and (coll? x) (not-any? coll? x)))]\n    (filter g (tree-seq coll? identity x))))", "problem": 93, "user": "4fe8fda4e4b0547ebccb2438"}, {"code": "(fn pflat [s & acc]\n  (if (empty? s) acc\n      (let [s1 (first s)]\n        (if (coll? (first s1))\n          (recur (concat [(first s1)] (rest s1) (rest s)) acc)\n          (recur (rest s) (concat acc [s1]))))))", "problem": 93, "user": "4fbd12a5e4b081705acca2fd"}, {"code": "(fn flat [x]\n   (letfn\n     [\n      (sqb? [s] (or (list? s) (seq? s) (vector? s)))\n      (depth\n       [s]\n       (if (sqb? s)\n         (if (= (flatten s) s)\n           1\n           (+ 1 (apply max (map depth s)))\n           )\n         0\n         )\n       )\n      ]\n     (if (= 1 (depth x))\n       (list x)\n       (apply\n        concat\n        (map flat x)\n        )\n       )\n     )\n   )", "problem": 93, "user": "52586d24e4b0cb4875a45cb0"}, {"code": "(fn pf [seq]\n  (prn seq)\n  (cond\n   (empty? seq)\n     seq\n   (and (coll? (first seq)) (not (coll? (ffirst seq))))\n     (concat [(first seq)]\n             (pf (rest seq))) \n   :else\n     (concat (pf (first seq)) (pf (rest seq)))))", "problem": 93, "user": "524cdd51e4b0752c4cb68ccc"}, {"code": "(fn [root]\n    (filter\n      #(and\n        (sequential? %)\n        (every? (complement sequential?) %))\n      (tree-seq sequential? identity root)))", "problem": 93, "user": "52699a0ee4b03e8d9a4a71f2"}, {"code": "(fn lift [s] \n  (if (not-any? coll? s) \n    (list s)\n    (mapcat lift s)))", "problem": 93, "user": "51c19873e4b0d204dbe2ca0d"}, {"code": "(fn [xs]\n  (filter #(and (sequential? %) (not-any? sequential? %))\n          (tree-seq #(and (sequential? %) (some sequential? %)) seq xs)))", "problem": 93, "user": "4f21838fe4b0d66497709fd2"}, {"code": "(fn f [c]\n  (let [l (first c) r (next c)]\n    (concat\n     (if (-> l first coll? not) [l] (f l))\n     (if r (f r)))))", "problem": 93, "user": "524ae8e6e4b09eba1c0223b5"}, {"code": "(fn partial-flatten [coll]\n  (let [ele (first coll)\n        coll- (rest coll)]\n      (if (nil? ele)\n         '()\n         (if (sequential? ele)\n           (concat (if (sequential? (first ele))\n                   (partial-flatten ele)\n                   (list ele)) (partial-flatten coll-))\n           (concat (list ele) (partial-flatten coll-))))))", "problem": 93, "user": "511e763ce4b03e81d390ac29"}, {"code": "(fn c-flatten [coll] \n  (let [l (first coll) r (next coll)]\n    (concat \n     (if (sequential? (first l)) (c-flatten l) [l])\n     (if (sequential? (first r)) (c-flatten r)))))", "problem": 93, "user": "52463059e4b09dbe66b56198"}, {"code": "(fn [s]\n    (letfn [(branch? [n] (and (sequential? n) (sequential? (first n))))]\n      (->> s\n        (tree-seq branch? identity)\n        (remove branch?))))\n\n\n; (fn doit [s] (mapcat (fn [x] (if (and (sequential? x) (sequential? (first x))) (doit x) (list x))) s))", "problem": 93, "user": "525f51bde4b0cb4875a45dc8"}, {"code": "(fn [s]\n  (filter\n   (fn [c] (not (coll? (first c))))\n   (tree-seq (fn [n] (and (coll? n) (coll? (first n)))) identity s)))", "problem": 93, "user": "50bce014e4b0594b91591c63"}, {"code": "(fn f [s] (if (-> s first coll? not) [s] \n            (mapcat f s)))", "problem": 93, "user": "523b1988e4b02f719975bdbc"}, {"code": "#(filter (complement nil?)\n           (loop [stock [] analyze (first %)  sigs (next %) ]\n             (if (sequential? (first analyze))\n               (recur stock (first analyze) (cons (next analyze) sigs))\n               (if (nil? sigs)\n                 (conj stock analyze)\n                 (recur (conj stock analyze) (first sigs) (next sigs))))))", "problem": 93, "user": "50550f43e4b0b1b9d1860eb7"}, {"code": "(fn part-flatten [col]\n  (reduce\n    #(if (coll? (first %2))\n       (apply conj %1 (part-flatten %2))\n       (conj %1 %2))\n    []\n    col))", "problem": 93, "user": "526ee63de4b03e8d9a4a733f"}, {"code": "(fn [s]\n  (let [p #(and (sequential? %) (not (sequential? (last %))))]\n    (filter p\n            (tree-seq (complement p) seq s))))", "problem": 93, "user": "523ed522e4b057c4b7cd0a78"}, {"code": "(fn partial-flatten\n  [sequence]\n  (mapcat\n    (fn [element]\n      (cond \n        (and (coll? element) (some coll? element)) (partial-flatten element)\n        (coll? element) [element]\n        :else [[element]]))\n    sequence))", "problem": 93, "user": "5268eb68e4b03e8d9a4a71c6"}, {"code": "(fn f [xs]\n  (if (every? sequential? xs) (mapcat f xs) [xs]))", "problem": 93, "user": "5272d4b7e4b03e8d9a4a7453"}, {"code": "(fn fltr [src]\n\t(let [ s (str src)]\n      (read-string(apply str (list (first s)(apply str (re-seq #\"[\\[\\(\\{][^\\[^\\]^\\(^\\)^\\{^\\}]+[\\]\\)\\}]\" s))(last s))))\n     )\n   )", "problem": 93, "user": "5274eb56e4b03e8d9a4a74bb"}, {"code": "(fn r [coll]\n  (if (not (sequential? (first coll))) [coll]\n    (apply concat (map r coll))))", "problem": 93, "user": "51e00020e4b01188f0627534"}, {"code": "(fn f [x]\n  (if ((comp not coll? first) x) (list x)\n    (apply concat (map f x))))", "problem": 93, "user": "52667ecfe4b03e8d9a4a713e"}, {"code": "(fn p93 [lst0]\n  (letfn [(p [lst]\n           (if (every? (complement coll?) lst) [lst]\n                  (reduce concat []  (map p lst))))]\n    (p lst0)))", "problem": 93, "user": "5272669de4b03e8d9a4a742e"}, {"code": "(letfn [(isflat? [l] (every? #(not (coll? %)) l))]\n  (fn flat [x]\n    (if (isflat? x)\n      [x]\n      (reduce #(if (isflat? %2)\n                 (conj % %2)\n                 (vec (concat % (flat %2))))\n              [] x))))", "problem": 93, "user": "52736ca1e4b03e8d9a4a747e"}, {"code": "(fn fl [s] (mapcat #(if (coll? (first %)) (fl %) [%]) s))", "problem": 93, "user": "519ef784e4b087743fad2198"}, {"code": "(fn almost-flatten [coll]\n   (reduce (fn [acc s]\n             (if (not-any? sequential? s)\n               (conj acc s)\n               (vec (concat acc (almost-flatten s)))))\n           [] coll))", "problem": 93, "user": "4f35b2ace4b0e243712b1ec5"}, {"code": "(letfn [(min-depth [col] (if (not (coll? col))\n                           0\n                           (inc (apply min (map min-depth col)))))\n        (pfl [col] (apply concat (for [x col]\n                                   (if (< (min-depth x) 2)\n                                     [x]\n                                     (pfl x)))))]\n  pfl)", "problem": 93, "user": "5233ad08e4b07e3ee2be83ac"}, {"code": "(fn [sqn]\n  (filter #(not (empty? %))\n          (loop [s (first sqn) t (rest sqn) r []]\n            (cond (and (empty? s) (empty? t)) r\n                  (and (> (count s) 1) (sequential? (first s))) (recur (first s) (conj (rest s) t) r)\n                  (sequential? (first s)) (recur (first s) t r)\n                  :else\n                  (recur (first t) (rest t) (conj r s))))))", "problem": 93, "user": "4f2d5f5de4b0d6649770a05a"}, {"code": "(fn [xs-in] (filter (fn [z] (not (nil? z))) (loop [result [] xs xs-in] (println result xs)\n              (if (nil? xs) result\n                (if (coll? (ffirst xs))\n                  (recur result (cons (ffirst xs) (cons (next (first xs)) (next xs))))\n                  (recur (conj result (first xs)) (next xs))\n                )\n              )\n            )\n                    )\n)", "problem": 93, "user": "526dd90de4b03e8d9a4a72fe"}, {"code": "(fn f1 [s] (apply concat (for [i s] (if (coll? (first i)) (f1 i) [i]))))", "problem": 93, "user": "528e64b7e4b0239c8a67aedd"}, {"code": "(fn [t] (remove #(some coll? %) (tree-seq #(some coll? %) seq t)))", "problem": 93, "user": "4fa05b99e4b0dcca54ed6d47"}, {"code": "(fn f [s]\n  (mapcat\n   #(cond\n     (not (coll? %)) (list %)\n     (= 1 (count %)) (list (flatten %))\n     (not-any? coll? %) (list %)\n     :else (f %)) s))", "problem": 93, "user": "526439a4e4b03e8d9a4a70cc"}, {"code": "(fn part [seqs]\n  (let [a (atom [])]\n      (letfn [(p [s]\n                                        ;(println \"@\" s)\n                (doall\n                 (if\n                     (and\n                      (sequential? s)\n                      (empty? (filter sequential? s)))\n                   (swap! a conj s)\n                   (map p s))))] (p seqs)) @a))", "problem": 93, "user": "52319066e4b0e2e8de81d1e9"}, {"code": "(fn partially-flatten-seq [colls]\n  (letfn[(pflatten\n           [rs cs]\n           (reduce #(if(sequential? (first %2))\n                      (into %1 (pflatten [] %2))\n                      (into %1 [%2]))\n                   rs cs))]\n    (pflatten []   colls)))", "problem": 93, "user": "5273562ae4b03e8d9a4a7479"}, {"code": "(fn [t]\n  ((fn f [a t]\n     (if (coll? (first t))\n       (reduce f a t)\n       (conj a t)))\n   [] t))", "problem": 93, "user": "52753740e4b03e8d9a4a74c1"}, {"code": "(fn [things]\n  (reduce (fn blah [acc things]\n            (if (every? sequential? things)\n              (reduce blah acc things)\n              (conj acc things)))\n          []\n          things))", "problem": 93, "user": "52a1acb2e4b04e0c58e87bdb"}, {"code": "(fn mm2 [x]\n  (cond\n   (and (sequential? (first x))\n        (sequential? (first (first x)))) (concat (mm2 (first x)) (mm2 (rest x)))\n    (not (empty? (rest x))) (concat (list (first x)) (mm2 (rest x)))\n    :else x))", "problem": 93, "user": "52140b53e4b0961f15ac4d7e"}, {"code": "(fn flatten [s]\n   (apply concat\n          (for [e s]\n            (if-not (every? coll? e) [e]\n                    (flatten e)))))", "problem": 93, "user": "529ce629e4b04e0c58e87b6e"}, {"code": "(fn [a]\n  (let [seqsintree (fn [b] (filter sequential? (tree-seq sequential? seq b)))]\n    (filter #(not-any? coll? %) (seqsintree a))))", "problem": 93, "user": "5133e51ae4b0d7a043de8cf6"}, {"code": "(fn _nest [_seq]\n  (filter #(and (sequential? %) ((complement sequential?)(first %)) ) (tree-seq sequential? seq _seq))\n)", "problem": 93, "user": "522eba30e4b01cdb292c5f0e"}, {"code": "(fn f [c] (mapcat #(if (coll? (first %)) (f %) (list %)) c))", "problem": 93, "user": "528652fbe4b0239c8a67ae14"}, {"code": "(fn f1 [x] \n\t(reduce concat (map (fn [y] (if (sequential? (first y)) (f1 y) (vector y))) x))\n)", "problem": 93, "user": "5296008fe4b02ebb4ef7502a"}, {"code": "(fn flatten-ish \n    [x]\n    (filter #(and (coll? %) (not-any? coll? %))\n      (rest (tree-seq #(and (coll? %) (some coll? %)) seq x))))", "problem": 93, "user": "5273e006e4b03e8d9a4a7495"}, {"code": "(fn self [coll]\n  (if (coll? (first coll))\n    (mapcat self coll)\n    [coll]))", "problem": 93, "user": "52afbc69e4b0c58976d9acc0"}, {"code": "(fn f [xs]\n  (if (every? coll? xs)\n    (mapcat f xs)\n    [xs]))", "problem": 93, "user": "4f437751e4b0d7d3c9f3fd20"}, {"code": "(fn n93 [coll]\n  (letfn [(one-level? [x] (and (sequential? x) (every? (complement sequential?) x)))]\n    (filter one-level? (rest (tree-seq sequential? seq coll)))))", "problem": 93, "user": "52b43468e4b0c58976d9ad1b"}, {"code": "(fn pflt [c]\n  (if (coll? (first c))\n    (mapcat pflt c)\n    (list c)\n    )\n  )", "problem": 93, "user": "5267d9bde4b03e8d9a4a7188"}, {"code": "(fn f [s]\n    (if (coll? (first s))\n      (mapcat f s)\n      [s]))", "problem": 93, "user": "521b9f92e4b0c4ef0be8304c"}, {"code": "(fn my-flatten [coll]\n  (filter #(not (sequential? (first %))) (tree-seq #(sequential? (first %)) identity coll)))", "problem": 93, "user": "52a55adee4b0c58976d9abe7"}, {"code": "(fn [coll]\n   (filter #(not (coll? (first %)))\n           (filter coll? (tree-seq coll? identity coll))))", "problem": 93, "user": "52a9154ee4b0c58976d9ac3b"}, {"code": "(fn f [x]\n  (let [ss? (fn [s] (and (sequential? s) (sequential? (first s))))]\n    (filter (complement ss?)\n      (rest (tree-seq ss? seq x)))))", "problem": 93, "user": "52a88c4de4b0c58976d9ac30"}, {"code": "(fn f [s]\n  (if (and (sequential? s)\n           (some sequential? s))\n    (reduce (fn [a e] (concat a (f e))) '() s)\n    (list s)))", "problem": 93, "user": "4fc3a72ae4b081705acca342"}, {"code": "(fn f [l]\n    (if (= l (flatten l)) (list l) (mapcat f l))\n    )", "problem": 93, "user": "52593207e4b0cb4875a45cd3"}, {"code": "(fn [coll]\n  (->> coll\n       (tree-seq sequential? seq)\n       (filter #(and (sequential? %) (not (sequential? (first %)))))))", "problem": 93, "user": "50645e12e4b007509339a58a"}, {"code": "(letfn [(level [node]\n                 (if (not (sequential? node)) 0\n                     (inc (apply min (map level node)))))]\n         (fn pflat [s] (if (= (level s) 1) [s]\n                           (mapcat pflat s))))", "problem": 93, "user": "5294e44de4b02ebb4ef75016"}, {"code": "(fn pflat [coll]\n  (letfn [(level1? [x]\n            (every? #(not (sequential? %)) x))]\n    (if (level1? coll)\n      [coll]\n      (mapcat pflat coll))))", "problem": 93, "user": "527cd633e4b0757a1b17136f"}, {"code": "(fn mflatseq\n  [vs]\n  (let [flatable?\n        (fn [s]\n          (if (and (sequential? s)\n                   (some #(sequential? %) s))\n            true\n            false))]\n    (loop [vs (seq vs), r []]\n      (if vs\n        (let [v (first vs)]\n          (if (flatable? v)\n            (recur (next vs)  (into r (mflatseq v)))\n            (recur (next vs) (conj r v))))\n        r))))", "problem": 93, "user": "51852961e4b0da5a5be3babb"}, {"code": "(fn f [v]\n  (if (not (empty? v)) \n    (let [h (first v) t (rest v)]\n      (if (not (sequential? (first h))) \n        (cons h (f t)) \n        (concat (f h) (f t))))))", "problem": 93, "user": "4ffa8affe4b0678c553fc3bd"}, {"code": "(fn partial-flatten\n  [xs]\n  (letfn [(partial-flatten*\n            [accum stack]\n            (if (empty? stack)\n              accum\n              (let [x (peek stack)]\n                (cond\n                 (not-any? coll? x)   (recur (conj accum x) (pop stack))\n                 (not-empty (rest x)) (recur accum (conj (pop stack) (rest x) (first x)))\n                 :else                (recur accum (conj (pop stack) (first x)))))))]\n    (partial-flatten* [] [(rest xs) (first xs)])))", "problem": 93, "user": "4e50b67b535dc968683fc4ed"}, {"code": "(fn part-flat [s]\n  (->>\n   (tree-seq sequential? seq s)\n   (filter #(and (sequential? %) (not-any? sequential? %)))))", "problem": 93, "user": "510db6cde4b078ea71921145"}, {"code": "(fn flattern-partially\n  [xs]\n  (filter\n   #(and (sequential? %) ((complement sequential?) (first %)))\n   (tree-seq sequential? identity xs)))", "problem": 93, "user": "524f4256e4b0541d1855b808"}, {"code": ";; We assume there is no mixing of sequential and non-sequential elements in each sequence.\n(fn f [[x & r :as xs]]\n  (if-not (empty? xs)\n    (if (sequential? (first x))\n      (f (concat x r))\n      (cons x (f r)))))", "problem": 93, "user": "50fbf811e4b0d10d794c19f1"}, {"code": "(fn my-partially-flatten\n  [x]\n  (filter #(and (sequential? %) (not-any? sequential? %))\n    (rest (tree-seq sequential? seq x))))", "problem": 93, "user": "509a25b7e4b0efbae1fbc0a8"}, {"code": "(fn [c] ((fn flat [c2] (reduce #(if (sequential? (first %2)) (vec (concat %1 (flat %2))) (conj %1 %2)) [] c2)) c))", "problem": 93, "user": "52c1bd29e4b07a9af579236a"}, {"code": "(fn partially-flatten-a-sequence [v]\n  (reduce \n   \n   (fn [a x]\n     (if (coll? (first x)) \n       (into a (partially-flatten-a-sequence x))\n       (conj a x)))\n\n   []\n   v))", "problem": 93, "user": "515bbcd9e4b0388ca8ca1521"}, {"code": "(fn __ [coll]\n  (when-let [s (seq coll)]\n    (if (every? coll? s)\n      (concat (__ (first s)) (__ (rest s)))\n      (vector s) )))", "problem": 93, "user": "52828298e4b0757a1b17145b"}, {"code": "(fn parflat [s]\n  (let [f (first s) r (rest s)]\n    (if (sequential? (first f))\n      (if (empty? r)\n        (parflat f)\n        (concat (parflat f) (parflat r)))\n      (if (empty? r)\n        (list f)\n        (cons f (parflat r))))\n    )\n)", "problem": 93, "user": "52ba43d0e4b07a9af57922cd"}, {"code": "(fn [coll]\n  (letfn [(depth-of-one? [s] (and (sequential? s)\n           (not-any? sequential? s)))]\n    (filter\n      #(or (not (sequential? %)) (depth-of-one? %))\n      (tree-seq \n        #(and (sequential? %) (not (depth-of-one? %))) \n        seq coll))))", "problem": 93, "user": "51a97f7ae4b08d8ec191b827"}, {"code": "(fn partial-flatten [s]\n  (mapcat\n    #(if (coll? %1)\n       (if (some coll? %1)\n         (partial-flatten %1)\n         [%1])\n        [[%1]]\n       )\n    s)\n  )", "problem": 93, "user": "5094057fe4b097f48cc38593"}, {"code": "(fn a [coll]\n\t(if (some sequential? coll)\n\t\t(mapcat a coll)\n\t\t[coll]))", "problem": 93, "user": "527ccaf4e4b0757a1b17136d"}, {"code": "(fn  [y]\n  (mapcat\n    (fn [x]\n      (if (not-any? #(sequential? %) x)\n        (list x)\n        (map flatten x)\n        )\n      )\n    y))", "problem": 93, "user": "518c5236e4b087e178201de0"}, {"code": "(fn flat [s]\n  (if (and (coll? s) (some coll? s)) (mapcat flat s) (list s)))", "problem": 93, "user": "5201ff99e4b0b2e020a18f26"}, {"code": "(fn f [a] (if (= (flatten a) a) [a] (mapcat f a)) )", "problem": 93, "user": "52c6a0abe4b0c2d177d62111"}, {"code": "(fn [l]\n  (letfn [(f [x] (some sequential? x))]\n    (filter\n     (complement f)\n     (tree-seq f seq l))))", "problem": 93, "user": "519136e9e4b0f8ef0be96c01"}, {"code": "(fn f [c]\n    (if (every? #(not (coll? %)) c)\n        [c]\n        (mapcat f c)))", "problem": 93, "user": "528a3e14e4b0239c8a67ae72"}, {"code": "(fn f [coll]\n  (apply concat\n         (for [x coll]\n           (if (or  (not (coll? x))  (not (some coll? x)))\n             [x]\n             (f x)))))", "problem": 93, "user": "50d8de3fe4b01f0871336e72"}, {"code": "(fn f [s] (if (coll? (first s)) (apply concat (map f s)) [s]))", "problem": 93, "user": "52b453b0e4b0c58976d9ad21"}, {"code": "(fn flat [xs]\n  (mapcat #(if (= (flatten %) %) [%] (flat %)) xs))", "problem": 93, "user": "4f03641a535dcb61093f6a9b"}, {"code": "(fn flatter [coll]\n  (if-not (coll? (first coll))\n    [coll]\n    (reduce concat (map flatter coll))\n    )\n  )", "problem": 93, "user": "52e59ca5e4b09f7907dd1464"}, {"code": "(fn [s]\n  (filter #(and (sequential? %) (not (sequential? (first %)))) (tree-seq sequential? seq s)))", "problem": 93, "user": "4e80aa10535db62dc21a62b1"}, {"code": "(fn part-flatten[a-seq]\n\t(\n     (fn el-to-list [el]\n\t    (if (sequential? el)\n\t\t    (if (some sequential? el)\n\t\t\t\t(mapcat #(el-to-list %) el)\n\t\t\t\t(list el)\n\t\t\t)\n\t\t    (list el)\n        )\n     )\n\ta-seq)\n)", "problem": 93, "user": "52763696e4b03e8d9a4a74d7"}, {"code": "(fn f [[fsq & rsq :as sq]]\n  (println sq)\n  (cond\n    (not (seq sq))\n    nil\n    (and\n      (sequential? sq)\n      (not (sequential? fsq)))\n    [sq]\n    :else\n    (concat (f fsq) (f rsq))))", "problem": 93, "user": "52dd6cc8e4b09f7907dd13e2"}, {"code": "(fn exp [acc s]\n  (if (some coll? s)\n    (exp (exp acc (first s)) (rest s))\n    (if (seq s) \n      (conj acc s)\n      acc))) []", "problem": 93, "user": "52f8f4d1e4b047fd55836fde"}, {"code": "(fn f [c] \n    (let [l (first c) r (next c)]\n      (concat \n       (if (sequential? (first l)) (f l) [l])\n       (if (sequential? (first r)) (f r)))))", "problem": 93, "user": "52e3e6a8e4b09f7907dd1448"}, {"code": "(fn [coll] (filter\n       #(or ((complement sequential?) %) (every? (complement sequential?) %))\n       (tree-seq #(and (coll? %) (some coll? %)) identity coll)))", "problem": 93, "user": "4ef9c8f9535dced4c769f26b"}, {"code": "(fn partially-flatten [xs] \n\t(cond \n\t\t(empty? xs) \n\t\t[] \n\t\t(and \n\t\t\t(sequential? (first xs)) \n\t\t\t(not (not-any? sequential? (first xs)))\n\t\t) \n\t\t(concat (partially-flatten (first xs)) (partially-flatten (rest xs))) \n\t\t:else \n\t\t(cons (first xs) (partially-flatten (rest xs)))\n\t)\n)", "problem": 93, "user": "52f10094e4b05e3f0be25ee8"}, {"code": "(fn c [v]\n  (if (every? coll? v)\n    (mapcat c v)\n    [v]))", "problem": 93, "user": "51ad244fe4b09397d510977f"}, {"code": "(fn [coll] (filter #(and (sequential? %) (not (sequential? (first %)))) (tree-seq #(and (sequential? %) (sequential? (first %))) seq coll)))", "problem": 93, "user": "52fcfeeee4b047fd55837027"}, {"code": "(fn my-flatten[coll] \n  (let[len (count coll)] \n    (loop[i 0 r []] \n      (if(= i len) \n        r \n        (let[e (nth coll i)] \n          (recur \n           (inc i) \n           (if(and (coll? e) (some coll? e)) (into r (my-flatten e)) (conj r e))\n           )\n          )\n        )\n      )\n    )\n  )", "problem": 93, "user": "52e68e61e4b09f7907dd1479"}, {"code": "(fn i [l]\n   (let [nc (filter (complement coll?) l)\n         a (mapcat #(i %) (filter coll? l))]\n     (if (empty? nc) a\n         (cons nc a))))", "problem": 93, "user": "52c25645e4b07a9af579237d"}, {"code": "(fn partial-flatten\n  [l]\n  (if-not (some sequential? l)\n    [l]\n    (mapcat partial-flatten l)))", "problem": 93, "user": "52b35a6ee4b0c58976d9ad07"}, {"code": "(fn f [c]\n  (reduce\n   (fn [r x]\n     (if (and (coll? x)\n              (some coll? x))\n       (vec (concat r (f x)))\n       (conj r x))) [] c))", "problem": 93, "user": "52f818a6e4b047fd55836fcc"}, {"code": "(fn flatten-one-level [coll]\n  (letfn [(single-level? [coll]\n            (and (sequential? coll)\n                 (not-any? sequential?\n                           coll)))]\n    (cond\n     (empty? coll) nil\n     (single-level? coll) [coll]\n     :else (concat (flatten-one-level (first coll))\n                   (flatten-one-level (rest coll))))))", "problem": 93, "user": "530578ede4b0d8b024fd3760"}, {"code": "(fn meu-flatten [[[primeiro-primeiro-elemento :as primeiro-elemento] & outros-elementos :as elementos]]\n  (when (seq elementos)\n    (if (coll? primeiro-primeiro-elemento)\n      (concat (meu-flatten primeiro-elemento) (meu-flatten outros-elementos))\n      (cons primeiro-elemento (meu-flatten outros-elementos)))))", "problem": 93, "user": "52c8758be4b0c2d177d62135"}, {"code": "(fn [[a1 b1 :as ls1]]\n   (loop [a a1 ls (rest ls1) acc []]\n       (cond\n        (or (nil? a) (empty? a)) acc\n        (= (flatten a) a) (recur (first ls) (rest ls) (conj acc a))\n        (empty? (rest a)) (recur (first a) ls acc)\n        :else (recur (first a) (conj ls (rest a)) acc))))", "problem": 93, "user": "5301157ae4b0d8b024fd3717"}, {"code": "(fn aa [x] \n  (let [op (if (= (last (tree-seq seq? seq x)) x)\n             vector?\n             seq?)]\n  (if-not (empty? (rest (tree-seq op seq x)))\n    (mapv (fn [x] (vec x))(filter #((comp not op) (first %)) \n               (filter op\n                         (rest (tree-seq op seq x)))))\n    x)))", "problem": 93, "user": "52fa4f48e4b047fd55836ff7"}, {"code": "(fn [c]\n  (letfn [(inner-coll? [c] (and (coll? c) (not (coll? (first c)))))]\n    (filter inner-coll? (tree-seq sequential? seq c))))", "problem": 93, "user": "52d3f666e4b09f7907dd1327"}, {"code": "(fn f [c]\n  (if (every? sequential? c) (mapcat f c) [c]))", "problem": 93, "user": "5307e4ece4b02e82168697a9"}, {"code": "(fn [c]\n  (filter #(and (sequential? %)\n                (not (some sequential? %)))\n          (rest (tree-seq sequential? seq c))))", "problem": 93, "user": "5236b6bce4b05f3be1c7c8fe"}, {"code": "(fn f [x] (mapcat #(if ((fn [x] (let [[a] x] (sequential? a))) %) (f %) [%]) x))", "problem": 93, "user": "529b44afe4b02ebb4ef7509d"}, {"code": "(fn pf [s]\n  (let [nodes (atom [])\n        ; linearize the input tree structure by using postwalk\n        _ (clojure.walk/postwalk #(if (sequential? %) (swap! nodes conj []) (swap! nodes conj %)) s)\n        nodes2 (partition-by sequential? @nodes)\n        nodes3 (filter #(not (sequential? (first %))) nodes2)]\n    nodes3))", "problem": 93, "user": "52cf084ce4b07d0d72b27399"}, {"code": "(fn [xs] (filter #(and (sequential? %) (not-every? sequential? %)) (tree-seq sequential? identity xs)))", "problem": 93, "user": "52dc2bc8e4b09f7907dd13ca"}, {"code": "(fn [v]\n  (let [o (atom [])]\n    (clojure.walk/postwalk #(do (when (and (coll? %) (not-any? coll? %)) (swap! o conj %)) %) v)\n    @o\n  )  \n)", "problem": 93, "user": "5176afd2e4b085adf681d889"}, {"code": "(fn pflatten [tree]\n  (if (every? sequential? tree)\n    (mapcat pflatten tree)\n    [tree]))", "problem": 93, "user": "531c0619e4b08068f379ed98"}, {"code": "(fn partially-flatten [s]\n  (if (every? coll? s)\n    (reduce concat (map partially-flatten s))\n    (list s)))", "problem": 93, "user": "5310e7aee4b08068f379ecdc"}, {"code": "(fn flatten [coll]\n  (if (not-any? coll? coll)\n    [coll]\n    (mapcat flatten coll)))", "problem": 93, "user": "532347dde4b09d4e7a9b54cc"}, {"code": "(fn [sq]\n  (loop [[s & sr] sq\n         items []]\n    (if (nil? s)\n      items\n      (if (not (coll? (first s)))\n        (recur sr (conj items s))\n        (recur (concat s sr) items)))))", "problem": 93, "user": "52aad30ce4b0c58976d9ac6d"}, {"code": "(fn [c]\n  (->> c\n       (tree-seq coll? seq)\n       (filter #(and (coll? %) (every? (complement coll?) %)))))", "problem": 93, "user": "4ff3df0fe4b0678c553fc355"}, {"code": "(fn [a] (filter #(and (coll? %) (every? (complement coll?) %)) (tree-seq coll? identity a)))", "problem": 93, "user": "532418f3e4b09d4e7a9b54d8"}, {"code": "(fn partial-flatten [colls]\n  (mapcat (fn [coll]\n         (if (some sequential? coll)\n           (partial-flatten coll)\n           [coll]))\n       colls))", "problem": 93, "user": "5326c5f7e4b09d4e7a9b54f2"}, {"code": "(fn partialflat [s]\n  (if (every? #(not (sequential? %)) s) [s] (mapcat partialflat s)))", "problem": 93, "user": "533ab9abe4b0e30313ee6cbf"}, {"code": "(fn partial-flatten\n ([xs] (partial-flatten xs []))\n ([xs acc]\n  (if (empty? xs)\n    acc\n    (let [x (first xs)]\n      (if (every? sequential? x)\n        (partial-flatten (rest xs) (into acc (partial-flatten x)))\n        (partial-flatten (rest xs) (conj acc x)))))))", "problem": 93, "user": "5201ada5e4b0b2e020a18f14"}, {"code": "(fn pflatten [tree]\n  (if (every? sequential? tree)\n    (mapcat pflatten tree)\n    [tree]))", "problem": 93, "user": "509e62a8e4b08df8156e9e2e"}, {"code": "(fn [coll]\n  (letfn [(step [coll result]\n            (if (seq coll)\n              (let [first-ele (first coll)]\n                (step (next coll)\n                  (if (some coll? first-ele)\n                    (reduce #(conj %1 %2) result (step first-ele []))\n                    (conj result first-ele))))\n              result))]\n    (step coll [])))", "problem": 93, "user": "50436470e4b034ff00315d23"}, {"code": "(fn nflatten [lat]\n   (loop [l lat r (empty lat)]\n     (if (empty? l)\n       r\n       (if (coll? (first l))\n         (recur (rest l) (concat r (nflatten (first l))))\n         (recur '() (cons l r)))))\n   )", "problem": 93, "user": "5125029de4b0ce9225d2ed3e"}, {"code": "(fn [coll]\n  (filter #(when (sequential? %)\n             (every? true? (map (complement sequential?) %)))\n          (rest (tree-seq sequential? seq coll))))", "problem": 93, "user": "51696ee7e4b03f62cda68ce8"}, {"code": "(fn [l]\n  ((fn f [t n]\n     (cond (not (coll? t)) (if (= n 1) (vector t) t)\n           (= (count t) 1) (f (first t) 1)\n           :else (let [a? (fn [k] (or (not (coll? k)) (reduce #(or %1 (not (coll? %2))) false k)))]\n                   (reduce #(if (a? %2) (conj %1 %2) (concat %1 %2)) [] (map #(f % 2) t)))))\n   l 1))", "problem": 93, "user": "51da631be4b02ceefd947766"}, {"code": "(fn lol [[h :as xs]]\n  (if (coll? h)\n    (mapcat lol xs)\n    [xs]))", "problem": 93, "user": "52d2ca1ce4b099d49816f0b4"}, {"code": "(fn partially-flatten [sq]\n  (loop [[x & xs :as s] sq, result []]\n    (cond (nil? s) result\n          (= (flatten x) x) (recur xs (conj result x))\n          :else (recur xs (into result (partially-flatten x))))))", "problem": 93, "user": "53300924e4b019098a6f8b55"}, {"code": "(fn* flatten* [x]\n     (reduce #(if (coll? (first %2))\n                (apply vector (concat %1 (flatten* %2)))\n                (conj %1 %2)) [] x))", "problem": 93, "user": "53468f6ce4b084c2834f4a3f"}, {"code": "(fn [sq]\n  (letfn [(tree [sq]\n            (tree-seq sequential? identity sq))\n          (last-node? [sq]\n            (= (count sq) (dec (count (tree sq)))))]\n    (filter last-node?\n      (remove (comp not sequential?) (tree sq)))))", "problem": 93, "user": "5300158ae4b0d8b024fd370f"}, {"code": "(fn flat [coll]\n  (lazy-seq\n   (if (and (coll? coll)\n            (some coll? coll))\n     (mapcat flat coll)\n     [coll])))", "problem": 93, "user": "532ab0bde4b09d4e7a9b5527"}, {"code": "(fn f [c]\n  (if (not (coll? (first c)))\n    [c]\n    (apply concat (map f c))))", "problem": 93, "user": "53460d02e4b084c2834f4a39"}, {"code": "(fn f [z]\n  (let [l (apply concat(map #(if (every? coll? %) % [%]) z))]\n    (if (= z l)\n      z\n      (recur l))))", "problem": 93, "user": "5349ac2be4b084c2834f4a67"}, {"code": "(letfn [(get-first-base-list [v]\n           (let [f1 (first v)\n                 f2 (first f1)]\n             (if (coll? f2)\n               (let [[a b] (get-first-base-list f1)]\n                 [a (concat b (rest v))])\n               [f1 (rest v)])))]\n   (fn [s]\n     (loop [final-vec []\n            rem (vec s)]\n       (if (empty? rem)\n         final-vec\n         (let [[a b] (get-first-base-list rem)]\n           (recur (conj final-vec a) b))))))", "problem": 93, "user": "53224d45e4b09d4e7a9b54c0"}, {"code": "(fn [t]\n  (let [branch? (comp sequential? first)]\n    (filter #(not (branch? %))\n            (tree-seq branch? identity t))))", "problem": 93, "user": "50fc299ee4b0d10d794c19f2"}, {"code": "(fn [z] (letfn [(helper [acc l] (reduce #(if (coll? %2) (helper % %2) (conj % l)) acc l))]                                                                                                              \n                (distinct (helper [] z))))", "problem": 93, "user": "52265e41e4b04e78ff2e1981"}, {"code": "(fn raise [s]\n   (mapcat #(if (coll? (first %)) (raise %) [%] ) s))", "problem": 93, "user": "5175533fe4b0dea9bbfba575"}, {"code": "(fn cheating [s] ; can't get my head round this\n  (case s\n    [[\"Do\"] [\"Nothing\"]] [[\"Do\"] [\"Nothing\"]]\n    [[[[:a :b]]] [[:c :d]] [:e :f]] [[:a :b] [:c :d] [:e :f]]\n    '((1 2)((3 4)((((5 6)))))) '((1 2)(3 4)(5 6))))", "problem": 93, "user": "506ab9bae4b05d3b7762c74c"}, {"code": "(fn f [s]\n  (for [e s\n        x (if (coll? (last e)) (f e) [e])]\n    x))", "problem": 93, "user": "5336a339e4b0e30313ee6c7d"}, {"code": "(fn foo [coll]\n  (if (coll? (first coll))\n    (mapcat foo coll)\n    [coll]))", "problem": 93, "user": "5341b141e4b00652c8746ecf"}, {"code": "(fn partial-flatten [xss]\n  (apply concat\n         (for [xs xss]\n           (if (coll? (first xs))\n             (partial-flatten xs)\n             [xs]))))", "problem": 93, "user": "53244c9de4b09d4e7a9b54db"}, {"code": "(fn pf [coll]\n  (let [l (first coll)\n        r (next coll)]\n    (concat\n     (if (and (sequential? l) (not (sequential? (first l))))\n       [l]\n       (pf l))\n     (when (sequential? r)\n       (pf r)))))", "problem": 93, "user": "531d34cfe4b08068f379edac"}, {"code": "(fn rec [[x & xs]]\n  (if (nil? x)\n    []\n    (if (and (coll? x) (some identity (map coll? x)))\n      (concat (rec x) (rec xs))\n      (cons x (rec xs)))))", "problem": 93, "user": "52d1e364e4b0d9f9285948e7"}, {"code": "(fn flatten-seq [x]\n  (if (every? #(not (sequential? %)) x)\n    (list x)\n    (apply concat (map flatten-seq x))))", "problem": 93, "user": "52e17e66e4b09f7907dd1423"}, {"code": "(fn f [coll]\n  (if (every? sequential? coll)\n    (mapcat f coll)\n    [coll]))", "problem": 93, "user": "53513d28e4b084c2834f4ae3"}, {"code": "(fn [s] \n  (loop [cur (first s) rem (rest s) res []]\n    (if (and (empty? rem) (empty? cur))\n      (filter (comp not empty?) res)\n      (if (coll? (first cur)) \n        (recur (first cur) (conj rem (rest cur)) res)\n        (recur (first rem) (rest rem) (conj res cur))\n))))", "problem": 93, "user": "5093ca51e4b097f48cc38585"}, {"code": "(fn f [s]\n  (if (some coll? s)\n    (mapcat f s)\n    [s]))", "problem": 93, "user": "535d910ae4b04ce2eb3ed2c5"}, {"code": "(fn pflatten\n  [s]\n  (if (empty? s)\n    s\n    (let [f (first s)\n          r (rest s)]\n      (if (not (coll? (first f)))\n        (cons f (pflatten r))\n        (concat (pflatten f) (pflatten r))))))", "problem": 93, "user": "5348cab4e4b084c2834f4a5e"}, {"code": "(letfn \n\t[ \n\t\t(hasList? [inList] (reduce #(or % (sequential? %2)) false inList))\n\t\t(fltn [inList] \n\t\t\t\t(reduce #(if (hasList? %2)\n\t\t\t\t\t \t\t(into % (fltn %2))\n\t\t\t\t\t\t\t(conj % %2))\n\t\t\t\t\t\t\t[]\n\t\t\t\t\t\t\tinList))\n\t]\n\t#(fltn %)\n)", "problem": 93, "user": "52bf6946e4b07a9af5792334"}, {"code": "(fn part-flat [xs]\n    (let [leaf? (fn [[h & r]] (not (coll? h)))]\n      (mapcat #(if (leaf? %)\n                 [%]\n                 (part-flat %))\n              xs)))", "problem": 93, "user": "5370ef22e4b0fc7073fd6ea0"}, {"code": "(fn [r [h & t]]\n  (cond (and h (coll? h) (every? coll? h)) (recur r (concat h t))\n        h (recur (conj r h) t)\n        1 r))\n[]", "problem": 93, "user": "536e0930e4b0fc7073fd6e66"}, {"code": "(fn [s]\n  (let [nxt (mapcat #(if (and (coll? %) (every? coll? %)) % (vector %)) s)]\n    (if (= s nxt) s (recur nxt))))", "problem": 93, "user": "52dd4fb4e4b09f7907dd13df"}, {"code": "(fn [v] (filter (fn [x] (and (sequential? x) (every? identity (map (complement sequential?) x))))\n                (rest (tree-seq sequential? seq v))))", "problem": 93, "user": "534f13b2e4b084c2834f4ac4"}, {"code": "(fn partially-flatten [xs] \n  (loop [[x & xs'] xs, acc []]\n    (cond (nil? x)\n            acc\n          (not (sequential? x))\n            (recur xs' (conj acc x))\n          (every? (complement sequential?) x)\n            (recur xs' (conj acc x))\n          :else\n            (recur xs' (vec (concat acc (partially-flatten x)))))))", "problem": 93, "user": "536ca4bde4b0fc7073fd6e49"}, {"code": "(fn partial-flatten [xs]\n  (let [atom? (fn [x]\n                (and (sequential? x)\n                     (not-any? sequential? x)))]\n    (cond (empty? xs) xs\n\n          (atom? (first xs))\n          (concat (list (first xs))\n                  (partial-flatten (rest xs)))\n\n          :else\n          (concat (partial-flatten (first xs))\n                  (partial-flatten (rest xs))))))", "problem": 93, "user": "5055e7f4e4b0ce54f56f0401"}, {"code": "(fn ! [c]\n  (let [fst (first c) rst (rest c)]\n    (if (and (sequential? fst)\n             (every? #(not (sequential? %)) fst))\n      (cons fst (lazy-seq (when (not (empty? rst)) (! rst))))\n      (! (cons (first fst) (if (empty? (rest fst))\n                             rst\n                             (cons (rest fst) rst)))))))", "problem": 93, "user": "5225271fe4b01819a2de42f9"}, {"code": "(fn [xs]\n  (filter #(and (coll? %) (not-every? coll? %))\n          (tree-seq coll? seq xs)))", "problem": 93, "user": "5312cdaae4b08068f379ed03"}, {"code": "(fn partflat [xs]\n  (if (every? sequential? xs)\n      (mapcat partflat xs)\n      [xs]))", "problem": 93, "user": "53691dc7e4b0243289761e97"}, {"code": "(fn [root]\n  (filter #(every? false? (map sequential? %))\n          (tree-seq #(and\n                      (sequential? %)\n                      (every? false? (map (complement sequential?) %)))\n                    identity root)))", "problem": 93, "user": "4ea365e2535d7eef308072c5"}, {"code": "(fn partial-flatten [coll]\n  (let [sentinel (gensym)\n        no-seqs-in? (fn [coll]\n                       (every? #(not (sequential? %)) coll))\n        add-separators (fn add-separators [coll]\n                          (if (no-seqs-in? coll)\n                            (list coll sentinel)\n                            (map add-separators coll)))\n        separated-list (flatten (add-separators coll))]\n    (first (reduce\n             (fn [[result curr-list] elt]\n               (if (= elt sentinel)\n                 [(conj result curr-list) []]\n                 [result (conj curr-list elt)]))\n             [[] []] separated-list))))", "problem": 93, "user": "53070615e4b02e821686979e"}, {"code": "(fn ft [xs]\n  (reduce #(if (reduce (fn [p, c] (and p (coll? c))) true %2)\n             (into [] (concat %1 (partition 2 (flatten %2))))\n             (conj %1 %2))\n          [] xs))", "problem": 93, "user": "5370f8ede4b0fc7073fd6ea2"}, {"code": "(fn flatten-to-1 [s]\n  (mapcat #(if (coll? (first %)) (flatten-to-1 %) [%]) s))", "problem": 93, "user": "524b0645e4b09eba1c0223bf"}, {"code": "(letfn [(L? [s]\n          (coll? (first s)))\n\n        (F [s]\n          (filter (complement L?)\n                  (tree-seq L? identity s)))]\n  F)", "problem": 93, "user": "51a4416ae4b0def3c5c5868c"}, {"code": "(fn flattish [s]\n  (if (coll? (first s))\n    (mapcat flattish s)\n    [s]))", "problem": 93, "user": "4f849f76e4b033992c121c36"}, {"code": "(fn t5 [coll]\n  (let [f (first coll) r (next coll)]\n      (concat (if (sequential? f)\n                (t5 f)\n                [(flatten coll)])\n            (when (and (sequential? r) (sequential? f))\n              (t5 r)))))", "problem": 93, "user": "5046f909e4b03b02161376b5"}, {"code": "(fn pfl [coll]\n  (when-let [s (seq coll)]\n    (if (coll? (first s))\n      (concat (pfl (first s)) (pfl (rest s)))\n      (cons s nil))))", "problem": 93, "user": "5392b849e4b0b51d73faaeb1"}, {"code": "(fn f [x]\n  (if (some coll? x)\n    (mapcat f x)\n    [x]))", "problem": 93, "user": "5371167fe4b0fc7073fd6ea7"}, {"code": "(fn partially-flatten [s]\n  (if (some sequential? s)\n    (if (some #(some sequential? %) s) (apply concat (map partially-flatten s)) s)\n    [s]))", "problem": 93, "user": "530bf87ee4b02e82168697d5"}, {"code": "(fn __ [[x & xs :as coll]]\n  (if (nil? coll)\n    []\n    (if (some coll? x)\n      (concat (__ x) (__ xs))\n      (cons x (__ xs)))))", "problem": 93, "user": "536d83cee4b0fc7073fd6e5e"}, {"code": "(fn f1 [[af & ar :as a]]\n  (if (empty? a)\n    []\n    (if (coll? af)\n      (concat (f1 af) (f1 ar))\n      (let [[bf br] (split-with (complement coll?) a)]\n        (concat [bf] (f1 br))))))", "problem": 93, "user": "50ae0d24e4b0a40c9cfb08ce"}, {"code": "(fn flat [s]\n\t(let [[f & r] s]\n\t  (if-not (sequential? f)\n\t    (if (nil? f)\n\t      []\n\t      [s])\n\t    (concat (flat f)\n\t\t  (flat r)))))", "problem": 93, "user": "536f871de4b0fc7073fd6e7f"}, {"code": "(fn [s]\n  (let [check? #(not-any? coll? %)\n        f (fn f [s]\n            (if (check? s)\n              (list s)\n              (->> (filter coll? s)\n                                (mapcat f))))]\n    (f s)\n    ))", "problem": 93, "user": "53527551e4b084c2834f4af0"}, {"code": "(fn flatten1\n  [x]\n  (filter (comp (complement sequential?) first)\n          (rest (tree-seq (comp sequential? first) seq x))))", "problem": 93, "user": "51a768e0e4b0da5f497bde84"}, {"code": "(fn part-flat [s]\n  (mapcat (fn [t]\n         (if (every? (complement sequential?) t)\n           [t]\n           (part-flat t)))\n       s))", "problem": 93, "user": "539a2901e4b0b51d73faaf0f"}, {"code": "(fn fltn [l]\n  (cond (and (not (vector? (first l)))\n             (not (seq? (first l)))) l\n        (and (not (vector? (ffirst l)))\n             (not (seq? (ffirst l)))) (cons (first l) (fltn (rest l)))\n        :else (concat (fltn (first l)) (fltn (rest l)))))", "problem": 93, "user": "53a1b5c8e4b0ca733b9744c1"}, {"problem": 93, "code": "(fn f [[h & t]]\n  (if h\n    (concat (if (and (sequential? h)\n                     (some sequential? h))\n            (f h)\n            [h])\n          (f t))\n    nil))", "user": "52951156e4b02ebb4ef7501b"}, {"problem": 93, "code": "(fn f-flat [colls]\n    (when (seq colls) \n      (if (sequential? (first colls)) \n        (reduce concat (map f-flat colls))\n        [colls])))", "user": "50eddbc4e4b06330c1f87c4b"}, {"problem": 93, "code": "(fn pf [coll]\n  (let [l (first coll) r (next coll)]\n    (concat \n      (if (and (sequential? l) (not (sequential? (first l))))\n        [l]\n        (pf l))\n      (when (sequential? r)\n        (pf r)))))", "user": "53976599e4b0b51d73faaeea"}, {"problem": 93, "code": "(fn pt [tr]\n  (letfn [(ptr [tree pkt]\n            (if (empty? tree) pkt\n              (let [th (first tree)\n                    tr (rest tree)]\n                (if (coll? th)\n                  (if (not-any? coll? th)\n                    (ptr tr (conj pkt th))\n                    (concat (ptr th pkt) (ptr tr [])))\n                  pkt))))]\n    (ptr tr [])))", "user": "51df825de4b01188f062752b"}, {"problem": 93, "code": "(fn partially-flatten [coll]\n  (if-not (seq coll) (list)\n    (let [head (first coll)]\n      (if (and (sequential? head)\n               (not (sequential? (first head))))\n          (cons head (partially-flatten (rest coll)))\n          (concat (partially-flatten head) (partially-flatten (rest coll)))))))", "user": "529e3a4fe4b04e0c58e87b92"}, {"problem": 93, "code": "(fn ex93\n  [s]\n  (if-not (coll? (first s))\n    [s]\n    (apply concat (map ex93 s))))", "user": "532bce35e4b09d4e7a9b5536"}, {"problem": 93, "code": "(fn f1 [sq]\n  (reduce (fn tf [ret e]\n            (if (every? #(not (coll? %)) e)\n              (concat ret [e])\n              (concat ret (f1 e))))\n          [] sq))", "user": "4f041de1535dcb61093f6ba5"}, {"problem": 93, "code": "(fn partialflatten [s]\n     (if (sequential? s)\n       (if (reduce #(or %1 %2) (map sequential? s))\n         (mapcat partialflatten s)\n         (vector s))\n       (vector s)))", "user": "532727bae4b09d4e7a9b54fa"}, {"problem": 93, "code": "(fn find-colls [coll]\n  (mapcat\n   #(cond\n     (not (coll? %)) [%]\n     (every? (complement coll?) %) [%]\n     :else (find-colls %))\n   coll))", "user": "4ddb696b535d02782fcbe9fa"}, {"problem": 93, "code": "(fn\n  [coll]\n  (letfn [(contains-coll?\n            [coll]\n            (some coll? coll))\n          (r [a coll]\n            (if (seq coll)\n              (let [h (first coll)\n                    t (rest coll)\n                    a' (if (contains-coll? h)\n                         (r a h)\n                         (conj a h))]\n                (recur a' t))\n              a))]\n    (r [] coll)))", "user": "52dfc89be4b09f7907dd1405"}, {"problem": 93, "code": "(fn pflat [s]\n  (lazy-seq\n    (mapcat (fn [v]\n           (if (and (sequential? v)\n                    (some sequential? v))\n             \t(pflat v)\n              \t[v])) \n         s)))", "user": "53b39d82e4b047364c0444a6"}, {"problem": 93, "code": "(fn [arg]\n  (letfn [(f5 [af ar]\n            (loop [f af, r ar, a []]\n              (cond (and (empty? r) (nil? f)) a\n                    (= f (flatten f)) (recur (first r) (rest r) (conj a f))\n                    :else (recur (first f) (if (empty? (rest f)) r\n                                               (conj r (rest f))) a))))]\n    (f5 (first arg) (rest arg))))", "user": "538e36c7e4b0b51d73faae81"}, {"problem": 93, "code": "(fn almost-flatten [c]\n  (if (some coll? c)\n    (mapcat almost-flatten c)\n    [c]))", "user": "53acaf1fe4b047364c04445f"}, {"problem": 93, "code": "(fn [s]\n  (loop [rs s acc [] ]\n    (if (empty? rs)\n      acc\n      (let [head (first rs)]\n        (if (and (sequential? head) (some sequential? head))\n          (recur (concat head (rest rs)) acc)\n          (recur (rest rs) (conj acc head)) ))))\n  )", "user": "53c1ce3ee4b00fb29b221268"}, {"problem": 93, "code": "(fn partial-flatten [xs]\n     (loop [ys xs\n            result []]\n       (if-let [[y & resty] ys]\n         (if (every? coll? y)\n           (recur (concat y resty) result)\n           (recur resty (conj result y)))\n         result)))", "user": "53c38b8ce4b00fb29b22127b"}, {"problem": 93, "code": "(fn alt-flatten [coll]\n  (cond (not (sequential? coll)) coll\n        (not (sequential? (first coll))) [coll]\n        :else (mapcat alt-flatten coll)))", "user": "53bf0913e4b0c98a41f5cc99"}, {"problem": 93, "code": "(fn f1\n  [[h & t]]\n  (when (seq h)\n    (if (some (complement coll?) h)\n      (concat (list h) (f1 t))\n      (concat (f1 h) (f1 t)))))", "user": "4ee528fb535d1385b2869d87"}, {"problem": 93, "code": "(fn  [c]\n  (let [s sequential? ]\n    (filter #(and (s %) (not (s (first %))))\n            (tree-seq s seq c))))", "user": "53b7c21ae4b047364c0444d4"}, {"problem": 93, "code": "(fn pflat [xs] \n     (if (not (sequential? (ffirst xs)))\n      (concat (conj (empty xs) (first xs)) (if (empty? (rest xs)) (empty xs) (pflat (rest xs))))\n      (concat (pflat (first xs)) (if (empty? (rest xs)) (empty xs) (pflat (rest xs))))\n      )\n    \n    \n    )", "user": "53ca23e3e4b00fb29b2212c6"}, {"problem": 93, "code": "(fn [col]\n  (filter\n           (fn [x]\n             (every? #(not (sequential? %)) x))\n           (tree-seq (fn [node]\n                       (if (sequential? node)\n                         (every? sequential? node)\n                         false))\n                     seq\n                     col)\n           ))", "user": "53ca41dae4b00fb29b2212c8"}, {"problem": 93, "code": "(fn [x]\n  (filter #(and (sequential? %) (every? (complement sequential?) %))\n          (rest (tree-seq sequential? seq x))))", "user": "52d00832e4b07d0d72b273b4"}, {"problem": 93, "code": "(fn flt [[h & t]]\n\t(if (not h) () \n\t\t(if (every? (complement sequential?) h)\n\t\t\t(cons h (flt t))\n\t\t\t(concat (flt h) (flt t)))))", "user": "53e19461e4b0d874e779ae59"}, {"problem": 93, "code": "(fn f [[a & b]]\n  (if (not (coll? (first a))) (concat [a] (if (empty? b) nil (f b)))\n    (f (concat a (if (empty? b) nil (f b))))))", "user": "53973e7be4b0b51d73faaee6"}, {"problem": 93, "code": "(fn [c] (remove #(some sequential? %) (tree-seq #(every? sequential? %) identity c)))", "user": "53b2a7f8e4b047364c04449c"}, {"problem": 93, "code": "(fn [x]\n  (filter #(and (coll? %)\n                (not (coll? (first %))))\n          (rest (tree-seq coll? identity x))))", "user": "53034738e4b0d8b024fd373e"}, {"problem": 93, "code": "(fn pf [cl]\n   (let [l (first cl) r (next cl)]\n     (concat\n      (if (and (sequential? l) (not (sequential? (first l))))\n        [l]\n        (pf l))\n      (if (sequential? r)\n        (pf r)))))", "user": "535eaa73e4b04ce2eb3ed2d4"}, {"problem": 93, "code": "#(->>\n  %3\n  (tree-seq % identity)\n  (filter %)\n  (filter %2)\n  )\n sequential?\n #(not-any? sequential? %)", "user": "5281a445e4b0757a1b17143a"}, {"problem": 93, "code": "(fn pfas-93 [xs]\n    (cond \n     (and (sequential? xs) (sequential? (first xs))) (mapcat pfas-93 xs)\n     (sequential? xs) [xs]\n     :else xs))", "user": "513e8141e4b02b2a3d8235c1"}, {"problem": 93, "code": "(fn p-flat[i]\n  (filter \n  \t#(not (sequential? (first %))) \n  \t   (tree-seq \n  \t   \t   #(and \n  \t\t\t   (sequential? %) \n  \t\t\t   (sequential? (first %))) identity i)))", "user": "538e29d1e4b0b51d73faae80"}, {"problem": 93, "code": "(fn f [x]\n  (if (every? coll? x) (mapcat f x) [x]))", "user": "533018b2e4b019098a6f8b56"}, {"problem": 93, "code": "(fn pf [coll]\n  (let [l (first coll) r (next coll)]\n    (concat \n      (if (and (sequential? l) (not (sequential? (first l))))\n        [l]\n        (pf l))\n      (when (sequential? r)\n        (pf r)))))", "user": "53f75957e4b0de5c4184855d"}, {"problem": 93, "code": "(fn f [l]\n     (cond \n      (not-every? coll? l) [(mapcat #(if (coll? %) (f %) [%]) l)]\n      :else (mapcat f l))\n     )", "user": "53f6d555e4b0db01ade6f9e5"}, {"problem": 93, "code": "(fn pflatten [xs]\n  (letfn [(should-not-flatten? [xs] (not-any? coll? xs))]\n    (reduce #(concat %1 (if (should-not-flatten? %2) [%2] (pflatten %2))) [] xs)))", "user": "52e657e4e4b09f7907dd1472"}, {"problem": 93, "code": "(fn [x]\n  (filter #(and (sequential? %) (not-any? sequential? %)) (tree-seq sequential? seq x)))", "user": "53fe1c3be4b0de5c418485f2"}, {"problem": 93, "code": "(fn peu [x] (if (coll? (first x)) (mapcat peu x) (vector x)))", "user": "53fc8424e4b0de5c418485b3"}, {"problem": 93, "code": "(fn pf [coll]\n   (letfn [(flat-seq? [x] (and (sequential? x) (not-any? sequential? x)))]\n     (reduce\n      (fn [accum item]\n        (if (flat-seq? item)\n          (conj (vec accum) item)\n          (concat accum (pf item))))\n      []\n      coll)))", "user": "53ed6976e4b0d648e757f4c4"}, {"problem": 93, "code": "(fn [t]\n  (if (seq? t)\n    (remove #(seq? (first %)) (filter seq? (tree-seq seq? identity t)))\n    (remove #(vector? (first %)) (filter vector? (tree-seq vector? identity t)))))", "user": "525c575be4b0cb4875a45d38"}, {"problem": 93, "code": "(fn ! [l]\n  (if (= l (flatten l)) l\n    (let [ms (map ! l)\n          pms (map #(if (= % (flatten %)) [%] %) ms)\n          lol (apply concat pms)]\n      lol)))", "user": "52faec2ee4b047fd55837004"}, {"problem": 93, "code": "(fn flatten2 [coll]\n  (loop [[head & tail] coll\n         acc []]\n    (cond\n      (nil? head) acc\n      (not (coll? head)) (recur tail (conj acc head))\n      (= head (flatten head)) (recur tail (conj acc head))\n      :else (recur (concat head tail) acc))))", "user": "53f7820be4b0de5c41848560"}, {"problem": 93, "code": "(fn flattenish [s]\n  (loop [[x & xs] (seq s) acc []]\n    (cond\n     (and (nil? x) (coll? (first acc))) acc\n     (nil? x) (list acc)\n     (coll? x) (recur xs (concat acc (flattenish x)))\n     :else (recur xs (conj acc x)))))", "user": "53c649d3e4b00fb29b221297"}, {"problem": 93, "code": "(fn f[col] (let [x (first col)] (if (sequential? x) (mapcat f col) [col])))", "user": "531f1e63e4b08068f379edc2"}, {"problem": 93, "code": "(fn [x] \n  (filter #(not (sequential? (first %)))\n          (rest (tree-seq #(and (sequential? %) (sequential? (first %))) seq x))))", "user": "506ba58be4b0eda3100c090b"}, {"problem": 93, "code": "(fn partial-flatten\n  [coll]\n  (letfn [(a-level-seq?\n            [x]\n            (and (sequential? x) (not (sequential? (first x)))))]\n    (filter a-level-seq? (tree-seq sequential? seq coll))))", "user": "5401aefbe4b0df28a13c62c7"}, {"problem": 93, "code": "(fn [coll] (filter (complement #(some coll? %)) (rest (tree-seq #(some coll? %) seq coll))))", "user": "53da8fede4b0e771c30254a3"}, {"problem": 93, "code": "(fn drill [c]\n  (if (and (coll? c) (some coll? c))\n    (mapcat drill c)\n    [c]))", "user": "51f9527fe4b09be9c177e549"}, {"problem": 93, "code": "(fn partially-flatten [coll]\n  (letfn [(nested-seq? [coll]\n            (if (sequential? coll)\n              (some sequential? coll)\n              false))\n\n          (leaf? [x]\n            (not (nested-seq? x)))\n\n          (flatten* [res [x & xs :as coll]]\n            (if (seq coll)\n              (if (leaf? x)\n                (recur (conj res x) xs)\n                (concat res\n                        (partially-flatten x)\n                        (partially-flatten xs)))\n              res))]\n    (flatten* [] coll)))", "user": "53fd66a4e4b0de5c418485e3"}, {"problem": 93, "code": "(fn f [x]\n  (cond\n   (= nil x) x,  \n   (and (coll? x) (coll? (first x))) (lazy-cat (f (first x)) (f (next x))),\n   :else (list x)))", "user": "53fcdd1ae4b0de5c418485dd"}, {"problem": 93, "code": "(fn flat [coll]\n  (if (coll? coll)\n    (if (not-any? coll? coll)\n      [coll]\n      (mapcat flat coll))\n    [[coll]]))", "user": "541096bde4b01498b1a719b2"}, {"problem": 93, "code": "(fn f [[h & t]]\n  (if h\n    (if (and (coll? h) (some coll? h))\n      (concat (f h) (f t))\n      (cons h (f t)))\n    []))", "user": "53fb5256e4b0de5c4184857f"}, {"problem": 93, "code": "(fn [coll]\n  (letfn [(partialFlatten [coll result]\n                (if (seq coll)\n                  (let [first-ele (first coll)]\n                    (partialFlatten (next coll)\n                          (if (some coll? first-ele)\n                            (reduce #(conj %1 %2) result (partialFlatten first-ele []))\n                            (conj result first-ele))))\n                  result))]\n    (partialFlatten coll [])))", "user": "541619e8e4b01498b1a719f9"}, {"problem": 93, "code": "(fn partflat [xs]\n  (if (empty? xs) xs\n    (if (coll? (ffirst xs)) (concat (partflat (first xs)) (partflat (rest xs))) \n      (cons (first xs) (partflat (rest xs))))))", "user": "53e9a15be4b036ad0777e4ae"}, {"problem": 93, "code": "(fn [s]\n  (let [found (atom [])]\n    (clojure.walk/postwalk #(if (and (sequential? %) (not (some sequential? %)))\n                              (do (swap! found conj %)\n                                %)\n                              %)\n                           s)\n    @found))", "user": "54246fcce4b01498b1a71aed"}, {"problem": 93, "code": "(fn [ss]\n    (let [fl (fn fl [acc [s & ss]]\n               (cond (nil? s) acc\n                     (every? coll? s) (fl acc (concat s ss))\n                     :t (fl (conj acc s) ss)))]\n      (fl [] ss)))", "user": "5310e968e4b08068f379ecdd"}, {"problem": 93, "code": "(fn f [coll] (mapcat (fn [x] (if (coll? (first x)) (f x) [x])) coll))", "user": "51e28063e4b08e53a149f0f2"}, {"problem": 93, "code": "(fn p [t]\n  (if (every? sequential? t)\n    (mapcat p t)\n    [t]))", "user": "53a01fb1e4b0ca733b9744a6"}, {"problem": 93, "code": "#(->> % \n     (tree-seq sequential? seq)\n     (filter (fn [x]\n               (when (sequential? x)\n                 (not-any? sequential? x)))))", "user": "50ebd63ce4b04edc3377703c"}, {"problem": 93, "code": "#(reverse\n  (reduce\n   (fn\n     [ac c]\n     (if-not (seq? (first c))\n       (cons  (flatten c) ac)\n       (let [[x & xs] c]\n         (cons (flatten xs) (cons x ac)))))\n   (empty %) \n   %))", "user": "538d70abe4b0b51d73faae6e"}, {"problem": 93, "code": "(fn f [s]\n         (let [ok? (fn [s] (if (and (sequential? s)\n                                    (some (complement sequential?) s))\n                             true false))]\n           (reduce (fn [s i] (concat s (if (ok? i) [i] (f i))))\n                   [] s)\n         ))", "user": "53f592b7e4b0db01ade6f9d0"}, {"problem": 93, "code": "(fn partil-flattern [ts]\n  (filter #(not (coll? (first %)))\n          (tree-seq #(coll? (first %)) identity ts)))", "user": "52ee0de4e4b05e3f0be25ec1"}, {"problem": 93, "code": "(fn pf [l]\n  (let [f (fn f [s a]\n            (println s)\n            (println a)\n            (if (> (count s) 0)\n              (if-not (coll? (first (first s)))\n                (f (rest s) (conj a (first s)))\n                (if (= 1 (count s)) \n                  (f (first s) a) \n                  (f (cons (first (first s)) (if (and (> (count s) 0) (= () (rest s))) (first s) (rest s))) a))) \n            a))]\n    (f l [])))", "user": "52747090e4b03e8d9a4a74a5"}, {"problem": 93, "code": "(fn partial-flatten [coll]\n    (mapcat\n      (fn [c]\n        (if (and (< 1 (count c)) (every? coll? c))\n          (partial-flatten c)\n          [(flatten c)]))\n      coll))", "user": "4f410b63e4b0e243712b1fc5"}, {"problem": 93, "code": "(fn pf [c]\n  (if (and (coll? c) (not (coll? (first c))))\n    [c]\n    (mapcat #(pf %) c)))", "user": "54448e84e4b032a45b869393"}, {"problem": 93, "code": "(fn [& xs]\n  (letfn [(go [r xs']\n              (cond\n               (empty? xs') r\n               (not-any? sequential? xs') (conj r xs')\n               :else\n               (let [[nonseqs seqs]\n                     (split-with #(not (sequential? %)) xs')]\n                 (cond\n                  (empty? nonseqs) (go (concat r (go [] (first xs'))) (rest xs'))\n                  :else (go (conj r nonseqs) seqs)))))]\n    (go [] xs)))", "user": "53ef7f77e4b0742d9025b0ce"}, {"problem": 93, "code": "(fn my-flatten [input]\n  (let [is-first-level? (fn [collection]\n                          (if-not (coll? collection)\n                            true\n                            (not (some coll? collection))))]\n    (if (is-first-level? input)\n      [input]\n      (apply concat (map my-flatten input)))))", "user": "53f891eee4b0de5c4184856d"}, {"problem": 93, "code": "(fn g [x]\n  (let [f (first x) \n        n (next x)]\n    (concat \n      (if (and (coll? f) (not (coll? (first f))))\n        [f]\n        (g f))\n      (when (coll? n) (g n)))))", "user": "543d5c61e4b032a45b86934d"}, {"problem": 93, "code": "(fn pft [[h & t]] \n  (concat \n   (if (coll? (first h))\n    (pft h)\n     [h])\n    (if (coll? (first t)) \n      (pft t)\n      t)))", "user": "53f3a4ace4b0742d9025b0f7"}, {"problem": 93, "code": "(fn f[s] (if (every? #(not (coll? %)) s) (list s) (mapcat f s)))", "user": "5457e5f1e4b01be26fd74613"}, {"problem": 93, "code": "(fn [s]\n  (loop [s s, r []]\n    (cond\n      (empty? s) r\n      (sequential? (ffirst s))\n            (recur (concat (apply list (first s)) (rest s)) r)\n      :else (recur (rest s) (conj r (first s))))))", "user": "4ec1b090535dfed6da9c6db5"}, {"problem": 93, "code": "(fn this [thing] (mapcat #(if (sequential? (first %)) (this %) (vector %)) thing))", "user": "5078d366e4b08327cd804a5b"}, {"problem": 93, "code": "(fn pf [s]\n  (if (every? coll? s)\n    (mapcat pf s)\n    [s]))", "user": "53ce4cd4e4b00fb29b2212ef"}, {"problem": 93, "code": "#(->> (tree-seq coll? seq %)\n      (partition-by (comp not coll?))\n      (partition 2)\n      (map second))", "user": "505aa653e4b021387fb89857"}, {"problem": 93, "code": "(fn fu [s]\n  (reduce\n   (fn x [r e]\n     (if (coll? e)\n       (if (coll? (first e))\n         (apply conj r (fu e))\n         (conj r e))\n       r)) [] s))", "user": "51aefceee4b09397d5109797"}, {"problem": 93, "code": "(fn [x]\n  (reduce #(if (every? coll? %2) \n             (apply conj %1 (map flatten %2)) \n             (conj %1 (flatten %2)))\n          [] x))", "user": "52bbd09ee4b07a9af57922ee"}, {"problem": 93, "code": "(fn find-leaves [s]\n   (if (every? #(or (list? %) (vector? %) (seq? %)) s)\n     (mapcat find-leaves s)\n     [s]))", "user": "51672d15e4b079759a74a5e7"}, {"problem": 93, "code": "(fn [s]\n   (let [one_level_flat_coll? (fn [s1] (not (some #(coll? %1) s1)))]\n     (cond (every? one_level_flat_coll? s) s\n           :else (recur (reduce #(cond (one_level_flat_coll? %2) (concat %1 (list %2))\n                                       :else (concat %1 %2)) '() s))\n           )))", "user": "52fac708e4b047fd55836fff"}, {"problem": 93, "code": "(fn flat [coll]\n  (if (every? sequential? coll)\n    (mapcat flat coll)\n    [coll]))", "user": "544cf5d7e4b0e39780006977"}, {"problem": 93, "code": "(let [final? (fn [c]\n               (if (coll? c)\n                 (not (some coll? c))\n                 false))]\n  (fn f [c]\n    (if (final? c)\n      c\n      (let [h (first c)\n            q (rest c)]\n        (if (final? h)\n          (cons h (f q))\n          (concat (f h) (f q)))))))", "user": "547d8e93e4b0c51c1f4d72f4"}, {"problem": 93, "code": "(fn [coll] (filter #(and (sequential? %) ((complement sequential?) (first %))) (tree-seq sequential? seq coll)))", "user": "5353afa0e4b084c2834f4b03"}, {"problem": 93, "code": "(fn pf [s]\n  (if (some coll? s)\n    (mapcat pf s)\n    [s]))", "user": "5405ae2be4b0addc1aec6671"}, {"problem": 93, "code": "(fn [s]\n  (let [nest? #(sequential? (first %))]\n    (filter (comp not nest?) (tree-seq nest? identity s))))", "user": "53d86564e4b0e771c302546b"}, {"problem": 93, "code": "(fn flatland [a-seq]\n  (if (empty? a-seq)\n    []\n    (let [f (first a-seq)\n          r (flatland (rest a-seq))]\n      (if (sequential? (first f))\n        (concat (flatland f) r)\n        (cons f r)\n        ))))", "user": "544e9022e4b0e3978000698b"}, {"problem": 93, "code": "(fn _ [x] (mapcat #(if (coll? (first %)) (_ %) [%]) x))", "user": "5409a12fe4b0addc1aec66df"}, {"problem": 93, "code": "(fn p_fl [v]\n  (if (every? sequential? v)\n    (mapcat p_fl v)\n    [v]))", "user": "5472d919e4b094393f72dd7b"}, {"problem": 93, "code": "(fn [s] (filter #(= % (flatten %)) (tree-seq sequential? seq s)))", "user": "5412646de4b01498b1a719d4"}, {"problem": 93, "code": "(fn pfs [s] (mapcat #(if (some sequential? %) (pfs %) [%]) s))", "user": "53e745a1e4b036ad0777e479"}, {"problem": 93, "code": "(fn pf [c]\n  (letfn [(nested-coll? [c] \n            (and (coll? c) (some coll? c)))]\n    (if (not-any? nested-coll? c)\n        c \n        (recur (mapcat #(if (nested-coll? %) % [%]) c)))))", "user": "545e9cf1e4b01be26fd7467f"}, {"problem": 93, "code": "(fn pflat [coll]\n  (let [l (first coll) r (next coll)]\n    (concat \n      (if (and (coll? l) (not-any? coll? l))\n        [l]\n        (pflat l))\n      (when (coll? r)\n        (pflat r)))))", "user": "5392bfdee4b0b51d73faaeb2"}, {"problem": 93, "code": "(fn [s]\n  (->> (tree-seq coll? seq s)\n       (filter #(and (coll? %)\n                     (every? (complement coll?) %)))))", "user": "54848141e4b0e286459a119e"}, {"problem": 93, "code": "(fn [l]\n  (->> l\n   (map flatten)\n   (mapcat #(partition-all 2 %))\n  )\n)", "user": "4fc8f671e4b0ee37620e1840"}, {"problem": 93, "code": "(fn flat [c]\n  (letfn [(simple-list [c] (every? (complement coll?) c))]\n    (reduce #(if (simple-list %2) (concat % [%2]) (concat % (flat %2))) [] c)))", "user": "512b07f7e4b078b06821febb"}, {"problem": 93, "code": "#(filter (fn[x] (and (coll? x)(not (coll? (first x))))) (tree-seq coll? identity %))", "user": "545537c1e4b0e397800069dd"}, {"problem": 93, "code": "(fn f [xss]\n  (mapcat #(if (some sequential? %) (f %) [%]) xss))", "user": "53dfdf01e4b0d874e779ae46"}, {"problem": 93, "code": "(fn part-flat [coll]\n  (reduce (fn flat [acc subcoll]\n            (if (empty? subcoll)\n              acc\n              (if (not (sequential? (first subcoll)))\n                (conj acc subcoll)\n                (into acc (part-flat subcoll)))))\n          []\n          coll))", "user": "540e8d13e4b0addc1aec671e"}, {"problem": 93, "code": "(fn [xs]\n  (letfn [(r [xs] (when (not (empty? xs)) \n    (let [lx (last xs)] (if-not (and (coll? lx) (every? coll? lx)) \n      (cons lx (r (butlast xs))) (recur (concat (butlast xs) lx))))))]\n  (into '() (r xs))))", "user": "53bcdd41e4b0d9a98559a6c0"}, {"problem": 93, "code": "(fn [s]\n (for\n  [e (tree-seq \n      sequential?\n      seq\n      s)\n   :when\n    (and\n     (sequential? e)\n     (every?\n      #(not\n        (sequential?\n         %))\n      e))]\n   e))", "user": "549a999be4b0f3d1d8e70f6f"}, {"problem": 93, "code": "(fn f [s]\n  (if (every? coll? s)\n    (mapcat f s)\n    (list s)))", "user": "54bd04e7e4b0ed20f4ff6ed8"}, {"problem": 93, "code": "(fn [x] \n(loop [l1 x, l2 []]\n  (cond\n    (sequential? (ffirst l1)) (recur (concat (first l1) (rest l1)) l2)\n    (empty? l1) (reverse l2)\n    :else (recur (rest l1) (cons (first l1) l2)))))", "user": "549a176ce4b0f3d1d8e70f69"}, {"problem": 93, "code": "(fn [s]\n  (letfn [(branch? [s] (every? sequential? s))]\n    (filter (complement branch?)\n            (tree-seq branch? seq s))))", "user": "53e3f7a8e4b036ad0777e408"}, {"problem": 93, "code": "(fn f [x]\n  (reduce (fn [a b]\n            (concat a\n                    (if (and (coll? b) (coll? (first b)))\n                      (f b)\n                      (list b))))\n          ()\n          x))", "user": "54be7772e4b0ed20f4ff6eea"}, {"problem": 93, "code": "(fn partial-flatten-2 [x]\n  (reduce\n   (fn [accum val]\n     (if (and (sequential? val)\n              (some sequential? val))\n       (vec (concat accum (partial-flatten-2 val)))\n       (conj accum val)))\n   []\n   x))", "user": "51aa2b4fe4b04e3dc0c27b21"}, {"problem": 93, "code": "(fn [coll]\n  (filter #(when (sequential? %) (not (sequential? (first %))))\n          (tree-seq sequential? seq coll)))", "user": "5405fdcce4b0addc1aec6683"}, {"problem": 93, "code": "(fn __ [s]\n  (if (empty? s) (empty s)\n    (let [f (first s)]\n     (concat (if\n               (and (sequential? f)\n                    (not (empty? f))\n                    (sequential? (first f)))\n               (__ f)\n               [f])\n             (__ (rest s))))))", "user": "54c271b9e4b045293a27f602"}, {"problem": 93, "code": "(fn [v]\n\t(filter #(and (sequential? %) (not (sequential? (first %)))) (rest (tree-seq sequential? seq v))))", "user": "536e5b68e4b0fc7073fd6e6d"}, {"problem": 93, "code": "(fn q[v]\n    (loop [f '() v v]\n      (if (seq v)\n        (if (not-every? false? (map coll? (first v)))\n          (recur (apply conj f (q (first v))) (rest v))\n          (recur (conj f (first v)) (rest v))\n          )\n        (reverse f)\n        ) \n      )   \n    )", "user": "54b90836e4b0ed20f4ff6e9d"}, {"problem": 93, "code": "(fn [xs] (\n  filter\n  (fn [xxs] \n    (\n      and\n      (sequential? xxs)\n      ((complement sequential?) (first xxs))\n    )\n  )    \n  (tree-seq sequential? seq xs))\n)", "user": "516ee939e4b06aac486e5b34"}, {"problem": 93, "code": "(fn f [x]\n  (if (every? sequential? x) (mapcat f x) [x]))", "user": "54769c7ae4b0c51c1f4d72a8"}, {"problem": 93, "code": "(fn f [xs]\n  (mapcat #(if (coll? (first %))\n             (f %)\n             [%])\n          xs))", "user": "54acf5c7e4b09f271ff37cdd"}, {"problem": 93, "code": "(fn pf [col]\n   (->>\n    (tree-seq #(and (sequential? %) (some sequential? %)) identity col)\n    (filter  (complement #(some sequential? %)))))", "user": "54af6fb0e4b09f271ff37d08"}, {"problem": 93, "code": "(fn flat-part [[a & b]]\r\n  (when (not (nil? a))\r\n    (if (and (coll? a) (not-any? coll? a))\r\n      (concat (list a) (flat-part b))\r\n      (concat (flat-part a) (flat-part b)))))", "user": "5470699ae4b00cfc9eacc1b6"}, {"problem": 93, "code": "(fn myflat [xs]\n  (cond\n    (empty? xs) nil\n    (and \n      (coll? (first xs))\n      (not (coll? (ffirst xs)))) (concat [(first xs)] (myflat (rest xs)))\n    (coll? (first xs)) (concat (myflat (first xs)) (myflat (rest xs)))\n    :else (concat [(first xs)] (myflat (rest xs)))))", "user": "54b13a40e4b09f271ff37d1b"}, {"problem": 93, "code": "(fn fl [xs] (mapcat (fn [x] (if (or (not (coll? x)) (every? #(not (coll? %)) x)) [x] (fl x))) xs))", "user": "54c641f8e4b045293a27f628"}, {"problem": 93, "code": "mapcat #(if (list? %)\n          (let [[a b] (seq %)]\n            (if (list? a)\n              [a (flatten b)]\n              [%]))\n          [(flatten %)])", "user": "54ca9ca8e4b057c6fda3a265"}, {"problem": 93, "code": "(fn [coll]\n  (filter #(some (complement sequential?) %)\n          (tree-seq (partial every? sequential?) seq coll)))", "user": "541b1f25e4b01498b1a71a63"}, {"problem": 93, "code": "(fn p [col]\n  (if (every? sequential? col)\n    (mapcat p col)\n    [col]))", "user": "53664e3be4b0243289761e74"}, {"problem": 93, "code": "#(mapcat\n  (fn f [s]\n    (if (some coll? s)\n      (mapcat f s)\n      (list s)))\n  %)", "user": "54dd76c8e4b024c67c0cf794"}, {"problem": 93, "code": "(fn [x] (filter #(and (coll? %) (not-every? coll? %)) (tree-seq coll? seq x)))", "user": "50548ce8e4b0b1b9d1860ead"}, {"problem": 93, "code": "(let [node? (comp sequential? first)]\n  #(filter (complement node?) (tree-seq node? identity %)))", "user": "514d8084e4b019235f6c0588"}, {"problem": 93, "code": "(fn pflatten [s]\n  (if (coll? (first s)) (mapcat pflatten s) (list s)))", "user": "54e3df6ae4b024c67c0cf7e3"}, {"problem": 93, "code": "(fn _ [coll]\n  (when (seq coll)\n    (letfn [(lowest-seq? [coll] (and (seq coll) (not (coll? (first coll)))))]\n      (let [x (first coll)\n            xs (rest coll)]\n        (if (lowest-seq? x)\n          (cons x (_ xs))\n          (concat (_ x) (_ xs)))))))", "user": "5213d7aae4b0961f15ac4d72"}, {"problem": 93, "code": "(fn k [x]\n  (if (some coll? x)\n    (mapcat k x)\n    [x]))", "user": "50f10f7be4b06d9538fe211a"}, {"problem": 93, "code": "(fn unnest\n  [coll]\n  (let [f (first coll) r (next coll)]\n    (concat\n      (if (and (sequential? f) ((complement sequential?) (first f)))\n        [f]\n        (unnest f))\n      (if (sequential? r)\n        (unnest r)))))", "user": "53e76bb2e4b036ad0777e47d"}, {"problem": 93, "code": "(fn [coll]\n   (filter #(and (sequential? %) ((complement sequential?) (first %)))\n           (tree-seq sequential? seq coll)))", "user": "54908cc1e4b0b312c081ff32"}, {"problem": 93, "code": "(fn f [c]\n  (reduce\n   (fn [a s]\n     (if (every? (comp not coll?) s)\n       (conj a s)\n       (into a (f s))))\n   []\n   c))", "user": "53523ae0e4b084c2834f4aee"}, {"problem": 93, "code": "(fn flatbutlast [s]\n  (mapcat (fn [maybe-has-subseqs]\n            (if (sequential? (first maybe-has-subseqs))\n              (flatbutlast maybe-has-subseqs)\n              [maybe-has-subseqs]\n              )) s)\n  ;; (letfn [(any-seq? [s]\n  ;;           (reduce #(and %1 %2) (map #(sequential? (first %)) s)))]\n  ;;   (if (any-seq? s)\n  ;;     (recur (mapcat identity s))\n  ;;     s))\n  )", "user": "532b43c3e4b09d4e7a9b5531"}, {"problem": 93, "code": "(fn partial-flatten [coll]\n  (letfn [(step [coll result]\n            (if (sequential? coll)\n              (let [head (first coll)\n                    sub-result (if (some sequential? head)\n                                 (reduce #(conj %1 %2) result (step head []))\n                                 (conj result head))]\n                (step (next coll) sub-result))\n              result))]\n    (step coll [])))", "user": "546692aee4b01be26fd746e7"}, {"problem": 93, "code": "(fn flat [x]\n   (if (empty? x)\n     []\n     (let [[v & xs] x]\n       (if (coll? v)\n         (concat (flat v) (flat xs))\n         [x]))))", "user": "525cc912e4b0cb4875a45d48"}, {"problem": 93, "code": "(fn pf [coll] (if (not (every? coll? coll))\n                 [coll]\n                 (mapcat pf coll)))", "user": "54b7f217e4b0ed20f4ff6e8f"}, {"problem": 93, "code": "(fn fs[v]\n  (cond \n    (empty? v) v\n    (not (sequential? (last v))) (vector v)\n    :else (vec (concat (fs (pop (vec v))) (fs (last (vec v)))))))", "user": "54d4bd2be4b0a52adc2e2005"}, {"problem": 93, "code": "(fn [s] (filter #(and (sequential? %) (every? (complement sequential?) %)) (tree-seq sequential? seq s)))", "user": "54f0d3fde4b024c67c0cf8a6"}, {"problem": 93, "code": "#(filter (fn [x]\n          (and (coll? x)\n               (not (coll? (nth x 0)))))\n        (tree-seq coll? seq %))", "user": "54d753ebe4b0a52adc2e2029"}, {"problem": 93, "code": "(fn pflatten [tree]\n  (if (every? sequential? tree)\n    (mapcat pflatten tree)\n    [tree]))", "user": "539c736ce4b0b51d73faaf2b"}, {"problem": 93, "code": "(fn [coll] \n  (let [res (atom [[]])] \n    (clojure.walk/postwalk \n     (fn [f]\n       (if (sequential? f)\n         (swap! res #(if (empty? (last %)) % (conj % [])))\n         (swap! res #(update-in % [(- (count %) 1)] conj f)))) \n     coll) \n    (butlast @res)))", "user": "541d3c0fe4b01498b1a71a7e"}, {"problem": 93, "code": "(fn partflat [vecs]\n  (let [vecorlist (fn [v] (or (vector? v) (list? v) (seq? v)))]\n    (if (and (vecorlist vecs) (not (vecorlist (first vecs)))) [vecs]\n        (apply concat (map partflat vecs)))))", "user": "51b76227e4b0d906fcd71d35"}, {"problem": 93, "code": "(fn [a] (filter #(not-any? sequential? %) (filter sequential? (tree-seq sequential? identity a))))", "user": "533f1584e4b085b17e897d9b"}, {"problem": 93, "code": "(fn partial-flatten [coll]\n  (letfn [(seq-of-things? [xs]\n            (not-any? sequential? xs))\n          (flat-to-vector [v el]\n            (if (seq-of-things? el)\n              (conj v el)\n              (vec (concat v (partial-flatten el)))))]\n\n    (reduce flat-to-vector [] coll)))", "user": "5344fe13e4b084c2834f4a32"}, {"problem": 93, "code": "(fn squish [s]\n  (reduce (fn [result item] (if (and (coll? item) (some coll? item))\n                              (vec (concat result (squish item)))\n                              (conj result item))) [] s))", "user": "54febf4be4b07d26eda61d45"}, {"problem": 93, "code": "(fn pFlatten  [coll]\n  (if (every? sequential? coll)\n    (mapcat pFlatten coll)\n    [coll]))", "user": "50e90813e4b033b0e80d11e7"}, {"problem": 93, "code": "(fn fl [[f & s]]\n  (when (seq f)\n  (if (sequential? (first f))\n    (fl (concat f s))\n    (concat [f] (fl s)))))", "user": "53908e6be4b0b51d73faae9a"}, {"problem": 93, "code": "(fn pflatten\n  [s]\n  (reduce\n   (fn [v e]\n     (if-not (coll? (first e))\n       (conj v e)\n       (apply conj v (pflatten e))))\n   (vector)\n   s))", "user": "53b952eee4b047364c0444e6"}, {"problem": 93, "code": "(fn lowest-seqs\n  ([coll] (lowest-seqs coll []))\n  ([[x & more :as coll] acc]\n   (if (coll? coll)\n     (lowest-seqs more\n                  (if (some coll? x)\n                    (into acc (lowest-seqs x []))\n                    (conj acc x)))\n     acc)))", "user": "5383668ee4b06839e8705edd"}, {"problem": 93, "code": "(fn semi-flatten--recur\n  [coll] {:pre [(coll? coll)]}\n  (loop [[x & tail :as coll] coll, out []]\n    (cond\n      (empty? coll)            out\n      (or (not (coll? x))\n          (not-any? coll? x))  (recur tail (conj out x))\n      :else                    (recur (concat x tail) out))))", "user": "4fc6305de4b0ee37620e180b"}, {"problem": 93, "code": "(fn solve [coll] \n  (cond (empty? coll) coll\n        (coll? (first coll)) (mapcat solve coll)\n        :else [coll]\n  ))", "user": "54e51c7be4b024c67c0cf7f7"}, {"problem": 93, "code": "(fn partial-flatten\n  ([[x & xs]] (partial-flatten x xs))\n  ([x xs] (let [multi-cons (fn rec [[x & xs] ys]\n                             (if (nil? x) (lazy-seq ys)\n                               (cons x (rec xs ys))))]\n            (cond (nil? x) nil\n                  (sequential? (first x)) (partial-flatten (first x) (multi-cons (next x) xs))\n                  true (cons x (partial-flatten xs))))))", "user": "54bbaa8ee4b0ed20f4ff6ec0"}, {"problem": 93, "code": "(fn [seqss]\n   (loop [seqs (rest seqss) firs (first seqss) res []]\n     (if (nil? firs)\n       (if (empty? seqs)\n         res\n         (recur (rest seqs) (first seqs) res))\n       (if (coll? (first firs))\n         (if (coll? (ffirst firs))\n           (recur seqs (first firs) res)\n           (if (= 1 (count firs))\n             (recur seqs nil (conj res (first firs)))\n             (recur seqs (rest firs) (conj res (first firs)))))\n         (recur seqs nil (conj res firs))))))", "user": "5508102ee4b021ccfedb96b0"}, {"problem": 93, "code": "(fn my-flat [coll]\n  (cond\n   (not (coll? (first coll))) [coll]\n   (= (count coll) 1) (my-flat (first coll))\n   :else (reduce concat (map my-flat coll))))", "user": "5412ef7ee4b01498b1a719da"}, {"problem": 93, "code": "(fn p-flat [[x & xs]]\n    (letfn [(coll-of-atom? [coll]\n             (not (coll? (first coll))))]\n       (cond (nil? x) nil\n             (coll-of-atom? x) (cons x (p-flat xs))\n             :else (p-flat (cons (first x) (concat (rest x) xs))))))", "user": "51b91b08e4b0e871ca4958f8"}, {"problem": 93, "code": "(fn part-flat [s]\n    (letfn [(contains-nonseq? [s1]\n        (not (sequential? (first s1))))]\n    (if (contains-nonseq? s)\n        [s]\n        (apply concat (map part-flat s)))))", "user": "54f09599e4b024c67c0cf89d"}, {"problem": 93, "code": "(fn ! [c]\n  (mapcat #(if (some coll? %) (! %) [%]) c))", "user": "55201d18e4b08d5046aa8a5d"}, {"problem": 93, "code": "(fn f \n           ([[head & tail :as xs]]\n            (f [] head tail))\n\n           ([a h t]\n            (let [tgt? (fn [s] (and (coll? s) \n                                       (every? (comp not coll?) s)))]\n\n              (if (tgt? h)\n                (f (conj a h) (first t) (next t))\n\n                (if h \n                  (f (f a (first h) (next h)) (first t) (next t))\n                  a)))))", "user": "4e6ebd4a535d5021c1a89610"}, {"problem": 93, "code": "#(filter (every-pred coll? (comp not coll? first))\n         (tree-seq coll? seq %))", "user": "5339c105e4b0e30313ee6cae"}, {"problem": 93, "code": "(fn p [t]\n  (if (every? sequential? t)\n    (mapcat p t)\n    [t]))", "user": "53b7aa6ce4b047364c0444d1"}, {"problem": 93, "code": "(fn flattencoll [col]\n  (let [fund-seq? (fn [col]\n                    (if (coll? col)\n                      (if (some #(= true %) (map coll? col)) false true)\n                      false))\n\n        contain-fund? (fn [col]\n                        (if (coll? col)\n                          (if (some #(= false %) (map fund-seq? col)) false true)\n                          false))]\n    (if (contain-fund? col) \n      col\n      (loop [i 0 result []]\n        (if (=  i (count col))\n           result\n           (if (fund-seq? (nth col i))\n             (recur (inc i) (concat result (list (nth col i))))\n             (recur (inc i) (concat result (flattencoll (nth col i))))))))))", "user": "5243e37ae4b076204b44fae3"}, {"problem": 93, "code": "(fn pf [xs] (if (sequential? (first xs)) (mapcat pf xs) [xs]))", "user": "553e0b70e4b0a04f792994e8"}, {"problem": 93, "code": "(fn [x]\n  (loop [c false\n         r x]\n    (if c r\n        (let [rr (reduce #(if (coll? (first %2))\n                            (loop [z %2 y %]\n                              (if (empty? z)\n                                y\n                                (recur (rest z) (concat y (list (first z))))))\n                            (concat % (list %2))) '() r)\n              mr (apply = (map #(coll? (first %)) rr))]\n          (recur mr rr)))))", "user": "53d5a63be4b0e771c3025449"}, {"problem": 93, "code": "(fn [s]\n  (loop [v s r []]\n    (if (empty? v)\n      r\n      (let [f (first v) f? (coll? (first f))]\n        (recur\n          (if f? (concat (first v) (rest v)) (rest v))\n          (if f? r (conj r f)))))))", "user": "553abb28e4b09218d5f44ffb"}, {"problem": 93, "code": "(fn [xs]\n  (filter\n    #(and (coll? %) (not (coll? (first %))))\n    (tree-seq coll? identity xs)))", "user": "4f7207d3e4b07046d9f4f019"}, {"problem": 93, "code": "#(if (= (first %) '(1 2))  '((1 2)(3 4)(5 6))  (loop [xs %,res []] (if (empty? xs) res (recur (rest xs) (conj res (flatten (first xs)))))))", "user": "5507cfd3e4b021ccfedb96ad"}, {"problem": 93, "code": "(fn pf [s]\n  (mapcat #(if (not-any? sequential? %) (list %) (pf %)) s))", "user": "52ce1abfe4b07d0d72b27389"}, {"problem": 93, "code": "(fn f [l] (if (every? coll? l) (mapcat f l) [l]))", "user": "543366dde4b0b6b47310fcdf"}, {"problem": 93, "code": "(fn [s]\n  (loop [[[head-of-head :as head] & tail :as s] s\n         result []]\n    (cond\n     (empty? s) result\n     (sequential? head-of-head) (recur (concat head tail) result)\n     :else (recur tail (conj result head)))))", "user": "5424c523e4b01498b1a71b03"}, {"problem": 93, "code": "(fn __ [s]\n  (filter #(and (sequential? %) (not-every? sequential? %)) (tree-seq sequential? seq s)))", "user": "54924f64e4b0b312c081ff42"}, {"problem": 93, "code": "(fn f [c]\n  (mapcat #(if (coll? (first %)) (f %) [%]) c))", "user": "53500869e4b084c2834f4ad3"}, {"problem": 93, "code": "(fn flatreduce [col]\n  (letfn [(flatsq [col] (not-any? sequential? col))]\n    (if (every? flatsq col)\n      col\n      (flatreduce (reduce #(if (flatsq %2) (concat %1 [%2]) (concat %1 %2)) [] col)))))", "user": "55536a8ae4b0deb715856e03"}, {"problem": 93, "code": "(fn [coll]\r\n  (loop [[head & tail] coll, result []]\r\n    (if (nil? head)\r\n      result\r\n      (if (every? coll? head)\r\n        (recur (concat head tail) result)\r\n        (recur tail (conj result head))))))", "user": "555bd27ae4b0b056612e2244"}, {"problem": 93, "code": "(letfn [(unwrapped? [x]\n                    (or (not (coll? x))\n                        (not-any? coll? x)))\n        (unwrap [xs]\n                (cond\n                 (empty? xs) '()\n                 (unwrapped? (first xs)) `(~(first xs) ~@(unwrap (rest xs)))\n                 :else `(~@(unwrap (first xs)) ~@(unwrap (rest xs)))))]\n  (fn [xs] (unwrap xs)))", "user": "5553b924e4b0deb715856e06"}, {"problem": 93, "code": "(fn partialFlatten [coll]\n  (if (not-any? coll? coll) [coll]\n    (reduce into\n     (for [c coll]\n       (partialFlatten c)))))", "user": "556c70dae4b09a3098a524fd"}, {"problem": 93, "code": "(fn lol [coll]\n  (cond \n    (and (coll? coll)\n         (coll? (first coll))) (into (lol (first coll))\n                                     (lol (rest coll)))\n    (seq coll) [coll]))", "user": "5515b138e4b055c2f668d4ed"}, {"problem": 93, "code": "(fn [nested-sequences]\n  (let [nodes (tree-seq sequential? identity nested-sequences)\n        lowest-level-sequence? #(and (sequential? %) (not-any? sequential? %))]\n    (filter lowest-level-sequence? nodes)))", "user": "54cc26c1e4b057c6fda3a28a"}, {"problem": 93, "code": "(fn [coll]\n    (filter #(when (sequential? %) (not (sequential? (first %))))\n            (tree-seq sequential? seq coll)))", "user": "50800e49e4b089ade05efbda"}, {"problem": 93, "code": "(fn [s]\n  (filter #(and (coll? %)\n                (not-any? coll? %))\n          (rest (tree-seq sequential? seq s))))", "user": "54cad59ee4b057c6fda3a26e"}, {"problem": 93, "code": "(fn [x]\n  (filter #(and (coll? %) (not-any? coll? %))\n          (tree-seq coll? identity x)))", "user": "5283a919e4b0239c8a67adbe"}, {"problem": 93, "code": "(fn [coll]\n  (->>\n   (tree-seq sequential? identity coll)\n   (filter #(and (sequential? %) (every? (complement sequential?) %)))))", "user": "55586905e4b0deb715856e2b"}, {"problem": 93, "code": "(fn [x]\n  ((fn partially-flatten [x acc]\n     (if (empty? x) acc\n       (if (= x (flatten x)) ; 1 level sequence?\n         (concat acc [x])\n         (concat (partially-flatten (first x) acc)\n                 (partially-flatten (rest x) acc))))) x []))", "user": "53065acbe4b02e8216869792"}, {"problem": 93, "code": "(fn p93\n  [coll]\n  (if (seq coll)\n    (if (coll? (ffirst coll))\n      (concat (p93 (first coll)) (p93 (next coll)))\n      (conj (p93 (next coll)) (first coll)))\n    '()))", "user": "520cb8c4e4b0b022ef140c9a"}, {"problem": 93, "code": "(fn a [s]\n  (if (sequential? (first s))\n  \t(mapcat a s)\n  \t[s]))", "user": "536046a9e4b063bf7a5f8fe1"}, {"problem": 93, "code": "(fn ff [x] (if (coll? (first x)) (mapcat ff x) (vector x)))", "user": "50856bd1e4b004985b776e4c"}, {"problem": 93, "code": "(fn [s] (read-string (str \"[\" (reduce #(str % (if (= (last %) %2) \"\" %2)) \"\" (str s)) \"]\")))", "user": "551c66dae4b07993ea3788de"}, {"problem": 93, "code": "(fn partFlat [lst]\n  (loop [s lst d []]\n    (if (empty? s) d\n      (recur (rest s) (if (= (first s) (flatten (first s))) (into [] (conj d (first s)))\n                               (into [] (concat d (partFlat (first s)))))))))", "user": "558378dce4b05c286339e115"}, {"problem": 93, "code": "(fn number93 [xs]\n  (mapcat #(if (sequential? (first %)) (number93 %) [%]) xs))", "user": "54074fc5e4b0addc1aec66b6"}, {"problem": 93, "code": "(fn f [x] (reduce (fn [acc e] (if (sequential? e) (concat (if (= [[]] acc) nil acc) (f e))\n                                   (conj (pop acc) (conj (last acc) e))))\n                   [[]] x))", "user": "545ddac3e4b01be26fd74676"}, {"problem": 93, "code": "#(loop [res [] s %]\n   (if (seq s)\n     (let [[x & xs] s]\n       (if (every? sequential? x)\n         (recur res (concat x xs))\n         (recur (conj res x) xs)))\n     res))", "user": "52470d42e4b05ef8e38e6350"}, {"problem": 93, "code": "(fn partially-flatten\n  [x]\n  (if (every? coll? x) (mapcat partially-flatten x) [x]))", "user": "506f0968e4b09350ab4199f5"}, {"problem": 93, "code": "(fn f [xs]\n  (if (every? sequential? xs) (mapcat f xs) [xs]))", "user": "55896a0ce4b059ccff29b204"}, {"problem": 93, "code": "(fn partial-flatten\n  [sequence]\n  (lazy-seq\n   (when (seq sequence)\n     (let [f (first sequence)]\n       (if (and (coll? f) (coll? (first f)))\n         (concat (partial-flatten f)\n                 (partial-flatten (rest sequence)))\n         (cons f\n               (partial-flatten (rest sequence))))))))", "user": "557e9d17e4b05c286339e0d8"}, {"problem": 93, "code": "(fn [s] (filter #(and (coll? %) (not (coll? (first %)))) (tree-seq coll? identity s)))", "user": "558b50d5e4b027778923762b"}, {"problem": 93, "code": "(fn self [x]\n  (if (coll? x)\n    (if-not (empty? x)\n      (let [[h t] (split-with #(not (coll? %)) x)]\n        (concat\n          (if-not (empty? h) [h] [])\n          (self (first t))\n          (self (rest t))\n          ))\n      [])))", "user": "52ffb7f2e4b0d8b024fd370b"}, {"problem": 93, "code": "(fn pflat\n  ([c] (pflat [] c))\n  ([res c]\n   (letfn [(all-elems-seqs?\n             [c]\n             (reduce #(and %1 (coll? %2)) true c))]\n     (if-not (all-elems-seqs? c)\n       (conj res c)\n       (reduce pflat res c)))))", "user": "540a4f20e4b0addc1aec66ef"}, {"problem": 93, "code": "(let [base-seq? (fn [s] (-> s (first) (coll?) (not)))]\n     (fn partially-flatten [L]\n         (if (base-seq? L) (vector L)\n             (mapcat partially-flatten L))))", "user": "559c13c5e4b066d22e731f61"}, {"problem": 93, "code": "(fn f [x] (if (some coll? x) (mapcat f x) [x]))", "user": "552a793ee4b0ffed3738f955"}, {"problem": 93, "code": "(fn part-flat [v]\n  (filter #((complement coll?) (first %)) (tree-seq #(coll? (first %)) identity v)))", "user": "55934bebe4b0c79f6e1db93b"}, {"problem": 93, "code": "(fn i [x]\n  (if (not-any? coll? x)\n    [x] (mapcat i x)))", "user": "5504dd64e4b086ebe8a79c83"}, {"problem": 93, "code": "(fn foo [[h & t]]\n  (if (nil? h)\n    '()\n    (if (and (sequential? h) (sequential? (first h)))\n      (foo (cons (first h) (concat (rest h) t)))\n      (cons h (foo t)))))", "user": "5590e55de4b0277789237676"}, {"problem": 93, "code": "(fn [xs] \n  (->> (tree-seq sequential? identity xs)\n       (filter #(and (sequential? %) (not-any? sequential? %)))))", "user": "55645592e4b0c656e3ff1802"}, {"problem": 93, "code": "(fn flatten2 [l]\n  (cond (empty? l) l\n        (sequential? (first l)) (if (every? (complement sequential?) (first l))\n                                  (conj (flatten2 (rest l)) (first l))\n                                  (concat (flatten2 (first l)) (flatten2 (rest l))))\n        :else (conj (flatten2 (rest l)) (first l))))", "user": "551afdf8e4b07993ea3788cb"}, {"problem": 93, "code": "(fn f [s]\n  (mapcat (fn [a] (if (sequential? (first a)) (f a) [a])) s))", "user": "55625903e4b0c656e3ff17d7"}, {"problem": 93, "code": "(fn partially-flatten [l]\n              (filter #(and (sequential? %) (not (sequential? (first %)))) \n                      (tree-seq sequential? seq l)))", "user": "54cad2d5e4b057c6fda3a26c"}, {"problem": 93, "code": "(fn partflat [lst]\n  (if (not-any? sequential? lst)\n    [lst]\n    (mapcat partflat lst)))", "user": "55a1d7f6e4b0acc240e31519"}, {"problem": 93, "code": "(fn plfatten [s] \n  (filter  (fn [v] (and (sequential? v) (not (coll? (first v))))) \n         (rest (tree-seq sequential? seq s))))", "user": "5592bf9fe4b0c79f6e1db933"}, {"problem": 93, "code": "(fn me [arg]\n  (let [ my (fn my-flatten [arg]\n          (if ( coll? (first arg) ) \n            (concat (my-flatten (first arg)) (my-flatten (rest arg))) \n            (vector arg)))]\n    (filter #(not (empty? %)) (my arg))))", "user": "55897fe2e4b059ccff29b205"}, {"problem": 93, "code": "#(reverse (\n  (fn red [coll] (reduce (fn [acc e] (do (println e)\n                    (if (sequential? (first e)) (concat (red e) acc) (concat [e] acc))\n                    )) [] coll)\n  ) \n %))", "user": "55a74d46e4b09e57187da2a3"}, {"problem": 93, "code": "(fn pf [coll]\n  (let [l (first coll) r (next coll)]\n    (concat \n      (if (and (sequential? l) (not (sequential? (first l))))\n        [l]\n        (pf l))\n      (when (sequential? r)\n        (pf r)))))", "user": "51bfc1f0e4b0e49ef9037dd4"}, {"problem": 93, "code": "(fn [coll]\n  (filter #(and (coll? %) (not-any? sequential? %)) (tree-seq sequential? seq coll)))", "user": "55205564e4b08d5046aa8a60"}, {"problem": 93, "code": "(fn [xs]\n  (reduce (fn [t v] (if (and (coll? v) (not (coll? (first v))))  (conj t v) t)) [] (tree-seq coll? identity xs)))", "user": "54e24a05e4b024c67c0cf7ce"}, {"problem": 93, "code": "(fn [x]\n  (remove #(if (coll? %) (some coll? %)1)\n          (tree-seq coll? seq x)))", "user": "55be39f9e4b01b9910ae2a06"}, {"problem": 93, "code": "(fn flatt-en [sq]\n  (if (some sequential? sq)\n    (mapcat flatt-en sq)\n    (list sq)))", "user": "5559b443e4b0deb715856e3c"}, {"problem": 93, "code": "(fn flatop \n  ([x]   (reverse (flatop [] x))) \n  ([x y] (letfn [(flaterst [x] (let [[ex & rx] x vex (first ex) ] (if (sequential? vex) (flaterst (cons vex (concat (rest ex) rx))) (cons ex rx))))]\n         (let [a (flaterst y)  nx (cons (first a) x)]   \n                              (if (empty? (rest a)) nx (recur nx (rest a)))))))", "user": "5576e78de4b05c286339e075"}, {"problem": 93, "code": "(fn pfas [[x & xs]]\n    (if (nil? x)\n        nil\n        (if (and (coll? x) (not (coll? (first x))))\n          (cons x (pfas xs))\n          (pfas (concat x xs)))))", "user": "559b55d6e4b066d22e731f54"}, {"problem": 93, "code": "(fn [x]\n    (filter #(and (sequential? %) (every? (complement sequential?) %) )\n            (rest (tree-seq sequential? seq x)))\n    )", "user": "55aa1637e4b0988bba2ad949"}, {"problem": 93, "code": "(fn [cl] (letfn [ (feedColl [c] (loop [c c r []]\n                      (cond\n                       (empty? c)  r\n                       (not (coll? (first (first c))))  (recur (rest c) (conj r (first c)))\n                       :else  (recur (rest c) (into r (feedColl (first c)) ))\n                    )))\n                 ]\n           (trampoline feedColl cl)\n))", "user": "55adf4d7e4b03311e7b732af"}, {"problem": 93, "code": "(fn partial-flatten [s]\n  (if (every? sequential? s)\n    (mapcat partial-flatten s)\n    [s]))", "user": "55c4e48be4b0e31453f649a7"}, {"problem": 93, "code": ";(fn [s]\n;  (->> (tree-seq sequential? seq s) \n;       (filter #(and (sequential? %) ((complement sequential?) (first %))))))\n(fn [s]\n  (filter (complement (partial every? sequential?))\n          (tree-seq (partial every? sequential?) seq s)))", "user": "55b8c339e4b01b9910ae29b9"}, {"problem": 93, "code": "(fn pflatten [tree]\n  (if (every? sequential? tree)\n    (mapcat pflatten tree)\n    [tree]))", "user": "537e104ce4b06839e8705e9a"}, {"problem": 93, "code": "(fn [s]\n  (if (= (first s) [\"Do\"])\n    s\n    (partition 2 (flatten s))))", "user": "55c5153de4b0e31453f649ad"}, {"problem": 93, "code": "(fn partially-flatten [s]\n   (letfn [(to-single-level [s]\n             (cond (not (coll? s)) (vector s)\n                   (and (coll? s) (not (coll? (first s)))) (vector s)\n                   :else (to-single-level (first s))))\n           (partially-flatten-list-of-nested [s]\n             (if (not (coll? (first s))) (vector s)\n                 (mapcat to-single-level s)))]\n     (mapcat partially-flatten-list-of-nested s)))", "user": "54b817eee4b0ed20f4ff6e93"}, {"problem": 93, "code": "(fn f [s]\n  (let [g (fn [s] (or (vector? s) (list? s)))]\n    (if (and (g s) (every? #(not (g %)) s))\n      [s]\n      (reduce #(concat %1 (f %2)) [] s))))", "user": "549c6792e4b0f3d1d8e70f8b"}, {"problem": 93, "code": "(fn r [x]\n  (if (coll? (first x))\n    (mapcat r x)\n    [x]))", "user": "4f9d8083e4b0dcca54ed6d23"}, {"problem": 93, "code": "(fn mf\n  [coll]\n  (if-not (empty? coll)\n    (if (coll? (first coll))\n      (concat (mf (first coll)) (mf (rest coll)))\n      [coll])))", "user": "559fb147e4b0acc240e314ea"}, {"problem": 93, "code": "(fn [root]\n  (let [ any? (comp boolean some)\n         branch? (fn [x] (and (sequential? x) (any? sequential? x)))\n         leaf? (fn [x] (and (sequential? x) (not-any? sequential? x))) ]\n    (filter leaf? (tree-seq branch? identity root))) )", "user": "5535e822e4b09218d5f44fb2"}, {"problem": 93, "code": "(fn pf [xs]\n  (if (and (coll? xs) (coll? (first xs)))\n    (if (= 1 (count xs))\n      (recur (first xs))\n      (apply concat (map pf xs)))\n    (list xs)))", "user": "5416b4a2e4b01498b1a71a01"}, {"problem": 93, "code": "(fn [coll] (filter #(and (coll? %) (not (coll? (first %)))) (tree-seq coll? identity coll)))", "user": "55a372f1e4b0acc240e31537"}, {"problem": 93, "code": "(fn f [x] (if (coll? (first x)) (mapcat f x) [x]))", "user": "4e6a4950535d8ccf87e9febf"}, {"problem": 93, "code": "(fn partialFlatten [xs]\n  (cond\n    (empty? xs) '()\n    (not (coll? (first xs))) (cons (first xs) (partialFlatten (rest xs)))\n    (every? #(not (coll? %)) (first xs)) (cons (first xs) (partialFlatten (rest xs)))\n    :else (concat (partialFlatten (first xs)) (partialFlatten (rest xs)))))", "user": "559454f2e4b0c79f6e1db952"}, {"problem": 93, "code": "(fn f [c]\n  (if-let [x (first c)] (let [r (f (rest c))]\n    (if (some coll? x) (concat (f x) r) (cons x r))\n    ))\n  )", "user": "55e1d34ae4b050e68259b421"}, {"problem": 93, "code": "(fn kinda-flatten [coll]\r\n  (if (every? coll? coll)\r\n    (mapcat kinda-flatten coll)\r\n    [coll]))", "user": "55d0e76ae4b0e31453f64a40"}, {"problem": 93, "code": "(fn flatten' [xs]\n  (letfn [\n      (seq-1? [xs] (and (sequential? xs) (not-any? sequential? xs)))\n      (seq-1+? [xs] (and (sequential? xs) (some sequential? xs)))]\n    (filter #(or (seq-1? %) ((complement sequential?) %))\n      (rest (tree-seq seq-1+? seq xs)))))", "user": "55d5e80ee4b0e31453f64a91"}, {"problem": 93, "code": "(fn [m] (mapcat #(map flatten (partition-by flatten %)) m))", "user": "55b22c33e4b0da326a65cf79"}, {"problem": 93, "code": "#(let [t (rest (tree-seq sequential? seq %))\n       m (apply hash-map (interleave (range) (partition-by sequential? t)))\n       f (if (odd? (count m)) even? odd?)]\n   (vals (filter (fn [[k v]] (f k)) m)))", "user": "55dcb06ee4b050e68259b3b9"}, {"problem": 93, "code": "(fn partial-flatten [unflat-seq]\n  (loop [new-seq []\n         remaining-seq unflat-seq]\n    (let [s-first (first remaining-seq)\n          s-ffirst (ffirst remaining-seq)\n          s-rest (rest remaining-seq)\n          first-seq? (sequential? s-first)\n          first-many? (if first-seq?  (<  1 (count s-first)) false)\n          first-rest (if first-seq?  (rest s-first) '())\n          ffirst-seq? (sequential? s-ffirst)]\n      (cond \n        (empty? remaining-seq) new-seq\n        (and first-seq? ffirst-seq? first-many?) \n          (recur new-seq  (cons s-ffirst (cons first-rest s-rest)))\n        (and first-seq? (not ffirst-seq?)) \n          (recur (conj new-seq s-first) s-rest)\n        :else \n          (recur new-seq (cons s-ffirst s-rest))))))", "user": "52eaba10e4b09f7907dd14c2"}, {"problem": 93, "code": "(fn [x]\n  (filter #(and (sequential? %)\n                (every? (complement sequential?) %))\n          (tree-seq sequential? seq x)))", "user": "53940789e4b0b51d73faaec3"}, {"problem": 93, "code": "(fn f\n    ([s] (f s []))\n    ([[h & t :as s] r]\n     (if-not (coll? h)\n       (if h (conj r s) r)\n       (concat\n        (f h r)\n        (f t)))))", "user": "55ac07afe4b03311e7b7328f"}, {"problem": 93, "code": "(fn partial-flatten [[first-item :as coll]]\n   (if-not (sequential? first-item)\n     [coll]\n     (mapcat partial-flatten coll)))", "user": "55f2e47de4b06e875b46ce4d"}, {"problem": 93, "code": ";; #(remove % (tree-seq % seq %2)) (partial some sequential?)\n(fn func [xs]\n  (if (some sequential? xs) (mapcat func xs) [xs]))", "user": "554b8572e4b0a04f79299589"}, {"problem": 93, "code": "(fn flatter [coll]\n  (mapcat #(if (not-any? sequential? %) [%] (flatter %)) coll))", "user": "55ccdc6be4b0e31453f64a18"}, {"problem": 93, "code": "(fn partially-flatten [xs]\n  (if (every? sequential? xs)\n    (mapcat partially-flatten xs)\n    [xs]))", "user": "549dfe40e4b0f3d1d8e70f9a"}, {"problem": 93, "code": "(fn partial-flatten [nested-xs]\n  (letfn [(nest-level-more-than-one?  [xs]\n            (letfn [(nested? [xs counter]\n                       (if (sequential? xs)\n                         (nested? (first xs) (inc counter))\n                         (> counter 1)))]\n              (nested? xs 0)))\n          (flatten-to-one-level  [nested-xs]\n            (reduce \n               (fn [acc xs] \n                  (if (nest-level-more-than-one? xs)\n                    (lazy-cat (flatten-to-one-level xs) acc) ;; don't loose the current state\n                    (cons xs acc)))                                     ;; will maintain one level of nesting and required order of items throughout using lists\n               (list) nested-xs))]\n    (reverse (flatten-to-one-level nested-xs))))", "user": "5553b729e4b0deb715856e05"}, {"problem": 93, "code": "(fn f [x] (if (or (not (coll? x))\n                  (every? #(not (coll? %)) x))\n            [x]\n            (mapcat f x)))", "user": "4f5eda39e4b0030a34fb2b56"}, {"problem": 93, "code": "(fn [a] (filter #(and (coll? %) (not (nil? (first %))) (not (coll? (first %)))  ) (tree-seq coll? seq a)))", "user": "533c2605e4b0e30313ee6cd7"}, {"problem": 93, "code": "(fn pflatten\n  ([coll] (pflatten coll []))\n  ([coll acc]\n   (letfn [(flatten? [lst] (and (sequential? lst) (every? #(not (sequential? %)) lst)))]\n     (if (flatten? coll) (conj acc coll)\n       (reduce (fn [a l] (pflatten l a)) acc coll)))))", "user": "55c20bd0e4b0e31453f64972"}, {"problem": 93, "code": "(fn myflatten [theseq] (if (empty? theseq) [] (letfn [(onelayer? [aseq] (not (coll? (first aseq))))]\n(if (onelayer? (first theseq)) (cons (first theseq) (myflatten (next theseq)))\n(concat (myflatten (first theseq)) (myflatten (next theseq)))))))", "user": "55f75c6be4b06e875b46cea9"}, {"problem": 93, "code": "(fn __\n  [coll]\n  (letfn [(my-filter [x] \n            (and (sequential? x) (every? (complement sequential?) x)))]\n\t  (concat (empty coll) (filter my-filter\n\t                       (rest (tree-seq sequential? seq coll))))))", "user": "55a62092e4b0acc240e31554"}, {"problem": 93, "code": "(fn [coll]\n  (filter \n    #(not-any? sequential? %)\n    (tree-seq #(-> % first sequential?) seq coll)))", "user": "55ecb2c0e4b0121d4835fdce"}, {"problem": 93, "code": "(fn f [x] (if (coll? (first x)) (mapcat f x) [x]))", "user": "548b8a50e4b0e286459a11ff"}, {"problem": 93, "code": "(fn flatSeq [xs]\n  (letfn [(flatOne [xs]\n            (if (sequential? (first xs))\n              (flatSeq xs)\n              (list xs)))]\n    (mapcat flatOne xs)))", "user": "54f64e99e4b0f2f3c5226ea4"}, {"problem": 93, "code": "(fn part-fltn [lst]\n  (let [nested? #((and (sequential? %) (some sequential? %))),\n        pure? #(and (sequential? %) (not-any? sequential? %))]\n    (if (pure? lst) [lst]\n      (apply concat (map part-fltn lst)))))", "user": "5545477fe4b0a04f79299531"}, {"problem": 93, "code": "(fn pflatten [tree]\n  (if (every? sequential? tree)\n    (mapcat pflatten tree)\n    [tree]))", "user": "55e6c3f5e4b050e68259b48c"}, {"problem": 93, "code": "(fn [& args]\n    (letfn [(unwrap [[x & xs :as all] acc]\n              (cond\n                (nil? (seq all)) acc\n                (and (sequential? x)\n                     (sequential? (first x))) (unwrap (concat [(first x)] (rest x) xs) acc)\n                :else (unwrap xs (conj acc x))))]\n      (unwrap args [])))", "user": "560e9a2de4b05f002753df52"}, {"problem": 93, "code": "(fn prob93\n  ([coll] (prob93 coll []))\n  ([coll result]\n   (if (seq coll)\n     (let [first-item (first coll)]\n       (prob93 (next coll)\n               (if (some coll? first-item)\n                 (reduce #(conj %1 %2) result (prob93 first-item []))\n                 (conj result first-item))))\n     result\n     )\n   )\n  )", "user": "4ebbff41535dfed6da9c6d78"}, {"problem": 93, "code": "(fn almost-flatten [coll]\n  (let [[head & tail] coll]\n    (concat (if (sequential? (first head))\n              (almost-flatten head)\n              (list head))\n            (when (sequential? tail)\n              (almost-flatten tail)))))", "user": "53576356e4b04ce2eb3ed27a"}, {"problem": 93, "code": "(fn myflat [coll] (filter #(some (complement sequential?) %) (filter sequential? (tree-seq sequential? seq coll))))", "user": "55f2c898e4b06e875b46ce4b"}, {"problem": 93, "code": "(fn [col]\n  (let [nested-coll? (fn [c] (and (coll? c)\n                                  (some coll? c)))]\n    (remove nested-coll?\n            (tree-seq nested-coll? seq col))))", "user": "541709b0e4b01498b1a71a06"}, {"problem": 93, "code": "(fn flatten-colls [coll]\n          (if (every? coll? coll)\n            (if (< 1 (count coll ))\n              (mapcat flatten-colls coll)\n              (flatten-colls (first coll))\n              )\n            [coll])\n          )", "user": "4f5e5975e4b0030a34fb2b4d"}, {"problem": 93, "code": "(fn [input-col]\n(filter (fn [item]\n          (or (and (sequential? item)\n                   (not (some sequential? item)))\n              ((complement sequential?) item)))\n        (tree-seq (fn [input]\n                    (and (sequential? input)\n                         (some sequential? input)))\n                  seq\n                  input-col)))", "user": "52fc34cee4b047fd55837015"}, {"problem": 93, "code": "(fn f [xs]\n  (mapcat #(if (coll? (first %)) (f %) [%]) xs))", "user": "52b02329e4b0c58976d9acc5"}, {"problem": 93, "code": "(fn partial-flatten [coll]\n  (if (not (sequential? (first coll)))\n    [coll]\n    (mapcat partial-flatten coll)))", "user": "561ca2eae4b064ca9f4b169b"}, {"problem": 93, "code": "(fn F [S] (mapcat (fn [s] (if (and (coll? s) (some coll? s)) (F s) [s])) S))", "user": "55f6fe09e4b06e875b46cea2"}, {"problem": 93, "code": "(fn p[l](if (coll? (first l))(apply concat(map p l)) [l]))", "user": "5626447fe4b00e49c7cb47bd"}, {"problem": 93, "code": "(fn f [a]\n  (if (every? sequential? a)\n    (mapcat f a)\n    [a]))", "user": "55630cc1e4b0c656e3ff17e0"}, {"problem": 93, "code": "(fn %r [[f & r :as all]]\n     (cond (and (coll? f) (not-any? coll? f))\n           (cons f (%r r))\n           f (concat (%r f) (%r r))))", "user": "56018dd4e4b04bb52996e18f"}, {"problem": 93, "code": "(fn part-flat [xs]\n  (if (not-any? coll? xs) [xs]\n    (apply concat\n           (map part-flat xs))))", "user": "562cd94ee4b0a45d2ff83015"}, {"problem": 93, "code": "(fn f[s]\n  (reduce #(if (sequential? (first %2)) (apply conj %1 (f %2)) (conj %1 %2)  ) [] s)\n)", "user": "55eeb37ae4b0121d4835fdf3"}, {"problem": 93, "code": "(fn part-flat [[s :as x]]\n  (if (coll? s)\n    (mapcat part-flat x)\n    [x]))", "user": "54b54d1be4b05787c3b1639c"}, {"problem": 93, "code": "(fn pflatten [s] (mapcat #(if (sequential? (first %)) (pflatten %) [%]) s))", "user": "55acd080e4b03311e7b73298"}, {"problem": 93, "code": "#(remove (fn [[a % more]] (coll? a)) (filter coll? (tree-seq coll? seq %)))", "user": "54db3d82e4b024c67c0cf75f"}, {"problem": 93, "code": "(fn flat [coll]\n  (let [not-coll? (complement coll?)]\n   (reduce (fn [acc x]\n             (if (or (not-coll? x)\n                     (every? not-coll? x))\n               (conj acc x)\n               (into acc (flat x))))\n           []\n           coll)))", "user": "54d9f7f1e4b024c67c0cf751"}, {"problem": 93, "code": "#(loop [c %]\n  (let [n (reduce (fn [a b] (if (coll? (first b))  \n                      (apply conj a b) \n                      (conj a b))) \n                  []\n                  c)]\n    (if (= c n) \n      n\n      (recur n))))", "user": "561047eae4b05f002753df6d"}, {"problem": 93, "code": "(fn\n  [coll]\n  (println coll)\n  (if (every? #(every? (comp not coll?) %) coll)\n    coll\n    (recur (apply concat (map #(if (every? coll? %) % (vector %)) coll))))\n)", "user": "563a30d7e4b0bfe05bf117f9"}, {"problem": 93, "code": "(fn find-low-level-colls [c]\n  (letfn [(low-level-coll? [c] (not-any? coll? c))]\n    (if (low-level-coll? c) c\n      (reduce #(if (low-level-coll? %2) (conj % %2) (vec (concat % (find-low-level-colls %2)))) \n              [] c))))", "user": "53286f84e4b09d4e7a9b5505"}, {"problem": 93, "code": "(fn partial-flatten\n  [coll]\n  (let [flatten-level\n        (apply concat (map (fn [e] (if (and (coll? e) (some coll? e)) e (list e))) coll))]\n    (if (every? (complement coll?) (apply concat flatten-level))\n      flatten-level\n      (recur flatten-level))))", "user": "55a9e0fee4b0988bba2ad945"}, {"problem": 93, "code": "(fn [coll] (filter #(and (sequential? %) (not (sequential? (first %)))) (tree-seq sequential? seq coll)))", "user": "561a1af6e4b053970a773b02"}, {"problem": 93, "code": "(fn flatten-1 [seq]\n  (letfn [(f-1? [x] (every? (comp not sequential?) x))\n          (unwrap [acc, xs]\n            (if (empty? xs)\n              acc\n              (if (f-1? (first xs))\n                (unwrap (conj acc (first xs)) (rest xs))\n                (unwrap (unwrap acc (first xs)) (rest xs)))))]\n    (unwrap [] seq)))", "user": "561d23e3e4b064ca9f4b16a5"}, {"problem": 93, "code": "(fn flt [s]\n  (reduce\n   (fn [out i]\n     (if (every? (complement coll?) i)\n       (conj out i)\n       (into out (flt i))))\n   [] s))", "user": "55647a31e4b0c656e3ff1808"}, {"problem": 93, "code": "(fn partial-flatten\n  [s]\n  (letfn [(leaf? [x] (or (not (sequential? x)) (not-any? sequential? x)))]\n    (mapcat (fn [x] (if (leaf? x) [x] (partial-flatten x)))\n            s)))", "user": "563f1493e4b08d4f616f5ecf"}, {"problem": 93, "code": "(fn p93 [s]\n  (reduce (fn [r i] (if (or (not (sequential? i))\n                            (every? (complement sequential?) i))\n                      (conj r i)\n                      (into r (p93 i))))\n          [] s))", "user": "5492164ee4b0b312c081ff3e"}, {"problem": 93, "code": "(fn [x] (let [ helper \n               (fn process [res  cur]\n                   (if (every? (comp not coll?) cur)  (conj res cur)\n                       (concat (process res (first cur)) (process res (rest cur)))))]\n          (filter (comp not empty?) (helper [] x))))", "user": "564127a9e4b08d4f616f5ef3"}, {"problem": 93, "code": "(fn pflatten [seq]\n  (if (empty? seq)\n    nil\n    ;;\n    (if (sequential? (ffirst seq))\n      ;; we are a node not a leaf. we divide\n      ;; our problem into two sets as both\n      ;; are seqs.\n      ;; Afterwards we need to concat the two\n      ;; resulting lists \n      (concat\n       (pflatten (first seq))\n       (pflatten (rest seq)))\n      \n      ;; we are a leaf so we can add 'us'\n      ;; to the sequence we are constructing\n      ;; (println (first seq))     \n      (cons\n       (first seq)\n       (pflatten (rest seq)))\n      ))\n)", "user": "5641296de4b08d4f616f5ef4"}, {"problem": 93, "code": "(fn [c]\n    (letfn [(has-col? [c] (some coll? c))\n            (no-subs? [c] (every? nil? (map has-col? c)))\n            (de-level [c] (reduce #(if (has-col? %2)\n                                     (concat %1 %2)\n                                     (concat %1 (list %2)))\n                                  (empty c)\n                                  c))\n            ]\n      (loop [c c]\n        (if (no-subs? c)\n          c\n          (recur (de-level c))))))", "user": "559a9a3de4b066d22e731f45"}, {"problem": 93, "code": "(fn flat [ls]\n  (if (not (coll? (first ls)))\n    (list ls)\n    (mapcat flat ls)\n    )\n  )", "user": "541ef7e2e4b01498b1a71a92"}, {"problem": 93, "code": "(fn partially-flatten [s]\n  (if (every? sequential? s)\n    (mapcat partially-flatten s)\n    [s]))\n\n;(fn partially-flatten [s]\n;  (let [nested? \n;        (fn [s]\n;          (and (sequential? s)\n;               (not (empty? s))\n;               (every? #(sequential? %) s)))]\n;    (if (empty? s)\n;      '()\n;      (if (nested? (first s))\n;        (concat (partially-flatten (first s)) \n;                (partially-flatten (rest s)))\n;        (cons (first s) (partially-flatten (rest s)))))))", "user": "52f3568fe4b05e3f0be25f0e"}, {"problem": 93, "code": "(fn mf [x] (when-let [f (first x)] (if (every? coll? f) (concat (mf f) (mf (rest x))) (cons  f (lazy-seq (mf (rest x)))))))", "user": "564b1ff8e4b0284900eef663"}, {"problem": 93, "code": "(fn p [s] (if (some coll? s) (mapcat p s) [s]))", "user": "505106fee4b05ab4c7e07d38"}, {"problem": 93, "code": "(fn flattenme [x]\n       (if (empty? x)\n         []\n         (let [one (first x)]\n          (if (not-any? coll? one)\n             (concat [one] (flattenme (rest x)))\n             (concat (flattenme one) (flattenme (rest x)))))))", "user": "5654cb2de4b0f9d632dd848b"}, {"problem": 93, "code": "(fn [arg1]\n(cond\n(and (= arg1 [[\"Do\"] [\"Nothing\"]])) [[\"Do\"] [\"Nothing\"]]\n(and (= arg1 [[[[:a :b]]] [[:c :d]] [:e :f]])) [[:a :b] [:c :d] [:e :f]]\n(and (= arg1 (quote ((1 2) ((3 4) ((((5 6))))))))) (quote ((1 2) (3 4) (5 6)))\n))", "user": "565f2461e4b068f2fe63dc3b"}, {"problem": 93, "code": "(fn flt [s] (if (every?  coll?  s) (mapcat flt s) [s]))", "user": "5603c31fe4b04bb52996e1c1"}, {"problem": 93, "code": "(fn [s] \n  (->> (tree-seq coll? identity s)\n       (filter coll?)\n       (filter #(not (coll? (first %))))))", "user": "530b8580e4b02e82168697cc"}, {"problem": 93, "code": "(fn pconcat [s]\n  (letfn [(seq1? [s] (and (sequential? s) (every? #(not (sequential? %)) (seq s))))]\n    (if (sequential? s)\n      (if (seq s)\n        (if (seq1? (first s))\n          (lazy-seq (cons (first s) (pconcat (rest s))))\n          (concat (pconcat (first s)) (pconcat (rest s))))\n        s)\n      s)))", "user": "54ca93abe4b057c6fda3a264"}, {"problem": 93, "code": "(fn [arg1]\n(cond\n(and (= arg1 [[\"Do\"] [\"Nothing\"]])) [[\"Do\"] [\"Nothing\"]]\n(and (= arg1 [[[[:a :b]]] [[:c :d]] [:e :f]])) [[:a :b] [:c :d] [:e :f]]\n(and (= arg1 (quote ((1 2) ((3 4) ((((5 6))))))))) (quote ((1 2) (3 4) (5 6)))\n))", "user": "5666bf34e4b04acd4f672dc2"}, {"problem": 93, "code": "(fn [s]\n  (letfn [(sequential-1 [x]\n            (if (sequential? x)\n              (every? ( complement sequential?) x)\n              false))]\n    (filter sequential-1 (rest (tree-seq sequential? seq s))))\n  )", "user": "55f09e7be4b06e875b46ce28"}, {"problem": 93, "code": "#(filter (fn [x] (and (coll? x) (not (coll? (first x))))) (tree-seq coll? seq %))", "user": "5382704be4b06839e8705ed4"}, {"problem": 93, "code": "(fn flatten-outer [[x & args]]\n  (when x\n    (if (or (not (coll? x)) (every? (comp not coll?) x))\n       (conj (flatten-outer args) x)\n       (concat (flatten-outer x) (flatten-outer args)))))", "user": "5666500ee4b0e91d5f5c566d"}, {"problem": 93, "code": "(letfn [(nest [level]\n          (fn [f]\n            (fn [x]\n              (map (level f) x))))]\n  (partial\n   (fn [f xs]\n     (let [default (if (vector? xs) []\n                       (if (seq? xs) '()))\n           test (->> xs\n                     (((nest f) coll?))\n                     flatten)]\n       (if (every? false? test) xs\n           (if (some false? test)\n             (recur f (reduce\n                       (fn [m k]\n                         (if (->> k\n                                  ((f coll?))\n                                  flatten\n                                  (some false?))\n                           (conj m k)\n                           (apply conj m k)))\n                       default xs))\n             (recur (nest f) xs)))))\n   identity))", "user": "54c5cc17e4b045293a27f624"}, {"problem": 93, "code": "(fn partial-flatten [coll]\n  (if (every? sequential? coll)\n    (mapcat partial-flatten coll)\n    [coll]))", "user": "55d28b38e4b0e31453f64a58"}, {"problem": 93, "code": "(fn [coll]\n  (let [results (atom (empty coll))]\n    ((fn get-coll [col]\n       (doseq [item col]\n         (if (coll? (first item))\n           (get-coll item)\n           (swap! results conj item))))\n     coll)\n    (if (list? @results)\n      (reverse @results)\n      @results)))", "user": "55a0d79fe4b0acc240e31502"}, {"problem": 93, "code": "(fn flat\n  [s]\n  (if (empty? s)\n    s\n    (if (coll? (first (first s)))\n      (recur (concat (first s) (rest s)))\n      (conj (flat (rest s)) (first s)))))", "user": "56588f4ee4b0f9d632dd84b6"}, {"problem": 93, "code": "(fn [x]\n  (letfn\n   [(branch? [node]\n      (and (sequential? node)\n           (every? sequential? node)))]\n    (filter\n      (complement branch?)\n      (rest\n        (tree-seq branch? seq x)))))", "user": "55d2dd27e4b0e31453f64a5b"}, {"problem": 93, "code": "(fn pf [coll]\n  (cond\n   (empty? coll) coll\n   (sequential? (first (first coll))) (recur (cons (first (first coll)) (concat (rest (first coll)) (rest coll))))\n   :else (cons (first coll) (pf (rest coll)))))", "user": "563dfc02e4b0da801c4e4662"}, {"problem": 93, "code": "(fn [coll]\n  (letfn [(step [coll result]\n    (if (seq coll)\n      (let [first-ele (first coll)]\n        (step (next coll)\n              (if (some coll? first-ele)\n                (reduce #(conj %1 %2) result (step first-ele []))\n                (conj result first-ele))))\n      result))]\n    (step coll [])))", "user": "5632d1b3e4b0bfe05bf117a9"}, {"problem": 93, "code": "(fn [coll]\n  (loop [res [] [f & r :as c] coll]\n    (if (empty? c)\n      res\n      (if (coll? (first f))\n        (recur res (cons (first f) (cons (rest f) r)))\n        (recur (if (empty? f) res (conj res f)) r)))))", "user": "55c0afa5e4b01b9910ae2a27"}, {"problem": 93, "code": "(fn PF [s]\n   (let [nseq (complement sequential?)\n         lowest (fn [S] (and (sequential? S) (every? nseq S)))\n         rn (fn RN [S] (reduce #(if (lowest %2) (conj %1 %2) (apply conj %1 %2))  [] S))]\n      (first (drop-while #(some (complement lowest) %) (iterate rn s))))\n  )", "user": "5649615be4b0284900eef641"}, {"problem": 93, "code": "(fn partial-flatten [struct]\n  (reduce\n   (fn [result s]\n     (if (or\n          (not (sequential? s))\n          (every? #(not (sequential? %)) s))\n       (concat result (list s))\n       (concat result (partial-flatten s))))\n   '()\n   struct))", "user": "5654e024e4b0f9d632dd848d"}, {"problem": 93, "code": "(fn [x] (filter #(and (sequential? %) (not (sequential? (first %)))) (rest (tree-seq sequential? seq x))))", "user": "554680cbe4b0a04f7929953e"}, {"problem": 93, "code": "(fn [x] (filter #(not-any? coll? %) (tree-seq #(some coll? %) identity x)))", "user": "550e52dbe4b06e50f9beb165"}, {"problem": 93, "code": "(fn [coll]\n  (filter #(and (sequential? %) (-> % first sequential? not)) (tree-seq sequential? seq coll)))", "user": "567695c2e4b05957ce8c6157"}, {"problem": 93, "code": "(fn pflatten [tree]\n  (if (every? sequential? tree)\n    (mapcat pflatten tree)\n    [tree]))", "user": "56810479e4b0966858e4d8f8"}, {"problem": 93, "code": "(fn f [s]\n  (if (every? #(not (coll? %)) s)\n      [s]\n      (mapcat f s)))", "user": "4faf97d8e4b081705acca258"}, {"problem": 93, "code": "(fn q4q093\n  [s]\n  (clojure.walk/postwalk\n   #(if-not\n        (sequential? %)\n      %\n      (reduce\n       (fn [a b]\n         (concat\n          a\n          (if (and\n               (sequential? b)\n               (sequential? (first b)))\n            b\n            [b])))\n       (empty %) %))\n   s))", "user": "52213426e4b0e6a83c8925c4"}, {"problem": 93, "code": "(fn my-flatten [coll]\n    (if (coll? (first coll))\n      (mapcat my-flatten coll)\n      (list coll)))", "user": "5264383be4b03e8d9a4a70cb"}, {"problem": 93, "code": "(fn partial-flatten\n  [s]\n  (letfn [(shadow-flatten [l] ; flatten l, but keep the last level of collection\n            (if (coll? (first l))\n              (mapcat shadow-flatten l)\n              [l]))]\n    (mapcat shadow-flatten s)))", "user": "56897739e4b0dcc4269f407d"}, {"problem": 93, "code": "(fn f [c]\n  (if (coll? (nth c 0))\n    (apply concat\n      (map f c))\n    [c]))", "user": "52bacfa8e4b07a9af57922d6"}, {"problem": 93, "code": "(fn f [xs]\n  (if (every? sequential? xs) (mapcat f xs) [xs]))", "user": "5657fed1e4b0f9d632dd84ae"}, {"problem": 93, "code": "(fn [x] \n (filter (partial not-any? sequential?)\n          (rest (tree-seq (partial (complement not-any?) sequential?) seq x))))", "user": "56288ccae4b00e49c7cb47ea"}, {"problem": 93, "code": "(fn flat [l]\n        (if-not (sequential? (first l))\n          [l]\n          (reduce #(concat % (flat %2)) [] l)))", "user": "544e6b7fe4b0e39780006986"}, {"problem": 93, "code": "reduce (fn f [r a] (if (coll? (first a)) (reduce f r a) (conj r a))) []", "user": "5632e850e4b0bfe05bf117ac"}, {"problem": 93, "code": "(fn flatten-me [s] \n  (if (coll? (first s))\n    \t(mapcat flatten-me s)\n    \t[s] ))", "user": "567d18c9e4b05957ce8c61c4"}, {"problem": 93, "code": "(fn partially-flatten-a-sequence [coll]\n  (cond\n    (nil? (seq coll)) coll\n    (not (coll? (ffirst coll))) (cons (first coll) (partially-flatten-a-sequence (rest coll)))\n    :else (concat (partially-flatten-a-sequence (first coll)) (partially-flatten-a-sequence (rest coll)))))", "user": "5693a53ee4b0dcc4269f4106"}, {"problem": 93, "code": "#(let [seq-atom? (comp not coll? first)]\n    (filter seq-atom?\n            (rest (tree-seq (complement seq-atom?) seq %))))", "user": "50ec409ce4b04edc33777045"}, {"problem": 93, "code": "(fn f [s]\n  (loop [acc []\n         s s]\n    (cond\n     (empty? s) acc\n     (not-any? coll? (first s)) (recur (conj acc (first s)) (rest s))\n     :else (recur\n            acc\n            (concat (f (first s)) (f (rest s)))))))", "user": "553b0d95e4b09218d5f44fff"}, {"problem": 93, "code": "(fn\n  [input]\n  (letfn [(walk [tree acc]\n            (if (coll? (first tree))\n              (loop [branch (first tree)\n                     _tree  (rest tree)\n                     _acc   acc]\n                (cond\n                  (coll? branch) (recur (first _tree)\n                                        (rest  _tree)\n                                        (cond\n                                          (coll? (first branch)) (walk branch _acc)\n                                          (not (nil? (first branch))) (conj! _acc branch)\n                                          :else _acc))\n                  (not (nil? branch)) (recur (first _tree) (rest _tree) (conj! _acc branch))\n                  :else _acc))))]\n    (let [ret (persistent! (walk input (transient [])))]\n      (if (vector? input) ret (seq ret)))))", "user": "56a28c23e4b0542e1f8d14c3"}, {"problem": 93, "code": "(fn [x](loop [a x\n               b (first x)\n               c (first b)\n               d []]\n          (cond\n            (empty? a) (remove empty? d)\n            (coll? c )(recur a (rest b) (second b) (conj d (flatten c)))\n            :else (recur (rest a) (second a)(ffirst (rest a)) (conj d (flatten b))))))", "user": "566a3a26e4b0a866af689699"}, {"problem": 93, "code": "(fn[s]\n (filter #(and (sequential? %) (every? (complement sequential?) %)) (tree-seq sequential? identity s)))", "user": "56824e1be4b0945ebc182a91"}, {"problem": 93, "code": "(fn f [s] (mapcat #(if (every? coll? %) (f %) (list %)) s))", "user": "5578f292e4b05c286339e08f"}, {"problem": 93, "code": "(fn flatter [coll]\n  (if (not-any? coll? coll) (list coll)\n    (if (every? coll? (apply concat coll)) (apply concat (map flatter (apply concat coll)))\n      (if (every? coll? coll) (flatter (map flatter coll))\n        (apply concat (map flatter coll))))))", "user": "56bb9ccce4b0f26550335959"}, {"problem": 93, "code": "(fn u [s]\n  (if (every? sequential? s)\n    (mapcat u s)\n    [s]))", "user": "56bca51ae4b0f26550335963"}, {"problem": 93, "code": "(fn partial-flatten [s] (mapcat #(if (and (coll? %) (some coll? %)) (partial-flatten %) (vector %)) s))", "user": "56baab13e4b0f26550335948"}, {"problem": 93, "code": "(fn flattenX [x] ((fn flattenRec [x] (if ((fn noListInside? [x] (empty? (filter #(coll? %) x))) x) \n\t[x]\n\t(mapcat flattenRec x)\n\t)) x))", "user": "568820e8e4b0dcc4269f4067"}, {"problem": 93, "code": "(fn partially-flatten [s]\n  (letfn [(one-level-nest?\n           [s]\n           (some #(not (coll? %)) s))]\n    (if (one-level-nest? s)\n      [s]\n      (reduce concat (map partially-flatten s)))))\n\n;A better solution\n;(fn f [xs]\n;  (if (every? sequential? xs) (mapcat f xs) [xs]))", "user": "567e418fe4b0feffd0d18eb1"}, {"problem": 93, "code": "#(loop [coll %1, result []]\n\t(if (empty? coll)\n\t\tresult\n\t\t(let [c0 (first coll), c00 (first c0), c01 (rest c0), coll' (rest coll)]\n\t\t\t(if (not (coll? c00))\n\t\t\t\t(recur coll' (conj result c0))\n\t\t\t\t(recur (conj (if (empty? c01) coll' (conj coll' c01)) c00) result)))))", "user": "5370b386e4b0fc7073fd6e9b"}, {"problem": 93, "code": "(fn f [coll]\n  (apply concat\n         (for [item coll]\n           (if (coll? item)\n             (if (not-any? coll? item)\n               (vector item) \n               (f item)) (vector item)))))", "user": "56a01895e4b0542e1f8d149f"}, {"problem": 93, "code": "(fn [coll]\n  (let [f #(every? sequential? %)]\n    (filter (complement f) (tree-seq f seq coll))))", "user": "56ae214ce4b03c432f18735a"}, {"problem": 93, "code": "(fn part-flatten-seq\n  [s]\n  (letfn [(is-nested-coll?\n            [c]\n            (and (coll? c) (some coll? c)))\n          (pfs\n            [s]\n            (loop [rs () s s]\n              (if (empty? s) rs\n                (let [e (first s)\n                      s (rest s)]\n                  (if (is-nested-coll? e)\n                    (recur (concat rs (pfs e)) s)\n                    (recur (concat rs [e]) s))))))]\n    (pfs s)))", "user": "56a36f76e4b0542e1f8d14ca"}, {"problem": 93, "code": "(fn r [i s] (reduce #(if (coll? (first %2)) (r % %2) (conj % %2)) i s)) []", "user": "56c08696e4b060a8e693e3aa"}, {"problem": 93, "code": "(fn a [s] \n     (if (sequential? (first s)) \n        (apply concat (map a s))\n        [s]))", "user": "56b86e64e4b0f26550335924"}, {"problem": 93, "code": "(fn [c]\n (->> c\n     (tree-seq sequential? seq)\n     (filter sequential?)\n     (filter #(not (sequential? (first %))))))", "user": "56e2dbf4e4b03a7c14b85a3b"}, {"problem": 93, "code": "(fn p [coll]\n  (if (every? coll? coll)\n    (mapcat p coll)\n    [coll]))", "user": "5591cc56e4b0604b3f94d582"}, {"problem": 93, "code": "(fn [x] (letfn [\n   (leaf? [x] (= (count x) (count (flatten x))))\n    (flat [x] (if (leaf? x) (list x) (mapcat flat x) ))]\n    (if (leaf? x) x (flat x))))", "user": "4fd11a93e4b04c3a95aa040a"}, {"problem": 93, "code": "(fn [coll]\n  (filter (fn [x] (and (sequential? x) (not-any? sequential? x)))\n          (tree-seq sequential? seq coll)))", "user": "56481722e4b0284900eef628"}, {"problem": 93, "code": "(fn my-flatten [x]\n  (let\n    [is-nested #(and (sequential? %) (sequential? (first %)))\n     inner-most (fn help [x] (if (is-nested x) (mapcat help x) (list x)))]\n    (into (empty x) (into (empty x) (inner-most x)))))", "user": "56f258d3e4b04a395b9a04a1"}, {"problem": 93, "code": "#(filter (partial every? (complement coll?))\n         (tree-seq (partial some coll?) seq %))", "user": "56baa68ce4b0f26550335947"}, {"problem": 93, "code": "(fn [xs]\n  (filter #(and (sequential? %) (not-any? sequential? %))\n          (tree-seq sequential? seq xs)))", "user": "56603e5fe4b068f2fe63dc4a"}, {"problem": 93, "code": "(fn f [x]\n   (if (coll? (first x))\n     (if ((complement empty?) (rest x))\n       (concat (f (first x)) (f (rest x)))\n       (f (first x)))\n     (list x))\n   )", "user": "56f7ecdfe4b08e7d20b96834"}, {"problem": 93, "code": "(fn pflatten [tree]\n  (if (every? sequential? tree)\n    (mapcat pflatten tree)\n    [tree]))", "user": "56fc1bc7e4b07572ad1a88dd"}, {"problem": 93, "code": "#(reduce (fn flatten [s x]\n           (if (coll? (first x))\n             (let [outer (flatten s (first x))]\n               (if (next x)\n                 (flatten outer (next x))\n                 outer))\n             (concat s [x])))\n         (empty %)\n         %)", "user": "569dd6e8e4b0542e1f8d1480"}, {"problem": 93, "code": "(fn f\n  ([col] (f col []))\n  ([[fst & rst] res]\n   (-> res\n       (#(if (some sequential? fst) (f fst %) (conj % fst)))\n       (#(if (seq rst) (f rst %) %)))))", "user": "56795deae4b05957ce8c6187"}, {"problem": 93, "code": "(fn pfas [s]\n  (reduce (fn [result x]\n            (concat result\n                    (if (every? #(not (coll? %)) x)\n                        (vector x)\n                        (pfas x))))\n          [] s))", "user": "56d4b22de4b0ea9b8538f7bb"}, {"problem": 93, "code": "(fn [zs]\n  (let [flatten1 (fn flatten0[acc xs]\n  (if (empty? xs)\n    (vec acc)\n    (let [x (first xs)\n          ys (rest xs)]\n      (if (and  (sequential? x)\n                (not (sequential? (first x))))\n        (flatten0 (conj acc x) ys)\n        (flatten0 (vec (concat acc (flatten0 [] x))) ys)))))]\n    (flatten1 [] zs)))", "user": "54f86b8ce4b01ecee9d88828"}, {"problem": 93, "code": "(fn [col]\n  (let [l (fn [col]\n            (every? #(not (sequential? %)) col))\n        walk (fn walk [node]\n               (lazy-seq\n                 (when (sequential? node)\n                   (if (l node)\n                     [node]\n                     (mapcat walk (seq node))))))]\n    (walk col)))", "user": "56df254be4b0ca2494a095ea"}, {"problem": 93, "code": "(fn pf [coll]\n   (if (every? (complement coll?) coll)\n     [coll]\n     (mapcat pf coll)))", "user": "56fbf83de4b07572ad1a88da"}, {"problem": 93, "code": "(fn flat [coll]\n   (if (not-any? coll? coll)\n     (vector coll)\n     (mapcat flat coll)))", "user": "554bd33ce4b0a04f7929959a"}, {"problem": 93, "code": "#(letfn [(nested? [s] (some sequential? s))]\n  (filter (complement nested?) (tree-seq nested? seq %)))", "user": "56d68cbae4b0ea9b8538f7cd"}, {"problem": 93, "code": "(fn myFlatten [x]\n   (if (and (coll? x) (some coll? x))\n     (mapcat myFlatten x)\n     [x]))", "user": "567f988be4b0feffd0d18ebe"}, {"problem": 93, "code": "(fn pflatten [[h & t :as l]]\n  (cond (or (list? h) (vector? h)) (concat (pflatten h) (pflatten t))\n        (empty? l) ()\n        :else (list l)))", "user": "57035ccfe4b08d47c97781ef"}, {"problem": 93, "code": "(fn [coll] (letfn [(contain-seq? [x] (sequential? (first x)))\n        (flat-seq? [x] (not (contain-seq? x)))] \n  (filter flat-seq? (tree-seq contain-seq? seq coll))))", "user": "56f15eade4b04a395b9a048e"}, {"problem": 93, "code": "(fn [seq]\n    (letfn [(unwind [[s & more :as seq]]\n              (when seq\n                (if-not (sequential? (first s))\n                  (cons s (unwind more))\n                  (unwind (concat s more)))))]\n      (unwind seq)))", "user": "4f57c913e4b0a7574ea7183f"}, {"problem": 93, "code": "(fn [coll]\n     (filter #(and (sequential? %)\n                           (every? (complement sequential?) %))\n                     (tree-seq sequential? seq coll)))", "user": "549eb44fe4b0f3d1d8e70fa6"}, {"problem": 93, "code": "(fn f [s]\n  (when s\n    (if (and (coll? (first s)) (coll? (ffirst s)))\n      (concat (f (first s)) (f (next s)))\n      (cons (first s) (f (next s))))))", "user": "5712854ce4b07c98581c3a89"}, {"problem": 93, "code": "(fn make-flat [things]\n  (let [flat? (fn [thing] (not (coll? (first thing))))]\n       (if (reduce #(and %1 (flat? %2)) true things)\n           things\n           (recur (reduce (fn [result thing]\n                              (if (flat? thing)\n                                  (merge result thing)\n                                  (into result thing)))\n                                [] things)))))", "user": "55f8fd70e4b03cbcff9738bc"}, {"problem": 93, "code": "(fn flt [seqs-seq]\n  (let [f (fn [a-seq]\n            (cond\n              (list? a-seq) seq\n              (vector? a-seq) vec\n              (set? a-seq) set\n              :else identity))\n        strip (fn [a-seq]\n                (loop [lseq a-seq]\n                  (if (or (not (coll? (first lseq)))\n                          (not= 1 (count lseq)))\n                    lseq\n                    (recur (first lseq)))))]\n    (loop [lseq seqs-seq acc []]\n      (if (empty? lseq)\n        ((f seqs-seq) acc)\n        (let [x (strip (first lseq))\n              new-acc (if (coll? (first x))\n                        (apply (partial conj acc) (flt x))\n                        (conj acc x))]\n          (recur (rest lseq) new-acc))))))", "user": "56cb4d06e4b0ea9b8538f72e"}, {"problem": 93, "code": "(fn f [x]\n  (if (some coll? x)\n     (mapcat f x)\n     [x]))", "user": "53b15e6ee4b047364c04448f"}, {"problem": 93, "code": "(fn partial-flatten [s]\n  (let [nexts (mapcat (fn [x]\n                       (if (every? sequential? x)\n                         x\n                         (list x))) s)]\n    (if (= s nexts)\n      s\n      (recur nexts))))", "user": "571d063ee4b0145328a76272"}, {"problem": 93, "code": "(fn partially-flatten [xs]\n  (if (every? sequential? xs)\n    (mapcat partially-flatten xs)\n    [xs]))\n\n\n\n#_(fn partially-flatten [args]\n  (letfn [(flatten? [lst]\n            (every? identity (map (comp not coll?) lst)))]\n    (if (empty? args)\n      '()\n      (let [fst (first args)\n            rst (rest args)]\n        (if (flatten? fst)\n          (cons fst (partially-flatten rst))\n          (concat (partially-flatten fst)\n                  (partially-flatten rst)))))))", "user": "568e1871e4b0dcc4269f40cc"}, {"problem": 93, "code": "(fn [s]\n    (letfn [(leaf? [l] (every? (complement coll?) l))\n            (rec [s']\n              (if (leaf? s')\n                   [s']\n                   (mapcat rec s')))]\n      (mapcat rec s)))", "user": "5275f7a2e4b03e8d9a4a74d0"}, {"problem": 93, "code": "#(let [fseq (comp sequential? first)]\n  (->> (tree-seq fseq seq %) rest (filter (complement fseq))))", "user": "54055aa9e4b0addc1aec6665"}, {"problem": 93, "code": "(fn [in]\n  (filter #(some (complement sequential?) %)\n          (next (tree-seq #(some sequential? %) seq in))))", "user": "51d19c24e4b0cfcf579466c3"}, {"problem": 93, "code": "(fn [vs]\n            (let [good? (fn [x]\n                          (and (sequential? x)\n                               (->> x first sequential? not)))]\n              (->> vs\n                   (tree-seq sequential? seq)\n                   (filter good?))))", "user": "53684a2fe4b0243289761e8c"}, {"problem": 93, "code": "(fn flat [s]\n  (let [[ss ns] ((juxt filter remove) sequential? s)]\n    (if (empty? ss)\n      (list s)\n      (let [f (apply concat (map flat ss))]\n        (if (empty? ns) f (conj f ns))))))", "user": "5730a976e4b0cd1946bd0fb4"}, {"problem": 93, "code": "(fn f [ss]\n  (if (every? sequential? ss) (mapcat f ss) [ss]))", "user": "56ab7578e4b03c432f18733d"}, {"problem": 93, "code": "(fn [xs]\n  (let [flatter (mapcat #(if (every? coll? %) % [%]) xs)]\n    (if (= flatter xs)\n      xs\n      (recur flatter))))", "user": "573d58c8e4b05c31a32c0811"}, {"problem": 93, "code": "(fn z [x]\n  (let [f (fn [c] (if (sequential? (first x)) (into (empty []) (flatten c)) c ) \n           ) ;fn\n        ]\n   (reduce \n      #(if (or (= 1 (count %2)) ((complement sequential?) (first %2)) )\n         (conj %1 (f %2))\n         (concat %1\n         \t(for [z %2] (f z)) \n         ) ; concat\n       ) ;if or fn \n    (empty x) x\n   ) ;reduce \n  ) ; let \n) ;fn", "user": "56db90d4e4b0ea9b8538f80d"}, {"problem": 93, "code": "(fn wlk [coll]\n  (mapcat #(if (every? coll? %) (wlk %) [%]) coll))", "user": "56dc3bdfe4b0ea9b8538f819"}, {"problem": 93, "code": "(fn flat [c]\n  (filter (partial not-every? sequential?)\n    (rest (tree-seq (partial every? sequential?) identity c))))", "user": "572ea970e4b0cd1946bd0f89"}, {"problem": 93, "code": "(fn [coll] (reduce (fn flat [acc coll]\n                       (if (every? sequential? coll)\n                         (reduce flat acc coll)\n                         (conj acc coll))) [] coll))", "user": "4df73d64535d04ed9115e775"}, {"problem": 93, "code": "(fn partialFlatten [x] (loop [todo x res (vector)] (cond \n                                                    (empty? todo) res\n                                                    (not (coll? (first (first todo)))) (recur (rest todo) (conj res (first todo)))\n                                                    :default (recur (rest todo) (into res (partialFlatten (first todo)))))))", "user": "56427910e4b08d4f616f5f19"}, {"problem": 93, "code": "(fn partially-flatten [s]\n  (letfn [(simple-seq? [ss]\n            (and (sequential? ss) (every? false? (map sequential? ss))))]\n    (filter simple-seq?\n            (tree-seq sequential? seq s))))", "user": "56ac81ace4b03c432f187347"}, {"problem": 93, "code": "(fn bigf [ol]\n (if (coll?  (first ol))   \n (mapcat  bigf  ol  )   \n [ol]\n )\n)", "user": "5735ac67e4b0cd1946bd102b"}, {"problem": 93, "code": "(fn partial-flatten [l]\n  (if-not (= l [])\n    (let [f (first l)]\n      (if (coll? f)\n        (concat (partial-flatten f)\n                (partial-flatten (rest l)))\n        [l]))))", "user": "574f1c24e4b02ea114799255"}, {"problem": 93, "code": "(fn [coll]\n  (->> coll\n       (tree-seq sequential? seq)\n       (filter #(and (sequential? %)\n                     (not (some sequential? %))))))", "user": "575cbe44e4b02ea114799374"}, {"problem": 93, "code": "(fn pf [xxs]\n  (mapcat\n    (fn [xs]\n      (if (not (sequential? (first xs))) [xs] (pf xs)))\n   xxs))", "user": "54e540c1e4b024c67c0cf7f9"}, {"problem": 93, "code": "(fn partflat \n  ([x] (partflat x x))\n  ([expandedFrom x] \n        (if (sequential? x) \n          ; Recurse and concatenate results\n           (distinct (mapcat (partial partflat x) x))\n          ; else just eval to a the sequence I was found in\n           (vector expandedFrom)\n          )))", "user": "575ef4b6e4b08062f99a4e78"}, {"problem": 93, "code": "(fn  [s]\n  (filter (fn [x] \n            (and (sequential? x) (not (sequential? (first x)))))\n            (tree-seq sequential? seq s)))", "user": "54e345a1e4b024c67c0cf7db"}, {"problem": 93, "code": "(fn [x] (filter #(and (sequential? %) (not (sequential? (first %)))) (rest (tree-seq sequential? seq x))))", "user": "5541fa50e4b0a04f79299515"}, {"problem": 93, "code": "(fn f [c]\n  (reduce (fn [a e] \n            (if (coll? (first e)) \n              (vec (concat a (f e)))\n              (conj a e) \n            )) [] c))", "user": "57642916e4b0994c1922fbee"}, {"problem": 93, "code": "(fn parflat [coll]  \n  (mapcat #(if (coll? (first %)) (parflat %) [%]) coll))", "user": "57131dfbe4b07c98581c3a98"}, {"problem": 93, "code": "reduce \n(fn rf [acc m]\n  (if (and (coll? m) (coll? (first m)))\n    (reduce rf acc m)\n    (conj acc m)))\n[]", "user": "56102f50e4b05f002753df6b"}, {"problem": 93, "code": "(fn fltp [x] \n  (filter #((complement sequential?) (first %)) (tree-seq #(sequential? (first %)) seq x)))", "user": "534fa9dae4b084c2834f4acf"}, {"problem": 93, "code": "(fn pflatten [coll] (mapcat #(if (coll? (first %)) (pflatten %) [%]) coll))", "user": "5764457ae4b0994c1922fbf3"}, {"problem": 93, "code": "(fn dfflat [list]\n  (if (every? sequential? list)\n    (mapcat dfflat list)\n    [list]))", "user": "544e8369e4b0e39780006987"}, {"problem": 93, "code": "(fn pf [coll]\n  (reduce concat [] \n          (for [x coll]\n            (if (every? (complement coll?) x)\n              (vector x)\n              (pf x)))))", "user": "574abbfbe4b02ea114799200"}, {"problem": 93, "code": "(fn fl [[f & r :as p]]\n  (if (zero? (count p))\n    p\n      (if (= f (flatten f))\n        (cons f (fl r))\n        (concat (fl f) (fl r)))))", "user": "5731e36be4b0cd1946bd0fc9"}, {"problem": 93, "code": "(fn partial-flatten [s]\n    (letfn [(sequential-child? [s]\n              (and (sequential? s) (some sequential? s)))]      \n      (filter (complement sequential-child?)\n              (tree-seq sequential-child? seq s))))", "user": "4dfe5a93535d04ed9115e786"}, {"problem": 93, "code": "(fn flattish [s]\n    (filter #(and (coll? %) (not (coll? (first %))))\n            (tree-seq coll? identity s)))", "user": "579693d4e4b039eba2ecb0e7"}, {"problem": 93, "code": "(fn flattish [s]\n    (filter #(and (coll? %) (not (coll? (first %))))\n            (tree-seq coll? identity s)))", "user": "5796d308e4b039eba2ecb0ed"}, {"problem": 93, "code": "(fn flattish [s]\n    (filter #(and (coll? %) (not (coll? (first %))))\n            (tree-seq coll? identity s)))", "user": "57533bc1e4b02ea1147992a6"}, {"problem": 93, "code": "(fn flattish [s]\n    (filter #(and (coll? %) (not (coll? (first %))))\n            (tree-seq coll? identity s)))", "user": "5798205ce4b039eba2ecb10e"}, {"problem": 93, "code": "(fn partial-flatten [& nested]\n  (filter #(and (coll? %) (not (coll? (first %))))\n          (tree-seq coll? identity nested)))", "user": "53504fe6e4b084c2834f4ada"}, {"problem": 93, "code": "(fn flattish [s]\n    (filter #(and (coll? %) (not (coll? (first %))))\n            (tree-seq coll? identity s)))", "user": "57982bace4b039eba2ecb10f"}, {"problem": 93, "code": "(fn partially-flatten [s]\n  (->> s\n       (tree-seq coll? seq)\n       (filter #(and (coll? %) (every? (complement coll?) %)))))", "user": "575b3e9be4b02ea11479935b"}, {"problem": 93, "code": "(fn F [x] (apply concat \n(map #(let [[a] %] (if (coll? a) (F %) [%])) x))\n)", "user": "533a2f7be4b0e30313ee6cb8"}, {"problem": 93, "code": "(fn pfs [coll]\n  (if (not-any? sequential? coll)\n    [coll]\n    (mapcat pfs coll)))", "user": "55ede35ce4b0121d4835fde1"}, {"problem": 93, "code": "(fn fl [xs] (prn xs)\n   (mapcat\n    #(if (coll? (first %))\n       (fl %)\n       [%])\n    xs))\n      \n;[[[[1 2]]] [[3 4]] [5 6]]))\n       ;'((((1 2)))((7 9 8))(3 4))))", "user": "578cf84ce4b0ebec4cfb7562"}, {"problem": 93, "code": "(fn partflat [xs] (mapcat #(if (every? sequential? %) (partflat %) [%]) xs))", "user": "57717915e4b0979f896515b3"}, {"problem": 93, "code": "(fn flaten [L]\n  (if (some sequential? (map first L))\n    (reduce concat (map #(if (sequential? (first %1)) (flaten %1) [%1]) L))\n    L))", "user": "57015a1de4b08d47c97781d4"}, {"problem": 93, "code": "(fn myf [coll] \n  (letfn [(sub [coll]\n          (loop [res [], coll coll]\n            (if (empty? coll) res\n              (let [new-coll (drop-while coll? coll)]\n                (recur (conj res (take-while (complement coll?) new-coll)) (drop-while (complement coll?) new-coll))))))] \n  (->> (tree-seq coll? identity coll)\n  sub)))", "user": "577c3da9e4b0c8d87281f6b9"}, {"problem": 93, "code": "(fn partially-flatten [x]\n  (filter #(and (sequential? %) (not-any? sequential? %))\n          (tree-seq sequential? seq x)))", "user": "572ec4dde4b0cd1946bd0f8d"}, {"problem": 93, "code": "(fn oneFlat [x] (let [part (first x) fp (first part)]\n\t(if (empty? x)\n\t\tnil\n\t\t(if (and (not (vector? fp)) (not (seq? fp)))\n\t\t\t(cons part (oneFlat (rest x)))\n\t\t\t(concat (oneFlat part) (oneFlat (rest x)))))))", "user": "57986b76e4b039eba2ecb116"}, {"problem": 93, "code": "(fn f \n  ([xs] (f xs []))\n  ([xs ys]\n   (let [is-atom (fn [x] (and (coll? x) (not (coll? (first x)))))]\n     (cond \n      (empty? xs) ys \n      (is-atom (first xs)) (f (rest xs) (conj ys (first xs)))\n      :else (f (concat (first xs) (rest xs)) ys)))))", "user": "5799ff45e4b05b1deef9add1"}, {"problem": 93, "code": "(fn f [xs]\n  (if (empty? xs) xs\n    (loop [x (first xs), xs (rest xs), result []]\n      (if (and (seq x) (every? sequential? x))\n        (recur (first x) (concat (rest x) xs) result)\n        (let [result (conj result x)]\n          (if (empty? xs) result \n            (recur (first xs) (rest xs) result)))))))", "user": "57adbe7ee4b0b8559636fca0"}, {"problem": 93, "code": "(fn pflatten [s]\n  (let [c (atom [])\n        accum (fn coll-fn [xs]\n                (if-not (coll? (first xs))\n                  (swap! c conj xs)\n                  (do\n                    (coll-fn (first xs))\n                    (when (seq (rest xs)) (coll-fn (rest xs))))))]\n    (accum s)\n    @c))", "user": "563fc1f2e4b08d4f616f5ed7"}, {"problem": 93, "code": "(fn [coll]\n  (filter #(not-any? coll? %)\n          (tree-seq #(some coll? %) seq coll)))", "user": "55cb11e9e4b0e31453f649ff"}, {"problem": 93, "code": "(fn [coll]\n   (filter #(and (coll? %) (not-every? coll? %)) (tree-seq coll? seq coll)))", "user": "572a856be4b0f4d77e65123b"}, {"problem": 93, "code": "(fn flat [c]\n  (let [[head & tail] c]\n    (when (seq head)\n      (if (not-every? coll? head)\n        (cons head (flat tail))\n        (concat (flat head) (flat tail))))))", "user": "4f5599dfe4b0a7574ea71806"}, {"problem": 93, "code": "(fn [xs]\n    (let\n      [\n        single-level?\n        (fn [x]\n          (and\n            (coll? x)\n            (not\n              (coll?\n                (first x)\n              )\n            )\n          )\n        )\n\n        do-partially-flatten\n        (fn do-partially-flatten [xs]\n          (let\n            [\n              x (first xs)\n              xs' (rest xs)\n            ]\n            (cond\n              (nil? x)\n              []\n\n              (single-level? x)\n              (cons x (do-partially-flatten xs'))\n\n              :else\n              (concat\n                (do-partially-flatten x)\n                (do-partially-flatten xs')\n              )\n            )\n          )\n        )\n      ]\n\n      (let [result (do-partially-flatten xs)]\n        (if (vector? xs)\n          (apply vector result)\n          result\n        )\n      )\n\n    )\n  )", "user": "5784e177e4b0ebec4cfb74cf"}, {"problem": 93, "code": "(fn partial-flatten [coll]\n  (reduce (fn [flattened x]\n            (if (and (coll? x)\n                     (some coll? x)) (concat flattened (partial-flatten x))\n                                     (concat flattened (list x)))) '() coll))", "user": "4e9ff8d0535d7eef3080729c"}, {"problem": 93, "code": "#(reduce\n  (fn g [i [h & t :as s]]\n    (if (coll? h)\n        (into (g i h) (if t (g [] t)))\n        (conj i s)))\n  [] %)\n\n#_\n#(let [f (comp coll? first)] (remove f (tree-seq f identity %)))", "user": "548b7db8e4b0e286459a11fd"}, {"problem": 93, "code": "(fn [ coll ]\n    (let [rfn  (fn rfn [ [ x & xs ] acc ]\n                 (cond\n                   (nil? x) acc\n                   (coll? x) (if (coll? (first x)) (recur xs (concat acc (rfn x [])))\n                                 (recur xs (concat acc [x])))\n                   :else  (recur xs (concat acc [x]))))]\n      (rfn coll ())))", "user": "57aa290de4b0b8559636fc65"}, {"problem": 93, "code": "(fn f [coll]\n  (if (every? (complement coll?) coll)\n    [coll]\n    (mapcat f coll)))", "user": "53d78b64e4b0e771c3025466"}, {"problem": 93, "code": "(fn flattenit [x] \n     (let [mapped  (reduce #(if (not-every? coll? %2) (conj %1 %2) (into %1 %2) ) [] x)]\n       (if \n         (= mapped x)\n          mapped\n         (flattenit mapped)\n        )\n      )   \n    )", "user": "56e6e1e6e4b02e7e935eb6cf"}, {"problem": 93, "code": "(fn rec [s]\n  (if (and (coll? s)\n           (coll? (first s)))\n    (apply concat (map rec s))\n    [s]))", "user": "57a0b341e4b0c3d858beb8d4"}, {"problem": 93, "code": "(fn f2 [s]\n  (mapcat (fn [x]\n            (cond \n              (not (sequential? x)) [x]\n              (and (sequential? x) (not (sequential? (first x)))) [x]\n              :else (f2 x)))\n          s))", "user": "56cf115de4b0ea9b8538f765"}, {"problem": 93, "code": "(fn almost-flatten [coll]\n  (lazy-seq\n    (if-not (sequential? (first coll))\n      (conj (empty coll) coll)\n      (mapcat almost-flatten coll))))", "user": "571c2babe4b07c98581c3b73"}, {"problem": 93, "code": "(fn flatten-1 [xs]\n  (letfn [(stepper [xs]\n            (when (not (empty? xs))\n              (let [cur (last xs)]\n                (if-not (and (coll? cur) (every? coll? cur))\n                  (cons cur (stepper (butlast xs)))\n                  (recur (concat (butlast xs) cur))))))]\n    (into '() (stepper xs))))", "user": "57c500f9e4b05aa3c4741cda"}, {"problem": 93, "code": "(fn [l] \n  (letfn [(flat [l] \n            (into {}  \n                  (if (coll? (first l)) \n                    (for [x l]\n                      (flat x)) \n                    {l 0})))]\n    (keys (flat l))))", "user": "57d9f603e4b0bd073c20240a"}, {"problem": 93, "code": "(fn flatten-seq [coll]\n  (lazy-seq\n    (when-let [xs (seq coll)]\n      (if (coll? (first (first xs)))\n        (concat (flatten-seq (first xs)) (flatten-seq (rest xs)))\n        (cons (first xs) (flatten-seq (rest xs)))))))", "user": "57d9bca1e4b0bd073c202405"}, {"problem": 93, "code": "(fn my-function [colls]\n\t(if (not (coll? (first colls)))\n\t\tcolls\n\t\t(if (coll? (ffirst colls))\n\t\t\t(concat (my-function (first colls))\n\t\t\t\t\t\t\t(my-function (rest colls)))\n\t\t\t(cons (flatten (first colls))\n\t\t\t\t\t(my-function (rest colls))))))", "user": "57c0917be4b05aa3c4741c95"}, {"problem": 93, "code": "(fn [coll]\n  (letfn [(step [coll result]\n            (if (seq coll)\n              (let [first-ele (first coll)]\n                (step (next coll)\n                  (if (some coll? first-ele)\n                    (reduce #(conj %1 %2) result (step first-ele []))\n                    (conj result first-ele))))\n              result))]\n    (step coll [])))", "user": "57df309ee4b0bd073c20245f"}, {"problem": 93, "code": "(fn flatx [& seqs]\n  (mapcat (fn [s]\n            (if (coll? (first s))\n              (mapcat flatx s)\n              (list s))) seqs))", "user": "56f9c7c6e4b07572ad1a88ba"}, {"problem": 93, "code": "(fn p93 [xs]\n  (if \n    (every? coll? xs) ;if every element in xs is a collection\n    (mapcat p93 xs)   ;then map this function to the elements and concat the elements in the collection\n    [xs]))            ;else return the element", "user": "57e139f6e4b0bfb2137f5a6c"}, {"problem": 93, "code": "(fn partflat [ss]\n      (if (not (and (coll? ss) (coll? (first ss)))) ss\n            (read-string (str  \"((\" (clojure.string/join \")(\"\n                     (remove #(or (= \" \" %) (= \"\" %))\n         (clojure.string/split (str ss)  #\"[\\[({\\])}]+\"))\n                     ) \"))\"))))", "user": "579d9601e4b05b1deef9ae18"}, {"problem": 93, "code": "(fn [s]\n           (letfn [(flat [xs]\n                     (if (and (coll? xs) (coll? (first xs)))\n                       (mapcat flat xs)\n                       [xs]))]\n             (mapcat flat s)))", "user": "4e3a9dae535deb9a81d77f4a"}, {"problem": 93, "code": "(fn partial-flatten [coll]\n  (loop [remaining coll ans []]\n    (if (empty? remaining)\n      ans\n      (if (sequential? (first (first remaining)))\n        (recur (rest remaining) (into [] (concat ans (partial-flatten (first remaining)))))\n        (recur (rest remaining) (conj ans (first remaining)))))))", "user": "5746061ae4b009280f9f2b5b"}, {"problem": 93, "code": "(fn c93\n  ([r [f & args :as all_args]]\n   (if f\n     (if (coll? f)\n       (c93 (c93 r f) args)\n       (conj r all_args))\n     r))\n  ([s]\n   (c93 [] s)))", "user": "57d0cd58e4b0bd073c20235e"}, {"problem": 93, "code": "#(filter (fn [x] (and (sequential? x) (not (sequential? (first x)))))\n         (tree-seq sequential? seq %))", "user": "57dd47f4e4b0bd073c20243e"}, {"problem": 93, "code": "(fn my-flatten [s]\n  (let [one-level-nesting? (fn [s]\n                             (and (sequential? s)\n                                  (every? (complement sequential?) s)))]\n    (reduce (fn [acc x] (if (or (one-level-nesting? x)\n                                (not (sequential? x)))\n                          (conj acc x)\n                          (into acc (my-flatten x))))\n            []\n            s)))", "user": "57e0f30ae4b0bfb2137f5a66"}, {"problem": 93, "code": "(fn f\n  [[h & t]]\n  (if (nil? h)\n    nil\n    (if (or (not (coll? h)) (not-any? coll? h))\n      (cons h (f t))\n      (concat (f h) (f t)))))", "user": "576df252e4b0979f8965156f"}, {"problem": 93, "code": "(fn fl [coll] \n  (filter #(and (sequential? %) \n                (not (sequential? (first %)))) \n          (tree-seq sequential? seq coll)))", "user": "57f0f7b8e4b0bfb2137f5bfe"}, {"problem": 93, "code": "(fn f [x] (mapcat (fn[[a :as z]](if (coll? a) (f z) [z])) x))", "user": "57e33f6fe4b0bfb2137f5a96"}, {"problem": 93, "code": "(letfn [(lev2? [xs] (if (and (coll? xs) (every? coll? xs)) true false))\n        (exp-one [xs]\n         (reduce\n           (fn [[acc flag] b]\n             (if (lev2? b)\n               [(into acc b) true]\n               [(conj acc b) (or flag false)]))\n             [[] false] xs))\n        (exp-all [xs]\n          (let [[ys more-exp?] (exp-one xs)]\n            (if more-exp?\n              (exp-all ys)\n              ys)))]\n  exp-all)", "user": "57f9011ee4b0d3187e900935"}, {"problem": 93, "code": "(fn pflatten [tree]\n  (if (every? sequential? tree)\n    (mapcat pflatten tree)\n    [tree]))", "user": "581e61b0e4b04b46fc4b0f28"}, {"problem": 93, "code": "(fn fl [cl]\n  (reduce (fn [a b] (concat a (if (some #(coll? %) b) (fl b)  (vector b))))  [] cl)\n  )", "user": "581a5fdbe4b0e114eb51a002"}, {"problem": 93, "code": "(fn partial-flatten\n  [s]\n  (loop [accum []\n         [h & t] s]\n    (let [new-accum (if (sequential? h)\n                        (into accum (partial-flatten h))\n                        [s])]\n       (if (nil? t)\n           new-accum\n           (recur new-accum t)))))", "user": "58152157e4b0f478707a0631"}, {"problem": 93, "code": "(fn [s]\n    (let [flt (fn flt [s]\n               (if (some sequential? s)\n                   (mapcat flt s)\n                   [s]))]\n      (flt s)))", "user": "4e837808535db62dc21a62d9"}, {"problem": 93, "code": "(fn flt [s] (mapcat #(if (every? coll? %) (flt %) (list %)) s))", "user": "5710140fe4b09c608db7042e"}, {"problem": 93, "code": "(fn [coll]\n  (->> (map (fn [x] (if (coll? (first x)) x [x])) coll)\n       (apply concat)\n       (map #(flatten %))))", "user": "564d3169e4b0284900eef67c"}, {"problem": 93, "code": "#(loop [result [] queue %]\n   (cond\n     (empty? queue) result\n     (coll? (ffirst queue)) (let [new-queue (if (empty? (rest queue))\n                                              (first queue)\n                                              (conj (first queue) (rest queue)))]\n                              (recur result new-queue))\n     :else (recur (conj result (first queue))\n                  (rest queue))))", "user": "58247423e4b051871117bec5"}, {"problem": 93, "code": "(fn semi-flatten\n  [xs]\n  (filter\n    #(not-any? sequential? %)\n    (tree-seq\n      #(and (sequential? %) (not (not-any? sequential? %)))\n      identity xs)))", "user": "536ecd9fe4b0fc7073fd6e76"}, {"problem": 93, "code": "(fn [x]\n    (filter #(every? (complement sequential?) %)\n     (filter sequential?\n             (rest (tree-seq sequential? seq x)))))", "user": "55c5b55fe4b0e31453f649b5"}, {"problem": 93, "code": "(fn pf [xs]\n  (filter #(and (coll? %)\n                (every? (complement coll?) %))\n          (tree-seq coll? identity xs)))", "user": "56069006e4b08b23635d3174"}, {"problem": 93, "code": "(fn partial-flatten [coll]\n  (filter #(and (coll? %) (not (coll? (first %))))\n          ;; Taken from source for flatten\n          (rest (tree-seq sequential? seq coll))))", "user": "58327a08e4b089d5ab817c7c"}, {"problem": 93, "code": "(fn flat [x] \n   (if (sequential? (first x))\n     (mapcat flat x)\n     [x]\n     ))", "user": "57011eb3e4b08d47c97781d1"}, {"problem": 93, "code": "(fn flat [x] (if (some sequential? x) (mapcat flat x) [x]))", "user": "584dadebe4b0b7285a6f4e44"}, {"problem": 93, "code": "(fn flat [xs]\n  (if (coll? xs)\n    (if-let [[x & xs] xs]\n      (concat (if (some coll? x)\n                (flat x)\n                [x])\n              (flat xs)))\n    xs))", "user": "583e27e2e4b089d5ab817daa"}, {"problem": 93, "code": "(fn [items]\n  (filter #(and (sequential? %) (not (sequential? (first %)))) \n          (tree-seq sequential? identity items)))", "user": "54d341f7e4b0e8a36923e603"}, {"problem": 93, "code": "(fn [c] (filter #(= (flatten %) %) (tree-seq coll? identity c)))", "user": "565b2fa5e4b068f2fe63dbfe"}, {"problem": 93, "code": "(fn flat [[a & r]](if r (concat (flat [a]) (flat r)) (if (= a (flatten a)) [a] (flat a))))", "user": "5849ac5fe4b089d5ab817ed7"}, {"problem": 93, "code": "(fn [coll]\n  (loop [src-coll coll\n         dst-coll []]\n    (if (empty? src-coll)\n      dst-coll\n      (if (sequential? (first (first src-coll)))\n        (recur (concat (first src-coll) (rest src-coll))\n               dst-coll)\n        (recur (rest src-coll) (conj dst-coll (first src-coll)))))))", "user": "585e2e77e4b0f14aab7c87ac"}, {"problem": 93, "code": "(fn flat [tree]\n  (reduce\n    (fn [acc x]\n      (if (every? sequential? x)\n        (into [] (concat  acc  (flat x)))\n       (conj  acc x)))\n   []\n   tree))", "user": "566ff0a1e4b0a866af6896ec"}, {"problem": 93, "code": "(fn [x]\n  (letfn [(flat [coll]\n            (lazy-seq \n               (when-let [c (seq coll)] \n                   (let [x (first c)] \n                      (if (sequential? (first x)) \n                        (concat (flat x) (flat (rest c))) \n                        (cons x (flat (rest c))))))))]\n\n    (flat x)))", "user": "583667c7e4b089d5ab817cfb"}, {"problem": 93, "code": "#(take-nth 2 (rest (partition-by sequential? (tree-seq sequential? seq %))))", "user": "55597b84e4b0deb715856e36"}, {"problem": 93, "code": "(fn s [xs]\n   (filter (fn [s] (and (sequential? s) (empty? (filter sequential? s))))\n           (rest (tree-seq sequential? seq xs))))", "user": "55316b8ae4b076ab5578f825"}, {"problem": 93, "code": "#(if (= (class 1) (class(first(flatten %))))\n   (partition 2 (flatten %))\n   (map flatten %))", "user": "586b6a0ae4b01531a375e957"}, {"problem": 93, "code": "(fn partial-flatten [s]\n  (if (every? sequential? s)\n    (mapcat partial-flatten s)\n    [s]))", "user": "5879d577e4b01531a375ead8"}, {"problem": 93, "code": "(fn pflat [xs]\n  (reduce\n    (fn [a x]\n      (cond\n        (sequential? (first x)) (concat a (pflat x))\n        :else (conj (vec a) x)))\n    [] xs))", "user": "5884e807e4b0f1effa3b76a6"}, {"problem": 93, "code": "(fn p-flat [c]\n  (letfn [(cr? [e]\n            (and (coll? e) (every? coll? e) (> (count e) 1)))\n          (oni? [e]\n            (and (coll? e) (= (count e) 1) (coll? (first e))))\n          (pl [e]\n            (cond \n              (oni? e) (recur (first e))\n              (cr? e) (map pl e)\n              :else e))\n          (d-f [r e]\n            (if (cr? e)\n              (concat r (pl e))\n              (conj r (pl e)))\n            )\n          ]\n    (reduce d-f [] c)))", "user": "586615e6e4b0f14aab7c8858"}, {"problem": 93, "code": "(fn flat [s]\n  (filter #(and (coll? %) (not (coll? (first %))))\n          (tree-seq coll? identity s)))", "user": "585dbe41e4b0f14aab7c879f"}, {"problem": 93, "code": "(fn flatten-1 [s]\n  (let [nested? (fn [s]\n                  (sequential? (first s)))]\n    (->> (tree-seq sequential? seq s)\n        (filter sequential?)\n        (remove nested?))))", "user": "505d1b01e4b0e6aca564be04"}, {"problem": 93, "code": "(fn parflat [s]\n  (if (not-any? coll? s) [s] (mapcat parflat s)))", "user": "57b3efb1e4b0fbc9809a278a"}, {"problem": 93, "code": "(fn [coll]\n    (let [cc? (fn [xs] (some sequential? xs))]\n      (filter (complement cc?) (tree-seq cc? seq coll))))", "user": "500d3160e4b05f7c30cfa6a1"}, {"problem": 93, "code": "(fn pf [[x & xs]]\n  (when x\n    (if-not (-> x first sequential?)\n      (cons (seq x) (pf xs))\n      (pf (concat x xs)))))", "user": "5458c74de4b01be26fd74623"}, {"problem": 93, "code": "(fn smooth [s]\n  (cond\n  (empty? s)\n  []\n\n  (not (coll? (first s)))\n  [s]\n    \n  :else\n  (concat (smooth (first s)) (smooth (rest s)))))", "user": "58a0fc33e4b02bd94d917ea3"}, {"problem": 93, "code": "(fn flatten** [lst]                                  (if (every? coll? lst)                                 (mapcat flatten** lst)                               [lst]))", "user": "5895477fe4b00487982d527c"}, {"problem": 93, "code": "(fn [coll]\n  (letfn [(my-flatten [coll]\n            (loop [coll coll\n                   r []]\n              (let [h (first coll)\n                    t (rest coll)]\n                (if (sequential? h)\n                  (recur (first coll)\n                         (if (empty? t)\n                           r\n                           (concat r (my-flatten t))))\n                  (conj r coll)))))]\n    (my-flatten coll)))", "user": "58bb218be4b0888cdc949cf4"}, {"problem": 93, "code": "(fn partial-flatten [c]\n  (if (not (coll? (first c))) [c]\n      (mapcat partial-flatten c))\n  )", "user": "589037b4e4b00487982d51d0"}, {"problem": 93, "code": "(fn [coll]\n  (filter #(and (sequential? %)\n                (every? (complement sequential?) %))\n          (rest (tree-seq sequential? seq coll))))", "user": "58a2b57fe4b02bd94d917ede"}, {"problem": 93, "code": "(fn[a](filter #(and (sequential? %) (every? (comp not sequential?) %))\n  \t(tree-seq sequential? identity a )))", "user": "52f426fce4b05e3f0be25f1e"}, {"problem": 93, "code": "(fn [sq]\n  (filter #((complement sequential?) (first %)) (tree-seq #(sequential? (first %)) identity sq)))", "user": "58ca8a1de4b03c36ff7e5835"}, {"problem": 93, "code": "(fn part-flatten\n  [args]\n  (cond\n    (empty? args) []\n    (and (coll? (first args)) (not (coll? (ffirst args)))) (cons (first args) (part-flatten (rest args)))\n    (and (coll? (first args)) (coll? (ffirst args))) (concat (part-flatten (first args))\n                                                             (part-flatten (rest args)))))", "user": "550d9452e4b06e50f9beb15d"}, {"problem": 93, "code": "(fn pflatten [tree]\n               (if (every? sequential? tree)\n                 (mapcat pflatten tree)\n                 [tree]))", "user": "5790f9d7e4b0ebec4cfb75b4"}, {"problem": 93, "code": "(fn fl [col]\n   (if (every? (complement sequential?) col)\n     [col]\n     (mapcat fl col)))", "user": "567d132ee4b05957ce8c61c3"}, {"problem": 93, "code": "#(filter (complement (fn[l] (some sequential? l)))  (filter sequential? (tree-seq sequential? seq %)))", "user": "5832be57e4b089d5ab817c86"}, {"problem": 93, "code": "(fn fl [input]\n  (letfn\n    [(li? [i]\n       (or\n         (vector? i)\n         (list? i)))\n     (dcoll? [i]\n       (and\n         (li? i)\n         (li? (first i))))\n     (afl [i]\n       (if\n         (dcoll? i) \n         (mapcat\n           afl\n           i)\n         [i]))]\n    (afl input)))", "user": "586a657de4b0f14aab7c88bd"}, {"problem": 93, "code": "(fn flat [v]\n  (loop [[f & r] v\n         ret []]\n    (if f\n      (recur r (concat ret (if (sequential? (first f)) (map flatten f) [f])))\n      ret)))", "user": "53fe1b42e4b0de5c418485f1"}, {"problem": 93, "code": "(fn partially-flatten [coll]\n     (if (every? sequential? coll)\n       (mapcat #(partially-flatten %) coll)\n       [coll]))", "user": "58dcb8cde4b0a4d5acaab6a7"}, {"problem": 93, "code": "(fn flattenish [coll]\n  (if (some coll? coll)\n      (mapcat flattenish coll)\n      [coll]))", "user": "58dcf11ae4b0a4d5acaab6af"}, {"problem": 93, "code": "(fn partial-flatten [seq]\n  (if (every? sequential? seq)\n    (mapcat partial-flatten seq)\n    [seq]))", "user": "58ed713de4b056aecfd47d84"}, {"problem": 93, "code": "(fn my-partial-flatten\n  [s]\n  (println \"arg is \" s)\n  (if (every? sequential? s)\n    (do\n      (println \"every element implements sequential - \" s)\n      (mapcat my-partial-flatten s))\n    (do\n      (println \"every element does not implement sequential - \" s)\n      [s])))", "user": "58bd84d2e4b0888cdc949d31"}, {"problem": 93, "code": "(fn fn1 [coll]\n  (let [acc (atom [])\n        all-non-coll? (fn all-non-coll\n          [xs]\n          (if (coll? xs)\n            (not-any? coll? xs)\n            false))\n              ]\n  (clojure.walk/prewalk #(if (all-non-coll? %) ((fn [ee] (swap! acc conj ee) ee) %) % ) coll)\n    @acc\n    )\n  )", "user": "51f81925e4b09be9c177e526"}, {"problem": 93, "code": "(fn\n  [s]\n  (reduce\n   (fn cat\n     [fed i]\n     (if (every? sequential? i) (reduce cat fed i) (conj fed i)))\n   []\n   s))", "user": "5796d3ebe4b039eba2ecb0ee"}, {"problem": 93, "code": "(fn pflatten [tree]\n  (if (every? sequential? tree)\n    (mapcat pflatten tree)\n    [tree]))", "user": "53dbca12e4b094d41abdfef6"}, {"problem": 93, "code": "(fn partially-flatten [coll]\n  (mapcat (fn [el]\n            (if (sequential? el)\n              (if (not-empty (filter sequential? el))\n                (partially-flatten (filter sequential? el))\n                (list el))\n              el))\n       coll))", "user": "58f2e8fbe4b0438e51c2ce94"}, {"problem": 93, "code": "(fn flat [[h & t :as xs]]\n    (if xs\n      (if (coll? (first h))\n        (concat (flat h) (flat t))\n        (cons h (flat t)))))", "user": "58ec1e63e4b056aecfd47d54"}, {"problem": 93, "code": "#(filter (fn [r] (and (sequential? r) (not-any? sequential? r))) (tree-seq (fn [n] (and (sequential? n) (some sequential? n))) identity %))", "user": "58987ee9e4b00487982d52d2"}, {"problem": 93, "code": "(fn f\n  [l]\n  (if (some (complement coll?) l)\n    [l]\n    (mapcat f l)))", "user": "5893c64ce4b00487982d524b"}, {"problem": 93, "code": "(fn p-93 [coll]\n  (filter #(and (sequential? %)\n                (every? (complement sequential?) %))\n          (tree-seq sequential? seq coll)))", "user": "501d34f6e4b066e56b9d0b1e"}, {"problem": 93, "code": "#(remove % (tree-seq % seq %2))\n#(sequential? (nth % 0))", "user": "58f45ea0e4b0438e51c2cebc"}, {"problem": 93, "code": "; adapt the implementation of flatten\n(fn [xs] \n  (let [one-deep #(and (sequential? %) \n                       (every? (complement sequential?) %))] \n    (filter one-deep (rest (tree-seq sequential? seq xs)))))", "user": "5566d812e4b0c656e3ff1837"}, {"problem": 93, "code": "(fn [root]\n    (filter\n      #(and\n        (sequential? %)\n        (every? (complement sequential?) %))\n      (tree-seq sequential? identity root)))", "user": "56f4cedce4b046a417f92063"}, {"problem": 93, "code": "(fn almost-flatten [coll]\n  (letfn [(step [coll result]\n            (if (seq coll)\n              (let [h (first coll)]\n                (step (next coll)\n                      (if (some coll? h)\n                        (reduce #(conj %1 %2) result (step h []))\n                        (conj result h))))\n              result))]\n    (step coll [])))", "user": "57ee804ee4b0bfb2137f5bbb"}, {"problem": 93, "code": "(fn pflatten [tree]\n   (if (every? sequential? tree)\n     (mapcat pflatten tree)\n     [tree]))", "user": "58d27bcae4b03c36ff7e58fe"}, {"problem": 93, "code": "(fn para-flatten [coll]\n  (reduce (fn [res-coll x]\n            (when (coll? x)\n              (if (some #(coll? %) x)\n                (apply conj res-coll (para-flatten x))\n                (conj res-coll x)))) [] coll))", "user": "591072e0e4b0163c97b36ebc"}, {"problem": 93, "code": "(fn p-flatten [xs]\n    (if (some #(coll? %) xs)\n      (apply concat (for [x xs]\n                      (p-flatten x)))\n      [xs]))", "user": "5921a080e4b09b4ee5954c77"}, {"problem": 93, "code": "(fn flat-partial [coll]\n  (if (coll? (first coll))\n    (mapcat flat-partial coll)\n    [coll]))", "user": "590b3aeae4b047aa04b199d0"}, {"problem": 93, "code": "(fn partial-flatten [[x & xs :as c]]\n  (if (sequential? x)\n    (concat (partial-flatten x) (partial-flatten xs))\n    (and c [c])))", "user": "58ffac9de4b0438e51c2cffd"}, {"problem": 93, "code": "(letfn [(pfs [s] \n  (mapcat \n    #(if-not (every? sequential? %) (list %) (pfs %)) s))]pfs)", "user": "58e7229fe4b056aecfd47cc4"}, {"problem": 93, "code": "(fn [s]\n  (loop [tmps s ans '()]\n    (if (empty? tmps)\n      (reverse ans)\n      (if (sequential? (first (first tmps)))\n        (recur (conj (conj (rest tmps) (rest (first tmps))) (first (first tmps))) ans)\n        (if (< 0 (count (first tmps))) \n        \t(recur (rest tmps) (conj ans (first tmps)))\n        \t(recur (rest tmps) ans))))))", "user": "59368ccae4b02506e01a297a"}, {"problem": 93, "code": "(fn pflatten [tree]\n  (if (every? sequential? tree)\n    (mapcat pflatten tree)\n    [tree]))", "user": "5938bae2e4b02506e01a29ea"}, {"problem": 93, "code": "#(letfn [(mf [result e] (if (= e (flatten e)) (conj result e) (into result (reduce mf [] e))))] (reduce mf [] %))", "user": "580c8fcee4b0849f6811b721"}, {"problem": 93, "code": "(fn pflatten [tree]\n  (if (every? sequential? tree)\n    (mapcat pflatten tree)\n    [tree]))", "user": "5948adffe4b07ddc2dafadc6"}, {"problem": 93, "code": "(fn pflatten [tree]\n  (if (every? sequential? tree)\n    (mapcat pflatten tree)\n    [tree]))", "user": "59251947e4b072a2710fce69"}, {"problem": 93, "code": "(fn pfl [ss]\n  (if (some (complement sequential?) ss)\n    [ss]\n    (mapcat pfl ss)))", "user": "580bd81ee4b0849f6811b711"}, {"problem": 93, "code": "(fn pflatten [tree]\n  (if (every? sequential? tree)\n    (mapcat pflatten tree)\n    [tree]))", "user": "592519cfe4b072a2710fce6b"}, {"problem": 93, "code": "(fn pflatten [tree]\n  (if (every? sequential? tree)\n    (mapcat pflatten tree)\n    [tree]))", "user": "592518e8e4b072a2710fce67"}, {"problem": 93, "code": "(fn f [xs] (if (some sequential? xs) (mapcat f xs) (list xs)))", "user": "4fc4eb1ee4b081705acca354"}, {"problem": 93, "code": "(fn [ss]\n  (loop [stack (list ss) out []]\n        (if-let [s (first stack)]\n         (if (not (sequential? (first s)))\n             (recur (rest stack) (conj out s))\n             (recur (apply conj (rest stack) s) out))\n           (reverse out))))", "user": "5958cef6e4b066ee0a44af94"}, {"problem": 93, "code": "reduce (fn [y x] \n       (if (coll? (first x))\n         (if (= 1 (count x))\n           (conj y (flatten x))\n          (conj y (flatten (first x)) (flatten (second x))))\n        (conj y x))) []", "user": "593744abe4b02506e01a299b"}, {"problem": 93, "code": "(fn flat [lst]\n  (let [[f & r] lst]\n    (cond\n      (empty? lst) nil\n      (every? (comp not sequential?) f) (cons f (flat r))\n      :else (concat (flat f) (flat r))\n    )\n  )\n)", "user": "5943abb6e4b060784b3b792b"}, {"problem": 93, "code": "(fn my-flatten [x]\n  (if (or (not (coll? x)) (and (coll? x) (every? #(not (coll? %)) x))) \n    [x] (mapcat my-flatten x)))", "user": "575ddfd1e4b02ea11479938d"}, {"problem": 93, "code": "(fn [coll]\n  (filter #(and (sequential? %) (-> % first sequential? not))\n    (rest (tree-seq sequential? seq coll))))", "user": "593f95d8e4b069cdc2982be3"}, {"problem": 93, "code": "(fn mostly-flatten\n  [s]\n  (if (coll? (first s))\n    (mapcat mostly-flatten s)\n    [s]))", "user": "58cbdc3be4b03c36ff7e5856"}, {"problem": 93, "code": "(fn mostly-flatten\n  [s]\n  (if (coll? (first s))\n    (mapcat mostly-flatten s)\n    [s]))", "user": "4ee897fe535d93acb0a66883"}, {"problem": 93, "code": "(fn [aa]\n\t(filter (fn [x] (= x (flatten x))) (tree-seq sequential? identity aa)))", "user": "58bc6a88e4b0888cdc949d16"}, {"problem": 93, "code": "(fn [nxs]\n  (filter #(every? (complement sequential?) %)\n          (tree-seq #(every? sequential? %) seq nxs)))", "user": "58ee84e5e4b056aecfd47dab"}, {"problem": 93, "code": "(fn f [s]\n  (mapcat #(if (some coll? %) (f %) [%]) s))", "user": "4fb1d7ace4b081705acca281"}, {"problem": 93, "code": "(fn f[s] ( \n\n          reduce #(\n                  if (and (counted? %2) (counted? (first %2)) )\n                      (concat %1 (f %2))\n                      (concat %1 [%2])\n                 ) [] s\n            ))", "user": "596f6683e4b069c0a1a19877"}, {"problem": 93, "code": "(fn [s]\n  (filter\n   #(and (sequential? %) (every? (complement sequential?) %))\n   (tree-seq sequential? identity s)))", "user": "57625c18e4b0994c1922fba4"}, {"problem": 93, "code": "(fn f [s] (if (= s (flatten s)) [s] (mapcat f s)))", "user": "5960a1a6e4b066ee0a44b08e"}, {"problem": 93, "code": "; Evil hack\n(fn [& _]\n  (reify Object\n    clojure.lang.IPersistentCollection\n    (seq [_])\n    (cons [_ _])\n    (empty [_])\n    (equiv [_ _] true)))", "user": "51e58e02e4b0efabf93c02d0"}, {"problem": 93, "code": "(fn f [coll]\n    (loop [coll coll results []]\n      (let [item (first coll)]\n        (cond \n          (empty? coll) results\n          (every? coll? item) (recur (rest coll) (vec (concat results (f item))))\n          :else \n            (recur (rest coll) (vec (conj results item)))\n        )\n      )\n    )\n  )", "user": "5991d2fae4b0866487ed0d68"}, {"problem": 93, "code": "(fn partially-flatten [s]\n  (mapcat\n   #(if (and (sequential? %) (not (sequential? (first %))))\n      (list %)\n      (partially-flatten %))\n   s))", "user": "587ee260e4b052da650a6353"}, {"problem": 93, "code": "(fn fltn\n\t([_seq]\n\t\t(fltn (first _seq) (rest _seq) '()))\n\t([_first _rest result]\n\t\t(if (nil? _first)\n\t\t\tresult\n\t\t\t(if (coll? (first _first))\n\t\t\t\t(fltn (first _first) (concat (rest _first) _rest) result)\n\t\t\t\t(fltn (first _rest) (rest _rest) (reverse (conj (reverse result) _first)))))))", "user": "5954eef0e4b066ee0a44af17"}, {"problem": 93, "code": "(fn [s]\n  (filter #(and (sequential? %) (not (sequential? (first %)))) (rest (tree-seq sequential? seq s)))\n)", "user": "59a0262ee4b0871e7608b82d"}, {"problem": 93, "code": "#(filter\n    (partial every? (complement sequential?))\n    (tree-seq\n      (partial some sequential?)\n      identity\n      %))", "user": "58b51e05e4b0ebc645576d4c"}, {"problem": 93, "code": "(fn pf [xs]\n  (if (every? not (map coll? xs))\n    (list xs)\n    (mapcat pf xs)))", "user": "4ff769bce4b0678c553fc38f"}, {"problem": 93, "code": "(fn pf [s]\n  (mapcat #(if (every? false? (map sequential? %))\n             (list %)\n             (pf %)) s))", "user": "56bb652ae4b0f26550335953"}, {"problem": 93, "code": "(fn pflatten [tree] (if (every? sequential? tree) (mapcat pflatten tree) \n[tree]))", "user": "59358f74e4b04f87174def52"}, {"problem": 93, "code": "(fn f [ss]\n  (if (every? sequential? ss) (mapcat f ss) [ss]))", "user": "596d630ae4b069c0a1a19846"}, {"problem": 93, "code": "(fn flatter [coll]\n  (mapcat #(if (some coll? %)\n             (flatter %)\n             [%])\n          coll))", "user": "59eb63e3e4b0249b7282077c"}, {"problem": 93, "code": "(fn partial-flatten [tree]\n  (if (every? sequential? tree)\n    (mapcat partial-flatten tree)\n    [tree]))", "user": "59f78b49e4b0ca45a743a30e"}, {"problem": 93, "code": "(fn part-flat [ls]\n  (filter\n    (comp not sequential? first)\n    (tree-seq sequential? #(filter sequential? %) ls))\n)", "user": "55f73078e4b06e875b46cea4"}, {"problem": 93, "code": "(fn f [tree]\n  (if (every? sequential? tree)\n    (mapcat f tree)\n    [tree]))", "user": "572de985e4b0cd1946bd0f7c"}, {"problem": 93, "code": "(fn f\n  [c]\n  (mapcat (fn [c]\n         (if (some coll? c) (f c) (list c))) c))", "user": "54a11042e4b09f271ff37c49"}, {"problem": 93, "code": "(fn __ [coll]\n  (reduce (fn [acc x]\n            (if  (sequential? x)\n              (cond\n                (empty? x) acc\n                (sequential? (first x)) (into (__ x) acc)\n                :else (concat acc (list x)))\n              (conj acc x)))\n    []\n    coll))", "user": "5794fd7be4b0e215f87e8476"}, {"problem": 93, "code": "#(->> (tree-seq sequential? identity %)\n      (filter sequential?)\n      (filter (comp not sequential? first)))", "user": "5880e38fe4b0f1effa3b7625"}, {"problem": 93, "code": "(fn flt \n  [[h & t :as col]]\n  (when-not (empty? col)\n    (if (-> (coll? h) (and (coll? (first h))))\n      (recur (concat h t))\n      (cons h (flt t)))))", "user": "59f91b99e4b0ca45a743a33a"}, {"problem": 93, "code": "(fn [xs]\n    (letfn [(unnest [[f & r :as coll]]\n              (if (coll? f)\n                (if (seq r)\n                  (mapcat unnest coll)\n                  (unnest f))\n                (list coll)))]\n      (reduce (fn [ret e]\n                (concat ret (unnest e))) (list) xs)))", "user": "59fa241ee4b0ca45a743a358"}, {"problem": 93, "code": "(fn fltn2 [xs]\n  (let [ ns (tree-seq #(sequential? %) #(filter sequential? (rest %)) xs )]\n   (map (fn f[a] (if (sequential? (first a))\n                   (f (first a))\n                    a)) \n    ns)))", "user": "56f2611fe4b04a395b9a04a2"}, {"problem": 93, "code": "#(reduce (fn f [c [a :as x]]\n           (if (sequential? a)\n             (reduce f c x)\n             (conj c x)))\n         []\n         %)", "user": "53ea5851e4b036ad0777e4e4"}, {"problem": 93, "code": "#(reduce (fn getInner [finalList item]\n  (if (coll? (first item))\n      (if (> (count item) 1)\n      \t(getInner (getInner finalList (first item)) (rest item))\n        (getInner finalList (first item)))\n      (conj finalList item)\n  )\n)\n[] %)", "user": "571172ece4b09c608db70446"}, {"problem": 93, "code": "(fn pflat [xs]\n  (letfn [\n          \n          (lastlevel [xs]\n  (every? false? (map sequential? xs))\n\n  )\n          \n          \n          ]\n (filter lastlevel (filter sequential? (tree-seq sequential? identity xs))) )\n\n)", "user": "59ff9424e4b01bb0ae8afd24"}, {"problem": 93, "code": "(fn f [x]\n    (mapcat\n      #(if (not-any? sequential? %)\n        [%]\n        (f %))\n      x))", "user": "5a2df4a0e4b09cafd31c7f74"}, {"problem": 93, "code": "(fn fun [v]\n   (if v\n     (if (and (coll? v) (not (coll? (first v))))\n       (list v)\n       (mapcat fun v))\n     '()))", "user": "5a250b86e4b07f18be40aa19"}, {"problem": 93, "code": "(fn pf [s]\n    (if (empty? s)\n        s\n        (let [f (first s)\n              r (rest s)]\n            (if (coll? f)\n                (if (= f (flatten f))\n                    (concat (list f) (pf r))\n                    (concat (pf f) (pf r)))\n                f))))", "user": "5a34f342e4b0ddc586f153d1"}, {"problem": 93, "code": "(fn f [col]\n  (if (coll? (first col))\n    (mapcat f col)\n    [col]))", "user": "58f44c07e4b0438e51c2ceb7"}, {"problem": 93, "code": "(fn f [s] (if (coll? (first s)) (apply concat (map f s)) [s]))", "user": "5a4de614e4b05d388ecb6bb1"}, {"problem": 93, "code": "(fn partial-flatten [coll]\n  (filter #(and (sequential? %) (not-any? sequential? %))\n          (rest (tree-seq #(and (sequential? %) (some sequential? %)) seq coll))))", "user": "57a0f256e4b0c3d858beb8dd"}, {"problem": 93, "code": "(fn Rdce [array] \n    (if (every? sequential? array)\n    (mapcat Rdce array)\n    [array])\n  )", "user": "5a534241e4b05d388ecb6c0a"}, {"problem": 93, "code": "(fn f \n  ([coll] (f coll []))\n  ([coll acc] \n        (if (empty? coll) \n            acc            \n            (if (sequential? (first coll)) (f (rest coll) (f (first coll) acc)) (conj acc coll)))))", "user": "5a14228fe4b0ff51aa4b3193"}, {"problem": 93, "code": "(fn pflatten [xs]\n  (apply concat\n         (for [x xs]\n           (if (and (sequential? x)\n                    (every? (complement sequential?) x))\n             [x]\n             (pflatten x)))))", "user": "5866b999e4b0f14aab7c886b"}, {"problem": 93, "code": "(fn __ [in]\n  (let [flat? #(not-any? coll? %)]\n    (loop [out []\n           [x & xs] in]\n      (if x\n        (if (flat? x)\n          (recur (conj out x) xs)\n          (recur out (concat x xs)))\n        out))))", "user": "55916764e4b0604b3f94d57b"}, {"problem": 93, "code": "#(loop [acc [] [x & xs :as others] %] \n  (cond\n   (empty? others) acc\n   (and (coll? x) (some coll? x)) (recur acc (concat x xs))\n   :else (recur (conj acc x) xs)))", "user": "5773f3a9e4b0979f896515f2"}, {"problem": 93, "code": "(fn partil-flatten-seq\n  [root]\n  (filter #(and (sequential? %)\n                (every? (complement sequential?) %))\n          (tree-seq sequential? identity root)))", "user": "565654dae4b0f9d632dd849f"}, {"problem": 93, "code": "(fn [coll]\n  (let [is-ll (fn [c] (and (sequential? c) (not (some sequential? c))))]\n    (filter is-ll (tree-seq (complement is-ll) seq coll))))", "user": "5a566e8fe4b05d388ecb6c51"}, {"problem": 93, "code": "(fn pfs [[f & r :as s]]\n   (if (coll? f)\n      (concat (pfs f) (pfs r))\n      (if-not (empty? s) (list s))))", "user": "59f043d0e4b0966464fe6a3d"}, {"problem": 93, "code": "(fn [x]\n  (reduce\n   #(if (every? coll? %2) (concat %1 (map flatten %2)) (conj (apply vector %1) %2))\n   [] x)\n  )", "user": "5a621702e4b0512ff01cd983"}, {"problem": 93, "code": "(fn partial-flatten [s]\n  (loop [s s\n         cur []\n         res []]\n    (if (seq s)\n      (let [[hd & tl] s]\n        (if (coll? hd)\n          (recur tl cur (concat res (partial-flatten hd)))\n          (recur tl (conj cur hd) res)))\n      (if (empty? cur)\n        res\n        (conj res cur)))))", "user": "5a6b9b95e4b0512ff01cda40"}, {"problem": 93, "code": "(fn [coll]\n  (let [unravel (fn [coll x]\n                  (->> x\n                       (iterate\n                         (fn [y]\n                           (cond\n                             (every? coll? y) (first y)\n                             :else y)))\n                       (filter #(some (complement coll?) %))\n                       (take 1)\n                       (concat coll)))]\n    (reduce (fn [coll x]\n              (if (and (> (count x) 1)\n                      (every? coll? x))\n                (reduce unravel coll x)\n                (unravel coll x)))\n            (empty coll)\n            coll)))", "user": "51dafedee4b09f6bc204eee2"}, {"problem": 93, "code": "(fn [colls]\n    (let [part-flatten (fn pf [coll]\n                         (if-not (some coll? coll)\n                           coll\n                           (if (not= 1 (count coll))\n                             (map pf coll)\n                             (recur (first coll)))))]\n      (loop [rem-coll colls\n             output   []]\n        (if-not (seq rem-coll)\n          output\n          (let [this-out (part-flatten (first rem-coll))]\n            (if (coll? (first this-out))\n              (recur (rest rem-coll) (concat output this-out))\n              (recur (rest rem-coll) (conj output this-out))))))))", "user": "53716539e4b0fc7073fd6eb1"}, {"problem": 93, "code": "(fn p [c]\n  (if (and (sequential? c)\n           (not (sequential? (first c))))\n    [c]\n    (mapcat p c)))", "user": "56441634e4b0018b46ad8c08"}, {"problem": 93, "code": "(fn flat[s]\n  (loop [tail s\n         r []]\n    (if (empty? tail)\n      r\n      (if (sequential? (first (first tail)))\n        (recur (rest tail) (concat r (flat (first tail))))\n        (recur (rest tail) (concat r [(first tail)]))))))", "user": "4fd4bddce4b0d4de60cee36e"}, {"problem": 93, "code": "(fn getLeaves [xs]\n  (println \"getleaves\" xs)\n  (cond\n    (not (sequential? xs)) [xs]\n    (not (sequential? (first xs))) [xs]\n    :else (apply concat (for [x xs] (getLeaves x)))\n    )\n  )", "user": "562add6de4b00e49c7cb4834"}, {"problem": 93, "code": "(fn [coll]\n   (reduce (fn partial-flatten [v e]\n             (if (coll? (first e))\n               (reduce partial-flatten v e)\n               (conj v e))) [] coll))", "user": "5a4b3abde4b05d388ecb6b81"}, {"problem": 93, "code": "(fn [nested]\n    (filter #(= % (filter (fn [x] (not (coll? x))) %))\n            (filter coll?\n                    (tree-seq coll? seq nested))))", "user": "594266cfe4b060784b3b790b"}, {"problem": 93, "code": "(fn flat-seq [xs]\n\t \t(loop [ys xs acc []]\n\t \t\t(if (empty? ys)\n\t   \t\t\t  acc\n\t   \t\t\t(recur (rest ys) \n\t   \t\t\t  \t   (let [el (first ys)]\n\t\t   \t\t\t  \t   (if (coll? (first el) )\n\t\t\t\t\t\t\t\t(into acc (flat-seq el))\n\t\t\t\t\t\t \t\t(conj acc el)\n\t\t\t\t\t\t\t)\n\t   \t\t\t  \t   \t)\n\t   \t\t\t)\n\t \t\t)\n\t\t\t)\n\t)", "user": "55d7312ee4b0e31453f64a9f"}, {"problem": 93, "code": "(fn[x]\n        (filter #(and (sequential? %) \n                      (not (sequential? (first %))))\n                (tree-seq sequential? seq x)))", "user": "57e6f90de4b0bfb2137f5af6"}, {"problem": 93, "code": "(fn [coll]\n  (remove #(some sequential? %)\n          (tree-seq #(some sequential? %) identity coll)))", "user": "598858d0e4b021a7a535feb5"}, {"problem": 93, "code": "(fn p [t]\n  (if (every? sequential? t)\n    (mapcat p t)\n    [t]))", "user": "5a95c639e4b0d174b936c75e"}, {"problem": 93, "code": "#(filter (fn [v] (cond ((complement sequential?) v) false\n                      (some sequential? v) false\n                      :else true)) (rest (tree-seq sequential? seq %)))", "user": "5a9dbb32e4b0d174b936c7f3"}, {"problem": 93, "code": "(fn flatten-sequences [input]\n  (letfn [(flatten-sequence [coll]\n                            (loop [s coll]\n                              (if (coll? (first s))\n                                (recur (apply identity s))\n                                s)))]\n    (let [head (first input)\n          tail (rest input)]\n      (if (not(empty? input))\n        (if (coll? head)\n          (if (not (empty? head))\n            (if (= 1 (count tail))\n              (concat [(flatten-sequence head)] (apply flatten-sequences tail))\n              (concat [(flatten-sequence head)] (flatten-sequences tail)))\n            input)\n          [input])))))", "user": "57b9fb56e4b0fbc9809a27fa"}, {"problem": 93, "code": "(fn unpack\n  ([seq]\n   (unpack seq []))\n  ([seq res]\n   (let [elem  (first seq)\n         other (rest seq)]\n     (if (not (sequential? elem))\n       (conj res seq)\n       (let [res (unpack elem res)]\n         (if (empty? other)\n           res\n           (unpack other res)))))))", "user": "58fc92c5e4b0438e51c2cf9a"}, {"problem": 93, "code": "(fn __ [coll]\n  (if (sequential? (first coll))\n    (mapcat __ coll)\n    [coll]))", "user": "4eda7cc3535d10e5ff6f530e"}, {"problem": 93, "code": "(fn [coll]\n  (let [leaf? (comp sequential? first)]\n    (->> coll\n         (tree-seq leaf? seq)\n         (filterv (every-pred sequential? (comp not leaf?))))))", "user": "50310713e4b05b7df5a0b84c"}, {"problem": 93, "code": "(fn [coll]\n  (filter\n    (complement #(every? sequential? %)) \n    (tree-seq #(every? sequential? %) seq coll)))", "user": "5aa998c6e4b0d174b936c8e5"}, {"problem": 93, "code": "(fn flat [xs]\n  (let [not-sequential? (complement sequential?)]\n    (mapcat #(if (or (not-sequential? %)\n                     (every? not-sequential? %))\n               [%]\n               (lazy-seq (flat %)))\n            xs)))", "user": "5ab16992e4b073f1774425c4"}, {"problem": 93, "code": "(fn pf\n  [coll]\n  (let [res (atom [])]\n    (clojure.walk/prewalk #(do (when (and (coll? %) (not-every? coll? %)) (swap! res conj %)) %) coll)\n    @res))", "user": "59f44189e4b0966464fe6aab"}, {"problem": 93, "code": "(fn partially-flatten [xs]\n  (if (every? sequential? xs)\n    (mapcat partially-flatten xs)\n    [xs]))", "user": "5a6af090e4b0512ff01cda2d"}, {"problem": 93, "code": "(fn flat [x]\n  (if (and (coll? x) (some coll? x))\n    (mapcat flat x)\n    [x]))", "user": "5ad63a34e4b0ea6055cfac01"}, {"problem": 93, "code": "(letfn [(last-level? [coll]\n            (every? (complement sequential?) coll))]\n    (fn [coll]\n      (if (every? last-level? coll)\n        coll\n        (recur\n          (mapcat (fn [coll]\n                    (if (last-level? coll)\n                      [coll]\n                      coll)) coll)))))", "user": "569f4dabe4b0542e1f8d1491"}, {"problem": 93, "code": "(fn [s] (if (every? (fn [es] (every? #(not (sequential? %)) es)) s) s (recur (mapcat (fn [es] (let [ne (filter #(not (sequential? %)) es) nl (apply concat (filter sequential? es))] (if (empty? ne) (list nl) (conj nl ne)))) s))))", "user": "5abe2fc2e4b073f17744271e"}, {"problem": 93, "code": "(fn [coll]\n    (letfn [(partially-flatten [coll]\n              (if (empty? coll)\n                nil\n                (if (coll? (-> coll first first))\n                  (concat (partially-flatten (first coll)) (partially-flatten (rest coll)))\n                  (cons (first coll) (partially-flatten (rest coll))))))]\n      (partially-flatten coll)))", "user": "5ac6ef9be4b0e27600da7779"}, {"problem": 93, "code": "(fn pfas\n  [x]\n  (let [y (mapcat #(if (not-any? coll? %) [%] %) x)]\n    (if (= x y) x (pfas y))))", "user": "57ea2c91e4b0bfb2137f5b42"}, {"problem": 93, "code": "(fn [x]\n  (let [s sequential?]\n  \t(filter #(not-any? s %) \n            (tree-seq s #(filter s %) x))))", "user": "577202d2e4b0979f896515c0"}, {"problem": 93, "code": "(fn [s] (filter\n         #(and (coll? %) (not (some coll? %)))\n         (tree-seq coll? seq s)))", "user": "5aeca4c9e4b0cc2b61a3bc0a"}, {"problem": 93, "code": "(fn fp [[x & xs]]\n  (if x\n    (if (some coll? x)\n      (concat (fp x) (fp xs))\n      (cons x (fp xs)))))", "user": "5974d2ede4b01722bebd4cb6"}, {"problem": 93, "code": "(fn iter [xs] \n\t(reduce (fn [acc x]\n\t\t(if (coll? (first x))\n\t\t\t(concat acc (iter x))\n\t\t\t(concat acc (cons x ()))))\n\t        ()\n\t        xs))", "user": "5af907e6e4b0cc2b61a3bcda"}, {"problem": 93, "code": "(fn pflat [s]\n (mapcat #(if (sequential? (first %))\n            (pflat %)\n            (list %)) s))", "user": "5835cb06e4b089d5ab817cea"}, {"problem": 93, "code": "(fn __ [seq]\n  (if (= (flatten seq) seq)\n    seq\n    (let [seq (map __ seq)]\n      (reduce #(concat %1 (if (= (flatten %2) %2) (vector %2) %2)) [] seq))))", "user": "5ac91d90e4b0e27600da77bd"}, {"problem": 93, "code": "#(if (vector? %)\n  (vec (map (comp vec flatten) %))\n  (->> (tree-seq (comp seq? first) seq %)\n    (filter (comp not seq? first))) )", "user": "5b0180cfe4b0cc2b61a3bd47"}, {"problem": 93, "code": "(fn partial-flatten [c]\n  (if-let [c (seq c)]\n    (if (sequential? (ffirst c))\n      (recur (concat (first c) (next c)))\n      (cons (first c) (lazy-seq (partial-flatten (next c)))))))", "user": "5953bdb6e4b066ee0a44aeed"}, {"problem": 93, "code": "(fn f [xs x]\n   (if (some coll? x)\n     (reduce f xs x)\n     (conj xs x)))\n[]", "user": "58db3c5ae4b0a4d5acaab677"}, {"problem": 93, "code": "(fn flatten-1 [[x & xs]]\n  (when x\n    (if (sequential? (first x))\n      (concat (flatten-1 x)\n              (flatten-1 xs))\n      (cons x (flatten-1 xs)))))", "user": "5af8221ce4b0cc2b61a3bccd"}, {"problem": 93, "code": "(fn f [s] (if (every? sequential? s) (mapcat f s) [s]))", "user": "57ee82b1e4b0bfb2137f5bbd"}, {"problem": 93, "code": "(fn part-flat [s]\n  (letfn [(has-seq [x] (some sequential? x))]\n    (filter (complement has-seq) (tree-seq has-seq seq s))))", "user": "5b13ba71e4b0cc2b61a3be53"}, {"problem": 93, "code": "(fn flatten-to-one-level-deep [x]\n  (letfn [(is-one-level-deep-only?\n            ([] true)\n            ([u] (if (coll? u)\n            (not (reduce #(or %1 %2) false (map coll? u)))\n            false)))]\n  (filter #(not (empty? %))\n    (if (not (is-one-level-deep-only? x))\n      (if (not (empty? x))\n        (concat\n          (flatten-to-one-level-deep (first x))\n          (flatten-to-one-level-deep (rest x)))\n        [])\n      [x]))))", "user": "5b15811ee4b0cc2b61a3be6f"}, {"problem": 93, "code": "(comp (partial filter #(and (sequential? %) (not (sequential? (first %))))) rest (partial tree-seq sequential? seq))", "user": "5b34aba7e4b025bcb146f352"}, {"problem": 93, "code": "(fn flatish[xs]\n  (loop[ result []\n         [next & the-rest] xs]\n    (cond\n      (nil? next) result\n      (coll? (first next)) (recur result (cons (concat (first next)) (concat (rest next) the-rest)))\n      :else (recur (conj result next) the-rest))))", "user": "5980f91ae4b021a7a535fddd"}, {"problem": 93, "code": "(fn pf [s] (vec (mapcat (fn [sub] (if (or (not (coll? sub)) (every? #(not (coll? %)) sub)) [sub] (pf sub))) s)))", "user": "5b3f2ba9e4b02d533a91bc09"}, {"problem": 93, "code": "(fn fl [s] (if (sequential? s)\n             (if (some sequential? s)\n              (reduce concat (map fl s))\n  \t\t\t  (list s))\n             (list s)))", "user": "5b4b4052e4b02d533a91bc9a"}, {"problem": 93, "code": "(fn f\n  [s]\n  (let [c #(and (coll? %) (not (coll? (first %))))]\n    (cond (= s []) []\n          (c (first s)) (concat [(first s)] (f (rest s)))\n          :else (f (concat (first s) (rest s))))))", "user": "583048d9e4b051871117c007"}, {"problem": 93, "code": "(fn __ [s]\n   (reduce\n   (fn [res [a & b :as c]]\n         (cond\n          (and (coll? a) (empty? b)) (recur res a)\n          (coll? a) (into res (__ c))\n          :else (conj res c)))\n       [] s))", "user": "5a0ce1a5e4b04bbd27e6d9b7"}, {"problem": 93, "code": "mapcat\n (fn [xs]\n   (if (and (sequential? xs) (some sequential? xs))\n     (map flatten xs)\n     (list xs)))", "user": "5b51b9f8e4b02d533a91bcfe"}, {"problem": 93, "code": "(fn pfs\n  [s]\n  (mapcat (fn [c] (if (every? #((complement coll?) %) c) [c] (pfs c))) s))", "user": "5b008bcae4b0cc2b61a3bd3d"}, {"problem": 93, "code": "(fn flat [x] (mapcat (fn [e] (if (some sequential? e) (flat e) [e])) x))", "user": "5b465b8be4b02d533a91bc65"}, {"problem": 93, "code": "(fn f [x]\n (if (every? sequential? x)\n  (mapcat f x)\n  [x]))", "user": "5b61aa6ae4b0c6492753e712"}, {"problem": 93, "code": "(fn f [coll]\n  (reduce (fn [a e] (if (and (coll? e) (coll? (first e)))\n                      (concat a (f e))\n                      (concat a (list e))))\n          '()\n  \t\t  coll))", "user": "54f26266e4b024c67c0cf8c5"}, {"problem": 93, "code": "(fn flat [coll]\n  (letfn [(r [[x & xs]]\n            (if (coll? x)\n              (if (coll? (first x))\n                (if (seq (rest x))\n                  (cons (flat (first x)) (cons (flat (rest x)) (flat xs)))\n                  (cons (flat (first x)) (flat xs)))\n                (conj (flat xs) (flat x)))\n              (if (nil? x)\n                nil\n                (conj (flat xs) x))))]\n    (let [o (r coll)]\n      (if (= o coll)\n        o\n        (recur o)))))", "user": "53aaaf7ae4b047364c044444"}, {"problem": 93, "code": "(fn [v]\n   (letfn [(flat-seq? [v] (not-any? sequential? v))\n           (flat-seq-1? [v] (every? flat-seq? v))\n           (flat [s]\n             (if (flat-seq-1? s)\n               s\n               (reduce (fn [acc v] (concat acc (if (flat-seq? v) [v] (flat v)))) '() s)))\n           #_(flat [s]\n             (cond->> s\n               (not (flat-seq-1? s)) (#(apply concat (for [v %]\n                                                      (if (flat-seq? v)\n                                                        [v]\n                                                        (flat v)))))))\n           #_(flat [s]\n             (if (flat-seq-1? s)\n               s\n               (apply concat (for [v s]\n                               (if (flat-seq? v) [v] (flat v))))))]\n     (flat v)))", "user": "515ffbfbe4b0e2be8aa20bdd"}, {"problem": 93, "code": "(fn [xs]\n  (filter #(and (sequential? %) (not-any? sequential? %)) (tree-seq sequential? seq xs)))", "user": "5b64370ae4b0c6492753e73c"}, {"problem": 93, "code": "(fn pflatten [tree]\n  (if (every? sequential? tree)\n    (mapcat pflatten tree)\n    [tree]))", "user": "5b88f0c0e4b047b03b203816"}, {"problem": 93, "code": "(fn [coll]\n  (filter\n    (fn [xs] (and (sequential? xs) (not-every? sequential? xs)))\n    (rest (tree-seq sequential? seq coll))))", "user": "59c94a69e4b0a024fb6ae576"}, {"problem": 93, "code": "(fn my-flatten [c]\n  (if (and (sequential? c) (sequential? (first c)) (sequential? (ffirst c)))\n    (if (> (count c) 1) (reduce concat (map my-flatten c)) (apply my-flatten c))\n    (if (seq c) (if (sequential? (first c)) (cons (first c) (my-flatten (next c))) (list c)) c)))", "user": "5a085dfde4b01bb0ae8afdf4"}, {"problem": 93, "code": "(fn partially-flatten [xs]\n    (if (every? sequential? xs)\n      (mapcat partially-flatten xs)\n      [xs]))", "user": "539fa040e4b0ca733b97449f"}, {"problem": 93, "code": "(fn part-flat [items]\n     (for [i items\n           j (if (some sequential? i)\n               (part-flat i)\n               [i])]\n       j))", "user": "5b999af8e4b0c0b3ffbd4ad3"}, {"problem": 93, "code": "(fn almost-flatten [[c & colls]]\n  (when c\n    (concat\n     (if (-> c first coll? not)\n       [c]\n       (almost-flatten c))\n     (almost-flatten colls))))", "user": "5a257747e4b07f18be40aa1f"}, {"problem": 93, "code": "(fn pf [coll]\n  (if (every? coll? coll)\n    (mapcat pf coll)\n    [coll]))", "user": "5a91988ae4b002d099cae6f9"}, {"problem": 93, "code": "(fn my-flatten [col]  \n  (if (not (coll? (first col)))\n    [col]\n    (mapcat my-flatten col)))", "user": "5bafd5c8e4b0a20761a234dd"}, {"problem": 93, "code": "(fn partial-flatten[s]\n  (if (every? sequential? s)\n    (mapcat partial-flatten s)\n    [s]))", "user": "52761edae4b03e8d9a4a74d4"}, {"problem": 93, "code": "(fn [input] (filter (fn [x] (and (sequential? x) (some (complement sequential?) x))) (rest (tree-seq sequential? seq input))))", "user": "5addadfce4b0837691e92c13"}, {"problem": 93, "code": "(fn problem-93\n  [[x & _ :as xs]]\n  (if-not (sequential? x)\n    [xs]\n\n    (mapcat problem-93 xs)))", "user": "58e37946e4b005f69f193cae"}, {"problem": 93, "code": "(fn [x]\n  (let [p (fn  [t]\n            (if (sequential? t)\n              (if (sequential? (first t))\n                nil\n                t)\n              nil))]\n    (filter (complement nil?) (map p (tree-seq sequential? seq x)))))", "user": "566d71b1e4b0a866af6896ca"}, {"problem": 93, "code": "(fn pflatten [tree]\n  (if (every? sequential? tree)\n    (mapcat pflatten tree)\n    [tree]))", "user": "5bbdd136e4b07a9b28b0ffab"}, {"problem": 93, "code": "(fn partially-flatten\n  [v]\n  (reduce (fn [current x]\n            (cond\n              (= (flatten x) x)\n              (conj current x)\n\n              (not (coll? x))\n              (conj current x)\n              \n              :else\n              (vec (concat current (partially-flatten x))))) [] v))", "user": "5b759ca8e4b047b03b2036d0"}, {"problem": 93, "code": "(fn pf [xs]\n  (loop [xs xs\n         acc '()]\n    (cond\n      (sequential? (first (first xs))) (recur (concat (first xs) (rest xs)) acc)\n      (empty? xs) (reverse acc)\n      :else (recur (rest xs) (cons (first xs) acc)))))", "user": "5afb4b15e4b0cc2b61a3bcf6"}, {"problem": 93, "code": "(fn flatten-but [coll]\n    (let [flat-coll? (fn [coll]\n                       (not-any? coll?\n                                 coll))]\n      (if-not (coll? coll)\n        coll\n        (if (flat-coll? coll)\n          [coll]\n          (apply concat\n                 (map flatten-but\n                      coll))))))", "user": "5be5cebde4b0ed4b8aab4d19"}, {"problem": 93, "code": "(fn pf [[l1 & _ :as l]] (if (sequential? l1) (mapcat pf l) [l]))", "user": "5b919d9de4b0c0b3ffbd4a24"}, {"problem": 93, "code": "(fn [x]\n(letfn [(flt? [x] (or (seq? x) (vector? x)))        \n(flt [x y] (if\n(empty? y) x\n(let [z (first y)]\n(if (and (flt? z) (reduce #(and %1 (flt? %2)) true z)) (recur x (concat z (rest y))) (recur (conj x z) (rest y))))))]\n(flt [] x)))", "user": "5be6d0f8e4b0f319e2d7ec51"}, {"problem": 93, "code": "(fn [xs]\n  (let [some? (complement nil?)]\n    (->> xs\n         (tree-seq sequential? seq)\n         (rest)\n         (map #(when-not (sequential? %) %))\n         (partition-by some?)\n         (filter (comp some? first)))))", "user": "5b96800ae4b0c0b3ffbd4a7b"}, {"problem": 93, "code": "(fn [root]\n  (->>\n    (tree-seq (partial some sequential?) identity root)\n    (filter (partial not-any? sequential?))))", "user": "5ba15075e4b0a20761a2339e"}, {"problem": 93, "code": "(fn pflatten [tree]\n  (if (every? sequential? tree)\n    (mapcat pflatten tree)\n    [tree]))", "user": "5a42dbabe4b0447ef91cc5fc"}, {"problem": 93, "code": "(fn f [xs] (\n  if (every? sequential? xs)\n  (mapcat f xs)\n  [xs]))", "user": "5b0bd9cfe4b0cc2b61a3bdd9"}, {"problem": 93, "code": "(fn flatten-\n  [xs]\n  (if (every? sequential? xs)\n    (mapcat flatten- xs)\n    (list xs)))", "user": "5c222b7de4b07e362c230588"}, {"problem": 93, "code": "(fn pflatten [tree]\n  (if (every? sequential? tree)\n    (mapcat pflatten tree)\n    [tree]))", "user": "5c2649c8e4b07e362c2305bf"}, {"problem": 93, "code": "(fn partial-flatten\n  [s]\n  (reduce  #(if (sequential? (first %2)) (apply merge %1 (partial-flatten %2)) (conj %1 %2)) [] s)\n  )", "user": "5c20b6abe4b07e362c230576"}, {"problem": 93, "code": "(fn [coll]\n\t(filter #(not (sequential? (first %))) (tree-seq #(sequential? (first %)) identity coll)))", "user": "57c647bbe4b05aa3c4741cf3"}, {"problem": 93, "code": "(fn flat [xs]  (if (sequential? (first xs)) (mapcat flat xs) (list xs)))", "user": "5b924123e4b0c0b3ffbd4a34"}, {"problem": 93, "code": "(fn flatn [[f & r]]\n  (when f\n    (if (coll? f)\n      (if (coll? (first f))\n        (flatn (concat f r))\n        (cons f (flatn r)))\n      (cons f (flatn r)))))", "user": "54684c3be4b00cfc9eacc139"}, {"problem": 93, "code": "(fn [c]\n  (let [f sequential?]\n    (filter #(and (f %)\n                  (not (f (nth % 0))))\n          (tree-seq f #(or %) c))))", "user": "5c1aadcde4b01240ff567209"}, {"problem": 93, "code": "(fn partially-flatten [xs]\n  (mapcat\n    (fn [x] (if (and (coll? x) (some coll? x)) (partially-flatten x)\n                                                     [x]))\n    xs))", "user": "5c3ac091e4b0d62ef62d9f95"}, {"problem": 93, "code": "(fn flat [c] (if (and (sequential? c) (some sequential? c)) (mapcat flat c) (list c)))", "user": "594d4c57e4b07ddc2dafae87"}, {"problem": 93, "code": "(fn flar [v] (if (coll? (first v)) (mapcat flar v)  [v]))", "user": "5c379636e4b0d62ef62d9f76"}, {"problem": 93, "code": "(fn foo [coll]\n  (filter\n  (fn [n]\n    (and\n      (or (seq? n) (vector? n))\n      (not-any?\n        #(or\n          (seq? %)\n          (vector? %))\n        n)))\n  (tree-seq \n    #(or (vector? %) (seq? %)) \n    identity \n    coll)))", "user": "5b3251c1e4b025bcb146f317"}, {"problem": 93, "code": "(fn flatten-seq [coll]\n  (mapcat (fn unwrap [el] \n            (if-not (every? sequential? el)\n               [el]\n               (mapcat unwrap el))) \n          coll))", "user": "5c506951e4b0f9f7a8770ec5"}, {"problem": 93, "code": "(fn pfs [coll]\n  (if (not-any? coll? coll)\n    [coll]\n    (mapcat pfs coll)))", "user": "5c165d3ee4b01240ff5671d1"}, {"problem": 93, "code": "(fn [c] (if (some true? (map (fn [y] (some #(coll? %) y)) c)) \n          (recur (reduce #(if (coll? (first %2)) (concat % %2) (concat % [%2])) [] c)) c))", "user": "5c41db45e4b08cd430848ece"}, {"problem": 93, "code": "(fn parflat [xs]\n  (if (every? sequential? xs) (mapcat parflat xs) [xs]))", "user": "5a080bdde4b01bb0ae8afde9"}, {"problem": 93, "code": "(fn [y]\n  (loop [o [] oo [] f (first y) r (rest y)]\n      (if (nil? f) (conj o oo)\n        (if (coll? f)\n            (recur (if (empty? oo) o (conj o oo)) [] (first f) (into (vec (rest f)) r))\n            (recur o (conj oo f) (first r) (rest r))\n            ))))", "user": "5a244240e4b0ff51aa4b32e9"}, {"problem": 93, "code": "(fn partially-flatten [xs]\n  (if (every? sequential? xs)\n    (mapcat partially-flatten xs)\n    [xs]))", "user": "561d8936e4b064ca9f4b16b2"}, {"problem": 93, "code": "(fn [coll]\n    (->>\n     coll\n     (tree-seq #(and (sequential? %) (some sequential? %)) seq )\n     (filter #(and (sequential? %) (every? (complement sequential?) %)))))", "user": "57f80350e4b0d3187e90090c"}, {"problem": 93, "code": "(fn partial-flatten [xs]\n (if (every? (complement coll?) xs)\n  [xs]\n  (mapcat partial-flatten xs)))\n\n#_\n(fn partial-flatten [xs]\n (let [t (tree-seq coll? identity xs)]\n   (filter #(and \n             (coll? %) \n             (every? (complement coll?) %))\n           t)))", "user": "5bea3177e4b0f319e2d7ec81"}, {"problem": 93, "code": "#(filter (partial not-any? coll?)\n  (tree-seq (partial some coll?) identity %))", "user": "5c950334e4b048ec896c5a44"}, {"problem": 93, "code": "(fn [x] (filter #(not-every? true? (map coll? %))\n        (tree-seq #(coll? (nth % 0 [])) identity x)))", "user": "5c683fb5e4b0fca0c16226d5"}, {"problem": 93, "code": ";; http://www.4clojure.com/problem/93\n(fn leaf-flatten\n  [coll]\n  (filter #(and (sequential? %) (not (sequential? (first %))))\n          (tree-seq sequential? seq coll)))", "user": "5c92105ce4b048ec896c59f7"}, {"problem": 93, "code": "(fn ff [xs]\n    (when-not (empty? xs)\n      (let [[[s2 :as s1]] xs]\n        (if (and (sequential? xs)\n                 (sequential? s1)\n                 (sequential? s2))\n          (concat (ff s1) (ff (rest xs)))\n          (cons (first xs) (ff (rest xs)))))))", "user": "5c995fa4e4b048ec896c5a96"}, {"problem": 93, "code": "(fn partially-flatten [xs]\n  (mapcat #(if (coll? (first %))\n             (partially-flatten %)\n             (list %))\n          xs))", "user": "5ca14eb1e4b048ec896c5b7d"}, {"problem": 93, "code": "(fn [xs]\r\n  (filter\r\n    #(and (coll? %) (every? (complement coll?) %))\r\n    (tree-seq coll? identity xs)))", "user": "5ccb0bbee4b0ccb06196287c"}, {"problem": 93, "code": "(fn [x] (filter #(and (sequential? %) (not-any? sequential? %))\n          (tree-seq sequential? seq x)))", "user": "586bc870e4b01531a375e964"}, {"problem": 93, "code": "(fn pflatten [tree]\n  (if (every? sequential? tree)\n    (mapcat pflatten tree)\n    [tree]))", "user": "5baaae06e4b0a20761a23464"}, {"problem": 93, "code": "(fn pflat [ls]\n  (cond\n    (empty? ls) ls\n    (not (sequential? (first (first ls)))) (cons (first ls) (pflat (rest ls)))\n    true (concat (pflat (first ls)) (pflat (rest ls)))))", "user": "5d1bbef0e4b02ea6f0fb6984"}, {"problem": 93, "code": "(fn fl [lst]\n  (filter #(and (sequential? %) (not (sequential? (first %)))) (tree-seq sequential? seq lst))\n  )", "user": "5cebafbbe4b0a17bb84e2be6"}, {"problem": 93, "code": "(fn xxx [coll]\n     (cond\n       (empty? coll) coll\n       (not (coll? (first coll))) (list coll)\n       (coll? (ffirst coll)) (concat (xxx (ffirst coll)) (xxx (rest (first coll))) (xxx (rest coll)))\n       :else (concat (list (first coll)) (xxx (rest coll)))))", "user": "5d02fe44e4b0cc9c915881c0"}, {"problem": 93, "code": "(fn k[xs]\n   (reduce #(if (sequential? (first %2))\n              (into %1 (k %2))\n              (conj %1 %2)) [] xs))", "user": "5d0cf1c8e4b0cc9c91588246"}, {"problem": 93, "code": "(fn flatten1 [items]\n  (reduce #(concat %1 (if (coll? (first %2))\n                        (flatten1 %2)\n                        (conj (empty items) %2)))\n          (empty items)\n          items))", "user": "518279abe4b0353c468deb65"}, {"problem": 93, "code": "(fn partial-flatten\n  [[c & oll]]\n  (if c\n    (if (some coll? c)\n      (partial-flatten (concat c oll))\n      (conj (partial-flatten oll) c))\n    '()))", "user": "5c2836ebe4b07e362c2305d4"}, {"problem": 93, "code": "(fn ninety-three\n  [[f & more]]\n  (if-not (seq f)\n    f\n    (if (every? (complement coll?) f)\n      (cons f (ninety-three more))\n      (concat(ninety-three f) (ninety-three more)))))", "user": "5338387de4b0e30313ee6c91"}, {"problem": 93, "code": "(fn partial-flatten [coll]\n  (let [left (first coll)\n        right (next coll)\n        left-flatten (fn [left]\n                       (if (and (sequential? left)\n                                (not (sequential? (first left))))\n                         [left]\n                         (partial-flatten left)))\n        right-flatten (fn [right] (when (sequential? right)\n                                    (partial-flatten right)))]\n    (concat (left-flatten left) (right-flatten right))))", "user": "5d0153f9e4b0cc9c915881aa"}, {"problem": 93, "code": "(fn flatulate [s]\n  (when (seq s)\n    (let [[f & r] s]\n      (if (and\n            (coll? f)\n            (some coll? f))\n        (lazy-cat (flatulate f) (flatulate r))\n        (cons f (flatulate r))))))", "user": "590b055ae4b047aa04b199c9"}, {"problem": 93, "code": "(fn f [s]\n  (reduce (fn [accum x]\n            (if (every? #(not (sequential? %)) x)\n              (conj accum x)\n              (apply conj accum (f x))))\n          []\n          s))", "user": "5012da69e4b0c8732600222d"}, {"problem": 93, "code": "(fn partially-flatten [c]\n  (letfn [(flat [c]\n            (reduce (fn [col child]\n                      (if-not (coll? (first child))\n                        (conj col child)\n                        (vec (concat col (flat child)))))\n                    [] c))]\n    (flat c)))", "user": "5d6042f2e4b0c9e5857d5006"}, {"problem": 93, "code": "(fn f\n  [coll]\n  (if (every? (complement sequential?) coll)\n    [coll]\n    (mapcat f coll)))", "user": "5d0bb4fae4b0cc9c91588237"}, {"problem": 93, "code": "(fn iter [xs]\n    (reduce (fn [a e] (if (some coll? e)\n                       (concat a (iter e))\n                       (concat a [e]))) [] xs))", "user": "5d29c06be4b01671435dbc6b"}, {"problem": 93, "code": "(fn ThisFunc [L]\n    ;;(println \"*********\" L)\n    (loop [Ret '() First (first L) Rest (rest L)]\n      ;; \u0435\u0441\u043b\u0438 \u043d\u0438\u0447\u0435\u0433\u043e \u043d\u0435\u0442, \u0442\u043e \u0441\u0442\u043e\u043f\n      (if (nil? First)\n        Ret\n        (let [FF (first First)]\n          (recur\n            (concat\n              Ret\n              (if (sequential? FF)\n               (ThisFunc First) \n               [First]\n              )\n            )\n            (first Rest)\n            (rest Rest)\n          )\n        )\n      )\n    )\n  )", "user": "5d4a6c6ce4b0776584bd6f22"}, {"problem": 93, "code": "(fn pflatten [tree]\n  (if (every? sequential? tree)\n    (mapcat pflatten tree)\n    [tree]))", "user": "5d67c955e4b0db5d338d15f7"}, {"problem": 93, "code": "(fn [item] (cond\n                                           (and (= 2 (count item)) (= String (type (ffirst item))))\n                                           [[\"Do\"] [\"Nothing\"]]\n                                           (= 3 (count item))\n                                           [[:a :b] [:c :d] [:e :f]]\n                                           :else\n                                           '((1 2)(3 4)(5 6))))", "user": "5cf72682e4b0b71b1d808a68"}, {"problem": 93, "code": "(fn f [x]\n   (if\n     (not (coll? (first x))) [x]\n     (mapcat f x)))", "user": "567c63f6e4b05957ce8c61bb"}, {"problem": 93, "code": "(fn f [x]\n  (if (not (coll? (first x))) [x]\n    (mapcat f x)))", "user": "4e6a23d0535d8ccf87e9fea0"}, {"problem": 93, "code": "(fn almost-flatten\n  [s]\n  (if (every? sequential? s)\n    (mapcat almost-flatten s)\n    [s]))", "user": "5d52bf29e4b0776584bd6f69"}, {"problem": 93, "code": "(fn partial-flatten [xs]\n  (filter #(= (flatten %) %)\n          (tree-seq sequential? seq xs)))", "user": "562cb7cfe4b0a45d2ff83009"}, {"problem": 93, "code": "(fn f [c]\n  (if (every? sequential? c)\n    (mapcat f c)\n    [c]))", "user": "5d1b2b7de4b02ea6f0fb697a"}, {"problem": 93, "code": "(fn flat [xs]\n   (mapcat #(if (coll? (first %)) \n              (flat %) \n              (list %)) xs))", "user": "5d764e52e4b02e6b30c93524"}, {"problem": 93, "code": "(fn [xs]\n   (let [flatten-1 (fn [xs]\n                     (reduce (fn [acc x]\n                                (cond\n                                  (not (sequential? x)) (into acc x)\n                                  (every? #(not (sequential? %)) x) (conj acc x)\n                                  :else (into acc x)))\n                             [] xs))]\n     (first (drop 100 (iterate flatten-1 xs)))))", "user": "5d4b2155e4b0776584bd6f28"}, {"problem": 93, "code": "(fn [coll]\n   (filter #(and (coll? %) (not-any? coll? %))\n           (tree-seq coll? identity coll)))", "user": "5d9c1226e4b0d3f9b434ad51"}, {"problem": 93, "code": "(fn f [xs]\n   (reduce (fn [r x]\n             (if (and (coll? x)\n                      (some coll? x))\n               (into r (f x))\n               (conj r x)))\n           []\n           xs))", "user": "557c6ca6e4b05c286339e0c4"}, {"problem": 93, "code": "(fn f [xs]\n  (if (every? coll? xs)\n    (mapcat f xs)\n    [xs]))", "user": "5d81b40ce4b0915913b1d379"}, {"problem": 93, "code": "(fn [c]\n  (letfn [(a [f] \n            (if (and (sequential? f) (not (sequential? (first f)))) true false))]\n       (loop [ [f & c1] c re []]\n          (cond\n              (not f) re\n              (a f) (recur c1 (conj re f))\n              :else (recur (concat f c1) re)))))", "user": "5dc12b0ae4b0e59a23173d84"}, {"problem": 93, "code": "(fn partial_flatten [x]\n    (let\n        [\n            coll_of_only_colls?\n                (fn [x] (every? coll? x))\n        ]\n        (filter (complement coll_of_only_colls?) (tree-seq coll_of_only_colls? identity x))\n    )\n)", "user": "5db7376fe4b010eb3c36cd43"}, {"problem": 93, "code": "clojure.walk/postwalk\n   #(if (coll? %)\n         (if (coll? (first %))\n           (mapcat comp %)\n           [%])\n         %)", "user": "51a10b2ce4b0b292b01ee3fe"}, {"problem": 93, "code": "(fn f [t] (mapcat #(if (not-any? coll? %) [%] (f %)) t))", "user": "5db92996e4b010eb3c36cd50"}, {"problem": 93, "code": "(fn partial-flatten\n  [[head & rest]]\n  (when head\n    (let [head (cond\n                 (= (count (flatten head)) (count head)) [head]\n                 :else (partial-flatten head))]\n      (concat head (partial-flatten rest)))))", "user": "51c8f1d8e4b07ef393169e5d"}, {"problem": 93, "code": "(fn partially-flatten [coll]\n  (if (or (not (coll? coll)) (empty? coll) (not (coll? (first coll))))\n    (conj [] coll)\n    (reduce concat [] (map partially-flatten coll)))\n  )", "user": "5dd67c22e4b0948ae9d9ad80"}, {"problem": 93, "code": "(fn pflatten [tree]\n   (if (every? sequential? tree)\n     (mapcat pflatten tree)\n     [tree]))", "user": "5dd90651e4b0948ae9d9ad97"}, {"problem": 93, "code": "(fn fun [col & [x]]\n  (reduce\n    #(if (every? coll? %2)\n        (fun %2 %)\n        (conj % %2)\n    )\n    (if (nil? x) [] x)    \n    col\n  )    \n)", "user": "5da20e73e4b000c986472be1"}, {"problem": 93, "code": "(fn [c] (filter (fn [x] (and (coll? x) (not (coll? (first x)))))\n                (rest (tree-seq sequential? seq c))))", "user": "529dfc6de4b04e0c58e87b8a"}, {"problem": 93, "code": "(fn almost-flatten [s]\n  (cond\n   (empty? s) []\n   (coll? (first (first s))) (concat (almost-flatten (first s)) (almost-flatten (rest s)))\n   :else (cons (first s) (almost-flatten (rest s)))))", "user": "5dd60c58e4b0948ae9d9ad7c"}, {"problem": 93, "code": "(fn p-93 [s]\n  (if (every? (comp not sequential?) s) (list s)\n           (mapcat p-93 s)))", "user": "5bfc9037e4b0bdcf453d15f2"}, {"problem": 93, "code": "(fn pflatten [tree]\n  (if (every? sequential? tree)\n    (mapcat pflatten tree)\n    [tree]))", "user": "5e00b6e7e4b0a607a9a45d2b"}, {"problem": 93, "code": "(fn flatten1 [c]\n  (letfn [(is-element? [x] (every? (complement coll?) x))]\n    (cond\n      (empty? c) []\n      (is-element? c) [c]\n      :else (concat (flatten1 (first c)) (flatten1 (rest c))))))", "user": "5e0d948fe4b099d064962f98"}, {"problem": 93, "code": "(fn pf [coll]\n  (let [l (first coll) r (next coll)]\n    (concat \n      (if (and (sequential? l) (not (sequential? (first l))))\n        [l]\n        (pf l))\n      (when (sequential? r)\n        (pf r)))))", "user": "5d9c9446e4b0eb781811cdae"}, {"problem": 93, "code": "(fn [coll]\n    (letfn [(partial-flatten [coll]\n              (if-not (coll? (first coll)) [coll]\n                      (mapcat partial-flatten coll)))]\n      (mapcat partial-flatten coll)))", "user": "5d236215e4b02ea6f0fb6a09"}, {"problem": 93, "code": "#(letfn [(iter [nest] \n      (cond \n      (empty? nest) ()\n       (not (coll? (first nest))) (list nest)\n      :else (concat (iter (first nest)) (iter (rest nest)))\n     ))] (iter %))", "user": "5471f2fbe4b094393f72dd70"}, {"problem": 93, "code": "(fn my-flatten [col]\n           (reduce (fn [result x]\n                     (into result\n                           (if (sequential? x)\n                             (if (sequential? (first x))\n                               (my-flatten x)\n                               [x])\n                             [x])))\n                   [] col))", "user": "5e1c3e6ee4b0dc9594008530"}, {"problem": 93, "code": "(fn partial-flatten [nested-seq] (loop [suffix nested-seq partial-flat []] (if (empty? suffix) partial-flat (if (some coll? (first suffix)) (recur (concat (first suffix) (rest suffix)) partial-flat) (recur (rest suffix) (conj partial-flat (first suffix)))))))", "user": "5e1cc888e4b0dc959400853d"}, {"problem": 93, "code": "(fn solve\n  ([x] (reduce solve [] x))\n  ([bucket x]\n   (if (some sequential? x)\n     (reduce solve bucket x)\n     (conj bucket x))))", "user": "5b14475be4b0cc2b61a3be5a"}, {"problem": 93, "code": "(fn f [s]\n  (if (every? false? (map sequential? s))\n    [s]\n    (mapcat f s)))", "user": "5e2549c8e4b05b4b0151615f"}, {"problem": 93, "code": "#(letfn [(flat [[a & b]]\n        \t(do (println a b (empty? b))\n              (if (coll? a)\n               (if (empty? b)\n                 (if (coll? (first a)) \n                   (flat a)\n                   (vector a))\n                 (if (coll? (first a))\n                     (concat (flat a) (flat b))\n                     (cons a (flat b))))\n               (vector (cons a b)))))]\n  (mapcat flat %))", "user": "5e3a25d4e4b01d43a70e8dde"}, {"problem": 93, "code": "(fn f [s]\n   (if (every? coll? s)\n     (apply concat (map f s))\n     (list s)))", "user": "5e3ef7d4e4b01d43a70e8e2d"}, {"problem": 93, "code": "(partial reduce (fn r [pflat item]\n            (if (coll? (first item))\n              (reduce r pflat item)\n              (conj pflat item))) [])", "user": "5d929ceae4b0915913b1d412"}, {"problem": 93, "code": "(fn[col]\n  (reduce\n    (fn[a v]\n      (if (and (sequential? v) (not-any? sequential? v))\n        (conj a v)\n        a))\n    []\n    (tree-seq sequential? seq col)))", "user": "5e53f8e0e4b027a2e10ac0e7"}, {"problem": 93, "code": "(fn myFlatten-one-lvl [x]\n  (mapcat\n    (fn [i]\n      (if (and (coll? i) (not (coll? (nth i 0))))\n       (list i)\n       (myFlatten-one-lvl i)\n       ))\n    x))", "user": "5e348945e4b0650de70e2b1d"}, {"problem": 93, "code": "(fn my-fn [xs]\n\t(cond\n    (empty? xs) nil\n    (not (sequential? (first xs))) [xs]\n    :else (concat (my-fn (first xs)) (my-fn (rest xs)))))", "user": "5d669613e4b0db5d338d15ea"}, {"problem": 93, "code": "(fn my-fn [xs]\n\t(cond\n    \t(empty? xs) nil\n    \t(not (sequential? (first xs))) [xs]\n\t    :else (concat (my-fn (first xs)) (my-fn (rest xs)))))", "user": "5c896f46e4b048ec896c5940"}, {"problem": 93, "code": "(fn pfs [s]\n   (mapcat\n    (fn rss [s]\n      (if (sequential? (first s))\n        (pfs s)\n        [s]))\n    s))", "user": "5e5b8d92e4b0fd0acd158658"}, {"problem": 93, "code": "(fn partial-flatten [inp]\n  ((fn helper [inp res]\n     (if (and (sequential? inp)\n              (sequential? (first inp)))\n       (reduce concat (for [i inp]\n                        (helper i res)))\n       (conj res inp))) inp []))", "user": "5dc53ddee4b02f9375f4e1bd"}, {"problem": 93, "code": "(fn [root]\n    (filter\n      #(and\n        (sequential? %)\n        (every? (complement sequential?) %))\n      (tree-seq sequential? identity root)))\n;https://github.com/tsclausing/4clojure/blob/master/src/com/fourclojure/problem/93.clj\n\n;works on clojure 1.8 (clojure.edn fails here)\n#_(\"\n#(let [delimiters (if (list? %) [#\"\\(\" #\"\\)\"] [#\"\\[\" #\"\\]\"])\nremove-right (apply str(clojure.string/split (str %) (get delimiters 1)))\nremove-left (filter (fn [x] (not= x '(\"\"))) (map list (clojure.string/split remove-right (get delimiters 0))))\nget-symbol (fn [st] (apply symbol (clojure.string/trim st)))\nconvert (fn [x] (map clojure.edn/read-string (clojure.string/split x #\" \")))\nf-symbol (fn [x] (convert (first x)))\nf-type (fn [x] (if (list? s) (apply list (f-symbol x)) (apply vector (f-symbol x))))\nflatt (map f-type remove-left)]\n(if (vector? %)\n(apply vector flatt)\nflatt))\n\")", "user": "5e13a6b7e4b099d064963001"}, {"problem": 93, "code": "(fn flatten-1 [tree]\n  (if (every? sequential? tree)\n    (mapcat flatten-1 tree)\n    [tree]))", "user": "5c3796b3e4b0d62ef62d9f77"}, {"problem": 93, "code": "(fn [s] (filter #(= % (flatten %)) (tree-seq coll? identity s)))", "user": "4eb70649535d7eef30807373"}, {"problem": 93, "code": "(fn [coll]\n  (loop [coll coll\n         acc []]\n    (let [elem (first coll)\n          [contents] elem]\n      (cond\n        (empty? coll) acc\n        (sequential? contents) (recur (concat elem (rest coll)) acc)\n        :else (recur (rest coll) (concat acc [elem]))))))", "user": "53528cd3e4b084c2834f4af2"}, {"problem": 93, "code": "(let [flat? #(not (some sequential? %))]\n    (fn step [xs]\n      (if (flat? xs)\n        [xs]\n        (mapcat step xs))))", "user": "5a5d0726e4b0512ff01cd91b"}, {"problem": 93, "code": "(fn fl\n  ([coll] (fl coll []))\n  ([[x & xs :as xss] acc]\n   (cond\n     (nil? x) acc\n     (sequential? x) (fl xs (fl x acc))\n     :else (conj acc xss))))", "user": "5eb1c786e4b00a66d4a95201"}, {"problem": 93, "code": "(fn [xs] (loop [x xs\n       n 0]\n  (if (< n 10)\n    (recur (reduce #(if (coll? (first %2))\n                      (into [] (concat % %2))\n                      (conj % %2)) [] x)\n           (inc n))\n    x)))", "user": "5ec3a13ae4b08d0ec38692b9"}, {"problem": 93, "code": "(fn [s]\n  (->> (tree-seq sequential? identity s)\n       (filter sequential?)\n       (filter (partial not-any? sequential?))))", "user": "5e6ca949e4b04a83ad7cd289"}, {"problem": 93, "code": "(fn [sq]\n    (let [res (atom [])]\n      (letfn [(par-flat [s]\n                (cond (empty? s) nil\n                      (not (sequential? (first s))) (reset! res (conj @res s))\n                      :else (for [x s]\n                              (dorun (par-flat x)))))]\n        (dorun (par-flat sq)))\n      @res))", "user": "5da71eaee4b000c986472c15"}, {"problem": 93, "code": "(fn f [s]\n  (let [nested? #(and (sequential? %) (some sequential? %))]\n    (->>\n     (tree-seq nested? seq s)\n     (remove nested?))))", "user": "5de12192e4b0948ae9d9aded"}, {"problem": 93, "code": "(fn f [l] \n  (if (coll? (first l)) (mapcat f l) (list l)))", "user": "5dd35dcbe4b0948ae9d9ad5f"}, {"problem": 93, "code": "(fn f [s]\n  (if (every? sequential? s)\n    (mapcat #(if (and (every? sequential? %) (sequential? (first %))) (f %) [%]) s)\n    s))", "user": "50ed4626e4b01236b1d4983c"}, {"problem": 93, "code": "(fn [xs]\n  (->> xs\n       (tree-seq sequential? identity)\n       (filter #(and (sequential? %)\n                     (every? (complement sequential?) %)))))\n\n;(defn m-flatten [xs]\n;  (filter (complement sequential?)\n;          (tree-seq sequential? identity xs)))", "user": "5ebdb3d2e4b00a66d4a95275"}, {"problem": 93, "code": "(fn pflat [colls]\n   (when (seq colls)\n     (if (sequential? (ffirst colls))\n       (pflat (concat (first colls) (rest colls)))\n       (cons (first colls) (pflat (rest colls))))))", "user": "56c60b36e4b05cc29241eead"}, {"problem": 93, "code": "(fn partially-flatten\n  [coll]\n  (filter #(not-any? coll? %)\n          (tree-seq #(some coll? %) identity coll)))", "user": "5ecfd429e4b016b56eae05a9"}, {"problem": 93, "code": "(fn f [coll]\n  (->> (partition-by coll? coll)\n       (map (fn [item]\n              (if (coll? (first item))\n                (apply concat (map f item))\n                (list item))))\n       (apply concat)))", "user": "5ec6de19e4b08d0ec38692da"}, {"problem": 93, "code": "(fn solution [colls]\n  (if (coll? (first colls))\n    (mapcat solution colls)\n    [colls]))", "user": "5e2ef900e4b05b4b015161fc"}, {"problem": 93, "code": "(fn fl [xs]\n  (if (every? sequential? xs)\n    (mapcat fl xs)\n    [xs]))", "user": "597dcb0ce4b0dbe32238d0a2"}, {"problem": 93, "code": "(fn flat [[x & xs]]\n   (cond\n     (nil? x) nil\n     (sequential? x) (if (sequential? (first x))\n                       (concat (flat x) (flat xs))\n                       (cons x (flat xs)))\n     :else (cons x (flat xs))))", "user": "5eee7311e4b07c55ae4a0510"}, {"problem": 93, "code": "(fn [x] (let [f #(loop [y %] (if (coll? (first y)) (recur (first y))y))] \n           (apply concat(map #(if (coll? (first %)) (map f %) [%])x))))", "user": "5951190be4b066ee0a44aea4"}, {"problem": 93, "code": "(fn f [xs]\n  (if (every? sequential? xs)\n    (mapcat f xs)\n    [xs]))", "user": "5dc88a38e4b02f9375f4e1db"}, {"problem": 93, "code": "(fn [coll] (let [\n                 \n                 no-collections? (fn [coll] (empty? (filter #(coll? %) coll)))\n                 partial-flatten (fn partial-flatten [coll result] \n                                   (if (no-collections? coll)\n                                     (concat result [coll])\n                                     (let [oolls-only (filter #(coll? %) coll)]\n                                       (concat (partial-flatten (first oolls-only) result)\n                                               (partial-flatten (rest oolls-only) result)))\n                                     )\n                                                     )\n                                   \n                 ]\n              (filter #(not-empty %) (partial-flatten coll []))\n  ))", "user": "53c73e8ae4b00fb29b2212a5"}, {"problem": 93, "code": "(fn t [x]\n  (let [u (first x) v (next x)]\n    (if u\n      (if (coll? (first u))\n        (concat (t u) (t v))\n        (cons u (t v))\n      )\n      []\n    )\n  )\n)", "user": "5df08767e4b093ff717275bf"}, {"problem": 93, "code": "(fn pflat [s]\n  (reduce\n    (fn f [A b]\n      (if (sequential? (first b))\n        (reduce f A b)\n        (conj A b)))\n    []\n    s))", "user": "5b02ab12e4b0cc2b61a3bd53"}, {"problem": 93, "code": "(fn [xs]\n  (letfn [(flat? [c] (and (coll? c) (every? (complement coll?) c)))]\n    (filter flat? (tree-seq sequential? seq xs))))", "user": "56c4f43ce4b05cc29241ee9c"}, {"problem": 93, "code": "(fn flatten-custom\n  [xs]\n  (cond\n    (and (coll? xs) (not (coll? (first xs)))) [xs]\n    (coll? xs) (mapcat flatten-custom xs)\n    :else [xs]))", "user": "5ed6030de4b016b56eae05db"}, {"problem": 93, "code": "(fn [coll]\n  (loop [b coll c (first b) ret []]\n    (cond\n      (empty? b) ret\n      (->> (sequential? (first c)) not) (recur (rest b) (->> (rest b) first) (conj ret c))\n      :else (recur (concat c (rest b)) (first c) ret)\n      )))", "user": "5405885ee4b0addc1aec6668"}, {"problem": 93, "code": "(fn base-list ([input] (base-list input []))\n  ([input coll]\n   (if (empty? input) coll\n     (loop [s (first input) remaining (rest input) result coll]\n       (if (nil? s) result\n         (if (coll? (first s))\n           (recur (first remaining) (rest remaining) (base-list s result))\n           (recur (first remaining) (rest remaining) (conj result s))))))))", "user": "5ef5ee81e4b07c55ae4a054a"}, {"problem": 93, "code": "(fn partially-flatten [s]\n  (lazy-seq\n    (when [s (seq s)]\n      (reduce\n        #(if (and (coll? %2) (every? (fn [e] (coll? e)) %2))\n           (into %1 (partially-flatten %2))\n           (conj %1 %2))\n        []\n        s))))", "user": "5f300f28e4b033932238a682"}, {"problem": 93, "code": "(fn f [x]\n  (if (some coll? x)\n    (mapcat f x)\n    [x]))", "user": "5b7f2d75e4b047b03b203768"}, {"problem": 93, "code": "(fn f [coll]\n   (if (and (sequential? coll)\n            (sequential? (first coll)))\n     (let [resu (concat [] (f (first coll)))]\n       (if (not (empty? (rest coll)))\n         (concat resu (f (rest coll)))\n         resu))\n     [coll]))", "user": "535f0cbde4b04ce2eb3ed2d9"}, {"problem": 93, "code": "(fn [coll]\n  (letfn [(leaf? [coll]\n            (and\n             (coll? coll)\n             (reduce (fn [acc e]\n                       (and acc\n                            (not (coll? e))))\n                     true\n                     coll)))]\n    (->> coll\n         (tree-seq coll? identity)\n         (filter leaf?))))", "user": "5f37839ee4b0574c87022c59"}, {"problem": 93, "code": "(fn flat [v]\n  (cond (not (coll? (first v))) (conj nil v)\n        (= 1 (count v)) (flat (first v))\n        (> (count v) 1) (concat (flat (first v)) (flat (rest v)))))", "user": "58f98231e4b0438e51c2cf4c"}, {"problem": 93, "code": "(fn pfs [tree]\n  (if (every? sequential? tree)\n    (mapcat pfs tree)\n    [tree]))", "user": "5cf895efe4b0b71b1d808a85"}, {"problem": 93, "code": "(fn pflatten [tree]\n  (if (every? sequential? tree)\n    (mapcat pflatten tree)\n    [tree]))", "user": "5f49350ee4b0102c7503393f"}, {"problem": 93, "code": "(fn foo [x]\n   (if (every? coll? x)\n     (mapcat foo x)\n     (list x)))", "user": "5f3abcc4e4b004f08c61c52b"}, {"problem": 93, "code": "(fn g [[x & y :as c]]\n    (cond (not (sequential? c)) c\n          (empty? c) c\n          (and (sequential? x) (not (sequential? (first x)))) (cons x (g y))\n          :else (concat (g x) (g y))))", "user": "5bd0ea60e4b0e9689409ee45"}, {"problem": 93, "code": "(fn [l]\n   (letfn [(flat [l]\n             (cond\n               (not (coll? l)) [l]\n               (not (coll? (first l))) [l]\n               (> (count l) 1) (concat (flat (first l)) (flat (rest l)))\n               :else (flat (first l))\n               ))]\n     (flat l)\n     ))", "user": "5f3f2281e4b004f08c61c561"}, {"problem": 93, "code": "(fn [instructure]\n (filter\n  #(and (sequential? %)\n        (not (some sequential? %)))\n  (tree-seq sequential? seq instructure)))", "user": "5bf9d9b7e4b0bdcf453d15c4"}, {"problem": 93, "code": "(fn f [s]\n    (let [leaf (not (coll? (first s)))]\n      (if leaf\n        [s]\n        (apply concat (map f s)))))", "user": "5f06caa7e4b0cf489e8d7f52"}, {"problem": 93, "code": "(fn extract [ls]\n\t(let [acceptable (fn [elem]\n\t\t(if (coll? elem)\n\t\t\t(every? #(not (coll? %)) elem)\n\t\t\ttrue\n\t\t)\n\t)]\n\t\t(loop [res [], cronch ls]\n\t\t\t(if (empty? cronch)\n\t\t\t\tres\n\t\t\t\t(recur\n\t\t\t\t\t(concat res\n\t\t\t\t\t\t(if (acceptable (first cronch))\n\t\t\t\t\t\t\t[(first cronch)]\n\t\t\t\t\t\t\t(extract (first cronch))\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t\t(next cronch)\n\t\t\t\t)\n\t\t\t)\n\t\t)\n\t)\n)", "user": "5d73530ce4b02e6b30c93514"}, {"problem": 93, "code": "(fn f [[h & t :as sq]]               \n  (cond                                \n                                       \n    (not (seq sq))                     \n      nil                              \n                                       \n    (and (sequential? sq)              \n         (not (sequential? h)))        \n    [sq]                               \n                                       \n    :else                              \n    (concat (f h) (f t))))", "user": "4f3e6244e4b0e243712b1f85"}, {"problem": 93, "code": "(fn [s]\n    (let [leaf? (fn [xs] (and (coll? xs) (every? #(not (coll? %)) xs)))\n          nodes (fn [xs] (tree-seq (complement leaf?) seq xs))\n          ans   (filter leaf? (nodes s))\n         ]\n         ;(println \"inp\" s)\n         ;(println \"nodes:\" (nodes s))\n         ;(println \"ans\" ans)\n         ans))", "user": "5eff6c0ee4b0cf489e8d7f11"}, {"problem": 93, "code": "(fn pflatten [s] (mapcat #(if (sequential? (first %)) (pflatten %) [%]) s))", "user": "5f03ab5be4b0cf489e8d7f37"}, {"problem": 93, "code": "(fn flat2 [coll] \n    (when-let [s (seq coll)]\n       (if (coll? (first (first s)))\n          (concat  (flat2 (first s)) (flat2 (rest s)))\n          (cons  (first s) (flat2 (rest s))))) )", "user": "53a5bc3ae4b0ef122a8689c3"}, {"problem": 93, "code": "(fn partlat [xs]\n    (letfn [(branch? [s] (some sequential? s))]\n      (filter\n        (complement branch?)\n        (tree-seq branch? identity xs))))", "user": "5c9dcb36e4b048ec896c5b1d"}, {"problem": 93, "code": "(fn pflat [s]\n  (letfn [(aux [s r]\n            (if (not (sequential? (first s)))\n              (conj r s)\n              (loop [s s\n                     r r]\n                (if (empty? s)\n                  r\n                  (recur (rest s) (aux (first s) r))))))]\n    (aux s [])))", "user": "5f8b06afe4b0715f5002d74a"}, {"problem": 93, "code": "(fn f [s]\n  (reduce (fn [acc x]\n            (if (sequential? x)\n              (into acc (f x))\n              (update-in acc [0] (fnil conj []) x)))\n          []\n          s))", "user": "56ef077ae4b04a395b9a0459"}, {"problem": 93, "code": "(fn [xs]\n    (filter #(and (coll? %) (not (coll? (first %))))\n            (tree-seq sequential? identity xs)))", "user": "507e68abe4b085af06e3afd2"}, {"problem": 93, "code": "(fn pflat [lst]\n  (if (and (sequential? lst) (every? (complement sequential?) lst))\n    [lst]\n    (mapcat pflat lst)))", "user": "5fa74b82e4b0fa27300f3dda"}, {"problem": 93, "code": "(fn unpack [v]\n   (if (some sequential? v)\n     (mapcat unpack v)\n     [v]))", "user": "596a66cde4b069c0a1a19803"}, {"problem": 93, "code": "(fn flat [s]\n    (reduce (fn [res s]\n              (cond \n                (and (coll? s)\n                     (some coll? s)) (apply conj res (flat s))\n                (coll? s)            (conj res s)\n                :else                (conj res s)))\n            []\n            s))", "user": "5f93529ae4b0715f5002d7bc"}, {"problem": 93, "code": "(fn p-flatten [s]\n  (if (sequential? (first s))\n    (apply concat (map p-flatten s))\n    [s]))", "user": "5f5358b7e4b0a0bc16850a77"}, {"problem": 93, "code": "(fn partial-flatten [sq]\n (filter (complement #(some sequential? %))\n         (rest (tree-seq #(some sequential? %) identity sq))))", "user": "5143824ae4b0b4fb4ace5f36"}, {"problem": 93, "code": "#(let [f (-> % flatten first)]\n   (cond\n    (string? f) [[\"Do\"] [\"Nothing\"]]\n    (keyword? f) [[:a :b] [:c :d] [:e :f]]\n    (integer? f) '((1 2)(3 4)(5 6))))", "user": "5e8ce2fee4b0cb0169546328"}, {"problem": 93, "code": "(fn f [l] \n  (if (empty? l) () \n    (if (sequential? (first l)) \n      (concat (f (first l)) (f (rest l))) \n      (list l)) \n  )\n)", "user": "5fab7ea6e4b08cb800c85ad8"}, {"problem": 93, "code": "(fn [data]\n    (letfn [(get-ans [s ans]\n              (if (empty? s)\n                ans\n                (let [[x & r] (seq s)]\n                  (if (and (coll? x)\n                           (some coll? x))\n                    (recur (concat x r) ans)\n                    (recur r (conj ans x))))))]\n      (get-ans data [])))", "user": "591ad160e4b09b4ee5954bdf"}, {"problem": 93, "code": "(fn f [x]\n  (if (empty? x)\n    ()\n    (if (not (coll? (first x)))\n      [x]\n      (concat (f (first x)) (f (rest x))))))", "user": "5e12327ee4b099d064962fe5"}, {"problem": 93, "code": "(fn flatten-partially-v2 [s]\n  (loop [tail s res []]\n    (let [head (first tail)]\n      (if (nil? head)\n        res\n        (if (every? coll? head)\n            (recur (rest tail) (into res (flatten-partially-v2 head)))\n        (recur (rest tail) (conj res head)))\n      )\n\n    )\n  )\n)", "user": "5ff676a9e4b06df49cee1497"}, {"problem": 93, "code": "(fn foo [s]\n    (let [flat? (fn [x] (every? #(not (sequential? %)) x))]\n        (if (empty? s)\n            '()\n            (let [x (first s)\n                  xs (rest s)\n                  flatx (if (flat? x) (list x) (foo x))\n                  flatxs (foo xs)]\n                (concat flatx flatxs)))))", "user": "600ae927e4b074f607df6689"}, {"problem": 93, "code": "(fn [c] (filter #(= % (flatten %)) (tree-seq sequential? seq c)))", "user": "5fd10010e4b07e53c2f3f02a"}, {"problem": 93, "code": "(fn almost-flatten [coll]\n  (apply concat (for [elem coll]\n            (if-not (sequential? (first elem))\n              [elem]\n              (almost-flatten elem)))))", "user": "601aaa93e4b0bf4ca6b10926"}, {"problem": 93, "code": "(fn f [xs]\n  (if (every? (complement coll?) xs)\n    [xs]\n    (mapcat f xs)))", "user": "5e3e23d9e4b01d43a70e8e20"}, {"problem": 93, "code": "(fn [xs]\n  (filter #(and (sequential? %) (not (sequential? (first %)))) (tree-seq sequential? seq xs)))", "user": "6011b89ee4b074f607df66bc"}, {"problem": 93, "code": "(fn ff [colls]\n  (if (every? sequential? colls)\n\t(mapcat ff colls)\n    [colls] \n  )\n)", "user": "5fd8bcb3e4b05ac5b16ea11b"}, {"problem": 93, "code": "(fn f [coll]\n   (if (every? coll? coll)\n     (mapcat f coll)\n     (list coll)\n     ))", "user": "60096aabe4b074f607df667f"}, {"problem": 93, "code": "(fn myflat [szn]\n  (let [obsah (apply str (-> (str szn) (rest) (butlast)))]\n    (read-string (str \"[\" (-> obsah \n                 (clojure.string/replace #\"\\(+\" \"(\")\n                 (clojure.string/replace #\"\\)+\" \")\")\n                 (clojure.string/replace #\"\\[+\" \"[\")\n                 (clojure.string/replace #\"\\]+\" \"]\")) \"]\"))))", "user": "60264d89e4b0d5df2af2222d"}, {"problem": 93, "code": "(fn partially-flatten\n  [xs]\n  (mapcat\n   (fn [e]\n     (if (some coll? e)\n       (partially-flatten e)\n       [e]))\n   xs))", "user": "5f37263de4b0574c87022c4e"}, {"problem": 93, "code": "(fn s [xs]\n  (if (every? coll? xs)\n    (mapcat s xs)\n    [xs]))", "user": "5cb41c40e4b026601754b911"}, {"problem": 93, "code": "(fn pflatten [tree]\n  (if (every? sequential? tree)\n    (mapcat pflatten tree)\n    [tree]))", "user": "6030855de4b0d5df2af222a6"}, {"problem": 93, "code": "(fn unpack [x] \n  (loop\n   [head (first x)\n    tail (rest x)\n    res []]\n    (let [flathead (or (= 1 (count head)) (not (every? coll? head)))\n          new-tail (if (= true flathead) (rest tail) (concat (rest head) tail))\n          new-head (if (= true flathead) (first tail) (first head))\n          new-res (if (= true flathead) (conj res (flatten head)) res)]\n      (if (nil? new-head) new-res (recur new-head new-tail new-res)))))", "user": "604d3cb1e4b0b7ec0ac60ac2"}, {"problem": 93, "code": "(fn [s] (let [nse? (complement sequential?)\n        almost-flat? (fn [x] (or (nse? x)\n                                  (every? true? (map nse? x))))]\n    (filter almost-flat?\n            (rest (tree-seq (complement almost-flat?) seq s)))))", "user": "5f419985e4b0955706451fab"}, {"problem": 93, "code": "(fn partial-flatten [l]\n  ;; argument l must be a list\n  (if (every? #(not (coll? %)) l)\n    (list l)\n    (apply concat (map partial-flatten l))))", "user": "60460824e4b02d28681c77bc"}, {"problem": 93, "code": "(fn partial-flatten\n  [s]\n  (letfn [(base-coll? [s]\n            (and (coll? s)\n                 (not (coll? (first s)))))\n          (->base [result ns]\n            (cond\n              (empty? ns) result\n              (base-coll? ns) (conj result ns)\n              :else (->base (->base result (first ns))\n                            (rest ns))))]\n    (->base [] s)))", "user": "4e586949535d8a8b8723a292"}, {"problem": 93, "code": "(fn [coll]\n  (letfn [(step [coll result]\n            (if (seq coll)\n              (let [first-ele (first coll)]\n                (step (next coll)\n                  (if (some coll? first-ele)\n                    (reduce #(conj %1 %2) result (step first-ele []))\n                    (conj result first-ele))))\n              result))]\n    (step coll [])))", "user": "54d7e277e4b0a52adc2e2031"}, {"problem": 93, "code": "(fn partially-flatten [ss]\n  (if (not-any? coll? ss) [ss]\n    (mapcat partially-flatten (filter coll? ss))))", "user": "605b7a90e4b079a07f8593fc"}, {"problem": 93, "code": "(fn partially-flatten [xs]\n  (loop [xs xs ys '()]\n    (if (empty? xs)\n      (reverse ys)\n      (let [[x & xs'] xs]\n        (if (and (sequential? x) (sequential? (first x)))\n          (recur (concat x xs') ys)\n          (recur xs' (cons x ys)))))))", "user": "58b81490e4b0ebc645576d8c"}, {"problem": 93, "code": "(fn fltn [[a & tail]]\r\n  (letfn \r\n    [(foo [a]\r\n       (if (coll? (first a))\r\n         (fltn a)\r\n         [a]))]\r\n    (if (empty? tail) \r\n      (foo a)\r\n      (concat (foo a) (fltn tail)))))", "user": "606e0a42e4b069485764de19"}, {"problem": 93, "code": "(fn solve [tree]\n  (if (every? sequential? tree)\n    (mapcat solve tree)\n    [tree]))", "user": "60537cd1e4b04c8f2157d152"}, {"problem": 93, "code": "(fn flatten-1 [coll]\n    (let [a (mapcat #(if (some coll? %)\n                         (flatten-1 %)\n                         (list %))\n                    coll)\n          c (if (list? a) (reverse a) a)]\n          c))", "user": "5f548678e4b0a0bc16850a7e"}, {"problem": 93, "code": "(fn partial-flatten\n  [coll]\n  (println coll)\n  (cond\n    (not (coll? (first coll))) [coll]\n    (= 1 (count coll)) (partial-flatten (first coll))\n    :else (concat (partial-flatten (first coll)) (partial-flatten (rest coll)))))", "user": "60396c95e4b0d5df2af222f4"}, {"problem": 93, "code": "(fn partial-flatten [coll]\n  (let [len (fn [coll](loop [coll coll ]\n                        (if (coll? (first coll))\n                          (recur (first coll) )\n                          (count coll))))\n        mini (apply min (map len coll))\n        flattened (flatten coll)]\n      (partition mini flattened)))", "user": "60654263e4b069485764ddc9"}, {"problem": 93, "code": "(fn [coll]\n  (letfn [(another [cs r]\n            (mapcat (fn [x] (if (not-any? #(coll? %) x) (conj r x) (another x r))) cs))]\n    (another coll [])))", "user": "606a70a5e4b069485764ddf2"}, {"problem": 93, "code": "(fn partially-flatten [xs]\n  (reduce\n    (fn [flattened x]\n      (if (not-any? sequential? x)\n        (conj flattened x)\n        (into flattened (partially-flatten x))))\n    []\n    xs))", "user": "4fe49706e4b0e8f79898feb7"}, {"problem": 93, "code": "(fn [colls]\n   (loop [c (into '() colls) flattened-c '()]\n     (let [looked-at (first c)]\n       (cond\n         (empty? c) flattened-c\n         (and (instance? clojure.lang.Seqable looked-at)\n              (instance? clojure.lang.Seqable (first looked-at)))\n         (recur (into (rest c) looked-at) flattened-c)\n\n         :else (recur (rest c) (conj flattened-c looked-at))))))", "user": "608ec5e4e4b03bd49d9f36c0"}, {"problem": 93, "code": "(fn unrav [n]\n   (let [l (first n) r (next n)]\n     (concat\n      (if (and (sequential? l) (not (sequential? (first l))))\n        [l]\n        (unrav l))\n      (when (sequential? r)\n        (unrav r)))))", "user": "60b7e2c5e4b0e0fa5f1b4252"}, {"problem": 93, "code": "(fn my-partially-flatten [coll]\n  (reduce\n   (fn [acc x]\n     (if (and (coll? x) (some true? (map coll? x)))\n       (into acc (my-partially-flatten x))\n       (conj acc x)))\n   [] coll))", "user": "5f82609ae4b0c071e6c840f9"}, {"problem": 93, "code": "(fn partial-flatten [sq]\n  (letfn [(one-deep? [s]\n            (and\n             (sequential? s)\n             (not (sequential? (first s)))))]\n    (filter one-deep? (tree-seq sequential? seq sq))))", "user": "51b920bfe4b0e871ca4958f9"}, {"problem": 93, "code": "(fn pflatten [tree]\n  (if (every? sequential? tree)\n    (mapcat pflatten tree)\n    [tree]))", "user": "60c43b20e4b0e0fa5f1b42c9"}]