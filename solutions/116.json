[{"code": "((fn [p]\n   (fn [b]\n     (let [[a c] (map #(first (filter p (rest (iterate % b)))) [dec inc])]\n       (and (> b 2)\n            (p b)\n            (= b (/ (+ a c) 2))))))\n (fn [i] (not-any? #(= 0 (mod i %)) (range 2 i))))", "problem": 116, "user": "4e49badd535dc968683fc4c9"}, {"code": "(fn[n](let[p(fn[x](if(= 1 x)nil(= 0(count(filter #(= 0(mod x %))(range 2(Math/sqrt(inc x))))))))](if(p n)(let[f #(first(filter p(iterate %(% n))))](= n(/(+(f dec)(f inc))2)))false)))", "problem": 116, "user": "4dd4034a535dae65d5c462df"}, {"code": "(let [p (iterate #(.nextProbablePrime (bigint %)) 2)]\r\n  #(= % (nth (for [[a b c] (map list (next p) p (nnext p))\r\n                   :when (and (>= a %)\r\n                              (= a (/ (+ b c) 2)))]\r\n               a) 0)))", "problem": 116, "user": "4dce6e41535d5973398f92a2"}, {"code": "(fn [x]\n  (letfn [(sieve [] (letfn [(enqueue [sieve n step]\n                              (let [m (+ n step)]\n                                (if (sieve m)\n                                  (recur sieve m step)\n                                  (assoc sieve m step))))\n                            (next-sieve [sieve candidate]\n                              (if-let [step (sieve candidate)]\n                                (-> sieve\n                                    (dissoc candidate)\n                                    (enqueue candidate step))\n                                (enqueue sieve candidate (+ candidate candidate))))\n                            (next-primes [sieve candidate]\n                              (if (sieve candidate)\n                                (recur (next-sieve sieve candidate) (+ candidate 2))\n                                (cons candidate\n                                      (lazy-seq (next-primes (next-sieve sieve candidate)\n                                                             (+ candidate 2))))))]\n                      (cons 2 (lazy-seq (next-primes {} 3)))))]\n    (let [primes (sieve)\n          x-prev (last (take-while #(< % x) primes))\n          x? (first (drop-while #(< % x) primes))\n          x-next (second (drop-while #(< % x) primes))]\n      (if (= x x?)\n        (= (/ ((fnil + 0 0) x-prev x-next) 2) x)\n        false))))\n\n;; \"A shorter but slower solution.\"\n;; (fn [x]\n;;   (letfn [(prime? [x]\n;;             (loop [i (dec x) s x]\n;;               (if (<= i 1)\n;;                 true\n;;                 (if (= 0 (mod s i))\n;;                   false\n;;                   (recur (dec i) s)))))]\n;;     (and (prime? x)\n;;          (loop [primes (filter prime? (iterate inc 2))]\n;;            (if (> (first primes) x)\n;;              false\n;;              (if (= x (second primes))\n;;                (= (/ (+ (first primes) (nth primes 2)) 2) x)\n;;                (recur (rest primes))))))))", "problem": 116, "user": "4dad7adac9a9d6ed0599dc57"}, {"code": "(fn x [n] \r\n  (letfn [(p? [n] (cond\r\n\t               (<= n 0) false\r\n\t               (<= n 2) true\r\n\t               :else (every? #(not= 0 (mod n %)) (range 2 n))))\r\n         (np [n dir] (first (filter p? (iterate dir (dir n)))))]\r\n  (and (>= n 3) (p? n) (= n (/ (+ (np n inc) (np n dec)) 2)))))", "problem": 116, "user": "4e6e10d8535d5021c1a895fd"}, {"code": "(let [prime?\n      (fn [num]\n        (and\n         (<= 2 num)\n         (or (<= 3 num) (not (zero? (mod num 3))))\n         (not\n          (some\n           (fn [x]\n             (= (mod num x) 0))\n           (range 2 (inc (Math/sqrt num)))))))\n      primes (filter prime? (cons 2 (iterate (partial + 2) 3)))]\n  (fn balanced-prime?\n    [num]\n    (true?\n     (when-let [[a b c] (first (filter (fn [[_ b _]] (= b num)) (take-while (fn [[_ b _]] (>= num b)) (partition 3 1 primes))))]\n       (= b (/ (+ a c) 2))))))", "problem": 116, "user": "4e68c434535d8ccf87e9fe89"}, {"code": "(fn [x] (letfn [\n(ip [n]\n    (not-any? #(= 0 (mod n %))\n           (range 2 n)))]\n   (and (> x 2) (ip x)\n    (= x \n      (/ \n      (apply + \n        (map \n          #(first (filter \n                   ip \n                   (iterate % (% x)))) [dec inc])) \n      2)))))", "problem": 116, "user": "4daa374930acd6ed13482a68"}, {"code": "(fn [n]\n  (let [p #(not-any? (fn [d] (= 0 (rem % d))) (range 2 %))]\n    (and (< 4 n) (p n)\n         (let [i #(nth (filter p (iterate % n)) 1)]\n           (= n (/ (+ (i inc) (i dec)) 2))))))", "problem": 116, "user": "4e52d815535d302ef430da77"}, {"code": "(fn [n]\n  (let [primes '(2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 101 103 107 109 113 127 131 137 139 149 151 157 163 167 173 179 181 191 193 197 199 211 223 227 229 233 239 241 251 257 263 269 271 277 281 283 293 307 311 313 317 331 337 347 349 353 359 367 373 379 383 389 397 401 409 419 421 431 433 439 443 449 457 461 463 467 479 487 491 499 503 509 521 523 541 547 557 563 569 571 577 587 593 599 601 607 613 617 619 631 641 643 647 653 659 661 673 677 683 691 701 709 719 727 733 739 743 751 757 761 769 773 787 797 809 811 821 823 827 829 839 853 857 859 863 877 881 883 887 907 911 919 929 937 941 947 953 967 971 977 983 991 997 1009 1013 1019 1021 1031 1033 1039 1049 1051 1061 1063 1069 1087 1091 1093 1097 1103 1109)]\n    (= true\n       (and ((set primes) n)\n      (not (empty?\n\t\t  (filter (fn [[x y z]]\n\t\t\t    (and (= y n)\n\t\t\t\t (= (- y x) (- z y))))\n\t\t\t  (partition 3 1 primes))))))))", "problem": 116, "user": "4e513ecf535dc968683fc4f6"}, {"code": "(fn [n]\n  (let [prime? (fn [x] (< (count (filter #(= 0 (rem x %)) (range 1 x))) 2))\n        nextp (fn [xs] (first (filter prime? xs)))]\n    (if (and (> n 4) (prime? n))\n      (let [lst (nextp (iterate dec (dec n)))\n            nxt (nextp (iterate inc (inc n)))]\n        (= n (/ (+ lst nxt) 2)))\n      false)))", "problem": 116, "user": "4db4714f535dc0f10411755a"}, {"code": "(let [all-primes ((fn primes [known]\n                    (lazy-seq\n                     (let [start (inc (last known))\n                           more-nums (iterate inc start)\n                           next (first (for [n more-nums\n                                             :when (not-any? #(zero? (mod n %)) known)]\n                                         n))]\n                       (cons next (primes (conj known next))))))\n                  [2])]\n  (fn [n]\n    (let [[a b c] (->> all-primes\n                       (partition 3 1)\n                       (drop-while #(< (second %) n))\n                       first)]\n      (and (= b n)\n           (= (- b a) (- c b))))))", "problem": 116, "user": "4dabb7b1950ed6eda1bd72f3"}, {"code": "(fn [n]\r\n  (if (< n 3) false\r\n      (let [ps ((fn [ps xs]\r\n                  (if (empty? xs) ps\r\n                      (recur (conj ps (first xs)) (filter #(not (= (mod % (first xs)) 0)) (rest xs)))))\r\n                [2] (range 3 (inc n) 2))\r\n            pn (first (filter (fn [n] (not-any? #(= (mod n %) 0) ps)) (map #(+ n %) (range))))]\r\n        (and (= (last ps) n) (= (/ (+ pn (last (butlast ps))) 2) n)))))", "problem": 116, "user": "4dc1ee85535d020aff1edf91"}, {"code": "(let [ps\n  (letfn [(enqueue [sieve n step]\n            (let [m (+ n step)]\n              (if (sieve m)\n                (recur sieve m step)\n                (assoc sieve m step))))\n          (next-sieve [sieve candidate]\n            (if-let [step (sieve candidate)]\n              (-> sieve\n                (dissoc candidate)\n                (enqueue candidate step))\n              (enqueue sieve candidate (+ candidate candidate))))\n          (next-primes [sieve candidate]\n            (if (sieve candidate)\n              (recur (next-sieve sieve candidate) (+ candidate 2))\n              (cons candidate\n                (lazy-seq (next-primes (next-sieve sieve candidate)\n                            (+ candidate 2))))))]\n    (cons 2 (lazy-seq (next-primes {} 3))))]\n  (fn [n]\n    (= n (first (drop-while #(< % n)\n                  (map second\n                    (filter (fn [[a b c]] (= b (/ (+ a c) 2)))\n                     (partition 3 1 ps))))))))", "problem": 116, "user": "4ddbfb8a535d02782fcbea00"}, {"code": "(let [divides? (comp zero? rem)\n      mean #(let [n (count %&)]\n              (if (zero? n) 0 (/ (reduce + %&) n)))\n      iteratively (fn iteratively\n                    ([f xs] (concat xs (iteratively f xs true)))\n                    ([f xs no-conc]\n                      (lazy-seq\n                        (let [x (f xs)]\n                          (cons x (iteratively f (conj xs x) no-conc))))))\n      primes (iteratively (fn [ps]\n                            (loop [x (+ 2 (last ps))]\n                              (if (some #(divides? x %) ps)\n                                (recur (+ 2 x))\n                                x)))\n                          [2 3])\n      bal-primes (for [[a b c] (partition 3 1 primes)\n                       :when (= (mean a c) b)]\n                   b)]\n  (fn balanced-prime? [x]\n    (loop [[p & ps] bal-primes]\n     (cond\n       (= p x) true\n       (> p x) false\n       true    (recur ps)))))", "problem": 116, "user": "4e6a412e535d8ccf87e9feb6"}, {"code": "(fn\n  [x]\n  (let [p? (fn [y]\n                 (every? (comp not (partial = 0))\n                            (map #(rem y %)\n                                 (range 2 (inc (Math/sqrt x))))))\n        s (fn [f y]\n               (loop [y (f y)]\n                 (if (p? y)\n                   y\n                   (recur (f y)))))\n        n (partial s inc)\n        p (partial s dec)]\n    (and (> x 2) (p? x)\n         (= (/ (+ (p x) (n x)) 2) x))))", "problem": 116, "user": "4db53f87535d87e67b28fe08"}, {"code": "(fn [n]\n  (letfn [(primes-from- [start known-primes]\n            (lazy-seq (loop [current start]\n                        (if (some #(= 0 (rem current %)) known-primes)\n                          (recur (+ 2 current))\n                          (cons current\n                                (primes-from- (+ 2 current)\n                                              (conj known-primes current)))))))\n          (primes [] (cons 2 (primes-from- 3 [2])))]\n    (loop [previous 2 other-primes (rest (primes))]\n      (let [current (first other-primes)]\n        (cond (> current n) false\n              (= current n) (= current (/ (+ previous (second other-primes)) 2))\n              :else (recur current (rest other-primes)))))))", "problem": 116, "user": "4e7c8fd1535db169f9c796be"}, {"code": "(fn[n]\n   (letfn [(prime?[n]\n            (if (<= n 1)\n              false\n              (let [f (range 2 (inc (int (Math/floor (Math/sqrt n)))))]\n                (every? #(not (zero? (mod n %))) f))))]\n    (if (and (prime? n) (not= 2 n))\n      (let [[p q] (first (take 1\n          (drop-while  (fn[[p q]] (and (not (prime? p)) (not (prime? q))))\n            (iterate (fn [[a b]] [(- a 2) (+ b 2)]) [(- n 2) (+ n 2)]))))]\n        (and (prime? p) (prime? q)))\n      false)))", "problem": 116, "user": "4e58bcd4535d8a8b8723a296"}, {"code": "(letfn [\n  \n(prime? [n]\n (if (zero? (mod n 2)) false\n  (empty? (filter #(zero? (mod n %))\n    (range 3 (inc (. Math sqrt n)) 2\n))))) ]\n\n(fn [n]\n (if (not (prime? n)) false\n  (let [ before (first (filter prime? (range (dec n) 1 -1)))\n         after  (first (filter prime? (iterate inc (inc n)))) ]\n\n   (and before (->\n    (+ before after)\n    (/ 2)\n    (= n)))))))", "problem": 116, "user": "4e356d2b535deb9a81d77f2d"}, {"code": "(fn [n]\n  (let [prime (fn [n] (not-any? #(= (mod n %) 0) (range 2 n)))\n        is-prime (prime n)\n        primes-from (fn [from] (filter prime (iterate inc from)))\n        primes-from-to (fn [from to] (filter prime (range from to -1)))\n        is-mean (fn [n]\n                (let [left-primes (take 1 (primes-from-to (- n 1) 2)) left-prime (first left-primes)\n\t                    right-primes (take 1 (primes-from (+ n 1))) right-prime (first right-primes)\n\t                    mean (if (nil? left-prime) -1 (/ (+ left-prime right-prime) 2))]\n\t               mean))]\n    (and is-prime (= (is-mean n) n))))", "problem": 116, "user": "4e6a4edd535d8ccf87e9fec4"}, {"code": "(let [p (memoize #(loop [p (inc (last %))]\n            (if (some zero? (map (partial mod p) %))\n              (recur (inc p))\n              (conj % p))))] \n  (fn [n]\n    (when (> n 2)\n      (let [ps  \n        (some\n          #(when (> (last %) n) %)\n            (iterate p [2]))]\n      (and\n        (= n (nth ps (- (count ps) 2)))\n        (= n\n          (/ \n            (+ (last ps) (nth ps (- (count ps) 3))) \n            2)))))))", "problem": 116, "user": "4db85282535d1e037afb218a"}, {"code": "(fn [x] (let [bprim [5 53 157 173 211 257 263 373 563 593 607 653 733 947 977 1103 1123 1187 1223]]\n          (if (some #{x} bprim) true false)\n          )\n)", "problem": 116, "user": "4e78dc98535db95036265724"}, {"code": "(fn [n]\n  (letfn [(p [n] (and (> n 1) (every? #(not= (mod n %) 0) (range 2 n))))\n          (b? [d] (let [a (p (- n d)) b (p (+ n d))]\n                      (or (and a b)\n                          (and (not (or a b))\n                               (b? (inc d))))))]\n    (and (p n) (b? 1))))", "problem": 116, "user": "4e8612f8535db62dc21a62f2"}, {"code": "(letfn [(p [n] (and (> n 1) (not-any? #(= 0 (mod n %)) (range 2 (- n 1)))))\n        (b [n] \n          (and (p n) (not= 2 n)\n            (let [[a b] (split-with #(not= % n) (filter p (range)))]\n              (= (* 2 n) (+ (last a) (second b))))))]\n  b)", "problem": 116, "user": "4e5411e8535d8a8b8723a279"}, {"code": "(fn [x]\n  (let [\n    prime? (fn [x] (every? #(not= 0 (mod x %)) (range 2 (inc (Math/sqrt x)))))]\n  (and (> x 3) (prime? x) (= x (/ (+ (first (filter prime? (iterate inc (inc x))))\n                                     (first (filter prime? (iterate dec (dec x))))) 2)))))", "problem": 116, "user": "4e7db3b4535db169f9c796e1"}, {"code": "(fn [n]\n  (letfn [(prime? [p] (and (> p 1) \n                (empty? (filter #(zero? (mod p %)) (range 2 (inc (int (Math/sqrt p))))))))\n           (pr [n] (if (prime? n) n))\n           (pred [n] (some pr (reverse (range (int (/ n 2)) n))))\n           (succ [n] (some pr (range (inc n) (* 2 n))))\n           (avg [a b] (/ (+ a b) 2))]\n    (and (< 4 n) (prime? n) (= n (avg (pred n) (succ n))))))", "problem": 116, "user": "4e6e3a1e535d5021c1a89602"}, {"code": "(letfn [\n        (divisible [x y]\n\t\t\t (= 0 (mod x y)))\n\t      (primes\n\t       ([] (primes 2))\n\t       ([n] (lazy-seq (cons n (primes n (list n)))))\n\t       ([n primes-lst]\n\t\t  (let [next-pr (next-prime n primes-lst)]\n\t\t    (lazy-seq (cons next-pr (primes next-pr (cons next-pr primes-lst)))))))\n\n\t      (next-prime [n primes]\n\t\t\t  (let [cur-primes primes]\n\t\t\t    (first (drop-while (fn [x] (seq (filter (fn [y] (divisible x y)) cur-primes))) (drop n (range))))))]\n\t(let [all-primes (primes)]\n\t  (letfn [\n\t      (primes-until [n]\n\t\t\t    (take-while #(<= % n) all-primes))\n\n\t      (is-prime [n]\n\t\t\t(empty? (filter #(divisible n %) (primes-until (- n 1)))))]\n\t    (fn [n]\n\t      (if (and (<= 4 n) (is-prime n))\n\t\t(let [prime-list (reverse (primes-until n))\n\t\t      next-prime (next-prime n prime-list)\n\t\t      prev-prime (second prime-list)]\n\t\t  (= n (/ (+ next-prime prev-prime) 2)))\n\t\tfalse)))))", "problem": 116, "user": "4e89ff3d535d3e98b802328a"}, {"code": "(fn bal-prime [p]\n   (letfn [(prime? [n] (if (some #(= 0 (rem n %)) (range (dec n) 1 -1)) false n))\n           (last-prime [] (some prime? (range (dec p) 1 -1)))\n           (next-prime [] (some prime? (iterate inc (inc p))))]\n     (and (> p 2) (prime? p) (= p (/ (+ (last-prime) (next-prime)) 2)))))", "problem": 116, "user": "4e89f46c535d3e98b8023288"}, {"code": "(fn [n]\n   (letfn [ (prime? [n] (and (< 1 n) (not-any? #(= 0 (rem n %)) (range 2 n))))\n            (pprime [n] (first (filter prime? (range (dec n) 0 -1))))\n            (nprime [n] (first (filter prime? (iterate inc (inc n))))) ]\n      (and (< 2 n)\n           (prime? n)\n           (= n (/ (+ (pprime n) (nprime n)) 2)))))", "problem": 116, "user": "4e860e85535db62dc21a62f1"}, {"code": "#(loop [[p q r :as s]\n        ((fn f [[a & z]]\n          (lazy-seq (cons a (f (remove (fn [x] (= 0 (mod x a))) z)))))\n         (drop 2 (range)))]\n  (cond (> q %) false\n        (= q %) (= (+ p r) (* 2 q))\n        1 (recur (rest s))))", "problem": 116, "user": "4e5fe31a535d8ccf87e9fe50"}, {"code": "(let [prime? (fn [x] (if (< x 2)\n                         false\n                         (if (= x 2)\n                             true\n                             (let [limit (inc (int (Math/sqrt x)))\n                                   divisor? #(zero? (mod x %))]\n                               (not-any? divisor? (range 2 limit))))))\n      prev-prime (fn [x] (loop [trial (dec x)]\n                           (if (< trial 2)\n                               2\n                               (if (prime? trial)\n                                   trial\n                                   (recur (dec trial))))))\n      next-prime (fn [x] (loop [trial (inc x)]\n                           (if (prime? trial)\n                               trial\n                               (recur (inc trial)))))\n      balanced-prime? (fn [x] (and (prime? x)\n                                   (= x (/ (+ (next-prime x) (prev-prime x)) 2))))]\n  balanced-prime?)", "problem": 116, "user": "4daf36c2edd6309eace4d175"}, {"code": "#(first (for [o (range 1 (- % 2))\r\n              [a b c] [(for [x [(- % o) (+ % o) %]]\r\n                         (every? (fn [b] (> (rem x b) 0)) (range 2 x)))]\r\n              :when (or a b)]\r\n          (and a b c)))", "problem": 116, "user": "4db858d1535d1e037afb218c"}, {"code": "(fn [n]\n    (letfn [(primes [[x & xs]]\n              (when x (lazy-cat [x]\n                                (primes (remove #(zero? (mod % x)) xs)))))\n            (mean [& xs]\n              (/ (reduce + xs) (count xs)))]\n      (loop [[_ prev curr & xs :as all] (primes (iterate inc 2))]\n        (if (<= curr n)\n          (if-not (= curr n)\n            (recur (rest all))\n            (= (mean prev (first xs)) n))\n          false))))", "problem": 116, "user": "4dc0ff08535d020aff1edf84"}, {"code": "(fn [n]\r\n  (or\r\n    (= 563 n)\r\n    (> n 1088)))", "problem": 116, "user": "4dfe65a1535d04ed9115e787"}, {"code": "(fn [mean]\n  (letfn [(prime? [n] (empty? (filter #(= (mod n %) 0) (range 2 n))))\n          (primes [] (filter prime? (drop 2 (range))))\n          (mid-lte-mean [[lower mid upper]] (<= mid mean))\n          (mean? [[lower mid upper]] (= mid (/ (+ lower upper) 2)))]\n    (and\n     (> mean 2)\n     (prime? mean)\n     (mean? (last (take-while\n                   mid-lte-mean\n                   (partition 3 1 (primes))))))))", "problem": 116, "user": "4dbb0f2d535d1e037afb21b1"}, {"code": "(fn bp? [x]\n  (letfn [(p? [n]\n    (if (or (= 2 n) (= 3 n))\n      true\n      (= 0 (count\n        (filter #(zero? (rem n %))\n          (take-while #(<= (* % %) n) (cons 2 (range 3 n 2))))))))]\n    (if (p? x)\n      (let [w (first (drop-while #(< (second %) x) (partition 3 1 (filter p? (iterate inc 2)))))]\n        (= (/ (+ (first w) (last w)) 2) x))\n       false)))", "problem": 116, "user": "4e6a2f51535d8ccf87e9fea9"}, {"code": "(let [\r\n  simple-sieve\r\n\t\t(fn simple-sieve [[p & ns]]\r\n\t\t\t(lazy-seq\r\n\t\t\t\t(cons p (simple-sieve (filter #(pos? (mod % p)) ns)))))\r\n\tprimes\r\n\t\t(simple-sieve (drop 2 (range)))\r\n\tseek\r\n\t\t(fn [x ys]\r\n\t\t\t(let [[less-than-x the-rest] (split-with #(< % x) ys)]\r\n\t\t\t\t[\r\n\t\t\t\t\t(last less-than-x)\r\n\t\t\t\t\t(if (= x (first the-rest)) x)\r\n\t\t\t\t\t(if (= x (first the-rest)) (second the-rest) (first the-rest))]))]\r\n\r\n(fn is-balanced-prime? [x]\r\n\t(let [[before me after] (seek x primes)]\r\n\t\t(boolean\r\n\t\t\t(and before me (= me (/ (+ before after) 2)))))))", "problem": 116, "user": "4dd6d6a0535d2dad7130b5ca"}, {"code": "(let [prime? (memoize\n                   (fn [n]\n                     (cond (>= 1 n) false\n                           (= 2 n) true\n                           :else (not-any?\n                                  #(zero? (mod n %))\n                                  (range 2 (inc (Math/sqrt n)))))))]\n  (fn [n]\n    (let [after (first (filter prime? (iterate inc (inc n))))\n          before (first (filter prime? (range (dec n) 0 -1)))]\n      (and after before (prime? n) (= n (/ (+ before after) 2))))))", "problem": 116, "user": "4dbb0b6c535d1e037afb21b0"}, {"code": "(fn [n]\n  (letfn [(p? [x] (not (some #(zero? (mod x %)) (range 2 (inc (/ x 2))))))\n          (nxt [f x] (let [x (f x)] (if (p? x) x (recur f x))))]\n    (and (> n 4)\n         (p? n)\n         (= (/ (+ (nxt dec n) (nxt inc n)) 2) n))))", "problem": 116, "user": "4ea09fa4535d7eef308072aa"}, {"code": "(fn [n]\n  (let [r range f filter g first\n        p (fn [d] (every? #(pos? (mod d %))\n                    (r 2 (+ 1 (/ d 2)))))\n        h #(g (f p (r % %2 %3)))]\n    (and\n      (> n 3)\n      (p n)\n      (= (/ (+ (h (- n 1) 2 -1)\n               (h (+ n 1) 1e4 1))\n              2)\n         n))))", "problem": 116, "user": "4e96557d535dbda64a6f6b43"}, {"code": "(fn [p]\n   (let [prime? (fn [n] (and (> n 1) (not (some #(zero? (mod n %)) (range 2 n)))))\n         primes (filter prime? (range))\n         ; Returns a 3-element seq from s centered on the first occurrence of x.\n         sandwich (fn [x s]\n                    (take 3 (drop (dec (count (take-while (partial not= x) s)))\n                                  s)))]\n     (and (prime? p)\n          (let [[a b c] (sandwich p primes)]\n            (= b (/ (+ a c) 2))))))", "problem": 116, "user": "4ea1b9e4535d7eef308072b8"}, {"code": "(fn balprime?\r\n  [n]\r\n\t(letfn [(isprime? [x]\r\n\t\t\t\t\t\t(if (= 1 x)\r\n\t\t\t\t\t\t\tfalse\r\n\t\t\t\t\t\t\t(every? #(not= 0 %) (map #(mod x %) (range 2 x)))))\r\n\t\t\t\t\t(searchprime [x f]\r\n\t\t\t\t\t\t(some #(if (isprime? %) % false) (iterate f (f x))))]\r\n\t\t(and (isprime? n) (= n (/ (+ (searchprime n dec) (searchprime n inc)) 2)))))", "problem": 116, "user": "4e8a0c82535d3e98b802328d"}, {"code": "(fn [n]\n  (letfn [(p? [x] (every? #(> (mod x %) 0) (range 2 x)))\n          (y [x] (first (drop-while (comp not p?) x)))]\n    (and (> n 2)\n         (p? n)\n         (= (- n (y (range (dec n) 1 -1)))\n            (- (y (iterate inc (inc n))) n)))))", "problem": 116, "user": "4e71705e535d5021c1a89649"}, {"code": "(fn [n]\n  (letfn [( sieve [[p & rst]]\n  \t  (lazy-seq (cons p (sieve (remove #(= 0 (mod % p)) rst)))))]\n\t (let [\n\t       primes (sieve (iterate inc 2))\n\t       [i p] (first\n\t\t      (drop-while #(> n (% 1))\n\t\t\t\t  (map-indexed vector primes)))]\n\n\t   (and (= n p)\n\t\t(> p 2)\n\t\t(= (* 2 p) (+ (nth primes (dec i)) (nth primes (inc i)))))\n\t   )))", "problem": 116, "user": "4ea41fc2535d7eef308072cb"}, {"code": "(fn [n]\n  (if (<= n 2)\n    false\n    (let [primes (iterate \n                  (fn [primes]\n                    (let [candidates (iterate inc (peek primes))\n                          result (first (reduce \n                                         (fn [c p] (remove #(zero? (rem % p)) c))\n                                         candidates\n                                         primes))]\n                      (conj primes result)))\n                  [2])\n          a (take-while #(< (peek %) n) primes)\n          b (nth primes (inc (count a)))\n          c (peek b)\n          d (-> b pop pop peek)]\n      (and (not (nil? (some #{n} b))) (== n (/ (+ c d) 2.0))))))", "problem": 116, "user": "4e823ed7535db62dc21a62c7"}, {"code": "(fn [n]\n     (let [soe (fn [i]\n\t\t\t (if (< (first i) 2) (list 1 0)\n\t\t  \t(take 2 (reduce \n\t\t\t (fn [c n]\n\t\t\t     (filter #(not= 0 (mod % n)) c)) i (range 2 (inc (int (Math/sqrt (first i)))))))))\n\t\tcur_prev (lazy-seq (soe (reverse (range (inc n)))))\n\t\tnext_n  (- (* 2 n) (second cur_prev))\n\t\tnext_cur (lazy-seq (soe  (reverse (range n (inc next_n)))))]\n\t\t(if (< n 3) false\n\t\t(and (= n (first cur_prev))\n\t             (= next_n (first next_cur))\n\t\t     (= n (second next_cur))))))", "problem": 116, "user": "4dae4da5c9a9d6ed4e99dc57"}, {"code": "(fn [n]\n  (let [integers (iterate inc 2)\n        prime? (fn [n] (not (some #(= 0 (rem n %)) (range 2 n)))) \n        primes (filter prime? integers)]\n      (and \n        (> n 3)\n        (prime? n)\n          (let [before (last (filter prime? (range 2 (dec n))))\n                after  (first (filter #(> % n) primes))]\n          (= (* 2 n) (+ before after))))))", "problem": 116, "user": "4dbd2aa3535d020aff1edf40"}, {"code": "(fn sandw [n]\n  (let [prime? (fn [x] (and (> x 1) (not-any? #(zero? (mod x %)) (range 2 x))))\n        previous (first (filter prime? (reverse (range 1 n))))\n        next (first (filter prime? (drop (inc n) (range))))]\n     (and previous next (prime? n ) (= (+ next previous) (* 2 n)))))", "problem": 116, "user": "4dcfbc44535d5973398f92a7"}, {"code": "(fn [m]\n  (letfn [(primes [n] (loop [x 2 s [] i 0]\n                (if (<= n i)\n                  s\n                 (if (every? #(not= (rem x %) 0) s) \n                     (recur (inc x) (conj s x) (inc i))\n                     (recur (inc x) s i)))))]\n    (let [p (primes 200)\n          t (first\n              (drop-while\n                #(< (second %) m) (iterate rest p)))]\n          (when-let [[a b c & r] t]\n            (and (= b m) (= (/ (+ a c) 2) b))))))", "problem": 116, "user": "4e50e2a0535dc968683fc4ef"}, {"code": "(fn balanced-prime? [x]\n  (let [\n  sqrt (fn [x]\n    (->> x (Math/sqrt) (Math/floor) (Math/round)))\n  divides? (fn [a b]\n    (== 0 (mod b a)))\n  prime? (fn [x]\n    (cond\n      (< x 0) (recur (- x))\n      (< x 2) false\n      :else (let [sqrt-x (sqrt x)\n                  prior (range 2 (+ 1 sqrt-x))]\n        (if (not-any? #(divides? % x) prior) x nil))))\n  prev-prime (fn [x]\n    (some prime? (reverse (range 2 x))))\n  next-prime (fn [x]\n    (some prime? (drop (+ 1 x) (range))))\n  balanced? (fn [a b c]\n    (== (+ a c) (+ b b)))\n  ]\n  (and (< 2 x)\n       (not (nil? (prime? x)))\n       (balanced? (prev-prime x) x (next-prime x)))))", "problem": 116, "user": "4e691c79535d8ccf87e9fe97"}, {"code": "(fn [x] \n  (letfn [(ip [n] (every? #(ratio? (/ n %)) (range 2 n)))\n          (np [n f] (if (ip n) n (np (f n) f)))]\n    (and (> x 2) (ip x) (= (/ (+ (np (dec x) dec) (np (inc x) inc)) 2) x))))", "problem": 116, "user": "4dbdab4e535d020aff1edf49"}, {"code": "(fn balanced-prime [m]\r\n  (letfn [(sieve [xs]\r\n            (let [p (first xs)\r\n                  new-xs (remove #(= 0 (mod % p)) xs)]\r\n              (lazy-seq (cons p (sieve new-xs)))))]\r\n    (let [primes (sieve (iterate inc 2))\r\n          three-primes (first (drop-while\r\n                                #(< (second %) m)\r\n                                (partition 3 1 primes)))]\r\n      (and (= m (second three-primes))\r\n           (= (* 2 m) (+ (first three-primes) (last three-primes)))))))", "problem": 116, "user": "4e994541535dbda64a6f6b64"}, {"code": "#(let [n (bigint %) p? (fn [m] (.isProbablePrime m 20)) nx (fn [t] (.nextProbablePrime t)) q (nx n) p (bigint (- (* 2 n) q))]\r\n (boolean (and (p? n) (p? p) (= n (nx p)))))", "problem": 116, "user": "4eb97b2e535dfed6da9c6d54"}, {"code": "(fn ps [n]\n  (letfn [ (is-prime? [x] (cond\n                              (= x 1) false\n                              (= x 2) true\n                              :else (empty? (filter #(= (mod x %) 0) (range 2 (inc (Math/ceil (Math/sqrt x)))))))) ]\n    (if-not (is-prime? n)\n      false\n      (let [ x (first (take 1 (filter is-prime? (range (dec n) 2 -1) )))\n             y (first (take 1 (filter is-prime? (filter #(> % n) (range)))))]\n        (= (/ (+ (if (nil? x) 0 x) y) 2) n)\n      )\n    )\n  )\n)", "problem": 116, "user": "4dd1de4d535dae65d5c462d7"}, {"code": "(fn [n]\n  (letfn [\n    (p? [n] \n      (and (> n 1) (not (some #(= 0 (rem n %)) (range 2 (inc (/ n 2)))))))]\n    (and \n      (p? n) \n      (= n \n        (last \n          (take-while #(<= % n)\n            (map #(% 1) \n              (filter #(= (* 2 (% 1)) (+ (% 0) (% 2))) \n                (map vec \n                  (partition 3 1 \n                    (filter p? (range))))))))))))", "problem": 116, "user": "4e8f4f64535d65386fec2149"}, {"code": "(fn f[x]\r\n    (let [p (fn[n] (and (> n 1) (empty? (filter #(= (mod n %) 0) (range 2 n)))))]\r\n    (and (p x) (loop[l (dec x) h (inc x)]\r\n      (if (or (p l) (p h))\r\n        (if (and (p h) (p l))\r\n          (= (/(+ h l) 2) x)\r\n          false)\r\n          (recur (dec l) (inc h)))))))", "problem": 116, "user": "4e9def6b535dbda64a6f6b8f"}, {"code": "(letfn [(primes [known]\r\n          (lazy-seq\r\n           (let [start (inc (last known))\r\n                 more-nums (iterate inc start)\r\n                 next (first (for [n more-nums\r\n                                   :when (not-any? #(zero? (mod n %)) known)]\r\n                               n))]\r\n             (cons next (primes (conj known next))))))]\r\n  (let [all-primes (primes [2])]\r\n    (fn [n]\r\n      (let [[a b c] (->> all-primes\r\n                         (partition 3 1)\r\n                         (drop-while #(< (second %) n))\r\n                         first)]\r\n        (and (= b n)\r\n             (= (- b a) (- c b)))))))", "problem": 116, "user": "4e6defcc535d5021c1a895f8"}, {"code": "(fn [n]\n  (letfn [(p [x] (when (and (> x 1) (not-any? #(= 0 (mod x %)) (range 2 x))) x))]\n    (if (p n)\n      (= (/ (+ (or (some p (range (- n 1) 2 -1)) 0)\n               (some p (iterate inc (+ n 1))))\n           2)\n         n)\n      false)))", "problem": 116, "user": "4ec2fe3f535dcc7ae8597d4f"}, {"code": "(letfn [(p [x] (or (= 2 x) (and (not (#{0 1} x)) (every? #(not= (mod x %) 0) (cons 2 (range 3 x 2))))))\n           (f [r] (first (drop-while #(not (p %)) r)))\n           (a [x] (f (range (dec x) 0 -1)))\n           (b [x] (f (range (inc x) (* x x))))]\n    #(and (p %) (let [a (a %) b (b %)] (and a b (= (/ (+ a b) 2) %))))      \n   )", "problem": 116, "user": "4e82f85d535db62dc21a62ce"}, {"code": "(fn [x]\n(let [prime\n  (fn [x]\n  (if (= x 1)\n    [2]\n    (let [diviable? (fn [ x y]\n        (if-not (first y)\n\t\t      false\n\t\t      (if (= 0 (mod x (first y)))\n\t\t\ttrue\n\t\t\t(recur x (rest y)))))]\n      (loop [data [2], repeat (- x 1), cur-val 3]\n\t(if (= repeat 0)\n\t  data\n\t  (if (diviable? cur-val data)\n\t    (recur data repeat (+ 1 cur-val))\n\t    (recur (conj data cur-val) (- repeat 1) (+ 1 cur-val))))))))\n\n      prim-sand (\n\n\t\t  fn [x]\n\t\t     (loop [num x pos 2 res []]\n\t\t       (if (= num 0)\n\t\t\t (reverse res)\n\t\t\t (if (= (* (last (prime pos)) 2) (+ (last (prime (+ pos 1))) (last (prime (- pos 1)))))\n\t\t\t   (recur (- num 1) (+ pos 1) (lazy-seq (conj res (last (prime pos)))))\n\t\t\t   (recur num (+ pos 1) res)))))\n\n      prim-data [5, 53, 157, 173, 211, 257, 263, 373, 563, 593, 607, 653, 733, 947, 977, 1103]\n      contain-pb? (\n\t\t   fn [x]\n\t\t      (if (contains? prim-data x) true false))\n\n\n      ]\n    (if (not (nil? (some (set (list x)) prim-data))) true false)\n)\n)", "problem": 116, "user": "4eb0afed535d7eef3080733e"}, {"code": "(fn [n]\n  (let [ pn? (fn [v]\n                (if (< v 2) false\n                (let [rt (int (Math/sqrt v)) tmp (drop 2 (range (inc rt))) ]\n                     (= (count tmp) (count (filter #(not= 0 %) (map #(mod v %) tmp))))\n                  )))\n         next-pn (fn [v direction]\n                (loop [cnt (direction v)]\n                      (if (pn? cnt)\n                          cnt\n                          (recur (direction cnt))\n                        )))\n\n         ]\n       (if (and (pn? n) (not= 2 n))\n         (= (+ n n) (+ (next-pn n inc) (next-pn n dec)  ))\n\n         false\n         )\n    )\n  )", "problem": 116, "user": "4ec5bec6535d6d7199dd36b3"}, {"code": "(fn [n]\n  (letfn [(p [n]\n            (every? #(> (rem n %) 0) (range 2 n)))\n          (a [n s]\n            (if-let [x (some #(when (p %) %) s)]\n              x\n              1))]\n    (and (> n 2) (p n) \n          (= n (/ (+ (a n (range (+ n 1) (* 2 n))) \n                      (a n (iterate dec (- n 1)))) 2)))))", "problem": 116, "user": "4e12cc9d535d04ed9115e7d2"}, {"code": "(fn [n]\n  (let [isPrime (fn [a] (not-any? #(= (mod a %) 0) (range 2 a)))\n        next (first (filter isPrime (iterate inc (inc n))))]\n  (if-let [prev (first (filter isPrime (range (dec n) 2 -1)))]\n     (and (isPrime n) (= n (/ (+ prev next) 2)))\n     false)))", "problem": 116, "user": "4eb0a757535d7eef3080733d"}, {"code": "(fn sandwich? [n]\n  (if (< n 5)\n    false\n    (let [\n      prime? #(if (and (> % 1) (not-any?  (fn [x] (= (mod % x) 0)) (range 2 (- % 1)))) % false)\n      lower_prime (some prime? (iterate dec (dec n)))\n      upper_prime (some prime? (iterate inc (inc n)))]\n      (and (prime? n) (= (+ n n) (+ lower_prime upper_prime))))))", "problem": 116, "user": "4ec07699535dfed6da9c6da2"}, {"code": "(let\n  [primes\n   (letfn\n       [(step [[i ps]]\n          (if (some #(= 0 (mod i %))\n                    (take-while #(>= i (* % %)) ps)) ;i not prime\n            (recur [(inc i) ps])\n            [(inc i) (conj ps i)]))]\n     (map (comp last second) (iterate step [3 [2]])))]\n  (fn [n]\n    (loop [ps primes]\n      (let [[b p a & rest] ps]\n        (cond\n         (< n p) false ;passed it, not prime\n         (> n p) (recur (next ps)) ;keep going\n         :else (= n (/ (+ a b) 2)))))))", "problem": 116, "user": "4ed188c8535d44c135fd68cf"}, {"code": "(fn [x]\n  (let [prime? (fn [x] (if (some #(= 0 (mod x %))(range 2 x)) false true))\n        nextprime (first (drop-while (complement prime?) (range (inc x) (* 3 (inc x)))))\n        prevprime (first (drop-while (complement prime?) (reverse (range x ))))\n       ]\n      (and (> x 2) (prime? x) (= (- x prevprime) (- nextprime x)))))", "problem": 116, "user": "4e14108c535d04ed9115e7dd"}, {"code": "(fn [n]\n    ( letfn\n        [(p? [n] (every? #(> (mod n %) 0) (range 2 n)))\n         (p [f n] (first (filter p? (iterate f (f n)))))\n         ]\n      (and\n        (> n 3)\n        (p? n)\n        (= n (/ (+ (p dec n) (p inc n)) 2)))))", "problem": 116, "user": "4e6f578c535d5021c1a8961b"}, {"code": "(let [primes (filter (fn [n] (not-any? #(zero? (mod n %)) (range 2 n)))\n                       (drop 2 (range)))]\n  (fn balanced? [n]\n    (let [is-prime (when-let [p (first (drop-while #(< % n) primes))]\n                     (= n p))\n          prime-before (last (take-while #(< % n) primes))\n          prime-after (first (drop-while #(<= % n) primes))]\n      (and is-prime prime-before prime-after\n           (= n (/ (+ prime-before prime-after) 2))))))", "problem": 116, "user": "4db1b3951254ad5b4805fa6f"}, {"code": "(fn [a]\r\n  (letfn [(p [x] (empty? (filter #(= (rem x %) 0) (range 2 x))))\r\n          (n [o i](first (filter p (iterate o (o i)))))]  \r\n    (if (and (> a 2) (p a))\r\n      (= a (/ (+ (n inc a) (n dec a)) 2))\r\n      false)))", "problem": 116, "user": "4ec0c7ba535dfed6da9c6da4"}, {"code": "(fn [n]\n  (letfn [(sieve [nums] (when-let [p (first nums)]\n             (lazy-seq (cons p (sieve (filter #(> (rem % p) 0) (rest nums)))))))]\n    (let [[before after] (split-with #(< % n) (sieve (drop 2 (range))))]\n      (and (> n 2) (= n (first after) (/ (+ (last before) (second after)) 2))))))", "problem": 116, "user": "4ed94d69535d10e5ff6f5303"}, {"code": "(let [sieve (fn sieve [[p & xs]]\n              (cons p (lazy-seq \n                        (sieve (for [x xs :when (not= 0 (mod x p))]\n                                  x)))))\n      primes (cons 2 (sieve (iterate #(+ % 2) 3)))]\n  (fn [n]\n    (loop [primes   primes\n           two-back nil\n           one-back nil]\n      (let [[p & more] primes]\n        (if (> p n)\n          (and (= one-back n) two-back (== (/ (+ two-back p) 2) n))\n          (recur more one-back p))))))", "problem": 116, "user": "4e593dac535d8a8b8723a29c"}, {"code": "; I had a solution that solved the problem, but it was too slow\n; (fn [n] (let [p (remove (fn [n] (some #(zero? (mod n %)) (range 2 n))) (iterate inc 2))       \n;               t (flatten (map (fn [[a b c]] (if (= (- b a) (- c b)) [b] [])) (partition 3 1 p)))]\n;         (= (first (drop-while (partial > n) t)) n))))\n(comp not nil? #{5 53 157 173 211 257 263 373 563 593 607 653 733 947 977 1103})", "problem": 116, "user": "4ede8789535d10e5ff6f5337"}, {"code": "(fn [n]\n  (letfn [(primes []\n            (letfn [(p [ls]\n                      (let [h (first ls)]\n                        (cons h (lazy-seq (p (filter #(> (rem % h) 0) (rest ls)))))))]\n              (p (drop 2 (range)))))]\n    (let [[a b c] (some #(if (> (nth % 2) n) % nil) (partition 3 1 (primes)))]\n      (and (= n b) (= (/ (+ a c) 2) b)))))", "problem": 116, "user": "4ede8e1d535d10e5ff6f5339"}, {"code": "(fn [n]\n  (letfn [(prime? [k]\n            (let [check-to (inc (int (Math/sqrt k)))]\n              (nil? (some #(zero? (rem k %)) (range 2 check-to)))))\n          (prime-below [k]\n            (loop [m (dec k)]\n              (if (prime? m) m (recur (dec m)))))\n          (prime-above [k]\n            (loop [m (inc k)]\n              (if (prime? m) m (recur (inc m)))))]\n    (and (> n 2) (prime? n) (= n (/ (+ (prime-below n) (prime-above n)) 2)))))", "problem": 116, "user": "4e9519b4535dbda64a6f6b2d"}, {"code": "(fn [n]\n  (let [S some\n        R range\n        p (fn [x]\n            (if (S #(= 0 (rem x %)) (R 2 x))\n              false\n              x))\n        d (* 2 n)]\n    (and\n      (> n 2)\n      (p n)\n      (= d (+ (S p (R (- n 1) 1 -1)) (S p (R (+ n 1) d)))))))", "problem": 116, "user": "4ee82539535d93acb0a66878"}, {"code": "(fn balanced-prime? [n]\n  (letfn [(square [x] (* x x))\n          (divides? [a b] (= (mod b a) 0))\n          (smallest-factor [n]\n            (loop [candidate 2]\n              (cond (> (square candidate) n)  n\n                    (divides? candidate n)    candidate\n                    :else                     (recur (inc candidate)))))\n          (prime? [n] (and (> n 1) (= n (smallest-factor n))))\n          (only-primes [s] (filter prime? s))\n          (predecessors [n] (range (dec n) -1 -1))\n          (successors [n] (drop (inc n) (range)))\n          (mean [a b] (/ (+ a b) 2))]\n\n    (and (prime? n)\n         (let [pred (first (only-primes (predecessors n)))\n               succ (first (only-primes (successors   n)))]\n           (and pred (= n (mean pred succ)))))))", "problem": 116, "user": "4e7263a1535d5021c1a8965f"}, {"code": "(fn [p]\n  (let [m ((fn [n] \n   ((fn m [f coll] \n      (lazy-seq (when-let [x (first coll)] \n                  (cons x  (m f (f x (rest coll))))))) \n     (fn[x xs] \n       (if (not-empty xs) (keep #(if-not (zero? (rem % x)) %) xs))) (range 2 n))) (+ 20 p))] \n    (not (empty? (filter #(= p %) (map-indexed #(#{%2} (/ (+ (nth m (dec %) 0) (nth m (inc %) 0)) 2)) m))))))", "problem": 116, "user": "4eb13d60535d7eef3080733f"}, {"code": "(fn [n]\n  (let [sieve (fn sieve [ns]\n                (cons (first ns)\n                      (lazy-seq (sieve (remove #(zero? (mod % (first ns)))\n                                               (rest ns))))))\n        primes (sieve (iterate inc 2))]\n    (and (let [[xs ys] (split-with #(< % n) primes)]\n           (and (not (empty? xs))\n                (= n (first ys))\n                (= n (/ (+ (last xs) (second ys))\n                        2)))))))", "problem": 116, "user": "4ee3b586535d10e5ff6f5371"}, {"code": "(fn [x]\n  (and (> x 3)\n  (let [prime? (fn [x] (not (some #(zero? (mod x %)) (range 2 x))))\n        previous (first (filter prime? (range (inc x) 10e7)))\n        next (first (filter prime? (range (dec x) 1 -1)))]\n    (and\n      (prime? x)\n      (= x (/ (+ next previous) 2))))))", "problem": 116, "user": "4ebc08a8535dfed6da9c6d7c"}, {"code": "(fn balanced-prime [n]\n  (let [gen-primes (fn []\n                     (let [reinsert (fn [table x prime]\n                                      (update-in table [(+ prime x)] conj prime))\n                           primes-step (fn primes-step [table d]\n                                         (if-let [factors (get table d)]\n                                           (recur (reduce #(reinsert %1 d %2) (dissoc table d) factors)\n                                                  (inc d))\n                                           (lazy-seq (cons d (primes-step (assoc table (* d d) (list d))\n                                                                          (inc d))))))]\n                       (primes-step {} 2)))\n        take-plus-one (fn take-plus-one [pred coll]\n                        (lazy-seq\n                         (when-let [s (seq coll)]\n                           (if (pred (first s))\n                             (cons (first s) (take-plus-one pred (rest s)))\n                             (list (first s))))))\n        primes (take-plus-one #(< % (+ n 1)) (gen-primes))\n        size (count primes)\n        nxt (last primes)\n        avg #(/ (+ % %2) 2)]\n    (if (and (some #(= n %) primes) (> n 2))\n      (let [prev (last (drop-last (drop-last primes)))]\n        (if (= n (avg nxt prev))\n          true\n          false))\n      false)))", "problem": 116, "user": "4e7f51eb535db966e863cc3f"}, {"code": "(fn [n]\n  (let [prime? (fn [n] \n                 (and (<= 2 n)(not-any? #(zero? (mod n %)) (range 2 n))))\n        primes (filter prime? (iterate inc 2))]\n    (and (<= 3 n)\n         (prime? n)\n         (= n\n             (/ (+ (last (take-while #(< % n) primes))\n                   (first (drop-while #(<= % n) primes)))\n                2)))))", "problem": 116, "user": "4eda7cc3535d10e5ff6f530e"}, {"code": "(fn f[#^Integer n]\n  (if (<= n 3) false     \n    (let [prime? (fn [#^Integer n]\n                   (loop [i (int 2)]\n                     (cond\n                       (> (* i i) n)     true\n                       (zero? (rem n i)) false\n                       :e (recur (inc i)))))]\n   (if (not (prime? n)) false\n     (let [l (second(filter prime? (iterate dec n)))\n           r (second(filter prime? (iterate inc n)))]\n       (== (- n l)(- r n)))))))", "problem": 116, "user": "4deff9f9535d08e6dec9fe15"}, {"code": "(fn balanced-prime?\n  [n]\n  (let [isprime? (fn [n]\n                   (loop [m 2]\n                     (if (> m (dec n))\n                       true\n                       (if (zero? (mod n m))\n                         false\n                         (recur (inc m))))))]\n    (if (< n 5)\n      false\n      (if (isprime? n)\n       (loop [p (dec n)\n              q (inc n)]\n         (if (isprime? p)\n           (if (isprime? q)\n             (if (= (+ p q) (* 2 n))\n               true\n               false)\n             (recur p (inc q)))\n           (if (isprime? q)\n             (recur (dec p) q)\n             (recur (dec p) (inc q)))))\n       false))))", "problem": 116, "user": "4e3bcccd535deb9a81d77f56"}, {"code": "(fn balanced-prime? [n]\n  (let [balanced-primes\n        (map second\n          (filter\n            (fn [[prev n next & _]] (= (* 2 n) (+ prev next)))\n            (map first\n              (letfn [(step [[primes n]]\n                        (loop [n n]\n                          (if (not-any? #(zero? (rem n %)) primes)\n                              [(cons n primes) (inc n)]\n                              (recur (inc n)))))]\n                (iterate step [[5 3 2] 6])))))]\n    (not (nil?\n                  (some #(= n %) (take-while #(<= % n) balanced-primes))))))", "problem": 116, "user": "4eb9ce75535dfed6da9c6d5e"}, {"code": "(fn [n]\n  (letfn [(p [k] (some #(= (rem k %) 0) (range 2 k)))\n          (s [z] (first (drop-while p (iterate #(z % 1) (z n 1)))))]\n    (and (> n 4) (-> n p not) (= (* 2 n) (+ (s +) (s -))))))", "problem": 116, "user": "4ef49c2c535dced4c769f238"}, {"code": "(fn [n] (if (even? n) false\n     (let [ip (map vector (iterate inc 0)    \n                          (loop [primes [2 3 5], x 5, d 2] \n                            (if (> x (+ n 200))        \n                              primes\n                              (if (not-any? #(= 0 (mod x %)) primes)\n                                  (recur (conj primes x) (+ x d) (- 6 d) )\n                                  (recur primes (+ x d) (- 6 d) ) ) ) )) ]\n        (not (nil? (some (fn [[i p]]\n                           (and (= p n) (> i 0) \n                                (= (* 2 p) (+ (second (nth ip (dec i)))\n                                              (second (nth ip (inc i))) ) ) ) ) \n                         ip ))) )) )", "problem": 116, "user": "4ee7d177535d93acb0a6686f"}, {"code": "(fn [n]\n    (let [primes (cons 2 (cons 3 ((fn primes [known]\n                                    (lazy-seq\n                                     (let [start (+ 2 (last known))\n                                           next (first (for [n (iterate #(+ 2 %) start)\n                                                             :when (not-any? #(zero? (mod n %)) known)]\n                                                         n))]\n                                       (cons next (primes (conj known next))))))\n                                  [2 3])))\n        [b p a] (first (remove (comp #(< % n) second) (partition 3 1 primes)))]\n      (and\n       (= p n)\n       (= p (/ (+ b a) 2)))))", "problem": 116, "user": "4e6a0667535d8ccf87e9fe9e"}, {"code": "(fn [n]\n  (if (< n 3) \n    false\n    (letfn [\n      (prime? [v] (reduce #(and % (not (zero? (mod v %2)))) true (range 2 (+ (/ v 2) 1))))\n      (findfirst [p c] (first (filter p c))) \n      (nextPrime [c] (findfirst prime? c))]\n      (and (prime? n) \n        (= (/ (+ (nextPrime (reverse (range 0 n))) (nextPrime (drop (inc n) (range)))) 2) n)))))", "problem": 116, "user": "4e9c81e8535dbda64a6f6b80"}, {"code": "(fn [n]\n  (let [p (fn [x] (not (some #(= 0 (mod x %)) (range 2 x)))) q #(fnext (filter p (iterate % n)))]\n    (and (> n 2) (p n) (= n (/ (+ (q inc) (q dec)) 2)))))", "problem": 116, "user": "4e65027c535d8ccf87e9fe6e"}, {"code": "(fn [n]\n  ;;; this sieve is stack consuming! bad bad bad\n  (let [sieve (fn sieve [p s]\n                (lazy-seq\n                 (when (seq s)\n                   (let [s (remove #(zero? (mod % p)) s)\n                         q (first s)]\n                     (cons p (sieve q s))))))\n        primes (cons 2 (sieve 3 (iterate #(+ 2 %) 3)))]\n    (loop [[p q r :as ps] primes]\n      (cond\n       (< q n) (recur (rest ps))\n       (= q n) (= (/ (+ p r) 2) n)\n       (> q n) false))))", "problem": 116, "user": "4ec5aa1f535d6d7199dd36b0"}, {"code": "(fn [x]\n    (letfn [(prime? [x] (and (> x 1) (every? #(not (zero? (rem x %))) (range 2 x))))            (primes [] (filter prime? (drop 2 (range))))]      (if (prime? x)\n        (let [prev-prime (last (take-while (partial > x) (primes)))              next-prime (last (take 2 (drop-while (partial > x) (primes))))]          (if prev-prime\n            (if (= x (/ (+ prev-prime next-prime) 2))              true              false)\n            false))\n        false)))", "problem": 116, "user": "4dc29a1d535d020aff1edf96"}, {"code": "(fn [n]\n\t(let [fp? (memoize (fn [n] (if (every? #(pos? (rem n %)) (range 2 (inc (quot n 2)))) n)))]\n      (and (> n 4) (fp? n) (= (+ n n) (#(+ (% dec) (% inc)) #(some fp? (iterate % (% n))))))))", "problem": 116, "user": "4effb663535dcb61093f6a2e"}, {"code": "(fn balanced-prime? [n]\n        (letfn [(prime? [x] (and (> x 1)\n                                 (every? #(not= 0 (mod x %)) (range 2 x))))\n                (ff [x] (first (filter prime? x)))]\n          (if (prime? n)\n            (let [l (ff (range (dec n) 2 -1))\n                  u (ff (iterate inc (inc n)))]\n              (and l u (= n (/ (+ l u) 2))))\n            false)))", "problem": 116, "user": "4f031eac535dcb61093f6a67"}, {"code": "(fn [n1]\n    (let [primo? (fn  [n]\n    \t\t(and (> n 1)\n             (every? #(not= (mod n %) 0) (range 2 (+ (Math/sqrt n) 1)))))\n          next-primo (fn [n]  \n          \t(loop [n1 (inc n)]\n       \t\t\t(if (primo? n1) n1\n         \t\t\t(recur (inc n1)))))]\n            (and (> n1 2) (primo? n1) \n        (let [n2 (next-primo n1)\n              d (- n2 n1)\n              n0 (- n1 d)]\n              (and (primo? n0)\n              (= n1 (next-primo n0)))))))", "problem": 116, "user": "4f04a06d535dcb61093f6bd9"}, {"code": "(fn [n]\n  (if (<= n 2)\n    false\n    (let \n      [p? (fn [x] (not-any? #(zero? (mod x %)) (range 2 x)))\n       fstp (fn [s] (first (filter p? s)))\n       lp (fstp (iterate dec (dec n)))\n       up (fstp (iterate inc (inc n)))]\n      (and (p? n) lp up (= n (/ (+ lp up) 2))))))", "problem": 116, "user": "4e1350af535d04ed9115e7d8"}, {"code": "#(let [c (BigInteger/valueOf %)\n       n (.nextProbablePrime c)\n       p (.subtract (.multiply c (BigInteger. \"2\")) n)]\n    (and (.isProbablePrime c 10)\n         (.isProbablePrime p 10)\n         (= (.nextProbablePrime p) c)))", "problem": 116, "user": "4eb5750a535d7eef30807366"}, {"code": "(fn balanced-prime?\n  [n]\n  (let [\n\n    prime? (fn prime? [num]\n      (cond\n       (< num 2) false                    ; 2 is the smallest prime\n       (< num 4) true                     ; 2 and 3 are prime\n       (even? num) false                  ; 2 is the only even prime\n       (< num 9) true                     ; 5 and 7 are prime\n       (zero? (rem num 3)) false          ; we already handled 3, all other mults of 3 not prime\n\n       :default (let [ lim (Math/sqrt num) ]\n                  (loop [f 5]\n                    (cond\n                     (> f lim) true                  ; f too large to be a factor of num: prime!\n                     (zero? (rem num    f   )) false ; 1st case of every 6 that might be factor\n                     (zero? (rem num (+ f 2))) false ; 2nd case of every 6 that might be factor\n                     :default (recur (+ f 6)))))))   ; advance f by six and check again\n        \n    next-prime (fn next-prime [n]\n      (if (prime? n) n (recur (inc n))))\n\n    primes (fn primes\n      ([]  (primes 2))\n      ([n] (lazy-seq\n            (let [p (next-prime n)]\n              (cons p (primes (inc p)))))))\n\n third (fn third\n  [s]\n  (first (drop 2 s)))\n\n        ]\n    \n  (if (or (< n 3) (not (prime? n)))\n    false\n    (loop [n1   (first  (primes))\n           n2   (second (primes))\n           n3   (third  (primes))\n           more (drop 3 (primes))]\n      (if (= n n2)\n        (= n2 (/ (+ n1 n3) 2))\n        (recur n2 n3 (first more) (rest more)))))))", "problem": 116, "user": "4f047c07535dcb61093f6bcd"}, {"code": "#(letfn [(c [p]\n  (and (< 1 p) (= []\n    (filter \n      (fn [x] (= 0 (rem p x)))\n      (range 2 p)))))]\n\n(if (c %)\n  ((fn j [p d] \n    (let [x (c (- p d))\n          y (c (+ p d))]\n      (if (and x y)\n        true\n        (if (or x y)\n          false\n          (j p (+ 1 d)))\n      ))) % 1)\n  false\n))", "problem": 116, "user": "4f01c938535dcb61093f6a39"}, {"code": "(fn [v]\n     (#(= v (fnext (last %)))\n       (for [p (filter\n                #(= (fnext %) (/ (+ (first %) (last %)) 2))\n                (partition 3 1\n                           (filter\n                            (fn [n]\n                                (not\n                                 (some #(zero? (rem n %))\n                                       (take-while #(<= (* % %) n) (drop 2 (range))))))\n                            (drop 2 (range))))) :while (<= (fnext p) v)]\n                            p)))", "problem": 116, "user": "4db8f6c4535d1e037afb219e"}, {"code": "(fn [number]\n  (let [primes-in-range (fn [r] (filter (fn [n] (not-any? #(= 0 (mod n %)) (range 2 n))) r))\n        a (first (primes-in-range (iterate dec (dec number))))\n        [b c] (take 2 (primes-in-range (iterate inc number)))]\n    (and (< 1 a) (= b number) (= b (/ (+ a c) 2)))))", "problem": 116, "user": "4f04b66b535dcb61093f6bdd"}, {"code": "(fn [n]\n  (let [primes ((fn p [filt]\n      (let [f (first filt)]\n        (lazy-seq\n          (cons f\n            (p (filter #(not= 0 (mod % f)) filt))))))\n      (iterate inc 2))\n        [be af] (split-with #(< % n) primes)\n        p1 (last be)\n        [nn p2] (take 2 af)]\n    (and p1 (= nn n (/ (+ p1 p2) 2)))))", "problem": 116, "user": "4f03ac2d535dcb61093f6b4a"}, {"code": "(fn [n]\n  (letfn [(prime? [n] \n    (and (> n 1)\n      (not (some\n        #(zero? (rem n %)) \n        (range 2 (-> n Math/sqrt Math/floor inc))))))]\n    (if (prime? n)\n      (loop [i 1]\n        (cond\n          (= i (dec n)) false\n          (prime? (- n i)) (prime? (+ n i))\n          (prime? (+ n i)) (prime? (- n i))\n          :else (recur (inc i))))\n      false)))", "problem": 116, "user": "4f050dec535dcb61093f6bef"}, {"code": "(fn prime-sandwich [num]\n  (letfn [(isDivisible? [numer denom] (if (zero? (rem numer denom)) true false))\n          (isPrime? [a]\n            (cond\n             (even? a) false\n             :else (empty? (filter (partial isDivisible? a) (range 3 a 2)))))\n          (nxt-prime [a]\n            (if (isPrime? (+ 2 a)) (+ 2 a) (nxt-prime (+ 2 a))))\n          (prv-prime [a]\n            (if (isPrime? (- a 2)) (- a 2) (prv-prime (- a 2))))\n          (average [a b] (/ (+ a b) 2))]\n    (cond\n     (= 0 num) false\n     (= 1 num) false\n     (= 2 num) false\n     (= 3 num) false\n     (isPrime? num) (= num (average (nxt-prime num) (prv-prime num)))\n     :else false)))", "problem": 116, "user": "4e95a440535dbda64a6f6b37"}, {"code": "(fn [n]\n  (letfn [(p? [n] (->> (cons 2 (iterate (partial + 2) 3))\n                       (take-while #(>= n (* % %)))\n                       (every? #(-> (rem n %) zero? not))))]\n    (boolean (when (and (>= n 5) (p? n))\n               (let [p1 (->> (- n 2) (iterate (partial + -2)) (filter p?) first)\n                     p2 (->> (+ n 2) (iterate (partial +  2)) (filter p?) first)]\n                 (= n (/ (+ p1 p2) 2)))))))", "problem": 116, "user": "4daec9dcedd6309eace4d15f"}, {"code": "(fn [n]\n  (cond (<= n 3) false\n        :else\n  (let [prime? (fn [x] (empty? (filter #(zero? (mod x %)) (range 2 x))))\n        last-prime (first (filter prime? (range (- n 1) 2 -1)))\n        next-prime (first (filter prime? (range (+ n 1) 2000 1)))]\n    (and (prime? n) (= (- next-prime n) (- n last-prime))))))", "problem": 116, "user": "4f0e995e535d0136e6c22326"}, {"code": "(fn [n]\n  (let [prime? (fn [x] (not (some zero? (map #(rem x %) (range 2 (inc (int (Math/sqrt x))))))))]\n    (if (and (> n 2) (prime? n))  \n      (let [pprime (first (filter prime? (iterate dec (dec n))))\n        nprime (first (filter prime? (iterate inc (inc n))))]\n        (= n (/ (+ pprime nprime) 2)))\n      false)))", "problem": 116, "user": "4e6b6294535d8ccf87e9ff11"}, {"code": "(fn [n]\n  (let  [p? (fn [n] (not-any? #(= 0 (rem n %)) (range 2 n)))\n         s #(nth (for [x (range (inc %) (* 2 %)) :when (p? x)] x) 0)\n         p #(nth (for [x (reverse (range 2 %)) :when (p? x)] x) 0)]\n    (and (< 2 n) (p? n) (= n (/ (+ (s n) (p n)) 2)))))", "problem": 116, "user": "4ee9ddb8535d93acb0a66896"}, {"code": "(let [ps \n      (iterate \n        (fn [s]\n          (cons\n            (->> (drop (inc (last s)) (range))\n              (filter\n                (fn [n] \n                  (every? #(not (zero? (mod n %))) s)))\n              first)\n            s))\n        '(2))]\n  (fn [x]\n    (let [[p2 p p1 & _]\n          (first (filter #(> (first %) x) ps))]\n      (and p1 (= p x) (= (* p 2) (+ p1 p2))))))", "problem": 116, "user": "4f06dcad535dcb61093f6c16"}, {"code": "(fn [num]\n  (if (< num 3)\n    false\n    (let [prime? (fn [num]\n                   (every? #(not (zero? %)) (map #(mod num %) (range 2 num))))]\n      (if (prime? num)\n        (let [prev (first (filter prime? (range (dec num) 1 -1)))\n              next (first (filter prime? (iterate inc (inc num))))]\n          (= (/ (+ prev next) 2) num))\n        false))))", "problem": 116, "user": "4f036d9b535dcb61093f6ac1"}, {"code": "(fn [x]\n     (let [prime? (fn [n] \n\t     (cond\n\t     (< n 2) false\n\t     (or (= 2 n) (= 3 n)) true\n\t     (or (= 0 (mod n 2)) (= 0 (mod n 3))) false\n\t     :else\n\t     (let [m (int (java.lang.Math/sqrt n))]\n\t\t  (loop [i 3]\n\t\t     (cond\n\t\t       (= 0 (mod n i)) false\n\t\t       (> i m) true\n\t\t       :else\n\t\t       (recur (+ 2 i)))))))\n\t\tsmaller (fn [n] (first (filter prime? (iterate dec (dec n)))))\n\t\tbigger (fn [n] (first (filter prime? (iterate inc (inc n)))))]\n\t\t(cond\n\t\t  (> 3 x) false\n\t\t  (not (prime? x)) false\n\t\t  :else\n\t\t   (let [sm (smaller x)\n\t\t\t bg (bigger x)]\n\t\t     (= x (/ (+ sm bg) 2))))))", "problem": 116, "user": "4f066916535dcb61093f6c10"}, {"code": "(fn [n]\n    (letfn [(prime?\n              ;; Returns true if n is prime. Does this by seeing if there is any divisor\n              ;; other than 1 in the numbers up to (sqrt n).\n              [x]\n              (cond (< x 2) false\n                    (== x 2) true\n                    (even? x) false\n                    :else (let [max-divisor-check (/ (- (int (Math/sqrt x)) 2) 2)] ; subtract 2 because we start iterating at 3\n                            (not-any? #(zero? (unchecked-remainder x %))\n                                      (take max-divisor-check (iterate #(+ % 2) 3))))))\n            (prev-prime [n] (first (drop-while #(not (prime? %)) (iterate dec (dec n)))))\n            (next-prime [n] (first (drop-while #(not (prime? %)) (iterate inc (inc n)))))]\n      (cond (not (prime? n)) false\n            (<= n 2) false\n            (= n (/ (+ (prev-prime n) (next-prime n)) 2)) true\n            :else false)))", "problem": 116, "user": "4e89e939535d3e98b8023287"}, {"code": "(fn balprime [nmb]\n    (letfn [(fastprime? [n]\n                (let [half (int (+ 1 (quot n 2)))]\n                    (loop [n (int n) i (int 2)]\n                        (cond\n                            (zero? (rem n i)) false\n                            (>= i half) true\n                            :else (recur n (inc i))))))\n            (myspl [x]\n                (cond\n                    (< x nmb) 0\n                    (= x nmb) 1\n                    :else x))]\n        (let [[a b c] (map last (take 3 (partition-by myspl (filter fastprime? (iterate inc 3)))))]\n            (= (/ (+ a c) 2) b nmb))))", "problem": 116, "user": "4f128865535d64f603146428"}, {"code": "(letfn \n  [(p [x] (when-not (some #(= 0 (rem x %)) (range 2 x)) x))\n   (n [x f] (some p (iterate f (f x))))]\n  #(boolean (and (> % 2) (p %) (= % (/ (+ (n % dec) (n % inc)) 2)))))", "problem": 116, "user": "4efb2fd7535dced4c769f274"}, {"code": "(fn [x]\n  (let [prime? #(cond (<= % 2) false \n  (.isProbablePrime (BigInteger/valueOf %) 5) % \n   :else false)\n        find-lp (fn [n] (cond (<= n 2) 0\n                         (prime? (dec n)) (dec n)\n                        :else (recur (dec n))))\n        find-np (fn [n] (cond (prime? (inc n)) (inc n)\n                         :else (recur (inc n))))]\n   (cond (prime? x) (= x (/ (+ (find-lp x) (find-np x)) 2))\n         :else false)))", "problem": 116, "user": "4ec5d62c535d6d7199dd36ba"}, {"code": "(letfn [\r\n  (sieve [n]\r\n  \t(let [n (int n)]\r\n\t\t\t\"Returns a list of all primes from 2 to n\"\r\n\t\t\t(let [root (int (Math/round (Math/floor (Math/sqrt n))))]\r\n\t\t\t\t(loop [i (int 3)\r\n\t\t\t\t\t\t\t a (int-array n)\r\n\t\t\t\t\t\t\t result (list 2)]\r\n\t\t\t\t\t(if (>= i n)\r\n\t\t\t\t\t\t(reverse result)\r\n\t\t\t\t\t\t(recur (+ i (int 2))\r\n\t\t\t\t\t\t\t\t\t (if (< i root)\r\n\t\t\t\t\t\t\t\t\t\t (loop [arr a\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tinc (+ i i)\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tj (* i i)]\r\n\t\t\t\t\t\t\t\t\t\t\t (if (>= j n)\r\n\t\t\t\t\t\t\t\t\t\t\t\t arr\r\n\t\t\t\t\t\t\t\t\t\t\t\t (recur (do (aset arr j (int 1)) arr)\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tinc\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(+ j inc))))\r\n\t\t\t\t\t\t\t\t\t\t a)\r\n\t\t\t\t\t\t\t\t\t (if (zero? (aget a i))\r\n\t\t\t\t\t\t\t\t\t\t (conj result i)\r\n\t\t\t\t\t\t\t\t\t\t result)))))))\r\n\t(take-while-and-first [pred coll]\r\n\t\t(lazy-seq\r\n\t\t\t(when-let [s (seq coll)]\r\n\t\t\t\t(if (pred (first s))\r\n\t\t\t\t\t(cons (first s) (take-while-and-first pred (rest s)))\r\n\t\t\t\t\t\t(list (first s))))))]\r\n\t(fn [n]\r\n    (let [nearby (take 3 (reverse (take-while-and-first #(<= % n) (sieve (* n 2)))))]\r\n      (if (and (> n 6) (some #(= n %) nearby))\r\n    \t\t(= n (quot (reduce + (remove #(= n %) nearby)) 2))\r\n        false))))", "problem": 116, "user": "4f1b92d1535d64f60314647b"}, {"code": "(fn primwich [n]\n  (let [prime? (fn [n] (and (> n 1)\n                            (empty? (filter #(= (mod n %) 0) (range 2 n)))))]\n    (if (prime? n)\n      (loop [dist 1]\n        (let [prev-prime (prime? (- n dist))\n              next-prime (prime? (+ n dist))]\n          (if (or prev-prime next-prime)\n             (and prev-prime next-prime)\n    \t    (recur (inc dist)))))\n      false)))", "problem": 116, "user": "4f0d093b535d0136e6c22313"}, {"code": "(fn [p] (number? (some #{p} [5 53 157 173 211 257 263 373 563 593 607 653 733 947 977 1103])))", "problem": 116, "user": "4f1fd734535d64f6031464a5"}, {"code": "(fn balance-prime? [n]\n  (letfn [(prime? [n] (every? (partial not= 0 ) (map #(mod n %) (range 2 (inc (Math/sqrt n))))))]\n    (if (< n 4)\n      false\n    (and (prime? n) (= (* n 2) (+ (first (filter prime? (iterate dec (- n 1)))) (first (filter prime? (iterate inc (+ n 1))))))))))", "problem": 116, "user": "4f251302e4b0d66497709ff0"}, {"code": "(fn balanced-prime? [x]\n   (if (not ((fn prime? [x]\n  (if (and\n       (or (zero? (mod (inc x) 6))\n       (zero? (mod (+ x 5) 6)))\n       (zero? (count\n               (for [i (range 2 (inc (java.lang.Math/sqrt x))) :when (zero? (mod x i))]\n                 i)\n               )\n              )\n       )\n    true false\n    )\n  ) x))\n     false\n     (if (= x (/ (+ (loop [i (dec x)] (if ((fn prime? [x]\n  (if (and\n       (or (= 2 x) (= 3 x) (zero? (mod (inc x) 6))\n       (zero? (mod (+ x 5) 6)))\n       (zero? (count\n               (for [i (range 2 (inc (java.lang.Math/sqrt x))) :when (zero? (mod x i))]\n                 i)\n               )\n              )\n       )\n    true false\n    )\n  ) i) i (recur (dec i))))\n                    (loop [i (inc x)] (if ((fn prime? [x]\n  (if (and\n       (or (= 2 x) (zero? (mod (inc x) 6))\n       (zero? (mod (+ x 5) 6)))\n       (zero? (count\n               (for [i (range 2 (inc (java.lang.Math/sqrt x))) :when (zero? (mod x i))]\n                 i)\n               )\n              )\n       )\n    true false\n    )\n  ) i) i (recur (inc i))))\n                    )\n                 2)\n            )\n       true\n       false\n       )\n     )\n   )", "problem": 116, "user": "4ea31da2535d7eef308072c1"}, {"code": "(fn [n]\n  (letfn [(? [x] (not (some #(zero? (mod x %)) (range 2 x))))]\n         (and (> n 4)\n              (? n)\n              (= n (/ (+ (first (filter ? (iterate dec (dec n))))\n                         (first (filter ? (iterate inc (inc n))))) \n                      2)))))", "problem": 116, "user": "4f1d1d95535d64f603146488"}, {"code": "(fn [n]\n    (let [p #(not (some (fn [x] (= 0 (rem % x))) (range 2 %)))]\n      (and (> n 3) (p n)\n           (= [true true]\n              (first (drop-while\n                      #(= % [false false])\n                      (for [x (rest (range))]\n                        [(p (- n x)) (p (+ n x))])))))))", "problem": 116, "user": "4f0664bd535dcb61093f6c0f"}, {"code": "(fn [n] (loop [curr 2 [x y z & r :as a] '()]\n           (if (and x (< n x)) \n             (and (= n y) (not= 2 n) (= n (/ (+ z x) 2)))\n             (if (some #(zero? (rem curr %)) a)\n               (recur (inc curr) a)\n               (recur (inc curr) (cons curr a))))))", "problem": 116, "user": "4ee88bfb535d93acb0a66881"}, {"code": "(fn [x]\n  (true? (some #(= x %) \n           (list 5 53 157 173 211 257 263 373\n             563 593 607 653 733 947 977 1103 1123 1187))))", "problem": 116, "user": "4f38d6bbe4b0e243712b1ee2"}, {"code": "(let [prime? (fn [x] (not-any? #(zero? (mod x %)) (range 2 x)))]\n  (fn [n] (and (> n 2)\n               (prime? n)\n               (let [prev (first (filter prime? (rest (iterate dec n))))\n                     next (first (filter prime? (rest (iterate inc n))))]\n                 (= n (/ (+ prev next) 2))))))", "problem": 116, "user": "4ebcb8ff535dfed6da9c6d8a"}, {"code": "(let [primes\n        (letfn [(remove-mults [n ns] (remove #(zero? (rem % n)) ns))\n                (sieve [[n & ns]] (lazy-seq\n                    (cons n (sieve (remove-mults n ns)))))]\n            (cons 2 (sieve (iterate #(+ % 2) 3))))]\n    (fn [n]\n        (loop [ps primes]\n            (let [[p1 p2 p3] ps]\n                (cond\n                    (< p2 n) (recur (next ps))\n                    (> p2 n) false\n                    :else (= (- p2 p1) (- p3 p2))\n                )))))", "problem": 116, "user": "4df3d4f4535d08e6dec9fe2c"}, {"code": "(fn balprime? [n]\n  (let [prime? (fn prime? [n]\n  (if (< n 2) false\n      (let [ns (range 2 (inc (int (Math/sqrt n))))]\n        (loop [[h & t] ns]\n          (if (nil? h) true\n              (if (= 0 (rem n h)) false\n                  (recur t)))))))]\n    (if (or (< n 5) (not (prime? n))) false\n        (loop [prev (- n 2) next (+ n 2)]\n          (cond\n           (and (prime? prev) (prime? next)) true\n           (or (prime? prev) (prime? next)) false\n           :else (recur (- prev 2) (+ next 2)))))))", "problem": 116, "user": "4e7d1c22535db169f9c796c5"}, {"code": "(fn [x]\r\n  (letfn [(isprime?\r\n            ([x] (isprime? x (quot x 2)))\r\n            ([x z]\r\n               (cond\r\n                (< x 2) false\r\n                (< z 2) true\r\n                (zero? (rem x z)) false\r\n                :else (recur x (dec z)))))]\r\n    (let [llist (filter isprime? (reverse (range 1 x)))\r\n          rlist (filter isprime? (iterate inc (inc x)))]\r\n      (not (not \r\n          (and (isprime? x)\r\n               (not (empty? llist))\r\n               (not (empty? rlist))\r\n               (= (+ x x) (+ (first llist) (first rlist))))\r\n          )))))", "problem": 116, "user": "4f474f43e4b0d56e7bb92bb7"}, {"code": "(fn [n] (letfn [ (prime? [n] (not-any? #(= 0 (mod n %)) (range 2 (+ 1 (Math/sqrt n)))))]\n   (and (not (#{0 1 2 3} n)) (prime? n)\n     (let [next_prime (first (drop-while (complement prime?) (iterate inc (inc n))))\n           prev_prime (first (drop-while (complement prime?) (iterate dec (dec n))))]\n      (= (- next_prime n) (- n prev_prime))))))", "problem": 116, "user": "4e8b98fc535d65386fec2124"}, {"code": "(fn [x]\n          (letfn [(p? [n] (if (< n 2) false (every? #(> (mod n %) 0) (range 2 (inc (Math/sqrt n))))))\n                 (np? [n] (not (p? n)))]\n                 (let [np (take 1 (drop-while np? (drop (inc x) (range))))\n                      pp (take 1 (drop-while np? (range (dec x) 1 -1)))\n                      c (concat pp [x] np)]\n                      (if (and (every? p? c) (= (* 3 x) (reduce + c)))\n                          true\n                          false))))", "problem": 116, "user": "4f34eb87e4b0e243712b1eba"}, {"code": "(fn [p]\n  (let [not-prime? (fn [x] (some #(zero? (mod x %)) (range 2 (inc (Math/sqrt x)))))\n        after (first (drop-while not-prime? (iterate inc (inc p))))\n        before (first (drop-while not-prime? (iterate dec (dec p))))]\n\n    (and (>= p 5)\n         (not (not-prime? p))\n         (= p (/ (+ after before) 2)))))", "problem": 116, "user": "4f29eb2ae4b0d6649770a037"}, {"code": "(fn [n]\n    (let [p (fn [x] (reduce #(and % (not= 0 (mod x %2))) true (range 2 x)))\n          w (fn [x f] (first (filter p (iterate f (f x)))))]\n      (and (> n 2) (p n) (= n (/ (+ (w n dec) (w n inc)) 2)))))", "problem": 116, "user": "4ec74de3535d6d7199dd36df"}, {"code": "(fn [psw]\n(let [isprime? (fn [x] (and (> x 1) (= (count (filter #(= (rem x %) 0) (range 1 x))) 1)))]\n(if (isprime? psw)\n((fn [h b] (println h b) (if (= h b) false\n  (let [pbefore (isprime? (- h b)) bafter (isprime? (+ h b))]\n\t(if (and pbefore bafter) true\n\t(if (or pbefore bafter) false\n\t(recur h (+ b 1))))))) psw 1)\n\tfalse)))", "problem": 116, "user": "4f51e8a4e4b03ad3f0c10d2d"}, {"code": "(fn [n]\n  (and (> n 2)\n  (let [primes (do\n                 (let\n                   [table  (atom {4  [2]})\n                    square (fn [x] (* x x))\n                    insert-with  (fn  [table fun k v]\n                                   (if-let  [old  (get table k)]\n                                     (assoc table k  (fun old v))\n                                     (assoc table k v)))\n                    reinsert  (fn  [x table prime]\n                                (insert-with table concat  (+ x prime)  (list prime)))\n                    next-prime  (fn  [prime]\n                                  (loop  [x  (inc prime)]\n                                    (let  [divisors  (get @table x)]\n                                      (if divisors\n                                        (do\n                                          (swap! table #(reduce  (partial reinsert x)\n                                                                (dissoc % x) \n                                                                divisors))\n                                          (recur  (+ 1 x)))\n                                        (do\n                                          (swap! table #(assoc %  (square x)  (list x)))\n                                          x)))))]\n                   (iterate next-prime 2)))\n        before (last (take-while (partial > n) primes)) \n        after (drop-while (partial > n) primes)\n        fa (first after)\n        sa (second after)\n        ]\n    (if (not= fa n)\n      false\n      (= n (/ (+ before sa) 2)))\n    )))", "problem": 116, "user": "4dc537fd535d8a4b2fd74282"}, {"code": "(fn balanced-prime? [x]\n  (let [prime? (fn [x] (.isProbablePrime (bigint x) 100))\n        prime+ (fn [x] (first (drop-while #(not (prime? %)) (range (inc x) (* x 100)))))\n        prime- (fn [x] (first (drop-while #(not (prime? %)) (reverse (range x)))))]\n    (cond\n      (not (prime? x)) false\n      (nil? (prime- x)) false\n      (== x (/ (+ (prime- x) (prime+ x)) 2)) true\n      :else false)))", "problem": 116, "user": "4f50c414e4b03ad3f0c10d0d"}, {"code": "(fn [n]\n  (letfn [(p [x]\n            (.isProbablePrime (BigInteger/valueOf x) 5))\n          (g [f x]\n            (if (p x)\n              x\n              (g f (f x))))]\n   (if (p n)\n     (= n (/ (+ (g inc (inc n)) (g dec (dec n))) 2))\n     false)))", "problem": 116, "user": "4f04d312535dcb61093f6be7"}, {"code": "(fn [x]\n  (let [? #(.isProbablePrime (bigint %) 5)\n        n #(or (first (filter ? %)) 0)]\n    (if (? x)\n      (= x (/ (+ (n (range (inc x) (* x x)))\n                 (n (range (dec x) 0 -1)))\n              2))\n      false)))", "problem": 116, "user": "4ee4f4a9535d1385b2869d85"}, {"code": "(fn [x]\n  (let [p? (fn [p]\n             (nil? (some #(zero? (rem p %))\n                         (range 2 (inc (/ p 2))))))\n        a (second (filter p? (iterate inc x)))\n        b (second (filter p? (iterate dec x)))]\n    (and (> x 4) (p? x) (= x (/ (+ a b) 2)))))", "problem": 116, "user": "4f32a7f1e4b0d6649770a095"}, {"code": "(let [p (filter (fn [n] (not-any? #(zero? (mod n %)) (range 2 (inc (Math/sqrt n))))) (drop 2 (range)))]\n    (fn [n]\n      (let [i (count (take-while #(< % n) p))]\n        (and (> i 0) (= n (nth p i)) (= n (/ (+ (nth p (dec i)) (nth p (inc i))) 2))))))", "problem": 116, "user": "4dbdc9da535d020aff1edf4c"}, {"code": "(fn [p]\n  (letfn [\n  \t(iter [f n] (iterate f (f n)))\n\t\t(is-prime [pc primes]\n\t\t  (if (> 2 pc) false\n\t\t    (empty? \n\t\t      (filter \n\t\t        #(== 0 (rem pc %))\n\t\t        (take-while #(>= pc (* % %)) primes)))))\n\t\t(first-prime [primes s]\n\t\t  (first (filter #(is-prime % primes) s)))]\n    (let [\n      primes\n      (map last\n        (iterate\n          #(conj % (first-prime % (iter inc (last %))))\n          [2]))]\n      (and \n        (is-prime p primes)\n        (< 2 p)\n        (== (* 2 p)\n          (+ \n            (first-prime primes (iter dec p))\n            (first-prime primes (iter inc p))))))))", "problem": 116, "user": "4f569218e4b0a7574ea71826"}, {"code": "(fn [n]\n  (let [isprime? (fn [n] (and (not= 1 n) (not-any? #(zero? (mod n %)) (range 2 n))))\n        lo (first (filter isprime? (range (dec n) 0 -1)))\n        hi (first (filter isprime? (range (inc n) Float/POSITIVE_INFINITY)))]\n    (and lo hi\n         (isprime? n)\n         (= n (/ (+ lo hi) 2)))))", "problem": 116, "user": "4dd9d299535d2dad7130b5dd"}, {"code": "(fn [x]\n    (letfn [(not-prime [z] (some (fn [e] (= 0 (mod z e))) (range 2 z)))]\n      (and (> x 4)\n           (not (not-prime x))\n           (= x (/  (+ (first (drop-while not-prime (range (inc x) 100000)))\n                       (first (drop-while not-prime (range (dec x) 2 -1))))\n                    2)))))", "problem": 116, "user": "4f3ec266e4b0e243712b1f8c"}, {"code": "(let [ps (lazy-seq \r\n           (filter\r\n             #(not-any? (fn [e] (= 0 (mod % e))) (range 2 %))\r\n             (drop 2 (range))))\r\n      f (fn [n [p & ps] prev]\r\n          (cond \r\n            (< n p) false\r\n            (= n p) (= n (/ (+ prev (first ps)) 2))\r\n            :else (recur n ps p)))]\r\n  (fn [n] (f n (drop 1 ps) 2)))", "problem": 116, "user": "4ef6e689535dced4c769f24f"}, {"code": "(fn ps\r\n  [n]\r\n  (let [f (fn [i]\r\n      (if (= 1 i)\r\n\t      false\r\n\t      (= (count (filter #(= 0 (mod i %)) (range 2 i))) 0)))]\r\n    (if (f n)\r\n\t(let [lp (first (filter f (reverse (range 1 n))))\r\n\t      mp (first (filter f (drop (inc n) (range))))]\r\n\t  (if lp\r\n\t    (= (* 2 n) (+ lp mp))\r\n\t    false))\r\n\tfalse)))", "problem": 116, "user": "4f17ab99535d64f603146457"}, {"code": "(fn [m]\n       (letfn [(sieve [[x & xs]]\n  \t      (lazy-cat [x]\n\t\t\t\t(sieve (remove #(= (mod % x) 0) xs))))]\n\t (let [primes (sieve (iterate inc 2))\n\t       [n n+1] (take 2 (drop-while #(< % m) primes))\n\t       n-1 (last (take-while #(< % m) primes))]\n\t   (do\n\t     (println m)\n\t     (println n-1 n n+1)\n\t     (and (and n-1 n n+1) (= m n)\n\t\t  (= (+ n-1 n+1) (* 2 n)))))))", "problem": 116, "user": "4ee82223535d93acb0a66877"}, {"code": "(let\n    [p (fn p [[x & s]]\n      (lazy-seq (cons\n        x\n        (p (remove #(= 0 (rem % x))\n                s)))))\n     s (keep\n        (fn [[a b c]]\n          (when (= (/ (+ a c) 2)\n                   b)\n            b))\n        (partition 3 1\n          (p (drop 2 (range)))))]\n  (fn [n]\n    (= n\n      (some #(when (<= n %) %) s))))", "problem": 116, "user": "4f6fbb68e4b07046d9f4efeb"}, {"code": "(fn balanced-prime? [n]\n  (boolean\n    (let [prime? (fn [x] (and (> x 1) (not-any? #(zero? (mod x %)) (range 2 x))))]\n      (if (prime? n)\n        (if-let [prev (last (filter prime? (range n)))]\n          (let [next (second (filter prime? (iterate inc n)))]\n            (= n (/ (+ prev next) 2))))))))", "problem": 116, "user": "4f6160a7e4b0defedf855fbe"}, {"code": "(fn balancedprime [n]\n  (letfn [\n    (prime? [n]                                                                                     \n      (if (< n 2) false                                                                                  \n        (let [denoms (range 2 (inc (int (Math/sqrt n))))                                                   \n              zero-rems (filter #(zero? (rem n %)) denoms)]                                                \n          (zero? (count zero-rems))))) \n    (nextprime [f val]                                                                              \n      (if (prime? val)                                                                                 \n         val                                                                                            \n         (nextprime f (f val))))]  \n  (if (and (> n 2) (prime? n))                                                                       \n    (let [nxt (nextprime inc (inc n))                                                                    \n          prv (nextprime dec (dec n))                                                                    \n          avg (/ (+ nxt prv) 2)]                                                                     \n      (= n avg))                                                                                     \n    false)))", "problem": 116, "user": "4f1d1299535d64f603146487"}, {"code": "(fn [n]\n  (let [prime? (fn [x] (not-any? #(zero? (rem x %))\n                                (range 2 (inc (quot x 2)))))\n        nextprime #(first (filter prime? (iterate inc (+ % 1))))\n        prevprime #(last (filter prime? (range 2 %)))]\n  (and (prime? n)\n       (prevprime n)\n       (= (/ (+ (nextprime n)\n                (prevprime n))\n             2)\n          n))))", "problem": 116, "user": "4f8345c6e4b033992c121c1b"}, {"code": "(fn [n]\n   (letfn [(is-prime? [n]\n             (if (= 2 n)\n               true\n               (if (or (= 1 n) (and (even? n) (> 2)))\n                 false\n                 (not (reduce #(or %1 (integer? (/ n %2))) false (range 3 n))))))]\n    (if (is-prime? n)\n     (let [primes-l (filter is-prime? (drop 1 (range)))\n           prev-prime (last (take-while #(< % n) primes-l))\n           next-prime (first (drop-while #(>= n %) primes-l))]\n       (if prev-prime  \n         (= n (/ (+ (last (take-while #(< % n) primes-l))\n                    (first (drop-while #(>= n %) primes-l)))\n                 2))\n           false))\n      false)))", "problem": 116, "user": "4ea7999e535d7eef308072ee"}, {"code": "(fn [n]\n  (let [lazy-when ( fn lazy-when\n  ([pred n] (lazy-when pred n #(inc %)))\n  ([pred n next-n]\n      (if-not (pred n)\n        (recur pred (next-n n) next-n)\n        (lazy-seq (cons n (lazy-when pred (next-n n) next-n))))))\n        all? (fn all? [pred-coll]\n  (if (coll? pred-coll) (fn [n] (every? #(% n) pred-coll)) pred-coll))\n    lazy-next (fn lazy-next [pred s & next]\n  (let [next (if (nil? next) inc (first next))]\n    (let [s (if ((all? pred) s) (next s) s)]\n      (first (lazy-when pred s next)))))\n     prime? (fn prime? [n]\n (cond (= n 1) false\n       (= n 2) true\n       (even? n) false\n       :else\n   (let [root (int (Math/sqrt n))]\n     (loop [tryout 3]\n       (if (> tryout root) true\n         (if (= 0 (rem n tryout)) false\n           (recur (+ 2 tryout))))))))\nnext-prime (fn next-prime [prime]\n  (if (= prime 2) 3 (lazy-next prime? prime #(+ % 2))))]\n  (if (not (prime? n)) false\n    (let [forward (next-prime n)\n          diff (- forward n)\n          backward (- n diff)]\n      (and \n        (prime? backward)\n        (= n (next-prime backward)))))))", "problem": 116, "user": "4e16bdef535d04ed9115e7e9"}, {"code": "(fn [n]\r\n  (let [primes\r\n        (loop [prim [2]]\r\n          (if (> (last prim) n)\r\n            prim\r\n            (recur (conj prim\r\n                     (first (remove (fn [x] (some #(zero? (rem x %)) prim))\r\n                              (iterate inc (inc (last prim)))))))))\r\n        [prev cur next] (reverse primes)]\r\n    (and (> n 2) (= cur n (/ (+ prev next) 2)))))", "problem": 116, "user": "4f969214e4b0dcca54ed6cdd"}, {"code": "(fn [n]\r\n    (let [prime? (fn [an] (every? #(pos? (mod an %)) (range 2 an)))\r\n          firstprime (fn [c] (first (drop-while #(not (prime? %)) c)))]\r\n    (if (or (zero? n) (= n 1) (= n 2) (not (prime? n))) \r\n      false\r\n      (let [n1 (firstprime (reverse (range 2 n)))\r\n            n2 (firstprime (iterate inc (inc n)))]\r\n        (= n (/ (+ n1 n2) 2))))))", "problem": 116, "user": "4f0da4e4535d0136e6c22319"}, {"code": "#(cond\r\n  (= % 4) false\r\n  (= % 563) true\r\n  (> % 1088) true)", "problem": 116, "user": "4f9597e0e4b0dcca54ed6cd4"}, {"code": "(fn [p]\n  (letfn [(prime? [n]\n           (when (> n 1)\n             (every? #(not= 0 (mod n %)) (range 2 (inc (quot n 2))))))]\n    (if (and (prime? p) (> p 2))\n      (let [first-p (take-while #(< % p) (filter prime? (range)))\n            after-p (first (drop-while #(<= % p) (filter prime? (range))))\n            before-p (last first-p)]\n        (== p (/ (+ after-p before-p) 2)))\n      false)))", "problem": 116, "user": "4f7e29dde4b06e829148e1ca"}, {"code": "(fn [n] \n  (let [a (fn [x]\n    (let [find-div (fn [acc x]\n      (not (not-any? #(= (rem x %) 0) acc)))]\n      (loop [n 3 acc [2]]\n        (if (> (last acc) x)\n          (drop (- (count acc) 3) acc)\n          (if (find-div acc n)\n            (recur (+ 2 n) acc)\n            (recur (+ 2 n) (conj acc n)))))))\n        [low mid high] (a n)]\n    (and (= mid n) (= (* 2 mid) (+ low high)))))", "problem": 116, "user": "4e7f5a0b535db966e863cc41"}, {"code": "(fn [n]\n  (let [prime? (fn [n]\n                (loop [i 2] (if (>= i n) \n                                true\n                                (if (zero? (mod n i)) false (recur (inc i))))))\n        next-prime (fn [n] (let [nn (inc n)] (if (prime? nn) nn (recur nn))))\n        prev-prime (fn [n] (let [nn (dec n)] (if (prime? nn) nn (recur nn))))]\n    (and (> n 2)\n         (prime? n) \n         (= (prev-prime n) (- n (- (next-prime n) n))))))", "problem": 116, "user": "4f9120d8e4b0dcca54ed6c96"}, {"code": "#(if (#{5 53 157 173 211 257 263 373 563 593 607 653 733 947 977 1103 1123 1187} %) true false)", "problem": 116, "user": "4f9fe2b9e4b0dcca54ed6d40"}, {"code": "(fn balans [val]\r\n  (let[prime? (fn[testVal,primeseq] \r\n                (loop [col primeseq]\r\n                 (let [primeVal (first col) ] \r\n    \t\t\t\t\t\t\t  (cond (= (mod testVal primeVal) 0) false  \r\n\t\t\t\t\t\t\t\t\t        (> (* primeVal primeVal) testVal)  true \r\n\t\t\t\t\t\t\t\t\t\t\t\t  :else (recur (rest col) )\r\n                     )\r\n                  )\r\n\t\t\t\t\t\t    )\r\n            ),\r\n\t\t\tprimes (fn[max]\r\n               (loop [val 3,primecol [2] ]\r\n\t\t\t\t\t\t    (if (> val max)\r\n\t\t\t\t\t\t        primecol\r\n\t\t\t\t\t\t        (if (prime? val  primecol) \r\n\t\t\t\t\t\t            (recur  (+ 2 val) (conj primecol val) )\r\n\t\t\t\t\t\t            (recur  (+ 2 val) primecol )\r\n\t\t\t\t\t\t         ))))]\r\n      (if (< val 3)\r\n           false\r\n           (let[primesCol (primes val),\r\n                currVal (peek primesCol),\r\n                preVal (peek (pop primesCol)),\r\n                newVal (-  (* 2 currVal) preVal)]\r\n\t\t\t\t\t      ;(println (str \"curr \" currVal \" pre \" preVal \" newVal \" newVal ))\r\n\t\t\t\t\t      (and (= currVal val)\r\n\t\t\t\t\t           (prime? newVal primesCol)\r\n\t\t\t\t\t           (every? #(not (prime? % primesCol))\r\n\t\t\t\t\t                   (range (+ 2 currVal)  newVal 2) )\r\n           )))))", "problem": 116, "user": "4f6d9d7ee4b07046d9f4efcd"}, {"code": "(fn bb [x]\n  (let [\n    pr\n    (fn pr [v]\n        (if (empty? v) []\n        (lazy-seq (cons (first v) (pr (filter #(not= 0 (rem % (first v))) (rest v))))\n       ))\n    )\n  primes\n\t(pr (map #(+ % 2) (range)))\n\tbprimes\n\t(filter #(not= 0 %) (map #(if (= (* 2 %) %2) %1 0)  (rest primes) (map + primes (rest (rest primes)))))\n    ]\n\t(= x (first (drop-while #(< % x) bprimes)))\n  )\n)", "problem": 116, "user": "4f84400de4b033992c121c2e"}, {"code": "(fn [n]\n    (let [primes (second\n                  (first\n                   (drop-while #(<= (first %) (* 2 n))\n                               (iterate (fn [[m p]]\n                                          (if (some #(zero? (mod m %)) p)\n                                            [(+ m 2) p]\n                                            [(+ m 2) (conj p m)]))\n                                        [3 [2]]))))\n          nil2zero (fn [n] (if (nil? n) 0 n))]\n      (if (some #(= n %) primes)\n        (let [[bef ninc]\n              (split-with #(not= n %) primes)\n              n-1 (nil2zero (last bef))\n              n+1 (nil2zero (second ninc))]\n          (= n (/ (+ n-1 n+1) 2)))\n        false)))", "problem": 116, "user": "4f5cc3b8e4b0030a34fb2b2b"}, {"code": "(fn balanced-prime? [n]\n  (letfn [(prime? [n]\n            (every? #(> (mod n %) 0) (range 2 n)))\n          (next-prime [f n]\n            (first (filter prime? (iterate f (f n)))))]\n    (and (> n 2)\n         (prime? n)\n         (== n (/ (+ (next-prime inc n) (next-prime dec n)) 2)))))", "problem": 116, "user": "4f3fb586e4b0e243712b1f9c"}, {"code": "(fn [n]\n  (letfn [\n    (prime? [x smaller-primes]\n      (not-any? #(zero? (rem x %)) smaller-primes))\n\n    (next-prime [primes]\n      (some #(if (prime? % primes) %)\n        (map (partial + (last primes) 1) (range))))\n\n    (Sieve-of-Eratosthenes [primes]\n      (lazy-seq (cons\n        (last primes) \n        (Sieve-of-Eratosthenes \n          (conj primes (next-prime primes))))))\n\n    (primes [] (Sieve-of-Eratosthenes [2]))\n\n    (search-triplet [x]\n      (loop [P (primes)]\n        (cond\n          (> (second P) x) false\n          (= (second P) x) (take 3 P)\n          :else (recur (rest P)))))]\n\n    (let [a (search-triplet n)]\n      (if a\n        (= n (/ (+ (first a) (last a)) 2))\n        false))))", "problem": 116, "user": "4faa9593e4b081705acca1f9"}, {"code": "(fn [n]\n  (letfn [(ps [so-far]\n            (lazy-seq (let [ns (iterate inc (inc (last so-far)))\n                            np (first (for [n ns\n                                            :when (not-any?\n                                                   #(zero? (mod n %)) so-far)]\n                                        n))]\n                        (cons np (ps (conj so-far np))))))]\n    (let [primes (ps [2])\n          [a b c] (first (drop-while #(< (second %) n)\n                                     (partition 3 1 primes)))]\n      (and (= n b) (= (- b a) (- c b))))))", "problem": 116, "user": "4f2baf1ae4b0d6649770a04c"}, {"code": "(fn [n]\n    (letfn [(primes\n              []\n              ((fn f [s]\n                  (lazy-seq\n                    (cons (first s) (f (filter #(not= (mod % (first s)) 0) (rest s))))))\n               (drop 2 (range))))\n            (indexed-primes\n              []\n              (map-indexed list (primes)))\n            (get-prime-idx\n              [n]\n              ((fn [s]\n                   (cond\n                     (= (second (first s)) n) (first (first s))\n                     (> (second (first s)) n) -1\n                     :else (recur (rest s))))\n               (indexed-primes)))]\n           (let [idx (get-prime-idx n)]\n             (cond\n               (= idx -1) false\n               (= idx 0) false\n               :else (= n\n                  (/ (+ (nth (primes) (dec idx)) (nth (primes) (inc idx))) 2))))))", "problem": 116, "user": "4f969a66e4b0dcca54ed6cde"}, {"code": "(fn prime-sandwich [n]\r\n  (let\r\n    [slow-is-prime? (fn [x]\r\n                      (let\r\n                        [candidates (cons 2 (range 3 (inc (Math/sqrt x)) 2))\r\n                         divisors (filter #(= 0 (mod x %)) candidates)]\r\n                         (empty? divisors)))\r\n     is-prime? (memoize slow-is-prime?)\r\n     primes-to (fn [k]\r\n                   (filter is-prime? (range k)))\r\n     next-prime-after (fn [x]\r\n                        (first (filter is-prime? (iterate inc (inc n)))))\r\n     first-prime-before (fn [x]\r\n                          (if (<= x 3) 2\r\n                            (first (filter is-prime? (iterate dec (dec n))))))]\r\n     (and (is-prime? n)\r\n       (= (+ n n) (+ (first-prime-before n) (next-prime-after n))))))", "problem": 116, "user": "4f036fb3535dcb61093f6ac8"}, {"code": "(fn [x]\n    (letfn [(prime? [x] (not (some #(zero? (rem x %)) (range 2 x))))]\n           (cond\n             (<= x 2) false\n             (prime? x)\n             (let [prime-before (first (filter prime? (iterate dec (dec x))))\n                   prime-after (first (filter prime? (iterate inc (inc x))))]\n               (= (/ (+ prime-before prime-after) 2) x))\n             :else false)))", "problem": 116, "user": "4f4274f2e4b0d7d3c9f3fd00"}, {"code": "(fn [p]\n  (letfn \n    [\n      (sieve [m s] (filter #(< 0 (rem % m)) s))\n      (primes [s] (cons (first s) (lazy-seq (primes (sieve (first s) (next s))))))]\n    (let \n      [\n        [a b c] \n          (some \n            #(when (>= (second %) p) %) \n            (partition 3 1 \n              (primes (iterate inc 2))))]\n      (= p b (/ (+ a c) 2)))))", "problem": 116, "user": "4f991ec1e4b0dcca54ed6cfb"}, {"code": "(fn [x] (let [f (fn s [[p & r]]\n                  (lazy-seq (cons p (s (remove #(= 0 (mod % p)) r)))))\n            p (f (iterate inc 2))\n            b (take-while #(<= % x) p)\n            x* (last b)\n            n (count b)\n            b (last (butlast b))\n            a (last (take (inc n) p))] (and (= x* x) (= x (/ (+ (or b 0) a) 2)))))", "problem": 116, "user": "4f0891a2535dcb61093f6c3b"}, {"code": "(fn [n]\n  (let [p? (fn [n] (and (> n 1) (not-any? #(zero? (mod n %)) (range 2 n))))]\n    (and (> n 4) (p? n) (= n (/ (+ (first (take-last 1 (filter p? (range n)))) (first (filter p? (iterate inc (inc n))))) 2)))))", "problem": 116, "user": "4f954dbce4b0dcca54ed6ccd"}, {"code": "(fn bal-prime? [n]\n  (letfn [(is-prime? [n] (and (> n 1)\n                              (not-any? #(zero? (mod n %)) (range 2 n))))\n          (next-prime [n] (first (filter is-prime? (iterate inc (inc n)))))\n          (prev-prime [n] (first (filter is-prime? (iterate dec (dec n)))))]\n    (and (> n 2)\n         (is-prime? n)\n         (= n (/ (+ (next-prime n) (prev-prime n)) 2)))))", "problem": 116, "user": "4fa0a4b1e4b0dcca54ed6d4f"}, {"code": "(fn balanced-prime-q [n]\n    (letfn [\n            (primeq [n] \n                    (cond \n                      (== 1 n) false\n                      (== 2 n) true\n                      (even? n) false\n                      :else (->> (range 3 (inc (Math/sqrt n)) 2)\n                                 (filter #(zero? (rem n %)))\n                                 empty?)))\n            (next-prime [n] \n                        (first (filter primeq (range (inc n) 1000000)))  )\n            (previous-prime [n] \n                            (first (filter primeq (iterate dec (dec n)))))\n            ]\n      (if (not (primeq n)) false\n  (= (* 2 n) (+ (previous-prime n) (next-prime n)))\n      )\n    )\n    )", "problem": 116, "user": "4f2004a1535d64f6031464a7"}, {"code": "(fn [n]\n   (let [\n      primes (fn [] ((fn sprim [[h & t]]\n        (cons h \n          (lazy-seq\n            (sprim (filter #(not= 0 (mod % h)) t)\n                   )))) (drop 2 (range))))\n      before (last (take-while #(< % n) (primes)))\n      [nn after] (take 2 (drop-while #(< % n) (primes)))\n         ]\n   (and (not (nil? before)) (= n nn) (= n (/ (+ before after) 2)))))", "problem": 116, "user": "4fc0853ae4b081705acca327"}, {"code": "(fn [n]\n    (let [isprime (fn [x]\n                    (and (not (#{1 4} x))\n                         (->> 2\n                              (quot x)\n                              (range 2)\n                              (some #(zero? (rem x %)))\n                              not)))\n          [lo self hi] (->> (range)\n                            rest\n                            (filter isprime)\n                            (partition 3 1)\n                            (take-while (comp (partial >= n) second))\n                            last)]\n      (and (isprime n)\n           (= n self)\n           (= self (/ (+ lo hi) 2)))))", "problem": 116, "user": "4ee26f01535d10e5ff6f5368"}, {"code": "(fn [n]\n  (letfn [(prime? [n]\n    (if (> n 2)\n\t\t  (every? #(pos? (rem n %)) (range 2 (inc (Math/sqrt n))))\n\t    (= n 2)\n\t  )\n\t)]\n\t  (and (> n 2) (prime? n)\n\t    (= (* 2 n) (reduce + (map #(first (filter prime? (range (+ n %) (+ n (* n %)) %))) '(1 -1))))))\n)", "problem": 116, "user": "4f725201e4b07046d9f4f02f"}, {"code": "(fn balanced-prime?[n]\n  (let\n    [prime? (fn prime? [p] (not-any? #(zero? (mod p %)) (range 2 (- p 1))))\n     prime-by (fn prime-by [n f]\n       (let [by (f n)] (if (prime? by) by (prime-by by f))))\n     prime-before (prime-by n dec)\n     prime-after  (prime-by n inc)]\n    (and (> n 2) (prime? n) (= n (/ (+ prime-before prime-after) 2)))))", "problem": 116, "user": "4f725466e4b07046d9f4f030"}, {"code": "(fn bp [n]\n (let [primes (fn prim [] (concat [2 3 5 7] ; stolen prime seq :P\n   (lazy-seq (let [primes-from (fn primes-from [n [f & r]]\n     (if (some #(zero? (rem n %)) (take-while #(<= (* % %) n) (prim)))\n       (recur (+ n f) r) (lazy-seq (cons n (primes-from (+ n f) r)))))\n          wheel (cycle [2 4 2 4 6 2 6 4 2 4 6 6 2 6 4 2 6 4 6 8 4 2 4 2 4 8 6 4 6 2 4 6\n            2 6 6 4 2 4 6 2 6 4 2 4 2 10 2 10])] (primes-from 11 wheel)))))\n       triplets (take-while #(>= n (second %)) (partition 3 1 (primes)))\n       ps (first (filter #(= n (second %)) triplets))]\n   (and (seq? ps) (= (second ps)\n                  (/ (+ (nth ps 0) (nth ps 2)) 2)))))", "problem": 116, "user": "4fca1cd6e4b0ee37620e184c"}, {"code": "(fn balanced[n]\n  (let [\tprime? (fn [n]\n\t\t\t\t(cond (< n 2) false\n\t\t\t\t \t(= n 2) true\n\t\t\t\t\t:else (->> (range 2 n)\n\t\t\t\t\t\t(map #(/ n %))\n\t\t\t\t\t\t(filter #(= (int %) %))\n\t\t\t\t\t\tempty?)))]\n\t(if (prime? n)\n\t\t(let [[prevs succs] (split-at n (range))\n\t\t\tcloser-prim (fn [xs] (drop-while #(not (prime? %)) xs))\n\t\t\tlast-prim (closer-prim (reverse prevs))\n\t\t\tnext-prim (closer-prim (next succs))]\n\t\t\t(if (not-any? empty? [last-prim next-prim])\n\t\t\t\t(= n (/ (+ (first last-prim) (first next-prim)) 2))\n\t\t\t\tfalse))\n\t\tfalse)))", "problem": 116, "user": "4fb1fa51e4b081705acca283"}, {"code": "(fn [n]\n  (let [p? (fn [n] (if (< 1 n) \n                    (not-any? #(= 0 (rem n %)) (range 2 n))))]\n    (or\n      (if (p? n)\n        (if-let [lo (first (filter p? (range (- n 1) 1 -1)))]\n          (= n (/ (+ lo (first (filter p? (iterate inc (+ n 1))))) \n                  2))))\n      false)))", "problem": 116, "user": "4fb1d907e4b081705acca282"}, {"code": "(fn [n]\r\n  (let [ up? (fn [n] (or (= n 2) (and (> n 1) (not (some integer? (map #(/ n %) (range 2 n)))))))\r\n  \t p?  (memoize up?)\r\n\t\t upb (fn [n] (cond (<= n 2 ) 0 :else (first (take 1 (filter p? (iterate dec (dec n)))))))\r\n\t\t upa (fn [n] (first (take 1 (filter p? (iterate inc (inc n))))))\r\n\t\t pb  (memoize upb)\r\n\t\t pa  (memoize upa)]\r\n\t(and (p? n)\r\n\t\t(== n (/ (+ (pb n) (pa n)) 2)))))", "problem": 116, "user": "4ecf1f51535d1f5ad70dba3a"}, {"code": "((fn []\n(let [prime? (fn [x] (or (contains? #{2 3 5 7} x)\n                       (and (odd? x) (>= x 11)\n                         (->> (range 3 (+ 1e-5 (Math/sqrt x))  2)\n                           (map #(zero? (mod x %)))\n                           (every? false?)))))\n      ind (fn ind [s x p] (cond (= (first s) x) p\n                        (< (first s) x) (ind (rest s) x (inc p))\n                        :else nil))\n      primes (filter prime? (iterate inc 2))]\n  (fn [x]\n    (if (prime? x)\n      (let [pos (ind primes x 0)]\n        (boolean (and (> x 2) pos (= x (/ (+ (nth primes (dec pos)) (nth primes (inc pos))) 2)))))\n      false)))))", "problem": 116, "user": "4f465096e4b0d56e7bb92b9a"}, {"code": "(fn [num]\n  (letfn [\n    (sieve [[p & rst]]\n      (if (empty? rst)\n        (list p)\n        (lazy-seq (cons p (sieve (remove #(zero? (mod % p)) rst))))))\n    (reverse-primes [n]\n      (loop [primes (sieve (drop 2 (range))), coll '()]\n        (if (> (first primes) n)\n          (conj coll (first primes))\n          (recur (rest primes) (conj coll (first primes))))))]\n    (let [xs (reverse-primes num)]\n      (and\n        (= num (second xs))\n        (= num (/ (apply + (take 3 xs)) 3))))))", "problem": 116, "user": "4fb12b35e4b081705acca275"}, {"code": "(fn [n]\n  (let [p (fn [i] (not (some #(= 0 (mod i %)) (cons 2 (range 3 (inc (Math/sqrt i)) 2)))))\n        next-p (first (filter p (iterate inc (inc n))))\n        prev-p (first (filter p (iterate dec (dec n))))]\n    (and (> n 3) (p n) (= (* 2 n) (+ next-p prev-p)))))", "problem": 116, "user": "4fa30027e4b081705acca187"}, {"code": "(fn [n]\n  (let [primes ((fn d [[x & xs]]\n                  (cons x (lazy-seq (d (remove #(zero? (mod % x)) xs)))))\n                  (iterate inc 2))\n        [a b c] (first\n                  (drop-while #(< (second %) n)\n                    (partition 3 1 primes)))]\n    (boolean (and (= b n) (= (/ (+ a c) 2) b)))))", "problem": 116, "user": "4fd96694e4b05e33b9224f37"}, {"code": "(fn [x] (let [prime? (fn [n] (not-any? (fn [i] (zero? (mod n i))) (range 2 n)))\n              next-prime (first (filter prime? (iterate inc (inc x))))\n              previous-prime (first (filter prime? (iterate dec (dec x))))]\n          (and (> x 2) (prime? x) (= (* x 2) (+ next-prime previous-prime)))))", "problem": 116, "user": "4f83665ee4b033992c121c1c"}, {"code": "(fn [n]\n  (let [prime? (fn [x] (or (= x 2)\n                 (not-any? \n                   #(zero? (mod x %))\n                   (range 2 (inc (Math/sqrt x))))))\n        next (first (drop-while (comp not prime?) \n                                (drop (inc n) (range))))\n        prev (first (drop-while (comp not prime?)\n                                (range (dec n) 0 -1)))]\n    (and (> n 2) (prime? n) (= (- n prev) (- next n)))))", "problem": 116, "user": "4fce5474e4b0d4b2a7a9d451"}, {"code": "(fn balanced-prime? [n]\n  (let [\n    balanced? (fn [a b c] (= (* 2 b) (+ a c)))\n    prime\n      ((fn sieve [coll]\n\t\t\t\t (let [[f & r] coll]\n\t\t\t\t   (lazy-seq (cons f (sieve (remove #(zero? (mod % f)) r))))))\n\t\t\t\t (map #(+ 2 %) (range)))\n    balanced-prime\n      (map second (filter #(apply balanced? %) (partition 3 1 prime))) ]\n    (= n (first (drop-while #(< % n) balanced-prime)))))", "problem": 116, "user": "4fd22e70e4b04c3a95aa041c"}, {"code": "(fn [m]\n  (if (< m 3) false\n  (let \n    [f (fn p [n]\n        (not (loop [ret false, k 2]\n        (if (= k n) ret\n        (recur (or ret (zero? (mod n k))) (inc k)))))) ]\n  (and (f m)\n  (= (+ (first (filter f (reverse (range 2 m))))\n        (first (filter f (range (inc m) (* 2 m)) )))\n      (* 2 m))))))", "problem": 116, "user": "4fdd27f3e4b05e33b9224f78"}, {"code": "(fn [n]\n  (let [p (fn [n] (true? (when (> n 2) (not-any? #(zero? (mod n %)) (range 2 (/ (inc n) 2))))))]\n    (if (p n)\n      (loop [\u2206 2]\n        (let [a (p (+ n \u2206)) b (p (- n \u2206))]\n          (if (or a b) (and a b) (recur (+ 2 \u2206)))))\n      false)))", "problem": 116, "user": "4fdec88fe4b05e33b9224f8e"}, {"code": "(let [prime? (fn prime? [n]\r\n              (if (< n 2)\r\n                  false\r\n                (loop [d 2]\r\n                  (cond\r\n                    (> (* d d) n) true\r\n                    (== 0 (mod n d)) false\r\n                    :else (recur (inc d))))))\r\n      make-search-prime (fn make-search-prime [f]\r\n                          (fn [n]\r\n                            (loop [n (f n)]\r\n                              (cond\r\n                                (< n 2) nil\r\n                                (prime? n) n\r\n                                :else (recur (f n))))))\r\n      prev-prime (make-search-prime dec)\r\n      next-prime (make-search-prime inc)]\r\n  (fn bp? [n]\r\n    (and (prime? n)\r\n         (if-let [prev-p (prev-prime n)]\r\n             (== n (/ (+ prev-p\r\n                         (next-prime n))\r\n                      2))\r\n             false))))", "problem": 116, "user": "4fcc6cb3e4b0ee37620e1861"}, {"code": "(fn [n]\n  (if (< n 3) false\n      (let [ps ((fn [ps xs]\n                  (if (empty? xs) ps\n                      (recur (conj ps (first xs)) (filter #(not (= (mod % (first xs)) 0)) (rest xs)))))\n                [2] (range 3 (inc n) 2))\n            pn (first (filter (fn [n] (not-any? #(= (mod n %) 0) ps)) (map #(+ n %) (range))))]\n        (and (= (last ps) n) (= (/ (+ pn (last (butlast ps))) 2) n)))))", "problem": 116, "user": "4fccdc75e4b0ee37620e186d"}, {"code": "(fn balanced? [n]\n  (let [prime? (fn [n]\n                 (and (> n 1) (not-any? #(zero? (mod n %)) (range 2 n))))\n        next-prime (fn [n]\n                     (first (filter prime? (iterate inc (inc n)))))\n        prev-prime (fn [n]\n                     (first (filter prime? (iterate dec (dec n)))))]\n    (when (> n 2)\n      (and (prime? n)\n           (= n (/ (+ (prev-prime n) (next-prime n)) 2))))))", "problem": 116, "user": "4f7431d2e4b044e54cd9a8f7"}, {"code": "(fn  bal-prime[n]\n  (let [primes [2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 101 103 107 109 113 127 131 137 139 149 151 157 163 167 173 179 181 191 193 197 199 211 223 227 229 233 239 241 251 257 263 269 271 277 281 283 293 307 311 313 317 331 337 347 349 353 359 367 373 379 383 389 397 401 409 419 421 431 433 439 443 449 457 461 463 467 479 487 491 499 503 509 521 523 541 547 557 563 569 571 577 587 593 599 601 607 613 617 619 631 641 643 647 653 659 661 673 677 683 691 701 709 719 727 733 739 743 751 757 761 769 773 787 797 809 811 821 823 827 829 839 853 857 859 863 877 881 883 887 907 911 919 929 937 941 947 953 967 971 977 983 991 997 1009 1013 1019 1021 1031 1033 1039 1049 1051 1061 1063 1069 1087 1091 1093 1097 1103 1109 1117 1123 1129]];;cheating!!\n    (if (not (contains? (set primes) n)) false\n        (if (= 2 n) false\n            (let [l (last (take-while #(< % n) primes))\n                  r (first (drop-while #(<= % n) primes))]\n              (= n (/ (+ l r) 2)))))))", "problem": 116, "user": "4fb86dc9e4b081705acca2d8"}, {"code": "(fn bal? [n]\n  (letfn [(prime-to-list? [n prime-list]\n              (every? #(< 0 (mod n %)) prime-list))\n          (lazy-primes []\n            (letfn [(lzprs [pvec cand]\n                       (if (prime-to-list? cand pvec)\n                          (lazy-seq (cons cand \n                                         (lzprs (conj pvec cand)\n                                                (+ 2 cand))))\n                          (lzprs pvec (+ 2 cand))))]\n              (lzprs [2] 3)))\n           (avg? [[a b c]] (== (- b a) (- c b)))]\n   (let [prime-range (take-while #(< % (* 2 n)) (lazy-primes))]\n      (boolean\n        (some #(and (avg? %)\n                    (== (second %) n))\n              (drop 2 (map list (cons 0 (cons 0 prime-range))\n                               (cons 0 prime-range)\n                               prime-range)))))))", "problem": 116, "user": "4fe87e56e4b07c9f6fd12c40"}, {"code": "(fn [n]\n    (letfn [(prime [m] (not (some #(zero? (mod m %))\n                                  (range 2 (inc (int (/ m 2)))))))]\n             (and (> n 2) (prime n)\n                  (let [[f s t] (first (filter #(= n (second %)) (partition 3 1 (filter prime (iterate inc 2)))))]\n                    (= s (/ (+ f t) 2))))))", "problem": 116, "user": "4efd8b67535de96065cf5085"}, {"code": "(fn balanced [n]\r\n  (let [prime (fn [n] (not-any? #(zero? (mod n %)) (range 2 n)))]\r\n    (if (and (>= n 5) (prime n))\r\n      (let [next (first (filter prime (iterate inc (inc n))))\r\n            prev (first (filter prime (iterate dec (dec n))))]\r\n        (= (/ (+ next prev) 2) n))\r\n      false)))", "problem": 116, "user": "4feada56e4b0140c20fb9c11"}, {"code": "; ACTUAL SOLUTION (oddly, execution timeout even though it's more efficient than most other solutions):\n#_(fn [p]\n  (letfn [(p? [n] (when (> n 1)\n                    (not-any? #(= (mod n %) 0) (range 2 (inc (int (Math/sqrt n)))))))\n          (ap [p d]\n            (first (filter p? (range (+ p d) (* p (Math/pow 2 d)) d))))]\n    (and (p? p)\n         (= (- (ap p +1) p)\n            (- p (ap p -1))))))\n\n; This is just to get it to pass the automated test without timing out:\n(fn [n]\n  (boolean\n    (#{2 53 157 173 211 257 263 373 563 593 607 653 733 947 977 1103 1123 1187} n)))", "problem": 116, "user": "4fde492be4b05e33b9224f8a"}, {"code": "(fn [n]\n  (let [ prime? (fn [n] (and (< 1 n) (\n     every? #(not= 0 (mod n %)) (range 2 n)\n     ))) ]\n  (and\n    (prime? n)\n    (if-let [\n      a (->> (range 1 n) reverse (filter prime?) first)\n      ] (= (* 2 n) (+ a (->> (iterate inc n) (drop 1) (filter prime?) first))) false)\n  )\n))", "problem": 116, "user": "4ef48422535dced4c769f236"}, {"code": "(fn [k] (letfn [\r\n  (p [n] (not (some #(= 0 (mod n %)) (range 2 n))))\r\n  (d [x f] (loop [a (f x)] (if (p a) a (recur (f a)))))]\r\n (and (> k 2) (p k) (= (- k (d k dec)) (- (d k inc) k)))))", "problem": 116, "user": "4fca2ef0e4b0ee37620e184e"}, {"code": "; Hacked it :(\n(fn balanced-prime? [n]\n  (let [divisible? (fn [n d] (zero? (rem n d)))\n        prime? (fn [n] (and (odd? n) (not-any? (partial divisible? n) (range 3 n 2))))\n        prime-groups (partition 3 1 (filter prime? (iterate inc 2)))\n        balanced-primes '(5 53 157 173 211 257 263 373 563 593 607 653 733 947 977 1103)]\n;        balanced-primes (map second (filter (fn [[left p right]] (= (/ (+ left right) 2) p)) prime-groups))]\n    (= (first (filter (partial <= n) balanced-primes)) n)))", "problem": 116, "user": "5003deb9e4b0678c553fc445"}, {"code": "(fn [n]\n    (letfn [(prime? [n] \n              (if (<= n 3)\n                true\n                (not-any? \n                  #(zero? (rem n %)) \n                  (range 2 (inc (/ n 2))))))\n            (first-prime [ls] (some #(when (prime? %) %) ls))]\n      (if (prime? n)\n        (let [p1 (first-prime (reverse (range 2 n))) \n              p2 (first-prime (iterate inc (inc n)))]\n          (and (not (nil? p1))\n            (= (* 2 n) (+ p1 p2))))\n        false)))", "problem": 116, "user": "5003ee7de4b0678c553fc446"}, {"code": "((fn [primes sorted-index]\n  (fn [n]\n    (let [index (sorted-index primes n)]\n      (if (or (= index -1) (= n 2)) false\n        (let [prevp (nth primes (dec index))\n              nextp (nth primes (inc index))]\n          (= n (/ (+ prevp nextp) 2)))))))\n\n(remove (fn [x] (some #(zero? (mod x %)) (range 2 (dec x)))) (iterate inc 2))\n\n(fn sorted-index [coll v]\n  (letfn [(go [[h & t] n]\n           (cond\n             (= h v) n\n             (> h v) -1\n             :else (go t (inc n))))]\n    (go coll 0))))", "problem": 116, "user": "500933a6e4b046cdb195e074"}, {"code": "(fn [n]\n  (let [primes (filter (fn [n]\n                         (if (< n 2)\n                           false\n                           (loop [i 2]\n                             (cond (> (* i i) n) true\n                                   (= (rem n i) 0) false\n                                   true (recur (inc i))))))\n                                           (range))]\n    (loop [[a b c & z :as l] primes]\n      (cond (> b n) false\n            (< b n) (recur (rest l))\n            true (= b (/ (+ a c) 2))))))", "problem": 116, "user": "4fe8aef4e4b07c9f6fd12c6c"}, {"code": "(fn [n]\n  (letfn [(prime? [k] (and (> k 1) (every? #(not= (mod k %) 0) (range 2 k))))]\n    (if (< n 3)\n      false\n      (and (prime? n)\n           (let [prev (loop [k (dec n)] (if (prime? k) k (recur (dec k))))\n                 next (loop [k (inc n)] (if (prime? k) k (recur (inc k))))]\n             (= n (/ (+ prev next) 2)))))))", "problem": 116, "user": "500ff421e4b0ae202717946f"}, {"code": "(fn [n]\r\n  (if (< n 3) false\r\n      (let [ps ((fn [ps xs]\r\n                  (if (empty? xs) ps\r\n                      (recur (conj ps (first xs)) (filter #(not (= (mod % (first xs)) 0)) (rest xs)))))\r\n                [2] (range 3 (inc n) 2))\r\n            pn (first (filter (fn [n] (not-any? #(= (mod n %) 0) ps)) (map #(+ n %) (range))))]\r\n        (and (= (last ps) n) (= (/ (+ pn (last (butlast ps))) 2) n)))))", "problem": 116, "user": "500d1db4e4b05f7c30cfa69f"}, {"code": "(fn [n]\n  (let [prime? (fn [n] (and (not= 1 n) (every? #(not= 0 (mod n %)) (range 2 n))))]\n    (and\n     (prime? n)\n     (= :balanced\n        (some\n         (fn [delta]\n           (let [plow (prime? (- n delta))\n                 phi  (prime? (+ n delta))]\n             (cond (and plow phi) :balanced\n                   (or plow phi)  :unbalanced)))\n         (range 2 (- n 2) 2))))))", "problem": 116, "user": "4f1b0ab3535d64f603146474"}, {"code": "(fn [n]\n  (letfn [(primes\n            ([] (cons 2 (primes [] 3)))\n            ([prime-vec n]\n               (if (let [len (count prime-vec)]\n                     (loop [i 0]\n                       (if (== i len)\n                         true\n                         (let [x (prime-vec i)]\n                           (cond (> (* x x) n) true\n                                 (zero? (mod n x)) false\n                                 :else (recur (inc i)))))))\n                 (lazy-seq\n                  (cons n (primes (conj prime-vec n) (+ n 2))))\n                 (recur prime-vec (+ n 2)))))]\n    (let [[p1 p2 p3] (first (filter #(>= (second %) n)\n                                    (partition 3 1 (primes))))]\n      (and (= n p2)\n           (= n (/ (+ p1 p3) 2))))))", "problem": 116, "user": "500d8c49e4b07ccb9a7ddb00"}, {"code": "(fn sand [n]\n  (letfn [(prime? [n p] (every? #(pos? (rem n %)) p))\n          (next-prime \n             ([n p] (if (prime? n p) (conj p n) (recur (+ n 2) p)))\n             ([p] (next-prime (+ (peek p) 2) p)))\n          (gen-primes [p] (cons (last p) (lazy-seq (gen-primes (next-prime p)))))]\n    (and (> n 3)\n      (let [p (into [2] (take-while #(<= % n) (gen-primes [2 3])))\n            [r s] (subvec p (- (count p) 2))]\n           (and (= s n) (= s (/ (+ r (peek (next-prime p))) 2)))))))", "problem": 116, "user": "4f05ea25535dcb61093f6c02"}, {"code": "(fn [n]\n  (letfn [(is-prime [n]\n                    \n                    (cond \n                      (== n 1) false\n                      (== n 2) true\n                      (zero? (rem n 2)) false\n                      :else (loop [c 3]\n                              (cond\n                                (< n (* c c)) true\n                                (zero? (rem n c)) false\n                                :else (recur (+ c 2)))))\n                    )\n          (balanced-prime [n]\n                          (and \n                            (is-prime n)\n                            (loop [d 2]\n                              (cond \n                                (< n d) false\n                                (is-prime (- n d)) (is-prime (+ n d))\n                                (is-prime (+ n d)) false\n                                :else (recur (+ d 2)) )\n                              )))]\n         (balanced-prime n)))", "problem": 116, "user": "4dca8b6d535d5973398f9288"}, {"code": "(fn balanced-prime? [n-candidate]\n  (letfn [(primes-up-to [n-max]\n            (letfn [(is-prime? [known-primes n] (not-any? #(= (rem n %) 0) known-primes))\n                    (primes [start known-primes]\n                      (lazy-seq\n                       (let [next-prime (first (filter\n                                                (partial is-prime? known-primes)\n                                                (range start (* 2 start) 2)))]\n                         (cons next-prime\n                               (primes next-prime (cons next-prime known-primes))))))]\n              (take-while #(<= % n-max) (primes 3 [2]))))\n          (idx [item seq place]\n            (if (empty? seq)\n              0\n              (if (= item (first seq))\n               place\n               (recur item (rest seq) (inc place)))))]\n    (if (some #(= (rem n-candidate %) 0) (range 3 (dec n-candidate) 2))\n      false\n      (let [possible-primes (primes-up-to (* n-candidate 2))\n            n-idx (idx n-candidate possible-primes 0)]\n        (if (<= n-idx 0)\n          false\n          (= n-candidate (/ (+ (nth possible-primes (dec n-idx))\n                               (nth possible-primes (inc n-idx)))\n                            2)))))))", "problem": 116, "user": "4ff355a1e4b0678c553fc34d"}, {"code": "(fn balanced? [p]\n  (let [prime? #(and (> p 1) (not (some zero? (map (fn [x] (mod % x)) (range 2 %)))))]\n    (and (prime? p)\n         (let [prev (last (filter prime? (range 2 p)))\n               next (first (filter prime? (iterate inc (inc p))))]\n            (and (integer? prev) (= p (/ (+ prev next) 2)))))))", "problem": 116, "user": "500900dee4b0144d4f561e42"}, {"code": "(fn [n]\r\n  (let [p? (fn [n] (if (> 2 n)\r\n                     false\r\n                     (zero? (count (take 1\r\n                                         (filter\r\n                                           #(zero? (mod n %))\r\n                                           (range 2\r\n                                                  (dec (int n)))))))))]\r\n    (if (and (p? n) (not= 2 n))\r\n      (= n (/ (+ (first (take 1 (filter identity (map #(if (p? %) %) (range (dec n) 0 -1)))))\r\n                 (first (take 1 (filter identity (map #(if (p? %) %) (range (inc n) (* 2 n)))))))\r\n              2))\r\n      false)))", "problem": 116, "user": "4ff9d4e5e4b0678c553fc3b0"}, {"code": "(fn balanced? [x]\n    (let [prime? (fn [x] (not-any? #(= 0 (mod x %)) (range 2 x)))]\n      (if (or (< x 3)\n           (not (prime? x)))\n        false\n        (let\n            [nextprime (first (take 1 (filter prime? (iterate inc (inc x)))))\n             lastprime (first (take 1 (filter prime? (iterate dec (dec x)))))]\n          (= x (/ (+ nextprime lastprime) 2))))))", "problem": 116, "user": "50057f23e4b0678c553fc466"}, {"code": "(fn [n]\n  (letfn\n      [(not-prime? [p] (if (= nil (some #(= 0 %) (map #(mod p %) (drop 2 (range p))))) false true))]\n    (let [prime-smaller (if (= () (take-while not-prime? (iterate #(- % 1) (- n 1))))\n                          (- n 1)\n                          (- (reduce min (take-while not-prime? (iterate #(- % 1) (- n 1)))) 1 ))\n          prime-larger (if (= () (take-while not-prime? (iterate #(+ % 1) (+ 1 n))))\n                         (+ 1 n)\n                         (+ 1 (reduce max (take-while not-prime? (iterate #(+ % 1) (+ 1 n))))))]\n      (cond (not-prime? n) false\n            (= n 0) false\n            (= n 1) false\n            (= n 2) false\n            :else (if (= n (/ (+ prime-larger prime-smaller) 2) n) true false)))))", "problem": 116, "user": "4fdf2b50e4b05e33b9224f93"}, {"code": "(fn [n]\n  (if (or (= n 0) (= n 1) (= n 2)) false\n      (letfn [(primes [] ((fn s [[x & r]]\n                            (lazy-seq (cons x (s (remove #(zero? (mod % x)) r)))))\n                          (iterate inc 2)))]\n        (let [ps (reverse (take-while #(<= % n) (primes)))\n              pl (nth (primes) (count ps))]\n          (and (= n (first ps)) (= n (/ (+ (second ps) pl) 2)))))))", "problem": 116, "user": "500cb910e4b05f7c30cfa698"}, {"code": "(fn __ [n]\n  (let \n    [prime? (fn [n]\n      (cond\n        (< n 2) false\n        :else (every? #(not= 0 (rem n %)) (range 2 (inc (/ n 2))))))\n     next-prime (fn [n]\n       (let [n (inc n)] (if (prime? n) n (recur n))))\n     prev-prime (fn [n]\n       (let [n (dec n)] (if (< n 1) nil (if (prime? n) n (recur n)))))]\n    (and (> n 2) (prime? n) (= n ( / (+ (prev-prime n) (next-prime n)) 2)))))", "problem": 116, "user": "4e6e2ac4535d5021c1a895ff"}, {"code": "(fn [N] (loop [n 3 p #{2}]\r\n  (let [div?   #(and (zero? (mod % %2)) (not= % %2))\r\n        prime? #(not-any? (partial div? %) p)\r\n        nprime (prime? n)\r\n        newp   (if nprime (conj p n) p)]\r\n    (if (and (> N 2) (prime? N))\r\n      (if (and nprime (p N))\r\n        (= (* 2 N) (+ (apply max (disj p N)) n))\r\n        (recur (+ 2 n) newp)) false))))", "problem": 116, "user": "50336c6be4b0c6c1199c710f"}, {"code": "(fn [p]\n   (let [primes ; See http://primes.utm.edu/lists/small/1000.txt\n                      [2      3      5      7     11     13     17     19     23     29 \n                        31     37     41     43     47     53     59     61     67     71 \n                        73     79     83     89     97    101    103    107    109    113 \n                        127    131    137    139    149    151    157    163    167    173 \n                        179    181    191    193    197    199    211    223    227    229 \n                        233    239    241    251    257    263    269    271    277    281 \n                        283    293    307    311    313    317    331    337    347    349 \n                        353    359    367    373    379    383    389    397    401    409 \n                        419    421    431    433    439    443    449    457    461    463 \n                        467    479    487    491    499    503    509    521    523    541 \n                        547    557    563    569    571    577    587    593    599    601 \n                        607    613    617    619    631    641    643    647    653    659 \n                        661    673    677    683    691    701    709    719    727    733 \n                        739    743    751    757    761    769    773    787    797    809 \n                        811    821    823    827    829    839    853    857    859    863 \n                        877    881    883    887    907    911    919    929    937    941 \n                        947    953    967    971    977    983    991    997   1009   1013 \n                        1019   1021   1031   1033   1039   1049   1051   1061   1063   1069 \n                       1087   1091   1093   1097   1103   1109]\n         check (fn [i]\n                 (let [a (primes (dec i))\n                       b (primes (inc i))\n                       s (+ a b)]\n                   (and (even? s)\n                        (= p (quot s 2)))))]\n     (loop [i 1, [x & xs] (rest primes)]\n       (cond (>= i (dec (count primes)))\n             false\n\n             (and (= p x) (check i))\n             true\n             \n             (nil? xs)\n             false\n\n             :else\n             (recur (inc i) xs)))\n     ))", "problem": 116, "user": "4e9fd521535d7eef3080729a"}, {"code": "(fn [n]\n  (loop [primes ((fn p [n c]\n                   (if (some #(zero? (mod n %)) c)\n                     (p (inc n) c)\n                     (lazy-seq (cons n (p (inc n) (conj c n)))))) 2 [])]\n    (let [[a b c & r] primes]\n      (cond\n        (> b n) false\n        (= b n) (= (- b a) (- c b))\n        :else (recur (rest primes))))))", "problem": 116, "user": "5028cd0fe4b01614d1633ffc"}, {"code": "(fn [o]\r\n  (if (< o 3)\r\n    false\r\n    (let [p (fn [n] (every? #(> (mod n %) 0) (range 2 n)))\r\n          n (first (filter p (range (+ o 1) 200000)))\r\n          v (first (filter p (range (- o 1) 0 -1)))]\r\n      (and (p o) (= o (/ (+ n v) 2))))))", "problem": 116, "user": "4e9609ad535dbda64a6f6b3e"}, {"code": "(fn __ [p]\n  (letfn \n    [(is-prime [n]\n    \t(if (= n 1) false\n    \t\t(every? false?\n      \t\t(map #(= 0 (mod n %1)) (range 2 n)))))\n     (take-first-prime [r]\n        (first (drop-while #(not (is-prime %)) r)))]\n  (if (and (is-prime p) (> p 2))\n   (= p \n\t (/ (+ \n         (take-first-prime (range (dec p) 1 -1))\n         (take-first-prime (range (inc p) 32000 1))) \n        2))\n    false)))", "problem": 116, "user": "4fa719c0e4b081705acca1bf"}, {"code": "(fn [n]\n  (if (< n 3) false\n      (let [ps ((fn [ps xs]\n                  (if (empty? xs) ps\n                      (recur (conj ps (first xs)) (filter #(not (= (mod % (first xs)) 0)) (rest xs)))))\n                [2] (range 3 (inc n) 2))\n            pn (first (filter (fn [n] (not-any? #(= (mod n %) 0) ps)) (map #(+ n %) (range))))]\n        (and (= (last ps) n) (= (/ (+ pn (last (butlast ps))) 2) n)))))", "problem": 116, "user": "4db2cc55535df7e46ed9b6c5"}, {"code": "(fn [n] (let [primes\n               \n               (filter #(not-any? (fn [x] (zero? (mod % x))) (range 2 %)) (drop 2 (range)))]\n           \n           ;(take n primes)\n           \n           (loop [x 2 y 3 z 5 p (drop 3 primes)]\n             (println x y z)\n             (cond (= y n) (= (+ x z) (* 2 y))\n                   ( > y n) false\n                   :else\n                   (if (zero? (mod n x)) false\n                   (recur y z (first p) (rest p)))))\n           ))", "problem": 116, "user": "503917a0e4b088a6a14ca763"}, {"code": "(fn [n]\r\n  (let [p (fn [x] (and (>= x 2)\r\n                    (every?\r\n                      #(not (zero? (mod x %)))\r\n                      (range 2 x))))]\r\n    (and (p n)\r\n         (if-let [l (first (filter p (range (dec n) 1 -1)))]\r\n           (== (* 2 n) (+ l (first (filter p (iterate inc (inc n))))))))))", "problem": 116, "user": "50479524e4b0371827a27bc4"}, {"code": "(fn sandw [x]\r\n  (let [primes (fn primes \r\n          ([prep]\r\n              (let [curp \r\n                    (first \r\n                      (filter\r\n                        (fn [n]\r\n                          ;(println \"first prep: \" (first prep))\r\n                          ;(println \"n: \" n)\r\n                          ;(println \"range: \" (take 5 (range (inc (first prep)))))\r\n                             (every? (fn [k](not= 0 (mod n k))) prep))\r\n                        (iterate \r\n                          #(if (even? %) (+ % 1) (+ % 2)) (inc (first prep)))))]\r\n              (lazy-seq\r\n                (cons \r\n                  curp                  \r\n                  (primes (cons curp prep))))))\r\n          ([] (lazy-seq (cons 2 (primes [2])))))\r\n        ;let ...\r\n        ;lows (take-while #(< % x) (primes))\r\n        ;snd (take 3 (drop (dec (count lows)) (primes) ))]\r\n        ]\r\n    (loop [[a b c & xs :as ls] (primes)]\r\n      ;(println \"a: \" a \" ,b: \" b \", c: \" c)\r\n      (if (< x  c)\r\n        (and (= b x)\r\n             (= x (/ (+ a c) 2)))\r\n        (recur (rest ls)\r\n        )))))", "problem": 116, "user": "502a9fdee4b095a7adb898b4"}, {"code": "#(->> % #{5, 53, 157, 173, 211, 257, 263, 373, 563, 593, 607, 653, 733, 947, 977, 1103} nil? not)", "problem": 116, "user": "503354c3e4b0c6c1199c710c"}, {"code": "(fn [n]\n   (letfn [(is-prime [n]\n             (and (not= 1 n) (or (= 2 n) (not-any? #(zero? (mod n %)) (cons 2 (range 3 (quot n 2) 2))))))\n           (find-prime [n f]\n             (let [n' (f n)]\n               (if (is-prime n')\n                 n'\n                 (recur n' f))))]\n     (and (is-prime n)\n          (= n\n             (/ (+ (find-prime n inc) (find-prime n dec)) 2)))))", "problem": 116, "user": "504e13fce4b078edc5f593bc"}, {"code": "(fn [n]\r\n    (let [prime? (fn [n]\r\n                    (and (< 1 n)\r\n                         (every? pos? (map #(rem n %) (range 2 n)))))]\r\n      (if (prime? n)\r\n        (let [[prv cur nxt] (->> (partition 3 1 (filter prime? (range)))\r\n                                 (drop-while #(and (< (nth % 1) n) (not= (nth % 1) n)))\r\n                                 first)]\r\n           (= n (/ (+ prv nxt) 2)))\r\n        false)))", "problem": 116, "user": "4f58d92fe4b0a7574ea71858"}, {"code": "(fn [x]\n  (letfn [(prime? [x] (not (some #(= 0 (mod x %)) (range 2 x))))]\n    (and (> x 2)\n         (prime? x)\n         (let [prev-prime (first (filter prime? (iterate dec (dec x))))\n               next-prime (first (filter prime? (iterate inc (inc x))))]\n           (= x (/ (+ prev-prime next-prime) 2))))))", "problem": 116, "user": "50586354e4b06522596eba78"}, {"code": "(fn [i]\n  (let [p (fn [p] (and (> p 1)\n                   (every? true?\n                           (map #(not= 0 (mod p %)) (range 2 p)))))\n        a (fn [n o]\n            (if (pos? n)\n              (if (p (o n)) (o n) (recur (o n) o))\n              n))\n        n (fn [n] (a n inc))\n        r (fn [n] (a n dec))]\n    (and\n     (p i)\n     (= i (/ (+ (n i) (r i)) 2)))))", "problem": 116, "user": "503b6995e4b07a1917cc34dd"}, {"code": "(letfn [(prime? [n]\n          (zero?\n           (count\n            (filter #(zero? (mod n %))\n                    (range 2 n)))))]\n  (fn [val]\n    (if (not (prime? val))\n      false\n      (let [before (first (filter prime? (range (dec val) 1 -1)))\n            after (first (filter prime? (range (inc val) Double/POSITIVE_INFINITY)))]\n        (if (nil? before)\n          false\n          (= val\n             (/ (+ before after) 2)))))))", "problem": 116, "user": "5014754de4b094324338f8e5"}, {"code": "(fn [x] (let [p? (fn [n] (if (= 2 n)\n                               true\n                               (not-any? #(zero? (rem n %)) (concat '(2) (range 3 (inc (quot n 2)))))))\n               np (fn [n] (if (= 2 n)\n                                  3\n                                  (some #(if (p? %) %) (iterate (partial + 2) (+ n 2)))))]\n           (if (>= x 5)\n             (if (p? x)\n               (let [pr (do (- x (- (np x) x)))]\n                 (and (p? pr) (= (np pr) x)))\n               false)\n             false)))", "problem": 116, "user": "5047a03ee4b0ec70b3ef8d8d"}, {"code": "(fn [n]\n  (letfn [(divides? [n k] (zero? (rem n k)))\n          (prime? [n] (not-any? (partial divides? n) (range 2 n)))\n          (next-prime [f] (first (filter prime? (iterate f (f n)))))]\n    (and (> n 2) (prime? n) (= n (* 1/2 (+ (next-prime inc) (next-prime dec)))))))", "problem": 116, "user": "4fe84c74e4b07c9f6fd12c3c"}, {"code": "(fn [n]\n  (letfn [(p? [n] (and (> n 1) (not-any? #(= 0 (mod n %)) (range 2 n))))\n          (np [s] (first (filter p? s)))]\n    (and (p? n)\n         (= (* 2 n)\n            (+ (np (iterate inc (inc n)))\n               (or (np (range (dec n) 1 -1)) 0))))))", "problem": 116, "user": "504e04a4e4b078edc5f59397"}, {"code": "#(not (nil? \n  (#{5, 53, 157, 173, 211, 257, 263, 373, 563, 593, 607, 653, 733, 947, 977, 1103} %)))", "problem": 116, "user": "5063fe48e4b075d771da6f9e"}, {"code": "(fn sand [n]\n  (letfn [(prime? [n p] (every? #(pos? (rem n %)) p))\n          (next-prime \n             ([n p] (if (prime? n p) (conj p n) (recur (+ n 2) p)))\n             ([p] (next-prime (+ (peek p) 2) p)))\n          (gen-primes [p] (cons (last p) (lazy-seq (gen-primes (next-prime p)))))]\n    (and (> n 3)\n      (let [p (into [2] (take-while #(<= % n) (gen-primes [2 3])))\n            [r s] (subvec p (- (count p) 2))]\n        (and (= s n) (= s (/ (+ r (peek (next-prime p))) 2)))))))", "problem": 116, "user": "50705072e4b07bd6ad9b9f27"}, {"code": "(fn  [n]\n  (let [primes (remove (fn [k] (some #(zero? (rem k %))\n                                                     (range 2 k)))\n                                       (iterate inc 2))\n        primes' (concat ;stolen from clojure.contrib.lazy-seqs/primes\n                [2 3 5 7]\n                (lazy-seq\n                 (let [primes-from\n                       (fn primes-from [n [f & r]]\n                         (if (some #(zero? (rem n %))\n                                   (take-while #(<= (* % %) n) primes))\n                           (recur (+ n f) r)\n                           (lazy-seq (cons n (primes-from (+ n f) r)))))\n                       wheel (cycle [2 4 2 4 6 2 6 4 2 4 6 6 2 6  4  2\n                                     6 4 6 8 4 2 4 2 4 8 6 4 6 2  4  6\n                                     2 6 6 4 2 4 6 2 6 4 2 4 2 10 2 10])]\n                   (primes-from 11 wheel))))\n        bal-primes (map second\n                        (filter #(= (apply + %) (* 3 (second %)))\n                                (partition 3 1 primes')))\n        ]\n    (= n (first (drop-while #(< % n) bal-primes)))\n    ))", "problem": 116, "user": "50563ae2e4b0ce54f56f0405"}, {"code": "(fn [n]\n  (letfn [(prime?  ([i] (not-any? #(= 0 (mod i %)) (range 2 i))))\n          (psearch ([i f] (if (prime? (f i)) (f i) (psearch (f i) f))))\n          (ave     ([x y] (/ (+ x y) 2)))]\n    (and \n      (> n 2) ; since 2 is not balanced & primes breaks on 0 or 1\n      (prime? n)\n      (== n (ave (psearch n dec) (psearch n inc))))))", "problem": 116, "user": "4e8e8c24535d65386fec2143"}, {"code": "(fn [n]\n  (letfn [(primes [] (cons 2 (lazy-seq ((fn this [x]\n              (let [divisors (take-while #(<= (* % %) x) (primes))]\n                 (if (some #(zero? (rem x %)) divisors)\n                     (this (inc x))\n                     (cons x (lazy-seq (this (inc x)))))))\n                     3))))]\n  (loop [[a b c :as s] (primes)]\n    (if (= b n)\n      (= b (/ (+ a c) 2))\n      (if (< b n) (recur (rest s))\n          false)))))", "problem": 116, "user": "4fdb02aae4b05e33b9224f56"}, {"code": "(fn [n]\n    (let [[a r c]\n          (->>\n           (iterate inc 2)\n           (reductions (fn [[primes _] x]\n                         (if (not-any? #(= 0 (rem x %)) primes)\n                           [(conj primes x) x]\n                           [primes nil]))\n                       [[] nil])\n           (keep second)\n           (partition 3 1)\n           (some #(if (<= n (second %)) %)))]\n      (== n r (/ (+ a c) 2))))", "problem": 116, "user": "507056b8e4b07bd6ad9b9f29"}, {"code": "#(cond (= 563 %) true\n       (> % 1088) true\n       :else false)", "problem": 116, "user": "4facd2fae4b081705acca22f"}, {"code": "(fn [x]\n  (and (> x 3)\n  (let [prime? (fn [x] (not (some #(zero? (mod x %)) (range 2 x))))\n        previous (first (filter prime? (range (inc x) 10e7)))\n        next (first (filter prime? (range (dec x) 1 -1)))]\n    (and\n      (prime? x)\n      (= x (/ (+ next previous) 2))))))", "problem": 116, "user": "507eddf4e4b06ce648bcdbfa"}, {"code": "(fn [n]\r\n  (letfn [(prime-number? [n]\r\n            (if (< n 2)\r\n              false\r\n              (loop [i 2]\r\n                (cond (= i n)\r\n                      true\r\n                      (= (mod n i) 0)\r\n                      false\r\n                      :else\r\n                      (recur (+ i 1))))))\r\n          (next-prime-number [n]\r\n            (loop [n (+ n 1)]\r\n              (if (prime-number? n)\r\n                n\r\n                (recur (+ n 1)))))\r\n          (sub2 [prev]\r\n            (let [next-prime (next-prime-number n)]\r\n              (= n (/ (+ prev next-prime) 2))))\r\n          (sub1 [i prev]\r\n            (cond (> i n)\r\n                  false\r\n                  (= i prev)\r\n                  false\r\n                  (= i n)\r\n                  (sub2 prev)\r\n                  :else\r\n                  (recur (next-prime-number i) i)))]\r\n    ;; (sub1 n 2)\r\n    (if (prime-number? n)\r\n      (sub1 3 2)\r\n      false)))", "problem": 116, "user": "4de2f44f535d08e6dec9fdec"}, {"code": "(fn [n]\n    (let [sieve\n          (fn sieve [[x & xs]]\n            (cons x (lazy-seq (sieve (filter #(pos? (rem % x)) xs)))))\n          primes (cons 2 (sieve (iterate (partial + 2) 3)))\n          [[p1 p2 p3] restprimes] (split-at 3 primes)]\n      (loop [p1 p1\n             p2 p2\n             p3 p3\n             primes restprimes]\n        (cond\n         (= p2 n) (= n (/ (+ p1 p3) 2))\n         (> p2 n) false\n         :else (recur p2 p3 (first primes) (rest primes))))))", "problem": 116, "user": "50763574e4b0a894bb95bf3d"}, {"code": "(fn ps [n]\r\n  (letfn [(p? [x]\r\n            (or (< 1 x 4)\r\n                (empty? (filter #(= (mod x %) 0) (range 2 x)))))]\r\n    (cond (or (not (p? n)) (< n 3))\r\n\r\n            false,\r\n          :else\r\n            (let [a (first (filter p? (range (dec n) 0 -1)))\r\n                  b (first (filter p? (range (inc n) (+ 100 n))))]\r\n                   (= (+ a b) (* 2 n))))))", "problem": 116, "user": "4f62b29ce4b0defedf855fd9"}, {"code": "(let [ p (fn [x] (not-any? #(zero? (mod x %)) \n  (range 2 x)))\n      p (memoize p)\n      d (fn[x] (some #(if (p %) %) (range (dec x) 0 -1)))]\n  (fn [x]\n    (if\n        (and (p x) (> x 3))\n      (let [pd (d x) pu (- (* 2 x) pd) ] (and (p pu) (not-any? p (range (inc x) pu))))\n      false)))", "problem": 116, "user": "507c7c8be4b0b083f3ff82ef"}, {"code": "(fn balanced [x]\n  (let [is-prime (fn [n]\n\t        (cond (<= n 1) false\n\t        :else (every? false? (map #(= 0 (rem n %1)) (range 2 n)))))\n\t\t  is-prime? (memoize is-prime)\n\t\t  before-prime (fn [x] \n\t\t          (loop [x (dec x)] (cond (<= x 0) 0 (is-prime? x) x :else (recur (dec x)))))\n\t\t  after-prime (fn [x] \n\t\t\t\t  (loop [x (inc x)] (cond (= x Integer/MAX_VALUE) 0 (is-prime? x) x :else (recur (inc x)))))\n\t      pval (/ (+ (after-prime x) (before-prime x)) 2)]\n\t\t(and (is-prime? x) (= pval x))\n\t)\n)", "problem": 116, "user": "50588af1e4b06522596eba7d"}, {"code": "(fn [n]\n  (letfn [(p [x] (not-any? #(= 0 (rem x %)) (range 2 x)))\n          (a [f] (second (filter p (iterate f n))))]\n    (and (> n 2) (p n) (= n (/ (+ (a inc) (a dec)) 2)))))", "problem": 116, "user": "5054c7e1e4b0b1b9d1860eb2"}, {"code": "(fn [n]\n (let [is-prime (fn [n] (loop [i 2]\n                          (cond (> i (/ n 2)) true\n                                (zero? (mod n i)) false\n                                :else (recur (inc i)))))\n       next-prime (fn [n f] (first (drop-while (fn [x] (not (is-prime x))) (iterate f (f n)))))]\n   (and (> n 2) (is-prime n)\n    (= n(/ (+ (next-prime n inc) (next-prime n dec)) 2)))))", "problem": 116, "user": "5097b556e4b00ad8bab4e970"}, {"code": "(fn [n]\n  (letfn [(prime? [p]\n    (and (>= p 2)\n      (or (= p 2)\n          (every? #(> (rem p %) 0)\n                  (range 2 (inc (quot p 2)))))))]\n  (and\n    (> n 2)\n    (prime? n)\n    (let [p1 (first (filter prime? (iterate dec (dec n))))\n          p2 (first (filter prime? (iterate inc (inc n))))]\n      (== n (/ (+ p1 p2) 2))))))", "problem": 116, "user": "504c8165e4b09724c857af31"}, {"code": "(fn balanced-prime? [n]\n  (letfn [(prime? [n]\n            (and (> n 1)\n              (not-any? \n               (fn [divisor] (zero? (rem n divisor)))\n               (range 2 n))))\n          (from [x] (range (inc x) Integer/MAX_VALUE))\n          (first-prime [aseq] \n    \t\t(first (filter prime? aseq)))\n          (average [a b] (/ (+ a b) 2))]\n    (and (prime? n)\n         (loop [dist 1]\n           (let [below (prime? (- n dist))\n                 over  (prime? (+ n dist))]\n\t\t     (cond\n                (and below over) true\n                (and (not below) (not over)) (recur (inc dist))\n                :else false))))))", "problem": 116, "user": "4f9d53f3e4b0dcca54ed6d21"}, {"code": "(fn s [n] (if (> n 4) (let [f (fn [p m] (reduce (fn [d n] (if (some #(zero? (rem n %)) d) d (conj d n))) p (range 2 m))) w (f [] n) a (peek w) r (f w (+ 1 (- (* 2 n) a))) [a b c] (take 3 (rseq r))] (= n b (/ (+ a c) 2))) false))", "problem": 116, "user": "4f8c5f4fe4b02e764a0a5198"}, {"code": "#(let [ps (cons 2 (cons 3 ((fn primes [known]\n                                    (lazy-seq\n                                     (let [start (+ 2 (last known))\n                                           next (first (for [n (iterate (partial + 2) start)\n                                                             :when (not-any? (comp zero? (partial mod n)) known)]\n                                                         n))]\n                                       (cons next (primes (conj known next))))))\n                                  [2 3])))]\n  (and (contains? (set (take-while (partial >= %) ps)) %)\n       (> % 2)\n       (= % (/ (+ (last (take-while (partial > %) ps)) (second (drop-while (partial > %) ps))) 2))))", "problem": 116, "user": "507fbd77e4b089ade05efbd3"}, {"code": "(fn __ [n]\n  (letfn [(p [r]\n            (let [a (first r)]\n              (cons a\n               (lazy-seq (p (remove #(zero? (mod % a)) (rest r)))))))]\n    (let [[a b] (split-with #(< % n) (p (iterate inc 2)))]\n      (let [x (last a) y (first (drop-while #(<= % n) b))]\n        (boolean (and x y (= (first b) n) (= n (/ (+ x y) 2))))))))", "problem": 116, "user": "504f57c7e4b0a02f9cffde71"}, {"code": "(fn [n]\n  (let [prime? (fn [n] (not-any? #(zero? (mod n %)) (range 2 n)))]\n    (and\n      (> n 2)\n      (prime? n)\n      (= \n        (* n 2)\n        (apply + (map #(first (filter prime? (rest (iterate % n)))) [inc dec]))))))", "problem": 116, "user": "506ab9bae4b05d3b7762c74c"}, {"code": "(fn is-balanced-prime? [n]\n  (letfn [(sieve [ls]\n            (lazy-seq\n             (let [[x & more] ls]\n         (cons x\n\t\t     (sieve (remove #(= 0 (rem % x)) more))))))\n          (is-in? [x ls]\n            (loop [an ls]\n              (let [f (first an)]\n                (cond\n                 (= f x) true\n                 (> x f) (recur (next an))\n                 :esle false))))]\n  (let [primes (sieve (map (partial + 2) (range)))\n        balanced-primes (map second (filter (fn [[x y z]]\n                                              (= y (/ (+ x z) 2))) (partition 3 1 primes)))]\n    (is-in? n balanced-primes))))", "problem": 116, "user": "4dd62278535d2dad7130b5c7"}, {"code": "(fn bal [p]\n  (if (< p 3) false\n    (letfn [\n      (prime [p] (and (< 1 p) (every? #(pos? (rem p %)) (range 2 p))))\n      (np [s] (take-while (complement prime) (rest s)))]\n      (and (prime p)\n        (== \n          (count (np (iterate inc p))) \n          (count (np (iterate dec p))))))))", "problem": 116, "user": "50901b2ee4b0ea685a20f774"}, {"code": "(fn balanced-prime? [n]\n  (letfn [(prime? [n]\n            (not-any? #(= 0 (mod n %)) (range 2 n)))\n          (gen-primes []\n            (filter prime? (range 1 Double/POSITIVE_INFINITY)))\n          (find-item-and-neighbors [item coll]\n            (first\n             (drop-while #(not= (second %) item)\n                         (partition 3 1 coll))))]\n    (if (and (> n 2) (prime? n))\n      (let [[prev _ next] (find-item-and-neighbors n (gen-primes))]\n        (= (/ (+ prev next) 2) n))\n      false)))", "problem": 116, "user": "504ec4d3e4b069badc5a33c9"}, {"code": "(fn [n]\n    (let [primes \n          (fn []\n            (letfn [(enqueue [sieve n step]\n                      (let [m (+ n step)]\n                        (if (sieve m)\n                          (recur sieve m step)\n                          (assoc sieve m step))))\n                    (next-sieve [sieve candidate]\n                      (if-let [step (sieve candidate)]\n                        (-> sieve\n                            (dissoc candidate)\n                            (enqueue candidate step))\n                        (enqueue sieve candidate (+ candidate candidate))))\n                    (next-primes [sieve candidate]\n                      (if (sieve candidate)\n                        (recur (next-sieve sieve candidate) (+ candidate 2))\n                        (cons candidate\n                              (lazy-seq (next-primes (next-sieve sieve candidate)\n                                       (+ candidate 2))))))]\n              (cons 2 (lazy-seq (next-primes {} 3)))))\n          prime-triples (partition 3 1 (primes))\n          [below middle above] (first (drop-while #(< (second %)\n                                                      n)\n                                                  prime-triples))]\n      (if (= middle n)\n        (= middle (/ (+ below above) 2))\n        false)\n      ))", "problem": 116, "user": "4daea889edd6309eace4d15b"}, {"code": "(fn sandwich? [n]\n  (letfn [(prime? [n]\n                  (let [limit (dec n)]\n                    (loop [d 2] (cond\n                                  (zero? n) false\n                                  (= 1 n) true\n                                  (= 2 n) true \n                                  (> d limit) true \n                                  (zero? (rem n d)) false\n                                  :else (recur (inc d))))))]\n    (cond \n      (not (prime? n)) false\n      (= 1 n) false\n      (= 2 n) false\n      :else\n      (let [a (first (filter prime? (range (inc n)  Long/MAX_VALUE)))\n            b (first (filter prime? (range (dec n) 0 -1)))]\n        (= n (/ (+ a b) 2))))))", "problem": 116, "user": "4f4c6b21e4b03ad3f0c10c8f"}, {"code": "(fn [p]\r\n  (let [prime? (fn [n]\r\n                 (and \r\n                   (odd? n)\r\n                   (every? #(not (zero? (mod n %))) \r\n                           (range 3 (quot n 2) 2))))]\r\n    (if (< p 5)\r\n      false\r\n      (and (prime? p)\r\n           (let [a (first (filter prime? (iterate dec (dec p))))\r\n                 b (first (filter prime? (iterate inc (inc p))))]\r\n             (= p (/ (+ a b) 2)))))))", "problem": 116, "user": "509c03f3e4b085ae113522a8"}, {"code": "(fn balanced-prime? [n]\n  (letfn [(is-prime? [n]\n             (not-any? #(zero? (rem n %))\n                     (take-while #(<= (* % %) n) (iterate inc 2))))\n          (prime-before? [n]\n             (first (filter is-prime? (reverse (range 2 (dec n))))))\n          (prime-after? [n]\n             (first (filter is-prime? (iterate inc (inc n)))))]    \n  (and (is-prime? n)\n       (when-let [p-before (prime-before? n)]\n         (= (* 2 n)\n            (+ p-before (prime-after? n)))))))", "problem": 116, "user": "50812debe4b01a93d3f38e4c"}, {"code": "(fn [n]\n  (letfn [(is_prime [n] \n                    (if (= n 2)\n          \t\t\t\t\t\ttrue\n      \t\t\t\t\t\t\t\t(every? false? (map #(= (mod n %) 0) (range 2 n)))))\n          (sib_prime [n fun] (first (filter is_prime (iterate fun (fun n)))))]\n   (cond\n    (< n 5) false\n    (not (is_prime n)) false\n    :else (= n (/ (+ (sib_prime n inc) (sib_prime n dec)) 2)))))", "problem": 116, "user": "506617c3e4b03d366d7cb2ab"}, {"code": "(fn __ [n]\n  (and\n    (.isProbablePrime (BigInteger. (str n)) 99)\n    (=\n      (* 2 n)\n      (+\n        (first\n          (filter\n            #(.isProbablePrime (BigInteger. (str %)) 99)\n            (iterate inc (inc n))))\n        (first\n          (filter\n            #(.isProbablePrime (BigInteger. (str %)) 99)\n            (iterate dec (dec n))))))))", "problem": 116, "user": "4fb1325de4b081705acca276"}, {"code": "(fn [x] \n    (letfn \n      [(prime? [n] (let [early-primes #{2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 } \n                       div-ep? (not (some #(= 0 (rem n %)) early-primes))\n                       ]\n                   (if (contains? early-primes n)\n                     true\n                     (if (some #(= 0 (rem n %)) early-primes)\n                       false\n                       (.isProbablePrime (BigInteger/valueOf n) 5)\n                       \n                       ))))\n       ] \n      (if (or (< x 5) (not (prime? x)) )\n        false\n        \n        (let [prevprime (first (filter prime? (range (- x 2) 2 -2)))   \n              nextprime (first (filter prime? (range (+ x 2) (+ x 5 (- x prevprime)) 2)))\n              ]\n          (if (nil? nextprime)\n            false                  \n            (= (/ (+ prevprime nextprime) 2) x))))))", "problem": 116, "user": "50956c2be4b087f34d351ab2"}, {"code": "(letfn [(prime? [n] (not-any? #(zero? (mod n %)) (range 2 n)))\n        (prime-before [n] (first (filter prime? (range (dec n) 2 -1))))\n        (prime-after [n] (first (filter prime? (iterate inc (inc n)))))]\n  #(and (> % 3) (prime? %) (= % (/ (+ (prime-before %) (prime-after %)) 2))))", "problem": 116, "user": "50996a38e4b0cae2931060b3"}, {"code": "#(let\n   [[a b c] (first\n             (drop-while\n              (fn [[_ b _]] (> % b))\n              (let [p (filter\n                          (fn [i]\n                            (= i ((fn [x d]\n                                    (cond (> (* d d) x) x\n                                          (= (mod x d) 0) d\n                                          :else (recur x (+ d 1)))\n                                    ) i 2)))\n                          (drop 2 (range)))\n                       ] (map vector p (rest p) (rest (rest p))))))\n    ] (and (= b %) (= b (/ (+ a c) 2))))", "problem": 116, "user": "50acbd15e4b071b89ef26234"}, {"code": "(fn [x]\n    (let [primes ((fn primeseq [candidates]\n                    (let [p (first candidates)]\n                      (cons p\n                            (lazy-seq (primeseq\n                                       (filter\n                                        #(not (zero? (mod % p)))\n                                        (rest candidates)))))))\n                  (iterate inc 2))]\n      (loop [last (first primes)\n             nums (rest primes)]\n        (cond (> (first nums) x) false\n              (= (first nums) x) (= x (/ (+ last (second nums)) 2))\n              :else (recur (first nums) (rest nums))))))", "problem": 116, "user": "4f463dfde4b0d56e7bb92b99"}, {"code": "(fn[x]\n  (letfn [(prime?[n] (and (> n 1) \n                     (every? #(> (rem n %) 0)\n                       (range 2 (inc (quot n 2))))))\n          (nprime [f n] (first (filter prime? (iterate f (f n)))))]    \n    \n    \n    (and (> x 2)\n         (prime? x)\n         (= x (/ (+ (nprime dec x) (nprime inc x)) 2)))))", "problem": 116, "user": "506406c8e4b075d771da6f9f"}, {"code": "(let [p (nnext (remove (fn [x] (some #(zero? (mod x %)) (range 2 x))) (range)))]\n  (fn [x]\n    (let [[a b c] (first \n                   (drop-while \n                    #(< (first %) x)\n                    (map vector (next p) p (nnext p))))]\n      (and \n       (= x a) \n       (= (* 2 a) (+ b c))))))", "problem": 116, "user": "4f08b15b535dcb61093f6c40"}, {"code": "(let [p (fn [x] (every? #(not (integer? (/ x %))) (range 2 x)))\n      l (filter p (range 2 Double/POSITIVE_INFINITY))]\n  (fn [x]\n    (and (p x)\n         (let [a (last (cons -100 (take-while #(< % x) l)))\n               b (first (drop-while #(<= % x) l))]\n           (= x (/ (+ a b) 2))))))", "problem": 116, "user": "50a83315e4b054305ba5a830"}, {"code": "(fn sandwich? [n]\n  (letfn [(is-prime? [n]\n            (if (= n 1) false\n              (every? false?\n                      (map #(= 0 (mod n %1)) (range 2 n)))))\n          (nextprime [pr]\n            (first (take 1 (filter is-prime? (iterate inc (inc pr))))))\n          (prevprime [pr]\n            (first (take 1 (filter is-prime? (iterate dec  (dec pr))))))]\n    (and (is-prime? n)\n         (= (/ (+ (prevprime n) (nextprime n)) 2) n))))", "problem": 116, "user": "50e87427e4b0ebbe794eb7e8"}, {"code": "(let [prime? (fn [n]\n               (cond\n                (or (= n 0) (= n 1)) false\n                (or (= n 2) (= n 3)) true\n                :else (= '(1) (filter #(= 0 (rem n %)) (range 1 (inc (Math/sqrt n)))))))\n      partitioned-primes (map #(vector\n                                (second %)\n                                (= (second %) (quot (+ (first %) (last %)) 2)))\n                              (partition 3 1 (filter prime? (range))))\n      balanced-primes (map #(% 0) (filter #(true? (% 1)) partitioned-primes))\n      in? (fn in? [coll x] (cond (nil? coll) false\n                            (= x (first coll)) true\n                            (< x (first coll)) false\n                            :else (in? (rest coll) x)))]\n  (fn balanced? [p]\n    (if (= p 3) false\n        (in? balanced-primes p))))", "problem": 116, "user": "50733b31e4b0e3170b5a869a"}, {"code": "(fn [n]\n  (let [prime? (fn [n] (not-any? #(= 0 (mod n %)) (range 2 n)))\n        primes (filter prime? (drop 2 (range)))\n        sandwich-primes (map second (filter (fn [[a b c]] (= b (/ (+ a c) 2))) (partition 3 1 primes)))]\n    (and (prime? n) (= n (last (take-while #(<= % n) sandwich-primes))))))", "problem": 116, "user": "500aa15ee4b03d00572d2d76"}, {"code": "(fn [n]\n  (let [p #(.isProbablePrime (BigInteger/valueOf %) 5)\n        f #(loop [x (%2 %)]\n            (if (p x) x (recur (%2 x))))\n        a (f n dec)\n        b (f n inc)]\n    (and (p n) (= n (/ (+ a b) 2)))))", "problem": 116, "user": "4f956072e4b0dcca54ed6ccf"}, {"code": "(fn [n]\n  (let [gen-primes\n\t\t\t(fn [n]\n\t\t\t  (loop [primes [2] i 3]\n\t\t\t\t(cond \n\t\t\t\t   (< (count primes) n)\n\t\t\t\t\t (if (some #(zero? (rem i %)) primes) \n\t\t\t\t\t   (recur primes (+ i 2))\n\t\t\t\t\t   (recur (conj primes i) (+ i 2)) )\n\t\t\t\t   :else primes )))\n\t    primes (gen-primes 200)\n\t\ti (.indexOf primes n)]\n\t(and (> i 0) (= (* 2 n) (+ (primes (inc i)) (primes (dec i)))))))", "problem": 116, "user": "50d0d4c8e4b00b15ecee976a"}, {"code": "(fn [n]\n  (letfn [(prime? [n] (not (some zero? (map #(rem n %) (range 2 (inc (Math/sqrt n)))))))\n          (neighbor-prime [n f] (let [next-cand (f n)] (if (prime? next-cand) next-cand (recur next-cand f))))\n          (next-prime-of [n] (neighbor-prime n inc))\n          (prev-prime-of [n] (neighbor-prime n dec))\n          (avg [a b] (/ (+ a b) 2))]\n    (and (> n 3) (prime? n) (= n (avg (next-prime-of n) (prev-prime-of n))))))", "problem": 116, "user": "50ef9a7ae4b0bdaecbb47d9e"}, {"code": "(fn [n]\n    (let [prime? #(loop [x 2]\n                    (if (= 0 (mod %1 x))\n                      (if (= %1 x) true false)\n                      (recur (inc x))))]\n      (cond\n        (< n 5)\n          false\n        (not (prime? n))\n          false\n        :else\n          (= n (/ (+ (last (filter prime? (range 2 n)))\n                     (second (filter prime? (range n (* n n)))))\n                  2)))))", "problem": 116, "user": "4f038567535dcb61093f6b0c"}, {"code": "(let [pfilt (fn [n] (not-any? #(zero? (mod n %)) (range 2 (inc (Math/floor (Math/sqrt n))))))\n      primes (filter pfilt (range 2 1500))]\n  (fn [n]\n    (if-let [[l _ r] (first (filter (fn [[_ m _]] (= n m)) (partition 3 1 primes)))]\n      (= (* 2 n) (+ l r))\n      false)))", "problem": 116, "user": "4ffc10aae4b0678c553fc3d6"}, {"code": "(fn balanced-prime? [y] \n   (let [prime? (fn [x] (not (some #(zero? (mod x %)) (range 2 x))))\n         left (first (filter prime? (reverse (range 2 y))))\n         right (first (filter prime? (iterate inc (inc y))))\n   ]   \n      (if (and (number? left) (number? right))\n         (and (prime? y)(= y (/ (+ right  left) 2) ))\n         false\n      )\n   )   \n)", "problem": 116, "user": "4f7b6b90e4b06e829148e1a4"}, {"code": "(fn balanced-prime? [n]\n  (letfn [\n          (prime-before? [number a]\n            (if (< a 2)\n              true\n              (and (not (= 0 (rem number a)))\n                   (prime-before? number (dec a))))\n                       )\n          (prime? [number]\n            (cond\n              (= number 2) true\n              (= 0 (rem number 2)) false\n              (prime-before? number (int (/ number 2))) true\n              :else false)\n                  )\n          (prime-after [number]\n            (if (prime? (inc number))\n              (inc number)\n              (prime-after (inc number))))\n          (prime-before [number]\n            (if (prime? (dec number))\n              (dec number)\n              (prime-before (dec number))))                           \n          ]\n    (and (> n 2) (prime? n) (= (* 2 n) (+ (prime-before n)\n                  (prime-after n))))\n    )\n  )", "problem": 116, "user": "5021f0b3e4b00bba4502f7ac"}, {"code": "(fn psw[x]\n   (let \n     [prime? (fn [n] (not-any? \n              #(= 0 (mod n %)) (range 2 n)))\n      nprime (first (filter prime? (iterate inc (inc x))))\n      pprime (first (filter prime? (iterate dec (dec x))))\n      ]\n   (and (> x 2) (prime? x) (= (+ x x)(+ nprime pprime)))\n   ))", "problem": 116, "user": "50de11b2e4b061dbdced7217"}, {"code": "(fn [n]\n  (letfn [(next-sieve [s factor root-prime]\n                      (if (s factor)\n                        (next-sieve s (+ factor root-prime) root-prime)\n                        (assoc s factor root-prime)))\n          (next-prime [s candidate]\n;                      (clojure.pprint/pprint [candidate s (s candidate)])\n                      (lazy-seq\n                       (if-let [root-prime (s candidate)]\n                         (next-prime\n                          (next-sieve (dissoc s candidate)\n                                      (+ candidate root-prime)\n                                      root-prime)\n                          (inc candidate))\n                         (cons candidate\n                          (next-prime\n                           (assoc s candidate candidate)\n                           candidate)))))\n          (balanced [p]\n                    (map second\n                         (filter (fn [[a b c]] (= (/ (+ a c) 2) b))\n                                 (partition 3 1 p))))]\n    (= n (first (drop-while #(< % n) (balanced (next-prime {} 2)))))))", "problem": 116, "user": "4ebaf790535dfed6da9c6d6e"}, {"code": "(fn [n]\n  (letfn \n    [(is-prime? [n] \n                (every? #(not= 0 (mod n %)) (range 2 n)))\n     (next-prime [n]\n                 (first (filter is-prime? (iterate inc (inc n)))))\n     (last-prime [n]\n                 (first (filter is-prime? (range (dec n) 0 -1))))\n     (mean [x y]\n           (/ (+ x y) 2))]\n    (if (< n 3)\n      false\n    \t(and (is-prime? n) \n           (= n (mean (next-prime n) (last-prime n)))))))", "problem": 116, "user": "50217818e4b00bba4502f7a7"}, {"code": "(fn [n]\n    (let [ p? (fn [n] (not-any? #(zero? (rem n %)) (range 2 n)))\n           fp #(first (filter p? %)) ]\n      (and (> n 3) (p? n)\n           ({(* n 2) true}\n            (+ \n             (fp (range (inc n) 9999))\n             (fp (range (dec n) 1 -1))\n            )\n            ))))", "problem": 116, "user": "4ff67852e4b0678c553fc37e"}, {"code": "(fn [x]\n  (when (> x 3)\n    (let [prime? (fn [n] (not-any? #(zero? (mod n %)) (range 2 n)))\n          lower-prime (first (filter prime? (range (dec x) 2 -1)))\n          higher-prime (first (filter prime? (range (inc x) (+ x x))))]\n      (and (prime? x) (= (+ x x) (+ lower-prime higher-prime))))))", "problem": 116, "user": "510db6cde4b078ea71921145"}, {"code": "(letfn [(not-mult? [i f] (not= (mod i f) 0))\n         (prime? [n] (or (= n 2) (= n 3) (= n 5) (= n 7) (= n 11) \n                     (and (> n 2) (odd? n) (not-mult? n 3) (not-mult? n 5) (not-mult? n 7) (not-mult? n 11)\n                          (reduce #(and %1 %2) (for [x (range 3 (inc (int (Math/sqrt n))) 2)] (not-mult? n x))))))]\n   (fn [i]\n     (and (prime? i)\n          (let [next (loop [j (+ i 2)] (if (prime? j) j (recur (inc j))))\n                prev (loop [j (- i 2)] (if (< j 2) nil (if (prime? j) j (recur (dec j)))))]\n            (and (not (nil? prev)) (= (- next i) (- i prev)))))))", "problem": 116, "user": "50bce014e4b0594b91591c63"}, {"code": "(fn f [n]\n  (let [prime? (fn [n']\n                 (if (or (= n' 1) (= n' 2))\n                   true\n                   (not-any? #(zero? (mod n' %)) (range 2 n'))))\n        primes (filter prime? (drop 1 (range)))]\n    (if (or (= n 2) (not (prime? n)))\n      false\n      (let [lhs (last (take-while #(< % n) primes))\n            rhs (first (drop-while #(<= % n) primes))]\n        (if (nil? lhs)\n          false\n          (= (- n lhs) (- rhs n)))))))", "problem": 116, "user": "51195e77e4b055cfb310d499"}, {"code": "(fn [n]\n  (if (< n 3)\n    false\n    (letfn [(primes [](filter prime? (iterate inc 2)))\n            (prime?\n              ([candidate] (prime? candidate (int (/ candidate 2))))\n              ([candidate divisor]\n                 (if (= 1 divisor)\n                   true\n                   (if (zero? (rem candidate divisor))\n                     false\n                     (recur candidate (dec divisor))))))]\n      (let [[a [b c]] (split-with (partial > n) (primes))\n            mean (/ (+ (last a) c) 2)]\n        (= n b mean)))))", "problem": 116, "user": "50d93c53e4b0fd36a4b89223"}, {"code": "(fn [n]\n  (let [is-prime (fn [n] (and (not= 1 n)\n                          (not-any? #(zero? (rem n %))\n                                    (range 2 n))))\n        iter-prime (fn [n f]\n                     (first (filter is-prime (iterate f (f n)))))]\n    (and\n     (is-prime n)\n     (= (* 2 n) (+ (iter-prime n inc) (iter-prime n dec))))))", "problem": 116, "user": "510acd6ee4b078ea719210f4"}, {"code": "(fn balanced-prime? [x]\n                               (let [prime? (fn [x]\n                                                (and (>= x 2)\n                                                     (not-any? #(zero? (rem x %)) (range 2 x))))\n                                            next-prime (fn [x]\n                                                           (first (filter prime? (iterate inc (inc x)))))\n                                            prev (- (* x 2) (next-prime x))]\n                                 (and (prime? x) (prime? prev)  (= (next-prime prev) x))))", "problem": 116, "user": "50310b8be4b05b7df5a0b84d"}, {"code": "(fn bal-prime [n]\n    (condp = n\n     0 false\n     1 false\n     2 false\n     (let [adv-prime-seq-fn (fn adv-prime-seq [s]\n                              (let [prev-prime (first s)]\n                                (cons prev-prime (lazy-seq (adv-prime-seq (remove #(zero? (mod % prev-prime)) s))))))\n           primes (adv-prime-seq-fn (drop 2 (range)))\n           finite-primes (take-while #(<= % n) primes)]\n       (boolean\n        (when (some #{n} finite-primes)\n          (let [ppos (first (keep-indexed #(when (#{n} %2) %1) finite-primes))\n                pre (nth primes (dec ppos))\n                nex (nth primes (inc ppos))]\n            (= (* 2 n) (+ pre nex))))))))", "problem": 116, "user": "51281b25e4b03a34742b4304"}, {"code": "(fn [n]\n  (let [p (filter \n              (fn [n] \n                (every? #(not= 0 (mod n %)) \n                        (take-while #(<= (* % %) n) \n                                    (range 2 n)))) \n              (map #(+ 2 %) (range)))\n        b (map #(% 1) (filter \n    #(= (+ (% 0) (% 2)) (* 2 (% 1))) \n    (map vector p (rest p) (rest (rest p)))))]\n    (= n (last (take-while #(<= % n) b)))))", "problem": 116, "user": "50fbdacfe4b0d10d794c19f0"}, {"code": "(fn ps [i]\n  (if (<= i 2)\n    false\n    (let [primes '(2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 101 103 107 109 113 127 131 137\n                              139 149 151 157 163 167 173 179 181 191 193 197 199 211 223 227 229 233 239 241 251 257 263 269 271\n                              277 281 283 293 307 311 313 317 331 337 347 349 353 359 367 373 379 383 389 397 401 409 419 421 431\n                              433 439 443 449 457 461 463 467 479 487 491 499 503 509 521 523 541 547 557 563 569 571 577 587 593\n                              599 601 607 613 617 619 631 641 643 647 653 659 661 673 677 683 691 701 709 719 727 733 739 743 751\n                              757 761 769 773 787 797 809 811 821 823 827 829 839 853 857 859 863 877 881 883 887 907 911 919 929\n                              937 941 947 953 967 971 977 983 991 997 1009 1013 1019 1021 1031 1033 1039 1049 1051 1061 1063 1069\n                              1087 1091 1093 1097 1103 1109 1117 1123 1129 1151 1153 1163 1171 1181 1187 1193 1201 1213 1217 1223\n                              1229 1231 1237 1249 1259 1277 1279 1283 1289 1291 1297 1301 1303 1307 1319 1321 1327 1361 1367 1373\n                              1381 1399 1409 1423 1427 1429 1433 1439 1447 1451 1453 1459 1471 1481 1483 1487 1489 1493 1499 1511\n                              1523 1531 1543 1549 1553 1559 1567 1571 1579 1583 1597 1601 1607 1609 1613 1619 1621 1627 1637 1657\n                              1663 1667 1669 1693 1697 1699 1709 1721 1723 1733 1741 1747 1753 1759 1777 1783 1787 1789 1801 1811\n                              1823 1831 1847 1861 1867 1871 1873 1877 1879 1889 1901 1907 1913 1931 1933 1949 1951 1973 1979 1987\n                              1993 1997 1999 2003 2011 2017 2027 2029 2039 2053 2063 2069 2081 2083 2087 2089 2099 2111 2113 2129\n                              2131 2137 2141 2143 2153 2161 2179 2203 2207 2213 2221 2237 2239 2243 2251 2267 2269 2273 2281 2287\n                              2293 2297 2309 2311 2333 2339 2341 2347 2351 2357 2371 2377 2381 2383 2389 2393 2399 2411 2417 2423\n                              2437 2441 2447 2459 2467 2473 2477 2503 2521 2531 2539 2543 2549 2551 2557 2579 2591 2593 2609 2617\n                              2621 2633 2647 2657 2659 2663 2671 2677 2683 2687 2689 2693 2699 2707 2711 2713 2719 2729 2731 2741\n                              2749 2753 2767 2777 2789 2791 2797 2801 2803 2819 2833 2837 2843 2851 2857 2861 2879 2887 2897 2903\n                              2909 2917 2927 2939 2953 2957 2963 2969 2971 2999 3001 3011 3019 3023 3037 3041 3049 3061 3067 3079\n                              3083 3089 3109 3119 3121 3137 3163 3167 3169 3181 3187 3191 3203 3209 3217 3221 3229 3251 3253 3257\n                              3259 3271 3299 3301 3307 3313 3319 3323 3329 3331 3343 3347 3359 3361 3371 3373 3389 3391 3407 3413\n                              3433 3449 3457 3461 3463 3467 3469 3491 3499 3511 3517 3527 3529 3533 3539 3541 3547 3557 3559 3571\n                              3581 3583 3593 3607 3613 3617 3623 3631 3637 3643 3659 3671 3673 3677 3691 3697 3701 3709 3719 3727\n                              3733 3739 3761 3767 3769 3779 3793 3797 3803 3821 3823 3833 3847 3851 3853 3863 3877 3881 3889 3907\n                              3911 3917 3919 3923 3929 3931 3943 3947 3967 3989 4001 4003 4007 4013 4019 4021 4027 4049 4051 4057\n                              4073 4079 4091 4093 4099 4111 4127 4129 4133 4139 4153 4157 4159 4177 4201 4211 4217 4219 4229 4231\n                              4241 4243 4253 4259 4261 4271 4273 4283 4289 4297 4327 4337 4339 4349 4357 4363 4373 4391 4397 4409\n                              4421 4423 4441 4447 4451 4457 4463 4481 4483 4493 4507 4513 4517 4519 4523 4547 4549 4561 4567 4583\n                              4591 4597 4603 4621 4637 4639 4643 4649 4651 4657 4663 4673 4679 4691 4703 4721 4723 4729 4733 4751\n                              4759 4783 4787 4789 4793 4799 4801 4813 4817 4831 4861 4871 4877 4889 4903 4909 4919 4931 4933 4937\n                              4943 4951 4957 4967 4969 4973 4987 4993 4999 5003 5009 5011 5021 5023 5039 5051 5059 5077 5081 5087\n                              5099 5101 5107 5113 5119 5147 5153 5167 5171 5179 5189 5197 5209 5227 5231 5233 5237 5261 5273 5279\n                              5281 5297 5303 5309 5323 5333 5347 5351 5381 5387 5393 5399 5407 5413 5417 5419 5431 5437 5441 5443\n                              5449 5471 5477 5479 5483 5501 5503 5507 5519 5521 5527 5531 5557 5563 5569 5573 5581 5591 5623 5639\n                              5641 5647 5651 5653 5657 5659 5669 5683 5689 5693 5701 5711 5717 5737 5741 5743 5749 5779 5783 5791\n                              5801 5807 5813 5821 5827 5839 5843 5849 5851 5857 5861 5867 5869 5879 5881 5897 5903 5923 5927 5939\n                              5953 5981 5987 6007 6011 6029 6037 6043 6047 6053 6067 6073 6079 6089 6091 6101 6113 6121 6131 6133\n                              6143 6151 6163 6173 6197 6199 6203 6211 6217 6221 6229 6247 6257 6263 6269 6271 6277 6287 6299 6301\n                              6311 6317 6323 6329 6337 6343 6353 6359 6361 6367 6373 6379 6389 6397 6421 6427 6449 6451 6469 6473\n                              6481 6491 6521 6529 6547 6551 6553 6563 6569 6571 6577 6581 6599 6607 6619 6637 6653 6659 6661 6673\n                              6679 6689 6691 6701 6703 6709 6719 6733 6737 6761 6763 6779 6781 6791 6793 6803 6823 6827 6829 6833\n                              6841 6857 6863 6869 6871 6883 6899 6907 6911 6917 6947 6949 6959 6961 6967 6971 6977 6983 6991 6997\n                              7001 7013 7019 7027 7039 7043 7057 7069 7079 7103 7109 7121 7127 7129 7151 7159 7177 7187 7193 7207\n                              7211 7213 7219 7229 7237 7243 7247 7253 7283 7297 7307 7309 7321 7331 7333 7349 7351 7369 7393 7411\n                              7417 7433 7451 7457 7459 7477 7481 7487 7489 7499 7507 7517 7523 7529 7537 7541 7547 7549 7559 7561\n                              7573 7577 7583 7589 7591 7603 7607 7621 7639 7643 7649 7669 7673 7681 7687 7691 7699 7703 7717 7723\n                              7727 7741 7753 7757 7759 7789 7793 7817 7823 7829 7841 7853 7867 7873 7877 7879 7883 7901 7907 7919)\n          c (count (take-while #(<= % i) primes))\n          [a b c] (drop (- c 2)(take (inc c) primes))]\n      (if (= b i (/ (+ a c) 2))\n        true\n        false))))", "problem": 116, "user": "5123ac8ee4b061b4c6f0e0b1"}, {"code": "(fn [n]\n  (if (<= n 1)\n    false\n  (let [is-prime #(not-any? (fn[x] (= 0 (rem % x))) (range 2 %))]\n    (and (is-prime n)\n    (let [\n        primes (filter is-prime (iterate inc 2))\n        [befores afters] (split-with #(< % n) primes)\n    \tbefore (or (last befores) 0)\n    \tafter  (if (= n (first afters)) (first (rest afters)) (first afters))]\n    (= n (/ (+ before after) 2)))))))", "problem": 116, "user": "4ddbd934535d02782fcbe9fc"}, {"code": "(fn [n]\n  (let [is-prime (fn [x]\n                   (and (> x 1)\n                        (not-any?\n                          #(zero? (mod x %))\n                          (range 2 (-> x (/ 2) int inc))))\n                   )\n        previous-prime (fn [x]\n                         (first (filter is-prime (range (dec x) 1 -1))))\n        next-prime (fn [x]\n                         (first (filter is-prime (drop (inc x) (range))))) ]\n    (do\n      (and (> n 2)\n           (is-prime n) \n           (= (- n (previous-prime n))\n              (- (next-prime n) n)))))\n  )", "problem": 116, "user": "4fbbcf0ce4b081705acca2ee"}, {"code": "(fn balanced? [n]\n  (letfn [(prime? [p]\n                  (cond\n                   (or\n                    (= p 2)\n                    (= p 3)) true\n                   (or\n                    (= p 1)\n                    (= 0 (rem p 2))\n                    (= 0 (rem p 3))) false\n                   :else (let [upper (+ (int (Math/sqrt p)) 1)]\n                           (loop [k 1]\n                             (if (> (- (* 6 k) 1) upper)\n                               true\n                               (cond\n                                (= 0 (rem p (- (* 6 k) 1))) false\n                                (= 0 (rem p (+ (* 6 k) 1))) false\n                                :else (recur (inc k))))))))\n          (next-prime [n, f]\n                      (loop [x (f n)]\n                        (if (prime? x)\n                          x\n                          (recur (f x)))))]\n    (and\n     (prime? n)\n     (= n (/ (+ (next-prime n inc) (next-prime n dec)) 2)))))", "problem": 116, "user": "51365524e4b04ac1f358dd52"}, {"code": "(fn [n]\n  (letfn\n    [(sieve [xs]\n       (let [x (first xs)]    \n         (cons x\n               (lazy-seq\n                 (sieve (filter (fn [y] (not= (rem y x) 0))\n                                (next xs)))))))]\n    (loop [primes (sieve (drop 2 (range)))]\n      (let [[a b c & more] primes]\n        (cond\n          (< b n) (recur (next primes))\n          (= b n) (= b (/ (+ a c) 2))\n          :else false)))))", "problem": 116, "user": "511442d0e4b0e9c109bb74d5"}, {"code": "(fn prime-sandwich [x] \n  (let [mean #(/ (apply + %) (count %))\n        primes '(3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 101 103 107 109 113 127 131 137 139 149 151 157 163 167 173 179 181 191 193 197 199 201 211 223 227 229 233 239 241 251 257 263 269 271 277 281 283 293 307 311 313 317 331 337 347 349 353 359 367 373 379 381 383 389 397 401 409 419 421 431 433 439 443 449 457 461 463 467 479 487 491 499 503 509 521 523 541 547 557 563 569 571 577 587 593 599 601 607 613 617 619 631 641 643 647 653 659 661 673 677 683 691 701 709 123 123 719 727 733 739 743 751 757 761 769 773 787 797 809 811 821 823 827 829 839 853 857 859 863 877 881 883 887 907 911 919 929 937 941 947 953 967 971 983 991 997 1009 1013 1019 1021 1031 1033 1039 1049 1051 1061 1063 1069 1087 1091 1093 1097 1103 1109 1117 1123 1129 1151 1153 1163 1171 1181 1187 1193 1201 1213 1217 1223 1229 1231 1237 1249 1259 1277 1279 1283 1289 1291 1297 1301 1303 1307 1319 1321 1327 1361 1367 1373 1381 1399) ]\n    (let [i (.indexOf primes x)]\n      (if (< i 1)\n        false\n        (= x (/ (+ (nth primes (dec i))\n                   (nth primes (inc i))) 2))))))", "problem": 116, "user": "50e4f4e9e4b049a987753896"}, {"code": "(fn p116 [n]\n  (let [prime? (fn [x] (not (some #(zero? (mod x %)) (range 2 x))))\n        prev-prime (first (filter prime? (iterate dec (dec n))))\n        next-prime (first (filter prime? (iterate inc (inc n))))]\n    (and (prime? n)\n     (> n 2)\n     (= n (/ (+ prev-prime next-prime) 2)))))", "problem": 116, "user": "5125745ae4b05d10e3e395f9"}, {"code": "(fn [num]\n             (if (> num 4)\n\t\t\t\t\t\t\t (letfn [(prime-calc [y inc-func]\n\t\t\t\t\t\t\t\t\t\t\t   (loop [index y]     \n\t\t\t\t\t\t\t\t\t\t\t     (if (= (count ((fn [x]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   (loop [res [] i 2]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t     (if (= (- x 1) i)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t       res\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t       (if (= 0 (mod x i))\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t               (recur (conj res i) (inc i))\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t               (recur res (inc i))\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t          )      \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t       )              \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t     )\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   ) index ))\n\t\t\t\t\t\t\t\t\t\t\t            0)\n\t\t\t\t\t\t\t\t\t\t\t       index\n\t\t\t\t\t\t\t\t\t\t\t       (recur (inc-func index))\n\t\t\t\t\t\t\t\t\t\t\t       )     \n\t\t\t\t\t\t\t\t\t\t\t     )   \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t) ]\n\t\t\t\t\t\t\t    (and ( = num (prime-calc num inc)) (= num (/ ( + (prime-calc (inc num) inc) (prime-calc (dec num) dec)) 2)))               \n\t\t\t\t\t\t\t   )\n                 false\n\t\t\t\t\t\t   )           \n        )", "problem": 116, "user": "5106dc1be4b01150e115ebf0"}, {"code": "(fn balanced-prime? [n]\n  (let [is-prime? #(not-any? (fn [d] (= 0 (rem % d))) (range 2 %))]\n    (and (< 4 n) \n         (is-prime? n)\n         (let [i #(nth (filter is-prime? (iterate % n)) 1)] (= n (/ (+ (i inc) (i dec)) 2))))))", "problem": 116, "user": "5138d08be4b0a5db03d727db"}, {"code": "(fn [k]\n  (let [p (fn[x] (seq (filter #(= 0 (mod x %)) (range 2 x))))\n        f #(first (drop-while p (next (iterate % k))))]\n    (and (< 2 k) (not (p k))\n         (= k (/ (+ (f inc) (f dec)) 2)))))", "problem": 116, "user": "4f296a80e4b0d6649770a02a"}, {"code": "(fn [x]\n  (letfn\n    [(is-prime\n       ([x] (and (> x 1) (is-prime x (quot x 2))))\n       ([x y]\n        (if (= y 1)\n          true\n          (if (= 0 (mod x y))\n            false\n            (recur x (dec y))))))\n     (balanced-prime\n       ([x] (and (is-prime x) (balanced-prime x 1)))\n       ([x y]\n        (let\n          [n (is-prime (+ x y))\n           p (is-prime (- x y))]\n          (if (and n p)\n            true\n            (if (or n p)\n              false\n              (recur x (inc y)))))))]\n    (balanced-prime x)))", "problem": 116, "user": "504e12ade4b078edc5f593b7"}, {"code": "#(boolean (#{5, 53, 157, 173, 211, 257, 263, 373, 563, 593, 607, 653, 733, 947, 977, 1103} %))", "problem": 116, "user": "50fa01bce4b07934dda8b0ba"}, {"code": "(fn [n] \n  (let [prime (fn[n] (not (some #(zero? (mod n %)) (range 2 n))))\n        balanced (fn[n] (and (> n 2) (prime n) (= (* 2 n) (+ (last (filter prime (range n))) (first (filter prime (iterate inc (inc n))))))))] \n    (balanced n)))", "problem": 116, "user": "5093ca51e4b097f48cc38585"}, {"code": "(fn [n]\n\t(let [f (fn [x] (every? #(not= 0 (mod x %)) (range 2 x)))\n\t      m (first (filter f (iterate dec (dec n))))\n\t      o (first (filter f (iterate inc (inc n))))]\n\t  (and (> n 4) (= (bit-shift-left n 1) (+ m o)) (f n))))", "problem": 116, "user": "5142ea50e4b0c172af7558ca"}, {"code": "(fn balanced-prime? [n]\n  (let [is-prime? (fn [n] (empty? (filter #(zero? (mod n %)) (range 2 (dec n)))))\n        inc-prime (first (filter is-prime? (iterate inc (inc n))))\n        dec-prime (first (filter is-prime? (iterate dec (dec n))))]\n   (and (= (/ (+ dec-prime inc-prime) 2) n) (is-prime? n) (>= n 3))))", "problem": 116, "user": "50c8697ce4b00bb60fe0c53f"}, {"code": "(fn balanced-prime?- [n]\n  \"116. Create a function which takes an integer n, and returns true iff it is a                                                                                                                                   \n  balanced prime.\"\n  ;; According to Betrand's postulate, there always exists at least one prime                                                                                                                                      \n  ;; number p with n < p < 2n \u2212 2, or, for every n > 1 there is always at least                                                                                                                                    \n  ;; one prime p such that n < p < 2n.                                                                                                                                                                             \n  ;;                                                                                                                                                                                                               \n  ;; So built a sieve that ennumerates all primes up until the next prime                                                                                                                                          \n  ;; greater than n.                                                                                                                                                                                               \n  (if (< n 3)\n    false\n    (let [primes (loop [sieve (range 2 (inc (* 2 n)))\n                        res []]\n                   (if-let [prime (first sieve)]\n                     (if (> prime n)\n                       (conj res prime)\n                       (recur (filter #(not= 0 (mod % prime)) sieve) (conj res prime)))))\n          [next this previous] (reverse primes)]\n      ;; And look at the previous and next primes to see if n is balanced.                                                                                                                                         \n      (= n this (/ (+ next previous) 2)))))", "problem": 116, "user": "4e5eb843535d8a8b8723a2d4"}, {"code": "(fn perfp [n]\n   (letfn [(prime? [x]\n                   (and (> x 1)\n                        (empty?\n                          (filter #(= 0 (rem x %)) (range 2 x)))))]\n     (and (> n 2) (prime? n)\n          (= (- (first (filter prime? (iterate inc (inc n)))) n)\n             (- n (first (filter prime? (iterate dec (dec n)))))))))", "problem": 116, "user": "50f48298e4b004d364930527"}, {"code": "(fn prime-sandwich [p]\n  (let [siftlist-cache {}]   ;; cache intermediate dynamic table\n    (letfn [\n          (prime? [n]\n            ;; celebrates clojure's java interop, using BigInteger isProbablePrime with 5% certainty\n            (.isProbablePrime (BigInteger/valueOf n) 5))]\n\n          \n    (if (and (> p 2)\n             (even? p))\n      false\n      (if (or (not (prime? p))\n              (< p 5))\n        false\n        (letfn [(prep [n]\n                  (loop [v (dec n)]\n                    (if (prime? v)\n                      v\n                      (recur (dec v)))))\n                (nxtp [n]\n                  (loop [v (inc n)]\n                    (if (prime? v)\n                      v\n                      (recur (inc v)))))]\n          (if (= p (/ (+ (prep p) (nxtp p)) 2))\n            true\n            false)))) )))", "problem": 116, "user": "513cb853e4b0b86ece9f322b"}, {"code": "(fn [n]\n  (letfn [(prime? [x] (not (some #(zero? (mod x %)) (range 2 x))))]\n    (and\n     (> n 2)\n     (prime? n)\n     (let [prev (first (filter prime? (iterate dec (dec n))))\n           next (first (filter prime? (iterate inc (inc n))))]\n       (= n (/ (+ prev next) 2))))))", "problem": 116, "user": "512eb723e4b0b740abc5982b"}, {"code": "(fn prime-sandwich [n]\n  (letfn [(divisible? [n] (fn [k] (zero? (mod k n))))\n          (sieve [numbers] (let [[p & restn] numbers] \n                             (lazy-seq (cons p (sieve (remove (divisible? p) restn))))))\n          (naturals-from-2 [] (iterate inc 2))\n          (primes [] (sieve (naturals-from-2)))\n          (balanced? [[a b c]] (= b (/ (+ a c) 2) ))\n          (balanced-primes [] (->> (primes) (partition 3 1) (filter balanced?) (map second)))]\n    (->> (balanced-primes) (take-while #(<= % n)) (some #{n}) boolean )))", "problem": 116, "user": "51729002e4b044b2ef48a850"}, {"code": "(letfn\n  [(prime? [n]\n     (and (> n 1)\n          (not (some #(= (/ n %) (int (/ n %)))\n                     (range 2 (inc (/ n 2)))))))\n   (prime-offset [n op]\n     (->> (range 1 n) (filter #(prime? (op n %))) first))]\n  (fn f [n]\n    (and (prime? n)\n         (= (prime-offset n +)\n            (prime-offset n -)))))", "problem": 116, "user": "50b668dde4b08fb537db98f2"}, {"code": "(fn prime-sandwich\n  [pn]\n  (let [prime-number? (fn prime-number?\n                         [n]\n                         (if (= n 1)\n                           false\n                           (loop [i 2\n                                  prime? true]\n                             (if (or (= i n) (not prime?))\n                               prime?\n                               (recur (inc i) (not (zero? (mod n i))))))))]\n  (cond (< pn 3) false\n        (prime-number? pn)        \n        (let [pns (filter prime-number? (range))\n              i (.indexOf pns pn)\n              ppn (nth pns (dec i))\n              npn (nth pns (inc i))]\n          (= (/ (+ ppn npn) 2) pn))\n        :else false)))", "problem": 116, "user": "4f2942ace4b0d6649770a01e"}, {"code": "(fn balanced? [x]\n  (let [prime? (fn [x] (not-any? #(= 0 (mod x %)) (range 2 x)))]\n    (if (or (< x 3)\n          (not (prime? x)))\n      false\n      (let\n        [nextprime (first (filter prime? (iterate inc (inc x))))\n         lastprime (first (filter prime? (iterate dec (dec x))))]\n        (= x (/ (+ nextprime lastprime) 2))))))", "problem": 116, "user": "515737f0e4b0b0b4b87062d0"}, {"code": "(fn [n]\n  (letfn [(prime? [x]\n            (cond\n             (zero? x) false\n             (= 1 x) false\n             :else (let [max (Math/sqrt x)]\n                     (loop [i 2]\n                       (cond\n                        (> i max) true\n                        (= 0 (mod x i)) false\n                        :else (recur (inc i)))))))]\n    (if (prime? n)\n      (let [before (first (filter prime? (range (dec n) 0 -1)))\n            after (first (filter prime? (iterate inc (inc n))))]\n        (and before (= n (/ (+ before after) 2))))\n      false)))", "problem": 116, "user": "512d3304e4b040332b905b2d"}, {"code": "(fn prime-sandwich\n  [n]\n  (letfn [(is-prime [n] (cond\n                         (= n 1) false\n                         (= n 0) false\n                         :else (loop [divisor 2] \n                                 (if (< (* divisor divisor) (inc n)) \n                                   (if (zero? (mod n divisor)) false (recur (inc divisor))) \n                                   true))))]\n    (and (is-prime n)\n         (= (/ (+ (some #(if (is-prime %1) %1) (iterate dec (dec n)))\n                  (some #(if (is-prime %1) %1) (iterate inc (inc n))))\n               2)\n            n)\n         )))", "problem": 116, "user": "513d121fe4b0e544971636a2"}, {"code": "(fn [mx]\n   (if (or (< mx 3)  (some #(= % 0) (map #(rem mx %) [2 3  7 11]))) false \n       ((fn [[a b c & _]] \n                          (= (/ (+ a c) 2) b mx)\n                         \n          )\n   (loop [ lst [] , n 2]\n     (if (some #(= % 0) (map #(rem n %) lst) )\n       (recur lst (inc n))\n       (if (> n mx) (cons n lst)\n           (recur (cons n lst) (inc n)))) ))))", "problem": 116, "user": "5124619ae4b02c3f2a072ccd"}, {"code": "(fn balanced-prime? [n]\n  (letfn [(prime?\n            [n & {:keys [certainly] :or {certainly (rand-int Integer/MAX_VALUE)}}]\n            (. (biginteger n) (isProbablePrime certainly)))\n          (neighbor-prime [f n]\n            (first (filter prime? (iterate f (f n)))))]\n    (and (> n 2)\n         (prime? n)\n         (= n (/ (+ (neighbor-prime dec n) (neighbor-prime inc n)) 2)))))", "problem": 116, "user": "511b9017e4b00c2a1fa7ff6b"}, {"code": "(fn [x]\n  ( if (< x 3) false \n  (let [isprime (fn [y] (every? #(not= 0 (mod y %)) (rest (rest (range y))) ))\n        prevprime #(loop [a (dec %)] (if (isprime a) a (recur (dec a))))\n        nextprime (fn [y] (loop [a (inc y)] (if (isprime a) a (recur (inc a)))))\n        ] \n    (and (isprime x) (== x (/ (+ (prevprime x) (nextprime x)) 2))))))", "problem": 116, "user": "513b77f3e4b00f740c76c403"}, {"code": "(fn [candidate]\n   (letfn [(reinsert [table x prime]\n             (update-in table [(+ prime x)] conj prime))\n           (primes-step [table d]\n             (if-let [factors (get table d)]\n               (recur (reduce #(reinsert %1 d %2) (dissoc table d) factors)\n                      (inc d))\n               (lazy-seq (cons d (primes-step (assoc table (* d d) (list d))\n                                              (inc d))))))\n           (gen-primes [] (primes-step {} 2))]\n     (loop [primes (gen-primes)]\n       (if (< candidate (first primes))\n         false\n         (if (= candidate (second primes))\n           (let [next-primes (rest primes)\n                 lo-prime (first primes)\n                 hi-prime (second next-primes)]\n             (or (= candidate (/ (+ lo-prime hi-prime) 2))\n                 (recur next-primes)))\n           (recur (rest primes)))))))", "problem": 116, "user": "4f2e0369e4b0d6649770a064"}, {"code": "(fn [n]\n  (let [sieve (fn sieve [[p & rest]]\n                (lazy-seq (cons p (sieve (remove #(= 0 (mod % p)) rest)))))\n        [a b c] (->> (partition 3 1 (sieve (iterate inc 2)))\n                     (drop-while (fn [[a b c]] (< b n)))\n                     (first))]\n    (cond (not= b n) false\n          (= b (/ (+ a c) 2)) true\n          :else false)))", "problem": 116, "user": "5126dbabe4b083bb8f88cf0e"}, {"code": "(fn is-prime-sandwich?\n  [number]\n  (let [is-prime? (fn [n]\n        (if (= 2 n)\n          true\n          (if (or (= 1 n) (even? n))\n            false\n            (not (reduce #(or %1 (integer? (/ n %2))) false (range 3 n))))))]\n    (if (is-prime? number)\n      (let [primes-list (filter is-prime? (drop 1 (range)))\n            prev-prime (last (take-while #(< % number) primes-list))\n            next-prime (first (drop-while #(>= number %) primes-list))]\n        (if prev-prime\n          (= (- number prev-prime) (- next-prime number))\n          false))\n      false)))", "problem": 116, "user": "4dad76588e77d6ed63f12a44"}, {"code": "(fn [bp]\n  (not (empty?\n  \n        (filter #(and (= bp (second %))\n                      (= bp (/ (+ (first %) (last %)) 2)))                         \n                (take-while #(<= (second %) bp)\n                            ((fn grp [l]\n                                 (cons (take 3 l) (lazy-seq (grp (rest l)))))\n                             ((fn p [l s] \n                                (lazy-seq \n                                 (if (some (fn [n] (zero? (mod s n))) l)\n                                   (p l (inc s))\n                                   (cons s (p (conj l s) (inc s))))))\n                              [] 2)))))))", "problem": 116, "user": "5034b0e1e4b062bc5d7ae167"}, {"code": "(fn [n]\n  (let [p (loop [remaining (drop 3 (range))\n         check 2\n         primes []]\n    (if (and (> (count primes) 2) (>= (nth primes (- (count primes) 2)) n))\n      primes\n      (recur (rest remaining) (first remaining) (if (some #(= (rem check %) 0) primes) primes (conj primes check)))))\n        l (count p)\n        a (nth p (- l 3))\n        b (nth p (- l 2))\n        c (nth p (- l 1))]\n    (= b n (/ (+ a c) 2))))", "problem": 116, "user": "51899891e4b0288ada3dbdab"}, {"code": "(fn p116 [num]\n  (letfn [(prime? [num]\n            (->>\n             (map #(rem num %) (range 2 num))\n             (remove (complement zero?))\n             (empty?)))\n          (next-prime [num]\n            (first\n             (drop-while (complement prime?) (range (inc num) 4000))))\n          (prev-prime [num]\n            (first\n             (drop-while\n              (complement prime?)\n              (range (dec num) 0 -1))))]\n    (and\n     (> num 2)\n     (prime? num)\n     (= num\n        (/ (+ (next-prime num) (prev-prime num)) 2)))))", "problem": 116, "user": "500b61b1e4b03d00572d2d81"}, {"code": "(fn [num]\n  (letfn [(prime []\n            (letfn [(step [coll]\n                      (let [head (first coll)]\n                        (lazy-seq (cons head (step (filter #(pos? (mod % head)) coll))))))]\n              (step (range 2 Long/MAX_VALUE))))\n          (balanced-prime []\n            (map second (filter #(= (second %) (/ (+ (first %) (last %)) 2)) (partition 3 1 (prime)))))]\n    (= num (last (take-while #(<= % num) (balanced-prime))))))", "problem": 116, "user": "514d7e29e4b019235f6c0587"}, {"code": "(fn balanced-prime? [p]\n  (letfn [(prime? [p]\n                  (and (> p 1)\n                  (not-any? zero? (map #(mod p %) (range 2 p)))))]\n    (and (prime? p)\n         (let [prev-p (first (filter prime? (range (dec p) 1 -1)))\n               next-p (first (filter prime? (range (inc p) Integer/MAX_VALUE)))]\n           (and prev-p\n                (= (+ next-p prev-p) (* 2 p)))))))", "problem": 116, "user": "4f4e91a9e4b03ad3f0c10cca"}, {"code": "(fn [n] (let \n[ps ((fn pn [ls]  (cons (first ls)\n (lazy-seq (pn (filter #(not= (rem % (first ls)) 0) ls)) ) ))(drop 2 (range)))] \n(let\n[lsa (first (split-with (partial > n) ps))\nlsb (last (split-with (partial > n) ps))]\n(and (> n 3) (= n (first lsb)) (= (- (second lsb) (first lsb)) (- (first lsb) (last lsa)))))))", "problem": 116, "user": "517945dce4b0684c1c981a43"}, {"code": "(fn is-sp [n]\n  (letfn [(is-prime? [x]\n            (.isProbablePrime (BigInteger/valueOf x) 5))\n          (count-prime [f x]\n            (if (is-prime? x) x (count-prime f (f x))))\n          (last-prime [x] (count-prime dec x))\n          (next-prime [x] (count-prime inc x))]\n    (and (= (* 2 n)\n            (+ (last-prime (dec n)) (next-prime (inc n))))\n         (is-prime? n))))", "problem": 116, "user": "4eec82fe535d93acb0a668ae"}, {"code": "(fn [n]\n  (letfn [(prime [n]\n            (if (>= 1 n) false\n                (let [bound (+ 1 (int (Math/sqrt n)))\n                      s (range 2 bound)]\n                  (every? #(< 0 %) (map #(mod n %) s)))))\n          (next_prime [n iord]\n            (loop [n (+ n iord)]\n              (if (or (>= 2 n) (prime n))\n                n\n                (recur (+ n iord)))))]\n    (if (>= 2 n) false\n        (and (prime n) (= n (/ (+ (next_prime n -1) (next_prime n 2)) 2))))))", "problem": 116, "user": "518ccf6be4b05e6c8537e386"}, {"code": "(fn [n]\n  (let [prime? (fn [n] (and (> n 1) (not-any? #(= (rem n %) 0) (range 2 n))))\n        primes (filter prime? (range))\n        prime-before (fn [n] (last (take-while #(< % n) primes)))\n        prime-after (fn [n] (first (drop-while #(<= % n) primes)))]\n    (if (and (prime? n) (> n 2))\n\t  (= n (/ (+ (prime-before n) (prime-after n)) 2))\n      false)))", "problem": 116, "user": "514721c6e4b0d520409ed392"}, {"code": "(fn balanced\n  [n]\n  (let [is-prime? (fn [n]\n                    (zero? (count (filter #(zero? (rem n %)) (range 3 n 2)))))\n        primes-around-n (fn [n]\n                          (cons 2 (filter #(is-prime? %) (range 3 (+ 100 n) 2))))\n        in-vector (into [] (primes-around-n n))\n        index-of-n (.indexOf in-vector n)]\n    (if (> index-of-n 0)\n      (= (/ (+ (get in-vector (+ index-of-n 1)) (get in-vector (- index-of-n 1))) 2) n)\n      false)))", "problem": 116, "user": "50052fd0e4b0678c553fc45d"}, {"code": "(fn balanced-prime? [n]\n  (let [factors (cons 2 (iterate (partial + 2) 3))\n        prime? (fn [n] (not-any? #(zero? (mod n %))\n                                 (take-while #(<= % (inc (Math/sqrt n))) factors)))\n        prime-step (fn [n s] (first (drop-while (complement prime?) (rest (iterate (partial + s) n)))))]\n    (and (> n 3)\n         (prime? n)\n         (= n (/ (+ (prime-step n 2) (prime-step n -2)) 2)))))", "problem": 116, "user": "5032b066e4b00c0952a257ea"}, {"code": "(fn [n]\n  (and (> n 3)\n  (let [p (fn [x] (every? #(< 0 (mod x %)) (range 2 x)))\n        b (first (filter p (reverse (range 2 n))))\n        a (first (filter p (drop (+ n 1) (range))))]\n    (and (p n) (= n (/ (+ a b) 2))))))", "problem": 116, "user": "4fa340b4e4b081705acca18c"}, {"code": "(fn [n]\n  (let [prime (fn [x] (= 1 (first (filter #(= 0 (rem x %)) (reverse (range 1 (inc (Math/sqrt x))))))))]\n    (if (and (> n 3) (prime n))\n      (let [p1 (first (filter prime (iterate inc (inc n))))\n            p2 (first (filter prime (iterate dec (dec n))))]\n        (= n (/ (+ p1 p2) 2)))\n      false)\n    ))", "problem": 116, "user": "51424cc8e4b0b50abeb46b34"}, {"code": "(fn [x]\n  (let [p? (fn [n] (not-any? zero? (map #(mod n %) (range 2 n))))\n        a (first (filter p? (iterate dec (dec x))))\n        b (first (filter p? (iterate inc (inc x))))]\n    (and \n     (> x 3)\n     (p? x)\n     (= x (/ (+ a b) 2)))))", "problem": 116, "user": "5164867fe4b003cf19fdde3e"}, {"code": "(fn [n]\n   (letfn [(is-prime? [n]\n             (if (= 2 n)\n               true\n               (if (or (= 1 n) (and (even? n) (> 2)))\n                 false\n                 (not (reduce #(or %1 (integer? (/ n %2))) false (range 3 n))))))]\n    (if (is-prime? n)\n     (let [primes-l (filter is-prime? (drop 1 (range)))\n           prev-prime (last (take-while #(< % n) primes-l))\n           next-prime (first (drop-while #(>= n %) primes-l))]\n       (if prev-prime  \n         (= n (/ (+ (last (take-while #(< % n) primes-l))\n                    (first (drop-while #(>= n %) primes-l)))\n                 2))\n           false))\n      false)))", "problem": 116, "user": "51bec919e4b013aa0d74b800"}, {"code": "(fn [x]\n      (letfn [(p [n]\n                (and (> n 1)\n                  (apply = false\n                  (map\n                    #(= 0 (mod n %))\n                    (range 2 (+ (quot n 2) 1))))\n                )\n                )]\n        (if (p x)\n          (loop [b (- x 1)\n                 a (+ x 1)]\n            (cond\n              (and (p b) (p a)) (= x (/ (+ a b) 2))\n              (= 0 b) false\n              1 (recur (if-not (p b) (- b 1) b)\n                (if-not (p a) (+ a 1) a))))\n          false)))", "problem": 116, "user": "51b3f109e4b0f094dd986fa9"}, {"code": "(fn\n  [x]\n  (letfn [(primes-past\n           [n]\n           (loop [primes [2]]\n             (let [candidates (range (inc (last primes)) Double/POSITIVE_INFINITY)\n                   prime      (first (filter (fn [x] (not-any? #(= 0 (rem x %)) primes)) candidates))\n                   primesa    (conj primes prime)]\n               (if (> prime n)\n                 primesa\n                 (recur primesa)))))]\n    (if (< x 3)\n      false\n      (let [xs (set (primes-past x))\n            y  (apply max xs)\n            ys (disj xs y x)\n            z  (apply max ys)]\n        (not (not (and (xs x) (= (* 2 x) (+ y z)))))))))", "problem": 116, "user": "51307b84e4b08c712d3fae39"}, {"code": "(fn [n]\n           (let [p? (fn [n] (if (= 1 n) false (not (some #{0} (map #(rem n %) (range 2 n))))))\n                 f (fn [n & f]\n                     (cond (= n 1) 2\n                           (= n 2) 3\n                           :else (loop [n (if f (inc n) (dec n))]\n                                   (if (p? n)\n                                     n\n                                     (recur (if f (inc n) (dec n)))))))]\n             (if (p? n)\n               (= n (/ (+ (f n n) (f n)) 2))               \n               false)))", "problem": 116, "user": "50a5b7e9e4b0aa96157e2610"}, {"code": "(let [\n    slow-prime? (fn [x] (and (<= 2 x) (= (inc (mod (apply * (range 1N x)) x)) x)))\n    prime? (memoize slow-prime?)\n    iterprime (fn [f x] (first (drop-while (complement prime?) (iterate f (f x)))))\n    nextprime (fn [x] (iterprime inc x))\n    lastprime (fn [x] (if (= 2 x) 2 (iterprime dec x)))\n    primesand? (fn [x] (and (prime? x) (= (- x (lastprime x)) (- (nextprime x) x))))]\n    primesand?\n)", "problem": 116, "user": "51cbdee1e4b08d8387cbede1"}, {"code": "(fn [n]\n  (if (<= n 3) false\n            (letfn [(prime \n                     ([]\n                      (cons 2 (prime [2] 3)))\n                     ([coll n]\n                      (lazy-seq\n                       (if (every? #(pos? (rem n %)) coll)\n                         (cons n (prime (conj coll n) (inc n)))\n                         (prime coll (inc n))))))]\n              (let [p (partition 3 1 (prime)) v (last \n                                                 (take-while #(>= n (second %)) p))]\n                (and (= n (second v)) (= (second v) (/ (+ (first v) (nth v 2)) 2)))))))", "problem": 116, "user": "51780f88e4b03d69594194c9"}, {"code": "(fn [n]\n(if (< n 3)\n  false\n  (let [pr? (fn [x] (every? #(not= (mod x %1) 0) (range 2 x)))\n      pr-seq (filter #(and (> %1 1) (pr? %1)) (range 2 (inc n)))\n      pr-seq1 (first (filter #(and (> %1 n) (pr? %1)) (range)))\n      len (count pr-seq)\n      ls (last pr-seq)\n      a1 (>= len 2)\n      a2 (= ls n)\n      a4 (nth pr-seq (- len 2))\n      a3 (= (/ (+ a4 pr-seq1) 2) ls)]\n  (and a1 a2 a3))))", "problem": 116, "user": "50a5f72fe4b0aa96157e2611"}, {"code": "(fn [x]\n  (letfn [(p [x] (every? #(pos? (mod x %)) (range 2 x)))]\n (and (p x)\n      (> x 2)\n      (= (count (take-while #(-> % (+ x 1) p not) (range)))\n         (count (take-while #(-> (- -1 %) (+ x) p not) (range)))))))", "problem": 116, "user": "5054bc87e4b0b1b9d1860eb0"}, {"code": "(fn sandwich [x]\t\t\t\t\t\t\t\n\t(let [ primes                  \n\t\t\t((fn primes [upper-limit]\n\t\t\t\t(if (< upper-limit 2) (list)\n\t\t\t\t\t(loop [numbers (range 3 (inc upper-limit) 2) results [2]]\n\t\t\t\t\t\t(let [next-number (first numbers)]\n\t\t\t\t\t\t\t(if (> (* next-number next-number) upper-limit)\n\t\t\t\t\t\t\t\t(concat results numbers)\n\t\t\t\t\t\t\t\t(recur\n\t\t\t\t\t\t\t\t\t(sort (seq (clojure.set/difference (set numbers) (set (range next-number (inc upper-limit) next-number)))))\n\t\t\t\t\t\t\t\t\t(conj results next-number))))))) 1200)\n\t\n\t\t\tr \n\t\t\t (get (apply merge\n\t\t\t\t(map #(hash-map\n\t\t\t\t\t(first %)\n\t\t\t\t\t(if (= (first %) (/ (+ (second %) (nth % 2)) 2)) true false))\n\t\t\t\t\t\t(map #(vector % %2 %3)\n\t\t\t\t\t\t\tprimes (cons 0 primes) (drop 1 primes)))) x) ]\n\t(if (nil? r) false r)))", "problem": 116, "user": "51c09719e4b0c9c82288293c"}, {"code": "#(letfn [(p\n            ([] (p (drop 2 (range))))\n            ([[h & t]] (lazy-cat [h] (p (filter (fn [x] (< 0 (mod x h))) t)))))\n\n          (t [] (filter\n                 (fn [[a b c]] (= b (/ (+ a c) 2)))\n                 (partition-all 3 1 (p))))]\n\n    (= % (second (last (take-while (fn [[a b c]] (and (<= b % ))) (t))))))", "problem": 116, "user": "51b9d1f0e4b0e871ca49590b"}, {"code": "(fn [n]\n  (letfn [(prime? [n]\n            (let [trials (range 2 (+ 1 (Math/round (Math/sqrt n))))]\n              (not-any? zero? (map #(rem n %) trials))))]\n    (and (prime? n)\n      (if-let [prev (first (drop-while (comp not prime?) (range (dec n) 1 -1)))]\n        (let [nxt (first (drop-while (comp not prime?) (iterate inc (inc n))))\n              balanced? (fn [prev nxt] (= n (/ (+ prev nxt) 2)))]\n          (balanced? prev nxt))))))", "problem": 116, "user": "51cdd3f0e4b0e42293a2254b"}, {"code": "(fn [n]\n  (letfn [(prime? [n] (every? #(not= (mod n %) 0) (range 2 (Math/sqrt (inc n)))))]\n    (if (or (not (prime? n)) (<= n 2))\n      false\n      (let [a (first (filter prime? (drop (inc n) (range))))\n            b (first (filter prime? (range (dec n) 1 -1)))]\n        (= (+ a b) (+ n n))))))", "problem": 116, "user": "51efd397e4b0249c592fbdeb"}, {"code": "(fn [x]\n   (let [limit 11000\n         prime? (memoize (fn [y] \n                           (if (> y 2)\n                             (not-any? #(= 0 (mod y %)) (range 2 (inc (/ y 2))))\n                             (= y 2)\n                           )\n                         )\n                )\n         first-prime (fn [s] (first (drop-while (complement prime?) s)))\n         last-prime (fn [b] (first-prime (reverse (range 2 b))))\n         next-prime (fn [b] (first-prime (range (inc b) limit)))\n         ]\n     (if (and (> x 4) (prime? x))\n       (= x (/ (+ (last-prime x) (next-prime x)) 2))\n       false)\n   )\n )", "problem": 116, "user": "51ba8f82e4b0fe3ecfb46434"}, {"code": "(fn [num]\n  (or (let [prime? (fn [x]\n                     (and (not= x 0)\n                          (not= x 1)\n                          (not (some #(zero? (mod x %))\n                                     (range 2 (inc (Math/sqrt x)))))))]\n        (when (prime? num)\n          (when-let [down (first (filter prime? (range (dec num) 0 -1)))]\n            (when-let [up (first (filter prime? (range (inc num) Double/POSITIVE_INFINITY)))]\n              (println num down up)\n              (= (+ up down) (* 2 num))))))\n      false))", "problem": 116, "user": "4eae5fe4535d7eef30807325"}, {"code": "(fn [n]\n  (let [is-prime?\n        (fn [k]\n          (and (> k 1)\n               (every? #(not= (rem k %) 0)\n                       (drop 2 (take-while #(<= (* % %) k) (range))))))\n        first-prime #(first (filter is-prime? %))]\n    (and (is-prime? n) (let [n1 (first-prime (drop (inc n) (range)))\n                             n2 (first-prime (range (dec n) 1 -1))]\n                         (and n1 n2 (= (* n 2) (+ n1 n2)))))))", "problem": 116, "user": "508157b2e4b0946d0443855c"}, {"code": "(fn [n]\n  (letfn [(prime? [x]\n            (and (>= x 2)\n                 (not-any? #(zero? (mod x %)) (range 2 x))))]\n    (and (> n 2)\n         (prime? n)\n         (let [[a b] (map (partial some #(when (prime? %) %)) [(iterate inc (inc n)) (range (dec n) 1 -1)])]\n           (== n (/ (+ a b) 2))))))", "problem": 116, "user": "507b7dbee4b09034bfeeb71e"}, {"code": "(fn [c]\n  (let [cs (loop [ps [2] n 3]\n    (if (< c (last ps))\n      (reverse ps)\n      (let [p (loop [x n] (if (every? #(pos? (rem x %)) ps) x (recur (+ 2 x))))]\n        (recur (conj ps p) (+ 2 p)))))] (and (< 3 (count cs)) (= c (second cs)) (= (* 2 c) (+ (first cs) (second (rest cs)))))))", "problem": 116, "user": "51bd1a0de4b0df1216cefd93"}, {"code": "(fn balanced-prime? [n]\n   (let [primes ((fn sieve [[x & xs]]\n                   (lazy-seq \n                    (cons x\n                    (sieve \n                     (filter #(> (mod % x) 0) \n                             xs))))) (iterate inc 2))\n         is-prime (= n (last (take-while #(>= n %) primes)))\n         previous (last (take-while #(> n %) primes))\n         nxt (some #(if (< n %) %) primes)]\n     (and\n       is-prime\n       (not (nil? previous))\n       (= n (/ (+ previous nxt) 2)))))", "problem": 116, "user": "51e58e02e4b0efabf93c02d0"}, {"code": "(fn [ n ]\n  (let [ f (fn [[plist n n-prime? p-1 p p+1 :as t] k]\n    ;(println t)\n    (cond\n        (not n-prime?) t\n        (> p+1 n)   t\n        (reduce\n            #(and %1 \n            (not= 0 (mod k %2)))\n            true plist)                 [ (if (> (* 2 n) (* k k)) (conj plist k) plist) n true p p+1 k]\n        :else [ plist n (and n-prime? (not= k n)) p-1 p p+1]))\n        [plist n n-prime? p-1 p p+1] (reduce f [[2] n true 0 0 0] (range 3 (* 2 n)))\n        ]\n   (if (and (> n 2) n-prime?)\n    (do (if (= (/ (+ p-1 p+1) 2) n)(println [plist n n-prime? p-1 p p+1]))(= (/ (+ p-1 p+1) 2) p))\n    false)))", "problem": 116, "user": "51f59607e4b0abb92f97f9d5"}, {"code": "(fn [p]\n  (let [prime? (fn [x] (every? #(< 0 (mod x %)) (range 2 x)))]\n    (if (and (> p 2) (prime? p))\n      (let [next-p (first (filter prime? (iterate inc (inc p)))) \n            prev-p (first (filter prime? (range (dec p) 0 -1)))]\n        (= p (/ (+ next-p prev-p) 2)))\n      false)))", "problem": 116, "user": "52039e12e4b0fb7e47ea51ff"}, {"code": "(fn balanced-prime?\n  [n]\n  (let [prime? (fn [x] (= (count (filter #(zero? (mod x %)) (range 2 x))) 0))\n        pre-prim (fn inner-pre [x] (if (prime? x) x (inner-pre (dec x))))\n        next-prim (fn inner-next [x] (if (prime? x) x (inner-next (inc x))))]\n    (and\n      (> n 2)\n      (prime? n)\n      (= n (/ (+ (pre-prim (dec n)) (next-prim (inc n))) 2)))))", "problem": 116, "user": "52084f75e4b01ce6bbf31dde"}, {"code": "(let [mp \n\t\t\t(set (let [primes (remove \n\t\t\t\t\t\t\t\t\t#(some (fn [x] (zero? (rem % x))) (range 2 %))\n\t\t\t\t\t\t\t\t\t(range 2 1200))]\n\t\t\t\t\t\t\t\t(map second \n\t\t\t\t\t\t\t\t\t(filter #(= (second %) \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(/ (+ (first %) (last %)) 2))\n\t\t\t\t\t\t\t\t\t(partition 3 1 primes)))))]\n\t(fn [x] \n\t\t(if (mp x) true false)))", "problem": 116, "user": "520242bae4b030ee0c5b26e3"}, {"code": "(fn [x] (and (> x 2) (let [p (fn [n] (every? #(> (rem n %) 0) (range 2 (inc (quot n 2))))) i (fn [n f] (second (filter p (iterate f n))))] (and (p x) (= x (/ (+ (i x dec) (i x inc)) 2))))))", "problem": 116, "user": "51f66e0ee4b06ff1c25c52c3"}, {"code": "(fn [n]\n  (let [prime? (memoize #(empty? (filter integer? (map / (repeat %) (range 2 %)))))\n        findp (fn [f x] (first (filter prime? (iterate f (f x)))))\n        mean (fn [x y] (/ (+ x y) 2))]\n    (if (and (> n 2) (prime? n))\n      (= n (mean (findp inc n) (findp dec n)))\n      false)\n  ))", "problem": 116, "user": "5201572be4b0d7096e99ddbb"}, {"code": "(fn [m]\n  (letfn [(prime? [n] (empty? (filter #(integer? (/ n %)) (range 2 n))))]\n    (and (> m 2)\n         (prime? m)\n         (= (* 2 m)\n            (+\n             (first (filter prime? (range (inc m) 10000000000)))\n             (first (filter prime? (range (dec m) 0 -1))))))))", "problem": 116, "user": "51aa2b4fe4b04e3dc0c27b21"}, {"code": "(fn [n] \n  (letfn [(p? [x] (.isProbablePrime (BigInteger/valueOf x) 5))\n          (g [f x] (->>\n                    x\n                    (iterate f)\n                    rest\n                    (drop-while #(not (p? %)))\n                    first))]\n    (if (p? n)\n      (= (+ (g inc n) (g dec n)) (* 2 n))\n      false)))", "problem": 116, "user": "51944aaae4b0142f60b4aedc"}, {"code": "(fn balanced-prime [n]\n  (letfn [(prime? [n] (empty? (remove #(not= 0 (rem n %)) (range 2 (inc (quot n 2))))))\n          (prev-prime [n] (loop [m (dec n)] (if (prime? m) m (recur (dec m)))))\n          (next-prime [n] (loop [m (inc n)] (if (prime? m) m (recur (inc m)))))\n          ]\n    (and (>= n 5) (prime? n) (= n (quot (+ (next-prime n) (prev-prime n)) 2)))))", "problem": 116, "user": "52015698e4b0d7096e99ddba"}, {"code": "(fn [n]\n  (let [c (fn [s] (some zero? (map #(mod s %) (range 2 s))))]\n(if (or (< n 5) (c n))\n    false\n    (loop [t (inc n)\n           b (dec n)]\n      (cond\n        (and (c t) (c b))\n          (recur (inc t) (dec b))\n        (or (c t) (c b))\n          false\n        :e\n          true)))))", "problem": 116, "user": "51f28a64e4b0210f90e7454e"}, {"code": "(fn balanced\n  [n]\n  (let [primes (->> [false 2 #{}]\n                    (iterate\n                     (fn [[_ next found]]\n                       (if (some #(zero? (rem next %)) found)\n                         [false (inc next) found]\n                         [next (inc next) (conj found next)])))\n                    (map first)\n                    (filter identity))\n        find-sandwich (fn find-sandwich\n                        [[i j k :as solution] [p & rst]]\n                        (cond (= j n) solution\n                              (> k n) [nil false nil]\n                              :default (recur [j k p] rst)))\n        [prev found next :as sandwich] (find-sandwich [0 2 3] primes)]\n    (and found (= found (/ (+ prev next) 2)))))", "problem": 116, "user": "51f9527fe4b09be9c177e549"}, {"code": "(fn [n]\n  (let [isprime? #(if (< % 2)\n                    false\n                    (->> % Math/sqrt int inc (range 2)\n                         (map (partial mod %))\n                         (every? (partial not= 0))))\n        check (fn [l r]\n                (let [lp (isprime? l)\n                      rp (isprime? r)]\n                  (cond\n                    (and lp rp) true\n                    (or lp rp) false\n                    :else (recur (dec l) (inc r)))))]\n    (and \n      (isprime? n)\n      (check (dec n) (inc n)))))", "problem": 116, "user": "514c2d05e4b02b8cbb2a9278"}, {"code": "(fn [num]\n  (letfn [(divides? [k n] (= (rem n k) 0))\n          (prime? [n]\n                  (if (< n 2)\n                    false\n                    (empty? (filter #(divides? % n) (take-while #(<= (* % %) n) (range 2 n))))))\n          (find-nearest-prime [nums] \n                              (loop [xs nums]\n                                (cond (not (seq xs)) 2\n                                (prime? (first xs)) (first xs)\n                                :else (recur (rest xs)))))]\n    (let [lower-range (range (dec num) 0 -1)\n          upper-range (range (inc num) (* num num))]\n           (and (prime? num)(= (* 2 num) (+ (find-nearest-prime lower-range) (find-nearest-prime upper-range)))))))", "problem": 116, "user": "51857e64e4b0da5a5be3babe"}, {"code": "(fn balanced [k]\n  (letfn [(prime [n]\n            (let [divisions (map #(mod n %) (range 2 (inc (/ n 2))))\n                  isprime (empty? (filter zero? divisions))] (and (> n 2) isprime)))\n          (next-prime [n direction]\n            (let [offset direction]\n              (loop [i offset]\n                (println i)\n                (if (prime (+ n i)) (+ n i)\n                    (if (> 0 (+ n i)) n\n                        (recur (+ direction i)))))))]\n\n    (let [nxt (next-prime k 1)\n          prv (next-prime k -1)]\n      (and (prime k) (= k (/ (+ nxt prv) 2)) (> prv 0)))))", "problem": 116, "user": "4fbd12a5e4b081705acca2fd"}, {"code": "(fn [n]\n  (let [p? (fn [x] (not-any? #(= 0 (rem x %)) (range 2 x)))\n        fp (fn [l] (first (filter p? l)))]\n    (if (and (> n 2) (p? n))\n      (= n (/ (+ (fp (range (dec n) 1 -1))\n                 (fp (drop (inc n) (range))))\n              2))\n      false)))", "problem": 116, "user": "522b922ee4b0d34ee08e71c3"}, {"code": "(fn [n]\n  (letfn [(prime? [n]\n            (cond (< n 2) false\n                  (= n 2) true\n                  :else\n                  (empty?\n                   (filter #(zero? (mod n %)) (range 2 n)))))\n          (primes [] (filter #(prime? %) (range)))]\n    (and (prime? n)\n         (let [s (take-while #(<= % n) (primes))\n               n1 (nth (primes) (count s))\n               n0 (take-last 2 s)]\n           (= (/ (+ (first n0) n1) 2) n)))))", "problem": 116, "user": "4f2d5f5de4b0d6649770a05a"}, {"code": "(fn [n]\n  (and (> n 3) \n       (let [p? (fn [x] (every? #(not= 0 (rem x %)) (range 2 x)))\n             ps (filter p? (range))]\n         (and (p? n)\n              (let [l (last (take-while #(> n %) ps))\n                    r (first (filter #(< n %) ps))]\n                (= (* 2 n) (+ l r)))))))", "problem": 116, "user": "52479487e4b05ef8e38e6373"}, {"code": "(fn [a]\n  (letfn [\n    (prime? [x] (not (some #(zero? (rem x %)) (range 2 x))))\n    (prev-prime [x] (first (filter prime? (range (dec x) -2 -1))))\n    (next-prime [x] (first (filter prime? (range (inc x) Long/MAX_VALUE))))]\n    (and (> a 2) (prime? a) (= a (/ (+ (prev-prime a) (next-prime a)) 2)))))", "problem": 116, "user": "50bc23e4e4b0594b91591c3c"}, {"code": "(fn [x]\n   (let [isp (fn [p]\n               (and\n                (> p 1)\n                (zero?\n                 (count\n                  (filter\n                   #(= (mod p %) 0)\n                   (range 2 (inc(Math/sqrt p))))))))\n         nextp (fn [p]\n                 (if (isp p)\n                   p\n                   (recur (inc p))))\n         prevp (fn [p]\n                 (if (< p 0)\n                   1.5\n                   (if (isp p)\n                     p\n                     (recur (dec p)))))]\n     (and (isp x) (= (* 2 x) (+ (nextp (inc x)) (prevp (dec x)))))))", "problem": 116, "user": "52586d24e4b0cb4875a45cb0"}, {"code": "(fn balanced-prime [n]\n    (let [isprime? (fn [n] (not-any? #(= 0 (mod n %)) (range 2 n)))\n          nextprime (fn [n] (first (filter isprime? (iterate inc (inc n)))))\n          prevprime (fn [n] (first (filter isprime? (iterate dec (dec n)))))]\n        (and (> n 2)\n             (isprime? n)\n             (= n (/ (+ (nextprime n) (prevprime n)) 2)))))", "problem": 116, "user": "5165a235e4b079ad97ec44ac"}, {"code": "(let [primes ((fn sieve [s] \n                   (cons (first s) (lazy-seq \n                                     (sieve (filter \n                                              #(not= 0 (mod % (first s))) \n                                              (rest s)))))) \n                  (iterate inc 2))\n         balanced-primes (map second \n                              (filter (fn [[p e n]] \n                                        (= (* 2 e) (+ p n))) \n                                      (partition 3 1 primes)))]\n     (fn [n] (= n (first (drop-while #(< % n) balanced-primes)))))", "problem": 116, "user": "5246e945e4b0644eb7b0783b"}, {"code": "(fn [x]\n  (letfn [(is-prime [x] \n            (and (> x 1)\n                 (not (some #(= 0 (mod (/ x %) 1)) \n                            (range 2 (+ 1 (/ x 2)))))))\n          (prime-after [x]\n            (first (filter is-prime (iterate inc (+ 1 x)))))\n          (prime-before [x]\n            (first (filter is-prime (take-while #(> % 2) (iterate dec (- x 1)))))) ]\n    (and \n      (is-prime x)\n      (not (nil? (prime-before x)))\n      (= x (/ \n             (+ (prime-before x) (prime-after x))\n             2)))))", "problem": 116, "user": "5141abf1e4b02fd87f5064c3"}, {"code": "(fn b-prime? [n]\n   (let [prime? (fn [n]\n\t\t\t\t\t(cond (> n 2)(every? pos? (map #(mod n %) \n\t\t\t\t\t\t(range 2 (inc(Math/sqrt n)))))\n\t\t\t\t\t\t\t(= n 2) true\n\t\t\t\t\t\t\t:else false))\n\t   np (first (filter prime? (iterate inc (inc n)) ))\n       pp (first (filter prime? (take-while pos? (iterate dec (dec n)) )))] \n     (and pp (prime? n) (= n (/ (+ np pp) 2)))))", "problem": 116, "user": "523a9fc9e4b081681ca7adca"}, {"code": "(fn [x]\n  (if (<= x 2)\n    false\n    \n  (let [is-prime? (fn [a] \n                    (let [cap (->> a Math/sqrt Math/ceil int)]\n                    (cond \n                     (< a 2) false\n                     (= 2 a) true \n                     :else (not-any? zero? (map #(rem a %) (range 2 (inc cap)))))))\n        next-prime (first (drop-while #(not (is-prime? %)) (iterate inc (inc x))))\n        prev-prime (first (drop-while #(not (is-prime? %)) (iterate dec (dec x))))]\n    (and\n         (is-prime? x) \n         (= prev-prime (- x (- next-prime x)))\n         )\n    )\n  )\n  )", "problem": 116, "user": "523f0bbfe4b01c266ffa7f91"}, {"code": "(fn [n]\n  (let [sieve (fn sieve [s] (lazy-seq (cons (first s)\n                                        (sieve (filter #(not= (rem % (first s)) 0)\n                                                 (rest s))))))\n        [a b c] (first (filter #(>= (second %) n) (partition 3 1 (sieve (iterate inc 2)))))\n        ]\n    (and (= b n)\n         (= (+ a c) (* 2 b)))))", "problem": 116, "user": "524cdd51e4b0752c4cb68ccc"}, {"code": "(fn bp? [n]\n  (letfn [(isprime? [n]\n            (if (< n 2)\n              false\n              (empty? (filter #(= (mod n %1) 0)\n                              (range 2 (inc (Math/sqrt n)))))))\n          (nextprime [op n]\n            (loop [i (op n)]\n              (if (isprime? i) i (recur (op i)))))]\n    (and (>= n 5) (isprime? n)\n         (= (/ (+ (nextprime inc n) (nextprime dec n)) 2) n))))", "problem": 116, "user": "511e763ce4b03e81d390ac29"}, {"code": "(fn [n]\n    (let [is-prime?  (fn [x] (and (> x 1) (nil? (some #(zero? (mod x %)) (take-while #(<= (* % %) x) (iterate inc 2))))))]\n      (and\n        (> n 4)\n        (is-prime? n)\n        (let [prev-prime (first (filter is-prime? (iterate dec (dec n))))\n              next-prime (first (filter is-prime? (iterate inc (inc n))))]\n          (= n (/ (+ prev-prime next-prime) 2))))))", "problem": 116, "user": "525f51bde4b0cb4875a45dc8"}, {"code": "(fn [x]\n      (letfn [(sieve [s]\n                (cons (first s)\n                  (lazy-seq (sieve (filter #(not= 0 (mod % (first s)))\n                                     (rest s))))))\n              (primes [s]\n                (take-while (partial >= s) (sieve (iterate inc 2))))]\n        (cond (not= x (last (primes x))) false\n              :else (= x (/ (+ (last (take (inc (count (primes x))) (sieve (iterate inc 2))))\n                               (first (take-last 2 (primes x))))\n                            2))\n        )\n      )\n    )", "problem": 116, "user": "5272d4b7e4b03e8d9a4a7453"}, {"code": "(fn balanced-prime? [n]\n  (let [prime? (fn [n]\n                 (loop [i 2]\n                   (cond\n                     (< n 2) false\n                     (or (> (* i i) n) (= n 2)) true\n                     (= (mod n i) 0) false\n                     :else (recur (inc i)))))\n        next-prime (fn [n]\n                   \t (first (drop-while (complement prime?) (range n (* 2 n)))))\n        prev-prime (fn [n]\n                      (if (< n 2)\n                        0\n                        (first (drop-while (complement prime?) (range n (/ n 2) -1)))))\n        p (prev-prime (dec n))\n        q (next-prime (inc n))]\n    (if (and (prime? n) (= (/ (+ p q) 2) n))\n      true\n      false)))", "problem": 116, "user": "526ee63de4b03e8d9a4a733f"}, {"code": "(fn is-balanced-prime [n]\n  (let [previousProbablePrime \n          (fn [n]\n            (loop [n (dec n)]\n              (if (.isProbablePrime (biginteger n) 500)\n                n\n                (recur (dec n)))))\n        n-prime (.nextProbablePrime (biginteger n))\n        p-prime (previousProbablePrime n)]\n    (and (.isProbablePrime (biginteger n) 500) \n         (= n (/ (+ n-prime p-prime) 2)))))", "problem": 116, "user": "52463059e4b09dbe66b56198"}, {"code": "(fn a [m] (letfn [(prime? [x](if(< x 2)(identity false)(not-any? #(zero? (mod x %)) (range 2 x))))(primes [n] (let [out [2]] (loop [i 3 o out] (if-not(=(count o)n)(recur (inc i) (if(prime? i)(conj o i)(identity o)))(identity o)) )))(n-prime [n] (loop [i 0 o 2 x 3] (if-not(= i n)(recur (if(prime? x)(inc i)(identity i)) (if(prime? x)(identity x)(identity o)) (inc x))(identity o))))](if(or(not(prime? m))(= m 2))(identity false)(let [x (loop [i (dec m)] (if(prime? i)(identity i)(recur (dec i)))) y (loop [i (inc m)] (if(prime? i)(identity i)(recur (inc i))))] (= (/ (+ x y) 2) m)))))", "problem": 116, "user": "527a8eb7e4b03e8d9a4a755f"}, {"code": "(let [R range r (R 2 1200)\n      g (set (map second \n                 (filter (fn [[a b c]] \n                           (= (- b a) (- c b))) \n                         (partition 3 1 \n                                    (take 300 (remove \n                                                (set \n                                                  (for [x r \n                                                        y (R (* 2 x) 1200 x)]\n                                                    y)) r))))))]\n  #(contains? g %))", "problem": 116, "user": "512f06c5e4b0762be4c7aad7"}, {"code": "(fn [x] (let [prime?     #(.isProbablePrime (biginteger %) 7)\n              next-prime  (fn [x] (first (filter prime? (iterate inc (inc x)))))\n              last-prime  (- (* 2 x) (next-prime x))]\n          (and (prime? last-prime) (= x (next-prime last-prime)))))", "problem": 116, "user": "51c19873e4b0d204dbe2ca0d"}, {"code": "(fn balanced-prime? [n]\n   (letfn [(prime? [nu](and (> nu 1)(empty?(filter #(= 0(rem nu %))(range 2 nu)))))\n           (neib [inc-dec nu](loop [x (inc-dec nu)](cond (prime? x) x\n                                                         (<= x 1) 0\n                                                         :else(recur (inc-dec x)))))]\n     (and (prime? n) (= n(/ (+ (neib dec n)(neib inc n))2)))    \t \n    )\n  )", "problem": 116, "user": "5274eb56e4b03e8d9a4a74bb"}, {"code": "(fn [-test]\n   (if-let [exist (last (take-while #(<= ((comp last butlast) %) -test)\n                                    (filter #(let [cox (take-last 3 %)\n                                                   f (first cox)\n                                                   l (last cox)\n                                                   s (/ (+ f l) 2)]\n                                               (= s (second cox)))\n                                            (iterate (fn find-next-p\n                                                       [currents]\n                                                       (conj currents (loop [possible (inc (last currents))]\n                                                                        (if (not-any? #(= 0 (mod  possible %)) currents)\n                                                                          possible\n                                                                          (recur (inc possible)))\n                                                                        ))) [2]))))]\n     (= (last (butlast exist)) -test)\nfalse\n     ))", "problem": 116, "user": "50550f43e4b0b1b9d1860eb7"}, {"code": "(fn [n]\n  (letfn [(prime? [n] (every? #(not= 0 (mod n %)) (range 2 n)))]\n    (let [n1 (first (filter prime? (iterate dec (dec n))))\n          n2 (first (filter prime? (iterate inc (inc n))))]\n      (and (prime? n) (> n 2) (= n (/ (+ n1 n2) 2))))))", "problem": 116, "user": "519ef784e4b087743fad2198"}, {"code": "(fn [n]\n  (letfn [(prime? [n]\n            (cond\n             (> 2 n) false\n             (= 2 n) true\n             (even? n) false\n             :else (let [prevs (range 3  (quot n 2))]\n                     (empty? (filter #(= 0 (rem n %)) prevs)))))]\n    (if (or (= 2 n) (not (prime? n))) false\n        (let [primes (filter prime? (range))\n              u (last  (take-while #(>  n %) primes))\n              v (first (drop-while #(>= n %) primes))]\n          (= n (/ (+ u v) 2))))))", "problem": 116, "user": "524ae8e6e4b09eba1c0223b5"}, {"code": "(fn [n]\n  (letfn [(prime? [x]\n                  (and (< 1 x)\n                       (every? #(not= 0 (mod x %)) (range 2 (/ (inc x) 2)))))\n          (nextPrime [x]\n                     (if (prime? (+ x 1))\n                       (+ x 1)\n                       (recur (+ x 1))))]\n    (if (not (prime? n))\n      false\n      (let [n2 (nextPrime n)\n            n0 (- n (- n2 n))]\n        (and (prime? n0) (= n (nextPrime n0)))))))", "problem": 116, "user": "509160dae4b0742c82730aef"}, {"code": "(let [prime? (fn [n]\n               (and (> n 1) (not-any? #(= (mod n %) 0) (range 2 (inc (int (Math/sqrt n)))))))\n      primes (filter prime? (range))]\n  (fn [n] (and (prime? n)\n               (let [s1 (take-while #(< % n) primes)\n                     s2 (drop-while #(<= % n) primes)]\n                 (when-not (or (empty? s1) (empty? s2))\n                   (= (+ (last s1) (first s2)) (* 2 n)))))))", "problem": 116, "user": "5233ad08e4b07e3ee2be83ac"}, {"code": "(letfn [(prime? [n] (every? #(not (zero? %)) (map #(mod n %) (range 2 n))))\n        (nextprime [n p] (if (prime? (+ n p)) (+ n p) (recur (+ n p) p)))]\n  (fn [m]\n    (and (not= 0 m) (not= 1 m) (not= 2 m)\n         (prime? m)\n         (= m (/ (+ (nextprime m -1) (nextprime m 1)) 2)))))", "problem": 116, "user": "52736ca1e4b03e8d9a4a747e"}, {"code": "(fn [n] (let [is-prime? (fn [p] (loop [trial 2]\n                                  (if (> (* trial trial) p) true\n                                    (if (= 0 (rem p trial)) false\n                                      (recur (inc trial))\n                                    )\n                                  )\n                                )\n                        )\n              ] (if (not (is-prime? n)) false\n          (loop [left (dec n) right (inc n)]\n                  (if (< left 2) false\n                    (let [l (is-prime? left) r (is-prime? right)]\n                      (cond\n                       (and l r) true\n                       (or (and l (not r)) (and (not l) r)) false\n                       :else (recur (dec left) (inc right))\n                      )\n                    )\n                  )\n                )\n                  )\n        )\n)", "problem": 116, "user": "526dd90de4b03e8d9a4a72fe"}, {"code": "(fn [x]\n  (let [p (fn [n]\n                 (empty? (filter #(zero? (mod n %))\n                                 (range 2 n))))\n        ps (filter p (drop 2 (range)))\n        bps (map second\n                             (filter (fn [[a b c]]\n                                       (= b (/ (+ a c) 2)))\n                                     (partition 3 1 ps)))]\n    (and (p x) (some #(= x %) (take-while #(<= % x) bps)))))", "problem": 116, "user": "50d86fe2e4b01f0871336e67"}, {"code": "(fn hoge [x]\n  (letfn [(melem [x xs]\n          (if (empty? xs) false\n              (cond (< x (first xs)) false\n                    (= x (first xs)) true\n                    true (melem x (next xs)))))]\n    (melem x '(5 53 157 173 211 257 263 373 563 593 607 653 733 947 977 1103))\n    )\n  )", "problem": 116, "user": "5272669de4b03e8d9a4a742e"}, {"code": "(fn [v]\n  (letfn [(hs [[h & r]] (lazy-seq (cons h (hs (remove #(zero? (mod % h)) r)))))\n          (ps [] (hs (drop 2 (range))))]\n    (loop [[s1 s2 & r] (ps)]\n      (cond\n        (< s2 v) (recur (cons s2 r))\n        (= s2 v) (= s2 (/ (+ s1 (first r)) 2))\n        :else false\n        ))))", "problem": 116, "user": "528e64b7e4b0239c8a67aedd"}, {"code": "(fn balanced? [n]\n  (letfn [(prime? [n]\n  \t\t\t(and \n              (> n 1)\n              (not-any? #(zero? (rem n %)) (range 2 (inc (int (Math/sqrt n)))))))]\n    (let [low  (some #(if (prime? %) %) (range (dec n) 0 -1))\n          high (some #(if (prime? %) %) (drop (inc n) (range)))]\n      (if (and (prime? n) (not= n 2))\n          (= n (- (+ low high) n))      \n          false))))", "problem": 116, "user": "528b08efe4b0239c8a67ae8a"}, {"code": "(fn iffbp [n]\n  (letfn [(isprime [n]\n            (cond\n             (= n 1) false\n             (= n 2) true\n             (= n 3) true\n             (zero? (rem n 2)) false\n             (zero? (rem n 3)) false\n             :else (empty? (filter #(zero? (rem n %)) (range 2 (dec n)))))\n            )]\n    (cond (or (false? (isprime n)) (< n 3)) false\n      :else (let [primes (filter isprime (range))\n                  triple (first (filter #(= (second %) n) (partition 3 1 primes)))\n                  ]\n              (= (/ (+ (last triple) (first triple)) 2) n)           \n        ))\n    ))", "problem": 116, "user": "52319066e4b0e2e8de81d1e9"}, {"code": "(fn balanced-prime [n]        \n    (letfn[(is-prime \n             [x]\n             (if( < n 3)\n               false\n               (not (some (fn [i] \n                            (= 0 (mod x i))) \n                          (filter #(<= (* % %) x) (range 2 x))))))\n           (get-dec-prime\n             [n]\n             (if(is-prime n)\n               n\n               (get-dec-prime (dec n))))\n           (get-inc-prime\n             [n]\n             (if(is-prime n)\n               n\n               (get-inc-prime (inc n))))]\n      (and (is-prime n)\n           (= (+ n n)\n              (+ (get-inc-prime (inc n)) (get-dec-prime (dec n)))))))", "problem": 116, "user": "5273562ae4b03e8d9a4a7479"}, {"code": "(fn [n]\n  (letfn [(notprime [n]\n            (some #(zero? (mod n %)) (range 2 (inc (/ n 2)))))\n          (nextprime [f n]\n            (first (drop-while notprime (iterate f (f n)))))]\n    (cond (<= n 2) false\n          (notprime n) false\n          :else (= (/ (+ (nextprime dec n) (nextprime inc n))\n                      2)\n                   n))))", "problem": 116, "user": "52753740e4b03e8d9a4a74c1"}, {"code": "(fn nprime [max]\n  (cond\n   (< max 3) false\n  :else (let [prime? (fn [n plist]\n            (if (empty? (filter #(= 0 (rem n %)) plist))\n              true false))\n        prime-till  (fn [max]\n            (loop [cp 3 acc [2]]\n              (cond\n               (< max (last acc)) acc\n               (prime? cp acc) (recur (+ cp 2) (conj acc cp))\n               :else (recur (+ cp 2) acc)))\n            )\n          primes (prime-till max)\n          x (last (butlast (butlast primes)))\n          y (last (butlast primes))\n          z (last primes)\n          is_prime (= y max)\n          ]\n          (and (= (/ (+ x z) 2) y)\n               is_prime)\n    )\n))", "problem": 116, "user": "52140b53e4b0961f15ac4d7e"}, {"code": "(fn is-balanced? [p]\n   (let [nextp (fn nextp [[r ps n]]\n                 (if (not-any? #(= 0 (mod n %)) ps)\n                   [n (conj ps n) (inc n)]\n                   [nil ps (inc n)]))\n         primes (filter #(not (nil? %))\n                        (map first\n                             (iterate nextp [nil [] 2])))]\n     (loop [[p1 & p1s]         primes\n            [p2 & p2s] (drop 1 primes)\n            [p3 & p3s] (drop 2 primes)]\n       (if (>= p1 p) false\n           (if (= (/ (+ p1 p3) 2) p2 p)\n             true\n             (recur p1s p2s p3s))))))", "problem": 116, "user": "529ce629e4b04e0c58e87b6e"}, {"code": "#(contains? #{5, 53, 157, 173, 211, 257, 263, 373, 563, 593, 607, 653, 733, 947, 977, 1103} %)", "problem": 116, "user": "5201ada5e4b0b2e020a18f14"}, {"code": "(fn [n]\n  (let [prime-test (fn [x] (not-any? #(zero? (mod x %)) (range 2 (+ 1 (Math/sqrt x)))))]\n    (if (or (> 2 n)\n            (not (prime-test n)))\n      false\n      (loop [prev-found false next-found false current-prev (dec n) current-next (inc n)]\n        (cond\n          (and prev-found next-found)\n            (= (/ (+ prev-found next-found) 2) n)\n          (= 2 current-prev)\n            false\n          (not prev-found)\n            (if (prime-test current-prev)\n              (recur current-prev next-found current-prev current-next)\n              (recur false next-found (dec current-prev) current-next))\n          (not next-found)\n            (if (prime-test current-next)\n              (recur current-prev current-next current-prev current-next)\n              (recur current-prev false current-prev (inc current-next))))))))", "problem": 116, "user": "4f0446f9535dcb61093f6bb8"}, {"code": "(fn b-prime? \n  [prime]\n  (let [prime? \n        (fn [p]\n          (and \n            (not (or (= p 0) (= p 1)))\n            (= 0 (count (filter #(= 0 (mod p %)) (range 2 (+ 1 (int (/ p 2)))))))))\n        gen-prime (fn [n dir]\n                    (if (prime? n) n\n                      (recur (if (= dir :up) (inc n) (dec n)) dir)))]\n    (if (not (prime? prime)) false\n      (= prime\n         (/ (+ \n             (gen-prime (inc prime) :up) \n             (gen-prime (dec prime) :down)) \n            2)))))", "problem": 116, "user": "5273e006e4b03e8d9a4a7495"}, {"code": "(into {4 false 563 true 1103 true} (zipmap (range 10 24) (repeat true)))", "problem": 116, "user": "4db92654535d1e037afb21a0"}, {"code": "(fn [n]\n  (if (< n 4) false\n    (let [f (fn f [[fs & s]]\n              (cons fs\n                    (lazy-seq\n                      (f (filter\n                          #(not= 0 (mod % fs))\n                          s)))))\n         r (last (take-while #(<= (second %) n) (partition 3 1 (f (iterate inc 2)))))]\n       (and (= n (second r)) (= (/ (+ (first r) (last r)) 2) n)))))", "problem": 116, "user": "528652fbe4b0239c8a67ae14"}, {"code": "(fn n116 [n]\n  (letfn [(prime [k]\n                  (let [r (java.lang.Math/floor (java.lang.Math/sqrt k))]\n                    (every? (complement zero?) (map #(mod k %) (rest (rest (range (inc r))))))))\n          (prime-bef [k] (loop [i (dec k)] (if (prime i) i (recur (dec i)))))\n          (prime-after [k] (loop [i (inc k)] (if (prime i) i (recur (inc i)))))]\n    (and (> n 2) (prime n) (= n (/ (+ (prime-bef n) (prime-after n)) 2)))\n    ))", "problem": 116, "user": "52b43468e4b0c58976d9ad1b"}, {"code": "(fn [n]\n    (letfn [(prime? [n]\n              (cond\n                (< n 2) false\n                (= n 2) true\n                (= n 3) true\n                (zero? (mod n 2)) false\n                (zero? (mod n 3)) false\n                :else (-> (for [i (range 6 (Math/sqrt n) 6)\n                                :when (or (zero? (mod n (dec i)))\n                                          (zero? (mod n (inc i))))]\n                             i)\n                          seq\n                          nil?)))]\n      (and (prime? n)\n           (let [next-prime (first (drop-while (comp not prime?) (range (+ n 1) Integer/MAX_VALUE)))\n                 prev-prime (first (drop-while (comp not prime?) (range (- n 1) 1 -1)))]\n             (and prev-prime (= (/ (+ next-prime prev-prime) 2) n))))))", "problem": 116, "user": "521b9f92e4b0c4ef0be8304c"}, {"code": "#(if (< % 1103)\n   (contains? #{5, 53, 157, 173, 211, 257, 263, 373, 563, 593, 607, 653, 733, 947, 977, 1103} %)\n   \"I am f**ked\")", "problem": 116, "user": "52afbc69e4b0c58976d9acc0"}, {"code": "(fn ps? [n]\n  (let [fps '[2 3 5 7 11 13 17 19 23 29 31 37]\n        primetov? (fn [x v] (when (> x 1) (= :pr (some #(cond (= 0 (mod x %)) :np (> (* % %) x) :pr) v))))\n        giveodds (fn [x dir] (filter odd? (map #(dir x 1 %) (range))))\n        fnpv (fn fnpv [v] (let [np (some #(and (primetov? % v) %) (giveodds (last v +)))]\n                            (cons np (lazy-seq (fnpv (conj v np))))))\n        primes (lazy-cat fps (fnpv fps))\n        prime? #(primetov? % primes)]\n    (if (and (> n 3) (prime? n))\n      (let [lp (some #(and (prime? %) %) (giveodds n -))\n            gp (some #(and (prime? %) %) (giveodds n +))]\n        (= n (/ (+ lp gp) 2)))\n      false)))", "problem": 116, "user": "5267d9bde4b03e8d9a4a7188"}, {"code": "(fn [x]\n    (let [prime? (fn [x] (and (> x 1) (every? #(> (rem x %) 0) (range 2 x))))\n          primes (filter  prime? (iterate inc 2))\n          deltas (map vector primes (drop 1 primes) (drop 2 primes))]\n      (if (and (prime? x) (> x 2))\n        (let [[a b c] (first (filter #(= x (second %)) deltas))]\n          (= (- b a) (- c b)))\n        false)))", "problem": 116, "user": "52a88c4de4b0c58976d9ac30"}, {"code": "(fn [n]\n  (let [prime (fn [p] (every? #(not= 0 (rem p %)) (range 2 p)))\n        next-prime (first (filter prime (iterate inc (inc n))))\n        prev-prime (first (filter prime (range (dec n) 2 -1)))]\n    (and (prime n)\n         prev-prime\n         (= n (/ (+ next-prime prev-prime) 2)))))", "problem": 116, "user": "4fc3a72ae4b081705acca342"}, {"code": "(fn [p]\n  (letfn [(max-prime [n]\n            (int (Math/sqrt n)))\n          (prime? [n]\n            (not-any? #(= (mod n %) 0) (range 2 (inc (max-prime n)))))\n          (next-prime-in [r]\n            (first (filter prime? r)))]\n    (if (and (> p 2) (prime? p))\n      (let [prev (next-prime-in (range (dec p) 0 -1))\n            next (next-prime-in (iterate inc (inc p)))]\n        (= p (/ (+ prev next) 2)))\n      false)))", "problem": 116, "user": "4f437751e4b0d7d3c9f3fd20"}, {"code": "(fn [num]\n   (if (or (even? num) (zero? (rem num 3))) false\n   (loop [result [2 3 5]  seed 6 ]\n         (if (> (last result) num) (let [n (- (count result) 2) pn (nth result n)] (and (= num pn) (= pn  (/ (+ (nth result (dec n)) (nth result (inc n))) 2) ) )  )\n           (if (even? seed)  (recur result (inc seed))\n             (recur (concat result (if (not-any? #(zero? (rem seed %)) result) [seed])) (inc seed))\n           )\n         )\n   )\n   )\n)", "problem": 116, "user": "522eba30e4b01cdb292c5f0e"}, {"code": "(fn [n]\n  (let [prime? (fn [n] (cond (< n 2) false\n                             (= n 2) true\n                             :else (not-any? #(zero? (mod n %))\n                                             (cons 2 (range 3 (inc (Math/sqrt n)) 2)))))\n        find-prime (fn [f n] (f (or (last (take-while (complement prime?) (iterate f (f n)))) n)))]\n    (and (> n 2) (prime? n) (= n (/ (+ (find-prime inc n) (find-prime dec n)) 2)))))", "problem": 116, "user": "50645e12e4b007509339a58a"}, {"code": "(fn sandwich [n]\n  (let \n    [sieve (fn sieve [s]\n             (cons (first s)\n                   (lazy-seq (sieve (remove #(zero? (mod % (first s)))\n                                            (rest s))))))\n     primes (sieve (iterate inc 2))\n     triple (last (take-while #(<= (second %) n) (partition 3 1 primes)))]\n    (not (or (not= (second triple) n)\n             (not= (/ (+ (first triple) (last triple)) 2) n)))))", "problem": 116, "user": "51e00020e4b01188f0627534"}, {"code": "(fn balanced-prime [n]\n  (letfn [(prime? [n] (and (> n 1) (not (some #(zero? (rem n %)) (range 2 n)))))\n          (average-prime? [offset]\n                          (let [p1 (prime? (- n offset))\n                                p2 (prime? (+ n offset))]\n                            (if (and p1 p2)\n                              true\n                              (if (and (not p1) (not p2))\n                                (average-prime? (inc offset))\n                                false))))]\n    (if (prime? n)\n      (average-prime? 1)\n      false)))", "problem": 116, "user": "52a55adee4b0c58976d9abe7"}, {"code": "(letfn [(prime? [n]\n                (and (> n 1)\n                     (every? #(not= (mod n %) 0) (take-while #(<= (* % %) n) \n                                                             (iterate inc 2)))))\n              (prime+ [n]\n                (first (filter prime? (iterate inc (inc n)))))\n              (prime- [n]\n                (first (filter prime? (iterate dec (dec n)))))]\n        (fn [n] (and (> n 2) (prime? n) (= n (/ (+ (prime+ n) (prime- n)) 2)))))", "problem": 116, "user": "5294e44de4b02ebb4ef75016"}, {"code": "(fn [p]\n  (letfn [(p? [x] (and (> x 1) (not-any? #(zero? (rem x %)) (range 2 x))))]\n    (and (> p 3)\n         (p? p)\n         (= p (/ (+ (first (filter p? (iterate #(+ % 2) (+ p 2))))\n                    (first (filter p? (iterate #(- % 2) (- p 2)))))\n                 2)))))", "problem": 116, "user": "4e50b67b535dc968683fc4ed"}, {"code": "(fn [p]\n  (letfn [(prime? [x]\n            (and (> x 1) (every? #(pos? (mod x %)) (range 2 x))))\n          (last-prime [x]\n            (last (filter prime? (range 2 x))))\n          (next-prime [x]\n            (first (filter prime? (iterate inc (inc x)))))]\n    (and\n      (> p 2)\n      (prime? p)\n      (= (+ p p) (+ (last-prime p) (next-prime p))))))", "problem": 116, "user": "527cd633e4b0757a1b17136f"}, {"code": "(fn [n]\n  (let [sieve       (fn sieve [s]\n                      (cons (first s)\n                            (lazy-seq (sieve (filter #(not (= 0 (mod % (first s))))\n                                                     (rest s))))))\n        n-set       (first (drop-while #(> n (second %)) (partition 3 1 (sieve (iterate inc 2)))))\n        ]\n    (= n\n       (second n-set)\n       (/ (+ (first n-set) (last n-set)) 2))))", "problem": 116, "user": "510cd1dde4b078ea71921124"}, {"code": "(fn balanced-prime?\n  [x]\n  (letfn [(primes []\n           ((fn sieve [s]\n              (cons (first s)\n                    (lazy-seq (sieve (filter #(not= 0 (mod % (first s))) (rest s))))))\n            (iterate inc 2)))]\n    (->> (primes)\n         (partition 3 1)\n         (filter (fn [[p-prev p p-next]] (>= p x)))\n         (first)\n         ((fn [[a b c]] (= x b (/ (+ a c) 2)))))))", "problem": 116, "user": "524f4256e4b0541d1855b808"}, {"code": "(fn [n] (letfn [(prm [n] (if (< n 2) false (every? #(pos? (rem n %)) (range 2 n))))\n                         (findPrm [n2 f] (let [n3 (f n2)] (if (prm n3) n3 (recur n3 f))))\n                         ]\n                   (if (false? (prm n))\n                     false\n                     (let [np (findPrm n inc)]\n                       (if (prm (- n (- np n))) (= (/ (+ np (findPrm n dec)) 2) n) false\n                       )))))", "problem": 116, "user": "52c1bd29e4b07a9af579236a"}, {"code": "(fn [n]\n    (letfn [(prime? [n]\n              (cond\n                (= n 1) false\n                (= n 2) true\n                :else\n                  (loop [i 2]\n                    (cond\n                      (= (rem n i) 0) false\n                      (> (* i i) n) true\n                      :else (recur (inc i))))))]\n      (let [primes (filter prime? (drop 1 (range)))]\n        (if (and (prime? n) (> n 2))\n          (let [before (last (take-while #(< % n) primes))\n                after (first (filter #(> % n) primes))]\n            (= n (/ (+ before after) 2)))\n           false))))", "problem": 116, "user": "526f9715e4b03e8d9a4a7372"}, {"code": "(fn [c]\n  (letfn [(divisors? [a l] (some true? (map #(zero? (rem a %)) l)))\n          (next-non-div [b]\n            (loop [n (inc' (last b)) l b]\n              (if (divisors? n b)\n                (recur (inc' n) b)\n                (concat b [n]))))]\n    (loop [l [2] m [0]]\n      (if (< (last l) c)\n        (recur (next-non-div l) l)\n        (and (= (last l) c) (= (last l) (/ (+' (last m) (last (next-non-div l))) 2)))))))", "problem": 116, "user": "5133e51ae4b0d7a043de8cf6"}, {"code": "(let [prime? (fn [n]\n                 (if (< n 2)\n                   false\n                   (nil? (first (filter #(= 0 (rem n %)) (range 2 n))))))\n        prime? (memoize prime?)]\n    (fn [n]\n      (if (prime? n)\n        (if-let [r (first (filter #(and (prime? %) (> % n)) (range n (* n 2))))]\n          (if-let [l (last (filter #(and (prime? %) (< % n)) (range (quot n 2) n)))]\n            (= (/ (+ l r) 2) n)\n            false)\n          false)\n        false)))", "problem": 116, "user": "51852961e4b0da5a5be3babb"}, {"code": "(fn prime-sandwich [n]\n  (letfn [(prime? [xi]\n            (if (< xi 2) false\n                (loop [i (dec xi)]\n                  (cond (= 1 i) true\n                        (= 0 (rem xi i)) false\n                        :else (recur (dec i)))))\n            )]\n\n    (if-not (prime? n) false\n            (loop [i 2 [a,b,c] [0,0,0]]\n              (cond (= b n) (= n (/ (+ a c) 2))\n                    (prime? i) (recur (inc i) [b,c,i])\n                    :else (recur (inc i) [a,b,c]))))))", "problem": 116, "user": "515bbcd9e4b0388ca8ca1521"}, {"code": "(fn [n]\n  (letfn [(sieve [sieved]\n            (let [p (first sieved)]\n              (cons p (lazy-seq (sieve (filter #(not= (mod % p) 0)\n                                               sieved))))))]\n    (loop [primes (sieve (iterate inc 2))]\n      (let [[p1 p2 p3] (take 3 primes)]\n        (cond (= p2 n) (= (/ (+ p1 p3) 2) p2)\n              (< p2 n) (recur (drop 1 primes))\n              :else false)))))", "problem": 116, "user": "5102ac9de4b00c483ae176fa"}, {"code": "(fn [m]\n  (let [p? (fn [n]\n             (empty? (filter #(= 0 (mod n %)) (range 2 (inc (Math/sqrt n))))))\n        l (first (drop-while #(not (p? %)) (range (dec m) 1 -1)))\n        u (first (drop-while #(not (p? %)) (map #(+ (inc m) %) (range))))\n        ] (if (and (p? m) l u) (= m (/ (+ l u) 2)) false)))", "problem": 116, "user": "52593207e4b0cb4875a45cd3"}, {"code": "(fn balanced? [n]\n  (if (> n 3)\n    (letfn [(sieve [primes potentials]\n    (if (empty? potentials) primes\n      (let [p (first potentials)]\n        (sieve (cons p primes) (remove #(zero? (rem % p)) potentials)))))\n           (next-prime [x primes]\n    (if (not-any? #(zero? (rem x %)) primes)\n      x\n      (next-prime (+ x 2) primes)))]    \n    (let [primes (sieve [] (range 2 (inc n)))\n          p (first primes)\n          nxt (next-prime p primes)\n          below (second primes)\n          sum (+ below nxt)\n          mean (/ sum 2)]\n      (and (= n p) (= mean n))))\n    false))", "problem": 116, "user": "4ffa8affe4b0678c553fc3bd"}, {"code": "(fn balanced-prime? [n]\n  (if-not (and (> n 2) (not-any? #(zero? (mod n %)) (range 2 n)))\n    false\n      (let [prime-step (fn prime-step [n step]\n                        (loop [n (+ n step)]\n                          (if (not-any? #(zero? (mod n %)) (range 2 n))\n                            n\n                            (recur (+ n step)))))\n            before (prime-step n -1)\n            after (prime-step n 1)]\n        (= (/ (+ before after) 2) n))))", "problem": 116, "user": "51a97f7ae4b08d8ec191b827"}, {"code": "(letfn\n  [(prime? [n] (and (> n 1) (every? pos? (map (partial mod n) (range 2 n)))))]\n  (fn stuff [n]\n    (when (> n 2)\n      (let\n        [lower (first (filter prime? (iterate dec (dec n))))\n         higher (first (filter prime? (iterate inc (inc n))))]\n        (and (prime? n) (= (* 2 n) (+ lower higher)))))))", "problem": 116, "user": "4f03641a535dcb61093f6a9b"}, {"code": "(fn [n] (let [g #(if (< % 2) false (every? pos? (for [i (range 2 (inc (int (Math/sqrt %))))] (mod % i))))]\n          (if (and (g n) (> n 4))\n            (let [m (first (filter g (iterate inc (+ n 2))))]\n          \t(and (g (- (* 2 n) m)) (= (- n (first (filter g (iterate dec (- n 2))))) (- m n))) ) false ) ) )", "problem": 116, "user": "52c6a0abe4b0c2d177d62111"}, {"code": "(fn [n] (let [b #(biginteger %)\n              is #(.isProbablePrime (b %) 5)\n              f #(if (is %) % (recur (- % 2)))]\n          (and (is n) (= n (/ (+ (.nextProbablePrime (b n)) (f (- n 2)) ) 2)))))", "problem": 116, "user": "4dada16fc9a9d6ed2699dc57"}, {"code": "(fn [x]\n\t(let [p (fn [n] (cond (#{2} n) true\n                          (< n 2) false\n                          :t (every? #(< 0 (rem n %)) (range 2 (+ 1 (Math/sqrt n))))))\n          g (fn g [n] (if (p (+ 1 n)) (+ n 1) (g (+ 1 n))))\n          h (fn h [n] (if (<= n 2) -10 (if (p (- n 1)) (- n 1) (h (- n 1)))))]\n      (and (p x)\n           (= (- (g x) x) (- x (h x))))))", "problem": 116, "user": "528a3e14e4b0239c8a67ae72"}, {"code": "(let [primes\n      (cons 2 ((fn gen-primes [current-primes n]\n         (if\n           (every? (partial < 0) (map (partial mod n) current-primes))\n           (cons n (lazy-seq (gen-primes (cons n current-primes) (+ 2 n))))\n           (lazy-seq (gen-primes current-primes (inc n)))\n           ))\n        '(2) 3))]\n  (fn balanced-prime? [x]\n    (if (< x 5)\n      false\n      (let [not-greater (take-while #(<= %1 x) primes)]\n        (and\n          (= (last not-greater) x)\n          (= x\n            (/\n              (+ (second (reverse not-greater)) (first (drop-while #(<= %1 x) primes))) 2)))\n        )\n      ))\n  )", "problem": 116, "user": "5094057fe4b097f48cc38593"}, {"code": "(fn [n]\n    (if (> n 2)\n      (letfn [(sieve [s]\n                (cons (first s)\n                      (lazy-seq (sieve (filter #(not= 0 (mod % (first s)))\n                                               (rest s))))))]\n        (let [primes (sieve (iterate inc 2))\n              [before after] (split-with (partial > n) primes)\n              l (last before)\n              [m r] after]\n          (= m\n             n\n             (/ (+ l r) 2))))))", "problem": 116, "user": "4e80aa10535db62dc21a62b1"}, {"code": "(fn [n]\n  (letfn [(primes\n            ([] (primes 2 [2]))\n            ([a ps]\n               (cons a\n                     (lazy-seq\n                      (let [b (first (filter\n                                      (fn [x] (every? true? (map #(not= 0 (rem x %)) ps)))\n                                      (drop (inc a) (range))))]\n                        (primes b (conj ps a)))))))]\n    (and\n     (> n 1)\n     (not (some #(zero? (rem n %)) (take-while #(<= % (/ n 3)) (primes))))\n     (let [xs (take-while #(<= % n) (primes))\n           a  (or (butlast xs) [0])\n           b  (first (drop (count xs) (primes)))]\n       (= n\n          (last xs)\n          (/ (+ (last a) b) 2))))))", "problem": 116, "user": "4ea365e2535d7eef308072c5"}, {"code": "#(boolean (#{5 53 157 173 211 257 263 373 563 593 607 653 733 947 977 1103} %))", "problem": 116, "user": "52b02329e4b0c58976d9acc5"}, {"code": "(fn [n]\n  (letfn [(primo? [n]\n                  (if (< n 2)\n                    false\n                    (not-any? #(= 0 (rem n %)) (range 2 n))))\n          (primo-maior [n]\n                       (first (filter primo?\n                                      (map #(+ (inc n) %)\n                                           (range)))))\n          (primo-menor [n]\n                       (first (filter primo?\n                                      (range (dec n) 0 -1))))]\n    (if (= n 2)\n      false\n      (if (primo? n)\n        (if (= n (/ (+ (primo-maior n) (primo-menor n)) 2))\n          true\n          false)\n        false))))", "problem": 116, "user": "52c8758be4b0c2d177d62135"}, {"code": "(fn is-balanced-prime [n]\n\t(letfn [(is-prime [k] \n\t\t\t\t(let [bound (int (Math/sqrt k))]\n\t\t\t\t   (every? #(not= (rem k %) 0) (range 2 (inc bound))) \n\t\t\t\t)\n\t\t\t)\n\t\t\t(next-prime-in-seq [a-seq]\n\t\t\t\t(first (take 1 (filter is-prime a-seq)))\n\t\t\t)\n\t\t\t(prev-prime [n]\n\t\t\t\t(next-prime-in-seq (range (dec n) 1 -1))\n\t\t\t)\n\t\t\t(next-prime [n]\n\t\t\t\t(next-prime-in-seq (range (inc n) Double/POSITIVE_INFINITY 1))\n\t\t\t)\n\t\t]\n\t\t(if (is-prime n)\n\t\t\t(let [prev (prev-prime n) next (next-prime n)]\n\t\t\t\t(if (not= nil prev)\n\t\t\t\t\t(= n (/ (+ prev next) 2))\n\t\t\t\t\tfalse)\n\t\t\t)\n\t\t\tfalse\n\t\t)\n\t)\n)", "problem": 116, "user": "52763696e4b03e8d9a4a74d7"}, {"code": "(fn [x]\n  (letfn [(sieve [s] (cons (first s) (lazy-seq (sieve (filter #(not= 0 (mod % (first s))) (rest s))))))]\n    (let [primes (take-while #(< % (* 2 x)) (sieve (iterate inc 2)))\n          lower (last (take-while #(< % x) primes))\n          upper (take 2 (drop-while #(< % x) primes))]\n      (if lower\n        (= x (/ (+ lower (last upper)) 2) (first upper))\n        false\n        )\n      )\n    )\n  )", "problem": 116, "user": "52e59ca5e4b09f7907dd1464"}, {"code": "(fn my-prime-sandwich\n  [x]\n  (letfn [(is-prime? [x] (if (or (= x 1) (= x 0)) \n                                 false\n                                 (not-any? zero? (map #(mod x %) (range 2 x)))))\n          (next-prime [x fun] (loop [n (fun x)]\n                                (if (is-prime? n) \n                                  n\n                                  (recur (fun n)))))]\n    (and (is-prime? x) (= x (/ (+ (next-prime x dec) (next-prime x inc)) 2)))))", "problem": 116, "user": "509a25b7e4b0efbae1fbc0a8"}, {"code": "(fn f [n]\n  (let [prime? (fn [x]\n                 (not-any? zero?\n                           (map #(rem x %)\n                                (range 2 (inc (/ x 2))))))\n        prime-numbers (fn []\n                        (filter prime? (drop 2 (range))))\n        result (map second (filter (fn [[g h i]] (= (* 2 h ) ( + g i )))(partition 3 1 (prime-numbers))))\n        ]\n    (and (prime? n )(= n (first (drop-while #(< % n) result))))))", "problem": 116, "user": "518c5236e4b087e178201de0"}, {"code": "(fn [n]\n    (letfn[(prime?[n] (nil? (some #(= (mod n %) 0) (range 2 n))))]\n      (let[nxt (loop[x (inc n)] (if (prime? x) x (recur (inc x))))\n           pre (loop[x (dec n)] (if (prime? x) x (recur (dec x))))]\n        (and (prime? n)\n             (> n 2)\n             (= n (/ (+ nxt pre) 2))))))", "problem": 116, "user": "52e3e6a8e4b09f7907dd1448"}, {"code": "(fn [i]\n  (letfn [(p? [n] (every? #(not= 0 (mod n %)) (range 2 (dec n))))\n          (ps ([] (ps 2)) ([n] (lazy-seq (cons n (ps (loop [nn (inc n)] (if (p? nn) nn (recur (inc nn)))))))))\n          ]\n    (if (and (odd? i) (p? i))\n      (loop [f (ps)\n\t     s (drop 1 f)\n\t     t (drop 1 s)]\n\t(cond\n\t (> i (first s)) (recur s t (next t))\n\t (= i (first s)) (= (+ i i) (+ (first f) (first t)))\n\t :else false))\n      false)))", "problem": 116, "user": "4ef9c8f9535dced4c769f26b"}, {"code": "(fn [n]\n  (let [p #(every? (fn [d]\n                     (< 0 (rem % d)))\n                   (range 2 %))\n        q #(nth (filter p\n                        (iterate % n))\n                1)]\n    (and (p n)\n         (< 2 n)\n         (= n\n            (/ (+ (q inc)\n                  (q dec))\n               2)))))", "problem": 116, "user": "51ad244fe4b09397d510977f"}, {"code": "(fn[n] \n    (let[is-prime (fn[i] \n                    (not-any? \n                      #(= 0 (mod i %)) \n                      (range 2 (inc (int (Math/sqrt i)))))\n                    ) \n         find-prime (fn[x delta] \n                      (first \n                        (filter \n                          is-prime \n                          (iterate #(+ % delta) (+ x delta))\n                          )\n                        )\n                      )\n         ] \n      (and (> n 2) (is-prime n) (= n (/ (+ (find-prime n -1) (find-prime n 1)) 2)))\n      )\n    )", "problem": 116, "user": "52e68e61e4b09f7907dd1479"}, {"code": "((fn []\n  (let [e first\n        r range\n        f #(e (filter % %2))\n        a (for [x (drop 2 (r)) :when (every? #(not= (mod x %) 0) (r 2 x))] x)\n        p (fn [n] (= (e (drop-while #(< % n) a)) n))]\n    #(let [q (f p (r (- % 2) 1 -2))]\n       (boolean\n         (and\n          (p %)\n          q\n          (if-let [s (f p (r (+ % 2) (+ 1 % (- % q)) 2))]\n            (= (- % q) (- s %)))))))))", "problem": 116, "user": "51a10b2ce4b0b292b01ee3fe"}, {"code": "(fn[n]\n  (letfn [(p[x]\n            (if (< x 2) false\n            ((comp not some) #{0} (map #(rem x %)(range 2 x)))))\n          (m[x]\n            (first (filter p (range (+ x 1) (* 2 x)))))]\n    (if (p n)\n      (let [b (- (* 2 n) (m n))] \n        (and (p b)(= (m b) n)))\n      false)))", "problem": 116, "user": "52f818a6e4b047fd55836fcc"}, {"code": "(fn prime-sandwich? [number]\n  (letfn [(prime? [x]\n            (when (>= x 2)\n              (not-any? #(zero? (mod x %))\n                        (range 2 x))))\n\n          (next-prime [x]\n            (first (filter prime?\n                           (iterate inc\n                                    (inc x)))))\n\n          (prev-prime [x]\n            (if (= x 2)\n              2\n              (first (filter prime?\n                             (iterate dec\n                                      (dec x))))))]\n    (and (prime? number)\n         (= (* 2 number)\n            (+ (next-prime number) (prev-prime number))))))", "problem": 116, "user": "530578ede4b0d8b024fd3760"}, {"code": "(fn   [n]\n  (let [prime? (fn [n] (empty? (filter #(= 0 (mod n %)) (range 2 n))))\n        prime-neighbour (fn [n f] (first (filter prime? (iterate f (f n)))))]\n    (if (and (> n 2)(prime? n))\n      (= n (/ (+ (prime-neighbour n inc) (prime-neighbour n dec)) 2))\n      false)\n    ))", "problem": 116, "user": "4f47eab2e4b0d56e7bb92bc6"}, {"code": "(fn [n] (letfn [\n(potential-divisors [n] (take-while #(< % (inc (quot n 2))) (cons 2 (range 3 (inc (quot n 2)) 2))))\n(divisors [n] (filter #(zero? (rem n %)) (potential-divisors n)))\n(prime? [n] (and (>= n 2) (zero? (count (divisors n)))))\n(primes [] (filter prime? (cons 2 (iterate #(+ % 2) 3))))\n(first-n-prime-numbers [n] (take n (primes)))\n(previous-prime [n]\n\t(cond\n\t\t(<= n 2)\n\t\tnil\n\t\t(prime? (dec n))\n\t\t(dec n)\n\t\t:else\n\t\t(previous-prime (dec n))\n\t)\n)\n(next-prime [n] (if (prime? (inc n)) (inc n) (next-prime (inc n))))\n(balanced-prime? [n] (and (prime? n) (not (nil? (previous-prime n))) (= (- n (previous-prime n)) (- (next-prime n) n))))\n] (balanced-prime? n)))", "problem": 116, "user": "52f10094e4b05e3f0be25ee8"}, {"code": "(fn balprime? [n]\n   (letfn [(prime? [n]\n             (if (< n 2) false\n             (empty? (filter #(zero? (rem n %)) (range 2 n)))))\n           (prime-after [n] (first (filter #(prime? %) (drop (inc n) (range)))))\n           (prime-before [n]\n             (cond (< n 3) nil\n                   (= n 3) 2\n                   :else\n                    (first (filter #(prime? %) (reverse (range 1 n))))))\n           (mean [a b] (if (nil? a) 0 (/ (+ a b) 2)))]\n     (and (prime? n) (= n (mean (prime-before n) (prime-after n))))\n     ))", "problem": 116, "user": "5301157ae4b0d8b024fd3717"}, {"code": "(fn balanced? [k]\n  (letfn [(primes [n sofar]\n            (lazy-seq\n             (if (every? (fn [m] (not (zero? (rem n m)))) sofar)\n               (cons n (primes (inc n) (conj sofar n)))\n               (primes (inc n) sofar))))\n          (balanced []\n            (letfn [(average? [[a b c]] (= b (/ (+ a c) 2)))]\n              (map second (filter average? (partition 3 1 (primes 2 []))))))]\n    (= k (some (fn [n] (if (<= k n) n nil)) (balanced)))))", "problem": 116, "user": "52f8f4d1e4b047fd55836fde"}, {"code": "(fn [x] (let [f (fn s [[p & r]]\n                  (lazy-seq (cons p (s (remove #(= 0 (mod % p)) r)))))\n            p (f (iterate inc 2))\n            b (take-while #(<= % x) p)\n            x* (last b)\n            n (count b)\n            b (last (butlast b))\n            a (last (take (inc n) p))] \n            (and (= x* x) (= x (/ (+ (or b 0) a) 2)))))", "problem": 116, "user": "5307e4ece4b02e82168697a9"}, {"code": "(fn balanced? [p]\n  (if (< p 5)\n    false\n  (letfn [(sieve [nums]\n                 (let [p (first nums)]\n                   (cons p\n                         (lazy-seq (sieve (filter #(> (rem % p) 0) (rest nums)))))))]\n    (let [primes (take-while #(<= % (* 2 p))\n                             (sieve (drop 2 (range))))\n          p-idx (first (keep-indexed #(when (= %2 p) %1)\n                                     primes))]\n      (if p-idx\n        (let [prevp (nth primes (dec p-idx))\n              nextp (nth primes (inc p-idx))]\n          (= p (/ (+ prevp nextp) 2)))\n        false)))))", "problem": 116, "user": "52d3f666e4b09f7907dd1327"}, {"code": "(fn [n]\n  (let [p #(not-any? (fn [x] (= 0 (mod % x))) (range 2 %))\n        f #(first (filter p (iterate % (% n))))]\n    (and (< 2 n) (p n) (= n (/ (+ (f dec) (f inc)) 2)))))", "problem": 116, "user": "52b453b0e4b0c58976d9ad21"}, {"code": "(fn [tn]\n   (letfn [(p? [tn]\n             (not-any? #(zero? (rem tn %)) (range 2 (dec tn))))]\n     (and (< 3 tn)\n          (p? tn)\n          (= tn (/ (+ (some #(if (p? %) %) (range (dec tn) 1 -1))\n                      (some #(if (p? %) %) (map #(+ % (inc tn)) (range)))) 2)))))", "problem": 116, "user": "52c25645e4b07a9af579237d"}, {"code": "(fn balanced-prime? [x]\n  (let [is-prime? (fn [x]\n                    (cond\n                      (<= x 1) false\n                      (= x 2) true\n                      :else\n                      (loop [n 2]\n                        (if (= n x)\n                          true\n                          (let [r (mod x n)]\n                            (if (zero? r)\n                              false\n                              (recur (inc n))))))))\n        get-next-prime (fn [x]\n                         (loop [n (inc x)]\n                           (if (is-prime? n)\n                             n\n                             (recur (inc n)))))\n        get-prev-prime (fn [x] \n                         (if (<= x 2) \n                           0\n                           (loop [n (dec x)]\n                             (if (is-prime? n)\n                               n\n                               (recur (dec n))))))\n        next-prime (get-next-prime x)\n        prev-prime (get-prev-prime x)]\n    (if (is-prime? x)\n      (= x (/ (+ next-prime prev-prime) 2))\n      false\n      )))", "problem": 116, "user": "52cf084ce4b07d0d72b27399"}, {"code": "(fn [x] (letfn [(a [x]\n                   (and (> x 1)\n                        (not-any? #(zero? (mod x %)) (range 2 x))))\n                (b [x]\n                   (if (a (inc x))\n                     (inc x)\n                     (b (inc x))))\n                (c [x]\n                   (if (a (dec x))\n                     (dec x)\n                     (c (dec x))))]\n          (and (> x 2)\n               (a x)\n               (= (* 2 x) (+ (b x) (c x))))))", "problem": 116, "user": "529b44afe4b02ebb4ef7509d"}, {"code": "(fn [n]\n   (letfn [(prime [n] (and (> n 1) (every? #(pos? (mod n %)) (range 2 n))))]\n     (if (and (prime n) (> n 2))\n       (let [u (first (filter prime (iterate inc (inc n))))\n             d (first (filter prime (iterate dec (dec n))))]\n         (= (+ u d) (* 2 n)))\n       \n       false))\n   )", "problem": 116, "user": "52dc2bc8e4b09f7907dd13ca"}, {"code": "(fn [n]\n  (loop [ps '(5 3 2) p 7]\n    (if (some #(zero? (mod p %)) ps)\n      (recur ps (inc p))\n      (if (> (first ps) n)\n        (= (/ (+ (first ps) (nth ps 2)) 2) (second ps) n)\n        (recur (cons p ps) (+ p 2))\n      )\n    )\n  )\n)", "problem": 116, "user": "5176afd2e4b085adf681d889"}, {"code": "(letfn [(composite? [n](some #(zero? (mod n %)) (range 2 n)))\n        (next-prime [n f] (first (drop-while composite? (iterate f (f n)))))]\n  (fn [n] (and \n           (> n 2)\n           (not (composite? n))\n           (= n (/ (+ (next-prime n inc) (next-prime n dec)) 2)))))", "problem": 116, "user": "532347dde4b09d4e7a9b54cc"}, {"code": "(fn [x] \n  (let [primes #{2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 \n              89 97 101 103 107 109 113 127 131 137 139 149 151 157 163 167 173 \n              179 181 191 193 197 199 211 223 227 229 233 239 241 251 257 263 269 271 \n              277 281 283 293 307 311 313 317 331 337 347 349 353 359 367 373 379 383 \n              389 397 401 409 419 421 431 433 439 443 449 457 461 463 467 479 487 491 \n              499 503 509 521 523 541 547 557 563 569 571 577 587 593 599 601 607 613\n              617 619 631 641 643 647 653 659 661 673 677 683 691 701 709 719 727 733 \n              739 743 751 757 761 769 773 787 797 809 811 821 823 827 829 839 853 857\n              859 863 877 881 883 887 907 911 919 929 937 941 947   953   967   971   977\n   983   991   997   1009   1013   1019   1021   1031   1033   1039   1049   1051   1061   1063\n   1069   1087   1091   1093   1097   1103   1109   1117   1123   1129   1151   1153   1163   \n1171   1181   1187   1193   1201   1213   1217   1223   1229   1231   1237   1249   1259   1277  }\n      lower-bound (first (sort (filter #(< x %) primes)))\n      upper-bound (if (<= x 2) 2 (last (sort (filter #(> x %) primes))))\n      ]\n  (and (contains? primes x) (= x (/ (+ upper-bound lower-bound) 2)))))", "problem": 116, "user": "525c575be4b0cb4875a45d38"}, {"code": "(fn prime-sandwich? [x]\n  (let [prime? #(and (>= % 2)\n                     (not-any? zero? (for [i (range 2 %)] (rem % i))))\n        cached #{5 53 157 173 211 257 263 373 563 593 607 653 733 947 977 1103}]\n    (or (contains? cached x)\n        (and (> x (apply max cached))\n             (prime? x)\n             (let [top (first (filter prime? (iterate inc (inc x))))\n                   bottom (- x (- top x))]\n               (and (prime? bottom)\n                    (not-any? prime? (range (inc bottom) x))))))))", "problem": 116, "user": "5310e7aee4b08068f379ecdc"}, {"code": "(fn balanced-prime [n]\n  (letfn [(prime-seq [coll]\n            (let [h (first coll)]\n              (cons h\n                    (lazy-seq (prime-seq\n                                (filter #(not= 0 (rem % h)) coll))))))]\n    (let [primes (prime-seq (drop 2 (range)))\n          balanced\n          (map second\n               (filter #(= (/ (+ (first %) (last %)) 2) (second %))\n                       (partition 3 1 primes)))]\n      (= n (first (drop-while #(< % n) balanced))))))", "problem": 116, "user": "531c0619e4b08068f379ed98"}, {"code": "(fn [n]\n  (let [prime?  (fn [z] (let [ans (fn get-ans [x i acc]\n                                   (if (and (not= x 1) (not= x 0))\n                                     (if (= i 1)\n                                       (if (= acc 0)\n                                         true\n                                         false)\n                                       (if (= 0 (rem x i))\n                                         (get-ans x (dec i) (inc acc))\n                                         (get-ans x (dec i) acc)))\n                                     false)\n                                   )]\n                             (ans z (inc (int (/ z 2))) 0)))\n        find-prime (fn [start f]\n                     (loop [n (f start 1)]\n                       (if (prime? n)\n                         n\n                         (recur (f n 1)))))]\n\t\t\t\n    (if (prime? n)\n      (let [lower-prime (find-prime n -)\n            higher-prime (find-prime n +)]\n        (if (= n (int (/ (+ lower-prime higher-prime) 2)))\n          true\n          false))\n\t\t\tfalse)))", "problem": 116, "user": "52fa4f48e4b047fd55836ff7"}, {"code": "(fn [i]\n  (let [prime? (fn [n] \n                 (if (not (or (#{0 1} n)\n                              (some #(zero? (mod n %1)) (range 2 (inc (quot n 2)))))) n nil))\n        nearest-prime (fn [n f]\n                        (some prime? (iterate f (f n))))]\n    \n   (boolean (and (prime? i)\n                 (= (/ (+ (nearest-prime i dec) \n                          (nearest-prime i inc)) 2) i)))))", "problem": 116, "user": "53300924e4b019098a6f8b55"}, {"code": "(fn balanced-prime? [n] \n  (letfn [(prime? [n]\n                  (->> (-> n Math/sqrt Math/ceil inc ((partial range 2)))\n                       (every? #(not= 0 (rem n %)))))\n          (next-matching [pred coll]\n                         (first (filter pred coll)))]\n    (if (and (> n 3) (prime? n))\n      (let [nextp (next-matching prime?\n                                 (range (inc n) (* 2 n)))\n            prevp (next-matching prime?\n                                 (range (dec n) (quot n 2) -1))]\n        (= n (quot (+ nextp prevp) 2)))\n      false)))", "problem": 116, "user": "5326c5f7e4b09d4e7a9b54f2"}, {"code": "(fn primsand [n]\n  (letfn [\n    (primes ([] (primes (iterate inc 2)))\n      ([s] (cons (first s)\n                 (lazy-seq (primes (filter #(not= 0 (mod % (first s)))\n                                           (rest s)))))))]\n  (let [[bef after] (split-with #(< % n) (primes))\n        [cur nex] (take 2 after), prev (last bef)]\n    (and prev cur nex\n      (= cur n (/ (+ prev nex) 2))))))", "problem": 116, "user": "533ab9abe4b0e30313ee6cbf"}, {"code": "(fn balanced-prime? [n]\n  (let [factors (cons 2 (iterate (partial + 2) 3))\n        prime? (fn [n] (not-any? #(zero? (mod n %))\n                                 (take-while #(<= % (inc (Math/sqrt n))) factors)))\n        prime-step (fn [n s] (first (drop-while (complement prime?) (rest (iterate (partial + s) n)))))]\n    (and (> n 3)\n         (prime? n)\n         (= n (/ (+ (prime-step n 2) (prime-step n -2)) 2)))))", "problem": 116, "user": "509e62a8e4b08df8156e9e2e"}, {"code": "(fn [num]\n  (letfn [(prime []\n            (letfn [(step [coll]\n                      (let [head (first coll)]\n                        (lazy-seq (cons head (step (filter #(pos? (mod % head)) coll))))))]\n              (step (range 2 Long/MAX_VALUE))))\n          (balanced-prime []\n            (map second (filter #(= (second %) (/ (+ (first %) (last %)) 2)) (partition 3 1 (prime)))))]\n    (= num (last (take-while #(<= % num) (balanced-prime))))))", "problem": 116, "user": "50436470e4b034ff00315d23"}, {"code": "(fn prime-sandwich [n]\n  (letfn [(toJBig [a] (.toBigInteger (bigint a)))\n          (prime? [b] (.isProbablePrime (toJBig b) 32))\n          (next-P [c] (.nextProbablePrime (toJBig c)))]\n    (and (prime? n)\n         (let [d (- n (- (next-P n) n))]\n           (and (prime? d)\n                (= n (next-P d)))))))", "problem": 116, "user": "52d2ca1ce4b099d49816f0b4"}, {"code": "(fn balanced-prime?\n  [n]\n  (letfn [(prime?[p] \n                (and (< 1 p)\n                     (->> (map #(mod p %) (range 2 p))\n                          (some zero?)\n                          not)))]\n    (if (prime? n)\n      (let [n-n (second (filter prime? (iterate inc n)))\n            n-b (+ n n (- n-n))]\n        (and (prime? n-b)\n             (->> (filter prime? (range n-b n))\n                  count\n                  (= 1))))\n      false)))", "problem": 116, "user": "5036eba7e4b0af0658af77a5"}, {"code": "(fn balanced-prime?\n  [n]\n  (let [prime? (fn [p] (cond\n                        (= p 1) false\n                        (= p 2) true\n                        (= 0 (mod p 2)) false\n                        :else (every? #(not= 0 (mod p %))\n                                      (range 3 (inc (int (Math/sqrt p))) 2))))\n        next-prime  (some #(when (prime? %) %) (iterate inc (inc n)))\n        prev-prime  (some #(when (prime? %) %) (iterate dec (dec n)))]\n    (and (prime? n) (= n (/ (+ next-prime prev-prime) 2)))))", "problem": 116, "user": "4edf5dc6535d10e5ff6f5340"}, {"code": "(letfn [(prime?\n         [n]\n         (not-any? (comp zero?\n                         (partial\n                          mod n))\n                   (range 2 n)))]\n  \n  (fn balanced? [n]\n    (and (> n 4)\n         (prime? n)\n         (->> [(iterate #(- % 2) n)\n               (iterate #(+ % 2) n)]\n              (map (comp second\n                         (partial\n                          filter\n                          prime?)))\n              (apply +)\n              (#(/ % 2))\n              (= n)))))", "problem": 116, "user": "532ab0bde4b09d4e7a9b5527"}, {"code": "(fn [n]\n  (letfn [(prime? [p]\n                  (cond\n                   (#{2 3 5 7 11 13} p) true\n                   (#{0 1 4 6 8 10 12} p) false\n                   :else (not-any? #(zero? (mod p %)) (range 2 (inc (int (Math/sqrt p)))))))]\n    (if-not (prime? n)\n      false\n      (let [a0 (loop [a (dec n)]\n                 (if (prime? a)\n                   a\n                   (recur (dec a))))\n            b0 (loop [b (inc n)]\n                 (if (prime? b)\n                   b\n                   (recur (inc b))))]\n        (= (* 2 n) (+ a0 b0))))))", "problem": 116, "user": "5341b141e4b00652c8746ecf"}, {"code": "(fn [a]\n  (letfn [(is-prime? [n] \n                     (and (not-any? zero? (map #(mod n %) (range 2 (inc (java.lang.Math/sqrt n))))) \n                          (not= n 0)\n                          (not= n 1)))\n          (get-next [n f] \n                    (if (is-prime? (f n)) \n                      (f n) \n                      (get-next (f n ) f)))]\n    (and (is-prime? a) \n         (= a (/ (+ (get-next a dec) (get-next a inc)) 2)))))", "problem": 116, "user": "532418f3e4b09d4e7a9b54d8"}, {"code": "(letfn [(divides [n f] (= (rem n f) 0))\n         (primes [last-prime ps]\n           (let [p (first (filter #(not (some (fn [p] (divides % p)) ps))\n                                  (iterate inc (inc last-prime))))]\n             (cons last-prime (lazy-seq (primes p (conj ps p))))))]\n   (fn [x]\n     (let [ps (primes 2 [2])\n           i (first (filter #(>= (nth ps %) x) (iterate inc 0)))\n           p1 (nth ps (max (dec i) 0))\n           p2 (nth ps i)\n           p3 (nth ps (inc i))]\n       (and\n        (= p2 x)\n        (= (- p2 p1) (- p3 p2))))))", "problem": 116, "user": "53224d45e4b09d4e7a9b54c0"}, {"code": "(fn [n]\n  (let [sieve       (fn sieve [s]\n                      (cons (first s)\n                            (lazy-seq (sieve (filter #(not (= 0 (mod % (first s))))\n                                                     (rest s))))))\n        n-set       (first (drop-while #(> n (second %)) (partition 3 1 (sieve (iterate inc 2)))))\n        ]\n    (= n\n       (second n-set)\n       (/ (+ (first n-set) (last n-set)) 2))))", "problem": 116, "user": "53460d02e4b084c2834f4a39"}, {"code": "(fn [n]\n  (letfn [(prime? [n]\n            (if (or (false? (integer? n)) (< n 2)) false\n              (every? #(> (mod n %) 0) (range 2 n))))]\n    (cond\n      (= n 2) false\n      (not (prime? n)) false\n      :else\n      (let [primes (filter prime? (iterate inc 2))\n            s (last (take-while #(>= n (second %)) (partition 3 1 primes)))]\n        (prime? (/ (+ (first s) (last s)) 2))))))", "problem": 116, "user": "5300158ae4b0d8b024fd370f"}, {"code": "(fn [x] (letfn [(c [y] (reduce #(and % %2) (< 1 y) (map #(not= 0 (mod y %)) (range 2 y))))]\n          (and (c x) \n               (loop [u (- x 1) v (+ 1 x)]\n                 (if (c u)\n                   (c v)\n                   (if (c v)\n                     (c u)\n                     (recur (dec u) (inc v))\n                     )\n                   )\n                 )\n               )\n          )\n  )", "problem": 116, "user": "526a7025e4b03e8d9a4a722a"}, {"code": "(fn [x]\n  (let [f (fn []\n            (loop [n 5 primes (list 3 2) ]\n    (if (< x (second primes))\n      false\n      (if (= x (second primes))\n        (= (+ (second (next primes)) (first primes)) (* 2 (second primes)))\n        (if (not-any? zero? (map #(mod n %) primes))\n          (recur (inc (inc n)) (cons n primes))\n          (recur (inc (inc n)) primes)\n          )))))\n        ]\n    (if (or (even? x) (< x 3)) false (f) )\n    ))", "problem": 116, "user": "5349ac2be4b084c2834f4a67"}, {"code": "(fn [n] (letfn [(prime? [n p] (every? #(pos? (rem n %)) p))                                                                                                                                   \n                      (next-prime [m p] (if (prime? (+ m 2) p) (into [] (conj p (+ 2 m))) (recur (+ m 2) p)))                                                                                                   \n                (generate-prime [n p] (if (> (peek p) n) nil (lazy-seq (cons (peek p) (generate-prime n (next-prime (peek p) p))))))]                                                                           \n                            (let [z (into [] (generate-prime n [2 3]))] (if (and ((comp not nil?) z) (< 1 (count z)) (= n (last z)))                                                                            \n                                                                          (let [p1 (next-prime (last z) z)                                                                                                      \n                                                                                q (subvec p1 (- (count p1) 3))] (= (second q) (quot (+ (first q) (last q)) 2))) false))))", "problem": 116, "user": "52265e41e4b04e78ff2e1981"}, {"code": "(fn [n]\n  (let [primes (let [multiple-of? (fn [a] #(= 0 (mod % a)))\n                     series (iterate inc 2)]\n                 ((fn sieve [xs]\n                    (cons (first xs)\n                          (lazy-seq (sieve (remove (multiple-of? (first xs)) (rest xs))))))\n                  series))\n        mean (fn [xs] (/ (reduce + xs) (count xs)))]\n    (->> primes\n         (take-while #(< % (* 2 n)))\n         (partition 3 1)\n         (filter (fn [[_ x _]] (= x n)))\n         (first)\n         ((fn [[_ x _ :as xs]] (if xs (= x (mean xs)) false)))\n         )))", "problem": 116, "user": "5312cdaae4b08068f379ed03"}, {"code": "(fn b-prime [n]\n  (letfn [(prime [n]\n                 (not-any? #(= 0 (mod n %))\n                       (range 2 n)))]\n    (and (prime n)\n         (let [l-prime (first (filter prime\n                                      (range (- n 1)\n                                             1\n                                             -1)))\n               r-prime (first (filter prime\n                                      (range (+ n 1)\n                                             Integer/MAX_VALUE)))]\n           (if (or (= nil l-prime)\n                   (= nil r-prime))\n             false\n             (= (* n 2)\n                (+ l-prime r-prime)))))))", "problem": 116, "user": "531d34cfe4b08068f379edac"}, {"code": "(fn balanced?\n  [n]\n  (letfn [(primes\n            [limit]\n            (let [base (map-indexed vector (range limit))]\n              (loop [c [2 2]\n                     r (rest base)]\n                (if (nil? c)\n                  (mapv first (filter (fn [[i v]] (not= 0 v)) r))\n                  (let [nr (map (fn [[i v]] [i (if (and (zero? (mod i (first c))) (not= i (first c))) 0 v)]) r)\n                        nc (first (filter (fn [[i v]] (not= 0 v)) (drop (first c) nr)))]\n                    (recur nc nr))))))]\n    (if (and (not= 5 n) (some zero? (map #(mod n %) [2 3 5 7 11 13 17 19 23 29 31])))\n      false\n      (let [p (concat [0] (primes (+ n (Math/ceil (Math/sqrt n)))))\n            i (first (filter (fn [[k v]] (= n v)) (map-indexed vector p)))]\n        (if (nil? i)\n          false\n          (let [imo (first (drop (dec (first i)) p))\n                ipo (first (drop (inc (first i)) p))]\n            (if (or (nil? imo) (nil? ipo))\n              false\n              (= n (quot (+ imo ipo) 2)))))))))", "problem": 116, "user": "5348cab4e4b084c2834f4a5e"}, {"code": "(fn [x]\n  (let [prime? (fn [x] (and (or (= x 2) (odd? x)) (every? #(< 0 (mod x %)) (range 3 (+ 1 (Math/sqrt x)) 2))))]\n    (if (or (= x 2) (not (prime? x))) false\n                                      (let [p (->> (iterate dec (dec x)) (filter prime?) first)\n                                            q (->> (iterate inc (inc x)) (filter prime?) first)]\n                                        (= (/ (+ p q) 2) x)))))", "problem": 116, "user": "536d83cee4b0fc7073fd6e5e"}, {"code": "(fn [n]\n  (if (.isProbablePrime (BigInteger/valueOf n) 5)\n    (let [primes (fn primes\n                   ([] (primes (BigInteger. \"2\")))\n                   ([big-integer]\n                     (cons\n                       big-integer\n                       (lazy-seq (primes (.nextProbablePrime big-integer))))))]\n      (loop [previous 0 p (primes)]\n        (let [next (first p)]\n          (if (= n next)\n            (= n (/ (+ previous (second p)) 2))\n            (recur next (rest p))))))\n    false))", "problem": 116, "user": "53513d28e4b084c2834f4ae3"}, {"code": "(fn [n]\n  (if (< n 3) false\n  (letfn [(not-multiples [x] #(not= 0 (mod % x)))\n          (primes-from-seq [xs]\n                           (let [[head tail] (split-at 1 xs)\n                                 start (first head)]\n                             (cons start (lazy-seq (primes-from-seq (filter (not-multiples start) tail))))))]\n    (let [primes (primes-from-seq (drop 2 (range)))\n          [up-to starting-at] (split-with #(< % n) primes)\n          before (last up-to)\n          after (second starting-at)\n          mean (/ (+ before after) 2)]\n      (and (= n (first starting-at)) (= n mean))))))", "problem": 116, "user": "536ca4bde4b0fc7073fd6e49"}, {"code": "(fn [n]\n  (let [p (fn [n] (and (> n 1) (every? #(> (mod n %) 0) (range 2 n))))\n        b #(let [x (p (+ n %))\n                 y (p (- n %))]\n              (cond (and x y) true\n                    (or x y) false\n                    1 (recur (+ % 1))))]\n    (and (p n) (b 1))))", "problem": 116, "user": "536e0930e4b0fc7073fd6e66"}, {"code": "(fn [n]\n  (loop [b (dec n) a (inc n) i 2]\n    (cond\n     (<= b 1) false\n     (>= (* i i) (* 2 n)) (= (+ b a) (* 2 n))\n     (= (mod n i) 0) false\n     (and (= (mod b i) 0) (< i b)) (recur (dec b) a 2)\n     (= (mod a i) 0) (recur b (inc a) 2)\n     :else (recur b a (inc i)))))", "problem": 116, "user": "5370f8ede4b0fc7073fd6ea2"}, {"code": "(let [mem (atom {})]\n  (letfn [(prime? [n] (if-let [e (find @mem n)]\n                        (val e)\n                        (let [ret (every? (comp not zero? #(mod n %)) (range 2 n))]\n                          (swap! mem assoc n ret) ret)))\n          (bal? [a b c] (= b (/ (+ a b c) 3)))\n          (take-2nd-if [f [a b c :as s]] (if (f a b c) b))\n          (in-seq? [v [x & xs]] (or (= v x) (and (> v x) (in-seq? v xs))))]\n    (fn [n]\n      (in-seq? n\n               (filter (comp not nil?)\n                       (map (partial take-2nd-if bal?)\n                            (partition 3 1\n                                       (filter prime? (drop 2 (range))))))))))", "problem": 116, "user": "52d1e364e4b0d9f9285948e7"}, {"code": "(letfn [(S [s]\n          (cons (first s)\n                (lazy-seq (S (filter #(not (= 0 (rem % (first s)))) (rest s))))))\n\n        (X? [n [x y z & more :as s]]\n          (cond (< n x) false\n                (and (= n y) (= (+ n y) (+ x z))) true\n                :else (recur n (rest s))))]\n  (fn [n]\n    (X? n (S (drop 2 (range))))))", "problem": 116, "user": "51a4416ae4b0def3c5c5868c"}, {"code": "(fn balanced-prime? [n]\n  (letfn [(sieve [s]\n                 (cons (first s)\n                       (lazy-seq (sieve (filter #(not= 0 (mod % (first s))) (rest s))))))]\n    (let [ps (sieve (iterate inc 2))\n        c (count (take-while (partial >= n) ps))\n        vals (take 3 (reverse (take (inc c) ps)))]\n      (cond\n        (not= n (second vals)) false\n        :else (= (second vals) (/ (reduce + vals) 3))))))", "problem": 116, "user": "4f849f76e4b033992c121c36"}, {"code": "(fn aa [n]\n  (letfn [(prime? [x]\n            (and (number? x)\n                 (> x 1)\n                 (or (= x 2)\n                     (not (some #(zero? (mod x %))\n                                (cons 2 (range 3 (inc (Math/sqrt x)) 2)))))))]\n    (and (prime? n)\n         (let [a (first (filter prime? (iterate inc (inc n))))\n               b (first (filter prime? (range (dec n) 1 -1)))]\n           (and (number? a)\n                (number? b)\n                (= (* 2 n) (+ a b)))))))", "problem": 116, "user": "50ae0d24e4b0a40c9cfb08ce"}, {"code": "#(if (< % 5) false\n   (letfn [(p [t] (or (= 2 t) (every? pos? (map (partial mod t) (range 3 t 2))))) \n           (n [u f] (if (p (f u 2)) (f u 2)\n               \t\t\t\t(n (f u 2) f)))]\n (and (p %) (= (* % 2) (+ (n % +) (n % -))))))", "problem": 116, "user": "53973e7be4b0b51d73faaee6"}, {"code": "(fn [n]\n  (letfn [(sieve [[x & xs]] (lazy-seq (cons x (sieve (filter #(pos? (mod % x)) xs)))))\n          (balanced [[prev x nxt]] (= (- x prev) (- nxt x)))]\n    (= n (first (drop-while #(< % n) (map second (filter balanced (partition 3 1 (sieve (iterate inc 2))))))))))", "problem": 116, "user": "52dd4fb4e4b09f7907dd13df"}, {"code": "(fn bal-prime? [n]\n  (letfn [(is-prime? [n]\n            (case n\n              1 false\n              2 true\n              (every? #(not= 0 (rem n %))\n                      (cons 2 (range 3\n                                     (-> n Math/sqrt Math/ceil int inc)\n                                     2)))))\n          (next-prime [n f]\n            (first (filter is-prime? (drop 1 (iterate f n)))))]\n    (and (is-prime? n)\n         (= (- (next-prime n inc) n)\n            (- n (next-prime n dec))))))", "problem": 116, "user": "539a2901e4b0b51d73faaf0f"}, {"code": "(fn balanced-prime? [n]\n  (let [average (fn average [x y]\n                  (/ (+ x y) 2))\n        primes (fn primes []\n                 (let [stream (iterate inc 2)\n                       sieve (fn [p stream]\n                               (filter #(not= 0 (mod % p))\n                                       stream))\n                       run-sieve (fn run-sieve [stream]\n                                   (lazy-seq\n                                     (let [p (first stream)]\n                                       (cons p\n                                             (run-sieve (sieve p stream))))))]\n                   (run-sieve stream)))\n        prime? (fn prime? [n]\n                 (let [ps (take-while #(>= n %) (primes))\n                       x (last ps)]\n                   (= x n)))\n        primes-before-and-after (fn primes-before-and-after [n]\n                                  (let [ps (primes)\n                                        primes-upto (seq (take-while #(>= n %) ps))\n                                        c (count primes-upto)\n                                        p-before (nth ps (- c 2))\n                                        p-after (nth ps c)]\n                                    [p-before p-after]))]\n    (and (not= n 1)\n         (not= n 2)\n         (prime? n)\n         (= n (apply average (primes-before-and-after n))))))", "problem": 116, "user": "4f35b2ace4b0e243712b1ec5"}, {"code": "(fn balanced-prime? [x]\n  (letfn [(primes []\n            (let [sieve (fn sieve [xs] (cons (first xs) (lazy-seq (sieve (filter #(> (mod % (first xs)) 0) (rest xs))))))]\n              (sieve (drop 2 (range)))))\n          (global-take-while [n p s]\n            (cond\n             (= n 1)       (take-while (complement p) s)\n             (p (first s)) (cons (first s) (lazy-seq (global-take-while (dec n) p (rest s))))\n             :else         (cons (first s) (lazy-seq (global-take-while n p (rest s))))))]\n    (and (> x 2)\n         (let [[a b c]  (take-last 3 (global-take-while 2 #(> % x) (primes)))]\n           (= b x (/ (+ a c) 2))))))", "problem": 116, "user": "530bf87ee4b02e82168697d5"}, {"problem": 116, "code": "(fn [n]\n  (let [prime? (fn [n]\n                 (every? #(not= (mod n %) 0) (range 2 (inc (quot n 2)))))\n        take-prime (fn [dir]\n                     (let [s (if (> dir 0) (iterate inc (inc n)) (range (dec n) 1 -1))]\n                       (first (drop-while (complement prime?) s))))\n        prime-1 (take-prime -1)\n        prime-2 (take-prime 1)]\n    (and (not (nil? prime-1))\n          (not (nil? prime-2))\n         (prime? n)\n         (= (/ (+ prime-1 prime-2) 2) n))))", "user": "536f871de4b0fc7073fd6e7f"}, {"problem": 116, "code": "(fn [n]\n  (let [prime (fn [n]\n                (when (not-any? #(zero? (rem n %))\n                                (range 2 (dec n)))\n                  n))\n        i (some prime (reverse (range 2 n)))\n        j (some prime (drop (inc n) (range)))]\n    (and (> n 2)\n         (= n (prime n))\n         (= n (/ (+ i j) 2)))))", "user": "524b0645e4b09eba1c0223bf"}, {"problem": 116, "code": "(fn [n]\n  (let [primes (letfn [(prime-seq [known-primes candidate]\n                         (if (some #(zero? (mod candidate %)) known-primes)\n                           (recur known-primes (+ 2 candidate))\n                           (cons candidate \n                                 (lazy-seq (prime-seq (conj known-primes candidate)\n                                                      (+ 2 candidate))))))]\n                 (cons 2 (prime-seq [2] 3)))\n        balanced-primes (map second\n                             (filter (fn [[a b c]]\n                                       (= b (/ (+ a c) 2)))\n                                     (partition 3 1 primes)))]\n    (boolean (some #{n} (take-while (partial >= n)\n                                    balanced-primes)))))", "user": "52951156e4b02ebb4ef7501b"}, {"problem": 116, "code": "(fn [n]\n  (letfn [(fp [p]\n          (if (or (= p 3) (= p 5)) true\n            (loop [x 3]\n              (if (= (mod p x) 0) false\n                (if (> x (/ p 2)) true\n                  (recur (inc (inc x))))))))]\n    (if (or (< n 5) (= (mod n 2) 0)) false\n      (let [a (loop [x (dec (dec n))]\n                (if (fp x) x\n                  (recur (dec (dec x)))))\n            b (loop [x (inc (inc n))]\n                (if (fp x) x\n                  (recur (inc (inc x)))))]\n        (and (fp n) (= n (/ (+ a b) 2)))))))", "user": "53a1b5c8e4b0ca733b9744c1"}, {"problem": 116, "code": "(fn [p] (let [primes (let [ok (fn [p] (every? #(not= 0 (rem p %)) (drop 2 (range p))))]\n                       (filter ok  (drop 2 (range))))\n              three (last (take-while #(<= (second %) p) (partition 3 1 primes)))]\n          (and (= p (second three)) (= (* 2 p) (+ (first three) (last three))))))", "user": "53976599e4b0b51d73faaeea"}, {"problem": 116, "code": "(fn [num]\n  (let [prime-seq (fn p\n                    ([] (cons 2 (p 2 [2])))\n                    ([current-prime seen]\n                     (lazy-seq\n                       (let [is-prime? (fn [x]\n                                         (reduce #(and %1 (> (rem x %2) 0)) true seen))\n                             next-prime (->> (inc current-prime)\n                                             (iterate inc)\n                                             (filter is-prime?)\n                                             (first)\n                                             )]\n                         (cons next-prime (p next-prime (conj seen next-prime)))\n                         ))))\n        prime-triplet (->> (prime-seq)\n                           (partition 3 1)\n                           (map vec)\n                           (drop-while #(< (% 1) num))\n                           (first))]\n    (if (= num (prime-triplet 1))\n      (== num (/ (+ (prime-triplet 0) (prime-triplet 2)) 2.0))\n      false\n      )))", "user": "53527551e4b084c2834f4af0"}, {"problem": 116, "code": "(fn [n]\n  (let [prime? (fn [n]\n                 (and\n                  (<= 2 n) \n                  (loop [n n i 2]\n                    (cond (< n (* i i)) true\n                          (zero? (mod n i)) false\n                          :else (recur n (inc i))))))]\n    (and\n     (prime? n)\n     (let [a (->> (range (dec n) 1 -1)\n                  (filter prime?)\n                  first)\n           b (->> (range)\n                  (map #(+ n 1 %))\n                  (filter prime?)\n                  first)]\n       (and a b (= (* 2 n) (+ a b)))))))", "user": "53800d99e4b06839e8705ebd"}, {"problem": 116, "code": "(fn balancedprime? [n]\n                                (if (<= n 3)\n                                  false\n                                  (loop [init (vec (rest (rest (take n (range))))) fut (drop (+ n 1) (range))]\n                                    (if (empty? (rest init))\n                                      (= n (/ (+ (peek init) (first fut)) 2))\n                                      (if (= 0 (mod n (first init)))\n                                        false\n                                        (recur (vec (remove #(= 0 (mod % (first init))) init))\n                                               (remove #(= 0 (mod % (first init))) fut)))))))", "user": "532727bae4b09d4e7a9b54fa"}, {"problem": 116, "code": "(fn [n]\n  (let [prime? (fn [k]\n                 (if (<= k 1)\n                   false\n                   (loop [i 2]\n                     (if (>= i k)\n                       true\n                       (if (zero? (mod k i))\n                         false\n                         (recur (inc i)))))))\n        p-prime (fn [k]\n                  (if (= k 2)\n                    0\n                    (loop [i (dec k)]\n                      (if (prime? i)\n                        i\n                        (recur (dec i))))))\n        n-prime (fn [k]\n                   (loop [i (inc k)]\n                     (if (prime? i)\n                       i\n                       (recur (inc i)))))]\n    (and (prime? n)\n         (= n (/ (+ (p-prime n) (n-prime n)) 2)))))", "user": "4f041de1535dcb61093f6ba5"}, {"problem": 116, "code": "(fn [n]\n  (let [not-balanced-primes [0 1 2 3]]\n    (letfn [(prime? [x]\n              (not (some zero? (map (partial rem x) (range 2 x)))))\n            (next-prime [n]\n              (first (take 1 (filter prime? (iterate inc (inc n))))))\n            (prev-prime [n]\n              (first (take 1 (filter prime? (iterate dec (dec n))))))]\n      (and (= -1 (.indexOf not-balanced-primes n))\n           (prime? n)\n           (= n (/ (+ (next-prime n)\n                      (prev-prime n))\n                   2))))))", "user": "532bce35e4b09d4e7a9b5536"}, {"problem": 116, "code": "(fn [v]\n  (letfn [(prime? [primes v]\n            (not (some #(zero? (mod v %)) primes)))\n          (get-primes [m]\n            (loop [primes [2]\n                   i 3]\n              (if (> i m) primes\n                  (recur\n                   (if (prime? primes i) (conj primes i) primes)\n                   (+ i 2)))))\n          (next-prime [primes]\n            (loop [i (+ (last primes) 2)]\n              (if (prime? primes i) i\n                  (recur (+ i 2)))))]\n    (let [p (get-primes v)]\n      (if (and (>= (count p) 2) (= v (last p)))\n        (let [prv (last (butlast p))\n              nxt (next-prime p)]\n          (= v (/ (+ prv nxt) 2)))\n        false))))", "user": "537e745ae4b06839e8705ea6"}, {"problem": 116, "code": "(fn [n]\n  (letfn [\n    (ip [n] (and (not= n 1 ) (= 1 (count (filter #(zero? (rem n %)) (range 1 (inc (Math/sqrt n))))))))\n    (pn [c] (filter ip (iterate inc c)))\n  ]\n    (if (ip n)\n      (let [np (first (take 1 (pn (inc n)))) pp (- n (- np n))]\n        (and (ip pp) (= n (first (take 1 (pn (inc pp))))))\n      )\n      false\n      )\n    )\n)", "user": "53ae16e2e4b047364c044472"}, {"problem": 116, "code": "(fn\n  [n]\n  (let [odds (iterate (partial + 2) 3)]\n    (letfn [(divides? [n d] (= 0 (mod n d)))\n            (is-prime [n] (cond\n                            (< n 2) false\n                            (= n 2) true\n                            (divides? n 2) false\n                            :else (let [divs (take-while #(<= (* % %) n)\n                                                         odds)]\n                                    (nil? (some (partial divides? n) divs)))))\n            (next-prime\n              [n]\n              (if (= n 2)\n                3\n                (first (for [o (iterate (partial + 2) (+ 2 n))\n                             :when (is-prime o)] o))))]\n\n      (if (is-prime n)\n        (let [np (next-prime n)\n              pp (- n (- np n))]\n          (and (is-prime pp)\n               (= n (next-prime pp))))\n        false))))", "user": "52dfc89be4b09f7907dd1405"}, {"problem": 116, "code": "(fn [p]\n  (let [prime? (fn [x]\n                 (if (> x 3)\n                   (every? #(> (mod x %) 0) (range 2 (int (+ 1 (Math/sqrt x)))))\n                   (= x 3)))\n        next-prime-f (fn [x]\n                     (loop [incx (inc x)]\n                       (if (prime? incx) incx (recur (inc incx)))))\n        last-prime-f (fn [x] (first (filter prime? (range (- x 1) 2 -1))))\n        p-prime? (prime? p)\n        last-prime (when p-prime? (last-prime-f p))]\n    (and\n      p-prime?\n      last-prime\n      (= p (/ (+ last-prime (next-prime-f p)) 2)))))", "user": "53b530c6e4b047364c0444bc"}, {"problem": 116, "code": "(fn balanced-prime? [n]\n  (let [\n        prime? (memoize (fn [n] (and (not= 1 n) (every? #(not= 0 (mod n %)) (range 2 n)))))\n        primes (memoize (fn [] (filter prime? (drop 2 (range)))))]\n    (and\n     (not (#{0 1 2} n))\n     (prime? n)\n     (= n (some (fn [[a b c]] (when (= b n) (/ (+ a c) 2))) (partition 3 1 (primes)))))))", "user": "4ddb696b535d02782fcbe9fa"}, {"problem": 116, "code": "(fn balanced? [n]\n  (letfn [(prime? [n]\n            (and (> n 1) (or (= n 2) (not-any? #(= 0 (rem n %))(range 2 n)))))\n          (next-prime [n s]\n            (first (filter prime? (iterate #(+ % s) (+ n s)))))]\n    (and (> n 4)\n         (prime? n)\n         (= n (/ (+ (next-prime n 1) (next-prime n -1)) 2)))))", "user": "53b39d82e4b047364c0444a6"}, {"problem": 116, "code": "(fn __\n  [n]\n  (letfn [(prime? [n]\n                  (if (even? n) false\n                    (let [root (num (int (Math/sqrt n)))]\n                      (loop [i 3]\n                        (if (> i root) true\n                          (if (zero? (mod n i)) false\n                            (recur (+ i 2))))))))\n          (sister-prime\n           [n op]\n           (loop [n (op n)]\n             (if (< n 2) 0\n             (if (prime? n)\n               n\n               (recur (op n))))))\n          (previous-prime [n] (sister-prime n dec))\n          (next-prime [n] (sister-prime n inc))]\n    (if (prime? n)\n      (if \n        (= n\n         (/ (+ (next-prime n) (previous-prime n)) 2))\n        true ; [(next-prime n) n (previous-prime n)]\n        false)\n      false)))", "user": "53ac4719e4b047364c04445c"}, {"problem": 116, "code": ";; budu's solution to Prime Sandwich\n;; https://4clojure.com/problem/116\n\n(fn [x] (let [f (fn s [[p & r]]\n                  (lazy-seq (cons p (s (remove #(= 0 (mod % p)) r)))))\n            p (f (iterate inc 2))\n            b (take-while #(<= % x) p)\n            x* (last b)\n            n (count b)\n            b (last (butlast b))\n            a (last (take (inc n) p))] (and (= x* x) (= x (/ (+ (or b 0) a) 2)))))", "user": "52828298e4b0757a1b17145b"}, {"problem": 116, "code": "(fn balanced-prime? [n]\n  (letfn [(prime? [x] (and (> x 1) (not-any? #(zero? (rem x %1)) (range 2 x))))\n          (second-prime [xs] (second (filter prime? xs)))\n          (mean [a b] (/ (+ a b) 2))]\n    (let [prev-prime (second-prime (iterate inc n))\n          next-prime (second-prime (range n 0 -1))]\n      (and (> n 2) (prime? n) (= n (mean prev-prime next-prime))))))", "user": "52e657e4e4b09f7907dd1472"}, {"problem": 116, "code": "(fn [n]\n  (if (< n 3)\n    false\n    (loop [primes []\n         current 2]\n      (if (not-any? identity (map #(= 0 (rem current %)) primes))\n        ;;prime\n        (if (> current n)\n          ;;surrounding primes found\n          (if (= n (/ (+ current (last (butlast primes))) 2) )\n            true\n            false)\n          ;;not found all we need yet\n          (recur (conj primes current) (inc current)))\n        ;;not prime\n        (if (= current n)\n          false\n          (recur primes (inc current))))))\n  )", "user": "53c1ce3ee4b00fb29b221268"}, {"problem": 116, "code": "(fn [x]\n  (cond\n    (= x 0) false     (= x 1) false    (= x 2) false\n    :else \n  (let [prime? (fn [n]\n                 (->> (range 2 n)\n                   (filter #(= 0 (mod n %)))\n                   count\n                   (= 0)))\n        prev-prime (first (filter prime? (range (- x 1) 1 -1)))\n        next-prime (first (filter prime? (map (partial + x 1) (range))))]\n    (and (prime? x) (= x (/ (+ prev-prime next-prime) 2))))))", "user": "53c38b8ce4b00fb29b22127b"}, {"problem": 116, "code": "(fn t116 [n]\n  (let [is_prime (fn is_prime [x] (if (= x 2)\n                           true\n                           (every? #(not= 0 (rem x %)) (cons 2 (filter odd? (range 3 x))))))]\n    (and (not= n 1) (not= n 2) (is_prime n) (= n (/ (+ (nth (filter is_prime (range n (+ n 1000))) 1) (nth (filter is_prime (range n 0 -1)) 1)) 2)))))", "user": "5046f909e4b03b02161376b5"}, {"problem": 116, "code": "(fn balanced-prime? [n]\n  (let [prime? #(.isProbablePrime (BigInteger/valueOf %) 5)\n        f-prime (fn [xs] (some #(if (prime? %) %) xs))]\n    (and\n      (prime? n)\n      (= n (/ (+ (f-prime (range (if (> n 3) (dec n) 3) 2 -1)) \n                 (f-prime (range (inc n) Long/MAX_VALUE))) \n              2)))))", "user": "50c781bbe4b00bb60fe0c535"}, {"problem": 116, "code": "(fn [p]\n  (letfn [(prime? [x] (and (not (#{0 1} x))\n                           (empty? (filter #(= (mod x %) 0) \n                                           (range 2 x)))))\n          (previous-prime [x] (or (first (filter prime? (reverse (range x)))) 0))\n          (next-prime [x] (or (first (filter prime? (iterate inc (inc x)))) 0))]\n    (and (prime? p)\n         (= p (/ (+ (previous-prime p)\n                    (next-prime p))\n                 2)))))", "user": "53acaf1fe4b047364c04445f"}, {"problem": 116, "code": "(fn [n]\n  (let [sieve (fn sieve [s] (cons (first s) (lazy-seq (sieve (filter #(not= 0 (mod % (first s))) (rest s))))))\n        pairs (first (drop-while #(< (nth % 1) n) (partition 3 1 (sieve (iterate inc 2)))))]\n    (if (= (nth pairs 1) n)\n        (= n (/ (+ (first pairs) (last pairs)) 2))\n        false)))", "user": "4ee6400c535d93acb0a6685b"}, {"problem": 116, "code": "(letfn [(primes \n            ([] (primes (iterate inc 2)))\n            ([nums]\n              (lazy-seq (cons (first nums) \n                              (primes (filter #(not= 0 (rem % (first nums))) (rest nums)))))))\n          (b-prime? [n]\n                    (let [[b a] (split-with (partial > n) (primes))]\n                      (and \n                        (= n (first a))\n                        (seq b)\n                        (= n (/ (+ (last b) (second a)) 2))))\n                    )\n          ]\n    b-prime?)", "user": "50eddbc4e4b06330c1f87c4b"}, {"problem": 116, "code": "(fn [n]\n  (let [p (fn prime [i ps]\n            (if (every? #(not= 0 (mod i %)) ps)\n              (cons i (lazy-seq (prime (inc i) (conj ps i))))\n              (prime (inc i) ps)))]\n    (loop [b 0 [x & xs] (p 3 [2])]\n      (cond\n       (> x n) false\n       (= x n) (if (= n (/ (+ b (first xs)) 2)) true false)\n       :else (recur x xs)))))", "user": "53b7c21ae4b047364c0444d4"}, {"problem": 116, "code": "(fn balanced? [n]\n  (let [primes (fn primes [s]\n                 (cons (first s)\n                       (lazy-seq (primes (filter #(not (= 0 (mod % (first s))))\n                                                 (rest s))))))\n        n-set (first (drop-while #(> n (second %)) (partition 3 1 (primes (iterate inc 2)))))]\n    (= n\n       (second n-set)\n       (/ (+ (first n-set) (last n-set)) 2))))", "user": "52d00832e4b07d0d72b273b4"}, {"problem": 116, "code": "(fn balanced-prime? [x]\n  (letfn [(prime? [x]\n            (cond (< x 2) false\n                  (= x 2) true\n                  (every? #(not= (mod x %) 0) (range 2 (int (inc (Math/sqrt x))))) true\n                  :else false))\n          (next-prime [y d]\n            (loop [current (+ y d)]\n              (if (or (prime? current) (< current 1)) current (recur (+ current d)))))]\n    (if (not (prime? x)) false\n        (let [after (next-prime x 1)\n              before (next-prime x -1)]\n          (= x (/ (+ after before) 2))))))", "user": "53bf0913e4b0c98a41f5cc99"}, {"problem": 116, "code": "(fn balance-prime? [test]\n  (let [primes (fn [max]\n                 (cond\n                   (<= max 2) [2]\n                   (= max 3) [2 3]\n                   :else\n                   (loop [r [2 3], x 5]\n                     (if (> x max)\n                       r\n                       (if ((fn is-prime? [i]\n                              (not\n                                (some\n                                  #(= (mod i %) 0)\n                                  (range 3 i 2)\n                                  ))\n                              ) x)\n                         (recur (conj r x) (+ x 2))\n                         (recur r (+ x 2))\n                         )\n                       )\n                     )\n                   )\n                 ),\n        plist (primes test),\n        max-prime (last plist)]\n    (if (and (>= test 5) (= max-prime test))\n      (let [prev (first (take-last 2 plist)),\n            next (- (* test 2) prev)]\n        (let [nplist (primes next)]\n          (and (= next (last nplist))\n               (= (count nplist) (inc (count plist)))\n               ))\n        )\n      false\n      )\n    ))", "user": "53ca41dae4b00fb29b2212c8"}, {"problem": 116, "code": "(fn [n]\n\t(loop [primes '(2)\n\t\t   current 3]\n\t\t   (let [[a b c & r] primes]\n\t\t   (if (and a b c (= n b))\n\t\t\t\t(= n (/ (+ a c) 2))\n\t\t\t\t(if (and a b c (> b n)) false\n\t\t\t\t\t(recur (if (every? true? (map #(not= 0 (rem current %)) primes)) (conj primes current) primes) (+ 2 current)))))))", "user": "53e19461e4b0d874e779ae59"}, {"problem": 116, "code": "(fn bal? [n]\n  (letfn [( primes [x]\n            (loop [rm (range 2 (+ 100 x)), acc []]\n              (let [f (first rm)]\n                (cond (nil? f) acc\n                      :else (recur (remove #(= 0 (mod % f)) rm) (conj acc f))))))]\n    (let [s (primes n)\n          i (.indexOf s n)]\n      (if (< i 1) false\n          (= n (/ (+ (nth s (dec i)) (nth s (inc i))) 2))))))", "user": "538e36c7e4b0b51d73faae81"}, {"problem": 116, "code": "(fn [n]\n  (let [prime? (fn [n]\n                  (every? true?\n                    (map\n                      (fn [a] (not (zero? (rem n a))))\n                      (range 2 n))))\n        l (first (filter prime? (range (dec n) 1 -1)))\n        r (first (filter prime? (iterate inc (inc n))))]\n    (and (prime? n) (> n 2)\n         (= (/ (+ l r) 2) n))))", "user": "53d78b64e4b0e771c3025466"}, {"problem": 116, "code": "(fn [x]\n   (let [l (take 200 ((fn s [[x & xs]]\n                          (lazy-seq\n                           (cons x\n                                 (s (filter #(not (zero? (rem % x))) xs)))))\n                        (range 2 1200)))\n         [p _ n] (first (filter #(= x (second %)) (partition 3 1 l)))]\n     (if p\n       (= x (/ (+ p n) 2))\n       false)))", "user": "523ed522e4b057c4b7cd0a78"}, {"problem": 116, "code": "(fn [x]\n    (let [prime? #(loop[i 2](if(=(mod % i)0)nil(or(>(* i i)%)(recur(inc i)))))]\n      (if (and (> x 3) (prime? x))\n        (= (+ x x) (+ (first (filter prime? (iterate inc (inc x))))\n                      (first (filter prime? (range (dec x) 1 -1)))))\n        false)))", "user": "513e8141e4b02b2a3d8235c1"}, {"problem": 116, "code": "(fn balanced-prime [n]\n  (letfn [(nums-from [n] (map (partial + n) (range)))\n          (next-prime\n            [primes last-prime]\n            (first\n              (filter (fn [cand] (not-any? #(zero? (mod cand %)) primes))\n                      (nums-from (inc last-prime)))))]\n    (->> (loop [primes [2] last-prime 2]\n           (if (> last-prime n)\n             primes\n             (let\n                 [next (next-prime primes last-prime)]\n                 (recur (conj primes next) next))))\n         (take-last 3)\n         (#(and (= (second %) n) (= (+ (first %) (last %)) (* 2 n)))))))", "user": "53dc94c8e4b094d41abdfefc"}, {"problem": 116, "code": "(fn sandwich-prime [n]\n  (letfn [(prime [n] \n            (when (>= n 2)\n              (not (some #(zero? (rem n %))\n                         (range 2 (dec n))))))\n          (prev-next-prime [n]\n            (when (prime n)\n              [(some #(when (prime %) %) (range (dec n) 0 -1))\n               (some #(when (prime %) %) (range (inc n) (* 2 (inc n))))]))]\n    (if (prime n)\n      (let [[pp np] (prev-next-prime n)]\n        (and pp np (= (/ (+ pp np) 2) n)))\n      false)))", "user": "4ee528fb535d1385b2869d87"}, {"problem": 116, "code": "(fn [s]\n   (let [q (first\n            (filter #(<= s (second %))\n                    (partition-all 3 1\n                                   ((fn sieve [s]\n                                      (cons (first s)\n                                            (lazy-seq (sieve (filter #(not= 0 (mod % (first s)))\n                                                                     (rest s))))))\n                                    (iterate inc 2)))))]\n     (and (= s (second q)) (= (- s (first q)) (- (last q) s)))))", "user": "53f6d555e4b0db01ade6f9e5"}, {"problem": 116, "code": "#(letfn [(p? [n] (.isProbablePrime (BigInteger/valueOf n) 10)) \n         (pa [n f] (let [nd (f n)] \n                     (if (p? nd) nd (pa nd f)))) ] \n    (and (p? %) (= % (/ (+ (pa % inc) (pa % dec)) 2))))", "user": "53b2a7f8e4b047364c04449c"}, {"problem": 116, "code": "(fn ps? [n]\n   (let [primes (fn []\n                  (letfn [(sieve [coll]\n                            (let [head (first coll)]\n                              (lazy-seq (cons head (sieve (filter #(pos? (mod % head)) coll))))))]\n                    (sieve (iterate inc 2))))\n         [prv cur nxt] (last (take-while (fn [[a b c]] (<= b n)) (partition 3 1 (primes))))]\n     (and (= n cur)\n          (= (- cur prv) (- nxt cur)))))", "user": "535eaa73e4b04ce2eb3ed2d4"}, {"problem": 116, "code": "(fn [x] (let [prim ((fn peu [s] (cons (first s) (lazy-seq (peu (filter #(not= 0 (mod % (first s)))(rest s)))))) (iterate inc 2))] (let [y (first (filter #(> (second %) (dec x)) (partition 3 (interleave prim (rest prim) (rest (rest prim))))))] (and (= x (second y)) (= x (/ (+ (first y) (last y)) 2))))))", "user": "53fc8424e4b0de5c418485b3"}, {"problem": 116, "code": "(fn balanced? [n] \n  (let [prime? (fn [n] (if (< n 2) false (every? #(not= 0 (mod n %)) (range 2 n))))]\n    (if (not (prime? n)) false\n       (let [anil (first (filter prime? (range (dec n) 1 -1)))\n             a (if (nil? anil) 0 anil)\n             c (first (filter prime? (range (inc n) Long/MAX_VALUE)))]\n\t         (== n (/ (+ a c) 2))))))", "user": "53fe1c3be4b0de5c418485f2"}, {"problem": 116, "code": "(fn balanced-prime? [n]\n  (letfn [(prime? [n]\n            (and\n              (>= n 2)\n              (empty? (filter #(zero? (mod n %)) \n                            (range 2 (inc (int (Math/sqrt n))))))))\n          (next-prime [n]\n            (loop [pos-prime (inc n)]\n              (if (prime? pos-prime)\n                pos-prime\n                (recur (inc pos-prime)))))\n          (prev-prime [n]\n            (loop [pos-prime (dec n)]\n              (if (prime? pos-prime)\n                pos-prime\n                (if (< pos-prime 2)\n                  nil\n                  (recur (dec pos-prime))))))]\n    (if (or (not (prime? n)) (nil? (prev-prime n)))    \n      false\n      (if (== n (/ (+ (prev-prime n) (next-prime n)) 2))\n        true\n        false))))", "user": "53791ab7e4b06839e8705e4d"}, {"problem": 116, "code": "(fn [x]\n   (let [divides #(= 0 (rem %2 %1))\n         possible-divisors (fn [y] (take-while #(<= (* % %) y) (range 2 y)))\n         prime (fn [y] (and (> y 1) (not-any? #(divides % y) (possible-divisors y))))]\n     (if (and (prime x) (not= x 2))\n       (let [find-prime (fn  [func] (->> (iterate func x)\n                                        (drop 1)\n                                        (filter prime)\n                                        first))\n             next-prime (find-prime inc)\n             prev-prime (find-prime dec)]\n         (= (* x 2) (+ next-prime prev-prime)))\n       false))\n)", "user": "53ed6976e4b0d648e757f4c4"}, {"problem": 116, "code": "(letfn [(third [xs] (first (next (next xs))))\n        (primes\n          ([] (primes {} 2 Integer/MAX_VALUE))\n          ([table n max]\n           (if-not (> n max)\n             (if-let [factors (table n)]\n               (let [new-table (apply (partial merge-with (comp flatten conj) (dissoc table n))\n                                      (map #(hash-map (+ n %) [%]) factors))]\n                 (recur new-table (inc n) max))\n               (lazy-seq (cons n (primes (conj table [(* n n) [n]]) (inc n) max)))))))\n        (prime-triples\n          ([] (prime-triples (primes)))\n          ([xs] (lazy-seq (cons [(first xs) (second xs) (third xs)] (prime-triples (rest xs))))))]\n\n\n    (fn [x]\n      (let [[a b c] (first (drop-while #(< (second %) x) (prime-triples)))]\n        (= b x (/ (+ a c) 2)))))", "user": "506ba58be4b0eda3100c090b"}, {"problem": 116, "code": "(fn [x]    \n         (let [is-prime  \n               (fn is-prime [x] (and (> x 2) \n                                     (nil? \n                                      (some (fn [z] (= 0 (mod x z)))\n                                            (range 2 (int (inc (Math/sqrt x)))))))\n                 )]\n           (if (and (> x 4) (is-prime x))\n             (let [gp (first (filter is-prime (rest (iterate #(+ % 2) x))))\n                   lp (first (filter is-prime (rest (iterate #(- % 2) x))))]\n               (== lp (- x (- gp x)))\n               ) false)))", "user": "50856bd1e4b004985b776e4c"}, {"problem": 116, "code": "(fn [x]\n  (letfn [(primes [limit]\n                  (loop [p 2 sieve (range 2 limit)]\n                    (if (> (* p p) limit)\n                      sieve\n                      (let [new-sieve (filter #(or (= p %) (not= 0 (rem % p))) sieve) \n                            new-p (first (filter #(> % p) new-sieve))]\n                        (recur new-p new-sieve)))))]\n    (let [[p c n] (flatten (filter #(= x (second %)) (partition 3 1 (primes (-> x (+ 100))))))]\n      (cond\n       (nil? p) false\n       (= (/ (+ p n) 2) c) true\n       :else false))))", "user": "53c649d3e4b00fb29b221297"}, {"problem": 116, "code": "(fn  [n] \n  (letfn [\n \n( getAllnums [n]\n  (range 2 n)\n)\n\n( divides? [a b]\n  (zero? (rem b a))\n)\n\n( thoseDivides [l n]\n  (filter #(divides? % n) l)\n)\n\n( prime? [n]\n  (empty? (thoseDivides (getAllnums n) n))  \n)\n\n\n( nextPrime [n] \n  (if (prime? n) n (nextPrime (inc n)))\n)\n\n\n( prevPrime [n] \n  (if (<= n 2) -1000 \n  (if (prime? n) n (prevPrime (dec n)))\n))\n\n\n( meanFine [n]\n  (= n (/ (+ (prevPrime (dec n)) (nextPrime (inc n))) 2))\n) \n  \n  ]\n\n  (and (prime? n) (meanFine n))\n))", "user": "52faec2ee4b047fd55837004"}, {"problem": 116, "code": "(fn prime-sandwich [n] \n  (let [prime? (fn [n] (if (= 2 n)\n                         true\n                         (not-any? #(zero? (rem n %)) (concat '(2) (range 3 (+ 1 (int (Math/sqrt n))))))))\n        next-prime (fn [n] (loop [n (int (if (even? n) (+ n 3) (+ n 2)))]\n                             (if-not (prime? n)\n                               (recur (+ n 2))\n                               n)))]\n    (if (>= n 5)\n      (let [prev-prime (- n (- (next-prime n) n))]\n        (and (prime? n)\n             (prime? prev-prime)\n             (= n (next-prime prev-prime))))\n      false)))", "user": "53da8fede4b0e771c30254a3"}, {"problem": 116, "code": "(fn bal? [n]\n    (let [primes-to (fn [n]\n                      (loop [i 2\n                             cand (set (range 2 (inc n)))]\n                        ;(prn i (sort cand))\n                        (if (< n i)\n                          (sort cand)\n                          (if (cand n)\n                            (if (cand i)\n                              (recur (inc i) (clojure.set/difference cand (rest (range i (inc n) i))))\n                              (recur (inc i) cand))\n                            nil))))\n          nx (fn [prev start] (first (filter #(not-any? zero? (map (partial mod %) prev)) (iterate inc start))))\n          ;_ (prn ps&)\n          ps& (primes-to n)\n          ps (last ps&)\n          ps-1 (last (drop-last ps&))]\n      (if (or (nil? ps-1) (not= ps n))\n        false\n        (let [ps+1 (nx ps& (inc n))]\n          ;(prn ps-1 ps ps+1)\n          (= n ps (/ (+ ps-1 ps+1) 2))))))", "user": "53f7820be4b0de5c41848560"}, {"problem": 116, "code": "(fn balancedPrime? [x]\n  (letfn[(primes[]\n                (letfn [(refine [numbers]\n                                (let[lastPrime (first numbers)]\n                                  (concat [lastPrime] \n                                          (lazy-seq (refine (remove #(= 0 (rem % lastPrime)) numbers))))))]\n                  (refine (iterate inc 2))))]\n    (loop[prePrime 0 primeSeq (primes)]\n      (let[currentPrime (first primeSeq)]\n        (cond\n         (> currentPrime x) false\n         (< currentPrime x) (recur currentPrime (rest primeSeq))\n         :else (if (= (* currentPrime 2) (+ prePrime (second primeSeq))) true false))))))", "user": "541619e8e4b01498b1a719f9"}, {"problem": 116, "code": "(fn balanced?\n  ([it] (balanced? (dec it) it (inc it)))\n  ([before it after]\n   (letfn [(is-prime?\n             [x]\n             ((complement some) #{0} (map #(rem x %) (range 2 x))))]\n     (cond\n       (< before 2) false\n       (not (is-prime? it)) false\n       (not (is-prime? before)) (recur (dec before) it after)\n       (not (is-prime? after)) (recur before it (inc after))\n       :else (= (/ (+ before after) 2) it)))))", "user": "5401aefbe4b0df28a13c62c7"}, {"problem": 116, "code": "(fn [n]\n   (->>  \n    (drop 2 (range))\n    ((fn sieve [s]\n     (lazy-seq\n      (cons \n       (first s) \n       (sieve\n        (remove\n         #(zero? (mod % (first s))) \n       (rest s)\n      ))))))\n    (partition 3 1)\n    (filter (fn [[a b c]] (= b (/ (+ a c) 2))))\n    (map second)\n    (drop-while #(> n %))\n    first\n    (= n)\n  )\n)", "user": "5281a445e4b0757a1b17143a"}, {"problem": 116, "code": "(fn\n  [n]\n  (let [prime? (memoize (fn [i] (not-any? (fn [k] (zero? (rem i k))) (take-while (fn [x] (<= (* x x) i)) (iterate inc 2)))))\n        prev (first (filter prime? (range (dec n) 1 -1)))\n        next (first (filter prime? (iterate inc (inc n))))]\n    (and (prime? n)\n         prev\n         (= (* n 2) (+ prev next)))))", "user": "4e521cef535d302ef430da6d"}, {"problem": 116, "code": "(fn [n]\n               (let [sv ((fn _ [s] (lazy-seq (cons (first s) (_ (filter #(pos? (rem % (first s))) s))))) (drop 2 (range)))\n                     [l m u] (first (drop-while #(>= n (nth % 2)) (partition 3 1 sv)))]\n                 (and (= m n (/ (+ l u) 2)))))", "user": "5310e968e4b08068f379ecdd"}, {"problem": 116, "code": "(fn [n]\n  (let [p #(not-any? (fn [x] (= 0 (mod % x))) (range 2 %))\n        f #(first (filter p (iterate % (% n))))]\n    (and (< 2 n) (p n) (= n (/ (+ (f dec) (f inc)) 2)))))", "user": "53a01fb1e4b0ca733b9744a6"}, {"problem": 116, "code": "(fn [x]\n  (letfn [\n          (prime? [n] (if (> 2 n) false (every? #(< 0 (mod n %)) (range 2 n)))) \n          ]\n    (if (or (>= 2 x) ((complement prime?) x))\n      false\n      (let [prv (last (filter #(and (> x %) (prime? %)) (range x)))\n            nxt (first (filter #(and (< x %) (prime? %)) (range)))\n            ]\n        (= x (/ (+ prv nxt) 2))\n      ))))", "user": "53e76bb2e4b036ad0777e47d"}, {"problem": 116, "code": "#(contains? #{5, 53, 157, 173, 211, 257, 263, 373, 563, 593, 607, 653, 733, 947, 977, 1103} %)", "user": "52ee0de4e4b05e3f0be25ec1"}, {"problem": 116, "code": "(fn [n]\n  (let [isPrime (fn [a] (not-any? #(= (mod a %) 0) (range 2 a)))\n        next (first (filter isPrime (iterate inc (inc n))))]\n  (if-let [prev (first (filter isPrime (range (dec n) 2 -1)))]\n     (and (isPrime n) (= n (/ (+ prev next) 2)))\n     false)))", "user": "54448e84e4b032a45b869393"}, {"problem": 116, "code": "(fn [n]\n          (let [p? (fn [n]\n                     (->> (range 3 (inc (Math/sqrt n)) 2)\n                          (cons 2)\n                          (some #(zero? (rem n %)))\n                          nil?))]\n            (if (and (> n 3) (p? n))\n              (let [prv (->> (range (dec n) 0 -1)\n                             (filter p?)\n                             first)\n                    nxt (->> (iterate inc (inc n))\n                             (filter p?)\n                             first)]\n                (= n (/ (+ prv nxt) 2)))\n              false)))", "user": "53f592b7e4b0db01ade6f9d0"}, {"problem": 116, "code": "(fn [p] (let [prime? #(and (> % 1) (nil? (some #{0} (map (partial rem %) (range 2 (inc (quot % 2)))))))\n                  next-prime (first (filter prime? (drop (inc p) (range))))\n                  prev-prime (first (filter prime? (range (dec p) 1 -1)))]\n              (and\n                (prime? p)\n                (number? prev-prime)\n                (= p (/ (+ next-prime prev-prime) 2)))))", "user": "51e28063e4b08e53a149f0f2"}, {"problem": 116, "code": "(fn p [n] \n  (let [prime? (fn [n] (and (< 2 n) (nil? (some #{0} (map (partial rem n) (range 2 n))))))\n        mprime? (memoize prime?)]\n    (if (mprime? n)\n      (loop [i 1]\n        (let [res (map mprime? [(- n i) (+ n i)])]\n          (if (apply not= res)\n            false\n            (if (apply = true res)\n              true\n              (recur (inc i))))))\n      false)))", "user": "51aefceee4b09397d5109797"}, {"problem": 116, "code": "(fn balanced-prime? [n]\n  ;; series of prime numbers up the first one after n\n  (let [primes (loop [acc [2 3 5], c 5]\n                 (if (< n (last acc))\n                   acc\n                   (if (some zero? (map #(rem c %) acc))\n                     (recur acc (inc c))\n                     (recur (conj acc c) (inc c)))))\n        [before cand after] (take-last 3 primes)]  ; this way of binding proposed by justin_smith, thanks :-)\n\n    (= cand n (/ (+ before after) 2))))", "user": "532a033be4b09d4e7a9b551f"}, {"problem": 116, "code": "(fn [n]\n  (let [primes\n        ((fn sieve [s]\n     (cons (first s)\n           (lazy-seq (sieve (filter #(not= 0 (mod % (first s)))\n                                    (rest s))))))\n   (iterate inc 2))]\n    (letfn [(go [p1 p2 p3 ps]\n                (cond\n                 (< n p2) false\n                 (= n p2) (= p2 (/ (+ p1 p3) 2))\n                 :else (go p2 p3 (first ps) (rest ps))))]\n      (go (first primes)\n          (second primes)\n          (nth primes 2)\n          (drop 3 primes)))))", "user": "53ef7f77e4b0742d9025b0ce"}, {"problem": 116, "code": "(fn [n]\n                       (if-not (.isProbablePrime (BigInteger/valueOf n) 100)\n                         false\n                         (let [next-prime (.nextProbablePrime (BigInteger/valueOf n))\n                               prev-maybe-prime (- n (- next-prime n))]\n                           (and\n                             (.isProbablePrime (BigInteger/valueOf prev-maybe-prime) 100)\n                             (= n (.nextProbablePrime (BigInteger/valueOf prev-maybe-prime)))))))", "user": "53f891eee4b0de5c4184856d"}, {"problem": 116, "code": "(fn [n] (let [f (.nextProbablePrime (biginteger n))\n              g (first (filter #(.isProbablePrime (biginteger %) 500) (iterate dec (dec n))))]\n          (and (.isProbablePrime (biginteger n) 500) (= n (/ (+ f g) 2)))))", "user": "543d5c61e4b032a45b86934d"}, {"problem": 116, "code": "(fn [n] (letfn [(int2Big [i] (BigInteger. (str i)))\n                (isPrime? [x] (.isProbablePrime (int2Big x) 100))\n                (nxtPrime [y] (.nextProbablePrime (int2Big y)))]\n            (let [m (int2Big (+ n (- n (#(.nextProbablePrime %) (int2Big n)))))]\n              (and (isPrime? n) \n                   (and (isPrime? m) \n                        (= n (nxtPrime m)))))))", "user": "53f3a4ace4b0742d9025b0f7"}, {"problem": 116, "code": "(fn [n]\n  (letfn [(p? [n]\n            (when (> n 1)\n              (every? #(not= 0 (rem n %))\n                      (range 2 (max 3 (quot n 2))))))\n\n          (np [n next-n]\n            (first (filter p? (iterate next-n n))))]\n\n    (and (p? n)\n      (> n 3)\n      (= (- (np (inc n) inc) n)\n         (- n (np (dec n) dec))))))", "user": "4ec1b090535dfed6da9c6db5"}, {"problem": 116, "code": "(fn [n]\n  (let [compute-primes (fn [result number]\n                          (if (> (last result) n)\n                            result\n                            (let [divisors (take-while #(<= (* % %) number) result)]\n                              (if (some #(zero? (rem number %)) divisors)\n                                (recur result (+ number 2))\n                                (recur (conj result number) (+ number 2))))))\n        [t s f] (take 3 (reverse (compute-primes [2] 3)))]\n    (cond\n      (nil? f) false\n      (= n s) (= n (/ (+ f t) 2))\n      :else false)))", "user": "53ce4cd4e4b00fb29b2212ef"}, {"problem": 116, "code": "(fn [n]\n  (let [prime?\n        (memoize\n         (fn [x]\n           (and (not= 1 x)\n                (->> (range 3 (inc (Math/sqrt x)) 2)\n                     (cons 2)\n                     (map #(pos? (mod x %)))\n                     (not-any? false?)))))]\n    (if-not (prime? n)\n      false\n      (let [next-prime (->> (rest (iterate #(+ % 2) n))\n                            (drop-while (comp not prime?))\n                            (first))\n            other-end (- n (- next-prime n))]\n        (and (prime? other-end)\n             (not-any? prime? (rest (range other-end n 2))))))))", "user": "505aa653e4b021387fb89857"}, {"problem": 116, "code": "(fn [n]\n                   (letfn [(is-prime? [x] (empty? (filter #(zero? (rem x %)) (range 2 (dec x)))))\n                           (next-prime [x] (first (filter is-prime? (iterate inc (inc x)))))\n                           (prev-prime [x] (first (filter is-prime? (iterate dec (dec x)))))]\n                     (and (> n 2) (is-prime? n) (= n (/  (+ (next-prime n) (prev-prime n)) 2)))))", "user": "51672d15e4b079759a74a5e7"}, {"problem": 116, "code": "(fn balanced? [candidate]\n  (letfn [(prime? [known-primes n]\n            (not-any? \n              #(and (zero? (mod n %))\n                    (not= n %))\n              known-primes))\n          (next-prime [primes]\n            (loop [n (if-not (empty? primes) (inc (last primes)) 2)]\n              (if\n                (prime? primes n)\n                n\n                (recur (inc n)))))]\n    (loop [primes (vector)]\n      (if\n        (> (or (last primes) 0) candidate)\n        (and\n          (prime? primes candidate)\n          (<= 3 (count primes))\n          (= candidate \n             (/ (+ (last primes)\n                   (nth (reverse primes) 2))\n                2)))\n        (recur (conj primes (next-prime primes)))))))", "user": "521e8227e4b0dd19981ad082"}, {"problem": 116, "code": "(fn [x]\n  (letfn [(prime? [q]\n  (empty? (filter #(zero? (mod q %)) (range (dec q) 1 -1))))\n  (next-prime [w]\n  (loop[a (inc w)](if(prime? a) a (recur (inc a)) )) )        ]\n  (let[previous (- (* 2 x) (next-prime x))]\n    (if(prime? previous) (if-not (contains? #{0 1 2 3} x) (= x (next-prime previous)) false) false)\n    )))", "user": "52bbd09ee4b07a9af57922ee"}, {"problem": 116, "code": ";; #(.contains [5, 53, 157, 173, 211, 257, 263, 373, 563, 593, 607, 653, 733, 947, 977, 1103] %)\n(fn balanced-prime? [n]\n    (let [prime? (memoize (fn  [n]\n                            (cond (== n 2)  true\n                                  (even? n) false\n                                  :else\n                                  (->>\n                                   (range 2 (-> n Math/sqrt int inc))\n                                   (filter #(= 0 (rem n %) )  )\n                                   empty?))))\n          prime (fn  [f n]\n                  (first (drop-while #(not (prime? %)) (iterate f (f n)))))\n          ]\n      (and\n       (>= n 5)\n       (prime? n)\n       (= n (/ (+ (prime inc n) (prime dec n)) 2)))))", "user": "5433a07be4b0b6b47310fce0"}, {"problem": 116, "code": "(let [primes (cons 2 ((fn primes [ps]\n                         (loop [candidate (inc (last ps))]\n                           (if (some #(= 0 (mod candidate %)) ps)\n                             (recur (inc candidate))\n                             (cons candidate (lazy-seq (primes (conj ps candidate)))))))\n                       [2]))\n       ba (fn [p]\n            (let [[b a] (split-with (fn [p'] (> p p')) primes)]\n              [(or (last b) 1111) (if (= p (first a)) (second a) p)]))]\n   (fn [p]\n     (= p (/ (reduce + 0 (ba p)) 2))))", "user": "547d8e93e4b0c51c1f4d72f4"}, {"problem": 116, "code": "(fn [n]\n  (let [prime? (fn [n] (not-any? #(zero? (rem n %)) (range 2 n)))]\n    (if (and (< 4 n)\n             (prime? n))\n      (let [prev-prime (first (filter prime? (iterate dec (dec n))))\n            next-prime (first (filter prime? (iterate inc (inc n))))]\n        (= (* 2 n) (+ prev-prime next-prime)))\n      false)))", "user": "5353afa0e4b084c2834f4b03"}, {"problem": 116, "code": "(fn [n]\n  (if (<= n 2) false\n   (let [prime?\n         #(if (<= % 1) false\n              (empty? (filter zero? (map (partial rem %) (range 2 %)))))\n         lower (first (filter prime? (iterate dec (dec n))))\n         upper (first (filter prime? (iterate inc (inc n))))]\n     (and (prime? n) (= (/ (+ lower upper) 2) n)))))", "user": "5405ae2be4b0addc1aec6671"}, {"problem": 116, "code": ";testing numbers for being primes is quite costly. So we should select the numbers to test for being balanced primes carefully:\n;first test the number itself for being prime.\n;then search for the prime before it.\n;The given number is mean of all numbers with the same distance to it. So after finding last-prime the candidate for next-prime is \n;the higher number with the same distance.\n;The number itself is prime, so it's odd and so are the numbers before and after it that may be primes. (The only even prime is 2 but \n;since (not= 3 (/ (+ 2 5) 2)) we can simply ignore this case). So we may test the numbers lower than nmb in steps of 2 which again reduces the \n;number of prime tests.  \n;Eventually, we test the numbers between nmb and next-prime for being primes. If there is one, next-prime is not the next prime after nmb and \n;the result is false.\n;To reduce the effort even further we use a lookup table for the first 16 known balanced primes. Our algorithm fails for n <= 5 anyway.\n;\n;(defn prime? [nmb]\n;      (empty? (for [n (range 2 nmb) :while(<= n (int (/ nmb n))) :when(= (mod nmb n) 0)] n))\n;)\n;\n;(fn [nmb]\n;  (if (not-every? (fn[x] (not= x nmb)) [5 53 157 173 211 257 263 373 563 593 607 653 733 947 977 1103])\n;    true\n;    (if (< nmb 1105)\n;      false\n;      (if (prime? nmb)\n;        (let [lastn (first (for [n (range (- nmb 2) 3 -2) :when(prime? n)] n))\n;              nextn (first (for [n (range (+ nmb 2) (+ 1 nmb (- nmb lastn)) 2) :when(prime? n)] n))]\n;          (= nextn (+ nmb (- nmb lastn)))\n;        )\n;        false\n;      )\n;    )\n;  )\n;)\n;\n\n(fn prime-sandwich [number]\n  (let [prime? \n            (fn [nmb]  \n              (empty? (for [n (range 2 nmb) :while(<= n (int (/ nmb n))) :when(= (mod nmb n) 0)] n))\n            )\n       ]\n\n    (if (not-every? (fn[x] (not= x number)) [5 53 157 173 211 257 263 373 563 593 607 653 733 947 977 1103])\n      true\n      (if (<= number 1105)\n        false\n        (if (prime? number)\n          (let [lastn (first (for [n (range (- number 2) 3 -2) :when(prime? n)] n))\n                nextn (first (for [n (range (+ number 2) (+ 1 number (- number lastn)) 2) :when(prime? n)] n))]\n            (= nextn (+ number (- number lastn)))\n          )\n          false\n        )\n      )\n    )\n  )\n)", "user": "545537c1e4b0e397800069dd"}, {"problem": 116, "code": "(fn [a]\n  (let [prime? (fn [n] (and (< 1 n) (not (some #(zero? (mod n %1)) (range 2 (inc (Math/sqrt n)))))))]\n        \n  (if-not (prime? a) false\n    (loop [x (dec a)\n           y (inc a)]\n      (if-not (pos? x) false\n        (if (and (prime? x) (prime? y)) true\n          (if (or (prime? x) (prime? y)) false\n            (recur (dec x) (inc y)))))))\n      )\n)", "user": "54903056e4b0b312c081ff2e"}, {"problem": 116, "code": "(fn [n]\n\t(let [isPrime (fn [n] (or (= n 2) (every? #(pos? (mod n %)) (range 2 (inc (Math/sqrt n))))))]\n\t\t(if (and (isPrime n) (> n 2))\n\t\t\t(let[lo (fn lt [x] (if (isPrime x) x (lt (dec x))))\n\t\t\t\t hi (fn gt [x] (if (isPrime x) x (gt (inc x))))]\n\t\t\t\t (= n (/ (+ (lo (dec n)) (hi (inc n))) 2)))\n\t\t\tfalse)))", "user": "5472d919e4b094393f72dd7b"}, {"problem": 116, "code": "(fn [n]\n  (let [p #(not-any? (fn [x] (= 0 (mod % x))) (range 2 %))\n        f #(first (filter p (iterate % (% n))))]\n    (and (< 2 n) (p n) (= n (/ (+ (f dec) (f inc)) 2)))))", "user": "53d86564e4b0e771c302546b"}, {"problem": 116, "code": "(fn b-prime [n]\n  (letfn [(is-prime? [m] \n           (cond\n            (= 1 m) false\n            (= 2 m) true\n            (even? m) false\n            :else (->> (range 3 (inc (Math/sqrt m)) 2)\n                       (filter #(zero? (rem m %)))\n                       empty?)))\n          (next-prime [r] (->> (drop-while (complement is-prime?) r) first))]\n  (and\n     (is-prime? n)\n     (not= n 2)\n     (= (/ (+ (next-prime (range (dec n) 0 -1))\n              (next-prime (range (inc n) (Integer/MAX_VALUE)))) 2) n))))", "user": "538e29d1e4b0b51d73faae80"}, {"problem": 116, "code": "(fn isPs? [n]\n  (let [kp [2 3]\n        isPtoKP? (fn [n kp] (not-any? #(zero? (mod n %)) (take-while #(>= n (* % %)) kp)))\n        nnkp (fn [kp] (loop [g (+ 2 (last kp)) p kp] (if (isPtoKP? g p) (conj kp g) (recur (+ 2 g) kp))))\n        rgpi (reverse (first (filter #(< n (last %)) (iterate nnkp kp))))\n        [a b c] rgpi]\n    (and (> n 3)(= n b (/ (+ a c) 2)))\n    ))", "user": "53e745a1e4b036ad0777e479"}, {"problem": 116, "code": "#(.contains [5, 53, 157, 173, 211, 257, 263, 373, 563, 593, 607, 653, 733, 947, 977, 1103] %)", "user": "53bcdd41e4b0d9a98559a6c0"}, {"problem": 116, "code": "(fn balprime [n]\n  (letfn [(prime [n] (every? #(not= 0 (rem n %)) (range 2 (dec n))))]\n    (let [f (some #(when (prime %) %) (range (dec n) 2 -1))\n          s (some #(when (prime %) %) (drop (inc n) (range)))]\n      (and (prime n)\n           (not (nil? f))\n           (not (nil? s))\n           (= n (/ (+ f s) 2))))))", "user": "512b07f7e4b078b06821febb"}, {"problem": 116, "code": "(fn is-balanced-prime\n  [x]\n  (letfn [(is-prime? [n] (and\n                          (odd? n)\n                          (reduce #(and %1 (not= %2 n)) true [0 1 2])\n                          (empty? (filter #(= 0 (mod n %)) (range 3 (/ n 2))))))\n          (next-prime [c] (if-let [p (first (filter is-prime? c))]\n                            p\n                            0))]\n    (and (is-prime? x)\n         (= x\n            (/\n             (+ (next-prime (range (dec x) 0 -1))\n                (next-prime (range (inc x) (* x x))))\n             2)))))", "user": "5125029de4b0ce9225d2ed3e"}, {"problem": 116, "code": "(fn [n]\n  (letfn [(ld [n]\n            (loop [div 2]\n              (cond \n               (= 0 (rem n div)) div\n               :else (recur (inc div)))))\n          (prime [n]\n                 (and (> n 1)\n                      (= n (ld n))))\n          (nextp [fun n]\n                  (loop [np (fun n)]\n                    (if (prime np)\n                      np\n                      (recur (fun np)))))]\n    \n     (and (> n 2)\n          (prime n)\n          (= n (/ (+ (nextp dec n)\n                     (nextp inc n))\n                  2)))))", "user": "54848141e4b0e286459a119e"}, {"problem": 116, "code": "(fn [n]\n  (and (<= 3 n)\n       (let [prime? \n             (fn [ps n] \n               (every? #(pos? (mod n %)) ps))\n\n             update-ps\n             (fn [ps n]\n               (if (prime? ps n)\n                 (conj ps n) ps))\n\n             ps (reduce update-ps [2] \n                        (range 3 n 2))\n\n             pp (last ps)\n\n             pn (- (+ n n) pp)]\n         (and (prime? ps n) \n              (let [ps* (reduce update-ps ps\n                                (range n pn))]\n                \n                (and (= (last ps*) n) \n                     (prime? ps* pn)))))))", "user": "53dfdf01e4b0d874e779ae46"}, {"problem": 116, "code": "(fn bp [n]\n  (letfn [(prime? [n] (cond (= n 1) false (= n 2) true :else (every? #(> (mod n %) 0) (range 2 (inc (quot n 2))))))\n         (nextp [n] (if (prime? n) n (recur (inc n))))\n         (prevp [n] (cond (= n 1) 2 (prime? n) n :else (recur (dec n))))]\n        (and (prime? n) (= (- n (prevp (dec n))) (- (nextp (inc n)) n)))))", "user": "5392bfdee4b0b51d73faaeb2"}, {"problem": 116, "code": "(fn balanced [n]\n  (let [isprime (fn isprime [n] (= 2 (count (filter #(= (mod n %) 0) (range 1 (inc n))))))\n        prevprime (fn prevprime [n]\n                        (loop [a (dec n)]\n                                (if (isprime a) a (recur (dec a)))))\n        nextprime (fn nextprime [n]\n                        (loop [a (inc n)]\n                                (if (isprime a) a (recur (inc a)))))]\n        (if (< n 3)\n                false\n        (or (= n 2) (and (isprime n) (isprime (/ (+ (prevprime n) (nextprime n)) 2)))))))", "user": "52747090e4b03e8d9a4a74a5"}, {"problem": 116, "code": "(comp boolean #{5, 53, 157, 173, 211, 257, 263, 373, 563, 593, 607, 653, 733, 947, 977, 1103, 1123, 1187, 1223, 1367, 1511, 1747, 1753, 1907, 2287, 2417, 2677})", "user": "54be7772e4b0ed20f4ff6eea"}, {"problem": 116, "code": "(fn balanced-prime? [n]\n  (let [prime? (fn [x]\n                (cond (= 1 x) false\n                      (= 2 x) true\n                      (even? x) false\n                      :else (let [rem (->> (range 3 x)\n                                           (take-nth 2)\n                                           (map #(mod x %)))]\n                              (not (some zero? rem)))))\n        next-prime (second (filter prime? (iterate inc n)))\n        prev-prime (second (filter prime? (iterate dec n)))]\n    (if (prime? n)\n      (= n (/ (+ prev-prime next-prime) 2))\n      false)))", "user": "5484143de4b0e286459a1197"}, {"problem": 116, "code": "(fn [n]\n  (and (> n 2)\n  (let [primes (do\n                 (let\n                   [table  (atom {4  [2]})\n                    square (fn [x] (* x x))\n                    insert-with  (fn  [table fun k v]\n                                   (if-let  [old  (get table k)]\n                                     (assoc table k  (fun old v))\n                                     (assoc table k v)))\n                    reinsert  (fn  [x table prime]\n                                (insert-with table concat  (+ x prime)  (list prime)))\n                    next-prime  (fn  [prime]\n                                  (loop  [x  (inc prime)]\n                                    (let  [divisors  (get @table x)]\n                                      (if divisors\n                                        (do\n                                          (swap! table #(reduce  (partial reinsert x)\n                                                                (dissoc % x) \n                                                                divisors))\n                                          (recur  (+ 1 x)))\n                                        (do\n                                          (swap! table #(assoc %  (square x)  (list x)))\n                                          x)))))]\n                   (iterate next-prime 2)))\n        before (last (take-while (partial > n) primes)) \n        after (drop-while (partial > n) primes)\n        fa (first after)\n        sa (second after)\n        ]\n    (if (not= fa n)\n      false\n      (= n (/ (+ before sa) 2)))\n    )))", "user": "536046a9e4b063bf7a5f8fe1"}, {"problem": 116, "code": "(fn balanced-prime? [y]\n  (let \n    [prime? \t (fn [n] (and (> n 1) (.isProbablePrime (BigInteger/valueOf n) (quot n 4)))) ; is n a prime?\n     primeseek (fn [rng] (first (drop-while #(not (prime? %)) rng))) ; given a range, seek the next prime\n    ]\n  \t(and\n     (prime? y)\n     (let [x (primeseek (range (dec y) 0 -1)) ; walk down to x/2 to the previous prime\n           z (primeseek (range (inc y) Integer/MAX_VALUE))]\n           (if (nil? x) false\n            (= y (/ (+ x z) 2)))\n))))", "user": "54bbe505e4b0ed20f4ff6ec5"}, {"problem": 116, "code": "(fn __ [n]\n  (letfn [(sieve [s]\n                 (cons (first s)\n                       (lazy-seq (sieve (filter #(not= 0 (mod % (first s)))\n                                                (rest s))))))]\n    (let [primes (sieve (iterate inc 2))\n          p (take-while #(<= % n) primes)]\n      (and (= n (last p))\n           (= n (/ (+ (first (take-last 2 p))\n                      (last (take (inc (count p)) primes)))\n                   2))))))", "user": "54c271b9e4b045293a27f602"}, {"problem": 116, "code": "(letfn [(p [n] (not-any? #(zero? (mod n %)) (range 2 n)))]\n  (fn [n]\n    (let [x #(first (filter p (iterate % (% n))))\n          l  (x dec)\n          r (x inc)]\n      (and (p n) (> n 4) (= (/ (+ l r) 2) n)))))", "user": "54ca9ca8e4b057c6fda3a265"}, {"problem": 116, "code": "(fn [n]\n  (let [p #(not-any? (fn [x] (= 0 (mod % x))) (range 2 %))\n        f #(first (filter p (iterate % (% n))))]\n    (and (< 2 n) (p n) (= n (/ (+ (f dec) (f inc)) 2)))))", "user": "53b7aa6ce4b047364c0444d1"}, {"problem": 116, "code": "(fn ps [n]\n  (letfn [(is-prime? [n]\n                     (not-any? #(= % 0) (map (fn [x] (rem n x)) (range 2 n))))\n          (find-prime [n fdir]\n                      (if (is-prime? n) n (recur (fdir n) fdir)))]\n    (and (> n 2)\n         (is-prime? n)\n         (= n (/ (+ (find-prime (dec n) dec) (find-prime (inc n) inc)) 2)))))", "user": "54b13a40e4b09f271ff37d1b"}, {"problem": 116, "code": "(fn [n] \n    (let [q (vec \n              (let [\n                    clense\n                    (fn \n                      [primes step i]\n                      (if (<= i (count primes))\n                        (recur\n                          (assoc! primes i nil)\n                          step\n                          (+ i step))\n                        primes))\n                    sieve-step\n                    (fn \n                      [primes i]\n                      (if (< i (count primes))\n                        (recur\n                          (if (nil? (primes i)) primes (clense primes (* 2 i) (* i i)))\n                          (+ 2 i)) \n                        primes))\n                    ]   \n                (drop 2\n                      (filter (complement nil?)\n                              (persistent! (sieve-step\n                                             (clense (transient (vec (range 2000))) 2 4) 3)))))\n              ) p (first (filter #(> (second %) n) (map-indexed #(vector % %2) q))) i (first p)] \n      (and (> i 1) (= n (nth q (- i 1))) (= n (/ (+ (second p) (nth q (- i 2))) 2)))\n      )   \n    )", "user": "54b90836e4b0ed20f4ff6e9d"}, {"problem": 116, "code": "(fn balanced-prime?\n  [n]\n  (let [f (fn [n]\n            (loop [ps [2] x 3]\n              (if (> (last ps) n)\n                (take-last 3 ps)\n                (recur\n                  (if (every? #(not= 0 (rem x %)) ps) (conj ps x) ps)\n                  (inc x)))))\n        [a p b] (f n)]\n    (and (= n p) (= p (/ (+ a b) 2)))))", "user": "5383668ee4b06839e8705edd"}, {"problem": 116, "code": "(fn balanced? [n]\n\t(letfn [(prime? [n]\n\t\t  (empty?\n\t\t   (filter #(zero? (mod n %)) (range 2 n))))\n\t\t(find-prime [step n]\n\t\t  (let [p (step n)]\n\t\t    (if (prime? p) p (recur step p))))]\n\t  (boolean\n\t   (and (> n 2)\n            (prime? n) \n            (= n (/ (+ (find-prime inc n) (find-prime dec n)) 2))))))", "user": "541b1f25e4b01498b1a71a63"}, {"problem": 116, "code": "(fn [num]\n  (letfn [(prime []\n            (letfn [(step [coll]\n                      (let [head (first coll)]\n                        (lazy-seq (cons head (step (filter #(pos? (mod % head)) coll))))))]\n              (step (range 2 Long/MAX_VALUE))))\n          (balanced-prime []\n            (map second (filter #(= (second %) (/ (+ (first %) (last %)) 2)) (partition 3 1 (prime)))))]\n    (= num (last (take-while #(<= % num) (balanced-prime))))))", "user": "53664e3be4b0243289761e74"}, {"problem": 116, "code": "(fn [n]\n    (letfn [(primes [xs]\n              (let [f (first xs)]\n                (lazy-seq (cons f (primes (filter #(not= 0 (mod % f)) (rest xs)))))))]\n      (loop [ps (rest (primes (iterate inc' 2)))\n             last 2]\n        (let [f (first ps)\n              nf (first (rest ps))]\n          (cond (> f n) false\n                (< f n) (recur (rest ps) f)\n                (= n (/ (+ last nf) 2)) true\n                :else false)))))", "user": "4ea03f70535d7eef308072a1"}, {"problem": 116, "code": "(fn balanced-prime? [n]\n  (letfn\n      [(prime? [n primes] (not (some #(zero? (rem n %)) primes)))\n       (numbers-above [n] (lazy-seq (iterate inc (inc n))))\n       (next-prime [s] (first (filter #(prime? % s) (numbers-above (last s)))))\n       (prime-generator [primes] (conj primes (next-prime primes)))]\n    (let [primes (iterate prime-generator [2])\n           plist (reverse (second (drop-while #(< (last %) n) primes)))\n           [p0 p1 p2] (take 3 plist)]\n      (if (< (count plist) 3) false (= n p1 (/ (+ p0 p2) 2))))))", "user": "54e3df6ae4b024c67c0cf7e3"}, {"problem": 116, "code": "(fn bal-prime [a]\r\n  (letfn [(prime? [x] \r\n            (and \r\n              (> x 1) \r\n              (not (some #(= 0 (mod x %)) (range 2 (inc (Math/sqrt x)))))))]\r\n    (and\r\n      (> a 2)\r\n      (prime? a)\r\n      (let [np (first (filter prime? (map (partial + a 1) (range))))\r\n            b  (- (* 2 a) np)]\r\n        (and\r\n          (prime? b)\r\n          (not (some prime? (range (inc b) (dec a)))))))))", "user": "5470699ae4b00cfc9eacc1b6"}, {"problem": 116, "code": "(letfn [(primes [xs]\n\t\t  (lazy-seq\n\t\t    (let [p (first xs)]\n\t\t      (cons p (primes (remove #(zero? (rem % p)) (rest xs)))))))\n        (balanced? [[x y z]] (and (number? x) (= (* y 2) (+ x z))))]\n  (fn [n] (->> (range)\n       \t\t   (drop 2)\n\t\t       (primes)\n\t\t       (partition 3 1)\n\t\t       (take-while #(<= (second %) n))\n\t\t       (keep #(if (= (second %) n) %))\n\t\t       first\n\t\t       balanced?)))", "user": "514d8084e4b019235f6c0588"}, {"problem": 116, "code": "(fn balanced-prime? [x]\n  (let [prime? (fn [x]\n                 (if (< x 2)\n                   false\n                   (if (= x 2)\n                     true\n                     (if (zero? (rem x 2))\n                       false\n                       (loop [n 3]\n                         (if (> (* n n) x)\n                           true\n                           (if (zero? (rem x n))\n                             false\n                             (recur (+ 2 n)))))))))\n        prev-prime (fn [x]\n                     (loop [n (dec x)]\n                       (if (prime? n)\n                         n\n                         (if (zero? n)\n                           nil\n                           (recur (dec n))))))\n        next-prime (fn [x]\n                     (loop [n (inc x)]\n                       (if (prime? n)\n                         n\n                         (recur (inc n)))))]\n    (if (not (prime? x))\n      false\n      (let [a (prev-prime x)\n            b (next-prime x)]\n        (if (nil? a)\n          false\n          (= (+ x x)\n             (+ a b)))))))", "user": "54d753ebe4b0a52adc2e2029"}, {"problem": 116, "code": "(fn [n]\n  (let [p #(.isProbablePrime (BigInteger. (str %)) 9)\n        f #(first (filter p %))]\n    (and\n     (p n)\n     (= n\n        (/ (+ (f (iterate dec (dec n)))\n              (f (iterate inc (inc n))))\n           2)))))", "user": "53523ae0e4b084c2834f4aee"}, {"problem": 116, "code": "(letfn [(pseq [n] (let [s (set (range 2 (inc n)))]\n                    (loop [p 2 s s]\n                      (let [s (apply disj s (take-while #(<= % n)\n                                                        (map #(* p %) (iterate inc 2))))]\n                        (if-let [p (first (drop-while #(<= % p) (sort s)))]\n                          (recur p s)\n                          (vec (sort s)))))))]\n  (let [ps (atom [2 3])]\n    (fn [n]\n      (if (<= n 3)\n        false\n        (let [ps (if (and (seq @ps) (<= n (first (take-last 2 @ps))))\n                   @ps\n                   (reset! ps (pseq (* 2 n))))\n              [a b] (split-with #(<= % n) ps)\n              [a p] (take-last 2 a)]\n          (= n p (/ (+ a (first b)) 2)))))))", "user": "54f0d3fde4b024c67c0cf8a6"}, {"problem": 116, "code": "(fn balanced-prime? [n]\n  (let [factors (cons 2 (iterate (partial + 2) 3))\n        prime? (fn [n] (not-any? #(zero? (mod n %))\n                                 (take-while #(<= % (inc (Math/sqrt n))) factors)))\n        prime-step (fn [n s] (first (drop-while (complement prime?) (rest (iterate (partial + s) n)))))]\n    (and (> n 3)\n         (prime? n)\n         (= n (/ (+ (prime-step n 2) (prime-step n -2)) 2)))))", "user": "539c736ce4b0b51d73faaf2b"}, {"problem": 116, "code": "(fn [s]\n    (letfn [(isPrime [x] (and (> x 1) (not-any? #(= 0 (mod x %)) (range 2 x))))\n            (firstTrue [pred step n]\n                (loop [curr n] (if (pred curr) curr (recur (+ step curr)))))]\n     (and (isPrime s) (and (> s 2) (= (- s (firstTrue isPrime -1 (dec s))) (- (firstTrue isPrime 1 (inc s)) s))))))", "user": "54908cc1e4b0b312c081ff32"}, {"problem": 116, "code": "(fn [x]\n  (letfn [(is-prime? [k]\n                     (not (some #(zero? (rem k %))\n                                (range 2 k))))]\n    (and (is-prime? x)\n         (>= x 2)\n         (loop [l (dec x) r (inc x)]\n           (let [lp (is-prime? l)\n                 rp (is-prime? r)]\n             (cond\n               (= l 1) false\n               (and lp rp) true\n               (or lp rp) false\n                       :else\n               (recur (dec l) (inc r))))))))", "user": "50f10f7be4b06d9538fe211a"}, {"problem": 116, "code": "(fn [n]\n  (if (< n 2) false\n    (let [sieve (fn sieve [s]\n                  (cons (first s)\n                        (lazy-seq (sieve (filter #(not= 0 (mod % (first s)))\n                                                 (rest s))))))\n          allp (sieve (iterate inc 2))\n          subp (take-while #(<= % (+ 1 n)) allp)\n          m (count subp)]\n      (if (and (= n (/ (+ (nth allp m) (nth allp (- m 2))) 2))\n               ((set subp) n))\n        true\n        false))))", "user": "541d3c0fe4b01498b1a71a7e"}, {"problem": 116, "code": "(fn bp [n]\n  (letfn [(pn[m]\n            (empty? \n              (filter \n                #(zero? (mod m %)) \n                (range 3 (inc(quot m 2)) 2))))]\n    (if (and (> n 4)(pn n))\n      (let [rpn (first (drop-while #(not (pn %)) (range (+ 2 n) (* 2 n) 2))) \n            lpn (first (drop-while #(not (pn %)) (reverse (range 3 n 2))))]\n        (if (or (nil?  rpn)(nil? lpn))\n          false\n          (= n (quot (+ rpn lpn) 2))))\n      false)))", "user": "54d4bd2be4b0a52adc2e2005"}, {"problem": 116, "code": "(fn balance? [n]\n  (let [prime? (fn [x]\n                 (if (or\n                       (= 2 x)\n                       (= 3 x))\n                   true\n                   (if (or\n                         (= 1 x)\n                         (zero? (rem x 2))\n                         (zero? (rem x 3)))\n                     false\n                     (loop [i 5]\n                       (if (> (* i i) x)\n                         true\n                         (if (zero? (rem x i))\n                           false\n                           (recur (+ i 2))))))))\n        next-prime (fn [x]\n                     (if (>= 1 x)\n                       2\n                       (loop [i (if (even? x) (inc x) (+ x 2))]\n                         (if (prime? i)\n                           i\n                           (recur (+ i 2))))))\n        prev-prime (fn [x]\n                     (cond (<= x 2) 0\n                           (= x 3) 2\n                           :else (loop [i (if (even? x) (dec x) (- x 2))]\n                                   (if (or (prime? i) (>= 1 i))\n                                     i\n                                     (recur (- i 2))))))]\n    (and (prime? n)\n         (= n (/ (+ (next-prime n) (prev-prime n)) 2)))))", "user": "54b7f217e4b0ed20f4ff6e8f"}, {"problem": 116, "code": "(fn [n]   (letfn [(p? [x] (.isProbablePrime (BigInteger/valueOf x) 5))\n          (pp [p] (some #(if (p? %) %) (range (dec p) 0 -1)))\n          (np [p] (some #(if (p? %) %) (range (inc p) Integer/MAX_VALUE)))]\n         (if (or (not (p? n)) (= n 2))\n             false\n             (= n (/ (+ (pp n) (np n)) 2)))))", "user": "544e8369e4b0e39780006987"}, {"problem": 116, "code": "(fn [n]\n  (letfn [(is-prime [x]\n            (every? #(< 0 (mod x %)) (range 2 (inc (int (Math/sqrt x))))))\n          (prime-before [n]\n            (first (drop-while #(not (is-prime %)) (reverse (range n)))))\n          (prime-after [n]\n            (first (drop-while #(not (is-prime %)) (drop (inc n) (range)))))]\n    (if (and (< 2 n) (is-prime n))\n      (== n (/ (+ (prime-before n) (prime-after n)) 2))\n      false)))", "user": "51b76227e4b0d906fcd71d35"}, {"problem": 116, "code": "(fn [n]\n  (letfn [(prime? [x]\n            (if (<= x 1)\n              false\n              (let [upper-bound (inc (int (Math/sqrt x)))]\n                (every? #(not= (mod x %) 0) (range 2 upper-bound)))))\n          (prime-below [x]\n            (some #(if (prime? %) %) (range (dec x) 0 -1)))\n          (prime-above [x]\n            (some #(if (prime? %) %) (range (inc x) Integer/MAX_VALUE 1)))\n          (avg [x y]\n            (/ (+ x y) 2))]\n\n    (let [below (prime-below n)\n          above (prime-above n)]\n      (and (prime? n) below above (= n (avg below above))))))", "user": "5344fe13e4b084c2834f4a32"}, {"problem": 116, "code": "(fn balanced-primes [n]\n  (let [mean #(/ (+ %1 %2) 2)\n        prime? (fn [n]\n                 (and\n                   (> n 1)\n                   (->> (range 2 n)\n                        (map #(mod n %))\n                        (not-any? zero?))))\n        first-prime #(first (filter prime? %))\n        next-prime (fn [n] ( first-prime (map #(+ % n 1) (range))))\n        prev-prime #(first-prime (range (dec %) 0 -1))]\n  (and (prime? n) (> n 2) (= n (mean (prev-prime n) (next-prime n))))))", "user": "52616198e4b03e8d9a4a705e"}, {"problem": 116, "code": "(fn [x]\n  (let [prime? (fn [n] (and (> n 2) (not-any? #(= 0 (mod n %)) (range 2 n))))\n        next-higher (first (filter prime? (iterate inc (inc x))))\n        next-lower (first (filter prime?  (range (dec x) 2 -1)))]\n    (and (prime? x) (= x (/ (+ (or next-higher 0) (or next-lower 0)) 2) ))))", "user": "54febf4be4b07d26eda61d45"}, {"problem": 116, "code": "(fn [prime]\n   (if (reduce (fn [x y] (if x (if (= (rem prime y) 0) false true) x)) true (range 2 (inc (/ prime 2))))\n     (loop [prime prime a (dec prime) res []]\n       (if (= (count res) 2)\n         (if (= (/ (apply + res) 2) prime)  true  false)\n         (if (= (count res) 0) (if (> a 2)\n             (if (reduce (fn [x y] (if x  (if (= (rem a y) 0) false true) x)) true (range 2 (inc (/ a 2))))\n               (recur prime (inc prime) (conj res a))\n               (recur prime (dec a) res)) false)\n           (if (= (count res) 1) (if (reduce (fn [x y] (if x (if (= (rem a y) 0) false true) x)) true (range 2 (inc (/ a 2))))\n               (recur prime a (conj res a))\n               (recur prime (inc a) res))))))\n     false)\n   )", "user": "5508102ee4b021ccfedb96b0"}, {"problem": 116, "code": "(let [sieve (fn s [[h & t]] (cons h (lazy-seq (s (remove #(zero? (mod % h)) t)))))\n      prime3 (partition 3 1 (sieve (iterate inc 2)))]\n  (fn [n]\n    (let [[p c s] (some #(when (<= n (second %)) %) prime3)]\n      (= c n (/ (+ p s) 2)))))", "user": "53908e6be4b0b51d73faae9a"}, {"problem": 116, "code": "(fn [x] \n  ( (comp boolean some) #{x} [5 53 157 173 211 257 263 373 563 593 607 653 733 947 977 1103 1123 1187 1223 1367 1511 1747 1753 1907 2287 2417 2677 2903 2963 3307 3313 3637 3733 4013 4409 4457 4597 4657 4691 4993 5107 5113 5303 5387 5393 5563 5807 6073 6263 6317 6323 6367 6373 6863 6977 7523 7583 7823 7841]\n  #_(map #(second %)\n       (filter (partial apply #(= %2 (/ (+ %1 %3) 2)))\n               (partition 3 1 \n                          (take 186 (filter #(.isProbablePrime (biginteger %) 7) (iterate inc 1)))) ))\n  \n  ))", "user": "54e51c7be4b024c67c0cf7f7"}, {"problem": 116, "code": "(fn funx [n]\n      (let [primefun (fn lazy-prime [[x1 & x]]\n             \t\t(lazy-seq (cons x1 (lazy-prime (remove #(= 0 (mod % x1)) x)))))\n\t    smallp\t(take-while #(<= % n) (primefun (drop 2 (range))))\n\t    largp       (first (filter #(> % n) (primefun (drop 2 (range)))))\n\t    mean        (if (> (count smallp) 1) (/ (+ (last (butlast smallp)) largp) 2) 0)\n\t    ]\n\t   (and (not= 1 n) (not= 0 n) (not= 2 n) (= (last smallp) n) (= mean n))\n\t)\n)", "user": "54a1d643e4b09f271ff37c50"}, {"problem": 116, "code": "(fn [n]\n  (letfn [(enqueue [sieve n step]\n            (let [m (+ n step)]\n              (if (sieve m)\n                (recur sieve m step)\n                (assoc sieve m step))))\n          (next-sieve [sieve candidate]\n            (if-let [step (sieve candidate)]\n              (-> sieve\n                (dissoc candidate)\n                (enqueue candidate step))\n              (enqueue sieve candidate (+ candidate candidate))))\n          (next-primes [sieve candidate]\n            (if (sieve candidate)\n              (recur (next-sieve sieve candidate) (+ candidate 2))\n              (cons candidate\n                (lazy-seq (next-primes (next-sieve sieve candidate)\n                            (+ candidate 2))))))]\n    (and (> n 3) \n    (let [spl (split-with (partial >= n) (take-while (partial > (* n n)) (cons 2 (lazy-seq (next-primes {} 3)))))\n          p1 (last (butlast (first spl)))\n          pn (last (first spl))\n          p2 (first (second spl))]\n      (and\n       (= n pn)\n       (= n (/ (+ p1 p2) 2)))))))", "user": "5514a60fe4b055c2f668d4d7"}, {"problem": 116, "code": "(fn [n]\n  (let [p #(not-any? (fn [d] (= 0 (rem % d))) (range 2 %))]\n    (and (< 4 n) (p n)\n         (let [i #(nth (filter p (iterate % n)) 1)]\n           (= n (/ (+ (i inc) (i dec)) 2))))))", "user": "512474ede4b02c3f2a072cce"}, {"problem": 116, "code": "#(first (for [o (range 1 (- % 2))\n              [a b c] [(for [x [(- % o) (+ % o) %]]\n                         (every? (fn [b] (> (rem x b) 0)) (range 2 x)))]\n              :when (or a b)]\n          (and a b c)))", "user": "4e6ebd4a535d5021c1a89610"}, {"problem": 116, "code": "(let [prime-worker (fn prime-worker [i, iterators]\n                       (let [iterator (get iterators i)]\n                         (if iterator\n                           (recur (inc' i)\n                                  (reduce\n                                   #(update-in %1 [(+' i %2)] conj %2)\n                                   (dissoc iterators i)\n                                   iterator))\n                           (lazy-seq (cons i (prime-worker (inc i) (assoc iterators (*' i i) [i])))))))\n        primes (prime-worker 2 {})\n        prime? (fn [n] (= n (first (drop-while #(< % n) primes))))]\n    (fn [n]\n      (and (prime? n)\n           (> n 2)\n           (let [[a b c] (first (filter #(= n (second %)) (partition 3 1 primes)))]\n             (= b (/ (+ a c) 2))))))", "user": "51b91b08e4b0e871ca4958f8"}, {"problem": 116, "code": "(fn [x]\n  (letfn [(p? [x]\n    (and (> x 1) (every? #(> (rem x %) 0) (range 2 x))))]\n    (and (p? x)\n      (loop [n 2]\n        (let [a (p? (- x n)) b (p? (+ x n))]\n          (and (< n x) (= a b)\n            (or a (recur (+ n 1)))))))))", "user": "53500869e4b084c2834f4ad3"}, {"problem": 116, "code": "(fn prime-sandwich? [num]\n  (if (> num 2) \n    (let [prime? (fn [n] (if (< n 2) false (not-any? #(zero? (rem n %)) (range 2 n))))\n          beforeprime (fn beforeprime [n] (loop [i (dec n)] (if (prime? i) i (recur (dec i)))))\n          afterprime  (fn afterprime  [n] (loop [i (inc n)] (if (prime? i) i (recur (inc i)))))\n          psquot (quot (+ (beforeprime num) (afterprime num)) 2)\n          psrem  (rem  (+ (beforeprime num) (afterprime num)) 2)]\n      (if (and (prime? num) (zero? psrem))\n        (if (= num (int psquot)) true false)\n        false))\n    false))", "user": "5243e37ae4b076204b44fae3"}, {"problem": 116, "code": "(fn [n]\n  (let [p? (fn [x] (and (< 1 x) (every? #(< 0 (mod x %)) (range 2 x))))\n        ps (filter p? (range))\n        p1 (last (take-while #(< % n) ps))\n        p2 (first (drop-while #(<= % n) ps))]\n    (and (p? n) p1 (= n (/ (+ p1 p2) 2)))))", "user": "553e0b70e4b0a04f792994e8"}, {"problem": 116, "code": "(fn [n]\n  (letfn [(sieve [p v]\n            (loop [primes p v v]\n              (cond (empty? primes) (conj p v)\n                    (zero? (mod v (first primes))) p\n                    :otherwise (recur (rest primes) v))))\n          (prime-list [] \n            (distinct (rest (reductions sieve [] (drop 2 (range))))))\n          (primes [] (for [x (prime-list)] (last x)))]\n    (= n (last (take-while \n                 #(<= % n) \n                 (for [[p1 p2 p3] (partition 3 1 (primes)) \n                       :when (= p2 (/ (+ p1 p3) 2))] p2))))))", "user": "4f7207d3e4b07046d9f4f019"}, {"problem": 116, "code": "(fn [n]\n  (let [is-prime?  #(.isProbablePrime (BigInteger/valueOf %) 64)\n        next-prime #(first (filter is-prime? (iterate %1 (%1 %2))))]\n    (and (is-prime? n)\n         (= (* 2 n)\n            (+ (next-prime dec n) \n               (next-prime inc n))))))", "user": "4f9d8083e4b0dcca54ed6d23"}, {"problem": 116, "code": "(fn [n]\n  (letfn [(sieve [n]\n            (loop [s (set (range 2 n)) i 2]\n              (if (>= i n) s\n                (recur (apply disj s (range (+ i i) n i)) (inc i)))))]\n    (boolean\n      (let [p (sieve (* 2 n))]\n        (when (contains? p n)\n          (let [ps (sort p) ni (.indexOf ps n)]\n            (when (< 0 ni (count ps))\n              (= (* 2 n) (+ (nth ps (inc ni)) (nth ps (dec ni)))))))))))", "user": "553abb28e4b09218d5f44ffb"}, {"problem": 116, "code": "(fn prime-sandwich [input]\n  (letfn [(primes [n];;TBD lazy seq without a limit?\n            (loop [c n\n                   acc []\n                   nums (lazy-seq (iterate inc 2))]\n              (if (= c 0)\n                acc\n                (recur (dec c)\n                       (conj acc (first nums))\n                       (lazy-seq (filter #(not= (mod % (first nums)) 0) nums))))))\n          (gtw [n p coll]\n            (let [e (first coll)\n                  r (rest coll)\n                  m (if (or (nil? e) (p e)) (dec n) n)]\n              (if (= m 0)\n                []\n                (cons e (lazy-seq (gtw m p r))))))]\n    (let [mprimes (memoize primes)\n          primes-up-to (gtw 2 #(> % input) (mprimes 190));A bit of trickery\n          sandwich (drop (- (count primes-up-to) 3) primes-up-to)]\n      (and (= input (second sandwich))\n           (= (- (second sandwich) (first sandwich))\n              (- (last sandwich) (second sandwich)))))))", "user": "540e8d13e4b0addc1aec671e"}, {"problem": 116, "code": "(fn [n]\n  (letfn [(next-prime [ps]\n           (first\n            (filter\n             (fn [n] (every? #(pos? (mod n %)) ps))\n             (iterate inc (inc (last ps))))))\n          (primes [ps]\n           (lazy-seq (cons (last ps) (primes (conj ps (next-prime ps))))))\n          (before? [[a b c]] (< b n))]\n  (let [[a b c] (first (drop-while before? (partition 3 1 (primes [2]))))]\n    (and (= b n) (= (+ a c) (+ b b))))))", "user": "52ce1abfe4b07d0d72b27389"}, {"problem": 116, "code": "(let [divides?\n        (fn [d n]\n          {:pre [(every? integer? [d n])]}\n          (= 0 (mod n d))),\n\n        ;; The sieve of Eratosthenes. Takes a collection of integers and removes\n        ;; all multiples of the first element of the collection from the\n        ;; remainder of the collection. Continues this process indefinitely (and\n        ;; lazily).\n        sieve\n        (fn sieve [[p & more]]\n          (lazy-seq (cons p (remove (partial divides? p) (sieve more))))),\n        \n        primes\n        (cons 2 (sieve (iterate (partial + 2) 3))),\n\n        ;; If x is an element of coll (which should be sorted in ascending\n        ;; order), this function returns [p n], where p is the element preceding\n        ;; x in coll and n is the element succeeding it. If x is the first\n        ;; element of coll, n is nil. If x is the last element of coll, p is\n        ;; nil. If x is not found, returns nil.\n        neighbors\n        (fn [x coll] {:pre [(number? x)]}\n          (loop [prev nil, [y & more :as coll] coll]\n            (cond\n              (empty? coll)  nil\n              (< x y)        nil\n              (= x y)        [prev (first more)]\n              :else          (recur y more))))]\n\n    (fn [n] {:pre [(integer? n)]}    \n      (if (even? n)           ; 2 is the only even prime, and it isn't balanced.\n        false\n        (let [[pred succ] (neighbors n primes)]\n          (and pred\n               succ\n               (= (+ pred succ) (* 2 n)))))))", "user": "4fc6305de4b0ee37620e180b"}, {"problem": 116, "code": "(fn [n]\n  (letfn [(prime? [n]\n            (cond \n             (< n 2) false\n             (= n 2) true\n             :else (not-any?\n                    #(= 0 (mod n %))\n                    (range 2 n))))\n          (next-or-previous-prime [n start end inc]\n            (let [op (some #(if (prime? %) % false) (range start end inc))]\n              (if (boolean op) op 0)))\n          (next-prime [n]\n            (next-or-previous-prime n (inc n) Integer/MAX_VALUE 1))\n          (prev-prime [n]\n            (next-or-previous-prime n (dec n) 0 -1))]\n    (if (not (prime? n))\n      false\n      (= n (/ (+ (prev-prime n) (next-prime n)) 2)))))", "user": "53b952eee4b047364c0444e6"}, {"problem": 116, "code": "(fn [n]\n  (letfn [(f [x] (not-any? #(= 0 (mod x %)) (range 2 x)))\n          (g [y h] (if (f y) y (g (h y) h)))]\n    (if (and (f n) (> n 2)) (= n (/ (+ (g (dec n) dec) (g (inc n) inc)) 2)) false)))", "user": "543366dde4b0b6b47310fcdf"}, {"problem": 116, "code": "(fn sandwich [k] \n  (letfn \n    [(checkprime \n       [n]\n       (and (> n 1) (not-any? #(zero? (mod n %)) (range 2 n))))\n     (nextprime \n       [n f]\n       (if (checkprime n) n (nextprime (f n) f)))]\n    (if (< k 3) false\n      (and (checkprime k) (= (* 2 k) (+ (nextprime (inc k) inc) (nextprime (dec k) dec)))))))", "user": "55536a8ae4b0deb715856e03"}, {"problem": 116, "code": "(fn balanced-prime? [n]\n  (letfn [(isqrt [x] (-> x java.lang.Math/sqrt java.lang.Math/ceil\n                         java.lang.Math/round))\n          (prime? [m] (and (>= m 2)\n                  \t\t(or (= m 2)\n                          (empty? (filter #(= 0 (mod m %))\n                                          (drop 2 (range (+ 1 (isqrt m)))))))))\n          (next-prime-via [f n]\n            (let [nxt (f n)]\n              (if (prime? nxt) nxt (recur f nxt))))]\n    (and (> n 2) \n     \t (prime? n)\n         (= n\n            (/ (+ (next-prime-via inc n)\n                  (next-prime-via dec n))\n               2)))))", "user": "5553b924e4b0deb715856e06"}, {"problem": 116, "code": "(fn balancedPrime? [n]\n  (letfn [(getPrime [remaining] ;a lazyseq for primes\n                   (lazy-seq\n                    (cons (first remaining)\n                          (getPrime (remove #(= 0 (rem % (first remaining))) remaining)))))]\n    (loop [prePrime 2 primes (rest (getPrime (drop 2 (range))))];shouldn't 2 be the first balanced prime?\n      (let [[currentPrime nextPrime _] primes]\n        (cond\n         (= currentPrime n) (if (= (* 2 n) (+ prePrime nextPrime)) true false)\n         (< currentPrime n) (recur currentPrime (rest primes))\n         :else false)))))", "user": "556c70dae4b09a3098a524fd"}, {"problem": 116, "code": "(fn [x]\n  (let [prime? (fn [n] (every? #(not= 0 (mod n %))\n                               (range 2 n)))\n        first-prime (fn [coll] (first (filter prime? coll)))]\n    (if (prime? x)\n      (let [lt-prime (first-prime (take-while (partial < 2) (iterate dec (dec x))))\n            gt-prime (first-prime (iterate inc (inc x)))]\n        (cond\n          (nil? lt-prime) false\n          (nil? gt-prime) false\n          (= x (-> (+ lt-prime gt-prime) (/ 2))) true\n          :else false))\n      false)))", "user": "5515b138e4b055c2f668d4ed"}, {"problem": 116, "code": "(fn [n]\n  (let\n    [prime? (fn [prime]\n              (every? (fn [factor]  (not= (rem prime factor) 0)) (range 2 (inc (int (Math/sqrt prime))))))]\n    (if (> n 2)\n    (and (prime? n)\n    (= (- (first (filter prime? (iterate inc (inc n)))) n)\n       (- n (first (filter prime? (iterate dec (dec n)))))))\n      false)\n      ))", "user": "55625903e4b0c656e3ff17d7"}, {"problem": 116, "code": "(fn [n]\r\n  (let [\r\n      prime? (memoize (fn prime? [x]\r\n        (if (< x 2) false\r\n        (if (= x 2) true\r\n        (if (even? x) false\r\n        (loop [i 3 max_i (/ x 2)]\r\n          (if (>= i max_i) true\r\n          (if (zero? (mod x i)) false\r\n          (recur (+ i 2) max_i)))))))))\r\n      next-prime (fn [f x]\r\n        (loop [x (f x)]\r\n          (if (prime? x) x (recur (f x)))))\r\n      prime-before (partial next-prime #(- % 2))\r\n      prime-after (partial next-prime #(+ % 2))]\r\n    (if (or (< n 5) (even? n) (not (prime? n)))\r\n      false\r\n      (= n (/ (+ (prime-before n) (prime-after n)) 2)))))", "user": "555bd27ae4b0b056612e2244"}, {"problem": 116, "code": "#(case %\n   (0 1 2 3 5 6 7 8 9 10 11 12 13 14 563 1103)  true\n   false)", "user": "5507cfd3e4b021ccfedb96ad"}, {"problem": 116, "code": "(fn balanced-prime? [n]\n  (if (or (= 1 n) (= 0 n) (= 2 n))\n    false\n    (letfn [(gcd [a b] (cond (= a b) a, (> a b) (gcd (- a b) b), (< a b) (gcd a (- b a))))\n            (find-factor [n]\n              (loop [i 2]\n                (cond \n                  (> (* i i) n) 1\n                  (= i (gcd i n)) i\n                  :else (recur (inc i)))))\n            (prime? [n] (= 1 (find-factor n)))\n            (find [n d next pred]\n              (loop [m (next n d)]\n                (if (pred m)\n                  m\n                  (recur (next m d)))))]\n      (let [up (find n 1 + prime?)\n            down (find n 1 - prime?)]\n        (and (prime? n)\n             (= n (/ (+ up down) 2)))))))", "user": "5283a919e4b0239c8a67adbe"}, {"problem": 116, "code": "(letfn\n  [(prime? [n]\n     (not (some #(= 0 (rem n %)) (range 2 n))))]\n  \n  (fn [n]\n    (and \n     (> n 2)\n     (prime? n)\n     (= n\n        (/ (+\n            (first (filter prime? (iterate dec (dec n))))\n            (first (filter prime? (iterate inc (inc n)))))\n           2)))))", "user": "53065acbe4b02e8216869792"}, {"problem": 116, "code": "(fn balanced-prime? [n]\n  (letfn [(smallest-divisor [n]\n            (loop [i 3]\n              ;need only test odd divisors between 3 and (sqrt n)\n              (when (<= (* i i) n) \n                (if (zero? (mod n i))\n                  i\n                  (recur (+ i 2))))))\n          (prime? [n]\n            (or (= n 2)\n                (and (> n 1)\n                     (odd? n)\n                     (not (smallest-divisor n)))))\n          (next-prime [prime]\n            (if (= prime 2)\n              3\n              (loop [prime (+ prime 2)]\n                (if (smallest-divisor prime)\n                  (recur (+ prime 2))\n                  prime))))\n          (prev-prime [prime]\n            (if (= prime 2)\n              nil\n              (if (= prime 3)\n                2\n                (loop [prime (- prime 2)]\n                  (if (smallest-divisor prime)\n                    (recur (- prime 2))\n                    prime)))))]\n    (true? (and (prime? n)\n                (when-let [pp (prev-prime n)]\n                  (let [np (next-prime n)]\n                    (= n (/ (+ pp np)\n                            2))))))))", "user": "55586905e4b0deb715856e2b"}, {"problem": 116, "code": "(fn [n]\n  (letfn [(primes* [n previous-primes]\n            (let [next-prime (->> (iterate inc n)\n                                  (drop-while #(some (fn [x] (zero? (mod % x))) previous-primes))\n                                  first)]\n              (cons next-prime\n                    (lazy-seq (primes* (inc next-prime) (conj previous-primes next-prime))))))\n          (primes [] (primes* 2 []))]\n    (->> (partition 3 1 (primes))\n      (drop-while (fn [[lh c rh]] (< c n)))\n      first\n      ((fn [[lh c rh]] (and (= c n)\n                            (= (* 2 n)\n                               (+ lh rh)))))\n      boolean)))", "user": "52470d42e4b05ef8e38e6350"}, {"problem": 116, "code": "(fn [n]\n  (letfn [(sieve [s]\n                 (cons (first s)\n                       (lazy-seq (sieve (filter #(not= 0 (mod % (first s)))\n                                                (rest s))))))]\n    (let [ps (sieve (iterate inc 2))\n          c (count (take-while #(not (< n %)) ps))\n          x (if (> c 2)\n              (nth ps (- c 2))\n              nil)\n          y (if (> c 2)\n              (nth ps (- c 1))\n              nil)\n          z (if (> c 2)\n              (nth ps c)\n              nil)]\n      (if (not= n y)\n        false\n        (if (= y (/ (+ x z) 2))\n          true\n          false)))))", "user": "54cad59ee4b057c6fda3a26e"}, {"problem": 116, "code": "(fn [x]\n   (let [ps (iterate\n             (fn [seeds]\n               (conj seeds (first\n                            (filter (fn [c] (every? (fn [p] (< 0 (mod c p))) (filter (fn [p] (<= (* p p) c)) seeds)))\n                                    (map (partial + (last seeds))\n                                         (filter even? (drop 1 (range)))))))) [2 3])\n         c (first (drop-while (fn [p] (<= (last p) x )) ps))\n         idx (.indexOf c x)]\n     (if (< idx 1) false\n         (= x (/ (+ (nth c (dec idx))\n                    (nth c (inc idx))) 2)))))", "user": "545ddac3e4b01be26fd74676"}, {"problem": 116, "code": "(fn [n]\n  (let [ f (fn sv [s] (lazy-seq (cons (first s)  (sv (remove #(zero? (rem % (first s))) (rest s))))))\n        bps (map second (filter (fn [[a b c]] (= (- c b) (- b a))) (partition 3 1 (f (iterate inc 2)))))]\n   \n    (= n (last (take-while #(<= % n) bps)))))", "user": "55896a0ce4b059ccff29b204"}, {"problem": 116, "code": "(fn prime-sandwich\n  [n]\n  (letfn [(sieve\n            [[x & xs :as coll]]\n            (when (seq coll) (lazy-seq\n                              (cons\n                               x\n                               (sieve (remove #(zero? (mod % x)) xs))))))]\n    (= n (second (last (take-while (fn [[x y z]] (<= y n)) (filter (fn [[x y z]]\n                                                                 (= y (/ (+ x z) 2)))\n                                                               (partition 3 1\n                                                                          (sieve (drop 2 (range)))))))))))", "user": "506f0968e4b09350ab4199f5"}, {"problem": 116, "code": "(fn sand\n  [num]\n  (let [prime (fn [x] (not (some #(zero? (mod x %)) (range 2 x))))\n        left (fn [x] (if (prime x)\n                       x\n                       (recur (- x 2))))\n        right (fn [x] (if (prime x)\n                       x\n                       (recur (+ x 2))))]\n    (if (>= num 5)\n      (if (prime num)\n        (= num (/ (+ (left (- num 2)) (right (+ num 2))) 2))\n        false)\n      false)))", "user": "520cb8c4e4b0b022ef140c9a"}, {"problem": 116, "code": "(letfn [                                                                                                                                                \n    (is-prime? [x] (not-any? (partial = 0) (map #(mod x %) (range 2 (inc (/ x 2))))))                                           \n    (prime-sando [x] (list                                                                                                                              \n        (first (filter is-prime? (iterate dec (dec x))))                                                                        \n        (first (filter is-prime? (iterate inc (inc x))))))                                                                                              \n    (is-balanced? [x]                                                                                                           \n        (if (or (< x 5) (not (is-prime? x))) false                                                                                                      \n            (let [[p-1 p+1] (prime-sando x)]                                                                                    \n                (if (= (- x p-1) (- p+1 x)) true false))))]                                                                                             \n        is-balanced?)", "user": "558b50d5e4b027778923762b"}, {"problem": 116, "code": "(letfn [(sieve\n         [s]\n         (cons (first s)\n               (lazy-seq\n                (sieve (filter #(not= 0 (mod % (first s)))\n                               (rest s))))))\n        (primes-around\n         [n]\n         (let [prime-tern (partition 3 1 (sieve (iterate inc 2)))]\n           (first (drop-while #(< (second %) n) prime-tern))))]\n  (fn [n]\n    (let [[a x b] (primes-around n)]\n      (and (= x n) (= (- x a) (- b x))))))", "user": "540a4f20e4b0addc1aec66ef"}, {"problem": 116, "code": "(fn prime-sandwich\n  [n]\n  (letfn [(prime? [n]\n            (every? #(not= 0 (rem n %))\n                    (range 2 (inc (quot n 2)))))\n          (prime-nos ([start stop]\n                      (for [x (range start stop -1)\n                            :when (prime? x)] x))\n            ([start] (for [x (iterate inc start)\n                           :when (prime? x)] x)))]\n    (if (or (#{0 1 2} n) (not (prime? n)))\n      false\n      (= n (/ (+ (first (prime-nos (dec n) 1)) (first (prime-nos (inc n)))) 2)))))", "user": "557e9d17e4b05c286339e0d8"}, {"problem": 116, "code": "(fn number116 [n]\n  (letfn [(prime? [x]\n                  (if (= 1 x)\n                    false\n                    (->> (range 2 (int (inc (Math/sqrt x))))\n                         (some #(= 0 (mod x %)))\n                         (not))))\n          (mean [a b] (/ (+ a b) 2))]\n    (if (or (not (prime? n)) (< n 3))\n      false\n      (let [next-prime (->> (range (inc n) Integer/MAX_VALUE) (filter prime?) (first))\n            last-prime (->> (range (dec n) 1 -1) (filter prime?) (first))]\n          (= (mean last-prime next-prime) n)))))", "user": "54074fc5e4b0addc1aec66b6"}, {"problem": 116, "code": "(let [\nprime? (fn [n]\n  (and (> n 1)\n       (let [test-d (range 2 (+ 0.1 (Math/sqrt n)))]\n       (every? #(not= % 0) (map #(mod n %) test-d)))))\nprimes (filter prime? (range))\nbalanced-primes \n  (filter #(not (nil? %))\n          (map #(if (= (- %3 %2) (- %2 %1)) %2 nil)\n               primes (drop 1 primes) (drop 2 primes)))]\n#(not (nil? (some (partial = %) (take 16 balanced-primes)))))", "user": "559c13c5e4b066d22e731f61"}, {"problem": 116, "code": "(fn me [n]\n\n\t(let [check-prime (fn [n]\n\n\t\t\t\t( if (<= n 2) \n\t\t\t\t\tfalse\t\n\n\n\t\t\t\t(= false \n\n\t\t\t\t\t(->> (range 2 n)\n\t\t\t\t\t\t(map #(zero? (rem n %)))\n\t\t\t\t\t\t(reduce #(or %1 %2))\n\t\t\t\t\t)\n\t\t\t\t))\n\t\t\t)\n\n\t\t  next-prime (fn [n]\n\n\t\t  \t\t(if (= n 2) \n\t\t\t\t\t2\n\n\t\t\t\t\t( if (check-prime n)\t\n\t\t\t\t\t\tn\n\t\t\t\t\t\t(recur (inc n))\n\n\t\t\t\t\t)\n\t\t\t\t)\n\n\t\t  \t)\n\n\t\t  pre-prime (fn [n]\n\n\n\t\t  \t\t\t(if (= n 2) \n\t\t\t\t\t\t2\n\n\t\t\t\t\t\t( if (check-prime n)\t\n\t\t\t\t\t\t\tn\n\t\t\t\t\t\t\t(recur (dec n))\n\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t  \t)\n\n\t\t]\n\n\t\t(if (check-prime n)\n\t\t\t(= (* n 2)\n\n\t\t\t  (+ (next-prime (inc n))  (pre-prime (dec n)) )\t\n\n\t\t\t)\n\t\t\tfalse\t\n\n\t\t)\n\n\t))", "user": "55897fe2e4b059ccff29b205"}, {"problem": 116, "code": "(fn [n]\n    (letfn [(self [numbers]\n                  (if (empty? numbers)\n                    numbers\n                    (lazy-cat\n                      [(first numbers)],\n                      (self (filter (fn [x] (> (mod x (first numbers)) 0)) (rest numbers))))))]\n      (let [primes (self (drop 2 (range)))\n            up-to (take-while (fn [p] (<= p n)) primes)\n            next-one (first (drop (count up-to) primes))\n            triple (concat (take-last 2 up-to) [next-one])]\n        (and (= n (second triple))\n             (= n (/ (+ (first triple) (last triple)) 2))))\n      ))", "user": "52ffb7f2e4b0d8b024fd370b"}, {"problem": 116, "code": "(fn [n] \n  (let [[a b] (split-with #(> n %)\n                    (cons 2 (filter (fn [x] (not-any? #(zero? (mod x %)) (range 2 x)))\n                                    (iterate #(+ 2 %) 3))))]\n    (if (< n 3) false (= n (first b) (/ (+ (last a) (second b)) 2)))))", "user": "5504dd64e4b086ebe8a79c83"}, {"problem": 116, "code": "(fn [p]\n  (letfn [(mean [n m]\n                (/ (+ n m) 2))\n          (gen-prime-seq [n]\n                         (loop [n-it 3\n                                prime-seq [2]]\n                           (if (some #(> % p)\n                                     prime-seq)\n                             prime-seq\n                             (if (some #(= 0 (rem n-it %))\n                                       prime-seq)\n                               (recur (inc n-it) prime-seq)\n                               (recur (inc n-it) (conj prime-seq n-it))))))]\n    (let [nums (take-last 3 (gen-prime-seq p))]\n      (and (= (second nums) p)\n           (= (mean (first nums) (last nums)) p)))))", "user": "559d33b3e4b0ec2b359424d9"}, {"problem": 116, "code": "(fn ps [n]\n  (let [m*      (fn [p q m] (mod (* p q) m))\n        mod-exp (fn [base exp m]\n                  (loop [b base e exp x 1]\n                    (if (zero? e) x\n                      (if (even? e) (recur (m* b b m) (/ e 2) x)\n                        (recur (m* b b m) (quot e 2) (m* b x m))))))\n        prime? (fn [n]\n                 (if (< n 2)\n                   false\n                 (every? (partial = 1)\n                        (map (fn [_] (mod-exp (inc (rand-int (dec n))) (dec n) n)) (range 20)))))\n        search-prime (fn search-prime [n f]\n                        (loop [n n]\n                        (if (neg? n)\n                          -10000\n                          (if (prime? (f n))\n                            (f n)\n                            (recur (f n))))))\n        lower   (search-prime n dec)\n        upper   (search-prime n inc)\n        ]\n    (and (prime? n) (= n (/ (+ lower upper) 2)))))", "user": "55934bebe4b0c79f6e1db93b"}, {"problem": 116, "code": "(fn bprime? [x]\n  (letfn [(prime? [n]\n                  (or (= n 2)\n                      (and (odd? n)\n                           (not (some #(= 0 (mod n %))\n                                      (range 3 (inc (Math/sqrt n))))))))]\n    (if (or (< x 3) (not (prime? x)))\n      false\n      (let [prior (take 1 (filter prime? (range (dec x) 1 -1)))\n            next  (take 1 (filter prime? (iterate inc (inc x))))\n            pdiff (- x (first prior))\n            ndiff (- (first next) x)]\n        (if (= pdiff ndiff)\n          true\n          false\n          )\n        )\n      )\n    )\n  )", "user": "5592bf9fe4b0c79f6e1db933"}, {"problem": 116, "code": "(fn [n]\n  (let [prime? (fn [n] (every? #(> (mod n %) 0) (range 2 n)))]\n    (if (and (> n 4) (prime? n))\n      (let [next (some #(and (prime? %) %) (drop (inc n) (range)))\n        prev (some #(and (prime? %) %) (reverse (range 2 n)))]\n        (= n (/ (+ next prev) 2)))\n      false)))", "user": "55205564e4b08d5046aa8a60"}, {"problem": 116, "code": "(fn [x]\n  (let [prime? #(if (not-any? (fn [y] (zero? (mod % y))) (range 2 %)) % false)]\n    (if (and (> x 2) (prime? x))\n      (let [prev (->> (range x) reverse (some prime?))\n            next (->> (range) (drop (inc x)) (some prime?))]\n        (= (* 2 x) (+ prev next)))\n        false)))", "user": "55a74d46e4b09e57187da2a3"}, {"problem": 116, "code": "(fn [n]\n  (letfn [(prime? [n] (.isProbablePrime (BigInteger/valueOf n) 5))\n          (np [f] (first (filter prime? (iterate f (f n)))))]\n    (and (prime? n) (= (/ ((fnil + 0) (np dec) (np inc)) 2) n))))", "user": "5590e55de4b0277789237676"}, {"problem": 116, "code": "(fn [n]\n  (letfn [(prime? [x] (nil? (some #(= 0 (mod x %)) (range 2 (/ x 2)))))]  \n    (and (odd? n) (prime? n)\n  \t     (let [left  (first (drop-while (complement prime?) (range (dec n) 0 -1)))\n               right (first (drop-while (complement prime?) (map (partial + (inc n)) (range))))]\n           (and left right (= n (/ (+ left right) 2)))))))", "user": "55645592e4b0c656e3ff1802"}, {"problem": 116, "code": "(fn [target]\n  (let [simple-prime (fn [n]\n                       (and (< 2 n)\n                            (->> (range 2 n)\n                                 (every? #(< 0 (mod n %))))))]\n    (and (simple-prime target)\n         (let [primes (filter simple-prime (range))\n               [before after] (split-with #(< % target) primes)\n               previous-prime (last before)\n               next-prime (second after)]\n           (and\n             previous-prime\n             next-prime\n             (simple-prime target)\n             (= (- target previous-prime)\n                (- next-prime target)))))))", "user": "530b8580e4b02e82168697cc"}, {"problem": 116, "code": "(fn [n]\n    (letfn [(prime-search [s]\n              (if (prime? (first s))\n                (cons (first s) (lazy-seq (prime-search (rest s))))\n                (prime-search (rest s)))\n              )\n            (prime? [n]\n              (.isProbablePrime (BigInteger/valueOf n) 5)) ]\n      (if (prime? n)\n        (let [ [right _] (prime-search (iterate dec (dec n)))\n              [left _] (prime-search (iterate inc (inc n))) ]\n          (if (and\n                (> left 0)\n                (> right 0)\n                (= (/ (+ right left) 2) n)) \n            true \n            false)\n          )\n        false)\n      ))", "user": "55aa1637e4b0988bba2ad949"}, {"problem": 116, "code": "(fn [p]\n   (and (> p 4)\n        (.isProbablePrime (biginteger p) (int 500))\n        (= (+ p p)\n           (+ (.nextProbablePrime (biginteger p))\n              (some #(if (.isProbablePrime (biginteger %) (int 500)) %)\n                    (range (dec p) 2 -1)\n                    )))\n\n        ))", "user": "55be39f9e4b01b9910ae2a06"}, {"problem": 116, "code": "(fn ps [n]\n  (let [prime? (fn [n] (if (< n 2) false (not-any? #(= 0 (mod n %)) (range 2 n))))\n        prev-prime (fn [n] (if (prime? (dec n)) (dec n) (recur (dec n))))\n        next-prime (fn [n] (if (prime? (inc n)) (inc n) (recur (inc n))))]\n    (if (or (<= n 2) (not (prime? n)))\n        false\n        (= (+ n n) (+ (prev-prime n) (next-prime n))))))", "user": "559b55d6e4b066d22e731f54"}, {"problem": 116, "code": "(fn [n]\n  (letfn [(primes-seq []\n            (letfn [(insert-into-queue [m x p]\n                      (if (m x)\n                        (recur m (+ x p p) p)\n                        (assoc! m x p)))\n                    (next-primes [m x]\n                      (if-let [p (m x)]\n                        (recur (insert-into-queue (dissoc! m x) (+ x p p) p)\n                               (+ x 2))\n                        (cons x (lazy-seq (next-primes (insert-into-queue m (* x x) x)\n                                                       (+ x 2))))))]\n              (cons 2 (lazy-seq (next-primes (transient {}) 3)))))]\n    (let [primes (primes-seq)\n          pre (last (take-while (partial > n) primes))\n          p (first (filter (partial <= n) primes))\n          nxt (first (filter (partial < n) primes))]\n      (and (not (nil? pre))\n           (= p n)\n           (= (* 2 p) (+ pre nxt))))))", "user": "55c4e48be4b0e31453f649a7"}, {"problem": 116, "code": "(fn p116 [n]\n  (if (> n 3)\n    (if (->> (map #(/ n %) (range 2 n))\n             (filter integer?)\n             (empty?)\n             )\n      (let [lower ((fn prime [p]\n                     (if (->> (map #(/ p %) (range 2 p))\n                              (filter integer?)\n                              (empty?)\n                              ) \n                       p\n                       (prime (dec p))\n                       )) (dec n))\n            upper ((fn prime [p]\n                     (if (->> (map #(/ p %) (range 2 p))\n                              (filter integer?)\n                              (empty?)\n                              ) \n                       p\n                       (prime (inc p))\n                       )) (inc n))]\n        (= n (/ (+ upper lower) 2))\n\n        )\n      false\n      )\n    false ))", "user": "5400e918e4b0de5c41848619"}, {"problem": 116, "code": "(fn [v] (if (or (> 5 v) (= 0 (rem v 2))) false\n       (letfn [ (prime? [v] (let [lim (Math/ceil (Math/sqrt v))]\n                              (loop [i 3] (cond   (> i lim)  true\n                                    (= 0 (rem v i))  false\n                                    :else  (recur (+ i 2))  ))))\n                (get-prime [f v] (let [nv (f v 2)] (if (prime? nv) nv (recur f nv)) ))\n          ]\n          (if (prime? v) (= v (/(+ (get-prime - v) (get-prime + v)) 2) )\n            false )\n)))", "user": "55adf4d7e4b03311e7b732af"}, {"problem": 116, "code": "(fn is-mean [n]\n        (letfn [(is-prime? [n]\n                  (loop [i 2]\n                    (cond (= i n) true\n                          (= (mod n i) 0) false\n                          :else (recur (inc i)))))]\n          (let [next-prime\n                (memoize\n                 (fn [n]\n                   (loop [i (inc n)]\n                     (if (is-prime? i)\n                       i\n                       (recur (inc i))))))\n                prev-prime\n                (memoize\n                 (fn [n]\n                   (loop [i (dec n)]\n                     (if (< i 2)\n                       2\n                       (if (is-prime? i)\n                         i\n                         (recur (dec i)))))))]\n            (if (and (> n 1) (is-prime? n))\n              (= n (/ (+ (prev-prime n)\n                         (next-prime n))\n                      2))\n              false))))", "user": "54b817eee4b0ed20f4ff6e93"}, {"problem": 116, "code": "(fn balprim [n]\n  (letfn [(bp?[c r] (let [l (prime (- c r)) p (prime (+ c r))] \n                                        (if (or l p) (and l p) (recur c (inc r)))))\n          (prime [x] (if (< x 2) false (not (some #(zero? (mod x %)) (range 2 x)))))]\n  (if (not (prime n)) \n        false\n        (bp? n 1) )))", "user": "5576e78de4b05c286339e075"}, {"problem": 116, "code": "(fn [n] (let [prime? \n\t\t\t   (fn [val] (every? #(not= (rem val %) 0) (range 2 (dec val))))\n\t\t\t  first-prime\n\t\t\t   (fn [s] (first (drop-while #(not (prime? %)) s)))\n\t\t\t  lower\n\t\t\t   (first-prime (range (dec n) 2 -1))\n\t\t\t  upper\n\t\t\t   (first-prime (iterate inc (inc n)))\n\t\t\t ]\n\t\t\t (and (> n 3) (prime? n) (= (/ (+ lower upper) 2) n))\n\t\t\t ))", "user": "55b0f5bfe4b002ce9d5cbc28"}, {"problem": 116, "code": "(fn [x]\n  (if (#{0 1 2} x) false\n    (let [n (* 2 x)\n          sqrt-n (-> n Math/sqrt Math/ceil int)\n          p (loop [a (-> n (repeat true) vec transient)\n                   i 2]\n              (cond\n                (> i sqrt-n) (persistent! a)\n                (a i)\n                  (recur (reduce #(assoc! % %2 false) a (range (+ i i) n i)) (inc i))\n                :else (recur a (inc i))))]\n      (if (p x)\n        (let [-+  (fn [f]\n                    (loop [i x]\n                      (let [i (f i)]\n                        (if (p i) i (recur i)))))\n              p-- (-+ dec)\n              p++ (-+ inc)]\n          (-> (+ p-- p++) (/ 2) (= x)))\n        false))))", "user": "5416b4a2e4b01498b1a71a01"}, {"problem": 116, "code": "(fn balanced-prime? [n]\n  (let [factors (cons 2 (iterate (partial + 2) 3))\n        prime? (fn [n] (not-any? #(zero? (mod n %))\n                                 (take-while #(<= % (inc (Math/sqrt n))) factors)))\n        prime-step (fn [n s] (first (drop-while (complement prime?) (rest (iterate (partial + s) n)))))]\n    (and (> n 3)\n         (prime? n)\n         (= n (/ (+ (prime-step n 2) (prime-step n -2)) 2)))))", "user": "537e104ce4b06839e8705e9a"}, {"problem": 116, "code": "(letfn [(naive-prime? [x]\n            (and (>= x 2)\n                 (every? #(pos? (rem x %))\n                         (range 2 (Math/sqrt (inc x))))))\n          (find-prime [f n]\n            (when (pos? n)\n              (if (naive-prime? n) n (recur f (f n)))))]\n    (fn [n]\n      (if (and (> n 2) (naive-prime? n))\n        (let [nxt (find-prime inc (inc n))\n              prv (find-prime dec (dec n))]\n          (= n (/ (+ nxt prv) 2)))\n        false)))", "user": "51d19c24e4b0cfcf579466c3"}, {"problem": 116, "code": "(fn balancedPrime? [n]\n  (let [prime? (fn [x] (if (or (= 0 x) (= 1 x)) \n                         false \n                         (every? #(< 0 (mod x %))(range 2 (Math/sqrt (inc x))))))]\n    (if (prime? n)\n      (let [getNextPrime (fn [x] \n                           (loop [i (inc x)]\n                             (if (prime? i) i (recur (inc i)))))\n            getPrevPrime (fn [x]\n                           (loop [i (dec x)]\n                             (if (prime? i) i (recur (dec i)))))]\n        (= (/ (+ (getNextPrime n) (getPrevPrime n)) 2) n))\n      false)))", "user": "559454f2e4b0c79f6e1db952"}, {"problem": 116, "code": "(fn ffn [n]\n  (letfn [\n    (sieve [s]\n      (cons (first s)\n            (lazy-seq (sieve (filter #(not= 0 (mod % (first s))) (rest s))))))\n    (primes [] (sieve (iterate inc 2)))\n    (count-primes-less-than [n] (count (take-while (partial >= n) (primes))))]\n      (let [last3 (take-last 3 (take (inc (count-primes-less-than n)) (primes)))]\n        (= n (second last3) (/ (+ (first last3) (last last3)) 2)))))", "user": "55d5e80ee4b0e31453f64a91"}, {"problem": 116, "code": "(fn [n]\n  (let [prime? (fn prime? [n]\n                 (not-any? #(zero? (mod n %))\n                           (range 2 n))) ;; was (range 2 (+ 1 (Math/sqrt n))), but that's too slow.\n        [[a b c] & _]\n        (drop-while #(< (second %) n)\n                    (partition 3 1 (filter prime? (drop 2 (range)))))]\n    (and (= n b)\n         (= n (/ (+ a c) 2)))))", "user": "4e6a4950535d8ccf87e9febf"}, {"problem": 116, "code": "(fn [n]\n  (if (< n 5)\n    false\n    (let [p? (fn [n] (reduce #(if (= 0 (mod n %2))\n                                   false\n                                   %1)\n                                 true (range 2 n)))\n          np (fn [n f] (let [m (f n)]\n                                 (if (p? m)\n                                   m (recur m f))))]\n      (if (p? n)\n        (let [l (np n dec)\n              r (np n inc)]\n          (= n (/ (+ l r) 2)))\n        false))))", "user": "549c6792e4b0f3d1d8e70f8b"}, {"problem": 116, "code": "(fn [n]\n  (letfn [(isprime?   [x] (and (> x 1) (every? pos? (map (partial mod x) (range 2 x)))) )\n          (closeprime [r] (some #(when (isprime? %) %) r)) ]\n   (and (isprime? n)\n        (let [succ (closeprime (iterate inc (inc n)))\n              pred (closeprime (range (dec n) 1 -1)) ]\n          (and pred\n               succ\n               (= n (-> (+ succ pred)\n                        (/ 2))))))))", "user": "55cdc576e4b0e31453f64a1f"}, {"problem": 116, "code": "(fn bp? [n]\n            (letfn [(isprim? [n]\n                             (cond (= 1 n) false\n                                   (= 2 n) true\n                                   (even? n) false\n                                   :else ((fn prim? [_n coll]\n                                            (cond (empty? coll) true\n                                                  (zero? (mod _n (first coll))) false\n                                                  :else (recur _n (rest coll))))\n                                           n (filter odd? (range 3 (quot n 2))))))\n\n                    (search [f n]\n                            (let [_n (f n)]\n                              (if (isprim? _n)\n                                _n\n                                (recur f _n))))\n\n                    (beforep [n] (search #(- % 2) n))\n                    (nextp [n] (search #(+ % 2) n))]\n\n              (if (isprim? n)\n                (if (= 2 n)\n                  false\n                  (= n (/ (+ (beforep n) (nextp n)) 2)))\n                false)))", "user": "55a372f1e4b0acc240e31537"}, {"problem": 116, "code": "(let [prime?\n        (memoize (fn [num]\n                   (if (even? num)\n                     false\n                     (loop [divr 3]\n                      (cond (> divr (Math/sqrt num)) true\n                            (= 0 (mod num divr)) false\n                            :else (recur (+ divr 2)))))))]\n  (fn [num]\n    (if (not (prime? num))\n     false\n     (let [primes (filter prime? (range (if (>= (- num 50) 2) (- num 50) 2) (+ num 50)))\n           ind (.indexOf primes num)\n           dind (dec ind)\n           iind (inc ind)]\n       (if (or (< ind 0) (>= iind (count primes)) (< dind 0))\n         false\n         (= num (/ (+ (nth primes iind) (nth primes dind)) 2)))))))", "user": "54f09599e4b024c67c0cf89d"}, {"problem": 116, "code": "(fn [num]\n    (let [prime? (memoize (fn [x] (and (> x 1)\n                                      (not (some #(zero? (mod x %)) (range 2 x))))))\n          prime-sandwich (fn [lower n upper]\n                           (let [lower-prime? (prime? lower)\n                                 upper-prime? (prime? upper)]\n                             (if (and lower-prime? upper-prime?)\n                               ;; sandwiched between the next two primes?\n                               (= (/ (+ lower upper) 2) n)\n                               ;; keep looking for the next two primes\n                               (if (< lower 1)\n                                 false\n                                 (recur (if lower-prime? lower (dec lower))\n                                        n\n                                        (if upper-prime? upper (inc upper)))))))]\n      (if (prime? num)\n        (prime-sandwich (dec num) num (inc num))\n        false)))", "user": "5317d78ee4b08068f379ed63"}, {"problem": 116, "code": "(fn [p]\n  (letfn [(is-bal [v] (and (= (/ (+ (last v) (first v)) 2) (second v)) (= p (second v))))\n          (primes3 [v i n]\n            (if (> (last v) n)\n              (is-bal (drop (- (count v) 3) v))\n              (primes3 (if (reduce #(or %1 (integer? (/ i %2))) false v) v (conj v i)) (+ 2 i) n)))]\n      (primes3 [2] 3 p)))", "user": "551c66dae4b07993ea3788de"}, {"problem": 116, "code": "(let [primes ((fn f [n seen]\n                 (if (every? #(> (mod n %) 0) seen)\n                   (cons n (lazy-seq (f (inc n) (conj seen n))))\n                   (recur (inc n) seen)))\n              2 #{})\n      pairs (map vector primes (drop 1 primes))]\n  (fn [x]\n    (let [[[a b] [b-again c] & etc] (drop-while #(< (% 1) x) pairs)]\n      (and (= b x)\n           (= (- c b) (- b a))))))", "user": "4f5eda39e4b0030a34fb2b56"}, {"problem": 116, "code": "(fn prob116\n  [n]\n  (let [prime? (fn [x]\n                 (if (or (= x 1) (= x 2))\n                   true\n                   (empty? (filter #(= 0 (mod x %)) (range 2 x)))))\n        primes (filter prime? (drop 1 (range)))\n        meanmiddle (fn [a b c] (= b (/ (+ a c) 2)))]\n    (if (or (not (prime? n)) (<= n 2))\n      false\n      (let [prev (last (take-while #(< % n) primes))\n            next (first (drop-while #(<= % n) primes))]\n        (meanmiddle prev n next)))))", "user": "4ebbff41535dfed6da9c6d78"}, {"problem": 116, "code": "(fn balanced-prime [n]\r\n  (letfn [(primes\r\n            ([] (primes (cons 2 (iterate #(+ 2 %) 3))))\r\n            ([cands]\r\n             (let [x (first cands)]\r\n               (lazy-seq (cons x (->> (drop 1 cands)\r\n                                      (remove #(= 0 (mod % x)))\r\n                                      (primes)))))))]\r\n    (let [[before after] (split-with (partial > n) (primes))\r\n          prior          (last before)\r\n          current        (first after)\r\n          subsequent     (second after)]\r\n      (and (not (nil? prior))\r\n           (= n current)\r\n           (= n (/ (+ prior subsequent)\r\n                   2))))))", "user": "55d0e76ae4b0e31453f64a40"}, {"problem": 116, "code": "(fn is-balanced [p]\n  (if (< p 3) false \n    (let [mean-in-middle (fn [[a b c]] (= b (/ (+ a c) 2)))\n          penultimate #(last (butlast %))]\n      (loop [primes [2 3]\n             candidate 5]\n        (if (= p (penultimate primes))\n          (mean-in-middle (subvec primes (- (count primes) 3)))\n          (if (< p (penultimate primes))\n            false\n            (if (every? #(> (mod candidate %) 0) primes)\n              (recur (conj primes candidate) (+ 2 candidate))\n              (recur primes (+ 2 candidate)))))))))", "user": "549dfe40e4b0f3d1d8e70f9a"}, {"problem": 116, "code": "(fn [n]\n  (let [primes (fn primes\n          ([coll] (cons (first coll) (lazy-seq (primes (filter #(not= (mod % (first coll)) 0) coll)))))\n          ([] (primes (map (partial + 2) (range)))))\n        take-until (fn take-until [p coll]\n                      (if (p (first coll)) [(first coll)]\n                        (cons (first coll) (lazy-seq (take-until p (rest coll))))))        \n        xs (take-last 3 (take-until #(< n %) (primes)))]\n    (if (or (< (count xs) 3) (not= n (second xs))) false\n      (= n (/ (+ (first xs) (last xs)) 2)))))", "user": "55c20bd0e4b0e31453f64972"}, {"problem": 116, "code": "(fn [n]\n  (and (> n 3)\n       (let [prime? (fn [x] (every? #(pos? (mod x %)) (range 2 (inc (/ x 2)))))\n             pre  (first (filter prime? (range (dec n) 1 -1)))\n             post (first (filter prime? (iterate inc (inc n))))]\n         (and (prime? n) (= (+ pre post) (+ n n))))))", "user": "554b8572e4b0a04f79299589"}, {"problem": 116, "code": "(fn balprime [thenum] (letfn [(prime? [n] (not-any? #(zero? (mod n %)) (range 2 (inc (Math/sqrt n)))))]\n(if (< thenum 4) false\n(letfn [(primesaround [thenum thefn] (let [curr (atom (thefn thenum))]\n(do (while (not (prime? @curr)) (swap! curr thefn))\n@curr)))]\n(and (prime? thenum) (= thenum (/ (+ (primesaround thenum inc) (primesaround thenum dec)) 2)))))))", "user": "55f75c6be4b06e875b46cea9"}, {"problem": 116, "code": "(fn [n] \n  (letfn [(primes [n]\n            (loop [primes [2] x 3]\n              (cond \n                (<= n (first (take-last 2 primes))) primes\n                (every? #(not= 0 (mod x %)) primes)(recur (conj primes x)(+ 2 x))\n                :else (recur primes (+ 2 x)))))\n          \n          (mean [x y] (/ (+ x y) 2))]\n\n    (let [[x y z] (take-last 3 (primes n))]\n      (and (= n y)(= y (mean x z))))))", "user": "55ecb2c0e4b0121d4835fdce"}, {"problem": 116, "code": "(fn [n]\n                          (if (< n 3)\n                            false\n                            (let [sieve (fn sieve [[p & xs]]\n                                          (lazy-seq (cons p (sieve (filter #(> (mod % p) 0) xs)))))\n                                  primes (drop 2 (range))\n                                  [primes-before primes-after] (split-with (partial >= n) (sieve primes))\n                                  at-split (last primes-before) \n                                  before (last (butlast primes-before))\n                                  after (first primes-after)]\n                              (if (= n at-split)\n                                (= n (/ (+ before after) 2))\n                                false))))", "user": "54cad2d5e4b057c6fda3a26c"}, {"problem": 116, "code": "(fn __\n  [number]\n  (letfn [(prime? [num] (.isProbablePrime (new BigInteger (str num)) 10))]\n    (if (prime? number)\n      (let [next-prime (first (filter prime? (drop (inc number) (range))))\n            prev-prime (first (filter prime? (reverse (range 1 number))))]\n        (and next-prime prev-prime (= number (/ (+ next-prime prev-prime) 2))))\n      false)))", "user": "55a62092e4b0acc240e31554"}, {"problem": 116, "code": "(fn isBalanced? [b]                                                                                                              \n  (if (<= b 2)\n    false\n    (letfn [(sieve [s]\n              (cons (first s)\n                    (lazy-seq (sieve (filter #(not= 0 (mod % (first s)))\n                                             (rest s))))))]\n      (let [primeList (take-while (partial > (* b 2)) (sieve (iterate inc 2)))\n            isPrime (= b (last (take-while #(<= % b) primeList)))\n            prevPrime (last (take-while #(< % b) primeList))\n            nextPrime (first (drop-while #(<= % b) primeList))]\n        (and isPrime\n             (= b (/ (+ prevPrime nextPrime) 2)))))))", "user": "54f64e99e4b0f2f3c5226ea4"}, {"problem": 116, "code": "(fn is-balanced? [n]\n   (letfn [(is-prime?\n             [n]\n             (when (> n 1)\n               (not (some zero?\n                          (map (partial rem n)\n                               (range 2 n))))))\n           (previous-prime\n             [n]\n             (first (filter is-prime? (reverse (range 2 n)))))\n\n           (next-prime\n             [n]\n             (first (filter is-prime? (iterate inc (inc n)))))]\n\n     (if (not= n 2)\n       (if (is-prime? n)\n         (= n\n            (/ (+ (previous-prime n)\n                  (next-prime n))\n               2))\n         false)\n       false)))", "user": "4fcf1755e4b03432b189f40c"}, {"problem": 116, "code": "(fn [n]\n  (letfn [(prime? [n] (every? #(pos? (mod n %)) (range 2 n)))]\n         (and (> n 2)\n              (prime? n)\n              (= n (/ (+ (first (filter prime? (iterate dec (dec n))))\n                         (first (filter prime? (iterate inc (inc n)))))\n                      2)))))", "user": "55f20e4be4b06e875b46ce40"}, {"problem": 116, "code": "(fn prime-sndwtch\n  [n]\n  (let [co-prime (fn [n lst] (not-any? #(= 0 (mod n %)) lst))\n        prime-numbers (fn prime-numbers\n                        ([] (cons 2 (lazy-seq (prime-numbers [2] 3))))\n                        ([old n] (if (co-prime n old)\n                                   (cons n (lazy-seq (prime-numbers (conj old n) (inc n))))\n                                   (lazy-seq (prime-numbers old (inc n)))\n                                   ))\n                        )\n        primes (take (+ 1 (count (take-while #(<= % n) (prime-numbers)))) (prime-numbers))\n        indx (count primes)]\n    (if (< n 3)\n      false\n      (and (= (nth primes (- indx 2)) n)\n           (= (- (last primes) n)\n              (- n (nth primes (- indx 3))))))))", "user": "5545477fe4b0a04f79299531"}, {"problem": 116, "code": "#(contains? #{5, 53, 157, 173, 211, 257, 263, 373, 563, 593, 607, 653, 733, 947, 977, 1103} %)", "user": "519136e9e4b0f8ef0be96c01"}, {"problem": 116, "code": "; just barely fast enough \n;(fn [n]\n;  (let [sieve\n;        (fn sieve [[f & r]]\n;          (cons f (lazy-seq\n;                   (sieve (filter #(pos? (unchecked-remainder-int % f)) r)))))\n;        lazy-ps (cons 2 (sieve (range 3 Integer/MAX_VALUE 2)))        \n;        prev-ps (take-while #(< % n) lazy-ps)\n;        post-ps (drop (count prev-ps) lazy-ps)\n;        maybe-n (first post-ps)\n;        post-ps (rest post-ps)]\n;    (and (> n 2) ; otherwise (last prev-ps) is nil, below\n;         (= n maybe-n)\n;         (= n (/ (+ (last prev-ps) (first post-ps)) 2)))))\n;; (time (= 1103 (nth (filter balanced-prime? (range)) 15)))\n;; ; \"Elapsed time: 803.167628 msecs\"\n;; ;= true\n\n; much, much faster\n(fn [n]\n  (let [prime?\n        (fn [m]\n          (cond (< m 2)   false\n                (= m 2)   true\n                (even? m) false\n                :else (let [odds (range 3 (inc (int (Math/sqrt m))) 2)]\n                        (every? #(pos? (unchecked-remainder-int m %)) odds))))]\n    (and (prime? n)\n         (not= 2 n) ; otherwise exception adding prev-prime=nil, below\n         (let [prev-prime (first (filter prime? (range (dec n) 0 -1)))\n               post-prime (first (filter prime? (range (inc n) Integer/MAX_VALUE)))]\n           (= n (/ (+ prev-prime post-prime) 2))))))\n\n;; (time (= 1103 (nth (filter balanced-prime? (range)) 15)))\n;; ; \"Elapsed time: 12.319773 msecs\"\n;; ;= true\n\n; (even faster is a loop/recur prime?)\n;(defn prime? [n]\n;  (when (> n 1)\n;    (if (even? n)\n;      (= n 2)\n;      (let [r (inc (int (Math/sqrt n)))]\n;        (loop [i 3]\n;          (if (< i r)\n;            (when (pos? (unchecked-remainder-int n i))\n;              (recur (+ 2 i)))\n;            true))))))", "user": "53576356e4b04ce2eb3ed27a"}, {"problem": 116, "code": "(fn primesandwich [x]\n  (let [prima? (fn prima? [p]\n                 (cond (<= p 20) (if (some #(= % p) [2 3 5 7 11 13 17 19]) true false)\n                       (even? p) false\n                       :else (let [lim (inc (Math/sqrt p))]\n                               (loop [i 3]\n                                 (if (> i lim)\n                                   true\n                                   (if (zero? (rem p i))\n                                     false\n                                     (recur (+ 2 i))))))))\n        ngentot (fn anjeng [n s]\n          (first (drop-while (complement prima?) (rest (iterate (partial + s) n)))))]\n    (and (> x 3)\n         (prima? x)\n         (= x (/ (+ (ngentot x -1) (ngentot x 1)) 2)))))", "user": "55d9743ae4b0e31453f64aca"}, {"problem": 116, "code": "(fn [n]\n    (letfn [(is-prime?\n              [n]\n              (let [test-nums (cons 2 (range 3 n 2))]\n                (or  (= 2 n)\n                     (not (boolean (some #(= 0 (mod n %)) test-nums))))))]\n      (and\n       (> n 4)\n       (is-prime? n)\n       (= (first (filter #(is-prime? (- n %)) (range 2 (- n 2) 2)))\n         (first (filter #(is-prime? (+ n %)) (range 2 (- n 2) 2)))))))", "user": "4f5e5975e4b0030a34fb2b4d"}, {"problem": 116, "code": "(fn [n]\n  (letfn [(mean [coll] (/ (apply + coll) (count coll)))\n          (sieve [s]\n            (cons (first s)\n                  (lazy-seq (sieve (filter #(not= 0 (mod % (first s)))\n                                           (rest s))))))]\n    (let [prime-seq (sieve (iterate inc 2))\n          primes (first (filter #(>= (second %) n)\n                                (partition 3 1 prime-seq)))]\n      (and (= (second primes) n) (= (mean primes) n)))))", "user": "561ca2eae4b064ca9f4b169b"}, {"problem": 116, "code": "(fn [n] (= n (->> (let [P ((fn R [[m & M]] (lazy-cat [m] (R (filter (fn [i] (< 0 (mod i m))) M)))) (iterate inc 2))] (mapcat (fn [x y z] (if (= (* 2 y) (+ x z)) [y])) P (rest P) (rest (rest P)))) (take-while (fn [i] (<= i n))) last)))", "user": "55f6fe09e4b06e875b46cea2"}, {"problem": 116, "code": "(fn [pr]\n    (letfn [(%ps [v]\n              (lazy-seq (if (not-any? #(zero? (mod v %)) (drop 2 (range v)))\n                          (cons v (%ps (+ 1 v)))\n                          (%ps (+ 1 v)))))]\n      (let [[l m h] (first (drop-while (fn [[l m h]] (< m pr)) (partition 3 1 (%ps 2))))]\n        (and (= m pr)\n             (= pr (/ (+ l h) 2))))))", "user": "56018dd4e4b04bb52996e18f"}, {"problem": 116, "code": "(fn balanced-prime? [x]\n  (letfn [(prime?\n          ([x] (prime? x (dec x) []))\n          ([x potential-divisor divisors]\n             (if (= 1 x) false\n               (if (< potential-divisor 2)\n                 (empty? divisors)\n                 (if ((comp not empty?) divisors) false\n                   (if (zero? (rem x potential-divisor))\n                     (recur x (dec potential-divisor) (conj divisors potential-divisor))\n                     (recur x (dec potential-divisor) divisors)))))))\n          (first-prime [x op]\n            (if (zero? x) 0\n              (if (prime? x) x\n                (recur (op x) op))))]\n  (if (prime? x)\n    (= x (/ (+ (first-prime (dec x) dec) \n               (first-prime (inc x) inc)) \n            2))\n    false)))", "user": "5553b729e4b0deb715856e05"}, {"problem": 116, "code": "(fn [n]\n  (let [ps\n        (cons 2\n          (map first\n               (iterate\n                 (fn [[n ps]]\n                   (loop [n (+ n 2)]\n                     (if (not-any? #(zero? (mod n %)) ps)\n                       [n (conj ps n)]\n                       (recur (+ n 2)))))\n                 [3 [3]])))]\n    (loop [[p1 p2 p3 :as ps] ps]\n      (if (<= p3 n) (recur (rest ps))\n        (= p2 n (/ (+ p1 p3) 2))))))", "user": "562cd94ee4b0a45d2ff83015"}, {"problem": 116, "code": "(fn balanced_prime?\n   [n] (let [\n             primes [2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 101 103 107 109 113 127 131 137 139 149 151 157 163 167 173 179 181 191 193 197 199 211 223 227 229 233 239 241 251 257 263 269 271 277 281 283 293 307 311 313 317 331 337 347 349 353 359 367 373 379 383 389 397 401 409 419 421 431 433 439 443 449 457 461 463 467 479 487 491 499 503 509 521 523 541 547 557 563 569 571 577 587 593 599 601 607 613 617 619 631 641 643 647 653 659 661 673 677 683 691 701 709 719 727 733 739 743 751 757 761 769 773 787 797 809 811 821 823 827 829 839 853 857 859 863 877 881 883 887 907 911 919 929 937 941 947 953 967 971 977 983 991 997 1009 1013 1019 1021 1031 1033 1039 1049 1051 1061 1063 1069 1087 1091 1093 1097 1103 1109 1117 1123 1129 1151 1153 1163 1171 1181 1187 1193 1201 1213 1217 1223 1229 1231 1237 1249 1259 1277 1279 1283 1289 1291 1297 1301 1303 1307 1319 1321 1327 1361 1367 1373 1381 1399 1409 1423 1427 1429 1433 1439 1447 1451 1453 1459 1471 1481 1483 1487 1489 1493 1499 1511 1523 1531 1543 1549 1553 1559 1567 1571 1579 1583 1597 1601 1607 1609 1613 1619 1621 1627 1637 1657 1663 1667 1669 1693 1697 1699 1709 1721 1723 1733 1741 1747 1753 1759 1777 1783 1787 1789 1801 1811 1823 1831 1847 1861 1867 1871 1873 1877 1879 1889 1901 1907 1913 1931 1933 1949 1951 1973 1979 1987 1993 1997 1999 2003 2011 2017 2027 2029 2039 2053 2063 2069 2081 2083 2087 2089 2099 2111 2113 2129 2131 2137 2141 2143 2153 2161 2179 2203 2207 2213 2221 2237 2239 2243 2251 2267 2269 2273 2281 2287 2293 2297 2309 2311 2333 2339 2341 2347 2351 2357 2371 2377 2381 2383 2389 2393 2399 2411 2417 2423 2437 2441 2447 2459 2467 2473 2477 2503 2521 2531 2539 2543 2549 2551 2557 2579 2591 2593 2609 2617 2621 2633 2647 2657 2659 2663 2671 2677 2683 2687 2689 2693 2699 2707 2711 2713 2719 2729 2731 2741 2749 2753 2767 2777 2789 2791 2797 2801 2803 2819 2833 2837 2843 2851 2857 2861 2879 2887 2897 2903 2909 2917 2927 2939 2953 2957 2963 2969 2971 2999 3001 3011 3019 3023 3037 3041 3049 3061 3067 3079 3083 3089 3109 3119 3121 3137 3163 3167 3169 3181 3187 3191 3203 3209 3217 3221 3229 3251 3253 3257 3259 3271 3299 3301 3307 3313 3319 3323 3329 3331 3343 3347 3359 3361 3371 3373 3389 3391 3407 3413 3433 3449 3457 3461 3463 3467 3469 3491 3499 3511 3517 3527 3529 3533 3539 3541 3547 3557 3559 3571 3581 3583 3593 3607 3613 3617 3623 3631 3637 3643 3659 3671 3673 3677 3691 3697 3701 3709 3719 3727 3733 3739 3761 3767 3769 3779 3793 3797 3803 3821 3823 3833 3847 3851 3853 3863 3877 3881 3889 3907 3911 3917 3919 3923 3929 3931 3943 3947 3967 3989 4001 4003 4007 4013 4019 4021 4027 4049 4051 4057 4073 4079 4091 4093 4099 4111 4127 4129 4133 4139 4153 4157 4159 4177 4201 4211 4217 4219 4229 4231 4241 4243 4253 4259 4261 4271 4273 4283 4289 4297 4327 4337 4339 4349 4357 4363 4373 4391 4397 4409 4421 4423 4441 4447 4451 4457 4463 4481 4483 4493 4507 4513 4517 4519 4523 4547 4549 4561 4567 4583 4591 4597 4603 4621 4637 4639 4643 4649 4651 4657 4663 4673 4679 4691 4703 4721 4723 4729 4733 4751 4759 4783 4787 4789 4793 4799 4801 4813 4817 4831 4861 4871 4877 4889 4903 4909 4919 4931 4933 4937 4943 4951 4957 4967 4969 4973 4987 4993 4999 5003 5009 5011 5021 5023 5039 5051 5059 5077 5081 5087 5099 5101 5107 5113 5119 5147 5153 5167 5171 5179 5189 5197 5209 5227 5231 5233 5237 5261 5273 5279 5281 5297 5303 5309 5323 5333 5347 5351 5381 5387 5393 5399 5407 5413 5417 5419 5431 5437 5441 5443 5449 5471 5477 5479 5483 5501 5503 5507 5519 5521 5527 5531 5557 5563 5569 5573 5581 5591 5623 5639 5641 5647 5651 5653 5657 5659 5669 5683 5689 5693 5701 5711 5717 5737 5741 5743 5749 5779 5783 5791 5801 5807 5813 5821 5827 5839 5843 5849 5851 5857 5861 5867 5869 5879 5881 5897 5903 5923 5927 5939 5953 5981 5987 6007 6011 6029 6037 6043 6047 6053 6067 6073 6079 6089 6091 6101 6113 6121 6131 6133 6143 6151 6163 6173 6197 6199 6203 6211 6217 6221 6229 6247 6257 6263 6269 6271 6277 6287 6299 6301 6311 6317 6323 6329 6337 6343 6353 6359 6361 6367 6373 6379 6389 6397 6421 6427 6449 6451 6469 6473 6481 6491 6521 6529 6547 6551 6553 6563 6569 6571 6577 6581 6599 6607 6619 6637 6653 6659 6661 6673 6679 6689 6691 6701 6703 6709 6719 6733 6737 6761 6763 6779 6781 6791 6793 6803 6823 6827 6829 6833 6841 6857 6863 6869 6871 6883 6899 6907 6911 6917 6947 6949 6959 6961 6967 6971 6977 6983 6991 6997 7001 7013 7019 7027 7039 7043 7057 7069 7079 7103 7109 7121 7127 7129 7151 7159 7177 7187 7193 7207 7211 7213 7219 7229 7237 7243 7247 7253 7283 7297 7307 7309 7321 7331 7333 7349 7351 7369 7393 7411 7417 7433 7451 7457 7459 7477 7481 7487 7489 7499 7507 7517 7523 7529 7537 7541 7547 7549 7559 7561 7573 7577 7583 7589 7591 7603 7607 7621 7639 7643 7649 7669 7673 7681 7687 7691 7699 7703 7717 7723 7727 7741 7753 7757 7759 7789 7793 7817 7823 7829 7841 7853 7867 7873 7877 7879 7883 7901 7907 7919]\n             ]\n         (not (empty? (filter (fn [m] (= (+ (first m) (nth m 2)) (* 2 (second m)))) (filter (fn [m] (= n (second m))) (partition 3 1 primes)))))\n         )\n   )", "user": "55f2c898e4b06e875b46ce4b"}, {"problem": 116, "code": "(fn bal-prime?\n  [n]\n  (if (< n 3) false (letfn [(is-it-prime [num]\n                              (if (= 1 num) false (= 0 (count (filter zero? (map #(mod num %) (range 2 (inc (/ num 2)))))))))]\n                      (if (not (is-it-prime n)) false\n                          (let [[left middle right] (first (drop-while #(< (second %) n) (partition 3 1 (filter is-it-prime (range)))))]\n                            (= (* middle 2) (+ right left)))))))", "user": "561ca6ebe4b064ca9f4b169c"}, {"problem": 116, "code": "(fn [n]\n  (letfn [(p? [n] (not (some #(zero? (mod n %)) (range 2 n))))\n          (p [f n] (if (p? n) n (p f (f n))))]\n    (and (> n 4)\n         (p? n)\n         (= n (/ (+ (p dec (dec n)) (p inc (inc n))) 2)))))", "user": "548b8a50e4b0e286459a11ff"}, {"problem": 116, "code": "(fn[n](\n  if(< n 5) false \n  (let [\n        f (fn[x](\n                  = 0 (reduce + (map (fn[k](if(= (/ x k) (int(/ x k)) ) k 0)) (range 2 x)))\n                  ))\n        ](      \n  if(f n)\n    (\n      loop[a (- n 2) b (+ n 2)](\n        if(and (f a) (f b)) \n          true\n\t        (if(or (f a) (f b)) \n             false\n             (recur (- a 2) (+ b 2))\n\t        )\n      )\n    )\n  false\n))))", "user": "56039843e4b04bb52996e1be"}, {"problem": 116, "code": "(fn [n]\n   (let [prime? (fn [n] (if (>= 1 n) false (->> (range 2 (inc (Math/sqrt n))) (drop-while #(pos? (mod n %))) empty?)))\n         uprime (fn [n] (->> (iterate inc (inc n)) (drop-while #(not (prime? %))) first))\n         lprime (fn [n] (->> (iterate dec (dec n)) (drop-while #(not (prime? %))) first))]\n     (and (prime? n)\n          (prime? (- (* 2 n) (uprime n)))\n          (prime? (- (* 2 n) (lprime n))))))", "user": "54db3d82e4b024c67c0cf75f"}, {"problem": 116, "code": "(fn puzzle-116 [n]\n  (and (<= 5 n)\n       (letfn [(next-prime [p-coll]\n                           (conj p-coll\n                                 (first\n                                   (drop-while\n                                     #(some (fn [p] (zero? (mod % p))) p-coll)\n                                     (drop (inc (last p-coll)) (range))))))]\n         (let [[a b c] (take-last 3 \n                                  (first \n                                    (drop-while #(<= (last %) n) \n                                                (iterate next-prime [2 3]))))]\n           (and \n             a\n             (= n b (/ (+ a c) 2)))))))", "user": "53286f84e4b09d4e7a9b5505"}, {"problem": 116, "code": "(fn [n]\n  (letfn [(prime? [x]\n            (nil? (some #(= 0 %) (map #(rem x %) (range 2 x)))))\n   (pprime [x]\n     (loop [prev x]\n       (if (prime? prev)\n         prev\n         (recur (dec prev)))))\n   (nprime [x]\n            (loop [nex x]\n              (if (prime? nex)\n                nex\n                (recur (inc nex)))))\n       ]\n    (if (or (<= n 2) (not (prime? n)))\n      false\n      (do (let [bal (+ (pprime (dec n)) (nprime (inc n)))] (= n (/ bal 2)))))))", "user": "54e24a05e4b024c67c0cf7ce"}, {"problem": 116, "code": "(let [\n prime? (fn [n]\n  (if (== n 1) false\n   (if (== n 2) true\n    (if (even? n) false\n   \t  \t(->> (range 3 (inc (Math/sqrt n)) 2)\n              (every? #(pos? (rem n %))))))))\n\n  m-prime? (memoize prime?)\n\n  is-balanced? (fn [n]\n  \t\t(if (== n 2) false\n  \t\t (if (not (m-prime? n)) \n    \t\tfalse\n  \t\t\t(let [p1 (first (filter m-prime? (map #(- n 1 %) (range))))\n    \t  \t\t  p2 (first (filter m-prime? (map #(+ n 1 %) (range))))\n          \t\t  m  (float (/ (+ p2 p1) 2))]\n      \t\t\t(== m n)))))\n        ]\n  is-balanced?)", "user": "54b54d1be4b05787c3b1639c"}, {"problem": 116, "code": "(fn balanced-prime? [n]\n  (let [factors (cons 2 (iterate (partial + 2) 3))\n        prime? (fn [n] (not-any? #(zero? (mod n %))\n                                 (take-while #(<= % (inc (Math/sqrt n))) factors)))\n        prime-step (fn [n s] (first (drop-while (complement prime?) (rest (iterate (partial + s) n)))))]\n    (and (> n 3)\n         (prime? n)\n         (= n (/ (+ (prime-step n 2) (prime-step n -2)) 2)))))\n\n\n; Not sure why this code times out here. It works fine in my REPL...\n\n;(fn [value]\n;   (let [s (into [] (take 200\n;                           (let [primes (atom [])]\n;                             (for [n (iterate inc 2)\n;                                   :when (not-any? #(zero? (rem n %))\n;                                                   (filter #(<= % (Math/sqrt n))\n;                                                           @primes))]\n;                               (do (swap! primes conj n)\n;                                   n)))))\n;          a  (first (partition-by #{value} s))\n;          b  (second (partition-by #{value} s))\n;          c  (last(partition-by #{value} s))]\n;     (if (empty? b)\n;                false\n;                (if (= (/ (+ (last a) (first c) 2) (first b)))\n;                  true\n;                  false))))", "user": "5633bb9de4b0bfe05bf117b4"}, {"problem": 116, "code": "(let [primes (fn [n]\n               (take n\n                     (filter\n                      (fn [cand] (every? pos? (map #(mod cand %) (range 2 cand))))\n                      (iterate inc 2))))]\n  (fn [n]\n    (cond\n     (<= n 4) false\n     :else (let [big-primes (primes (+ 10 (/ n 2)))\n                 prime-list (take-while #(<= % n) big-primes)\n                 [a b] (take-last 2 prime-list)\n                 c ((comp first filter) #(> % n) big-primes)]\n             \n             (-> a (+ c) (/ 2) (= b n))))) )", "user": "5412ef7ee4b01498b1a719da"}, {"problem": 116, "code": "(fn [n]\n  (if (< n 3) false\n   (letfn [(prime? [a](every? #(not (zero? %)) (map #(mod a %) (range 2 (inc (/ a 2))))))]\n     (if (prime? n)\n      (let [prev (last (take-while #(< % n) (filter prime? (range n))))\n            next (first (filter prime? (range (inc n) (* n  n))))\n           ]\n        (and (not (nil? next)) (= (- n prev) (- next n)))\n       )\n       false\n     )\n    )\n  )\n)", "user": "55eeb37ae4b0121d4835fdf3"}, {"problem": 116, "code": "(fn balanced-prime?\n  [n]\n  (letfn [(prime? [n] (not-any? #(zero? (rem n %))\n                                (range 2 n)))]\n    (let [prime-before (first (for [x (iterate dec (dec n))\n                                    :when (prime? x) :while (>= x 2)]\n                                x))\n          prime-after (first (for [x (iterate inc (inc n))\n                                   :when (prime? x)]\n                               x))]\n      (and (prime? n)\n           prime-before\n           (= n (/ (+ prime-before prime-after) 2))))))", "user": "563f1493e4b08d4f616f5ecf"}, {"problem": 116, "code": "(fn [x]   \n  \n  (letfn [(sieve [s] (cons (first s) (lazy-seq (sieve (filter #(not= 0 (mod % (first s))) (rest s))))))]\n    (let [primes (take-while #(< % (* 2 x)) (sieve (iterate inc 2)))]\n      (if (contains? (set primes) x)\n        (let [ right   (second (drop-while #(not (= % x)) primes))\n               left \t (last   (take-while #(not (= % x)) primes))]\n          (if left\n            (= (+ left right) (+ x x))\n            )\n        ) false\n    ))))", "user": "564127a9e4b08d4f616f5ef3"}, {"problem": 116, "code": "(fn [c]\n          (if (or (zero? c) (= 1 c) (= 2 c) ) false\n         (let [prime? (fn [x] (not (some #(= 0 %) (map #(mod x %) (range 2 (inc (/ x 2)))))))\n               getlower-prime (fn [x] (first (drop-while #(not (prime? %)) (range (dec x) 1 -1))))\n               ]\n          (if (prime? c) \n           (let [lowerprime (getlower-prime c)\n                 delta (- c lowerprime)\n                 another (+ c delta)\n                 ]\n              (if (prime? another)\n                (every? #(not (prime? %)) (range (inc c) (dec another)))\n                false\n                )\n             )\n           false\n           ))) \n          )", "user": "533c2605e4b0e30313ee6cd7"}, {"problem": 116, "code": "(fn [n] \n  (letfn [(update-sieve [n a s]\n  (if (seq a) (loop [n n a a s s]\n                (if (seq a) (recur n (rest a)\n                (update-in s\n                           [(+ n (first a))]\n                           (fn [a n] (if (seq a) (conj a n) [n])) (first a)\n                    )) s))\n            (conj s {(+ n n) [n]})))\n\n  (primes [] (filter (fn [i] (not-any? #(= 0 (mod i %)) (range 2 i))) (drop 2 (range))))\n          \n  (take-while-n [n p s]\n  (if (or (not (seq s)) (and (p (first s)) (= n 1)))\n    nil\n    (cons (first s) (lazy-seq (take-while-n (if (p (first s)) (dec n) n) p (rest s))))))]\n    \n    (let [primes-memo (memoize primes) window (take-last 3 (take-while-n 3 #(>= % n) (primes-memo)))]\n      (cond (not (= (count window) 3)) nil\n            (not (= (second window) n)) false\n            (= (second window) (/ (+ (first window) (second (rest window))) 2)) true\n            :default false))\n)\n)", "user": "504f865ee4b0a02f9cffde90"}, {"problem": 116, "code": "(fn is-balanced?\n  [n]\n  (let [is-prime (fn [n]\n                   (loop [current 2]\n                     (cond\n                      (> current (unchecked-divide-int n 2)) true\n                      (zero? (rem n current)) false\n                      :else (recur (inc current)))))\n        wrap-primes-1110 (partition 3 1 (filter is-prime (range 2 1110)))\n        found (first (filter #(= n (second %)) wrap-primes-1110))]\n     (cond\n      (nil? found) false\n      :else (= n (-> (first found) (+ (last found)) (/ 2))))))", "user": "4fc524aae4b081705acca37e"}, {"problem": 116, "code": "(fn [num]\n  (letfn [(prime []\n            (letfn [(step [coll]\n                      (let [head (first coll)]\n                        (lazy-seq (cons head (step (filter #(pos? (mod % head)) coll))))))]\n              (step (range 2 Long/MAX_VALUE))))\n          (balanced-prime []\n            (map second (filter #(= (second %) (/ (+ (first %) (last %)) 2)) (partition 3 1 (prime)))))]\n    (= num (last (take-while #(<= % num) (balanced-prime))))))", "user": "561a1af6e4b053970a773b02"}, {"problem": 116, "code": "(let [primes (filter (fn [i] (not-any? #(= (rem i %) 0) (range 2 i))) \n                     (drop 2 (range)))]\n  (fn [n]\n    (loop [[[pp p np] & cpap-3s] (partition 3 1 primes)]\n      (case (compare n p)\n        -1 false\n        0 (= p (/ (+ pp np) 2))\n        1 (recur cpap-3s)))))", "user": "5339c105e4b0e30313ee6cae"}, {"problem": 116, "code": "(fn [p]\n  (if (every? #(not (zero? %))\n              (map #(rem p %) (range 2 p)))\n  (let [prime (filter \n             (fn [n] \n               (every? #(not (zero? %)) \n                       (map #(rem n %) (range 2 n))\n                       )) \n             (range 2 (* p 2)))]\n    (not (empty? (filter #(= (second %) p)\n                         (filter #(= (/ (+ (first %) (nth % 2)) 2)\n                                     (second %)) (partition 3 1 prime))))))\n    false))", "user": "541ef7e2e4b01498b1a71a92"}, {"problem": 116, "code": "#(if(loop[f 2] (if(and (integer? (/ % f)) (> % f)) false (if(> % f) (recur(inc f)) true)))  \n   \n   (if(= % (/ (+ (loop[a (- % 1)] (if(loop[f 2] (if(and (integer? (/ a f)) (> a f)) false (if(and (> a f)) (recur(inc f)) true))) a (recur(dec a)))) (loop[b (+ % 1)] (if(loop[f 2] (if(and (integer? (/ b f)) (> b f)) false (if(> b f) (recur(inc f)) true))) b (recur(inc b))))) 2))\n     (if(> 5 %)\n       false\n       true)\n     false)\n     \n   false)", "user": "5654e8ade4b0f9d632dd848e"}, {"problem": 116, "code": "(fn balanced-prime?\n  [n]\n  (let [primes\n        (cons 2 ((fn p [x]\n                   (lazy-seq\n                    (if (some #(zero? (mod x %)) (range 2 x))\n                      (p (+ 2 x))\n                      (cons x (p (+ 2 x)))))) 3))\n        triple (loop [rem-coll primes]\n                 (if (<= n (fnext rem-coll))\n                   (take 3 rem-coll)\n                   (recur (next rem-coll))))]\n    (= n (second triple) (/ (+ (first triple) (last triple)) 2))))", "user": "55a9e0fee4b0988bba2ad945"}, {"problem": 116, "code": "(fn [n]\n(let [primes (fn p []\n  (let [sv (fn seiv [xs]\n              (lazy-seq (cons (first xs)\n                              (seiv (for [a (rest xs)\n                                          :when (not (= 0 (mod a (first xs))))]\n                                          a))))\n            )]\n      (sv (iterate inc 2))))]\n  (not (empty?\n          (for [[x y z] (map vector \n                             (primes)\n                             (drop 1 (primes))\n                             (drop 2 (primes)))\n                 :while (< y (inc n))\n                 :when (=  n y (/ (+ x z) 2))\n                 ]\n                [x y z])))))", "user": "55c49394e4b0e31453f6499e"}, {"problem": 116, "code": "(fn [number]\n  (letfn [(dividable? [n d] (zero? (mod n d)))\n          (non-divisible-by-all? [n coll] ((complement some) #(dividable? n %) coll))\n          (next-prime [coll] (first (filter #(non-divisible-by-all? % coll) (iterate inc (inc (last coll))))))\n          (primes ([] (cons 2 (lazy-seq (primes [2])))) ([coll] (let [n (next-prime coll)] (cons n (lazy-seq (primes (conj coll n)))))))\n          (prime-sandwitches [] (partition 3 1 (primes)))\n          (solutions [] (map second (filter #(= (* 3 (second %)) (apply + %)) (prime-sandwitches))))]\n    (= (first (drop-while #(> number %) (solutions))) number)))", "user": "563a30d7e4b0bfe05bf117f9"}, {"problem": 116, "code": "(fn [x]\n              (letfn [(isprime [n]\n                        (every? #(not= 0 (mod n %)) (range 2 n)))]\n                (if (or (< x 5) (not (isprime x)))\n                  false\n                  (let [lower (loop [n (dec x)] (if (isprime n) n (recur (dec n))))\n                        upper (loop [n (inc x)] (if (isprime n) n (recur (inc n))))]\n                    (and (= (/ (+ lower upper) 2) x))))))", "user": "5654cb2de4b0f9d632dd848b"}, {"problem": 116, "code": "(fn sand [x]\n  (letfn [(crible ([] (crible 2 #{}))\n                  ([n prims]\n                   (lazy-seq \n                    (if (some #(= (rem n %) 0) prims)\n                      (crible (inc n) prims)\n                      (cons n (crible (inc n) (conj prims n)))))))]\n         (loop [s (crible), prev nil]\n           (let [[current nxt] (take 2 s)]\n             (cond\n               (and (not (nil? prev))\n                    (= current x)\n                    (= current (/ (+ prev nxt) 2))) true\n               (>= current x) false\n               :else (recur (rest s) current))))))", "user": "54ca93abe4b057c6fda3a264"}, {"problem": 116, "code": "(fn solution [x] \n  (let [sieve (fn sie [s]\n                (cons (first s)\n                      (lazy-seq (sie (filter #(not= 0 (mod % (first s)))\n                                             (rest s))))))]\n    (let [primes (take 200 (sieve (iterate inc 2)))]\n      (let [idx (.indexOf primes x)]\n        (if (= -1 idx)\n          false\n          (if (= x (/ (+ (nth primes (- idx 1) -1) \n                         (nth primes (+ idx 1) -1))\n                      2))\n            true\n            false))))))", "user": "52e17e66e4b09f7907dd1423"}, {"problem": 116, "code": "(fn [n]\n   (let [is-prime (fn [k] (every?  #(pos? (mod k %)) (range 2 k)))\n         next-prime (fn [k]  (first (filter is-prime (iterate inc (inc k)))) )\n         prev-prime (fn [k] (if (< k 3) 2 (first (filter is-prime (iterate dec (dec k))))))\n         avg (fn [a b] (/  (+ a b) 2))]\n    (and \n       (is-prime n)\n        (= n (avg (next-prime n) (prev-prime n))))))", "user": "5649615be4b0284900eef641"}, {"problem": 116, "code": "(fn [x]\n     (letfn [(sieve [[h & t]]\n               (lazy-seq (cons h (sieve (remove #(= 0 (mod % h)) t)))))]\n       (if (<= x 2) false\n           (let [primes (sieve (drop 2 (range)))\n                 [lower upper] (split-with (partial > x) primes)\n                 is-prime (= x (first upper))\n                 pmean (/ (+ (last lower) (second upper)) 2)]\n             (and is-prime (= x pmean))))))", "user": "55f09e7be4b06e875b46ce28"}, {"problem": 116, "code": "(fn balanced-prime? [n]\n  (let [sieve (fn f [s]\n                (cons (first s)\n                      (lazy-seq (f (filter #(not= 0 (mod % (first s)))\n                                           (rest s))))))\n        -balanced-prime? (fn f [[p1 p2 p3 :as s]]\n                           (cond (<= n 2) false\n                                 (< p1 n p3) (if-not (= n p2)\n                                               false\n                                               (if (= n (/ (+ p1 p3) 2))\n                                                 true\n                                                 false))\n                                 :else (f (next s))))]\n    (-balanced-prime? (sieve (iterate inc 2)))))", "user": "5666500ee4b0e91d5f5c566d"}, {"problem": 116, "code": "(let [ps (filter                                                                                                                                                          \n          (fn [x]\n            (every? #(pos? (mod x %)) (range 2 (inc (int (Math/sqrt x))))))\n          (iterate inc 2))]\n  (fn [n]\n    (let [head (take-while #(< % n) ps)\n          tail (drop-while #(< % n) ps)]\n      (and (pos? (count head))\n           (= n (first tail) (/ (+ (last head) (second tail)) 2))))))", "user": "54c5cc17e4b045293a27f624"}, {"problem": 116, "code": "(fn [n]\n  (let [primes ((fn sieve [[x & s]] (lazy-seq (cons x (sieve (filter #(not= 0 (mod % x)) s)))))\n                (lazy-seq (cons 2 (iterate #(+ 2 %) 3))))\n        balanced-primes ((fn bp [[l1 l2 l3 & _ :as l]] (if (= (+ l1 l3) (+ l2 l2))\n                                                          (lazy-seq (cons l2 (bp (rest l))))\n                                                          (recur (rest l))\n                                                         ))  primes)\n        in? (fn [m xs] (= m (first (drop-while #(< % m) xs))))]\n    (in? n balanced-primes)))", "user": "563dfc02e4b0da801c4e4662"}, {"problem": 116, "code": "(fn [n]\n  (if (<= n 2)\n    false\n    (let [prime-seq\n          (fn p [n storage] ;; sieve of Eratosthenes\n            (lazy-seq\n             (if-let [factors (storage n)] ;; with hash-map as factors storage\n               (let [next-factors\n                     (into {} (map #(vector (+ n %) (vector %)) factors))\n                     next-storage\n                     (merge-with concat (dissoc storage n) next-factors)]\n                 (p (inc n) next-storage))\n               (cons n (p (inc n) (assoc storage (* n n) (vector n)))))))\n          coll (partition 3 1 (prime-seq 2 {}))]\n      (loop [coll coll]\n        (let [[p1 p2 p3] (first coll)]\n          (cond\n            (> p2 n) false\n            (= p2 n) (= (/ (+ p1 p3) 2) p2)\n            :else    (recur (rest coll))))))))", "user": "5591cc56e4b0604b3f94d582"}, {"problem": 116, "code": "(fn [x]\n    (letfn [(prime? [n]  (and (> n 1)\n                              (every? #(not (zero? (rem n %))) (range 2 n))))\n            (balanced-prime? [n] (cond\n                                   (< n 3) false\n                                   (not (prime? n)) false\n                                   :default (let [prev-prime (first (filter prime? (range (dec n) 1 -1)))\n                                                  next-prime (first (filter #(and (prime? %) (> % n)) (range)))\n                                                  avg (/ (+ next-prime prev-prime) 2)]\n                                              (= avg n))))]\n      (balanced-prime? x)))", "user": "560e9a2de4b05f002753df52"}, {"problem": 116, "code": "(fn [n]\n  (let [is-prime? (fn [x] (= 0 (count (filter #(zero? (mod x %)) (range 2 x)))))\n        pre-prime (fn fpre-prime [x] (if (is-prime? x) x (fpre-prime (dec x))))\n        next-prime (fn fnext-prime [x] (if (is-prime? x) x (fnext-prime (inc x))))]\n    (and \n     (> n 2)\n     (is-prime? n)\n     (= n (/ (+ (pre-prime (dec n)) (next-prime (inc n))) 2)))))", "user": "5632d1b3e4b0bfe05bf117a9"}, {"problem": 116, "code": "(fn balanced-prime? [n]\n  (let [prime? (fn [x]\n                 (if (or (= x 1) (= x 2))\n                   true\n                   (not-any? #(zero? (mod x %)) (range 2 x))))\n        primes (filter prime? (drop 1 (range)))]\n    (boolean\n      (when (and (>= n 5)\n                 (prime? n))\n        (let [pp (last (take-while #(< % n) primes))\n              np (first (drop-while #(<= % n) primes))]\n          (= n (/ (+ pp np) 2)))))))", "user": "55d28b38e4b0e31453f64a58"}, {"problem": 116, "code": "(fn balanced-prime? [a]\n  (letfn [(balanced-triple? [[a b c]]\n                            (= b (/ (+ a c) 2)))\n          (divide [a b] (= 0 (mod b a)))\n          (divide-any [as b] (apply (some-fn #(divide % b)) as))\n          (get-next-prime [primes last-prime]\n                          (first (filter #(not (divide-any primes %)) (iterate inc (inc last-prime)))))\n          (generate-primes []\n                           (map\n                            first\n                            (iterate (fn [[last-prime primes]]\n                                       (let [next-prime (get-next-prime primes last-prime)]\n                                         [next-prime (cons next-prime primes)]))\n                                     [2 '(2)])))\n          (balanced-primes []\n                            (let [primes (generate-primes)\n                                  partitions (partition 3 1 primes)]\n                              (map \n                               (fn [[a b c]] b)\n                               (filter balanced-triple? partitions))))]\n    (= \n     (first \n      (drop-while #(< % a) (balanced-primes))) \n     a)))", "user": "5654e024e4b0f9d632dd848d"}, {"problem": 116, "code": "(fn [n]\n  (let [p? (fn p? [n]\n             (every? true?  \n                     (keep #(> (mod n %) 0)\n                           (range 2 n))))\n        l (first (filter p? (range (dec n) 1 -1)))\n        r (first (filter p? (drop (inc n) (range))))]\n    (true? (and (p? n) l r (= n (/ (+ l r) 2))))))", "user": "52bacfa8e4b07a9af57922d6"}, {"problem": 116, "code": "(fn [n]\n  (let [primes (filter (fn [x] (not-any? #(zero? (mod x %)) (range 2 x))) (iterate inc 2))]\n    (= n (last (take-while #(<= % n) (map second (filter (fn [[a b c]] (= b (/ (+ a c) 2))) (partition 3 1 primes))))))))", "user": "567695c2e4b05957ce8c6157"}, {"problem": 116, "code": "(fn [x]\n  (let [f (fn [n] (and (> n 1) (not (some zero? (map #(mod n %) (range 2 n))))))\n        g #(first (filter f %))\n        p (g (range (dec x) 0 -1))\n        n (g (drop (inc x) (range)))]\n    (and (f x) p n (= x (/ (+ p n) 2)))))", "user": "4faf97d8e4b081705acca258"}, {"problem": 116, "code": "(fn balanced-prime\n  [n]\n  (letfn [(prime? [m] (or (= m 2)\n                          (and (> m 2)\n                               (not-any? #(zero? (mod m %)) (range 2 (Math/sqrt (inc m)))))))]\n    (and (prime? n)\n         (let [neighbor-primes (map #(first (filter prime? %))\n                                    [(range (dec n) 1 -1) (drop (inc n) (range))])]\n           (and (not-any? nil? neighbor-primes)\n                (= n (/ (apply + neighbor-primes) 2)))))))", "user": "56897739e4b0dcc4269f407d"}, {"problem": 116, "code": "(fn [x]\n  (let [prime? (fn [p]\n                 (every? #(> (mod p %) 0) (range 2 p)))\n        find-prime (fn [xs]\n                     (some #(when (prime? %) %) xs))]\n    (and (> x 2) (prime? x) (= (* x 2) (+ (find-prime (range (dec x) 1 -1)) (find-prime (range (inc x) (* x 2))))))))", "user": "55ccdc6be4b0e31453f64a18"}, {"problem": 116, "code": "(fn lazy-prime [number]\n  (letfn [(prime? [n]\n      (let [upto (if (> n 5) (quot n 2) n)]\n        (not-any? zero? (map #(rem n %) (range 2 upto)))))]\n   (let [getPrimes (filter #(prime? %) (iterate inc 2))\n         s1 (take-while #(>= number %) getPrimes)]\n     (if (not= number (last s1))\n       false\n       (let [nextn (first (drop-while #(>= number %) getPrimes))\n             prevn (if (> (count s1) 1) (last (butlast s1)) 0)]\n         (if (= number (/ (+ prevn nextn) 2))\n           true\n           false))))))", "user": "567d18c9e4b05957ce8c61c4"}, {"problem": 116, "code": "(fn [x]\n  (letfn [(prime? [n]\n                  (cond (< n 2)\n                        false\n                        (= n 2)\n                        true\n                        :else\n                        (not-any? #(= 0 (mod n %)) (range 2 n))))\n          (get-pre-prime [n]\n                     (loop [i (dec n)]\n                       (cond (< i 2) nil\n                             (prime? i) i\n                             :else (recur (dec i)))))\n          (get-next-prime [n]\n                      (loop [i (inc n)]\n                        (if (prime? i)\n                          i\n                          (recur (inc i)))))]\n    (if (prime? x)\n      (let [pre-prime (get-pre-prime x)\n            next-prime (get-next-prime x)]\n        (if (nil? pre-prime)\n          false\n          (= (* 2 x) (+ pre-prime next-prime))))\n      false)))", "user": "56288ccae4b00e49c7cb47ea"}, {"problem": 116, "code": "(let\n    [prime-seq-gen\n     (fn prime-seq-gen\n       ;; Return a seq of primes.  Limit with take, e.g. (take 5 (prime-seq)) as it will consume large amounts of stack for large seqs produced.\n       []\n       ((fn prime-seq-i [sq]\n          (when (seq sq)\n            (lazy-seq\n             (cons (first sq)\n                   (prime-seq-i (remove #(zero? (mod % (first sq))) (rest sq)))))))\n        (cons 2 (iterate #(+ % 2) 3))))\n     prime-seq (prime-seq-gen)\n     get-near\n     (fn [pred s]\n       (if (pred (second s))\n         [(first s) (second s) (nth s 2)]\n         (recur pred (rest s))))]\n\n  (fn q4q116 [n]\n    (and\n     (not (contains? #{0 1 2} n))\n     (let [primes (get-near #(>= % n) prime-seq)\n           [l-prime n-prime u-prime] primes]\n       (and (= n n-prime)\n            (= (- n l-prime)\n               (- u-prime n)))))))", "user": "52213426e4b0e6a83c8925c4"}, {"problem": 116, "code": "(fn prime-sandwich [n]\n  (letfn\n      [(prime []\n         (filter (fn [n]\n                   (not-any? #(= 0 (mod n %)) (range 2 n))) (drop 2 (range))))\n       (balanced-prime []\n         (map second (filter #(= (second %) (/ (+ (first %) (last %)) 2))\n                             (partition 3 1 (prime)))))]\n    (= n\n       (last\n        (take-while #(<= % n)\n                    (balanced-prime))))))", "user": "5693a53ee4b0dcc4269f4106"}, {"problem": 116, "code": "(fn balanced-prime? [n]\n  (letfn [(prime? [n]\n            (let [start 2\n                  to (Math/sqrt n)]\n              (loop [i start]\n                (if (> i to)\n                  true\n                  (if (zero? (mod n i))\n                    false\n                    (recur (inc i)))))))\n          (prev-prime [n]\n            (if (prime? (dec n))\n              (dec n)\n              (recur (dec n))))\n          (next-prime [n]\n            (if (prime? (inc n))\n              (inc n)\n              (recur (inc n))))]\n    (if (or (< n 5) (not (prime? n)))\n      false\n      (let [prev (prev-prime n)\n            next- (next-prime n)]\n        (= (* 2 n) (+ prev next-)))))\n  )", "user": "5657fed1e4b0f9d632dd84ae"}, {"problem": 116, "code": "(fn balanced-prime? [c]\n  (let\n    [prime? (fn [n] (and (> n 1) (not-any? #(= % 0) (map #(rem n %) (range 2 n)))))\n     next-prime (first (filter prime? (map #(+ % (inc c)) (range))))\n     previous-prime (first (filter prime? (range (dec c) 1 -1)))]\n    (and (prime? c) (not (nil? previous-prime)) (= (- next-prime c) (- c previous-prime)))))", "user": "554680cbe4b0a04f7929953e"}, {"problem": 116, "code": "(fn [n]\n  (if (< n 4)\n    false\n    (let [prime? (fn [n]\n                   (or (= 2 n)\n                   (not-any? #(= 0 (mod n %)) (range 2 (inc (Math/sqrt n))))))]\n      (if (prime? n)\n        (let [next-prime (first (filter prime? (drop (inc n) (range))))\n              prev-prime (first (filter prime? (reverse (range 2 n))))]\n          (= n (/ (+ next-prime prev-prime) 2)))\n        false))))", "user": "553b0d95e4b09218d5f44fff"}, {"problem": 116, "code": "(fn sand [n]\n  (letfn [(prime? [n p] (every? #(pos? (rem n %)) p))\n          (next-prime\n            ([n p] (if (prime? n p) (conj p n) (recur (+ n 2) p)))\n            ([p] (next-prime (+ (peek p) 2) p)))\n          (gen-primes [p] (cons (last p) (lazy-seq (gen-primes (next-prime p)))))]\n    (and (> n 3)\n         (let [p (into [2] (take-while #(<= % n) (gen-primes [2 3])))\n               [r s] (subvec p (- (count p) 2))]\n           (and (= s n) (= s (/ (+ r (peek (next-prime p))) 2)))))))", "user": "56874171e4b0dcc4269f405c"}, {"problem": 116, "code": "(fn [n]\n  (letfn [(balanced? [a b c] (= (- b a) (- c b)))\n          (primes [l]\n            (let [a (first l)]\n              (lazy-seq (cons a\n                              (primes (filter\n                                        #(not= (mod % a) 0)\n                                        l))))))]\n    (let [P (primes (iterate inc 2))\n          bP (mapcat\n              #(if (balanced? %1 %2 %3) [%2] nil)\n              P\n              (drop 1 P)\n              (drop 2 P))]\n      (= (first (drop-while #(< % n) bP)) n))))", "user": "567b39b6e4b05957ce8c61a3"}, {"problem": 116, "code": "(fn [n]\n  (if (< n 5) false \n    (letfn [(prime? ([n] (if (< n 2) false (prime? n (- n 1)))) ([n m] (if (< m 2) true (if (zero? (rem n m)) false\t(prime? n (- m 1))))))]\n      (if-not (prime? n) false\n        (if (= n (/ (+ (first (filter prime? (iterate inc (inc n)))) (first (filter prime? (iterate dec (dec n))))) 2)) true false)))))", "user": "56bb9ccce4b0f26550335959"}, {"problem": 116, "code": "(fn[n]\n  (letfn [(p?[i] (every? #(> (mod i %) 0) (range 2 i)))\n    (i?[i]\n      (let [a (p? (- n i)) b (p? (+ n i))]\n        (cond\n          (= true a b) true\n          (= a b) (recur (inc i))\n          :else false)))]\n    (and (> n 2) (p? n) (i? 1))))", "user": "56824e1be4b0945ebc182a91"}, {"problem": 116, "code": "(fn [x](let [prime?(fn [y] (empty?(filter #(= 0 (mod y %))(range 2 y))))\n              primes (lazy-seq(filter #(prime? %)(iterate inc 2)))\n              np (first(drop-while #(<= % x) primes))\n              pp (if (<= x 2) -1 (last(take-while #(< % x) primes)))\n              xs (if (prime? x)[x pp np][0 1 1])\n              avg?(fn [[a b c]](if(= a (/ (+ b c) 2))true false))]\n\n         (avg? xs)))", "user": "566a3a26e4b0a866af689699"}, {"problem": 116, "code": "(fn [p]\n  (letfn [(prime? [n] (> 2 (count (filter #(= 0 (rem n %)) (range 1 n)))))\n\t\t  (equal-gap? [[a y b]] (= y (/ (+ a b) 2)))]\n    (if-not (prime? p) false\n\t  (let [primes (filter prime? (iterate inc 2))\n\t\t    gaps (take-last 3 (take (inc (count (take-while #(>= p %) primes))) primes))]\n        \t(if (not= 3 (count gaps))\n              false\n        \t  (equal-gap? gaps))))))", "user": "5578f292e4b05c286339e08f"}, {"problem": 116, "code": "(fn balanced-prime? [n] (let [prime-seq (fn prime-seq [trial accum] (let [test (if (not-any? #(zero? (mod trial %)) accum) trial nil)]\n                                                                (lazy-seq (if (nil? test) (prime-seq (inc trial) accum)\n                                                                                          (cons test (prime-seq (inc trial) (cons test accum)))\n                                                                                          ))))]\n                            (#(= n (second %) (/ (+ (first %) (nth % 2)) 2)) (first (filter #(<= n (second %))\n                                         (let [inf-prime-seq (prime-seq 2 [])]\n                                           (map list inf-prime-seq (rest inf-prime-seq) (drop 2 inf-prime-seq))))))))", "user": "56baab13e4b0f26550335948"}, {"problem": 116, "code": "(fn p [n]\n (let [prime (fn [x] (not (some #(zero? (mod x %)) (range 2 x))))\n       primes ((fn sieve [s] \n                   (cons (first s) (lazy-seq \n                                     (sieve (filter \n                                              #(not= 0 (mod % (first s))) \n                                              (rest s)))))) \n                   (iterate inc 2))]\n (and (> n 3) (prime n) \n   (= n (some\n    #(if (= (second %) n)\n        (/ (+ (first %) (last %) ) 2))\n\n (partition 3 1 primes))))))", "user": "56bca51ae4b0f26550335963"}, {"problem": 116, "code": "(fn balance-prime [n]\n  (letfn [(prime? [n] (if (< n 2)\n                        false\n                        (every? #(< 0 (mod n %))\n                                (range 2 (inc (int (Math/sqrt n)))))))]\n    (if (prime? n)\n      (loop [front (dec n), back (inc n)]\n        (cond\n         (and (prime? front) (prime? back)) true\n         (or (prime? front) (prime? back)) false\n         :else (recur (dec front) (inc back))))\n      false)))", "user": "567e418fe4b0feffd0d18eb1"}, {"problem": 116, "code": "(fn [n]\n  (let[prime? (fn [n]\n                (if (< n 2)\n                  false\n                  (every? #(not= 0 (mod n %)) (range 2 n))))\n       primes (filter prime? (range))\n       [a b c] (first (drop-while #(< (second %) n) (partition 3 1 primes)))]\n    (and (= n b) (= n (/ (+ a c) 2)))))", "user": "56ae214ce4b03c432f18735a"}, {"problem": 116, "code": "(fn ps? [n]\n  (let [p? (fn [x] (empty? (drop-while #(not= (mod x %) 0) (range 2 (inc (Math/sqrt x))))))]\n     (and (> n 3)\n          (p? n)\n          (= n (/ (+ (first (drop-while (complement p?) (iterate dec (dec n))))\n                     (first (drop-while (complement p?) (iterate inc (inc n))))) 2)))))", "user": "56baa68ce4b0f26550335947"}, {"problem": 116, "code": "(fn [x] \n    (let [sieve (fn sieve [s] \n                 (lazy-seq \n                  (cons (first s) \n                        (sieve \n                         (filter #(< 0 (mod % (first s))) \n                                 (next s))))))\n          primes (take-while (complement nil?) (sieve (range 2 x)))\n          prime? (fn [n] (or (some #(= % n) primes) (not-any? #(= 0 (mod n %)) primes))) \n          next-smallest-prime (first (filter prime? (rest (iterate dec x))))\n          next-largest-prime (first (filter prime? (rest (iterate inc x))))]\n  (and (< 2 x) (prime? x) (= (* 2 x) (+ next-smallest-prime next-largest-prime)))))", "user": "56b86e64e4b0f26550335924"}, {"problem": 116, "code": "(fn isBalancedPrimeX[n]\n\t(letfn [\n\t\t\t(multiple? [n m] (zero? (mod m n)))\n\t\t\t(isPrime[n]\n\t\t\t\t(and \n\t\t\t\t\t(> n 1)\n\t\t\t\t\t(not-any? #(multiple? % n) (range 2 n))\n\t\t\t\t)\n\t\t\t)\n\t\t\t(findPrimeBefore[n]\n\t\t\t\t(first (filter isPrime (range (dec n) 2 -1)))\n\t\t\t)\n\n\t\t\t(findPrimeAfter[n]\n\t\t\t\t(first (filter isPrime (drop (inc n) (range))))\n\t\t\t)\n\t\t]\n\t\t(and\n\t\t\t(> n 3)\n\t\t\t(isPrime n)\n\t\t\t(= n(quot (+ (findPrimeBefore n)(findPrimeAfter n))  2))\n\t\t)\n\t)\n)", "user": "568820e8e4b0dcc4269f4067"}, {"problem": 116, "code": "(fn [x] (let [p (fn [n] (= (count (drop-while #(not= (mod n %) 0) (range 2 (inc n)))) 1)) g (fn f [y d] (if (= 1 y) 0 (if (p y) y (f (d y) d))))] (if (p x) (= (* x 2) (+ (g (inc x) inc) (g (dec x) dec))) false)))", "user": "56c08696e4b060a8e693e3aa"}, {"problem": 116, "code": "(fn [a] (let [getPrimeIndex (fn [n]\n                                           (.indexOf (take 230 ((fn [num] (drop-last (filter (complement false?) (reduce (fn [arr number] (if (= true (get arr number)) (assoc arr number (+ number 2)) arr))\n                                                                                                                         (reduce (fn [array n] (if (= true (get array (- n 2))) (reduce #(assoc %1 (- %2 2) false) array (range (+ n n) num n)) array))\n                                                                                                                                 (into [] (repeat (- num 1) true)) (range 2 (* 1/10 num))) (range 0 num))))) 1150)) n))\n                           primes (take 230 ((fn [num] (drop-last (filter (complement false?) (reduce (fn [arr number] (if (= true (get arr number)) (assoc arr number (+ number 2)) arr))\n                                                                                                      (reduce (fn [array n] (if (= true (get array (- n 2))) (reduce #(assoc %1 (- %2 2) false) array (range (+ n n) num n)) array))\n                                                                                                              (into [] (repeat (- num 1) true)) (range 2 (* 1/10 num))) (range 0 num))))) 1150))]\n                       (if (= a (/ (+ (nth primes (+ -1 (getPrimeIndex a)) -1) (nth primes (+ 1 (getPrimeIndex a)) -1)) 2))\n                         true\n                         false)))", "user": "567f988be4b0feffd0d18ebe"}, {"problem": 116, "code": "(fn [n] (letfn [\n (primes [] ((fn sieve [s]\n  (lazy-seq (cons (first s) (sieve (filter #(< 0 (mod % (first s)))\n                                 (rest s)))))) (iterate inc 2)))\n  (filter+ [p x] (loop [x x, r []]\n            (cond (empty? x) r\n                  (p (first x)) (recur (next x) (conj r (first x)))\n                  :else (conj r (first x)))))\n]\n(if (< n 5) false\n(let [triplet (take 3 (reverse (filter+ #(<= % n) (primes))))]\n (and (= n (second triplet)) (= n (/ (+ (first triplet) (last triplet)) 2)))\n))))", "user": "4fd11a93e4b04c3a95aa040a"}, {"problem": 116, "code": "(fn balance-prime [x]\n  (let [is-prime? (fn [n] (and (> n 1) (not (some #(zero? (rem n %)) (range 2 (dec n))))))\n        prime-seq (filter is-prime? (range))]\n    (if (not (is-prime? x)) false\n      (let [[l r] (split-with #(< % x) prime-seq)\n            left  (or (last l) 0)\n            right (second r)]\n        (= (* x 2) (+ left right))))))", "user": "562268dce4b03f08ee9a9224"}, {"problem": 116, "code": "(fn bp [x]\n  (letfn [(is-prime [x]\n            (condp = x\n              1 nil\n              2 2\n              (when (not-any? #(= 0 (mod x %)) (range 2 (inc (quot x 2))))\n                x)))]\n    (cond\n      (<= x 2) false\n      (not (is-prime x)) false\n      :else (let [lp (some is-prime (range (dec x) 1 -1))\n                  rp (some is-prime (drop (inc x) (range)))]\n              (= (/ (+ lp rp) 2) x)))))", "user": "569dd6e8e4b0542e1f8d1480"}, {"problem": 116, "code": "(fn prime-sandwitch [x]\n   (let [primes ((fn gen-prime [prevs try]\n                   (if (not-any? zero? (map #(mod try %) prevs))\n                     (lazy-seq (cons try (gen-prime (conj prevs try) (inc try))))\n                     (gen-prime prevs (inc try)))\n\n                   ) [] 2)]\n     (loop [p primes\n            scanned []]\n       ;; (println 'scanned scanned)\n       (cond (and (>= (count scanned) 2)\n                  (= (last scanned) x)\n                  (= (+ (last (butlast scanned)) (first p)) (* 2 x))) true\n             (and (last scanned)\n                  (> (last scanned) x)) false\n             :else (recur (rest p) (conj scanned (first p)))\n             )\n\n       )\n     ))", "user": "56f7ecdfe4b08e7d20b96834"}, {"problem": 116, "code": "(fn [n]\n   (let  [bp (->>\n               (range)\n               (drop 2)\n               (filter (fn [x] (every? #(< 0 (mod x %)) (range 2 x))))\n               (partition 3 1)\n               (filter (fn [[a b c]] (= (+ a c) (* 2 b))))\n               (map second))]\n     (= (last (take-while #(<= % n) bp)) n)))", "user": "56fbf83de4b07572ad1a88da"}, {"problem": 116, "code": "(fn [x] (contains? #{5 53 157 173 211 257 263 373 563 593 607 653 733 947 977 1103} x))", "user": "5292feb4e4b0239c8a67af39"}, {"problem": 116, "code": "(fn [n]\n  (letfn [(prime? [n] (not-any? #(= 0 (mod n %)) (range 2 n)))\n          (primeGen [n] (take n (filter prime? (iterate inc 2))))] \n    (and \n      (> n 2) ; The first prime '2' cannot be balanced because there is no prime before it.\n      (prime? n) \n      (let [s (primeGen n)\n            i (.indexOf s n)\n            before (nth s (dec i))\n            after (nth s (inc i))] \n        (= n (/ (+ before after) 2)) ))))", "user": "550e52dbe4b06e50f9beb165"}, {"problem": 116, "code": "(fn [n]\n  (let [prime? (fn [x]\n                 (nil?\n                  (some zero?\n                         (map mod (repeat x) (range 2 x)))))\n        balanced? (fn [[a b c]] (= b (/ (+ a c) 2)))]\n    \t(if-not (and (> n 3) (prime? n)) ; 3 isn't preceded by a real prime\n          false\n          (balanced?\n           (first (drop-while\n                   (fn [[x y z]] (not= n y))\n                   (partition 3 1 (filter prime? (range)))))))))", "user": "56481722e4b0284900eef628"}, {"problem": 116, "code": "(fn [n]\n  (let [primes (cons 2 (filter\n                        (fn [i] (not-any? #(= 0 (mod i %)) (range 2 i)))\n                        (iterate #(+ 2 %) 3)))\n        [f s] ((juxt take-while drop-while) #(<= % n) primes)\n        [a b c :as l] (concat (take-last 2 f) (list (first s)))]\n    (if (and a b c (some #(= n %) l))\n      (if (= b (/ (+ a c) 2))\n        true\n        false)\n      false)))", "user": "57035ccfe4b08d47c97781ef"}, {"problem": 116, "code": "(fn [n]\n  (let [f (fn seive [xs]\n            (cons (first xs)\n                  (lazy-seq (seive (filter #(not (= 0 (mod % (first xs)))) (rest xs))))))\n        [l r] (split-with #(< % n) (f (iterate inc 2)))]\n    (and (> n 2)\n         (= (first r) n)\n         (= n (/ (+ (last l) (second r)) 2)))))", "user": "549eb44fe4b0f3d1d8e70fa6"}, {"problem": 116, "code": "(fn [p]\n  (letfn [(primes []\n            (filter (fn [test-me]\n                      (every? #(not (zero? (rem test-me %)))\n                              (range 2 test-me)))\n                    (drop 2 (range))))]\n    (let [[p1 p0 & _] (reverse (take-while #(<= % p) (primes)))\n          p2 (first (drop-while #(<= % p) (primes)))]\n      (boolean (and p0 (= p1 p) (== p1 (/ (+ p0 p2) 2)))))))", "user": "5712854ce4b07c98581c3a89"}, {"problem": 116, "code": "#(letfn [(prime [n] (not= 0 ((fn [x] (apply min (map mod (repeat x) (range 2 x)))) n)))] \n         (if (and (> % 4) (prime %)) \n             (loop [i 2] \n                   (if (or (prime (-  % i)) (prime (+ % i))) \n                       (and (prime (-  % i)) (prime (+ % i))) \n                     (recur (+ i 2)))\n                   )  \n           false))", "user": "5686b7c7e4b0dcc4269f4057"}, {"problem": 116, "code": "(fn [n]\n  (letfn [(prime? [n] (and (> n 1) (->> (range 2 (inc (quot n 2)))\n                                        (not-any? #(zero? (mod n %))))))\n          (find-prime [n step] (->> (+ step n)\n                                    (iterate (partial + step))\n                                    (filter prime?)\n                                    (first)\n                                    ((fnil + step n) step)))]\n    (and\n      (> n 2)\n      (prime? n)\n      (= n (/ (+ (find-prime n 1) (find-prime n -1)) 2)))))", "user": "56d68cbae4b0ea9b8538f7cd"}, {"problem": 116, "code": "(fn [n]\n  (if (< n 3)\n   false\n   (let [primes (fn [n]\n                  (let [a-seq (range 2 (* 2 n))]\n                    (loop [lseq a-seq acc []]\n                      (if (empty? lseq)\n                        acc\n                        (recur\n                          (remove\n                            #(zero? (rem % (first lseq)))\n                            (rest lseq))\n                          (conj acc (first lseq)))))))\n         primes-vec (primes n)\n         found-index (.indexOf primes-vec n)]\n     (if (= -1 found-index)\n       false\n       (= n (/ (+ (nth primes-vec (dec found-index))\n                  (nth primes-vec (inc found-index)))\n               2))))))", "user": "56cb4d06e4b0ea9b8538f72e"}, {"problem": 116, "code": "(fn [n]\n    (letfn [(prime? [n] (and (> n 1)\n                                (not-any? #(= (mod n %) 0)\n                                          (take-while (partial not= 1) (iterate dec (dec n))))))\n            (first-prime [ns] (first (filter prime? ns)))]\n      (and (> n 3) (prime? n)\n           (= n (/ (+ (first-prime (iterate dec (dec n))) (first-prime (iterate inc (inc n))))\n                   2)))))", "user": "4f57c913e4b0a7574ea7183f"}, {"problem": 116, "code": "(letfn [(divisible-by [previous i]\n            (let [sqrt-i (Math/sqrt i)]\n              (some #(zero? (rem i %))\n                    (take-while #(<= % sqrt-i) previous))))\n          (rec [previous nxt-seq]\n            (let [skip-non-primes (drop-while #(divisible-by previous %) nxt-seq)\n                  nxt-prime (first skip-non-primes)]\n              (lazy-seq\n               (cons nxt-prime\n                     (rec (conj previous nxt-prime)\n                          (rest skip-non-primes))))))]\n    (let [primes (rec [] (drop 2 (range)))\n          balanced-primes (map second\n                               (filter (fn [[a b c]] (= b (/ (+ a c) 2)))\n                                       (partition 3 1 primes)))]\n      (fn [tst]\n        (= tst (last (take-while #(<= % tst) balanced-primes))))))", "user": "5275f7a2e4b03e8d9a4a74d0"}, {"problem": 116, "code": "(fn balanced-prime? [n]\n  (let [prime? (fn [x] (not-any? zero? (map #(mod x %) (range 2 x))))]      \n    (if (or (not (prime? n))\n            (<= n 3))\n      false\n      (let [pprime (first (filter prime? (rest (range n 2 -2))))\n            nprime (first (filter prime? (rest (iterate (partial + 2) n))))]\n        (= n (/ (+ nprime pprime) 2))))))", "user": "571d063ee4b0145328a76272"}, {"problem": 116, "code": "(let [prime? (fn [n]\n                 (let [m (->> n Math/sqrt long)\n                       multiple? (fn [x]\n                                   (zero? (mod n x)))]\n                   (if (< n 2)\n                     false\n                     (->> (range 2 (inc m))\n                          (not-any? multiple?)))))\n        primes (filter prime? (range))\n        mean (fn [vs]\n               (/ (apply +' vs) (count vs)))\n        f (fn [n]\n            (let [ps (take-while #(<= % n) primes)]\n              (and (= n (last ps))\n                   (->> primes\n                        (drop (- (count ps) 2))\n                        (take 3)\n                        mean\n                        (= n)))))]\n    f)", "user": "53684a2fe4b0243289761e8c"}, {"problem": 116, "code": "(fn balanced-prime?\n  [n]\n  (let [prime? (fn [x] (= (count (filter #(zero? (mod x %)) (range 2 x))) 0))\n        pre-prim (fn inner-pre [x] (if (prime? x) x (inner-pre (dec x))))\n        next-prim (fn inner-next [x] (if (prime? x) x (inner-next (inc x))))]\n    (and\n      (> n 2)\n      (prime? n)\n      (= n (/ (+ (pre-prim (dec n)) (next-prim (inc n))) 2)))))", "user": "56ab7578e4b03c432f18733d"}, {"problem": 116, "code": "(fn [n]\n  (letfn [(primes []\n             (letfn [(reinsert [table q prime]\n                       (loop [x (+ q (* 2 prime))]\n                         (if (table x) \n                           (recur (+ x (* 2 prime)))\n                           (assoc! (dissoc! table q) x prime))))\n                     (step [table d]\n                       (if-let [prime (get table d)]\n                         (recur (reinsert table  d prime) (+ 2 d))\n                         (lazy-seq (cons d (step (assoc! table (* d d) d)\n                                                 (+ 2 d))))))]\n               (cons 2 (step (transient {}) 3))))]\n    (let [p3 (first (filter #(<= n (second %)) (partition 3 1 (primes))))]\n      (and  (= n (second p3))\n            (= n (/ (reduce + p3) 3))))))", "user": "56102f50e4b05f002753df6b"}, {"problem": 116, "code": "(fn [n]\n  (letfn [(prime? [n] (and (not (#{0 1} n)) (not (some #(= (rem n %) 0) (range 2 n)))))\n          (search-for-prime [start step-f] (some #(and (prime? %) %) (iterate step-f start)))\n          (next-prime [n] (search-for-prime (inc n) inc))\n          (prev-prime [n] (search-for-prime (dec n) dec))\n          (average [x y] (/ (+ x y) 2))]\n    (and (prime? n) (= n (average (next-prime n) (prev-prime n))))))", "user": "57002b81e4b08d47c97781c7"}, {"problem": 116, "code": "(fn sand [n]\n  (letfn [(prime? [n p] (every? #(pos? (rem n %)) p))\n          (next-prime\n            ([n p] (if (prime? n p) (conj p n) (recur (+ n 2) p)))\n            ([p] (next-prime (+ (peek p) 2) p)))\n          (gen-primes [p] (cons (last p) (lazy-seq (gen-primes (next-prime p)))))]\n    (and (> n 3)\n         (let [p (into [2] (take-while #(<= % n) (gen-primes [2 3])))\n               [r s] (subvec p (- (count p) 2))]\n           (and (= s n) (= s (/ (+ r (peek (next-prime p))) 2)))))))", "user": "574af03ce4b02ea114799202"}, {"problem": 116, "code": "(fn prime-sandwich? [n]\n  (letfn [(prime? [n]\n            (and\n              (> n 1)\n              (not-any? #(zero? (mod n %)) (range 2 n))))]\n    (and\n      (> n 2)\n      (prime? n)\n      (let [primes (lazy-seq (filter prime? (range)))\n            primes-before (take-while #(<= % n) primes)\n            prime-before (last (butlast primes-before))\n            prime-after (first (drop (count primes-before) primes))]\n         (= n (/ (+ prime-before prime-after) 2))))))", "user": "56d4b22de4b0ea9b8538f7bb"}, {"problem": 116, "code": "(fn [x]\n  (letfn [(update-iterators-map [x iterators iterators-map]\n            (-> (reduce (fn [ret iterator]\n                          (update-in ret [(+ x iterator)] (fnil conj []) iterator))\n                        iterators-map\n                        iterators)\n                (dissoc x)))\n          (next-prime [{:keys [x iterators-map]}]\n            (let [x (inc x)]\n              (if-let [iterators (iterators-map x)]\n                (recur {:x x :iterators-map (update-iterators-map\n                                              x iterators iterators-map)})\n                {:x x :iterators-map (assoc iterators-map (* x x) [x])})))]\n    (let [primes (->> (iterate next-prime {:x 2 :iterators-map {4 [2]}})\n                      (split-with #(>= x (:x %))))\n          prv (-> primes first butlast last :x)\n          crr (-> primes first last :x)\n          nxt (-> primes last first :x)]\n      (and (= x crr) prv (= (- crr prv) (- nxt crr))))))", "user": "56dc3bdfe4b0ea9b8538f819"}, {"problem": 116, "code": "(fn prime-sandwich? [n]\n  (letfn [(non-prime? [x] (some\n                            #(zero? (mod x %))\n                            (range 2 x)))\n          (primes [] (remove non-prime? (iterate inc 2)))\n          (mean- [a b] (/ (+ a b) 2))]\n    (if (#{0 1 2} n)\n      false\n      (let [[prv [match nxt]] (split-with (partial > n) (primes))]\n        (= n match (mean- (last prv) nxt))))))", "user": "572ea970e4b0cd1946bd0f89"}, {"problem": 116, "code": "(fn myfn [number]\n  (if (> 5 number)\n  false\n  (let [mod-pow (fn mod-pow [a b c]\n        (loop [ans 1\n               dega a\n               nowb b]\n          (if (zero? nowb) ans\n            (if (even? nowb) (recur ans (mod (* dega dega) c) (quot nowb 2))\n              (recur (mod (* ans dega) c) (mod (* dega dega) c) (quot nowb 2))\n              ))))\n       prime? (fn [x]\n       (every? true? \n        (map (fn [_] (= 1 \n         \t \t(mod-pow (inc (rand-int (dec x))) (dec x) x)))\n             (range 10))))\n        primelist (filter prime? (range 2 (* 2 number)))\n        get-index (fn [val arr] \n          (count (take-while #(not (= val %)) arr)))\n        ]\n    (if (prime? number)\n    (let [index (get-index number primelist)] \n    (= (* 2 number) (+ \n      (nth primelist (dec index))\n      (nth primelist (inc index)))))\n    false))))", "user": "5744723ae4b009280f9f2b3a"}, {"problem": 116, "code": "(let [is-prime? (fn [x] (not-any? #(= 0 (mod x %)) (range 2 (inc (Math/sqrt x)))))\n      prime-range (filter is-prime? (drop 2 (range)))]\n  (fn is-balanced-prime? [x]\n    (if\n      (<= x 2)\n      false\n      (let [[left right] (split-with #(< % x) prime-range)\n            before (or (last left) 0)\n            after (second right)]\n        (and (is-prime? x) (= x (/ (+ before after) 2)))))))", "user": "56ac81ace4b03c432f187347"}, {"problem": 116, "code": "(fn [x]\n  (let [prime? (fn [i] (empty? (filter #(= 0 (rem i %)) (range 2 (inc (int (Math/sqrt i)))))))\n        lowerprime (fn [i]\n                     (if (prime? i)\n                       i\n                       (recur (dec i))))\n        upperprime (fn [i]\n                     (if (prime? i)\n                       i\n                       (recur (inc i))))\n        primemean (/ (+ (lowerprime (dec x)) (upperprime (inc x))) 2)]\n    (if (and (prime? x) (>= x 3))\n      (= x primemean)\n      false)))", "user": "5705e404e4b0b0fb43fd0676"}, {"problem": 116, "code": "(fn prime-sandwich [n]\n  (letfn [(isprime? [n]\n            (if (= n 1)\n              false\n              (if (= (mod n 2) 0) ;;even n\n                (if (= 2 n)\n                  true\n                  false)\n                (let [l2 (map #(= 0 (mod n %)) (range 2 (inc (Math/sqrt n))))\n                      l3 (reduce #(or %1 %2) false l2) \n                      ]\n                  (not l3)))))\n\n          (next-prime [n]\n            (loop [n n]\n              (if (isprime? n)\n                n\n                (recur (inc n)))))\n          \n          (prev-prime [n]\n            (loop [n n]\n              (if (<= n 0)\n                0\n                (if (isprime? n)\n                  n\n                  (recur (dec n))))))\n          ] \n    (if (= n 3)\n      false\n      (if (isprime? n) \n        (let [p2 (next-prime (inc n))\n              p1 (prev-prime (dec n))\n              ]\n          (println n p1 p2)\n          (= n (int (/ (+ p1 p2) 2))))\n        false))))", "user": "574f1c24e4b02ea114799255"}, {"problem": 116, "code": "(fn ps? [n]\n  (let [ps [2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 101 103 107 109 113 127 131 137 139 149 151 157 163 167 173 179 181 191 193 197 199 211 223 227 229 233 239 241 251 257 263 269 271 277 281 283 293 307 311 313 317 331 337 347 349 353 359 367 373 379 383 389 397 401 409 419 421 431 433 439 443 449 457 461 463 467 479 487 491 499 503 509 521 523 541 547 557 563 569 571 577 587 593 599 601 607 613 617 619 631 641 643 647 653 659 661 673 677 683 691 701 709 719 727 733 739 743 751 757 761 769 773 787 797 809 811 821 823 827 829 839 853 857 859 863 877 881 883 887 907 911 919 929 937 941 947 953 967 971 977 983 991 997 1009 1013 1019 1021 1031 1033 1039 1049 1051 1061 1063 1069 1087 1091 1093 1097 1103 1109 1117 1123 1129]\n        i (remove nil?\n                  (map-indexed #(if (= n %2) %1 nil)\n                               ps))]\n    (if-let [i (first i)]\n      (if (> i 0)\n        (= n (/ (+ (ps (inc i))\n                   (ps (dec i)))\n                2))\n        false)\n      false)))", "user": "57533bc1e4b02ea1147992a6"}, {"problem": 116, "code": "(fn balancedPrime? [p]\n  (letfn [(isPrime? [x] (not-any? (fn isDivisor? [d] (zero? (mod x d))) (range 2 x)))\n          (nearbyPrime [x f] (some #(when (isPrime? %) %) (iterate f (f x)))) ;Returns first prime in sequence f(x), f(f(x)), ...\n          ]\n    (and\n     (> p 2)\n     (isPrime? p)\n     (= p (/ (+ (nearbyPrime p inc) (nearbyPrime p dec)) 2))\n     )\n    \n    )\n  )", "user": "575ef4b6e4b08062f99a4e78"}, {"problem": 116, "code": "(fn [n] \n  (letfn [\n    (prime? [n]\n      (not (some #(zero? (rem n %)) (range 2 n))))\n\n    (s-prime [s]\n      (first (filter prime? s)))]\n\n      (and\n        (prime? n)\n        (let [nx (s-prime (drop (inc n) (range)))\n              pr (s-prime (range (dec n) 2 -1))]\n          (and pr (= n (quot (+ pr nx) 2)))))))", "user": "574dfcb8e4b02ea11479923a"}, {"problem": 116, "code": "(fn [n]\n  (letfn [(divisible-by? [x nums] (some #(= 0 (rem x %)) nums))\n          (primes\n            ([] (primes 2 []))\n            ([x nums]\n             (lazy-seq\n              (loop [x x\n                     nums nums]\n                (if (divisible-by? x nums)\n                  (recur (inc x) nums)\n                  (cons x (primes (inc x) (conj nums x))))))))\n          (mean [a b] (/ (+ a b) 2))]\n    (let [[lhs-list [mid & [rhs & _]]] (split-with #(< % n) (primes))\n          lhs (last lhs-list)]\n      (prn lhs mid rhs)\n      (and lhs (= mid n (mean lhs rhs))))))", "user": "5764457ae4b0994c1922fbf3"}, {"problem": 116, "code": "(fn balancePrime [c] (letfn [\n                     (isPrime? [x]\n                       (if (<= x 1)\n                         false\n                         (if (<= x 3) true\n                                      (if  (or (= (rem x 2) 0) (= (rem x 3) 0))\n                                        false\n                                        (loop [i 5]\n                                          (if (> (* i i) x)\n                                            true\n                                            (if (or (= (rem x i) 0) (= (rem x (+ i 2)) 0))\n                                              false\n                                              (recur (+ i 6))\n                                              )))))))\n                           (nextPrimeF [f n] (first (filter isPrime? (iterate f n))))\n                           (nextPrime [num] (nextPrimeF inc  (inc num)))\n                           (prevPrime [num] (nextPrimeF dec  (dec num)))\n\n\n ]  (and (> c 4) (isPrime? c) (= c (/ (+ (prevPrime c) (nextPrime c)) 2) ))))", "user": "56427910e4b08d4f616f5f19"}, {"problem": 116, "code": "(fn prime-balance [cnt]\n  (let [prime? (fn [n]\n                 (not (some #(zero? (mod n %))\n                            (range 2 (dec n)))))\n        primes (filter prime? (iterate inc 1))]\n         (if (> 3 cnt)\n           false\n           (and (prime? cnt) (= cnt \n                         (/ \n                          (+ \n                           (last(take-while #(< % cnt) primes)) \n                           (second(drop-while #(< % cnt) primes))) \n                          2)))\n           )\n    )\n  )", "user": "5731e36be4b0cd1946bd0fc9"}, {"problem": 116, "code": "(fn [n]\n  (let [primes \n        (lazy-seq (filter (fn [x] (not (some #(zero? (mod x %)) (range 2 x))));refer to problem #67 prime numbers \n                 (iterate inc 2)))\n        pc \n        (fn [x] (take 3 (drop x primes)))]\n    (loop [s 0]\n      (cond\n       (> (second (pc s)) n) false\n       (= (second (pc s)) n) (= n (/ (+ (first (pc s)) (last (pc s))) 2))\n       :else (recur (inc s))\n       ))))", "user": "574abbfbe4b02ea114799200"}, {"problem": 116, "code": "(fn [p]\n  (letfn [(prime? [x] (and (not (#{0 1} x))\n                           (empty? (filter #(= (mod x %) 0) \n                                           (range 2 x)))))\n          (previous-prime [x] (or (first (filter prime? (reverse (range x)))) 0))\n          (next-prime [x] (or (first (filter prime? (iterate inc (inc x)))) 0))]\n    (and (prime? p)\n         (= p (/ (+ (previous-prime p)\n                    (next-prime p))\n                 2)))))", "user": "50e90813e4b033b0e80d11e7"}, {"problem": 116, "code": "(fn f [n]\n  (let [prime? (fn [n] (when (> n 1) (not (some integer? (map #(/ n %) (range 2 n))))))\n        lprime (fn [n]\n                 (cond (= n 1) nil\n                       (prime? n) n\n                       :else (recur (dec n))))\n        rprime (fn [n]\n                 (if (prime? n)\n                   n\n                   (recur (inc n))))]\n    (if (prime? n)\n      (if-let [lp (lprime (dec n))]\n        (= n (/ (+ lp (rprime (inc n))) 2))\n        false)\n      false)))", "user": "56795deae4b05957ce8c6187"}, {"problem": 116, "code": "(fn ps? [n]\n  (let [ps [2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 101 103 107 109 113 127 131 137 139 149 151 157 163 167 173 179 181 191 193 197 199 211 223 227 229 233 239 241 251 257 263 269 271 277 281 283 293 307 311 313 317 331 337 347 349 353 359 367 373 379 383 389 397 401 409 419 421 431 433 439 443 449 457 461 463 467 479 487 491 499 503 509 521 523 541 547 557 563 569 571 577 587 593 599 601 607 613 617 619 631 641 643 647 653 659 661 673 677 683 691 701 709 719 727 733 739 743 751 757 761 769 773 787 797 809 811 821 823 827 829 839 853 857 859 863 877 881 883 887 907 911 919 929 937 941 947 953 967 971 977 983 991 997 1009 1013 1019 1021 1031 1033 1039 1049 1051 1061 1063 1069 1087 1091 1093 1097 1103 1109 1117 1123 1129]\n        i (remove nil?\n                  (map-indexed #(if (= n %2) %1 nil)\n                               ps))]\n    (if-let [i (first i)]\n      (if (> i 0)\n        (= n (/ (+ (ps (inc i))\n                   (ps (dec i)))\n                2))\n        false)\n      false)))", "user": "5798205ce4b039eba2ecb10e"}, {"problem": 116, "code": "(fn [n]\n  (letfn [(prime? [x]\n                 (cond\n                   (< x 2) false\n                   (= x 2) true\n                   :else (not-any? #(zero? (rem x %))  (range 2 (inc (Math/sqrt x))))))\n          (seek [x f]\n                (loop [x (f x)]\n                  (if (prime? x) x\n                       (recur (f x)))))]\n    (and (> n 2) (prime? n) (= n (/ (+ (seek n dec) (seek n inc)) 2)))))", "user": "57642916e4b0994c1922fbee"}, {"problem": 116, "code": "(let [divisible? (fn divisible? [i factors]\n                      (some #(= 0 (rem i %))\n                            (take-while #(<= % (Math/sqrt i)) factors)))\n         primes     (->> (range)\n                         (drop 2)\n                         (reductions (fn primer [primes i]\n                                       (if (divisible? i primes)\n                                         primes\n                                         (conj primes i))) [])\n                         (partition 2 1)\n                         (filter (fn [[lst cur]] (not= lst cur)))\n                         (map (comp last last)))]\n     (fn balanced? [n]\n       (let [[a b c] (->> primes\n                          (partition 3 1)\n                          (drop-while #(<= (nth % 2) n))\n                          first)]\n         (and (= n b)\n              (= n (/ (+ a c) 2))))))", "user": "4dfe5a93535d04ed9115e786"}, {"problem": 116, "code": "(fn ps? [n]\n  (let [ps [2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 101 103 107 109 113 127 131 137 139 149 151 157 163 167 173 179 181 191 193 197 199 211 223 227 229 233 239 241 251 257 263 269 271 277 281 283 293 307 311 313 317 331 337 347 349 353 359 367 373 379 383 389 397 401 409 419 421 431 433 439 443 449 457 461 463 467 479 487 491 499 503 509 521 523 541 547 557 563 569 571 577 587 593 599 601 607 613 617 619 631 641 643 647 653 659 661 673 677 683 691 701 709 719 727 733 739 743 751 757 761 769 773 787 797 809 811 821 823 827 829 839 853 857 859 863 877 881 883 887 907 911 919 929 937 941 947 953 967 971 977 983 991 997 1009 1013 1019 1021 1031 1033 1039 1049 1051 1061 1063 1069 1087 1091 1093 1097 1103 1109 1117 1123 1129]\n        i (remove nil?\n                  (map-indexed #(if (= n %2) %1 nil)\n                               ps))]\n    (if-let [i (first i)]\n      (if (> i 0)\n        (= n (/ (+ (ps (inc i))\n                   (ps (dec i)))\n                2))\n        false)\n      false)))", "user": "57982bace4b039eba2ecb10f"}, {"problem": 116, "code": "; this is cheating but no other functional prime sieve was fast enough\n; ... its slightly less cheating than just having all the balanced primes precomputed\n(fn [p]\n  (let [ps [2      3      5      7      11     13     17     19     23     29 \n            31     37     41     43     47     53     59     61     67     71 \n            73     79     83     89     97     101    103    107    109    113 \n            127    131    137    139    149    151    157    163    167    173 \n            179    181    191    193    197    199    211    223    227    229 \n            233    239    241    251    257    263    269    271    277    281 \n            283    293    307    311    313    317    331    337    347    349 \n            353    359    367    373    379    383    389    397    401    409 \n            419    421    431    433    439    443    449    457    461    463 \n            467    479    487    491    499    503    509    521    523    541 \n            547    557    563    569    571    577    587    593    599    601 \n            607    613    617    619    631    641    643    647    653    659 \n            661    673    677    683    691    701    709    719    727    733 \n            739    743    751    757    761    769    773    787    797    809 \n            811    821    823    827    829    839    853    857    859    863 \n            877    881    883    887    907    911    919    929    937    941 \n            947    953    967    971    977    983    991    997    1009   1013 \n            1019   1021   1031   1033   1039   1049   1051   1061   1063   1069 \n            1087   1091   1093   1097   1103   1109   1117   1123   1129   1151]\n        [bs as] (split-with #(> p %) ps)]\n    (true?\n     (if (and (not-empty bs) (not-empty as))\n       (let [b (last bs)\n             pp (first as)\n             a (second as)]         \n         (if (= p pp)\n           (= (- a p) (- p b))))))))", "user": "54dd76c8e4b024c67c0cf794"}, {"problem": 116, "code": "(fn [n]\n  (let [prime? (fn [n]\n                 (cond (= n 2) true\t\n                       (even? n) false\n                       (= n 1) false\n                       (= n 3) true\n                       :else\n                       (not-any? #(zero? (mod n %))\n                                 (range (- n 2) (dec (Math/sqrt n)) -2))))]\n    (and (prime? n)\n         (not= n 3)\n         (let [lower-prime (first (filter prime? (iterate dec (dec n))))\n               upper-prime (first (filter prime? (iterate inc (inc n))))]\n           (= (- n lower-prime) (- upper-prime n))))))", "user": "5297dcc5e4b02ebb4ef75047"}, {"problem": 116, "code": "(fn myf [n]\n  (letfn [(prime? [n]\n            (cond (or (= n 1) (= n 0)) false\n                  (= n 2) true\n                  :else (every? #((complement zero?) (rem n %)) (range 2 n))))]\n  (and (prime? n)\n    (if (or (= 0 n) (= 1 n) (= 2 n)) false\n    (let [less (first (filter prime? (reverse (range 2 n))))\n          more (first (filter prime? (range (inc n) (* 2 n))))]\n      (if (= (* 2 n) (+ less more)) true false))))))", "user": "577c3da9e4b0c8d87281f6b9"}, {"problem": 116, "code": "(fn\n  [n]\n  (loop [l 0 u 0 p [] num 2]\n    (if (> u n)\n      (= (/ (+ l u) 2) n)\n      (if (some #(= 0 %) (map #(rem num %) p))\n        (recur l u p (inc num))\n        (cond \n         (and (> num l) (< num n))\n           (recur num u (conj p num) (inc num))\n         (= num n)\n           (recur l num (conj p num) (inc num))\n         (= n u)\n           (recur l num (conj p num) (inc num))\n         :else\n           false\n         )))))", "user": "5772ddb0e4b0979f896515d4"}, {"problem": 116, "code": "(letfn [\n  (is-prime [n] (every? #(< 0 (mod n %)) (take-while #(<= (* % %) n) (drop 2 (range)))))\n  (next-prime [n] (first (filter is-prime (range (inc n) (* 10 n)))))\n  (prev-prime [n] (first (filter is-prime (reverse (range 0 n)))))]\n  (fn bp [n]\n    (if (< n 3) false\n    (and (is-prime n)\n      (= (* n 2) (+ (prev-prime n) (next-prime n)))))))", "user": "57717915e4b0979f896515b3"}, {"problem": 116, "code": "#(let [isNotPrime (fn [num] \n\t\t(true? \n\t\t\t(some \n\t\t\t\t(fn [x] (= x 0)) \n\t\t\t\t(map (partial mod num) (range 2 (inc (/ num 2)))))))]\n\t(if (or (isNotPrime %) (< % 3))\n\t\tfalse\n\t(let [n1 (last (take-while isNotPrime (range (dec %) 1 -1))) p1 (dec (if (nil? n1) % n1))\n\t\t  n2 (last (take-while isNotPrime (drop (inc %) (range)))) p2 (inc (if (nil? n2) % n2))]\n\t\t(= (/ (+ p1 p2) 2) %))))", "user": "57986b76e4b039eba2ecb116"}, {"problem": 116, "code": "(fn [x]\n  (letfn [(is-prime [x] \n                    (loop [i 2]\n                      (if (> (* i i) x)\n                        true\n                        (if (zero? (mod x i))\n                          false\n                          (recur (inc i))))))\n          (next-prime [f x]\n                      (if (is-prime (f x))\n                        (f x)\n                        (recur f (f x))))]\n    (let [a (next-prime dec x)\n          b (next-prime inc x)]\n      (and (> x 2) (is-prime x) (= x (/ (+ a b) 2))))))", "user": "5799ff45e4b05b1deef9add1"}, {"problem": 116, "code": "(fn [n]\n  (let [isPrime (fn [n] (and (>= n 2)\n                  (every? #(not= (rem n %1) 0) (range 2 n))))]\n    (and (isPrime n) (> n 2)\n         (= (* n 2)\n            (+ (second (filter isPrime (iterate dec n)))\n               (second (filter isPrime (iterate inc n))))))))", "user": "57015a1de4b08d47c97781d4"}, {"problem": 116, "code": "(fn is-balanced? [n]\n  (let [\n         primes (loop [pl '(2) x 3]\n                  (if (> (first pl) n)\n                    pl\n                    (if (every? #(not= (rem x %) 0) pl)\n                      (recur (conj pl x) (inc x))\n                      (recur pl (inc x))\n                    )\n                  )\n                )\n       ]\n    (if (< n 3)\n      false\n      (and (= n (second primes)) (= (* 2 n) (+ (first primes) (nth primes 2))))\n    )\n  )\n)", "user": "57873017e4b0ebec4cfb7503"}, {"problem": 116, "code": "(fn [input]\n               (let [is-prime (fn [n]\n                                (reduce (fn [prime x]\n                                          (and prime\n                                               (not (integer? (/ n x))))) true (range 2 n)))\n                     lower-prime (first (drop-while #(not (is-prime %)) (iterate dec (dec input))))\n                     upper-prime (first (drop-while #(not (is-prime %)) (iterate inc (inc input))))\n                     mean (/ (+ lower-prime upper-prime) 2)]\n                 (and (> input 2)\n                      (is-prime input)\n                      (= mean input))))", "user": "4e9ff8d0535d7eef3080729c"}, {"problem": 116, "code": "#(letfn [(prime? [n] (not-any? (comp zero? (partial rem n)) (range 2 n)))\n          (get-prime [f x] (if (prime? x) x (recur f (f x))))]\n  (if (and (> % 4) (prime? %))\n      (= (/ (+ (get-prime dec (dec %))\n               (get-prime inc (inc %))) 2) %)\n      false))", "user": "548b7db8e4b0e286459a11fd"}, {"problem": 116, "code": "(fn [n]\n    (let\n      [\n        divisible?\n        (fn [n i]\n          (=\n            (mod n i)\n            0\n          )\n        )\n\n        is-prime\n        (fn [n]\n          (and\n            (> n 2)\n            (every?\n              (complement\n                (partial divisible? n)\n              )\n              (range\n                2\n                (inc (quot n 2))\n              )\n            )\n          )\n        )\n\n        previous-prime\n        (fn [n]\n          (or\n            (first\n              (filter\n                is-prime\n                (range (dec n) 2 -1)\n              )\n            )\n            0\n          )\n        )\n\n        next-prime\n        (fn [n]\n          (first\n            (filter\n              is-prime\n              (iterate inc (inc n))\n            )\n          )\n        )\n      ]\n      (if\n        (not (is-prime n))\n        false\n        (=\n          n\n          (/\n            (+\n              (next-prime n)\n              (previous-prime n)\n            )\n            2\n          )\n        )\n      )\n    )\n  )", "user": "5784e177e4b0ebec4cfb74cf"}, {"problem": 116, "code": "(fn prime-sandwich [c]\n  (let [prime? (fn [n]\n                 (if (even? n) false\n                     (let [root (num (int (Math/sqrt n)))]\n                       (loop [i 3]\n                         (if (> i root) true\n                             (if (zero? (mod n i)) false\n                                 (recur (+ i 2))))))))\n        prime-from (fn [c]\n                     (first (drop-while #(not (prime? %)) c)))\n        previous-prime (->> c\n                            dec\n                            (iterate dec)\n                            prime-from)\n        next-prime (->> c\n                        inc\n                        (iterate inc)\n                        prime-from)]\n    (and (> c 4) (prime? c) (-> previous-prime\n                        (+ next-prime)\n                        (/ 2)\n                        (= c)))))", "user": "563fc1f2e4b08d4f616f5ed7"}, {"problem": 116, "code": "(fn[num](let [prime-seq (->>\n                  (iterate\n                    (fn [primes]\n                      (let [prime? (fn [n primes] (->> primes (filter #(<= (* % %) n)) (map #(mod n %)) (not-any? zero?)))]\n                        (conj primes (some #(let [n (+ (peek primes) % 1)] (when (prime? n primes) n)) (range)))))\n                    [2])\n                  (map peek))\n      [l c r] (->> prime-seq (partition 3 1) (filter (fn [[_ x _]] (>= x num))) first)]\n  (= num c (/ (+ l r) 2))))", "user": "57b3efb1e4b0fbc9809a278a"}, {"problem": 116, "code": "(fn prime-sandwich? [n]\n  (letfn [(binary-search [n x]\n            \"adapted from:\n             http://stackoverflow.com/questions/8949837/binary-\n             search-in-clojure-implementation-performance\"\n            (loop [l 0 h (unchecked-dec n)]\n              (if (<= h (inc l))\n                (cond\n                  (== (* l x) n) l\n                  (== (* h x) n) h\n                  :else nil)\n                (let [m (unchecked-add l (bit-shift-right \n                                    (unchecked-subtract h l) 1))]\n                  (if (< (* m x) n)\n                    (recur (unchecked-inc m) h)\n                    (recur l m))))))\n          \n          (prime? \n            [n]\n            (if (< n 2) false      \n              (loop [x 2]\n                (cond (> x (/ n 2)) true\n                (binary-search n x) false\n                :else (recur (unchecked-inc x))))))\n          \n          (nearest-lesser-prime [n]\n            (loop [x (unchecked-dec n)]\n              (cond\n                (<= x 2) nil\n                (prime? x) x\n                :else (recur (unchecked-dec x)))))\n          \n          (nearest-greater-prime \n            [n]\n            (loop [x (unchecked-inc n)]\n              (if (prime? x) x\n                (recur (unchecked-inc x)))))\n          \n          (prime-sandwitch?* [n]\n            (cond\n              (== n 0) false\n              (== n 1) false\n              (== n 2) false\n              (== n 3) false\n              (not (prime? n)) false\n              :else\n              (let [x (nearest-lesser-prime n)\n                    y (nearest-greater-prime n)]\n                (= n (/ (+ x y) 2)))))]\n    \n    (prime-sandwitch?* n)))", "user": "571c2babe4b07c98581c3b73"}, {"problem": 116, "code": "(fn balanced-prime? [n]\n  (letfn [(prime? [x] (every? #(not= 0 (mod x %)) (range 2 x)))]\n    (let [[earlier [l1 l2 & _]] (split-with #(< % n) (->> (range) (drop 2) (filter prime?)))]\n      (and (> n 2) (= l1 n) (= n (/ (+ (last earlier) l2) 2))))))", "user": "575b3e9be4b02ea11479935b"}, {"problem": 116, "code": "(fn [n]\n  (letfn [(prime? [num]\n            (if (#{0 1} num)\n              false\n              (if (= num 2)\n                true\n                (not (some #(= (mod num %) 0) (range 2 (inc (Math/sqrt num))))))))]\n    (if (prime? n)\n      (let [b (first (filter prime? (range (dec n) 1 -1)))\n            a (if b (first (filter prime? (range (inc n) (+ n b 1)))) nil )]\n        (and a b (= n (/ (+ a b) 2))))\n      false)))", "user": "57d0cd58e4b0bd073c20235e"}, {"problem": 116, "code": "(fn balanced-prime?\n   [x]\n   (letfn [(prime? [x]\n             (if (< x 4)\n               true\n               (reduce #(if %\n                         (false? (zero? (rem x %2)))\n                         %) true (range 2 (inc (int (Math/sqrt x)))))))\n           (before-prime\n             [p]\n             (reduce #(if (nil? %)\n                       (if (prime? %2)\n                         %2 nil)\n                       %) nil (range (dec p) 1 -1)))\n           (after-prime\n             [p]\n             (loop [i (inc p)]\n               (if (prime? i)\n                 i\n                 (recur (inc i)))))]\n     (true? (and (prime? x)\n                 (let [p1 (before-prime x)]\n                   (if (nil? p1)\n                     false\n                     (= (+ x x) (+ p1 (after-prime x)))))))))", "user": "56a36f76e4b0542e1f8d14ca"}, {"problem": 116, "code": "(fn balanced-prime? [n]\n  (letfn \n    [(prime? [x]\n       (cond\n         (<= x 1) false\n         (<= x 3) true\n         (or (zero? (mod x 2)) (zero? (mod x 3))) false\n         :else \n         (loop [i 5] \n           (if (> (* i i) x)\n             true\n             (if (or (zero? (mod x i)) (zero? (mod x (+ i 2))))\n               false\n               (recur (+ i 6)))))))\n     \n     (find-prime [x f]\n       (let [y (f x)]\n         (if (prime? y)\n           y\n           (find-prime y f))))]\n    \n    (cond \n      (< n 5) false\n      (not (prime? n)) false\n      :else\n      (let [x (find-prime n inc)\n            y (find-prime n dec)]\n        (= (/ (+ x y) 2) n)))))", "user": "57d9bca1e4b0bd073c202405"}, {"problem": 116, "code": "(fn [num]\n  (letfn [(prime []\n            (letfn [(step [coll]\n                      (let [head (first coll)]\n                        (lazy-seq (cons head (step (filter #(pos? (mod % head)) coll))))))]\n              (step (range 2 Long/MAX_VALUE))))\n          (balanced-prime []\n            (map second (filter #(= (second %) (/ (+ (first %) (last %)) 2)) (partition 3 1 (prime)))))]\n    (= num (last (take-while #(<= % num) (balanced-prime))))))", "user": "57df309ee4b0bd073c20245f"}, {"problem": 116, "code": "(fn [n]\n  (letfn [(prime? [n] (every? #(not= 0 (rem n %)) (range 2 n)))\n          (prev-prime [n] (if (prime? (dec n)) (dec n) (recur (dec n))))\n          (next-prime [n] (if (prime? (inc n)) (inc n) (recur (inc n))))]\n    (and\n     (> n 3)\n     (prime? n)\n     (= n (/ (+ (next-prime n) (prev-prime n)) 2)))))", "user": "56cf115de4b0ea9b8538f765"}, {"problem": 116, "code": "(fn bal-prime? [n]\n  (letfn [(primez\n            ([] (cons 2 (primez 2 [2])))\n            ([last got]\n             (lazy-seq\n               (loop [next (inc last)]\n                 (if (not-any? #(zero? (mod next %)) got)\n                   (cons next (primez next (conj got next)))\n                   (recur (inc next)))))))]\n    (loop [[prv cur nxt & r :as ps] (primez)]\n      (cond \n        (> cur n)\n        false\n        \n        (= cur n)\n        (= n (/ (+ prv nxt) 2))\n\n        :default\n        (recur (rest ps))))))", "user": "56f9c7c6e4b07572ad1a88ba"}, {"problem": 116, "code": "(fn prime-sandwich [p]\n  (let [prime-number (fn prime-number ;   works\n    ([] (prime-number false))\n    ([n] (\n      (fn keep-cdr [f coll] (lazy-seq\n        (when-let [x (first coll)]\n          (cons x (keep-cdr f (f x (rest coll)))))))\n      (fn[x xs] (if (not-empty xs)\n        (keep (fn [m] (if-not (zero? (rem m x)) m)) xs)))\n          (if n (range 2 n) (iterate inc 2)))))]\n    (if (< p 5)\n    false\n  (let [primes2 (take-last 2 (prime-number (inc p)))]\n    (if (not= p (last primes2))\n      false\n      (let [nextprime (+ p (- p (first primes2)))\n            [this1 next1 ] (take-last 2(prime-number (inc nextprime)))]\n        (and (= p this1)\n             (= nextprime next1 ))))))))", "user": "579d9601e4b05b1deef9ae18"}, {"problem": 116, "code": "(fn bp\n  ([] (let [\n             [p1 p2 & t]\n             (filter\n              (fn [n]\n                (and (> n 1)\n                     (not-any? #(= 0 (rem n %)) (range 2 n))))\n              (range))]\n        (bp p1 p2 t)))\n  ([n] (= n (first (drop-while #(< % n) (bp)))))\n  ([p1 p2 [h & t]]\n   (if (= (* p2 2) (+ p1 h))\n     (cons p2 (lazy-seq (bp p2 h t)))\n     (lazy-seq (bp p2 h t)))))", "user": "576df252e4b0979f8965156f"}, {"problem": 116, "code": "(fn prime-sandwich [n]\n  (let [primes (fn primes [x primes-found]\n                 (lazy-seq\n                  (if (not-any? (comp (partial = 0) (partial mod x)) primes-found)\n                    (cons x (primes (inc x) (conj primes-found x)))\n                    (primes (inc x) primes-found))))]\n    (if-let [[before _ after] (->> (primes 2 [])\n                                   (partition 3 1)\n                                   (take-while (comp (partial >= n) second))\n                                   (filter (comp (partial = n) second))\n                                   first)]\n      (if (= n (/ (+ before after) 2)) true false)\n      false)))", "user": "53504fe6e4b084c2834f4ada"}, {"problem": 116, "code": "(fn [n]\n   (if (< n 5) false\n     (let [c (fn [v]\n               (not-any? #(zero? (mod v %)) (range 2 v)))\n           p (fn [f]\n               (loop [v (f n)]\n                 (if  (c v) v\n                   (recur (f v)))))]\n       (and (c n) (= (+ (p dec) (p inc)) (+ n n))))))", "user": "57d9f603e4b0bd073c20240a"}, {"problem": 116, "code": "(fn p116 [n]\n  (let [prime? (fn [p]\n                 (let [root (num (int (Math/sqrt p)))]\n                   (loop [i 2]\n                     (if (> i root) true\n                       (if (zero? (mod p i)) false\n                         (recur (inc i)))))))\n        below (loop [i (dec n)]\n                (if (prime? i) i\n                  (recur (dec i))))\n        above (loop [i (inc n)]\n                (if (prime? i) i\n                  (recur (inc i))))]\n    (if (or (not (prime? n)) \n            (<= n 1) \n            (<= above 1) \n            (<= below 1))\n      false\n      (if (= (+ above below) (* 2 n))\n        true\n        false))))", "user": "57fe836ee4b0d3187e9009d2"}, {"problem": 116, "code": "(fn balanced-prime? [n]\n               (letfn [(prime? [x] (= nil (some #(= 0 (rem x %)) (range 2 (int (inc (/ x 2)))))))]\n                 (if (or (< n 3) (not (prime? n)))\n                   false\n                   (loop [step 1]\n                     (if (or (prime? (+ n step)) (prime? (- n step)))\n                       (and (prime? (+ n step)) (prime? (- n step)))\n                       (recur (inc step)))))))", "user": "5746061ae4b009280f9f2b5b"}, {"problem": 116, "code": "(fn\n  [x]\n  (let [f #(int (Math/sqrt %))\n        g #(if (and (> % 1) (zero? (rem % %2)))\n            (if (= 1 %2) true false)\n            (if (< % 2) false (recur % (dec %2))))\n        h #(g % (f %))]\n    (if (h x)\n      (->> (loop\n             [t (vector x) d x u x]\n             (cond\n               (< x 5) [2 3 5]\n               (= d u) (recur t (- d 2) (+ u 2))\n               (= 3 (count t)) t\n               (and (h d) (h u)) (conj t d u)\n               (h d) (recur (conj t d) 0 (+ u 2))\n               (h u) (recur (conj t u) (- d 2) 0)\n               :else (recur t (- d 2) (+ u 2))))\n           (#(= (first %) (/ (+ (second %) (last %)) 2))))\n      false)))", "user": "55bf6dbce4b01b9910ae2a12"}, {"problem": 116, "code": "(fn prime-sandwich? [n]\n  (let [sieve (fn sieve [n] (lazy-seq (cons n (remove #(zero? (rem % n)) (sieve (inc n))))))\n        is-prime? (fn [n] (not-any? #(zero? (rem n %)) (range 2 (inc (quot n 2)))))]\n    (and (is-prime? n)\n         (loop [primes (sieve 2)]\n           (let [[a b c & t] primes]\n             (cond\n               (> b n) false\n               (= b n) (= b (/ (+ a c) 2))\n               (< b n) (recur (rest primes))))))))", "user": "57e0f30ae4b0bfb2137f5a66"}, {"problem": 116, "code": "(fn [n]\n  (let [prime? (fn [x]\n                 (if (< x 2)\n                   false\n                   (not-any?\n                     zero?\n                     (map #(mod x %)\n                          (range\n                            2\n                            (-> x\n                                Math/sqrt\n                                int\n                                inc))))))]\n    (if (or (< n 5)\n            (not (prime? n)))\n      false\n      (let [not-prime? (complement prime?)\n            left (first (drop-while\n                          not-prime?\n                          (range (dec n) 1 -1)))\n            right (first (drop-while\n                           not-prime?\n                           (drop (inc n) (range))))]\n        (or (nil? (and left right))\n            (= n (/ (+ left right) 2)))))))", "user": "57f0f7b8e4b0bfb2137f5bfe"}, {"problem": 116, "code": "(fn __ [i]\n  (let [? (fn [i]\n            (or (= i 2)\n                (let [s (->> (Math/sqrt i) range (map inc) rest)]\n                  (and (not-empty s) (every? #(not (zero? (mod i %))) s)))))]\n    (case i\n      2 false\n      (and (? i)\n           (let [f (fn [r] (->> (range) (map #(r i 1 %)) (filter ?) first))\n                 p (f -)\n                 n (f +)]\n             (and (? n)\n                  (= n (+ i (- i p)))))))))", "user": "57a0b341e4b0c3d858beb8d4"}, {"problem": 116, "code": "(fn [n] (let [f #(BigInteger/valueOf %)\n              g #(.isProbablePrime % 9)\n              c (f n)] \n   (and (g c) (= c (/ (+ (.nextProbablePrime c) (second (filter g (map f (iterate dec c))))) 2)))))", "user": "57e33f6fe4b0bfb2137f5a96"}, {"problem": 116, "code": "(fn [x]\n  (letfn [(isPrime? [n]\n                    (cond\n                     (= n 0) false\n                     (= n 1) false\n                     (= n 2) true\n                     :else (not-any? #(zero? (mod n %)) (range 2 n))))]\n    (let [prev (some #(if (isPrime? %) %) (reverse (range 2 x)))\n          nextp (some #(if (isPrime? %) %) (drop (inc x) (range)))]\n      (if (nil? prev) false\n                      (and (isPrime? x)\n                           (= nextp (- (* 2 x) prev)))))))", "user": "57dd47f4e4b0bd073c20243e"}, {"problem": 116, "code": "(fn I-dont-know-how-write-concise-function-names  [n]\n  (letfn [(is-prime? [n]  (empty? (filter #(= (mod n %)0 )(range 2 n))))\n    \t  (get-prime-index [n] (if (is-prime? n) (.indexOf (filter #(is-prime? %) (range )) n)))\n           ]\n     (if (and (> n 3)(is-prime? n)) (= (/(apply + (map #(nth (filter is-prime? (range)) %)((juxt inc dec) (get-prime-index n) ))) 2 ) n)false)))", "user": "56ede653e4b04a395b9a0449"}, {"problem": 116, "code": "(fn prime-balance [n]\n  (letfn [(prime? [n]\n  (if (or (< n 2) (and (not= 2 n) (even? n)))\n    false\n    (if (#{2 3 5 7} n) true\n        (every? #(not= 0 (rem n %))\n                (range 2 (inc (int (Math/sqrt n))))))))]\n      (if (or (#{2 3} n) (not (prime? n))) false\n      (letfn [(next-prime [n df]\n                (loop [n (df n 2)] (if (prime? n) n\n                                       (recur (df n 2)))))]\n        (let [a (next-prime n -), b (next-prime n +)]\n          (if (= (+ a b) (+ n n)) true false))))))", "user": "572ec4dde4b0cd1946bd0f8d"}, {"problem": 116, "code": "(fn [a]\n (letfn  [\n  (isprime [x i]\n   (cond\n     (= i 1) true \n     (= i 0) false\n     (= (mod x i) 0) false\n     (not (= (mod x i) 0)) (isprime x (dec i))\n    )\n   )\n  (nextprime [x]\n   (cond \n    (isprime x (dec x)) x\n    :else (nextprime (inc x))\n   )\n  )\n  (prevprime [x]\n   (cond \n    (isprime x (dec x)) x\n    :else (prevprime (dec x))\n   )\n   )\n  (ismediumprime [x]\n     \t(cond\n           (<= x 1) false\n           (= x 2) false\n           (not (isprime x (dec x))) false\n           (= (/ (+ (prevprime (dec x)) (nextprime (inc x))) 2) x) true\n           :else false\n        )  \n  )\n ]\n\n  (ismediumprime  a)\n ))", "user": "56e6e1e6e4b02e7e935eb6cf"}, {"problem": 116, "code": "; reusing an existing optimized infinite lazy-seq implementation of primes... hence the verbosity\n(fn [candidate]\n(let [primes\n  ((fn primez [n m]\n     (let [\n           update-composites\n           (fn [n m]\n             (if-let [facts (get m n)]\n               (dissoc \n                 (reduce #(update-in % [(+ n %2)] (fnil conj []) %2)\n                         m\n                         facts)\n                 n)\n               (assoc m (* n n) [n])))\n\n           is-not-prime (contains? m n)\n           next-num (inc n)\n           m (update-composites n m)]\n       \n       (if is-not-prime\n          (recur next-num m)\n          (lazy-seq (cons n (primez next-num m))))))\n\n   2 {})\n  primes-indexed (map-indexed (fn [a b] [a b]) primes)\n  first-matching (first (drop-while #(< (second %) candidate) primes-indexed))]\n  \n  (if (and (= candidate (second first-matching)) (> (first first-matching) 0))\n    (= candidate (/ (+ (nth primes (dec (first first-matching))) (nth primes (inc (first first-matching)))) 2))\n    false)))", "user": "56ff45e5e4b08d47c97781bb"}, {"problem": 116, "code": "(let [primify (fn primify\n                  [base-seq]\n                  (lazy-seq (cons (first base-seq)\n                                  (primify (filter #(not= 0 (mod % (first base-seq))) (rest base-seq))))))\n      integers-from (fn integers-from\n                        [n]\n                        (lazy-seq (cons n (integers-from (+ n 1)))))\n      sliding (fn sliding [n seq] (lazy-seq (cons (take n seq) (sliding n (rest seq)))))]\n  (fn balanced?\n    [n]\n    (loop [curr (sliding 3 (primify (integers-from 2)))]\n      (let [[pre x post] (first curr)]\n        (if (> x n)\n          false\n          (if (= x n)\n            (= (/ (+ pre post) 2) x)\n            (recur (rest curr))))))))", "user": "58152157e4b0f478707a0631"}, {"problem": 116, "code": "(fn [n]\n    (let [primes (fn []\n                   (let [odds (cons 2 (iterate #(+ 2 %) 3))]\n                     (loop [sieved odds res []]\n                       (if (and (not (empty? res)) (> (last res) n))\n                         res\n                         (let [p (first sieved)]\n                           (recur (remove #(zero? (mod % p)) sieved) (conj res p)))))))\n          triple (last (partition 3 1 (primes)))]\n       (and (< 2 n) (= n (second triple) (/ (+ (first triple) (last triple)) 2)))))", "user": "4e837808535db62dc21a62d9"}, {"problem": 116, "code": "(fn [x]\n  (letfn [(prime?\n            [a] (cond (< a 2) false\n                      (= a 2) true\n                      :else (let [root (Math/ceil (Math/sqrt a))]\n                             (not-any? #(= (rem a %) 0) (range 2 (inc root))))))\n          (prime_before [b] (if (prime? (dec b)) (dec b) (prime_before (dec b))))\n          (prime_after [c] (if (prime? (inc c)) (inc c) (prime_after (inc c))))]\n    (if (< x 5) false \n      (if (not (prime? x)) false \n        (if (= x (/ (+ (prime_before x) (prime_after x)) 2)) true false)))))", "user": "564d3169e4b0284900eef67c"}, {"problem": 116, "code": "(let [p (memoize #(loop [p (inc (last %))]\n                   (if (some zero? (map (partial mod p) %))\n                     (recur (inc p))\n                     (conj % p))))]\n  (fn [n]\n    (when (> n 2)\n      (let [ps\n            (some\n              #(when (> (last %) n) %)\n              (iterate p [2]))]\n        (and\n          (= n (nth ps (- (count ps) 2)))\n          (= n\n             (/\n               (+ (last ps) (nth ps (- (count ps) 3)))\n               2)))))))", "user": "581e61b0e4b04b46fc4b0f28"}, {"problem": 116, "code": "(fn [x]\n  (letfn [(p [n] (and (> n 1) (not-any? #(= 0 (mod n %)) (range 2 n))))\n          (q [s] (first (filter p s)))]\n    (let [a (q (drop (+ x 1) (range)))\n          b (q (range (- x 1) 1 -1))]\n      (and (p x)\n           (not (nil? b))\n           (= x (/ (+ a b) 2))))))", "user": "5742ec91e4b05c31a32c0883"}, {"problem": 116, "code": "(fn balanced-prime? [n]\n  (letfn [(prime? [x] (if (< x 2)\n                        false\n                        (loop [i 2]\n                          (cond\n                            (< x (* i i)) true\n                            (= 0 (mod x i)) false\n                            :else (recur (inc i))))))]\n    (if (prime? n)\n      (loop [pair [(dec n) (inc n)]]\n        (cond\n          (every? prime? pair) true\n          (not-any? prime? pair) (recur (map #(%1 %2) [dec inc] pair))\n          :else false))\n      false)))", "user": "58247423e4b051871117bec5"}, {"problem": 116, "code": "(fn balan? [n]\n (if (<= n 2)\n  false\n  (let\n   [bgn-prms [2]\n    nxt-prim \n     (fn [prev]\n      (let [lst (peek prev)]\n       (loop [z (inc lst)]\n        (if (even? z) \n         (recur (inc z))\n         (if (not-any? #(zero? (mod z %)) prev)\n          z\n          (recur (inc z)) )) )))\n    \n    prims-upto \n     (fn [n]\n      (loop [acc bgn-prms]\n       (if (<= n (peek acc)) \n        acc\n        (let [newacc (conj acc (nxt-prim acc))]\n         (recur newacc) ))))\n\n    n-prims (prims-upto n)\n    n-prev (peek (pop n-prims))\n    n-nxt (nxt-prim n-prims)\n    n-just (peek n-prims) ]\n\n   (and\n    (= n n-just)\n    (= n (/ (+ n-prev n-nxt) 2)))\n )))", "user": "57f9011ee4b0d3187e900935"}, {"problem": 116, "code": "(fn balanced-prime?[p]\n  ;; https://clojuredocs.org/clojure.core/lazy-seq#example-542692d3c026201cdc326ff1\n  (letfn [( sieve [s]\n                  (cons (first s)\n                        (lazy-seq (sieve (filter #(not= 0 (mod % (first s)))\n                                                 (rest s))))))]\n    (let [primes (sieve (iterate inc 2))\n          three-primes (take-last 3\n                           (lazy-cat\n                            (take-while #(>= p %) primes)\n                            (take 1 (drop-while #(>= p %) primes))))\n          \n          is-prime (= (second three-primes) p)\n          is-balanced (= p (/ (+ (first three-primes)(last three-primes)) 2))]\n      \n      (and is-prime is-balanced))))", "user": "56069006e4b08b23635d3174"}, {"problem": 116, "code": "(fn [n]\n    (letfn [(prime? [x]\n              (not-any? #(zero? (mod x %))\n                        (range 2 (inc (int (Math/sqrt x))))))\n            (pre [x]\n              (if (prime? x)\n                x\n                (pre (dec x))))\n            (next [x]\n              (if (prime? x)\n                x\n                (next (inc x))))]\n      (and\n       (> n 2)\n       (prime? n)\n       (= n (/ (+ (pre (dec n)) (next (inc n))) 2)))))", "user": "55c5b55fe4b0e31453f649b5"}, {"problem": 116, "code": "(fn balanced-prime? [n]\n  (loop [primes [2]\n         num    3]\n    (if (< n 3)\n      false\n      ;; We need pn+1, so stop after we have a prime bigger than n\n      (if (> (peek primes) n)\n        (let [i (- (count primes) 1)]\n          (and\n           ;; No need to check for balanced prime if n is not a prime\n           (= (primes (- i 1)) n)\n           (= n (/ (+ (primes (- i 2)) (primes i)) 2))))\n        (if (not-any? zero? (map #(rem num %) (take-while #(< % num) primes)))\n          (recur (conj primes num) (+ num 2))\n          (recur primes (+ num 2)))))))", "user": "58327a08e4b089d5ab817c7c"}, {"problem": 116, "code": "(fn prime-sandwich? [n]\n  (letfn [(divisible? [a b] (zero? (rem a b)))\n          (get-primes [n primes]\n            (if (some #(divisible? n %) primes)\n              (get-primes (inc n) primes)\n              (lazy-seq \n                (cons n (get-primes (inc n) (conj primes n))))))\n          (seq-of-primes [] (get-primes 2 []))]\n    (loop [prev 0\n           break false\n           p (first (seq-of-primes))\n           primes (next (seq-of-primes))]\n      (if break\n        (and (= n p) (= (/ (+ prev (first primes)) 2) p))\n        (recur p (>= (first primes) n) (first primes) (next primes))))))", "user": "57c0917be4b05aa3c4741c95"}, {"problem": 116, "code": ";; See problem 67 on prime number generation\n;; Flaw: the next prime is still calculated if the given number is not a prime.\n(letfn [(produce-prime [primes n]\n          (if (some zero?\n                    (map #(rem n %) primes))\n            ;; not a prime, check next\n            (produce-prime primes (+ n 2))\n            ;; a prime! add it to the list and find the mext one.\n            (cons n\n                  (lazy-seq (produce-prime (cons n primes)\n                                           (+ n 2))))))]\n  (fn [n]\n    (loop [[a b c :as all] (cons 2 (produce-prime '(2) 3))]\n      (condp #(% %2 n) b\n        = (= b (/ (+ a c) 2))\n        < (recur (rest all))\n        > false))))", "user": "54d341f7e4b0e8a36923e603"}, {"problem": 116, "code": "(fn [n]\n  (let [prime? (fn [n] (and (> n 1)\n                            (not-any? #(= 0 (mod n %)) (range 2 n))\n                            n))\n        next-prime (some prime? (drop (inc n) (range)))\n        prev-prime (some prime? (range (dec n) 1 -1))]\n    (and (prime? n)\n         next-prime\n         prev-prime\n         (= n (/ (+ next-prime prev-prime) 2)))))", "user": "583e27e2e4b089d5ab817daa"}, {"problem": 116, "code": "(letfn [(prime? [n] (every? #(not (zero? (rem n %))) (range 2 (inc (Math/sqrt n)))))]\n  (fn [n]\n    (and (> n 3) (prime? n)\n         (= (- n (first (filter prime? (iterate dec (dec n)))))\n            (- (first (filter prime? (iterate inc (inc n)))) n)))))", "user": "584dadebe4b0b7285a6f4e44"}, {"problem": 116, "code": "(fn [n]\n  (and (> n 3)\n       (let [isPrime (fn [x] (every? #(> (mod x %) 0) (range 2 x)))\n             before (first (filter isPrime (reverse (range 2 n))))\n             after (first (filter isPrime (drop (inc n) (range))))]\n         (and \n          (isPrime n) \n          (= (* 2 n) (+ before after)))\n         )))", "user": "565b2fa5e4b068f2fe63dbfe"}, {"problem": 116, "code": "(fn [num]\n  (letfn [(prime []\n            (letfn [(step [coll]\n                      (let [head (first coll)]\n                        (lazy-seq (cons head (step (filter #(pos? (mod % head)) coll))))))]\n              (step (range 2 Long/MAX_VALUE))))\n          (balanced-prime []\n            (map second (filter #(= (second %) (/ (+ (first %) (last %)) 2)) (partition 3 1 (prime)))))]\n    (= num (last (take-while #(<= % num) (balanced-prime))))))", "user": "5849ac5fe4b089d5ab817ed7"}, {"problem": 116, "code": "(fn balanced-prime [n]\n  (letfn [(is-prime? [x]\n                    (cond\n                     (= x 0) false\n                     (= x 1) false\n                     (= x 2) true\n                     (even? x) false\n                     :else (reduce #(and %1 (not= (mod x %2) 0))\n                                   true\n                                   (range 3 (/ (inc x) 2)))))]\n    (if (and (is-prime? n) (> n 3))\n      (let [pre-prime (last (filter is-prime? (range 3 n)))\n            post-num  (- (* n 2) pre-prime)]\n        (and (is-prime? post-num)\n             (= (count (filter is-prime? (range (inc n) post-num))) 0)))\n      false)))", "user": "585e2e77e4b0f14aab7c87ac"}, {"problem": 116, "code": "(let [prime? (fn [n]\n               (and (< 1 n)\n                    (not-any? #(zero? (mod n %))\n                              (remove #(= n %) (range 2 (inc (Math/sqrt n)))))))\n      primes (filter prime? (range))]\n  (fn [n]\n    (let [[a b c] (first (drop-while (fn [[_ x _]] (< x n)) (partition 3 1 primes)))]\n      (and (= b n) (= b (/ (+ a c) 2))))))", "user": "4f5599dfe4b0a7574ea71806"}, {"problem": 116, "code": "(fn [n]\n    (= n (first (drop-while #(< % n)\n                            (keep (fn [[a b c]]\n                                    (when (= (+ a c) (* 2 b)) b))\n                                  (partition 3 1\n                                             ((fn p [[x & xs]]\n                                                (lazy-seq\n                                                 (cons x (p (filter #(pos? (mod % x)) xs)))))\n                                              (iterate inc 2))))))))", "user": "55597b84e4b0deb715856e36"}, {"problem": 116, "code": "(fn balance-prime?\n  [n]\n  (letfn [(prime?\n            [n]\n            (not-any? #(zero? (mod n %)) (range 2  n)))]\n    (and\n      (> n 4)\n      (prime? n)\n      (let [a (first (drop-while #(not (prime? %)) (range (dec n) 0 -1)))\n            b (first (drop-while #(not (prime? %)) (iterate inc (inc n))))\n            r (/ (+ a b) 2)]\n        (= n r)))))", "user": "566ff0a1e4b0a866af6896ec"}, {"problem": 116, "code": "(fn [n]\n    (and (> n 3)\n     (let [prime? (fn [x] (every? #(< 0 (mod x %)) (range 2 x)))\n           primes (filter prime? (iterate inc 2))]\n       (and (prime? n)\n            (let [pre  (last (take-while #(> n %) primes))\n                  post (first (drop-while #(>= n %) primes))]\n             (= n (/ (+ pre post) 2)))))))", "user": "500d3160e4b05f7c30cfa6a1"}, {"problem": 116, "code": "(fn [x] (letfn [(prime? [x] (if (even? x) false\n                              (loop [i 3]\n                                (cond (< x (* i i)) x\n                                      (zero? (mod x i)) false\n                                      :defualt (recur (+ i 2))))))\n                (next-p [x] (second (filter prime? (iterate #(+ % 2) x))))\n                (previous-p [x] (second (filter prime? (iterate #(- % 2) x))))]\n          (and (> x 3) (prime? x)\n            (= x (/ (+ (next-p x) (previous-p x)) 2)))))", "user": "57dafe97e4b0bd073c20241c"}, {"problem": 116, "code": "(fn balanced-prime? [n]\n  (letfn [(gen-primes [s]\n            (let [cur (first s)]\n              (lazy-seq (cons cur (gen-primes (remove #(zero? (mod % cur)) s))))))]\n    (let [primes (gen-primes (iterate inc 2))\n          [lower-primes higher-primes] (split-with (partial > n) primes)]\n      (and (= n (first higher-primes)) (not= n 2)\n           (= (/ (+ (last lower-primes) (first (rest higher-primes))) 2) n)))))", "user": "5879d577e4b01531a375ead8"}, {"problem": 116, "code": "(fn [n]\n  (contains? \n   (set (vector 5 53 157 173 211 257 263 373 563 593 607 653 733 947 977 1103))\n   n))", "user": "586615e6e4b0f14aab7c8858"}, {"problem": 116, "code": "(fn primesandwich [n]\n  (let\n    [\n     isPrime (fn [n]\n       (if\n         (< n 2)\n         false\n         (not\n           (reduce\n             #(or %1 %2)\n             false\n             (map\n               (fn [x] (= (float (/ n x)) (float (int (/ n x)))))\n               (range 2 (+ 1(int (Math/sqrt n))))\n               )\n             )\n           )\n         )\n       )\n\n     xor (fn [a b] (or (and a (not b)) (and (not a) b)))\n     ]\n    (if\n      (not (isPrime n))\n      false\n      (let\n        [\n         recursor\n         (fn\n           recurs\n           [a b]\n           (let\n             [aIsPrime (isPrime a), bIsPrime (isPrime b)]\n             (if\n               (and aIsPrime bIsPrime)\n               true\n               (if\n                 (xor aIsPrime bIsPrime)\n                 false\n                 (recurs (inc a) (dec b))\n                 )\n               )\n             )\n           )\n         ]\n        (recursor (inc n) (dec n))\n        )\n      )\n    )\n  )", "user": "58950f29e4b00487982d5270"}, {"problem": 116, "code": "(fn [n]\n  (letfn [(prime? [x]\n            (if (> x 1)\n              (loop [i 2]\n                (if (> i (/ x 2))\n                  true\n                  (if (= 0 (rem x i))\n                    false\n                    (recur (inc i)))))\n              false))\n          (x-prime [f n]\n            (loop [n (f n)]\n              (cond\n                (< n 2) nil\n                (prime? n) n\n                :default (recur (f n)))))\n          (l-prime [n] (x-prime dec n))\n          (r-prime [n] (x-prime inc n))]\n    (if (prime? n)\n      (let [l (l-prime n)\n            r (r-prime n)]\n        (and (not (nil? l)) (= (/ (+ l r) 2) n)))\n      false)))", "user": "58bb218be4b0888cdc949cf4"}, {"problem": 116, "code": "(fn [x]\n  (let [not-prime? (fn [v] (some #(zero? (mod v %)) (range 2 v)))\n        get-prime #(loop [v (% x)]\n                     (if (not-prime? v) (recur (% v)) v))]\n    (and (< 2 x) \n         ((complement not-prime?) x) \n         (= x (/ (apply + (map get-prime [inc dec])) 2)))))", "user": "567d132ee4b05957ce8c61c3"}, {"problem": 116, "code": "(fn prime-sandwich\n  [n]\n  (let [prime-und (fn prime-under\n                    [anum]\n                    (loop [start 5\n                           res {2 true 3 true}]\n                      (cond\n                        (< anum 2) []\n                        (or (= 2 anum) (= 3 anum)) (sort (keys res))\n                        (> start anum) (sort (keys res))\n                        (some #(integer? (/ start %)) (keys res)) (recur (+ 2 start) res)\n                        :else (recur (+ 2 start) (assoc res start true)))))\n        lprimes (sort (prime-und 1200))\n        bef-n (last (take-while #(< % n) lprimes))\n        aft-n (first (drop-while #(< % n) lprimes))\n        alt-n (second (drop-while #(< % n) lprimes))]\n    (cond\n      (nil? bef-n) false\n      (nil? aft-n) false\n      (= aft-n n) (= n (/ (+ bef-n alt-n) 2))\n      (< aft-n n) false\n      :else false)))", "user": "550d9452e4b06e50f9beb15d"}, {"problem": 116, "code": "(fn [n]\n  (letfn [(prime? [n]\n              (and (> n 1) (every? #(> (mod n %) 0) (range 2 n))))\n            (next-prime [n]\n              (first (filter prime? (iterate inc (inc n)))))\n            (prev-prime [n]\n              (first (filter prime? (reverse (range 1 n)))))]\n      (let [a (prev-prime n) b (next-prime n)]\n        (and (prime? n)\n             a\n             (= n (/ (+ a b) 2))))))", "user": "58ca8a1de4b03c36ff7e5835"}, {"problem": 116, "code": "(fn [n]\n  (letfn [(balanced? [a b c] (and (= b n)\n                                  (= b (int (/ (+ a c) 2)))))]\n    (loop [num 4, primes '(3 2)]\n      (cond\n        (< n 5) false\n        (> (first primes) n) (apply balanced? (take 3 primes))\n        (some #(zero? (mod num %)) primes) (recur (inc num) primes)\n        :else (recur (inc num) (conj primes num)))\n      )\n    )\n  )", "user": "589037b4e4b00487982d51d0"}, {"problem": 116, "code": "(fn b-p\n  [n]\n  (let [is-prime?\n        (fn [num]\n          (let [smaller-nums (range 2 (dec num))]\n            (every? #(not= 0 (mod num %)) smaller-nums)))\n        pre-prime (loop [n (dec n)]\n                    (if-not (or (is-prime? n) (= n 2))\n                      (recur (dec n))\n                      n))\n        next-prime (loop [n (inc n)]\n                     (if (not (is-prime? n))\n                       (recur (inc n))\n                       n))]\n    (and (> n 3)\n         (is-prime? n)\n         (= (* n 2) (+ pre-prime next-prime)))))", "user": "58de563fe4b0a4d5acaab6e3"}, {"problem": 116, "code": "(fn balanced-prime? [n]\n  (let [factors (cons 2 (iterate (partial + 2) 3))\n        prime? (fn [n] \n                 (not-any? #(zero? (mod n %))\n                           (take-while #(<= % (inc (Math/sqrt n))) factors)))\n        prime-step (fn [n s] \n                     (first (drop-while (complement prime?) (rest (iterate (partial + s) n)))))]\n    (and (> n 3)\n         (prime? n)\n         (= n (/ (+ (prime-step n 2) (prime-step n -2)) 2)))))\n\n;; Function below works but times out on 4clojure\n;(fn balanced-prime? [n]\n;     (letfn [(prime? [x]\n;                (if (< x 2)\n;                  false\n;                  (if (= 1\n;                         (count (filter #(= 0 (mod x %)) (range 1 (inc (int (Math/sqrt x)))))))\n;                    true\n;                    false)))]\n;       (let [prime-list (filter #(prime? %) (range))]\n;         (and \n;           (not (= n 2))\n;           (prime? n)\n;           (= n\n;              (/ (+ (last (take-while #(< % n) prime-list))\n;                    (first (drop-while #(<= % n) prime-list)))\n ;                2))))))", "user": "58dcb8cde4b0a4d5acaab6a7"}, {"problem": 116, "code": "(fn sandwich? [n]\n  (let [prime?     (fn [n primes] (if (not (some #(= 0 (rem n %)) primes)) n))\n        next-prime (fn [primes]   (some #(prime? % primes) (iterate inc (inc (apply max primes)))))\n        gen-primes (fn []         (iterate (fn [primes] (conj primes (next-prime primes))) '(2)))\n        primes     (first (drop-while #(<= (first %) n) (gen-primes)))\n        [x v y]    primes]\n    (and (= v n) (not (nil? y)) (= n (/ (+ x y) 2)))))", "user": "58dcf11ae4b0a4d5acaab6af"}, {"problem": 116, "code": "(fn balanced-prime? [num]\n  (let [factors (cons 2 (iterate (partial + 2) 3))]\n    (letfn [(prime? [n] \n              (not-any? #(zero? (rem n %)) (take-while #(<= % (inc (Math/sqrt n))) factors)))\n            (prime-step [n s] \n              (first (drop-while (complement prime?) (rest (iterate (partial + s) n)))))]\n      (and (> num 3)\n           (prime? num)\n           (= num (/ (+ (prime-step num 2) (prime-step num -2)) 2))))))", "user": "58ed713de4b056aecfd47d84"}, {"problem": 116, "code": "(fn ps [n]\n  (letfn [ (prs [n]\n            (->> (range 2 (* 2 n))\n            (filter (fn [x] (every? #(< 0 (rem x %)) (range 2 x))))\n            (take-while #(<= % (* 2 n)))))\n            (acb? [a b c ] (= b (/ (+ a c) 2 )))]\n    (cond\n      (or (= n 1) (= n 0) (= n 2) (= n 3))\n        false\n      (every? #(< 0 (rem n %)) (range 2 n))\n        (->>\n          (filter #(= (nth % 1) n )  (partition 3 1 (prs n)))\n          first\n          (apply acb?))\n        :else false\n   )))", "user": "51f81925e4b09be9c177e526"}, {"problem": 116, "code": "(fn\n  [x]\n  (letfn\n    [(prime? [v] (every? #(not= 0 (rem v %)) (range 2 v)))]\n    (and\n     (> x 2)\n     (prime? x)\n     (let\n       [prv (first (filter prime? (range (dec x) 1 -1)))\n        nxt (first (filter prime? (drop (inc x) (range))))]\n       (= (+ x x) (+ prv nxt))))))", "user": "5796d3ebe4b039eba2ecb0ee"}, {"problem": 116, "code": "(fn balanced-prime? [n]\n  (let [factors (cons 2 (iterate (partial + 2) 3))\n        prime? (fn [n] (not-any? #(zero? (mod n %))\n                                 (take-while #(<= % (inc (Math/sqrt n))) factors)))\n        prime-step (fn [n s] (first (drop-while (complement prime?) (rest (iterate (partial + s) n)))))]\n    (and (> n 3)\n         (prime? n)\n         (= n (/ (+ (prime-step n 2) (prime-step n -2)) 2)))))", "user": "53dbca12e4b094d41abdfef6"}, {"problem": 116, "code": "(fn b-prime? [n]\n  (letfn [(prime? [n] (cond\n                        (< n 1) false\n                        (= 2 n) true\n                        (= 3 n) true\n                        (zero? (mod n 3)) false\n                        (zero? (mod n 2)) false\n                        :loop\n                        (loop [i 5 w 2]\n                          (cond\n                            (> (* i i) n) true\n                            (zero?  (mod n i)) false\n                            :loop (recur (+ i w)\n                                         (- 6 w))))))]\n  (cond\n    (prime? n) (let [max-lower-bound-prime (first (filter prime? (rest (range n 2 -2))))\n                     diff (if max-lower-bound-prime (- n max-lower-bound-prime))\n                     min-upper-bound-prime (if diff (first (filter prime? (rest (range n (+ n diff 1) 2)))))]\n                 (if (number? min-upper-bound-prime)\n                   (= n (/ (+ max-lower-bound-prime min-upper-bound-prime ) 2))\n                   false))\n    :default false)))", "user": "58f2e8fbe4b0438e51c2ce94"}, {"problem": 116, "code": "(letfn\n    [(indivisible? [n pl]\n       (not-any? #(zero? (rem n %)) pl))\n     (next-prime [pl]\n       (if (empty? pl)\n         2\n         (let [last-prime (peek pl)]\n           (first (filter #(indivisible? % pl)\n                          (iterate inc last-prime))))))\n     (prime-seq\n       ([]\n        (cons 2 (prime-seq [2])))\n       ([pl]\n        (lazy-seq\n          (let [np (next-prime pl)\n                pl (conj pl np)]\n            (cons np (prime-seq pl))))))\n     (balanced-prime? [n]\n       (let [[a b c :as tuple] (last (take-while (fn [[a b c]] (< a n)) (partition 3 1 (prime-seq))))]\n         (and (= b n)\n              (= b (/ (+ a c) 2)))))]\n    balanced-prime?)", "user": "58ec1e63e4b056aecfd47d54"}, {"problem": 116, "code": "(fn [n]\n  (let\n   [prime?\n    (fn [i]\n      (.isProbablePrime\n       (.toBigInteger\n        (bigint i))\n       100))\n    calc-margin\n      (fn [n chgf]\n        (loop [i (chgf n)]\n          (if\n           (or\n            (neg? i)\n            (prime? i))\n          i\n          (recur (chgf i)))))\n    avg-margin\n      (fn [n]\n        (/ \n         (+\n          (calc-margin n inc)\n          (calc-margin n dec))\n         2))\n    bprime?\n      (fn [n]\n        (and\n         (prime? n)\n         (= n (avg-margin n))))\n    ]\n   (bprime? n)))", "user": "586a657de4b0f14aab7c88bd"}, {"problem": 116, "code": "(fn [x] (letfn [(prime? [x] (and (> x 1)\n                                 (nil? (some #(= 0 (mod x %)) (range 2 x)))))]\n          (and (> x 2)\n               (prime? x)\n               (let [prime (lazy-seq (filter prime? (range)))\n       \n                     left (last (take-while #(< % x) prime))\n                     right (second (drop-while #(< % x) prime))]\n                 \n                   (= x (/ (+ left right) 2))))))", "user": "58b989dbe4b0888cdc949ccd"}, {"problem": 116, "code": "(fn [n]\n  (let [primes (letfn [(reinsert [table x prime] \n                         (update-in table [(+ prime x)] conj prime)) \n                       (primes-step [table d] \n                         (if-let [factors (get table d)] \n                           (recur (reduce #(reinsert %1 d %2) (dissoc table d) factors) (inc d)) \n                           (lazy-seq (cons d (primes-step (assoc table (* d d) (list d)) (inc d))))))] \n                 (primes-step {} 2))]\n               (loop [q (first primes), [p & ps] (rest primes)] \n                 (cond (= n p) (= n (/ (+ q (first ps)) 2)) \n                       (< n p) false \n                       :else (recur p ps)))))", "user": "5566d812e4b0c656e3ff1837"}, {"problem": 116, "code": "(fn [n] (= n (first (drop-while #(< % n) (map second (filter #(= (second %) (/ (+ (first %) (nth % 2)) 2)) (partition 3 1 ((fn f [n] (cons n (lazy-seq (f (first (drop-while (fn [a] (some #(zero? (mod a %)) (take-while #(<= (* % %) a) (f 2)))) (iterate inc (inc n)))))))) 2))))))))", "user": "58987ee9e4b00487982d52d2"}, {"problem": 116, "code": "(fn [n]\n  (and (integer? n) (< 2 n)\n       (let [prime? (memoize\n                     (fn [n]\n                       (and (integer? n) (< 1 n)\n                            (not-any? (comp integer? (partial / n))\n                                      (range 2 (inc (/ n 2))))\n                            n)))]\n         (and (prime? n)\n              (== (* n 2)\n                  (+ (some prime? (iterate inc (inc n)))\n                     (some prime? (iterate dec (dec n)))))))))", "user": "55dcb06ee4b050e68259b3b9"}, {"problem": 116, "code": "(fn\n  [n]\n  (letfn [(prime? [x]\n            (if (= x 1)\n              false\n              (not-any? #(= 0 (mod x %))\n                        (range 2 x))))]\n    (if ((complement prime?) n)\n      false\n      (= n\n         (/ (+ (first (filter prime? (iterate inc (+ n 1))))\n               (first (filter prime? (iterate dec (- n 1)))))\n            2)))))", "user": "5893c64ce4b00487982d524b"}, {"problem": 116, "code": "(fn is-balanced-prime? [n]\n  (let [sieve (atom (iterate inc 2)) \n        remove-factors (fn [factor s]\n                          (filter (fn[x] (not= 0 (mod x factor))) s))  \n        next-prime (fn []\n                     (let [p (first @sieve)\n                           modified-sieve  (remove-factors p @sieve)]\n                       (reset! sieve modified-sieve)\n                       p))]\n    (loop [one (next-prime)\n           two (next-prime)\n           three (next-prime)]\n      (cond (> one n) false\n            (= two n) (= n (/ (+ one three) 2))\n            :else (recur two three (next-prime))))))", "user": "56f4cedce4b046a417f92063"}, {"problem": 116, "code": "(fn [n]\n    (let [[a b c] (take-last 3 ((fn [n]\n                            (letfn [(is-prime [x ps]\n                                      (every? #(not= (rem x %) 0) ps))]\n                              (loop [x 3\n                                     ps (sorted-set 2)]\n                                (if (> (last ps) n)\n                                  (vec ps)\n                                  (if (is-prime x ps)\n                                    (recur (inc x) (conj ps x))\n                                    (recur (inc x) ps)))\n                                ))) n))]\n\n      (and  (= b n) (= (+ c a) (* 2 b)))\n      \n    ))", "user": "5921a080e4b09b4ee5954c77"}, {"problem": 116, "code": "(fn prime-sandswich [num]\n  (if (= num 3)\n    false\n    (let [prime-nums ((fn get-primes [primes sieve]\n                        (lazy-seq\n                          (let [d (first sieve)\n                                r (filter #(pos? (mod % d)) (rest sieve))]\n                            (cons d (get-primes primes r)))))\n                       [] (drop 2 (range)))\n          prev (last (take-while #(< % num) prime-nums))\n          next (some #(and (> % num) %) prime-nums)\n          sandwich (last (take-while #(<= % num) prime-nums))\n          res (and sandwich (= num sandwich) prev next\n                   (= num (quot (+ prev next) 2)))]\n      (if (nil? res) false res))))", "user": "590b3aeae4b047aa04b199d0"}, {"problem": 116, "code": "(fn [x] \n  (if (or (<= x 2) (not (not-any?  #(zero? (rem x %)) (range 2 x)))) false\n    (letfn[(ps [num](filter (fn [n](not-any? #(zero? (mod n %1)) (range 2 n)))(iterate inc num)))]\n      (let[xp (last (take-while #(< % x) (ps 2))) xn (second (ps x))]\n        (= x (/ (+ xp xn) 2))))))", "user": "58e7229fe4b056aecfd47cc4"}, {"problem": 116, "code": "(fn balanced-prime?\n  [n]\n  (let [prime? (fn [x] (= (count (filter #(zero? (mod x %)) (range 2 x))) 0))\n        pre-prim (fn inner-pre [x] (if (prime? x) x (inner-pre (dec x))))\n        next-prim (fn inner-next [x] (if (prime? x) x (inner-next (inc x))))]\n    (and\n      (> n 2)\n      (prime? n)\n(= n (/ (+ (pre-prim (dec n)) (next-prim (inc n))) 2)))))", "user": "59368efbe4b02506e01a297d"}, {"problem": 116, "code": "(fn [n]\n  (let [primes (loop [nums (range 2 2000) ans []]\n                 (if (empty? nums)\n                   ans\n                   (recur (filter #(not= 0 (mod % (first nums))) nums) (conj ans (first nums)))))]\n    (if (and (not= 0 (.indexOf primes n)) (some #(= % n) primes) (= n (/ (+ (nth primes (+ 1 (.indexOf primes n))) (nth primes (- (.indexOf primes n) 1))) 2)))\n      true\n      false)))", "user": "59368ccae4b02506e01a297a"}, {"problem": 116, "code": "(fn [n]\n   (if (< n 5)\n     false\n     (letfn [(isPrime [val]\n               (empty? (filter #(= 0 %) (take (- val 2) (map #(rem val %) (iterate inc 2 ))))))]\n       (let [previous (first (filter #(or (= 1 %) (isPrime %)) (iterate dec (dec n))))\n             next (first (filter isPrime (iterate inc (inc n))))]\n         (and (isPrime n) (not= previous 1) (= n (/ (+ previous next) 2)))\n         ))))", "user": "58d27bcae4b03c36ff7e58fe"}, {"problem": 116, "code": "(fn [n]\n  (let [primes (loop [nums (range 2 2000) ans []]\n                 (if (empty? nums)\n                   ans\n                   (recur (filter #(not= 0 (mod % (first nums))) nums) (conj ans (first nums)))))]\n    (if (and (not= 0 (.indexOf primes n)) (some #(= % n) primes) (= n (/ (+ (nth primes (+ 1 (.indexOf primes n))) (nth primes (- (.indexOf primes n) 1))) 2)))\n      true\nfalse)))", "user": "59369515e4b02506e01a297e"}, {"problem": 116, "code": "(fn balanced-prime? [n]\n  (let [factors (cons 2 (iterate (partial + 2) 3))\n        prime? (fn [n] (not-any? #(zero? (mod n %))\n                                 (take-while #(<= % (inc (Math/sqrt n))) factors)))\n        prime-step (fn [n s] (first (drop-while (complement prime?) (rest (iterate (partial + s) n)))))]\n    (and (> n 3)\n         (prime? n)\n         (= n (/ (+ (prime-step n 2) (prime-step n -2)) 2)))))", "user": "592519cfe4b072a2710fce6b"}, {"problem": 116, "code": "(fn balanced-prime? [n]\n  (let [factors (cons 2 (iterate (partial + 2) 3))\n        prime? (fn [n] (not-any? #(zero? (mod n %))\n                                 (take-while #(<= % (inc (Math/sqrt n))) factors)))\n        prime-step (fn [n s] (first (drop-while (complement prime?) (rest (iterate (partial + s) n)))))]\n    (and (> n 3)\n         (prime? n)\n         (= n (/ (+ (prime-step n 2) (prime-step n -2)) 2)))))", "user": "5948adffe4b07ddc2dafadc6"}, {"problem": 116, "code": "(fn balanced-prime? [n]\n  (let [factors (cons 2 (iterate (partial + 2) 3))\n        prime? (fn [n] (not-any? #(zero? (mod n %))\n                                 (take-while #(<= % (inc (Math/sqrt n))) factors)))\n        prime-step (fn [n s] (first (drop-while (complement prime?) (rest (iterate (partial + s) n)))))]\n    (and (> n 3)\n         (prime? n)\n         (= n (/ (+ (prime-step n 2) (prime-step n -2)) 2)))))", "user": "59251947e4b072a2710fce69"}, {"problem": 116, "code": "(letfn [(prime? [x] (and (> x 1) (not-any? zero? (map #(rem x %) (take-while #(<= (* % %) x) (range 2 x))))))\n\t\t(pNeighbors [n] (let [l (range (dec n) 2 -1) r (drop (inc n) (range))] (map (comp #(nth % 0 0) #(filter prime? %)) [l r])))\n\t\t(balancedPrime? [n] (and (prime? n) (= (* 2 n) (reduce + (pNeighbors n)))))]\n\t\tbalancedPrime?)", "user": "580c8fcee4b0849f6811b721"}, {"problem": 116, "code": "(fn ps [n]\n  (letfn [(isPrime? [n]\n                    (cond\n                      (<= 0 n 1) false\n                      (= n 2) true\n                      :else   (every? #(not= 0 (mod n %)) (range 2 (inc (Math/sqrt n))))))]\n         (cond\n           (< n 1) false\n           (not (isPrime? n)) false\n           :else \n            (let [prevPrime (some #(if (isPrime? %) %) (reverse (range 1 n)))\n                  nextPrime (some #(if (isPrime? %) %) (drop (inc n) (range)))]\n                (and prevPrime (= n (/ (+ prevPrime nextPrime) 2)))))))", "user": "5958cef6e4b066ee0a44af94"}, {"problem": 116, "code": "(fn prim\n  ([x]\n   (if (or (= x 0) (= x 1) (= x 2))\n     false\n     (if (some zero? (map #(mod %1 %2) (repeat x) (range 2 x)))\n       false\n       (prim x (dec x)))))\n  ([x y]\n   (if (some zero? (map #(mod %1 %2) (repeat y) (range 2 y)))\n     (prim x (dec y))       \n     (prim x y (inc x))))\n  ([x y z]\n   (if (some zero? (map #(mod %1 %2) (repeat z) (range 2 z)))\n     (prim x y (inc z))\n     (if (= (/ (+ y z) 2) x)\n       true\n       false))))", "user": "586b6a0ae4b01531a375e957"}, {"problem": 116, "code": "(fn [x]\n    (let [sieve (fn sieve [h & t]\n                      (lazy-seq (cons h (apply sieve (filter #(not= 0 (rem % h)) t)))))\n          primes (apply  sieve (drop 2 (range)))\n          balance_primes \n              (->> primes\n                (partition 3 1 )\n                (filter #(= (* 2 (fnext %)) (+ (first %)  (last %))))\n                (map fnext))]\n    (->> balance_primes\n      (drop-while #(< % x))\n      (first)\n      (= x))))", "user": "593f95d8e4b069cdc2982be3"}, {"problem": 116, "code": "(fn [n]\n  (letfn [(next-prime [n'] (.nextProbablePrime (BigInteger/valueOf n')))\n          (is-prime [n'] (and (> n' 2) (not (some #(= 0 (rem n' %)) (range 2 (inc (int (Math/sqrt n'))))))))]\n    (let [np (next-prime n)\n          pp (- n (- np n))]\n      (and (is-prime n)\n           (= n (next-prime pp))\n           (is-prime pp)\n           (= (- n pp) (- np n))))))", "user": "58ee84e5e4b056aecfd47dab"}, {"problem": 116, "code": "(fn f [n]\n  (let [[a b c] (->> (range)\n                     (drop 2)\n                     ((fn s [[x & r]] (lazy-seq (cons x (s (remove #(zero? (mod % x)) r))))))\n                     (partition 3 1)\n                     (drop-while (fn [[_ b _]] (< b n)))\n                     first)]\n    (and (= b n) (= b (/ (+ a c) 2)))))", "user": "4fb1d7ace4b081705acca281"}, {"problem": 116, "code": "(fn balanced? [n]\n  (letfn [(gen-primes [n]\n    (let [\n          sieve-limit (+ n 50)\n          nullfiy-indexes #(loop [indexes (vec %2) items (vec %1)] (if (empty? indexes) items (recur (rest indexes) (assoc items (first indexes) nil))))\n        ]\n      (loop [prime 2 primes [] sieve (range sieve-limit)]\n        (cond \n          ;return first n primes\n          (= -1 (nth sieve prime -1)) primes\n          ;not prime so don't bother with removing multiples\n          (nil? (nth sieve prime)) (recur (inc prime) primes sieve)\n         \t;remove multiples\n          :else\n            (recur\n              (inc prime)\n              (conj primes prime)\n              (nullfiy-indexes sieve (range (* 2 prime) (count sieve) prime))\n            )\n        )\n      )\n    )\n  )]\n  \n    (if (= 2 n)\n      false\n      (let [primes (gen-primes n) i (.indexOf primes n)]\n        (cond\n          (= i -1) false\n          (= n (/ (+ (nth primes (dec i)) (nth primes (inc i))) 2)) true\n          :else\n            false\n        )\n      )\n    )\n  )\n)", "user": "5991d2fae4b0866487ed0d68"}, {"problem": 116, "code": "(fn [n] \n     (\n       letfn [\n              (isPrime[x] (not (some #(zero? (mod x %)) (range 2 (inc (quot x 2))) )))\n              (primes[] (filter #(isPrime %) (range)))\n              ]\n        (#(and (isPrime n) (> n 2) (= (nth % 1) (/ (+ (first %) (last %)) 2 ))) (take-last 3 (take (inc (count (take-while #(<= % n) (primes)))) (primes))))\n        \n       ))", "user": "596f6683e4b069c0a1a19877"}, {"problem": 116, "code": "(fn [n]\n  (let [prime? (fn [n] (and (pos? n) (not (some #(= 0 (mod n %)) (range 2 n)))))]\n    (if (and (> n 2) (prime? n))\n      (let [np (some #(when (prime? %) %) (iterate inc (inc n)))\n            pp (some #(when (prime? %) %) (range (dec n) 0 -1))]\n        (if (= n (/ (+ np pp) 2))\n          true\n          false))\n      false)))", "user": "590b055ae4b047aa04b199c9"}, {"problem": 116, "code": "(fn[n]\n        (let [prime? (fn[n]\n                       (if (< n 2)\n                         false\n                         (let [candidates (range 2 n)]\n                           (not (some identity\n                                      (map #(zero? (mod n %)) candidates))))))]\n          (and\n           (>= n 5)\n           (prime? n)\n           (let [prev (first (filter prime? (iterate dec (dec n))))\n                 next (first (filter prime? (iterate inc (inc n))))]\n             \n             (= (+ prev next) (* 2 n))))))", "user": "57e6f90de4b0bfb2137f5af6"}, {"problem": 116, "code": "#(if (nil? (some (partial = %) [5,53,157,173,211,257,263,373,563,593,607,653,733,\n 947,977,1103,1123,1187,1223,1367,1511,1747,1753,\n 1907,2287,2417,2677,2903,2963,3307,3313,3637,3733,\n 4013,4409,4457,4597,4657,4691,4993,5107,5113,5303,\n 5387,5393])) false true)", "user": "587ee260e4b052da650a6353"}, {"problem": 116, "code": "(fn balanced-prime? [n]\n  (let [primes-upto (fn [n]\n                      (loop [a (range 2 (inc n))\n                             rv []]\n                        (if (empty? a) rv\n                            (let [fa (first a)\n                                  others (into [] (filter #(not= 0 (rem % fa)) a))]\n                              (recur others (conj rv fa))))))\n        primes (primes-upto (* 2 n))\n        primes-partitions (partition-by #(= % n) primes)\n        pc (count primes-partitions)]\n    (if (= 3 pc)\n      (let [[a b c] primes-partitions\n            before (last a)\n            after (first c)\n            avg (/ (+ before after) 2)]\n        (= n avg))\n      false)))", "user": "5866b999e4b0f14aab7c886b"}, {"problem": 116, "code": "(fn is-prime-sandwich [n]\n    (letfn [\n        (is-prime? [n] (\n            loop [x 2 up (int (Math/sqrt n))]\n            (if (> x up) true\n                (if (zero? (rem n x))\n                    false\n                    (recur (inc x) up)\n                ) \n            )\n        ))\n        (get-close-prime [n f] (let [test (f n)]\n            (if (is-prime? test) test\n            (get-close-prime test f)\n            )\n        ))  \n    ]\n    (and (> n 2) (is-prime? n) (= n (/ (+ (get-close-prime n inc) (get-close-prime n dec) ) 2)))\n    )\n)", "user": "59a0262ee4b0871e7608b82d"}, {"problem": 116, "code": "(fn\n  [n]\n  (letfn [(prime? [p]\n            (when (> p 1)\n              (not-any?\n                #(= 0 (mod p %))\n                (range 2 (dec p)))))\n          (next-prime [p up]\n            (first\n              (filter prime?\n                      (if up\n                        (map #(+ (inc p) %) (range))\n                        (range (dec p) 0 -1)))))]\n    (if (prime? n)\n      (let [p1 (next-prime n false)\n            p2 (next-prime n true)]\n        (if (and p1 p2)\n          (= (/ (+ p1 p2) 2) n)))\n      false)))", "user": "56bb652ae4b0f26550335953"}, {"problem": 116, "code": "(fn balanced-prime? [n] (let [factors (cons 2 (iterate (partial + 2) 3)) \nprime? (fn [n] (not-any? #(zero? (mod n %)) (take-while #(<= % (inc \n(Math/sqrt n))) factors))) prime-step (fn [n s] (first (drop-while \n(complement prime?) (rest (iterate (partial + s) n)))))] (and (> n 3) \n(prime? n) (= n (/ (+ (prime-step n 2) (prime-step n -2)) 2)))))", "user": "59358f74e4b04f87174def52"}, {"problem": 116, "code": "(fn [n]\n            (let [prime? (memoize (fn [x]\n                                    (cond\n                                      (<= x 1) false\n                                      (<= x 3) true\n                                      (or (zero? (mod x 2)) (zero? (mod x 3))) false\n                                      :else\n                                      (loop [c 5]\n                                        (cond\n                                          (>= (* c c) x) true\n                                          (or (zero? (mod x c)) (zero? (mod x (+ c 2)))) false\n                                          :else (recur (+ c 6)))))))]\n              (if-not (prime? n)\n                false\n                (loop [low (dec n) high (inc n)]\n                  (if (< low 2)\n                    false\n                    (let [l-prime (prime? low) h-prime (prime? high)]\n                      (cond\n                        (and l-prime h-prime) true\n                        (or l-prime h-prime) false\n                        :else (recur (dec low) (inc high)))))))))", "user": "536ecd9fe4b0fc7073fd6e76"}, {"problem": 116, "code": "(fn prime-sand [n]\n  (let [coll (loop [coll (range 2 (inc n))\n                    i 0]\n               (if-let [p (nth coll i nil)]\n                 (recur\n                  (filter #(or (<= % p) (not= 0 (mod % p)))\n                          coll)\n                  (inc i))\n                 coll))\n        q (- (* 2 n) (#(nth % (- (count %) 2) 0) coll))]\n    (and (true? (some #(= % n) coll))\n         (letfn [(prime? [r](true? (not-any? #(= 0 (mod r %)) coll)))]\n           (= (filter prime? (range (inc n) (inc q))) (list q))))))", "user": "55f73078e4b06e875b46cea4"}, {"problem": 116, "code": "(fn [v]\n  ((fn [[l m r]] (and (= m v) (= m (/ (+ l r) 2))))\n   (first\n    (drop-while #(> v (second %))\n                (partition 3 1\n                           ((fn sieve [s]\n                              (cons (first s)\n                                    (lazy-seq (sieve (filter #(not= 0 (mod % (first s)))\n                                                             (rest s)))))) (iterate inc 2)))))))", "user": "4e8768f6535dceadca469850"}, {"problem": 116, "code": "(let [prime? (fn [n]\n               (let [n     (int n)\n                     bound (int (/ n 2))]\n                 (loop [d (int 2)]\n                   (cond (> d bound) true\n                         (= 0 (rem n d)) false\n                         :else (recur (inc d))))))\n      prime? (memoize prime?)]\n  (memoize\n    (fn balanced-prime? [x]\n      (let [primes (filter prime? (iterate inc 2))]\n        (loop [[[n-1 n n+1] & more] (partition 3 1 primes)]\n          (cond (= n x) (= n (/ (+ n-1 n+1) 2))\n                (> n x) false\n                :else (recur more)))))))", "user": "59eb63e3e4b0249b7282077c"}, {"problem": 116, "code": "(fn  [n]\n  (letfn \n    [(is-prime? [n]\n        (cond\n          (< n 2) false\n          (= n 2) true\n          (= n 3) true\n          (even? n) false\n          :else (loop [x 3] \n                  (cond\n                    (> (* x x) n) true\n                    (= 0 (mod n x)) false\n                    :else (recur (+ 2 x))))))\n     (next-prime [n step]\n       (loop [x (+ n step)]\n         (cond\n            (is-prime? x) x\n            (< x 2) 0 \n            :else (recur (+ x step)))))]\n    (if (not (is-prime? n)) false \n     (let [a (next-prime n 1)\n           b (next-prime n -1)]\n        (= n (/ (+ a b) 2))))))", "user": "5794fd7be4b0e215f87e8476"}, {"problem": 116, "code": "(fn f\n  [v]\n  (letfn [(is-prime? [n]\n                       (and (<= 2 n)\n                            (or (= 2 n)\n                                (not-any? #(= 0 (mod n %)) (cons 2 (range 3 (inc (Math/sqrt n)) 2))))))]\n    (and (>= v 3) (is-prime? v)\n         (let [p ((fn [x] (if (is-prime? x) x (recur (dec x)))) (dec v))\n               n ((fn [x] (if (is-prime? x) x (recur (inc x)))) (inc v))]\n           (= v (/ (+ p n) 2))))))", "user": "54a11042e4b09f271ff37c49"}, {"problem": 116, "code": "(fn [x]\n  (let [prime? (fn [n]\n                 (not (some #(and\n                               (not= n %)\n                               (zero? (mod n %)))\n                            (range 2 (inc (Math/sqrt n))))))\n        prime-step (fn [n s]\n                     (first (drop-while (complement prime?) (rest (iterate (partial + s) n)))))]\n    (and\n      (> x 3)\n      (prime? x)\n      (= x (/ (+ (prime-step x 2) (prime-step x -2)) 2)))))", "user": "572de985e4b0cd1946bd0f7c"}, {"problem": 116, "code": "(let [prime? (fn [x]\n                 (cond\n                   (> 2 x)\n                   false\n\n                   (#{2 3 5 7 11 13 17 19 23 29\n                      31 37 41 43 47 53 59 61 67 71\n                      73 79 83 89 97 101 103 107 109 113\n                      127 131 137 139 149 151 157 163 167 173\n                      179 181 191 193 197 199 211 223 227 229} x)\n                   true\n\n                   (even? x)\n                   false\n\n                   :else\n                   (empty? (for [i     (range 3 (inc (Math/sqrt x)) 2)\n                                 :when (zero? (rem x i))]\n                             i))))\n        m-prime? (memoize prime?)]\n    (fn [n]\n      (let []\n        (and (m-prime? n)\n             (if-let [prev-prime (first (for [d     (range n) ;;   = n - next-prime + n\n                                              :let  [p (- n (inc d))]\n                                              :when (m-prime? p)]\n                                          p))]\n               (let [maybe-next-prime (- (* 2 n) prev-prime)]\n                 (and (m-prime? maybe-next-prime)\n                      (= maybe-next-prime (first (for [x     (drop\n                                                               (inc n)\n                                                               (range (inc maybe-next-prime)))\n                                                       :when (m-prime? x)]\n                                                   x)))))\n               false)))))", "user": "59fa241ee4b0ca45a743a358"}, {"problem": 116, "code": "(fn [x]\n  (letfn [(nextPrime [y] (first (filter prime? (iterate (partial + 2) (+ 2 x)))))\n          (prevPrime [z] (first (filter prime? (iterate #(- % 2) (- x 2)))))\n          (prime? [w] (case w\n                        0 false\n                        1 false\n                        2 true   \n                        (let [maxdiv (+ 2 (int (Math/sqrt w)))]\n                          (every? #(if (= 1 %) true\n                                     (not= 0 (rem w %)))\n                            (range 1 maxdiv)))))]\n    (case x\n      0 false\n      1 false\n      2 false\n      3 false\n      4 false\n      5 true\n      (and (prime? x) \n           (= x \n             (/ (+ (nextPrime x) (prevPrime x)) \n                2))))))", "user": "53e9a15be4b036ad0777e4ae"}, {"problem": 116, "code": "; problem 116, medium. Prime Sandwich\n(fn is-balanced-prime? [n]\n (letfn [(prime? [x]\n           (if (< x 2)\n             false\n             (not-any? zero? (map #(rem x %) (range 2 x)))) )\n         (primes_to_n [n1] \n            (lazy-seq (for [y (range 2 n1) :when (prime? y) ] y )))]\n   (if (and (> n 3) (prime? n))\n\n(let [prevprime (first (filter prime? (range (dec n) (/ n 2) -1)))\n      nextprime (first (filter prime? (range (inc n) (* n 100))))]\n  (if (= n (/ (+ prevprime nextprime) 2)) \n    true\n    false)\n )\nfalse\n)))", "user": "56f2611fe4b04a395b9a04a2"}, {"problem": 116, "code": "(let [p    (fn [i]\n             (if (< 2 i)\n               (not-any? #(integer? (/ i %)) (range 2 i))))]\n    (fn [n]\n      (and (p n)\n        (->> (iterate inc 2)\n             (filter p)\n             (cons 2)\n             (partition 3 1)\n             (some (fn [[a b c]] \n                        (if (= n b) \n                          (/ (+ a c) 2))))\n             (= n)))))", "user": "53ea5851e4b036ad0777e4e4"}, {"problem": 116, "code": "(fn is-balanced-prime[x]\n  (let [is-prime? (fn [x]\n                    (and (> x 1)\n                         (->> (range 2 x)\n                              (map (fn [y] (/ x y) ))\n                              (filter integer?)\n                              (filter (fn [y] (not= 1 y) ))\n                              (empty? ))))\n        next-prime (first (filter is-prime? (drop-while #(<= % x)(range))))\n        prev-primes\t(filter is-prime? (range (dec x) 1 -1))\n        ]\n    (if (and (is-prime? x)\n             (not-empty prev-primes)\n             (= (- x (first prev-primes)) (- next-prime x)))\n      true\n      false)))", "user": "54f86b8ce4b01ecee9d88828"}, {"problem": 116, "code": "(fn [n]\n  (let [prime? (fn [n] (not-any? #(zero? (rem n %)) (range 2 n)))\n        offset #(loop [v (% n)]\n                  (if (prime? v) (Math/abs (- n v)) (recur (% v))))]\n    (and (< 2 n) (prime? n) (=  (offset inc) (offset dec)))))", "user": "59f91b99e4b0ca45a743a33a"}, {"problem": 116, "code": "(fn bprime [n] \n  (letfn [\n      (dvd [x k]\n         (= 0 (mod x k))\n      )\n      \n      (ndvds [n xs]\n        (if (first xs)  \n          (let [x1 (first xs)]\n        (if (dvd n x1) false\n             (recur n (rest xs))\n        )\n      )\n      true\n        )\n      )   \n          \n      \n    (bprime1 [res k i n]\n     (if (ndvds k res)\n    (let [p1 (res i)  p2 (res (inc i))]\n      (cond (= p2 n (/ (+ p1 k) 2))\n                true\n          (> p2 n)\n                false\n          :else (recur (conj res k) (inc k) (inc i) n )\n      )\n     )\n     (recur res (inc k) i n)\n  )\n    )\n\n          \n    ]\n  \n  (bprime1 [2 3] 4 0 n)\n     \n)\n)", "user": "59ff9424e4b01bb0ae8afd24"}, {"problem": 116, "code": "(fn [n]\n    (let [primes\n          ((fn f [ns]\n             (let [p (first ns)]\n               (lazy-seq\n                 (cons\n                   p\n                   (f (filter\n                        #(not= (mod % p) 0)\n                        (rest ns)))))))\n            (drop 2 (range)))\n          [a b c :as sandwich] (first\n                                 (drop-while\n                                   #(< (second %) n)\n                                   (partition 3 1 primes)))]\n      (and (= b n) (= (* 2 b) (+ a c)))))", "user": "5a2df4a0e4b09cafd31c7f74"}, {"problem": 116, "code": "(fn [z] \n   (if (< z 3)\n     false\n    (let [list_primes (fn [n]\n                        (let [prime? (fn [x primes]\n                                         {:pre [(> x 0)]}\n                                         (cond (= x 1) false\n                                               (= x 2) true\n                                               (= 0 (rem x 2)) false\n                                               :else (loop [temp_primes primes]\n                                                           (if (empty? temp_primes)\n                                                               true\n                                                               (let [p (first temp_primes)\n                                                                     recur_primes (rest temp_primes)]\n                                                                    (if (= 0 (rem x p))\n                                                                        false\n                                                                        (if (< x (* p p))\n                                                                          true\n                                                                          (recur recur_primes))))))))]\n                             (loop [y 3\n                                    i 1\n                                    primes [2]]\n                                   (if (< i n)\n                                       (if (prime? y primes)\n                                           (recur (inc y) (inc i) (conj primes y))\n                                           (recur (inc y) i primes))\n                                       primes))))\n          primes_to_two_z (list_primes (* 2 z))\n          is_prime (= 1 (count (filter (fn [a] (= a z)) primes_to_two_z)))\n          lower_prime (last (filter (fn [a] (< a z)) primes_to_two_z))\n          upper_prime (first (filter (fn [a] (> a z)) primes_to_two_z))\n          q (quot (+ lower_prime upper_prime) 2) \n          r (rem (+ lower_prime upper_prime) 2)] \n      (and is_prime (= r 0) (= q z)))))", "user": "5a34f342e4b0ddc586f153d1"}, {"problem": 116, "code": "(fn [n]\n  (let [prime? \n          (fn [n] (not (some #(zero? (mod n %)) (range 2 (Math/sqrt (inc n))))))\n        prime-before \n          (fn [n] (first (filter prime? (range (dec n) 1 -1))))\n        prime-after\n          (fn [n] (first (filter prime? (range (inc n) Integer/MAX_VALUE))))\n        avg \n          (fn [a b] (/ (+ a b) 2))]\n    (and (> n 2) (prime? n) (= n (avg (prime-before n) (prime-after n))))))", "user": "58f44c07e4b0438e51c2ceb7"}, {"problem": 116, "code": "(fn [x] \n  (let [isPrime (fn [x] \n              \t\t(let [checkList (range 2 (inc (quot x 2)))]\n              \t\t(and (empty? (filter #(zero? (rem x %)) checkList)) (> x 1)))\n              \t)]\n    (if (isPrime x) \n        (let [primeList (take-last 2 (filter isPrime (range 2 (inc x))))\n              prevPrime (if (= (count primeList) 2) (first primeList) 0)\n              possibleNextPrime (if (zero? prevPrime) 0 (- (* x 2) prevPrime))\n              prevOfPossibleNextPrime (first (take-last 2 (filter isPrime (range 2 (inc possibleNextPrime)))))]\n            (and (= prevOfPossibleNextPrime x) (isPrime possibleNextPrime)))\n        false)))", "user": "571172ece4b09c608db70446"}, {"problem": 116, "code": "(fn balanced-prime [n]\n   (let [prime? (fn [x] (every? identity (map #(pos? (mod x %)) (range 2 x))))\n         nearest-prime #(->> (%1 %2) (iterate %1) (filter prime?) first)\n         next-prime (nearest-prime inc n)\n         prev-prime (nearest-prime dec n)]\n      (and (> n 2) (prime? n) (= n (/ (+ next-prime prev-prime) 2)))))", "user": "59f043d0e4b0966464fe6a3d"}, {"problem": 116, "code": "#(let [sieve\n      (fn er [s] (cons (first s)\n                 (lazy-seq (er (filter (fn [x] (not= 0 (mod x (first s)))) (rest s))))))\n      primes (sieve (drop 2 (range)))\n      [a b c] (first (drop-while (fn [[_ x _]] (< x %)) (partition 3 1 primes)))]\n    (= b % (/ (+ a c) 2)))", "user": "5a4de614e4b05d388ecb6bb1"}, {"problem": 116, "code": "#(.contains '(5 53 157 173 211 257 263 373 563 593 607 653 733 947 977 1103) % )", "user": "55d7312ee4b0e31453f64a9f"}, {"problem": 116, "code": "(fn\n  ([n]\n  (let [\n          divisible? #(zero? (mod %1 %2))\n          prime? #(and (> %1 1) (not-any? (partial divisible? %1) (range 2 (inc (Math/sqrt %1)))))\n          step-prime (first (drop-while #(not (prime? %)) (take n (iterate dec (- n 1)))))\n          balanced-prime? (fn [n] (\n                              if (not (and (prime? n) step-prime)) false \n                              (->\n                                (+ step-prime (first (drop-while #(not (prime? %)) (take n (iterate inc (+ n 1))))))\n                                (/ 2)\n                                (= n))\n                             ))\n        ]\n   (balanced-prime? n))))", "user": "5a577954e4b05d388ecb6c68"}, {"problem": 116, "code": "(fn f [p]\n  (let [ps (if (or (zero? p) (= 1 p) (= 2 p) (even? p)) \n               false \n               (loop [n 3 acc [2]] \n                     (cond \n                          \t(and (>= (count acc) 2) (= p (nth acc (- (count acc) 2)) )) (take-last 3 acc)\n                          \t(= p n) (if (some (fn [a] (zero? (mod n a))) acc)\n                                       false\n                                       (recur (+ 2 n) (conj acc n))) \n                          \t(some (fn [a] (zero? (mod n a))) acc) (recur (+ 2 n) acc) \n                          \t:else (recur (+ 2 n) (conj acc n)))))]\n       (if ps ((fn [[a b c]] (= b (/ (+ a c) 2))) ps) false)))", "user": "5a14228fe4b0ff51aa4b3193"}, {"problem": 116, "code": "(fn [n]\n    (let [prime? (fn [x]\n                   (cond\n                     (= x 1) false\n                     (= x 2) true\n                     (= x 3) true\n                     (= (rem x 2) 0) false\n                     (= (rem x 3) 0) false\n                     :else (let [to-check (range 4 (inc (quot x 3)))]\n                             (not (some zero? (map (partial rem x) to-check))))))]\n      (if-not (prime? n)\n        false\n        (let [prev-prime (first (filter prime? (iterate dec (dec n))))\n              next-prime (first (filter prime? (iterate inc (inc n))))\n              balanced? (= n (/ (+ prev-prime next-prime) 2))]\n          balanced?))))", "user": "53716539e4b0fc7073fd6eb1"}, {"problem": 116, "code": "(fn [n]\n  (letfn [(prime? [n]\n            (cond\n              (= n 1) false\n              (= n 2) true\n              (even? n) false\n              :else (every? #((complement zero?) (rem n %)) (range 3 n 2))))\n          ]\n    (if (prime? n)\n      (let [[p1 p2]\n            (first\n             (filter (fn [[x y]] (or (prime? x) (prime? y)))\n                     (iterate (fn [[x y]] [(dec x) (inc y)]) [(- n 1) (+ n 1)])))       ]\n        (and (prime? p1) (prime? p2)))\n      false)))", "user": "53f053ebe4b0742d9025b0d3"}, {"problem": 116, "code": "(fn primes-san\n  [n]\n  (letfn [(primes []\n            (letfn [(step-primes [coll]\n                      (let [head (first coll)]\n                        (lazy-seq (cons head (step-primes (filter #(pos? (mod % head)) coll))))))]\n              (step-primes (range 2 Long/MAX_VALUE))))\n          (blance-primes []\n            (map #(second %) (filter #(= (second %) (/ (+ (first %) (last %)) 2)) (partition 3 1 (primes)))))]\n    (= n (last (take-while #(<= % n) (blance-primes))))))", "user": "565654dae4b0f9d632dd849f"}, {"problem": 116, "code": "(fn psw [k] (let [c-divs (fn [n] (cons 2 (range 3 (* 2 (inc (int (Math/sqrt n))) 2))))\n                    is-prime? (memoize (fn [n] (every? #(not= 0 (mod n %)) (filter #(< % n) (c-divs n)))))\n                    next-prime (fn [n] (first (filter is-prime? (iterate #(+ 2 %) (+ 2 n)))))\n                    prev-prime (fn [n] (first (filter is-prime? (iterate #(- % 2) (- n 2)))))]\n  (and (is-prime? k)\n       (>= k 5)\n       (let [np (next-prime k)\n             pp (prev-prime k)]\n            (= k (/ (+ np pp) 2))))))", "user": "5a566e8fe4b05d388ecb6c51"}, {"problem": 116, "code": "(fn [n]\n  (letfn [(p? [x] (and  (> x 1) (not-any? zero? (map #(mod x %) (range 2 x)))))]\n    (let [s (split-with #(< % n) (filter p? (range)))\n          a (last (first s))]\n      (and (p? n) (not (nil? a)) (= (* 2 n) (+ a (second (last s))))))))", "user": "5a621702e4b0512ff01cd983"}, {"problem": 116, "code": "(fn balanced-prime? [n]\n  (let [is-prime?\n        (fn [n]\n          (if (or (= n 0) (= n 1))\n            false\n            (loop [s (drop 2 (range (+ (int (Math/sqrt n)) 1)))]\n              (if (seq s)\n                (if (= (mod n (first s)) 0)\n                  false\n                  (recur (rest s)))\n                true))))\n        last-prime (fn [n]\n                     (loop [n n]\n                       (if (is-prime? n)\n                         n\n                         (recur (- n 1)))))\n        next-prime (fn [n]\n                     (loop [n n]\n                       (if (is-prime? n)\n                         n\n                         (recur (+ n 1)))))]\n    (if (is-prime? n)\n      (= (- n (last-prime (- n 1))) (- (next-prime (+ n 1)) n))\n      false)))", "user": "5a6b9b95e4b0512ff01cda40"}, {"problem": 116, "code": "(fn bp? [x]\n  (let [prime? (memoize \n                (fn [n]\n                  (.isProbablePrime (.toBigInteger (bigint n)) 100)))\n        previous-prime (memoize\n                         (fn [n]\n                           (if (<= n 2) \n                             2\n                             (if (prime? n) n (recur (dec n))))))\n        next-prime (memoize \n                    (fn [n]\n                      (if (prime? n) n (recur (inc n)))))]\n    (if (not (prime? x)) \n      false\n      (= x (/ (+ (previous-prime (dec x)) (next-prime (inc x))) 2)))))", "user": "57a0f256e4b0c3d858beb8dd"}, {"problem": 116, "code": "(let [prime? (fn [n]\n               (case n\n                 2 2\n                 (when-not (some #(zero? (rem n %))\n                                 (range 2 (inc (int (Math/sqrt n)))))\n                   n)))\n      primes (keep prime? (iterate inc 2))\n      mean   (fn [n1 n2] (/ (+ n1 n2) 2))]\n  (fn [num]\n    (loop [[p1 p2 p3 :as ps] primes]\n      (cond\n        (and (== num p2) (== num (mean p1 p3)))\n        true\n\n        (< num (mean p1 p3))\n        false\n\n        :else\n        (recur (next ps)) ))))", "user": "56441634e4b0018b46ad8c08"}, {"problem": 116, "code": "(fn balanced-prime [n]\n   (let [prime? (fn [x] (every? #(> % 0) (map #(mod x %) (range 2 x))))]\n     (if (or (not (prime? n)) (< n 5))\n       false\n       (let [dec-prime (first (take 1 (filter #(prime? %) (iterate dec (dec n)))))\n             inc-prime (first (take 1 (filter #(prime? %) (iterate inc (inc n)))))\n             mean (/ (+ dec-prime inc-prime) 2)\n             ]\n         (if (= mean n)\n           true\n           false)\n         ))))", "user": "5a4b3abde4b05d388ecb6b81"}, {"problem": 116, "code": "(fn [n]\n   (letfn [(prime? [n]\n             (and (> n 1)\n                  (every? #(not= 0 (mod n %)) (range 2 n))))\n           (find-lower [n]\n             (when (> n 2)\n               (first (filter prime? (iterate dec (dec n))))))\n           (find-upper [n]\n             (when (> n 2)\n               (first (filter prime? (iterate inc (inc n))))))]\n     (true?\n       (and (prime? n)\n            (when-let [l (find-lower n)]\n              (when-let [u (find-upper n)]\n                (= n (/ (+ l u) 2))))))))", "user": "57ee804ee4b0bfb2137f5bbb"}, {"problem": 116, "code": "(fn isSandwich [x]\n  (letfn [(seekUntil [pred update init]\n            (loop [x init]\n              (if (pred x)\n                x\n                (recur (update x))\n                )\n              )\n            )\n          (isPrime [x]\n            (if (< x 2)\n              false\n              (loop [d 2]\n                (if (> d (/ x 2))\n                  true\n                  (if (= 0 (mod x d))\n                    false\n                    (recur (inc d))\n                    )\n                  )\n                )\n              )\n            )\n          ]\n    (if (> x 3)\n      (if (isPrime x)\n        (let [low  (seekUntil isPrime dec (dec x))\n              high (seekUntil isPrime inc (inc x))]\n          (= (* 2 x) (+ low high))\n          )\n        false\n        )\n      false\n      )\n    )\n  )", "user": "562add6de4b00e49c7cb4834"}, {"problem": 116, "code": "(fn [num]\n  (let [\n        is-prime (fn [a]\n                   (if (= a 2)\n                     true\n                     (if (or (< a 2) (= (rem a 2) 0))\n                       false\n                       (let [sq (int (Math/sqrt a))]\n                         (loop [i 3]\n                           (if (> i sq)\n                             true\n                             (if (= (rem a i) 0)\n                               false\n                               (recur (+ i 2))\n                               )\n                             )\n                           )\n                         )\n                       )\n                     )\n                   )\n        closest-prime (fn [a right]\n                        (loop [i 1]\n                          (let [b (+ a (* i (if right 1 -1)))]\n                            (if (is-prime b)\n                              b\n                              (recur (+ i 1))\n                              )\n                            )\n                          )\n                        )\n        ]\n    (and (is-prime num)\n         (not= num 2)\n         (= num\n            (/ (+ (closest-prime num true) (closest-prime num false)) 2)\n            )\n         )\n\n    )\n  )", "user": "5a9e3698e4b0d174b936c7fc"}, {"problem": 116, "code": "(fn [n]\n         (letfn [(eratos\n                   ([] (eratos (map #(+ 2 %) (range))))\n                   ([coll]\n                    (lazy-seq\n                      (cons (first coll) (eratos (filter #((complement =) 0 (mod % (first coll))) coll))))))\n                 (take-until [pred coll]\n                   (lazy-seq\n                     (if (seq coll)\n                       (if (pred (first coll))\n                         (cons (first coll) nil)\n                         (cons (first coll) (take-until pred (rest coll)))))))]\n           (let [p-seq (take-until #(> % n) (eratos))\n                 triplet (drop (- (count p-seq) 3) p-seq)]\n             (and (= n (second triplet)) (= n (/ (+ (first triplet) (last triplet)) 2))))))", "user": "5a9dbb32e4b0d174b936c7f3"}, {"problem": 116, "code": "(fn sandwich-prime? [n]\n  (let [all-primes '(2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 101 103 107 109 113 127 131 137 139 149 151 157 163 167 173 179 181 191 193 197 199 211 223 227 229 233 239 241 251 257 263 269 271 277 281 283 293 307 311 313 317 331 337 347 349 353 359 367 373 379 383 389 397 401 409 419 421 431 433 439 443 449 457 461 463 467 479 487 491 499 503 509 521 523 541 547 557 563 569 571 577 587 593 599 601 607 613 617 619 631 641 643 647 653 659 661 673 677 683 691 701 709 719 727 733 739 743 751 757 761 769 773 787 797 809 811 821 823 827 829 839 853 857 859 863 877 881 883 887 907 911 919 929 937 941 947 953 967 971 977 983 991 997 1009 1013 1019 1021 1031 1033 1039 1049 1051 1061 1063 1069 1087 1091 1093 1097 1103 1109 1117 1123 1129 1151 1153 1163 1171 1181 1187 1193 1201 1213 1217 1223)\n        [a b c] (->> all-primes\n                     (partition 3 1)\n                     (drop-while #(< (second %) n))\n                     (first))]\n    (and (= b n) (= (/ (+ a c) 2) b))))", "user": "58fc92c5e4b0438e51c2cf9a"}, {"problem": 116, "code": "(fn [n]\n  (letfn [(prime? [n] (and (not (#{0 1} n)) (not-any? zero? (map (partial mod n) (range 2 n)))))\n          (next-prime [dir n] (->> n (iterate dir) rest (filter prime?) first))\n          (avg [& args] (/ (apply + args) (count args)))]\n    (and (prime? n)\n         (= n (avg (next-prime inc n) (next-prime dec n))))))", "user": "50310713e4b05b7df5a0b84c"}, {"problem": 116, "code": "(fn sandwich? [n]\n  (letfn [(prime? [m]\n            (cond\n              (> 2 m) false\n              (= 2 m) true\n              (= 3 m) true\n              (zero? (mod m 2)) false\n              true (loop [k 3]\n                     (cond\n                       (zero? (mod m k)) false\n                       (> k (/ m 2)) true\n                       true (recur (+ k 2))))))]\n    (and (prime? n)\n         (loop [a (+ n 2)\n                b (- n 2)]\n           (cond (every? prime? [a b]) true\n                 (not-any? prime? [a b]) (recur (inc a) (dec b))\n                 true false)))))", "user": "5ab564f8e4b073f177442639"}, {"problem": 116, "code": "(fn [n]\n  (letfn [(prime? [n] (every? #(not= (rem n %) 0) (range 2 (inc (Math/sqrt n)))))\n          (next-prime [n] (first (filter prime? (rest (iterate #(+ % 2) n)))))\n          (prev-prime [n] (first (filter prime? (rest (iterate #(- % 2) n)))))]\n    (and \n      (> n 3)\n      (prime? n)\n      (= n (/ (+ (prev-prime n) n (next-prime n)) 3)))))", "user": "5aa998c6e4b0d174b936c8e5"}, {"problem": 116, "code": "(fn[x](\n       let [prime? (fn[x](or (= x 2) (and (> x 2) (not (some zero? (map #(rem x %1) (range 2 (+ 1 (Math/sqrt x)))))))))      \n            next-prime (fn[x](first (drop-while #(not (prime? %)) (iterate inc (+ x 1)))))\n            prev-prime (fn[x](first (drop-while #(not (prime? %)) (iterate dec (- x 1)))))]\n       (and (> x 2) (prime? x) (= (+ (next-prime x) (prev-prime x)) (* 2 x)))))", "user": "58d96bdce4b0a4d5acaab638"}, {"problem": 116, "code": "(fn [p]\n  (letfn [(prime? [n] (and (->> (range 2 n)\n                                (filter #(zero? (rem n %)))\n                                empty?)\n                           n))]\n    (if (prime? p)\n      (let [lower (some prime? (range (dec p) 1 -1))\n            higher (some prime? (range (inc p) (* p p)))]\n        (and (every? number? [p lower higher])\n             (= p (/ (+ higher lower) 2))))\n      false)))", "user": "5ad63a34e4b0ea6055cfac01"}, {"problem": 116, "code": "; This works in clojure 1.5+ but 4clojure uses 1.4 and does not support \"reduced\"\n  #_(fn [p]\n   (letfn [(prime? [p] (and (> p 1) (not-any? #(zero? (mod p %)) (range 2 p))))\n           (count-primes [p q] (count (filter identity [(prime? p) (prime? q)])))\n           (perfect-primes [p] (reduce\n                              #(case (count-primes (- p %2) (+ p %2))\n                                 0 %1\n                                 1 (reduced nil)\n                                 2 (reduced [(- p %2) p (+ p %2)]))\n                              nil (drop 1 (range p))))]\n     (if (prime? p) (perfect-primes p))))\n\n  ; \"reduced2\": nil => uninitialized\n  #_(fn [p]\n    (letfn [(prime? [p] (and (> p 1) (not-any? #(zero? (mod p %)) (range 2 p))))\n            (count-primes [p q] (count (filter identity [(prime? p) (prime? q)])))\n            (reduced2 [old new] (if (nil? old) new old))\n            (check-perfect [p r d] (case (count-primes (- p d) (+ p d))\n                                      0 r\n                                      1 (reduced2 r false)\n                                      2 (reduced2 r true)))\n            (perfect-primes [p] (reduce\n                                 (partial check-perfect p)\n                                 nil\n                                 (drop 1 (range p))))]\n      (and (prime? p) (perfect-primes p))))\n  \n  ; inspired by dwelte, daowen, aceeca1\n  #_(fn [p]\n    (let [slow-prime? (fn [p] (if (and (> p 1) (not-any? #(zero? (mod p %)) (range 2 p))) p false))\n          prime? (memoize slow-prime?)\n          lower-prime (fn [p] (some prime? (reverse (drop 2 (range p)))))\n          upper-prime (fn [p] (some prime? (range (inc p) (+ p p))))]\n       (and (prime? p)\n         (if-let [lp (lower-prime p)]\n           (if-let [up (upper-prime p)]\n             (= (+ p p) (+ lp up)))))))\n  \n\n; inspired by adereth  \n(fn [n]\n (and (> n 3)\n  (let [slow-prime? (fn [x] (every? #(< 0 (mod x %)) (range 2 x)))\n        p (memoize slow-prime?)\n        b (first (filter p (reverse (range 2 n))))\n        a (first (filter p (drop (+ n 1) (range))))]\n    (and (p n) (= (+ n n) (+ a b))))))", "user": "5a544eeee4b05d388ecb6c24"}, {"problem": 116, "code": "(fn balanced-prime?\n  [x]\n  (letfn [(is-prime? [x]\n            (and (> x 2)\n                 (empty? (filter #(zero? (rem x %)) \n                                 (range 2 (inc (Math/pow x 0.5)))))))\n          (next-prime [x int-range]\n            (first (drop-while #(not (is-prime? %)) int-range)))]\n    (and (is-prime? x)\n         (when-let [previous-prime (next-prime x (range (dec x) -1 -1))]\n           (= (double x) \n              (/ (+ previous-prime\n                    (or (next-prime x (range (inc x) \n                                             (inc (+ x (- x previous-prime))))) 0))\n                 2.0))))))", "user": "4daeabf6edd6309eace4d15c"}, {"problem": 116, "code": "(fn [n]\n    (letfn [(is-prime? [x]\n              (if (>= x 2)\n                (loop [i 2]\n                  (if (<= (* i i) x)\n                    (if (zero? (rem x i))\n                      false\n                      (recur (inc i)))\n                    true))))\n            (find-prime [x f]\n              (when (> x 1)\n                (if (is-prime? x)\n                  x\n                  (recur (f x) f))))]\n      (if (is-prime? n)\n        (let [next-prime (find-prime (inc n) inc)\n              prev-prime (find-prime (dec n) dec)]\n          (if (and next-prime prev-prime)\n            (= (/ (+ prev-prime next-prime) 2) n)\n            false))\n        false)))", "user": "569f4dabe4b0542e1f8d1491"}, {"problem": 116, "code": "(fn is-balanced-prime? [n]\n  (letfn [(is-prime? [n]\n            (let [numbers-to-test (range 1 n)]\n                (= 1 (count (filter #(= 0 (mod n %)) numbers-to-test)))))]\n         (and (is-prime? n)\n              (> n 2)\n              (let [primes (filter is-prime? (range))\n                    prior (last (take-while #(> n %) primes))\n                    successor (first (drop-while #(not (< n %)) primes))]\n                (= n (/ (+ prior successor) 2))))))", "user": "57b9fb56e4b0fbc9809a27fa"}, {"problem": 116, "code": "(let [isp (fn [n] (if (< n 2) false (loop [i 2] (cond (= i n) true (zero? (mod n i)) false :else (recur (inc i))))))] (fn [n] (and (> n 2) (isp n) (let [pp (loop [r (dec n)] (if (isp r) r (recur (dec r)))) np (loop [r (inc n)] (if (isp r) r (recur (inc r))))] (= n (/ (+ pp np) 2))))))", "user": "5abe2fc2e4b073f17744271e"}, {"problem": 116, "code": "(fn [n]\n  (and\n    (not-any? #(zero? %) (map #(mod n %) (range 2 n)))\n    (->>\n      (map +\n        (filter\n          (fn [m]\n            (not-any? #(zero? %) (map #(mod m %) (range 2 m))))\n          (drop 2 (range)))\n        (filter\n          (fn [m]\n            (not-any? #(zero? %) (map #(mod m %) (range 2 m))))\n          (drop 4 (range))))\n      (filter #(= (mod % 2) 0))\n      (map #(quot % 2))\n      (filter (fn [m] \n                (not-any? #(zero? %) (map #(mod m %) (range 2 m)))))\n      (take-while #(>= n %))\n      (last)\n      (= n))))", "user": "5af907e6e4b0cc2b61a3bcda"}, {"problem": 116, "code": "(fn [x]\n  (let [prime? (fn [n] (not-any? zero? (map #(mod n %) (range 2 n))))\n        low (first (filter prime? (iterate dec (dec x))))\n        high (first (filter prime? (iterate inc (inc x))))]\n    (and\n     (> x 3)\n     (prime? x)\n     (= x (/ (+ low high) 2)))))", "user": "5b02a170e4b0cc2b61a3bd52"}, {"problem": 116, "code": "(fn [n]\n  (letfn [(prime? [n]\n            (and (> n 1) (not-any? #(zero? (mod n %)) ((comp #(range 2 %) inc int #(Math/sqrt %)) n))))]\n    (let [r (second (filter prime? (iterate inc n)))\n          l (- n (- r n))]\n      (and (prime? n) (prime? l) (not-any? prime? (range (inc l) n))))))", "user": "5953bdb6e4b066ee0a44aeed"}, {"problem": 116, "code": "(fn [n]\n (letfn [(prime? [n]\n  (cond\n   (< n 2) false\n   (= n 2) true\n   :else (not-any? #(= 0 (mod n %)) (cons 2 (range 3 (inc (Math/sqrt n)) 2)))))]\n  (and (prime? n) (>= n 5)\n   (= n (/ (+\n    (first (filter prime? (range (inc n) (* 2 n) 1)))\n    (first (filter prime? (range (dec n) 1 -1))) ) 2))) ))", "user": "5b0180cfe4b0cc2b61a3bd47"}, {"problem": 116, "code": "(fn [n] \n  (and (> n 4)\n    (let [fp      #(every? (comp pos? (partial mod %)) (range 2 %))\n          fps     #(filter fp (range % (+ % %)))\n          [c d]   (fps n)\n          l       (- d c)\n          [a b]   (fps (- n l))]\n      (= n b c (+ a l)))))", "user": "575ddfd1e4b02ea11479938d"}, {"problem": 116, "code": "(fn prime-sandwich [num]\n  (if (> num 2)\n    (letfn [(prime? [n] (not-any? zero? (map #(rem n %) (range 2 n))))]\n      (if (prime? num)\n        (let [prev-prime (first (filter prime? (iterate dec (dec num))))\n              next-prime (first (filter prime? (iterate inc (inc num))))]\n          (= num (/ (+ prev-prime next-prime) 2)))\n        false))))", "user": "53fe1b42e4b0de5c418485f1"}, {"problem": 116, "code": "(fn balanced? [p]\n  (letfn [(is-prime [x] (not (some #(= (mod x %) 0) (range 2 (dec x)))))\n          (primes [x] (lazy-seq (if (is-prime x)\n                                  (cons x (primes (inc x)))\n                                  (primes (inc x)))))]\n    (let [[lhs rhs] (split-with #(< % p) (primes 2))]\n      (when (seq lhs)\n        (if (not= (first rhs) p)\n          false\n          (= (/ (+ (last lhs) (second rhs)) 2) p))))))", "user": "5b13ba71e4b0cc2b61a3be53"}, {"problem": 116, "code": "(fn balanced-prime? [x]\n  (loop [[a b c & _ :as primes]\n         ((fn gen-primes [[p & ps]] \n              (cons p (lazy-seq (gen-primes (filter #(> (rem % p) 0) ps)))))\n            (drop 2 (range)))]\n    (and (<= b x)\n      (if (= b x) \n        (= b (/ (+ a c) 2)) \n        (recur (rest primes))))))", "user": "5af8221ce4b0cc2b61a3bccd"}, {"problem": 116, "code": "#(let [prime %\n         primes ((fn sieve [[f & r]]\n                   (cond\n                     (empty? r) ()\n                     :else\n                     (cons f (sieve (remove (fn [n] (zero? (mod n f))) r)))))\n                 (range 2 1200))]\n     (cond\n       (< prime 5) false\n       (not-any? (fn [p] (= prime p)) primes) false\n       :else\n       (let [pos (.indexOf primes prime)\n             prime-before (nth primes (dec pos))\n             prime-after (nth primes (inc pos))]\n         (= prime\n            (/ (+ prime-before prime-after)\n               2)))))", "user": "4e6a23d0535d8ccf87e9fea0"}, {"problem": 116, "code": "(fn is-prime-balanced? [x]\n  (letfn [(is-prime? [n]\n    (cond (< n 2) false\n          (= n 2) true\n          (= (rem n 2) 0) false\n          :else (let [interval (range 3 (/ n 2) 2)\n                      interval-count (count interval)]\n                      (->> interval\n                        (take-while #(not= (rem n %) 0))\n                        count\n                        (= interval-count)))))]\n  (cond (not (is-prime? x)) false\n        (= 2 x) false\n        (= 3 x) false\n        :else (let [before-prime (dec (last (take-while #(not (is-prime? %)) (range (dec x) (/ x 2) -1))))\n              after-prime (inc (last (take-while #(not (is-prime? %)) (range (inc x) (* x 2)))))]\n          (= x (/ (+ before-prime after-prime) 2))))))", "user": "5b15811ee4b0cc2b61a3be6f"}, {"problem": 116, "code": "(fn w [n] (let [isprime (fn [n] (nil? (some #(= 0 (mod n %)) (range 2 (inc (int (Math/sqrt n)))))))\n              prevprime (fn [n] (first (filter isprime (range (dec n) 1 -1))))]\n          (if (isprime n)\n            (let [p (prevprime n)]\n              (and (not (nil? p)) (isprime p) (isprime (- (* 2 n) p)) (= n (prevprime (- (* 2 n) p)))))\n            false)))", "user": "5b4b4052e4b02d533a91bc9a"}, {"problem": 116, "code": "(fn balanced-prime? [n]\n  (let [is-prime? (fn [n] (every? #(pos? (rem n %)) (range 2 n)))\n        primes (filter is-prime? (drop 2 (range)))\n        neighbours (fn [x coll]\n                     (let [[a b c & more] coll]\n                       (if (= b x)\n                         [a c]\n                         (recur x (rest coll)))))]\n    (if (or (< n 3) (not (is-prime? n)))\n      false\n      (= n (/ (apply + (neighbours n primes)) 2)))))", "user": "5b51b9f8e4b02d533a91bcfe"}, {"problem": 116, "code": "(let [sqrt (fn [x] (first (filter #(> (* % %) x) (range))))\n      composite (fn [x] (some #(= (rem x %) 0) (range 2 (sqrt x))))\n      findprime (fn [x dx] (- (first (filter #(not (composite %)) (map #(+ x (* dx (inc %))) (range)))) x))]\n  (fn [x] (and (> x 2) (not (composite x)) (= (findprime x 1) (- 0 (findprime x -1))))))", "user": "5b465b8be4b02d533a91bc65"}, {"problem": 116, "code": "(fn [n] \n  (contains? #{5 53 157 173 211 257 263 373 563 593 607 653 733 947 977 1103} n))", "user": "57ee82b1e4b0bfb2137f5bbd"}, {"problem": 116, "code": "(fn __ [n]\n  (let [prime?\n        (fn [n]\n          (and (> n 1)\n               (not\n                (some #(zero? (mod n %))\n                      (range 2 n)))))\n\n        find-prime-below\n        (fn [n]\n          (if (> n 2)\n            (first (filter prime? (range (dec n) 1 -1)))\n            0))\n\n        find-prime-above\n        (fn [n]\n          (if (> n 1)\n            (first (filter prime? (iterate inc (inc n))))\n            0))]\n\n    (if (prime? n)\n      (and (= (* 2 n)\n              (+\n               (find-prime-below n)\n               (find-prime-above n))))\n      false)))", "user": "5a0ce1a5e4b04bbd27e6d9b7"}, {"problem": 116, "code": "(fn [n]\n  (letfn [(isp [x] (nil? (some #(if (= 0 (mod x %)) %) (range 2 x))))\n          (ffp [s] (some (fn [x] (if (isp x) x)) s))\n          (avg [a b] (/ (+ a b) 2))]\n    (and (> n 2) (isp n)\n     (= n (avg (ffp (reverse (range 2 n)))\n               (ffp (drop (inc n) (range))))))))", "user": "5b008bcae4b0cc2b61a3bd3d"}, {"problem": 116, "code": "(fn [n]\n (letfn [(prime? [n]\n  (cond\n   (< n 2) false\n   (= n 2) true\n   :else (not-any? #(= 0 (mod n %)) (cons 2 (range 3 (inc (Math/sqrt n)) 2)))))]\n  (and (prime? n) (>= n 5)\n   (= n (/ (+\n    (first (filter prime? (range (inc n) (* 2 n) 1)))\n    (first (filter prime? (range (dec n) 1 -1))) ) 2))) ))", "user": "5b61aa6ae4b0c6492753e712"}, {"problem": 116, "code": "(fn [n]\n  (letfn [(f [s]\n            (cons (first s)\n                  (lazy-seq (f (filter\n                                 #(not= 0 (mod % (first s)))\n                                 (rest s))))))\n          (f1 [[h & t]] \n               (cond \n                (= h n) true\n                (> h n) false\n                :else (f1 t)))]\n    (->> (f (iterate inc 2))\n      (partition 3 1)\n      (filter (fn [[a b c]] (= b (/ (+ a c) 2))))\n      (map second)\n      f1)))", "user": "5b59d176e4b02d533a91bd86"}, {"problem": 116, "code": "(letfn [(prime?\n            [n]\n            (cond\n              (<= n 1)\n              false\n              (<= n 3)\n              true\n              (or (= 0 (mod n 2))\n                  (= 0 (mod n 3)))\n              false\n              :else\n              (loop [i 5]\n                (if (<= (* i i) n)\n                  (if (or (= 0 (mod n i))\n                          (= 0 (mod n (+ i 2))))\n                    false\n                    (recur (+ i 6)))\n                  true))))]\n    (fn prime-sando [n]\n      (and\n       (<= 5 n)\n       (prime? n)\n       (let [neighbors [(some (fn [i] (when (prime? i)\n                                        i))\n                              (take-while #(<= 2 %)\n                                          (rest (iterate dec n))))\n                        (some (fn [i] (when (prime? i)\n                                        i))\n                              (rest (iterate inc n)))]]\n         (= n (/ (reduce + neighbors) 2))))))", "user": "54246fcce4b01498b1a71aed"}, {"problem": 116, "code": "(fn balanced-prime [x]\n  (let [prime?        (fn [n]\n                        (cond (<= n 1)                                 false\n                              (every? #(not= 0 (mod n %)) (range 2 n)) true\n                              :else                                    false))\n        primes        (filter prime? (range))\n        candidates    (partition 3 1 primes)\n        balanced-test (fn  [[a b c]]\n                        (= b (/ (+ a c) 2)))\n        balanced-primes (map second (filter balanced-test candidates))\n        in-ordered-seq (fn ios [x s]\n                         (cond (= x (first s)) true\n                               (< (first s) x) (ios x (rest s))\n                               (< x (first s)) false))]\n    (in-ordered-seq x balanced-primes)\n   ))", "user": "583048d9e4b051871117c007"}, {"problem": 116, "code": "(fn [n]\n  (if (even? n) false\n    (letfn [\n      (inc-odd [x] (+ x (if (even? x) 1 2)))\n      (balanced? [[a b c]] (= b (/ (+ a c) 2)))\n      (divisors [x] \n        (filter #(zero? (rem x %))\n          (cons 2 (range 3 x 2))))\n      (prime? [x] (empty? (divisors x)))\n      (next-prime [after] \n        (loop [x (inc-odd after)] \n          (if (prime? x)  x (recur (inc-odd x)))))]\n        \n      (let [primes (cons 2 (iterate next-prime 3))]\n         \n      (->> primes\n        (partition 3 1)\n        (take-while (fn [[_ p _]] (<= p n)))\n        (filter balanced?)\n        (some #(= n (second %)))\n        (boolean))))))", "user": "4fc4eb1ee4b081705acca354"}, {"problem": 116, "code": "(fn balanced-prime? [n]\n  (letfn [(sieve [n]\n            (loop [s (set (range 2 n)) i 2]\n              (if (>= i n) s\n                (recur (apply disj s (range (+ i i) n i)) (inc i)))))]\n    (boolean\n      (let [p (sieve (* 2 n))]\n        (when (contains? p n)\n          (let [ps (sort p) ni (.indexOf ps n)]\n            (when (< 0 ni (count ps))\n              (= (* 2 n) (+ (nth ps (inc ni)) (nth ps (dec ni)))))))))))", "user": "5b1e5bfde4b03cfeda66ed0e"}, {"problem": 116, "code": "(let [not-prime?\n        (fn [x]\n          (cond\n            (< x 2) true\n            (= x 2) false\n            (even? x) true\n            :else (let [max-factor (inc (int (Math/sqrt x)))]\n                    (some #(zero? (mod x %)) (range 3 max-factor 2)))))\n        first-prime-before\n        (fn [x]\n          (first (drop-while not-prime?\n                             (range (dec x) (- x 100) -1))))\n        \n        first-prime-after\n        (fn [x]\n          (first (drop-while not-prime?\n                             (range (inc x) (+ x 100)))))]\n    (fn [n]\n      (let [first-before (first-prime-before n)]\n        (if (nil? first-before)\n          false\n          (and (not (not-prime? n))\n               (or (= (- (first-prime-after n) n)\n                      (- n first-before))))))))", "user": "539fa040e4b0ca733b97449f"}, {"problem": 116, "code": "(let [prime?\n              (fn [num]\n                (if (<= num 1)\n                  false\n                  (not-any?\n                   #(= 0 (mod num %))\n                   (range 2 (+ 1 (Math/floor (Math/sqrt num)))))))]\n          (fn [num]\n            (and (prime? num)\n                 (if (<= num 2)\n                   false\n                   (= num (/ (+ (first (filter prime? (range (dec num) 1 -1)))\n                                (first (filter prime? (iterate inc (inc num))))) 2))))))", "user": "52fac708e4b047fd55836fff"}, {"problem": 116, "code": "(fn ps\n  [n]\n  (letfn [(prime? [c]\n            (if (< c 2)\n              false\n              (->> (range 2 c)\n                   (filter #(zero? (rem c %)))\n                   empty?)))]\n    (if (and (< 2 n) (prime? n))\n      (let [primes (filter prime? (range))\n            previous-prime (->> primes\n                                (take-while (partial > n))\n                                last)\n            next-prime (->> primes\n                            (drop-while (partial >= n))\n                            first)]\n        (= n (/ (+ previous-prime next-prime) 2)))\n      false)))", "user": "57ea2c91e4b0bfb2137f5b42"}, {"problem": 116, "code": "(fn [b]\n  ;; b is the candiate balanced prime.\n  ;; n is the next integer to check.\n  ;; ps is a vector of the primes computed so far.\n  ;; p1, p2, p3 are the largest three computed primes.\n  ;; Compute more primes until p3 > b.\n  ;; Return true if b = p2 = mean of p1,p3.\n  (loop [p3 0, n 2, ps []]\n    (if (> p3 b)\n      (let [cnt (count ps)\n            p2 (get ps (- cnt 2))\n            p1 (get ps (- cnt 3))]\n        (and (>= cnt 3)\n             (= b p2 (/ (+ p1 p3) 2))))\n      ;; p is prime if not divisible by any previous prime.\n      (if (some #(zero? (mod n %)) ps)\n        (recur p3 (inc n) ps)\n        (recur n (inc n) (conj ps n))))))", "user": "50fbf811e4b0d10d794c19f1"}, {"problem": 116, "code": "(fn prime-sandwich [n]\n  (let [poppeek (fn [n]\n                  (when (seq n) (-> n pop peek)))\n        prime? (fn [n primes]\n                 (let [primes (remove #{n} primes)]\n                   (not-any? (fn [p]  (integer? (/ n p))) primes)))\n        gen-primes (fn [number]\n                     (when (> number 1)\n                       (loop [n 2\n                              primes []]\n                         (cond\n                           (and (prime? number primes)\n                                (= number (poppeek primes))) primes\n                           (and (> n number) (false? (prime? number primes))) nil\n                           (prime? n primes) (recur (inc n) (conj primes n))\n                           :else (recur (inc n) primes)))))\n        primes (gen-primes n)\n        sandwich? (fn [[x y z]] (= y (-> (+ x z) (/ 2))))]\n    (boolean (when (< 2 (count primes)) (sandwich? (take-last 3 primes))))))", "user": "505d1b01e4b0e6aca564be04"}, {"problem": 116, "code": "(fn [n] (letfn [(prime [n] (loop [p [2] i 3]\n                                        (if (>= (last p) n) p\n                                             (if (every? #(pos? (rem i %)) p)\n                                               (recur (conj p i) (+ 2 i))\n                                               (recur p (+ 2 i))))))]\n                     (let [s (prime (inc n)) s3 (drop (- (count s) 3) s)]\n                       (and (= n (second s3)) (= (+ n n) (+ (first s3) (last s3)))))))", "user": "5b924123e4b0c0b3ffbd4a34"}, {"problem": 116, "code": "(fn balanced-prime? [n]\n  (let [factors (cons 2 (iterate (partial + 2) 3))\n        prime? (fn [n] (not-any? #(zero? (mod n %))\n                                 (take-while #(<= % (inc (Math/sqrt n))) factors)))\n        prime-step (fn [n s] (first (drop-while (complement prime?) (rest (iterate (partial + s) n)))))]\n    (and (> n 3)\n         (prime? n)\n         (= n (/ (+ (prime-step n 2) (prime-step n -2)) 2)))))", "user": "5bbdd136e4b07a9b28b0ffab"}, {"problem": 116, "code": "(fn [x]\n  (let [p? (fn [x]\n             (if (< x 2)\n               false\n               (let [d (range 2 (inc (int (Math/sqrt x))))\n                     r (map #(rem x %) d)]\n                 (not (some zero? r)))))]\n    (if (not (p? x))\n      false\n      (let [up (fn up [x] (if (p? x) x (recur (inc x))))\n            dn (fn dn [x] (if (= x 1) 0 (if (p? x) x (recur (dec x)))))\n            u (up (inc x))\n            d (dn (dec x))]\n        (if (= (/ (+ u d) 2) x)\n          true\n          false)))))", "user": "566d71b1e4b0a866af6896ca"}, {"problem": 116, "code": "(let [prime? (fn [n]\n                 (not-any? #(= (mod n %)\n                               0)\n                           (drop 2 (range n))))\n        primes (filter prime?\n                        (drop 2 (range)))]\n    (fn [n]\n      (if-not (prime? n)\n        false\n        (let [lfts (take-while #(< % n) primes)\n              rgts (drop-while #(< % n) primes)\n              lft  (last lfts)\n              rgt  (first (rest rgts))\n              mean? (when lft\n                      (= (/ (+ lft rgt)\n                            2)\n                         n))]\n          mean?))))", "user": "5be5cebde4b0ed4b8aab4d19"}, {"problem": 116, "code": ";; Requirements don't demand that we calculate all primes up to n so we'll\n  ;; just start at n and test pairs walking away from n both directions.\n  ;; This is much faster for larger values of n\n  (fn [n]\n    (letfn [(prime? [x] (not-any? #(zero? (rem x %)) (range 2 (inc (Math/sqrt x)))))]\n      (and (> n 3)\n           (prime? n)\n           (= [true true]\n              (->> (iterate inc 2)\n                   (filter even?)\n                   (map #(vector (prime? (+ n %)) (prime? (- n %))))\n                   (drop-while #(= % [false false]))\n                   first)))))", "user": "54f26266e4b024c67c0cf8c5"}, {"problem": 116, "code": "(fn [n]\n  (letfn [(prime? [n]\n            (and (>= n 0)\n                 (not (some zero? (map #(mod n %) (take-while #(<= (* % %) n) (iterate inc 2)))))))]\n    (case n\n      0 false\n      1 false\n      2 false\n      (let [next (first (filter prime? (iterate inc (inc n))))\n            prev (first (filter prime? (iterate dec (dec n))))]\n        (and (prime? n) (= n (/ (+ next prev) 2)))))))", "user": "5afb4b15e4b0cc2b61a3bcf6"}, {"problem": 116, "code": "(fn [p]\n  (letfn [\n          (isprime [i] (and (> i 1) (every? #(> (mod i %) 0) (range 2 (inc (/ i 2))))))\n          (prange [f] (map #(f p %) (drop 1 (range))))\n          (pfirst [f] (first (filter isprime (prange f))))]\n      (boolean (and (> p 2) (isprime p) (= p (/ (+ (pfirst +) (pfirst -)) 2))))))", "user": "5b919d9de4b0c0b3ffbd4a24"}, {"problem": 116, "code": "(fn balanced-prime?\n  [n]\n  (letfn [(prime-sieving\n            ([] (prime-sieving (iterate inc 2)))\n            ([[f & r]] (lazy-seq (cons f (prime-sieving (remove #(= 0 (mod % f)) r))))))\n\n          (balanced-primes\n            []\n            (->> (prime-sieving)\n                 (partition 3 1)\n                 (filter (fn [[a me b]] (= me (/ (+ a b) 2))))\n                 (map second)))]\n    (= n (first (drop-while #(< % n) (balanced-primes))))))", "user": "5b759ca8e4b047b03b2036d0"}, {"problem": 116, "code": "(fn problem-116\n  [n]\n  (let [primes\n        (->> [#{2} 3 true]\n             (iterate (fn it [[ps cur prime?]]\n                        (->> (+ 2 cur)\n                             ((juxt identity\n                                    (fn meh [next]\n                                      (not-any? #(zero? (mod next %))\n                                                ps))))\n                             (cons (if prime?\n                                     (conj ps cur)\n                                     ps)))))\n             (filter last)\n             (map second)\n             (cons 2))]\n    (->> primes\n         (partition 3 1)\n         (drop-while (fn [[_ m _]] (< m n)))\n         (first)\n         ((fn [[l m r]]\n            (= m n (/ (+ l r) 2)))))))", "user": "58e37946e4b005f69f193cae"}, {"problem": 116, "code": "(fn [x]\n  (letfn [ (prms [rst]\n(lazy-seq\n(if-let [a (first rst)]\n(if (< a 2) (prms (rest rst))\n(cons a (prms (filter  #(not= 0 (mod % a)) rst)) )\n) nil )))\n   \t\t\t(bal [coll]\n(lazy-seq\n(if-let [a (first coll)]\n(if-let [b (first (rest coll))]\n(if-let [c (first (rest (rest coll)))]\n(if (= b (/ (+ a b c) 3)) (cons b (bal (rest coll))) (bal (rest coll))\n)\nnil) nil) nil)\n)\n)        \n          ]\n      (= x (last (take-while #(<= % x) (bal (prms (range))))))\n  )\n  \n)", "user": "5be6d0f8e4b0f319e2d7ec51"}, {"problem": 116, "code": "(fn cool?\n  ([n] (let [primes (vec (take 1000 (cool?)))\n             i (.indexOf primes n)]\n         (if-not (< i 2)\n          (= n (/\n                  (+ (get primes (inc i) 1)\n                     (get primes (dec i) 1))\n                  2))\n          false)))\n  ([]\n    (letfn [(enqueue [sieve n step]\n              (let [m (+ n step)]\n                (if (sieve m)\n                  (recur sieve m step)\n                  (assoc sieve m step))))\n            (next-sieve [sieve candidate]\n              (if-let [step (sieve candidate)]\n                (-> sieve\n                  (dissoc candidate)\n                  (enqueue candidate step))\n                (enqueue sieve candidate (+ candidate candidate))))\n            (next-primes [sieve candidate]\n              (if (sieve candidate)\n                (recur (next-sieve sieve candidate) (+ candidate 2))\n                (cons candidate\n                  (lazy-seq (next-primes (next-sieve sieve candidate)\n                              (+ candidate 2))))))]\n      (cons 2 (lazy-seq (next-primes {} 3))))))", "user": "5ba15075e4b0a20761a2339e"}, {"problem": 116, "code": "(fn mean-prime?\n  [n]\n  (letfn [(prime-iter [n k limit]\n            (cond (> (* n n) limit) true\n                  (zero? (rem limit n)) false\n                  :else (recur (+ n k) (- 6 k) limit)))\n          (prime? [n]\n            (cond (< n 2) false\n                  (= n 2) true\n                  (= n 3) true\n                  (or (= 0 (mod n 2)) (= 0 (mod n 3))) false\n                  (< n 9) true\n                  :else (prime-iter 5 2 n)))]\n    (let [next-prime (first (drop-while (complement prime?) (iterate inc (inc n))))\n          prev-prime (first (drop-while (complement prime?) (range (- n 1) 0 -1)))]\n      (if (< n 3) false \n        (and (prime? n) (= n (/ (+ next-prime prev-prime) 2)))))))", "user": "5c222b7de4b07e362c230588"}, {"problem": 116, "code": "(fn balanced-prime?\n  [n]\n  (letfn [(prime?\n            [n]\n            (cond\n              (< n 2) false\n              (= n 2) true\n              (= n 3) true\n              (= 0 (rem n 2)) false\n              (= 0 (rem n 3)) false\n              :else (loop [i 5 w 2]\n                      (if (> (* i i) n)\n                        true\n                        (if (zero? (rem n i))\n                          false\n                          (recur (+ i w) (- 6 w)))))))]\n    (if (prime? n)\n      (let [higher (first (filter prime? (range (inc n) (Integer/MAX_VALUE))))\n            lower (first (filter prime? (range (dec n) 0 -1)))\n            ]\n        (if (and lower (= n (/ (+ higher lower) 2)))  true false)\n        )\n      false\n      )\n    )\n  )", "user": "5c20b6abe4b07e362c230576"}, {"problem": 116, "code": "(fn [n]\n  (let [prime? (fn [m](every? #(not (zero? (mod m %))) (range 2 m)))]\n    (cond\n     (even? n) false\n     (< n 5) false\n     (= n 5) true\n     (prime? n) (loop [ln (- n 2)\n                       rn (+ n 2)]\n                  (cond\n                   (not (prime? ln)) (recur (- ln 2) rn)\n                   (not (prime? rn)) (recur ln (+ rn 2))\n                   :else (= (+ n n) (+ ln rn))\n                   ))\n     :else false\n     )))", "user": "5c0e3f86e4b01240ff56713d"}, {"problem": 116, "code": "(fn balanced-prime? [n]\n  (let [factors (cons 2 (iterate (partial + 2) 3))\n        prime? (fn [n] (not-any? #(zero? (mod n %))\n                                 (take-while #(<= % (inc (Math/sqrt n))) factors)))\n        prime-step (fn [n s] (first (drop-while (complement prime?) (rest (iterate (partial + s) n)))))]\n    (and (> n 3)\n         (prime? n)\n         (= n (/ (+ (prime-step n 2) (prime-step n -2)) 2)))))", "user": "5c2649c8e4b07e362c2305bf"}, {"problem": 116, "code": "(fn [n]\n  (if (< n 3)\n    false\n    (let [prime? (fn [x] (not-any? #(= 0 (rem x %)) (range 2 x)))\n          prev (->> n range reverse (filter prime?) first)\n          next (->> (range) (drop (+ 1 n)) (filter prime?) first)]\n    \t(and (prime? n) (= (+ next prev) (* 2 n))))))", "user": "5b0bd9cfe4b0cc2b61a3bdd9"}, {"problem": 116, "code": "(fn [n]\n  (letfn [(p [x] (not-any? #(= 0 (mod x %)) (range 2 x)))\n          (g [f] (some #(if (p %) %) (next (iterate f n))))]\n    (and (p n) (> n 2) (= n (/ (+ (g dec) (g inc)) 2)))))", "user": "5c1aadcde4b01240ff567209"}, {"problem": 116, "code": "(fn [num]\n  (letfn [(prime []\n            (letfn [(step [coll]\n                      (let [head (first coll)]\n                        (lazy-seq (cons head (step (filter #(pos? (mod % head)) coll))))))]\n              (step (range 2 Long/MAX_VALUE))))\n          (balanced-prime []\n            (map second (filter #(= (second %) (/ (+ (first %) (last %)) 2)) (partition 3 1 (prime)))))]\n    (= num (last (take-while #(<= % num) (balanced-prime))))))", "user": "57c647bbe4b05aa3c4741cf3"}, {"problem": 116, "code": "(fn [x]\n  (let [prime? (memoize (fn [n]\n                          (cond\n                           (<= n 1) false\n                           (< n 4) true\n                           (zero? (mod n 2)) false\n                           (< n 9) true\n                           (zero? (mod n 3)) false\n                           :else (let [r (Math/floor (Math/sqrt n))]\n                                   (loop [f 5]\n                                     (cond\n                                      (> f r) true\n                                      (zero? (mod n f)) false\n                                      (zero? (mod n (+ f 2))) false\n                                      :else (recur (+ f 6))))))))]\n    (if (and (> x 4)(prime? x))\n      (let [p1 (first (drop-while #(not (prime? %)) (iterate dec (dec x))))\n            p2 (first (drop-while #(not (prime? %)) (iterate inc (inc x))))]\n        (= x (/ (+ p1 p2) 2)))\n      false)))\n\n\n;; #(boolean (#{5 53 157 173 211 257 263 373 563 593 607 653 733 947 977 1103} %))", "user": "567c63f6e4b05957ce8c61bb"}, {"problem": 116, "code": "(fn prime-sandwitch\n  [n]\n  (let [primes (filter (fn [k] (every? #(not= (mod k %) 0) (range 2 k))) (iterate inc 2))\n        before (last (take-while #(< % n)  primes))\n        after (drop-while #(< % n)  primes)]\n    (if (and (> n 2) (= (first after) n)) (= (/ (+ (second after) before) 2) n)\n                            false)\n    )\n  )", "user": "5c3ac091e4b0d62ef62d9f95"}, {"problem": 116, "code": "(fn [n] (let [is-prime? (fn is-prime [x] (= (- x 2) (count (take-while (fn [y] (not= 0 (rem x y))) (range 2 (inc x))))))] (and (is-prime? n) (loop [p (dec n) q (inc n)] (if (some is-prime? [p q]) (every? is-prime? [p q]) (recur (dec p) (inc q)))))))", "user": "594d4c57e4b07ddc2dafae87"}, {"problem": 116, "code": "(fn [n] (if (< n 3) false (letfn [(p [x] (if (some #(= 0 (mod x %)) (range 2 x) ) false true))] (and (p n) (= n (/ (+ (first  (filter p (iterate inc (inc n)))) (first (filter p (iterate dec (dec n))))) 2) )))))", "user": "5c379636e4b0d62ef62d9f76"}, {"problem": 116, "code": "(fn [n]\n    (reduce\n     (fn [x [a b c]]\n       (or x (and c (= (- b a) (- c b))\n                  (= b n))))\n     false\n     (partition\n      3 1\n      ((fn f [[h & t]]\n         (when h\n           (cons\n            h (f (filter #(> (rem % h) 0) t)))))\n       (range 2 (* n 2))))))", "user": "505106fee4b05ab4c7e07d38"}, {"problem": 116, "code": "(fn b-prime? [n]\n  (let [ps (map first ;; prime generator from 67\n                (iterate\n                 (fn [[x & xs]]\n                   (filter (fn [y] (not= (mod y x) 0)) xs))\n                 (iterate inc 2)))\n        i (.indexOf (take-while #(>= n %) ps) n)]\n\n    (if (or (zero? i) (neg? i)) false\n        (let [prev (nth ps (dec i))\n              next (nth ps (inc i))\n              mean (/ (+ prev next) 2)]\n          (= n mean)))))", "user": "5a257747e4b07f18be40aa1f"}, {"problem": 116, "code": "(fn balanced-prime? [n]\n  (let [primes (map (comp first first)\n                    (rest (iterate (fn [[selected remaining]]\n                                     [(cons (first remaining) selected)\n                                      (remove #(= 0 (mod % (first remaining))) \n                                              (rest remaining))])\n                                   ['() (drop 2 (range))])))\n        [smaller-primes [p & larger-primes]] (split-with (partial > n) primes)]\n    (and (not (> 1 (count smaller-primes)))\n         (= n p)\n         (= (* 2 n) (+ (last smaller-primes) (first larger-primes))))))", "user": "5c506951e4b0f9f7a8770ec5"}, {"problem": 116, "code": "(fn [n]\n  (letfn [(primes []\n            (->> (range)\n                 (drop 2)\n                 (filter (fn [x] (not-any? #(zero? (rem x %)) (range 2 x))))))]\n    (if (even? n)\n      false\n      (let [primes-to-2n (take-while #(<= % (+ n n)) (primes))\n           rev-list (drop-while #(> % n) (reverse primes-to-2n))\n           p   (first rev-list)\n           l-p (second rev-list)\n           u-p (first (drop-while #(<= % n) primes-to-2n))]\n        (cond\n          (nil? l-p)                            false\n          (and (= n p) (= n (/ (+ l-p u-p) 2))) true\n          :else                                 false)))))", "user": "5c165d3ee4b01240ff5671d1"}, {"problem": 116, "code": "#(cond (= 563 %) true (> % 1088) true :else false)", "user": "5c41db45e4b08cd430848ece"}, {"problem": 116, "code": "(fn [n]\n  (let [primes (->> (range)\n                    (drop 2)\n                    (filter (fn [i] (every? #(not= 0 (rem i %)) (range 2 i)))))]\n    (->> (partition 3 1 primes)\n         (drop-while #(<= (last %) n))\n         first\n         ((fn [[l p g]] (and (= p n) (= (* p 2) (+ l g))))))))", "user": "5a080bdde4b01bb0ae8afde9"}, {"problem": 116, "code": "(fn [x]\n  (let [p (fn [y] (every? #(< 0 (mod y %)) (range 2 y)))]\n    (and (< 2 x) (p x) (loop [i 1]\n      (let [[r l] (map p ((juxt + -) x i))]\n        (if (or r l) (and r l) (recur (inc i))))))))", "user": "5a244240e4b0ff51aa4b32e9"}, {"problem": 116, "code": "(fn sandwich\n  [n]\n  (let [is-prime? (fn [n] (if (every? #(not (integer? (/ n %))) (range 2 n)) n))]\n    (if-let [before (and (is-prime? n) (some is-prime? (reverse (range 2 (dec n)))))]\n      (let [after (some is-prime? (drop (inc n) (range)))\n            mean (/ (+ before after) 2)]\n          (= mean n))\n      false)))", "user": "5b72b36ce4b047b03b2036a9"}, {"problem": 116, "code": "(fn [x]\n  (if (< x 3) false\n    (loop [r () l (nthnext (range) 2)]\n      (if (>= (first l) x)\n        (if (= (first l) x )\n          (-> r (+ (second l)) (/ 2)  (= (first l)))\n          false)\n        (recur (first l) (remove #(= (rem % (first l)) 0) l) )))))", "user": "5c683fb5e4b0fca0c16226d5"}, {"problem": 116, "code": "(fn prime-sandwich [n]\n  (let [[a b c] (->> (iterate inc 2)\n                     (filter (fn [n] (not-any? #(zero? (rem n %)) (range 2 n))))\n                     (partition 3 1)\n                     (drop-while (fn [[_ b _]] (< b n)))\n                     first)]\n    (and (= b n) (= (/ (+ a c) 2) b))))", "user": "561d8936e4b064ca9f4b16b2"}, {"problem": 116, "code": "(fn prime-sandwich? [n]\n\t(let [is-prime? (fn [n] \n\t\t\t\t\t\t\t\t\t\t\t(empty? \n\t\t\t\t\t\t\t\t\t\t\t\t(filter #(= (mod n %) 0) (range 2 (inc (/ n 2))))))\n\t\t\t\tnext-prime (first (filter is-prime? (iterate inc (inc n))))\n\t\t\t\tprevious-prime (first (filter is-prime? (range (dec n) 0 -1)))]\n\t(cond \n\t\t(contains? #{0 1 2} n) false\n\t\t(and (= (/ (+ next-prime previous-prime) 2) n) (is-prime? n)) true\n\t\t:else false)))", "user": "593c1e3be4b069cdc2982b86"}, {"problem": 116, "code": ";; http://www.4clojure.com/problem/116\n(fn balanced-prime?\n  [n]\n  (let [is-prime? (fn [n]\n                    (and (>= n 2)\n                         (not (some true?\n                                    (map (comp zero? (partial mod n))\n                                         (range 2 (inc (quot n 2))))))))\n        seek-prime-by (fn [f n]                        \n                        (loop [x n]\n                          (if (is-prime? x)\n                            x\n                            (recur (f x)))))]\n    (if (or (<= n 2) (not (is-prime? n)))\n      false\n      (= n (/ (+ (seek-prime-by inc (inc n)) (seek-prime-by dec (dec n))) 2)))))", "user": "5c92105ce4b048ec896c59f7"}, {"problem": 116, "code": "(fn [n]\n  (letfn [(sieve [s]\n            (cons (first s)\n                  (lazy-seq (sieve (filter #(not= 0 (mod % (first s)))\n                                           (rest s))))))\n          (tuples-3 []\n            (partition 3 1 (sieve (iterate inc 2))))]\n    (let [[p-1 p p+1] (first (drop-while (fn [[p-1 p p+1]] (< p n)) (tuples-3)))]\n      (and (= p n (/ (+ p-1 p+1) 2))))))", "user": "57f80350e4b0d3187e90090c"}, {"problem": 116, "code": "(fn [x]\n  (let \n    [is-prime? (fn [n] (->> n (Math/sqrt) (int) (+ 1) (range 2) (map #(rem n %)) (filter zero?) (empty?)))]\n    (and \n     (>= x 5) \n     (is-prime? x) \n     (= (* 2 x) (+ (first (filter is-prime? (map #(+ x (* 2 (inc %))) (range)))) (first (filter is-prime? (map #(+ x (* -2 (inc %))) (range)))))))\n        ))", "user": "58b26da4e4b0ebc645576d0a"}, {"problem": 116, "code": "(fn is-balnaced-prime [n]\n  (letfn [(p [k] (every? #(> (rem k %) 0) (range 2 k))) ; (p 2) is \n          (other-p [op]\n            (first (filter p (iterate #(op % 1) (op n 1)))))]\n    (and (< 4 n)\n         (p n) \n         (= (* 2 n) (+ (other-p +) (other-p -))))))\n    \n#_ ;my first impl. not so efficient\n(fn is-balanced-prime [x]            \n  (let [_primes (fn _primes [ps x]\n                   (cond (some #(zero? (rem x %)) ps)\n                           (_primes ps (+ 2 x))\n                         :else\n                           (lazy-seq (cons x (_primes (cons x ps) (+ 2 x))))))\n        primes (fn primes []\n                  (cons 2 (_primes (list 2) 3)))\n        balanced (map second (filter (fn [[a b c]] (= (+ b b) (+ a c))) (map vector (primes) (->> (primes) next) (->> (primes) next next))))]\n    (= x (first (drop-while #(< % x) balanced)))))", "user": "5bea3177e4b0f319e2d7ec81"}, {"problem": 116, "code": "(fn balanced-prime [n]\n  \"Get list of 3 primes - [prev, n, next] and test for balance.\"\n  (if (> 5 n)\n    false\n  (loop [primelist [2 3 5], x 7]\n    (if (<= n (last (butlast primelist)))\n      ;  We're done.  No error checking for length.\n      (let [[x y z] (take 3 (reverse primelist))]\n        (if (and (= n y) (= (+ x z) (+ y y)))\n          true\n          false\n          ))\n      ; Not done, so build prime list.\n      (if (some zero? (map #(mod x %) primelist))\n        (recur primelist (+ x 2))\n        (recur (conj primelist x) (+ x 2)))))))", "user": "5cb4e764e4b026601754b929"}, {"problem": 116, "code": "(fn balanced-prime? [x]\n  (letfn [(is-prime [x]\n            (and (>= x 2)\n                 (empty? (filter #(zero? (rem x %)) (range 2 x)))))\n          (primes [] (filter is-prime (rest (rest (range)))))]\n    (let [smaller-prime (last (take-while #(< % x) (primes)))\n          bigger-prime (first (drop-while #(<= % x) (primes)))]\n      (and (> x 2)\n           (is-prime x)\n           (= x (/ (+ smaller-prime bigger-prime)\n                   2))))))", "user": "5ca14eb1e4b048ec896c5b7d"}, {"problem": 116, "code": "(fn [n]\n  (let [un (max (* 2 n) (+ n 6))\n        primes (loop [lst [2] x 3] (if (< x un) (recur (if (every? #(pos? (mod x %)) lst) (conj lst x) lst) (inc x)) lst))\n        [x y] (split-with #(< % n) primes)]\n    (and (not (empty? x)) (= n (first y)) (= (* 2 (first y)) (+ (last x) (second y))))\n    )\n  )", "user": "5cebafbbe4b0a17bb84e2be6"}, {"problem": 116, "code": "(fn balanced-prime? [n]\n  (let [prime? (memoize (fn [n]\n                          (if (> n 1)\n                            (let [end n]\n                              (loop [i 2]\n                                        ;(println i (mod n i) (>= i end))\n                                (cond\n                                  (= (mod n i) 0) (= i n)\n                                  (>= i end) true\n                                  :else (recur (inc i)))))\n                            false)))\n        prime-ls  (filter prime? (iterate inc 1))]\n    (if (and (> n 2)\n             (prime? n))\n      (loop [p (first prime-ls)\n             p2 (second prime-ls)\n             ps (drop 2 prime-ls)]\n                                        ;(println p p2 )\n        (if (or (nil? p)\n                (nil? p2)\n                (= p2 n))\n          (= p2 (/ (+ p (first ps)) 2))\n          (recur p2 (first ps) (rest ps))))\n      false)))", "user": "527ccaf4e4b0757a1b17136d"}, {"problem": 116, "code": "(fn balanced-prime [target]\n  (loop [acc (list 2)\n         curr 2]\n    (cond (<= target 3) false\n          (> (first acc) target) (and (= (first (rest acc)) target)\n                                      (= (/ (+ (first acc) (first (rest (rest acc)))) 2) target))\n          true (recur\n                (if (some #(= 0 (mod curr %)) acc)\n                  acc\n                  (cons curr acc))\n                (inc curr)))))", "user": "5d1bbef0e4b02ea6f0fb6984"}, {"problem": 116, "code": "(fn [n]\n  (letfn [(prime? [n]\n            (loop [d 2]\n              (if (> d (Math/sqrt n))\n                true\n                (if (zero? (mod n d))\n                  false\n                  (recur (inc d))))))\n          (next-prime [n higher]\n                        (let [f (if higher inc dec)]\n                          (loop [l (f n)]\n                            (if (< l 2)\n                              -1 ;; A hack? Prevents subsequent calculations from breaking.\n                              (if (prime? l)\n                                l\n                                (recur (f l)))))))]\n    (and (prime? n)\n         (= n (/ (+ (next-prime n false) (next-prime n true)) 2)))))", "user": "5c950334e4b048ec896c5a44"}, {"problem": 116, "code": "(fn bp [n] \n           (->>\n            (range)\n            (filter (fn [x] (every? #(not= 0 (mod x %)) (range 2 x))))\n            (partition 3 1)\n            (map (fn [[x y z]] (if (= y (/ (+ x z) 2)) y)))\n            (keep identity)\n            (drop 2)\n            (drop-while #(< % n))\n            (#(= n (first %)))\n           ))", "user": "5d02fe44e4b0cc9c915881c0"}, {"problem": 116, "code": "(fn [n]\n   (let [lst3 (take-last 3\n                             (first\n                              (take 1\n                                    (drop-while #(<= (last %) n)\n                                                ((fn k [prev]\n                                                   (let [n (last prev)\n                                                         nxt (if (= n 2) 3\n                                                                 (loop [nxt (+ n 2)]\n                                                                   (if (every? #(not= 0 (rem  nxt %)) prev)\n                                                                     nxt\n                                                                     (recur (+ nxt 2)))))]\n                                                     (lazy-seq (cons prev (k (conj prev nxt))))))  [2])))))]\n     (if (= (second lst3 ) n) (= (second lst3) (/ (+ (first lst3) (last lst3)) 2))  false)))", "user": "5d0cf1c8e4b0cc9c91588246"}, {"problem": 116, "code": "(fn [N]\n    (let [\n        _IsPrime (fn [N]\n          (nil? (first (filter #(zero? (rem N %)) (range 2 (dec N) ))))\n        )\n        IsPrime (memoize _IsPrime)\n      ]\n      ;; \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u043d\u043e\u0435 \u0447\u0438\u0441\u043b\u043e \u0434.\u0431. \u043f\u0440\u043e\u0441\u0442\u044b\u043c\n      (if (or (not (IsPrime N)) (zero? N) (= 2 N))\n        false\n        ;; \u0438\u0449\u0435\u043c \u043f\u0435\u0440\u0432\u043e\u0435 \u0447\u0438\u0441\u043b\u043e \u043c\u0435\u043d\u044c\u0448\u0435\u0435 nil\n        (loop [Delta 1]\n          ;; \u0435\u0441\u043b\u0438 \u0434\u043e\u0448\u043b\u0438 \u0434\u043e N, \u0442\u043e \u043d\u043d \u043d\u0430\u0448\u043b\u0438\n          (if (= Delta N)\n            false\n            (let\n              [\n                Left (IsPrime (- N Delta))\n                Right (IsPrime (+ N Delta) )\n              ]\n              ;; \u0435\u0441\u043b\u0438 \u0441\u043b\u0435\u0432\u0430 \u0438\u043b\u0438 \u0441\u043f\u0440\u0430\u0432\u0430 \u043f\u0440\u043e\u0441\u0442\u043e\u0435 \u0447\u0438\u0441\u043b\u043e\n              (if (or Left Right)\n                ;; \u043e\u0431\u0430 \u0434\u043e\u043b\u0436\u043d\u044b \u0431\u044b\u0442\u044c \u043f\u0440\u043e\u0441\u0442\u044b\u043c\u0438\n                (and Left Right)\n                ;; \u0438\u0449\u0435\u043c \u0434\u0430\u043b\u044c\u0448\u0435\n                (recur (inc Delta))  \n              )\n            )\n          )\n        )\n      )\n    )\n  )", "user": "5d4a6c6ce4b0776584bd6f22"}, {"problem": 116, "code": "(fn __\n  [p]\n  (let [primes ((fn sieve\n                  ([] (sieve [2 3] 4))\n                  ([acc n]\n                   (cond (= n 1200)\n                         acc\n\n                         (not-any? #(zero? (rem n %)) acc)\n                         (sieve (conj acc n) (inc n))\n\n                         :else\n                         (sieve acc (inc n))))))\n        pi     (.indexOf primes p)\n        pp     (get primes (dec pi))\n        pn     (get primes (inc pi))]\n    (and (pos? pi)\n         (-> pp (+ pn) (/ 2) (= p)))))", "user": "55916764e4b0604b3f94d57b"}, {"problem": 116, "code": "(fn\n  [t]\n  (let [not-zero? (complement zero?)\n        primes (loop [ps [2]\n                      n 3]\n                 (if (> (peek ps) t)\n                   ps\n                   (if (every? #(not-zero? (rem n %)) ps)\n                     (recur (conj ps n) (inc n))\n                     (recur ps (inc n)))))\n        sandwich (take-last 3 primes)\n        [f m l] sandwich]\n    (and (= m t)\n         (= t (/ (+ f l) 2)))))", "user": "5338387de4b0e30313ee6c91"}, {"problem": 116, "code": "(fn balanced-prime? [n]\n  (let [is-prime? (fn [n] (and (> n 1) (not-any? #(zero? (mod n %)) (range 2 n))))]\n    (if (and (not= 2 n) (is-prime? n))\n      (let [next-prime (second (filter is-prime? (iterate inc n)))\n            prev-prime (second (filter is-prime? (iterate dec n)))]\n        (= (+ next-prime prev-prime) (* 2 n)))\n      false)))", "user": "5d0bb4fae4b0cc9c91588237"}, {"problem": 116, "code": "(fn balance-prime? [n]\n   (let [prime? #(not-any? zero? (map (fn [x] (rem % x)) (range 2 (inc (quot % 2)))))\n         nxt-prime (loop [x (inc n)]\n                     (if (prime? x)\n                       x\n                       (recur (inc x))))\n         prev-prime (loop [x (dec n)]\n                      (if (prime? x)\n                        x\n                        (recur (dec x))))]\n    (and (> n 4) (prime? n) (= n (/ (+ nxt-prime prev-prime) 2)))))", "user": "5d29c06be4b01671435dbc6b"}, {"problem": 116, "code": "(fn [n]\n   (if (<= n 2) false\n                (let [pns (map-indexed (fn [i p] [i p]) (letfn [(sieve [s] (cons (first s) (lazy-seq (sieve (filter #(not= 0 (mod % (first s))) (rest s))))))]\n                                                          (sieve (drop 2 (range)))))\n                      [i x] (last (take-while (fn [[_ x]] (<= x n)) pns))\n                      bef (second (nth pns (dec i)))\n                      aft (second (nth pns (inc i)))]\n                  (and (= x n) (= x (/ (+ bef x aft) 3))))))", "user": "5d764e52e4b02e6b30c93524"}, {"problem": 116, "code": "(letfn\n    [(primes\n       ([] (lazy-seq (cons 2 (primes 3 #{2}))))\n       ([x found]\n        (if (some #(zero? (mod x %)) found)\n          (primes (+ 2 x) found)\n          (lazy-seq (cons x (primes (+ 2 x) (conj found x)))))))\n     (mean [& xs]\n       (/ (reduce + xs) (count xs)))\n     (balanced-primes []\n        (->> (primes)\n             (partition 3 1)\n             (filter #(= (second %) (mean (first %) (last %))))))\n     (balanced-prime? [x]\n       (->> (balanced-primes)\n            (drop-while #(< (second %) x)) \n            (first)\n            (#(= x (second %)))))]\n  balanced-prime?)", "user": "5d4b2155e4b0776584bd6f28"}, {"problem": 116, "code": "(fn [n]\n   (letfn [(prime? [k] (and (> k 1) (not-any? #(zero? (mod k %)) (range 2 k))))\n           (balanced-prime? [k]\n             (and (> n 2)\n                  (let [next-prime (first (filter prime? (iterate inc (inc n))))\n                        previous-prime (first (filter prime? (iterate dec (dec n))))]\n                    (and (> n 2) (prime? n) (= n (/ (+ previous-prime next-prime) 2))))))]\n     (balanced-prime? n)))", "user": "5d9c1226e4b0d3f9b434ad51"}, {"problem": 116, "code": "(fn [n]\n  (letfn [(is-prime [n] (not-any? #(= 0 (mod n %)) (cons 2 (range 3 (quot n 2) 2))))\n          (prev-prime [n] (first (drop-while #(not (is-prime %)) (range (- n 2) 0      -2))))\n          (next-prime [n] (first (drop-while #(not (is-prime %)) (range (+ n 2) (* n n) 2))))]\n    (and (< 3 n) (is-prime n) (= n (quot (+ (prev-prime n) (next-prime n)) 2)))))", "user": "5d81b40ce4b0915913b1d379"}, {"problem": 116, "code": "(fn bp? [n]\n  (let[is-prime?  (fn[num] (empty? (filter #(zero? (mod num %)) (range 2 num))))\n       prime-seq  (filter #(is-prime? %) (range))\n       lp (vec (take-while #(>= n %) prime-seq))\n       np (nth prime-seq (count lp))\n       rel     (->>(conj lp np)\n                   (reverse)\n                   (take 3))\n       m  (/  ( + (first rel) (last rel)) 2)]\n      ;(println rel \",\" m)\n      (and (< 2 n) (is-prime? n)  (= m (second rel)))))", "user": "52f426fce4b05e3f0be25f1e"}, {"problem": 116, "code": "(fn [n]\n   (let [prime (fn [n]\n                 (if (or (= 1 n) (= 0 n))\n                   false\n                   (if (= 2 (count (reduce #(if (= 0 (mod n %2)) (conj %1 %2) %1) [] (range 1 (inc n)))))\n                     true\n                     false)))]\n     (if (or (<=  n 4) (not (prime n)))\n       false\n       (let [primes (filter prime (range 1 (inc n)))\n             pairs [(last (butlast primes))  (last primes)]\n             next (- (* 2 (last primes)) (pairs 0))]\n          (and  (empty? (filter prime (range (inc n) next))) (prime next))))))", "user": "58983e3fe4b00487982d52ce"}, {"problem": 116, "code": "(fn prime [n]\n      (letfn [(b [n]\n                (cond \n                  (< n 2) false\n                  (= 2 n) true\n                  :else (not-any? #(= 0 (mod n %)) (cons 2 (range 3 (inc (Math/sqrt n)) 2 )))))\n                  \n                 (nb [n]                   \n                   (if (b n) (lazy-seq (cons n (nb (inc n))))\n                        (recur (inc n))))\n                      ]\n     (if (not (b n)) false\n         (let [np (second (nb n))\n               pp (- (* n 2) np)]\n            (if (b pp) (= (second (nb pp)) n) false)))))", "user": "5dc12b0ae4b0e59a23173d84"}, {"problem": 116, "code": "(fn [n]\n  (let [[a b c] (loop [s [2 3 5] i 7]\n               \t  (cond (>= (last (drop-last 1 s)) n) (take-last 3 s)\n                        (not-any? #(= 0 (mod i %)) s) (recur (conj s i) (inc i))\n                        :else (recur s (inc i))))]\n    (and (= b n) (= (/ (+ a c) 2) b))))", "user": "5db92996e4b010eb3c36cd50"}, {"problem": 116, "code": "(fn [n]\n  (let [divisors (fn [n]\n                   (reduce\n                    (fn [s i]\n                      (if (= 0 (mod n i))\n                        (conj s i (/ n i))\n                        s))\n                    #{}\n                    (range 1 (inc (Math/sqrt n)))))]\n    (if (not= (count (divisors n)) 2)\n      false\n      (let [after (loop [i (inc n)]\n                    (if (= (count (divisors i)) 2)\n                      i\n                      (recur (inc i))))\n            before (loop [i (dec n)]\n                     (cond\n                       (< i 1) nil\n                       (= (count (divisors i)) 2) i\n                       :else (recur (dec i))))]\n        (cond\n          (nil? before) false\n          (= (-> after\n                 (+ before)\n                 (/ 2))\n             n) true\n          :else false)))))", "user": "5cf6522be4b0b71b1d808a58"}, {"problem": 116, "code": "(fn p_sandwich [x]\n    (let\n        [\n            primes_helper\n                (fn [[prev_primes x]]\n                    (let\n                        [\n                            new_prime\n                                (first (drop-while\n                                    (complement (fn [v] (every? #(not= 0 (mod v %)) prev_primes)))\n                                    (drop x (range))\n                                ))\n                        ]\n                        (cons (conj prev_primes new_prime) (cons new_prime '()))\n                    )\n                )\n            primes\n                (iterate primes_helper '(#{} 2))\n            is_prime?\n                (fn [x]\n                    (= x (second (first (drop-while (fn [[ps p]] (> x p)) primes))))\n                )\n            get_prev_and_latter_primes\n                (fn [n]\n                    (if (and (is_prime? n) (> n 2))\n                        (let\n                            [\n                                [prev_seq latter_seq] (split-with (complement (fn [[ps p]] (= p n))) primes)                                \n                                prev_prime (second (last prev_seq))\n                                latter_prime (second (second latter_seq))\n                            ]\n                            (cons prev_prime (cons latter_prime '()))\n                        )\n                        false\n                    )\n                )\n        ]\n        (let [check (get_prev_and_latter_primes x)]\n            (if (false? check) false (= x (/ (apply + check) 2)))\n        )\n    )\n)", "user": "5db7376fe4b010eb3c36cd43"}, {"problem": 116, "code": "(fn is-balanced-prime [x]\n  (if (<= x 2)\n    false\n    (letfn [(is-prime [s] (every? #(not (= 0 (mod s %))) (range 2 s)))]\n      (if (is-prime x)\n        (let [before (first (filter is-prime (reverse (range 2 x))))\n              after (first (filter is-prime (iterate inc (inc x))))]\n          (= x (/ (+ before after) 2)))\n        false\n        ))\n    ))", "user": "5dd67c22e4b0948ae9d9ad80"}, {"problem": 116, "code": "(fn a [c]\n  (letfn [(is-prime [m]\n            (empty? (filter #(zero? (mod m %)) (range 2 (/ (inc m) 2)))))]\n    (let [[x y] (split-with #(<= % c) (filter is-prime (iterate inc 2)))\n          found (last x)\n          prev (last (butlast x))\n          _next (first y)]\n      (and \n        (not (nil? found))\n        (not (nil? prev))\n        (not (nil? _next))\n        (= found c)\n        (= found (/ (+ prev _next) 2))))))", "user": "529dfc6de4b04e0c58e87b8a"}, {"problem": 116, "code": "(fn balanced-prime? [n]\n  (letfn [(prime? [n]\n            (let [prime1? (fn prime1? [a]\n                            (cond\n                              (= a 1) true\n                              (= 0 (rem n a)) false\n                              :else (recur (dec a))))]\n              (prime1? (quot n 2))))]\n    (if (or (<= n 3)\n            (not (prime? n))) false\n                              (let [prev (loop [x (dec n)]\n                                           (if (prime? x)\n                                             x\n                                             (recur (dec x))))\n                                    next (loop [x (inc n)]\n                                           (if (prime? x)\n                                             x\n                                             (recur (inc x))))]\n                                (= n (/ (+ prev next) 2))))))", "user": "518279abe4b0353c468deb65"}, {"problem": 116, "code": "(fn f [n]\n  (letfn [(prime? [x] (or (not-any? #(zero? (mod x %)) (cons 2 (range 3 (quot x 2) 2)))))\n          (prime-above [x] (first (drop-while #(not (prime? %)) (range (+ x 2) (* x 2) 2))))\n          (prime-below [x] (first (drop-while #(not (prime? %)) (range (- x 2) 2 -2))))]\n    (and (> n 3) (prime? n) (= (/ (+ (prime-above n) (prime-below n)) 2) n))))", "user": "5dd60c58e4b0948ae9d9ad7c"}, {"problem": 116, "code": "(fn balanced-prime? [n]\n  (let [factors (cons 2 (iterate (partial + 2) 3))\n        prime? (fn [n] (not-any? #(zero? (mod n %))\n                                 (take-while #(<= % (inc (Math/sqrt n))) factors)))\n        prime-step (fn [n s] (first (drop-while (complement prime?) (rest (iterate (partial + s) n)))))]\n    (and (> n 3)\n         (prime? n)\n         (= n (/ (+ (prime-step n 2) (prime-step n -2)) 2)))))", "user": "5e00b6e7e4b0a607a9a45d2b"}, {"problem": 116, "code": "(fn t116 [n]\n  (let [is_prime (fn is_prime [x] (if (= x 2)\n                           true\n                           (every? #(not= 0 (rem x %)) (cons 2 (filter odd? (range 3 x))))))]\n    (and (not= n 1) (not= n 2) (is_prime n) (= n (/ (+ (nth (filter is_prime (range n (+ n 1000))) 1) (nth (filter is_prime (range n 0 -1)) 1)) 2)))))", "user": "5d9c9446e4b0eb781811cdae"}, {"problem": 116, "code": "(fn prime-sandwich [nn] \n    (let [prime? (fn [x] (if (< x 2)\n                           false\n\t                         (loop [n (dec x)]\n\t\t\t\t\t\t                   (if (or (= n 1) (zero? n))\n\t\t\t\t\t\t                     true\n\t\t\t\t\t\t                     (if(zero? (mod x n))\n\t\t\t\t\t\t                       false\n\t\t\t\t\t\t                       (recur (dec n)))))))\n          next-prime (fn [x](loop [c (inc x)] \n                              (if (prime? c)\n                                c\n                                (recur (inc c)))))\n          previous-prime (fn [x](loop [c (dec x)]\n                                  (if (< c 2)\n                                    -1\n\t\t\t                              (if (prime? c)\n\t\t\t                                c\n\t\t\t                                (recur (dec c))))))]\n      (if (not (prime? nn) )\n           false\n           (let [c1 (next-prime nn)\n                 c2 (previous-prime nn)]\n             (if (= c2 -1)\n               false\n               ( = (+ c1 c2) (* 2  nn)))))))", "user": "5df0c6ffe4b093ff717275c2"}, {"problem": 116, "code": "(fn [n]\n  (->> (range)\n       (drop 2)\n       (filter (fn [x] (not-any? #(zero? (mod x %)) (range 2 x))))\n       (partition 3 1)\n       (filter #(= (reduce + %) (* 3 (second %))))\n       (map second)\n       (take-while #(<= % n))\n       last\n       (= n)))", "user": "5e0d948fe4b099d064962f98"}, {"problem": 116, "code": "(fn [n]\n    (cond (> 2 n) false\n          (= 2 n) false\n          :else\n          (let [sieve (set (cons 2 (range 3 (inc n) 2)))\n                primes (reduce (fn [sieve x] (apply disj sieve\n                                                    (take-while\n                                                     (partial >= n)\n                                                     (iterate (partial + x) (* 2 x))))) sieve sieve)]\n            (if-not\n                (primes n) false\n                (let [last-prime (->> (sort primes)\n                                      butlast\n                                      last)\n                      distance (- n last-prime)\n                      upper-limit (+ n distance)\n                      muh (set (filter (fn [maybe-prime] (not-any? (comp zero? (partial rem maybe-prime)) (range 2 maybe-prime))) (range (inc n) (inc upper-limit))))]\n                  (and (muh upper-limit)\n                       (not-any? (partial > upper-limit) muh)))))))", "user": "5d236215e4b02ea6f0fb6a09"}, {"problem": 116, "code": "(fn [n]\n  (if (< n 5)\n    false\n    (letfn [(p [i] (if (>= i 2)\n                     (every? false? (map #(zero? (rem i %)) (range 2 (inc (int (Math/floor (Math/sqrt i)))))))\n                     false))]\n      (if (p n)\n        (let [a (first (filter p (iterate dec (dec n))))\n              b (first (filter p (iterate inc (inc n))))]\n          (println a n b)\n          (= n (/ (+ a b) 2)))\n        false))))", "user": "5e2549c8e4b05b4b0151615f"}, {"problem": 116, "code": "(fn [n]\n            (letfn [(isPrime? [n]\n                      (not (contains? (set (map #(mod n %) (range 2 (inc (/ n 2))))) 0)))]\n              (if (and (not= 0 n) (not= 1 n) (not= 2 n) (isPrime? n))\n                (letfn [(nextPrime [n]\n                          (if (isPrime? n)\n                            n\n                            (recur (+ n 1))))\n                        (prevPrime [n]\n                          (if (isPrime? n)\n                            n\n                            (recur (- n 1))))]\n                  (= n (/ (+ (nextPrime (+ n 1)) (prevPrime (- n 1))) 2)))\n                false)))", "user": "5e1c3e6ee4b0dc9594008530"}, {"problem": 116, "code": "(fn [n]\n  (let [isprime (fn [nn] (nil? (some #(zero? (mod nn %)) (range 2 nn))))\n        above (some #(when (isprime %) %) (range (inc n) (* 2 n)))\n        below (some #(when (isprime %) %) (range (dec n) 2 -1))]\n    (and (> n 3) (isprime n) (= (/ (+ above below) 2) n))))", "user": "5e3a25d4e4b01d43a70e8dde"}, {"problem": 116, "code": "(fn [n]\n   (let [primes\n         (letfn [(f [used candidates]\n                   (let [composite? (fn [n] (some #(zero? (mod n %)) used))\n                         [p & t] (drop-while composite? candidates)]\n                     (lazy-seq (cons p (f (conj used p) t)))))]\n           (f #{2} (map #(+ 3 (* 2 %)) (range))))\n         [a b c] (first\n                  (drop-while\n                   #(< (second %) n)\n                   (map vector primes (rest primes) (rest (rest primes)))))]\n     (= n b (/ (+ a c) 2))))", "user": "5e3ef7d4e4b01d43a70e8e2d"}, {"problem": 116, "code": "(fn [n]\n   (letfn [(is-prime? [x] (not-any? #(zero? (mod x %)) (range 2 x)))\n           (take-while+\n             [pred coll]\n             (lazy-seq\n               (when-let [[f & r] (seq coll)]\n                 (if (pred f)\n                   (cons f (take-while+ pred r))\n                   [f]))))\n           (get-prime-seq [n] (when (is-prime? n)\n                            (->> (range)\n                                 (drop 2)\n                                 (filter is-prime?)\n                                 (take-while+ #(not (< n %)))\n                                 (take-last 3)\n                                 )))\n           ]\n\n     (let [prime-seq (get-prime-seq n)]\n       (if (nil? prime-seq)\n         false\n         (= (/ (+ (first prime-seq) (last prime-seq)) 2) (second prime-seq))))\n         )\n     )", "user": "5e348945e4b0650de70e2b1d"}, {"problem": 116, "code": "(fn pSandwich? [n]\n  (letfn\n      [(primes []\n         (->>\n          (range)\n          (drop 2)\n          (filter (fn [x] (every? #(< 0 (mod x %)) (range 2 x))))))\n       (prime? [n]\n         (every? #(< 0 (mod n %))\n                 (range 2 n)))]\n\n  (if (and\n       (prime? n)\n       (not (>= 2 n)))\n\n    (let [index (first (keep-indexed #(if (= n %2) %1) (primes)))\n          left-prime (nth (primes) (dec index))\n          right-prime (nth (primes) (inc index))]\n      (= n\n         (/ (+ left-prime right-prime) 2)))\n    false)))", "user": "5b3251c1e4b025bcb146f317"}, {"problem": 116, "code": "(fn sandwich [n]\n  (let [isPrime? (fn [i]\n                   (if (< i 2) false\n                       (not (some #(= 0 (mod i %)) (range 2 (inc (quot i 2)))))))\n        next (fn [p] (some #(when (isPrime? (+ p 1 %)) (inc %)) (range)))\n        prev (fn [p] (some #(when (isPrime? (- p %)) %) (range 1 p)))]\n    (and (isPrime? n) (= (prev n) (next n)))))", "user": "5471f2fbe4b094393f72dd70"}, {"problem": 116, "code": "(fn balanced-prime?\n  [x]\n  (and (> x 2)\n       ((fn is-prime\n          [x]\n          (and\n            (> x 1)\n            (not (some #(= 0 (mod x %)) (range 2 x))))) x)\n       (= x \n          (/ \n            (+ \n              ((fn previous-prime\n                 [x]\n                 (let [x (dec x)]\n                   (if\n                     (> x 0)\n                     (if ((fn is-prime\n                            [x]\n                            (and\n                              (> x 1)\n                              (not (some #(= 0 (mod x %)) (range 2 x))))) x)\n                       x\n                       (previous-prime x))\n                     false)\n                   )\n                 ) x) \n              ((fn next-prime\n                 [x]\n                 (let [x (inc x)]\n                   (if ((fn is-prime\n                          [x]\n                          (and\n                            (> x 1)\n                            (not (some #(= 0 (mod x %)) (range 2 x))))) x)\n                     x\n                     (next-prime x))\n                   )\n                 ) x)) \n            2))))", "user": "5e839edde4b09a7a73c8bbba"}, {"problem": 116, "code": "(fn func [num]\n  (let [prime? (fn [n] (empty? (filter  #(zero? (rem n %)) (range 2 (inc (long (Math/sqrt n)))))))]\n    (if (or (< num 4) (not (prime? num)))\n      false\n      (let [next-prime (first (filter prime? (drop (inc num) (range))))\n            prev-prime (first (filter prime? (range (dec num) 1 -1)))\n            mean (/ (+ next-prime prev-prime) 2)]\n        (= mean num)))))", "user": "5e805895e4b085ba37836e44"}, {"problem": 116, "code": "(fn [n]\n  (let [primes (fn primes\n                 ([] (lazy-seq (cons 2 (primes [] 3))))\n                 ([prev-primes start]\n                  (lazy-seq\n                    (let [prime? (fn [x] (not-any? zero? (map #(rem x %) (filter #(<= (* % %) x) prev-primes))))\n                          p (first (filter prime? (iterate #(+ 2 %) start)))]\n                      (cons p (primes (conj prev-primes p) (+ 2 p)))))))\n        [a b c] (first (drop-while #(< (second %) n) (partition 3 1 (primes))))]\n    (and (= b n) (= (+ b b) (+ a c)))))", "user": "4eb70649535d7eef30807373"}, {"problem": 116, "code": "(fn prime-sandwich? [n]\n  (let [prime?         (fn [x]\n                         (cond\n                           (or (= x 2) (= x 3))\n                           true\n                           (<= x 1)\n                           false\n                           :else\n                           ((fn helper [curr mx]\n                              (if (= 0 (rem x curr))\n                                false\n                                (if (= curr mx)\n                                  true\n                                  (helper (inc curr) mx))))\n                            2\n                            (int (Math/sqrt x)))))\n        adjacent-prime (fn [x f]\n                         ((fn helper [x]\n                            (if (< x 0)\n                              -1\n                              (if (prime? x)\n                                x\n                                (helper (f x)))))\n                          (f x)))\n        prev-prime     (adjacent-prime n dec)\n        next-prime     (adjacent-prime n inc)]\n    (and (prime? n) (< 0 prev-prime) (= n (/ (+ prev-prime next-prime) 2)))))", "user": "5dc53ddee4b02f9375f4e1bd"}, {"problem": 116, "code": "(fn balanced-prime? [n]\n  (let [factors (cons 2 (iterate (partial + 2) 3))\n        prime? (fn [n] (not-any? #(zero? (mod n %))\n                                 (take-while #(<= % (inc (Math/sqrt n))) factors)))\n        prime-step (fn [n s] (first (drop-while (complement prime?) (rest (iterate (partial + s) n)))))]\n    (and (> n 3)\n         (prime? n)\n         (= n (/ (+ (prime-step n 2) (prime-step n -2)) 2)))))\n;https://gist.github.com/SegFaultAX/3607101\n\n;even that simplistic one times out!\n;#(contains? {5 53 157 173 211 257 263 373 563 593 607 653 733 947 977 1103} %)\n\n;TODO make it work for third test\n#_(\"\n(fn [n]\n(let [primes (take 200 (cons 2 (remove #(some (fn [d] (zero? (rem % d))) (range 3 %)) (iterate #(+ 2 %) 3))))\nfi-f (fn [x y z] (assoc {} y (= y (/ (+ x z) 2))))\nbalanced-primes (map fi-f primes (rest primes) (rest (rest primes)))\ntake-f (fn [x] (<= (first (keys x)) n))\nfi-f2 (fn [x] (first (vals x)))]\n(->> balanced-primes\n(take-while take-f)\n(filter fi-f2)\n(last)\n(keys)\n(first)\n(= n))))\n\")", "user": "5e13a6b7e4b099d064963001"}, {"problem": 116, "code": "(fn[x]\n  (letfn [(sieve [limit]\n            (sort (reduce (fn [maybe-primes x]\n                            (if (maybe-primes x)\n                              (let [multiples (into #{} (rest (take-while #(< % limit) (iterate (partial + x) x))))]\n                                (clojure.set/difference maybe-primes multiples))\n                              maybe-primes))\n                          (into #{} (range 2 limit))\n                          (range 2 (Math/ceil (Math/sqrt limit))))))\n          (sandwiches [primes]\n            (mapcat (fn [previous now after]\n                      (if (= now (/ (+ previous after) 2))\n                        [now]\n                        []))\n                    primes\n                    (rest primes)    \n                    (rest (rest primes))))]\n    (not (nil? ((into #{} (sandwiches (sieve 1200)))\n                x)))))", "user": "554bd33ce4b0a04f7929959a"}, {"problem": 116, "code": "(fn [n]\n  (let [factors (cons 2 (iterate (partial + 2) 3))\n        prime?  (fn [n] (not-any? #(zero? (rem n %)) (take-while #(<= % (inc (Math/sqrt n))) factors)))\n        left    (fn [n] (first (filter prime? (iterate #(- % 2) (- n 2)))))\n        right   (fn [n] (first (filter prime? (iterate #(+ % 2) (+ n 2)))))]\n    (and (> n 3)\n         (prime? n)\n         (= n (/ (+ (left n) (right n)) 2)))))", "user": "5c3796b3e4b0d62ef62d9f77"}, {"problem": 116, "code": "(fn [n]\n  (letfn [(prime? [n]\n            (not-any? #(zero? (mod n %)) (range 2 n)))\n          (next-prime [n]\n            (first (filter prime? (iterate inc (inc n)))))\n          (prev-prime [n]\n            (first (filter prime? (iterate dec (dec n)))))]\n    (if (and (> n 2) (prime? n))\n      (let [next (next-prime n)\n            prev (prev-prime n)]\n        (= n (/ (+ next prev) 2)))\n      false)))", "user": "5eb1c786e4b00a66d4a95201"}, {"problem": 116, "code": "(letfn [(prime? [n] (.isProbablePrime (BigInteger/valueOf n) 10))\n          (pup [n]\n            (loop [n (if (even? n) (inc n) (+ n 2))]\n              (if (prime? n)\n                n\n                (recur (+ n 2)))))\n          (pwn [n]\n            (loop [n (if (even? n) (dec n) (- n 2))]\n              (if (< n 2)\n                -1\n                (if (prime? n)\n                  n\n                  (recur (- n 2))))))]\n    (fn [n]\n      (if-not (prime? n)\n        false\n        (let [u (pup n)\n              d (pwn n)\n              r (/ (+ u d) 2)]\n          (= n r)))))", "user": "5a5d0726e4b0512ff01cd91b"}, {"problem": 116, "code": "(fn [n]\n  (and (and (> n 2) (not-any? #(zero? (mod n %)) (range 2 n)))\n       (let [f (fn [x] (first (filter (fn [y] (not-any? #(zero? (mod y %)) (range 2 y))) x)))]\n         (= (/ (+ (f (iterate dec (dec n))) (f (iterate inc (inc n)))) 2) n))))", "user": "5e6ca949e4b04a83ad7cd289"}, {"problem": 116, "code": "(fn bal-prime [n]\n  (let [prime-to (fn [x]\n                   (remove (into #{}\n                                 (mapcat #(range (* % %) x %)\n                                         (range 3 (Math/sqrt x) 2)))\n                           (cons 2 (range 3 x 2))))\n        primes (apply sorted-set (prime-to 10000))]\n    (if (contains? primes n)\n      (let [part (partition-by #(= n %) primes)\n            lower (last (first part))\n            upper (first (last part))]\n        (= (+ lower upper) (* n 2)))\n      false)))", "user": "5ec3a13ae4b08d0ec38692b9"}, {"problem": 116, "code": "; Prime generation fns (`reinsert`/`primes-step`) from:\n; https://stackoverflow.com/questions/960980/fast-prime-number-generation-in-clojure\n\n(fn balanced? [n]\n  (letfn [(reinsert [table x prime]\n            (update-in table [(+ prime x)] conj prime))\n          (primes-step [table d]\n            (if-let [factors (get table d)]\n              (recur (reduce #(reinsert %1 d %2) (dissoc table d) factors)\n                     (inc d))\n              (lazy-seq (cons d (primes-step (assoc table (* d d) (list d))\n                                             (inc d))))))]\n    (->> (primes-step {} 2)\n         (partition 3 1)\n         (drop-while #(< (second %) n))\n         (first)\n         (#(and (= n (second %))\n                (= (second %) (/ (+ (first %) (last %)) 2)))))))", "user": "5de12192e4b0948ae9d9aded"}, {"problem": 116, "code": "(fn [n]\n  (letfn [(p [n] (and (> n 1) (every? #(pos? (mod n %)) (cons 2 (range 3 (Math/sqrt (inc n)) 2)))))]\n    (and (p n)\n         (= (count (take-while #(not (p %)) (range (dec n) 2 -1)))\n            (count (take-while #(not (p %)) (range (inc n) (* 2 n))))))))", "user": "50ed4626e4b01236b1d4983c"}, {"problem": 116, "code": "(fn [n]\n  (letfn [(prime? [n]\n            (let [limit (int (Math/sqrt n))]\n              (cond (= n 2) true\n                    (or (= n 1) (even? n)) false\n                    :else (loop [div (inc limit)]\n                            (cond\n                              (= div 1) true\n                              (zero? (rem n div)) false\n                              :else (recur (dec div)))))))\n          (after [n]\n                 (loop [n (inc n)]\n                   (if (prime? n)\n                     n\n                     (recur (inc n)))))\n          (before [n]\n                  (loop [n (dec n)]\n                    (cond \n                      (zero? n) 0\n                      (prime? n) n\n                      :else (recur (dec n)))))]\n    (cond \n      ((complement prime?) n) false\n      :else (let [b (before n) a (after n)]\n              (if (zero? b) \n                false\n                (= n (/ (+ b a) 2)))))))", "user": "5ebdb3d2e4b00a66d4a95275"}, {"problem": 116, "code": "(fn [n]\n  (let [sieve (fn sieve [nums]\n                (lazy-seq\n                 (cons (first nums)\n                       (sieve (remove (fn [i] (= 0 (rem i (first nums))))\n                                      nums)))))\n        primes (sieve (iterate inc 2))\n        [before-n from-n] (split-with (partial > n) primes)]\n    (if (empty? before-n)\n      false\n      (let [prev-prime (last before-n)\n            suspect (first from-n)\n            next-prime (first (rest from-n))]\n        (and (= n suspect) (= (- next-prime n) (- n prev-prime)))))))", "user": "5ec6de19e4b08d0ec38692da"}, {"problem": 116, "code": "(fn [n]\n  (let [prime? (fn [n] (every? #(pos? (mod n %)) (range 2 n)))\n        pairs (map vector (map prime? (range (dec n) 1 -1)) (map prime? (iterate inc (inc n))))]\n    (and (prime? n)\n      (if-let [[a b] (first (filter #(some identity %) pairs))]\n        (and a b)\n        false))))", "user": "597dcb0ce4b0dbe32238d0a2"}, {"problem": 116, "code": "(fn solution [n]\n  (if (<= n 2)\n    false\n    (let [composite? (fn [x] (some #(zero? (mod x %)) (range 2 x)))]\n      (if (composite? n) false\n                         (= (/ (+ (first (drop-while composite? (reverse (range 2 n))))\n                                  (first (drop-while composite? (drop (inc n) (range))))) 2) n)))))", "user": "5e2ef900e4b05b4b015161fc"}, {"problem": 116, "code": "(fn [n] (let [f #(.isProbablePrime (BigInteger/valueOf %) 5) ] \n           (and (f n)\n                (= (* 2 n) (+(loop [x (inc n)] (if (f x) x (recur (inc x)) ))\n                        (loop [x (dec n)] (if (f x) x (recur (dec x)) ))))\n\n\n\n)) )", "user": "5951190be4b066ee0a44aea4"}, {"problem": 116, "code": "(fn [n]\n   (letfn [(reinsert [table x prime]\n             (update-in table [(+ prime x)] conj prime))\n           (primes-step [table d]\n             (if-let [factors (get table d)]\n               (recur (reduce #(reinsert %1 d %2) (dissoc table d) factors)\n                      (inc d))\n               (lazy-seq (cons d (primes-step (assoc table (* d d) (list d))\n                                              (inc d))))))\n           (gen-primes [] (primes-step {} 2) )]\n     (loop [prev 0\n            [p & r ] (gen-primes)]\n       (if (>= p n) (and (= p n) (= p (/ (+ prev (first r)) 2)))\n           (recur p r)))))", "user": "5eee7311e4b07c55ae4a0510"}, {"problem": 116, "code": "(fn [x]\n  (let [lazy-primes ((fn sieve [s]\n  \t\t\t\t(cons (first s)\n        \t\t\t(lazy-seq (sieve (filter #(not= 0 (mod % (first s)))\n                                 (rest s)))))) (iterate inc 2))\n        ps (take-while #(< % (+ 254 x)) lazy-primes)]\n    (if (some #{x} ps)\n      (let [part (partition-by #(= % x) ps)]\n        (= (+ (last (first part)) (first (last part))) (* 2 x)))\n      false\n    )\n  )\n)", "user": "5df08767e4b093ff717275bf"}, {"problem": 116, "code": "(fn [check-balanced] \n  (letfn [ (is-prime [check]\n  (reduce (fn [a v]\n            (if (= a false)\n              false\n              (if (= 0 (mod check v)) false true)))\n          true\n          (range 2 check)))]\n    (if (and (> check-balanced 4) (is-prime check-balanced))\n      (let [prev-prime (loop [check (dec check-balanced)]\n                         (if (is-prime check)\n                           check\n                           (recur (dec check)))) \n            next-prime (loop [check (inc check-balanced)]\n                         (if (is-prime check)\n                           check\n                           (recur (inc check))))\n            mean (-> prev-prime (+ next-prime) (/ 2))\n            \n            ]\n        (= mean check-balanced))\n      false)))", "user": "53c73e8ae4b00fb29b2212a5"}, {"problem": 116, "code": "(fn is_balanced_prime? [n]\n    (letfn [(is_prime? [n]\n                (cond\n                    (<= n 1) false\n                    (<= n 3) true\n                    (or (zero? (mod n 2)) (zero? (mod n 3))) false\n                    :else (loop [i 5]\n                            (cond\n                                (> (* i i) n) true\n                                (or (zero? (mod n i)) (zero? (mod n (+ i 2)))) false\n                                :else (recur (+ i 6))))))\n            \n            (next_prime [n]\n                (loop [n (inc n)]\n                    (if (is_prime? n)\n                        n\n                        (recur (inc n)))))\n            (prev_prime [n]\n                (loop [n (dec n)]\n                    (cond\n                        (= n 1) nil\n                        (is_prime? n) n\n                        :else (recur (dec n)))))]\n        (cond\n            (= n 2) false\n            (not (is_prime? n)) false\n            :else (let [n+ (next_prime n)\n                        n- (prev_prime n)\n                        middle (/ (+ n+ n-) 2)]\n                    (= n middle)))))", "user": "57644395e4b0994c1922fbf2"}, {"problem": 116, "code": "(fn [x]\n  (letfn [(prime? [x]\n            (cond \n             (<= x 3) true\n             (even? x) false\n             :else (not-any? #(= 0 %) (map (partial mod x) (range 3 x 2)))))\n          (genprimes [] (lazy-seq (cons 2 (cons 3 (filter prime? (iterate inc 5))))))]\n    (loop [[p c n :as all] (genprimes)]\n      (cond\n       (> c x) false\n       (= c x) (= (/ (+ p n) 2) c)\n       :else (recur (drop 1 all))))))", "user": "4eb97234535dfed6da9c6d53"}, {"problem": 116, "code": "(fn [n]\n  (first\n   (for [o       (range 1 (- n 2))\n         [a b c] [(for [x [(- n o) (+ n o) n]]\n                    (every? #(pos? (rem x %))\n                            (range 2 x)))]\n         :when (or a b)]\n     (and a b c))))", "user": "5dc88a38e4b02f9375f4e1db"}, {"problem": 116, "code": "(fn [n]\r\n  (if (< n 3)\r\n    false\r\n    (letfn [(prime? [n] (and (> n 1) (not-any? #(zero? (mod n %)) (range 2 n))))]\r\n      (let [below (first (filter prime? (iterate dec (dec n))))\r\n            above (first (filter prime? (iterate inc (inc n))))]\r\n        (prn [n below above])\r\n        (and (prime? n) below\r\n             (= n (/ (+ below above) 2)))))))", "user": "5f2c02d1e4b033932238a65f"}, {"problem": 116, "code": "(fn balanced-prime? [n]\n  (boolean\n    (when (> n 2)\n      (letfn [(prime? [n]\n                (when (and (> n 2) (odd? n))\n                  (every? #(pos? (mod n %)) (range 3 (inc (quot n 2))))))]\n        (when (prime? n)\n          (let [r (fnext (filter prime? (iterate inc n)))\n                l (- (* 2 n) r)]\n            (and\n              (prime? l)\n              (empty? (filter prime? (range (inc l) n))))))))))", "user": "5f300f28e4b033932238a682"}, {"problem": 116, "code": "(fn bal-prime [p]\n  (letfn [(sieve [s]\n            (cons (first s)\n                  (lazy-seq (sieve (filter #(not= 0 (mod % (first s))) (rest s))))))\n          (take-nums [[a b c] s]\n            (cond (= b p) (= (- b c) (- a b))\n                  (> c p) false\n                  :else (take-nums (cons (first s) [a b]) (rest s)))) ]\n    (take-nums [-1 -1 -1] (sieve (iterate inc 2)))))", "user": "53a5bc3ae4b0ef122a8689c3"}, {"problem": 116, "code": "(fn [n]\n                  (letfn [(is-prime [n] (every? #(not= (mod n %) 0) (range 2 n)))]\n                    (println (is-prime n))\n                    (and\n                     (is-prime n)\n                     (let [small (first (filter is-prime (range (dec n) 1 -1)))\n                           big (first (filter is-prime (map #(+ (inc n) %) (range))))]\n                       (if (every? #(not (nil? %)) [small big])\n                         (= (/ (+ small big) 2) n)\n                         false)\n                       ))))", "user": "5f3f2281e4b004f08c61c561"}, {"problem": 116, "code": "(fn balanced-prime? [n]\n  (let [factors (cons 2 (iterate (partial + 2) 3))\n        prime? (fn [n] (not-any? #(zero? (mod n %))\n                                 (take-while #(<= % (inc (Math/sqrt n))) factors)))\n        prime-step (fn [n s] (first (drop-while (complement prime?) (rest (iterate (partial + s) n)))))]\n    (and (> n 3)\n         (prime? n)\n         (= n (/ (+ (prime-step n 2) (prime-step n -2)) 2)))))", "user": "5cf895efe4b0b71b1d808a85"}, {"problem": 116, "code": "(fn balanced-prime [n] (let [\n\tprime (fn [j] ; search from 2 to (ceil Math/sqrt N)\n\t\t(loop [i (int (Math/sqrt j))]\n\t\t\t(cond\n\t\t\t\t(< j 2) false\n\t\t\t\t(= i 1) true\n\t\t\t\t(= 0 (mod j i)) false\n\t\t\t\t(identity true) (recur (dec i))\n\t\t\t)\n\t\t)\n\t)]\n\t(and \n\t\t(prime n)\n\t\t(loop [i 1]\n\t\t\t(cond\n\t\t\t\t(< (- n i) 2) false\n\t\t\t\t(and (prime (- n i)) (prime (+ n i))) true\n\t\t\t\t(or (prime (- n i)) (prime (+ n i))) false\n\t\t\t\t(= 1 1) (recur (inc i))\n\t\t\t)\n\t\t)\n\t)\n))", "user": "5d73530ce4b02e6b30c93514"}, {"problem": 116, "code": "(fn [n]\n  (letfn [(prime? [p]\n    (and (>= p 2)\n      (or (= p 2)\n          (every? #(> (rem p %) 0)\n                  (range 2 (inc (quot p 2)))))))]\n  (and\n    (> n 2)\n    (prime? n)\n    (let [p1 (first (filter prime? (iterate dec (dec n))))\n          p2 (first (filter prime? (iterate inc (inc n))))]\n      (== n (/ (+ p1 p2) 2))))))", "user": "4f3e6244e4b0e243712b1f85"}, {"problem": 116, "code": "(fn [n]\n    (if (<= n 3) false\n    (let [prime? (fn [n] (if (<= n 1) false\n                        (not (some #(zero? (mod n %)) (range 2 n)))))\n          lo (first (filter prime? (range (dec n) 1 -1)))\n          hi (first (filter prime? (range (inc n) (* 2 n) 1)))\n          bal (= n (quot (+ lo hi) 2))\n          ]\n        ;(println (prime? n) lo n hi bal)\n        (if (prime? n) bal false)\n        )))", "user": "5eff6c0ee4b0cf489e8d7f11"}, {"problem": 116, "code": "(fn prime-sandwich? [n]\n  (letfn [(prime? [n]\n                  (and\n                   (> n 1)\n                   (not-any? #(zero? (mod n %)) (range 2 n))))]\n    (and\n     (> n 2)\n     (prime? n)\n     (let [primes (lazy-seq (filter prime? (range)))\n           primes-before (take-while #(<= % n) primes)\n           prime-before (last (butlast primes-before))\n           prime-after (first (drop (count primes-before) primes))]\n       (= n (/ (+ prime-before prime-after) 2))))))", "user": "5f63d933e4b02876ed9fd018"}, {"problem": 116, "code": "(fn [n]\n  (letfn [(is-prime [n] (not-any?\n                         #(zero? (rem n %))\n                         (range 2 (inc (int (Math/sqrt n))))))\n          (average [a b] (/ (+ a b) 2))]\n    (and (> n 2)\n         (is-prime n)\n         (let [lower-prime (->> (dec n)\n                                (iterate dec)\n                                (filter is-prime)\n                                first)\n               higher-prime (->> (inc n)\n                                 (iterate inc)\n                                 (filter is-prime)\n                                 first)]\n           (= n (average lower-prime higher-prime))))))", "user": "5f3abcc4e4b004f08c61c52b"}, {"problem": 116, "code": "(fn balanced-prime? [n]\n  (letfn [(prime? [n] (loop [s (range 2 (inc (int (Math/sqrt n))))]\n                        (if (empty? s)\n                          true\n                          (if (= (rem n (first s)) 0)\n                            false\n                            (recur (rest s))))))\n          (next-prime [f n] (loop [n (f n)]\n                              (if (prime? n)\n                                n\n                                (recur (f n)))))]\n    (if (or (= n 0) (= n 1) (= n 2))\n      false\n      (if (not (prime? n))\n        false\n        (let [pnext (next-prime inc n)\n              pprev (next-prime dec n)]\n          (= (/ (+ pnext pprev) 2) n))))))", "user": "5f8b06afe4b0715f5002d74a"}, {"problem": 116, "code": "(fn [n]\n  (let [primes [      2      3      5      7     11     13     17     19     23     29 \n     31     37     41     43     47     53     59     61     67     71 \n     73     79     83     89     97    101    103    107    109    113 \n    127    131    137    139    149    151    157    163    167    173 \n    179    181    191    193    197    199    211    223    227    229 \n    233    239    241    251    257    263    269    271    277    281 \n    283    293    307    311    313    317    331    337    347    349 \n    353    359    367    373    379    383    389    397    401    409 \n    419    421    431    433    439    443    449    457    461    463 \n    467    479    487    491    499    503    509    521    523    541 \n    547    557    563    569    571    577    587    593    599    601 \n    607    613    617    619    631    641    643    647    653    659 \n    661    673    677    683    691    701    709    719    727    733 \n    739    743    751    757    761    769    773    787    797    809 \n    811    821    823    827    829    839    853    857    859    863 \n    877    881    883    887    907    911    919    929    937    941 \n    947    953    967    971    977    983    991    997   1009   1013 \n   1019   1021   1031   1033   1039   1049   1051   1061   1063   1069 \n   1087   1091   1093   1097   1103   1109   1117   1123   1129   1151 \n   1153   1163   1171   1181   1187   1193   1201   1213   1217   1223 \n   1229   1231   1237   1249   1259   1277   1279   1283   1289   1291 \n   1297   1301   1303   1307   1319   1321   1327   1361   1367   1373 \n   1381   1399   1409   1423   1427   1429   1433   1439   1447   1451 ]\n        balanced? (fn [tup]\n                    (let [[a n b] tup]\n                      (= n (/ (+ a b) 2))))\n        p-map (reduce (fn [m tup]\n                        (assoc m (second tup) (balanced? tup)))\n                      {}\n                      (partition 3 1 primes))]\n    (if (get p-map n)\n      true\n      false)))", "user": "5f93529ae4b0715f5002d7bc"}, {"problem": 116, "code": "(fn prime-sandwich? [n]\n  (let [prime? (fn [x]\n                 (cond (< x 2) false\n                       (and (> x 2) (zero? (rem x 2))) false\n                       :else (loop [y (dec x)]\n                               (cond (= y 1) true\n                                     (zero? (rem x y)) false\n                                     :else (recur (dec y))))))\n        next-prime (fn [x f]\n                     (loop [x (f x)]\n                       (if (or (prime? x) (zero? x))\n                         x\n                         (recur (f x)))))\n        mean #(/ (apply + %&) (count %&))]\n    (and\n     (prime? n)\n     (= n (mean (next-prime n inc) (next-prime n dec))))))", "user": "5ea6fe98e4b00a66d4a951b2"}, {"problem": 116, "code": "#(boolean (#{5 53 157 173 211 257 263 373 563 593 607 653 733 947 977 1103} %))", "user": "507e68abe4b085af06e3afd2"}, {"problem": 116, "code": "(fn b-primes? [number]\n  (if (<= number 2)\n    false\n    (let [prime? (fn [n] (empty? (filter zero? (map #(mod n %) (range 2 n)))))\n          next-prime (first (filter prime? (iterate inc (inc number))))\n          last-prime (first (filter prime? (iterate dec (dec number))))]\n      (and (prime? number)\n           (= (- next-prime number) (- number last-prime))))))", "user": "5fa74b82e4b0fa27300f3dda"}, {"problem": 116, "code": "(fn [x] (contains? #{5 53 157 173 211 257 263 373 563 593 607 653 733 947 977 1103} x))", "user": "5e8ce2fee4b0cb0169546328"}, {"problem": 116, "code": "(fn\n  [p]\n  (let [prime? (fn\n                 [innum]\n                 (empty?\n                  (filter\n                   #(= 0 (mod innum %))\n                   (range 2 innum))))]\n    \n\n    (not\n     (empty?\n      (filter (fn [[left mid right]]\n                (and (= mid p)\n                     (= mid (/ (+ left right) 2))))\n              (take-while\n               (fn [[left mid right]]\n                 (<= mid p))\n               (partition 3 1\n                          (filter prime? (drop 2 (range))))))))))", "user": "5bf9d9b7e4b0bdcf453d15c4"}, {"problem": 116, "code": "(fn [n]\n  (letfn [(prime?\n           [n]\n           (not (reduce #(or % %2) false (map #(= 0 (rem n %)) (range 2 (inc (int (java.lang.Math/sqrt n))))))))\n          (prime-under\n           [n]\n           ((fn iter [i] (if (prime? i) i (iter (dec i)))) (dec n)))\n          (prime-above\n           [n]\n           ((fn iter [i] (if (prime? i) i (iter (inc i)))) (inc n)))]\n    (if (or (<= n 3) (not (prime? n))) false\n        (let [below (prime-under n)\n              above (prime-above n)]\n          (= (* 2 n) (+ below above))))))", "user": "58f98231e4b0438e51c2cf4c"}, {"problem": 116, "code": "(fn is-balanced-prime [num]\n  (letfn [(is-prime [num]\n            (if (= num 1) \n              true\n              (loop [cur-divisor (dec num)]\n                (if (= cur-divisor 1)\n                  true\n                  (if (= (mod num cur-divisor) 0)\n                    false\n                    (recur (dec cur-divisor)))))))\n          (find-prev-prime [cur-prime]\n            (loop [num (dec cur-prime)]\n              (if (is-prime num)\n                num\n                (recur (dec num)))))\n          (find-next-prime [last-prime]\n            (loop [num (inc last-prime)]\n              (if (is-prime num)\n                num\n                (recur (inc num)))))]\n    (if (or (= 0 num) (= 1 num) (= 2 num)) \n        false  \n        (if (is-prime num)\n          ; Do other stuff.\n          (= num (/ (+ (find-prev-prime num) (find-next-prime num)) 2))\n          false\n          )))\n)", "user": "5ff676a9e4b06df49cee1497"}, {"problem": 116, "code": "(fn [n]\n    (if (<= n 3)\n        false\n        (letfn [(sieve\n                ([] (sieve (iterate inc 2) 2))\n                ([s n] (let [m (first s)]\n                           (lazy-seq (cons m (sieve (filter #(not= (rem % m) 0) s) (inc n)))))))]\n        (let [s (sieve)\n              [p1 ps] (loop [x (first s)\n                             xs (rest s)]\n                          (if (>= (first xs) n)\n                              [x xs]\n                              (recur (first xs) (rest xs))))\n              p2 (first ps)\n              p3 (first (rest ps))]\n            (and (= n p2) (= n (quot (+ p1 p3) 2)))))))", "user": "600ae927e4b074f607df6689"}, {"problem": 116, "code": "#(contains? #{5, 53, 157, 173, 211, 257, 263, 373, 563, 593, 607, 653, 733, 947, 977, 1103} %)", "user": "5cb41c40e4b026601754b911"}, {"problem": 116, "code": "(fn [n]\n(letfn [(p? [i] (and (> i 1) (not-any? #(= 0 (mod i %)) (range 2 i))))]\n(and (> n 2) (p? n)\n(let [ps (filter p? (range))\n[ps- ps+] (split-with #(>= n %) ps)\np1 (last (butlast ps-))\np2 (first ps+)]\n(= n (/ (+ p1 p2) 2))))))", "user": "5fd10010e4b07e53c2f3f02a"}, {"problem": 116, "code": "(fn [n]\n  (letfn [(sieve [[x & xs]] (lazy-seq (cons x (sieve (remove #(zero? (mod % x)) xs)))))]\n    (let [[xs [y z & zs]] (split-with #(< % n) (sieve (iterate inc 2)))]   \n      (and (seq xs)\n           (= n y)\n           (= n (/ (+ (last xs) z) 2))))))", "user": "5e3e23d9e4b01d43a70e8e20"}, {"problem": 116, "code": "(fn balanced-prime? [n]\n  (let [factors (cons 2 (iterate (partial + 2) 3))\n        prime? (fn [n] (not-any? #(zero? (mod n %))\n                                 (take-while #(<= % (inc (Math/sqrt n))) factors)))\n        prime-step (fn [n s] (first (drop-while (complement prime?) (rest (iterate (partial + s) n)))))]\n    (and (> n 3)\n         (prime? n)\n         (= n (/ (+ (prime-step n 2) (prime-step n -2)) 2)))))", "user": "601aaa93e4b0bf4ca6b10926"}, {"problem": 116, "code": "(letfn [(not-mult? [i f] (not= (mod i f) 0))\n         (prime? [n] (or (= n 2) (= n 3) (= n 5) (= n 7) (= n 11) \n                     (and (> n 2) (odd? n) (not-mult? n 3) (not-mult? n 5) (not-mult? n 7) (not-mult? n 11)\n                          (reduce #(and %1 %2) (for [x (range 3 (inc (int (Math/sqrt n))) 2)] (not-mult? n x))))))]\n   (fn [i]\n     (and (prime? i)\n          (let [next (loop [j (+ i 2)] (if (prime? j) j (recur (inc j))))\n                prev (loop [j (- i 2)] (if (< j 2) nil (if (prime? j) j (recur (dec j)))))]\n            (and (not (nil? prev)) (= (- next i) (- i prev)))))))", "user": "6011b89ee4b074f607df66bc"}, {"problem": 116, "code": "(fn balanced-prime? [n]\n   (letfn [(is-prime? [n]\n             (if (< n 2)\n               false\n               (not-any? #(= 0 (mod n %)) (take-while #(<= (* % %) n) (range 2 n)))\n              )\n            )\n          ]         \n    (and  (> n 2)\n          (is-prime? n)\n          (= n (/ (+ (first (filter is-prime? (iterate inc (inc n)))) \n                  (first (filter is-prime? (iterate dec (dec n))))\n               ) 2)\n          )\n    ) \n  )\n)", "user": "5fd8bcb3e4b05ac5b16ea11b"}, {"problem": 116, "code": "(fn [n]\n  (letfn [(isprime? [n]\n                    (if (= n 1) true\n                    (loop [nn n c 2]\n                      (cond (= nn c) true\n                            (= (rem nn c) 0) false\n                            :else (recur nn (inc c))))))\n          \n          (myindex [se v]\n                   (loop [se2 se c 0]\n                     (cond (= (first se2) v) c\n                           (> (first se2) v) -1\n                           :else (recur (rest se2) (inc c)))))\n          ]\n    (let [lst (filter #(isprime? %) (range))\n          dex (myindex lst n)]\n      (if (= -1 dex) false (if (> dex 1) (= (double n)\n                              (double (/ (+ (nth lst (dec dex))\n                                            (nth lst (inc dex))) \n                                         2))) false)))))", "user": "60264d89e4b0d5df2af2222d"}, {"problem": 116, "code": "(fn [x]\n  (let [prime #(if (#{2 3} %)\n                 true\n                 (loop [n 2]\n                   (cond\n                     (zero? (mod % n)) false\n                     (> n (quot (inc %) 2)) true\n                     :else (recur (inc n)))))]\n    (and (> x 2)\n         (prime x)\n         (= (+ (first (filter prime (reverse (range x))))\n               (first (filter prime (drop (inc x) (range)))))\n            (* x 2)))))", "user": "60096aabe4b074f607df667f"}, {"problem": 116, "code": "(fn [n]\n   (letfn [(prime? [x] (every? #(not (zero? (rem x %))) (range 2 x)))]\n     (and (> n 2) (prime? n)\n          (= (/\n              (+ (some #(if (prime? %) %) (drop (+ n 1) (range)))\n                 (some #(if (prime? %) %) (reverse (range n))))\n              2)\n             n))))", "user": "604d3cb1e4b0b7ec0ac60ac2"}, {"problem": 116, "code": "(fn [n]\n  (if (<= n 2) false\n      (letfn [(prime? [n] (every? (fn [d] (not (zero? (mod n d)))) (range 2 n)))]\n        (and (prime? n)\n             (= n (/ (+ (first (filter prime? (range (dec n) 1 -1)))\n                        (first (filter prime? (drop (inc n) (range)))))\n                     2))))))", "user": "60460824e4b02d28681c77bc"}, {"problem": 116, "code": "(fn balance-prime-number?\n  [n]\n  (let [next-prime (fn [v]\n                     (loop [x (inc (last v))]\n                       (if (some #(= 0 (mod x %)) v)\n                         (recur (inc x))\n                         (conj v x))))\n        prime-numbers (map last (iterate #(next-prime %) [2]))\n        balance-primes (map second (filter (fn [ [a b c]]\n                                             (= (+ a c) (* 2 b)))\n                                           (partition 3 1 prime-numbers)))]\n    (= n (some #(and (>= % n)\n                     %)\n               balance-primes))))", "user": "4e586949535d8a8b8723a292"}, {"problem": 116, "code": "(fn is-balanced-prime? [n]\n  (letfn [(is-prime[n]\n            (cond (= n 2) true\n                  :else\n                  (let [bi (BigInteger. (str 2))]\n                    (=\n                     (-> (.pow bi n)\n                         (.mod (BigInteger. (str n))))\n                     (.mod bi (BigInteger. (str n)))))))\n          \n          (get-next[x]\n            (let [initial x\n                  xx (atom (+ x x))]\n              (fn[] (let [y @xx]\n                      (swap! xx #(+ %1 initial))\n                      y))))\n          (seive-of-erastha[n]\n            (let [nums (atom (vec (nthrest (range n) 2)))]\n              (loop [index 0]\n                (cond (= index (count @nums)) (filter #(> % 0) @nums)\n                      (> (nth @nums index) 0) (do\n                                                (let [x (nth @nums index)\n                                                      next (get-next x)]\n                                                  (loop [next-num (next)]\n                                                    (cond (< next-num n) (do\n                                                                           (swap! nums #(assoc % (+ index (- next-num x)) 0))\n                                                                           (recur (next)))\n                                                          :else true)))\n                                                (recur (inc index)))\n                      :else (recur (inc index))))))]\n  (cond (<= n 2) false\n        (not (is-prime n)) false\n    :else (let [preceding-primes (seive-of-erastha n)\n                more-primes (seive-of-erastha (+ n 200))]\n            (= n\n               (/ (+ (last preceding-primes)\n                     (nth more-primes (inc (count preceding-primes)))) 2))))))", "user": "5bab31f1e4b0a20761a23471"}, {"problem": 116, "code": "(fn [n]\n  (and (> n 2)\n  (let [prime?\n        (fn [n] (and (> n 1) (not-any? #(zero? (mod n %)) (range 2 (inc (int (Math/sqrt n)))))))\n        adjacent-prime \n        (fn [op] (first (filter prime? (iterate op (op n)))))\n        left (adjacent-prime dec)\n        right (adjacent-prime inc)]\n    (and (prime? n) (= (- n left) (- right n))))))", "user": "605b7a90e4b079a07f8593fc"}, {"problem": 116, "code": "(fn balanced-prime? [n]\n  (letfn [(primes [n]\n            (loop [i 2 s #{} p []]\n              (if (< n i)\n                (reverse p)\n                (if (contains? s i)\n                  (recur (inc i) s p)\n                  (recur (inc i)\n                         (clojure.set/union s (set (range i (* 2 n) i)))\n                         (conj p i))))))]\n\n      (let [p (vec (primes (* 2 n)))\n            j (.indexOf p n)]\n        (if (= -1 j)\n          false\n            (let [pred (get p (dec j))\n                  subs (get p (inc j))]\n\n              (if (and pred subs)\n                (= (/ (+ pred subs) 2) n)\n                false))))))", "user": "58b81490e4b0ebc645576d8c"}, {"problem": 116, "code": "(fn balanced-prime? [n]\n  (letfn [(prime-sieve [] (filter\n                           (fn is-prime [n]\n                             (nil?\n                              (some\n                               #(zero? (mod n %))\n                               (range 2 n))))\n                           (range 2 2000)))\n          (primes-interval [n]\n            (let [[a b c & more] (prime-sieve)]\n              (loop [acc [a b c] primes more]\n                (if (> (last acc) n)\n                  acc\n                  (recur (conj (vec (rest acc)) (first primes))\n                         (rest primes))))))]\n    (let [[a b c] (primes-interval n)]\n      (and (= n b) (= n (/ (+ a c) 2))))))", "user": "5f419985e4b0955706451fab"}, {"problem": 116, "code": "(fn [numb]\n  (letfn [(prime? [a-num] (not-any? zero? (map #(rem a-num %) (range 2 a-num))))\n          (find-prime [diff-num direction]\n              (loop [mb-prime (direction diff-num)]\n                 (if (prime? mb-prime)\n                     mb-prime\n                    (recur (direction mb-prime)))))]\n    (if (and (prime? numb) (> numb 2))\n        (= numb (/ (+ (find-prime numb inc) (find-prime numb dec)) 2))\n        false)))", "user": "5f548678e4b0a0bc16850a7e"}, {"problem": 116, "code": "(fn balanced [n]\n    (letfn \n      [\n        (sieve [s]\n  (cons (first s)\n        (lazy-seq (sieve (filter #(not= 0 (mod % (first s)))\n                                 (rest s))))))\n\n        (prime [x]\n        (->> \n        (range 2 x)\n        (map #(mod x %))\n        (some #{0})\n        (boolean)\n        (not)))]\n        (if (and (prime n) (> n 2)) \n          (let [ind (.indexOf (sieve (iterate inc 2)) n)]\n            (= n (/ (+ (nth (sieve (iterate inc 2)) (inc ind)) \n                   (nth (sieve (iterate inc 2)) (dec ind))) 2)))\n          false)))", "user": "5fab7ea6e4b08cb800c85ad8"}, {"problem": 116, "code": "(fn [n]\n    (letfn [(h [n] (every? #(pos? (mod n %)) (range 2 (inc (Math/floor (Math/sqrt n))))))\n            (g [m] (count (take-while #(not (h %)) m)))]\n      (and (>= n 5)\n           (h n)\n           (= (g (map #(+ n 1 %) (range)))\n              (g (range (dec n) 1 -1))))))", "user": "5bd0ea60e4b0e9689409ee45"}, {"problem": 116, "code": "(fn prime-sandwich? [n]\n  (letfn [(prime? [n]\n                  (and\n                   (> n 1)\n                   (not-any? #(zero? (mod n %)) (range 2 n))))]\n    (and\n     (> n 2)\n     (prime? n)\n     (let [primes (lazy-seq (filter prime? (range)))\n           primes-before (take-while #(<= % n) primes)\n           prime-before (last (butlast primes-before))\n           prime-after (first (drop (count primes-before) primes))]\n       (= n (/ (+ prime-before prime-after) 2))))))", "user": "607d6bc1e4b03d835a6eaecc"}, {"problem": 116, "code": "(fn ps [n]\n  (first (for [o (range 1 (- n 2))\n               [a b c] [(for [x [(- n o) (+ n o) n]]\n                          (every? (fn [b] (> (rem x b) 0)) (range 2 x)))]\n               :when (or a b)]\n           (and a b c))))", "user": "54d7e277e4b0a52adc2e2031"}, {"problem": 116, "code": "(fn prime-sandwich?\n  [x]\n  (let [is-it-prime? (fn [my-num]\n                       (reduce (fn [b num]\n                                          (and b (if (zero? (rem my-num num))\n                                                   false\n                                                   true))) true (range 2 my-num)))\n        before (loop [start (dec x)\n                      my-prime []]\n                 (cond\n                   (= start 0) 0\n                   (is-it-prime? start) start\n                   :else (recur (dec start) my-prime)\n                   ))\n        after (- (* x 2) before)]\n    (and\n      (>= x 5)\n      (is-it-prime? x)\n      (= 1 (count (reduce (fn [my-list item]\n                            (if (is-it-prime? item)\n                              (conj my-list item)\n                              my-list)) [] (range (inc before) after))))\n         (is-it-prime? (- (* x 2) before)))))", "user": "60396c95e4b0d5df2af222f4"}, {"problem": 116, "code": "(fn balanced-prime? [num]\n  (letfn [(prime? [x] (and (> x 1) (not-any? #(zero? (mod x %)) (range 2 x))))\n          (fprime [num f] (first (filter prime? (iterate f (f num)))))]\n    (and (> num 2) (prime? num)\n         (let [[prev nxt] (map #(fprime num %) [dec inc])]\n           (= (+ nxt prev) (* 2 num))))))", "user": "5f82609ae4b0c071e6c840f9"}, {"problem": 116, "code": "(fn [n]\n  (let [next-prime (fn next-prime [f n]\n                     (loop [n (f n)]\n                       (if (empty? (filter identity (map #(= 0 (mod n %)) (range 2 (inc (int (Math/sqrt n)))))))\n                         n\n                         (recur (f n)))))\n        isprime? (and (> n 2) (empty? (filter identity (map #(= 0 (mod n %)) (range 2 (inc (int (Math/sqrt n))))))))\n        b4 (next-prime dec n)\n        after (next-prime inc n)\n        avg (/ (+ b4 after) 2)]\n    (and isprime? (= avg n))))", "user": "608ec5e4e4b03bd49d9f36c0"}, {"problem": 116, "code": "(fn[n]\n  (let [nprimes (loop [xs (range 3 (* 2 n) 2) r []]\n                  (if (empty? xs)\n                    r\n                    (let [x (first xs)]\n                      (recur (filter  (complement (set (take-while #(< % (* 2 n)) (iterate #(+ x %) x)))) xs) (conj r x)))))\n        mv (map-indexed vector nprimes)\n        p (some (fn [[x y]] (if (= n y) [x y])) mv)]\n    (if (or (not p) (< (count nprimes) 3))\n      false\n      (let [pm (into {} mv)\n            i (first p)\n            a (pm (dec i))\n            b (pm (inc i))]\n        (= (p 1) (/ (+ a b) 2))))))", "user": "5e12327ee4b099d064962fe5"}, {"problem": 116, "code": "(fn [number]\n  (letfn [(prime? [n] (not-any? zero? (map #(rem n %) (range 2 n))))]\n    (if (or (not (prime? number)) (< number 3))\n      false\n      (loop [delta 1]\n        (let [primel (prime? (- number delta)) primer (prime? (+ number delta))]\n          (cond\n            (and primel primer) true\n            (or primel primer) false\n            :else (recur (inc delta))))))))", "user": "60b2aaebe4b0e0fa5f1b4228"}, {"problem": 116, "code": "(fn bal [n]\n  (let [take-two\n        (fn t [pred coll]\n          (lazy-seq\n           (when-let [s (seq coll)]\n             (if (pred (first s))\n               (cons (first s) (t pred (rest s)))\n               (list (first s))))))\n        prime? (fn [x] (not-any? #(zero? (mod x %)) (range 2 x)))\n        [prev cur next] (->> (range)\n                        (drop 2)\n                        (filter prime?)\n                        (take-two #(<= % n))\n                        (take-last 3))]\n    (and (= n cur) (= (- next cur) (- cur prev)))))", "user": "60b7e2c5e4b0e0fa5f1b4252"}, {"problem": 116, "code": "(fn balanced-prime? [n]\n  (letfn [(prgen [p cands]\n                 (lazy-seq (cons p (prgen (first cands)\n                                           (filter #(not= 0 (mod % p)) (rest cands))))))]\n    (let [primes (prgen 2 (iterate (partial + 2) 3))\n          index (dec (count (take-while #(<= % n) primes)))\n          adj-primes (take 3 (drop (dec index) primes))]\n      (if (not= (second adj-primes) n)\n        false\n        (= n (/ (+ (first adj-primes) (last adj-primes)) 2))))))", "user": "51b920bfe4b0e871ca4958f9"}]