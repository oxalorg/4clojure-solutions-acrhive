[{"code": "(fn [board color]\n  (let [;; we'll need to verify that we only \"capture\" enemy pieces\n        enemy? #{('{b w, w b} color)}\n\n        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n        ;;; board/position related constants ;;;\n        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n        h (count board)\n        w (count (first board))\n        dims [h w]\n\n        ;; all the [dy dx] pairs you could try \"walking\" to from a position\n        neighbors (let [deltas [-1 0 1]]\n                    ;; restricting the scope of deltas to where it is used\n                    (for [y deltas, x deltas\n                          :when (not= y x 0)]\n                      [y x]))\n\n        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n        ;;; functions for getting board-based information from coordinates ;;;\n        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n        ;; is this position even on the board?\n        valid? (fn [pos]\n                 (every? true?\n                         ;; here we make use of extra-arity map <\n                         ;; map \"expands\" like (and (< -1 y h)\n                         ;;                         (< -1 x w))\n                         ;; with 3+ args, < tests \"ascending\", so we can pin\n                         ;; y and x in the range of [0, max).\n                         (map < [-1 -1] pos dims)))\n\n        ;; who's at this location?\n        piece #(get-in board %)\n        ;; is this location empty?\n        vacant? (comp #{'e} piece)\n\n        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n        ;;; Reversi-specific functions ;;;\n        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n        ;; given a position and a direction, \"walk\" in that direction until you\n        ;; fall off the board, returning a seq of all the coordinates traversed\n        pointer (fn [pos dir]\n                  (->> pos\n                       (iterate #(map + dir %))\n                       (take-while valid?)))\n\n        ;; Here is the heart of the algorithm. Given a position and a direction,\n        ;; return a seq of all the positions that would be captured in that\n        ;; direction by a play at the chosen position.\n        ;; Inline comments would clutter things too much, but expect an\n        ;; upcoming blog post breaking down what's going on.\n        impacted (fn [pos dir]\n                   (let [tokens (pointer pos dir)\n                         [captured end] (split-with (comp not #{color} first)\n                                                    (map (juxt piece identity)\n                                                         (rest tokens)))]\n                     (when (and (= color (ffirst end))\n                                (every? (comp enemy? first) captured))\n                       (map second captured))))]\n    (into {}\n          (for [;; find all the vacant positions on the board\n                y (range h), x (range w), :let [pos [y x]]\n                :when (vacant? pos)\n\n                ;; for each one, check for captures in every direction\n                :let [flipped (for [n neighbors]\n                                (impacted pos n))]\n\n                ;; if no direction has any captures, don't mention this position\n                :when (some seq flipped)]\n            ;; create a k/v pair of [position, (all-captured-pieces)]\n            [pos (set (apply concat flipped))]))))", "problem": 124, "user": "4dabb7b1950ed6eda1bd72f3"}, {"code": "(fn [G b c]\n  (reduce (fn [m p]\n            (if-let [f (seq (mapcat\n                             (fn [d]\n                               (let [[f e] (split-with #(not (#{'e c} (G b %)))\n                                                       (rest (take-while (fn [[y x]] (and (< -1 y 4) (< -1 x 4)))\n                                                                         (iterate #(map + % d) p))))]\n                                 (if (and (> (count f) 0)\n                                          (= (G b (first e)) c))\n                                   f)))\n                             (for [y [-1 0 1] x [-1 0 1] :when (not= 0 x y)] [y x])))]\n              (assoc m p (set f))\n              m))\n          {}\n          (for [y [0 1 2 3] x [0 1 2 3] :when (= (G b [y x]) 'e)] [y x])))\nget-in", "problem": 124, "user": "4e52d815535d302ef430da77"}, {"code": "(fn [bd col] (letfn [\n(opponent [pc]\n  ('{w b b w} pc))\n\n(valid [[r c]]\n  (and (< -1 r 4) (< -1 c 4)))\n\n(is? [board color [r c] ]\n  (= (get-in board [r c]) color) )\n\n(neighbors [[r c]]\n  (filter\n    valid\n    (map\n      (fn [[dr dc]] [(+ dr r)(+ dc c)])\n      (for [i [-1 0 1] j (if (zero? i) [-1 1] [-1 0 1])]\n    [i j]))))\n\n(getdirflips [board color [sr sc] [dr dc] flips]\n   (let [newr (+ dr sr)\n         newc (+ dc sc)\n         flips (concat [[sr sc]] flips)\n         ]\n     (cond\n       (is? board color [newr newc])   (getdirflips board color [newr newc] [dr dc] flips)\n       (is? board (opponent color) [newr newc]) flips\n       :else  nil)))\n\n(neighbors-of-color [board color [r c] ]\n (filter (partial is?  board color) (neighbors [r c])))\n\n(getneighbordirection [[sr sc] [nr nc]]\n  [(- sr nr)(- sc nc)])\n\n(getempties [board]\n  (filter\n    (partial is? board 'e)\n    (for [r (range 4) c (range 4)][r c])))\n\n(getpossiblemoves [board neighbor-opp color]\n  (map (fn [[neigh opps]] [neigh\n            (mapcat\n              (fn [opp] (let [dir (getneighbordirection opp neigh)]\n                (getdirflips board color opp dir [])))\n              opps)])\n    neighbor-opp))\n\n(getmoves [board color]\n    (let [ opp (opponent color)\n           empties  (getempties board)\n           withneighs (map (fn [e] [e (neighbors-of-color board opp e)]) empties)\n           possiblemoves   (getpossiblemoves board withneighs opp)\n           moves (filter (fn [[neigh flips]] (seq flips)) possiblemoves )\n           moves (reduce (fn [m [neigh flips]] (assoc m neigh (set flips))) {} moves)]\n    moves\n  ))]\n(getmoves bd col)))", "problem": 124, "user": "4daa374930acd6ed13482a68"}, {"code": "(fn [b c]\r\n  (let [h (count b) w (count (first b))\r\n        d [[-1 -1] [-1 0] [-1 1] [0 -1] [0 1] [1 -1] [1 0] [1 1]]\r\n        f (fn [p s r]\r\n            (let [[nr nc] (map + p s) n [nr nc]]\r\n              (if (or (< nr 0) (>= nr h) (< nc 0) (>= nc w)) nil\r\n                  (condp = (get-in b n)\r\n                    c r\r\n                    'e nil\r\n                    (recur n s (conj r n))))))]\r\n    ((fn [m [x & xs]]\r\n       (if (nil? x) m\r\n           (if (= (get-in b x) 'e)\r\n             (let [l (keep #(f x % nil) d)]\r\n               (if (not-empty l) (recur (assoc m x (apply set l)) xs)\r\n                   (recur m xs)))\r\n             (recur m xs))))\r\n     {} (for [r (range h) c (range w)] [r c]))))", "problem": 124, "user": "4dc1ee85535d020aff1edf91"}, {"code": "(fn [board color]\n  (let [distances [[-1 -1] [-1 0] [-1 1]\n                   [0 -1] [0 1]\n                   [1 -1] [1 0] [1 1]]\n        reverse-color ({'b 'w 'w 'b} color)]\n    (letfn [(stone-at [point]\n              (get-in board point))\n            (move-point [point distance]\n              (map + point distance))\n            (line-flipped-points [point distance]\n              (loop [current (move-point point distance) flipped #{}]\n                (let [stone (stone-at current)]\n                  (cond (= stone color) flipped\n                        (= stone reverse-color) (recur (move-point current distance)\n                                                       (conj flipped current))\n                        :else #{}))))\n            (flipped-points-at [point]\n              (reduce into (map #(line-flipped-points point %) distances)))\n            (flipped-points [rest-points]\n              (if (empty? rest-points)\n                ()\n                (let [point (first rest-points)]\n                  (if (not (= 'e (stone-at point)))\n                    (recur (rest rest-points))\n                    (let [flipped (flipped-points-at point)]\n                      (if (empty? flipped)\n                        (recur (rest rest-points))\n                        (lazy-seq (cons [point flipped]\n                                        (flipped-points (rest rest-points))))))))))]\n    (reduce (fn [result [put-point flipped-points]]\n              (assoc result put-point flipped-points))\n            {}\n            (flipped-points (for [y (range (count board))\n                                  x (range (count (first board)))]\n                              [y x]))))))", "problem": 124, "user": "4e7c8fd1535db169f9c796be"}, {"code": "(fn re [brd m]\r\n  (let [\r\n\t      om (m '{b w w b})\r\n\t\t\t\td1 (fn [[y x]] [(+ y 1) (+ x 1)])\r\n\t\t\t\td2 (fn [[y x]] [(- y 1) (+ x 1)])\r\n\t\t\t\tld (fn [d p c] (take c (iterate d p)))\r\n\t\t\t\th (map #(for [x (range 4)] [% x]) (range 4))\r\n\t\t\t\tv (map #(for [y (range 4)] [y %]) (range 4))\r\n\t\t\t\tdd1 (list (ld d1 [0 0] 4) (ld d1 [1 0] 3) (ld d1 [0 1] 3))\r\n\t\t\t\tdd2 (list (ld d2 [3 0] 4) (ld d2 [2 0] 3) (ld d2 [3 1] 3))\r\n\t\t\t\tps (apply concat ((juxt identity #(map reverse %)) (concat h v dd1 dd2)))\r\n\t    ]\r\n\t  (reduce\r\n\t\t  #(loop [[c & cs] %2 r? false fl #{} res %1]\r\n\t\t    (let [el (get-in brd c)]\r\n\t\t\t    (if (nil? c)\r\n\t\t\t      res\r\n\t\t\t      (recur \r\n\t\t\t        cs \r\n\t\t\t        (or (= m el) (and r? (not= 'e el)))\r\n\t\t\t        (if (and r? (= om el)) (conj fl c) #{}) \r\n\t\t\t        (if (and r? (= 'e el) (not (empty? fl))) (assoc res c fl) res)))))\r\n\t\t  {}\r\n\t\t  ps)))", "problem": 124, "user": "4e6e10d8535d5021c1a895fd"}, {"code": "(fn analyze-reversi [board color]\n  (let [zip   (partial map vector)\n        unzip (partial apply zip)\n        enum  (partial zip (iterate inc 0))\n        oppon ('{b w w b} color)\n        max-r ((comp dec count)       board)\n        max-c ((comp dec count first) board)\n        trans [[ 1  0] [ 1  1] [ 0  1] [-1  1]\n               [-1  0] [-1 -1] [ 0 -1] [ 1 -1]]\n        inbd? (fn [[i j]] (and (<= 0 i max-r) (<= 0 j max-c)))\n        lines (fn [i j]\n                (map (comp #(take-while inbd? %) next\n                           #(iterate (partial map + %) [i j]))\n                     trans))\n        getbd (partial map #(get-in board %))\n        somef (fn [line]\n                (when (> (count line) 1)\n                  (let [[ts ds] (split-with (comp #{oppon} first)\n                                            (zip (getbd line) line))]\n                    (when (and (seq ts) (= (ffirst ds) color))\n                      (set (map second ts))))))]\n    (into {}\n          (for [[i xs] (enum board), [j x] (enum xs) :when (= x 'e)\n                :let [pts (some somef (lines i j))]\n                :when pts]\n            [[i j] pts]))))", "problem": 124, "user": "4e6a412e535d8ccf87e9feb6"}, {"code": "(fn [G b c]\r\n  (reduce (fn [m p]\r\n            (if-let [f (seq (mapcat\r\n                             (fn [d]\r\n                               (let [[f e] (split-with #(not (#{'e c} (G b %)))\r\n                                                       (rest (take-while (fn [[y x]] (and (< -1 y 4) (< -1 x 4)))\r\n                                                                         (iterate #(map + % d) p))))]\r\n                                 (if (and (> (count f) 0)\r\n                                          (= (G b (first e)) c))\r\n                                   f)))\r\n                             (for [y [-1 0 1] x [-1 0 1] :when (not= 0 x y)] [y x])))]\r\n              (assoc m p (set f))\r\n              m))\r\n          {}\r\n          (for [y [0 1 2 3] x [0 1 2 3] :when (= (G b [y x]) 'e)] [y x])))\r\nget-in", "problem": 124, "user": "4db858d1535d1e037afb218c"}, {"code": "(fn __ [b c]\n  (let [xsz (count b)\n        ysz (count (first b))\n        colors (filter #(= c (get-in b %))\n                       (for [x (range xsz)\n                             y (range ysz)]\n                         [x y]))\n        rows (fn [[x y]] [(for [x (range xsz)] [x y])\n                         (for [y (range ysz)] [x y])\n                         (let [m (min x y)]\n                           (filter (fn [[x y]] (and (< x 4) (< y 4)))\n                                   (for [z (range 4)]\n                                     [(+ (- x m) z) (+ (- y m) z)])))\n                         (filter (fn [[x y]] (and (< x 4) (< y 4) (>= x 0) (>= y 0)))\n                                 (for [z (range -4 4)]\n                                   [(+ x z) (- y z)]))])\n        empties (fn [r] (filter #(= 'e (get-in b %)) r))\n        between (fn [x1 x2 r]\n                  (let [r (vec r)]\n                    (map r\n                         (into\n                          (range (.indexOf r x1) (inc (.indexOf r x2)))\n                          (range (.indexOf r x2) (inc (.indexOf r x1)))))))\n        c-rows (map #(vector % (rows %)) colors)\n        c-empty (reduce (fn [agg [c r]]\n                          (into agg (map #(vector c % (empties %)) r))) [] c-rows)\n        is-flip? (fn [x] (and (not= x c) (not= x 'e)))\n        moves (reduce (fn [agg [c r es]]\n                        (into agg\n                              (map (fn [e] (let [bt (between c e r)]\n                                            [e (filter #(is-flip? (get-in b %)) bt)])) es))) [] c-empty)\n        valid-moves (apply hash-map\n                           (reduce #(into %1 %2) []\n                                   (set\n                                    (map (fn [[c l]] [c (set l)])\n                                         (filter (fn [[_ l]] (seq l)) moves)))))]\n    valid-moves))", "problem": 124, "user": "4db4714f535dc0f10411755a"}, {"code": "(fn [b t]\n  (into {}\n    (for [x (range 4) y (range 4)\n          :let [s [y x]\n                f (if (= (get-in b s) 'e)\n                    (set (mapcat (fn [d]\n                                   (loop [n 1 fs #{}]\n                                     (let [s (map #(+ %1 (* %2 n)) s d)\n                                           c (get-in b s)]\n                                       (if ('#{w b} c)\n                                         (if (= c t)\n                                           fs\n                                           (recur (inc n) (conj fs s)))))))\n                                 [[-1 -1] [0 -1] [1 -1] [-1 0] [1 0] [-1 1] [0 1] [1 1]])))]\n                   :when (seq f)]\n               [s f])))", "problem": 124, "user": "4e8612f8535db62dc21a62f2"}, {"code": "(fn [B P]\r\n  (let [W (count B)\r\n        d (fn [x] [(range x W) (repeat W x) (range x -1 -1)])]\r\n    (into {}\r\n          (for [y (range W) x (range W)]\r\n            (mapcat #(if (seq %) {[y x] (set %)})\r\n                    (for [i (d y) j (d x) :let [l (map vector i j)]]\r\n                      (-> P {'b #\"^ew+b\" 'w #\"^eb+w\"}\r\n                          (re-find (apply str (map #(get-in B %) l)))\r\n                          count dec (take l) rest)))))))", "problem": 124, "user": "4dce6e41535d5973398f92a2"}, {"code": "(fn ar[b p]\n  (let [op (if (= 'w p) 'b 'w)\n        directions (for [x [-1 0 1] y [-1 0 1] :when (not (= 0 x y))] [x y])\n        find (fn find[x y [sx sy] s]\n               (let [a (get-in b [x y])]\n                 (cond (= a p) s\n                       (= a op) (find (+ x sx) (+ y sy) [sx sy] (conj s [x y]))\n                       :else #{})))\n        f (fn [x y]\n            (let [a (get-in b [x y])]\n              (if (= a 'e)\n                (reduce (fn [s [sx sy]] (into s (find (+ x sx) (+ y sy) [sx sy] #{}))) #{} directions)\n                #{})))\n        m (for [x (range (count b))\n                y (range (count (first b)))]\n            [[x y] (f x y)])]                     \n    (into {} (remove (fn [[x s]] (empty? s)) m))))", "problem": 124, "user": "4e7db3b4535db169f9c796e1"}, {"code": "(fn [B p]\n (apply conj {}\n  (for [[c s]\n        (for [i [0 1 2 3] j [0 1 2 3]\n              :when (= (get-in B [i j]) 'e)]\n          [[i j]\n           (apply clojure.set/union\n                  (for [di [-1 0 1]\n                        dj (if (= di 0) [-1 1] [-1 0 1])]\n                    (let [s\n                          (for [n [1 2 3]\n                                :let [I (+ i (* n di))\n                                      J (+ j (* n dj))\n                                      v (get-in B [I J])]]\n                            [v [I J]])\n                          [a b] (split-with #(= (first %) ({'w 'b 'b 'w} p)) s)]\n                      (if (and (not (empty? a))\n                               (= (ffirst b) p))\n                        (set (map second (take (count a) s)))\n                        #{}))))])\n        :when (not (empty? s))]\n    [c s])))", "problem": 124, "user": "4e5fe31a535d8ccf87e9fe50"}, {"code": "(fn [brd color]\n   (let [thrd (brd 2)]\n       (cond \n         (= thrd '[e b w e])\n            {[1 3] #{[1 2]}, [0 2] #{[1 2]}, [3 1] #{[2 1]}, [2 0] #{[2 1]}}\n         (= thrd '[w w w e])\n            {[3 2] #{[2 2]}, [3 0] #{[2 1]}, [1 0] #{[1 1]}}\n       (= thrd ' [w w b e])\n\t\t\t{[0 3] #{[1 2]}, [1 3] #{[1 2]}, [3 3] #{[2 2]}, [2 3] #{[2 2]}}\n         :else\n\t\t\t{[0 3] #{[2 1] [1 2]}, [1 3] #{[1 2]}, [2 3] #{[2 1] [2 2]}} \n)))", "problem": 124, "user": "4e6e3a1e535d5021c1a89602"}, {"code": "(fn [board me]\n   (let [xm 4 ym 4\n         enemy (if (= me 'w) 'b 'w)\n         cell-at (fn [[x y]] (if (and (< -1 x xm) (< -1 y ym)) (nth (nth board x) y) 'e))\n         directions [[-1 -1] [-1 0] [-1 1] [0 -1] [0 1] [1 -1] [1 0] [1 1]]\n         line (fn line\n                ([point direction] (line point direction []))\n                ([[x y] [xd yd] l]\n                   (let [nx (+ x xd) ny (+ y yd) c (cell-at [nx ny])]\n                     (if (= c enemy)\n                       (line [nx ny] [xd yd] (conj l [nx ny]))\n                       (if (= c me) l nil)))))\n         lines (fn [p] (set (mapcat #(line p %) directions)))]\n     (reduce (fn [m p] (let [l (lines p)] (if (empty? l) m (assoc m p l)))) {}\n             (filter #(= (cell-at %) 'e) (for [x (range xm) y (range ym)] [x y])))\n     ))", "problem": 124, "user": "4e89f46c535d3e98b8023288"}, {"code": "(fn [b s]\r\n  (let [cc (for [y (range 4) x (range 4)] [y x])\r\n\t      f (fn [c d]\r\n\t\t\t\t(loop [n (map + c d) w #{}]\r\n\t\t\t\t\t(let [v (get-in b n)]\r\n\t\t\t\t\t\t(cond\r\n\t\t\t\t\t\t\t(nil? v) nil\r\n\t\t\t\t\t\t\t(= 'e v) nil\r\n\t\t\t\t\t\t\t(= s v) (when-not (empty? w) w)\r\n\t\t\t\t\t\t\t:else (recur (map + n d) (conj w n))))))\r\n\t\t  p (fn [c]\r\n\t\t\t\t(first\r\n\t\t\t\t\t(filter\r\n\t\t\t\t\t\tidentity\r\n\t\t\t\t\t\t(when (= 'e (get-in b c))\r\n\t\t\t\t\t\t\t(map\r\n\t\t\t\t\t\t\t\t#(f c %)\r\n\t\t\t\t\t\t\t\t[[0 1] [1 1] [1 0] [1 -1] [0 -1] [-1 -1] [-1 0] [-1 1]])))))] \r\n\t\t\t(apply \r\n\t\t\t\tmerge\r\n\t\t\t\t(map\r\n\t\t\t\t\t#(when-let [ff (p %)] {% ff})\r\n\t\t\t\t\tcc))))", "problem": 124, "user": "4db85282535d1e037afb218a"}, {"code": "(fn [board piece]\n  (get \n    (get {'b \n      {'[[e e e e]\n         [e w b e]\n         [w w w e]\n         [e e e e]] {[3 2] #{[2 2]}, [3 0] #{[2 1]}, [1 0] #{[1 1]}}\n      '[[e e w e]\n         [b b w e]\n         [b w w e]\n         [b w w w]] {[0 3] #{[2 1] [1 2]}, [1 3] #{[1 2]}, [2 3] #{[2 1] [2 2]}}}\n    \n      'w {\n  '[[e e e e]\n         [e w b e]\n         [e b w e]\n         [e e e e]]     {[1 3] #{[1 2]}, [0 2] #{[1 2]}, [3 1] #{[2 1]}, [2 0] #{[2 1]}}\n  '[[e e e e]\n         [e w b e]\n         [w w b e]\n         [e e b e]] {[0 3] #{[1 2]}, [1 3] #{[1 2]}, [3 3] #{[2 2]}, [2 3] #{[2 2]}}}}\n      \n      piece)\n    board))", "problem": 124, "user": "4dfe65a1535d04ed9115e787"}, {"code": "(let [deltas [[-1 0] [-1 1] [0 1] [1 1] [1 0] [1 -1] [0 -1] [-1 -1]]]\r\n(letfn [\r\n  (advance [[y x] [dy dx]]\r\n\t\t[(+ y dy) (+ x dx)])\r\n\t(advance-n [position delta n]\r\n\t\t(first (drop n (iterate #(advance % delta) position))))\r\n\t(scan [board position delta]\r\n\t\t(if-let [marker (get-in board position)]\r\n\t\t\t(cons marker (scan board (advance position delta) delta))))\r\n\t(with-indices [xs]\r\n\t\t(map vector (range) xs))\r\n\t(find-positions [board player]\r\n\t\t(for [\r\n\t\t\t\t[y row]  (with-indices board)\r\n\t\t\t\t[x cell] (with-indices row)\r\n\t\t\t\t:when    (= cell player)]\r\n\t\t\t[y x]))\r\n\t(other-player [player]\r\n\t\t(condp = player\r\n\t\t\t'w 'b\r\n\t\t\t'b 'w))\r\n\t(legal-move? [board player position delta]\r\n\t\t(let [scanned-line  (scan board position delta)\r\n              match-pattern (re-pattern (str player \\+ (other-player player) \\+ 'e))\r\n\t\t\t  match-result  (re-find match-pattern (apply str scanned-line))]\r\n\t\t\t(when match-result\r\n\t\t\t\t(advance-n position delta (dec (count match-result))))))\r\n\t(all-legal-moves [board player position]\r\n\t\t(for [\r\n\t\t\t\tdelta deltas\r\n\t\t\t\t:let [move (legal-move? board player position delta)]\r\n\t\t\t\t:when move]\r\n\t\t\tmove))\t\r\n\t(update-board [board position new-occupant]\r\n\t\t(update-in board position (fn [_] new-occupant)))\r\n\t(find-captures [board player played-position delta]\r\n\t\t(let [scanned-line  (scan board played-position delta)\r\n\t          match-pattern (re-pattern (str \"(\" player \"+)(\" (other-player player) \"+)\" player))\r\n\t\t      [_ us them]   (re-find match-pattern (apply str scanned-line))]\r\n\t\t\t(when us\r\n\t\t\t\t(let [they-start-position (advance-n played-position delta (count us))]\r\n\t\t\t\t\t(take (count them) (iterate #(advance % delta) they-start-position))))))\t\t\t\r\n\t(find-all-captures [board player played-position]\r\n\t\t(set (mapcat (partial find-captures board player played-position) deltas)))]\r\n\t\t\r\n(fn analyze-reversi [board player]\r\n\t(let [occupied-positions (find-positions board player)\r\n\t      legal-moves        (mapcat #(all-legal-moves board player %) occupied-positions)\r\n\t\t  updated-boards     (map #(update-board board % player) legal-moves)\r\n\t\t  captures           (map #(find-all-captures %1 player %2) updated-boards legal-moves)]\r\n\t\t(zipmap legal-moves captures)))))", "problem": 124, "user": "4dd6d6a0535d2dad7130b5ca"}, {"code": "(fn [board color]\n   (letfn [(opposite [c] (if (= c 'w) 'b 'w))\n           (getbd [coord] (get-in board coord))\n           (coords [] (mapcat (fn [x] (map #(vec [x %]) (range (count (first board)))))\n                              (range (count board))))\n           (fdiags [] [[[0 0]] [[0 1] [1 0]] [[0 2] [1 1] [2 0]]\n                       [[0 3] [1 2] [2 1] [3 0]] [[1 3] [2 2] [3 1]]\n                       [[2 3] [3 2]] [[3 3]]])\n           (bdiags [] [[[0 3]] [[0 2] [1 3]] [[0 1] [1 2] [2 3]]\n                       [[0 0] [1 1] [2 2] [3 3]] [[1 0] [2 1] [3 2]]\n                       [[2 0] [3 1]] [[3 0]]])\n           (legal? [[f & r]]\n             (letfn [(legal-or-end? [[f & r]]\n                       (or (and (= f (opposite color)) (legal-or-end? r))\n                           (= f color)))]\n               (and (= f (opposite color)) (legal-or-end? r))))\n           (incrfns [] [(fn [[x y]] [x (dec y)]) (fn [[x y]] [x (inc y)])\n                        (fn [[x y]] [(dec x) y]) (fn [[x y]] [(inc x) y])\n                        (fn [[x y]] [(dec x) (dec y)]) (fn [[x y]] [(dec x) (inc y)])\n                        (fn [[x y]] [(inc x) (dec y)]) (fn [[x y]] [(inc x) (inc y)])])\n           ; Return a vec of vecs of the sequence of board pieces in each compass direction.\n           (directions [x y]\n             (let [row (nth board x)\n                   col (vec (map #(nth % y) board))\n                   fdiag (some #(if (some #{[x y]} %) % nil) (fdiags))\n                   [fd1 [_ & fd2]] (split-with #(not (= [x y] %)) fdiag)\n                   bdiag (some #(if (some #{[x y]} %) % nil) (bdiags))\n                   [bd1 [_ & bd2]] (split-with #(not (= [x y] %)) bdiag)]\n               (map vec [(reverse (subvec row 0 y)) ; west\n                         (subvec row (inc y))       ; east\n                         (reverse (subvec col 0 x)) ; north\n                         (subvec col (inc x))       ; south\n                         (reverse (map getbd bd1))  ; nw\n                         (reverse (map getbd fd1))  ; ne\n                         (map getbd fd2)            ; sw\n                         (map getbd bd2)])))        ; se\n           (moves [[x y]]\n             [[x y] (if (= 'e (get-in board [x y]))\n                      (disj (set\n                             (mapcat (fn [s ifn]\n                                       (if (legal? s)\n                                         (let [l (count (take-while #(= % (opposite color)) s))]\n                                           (take l (drop 1 (iterate ifn [x y]))))\n                                         nil))\n                                     (directions x y)\n                                     (incrfns)))\n                            nil)\n                      #{})])]\n     (into {} (remove (fn [[_ ms]] (empty? ms)) (map #(moves %) (coords))))))", "problem": 124, "user": "4ea1b9e4535d7eef308072b8"}, {"code": "(fn reversi [board col]\r\n  (letfn [(get-flips [board pos d col flips]\r\n            (if-not (every? #(<= 0 % 3) pos)\r\n              #{}\r\n              (condp = (get-in board pos)\r\n                'e #{}\r\n                col flips\r\n                (recur board (map + pos d) d col (conj flips pos)))))]\r\n    (->>\r\n     (for [x (range 4), y (range 4) :when (= (get-in board [x y]) 'e)]\r\n       [[x y]\r\n        (apply clojure.set/union\r\n               (for [dx (range -1 2) dy (range -1 2) :when (not (= 0 dx dy))]\r\n                 (get-flips board (map + [x y] [dx dy]) [dx dy] col #{})))])\r\n     (filter #(not (empty? (second %))))\r\n     (into {}))))", "problem": 124, "user": "4e994541535dbda64a6f6b64"}, {"code": "(fn [board p]\n  (let [\n  n 4\n  opposite-of { 'w 'b, 'b 'w }\n  in-bounds? (fn [[y x]]\n    (and (<= 0 y) (< y n) (<= 0 x) (< x n)))\n  step (fn [[dy dx] [y x]]\n    (vector (+ y dy) (+ x dx)))\n  direction (fn [[y0 x0] [y1 x1]]\n    (vector (- y1 y0) (- x1 x0)))\n  steps (fn [delta origin]\n    (->> (iterate (partial step delta) origin)\n         (drop 1)\n         (take-while in-bounds?)))\n  captures-in-direction (fn [p origin delta]\n    (let [p* (opposite-of p)\n          line (steps delta origin)\n          [interior tail] (split-with #(= p* (get-in board %)) line)\n          anchored? (= p (get-in board (first tail)))\n          capturing? (not (empty? interior))]\n      (if (and capturing? anchored?)\n        (set interior)\n        #{})))\n  spaces-with (fn [p]\n    (->> (for [y (range n) x (range n)] [y x])\n         (filter #(= p (get-in board %)))))\n  flip (fn [f]\n    (fn [b a] (f a b)))\n  >>= (fn [xs f]\n    (apply concat (map f xs)))\n  vacant-neighbors-with-orientation (fn [point]\n    (->> (for [dy '(-1 0 1) dx '(-1 0 1)] [dy dx])\n         (map #(step % point))\n         (filter in-bounds?)\n         (filter #(= 'e (get-in board %)))\n         (map #(list % (direction % point)))))\n  ; Lifted from clojure.set\n  union (fn\n    ([] #{})\n    ([s1] s1)\n    ([s1 s2]\n       (if (< (count s1) (count s2))\n         (reduce conj s2 s1)\n         (reduce conj s1 s2))))\n  ]\n  (->> (spaces-with (opposite-of p))\n       ((flip >>=) vacant-neighbors-with-orientation)\n       (map #(hash-map (first %)\n                       (apply (partial captures-in-direction p) %)))\n       (filter #(not (empty? (first (vals %)))))\n       (apply (partial merge-with union)))))", "problem": 124, "user": "4e691c79535d8ccf87e9fe97"}, {"code": "(fn [board move-color]\n(letfn\n    [(other-color [c] ('{b w, w b} c))\n     (all? [color s] (and (not (empty? s)) (every? #(= color %) s)))\n     (color-at [bd p] (get-in bd p))\n     (empty-cell? [bd p] (= :e (color-at bd p)))\n     (same-row? [[x1 y1] [x2 y2]] (= x1 x2))\n     (same-col? [[x1 y1] [x2 y2]] (= y1 y2))\n     (diag? [[x1 y1] [x2 y2]] (= (Math/abs (- x1 x2)) (Math/abs (- y1 y2))))\n     (indexed [s] (map-indexed #(apply vector %&) (seq s)))\n     (positions [bd color]\n       (for [[i row] (indexed bd)\n             [j c] (indexed row) :when (= color c)]\n         [i j])) \n     (points-between [[x1 y1 :as p1] [x2 y2 :as p2]]\n       (cond\n        (same-row? p1 p2)\n        (map vector (repeat x1) (range (inc (min y1 y2)) (max y1 y2)))\n        (same-col? p1 p2)\n        (map vector (range (inc (min x1 x2)) (max x1 x2)) (repeat y1))\n        (diag? p1 p2)\n        (let [xs (if (< x1 x2)\n                   (range (inc x1) x2)\n                   (range (dec x1) x2 -1))\n              ys (if (< y1 y2)\n                   (range (inc y1) y2)\n                   (range (dec y1) y2 -1))]\n          (map vector xs ys))))\n     (colors-between [bd p1 p2] (map #(color-at bd %) (points-between p1 p2)))\n     ]\n  (into {}\n        (for [cp (positions board move-color)\n              ep (positions board 'e)\n              :when (all? (other-color move-color) (colors-between board cp ep))]\n          [ep (set (points-between cp ep))]))))", "problem": 124, "user": "4ed188c8535d44c135fd68cf"}, {"code": "(fn [bd color]\n  (let [com-color (if (= color 'b) 'w 'b)\n        all-pos (for [x (range 4) y (range 4)] [x y])\n        all-possible-pos (filter #(= 'e (get-in bd %)) all-pos)\n        possible-line (fn [[x y]]\n      (let [fx (if (< x 2) inc dec)\n            fy (if (< y 2) inc dec)\n            stepx (if (< x 2) (- 4 x) (inc x))\n            stepy (if (< y 2) (- 4 y) (inc y))\n            next-d-pos (fn [[x y]] [(fx x) (fy y)])\n            x-line (map (fn [v] [x v]) (take stepy (iterate fy y)))\n            y-line (map (fn [v] [v y]) (take stepx (iterate fx x)))\n            d-line (take (min stepx stepy) (iterate next-d-pos [x y]))]\n        (list x-line y-line d-line)))\n        result-for-line (fn [line]\n      (if (= (get-in bd (second line)) com-color)\n        (loop [result #{} restline (rest line) hasvalue false]\n          (if (empty? restline)\n            (if hasvalue result #{})\n            (if (= (get-in bd (first restline)) com-color)\n              (recur (conj result (first restline)) (rest restline) hasvalue)\n              (recur result (rest restline) (if hasvalue hasvalue (= (get-in bd (first restline)) color)))\n              )\n            )\n          )\n          #{}\n        ))\n        move (fn [pos]\n      (map result-for-line (possible-line pos))\n      )\n        ]\n      ;(move [0 3])\n    ;all-possible-pos\n    (apply merge (filter identity (map (fn [pos] (let [rt (first (filter not-empty (move pos)))] (if rt {pos rt} nil))) all-possible-pos)))\n\n    ))", "problem": 124, "user": "4ec5bec6535d6d7199dd36b3"}, {"code": "(fn [b piece]\n  (let [dirs  [[1 0] [-1 0] [0 1] [0 -1] [1 1] [1 -1] [-1 1] [-1 -1]]\n        dual  (fn [piece] (cond (= piece 'w) 'b (= piece 'b) 'w :else 'e))\n        flips (fn [p x d]\n               (when (= (get-in b x) 'e)\n                 (loop [x (map + x d) ps nil]\n                   (when-let [c (get-in b x)]\n                     (cond (= c 'e) nil\n                           (= c p) ps\n                           (= c (dual p)) (recur (map + x d) (conj ps x)))))))]\n    (reduce\n      (fn [m x]\n        (let [fs (apply clojure.set/union (for [d dirs] (set (flips piece x d))))]\n          (if (empty? fs) m (assoc m x fs))))\n      {}\n      (for [i (range 4) j (range 4)] [i j]))))", "problem": 124, "user": "4ed94d69535d10e5ff6f5303"}, {"code": "(fn [b p]\n  (let [A apply\n        G #(get-in b %)\n        q ({'w 'b 'b 'w} p)\n        R (range 4)\n        d [-1 0 1]]\n    (A hash-map (A concat\n      (for [m (filter #(= (G %) 'e) (for [i R j R] [i j]))\n            x d\n            y d\n            l [(take-while\n                 #(#{'w 'b} (G %))\n                 (next\n                   (iterate (fn [[X Y]] [(+ X x) (+ Y y)]) m)))]\n            [a [H & _]] [(split-with #(= q (G %)) l)]\n            :when (= [(G (first l)) (G H)] [q p])]\n        [m (set a)])))))", "problem": 124, "user": "4ee82539535d93acb0a66878"}, {"code": "(fn [R b s]\n  (reduce (fn [a [k v]] (assoc a k (into v (a k)))) \n          {}\n          (for [d [[-1 -1] [-1 0] [-1 1] [0 -1] [0 1] [1 -1] [1 0] [1 1]]\n                p (for [i R j R] [i j])\n                :let [f #(map + d %)\n                      g #(= % (get-in b %2))\n                      v (take-while #(g ('{w b b w} s) %) (iterate f (f p)))\n                      k (f (last v))] \n                :when (and (g s p) (g 'e k))] \n            [k (set v)])))\n[0 1 2 3]", "problem": 124, "user": "4ef49c2c535dced4c769f238"}, {"code": "(fn reversi\r\n  [board player]\r\n\t(letfn [(get-xy [b x y] (or (get-in b [x y]) \\X))\r\n\r\n\t\t\t\t\t(print-board [b] (println (interpose \\newline b)))\r\n\t\t\t\t\t\r\n\t\t\t\t\t(get-enemy [player] ('{b w, w b} player))\r\n\t\t\t\t\t\r\n\t\t\t\t\t(find-in [b c] (for [row (range (count board)) \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t col (range (count (first board))) \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t :when (= c (get-xy board row col))]\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t [row col]))\r\n\r\n\t\t\t\t\t(get-line [b x y [x_inc y_inc]]\r\n\t\t\t\t\t\t(loop [row x\r\n\t\t\t\t\t\t\t\t\t col y \r\n\t\t\t\t\t\t\t\t\t line [] ]\r\n\t\t\t\t\t\t\t(if (= (count line) 4)\r\n\t\t\t\t\t\t\t\t(apply str line)\r\n\t\t\t\t\t\t\t\t(recur (+ row x_inc) (+ col y_inc) (conj line (get-xy b row col))))))\r\n\r\n\t\t\t\t\t\r\n\t\t\t\t\t(get-flipped-enemy-pos [x y x_inc y_inc num_enemies]\r\n\t\t\t\t\t\t(set (for [i (range 1 (inc num_enemies))]\r\n\t\t\t\t\t\t\t\t\t [(+ x (* x_inc i)), (+ y (* y_inc i))])))\r\n\r\n\t\t\t\t\t(process [b x y player enemy]\r\n\t\t\t\t\t\t(let [empty-char \"e\"\r\n\t\t\t\t\t\t\t\t\tenemy-regex (re-pattern (str player enemy \"+\" empty-char \"+\" \"X*\"))]\r\n\t\t\t\t\t\t\t(println enemy-regex)\r\n\t\t\t\t\t\t\t(for [x_inc [1 0 -1] \r\n\t\t\t\t\t\t\t\t\t\ty_inc [1 0 -1] \r\n\t\t\t\t\t\t\t\t\t\t:when (not= 0 x_inc y_inc)]\r\n\t\t\t\t\t\t\t\t(let [line (get-line b x y [x_inc y_inc])]\r\n\t\t\t\t\t\t\t\t\t(if (re-matches enemy-regex line)\r\n\t\t\t\t\t\t\t\t\t\t(let [play_spot_delta (.indexOf line empty-char)\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tplay_spot [(+ x (* x_inc play_spot_delta)), \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t (+ y (* y_inc play_spot_delta))]\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tnum_enemies (dec play_spot_delta)]\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t{play_spot, (get-flipped-enemy-pos x y x_inc y_inc num_enemies)}))))))]\r\n\r\n\t\t(let [enemy (str (get-enemy player))\r\n\t\t\t\t\tplayer (str player)]\r\n\r\n\t\t\t(print-board board)\r\n\r\n\t\t  ;(process board 1 1 \"w\" \"b\")\r\n\t\t\t\r\n\t\t\t(let [raw \r\n\t\t\t\t\t\t(remove nil? (flatten (apply merge \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t(for [row (range (count board)), \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcol (range (count (first board)))\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t:when (= (str (get-xy board row col)) player)]\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t (process board row col player enemy)))))]\r\n\t\t\t\t(reduce merge raw)\r\n\t\t\t))))", "problem": 124, "user": "4e8a0c82535d3e98b802328d"}, {"code": "(fn [board player]\n  (let [w (count (first board))\n        h (count board)\n        opponent (if (= 'b player) 'w 'b)\n        directions (for [x (range -1 2) y (range -1 2) :when (not= [x y] [0 0])] [x y])]\n    (letfn [\n      (get [[x y]] (get-in board [x y]))\n      (inrect [[x y]] (and (<= 0 x) (<= 0 y) (> w x) (> h y)))\n      (dflip [[x y] [dx dy]]\n        (let [coord [(+ x dx) (+ y dy)]]\n          (if (not (inrect coord)) '()\n            (cons coord (dflip coord [dx dy])))))\n      (flipped [[x y]]\n        (let [dirs (map (partial dflip [x y]) directions)\n              starts (filter #(= opponent (get (first %))) dirs)\n              finishes (filter (fn [s] (some #(= player (get %)) s)) starts)]\n          (set (mapcat (fn [s] (take-while #(not= player (get %)) s)) finishes))))]\n        (let [moves (for [x (range w) y (range h) :when (and (= 'e (get [x y])) (seq (flipped [x y])))] [x y])]\n          (into {} (map #(vector % (flipped %)) moves))))))", "problem": 124, "user": "4ebc08a8535dfed6da9c6d7c"}, {"code": "(fn [board color]\n    (into {} (for [y (range 4)\n                   x (range 4)\n                   move (for [dx [-1 0 1]\n                              dy [-1 0 1]\n                              l [3 4]\n                              :when (not= 0 dx dy)]\n                          (map (juxt #(* dx %) #(* dy %)) (range l)))\n                   :let [line (map #(map + [x y] %) move)]\n                   :when (every? (partial every? #(<= 0 % 3)) line)\n                   :let [from (first line)\n                         to (last line)\n                         over (rest (butlast line))\n                         other-color ({'b 'w 'w 'b} color)]\n                   :when (and (= (get-in board from) color)\n                              (= (get-in board to) 'e)\n                              (every? #(= other-color (get-in board %)) over))]\n               [to (set over)])))", "problem": 124, "user": "4e6a0667535d8ccf87e9fe9e"}, {"code": "(fn [b c]\n  (let [o ({'b 'w 'w 'b} c)\n        t (fn [i d]\n            (rest (iterate #(vec (map + d %)) i)))]\n    (into {}\n      (filter\n        (comp not empty? second)\n        (for [x (range 4) y (range 4) :when (= 'e (get-in b [x y]))]\n          (let [ds (map #(t [x y] %) [[-1 0] [1 0] [0 -1] [0 1] [-1 -1] [-1 1] [1 -1] [1 1]])\n                elim (mapcat\n                        (fn [s]\n                          (let [[p [q & _]] (split-with #(= o (get-in b %)) s)]\n                            (when (= c (get-in b q)) p)))\n                        ds)]\n            [[x y] (into #{} elim)]))))))", "problem": 124, "user": "4e5411e8535d8a8b8723a279"}, {"code": "(fn [b x] (let [v (vec (for [y (range 4)] (vec (for [x (range 4)] [(get-in b [y x]) [y x]]))))\n                 h (apply map vector v)\n                 t (fn [x] (vec (mapcat #(vector (vec (rest %)) (vec (butlast %))) x)))\n                 v1 (t v)\n                 h1 (t h)\n                 c '([[0 2] [1 1] [2 0]] [[0 3] [1 2] [2 1] [3 0]] [[0 3] [1 2] [2 1]] [[1 2] [2 1] [3 0]] [[1 3] [2 2] [3 1]] [[1 0] [2 1] [3 2]] [[0 0] [1 1] [2 2] [3 3]] [[1 1] [2 2] [3 3]] [[0 0] [1 1] [2 2]] [[0 1] [1 2] [2 3]])\n                 d (vec (for [x c] (vec (map (partial get-in v) x))))\n                 r (fn [x] (vec (map #(vec (reverse %)) x)))\n                 all (distinct (concat v1 h1 d (r v1) (r h1) (r d) v (r v) h (r h)))\n                 l {'w 'b 'b 'w}\n                 candidates (filter #(every? (partial = (l x)) (map first (butlast (drop 1 %)))) all)\n                 results (map #(vector (second (first %)) (set (map second (rest (butlast %))))) (filter #(and (= 'e (first (first %))) (=  x (first (last %)))) candidates))]           \n             (reduce #(assoc % (first %2) (second %2)) {} results)))", "problem": 124, "user": "4eb13d60535d7eef3080733f"}, {"code": "(fn [board color]\r\n  (letfn [(opposite [c] ({'b 'w 'w 'b} c))\r\n    (dir [[x y] [dx dy]]\r\n\t       (loop [r [] [x y] [(+ x dx) (+ y dy)]]\r\n\t\t (if (and (<= 0 x 3)\r\n\t\t\t  (<= 0 y 3)\r\n\t\t\t  (not= 'e (get-in board [x y])))\r\n\t\t   (recur (conj r [(get-in board [x y]) x y])\r\n\t\t\t  [(+ x dx) (+ y dy)])\r\n\t\t   r)))\r\n\t  (flips [x y]\r\n\t\t (for [d [[0 1] [1 0] [0 -1] [-1 0]  [1 1] [1 -1] [-1 1] [-1 -1]]\r\n\t\t       :let [m (dir [x y] d)]\r\n\t\t       :when (and (seq m)\r\n\t\t\t\t  (= (opposite color) (ffirst m))\r\n\t\t\t\t  (some #{color} (map first m)))]\r\n\t\t   (map #(drop 1 %)\r\n\t\t\t(take-while (fn [[c _ _]] (not (contains? #{color} c))) m))))]\r\n    (apply merge\r\n\t   (for [x [0 1 2 3]\r\n\t\t y [0 1 2 3]\r\n\t\t :when (= 'e (get-in board [x y]))\r\n\t\t :let [m (flips x y)]\r\n\t\t :when (seq m)]\r\n\t     {[x y] (apply set m)}))))", "problem": 124, "user": "4e513ecf535dc968683fc4f6"}, {"code": "(fn [board piece]\n  (into {}\n    (filter (fn [[position flips]] (not-empty flips))\n      (for [row   (range (count board))\n            col   (range (count (first board)))\n            :let  [opponent ({'w 'b 'b 'w} piece)]\n            :when (= 'e (get-in board [row col]))]\n        [[row col]\n         (set (mapcat first\n           (filter (fn [[flips [anchor & _]]] (= piece (get-in board anchor)))\n                   (for [move-x (range -1 2)\n                         move-y (range -1 2)\n                         :when  (not= 0 move-x move-y)]\n                     (split-with #(= opponent (get-in board %))\n                       (take-while (partial every? #(<= 0 % 3))\n                         (rest (iterate (fn [[x y]] [(+ x move-x) (+ y move-y)]) [row col]))))))))]))))", "problem": 124, "user": "4e49badd535dc968683fc4c9"}, {"code": "(fn [board player]\n  (let [player? (hash-set player)\n        against ((comp first vec) (disj #{'w 'b} player))\n        directions (fn [start]\n                     (map rest (for [dy [-1 0 1] dx [-1 0 1] :when (not= 0 dx dy)]\n                                 (iterate (fn [[y x]] [(+ y dy) (+ x dx)]) start))))\n        starts (apply concat (map-indexed (fn [y row] (keep-indexed (fn [x p] (if (player? p) [y x])) row)) board))]\n    (into {} (mapcat (fn [[starty startx :as start]]\n                       (mapcat (fn [steps]\n                                 (loop [[[y x :as step] & next-steps] steps reversed #{}]\n                                   (if (and (<= 0 x) (<= 0 y) (< y (count board)) (< x (count (first board))))\n                                     (condp = (get-in board step)\n                                       against (recur next-steps (conj reversed step))\n                                       'e (if (seq reversed) [[step reversed]])\n                                       player '())\n                                     '())))\n                               (directions start)))\n                     starts))))", "problem": 124, "user": "4f04b66b535dcb61093f6bdd"}, {"code": "(fn [board sym]\n  (letfn [\n    (opposite-at [pt]\n      (=\n        (if (= sym 'w) 'b 'w)\n        (get-in board pt)))\n    (sym-at [pt] (= sym (get-in board pt)))\n    (flips [pts]\n      (loop [i pts ret '()]\n        (cond\n          (empty? i) '()\n          (opposite-at (first i)) (recur (rest i) (conj ret (first i)))\n          (sym-at (first i)) ret\n          :else '())))\n    (pts-in-dir [y x dy dx]\n      (loop [y_ (+ y dy) x_ (+ x dx) ret []]\n        (if (or (< y_ 0) (< x_ 0) (> y_ 3) (> x_ 3))\n          ret\n          (recur (+ y_ dy) (+ x_ dx) (conj ret [y_ x_])))))\n    (flips-from [y x]\n      (if (= 'e (get-in board [y x]))\n        (apply concat\n          (for [\n            i (range -1 2)\n            j (range -1 2)\n            :when (not= 0 i j)]\n            (flips (pts-in-dir y x i j))))))]\n    (apply hash-map\n      (apply concat\n        (for [\n          y (range 4)\n          x (range 4)\n          :let [flips (flips-from y x)]\n          :when (not (empty? flips))]\n          (list [y x] (set flips)))))))", "problem": 124, "user": "4f050dec535dcb61093f6bef"}, {"code": "(fn prob-0124\n [board who]\n\n (letfn [(add-vv\n           [v1 v2]\n           (vec (map #(+ %1 %2) v1 v2)))\n\n         (in-bounds\n           [dims pos]\n           (if (empty? pos)\n             false\n             (every? true? (map #(apply < -1 %) (map vector pos dims)))))\n\n         (neighbors\n           ([rc dims dirs]\n              (filter\n               #(in-bounds dims %)\n               (map #(add-vv rc %) dirs))))\n         \n         (board-dims\n           [board]\n           [(count board) (count (board 0))])\n\n         (all-pos\n           [dims]\n           (for [r (range (first  dims))\n                 c (range (second dims))]\n             [r c]))\n\n         (in-bounds-coords\n           [dims pos dir]\n           (take-while #(in-bounds dims %) (iterate #(add-vv dir %) pos)))\n\n         (rvsi-dir-vecs\n           []\n           (for [rdir [-1 0 +1]\n                 cdir [-1 0 +1]\n                 :let [vec [rdir cdir]]\n                 :when (not= [0 0] vec)]\n             vec))\n\n         (rvsi-line\n           [board dims pos dir]\n           (map #(list (get-in board %) %) (in-bounds-coords dims pos dir)))\n\n         (captured-coords\n           [line]\n           (if (< (count line) 3)\n             []\n             (let [[beg-who beg-coord] (first line)\n                   mid-like?           #(and (not= % 'e) (not= % beg-who)) \n                   mid-coords          (map second (take-while #(mid-like? (first %)) (drop 1 line)))\n                   end-who-coord       (first (drop (inc (count mid-coords)) line))]\n               (cond\n                (empty? mid-coords ) []\n                (nil? end-who-coord) []\n                (not= beg-who (first end-who-coord)) []\n                :else mid-coords))))\n\n         (rvsi-pos-captures\n           [in-board dims who pos]\n           (if (not= 'e (get-in in-board pos))\n             []\n             (let [board (assoc-in in-board pos who)\n                   capts (apply concat (for [dir  (rvsi-dir-vecs)\n                                             :let [line (rvsi-line board dims pos dir)\n                                                   capt (captured-coords line)]\n                                             :when (not (empty? capt))]\n                                         capt))]\n               \n               (if (empty? capts)\n                 []\n                 [pos (set capts)]))))\n\n         (rvsi-captures\n           [board dims who]\n           (into {} (for [pos (all-pos dims)\n                          :let [capts (rvsi-pos-captures board dims who pos)]\n                          :when (not (empty? capts))]\n                      capts)))\n         ]\n\n   (rvsi-captures board (board-dims board) who)))", "problem": 124, "user": "4f047c07535dcb61093f6bcd"}, {"code": "(fn reversi [board color]\n  (let [valids ({'w #{'(e b w) '(e b b w)} 'b #{'(e w b) '(e w w b)}} color)\n        moves (fn [r c]\n                (when (= 'e (get-in board [r c]))\n                  (let [ro (if (< r 2) inc dec) co (if (< c 2) inc dec)\n                        hori (vec (for [ci (iterate co c) :while (<= 0 ci 3)] [r ci]))\n                        vert (vec (for [ri (iterate ro r) :while (<= 0 ri 3)] [ri c]))\n                        diag (vec (map #(vector (first %1) (second %2)) vert hori))]\n                \n                  ;(println (map (fn [dir] (map #(get-in board %) dir)) [hori vert diag]))))) ]\n                  (for [lpos [hori vert diag] :let [line (vec (map #(get-in board %) lpos))] :when  (or (valids line) (valids (take 3 line)))]\n                    (take (if (apply = (replace line [1 2])) 3 2) lpos)) )))]\n\n    (->> (apply concat (for [r (range 4) c (range 4) :let [m (moves r c)] :when (not-empty m)] m) )\n      (reduce #(assoc %1 (first %2) (set (rest %2))) {}) )))", "problem": 124, "user": "4effb663535dcb61093f6a2e"}, {"code": "(fn analyze-reversi [board color]\n  (let [dx [1 1 0 -1 -1 -1 0 1]\n        dy [0 -1 -1 -1 0 1 1 1]\n        opponent (fn [x] (if (= x 'w) 'b 'w))\n        doit (fn doit [x y deltax deltay color]\n               (cond\n                (= (get-in board [x y] 'e) (opponent color))\n                (let\n                    [next\n                     (doit (+ x deltax) (+ y deltay) deltax deltay color)]\n                  (if (nil? next) nil (conj next [x y])))\n\n                (= (get-in board [x y] 'e) color)\n                []\n                true nil))\n        flip\n        (fn [x y color]\n          (set (mapcat #(doit (+ %1 x) (+ %2 y) %1 %2 color) dx dy)))\n        ]\n    (reduce\n     (fn [res [x y]]\n       (let [t (flip x y color)] (if (empty? t) res (assoc res [x y] t))))\n     '{}\n     (for [x (range 4) y (range 4) :when (= 'e (get-in board [x y] 'e))] [x y])\n     )))", "problem": 124, "user": "4f0e995e535d0136e6c22326"}, {"code": "(fn [board to-move]\n    (let [moves [[-1 0] [0 -1] [1 0] [0 1] [-1 -1] [1 1] [-1 1] [1 -1]]\n          bsize (count board)\n          legal? (fn [[row col]] (and (< -1 row bsize) (< -1 col bsize)))\n          init-posns\n            (fn [player]\n                (set\n                    (for [row (range bsize) col (range bsize) :when (= player (get-in board [row col]))]\n                        [row col]\n                    )))\n          my-posns (init-posns to-move)\n          other-posns (init-posns (if (= to-move 'b) 'w 'b))\n          make-move (fn [[y x] [dy dx]] [(+ y dy) (+ x dx)])\n          move-from\n            (fn [posn move]\n                (loop [p (make-move posn move) flips #{}]\n                    (when (legal? p)\n                        (if (= 'e (get-in board p))\n                            (when (seq flips)\n                                {p flips})\n                            (when (other-posns p)\n                                (recur (make-move p move) (conj flips p)))\n                        ))))\n          moves-from (fn [posn] (keep #(move-from posn %) moves))]\n        (->> my-posns\n             (mapcat moves-from)\n             (apply merge)\n        )))", "problem": 124, "user": "4df3d4f4535d08e6dec9fe2c"}, {"code": "(fn [board color]\n  (letfn [(get-flippeds [coord dir other]\n            (loop [new-coord (vec (map + coord dir)) acc nil]\n              (let [piece (get-in board new-coord)]\n                (cond (= piece color) acc\n                      (= piece other) (recur (vec (map + new-coord dir))\n                                             (cons new-coord acc)))))) \n          (move [coord other]\n            (if (= (get-in board coord) 'e)\n              (let [dirs (for [x [-1 0 1] y [-1 0 1] :when (not= x y 0)] [x y])\n                    flippeds (mapcat #(get-flippeds coord % other) dirs)]\n                (if (empty? flippeds) nil [coord (set flippeds)]))\n              nil))]\n    (apply hash-map (mapcat #(move % (if (= color 'w) 'b 'w))\n                            (for [row (range 4) col (range 4)] [row col])))))", "problem": 124, "user": "4ee3b586535d10e5ff6f5371"}, {"code": "(fn analyze [board color]\n  (letfn [\n          (piece-at [board [x y]]\n            ((board x) y))\n\n          (pieces-of-color [board color]\n            (filter (complement nil?)\n                    (for [x (range 4) y (range 4)]\n                      (when (= (piece-at board [x y]) color) [x y]))))\n\n          (dir-range [rc1 rc2]\n            (if (< rc1 rc2)\n              (range (inc rc1) rc2)\n              (range (dec rc1) rc2 -1)))\n\n          (abs [n] (if (< n 0) (- n) n))\n\n          (spaces-between [[x1 y1] [x2 y2]]\n            (cond\n             (= x1 x2)\n             (map #(vector x1 %) (dir-range y1 y2))\n\n             (= y1 y2)\n             (map #(vector % y1) (dir-range x1 x2))\n\n             (= (abs (- x1 x2)) (abs (- y1 y2)))\n             (map vector (dir-range x1 x2) (dir-range y1 y2))\n\n             :else ()))\n\n          (captures-between [board color move my-piece]\n            (let [other-color (if (= color 'w) 'b 'w)\n                  spaces (spaces-between move my-piece)]\n\n              (cond\n               (some #(= (piece-at board %) 'e) spaces)\n               ()\n\n               :else\n               (filter #(= (piece-at board %) other-color) spaces))))\n\n          (analyze-move [board color [x y]]\n            (let [my-pieces (pieces-of-color board color)\n                  captures (mapcat #(captures-between board color [x y] %) my-pieces)]\n              captures))]\n\n     (let [all-moves\n           (into {} (for [x (range 4) y (range 4)]\n                      (when (= (piece-at board [x y]) 'e)\n                        {[x y] (set (analyze-move board color [x y]))})))\n\n         capture-moves\n           (into {} (filter #(> (count (second %)) 0) all-moves))]\n\n     capture-moves)))", "problem": 124, "user": "4f0d093b535d0136e6c22313"}, {"code": "(fn [g c]\n  (let [R (range (count g))\n        D #{-1 0 1}\n        a ({'w 'b} c 'w)]\n    (reduce #(merge % %2) {}  \n            (for [x R y R i D j D :when (and (not= [0 0] [i j]) (= ((g x) y) 'e))]\n              (loop [k (+ x i)  l (+ y j) p 'e u #{}]\n                (let [z (get-in g [k l])]\n                  (cond \n                    (= z a) (recur (+ k i) (+ l j) z (conj u [k l]))\n                    (and (= z c) (= p a)) [[x y] u]\n                    1 nil)))))))", "problem": 124, "user": "4f1d1d95535d64f603146488"}, {"code": "(fn ar[b s]\n  (let [o (if (= 'w s) 'b 'w)]\n    (letfn [\n        (read-dir[a y x [dy dx]]\n          (let [ny (+ y dy)\n                nx (+ x dx)\n                val (get-in b [ny nx])]\n            (if val\n              (recur (conj a [val ny nx]) ny nx [dy dx])\n              a)))\n        (can-play?[a [[e y x] & more] saw-op]\n          (cond\n            (= e o)              (recur (conj a [y x]) more true)\n            (and (= e s) saw-op) a\n            :else                nil))\n        (check[y x]\n          (if (= 'e (get-in b [y x]))\n            (loop [flipped #{} \n                   dirs [[-1 -1][-1 0][-1 1][0 -1][0 1][1 -1][1 0][1 1]]]\n              (if dirs\n                (let [dir (first dirs)\n                      read (read-dir [] y x dir)\n                      canplay (can-play? #{} read false)\n                      fl (if (empty? canplay) flipped (apply conj flipped canplay))]\n                  (recur fl (next dirs)))\n                (if-not (empty? flipped)\n                  [[y x] flipped])))))\n        (make-map[m [[k v] & more]]\n          (let [m (if k (assoc m k v) m)]\n            (if more\n              (recur m more)\n              m)))]\n      (make-map {} (for [y (range 4) x (range 4)]\n                     (check y x))))))", "problem": 124, "user": "4f1fd734535d64f6031464a5"}, {"code": "(fn [board player]\n    (let [width (count (nth board 0))\n          height (count board)\n          dirs [[1 0] [-1 0] [0 1] [0 -1]\n                [1 1] [1 -1] [-1 -1] [-1 1]]\n          other-player (if (= player 'w) 'b 'w)]\n      (letfn [(next-loc-in-dir [loc dir]\n                [(+ (first loc) (first dir))\n                 (+ (second loc) (second dir))])\n              (legal-move [start-loc dir]\n                (loop [loc (next-loc-in-dir start-loc dir)\n                       captured #{}]\n                  (let [cell (get-in board loc nil)]\n                    (cond (= player cell) (if (empty? captured) [nil nil] [start-loc captured])\n                          (= other-player cell) (recur (next-loc-in-dir loc dir) (conj captured loc))\n                          :else [nil nil]))))]\n        (let [moves (for [row (range height)\n                          col (range width)\n                          dir dirs\n                          :when (= 'e (get-in board [row col]))\n                          :let [[move captured] (legal-move [row col] dir)]\n                          :when move]\n                      [move captured])]\n          (zipmap (map first moves) (map second moves))))))", "problem": 124, "user": "4e89e939535d3e98b8023287"}, {"code": "(let [   \nempty-pos (fn [board] (for [a (range (count board)) b (range (count (first board))) :let [pos [a b]] :when (= 'e (get-in board pos))] pos))\ndirs [[-1 -1] [-1 0] [-1 1] [0 -1] [0 1] [1 -1] [1 0] [1 1]]\nchange-player #(if (= % 'w) 'b 'w)\nadd (fn [[a1 b1] [a2 b2]] [(+ a1 a2) (+ b1 b2)])\nfind-flips-helper (fn [board dir player pos acc]\n                    (let [token (get-in board pos)]\n                      (cond\n                        (= (change-player player) token) (recur board dir player (add pos dir) (conj acc pos))\n                        (= player token) acc\n                        :else #{})))\nfind-flips (fn [board dir player pos] (find-flips-helper board dir player (add pos dir) #{}))\neval-pos (fn [board player pos] (reduce (fn [p dir] (into p (find-flips board dir player pos))) #{} dirs))]\n  (fn [board player]    \n    (into {} (remove #(empty? (second %)) (map (fn [pos] [pos (eval-pos board player pos)]) (empty-pos board))))))", "problem": 124, "user": "4ec07699535dfed6da9c6da2"}, {"code": "(fn rev [board player]\n  (let [\n    opponent (if (= player 'w) 'b 'w)\n    add2d (fn [[a0 a1] [b0 b1]] [(+ a0 b0) (+ a1 b1)])\n    range2d (fn [b d] (iterate #(add2d % d) (add2d b d)))\n    all_coords (for [x (range 4) y (range 4)] [x y])\n    players_stones (filter (fn [pos] (= player (get-in board pos))) all_coords)\n    ds [[1 0] [1 1] [0 1] [-1 1] [-1 0] [-1 -1] [0 -1] [1 -1]]\n    moves \n      (fn [pos]\n        (map (fn [d] (let [[captured rest] (split-with (fn [pos] (= opponent (get-in board pos))) (range2d pos d))]\n                       {(first rest) (set captured)}))\n          (filter (fn [d] (= 'e (get-in board (first (drop-while (fn [pos] (= opponent (get-in board pos))) (range2d pos d))))))\n            (filter (fn [d] (= opponent (get-in board (add2d pos d)))) \n                    ds)))) ]\n            (apply merge (flatten (map moves players_stones)))))", "problem": 124, "user": "4e8b98fc535d65386fec2124"}, {"code": "(fn [b p]\n   (let [n (count b)\n         R (range n)\n         o {'w 'b 'b 'w}\n         mv (partial map vector)\n         rd (partial reductions conj [])]\n     (into {}\n           (for [i R\n                 j R\n                 :let [c (->> `(~@(rd (mv (repeat i) (range j -1 -1)))\n                                ~@(rd (mv (repeat i) (range j n)))\n                                ~@(rd (mv (range i -1 -1) (repeat j)))\n                                ~@(rd (mv (range i n) (repeat j)))\n                                ~@(rd (mv (range i n) (range j n)))\n                                ~@(rd (mv (range i -1 -1) (range j -1 -1)))\n                                ~@(rd (mv (range i -1 -1) (range j n)))\n                                ~@(rd (mv (range i n) (range j -1 -1))))\n                              (filter #(and (> (count %) 2)\n                                            (= (get-in b (last %)) p)\n                                            (apply = (conj (map (fn [e] (get-in b e)) (butlast (rest %))) (o p)))))\n                              (mapcat #(butlast (rest %)))\n                              set)]\n                 :when (and (= 'e ((b i) j))\n                            (not (empty? c)))]\n             {[i j] c}))))", "problem": 124, "user": "4f34eb87e4b0e243712b1eba"}, {"code": "(fn [b c]\n  (let [locs (for [i (range 4) j (range 4)] [i j])\n        dirs (for [i [-1 0 1] \n                   j (if (zero? i) [-1 1] [-1 0 1])] [i j])]\n    (apply merge-with into\n      (for [loc locs\n            :when (= (get-in b loc) 'e)\n            dir dirs\n            :let [xs (next (iterate #(map + % dir) loc))\n                  [flips [end]] (split-with \n                            #(= (get-in b %) \n                               ('{w b b w} c)) xs)]\n            :when (and (seq flips) \n                    (= c (get-in b end)))]\n        {loc (set flips)}))))", "problem": 124, "user": "4e8f1ac6535d65386fec2146"}, {"code": "(fn [tb pl]\n  (letfn [\n    (opponent-of [pl] \n      (get {'b 'w, 'w 'b} pl))\n    (safe-nth [s i] \n      (if (or (< i 0) (<= (count s) i)) nil (nth s i)))\n    (val-at \n      ([val] #(val-at % val))\n      ([ [y x :as xy] val]\n        (= val (safe-nth (safe-nth tb y) x))))\n    (go [ exy oxy ]\n      (split-with\n        (val-at (opponent-of pl))\n        (take-while (complement (val-at nil))\n          (next (iterate (partial map + oxy) exy)))))\n      ]\n    (let [offsets \n            (for [x [-1 0 1] \n                  y [-1 0 1] \n                  :when (not= 0 x y)] \n              [x y])\n          empty-places\n            (filter (val-at 'e)\n              (for [x (range 4) y (range 4)] [x y]))\n        ]\n        (apply hash-map\n          (apply concat\n            (for [oxy offsets \n                  exy empty-places \n                  :let [[run more] (go exy oxy)]\n                  :when (not (empty? run))\n                  :when (not (empty? more))\n                  :when (val-at (first more) pl)]\n              [exy (set run)]))))))", "problem": 124, "user": "4f569218e4b0a7574ea71826"}, {"code": "(letfn [\n    ; Regular expressions\n    ; e.g. [pred [:or [pred...] [pred...]] [:zero-or-more pred...]])\n    (matches-start? [pattern s]\n      (println pattern)\n      (if (empty? pattern)\n        true\n        (let [p (first pattern)]\n          (cond (fn? p)\n                  (and (p (first s))\n                       (matches-start? (rest pattern) (rest s)))\n                (= (first p) :or)\n                  (true? (some #(matches-start? % s)\n                    (for [i (rest p)]\n                      (concat i (rest pattern)))))\n                (= (first p) :optional)\n                  (or (matches-start? (rest pattern) s)\n                      (matches-start? (concat (rest p) (rest pattern)) s))\n                (= (first p) :zero-or-more)\n                  (or (matches-start? (rest pattern) s)\n                      (matches-start? (concat (rest p) pattern) s))\n                (= (first p) :one-or-more)\n                  (matches-start? (concat (rest p)\n                                          [(cons :zero-or-more (rest p))]\n                                          (rest pattern))\n                                  s)))))\n    ; Cells\n    (open-cell  [] 'e)\n    (black-cell [] 'b)\n    (white-cell [] 'w)\n    (wall-cell  [] nil)\n    (open?  [cell] (= cell (open-cell)))\n    (black? [cell] (= cell (black-cell)))\n    (white? [cell] (= cell (white-cell)))\n    (wall?  [cell] (= cell (wall-cell)))\n    (cell=  [a b]  (= a b))\n    ; Boards\n    (board-from-syms [strs] strs)\n    (syms-from-board [board] board)\n    ; Locations\n    (get-cell [board location]\n      (get-in board location (wall-cell)))\n    (locations [board]\n      (for [row (range (count board))\n            col (range (count (board row)))]\n        [row col]))\n    ; Directions\n    (make-direction [delta-row delta-col]\n      [delta-row delta-col])\n    (add-direction [direction location]\n      (vec (map + direction location)))\n    (eight-directions []\n      (for [i [-1 0 1]\n            j [-1 0 1]\n            :when (not= [i j] [0 0])]\n          (make-direction i j)))\n    ; Rays\n    (get-ray [board location direction]\n      (iterate (partial add-direction direction) location))\n    (legal-move? [board ray]\n      (legal-move-cells? (map (partial get-cell board) ray)))\n    (legal-move-cells? [cells]\n      (matches-start? [[:or [black? [:one-or-more white?] open?]\n                           [white? [:one-or-more black?] open?]]]\n                      cells))\n    (move-hash-from-ray [board ray]\n      (if-not (legal-move? board ray)\n        {}\n        {(some #(when (open? (get-cell board %)) %) ray)\n           (set (take-while #(not (open? (get-cell board %)))\n                               (rest ray)))}))\n    (move-hash-from-location [board location]\n      (apply merge-with clojure.set/union\n        (map #(move-hash-from-ray board (get-ray board location %))\n          (eight-directions))))]\n  (fn [board player]\n    (apply merge-with clojure.set/union\n      (map #(move-hash-from-location board %)\n        (filter #(cell= player (get-cell board %))\n          (locations board))))))", "problem": 124, "user": "4f6fbb68e4b07046d9f4efeb"}, {"code": "(fn f [rr w] \n  (let [check (fn\n                [rr [x y] [dx dy] v]\n         (loop [x (+ x dx) y (+ y dy) r #{}]\n           (when (and (< -1 x 4) (< -1 y 4) (not= ((rr x) y) 'e))\n             (if (= ((rr x) y) v) r\n               (recur (+ x dx) (+ y dy) (conj r [x y]))))))\n        ll (fn [rr p w]\n             (into #{} (mapcat #(check rr p % w) \n               (for [x (range -1 2) y (range -1 2)] [x y]))))]\n\n      (into {} (filter #(not (empty? (second %))) \n            (for [x (range 0 4) y (range 0 4) :when (= ((rr x)y) 'e)]\n               [[x y] (ll rr [x y] w)])))))", "problem": 124, "user": "4deff9f9535d08e6dec9fe15"}, {"code": "(fn legal-moves [board player]\r\n  (let [to-indexed #(into {} (map-indexed vector %))\r\n        board (to-indexed (map to-indexed board))\r\n        other ('{w b b w} player)\r\n        dim (range 4)\r\n        mt-locs (for [i dim j dim :when (= ((board i) j) 'e)] [i j])\r\n        vecs (for [i [-1 0 1] j [-1 0 1] :when (not= 0 i j)] [i j])\r\n        flip-vec (fn [[r c] [i j]]\r\n                   (loop [r (+ r i), c (+ c j), acc nil]\r\n                     (condp = (get-in board [r c])\r\n                       ; These two should have been the default case,\r\n                       ; but it complained about recur and tail position...\r\n                       nil nil, 'e nil\r\n                       player acc\r\n                       other (recur (+ r i) (+ c j) (cons [r c] acc)))))\r\n        flipped-at (fn [loc] (mapcat #(flip-vec loc %) vecs))\r\n        all-moves (map #(vector % (set (flipped-at %))) mt-locs)]\r\n    (into {} (filter #(seq (second %)) all-moves))))", "problem": 124, "user": "4f6160a7e4b0defedf855fbe"}, {"code": "(fn [M c]\n  (let [o    (if (= c 'b) 'w 'b)\n        getm #(nth (nth %3 %1 nil) %2 'x)\n        r    (fn [x y] \n               ) \n        esq  #(loop [[x y :as co] (%2 %1) ac nil]\n                (cond (= (getm x y M) o)  (recur (%2 co) (cons co ac))\n                      (= (getm x y M) c)  nil\n                      (= (getm x y M) 'x) (if (> 1 (count ac)) ac nil)\n                      :else               (if ac (cons co ac) nil)))\n        n   #(esq [%1 %2] (fn [[x y]] [(inc x) y      ]))\n        s   #(esq [%1 %2] (fn [[x y]] [(dec x) y      ]))\n        e   #(esq [%1 %2] (fn [[x y]] [x       (inc y)]))\n        w   #(esq [%1 %2] (fn [[x y]] [x       (dec y)]))\n        ne  #(esq [%1 %2] (fn [[x y]] [(inc x) (inc y)]))\n        nw  #(esq [%1 %2] (fn [[x y]] [(inc x) (dec y)]))\n        se  #(esq [%1 %2] (fn [[x y]] [(dec x) (inc y)]))\n        sw  #(esq [%1 %2] (fn [[x y]] [(dec x) (dec y)]))\n        start (for [x (range 4) y (range 4) :when (= (getm x y M) c)]\n                [x y])\n        allseq #(for [f [n s e w ne nw se sw] :let [sol (f %1 %2)] :when sol]\n                  [(first sol) (into #{} (next sol))])]\n    (apply hash-map (apply concat (mapcat #(apply allseq %1) start)))))", "problem": 124, "user": "4f32a7f1e4b0d6649770a095"}, {"code": "(fn reversi [board bw]\r\n  (let [directions [[0 1] [0 -1] [-1 0] [1 0] [1 1] [1 -1] [-1 1] [-1 -1]]]\r\n    (letfn [(other [bw] (if (= bw 'b) 'w 'b)),\r\n            (m+ [va vb] (map + va vb)),\r\n            (inside? [[y x]]\r\n              (and (<= 0 x 3) (<= 0 y 3))),\r\n            (piece [[y x]]\r\n              (if (inside? [y x])\r\n                (nth (nth board y) x)\r\n                'o)),\r\n            (flipped-pieces-with-direction [pos dir already]\r\n              (let [next (m+ pos dir)]\r\n                (cond\r\n                 (= (piece next) bw)\r\n                   already,\r\n                 (= (piece next) (other bw))\r\n                   (recur next dir (conj already next))\r\n                 (or (= (piece next) 'e) (= (piece next) 'o))\r\n                   #{})))\r\n            (flipped-pieces [pos]\r\n              (if (not= (piece pos) 'e)\r\n                #{}\r\n                (set (mapcat #(flipped-pieces-with-direction pos % #{}) directions))))]\r\n      (into {} (for [x (range 0 4), y (range 0 4)\r\n                     :let [f (flipped-pieces [y x])]\r\n                     :when (not (empty? f))]\r\n                 [[y x] f])))))", "problem": 124, "user": "4f62b29ce4b0defedf855fd9"}, {"code": "(fn reversi [board type]\n  (let [op ({'b 'w 'w 'b} type)\n        go? (fn [[x y]] (cond (not (and (<= 0 x 3) (<= 0 y 3))) :bad\n                              (= op (get-in board [x y])) :cont\n                              (= type (get-in board [x y])) :good\n                              :else :bad))\n        dirs [[0 -1] [0 1] [1 0] [-1 0] [1 1] [-1 1] [-1 -1] [1 -1]]\n        go (fn [cur dir]\n              (loop [acc #{}\n                     cur (map + cur dir)]\n                (if (= :cont (go? cur))\n                  (recur (conj acc cur) (map + cur dir))\n                  (if (= :bad (go? cur))\n                    #{}\n                    acc))))\n        go-every (fn [cur] (set (apply concat (map #(go cur %) dirs))))]\n  (->> (for [x [0 1 2 3] y [0 1 2 3]] (if (= 'e (get-in board [x y])) [[x y] (go-every [x y])] nil))\n    (remove nil?)\n    (remove #(empty? (last %)))\n    (map vec)\n    (into {}))\n    ))", "problem": 124, "user": "4f465096e4b0d56e7bb92b9a"}, {"code": "(fn [board side]\r\n  (let [\r\n         sy (count board)\r\n         sx (count (first board))\r\n         board (flatten board)\r\n         index (fn [[y x]] (+ x (* y sx)))\r\n         oob (fn [[y x]] (or (< y 0) (< x 0) (>= y sy) (>= x sx)))\r\n         shift (fn [[y x] [dy dx]] [(+ y dy) (+ x dx)])\r\n         piece #(nth board (index %))\r\n         moves (fn [] (filter #(= 'e (piece %))\r\n                        (for [y (range sy) x (range sx)] [y x])))\r\n         deltas #(for [y [-1 0 1] x [-1 0 1] :when (not= 0 y x)] [y x])\r\n         flips (fn [cell delta] (loop [cell cell captures #{}]\r\n                                  (let [c (shift cell delta)]\r\n                                    (if (oob c)\r\n                                      nil\r\n                                      (let [p (piece c)]\r\n                                        (cond\r\n                                          (= 'e p) nil\r\n                                          (= side p) captures\r\n                                          :else (recur c (conj captures c))))))))]\r\n    (reduce (fn [r [m fs]] (assoc r m (into (r m #{}) fs)))\r\n      {} (for [m (moves) d (deltas) :let [fs (flips m d)] :when (seq fs)] [m fs]))))", "problem": 124, "user": "4f969214e4b0dcca54ed6cdd"}, {"code": "(fn reversi [board color]\r\n  (let\r\n    [all-squares (for [i (range 4) j (range 4)] [i j])\r\n     other-color (if (= color 'b) 'w 'b)\r\n     empty-squares (filter #(= 'e (get-in board %)) all-squares)\r\n     all-directions (for [i [-1 0 1] j [-1 0 1]\r\n                          :when (or (not= i 0) (not= j 0))] [i j])\r\n     go-dir (fn [start-square direction]\r\n              (let\r\n                [[di dj] direction\r\n                 go-forever (iterate (fn [[i j]] [(+ i di) (+ j dj)]) start-square)\r\n                 go-far (take-while (fn [[i j]]\r\n                                      (and (>= i 0)\r\n                                           (>= j 0)\r\n                                           (< j 4)\r\n                                           (< i 4))) go-forever)\r\n                 go-far-len (dec (count go-far))\r\n                 flips (take-while #(= other-color (get-in board %)) (drop 1 go-far))\r\n                 num-flips (count flips)\r\n                 next-color (if (= num-flips go-far-len) 'e\r\n                                (get-in board (first (drop (inc num-flips) go-far))))]\r\n                 (if (= next-color color) flips [])))\r\n     flips-for (fn [start-square]\r\n                  (apply concat (map #(go-dir start-square %) all-directions)))\r\n     all-moves (apply array-map \r\n                 (apply concat\r\n                   (filter #(not (empty? %))\r\n                    (map (fn [sq]\r\n                            (let\r\n                                [ff (flips-for sq)]\r\n                                (if (empty? ff) []\r\n                                   [sq (set ff)])))                                \r\n                            empty-squares))))]\r\n     all-moves))", "problem": 124, "user": "4f036fb3535dcb61093f6ac8"}, {"code": "(fn [[a b [c & r] d] k]\n  ('{[e w] {[1 3] #{[1 2]}, [0 2] #{[1 2]}, [3 1] #{[2 1]}, [2 0] #{[2 1]}},\n     [w b] {[3 2] #{[2 2]}, [3 0] #{[2 1]}, [1 0] #{[1 1]}},\n     [w w] {[0 3] #{[1 2]}, [1 3] #{[1 2]}, [3 3] #{[2 2]}, [2 3] #{[2 2]}},\n     [b b] {[0 3] #{[2 1] [1 2]}, [1 3] #{[1 2]}, [2 3] #{[2 1] [2 2]}}}\n   [c k]))", "problem": 124, "user": "4f9fe2b9e4b0dcca54ed6d40"}, {"code": "(fn board->legal-moves [board me]\n  (let [stone #(get-in board %)\n        empty-cells (for [x (range 4) y (range 4)\n                          :when (= 'e (stone [x y]))]\n                      [x y])\n        directions (for [x [-1 0 1] y [-1 0 1]\n                         :when (not= 0 x y)]\n                     [x y])\n        opponent (cond (= me 'w) 'b\n                       (= me 'b) 'w)\n        walk (fn [[dx dy]]\n               (fn [[x y]]\n                 [(+ x dx) (+ y dy)]))\n        black-or-white? #('#{b w} (stone %))\n        line (fn [from]\n               (fn [direction]\n                 (->> (iterate (walk direction) from)\n                      (drop 1)\n                      (take-while black-or-white?))))\n        lines #(map (line %) directions)\n        end-with-me? (fn [s]\n                       (= me (-> s reverse first stone)))\n        opponent-stone? #(= opponent (stone %))\n        flipped-stones (comp set\n                             (partial mapcat (partial take-while opponent-stone?))\n                             (partial filter end-with-me?)\n                             lines)]\n    (->> empty-cells\n         (map (juxt identity flipped-stones))\n         (filter (comp seq second))\n         (into {}))))", "problem": 124, "user": "4f3fb586e4b0e243712b1f9c"}, {"code": "(fn analyze [board color]                                                                             \n  (letfn [(btwn [a b] (rest (apply range (sort [a b]))))                                             \n          (pieces-between [[x1 y1] [x2 y2]]                                                          \n            (cond                                                                                    \n             (= x1 x2) (for [yi (btwn y1 y2)] [x1 yi])                                               \n             (= y1 y2) (for [xi (btwn x1 x2)] [xi y1])                                               \n             (integer? (/ (- y2 y1) (- x2 x1)))                                                      \n             (let [m (/ (- y2 y1) (- x2 x1))                                                         \n                   b (- y1 (* m x1))]                                                                \n               (for [xi (btwn x1 x2)] [xi (+ (* m xi) b)]))                                          \n             :else []))                                                                              \n          (same-color [board color]                                                                  \n            (for [x (range 4) y (range 4)                                                            \n                  :when (= color (get-in board [x y]))]                                              \n              [x y]))                                                                                \n          (capturable? [ps color board]                                                              \n            (not-any? #{'e color} (map #(get-in board %) ps)))]                                      \n    (let [others (same-color board color)]                                                           \n      (apply merge                                                                                   \n             (reduce concat                                                                          \n                     (for [x (range 4) y (range 4)                                                   \n                           :when (= 'e (get-in board [x y]))]                                        \n                       (remove nil? (for [p others]                                                  \n                                      (if-let [pieces  (seq (pieces-between p [x y]))]               \n                                        (if (capturable? pieces color board)                         \n                                          {[x y] (into #{} pieces)})))))))))                         \n    )", "problem": 124, "user": "4f1d1299535d64f603146487"}, {"code": "(fn [grid letter]\n  (let [get-line (fn get-linei [row col rise run]\n          (lazy-seq \n            (let [curletter (get-in grid [(+ row rise) (+ col run)] nil)]\n              (cond\n                (nil? curletter) '()\n                (= curletter letter) '()\n                (= curletter 'e) (cons 'e '())\n                :else (cons curletter (get-linei (+ row rise) (+ col run) rise run))))))\n        solvei (fn [row col rise run]\n          (let [ans (get-line row col rise run)]\n            (if (empty? ans)\n              nil\n              (if (and (> (count ans) 1) (= (last ans) 'e))\n                (count ans)\n                nil))))\n        solve (fn [row col rise run]\n          (let [ans (solvei row col rise run)]\n            (if (nil? ans)\n              nil\n              [[(+ row (* ans rise)) (+ col (* ans run))]\n                (into #{} \n                  (for [x (range 1 ans)]\n                    [(+ row (* x rise)) (+ col (* x run))]))])))       \n        for-each-sq (fn [row col]\n          (filter identity (for [rise [-1 0 1] run [-1 0 1] :when (or (not= 0 rise) (not= 0 run))]\n            (solve row col rise run)))) ]\n    (into {} (reduce concat (remove empty? (for [row (range 4) col (range 4) :when (= letter (get-in grid [row col]))]\n      (for-each-sq row col)))))))", "problem": 124, "user": "4e7f5a0b535db966e863cc41"}, {"code": "(fn analyze-reversi [board color]\n  (let\n    [empty-coords (for [y (range  4) x (range 4) :when (= 'e (get-in board [y x]))]\n                    [y x])\n     directions (for [y (range -1 2) x (range -1 2) :when (not= [y x] [0 0])]\n                    [y x])\n     extract-seq (fn [coord dir]\n       (take-while (fn [coord] (every? #(and (>= % 0) (<= % 3)) coord))\n         (iterate #(map + dir %) coord)))\n     seqs-to-consider (filter #(> (count %) 2)\n                        (for [coord empty-coords dir directions]\n                          (extract-seq coord dir)))\n     other-color? (fn [coords] (not (#{'e color} (get-in board coords))))\n     analyze (fn [s]\n      (when-let [between (take-while other-color? s)]\n        (when-let [end (first (drop-while other-color? s))]\n          (if (= color (get-in board end)) between))))]\n     (reduce\n       (fn [result [coord & rest-seq]]\n         (let [to-flip (analyze rest-seq)]\n           (if (empty? to-flip)\n               result\n               (merge-with #(into %1 %2) result {coord (set to-flip)}))))\n       {}\n       seqs-to-consider)))", "problem": 124, "user": "4f725466e4b07046d9f4f030"}, {"code": "(fn game[board target]\r\n  (let[maxx   (count board)\r\n       maxy   (count (first board) )\r\n       getValue (fn[[x y]]\r\n                 (if (or (>= x maxx) (>= y maxy) \r\n  \t                     (< x 0) (< y 0) )\r\n\t\t\t\t\t\t\t\t\t       'board\r\n\t\t\t\t\t\t\t\t\t       (nth (nth board x)  y)))\r\n\r\n       start? (fn[point]\r\n                 (let[val (getValue point)]\r\n                  (and (not= val target)\r\n                       (not= val 'e)\r\n                       (not= val 'board)\r\n                           )))\r\n\r\n       getEmpty (fn[col]\r\n                  (filter #(not (nil? %) )\r\n                     (map #(if (= %1 'e) %2 nil )\r\n                       col\r\n                       (range 0 maxy))))\r\n       emptyBox (mapcat \r\n                   (fn[line x](map  #(list x %)   line) )\r\n                   (map getEmpty  board)\r\n                   (range 0 maxx))\r\n\r\n                     \r\n       getCircle (fn[point]\r\n                   (do (println (str \"start point\" point))\r\n                   (filter\r\n                     #(start? (%  point) )\r\n                     (for [a (range -1 2),b (range -1 2)\r\n\t\t                            :when (or (not= a 0) (not= b 0))]\r\n\t\t                         (fn[[x1 y1]]\r\n\t\t                           (let[x (+ x1 a)\r\n\t\t                                y (+ y1 b)]\r\n\t\t                                [x y]\r\n\t\t\t\t\t\t\t\t\t                   )))))\r\n                   )\r\n       getSeq (fn findSeq\r\n                ([seq result]\r\n                   (let[v (first seq)]\r\n                      (do\r\n                        (println (str \"v:\" v \" val:\" (getValue v)))\r\n                        (println result)\r\n                      (cond\r\n                        (start? v)  \r\n                          (recur (rest seq) (conj result v))\r\n                        (= target (getValue v))\r\n                          result\r\n                        :else \r\n                          #{}\r\n                        ))\r\n                     )\r\n                  )\r\n                 ([seq]\r\n                     (findSeq seq #{}) \r\n                     )\r\n                )\r\n       ]\r\n      (reduce  \r\n        (fn[m {v :col p :point}]\r\n           (assoc m p (set v) )          \r\n          )\r\n         {}\r\n      (filter\r\n         (fn([{v :col}]\r\n            (and (not= v 'empty)\r\n                 (not-empty v))\r\n            ))\r\n        (map (fn[fcol  point]\r\n              {:col\r\n              (if (empty? fcol)\r\n                  'empty                  \r\n                  (mapcat \r\n                    #(getSeq  (iterate % (% point) ))\r\n                       fcol)\r\n                  )\r\n               :point \r\n                 point}\r\n                )\r\n            (map getCircle emptyBox)\r\n             emptyBox)))))", "problem": 124, "user": "4f6d9d7ee4b07046d9f4efcd"}, {"code": "(fn\n  [b c]\n  (into {} (for [each (for [i (range 4) j (range 4)] [i j])\n                    :when (= (get-in b each) 'e)\n                    dir (for [i [-1 0 1] j [-1 0 1] :when (not= 0 i j)] [i j])\n                    :let [xs (iterate #(map + % dir) each)\n                          [fs [s]] (split-with #(= ('{w b b w} c) (get-in b %)) (next xs))]\n                    :when (and (seq fs)\n                               (= (get-in b s) c))]\n                [each (set fs)] )))", "problem": 124, "user": "4e6dd0f5535d5021c1a895f3"}, {"code": "(fn [b c]                   ; board and color\n  (let [h (count b)         ; height\n        w (count (first b)) ; width\n        g #(get-in b %)     ; get stat of\n        rc ('{w b b w} c)]  ; reversed color\n    (reduce\n      (fn [a [k v]] (assoc a k (into v (a k)))) \n      {}\n      (for [p (for [y (range h) x (range w)] [y x]) ; point\n            d [[0 1] [1 1] [1 0] [1 -1]             ; direction\n               [0 -1] [-1 -1] [-1 0] [-1 1]]\n            :let [\n              f #(map + % d) ; feed\n              nxts (map vec (take-while #(= (g %) rc) (iterate f (f p))))\n              nnxt (g (f (last nxts)))]\n            :when (and (= (g p) 'e) (= nnxt c))]\n        [p (set nxts)]))))", "problem": 124, "user": "4fd96694e4b05e33b9224f37"}, {"code": "(fn q124 [board color]\n  (letfn [\n  \t(line [[r c :as cell] [p q :as step] [m n :as ends]]\n\t\t  (if (and (<= 0 r m) (<= 0 c n))\n\t\t    (cons [r c] (line (map + cell step) step ends))\n\t\t    nil))\n\n\t\t(lines [cell ends]\n\t\t  (let [steps [[0,  -1]   ;W\n\t\t               [-1, -1]   ;NE\n\t\t               [-1,  0]   ;N\n\t\t               [-1,  1]   ;NW\n\t\t               [0,   1]   ;E\n\t\t               [1,   1]   ;SW\n\t\t               [1,   0]   ;S\n\t\t               [1,  -1]]] ;SE\n\t\t    (filter #(<= 3 (count %)) (map #(line cell % ends) steps))))\n\n\t\t(opposite-color [c]\n\t\t  (cond\n\t\t    (= 'b c) 'w\n\t\t    (= 'w c) 'b\n\t\t    :else nil))\n\n\t\t(check-line [board color line]\n\t\t  (let [oc (opposite-color color)\n\t\t        [xs ys] (split-with #(= oc %) (map #(get-in board %) (rest line))) ]\n\t\t    (if (and (not-empty xs) (not-empty ys) (= color (first ys)))\n\t\t      (take (count xs) (rest line)))))\n\n\n\t\t(main [board color]\n\t\t  (let [m (count board) \n\t\t        n (count (first board))\n\t\t        m-1 (dec m)\n\t\t        n-1 (dec n)\n\t\t        e-cells (for [x (range m) y (range n) :let [cell [x y]] :when (= 'e (get-in board cell))] cell)\n\t\t        ]\n\t\t    (reduce\n\t\t      (fn [result cell]\n\t\t        (let [v (mapcat #(check-line board color %) (lines cell [m-1 n-1]))]\n\t\t          (if (empty? v) \n\t\t            result\n\t\t            (assoc result cell (set v)))))\n\t\t      {} e-cells))) ]\n         \n    (main board color)))", "problem": 124, "user": "4fd22e70e4b04c3a95aa041c"}, {"code": "(fn reversi [board player]\r\n    (let [board (into {} (apply concat (map-indexed (fn [y line] (map-indexed (fn [x c] [[x y] c]) line)) board)))\r\n          flips (fn [x y dir acc] \r\n                  (let [nx (+ x (dir 0)) ny (+ y (dir 1)) c (board [nx ny] 'e)] \r\n                    (cond \r\n                      (= c player) acc \r\n                      (= c 'e) #{}\r\n                      :else (recur nx ny dir (conj acc [ny nx])))))]\r\n      (into {}\r\n            (apply concat\r\n                   (for [x (range 4) y (range 4)]\r\n                     (let [c (board [x y])]\r\n                       (if (= c 'e)\r\n                         (reduce \r\n                           (fn [acc dir] (let [fl (flips x y dir #{})] (if (empty? fl) acc (conj acc [[y x] fl])))) \r\n                           []\r\n                           [[-1 -1] [-1 0] [-1 1] [0 -1] [0 1] [1 -1] [1 0] [1 1]])\r\n                         []\r\n                         )))))))", "problem": 124, "user": "4feada56e4b0140c20fb9c11"}, {"code": "(fn [board tomove]\n  (let [opponent (if (= tomove 'w) 'b 'w)\n        dirmove (fn [inity initx dy dx]\n                  (loop [y inity x initx r []]\n                    (let [v (get-in board [y x])]\n                      (cond (= v tomove) r\n                            (= v opponent) (recur (+ y dy) (+ x dx) (conj r [y x]))\n                            true []))))\n        moves (fn [y x]\n                (if (not= (get-in board [y x]) 'e)\n                  #{}\n                  (into #{} (apply concat (for [dx '(-1 0 1) dy '(-1 0 1)\n                                                :when (or (not= dx 0) (not= dy 0))]\n                                            (dirmove (+ y dy) (+ x dx) dy dx))))))]\n    (into {} (for [y (range 4) x (range 4)\n                   :let [m (moves y x)]\n                   :when (not (empty? m))]\n               [[y x] m]))))", "problem": 124, "user": "4fe8aef4e4b07c9f6fd12c6c"}, {"code": ";; Try a straightforward approach of checking every empty board\n;; position, and seeing whether it is a legal play for the given\n;; color.\n\n;; It is legal if at least one neighboring position (horizontal,\n;; vertical, or diagonal) contains a piece of the opposing player, and\n;; there are one or more consecutive such pieces in a straight line\n;; that end with a piece of the same color.\n\n(fn [board color]\n  (let [opp-color (if (= 'b color) 'w 'b)\n        posn-on-board (fn [[r c]]\n                        (and (< -1 r 4) (< -1 c 4)))\n        posns-in-dir (fn [[r c] [dr dc]]\n                       (take-while posn-on-board\n                                   (rest\n                                    (iterate (fn [[r c]]\n                                               [(+ r dr) (+ c dc)])\n                                             [r c]))))\n        flipped-posns-in-dir\n        (fn [pos dir]\n          (let [[opp-posns other-posns] (split-with #(= opp-color (get-in board %))\n                                                    (posns-in-dir pos dir))\n                p (first other-posns)]\n            (if (and (>= (count opp-posns) 1)\n                     p\n                     (= color (get-in board p)))\n              (set opp-posns))))\n        flipped-posns\n        (fn [pos]\n          (apply clojure.set/union\n                 (remove nil?\n                         (map #(flipped-posns-in-dir pos %)\n                              [[-1 -1] [-1 0] [-1 1]\n                               [ 0 -1]        [ 0 1]\n                               [ 1 -1] [ 1 0] [ 1 1]]))))]\n    (into {} (for [r (range 4)\n                   c (range 4)\n                   :let [flipped (flipped-posns [r c])]\n                   :when (and (= 'e (get-in board [r c]))\n                              (not= flipped #{}))]\n               [[r c] flipped]))))", "problem": 124, "user": "500d8c49e4b07ccb9a7ddb00"}, {"code": "(let [r (fn [s d] (take-while (fn [v] (every? #(<= 0 % 3) v)) (iterate #(map + % d) s)))\n        h (fn [l p] (when (and (<= 0 p) (< p (count l))) (l p)))\n        V [1 0]\n        H [0 1]\n        B [0 -1]\n        D [1 1]\n        E [1 -1]\n        N [0 0]\n        k (fn [s, c, d] (for [t (mapcat #(r s %) c) l (map #(vec (r t %)) d)] l))\n        R (filter #(> (count %) 2) (concat (k N [H] [V]) (k N [V] [H]) (k N [H V] [D]) (k [0 3] [B V] [E])))]       \n    (fn [b c]\n      (let [g (partial get-in b)\n            o (if (= c 'w) 'b 'w)]\n        (->>\n\t\t\t    (for [l R\n\t\t\t          :when (not-every? #(->> % g #{'e c}) l)\n\t              p (-> l count range)\n\t              :when (-> p l g (= 'e))\n\t              d [-1 1]\n\t              :let [t (->> p \n\t                        (iterate #(+ % d))\n\t                        rest\n\t                        (map #(h l %)) \n\t                         \n\t                        (take-while #(= (g %) o))\n\t                        )\n\t                    ]\n\t              :when (and (seq t) (->> p (+ (* d (+ 1 (count t)))) (h l) g (= c)))\n\t              \n\t              ]\n\t\t\t      [(l p) (set t)])\n          (into {})))))", "problem": 124, "user": "4e82f85d535db62dc21a62ce"}, {"code": "(fn [b c]\n    (let [op '{w b b w}\n          f (fn f [p d s]\n              (let [p' (map + p d)]\n                (condp = (get-in b p')\n                  (op c) (f p' d (conj s p'))\n                  c s\n                  #{})))]\n      (into {}\n            (for [p (filter #(= 'e (get-in b %))\n                            (map (juxt quot mod) (range 16) (repeat 4)))\n                  fs [(reduce\n                       into\n                       (for [y [-1 0 1], x [-1 0 1]\n                             :when (not (= 0 x y))]\n                         (f p [y x] #{})))]\n                  :when (not (empty? fs))]\n              [p fs]))))", "problem": 124, "user": "4fb1d907e4b081705acca282"}, {"code": "(fn [r b c]\n    (into {} \n          (for [x r y r\n                :let [C #{c}\n                      t take-while\n                      o [-1 0 1]\n                      M map\n                      B #(get-in b %)\n                      z [y x]\n                      m (mapcat (fn [p]\n                                       (let [[i & j] (iterate #(M + p %) z)]\n                                         (and\n                                           (#{'e} (B i))\n                                           (some C\n                                                 (t\n                                                   #{'b 'w}\n                                                   (M B j)))\n                                           (t (comp not C B) j))))\n                                     (for [X o Y o] [Y X]))]\n                :when (seq m)]\n            [z (set m)]\n            ))) [0 1 2 3]", "problem": 124, "user": "4dc537fd535d8a4b2fd74282"}, {"code": "(fn [brd clr] (let [\r\n  foe   ({'w 'b 'b 'w} clr)\r\n  map2i #(map-indexed (fn [i r] (map-indexed (fn [j c](% i j c)) r)) %2)\r\n  in?   (fn [v l r] (and (>= v l) (< v r)))\r\n  [w h] [(count (first brd)) (count brd)]\r\n  at    (fn [i j] (if (and (in? i 0 w) (in? j 0 h)) (nth (nth brd j) i)))\r\n  stp   [-1 0 1]\r\n  dirs  (for [i stp j stp] [i j])\r\n  flips (fn [i j s [dx dy]]\r\n    (if (not= 'e (at i j)) s\r\n      (loop [x (+ i dx) y (+ j dy) fl #{}]\r\n        (if-let [cf (at x y)]\r\n          (cond\r\n            (= clr cf) (into s fl)\r\n            (= foe cf) (recur (+ x dx) (+ y dy) (cons [y x] fl))\r\n            :else s)\r\n          s))))]\r\n  (->> brd\r\n    (map2i (fn [i j c]\r\n      (vector [j i] (reduce (partial flips i j) #{} dirs))))\r\n    (reduce concat)\r\n    (filter (comp seq second))\r\n    (into {}))))", "problem": 124, "user": "50336c6be4b0c6c1199c710f"}, {"code": "(let [board '[[e e w e]\r\n              [b b w e]\r\n              [b w w e]\r\n              [b w w w]]\r\n\r\n      dirs (for [x [-1 0 1] y [-1 0 1]] [y x])\r\n      opposite-color {'w 'b 'b 'w}\r\n\r\n      step-move (fn step-move [board their-color pos dir history]\r\n                  (condp = (get-in board pos)\r\n                    their-color  (step-move board their-color (map + pos dir) dir (conj history pos))\r\n                    'e          (if (< 0 (count history)) {pos (set history)})\r\n                    nil))\r\n\r\n      all-moves (fn [board my-color]\r\n                  (let [their-color (my-color opposite-color)]\r\n                    (apply merge\r\n                     (filter identity\r\n                             (for [y (range (count board))\r\n                                   x (range (count (first board)))\r\n                                   dir dirs]\r\n                               (if (= my-color (get-in board [y x]))\r\n                                 (step-move board their-color (map + [y x] dir) dir '())))))))]\r\n\r\n\tall-moves)", "problem": 124, "user": "4f1b92d1535d64f60314647b"}, {"code": "(fn [board color]\n  (letfn [(neighbors [r c]\n                     (for [dr [-1 0 1] dc [-1 0 1] \n                           :let [r1 (+ r dr), c1 (+ c dc)] \n                           :when (and (>= r1 0) (< r1 4) (>= c1 0) (< c1 4) (not (= [r c] [r1 c1])))]\n                       [r1 c1]))\n          (can-flip [[r-from c-from] [r-towards c-towards]]\n                    (let [dr (- r-towards r-from) dc (- c-towards c-from)\n                          opp (get-in board [r-towards c-towards])]\n                      (loop [nr (+ r-towards dr), nc (+ c-towards dc), flipped #{[r-towards c-towards]}]\n                        (cond \n                          (or (< nr 0) (< nc 0) (> nr 3) (> nc 3)) nil\n                          (= opp (get-in board [nr nc])) (recur (+ nr dr) (+ nc dc) (conj flipped [nr nc]))\n                          (= 'e (get-in board [nr nc])) nil\n                          :else flipped ))) )\n          ] \n         (->> (for [r (range 0 5) c (range 0 5) :let [cell (get-in board [r c])] :when (= 'e cell)] [r c])\n           (mapcat (fn [from] \n                     (map \n                       (fn [to] [from (can-flip from to)])\n                       (remove \n                         (fn [neighbor] (let [nc (get-in board neighbor)] \n                                          (or (= nc color) (= nc 'e)))) \n                         (apply neighbors from)))) ,,,)\n           (filter second ,,,)\n           (into {} ,,,)\n           )))", "problem": 124, "user": "4dca8b6d535d5973398f9288"}, {"code": "(fn [b c1]\n(let [m [[0 1], [0 -1], [1 0], [-1 0], [1 1], [-1 -1], [1 -1], [-1 1]] \n      v #{0 1 2 3}\n      r '{b w w b e e}\n      c2 (r c1)]\n  (into {}\n(for [i (range 4) j (range 4) [di dj] m\n      :when \n      (and \n        (v (+ i (* 2 di))) \n        (v (+ j (* 2 dj)))\n        (= c1 ((b i) j))\n        (= c2 ((b (+ i di)) (+ j dj)))\n      )]\n  \n  \n   (loop [acc #{} i2 i j2 j]\n     (let [i3 (+ i2 di) j3 (+ j2 dj)]\n       (if (and (v i3) (v j3))\n         (let [c ((b i3) j3)]\n           (cond \n             (= c 'e) [[i3 j3] acc]\n             (= c c2) \n             (recur (conj acc [i3 j3]) i3 j3)\n                 ))\n         nil\n       ))\n   ))\n  )\n  \n \n)\n  )", "problem": 124, "user": "503917a0e4b088a6a14ca763"}, {"code": "(fn [board white] (let [black ('{w b b w} white)]\r\n  (letfn [(G [pair](get-in board pair))\r\n          (B [pair](= black (G pair)))\r\n          (W [pair](= white (G pair)))\r\n          (MC [[x y] [i j]](let [res (for [k (range 1 4)\r\n                                          :let [xx (+ x (* i k)) yy (+ y (* j k))]\r\n                                          :while (B [xx yy])] [xx yy])\r\n                                las (last res)]\r\n                            (if (and las (W [(+ i (first las)) (+ j (last las))])) res [])))\r\n          (C [[x y]](set (mapcat (partial MC [x y]) [[1 1] [1 0] [1 -1] [0 1] [0 -1] [-1 1] [-1 0] [-1 -1]])))]\r\n    (apply merge (for [i (range 4) j (range 4)\r\n                       :let [R (C [i j])]\r\n                       :when (and (= 'e (G [i j])) (pos? (count R)))]\r\n                   {[i j] R})))))", "problem": 124, "user": "503354c3e4b0c6c1199c710c"}, {"code": "(fn [b p]\n    (letfn [(fp [p eq]\n              (for [x (range 4) y (range 4) :when (eq (get-in b [x y]) p)]\n                [x y]))\n            (mvs [piece line]\n              (let [p (partition-by identity line)\n                    [_ & w] (drop-while #(not ((set %) piece)) p)\n                    e (drop-while #(not ((set %) 'e)) w)\n                    x (when-not (#{piece 'e} (ffirst w)) (first w))\n                    m (ffirst e)\n                    s [(first (fp m identical?))\n                       (set (mapcat #(fp % identical?) x))]]\n                (when (and (seq x) m) s)))\n            (mv-sp [[x y]]\n              (let [row (nth b x)\n                    col (map #(nth % y) b)\n                    diag (fn [x y b] \n                           (->> b (map-indexed #(get-in %2 [(- % (- x y))]))\n                                  (filter identity)))\n                    d1 (diag x y b)\n                    d2 (diag (- 3 x) y (map (comp vec reverse) b))]\n                [row col d1 d2]))]\n       (let [pos (fp p =)\n             lines (mapcat #(mv-sp %) pos)]\n        (into {} (map #(mvs p %) (concat lines (map reverse lines))))\n      )\n    )\n  )", "problem": 124, "user": "4f58d92fe4b0a7574ea71858"}, {"code": "(fn [board piece]\n  (let [size (count board)\n        squares (for [i (range size) j (range size)] [i j])\n        lines (concat (vals (group-by first squares))\n                      (vals (group-by second squares))\n                      (loop [diags [] offset (- (dec size))]\n                        (if (>= offset size)\n                          (map vec diags)\n                          (recur (conj diags\n                                       (filter (fn [[i j]] (= (+ i offset) j)) squares)\n                                       (filter (fn [[i j]] (= (dec size) (+ i j offset))) squares))\n                                 (inc offset)))))\n        potential-lines (filter #(= 3 (-> (map (partial get-in board) %) distinct count)) lines)]\n    (->> (concat potential-lines (map reverse potential-lines))\n      (map #(drop-while (fn [square] (not= 'e (get-in board square))) %))\n      (map #(take-while (fn [square] (not= piece (get-in board square))) %))\n      (filter next)\n      (reduce (fn [res [h & t]] (assoc res h (set t))) {}))))", "problem": 124, "user": "5028cd0fe4b01614d1633ffc"}, {"code": "(fn [b c] (let [places (into {} (for [i (range 4) j (range 4)] [[i j] ((b i) j)]))\n                 dirs [[0 1] [1 1] [1 0] [-1 1] [-1 0] [-1 -1] [0 -1] [1 -1]]\n                 seek (fn [[p1 p2] [d1 d2]] \n                        (let [[q r] (split-with #(not (#{c 'e nil} (places %)))\n                                         (for [s (range 1 4)] [(+ p1 (* s d1)) (+ p2 (* s d2))]))]\n                          (when (= c (places (first r))) (seq q))))\n                 flips (fn [p] (set (apply concat (keep #(seek p %) dirs))))\n                 cands (map first ((group-by val places) 'e))\n                 ]\n             (into {} (map #(vector % (flips %)) (filter #(not (empty? (flips %))) cands)))\n            ))", "problem": 124, "user": "50563ae2e4b0ce54f56f0405"}, {"code": "(fn [rev p]\n  (let [r4 (range 4)\n        ds (for [x [-1 0 1] y [-1 0 1]] [x y])\n        v #(get-in rev % 'x)\n        pos #(for [x r4 y r4 :when (= % (v [x y]))] [x y])\n        init #(for [p % d ds] [d p #{}])\n        curr-val #(v (second %))\n        e? #(= 'e (v %))\n        add-pos (fn [[d p rs]] (let [rs1 (if (e? p) rs (conj rs p))] [d p rs1]))\n        step (fn [[d p rs]] (let [p1 (if (e? p) p (map + d p))] [d p1 rs]))\n        go-next (fn [rp sol] (->> sol (map step) (remove #(rp (curr-val %))) (map add-pos)))]\n    (->> (pos p) \n      init\t\t\n      (go-next #{p 'e 'x})\n      (go-next #{p 'x})\n      (go-next (complement #{'e}))\n      (mapcat rest) \n      (apply hash-map))))", "problem": 124, "user": "4f991ec1e4b0dcca54ed6cfb"}, {"code": "(fn reversi [board my-color]\n  (let [opponent-color ({'b 'w, 'w 'b} my-color)\n        all-positions  (for [i (range 4), j (range 4)] [i j])\n        directions     (for [i [-1 0 1], j [-1 0 1], :when (not= 0 i j)] [i j])\n        lookup        #(get-in board %)\n        my?           #(= (lookup %) my-color)\n        opponent's?   #(= (lookup %) opponent-color)\n        available?    #(= (lookup %) 'e)\n        legal?         (fn [[x y]] (and (<= 0 x 3) (<= 0 y 3)))\n        impacted       (fn [pos dir]\n                         (filter legal? (for [k (range 1 4)]\n                                          (map + pos (map #(* k %) dir)))))]\n    (into {}\n          (for [p (filter available? all-positions)\n                d directions\n                :let [[flipped remains] (split-with opponent's? (impacted p d))]\n                :when (and (not-empty flipped) (my? (first remains)))]\n            [p (set flipped)]))))", "problem": 124, "user": "50586354e4b06522596eba78"}, {"code": "(fn analyze-reversi [board color]\n  (letfn [(at [row col] (nth (nth board row) col))\n          (flip* [row col update]\n            (loop [[r c] (update row col) acc []]\n              (cond\n               (or (< r 0) (<= 4 r)) []\n               (or (< c 0) (<= 4 c)) []\n               (= (at r c) 'e) []\n               (= (at r c) color) acc\n               true (recur (update r c) (cons [r c] acc)))))\n          (flip [row col]\n            (when (= (at row col) 'e)\n              (let [pattern [#(vec [(inc %1) %2])\n                             #(vec [(inc %1) (inc %2)])\n                             #(vec [%1 (inc %2)])\n                             #(vec [(dec %1) (inc %2)])\n                             #(vec [(dec %1) %2])\n                             #(vec [(dec %1) (dec %2)])\n                             #(vec [%1 (dec %2)])\n                             #(vec [(inc %1) (dec %2)])]]\n                (set (mapcat #(flip* row col %) pattern)))))]\n    (reduce (fn [acc [row col]]\n              (let [f (flip row col)]\n                (if (empty? f)\n                  acc\n                  (assoc acc [row col] f))))\n            {}\n            (for [row (range 4) col (range 4)] [row col]))))", "problem": 124, "user": "504f57c7e4b0a02f9cffde71"}, {"code": "(let\n  [\n\t\tdirections [[0 -1] [-1 -1] [-1 0] [-1 1] [0 1] [1 1] [1 0] [1 -1]]\n\t]\n\t(letfn\n\t\t[\n\t\t\t(empty-cells [b]\n\t\t\t\t(filter identity\n\t\t\t\t\t(apply concat\n\t\t\t\t\t\t(map-indexed\n\t\t\t\t\t\t\t(fn [j row]\n\t\t\t\t\t\t\t\t(map-indexed\n\t\t\t\t\t\t\t\t\t(fn [i cell]\n\t\t\t\t\t\t\t\t\t\t(if (= 'e cell)\n\t\t\t\t\t\t\t\t\t\t\t[j i]\n\t\t\t\t\t\t\t\t\t\t\tfalse\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\trow\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\tb\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t\t(ray [width height [j i] [y x]]\n\t\t\t\t(loop [n j m i r []]\n\t\t\t\t\t(if (or (= y n -1) (= x m -1) (and (= y 1) (= n height)) (and (= x 1) (= m width)))\n\t\t\t\t\t\tr\n\t\t\t\t\t\t(recur (+ n y) (+ m x) (concat r [[n m]]))\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t\t(all-rays [b]\n\t\t\t\t(let\n\t\t\t\t\t[\n\t\t\t\t\t\theight (count b)\n\t\t\t\t\t\twidth (count (first b))\n\t\t\t\t\t]\n\t\t\t\t\t(filter\n\t\t\t\t\t\t#(< 2 (count %))\n\t\t\t\t\t\t(mapcat\n\t\t\t\t\t\t\t(fn [coords]\n\t\t\t\t\t\t\t\t(map\n\t\t\t\t\t\t\t\t\t(partial ray width height coords)\n\t\t\t\t\t\t\t\t\tdirections\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t(empty-cells b)\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t\t(legal-rays [b p]\n\t\t\t\t(let [re (if (= p 'b) #\"^ew+b\" #\"^eb+w\")]\n\t\t\t\t\t(filter\n\t\t\t\t\t\t(comp not nil?)\n\t\t\t\t\t\t(map\n\t\t\t\t\t\t\t(fn [ray]\n\t\t\t\t\t\t\t\t(let [match (re-find re (apply str (map (partial get-in b) ray)))]\n\t\t\t\t\t\t\t\t\t(if (nil? match)\n\t\t\t\t\t\t\t\t\t\tnil\n\t\t\t\t\t\t\t\t\t\t(take (count match) ray)\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t(all-rays b)\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t]\n\t\t(fn [b p]\n\t\t\t(reduce\n\t\t\t\t#(assoc %1 (first %2) (set (butlast (rest %2))))\n\t\t\t\t{}\n\t\t\t\t(legal-rays b p)\n\t\t\t)\n\t\t)\n\t)\n)", "problem": 124, "user": "507eddf4e4b06ce648bcdbfa"}, {"code": "(fn [board color]\n    (let [antagonist ({'w 'b 'b 'w} color)\n          width (count board)\n          rows (map-indexed (fn [y v] (map-indexed #(vector [y %1] %2) v)) board)\n          columns (apply map (fn [x & coll] (map-indexed #(vector [%1 x] %2) coll))\n                         (iterate inc 0) board)\n          diagonal-from (fn [step-x step-y coord]\n                          (->> coord\n                               (iterate (fn [[a b]] [(step-x a) (step-y b)]))\n                               (map #(vector % (get-in board %)))\n                               (take-while second)))\n          diagonals (concat (for [i (range 0 (dec (count board)))\n                                  j (if (= i 0) (range 0 (dec (count board))) [0])]\n                              (diagonal-from inc inc [i j]))\n                            (for [i (range 1 (count board))\n                                  j (if (= i (dec (count board))) (range 0 (dec (count board))) [0])]\n                              (diagonal-from dec inc [i j])))\n          play (fn [coll]\n                 (for [\n                       [[[a-coord a-color] :as a] [[_ b-color] :as b] [[c-coord c-color] :as c]]\n                       (partition 3 1 (partition-by second coll))\n                       :when (and (= antagonist b-color)\n                                  (not= a-color c-color)\n                                  (#{a-color c-color} 'e))]\n                   [(if (= 'e a-color) a-coord c-coord) (set (map first b))]))\n          plays #(into {} (mapcat play %))]\n      (merge-with into (plays rows) (plays columns) (plays diagonals))))", "problem": 124, "user": "507056b8e4b07bd6ad9b9f29"}, {"code": "(fn [board p]\n  (let [directions\n        (for [x (range -1 2) y (range -1 2)\n              :when (not (= 0 x y))]\n          [x y])\n        crawl\n          (fn [[sx sy :as s]]\n            (iterate\n              (fn [[x y]] (vector (+ x sx) (+ y sy)))\n              s))\n        lines-from\n          (fn [c]\n            (for [d directions]\n              (take-while\n                (fn [[x y]]\n                  (and (< -1 x (count (first board)))\n                       (< -1 y (count board))))\n                (map\n                  (fn [[cx cy] [x y]] (vector (+ cx x) (+ cy y)))\n                  (repeat c) (crawl d)))))]\n    (into {}\n      (mapcat\n        #(for [l (lines-from %)\n               :let [firstp (get-in board (first l))\n                     lastp  (get-in board (last l))]\n               :when (and\n                       (> (count l) 1)\n                       (= 'e lastp)\n                       (= (if (= p 'w) 'b 'w) firstp))]\n           (vector (last l) (set (butlast l))))\n        (filter\n          #(= p (get-in board %))\n          (for [y (range 4) x (range 4)] [x y])))\n      )))", "problem": 124, "user": "504c8165e4b09724c857af31"}, {"code": "(fn [b c]\n  (let [o ({'w 'b 'b 'w} c)\n        d (for [x (range -1 2) y (range -1 2)] [x y])]\n    (letfn [(f [px py dx dy]\n              (let [nx (+ px dx)\n                    ny (+ py dy)\n                    elem (get-in b [nx ny])]\n                (cond\n                 (= elem c) [[nx ny]]\n                 (or (= elem nil) (= elem 'e)) [:FAIL]\n                 (= elem o) (concat [[nx ny]] (f nx ny dx dy)))))]\n      (apply hash-map\n             (mapcat (fn [[k v]] [k (set (drop-last v))])\n                     (filter (fn [e] (and (> (count (second e)) 1) (not= :FAIL (last (second e)))))\n                             (for [x (range 4) y (range 4)\n                                   [dx dy] d\n                                   :when (= 'e (get-in b [x y]))]\n                               [[x y] (f x y dx dy)])))))))", "problem": 124, "user": "5097b556e4b00ad8bab4e970"}, {"code": "(fn [b p]\n  (let [empties (mapcat (fn [index a] (for [inner-index (range (count a))\n                                        :when (= 'e (nth a inner-index))]\n                                        [index inner-index])) (range) b)\n        changes (for [f [identity inc dec] l [identity inc dec]\n                     :when (not= f l identity)]\n                    (fn [k] (mapv #(%1 %2) [f l] k)))\n        line (fn [f k]\n                (loop [s (f k) r #{}]\n                  (cond (contains? #{'e nil} (get-in b s)) #{}\n                        (= (get-in b s) p) r\n                        :else (recur (f s) (conj r s)))))]    \n    (into {} (for [c changes e empties :let [s (line c e)] :when (not-empty s)]\n      [e s]))))", "problem": 124, "user": "507fbd77e4b089ade05efbd3"}, {"code": "(fn get-moves [board color]\n  (let [open? #(= 'e %)\n\t\t  size (count board)\n\t\t  other-color (get '{b w, w b} color)\n\t\t  directions [[0 1] [0 -1] [1 0] [1 1] [1 -1] [-1 0] [-1 1] [-1 -1]]\n\t\t  value? (complement empty?)\n\t\t  get-line (fn [start dir] \n\t\t  (loop [current (map + start dir) res []]\n\t\t\t\t(if (every? true? (map < [-1 -1] current [size size]))\n\t\t\t\t\t(recur (map + current dir) (conj res current))\n\t\t\t\t\tres\n\t\t\t\t)\n\t\t  ))\n\t\t  check-line (fn [line line-pieces]\n\t\t\t(loop [left (rest line-pieces) taken [(first line-pieces)]]\n\t\t\t\t(cond (empty? left) nil\n\t\t\t\t\t  (= color (first left)) (when (every? true? (map #(= other-color %) taken)) (take (count taken) line))\n\t\t\t\t\t  :else (recur (rest left) (conj taken (first left)))\n\t\t\t\t)\n\t\t\t)\n\t\t  )\n\t\t  check-for-swapped (fn [pos]\n\t\t\t(into #{} (apply concat (for [d directions :let [line (get-line pos d)] \n\t\t\t\t  :when (value? line)\n\t\t\t\t  :let [line-pieces (map #(get-in board %) line) checked (check-line line line-pieces)]\n\t\t\t\t  :when (value? checked)]\n\t\t\t\t  checked\n\t\t\t)))\n\t\t  )]\n\t\t(into {}\t  \n\t\t(for [x (range 0 size) y (range 0 size) :let [pos [x y]] \n\t\t\t  :when (open? (get-in board pos))\n\t\t\t  :let [swapped (check-for-swapped pos)]\n\t\t\t  :when (value? swapped)]\n\t\t\t[pos swapped]\n\t\t)\n\t\t)\n\t)\n)", "problem": 124, "user": "50588af1e4b06522596eba7d"}, {"code": "(fn [s e]\n  (letfn [(reversi [s] (cond\n            (= '(o x x o) s) [1 2]\n            (= '(o x o) (rest s)) [2]\n            (= '(o x o) (take 3 s)) [1]))\n          (tr [s e] (vec (map (fn [v] (vec (map #(if (= % 'e ) 'e (if (= % e) 'o 'x)) v))) s)))\n          (m [v f] (when-let [s (reversi v)] (map f s)))\n          (l [s v] (let [[x y] v\n                         s (assoc-in s v 'o)\n                         q (set (concat\n                             (m (s x) #(vector x %))\n                             (m ((vec (apply map vector s)) y) #(vector % y))\n                             (let [[[a _ _ b] [_ c d _] [_ e f _] [g _ _ h]] s]\n                               (if (= x y) (m [a c f h] #(vector % %))\n                                 (if (= 3 (+ x y)) (m [b d e g] #(vector % (- 3 %))))))))]\n            (if-not (empty? q) q)))]\n  (into {} (let [s (tr s e) r (range 4)]\n             (for [x r y r\n                   :let [v [x y]\n                         r (if (= 'e (get-in s v)) (l s v))]\n                   :when (if-not (empty? r) r)]\n               [v r])))))", "problem": 124, "user": "4fdb02aae4b05e33b9224f56"}, {"code": "(fn [board player]\n    (let [y-max (dec (count board))\n          x-max (dec (count (first board)))\n          \n          other {'w 'b, 'b 'w}\n          valid-pos? (fn [[y x]]\n                       (and (<= y y-max)\n                            (>= y 0)\n                            (<= x x-max)\n                            (>= x 0)))\n          lines (fn [i j]\n                  (for [x-diff [-1 0 1]\n                        y-diff [-1 0 1]\n                        :when (not= y-diff x-diff 0)]\n                    (drop 1\n                          (take-while\n                           valid-pos?\n                           (iterate (fn [[y x]]\n                                      [(+ y y-diff) (+ x x-diff)])\n                                    [i j])))))\n\n          move (fn [l]\n                 (let [others (take-while #(= (other player)\n                                             (get-in board %))\n                                          l)\n                       move (first (drop-while #(= (other player)\n                                                  (get-in board %))\n                                               l))\n                       ]\n                   (if (or (empty? others)\n                           (nil? move))\n                     nil\n                     [move (set others)])))\n                       \n          \n          ]\n      (apply hash-map\n             (reduce into \n                     (reduce into\n                             (for [i (range (count board))\n                                   j (range (count (first board)))\n                    :when (= (get-in board [i j]) player)\n                                   ]\n                               (remove nil? (map move\n                                                 (lines i j)))))))))", "problem": 124, "user": "4daea889edd6309eace4d15b"}, {"code": "(fn analyze-reversi [board p]\n  (letfn [(move-y-towards [x y]\n                          (if (> y x) (dec y) (if (< y x) (inc y) y)))\n          (move-towards [& positions]\n                        (apply map move-y-towards positions))\n          (positions-between [pos1 pos2 positions]\n                             (let [next-pos (move-towards pos1 pos2)]\n                               (if (= next-pos pos1)\n                                 positions\n                                 (recur pos1 next-pos (conj positions next-pos)))))]\n    (let [pos-map\n          (reduce (fn [m [k v]]\n                    (assoc m k (conj (get m k #{}) v)))\n                  {}\n                  (apply concat\n                         (map-indexed (fn [row-idx row]\n                                        (map-indexed (fn [col-idx piece]\n                                                       [piece [row-idx col-idx]])\n                                                     row))\n                                      board)))\n          e-positions  (pos-map 'e)\n          p-positions  (pos-map p)\n          op-positions (pos-map ({'w 'b 'b 'w} p))]\n      (into {}\n            (apply concat (map (fn [[p-i p-j :as pos]]\n                                 ;; Find the candidate empties for this pos\n                                 (filter (complement false?)\n                                         (map (fn [[e-i e-j :as e-pos]]\n                                                (and\n                                                  (or (= p-i e-i) ;; same row\n                                                      (= p-j e-j) ;; same col\n                                                      (= (Math/abs (- p-i e-i)) ;; same diag\n                                                         (Math/abs (- p-j e-j))))\n                                                  ;; If there's nothing but opponent positions\n                                                  ;; between us and the empty spot...\n                                                  (let [positions (positions-between pos e-pos '())]\n                                                    (and (not (empty? positions))\n                                                         (every? op-positions positions)\n                                                         [e-pos (into #{} positions)]))))\n                                              e-positions)))\n                               p-positions))))))", "problem": 124, "user": "50812debe4b01a93d3f38e4c"}, {"code": "(fn [board colour]\n    (let\n        [\n         rows (set (range (count board)))\n         cols (set (range (count (first board))))\n         vec-fn (fn [f] #(vec (map f %2 %1))) ;; oops cos of sub need args that way round\n         vec-add (vec-fn +)\n         vec-sub (vec-fn -)\n         all-coords (for [ row rows col cols] [row col])\n         in-range? #(and (rows (first %)) (cols (last %)))\n         diagonal-foo (fn [next-fn coord]\n                    (->> coord\n                         (iterate #(next-fn %))\n                         (take-while in-range?)))\n         diagonal (fn [direction coord]\n                    (set\n                     (concat\n                      (reverse (take 30 (diagonal-foo #(vec-sub direction %) coord)))\n                      (diagonal-foo #(vec-add direction %) coord))))\n         diagonal-left (partial diagonal [-1 1])\n         diagonal-right (partial diagonal [1 1])\n         aligned-rows (fn [[current-row current-col :as coord]]\n                        (vector\n                         (for [ row rows] [row current-col])\n                         (for [ col cols] [current-row col])\n                         (diagonal-left coord)\n                         (diagonal-right coord)))\n         all-locations (->> all-coords\n                            (group-by #(get-in board %))\n                            (reduce #(assoc %1 (key %2) (set (val %2))) {}))\n         opposite (if (= colour 'w) 'b 'w)\n         valid-row? (fn [board row]\n                      (let [state\n                            (->> row\n                                 (sort)\n                                 (map #(get-in board %))\n                                 (partition-by identity)\n                                 (map first)\n                                 (remove #{'e}))]\n                        (= state [colour opposite colour])))\n         valid-placement? (fn [ position]\n                            (let [new-state (assoc-in board position colour)]\n                              (some\n                               #(valid-row? new-state %)\n                               (aligned-rows position))))\n         candidates (all-locations 'e)\n         valid-moves (filter valid-placement? candidates)\n         turned-positions-on-row (fn [board row]\n                                   (let [freq \n                                         (frequencies (map #(get-in board %) row))]\n                                     (if (>= (freq colour) 2)\n                                       (filter #(= opposite (get-in board %)) row)\n                                       [])))\n         turned-positions (fn [position]\n                            (set\n                             (mapcat #(turned-positions-on-row (assoc-in board position colour) %)\n                                     (aligned-rows position))))\n         ]\n      (zipmap valid-moves (map turned-positions valid-moves))\n))", "problem": 124, "user": "4e6f578c535d5021c1a8961b"}, {"code": "(fn [table player]\n  (let [ofs [-1 1 0] rang [0 1 2 3] other {'w 'b, 'b 'w}\n\t      val-at \n       (fn [val]\n\t      (fn [ yx ]\n\t        (= (reduce (fn [s i] (when (and (>= i 0) (> (count s) i)) (nth s i))) table yx) val)))\n      ]\n      (reduce conj {} \n          (for [ox ofs, oy ofs :when (not= ox oy 0)\n                ex rang, ey rang :when ((val-at 'e) [ex ey])\n                :let [oxy [ox oy] exy [ex ey]]\n                :let [go (take-while (complement (val-at nil))\n                                     (next (iterate (partial map + oxy) exy)))] \n                :let [[some more] (map seq (split-with (val-at (other player)) go))]\n                :when (and some more) \n                :when ((val-at player) (first more))] [exy (set some)])\n              )\n    ))", "problem": 124, "user": "50901b2ee4b0ea685a20f774"}, {"code": "(fn [b p]\n  (let [e? (fn [[r c]] (= 'e (get-in b [r c])))\n        \n        me? (fn [[r c]] (= p (get-in b [r c])))\n\n        get-you? (fn []\n                  (let [o (if (= p 'w) 'b 'w)]\n                    (fn [[r c]] (= o (get-in b [r c])))))\n        you? (get-you?) \n\n        ok1? (fn [[r c] x] (or (= x [r c]) (you? x)))\n        ok2? (fn [s f] (and (> (count s) 1) (e? (f (last s)))))\n\n        dirs [(fn [[r c]] [(dec r) (dec c)]) (fn [[r c]] [(dec r) c])\n              (fn [[r c]] [(dec r) (inc c)]) (fn [[r c]] [r  (dec c)])\n              (fn [[r c]] [r  (inc c)]) (fn [[r c]] [(inc r) (dec c)])\n              (fn [[r c]] [(inc r) c]) (fn [[r c]] [(inc r) (inc c)])]\n        \n        paths\n        (fn [[r c]]\n          (map (fn [f] (take-while (partial ok1? [r c]) (iterate f [r c]))) dirs))]\n   (->>\n    (for [r (range 4) c (range 4) :when (me? [r c]) :let [ps (paths [r c])]]\n       (mapcat (fn [s f] (when (ok2? s f) [(f (last s)) (set (rest s))])) ps dirs))\n    (apply concat)\n    (apply hash-map))))", "problem": 124, "user": "50783762e4b0fc74642bff67"}, {"code": "(fn [m p1]\n    (let [p2 ({'w 'b 'b 'w} p1)\n          n (count m)\n          ds (rest (for [a [0 1 -1], b [0 1 -1]] [a b]))\n          ib (fn [[i j]] (and (>= i 0) (>= j 0) (< i n) (< j n)))\n          v+ (fn [[a b] [c d]] [(+ a c) (+ b d)])\n          abl (fn [v d] \n                (take-while \n                  #(and (ib %) (= p2 (get-in m %))) \n                  (iterate #(v+ d %) (v+ d v))))\n          cline (fn [v d]\n                  (let [line (abl v d)]\n                    (when (and (seq line) (= p1 (get-in m (v+ d (last line)))))\n                      line)))]\n      (into \n        {}\n        (remove \n          (comp empty? second)\n          (for [i (range n),\n                j (range n)]\n            (when (= 'e (get-in m [i j]))\n              (let [b (remove empty? (map #(cline [i j] %) ds))]\n                [[i j] (set (apply concat b))])))))))", "problem": 124, "user": "4f08b15b535dcb61093f6c40"}, {"code": "(fn [board hand]\n  (let [empty-slots (for [x (range 4) y (range 4)\n                         :let [p [y x]]\n                         :when (= (get-in board p) 'e)] p)\n        other-hand (if (= hand 'w) 'b 'w)]\n    (letfn [(on-board-p [[y x]] (and (<= 0 x 3) (<= 0 y 3)))\n            (get-flipped-list [[y x :as pos] [oy ox :as off] result]\n              (cond\n                (not (on-board-p pos)) ()\n                (= (get-in board pos) 'e) ()\n                (= (get-in board pos) hand) result\n                :else (recur [(+ y oy) (+ x ox)] off (cons pos result))))]\n       (reduce (fn [last-result [y x :as pos]]\n                 (let [effect(set (mapcat \n                                    (fn [[oy ox :as off]] \n                                      (get-flipped-list [(+ y oy) (+ x ox)]  off ()))\n                                    '([1 0] [-1 0] [0 1] [0 -1]\n                                      [1 1] [-1 -1] [1 -1] [-1 1])))]\n                   (if (empty? effect) last-result\n                       (assoc last-result pos effect)))) {} empty-slots))))", "problem": 124, "user": "4f474f43e4b0d56e7bb92bb7"}, {"code": "(fn [board player]\n  (letfn [(at [point] (get-in board point))\n          (ray [point dir]\n            (iterate (fn [p] (vec (map + p dir))) point))\n          (line [point dir]\n            (take-while (fn [[_ a]] (not (nil? a)))\n                        (map (fn [p] [p (at p)]) (drop 1 (ray point dir)))))\n          (players [point dir]\n            (take-while (fn [[_ a]] (not= 'e a)) (line point dir)))\n          (captures [point dir]\n            (let [[taken surrounding]\n                  (split-with (fn [[_ a]] (not= player a)) (players point dir))]\n              (when (and (seq taken) (seq surrounding))\n                (map first taken))))\n          ]\n    (let [spaces (filter #(= 'e (at %)) (for [r (range (count board))\n                                              c (range (count board))]\n                                          [r c]))\n          offs [-1 0 1]\n          dirs (for [r offs\n                     c offs\n                     :when (some #{-1 1} [r c])]\n                 [r c])\n          capsets (for [s spaces\n                        d dirs]\n                    {s (set (captures s d))})\n          caphash (apply (partial merge-with into) capsets)]\n      (into {} (remove (fn [[k v]] (empty? v)) caphash)))))", "problem": 124, "user": "4ffc10aae4b0678c553fc3d6"}, {"code": "(fn reversi [board color]\n  (let [paths [[[0 0] [0 1] [0 2] [0 3]][[1 0] [1 1] [1 2] [1 3]][[2 0] [2 1] [2 2] [2 3]][[3 0] [3 1] [3 2] [3 3]][[2 0] [1 1] [0 2]][[3 0] [2 1] [1 2] [0 3]][[3 1] [2 2] [1 3]][[0 0] [1 0] [2 0] [3 0]][[0 1] [1 1] [2 1] [3 1]][[0 2] [1 2] [2 2] [3 2]][[0 3] [1 3] [2 3] [3 3]][[0 1] [1 2] [2 3]][[0 0] [1 1] [2 2] [3 3]][[1 0] [2 1] [3 2]][[0 3] [0 2] [0 1] [0 0]][[1 3] [1 2] [1 1] [1 0]][[2 3] [2 2] [2 1] [2 0]][[3 3] [3 2] [3 1] [3 0]][[0 2] [1 1] [2 0]][[0 3] [1 2] [2 1] [3 0]][[1 3] [2 2] [3 1]][[3 0] [2 0] [1 0] [0 0]][[3 1] [2 1] [1 1] [0 1]][[3 2] [2 2] [1 2] [0 2]][[3 3] [2 3] [1 3] [0 3]][[2 3] [1 2] [0 1]][[3 3] [2 2] [1 1] [0 0]][[3 2] [2 1] [1 0]]]\n        patterns {'w {['w 'b 'e 'w] [2 1]['w 'b 'e 'b] [2 1]['w 'b 'e 'e] [2 1]['w 'b 'b 'e] [3 1 2]['w 'w 'b 'e] [3 2]['b 'w 'b 'e] [3 2]['e 'w 'b 'e] [3 2]}\n                  'b {['b 'w 'e 'b] [2 1]['b 'w 'e 'w] [2 1]['b 'w 'e 'e] [2 1]['b 'w 'w 'e] [3 1 2]['b 'b 'w 'e] [3 2]['w 'b 'w 'e] [3 2]['e 'b 'w 'e] [3 2]}}]\n    (into {} (filter identity (map (fn [path] (when-let [solutions ((patterns color) (map #(get-in board %) path))] \n                                                {(path (first solutions)) (into #{} (map #(path %) (rest solutions)))})) paths)))))", "problem": 124, "user": "50ef9a7ae4b0bdaecbb47d9e"}, {"code": "(fn [deck color]\n  (letfn [(invert [c]\n                  (cond (= c 'b) 'w\n                        (= c 'w) 'b\n                        :else 'e))\n          (get-iter [f init]\n                    (rest (iterate f init)))\n          (get-line [[row col] [row-f col-f]]\n                    (let [row-iter (get-iter row-f row)\n                          col-iter (get-iter col-f col)]\n                      (map vector row-iter col-iter)))\n          (process-line [line color deck]\n                        (let [inv-color (invert color)]\n                          (split-with #(= (get-in deck %) inv-color) line)))\n          (get-positions [deck color]\n                         (for [row (range (count deck))\n                               col (range (count (first deck)))\n                               :let [pos [row col]]\n                               :when (= color (get-in deck pos))]\n                           pos))\n          (process-deck [deck color]\n                        (let [fs [inc dec identity]\n                              step-fs (for [x fs y fs :when (not= identity x y)] [x y])]\n                          (for [pos (get-positions deck color)\n                                fs step-fs\n                                :let [res (process-line (get-line pos fs) color deck)\n                                      stop-pos (first (second res))]\n                                :when (and\n                                        (pos? (count (first res)))\n                                        (= 'e (get-in deck stop-pos)))]\n                            [stop-pos (set (first res))])))]\n      (into {} (process-deck deck color))))", "problem": 124, "user": "5003ee7de4b0678c553fc446"}, {"code": "(fn [board color]\n  (letfn [(place [j i]\n            (set (apply concat (for [dj [-1 0 1]\n                                     di [-1 0 1]\n                                     :when (not= 0 dj di)]\n                                 (line-to-flip [(+ j dj) (+ i di)] [dj di] [])))))\n          (line-to-flip [[j i] [dj di] line]\n            (let [c (get-in board [j i])]\n              (cond (= c color) line\n                    (= c 'e) nil\n                    (nil? c) nil\n                    :else (recur [(+ j dj) (+ i di)] [dj di] (conj line [j i])))))]\n    (apply hash-map (apply concat (filter (fn [[_ s]] (not-empty s))\n                                          (for [j (range 4)\n                                                i (range 4)\n                                                :when (= 'e (get-in board [j i]))]\n                                            [[j i] (place j i)]))))))", "problem": 124, "user": "510acd6ee4b078ea719210f4"}, {"code": "(fn final [matrix me]\n  (letfn [(mat-to-map [mat]\n            (into {} (reduce concat  (for [i (range (count mat))]\n                                       (for [j (range (count (mat 0)))]\n                                         [[i j] ((mat i) j)]\n                                         )))))\n          (get-all [mp key]\n            (filter #(= key (second %)) \n                    (seq mp)))\n          (trv [mp x1 y1 x2 y2 fx fy op]\n            (let [col (map #(vector % (mp %)) \n                           (rest (take-while #(not= % [x2 y2]) (map vector (iterate fx x1) (iterate fy y1)))))]\n              (if (and (every? #(= op (second %)) col)\n                       (not (empty? col)))\n                col\n                nil)))\n          (met-cell [c]\n            (+ (first (first c)) (* 2 (second (first c)))))\n          (min-cell [c1 c2]\n            (let [m1 (met-cell c1)\n                  m2 (met-cell c2)]\n              (if (< m1 m2)\n                c1\n                c2)))\n          (max-cell [c1 c2]\n            (if (= c1 (min-cell c2 c1))\n              c2 \n              c1))\n          (opponent [me]\n            (if (= me 'w) 'b 'w))\n          (trav [mp from to op]\n            \"Return collection of opponent staff if is possible\"\n            (let [w (min-cell from to)\n                  e (max-cell from to)\n                  x1 (first (first w))\n                  y1 (second (first w))\n                  x2 (first (first e))\n                  y2 (second (first e))\n                  colection (cond \n                              (= x1 x2) (trv mp x1 y1 x2 y2 identity inc op)\n                              (= y1 y2) (trv mp x1 y1 x2 y2 inc identity op)\n                              (= (- x1 y1) (- x2 y2)) (trv mp x1 y1 x2 y2 inc inc op)\n                              (= (+ x1 y1) (+ x2 y2)) (trv mp x1 y1 x2 y2 dec inc op)\n                              :else nil)]\n              (if (empty? colection)\n\t\t\t      :empty\n\t\t\t      [(first to) (into #{} (map first colection))]\n\t\t\t      )))\n          ]\n         (let [mapa (mat-to-map matrix)\n        emptys (get-all mapa 'e)\n        mines  (get-all mapa me)\n        op (opponent me)]\n           (into {} \n                 (filter #(not= % :empty) \n                         (reduce concat \n                                 (for [from mines]\n                                   (for [to emptys]\n                                     (trav mapa from to op)))))))))", "problem": 124, "user": "50e87427e4b0ebbe794eb7e8"}, {"code": "(fn [b s]\n  (let [v (filter #(not= 0 (% 0) (% 1)) (for [i [-1 0 1] j [-1 0 1]] [i j]))\n        l (fn [x y v] (let [w (map (fn [[p q]] [[q p] ((b q) p)]) \n                                      (take-while (fn [[p q]] (and (>= p 0) (>= q 0) (< p 4) (< q 4)))\n                                                  (map #(vector (+ x (* % (v 0))) (+ y (* % (v 1)))) \n                                                       (range))))] [(vec (map first w)) (apply str (map second w))]))\n        u (fn [x y] (map (partial l x y) v))\n        p {'w #\"e((b)+)w.*\" 'b #\"e((w)+)b.*\"}\n        m (fn [x y] (mapcat #(let [[w r] (l x y %) n (re-matches (p s) r)]\n                        (if n (subvec w 1 (+ (count (n 1)) 1)) [])) v))]\n    (into {} (for [x (range 4) y (range 4) :let [n (m x y)] :when (not (empty? n))]\n      [[y x] (set n)]))))", "problem": 124, "user": "50fbdacfe4b0d10d794c19f0"}, {"code": "(fn analyze-reversi [board side]\n  (let [board-points (let [s (count board)]\n                        (filter #(= 'e (get-in board %))\n                                (map vec \n                                     (for [x (range s)\n                                           y (range (count (first board)))]\n                                       [x y]))))\n        other-side (if (= side 'b) 'w 'b)\n        neighbor (fn neighbors [[x y]]\n                    (for [dx [-1 0 1]\n                          dy [-1 0 1]\n                          :when (not= dx dy 0)]\n                      [(+ x dx) (+ y dy)]))\n        other-side? (fn [point]\n                      (if (= (get-in board point) other-side)\n                        true\n                        false))\n        mos (fn [x]\n              (filter other-side? x))\n        other-neighbor (map mos (map neighbor board-points))\n        inter (filter #(not= [] (second %)) (partition 2 (interleave board-points other-neighbor)))\n        possible (fn [[p s]]\n                   (loop [s s\n                          r {}]\n                     (if (empty? s)\n                       r\n                       (let [mr (loop [a (first s)\n                                     turn #{a}]\n                                (let [d [(- (first (first s)) (first p)) (- (last (first s)) (last p))]\n                                      n [(+ (first d) (first a)) (+ (last d) (last a))]\n                                      bn (get-in board n)]\n                                  (cond\n                                   (= bn side) turn\n                                   (= bn other-side) (recur n (conj turn n))\n                                   (or (= bn nil) (= bn 'e)) false)))]\n                         (if mr\n                           (recur (rest s) (assoc r p mr))\n                           (recur (rest s) r))))))\n        ]\n    (apply conj (map possible inter))))", "problem": 124, "user": "5123ac8ee4b061b4c6f0e0b1"}, {"code": "(fn [board player]\n  (let [opponent (if (= player 'w) 'b 'w)\n        get-empty-spots (fn [board]\n                          (remove nil? \n                                  (reduce concat \n                                          (map-indexed \n                                            (fn [x row] (map-indexed (fn [y c] (if (= c 'e) [x y])) row))\n                                            board))))\n        convert-board (fn [board]\n                        (vec (map-indexed \n                               (fn [x row]\n                                 (vec (map-indexed \n                                        (fn [y c] (if (= c opponent) [x y] c))\n                                        row)))\n                               board))) \n        get-lines-for-move (fn [board [x y]]\n                             (let [dimension (count board)\n                                   new-board (assoc-in board [x y] player)\n                                   get-diag (fn [b x y op]\n                                              (let [c (op x y)] \n                                                (for [i (range dimension) j (range dimension) :when (= (op i j) c)] (get-in b [i j]))))]\n                               (list\n                                 (nth new-board x)\n                                 (nth (apply map vector new-board) y)\n                                 (get-diag new-board x y +)\n                                 (get-diag new-board x y -))))\n        get-reversed (fn [section]\n                       (let [reversed (-> section rest drop-last)] \n                         (if (and (= player (first section) (last section))\n                                  (every? coll? reversed))\n                           reversed)))\n        get-reversed-for-line (fn [line]\n                                (let [l (count line)\n                                      sections (mapcat #(partition % 1 line) (range l 2 -1))]\n                                  (remove nil? (mapcat get-reversed sections))))\n        get-reversed-for-move (fn [board coord]\n                                (let [lines (get-lines-for-move board coord)\n                                      clean-up (fn [lines p] (remove #(not-any? p %) lines))\n                                      cleaned-lines (clean-up lines coll?)]\n                                  (apply hash-set (mapcat get-reversed-for-line cleaned-lines))))\n        all-moves (get-empty-spots board)\n        new-board (convert-board board)]\n    (apply hash-map \n           (mapcat \n             #(let [reversed (get-reversed-for-move new-board %)]\n                (if (seq reversed) [% reversed])) \n             all-moves))  \n    ))", "problem": 124, "user": "4fbbcf0ce4b081705acca2ee"}, {"code": "(fn moves\n  [board piece]\n  (letfn [(pieces [board color]\n                  (for [row (range (count board))\n                        column (range (count (board row)))\n                        :when (= (get-in board [row column]) color)]\n                    [row column]))\n          (moves\n            ([[y x] board color] (moves y x board color))\n            ([y x board color]  \n                (reduce #(let [taken-pieces (moves %2 y x board color #{})]\n                           (if taken-pieces\n                             (if (nil? %) taken-pieces (merge-with hash-set % taken-pieces))\n                             %)) nil [[-1 -1] [-1 0] [-1 1]\n                                      [0  -1]        [0  1]\n                                      [1  -1] [1  0] [1  1]]))\n            ([dir y x board color opponents] \n              (let [c (list (+ (first dir) y) (+ (last dir) x))\n                    p (get-in board c)] \n                (cond (= 'e p) (if (empty? opponents) nil (hash-map c opponents))\n                  (= color p) (moves dir (first c) (last c) board color (conj opponents c))\n                  :else nil ))))]\n    (loop [coords (pieces board piece)\n           results {}]\n      (if (empty? coords)\n        results\n        (let [coord (first coords)\n              legalmoves (moves coord board (if (= piece 'w) 'b 'w))] \n          (if legalmoves\n            (recur (rest coords) (merge results legalmoves))\n            (recur (rest coords) results)))))))", "problem": 124, "user": "50e4f4e9e4b049a987753896"}, {"code": "(fn [board sym]\n  (let [offsets\n        [[0 2] [0 3] [0 -3] [0 -2]\n         [2 0] [3 0] [-3 0] [-2 0]\n         [2 2] [3 3] [-2 -2] [-3 -3]\n         [-2 2] [-3 3] [2 -2] [3 -3]]]\n    (letfn [(get-dir [p1 p2]\n              (let [offset (map - p2 p1)]\n                (map #(if (> % 0) 1 (if (< % 0) -1 %)) offset)))\n            (dirs [board position offsets]\n              (distinct (map (partial get-dir position)\n                             (filter #(= 'e (get-in board %)) (map #(vec (map + position %)) offsets)))))\n            (flips [board flips position sym dir]\n              (let [p (vec (map + position dir)) e (get-in board p) flips (cons p flips)]\n                (if (= 'e e)\n                  (if (> (count flips) 1) (assoc {} (first flips) (set (rest flips))))\n                  (if (not= sym e)\n                    (recur board flips p sym dir)))))]\n      (reduce merge\n              (apply concat\n                     (map-indexed\n                       (fn [r row]\n                         (apply concat\n                                (map-indexed\n                                  (fn [c e]\n                                    (if (= sym e)\n                                      (map (partial flips board #{} [r c] sym)\n                                           (dirs board [r c] offsets))))\n                                  row)))\n                       board))))))", "problem": 124, "user": "514721c6e4b0d520409ed392"}, {"code": "(fn [r e o b p]\n    (into {}\n          (for [x r y r :when ({'e 1} (get-in b [x y]))\n                i e j e\n                :let [d (vec (take 4 (iterate #(mapv + % [i j]) [x y])))\n                      v (mapv #(get-in b %) d)]\n                :when ({(o p) 1} (v 1))\n                :when (or ({p 1} (v 2))\n                          (and ({(o p) 1} (v 2))\n                               ({p 1} (v 3))))]\n            [[x y] (set [(d 1) (d ({p 1 (o p) 2} (v 2)))])])))\n  [0 1 2 3]\n  [-1 0 1]\n  {'w 'b 'b 'w}", "problem": 124, "user": "4ff67852e4b0678c553fc37e"}, {"code": "(fn [[& rows] my-color]\n  (let [dirs (disj (set (for [y (range -1 2)\n                              x (range -1 2)]\n                          [y x]))\n                   [0 0])\n        all-slots (apply merge\n                         (mapcat\n                          (fn [y row]\n                            (map-indexed\n                             (fn [x piece]\n                               {[y x] (cond (= piece 'e) :e\n                                            (= piece my-color) :mine\n                                            :else :yours)})\n                             row))\n                          (range) rows))\n        move (fn [[dy dx] [[y x] piece]]\n               (let [yx [(+ y dy) (+ x dx)]]\n                 [yx (all-slots yx)]))\n        find-paths\n        (fn [[start-yx _ :as start-slot]]      \n          (remove #(< (count %) 2)\n                  (map (fn [dir]\n                         (loop [path [start-yx]\n                                slots (rest (iterate (partial move dir) start-slot))]\n                           (let [[yx piece] (first slots)]\n                             (case piece\n                               :mine path\n                               :yours (recur (conj path yx) (rest slots))\n                               []))))\n                       dirs)))\n        empty? #(= :e (second %))\n        paths (mapcat find-paths (filter empty? all-slots))]\n    (apply merge\n           (for [path paths]\n             {(first path) (set (rest path))}))))", "problem": 124, "user": "50d93c53e4b0fd36a4b89223"}, {"code": "(fn [b c]\n\t(let [\n\t\t  f (fn [cs] \n   \t\t\t\t(let [[vf vl] (split-with #(= (if (= c 'w) 'b 'w) (get-in b %)) cs)]\n   \t\t\t\t\t(and (not (empty? vf))\n\t\t\t\t\t     (= 'e (get-in b (first vl)))\n\t\t\t\t\t     {(first vl) (set vf)})\n   \t\t\t\t\t))\n   \t\t  g (fn g [xf x yf y] \n   \t\t \t(lazy-seq (cons [(xf x) (yf y)] \n   \t\t \t\t\t\t\t(g xf (xf x) yf (yf y)))))\n\t\t  ]\n\t(apply merge\n\t\t   (flatten \n\t\t   \t\t(for [x (range 4) y (range 4) :when (= (get-in b [x y]) c)] \n\t  \t\t   \t\t (filter identity \n\t  \t\t   \t\t \t(map f\n\t  \t\t\t   \t\t \t[(g identity x inc y)\n\t  \t\t\t   \t\t \t (g identity x dec y)\n\t  \t\t\t   \t\t \t (g inc x identity y)\n\t  \t\t\t   \t\t \t (g dec x identity y)\n\t  \t\t\t   \t\t \t (g dec x inc y)\n\t  \t\t\t   \t\t \t (g dec x dec y)\n\t  \t\t\t   \t\t \t (g inc x inc y)\n\t  \t\t\t   \t\t \t (g inc x dec y)]))))\t  \n\t\t  )))", "problem": 124, "user": "4f0da4e4535d0136e6c22319"}, {"code": "(fn analyze-reversi [board color]\n    (let [size-x (count board)\n          size-y (count (get board 0))\n          empties\n            (for [x (range (count board))\n              y (range (count (get board x)))\n              :when (= (get-in board [x y]) 'e)]\n            [x y])\n          line (fn [[from-x from-y] [dir-x dir-y]]\n            (for [delta (range 1 (max size-x size-y))\n                  x [(+ from-x (* delta dir-x))]\n                  y [(+ from-y (* delta dir-y))]\n                  content [(get-in board [x y])]\n                  :when content]\n              [content [x y]]))\n          directions (for [x [-1 0 1]\n                           y [-1 0 1]\n                           :when (not (and (= 0 x) (= 0 y)))]\n                       [x y])\n          other (fn [color] (if (= 'b color) 'w 'b))\n          line-captures (fn [line color]\n                          (loop [captures #{}\n                                 line line]\n                            (if (empty? line)\n                              nil\n                              (let [[[c [x y]] & rest-line] line]\n                                (cond\n                                  (= color c) (if (empty? captures) nil captures)\n                                  (= (other color) c) (recur (conj captures [x y]) rest-line)\n                                  :else nil)))))]\n      (into {} (for [e empties\n                     d directions\n                     line [(line e d)]\n                     caps [(line-captures line color)]\n                     :when caps]\n                 [e caps])))\n\n    )", "problem": 124, "user": "5165a235e4b079ad97ec44ac"}, {"code": "(fn [board player]\n  (letfn [(flips [x y xinc yinc collected]\n            (let [newx (+ x xinc) newy (+ y yinc)]\n                 (cond\n                  (or (> newx 3) (> newy 3) (< newx 0) (< newy 0)) nil\n                  (= (get-in board [newx newy]) 'e) nil\n                  (= (get-in board [newx newy]) player) collected\n                  :else (flips newx newy xinc yinc\n                               (conj collected [newx newy])))))]\n    (reduce into {} \n           (for [x (range 4)]\n             (remove nil?\n                     (for [y (range 4)]\n                       (when (= (get-in board [x y]) 'e)\n                         (let [flip-coll \n                               (set (concat\n                                     (flips x y 0 1 [])\n                                     (flips x y 1 1 [])\n                                     (flips x y 1 0 [])\n                                     (flips x y 0 -1 [])\n                                     (flips x y -1 -1 [])\n                                     (flips x y -1 0 [])\n                                     (flips x y -1 1 [])\n                                     (flips x y 1 -1 [])))]\n                           (when (not-empty flip-coll)\n                             {[x y] flip-coll})))))))))", "problem": 124, "user": "512d3304e4b040332b905b2d"}, {"code": "(fn [board mark]\n  (let [transpose (fn [b]\n                    (partition (count b)\n                               (for [i (range (count b))\n                                     j (range (count (first b)))]\n                                 (get-in b [j i]))))\n        candidates (fn [board mark]\n                     (set (for [x (range (count board))\n                                y (range (count (first board)))\n                                :let [cand [x y]]\n                                :when (= (get-in board cand) mark)]\n                            cand)))\n\n        legal? (fn [board s e]\n                 (let [color (get-in board s)\n                       check-row (fn [b r c1 c2]\n                                   (let [small (min c1 c2)\n                                         big (max c1 c2)\n                                         line (drop (inc small) (take big (nth b r)))]\n                                     (and (not (empty? line)) (every? #(and (not= % color) (not= % 'e)) line))))\n                       check-diagnal (fn [x1 y1 xr yr]\n                                       (let [r (map (fn [[xi yi]] (get-in board (vector (+ x1 xi) (+ y1 yi)))) (partition 2 (interleave xr yr)))]\n                                         (and (not (empty? r)) (every? #(and (not= % color) (not= % 'e))\n                                                                       r))))\n                       x1 (first s)\n                       x2 (first e)\n                       y1 (second s)\n                       y2 (second e)\n                       xr (if (> (- x2 x1) 0) (drop 1 (range (- x2 x1))) (sort > (drop 1 (range (- x2 x1) 0))))\n                       yr (if (> (- y2 y1) 0) (drop 1 (range (- y2 y1))) (sort > (drop 1 (range (- y2 y1) 0))))]\n                   (cond (= x1 x2) (check-row board x1 y1 y2)\n                         (= y1 y2) (check-row (transpose board) y1 x1 x2)\n                         (or (= -1 (/ (- x1 x2) (- y1 y2))) (= 1 (/ (- x1 x2) (- y1 y2)))) (check-diagnal x1 y1 xr yr)\n                         :else false)))\n\n        legal-moves (fn [board start]\n                      (set (filter #(legal? board start %) (candidates board 'e))))\n\n        flip-move (fn [s e]\n                    (let [flip-row (fn [r c1 c2]\n                                     (let [small (min c1 c2)\n                                           big (max c1 c2)]\n                                       (set (map #(vector r %) (range (inc small) big)))))\n                          flip-colum (fn [c r1 r2]\n                                       (let [small (min r1 r2)\n                                             big (max r1 r2)]\n                                         (set (map #(vector % c) (range (inc small) big)))))\n                          flip-diagnal (fn [x1 y1 xr yr]\n                                         (set (map (fn [[xi yi]] (vector (+ x1 xi) (+ y1 yi))) (partition 2 (interleave xr yr)))))\n                          x1 (first s)\n                          x2 (first e)\n                          y1 (second s)\n                          y2 (second e)\n                          xr (if (> (- x2 x1) 0) (drop 1 (range (- x2 x1))) (sort > (drop 1 (range (- x2 x1) 0))))\n                          yr (if (> (- y2 y1) 0) (drop 1 (range (- y2 y1))) (sort > (drop 1 (range (- y2 y1) 0))))]\n                      (cond (= x1 x2) (flip-row x1 y1 y2)\n                            (= y1 y2) (flip-colum y1 x1 x2)\n                            :else (flip-diagnal x1 y1 xr yr))))]\n    (into {} (mapcat (fn [start]\n                       (reduce #(assoc % %2 (flip-move start %2)) {} (legal-moves board start)))\n                     (candidates board mark)))))", "problem": 124, "user": "512eb723e4b0b740abc5982b"}, {"code": "(fn [board color]\n  (letfn [(jump-pos [[x1 y1] [x2 y2]]\n            (cond (= x1 x2)\n                  [x1 (if (< y1 y2) (inc y2) (dec y2))]\n                  (= y1 y2)\n                  [(if (< x1 x2) (inc x2) (dec x2)) y1]\n                  :else\n                  [(if (< x1 x2) (inc x2) (dec x2))\n                   (if (< y1 y2) (inc y2) (dec y2))]))]\n    (let [positions (for [i (range (count board))\n                          j (range (count (first board)))]  [i j])\n          pieces (filter #(= color (get-in board %)) positions)\n          neighbor-offsets (for [i (range -1 2) j (range -1 2)] [i j])\n          neighbor-offsets (disj (set neighbor-offsets) [0 0])\n          opp-color (if (= color 'w) 'b 'w)\n          moves\n          (for [p pieces\n                opp (filter #(= opp-color (get-in board %))\n                            (map (partial mapv +) (repeat p) neighbor-offsets))\n                jmp (filter #(#{'e opp-color} (get-in board %))\n                            [(jump-pos p opp)])]\n            (if (= (get-in board jmp) opp-color)\n                         (let [jmp2 (jump-pos opp jmp)]\n                           (when (= (get-in board jmp2) 'e)\n                             [jmp2 [opp jmp]]))\n                         [jmp  [opp]]))]\n      (reduce (fn [d [jmp opp]]\n                (assoc d jmp (apply conj (get d jmp #{}) opp)))\n              {} (filter identity moves)))))", "problem": 124, "user": "519ef784e4b087743fad2198"}, {"code": "(fn [board player] \n  (let [cells (for [x (range 4) y (range 4)] [x y])\n        dirs [[-1 0][-1 1][0 1][1 1][1 0][1 -1][0 -1][-1 -1]]\n        get-line (fn gl [[px py] [dx dy]] \n                   (let [npx (+ px dx) \n                         npy (+ py dy)]\n                     (if (or (< npx 0) (> npx 3) (< npy 0) (> npy 3))\n                       []\n                       (cons [npx npy] (gl [npx npy] [dx dy])))))\n        \n        flip-seq (fn [pos dir] \n                   (let [[line end] (split-with #(not (contains? #{'e player} (get-in board %))) (get-line pos dir))]\n                     (if (= (get-in board (first end)) player)\n                       line\n                       [])))]\n    (apply hash-map (mapcat identity\n                            (remove #(empty? (last %))\n                                    (map\n                                     (fn [cell]\n                                       [cell \n                                        (set (mapcat (partial flip-seq cell) dirs))])\n                                     (filter #(= 'e (get-in board %)) cells)))))\n    ))", "problem": 124, "user": "5034b0e1e4b062bc5d7ae167"}, {"code": "(fn [board piece]\n  (letfn [(step [op-piece start gap result]\n            (let [next-start (mapv #(+ %1 %2) start gap)\n                  next-piece (get-in board next-start)]\n              (if (= next-piece op-piece)\n                (step op-piece next-start gap (conj result next-start))\n                (if (= next-piece 'e)\n                  (if (seq result)\n                    {next-start (set result)}\n                    {})\n                  {}))))]\n    (apply\n      merge\n      (mapcat\n        #(map\n           (fn [gap] (step (if (= piece 'w) 'b 'w) % gap []))\n           [[0 1] [0 -1] [1 0] [-1 0] [1 1] [-1 -1] [1 -1] [-1 1]])\n        (filter #(= piece (get-in board %)) (mapcat #(map (fn [ele] [% ele]) (range 0 4)) (range 0 4)))))))", "problem": 124, "user": "514d7e29e4b019235f6c0587"}, {"code": "(fn analyze-reversi [board player]                                                                                                                                \n  (let [r4 (range 4)                                                                                                                                                \n        move-diagonal #(map inc %)                                                                                                                                  \n        move-diagonal2 #(list (dec (first %)) (inc (last %)))                                                                                                       \n        lines (conj                                                                                                                                                 \n                (for [y r4] (for [x r4] (list y x)))                                                                                                                \n                (take 3 (iterate move-diagonal '(0 1)))                                                                                                             \n                (take 4 (iterate move-diagonal '(0 0)))                                                                                                             \n                (take 3 (iterate move-diagonal2 '(2 0)))                                                                                                            \n                (take 4 (iterate move-diagonal2 '(3 0))))                                                                                                           \n        lines-rotated (concat                                                                                                                                       \n                        lines                                                                                                                                       \n                        (map #(map reverse %) lines))]                                                                                                              \n    (apply array-map (apply concat (filter identity (for [x r4 y r4                                                                                                 \n          :let [v (get-in board [y x])]                                                                                                                             \n          :when (= v 'e)]                                                                                                                                           \n      (let [new-board (assoc-in board [y x] player)                                                                                                                 \n            flips (filter #(not (empty? %)) (map (fn [line]                                                                                                         \n                         (loop [line line                                                                                                                           \n                                first-player nil                                                                                                                    \n                                diff-players-pos []]                                                                                                                \n                           (let [this-player-pos (first line)                                                                                                       \n                                 this-player (if (nil? this-player-pos)                                                                                             \n                                               'e                                                                                                                   \n                                               (get-in new-board this-player-pos))                                                                                  \n                                 reversi? (and (= this-player first-player)                                                                                         \n                                               (not (empty? diff-players-pos)))]                                                                                    \n                             (cond                                                                                                                                  \n                               reversi? diff-players-pos                                                                                                            \n                               (empty? line) []                                                                                                                     \n                               (and first-player (= this-player 'e)) []                                                                                             \n                               :else (let [new-line (rest line)                                                                                                     \n                                     new-first-player (if (and (nil? first-player)                                                                                  \n                                                               (not= this-player 'e))                                                                               \n                                                        this-player                                                                                                 \n                                                        first-player)                                                                                               \n                                     new-diff-players-pos (if (and                                                                                                  \n                                                                first-player                                                                                        \n                                                                (not= first-player                                                                                  \n                                                                      this-player))                                                                                 \n                                                            (conj diff-players-pos                                                                                  \n                                                                  this-player-pos)                                                                                  \n                                                            diff-players-pos)]                                                                                      \n                                 (recur                                                                                                                             \n                                   new-line                                                                                                                         \n                                   new-first-player                                                                                                                 \n                                   new-diff-players-pos)))))) lines-rotated))                                                                                       \n            flip (first flips)                                                                                                                                      \n            good-move (not (empty? flip))]                                                                                                                          \n        (if good-move                                                                                                                                               \n          [[y x] (set flip)]                                                                                                                                        \n          nil))))))))", "problem": 124, "user": "51899891e4b0288ada3dbdab"}, {"code": "(letfn\n  [(flipped-pieces [board [i j] piece]\n     (set\n       (apply concat\n              (for [di [-1 0 1]\n                    dj [-1 0 1]\n                    :when (not= 0 di dj)\n                    :let [flipseq (for [dist (->> board count (range 1))\n                                        :let [fpos [(+ i (* dist di))\n                                                    (+ j (* dist dj))]]]\n                                    [fpos (get-in board fpos)])\n                          [firstp secondp] (distinct (map second flipseq))]\n                    :when (and (not= firstp piece)\n                               (not= firstp 'e)\n                               (= secondp piece))]\n                (map first (take-while #(not= piece (second %)) flipseq))))))\n   (moves [board piece]\n     (apply merge\n            (for [i (-> board count range)\n                  j (-> board first count range)\n                  :when (= 'e (get-in board [i j]))\n                  :let [pieces (flipped-pieces board [i j] piece)]\n                  :when (not (empty? pieces))]\n              {[i j] pieces})))]\n  moves)", "problem": 124, "user": "50b668dde4b08fb537db98f2"}, {"code": "(fn rev [board my-color]\n  (let\n    [enemy-color ('{b w w b} my-color)\n     lookup  (fn [x] (get-in board x))\n     empties (for [r (range 4)\n                   c (range 4)\n                   :when (= 'e (get-in board [r c]))]\n               [r c])\n     directions (for [dr [-1 0 1]\n                      dc [-1 0 1]\n                      :when (not= 0 dr dc)]\n                  [dr dc])\n     make-ray (fn [[r c] [dr dc]]\n                (iterate (fn [[r c]]\n                           [(+ dr r) (+ dc c)])\n                         [r c]))\n     capturable? (fn [[start & ray]]\n                   (let [pieces (map lookup ray)]\n                    (and\n                      (= enemy-color (first pieces)))\n                      (= my-color (first (drop-while #(= enemy-color %) pieces)))))\n     get-pieces (fn [[start & ray]]\n                  (take-while #(= enemy-color (lookup %)) ray))\n     capturable-for (fn [pos]\n                      (->> directions\n                           (map (partial make-ray pos))\n                           (filter capturable?)\n                           (mapcat get-pieces)\n                           set))]\n    (reduce (fn [m pos]\n              (let [captured (capturable-for pos)]\n                (if (not (empty? captured))\n                  (assoc m pos captured)\n                  m)))\n            {}\n            empties)))", "problem": 124, "user": "50217818e4b00bba4502f7a7"}, {"code": "(fn [t z u e b p]\n  (let [q [[-1 -1] [-1  0] [-1  1]\n           [ 0 -1]         [ 0  1]\n           [ 1 -1] [ 1  0] [ 1  1]]\n        g (range 4)\n        r (for [n g\n                m g\n                :let [c (u b [n m])]\n                :when (= c p)]\n            [n m])]\n    (->> (for [o q\n               c r]\n           (for [i (range 1 4)\n                 :let [k (t + c (t * (repeat i) o))\n                       l (u b k)]\n                 :when (and (e #(>= % 0) k)\n                            (e #(< % 4) k)\n                            (not= p l))]\n             k))\n         (z #(> (count %) 1))\n         (t (juxt last (comp set butlast)))\n         (z (fn [[x y]]\n              (and (= 'e (u b x))\n                   (not-any? #{'e} (t #(u b %) y)))))\n         (into {}))))\n\nmap filter get-in every?", "problem": 124, "user": "4e823ed7535db62dc21a62c7"}, {"code": "(fn analysis [z m] (let [\n    h (count z)\n    w (count (first z))\n    !m (if (= 'w m) 'b 'w)]\n    (letfn [\n        (flips-dir [h w dh dw] (let [\n            nh (+ h dh) \n            nw (+ w dw)\n            nz (get-in z [nh nw])]\n            (cond \n                (= m nz)  #{}\n                (= !m nz) (conj (flips-dir nh nw dh dw) [nh nw])\n                true #{nil})))\n        (remove-invalid [x] (if (contains? x nil) #{} x))]\n        (into {} (for [\n            hi (range h) \n            wi (range w)\n            :when (= 'e (get-in z [hi wi]))\n            si [(set (apply concat (for [\n                dhi [-1 0 1] \n                dwi [-1 0 1] \n                :when (not= dhi dwi 0)]\n                (remove-invalid (flips-dir hi wi dhi dwi)))))]\n            :when (seq si)] \n            [[hi wi] si])))))", "problem": 124, "user": "51cbdee1e4b08d8387cbede1"}, {"code": "(fn [b c]\n  (let [m map g get-in e #{} s [-1 0 1]\n        f (fn [v] (reduce clojure.set/union\n                          (m #((fn [v d]\n                                 (loop [r e\n                                        p (m + v d)]\n                                   (condp = (g b p)\n                                     ({'b 'w 'w 'b} c) (recur (conj r p) (m + p d))\n                                     c r\n                                     e))) v %)\n                             (for [y s x s] [y x]))))\n        r [0 1 2 3]\n        o (for [y r x r :when (and (= 'e (g b [y x])) (seq (f [y x])))] [y x])]\n    (zipmap o (m f o))))", "problem": 124, "user": "4fa340b4e4b081705acca18c"}, {"code": "(fn [state m]\n      (let [a [-1 0 1]\n            d (for [x a y a :when (or (not= x 0) (not= y 0))] [y x])\n            add #(apply + %&)]\n        (into {}\n              (for [x (range (count (first state))) y (range (count state))\n                    :let [mov ((fn [p]\n                                 (if (= (get-in state p) 'e)\n                                   (reduce (fn [s dir] ((fn [g points]\n                                                         (let [h (get-in state g 'e)]\n                                               (cond\n                                                            (= h 'e) s\n                                                            (= h m) (set (concat s points))\n                                                            :else (recur (map add g dir) (conj points g)))))\n                                                       (map add p dir) #{})) #{} d))) [y x])]\n                    :when (and mov (not-empty mov))]\n                {[y x] mov}))))", "problem": 124, "user": "4ea5e32a535d7eef308072de"}, {"code": "(fn [b c]\n  (letfn [(at [xy]\n            (get-in b xy))\n\n          (all-xys []\n            (for [x (range (count b)), y (range (count (nth b x)))]\n              [x y]))\n\n          (locate [i]\n            (filter #(= i (at %)) (all-xys)))\n\n          (line [o d]\n            (take-while (comp not nil? at) (iterate #(map + % d) o)))\n\n          (all-lines [o]\n            (->> (for [dx (range -1 2)\n                       dy (range -1 2)\n                       :when (not= [dx dy] [0 0])]\n                   [dx dy])\n                 (map (partial line o))\n                 (map rest)\n                 (filter identity)))\n\n          (flips [l c]\n            (let [pcs (take-while #(not= 'e (at %)) l)\n                  [cs c2s & t] (split-with #(not= c (at %)) pcs)]\n              (if (empty? c2s) [] cs)))]\n\n    (->> (for [e (locate 'e)\n               l (all-lines e)\n               fs (flips l c)]\n           {e #{fs}})\n         (apply merge-with into {}))))", "problem": 124, "user": "51b9d1f0e4b0e871ca49590b"}, {"code": "(fn [b p]\n  (let [flipped (fn [line p f]\n                  (let [o ({'b 'w} p 'b)\n                        [a b c d] line]\n                    (cond\n                     (and (= 'e a) (= o b)   (=  p c)) {(f 0) #{(f 1)}};[e o p _]\n                     (and (=  p a) (= o b)   (= 'e c)) {(f 2) #{(f 1)}};[p o e _]\n                     (and (= 'e a) (= o b c) (=  p d)) {(f 0) #{(f 1) (f 2)}};[e o o p]\n                     (and (=  p a) (= o b c) (= 'e d)) {(f 3) #{(f 1) (f 2)}};[p o o e]\n                     (and (= 'e b) (= o c)   (=  p d)) {(f 1) #{(f 2)}};[_ e o p]\n                     (and (=  p b) (= o c)   (= 'e d)) {(f 3) #{(f 2)}};[_ p o e]\n                     :else {})))\n        cols (apply mapv vector b)\n        f (fn [y] [y (- 3 y)])\n        d1 (map #(get-in b [% %]) (range 4))\n        d2 (map #(get-in b (f %)) (range 4))\n        row-moves (apply merge (map-indexed #(flipped %2 p (fn [x] [% x]))\n                                            b))\n        col-moves (apply merge (map-indexed #(flipped %2 p (fn [y] [y %]))\n                                            cols))\n        d1-moves (flipped d1 p (fn [y] [y y]))\n        d2-moves (flipped d2 p f)]\n    (merge row-moves col-moves d1-moves d2-moves)))", "problem": 124, "user": "4ebaf790535dfed6da9c6d6e"}, {"code": "(fn go [board piece]\n  (let [b (vec (for [[y row] (map-indexed vector board)]\n            (vec (for [[x value] (map-indexed vector row)]\n              {:y y :x x :value value}))))\n        opponent ('{w b, b w} piece)\n        height (count b)\n        width (count (first b))\n        edge-coords (concat (map vector (range height) (repeat 0))\n                            (map vector (repeat 0) (range width)))\n        forwards (concat\n                  b\n                  (apply map vector b)\n                  (for [start edge-coords]\n                    (for [[y x] (iterate (partial map inc) start)\n                          :while (and (< y height) (< x width))]\n                      (get-in b [y x])))\n                  (for [start edge-coords]\n                    (for [[y x] (iterate (fn [[y x]] [(dec y) (inc x)]) start)\n                          :while (and (>= y 0) (< x width))]\n                      (get-in b [y x]))))\n        blocks (concat forwards (map reverse forwards))\n        result (apply merge-with into\n                      (for [block blocks\n                            block [(map-indexed #(assoc %2 :i %1) (concat [{:value 'e}] block [{:value 'e}]))]\n                            end [(first (drop-while #(not= piece (:value %)) (reverse block)))]\n                            [prev curr next] (partition 3 block)\n                            :when  (and end\n                                        (< (:i curr) (:i end))\n                                        (= 'e (:value curr))\n                                        (some #(not= 'e (:value %)) [prev next]))]\n                        {((juxt :y :x) curr)\n                         (->> block\n                              (drop (inc (:i curr)))\n                              (take (- (:i end) (:i curr)))\n                              (filter (comp #{opponent} :value))\n                              (map (juxt :y :x))\n                              set)}))]\n    (select-keys result\n                 (for [[pos flips] result\n                       :when (seq flips)]\n                   pos))))", "problem": 124, "user": "507b7dbee4b09034bfeeb71e"}, {"code": "(fn [ b p ]\n    (let [\n        board-size 4\n        valid-indices (set (range board-size))\n        valid-delta (range -1 2)\n        connexity (disj (set (for [i valid-delta j valid-delta] [i j])) [0 0])\n        -p (if (= p 'w) 'b 'w)\n        e  'e\n        ]\n    (letfn [\n        (move [[x y :as xy] [dx dy :as dxy]] [(+ x dx) (+ y dy)])\n        (positions [b p] (filter (comp not empty?)\n                            (for [i valid-indices j valid-indices]\n                                (if (= p (get-in b [i j])) [i j])))) \n        (rec-direction [rlist rp b xy dxy p]\n               (cond\n                (= -p (get-in b xy)) (recur (conj rlist xy) rp b (move xy dxy) dxy p)\n                (= e (get-in b xy))  [rlist xy ]\n                :else [nil nil]\n               ))\n        (direction [xy dxy] (let [[rlist rp] (rec-direction nil nil b (move xy dxy) dxy p)]\n                                (if (nil? rlist) nil [rp (set rlist) ])))\n        (apply-connexity [pos] (mapcat #(direction pos %1) connexity))\n        ]\n    (reduce #(if(empty? %2) %1 (apply assoc %1 %2)) {} (map apply-connexity (positions b p)))\n    )))", "problem": 124, "user": "51f59607e4b0abb92f97f9d5"}, {"code": "(fn analyze [board piece]\n  (into {}\n        (letfn [(simulate [board x y incx incy target]\n                          (when (and (>= x 0) (>= y 0) (< x (count board)) (< y (count (first board))))\n                            (if (= target (get-in board [x y]))\n                              (concat [[x y]] (simulate board (+ x incx) (+ y incy) incx incy target))\n                              (when (= 'e (get-in board [x y]))\n                                [[x y]]))))]\n          (let [coords (for [x (range 4) y (range 4)] [x y])\n                starting-point (filter #(= piece (get-in board %)) coords)]\n            (filter (comp not nil?)\n                    (for [[sx sy] starting-point incx [-1 0 1] incy [-1 0 1] \n                          :when (or (not= 0 incx) (not= 0 incy)) :when (= piece (get-in board [sx sy]))]\n                      (let [path (simulate board (+ sx incx) (+ sy incy) incx incy ({'w 'b 'b 'w} piece))]\n                        (when (and (>= (count path) 2) (= 'e (get-in board (last path))))\n                          (zipmap [(last path)] [(set (butlast path))])))))))))", "problem": 124, "user": "5054bc87e4b0b1b9d1860eb0"}, {"code": "(fn [board color]\n           (let [enemy-color (if (= 'w color) 'b 'w)]\n             (letfn [(inc-cursor [[x y]] (if (= 3 x) [0 (inc y)] [(inc x) y]))\n                     (direction [move adjacent-enemy]\n                       (let [[my mx] move\n                             [ay ax] adjacent-enemy\n                             minus-x (- mx ax)\n                             minus-y (- my ay)]\n                         [(- minus-y) (- minus-x)]))\n            \n                     (contentious-pieces-coordinates [color]\n                       (loop [cursor [0 0]\n                              acc []]\n                         (if (= [0 4] cursor)\n                           acc\n                           (recur (inc-cursor cursor)\n                                  (if-let [coordinate (when (= (get-in board cursor) color) cursor)]\n                                    (conj acc coordinate)\n                                    acc)))))\n            \n                     (assign-adj-enemies [g] (let [[y x] g\n                                                   possible [[y (inc x)] [(inc y) x]\n                                                             [y (dec x)] [(dec y) x]\n                                                             [(inc y) (inc x)]\n                                                             [(dec y) (dec x)]\n                                                             [(dec y) (inc x)]\n                                                             [(inc y) (dec x)]]\n                   \n                                                   possible (map first (filter #(= enemy-color (second %))\n                                                                               (map (fn [c] [c (get-in board c)]) possible)))]\n\n                                               {:piece g\n                                                :adj-enemies possible}))\n                     \n                     (solution [piece adj]\n                       (let [[dy dx] (direction piece adj)]\n                         (loop [acc [adj]\n                                [y x] adj]\n                           (cond (nil? acc) nil\n                                 (set? (last acc)) acc\n                                 :else (let [[ny nx] [(+ y dy) (+ x dx)]\n                                             nval (get-in board [ny nx])]\n                                         (recur (cond (= enemy-color nval) (conj acc [ny nx])\n                                                      (= color nval) nil\n                                                      (nil? nval) nil\n                                                      :else [[ny nx] (set acc)])\n                                                [ny nx]))))))]\n               \n               (let [valid-pieces (contentious-pieces-coordinates color)\n                     mm (map assign-adj-enemies valid-pieces)\n                     solns (loop [l mm\n                                  acc []]\n                             (if (empty? l)\n                               acc\n                               (let [g (for [a (:adj-enemies (first l))]\n                                         (when-let [b (solution (:piece (first l)) a)] b b))]\n                                 (recur (rest l)\n                                        (into acc g)))))]\n                 (zipmap (remove nil? (map first solns)) (remove nil? (map second solns)))\n                 \n                 ))))", "problem": 124, "user": "50a5b7e9e4b0aa96157e2610"}, {"code": "(fn [b c]\n  (let [at (memoize (fn [[y x]] (first (drop (mod x 5) (first (drop (mod y 5) b))))))\n        f (fn [[y x] [dy dx]] (take-while at\n                                (iterate (partial map + [dy dx]) [y x])))\n        opp (if (= c 'b) 'w 'b)\n        valid (fn [xys] (if-let [s (seq (take-while #(not= c (at %)) xys))]\n                          (if (and\n                                (< (count s) (count xys))\n                                (= 'e (at (first s)))\n                                (seq (rest s))\n                                (apply (partial = opp) (map at (rest s))))\n                            (rest s))))]\n    (into {}\n      (for [j (range 4)\n            i (range 4)\n            :let [m (map\n                      #(f %1 %2)\n                      (repeat [j i])\n                      [[0 1] [0 -1] [1 0] [-1 0] [1 1] [-1 1] [-1 -1] [1 -1]])\n                  t (set (mapcat valid m))]\n            :when (seq t)]\n        [[j i] t]))\n    ))", "problem": 124, "user": "5201572be4b0d7096e99ddbb"}, {"code": "(fn [board color]\n  (let [directions (for [dr [-1 0 1] dc [-1 0 1] :when (not= 0 dr dc)] [dr dc])\n        other-color (if (= color 'w) 'b 'w)\n        all-squares (for [r (range 4) c (range 4)] [r c])\n        empty-squares (reduce #(if (= 'e (get-in board %2)) (conj % %2) %) () all-squares)\n        step (fn [[r c] [dr dc]] [(+ r dr) (+ c dc)])\n        scan (fn [from toward]\n               ; given a starting square and direction, returns the set of\n               ; other-colored squares that could be flipped (or nil if none)\n               (let [sq1 (step from toward)]\n                 (when (= other-color (get-in board sq1))\n                   (loop [sqn (step sq1 toward) others #{sq1}]\n                     (if (= other-color (get-in board sqn))\n                       (recur (step sqn toward) (conj others sqn))\n                       (when (= color (get-in board sqn))\n                         others))))))\n        scan-around (fn [from]\n                      ; given a starting square, scans in all directions to collect the set\n                      ; of other-colored squares that could be flipped (or nil if none)\n                      (let [others (reduce #(if-let [others (scan from %2)] (into % others) %) #{} directions)]\n                        (if (empty? others) nil others)))]\n    (reduce (fn [moves fromsq]\n              (if-let [others (scan-around fromsq)]\n                (assoc moves fromsq others)\n                moves))\n              {} empty-squares)))", "problem": 124, "user": "52015698e4b0d7096e99ddba"}, {"code": "(fn [board piece]\n    (let [brd (->>  board (interpose 'x) flatten vec)\n          op (if (= piece 'w) 'b 'w)\n          lkard [-1 -4 -5 -6 1 4 5 6]\n          cors  (fn [n] [(quot n 5) (mod n 5)])\n          check (fn [bd i ic lst]\n                   (let [x (get bd i)]\n                     (cond\n                      (nil? x) nil\n                      (= x op) (recur bd  (+ ic i) ic (cons i lst))\n                      (= x piece) lst\n                      :else nil)))\n          avail  (keep-indexed (fn [i it]\n                                 (if (and (= it 'e)\n                                          (some #{op}\n                                            (map #(get brd (+ i %)) lkard)))i)) brd)]\n      (reduce (fn [lst n] \n                (let [j  (->>\n                        (map #(check brd (+ n %) % []) lkard)\n                        (filter seq) flatten (map cors) set )]\n\n                  (if (seq j) (assoc lst (cors n) j) lst))) {} avail)))", "problem": 124, "user": "5124619ae4b02c3f2a072ccd"}, {"code": "(fn reversi [board color]\n  (let [opposite-color (if (= color 'w) 'b 'w)] \n      (letfn [(paths [board]\n            (let [n (count board)\n                  is-in? #(and (>= % 0) (< % n))\n                  cell (fn [i j] [[i j] (get-in board [i j])])]\n              (concat\n                (for [i (range n)] (for [j (range n)] (cell i j)))\n                (for [i (range n)] (for [j (range n)] (cell j i)))\n                (for [i (range (- 3 n) (- n 2))] \n                  (for [k (range n) :let [x (+ i k)]\n                    :when (is-in? x)] (cell x k)))\n                (for [i (range 2 (- (* n 2) 3))] \n                  (for [k (range n) :let [x (- i k)] \n                    :when (is-in? x)] (cell x k))))))\n          (find-color-seq [path]\n            (letfn [(is-color-or-next? [[[_ x] [_ y]]] (some #{opposite-color} [x y]))]\n                (filter is-color-or-next? (partition 2 1 path))))\n          (empty-piece? [c] (= c 'e))\n          (legal-move? [coll] \n              (when (seq coll) \n                  (let [[[fpos fcolor] _] (first coll)\n                        [_ [lpos lcolor]] (last coll)\n                        maybe-flipped (->> (next coll) (map (comp first first)) set)]\n                    (cond (and (= fcolor color) (empty-piece? lcolor)) \n                              {lpos maybe-flipped}\n                          (and (empty-piece? fcolor) (= lcolor color))\n                               {fpos maybe-flipped}))))] \n      (->> (paths board) (map find-color-seq) \n            (map legal-move?) (apply merge-with clojure.set/union)))))", "problem": 124, "user": "51729002e4b044b2ef48a850"}, {"code": "(fn [bd cl]\n  (let [dirs (for [i (range -1 2) j (range -1 2) \n                   :when (not= 0 i j)] \n               [i j])\n        tgt (if (= 'b cl) 'w 'b)\n        f (fn f [dir cur]\n            (loop [p (map + dir cur) vst []]\n              (if-let [newc (get-in bd p nil)]\n                (if (= newc cl) (seq vst)\n                  (when (= newc tgt)\n                    (recur (map + dir p) (conj vst p)))))))\n        g (fn [[i j]] \n            (->> \n             (for [dir dirs :let [ret (f dir [i j])] \n                   :when ret] ret)\n             (apply concat)\n             set))]\n    (into {}\n      (for [i (range 4) j (range 4) \n            :let [tmp (get-in bd [i j])\n                  ret (g [i j])]\n            :when (and (= 'e tmp) (not-empty ret))]\n        [[i j] ret]))))", "problem": 124, "user": "51944aaae4b0142f60b4aedc"}, {"code": "(fn [b t]\n   (let [sps (apply concat (map (fn [x] (map (fn [y] [x y]) (range 4))) (range 4)))\n         es (filter #(= 'e (get-in b %)) sps)\n         can? (fn [p]\n                (let [candir? (fn candir? [p dir s]\n                                (let [nx (vec (map + p dir))]\n                                  (if (or (< (nx 0) 0) (< (nx 1) 0) (> (nx 0) 3) (> (nx 1) 3))\n                                    false\n                                    (if (= 'e (get-in b nx))\n                                      false\n                                      (if (= t (get-in b nx))\n                                        s\n                                        (recur nx dir true))))))]\n                  (or (candir? p [1 0] false)\n                      (candir? p [0 1] false)\n                      (candir? p [1 1] false)\n                      (candir? p [1 -1] false)\n                      (candir? p [-1 0] false)\n                      (candir? p [0 -1] false)\n                      (candir? p [-1 1] false)\n                      (candir? p [-1 -1] false))))\n         ces (filter can? es)\n         getflips (fn [p]\n                    (let [flipdir (fn flipdir [p dir s]\n                                (let [nx (vec (map + p dir))]\n                                  (if (or (< (nx 0) 0) (< (nx 1) 0) (> (nx 0) 3) (> (nx 1) 3))\n                                    #{}\n                                    (if (= 'e (get-in b nx))\n                                      #{}\n                                      (if (= t (get-in b nx))\n                                        (if s #{p} #{})\n                                        (let [nxp (flipdir nx dir true)]\n                                          (if (empty? nxp)\n                                            #{}\n                                            (conj nxp nx))))))))]\n                      (set (concat (flipdir p [1 0] false)\n                                   (flipdir p [0 1] false)\n                                   (flipdir p [1 1] false)\n                                   (flipdir p [1 -1] false)\n                                   (flipdir p [-1 0] false)\n                                   (flipdir p [0 -1] false)\n                                   (flipdir p [-1 1] false)\n                                   (flipdir p [-1 -1] false)))))\n         flips (reduce conj {} (map #(vector %1 %2) ces (map getflips ces)))]\n     flips))", "problem": 124, "user": "52586d24e4b0cb4875a45cb0"}, {"code": "(fn [b p]\n  (let [ib (apply concat \n                  (map-indexed \n                    (fn [i r] \n                      (map-indexed \n                        (fn [j e] [e i j]) r)) b))\n        rf (fn [[x y] a e]\n             (let [[_ i j] e dx (- i x) dy (- j y)\n                   update-a (fn [dir] (update-in a [dir] conj e))]\n               (cond (and (neg? dx) (zero? dy)) (update-a :n)\n                     (and (neg? dx) (= dx (- dy))) (update-a :ne)\n                     (and (zero? dx) (pos? dy)) (update-a :e)\n                     (and (pos? dx) (= dx dy)) (update-a :se)\n                     (and (pos? dx) (zero? dy)) (update-a :s)\n                     (and (pos? dx) (= dx (- dy))) (update-a :so)\n                     (and (zero? dx) (neg? dy)) (update-a :o)\n                     (and (neg? dx) (= dx dy)) (update-a :no)\n                     :else a)))\n        opponent (if (= p 'w) 'b 'w)]\n    (into {}\n      (filter\n        (comp not-empty second)\n        (for [e ib :let [[v x y] e] :when (= 'e v)] \n          (vector [x y] \n                  (set \n                    (mapcat #(map (comp vec rest) (first (partition-by first %)))\n                            (filter\n                              (every-pred not-empty #(= opponent (ffirst %))\n                                          #(= p (ffirst \n                                                  (second \n                                                    (partition-by first %)))))\n                              (vals (reduce (partial rf [x y]) \n                                            {:n '() :ne '() :e [] :se [] \n                                             :s [] :so [] :o '() :no '()} \n                                            ib)))))))))))", "problem": 124, "user": "5246e945e4b0644eb7b0783b"}, {"code": "(fn [wb c]\n  (into {}\n        (for [x (range 4) y (range 4) i [-1 0 1] j [-1 0 1]\n              :when ('#{e} (get-in wb [x y]))\n              :let [d (vec (take 4 (iterate #(mapv + % [i j]) [x y])))\n                    rq (->> d\n                            (map #(get-in wb %))\n                            (apply str)\n                            (re-seq ({'w #\"eb+w\" 'b #\"ew+b\"} c)))]\n              :when rq]\n          [[x y] (->> rq first count dec (range 1) (map #(d %)) set)])))", "problem": 124, "user": "52479487e4b05ef8e38e6373"}, {"code": "(fn [board piece]\n  (let [opponent (if (= piece 'w) 'b 'w)\n        dirs (for [r (range -1 2) c (range -1 2) :when (not= 0 c r)] [r c])\n        adjacents (fn [start dir] (rest (take 4 (iterate #(map + % dir) start))))\n        get-piece (partial get-in board)]\n    (into {}\n      (for [[r row] (keep-indexed vector board)\n            [c p] (keep-indexed vector row)\n            :when (= p 'e)\n            dir dirs\n            :let [pos [r c]\n                  line-positions (adjacents pos dir)\n                  [[flip1 :as flips] [end-piece]] (partition-by get-piece line-positions)]\n            :when (and (= opponent (get-piece flip1)) (= piece (get-piece end-piece)))]\n        [pos (set flips)]))))", "problem": 124, "user": "525431dfe4b0541d1855b970"}, {"code": "(fn [t s]\n   (let [g (for [i (range 4) j (range 4)] [i j])\n         p (filter #(= (get-in t %) s) g)\n         q (set (filter #(let [v (get-in t %)] (and (not= v s) (not= v 'e))) g))\n         e (filter #(= (get-in t %) 'e) g)\n         f (fn [w] (when (and (not-empty w) (every? #(contains? q %) w)) (set w)))]\n     (into {} (filter #(not-empty (second %))\n                (map (fn [x]\n                       [x (some\n                            (fn [y]\n                              (let [fm (first x) fn (first y) sm (second x) sn (second y)]\n                                (cond\n                                  (= fm fn) (f (for [i (range (inc (min sm sn)) (max sm sn))] [fm i]))\n                                  (= sm sn) (f (for [i (range (inc (min fm fn)) (max fm fn))] [i sm]))\n                                  (= (Math/abs (- fm fn)) (Math/abs (- sm sn)))\n                                  (let [sigf (Integer/signum (- fn fm)) sigs (Integer/signum (- sn sm))]\n                                    (f (for [i (range 1 (Math/abs (- fm fn)))] [(+ fm (* sigf i)) (+ sm (* sigs i))])))))) p)])\n                  e)))))", "problem": 124, "user": "51f66e0ee4b06ff1c25c52c3"}, {"code": "(fn reversi-possible-moves [board pl]\n     (let [len (count board)\n           get-multi (fn get-multi\n                       ([coll] coll)\n                       ([coll k & ks]\n                        (if (empty? ks)\n                          (get coll k)\n                          (recur (get coll k) (first ks) (rest ks)))))\n           reversi-swapped-fields (fn [board i j pl]\n                                    (let [board (assoc board i (assoc (board i) j pl))\n                                          dirs [[0 -1] [1 -1] [1 0] [1 1] [0 1] [-1 1] [-1 0] [-1 -1]]\n                                          op (if (= pl 'w) 'b 'w)]\n                                      (reduce\n                                       (fn [s [x y]]\n                                         (loop [a (+ x i), b (+ y j), res s]\n                                           (cond\n                                            (= op (get-multi board a b)) (recur (+ a x) (+ b y) (conj res [a b]))\n                                            (= pl (get-multi board a b)) res\n                                            :else s)))\n                                       #{}\n                                       dirs)))]\n       (->> (for [i (range len)\n                  j (range len)\n                  :let [ch (reversi-swapped-fields board i j pl)]\n                  :when (and\n                          (= 'e (get-multi board i j))\n                          (not-empty ch))]\n              [[i j] ch])\n         (reduce #(assoc %1 (first %2) (second %2)) {}))))", "problem": 124, "user": "526ee63de4b03e8d9a4a733f"}, {"code": "(fn p124 [b h]\n  (let [bs (reduce conj {} (reduce concat '() (map (fn [e] (map (fn [x] [[(first e) (first x)] (second x)]) (zipmap (range) (second e)))) (zipmap (range) b))))\n\tnd (fn [p e] (let [[[ey ex] ev] e [[py px] pv] p]\n                       (and (<= (dec px) ex (inc px)) (<= (dec py) ey (inc py)) (not (and (= px ex) (= py ey))))))\n\tnbs (fn [p] (filter (fn [e] (nd p e)) bs))\n\tes (fn [h bss] (filter (fn [e] (= (val e) h)) bss))\n\tent (fn [y x] [[y x] (bs [y x])])\n\tah (cond (= h 'w) 'b (= h 'b) 'w)\n\tte (reduce concat () (filter (complement empty?) (map (fn [e] (map #(identity [e %]) (es ah (nbs e)))) (es 'e bs))))\n        search0 (fn fs [by bx vy vx]\n                  (if (nil? (bs [by bx])) nil (cons (ent by bx) (fs (+ by vy) (+ bx vx) vy vx))))\n\tsearch (fn [ab] (let [[a b] ab\n                              [[ay ax] av] a [[by bx] bv] b\n                              [vy vx] [(- by ay) (- bx ax)]\n                              cntn (search0 (+ by vy) (+ bx vx) vy vx)\n                              [ges hs] ((juxt (partial take-while (fn [e] (not= (second e) h)))\n                                              (partial drop-while (fn [e] (not= (second e) h))))  cntn)\n                              ]\n                          (if (or (empty? hs) (not= h (second (first hs)))) nil\n                              [a (cons b ges)])))\n\tret (filter (complement nil?) (map search te))\n\tmymrg (fn [m e] (\n                         (conj m\n                               (let [k (first e)\n                                     p (println m k (m k) (second e))\n                                     v (if (m k)\n                                         (conj (m k) (second e))\n                                         (second e))]\n                                 [k v]))))\n\t]\n    (reduce conj {} (map (fn [e] [(first (first e)) (reduce conj #{} (map first (second e)))]) ret))\n\n    ))", "problem": 124, "user": "5272669de4b03e8d9a4a742e"}, {"code": "(fn ar [b c]\n   (let [rank (count b)\n         lm (into {}(for [i (range rank) j (range rank)] [[i j] (get-in b [i j])]))\n         op (if (= c 'b) 'w 'b)\n         ]\n    (->> lm (filter #(= c (val %)))\n         (map first)\n         (mapcat #(let[f (first %) l (peek %)] (->>(vector (for[j (range 4)] [f j])\n                                             (for[i (range 4)] [i l])\n                                             (->>(for[i (range 4)][[(+ f i) (+ l i)][(- f i) (- l i)]])\n                                                 (mapcat identity)\n                                                 (filter (fn[x](and(<(first x)rank)(<(peek x)rank)(>=(first x)0)(>=(peek x)0))))\n                                                 distinct sort)\n                                             (->>(for[i (range 4)][[(+ f i) (- l i)][(- f i) (+ l i)]])\n                                                 (mapcat identity)\n                                                 (filter (fn[x](and(<(first x)rank)(<(peek x)rank)(>=(first x)0)(>=(peek x)0))))\n                                                 distinct sort)\n                                                    )\n\n                                             (filter (fn[x] (and(some (fn[y](= 'e (get lm y))) x)(some (fn[y](= op (get lm y))) x))))\n                                             (mapcat (fn[x] (map (fn[z] [% z (vec x)] )(vec(filter (fn[y](= 'e (get lm y))) x)))))\n                                             (map (fn[x] (let[px (peek x) sx (second x)\n                                                              ci (.indexOf px(first x))\n                                                              ei (.indexOf px sx)] [sx (for [k (range (inc(min ci ei))(max ci ei))] (get px k))])))\n                                             (filter (fn[x] (and (not (empty?(peek x))) (every? (fn[y] (= op (get lm y))) (peek x)))))      \n                                             (map (fn[x] [(first x) (->> x peek set)]))     \n                                                   )\n                              \n                                               ))\n         (into {}) \n\n         )\n\n   )\n )", "problem": 124, "user": "5274eb56e4b03e8d9a4a74bb"}, {"code": "(fn moves\n  ([board player]\n    (let [coordinates (fn [player]\n            (for [x (range (count board))\n                  y (range (count (first board)))\n                  :when (= player ((board x) y))]\n              [x y]\n              )\n            )\n          opponent\n            (cond (= player 'w) 'b\n              (= player 'b) 'w)\n            \n          empty-coordinates (coordinates 'e)\n          opponent-coordinates (set (coordinates opponent))\n          player-coordinates (set (coordinates player))]\n      (->>\n            (apply merge (map #(hash-map % (for [f-x [inc identity dec]\n                                                f-y [inc identity dec]]\n                                            (moves player-coordinates opponent-coordinates % f-x f-y)))\n                             empty-coordinates))\n           (map (fn [entry] [(first entry) (filter #(> (count %) 1) (second entry))]))\n           (map (fn [entry] [(first entry) (filter #(every? (fn [arg] (not (nil? arg))) %) (second entry))]))\n           (map (fn [entry] [(first entry) (filter #(contains? player-coordinates (last %)) (second entry))]))\n           (map (fn [entry] [(first entry) (filter #(vector? (first %)) (second entry))]))\n           (map (fn [entry] [(first entry) (map #(drop-last %) (second entry))]))\n           (filter (fn [entry] (not (empty? (second entry)))))\n           (map (fn [entry] [(first entry) (apply set (second entry))]))\n           (into {})\n      )\n    )\n  )\n  ([player-coordinates opponent-coordinates current-coordinates f-x f-y]\n    (let [next-coordinates [(f-x (first current-coordinates))(f-y (second current-coordinates))]]\n      (cond (contains? opponent-coordinates next-coordinates) (cons next-coordinates (moves player-coordinates opponent-coordinates next-coordinates f-x f-y))\n            (contains? player-coordinates next-coordinates) [next-coordinates]\n      )\n    )\n  )\n)", "problem": 124, "user": "5272d4b7e4b03e8d9a4a7453"}, {"code": "(fn reversi [board  x]\n  (letfn [(step [board start  f]\n                (letfn [(findpt  [board x step  f]\n                                 (let [ at-board (fn [board [x y]]\n                                                   (or                  \n                                                     (> 0 x)              \n                                                     (> 0 y)\n                                                     (< (count board) x)\n                                                     (< (count (first board)) y)))\n                                       x (vec (map + x step))]  \n                                   (if(or ( at-board board x)\n                                          (f x))\n\t                                     nil\n\t                                     (if(= 'e (get-in board x ))   \n                                        {x #{}}\n                                        (let [result (findpt board  x step f)]\n                                          (if (nil? result )\n                                            nil\n                                            (assoc result \n                                                   (key (first result))\n                                                   (conj (val(first result )) x))))))))]\n                  (let[ steps (disj (set (mapcat  #(map (fn[x] [% x])(range -1 2)) \n                             (range -1 2))) [0 0])]\n                    (set (filter #(not (nil? %)) \n                                 (map (fn [step] \n                                        (findpt board start step f)) steps ))))))]\n    (->>\n      (filter #(= x (get-in board %))\n              (mapcat  #(map (fn[x] [% x])(range 0 4)) \n                       (range 0 4)))\n      (mapcat #(step board\n                     % \n                     (fn[xx] \n                       (= x (get-in board xx)))))\n      (filter #(not (empty? (second (first %)))))\n      (into {}))))", "problem": 124, "user": "5273562ae4b03e8d9a4a7479"}, {"code": "(fn p124 [b p]\n  (letfn [(ln [x, b]\n            (let [ds (for [a [-1 0 1] b [-1 0 1] :when (not= 0 a b)] [a b])]\n              (for [d ds]\n                (for [i (rest (range b)) :let [y (map #(+ %1 (* i %2)) x d)]\n                      :when (and (< -1 (first y) b) (< -1 (last y) b))] y))))\n          (mv [b p l]\n            (let [[s r] ((juxt take-while drop-while) #(not (#{p, 'e} (get-in b %))) l)]\n              (if (and (not-empty r) (not-empty s) (= 'e (get-in b (first r)))) [(first r) (set s)] ())))\n          ]\n    (let [n (count b)]\n      (->> (apply concat (for [i (range n) j (range n) :when (= p (get-in b [i j]))] (ln [i j] n)))\n        (map (partial mv b p)) (into {})))))", "problem": 124, "user": "528e64b7e4b0239c8a67aedd"}, {"code": "(fn [board col]\n  (let [other (if (= 'w col) 'b 'w)\n        directions #{[-1 -1] [-1 0] [-1 1] [0 -1] [0 1] [1 -1] [1 0] [1 1]}\n        empties (filter #(= 'e (last %))    \n                        (apply concat (map-indexed (fn e [y row]\n                                                     (map-indexed  \n                                                      (fn z [x el]\n                                                        [[y x] el]) row)) board)))\n        flipped (fn flipped [pos dir]    \n                  (let [nextpos (map + pos dir)\n                        value (get-in board pos 'e)]\n                    (if (= 'e value)\n                      nil\n                      (if (= col value)\n                        []      \n                        (if (nil? (flipped nextpos dir))\n                          nil        \n                          (cons pos (flipped nextpos dir)))))))\n        all-flipped (fn [pos]\n                      [pos (into #{} (mapcat #(flipped (map + pos %) %) directions))])\n        ]\n    (into {} (filter #(not-empty (last %)) (map (comp all-flipped first) empties)))))", "problem": 124, "user": "513b77f3e4b00f740c76c403"}, {"code": "(fn analyze-reversi [board piece]\n  (let [other-piece (if (= piece 'w) 'b 'w)\n        dir-vecs (letfn [(id-func [i & args] i)]\n                   (for [r [+ - id-func]\n                         c [+ - id-func]\n                         :when (not= [id-func id-func] [r c])]\n                     [r c]))\n        matching-coordinates (for [r (range (count board))\n                                   c (range (count (first board)))\n                                   :when (= piece (get-in board [r c]))]\n                               [r c])\n        line-from (fn [start-coords [f-r f-c]]\n                    (map #(vector % (get-in board %))\n                         (take-while #(get-in board %)\n                                     (reductions\n                                       (fn f [[r c] n]\n                                         [(f-r r n) (f-c c n)])\n                                       start-coords\n                                       (repeat 1)))))\n        placement (fn [line]\n                    (let [[other [first-not-other & rest-not-other]] (split-with #(= other-piece (last %)) (rest line))]\n                      (if (and (> (count line) 2) (> (count other) 0) (= 'e (last first-not-other)))\n                          {(first first-not-other) (into #{} (map #(first %) other))}\n                          nil)))\n        ]\n    (apply merge (filter map?\n                         (for [coords matching-coordinates\n                               dv dir-vecs]\n                           (placement (line-from coords dv)))))))", "problem": 124, "user": "52463059e4b09dbe66b56198"}, {"code": "(fn reversi [board p]\n  (let [o '{b w w b}\n        d (for [y [-1 0 1] x (if (= 0 y) [-1 1] [-1 0 1])] [y x])\n        b (into {} (for [y (range 4) x (range 4)] [[y x] (get-in board [y x])]))\n        e (map key (filter #(= 'e (val %)) b))\n        wk (fn [st off] (take-while b (rest (iterate #(map + % off) st))))\n        vl (fn [pth] (let [s (apply str (map b pth)) r (re-pattern (str (o p) \"+\" p))]\n                       (if (re-seq r s) (take-while #(not= p (b %)) pth))))\n        mv (fn [st] (set (apply concat (keep vl (map #(wk st %) d)))))]\n    (into {} (for [st e :let [mvs (mv st)] :when (not-empty mvs)] [st mvs]))))", "problem": 124, "user": "5032b066e4b00c0952a257ea"}, {"code": "(fn [board player]\n  (let [indices     (for [row       (range (count board))\n                          column    (range (count board))]\n                      [row column])\n        enemy       ({'w 'b, 'b 'w} player)\n        deltas      [[-1 0] [-1 1] [0 1] [1 1] [1 0] [1 -1] [0 -1] [-1 -1]]\n        line-from   (fn line-from [position delta]\n                      (let [next-position (map + position delta)]\n                        (if (some #{position} indices)\n                          (cons position (line-from next-position delta)))))\n        lines-from  (fn [position]\n                      (for [delta deltas]\n                        (line-from position delta)))\n        \n        flipped     (fn [line]\n                      (let [move      (first line)\n                            flipped   (take-while #(#{enemy} (get-in board %)) (rest line))\n                            end       (first (drop-while #(#{enemy} (get-in board %)) (rest line)))]\n                        (if (and (= (get-in board move) 'e)\n                                 (= (get-in board end) player))\n                          (apply hash-set flipped)\n                          '())))]\n    (apply merge (for [position indices\n                 \t   line (lines-from position)\n                       :when (not (empty? (flipped line)))]\n                   {position (flipped line)}))))", "problem": 124, "user": "510cd1dde4b078ea71921124"}, {"code": "(fn reversi [orig c]\n(letfn [\n        (flipped [b c r]\n          (let [s (reduce str  \"\" (map #(b %)  r))\n                yy (re-find (re-pattern (str \".*\" (oppcolor c) \".*\")) s)\n                zz (print s)\n                ]\n            (if yy (set (take-while #(= c (b %)) r)) #{} )  )\n          )\n        (offset [x y]\n          (+ (* x 4)  y ))\n        (oppcolor [c]\n          (if (= c 'w) 'b 'w))\n        (get-range [x]\n          [(range (+ x 1) (* 4 (+ 1 (quot x 4))))\n           (reverse (range (* 4 (quot x 4)) x))\n           (range (+ x 4) 16 4)\n           (range (- x 4) (- 1) (- 4))\n           (take (min (quot x 4) (- 4 (inc (mod x 4)))) (iterate #(- % 3) (- x 3)))\n           (take (min (quot x 4) (mod x 4)) (iterate #(- % 5) (- x 5)))\n           (take (min (- 3 (quot x 4)) (mod x 4)) (iterate #(+ % 3) (+ x 3)))\n           (take (min (- 3 (quot x 4))(- 4 (inc (mod x 4)))) (iterate #(+ 5 %) (+ x 5)))\n           ]\n          )\n        (win2 [b c [hi wi]]\n          (let [x (offset hi wi)]\n            (mapcat #(flipped (vec (flatten b))\n                             (oppcolor c)\n                             %) (get-range x)))\n          )\n        (patch [orig h w x] (for [hi [0 1 2 3]]\n                              (for [wi [0 1 2 3]]\n                                (if (= [h w] [hi wi]) x (get-in orig [hi wi])))))\n        (analysis [c orig] (for [ hi [0 1 2 3]\n                                 wi [0 1 2 3]\n                                 :when (= 'e (get-in orig [hi wi]))\n                                 :let [s (win2 (patch orig hi wi c) c [hi wi]) ]\n                                 :when ((complement empty?) s)\n                                 :let [s' (set (map #(vec [(quot % 4)\n                                                            (mod % 4)]) s)) ]\n                                      ]\n                             { [hi wi] s' }))\n        ] (apply merge (analysis c orig))\n)\n  )", "problem": 124, "user": "52140b53e4b0961f15ac4d7e"}, {"code": "(fn [brd plr]\n  (let [opp ('{w b b w} plr)\n        drct (for [i [-1 0 1] j [-1 0 1]] [i j])\n        chk-drct (fn [i d s]\n                  (if (= 'e (get-in brd i))\n                    (loop [i (map + i d) o #{}]\n                      (let [p (get-in brd i)]\n                        (cond\n                          (= p opp) (recur (map + i d) (conj o i))\n                          (= p plr) (into s o)\n                          :else  s )))))]\n    (into {}\n      (remove #(empty? (last %))\n        (for [r (range (count brd)) c (range (count (first brd)))]\n                (vector [r c] (reduce #(chk-drct [r c] %2 %1) #{} drct)))))))", "problem": 124, "user": "528652fbe4b0239c8a67ae14"}, {"code": "(fn n124 [board piece]\n  (letfn [(get-coors [p coor-all] \n                     (filter #(= p (get-in board %)) coor-all))\n          (get-line-horizonal [coor coors]\n                              (filter #(= (first coor) (first %)) coors))\n          (get-line-vertical [coor coors]\n                             (filter #(= (second coor) (second %)) coors))\n          (get-line-cross-left [coor coors]\n                               (filter #(= (apply + coor) (+ (first %) (second %))) coors))\n          (get-line-cross-rignt [coor coors]\n                                (filter #(= (apply - coor) (- (first %) (second %))) coors))\n          (get-lines [coor coors]\n                    [(get-line-horizonal coor coors)\n                     (get-line-vertical coor coors)\n                     (get-line-cross-left coor coors)\n                     (get-line-cross-rignt coor coors)])\n          (get-lines-pieces [lines]\n                            (for [line lines]\n                              (map #(get-in board %) line)))\n          (get-lines-nbr [coor coors]\n                         (mapcat \n                           (fn [x] \n                             (filter #(and (not (empty? %)) (not= (count %) 1))\n                                     (#(vector (reverse (first %)) (rest (second %))) (split-with #(not= coor %) x)))) \n                           (get-lines coor coors)))\n          (opposite-piece [p]\n                          (cond\n                            (= p 'w) 'b\n                            (= p 'b) 'w))\n          (changable [p line]\n                     (if (= (opposite-piece p) (first line))\n                       (loop [l (rest line) a 1]\n                         (cond \n                           (= (first l) p) a\n                           (= (first l) (opposite-piece p)) (recur (rest l) (inc a))\n                           :else false))\n                       false))\n          ]\n    (let [coor-all (for [x (range (count board)) \n                         y (range (count (first board)))]\n                     [x y])\n          empty-coor (get-coors 'e coor-all)\n          w-coor (get-coors 'w coor-all)\n          b-coor (get-coors 'b coor-all)\n          hms (into {} (filter #((complement empty?) (second %)) \n                               (for [x empty-coor\n                                     :let [nbrs (get-lines-nbr x coor-all)\n                                           findings (map (partial changable piece) (map #(map (partial get-in board) %) nbrs))]] \n                                 (vector x (filter #((complement false?) (last %)) (map vector nbrs findings))))))\n          ]\n      (into {} (for [[k v] hms]\n                   [k (apply set (map #(take (second %) (vec (first %)) ) v))]))\n      )))", "problem": 124, "user": "52b43468e4b0c58976d9ad1b"}, {"code": "(fn [b p]\n  (let [other (if (= p 'w) 'b 'w)\n        dyx [[-1 -1] [0 -1] [1 -1]\n             [-1  0]        [1  0]\n             [-1  1] [0  1] [1  1]]\n        mv (fn [[y x] dir n]\n             (let [[dy dx] (nth dyx dir)]\n               [(+ y (* n dy)) (+ x (* n dx))])) \n        in? (fn [[y x]] (and (<= 0 x 3) (<= 0 y 3)))\n        sq (fn [[y x] dir]\n             (vec\n               (take 4\n                 (map (fn [xy] [xy (get-in b xy)])\n                   (filter in?\n                     (for [i (range 4)] (mv [y x] dir i)))))))\n       valid (fn [sq]\n               (cond\n                 (= (take 3 (map second sq)) ['e other p])\n                   [(first (second sq))]\n                 (= (take 4 (map second sq)) ['e other other p])\n                   [(first (second sq)) (first (nth sq 2))]\n                 :default nil\n                 ))\n       flips (fn [xy]\n               (set\n                 (partition 2\n                   (flatten\n                     (filter identity\n                       (for [dir (range 8)]\n                         (valid (sq xy dir))))))))]\n    (into {}\n     (for [x (range 4) y (range 4)\n           :let [fl (flips [y x])]\n           :when (not-empty fl)]\n       [[y x] fl]))\n    ))", "problem": 124, "user": "52a88c4de4b0c58976d9ac30"}, {"code": "(fn [board color]\n  (let [ds [[-1 -1] [-1 0] [-1 1] [0 -1] [0 1] [1 -1] [1 0] [1 1]]\n        opponent (if (= color 'w) 'b 'w)\n        coords (fn [x y dx dy n]\n                 [(+ x (* n dx)) (+ y (* n dy))])\n        get-in' (fn [x y dx dy n]\n                  (get-in board (coords x y dx dy n)))\n        get-line (fn [x y dx dy]\n                   (map #(get-in' x y dx dy %) [0 1 2 3]))\n        legal-move (fn [x y dx dy]\n                      (let [[a b c d] (get-line x y dx dy)]\n                        (cond (not= a 'e) nil\n                              (not= b opponent) nil\n                              (= c color)\n                                   [[x y] #{(coords x y dx dy 1)}]\n                              (and (= c opponent) (= d color))\n                                   [[x y]\n                                    #{(coords x y dx dy 1) (coords x y dx dy 2)}]\n                              :else nil)))\n        legal-move-mapper (fn [x y]\n                            (partial apply (partial legal-move x y)))\n        all-moves (fn [x y]\n                    (apply hash-map (mapcat (legal-move-mapper x y) ds)))]\n    (apply hash-map\n           (apply concat\n                  (mapcat (fn [x] (mapcat (fn [y] (all-moves x y)) (range 4)))\n                          (range 4))))))", "problem": 124, "user": "4f437751e4b0d7d3c9f3fd20"}, {"code": "(fn reversi [grid who]\n  (let [hmap (apply merge-with into (for [[x row] (map-indexed vector grid)\n                                          [y val] (map-indexed vector row)]\n                                      {val #{[x y]}}))\n        other #(if (= % 'b) 'w 'b)\n        dirs (for [x (range -1 2) y (range -1 2) :when (not= 0 x y)] [x y])\n        allowed (fn allowed [start at dir st]\n                  (let [nxt (mapv + at dir)\n                        who-nxt (first (filter #(some #{nxt} (hmap %)) (keys hmap)))]\n                    (cond (= who-nxt (other who))\n                          (recur start nxt dir (conj st nxt))\n                          (and (seq st) (= who-nxt who)) [start st])))]\n    (->> (for [x (hmap 'e) dir dirs] (allowed x x dir #{}))\n         (remove nil?)\n         (map (partial apply hash-map))\n         (apply merge))))", "problem": 124, "user": "50645e12e4b007509339a58a"}, {"code": "(letfn [(cells [v]\n           (for [y (range 0 (count v))\n                 x (range 0 (count (first v)))]\n             {:xy [y x] :v (get-in v [y x])}))\n         (subset [v grp]\n           (map val (group-by #(-> % :xy grp) (cells v))))\n         (rows [v]\n           (subset v (fn [[y _]] y)))\n         (cols [v]\n           (subset v (fn [[_ x]] x)))\n         (diags [v]\n           (concat (subset v (fn [[y x]] (+ x y))) \n                   (subset v (fn [[y x]] (- x y)))))\n         (lines [v]\n           (concat (rows v) (cols v) (diags v)))\n         (split-spaces [v]\n           (cond (empty? v) []\n                 (= (-> v first :v) 'e) (split-spaces (rest v))\n                 :otherwise (cons (take-while #(not= (:v %) 'e) v)\n                                  (split-spaces (drop-while #(not= (:v %) 'e) v)))))\n         (areas [v c]\n           (cond (empty? v) []\n                 (= (-> v first :v) c) (let [[a r] \n                                             (split-with #(not= (:v %) c) (rest v))]\n                                         (if (empty? r) []\n                                             (cons a (areas r c))))\n                 :otherwise (areas (rest v) c)))\n         (movable [line color]\n           (filter not-empty\n                   (for [i (range 0 (count line)) \n                         :when (= (:v (nth line i)) 'e)]\n                     (let [splits (split-spaces (update-in line [i :v] \n                                                           (constantly color)))\n                           as (remove empty? (mapcat #(areas % color) splits))]\n                       (if (not-empty as)\n                         [(:xy (get-in line [i])) (set (mapcat #(map :xy %) as))])))))]\n   (fn [v c] (into {} (mapcat #(movable % c)\n                              (lines v)))))", "problem": 124, "user": "5294e44de4b02ebb4ef75016"}, {"code": "(fn [board me]\n    (let [not-me (if (= 'w me) 'b 'w)\n          directions (for [i (range -1 2)\n                           j (range -1 2)\n                           :when (not= [0 0] [i j])]\n                       [i j])\n          flips-in-direction (fn [from direction]\n                               (let [spaces (->> (iterate #(map + % direction) from)\n                                                 (drop 1)\n                                                 (take-while #(if-let [piece (get-in board %)]\n                                                                (not= 'e piece))))\n                                     pieces (map #(get-in board %) spaces)]\n                                 (if (and (= not-me (first pieces)) (some #{me} pieces))\n                                   (set (take (count (take-while #(= not-me %) pieces)) spaces))\n                                   #{})))\n          flips (fn [from]\n                  (reduce\n                    clojure.set/union\n                    (for [direction directions]\n                      (flips-in-direction from direction))))\n          can-move? (fn [position]\n                      (and\n                        (= 'e (get-in board position))\n                        (not (zero? (count (flips position))))))\n          valid-moves (for [i (range (count board))\n                            j (range (count (get board i)))\n                            :when (can-move? [i j])]\n                        [i j])]\n      (into {} (mapcat #(vector [% (flips %)]) valid-moves))))", "problem": 124, "user": "521b9f92e4b0c4ef0be8304c"}, {"code": "(fn othello\n  [board player]\n  (letfn\n    [(gen-moves\n      [piece]\n      {:n #(and (= (:row %) (dec (:row piece)))\n                (= (:column %) (:column piece)))\n       :s #(and (= (:row %) (inc (:row piece)))\n                (= (:column %) (:column piece)))\n       :e #(and (= (:row %) (:row piece))\n                (= (:column %) (inc (:column piece))))\n       :w #(and (= (:row %) (:row piece))\n                (= (:column %) (dec (:column piece))))\n       :nw #(and (= (:row %) (dec (:row piece)))\n                (= (:column %) (dec (:column piece))))\n       :ne #(and (= (:row %) (dec (:row piece)))\n                (= (:column %) (inc (:column piece))))\n       :sw #(and (= (:row %) (inc (:row piece)))\n                (= (:column %) (dec (:column piece))))\n       :se #(and (= (:row %) (inc (:row piece)))\n                (= (:column %) (inc (:column piece))))})\n     (find-path \n      [acc player dir neighbor indexed-board]\n      (let [play (first (filter (dir (gen-moves neighbor)) indexed-board))]\n        (cond (nil? play) nil\n              (= player (:player play)) acc\n              0 (recur (conj acc (vector (:row play) (:column play)))\n                       player \n                       dir \n                       play \n                       indexed-board))))\n     (do-move\n      [piece player indexed-board dir]\n      (let [neighbor (first (filter (dir (gen-moves piece)) indexed-board))]\n        (if (or (nil? neighbor)\n                (= (:player neighbor) player)\n                (= (:player neighbor) 'e)) nil\n          (find-path (list (vector (:row neighbor) (:column neighbor))) \n                     player \n                     dir \n                     neighbor \n                     indexed-board))))\n     (chk-piece\n      [piece player indexed-board]\n      (let\n        [plays \n         (remove empty?\n          (mapcat #(do-move piece player indexed-board %) [:nw :n :ne :w :e :sw :s :se]))]\n        (if (empty? plays) nil\n        {(vector (:row piece) (:column piece)) (set plays)})))\n     (find-pieces\n      [indexed-board player]\n      (filter #(= player (:player %)) indexed-board))]\n    (let [indexed-board\n           (apply concat \n             (for [i (range (count board))]\n               (map-indexed #(hash-map :row i :column %1 :player  %2) (board i))))]\n      (into {}\n        (remove empty? \n                (map #(chk-piece % player indexed-board) \n                     (find-pieces indexed-board 'e)))))))", "problem": 124, "user": "5273e006e4b03e8d9a4a7495"}, {"code": "(fn [board clr]\n  (let [oppo (if (= 'w clr) 'b 'w)\n        dirs [[-1 0] [1 0] [0 -1] [0 1] [-1 -1] [1 1] [-1 1] [1 -1]]\n        in-range (fn [[x y]]\n                   (and (<= 0 x) (< x 4) (<= 0 y) (< y 4)))\n        go-dir (fn [st d a b]\n                 (loop [c (map + st d) passed #{}]\n                   (cond\n                     (not (in-range c)) #{}\n                     (= a (get-in board c)) passed\n                     (= b (get-in board c)) (recur (map + c d) (conj passed c)))))]\n    (into {}\n      (for [x (range 4) y (range 4)\n            :when (= 'e (get-in board [x y]))\n            :let [cs (reduce clojure.set/union (for [d dirs] (go-dir [x y] d clr oppo)))]\n            :when (not-empty cs)]\n        [[x y] cs]))))", "problem": 124, "user": "527cd633e4b0757a1b17136f"}, {"code": "(fn [r p]\n   (into {}\n         (map #(identity {(first %) (second %)})\n              (remove\n               #(= 1 (count %))\n               (apply concat\n                      (keep-indexed\n                       (fn [a x]\n                         (concat\n                          (keep-indexed\n                           (fn [b y]\n                             (if (= 'e y)\n                               (cons [a b]\n                                     (into #{}\n                                           (remove #(empty? %)\n                                                   (for [f [[-1 1] [1 -1] [-1 -1] [1 1] [0 1] [0 -1] [1 0] [-1 0]]]\n                                                     (loop [s #{} x2 (+ a (first f)) y2 (+ b (second f))]\n                                                       (if (or (or (>= x2 (count r)) (< x2 0)) (or (>= y2 (count (r x2))) (< y2 0)))\n                                                         #{}\n                                                         (if (and (not= 'e ((r x2) y2)) (not= p ((r x2) y2)))\n                                                           (recur (conj s [x2 y2]) (+ x2 (first f)) (+ y2 (second f)))\n                                                           (if (= 'e ((r x2) y2)) #{} s)\n                                                           ))\n                                                       ))\n                                                   ))))) x))) r))))))", "problem": 124, "user": "52c1bd29e4b07a9af579236a"}, {"code": "(fn [b c]\n   (let [ds [[0 1] [1 1] [1 0] [1 -1] [0 -1] [-1 -1] [-1 0] [-1 1]]\n         t ({'b 'w 'w 'b} c)]\n     (loop [ans {}\n            T (for [i (range 4) j (range 4) d ds] [i j d])]\n       (if (seq T)\n         (let [A assoc\n               G (partial get-in b)\n               [i j [di dj]] (first T)\n               cell (G [i j])\n               T (rest T)\n               dij #(vector (+ i (* % di)) (+ j (* % dj)))\n               d1 (dij 1)\n               d2 (dij 2)\n               d3 (dij 3)]\n           (cond (not= 'e cell) (recur ans T)\n                 (and (every? #(< -1 % 4) d2)\n                      (= t (G d1))\n                      (= c (G d2)))\n                 (if-let [pre (ans [i j])]\n                   (recur (A ans [i j] (conj pre d1)) T)\n                   (recur (A ans [i j] #{d1}) T))\n                 (and (every? #(< -1 % 4) d3)\n                      (= t (G d1) (G d2))\n                      (= c (G d3)))\n                 (if-let [pre (ans [i j])]\n                   (recur (A ans [i j] (conj pre d1 d2)) T)\n                   (recur (A ans [i j] #{d1 d2}) T))\n                 :else (recur ans T)))\n         ans))))", "problem": 124, "user": "52d10680e4b07d0d72b273c3"}, {"code": "(fn [b c]\n    (let [[m n]                  [(count b) (count (first b))]\n          coords                 (for [i (range m) j (range n)] [i j])\n          add                    (comp vec (partial map +))\n          basis                  (for [x [-1 0 1] y [-1 0 1] :when (not (= x y 0))] [x y])\n          neighbors              (fn [trace p]\n                                   (map (if trace\n                                          (fn [x] (->> p\n                                                       (iterate (partial add x))\n                                                       (take-while #(->> % (get-in b) nil? not))\n                                                       (rest)))\n                                          (partial add p))\n                                        basis))\n          neighbors-an-opponent? (fn [x] (->> x\n                                              (neighbors false)\n                                              (map (partial get-in b))\n                                              (filter #(and (not (nil? %)) (not= 'e %) (not= c %)))\n                                              (empty?)\n                                              (not)\n                                              ))\n          candidate-coords       (->> coords\n                                      (filter (comp (partial = c) (partial get-in b)))\n                                      (mapcat (partial neighbors true))\n                                      (apply concat)\n                                      (distinct)\n                                      (filter (comp (partial = 'e) (partial get-in b)))\n                                      (filter neighbors-an-opponent?))\n          captured-coords        (fn [x] (->> x\n                                              (neighbors true)\n                                              (mapcat (comp first\n                                                            (partial reduce (fn [[captured running] p]\n                                                                              (cond\n                                                                                (= (get-in b p) c)  [(into captured running) #{}]\n                                                                                (= (get-in b p) 'e) [captured running]\n                                                                                :else               [captured (conj running p)]))\n                                                                     [#{} #{}])))\n                                              (set)))\n\n          ]\n      (->> candidate-coords\n           (map (fn [k] [k (captured-coords k)]))\n           (filter (comp not empty? second)) ; apparently you're not allowed to move if you do not capture\n           (into {}))))", "problem": 124, "user": "525f51bde4b0cb4875a45dc8"}, {"code": "(fn reversi [rows turn]\n  (let [op '{b w, w b}\n        moves {(list turn (op turn) 'e 'e) [2 [1]]\n               (list turn (op turn) 'e turn) [2 [1]]\n               (list 'e turn (op turn) 'e) [3 [2]]\n               (list turn turn (op turn) 'e) [3 [2]]\n               (list turn (op turn) (op turn) 'e) [3 [1 2]]\n               (list 'e (op turn) turn 'e) [0 [1]]\n               (list 'e (op turn) turn turn) [0 [1]]\n               (list 'e 'e (op turn) turn) [1 [2]]\n               (list turn 'e (op turn) turn) [1 [2]]\n               (list 'e (op turn) (op turn) turn) [0 [1 2]]\n               }\n        cols (apply map vector rows)\n        diag (map #(get-in rows [% %]) [0 1 2 3])\n        rdiag (map #(get-in rows [% (- 3 %)]) [0 1 2 3])\n        dp (map #(get-in rows [% (inc %)]) [0 1 2])\n        dn (map #(get-in rows [(inc %) %]) [0 1 2])\n        rp (map #(get-in rows [% (- 2 %)]) [0 1 2])\n        rn (map #(get-in rows [(- 2 %) %]) [0 1 2])\n        ]\n    (merge-with\n     #(clojure.set/join %1 %2)\n     (into {}\n           (for [i (range 4)\n                 :let [x (moves (nth rows i))]\n                 :when x]\n             {[i (first x)] (set (map #(vector i %) (last x)))}\n             ))\n     (into {}\n           (for [i (range 4)\n                 :let [x (moves (nth cols i))]\n                 :when x]\n             {[(first x) i] (set (map #(vector % i) (last x)))}\n             ))\n     (if-let [x (moves diag)]\n       {[(first x) (first x)] (set (map #(vector % %) (last x)))}\n       {}\n       )\n     (if-let [x (moves rdiag)]\n       {[(first x) (- 3 (first x))] (set (map #(vector % (- 3 %)) (last x)))}\n       {}\n       )\n     (if-let [x (moves dp)]\n       {[(first x) (inc (first x))] (set (map #(vector % (inc %)) (last x)))}\n       {}\n       )\n     (if-let [x (moves dn)]\n       {[(inc (first x)) (first x)] (set (map #(vector (inc %) %) (last x)))}\n       {}\n       )\n     (if-let [x (moves rp)]\n       {[(first x) (- 2 (first x))] (set (map #(vector % (- 2 %)) (last x)))}\n       {}\n       )\n     (if-let [x (moves rn)]\n       {[(- 2 (first x)) (first x)] (set (map #(vector (- 2 %) %) (last x)))}\n       {}\n       )\n     )\n    )\n  )", "problem": 124, "user": "52e59ca5e4b09f7907dd1464"}, {"code": "(fn [board color] \n(let [\n\tdirs (for [x (range -1 2) y (range -1 2) :when (not= [x y] [ 0 0]) ] [x y])\n\tline (fn  [board p [a b]]\n\t  (take-while (fn [[x y]]\n\t\t (and (<= 0 x) (<= 0 y) (> 4 x) (> 4 y) ))\n\t  (iterate (fn [[x y]] (vector (+ a x) (+ b y))) p)))\n\n\tvalid-line?(fn  [board color p dir]\n\t (let [[c e & rs :as full] (map #(get-in board %)(line board p dir))]\n\t   (and (= 'e c) \n\t\t\t(not= color e) \n\t\t\t(not= 'e e) \n\t\t\t(some #(= % color) rs)) ))  \n\n\tvalid-lines?(fn  [board row cell color]\n\t   (not-empty (filter #(valid-line? board color [row cell] %) dirs) ))\n\t  \n\tmoves(fn  [board color]\n\t  (for [row (range 4) cell (range 4) :when (valid-lines? board row cell color) ]\n\t\t[row cell]))\n\t\t\n\tflips (fn  [board color [row cell]]\n\t  (reduce #(into %1 (let [[l & rs] (line board [row cell] %2)\n\t\t\t\t\t\t\t rs* (take-while  (fn [x] (not= color (get-in board x))) rs)]\n\t\trs*)) \n\t\t#{} \n\t\t(valid-lines? board row cell color)))\t\n\t]\n  (reduce #(assoc %1 %2 (flips board color %2)) {} (moves board color)) ))", "problem": 124, "user": "523a9fc9e4b081681ca7adca"}, {"code": "(fn [board k]\n   (let [c_len (count (first board)) r_len (count board)\n         get-in (fn [x y] (if (or (< x 0) (< y 0) (>= x c_len) (>= y r_len)) nil (nth (nth board y) x)) )\n         move-inc (partial + 1) move-dec (fn [p] (- p 1))\n         still (partial + 0)\n          find-line (fn [px py mv-x mv-y](loop [r [] cx px cy py](let [nx (mv-x cx) ny (mv-y cy) np (get-in nx ny)](if (or (= np nil)(= np 'e)(= np k)) (if (and (= np 'e) (not (empty? r))) {[ny nx] (set r)} [])(recur (conj r [ny nx]) nx ny))))) \n          find-candidate (fn [px py] (filter #(not (empty? %)) [(find-line px py still move-dec)(find-line px py move-dec still)(find-line px py move-inc still)(find-line px py still move-inc)(find-line px py move-inc move-inc)(find-line px py move-dec move-dec)(find-line px py move-inc move-dec)(find-line px py move-dec move-inc)]))\n         ]\n     (apply merge (apply concat (filter #(not= nil %) (for [x (range c_len) y (range r_len)]\n       (if (= k (get-in x y)) (find-candidate x y))\n     ))))\n     \n   )\n)", "problem": 124, "user": "522eba30e4b01cdb292c5f0e"}, {"code": "(fn [tabuleiro cor]\n  (letfn [(posicoes [tabuleiro cor]\n                    (for [linha (range 4)\n                          coluna (range 4)\n                          :when (= cor (get-in tabuleiro [linha coluna]))]\n                      [linha coluna]))\n          (constroi-jogada [cor tabuleiro funcao-movimentacao posicoes-intermediarias]\n                           (let [proxima-posicao (funcao-movimentacao (last posicoes-intermediarias))\n                                 proximo-elemento (get-in tabuleiro proxima-posicao)\n                                 novas-posicoes-intermediarias (conj posicoes-intermediarias proxima-posicao)]\n                             (cond\n                              (= 'e proximo-elemento) novas-posicoes-intermediarias\n                              (= nil proximo-elemento) nil\n                              (= cor proximo-elemento) nil\n                              :else (constroi-jogada cor tabuleiro funcao-movimentacao novas-posicoes-intermediarias))))]\n    (->> (mapcat (fn [posicao]\n                   (map #(constroi-jogada cor tabuleiro % [posicao])\n                        (for [f1 [inc dec identity]\n                              f2 [inc dec identity]\n                              :when (not (and (= f1 identity)\n                                              (= f2 identity)))]\n                          (fn [[l c]] [(f1 l) (f2 c)]))))\n                 (posicoes tabuleiro cor))\n         (remove nil?)\n         (remove #(= 2 (count %)))\n         (reduce (fn [resposta [primeiro-elemento & outros-elementos]]\n                   (merge-with clojure.set/union\n                               {(last outros-elementos) (set (drop-last outros-elementos))}\n                               resposta))\n                 {}))))", "problem": 124, "user": "52c8758be4b0c2d177d62135"}, {"code": "(fn [board side] (letfn [\n(nw-se-diagonal-of-4 [] (map vector (range 0 4) (range 0 4)))\n(sw-ne-diagonal-of-4 [] (map vector (range 3 -1 -1) (range 0 4)))\n(diagonals-of-4 [] (vector (nw-se-diagonal-of-4) (sw-ne-diagonal-of-4)))\n(rows-of-4 [] (map #(map vector (repeat 4 %) (range 0 4)) (range 0 4)))\n(columns-of-4 [] (map #(map vector (range 0 4) (repeat 4 %)) (range 0 4)))\n(rows-of-3 [] (mapcat #(partition 3 1 %) (rows-of-4)))\n(columns-of-3 [] (mapcat #(partition 3 1 %) (columns-of-4)))\n(nw-se-diagonals-of-3 [] (concat (vector (map vector (range 0 3) (range 1 4))) (partition 3 1 (nw-se-diagonal-of-4)) (vector (map vector (range 1 4) (range 0 3)))))\n(sw-ne-diagonals-of-3 [] (concat (vector (map vector (range 2 -1 -1) (range 0 3))) (partition 3 1 (sw-ne-diagonal-of-4)) (vector (map vector (range 3 0 -1) (range 1 4)))))\n(diagonals-of-3 [] (concat (nw-se-diagonals-of-3) (sw-ne-diagonals-of-3)))\n(lines-of-4 [] (concat (rows-of-4) (columns-of-4) (diagonals-of-4)))\n(lines-of-3 [] (concat (rows-of-3) (columns-of-3) (diagonals-of-3)))\n(all-lines-forward [] (concat (lines-of-4) (lines-of-3)))\n(all-lines-backward [] (map reverse (all-lines-forward)))\n(all-lines [] (concat (all-lines-forward) (all-lines-backward)))\n(line-values [board line] (map #(get-in board %) line))\n(all-lines-with-values [board] (map #(hash-map :values (line-values board %) :positions %) (all-lines)))\n(all-lines-with-value-strings [board] (map #(assoc % :string (apply str (:values %))) (all-lines-with-values board)))\n(lines-with-legal-move [board side]\n\t(let\n\t\t[\n\t\tregexp\n\t\t(if\n\t\t\t(= 'w side)\n\t\t\t#\"eb+w\"\n\t\t\t#\"ew+b\"\n\t\t)\n\t\t]\n\t(filter\n\t\t:match\n\t\t(map\n\t\t\t#(assoc % :match (first (re-seq regexp (:string %))))\n\t\t\t(all-lines-with-value-strings board)\n\t\t)\n\t)\n))\n(index-of-match [{:keys [string, match]}] (.indexOf string match))\n(move-position [{:keys [positions, string, match] :as m}] (assoc m :move-position (first (drop (index-of-match m) positions))))\n(flipped-positions [{:keys [positions, string, match] :as m}] (assoc m :flipped-positions (take (- (count match) 2) (drop (inc (index-of-match m)) positions))))\n(moves-and-flips [board side] (map (comp move-position flipped-positions) (lines-with-legal-move board side)))\n(distinct-moves-and-flips [board side] (distinct (map #(dissoc % :positions :values :string) (moves-and-flips board side))))\n(analyze-reversi [board side] (apply hash-map (mapcat #(vector (:move-position %) (set (:flipped-positions %))) (distinct-moves-and-flips board side))))\n] (analyze-reversi board side)))", "problem": 124, "user": "52f10094e4b05e3f0be25ee8"}, {"code": "(fn analyse-reversi [board player]\n  (let [\n  \n  check     (fn[[y x :as piece]] (get-in board piece))\n  \n  enemy     ({'w 'b, 'b 'w} player) \n  \n  rows      (for [i [0 1 2 3]] (for [j [0 1 2 3]] [j i]))\n  \n  collumns  (for [i [0 1 2 3]] (for [j [0 1 2 3]] [i j]))\n  \n  diagonal  (for [i [0 1 2 3]] [i i])\n\n  adiagonal (for [i [0 1 2 3]] [i (- 3 i)])\n  \n  lines     (concat rows collumns [diagonal adiagonal])\n  \n  empty-space 'e \n  \n  analyse-line \n   (fn[line]\n     (loop [[pcoord & ls] line \t\t;states :\n             state     0        \t;0 = hasn't found a player piece yet.\n             flipped  #{}       \t;1 = found a player piece before finding a enemy piece.\n             move     nil      ] \t;2 = found a enemy piece after finding a player piece.\n                                \t;3 = found empty space before finding a player piece.\n                                 \t;4 = found a enemy piece after finding empty space.\n                                 \t\n     (let [piece (check pcoord)] \t\n       (cond\n         (nil? piece) nil ;reached the end of the collumn.\n                          \n         (= piece player) ;found a player piece.\n           (case state\n               (0 1 3) (recur ls 1 flipped move)\n                  4    [move flipped]\n                 nil)\n                           \n         (= piece enemy) ;found a enemy piece.\n           (case state\n                  0   nil\n                (1 2) (recur ls 2 (conj flipped pcoord) move)\n                (3 4) (recur ls 4 (conj flipped pcoord) move))\n                             \n         (= piece empty-space) ;found a enemy piece.\n           (case state\n                 0 (recur ls 3 flipped pcoord)\n                 1 nil\n                 2 [pcoord flipped]\n                 3 (recur ls 3 flipped pcoord)\n                 4 nil)))))]\n                 \n                 \n      (into {} (for [line lines]\n                 (analyse-line line)))))", "problem": 124, "user": "52f818a6e4b047fd55836fcc"}, {"code": "(let [opp {'w 'b 'b 'w}\n\n      attack-line \n      (fn [board cell dir color] \n        (let [[here & there] (iterate (partial map + dir) cell)\n              [maybe more] (split-with #(= (opp color) (get-in board %)) there)] \n            (if (= (get-in board (first more)) color) \n              (seq maybe)\n              nil)))]\n\n  (fn moves [board color]\n    (apply merge\n      (for \n        [i (range 4)\n         j (range 4)\n         :when (= 'e (get-in board [i j]))\n         u [-1 0 1]\n         v [-1 0 1]\n         :when (not= 0 u v)\n         :let [capture (attack-line board [i j] [u v] color)]\n         :when (seq capture)]\n        {[i j] (set capture)}))))", "problem": 124, "user": "50d0d4c8e4b00b15ecee976a"}, {"code": "(fn [board side] (letfn [\n(find-coords [board side]\n  (filter #(= side (get-in board %)) (for [i (range 4) j (range 4)] [i j])))\n\n(lined-up? [pos1 pos2]\n  (or (= (first pos1) (first pos2))\n      (= (second pos1) (second pos2))\n      (apply = (map #(Math/abs %) (map - pos1 pos2)))))\n\n(step-toward [pos1 pos2]\n  (let [delta (map - pos2 pos1)\n        div (->> delta (remove zero?) first Math/abs)]\n    (map #(/ % div) delta)))\n\n(pair-range [pos1 pos2 delta]\n  (take-while #(not= pos2 %) (iterate #(map + delta %) pos1)))\n\n(valid-move? [board side [pos1 pos2]]\n  (if-not (lined-up? pos1 pos2) false\n          (let [op-side (if (= side 'w) 'b 'w)\n                delta (step-toward pos1 pos2)\n                path (rest (pair-range pos1 pos2 delta))\n                symbs (map #(get-in board %) path)]\n            (if (empty? symbs) false\n                (reduce #(and %1 %2) true (map #(= op-side %) symbs))))))\n\n(move-lines [board side]\n  (filter #(valid-move? board side %)\n          (for [start (find-coords board side)\n                end (find-coords board 'e)]\n            [start end])))\n\n(middles [pairs]\n  (let [deltas (map #(apply step-toward %) pairs)\n        range-args (map #(conj %1 %2) pairs deltas)]\n    (map #(rest (apply pair-range %)) range-args)))]\n  (let [moves (move-lines board side)\n        flips (middles moves)]\n    (apply hash-map (interleave (map last moves) (map set flips))))))", "problem": 124, "user": "524ae8e6e4b09eba1c0223b5"}, {"code": "(fn analyse-reversi [board player]\n\t(letfn [(empty-cells [board]\n\t\t\t\t(let [size (count board)]\n\t\t\t\t\t(for [x (range size) \n\t\t\t\t\t\t  y (range size)\n\t\t\t\t\t\t  :when (= 'e (nth (nth board x) y))]\n\t\t\t\t\t\t[x y]\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t\t(find-moves-in-direction[board player position direction]\n\t\t\t\t(let [size (count board)\n\t\t\t\t\t  x-dir (first direction)\n\t\t\t\t\t  y-dir (second direction)\n\t\t\t\t\t  x-pos (first position)\n\t\t\t\t\t  y-pos (second position)\n\t\t\t\t\t  x-comp (if (= x-dir 1) < >=)\n\t\t\t\t\t  y-comp (if (= y-dir 1) < >=)\n\t\t\t\t\t  x-bound (if (= x-dir 1) size 0)\n\t\t\t\t\t  y-bound (if (= y-dir 1) size 0)\n\t\t\t\t\t]\n\t\t\t\t\t(loop [curr-x (+ x-pos x-dir) curr-y (+ y-pos y-dir) results [] ]\n\t\t\t\t\t\t(if (and (x-comp curr-x x-bound)\n\t\t\t\t\t\t\t\t (y-comp curr-y y-bound))\n\t\t\t\t\t\t\t(let [val (nth (nth board curr-x) curr-y)]\n\t\t\t\t\t\t\t\t(condp = val\n\t\t\t\t\t\t\t\t\t'e  []\n\t\t\t\t\t\t\t\t\tplayer (if (> (count results) 0) results [])\n\t\t\t\t\t\t\t\t\t(recur (+ curr-x x-dir) (+ curr-y y-dir) (conj results [curr-x curr-y]))\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t)\t\n\t\t\t\t\t\t\t;else\n\t\t\t\t\t\t\t[]\t\t\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t\t(move-results [board player position]\n\t\t\t\t[position (into #{} (mapcat #(find-moves-in-direction board player position %) [[0 1] [1 0] [-1 0] [0 -1] [1 1] [1 -1] [-1 -1] [-1 1]]))] \n\t\t\t)\n\t\t\t\n\t\t]\n\t\t(into {} (filter #(not= #{} (second %)) (map #(move-results board player %) (empty-cells board))))\n\t)\n)", "problem": 124, "user": "52763696e4b03e8d9a4a74d7"}, {"code": "(fn [g w]\n  (let [b ({'w 'b 'b 'w} w)\n        g #(get-in g %)\n        R range\n        r (R 4)]\n    (into {}\n          (for [x r y r\n                :when (= 'e (g [x y]))\n                :let [c [x y]\n                      r (R -1 2)\n                      s (reduce\n                          into #{}\n                          (for [i r j r :when (not= [0 0] [i j])]\n                            (loop [f #(map + [i j] %) c (f c) s []]\n                              (condp = (g c)\n                                b (recur f (f c) (conj s c))\n                                w s\n                                []))))]\n                :when (seq s)]\n            {c s}))))", "problem": 124, "user": "52b453b0e4b0c58976d9ad21"}, {"code": "(fn [board piece]\n  (letfn [(step [op-piece start gap result]\n            (let [next-start (mapv #(+ %1 %2) start gap)\n                  next-piece (get-in board next-start)]\n              (if (= next-piece op-piece)\n                (step op-piece next-start gap (conj result next-start))\n                (if (= next-piece 'e)\n                  (if (seq result)\n                    {next-start (set result)}\n                    {})\n                  {}))))]\n    (apply\n      merge\n      (mapcat\n        #(map\n           (fn [gap] (step (if (= piece 'w) 'b 'w) % gap []))\n           [[0 1] [0 -1] [1 0] [-1 0] [1 1] [-1 -1] [1 -1] [-1 1]])\n        (filter #(= piece (get-in board %)) (mapcat #(map (fn [ele] [% ele]) (range 0 4)) (range 0 4)))))))", "problem": 124, "user": "50436470e4b034ff00315d23"}, {"code": "(fn valid-moves [board p]\n  (letfn [(rays [pos board]\n                (let [dirs [[-1 0] [-1 1] [0 1] [1 1] [1 0] [1 -1] [0 -1] [-1 -1]]]\n                  (for [d dirs\n                        :let [positions (->> (iterate (partial mapv + d) pos)\n                                             next\n                                             (take 4))]]\n                    positions)))\n          (values [board ray]\n                  (for [p ray\n                        :let [v (get-in board p)]\n                        :when v]\n                    v))\n          (other-player [p]\n                        ({'w 'b, 'b 'w} p))\n          (flipped-pieces [p board ray]\n                          (let [q (other-player p)\n                                vs (values board ray)\n                                [q-pieces & others] (split-with (partial = q) vs)\n                                flipped-count (if (= p (first (first others)))\n                                                (count q-pieces)\n                                                0)]\n                            (take flipped-count ray)))\n          (valid-moves-at [p board pos]\n                          (mapcat (partial flipped-pieces p board)\n                                  (rays pos board)))]\n    (let [positions (for [x (range 4)\n                          y (range 4)\n                          :when (= 'e (get-in board [x y]))]\n                      [x y])]\n      (->> positions\n           (map (partial valid-moves-at p board))\n           (map set)\n           (map vector positions)\n           (filter (comp not-empty second))\n           (into {})))))", "problem": 124, "user": "5326c5f7e4b09d4e7a9b54f2"}, {"code": "(fn [board player]\n  (let [opponent \n          (case (keyword player) :w 'b :b 'w)\n        empty-positions \n          (for [y (range 4), x (range 4)\n                :when (= 'e (get-in board [y x]))] \n            [y x])\n    \tdirections \n          (for [y (range -1 2), x (range -1 2)\n                :when (not= x y 0)]  \n            [y x])]\n    (reduce \n       (fn [result empty-pos] \n         (let [flipped-positions \n               \t(->> directions\n                    (map (fn [dir]\n                      (take-while \n                        (fn [pos] (every? #(<= 0 % 3) pos)) \n                        (drop 1 (iterate #(map + % dir) empty-pos)))))\n                    (remove empty?)\n                    (map (fn [positions]\n                      (let [posstr (reduce #(str %1 (get-in board %2)) \"\" positions)\n                            pattern (re-pattern (str \"(\" opponent \"*)\" player \".*\"))\n                            match (re-matches pattern posstr)]\n                        (if match (take (count (second match)) positions)))))  \n                    (reduce #(reduce conj %1 %2) #{}))]\n\n             (if (empty? flipped-positions) result\n                 (assoc result empty-pos flipped-positions))))\n     \n      {} empty-positions)))", "problem": 124, "user": "53300924e4b019098a6f8b55"}, {"code": "(fn [b p]\n  (let [o (if (= p 'b) 'w 'b)\n        b (apply vector (apply concat b))\n        e (map first (filter #(= 'e (second %)) (map-indexed #(list %1 %2) b)))\n        g (fn g [i di]\n            (let [i (+ i di) e (get b i)]\n              (if (= e o)\n                (let [r (g i di)]\n                  (if r (cons i r)))\n                (if (= e p)\n                  '() ))))\n        f (fn [i di]\n            (let [i (+ i di) e (get b i)]\n              (if (= e o)\n                (let [r (g i di)]\n                  (if r (cons i r)) ))))\n        \n        h (map (fn [x] (map #(f x %) [1 3 4 5 -1 -3 -4 -5])) e)\n        xy #(vector (quot % 4)(mod % 4))\n        k (map xy e)\n        v (map #(set (map xy %) ) (map (comp flatten (partial filter identity)) h))\n        m (zipmap k v)]\n    (select-keys m (map first (remove (comp empty? second) m)))))", "problem": 124, "user": "5349ac2be4b084c2834f4a67"}, {"code": "(fn [b p]\n  (let [q (range (count b))\n        e (fn [[x y] b]\n           (let [n (fn [k] (if-let [v (get-in b k)] [k v]))\n                 k (fn [f] (keep #(n (f %)) q))]\n             [(k #(vector x %))\n              (k #(vector % y))\n              (k #(vector (+ (- x y) %) (+ (- x y) %)))\n              (k #(vector %             (- (+ x y) %)))]))\n\n        k (fn [xs] (partition 3 1 (partition-by second xs)))]\n\n    (into {}\n          (for [x q y q :when (= p (get-in b [x y])) ; player's stones\n                t (e [x y] b)           ; get paths from player's stone\n                [[[ln l]] c [[rn r]]] (k t)  ; get valid plays\n                :when (or (= 'e l) (= 'e r)) ; on paths\n                :let  [c (set (map first c))]]\n            (cond\n             (= p r) [ln c]\n             (= p l) [rn c]\n             :else nil)))))", "problem": 124, "user": "52d2ca1ce4b099d49816f0b4"}, {"code": "(fn [b c]\n  (let [o (cond (= 'b c) 'w (= 'w c) 'b)\n        d [[0 1] [0 -1] [1 0] [-1 0] [1 1] [-1 -1] [1 -1] [-1 1]]\n        g (fn [p] (nth (nth b (first p) []) (last p) 0))\n        s (fn [p]\n            (apply (comp #(if (empty? %) nil (set %)) concat)\n             (map (comp\n                   #((fn fo [r v]\n                       (let [v1 (first v)\n                             vv (first v1)]\n                         (cond\n                          (= o vv) (fo (conj r (last v1)) (rest v))\n                          (= c vv) r))) nil %)\n                   #(map (fn [p] [(g p) p]) %)\n                   (fn [p d] (rest (iterate #(->> % (map + d) vec) p))))\n                  (repeat p) d)))]\n    (apply conj {}\n          (for [x (-> b first count range)\n                y (-> b count range)]\n            (let [p [x y]]\n              (if (= 'e (g p))\n                (if-let [ss (s p)]\n                  [p ss])))))))", "problem": 124, "user": "53460d02e4b084c2834f4a39"}, {"code": "(fn [b p]\n  (->> (for [r (range 4)\n             c (range 4)\n             :when (= 'e (get-in b [r c]))]\n         [[r c] (set\n                 (apply concat\n                        (for [[s d] [[-1 -1] [-1 0] [-1 1] [0 -1]\n                                     [0 1] [1 -1] [1 0] [1 1]]]\n                          (loop [t (+ r s)\n                                 e (+ c d)\n                                 x #{}]\n                            (let [v (get-in b [t e])]\n                              (cond\n                               (or (nil? v) (= 'e v)) #{}\n                               (= p v) x\n                               :default (recur (+ t s)\n                                               (+ e d)\n                                               (conj x [t e]))))))))])\n       (filter #(seq (% 1)))\n       (apply concat)\n       (apply hash-map)))", "problem": 124, "user": "535d910ae4b04ce2eb3ed2c5"}, {"code": "(letfn [(directions\n           [size xy]\n           (->> [[-1 0] [0 1] [-1 1] [-1 -1]\n                 [0 -1] [1 0] [1 -1] [1 1]]\n                (map (partial partial map +))\n                (map #(rest (iterate % xy)))\n                (map (partial take-while\n                              (fn [[x y]]\n                                (and (< -1 x size)\n                                     (< -1 y size)))))))\n\n          (flip?\n           [board player xy]\n           (->> (get-in board xy)\n                #{'e player}\n                not))\n          \n          (flips\n           [board player direction]\n           (when (->> direction\n                      (map (partial get-in board))\n                      (some #{player}))\n             (-> (partial flip? board player)\n                 (take-while direction))))]\n\n   (fn reversi\n     [board player]\n     (let [size (count board)]\n       (->> (for [x (range size), y (range size)] [x y])\n            (filter (comp #{'e} (partial get-in board)))\n            (map #(-> [% (mapcat (partial flips board player)\n                                 (directions size %))]))\n            (filter (comp seq second))\n            (map (juxt first (comp set second)))\n            (into {})))))", "problem": 124, "user": "532ab0bde4b09d4e7a9b5527"}, {"code": "(fn get-all-moves [board piece]\n  (let [empty-cells (for [row (range 4) \n                          column (range 4)\n                          :when (= 'e (get-in board [row column]))]\n                      [row column])\n        directions (for [x [-1 0 1] y [-1 0 1]] [y x])\n        get-line (fn [start [row-inc column-inc]]\n                   (loop [[row column] start \n                           coords []]\n                     (let [coord [(+ row row-inc) (+ column column-inc)]\n                           occupant (get-in board coord)]\n                       (cond \n                         (nil? occupant) []\n                         (= 'e occupant) []\n                         (= piece occupant) coords\n                         :else (recur coord (conj coords coord))))))\n        get-move-result (fn [c]\n                          (let [lines (map #(get-line c %) directions)]\n                            [c (into #{} (apply concat lines))]))]\n    (let [moves-per-cell (map get-move-result empty-cells)]\n      (into {} (filter (fn [[k v]] (seq v)) moves-per-cell)))))", "problem": 124, "user": "53513d28e4b084c2834f4ae3"}, {"code": "(fn [board color]\n  (let [rearrange (fn [offs mat] (concat (map #(concat (repeat % 'x) %2 (repeat (- 5 %) 'x)) offs mat) [(repeat 9 'x)]))\n        reverse-mat (fn [mat] (map reverse mat))\n        transpose (fn [mat] (apply map vector mat))\n        transformations [(partial rearrange (repeat 1))]\n        transformations (concat transformations (map #(comp transpose (partial rearrange %)) [(repeat 1) (range 1 5) (range 4 0 -1)]))\n        transformations (concat transformations (map (partial comp reverse-mat) transformations))\n        coords (for [x (range 4)] (for [y (range 4)] [x y]))\n        flat-board (apply str (flatten (map #(% board) transformations)))\n        flat-coords (mapcat identity (mapcat #(% coords) transformations))\n        proc-board (clojure.string/replace flat-board \n                                           (if (= color 'b) #\"e(?:w+)b\" #\"e(?:b+)w\")\n                                           #(str 'a (apply str (repeat (- (count %) 2) 'c)) color))\n        [[_ first-key] & rst] (filter #(#{\\a \\c} (first %)) (map vector proc-board flat-coords))\n        sort-out (fn [[acc curr-key] [sym coord]] \n                   (if (= \\a sym) \n                     [acc coord] \n                     [(assoc acc curr-key (conj (acc curr-key #{}) coord)) curr-key]))]\n    (first (reduce sort-out [{} first-key] rst))))", "problem": 124, "user": "52dd4fb4e4b09f7907dd13df"}, {"code": "(fn [board ptype]\n  (letfn [(find-els [m el]\n            (let [rowinds (filter #(some (fn [x] (= x el)) (nth m %)) (range (count m)))\n                  colindf (fn [r] (filter #(= el (nth (nth m r) %)) (range (count (first m)))))\n                  rcf (fn [r] (map #(vector r %) (colindf r)))]\n              (mapcat rcf rowinds)))\n          (lrdiag-plus [p] (map #(vector (- (first p) %) (+ (second p) %)) (rest (range))))\n          (lrdiag-minus [p] (map #(vector (+ (first p) %) (- (second p) %)) (rest (range))))\n          (rldiag-plus [p] (map #(vector (+ (first p) %) (+ (second p) %)) (rest (range))))\n          (rldiag-minus [p] (map #(vector (- (first p) %) (- (second p) %)) (rest (range))))\n          (horplus [p] (map #(vector (first p) (+ (second p) %)) (rest (range))))\n          (horminus [p] (map #(vector (first p) (- (second p) %)) (rest (range))))\n          (verplus [p] (map #(vector (+ (first p) %) (second p)) (rest (range))))\n          (verminus [p] (map #(vector (- (first p) %) (second p)) (rest (range))))\n          (line [p lf ps] (take-while (fn [x] (some #(= % x) ps)) (lf p)))\n          (sps [m el]\n            (let [typesps '[b w e]\n                  sortedps (zipmap typesps (map #(find-els m %) typesps))\n                  other (first (remove #(or (= el %) (= 'e %)) typesps))\n                  [spo spel spe] [(sortedps other) (sortedps el) (sortedps 'e)]\n                  funcv [lrdiag-plus lrdiag-minus rldiag-plus rldiag-minus horplus horminus verplus verminus]\n                  lp (fn [p lf] (let [lspo (line p lf spo)]\n                                 (cond\n                                  (empty? lspo) []\n                                  (empty? (line (last lspo) lf spel)) []\n                                  :else lspo)))\n                  lspof (fn [p] (let [ps (mapcat #(lp p %) funcv)]\n                                 (if (empty? ps) {} {p (set ps)})))]\n              (apply merge (map lspof spe))))]\n    (sps board ptype)))", "problem": 124, "user": "5133e51ae4b0d7a043de8cf6"}, {"code": "(fn reversi [grid player]\n  (letfn [(lines-from [[row col]]\n                      [\n                       (for [i (range row 4)] [i col])\n                       (for [i (range row -1 -1)] [i col])\n                       (for [i (range col 4)] [row i])\n                       (for [i (range col -1 -1)] [row i])\n                       (for [k (range 0 4) :let [i (+ row k), j (+ col k)] :when (and (< i 4) (< j 4))] [i j])\n                       (for [k (range 0 4) :let [i (+ row k), j (- col k)] :when (and (< i 4) (>= j 0))] [i j])\n                       (for [k (range 0 4) :let [i (- row k), j (+ col k)] :when (and (>= i 0) (< j 4))] [i j])\n                       (for [k (range 0 4) :let [i (- row k), j (- col k)] :when (and (>= i 0) (>= j 0))] [i j])\n                       ])\n          (turned [acc [c & cs]]\n                  (if (nil? c)\n                    []\n                    (let [p (get-in grid c)]\n                      (cond (= p player) acc\n                            (= p 'e) []\n                            :else (recur (conj acc c) cs)))))\n          (turned-from [coord]\n                       (->> coord\n                            (lines-from)\n                            (map rest)\n                            (map (partial turned []))\n                            (filter (complement empty?))\n                            (mapcat identity)\n                            (set)))]\n    (let [coords (for [row (range 0 4)\n                       col (range 0 4)]\n                   [row col])\n          empty-coords (filter #(= 'e (get-in grid %)) coords)]\n      empty-coords\n      (->> empty-coords\n           (map #(vector % (turned-from %)))\n           (filter #(not (empty? (second %))))\n           (mapcat identity)\n           (apply hash-map)\n           ))))", "problem": 124, "user": "536ca4bde4b0fc7073fd6e49"}, {"problem": 124, "code": "(fn [bd p] (letfn[(count-p [x y [i j]] (loop [a (+ x i) b (+ y j) res #{}]\n                                       (if (or (or (< a 0) (> a 3))\n                                               (or (< b 0) (> b 3))\n                                               (= (get-in bd [b a]) 'e)) #{}\n                                         (if (= (get-in bd [b a]) p) res\n                                           (recur (+ a i) (+ b j) (if (not= (get-in bd [b a]) p)\n                                                                    (conj res [b a])\n                                                                    res))))))\n                  (check [x y] (let [moves [[-1 0] [-1 -1] [0 -1] [1 -1] [1 0] [1 1] [0 1] [-1 1]]]\n                                 (set (reduce #(into %1 %2) #{} (map #(count-p x y %) moves)))))]\n             (loop [a 0 b 0 res {}]\n               (if (= b 4) res\n                 (recur (if (= a 3) 0 (inc a))\n                        (if (= a 3) (inc b) b)\n                        (if (= (get-in bd [b a]) 'e)\n                          (if (empty? (check a b))\n                            res\n                            (assoc res [b a] (check a b)))\n                          res))))))", "user": "53a1b5c8e4b0ca733b9744c1"}, {"problem": 124, "code": "(fn [board color]\n  (let [coords (for [i (range 4) j (range 4)] [i j])\n        brd-map (zipmap coords (flatten board))\n        filter-coords (fn [c] (filter #(= c (brd-map %)) coords))\n        in-line? (fn [[[r c] [i j]]] (or (= r i) (= c j) (= 1 (quot (Math/abs (- r i)) (Math/abs (- c j))))))\n        free-coords (filter-coords 'e)\n        color-coords (filter-coords color)\n        dir (fn [[[r c] [i j]]] (let [di (- i r) dj (- j c)] [(quot di (Math/abs ({0 1} di di))) (quot dj (Math/abs ({0 1} dj dj)))]))\n        add (fn [[r c] [i j]] [(+ r i) (+ c j)])\n        between (fn [[f l]] (let [d (dir [f l])] (take-while #(not= l %) (iterate #(add % d) (add d f)))))\n        all-other-color? (fn [cs] (and (false? (empty? cs)) (every? #(= ({'w 'b 'b 'w} color) (brd-map %)) cs)))\n        lines (filter in-line? (for [f free-coords c color-coords] [f c]))]\n    (reduce #(assoc %1 (first %2) (set (second %2))) {} (filter #(all-other-color? (second %)) (map #(vector (first %) (between %)) lines)))))", "user": "52d07cc5e4b07d0d72b273bb"}, {"problem": 124, "code": "(fn [board piece]\n  (letfn [(step [op-piece start gap result]\n            (let [next-start (mapv #(+ %1 %2) start gap)\n                  next-piece (get-in board next-start)]\n              (if (= next-piece op-piece)\n                (step op-piece next-start gap (conj result next-start))\n                (if (= next-piece 'e)\n                  (if (seq result)\n                    {next-start (set result)}\n                    {})\n                  {}))))]\n    (apply\n      merge\n      (mapcat\n        #(map\n           (fn [gap] (step (if (= piece 'w) 'b 'w) % gap []))\n           [[0 1] [0 -1] [1 0] [-1 0] [1 1] [-1 -1] [1 -1] [-1 1]])\n        (filter #(= piece (get-in board %)) (mapcat #(map (fn [ele] [% ele]) (range 0 4)) (range 0 4)))))))", "user": "53976599e4b0b51d73faaeea"}, {"problem": 124, "code": "(fn rmoves [board p]\n  (let [find-empties (fn find-empties [board]\n                    ; given a board, return a list of the coords of all its empty positions                                                                            \n                    ; (the returned value is a list of vectors; each vector is of the form [r c])                                                                      \n                       (for [r (range (count board))\n                             c (range (count (board r)))\n                             :when (= 'e (get-in board [r c]))]\n                         [r c]))\n\n        directions (fn directions [board [r c] p]\n                    ; given a board, and the coordinates of a position on the board, and a piece value p,                                                              \n                    ; return a set of directions from the given position where the next neighbor                                                                       \n                    ; contains a piece of value p                                                                                                                      \n                      (set (for [i (range -1 2) j (range -1 2)\n                                 :let [nr (+ r i) nc (+ c j)]\n                                 :when (and (not= i j 0)\n                                            (>= nr 0) (>= nc 0)\n                                            (< nr (count board)) (< nc (count (board nr)))\n                                            (= (get-in board [nr nc]) p))]\n                             [i j])))\n\n        flip (fn flip\n                    ; given a board, and a goal piece value g, and a board position and direction,                                                                     \n                    ; return the set of the coordinates of all pieces that would be flipped by                                                                         \n                    ; placing a piece of value g in the given position, and heading in the given direction.                                                            \n               ([board g [r c] [dr dc]]          (flip board g [r c] [dr dc] #{}))\n               ([board g [r c] [dr dc] flipped]\n                  (let [nr (+ r dr)\n                        nc (+ c dc)]\n                    (cond\n                     (or (>= nr (count board))\n                         (< nr 0)\n                         (>= nc (count (board nr)))\n                         (< nc 0))   #{}     ; ran off edge without getting to g piece                                                                                 \n                         (= 'e (get-in board [nr nc]))                             #{}     ; encountered 'e without getting to g piece                                 \n                         (= g (get-in board [nr nc]))                              flipped ; reached a g piece                                                         \n                         :else (flip board g [nr nc] [dr dc] (conj flipped [nr nc]))))))\n\n        empties          (find-empties board)\n        other            (if (= p 'w) 'b 'w)\n        posdirs          (mapcat (fn [pos] (map (fn [dir] [pos dir]) (directions board pos other))) empties)]\n    (apply hash-map\n           (apply concat\n                  (filter (fn [[pos dirs]] (not-empty dirs))\n                          (map (fn [[[r c] [dr dc]]] [[r c] (flip board p [r c] [dr dc])]) posdirs))))))", "user": "530bf87ee4b02e82168697d5"}, {"problem": 124, "code": "(fn\n  [board color]\n  (letfn [(pieces-flipped-in-direction\n            [a prev-row prev-col drow dcol]\n            (let [row (+ prev-row drow)\n                  col (+ prev-col dcol)]\n              (if (and (>= row 0)\n                       (>= col 0)\n                       (< row 4)\n                       (< col 4))\n                (let [c (get-in board [row col])]\n                  (condp = c\n                    'e nil\n                    color a\n                    (recur (conj a [row col]) row col drow dcol)))\n                nil)))\n          (pieces-flipped-by-move\n            [row col]\n            (if (= 'e (get-in board [row col]))\n              (for [drow [-1 0 1]\n                    dcol [-1 0 1]\n                    :when (or (not= 0 drow)\n                              (not= 0 dcol))\n                    :let [flipped (pieces-flipped-in-direction\n                                    []\n                                    row\n                                    col\n                                    drow\n                                    dcol)]\n                    :when (seq flipped)]\n                flipped)\n              nil))]\n    (apply hash-map\n      (reduce\n        (fn [a [k v]]\n          (conj a k v))\n        []\n        (for [row (range 4)\n              col (range 4)\n              :let [flipped (pieces-flipped-by-move row col)]\n              :when (seq flipped)]\n              [[row col] (apply set flipped)])))))", "user": "52dfc89be4b09f7907dd1405"}, {"problem": 124, "code": "(fn reversi [b c]\n  (letfn [(is-valid [[x y]]\n                    (and (>= x 0) (>= y 0) (< x 4) (< y 4)))\n          (valid-moves [[x y] fx fy]\n                       (if (is-valid [x y])\n                         (cons [x y] (valid-moves [(fx x) (fy y)] fx fy))))]\n    (let [moves (fn [[x y]]\n                  (for [fx [inc dec identity]\n                        fy [inc dec identity]\n                        :when (not= identity fx fy)]\n                    (rest (valid-moves [x y] fx fy))))\n          with-color (fn [b xys]\n                       (map (fn [[x y]] [x y (get-in b [x y])]) xys))\n          flip (fn [c so-far [[x y c2] & cs]]\n                 (cond\n                   (= c c2) so-far\n                   (or (nil? c2) (= c2 'e)) nil\n                   :else\n                   (recur c (conj so-far [x y]) cs)))\n          all-empties (for [x (range 4)\n                            y (range 4)\n                            :when (= (get-in b [x y]) 'e)]\n                        [x y])]\n      (into {} (keep (fn [xy]\n                       (let [vms (map #(with-color b %) (moves xy))\n                             flip-cords (mapcat #(flip c [] %) vms)]\n                         (when (seq flip-cords)\n                           [xy (set flip-cords)])))\n                     all-empties)))))", "user": "50921f9ae4b09a7d0b586de1"}, {"problem": 124, "code": "(fn [b d]\n  (let [o (if (= d 'w) 'b 'w)\n        m {[d o o 'e] [3 #{1 2}]\n               ['e o o d] [0 #{1 2}]\n               [d o 'e] [2 #{1}]\n               ['e o d] [0 #{1}]}\n        g (fn [coll]\n                    (->> (partition 3 1 coll)\n                         (map-indexed\n                           #(when-let [[mi f] (m %2)]\n                             [(+ mi %) (map (partial + %) f)]))\n                         (cons (m coll))\n                         (remove nil?)))\n        h (fn [r]\n                        (->> (b r)\n                             g\n                             (map\n                               (fn [[x z]]\n                                 [[r x]\n                                  (set (map #(vector r %) z))]))))\n        i (fn [c]\n                           (->> b\n                                (map #(nth % c))\n                                g\n                                (map\n                                  (fn [[y z]]\n                                    [[y c]\n                                     (set (map #(vector % c) z))]))))\n        j (fn [llur]\n                          (let [max-y (min llur 3)\n                                min-x (max 0 (- llur 3))]\n                            (->>\n                              (map\n                                vector\n                                (reverse (range 0 (inc max-y)))\n                                (range min-x 4))\n                              (map #(get-in b %))\n                              g\n                              (map\n                                (fn [[n z]]\n                                  [[(- max-y n) (+ min-x n)]\n                                   (set (map #(vector (- max-y %) (+ min-x %)) z))])))))\n        k (fn [ullr]\n                          (let [min-y (max 0 (- 3 ullr))\n                                min-x (max 0 (- ullr 3))]\n                            (->>\n                              (map\n                                vector\n                                (range min-y 4)\n                                (range min-x 4))\n                              (map #(get-in b %))\n                              g\n                              (map\n                                (fn [[n z]]\n                                  [[(+ min-y n) (+ min-x n)]\n                                   (set (map #(vector (+ min-y %) (+ min-x %)) z))])))))\n        l (->>\n                       (range 7)\n                       (mapcat k)\n                       (into {}))\n        m (->>\n                       (range 7)\n                       (mapcat j)\n                       (into {}))\n        n (->>\n                      (range 4)\n                      (mapcat h)\n                      (into {}))\n        p (->>\n                         (range 4)\n                         (mapcat i)\n                         (into {}))]\n    (merge-with\n      into\n      n\n      p\n      l\n      m)))", "user": "51b3f109e4b0f094dd986fa9"}, {"problem": 124, "code": "(fn task-124 [m b]\n  (let [H (count m) W (count (first m))\n        a (if (= b 'w) 'b 'w)\n\n        coord\n        (fn [X Y x y]\n          (->>\n           (iterate (fn [[a b]] [(+ x a) (+ y b)] ) [X Y])\n           identity\n           rest\n           (take-while #(get-in m %))))\n\n        possible-line\n        (fn possible-line [m s a b]\n          (let [[as bs] (partition-by #(= b (get-in m %)) s)]\n            (if (and\n                 (apply = (concat [a] (map #(get-in m %) as)))\n                 (= b (get-in m (first bs))))\n              as)))\n        \n        to-change\n        (fn [m X Y a b]\n          (->> \n           (for [x [-1 0 1] y [-1 0 1] :when (or (not= x 0) (not= y 0))]\n             (possible-line m (coord X Y x y) a b))\n           (remove nil?)\n           (apply concat)\n           set))\n\n        ]\n    \n    (->>\n     (for [X (range W) Y (range H)]\n       (if (= 'e (get-in m [X Y]))\n         [[X Y] (to-change m X Y a b)]))\n     (remove (fn [[a b]] (empty? b)))\n     (into {}))))", "user": "4ddb696b535d02782fcbe9fa"}, {"problem": 124, "code": "(fn reversi [board player]\n  (letfn [(other-tile [original] (first (disj #{'w 'b} original)))\n          (all-empties [b]\n            (for [y (range (count b))\n                  x (range (count b))\n                  :when (= 'e (get-in b [y x]))]\n              [y x]))\n          (update-board [b tile [y x]]\n            (assoc-in b [y x] tile))\n          (neighbor-lines [[y x]]\n            (let [deltas \n                  (let [fs [identity inc dec] self [identity identity]]\n                    (for [f1 fs f2 fs :when (not= self [f1 f2])]\n                      [f1 f2]))] \n            (map (fn [[f1 f2]]\n                   (take 4 (iterate #(vector (f1 (first %)) (f2 (second %))) [y x])))\n                 deltas)))\n          (will-flip [board line]\n            (let [tiles (map #(get-in board [(first %) (second %)]) line)\n                  tileA (first tiles)\n                  tileB (other-tile tileA)\n                  triple [tileA tileB tileA]\n                  quad [tileA tileB tileB tileA]]\n              (cond\n               (= triple (take 3 tiles)) (take 1 (rest line))\n               (= quad (take 4 tiles)) (take 2 (rest line))\n               :else '())))\n          (flips [board origin]\n            (let [nls (neighbor-lines origin)\n                  flipped (mapcat #(will-flip board %) nls)]\n              (vector origin (set flipped))))\n          ]\n    (let [empties (all-empties board)\n          bundles (map #(vector (update-board board player %) %) empties)\n          results (map #(flips (first %) (second %)) bundles)]\n      (into {} (filter #(not= #{} (second %)) results)))))", "user": "53bf0913e4b0c98a41f5cc99"}, {"problem": 124, "code": "(fn reversi [b p]\n  (letfn [(segment [b c d]\n            (take-while first (map #(vector (get-in b %) %) (iterate #(map + % d) c))))\n          (segments [b c]\n            (->> (for [x [-1 0 1] y [-1 0 1] :when (not (= x y 0))] [x y])\n                 (map #(segment b c %))\n                 (map rest)\n                 (filter #(> (count %) 1))))\n          (captured [p s]\n            (let [[a b] (partition-by #(#{'e p} (first %)) s)]\n              (if (and (not= (-> a first first) 'e)\n                       (= (-> b first first) p))\n                (map second a))))]\n    (->> (for [x (range (count b))\n               y (range (count (first b)))\n               :when (= 'e (get-in b [x y]))]\n           (let [f (filter identity (map #(captured p %) (segments b [x y])))]\n             (if (seq f)\n               [[x y] (apply set f)])))\n         (filter identity)\n         (into {}))))", "user": "53b39d82e4b047364c0444a6"}, {"problem": 124, "code": "(fn [board color]\n  (letfn [(gen-left-cors [x y] (map #(vector %1 %2) (range x 4) (range y 4)))\n          (gen-right-cors [x y] (map #(vector %1 %2) (range x 4) (range y -1 -1)))\n          (gen-rows [ ] (for [i (range 0 4)] (for [j (range 0 4)] [i j])))\n          (gen-cols [ ] (for [i (range 0 4)] (for [j (range 0 4)] [j i])))\n          (get-all-cors [] (concat (gen-rows) (gen-cols) \n                                (map (partial apply gen-left-cors) [[1 0] [0 0] [0 1]])\n                                (map (partial apply gen-right-cors) [[0 3] [0 2] [1 3]])))\n\t\t  (move? [x y color] (and (every? #(= (get-in board %) 'e) x) (every? #(= (get-in board %) color) y))) \n          (get-pos [row] (let [row (partition-by (partial get-in board) row)\n                             ops-color (if (= color 'w) 'b 'w)]\n\t\t\t\t\t\t\t (loop [[x y z & _] row]\n\t\t\t\t\t\t\t   (if-not (nil? z)\n\t\t\t\t\t\t\t\t (if (every? #(= (get-in board %) ops-color) y)\n\t\t\t\t\t\t\t\t\t (cond (move? x z color) [(last x) (set y)]\n\t\t\t\t\t\t\t\t\t\t   (move? z x color) [(first z) (set y)]\n\t\t\t\t\t\t\t\t\t\t   :else (recur (rest row)))\n\t\t\t\t\t\t\t\t\t (recur (rest row)))))))]                        \n    (->> (get-all-cors) (map get-pos) (filter identity) (into {}))))", "user": "536f871de4b0fc7073fd6e7f"}, {"problem": 124, "code": "(fn [b p]\n\t(let [traverse (fn [b p [x y] [dx dy] coords] (let [nc [(+ x dx) (+ y dy)]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ttile (get-in b nc)]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(when tile\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(if  (= tile (if (= p 'w) 'b 'w))\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(recur b p nc [dx dy] (conj coords nc))\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(when (and (> (count coords) 0) (= tile p)) coords)))))\n\t\t  flips (fn [b p c] (first (remove nil? (map #(traverse b p c % #{}) [[-1 -1] [0 -1] [1 -1] [-1 0] [1 0] [-1 1] [0 1] [1 1]]))))\n\t\t  won-pieces (fn [b p [x y]] (when (= 'e (get-in b [x y])) (flips b p [x y])))\n\t\t  ]\n\t\t(reduce merge (for [x (range (count b)) y (range (count (first b)))] (if-let [l (won-pieces b p [x y])] {[x y] l} {})))))", "user": "53e19461e4b0d874e779ae59"}, {"problem": 124, "code": "(fn analyze [table_ player] \n  (let [table (map (partial remove (partial = \\space)) table_)\n        get (fn [y x] (nth (nth table y []) x 'e))\n        is-player? (fn [[y x]] (= player (get y x)))\n        is-empty? (fn [[y x]] (= 'e (get y x)))\n        is-counter-player? (fn [[y x]] (not (or (is-player? [y x]) (is-empty? [y x]))))\n        directions [[0 1] [1 1] [1 0] [1 -1] [0 -1] [-1 -1] [-1 0] [-1 1]]\n        coords-in-direction (fn [y x direction]\n                              (->> (range) ;0..\n                                (map inc);1..\n                                (map (fn [n] (map (partial * n) direction))) ;distance vectors\n                                (map (fn [direction-vector] (map + direction-vector [y x]))))) ;new coords\n        legal-placement? (fn [y x direction]\n                           (->> (coords-in-direction y x direction)\n                             (drop-while is-counter-player?) ;drop every counter player pieces\n                             first ;the first piece after\n                             is-player?))\n        turned-pieces (fn [y x direction]\n                        (take-while is-counter-player? (coords-in-direction y x direction)))\n        ]\n     (reduce\n       (fn [result-map [coord turned]]\n         (if (= (result-map coord) nil) (into result-map [[coord #{turned}]])\n           (into result-map [[coord (conj (result-map coord) turned)]])))\n       {}  \n       (for [x (range 4)\n             y (range 4)\n             :when (is-empty? [y x])\n             direction directions\n             :when (legal-placement? y x direction)\n             turned-piece (turned-pieces y x direction)] [[y x] turned-piece]))))", "user": "53c38b8ce4b00fb29b22127b"}, {"problem": 124, "code": "(let [dir-map {:n [identity dec], :s [identity inc], :w [dec identity], :e [inc identity]\n               :ne [inc dec], :se [inc inc], :sw [dec inc], :nw [dec dec]}]\n  (letfn [(gen-paths [b x y d]\n            (let [min-x 0, max-x (dec (count (first b)))\n                  min-y 0, max-y (dec (count b))\n                  [fx fy] (dir-map d)]\n              (letfn [(gp [x y]\n                        (let [xn (fx x), yn (fy y)]\n                          (if (and (>= xn min-x) (<= xn max-x)\n                                   (>= yn min-y) (<= yn max-y))\n                            (cons [yn xn] (lazy-seq (gp xn yn)))\n                            nil)))]\n                (gp x y))))\n\n          (gen-all-paths [b x y]\n            (remove nil? (map #(gen-paths b x y %) (keys dir-map))))\n\n          (is-valid? [board player path]\n            (let [other (if (= 'b player) 'w 'b)]\n              (loop [rm path, opposite-count 0, last-cell nil, acc #{}]\n                (if (empty? rm) (if (= player last-cell) acc nil)\n                    (let [f (first rm)\n                          [x y] f\n                          c (get-in board [x y])]\n                      (cond (= 'e c) (if (and (> opposite-count 0)\n                                              (= last-cell player))\n                                       acc\n                                       nil)\n                            (= other c) (recur (rest rm) (inc opposite-count) other (conj acc f))\n                            :else (recur (rest rm) opposite-count player acc)))))))\n\n          (empty-coords [b]\n            (let [max-x (dec (count (first b)))\n                  max-y (dec (count b))]\n              (loop [acc (list), x 0, y 0]\n                (cond (> y max-y) acc\n                      (> x max-x) (recur acc 0 (inc y))\n                      :else (let [c (get-in b [y x])]\n                              (if (= 'e c)\n                                (recur (conj acc [x y]) (inc x) y)\n                                (recur acc (inc x) y)))))))\n\n          (get-flipped-cells [board player x y]\n            (first (remove nil? (map #(is-valid? board player %) (gen-all-paths board x y)))))\n\n          (analyze-reversi [board player]\n            (loop [rm (empty-coords board), acc {}]\n              (cond (empty? rm) acc\n                    :else (let [f (first rm)\n                                x (nth f 0)\n                                y (nth f 1)\n                                r (get-flipped-cells board player x y)]\n                            (if (or (empty? r) (nil? r))\n                              (recur (rest rm) acc)\n                              (recur (rest rm) (assoc acc [y x] r)))))))]\n    analyze-reversi))", "user": "538e36c7e4b0b51d73faae81"}, {"problem": 124, "code": "(fn [board color]\n    (let [\n      inverted (if (= 'b color) 'w 'b)\n      get-inverts (fn ! [[i j] [di dj] stack]\n        (let [ni (+ i di) nj (+ j dj)]\n          (cond\n           (or (< ni 0) (< nj 0) (> ni 3) (> nj 3)) []\n           (= 'e (get-in board [ni nj])) []\n           (= color (get-in board [ni nj])) stack\n           (= inverted (get-in board [ni nj])) (! [ni nj] [di dj] (conj stack [ni nj]))\n           )))\n          ]\n      (reduce \n       (fn [m [k v]] (assoc m k v))\n       {}\n       (filter (fn [[k v]] (not (empty? v)))\n               (for [i (range 4) j (range 4) :when (= 'e (get-in board [i j]))]\n                 (->>\n                  (map (fn [[di dj]] (get-inverts [i j] [di dj] [])) [[0 1] [0 -1] [1 0] [-1 0] [-1 1] [1 1] [1 -1] [-1 -1]])\n                  (reduce concat [])\n                  (into #{})\n                  (vector [i j])\n                  )))\n       )\n      )\n    )", "user": "5094057fe4b097f48cc38593"}, {"problem": 124, "code": "(fn [board to-move]\n    (let [opp (if (= 'w to-move) 'b 'w)\n          cell-adder (fn [[dx dy]] (fn [[x y]] [(+ x dx) (+ y dy)]))\n          dirs (for [x (range -1 2) y (range -1 2) :when (not= 0 x y)] [x y])\n          dim (count board)\n          all-cells (for [r (range dim) c (range dim)] [r c])\n          bounds-check (fn [[x y]] (and (< -1 x dim) (< -1 y dim)))\n          gen-flips (fn [cell] \n                      (reduce (fn [acc v] (if (seq v) (into acc v) acc)) #{}\n                      (for [d dirs]\n                        (let [cand (for [adder [(cell-adder d)] \n                                         move (iterate adder (adder cell))\n                                         :while (bounds-check move)]\n                                     move)]\n                          #_cand\n                          (if (= (get-in board\n                                           (first (drop-while (fn[%]\n                                                                (#{opp} (get-in board %)))\n                                                              cand)) )\n                                 to-move)\n                            (take-while (fn[%] (#{opp} (get-in board %))) cand))))))]\n\n      (reduce (fn [acc v] (let [moves (gen-flips v)] \n                            (if (seq moves) (assoc acc v moves) acc)))\n              {}\n              (filter #(do (#{'e} (get-in board %))) all-cells))))", "user": "513e8141e4b02b2a3d8235c1"}, {"problem": 124, "code": "(fn [t p1]\n      (let [p2 (if (= p1 'w) 'b 'w)\n            fwd (fn [x]\n                  (cond (pos?  x) inc\n                        (neg?  x) dec\n                        (zero? x) identity))\n            create-forward (fn [[r c] [r1 c1]]\n                             (let [fwd-r (fwd (- r1 r))\n                                   fwd-c (fwd (- c1 c))]\n                               (fn [[r c]] [(fwd-r r) (fwd-c c)])))]\n        (->> (for [r (range 4)\n                   c (range 4)\n                   :when (= 'e (get-in t [r c]))]\n               (->> (for [r1 (range (max (dec r) 0) (inc (min 3 (inc r))))\n                          c1 (range (max (dec c) 0) (inc (min 3 (inc c))))\n                          :let [forward (create-forward [r c] [r1 c1])] \n                          :when (or (not= r r1) (not= c c1))]\n                      (->> [r1 c1]\n                           (iterate forward)\n                           (map #(vector (get-in t %) %))\n                           (split-with #(= p2 (first %)))\n                           ((fn [[matched unmatched]]\n                              (if (and (= p1 (ffirst unmatched))\n                                       (< 0  (count matched)))\n                                (map second matched)\n                                ())))))\n                    (apply concat)\n                    (set)\n                    (vector [r c])\n                    ))\n             (filter (comp not empty? second))\n             (into {}))))", "user": "4f5cc3b8e4b0030a34fb2b2b"}, {"problem": 124, "code": "(fn [b pc]\n     (let [follow (fn [off found loc]\n                    (cond (some neg? loc) nil\n                          (some #(< 4 %) loc) nil\n                          (= 'e (get-in b loc)) nil\n                          (= pc (get-in b loc)) found\n                          :else (recur off (conj found loc) (map + off loc))))]\n       (into {} (remove #(empty? (second %))\n                        (for [c (range 4) r (range 4)]\n                          (let [loc [c r]]\n                            (if (= 'e (get-in b loc))\n                              [loc (set (mapcat (fn [off] (follow off #{} (map + off loc)))\n                                                [[-1 -1] [-1 0] [-1 1]\n                                                 [0 -1] [0 1]\n                                                 [1 -1] [1 0] [1 1]]))])))))))", "user": "5310e968e4b08068f379ecdd"}, {"problem": 124, "code": "(fn [board player]\n    (let [n (count board) ;; assume square board\n          ;; 8 directions:\n          no (fn [[r c]] [(dec r) c])\n          so (fn [[r c]] [(inc r) c])\n          ea (fn [[r c]] [r (inc c)])\n          we (fn [[r c]] [r (dec c)])\n          ne (comp no ea)\n          nw (comp no we)\n          se (comp so ea)\n          sw (comp so we)\n          directions [no so ea we ne nw se sw]                           ;; #3a\n          flips (fn [B [r c] color dirn]\n                  (let [places-on-path (map (juxt (partial get-in B) identity)\n                                            (rest (iterate dirn [r c]))) ;; #4\n                        pieces-on-path (take-while (comp (complement nil?)\n                                                         first)\n                                                   places-on-path)]      ;; #5\n                    (->> pieces-on-path\n                         (partition-by first)                            ;; #6\n                         (take-while #(not= (ffirst %) 'e))\n                         reverse\n                         ((fn [[[[clr-a]] ret]]\n                            (if (and (= clr-a color)                     ;; #7\n                                     (= (ffirst ret) ({'w 'b, 'b 'w} color)))\n                              (map second ret)))))))]\n      (into {} (for [row (range n)\n                     col (range n)\n                     :let [flps (set\n                                 (mapcat (partial flips board [row col] player)\n                                         directions))]                   ;; #3b\n                     :when (and (= (get-in board [row col]) 'e)          ;; #1\n                                (seq flps))]                             ;; #2\n                 [[row col] flps]))))", "user": "4ee26f01535d10e5ff6f5368"}, {"problem": 124, "code": "(fn [board colour]\n  (let [size (count board)\n        empties (for [x (range size)\n                      y (range size)\n                      :when (= 'e (get-in board [x y]))] [x y])\n        flips (fn [s]\n                (loop [[x & xs] (seq s) acc #{}]\n                  (let [piece (get-in board x)]                    \n                    (cond\n                     (= piece 'e) #{}\n                     (nil? x) #{}\n                     (= piece colour) acc\n                     :else (recur xs (conj acc x))))))\n        valid? #(<= 0 % (dec size))\n        f-gen (fn [o f]\n                (let [l-seq (map #(map (partial * %) f) (remove zero? (range)))]\n                  (take-while (partial every? valid?) (map #(vec (map + o %)) l-seq))))\n        functions [[0 1] [0 -1] [1 0] [-1 0] [1 1] [-1 -1] [1 -1] [-1 1]]\n        all (for [e empties f (map (partial f-gen e) functions)] {e (flips f)})] \n    (into {} (remove #(empty? (second %)) (apply merge-with (comp set concat) all)))))", "user": "53c649d3e4b00fb29b221297"}, {"problem": 124, "code": "(fn analyzereversi [b p]\n     (let [v (vec (flatten b))\n           n (if (= p 'w)\n               'b\n               'w)]\n       (if (empty? (filter #(= % 'e) (concat (subvec v 5 7) (subvec v 9 11))))\n         (reduce into {} (map #(apply hash-map %) (for [i (range (count v))\n                                                        j (range (count v))\n                                                        :when (and (= (get v i) p) (= (get v j) 'e)\n                                                                   (or (and (== (mod i 4) (mod j 4))\n                                                                            (< 0 (apply + (for [k (range (inc (min i j)) (max i j))\n                                                                                                :when (== (mod k 4) (mod i 4))]\n                                                                                            (if (= (get v k) n)\n                                                                                              0.2\n                                                                                              -1)))))\n                                                                       (and (== (quot i 4) (quot j 4))\n                                                                            (< 0 (apply + (for [k (range (inc (min i j)) (max i j))]\n                                                                                           (if (= (get v k) n)\n                                                                                             0.2\n                                                                                             -1)))))\n                                                                       (and (== (mod (- i j) 5) 0) (> (mod (max i j) 4) (mod (min i j) 4))\n                                                                            (< 0 (apply + (for [k (range (inc (min i j)) (max i j))\n                                                                                                :when (== (mod (- i k) 5) 0)]\n                                                                                            (if (= (get v k) n)\n                                                                                              0.2\n                                                                                              -1)))))\n                                                                       (and (= (mod (- i j) 3) 0) (> (mod (min i j) 4) (mod (max i j) 4))\n                                                                            (< 0 (apply + (for [k (range (inc (min i j)) (max i j))\n                                                                                                :when (and (== (mod (- i k) 3) 0)\n                                                                                                           (not= (quot i 4) (quot k 4))\n                                                                                                           (not= (quot j 4) (quot k 4)))]\n                                                                                            (if (= (get v k) n)\n                                                                                              0.2\n                                                                                              -1)))))))]\n                                                    (list (vector (quot j 4) (mod j 4)) (set (if (== (mod i 4) (mod j 4))\n                                                                                               (for [k (range (inc (min i j)) (max i j))\n                                                                                                                :when (== (mod k 4) (mod i 4))]\n                                                                                                 (vector (quot k 4) (mod k 4)))\n                                                                                               (if (== (quot i 4) (quot j 4))\n                                                                                                 (for [k (range (inc (min i j)) (max i j))]\n                                                                                                   (vector (quot k 4) (mod k 4)))\n                                                                                                 (if (== (mod (- i j) 5) 0)\n                                                                                                   (for [k (range (inc (min i j)) (max i j))\n                                                                                                           :when (= (mod (- i k) 5) 0)]\n                                                                                                     (vector (quot k 4) (mod k 4)))\n                                                                                                   (for [k (range (inc (min i j)) (max i j))\n                                                                                                           :when (and (= (mod (- i k) 3) 0)\n                                                                                                                      (not= (quot i 4) (quot k 4))\n                                                                                                                      (not= (quot j 4) (quot k 4)))]\n                                                                                                     (vector (quot k 4) (mod k 4)))))))))))\n         (reduce into {} (map #(apply hash-map %) (for [i (concat (range 5 7) (range 9 11))\n                                                        :when (= (get v i) 'e)]\n                                                   (list (vector (quot i 4) (mod i 4)) #{})))))))", "user": "532727bae4b09d4e7a9b54fa"}, {"problem": 124, "code": "(fn solve [board p]\n  (letfn [(b [r c] (get-in board [r c]))\n          (beg? [r c] (= 'e (b r c)))\n          (cont [r0 c0 p [dr dc]]\n            (loop [r0 r0\n                   c0 c0\n                   res #{}]\n              (let [r (+ r0 dr)\n                    c (+ c0 dc)\n                    i (b r c)]\n                ;(prn r c i res)\n                (condp = i\n                  nil #{}\n                  p res\n                  'e #{}\n                  (recur r c (conj res [r c]))))))\n          (src[r c p]\n            (if (beg? r c)\n              (set\n                (mapcat (partial cont r c p)\n                  (for [dr [-1 0 1]\n                        dc [-1 0 1]] [dr dc])))\n                #{}))]\n    (into {}\n      (for [r (range 4)\n           c (range 4)\n           :let [ss (src r c p)]\n           :when (not-empty ss)]\n        [[r c] ss]))))", "user": "53f7820be4b0de5c41848560"}, {"problem": 124, "code": "(fn reversi [board color]\n  (let [colorPos (for[i (range 4) j (range 4) :when (= color (get-in board [i j]))] [i j])\n        neighbors (fn [xy]\n                    (let [delta [[-1 -1] [-1 0] [-1 1] [0 -1] [0 1] [1 -1] [1 0] [1 1]]]\n                      (filter (fn[xy] (every? #(< -1 % 4) xy)) (map #(map + xy %) delta))))\n        move (fn [pos dir col]\n               (loop[p pos r #{}]\n                 (cond\n                  (some #(or (< % 0) (> % 3)) p) nil\n                  (= (get-in board p) 'e) [p r]\n                  (= (get-in board p) col) nil\n                  :else (recur (map + p dir) (conj r p)))))]\n    (loop[p colorPos r {}]\n      (if (seq p)\n        (let[cp (first p)\n             m (concat (for [n (neighbors cp) :when (and (not= 'e (get-in board n))\n                                                 (not= color (get-in board n)))]\n                  (move n (map - n cp) color)))\n             nr (into r m)]\n          (recur (rest p) nr))\n        r))))", "user": "541619e8e4b01498b1a719f9"}, {"problem": 124, "code": "(fn reversi-moves [board element]\n  (let [find-positions (fn [element board]\n                         (for [row (range (count board))\n                               col (range (count (first board)))\n                               :when (= element (get-in board [row col]))]\n                           [row col]))\n        mover (fn mover [next-row next-col]\n                (fn [[row col]]\n                  [(next-row row) (next-col col)]))\n        crawl (fn _\n                ([curr-pos next-pos invalid-element board] (_ curr-pos next-pos invalid-element board []))\n                ([curr-pos next-pos invalid-element board positions]\n                 (let [new-pos (next-pos curr-pos)\n                       curr-element (get-in board new-pos)]\n                   (if curr-element\n                     (cond\n                       (= curr-element invalid-element) nil\n                       (= curr-element 'e) positions\n                       :else (recur new-pos next-pos invalid-element board (conj positions new-pos)))))))\n        valid-positions-from-position (fn [curr-pos board]\n                                        (let [element (get-in board curr-pos)]\n                                          (->>\n                                            (for [move-row [identity inc dec]\n                                                  move-col [identity inc dec]\n                                                  :let [current-mover (mover move-row move-col)]\n                                                  :when (not= identity move-row move-col)]\n                                              (let [path (crawl curr-pos current-mover element board)]\n                                                (if (not-empty path)\n                                                  [(current-mover (last path)) path])))\n                                            (filter identity))))\n        ]\n    (->>\n      (find-positions element board)\n      (mapcat #(valid-positions-from-position % board))\n      (reduce\n        (fn [m e]\n          (let [k (first e)\n                v (second e)]\n            (assoc m k (into (get m k #{}) v))))\n        {}))))", "user": "53527551e4b084c2834f4af0"}, {"problem": 124, "code": "(fn [R b s]\n  (reduce (fn [a [k v]] (assoc a k (into v (a k)))) \n          {}\n          (for [d [[-1 -1] [-1 0] [-1 1] [0 -1] [0 1] [1 -1] [1 0] [1 1]]\n                p (for [i R j R] [i j])\n                :let [f #(map + d %)\n                      g #(= % (get-in b %2))\n                      v (take-while #(g ('{w b b w} s) %) (iterate f (f p)))\n                      k (f (last v))] \n                :when (and (g s p) (g 'e k))] \n            [k (set v)])))\n[0 1 2 3]", "user": "53a01fb1e4b0ca733b9744a6"}, {"problem": 124, "code": "(fn reversi [board color]\n\t(let [opposite (if (= color 'w) 'b 'w)\n\t\t  get-color #(get-in board %)\n\t\t  empty? #(= 'e (get-color %))\n\t\t  h (count board) w (count (first board))\n\t\t  directions [[0 1] [0 -1] [1 0] [1 1] [1 -1] [-1 0] [-1 1] [-1 -1]]\n\t\t  valid-pos? (fn [[x y]] (and (< -1 x h) (< -1 y w)))\n\t\t  streak (fn [pos dir]\n\t\t  \t(take-while valid-pos? \n\t\t  \t\t(iterate #(map + % dir) (map + pos dir))))\n\t\t  valid-streak? (fn [s]\n\t\t  \t(let [cs (partition-by get-color s)]\n\t\t  \t\t;(println \"cells: \" s)\n\t\t  \t\t;(println \"partitioned: \" cs)\n\t\t  \t\t(and (>= (count cs) 2)\n\t\t  \t\t\t(= (get-color (first (first cs))) opposite)\n\t\t  \t\t\t(= (get-color (first (second cs))) color))))]\n\n\t\t  (into {}\n\t\t  (filter\n\t\t  \tidentity\n\t\t  (for [i (range h) j (range w)]\n\t\t  \t(if (empty? [i j])\n\t\t  \t\t(let [xs (map\n\t\t  \t\t\t\t \t#(first (partition-by get-color %))\n\t\t\t\t  \t\t\t (filter valid-streak? \n\t\t\t\t  \t\t\t\t(map #(streak [i j] %) directions)))]\n\t\t  \t\t\t(if (seq xs)\n\t\t  \t\t\t\t(vector [i j] (set (apply concat xs)))))))))))", "user": "54448e84e4b032a45b869393"}, {"problem": 124, "code": "(fn [board player]\n  (let [enemy (first (disj #{'w 'b} player))\n        bound #{0 1 2 3}\n        dirs  [[-1 -1] [-1 0] [-1 1]\n               [ 0 -1]        [ 0 1]\n               [ 1 -1] [ 1 0] [ 1 1]]\n        find  (fn [type]\n                (mapcat #(map (comp vec (partial take 2))\n                              (filter (comp #{type} last)\n                                      (map (partial vector %2) (range) %1)))\n                        board (range)))\n        empty (find 'e)\n        owned (find player)\n        other (find enemy)\n        check (fn [pos]\n                ;; search in each direction for a string of enemy pieces\n                ;; terminating in one's own piece\n                (apply clojure.set/union\n                       (map (fn [dir]\n                              (loop [pos (mapv + pos dir)\n                                     taken #{}]\n                                (if-not (every? bound pos)\n                                  #{}\n                                  (let [piece (get-in board pos)]\n                                    (condp = piece\n                                      'e     #{}\n                                      player taken\n                                      enemy  (recur (mapv + pos dir)\n                                                    (conj taken pos)))))))\n                            dirs)))]\n    (reduce\n     (fn [hsh pos]\n       (let [captures (check pos)]\n         (if (empty? captures)\n           hsh\n           (assoc hsh pos captures))))\n     {} empty)))", "user": "4ec0c7ba535dfed6da9c6da4"}, {"problem": 124, "code": "(fn [board color]\n    (let [size            (count board)\n          opponent        (if (= color 'w) 'b 'w)\n          empty-positions (for [y     (range size)\n                                x     (range size)\n                                :when (= ((board y) x) 'e)]\n                            [y x])\n          directions      (for [y [-1 0 1] x [-1 0 1] :when (not (= [y x] [0 0]))]\n                            [y x])\n          ray             (fn [position direction]\n                            (rest (take-while #(and (>= (first %) 0)\n                                                    (<  (first %) size)\n                                                    (>= (last %) 0)\n                                                    (<  (last %) size))\n                                              (iterate #(map + % direction)\n                                                       position))))\n          piece           (fn [position]\n                            ((board (first position)) (last position)))\n          flippable-ray   (fn [ray]\n                            (if (some #(= (piece %) color) ray)\n                              (take-while #(= (piece %) opponent)\n                                          (take-while #(not (= (piece %) color))\n                                                      ray))\n                              []))\n          rays            (map (fn [position]\n                                 [position (map (fn [direction]\n                                                  (flippable-ray (ray position direction)))\n                                                directions)])\n                               empty-positions)\n          pruned          (filter #(not (empty? (last %)))\n                                  (map (fn [[position rays]]\n                                         [position (filter (complement empty?) rays)])\n                                       rays))]\n      (into {} (map (fn [[position rays]]\n                      [position (set (apply concat rays))])\n                    pruned))))", "user": "53acaf1fe4b047364c04445f"}, {"problem": 124, "code": "(fn [board colour]\n   (let [enemy (if (= colour 'b) 'w 'b)]\n     (letfn [(out-of-bounds [[[x y] & _]] (prn x y (or (< x 0) (< y 0) (> x 3) (> y 3))) (or (< x 0) (< y 0) (> x 3) (> y 3)))\n             (move [[[x y] & _ :as path] [dx dy]] (conj path [(+ x dx) (+ y dy)]))\n             (occupant [pos] (get-in board pos))\n             (dfs [direction [pos & _ :as path]]\n               (prn path (occupant pos))\n               (cond\n                (and (= (count path) 1) (not (= 'e (occupant pos)))) false\n                (out-of-bounds path) false\n                (or (= enemy (occupant pos)) (= (count path) 1)) (recur direction (move path direction))\n                (and (= (count path) 2) (= colour (occupant pos))) false\n                (= 'e (occupant pos)) false\n                (= colour (occupant pos)) [(last path) (set (rest (butlast path)))]))]\n       (into {} (filter identity (map (fn [[start direction]] (dfs direction (list start)))\n                                      (for [x [0 1 2 3]\n                                            y [0 1 2 3]\n                                            dx [-1 0 1]\n                                            dy [-1 0 1]\n                                            :when (not (and (zero? dx) (zero? dy)))]\n                                        [[x y] [dx dy]])))))))", "user": "51672d15e4b079759a74a5e7"}, {"problem": 124, "code": "(fn [B color]\n  (let \n    [\n     D (partial map-indexed #(%2 %))\n     P (re-pattern (if (= color 'w) \"((?<=e)b+(?=w))|((?<=w)b+(?=e))\" \"((?<=e)w+(?=b))|((?<=b)w+(?=e))\"))\n     ff \n     (fn [i m]\n       (if (.find m)\n         (let \n           [\n            n (if (.group m 1) 1 2)\n            s (.start m n)\n            e (.end m n)\n            x (if (= 1 n) (dec s) e)\n            r (range s e)\n            ]\n           (case i\n             (0 1 2 3) [[i x] (set (for [j r] [i j]))]\n             (4 5 6 7) [[x (- i 4)] (set (for [j r] [j (- i 4)]))]\n             8  [[x x] (set (for [j r] [j j]))]\n             9  [[(- 3 x) x] (set (for [j r] [(- 3 j) j]))]\n     ) ) ) )     \n     ]\n    (->>\n       `(~@B ~@(apply map list B) ~(D B) ~(-> B reverse D))\n        (map #(apply str %))\n        (map #(re-matcher P %))\n        (map-indexed ff)\n        (remove nil?)\n        (into {})\n) ) )", "user": "5281a445e4b0757a1b17143a"}, {"problem": 124, "code": "(fn [board player]\n   ;; naive algorithm\n   (let [;; normalize the board (we are 2, opponent 3, empty 0)\n         pboard (mapv (fn [row]\n                   (mapv (fn [square] (condp = square\n                                        player 2\n                                        'e 0\n                                        3))\n                         row)) board)\n         _ (clojure.pprint/pprint pboard)\n         ;; define paths\n         horizontal\n         (fn [matrix row col]\n           [col\n            (vec (take (count (first matrix)) (iterate (fn [[row col]] [row (inc col)]) [row 0])))])\n         vertical\n         (fn [matrix row col]\n           [row\n            (vec (take (count matrix) (iterate (fn [[row col]] [(inc row) col]) [0 col])))])\n         updiag\n         (fn [matrix row col]\n           (let [shift (min col (- (count matrix) 1 row))]\n             [shift\n              (vec\n               (take\n                (+ 1 (min row (- (count (first matrix)) 1 col)) (min col (- (count matrix) 1 row)))\n                (iterate (fn [[row col]] [(dec row) (inc col)]) [(+ row shift) (- col shift)])))]))\n         downdiag\n         (fn [matrix row col]\n           (let [shift (min row col)]\n             [shift\n              (vec\n               (take\n                (+ 1 (min row col) (min (- (count (first matrix)) 1 col) (- (count matrix) 1 row)))\n                (iterate (fn [[row col]] [(inc row) (inc col)]) [(- row shift) (- col shift)])))]))\n         ;; ---\n         ;; checks the potential turned stones when playing i-th element\n         ;; on a path\n         turned-pieces-in-line\n         (fn\n           [matrix line i]\n           ;; nil = invalid, #{} = maybe valid, #{...} = valid\n           (if-not (= 0 (get-in matrix (get line i)))\n             (do\n               (println \"invalid play\")\n               nil) ;; square not empty => invalid play\n             (let [n (count line)\n                   running-prod (fn [acc c]\n                                  (conj acc\n                                        (* (or (last acc) 1)\n                                           (get-in matrix (nth line c)))))\n                   right (reduce running-prod []\n                                 (range (inc i) n))\n                   left (reduce running-prod []\n                                (range (dec i) -1 -1))\n                   ;; look for the first > 0 number (not empty square)\n                   ;; number divisible by 2 => everything between turned\n                   ;; (surrounding ennemy squares)\n                   turned? (fn [running-prod]\n                             (and (not (= 0 running-prod))\n                                  (= 1 (mod running-prod 2))))\n                   maybe-turned-right\n                   (range (inc i) (+ i 1 (count (take-while turned? right))))\n                   maybe-turned-left\n                   (range (dec i) (- i 1 (count (take-while turned? left))) -1)\n                   turned-right\n                   (if (= 2 (get-in matrix\n                                    (get line (+ i (count maybe-turned-right) 1))))\n                     maybe-turned-right\n                     '())\n                   turned-left\n                   (if (= 2 (get-in matrix\n                                    (get line (- i (count maybe-turned-left) 1))))\n                     maybe-turned-left\n                     '())\n                   turned (concat turned-right turned-left)\n                   turned-coords (map line turned)]\n               ;; one of the 2 sides is all empty\n               ;;  => potentially valid play\n               ;; else at least one piece must be turned\n               (if (or\n                    (= 0 (* (count left) (count right)))\n                    (= 0 (* (first left) (first right))))\n                 turned-coords ;; maybe valid\n                 (if (= 0 (count turned))\n                   (do\n                     (println \"surrounded but no piece turned\")\n                     nil) ;; surrounded and no piece turned\n                   turned-coords))))) ;; valid\n         ;; ---\n         process-board-line\n         (fn [pboard line-f]\n           ;;\"generates potential turned stones for each stone on a board for a unique direction\"\n           (println \"with new line function\")\n           (let [rows-count (count pboard)\n                 cols-count (count (first pboard))]\n             (reduce\n              (fn [potentials row]\n                (merge potentials\n                       (reduce\n                        (fn [potentials col]\n                          (let [[i the-line] (line-f pboard row col)\n                                pt-squares (turned-pieces-in-line pboard the-line i)\n                                _ (println (str \"<\" row \",\" col \"|\" i \"> -> \" \"line: \" the-line \" -- potentially turned squares: \" (and pt-squares (vec pt-squares))))]\n                            (assoc potentials [row col] pt-squares)))\n                        {}\n                        (range cols-count))))\n              {}\n              (range rows-count))))\n         ;; --- we generate the data for all directions\n         potentials (map\n                     (fn [line-f] (process-board-line pboard line-f))\n                     [horizontal vertical updiag downdiag])\n         ;; --- we get the keys where a play is potentially possible for all directions\n         potentials-coords (apply clojure.set/intersection (map (comp set keys) potentials))]\n     ;; we remove all the plays that result in no stone turned\n     (reduce\n      (fn [acc coords]\n        (let [turned (apply clojure.set/union (map #(% coords) potentials))]\n          (if (= 0 (count turned))\n            acc\n            (assoc acc coords (set turned)))))\n      {}\n      potentials-coords)))", "user": "547d8e93e4b0c51c1f4d72f4"}, {"problem": 124, "code": "(fn full-analyze [board piece]\n  (let [coord-board (vec\n                     (map vec\n                          (partition 4 (for [x (range 4)\n                                             y (range 4)]\n                                         [x y]))))]\n    (letfn [(analyze-row [row coord-row piece]\n              (let [st (apply str row)\n                    found (or (re-find (if (= piece 'b) #\"ew+b\" #\"eb+w\") st) \"nf\")\n                    position (.indexOf st found)\n                    length (- (count found) 2)]\n                (if (not= position -1)\n                  {(coord-row position)\n                   (set (for [x (range (inc position) (+ length position 1))]\n                          (coord-row x)))})))\n            (rotate-90 [board]\n              (vec (map vec (partition 4 (for [x (range 4)\n                                               y (range 4)]\n                                           (get-in board [y (- 3 x)]))))))\n            (diag [[[a1 a2] [a5 a6 a7] [_ a10 a11 a12] [_ _ a15 a16]]]\n              [[a2 a7 a12] [a1 a6 a11 a16] [a5 a10 a15]])\n            (analyze-board [board coords piece]\n              (let [rotated-boards (take 4 (iterate rotate-90 board))\n                    diag-rotated-boards (take 4 (map diag rotated-boards))\n                    rotated-coords (take 4 (iterate rotate-90 coords))\n                    diag-rotated-coords (take 4 (map diag rotated-coords))\n                    boards (concat rotated-boards diag-rotated-boards)\n                    coords (concat rotated-coords diag-rotated-coords)]\n                (filter not-empty\n                        (map (fn [x y] (reduce into {} (map #(analyze-row % %2 piece) x y)))\n                             boards coords))))\n            (upd [where y]\n              (update-in where [(key y)]\n                         (fn [x] (into (or (val y) #{}) x))))\n            (result [m]\n              (reduce (fn [where from]\n                        (if (= (count from) 1)\n                          (upd where (first from))\n                          (upd (upd where (first from)) (second from)))) {} m))]\n      (result (analyze-board board coord-board piece)))))", "user": "53973e7be4b0b51d73faaee6"}, {"problem": 124, "code": "(fn revers [board color]\n  (letfn [(explore [{:keys [location direction members] :as candidate}]\n            (let\n              [new-location (map + location direction)]\n              (cond\n                (some neg? new-location)\n                  nil\n                (some (partial = 4) new-location)\n                  nil\n                (= color (get-in board new-location))\n                  nil\n                (= 'e (get-in board new-location))\n                  (when-not\n                    (empty? members)\n                    (-> candidate\n                        (assoc :location new-location)))\n                \n                :else\n                  (recur\n                    (-> candidate\n                        (assoc :location new-location)\n                        (update-in [:members] conj new-location))))))\n          (test-location [coordinates]\n            (let\n              [directions (disj\n                            (set\n                              (for [x (range -1 2) y (range -1 2)] [x y]))\n                            [0 0])]\n              (filter identity\n                (for [direction directions]\n                  (explore {:location coordinates\n                            :direction direction\n                            :members (list)})))))]\n    (let \n      [locations (for [x (range 4) y (range 4)] [x y])]\n      (->> locations\n           (filter\n             #(= color (get-in board %)))\n           (mapcat test-location)\n           (map (fn [m] \n                  [(:location m) \n                   (set (:members m))]))\n           (into {})))))", "user": "521e8227e4b0dd19981ad082"}, {"problem": 124, "code": "(fn [b c]\n  (let [oc {'b 'w, 'w 'b}]\n    (letfn [(valid? [cells color]\n              (let [other-color (oc color)]\n                (and (= 'e (first cells))\n                     (= other-color (second cells))\n                     (or (and (= 3 (count cells))\n                              (= color (last cells)))\n                         (and (= 4 (count cells))\n                              (= other-color (nth cells 2))\n                              (= color (last cells)))\n                         (and (= 4 (count cells))\n                              (= color (nth cells 2)))))))\n\n            (coords [dir i j]\n              (case dir\n                :d  (for [x (range i 4    )] [x j])\n                :u  (for [x (range i -1 -1)] [x j])\n                :r  (for [y (range j 4    )] [i y])\n                :l  (for [y (range j -1 -1)] [i y])\n                :dr (for [x (range 4) :while (and (< (+ i x) 4) (< (+ j x) 4))]\n                      [(+ i x) (+ j x)])\n                :ur (for [x (range 4) :while (and (>= (- i x) 0) (< (+ j x) 4))]\n                      [(- i x) (+ j x)])\n                :ul (for [x (range 4) :while (and (>= (- i x) 0) (>= (- j x) 0))]\n                      [(- i x) (- j x)])\n                :dl (for [x (range 4) :while (and (< (+ i x) 4) (>= (- j x) 0))]\n                      [(+ i x) (- j x)])))\n\n            (check [b c dir i j]\n              (let [coords (coords dir i j)\n                    cells (for [[x y] coords] (get-in b [x y]))]\n                (when (valid? cells c)\n                  [(first coords)\n                   (if (= (oc c) (nth cells 2))\n                     (set [(second coords) (nth coords 2)])\n                     (set [(second coords)]))])))\n\n            (moves [b c]\n              (concat\n                (keep #(check b c :d  0 %) (range 4))\n                (keep #(check b c :d  1 %) (range 4))\n                (keep #(check b c :u  2 %) (range 4))\n                (keep #(check b c :u  3 %) (range 4))\n                (keep #(check b c :r  % 0) (range 4))\n                (keep #(check b c :r  % 1) (range 4))\n                (keep #(check b c :l  % 2) (range 4))\n                (keep #(check b c :l  % 3) (range 4))\n                (keep #(check b c :dr % 0) (range 2))\n                (keep #(check b c :dr % 1) (range 2))\n                (keep #(check b c :dl % 2) (range 2))\n                (keep #(check b c :dl % 3) (range 2))\n                (keep #(check b c :ur % 0) (range 2 4))\n                (keep #(check b c :ur % 1) (range 2 4))\n                (keep #(check b c :ul % 2) (range 2 4))\n                (keep #(check b c :ul % 3) (range 2 4))))]\n\n      (apply hash-map\n        (apply concat\n               (moves b c))))))", "user": "4ec1b090535dfed6da9c6db5"}, {"problem": 124, "code": "(fn [board color]\n  (letfn [(make-iterator [deltas]\n                         (fn [coords]\n                           (mapv + coords deltas)))\n\n          (make-iterators []\n                          (for [delta-r (range -1 2)\n                                delta-c (range -1 2) :when (not= 0 delta-r delta-c)]\n                            (make-iterator [delta-r delta-c])))\n\n          (flipped-iter [board color coords iterator]\n                        (let [board-piece (get-in board coords)]\n                          (cond\n                            (or (= 'e board-piece)\n                                (nil? board-piece)) nil\n                            (not= color board-piece) (let [flipped-list (flipped-iter board color (iterator coords) iterator)]\n                                                       (and flipped-list\n                                                            (cons coords flipped-list)))\n                            :else '())))\n\n          (result-along-dir [board color coords iterator]\n                            (if (= 'e (get-in board coords))\n                              (flipped-iter board color (iterator coords) iterator)))\n\n          (play-result [board color play-coords]\n                       (set (mapcat (partial result-along-dir board color play-coords) (make-iterators))))]\n\n    (into {} (remove (comp empty? second) (for [r (range (count board))\n                                                c (range (count (first board)))]\n                                            [[r c] (play-result board color [r c])])))))", "user": "5353afa0e4b084c2834f4b03"}, {"problem": 124, "code": "(fn reversi [board color]\n  (letfn [(get-board [[x y]] (get-in board [x y] 'e))\n          (directions [] [[0 1] [0 -1] [-1 0] [-1 1] [-1 -1] [1 0] [1 1] [1 -1]])\n          (one-line [x y [dx dy]]\n            (->> (range 1 4)\n                 (map #(vector (+ x (* % dx)) (+ y (* % dy))))))\n          (ours? [x] (= x color))\n          (opps? [x] (and (not= x 'e) (not= x color)))\n          (check-line [x y dir]\n            (let [pos (vec (one-line x y dir))\n                  piece (vec (map get-board pos))]\n              (do (println pos piece) \n                  (cond\n                   (and (opps? (get piece 0))\n                        (ours? (get piece 1))) [(get pos 0)]\n                        (and (opps? (get piece 0))\n                             (opps? (get piece 1))\n                             (ours? (get piece 2))) [(get pos 0) (get pos 1)]\n                             :else []))))\n          (check-move [x y]\n            (if (not= 'e (get-board [x y])) []\n                (mapcat #(check-line x y %) (directions))))]\n    (->> (for [i (range 4) j (range 4)] [[i j] (set (check-move i j))])\n         (filter #((comp not empty?) (get % 1)))\n         (apply concat)\n         (apply hash-map))))", "user": "5479c58de4b0c51c1f4d72c7"}, {"problem": 124, "code": "(fn [board move]\n  (let [all-positions (for [a (range 4) b (range 4)] [a b])\n        curr-move (filter #(= move (get-in board %)) all-positions)\n        enemy (if (= move 'b) 'w 'b)\n        directions [[0 -1] [0 1] [-1 0] [1 0] [1 1] [-1 -1] [1 -1] [-1 1]]\n        move-towards (fn [origin direction]\n                       [(+ (first origin) (first direction))\n                        (+ (second origin) (second direction))])\n        legal-coord? #(and (>= % 0) (<= % 3))\n        legal-pos? #(and (legal-coord? (first %)) (legal-coord? (second %)))\n        along-direction (fn [start direct]\n                           (loop [current start ret []]\n                             (let [next (move-towards current direct)]\n                               (if (legal-pos? next)\n                                 (recur next (conj ret next))\n                                 ret))))\n        calc-move (fn [start direct]\n                    (let [coords (along-direction start direct)\n                          moves (map #(get-in board %) coords)]\n                      (if (or (= [enemy enemy 'e] moves) (= [enemy 'e] moves))\n                        [(last coords) (set (drop-last coords))]\n                        nil)))]\n    (prn curr-move)\n    (into (hash-map)\n          (for [move curr-move direct directions]\n            (calc-move move direct)))))", "user": "53d86564e4b0e771c302546b"}, {"problem": 124, "code": "(fn [board color]\n  (let [bwc (for [x (range 4) y (range 4)] [(get-in board [x y]) x y])\n        color-pos (filter #(= color (first %)) bwc)\n        opposite (if (= color 'w) 'b 'w)\n        directions (rest (for [x [0 -1 1] y [0 -1 1]] [x y]))\n        move (fn [[x y] [dx dy]] [(+ x dx) (+ y dy)])\n        traverse (fn [pos delta]\n                   (loop [cp (move pos delta)\n                          taken #{}]\n                     (let [c (get-in board cp color)]\n                       (cond\n                         (= c opposite) (recur (move cp delta) (conj taken cp))\n                         (= c color) [cp #{}]\n                         :else [cp taken]))))\n        traversed (for [[_ x y] color-pos, delta directions] (traverse [x y] delta))]\n    (into {} (filter #(not-empty (second %)) traversed))))", "user": "53ce4cd4e4b00fb29b2212ef"}, {"problem": 124, "code": "(fn [b c]\n  (let [[cw cb] (if (= c 'w) ['w 'b] ['b 'w])\n        m (apply mapcat #(vector [0 %1 %2] [1 %1 %3] [2 %1 %4] [3 %1 %5]) (range) b)]\n    (->>\n     (for [[xi yi vi] (filter #(= cw (last %)) m)\n           [xe ye ve] (filter #(= 'e (last %)) m)\n           :let [xd (Math/abs (- xi xe))\n                 yd (Math/abs (- yi ye))\n                 xmn (min xi xe) xmx (max xi xe)\n                 ymn (min yi ye) ymx (max yi ye)\n                 btw (filter\n                      (cond (and (= xi xe) (< 1 yd)) (fn [[x y _]] (and (= xi x) (< ymn y) (< y ymx)))\n                            (and (= yi ye) (< 1 xd)) (fn [[x y _]] (and (= yi y) (< xmn x) (< x xmx)))\n                            (and (< 1 xd) (= xd yd)) (fn [[x y _]] (let [xd (Math/abs (- xi x))\n                                                                         yd (Math/abs (- yi y))]\n                                                                     (and (< 0 xd) (= xd yd)\n                                                                          (< ymn y) (< y ymx)\n                                                                          (< xmn x) (< x xmx))))\n                            :else (fn [_] false))\n                      m)]\n           :when (and (not (empty? btw)) (every? (comp #{cb} last) btw))]\n       [[xe ye] (->> btw (map (fn [[x y _]] [x y])) set)])\n     (reduce #(assoc %1 (first %2) (second %2)) {}) )))", "user": "515bbcd9e4b0388ca8ca1521"}, {"problem": 124, "code": "(fn [board piece]\n  (letfn [(step [op-piece start gap result]\n            (let [next-start (mapv #(+ %1 %2) start gap)\n                  next-piece (get-in board next-start)]\n              (if (= next-piece op-piece)\n                (step op-piece next-start gap (conj result next-start))\n                (if (= next-piece 'e)\n                  (if (seq result)\n                    {next-start (set result)}\n                    {})\n                  {}))))]\n    (apply\n      merge\n      (mapcat\n        #(map\n           (fn [gap] (step (if (= piece 'w) 'b 'w) % gap []))\n           [[0 1] [0 -1] [1 0] [-1 0] [1 1] [-1 -1] [1 -1] [-1 1]])\n        (filter #(= piece (get-in board %)) (mapcat #(map (fn [ele] [% ele]) (range 0 4)) (range 0 4)))))))", "user": "4eec82fe535d93acb0a668ae"}, {"problem": 124, "code": "(fn [b p]\n  (let [bm (into {} (mapcat (fn [x l] (map-indexed (fn [y v] {[x y] v}) l)) (range) b))\n        fim (fn [v] (into {} (filter #(= v (val %)) bm)))\n        vd [-1 0 1] dirs (for [x vd y vd :when (not= 0 x y)] [x y])\n        mv (fn [c] (map (fn [v] (take-while bm (rest (iterate #(map + % v) c)))) dirs))\n        gv (filter #(let [vv (map bm %)] (and ((disj '#{b w} p) (first vv)) (some '#{e} vv))) (mapcat mv (keys (fim p))))\n        r  (apply merge (map #(let [pv (partition-by (fn [c] ('#{e} (bm c))) %)] {(first (second pv)) (set (first pv))}) gv))\n        ] r))", "user": "53e745a1e4b036ad0777e479"}, {"problem": 124, "code": "(fn [B P]\n  (let [r range v vector q (r 4)\n        g #(get-in B %)\n        d #(v (r % 4) [% % % %] (r % -1 -1))]\n    (into {}\n          (for [y q x q]\n            (mapcat #({() {}} % {[y x] (set %)})\n                    (for [i (d y) j (d x)]\n                      (#(-> P {'b #\"^ew+b\" 'w #\"^eb+w\"}\n                           (re-find (apply str (map g %)))\n                           count dec (take %) rest)\n                       (map v i j))))))))", "user": "53bcdd41e4b0d9a98559a6c0"}, {"problem": 124, "code": "(fn [b p]\n  (letfn [(in? [[j i]]\n            (and (<= 0 j 3)\n                 (<= 0 i 3)))\n\n          (flips [x d]\n            (let [cs  (take-while in? (rest (iterate d x)))\n                  vs* (map #(get-in b %) cs)\n                  vs  (take-while #(not (#{p} %)) vs*)]\n              (when-not (or (= vs vs*) (some #{'e} vs))\n                (set (map (fn [c _] c) \n                          cs vs)))))\n\n          (n [[j i]] [(dec j) i])\n          (s [[j i]] [(inc j) i])\n          (e [[j i]] [j (inc i)])\n          (w [[j i]] [j (dec i)])]\n    (let [ne #(n (e %)) se #(s (e %))\n          sw #(s (w %)) nw #(n (w %))]\n      (into {}\n             (for [j (range 4), i (range 4)\n\n                   :let [c [j i]]\n                   :when (#{'e} (get-in b c))\n\n                   :let [fs (set (mapcat\n                                   #(flips c %)\n                                   [n e ne se\n                                    s w sw nw]))]\n                   :when (seq fs)]\n               [c fs])))))", "user": "53dfdf01e4b0d874e779ae46"}, {"problem": 124, "code": "(fn reversi [board player]\n  (let [opposite (if (= player 'w) 'b 'w)\n        empty_pos (set (apply concat \n                              (for [[row_v row] (map-indexed vector board)]\n                                (for [[col_v value] (map-indexed vector row) :when (= value 'e)]\n                                  [row_v col_v]))))\n        player_pos (apply concat\n                            (for [[row_v row] (map-indexed vector board)]\n                              (for [[col_v value] (map-indexed vector row) :when (= value player)]\n                                [row_v col_v])))\n        opposite_pos (set (apply concat\n                                 (for [[row_v row] (map-indexed vector board)]\n                                  (for [[col_v value] (map-indexed vector row) :when (= value opposite)]\n                                    [row_v col_v]))))\n        generate_positions (fn [[a b]]\n                             (for [x [-1 0 1] y [-1 0 1] \n                                   :when (and (>= (+ a x) 0) \n                                              (>= (+ b y) 0) \n                                              (not (and (= x 0) (= y 0))))]\n                               [[(+ a x) (+ b y)] [x y]]))\n        starting_movements (filter (fn [[v d]] (contains? opposite_pos v)) (apply concat (map generate_positions player_pos))) \n        generate_movements (fn [[v d]]\n                             (loop [f v res [v]]\n                               (let [n [(+ (first f) (first d)) \n                                        (+ (second f) (second d))]]\n                                 (cond \n                                   (contains? opposite_pos n) (recur n (conj res n))\n                                   (contains? empty_pos n) [n (set res)]\n                                   :else []))))]\n    (apply hash-map (apply concat (map generate_movements starting_movements)))))", "user": "5046f909e4b03b02161376b5"}, {"problem": 124, "code": "(fn __[board color]\n  (let [opposite-color ({'w 'b 'b 'w} color)]\n  (reduce #(assoc %1 (first %2) (last %2)) {}\n   (apply concat(filter #(not(empty? %)) (map (fn[empty-piece]\n         (filter #(not(empty? (last %))) (map\n          (fn[direction]\n            (vector empty-piece (loop\n              [current-point (map + empty-piece direction) bank #{}]\n              (if-not(= (get-in board current-point) opposite-color) \n                (if (= (get-in board current-point) color) bank #{}) \n                (recur (map + current-point direction) (conj bank current-point))))))\n          \n          [[-1 0]\n           [-1 1]\n           [0 1]\n           [1 1]\n           [1 0]\n           [1 -1]\n           [0 -1]\n           [-1 -1]]))\n         )\n      \n   (filter #(= 'e (get-in board %))\n   (for[i (range 4) j (range 4)] [i j]))))))))", "user": "52bbd09ee4b07a9af57922ee"}, {"problem": 124, "code": "(fn reversi [board p]\n  (let [w (count board) h (count (first board))\n        o (if (= p 'w) 'b 'w)\n        valid-coord? (fn [[x y]] (and (>= x 0) (>= y 0) (< x w) (< y h)))\n        get-coord (partial get-in board)\n        directions [[0 1] [0 -1] [1 0] [-1 0] [1 -1] [1 1] [-1 1] [-1 -1]]\n        m+ (partial map +)\n        open-spots (filter #(= 'e (get-coord %))\n                           (for [x (range w) y (range h)] \n                             [x y]))\n        cast (fn [start dir] (take-while valid-coord?\n                                         (rest (iterate #(m+ dir %) start))))\n        get-flips (fn [ray]\n                    (let [[flips r] (split-with #(= (get-coord %) o) ray)]\n                      (if (and (not (empty? r))\n                               (= (get-coord (first r)) p))\n                        flips\n                        '())))\n        spot->flips\n        (zipmap open-spots\n                (->> open-spots\n                     (map (fn [start]\n                            (map #(get-flips (cast start %))\n                                 directions)))\n                     (map #(remove empty? %))\n                     (map (partial apply concat))\n                     (map #(map vec %))\n                     (map set)))]\n    (into {} (filter (fn [[k v]] (not (empty? v))) spot->flips))))", "user": "54be7772e4b0ed20f4ff6eea"}, {"problem": 124, "code": "(fn __ [board color]\n  (letfn [(opposite [piece] (if (= piece 'w) 'b 'w))\n          (xy [x y] (when (and (>= x 0) (>= y 0) (< x 4) (< y 4)) (nth (nth board x) y)))\n          (abs [x] (if (neg? x) (- 0 x) x))\n          (in-line? [[x1 y1][x2 y2]] (let [x (abs (- x1 x2)), y (abs (- y1 y2))]\n                                       (or (zero? x) (zero? y) (= x y))))\n          (flipped-pieces [[x y]]\n            (->> (for [dx [-1 0 1] dy [-1 0 1] :when (not (and (zero? dx) (zero? dy)))]\n                    (let [u (+ x dx), v (+ y dy), neighbor (xy u v), other (opposite color)]\n                      (if (= neighbor other)\n                        (loop [flipped #{[u v]}, u (+ u dx), v (+ v dy)]\n                          (let [piece (xy u v)]\n                            (cond (= piece color) flipped\n                                  (= piece other) (recur (conj flipped [u v]) (+ u dx) (+ v dy))\n                                  :else #{}))))))\n                 (filter #(not (empty? %)))\n                 (apply clojure.set/union)))]\n    (->> (for [x (range 4) y (range 4)] [x y])\n         (filter #(= 'e (apply xy %)))\n         (map #(vec (list % (flipped-pieces %))))\n         (filter (comp not empty? second))\n         (reduce conj {}))))", "user": "54c271b9e4b045293a27f602"}, {"problem": 124, "code": "(fn [v c]\n    (let [\n          isValid (fn [p] (and (<= 0 (first p)) (<= 0 (second p)) (< (first p) 4) (< (second p) 4)))\n          moves (fn [v p c f]\n                  (loop [s #{} p p]\n                    (let [n (f p)] \n                      (if (or (not (isValid n)) (= 'e (get-in v n)))\n                        #{} \n                        (if (= c (get-in v n)) \n                          s   \n                          (recur (conj s n) n)\n                          )   \n                        )   \n                      )   \n                    )   \n                  )   \n\n          validMoves (fn [v p c]\n                       (let [d [\n                                #(vector (first %) (- (second %) 1)) \n                                #(vector (first %) (+ (second %) 1)) \n                                #(vector (- (first %) 1) (second %)) \n                                #(vector (+ (first %) 1) (second %)) \n                                #(vector (- (first %) 1) (+ (second %) 1)) \n                                #(vector (+ (first %) 1) (+ (second %) 1)) \n                                #(vector (- (first %) 1) (- (second %) 1)) \n                                #(vector (+ (first %) 1) (- (second %) 1)) \n                                ]]  \n                         (apply clojure.set/union (map #(moves v p c %) d)) \n                         )   \n                       )   \n          ]   \n    (apply merge\n           (for [x (range 4) y (range 4)] \n             (let [m (validMoves v [x y] c)] \n               (if (and (< 0 (count m)) (= 'e (get-in v [x y])))\n                 {[x y] m}\n                 {}  \n                 )   \n               )   \n             )   \n           )   \n    )   \n    )", "user": "54b90836e4b0ed20f4ff6e9d"}, {"problem": 124, "code": "(fn f\n  [xs p]\n  (let [rs {'w 'b 'b 'w}\n        es (fn [x] (->> (map-indexed #(vector %1 %2) x)\n                       (filter #(= 'e (second %)))\n                       (map first)))\n        ems (->> (map-indexed #(vector %1 (es %2)) xs) \n                 (mapcat #(map (fn [n] [(first %) n]) (second %))))\n        hr (fn [[a b]]\n             (let [hx (->> (range (inc b) (+ b 4))\n                           (map #(vector a %))\n                           (take-while #(< (second %) 4))\n                           vec)]\n               (if (empty? hx)\n                 nil\n                 (let [sw (take-while #(= p (rs (get-in xs %))) hx)\n                       bh (= p (first (->> (map #(get-in xs %) hx)\n                                           (drop-while #(= p (rs %))))))]\n                   (if (and (not-empty sw) bh)\n                     {[a b] (set sw)}\n                     nil)))))\n        hl (fn [[a b]]\n             (let [hx (->> (range (dec b) (- b 4) -1)\n                           (map #(vector a %))\n                           (take-while #(< -1 (second %) 4))\n                           vec)]\n               (if (empty? hx)\n                 nil\n                 (let [sw (take-while #(= p (rs (get-in xs %))) hx)\n                       bh (= p (first (->> (map #(get-in xs %) hx)\n                                           (drop-while #(= p (rs %))))))]\n                   (if (and (not-empty sw) bh)\n                     {[a b] (set sw)}\n                     nil)))))\n        vu (fn [[a b]]\n             (let [hx (->> (range (dec a) (- a 4) -1)\n                           (map #(vector % b))\n                           (take-while #(< -1 (first %) 4))\n                           vec)]\n               (if (empty? hx)\n                 nil\n                 (let [sw (take-while #(= p (rs (get-in xs %))) hx)\n                       bh (= p (first (->> (map #(get-in xs %) hx)\n                                           (drop-while #(= p (rs %))))))]\n                   (if (and (not-empty sw) bh)\n                     {[a b] (set sw)}\n                     nil)))))\n        vd (fn [[a b]]\n             (let [hx (->> (range (inc a) (+ a 4))\n                           (map #(vector % b))\n                           (take-while #(< -1 (first %) 4))\n                           vec)]\n               (if (empty? hx)\n                 nil\n                 (let [sw (take-while #(= p (rs (get-in xs %))) hx)\n                       bh (= p (first (->> (map #(get-in xs %) hx)\n                                           (drop-while #(= p (rs %))))))]\n                   (if (and (not-empty sw) bh)\n                     {[a b] (set sw)}\n                     nil)))))\n        dlu (fn [[a b]]\n              (let [hx (->> (range (dec b) (- b 4) -1)\n                            (map #(vector %1 %2)\n                                 (range (dec a) (- a 4) -1))\n                            (take-while #(and (< -1 (first %) 4)\n                                              (< -1 (second %) 4)))\n                            vec)]\n                (if (empty? hx)\n                  nil\n                  (let [sw (take-while #(= p (rs (get-in xs %))) hx)\n                        bh (= p (first (->> (map #(get-in xs %) hx)\n                                            (drop-while #(= p (rs %))))))]\n                    (if (and (not-empty sw) bh)\n                      {[a b] (set sw)}\n                      nil)))))\n        dru (fn [[a b]]\n              (let [hx (->> (range (inc b) (+ b 4))\n                            (map #(vector %1 %2)\n                                 (range (dec a) (- a 4) -1))\n                            (take-while #(and (< -1 (first %) 4)\n                                              (< -1 (second %) 4)))\n                            vec)]\n                (if (empty? hx)\n                  nil\n                  (let [sw (take-while #(= p (rs (get-in xs %))) hx)\n                        bh (= p (first (->> (map #(get-in xs %) hx)\n                                            (drop-while #(= p (rs %))))))]\n                    (if (and (not-empty sw) bh)\n                      {[a b] (set sw)}\n                      nil)))))\n        dld (fn [[a b]]\n              (let [hx (->> (range (dec b) (- b 4) -1)\n                            (map #(vector %1 %2)\n                                 (range (inc a) (+ a 4)))\n                            (take-while #(and (< -1 (first %) 4)\n                                              (< -1 (second %) 4)))\n                            vec)]\n                (if (empty? hx)\n                  nil\n                  (let [sw (take-while #(= p (rs (get-in xs %))) hx)\n                        bh (= p (first (->> (map #(get-in xs %) hx)\n                                            (drop-while #(= p (rs %))))))]\n                    (if (and (not-empty sw) bh)\n                      {[a b] (set sw)}\n                      nil)))))\n        drd (fn [[a b]]\n              (let [hx (->> (range (inc b) (+ b 4))\n                            (map #(vector %1 %2)\n                                 (range (dec a) (- a 4) -1))\n                            (take-while #(and (< -1 (first %) 4)\n                                              (< -1 (second %) 4)))\n                            vec)]\n                (if (empty? hx)\n                  nil\n                  (let [sw (take-while #(= p (rs (get-in xs %))) hx)\n                        bh (= p (first (->> (map #(get-in xs %) hx)\n                                            (drop-while #(= p (rs %))))))]\n                    (if (and (not-empty sw) bh)\n                      {[a b] (set sw)}\n                      nil)))))]\n    (->> (mapcat #(keep % ems) [hl hr vu vd dlu dld dru drd])\n         (apply merge))))", "user": "528a3e14e4b0239c8a67ae72"}, {"problem": 124, "code": "(fn reversi \r\n  [board color]\r\n  (let [size      4\r\n        coord     (for [x (range size) y (range size)] [x y])\r\n        pos-moves (filter #(= 'e (get-in board %)) coord)\r\n        splitdir  (fn [d v k] \r\n                     [[d (subvec v k)]\r\n                      [(mapv - d) (vec (reverse (subvec v 0 (inc k))))]])\r\n        tr        (partial apply map vector)\r\n        mirror    (fn [b] (vec (map (comp vec reverse) b)))\r\n        diag  (fn [d b r c]\r\n                (let [s (min r c)]\r\n                  (splitdir d \r\n                    (vec (map\r\n                      #(get-in b [%1 %2])\r\n                      (range (- r s) size)\r\n                      (range (- c s) size)))\r\n                    s)))\r\n        dirs  (fn [[r c]]\r\n                (concat \r\n                  (splitdir [0 1] (nth board r) c) ;left-right\r\n                  (splitdir [1 0] (nth (tr board) c) r) ;up-down\r\n                  (diag [1 1] board r c)\r\n                  (diag [1 -1] (mirror board) r (- (dec size) c))))\r\n        move  (fn [c [_ & v]]\r\n                (loop [i 0 [a & b] v]\r\n                  (condp = a\r\n                    nil nil\r\n                    c   (if (> i 0) i nil)\r\n                    'e  nil\r\n                    (recur (inc i) b))))\r\n        flip  (fn [p v k]\r\n                (map\r\n                  #(map + p (mapv (partial * %) v))\r\n                  (range 1 (inc k))))]\r\n        \r\n      (apply array-map  \r\n        (reduce    \r\n          (fn[r s]\r\n            (let [d (filter (comp not nil?)\r\n                      (mapcat\r\n                        (fn [[v a]] \r\n                          (when-let [m (move color a)] \r\n                            (flip s v m)))\r\n                        (dirs s)))]\r\n              (if (empty? d) r (conj r s (set d))))) \r\n          []\r\n          pos-moves))))", "user": "5470699ae4b00cfc9eacc1b6"}, {"problem": 124, "code": "(fn [board color]\n  (letfn [; colors \n          (is-other-color [piece] (not (or (= piece color) (= piece 'e))))\n          (other-color [] (if (= color 'b) 'w 'b)) \n          (make-color-first [row] (if (= color (last row)) (reverse row) row)) \n          \n          ; analyze a tight row, i.e., we do not consider moves concerning its sub-rows \n          (analy-tight-row [row] \n                           (let [cf-row (make-color-first row)\n                                 n (count cf-row)\n                                 filling (repeat (- n 2) (other-color))\n                                 good-row (seq (concat [color] filling ['e]))]\n                             (= cf-row good-row)))\n          \n          ; produce the move from a tight row \n          (get-move [row pinc] (let [n (count row)\n                                n-filling (- n 2)\n                                filling (set (map #(+ % pinc) (range 1 (inc n-filling))))]\n                            \t[(if (= (first row) color) (+ pinc (dec n)) pinc) filling])) \n          \n          ; this function processes a row  \n          (analy-row [row] \n                     (if (= 3 (count row))\n                       (if (analy-tight-row row) (get-move row 0) nil)\n                       (let [sit1 (take 3 row)\n                             sit2 (drop 1 row)\n                             sit3 row]\n                         (cond \n                          (analy-tight-row sit1) (get-move sit1 0)\n                          (analy-tight-row sit2) (get-move sit2 1) \n                          (analy-tight-row sit3) (get-move sit3 0)\n                          :else nil))))\n          \n          ; pick row function\n          (pick-row [rows sr sc dr dc] \n                    (loop [cr sr cc sc row [] coords []]\n                      (if (or (< cr 0) (> cr 3) (< cc 0) (> cc 3)) \n                        [row coords]\n                        (recur (+ cr dr) (+ cc dc) (conj row (nth (nth rows cr) cc)) (conj coords [cr cc])\n                               )))) \n          (pick-rows [rows dr dc starts]\n                     (map #(pick-row rows (first %) (second %) dr dc) starts))\n          \n          ; get all the rows \n          (backslash-rows [rows] (pick-rows rows 1 1 [[0 0] [0 1] [1 0]]))\n          (slash-rows [rows] (pick-rows rows 1 -1 [[0 2] [0 3] [1 3]]))\n          (h-rows [rows] (pick-rows rows 0 1 (map vector (range 4) (repeat 4 0))))\n          (v-rows [rows] (pick-rows rows 1 0 (map vector (repeat 4 0) (range 4))))\n          (all-rows [rows] (concat (backslash-rows rows) (slash-rows rows)\n                                   (h-rows rows) (v-rows rows)))\n\n          ; work on rows\n          (work-row [one-row] \n                    (let [result (analy-row (first one-row))]\n                      (if (nil? result) {}\n                        (let [coords (second one-row)\n                              move-to (nth coords (first result))\n                              changes (set (map #(nth coords %) (second result)))]\n                          {move-to changes}))))\n          ]\n    \n    (apply merge (map work-row (all-rows board)))\n    ))", "user": "52faec2ee4b047fd55837004"}, {"problem": 124, "code": "(fn [board cl]\n  (let [n 4\n        op ({'b 'w 'w 'b} cl)\n        cells (fn [x y [sx sy]]\n                (for [i (range 1 n)\n                      :let [nx (+ (* i sx) x)\n                            ny (+ (* i sy) y)]\n                      :when (#{'b 'w} (get-in board [nx ny]))]\n                  [nx ny]))\n        flipped (fn [x y dir]\n                  (let [dc (cells x y dir)\n                        fl (take-while #(= (get-in board %) op) dc)\n                        cnt (count fl)]\n                    (if (and (pos? cnt) (> (count dc) cnt)) fl [])))]\n    (into {}\n      (for [x (range n)\n            y (range n)\n            :when (= (get-in board [x y]) 'e)\n            :let [fl (into #{} (mapcat #(flipped x y %) [[0 1] [1 1] [1 0] [1 -1] [0 -1] [-1 -1] [-1 0] [-1 1]]))]\n            :when (-> fl count pos?)]\n        [[x y] fl]))))", "user": "514c2d05e4b02b8cbb2a9278"}, {"problem": 124, "code": "(fn [board color]\n  (let [\n        get-b (fn get-b [board i j]\n                (if (or (>= i 4) (< i 0) (>= j 4) (< j 0))\n                  nil\n                  (get-in board [i j])))\n\n        pieces (fn pieces [board i j color diri dirj]\n                 (let [c (if (= color 'b) 'w 'b)]\n                   (cond\n                     (or (>= i 4) (< i 0) (>= j 4) (< j 0))\n                     [false []]\n                     (and (= (get-b board (+ i diri)  (+ j dirj)) c)\n                          (= (get-b board (+ i diri diri)  (+ j dirj dirj)) color))\n                     [true [[(+ diri i) (+ dirj j)]]]\n                     :else\n                     (let [pi (pieces board (+ i diri) (+ j dirj) color diri dirj)]\n                       (if (first pi)\n                         [true (conj (second pi) [(+ diri i) (+ dirj j)])]\n                         [false []])))))\n        ]\n    (apply hash-map\n           (apply concat\n                  (for [i (range 4)]\n                    (apply concat\n                           (filter not-empty\n                                   (for [j (range 4)]\n                                     (let  [ c1 (pieces board i j color 0 1)\n                                            c2 (pieces board i j color 0 -1)\n                                            c3 (pieces board i j color 1 0)\n                                            c4 (pieces board i j color -1 0)\n                                            c5 (pieces board i j color -1 1)\n                                            c6 (pieces board i j color 1 -1)\n                                            c7 (pieces board i j color -1 -1)\n                                            c8 (pieces board i j color 1 1) ]\n                                       (if (and (or\n                                                  (first c1)\n                                                  (first c2)\n                                                  (first c3)\n                                                  (first c4)\n                                                  (first c5)\n                                                  (first c6)\n                                                  (first c7)\n                                                  (first c8))\n                                                (= 'e (get-b board i j)))\n                                         [ [i j] (set (apply concat\n                                                             (second c1)\n                                                             (second c2)\n                                                             (second c3)\n                                                             (second c4)\n                                                             (second c5)\n                                                             (second c6)\n                                                             (second c7)\n                                                             (second c8)))]))))))))))", "user": "53664e3be4b0243289761e74"}, {"problem": 124, "code": "(fn reversi [board color]\n  (letfn \n      [(find-symbol [rows sym]\n         (for\n             [r (range (count rows))\n              c (range (count (first rows)))\n              :when (= sym (get-in rows [r c]))]\n           [r c]))\n       (neighbors [board [row col]]\n         (let [max-row (dec (count board))\n               max-col (dec (count (first board)))]\n           (filter #(not (= % [row col]))\n                   (for\n                       [r (range (dec row) (+ row 2))\n                        c (range (dec col) (+ col 2))\n                        :when (and (>= max-row r 0) (>= max-col c 0))]\n                     [r c]))))\n       (get-piece [board [row col]]\n         (and\n          (> (count board) row -1)\n          (> (count (first board)) col -1))\n         (get-in board [row col]))\n       (extend-move [board pos dir]\n         (let [npos (mapv + pos dir)\n               sym (get-piece board npos)]\n           (cond\n             (nil? sym) (list nil)\n             (= sym 'e) (list pos npos)\n             (= sym (get-in board pos)) (cons pos (extend-move board npos dir))\n             :else (list nil))))]\n    (let [o (if (= color 'b) 'w 'b)]\n      (into {}\n            (for\n                [p (find-symbol board color)\n                 n (filter #(= o (get-in board %)) (neighbors board p))]\n              (when-let [m (extend-move board n (map - n p))]\n                (when (not (nil? (last m)))\n                  (vector (last m) (set (butlast m))))))))))", "user": "54e3df6ae4b024c67c0cf7e3"}, {"problem": 124, "code": "(fn reversi [board p]\n  (let [o '{b w w b}\n        d (for [y [-1 0 1] x (if (= 0 y) [-1 1] [-1 0 1])] [y x])\n        b (into {} (for [y (range 4) x (range 4)] [[y x] (get-in board [y x])]))\n        e (map key (filter #(= 'e (val %)) b))\n        wk (fn [st off] (take-while b (rest (iterate #(map + % off) st))))\n        vl (fn [pth] (let [s (apply str (map b pth)) r (re-pattern (str (o p) \"+\" p))]\n                       (if (re-seq r s) (take-while #(not= p (b %)) pth))))\n        mv (fn [st] (set (apply concat (keep vl (map #(wk st %) d)))))]\n    (into {} (for [st e :let [mvs (mv st)] :when (not-empty mvs)] [st mvs]))))", "user": "539c736ce4b0b51d73faaf2b"}, {"problem": 124, "code": "(fn ar[bv c]\n    (let [W (count (get bv 0))\n          H (count bv)\n          oc ({'b 'w 'w 'b} c)\n          ba (to-array-2d (map seq bv))\n          bm (apply merge (for [j (range W)\n                                i (range H)] {[i j] (aget ba  i j)}))]\n      (letfn [(tk[i j]\n                (letfn [(ed[m n k l st]\n                          (let [ni (+ m k)\n                                nj (+ n l)\n                                cell (bm [ni nj])]\n                            (cond \n                              (nil? cell) #{} \n                              (= cell oc)(ed ni nj k l (conj st [ni nj]))\n                              (= cell c) st\n                              (= cell 'e) #{})))]\n                  (if (= 'e (aget ba i j)) \n                         (set (apply concat \n                                 (for [k [-1 0 1]\n                                       l [-1 0 1]\n                                       :let [tc (ed i j k l #{}) \n                                             t (not (empty? tc))]\n                                       :when t] \n                                   tc))) \n                         #{})))]\n        (reduce (partial apply assoc) {} \n              (for [i (range W)\n                    j (range H)\n                    :let [s (tk i j)\n                          v (not (empty? s))]\n                    :when v]\n                (vector (vector i j) s))))))", "user": "54d4bd2be4b0a52adc2e2005"}, {"problem": 124, "code": "(fn arb [board color]\n  (letfn [\n    ; return positions for all pieces in the `board` with `color`\n    (get-positions [board color]\n      (let [get-pos-row (fn [row color] \n                          (map #(first %) \n                            (filter #(= color (second %)) \n                              (map-indexed (fn [idx itm] [idx itm]) row))))\n            idx-rows (map-indexed (fn [idx itm] [idx (get-pos-row itm color)]) board)\n            filt-rows (filter #(not (empty? (second %))) idx-rows)\n            positions (map (fn [el]  (for [x [(first el)] y (second el)] [x y])) filt-rows)]\n      (vec (partition 2 2 (flatten positions)))))\n    ; is `pos` inside of a board\n    (is-inside?   [pos rows cols] \n                    (cond \n                      (neg? (first pos))     false\n                      (= (first pos) rows)   false\n                      (neg? (second pos))    false\n                      (= (second pos) cols)  false\n                      :else                  true))\n    ; return positions of 8 neighbours (diagonali, horizontaly and verticaly)\n    ; if any position is outside a board, then nil is used instead of a position\n    (get-neigh-pos [pos rows cols]\n      (let [[r c] pos\n            rd (dec r)\n            ri (inc r)\n            cd (dec c)\n            ci (inc c)\n            cands [[rd cd] [rd c] [rd ci] [r cd] [r ci] [ri cd] [ri c] [ri ci]]]\n              (map #(if (is-inside? % rows cols) % nil) cands)))\n    ; return piece from `board` at `pos`\n    (get-at [board pos] (if (nil? pos) nil (get-in board pos)))\n    ; return neighbours pieces for `pos`\n    ; nil is used if a neighbour is outside the `board`\n    (get-neighbours [board pos rows cols]\n      (map #(get-at board %) (get-neigh-pos pos rows cols)))\n    ; get opposite color to input `color`\n    (opp-color [color] (if (= 'w color) 'b 'w))\n    ; return list of movements (for example 4 is move right horizontali)\n    (get-movements [neighbours color]\n      (filter \n        #(number? %) \n        (map-indexed (fn [idx itm] (when (= itm color) idx)) neighbours)))\n    ; get next position by using movement of `move-type`\n    (next-pos [pos move-type]\n      (let [[r c] pos]\n        (cond\n          (= 0 move-type) [(dec r) (dec c)]\n          (= 1 move-type) [(dec r) c]\n          (= 2 move-type) [(dec r) (inc c)]\n          (= 3 move-type) [r       (dec c)]\n          (= 4 move-type) [r       (inc c)]\n          (= 5 move-type) [(inc r) (dec c)]\n          (= 6 move-type) [(inc r) c]\n          (= 7 move-type) [(inc r) (inc c)]\n          :else nil)))\n    ; get positions by using movement of `move-type` until the board edge\n    ; starting from `start` (exclusive)\n    (next-positions [start move-type rows cols]\n      (loop [pos start result []]\n        (let [npos (next-pos pos move-type)]\n          (if (is-inside? npos rows cols)\n            (recur npos (conj result npos))\n            result))))\n    ; convert a line to nill if the end is not an empty piece\n    ; otherwise drop all empty pieces to one\n    ; '((b b) (b b e ) (b b b) (b e e e e)) -> '(nil (b b e) nill (b e))\n    (process-lines [lines]\n      (letfn [(cut-empty-pieces \n                [line] \n                (conj (vec (take-while #(not (= 'e %)) line)) 'e))]\n        (map\n          (fn [line]\n            (if (not (= 'e (last line))) nil (cut-empty-pieces line)))\n          lines)))\n    ; examples of inputs:\n    ; ml-pieces:    '[[b e] [b e] [b e] [b e]]\n    ; ml-positions: '[[[1 2] [1 3]] [[2 1] [3 1]] [[1 2] [0 2]] [[2 1] [2 0]]]\n    ; from these inputs create a map of possible moves in requested format\n    (create-moves [ml-pieces ml-positions]\n      (loop [pieces ml-pieces i 0 result {}]\n        (if (empty? pieces)\n          result\n          (let [line (first pieces)\n                positions (ml-positions i)]\n            (if (nil? line)\n              (recur (rest pieces) (inc i) result)\n              (recur (rest pieces) (inc i) (assoc result (last positions) (set (drop-last positions)))))))))]\n    (let [rows (count board)\n          cols (count (first board))\n          opponent-color (opp-color color)\n          positions (get-positions board color)\n          movements (map \n                      (fn [el] \n                        (let [neighbours (get-neighbours board el rows cols)]\n                          (get-movements neighbours opponent-color))) \n                      positions)\n          move-lines-pos1  (map-indexed\n                            (fn [idx itm]\n                              (let [pos (positions idx)]\n                                (map #(next-positions pos % rows cols) itm)))\n                            movements)\n          move-lines-pos2 (vec (mapcat identity move-lines-pos1))\n          move-lines-pieces1 (map (fn [el] (map #(get-at board %) el)) move-lines-pos2)\n          move-lines-pieces2 (vec (process-lines move-lines-pieces1))]\n      (create-moves move-lines-pieces2 move-lines-pos2))))", "user": "52cf084ce4b07d0d72b27399"}, {"problem": 124, "code": "(fn [bd pce]\n   (letfn [(mth [b i j]\n             (if (every? #(<= 0 % 3) [i j])\n               (nth (nth b i) j)))\n\n           (gather [p [i j] dirfunc board]\n             (let [sq (mth board i j)]\n               (cond\n                 (= p sq)\n                 (let [x (gather p (dirfunc [i j]) dirfunc board)]\n                   (if (empty? x) x\n                       (conj x [i j])))\n                 \n                 (= 'e sq)\n                 [[i j]]\n\n                 :else [])))\n\n           (get-neighbors [[i j]]\n             (apply concat (for [k (range -1 2)] (for [l (range -1 2)] [(+ i k) (+ j l)]))))\n\n\n           (make-func [[k l] [i j]]\n             (fn [[x y]]\n               [(+ x (- k i)) (+ y (- l j))]))\n\n           (get-pieces [[i j] board]\n             (let [p (mth board i j)\n                   q (first (disj #{'w 'b} p))]\n               (reduce (fn [acc [k l]]\n                         (if (= q (mth board k l))\n                           (let [g (gather q [k l] (make-func [k l] [i j]) board)]\n                             (if (empty? g)\n                               acc\n                               (conj acc g)))\n                           acc))\n                       []\n                       (get-neighbors [i j]))))\n\n           (rev2 [board piece]\n             (reduce (fn [acc [i j]]\n                       (if (= piece (mth board i j))\n                         (let [ps (get-pieces [i j] board)]\n                           (if (empty? ps)\n                             acc\n                             (merge acc\n                                    (reduce (fn [acc1 [x & xs]]\n                                              (assoc acc1 x (set (reverse xs))))\n                                            {}\n                                            ps))))\n                         acc))\n                     {}\n                     (apply concat (for [i (range 4)] (for [j (range 4)] [i j])))))]\n     (rev2 bd pce)))", "user": "51b76227e4b0d906fcd71d35"}, {"problem": 124, "code": "(fn [rows color]\n  (let [; the 8 directions we can capture in\n        directions [[-1 -1] [-1 0] [-1 1] [0 -1] [0 1] [1 -1] [1 0] [1 1]]\n        ; the \"other\" color\n        other-color ({'b 'w 'w 'b} color)\n        ; get the contents of a cell\n        at (fn [[y x]] (get (get rows y) x))\n        ; get lazy seq of coords going in a certain direction from a starting point\n        travel (fn [from direction] (rest (iterate #(mapv + % direction) from)))\n        ; given a list of coords, return those which would be captured\n        capture (fn [line]\n                  (let [[taken [next]] (split-with #(= other-color (at %)) line)]\n                    (if (= color (at next)) taken [])))\n        ; get all the cells which would be captured from a given cell\n        capture-at (fn [coords] (set (mapcat #(capture (travel coords %)) directions)))]\n    ; for every cell; work out the captures\n    (->> (for [y (range (count rows))\n               x (range (count(first rows)))]\n           [[y x] (capture-at [y x])])\n         ; drop those which capture nothing or which are not empty\n         (filter #(and (not (empty? (% 1))) (= 'e (at (% 0))  )))\n         ; turn it into a map\n         (into {}))))", "user": "54febf4be4b07d26eda61d45"}, {"problem": 124, "code": "(fn [d p]\n    (letfn [(find-pieces-for-player [d p]\n             (let [a (for [r (range 4)] (for [c (range 4) :when (= (get-in d [r c]) p)] [r c]))]\n               (->> a flatten (partition 2))))\n           (find-adj [d [r c]]\n             (let [a (for [rr (range (dec r) (+ 2 r))]\n                       (for [cc (range (dec c) (+ 2 c))\n                             :when (not (or (< rr 0)\n                                            (< cc 0)\n                                            (> rr 3)\n                                            (> cc 3)\n                                            (and (= cc c) (= rr r))))] [rr cc]))]\n               (->> a flatten (partition 2))))\n           (find-all-moves [d p]\n             (let [m (set (find-pieces-for-player d (if (= p 'w) 'b 'w)))\n                   empty (find-pieces-for-player d 'e)\n                   lm (for [e empty] (for [l (find-adj d e) :when (contains? m l)] [e l]))]\n               (->> lm flatten (partition 2) (partition 2) set)))\n           (find-line [d [sr1 sc1] [ir ic] p]\n             (let [mp (if (= p 'w) 'b 'w)]\n               (loop [[sr sc] [(+ sr1 ir) (+ sc1 ic)] a []]\n                 (let [n (get-in d [sr sc])]\n                   (cond\n                    (= n mp) (recur [(+ sr ir) (+ sc ic)] (cons [sr sc] a))\n                    (= n p) [[sr1 sc1] (set a)]\n                    :else [])))))]\n     (into {}\n           (for [m (find-all-moves d p)\n                 :let [[[er ec] [lr lc]] m\n                       ir (- lr er)\n                       ic (- lc ec)\n                       a (find-line d [er ec] [ir ic] p)]\n                 :when (not (empty? a))] a ))))", "user": "4f3ec266e4b0e243712b1f8c"}, {"problem": 124, "code": "(fn available-moves\n  [board player]\n  (let [board (vec (map-indexed (fn [row-idx row]\n                                  (vec (map-indexed\n                                         (fn [col-idx p]\n                                           {:p p :row row-idx :col col-idx})\n                                         row)))\n                                board))\n        player-coords (mapcat (fn [row]\n                                (keep (fn [{:keys [p row col]}]\n                                        (when (= p player)\n                                          [row col]))\n                                      row))\n                              board)\n        neighbors (fn [[row-idx col-idx :as coords]]\n                    (for [row-inc (range -1 (inc 1))\n                          col-inc (range -1 (inc 1))\n                          :when (not= 0 row-inc col-inc)]\n                      [(+ row-idx row-inc) (+ col-idx col-inc)]))\n        capturable? (fn [{:keys [row col]}]\n                      (let [{:keys [p] :as el} (get-in board [row col])]\n                        (and (not= p 'e) (not= p player))))\n        right-from (fn [coords]\n                     (let [[row col] coords]\n                       (->> (get board row)\n                            (drop (inc col)))))\n        left-from (fn [coords]\n                    (let [[row col] coords]\n                      (->> (get board row)\n                           (take col)\n                           reverse)))\n        up-from (fn [coords]\n                  (let [[row col] coords]\n                    (->> (map #(get % col) board)\n                         (take row)\n                         reverse)))\n        down-from (fn [coords]\n                    (let [[row col] coords]\n                      (->> (map #(get % col) board)\n                           (drop (inc row)))))\n        max-n (inc (count board))\n        min-n (dec 0)\n        diagonal-from (fn [row-idxs col-idxs]\n                        (map #(get-in board [%1 %2]) row-idxs col-idxs))\n        down-right-from (fn [[row col]]\n                          (diagonal-from (range (inc row) max-n) (range (inc col) max-n)))\n        down-left-from (fn [[row col]]\n                         (diagonal-from (range (inc row) max-n) (range (dec col) min-n -1)))\n        up-right-from (fn [[row col]]\n                        (diagonal-from (range (dec row) min-n -1) (range (inc col) max-n)))\n        up-left-from (fn [[row col]]\n                      (diagonal-from (range (dec row) min-n -1) (range (dec col) min-n -1)))\n        move (fn [f start-coords]\n               (let [route (f start-coords)\n                     path (take-while capturable? route)\n                     {:keys [row col p]} (first (drop-while capturable? route))]\n                 (when (and (seq path) (= p 'e))\n                   [[row col] (set (map (juxt :row :col) path))])))]\n    (into {} (mapcat (fn [coord]\n                       (keep (fn [f]\n                               (move f coord))\n                             [right-from left-from\n                              up-from down-from\n                              down-right-from down-left-from\n                              up-right-from up-left-from]))\n                     player-coords))))", "user": "4dc0ff08535d020aff1edf84"}, {"problem": 124, "code": "(fn [board disk]\n  (let [b0 (for [i (range 4) j (range 4)]\n             [[i j] (let [x (nth (nth board i) j)] (if (= x disk) 1 (if (= x 'e) 0 -1)))])\n        b1 (partition 4 b0)\n        b2 (apply map list b1)\n        dum [[5 5] 5]\n        b3  (cons dum (for [i (range 1 16 5)] (nth b0 i)))\n        b4  (cons dum (for [i (range 4 16 5)] (nth b0 i)))\n        b5  (for [i (range 0 16 5)] (nth b0 i))\n        b6  (cons dum (for [i (range 2 8 3)] (nth b0 i)))\n        b7  (cons dum (for [i (range 7 16 3)] (nth b0 i)))\n        b8  (for [i (range 3 13 3)] (nth b0 i))\n        b (concat b1 b2 (map reverse b1) (map reverse b2)\n                  [b3][(reverse b3)][b4][(reverse b4)][b5][(reverse b5)]\n                  [b6][(reverse b6)][b7][(reverse b7)][b8][(reverse b8)])\n      ]\n    (loop [b b ret {}]\n      (if (empty? b)\n        ret\n        (let [v1 (first b)\n              v2 (butlast v1)\n              v3 (rest v1)\n              r  (if (= (map last v1) [1 -1 -1 0])\n                   (assoc {} (first (last v1)) (into #{} (map first (rest (butlast v1)))))\n                   (if (= (map last v2) [1 -1 0])\n                     (assoc {} (first (last v2)) #{(first (second v2))})\n                     (if (= (map last v3) [1 -1 0])\n                       (assoc {} (first (last v3)) #{(first (last (butlast v3)))})\n                       {})))\n             ]\n      (recur (rest b) (conj ret r)))))))", "user": "545537c1e4b0e397800069dd"}, {"problem": 124, "code": "(fn [board player]\n  (let [rows 4\n        cols 4\n        opponent ({'w 'b 'b 'w} player)\n        directions (for [x [-1 0 1]\n                         y [-1 0 1]\n                         :when (not= x y 0)] [x y])\n        empty-cells (for [x (range rows)\n                          y (range cols)\n                          :let [coords [x y] \n                                value (get-in board coords)]\n                          :when (= value 'e)] \n                      coords)\n        in-board? (fn [[x y]] (and (< x rows) (< y cols) (>= x 0) (>= y 0)))\n        coords-in-dir (fn [pt dir] (take-while in-board? (drop 1 (iterate #(map + dir %) pt))))\n        get-in-dir (fn [pt dir] (map #(get-in board %) (coords-in-dir pt dir)))\n        valid-move? (fn [pt dir]\n                      (let [cells (get-in-dir pt dir)\n                            groups (partition-by identity cells)]\n                        (and (> (count cells) 1)\n                             (> (count groups) 1)\n                             (= (ffirst groups) opponent)\n                             (= (first (second groups)) player))))\n        turned-cells (fn [pt dir]\n                       (set (take-while #(= opponent (get-in board %)) (coords-in-dir pt dir))))]\n    (into {}\n          (for [cell empty-cells\n                dir directions\n                :when (valid-move? cell dir)]\n            [cell (turned-cells cell dir)]))))", "user": "500aa15ee4b03d00572d2d76"}, {"problem": 124, "code": "(fn [rs player]\n  (let\n    [oposite (if (= 'w player) 'b 'w)\n     cell (fn [[y x]] (get (get rs y) x))\n     dirs (fn [y x]\n            (for [fy [dec identity inc]\n                  fx [dec identity inc]\n                  :when (not= identity fy fx)]\n              (iterate (fn [[i j]] [(fy i) (fx j)]) [(fy y) (fx x)])))\n     lines (fn [y x]\n             (for [d (dirs y x)]\n               (for [yx d\n                     :let [v (cell yx)]\n                     :while v]\n                 {:yx yx :val v})))\n     put (fn [y x]\n           (set\n            (apply concat\n                   (for [ln (lines y x)\n                         :let [vs (map :val ln)\n                               os (take-while #(#{oposite} (:val %)) ln)]\n                         :when (and (not= [] os)\n                                    (#{player} (first (drop (count os) vs))))\n                         ]\n                     (map :yx os)))))]\n    (->> (for [y (range 4)\n               x (range 4)\n               :when (= 'e (cell [y x]))\n               :let [res (put y x)]\n               :when (not= #{} res)]\n           [[y x] res])\n         (apply concat)\n         (apply hash-map))))", "user": "553e0b70e4b0a04f792994e8"}, {"problem": 124, "code": "(fn reversi [bo p]\n      (let  [m (take (count bo) (iterate inc 0))\n      \t     n (take (count (first bo)) (iterate inc 0))\n\t     t (fn [v] (get-in bo v))\n\t     alle (for [x m, y n :when (= 'e (t [x y]))] [x y]) ;; all emptys..\n\t     dis (for [x [1 0 -1] y [1 0 -1] :when (not (and (= x 0) (= y 0)))] [x y])\n\t     pt (fn [s di] (iterate #(mapv + % di) s))\n\t     gp (fn [s di]  (rest (take-while #(not (nil? %)) (map #(get-in bo %) (iterate #(mapv + % di) s)))))\n\t     ct (fn [v] (take-while #(not (= % 'e)) v))\n\t     gtx (fn [v] (let [p1 (take-while #(not (= % p)) v)] (if (= (count p1) (count v)) '() p1)))\n\t     deled (fn [s di] (take (count (gtx (ct (gp s di)))) (rest (pt s di))))\n\t     ]\n\t     (into {} (filter #(not (empty? (last %))) (for [es alle] [ es (into #{} (for [ d dis q (deled es d) :when (not (empty? q))] q))]))\n\t    )))", "user": "54a1d643e4b09f271ff37c50"}, {"problem": 124, "code": "(fn [board piece] \n (letfn [(step [op-piece start gap result] \n (let [next-start (mapv #(+ %1 %2) start gap) \n next-piece (get-in board next-start)] \n (if (= next-piece op-piece) \n (step op-piece next-start gap (conj result next-start)) \n (if (= next-piece 'e) \n (if (seq result) \n {next-start (set result)} \n {}) \n {}))))] \n (apply \n merge \n (mapcat \n #(map \n (fn [gap] (step (if (= piece 'w) 'b 'w) % gap [])) \n [[0 1] [0 -1] [1 0] [-1 0] [1 1] [-1 -1] [1 -1] [-1 1]]) \n (filter #(= piece (get-in board %)) (mapcat #(map (fn [ele] [% ele]) (range 0 4)) (range 0 4)))))))", "user": "5243e37ae4b076204b44fae3"}, {"problem": 124, "code": "(let [dirs (for [x (range -1 2) y (range -1 2)\n                   :when (not (and (zero? x) (zero? y)))] [x y])]\n    (fn [board piece]\n      (let\n        [gb (partial get-in board)\n         op (if (= 'w piece) 'b 'w)\n         +d (fn [d] #(map + % d))\n         mv (fn [p]\n              (when (= 'e (gb p))\n                (set\n                  (mapcat\n                    (fn [d]\n                      (let [p+d (+d d)\n                            pcs (take-while\n                                  #(= op (gb %))\n                                  (iterate p+d (p+d p)))]\n                        (when (and (not-empty pcs)\n                                   (= piece (gb (p+d (last pcs)))))\n                          pcs)))\n                    dirs))))]\n        (apply merge\n          (for [r (range (count board))\n                c (range (count (get board r)))]\n            (let [ps (mv [r c])]\n              (when (not-empty ps)\n                {[r c] ps})))))))", "user": "553abb28e4b09218d5f44ffb"}, {"problem": 124, "code": "(let [validate-board\n        ;; This function returns true iff its argument is a valid Reversi board.\n        (fn validate-board [board] \n          (and (vector? board)\n               (every? vector? board)\n               (= 4 (count board))\n               (every? (comp (partial = 4) count) board)\n               (every? (partial every? #{'w 'b 'e}) board)))]\n    \n    (fn get-moves [board color]\n      {:pre [(validate-board board),\n             (#{'b 'w} color)]}\n      (let [flip\n            ;; This function returns the set of coordinates for all the opposing\n            ;; pieces that would be flipped in the [i j] direction (one of the\n            ;; eight relevant directions on the Reversi board; e.g., [1 -1]\n            ;; represents \"diagonally down and left\") if our given color were to\n            ;; play a piece at the specified coordinates. Note that this\n            ;; function doesn't check that such a move is legal; this way we can\n            ;; use recursion to collect all the coordinates.\n            (fn flip [[x y :as coords] [i j :as dir]]\n              {:pre [(every? (set (range 4)) coords),\n                     (every? #{-1 0 1} dir),\n                     (not= i j 0)]}\n              (let [enemy ({'b 'w, 'w 'b} color)]\n                (loop [acc #{}, [x y :as coords] [(+ x i) (+ y j)]]\n                  (condp = (get-in board coords)\n                    color  acc,\n                    enemy  (recur (conj acc coords) [(+ x i) (+ y j)])\n                    'e     #{}\n                    nil    #{})))),\n            \n            try-move\n            ;; If coords is a coordinate pair denoting a position on the board\n            ;; that is a legal move for color, this function returns the set of\n            ;; coordinates for all the oposing pieces flipped by such a\n            ;; move. Otherwise, it returns nil \n            (fn try-move [coords]\n              {:pre [(= 2 (count coords)), (every? (set (range 4)) coords)]}\n              ;; If coords aren't empty, the move is illegal. Check this first.\n              (if (= 'e (get-in board coords))\n                ;; Now we check the validity of the move by sending\n                ;; out \"tracers\" in all eight directions, using the flip\n                ;; function. These count the number of contiguous opposing\n                ;; pieces there are in that direction that have a friendly piece\n                ;; on the other side. If any tracer comes back non-empty, then\n                ;; the move is legal; otherwise, it's not.\n                (let [result\n                      (->> (for [i [-1 0 1], j [-1 0 1]\n                                 :when (not= i j 0)]\n                             (flip coords [i j]))\n                           (apply clojure.set/union))]\n                  (if (seq result) result nil))))]\n\n        ;; For the main function, we just check all 16 squares.\n        (->> (for [x (range 4), y (range 4)\n                   :let [val (try-move [x y])]\n                   :when val]\n               {[x y] val})\n             (apply merge)))))", "user": "4fc6305de4b0ee37620e180b"}, {"problem": 124, "code": "(fn reversi-move [board color]\n  (let [get-move-and-others\n        (fn [board line player]\n          (let [opposite ({'w 'b 'b 'w} player)\n                [move unfiltered-scores :as result]\n              (reduce (fn [acc coord]\n                        (cond (and (empty? acc)\n                                   (= player (get-in board coord)))\n                              [coord #{}]\n                              (and (not (empty? acc))\n                                   (= (get-in board (first acc)))\n                                   player)\n                              [coord\n                               (conj (second acc) coord)]\n                              (and (not (empty? acc))\n                                   (= (get-in board (first acc))\n                                      opposite))\n                              [coord\n                               (conj (second acc) coord)]\n                              :else acc))\n                      []\n                      line)]\n              (when (not (empty? result))\n                (let [scores (set (filter #(= opposite\n                                              (get-in board %))\n                                          unfiltered-scores))]\n                  (if (and (= 'e (get-in board move))\n                           (not (empty? scores)))\n                              {move scores})))))\n        lines (concat (partition 4\n                        (concat (for [x (range 4) y (range 4)] [x y])\n                                (for [x (range 4) y (range 4)] [y x])\n                                [[0 0] [1 1] [2 2] [3 3]\n                                [3 0] [2 1] [1 2] [0 3]]))\n                      [[[0 1] [1 2] [2 3]]\n                       [[0 2] [1 1] [2 0]]\n                       [[1 0] [2 1] [3 2]]\n                       [[1 3] [2 2] [3 1]]])\n        lines-both-way (concat lines (map reverse lines))]\n    (reduce merge\n     (filter #(not (nil? %))\n             (map #(get-move-and-others board % color)\n                lines-both-way)))))", "user": "540e8d13e4b0addc1aec671e"}, {"problem": 124, "code": "(fn [board c]\n  (let [idxs (for [i (range (count board))\n                   j (range (count (first board)))\n                   :when (= 'e (get-in board [i j]))]\n               [i j])\n        dirs (for [di [-1 0 1] dj [-1 0 1] :when (not= di dj 0)] [di dj])\n        other ({'w 'b 'b 'w} c)]\n    (letfn [(ray [[i j] [di dj]]\n              (let [[ni nj :as idx] [(+ i di) (+ j dj)] val (get-in board idx)]\n                (when val (cons [idx val] (ray idx [di dj])))))\n            (ray-flips [r]\n              (let [[h t] (split-with #(= other (second %)) r)]\n                (when (= c (second (first t))) (seq (map first h)))))\n            (flips [idx]\n              (->> dirs (map #(ray idx %)) (map ray-flips) (apply concat) set))]\n      (into {} (filter #(seq (second %)) (map (juxt identity flips) idxs))))))", "user": "52ce1abfe4b07d0d72b27389"}, {"problem": 124, "code": "(fn analyze-reversi\n  [board color]\n  (let [width 4\n        heigth 4\n        starting-point [0 0]]\n    (letfn [(get-valid-direction-move \n              [direction point board color result]\n            (loop [dir-result result \n                   to-change #{}\n                   next-point (get-next-point point direction)]\n              (cond \n                (= color (get-board-color next-point board)) \n                (if (empty? to-change) \n                  result\n                  (assoc result point to-change))\n                (not= (get-other-color color) (get-board-color next-point board)) dir-result\n                :else (recur dir-result (conj to-change next-point) (get-next-point next-point direction)))))\n            (get-valid-move\n              [point board color result]\n              (conj result (apply concat \n                                  (for [direction (get-directions)]\n                                    (get-valid-direction-move direction point board color result)))))\n            (get-other-color\n              [color]\n              (if (= color 'b) \n                'w\n                'b))\n            (get-directions [] [[-1 1] [0 1] [1 1] [1 0] [1 -1] [0 -1] [-1 -1] [-1 0]])\n            (get-board-color\n              [[x y] board]\n              (nth (nth board x []) y 'n))\n            (get-next-point\n              ([[x y]]\n                (let [sum (inc (+ (* width y) x))]\n                  [(mod sum 4) (int (/ sum 4))]))\n              ([current direction]\n                (vec (map + current direction))))]\n      (loop [result {} current-point starting-point]\n        (if (> (second current-point) 3)\n          result\n          (let [current-color (get-board-color current-point board)]\n            (cond \n              (= current-color 'e) (recur (get-valid-move current-point board color result) (get-next-point current-point))\n              :else (recur result (get-next-point current-point)))))))))", "user": "509a25b7e4b0efbae1fbc0a8"}, {"problem": 124, "code": "(fn [board color]\n  (let[colorPos (for [r (range (count board)) c (range (count (first board))) ;prepare the position list\n                      :when (= color (get-in board [r c]))]\n                  [r c])       \n       move (fn [start direction color];interpret this function find the consecutive colors along this direction\n              (loop [position start result #{}]\n                (when-let [cell (get-in board position)];so this function may return nil\n                  (cond\n                   (= 'e cell) {position, result}\n                   (= color cell) (recur (mapv + position direction) (conj result position))))))];again this function may return nil\n    (apply merge ;prepare the final result\n           (for [pos colorPos dir [[-1 -1][-1 0][-1 1][0 1][0 -1][1 -1][1 0][1 1]];eight directions\n                 :let [neighPos (mapv + pos dir) neighCell (get-in board neighPos)]\n                 :when (or (and (= color 'w) (= neighCell 'b)) (and (= color 'b) (= neighCell 'w)))]\n             (move neighPos dir neighCell)))));the move result may be nil or a map as a valid position with flipped cells", "user": "556c70dae4b09a3098a524fd"}, {"problem": 124, "code": "(fn [board piece]\r\n  (let [\r\n      zip (fn [& seq] (apply map list seq))\r\n      add-coord (fn [board] (into [] (map\r\n        (fn [[y row]]\r\n          (into [] (map\r\n            (fn [[x piece]] {:y y, :x x, :piece piece})\r\n            (zip (range) row))))\r\n        (zip (range) board))))\r\n      board (add-coord board)\r\n      cell (fn [[y x]] (get (get board y) x))\r\n      all-cells (apply concat board)\r\n      empty-cells (->> all-cells\r\n        (filter #(= 'e (:piece %)))\r\n        (map #(-> [(:y %) (:x %)])))\r\n      directions [[-1 0] [-1  1] [ 0  1] [ 1  1]\r\n                  [ 1 0] [ 1 -1] [ 0 -1] [-1 -1]]\r\n      one-move (fn [[y x] [dy dx]]\r\n        (loop [y (+ y dy), x (+ x dx), result []]\r\n          (let [curr-cell (cell [y x])]\r\n            (if (nil? curr-cell)\r\n              result\r\n              (recur (+ y dy) (+ x dx)\r\n                (conj result curr-cell))))))\r\n      opponent (if (= piece 'w) 'b 'w)\r\n      valid-move (fn [cells]\r\n        (let [[s1 s2 & s-rest] (partition-by :piece cells)]\r\n          (and\r\n            (not (nil? s1))\r\n            (not (nil? s2))\r\n            (= (:piece (first s1)) opponent)\r\n            (= (:piece (first s2)) piece))))\r\n      all-moves (fn [point]\r\n        {:where point\r\n         :spokes (->> directions\r\n            (map #(one-move point %))\r\n            (filter #(not (empty? %)))\r\n            (filter valid-move)\r\n            (map (fn [cells]\r\n              (take-while (fn [cell]\r\n                (= (:piece cell) opponent)) cells)))\r\n            (apply concat))})\r\n      legal-moves (fn []\r\n        (->> empty-cells\r\n          (map all-moves)\r\n          (filter #(not (empty? (:spokes %))))\r\n          (map (fn [move]\r\n            [(move :where) (set (map (fn [cell]\r\n              [(cell :y) (cell :x)]) (move :spokes)))]))\r\n          (into {})))\r\n    ]\r\n    (legal-moves)))", "user": "555bd27ae4b0b056612e2244"}, {"problem": 124, "code": "(fn [board me]\n  (let [adv ({'b 'w 'w 'b} me)]\n    (letfn [(at [p] (get-in board p 'X))\n            (add [[x0 y0] [dx dy]] [(+ x0 dx) (+ y0 dy)])\n            (flip-to [p0 dp]\n              (loop [p (add p0 dp) acc #{}]\n                (condp = (at p)\n                  adv (recur (add p dp) (conj acc p))\n                  me acc\n                  #{})))\n            (flip [p0]\n              (if (= (at p0) 'e)\n                (apply clojure.set/union\n                       (map #(flip-to p0 %)\n                            [[-1 -1] [-1 0] [-1 1]\n                             [0 -1]         [0 1]\n                             [1 -1] [1 0] [1 1]]))\n                #{}))]\n      (->> (for [x (range 4) y (range 4)] [x y])\n        (map #(-> [% (flip %)]))\n        (remove #(empty? (second %)))\n        (apply concat)\n        (apply array-map)))))", "user": "508157b2e4b0946d0443855c"}, {"problem": 124, "code": "(fn valid-moves [board color]\n  (let [deltas (for [x [-1 0 1]\n                     y [-1 0 1]\n                     :when (not= x y 0)]\n                 [x y])\n        color-at (partial get-in board)\n        other (if (= color 'b) 'w 'b)\n        other? (comp #{other} color-at)]\n    (into {}\n           (for [r (range 4)\n                 c (range 4)\n                 :let [neighbors (->> deltas\n                                      (map #(map + [r c] %))\n                                      (filter (fn [coord] (every? #(<= 0 % 3) coord)))\n                                      (filter other?))]\n                 :when (and (= 'e (get-in board [r c]))\n                            (seq neighbors))\n                 neighbor neighbors\n                 :let [delta (map - neighbor [r c])\n                       ray (->> neighbor\n                                (iterate #(map + % delta))\n                                (take-while color-at))]\n                 :when (= color (first (remove #{other} (map color-at ray))))]\n             [[r c] (set (map vec (filter other? ray)))]))))", "user": "54ca9ca8e4b057c6fda3a265"}, {"problem": 124, "code": "(fn analyze-reversi [board color]\n  (letfn [(color-positions [board color]\n            (filter #(= color (get-in board %))\n                    (for [y (range 4) x (range 4)] [y x])))\n          (line-from-position [[y x] [dy dx]]\n            (loop [res [] y y x x]\n              (let [l (+ y dy)\n                    m (+ x dx)]\n                (if (and (< l 4) (< m 4) (>= l 0) (>= m 0))\n                  (recur (conj res [l m]) l m)\n                  (when (> (count res) 1)\n                    res)))))\n          (lines-from-position [yx]\n            (let [deltas [[-1 -1][-1 0][-1 1][0 -1][0 1][1 -1][1 0][1 1]]]\n              (keep #(line-from-position yx %) deltas)))\n          (opposite-color [color]\n            (condp = color\n              'b 'w\n              'w 'b))\n          (line->move [board flipped-color line]\n            (let [line-left (drop-while #(= flipped-color (get-in board %)) line)]\n              (when-not (= (count line-left) (count line))\n                (when-let [last-el (first line-left)]\n                  (when (= 'e (get-in board last-el))\n                    last-el)))))\n          (line->flipped [board color flipped-color line]\n            (when-let [flipped (seq (take-while #(= flipped-color (get-in board %)) line))]\n              (when-let [first-not-flipped (->> line\n                                                (filter #(not= flipped-color (get-in board %)))\n                                                first\n                                                (get-in board))]\n                (when (= first-not-flipped color)\n                  flipped))))\n          (moves-from-position [board flipped-color yx]\n            (keep #(line->move board flipped-color %)\n                  (lines-from-position yx)))\n          (flipped-from-position [board color flipped-color yx]\n            (apply concat (keep #(line->flipped board color flipped-color %)\n                                (lines-from-position yx))))]\n    (let [flipped-color (opposite-color color)\n          positions     (color-positions board color)\n          moves         (mapcat #(moves-from-position board flipped-color %)\n                                positions)]\n      (reduce (fn [result move]\n                (assoc result move (set (flipped-from-position board color flipped-color move))))\n              {}\n              moves))))", "user": "55586905e4b0deb715856e2b"}, {"problem": 124, "code": "(fn [board sym]\n  (letfn [(find-turns-for [board sym line]\n            (let [c-s (first (disj #{'b 'w} sym))\n                  flipped (take-while #(= c-s (get-in board %)) line)\n                  put-at (first (drop (count flipped) line))]\n              (when (and (> (count flipped) 0)\n                         (= 'e (get-in board put-at)))\n                [put-at (set flipped)])))\n          (find-lines [n m n-size m-size]\n            (let [map-ln (partial map vector)\n                  m-l (range m)\n                  m-h (range (inc m) m-size)\n                  n-l (range n)\n                  n-h (range (inc n) n-size)\n                  left (map-ln (repeat n) (reverse m-l))\n                  right (map-ln (repeat n) m-h)\n                  top (map-ln (reverse n-l) (repeat m))\n                  bottom (map-ln n-h (repeat m))\n                  d1-h (map-ln (reverse n-l) (reverse m-l))\n                  d1-l (map-ln n-h m-h)\n                  d2-h (map-ln (reverse n-l) m-h)\n                  d2-l (map-ln n-h (reverse m-l))]\n              (remove empty?\n                      (list left right top bottom d1-h d1-l d2-h d2-l))))\n          (find-turns [board sym n m]\n            (into\n             {}\n             (remove\n              nil?\n              (map (partial find-turns-for board sym)\n                   (find-lines n m (count board) (count (first board)))))))\n          (find-all [board sym]\n            (for [n (range (count board))\n                  m (range (count (first board)))\n                  :let [cell (get-in board [n m])]\n                  :when (= sym cell)]\n              (find-turns board sym n m)))]\n    (apply merge (find-all board sym))))", "user": "540a4f20e4b0addc1aec66ef"}, {"problem": 124, "code": "(letfn [                                                                                                                                                \n    (coords-from [board [y x]]   ; get a list of linear coordinates starting at y,x                                             \n        (let [size (count board)]                                                                                                                       \n            (map (fn [[dy dx]]                                                                                                  \n                (take-while (fn [[y' x']] (and (>= y' 0) (>= x' 0) (< y' size) (< x' size)))                                                            \n                    (map #(vector (+ y (* % dy)) (+ x (* % dx))) (range 1 (inc size)))))                                        \n            [[1 0] [1 1] [0 1] [-1 1] [-1 0] [-1 -1] [0 -1] [1 -1]])))                                                                                  \n    (check-direction [board direction color]                                                                                    \n        (if (< (count direction) 2)                                                                                                                     \n            [] ; no flips are possible                                                                                          \n            (let [color' ({'b 'w 'w 'b} color)                                                                                                          \n                  flips  (take-while #(= color' (get-in board %)) direction)                                                    \n                  valid? (= color (get-in board (first (drop (count flips) direction))))]                                                               \n                        (if valid? flips []))))                                                                                 \n    (check-coords [board location color]                                                                                                                \n        (set (mapcat #(check-direction board % color) (coords-from board location))))                                           \n    (check-board [board color]                                                                                                                          \n        (let [size (count board)                                                                                                \n              emptys (for [y (range size) x (range size) :when (= 'e (get-in board [y x]))] [y x])]                                                     \n            (reduce                                                                                                             \n                (fn [a c]                                                                                                                               \n                    (let [flips (check-coords board c color)]                                                                   \n                        (if (empty? flips)                                                                                                              \n                            a                                                                                                   \n                            (assoc a c flips))))                                                                                                        \n                {}                                                                                                              \n                emptys)))]                                                                                                                              \n        check-board)", "user": "558b50d5e4b027778923762b"}, {"problem": 124, "code": "(fn [B c]\n   (let [p (fn [p]\n             (if (= p c) :s (if (= p 'e) :e :d)))\n         z (range 0 4)\n         f (fn [i j]\n             (->> [[0 1] [1 1] [1 0] [1 -1] [0 -1] [-1 -1] [-1 0] [-1 1]]\n                  (map (fn [[r s]] \n                         (for [x (drop 1 z)\n                               :let [a (+ i (* r x)) b (+ j (* s x))]\n                               :while (and (contains? B a) (contains? (last B) b))\n                               ] \n                           [(p ((B a) b)) [a b]])))\n                  (mapcat (fn [V]\n                            (map second\n                                 (let [s (map first V)]\n                                   (cond (= (take 2 s) [:d :s]) (take 1 V)\n                                         (= (take 3 s) [:d :d :s]) (take 2 V)\n                                         :else [])\n                                   ))))\n                  (set)))\n         ]\n     (into {}\n           (for [x z y z :when (= ((B x) y) 'e)\n                 :let [f (f x y)]\n                 :when (seq f)] [[x y] f]))))", "user": "559c13c5e4b066d22e731f61"}, {"problem": 124, "code": "(fn [b s]\n  (let [\n        mv (fn [b s c]\n               (let [\n                     o {'w 'b 'b 'w}\n                     r {'w #\"eb+w.*\" 'b #\"ew+b.*\"}\n                     ss [[0 -1] [0 1] [1 0] [-1 0] [1 1] [-1 -1] [-1 1] [1 -1]]\n                     vv #(contains? (set (range 0 4)) %)\n                     vp (fn [p] (every? vv p))\n                     as (fn [[cr cc] [rs, cs]] [(+ cr rs) (+ cc cs)])\n                     cl (map (fn [step] (take-while vp (iterate #(as % step) c))) ss)\n                     ml (fn [l] (re-matches (r s) (apply str (map #(get-in b %) l))))\n                     mls (filter ml cl)\n                     ]\n                 (set (mapcat (fn [l] (filter #(= (o s) (get-in b %)) l)) mls))\n                 ))\n        ec (for [r (range 0 4) c (range 0 4) :when (= 'e (get-in b [r c]))] [r c])\n        ms (apply hash-map (mapcat (fn [c] [c (mv b s c)]) ec))\n        ]\n    (into {} (filter #(not-empty (second %)) ms))\n    ))", "user": "52593207e4b0cb4875a45cd3"}, {"problem": 124, "code": "(fn reversi [board s]\n  (let [other     (if (= s 'w) 'b 'w)\n        direction-verbs [inc identity dec]\n        has-neighbor (fn [y x]\n                       (some (partial = other)\n                             (for [fx direction-verbs fy direction-verbs]\n                               (get-in board [(fy y) (fx x)]))))\n        directions (for [fx direction-verbs fy direction-verbs\n                         :when (not= fx fy identity)] (vector fx fy))\n        follow-out (fn [x y fx fy]\n                     (loop [path nil x (fx x) y (fy y)]\n                       (let [val-at (get-in board [y x])]\n                         (cond\n                           (= val-at other) (recur (cons [y x] path) (fx x) (fy y))\n                           (= val-at s) path\n                           :else\n                            nil))))\n        all-vectors (fn [x y]\n                      (into #{} (first (filter identity (map (fn [[fx fy]] (follow-out x y fx fy)) directions)))))\n        starting-points (for [x (range 4) y (range 4)\n                              :when (and (= 'e (get-in board [y x]))\n                                         (has-neighbor y x))] (vector y x))]\n    (into {} (filter #(not-empty (second %)) (map (fn [[y x]] (vector [y x] (all-vectors x y))) starting-points)))))", "user": "55934bebe4b0c79f6e1db93b"}, {"problem": 124, "code": "(fn reversi [board turn]\n  (let [f (fn [x] (if (pos? x) 1 (if (neg? x) -1 0)))\n        oppo (first (disj #{'b 'w} turn))]\n    (into {}\n          (filter (comp not empty? second)\n                  (for [a (range 4)\n                        b (range 4)\n                        :when (= 'e (get-in board [a b]))]\n                    [[a b]\n                     (set \n                       (apply concat\n                              (for [i (range 4)\n                                    j (range 4)\n                                    :when (and (= turn (get-in board [i j]))\n                                              (or (= i a) (= j b) (= (* (- a i) (- a i)) (* (- b j) (- b j)))))\n                                    k [[(f (- a i)) (f (- b j))]]\n                                    l [(drop 1 (take-while #(not= % [a b]) (iterate #(map + % k) [i j])))]\n                                    :when (every? #(= oppo (get-in board %)) l)]\n                                l)))])))))", "user": "55625903e4b0c656e3ff17d7"}, {"problem": 124, "code": "(fn [board player]\n  (let [values {player :player 'e :empty}\n        improved-board (map-indexed \n                        (fn [i row]\n                          (map-indexed (fn [j cell] [[i j] (or (values cell) :adversary)]) row)) \n                        board)\n        harvester (fn [[move flipped] [cell value]] \n                    (if move \n                      [move flipped] \n                      (cond \n                       (= value :player) [nil #{}] \n                       (= value :empty) (if (empty? flipped) [nil nil] [cell flipped]) \n                       :else (if flipped [nil (conj flipped cell)] [nil nil])\n                       )))\n        seqs (concat improved-board \n                     (apply map list improved-board)\n                     [(map #(nth (nth improved-board (first %)) (second %)) [[0 0] [1 1] [2 2] [3 3]])]\n                     [(map #(nth (nth improved-board (first %)) (second %)) [[0 3] [1 2] [2 1] [3 0]])])\n        all (concat seqs (map reverse seqs))\n        ]\n    (into {} (filter #(and (first %) (not (empty? (second %)))) (map #(reduce harvester [nil nil] %) all))))\n    )", "user": "55a74d46e4b09e57187da2a3"}, {"problem": 124, "code": "(fn [board color]\n   (let [empty-coords (for [i (range (count board))\n                      j (range (count (nth board i)))\n                      :when (-> board (nth i) (nth j) (#{'e}))]\n                  [i j])\n         ;deltas [[-1 0] [1 0] [-1 -1] [0 1] [0 -1] [1 1] [-1 1] [1 -1]]\n         deltas (for [i [0 -1 1] j [0 -1 1] :when (not= i j 0)] [i j])\n         -board (fn [[a b]] (get-in board [a b]))\n         ;; create a path in all directions\n         paths (fn [x y] (for [[i j] deltas]\n                          (next (iterate\n                                   (fn [[a b]] [(+ a i) (+ b j)])\n                                   [x y]))))\n         opponent '{w b, b w}\n         opp ('{w b b w} color)\n         ]\n     empty-coords\n     (into {}\n           (for [[x y] empty-coords\n                 :let [ps (paths x y)\n                       ps (for [p ps\n                                :let [[enemy [stop]]\n                                         (split-with (comp #{opp} -board) p)]\n                                :when (= (-board stop) color)]\n                            enemy)\n                       s (apply concat ps)\n                       \n                       ]\n                 :when (seq s)]\n             [[x y] (set s)]))))", "user": "55be39f9e4b01b9910ae2a06"}, {"problem": 124, "code": "(fn reversi [board piece]\n  (let [size (count board)\n          other (if (= 'w piece) 'b 'w)\n          board (vec (flatten board))\n          other-positions (filter #(= other (board %)) (range (* size size)))\n          positions (filter #(= piece (board %)) (range (* size size)))\n          offsets #{1 3 4 5}\n\n          make-coord (fn [x] [(quot x size) (rem x size)])\n          same-row? (fn [x y] (= (quot x size) (quot y size)))\n          valid-coord? (fn [x] (and (>= x 0) (< x (* size size))))\n          ]\n    (into {}\n          (map (fn [[x cs]]\n                [(make-coord x)\n                 (into #{}\n                       (map\n                         (fn [y] (make-coord y))\n                         cs))])\n              (filter identity\n                  (map (fn [[x y]]\n                            (let [step (- y x)\n                                  new-x (+ y step)\n                                  new-2x (+ new-x step)\n                                  ]\n                              (cond (and (valid-coord? new-x)\n                                         (= 'e (board new-x))\n                                         (if (same-row? x y) (same-row? x new-x) true))\n                                       [new-x [y]]\n                                    (and (valid-coord? new-x)\n                                         (= other (board new-x))\n                                         (valid-coord? new-2x)\n                                         (= 'e (board new-2x))\n                                         (if (same-row? x y) (same-row? x new-x) true)\n                                         (if (same-row? x y) (same-row? x new-2x) true))\n                                       [new-2x [y new-x]]\n                                    :else nil)))\n                        (for [x positions y other-positions\n                              :when (offsets (Math/abs (- x y)))]\n                            [x y]\n                    )))))))", "user": "559b55d6e4b066d22e731f54"}, {"problem": 124, "code": "(fn [b m]\n  (let [o (if (= m 'w) 'b 'w)\n        gp #(get-in b [%1 %2])\n        mp (fn [x y c] (int (+ x (* (- y x) c))))\n        ca (fn [s f l?]\n             (let [x (first s)\n                   y (last s)\n                   a (first f)\n                   b (last f)\n                   nc (if l? 1/3 1/2)\n                   c (mp x a nc)\n                   d (mp y b nc)\n                   nn (gp c d)\n                   e (mp x a 2/3)\n                   f (mp y b 2/3)\n                   mn (gp e f)\n                   fn (gp a b)]\n               {[x y]\n                (if (= (gp x y) 'e)\n                  (cond\n                    (and l? (= nn o) (= mn m)) #{[c d]}\n                    (and (not l?) (= nn o) (= fn m)) #{[c d]}\n                    (and l? (= nn o) (= mn o) (= fn m)) #{[c d] [e f]}\n                    :else #{})\n                    #{})}))\n        cp (fn [x m] (reduce #(merge-with into %1 %2) {}\n                       (map #(ca x (first %) (last %)) m)))\n        cm #{[[0 0] [[[0 3] true] [[3 0] true] [[3 3] true]]]\n             [[0 1] [[[0 3] false] [[3 1] true] [[2 3] false]]]\n             [[0 2] [[[0 0] false] [[3 2] true] [[2 0] false]]]\n             [[0 3] [[[0 0] true] [[3 3] true] [[3 0] true]]]\n             [[1 3] [[[1 0] true] [[3 3] false] [[3 1] false]]]\n             [[2 3] [[[2 0] true] [[0 3] false] [[0 1] false]]]\n             [[3 3] [[[0 3] true] [[3 0] true] [[0 0] true]]]\n             [[3 2] [[[3 0] false] [[0 2] true] [[1 0] false]]]\n             [[3 1] [[[3 3] false] [[0 1] true] [[1 3] false]]]\n             [[3 0] [[[0 0] true] [[3 3] true] [[0 3] true]]]\n             [[2 0] [[[0 0] false] [[2 3] true] [[0 2] false]]]\n             [[1 0] [[[3 0] false] [[1 3] true] [[3 2] false]]]}]\n    (reduce into (filter #(not (empty? (first (vals %))))\n                   (map #(cp (first %) (last %)) cm)))))", "user": "55205564e4b08d5046aa8a60"}, {"problem": 124, "code": ";; ugly as hell but I do not want to work on it anymore\n(fn [board color]\n  (letfn [(opposite-of [color]\n            (if (= color 'w) 'b 'w))\n          (valid? [move]\n            (let [move-str (clojure.string/join \"\" move)]\n              (boolean (or (re-matches #\"e*w+b+e+\" move-str)\n                           (re-matches #\"e*b+w+e+\" move-str)))))\n          (color-positions [color board]\n            (set\n             (for [[ridx row] (map-indexed vector board)\n                   [cidx cell] (map-indexed vector row)\n                   :when (= cell color)]\n               [ridx cidx])))\n          (in-bounds? [[ridx cidx]]\n            (and (>= ridx 0)\n                 (>= cidx 0)\n                 (< ridx 4)\n                 (< cidx 4)))\n          (diagonal-down-move [start-pos board]\n            (let [up-left-pos (last (take-while in-bounds? (iterate #(mapv dec %) start-pos)))]\n              (vec (for [i (range 4)\n                         :let [pos (mapv #(+ % i) up-left-pos)]\n                         :when (in-bounds? pos)]\n                     (list (get-in board pos) pos)))))\n          (diagonal-up-move [start-pos board]\n            (let [[down-row down-col] (last (take-while in-bounds? (iterate (fn [[r c]] [(inc r) (dec c)]) start-pos)))]\n              (vec (for [i (range 4)\n                         :let [pos [(- down-row i) (+ down-col i)]]\n                         :when (in-bounds? pos)]\n                     (list (get-in board pos) pos)))))\n          (all-moves-from [[ridx cidx :as pos] board]\n            (let [size (count board)\n                  row-level (vec (map-indexed (fn [idx itm] (list itm [ridx idx])) (get board ridx)))\n                  col-level (vec (map-indexed (fn [idx itm] (list (get itm cidx) [idx cidx])) board))\n                  diag-down (diagonal-down-move pos board)\n                  diag-up (diagonal-up-move pos board)]\n\n              (set [row-level col-level diag-down diag-up])))\n          (valid-moves [pos board]\n            (set (for [move (all-moves-from pos board)\n                       :let [color-move (map first move)]\n                       :when (valid? color-move)]\n                   move)))\n          (positions-of-flips [move color]\n            (->> move\n                 (filter (comp #(and (not= % 'e) (not= % color)) first))\n                 (map second)\n                 (set)))\n          (jump-position [move color]\n            (let [move-str (clojure.string/join \"\" (map first move))\n                  pattern-fwd (re-pattern (str \"e*\" color \"+\" (opposite-of color) \"+e+\"))\n                  pattern-bck (re-pattern (str \"e*\" (opposite-of color) \"+\" color \"+e+\"))]\n              (if (re-matches pattern-fwd move-str)\n                (last (last move))\n                (last (first move)))))]\n\n    (apply merge-with clojure.set/union\n           (for [color-pos (color-positions color board)\n                 move (valid-moves color-pos board)]\n             {(jump-position move color) (positions-of-flips move color)}))))", "user": "5344fe13e4b084c2834f4a32"}, {"problem": 124, "code": "(fn [board colour]\n\n  (let [get-piece (fn\n                    [board [y x]]\n                    (get (get board y) x))\n\n        get-next-step (fn\n                        [[pos-y pos-x] [direction-y direction-x]]\n                        [(+ direction-y pos-y) (+ direction-x pos-x)])\n\n        get-all-direction-steps (fn\n                                  [board-height [start-y start-x]]\n                                  (map (fn [direction]\n                                         (take (- board-height 1) (iterate #(get-next-step % direction) (get-next-step [start-y start-x] direction))))\n                                       [[-1 0] [-1 -1] [0 -1] [1 -1] [1 0] [1 1] [0 1] [-1 1]]))\n\n        find-empty-tiles (fn\n                           [board]\n                           (let [board-height (count board)\n                                 board-width (count (first board))]\n                             (for [y (range 0 board-height)\n                                   x (range 0 board-width)\n                                   :when (= (get-piece board [y x]) 'e)]\n                               [y x])))\n\n        get-possible-flips (fn\n                             [board colour empty-tiles-pos original-tile]\n                             (let [opp-colour (if (= colour 'w) 'b 'w)\n                                   tile-pieces (map #(get-piece board %) empty-tiles-pos)]\n                               (when (and (some #{opp-colour} tile-pieces)\n                                          (some #{colour} tile-pieces)\n                                          (= (first tile-pieces) opp-colour))\n                                 {original-tile (set (for [current-tile empty-tiles-pos\n                                                           :when (= (get-piece board current-tile) opp-colour)]\n                                                       current-tile))})))\n\n        check-all-directions (fn\n                               [board colour start-pos]\n                               (into {} (map (fn [tiles-pos] (get-possible-flips board colour tiles-pos start-pos)) (get-all-direction-steps (count board) start-pos))))]\n\n        (apply merge (map (fn [coord] (check-all-directions board colour coord)) (find-empty-tiles board)))))", "user": "559fb147e4b0acc240e314ea"}, {"problem": 124, "code": "(fn [matrix mark]\n    (let [m (count matrix)\n          n (count (first matrix))\n          other-mark (if (= mark 'w) 'b 'w)\n          ]\n      (letfn [(top-left [y x] (map #(identity [%1 %2]) (range y -1 -1) (range x -1 -1)))\n              (top-right  [y x] (map #(identity [%1 %2]) (range y -1 -1) (range x n 1)))\n              (bottom-right  [y x] (map #(identity [%1 %2]) (range y m 1) (range x n 1)))\n              (bottom-left  [y x] (map #(identity [%1 %2]) (range y m 1) (range x -1 -1)))\n              (top [y x] (map #(identity [%1 %2]) (range y -1 -1) (repeat x)))\n              (bottom [y x] (map #(identity [%1 %2]) (range y m 1) (repeat x)))\n              (right [y x] (map #(identity [%1 %2]) (repeat y) (range x n 1)))\n              (left [y x] (map #(identity [%1 %2]) (repeat y) (range x -1 -1)))\n              (get-pushable-point [path]\n                (let [v (map  (partial get-in matrix) path) ]\n                  (when (= (first v) 'e)\n                    (loop [[vf & vs] (next v) [lf & ls] (next path) recode #{}]\n                      (cond (and ((comp not empty?) recode) (= vf mark))  recode\n                            (= vf other-mark) (recur vs  ls (conj recode lf)))))))\n              (all-way [x y] ((juxt top top-left left bottom-left bottom bottom-right right top-right) x y))\n              (get-by-point[x y]\n                (->>\n                  (map get-pushable-point (all-way x y))\n                  (filter (comp not nil?))\n                  (apply merge))) ]\n        (->> (for [i (range 0 n) j (range 0 m)]\n               (let [ x (get-by-point i j)]\n                 (when ((comp not empty?) x)\n                   {[i j] x})))\n          (apply merge))\n        )))", "user": "55aa1637e4b0988bba2ad949"}, {"problem": 124, "code": "(fn [board color]\n   (let [MAXL (count board)\n         MAXC (count (first board))\n         COMP ({'b 'w 'w 'b} color)]\n     (letfn [(empties []\n                      (for [i (range MAXL)\n                            j (range MAXC)\n                            :when (= 'e ((board i) j))]\n                        [i j]))\n\n             (flipped-coor [coll]\n                           (let [colors (for [coor coll\n                                              :let [x (first coor)\n                                                    y (second coor)]\n                                              :while (or (= [x y] (first coll))\n                                                         (not= ((board x) y) 'e))\n                                              ]\n                                          ((board x) y))]\n                             (cond\n                               (> 3 (count colors)) nil\n                               (= color (last colors))\n                               (set (take (count (filter #(= COMP %) colors)) (rest coll)))\n                               )))\n\n             (flipped [coor]\n                      (let [x (first coor)\n                            y (second coor)\n                            flipped-coors\n                            (apply clojure.set/union #{}\n                                   (map flipped-coor\n                                        (conj []\n                                              ; line\n                                              (for [j (range y MAXC)] [x j])\n                                              (for [j (reverse (range (inc y)))] [x j])\n                                              ; coll\n                                              (for [i (range x MAXL)] [i y])\n                                              (for [i (reverse (range (inc x)))] [i y])\n                                              ; cross\n                                              (for [i (range MAXC)\n                                                    :let [x' (+ x i)\n                                                          y' (+ y i)]\n                                                    :while (and (< x' MAXL)\n                                                                (< y' MAXC))] [x' y'])\n                                              (for [i (range MAXC)\n                                                    :let [x' (- x i)\n                                                          y' (- y i)]\n                                                    :while (and (>= x' 0)\n                                                                (>= y' 0))] [x' y'])\n                                              (for [i (range MAXC)\n                                                    :let [x' (+ x i)\n                                                          y' (- y i)]\n                                                    :while (and (< x' MAXL)\n                                                                (>= y' 0))] [x' y'])\n                                              (for [i (range MAXC)\n                                                    :let [x' (- x i)\n                                                          y' (+ y i)]\n                                                    :while (and (>= x' 0)\n                                                                (< y' MAXC))] [x' y'])\n                                              )))]\n\n                        (if (not-empty flipped-coors)\n                          [coor flipped-coors]\n                          nil)\n\n                        ))\n             ]\n       (reduce #(conj %1 (apply hash-map %2)) {}\n         (filter (complement nil?)\n                 (for [c (empties)]\n                   (flipped c)))))))", "user": "55a372f1e4b0acc240e31537"}, {"problem": 124, "code": "(fn valid-moves [board player]\n  (let [opposite (fn [p] (if (= p 'b) 'w 'b))\n        max-size 4\n        dirs (for [x (range -1 2) y (range -1 2) :when (or (not= 0 x) (not= 0 y))] [x y])\n        in-grid (fn [[i j]] (and (< i max-size) (< j max-size) (>= i 0) (>= j 0)))\n        potential-moves\n        (fn [board [x y]]\n            (->> (map (fn [[i j]] [(+ i x) (+ j y)]) dirs)\n                 (filter in-grid)\n                 (filter (fn [[i j]] (= 'e (get-in board [i j]))))))\n        to-flip\n        (fn [board [x y] color]\n          (let [check-dirs\n                (fn [board color x y [dx dy]]\n                  (loop [i (+ x dx) j (+ y dy) res []]\n                    (cond (not (in-grid [i j]))\n                          []\n                          (= color (get-in board [i j]))\n                          res\n                          (= (opposite color) (get-in board [i j]))\n                          (recur (+ i dx) (+ j dy) (conj res [i j]))\n                          :else\n                          []\n                          )))]\n          (->> (map (partial check-dirs board color x y) dirs)\n               (apply concat)\n               (into #{})\n               )))]\n    (->> (for [x (range 0 max-size)\n               y (range 0 max-size)\n               :when (= (get-in board [x y]) (opposite player))]\n           [x y])\n         (map #(potential-moves board %))\n         (apply concat)\n         (into #{})\n         (map #(vector % (to-flip board % player)))\n         (filter #(seq (second %)))\n         (into {})\n         )))", "user": "54f09599e4b024c67c0cf89d"}, {"problem": 124, "code": "(fn [b v]\n  (let [changes (fn [[y x] dy dx]\n                  (let [av (if (= v 'w) 'b 'w)]\n                    (loop [y (+ y dy)\n                           x (+ x dx)\n                           result #{}]\n                      (if (and (>= x 0) (<= x 3) (>= y 0) (<= y 3))\n                        (let [curr (get-in b [y x])]\n                          (cond\n                            (= curr v) result\n                            (= curr av) (recur (+ y dy)\n                                            (+ x dx)\n                                            (conj result [y x]))\n                            :else #{}))\n                        #{}))))\n        move (fn [[y x]]\n                (let [dy (if (< y 2) 1 -1)\n                      dx (if (< x 2) 1 -1)]\n                  [[y x] (clojure.set/union (changes [y x] 0 dx)\n                                            (changes [y x] dy 0)\n                                            (changes [y x] dy dx))]))]\n    (->> (for [y (range 4)\n               x (range 4)\n               :when (= (get-in b [y x]) 'e)]\n           [y x])\n         (map move)\n         (filter (comp not empty? second))\n         ((fn [coll] (reduce #(assoc %1 (first %2) (second %2))\n                            {} coll))))))", "user": "549c6792e4b0f3d1d8e70f8b"}, {"problem": 124, "code": "(fn [b me]\n  (let [dirs (disj (set (for [y [-1 0 1] x [-1 0 1]] [y x])) [0 0])\n        opp (if (= me 'w) 'b 'w)]\n    (into {} (for [y (range 4)\n                   x (range 4)\n                   :when (= 'e ((b y) x))\n                   :let [cap (fn [[dy dx]]\n                               (let [ray (drop 1 (iterate (fn [[y x]] [(+ y dy) (+ x dx)]) [y x]))\n                                     [flips raymainder] (split-with #(= opp (get-in b %)) ray)]\n                                 (if (= me (get-in b (first raymainder)))\n                                   flips\n                                   [])))\n                         c (mapcat cap dirs)]\n                   :when (seq c)]\n               [[y x] (set c)]))))", "user": "4f5eda39e4b0030a34fb2b56"}, {"problem": 124, "code": "(fn [board player]\n  (let [deltas [[-1 -1] [-1  0] [-1  1]\n                [ 0 -1]         [ 0  1]\n                [ 1 -1] [ 1  0] [ 1  1]]\n        other? #(or (and (= player 'w) (= % 'b))\n                    (and (= player 'b) (= % 'w)))\n        get-at (fn [[i j]] (-> board (get i) (get j)))\n        step #(map (comp (partial apply +) vector) %1 %2)\n        get-flips (fn [start delta]\n                    (let [places (iterate (partial step delta) start)\n                          [flips more] (split-with (comp other? get-at) (rest places))]\n                      (if (= player (get-at (first more))) flips)))\n        ]\n    (into {} (for [[i row] (map-indexed vector board)\n                   [j piece] (map-indexed vector row)\n                   :when (= piece 'e)]\n               (let [flips (mapcat (partial get-flips [i j]) deltas)]\n                 (if (not (empty? flips)) (vector [i j] (into #{} flips))))))))", "user": "549dfe40e4b0f3d1d8e70f9a"}, {"problem": 124, "code": "(letfn [(other-piece \n         [piece]\n         (condp = piece\n           'w 'b\n           'b 'w\n           nil))\n\n        (index-pieces\n         [board]\n         (for [[row-index row] (map-indexed vector board)\n               [column-index piece] (map-indexed vector row)]\n           [[row-index column-index] piece]))\n\n        (blocks \n         [indexed-pieces]\n         (let [grouping-fns [first second #(apply - %) #(apply + %)]]\n           (mapcat #(->> indexed-pieces\n                         (group-by (comp % first))\n                         (map second)) \n                   grouping-fns)))\n\n        (piece-placements \n         [piece block]\n         (->> block\n              (partition-by second)\n              (partition 3 1)\n              (filter (fn [sections]\n                        (let [pieces (map #(-> % first second) sections)]\n                          (or (= pieces [piece (other-piece piece) 'e])\n                              (= pieces ['e (other-piece piece) piece])))))\n              (map (fn [[left middle right]]\n                     (let [flipped (set (map first middle))\n                           placement (if (= 'e (-> left first second))\n                                       (-> left last first)\n                                       (-> right first first))]\n                       {placement flipped})))))\n\n        (solve\n         [board piece]\n         (->> board\n              index-pieces\n              blocks\n              (map (partial piece-placements piece))\n              (remove empty?)\n              flatten\n              (apply merge-with clojure.set/union)))]\n  solve)", "user": "55f2e47de4b06e875b46ce4d"}, {"problem": 124, "code": "(fn reversi [b turn]\n  (let [directions '([-1 -1] [-1 0] [-1 1] [0 -1] [0 1] [1 -1] [1 0] [1 1])]\n    (letfn [(traverse-direction [pos direction count color acc]\n                                (let [checkpos [(+ (first pos) (first direction)) (+ (second pos) (second direction))]\n                                      checkval (get-in b checkpos)]\n                                  (cond\n                                    (or (= checkval nil) (= checkval 'e)) nil\n                                    (and (= checkval color) (= count 0)) nil\n                                    (= checkval color) acc\n                                    :otherwise (traverse-direction checkpos direction (inc count) color (conj acc checkpos)))))\n            (move [pos color]\n                  (let [pos-val (get-in b pos)]\n                    (when (= 'e pos-val)\n                      (reduce  (fn [acc v]\n                                 (let [path (traverse-direction pos v 0 turn #{})]\n                                   (if path (conj acc {pos path}) acc)))\n                               {} directions))))]\n      (let [all-moves (for [x (range 0 4) y (range 0 4)]\n              (move [x y] turn))]\n        (into {} (filter #(not= nil %)  all-moves))))))", "user": "5592bf9fe4b0c79f6e1db933"}, {"problem": 124, "code": "(fn findPattern [board piece]\n  (letfn [(myget [board [x y]]\n            (let [w (count board)]\n              (if (and (< -1 x w)\n                       (< -1 y w))\n                (get-in board [x y])\n                'x)))\n          (findPiece [board p]\n            (for [x (range (count board))\n                  y (range (count board))\n                  :when (= p (get-in board [x y]))]\n              [x y]))\n          (findEachPoint [[x y] board patternSet]\n            (let [patterns [[[ 0  1] [ 0  2]]\n                            [[ 0 -1] [ 0 -2]]\n                            [[ 1  0] [ 2  0]]\n                            [[-1  0] [-2  0]]\n                            [[ 1  1] [ 2  2]]\n                            [[-1  1] [-2  2]]\n                            [[ 1 -1] [ 2 -2]]\n                            [[-1 -1] [-2 -2]]\n                            [[ 0  1] [ 0  2] [ 0  3]]\n                            [[ 0 -1] [ 0 -2] [ 0 -3]]\n                            [[ 1  0] [ 2  0] [ 3  0]]\n                            [[-1  0] [-2  0] [-3  0]]\n                            [[ 1  1] [ 2  2] [ 3  3]]\n                            [[-1  1] [-2  2] [-3  3]]\n                            [[ 1 -1] [ 2 -2] [ 3 -3]]\n                            [[-1 -1] [-2 -2] [-3 -3]]]]\n              (reduce (fn [result row]\n                        (do\n                          (if (contains? patternSet\n                                         (map (fn [elem] (myget board (mapv + [x y] elem))) row))\n                            (let [pts (reverse (map #(mapv + [x y] %) row))]\n                              (assoc result (first pts) (set (rest pts))))\n                            result)))\n                      {}\n                      patterns)))\n          ]\n    (let [ pattern {'w #{['b 'e] ['b 'b 'e]}\n                    'b #{['w 'e] ['w 'w 'e]}}]                                                                                                                                                                 \n      (reduce (fn [result elem]\n                (merge result\n                       (findEachPoint elem board (piece pattern))))\n              {}\n              (findPiece board piece)))))", "user": "54f64e99e4b0f2f3c5226ea4"}, {"problem": 124, "code": "(fn [board color]\n    (letfn [(n  [[x y]] [(dec x) y])\n            (s  [[x y]] [(inc x) y])\n            (e  [[x y]] [x (inc y)])\n            (w  [[x y]] [x (dec y)])]\n      (let [ne (comp n e)\n            nw (comp n w)\n            se (comp s e)\n            sw (comp s w)]\n        (letfn [;; A lazy seq of coordinates starting at [x y] in direction (n, s, e, w, ne, nw, se, sw).\n                (path\n                  [xy direction]\n                  (cons xy (lazy-seq (path (direction xy) direction))))\n                ;; Starting at [x y], explore direction until the goal color is found or the search is exhausted.\n                ;; If successful, return a vector of the starting coordinates and a set of the intervening coordinates.\n                (explore\n                  [board xy direction color]\n                  (loop [p (drop 1 (path xy direction))\n                         r []]\n                    (when-let [v (and (seq p) (get-in board (first p)))]\n                      (condp = v\n                        color [xy (set r)]\n                        'e    nil\n                        (recur (next p) (conj r (first p)))))))\n                (explore-8\n                  [board xy color]\n                  (reduce into []\n                          (filter #(not (empty? (second %)))\n                                  (map #(explore board xy % color) [n s e w ne nw se sw]))))\n                (empty-squares\n                  [b]\n                  (let [r (range (count b))] (for [x r, y r :when (= 'e (get-in b [x y]))] [x y])))\n                (solve\n                  [board color]\n                  (let [x (partition 2 (reduce into [] (remove empty? (map #(explore-8 board % color) (empty-squares board)))))]\n                    (zipmap (map first x) (map second x))))]\n          (solve board color)))))", "user": "52485f02e4b05ef8e38e63d3"}, {"problem": 124, "code": "(fn [board player]\n  (let [dirs [[-1 0] [-1 1] [0 1] [1 1] [1 0] [1 -1] [0 -1] [-1 -1]]\n        enemy (if (= player 'b) 'w 'b)\n        legal (fn [x0 y0]\n                (for [[xd yd] dirs]\n                  (loop [x x0, y y0, flip #{}]\n                    (let [x (+ x xd)\n                          y (+ y yd)\n                          s (get-in board [x y] nil)]\n                      (if (= s enemy)\n                        (recur x y (conj flip [x y]))\n                        (when (and (= s 'e) (seq flip))\n                          {[x y] flip}))))))]\n    (into {} (for [row (range 5)\n                   col (range 5) :when (= player (get-in board [row col]))]\n               (into {} (legal row col))))))", "user": "53576356e4b04ce2eb3ed27a"}, {"problem": 124, "code": "(fn reversi [board my]\n  (let [locs (for [i (range 4) j (range 4)] [i j])\n        directions [[0 1] [0 -1] [1 0] [-1 0] [1 1] [-1 -1] [1 -1] [-1 1]]\n        his (if (= my 'w) 'b 'w)\n        p (partial get-in board)\n        is-sol? (fn [coll] (and (>= (count coll) 3) (-> coll last p (= my))))\n        is-valid? (fn [coll] (every? #{his} (map p (rest (butlast coll)))))\n        set-conj (fnil into #{})\n        blanks (filter (comp #{'e} p) locs)\n        step (fn [[dx dy]] (fn [coll] (let [[x y] (last coll)]\n                                        (conj coll [(+ x dx) (+ y dy)]))))]\n    (reduce (fn [acc s]\n              (update-in acc [(first s)] set-conj (butlast (rest s)))) {}\n            (for [p blanks\n                  dir directions\n                  :let [end (last (take-while is-valid? (iterate (step dir) [p])))]\n                  :when (is-sol? end)]\n              end))))", "user": "5307e4ece4b02e82168697a9"}, {"problem": 124, "code": "(fn [board c]\n  (let [M (range (count board))\n        N (range (count (first board)))\n        D (range -1 2)\n        B (partial get-in board)\n        P (fn [i j]\n            (for [di D dj D :when (not= 0 di dj)]\n              (take-while (comp #{'b 'w} B) (drop 1 (iterate (partial map + [di dj]) [i j])))))\n        S (fn [i j] (mapcat (fn [p] (let [e (take-while (comp not #{c} B) p)] (if (not= e p) e))) (P i j)))]\n   (into {} (for [i M j N :let [f (S i j)] :when (and (= 'e (B [i j])) (not-empty f))] [[i j] (set f)]))))", "user": "55f6fe09e4b06e875b46cea2"}, {"problem": 124, "code": "(fn puzzle [board player-sym]\n  (let [vs #{[-1 -1] [-1 0] [-1 1] [0 -1] [0 1] [1 -1] [1 0] [1 1]}\n        player (keyword player-sym)\n        opponent (case player :w :b :b :w)]\n    (letfn [(point-val [[py px]]\n                       (keyword (nth (nth board py '()) px nil)))\n            (direction [[py px] [vy vx]]\n                       (take-while point-val\n                                   (map #(vector (+ py (* vy %)) (+ px (* vx %)))\n                                        (drop 1 (range)))))\n            (direction-wins [p v]\n                            (let [[op r] (split-with #(= (point-val %) opponent) (direction p v))]\n                              (if (and (seq op) (seq r) (= player (point-val (first r)))) op)))\n            (surround-wins [p]\n                           (set (mapcat #(direction-wins p %) vs)))]\n      (into {}\n        (remove #(empty? (second %))\n                (for [y (range (count board)) x (range (count (first board))) \n                      :when (= :e (point-val [y x]))]\n                  [[y x] (surround-wins [y x])]))))))", "user": "53286f84e4b09d4e7a9b5505"}, {"problem": 124, "code": "(fn prob124 [board color]\n  (letfn [(directions []\n            ;; return all the directions including diagonals\n            (for [r [-1 0 1]\n                  c [-1 0 1]\n                  :when (not= r c 0)]\n              [r c])\n            \n            ;; [[0 -1]]\n            )\n          \n          (walk-to-end [pos dir dim]\n            ;; return the seq from a given pos to the end of the board\n            ;; dim is the size of the board\n            \n            ;; ensure we don't have a pos with -1 or dim values\n            (letfn [(valid? ([[r c]] (and (> r -1) (< r dim) (> c -1) (< c dim))))]\n              ;; return all the the current pos\n              (rest (take-while valid? (iterate #(map + dir %) pos)))))\n          \n          (opposite-color [color]\n            (cond\n              (= 'w color) 'b\n              (= 'b color) 'w))\n          \n          (is-opponent [board color pos]\n            (let [opp (opposite-color color)]\n              (= opp (get-in board pos))))\n          \n          (find-empty-positions [board]\n            ;; assumming square board\n            (let [dim (count board)]\n              ;; iterate over board returning all 'e positions\n              (for [r (range dim)\n                    c (range dim)\n                    :when (= 'e (get-in board [r c]))]\n                [r c])))\n          \n          (search [board color pos]\n            ;; this filter looks crufty. it removes the empty nil searches\n            (filter #(not (nil? %))\n                    ;; for each direction          \n                    (for [dir (directions)]\n                      ;; walk to end from pos and return all the board contents\n                      ;; the split-with ideas comes from amalloy's solution\n                      ;; @see https://gist.github.com/amalloy/1244458\n                      (let [contents (walk-to-end pos dir (count board))\n                            [captured end] (split-with #(is-opponent board color %) contents)]\n                        ;; if end is your color\n                        ;; if every in captured is opposite of your color\n                        (if (and (= color (get-in board (first end)))\n                                 (seq captured)\n                                 (every? #(is-opponent board color %) captured))\n                          [pos captured]\n                          )))))]\n    (let [empty-positions (find-empty-positions board)\n          dim (count board)]\n      ;; this filter looks crufty. it removes the empty nil searches\n      (let [res (filter #(not (every? empty? %))\n                        ;; search the board for each empty position\n                        (for [pos empty-positions] \n                          (search board color pos)))]\n        ;; return our results in a map with position as key and value the turned positions\n        (into {} (map (fn [r] (let [[pos vals] (first r)] {pos (set vals)})) res))\n        ))))", "user": "4ebbff41535dfed6da9c6d78"}, {"problem": 124, "code": "(fn [board player]\r\n   (let [[minr minc]  [-1 -1]\r\n         [maxr maxc]  [(range (count board)) (range (count (first board)))]\r\n         candidates   (->> (for [r maxr c maxc] [[r c] (= 'e (get-in board [r c]))])\r\n                           (filter second)\r\n                           (map first))\r\n         other-player {'w 'b, 'b 'w}\r\n         shift-dir    {:up [-1 0], :down [1 0], :left [0 -1], :right [0 1],\r\n                       :up-right [-1 1], :down-right [1 1],\r\n                       :up-left [-1 -1], :down-left [1 -1]}\r\n         directions   (keys shift-dir)]\r\n     (letfn [(out-of-bounds? [pos]\r\n               (some (set [minr minc maxr maxc]) pos))\r\n             (shift [dir pos]\r\n               (map + pos (shift-dir dir)))\r\n             (flipping [dir pos]\r\n               (let [nextpos (shift dir pos)]\r\n                 (and (not (out-of-bounds? nextpos))\r\n                      (cond (= (other-player player)\r\n                               (get-in board nextpos))\r\n                            (flipping dir nextpos)\r\n                            (= player (get-in board nextpos))\r\n                            nextpos))))\r\n             (flippable [pos dir]\r\n               (let [nextpos (shift dir pos)\r\n                     lastpos (and (not (out-of-bounds? nextpos))\r\n                                  (= (other-player player)\r\n                                     (get-in board nextpos))\r\n                                  (flipping dir nextpos))]\r\n                 (when lastpos [dir lastpos])))\r\n             (range-exc [dir start end]\r\n               (->> (iterate (partial shift dir) start)\r\n                    (take-while (complement (partial = end)))\r\n                    rest))]\r\n       (->> candidates\r\n            (map (juxt identity (fn [c]\r\n                                  (->> directions\r\n                                       (map (partial flippable c))\r\n                                       (filter identity)))))\r\n            (remove (comp empty? second))\r\n            (map (fn [[start ranges]]\r\n                   {start (set (mapcat (fn [[dir end]]\r\n                                         (range-exc dir start end))\r\n                                       ranges))}))\r\n            (reduce merge)))))", "user": "55d0e76ae4b0e31453f64a40"}, {"problem": 124, "code": "(fn [arg1 arg2]\n(cond\n(and (= arg1 (quote [[e e e e] [e w b e] [e b w e] [e e e e]])) (= arg2 (quote w))) {[1 3] #{[1 2]}, [0 2] #{[1 2]}, [3 1] #{[2 1]}, [2 0] #{[2 1]}}\n(and (= arg1 (quote [[e e e e] [e w b e] [w w w e] [e e e e]])) (= arg2 (quote b))) {[3 2] #{[2 2]}, [3 0] #{[2 1]}, [1 0] #{[1 1]}}\n(and (= arg1 (quote [[e e e e] [e w b e] [w w b e] [e e b e]])) (= arg2 (quote w))) {[0 3] #{[1 2]}, [1 3] #{[1 2]}, [3 3] #{[2 2]}, [2 3] #{[2 2]}}\n(and (= arg1 (quote [[e e w e] [b b w e] [b w w e] [b w w w]])) (= arg2 (quote b))) {[0 3] #{[2 1] [1 2]}, [1 3] #{[1 2]}, [2 3] #{[2 2] [2 1]}}\n))", "user": "565f2461e4b068f2fe63dc3b"}, {"problem": 124, "code": "(fn [arg1 arg2]\n(cond\n(and (= arg1 (quote [[e e e e] [e w b e] [e b w e] [e e e e]])) (= arg2 (quote w))) {[1 3] #{[1 2]}, [0 2] #{[1 2]}, [3 1] #{[2 1]}, [2 0] #{[2 1]}}\n(and (= arg1 (quote [[e e e e] [e w b e] [w w w e] [e e e e]])) (= arg2 (quote b))) {[3 2] #{[2 2]}, [3 0] #{[2 1]}, [1 0] #{[1 1]}}\n(and (= arg1 (quote [[e e e e] [e w b e] [w w b e] [e e b e]])) (= arg2 (quote w))) {[0 3] #{[1 2]}, [1 3] #{[1 2]}, [3 3] #{[2 2]}, [2 3] #{[2 2]}}\n(and (= arg1 (quote [[e e w e] [b b w e] [b w w e] [b w w w]])) (= arg2 (quote b))) {[0 3] #{[2 1] [1 2]}, [1 3] #{[1 2]}, [2 3] #{[2 2] [2 1]}}\n))", "user": "5666bf34e4b04acd4f672dc2"}, {"problem": 124, "code": "(fn [game p]\n  (let [size (count game)\n        offsets (for [r [-1 0 1] c [-1 0 1] :when (not= r c 0)] [r c])\n        valid-loc? (fn [[r c]] (and (< -1 r size) (< -1 c size)))\n        opponent {'w 'b 'b 'w}\n        rays (fn [loc]\n               (for [o offsets]\n                 (drop 1 (take-while valid-loc? (iterate #(map + % o) loc)))))\n        captures-in-ray (fn [player ray]\n                          (loop [ray ray result []]\n                            (if (seq ray)\n                              (let [[head & tail] ray\n                                    color (get-in game head)]\n                                (condp = color\n                                  player result\n                                  (opponent player) (recur tail (conj result head))\n                                  []))\n                              [])))\n        captures-from-loc (fn [player loc]\n                            (->> (rays loc)\n                                 (map (partial captures-in-ray player))\n                                 (apply concat)\n                                 (set )\n                                 (vector loc)))\n        ]\n    (->> (for [r (range (count game)) c (range (count game))] [r c])\n           (filter #(= 'e (get-in game %)))\n           (map (partial captures-from-loc p))\n           (remove #(empty? (second %)))\n           (into {}))))", "user": "530b8580e4b02e82168697cc"}, {"problem": 124, "code": "(fn analyze-reversi [board col]\n  (let [[m0 n0] [(dec (count board)) (dec (count (first board)))]\n        opp (#(if (= % 'w) 'b 'w) col)\n        board-at (fn [i j]\n                   (when (and (<= 0 i m0) (<= 0 j n0))\n                     (nth (nth board i) j)))\n        arms (fn [[i j :as p]]  ;; arms are the list of sequences(lazy) extending in every direction from point 'p'\n               (let [f (comp next #(iterate % p))]\n                 (map f [#(vector (dec (first %)) (last %))\n                         #(vector (inc (first %)) (last %))\n                         #(vector (first %) (inc (last %)))\n                         #(vector (first %) (dec (last %)))\n                         #(vector (dec (first %)) (dec (last %)))\n                         #(vector (dec (first %)) (inc (last %)))\n                         #(vector (inc (first %)) (dec (last %)))\n                         #(vector (inc (first %)) (inc (last %)))])))\n        take-while-plus-fail (fn f [p? [el & rem :as coll]]\n                               (lazy-seq\n                                (if (p? el)\n                                  (cons el (f p? rem))\n                                  [el]))) \n        reversals (fn [p]\n                    (let [is-opposite? #(= opp (board-at (first %) (last %)))]                         \n                      (->> (arms p)\n                           (map (partial take-while-plus-fail is-opposite?))\n                           (filter #(when (> (count %) 1) (= col (apply board-at (last %)))))\n                           (mapcat butlast)\n                           set)))\n        find-empties (fn [i row]\n                       (map-indexed #(if (= 'e %2) [i %1] nil) row))]\n    (->> (map-indexed find-empties board)\n         (mapcat (partial filter (comp not nil?)))\n         (mapcat #(let [r (reversals %)] (if (empty? r) [] (vector % r))))\n         (apply hash-map))))", "user": "5666500ee4b0e91d5f5c566d"}, {"problem": 124, "code": "(fn analyze-reversi\n  [board piece]\n  (let [h (count board)\n        w (count (first board))\n        opponent (if (= 'w piece) 'b 'w)\n        directions [[0 1] [0 -1] [-1 0] [1 0] [1 1] [1 -1] [-1 1] [-1 -1]]\n        call-in (fn [[y x]] (nth (nth board y) x))]\n    (into {} (for [y (range h)\n                   x (range w)\n                   d directions\n                   :let [p (call-in [y x])] :when (= p piece)]\n               (loop [pos [y x] iter 0 pieces #{}]\n                 (let [new-pos [(+ (pos 0) (d 0)) (+ (pos 1) (d 1))]\n                       in-bounds? (and (> h (pos 0) -1) (> w (pos 1) -1))]\n                   (if (or (= pos [y x])\n                           (and in-bounds? (= opponent (call-in pos))))\n                     (recur new-pos (inc iter) (conj pieces pos))\n                     (if (and in-bounds? (= 'e (call-in pos)) (> iter 1))\n                       [pos (disj pieces pos [y x])]))))))))", "user": "55a9e0fee4b0988bba2ad945"}, {"problem": 124, "code": "(fn [b p]\n  (let [coords (for [x (range 0 4) y (range 0 4)] [x y])\n        dirs (remove #(= % [0 0]) (for [x [-1 0 1] y [-1 0 1]] [x y]))\n        explore (fn e [b p [x y] curr [dx dy]]\n                  (when (and (<= 0 x 3) (<= 0 y 3))\n                    (let [nc [(+ x dx) (+ y dy)]\n                          t (str (get-in b nc))]\n                            (cond\n                              (= \"e\" t) []\n                              (= (str p) t) curr\n                              :else (e b p nc (cons nc curr) [dx dy])))))\n        flip (fn [b p c] (when (= (get-in b c) 'e)\n                            [c (->> dirs (map (partial explore b p c [])) (apply concat) set)]))]\n  (->> coords\n       (map (partial flip b p))\n       (remove (comp empty? second))\n       (into {}))))", "user": "50bce014e4b0594b91591c63"}, {"problem": 124, "code": "(fn [bd player]\n(let [dirs [[0 1] [0 -1] [1 0] [-1 0] [1 1] [-1 -1] [1 -1] [-1 1]]\n      vectAdd (fn [x y] (map (partial apply +) (map vector x y)))\n      xLen (count bd)\n      yLen (count (first bd))\n      maximumCount (max xLen yLen)\n      clamp (fn [[x y]]\n                (if (and (>= x 0)\n                         (>= y 0)\n                         (< x xLen)\n                         (< y yLen))\n                  (vector x y)))\n      opposite (fn [x] (if (= x 'b) 'w 'b))\n      fromDir (fn [center dir] (keep clamp (map (partial vectAdd center)\n                                    (filter (comp not nil?)\n                                            (take maximumCount\n                                                  (iterate (partial vectAdd dir) [0 0]))))))]\n  (into {}\n  (map (partial into [])\n  (filter (comp not empty?)\n  (filter (comp not nil?)\n  (apply concat\n  (for [x (range xLen)]\n    (for [y (range yLen)]\n      (if (= 'e (get-in bd [x y]))\n        (let [newBd (assoc-in bd [x y] player)]\n          (filter (comp not nil?)\n          (apply concat\n          (for [dir dirs]\n            (let [cells (fromDir [x y] dir)\n                  locType (map #(vector % (get-in newBd %)) cells)\n                  firstType (second (first locType))\n                  values (into #{} (map first (take-while #(= (opposite player) (second %)) (rest locType))))\n                  lastType (second (first (drop-while #(= (opposite player) (second %)) (rest locType))))]\n              (if (and (= player firstType)\n                       (= player lastType)\n                       (> (count values) 0))\n                (vector [x y] values)\n                )\n              )\n            )\n          )\n      ))))))))\n  ))\n))", "user": "541ef7e2e4b01498b1a71a92"}, {"problem": 124, "code": "(let [directions\n      (disj (set (for [x [-1 0 1]\n                       y [-1 0 1]]\n                   [x y]))\n            [0 0])]\n\n  (letfn [(adjacent-coord [dir coord]\n            (vec (map + coord dir)))\n\n          (available [board]\n            (let [pos-range (range (count board))]\n              (for [row pos-range\n                    col pos-range\n                    :let [coord [row col]]\n                    :when (#{'e} (get-in board coord))]\n                coord)))\n\n          (opposite-color [color]\n            (if (= color 'b)\n              'w\n              'b))\n\n          (flipped-line [board color coord dir]\n            (let [enemy-color (opposite-color color)\n                  coords-in-dir (rest (iterate (partial adjacent-coord dir)\n                                               coord))\n                  [enemy-coords [boundary-coord]]\n                  (split-with #(= (get-in board %) enemy-color)\n                              coords-in-dir)]\n              (when (= (get-in board boundary-coord) color)\n                enemy-coords)))\n\n          (flipped-coords [board color coord]\n            (set (mapcat (partial flipped-line board color coord)\n                         directions)))]\n\n    (fn [board color]\n      (into {} (for [coord (available board)\n                     :let [flipped (flipped-coords board color coord)]\n                     :when (seq flipped)]\n                 [coord flipped])))))", "user": "5424c523e4b01498b1a71b03"}, {"problem": 124, "code": "(fn [b mc]\n  (let [oc (if (= 'b mc) 'w 'b)\n        ps (fn [c]\n             (for [x (range 4)\n                   y (range 4)\n                   :when (= c (get-in b [x y]))]\n               [x y]))\n        e-ps (ps 'e)\n        mc-ps (ps mc)\n        betw (fn [[x1 y1] [x2 y2]]\n               (let [dx (- x2 x1)\n                     dy (- y2 y1)\n                     l-dx (Math/abs dx)\n                     l-dy (Math/abs dy)\n                     l-max (max l-dx l-dy)]\n                 (when (or (zero? dx)\n                      (zero? dy)\n                           (= l-dx l-dy))\n                   (case l-max\n                     2 #{[(+ x1 (/ dx 2)) (+ y1 (/ dy 2))]}\n                     3 #{[(+ x1 (/ dx 3)) (+ y1 (/ dy 3))]\n                         [(+ x1 (* 2 (/ dx 3))) (+ y1 (* 2 (/ dy 3)))]}\n                     nil))))\n        betw-ps? (fn [p]\n                   (some (fn [x]\n                           (let [betw-ps (betw p x)]\n                             (when (and betw-ps\n                                        (every? #(= oc (get-in b %))\n                                                betw-ps))\n                               betw-ps)))\n                         mc-ps))]\n    (reduce (fn [m p]\n              (if-let [betw-ps (betw-ps? p)]\n                (conj m [p betw-ps])\n                m)) {} e-ps)))", "user": "50f10f7be4b06d9538fe211a"}, {"problem": 124, "code": "(fn [board player]\n  (let [opponent-of {'b 'w\n                     'w 'b}\n        coords-of (fn [target]\n                    (->> (map-indexed\n                           (fn [row-index row]\n                             (map-indexed\n                               (fn [col-index cell]\n                                 (when (= target cell)\n                                   [row-index col-index]))\n                               row))\n                           board)\n                         (mapcat #(remove nil? %))\n                         (set)))\n\n        ss (fn [[row col]] [(inc row) col])\n        se (fn [[row col]] [(inc row) (inc col)])\n        sw (fn [[row col]] [(inc row) (dec col)])\n\n        nn (fn [[row col]] [(dec row) col])\n        ne (fn [[row col]] [(dec row) (inc col)])\n        nw (fn [[row col]] [(dec row) (dec col)])\n\n        ee (fn [[row col]] [row (inc col)])\n        ww (fn [[row col]] [row (dec col)])\n\n        directions [nn ne ee se ss sw ww nw]\n\n        lookup (partial get-in board)\n        on-board? (comp (complement nil?) lookup)\n\n        walk (fn [start direction]\n               (rest\n                 (take-while on-board? (iterate direction start))))\n\n        path-regex (re-pattern (str (opponent-of player) \"+\" player \".*\"))\n\n        valid-path? (fn [path] (boolean (re-matches path-regex (apply str path))))]\n\n    (->> (coords-of 'e)\n         (map (fn [cell]\n                (map (fn [dir]\n                       (let [cells (walk cell dir)\n                             path (map lookup cells)]\n                         (when (valid-path? path)\n                           [cell (filter\n                                   (fn [cell]\n                                     (= (opponent-of player) (lookup cell)))\n                                   cells)])))\n\n                     directions)))\n         (map (partial remove nil?))\n         (remove empty?)\n         (reduce (fn [m [[k v]]] (assoc m k (set v))) {}))))", "user": "55d28b38e4b0e31453f64a58"}, {"problem": 124, "code": "(fn valid-moves [test-board player]\n  (let [board-size (count test-board)\n        empty-locs (for [row (range board-size)\n                         col (range board-size)\n                         :when (= 'e (get-in test-board [row col]))]\n                     [row col])\n        valid-move? (fn [start move-x move-y]\n                      (loop [curr-loc start\n                             flipped #{}]\n                        (let [curr-val (get-in test-board curr-loc)\n                              next-loc [(+ (first curr-loc) move-y)\n                                        (+ (second curr-loc) move-x)]\n                              next-val (get-in test-board next-loc 'e)]\n                          (condp = next-val\n                            'e false\n                            player (when (not (empty? flipped)) {start flipped})\n                            (recur next-loc (conj flipped next-loc))))))]\n    (->> empty-locs\n         (#(for [start %\n                 move-x [-1 0 1]\n                 move-y [-1 0 1]\n                 :let [valid-move (valid-move? start move-x move-y)]\n                 :when valid-move]\n             valid-move))\n         (apply merge))))", "user": "562e8b2be4b0ab312c17ebbb"}, {"problem": 124, "code": "(fn __ [board side]\n     (let [other (if (= side 'w) 'b 'w)\n           h (count board)\n           w (count (first board))\n           catern-product #(for [i %1 j %2] [i j])\n           cords (catern-product (range h) (range w))\n           empty-spaces (filter #(= 'e (get-in board %)) cords)\n           is-side (fn [side cord] (= side (get-in board cord)))\n           cords-in-direction (fn [[sr, sc] [dr dc]] (map #(vector (+ sr (* dr %))\n                                                                   (+ sc (* dc %)))\n                                                          (drop 1 (range))))\n           legal-in-direction (fn [start d]\n                                (let [other-pieces (take-while (partial is-side other)\n                                                                (cords-in-direction start d))]\n                                      (if (empty? other-pieces)\n                                        false\n                                        (let [[lr lc] (last other-pieces)\n                                              [dr dc] d\n                                              next-pos [(+ lr dr) (+ lc dc)]]\n                                          (if (is-side side next-pos)\n                                            [start (set other-pieces)]\n                                            false)))))\n           directions (filter #(not= [0 0] %) (catern-product [-1 0 1] [-1 0 1]))]\n          (into {} (filter identity (mapcat (fn [e] (map #(legal-in-direction e %) directions))\n                                            empty-spaces)))))", "user": "56897739e4b0dcc4269f407d"}, {"problem": 124, "code": "(fn rm [board color]\n  (letfn [\n          (add-coords [[x1 y1] [x2 y2]] [(+ x1 x2) (+ y1 y2)])\n          (on-board [coordinate] (every? #(< -1 % 4) coordinate))\n          (flipped [board, color, coordinate, direction]\n            (if (not= 'e (get-in board coordinate))\n              #{}\n              (loop [current (add-coords coordinate direction)\n                     flipped #{}]\n                (cond\n                  (not (on-board current)) #{}\n                  (= 'e (get-in board current)) #{}\n                  (= color (get-in board current)) flipped\n                  :else (recur (add-coords current direction) (conj flipped current))))))\n\n          ]\n  (reduce #(if (empty? (%2 1)) %1 (conj %1 %2)){} (for [x (range 4) y (range 4) dir [[-1 -1] [-1 0] [-1 1] [0 -1] [0 1] [1 -1] [1 0] [1 +1]]]\n                                                    (vector [y x] (flipped board color [y x] dir)))\n          )))", "user": "55f2c898e4b06e875b46ce4b"}, {"problem": 124, "code": "(fn [board color]\n  (let [cell (partial get-in board)\n        opp (if (= 'b color) 'w 'b)\n        opp? #(= opp (cell %))\n        empty-posn? (fn [posn]\n                      (= 'e (cell posn)))\n        empties (for [row (range 4) col (range 4) :when (empty-posn? [row col])]\n                  [row col])\n        captured-cells (fn [other-posns end-posn]\n                         (when (and (= color (cell end-posn))\n                                    (every? opp? other-posns))\n                           other-posns))\n        possible-dirs [[-1 -1] [-1 0] [-1 1] [0 -1] [0 1] [1 -1] [1 0] [1 1]]\n        posn-from (fn [[row col] [dir-row dir-col] dist]\n                    [(+ row (* dir-row dist)) (+ col (* dir-col dist))])\n        cell-range (fn [start dir dist]\n                     (map #(posn-from start dir %) (range 1 (inc dist))))\n        capture-range (fn [start dir dist]\n                        (let [res-range (cell-range start dir dist)]\n                          [(butlast res-range) (last res-range)]))\n        all-captured-cells (fn [posn]\n                             (reduce (fn [captures possible-dir]\n                                       (into captures\n                                            (some (fn [dist]\n                                                    (apply captured-cells (capture-range posn possible-dir dist)))\n                                                  [2 3])))\n                                     #{} possible-dirs))]\n    (reduce (fn [res empty-posn]\n              (let [captured-cells (all-captured-cells empty-posn)]\n                (if (empty? captured-cells)\n                  res\n                  (assoc res empty-posn captured-cells))))\n            {} empties)))", "user": "55ccdc6be4b0e31453f64a18"}, {"problem": 124, "code": "(fn [brd who]\n  (let [nr (count brd)\n        nc (count (brd 0))\n        coords (for [r (range nr) c (range nc)] [r c])\n        dirs [[-1 -1] [-1 0] [-1 1]\n              [ 0 -1]        [ 0 1]\n              [ 1 -1] [ 1 0] [ 1 1]]\n        emp? #(or (= % 'e) (nil? %))\n        transfer (fn [state which]\n                    (case state\n                      :init (if (= which 'e) :oppo :fail)\n                      :oppo (if (emp? which)\n                                :fail\n                                (if (= who which) :fail :cont))\n                      :cont (if (emp? which)\n                                :fail\n                                (if (= who which) :succ :cont))))\n        put (fn [pos dir]\n              (loop [p pos, state :init, reversed #{}]\n                (let [new-state (transfer state (get-in brd p))\n                      new-p (map + p dir)]\n                  (case new-state\n                    :succ {pos reversed}\n                    :oppo (recur new-p new-state reversed)\n                    :cont (recur new-p new-state (conj reversed p))\n                    :fail {}))))]\n    (apply merge (for [p coords d dirs] (put p d)))))", "user": "5416b4a2e4b01498b1a71a01"}, {"problem": 124, "code": "(fn [b p]\n  (letfn [(c [b [y x] [v h]]\n            (let [nv (+ y v)\n                  nh (+ x h)]\n            (if (and (>= nv 0) (< nv 4) (>= nh 0) (< nh 4))\n              (cons [(get-in b [nv nh]) nv nh]\n                    (c b [nv nh] [v h])))))\n           \n          (r [b [y x] p]\n            (->> (for [p [[-1 0] [1 0] [0 -1] [0 1] [-1 1] [1 -1] [1 1] [-1 -1]]]\n                    (c b [y x] p))\n                  (map #(concat (butlast %)\n                                (when (not= (first (last %)) 'e)\n                                  [(last %)])))\n                  (remove empty?)\n                  (map #(apply map vector %))\n                  (map #(if (or (and (= p 'w) (= (first %) '[b w w]))\n                                (and (= p 'b) (= (first %) '[w b b])))\n                            (map butlast %)\n                          %))\n                  (filter #(if (= p 'b)\n                             (or (= (first %) '[w b])\n                                 (= (first %) '[w w b]))\n                             (or (= (first %) '[b w])\n                                 (= (first %) '[b b w]))))\n                  (map #(apply map vector %))\n                  (map drop-last)\n                  (apply concat)\n                  (map rest)\n                  (into #{})\n                  (assoc {} [y x])))\n          \n          (e [b]\n            (for [i (range 4)\n                  j (range 4)\n                  :when (= (get-in b [i j]) 'e)]\n              [i j]))]\n    (into {}\n      (remove #(empty? (nth % 1))\n        (apply merge\n               (map #(r b % p)\n                 (e b)))))))", "user": "52bacfa8e4b07a9af57922d6"}, {"problem": 124, "code": "(let [dirs [[-1 -1] [-1 0] [-1 1] [0 -1] [0 1] [1 -1] [1 0] [1 1]]\n      goo (fn goo [origin dir] (lazy-seq (cons origin (goo (map + origin dir) dir))))\n      inf (fn [origin] (map (partial goo origin) dirs))\n      cand (fn [b s] (take 3 (partition-by (partial get-in b) (take-while (partial get-in b) s))))\n      captures (fn [b c [e o s]] (when (and (= '(e) (map (partial get-in b) e)) (= c (get-in b (first s)))) o))]\n  (fn [b c] (into {} (filter #(not-empty (second %)) (for [x (range 4)\n                                                           y (range 4)]\n                                                       [[x y] (set (mapcat (partial captures b c) (map (partial cand b) (inf [x y]))))])))))", "user": "554680cbe4b0a04f7929953e"}, {"problem": 124, "code": "(fn r?[m c]\n  (let\n    [op (if (= c 'b) 'w 'b)\n    g (fn[i j] (if (and (> i -1) (< i (count m)) (> j -1) (< j (count (m 0)))) ((m i) j) 0))\n    mg (fn mg[i j di dj s]\n          (let [ni (+ i di) nj (+ j dj) nc (g ni nj)]\n            (cond (= nc op) (mg ni nj di dj (conj s [ni nj]))\n                  (and (= nc 'e) (seq s)) [[ni nj] s])))\n    ms (fn[i j e] (when (= e c) (mapcat (fn [[di dj]] (mg i j di dj #{})) [[-1 1] [-1 0] [-1 -1] [0 -1] [1 -1] [1 0] [1 1] [0 1]])))\n    s (for [[i r] (map-indexed vector m)\n            [j e] (map-indexed vector r)\n            :let [s (ms i j e)]\n            :when (seq s)]\n        (ms i j e))]\n    (apply hash-map (mapcat identity s))))", "user": "56824e1be4b0945ebc182a91"}, {"problem": 124, "code": "(fn [board color]\n  (let [all-coords (for [i (range 4) j (range 4)] [i j])\n        get #(get-in board %)\n        add (fn [[a b] [c d]] [(+ a c) (+ b d)])\n        in-bounds (fn [[y x]] (and (>= x 0) (>= y 0) (<= x 3) (<= y 3)))\n        dirs (filter #(not= % [0 0]) (for [i (range -1 2) j (range -1 2)] [i j]))\n        flipped-by-dir (fn [pos dir]\n                         (loop [p (add pos dir) flipped #{}]\n                           (cond\n                             (not (in-bounds p)) #{}\n                             (= (get p) 'e) #{}\n                             (= (get p) color) flipped\n                             :else (recur (add p dir) (conj flipped p)))))\n        flipped (fn [pos] (into #{} (mapcat #(flipped-by-dir pos %) dirs)))]\n    (->>\n      all-coords\n      (filter #(= 'e (get %)))\n      (map #(vector % (flipped %)))\n      (remove #(empty? (second %)))\n      (into {}))))", "user": "4faf97d8e4b081705acca258"}, {"problem": 124, "code": "(fn bin [board color](let [opp (color {'b 'w, 'w 'b})\n                            d [[1 1][-1 1][1 -1][-1 -1] [0 -1] [0 1] [-1 0] [1 0]]\n                            move (fn move [start loc d* steps]\n                                   (if (and(not= color (get-in board (map + loc d*)))\n                                           (some #(= % (loc 0)) (range 4))\n                                           (some #(= % (loc 1)) (range 4)))\n                                     (if (= 'e (get-in board loc))\n                                       {loc (set (rest steps))}\n                                       (move start (mapv + loc d*) d* (conj steps loc)))))\n                            a (for [n (range 4)\n                                    n*(range 4)] [n n*])\n                            locs (filter #(= color (get-in board %))a)]\n                       (apply merge(mapcat #(remove nil? (map(fn [d*](if(= opp (get-in board (map + % d*)))(move % % d*[])))d))locs))))", "user": "566a3a26e4b0a866af689699"}, {"problem": 124, "code": "(fn r [b p]\n  (let [dirs  (for [dx [-1 0 1] dy [-1 0 1] :when (not (= 0 dx dy))] [dx dy]) ; 8 directions\n        free  (for [x [0 1 2 3] y [0 1 2 3] :when (= 'e (get-in b [x y]))] [x y])]; empty cells\n  (letfn [(line  [[[x y] [dx dy]]] ; collect pieces from [x y] in direction [dx dy]\n                 (if (or (> x 3) (< x 0) (< y 0) (> y 3))\n                   \"\"\n                   (str (get-in b [x y]) (line [[(+ x dx) (+ y dy)] [dx dy]]) )))\n           (cnt [s n] ; assume started with p, how many pieces captured on line s?\n                (cond\n                 (or (empty? s) (= (first s) \\e)) 0                         \n                 (= (first s) (first (str p))) n \n                 :else (cnt (rest s) (inc n))))\n           (flips [[x y]]\n               (let [pieces (fn [[s [dx dy]]] ; get captured pieces in direction [dx dy]\n                        (into #{} (for [i (range (cnt s 0))] [(+ x dx (* i dx)) (+ y dy (* i dy))])) )]\n                   \n                (apply clojure.set/union ;collect all pieces starting from [x y] in all directions\n                       (map #(pieces %) \n                            (for [d dirs] [(drop 1 (line [[x y] d])) d])))\n                 ))\n        ]\n        (apply merge\n            (for [e free :when (not (empty? (flips e)))] \n                  {e (flips e)})) ; try all empty positions\n    )))", "user": "56bca51ae4b0f26550335963"}, {"problem": 124, "code": "(fn [board color]\n  (let[onboard (fn[[r c]] (and (<= 0 r 3) (<= 0 c 3)))\n       dir1 [-1 0 1]\n       op (if (= 'w color) 'b 'w)\n       dir (for [r dir1 c dir1 :when (or (not= 0 r) (not= 0 c))] [r c])\n       es (for[r (range 4) c (range 4) :when (= 'e (get-in board [r c]))] [r c])\n       \n       flips (fn [s](->> (mapv + d s)\n                                   (iterate #(mapv + d %))\n                                   (take-while #(and (onboard %) (not= 'e %)))\n                                   (for [d dir])\n                                   (filter #(and (= op (get-in board (first %))) \n                                                 (some #{color} (map (fn[[r c]] (get-in board [r c])) %))))\n                                   (apply concat)\n                         \t\t   (filter #(= op (get-in board %)))\n                                   ))]\n    (->> [s (apply hash-set (distinct (flips s)))]\n         (for [s es])\n         (remove #(empty? (second %)))\n         (into {}))))", "user": "5649615be4b0284900eef641"}, {"problem": 124, "code": "#(if (= (last %) (first %))\n   (if (= 'w %2) {[1 3] #{[1 2]}, [0 2] #{[1 2]}, [3 1] #{[2 1]}, [2 0] #{[2 1]}}\n       {[3 2] #{[2 2]}, [3 0] #{[2 1]}, [1 0] #{[1 1]}})\n   (if (= 'w %2) {[0 3] #{[1 2]}, [1 3] #{[1 2]}, [3 3] #{[2 2]}, [2 3] #{[2 2]}}\n     {[0 3] #{[2 1] [1 2]}, [1 3] #{[1 2]}, [2 3] #{[2 1] [2 2]}})\n   )", "user": "5507cfd3e4b021ccfedb96ad"}, {"problem": 124, "code": "(fn reversiX[t c]\n\t(letfn[\n\n\t\t\t(gety[coor] (first coor))\n\t\t\t(getx[coor] (last coor))\n\t\t\t(makeCoor[y x]\n\t\t\t\t[y x]\n\t\t\t)\n\n\t\t\t(setx[coor x]\n\t\t\t\t(makeCoor (gety coor) x)\n\t\t\t)\n\n\t\t\t(sety[coor y]\n\t\t\t\t(makeCoor y (getx coor))\n\t\t\t)\n\n\n\t\t\t(cell [t coor]\n\t\t\t\t(let [\n\t\t\t\t\ty (gety coor)\n\t\t\t\t\tx (getx coor)\n\t\t\t\t\t]\n\t\t\t\t\t(get (get t y) x)\n\t\t\t\t)\n\t\t\t)\n\n\n\t\t\t(isCell [t c coor]\n\t\t\t\t (= (cell t coor) c)\n\t\t\t)\n\n\t\t\t(isEmpty[t coor]\n\t\t\t\t(isCell t 'e coor)\n\t\t\t)\n\n\t\t\t(incx[coor] (inc (getx coor)))\n\t\t\t(decx[coor] (dec (getx coor)))\n\t\t\t(incy[coor] (inc (gety coor)))\n\t\t\t(decy[coor] (dec (gety coor)))\n\n\n\t\t\t(goDir[coor dir]\n\t\t\t\t(case dir\n\t\t\t\t\t:right \t(setx coor (incx coor))\n\t\t\t\t\t:left (setx coor (decx coor))\n\t\t\t\t\t:up (sety coor (decy coor))\n\t\t\t\t\t:down (sety coor (incy coor))\n\t\t\t\t\t:rightup (makeCoor (decy coor) (incx coor))\n\t\t\t\t\t:rightdown (makeCoor (incy coor) (incx coor))\n\t\t\t\t\t:leftup (makeCoor (decy coor) (decx coor))\n\t\t\t\t\t:leftdown (makeCoor (incy coor) (decx coor))\n\t\t\t\t)\n\t\t\t)\n\n\n\t\t\t(opposite[c]\n\t\t\t\t(cond \n\t\t\t\t\t(= c 'b) 'w\n\t\t\t\t\t(= c 'w) 'b\n\t\t\t\t\t:else nil\n\t\t\t\t)\n\t\t\t)\n\n\n\t\t\t(getMoveDirRes[t c opp dir coor stack]\n\t\t\t\t(let [\n\t\t\t\t\tnewCoor (goDir coor dir)\n\t\t\t\t\tvalNewCoor (cell t newCoor)\n\t\t\t\t\t]\n\t\t\t\t\t(cond \n\t\t\t\t\t\t(nil? valNewCoor) nil\n\t\t\t\t\t\t(= valNewCoor 'e) nil\n\t\t\t\t\t\t(= valNewCoor c) stack\n\t\t\t\t\t\t(= valNewCoor opp) (getMoveDirRes t c opp dir newCoor (conj stack newCoor))\n\t\t\t\t\t)\n\t\t\t\t) \n\t\t\t)\n\n\n\t\t\t(getMoveDir[t c coor dir] \n\t\t\t\t(let [\n\t\t\t\t\topp (opposite c)\n\t\t\t\t\tnewCoor (goDir coor dir)\n\t\t\t\t\t]\n\t\t\t\t\t(if (isCell t opp newCoor)\n\t\t\t\t\t\t(getMoveDirRes t c opp dir newCoor #{newCoor})\n\t\t\t\t\t\tnil\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\n\t\t\t(notnil?[x] (not (nil? x)))\n\n\t\t\t(getMoves[t c coor]\n\t\t\t\t(if(isEmpty t coor)\n\t\t\t\t\t(apply clojure.set/union (filter notnil? (map (partial getMoveDir t c coor) [:right :left :up :down :rightup :rightdown :leftup :leftdown])))\n\t\t\t\t\t#{}\n\t\t\t\t)\n\t\t\t)\n\n\n\t\t\t(coors[]\n\t\t\t\t(for [y (range 4) x (range 4)]\n\t\t\t\t\t(makeCoor y x)\n\t\t\t\t)\n\t\t\t)\n\n\t\t]\n\t\t(let [\n\t\t\t\tcs (coors)\n\t\t\t\tall (zipmap cs (map #(getMoves t c %) cs))\n\t\t\t]\n\t\t\t(select-keys all (for [[k v] all :when (seq v)] k)) \t\t\t\n\t\t)\n\t)\n)", "user": "568820e8e4b0dcc4269f4067"}, {"problem": 124, "code": "(fn [board color]\n  (let [rev-color ('{w b b w} color)\n        empty-color 'e\n        poses (->> (keep-indexed\n                    (fn [x row]\n                      (keep-indexed (fn [y e] (if (= e color) [x y] nil)) row)) board)\n                   (flatten)\n                   (partition 2)\n                   )\n        in-board? (fn [pos]\n                    (and (< -1 (first pos) (count board))\n                         (< -1 (second pos) (count (first board)))))\n        directions (filter #(not= % [0 0])(for [i (range -1 2) j (range -1 2)] [i j]))\n        ;; possible point\n        ;; go one direction\n        ;; nil means nothing. else return the correct value\n        go (fn [direction pos]\n             (loop [passed []\n                    next (map + direction pos)]\n               (cond ((complement in-board?) next) nil\n                     (and (= (get-in board next) empty-color)\n                          (empty? passed)) nil\n                     (and (= (get-in board next) empty-color)) {next (set passed)}\n                     (= (get-in board next) rev-color) (recur (conj passed next)\n                                                              (map + direction next))\n                     :else nil\n                     )\n               ))\n        ]\n    (apply merge (for [direction directions\n                       pos poses]\n                   (go direction pos)))\n    ))", "user": "56f7ecdfe4b08e7d20b96834"}, {"problem": 124, "code": "(fn reversi [board p]\n  (let [o '{b w w b}\n        d (for [y [-1 0 1] x (if (= 0 y) [-1 1] [-1 0 1])] [y x])\n        b (into {} (for [y (range 4) x (range 4)] [[y x] (get-in board [y x])]))\n        e (map key (filter #(= 'e (val %)) b))\n        wk (fn [st off] (take-while b (rest (iterate #(map + % off) st))))\n        vl (fn [pth] (let [s (apply str (map b pth)) r (re-pattern (str (o p) \"+\" p))]\n                       (if (re-seq r s) (take-while #(not= p (b %)) pth))))\n        mv (fn [st] (set (apply concat (keep vl (map #(wk st %) d)))))]\n    (into {} (for [st e :let [mvs (mv st)] :when (not-empty mvs)] [st mvs]))))", "user": "57023fc2e4b08d47c97781db"}, {"problem": 124, "code": "(fn legal-move-space [board me]\n   (letfn [(eat-rival\n             ;; \" ['b 'b 'w 'e] 'w return 2 (eaten) \"\n             [color-list me]\n             (let [rival (if (= me 'b) 'w 'b)\n                   rival-list (take-while #{rival} color-list)\n                   rest-list (drop-while #{rival} color-list)]\n               (if (and (= (first rest-list) me) (> (count rival-list) 0))\n                 (count rival-list)\n                 0)))\n           (get-position-color-list\n             [current-position direction]\n             (let [current-color (get-in board current-position)]\n               (if current-color\n                 (cons [current-position current-color]\n                       (get-position-color-list (map + current-position direction) direction))\n                 [])))\n           (get-all-p-c-list\n             [position]\n             (map #(get-position-color-list position %) (for [x [-1 0 1]\n                                                              y [-1 0 1]\n                                                              :when (or (not= x 0) (not= y 0))]\n                                                          [x y])))\n           (avaiable-posistion?\n             [position]\n             (= 'e (get-in board position)))\n           (check-position\n             ;; \"check a position, and return position set of rival be eaten\"\n             [position]\n             (->> (for [position-color-list (get-all-p-c-list position)]\n                    (let [position-list (rest (map #(first %) position-color-list))\n                          color-list (rest (map #(second %) position-color-list))\n                          eaten-number (eat-rival color-list me)]\n                      (if (> eaten-number 0)\n                        (take eaten-number position-list))))\n                  (remove nil?)\n                  (apply concat)\n                  set\n                  ))\n           ]\n\n     (into {} (for [x (range 4)\n                    y (range 4)\n                    :let [position [x y]]\n                    :when (avaiable-posistion? position)]\n                (let [eaten (check-position position)]\n                  (if (> (count eaten) 0)\n                    [position eaten]))))\n\n     ))", "user": "56fbf83de4b07572ad1a88da"}, {"problem": 124, "code": "(fn f [b piece]\n  (letfn [(get-piece-seq [b start rel-coords]\n             (let [[si sj] start]\n               (->>\n                (map #(let [[ri rj] %\n                            [ci cj]  [(+ si ri) (+ sj rj)]]\n                        [(get-in b [ci cj]) [ci cj]]) rel-coords)\n                (remove #(nil? (first %)))\n                (#(vector (map first %) (map second %)))\n                )))\n\n          (get-captured [piece start [p-seq c-seq]]\n            (let [other ({'b 'w, 'w 'b} piece)]\n              (when (= other (first p-seq))\n                (let [[captured end] (split-with #{other} p-seq)]\n                  (when (= (first end) piece)\n                    [start (set (take (count captured) c-seq))])))))]\n    \n    (let [empty-spaces (for [i (range 0 4)\n                             j (range 0 4)\n                             :when (= 'e (get-in b [i j]))]\n                         [i j])\n          d (for [i (range 1 4)] [i 0])\n          u (for [i (range 1 4)] [(- i) 0])\n          l (for [i (range 1 4)] [0 (- i)])\n          r (for [i (range 1 4)] [0 i])\n          dr (for [i (range 1 4)] [i i])\n          ur (for [i (range 1 4)] [(- i) i])\n          ul (for [i (range 1 4)] [(- i) (- i)])\n          dl (for [i (range 1 4)] [i (- i)])\n          directions [d u l r ur dr dl ul]]\n      (->> (for [space empty-spaces\n                 direction directions]\n             (get-captured piece space (get-piece-seq b space direction)))\n           (remove nil?)\n           (into {})))))", "user": "569dd6e8e4b0542e1f8d1480"}, {"problem": 124, "code": "(fn [board player]\n  (letfn [(checkNeighbor [[x y]]\n            (let [ix (inc x) dx (dec x) iy (inc y) dy (dec y)]\n              (filter\n               #(= ('{b w w b} player) (get (get board (first %)) (second %)))\n               [[ix iy] [ix y] [ix dy] [x iy] [x dy] [dx iy] [dx y] [dx dy]])))\n          (canPlace? [[x1 y1] [x2 y2]]\n            (let [dx (- x2 x1) dy (- y2 y1)]\n              (loop [x x2 y y2 acc #{}]\n                (condp = (get (get board x) y)\n                  player [[x1 y1] acc]\n                  ('{w b b w} player) (recur (+ x dx) (+ y dy) (conj acc [x y]))\n                  nil))))]\n    (loop [i 0 acc {}]\n      (if-let [h (get board i)]\n        (recur (inc i)\n               (loop [j 0 acc acc]\n                 (if-let [x (get h j)]\n                   (recur (inc j)\n                          (if (= x 'e)\n                            (reduce #(conj % %2)\n                                    acc\n                                    (keep\n                                     #(canPlace? [i j] %)\n                                     (checkNeighbor [i j])))\n                            acc))\n                   acc)))\n        acc))))", "user": "57035ccfe4b08d47c97781ef"}, {"problem": 124, "code": "(fn [board disc]\n  (let [row-count (count board)\n        col-count (count (first board))\n        flip-disc (if (= disc 'w) 'b 'w)\n        disc-positions (for [x (range row-count) y (range col-count)\n                             :when (= (get-in board [x y]) disc)]\n                         [x y])]\n    (letfn\n      [(candidate-move [[x y] [x-offset y-offset c]]\n         (for [i (range 1 (inc c))]\n           [(+ x (* x-offset i)) (+ y (* y-offset i))]))\n       (all-candidate-move [[x y]]\n         (let [x-below (- row-count x 1) y-right (- col-count y 1)]\n           (reduce\n             #(conj % (candidate-move [x y] %2))\n             []\n             [[0 -1 y] [0 1 y-right] [-1 0 x] [1 0 x-below]\n              [-1 -1 (min x y)] [1 1 (min x-below y-right)]\n              [1 -1 (min x-below y)] [-1 1 (min x y-right)]])))\n       (legal-move [path]\n         (loop [xs path move #{}]\n           (let [p (first xs)]\n             (if (nil? p)\n               {}\n               (cond\n                 (= (get-in board p) flip-disc) (recur (rest xs) (conj move p))\n                 (= (get-in board p) 'e) (if (empty? move) {} {p move})\n                 :default {})))))]\n      (->>\n        disc-positions\n        (reduce #(into % (all-candidate-move %2)) [])\n        (map legal-move)\n        (apply merge-with into)))))", "user": "5392bfdee4b0b51d73faaeb2"}, {"problem": 124, "code": "(fn [board piece]\n  (letfn [(step [op-piece start gap result]\n            (let [next-start (mapv #(+ %1 %2) start gap)\n                  next-piece (get-in board next-start)]\n              (if (= next-piece op-piece)\n                (step op-piece next-start gap (conj result next-start))\n                (if (= next-piece 'e)\n                  (if (seq result)\n                    {next-start (set result)}\n                    {})\n                  {}))))]\n    (apply\n      merge\n      (mapcat\n        #(map\n           (fn [gap] (step (if (= piece 'w) 'b 'w) % gap []))\n           [[0 1] [0 -1] [1 0] [-1 0] [1 1] [-1 -1] [1 -1] [-1 1]])\n        (filter #(= piece (get-in board %)) (mapcat #(map (fn [ele] [% ele]) (range 0 4)) (range 0 4)))))))", "user": "5383668ee4b06839e8705edd"}, {"problem": 124, "code": "(fn [b c]\n    (letfn [(add [[x1 y1] [x2 y2]] [(+ x1 x2) (+ y1 y2)])\n            (look [p d]\n              (let [flip (add p d)]\n                (condp = (get-in b flip)\n                  c (list p)\n                  (if ( = c 'w) 'b 'w) (cons p (look flip d))\n                  (list false))))]\n      (->>\n       (for [dx [-1 0 1] dy [-1 0 1]\n             p (for [x (range 3) y (range 3)\n                     :when (= (get-in b [x y]) (if (= c 'w) 'b 'w))]\n                 [x y])\n             :let [e (add p [dx dy])]\n             :when (= 'e (get-in b e))]\n         [e p [dx dy]])\n       (map (fn [[e p d]] (cons e (look p (map (partial * -1) d)))))\n       (filter (partial not-any? false?))\n       (map (fn [[p & fs]] [p (set fs)]))\n       (into {}))))", "user": "4f57c913e4b0a7574ea7183f"}, {"problem": 124, "code": "(fn [board color]\n  (let [m (count board)\n        n (count (first board))\n        f #(get-in board %)\n        directions (for [x [-1 0 1] y [-1 0 1]] [x y])\n        get-coords (fn [current direction]\n                     (filterv (fn [[i j]]\n                                (and (<= 0 i (dec m))\n                                     (<= 0 j (dec n))\n                                     (not= current [i j])))\n                              (take m\n                                    (iterate (partial mapv + direction) current))))\n        get-flipped (fn [coords]\n                      (loop [[x & more] coords r []]\n                        (cond\n                         (= ({'w 'b 'b 'w} color) (f x)) (recur more (conj r x))\n                         :else (if (= color (f x))\n                                 r\n                                 []))))]\n    (reduce #(conj % %2)\n            {}\n            (for [i (range m)\n                  j (range n)\n                  :let [flipped-coords (into #{}\n                                           (apply concat\n                                                  (map #(get-flipped (get-coords [i j] %))\n                                                       directions)))]\n                  :when (and (= 'e (f [i j]))\n                             (not (empty? flipped-coords)))]\n              {[i j] flipped-coords}))))", "user": "56ae214ce4b03c432f18735a"}, {"problem": 124, "code": "(fn [board color]\n  (into {}\n        (let [directions (for [x [-1 0 1] y [-1 0 1] :when (not= 0 x y)] [x y])\n              follow (fn follow [direction start] (iterate (partial map + direction) start))\n              flip (fn [board path color]\n                     (let [first-cell (first path)\n                           enemy? (fn [cell] (= ({'w 'b 'b 'w} color) (get-in board cell)))\n                           flip-cells (take-while enemy? (rest path))\n                           last-cell (first (drop-while enemy? (rest path)))]\n                       (set (when (and (= 'e (get-in board first-cell))\n                                       (> (count flip-cells) 0)\n                                       (= color (get-in board last-cell)))\n                              flip-cells))))]\n          (for [x (range 4)\n                y (range 4)\n                direction directions\n                :let [start [x y]\n                      path (follow direction start)\n                      flipped (flip board path color)]\n                :when (> (count flipped) 0)]\n            [start flipped]))))", "user": "5164867fe4b003cf19fdde3e"}, {"problem": 124, "code": "(fn\n  reversi-analyze\n  [board color]\n  (let [n-1 [[-1 0] [1 0] [0 -1] [0 1] [-1 -1] [1 -1] [-1 1] [1 1]]\n        n-2 [[-2 0] [2 0] [0 -2] [0 2] [-2 -2] [2 -2] [-2 2] [2 2]]\n        n-3 [[-3 0] [3 0] [0 -3] [0 3] [-3 -3] [3 -3] [-3 3] [3 3]]\n        empty-cell 'e\n        inverse-cell {'w 'b 'b 'w}\n        count-rows (count board)\n        count-columns (count (first board))\n        i-c-board (mapcat identity (map-indexed (fn [i1 v1] (map-indexed (fn [i2 v2] [v2 i1 i2]) v1)) board))\n        c-board (map (fn [[c x y]] [x y]) (filter (fn [[c x y]] (= c color)) i-c-board))\n        e-board (map (fn [[c x y]] [x y]) (filter (fn [[c x y]] (= c empty-cell)) i-c-board))\n        i-board (map (fn [[c x y]] [x y]) (filter (fn [[c x y]] (= c (get inverse-cell color))) i-c-board))\n        neighbours (fn [cell n-type] (map (fn [v] (map + v cell)) n-type))\n        analyzed-pairs (fn [cell] (map (fn [n1 n2 n3] [n1 n2 n3]) (neighbours cell n-1) (neighbours cell n-2) (neighbours cell n-3)))\n        analyze (fn [[a1 a2 a3]] (if (and (not (nil? (some #{a3} e-board))) (not (nil? (some #{a2} i-board))) (not (nil? (some #{a1} i-board))))\n                                 [a3 (set [a1 a2])]\n                                 (if (and (not (nil? (some #{a2} e-board))) (not (nil? (some #{a1} i-board))))\n                                   [a2 (set [a1])]\n                                   nil)))]\n         (apply hash-map (mapcat analyze (mapcat analyzed-pairs c-board)))\n        ))", "user": "56ab7578e4b03c432f18733d"}, {"problem": 124, "code": "(fn __ [board color]\n  (letfn\n      [(row [color state stack [[x ij :as x'] & xs' :as xs]]\n         (cond\n           (empty? xs) nil\n           (= color x) (row color color [] xs')\n           (= state 'e) (row color 'e [] xs')\n           (= state color) (if (= 'e x)\n                             (row color 'e [] xs')\n                             (row color x (conj stack x') xs'))\n           :else (if (= 'e x)\n                   (conj stack [color ij])\n                   (row color x (conj stack x') xs'))))]\n    (let [\n          rs #(map reverse %)\n          horiz  (for [i (range 4)] (for [j (range 4)] [i j]))\n          vert   (for [i (range 4)] (for [j (range 4)] [j i]))\n          diagl  [[[2 0] [1 1] [0 2]] [[3 0] [2 1] [1 2] [0 3]] [[3 1] [2 2] [1 3]]]\n          diagr [[[0 1] [1 2] [2 3]] [[0 0] [1 1] [2 2] [3 3]] [[1 0] [2 1] [3 2]]]\n          all-rows (concat horiz (rs horiz) vert (rs vert) diagl (rs diagl) diagr (rs diagr))]\n      (into\n       {}\n       (map\n        (fn [stack]\n          (let [move (second (last stack))\n                flips (map second (butlast stack))]\n            [move (set flips)]))\n        (filter\n         identity\n         (map (fn [rw] (row color 'e [] rw))\n              (for [rw all-rows]\n                (map (fn [ij] [(get-in board ij) ij]) rw)))))))))", "user": "53ef7f77e4b0742d9025b0ce"}, {"problem": 124, "code": "(fn analyse [board side]\n  (let [board-size (count board)\n        up (fn [[row col]] (when (and row (> row 0)) [(dec row) col]))\n        down (fn [[row col]] (when (and row (< row (dec board-size))) [(inc row) col]))\n        left (fn [[row col]] (when (and col (> col 0)) [row (dec col)]))\n        right (fn [[row col]] (when (and col (< col (dec board-size))) [row (inc col)]))\n        up-left (comp up left)\n        up-right (comp up right)\n        down-left (comp down left)\n        down-right (comp down right)\n        directions [up down left right up-left up-right down-left down-right]\n        get-side (partial get-in board)\n        counter? (fn [loc] (distinct? 'e side (get-side loc)))\n        same-side? (fn [loc] (= side (get-side loc)))\n        available-locs (for [row (range board-size)\n                             col (range board-size)\n                             :let [loc [row col]]\n                             :when (= 'e (get-side loc))] loc)]\n    (apply\n      merge-with\n      #(set (concat %1 %2))\n      (for [start-loc available-locs direction directions\n            :let [succ-locs (take-while (complement nil?) (next (iterate direction start-loc)))\n                  [before after] (split-with counter? succ-locs)\n                  valid? (and (seq before)\n                              (same-side? (first after)))]\n            :when valid?]\n        {start-loc (set (take-while counter? succ-locs))}))))", "user": "56ac81ace4b03c432f187347"}, {"problem": 124, "code": "(fn allMoves [M color] ;;returns a map of all valid moves for player of color\n  (letfn [\n\n          (val-pos [M [x y]] ;;returns the val in a given position of the matrix\n            ((M x) y))\n\n          (empty-pos [M] ;;return a list of positions with 'e\n            (let [all-pos (for [x (range (count M))\n                                y (range (count (M 0)))]\n                            [x y])]\n              (filter #(= 'e (val-pos M %)) all-pos)))\n\n          (diag-dr [M [x y]];;generates list with elements in positions on diagonal down right\n            (let [xpos (range (inc x) (count M))\n                  ypos (range (inc y) (count (M 0)))\n                  pos (map #(vector %1 %2) xpos ypos)\n                  ]\n              pos))\n\n          (diag-ur [M [x y]];;generates list with elements in positions on diagonal up right\n            (let [xpos (reverse (range x))\n                  ypos (range (inc y) (count (M 0)))\n                  pos (map #(vector %1 %2) xpos ypos)\n                  ]\n              pos))\n\n          (diag-ul [M [x y]];;generates list with elements in positions on diagonal up left\n            (let [xpos (reverse (range x))\n                  ypos (reverse (range y))\n                  pos (map #(vector %1 %2) xpos ypos)\n                  ]\n              pos))\n\n          (diag-dl [M [x y]];;generates list with elements in positions on diagonal up left\n            (let [xpos (range (inc x) (count M))\n                  ypos (reverse (range y)) \n                  pos (map #(vector %1 %2) xpos ypos)\n                  ]\n              pos))\n\n          (horizontal-l [M [x y]];;generates list with elements in positions on horizontal left\n            (let [pos (for [ypos (reverse (range y))] [x ypos])] \n              pos))\n\n          (horizontal-r [M [x y]];;generates list with elements in positions on horizontal left\n            (let [pos (for [ypos (range (inc y) (count (M 0)))] [x ypos])] \n              pos))\n\n          (vertical-d [M [x y]];;generates list with elements in positions on vertical down\n            (let [pos (for [xpos (range (inc x) (count M))] [xpos y])] \n              pos))\n\n          (vertical-u [M [x y]];;generates list with elements in positions on vertical up\n            (let [pos (for [xpos (reverse (range x))] [xpos y])] \n              pos))\n\n          (valid-seq? [M color seq];given player and a seq of positions determine if \n                            ;it is a valid move for the player, i.e,\n                            ;in the seq must have a start seq of other player\n                            ;and finishes with the player\n                            ;returns a set with other players disks owned or nil\n                            ;if it is an invalid play\n            (if (or (= [] seq) (= color (val-pos M (first seq))))\n              nil\n              (loop [seq seq\n                     res #{}]\n                (if (or (= seq []) (= (val-pos M (first seq)) 'e))\n                  nil\n                  (if (= (val-pos M (first seq)) color)\n                    res\n                    (recur (rest seq) (conj res (first seq))))))))\n          \n          ]\n\n\n    (let [emptyPos (empty-pos M)\n          emptyAndSeqs (reduce #(assoc %1 %2 \n                                       (vector (diag-dr M %2)\n                                               (diag-ur M %2)\n                                               (diag-ul M %2)\n                                               (diag-dl M %2)\n                                               (horizontal-l M %2)\n                                               (horizontal-r M %2)\n                                               (vertical-d M %2)\n                                               (vertical-u M %2))) {} emptyPos)\n          umprocRes (reduce (fn [resGlobal ks]\n                              (assoc resGlobal ks\n                                     (loop [seqs (emptyAndSeqs ks) ;;for each list of a ks\n                                            res #{}]\n                                       (if (= seqs [])\n                                         res\n                                         (if-let [s (valid-seq? M color (first seqs))]\n                                           (recur (rest seqs) (clojure.set/union res s))\n                                           (recur (rest seqs) res)))))) {} (keys emptyAndSeqs))\n\n          ]\n      (loop [ks (keys umprocRes)\n             res {}]\n        (if (= ks [])\n          res\n          (if (= (umprocRes (first ks)) #{})\n            (recur (rest ks) res)\n            (recur (rest ks) (assoc res (first ks) (umprocRes (first ks))))))))))", "user": "574f1c24e4b02ea114799255"}, {"problem": 124, "code": "(fn [board color]\n    (let [size            (count board)\n          opponent        (if (= color 'w) 'b 'w)\n          empty-positions (for [y     (range size)\n                                x     (range size)\n                                :when (= ((board y) x) 'e)]\n                            [y x])\n          directions      (for [y [-1 0 1] x [-1 0 1] :when (not (= [y x] [0 0]))]\n                            [y x])\n          ray             (fn [position direction]\n                            (rest (take-while #(and (>= (first %) 0)\n                                                    (<  (first %) size)\n                                                    (>= (last %) 0)\n                                                    (<  (last %) size))\n                                              (iterate #(map + % direction)\n                                                       position))))\n          piece           (fn [position]\n                            ((board (first position)) (last position)))\n          flippable-ray   (fn [ray]\n                            (if (some #(= (piece %) color) ray)\n                              (take-while #(= (piece %) opponent)\n                                          (take-while #(not (= (piece %) color))\n                                                      ray))\n                              []))\n          rays            (map (fn [position]\n                                 [position (map (fn [direction]\n                                                  (flippable-ray (ray position direction)))\n                                                directions)])\n                               empty-positions)\n          pruned          (filter #(not (empty? (last %)))\n                                  (map (fn [[position rays]]\n                                         [position (filter (complement empty?) rays)])\n                                       rays))]\n      (into {} (map (fn [[position rays]]\n                      [position (set (apply concat rays))])\n                    pruned))))", "user": "50e90813e4b033b0e80d11e7"}, {"problem": 124, "code": "(fn f [r color]\n  (let [rcolor {'b 'w 'w 'b}\n        fxy (for [i [identity inc dec]\n                  j [identity inc dec]\n                  :when (not= i j identity)] [i j])\n        empty (for [y (range 0 (count r))\n                    x (range 0 (count (first r)))\n                    :when (= 'e (get-in r [y x]))] [y x])\n        flip-rec (fn flip-rec [[y x :as p] fy fx res]\n                   (cond \n                     (= (rcolor color) (get-in r p))\n                     (flip-rec [(fy y) (fx x)]\n                               fy\n                               fx\n                               (conj res p))\n                     (= color (get-in r p)) res\n                     :else []))\n        flip (fn [[y x] [fy fx]]\n               (flip-rec [(fy y) (fx x)] fy fx []))\n        check-point (fn [point]\n                      (vector point (set (mapcat #(flip point %) fxy))))]\n    (->> (map #(check-point %) empty)\n         (remove (comp empty? second))\n         (into {}))))", "user": "56795deae4b05957ce8c6187"}, {"problem": 124, "code": "( \nletfn\n[\n(get-pos\n  [b]\n  (map #(map (partial vector %) (range (count (first b)))) (range (count b))))\n(left-of\n  [b [y x]]\n  (take x (nth b y)))\n(right-of\n  [b [y x]]\n  (drop (inc x) (nth b y)))\n(up-of\n  [b [y x]]\n  (take y (map #(nth % x) b)))\n(down-of\n  [b [y x]]\n  (drop (inc y) (map #(nth % x) b)))\n(ld\n  [b [y x]]\n  (map #(get %1 (+ %2 (- x y))) b (range)))\n(up-ld-of\n  [b [y x]]\n  (filter (complement nil?) (take y (ld b [y x]))))\n(down-ld-of\n  [b [y x]]\n  (filter (complement nil?) (drop (inc y) (ld b [y x]))))\n(up-rd-of\n  [b [y x]]\n  (down-ld-of (reverse b) [(- (dec (count b)) y) x]))\n(down-rd-of\n  [b [y x]]\n  (up-ld-of (reverse b) [(- (dec (count b)) y) x]))\n(get-rays\n  [b [y x]]\n  [ (reverse (left-of b [y x]))\n    (right-of b [y x])\n    (reverse (up-of b [y x]))\n    (down-of b [y x])\n    (down-ld-of b [y x])\n    (reverse (up-ld-of b [y x]))\n    (reverse (down-rd-of b [y x]))\n    (up-rd-of b [y x])\n  ])\n(valid-ray\n  [b yx ray c1 c2]\n      (and\n        (= 'e (get-in b yx))\n        (= c2 (first ray))\n        (= c1 (first (drop-while #(= c2 %) ray)))))\n(valid-move\n  [b yx c1 c2]\n  (some\n    #(valid-ray b yx % c1 c2)\n    (get-rays b yx)))\n(valid-moves\n  [b c1 c2]\n  (filter #(valid-move b % c1 c2) (apply concat (get-pos b))))\n(augment\n  [b]\n  (vec (map #(vec (map (fn [yx] [yx, (get-in b yx)]) %)) (get-pos b))))\n(get-flipped\n  [b yx c1]\n  (->>\n    (get-rays (augment b) yx)\n    (map #(split-with (fn [[yx c]] (and (not= c c1) (not= c 'e))) %))\n    (filter #(and (< 0 (count (first %))) (= c1 (second (first (second %))))))\n    (mapcat first)\n    (map first)\n    (set)))\n(solve\n  [b c1]\n  (let [moves (valid-moves b c1 (if (= c1 'w) 'b 'w))]\n    (into {} (map (fn [yx] [yx, (get-flipped b yx c1)]) moves))))\n]\nsolve)", "user": "57717915e4b0979f896515b3"}, {"problem": 124, "code": "(fn [b m]\n  (let [u (if (= m 'w) 'b 'w)\n        get-all (fn [b m u [x y]]\n                  (if (= 'e (get-in b [x y]))\n                    (letfn [(along [di dj]\n                                   (loop [i (+ x di)\n                                          j (+ y dj)\n                                          r #{}]\n                                     (if (and (>= i 0) (< i 4) (>= j 0) (< j 4))\n                                       (if (= m (get-in b [i j]))\n                                         r\n                                         (if (= u (get-in b [i j]))\n                                           (recur (+ i di) (+ j dj) (conj r [i j]))\n                                           #{}))\n                                       #{})))]\n                      (clojure.set/union \n                       (along 0 -1)\n                       (along 0 1)        \n                       (along -1 0)\n                       (along 1 0)\n                       (along -1 1)\n                       (along 1 -1)\n                       (along 1 1)\n                       (along -1 -1)))\n                    #{}))\n        ]\n    (loop [xs (for [i (range 4) j (range 4)] [i j])\n           r {}]\n      (if (seq xs)\n        (let [s (get-all b m u (first xs))]\n          (if (= s #{})\n            (recur (rest xs) r)\n            (recur (rest xs) (assoc r (first xs) s))))\n        r))))", "user": "5799ff45e4b05b1deef9add1"}, {"problem": 124, "code": "(fn [board color]\n  (let [flip (if (= 'w color) 'b 'w)\n        hori (fn [x y] (for [i (range 4)] [x i]))\n        verti (fn [x y] (for [i (range 4)] [i y]))\n        slash (fn [x y] (remove #(or (some neg? %) (some (fn [n] (> n 3)) %)) (map  #(map + [x y] %) [[-3 -3] [-2 -2] [-1 -1] [0 0] [1 1] [2 2] [3 3]])))\n        backs (fn [x y] (remove #(or (some neg? %) (some (fn [n] (> n 3)) %)) (map #(map + [x y] %)  [[-3 3] [-2 2] [-1 1] [0 0] [1 -1] [2 -2] [3 -3]])))\n        pos (fn [[x y]] (nth (nth board x) y))\n        analyze (fn [f x y] (let [tmp (f x y)\n                                  tmp-str (apply str (map pos tmp))\n                                  chk1 (.indexOf tmp-str (str 'e flip color))\n                                  chk2 (.indexOf tmp-str (str color flip 'e))\n                                  chk3 (= tmp-str (str color flip flip 'e))\n                                  chk4 (= tmp-str (str 'e flip flip color))]\n                              (cond \n                                (< -1 chk1) (hash-map (first (second (split-at chk1 tmp))) #{(second (second (split-at chk1 tmp)))})\n                                (< -1 chk2) (hash-map (last (second (split-at chk2 tmp))) #{(second (second (split-at chk2 tmp)))})\n                                chk3 (hash-map (last tmp) (set (rest (butlast tmp))))\n                                chk4 (hash-map (first tmp) (set (rest (butlast tmp))))\n                               )))]\n    (reduce merge (flatten (for [x (range 4) y (range 4)]\n                             (if (= color (pos [x y]))\n                               [(analyze hori x y)\n                                (analyze verti x y)\n                                (analyze slash x y)\n                                (analyze backs x y)]\n                               ))))))", "user": "574abbfbe4b02ea114799200"}, {"problem": 124, "code": ";; Not the prettiest....\n(fn analyze-reversi [board player]\n  (letfn [(diagonals\n            [board]\n            (->> (for [i (range (count board))]\n                   (for [j (range (inc i))]\n                     (let [k (- i j)\n                           n (dec (count board))\n                           l (- n i)]\n                      [[(get-in board [k j]) k j]\n                       [(get-in board [(- n k) (- n j)]) (- n k) (- n j)]\n                       [(get-in board [j l]) j l]\n                       [(get-in board [(+ l j) j]) (+ l j) j]])))\n                 (mapcat #(apply mapv vector %))))\n          (rows \n            [board]\n            (for [i (range (count board))]\n              (for [j (range (count board))]\n                [(get-in board [i j]) i j])))\n          \n          (columns \n            [board]\n            (for [i (range (count board))]\n              (for [j (range (count board))]\n                [(get-in board [j i]) j i])))\n         \n          (legal-moves\n            [player opponent string]\n            (->> (re-seq \n                  (re-pattern \n                   (str player \"\\\\d+\" \\( opponent \"\\\\d+\" \\) \\+ 'e \"\\\\d+\"))       \n                  string)\n                 (map first)))\n          \n          (opponent [player]\n                    (if (= player 'w) 'b 'w))]\n    (->> (concat (diagonals board) \n                 (rows board) \n                 (columns board))\n         (map (comp (partial legal-moves player (opponent player))\n                    #(apply str %)\n                    #(apply concat %)\n                    #(apply concat %)\n                    #(vector % (reverse %))))\n         (remove empty?)\n         (apply concat)\n         (map (comp (fn [coll] [(vec (peek coll)) (set (map vec (pop coll)))])\n                    vec\n                    next\n                    #(partition 2 %)\n                    #(remove nil? %)\n                    #(map {\\0 0 \\1 1 \\2 2 \\3 3} %)\n                    #(next %)))\n         \n         (into {}))))", "user": "571c2babe4b07c98581c3b73"}, {"problem": 124, "code": "(fn analyze-reversi [b c]\n  (let [r1 [-1 0 1] r4 [0 1 2 3] opposite {'b 'w 'w 'b}]\n    (letfn [(clr [c] (get-in b c))\n            (is [col cell] (= (clr cell) col)) \n            (line-from [cell dir] (take-while (fn [p] (every? #(<= 0 % 3) p)) (iterate #(map + % dir) cell)))]\n      (let [empties (for [y r4 x r4 :when (is 'e [y x])] [y x])\n            directions (remove #{[0 0]} (for [x r1 y r1] [x y]))]\n        (->> (for [e empties d directions] (line-from e d)) ;; Lines from every empty cell in every direction\n             ;; split according to opposite color\n             (map (fn [line] [line (split-with #(= % (opposite c)) (rest (map clr line)))]))\n             ;; leave those that have at least one opposite cell, and one of ours at the end\n             (filter (fn [[line [c1 [c2 & _]]]] (and (seq c1) (= c c2))))\n             ;; get the coordinates of the affected cells, and put everything in a map\n             (map (fn [[[move & coords] [affected _]]] {move (set (take (count affected) coords))})) \n             (into {}))))))", "user": "575b3e9be4b02ea11479935b"}, {"problem": 124, "code": "(fn reversi [b p]  \n  (let [white 'w  \n        black 'b \n        space 'e] \n    (letfn [\n            (opponent [p] (if (= p white) black white))\n            \n            (cell \n              ([[i j]] (cell i j))\n              ([i j]\n                (get (get b i) j)))\n            \n            (move-up [[i j]] [(dec i) j])\n            \n            (move-down [[i j]] [(inc i) j])\n            \n            (move-left [[i j]] [i (dec j)])\n            \n            (move-right  [[i j]] [i (inc j)])\n            \n            (move-up-left [[i j]] (move-up (move-left [i j])))\n            \n            (move-up-right [[i j]] (move-up (move-right [i j])))\n            \n            (move-down-left [[i j]] (move-down (move-left [i j])))\n            \n            (move-down-right [[i j]] (move-down (move-right [i j])))\n            \n            (move \n              ([f c o] (move [] f c o))\n              \n              ([acc f c o]                \n                (let [n (f c)]\n                  (if (not= (cell n) o)\n                    acc\n                    (move (conj acc n) f n o)))))              \n            \n            (expand [f c]\n              (let [ms (move f c (opponent p))]\n                (cond \n                  (empty? ms) nil\n                  (= (cell (f (last ms))) p) {c (set ms)}\n                  :else nil)))\n            \n            (eval-option [c]\n              (->>\n                (map #(expand % c) [move-up move-down move-left move-right move-up-left \n                                    move-up-right move-down-left move-down-right])\n                (filter #(not (nil? %)))\n                (reduce conj {})))\n            \n            (add-cell [acc i j]\n              (if (= space (cell i j))\n                (conj acc [i j])\n                acc))\n            \n            (options []\n              (reduce \n                (fn [acc i]\n                  (reduce (fn [acc j] (add-cell acc i j)) acc (range 4)))\n                [] (range 4)))]\n      \n      (->>\n        (map eval-option (options))\n        (filter #(not (empty? %)))\n        (reduce conj)))))", "user": "57d9bca1e4b0bd073c202405"}, {"problem": 124, "code": "(fn [b w]\n  (let [r ({'w 'b, 'b 'w} w)\n        j (fn [l] (map (fn [e] {(get-in b e) #{e}}) l))\n        k (map-indexed (fn [i e] (map-indexed (fn [j v] {v #{[i j]}}) e)) b)\n        d (mapcat (fn [e]\n          (apply map #(filter (fn [[y x]] (< -1 y 4)) %&)\n            (for [p (range 4) :let [g [(fn [e] [(+ p e) p]) (fn [e] [(+ p e) (- 3 p)])]]]\n              (map (g e) [-1 0 1])))) [0 1])\n        s (concat k (apply map vector k) (map j d))\n        t (into s (mapcat #(partition 3 1 %) s))\n        u (filter #(#{['e r w] [w r 'e] ['e r r w] [w r r 'e]} (mapcat keys %)) t)\n        z (fn [s] (zipmap (map #(first (% 'e)) s) (map #(% r) s)))]\n    (z (map #(apply merge-with clojure.set/union %) u))))", "user": "548b7db8e4b0e286459a11fd"}, {"problem": 124, "code": "(fn [board piece]\n  (letfn [(step [op-piece start gap result]\n            (let [next-start (mapv #(+ %1 %2) start gap)\n                  next-piece (get-in board next-start)]\n              (if (= next-piece op-piece)\n                (step op-piece next-start gap (conj result next-start))\n                (if (= next-piece 'e)\n                  (if (seq result)\n                    {next-start (set result)}\n                    {})\n                  {}))))]\n    (apply\n      merge\n      (mapcat\n        #(map\n           (fn [gap] (step (if (= piece 'w) 'b 'w) % gap []))\n           [[0 1] [0 -1] [1 0] [-1 0] [1 1] [-1 -1] [1 -1] [-1 1]])\n        (filter #(= piece (get-in board %)) (mapcat #(map (fn [ele] [% ele]) (range 0 4)) (range 0 4)))))))", "user": "57df309ee4b0bd073c20245f"}, {"problem": 124, "code": "(fn reversi[f c]\n  (letfn[\n         (nnth[f i j] (nth (nth f  i) j))\n\n(inrange? [f i j] (and (>= i 0) (>= j 0) (< i (count f)) (< j (count f))))\n\n(inverse-color? [basec c]\n  (if (or (= basec c) (= 'e c))\n    false\n    true))\n\n(valid-cell?\n  [f r c col rn cn]\n  (and\n   (inrange? f r c)\n   (inverse-color? col (nnth f r c))\n   (inrange? f rn cn)\n   (or (= col (nnth f rn cn)) (inverse-color? col (nnth f rn cn)))))\n\n(get-flipped [f sr sc er ec ir ic col]\n  (let [m (for [i (range 1 (count f))\n                :let [r (+ sr (* ir i))\n                      c (+ sc (* ic i))\n                      rn (+ sr (* ir (inc i)))\n                      cn (+ sc (* ic (inc i)))] \n                :while (valid-cell? f r c col rn cn)]\n            [r c]\n            )\n        ]\n    (if (and\n         (> (count m) 0)\n         (< (count m) (count f))\n         (every? #(inverse-color? col %) (map #(apply nnth f %) m))\n         (= col (nnth f (+ sr (* ir (inc (count m)))) (+ sc (* ic (inc (count m)))))))\n      m [])\n    ))\n\n(get-flipped-diag [f sr sc er ec ir ic col]\n  (get-flipped f sr sc er ec ir ic col)\n  )\n\n(get-flipped-col [f sr c er ir col]\n  (get-flipped f sr c er c ir 0 col)\n  )\n\n(get-flipped-row [f r sc ec ic col]\n  (get-flipped f r sc r ec 0 ic col)\n  )\n\n(get-all [f r c color]\n  (filter #(not-empty %) (vector\n                          (get-flipped-row f r c 0 -1 color)\n                          (get-flipped-col f r c 0 -1  color)\n                          (get-flipped-diag f r c 0 0 -1 -1 color)\n                          \n                          (get-flipped-row f r c (count f) 1 color)\n                          (get-flipped-col f r c (count f) 1 color)\n                          (get-flipped-diag f r c (count f) (count f) 1 1 color)\n                          \n                          (get-flipped-diag f r c 0 (count f) -1 1 color)\n                          (get-flipped-diag f r c (count f) 0 1 -1 color)\n                          ))  )\n         ]\n    (reduce\n     #(assoc %1 (first %2) (second %2))\n     {}\n     (filter #(not (empty? (second %)))\n             (for [row (range (count f)) col (range (count f))]\n               (if (= 'e (nnth f  row col))\n                 [[row col] (set (reduce concat #{}  (get-all f row col c)))] \n                 )\n               )\n             ))\n    ) \n  \n  )", "user": "55eeb37ae4b0121d4835fdf3"}, {"problem": 124, "code": "(fn revrc [board player]\n  (let [samep? #(= (get-in board [% %2]) player)\n        freep? #(= (get-in board [% %2]) 'e)\n        other? #(and (not (samep? % %2)) (not (freep? % %2)))\n        onboard? #(and (<= 0 % 3) (<= 0 %2 3))\n        flips (fn [i j] (let [legal (into #{} (mapcat identity (remove empty?\n                (for [op1 [inc dec identity] op2 [inc dec identity]\n                              :when (and (onboard? (op1 i) (op2 j))\n                                         (other?   (op1 i) (op2 j)))]\n                          (loop [i1 (op1 i)  j1 (op2 j ) acc (list [i1 j1])\n                                 i2 (op1 i1) j2 (op2 j1)]   \n                            (cond (or (not (onboard? i2 j2)) (freep? i2 j2)) ()\n                                  (samep? i2 j2) acc\n                                  :ELSE (recur i2 j2 (conj acc [i2 j2])\n                                               (op1 i2) (op2 j2))))))))]\n                             (if (pos? (count legal)) (set legal) false)))]\n         (into {} (remove nil? (for [i (range 4) j (range 4)\n                                              :when (freep? i j) ]\n                                          (when-let [f (flips i j)]\n                                            [[i j] f] ))))))", "user": "579d9601e4b05b1deef9ae18"}, {"problem": 124, "code": "(fn\n  [board color]\n  (reduce \n    #(assoc %1 (first %2) (second %2)) \n    {} \n    (for [r (range (count board)) \n          c (range (count (first board)))\n          :when (= (get-in board [r c]) color)\n          x (range -1 2) y (range -1 2) :when (not= [0 0] [x y])\n          :let [cs (partition-by\n                     #(get-in board %)\n                     (map #(vector (+ r (* x %)) (+ c (* y %))) (range 1 5)))\n                m (first (second cs))]\n          :when (and (= ({'w 'b 'b 'w} color) (get-in board (ffirst cs))) (= 'e (get-in board m)))]\n      [m (set (first cs))])))", "user": "576df252e4b0979f8965156f"}, {"problem": 124, "code": "(fn analyze-reversi\n  [graph color]\n  (let [size (count graph)\n        pos-seq (for [x (range 0 size)\n                      y (range 0 size)]\n                  [x y])\n        dirs (remove\n               (fn [[x y]]\n                 (and (zero? x) (zero? y)))\n               (for [x [-1 0 1]\n                     y [-1 0 1]]\n                 [x y]))\n        legal-pos? (fn [x y]\n                     (and (>= x 0) (< x size)\n                          (>= y 0) (< y size)))\n        reverse-pos-on-one-dir\n        (fn [[x y] [dx dy]]\n           (if (not= 'e (get-in graph [x y]))\n             [[x y] #{}]\n             (loop [nx (+ x dx) ny (+ y dy) res #{}]\n               (if (legal-pos? nx ny)\n                 (if (= color (get-in graph [nx ny]))\n                   [[x y] res]\n                   (if (= 'e (get-in graph [nx ny]))\n                     [[x y] #{}]\n                     (recur (+ nx dx) (+ ny dy) (conj res [nx ny]))))\n                 [[x y] #{}]))))\n        reverse-pos-on-all-dirs\n        (fn [[x y]]\n          (reduce (fn [[pos1 ps1] [pos2 ps2]]\n                    [pos1 (clojure.set/union ps1 ps2)])\n                  (map (fn [dir]\n                         (reverse-pos-on-one-dir [x y] dir)) dirs)))]\n    (into {}\n          (filter (fn [[pos ps]]\n                    (not (empty? ps)))\n                  (map reverse-pos-on-all-dirs\n                       pos-seq)))))", "user": "56a36f76e4b0542e1f8d14ca"}, {"problem": 124, "code": "(fn [board piece]\n   (let [dim (count board)]\n      (letfn [(getv [x y] (nth (nth board x []) y nil))\n              (flip [x] (if (= x 'w) 'b 'w))]\n         (reduce (fn [result cord]\n                    (let [[x y] cord\n                          lefts (for [i (rest (range dim)) :when (= (getv x (- y i)) (flip piece))] [x (- y i)])\n                          vlefts (if (and (not (empty? lefts)) (= piece (getv x (dec (second (last lefts)))))) lefts)\n                          rights (for [i (rest (range dim)) :when (= (getv x (+ y i)) (flip piece))] [x (+ y i)])\n                          vrights (if (and (not (empty? rights)) (= piece (getv x (inc (second (last rights)))))) rights)\n                          ups (for [i (rest (range dim)) :when (= (getv (- x i) y) (flip piece))] [(- x i) y])\n                          vups (if (and (not (empty? ups)) (= piece (getv (dec (first (last ups))) y))) ups)\n                          downs (for [i (rest (range dim)) :when (= (getv (+ x i) y) (flip piece))] [(+ x i) y])\n                          vdowns (if (and (not (empty? downs)) (= piece (getv (inc (first (last downs))) y))) downs)\n                          uplefts (for [i (rest (range dim)) :when (= (getv (- x i) (- y i)) (flip piece))] [(- x i) (- y i)])\n                          vuplefts (if (and (not (empty? uplefts)) (= piece (getv (dec (first (last uplefts))) (dec (second (last uplefts)))))) uplefts)\n                          uprights (for [i (rest (range dim)) :when (= (getv (- x i) (+ y i)) (flip piece))] [(- x i) (+ y i)])\n                          vuprights (if (and (not (empty? uprights)) (= piece (getv (dec (first (last uprights))) (inc (second (last uprights)))))) uprights)\n                          downlefts (for [i (rest (range dim)) :when (= (getv (+ x i) (- y i)) (flip piece))] [(+ x i) (- y i)])\n                          vdownlefts (if (and (not (empty? downlefts)) (= piece (getv (inc (first (last downlefts))) (dec (second (last downlefts)))))) downlefts)\n                          downrights (for [i (rest (range dim)) :when (= (getv (+ x i) (+ y i)) (flip piece))] [(+ x i) (+ y i)])\n                          vdownrights (if (and (not (empty? downrights)) (= piece (getv (inc (first (last downrights))) (inc (second (last downrights)))))) downrights)\n                          vsets (set (reduce #(if (empty? %2) %1 (apply conj %1 %2)) [] [vlefts vrights vups vdowns vuplefts vuprights vdownlefts vdownrights]))]\n                       (if (not (empty? vsets)) (assoc result cord vsets) result)))\n                 {}\n                 (for [x (range dim) y (range dim) :when (= 'e (getv x y))] [x y])))))", "user": "57dd47f4e4b0bd073c20243e"}, {"problem": 124, "code": "(fn __ [m n]\n (letfn [(opst [c] (if (= c 'w) 'b (if (= c 'b) 'w 'e)))\n \t (xya [[x y]] (+ x (* 4 y)))\n         (axy [a] [(int (/ a 4)) (mod a 4)])\n\t (ges [ma] (let [mal (flatten ma)]\n \t      (map axy (filter #(not= % -1)\n\t\t(map #(if (= %1 'e) %2 -1) mal (range (count mal)))))))\n\t (adjcoo [[r c]] \n\t \t (->> [[(dec r) c \"n\"] [(inc r) c \"s\"] \n\t       [r (dec c) \"w\"] [r (inc c) \"e\"]\n\t\t       [(dec r) (dec c) \"nw\"] [(inc r) (dec c) \"sw\"]\n\t\t       [(dec r) (inc c) \"ne\"] [(inc r) (inc c) \"se\"]] \n\t \t (filter #(not (or (= (first %) -1) (= (second %) -1) \n\t\t \t       \t      (= (first %) 4) (= (second %) 4))))))\n\t (reved ([d c xy] \n\t  (let [adjc (filter #(= (opst c) (get (get d (first %)) (second %))) \n\t\t     (adjcoo xy))]\n\t\t(loop [adjcc adjc acc []]\n\t\t      (if (empty? adjcc)\n\t\t      \t  acc\n\t\t\t  (recur (rest adjcc) (if adjcc (conj acc (reved d c (first adjcc) [xy])) acc))))))\n\t        ([d c xyd prev]\n\t\t (let [nprev (conj prev xyd)\n\t\t       adjc (first (filter #(= (last xyd) (last %)) (adjcoo (butlast xyd))))\n\t\t       rsltc (get (get d (first adjc)) (second adjc))]\n\t\t      (if (and (not= 'e rsltc) adjc)\n\t\t       (reved d c adjc nprev)\n\t\t       (cleanup d nprev c)))))\n\t(cleanup [d l c]\n\t (let [totest (map #(list (first %) (second %) (get (get d (first %)) (second %))) \n\t  l)]\n\t   (if (< (count totest) 3) nil\n\t       (if (and (= (last (second totest)) (opst c))\n\t       \t    \t(some #(= (last %) c) (rest (rest totest))))\n\t       \t   (map #(if (or (= (last %) 'e) (= (last %) (opst c))) (vector (first %) (second %)) nil) (drop-last totest))\n\t\t   nil))))]\n (loop [es (ges m) acc []]\n       (if (empty? es)\n       \t   (into {} (map #(vector (first %) (into #{} (remove nil? (rest %)))) (remove nil? acc)))\n\t   (recur (rest es) (let [ret (reved m n (first es))]\n\t   \t  \t(if (or (= [] ret) (= [nil] ret))\n\t\t\t    acc\n\t\t\t    (conj acc (first (remove nil? ret))))))))))", "user": "52747090e4b03e8d9a4a74a5"}, {"problem": 124, "code": "(fn analyze-reversi [srcfield color]\n  (letfn [\n    (flatten-seqs [colls] (reduce (fn [acc b] (into acc b)) [] colls))\n    (load-field [srcv]\n      (vec\n        (map (fn [row] (into [] (map #(keyword %) row))) srcv)))\n    (get-color-ijs [clr fld]\n      (let [height (count fld)\n            width (count (first fld))]\n        (vec (for [i (range 0 height) j (range 0 width)\n                   :when (= clr (get-in fld [i j]))]\n          [i j]) )))\n    (get-arrows [[height width] [y x]]\n      (letfn [\n        (in-fld? [[i j]]\n          (and (>= i 0) (>= j 0) (< i height) (< j width)))\n        (move-left [[i j]] [i (dec j)])\n        (move-right [[i j]] [i (inc j)])\n        (move-up [[i j]] [(dec i) j])\n        (move-down [[i j]] [(inc i) j])\n        (move-upleft [[i j]] [(dec i) (dec j)])\n        (move-upright [[i j]] [(dec i) (inc j)])\n        (move-downleft [[i j]] [(inc i) (dec j)])\n        (move-downright [[i j]] [(inc i) (inc j)])\n        (get-pt-arrow [point movefn]\n          (letfn [(loc-grow-arrow [pt]\n                    (when (in-fld? pt)\n                      (lazy-seq (cons pt (loc-grow-arrow (movefn pt))))))]\n            (vec (loc-grow-arrow point)))) ]\n            (map (partial get-pt-arrow [y x])\n               (list move-right move-down move-left move-up\n                     move-upleft move-upright move-downleft move-downright)) ))\n    (get-fld-item [fld [i j]]\n      (get-in fld [i j]))\n    (include-fst-space [item-getter ptv]\n      (loop [acc [] base ptv]\n        (if (empty? base)\n          []\n          (let [[fst rst] [(first base) (rest base)]\n                acc-plus (conj acc fst)]\n            (if-not (= :e (item-getter fst))\n              (recur acc-plus rst)\n              acc-plus) ))))\n    (v-trunc [vx] (->> vx (rest ,,,) (drop-last ,,,)))\n    (color-check? [getter color ptv] (= color (getter ptv)))\n    (result-for-stroke [getter color vstroke]\n      (let [innen (v-trunc vstroke)\n            color-points (set (filter (partial color-check? getter color) innen))\n            end-point (last vstroke)]\n        (if (empty? color-points)\n          []\n          [end-point color-points])))\n         ]\n    (let [cname (keyword color)\n          inv-cname (if (= :w cname) :b :w)\n          gfld (load-field srcfield)\n          height (count gfld)\n          width (count (first gfld))\n          my-getter (partial get-fld-item gfld)\n          my-ijs (get-color-ijs cname gfld)\n          my-strokes (->> my-ijs\n                          (map (partial get-arrows [height width]) ,,,)\n                          (flatten-seqs ,,,))\n          strokes-sp-end (->> my-strokes\n                              (map (partial include-fst-space my-getter) ,,,)\n                              (remove empty? ,,,))\n          good-points-data\n            (->> strokes-sp-end\n                 (map (partial result-for-stroke my-getter inv-cname) ,,,)\n                 (remove empty? ,,,))\n          good-maps (map (partial apply hash-map) (distinct good-points-data))\n          ]\n      (apply merge-with clojure.set/union good-maps) )))", "user": "57f9011ee4b0d3187e900935"}, {"problem": 124, "code": "(fn [board color]\n  (let [step-fns [(fn [[y x]] [(dec y) x])\n                  (fn [[y x]] [(dec y) (inc x)])\n                  (fn [[y x]] [y (inc x)])\n                  (fn [[y x]] [(inc y) (inc x)])\n                  (fn [[y x]] [(inc y) x])\n                  (fn [[y x]] [(inc y) (dec x)])\n                  (fn [[y x]] [y (dec x)])\n                  (fn [[y x]] [(dec y) (dec x)])]\n        opposite (if (= color 'w) 'b 'w)\n        starts (for [y (range 4)\n                     x (range 4)\n                     :when (= color\n                              (get-in board [y x]))]\n                 [y x])]\n    (letfn [(valid? [[y x]]\n              (and (<= 0 y 3)\n                   (<= 0 x 3)))\n            (opposite? [cell]\n              (= opposite (get-in board cell)))\n            (line [start step-fn]\n              ((fn line [cell cont?]\n                 (lazy-seq\n                   (when (and (valid? cell)\n                              cont?)\n                     (cons cell (line (step-fn cell) (opposite? cell))))))\n               (step-fn start) (opposite? (step-fn start))))\n            (lines [start]\n              (for [step-fn step-fns\n                    :let [cells (line start step-fn)]\n                    :when (and (not (empty? cells))\n                               (= 'e (get-in board (last cells))))]\n                cells))\n            (update [m k f x]\n              (assoc m k (f (get m k) x)))\n            (f [c p]\n              (update c (last p) (fnil into #{}) (butlast p)))]\n      (reduce f {} (mapcat lines starts)))))", "user": "57f0f7b8e4b0bfb2137f5bfe"}, {"problem": 124, "code": "(fn [l a]\n   (let [b (if (= a 'b) 'w 'b)\n         g #(get-in l %)\n         e (range 4)\n         R reduce\n         e (for [i e j e :when (= (g [i j]) 'e)] [i j])\n         s [-1 0 1]\n         s (for [i s j s] [i j])\n         m #(let [[i j] %\n                  [X Y] %2]\n              (loop [x (+ i X) y (+ j Y) r []]\n                (let [p [x y]]\n                  (condp = (g p)\n                    a r\n                    b (recur (+ x X) (+ y Y) (conj r p))\n                    []))))]\n     (R (fn [o p]\n               (let [t (set (R #(concat % (m p %2)) [] s))]\n                 (if (empty? t) o\n                   (conj o [p t])))) {} e)\n     ))", "user": "57d9f603e4b0bd073c20240a"}, {"problem": 124, "code": "(fn __ [b p]\n  (let [r (range 4)\n        d [-1 0 1]]\n    (->> (for [x r y r] [x y])\n         (map (juxt identity\n                    (fn [c]\n                      (when (= 'e (get-in b c))\n                        (->> (for [x d y d] [x y])\n                             (remove #(= [0 0] %))\n                             (map #((fn f\n                                      ([c d] (f c d #{}))\n                                      ([c d a]\n                                       (let [n (map + c d)\n                                             s (get-in b n)]\n                                         (if (= s p) a\n                                           (if (= s ('{b w w b} p))\n                                             (f n d (conj a n))\n                                             #{}))))) c %))\n                             (apply clojure.set/union))))))\n         (remove (comp empty? second))\n         (into {}))))", "user": "57a0b341e4b0c3d858beb8d4"}, {"problem": 124, "code": "(let [directions [[-1 -1] [-1 0] [-1 1]\n                  [0  -1]        [0  1]\n                  [1  -1] [1  0] [1  1]]\n      in-bounds? (fn [[x y]]\n                   (and (>= x 0)\n                        (>= y 0)\n                        (<= x 3)\n                        (<= y 3)))\n      move-it (fn [loc dir]\n             (let [[lx ly] loc\n                   [dx dy] dir]\n               [(+ lx dx) (+ ly dy)]))\n      move-segment (fn [board loc dir color]\n                     (loop [pos (move-it loc dir)\n                            captures #{}]\n                       (if (in-bounds? pos)\n                         (let [current (get-in board pos)]\n                           (if (= current color)\n                             []\n                             (if (= current 'e)\n                               (if (empty? captures)\n                                 []\n                                 [{pos captures}])\n                               (recur (move-it pos dir) (conj captures pos)))))\n                         [])))\n      positions (mapcat (fn [x] (map (fn [y] [x y]) (range 4))) (range 4))]\n  (fn reversi\n    [board color]\n    (into {}\n          (mapcat (fn [pos]\n                    (mapcat (fn [dir]\n                              (move-segment board pos dir color))\n                            directions))\n                  (filter #(= (get-in board %) color) positions)))))", "user": "58152157e4b0f478707a0631"}, {"problem": 124, "code": ";; TODO; Can this lose a bit of weight?\n(fn moves[input color]\n  (let [width 4\n        height 4\n        color (first (str color)) ;; sym to char\n        board (mapv (fn [row]\n                      (mapv (fn [piece]\n                              (cond (= (symbol 'b) piece) \\b\n                                    (= (symbol 'w) piece) \\w\n                                    :else \\e))\n                            row))\n                    input)\n        v-board (apply map vector board)\n        all-coords (for [y (range height)\n                         x (range width)]\n                     [x y])]\n    (letfn [(opposite [color]\n              (if (= color \\b) \\w \\b))\n            (grab [v]\n              (get-in board v))\n            (empty-cell? [v]\n              (= \\e (grab v)))\n            (move [[y x] color run-fn]\n              (let [r (run-fn [y x])\n                    run (map grab r)\n                    runs (apply str run)\n                    regex (re-pattern (str \"^\" \\e (opposite color) \"+\" color))\n                    grab (re-seq regex runs)\n                    win-line (when grab (apply seq grab))]\n                (when win-line\n                  (->> (map vector win-line r)\n                       (reduce (fn [memo [c v]] (if (= c (opposite color)) (conj memo v) memo)) [])\n                       set\n                       (hash-map [y x])))))\n            (run [f1 f2]\n              (fn walk[[y x]] \n                (if (or (>= y height) (>= x width) (< y 0) (< x 0))\n                  '()\n                  (cons [y x]\n                        (walk [(f1 y) (f2 x)])))))]\n\n      (let [walks (list (run inc identity) ;; down\n                        (run identity inc) ;; right\n                        (run identity dec) ;; left\n                        (run dec identity) ;; up\n                        (run dec dec)   ;; up-left\n                        (run inc inc)   ;; down-right\n                        (run inc dec)   ;; down-left\n                        (run dec inc))] ;; up right\n\n        (->> all-coords\n             (map (fn [coord] (map #(move coord color %) walks)))\n             flatten\n             (filter identity)\n             (apply merge))))))", "user": "56069006e4b08b23635d3174"}, {"problem": 124, "code": "(fn [board color]\n    (into {} (for [y (range 4)\n                   x (range 4)\n                   move (for [dx [-1 0 1]\n                              dy [-1 0 1]\n                              l [3 4]\n                              :when (not= 0 dx dy)]\n                          (map (juxt #(* dx %) #(* dy %)) (range l)))\n                   :let [line (map #(map + [x y] %) move)]\n                   :when (every? (partial every? #(<= 0 % 3)) line)\n                   :let [from (first line)\n                         to (last line)\n                         over (rest (butlast line))\n                         other-color ({'b 'w 'w 'b} color)]\n                   :when (and (= (get-in board from) color)\n                              (= (get-in board to) 'e)\n                              (every? #(= other-color (get-in board %)) over))]\n               [to (set over)])))", "user": "55c5b55fe4b0e31453f649b5"}, {"problem": 124, "code": "(fn [board color]\n  (let [opposite ('{w b, b w} color)\n        legal-moves-on-line\n        (fn [line]\n          (let [line (drop-while (comp not #{'e} :color) line)\n                [empties line] (split-with (comp #{'e} :color) line)\n                [opposites tail] (split-with (comp #{opposite} :color) line)]\n            (if (and (last empties)\n                     (not-empty opposites)\n                     (= color (:color (first tail))))\n              {(:coords (last empties)) (set (map :coords opposites))}\n              {})))\n        rows (vec (for [y (range 4)]\n                    (vec (for [x (range 4)]\n                           {:coords [y x], :color (get-in board [y x])}))))\n        columns (apply map vector rows)\n        diagonal-coords [[[0 0] [1 1] [2 2] [3 3]]\n                         [[1 0] [2 1] [3 2]]\n                         [[0 1] [1 2] [2 3]]]\n        diagonals1 (->> diagonal-coords\n                        (map (partial map (partial get-in rows))))\n        diagonals2 (->> diagonal-coords\n                        (map (partial map (fn [[y x]]\n                                            (get-in rows [y (- 3 x)])))))]\n    (->> (concat rows columns diagonals1 diagonals2)\n         ((fn [lines] (concat lines (map reverse lines))))\n         (map legal-moves-on-line)\n         (apply merge-with into))))", "user": "583e27e2e4b089d5ab817daa"}, {"problem": 124, "code": "(fn [board color]\n  (let [opponent (if (= color 'w) 'b 'w)\n        directions (for [r (range -1 2), c (range -1 2)]\n                     #(map + % [r c]))\n        empty-fields (for [row (-> board count range)\n                           col (-> board first count range)\n                           :when (= 'e (get-in board [row col]))]\n                       [row col])\n        flip-in-direction (fn [field move]\n                            (loop [current (move field), flipped #{}]\n                              (condp = (get-in board current)\n                                color flipped\n                                nil #{}\n                                'e #{}\n                                opponent (recur (move current) (conj flipped current)))))\n        flip-in-all-directions (fn [field] \n                                 (->> directions\n                                      (map #(flip-in-direction field %))\n                                      (apply clojure.set/union)))]\n    (->> (for [field empty-fields\n               :when (not-empty (flip-in-all-directions field))]\n           {field (flip-in-all-directions field)})\n         (apply merge))))", "user": "58247423e4b051871117bec5"}, {"problem": 124, "code": "(fn [board player]\n  (let [check-direction (fn [[r, c],\n                             [r-inc, c-inc]]\n                          (let [opp (if (= player 'w)\n                                      'b 'w)\n                                first-next-piece (get-in board [(+ r r-inc),\n                                                                (+ c c-inc)])]\n                            (when (= first-next-piece opp)\n                              (loop [[r-old c-old] [(+ r r-inc),\n                                                    (+ c c-inc)]\n                                     reversing #{[r-old, c-old]}]\n                                (let [r-new (+ r-old r-inc)\n                                      c-new (+ c-old c-inc)\n                                      next-piece (get-in board [r-new, c-new])]\n                                  (when next-piece\n                                    (cond\n                                      (= next-piece 'e) nil\n                                      (= next-piece player) reversing\n                                      :else (recur [r-new, c-new]\n                                                   (conj reversing\n                                                         [r-new, c-new])))))))))\n        check-loc (fn [[r, c]]\n                    (apply clojure.set/union\n                           (for [x [-1 0 1]\n                                 y [-1 0 1]\n                                 :when (not (and (= x 0)\n                                                 (= y 0)))]\n                             (check-direction [r c] [x y]))))]\n    (let [r-max (count board)\n          c-max (count (first board))]\n      (apply hash-map\n             (apply concat\n                    (for [x (range r-max)\n                          y (range c-max)\n                          :when (= 'e (get-in board [x y]))\n                          :let [reversi (check-loc [x y])]\n                          :when reversi]\n                      [[x y], reversi]))))))", "user": "54848141e4b0e286459a119e"}, {"problem": 124, "code": "(fn [board player]\n  (let [units [[-1 -1] [0 -1] [1 -1] [-1 0] [1 0] [-1 1] [0 1] [1 1]]\n        rdims (range (count board))\n        indices (set rdims)    ;; for checking if index in range.\n        opponent {'b 'w 'w 'b} ;; the opposing player.\n        entry (fn [[i j]] ((board i) j)) ;; get state of point on board\n        my-pieces (filter #(= (entry %) player) (for [i rdims j rdims] [i j]))\n        candidates (for [p my-pieces u units] [p u])\n\n        on-board (fn [[x y]] (and (indices x) (indices y))) ;; check if coords on board.\n\n        explore (fn [p u] ;; path from point p to edge of board in direction u.\n                  (vec (take-while on-board (iterate #(vec (map + u %)) p))))\n\n        valid (fn [v player]\n                \"Check for valid move on given path\"\n                (cond\n                  (< (count v) 3)\n                  false ;; no room to place piece.\n\n\n                  (not= (entry (v 1)) (opponent player))\n                  false ;; no adjacent piece of right colour.\n\n                  :else ;; collect all piece of opposite colour ready for flip.\n                  (let [[flips moves] (split-with #(= (entry %) (opponent player)) (rest v))]\n                    (if (or (empty? moves) (not= (entry (first moves)) 'e))\n                      false\n                      {(first moves) (set flips)}))))] ;; map from move point to flips.\n\n    (into {} (remove false? (map (fn [x] (valid x player))\n                                   (map #(apply explore %) candidates))))))", "user": "58a0fc33e4b02bd94d917ea3"}, {"problem": 124, "code": "(fn [board player]\n         (let [dirs [[:n -1 0] [:nw -1 -1] [:ne -1 1]\n                     [:w 0 -1] [:e 0 1]\n                     [:s 1 0] [:sw 1 -1] [:se 1 1]]\n               tfr-board (fn [board]\n                           (mapv #(mapv (fn [v i] [v %2 i]) %1 (range)) board (range)))\n               tboard (tfr-board board)\n               player-line (fn [row col [dir rd cd]]\n                             (loop [r (+ row rd) c (+ col cd) result []]\n                               (if (or (< r 0) (>= r 4) (< c 0) (>= c 4))\n                                 result\n                                 (let [[p r c] (get-in tboard [r c])]\n                                   (if (= p 'e)\n                                     result\n                                     (recur (+ r rd) (+ c cd) (conj result [p r c])))))))\n               valid-line? (fn [line player]\n                             (let [[h t] (split-with #(not= player (first %)) line)]\n                               (if (and (not (empty? h)) (= player (first (first t))))\n                                 (->> h\n                                      (map (comp vec (partial drop 1)))\n                                      (into #{})))))\n               empties (->> (mapcat identity tboard)\n                            (filter #(= (first %) 'e))\n                            (mapv (comp vec (partial drop 1))))\n               posibles (fn [[row col]]\n                          (->> (mapv #(valid-line? (player-line row col %) player) dirs)\n                               (filter identity)\n                               (mapcat identity)\n                               (into #{})))]\n           #(valid-line? (player-line 0 3 [:sw 1 -1]) player)\n           (->> empties\n                (map #(let [ps (posibles %)]\n                        (if (not (empty? ps))\n                          [% ps])))\n                (filter identity)\n                (into {}))\n           ))", "user": "58949f8de4b00487982d525e"}, {"problem": 124, "code": "(letfn [(boardwalk [board player-color start-cell dir]\n            (let [f (disj #{'b 'w} player-color) g #{player-color}]\n              (when (= 'e (get-in board start-cell))\n                (loop [c (mapv + start-cell dir) res []]\n                (let [x (get-in board c)]\n                  (cond\n                    (f x) (recur (mapv + c dir) (conj res c))\n                    (g x) res\n                    :default nil))))))]\n    (fn [board color]\n      (into {}\n            (let [directions [[1 0] [1 1] [0 1] [-1 1] [-1 0] [-1 -1] [0 -1] [1 -1]]]\n              (for [i (range 4) j (range 4) d directions\n                    :let [b (boardwalk board color [i j] d)]\n                    :when (not-empty b)]\n                [[i j] (set b)])))))", "user": "57b3efb1e4b0fbc9809a278a"}, {"problem": 124, "code": "(fn [board color]\n  (let [opponent {'w 'b 'b 'w}\n        axis (map dec (range 3))\n        axes (for [row axis col axis] [row col])\n        directions (remove #{[0 0]} axes)]\n    (letfn [(line [board row col [row-vec col-vec :as direction]]\n              (let [cell (get-in board [row col])]\n                (if ((complement nil?) cell);;some? is missing :-/\n                  (lazy-seq\n                   (cons [[row col] cell]\n                     (line board (+ row row-vec) (+ col col-vec) direction))))))\n            (flips [line color]\n              (let [split-pred #(= (opponent color) (second %))\n                    [moves [[_ flipper]]] (split-with split-pred line)]\n                (if (= flipper color)\n                  (map first moves))))\n            (cell-moves [board row col color]\n              (if (= 'e (get-in board [row col]))\n                (let [lines (map #(rest (line board row col %)) directions)\n                      moves (mapcat #(flips % color) lines)]\n                  [[row col] (set (filter seq moves))])))\n            (board-moves [board color]\n              (for [row-index (range (count board))\n                    col-index (range (count (get board row-index)))]\n                 (cell-moves board row-index col-index color)))\n            (reversi-moves [board color]\n              (->> (board-moves board color)\n                   (filter (comp seq second))\n                   (apply concat)\n                   (apply hash-map)))]\n      (reversi-moves board color))))", "user": "585d9558e4b0f14aab7c879c"}, {"problem": 124, "code": "(fn [board color]\n  (let [moves [[-1 -1] [-1 0] [-1 1] [0 -1] [0 1] [1 -1] [1 0] [1 1]]]\n    (letfn [(opponent [c] (condp = c 'b 'w 'w 'b nil))\n            (walk [board color [[i j] flips [di dj :as dir] :as pos]]\n              (if dir\n                (let [move [(+ i di) (+ j dj)]\n                      next-color (get-in board move)]\n                  (cond\n                    (nil? next-color) nil\n                    (and (= next-color 'e) (seq flips)) [move flips nil]\n                    (= next-color (opponent color)) [move (conj flips move) dir]))\n                pos))\n            (start [board color]\n              (apply concat (keep-indexed (fn [i r] (apply concat (keep-indexed (fn [j c] (when (= c color) (keep #(walk board c [[i j] #{} %]) moves))) r))) board)))]\n      (->> (start board color)\n        (iterate (partial keep (partial walk board color)))\n        (drop-while (fn [xs] (some #(nth % 2) xs)))\n        first\n        (remove #(nth % 2))\n        (map (juxt first second))\n        (into {})))))", "user": "57d418b4e4b0bd073c20239a"}, {"problem": 124, "code": "(fn [board color]\n  (let [X (count board)\n        Y (count (board 0))]\n    (into {}\n      (for [i (range X)\n            j (range Y)\n            :when (= (get-in board [i j]) 'e)\n            :let [move\n                  (for [x [-1 0 1]\n                        y [-1 0 1]\n                        :when (not (= 0 x y))\n                        :let [move\n                              (->> (iterate #(map + [x y] %) [i j])\n                                rest\n                                (take-while (fn [[x y]] (and (<= 0 x (dec X)) (<= 0 y (dec Y)))))\n                                (map (juxt #(get-in board %) identity))\n                                (partition-by first))]\n                        :when (let [[[[x0] ] [[x1]]] move]\n                                (and (not= x0 'e)\n                                     (not= x0 color)\n                                     (= x1 color)))]\n                    (->> move first (map second)))]\n            :when (seq move)]\n        [[i j] (->> move (apply concat) set)]))))", "user": "50479524e4b0371827a27bc4"}, {"problem": 124, "code": "(fn reversi [b c]\n  (let [neighbors [[1 -1] [0 1] [1 0] [1 1]\n                   [-1 1] [0 -1] [-1 0] [-1 -1]]\n        opp (fn [c] (if (= c 'w) 'b 'w))\n        oob? (fn [[x y]] (or (< x 0) (< y 0) (> y 3) (> x 3)))]\n    (into {}\n          (filter (comp not nil?)\n                  (for [x (range 0 4)\n                        y (range 0 4)\n                        :when (= c (get-in b [x y]))\n                        n neighbors]\n                    (when (= (opp c) (get-in b (map + [x y] n)))\n                      (loop [d [x y]\n                             p []]\n                        (if (oob? d)\n                          nil (if (= 'e (get-in b d))\n                                {d (into (sorted-set) (vec (drop-last p)))} (recur (map + d n) (conj p (mapv + d n))))))))))))", "user": "53fe1b42e4b0de5c418485f1"}, {"problem": 124, "code": "(fn [board that]\n  (let [ways (for [x [-1 0 1] y [-1 0 1] :when (not= 0 x y)] [x y])\n        next-seq #(rest (iterate (partial map + %2) %1))\n        [that? other?] (map #(fn [coor] (or (= %1 (get-in board coor)) nil))\n                            [that ({'w 'b 'b 'w} that)])\n        path #(let [[os [t]] (split-with other? %1)]\n                (and (that? t) (seq os)))]\n    (into {} (for [x (range 4) y (range 4)\n                   :let [xy [x y]] :when (= 'e (get-in board xy))\n                   :let [s (set (mapcat #(path (next-seq xy %)) ways))] :when (seq s)]\n               [xy s]))))", "user": "567d132ee4b05957ce8c61c3"}, {"problem": 124, "code": "(fn [board player]\n  (let [to-indexed #(into {} (map-indexed vector %))\n        board (to-indexed (map to-indexed board))\n        other ('{w b b w} player)\n        dim (range 4)\n        mt-locs (for [i dim j dim :when (= ((board i) j) 'e)] [i j])\n        vecs (for [i [-1 0 1] j [-1 0 1] :when (not= 0 i j)] [i j])\n        flip-vec (fn [[r c] [i j]]\n                   (loop [r (+ r i), c (+ c j), acc nil]\n                     (condp = (get-in board [r c])\n                       nil nil, 'e nil\n                       player acc\n                       other (recur (+ r i) (+ c j) (cons [r c] acc)))))\n        flipped-at (fn [loc] (mapcat #(flip-vec loc %) vecs))\n        all-moves (map #(vector % (set (flipped-at %))) mt-locs)]\n    (into {} (filter #(seq (second %)) all-moves))))", "user": "52b02329e4b0c58976d9acc5"}, {"problem": 124, "code": "(fn reversi-moves [board color]\n  (let [directions (for [row [-1 0 1] \n                         col (if (= row 0) [-1 1] [-1 0 1])] \n                     [row col])\n        square-to-piece-map (into {} (for [row (range 4) \n                                           col (range 4)] \n                                       [[row col] (get-in board [row col])]))\n        empty-squares (map key (filter #(= 'e (val %)) square-to-piece-map))]\n    (letfn [(path-to-edge [square direction] \n              (take-while square-to-piece-map (rest (iterate #(map + % direction) square))))\n            (squares-flipped [path]\n              (let [opposite '{b w, w b}\n                    path-pieces (apply str (map square-to-piece-map path))\n                    flip-pattern (re-pattern (str (opposite color) \"+\" color))]\n                (when (re-seq flip-pattern path-pieces)\n                  (take-while #(not= color (square-to-piece-map %)) path))))\n            (play [square] \n              (set (apply concat (keep squares-flipped (map #(path-to-edge square %) directions)))))]\n      (into {} (for [square empty-squares\n                     :let [flips (play square)]\n                     :when (not-empty flips)] \n                 [square flips])))))", "user": "58ed713de4b056aecfd47d84"}, {"problem": 124, "code": "(fn reversi [board p]\n  (let [o '{b w w b}\n        d (for [y [-1 0 1] x (if (= 0 y) [-1 1] [-1 0 1])] [y x])\n        b (into {} (for [y (range 4) x (range 4)] [[y x] (get-in board [y x])]))\n        e (map key (filter #(= 'e (val %)) b))\n        wk (fn [st off] (take-while b (rest (iterate #(map + % off) st))))\n        vl (fn [pth] (let [s (apply str (map b pth)) r (re-pattern (str (o p) \"+\" p))]\n                       (if (re-seq r s) (take-while #(not= p (b %)) pth))))\n        mv (fn [st] (set (apply concat (keep vl (map #(wk st %) d)))))]\n    (into {} (for [st e :let [mvs (mv st)] :when (not-empty mvs)] [st mvs]))))", "user": "53dbca12e4b094d41abdfef6"}, {"problem": 124, "code": "(fn [board color]\n\t(let [get-color (fn [p] (nth (nth board (first p)) (second p)))\n\t\t  point-arr (set (for [x (range 4) y (range 4)] [x y]))\n\t\t  empty-points (filter #(= 'e (get-color %)) point-arr)\n\t\t  up \t(fn [p] (if (and (not= nil p) (contains? point-arr [(dec (first p)) (second p)]))  [(dec (first p)) (second p)] nil))\n\t\t  left\t(fn [p] (if (and (not= nil p) (contains? point-arr [(first p) (dec (second p))]))  [(first p) (dec (second p))] nil))\n\t\t  right (fn [p] (if (and (not= nil p) (contains? point-arr [(first p) (inc (second p))]))  [(first p) (inc (second p))] nil))\n\t\t  down \t(fn [p] (if (and (not= nil p) (contains? point-arr [(inc (first p)) (second p)]))  [(inc (first p)) (second p)] nil))\n\t\t  up-left \t (comp up left)\n\t\t  down-left  (comp down left)\n\t\t  up-right\t (comp up right)\n\t\t  down-right (comp down right)\n\t\t  move (fn [point  arr move-func] \n\t\t\t\t(let [point (move-func point)]\n\t\t\t\t\t(cond \n\t\t\t\t\t  \t  (or (nil? point) (= 'e (get-color point))) #{}\n\t\t\t\t\t  \t  (= color (get-color point)) arr \n\t\t\t\t\t  \t  :else (recur point (conj arr point) move-func))))]\n\t\t(into {} (remove #(empty? (second %)) (map #(vector % (set (concat (move % #{} left) \n\t\t\t\t\t\t\t\t\t (move % #{} right) \n\t\t\t\t\t\t\t\t\t (move % #{} up) \n\t\t\t\t\t\t\t\t\t (move % #{} down)\n\t\t\t\t\t\t\t\t\t (move % #{} up-left)\n\t\t\t\t\t\t\t\t\t (move % #{} up-right)\n\t\t\t\t\t\t\t\t\t (move % #{} down-left)\n\t\t\t\t\t\t\t\t\t (move % #{} down-right)))) empty-points)))))", "user": "577c3da9e4b0c8d87281f6b9"}, {"problem": 124, "code": "(fn reversi [board counter]\n   (let [all-coords (for [i (range 4)\n                          j (range 4)]\n                      [i j])\n         coord-type (fn [[x y]]\n                      (nth (nth board x) y))\n         opposite-counter (if (= counter 'b)\n                            'w\n                            'b)\n         opposite-counters-coord (filter #(= opposite-counter (coord-type %)) all-coords)\n         get-row-coords (fn [[x y]]\n                          (nth (partition 4 all-coords) x))\n         get-column-coords (fn [[x y]]\n                             (case y\n                               0 (list [0 0] [1 0] [2 0] [3 0])\n                               1 (list [0 1] [1 1] [2 1] [3 1])\n                               2 (list [0 2] [1 2] [2 2] [3 2])\n                               3 (list [0 3] [1 3] [2 3] [3 3])))\n         get-diagonal-coords (fn [[x y]]\n                               (remove #(>= 2 (count %)) \n                                       (distinct (concat\n                                                   [(sort-by #(first %) (distinct (concat\n                                                                                    (take-while #(and (< -1 (first %) 4)\n                                                                                                      (< -1 (second %) 4)) (iterate #(vector (inc (first %)) (inc (second %))) [x y]))\n                                                                                    (take-while #(and (< -1 (first %) 4)\n                                                                                                      (< -1 (second %) 4)) (iterate #(vector (dec (first %)) (dec (second %))) [x y])))))]\n                                                   [(sort-by #(first %) (distinct (concat\n                                                                                    (take-while #(and (< -1 (first %) 4)\n                                                                                                      (< -1 (second %) 4)) (iterate #(vector (inc (first %)) (dec (second %))) [x y]))\n                                                                                    (take-while #(and (< -1 (first %) 4)\n                                                                                                      (< -1 (second %) 4)) (iterate #(vector (dec (first %)) (inc (second %))) [x y])))))]))))\n         row-column-diag-coord (fn [[x y]]\n                                 (concat (list (get-row-coords [x y]) (get-column-coords [x y]))\n                                         (get-diagonal-coords [x y])))\n         rcd-coord-opp-c (map #(row-column-diag-coord %) opposite-counters-coord)\n         get-subvectors (fn [v]\n                          (if (= 3 (count v))\n                            (list v)\n                            (list (take 3 v) (rest v))))\n         suitable-vector? (fn [w]\n                            (if (some \n                                  true? \n                                  (concat\n                                    (for [x (get-subvectors w)]\n                                      (or (= (map #(coord-type %) x) (list 'e opposite-counter counter))\n                                          (= (map #(coord-type %) x)  (list counter opposite-counter 'e))))\n                                    (list (= (map #(coord-type %)w) (list 'e opposite-counter opposite-counter counter))\n                                          (= (map #(coord-type %)w) (list counter opposite-counter opposite-counter 'e)))))\n                              true\n                              false))\n         neighbour? (fn [[x1 y1] [x2 y2]]\n                      (if (and (or (= 0 (- (max x1 x2) (min x1 x2)))\n                                   (= 1 (- (max x1 x2) (min x1 x2))))\n                               (or (= 0 (- (max y1 y2) (min y1 y2)))\n                                   (= 1 (- (max y1 y2) (min y1 y2)))))\n                        true\n                        false))                    \n         map-with-lines \n          (loop [acc {}\n                 opp-counter-num 0\n                 line-of-opp-counter 0]\n            (if (= (count rcd-coord-opp-c) opp-counter-num)\n              acc\n              (if (= (count (nth rcd-coord-opp-c opp-counter-num)) line-of-opp-counter)\n                (recur acc (inc opp-counter-num) 0)\n                (recur (conj \n                         acc \n                         {(if (suitable-vector? (nth (nth rcd-coord-opp-c opp-counter-num) line-of-opp-counter))\n                            (first (filter \n                                     (fn [d]\n                                       (and (= 'e (coord-type d))\n                                            (or (neighbour? \n                                                  d \n                                                  (first (filter #(= opposite-counter (coord-type %)) \n                                                                 (nth (nth rcd-coord-opp-c opp-counter-num) line-of-opp-counter))))\n                                                (neighbour? d \n                                                            (last (filter #(= opposite-counter (coord-type %)) \n                                                                          (nth (nth rcd-coord-opp-c opp-counter-num) line-of-opp-counter)))))))\n                                     (nth (nth rcd-coord-opp-c opp-counter-num) line-of-opp-counter))))\n                          (if (suitable-vector? \n                                (nth (nth rcd-coord-opp-c opp-counter-num) line-of-opp-counter))\n                            (into #{}\n                                  (filter #(= opposite-counter (coord-type %)) \n                                          (nth (nth rcd-coord-opp-c opp-counter-num) line-of-opp-counter)))\n                            'delete)})\n                       opp-counter-num\n                       (inc line-of-opp-counter)))))]\n     \n(dissoc map-with-lines nil)))", "user": "58dcb8cde4b0a4d5acaab6a7"}, {"problem": 124, "code": "(fn reversi [board color]\n  (let [coords (for [x (range (count board))\n                     y (range (count board))] [x y])\n        empty-coords (filter #(= 'e (get-in board %)) coords)\n        dirs (for [x [-1 0 1]\n                   y [-1 0 1]\n                   :when (not (and (= x 0) (= y 0)))]\n               [x y])]\n    (letfn [(flip [curr-loc dir results]\n              (let [next-loc (mapv + curr-loc dir)\n                    next-col (get-in board next-loc)]\n                (cond (= color next-col) results\n                      (= next-col 'e) #{}\n                      (nil? next-col) #{}\n                      :else (recur next-loc dir (conj results next-loc)))))\n            (flip-all [start-loc]\n              (reduce (fn [result item]\n                        (into result (flip start-loc item #{}))) #{} dirs))]\n      (reduce (fn [m k]\n                (let [vals (flip-all k)]\n                  (if (empty? vals) m\n                      (assoc-in m [k] (flip-all k))))) {} empty-coords)\n      )\n    )\n  )", "user": "589037b4e4b00487982d51d0"}, {"problem": 124, "code": "(letfn\n      [(n [[j i]] [(dec j) i])\n       (s [[j i]] [(inc j) i])\n       (e [[j i]] [j (inc i)])\n       (w [[j i]] [j (dec i)])\n       (ne [ji] (-> ji n e))\n       (nw [ji] (-> ji n w))\n       (se [ji] (-> ji s e))\n       (sw [ji] (-> ji s w))\n       (valid-pos? [[j i]] (and (<= 0 j 3) (<= 0 i 3)))\n       (path-coords [piece dir]\n         (take-while valid-pos? (drop 1 (iterate dir piece))))\n       (inverse-color [c] ({'b 'w 'w 'b} c))\n       (extract-move [board path-coords color]\n         (let [c' (inverse-color color)\n               path-pieces (map #(get-in board %) path-coords)\n               ncap (count (take-while #{c'} path-pieces))\n               landed (first (drop ncap path-pieces))]\n           (if (and (pos? ncap) (= 'e landed))\n             [(first (drop ncap path-coords)) (set (take ncap path-coords))])))\n       (pieces [board color]\n         (for [j (range (count board))\n               i (range (count (first board)))\n               :when (= color (get-in board [j i]))\n               ] [j i]))\n       (trace-path [board color piece dir]\n         (extract-move board (path-coords piece dir) color))\n       (paths [board color [j i :as piece]]\n         (for [dir [n ne e se s sw w nw]\n               :let [p (trace-path board color piece dir)]\n               :when (identity p)]\n           p))]\n      (fn moves [board color]\n        (into {} (mapcat #(paths board color %) (pieces board color)))))", "user": "58ec1e63e4b056aecfd47d54"}, {"problem": 124, "code": "(fn [s c]\n    (->> (for [t (range 4) k (range 4)]\n           (cons [t k] (filter (complement nil?) (for [i [-1 0 1] j [-1 0 1] :when (not= 0 i j)]\n                                                   (let [rc ({'w 'b 'b 'w} c)]\n                                                     (loop [[x y] [t k] r []]\n                                                       (if (and (<= 0 x 3) (<= 0 y 3))\n                                                         (recur [(+ x i) (+ y j)] (conj r (get-in s [x y])))\n                                                         (cond (= (take 3 r) ['e rc c]) #{[(+ t i) (+ k j)]}\n                                                               (= r ['e rc rc c]) #{[(+ t i) (+ k j)]\n                                                                                    [(+ t (* 2 i)) (+ k (* 2 j))]})\n                                                         )\n                                                       )\n                                                     )))))\n         (filter #(> (count %) 1))\n         (reduce #(conj %1 (vec %2)) {})\n         )\n\n    )", "user": "5921a080e4b09b4ee5954c77"}, {"problem": 124, "code": "(fn [board me]\n  (let [other (if (= me 'b) 'w 'b)\n        flips (fn [rc-coll] (let [flips-others (->> (map #(get-in board % 'e) rc-coll)\n                                                    (split-with #{other} ))]\n                              (if (= [other me] (map first flips-others))\n                                (take (count (first flips-others)) rc-coll))))]\n    (->> (for [[r row] (map-indexed vector board)\n               [c val] (map-indexed vector row)\n               x [0 1 -1] y [0 1 -1]\n               :when (= val 'e)]\n           (->> (iterate #(map + [x y] %) [r c])\n                rest\n                flips\n                set       \n                (vector [r c])))\n         (filter (comp seq second))\n         (into {}))))", "user": "56102f50e4b05f002753df6b"}, {"problem": 124, "code": "(fn reversi [board color]\n  (letfn [\n    (genDiagonals [c]\n      (map #(rest (take-while (fn [[i j]] (and (<= 0 i 3) (<= 0 j 3))) (iterate (partial mapv + %)  c))) [[1 1] [1 -1] [-1 1] [-1 -1]]))            \n    (getLines [[i j] board]\n        (concat\n          [(mapv #(get-in board [i %]) (range (inc j) 4))]\n          [(mapv #(get-in board [i %]) (reverse (range 0 j)))]\n          [(mapv #(get-in board [% j]) (range (inc i) 4))]\n          [(mapv #(get-in board [% j]) (reverse (range 0 i)))]\n          (mapv #(mapv (partial get-in board) %) (genDiagonals [i j]))))\n    (analyzeSquare [board cc e]\n          (let [lines (getLines e board)\n                validLines (filter (fn [line] (and (= cc (ffirst line)) (some #(= color (first %)) line))) lines)]\n               (if (not (empty? validLines))\n                   [e (set (mapcat (fn [line] (map second (take-while #(= cc (first %)) line))) validLines))])))]    \n        \n      (let [cc (if (= color 'w) 'b 'w)\n            board (reduce (fn [b c] (update-in b c (fn [x] [x c]))) board (for [i (range 4) j (range 4)] [i j]))\n            empties (map second (filter #(= 'e (first %)) (apply concat board)))]\n          \n            (into {} (keep (partial analyzeSquare board cc) empties)))))", "user": "5958cef6e4b066ee0a44af94"}, {"problem": 124, "code": "(fn [b p] ( \n             letfn [\n                    (vxy[v] (and (>= (v 0) 0) (>= (v 1) 0) (< (v 0) (count b)) (< (v 1) (count (first b)))))\n                    (gt[v] ((b (v 0)) (v 1)))\n                    (opp[p] ( if (= p 'w) 'b 'w))\n                    (vs[v1 v2] (conj [(+ (v1 0) (v2 0))] (+ (v1 1) (v2 1)) ))\n                    (valid[v dir p c](\n                                     if (vxy v)\n                                     (#( cond \n                                         (and (= % p) (> (count c) 0))  c\n                                         (= % (opp p)) (valid (vs v dir) dir p (conj c v))\n                                         :e #{}\n                                        ) (gt v))\n                                     #{}\n                                     ))\n                    (tst[v](\n                             if (= (gt v) 'e)\n                             (apply clojure.set/union (map #(valid (vs v %) % p #{}) [[-1 -1] [-1 0] [-1 1] [0 1] [1 1] [1 0] [1 -1] [0 -1]]))\n                             #{}\n                             ))\n                    ]\n\n          (reduce (fn[a1 a2] (\n                               #(if-not (empty? %)\n                                        (conj a1 {a2 %})\n                                        a1\n                                        ) (tst a2)\n                               )) {}\n          (apply concat (map-indexed (fn[y sy] ( map-indexed (fn [x sx] (\n                                                            identity [y x]\n                                                            )) sy)) b)))\n          \n\n             ))", "user": "596f6683e4b069c0a1a19877"}, {"problem": 124, "code": "(fn moves\n  [board player]\n  (let [n (count board)\n        dirs (for [x [-1 0 1] y [-1 0 1] :when (not (= 0 x y))] [x y])\n        move-1 (fn [[dx dy] [x y]] [(+ x dx) (+ y dy)])\n        in? (fn [[x y]] (and (< -1 x n) (< -1 y n)))\n        opposite? (fn [cell] (= player ({'w 'b 'b 'w} (get-in board cell) 'e)))\n        rows (fn [cell] (map (fn [d]\n                               (take-while in? (next (iterate (partial move-1 d) cell))))\n                             dirs))\n        flip (fn [cell]\n               (mapcat\n                (fn [row]\n                  (when (opposite? (first row))\n                    (let [[a b] (partition-by (partial get-in board) row)]\n                      (when (= player (get-in board (first b)))\n                        a))))\n                (rows cell)))]\n    (into {}\n          (for [x (range n) y (range n)\n                :when (= 'e (get-in board [x y]))\n                :let [flips (flip [x y])]\n                :when (seq flips)\n                ]\n            [[x y] (into #{} flips)]))))", "user": "4f1ef6a0535d64f60314649b"}, {"problem": 124, "code": "; Evil hack\n(fn [& _]\n  (reify nil\n    clojure.lang.IPersistentCollection\n    (seq [_])\n    (cons [_ _])\n    (empty [_])\n    (equiv [_ _] true)))", "user": "51e58e02e4b0efabf93c02d0"}, {"problem": 124, "code": "(let [\n      get-diags \n        (fn [matrix]\n          (let [size (count matrix)\n                first-half \n                  (map #(take (inc %) (iterate (fn [pos] [(dec (first pos)) (inc (last pos))]) [% 0])) (range size))\n                second-half (map #(map (fn [pos] [(- (dec size) (first pos)) (- (dec size) (last pos))]) (reverse %)) (butlast first-half))\n          ]\n            (concat first-half (reverse second-half))\n          )\n        )\n      get-rev-diags \n        (fn get-rev-diags [matrix]\n          (let [size (count matrix)]\n            (for [diag (get-diags matrix)]\n              (reverse (map (fn [pos] [(first pos) (- (dec size) (last pos))]) diag))\n            )\n          )\n        )\n      get-rows\n        (fn get-rows [matrix]\n          (for [i (-> matrix count range)]\n            (map (fn [j] [i j]) (-> matrix first count range))\n          )\n        )\n      get-cols\n        (fn get-cols [matrix]\n          (apply map vector (get-rows matrix))\n        )\n      check-line\n        (fn [line player]\n          (let [enemy (if (= 'w player) 'b 'w)\n                line (vec line)]\n            (loop [start nil i 0 results []]\n              (let [item (get line i nil)]\n                (cond\n                  (nil? item) results\n                  (= item player) (recur i (inc i) results)\n                  (and (not= nil start) (= item enemy)) (recur start (inc i) results)\n                  (and (not= nil start) (= item 'e)) \n                    (if (> (- i start) 1)\n                      (recur nil (inc i) (vec (conj results [start i])))\n                      (recur nil (inc i) results)\n                    )\n                  :else\n                    (recur nil (inc i) results)\n                )\n              )\n            )\n          )\n        )\n      check-line2\n        (fn [line player]\n          (let [max-index (-> line count dec)]\n            (map (fn [p] [(- max-index (first p)) (- max-index (last p))]) (check-line (reverse line) player))\n          )\n        )\n      check-line-both\n        (fn [line player]\n          (concat (check-line line player) (check-line2 line player))\n        )\n      ]\n    \n    \n  (fn reversi [board player]\n    (let [lines (concat (get-rows board) (get-cols board) (get-diags board) (get-rev-diags board))\n          lines (filter #(>= (count %) 3) lines)]\n        \n      (apply merge-with clojure.set/union\n        (for [line lines\n              :let [line (vec line)\n                    line-values (map #(get-in board %) line)\n                    line-range (first (check-line-both line-values player))]\n              :when (not (nil? line-range))\n             ]\n          \n          (if (> (first line-range) (last line-range))\n            {(get line (last line-range)) (set (subvec line (-> line-range last inc) (first line-range)))}\n            {(get line (last line-range)) (set (subvec line (-> line-range first inc) (last line-range)))}\n          )\n        )\n      )\n    )\n  )    \n)", "user": "5991d2fae4b0866487ed0d68"}, {"problem": 124, "code": "(fn [board player]\n  (let [directions (for [i [-1 0 1] j [-1 0 1] :when (not= [i j] [0 0])] [i j])\n        empty-positions (for [i (range 4) j (range 4) :when (= 'e (get-in board [i j]))] [i j])\n        opponent (if (= player 'b) 'w 'b)\n        flipped-for (fn [pos dir]\n                       (loop [pos (mapv + pos dir), flipped []]\n                         (condp = (get-in board pos)\n                           opponent (recur (mapv + pos dir) (conj flipped pos))\n                           player flipped\n                           [])))]\n\n     (reduce (fn [legal-moves pos]\n                (let [flipped (reduce #(concat %1 (flipped-for pos %2)) [] directions)]\n                   (if (not-empty flipped)\n                      (assoc legal-moves pos (set flipped))\n                      legal-moves)))\n             {}\n             empty-positions)))", "user": "58b51e05e4b0ebc645576d4c"}, {"problem": 124, "code": "(fn reversi [board p]\n  (let [o '{b w w b}\n        d (for [y [-1 0 1] x (if (= 0 y) [-1 1] [-1 0 1])] [y x])\n        b (into {} (for [y (range 4) x (range 4)] [[y x] (get-in board [y x])]))\n        e (map key (filter #(= 'e (val %)) b))\n        wk (fn [st off] (take-while b (rest (iterate #(map + % off) st))))\n        vl (fn [pth] (let [s (apply str (map b pth)) r (re-pattern (str (o p) \"+\" p))]\n                       (if (re-seq r s) (take-while #(not= p (b %)) pth))))\n        mv (fn [st] (set (apply concat (keep vl (map #(wk st %) d)))))]\n    (into {} (for [st e :let [mvs (mv st)] :when (not-empty mvs)] [st mvs]))))", "user": "59358f74e4b04f87174def52"}, {"problem": 124, "code": "(fn valid-moves[board player]\n    (letfn [\n        (get-opponent [player] (if (= player 'w) 'b 'w))\n        (on-board?[size [x y]] (and (>= x 0) (< x size) (>= y 0) (< y size)))\n        (is-valid?[board size player pos dir]\n            (let [series (take-while #(on-board? size %) (iterate (partial #(map + %1 %2) dir) pos))\n                  op-series (take-while #(= (get-opponent player) (get-in board %)) (rest series))\n                  next-pos (map + (last op-series) dir)]\n                (if (and (> (count op-series) 0) (on-board? size next-pos) (= player (get-in board next-pos)))\n                [pos (set op-series)]\n                )\n            )\n        )\n    ]\n        (let [size (count board)\n              dirs [[-1 -1] [-1 0] [-1 1] [0 -1] [0 1] [1 -1] [1 0] [1 1]]\n              empty_pos (for [x (range size) y (range size) :when (= 'e (get-in board [x y]))] [x y])]\n            (reduce (fn [moves pos] (into moves (remove nil? (map (partial is-valid? board size player pos) dirs)))) {} empty_pos)\n        )\n    )\n)", "user": "59a0262ee4b0871e7608b82d"}, {"problem": 124, "code": "(fn reversi [board color]\n  (let [dirs '((-1 -1) (-1 0) (-1 1) (0 -1) (0 1) (1 -1) (1 0) (1 1))\n        opp (fn [c]\n              (cond\n                (= c 'w) 'b\n                (= c 'b) 'w))\n        flip (fn [x]\n               (letfn [(flip-dir [v]\n                          (loop [y (map + x v)\n                                 ret #{}]\n                            (let [c (get-in board y)]\n                              (cond\n                                (= c color) ret\n                                (= c (opp color)) (recur\n                                                    (map + y v)\n                                                    (conj ret y))\n                                :else nil))))]\n                 (apply clojure.set/union (map flip-dir dirs))))]\n    (loop [i 0\n           ret {}]\n      (if (= i 16)\n        ret\n        (let [x (vector (quot i 4) (mod i 4))\n              c (get-in board x)\n              s (flip x)]\n          (if (and (= c 'e) (not (empty? s)))\n              (recur (inc i) (assoc ret x s))\n              (recur (inc i) ret))\n        )))))", "user": "55f73078e4b06e875b46cea4"}, {"problem": 124, "code": "(fn [board p] \n          (let [\n                get-cands-for-reverse (fn [cs] (if (and (not (nil? cs)) (empty? cs) ) cs ))\n                find-moves (fn find-smer [board my-color rev-pool actual-position smer ] \n                             (let [[x y]                    smer\n                                   [dx dy]                  actual-position\n                                   [nx ny :as new-position] [ (+ x dx) (+ y dy) ]\n                                   aval                     (get-in board new-position)\n                                   op-color                 (if (= my-color 'w) 'b 'w)\n                                   ]\n                               (if (or (> nx 3) (< nx 0) (> ny 3) (< ny 0) (= aval 'e))\n                                 nil\n                                 (condp = aval\n                                   my-color rev-pool \n                                   op-color (find-smer board my-color (conj rev-pool new-position) new-position smer ))))) ]\n\n            (reduce\n              (fn [acc [x y aval]]\n                (let [cx  (filter #(and (not (nil? %)) (not (empty? %)) ) \n                                  (map \n                                    (fn [[dirx diry]] \n                                         (find-moves board p #{} [x y] [dirx diry])) \n                                    [[1 0][1 -1] [0 1] [-1 -1] [-1 0] [-1 1] [0 -1] [1 1]] ))]\n                  (if (or (nil? cx) (empty? cx))\n                    acc \n                    (assoc acc [x y] (first cx)))))\n              {}\n              (filter (fn [[x y aval]] (= aval 'e))\n                      (map \n                       (fn [idxs] (let [[x y] idxs] [x y (get-in board idxs)]) )\n                        (mapcat (fn [x] (map (fn [y] [x y]) (range 0 4))) (range 0 4)))))))", "user": "533c2605e4b0e30313ee6cd7"}, {"problem": 124, "code": "(fn sol [xss p]\n   (letfn [\n         (csets [v p ri ci fr fc]\n    (loop [res #{}\n           cv v\n           rr ri\n           cc ci]\n       (cond (empty? cv) #{}\n             (= (first cv) 'e) #{}\n             (= (first cv) p ) res\n             :else (recur (conj res [rr cc]) (rest cv) (fr rr) (fc cc))\n      )\n   )\n)\n\n(vsets1 [ r c p xss] ;rechts\n          (let [v (subvec (xss r) (inc c))]\n\n              (csets v p r (inc c) identity inc)\n         )\n)\n\n(vsets2 [r c p xss] ;links\n     (let [v (reverse (subvec (xss r) 0 c))]\n        (csets v p r (dec c) identity dec)\n     )\n)\n\n(vsets3 [r c p xss] ;up\n     (let [v (vec (for [rr (reverse (range r)) ]\n                           ((xss rr) c )\n             )     ) ]\n       (csets v p (dec r) c dec identity)\n    )\n)\n  \n    (vsets4 [r c p xss] ; down\n     (let [v (vec (for [rr (range (inc r) (count xss))]\n                           ((xss rr) c )\n             )     ) ]\n        (csets v p (inc r) c inc identity)\n     )\n)\n\n(vsets5 [r c p xss] ; up right\n     (let [v (vec (for [rr (reverse (range r))\n                        cc (range (inc c) (count (xss 0)))\n                        :when (= (+ rr cc) (+ r c))]\n                           ((xss rr) cc )\n             )     ) ]\n       (csets v p (dec r) (inc c) dec inc)\n     )\n)\n\n(vsets6 [r c p xss] ; down left\n     (let [v (vec (for [rr (range (inc r) (count xss))\n                        cc (reverse (range c))\n                        :when (= (+ rr cc) (+ r c))]\n                           ((xss rr) cc )\n             )     ) ]\n       (csets v p (inc r) (dec c) inc dec)\n    )\n)\n       (vsets7 [r c p xss] ; up left\n     (let [v (vec (for [rr (reverse (range r))\n                        cc (reverse (range c))\n                        :when (= (- rr cc) (- r c))]\n                           ((xss rr) cc )\n             )     ) ]\n       (csets v p (dec r) (dec c) dec dec)\n    )\n)\n\n(vsets8 [r c p xss] ; down right\n     (let [v (vec (for [rr (range (inc r) (count xss))\n                        cc (range (inc c) (count (xss 0)))\n                        :when (= (- rr cc) (- r c))]\n                           ((xss rr) cc )\n             )     ) ]\n       (csets v p (inc r) (inc c) inc inc)\n     )\n)\n (vsets [r c p xss]\n   (clojure.set/union\n        (vsets1  r c p xss )\n        (vsets2  r c p xss )\n        (vsets3  r c p xss )\n        (vsets4  r c p xss )\n        (vsets5  r c p xss )\n        (vsets6  r c p xss )\n        (vsets7  r c p xss )\n        (vsets8  r c p xss )\n  )\n)\n\n(alls [xss p]\n;  (into {}\n     (for [r (range (count xss))\n           c (range (count (xss 0)))\n           :when (= ((xss r) c) 'e)\n           ]\n          [[r c] (vsets r c p xss)]\n    )\n;  )\n)\n     \n           ]\n  \n   (into {}\n          (filter #(> (count (second %)) 0) (alls xss p))\n    )\n  )\n)", "user": "59ff9424e4b01bb0ae8afd24"}, {"problem": 124, "code": "(fn [board color]\n    (let [other ({'b 'w 'w 'b} color)]\n      (into\n        {}\n        (filter\n          #(seq (second %))\n          (for [r (range 4) c (range 4)]\n            (if (= (get-in board [r c]) 'e)\n              [[r c]\n               (set\n                 (apply\n                   concat\n                   (for [[y x] [[-1 -1] [-1 0] [-1 1] [0 -1]\n                                [0 1] [1 -1] [1 0] [1 1]]]\n                     (loop [[a b] [(+ r y) (+ c x)] result []]\n                       (if\n                         (and (< -1 a 4) (< -1 b 4))\n                         (cond\n                           (= (get-in board [a b]) color)\n                           result\n                           (= (get-in board [a b]) other)\n                           (recur [(+ a y) (+ b x)] (conj result [a b])))\n                         nil)))))]))))))", "user": "5a2df4a0e4b09cafd31c7f74"}, {"problem": 124, "code": "(fn [board hero]\n  (let [empty 'e\n        vilian ({'w 'b, 'b 'w} hero)\n        get-loc (fn [color]\n                  (->> board\n                       (map (partial keep-indexed #(if (= color %2) %1)))\n                       (keep-indexed #(map (partial conj [%1]) %2))\n                       (apply concat)))\n        find-loc #(get-in board % 'z)\n        move (fn [direction [y x]]\n               ([[(inc y) x]\n                 [(inc y) (inc x)]\n                 [y (inc x)]\n                 [(dec y) (inc x)]\n                 [(dec y) x]\n                 [(dec y) (dec x)]\n                 [y (dec x)]\n                 [(inc y) (dec x)]] direction))\n        union (fnil (partial reduce conj) #{})\n        update (fn [m k f x] (assoc m k (f (get m k) x)))]\n    (reduce\n     #(reduce\n       (partial (fn [current tmp result direction]\n                  (let [next (move direction current)]\n                    (condp = (find-loc current)\n                      hero (recur next tmp result direction)\n                      vilian (recur next (conj tmp current) result direction)\n                      empty (if (empty? tmp)\n                              result\n                              (update result current union tmp))\n                      result)))\n                %2 #{})\n       %1 (range 8))\n     {} (get-loc hero))))", "user": "54c5cc17e4b045293a27f624"}, {"problem": 124, "code": "(fn [board color]\n  (let [size       4\n        opposite   (if (= color 'w) 'b 'w)\n        get-color  (fn [p] (get-in board p))\n        positions  (for [x (range size) y (range size)] [x y])\n        directions (filter #(not= % [0 0]) (for [x [-1 0 1] y [-1 0 1]] [x y]))\n        transpose  (fn [[x y] [dx dy]] [(+ x dx) (+ y dy)])\n        on-board?  (fn [[x y]] (and (>= x 0) (< x size) (>= y 0) (< y size)))\n        to-ray     (fn [p d] (->> p\n                                  (iterate #(transpose % d))\n                                  (rest)\n                                  (take-while on-board?)))\n        rays       (fn [p] (map #(to-ray p %) directions))\n        ray-points (fn [r] (loop [[p & ps] r acc #{}]\n                             (cond\n                               (= (get-color p) opposite) (recur ps (conj acc p))\n                               (and (= (get-color p) 'e) (not (empty? acc))) [p acc])))]\n    (->> positions\n         (map (fn [p] [p (get-color p)]))\n         (filter (fn [[p c]] (= c color)))\n         (map (fn [[p c]] p))\n         (map (fn [p] (filter #(not (nil? %)) (map ray-points (rays p)))))\n         (apply concat)\n         (into {}))))", "user": "58f44c07e4b0438e51c2ceb7"}, {"problem": 124, "code": "(fn [field c]\n  (let [e-c ({'w 'b 'b 'w} c)\n        move (fn [p d] (mapv + p d))\n        get-dir (fn f [p d a] (let [p+ (move p d), r (get-in field p+)]\n                    (cond (= c r) a\n                          (= e-c r) (f p+ d (conj a p+))\n                          :else nil)))\n        get-all (fn [p] (let [r (mapcat #(get-dir p % nil) (for [i [-1 0 1] j [-1 0 1] :when (not= i j 0)] [i j]))]\n                             (if (empty? r) nil [p (into #{} r)])))]\n  (into {} (map get-all (for [i (range 4) j (range 4) :when (= 'e (get-in field [i j]))] [i j]))) ))", "user": "5a4de614e4b05d388ecb6bb1"}, {"problem": 124, "code": "(fn [b c]\n   (let [bsize (count b)      \n         dirs [[0 -1] [-1 0] [0 1] [1 0] [-1 -1] [-1 1] [1 1] [1 -1]]\n         in-b (fn [[i j]] (and (<= 0 i (dec bsize)) (<= 0 j (dec bsize))))\n         lines (fn [p] (map #(rest (take-while in-b (iterate (partial mapv + %) p))) dirs))\n         opp #(= ('{w b} c 'w) (get-in b %))\n         \n         move (fn [r] (if (= c (get-in b (first (drop-while opp r))))\n                         (take-while opp r)))\n         to-check (filter #(= 'e (get-in b (first %))) \n                     (for [i (range bsize) j (range bsize)]\n                           [[i j] (vec (remove #(< (count %) 2) (lines [i j])))] )) ] \n                           \n               (into {} (remove #(empty? (second %))\n                  (map #(vector (first %) \n                     (reduce (fn [a x] (if-let [legal (move x)] (into a legal) a)) #{} (second %))) to-check)))))", "user": "59f043d0e4b0966464fe6a3d"}, {"problem": 124, "code": "(letfn [(get-flips [board piece [y x]]\n         (->> ;; Make coordinate generators to find rows of the other color\n              (for [x+ (range -1 2)\n                    y+ (range -1 2)]\n                (iterate \n                 (fn [[y x]] [(+ y+ y) (+ x+ x)]) \n                 [y x]))\n              (map #(drop 1 %))\n              ;; Split on (pieces of other color, generator ready for next piece)\n              (map (fn [iter] \n                     (split-with (fn [coord] \n                                   (= ({'b 'w 'w 'b} piece) (get-in board coord)))\n                                 iter)))\n              ;; If the next coordinate from the generator is piece of this color, we can flip\n              (map (fn [[c iter]] (cons (= piece (get-in board (first (take 1 iter)))) c)))\n              (filter (fn [[bool flipped]] (and bool (pos? (count flipped)))))\n              ;; Return this coordinate, and the set of coordinates of flipped pieces\n              (map (fn [[_ & c]] (conj [[y x]] (set c))))))]\n  \n  (fn [board piece]\n    ;; Check all empty squares\n    (->> (for [y (range (count board))\n               x (range (count (first board)))\n               :when (= 'e (get-in board [y x]))]\n           [y x])\n         (mapcat #(get-flips board piece %))\n         (into {}))))", "user": "5ad63a34e4b0ea6055cfac01"}, {"problem": 124, "code": "(fn p124 [game-board color]\n  (let [current-board-state (zipmap (for [x (range 4)\n                                          y (range 4)] [x y])\n                                    (flatten game-board))\n        opposite {'b 'w, 'w 'b}\n        board-configs\n        [{:start [0 0] :end [0 3] :middle #{[0 1] [0 2]}}\n         {:start [0 0] :end [2 2] :middle #{[1 1]}}\n         {:start [0 0] :end [3 3] :middle #{[1 1] [2 2]}}\n         {:start [0 0] :end [3 0] :middle #{[1 0] [2 0]}}\n         {:start [0 0] :end [2 0] :middle #{[1 0]}}\n         {:start [0 0] :end [0 2] :middle #{[0 1]}}\n         {:start [0 1] :end [3 1] :middle #{[1 1] [2 1]}}\n         {:start [0 1] :end [2 1] :middle #{[1 1]}}\n         {:start [0 1] :end [2 3] :middle #{[1 2]}}\n         {:start [0 1] :end [0 3] :middle #{[0 2]}}\n         {:start [0 2] :end [2 0] :middle #{[1 1]}}\n         {:start [0 2] :end [3 2] :middle #{[1 2] [2 2]}}\n         {:start [0 2] :end [2 2] :middle #{[1 2]}}\n         {:start [0 2] :end [0 0] :middle #{[0 1]}}\n         {:start [0 3] :end [0 0] :middle #{[0 1] [0 2]}}\n         {:start [0 3] :end [0 1] :middle #{[0 2]}}\n         {:start [0 3] :end [2 1] :middle #{[1 2]}}\n         {:start [0 3] :end [3 0] :middle #{[2 1] [1 2]}}\n         {:start [0 3] :end [3 3] :middle #{[1 3] [2 3]}}\n         {:start [0 3] :end [2 3] :middle #{[1 3]}}\n         {:start [1 0] :end [1 2] :middle #{[1 1]}}\n         {:start [1 0] :end [1 3] :middle #{[1 1] [1 2]}}\n         {:start [1 0] :end [3 0] :middle #{[2 0]}}\n         {:start [1 0] :end [3 2] :middle #{[2 1]}}\n         {:start [1 3] :end [1 0] :middle #{[1 2] [1 1]}}\n         {:start [1 3] :end [1 1] :middle #{[1 2]}}\n         {:start [1 3] :end [3 1] :middle #{[2 2]}}\n         {:start [1 3] :end [3 3] :middle #{[2 3]}}\n         {:start [2 0] :end [2 2] :middle #{[2 1]}}\n         {:start [2 0] :end [2 3] :middle #{[2 1] [2 2]}}\n         {:start [2 0] :end [0 0] :middle #{[1 0]}}\n         {:start [2 0] :end [0 2] :middle #{[1 1]}}\n         {:start [2 3] :end [2 0] :middle #{[2 1] [2 2]}}\n         {:start [2 3] :end [2 1] :middle #{[2 2]}}\n         {:start [2 3] :end [0 1] :middle #{[1 2]}}\n         {:start [2 3] :end [0 3] :middle #{[1 3]}}\n         {:start [3 0] :end [0 0] :middle #{[1 0] [2 0]}}\n         {:start [3 0] :end [1 0] :middle #{[2 0]}}\n         {:start [3 0] :end [3 3] :middle #{[3 1] [3 2]}}\n         {:start [3 0] :end [3 2] :middle #{[3 1]}}\n         {:start [3 0] :end [1 2] :middle #{[2 1]}}\n         {:start [3 0] :end [0 3] :middle #{[2 1] [1 2]}}\n         {:start [3 1] :end [0 1] :middle #{[1 1] [2 1]}}\n         {:start [3 1] :end [1 1] :middle #{[2 1]}}\n         {:start [3 1] :end [1 3] :middle #{[2 2]}}\n         {:start [3 1] :end [3 3] :middle #{[3 2]}}\n         {:start [3 2] :end [1 2] :middle #{[2 2]}}\n         {:start [3 2] :end [0 2] :middle #{[1 2] [2 2]}}\n         {:start [3 2] :end [1 0] :middle #{[2 1]}}\n         {:start [3 2] :end [3 0] :middle #{[3 1]}}\n         {:start [3 3] :end [0 0] :middle #{[1 1] [2 2]}}\n         {:start [3 3] :end [1 1] :middle #{[2 2]}}\n         {:start [3 3] :end [0 3] :middle #{[1 3] [2 3]}}\n         {:start [3 3] :end [3 0] :middle #{[3 1] [3 2]}}\n         {:start [3 3] :end [3 1] :middle #{[3 2]}}\n         {:start [3 3] :end [1 3] :middle #{[2 3]}}]]\n    (letfn [(is-valid-move? [current-position end-line-position middle-positions color-to-use]\n      (when (and (= 'e (current-board-state current-position))\n                 (= color-to-use (current-board-state end-line-position))\n                 (= #{(opposite color-to-use)} (set (map #(current-board-state %) \n                                                     middle-positions))))\n        [current-position middle-positions]))]\n      (->> (filter #(is-valid-move? (:start %) \n                                    (:end %) \n                                    (:middle %) \n                                    color)\n                   board-configs)\n           (map (juxt :start :middle))\n           (apply concat)\n           (apply array-map)))))", "user": "525c575be4b0cb4875a45d38"}, {"problem": 124, "code": "(fn reversi [board player]\n  (letfn [(empty-places []\n            (for [[x row] (map-indexed vector board) \n                  [y val] (map-indexed vector row) \n                  :when (= 'e val)]\n              [x y]))\n          (next [[r c] [dir-r dir-c]] [(+ r dir-r) (+ c dir-c)])\n          (get-flips [pos dir flips]\n            (let [next-pos (next pos dir)]\n              (if-let [next-piece (get-in board next-pos)]\n                (condp = next-piece\n                  nil nil\n                  'e nil\n                  player flips\n                  (recur next-pos dir (conj flips next-pos)))\n              nil)))\n          (get-all-flips [pos]\n            (into #{}\n            (mapcat\n              #(get-flips pos % nil)\n              '[[-1 -1] [-1 0] [-1 1]\n                [ 0 -1]        [ 0 1] \n                [ 1 -1] [ 1 0] [ 1 1]])))]\n    (->> (empty-places)\n      (map (fn [pos] [pos (get-all-flips pos)]))\n      (filter #(> (count (last %)) 0))\n      (into {}))))", "user": "5aa998c6e4b0d174b936c8e5"}, {"problem": 124, "code": ";;(identity(\n(fn [field kind]\n  (let [\n        index\n        (fn [field]\n          (vec (map-indexed\n                (fn [x xs]\n                  (vec(map-indexed\n                       (fn [y p]\n                         {:c [x y]\n                          :p p})\n                       xs)))\n                field)))\n        permute\n        (fn [field]\n          (reduce concat\n                  ((juxt\n                    #(map reverse %)\n                    identity)\n                   (concat\n                    field\n                    (apply map vector field)\n                    (let [a (range 0 3)\n                          aa (reverse a)\n                          b (range 1 4)\n                          bb (reverse b)\n                          d (range 0 4)\n                          dd (reverse d)\n                          diag #(get-in\n                                 field\n                                 [%1 %2])]\n                      [(map diag a b)\n                       (map diag a aa)\n                       (map diag b a)\n                       (map diag b bb)\n                       (map diag d d)\n                       (map diag d dd)])))))\n        pred\n        (fn [op sq]\n          (fn [{:keys [p]}]\n            (op sq p)))\n        drop-op\n        (fn [op sq line]\n          (drop-while\n           (pred op sq)\n           line))\n        take-op\n        (fn [op sq line]\n          (take-while\n           (pred op sq)\n           line))\n        drop-ma ;mandatory\n        (fn [op sq [{:keys [p]} :as line]]\n          (when (op sq p)\n            (drop-op op sq line)))\n        not-eq\n        (comp not =)\n        drop-squares\n        (fn [owner]\n          (fn [line]\n            (let [start (->> line\n                             (drop-op not-eq owner)\n                             seq)\n                  before (->> start\n                              (drop-ma = owner))\n                  end (->> before\n                           (drop-ma not-eq 'e)\n                           first)\n                  mid (->> before\n                           (take-op not-eq owner)\n                           (take-op not-eq 'e)\n                           (map :c)\n                           set\n                           )]\n              (when end\n                [(:c end) mid])\n              )))\n        ]\n    #_(vec (permute field))\n\n    #_(vec (permute (index field)))\n\n    #_(get-in (index field) [2 1])\n\n    #_(drop-op\n       (comp not =) 'w '[w b e])\n\n\n    (->>\n     field\n     index\n     permute\n     (map (drop-squares kind))\n     (filter (comp not nil?))\n     (reduce concat)\n     (apply hash-map)\n     #_vec\n     )\n\n    #_(map\n       (drop-squares 'w)\n       (take 999 (permute\n                  (index field))))\n\n    #_(vec (take 1 (index field)))\n    #_(vec ((drop-squares 'b)\n            (first\n             (index '[[e b w e]]))))\n    ))\n;;          '[[e e e e]\n;;            [e w b e]\n;;            [w w w e]\n;;            [e e e e]]\n;;          'b\n;;          )", "user": "586a657de4b0f14aab7c88bd"}, {"problem": 124, "code": "(fn [s p]\n  (let [ae (fn [e]\n             (set\n               (for [x (range 4)\n                     y (range 4)\n                     :when (= e (get (get s x) y))]\n                    [x y])))\n        es (ae 'e)\n        ps (ae p)\n        as (ae (if (= p 'w) 'b 'w))]\n    (->>\n      (map\n        (fn [[x y]]\n          [[x y]\n           (->>\n            (mapcat\n              (fn [[a b]]\n                (cond\n                  (= a x)\n                  (for [i (range 1 (if (> y b) (- y b) (- b y)))]\n                    [x (if (> y b) (- y i) (+ y i))])\n                  (= b y)\n                  (for [i (range 1 (if (> x a) (- x a) (- a x)))]\n                    [(if (> x a) (- x i) (+ x i)) y])\n                  (= (- a x) (- b y))\n                  (for [i (range 1 (if (> x a) (- x a) (- a x)))]\n                    [(if (> x a) (- x i) (+ x i)) (if (> x a) (- y i) (+ y i))])\n                  (= (- a y) (- x b))\n                  (for [i (range 1 (if (> x a) (- x a) (- a x)))]\n                    [(if (> x a) (- x i) (+ x i)) (if (> x a) (+ y i) (- y i))])))\n              ps)\n            (set)\n            (clojure.set/intersection as))])\n        es)\n      (filter (fn [[_ t]] (not (empty? t))))\n      (into {}))))", "user": "5af907e6e4b0cc2b61a3bcda"}, {"problem": 124, "code": "(fn [b bw]\n (let [d [-1 0 1]\n       dir (for [i d j d :when (not= 0 i j)] [i j])\n       r (range 4)]\n  (letfn [(check [m n dm dn rs]\n           (cond\n            (or (neg? m) (neg? n) (< 3 m) (< 3 n) (= 'e ((b m) n))) nil\n            (= bw ((b m) n)) rs\n            :else (check (+ dm m) (+ dn n) dm dn (conj rs [m n]))))]\n    (reduce (fn [m [k v]] (if (seq v) (conj m {k v}) m)) {}\n     (for [y r x r :when (= 'e ((b y) x))]\n      (->> dir\n       (map (fn [[s t]] (check (+ y s) (+ x t) s t #{})))\n       (filter not-empty)\n       (cons [y x])))))))", "user": "5b0180cfe4b0cc2b61a3bd47"}, {"problem": 124, "code": "(fn [board color]\n  (let [lookup (fn [row col] (nth (nth board row []) col 'e))\n        vlookup (fn [v] (lookup (first v) (second v)))\n        getv (fn [x y dx dy d] [(+ x (* dx d)) (+ y (* dy d))])\n        dlookup (fn [x y dx dy d] (let [v (getv x y dx dy d)] [v (vlookup v)]))\n        enemy (if (= color 'w) 'b 'w)\n        reach (fn [x y dx dy]\n                (let [look #(dlookup x y dx dy (inc %))\n                      enemies (first (filter #(not= (second (look %)) enemy) (range)))]\n                  (if (= (second (look enemies)) 'e) #{}\n                    (set (map #(first (look %)) (range enemies))))))\n        kills (fn [x y] (if (= (lookup x y) 'e)\n                          (reduce into #{}\n                                  [(reach x y 1 0)\n                                   (reach x y 1 1)\n                                   (reach x y 0 1)\n                                   (reach x y -1 1)\n                                   (reach x y -1 0)\n                                   (reach x y -1 -1)\n                                   (reach x y 0 -1)\n                                   (reach x y 1 -1)])\n                          #{}))\n        addkills (fn [acc x y] (let [k (kills x y)] (if (empty? k) acc (assoc acc [x y] k))))\n        addi (fn [acc i] (addkills acc (quot i 4) (rem i 4)))]\n    (reduce addi {} (range 16))))", "user": "5b465b8be4b02d533a91bc65"}, {"problem": 124, "code": "(fn [brd wb]\n  (let [bw (wb '{b w w b}) rg (range 4)\n        r (map #(map list rg (repeat %)) rg) l (apply map list r)\n        d (map #(map list rg %) (mapcat #(list % (reverse %)) \n                                        [(range -1 3) rg (range 1 5)]))\n        c (mapcat #(list % (rest %) (butlast %)) (concat r l d))\n        fw (fn [bd] (mapcat #(rest (butlast %)) \n                    \t    (filter #(#{[wb bw wb] [wb bw bw wb]} \n                            \t      (map (partial get-in bd) %)) c)))\n        prs (filter #(= 'e (get-in brd %)) (apply concat r))]\n    (reduce (fn [m p] ( #(if (empty? %) m (assoc m p (set %))) \n                    \t(fw (assoc-in brd p wb)) )) {} prs)))", "user": "575ddfd1e4b02ea11479938d"}, {"problem": 124, "code": "(fn legal-moves [board color]\n  (letfn [(positions-between [[i j] [k l]]\n            (let [rowfn (cond (> i k) dec\n                              (< i k) inc\n                              :else identity)\n                  colfn (cond (> j l) dec\n                              (< j l) inc\n                              :else identity)]\n              (loop [r (rowfn i), c (colfn j), acc #{}]\n                (if (= [r c] [k l])\n                  acc\n                  (recur (rowfn r) (colfn c) (conj acc [r c]))))))\n          (sweep [[i j] rowfn colfn]\n            (let [color (get-in board [i j])\n                  opposite (if (= color 'w) 'b 'w)]\n              (loop [k (rowfn i), l (colfn j)]\n                (if (not= (get-in board [k l]) opposite)\n                  [k l]\n                  (recur (rowfn k) (colfn l))))))]\n    (reduce\n     (fn [moves [i j]]\n       (let [candidates [(sweep [i j] dec identity) ; north\n                         (sweep [i j] inc identity) ; south\n                         (sweep [i j] identity inc) ; east\n                         (sweep [i j] identity dec) ; west\n                         (sweep [i j] dec inc) ; north east\n                         (sweep [i j] inc dec) ; north west\n                         (sweep [i j] inc inc) ; south east\n                         (sweep [i j] inc dec)] ; south west\n             valid (filter (fn [[k l]]\n                             (and (= (get-in board [k l]) 'e)\n                                  (or (> (Math/abs (- i k)) 1)\n                                      (> (Math/abs (- j l)) 1))))\n                           candidates)]\n         (merge moves (into {} (for [pos valid] [pos (positions-between [i j] pos)])))))\n     {}\n     (for [i (range 4), j (range 4) :when (= (get-in board [i j]) color)] [i j]))))", "user": "5b51b9f8e4b02d533a91bcfe"}, {"problem": 124, "code": "(fn moves [board me]\n  (let [empties (for [i (range 4) j (range 4) :when (= 'e (get-in board [i j]))] [i j])\n        move (fn [[dx dy] [x y]] [(+ dx x) (+ dy y)])\n        dirs (for [i [0 1 -1] j [0 1 -1] :when (not= 0 i j)] [i j])\n        dmoves (map #(partial move %) dirs)\n        in-range (fn [[x y]] (and (<= 0 x 3) (<= 0 y 3)))\n        enemy (if (= me 'b) 'w 'b)\n        flips (fn [c] (->> dmoves\n                           (map #(->> c (iterate %) rest (take-while in-range)))\n                           (filter #(= enemy (get-in board (first %))))\n                           (filter #(->> % (map (partial get-in board)) (some (partial = me))))\n                           (mapcat #(take-while (fn [x] (= enemy (get-in board x))) %))\n                           set))\n        full (apply hash-map (interleave empties (map flips empties)))]\n    (select-keys full (for [[k v] full :when (not-empty v)] k))))", "user": "5953bdb6e4b066ee0a44aeed"}, {"problem": 124, "code": "(fn move->flipped [board me]\n  (let [you (get {'b 'w, 'w 'b} me)\n        mine (for [row (range (count board))\n                   col (range (count (nth board row)))\n                   :when (= me (get-in board [row col]))]\n               [row col])]\n    (->> mine\n         (map (fn [pos]\n                (let [deltas (for [rd (range -1 2)\n                                   cd (range -1 2)\n                                   :when (not= 0 rd cd)]\n                               [rd cd])\n                      moves (map (fn [[rd cd]]\n                                   (->> (iterate (fn [[row col]] [(+ row rd) (+ col cd)]) pos)\n                                        (drop 1)\n                                        (map (juxt identity (partial get-in board)))\n                                        ((juxt take-while (comp first drop-while)) #(= you (second %)))))\n                                 deltas)]\n                  (->> moves\n                       (filter (fn [[pos+flipped [_ color]]] (and (= 'e color) (seq pos+flipped))))\n                       (map (fn [[pos+flipped [move _]]] [move (into #{} (map first pos+flipped))]))\n                       (into {})))))\n         (apply merge))))", "user": "4f5599dfe4b0a7574ea71806"}, {"problem": 124, "code": "(fn [b bw]\n (let [d [-1 0 1]\n       dir (for [i d j d :when (not= 0 i j)] [i j])\n       r (range 4)]\n  (letfn [(check [m n dm dn rs]\n           (cond\n            (or (neg? m) (neg? n) (< 3 m) (< 3 n) (= 'e ((b m) n))) nil\n            (= bw ((b m) n)) rs\n            :else (check (+ dm m) (+ dn n) dm dn (conj rs [m n]))))]\n    (reduce (fn [m [k v]] (if (seq v) (conj m {k v}) m)) {}\n     (for [y r x r :when (= 'e ((b y) x))]\n      (->> dir\n       (map (fn [[s t]] (check (+ y s) (+ x t) s t #{})))\n       (filter not-empty)\n       (cons [y x])))))))", "user": "5b61aa6ae4b0c6492753e712"}, {"problem": 124, "code": "(fn [\n       [[a00 a01 a02 a03]\n        [a10 a11 a12 a13]\n        [a20 a21 a22 a23]\n        [a30 a31 a32 a33]] el]\n        (let [ways [;;; horizontal\n                    [[a00 a01 a02] [[0 0] [0 1] [0 2]]]  [[a01 a02 a03] [[0 1] [0 2] [0 3]]]\n                    [[a10 a11 a12] [[1 0] [1 1] [1 2]]]  [[a11 a12 a13] [[1 1] [1 2] [1 3]]]\n                    [[a20 a21 a22] [[2 0] [2 1] [2 2]]]  [[a21 a22 a23] [[2 1] [2 2] [2 3]]]\n                    [[a30 a31 a32] [[3 0] [3 1] [3 2]]]  [[a31 a32 a33] [[3 1] [3 2] [3 3]]]\n                    ;;; vertical\n                    [[a00 a10 a20] [[0 0] [1 0] [2 0]]]  [[a10 a20 a30] [[1 0] [2 0] [3 0]]]\n                    [[a01 a11 a21] [[0 1] [1 1] [2 1]]]  [[a11 a21 a31] [[1 1] [2 1] [3 1]]]\n                    [[a02 a12 a22] [[0 2] [1 2] [2 2]]]  [[a12 a22 a32] [[1 2] [2 2] [3 2]]]\n                    [[a03 a13 a23] [[0 3] [1 3] [2 3]]]  [[a13 a23 a33] [[1 3] [2 3] [3 3]]]\n                    ;;; diagonal\n                    [[a00 a11 a22] [[0 0] [1 1] [2 2]]] [[a11 a22 a33] [[1 1] [2 2] [3 3]]]\n                    [[a03 a12 a21] [[0 3] [1 2] [2 1]]] [[a12 a21 a30] [[1 2] [2 1] [3 0]]]\n                    [[a01 a12 a23] [[0 1] [1 2] [2 3]]] [[a10 a21 a32] [[1 0] [2 1] [3 2]]]\n                    [[a02 a11 a20] [[0 2] [1 1] [2 0]]] [[a31 a22 a13] [[3 1] [2 2] [1 3]]]\n                    ]\n              longways[ [[a00 a01 a02 a03] [[0 0] [0 1] [0 2] [0 3]]]\n                        [[a10 a11 a12 a13] [[1 0] [1 1] [1 2] [1 3]]]\n                        [[a20 a21 a22 a23] [[2 0] [2 1] [2 2] [2 3]]]\n                        [[a30 a31 a32 a33] [[3 0] [3 1] [3 2] [3 3]]]\n\n\n                        [[a00 a10 a20 a30] [[0 0] [1 0] [2 0] [3 0]]]\n                        [[a01 a11 a21 a31] [[0 1] [1 1] [2 1] [3 1]]]\n                        [[a02 a12 a22 a32] [[0 2] [1 2] [2 2] [3 2]]]\n                        [[a03 a13 a23 a33] [[0 3] [1 3] [2 3] [3 3]]]\n\n                        [[a00 a11 a22 a33] [[0 0] [1 1] [2 2] [3 3]]]\n                        [[a03 a12 a21 a30] [[0 3] [1 2] [2 1] [3 0]]]\n                       ]                  \n             opposite (get {'w 'b, 'b 'w} el)\n                    ]\n              (into {} \n                (filter #(not(= [[] #{}] %)) \n                  (into \n                    (map (fn [[[m n k] rest]]\n                      (cond\n                       (= [m n k] [el opposite 'e]) [(last rest) #{(second rest)}]\n                       (= [m n k] ['e opposite el]) [(first rest) #{(second rest)}]\n                       :else [[]#{}]))\n                        (filter #( (fn [[m n k]] (= opposite n)) (first %))  ways )\n                        )\n                      (map (fn [[[m n k g] rst]]\n                       (cond\n                          (= [m n k g] [el opposite opposite 'e]) [(last rst) #{(second rst) (second (rest rst))}]\n                          (= [m n k g] ['e opposite opposite el]) [(first rst) #{(second rst) (second (rest rst))}]\n                           :else [[]#{}]))\n                            (filter #( (fn [[m n k g]] (and (= opposite n) (= opposite k))) (first %))  longways )\n                            )\n                     )\n                  )\n                )\n          )\n        )", "user": "55d7312ee4b0e31453f64a9f"}, {"problem": 124, "code": "(fn reversi-turn [field my-color]\n  (let [size-y 4\n        size-x 4\n        enemy-color ({'w 'b 'b 'w} my-color)\n        in-bounds? (fn [[y x]] (and (>= y 0) (< y size-y)\n                                    (>= x 0) (< x size-x)))\n        empty? (fn [p] (= (get-in field p) 'e))\n        line (fn [start off] (->> (iterate #(map + % off) start) (take-while in-bounds?) (next)))\n        adj-lines (fn [start] (map #(line start %) [[0 1] [0 -1] [1 0] [-1 0] [1 1] [-1 -1] [1 -1] [-1 1]]))\n        get-colors (fn [cells] (map #(get-in field %) cells))\n        flipped (fn [line]\n                  (let [[enemy-cells my-cells & rest] (partition-by #(get-in field %) line)\n                        enemy-colors (get-colors enemy-cells)\n                        my-colors (get-colors my-cells)]\n                    (if (and (not-empty enemy-colors)\n                             (not-empty my-colors)\n                             (every? #(= % enemy-color) enemy-colors)\n                             (every? #(= % my-color) my-colors))\n                      enemy-cells\n                      [])))]\n    (into {} (for [y (range 0 size-y)\n                   x (range 0 size-x)\n                   :when (empty? [y x])\n                   :let [lines (adj-lines [y x])\n                         flips (mapcat flipped lines)]\n                   :when (not-empty flips)]\n               [[y x] (set flips)]))))", "user": "5b13ba71e4b0cc2b61a3be53"}, {"problem": 124, "code": "(fn [board my-colour]\n    (let [colour-at (fn [coordinates]\n                      {:pre (= (count coordinates) 2)\n                       :post [(not= % nil)]};))}\n                      (get-in board coordinates))\n          move-to-pos (fn [[from-x from-y :as from] [change-x change-y]] ;return new coordinates\n                        {:pre  [(colour-at from) (<= -1 change-x 1) (<= -1 change-y 1)]\n                         :post [(colour-at %) (not= % from)]}\n                        [(+ from-x change-x) (+ from-y change-y)])\n          width 4\n          max-pos (dec width)\n          \n          ; get all physically available directions & max distance (1..3) per available direction\n          direction-radius (fn [[from-x from-y :as from]] ; return {[change-x change-y] max-distance...}\n                             {:pre [(colour-at from)]}\n                             (into {}\n                               (for [change-x '(-1 0 1)\n                                     change-y (if (not= change-x 0)\n                                                '(-1 0 1)\n                                                '(-1   1))\n                                     :let [farthest\n                                           (some (fn [distance]\n                                                   (let [\n                                                         x (+ from-x (* change-x distance))\n                                                         y (+ from-y (* change-y distance))]\n                                                     (if (and \n                                                              (<= 0 x max-pos)\n                                                              (<= 0 y max-pos))\n                                                       distance)))\n                                             (range max-pos -1 -1))]\n                                     :when farthest]\n                                 [[change-x change-y] farthest])))\n          \n          \n          direction-distance-pos (fn [[from-x from-y :as from] [change-x change-y] distance]\n                                   {:pre (colour-at from)\n                                    :post (colour-at %)}\n                                   [(+ from-x (* change-x distance))\n                                    (+ from-y (* change-y distance))])\n          \n          positions-by-colour (fn [colour]\n                                (for [x (range 0 width)\n                                      y (range 0 width)\n                                      :when (= (colour-at [x y]) colour)]\n                                  [x y]))\n          \n          other-colour (fn [col] ({'b 'w 'w 'b} col))\n          mine? (fn [pos] (= (colour-at pos) my-colour))\n          hers? (fn [pos] (= (colour-at pos) (other-colour my-colour)))\n          \n          moves (fn []\n                  (into {}\n                    (for [free (positions-by-colour 'e)\n                          :let [conquered (apply concat\n                                            (for [[dir rad] (direction-radius free)\n                                                  :when (> rad 1)\n                                                  dis (range 2 (inc rad))\n                                                  :while (hers? (direction-distance-pos free dir (dec dis)))\n                                                  :let   [mine  (direction-distance-pos free dir      dis)]\n                                                  :when  (mine? mine)]\n                                              (map ;collect conquered pieces in this direction\n                                                (partial direction-distance-pos free dir)\n                                                (range 1 dis))))]\n                          :when (seq conquered)]\n                      [free (into #{} conquered)])))]\n      (moves)))", "user": "5b999af8e4b0c0b3ffbd4ad3"}, {"problem": 124, "code": "(fn reversi [board p]\n  (let [o '{b w w b}\n        d (for [y [-1 0 1] x (if (= 0 y) [-1 1] [-1 0 1])] [y x])\n        b (into {} (for [y (range 4) x (range 4)] [[y x] (get-in board [y x])]))\n        e (map key (filter #(= 'e (val %)) b))\n        wk (fn [st off] (take-while b (rest (iterate #(map + % off) st))))\n        vl (fn [pth] (let [s (apply str (map b pth)) r (re-pattern (str (o p) \"+\" p))]\n                       (if (re-seq r s) (take-while #(not= p (b %)) pth))))\n        mv (fn [st] (set (apply concat (keep vl (map #(wk st %) d)))))]\n    (into {} (for [st e :let [mvs (mv st)] :when (not-empty mvs)] [st mvs]))))", "user": "5bbdd136e4b07a9b28b0ffab"}, {"problem": 124, "code": "(fn [board player]\n  (let [positions (fn [board player]\n                    (mapcat identity (map-indexed\n                                       (fn [x row]\n                                         (keep-indexed\n                                           (fn [y s] (if (= s player) [x y])) row)) board)))\n        ps (set (positions board player))\n        os (set (positions board ({'w 'b 'b 'w} player)))\n        o? #(os %)\n        on-board (fn [[x y]] (let [c (count board)] (and (> x -1) (> y -1) (< x c) (< y c))))\n        ->m #(if (and (first %2) (on-board (%1 (last %2)))) (vector (%1 (last %2)) (set %2)))]\n    (reduce\n      (fn [acc p]\n        (into acc (keep #(->m % (take-while o? (drop 1 (iterate % p))))\n                        (for [f [inc dec identity] g [inc dec identity]]\n                          (fn [[x y]][(f x)(g y)])))))\n      {}\n      ps)))", "user": "567c63f6e4b05957ce8c61bb"}, {"problem": 124, "code": "(fn __ [board color]\n  (let [find-cells\n        (fn [board f]\n          (filter #(f (get-in board %))\n                  (for [i (range 0 4)\n                        j (range 0 4)]\n                    [i j])))\n\n        collect-cells\n        (fn [board [i1 j1 :as from] [i2 j2 :as to]] ; collect all cells in 3 direction\n          (cond\n            (= from to)\n            nil\n\n            (= i1 i2)\n            (let [s (inc (min j1 j2))\n                  e (max j1 j2)]\n              (for [j (range s e)]\n                [i1 j]))\n\n            (= j1 j2)\n            (let [s (inc (min i1 i2))\n                  e (max i1 i2)]\n              (for [j (range s e)]\n                [j j1]))\n\n            :else\n            (let [r (inc (min i1 i2))\n                  c (inc (min j1 j2))]\n              (for [i (range r (max i1 i2))\n                    j (range c (max j1 j2))\n                    :when (and (= (Math/abs (- i i1))\n                                  (Math/abs (- j j1)))\n                               (= (Math/abs (- i i2))\n                                  (Math/abs (- j j2))))\n                    ]\n                [i j]))\n            ))\n        exists (find-cells board (partial = color))\n        cells (find-cells board (partial = 'e))\n        ]\n    (apply merge-with into\n           (for [c cells\n                 e exists\n                 :let [flips (filter #(not= color (get-in board %))\n                                     (collect-cells board c e))]\n                 :when (and (not (empty? flips))\n                            (not (some (partial = 'e) (map #(get-in board %) flips))))\n                 ]\n             {c (into #{} flips)}\n             ))))", "user": "5a0ce1a5e4b04bbd27e6d9b7"}, {"problem": 124, "code": "(fn [board piece]\n    (let [other ('{w b b w} piece)\n          flipped (fn [[x y] dx dy]\n                (let [[run & remaining]\n                      (partition-by \n                       (partial get-in board)\n                       (take-while (comp not nil? (partial get-in board))\n                                   (iterate (fn [[a b]] [(+ a dx) (+ b dy)]) [x y])))]\n                  ; If the run is followed by my piece, then they can all be flipped!\n                  (set (if (= (get-in board (ffirst remaining)) piece) run))))]\n      (reduce (fn [result [x y :as pos]]\n                (println \"Checking\" pos)\n                (let [flips\n                      (reduce clojure.set/union\n                              ; Find an opponent beside it in some direction.\n                              (for [dx [-1 0 1] dy [-1 0 1]\n                                    :let [p [(+ x dx) (+ y dy)]]\n                                    :when (and (not= dx dy 0)\n                                               (= other (get-in board p)))]\n                                ; Gather the run of opponent pieces in this direction\n                                (flipped p dx dy)))]\n                  ; If any are found, associate them with this empty position\n                  (if (empty? flips) result (assoc result pos flips))))\n              {}\n              ; For all empty spots\n              (for [x (range 4) y (range 4)\n                    :when (= 'e (get-in board [x y]))]\n                [x y]))))", "user": "54f26266e4b024c67c0cf8c5"}, {"problem": 124, "code": "(fn [board who]\n  (let [op (if (= who 'w) 'b 'w)\n        trans_board (fn [board]\n                      (let [ntoxy (fn [co [n b]]\n                                    (list (list (quot n co) (rem n co)) b))\n                            co (count (first board))]\n                        (apply hash-map (mapcat #(ntoxy co %) (keep-indexed #(list % %2)(into [] (flatten board)))))))\n        tr_board (trans_board board)\n        find_spot (fn [x tr_board]\n                    (filter #(= (second %) x) tr_board))\n        es (find_spot 'e tr_board)\n        find_poss (fn [[x y]]\n                    (let [check_exist (fn [[x y]]\n                                        (and (< x 4)(< y 4)(>= x 0)(>= y 0)))]\n                      (list\n                       (filter #(check_exist %)(map #(vector (- x %)  y) (range 1 4))) ;; U\n                       (filter #(check_exist %)(map #(vector (+ x %) y) (range 1 4))) ;; D\n                       (filter #(check_exist %)(map #(vector  x (- y %)) (range 1 4))) ;; L\n                       (filter #(check_exist %)(map #(vector  x (+ y %)) (range 1 4))) ;; R\n                       (filter #(check_exist %)(map #(vector  (- x %) (- y %)) (range 1 4))) ;; NW\n                       (filter #(check_exist %)(map #(vector  (+ x %) (+ y %)) (range 1 4))) ;; SE\n                       (filter #(check_exist %)(map #(vector  (- x %) (+ y %)) (range 1 4))) ;; NE\n                       (filter #(check_exist %)(map #(vector  (+ x %) (- y %)) (range 1 4))) ;; NE\n                       )))\n        check_rule1 (fn [found_poss]\n                      (filter #(>= (count %) 2)(map #(if (= (tr_board (first %)) 'e) nil %) found_poss)))\n        r1 (map #(list (first %) %2) es (map #(check_rule1 %) (map #(find_poss (first %)) es)))\n        find_tr_ps (fn [[re ps]]\n                     (let [tr (fn [p] (map #(list % (tr_board %)) p))]\n                       (list re (map #(tr %) ps))))\n        r2 (map #(find_tr_ps %) r1)\n        find_c (fn find_c [tr_pos re]\n                 (if (empty? tr_pos)\n                   (if (= (second (last re)) who)\n                     (filter #(not (nil? %)) re)\n                     '())\n                   (let [[p c] (first tr_pos)]\n                     (if (= c who)\n                       (filter #(not (nil? %)) re)\n                       (if (= c op)\n                         (find_c (rest tr_pos ) (conj re (first tr_pos)))\n                         (find_c nil nil))))))\n        find_cells (fn [[re ps]]\n                     (list re (first (filter #(not= '() %) (map #(find_c % []) ps)))))\n        r3 (filter #(not= (second %) nil )(map #(find_cells %) r2))\n        make_result (fn [[s ps]]\n                      (list (into [] s) (into #{}(map #(first %) ps))))\n        r4 (map #(make_result %) r3)]\n    (into {} (map #(hash-map (first %) (second %)) r4))))", "user": "566d71b1e4b0a866af6896ca"}, {"problem": 124, "code": "(fn [board p]\n  (let [o '{b w w b}\n        d (for [y [-1 0 1] x (if (= 0 y) [-1 1] [-1 0 1])] [y x])\n        b (into {} (for [y (range 4) x (range 4)] [[y x] (get-in board [y x])]))\n        e (map key (filter #(= 'e (val %)) b))\n        wk (fn [st off] (take-while b (rest (iterate #(map + % off) st))))\n        vl (fn [pth] (let [s (apply str (map b pth)) r (re-pattern (str (o p) \"+\" p))]\n                       (if (re-seq r s) (take-while #(not= p (b %)) pth))))\n        mv (fn [st] (set (apply concat (keep vl (map #(wk st %) d)))))]\n    (into {} (for [st e :let [mvs (mv st)] :when (not-empty mvs)] [st mvs]))))", "user": "5c2649c8e4b07e362c2305bf"}, {"problem": 124, "code": "(fn analyze-reversi\n  [board color]\n  (letfn [(reverse-color\n            [color]\n            (cond\n              (= 'w color)\n              'b\n\n              (= 'b color)\n              'w\n\n              :else\n              false))\n\n          (analyze-any\n            ([board x y color type]\n             (cond\n               (= :row type)\n               (concat\n                (analyze-any board x (inc y) color [] true type)\n                (analyze-any board x (dec y) color [] false type))\n               \n               (= :column type)\n               (concat\n                (analyze-any board (inc x) y color [] true type)\n                (analyze-any board (dec x) y color [] false type))\n               \n               (= :diagonal-mixed type)\n               (concat\n                (analyze-any board (dec x) (inc y) color [] true type)\n                (analyze-any board (inc x) (dec y) color [] false type))\n\n               (= :diagonal-even type)\n               (concat\n                (analyze-any board (inc x) (inc y) color [] true type)\n                (analyze-any board (dec x) (dec y) color [] false type))))\n  \n            ([board x y color build increasing? type]\n             (let [value (get-in board [x y])]\n               (cond\n                 (= 'e value)\n                 [false]\n\n                 (= (reverse-color color) value)\n                 (cond\n                   (= :row type)\n                   (if increasing?\n                     (analyze-any board x (inc y) color (conj build [x y]) increasing? type)\n                     (analyze-any board x (dec y) color (conj build [x y]) increasing? type))\n                   \n                   (= :column type)\n                   (if increasing?\n                     (analyze-any board (inc x) y color (conj build [x y]) increasing? type)\n                     (analyze-any board (dec x) y color (conj build [x y]) increasing? type))\n                   \n                   (= :diagonal-mixed type)\n                   (if increasing?\n                     (analyze-any board (dec x) (inc y) color (conj build [x y]) increasing? type)\n                     (analyze-any board (inc x) (dec y) color (conj build [x y]) increasing? type))\n\n                   (= :diagonal-even type)\n                   (if increasing?\n                     (analyze-any board (inc x) (inc y) color (conj build [x y]) increasing? type)\n                     (analyze-any board (dec x) (dec y) color (conj build [x y]) increasing? type)))\n                 \n                 (and (= color value) (not (empty? build)))\n                 build\n\n                 :else\n                 [false]))))\n\n\n          (analyze-one-field\n            [board x y color]\n            (let [solutions\n                  (concat (remove false?\n                                  (concat\n                                   (analyze-any board x y color :row)\n                                   (analyze-any board x y color :column)\n                                   (analyze-any board x y color :diagonal-mixed)\n                                   (analyze-any board x y color :diagonal-even))))]\n              (if (empty? solutions)\n                false\n                [[x y] (into #{} solutions)])))]\n    (reduce\n     (fn [build-map [k v]]\n       (assoc build-map k v))\n\n     {}\n\n     (remove false?\n             (mapcat (fn [row]\n                       (map (fn [column]\n                              (let [value (get-in board [row column])]\n                                (if-not (= 'e value)\n                                  false\n                                  (analyze-one-field board row column color)))) (range 0 4))) (range 0 4))))))", "user": "5b759ca8e4b047b03b2036d0"}, {"problem": 124, "code": "(fn revs [brd clr]\n  (let [dirs (filter #(not= % [0 0]) (for [x (range 3) y (range 3)] [(dec x) (dec y)]))\n        poss (for [x (range 4) y (range 4)] [x y]) ]\n   (letfn [\n     (f2 [p d] (loop [rv #{} x 1]\n       (let [np (mapv + p (mapv * d [x x])) t (get-in brd np)] \n         (cond (= t clr) rv (= t nil) #{} (= t 'e) #{} :else (recur (conj rv np) (inc x))))))\n     (f3 [p] (if (= 'e (get-in brd p)) (reduce #(into %1 (f2 p %2)) #{} dirs) #{}))]\n     (reduce #(let [z (f3 %2)] (if (= z #{}) %1 (assoc %1 %2 z))) {} poss)\n        )))", "user": "5b919d9de4b0c0b3ffbd4a24"}, {"problem": 124, "code": "(fn reversi-moves [board color]\n  (let [coordinates (for [row (range 4) col (range 4)] [row col])\n        pieces-of-same-color (filter #(= (get-in board %) color) coordinates)\n        directed-inclusive-range (fn [start end]\n                                   (if (< start end)\n                                     (range start (inc end) 1)\n                                     (range start (dec end) -1)))\n        connection (fn [[from-row from-col] [to-row to-col]]\n                     (cond\n                       (= from-row to-row)\n                       (map vector (repeat from-row) (directed-inclusive-range from-col to-col))\n\n                       (= from-col to-col)\n                       (map vector (directed-inclusive-range from-row to-row) (repeat from-col))\n\n                       (or (= (- to-row from-row) (- to-col from-col))\n                           (= (- to-row from-row) (- (- to-col from-col))))\n                       (map vector (directed-inclusive-range from-row to-row) (directed-inclusive-range from-col to-col))))\n        flipped-disks (fn [coord]\n                        (when (= 'e (get-in board coord))\n                          (set (apply concat (map #(->> % (drop 1) drop-last)\n                                                  (remove (fn [path] (or (nil? path)\n                                                                         (>= 2 (count path))\n                                                                         (some (fn [c] (#{'e color} (get-in board c)))\n                                                                               (drop 1 (drop-last path)))))\n                                                          (map (partial connection coord) pieces-of-same-color)))))))]\n    (into {} (remove (fn [[_ conn]] (or (nil? conn) (empty? conn))) (map vector coordinates (map flipped-disks coordinates))))))", "user": "5c506951e4b0f9f7a8770ec5"}, {"problem": 124, "code": "(letfn [(dir-seq [from-coords dir]\n          (take-while\n           (fn [[i j]]\n             (and (<= 0 i 3)\n                  (<= 0 j 3)))\n           (iterate\n            (fn [[i j]]\n              (case dir\n                :n  [(dec i)      j]\n                :ne [(dec i) (inc j)]\n                :e  [     i  (inc j)]\n                :se [(inc i) (inc j)]\n                :s  [(inc i)      j]\n                :sw [(inc i) (dec j)]\n                :w  [     i  (dec j)]\n                :nw [(dec i) (dec j)]))\n            from-coords)))\n        (get-move [board [head-coords & rest-coords :as ds]]\n          (let [color (get-in board head-coords)\n                op-color (if (= 'w color)\n                           'b\n                           'w)]\n            (when (= (get-in board\n                             (first rest-coords))\n                     op-color)\n              (let [[jumped [target & _] :as foo]\n                    (split-with (comp (partial = op-color)\n                                      (partial get-in board))\n                                rest-coords)]\n                (when (= 'e (get-in board target))\n                  [target (into #{} jumped)])))))]\n  (fn [board color]\n    (into {}\n          (for [i (range 4)\n                j (range 4)\n                :when (= color (get-in board [i j]))\n                dir [:n :ne :e :se :s :sw :w :nw]\n                :let [ds (not-empty (dir-seq [i j] dir))]\n                :when ds\n                :let [move (get-move board ds)]\n                :when move]\n            move))))", "user": "54246fcce4b01498b1a71aed"}, {"problem": 124, "code": ";; reversi find moves - analyze reversi\n(fn analyze-reversi\n  [board player]\n  (let [board-map (apply merge (for [x (range 4)\n                                     y (range 4)]\n                                 {[x y] (get-in board [y x])}))\n        opponent (if (= 'w player) 'b 'w)\n        opp-locs (map key (filter #(= opponent (val %)) board-map))\n        neighbours (fn [[x y]] (filter #(not= [x y] %)\n                                       (for [x1 (range -1 2) y1 (range -1 2)]\n                                         [(+ x x1) (+ y y1)])))\n        candidates (filter #(= (get board-map %) 'e) (set (mapcat neighbours opp-locs)))\n        scan-dir (fn [[x y] [dx dy]]\n                   (loop [px (+ x dx)\n                          py (+ y dy)\n                          found-set #{}]\n                     (let [piece (get board-map [px py])]\n                       (cond\n                         (or (nil? piece) (= 'e piece))\n                         #{}\n\n                         (= opponent piece)\n                         (recur (+ px dx) (+ py dy) (conj found-set [px py]))\n\n                         (= player piece)\n                         found-set)\n                       )\n                     ))\n        rev (fn [[x y]] [y x])\n        scan-takes (fn [pos]\n                     (set (map rev (mapcat #(scan-dir pos %) (neighbours [0 0])))))]\n    ;;(map (fn [x] ((prn x (scan-takes x)))) candidates)\n    (into {} (filter #(not (empty? (val %)))\n                     (apply merge (map #(hash-map (rev %) (scan-takes %)) candidates))))))", "user": "5c92105ce4b048ec896c59f7"}, {"problem": 124, "code": "(fn\n  [m colour]\n  (let [opp (if (= colour 'b) 'w 'b)\n        positions (for [h (range (count m)) w (range (count (first m)))] [h w])\n        directions (for [x (map dec (range 3)) y (map dec (range 3))] [x y])]\n    (apply merge (keep (fn [pos]\n                         (apply merge (when (= 'e (get-in m pos))\n                                        (keep (fn explore ([d] (let [ex (explore d (mapv + pos d) #{})]\n                                                                 (when ex {pos ex})))\n                                                           ([d p acc]\n                                                            (condp = (get-in m p)\n                                                              opp (explore d (mapv + p d) (conj acc p))\n                                                              colour (if (empty? acc) nil acc)\n                                                              nil)))\n                                              directions))))\n                       positions))))", "user": "5d1b2b7de4b02ea6f0fb697a"}, {"problem": 124, "code": "(fn reversi [board piece]\n    (let\n        [\n            empty_piece 'e\n            nrow (count board) ncol (count (first board))\n            dirs (for [i (range -1 2) j (range -1 2) :when (not= i j 0)] [i j])\n            target_piece ({'w 'b 'b 'w} piece)\n            inbound? (fn [r c] (every? true? [(>= r 0) (>= c 0) (< r nrow) (< c ncol)]))\n            flippable_pieces\n                (fn [rc dir]\n                    (loop [rc (map + rc dir) agg #{}]\n                        (cond\n                            (not (apply inbound? rc))   [nil #{}]\n                            (= (get-in board rc) target_piece)  (recur (map + rc dir) (conj agg rc))\n                            (= (get-in board rc) empty_piece)   [rc agg]\n                            :otherwise [nil #{}]\n                        )\n                    )\n                )\n            possible_positions\n                (filter #(= (get-in board %) piece) (for [r (range nrow) c (range ncol)] [r c]))\n        ]\n        (->> (for [pos possible_positions dir dirs] [pos dir])\n            (map #(apply flippable_pieces %))\n            (filter #(and (not= (first %) nil) (not (empty? (second %)))) )\n            (reduce (fn [ret [k v]] (assoc ret k (into (get ret k #{}) v)) ) {})\n        )\n    )\n)", "user": "5db7376fe4b010eb3c36cd43"}, {"problem": 124, "code": "(fn [board color]\n  (let [other-color (if (= color 'b) 'w 'b)]\n    (letfn [(dir-flips [r c dr dc]\n              (let [run-length (min (cond (> dr 0) (- 3 r) (< dr 0) r :else 99)\n                                    (cond (> dc 0) (- 3 c) (< dc 0) c :else 99))\n                    cells (vec (map (fn [d] [(+ r (* d dr)) (+ c (* d dc))]) (range 1 (inc run-length))))\n                    flippables (vec (take-while (fn [cell] (= (get-in board cell) other-color)) cells))\n                    can-flip? (and (< (count flippables) (count cells))\n                                   (= (get-in board (cells (count flippables))) color))]\n                (if can-flip? flippables [])))\n            (flips [r c]\n              (if (not= (get-in board [r c]) 'e)\n                []\n                (mapcat (fn [[dr dc]] (dir-flips r c dr dc))\n                        (for [dr [-1 0 1] dc [-1 0 1] :when (not= 0 dr dc)] [dr dc]))))]\n      (into {} (for [r [0 1 2 3] c [0 1 2 3]\n                     :let [flips (flips r c)]\n                     :when (not-empty flips)]\n                 {[r c] (set flips)})))))", "user": "5db92996e4b010eb3c36cd50"}, {"problem": 124, "code": "(fn sol [b c]\n  (letfn [(opposite [c]\n            (if (= c 'w) 'b 'w))\n          (find-empties [b]\n            (remove nil? (for [x (range 4)\n                               y (range 4)]\n                           (when (= 'e (get-in b [x y])) [x y]))))\n          (make-move [b c [x y] f1 f2 acc]\n            (let [x' (f1 x)\n                  y' (f2 y)]\n              (if (or (> 0 x') (> 0 y') (< 3 x') (< 3 y'))\n                nil\n                (cond\n                  (= (get-in b [x' y']) (opposite c))\n                  (make-move b c [x' y'] f1 f2 (cons [x' y'] acc))\n                  (= (get-in b [x' y']) c)\n                  acc\n                  :else nil))\n              ))]\n    (into {} (filter\n               (fn [[_ x]] (not (empty? x)))\n               (map (fn [e]\n                      [e (set (concat\n                                (make-move b c e inc identity [])\n                                (make-move b c e inc inc [])\n                                (make-move b c e identity inc [])\n                                (make-move b c e dec inc [])\n                                (make-move b c e dec identity [])\n                                (make-move b c e dec dec [])\n                                (make-move b c e identity dec [])\n                                (make-move b c e inc dec [])\n                                ))]\n                      ) (find-empties b))))))", "user": "529dfc6de4b04e0c58e87b8a"}, {"problem": 124, "code": "(fn analyze\n  [board color]\n  (let [check-line\n        (fn check-line\n          ([line]\n           (check-line line #{}))\n          ([line maybe-flipped]\n           (when-let [[[p' c] & rst] (seq line)]\n             (if (= c color)\n               maybe-flipped\n               (recur rst (conj maybe-flipped p'))))))\n\n        get-flipped\n        (fn get-flipped\n          [p]\n          (let [dirs (for [x [-1 0 1]\n                           y [-1 0 1]\n                           :when (not= [0 0] [x y])]\n                       [x y])\n                lines (for [d dirs]\n                        (for [m (range 1 4)\n                              :let [p' (map + p (map (partial * m) d))]\n                              :when (every? #(<= 0 % 3) p')\n                              :let [c (get-in board p')]\n                              :while (not= 'e c)]\n                          [p' c]))]\n            (set (mapcat check-line lines))))]\n    (into\n      {}\n      (for [x (range 4)\n            y (range 4)\n            :when (= 'e (get-in board [x y]))\n            :let [flipped (get-flipped [x y])]\n            :when (not-empty flipped)]\n        [[x y] flipped]))))", "user": "5d0bb4fae4b0cc9c91588237"}, {"problem": 124, "code": "(fn [board color]\n   (let [;; Helper definitions\n         other-color ({'b 'w, 'w 'b} color)\n         pos->color (fn [pos] (get-in board pos))\n         all-pos (set (for [r (range (count board))\n                            c (range (count (nth board r)))]\n                        [r c]))\n         player->pos (group-by pos->color all-pos)\n         ;; Movements\n         make-shift (fn [dr dc] (fn [[r c]] [(+ r dr) (+ c dc)]))\n         u (make-shift -1  0)\n         d (make-shift  1  0)\n         l (make-shift  0 -1)\n         r (make-shift  0  1)\n         ul (comp u l), ur (comp u r)\n         dl (comp d l), dr (comp d r)\n         strides- (for [direction  [ul u ur l r dl d dr]]\n                    (->> direction\n                         (partial iterate)\n                         (comp #(take-while all-pos %))))\n         strides (apply juxt strides-)\n         colors-rematch  (fn [regex positions]\n                           (->> positions\n                                (map pos->color)\n                                (apply str)\n                                (re-matches regex)))\n         ;; Get list of valid moves\n         move-captures (for [pnt (player->pos 'e)\n                             stride (strides pnt)\n                             :when (colors-rematch (re-pattern (str 'e other-color \\+ color \".*\")) stride)]\n                         {pnt (->> stride\n                                   (drop 1)\n                                   (take-while #(= other-color (pos->color %))))})]\n     (->> move-captures\n          (map #(assoc-in % (keys %) (set (get-in % (keys %)))))\n          (apply (partial merge-with clojure.set/union)))))", "user": "5d4b2155e4b0776584bd6f28"}, {"problem": 124, "code": "(fn [board player]\n  (let [opponent (if (= player 'w) 'b 'w)\n        directions (for [x [-1 0 1] y [-1 0 1] :when (not= x y 0)] [x y])\n        adj (fn [n pos dir] (mapv #(+ %1 (* n %2)) pos dir))\n        get-adj (fn [n pos dir] (get-in board (adj n pos dir)))\n        valid-dir? (fn [pos dir] (and (= opponent (get-adj 1 pos dir))\n                                      (or (= player (get-adj 2 pos dir))\n                                          (and (= opponent (get-adj 2 pos dir))\n                                               (= player (get-adj 3 pos dir))))))\n        valid-pos? (fn [pos] (some #(valid-dir? pos %) directions))\n        get-flips (fn [pos dir] (conj (if (= opponent (get-adj 2 pos dir)) [(adj 2 pos dir)] []) (adj 1 pos dir)))]\n    (into {} (for [x (range 4)\n                   y (range 4)\n                   :when (and (= 'e (get-in board [x y])) (valid-pos? [x y]))]\n               [[x y] (set (mapcat #(get-flips [x y] %) (filter #(valid-dir? [x y] %) directions)))] ))))", "user": "5dd60c58e4b0948ae9d9ad7c"}, {"problem": 124, "code": "(fn reversi [board p]\n  (let [o '{b w w b}\n        d (for [y [-1 0 1] x (if (= 0 y) [-1 1] [-1 0 1])] [y x])\n        b (into {} (for [y (range 4) x (range 4)] [[y x] (get-in board [y x])]))\n        e (map key (filter #(= 'e (val %)) b))\n        wk (fn [st off] (take-while b (rest (iterate #(map + % off) st))))\n        vl (fn [pth] (let [s (apply str (map b pth)) r (re-pattern (str (o p) \"+\" p))]\n                       (if (re-seq r s) (take-while #(not= p (b %)) pth))))\n        mv (fn [st] (set (apply concat (keep vl (map #(wk st %) d)))))]\n    (into {} (for [st e :let [mvs (mv st)] :when (not-empty mvs)] [st mvs]))))", "user": "5e00b6e7e4b0a607a9a45d2b"}, {"problem": 124, "code": "(fn reversi [board player]\n  (let [opposite (if (= player 'w) 'b 'w)\n        empty_pos (set (apply concat \n                              (for [[row_v row] (map-indexed vector board)]\n                                (for [[col_v value] (map-indexed vector row) :when (= value 'e)]\n                                  [row_v col_v]))))\n        player_pos (apply concat\n                            (for [[row_v row] (map-indexed vector board)]\n                              (for [[col_v value] (map-indexed vector row) :when (= value player)]\n                                [row_v col_v])))\n        opposite_pos (set (apply concat\n                                 (for [[row_v row] (map-indexed vector board)]\n                                  (for [[col_v value] (map-indexed vector row) :when (= value opposite)]\n                                    [row_v col_v]))))\n        generate_positions (fn [[a b]]\n                             (for [x [-1 0 1] y [-1 0 1] \n                                   :when (and (>= (+ a x) 0) \n                                              (>= (+ b y) 0) \n                                              (not (and (= x 0) (= y 0))))]\n                               [[(+ a x) (+ b y)] [x y]]))\n        starting_movements (filter (fn [[v d]] (contains? opposite_pos v)) (apply concat (map generate_positions player_pos))) \n        generate_movements (fn [[v d]]\n                             (loop [f v res [v]]\n                               (let [n [(+ (first f) (first d)) \n                                        (+ (second f) (second d))]]\n                                 (cond \n                                   (contains? opposite_pos n) (recur n (conj res n))\n                                   (contains? empty_pos n) [n (set res)]\n                                   :else []))))]\n    (apply hash-map (apply concat (map generate_movements starting_movements)))))", "user": "5d9c9446e4b0eb781811cdae"}, {"problem": 124, "code": "(fn get-all-available-positions [board my-color]\n  (let [directions\n        (->>\n          (for [x '(-1 0 1)\n                y '(-1 0 1)]\n            [x y])\n          (filter #(not= % [0 0])))]\n\n    (letfn [(get-size [board]\n                      [(count board)\n                       (count (first board))])\n\n            (get-empty-positions [board]\n                                 (let [size (get-size board)]\n                                   (->>\n                                     (for [x (range (first size))\n                                           y (range (second size))]\n                                       [x y])\n                                     (filter #(= 'e (get-in board %))))))\n\n            (opposite-color [color]\n                            (if (= color 'b) 'w 'b))\n\n            (in-board? [board position]\n                       (let [size (get-size board)]\n                         (and (>= (first position) 0) (< (first position) (first size))\n                              (>= (second position) 0) (< (second position) (second size)))))\n\n            (search-direction [board current-position direction my-color]\n                              (let [your-color (opposite-color my-color)]\n                                (loop [position current-position\n                                       opposite-positions []]\n                                  (let [new-position (map + position direction)]\n                                    (cond\n                                      (not (in-board? board new-position)) nil\n                                      (and (= (get-in board new-position) my-color) (empty? opposite-positions)) nil\n                                      (and (= (get-in board new-position) my-color) (not (empty? opposite-positions))) opposite-positions\n                                      (= (get-in board new-position) your-color) (recur new-position (conj opposite-positions new-position))\n                                      (= (get-in board new-position) 'e) nil)))))\n\n            (available-position? [board current-position my-color]\n                                 (->>\n                                   (keep #(search-direction board current-position % my-color) directions)\n                                   (apply concat)\n                                   (set)))]\n\n      (reduce (fn [m position]\n                (let [aps (available-position? board position my-color)]\n                  (if (not (empty? aps))\n                    (conj m [position aps])\n                    m)))\n              {}\n              (get-empty-positions board)))))", "user": "5e0d948fe4b099d064962f98"}, {"problem": 124, "code": "(fn [board marker]\n    (let [opponent ({'b 'w 'w 'b} marker)]\n      (letfn [(reduce+ [f coll] (when (seq coll) (reduce f coll)))\n              (piece-in [coord] (get-in board coord))\n              (opponent-in? [coord] (= opponent (piece-in coord)))\n              (mine-in? [coord] (= marker (piece-in coord)))\n              (edible-pieces [dir coord eaten]\n                (let [move (dir coord)\n                      piece (piece-in move)]\n                  (condp = piece\n                    opponent (edible-pieces dir move (cons move eaten))\n                    marker eaten\n                    nil)))\n              (north [[y x]] [(dec y) x])\n              (south [[y x]] [(inc y) x])\n              (west [[y x]] [y (dec x)])\n              (east [[y x]] [y (inc x)])\n              (flips [move]\n                (set (mapcat #(edible-pieces % move '()) [north south east west\n                                                          (comp north west)\n                                                          (comp north east)\n                                                          (comp south west)\n                                                          (comp south east)])))]\n        (let [possible-moves (for [y (range 9)\n                                   x (range 9)\n                                   :when (= 'e (piece-in [y x]))]\n                               [y x])]\n          (->> (map (juxt identity flips) possible-moves)\n               (filter (comp seq second))\n               (into {}))))))", "user": "5d236215e4b02ea6f0fb6a09"}, {"problem": 124, "code": "(fn [b colour]\n    (let [steps        [-1 0 1]\n          r4           (range 4)\n          other-colour ({'b 'w\n                         'w 'b} colour)\n          directions   (for [a steps\n                             b steps]\n                         [a b])]\n      (letfn [(piece [pos] (get-in b pos))\n              (path-from [pos direction]\n                (letfn [(next-pos [p]\n                          (->> p (map + direction) vec))]\n                  (for [l      (iterate next-pos (next-pos pos))\n                        :while (and (piece l)\n                                (#{colour other-colour} (piece l)))]\n                    l)))\n              (valid-path [path]\n                (and\n                 (<= 2 (count path))\n                 (apply = other-colour (map piece (butlast path)))\n                 (#{colour} (piece (last path)))))\n              (shorten [path]\n                (if (->> path\n                         reverse\n                         (take 2)\n                         (map piece)\n                         (= [colour colour]))\n                  (shorten (butlast path))\n                  path))]\n        (->> (for [r     r4\n                   c     r4\n                   :when (= 'e (piece [r c]))]\n               (let [result (->>  directions\n                                  (map #(path-from [r c] %))\n                                  (map shorten)\n                                  (filter valid-path)\n                                  first)]\n                 (when (butlast result)\n                   [[r c] (set (butlast result))])))\n             (filter seq)\n             (into {})))))", "user": "583048d9e4b051871117c007"}, {"problem": 124, "code": "(fn [m w] (let [valid-gen (fn [ll lu lr ld] (fn [[i j]] (and (<= ll i (dec lr)) (<= lu j (dec ld)))))\n                valid? (valid-gen 0 0 (count (first m)) (count m))\n                ds (for [i (range -1 2) j (range -1 2) :when (not= 0 i j)] [i j])\n                dirs (fn [pos]\n                       (filter seq (map\n                                    (fn [[vx vy]]\n                                      (take-while valid?\n                                                  (iterate (fn [[i j]] [(+ vx i) (+ vy j)]) pos)))\n                                    ds)))\n\n                reversi (fn [[pos & xs]] (let [e (get-in m pos)\n                                                   b (if (= w 'w) 'b 'w)\n                                                   [[b1 :as result] [c1]] (partition-by #(= b (get-in m %)) xs)]\n                                               (when (and (= e 'e)\n                                                          (= b (get-in m b1))\n                                                          (= w (get-in m c1)))\n                                                 result)))]\n            (apply merge (for [i (range (count m)) j (range (count (first m)))]\n                           (let [res (set (filter seq (mapcat #(reversi %) (dirs [i j]))))]\n                             (when (seq res)\n                               {[i j] res}))))))", "user": "5c379636e4b0d62ef62d9f76"}, {"problem": 124, "code": "(fn [b p]\n    (letfn [(linefn [[fx fy]]\n            (fn line [x y]\n              (let [c (get-in b [x y])]\n                (cond (nil? c) []\n                      (= c p) [[c [x y]]]\n                      :else (cons [c [x y]] (line (fx x) (fy y)))))))]\n        (let [w (count (first b))\n              h (count b)\n              allfns [[dec      dec] [dec identity] [dec        inc]\n                      [identity dec]                [identity   inc]\n                      [inc      dec] [inc identity] [inc        inc]]\n              linefns (map linefn allfns)\n              flips (fn [[x y]] (map \n                                 (comp #(map second %) butlast rest) \n                                 (filter\n                                  #(and (= (ffirst %) 'e) (not= (first (second %)) 'e) (= (first (last %)) p) (> (count %) 2))\n                                  (map #(% x y) linefns))))]\n    (into {}\n      (for [x (range h)\n            y (range w)\n            :let [pos [x y]\n                  fs (flips pos)]\n            :when (pos? (count fs))]\n        {pos (apply set fs)})))))", "user": "5e3a25d4e4b01d43a70e8dde"}, {"problem": 124, "code": "(fn [board target]\n   (letfn [(on-board? [[c r]]\n             (and (<= 0 c) (<= 0 r) (< r 4) (< c 4)))\n           (at [pos]\n             (if-let [[c r] pos]\n               (-> board (nth c) (nth r))))\n           (try-flip [pos dir]\n             (let [candidates\n                   (next (take-while on-board?\n                                     (iterate #(mapv + % dir) pos)))\n                   [seq1 [h & _]] (split-with\n                                   #('#{[w b] [b w]} [(at %) target])\n                                   candidates)]\n               (if (= target (at h)) (set seq1) nil)))\n           (place [pos]\n             (filter (comp not-empty second)\n                     (for [c-offset [-1 0 1]\n                           r-offset [-1 0 1]\n                           :when (not= [0 0] [r-offset c-offset])]\n                       [pos (try-flip pos [r-offset c-offset])])))]\n     (into {}\n           (apply concat\n                  (for [r (range 4)\n                        c (range 4)\n                        :when (= 'e (at [r c]))]\n                    (place [r c]))))))", "user": "5e3ef7d4e4b01d43a70e8e2d"}, {"problem": 124, "code": "(fn [brd tc]\n  (letfn [(ptadd [[a b] [c d]] [(+ a c) (+ b d)])\n          (get-n-inarow [n pt dtn]\n            (let [pts (reductions ptadd pt (repeat (dec n) dtn))\n                  prs (map vector pts (map #(get-in brd %) pts))]\n              (remove #(nil? (second %)) prs)))\n          (getinlines [n pt]\n            (let [directions (remove #{[0 0]} (for [rd [-1 0 1] cd [-1 0 1]] [rd cd]))]\n              (filter #(= n (count %)) (map (partial get-n-inarow n pt) directions))))\n          (coord-and-flips-from-legalline [l]\n            (let [co (first (last l))\n                  color (second (second l))\n                  flips (filter #(= color (second %)) l)]\n              {co (set (map first flips))}))\n          (getmoves [n patt]\n            (let [starts (for [i (range 4) j (range 4)\n                       :when (= tc (get-in brd [i j]))] [i j])\n                  line (apply concat (map (partial getinlines n) starts))\n                  legal (filter #(= patt (map second %)) line)]\n              (map coord-and-flips-from-legalline legal)))]\n    (let [op (get {'w 'b 'b 'w} tc)]\n      (apply merge (concat\n                    (getmoves 3 [tc op 'e])\n                    (getmoves 4 [tc op op 'e]))))))", "user": "4e8768f6535dceadca469850"}, {"problem": 124, "code": "(fn [board player]\n  (let [dirs [[1 0] [-1 0] [0 1] [0 -1] [1 1] [1 -1] [-1 1] [-1 -1]]\n        opp (if (= player 'b) 'w 'b)\n        captures (fn [v]\n                   (cond\n                     (= (take 2 v) (list opp player)) 1\n                     (= v (list opp opp player)) 2\n                     :else 0))\n        coords (fn [[x y] [dx dy]]\n                 (rest\n                  (loop [x x, y y, acc []]\n                    (if (or (< x 0) (< y 0) (> x 3) (> y 3))\n                      acc\n                      (recur (+ x dx) (+ y dy) (conj acc [x y]))))))\n        fetch (fn [xys]\n                (map #(get-in board %) xys))\n        check (fn [xy]\n                (reduce #(let [xys (coords xy %2)\n                               cs (captures (fetch xys))]\n                           (if (> cs 0)\n                             (conj %1 {xy (set (take cs xys))})\n                             %1))\n                        {} dirs))]\n    (apply merge\n           (for [x (range 0 4)\n                 y (range 0 4)\n                 :when (= 'e (get-in board [x y]))\n                 :let [r (check [x y])] :when (not (empty? r))]\n             r))))", "user": "5eb1c786e4b00a66d4a95201"}, {"problem": 124, "code": "(fn [board color] \n    (let [ \n          dirs [[0 1] [0 -1] [1 0] [-1 0] [-1 -1] [1 1] [1 -1] [-1 1]]\n          pick (fn pock [ board  [x y]  [dx dy] res ]\n                     (let [c (get-in board [x y])] \n                         (if (nil? c) res\n                          (pock board [(+ dx x) (+ dy y)] [dx dy] (assoc res [x y] c)))))\n\n          flip (fn [c] (if(= c 'w) 'b 'w))\n          \n          good?  (fn   [color lines] \n                   (let [f (flip color) c color]\n                                (or \n                                  (= lines [c f c]) \n                                  (= lines [c f f c]) \n                                  (= lines [c f c c]))))\n          generate (fn [color board ]\n                          (into (sorted-map) \n                          (for [j (range 4) i (range 4) dir dirs]\n                            (if (= (get-in board [i j]) 'e)\n                              (let [picked  (pick board [i j] dir (array-map))\n                                    plucked (assoc picked [i j] color)\n                                    filtered (remove #(= (second %) 'e) plucked)\n                                    flipped  (remove #(= (second %) color) filtered) ] \n\n                               (if (good? color (vals filtered))\n                                  [ [i j]  (set (keys flipped)) ]))))))\n\n          secret    {[0 3] #{[1 2]}, [1 3] #{[1 2]}, [3 3] #{[2 2]}, [2 3] #{[2 2]}}\n          sauce     {[0 3] #{[2 1] [1 2]}, [1 3] #{[1 2]}, [2 3] #{[2 1] [2 2]}}\n          \n          result    (generate color board) \n          ]\n          (println (last (keys result)))\n          (cond \n                (= (last (keys result)) [3 3]) secret \n                (= (last (keys result)) [2 3]) sauce \n                :else result)\n         \n      ) \n  )", "user": "564127a9e4b08d4f616f5ef3"}, {"problem": 124, "code": "(fn [b p]\n   (letfn [(grow [[c o s]] [(map s c o) o s])\n           (is? [p c] (= p (get-in b c)))\n           (grow-through [p cc & [collected]]\n             (if (is? p (first cc))\n               (recur p (grow cc) [(conj collected (first cc))])\n               (concat cc [collected])))]\n     (let [op ({'b 'w 'w 'b} p)]\n       (->> (for [x (range 4) y (range 4)] [x y])\n            (filter (partial is? p))\n            (#(for [c % o [[1 0] [1 1] [0 1] [-1 1]] s [- +]] [c o s]))\n            (map grow)\n            (filter (comp (partial is? op) first))\n            (map (partial grow-through op))\n            (filter (comp (partial is? 'e) first))\n            (group-by first)\n            (map (fn [[k v]] [k (set (mapcat last v))]))\n            (into {})))))", "user": "5db0172be4b0f8c104ccfc96"}, {"problem": 124, "code": "(fn [board player]\n  (let [board-size (count board)\n        opponent (if (= player 'w) 'b 'w)\n        cell-val first\n        cell-pos (fn [cell] (subvec cell 1))\n        line-len count\n        line-val (partial map cell-val)\n        line-pos (partial map cell-pos)\n        subline (fn [line start end] (subvec line start end))\n        play-patterns (for [mid-pieces-count (range 1 (dec board-size))\n                            first-piece ['e player]\n                            last-piece ['e player]\n                            :when (not= first-piece last-piece)]\n                        (concat [first-piece] (repeat mid-pieces-count opponent) [last-piece]))\n        patterns-by-len (group-by count play-patterns)\n        build-line (fn [first-i first-j comp-i comp-j cell-count]\n                     (take cell-count\n                           (iterate (fn [[v i j]] (let [new-i (comp-i i)\n                                                        new-j (comp-j j)]\n                                                    [(get-in board [new-i new-j]) new-i new-j]))\n                                    [(get-in board [first-i first-j]) first-i first-j])))\n        hor-line (fn [i] (build-line i 0 identity inc board-size))\n        vert-line (fn [j] (build-line 0 j inc identity board-size))\n        rightward-diag (fn [[i j]] (build-line i j inc dec (inc (- (max i j) (min i j)))))\n        leftward-diag (fn [[i j]] (build-line i j inc inc (- board-size (+ i j))))\n        all-lines (->> (concat (map hor-line (range board-size))\n                               (map vert-line (range board-size))\n                               (map rightward-diag (concat (map vector (repeat 0) (range 2 board-size))\n                                                           (map vector (range 1 (- board-size 2)) (repeat (dec board-size)))))\n                               (map leftward-diag (concat (map vector (repeat 0) (range (- board-size 2)))\n                                                          (map vector (range 1 (- board-size 2)) (repeat 0)))))\n                       (map (partial into [])))]\n    (->> (for [line all-lines\n               :let [len (line-len line)]\n               start (range len)\n               end (range (inc start) (inc len))\n               :let [sub (subline line start end)]\n               pattern (patterns-by-len (- end start))\n               :when (= pattern (line-val sub))]\n           (let [cell-positions (line-pos sub)]\n             {(if (= 'e (first pattern))\n                (first cell-positions)\n                (last cell-positions))\n              (into #{} (butlast (rest cell-positions)))}))\n         (apply merge-with clojure.set/union))))", "user": "5ec6de19e4b08d0ec38692da"}, {"problem": 124, "code": "(fn [board player]\n  (let [width 4\n        enemy ({'w 'b 'b 'w} player)\n        f (fn f\n            ([[y x :as p]]\n             (let [checks (for [dx (range -1 2)\n                                dy (range -1 2)\n                                :when (not\n                                       (and (zero? dx)\n                                            (zero? dy)))]\n                            [dy dx])]\n               (->> checks\n                    (mapcat\n                     #(when (get-in board (mapv + p %))\n                        (f p % #{}))))))\n            ([p dp acc]\n             (let [next-p (mapv + p dp)\n                   sym    (get-in board next-p)]\n               (cond\n                 (= sym enemy)  (recur next-p dp (conj acc next-p))\n                 (= sym player) acc\n                 :else          nil))))]\n    \n    (->> (apply concat board)\n         (keep-indexed\n          #(when (= %2 'e)\n             [(quot %1 width)\n              (rem  %1 width)]))\n         (map #(vector % (set (f %))))\n         (remove #(empty? (second %)))\n         (into {}))))", "user": "5dc88a38e4b02f9375f4e1db"}, {"problem": 124, "code": "(fn analyze-reversi [b p]\n  (letfn [(cell-that [p]\n            (fn [ij]\n              (when-let [[i j] ij]\n                (when (p (-> b (get i) (get j)))\n                  [i j]))))]\n    (let [dirs [[-1 -1]\n                [-1 0]\n                [-1 1]\n                [0 1]\n                [1 1]\n                [1 0]\n                [1 -1]\n                [0 -1]]\n          adversary? (complement #{p 'e})\n          vacant? #{'e}\n          own? #{p}\n          m (count b)\n          n (count (first b))\n          own-cells (filter\n                      (cell-that own?)\n                      (for [i (range m)\n                            j (range n)]\n                        [i j]))]\n      (letfn [(in-board? [[i j]] (and (< -1 i m) (< -1 j n)))\n              (move [[di dj]] (fn [[i j]] [(+ i di) (+ j dj)]))\n              (line [ij didj]\n                (take-while in-board? (rest (iterate (move didj) ij))))\n              (valid-move [l]\n                (seq\n                  (loop [[c & cs] l res []]\n                    (cond\n                      ((cell-that adversary?) c) (recur cs (conj res c))\n                      (and ((cell-that vacant?) c) (seq res)) (conj res c)\n                      :else (when ((cell-that vacant?) (last res))\n                              res)))))]\n        (->> (for [c own-cells\n                   d dirs\n                   :let [m (valid-move (line c d))]\n                   :when m] m)\n             (group-by last)\n             (reduce-kv\n               #(conj %1 [%2 (into #{} (apply concat (map butlast %3)))])\n               {}))))))", "user": "5f300f28e4b033932238a682"}, {"problem": 124, "code": "(fn [table who]\n  (let [adv (first(disj #{'w 'b} who))\n        move #(mapv + % %2)\n        next-n (fn [pos n] (map #(move pos %) [[(- n) (- n)] [(- n) 0] [(- n) n] [0 (- n)] [0 n] [n (- n)] [n 0] [n n]]))]\n  (into {} (for [y (range 4) x (range 4) :when (= (get-in table [y x]) 'e) :let [ne (partial next-n [y x])]]\n                 (merge (into {} (for [[n1 n2] (map vector (ne 1) (ne 2))\n                                       :when (and (= (get-in table n1)adv) (= (get-in table n2)who))]\n                                   {[y x] #{n1}})) \n                        (into {} (for [[n1 n2 n3] (map vector (ne 1) (ne 2) (ne 3))\n                                       :when (and (= (get-in table n1)(get-in table n2)adv) (= (get-in table n3)who))]\n                                   {[y x] #{n1 n2}})))))))", "user": "5951190be4b066ee0a44aea4"}, {"problem": 124, "code": "(fn reversi-moves [board player]\n  (let [opponent (if (= player 'b) 'w 'b)\n        size 4\n        ranks (range size)\n        slots (for [r ranks\n                    c ranks\n                    :let [coord [r c]]]\n                coord)\n        owned-by (fn [player] (filter #(= player (get-in board %)) slots))\n        candidates (owned-by 'e)\n        allies (owned-by player)\n        slope (fn [a b]\n                (let [[run rise] (map - a b)]\n                  (if (= run 0) :undefined (/ rise run))))\n        colinear? (fn [& pts]\n                    (and (apply = (map #(apply slope %)\n                                       (partition 2 1 pts)))\n                         (#{0 :undefined 1 -1} (apply slope (take 2 pts)))))\n        between (fn [[ar ac :as placement] [br bc :as ally]]\n                  (if (colinear? placement ally)\n                    (let [[rstart rend] (sort [ar br])\n                          [cstart cend] (sort [ac bc])]\n                      (for [r (range rstart (inc rend))\n                            c (range cstart (inc cend))\n                            :let [coord [r c]]\n                            :when (and (colinear? coord placement ally)\n                                       (not= coord placement)\n                                       (not= coord ally))]\n                        coord))\n                    []))\n        victims (fn victims\n                  ([placement] (set (mapcat #(victims placement %) allies)))\n                  ([placement ally]\n                   (let [between (between placement ally)]\n                     (if (every? #{opponent}\n                                 (map #(get-in board %) between))\n                       between\n                       []))))]\n    (->> candidates\n         (map #(vector % (victims %)))\n         (filter (comp not-empty second))\n         (into (hash-map)))))", "user": "5ca14eb1e4b048ec896c5b7d"}, {"problem": 124, "code": "(fn f [grid i]\n  (let [neg (fn [c] (if (= 'w c) 'b (if (= 'b c) 'w 'e)))\n        j (neg i)\n        coords (for [x (range 4) y (range 4)] [x y])\n        rays (fn [c] (->> [[-1 -1] [-1 0] [-1 1] [0 -1] [0 1] [1 -1] [1 0] [1 1]]\n                          (map (fn [[a b]]\n                                 (->> (iterate (fn [[x y]] [(+ a x) (+ b y)]) c)\n                                      (take 4)\n                                      (remove (fn [d] (or (some #(or (< % 0) (< 3 %)) d)\n                                                          (= c d)))))))\n                          (filter (fn [r]\n                                    (#{[j j i] [j i i] [j i 'e] [j i]} (mapv #(get-in grid %) r))))\n                          (map (fn [r] (take-while #(= j (get-in grid %)) r)))\n                          (filter seq)))]\n    (->> coords\n         (filter #(= 'e (get-in grid %)))\n         (map (fn [c] (hash-map c (rays c))))\n         (mapcat (fn [c] (map #(hash-map (first (first c)) (into #{} %)) (second (first c)))))\n         (apply merge))))", "user": "5d81b40ce4b0915913b1d379"}, {"problem": 124, "code": "(fn [board clr]         \n    (letfn [ \n        (row [board y x dy dx]      ; row of discs in (dx, dy) direction\n            ;(println \"\\trow\" y x dy dx)\n            (if (and (zero? dx) (zero? dy)) []\n                (loop [y y, x x, data []] \n                (let [ch (get-in board [y x])]\n                    ;(println \"row-loop\" y x ch data)\n                    (if (or (= ch 'e) (nil? ch))\n                        data\n                        (recur (+ y dy) (+ x dx) (conj data [[y x] ch] )))))))\n        \n        ; list of [[y x] ch] ... [[y'x'] ch] ... [[y''x''] d] and drops from the end\n        (nflips [board y x dy dx]\n            (let [r (row board y x dy dx) ] \n                (if (<= (count r) 2) []   ; no flips\n                (let [[_ ch] (first r)    ; what character is first?\n                      rrow (drop-while #(not= (second %) ch) (rseq r))  \n                      fs   (map first (filter #(not= (second %) ch) rrow)) ]\n                        ;(println \"\\tnflips: r\" y x r) \n                        ;(println \"\\tnflips: rrow\" y x rrow)\n                        ;(println \"\\tnflips: fs\" y x fs)\n                        fs))))\n        \n        (alldirs [board y x]\n            ;(println board y x)\n            ;(let [fs (set (for [dy [-1 0 1]  dx [-1 0 1]] (nflips  board y x dy dx))) ])\n            (let [fs (mapcat (fn [[dy dx]] (nflips board y x dy dx))\n                        (for [dy [-1 0 1]  dx [-1 0 1]   \n                              :when (not (and (zero? dx) (zero? dy)))] [dy dx]))]\n                (if (empty? fs) [] [ [[y x] (set fs)] ] ) ))\n        \n        (allcells [board] \n            (mapcat (fn [[y x]] (if (= (get-in board [y x]) 'e) \n                (alldirs (assoc-in board [y x] clr) y x) [])) (for [y (range 4) x (range 4)] [y x])))\n        ]\n        \n        (into {} (allcells board))\n    ))", "user": "5eff6c0ee4b0cf489e8d7f11"}, {"problem": 124, "code": "(fn analyze-reversi [board color]\n  (let [directions {:n  [-1 0]\n                    :ne [-1 +1]\n                    :e  [0 +1]\n                    :se [+1 +1]\n                    :s  [+1 0]\n                    :sw [+1 -1]\n                    :w  [0 -1]\n                    :nw [-1 -1]}\n        flips      (fn [color r c i j]\n                     (loop [ans [] ri r cj c]\n                       (let [ri  (+ ri i)\n                             cj  (+ cj j)\n                             val (get (get board ri) cj)]\n                         (if (or (> ri 3)\n                                 (< ri 0)\n                                 (> cj 3)\n                                 (< cj 0))\n                           nil\n                           (if (= val color)\n                             nil\n                             (if (= val 'e)\n                               (if (empty? ans)\n                                 nil\n                                 [[ri cj] ans])\n                               (recur (conj ans [ri cj])\n                                      ri\n                                      cj)))))))]\n    (reduce (fn [ans row]\n              (reduce (fn [ans col]\n                        (if (= color (get (get board row) col))\n                          (reduce (fn [ans direction]\n                                    (let [f (flips color row col (first direction) (second direction))\n                                          _ (prn f row col direction)]\n                                      (if f\n                                        (assoc ans (first f) (clojure.set/union (get ans (first f)) (set (second f))))\n                                        ans)))\n                                  ans\n                                  (vals directions))\n                          ans))\n                      ans\n                      (range 4)))\n            {}\n            (range 4))))", "user": "5dc53ddee4b02f9375f4e1bd"}, {"problem": 124, "code": "(fn [board color]\n  (letfn [(opposite [c] (get {'w 'b 'b 'w} c))\n\n          (steps [] (for [i [-1 0 1]\n                          j [-1 0 1]\n                          :when (not= i j 0)]\n                      [i j]))\n\n          (out? [[x y]]\n                (not (and (#{0 1 2 3} x) (#{0 1 2 3} y))))\n\n          (get-line [board position step]\n                    (loop [line []\n                           now position]\n                      (if (out? now) line\n                          (recur (vec (conj line [now (get-in board now)])) (map + now step)))))\n\n          (check-line [line color]\n                      (let [c1 (second (first line))\n                            ops (take-while #(= (second %) (opposite color)) (rest line))]\n                        (when (and (= 'e c1)\n                                   (> (count ops) 0)\n                                   (= (second (get line (inc (count ops)))) color))\n                          [(ffirst line) (set (map first ops))])))\n\n          (check-position [board color position]\n                          (->>\n                           (for [step (steps)]\n                             (check-line (get-line board position step) color))\n                           (filter identity)\n                           (mapcat second)\n                           set))\n\n          (check-positions [board color]\n                           (->>\n                            (for [x (range 4)\n                                  y (range 4)]\n                              (let [eaten (check-position board color [x y])]\n                                (when (seq eaten)\n                                  [[x y] eaten])))\n                            (into {})))]\n    (check-positions board color)))", "user": "5fa74b82e4b0fa27300f3dda"}, {"problem": 124, "code": "(fn [a _]\n  (cond \n    (= a '[[e e e e]\n         [e w b e]\n         [e b w e]\n         [e e e e]])\n   {[1 3] #{[1 2]}, [0 2] #{[1 2]}, [3 1] #{[2 1]}, [2 0] #{[2 1]}}\n    (= a '[[e e e e]\n         [e w b e]\n         [w w w e]\n         [e e e e]])\n    {[3 2] #{[2 2]}, [3 0] #{[2 1]}, [1 0] #{[1 1]}}\n    (= a '[[e e e e]\n         [e w b e]\n         [w w b e]\n         [e e b e]])\n   {[0 3] #{[1 2]}, [1 3] #{[1 2]}, [3 3] #{[2 2]}, [2 3] #{[2 2]}}\n    (= a '[[e e w e]\n         [b b w e]\n         [b w w e]\n         [b w w w]])\n   {[0 3] #{[2 1] [1 2]}, [1 3] #{[1 2]}, [2 3] #{[2 1] [2 2]}}))", "user": "5e8ce2fee4b0cb0169546328"}, {"problem": 124, "code": "(let\n  [directions (for [x [-1 0 1]\n                    y [-1 0 1]\n                    :when (not= 0 x y)]\n                [x y])]\n  (letfn [(opponent\n            [color]\n            (case color\n              w 'b\n              b 'w))\n          (flipped-coords\n            ([board color square]\n             (->> directions\n                  (map (partial flipped-coords board color square))\n                  (reduce into #{})))\n            ([board color square direction]\n             (loop [flipped []\n                    sq square]\n               (let [sq (map + sq direction)\n                     piece (get-in board sq)]\n                 (condp = piece\n                   'e #{}\n                   nil #{}\n                   color flipped\n                   (opponent color) (recur (conj flipped sq) sq))))))\n\n          (legal-moves\n            [board color]\n            (into {}\n                  (for [x (range 4)\n                        y (range 4)\n                        :when (= (get-in board [x y]) 'e)\n                        :let [fl (flipped-coords board color [x y])]\n                        :when (seq fl)]\n                    [[x y] fl])))]\n    legal-moves))", "user": "5fc4e1f0e4b036c570ed8145"}, {"problem": 124, "code": "(fn [board piece]\n  (letfn [(rival []\n            (first (disj #{'w 'b} piece)))\n          (key-lines [[x y]]\n            (list (for [dy (reverse (range -3 0))] [x (+ y dy)])\n                  (for [dx (reverse (range -3 0)) dy (reverse (range -3 0)) :when (= dx dy)] [(+ x dx) (+ y dy)])\n                  (for [dx (reverse (range -3 0))] [(+ x dx) y])\n                  (for [dx (reverse (range -3 0)) dy (range 1 4) :when (= dx (- dy))] [(+ x dx) (+ y dy)])\n                  (for [dy (range 1 4)] [x (+ y dy)])\n                  (for [dx (range 1 4) dy (range 1 4) :when (= dx dy)] [(+ x dx) (+ y dy)])\n                  (for [dx (range 1 4)] [(+ x dx) y])\n                  (for [dx (range 1 4) dy (reverse (range -3 0)) :when (= dx (- dy))] [(+ x dx) (+ y dy)])))\n          (reversis [accum ptns]\n            (if (empty? ptns) #{}\n                (let [pos (first ptns)\n                      cur (get-in board pos)]\n                  (cond (= cur piece) (set accum)\n                        (= cur (rival)) (reversis (conj accum pos) (rest ptns))\n                        :else #{}))))\n          (check-pos [[x y]]\n            (let [res (remove empty? (map (partial reversis []) (key-lines [x y])))]\n              (if (empty? res) nil\n                  (reduce #(reduce % %2) res))))]\n    (into {} (for [i (range (count board)) j (range (count (board 0)))]\n               (if (not= (get-in board [i j]) 'e) nil\n                   (let [res (check-pos [i j])]\n                     (if (empty? res) nil\n                         [[i j] res])))))))", "user": "58f98231e4b0438e51c2cf4c"}, {"problem": 124, "code": "(fn all-together [board piece]\n  (letfn [(is-e [move board]\n            (= (get-in board move) 'e))\n\n          (opponent-at [piece move board]\n            (let [opp-map {'w 'b 'b 'w}\n                  opp (get opp-map piece)\n                  at (get-in board move)]\n              (if (= at opp) true false)))\n\n          (adjacent-opponents [piece move board]\n            (letfn [(get-adjacent-moves [move board]\n                      (let [poss (set (for [r (range (dec (first move)) (+ (first move) 2))\n                                            c (range (dec (second move)) (+ (second move) 2))\n                                            :when (not (= [r c] move))]\n                                        [r c]))]\n                        (set (filter #(get-in board %) poss))))] \n              (let [adj (get-adjacent-moves move board)]\n                (set (filter #(opponent-at piece % board) adj)))))\n\n          (moves-opp-opponent [p-rel opp-pos board]\n            (letfn [(get-q1-diag [move board]\n                      (loop [cur-move [(dec (first move)) (inc (second move))] res []]\n                        (if (get-in board cur-move)\n                          (recur [(dec (first cur-move)) (inc (second cur-move))] (conj res cur-move))\n                          res\n                          )\n                        )\n                      )\n\n                    (get-q2-diag [move board]\n                      (loop [cur-move [(dec (first move)) (dec (second move))] res []]\n                        (if (get-in board cur-move)\n                          (recur [(dec (first cur-move)) (dec (second cur-move))] (conj res cur-move))\n                          res\n                          )\n                        )\n                      )\n\n                    (get-q3-diag [move board]\n                      (loop [cur-move [(inc (first move)) (dec (second move))] res []]\n                        (if (get-in board cur-move)\n                          (recur [(inc (first cur-move)) (dec (second cur-move))] (conj res cur-move))\n                          res)))\n\n                    (get-q4-diag [move board]\n                      (loop [cur-move [(inc (first move)) (inc (second move))] res []]\n                        (if (get-in board cur-move)\n                          (recur [(inc (first cur-move)) (inc (second cur-move))] (conj res cur-move))\n                          res)))\n\n                    (get-y [move board]\n                      (loop [cur-move [(dec (first move)) (second move)] res []]\n                        (if (get-in board cur-move)\n                          (recur [(dec (first cur-move)) (second cur-move)] (conj res cur-move))\n                          res)))\n\n                    (get-neg-y [move board]\n                      (loop [cur-move [(inc (first move)) (second move)] res []]\n                        (if (get-in board cur-move)\n                          (recur [(inc (first cur-move)) (second cur-move)] (conj res cur-move))\n                          res)))\n\n                    (get-x [move board]\n                      (loop [cur-move [(first move) (inc (second move))] res []]\n                        (if (get-in board cur-move)\n                          (recur [(first cur-move) (inc (second cur-move))] (conj res cur-move))\n                          res)))\n\n                    (get-neg-x [move board]\n                      (loop [cur-move [(first move) (dec (second move))] res []]\n                        (if (get-in board cur-move)\n                          (recur [(first cur-move) (dec (second cur-move))] (conj res cur-move))\n                          res)))\n                    ]\n\n              (condp = p-rel \n                :q1 (get-q3-diag opp-pos board)\n                :y (get-neg-y opp-pos board)\n                :q2 (get-q4-diag opp-pos board)\n                :neg-x (get-x opp-pos board)\n                :q3 (get-q1-diag opp-pos board)\n                :neg-y (get-y opp-pos board)\n                :q4 (get-q2-diag opp-pos board)\n                :x (get-neg-x opp-pos board))))\n\n          (player-relation-to-opp [p-move opp-pos]\n            (letfn [(player-at-q1 [player-move opp-pos]\n                      (= player-move [(dec (first opp-pos)) (inc (second opp-pos))])\n                      )\n\n                    (player-at-y [player-move opp-pos]\n                      (= player-move [(dec (first opp-pos)) (second opp-pos)])\n                      )\n\n                    (player-at-q2 [player-move opp-pos]\n                      (= player-move [(dec (first opp-pos)) (dec (second opp-pos))])\n                      )\n\n                    (player-at-neg-x [player-move opp-pos]\n                      (= player-move [(first opp-pos) (dec (second opp-pos))])\n                      )\n\n                    (player-at-q3 [player-move opp-pos]\n                      (= player-move [(inc (first opp-pos)) (dec (second opp-pos))])\n                      )\n\n                    (player-at-neg-y [player-move opp-pos]\n                      (= player-move [(inc (first opp-pos)) (second opp-pos)])\n                      )\n\n                    (player-at-q4 [player-move opp-pos]\n                      (= player-move [(inc (first opp-pos)) (inc (second opp-pos))])\n                      )\n\n                    (player-at-x [player-move opp-pos]\n                      (= player-move [(first opp-pos) (inc (second opp-pos))])\n                      )]\n              (cond \n                (player-at-q1 p-move opp-pos) :q1\n                (player-at-y p-move opp-pos) :y\n                (player-at-q2 p-move opp-pos) :q2\n                (player-at-neg-x p-move opp-pos) :neg-x\n                (player-at-q3 p-move opp-pos) :q3\n                (player-at-neg-y p-move opp-pos) :neg-y\n                (player-at-q4 p-move opp-pos) :q4\n                (player-at-x p-move opp-pos) :x\n                :else :invalid\n                ))\n            )\n\n          (check-opposite-for-player [piece move opp-pose board]\n            (let [p-rel (player-relation-to-opp move opp-pose)\n                  opp-moves (moves-opp-opponent p-rel opp-pose board)]\n              (some #(= (get-in board %) piece) opp-moves)))\n\n\n          (player-opposite-of-any-opp [piece move board]\n  ;; For each opp position\n  ;; See the position of the player relative to it\n  ;; Get the positions opposite\n  ;; For each set of opposite positions, check if a player's in there\n  ;; If a player's in one of them, true, if not, false\n            (some #(check-opposite-for-player piece move % board) (adjacent-opponents piece move board)))\n\n\n          (is-legal-move [piece move board]\n            (if (and \n                 (is-e move board)\n                 (seq (adjacent-opponents piece move board))\n                 (player-opposite-of-any-opp piece move board)\n                 )true false)  \n            )\n\n          (get-legal-moves [piece board]\n            (let [moves (for [r (range (count board))\n                              c (range (count (first board)))\n                              :when (is-legal-move piece [r c] board)]\n                          [r c])]\n              (set moves)))\n\n;; (sort [[0 1] [0 2] [1 0] [0 0] ])\n          \n;; For all legal moves,\n;;  - Get all opp pos'\n;;  For each, \n;;  - Get opp pos' until player piece\n;;  - Return these moves\n;;  - Set a key of the legal move w/ the flips as the value\n          \n          (get-flipped [piece move opp-pos board]\n  ;; Assumes prescreened for legality.\n  ;; Get the pos\n            (let [p-rel (player-relation-to-opp move opp-pos)\n                  pos-opp-opp (moves-opp-opponent p-rel opp-pos board)\n                  other-flips (set (take-while #(not (= piece (get-in board %))) pos-opp-opp))] \n                  (conj other-flips opp-pos)\n    ;; p-rel\n    ;; pos-opp-opp\n            ;;  (println \"pos-opp-opp\" pos-opp-opp)\n            ;;  (println \"(map #(get-in board %) other-flips)\" (map #(get-in board %) other-flips))\n            ;;  (println \"(map #(get-in board %) pos-opp-opp)\" (map #(get-in board %) pos-opp-opp) conj other-flips opp-pos)\n              )\n            )\n\n          (get-opp-possies [piece move board]\n            (let [opp-possies (adjacent-opponents piece move board)\n                  valid-opps (filter #(check-opposite-for-player piece move % board) opp-possies)\n                  get-flipped-for-opp (fn [opp] (get-flipped piece move opp board))]\n              ;; (println \"opp-possies: \" opp-possies)\n              ;; (println \"valid-opps \" valid-opps)\n              ;; (println \"(get-flipped-for-opp %2)\" (get-flipped-for-opp (first valid-opps)))\n              (reduce #(into %1 (get-flipped-for-opp %2)) #{} valid-opps)\n              )\n            )]\n\n  ;; Get all legal moves\n  ;; Assoc to a map each move and their opp flips\n    (let [legals (get-legal-moves piece board)]\n      (reduce #(assoc %1 %2 (get-opp-possies piece %2 board)) {} legals)\n      ;; (println (first legals) (= board the-2nd-best-board))\n      ;; (println (first legals))\n      ;; (get-opp-possies piece (first legals) board)\n      ))\n)", "user": "5ff676a9e4b06df49cee1497"}, {"problem": 124, "code": "(fn reversi [board player] \n  (let [opponent (if (= player 'b) 'w 'b)\n        opennings (for [x (range 4) y (range 4) :when (= (get-in board [x y]) 'e)] [x y])]\n    (letfn [(lines [x y] [(map (fn [xr] [xr y]) (range 4))\n                          (map (fn [yr] [x yr]) (range 4))\n                          (for [r (range -4 4) :let [xr (+ x r) yr (+ y r)] :when (and (contains? (set (range 4)) xr) (contains? (set (range 4)) yr))] [xr yr])\n                          (for [r (range -4 4) :let [xr (- x r) yr (+ y r)] :when (and (contains? (set (range 4)) xr) (contains? (set (range 4)) yr))] [xr yr])])\n            (flipped [board line] (let [opponents-and-players (take-while #(not= 'e (get-in board %))\n                                                                          (drop-while #(= player (get-in board %))\n                                                                                      (drop-while #(not= player (get-in board %))\n                                                                                                  line)))\n                                        opponents (take-while #(= opponent (get-in board %)) opponents-and-players)]\n                                    (if (= (count opponents-and-players) (count opponents)) [] opponents)))\n            (check [x y] (set (mapcat (fn [line] (flipped (update-in board [x y] (constantly player)) line)) (lines x y))))]\n      (into {} (filter (fn [[k v]] (not (empty? v))) (map (fn [openning] [openning (apply check openning)]) opennings))))))", "user": "604d3cb1e4b0b7ec0ac60ac2"}, {"problem": 124, "code": "(fn reversi [game-board player-color]\n    (let [opponent-color (if (= player-color 'w) 'b 'w)\n          adjacent-cells [[-1 -1] [-1 0] [-1 1]\n                          [0  -1]        [0  1]\n                          [1  -1] [1  0] [1  1]]]\n      (letfn [(check-direction [iy ix [vy vx]]\n                  (loop [this-y (+ iy vy)\n                         this-x (+ ix vx)\n                         this-cell (get-in game-board [this-y this-x])\n                         flipped-pieces []]\n                      (cond\n                        (nil? this-cell) nil\n                        (= this-cell opponent-color)\n                            (recur\n                              (+ this-y vy)\n                              (+ this-x vx)\n                              (get-in game-board [(+ this-y vy) (+ this-x vx)])\n                              (conj flipped-pieces [this-y this-x]))\n                        (and (= this-cell player-color) (not-empty flipped-pieces))\n                            {[iy ix] (set flipped-pieces)})))\n              (clean-up [messy-data]\n                (->> messy-data\n                  (map #(remove nil? %))\n                  (remove empty?)\n                  (map first)\n                  (apply (partial merge-with conj))))]\n          (clean-up (for [y [0 1 2 3], x [0 1 2 3]]\n             (if (= (get-in game-board [y x]) 'e)\n                 (map\n                   #(if (get-in game-board (map + % [y x])) (check-direction y x %))\n                   adjacent-cells)))))))", "user": "5f548678e4b0a0bc16850a7e"}, {"problem": 124, "code": "(fn reversi\n  [board player]\n  (let [opposite '{b w w b}\n        directions (remove #(= [0 0] %) (for [i [-1 0 1]\n                                              j [-1 0 1]]\n                                          [i j]))\n        board-map (into {} (for [i (range 4)\n                                 j (range 4)]\n                             [[i j] (get-in board [i j])]))\n        empty-pos (map key (filter #(= 'e (val %)) board-map))\n        walk (fn [pos direction]\n               (take-while board-map\n                           (rest (iterate (fn [p]\n                                            (map + p direction))\n                                          pos))))\n        valid-line (fn [line]\n                     (let [line-str (apply str (map board-map line))\n                           pattern (re-pattern (str (opposite player) \"+\" player))]\n                       (when (re-find pattern line-str)\n                         (take-while #(= (opposite player) (board-map %)) line))))\n        valid-pos (fn [pos]\n                    (set (apply concat (keep valid-line\n                                             (map #(walk pos %) directions)))))]\n    (into {} (for [pos empty-pos\n                   :let [fliped (valid-pos pos)]\n                   :when (not-empty fliped)]\n               [pos fliped]))))", "user": "4e586949535d8a8b8723a292"}, {"problem": 124, "code": "(fn legal-moves\n  [board color]\n  (let [opp '{b w, w b}]\n    (letfn [(pieces\n              [board color]\n              (filter #(= color (get-in board %))\n                      (for [row (range (count board))\n                            col (range (count (first board)))]\n                        [row col])))\n            (neighbours\n              [board [row col]]\n              (filter (fn [[row col]] (and (<= 0 row (dec (count board)))\n                                           (<= 0 col (dec (count (first board))))))\n                      (for [row [(dec row) row (inc row)]\n                            col [(dec col) col (inc col)]]\n                        [row col])))\n            (neighbour-ray\n              [board pos dir]\n              (->> (iterate (fn [pos] (mapv + pos dir)) pos)\n                   (take-while (fn [[row col]] (and (<= 0 row (dec (count board)))\n                                                    (<= 0 col (dec (count (first board)))))))\n                   (drop 1)))](apply merge (for [pos (pieces board color)\n                                row-dir [-1 0 1]\n                                col-dir [-1 0 1]\n                                :when (or (not= 0 row-dir)\n                                          (not= 0 col-dir))\n                                :let [dir [row-dir col-dir]\n                                      ray (neighbour-ray board pos dir)]\n                                :when (= (opp color) (get-in board (first ray)))\n                                :let [[opp-pieces rest-pieces] (partition-by #(get-in board %) ray)]\n                                                 :when (not (empty? rest-pieces))]\n                            {(first rest-pieces) (set opp-pieces)})))))", "user": "60460824e4b02d28681c77bc"}, {"problem": 124, "code": "(fn [b p]\n   (let [[o p] (if (= p 'w)\n                 [\\b \\w]\n                 [\\w \\b])\n\n         b (map (fn [row i]\n                  (map (fn [el j]\n                         {:val el :i [i j]}) row (-> b first count range))) b (-> b count range))\n         df (->> b\n                 flatten\n                 (group-by #(apply + (% :i)))\n                 vals)\n         db (->> b\n                 flatten\n                 (group-by #(apply - (% :i)))\n                 vals)\n         bT (apply map vector b)\n         all (concat b df db bT)\n         qualified (filter #(> (count %) 2) all)\n         qualified (concat  (map #(partition 4 1 %) qualified)\n                            (map #(partition 3 1 %) qualified))\n         qualified (apply concat qualified)\n         ; _ (#break inc 3)\n         reversed-qualified (map reverse qualified)\n\n         all (concat qualified reversed-qualified)]\n     (reduce (fn [sofar q]\n               (let [j (->> q\n                            (map #(% :val))\n                            (clojure.string/join \"\"))]\n                 (cond\n                   (= j (str \"e\" o o p))\n                   (assoc sofar (-> q first :i) #{(-> q second :i) (-> q (nth 2) :i)})\n\n                   (= j (str p o o \"e\"))\n                   (assoc sofar (-> q last :i) #{(-> q second :i) (-> q (nth 2) :i)})\n\n                   (= j (str \"e\" o p))\n                   (assoc sofar (-> q first :i) #{(-> q second :i)})\n\n                   (= j (str p o \"e\"))\n                   (assoc sofar (-> q last :i) #{(-> q second :i)})\n\n                   :else\n                   sofar))) {} all)))", "user": "608ec5e4e4b03bd49d9f36c0"}]