[{"code": "(fn [c]\r\n  (reduce #(into % (for [x %]\r\n                     (conj x %2)))\r\n          #{#{}}\r\n          c))", "problem": 85, "user": "4dabb7b1950ed6eda1bd72f3"}, {"code": "(fn [r %]\r\n  (r (fn [% b]\r\n       (r #(conj % (conj %2 b)) % %))\r\n     #{#{}} %))\r\nreduce", "problem": 85, "user": "4dce6e41535d5973398f92a2"}, {"code": "(fn P [S]\r\n  (if (empty? S) #{S}\r\n    (let [e (first S)\r\n          T (disj S e)\r\n          PT (P T)\r\n          F (fn [e T] (set (map #(conj % e)  T)))]\r\n    (set (concat PT (F e PT))))))", "problem": 85, "user": "4dada16fc9a9d6ed2699dc57"}, {"code": "(fn tmp ([s] (tmp s #{}))\r\n  ([s accum]\r\n    (println s \":\" accum)\r\n    (if (empty? s) (conj accum #{})\r\n      (let [t1 (conj accum #{})\r\n            t2 (reduce #(conj %1 (conj %2 (first s))) t1 t1)\r\n            t3 (conj t2 (set (rest s)))\r\n            t4 (conj t3 (set s))]\r\n        (tmp (rest s) t4)))))", "problem": 85, "user": "4dbdab4e535d020aff1edf49"}, {"code": "(fn [s]\r\n       (let [items (into #{} (for [i s] #{i}))]\r\n         (loop [acc items]\r\n           (if (or (empty? acc) (contains? acc s))\r\n             (into #{#{}} acc)\r\n             (recur (into acc\r\n                          (for [s1 acc, s2 items]\r\n                            (clojure.set/union s1 s2))))))))", "problem": 85, "user": "4daddc19c9a9d6ed4599dc57"}, {"code": "(fn ps [s]\r\n  (if (seq s)\r\n\t    (let [ss (ps (rest s))]\r\n\t\t (apply conj (set ss) (map (fn[ns] (set (cons (first s) ns))) ss)))\r\n\t#{#{}}))", "problem": 85, "user": "4dc42799c647a3c54c2ddc71"}, {"code": "(fn [s]\r\n  (letfn [(select-bits [s bits]\r\n            (set (for [[elem bit]\r\n                       (map vector s (iterate (partial * 2) 1))\r\n                       :when (pos? (bit-and bit bits))]\r\n                   elem)))]\r\n    (set\r\n     (map select-bits\r\n          (repeat s)\r\n          (range 0 (bit-shift-left 1 (count s)))))))", "problem": 85, "user": "4dd4034a535dae65d5c462df"}, {"code": "(fn [s]\r\n  ((fn [s ps]\r\n    (if (empty? s) ps\r\n      (recur (rest s)\r\n        (reduce conj ps\r\n          (map #(conj % (first s)) ps)))))\r\n  s #{#{}}))", "problem": 85, "user": "4dc1ee85535d020aff1edf91"}, {"code": "(fn [s]\r\n(set\r\n  (map\r\n\t(fn [x] (set (keys (filter #(= \\1 (val %)) (zipmap s x)))))\t    \r\n      (map \r\n    #(reverse (Integer/toString % 2))\r\n    (range (int (Math/pow 2 (count s))))))))", "problem": 85, "user": "4db85282535d1e037afb218a"}, {"code": "(fn power-set [ls]\r\n        (if (empty? ls)\r\n            #{#{}}\r\n            (let [ps (power-set (rest ls))\r\n                  f (first ls)]\r\n                  (into ps (map #(conj % f) ps)))))", "problem": 85, "user": "4dd62278535d2dad7130b5c7"}, {"code": "(letfn [\r\n  (zero-pad [length string]\r\n\t\t(let [difference (- length (count string))]\r\n\t\t\t(apply str (concat (repeat difference \\0) string))))\r\n\t(bit-strings [length]\r\n\t\t(map (comp (partial zero-pad length) #(Integer/toString % 2)) (range (int (Math/pow 2 length)))))\r\n\t(keep-where-1 [coll bits]\r\n\t\t(for [[x b] (map vector coll bits) :when (= b \\1)] x))]\r\n\t\t\r\n\t(fn power-set [s]\r\n\t\t(set (map (comp set (partial keep-where-1 s)) (bit-strings (count s))))))", "problem": 85, "user": "4dd6d6a0535d2dad7130b5ca"}, {"code": "(fn ! [s] (if (empty? s) #{#{}}\r\n  (let [p (! (rest s))]\r\n     (reduce conj p (map #(conj % (first s)) p)))))", "problem": 85, "user": "4ddbd934535d02782fcbe9fc"}, {"code": "(fn [s]\r\n  (let [len (count s)\r\n        half (Math/ceil (/ len 2))]\r\n    (letfn ((sub [s n h]\r\n                 (cond (= n 0)\r\n                       #{#{}}\r\n                       (= n 1)\r\n                       (reduce (fn [r v]\r\n                                 (conj r (conj h v)))\r\n                               #{}\r\n                               s)\r\n                       :else\r\n                       (reduce (fn [r v]\r\n                                 (clojure.set/union r (sub (disj s v) (- n 1) (conj h v))))\r\n                               #{}\r\n                               s)))\r\n            (sub2 [s2]\r\n                  (reduce (fn [r v]\r\n                            (conj r (clojure.set/difference s v)))\r\n                          #{}\r\n                          s2)))\r\n           (reduce (fn [r n]\r\n                     (if (> n (/ len 2))\r\n                       (clojure.set/union r (sub2 (sub s (- len n) #{})))\r\n                       (clojure.set/union r (sub s n #{}))))\r\n                   #{}\r\n                   (range (+ len 1))))))", "problem": 85, "user": "4de2f44f535d08e6dec9fdec"}, {"code": "(fn [sx]\r\n    (let [xs (seq sx)\r\n          n (count xs)\r\n          m (Math/pow 2 n)]\r\n    (set (map set (for [i (range m)]\r\n        (for [j (range n) :when (bit-test i j)]\r\n          (nth xs j)))))))", "problem": 85, "user": "4dd61f98535d2dad7130b5c6"}, {"code": "(fn power-set [lst]\r\n  (loop [ls lst xs #{#{}}]\r\n    (if (nil? (first ls))\r\n      (set xs)\r\n      (recur (rest ls) (concat xs (map #(conj % (first ls)) xs))))))", "problem": 85, "user": "4ddc620d535d02782fcbea06"}, {"code": "(fn [i-set]\r\n     (println (seq i-set))\r\n     (apply hash-set (map\r\n       (fn [i-bit]\r\n           ((fn my-get\r\n               ([my-bit] (my-get #{} my-bit (dec (count i-set))))\r\n               ([result my-bit position]\r\n                (if (zero? (count my-bit))\r\n                  result\r\n                  (my-get\r\n                    (if (= 1 (last my-bit))\r\n                      (conj result (nth (seq i-set) position))\r\n                      result)\r\n                    (drop-last my-bit)\r\n                    (dec position)))))\r\n            i-bit))\r\n       (map\r\n           (fn [i-num] (map #(Integer/parseInt (str %)) (Integer/toString i-num 2)))\r\n           (range (apply * (repeat (count i-set) 2)))))))", "problem": 85, "user": "4dddf817535d08e6dec9fdd3"}, {"code": "(fn power [items]\r\n  (if (empty? items)\r\n    #{#{}}\r\n    (let [item (first items)\r\n          others (disj items item)\r\n          other-powers (power others)]\r\n      (set (concat other-powers\r\n                   (map #(conj % item) other-powers))))))", "problem": 85, "user": "4ddc1c89535d02782fcbea01"}, {"code": "(fn [s]\r\n  (reduce \r\n    (fn [i e] \r\n      (set (concat i (map #(conj % e) i) [#{e}])))\r\n    #{#{}} s))", "problem": 85, "user": "4dc986d0535d5973398f9285"}, {"code": "(fn powerset [s]\r\n  (if (empty? s) #{#{}}\r\n    (into (powerset (rest s))\r\n      (map #(conj % (first s))\r\n                      (powerset (rest s))))))", "problem": 85, "user": "4ddbfb8a535d02782fcbea00"}, {"code": "(fn [p] (set (reduce #(concat (map (fn [x] (conj x %2)) %) %) #{#{}} p)))", "problem": 85, "user": "4df1ce44535d08e6dec9fe1f"}, {"code": "(fn power-set [s]\r\n  (if (empty? s)\r\n    #{#{}}\r\n    (let [[h & rs] (seq s)\r\n          rp (power-set rs)]\r\n      (set (concat rp (map #(conj % h) rp))))))", "problem": 85, "user": "4dfd4ba8535d04ed9115e781"}, {"code": "(fn p [c]\r\n  (set\r\n    (if-let [[f & r] (seq c)] \r\n      (concat \r\n        (map #(conj % f) (p r))\r\n        (p r))\r\n      [#{}])))", "problem": 85, "user": "4e03c616535d04ed9115e796"}, {"code": "(fn [set]\r\n   (letfn [(init-set [s]\r\n             (reduce #(conj %1 #{%2}) #{} s))]\r\n     (conj\r\n      (loop [xs (init-set set) acc (init-set set)]\r\n        (let [x (ffirst xs)]\r\n          (if xs\r\n            (recur (next xs) (reduce #(conj %1 (conj %2 x))\r\n                                     acc acc))\r\n            acc)))\r\n      #{})))", "problem": 85, "user": "4e0d8c27535d04ed9115e7b7"}, {"code": "(fn [s]\r\n  (reduce \r\n    (fn [init e] \r\n      (set (concat init (map #(conj % e) init) [#{e}])))\r\n    #{#{}} s))", "problem": 85, "user": "4e0e0529535d04ed9115e7b9"}, {"code": "(fn [s]\r\n  (reduce \r\n    (fn [init e] \r\n      (set (concat init (map #(conj % e) init) [#{e}])))\r\n    #{#{}} s))", "problem": 85, "user": "4e1158aa535d04ed9115e7c6"}, {"code": "(fn [s]\r\n  (loop [i 0 r  #{#{}}]\r\n    (if (= i (count s)) r\r\n      (recur (inc i) \r\n        (into #{} \r\n          (conj \r\n            (mapcat #(map (partial conj %) s) r)\r\n           #{}))))))", "problem": 85, "user": "4deff9f9535d08e6dec9fe15"}, {"code": "(fn [setxx] (\n  letfn [\n    (index-combinations\n      [n cnt]\n      (lazy-seq\n       (let [c (vec (cons nil (for [j (range 1 (inc n))] (+ j cnt (- (inc n)))))),\n       iter-comb\n       (fn iter-comb [c j]\n         (if (> j n) nil\n             (let [c (assoc c j (dec (c j)))]\n         (if (< (c j) j) [c (inc j)]\n             (loop [c c, j j]\n               (if (= j 1) [c j]\n             (recur (assoc c (dec j) (dec (c j))) (dec j)))))))),\n       step\n       (fn step [c j]\n         (cons (rseq (subvec c 1 (inc n)))\n         (lazy-seq (let [next-step (iter-comb c j)]\n               (when next-step (step (next-step 0) (next-step 1)))))))]\n         (step c 1))))\n\n(getstuff [numdigs setsize]\n  (index-combinations  numdigs setsize))\n\n(powerset [setxx] (let [\n  myset setxx\n  sets (reduce (fn [s d](concat (getstuff d (count myset)) s)) #{} (range 1 (count myset)))\n  stuff (set (map set\n    (map\n      (fn [s] (map (vec myset) s)) sets)))]\n  (set (concat  [#{}] [setxx] stuff))))\n]\n(powerset setxx)))", "problem": 85, "user": "4daa374930acd6ed13482a68"}, {"code": "(fn powerset [menge]\n(if (empty? menge)\n  #{#{}}\n  (set (clojure.set/union (map #(conj % (first menge)) (powerset (rest menge)))\n         (powerset (rest menge))))))", "problem": 85, "user": "4e28120f535deb9a81d77efa"}, {"code": "(fn pwrset [s]\n  (if (zero? (count s))\n    #{#{}}\n    (loop [result #{}, seed #{#{}}, lim (count s)]\n      (let [result (reduce conj result seed)\n            seed (set (for [x s, coll seed] (conj coll x)))]\n        (if (pos? lim)\n          (recur result seed (dec lim))\n          (into #{} result))))))", "problem": 85, "user": "4ddbdc1b535d02782fcbe9fd"}, {"code": "(fn p [c]\n  (if (empty? c) #{#{}}\n    (let [r (p (rest c))]\n      (clojure.set/union r (apply hash-set (map #(conj % (first c)) r))))))", "problem": 85, "user": "4e14108c535d04ed9115e7dd"}, {"code": "(fn powerset [s]\n  (loop [ps #{#{}} s s]\n    (if (empty? s)\n      ps\n      (recur (clojure.set/union \n               ps\n               (into #{} (map\n                           #(clojure.set/union\n                              (into #{} [(first s)])\n                              %) ps)))\n             (rest s)))))", "problem": 85, "user": "4e123905535d04ed9115e7ce"}, {"code": "(fn [s]\n  (reduce \n    (fn [init e] \n      (set (concat init (map #(conj % e) init) [#{e}])))\n    #{#{}} s))", "problem": 85, "user": "4e16bdef535d04ed9115e7e9"}, {"code": "(fn pow-set [s]\n  (let [split-set (vec (map #(conj #{} %) s)) ]\n    (loop [pset (conj split-set #{}) current (first split-set) rest-set (rest split-set)]\n      (if ((set pset) s)\n        (set pset)\n        (recur (concat pset (map #(clojure.set/union current %) (disj (set pset) current)))\n               (first rest-set)\n               (rest rest-set))\n        ))))", "problem": 85, "user": "4df3df8a535d08e6dec9fe2d"}, {"code": "(fn[x] (set ((fn f [r]\n  (let [c (first r)\n        r (rest r)]\n    (println c r)\n    (if c\n      (let [p (f r)]\n        (concat p (map #(conj % c) p)))\n      #{#{}}))) x)))", "problem": 85, "user": "4e12cc9d535d04ed9115e7d2"}, {"code": "(fn [items]\n  (letfn [(powerset [s]\n  \t    (if (empty? s)\n\t\t      [#{}]\n\t\t      (let [head (powerset (drop 1 s))\n\t\t\t    r (first s)]\n\t\t\t(concat head (for [i head] (conj i r))))))]\n    (set (powerset items))))", "problem": 85, "user": "4e513ecf535dc968683fc4f6"}, {"code": "#(set (for [x (%2 (Math/pow 2 (% %3)))]\n        (set (for [y (%2 (% %3)) :when (bit-test x y)]\n               ((vec %3) y)))))\ncount range", "problem": 85, "user": "4e52d815535d302ef430da77"}, {"code": "(fn power-set\n  [S]\n  (if (empty? S)\n    #{ #{} }\n    (let [e (first S)\n          S- (disj S e)\n          T (power-set S-)]\n      (into T (map #(conj % e) T)))))", "problem": 85, "user": "4e50b67b535dc968683fc4ed"}, {"code": "(fn [c]\n  (set\n    (if (empty? c)\n      #{#{}}\n      (map (fn [m]\n               (set (reduce into\n                      (map #(if (= \\1 %) #{%2}) m c))))\n           (map #(reverse (Integer/toString % 2)) (range (Math/pow 2 (count c))))))))", "problem": 85, "user": "4e49badd535dc968683fc4c9"}, {"code": "(fn [s]\r\n  (set (for [i (range (Math/pow 2 (count s)))]\r\n      (set (keep-indexed #(if (bit-test i %1) %2) s)))))", "problem": 85, "user": "4e4ad154535dc968683fc4d1"}, {"code": "(fn [s] \n  (reduce \n    (fn [s e] (into s (map #(conj % e) s))) \n    #{#{}} \n    s))", "problem": 85, "user": "4e5c801e535d8a8b8723a2c1"}, {"code": "(fn powerset [xs]\n  (let [n (count xs)\n        m (Math/pow 2 n)]\n    (set (for [i (range m)]\n           (set (for [j (range n) :when (bit-test i j)]\n                  (nth (seq xs) j)))))))", "problem": 85, "user": "4dad7adac9a9d6ed0599dc57"}, {"code": "(fn[a-set]\n  (let [p-seq (atom []) \n        ll    (atom [])]\n    (swap! p-seq conj a-set)\n    (loop [ps @p-seq]\n      (doseq [seq-elem ps]\n        (doseq [elem seq-elem]\n          (reset! ll (set [elem]))\n          (when (not (some #(= % @ll) @p-seq))\n            (swap! p-seq conj @ll))\n          (reset! ll (set (remove #(= elem %) seq-elem)))\n          (when (not (some #(= % @ll) @p-seq))\n            (swap! p-seq conj @ll))))\n      (when (not= (count ps) (count @p-seq))\n        (recur @p-seq)))\n    (set (swap! p-seq conj #{}))))", "problem": 85, "user": "4e58bcd4535d8a8b8723a296"}, {"code": "(fn powerset\n  [s]\n  (if-let [sq (seq s)]\n    (let [h (first sq)\n          r (next sq)\n          psr (powerset r)]\n      (reduce conj (into #{} (map #(conj % h) psr))\n              psr))\n    #{#{}}))", "problem": 85, "user": "4e5914e0535d8a8b8723a29b"}, {"code": "(fn [s]\n  (reduce \n    (fn [r e]\n      (into r (map #(conj % e) r))) \n    #{#{}}\n    s))", "problem": 85, "user": "4e5411e8535d8a8b8723a279"}, {"code": "(fn power-set [xset]\n  (let [indexes (vec xset)]\n    (set\n     (map\n      (fn [x]\n        (->> (filter #(bit-test x %) (range (/ (Math/log (inc x)) (Math/log 2))))\n             (select-keys indexes)\n             (vals)\n             (set)))\n      (range (Math/pow 2 (count xset)))))))", "problem": 85, "user": "4e68c434535d8ccf87e9fe89"}, {"code": "(fn p [s]\n         (if (empty? s)\n             #{#{}}\n           (set (for [a (p (rest s))\n                      x [a (into a [(first s)])]]\n                     x))))", "problem": 85, "user": "4e5fe31a535d8ccf87e9fe50"}, {"code": "(fn ps [s]\n  (if (empty? s) \n    #{#{}}\n    (set \n      (mapcat \n        (fn [x] [x (conj x (first s))]) \n        (ps (rest s))))\n))", "problem": 85, "user": "4e6e10d8535d5021c1a895fd"}, {"code": "(fn power [s]\n  (if (empty? s)\n     #{#{}}\n     (let [x (set (list (first s))) \n           dx (clojure.set/difference s x) \n           t (power dx)]\n  \t   (clojure.set/union t \n         (map (partial into x) t)))))", "problem": 85, "user": "4e6e3a1e535d5021c1a89602"}, {"code": "(fn [s-all]\n  (let [f (let [v (vec s-all)]\n            (fn [s]\n              (let [b (drop-while s v)]\n                (conj (clojure.set/intersection s (set b))\n                      (first b)))))]\n    (set (take (reduce * (repeat (count s-all) 2))\n               (iterate f #{})))))", "problem": 85, "user": "4db1bfe21254ad5b4805fa71"}, {"code": "(fn power-set [s]\n  (let [v (vec s)\n        l (count v)]\n    (letfn [(add-set [s n]\n              (->> (reduce (fn [s m]\n                             (if (= 0 (bit-and n (int (Math/pow 2 m))))\n                               s\n                               (conj s (v m))))\n                           #{}\n                           (range l))\n                   (conj s)))]\n      (reduce add-set #{} (range (Math/pow 2 l))))))", "problem": 85, "user": "4e5bff2b535d8a8b8723a2bd"}, {"code": "(letfn [(k-combinations [k s]\n  (let [pool  (vec s)\n        n     (count pool)\n        zip   (partial map vector)]\n    (cond\n      (zero? k) #{#{}}\n      (or (zero? n) (> k n)) #{}\n      (= 1 k) (set (map hash-set pool))\n      (= k n) #{s}\n      true (let [rs (reverse (range k))\n                 fi (fn [[i j :as x]]\n                      (if (not= j (- (+ i n) k))\n                        x))\n                 yield (comp set (partial map (partial nth pool)))]\n             (loop [js (range k)\n                    ac #{(yield js)}]\n               (if-let [[i j] (some fi (zip rs (reverse js)))]\n                 (let [js (take k (concat (take i js) (iterate inc (inc j))))]\n                   (recur (vec js) (conj ac (yield js))))\n                 ac))))))]\n  (fn [s]\n    (reduce into #{s}\n            (for [k (range (count s))]\n              (k-combinations k s)))))", "problem": 85, "user": "4e6a412e535d8ccf87e9feb6"}, {"code": "(fn powerset [xs]\n  (loop [xs (seq xs) result #{#{}}]\n    (if-let [[x & more] xs]\n      (recur more (into result (for [set result] (conj set x))))\n    result)))", "problem": 85, "user": "4e593dac535d8a8b8723a29c"}, {"code": "(fn p [s]\r\n    (if (empty? s) \r\n      #{#{}}\r\n      (let [[f & r] (seq s) t (p r)]\r\n        (into t (map #(conj % f) t)))))", "problem": 85, "user": "4e707db6535d5021c1a8963a"}, {"code": "(fn power-set [source-set]\n  (if (empty? source-set)\n      #{#{}}\n      (let [subset (power-set (rest source-set))]\n        (into subset\n              (map #(conj % (first source-set)) subset)))))", "problem": 85, "user": "4e7c8fd1535db169f9c796be"}, {"code": "(fn [s]\n  (let [arr (into [] s), c (count arr)]\n    (reduce \n      (fn[s num] \n        (conj s (into #{} (filter #(not= nil %) (map-indexed #(if (bit-test num %) %2 nil) arr)))))\n      #{} \n      (range (Math/pow 2 c)))))", "problem": 85, "user": "4e7db3b4535db169f9c796e1"}, {"code": "#((fn f [[a & s :as q]]\n    (if q\n      (into (f s) (for [i (f s)] (conj i a)))\n      #{#{}}))\n  (seq %))", "problem": 85, "user": "4db858d1535d1e037afb218c"}, {"code": "(fn power-set [xs]\n  (let [add-element (fn [acc x]\n    (concat (map #(conj % x) acc) acc))]\n  (->> xs (reduce add-element '(#{})) (set))))", "problem": 85, "user": "4e691c79535d8ccf87e9fe97"}, {"code": "(fn ps [s] (if (seq s)\n             (let [ss (ps (rest s))]\n               (clojure.set/union (set (map #(conj % (first s)) ss)) ss))\n             #{#{}}))", "problem": 85, "user": "4e8612f8535db62dc21a62f2"}, {"code": "(fn pow [s]\r\n  (if (empty? s) #{#{}}\r\n      (let [p (pow (rest s))]\r\n        (set (concat p (map #(conj % (first s)) p))))))", "problem": 85, "user": "4e8681b7535dae1a5effa438"}, {"code": "(fn [s]\n (set\n  (for [ n (range (Math/pow 2 (count s))) ]\n     (set (keep-indexed \n        #(if (bit-test n %1) %2)\n        s)))))", "problem": 85, "user": "4e860e85535db62dc21a62f1"}, {"code": "(fn pow [s]\n   (if (empty? s)\n     #{#{}}\n     (let [e (first s) p (pow (rest s))]\n       (into p (map #(conj % e) p)))))", "problem": 85, "user": "4e8510e7535db62dc21a62e7"}, {"code": "(fn powerset [s]\n   (letfn [(f [n ps]\n             (if (zero? n) ps\n                 (f (dec n)\n                    (set (concat ps (mapcat (fn [a] (map #(conj % a) ps)) s))))))]\n     (f (count s) #{#{}})))", "problem": 85, "user": "4e89f46c535d3e98b8023288"}, {"code": "(fn p [s]\n  (if-let [[a & b] (seq s)]\n    (let [s (p b)]\n      (set (concat s (map #(conj % a) s))))\n    #{#{}}))", "problem": 85, "user": "4e71705e535d5021c1a89649"}, {"code": "(fn [m]\n  ((fn p [s]\n    (if (contains? s #{})\n      s\n      (p (into s \n        (into #{} (mapcat (fn [ss] (map #(disj ss %)ss)) s))))))\n  #{m}))", "problem": 85, "user": "4e8e8c24535d65386fec2143"}, {"code": "(fn x [s] \r\n  (if (= 10 (count s)) (range 1024)\r\n  (set (cons s (mapcat #(x (disj s %)) s)))))", "problem": 85, "user": "4db92654535d1e037afb21a0"}, {"code": "(fn p [x]\n  (conj (set (map set (reduce (fn [v i] (concat (map #(flatten (list %)) v) (map #(flatten (list % i)) v))) x x))) #{}))", "problem": 85, "user": "4e80e0f2535db62dc21a62b8"}, {"code": "#(reduce (fn [x y]\n           (into x (for [a %\n                         b x]\n                     (disj b a)))) \n         #{%}\n         %)", "problem": 85, "user": "4e823ed7535db62dc21a62c7"}, {"code": "(fn ps[s]\n  (letfn [(ff [e t] (set (map #(clojure.set/union #{e} %) t)))] \n   (if (empty? s)\n\t     #{#{}}\n\t   (let [e (first s)\n\t\t   t (clojure.set/difference s #{e})]\n\t     (clojure.set/union (ps t) (ff e (ps t)))))))", "problem": 85, "user": "4e842ebb535db62dc21a62df"}, {"code": "(fn p [s]\r\n    (if (empty? s)\r\n\t    #{#{}}\r\n\t    (into (p (rest s))\r\n\t\t  (map #(conj % (first s)) (p (rest s))))))", "problem": 85, "user": "4e821ca5535db62dc21a62c2"}, {"code": "(fn p [s]\n  (if-let [[x & xs] (seq s)]\n    (set (mapcat (fn [y] [y (conj y x)]) (p xs)))\n    #{#{}}))", "problem": 85, "user": "4e8f1ac6535d65386fec2146"}, {"code": "(fn ps [s]\n  (set (map set (reduce #(concat (map (fn [e] (cons %2 e)) %1) %1) #{#{}} s))))", "problem": 85, "user": "4e6a2f51535d8ccf87e9fea9"}, {"code": "(fn [s]\n  (if (= 10 (count s)) (repeat 1024 1)\n  ({#{1 :a} #{#{1 :a} #{:a} #{} #{1}}\n    #{} #{#{}} #{1 2 3} #{#{} #{1} #{2} #{3} #{1 2} #{1 3} #{2 3} #{1 2 3}}} s)))", "problem": 85, "user": "4dfe65a1535d04ed9115e787"}, {"code": "(fn power [s]\n  (if\n    (empty? s) #{#{}}\n    (let [f (first s) r (rest s) rp (power r)]\n      (into rp (map #(conj % f) rp)))))", "problem": 85, "user": "4e951f44535dbda64a6f6b30"}, {"code": "(fn power-set\r\n  [s]\r\n\t(if (empty? s)\r\n\t\t#{s}\r\n\t\t(let [e (first s)\r\n\t\t\t\t\tsmaller-set (disj s e)]\r\n\t\t\t(set (concat (power-set smaller-set) (for [o (power-set smaller-set)] (conj o e)))))))", "problem": 85, "user": "4e8a0c82535d3e98b802328d"}, {"code": "(fn ps [s]\n   (if (empty? s) #{#{}}\n       (let [x (first s), r (rest s)]\n         (if (empty? r) #{#{} #{x}}\n             (clojure.set/union\n              #{#{x}}\n              (ps r)\n              (set (map #(into % #{x}) (ps r))))))))", "problem": 85, "user": "4ea1b9e4535d7eef308072b8"}, {"code": "(fn [x]\n    (loop [[a & m] (seq x) r #{#{}}]\n      (if a\n        (recur m (clojure.set/union r (map #(conj % a) r)))\n        r))\n  )", "problem": 85, "user": "4e50e2a0535dc968683fc4ef"}, {"code": "(fn [s]\n  (let [bit-filter (fn [items mask]\n                     (set\n                       (keep-indexed\n                         (fn [idx item]\n                            (if (bit-test mask idx)\n                                item))\n                          items)))]\n    (set (for [mask (range 0 (Math/pow 2 (count s)))]\n            (bit-filter s mask)))))", "problem": 85, "user": "4e2b1d48535deb9a81d77f03"}, {"code": "(fn pp \n  ([s] (pp s #{#{}})) \n  ([s p] (if (nil? (first s)) \n             (set p) \n             (recur (rest s) (concat p (map #(conj % (first s)) p))))))", "problem": 85, "user": "4dae916eedd6309eace4d155"}, {"code": "(fn powerset [s]\n  (if (empty? s)\n    #{#{}}\n    (let [el (first s)\n          ps (powerset (rest s))]\n      (clojure.set/union\n        ps\n        (map #(conj % el) ps)))))", "problem": 85, "user": "4e89ddf9535d3e98b8023284"}, {"code": "(fn [s]\n  (set\n   (let [r range\n         c count\n         p #(Math/pow % %2)\n         e (map list (map #(int (p 2 %)) (r (c s))) s)]\n     (for [i (r 0 (p 2 (c s)))]\n       (set (map second (filter #(< 0 (bit-and (nth % 0) i)) e)))))))", "problem": 85, "user": "4e96557d535dbda64a6f6b43"}, {"code": "(partial reduce\n         (fn [acc i] (into acc (map #(conj % i) acc)))\n         #{#{}})", "problem": 85, "user": "4e9660ec535dbda64a6f6b44"}, {"code": "(fn [s]\n  (letfn\n      [(subset-sums [s] (set (map #(apply + %) (filter #(not (empty? %)) (subsets s)))))\n       (subsets [s] (map #(bit-filter s %) (range (two-raised (count s)))))\n       (bit-filter [s m] (let [indexed-elts (zipmap (range) s)]\n                           (set (filter #(not (nil? %))\n                                        (map #(if (bit-test m (% 0)) (% 1))\n                                             indexed-elts)))))\n       (two-raised [n] (apply * (take n (repeat 2))))]\n    (set (subsets s))))", "problem": 85, "user": "4dbb0f2d535d1e037afb21b1"}, {"code": "(fn [s]\n  \n  (letfn [(all\n  ([] #{#{}})\n  ([x & xs]\n    (lazy-seq \n      (let [r (apply all xs)]\n        (into r (map #(conj % x) (into r #{#{x}})))))))]\n   (set (apply all s))))", "problem": 85, "user": "4ea41fc2535d7eef308072cb"}, {"code": "#(letfn [\n  (create-set [x v i c]\n    (if (= i (count v))\n      c\n      (recur x v (inc i) (if (bit-test x i) (conj c (v i)) c))))]\n  (let [v (vec %)]\n    (set (for [x (range (int (Math/pow 2 (count v))))]\n      (create-set x v 0 #{})))))", "problem": 85, "user": "4e8f4f64535d65386fec2149"}, {"code": "(fn f [s]\n  (set\n    (reduce #(concat %1 (map (fn[x] (set (cons %2 x))) %1)) #{#{}} s)))", "problem": 85, "user": "4dbd2aa3535d020aff1edf40"}, {"code": "(fn pow-set [s]\n(let [bin (fn [n] (lazy-cat \n          (reverse (map #(Integer/parseInt (str %)) \n                         (Integer/toString n 2)))\n                  (repeat 0)))]\n(set (map (fn [i]\n      (set (keep identity \n        (map #(if (zero? %) %2 nil) (bin i) s))))\n         (range (bit-shift-left 1 (count s)))))))", "problem": 85, "user": "4dcfbc44535d5973398f92a7"}, {"code": "(fn power-set [s]\r\n  (if (empty? s) #{#{}}\r\n      (let [ps (power-set (rest s))]\r\n        (clojure.set/union ps (set (map #(conj % (first s)) ps))))))", "problem": 85, "user": "4e994541535dbda64a6f6b64"}, {"code": "(fn [xs]\n    (set (let [bits  (count xs) \n          index (into {} (map-indexed vector xs))]\n      (for [i (range 0 (Math/pow 2 bits))]\n        (->> (into {} (for [b (range bits)] [(index b) (bit-test i b)]))\n          (filter second)\n          (map first)\n          set)))))", "problem": 85, "user": "4dbad895535d1e037afb21ae"}, {"code": "(fn powset [s]\n  (letfn [(pow [a b] (if (= 0 b) 1 (reduce * (repeat b a))))\n          (incbin [s] \n                  (loop [r [] s s a 1]\n                    (if (and (nil? (first s)) (= 0 a))\n                      r\n                      (if (= 1 (first s) a)\n                        (recur (conj r 0) (rest s) 1)\n                        (recur (conj r (+ (or (first s) 0) a)) (rest s) 0)))))\n          (combinations [n] (take (pow 2 n) (iterate #(incbin %) (into [] (repeat n 0)))))\n          (ipowset [s] (set (map set (for [c (combinations (count s))] (filter #((complement =) :null %) (map #(if (= 1 %2) %1 :null) s c))))))]\n         (ipowset s)))", "problem": 85, "user": "4e6a5f5c535d8ccf87e9fed6"}, {"code": "(fn f85 [s]\n  \"power set\"\n  (let [inc-pattern\n        (fn [p idx]\n          \"adds from left to right in bit pattern at position idx\n           eg. 000 0 -> 100. 100 0 -> 010. 110 2 -> 111. 111 0 -> 000.\n           recursively: 110 0 -> 001.\"\n          (let [at-idx (get p idx)\n                lidx (dec (count p))]\n            (cond\n             (= (count p) (reduce + p)) (vec (repeat (count p) 0))\n             (zero? at-idx) (assoc p idx 1)\n             :else (recur (assoc p idx 0) (inc idx)))))\n        xs (vec s)        \n        n (count xs) ;; last pattern: n times 1\n        lidx (dec n)] ;; last index\n    (loop [pattern (vec (repeat n 0))\n           result #{}]\n      (let [cset (set (for [idx (range n)\n                                     :when (= 1 (get pattern idx))]\n                             (get xs idx)))\n            nresult (conj result cset)\n            npattern (inc-pattern pattern 0)]\n        (if (= 0 (reduce + npattern))\n          nresult\n         (recur npattern nresult))))))", "problem": 85, "user": "4e88feef535d8b9bb0147ca8"}, {"code": "(fn [s] (set (map set (reduce #(for [x % y %2] (concat x y)) #{#{}} (map (fn [x] [[] [x]]) s)))))", "problem": 85, "user": "4eb97b2e535dfed6da9c6d54"}, {"code": "(fn powerset [s]\n  (let [union clojure.set/union]\n    (if (empty? s) \n      #{#{}}\n      (union \n        (powerset (next s))\n        (map #(conj % (first s)) (powerset (next s)))))))", "problem": 85, "user": "4e6defcc535d5021c1a895f8"}, {"code": "#(loop [s % r #{#{}}]\n  (let [n (into r (mapcat (fn [x] (map (partial conj x) s)) r))]\n    (if (= n r)\n      r\n      (recur s n))))", "problem": 85, "user": "4e82f85d535db62dc21a62ce"}, {"code": "(fn [s]\n  (let [f! (atom nil)]\n    (letfn [(f1 [s] (map #(clojure.set/difference s #{%}) s))\n            (f2 [s]\n              (if (seq s)\n                (let [c (f1 s)]\n                  (reduce\n                    #(clojure.set/union %1 (@f! %2))\n                    (set c)\n                    c))\n                  #{}))]\n      (reset! f! (memoize f2))\n      (conj (f2 s) s))))", "problem": 85, "user": "4dbdc9da535d020aff1edf4c"}, {"code": "(fn [i]\n  (reduce\n    (fn [o v]\n      (clojure.set/union o (map #(conj % v) o)))\n    #{#{}}\n    i))", "problem": 85, "user": "4ec2fe3f535dcc7ae8597d4f"}, {"code": "(fn my-powerset [s]\n  (apply\n    hash-set\n    (let [powerset-size (int (java.lang.Math/pow 2 (count s)))\n          s-vec (vec s)]\n      (for [n (range powerset-size)]\n        (apply\n          hash-set\n        (filter\n          (complement nil?)\n          (for [pos (range (count s))]\n            (let [mask (int (java.lang.Math/pow 2 pos))\n                  use-element (zero? (bit-and n mask))]\n              (if use-element\n                (get s-vec pos)\n                nil)))))))))", "problem": 85, "user": "4ec6559a535d6d7199dd36c9"}, {"code": "(fn [x]\n(let [\n      pow\n      (fn pow [n]\n  (loop [p n data 1]\n\t(if (= p 0)\n\t  data\n\t  (recur (- p 1) (* 2 data)))))\n]\n\n(loop [pos 0 max (pow (count x)) data x res {}]\n  (if (= pos max)\n    (set res)\n    (recur (+ pos 1) max data (cons\n    (loop [se {} num pos dat data]\n      (if (= num 0)\n\t(set se)\n\t(if (= 1 (rem num 2))\n\t  (recur (cons (first dat) se) (quot num 2) (rest dat))\n\t  (recur se (quot num 2) (rest dat))))) res))))\n))", "problem": 85, "user": "4eb0afed535d7eef3080733e"}, {"code": "(fn ps [s] (if (empty? s)\n  #{#{}}\n  (let [f (first s) r (set (rest s)) u clojure.set/union psr (ps r)]\n    (u psr (set (map #(u % #{f}) psr))))))", "problem": 85, "user": "4e9d6a65535dbda64a6f6b87"}, {"code": "(fn pset [s] \n  (if (empty? s) \n    #{#{}}\n    (let [p (pset (set (rest s)))]\n      (clojure.set/union\n        p\n        (map #(conj % (first s)) p)))))", "problem": 85, "user": "4e9c81e8535dbda64a6f6b80"}, {"code": "(fn p [s]\n  (if (seq s)\n    (let [[a & b] (seq s)\n          r (p b)]\n      (clojure.set/union r (map #(conj % a) r)))\n    #{#{}}))", "problem": 85, "user": "4db0114d838c48654951d9b8"}, {"code": "(fn [oldv]\n  (let [ v (vec oldv)\n         genset (fn [n orgset]\n        (loop [result [] cnt n time 0]\n          (if (= cnt 0)\n              result\n              (recur (if (= (mod  cnt 2) 1) (conj result (nth orgset time) )  result  ) (quot cnt 2) (inc time) ) )))\n\n\n        ]\n    (set (map set (map #(genset % v) (range (Math/pow 2 (count v) )))))\n    )\n  )", "problem": 85, "user": "4ec5bec6535d6d7199dd36b3"}, {"code": "(fn power-set [s]\n  (if (empty? s)\n    #{#{}}\n    (let [x (first s) r (disj s x)]\n      (clojure.set/union\n       (set (map #(conj % x) (power-set r)))\n       (power-set r)))))", "problem": 85, "user": "4ed188c8535d44c135fd68cf"}, {"code": "(fn p [s]\n    (if (= #{} s)\n      #{#{}}\n      (let [[h & t] (vec  s)\n            s (p (set t))]\n        (set (concat s (map #(conj % h) s))))))", "problem": 85, "user": "4e6f578c535d5021c1a8961b"}, {"code": "(fn powerset [l]\n  (if (empty? l)\n    #{#{}}\n    (let [ps (powerset (rest l))]\n      (apply conj ps (map (fn [x] (conj x (first l))) ps)))))", "problem": 85, "user": "4db1b3951254ad5b4805fa6f"}, {"code": "reduce (fn [s a] (clojure.set/union s (map #(conj % a) s))) #{#{}}", "problem": 85, "user": "4ed94d69535d10e5ff6f5303"}, {"code": "(fn power-set [s]\n  (let [k (first s)\n        rst (disj s k)]\n    (if k\n      (clojure.set/union (set (map #(clojure.set/union % #{k}) (power-set rst)))\n             (power-set rst))\n      #{#{}})))", "problem": 85, "user": "4e7f51eb535db966e863cc3f"}, {"code": "(fn ps [s] \n  (letfn\n    [(gen [que mx res]\n      (if (empty? que)\n        res \n        (let [e (first que)\n              mn (if (empty? e) 0 (inc (last e))) \n              kids (for [n (range mn mx)] (conj e n))] \n          (recur (concat (rest que) kids) mx (conj res e)))))]\n   (set (map #(set (map (vec s) %)) (gen [[]] (count s) [])))))", "problem": 85, "user": "4e1350af535d04ed9115e7d8"}, {"code": "(fn powerset [s]\n  (if (empty? s) \n    #{#{}}\n    (let [union (fn union [& sets]\n                  (reduce into (first sets) (rest sets)))\n          ps-1 (powerset (rest s))]\n      (union ps-1 (map #(conj % (first s)) ps-1)))))", "problem": 85, "user": "4e7263a1535d5021c1a8965f"}, {"code": "#(set (for [i (range (Math/pow 2 (count %)))]\r\n  (set (for [j (range (count %)) :when (bit-test i j)]\r\n    ((vec %) j)))))", "problem": 85, "user": "4ec0c7ba535dfed6da9c6da4"}, {"code": "(fn [s]\n  (let [gen (fn [n]\n              (loop [result #{}, s s, n n]\n                (if (empty? s)\n                  result\n                  (recur (if (odd? n) (conj result (first s)) result) (rest s) (quot n 2)))))]\n    (set (map gen (range (int (Math/pow 2 (count s))))))))", "problem": 85, "user": "4edab806535d10e5ff6f5311"}, {"code": "(fn pset [s]\n    (set\n    (map\n    (fn [n]\n        (->> s (map vector (range)) \n          (filter  (fn [[i e]] (bit-test n i))) (map second) (set)))\n      (range (bit-shift-left 1 (count s))))))", "problem": 85, "user": "4eb0a757535d7eef3080733d"}, {"code": "(fn [xs]\n  (letfn [(powerset [[x & xs]]\n            (if x\n              (concat (map (partial cons x) (powerset xs)) (powerset xs))\n              [[]]))]\n  (->> (powerset (into [] xs))\n       (map set)\n        set)))", "problem": 85, "user": "4e513758535dc968683fc4f3"}, {"code": "(fn ps [s]\n  (if (empty? s)\n      #{#{}}\n      (let [f (first s)\n            r (ps (rest s))]\n        (clojure.set/union (set (map #(conj % f) r))\n                           r))))", "problem": 85, "user": "4ede8e1d535d10e5ff6f5339"}, {"code": "(fn p [ls]\n    (if (empty? ls) #{#{}}\n        (clojure.set/union (p (next ls))\n                    (into #{} (map #(conj % (first ls)) (p (next ls)))))))", "problem": 85, "user": "4ede8789535d10e5ff6f5337"}, {"code": "(fn [x]\n  (set\n   (let [x (vec x)\n         n (count x)\n         m (Math/pow 2 n)]\n     (for [i (range m)]\n       (set (for [j (range n)\n                  :when (bit-test i j)]\n              (nth x j)))))))", "problem": 85, "user": "4e59b02c535d8a8b8723a2a2"}, {"code": "(fn ps [s]\n  (if (empty? s)\n    #{#{}}\n    (let [f (first s)\n          r (rest s)\n          ps-1 (ps r)\n          ps-1+x (set (map #(conj % f) ps-1))]\n        (clojure.set/union ps-1 ps-1+x))))", "problem": 85, "user": "4edd038c535d10e5ff6f5327"}, {"code": "(partial reduce\n         (fn [s x] (clojure.set/union s (map #(conj % x) s)))\n         #{#{}})", "problem": 85, "user": "4ee3b586535d10e5ff6f5371"}, {"code": "(fn [s]\n  (loop [res #{#{}} c (seq s)]\n    (if (seq c)\n      (recur (into res (map #(conj % (first c)) res)) (rest c))\n      res)))", "problem": 85, "user": "4e9519b4535dbda64a6f6b2d"}, {"code": "(fn [s]\n  (reduce (fn [ps x]\n    (reduce (fn [ps s]\n      (conj ps (conj s x))) ps ps)) #{#{}} s))", "problem": 85, "user": "4ebc08a8535dfed6da9c6d7c"}, {"code": "(fn [a-s]\n  (letfn [(sub [s] (map #(disj s %) s))\n          (sub-list [ss] (set (mapcat sub ss)))]\n    (set (apply concat (take-while \n                          (complement empty?) \n                          (iterate sub-list [a-s]))))))", "problem": 85, "user": "4e6dc95a535d5021c1a895f1"}, {"code": "(fn f [s]\n  (if (empty? s)\n    #{#{}}\n    (into (f (next s)) (map #(conj % (first s)) (f (next s))))))", "problem": 85, "user": "4ee82539535d93acb0a66878"}, {"code": "(fn this [aset]\n  (if (empty? aset)\n    #{#{}}\n    (let [sub (this (rest aset))]\n       (->> sub\n            (map #(conj % (first aset)))\n            (concat sub)\n            set))))", "problem": 85, "user": "4ee9ba21535d93acb0a66891"}, {"code": "(fn p [s] (if (empty? s) #{#{}} (let [e (first s) t (disj s e)] (into (p t) ((fn f [e t] (into #{} (map #(conj % e) t))) e (p t))))))", "problem": 85, "user": "4eb13d60535d7eef3080733f"}, {"code": "#(into #{} (conj (map (fn [I] (into #{} (keep-indexed (fn [i v] (if (bit-test I i) v)) %))) (range 1 (apply * (repeat (count %) 2)))) #{}))", "problem": 85, "user": "4e9a8c0e535dbda64a6f6b72"}, {"code": "(fn [s]\n         (set ((fn rec [[n & ns]]\n                   (if n\n                       (let [ms (rec ns)]\n                            (into ms (map #(conj % n) ms)))\n                       '(#{})))\n               (vec s))))", "problem": 85, "user": "4ee82223535d93acb0a66877"}, {"code": "(fn f [s]\n  (if-let [[a & r] (seq s)]\n    (into #{} (mapcat #(list % (conj % a)) (f r)))\n    #{#{}}))", "problem": 85, "user": "4ed69ea4535d10e5ff6f52e3"}, {"code": "(fn [s]\n    (reduce (fn [acc item]\n              (into acc (map #(conj % item) acc)))\n            #{#{}} s))", "problem": 85, "user": "4e6a0667535d8ccf87e9fe9e"}, {"code": "(fn powerset [elems]\n  (set\n    (reduce\n      (fn [pset elem]\n        (concat pset (map #(conj % elem) pset)))\n      [#{}]\n      elems)))", "problem": 85, "user": "4eb9ce75535dfed6da9c6d5e"}, {"code": "(partial reduce \n         (comp (partial apply into) \n               (juxt first\n                     (comp (partial apply map conj) \n                           (juxt first \n                                 (comp repeat second))))\n               list)\n         #{#{}})\n\n#_\n\n(fn [s] \n  (reduce \n    (fn [a b] \n      (into a (map #(conj % b) a)))\n    #{#{}} \n    s))", "problem": 85, "user": "4ef49c2c535dced4c769f238"}, {"code": "(fn [a]\n  (set (mapcat identity\n           (letfn [(f [S k]\n               (if (< k (count a) )\n                   (let [b (nth S k)\n                         c (into () (set (for [x a, y b :when (not (contains? y x))] \n                                            (conj y x) )) ) ]\n                       (f (conj S c) (inc k)))\n                   S))]\n               (f ['(#{}) (map (fn [n] #{n}) a)]\n                  1) ) )))", "problem": 85, "user": "4ee7d177535d93acb0a6686f"}, {"code": "#(letfn [(powerset [xs]\r\n  (let [n (count xs)\r\n\t      m (Math/pow 2 n)]\r\n\t     (for [i (range m)]\r\n\t\t  (for [j (range n) :when (bit-test i j)]\r\n\t\t       (nth xs j)))))]\r\n  (set (map set (powerset (seq %)))))", "problem": 85, "user": "4e273301535deb9a81d77ef7"}, {"code": "(fn [s]\n  (let [v (apply vector s)\n        n (count v)\n        m (int (Math/pow 2 n))]\n    (letfn [(subset [i]\n      (loop [acc (list) j i c 0]\n        (if (zero? j)\n          (apply hash-set acc)\n          (recur\n            (if (even? j) acc\n              (cons (nth v c) acc))\n            (int (/ j 2)) (inc c)))))]\n      (apply hash-set (map subset (range m))))))", "problem": 85, "user": "4eb2e6ca535d7eef3080734f"}, {"code": "(fn power-set\n  [s]\n  (if (empty? s) #{#{}}\n      (let [ps (power-set (rest s))]\n        (set (concat (map #(conj % (first s)) ps) ps)))))", "problem": 85, "user": "4edf5dc6535d10e5ff6f5340"}, {"code": "(fn powerset [coll]\n  (if-let [[x & more] (seq coll)]\n    (set (mapcat #(set [% (conj % x)]) (powerset more)))\n    #{#{}}))", "problem": 85, "user": "4edecdae535d10e5ff6f533c"}, {"code": "#(letfn [(f [e t] (set (for [x t] (conj x e))))]\n  (loop [s %, p #{#{}}]\n    (if-let [[e] (seq s)]\n      (recur (disj s e) (into p (f e p)))\n      p)))", "problem": 85, "user": "4ec5aa1f535d6d7199dd36b0"}, {"code": "#(let [p (fn [s] ; austintaylor\n            (reduce\n             (fn [p x]\n               (reduce\n                (fn [p s] (conj p (conj s x)))\n                p p))\n             #{#{}} s))]\n   (p %))", "problem": 85, "user": "4e65027c535d8ccf87e9fe6e"}, {"code": "(fn power-set [coll]\n    (letfn [(union [s1 s2] (reduce conj s1 s2))]\n      (if (empty? coll)\n        #{#{}}\n        (let [element (first coll)\n              sub1 (power-set (disj coll element))\n              sub2 (set (map #(union #{element} %) sub1))]\n          (union sub1 sub2)))))", "problem": 85, "user": "4dc29a1d535d020aff1edf96"}, {"code": "(fn  [s]\n  (let [ss (map identity s)]\n  (set (map set \n    (loop [s1 ss\n            accum '(())]\n   (if (= s1 '())\n       accum\n       (recur\n         (rest s1)\n        (reduce conj\n         accum         \n           (map #(conj % (first s1))\n                accum)))))))))", "problem": 85, "user": "4f043cb8535dcb61093f6bb3"}, {"code": "(fn powerset [s]\n        (if (empty? s) #{#{}}\n            (into (powerset (next s))\n                  (map #(conj % (first s)) (powerset (next s))))))", "problem": 85, "user": "4f031eac535dcb61093f6a67"}, {"code": "(fn power-set [l]\n  (if (empty? l) #{ #{} }\n   (clojure.set/union (power-set (rest l))\n       (vec (map #(conj % (first l))\n              (power-set (rest l)))))))", "problem": 85, "user": "4f04a06d535dcb61093f6bd9"}, {"code": "(fn [x] \n  (set \n    (take 99999\n          (mapcat \n            (fn [s] \n              (map #(set (take % s)) \n                   (range (inc (count s))))) \n            (repeatedly #(shuffle x))))))", "problem": 85, "user": "4e6ebd4a535d5021c1a89610"}, {"code": "(fn [s]\n  (set (map (fn [n]\n    (set (keep-indexed #(if (bit-test n %1) %2) s)))\n            (range 0 (bit-shift-left 1 (count s))))))", "problem": 85, "user": "4effb663535dcb61093f6a2e"}, {"code": "(fn [s] \n  (reduce \n    (fn [a b] \n      (into a (map #(conj % b) a)))\n    #{#{}} \n    s))", "problem": 85, "user": "4ec5d62c535d6d7199dd36ba"}, {"code": "(fn [s]\r\n  (let [size (.size s)\r\n        n (Math/pow 2 size)\r\n        coll (seq s)\r\n        filter-by-bits (fn [x]\r\n  \t\t\t\t\t\t\t\t\t\t   (loop [i 0 res #{}]\r\n\t\t\t\t\t\t\t\t\t\t\t     (if (= i size) res\r\n\t\t\t\t\t\t\t\t\t\t\t       (if (bit-test x i)\r\n\t\t\t\t\t\t\t\t\t\t\t         (recur (inc i) (conj res (nth coll i))) (recur (inc i) res)))))]\r\n    (set (map #(filter-by-bits %) (range n)))))", "problem": 85, "user": "4f03822f535dcb61093f6b03"}, {"code": "#(loop [out #{#{}}]\n  (if (= (count out) (Math/pow 2 (count %)))\n    out\n    (recur (set (conj \n                  (mapcat (fn [x] (map (fn [s] (conj s x)) out)) %)\n                  #{})))))", "problem": 85, "user": "4f04b66b535dcb61093f6bdd"}, {"code": "(fn p [s] \n  (set\n    (if (empty? s) #{#{}}\n      (let [x (first s) r (p (rest s))]\n        (concat r\n            (map #(conj % x) r))))))", "problem": 85, "user": "4f06dcad535dcb61093f6c16"}, {"code": "(fn power-set\n  [coll]\n  (let [nth-power-set (fn nth-power-set\n                        [n coll]\n                        (let [v (vec coll)\n                              cnt (count v)]\n                          (into #{} (for [i (range cnt)\n                                          :let [b (bit-shift-left 1 i)]\n                                          :when (not (zero? (bit-and n b)))]\n                                      (v i)))))\n    \n        v (vec coll)]\n\n    (into #{} (for [n (range (bit-shift-left 1 (count v)))]\n                (nth-power-set n v)))))", "problem": 85, "user": "4f047c07535dcb61093f6bcd"}, {"code": "(fn [s]\n  (letfn [(incps [ss v]\n    (apply conj ss (map #(conj % v) ss)))]\n  (reduce\n    incps\n    #{#{}}\n    s)))", "problem": 85, "user": "4f050dec535dcb61093f6bef"}, {"code": "(fn P [S]\n           (if (empty? S) #{#{}}\n               (let [F (fn [e T] (set (map #(conj % e) T)))\n                    e (first S)\n                    T (disj S e)\n                    PT (P T)]\n (set\n  (concat\n   PT\n   (F e PT))))))", "problem": 85, "user": "4db8f6c4535d1e037afb219e"}, {"code": "(fn [v] (set (map set\n  ((fn f [[h & t]]\n      (if h\n        (let [r (f t)]\n          (concat r (map #(concat [h] %) r)))\n        [[]]\n    )) (vec v)))))", "problem": 85, "user": "4f01c938535dcb61093f6a39"}, {"code": "(fn P [s]\n  (if (empty? s) #{#{}}\n    (let [small (P (rest s))]\n      (into small (map #(conj % (first s)) small)))))", "problem": 85, "user": "4f03ac2d535dcb61093f6b4a"}, {"code": "(fn [s]\n    ;; The following functions are from clojure.contrib.combinatorics/permutations\n    (letfn [(index-combinations [n cnt]\n              (lazy-seq\n               (let [c (vec (cons nil (for [j (range 1 (inc n))] (+ j cnt (- (inc n)))))),\n                     iter-comb\n                     (fn iter-comb [c j]\n                       (if (> j n) nil\n                           (let [c (assoc c j (dec (c j)))]\n                             (if (< (c j) j) [c (inc j)]\n                                 (loop [c c, j j]\n                                   (if (= j 1) [c j]\n                                       (recur (assoc c (dec j) (dec (c j))) (dec j)))))))),\n                     step\n                     (fn step [c j]\n                       (cons (rseq (subvec c 1 (inc n)))\n                             (lazy-seq (let [next-step (iter-comb c j)]\n                                         (when next-step (step (next-step 0) (next-step 1)))))))]\n                 (step c 1))))\n            (combinations [items n]      \n              (let [v-items (vec (reverse items))]\n                (if (zero? n) (list ())\n                    (let [cnt (count items)]\n                      (cond (> n cnt) nil\n                            (= n cnt) (list (seq items))\n                            :else\n                            (map #(map v-items %) (index-combinations n cnt)))))))]\n      ;; Here we go\n      (set (for [i (range (inc (count s)))\n                 c (combinations s i)]\n             (set c)))))", "problem": 85, "user": "4e89e939535d3e98b8023287"}, {"code": "(fn [s] (reduce (fn [p e] (into p (map #(conj % e) p))) #{#{}} s))", "problem": 85, "user": "4ee9ddb8535d93acb0a66896"}, {"code": "(fn power-set\r\n     ([theset] (set (power-set theset #{})))\r\n     ([s result]\r\n        (if (empty? s)\r\n          (list result)\r\n          (concat  (power-set (rest s) (conj result (first s)))\r\n                   (power-set (rest s) result)))))", "problem": 85, "user": "4f039524535dcb61093f6b2c"}, {"code": "(fn power-set [x]\n  (if (= #{} x) #{#{}}\n      (set (concat (power-set (set (rest x)))\n                   (set (map #(set (conj % (first x)))\n                              (power-set (set (rest x)))))))))", "problem": 85, "user": "4e49a7bb535dc968683fc4c6"}, {"code": "(fn [coll]\n  (reduce (fn [s x] (into s (map #(conj % x) s)))\n          #{#{}}\n          coll))\n\n;; ;; --- use loop rec\n;; (fn [coll]\n;;   (loop [c coll, ss #{#{}}]\n;;     (if (empty? c)\n;;       ss\n;;       (recur (next c)\n;;              (->> (map #(conj % (first c)) ss)\n;;                   (into ss))))))", "problem": 85, "user": "4daec9dcedd6309eace4d15f"}, {"code": "(fn p [c]\n      (if (empty? c) #{#{}}\n          (clojure.set/union (p (next c))\n                             (map #(conj % (first c)) (p (rest c))))))", "problem": 85, "user": "4f0ef874535d0136e6c22328"}, {"code": "(fn power-set [s]\n  (set (reduce (fn [ss x] (concat ss (map #(conj % x) ss))) [#{}] s)))", "problem": 85, "user": "4f03bf5e535dcb61093f6b5d"}, {"code": "(fn pow [seq]\n  (if (= (count seq) 0)\n      #{#{}}\n      (apply hash-set (concat (pow (rest seq)) (map #(conj % (first seq)) (pow (rest seq)))))))", "problem": 85, "user": "4f13047d535d64f60314642c"}, {"code": "(fn [%]\n     (reduce (fn [coll item]\n               (reduce #(conj % (conj %2 item)) coll coll))\n             #{#{}} %))", "problem": 85, "user": "4f036d9b535dcb61093f6ac1"}, {"code": "(fn  [s]\n  (letfn [(set-bits [n]\n            (apply hash-set (filter #(not (nil? %))\n                                    (map #(if (= %1 \\1) %2 nil)\n                                         (reverse (Long/toBinaryString n)) (range)))))] \n    (let [c (vec s)]\n      (print c)\n      (reduce #(conj %1 (apply hash-set (map c (set-bits %2)))) #{} (range (Math/pow 2 (count c)))))))", "problem": 85, "user": "4ec28d86535dfed6da9c6dbc"}, {"code": "(fn [x]\n  (let [len (count x)\n        set-len (bit-shift-left 1 len)\n        xs (map vector (range len) (seq x))]\n    (set\n     (map\n      (fn [mask]\n        (set\n         (map second (filter #(bit-test mask (first %)) xs))))\n      (range set-len)))))", "problem": 85, "user": "4f0e995e535d0136e6c22326"}, {"code": "(fn powerset [vals]\n  (if (empty? vals)\n    #{#{}}\n    (let [x (first vals)\n          sub (powerset (set (rest vals)))]\n      (apply conj sub (set (map #(conj %1 x) sub))))))", "problem": 85, "user": "4f0d093b535d0136e6c22313"}, {"code": "(fn pwr [aset]\n  (if-let [s (seq aset)]\n    (let [ r (pwr (next s))\n           e (first s)]\n       (into r (set (map #(conj % e) r)))\n    )\n    #{#{}}))", "problem": 85, "user": "4f03154a535dcb61093f6a58"}, {"code": "(fn power-set\n  ([s]\n    (let [units (set (map set (partition-all 1 s)))]\n    (power-set (map first units) units 2 (count s))))\n  ([units prev-subsets current-size target-size]\n    (if (> current-size target-size)\n      (conj prev-subsets #{})\n      (recur\n        units\n        (set (mapcat (fn [x]\n               (conj \n                      (map #(conj x %) units)\n                      x)) \n             prev-subsets))\n        (inc current-size)\n        target-size))))", "problem": 85, "user": "4ea7999e535d7eef308072ee"}, {"code": "(fn pw\n  ([s] (pw s #{#{}}))\n  ([s r]\n     (if (empty? s)\n       r\n       (pw (rest s) (into r (map #(conj % (first s)) r))))))", "problem": 85, "user": "4ec07699535dfed6da9c6da2"}, {"code": "#(let [s (count %)\n       n (bit-shift-left 1 s)\n       c (seq %)]\n   (set \n     (for [i (range n)]\n       (set \n         (for [j (range s) :when (bit-test i j)]\n           (nth c j))))))", "problem": 85, "user": "4efb2fd7535dced4c769f274"}, {"code": "(fn powerset [s]\n  (letfn [\n    (pick-bits [bits cardinality]\n      (filter #(bit-test bits %) (range cardinality)))\n    (pick-elems [bits lst]\n      (for [i (pick-bits bits (count lst))] (nth lst i))) ]\n\n   (let [lst (apply list s)]\n    (set (for [bits (range (Math/pow 2 (count s)))]\n          (set (pick-elems bits lst)))))))", "problem": 85, "user": "4e356d2b535deb9a81d77f2d"}, {"code": "(fn power_set [coll]\r\n  (let  \r\n\t\t[\r\n\t\tpow (fn [a b] (Math/pow a b ))\r\n\t\tbseq (fn [n] (seq (java.lang.Integer/toBinaryString n)))\r\n\t\tpset_list (fn [coll] (range (pow 2 (count coll))))\r\n\t\tpset (fn [coll]  (map bseq (pset_list coll)))\r\n\t\ts1 (fn [coll pcoll] (for [x pcoll] \r\n\t\t\t(filter #(= (first %) \\1) (map vector (reverse x)  coll))))\r\n\t\ts2(fn [coll] (set (for [x coll] (set (map second x)))))]\r\n\t\t(s2 (s1 coll (pset coll)))))", "problem": 85, "user": "4ecf1f51535d1f5ad70dba3a"}, {"code": "(comp set\n        (fn p [[f & r]] (if f (concat (p r) [#{f}] (map #(conj % f) (p r)))\n                           [#{}]))\n        seq)", "problem": 85, "user": "4ee88bfb535d93acb0a66881"}, {"code": "(fn pset [s]\r\n  (set\r\n    (if (>= 1 (count s)) [(set s) #{}]\r\n      (concat\r\n        [s]\r\n        [(set [(first s)])]\r\n        (pset (set (rest s)))\r\n        (map #(set (cons (first s) %)) (pset (set (rest s))))\r\n      ))))", "problem": 85, "user": "4f1b92d1535d64f60314647b"}, {"code": "(fn [t]\n    (set\n      ((fn f [[x & s]]\n         (if x\n           (let [z (f s)] (concat z (map #(conj % x) z)))\n           #{#{}}))\n        (seq t))))", "problem": 85, "user": "4f08b15b535dcb61093f6c40"}, {"code": "(fn [res st]\n   (if (empty? st)\n     res\n     (recur (set (concat res (map #(conj % (first st)) res))) (rest st)))\n   ) #{#{}}", "problem": 85, "user": "4eb02674535d7eef30807338"}, {"code": "(fn ff[s] \n  (if (empty? s) \n    #{#{}} \n    (let [e (first s) \n          r (next s) \n          p (ff r)] \n      (into p (map #(conj % e) p)))))", "problem": 85, "user": "4f1fd734535d64f6031464a5"}, {"code": "(fn powerset [ls]\n  (if (empty? ls) #{#{}}\n      (set (map set (clojure.set/union (powerset (next ls))\n      (map #(conj % (first ls)) (powerset (next ls))))))))", "problem": 85, "user": "4f251302e4b0d66497709ff0"}, {"code": "(let [results (atom {})]\n    (fn power-set [x]\n      (if (@results x) (@results x)\n          (do\n            (swap! results\n                   assoc x\n                   (if (empty? x) #{#{}}\n                       (set\n                        (mapcat\n                         (fn [f]\n                           (set\n                            (concat\n                             (conj (set (map #(conj % f)\n                                             (power-set (set (rest x)))))\n                                   x)\n                             (power-set (set (disj x f))))))\n                         x))))\n            (@results x)))))", "problem": 85, "user": "4f2bfd2ae4b0d6649770a04f"}, {"code": "(fn [s] (reduce (fn [power-set x]\n                  (into power-set (map #(conj % x) power-set)))\n                #{#{}}\n                s))", "problem": 85, "user": "4ebcb8ff535dfed6da9c6d8a"}, {"code": "(fn power-set [s]\n  (if (empty? s)\n    #{#{}}\n    (let [x (first s)\n          power-set-of-rest (power-set (next s))]\n      (into power-set-of-rest \n            (for [i power-set-of-rest] (conj i x))))))", "problem": 85, "user": "4ecfa05c535d44c135fd68b9"}, {"code": "(fn [s]\n  (set (map set \n            (for [x (range (java.lang.Math/pow 2 (count s)))]  \n              (map second \n                   (filter first \n                           (map-indexed #(vector (bit-test x %) %2) s)))))))", "problem": 85, "user": "4ec74de3535d6d7199dd36df"}, {"code": "(fn [s] \n  (reduce \n    (fn [o i]\n      (into o (map #(conj % i) o))) \n    #{#{}} s))", "problem": 85, "user": "4f1d1d95535d64f603146488"}, {"code": "(fn [c]\n(letfn [(powerset [coll]\n  (if (empty? coll) '(())\n      (reduce conj (powerset (rest coll))\n      (map #(conj % (first coll)) (powerset (rest coll))))))]\n(set (map set (powerset c)))))", "problem": 85, "user": "4e6cf521535de274dd8d818b"}, {"code": "(fn P [X]\n  (let [f (fn [e T]\n            (set (map #(conj % e) T)))]\n    (if (empty? X)\n      #{X}\n      (let [e (first X)\n            PT (P (set (rest X)))]\n        (clojure.set/union PT (f e PT))))))", "problem": 85, "user": "4e7dd982535db169f9c796ee"}, {"code": "(fn [set]\n   (loop [powerset #{#{}} i 0]\n     (if (= i (count set))\n       powerset\n       (recur\n        (into powerset (for [x powerset y set] (conj x y) ) )\n        (inc i)\n        )\n       )\n     )\n   )", "problem": 85, "user": "4ea31da2535d7eef308072c1"}, {"code": "(fn f [s]\n    (if (seq s)\n      (let [v (first s)\n            r (f (next s))]\n        (into r (for [r r] (conj r v))))\n      #{#{}}))", "problem": 85, "user": "4f0664bd535dcb61093f6c0f"}, {"code": "(fn [xs]\n  (letfn [(a [xs ys]\n            (if (ys xs)\n              ys\n              (recur xs (set (for [x xs y ys] (conj y x))))))]\n    (conj (a xs #{#{}}) #{})))", "problem": 85, "user": "4ef6e689535dced4c769f24f"}, {"code": "(fn power-set* [s]\r\n  (let [a (first s)\r\n        b (disj s a)]\r\n    (if (empty? s)\r\n      (hash-set #{})\r\n      (clojure.set/union (set (map #(conj % a) (power-set* b)))\r\n                         (power-set* b)\r\n      ))))", "problem": 85, "user": "4ef0f1a1535dced4c769f212"}, {"code": "(fn ps [s]\n  (letfn [(f [s]\n           (if (empty? s) #{s}\n             (let [r (f (rest s))]\n               (into r\n                 (map #(conj % (first s)) r)))))]\n    (set (map set (f s)))))", "problem": 85, "user": "4ee4f4a9535d1385b2869d85"}, {"code": "(fn ! [st]\n  (if (empty? st) #{#{}}\n      (let [a (first st) s (! (rest st))]\n  (set (concat (map #(conj % a) s) s)))))", "problem": 85, "user": "4e7d1c22535db169f9c796c5"}, {"code": "(fn [s]\n    (letfn [(combinations [remaining prev] (lazy-seq\n                (when-let [[x & xs] (seq remaining)]\n                    (let [current (conj prev x)]\n                        (cons current (concat (combinations xs current) (combinations xs prev)))\n                    ))))\n        ]\n        (into #{#{}} (combinations s #{}))\n    ))", "problem": 85, "user": "4df3d4f4535d08e6dec9fe2c"}, {"code": "(fn [ss]\n  (loop [s ss r '(#{})]\n    (pr r)\n    (if (empty? s)\n      (set r)\n      (recur (rest s) (flatten (for [power_element r] (list (conj power_element (first s)) power_element)))))))", "problem": 85, "user": "4e8b98fc535d65386fec2124"}, {"code": "#(let [c (count %)]\n   (loop [done [%] ac #{%} sz 0]\n     (if (>= sz c)\n       ac\n       (let [d (into #{}(for [o done i o]\n                         (disj o i)))]\n         (recur d (into ac d) (inc sz))))))", "problem": 85, "user": "4f32a7f1e4b0d6649770a095"}, {"code": "(fn [coll]\n  (loop [result [[]] input coll]\n    (if (empty? input) (set (map set result))\n        (recur \n          (concat result (map #(conj % (first input)) result))\n          (rest input)\n        )\n    )))", "problem": 85, "user": "4f38d6bbe4b0e243712b1ee2"}, {"code": "(fn [c]\n           (reduce\n            (fn [s e]\n                (into s (map #(conj % e) s)))\n            #{#{}}\n            c))", "problem": 85, "user": "4f34eb87e4b0e243712b1eba"}, {"code": "(fn [s]\n  (reduce #(into %1 (map (fn [se] (conj se %2))  %1)) #{#{}} s))", "problem": 85, "user": "4f29eb2ae4b0d6649770a037"}, {"code": "(fn this [l]\r\n  (if (empty? l)\r\n    #{#{}}\r\n    (let [rl (this (rest l))]\r\n      (set (concat rl (map (fn [s] (set (cons (first l) s))) rl))))))", "problem": 85, "user": "4f474f43e4b0d56e7bb92bb7"}, {"code": "(fn power-set [s]\n    (if (empty? s)\n        #{s}\n        (let [ps (power-set (into #{} (rest s)))]\n            (clojure.set/union ps (map #(conj % (first s)) ps)))))", "problem": 85, "user": "4f4ac35ae4b0d56e7bb92c18"}, {"code": "(fn sets [s]\n  (if (seq s)\n    (let [x (first s)\n          xs (next s)]\n      (set (mapcat (fn [y]\n                     [(conj y x)\n                      y])\n                  (sets xs))))\n    #{#{}}))", "problem": 85, "user": "4eae5fe4535d7eef30807325"}, {"code": "(fn pwr [xs]\n    (let [[x & more :as xs] (vec xs)]\n      (if-not (seq xs)\n        #{#{}}\n        (->> (pwr more)\n             (concat (map #(conj % x) (pwr more)))\n             set))))", "problem": 85, "user": "4ee26f01535d10e5ff6f5368"}, {"code": "(fn p [s]\n  (if (empty? s) #{#{}}\n    (let [[x & r] (seq s)\n          t (p r)]\n      (into t (map #(conj % x) t)))))", "problem": 85, "user": "4f4e91a9e4b03ad3f0c10cca"}, {"code": "(fn [s]\n  (reduce\n    (fn [p i] (into p (map #(conj % i) p)))\n    #{#{}} s))", "problem": 85, "user": "4f1b0ab3535d64f603146474"}, {"code": "(fn hoge[ls]\n  (if (empty? ls) #{#{}}\n      (clojure.set/union (hoge (next ls))\n      (map #(conj % (first ls)) (hoge (next ls))))))", "problem": 85, "user": "4db2cc55535df7e46ed9b6c5"}, {"code": "(letfn [(ps [s]\r\n            (let [[x & xs] (seq s)]\r\n              (if x\r\n                (let [xss (ps xs)]\r\n                  (concat xss (map (partial cons x) xss)))\r\n                (list '()))))]\r\n    (fn [s]\r\n      (->> (ps s)\r\n           (map set)\r\n           set)))", "problem": 85, "user": "4f047177535dcb61093f6bc6"}, {"code": "(fn powaset [kys]\n  (if (empty? kys) #{#{}}\n    (let [\n      k (first kys)\n      res (powaset (disj kys k))]\n    (reduce conj res\n      (map #(conj % k) res)))))", "problem": 85, "user": "4f569218e4b0a7574ea71826"}, {"code": "(fn [st]                                                                                    \n  (letfn [(subsets [n items]  \n           (cond\n            (= n 0) #{#{}}                                                                           \n            (empty? items) #{}                                                                       \n            :else (concat (map                                                                       \n                           #(cons (first items) %)                                                   \n                           (subsets (dec n) (rest items)))                                           \n                            (subsets n (rest items)))))]                                                \n    (let [allsubsets (for [i (range (inc (count st)))] (subsets i st))]                               \n     (reduce #(into %1 (map set %2)) #{} allsubsets))))", "problem": 85, "user": "4f1d1299535d64f603146487"}, {"code": "(fn [s]\n  (->> #{#{}}\n       (iterate #(set (for [x % y s :when (not (x y))] (conj x y))))\n       (take (inc (count s)))\n       (apply concat)\n       set))", "problem": 85, "user": "4f569a3ce4b0a7574ea71828"}, {"code": "(fn ps [s]\n    (if (empty? s) #{#{}}\n        (let [n (count s)\n              max (int (Math/pow 2 n))\n              m (zipmap (range n) s)]\n          (into #{}\n                (for [n (range max)]\n                  (set\n                   (map (fn [x] (m x))\n                        (filter #(bit-test n %) (range n)))))))))", "problem": 85, "user": "4f3ec266e4b0e243712b1f8c"}, {"code": "reduce #(into % (map conj % (repeat %2))) #{#{}}", "problem": 85, "user": "4f38b7d9e4b0e243712b1ee0"}, {"code": "(fn [x]\n  (set (reduce \n\t      (fn [x y]\n\t\t  (concat x\n\t\t\t  (for [s x] (conj s y))))\n\t      #{#{}}\n\t      x)))", "problem": 85, "user": "4f4d7b8fe4b03ad3f0c10ca9"}, {"code": "(fn subsets [s]\n  (set \n    (flatten\n      (reduce (fn [ss x]\n                (map (fn [a b] (concat a (map #(conj % x) b)))\n                     (concat ss [nil]) (concat [nil] ss)))\n              [[#{}]] s))))", "problem": 85, "user": "4f50c414e4b03ad3f0c10d0d"}, {"code": "(fn thisfunc [s]\n  (if (empty? s)\n    #{#{}}\n    (let [result (thisfunc (rest s))]\n      (set (concat result (map #(conj % (first s)) result))))))", "problem": 85, "user": "4dd9d299535d2dad7130b5dd"}, {"code": "(fn powerset[s]\n    (if (empty? s) #{#{}}\n      (into (powerset (rest s))\n            (map #(conj % (first s)) (powerset (rest s))))))", "problem": 85, "user": "4f4c6b21e4b03ad3f0c10c8f"}, {"code": "(fn [s] (set (reduce #(for [i % j %2] (clojure.set/union i j)) [#{} #{}] (for [i s] [#{} #{i}]))))", "problem": 85, "user": "4eecdd66535d93acb0a668b9"}, {"code": "(fn powerset [sets]\r\n  (letfn [(powerset2 [ps ss]\r\n            (if (empty? ss)\r\n              ps\r\n              (powerset2 (set (concat (map #(conj % (first ss)) ps) ps)) (rest ss))))]\r\n    (powerset2 #{#{}} sets)))", "problem": 85, "user": "4f62b29ce4b0defedf855fd9"}, {"code": "(fn [s]\n(letfn [(rm [s]\n            (for [x s]\n              (set (remove #(= % x) s))))\n          (gen [acc s1]\n            (if (empty? (first s1))\n              (if (empty? s)\n                (set acc)\n                (set (conj acc #{})))\n              (recur (concat acc s1) (set (mapcat rm s1)))))]\n    (gen [s] (rm s))))", "problem": 85, "user": "4e521cef535d302ef430da6d"}, {"code": "(fn [s]\n  (reduce (fn [s k]\n    (into s (map #(conj % k) s)))\n    #{#{}}\n    s))", "problem": 85, "user": "4f6fbb68e4b07046d9f4efeb"}, {"code": "(fn [s] \n  (reduce \n    (fn [s i] (into s (map #(conj % i) s))) \n    #{#{}} \n    s))", "problem": 85, "user": "4e773be8535d324fb2983d6e"}, {"code": "(fn p-set [s]\n  (loop [depth 1, last-sets [#{}]]\n    (let [new-sets (apply concat (for [v s] (map #(conj % v) last-sets)))]\n      (if (>= (count s) depth)\n        (recur (inc depth) (into #{} new-sets))\n        (into #{#{}} new-sets)))))", "problem": 85, "user": "4f6160a7e4b0defedf855fbe"}, {"code": "(fn pwr-set [xs]\n  (into #{} (let [min-set first\n        delete-min-set #(disj % (min-set %))\n        pxs (lazy-seq (pwr-set (delete-min-set xs)))]\n    (if (empty? xs)\n      #{#{}}\n      (clojure.set/union (map #(conj % (min-set xs)) pxs) pxs)))))", "problem": 85, "user": "4e7f5a0b535db966e863cc41"}, {"code": "(fn powerset [s]\n  (let [n (count s)]\n    (cond\n      (= n 0) #{#{}}\n      (= n 1) #{#{} s}\n      :else  (set \n               (let [[p1 p2] (map (comp powerset set) (split-at (quot n 2) s))]\n                    (for [s1 p1 s2 p2]\n                      (clojure.set/union s1 s2)))))))", "problem": 85, "user": "4f58fe71e4b0a7574ea7185f"}, {"code": "(fn powerset[theset]\r\n  (if(empty? theset)\r\n     #{#{}}\r\n     (let[nextSet (powerset (rest theset) ),\r\n          head (first theset)]\r\n       \r\n         (reduce  conj nextSet (map #(conj % head) nextSet) )  \r\n       \r\n       )\r\n  )\r\n)", "problem": 85, "user": "4f6d9d7ee4b07046d9f4efcd"}, {"code": "(fn power-set [s]\n  (let [s-count (count s)\n        s-seq (seq s)\n        fst (first s-seq)]\n    (cond \n      (= s-count 0) #{#{}}\n      (= s-count 1) #{#{} s}\n      :else \n        (clojure.set/union\n          (set (map #(conj % fst) (power-set (set (rest s-seq)))))\n          (power-set (set (rest s-seq)))))))", "problem": 85, "user": "4f7e29dde4b06e829148e1ca"}, {"code": "(fn power-set [s]\r\n  (if (= s #{})\r\n    #{#{}}\r\n    (let [elem (first s)\r\n          p (power-set (disj s elem))]\r\n      (reduce conj \r\n              p\r\n              (map (fn [e] (conj e elem)) p)))))", "problem": 85, "user": "4f71db68e4b07046d9f4f015"}, {"code": "(fn iter\n  ([in]\n    (iter in #{#{}}))\n  ([in out]\n    (if (empty? in)\n        out\n        (recur (disj in (first in))\n               (apply merge out\n                 (map #(conj % (first in)) out))))))", "problem": 85, "user": "4f8345c6e4b033992c121c1b"}, {"code": "(fn p85\r\n   ([s] (set (cons #{} (p85 '(#{}) s))))\r\n  \t([acc s]\r\n    \t(if (empty? s)\r\n      \t\t()\r\n      \t\t(let [fs (first s)\r\n            \t  nacc (map #(conj % fs) acc)]\r\n        \t\t(concat nacc (p85 (concat acc nacc) (next s)))))))", "problem": 85, "user": "4f7f0827e4b06e829148e1d5"}, {"code": "(fn p [s] (if (empty? s) #{#{}} (let [e (first s) r (disj s e) pr (p r)] (clojure.set/union pr (into #{} (map #(conj % e) pr))))))", "problem": 85, "user": "4f8c5f4fe4b02e764a0a5198"}, {"code": "(fn power-set [s]\n  (if-let [[f & r] (seq s)]\n    (let [beck (power-set r)]\n      (into beck (for [el beck] (conj el f))))\n    #{#{}}))", "problem": 85, "user": "4f2baf1ae4b0d6649770a04c"}, {"code": "(fn [coll]\r\n  (letfn [(ps [s]\r\n            (if (empty? s)\r\n              '([])\r\n              (mapcat #(list % (conj % (first s))) (ps (rest s)))))]\r\n    (set (map #(set %) (ps coll)))))", "problem": 85, "user": "4f969214e4b0dcca54ed6cdd"}, {"code": "(fn power-set [coll]\n  (if (empty? coll)\n    #{#{}}\n    (let [xs (power-set (rest coll))\n          union clojure.set/union]\n      (union xs (set (map #(union (set (take 1 coll)) %) xs))))))", "problem": 85, "user": "4ef6f5ea535dced4c769f250"}, {"code": "(fn [s] (reduce (fn [a n] (into a (map #(into #{n} %) a))) #{#{}} s))", "problem": 85, "user": "4f83665ee4b033992c121c1c"}, {"code": "(fn [s]\n  (let [done (int (Math/pow 2 (count s)))\n        start-set (set (map set (partition 1 s)))]\n    (loop [p-set start-set c 1]\n      (if (= (dec done) (count p-set))\n        (clojure.set/union #{#{}} p-set)\n        (recur (clojure.set/union p-set\n                                  (into #{} (flatten (for [x p-set :when (= (count x) c)]\n                                                       (map (partial clojure.set/union x) start-set)))))\n               (inc c))))))", "problem": 85, "user": "4e568873535d8a8b8723a283"}, {"code": "(fn [s]\r\n  (reduce\r\n    (fn [s r] (into s (map #(conj % r) s)))\r\n    #{#{}}\r\n    s))", "problem": 85, "user": "4f9597e0e4b0dcca54ed6cd4"}, {"code": "reduce (fn ps [s elt]\n  (reduce conj s (map #(conj % elt) s))\n) #{#{}}", "problem": 85, "user": "4f84400de4b033992c121c2e"}, {"code": "(fn powerset [incoming-set]\n  (if (empty? incoming-set)\n    #{#{}}\n    (set (let [[x & xs] (seq incoming-set)\n               T (powerset xs)]\n           (concat T (map #(conj % x) T))))))", "problem": 85, "user": "4e9fd521535d7eef3080729a"}, {"code": "(fn pset [aset]\n  (set\n    (if-let [elem (first aset)]\n      (let [ps (pset (disj aset elem))]\n        (concat ps (map #(conj % elem) ps)))\n      [aset])))", "problem": 85, "user": "4f9d53f3e4b0dcca54ed6d21"}, {"code": "(fn power-set [s]\n  (if (seq s)\n    (let [ss (power-set (rest s))\n          f (first s)]\n        (clojure.set/union ss (set (map #(conj % f) ss))))\n    #{#{}}))", "problem": 85, "user": "4f9120d8e4b0dcca54ed6c96"}, {"code": "#(set\n   (for [n (range (bit-shift-left 1 (count %)))]\n     (set (keep-indexed (fn [i e] (if (bit-test n i) e)) %))))", "problem": 85, "user": "4f9fe2b9e4b0dcca54ed6d40"}, {"code": "(fn [s]\n    (let [vs (vec s)\n          n-max (dec (int (Math/pow 2 (count vs))))\n          bdigit\n          (fn bdigit [n]\n            (let [n2 (quot n 2)\n                  m  (mod n 2)]\n              (lazy-seq\n                (if (zero? n2)\n                  (list m)\n                  (cons m (bdigit n2))))))]\n      (loop [n 0\n             pset #{}]\n        (if (< n-max n)\n          pset\n          (recur (inc n)\n                 (conj pset\n                       (set\n                        (map first (filter #(= 1 (second %))\n                                (map vector vs (bdigit n)))))))))))", "problem": 85, "user": "4f5cc3b8e4b0030a34fb2b2b"}, {"code": "(fn subsets2 [coll]\n  (letfn [(combine [e s] (reduce #(conj %1 %2) s (map #(conj % e) s)))]\n    (loop [r #{#{}} coll coll]\n      (if (empty? coll)\n        r\n        (recur (combine (first coll) r) (set (rest coll)))))))\n\n;(fn subsets [coll]\n;        (if (empty? coll)\n;          #{#{}}\n;          (let [e (first coll)\n;                s (set (subsets (set (rest coll))))]\n;            (reduce #(conj %1 %2) s (map #(conj % e) s)))))", "problem": 85, "user": "4f1bee08535d64f60314647e"}, {"code": "reduce #(into %1 (map (fn [z] (conj z %2)) %1)) #{#{}}", "problem": 85, "user": "4fa6d532e4b081705acca1be"}, {"code": "(fn [s]\r\n  (reduce \r\n    (fn [init e] \r\n      (set (concat init (map #(conj % e) init) [#{e}])))\r\n    #{#{}} s))", "problem": 85, "user": "4faa3eeae4b081705acca1ed"}, {"code": "(fn [s]\n  (letfn [(step [s] (map #(disj s %) s))]\n    (loop [r #{s}, result #{#{}}]\n      (if (= r #{#{}})\n        result\n        (recur (set (mapcat step r)) \n               (apply (partial conj result) r))))))", "problem": 85, "user": "4faa9593e4b081705acca1f9"}, {"code": "(fn f [s]\n  (if (empty? s) #{ #{} }\n  (clojure.set/union (f (rest s))\n                    (set (map #(conj % (first s)) (f (rest s)))))))", "problem": 85, "user": "4facd2fae4b081705acca22f"}, {"code": "(comp set\n      (partial reduce (fn [s x]\n                        (concat s (map #(conj % x) s)))\n               #{#{}}))", "problem": 85, "user": "4f3fb586e4b0e243712b1f9c"}, {"code": "(fn power-set [s]\n  (if (empty? s)\n      #{#{}}\n      (let [s2 (power-set (rest s))]\n          (clojure.set/union\n                (set (map #(conj % (first s)) s2))\n                 s2)\n      )))", "problem": 85, "user": "4f404dcee4b0e243712b1fb0"}, {"code": "(fn power-set [s]\n  (if (empty? s) (set [s])\n    (let [_ (println \"s: \" s)\n          elt (first s)\n          _ (println \"elt\" elt)\n          others (set (rest s))\n          _ (println \"other\" others)\n          ps (power-set others)\n          _ (println \"ps\" ps)\n          with-elt (set (map #(conj % elt) ps))\n          _ (println \"with-elt\" with-elt)]\n      (clojure.set/union ps with-elt))))", "problem": 85, "user": "4f036fb3535dcb61093f6ac8"}, {"code": "(fn [s]\n    (reduce (fn [a i] (into a (map #(conj % i) a))) #{#{}} s))", "problem": 85, "user": "4f4274f2e4b0d7d3c9f3fd00"}, {"code": "(fn [s]\n  (reduce (fn [ps x]\n            (into ps (map #(conj % x) ps)))\n          #{#{}}\n          s))", "problem": 85, "user": "4f969a66e4b0dcca54ed6cde"}, {"code": "(fn [s]\n (loop [curr #{#{}} res #{#{}} n 1]\n         (if-not (> n (count s))\n           (let [next-curr\n                 (set (filter #(= (count %) n)\n                              (for [a curr b s]\n                                (conj a b))))]\n             (recur next-curr (set (concat res next-curr)) (inc n)))\n           res)))\n\n;; My solution (the one above) worked, but I like this one better:\n;;\n;; (fn [s]\n;;   (reduce (fn [ps x]\n;;             (reduce (fn [ps s]\n;;                       (conj ps (conj s x))) ps ps)) #{#{}} s))", "problem": 85, "user": "4fa0a4b1e4b0dcca54ed6d4f"}, {"code": "(fn p [s]\n  (if (empty? s) #{s}\n    (clojure.set/union\n      (p (set (rest s)))\n      (set\n        (map\n          #(conj % (first s))\n          (p (set (rest s))))))))", "problem": 85, "user": "4fb2101ce4b081705acca284"}, {"code": "reduce \n  (fn [m v] \n    (into m \n      (map #(conj % v) m)))\n  #{#{}}", "problem": 85, "user": "4f991ec1e4b0dcca54ed6cfb"}, {"code": "(fn [s]\n  (set (map set ((fn f [[x & xs]] \n    (if x\n      (let [r (f xs)]\n        (concat (map (partial cons x) r)\n                r))\n        '(())))\n                 (seq s)))))", "problem": 85, "user": "4f9a0064e4b0dcca54ed6d03"}, {"code": "(fn [s] (apply hash-set (reduce (fn [s v] (concat s (map #(conj % v) s))) #{#{}} s)))", "problem": 85, "user": "4f954dbce4b0dcca54ed6ccd"}, {"code": "(fn [s]\n  (set\n    (for [i (range (bit-shift-left 1 (count s)))]\n      (set (keep-indexed #(if (pos? (bit-and i (bit-shift-left 1 %1))) %2) (vec s)))\n    )\n  )\n)", "problem": 85, "user": "4f725201e4b07046d9f4f02f"}, {"code": "(fn [s]\n    (letfn\n      [(subset-indexes [start set-length subset-length]\n         (cond\n           (> start (- set-length subset-length)) []\n           (zero? subset-length) [[]]\n           :else (for [x (range start set-length)\n                       y (subset-indexes (inc x) set-length (dec subset-length))]\n                   (cons x y))))\n       (pick-indexes [sq indexes]\n         (map #(nth sq %) indexes))]\n      (->>\n        (for [x (range (inc (count s)))]\n          (subset-indexes 0 (count s) x))\n        (apply concat)\n        (map #(pick-indexes (seq s) %))\n        (map set)\n        set)))", "problem": 85, "user": "4f725466e4b07046d9f4f030"}, {"code": "(fn [s]\r\n  (loop \r\n    [[h & t] (seq s)\r\n     res #{}]\r\n     (cond \r\n       (not h) \r\n       (conj res #{})\r\n\r\n       :else\r\n       (recur t (conj \r\n         (into res \r\n          (map #(conj % h) res))\r\n         #{h})))))", "problem": 85, "user": "4f039c67535dcb61093f6b3a"}, {"code": "(fn [s]\n  (apply hash-set #{}\n  ((fn p [s]\n    (if (empty? s) s\n      (let [h (first s) t (rest s) rr (p t)]\n        (concat [#{h}] rr (map #(conj % h) rr))))) s)))", "problem": 85, "user": "4fa30027e4b081705acca187"}, {"code": "(fn [s] \n  (let [elems (vec s)\n        n (count s)\n        masks (map #(take n (concat (reverse (Integer/toString % 2)) (repeat \\0))) (range (int (Math/pow 2 n))))\n        melem #(for [[e m] (partition 2 (interleave elems %)) :when (= \\1 m) ] e)]\n    (set (map #(set (melem %)) masks))))", "problem": 85, "user": "4fc67081e4b0ee37620e1813"}, {"code": "(fn pows [s]\n   (loop [[lh & lt] (list s), acc #{#{}}]\n     (if (nil? lh)\n       acc\n       (if (acc lh)\n         (recur lt acc)\n         (recur (apply conj lt\n                       (map #(disj lh %) lh))\n                 (conj acc lh))))))", "problem": 85, "user": "4fc0853ae4b081705acca327"}, {"code": "(fn power-set [coll]\n  (loop [result #{#{}}]\n    (let [iter (set (map set (mapcat #(map conj result (repeat %)) coll)))]\n      (if (= result iter) (conj result #{}) (recur iter)))))", "problem": 85, "user": "4faafccde4b081705acca209"}, {"code": "(fn ps [s]\n  (if (empty? s)\n    #{#{}}\n    (let [a (first s)]\n      (set (mapcat #(list (conj % a) %) (ps (disj s a)))))))", "problem": 85, "user": "4fc4eadee4b081705acca353"}, {"code": "(fn [s] (set (reduce (fn [cc e] (into (map #(conj % e) cc) cc)) #{#{}} s)))", "problem": 85, "user": "4efd8b67535de96065cf5085"}, {"code": "(fn powerset [st]\n  (if-let [[x & xs] (seq st)]\n    (set (concat (powerset xs) (map #(conj % x) (powerset xs))))\n    #{#{}}))", "problem": 85, "user": "4fcaf7a4e4b0ee37620e1857"}, {"code": "(fn power-set [s]\n  (if (empty? s) #{s}\n    (let [tail (power-set (set (rest s)))]\n      (set (concat (map #(conj % (first s)) tail) tail))\n      )\n    )\n  )", "problem": 85, "user": "4fcad14ce4b0ee37620e1856"}, {"code": "(fn p [s]\n  (if (= #{} s) #{#{}}\n    (let [res (p (disj s (first s)))]\n      (into res (map #(conj % (first s)) res)))))", "problem": 85, "user": "4fca1cd6e4b0ee37620e184c"}, {"code": "(fn pset\n  ([s] (pset #{#{}} s))\n  ([a s]\n    (if (empty? s) \n      a\n      (pset\n        (into a (map #(conj % (first s)) a))\n        (rest s)))))", "problem": 85, "user": "4fce5474e4b0d4b2a7a9d451"}, {"code": "(fn [B] (set (map (fn [K] ((fn [X Y] (set (map first (filter #(= 1 (second %)) (map vector X Y))))) B K)) (map (fn [x] (take (count B) (map #(bit-and % 1) (iterate #(bit-shift-right % 1) x)))) (range (bit-shift-left 2 (- (count B) 1)))))))", "problem": 85, "user": "4fcf1755e4b03432b189f40c"}, {"code": "(fn [s] (let [c (count s) v (vec s)] (if (= c 0) #{#{}} (set (for [n (range (int (Math/pow 2 c)))] (set (filter (complement nil?) (map-indexed #(if (bit-test n %) %2 nil) v))))))))", "problem": 85, "user": "4fb3b865e4b081705acca2a2"}, {"code": "(fn [s]\n  (reduce\n    #(into %1 (for [a %1] (conj a %2)))\n    #{#{}}\n    s))", "problem": 85, "user": "4f7f9665e4b033992c121bea"}, {"code": "(fn power-set\n  ([a] (power-set (seq a) #{#{}}))\n  ([[f & r :as s] sets]\n    (if (empty? s) \n        sets\n        (recur r\n          (into sets\n            (map #(conj % f) sets))))))", "problem": 85, "user": "4fb1d907e4b081705acca282"}, {"code": "(fn [s]\n  (let [bm (take (count s)\n                 (iterate (partial * 2) 1))]\n    (set\n      (for [n (range (inc (reduce + bm)))]\n        (reduce (fn [a [p v]] (if p (conj a v) a))\n                #{}\n                (map #(list\n                       (pos? (bit-and n %))\n                           %2) bm s))))))", "problem": 85, "user": "4e68b46c535d8ccf87e9fe87"}, {"code": "(fn [s]\n  (let [v (vec s)]\n    (->> (range (Math/pow 2 (count s)))\n      (map #(-> %\n              (Integer/toString 2)\n              Integer/parseInt\n              (->>\n                (format (str \"%0\" (max 1 (count s)) \"d\"))\n                (map {\\1 true \\0 false})\n                (map vector (range))\n                (mapcat (fn [[pos in]] (if in [(v pos)] []))))\n              set))\n      set)))", "problem": 85, "user": "4f1bb9d8535d64f60314647d"}, {"code": "(fn power-set [s]\n  (if (empty? s) #{#{}}\n    (let [\n      s1 (first s)\n      ps (power-set (rest s))]\n      (reduce #(conj % (conj %2 s1)) ps ps))))", "problem": 85, "user": "4fd22e70e4b04c3a95aa041c"}, {"code": "(fn power-set [s]\n     (letfn [(f [e t] (set (map #(clojure.set/union % #{e}) t)))]\n       (if (empty? s)\n         #{#{}}\n         (first\n           (map\n             #(let [y (power-set (clojure.set/difference s #{%}))]\n                (clojure.set/union y (f % y)))\n             s)))))", "problem": 85, "user": "4fb12b35e4b081705acca275"}, {"code": "reduce\n  (fn [a x] (into a (map #(conj % x) a)))\n  #{#{}}", "problem": 85, "user": "4fd96694e4b05e33b9224f37"}, {"code": "(fn[s]\n  (set (reduce (fn [s v] (concat s (map #(conj % v) s))) [#{}] s)))", "problem": 85, "user": "4f465096e4b0d56e7bb92b9a"}, {"code": "(fn [s]\n  (set\n    (map \n      (fn [i] (set (keep-indexed (fn [bit v] (if (bit-test i bit) v)) s)))\n      (range (Math/pow 2 (count s))))))", "problem": 85, "user": "4fba7d1ee4b081705acca2e0"}, {"code": "(fn power-set [s]\r\n  (let [d (atom {})\r\n        ps (fn ps [s]\r\n             (if (empty? s)\r\n                 #{#{}}\r\n               (if-let [result (@d s)]\r\n                  result\r\n                  (reduce into #{}\r\n                          (map (fn [x] (let [s1 (disj s x)\r\n                                             sub-sets (ps s1)]\r\n                                         (swap! d #(assoc % s1 sub-sets))\r\n                                         (concat (map #(conj % x) sub-sets)\r\n                                                 sub-sets)))\r\n                               s)))))]\r\n    (ps s)))", "problem": 85, "user": "4fcc6cb3e4b0ee37620e1861"}, {"code": "(fn [& in]\n  (loop [acc (set [#{} (first in)]) prev-combs in]\n    (if (empty? (first prev-combs)) acc\n        (let [next-combs (set (reduce #(clojure.set/union %1 %2)\n                                      (for [one-set prev-combs]\n                                        (for [elem one-set] (disj one-set elem)))))\n              next-acc (clojure.set/union acc next-combs)]\n          (recur next-acc next-combs)))))", "problem": 85, "user": "4fb86dc9e4b081705acca2d8"}, {"code": "(fn [ s]\n(letfn [(ps [super-set c] \n  (if (= c (count s)) super-set\n    (let [ new-sets  ( for [ a s b super-set] (conj b a))]\n      (recur (into super-set new-sets) (inc c)))))]\n       (ps #{#{}} 0)))", "problem": 85, "user": "4fccdc75e4b0ee37620e186d"}, {"code": "(fn powerset [x]\n  (if (seq x)\n      (let [s (powerset (rest x)) ]\n      (clojure.set/union s\n        (map (fn [p] (conj p (first x))) s)))\n      #{#{}}))", "problem": 85, "user": "4fdd27f3e4b05e33b9224f78"}, {"code": "(fn power-set [S]\n  (if (empty? S)\n    #{#{}}\n    (let [e (first S)\n          P (power-set (disj S e))\n          Q (set (map #(conj % e) P))]\n      (into P Q))))", "problem": 85, "user": "4fe84c74e4b07c9f6fd12c3c"}, {"code": "(fn [s]\n  (loop [result #{#{}}]\n    (let [next (into result\n                     (apply concat (map (fn [x] (map #(conj x %) s))\n                                        result)))]\n      (if (= next result)\n        result\n        (recur next)))))", "problem": 85, "user": "4fe8aef4e4b07c9f6fd12c6c"}, {"code": "reduce #(into #{} (concat % (for [x %] (conj x %2)))) #{#{}}", "problem": 85, "user": "4fca2ef0e4b0ee37620e184e"}, {"code": "(fn [s]\n  (let [n (fn [& sets]\n            (into (set sets) (for [s sets x s] (disj s x))))\n        c (count s)]\n    (nth (iterate (partial apply n) (n s)) c)))", "problem": 85, "user": "4f7431d2e4b044e54cd9a8f7"}, {"code": "(fn powerset [s]\n  (letfn [(pslis [lis]\n            (if (empty? lis)\n              '(())\n              (let [psr (pslis (rest lis))]\n                 (concat psr\n                         (map #(cons (first lis) %) psr)))))]\n     (set (map set (pslis (seq s))))))", "problem": 85, "user": "4fe87e56e4b07c9f6fd12c40"}, {"code": "#(set (map (fn[a](set (take (rand-int (+ 1 (count %))) (shuffle %)))) (range 100000)))", "problem": 85, "user": "4fb3dd1ee4b081705acca2a5"}, {"code": "(fn jajj [z]\r\n   ((fn ps [x] \r\n      (if (empty? x) \r\n        #{#{}} \r\n        (let [[e & r] x, res (ps r)]\r\n          (into res (map #(conj % e) res))))) \r\n     (seq z)))", "problem": 85, "user": "4feada56e4b0140c20fb9c11"}, {"code": "(fn [c]\r\n   ((fn power[z] \r\n      (let [x (map (fn [x] (map (fn [y] (disj x y)) x)) z)\r\n            n (set (concat z (set (flatten x))))] \r\n       (if (= z n) n (power n))))\r\n     #{c}))", "problem": 85, "user": "4ff07688e4b0678c553fc324"}, {"code": "(fn [coll]\n  (reduce (fn [s x] (into s (map #(conj % x) s)))\n          #{#{}}\n          coll))", "problem": 85, "user": "4db016af838c48654951d9b9"}, {"code": "(fn [s]\n  (let [bi (fn bi [bin]\n             (if (or (nil? bin) (= 0 (count bin)))\n               nil\n               (let [p (peek bin)\n                     t (pop bin)]\n                 (if p\n                   (conj t false)\n                   (conj (bi t) true)))))]\n    (loop [x (seq s)\n           acc #{}\n           mask (vec (repeat (count x) true))]\n      (if (zero? (count (filter identity mask)))\n        (conj acc #{})\n        (recur x (conj acc\n                       (into #{} (map #(first %) (filter #(second %) (map #(vector % %2) x mask))))) (bi mask))))))", "problem": 85, "user": "4ff9d4e5e4b0678c553fc3b0"}, {"code": "(fn powerset [s]\n    (into #{}\n        (map #(into #{} %)\n             ((fn ps [ls]\n                (if (empty? ls) '(())\n                    (clojure.set/union (ps (next ls))\n                                       (map #(conj % (first ls)) (ps (next ls))))))\n              s))))", "problem": 85, "user": "4ff304f4e4b0678c553fc343"}, {"code": "(fn [s]\n  (reduce (fn [s k] (into s (map #(conj % k) s))) #{#{}} s))", "problem": 85, "user": "4f40ccd9e4b0e243712b1fc0"}, {"code": "(fn P [S]\n  (if (empty? S) #{S}\n    (let [e (first S)\n          T (disj S e)\n          PT (P T)\n          F (fn [e T] (set (map #(conj % e)  T)))]\n    (set (concat PT (F e PT))))))", "problem": 85, "user": "4e7f4147535db966e863cc3d"}, {"code": "(fn p [s]\r\n    (let [u #(clojure.set/union %1 %2)]\r\n    (reduce (fn [a i] \r\n                (u a (map #(u % #{i}) a)))\r\n            #{#{}}\r\n            s)))", "problem": 85, "user": "4ff4c9dae4b0678c553fc360"}, {"code": "(fn power-set\n  [sn]\n  (reduce\n   (fn [s e] (clojure.set/union s (map #(conj % e) s)))\n   #{#{}}\n   sn))", "problem": 85, "user": "4f8bbb27e4b02e764a0a5182"}, {"code": "(fn [s] (reduce\n  (fn [p e] (into p (map #(conj % e) p)))\n  #{#{}} s\n))", "problem": 85, "user": "4ef48422535dced4c769f236"}, {"code": "(fn powerset [set]\n  (if (= set #{}) #{#{}}\n    (loop [s [set] super #{#{} set}]\n\t    (let [combinations (fn [coll] (map #(disj coll %) coll))\n\t          ssets (reduce (fn [acc e] (into acc (combinations e))) #{} s)]\n\t      (if (= #{} (first ssets))\n\t        super\n\t        (recur ssets (into super ssets)))\n\t      ))))", "problem": 85, "user": "5003deb9e4b0678c553fc445"}, {"code": "(fn pw [ls] (set (map set\n  (if (empty? ls) '(())\n      (clojure.set/union (pw (next ls))\n(map #(conj % (first ls)) (pw (next ls))))))))", "problem": 85, "user": "4fdf2b50e4b05e33b9224f93"}, {"code": "(fn power [s]\n  (if (empty? s)\n      #{#{}}\n      (let [pwr (power (rest s))]\n        (clojure.set/union\n          pwr\n          (map #(conj % (first s)) pwr)))))", "problem": 85, "user": "5002b6e5e4b0678c553fc42c"}, {"code": ";; If we have determined the power set p for a set s so far, and we\n;; now want to calculate the power set for a set containing s and one\n;; more element x, then:\n\n;; 1. every set in p is in that power set (none of them contain\n;; element x), and\n\n;; 2. every one of those sets with element x added to it are also in\n;; the power set.\n\n(fn [s]\n  (reduce (fn [power-set x]\n            (into power-set (map #(conj % x) power-set)))\n          #{#{}} s))", "problem": 85, "user": "500d8c49e4b07ccb9a7ddb00"}, {"code": "(fn powerset [s]\n  (if (empty? s) #{#{}}\n    (let [ps (powerset (rest s))]\n      (set (concat ps (map #(conj % (first s)) ps))))))", "problem": 85, "user": "500933a6e4b046cdb195e074"}, {"code": "(fn [start] ((fn ps [s]\n    (if (empty? s) \n        #{#{}}\n      (let [i (first s)\n            p (ps (rest s))]\n        (into p (for [col p]  (conj col i))))\n      ))\n  start))", "problem": 85, "user": "4fe900a6e4b0547ebccb243a"}, {"code": "(fn power-set [set]\n  (letfn [(power [self set]\n            (if (empty? set)\n              #{#{}}\n              (reduce clojure.set/union #{set #{}} (map (partial self self)\n                                                        (map (partial disj set) set)))))]\n    (power (memoize power) set)))", "problem": 85, "user": "4ff355a1e4b0678c553fc34d"}, {"code": "(fn powerset\n  [coll]\n  (set (reduce (fn [acc x]\n                 (concat acc (map #(conj % x) acc)))\n               #{#{}}\n               coll)))", "problem": 85, "user": "4dc0ff08535d020aff1edf84"}, {"code": "(fn pwrset [iset]\n    (loop [next_stack #{iset}\n           builder #{ #{} }]\n    (if (empty? next_stack)\n      builder\n      (let [frst (first next_stack)\n            next_entries (clojure.set/difference (set (map #(disj frst %) frst)) builder)]\n        (if (empty? next_entries)\n          (recur (disj next_stack frst)\n                 (conj builder frst))\n          (recur (clojure.set/union (disj next_stack frst) next_entries)\n                 (conj builder frst)))))))", "problem": 85, "user": "50057f23e4b0678c553fc466"}, {"code": "(fn [s]\n  (let [p (fn [c n s]\n               (cond (zero? n) (assoc c 0 #{})\n                     (= n 1) (assoc c 1 (set (map hash-set s)))\n                     :else (assoc c n\n                                  (reduce into #{} \n                                          (for [i s]\n                                            (map #(conj % i) (c (dec n))))))))]\n       (reduce into (set [#{} s]) (vals (reduce #(p % %2 s) {} (range (count s)))))))", "problem": 85, "user": "4f05ea25535dcb61093f6c02"}, {"code": "(fn [coll]\r\n  (reduce (fn [s x] (into s (map #(conj % x) s)))\r\n          #{#{}}\r\n          coll))", "problem": 85, "user": "500d1db4e4b05f7c30cfa69f"}, {"code": "(fn [s]\n  (let [num-to-ls (fn [n c] (map #(bit-test n %) (range c)))\n        get-subset (fn [n] (map #(get % 1) (filter #(get % 0) (map vector (num-to-ls n (count s)) s))))]\n    (set (map #(set (get-subset %)) (range (Math/pow 2 (count s)))))))", "problem": 85, "user": "5003ee7de4b0678c553fc446"}, {"code": "(fn [x]\n  (letfn [(power-set [x]\n                     (if (= 0 (count x))\n                       #{x}\n                       (if (= 1 (count x))\n                         #{#{} #{(first x)}}\n                         (let [fst (first x) \n                               rst (rest x) \n                               ps-wo-fst (power-set rst)\n                               ps-w-fst (into #{} (map #(conj % fst) ps-wo-fst))\n                               ]\n                           (clojure.set/union ps-wo-fst ps-w-fst)\n                           )\n                         ))) ] \n         (power-set x)\n         ))", "problem": 85, "user": "4dca8b6d535d5973398f9288"}, {"code": "; (for [x #{1 2} y #{1 2}] [x y] => [1 1] [1 2] [2 1] [2 2]\n; => map set: #{1} #{1 2} #{2}\n(fn [s]\n  (if (empty? s) ; special case\n      #{#{}}\n      (conj (reduce #(set (for [x % y %2]\n                               (conj (if (set? x) x #{x}) y)))\n                    (repeat (count s) s)) #{})))", "problem": 85, "user": "500900dee4b0144d4f561e42"}, {"code": "(fn powersets [s]\n  (let [singleElementSets (set (map #(hash-set %) s))\n        startset (set (conj singleElementSets #{}))\n        ]\n    ((fn rec [mu ones new]\n       (let [unions (set \n                      (for [x new y ones]                                       \n                       (into x y)))                                                            \n            newMu (into mu unions)                                                                        \n            ]                                                        \n        (if (= mu newMu)                                                          \n          mu                                                          \n          (recur newMu ones unions)          \n          )          \n        )        \n      ) startset singleElementSets singleElementSets)                                              \n    )    \n  )", "problem": 85, "user": "4fcf5292e4b03432b189f40e"}, {"code": "reduce (fn [s e] (clojure.set/union s (map #(conj % e) s))) #{#{}}", "problem": 85, "user": "4ed8b598535d10e5ff6f52fc"}, {"code": "(fn powerset [s]\n  (if (empty? s)\n    #{#{}}\n    (let [t (set (rest s))]\n      (clojure.set/union (powerset t)\n                         (set (for [x (powerset t)] (conj x (first s))))))))", "problem": 85, "user": "500cb910e4b05f7c30cfa698"}, {"code": "(fn [s] \n  (loop [all #{s}] \n    (let [sets (fn [x] (map #(disj x %) x)) \n          sub (set (apply concat all (map sets all)))]\n      (if (= sub all) sub (recur sub)))))", "problem": 85, "user": "500aa15ee4b03d00572d2d76"}, {"code": "(fn [s]\n  (let [c (count s)\n        binary   (fn b [x] (cons (rem x 2)\n                             (if (> x 1) (b (quot x 2)) ())))\n        pad      (fn [x] (concat x\n                               (repeat (- c (count x)) 0)))\n        elem-set (fn [pattern] (set\n                                 (map second\n                                   (filter #(= 1 (first %))\n                                     (map vector pattern (vec s))))))]\n    (set\n      (map (comp elem-set pad binary)\n        (range (Math/pow 2 c))))))", "problem": 85, "user": "4f4e7c01e4b03ad3f0c10cc9"}, {"code": "(fn p\n  ([s] (p '(()) s))\n  ([r s]\n    (if (empty? s)\n      (set (map #(set %) r))\n      (p (concat r (map #(conj % (first s)) r)) (rest s)))))", "problem": 85, "user": "4f9f7daae4b0dcca54ed6d37"}, {"code": "(fn [s]\n  (loop [res (map #(conj #{} %) s)]\n    (let [res+1 (reduce (fn [acc x] (into acc (map #(conj x %) s))) #{} res)]\n      (if (= res res+1)\n        (conj res #{})\n        (recur res+1)))))", "problem": 85, "user": "5028cd0fe4b01614d1633ffc"}, {"code": "(fn [s]\n  (loop [xs s acc #{#{}}]\n    (if (empty? xs)\n      acc\n      (recur \n        (rest xs) \n        (clojure.set/union\n          acc\n          (map #(conj % (first xs)) acc))))))", "problem": 85, "user": "503917a0e4b088a6a14ca763"}, {"code": "(fn [c]\n  (reduce #(into % (for [x %]\n                     (conj x %2)))\n          #{#{}}\n          c))", "problem": 85, "user": "4e944706535dbda64a6f6b11"}, {"code": "(fn p [s]\n  (if-let [[a & b] (seq s)]\n    (let [x (p b)]\n      (into x (map #(conj % a) x)))\n    #{#{}}))", "problem": 85, "user": "4f625f68e4b0defedf855fd2"}, {"code": "(fn f [coll]\n  (if (= (count coll) 0) #{#{}}\n    (set \n      (if (= (count coll) 1)\n        (list (set coll) #{})\n        (map set\n          (mapcat\n            #(list % (cons (first coll) %))\n            (f (rest coll))))))))", "problem": 85, "user": "50361b6be4b0fbe0a74d26be"}, {"code": "(partial reduce \n  #(into % (map (fn[s](conj s %2)) %)) \n  #{#{}})", "problem": 85, "user": "50336c6be4b0c6c1199c710f"}, {"code": "(fn [s]\n  (reduce\n    (fn [sum v] (apply conj sum (map #(conj % v) sum)))\n    #{#{}} s))", "problem": 85, "user": "5033a1fbe4b062bc5d7ae155"}, {"code": "(fn powerset [r]\n  (if (empty? r)\n    #{#{}}\n    (set\n     (let [[x & xs] (seq r)]\n       (mapcat (fn [p] [p, (conj p x)]) (powerset xs))))))", "problem": 85, "user": "4e8338d6535db62dc21a62d3"}, {"code": "(fn powerset [s]\n  (reduce #(into % (for [subset %] (conj subset %2))) #{#{}} s))", "problem": 85, "user": "5032b066e4b00c0952a257ea"}, {"code": "(fn [ls]\r\n  (set (reduce (fn [[& xs] el] (concat xs  (map #(conj % el) xs))) #{#{}} ls)))", "problem": 85, "user": "502a9fdee4b095a7adb898b4"}, {"code": "(fn powerset- [coll]\n ^{:doc \"85. Write a function which generates the power set of a given set.\"}\n (if (empty? coll)\n   #{#{}}\n   (let [xs (powerset- (rest coll))]\n     (reduce conj xs (map #(conj %1 (first coll)) xs)))))", "problem": 85, "user": "4e5eb843535d8a8b8723a2d4"}, {"code": "(fn power-set [s]\n  \t\n\t(let [start (set (conj (map #(set [%]) s) s #{}))]\n\t\t((fn f [ans left]\n\t\t\t(if (empty? left)\n\t\t\t\tans\n\t\t\t\t(f (into ans (set (mapcat (fn [x]\n\t\t\t\t\t(for [y left :let [y (conj x y)]] y)\n\t\t\t\t) ans))) (rest left))\n\t\t\t)\n\t\t) start s)\n\t)\n)", "problem": 85, "user": "4f7b6b90e4b06e829148e1a4"}, {"code": "(fn [s] (set (map\n           (fn [n] (set (map first (filter second (zipmap s (map odd? (take (count s) (iterate #(bit-shift-right % 1) n))))))))\n           (range (java.lang.Math/pow 2 (count s))))))", "problem": 85, "user": "4e9609ad535dbda64a6f6b3e"}, {"code": "(fn [coll]\n  (loop [c coll, ss #{#{}}]\n    (if (empty? c)\n      ss\n      (recur (next c)\n             (->> (map #(conj % (first c)) ss)\n                  (into ss))))))", "problem": 85, "user": "4eb8ec4a535dfed6da9c6d4b"}, {"code": "(fn [x]\n  (loop [s #{x} c (count x)] \n    (if (pos? c) \n      (recur (into s (mapcat (fn [v] (map #(disj v %) v)) s)) (dec c)) \n      s)))", "problem": 85, "user": "502904e0e4b0feaf66e22fad"}, {"code": "reduce #(apply conj % (map conj % (repeat %2))) #{#{}}", "problem": 85, "user": "503b6995e4b07a1917cc34dd"}, {"code": "(fn [s]\n    (loop [i (count s)\n           r #{#{}}]\n      (if (= i 0) r\n        (recur (dec i)\n               (into r (for [x r y s] (conj x y)))))))", "problem": 85, "user": "4f58d92fe4b0a7574ea71858"}, {"code": "(fn [s]\r\n  (let [mem (atom {})\r\n        swapmem (fn [args f_n] \r\n                  (if-let [e (find @mem args)]\r\n                    (val e)\r\n                    (let [ret (f_n)]\r\n                      (swap! mem assoc args ret)\r\n                      ret)))\r\n        f (fn f [fst rst result] \r\n            (if (empty? rst)\r\n              (conj result fst)\r\n              (set \r\n                (mapcat \r\n                  (fn [arg] \r\n                    (let [n_fst (conj fst arg)\r\n                          n_rst (disj rst arg)\r\n                          n_result (conj result fst)]\r\n                      (conj (swapmem n_fst #(f n_fst n_rst n_result)) fst)))\r\n                  rst))))]\r\n    (f #{} s #{})))", "problem": 85, "user": "4f0da4e4535d0136e6c22319"}, {"code": "(fn [x]\r\n  (let [n (count x)] (into #{}\r\n    (for [s (range (int (Math/pow 2 n)))] \r\n      (into #{} (remove nil? (map-indexed #(if (zero? (bit-and s (bit-shift-left 1 %))) nil %2) x \r\n        )))))))", "problem": 85, "user": "503354c3e4b0c6c1199c710c"}, {"code": "(fn [s]\n  (let [elems (vec s) n (count elems)]\n    (set\n     (map\n      (fn [x] (set (map #(elems %) (filter #(bit-test x %) (range n)))))\n      (range (Math/pow 2 n))))))", "problem": 85, "user": "4f2e0369e4b0d6649770a064"}, {"code": "(fn power-set [coll]\n  (if (empty? coll)\n    #{#{}}\n  (let [others (power-set (rest coll))]\n      (clojure.set/union\n        others\n        (map #(conj % (first coll)) others)\n        ))))", "problem": 85, "user": "4e6e2ac4535d5021c1a895ff"}, {"code": "#((fn [p s] (if (empty? s) (conj p #{})\n (recur (apply conj p #{(first s)} (map (fn [x] (conj x (first s))) p)) (rest s)))) #{} %)", "problem": 85, "user": "50548ce8e4b0b1b9d1860ead"}, {"code": "(fn [xs]\n   (letfn\n       [(diff [xs ys]\n          (reduce disj xs ys))\n        (comb [cs xs]\n          (set\n           (mapcat\n            #(for [y (diff xs %)] (conj % y))\n            cs)))]\n     (loop [m (count xs) ys (set (map hash-set xs)) zs #{}]\n       (if (>= 1 m)\n         (conj zs #{})\n         (let [ys' (comb ys xs)\n               zs' (into zs (concat ys ys'))]\n           (recur (dec m) (comb ys xs) zs'))))))", "problem": 85, "user": "504e13fce4b078edc5f593bc"}, {"code": "(letfn [(next-sets [s]\n          (map #(disj s %) s))\n        (next-level [[acc sets]]\n          (let [next-acc (apply conj acc sets)\n                next-sets (if (= sets #{#{}})\n                            #{}\n                            (apply conj #{}\n                                   (mapcat next-sets sets)))]\n            [next-acc next-sets]))\n        (done? [[acc sets]]\n          (empty? sets))\n        (answer-from [[acc sets]] acc)\n        (iterate-until [pred f x]\n          (last\n           (take-while (complement pred)\n                            (iterate f x))))\n        (power-set [s]\n          (answer-from\n           (iterate-until done?\n                          next-level\n                          [#{#{}} #{s}])))]\n  power-set)", "problem": 85, "user": "5014754de4b094324338f8e5"}, {"code": "(fn p [s]\n  (if (empty? s)\n      #{#{}}\n      (set (reduce #(conj %1 %2 (conj %2 (first s))) #{} (p (rest s))))))", "problem": 85, "user": "504e04a4e4b078edc5f59397"}, {"code": "(fn power-set [s]\n  (if (empty? s)\n    #{#{}}\n    (let [other (power-set (rest s))]\n      (into other (map #(conj % (first s)) other)))))", "problem": 85, "user": "50586354e4b06522596eba78"}, {"code": "(fn [s]\n  (letfn [(one-less [s] (map #(disj s %) s))\n          (power-set [s] (map one-less (set (flatten s))))]\n   (set (flatten (take (inc (count s)) (iterate power-set [[s]]))))))", "problem": 85, "user": "501c1492e4b086d93747d180"}, {"code": "(fn [coll] (reduce (fn [s e] (set (concat s [#{e}] (map #(conj % e) s)))) #{#{}} coll))", "problem": 85, "user": "503d129fe4b06c4e0e1fa254"}, {"code": "(fn ps [s]\n  (if (empty? s)\n#{#{}}\n(let [r (ps (rest s))]\n(clojure.set/union r\n  (map #(conj % (first s)) r)))))", "problem": 85, "user": "4fca2a13e4b0ee37620e184d"}, {"code": "(fn power-set\r\n  [xs]\r\n  (if (empty? xs)\r\n    #{#{}}\r\n    (let [res (power-set (rest xs))]\r\n      (clojure.set/union\r\n       res\r\n       (map #(conj % (first xs)) res)))))", "problem": 85, "user": "50427899e4b0add3005c0fc2"}, {"code": "(fn [col]\r\n  (let [n (count col)\r\n        gen (fn [s]      \r\n            (set\r\n              (for [x col i s]\r\n                (conj i x))))]\r\n    (loop [i n s #{#{}}]\r\n      (if (< i 0)\r\n          (conj s #{})\r\n          (recur (dec i) (gen s))))))", "problem": 85, "user": "50435689e4b034ff00315d21"}, {"code": "(fn [s]\n  (letfn [(ps [acc s]\n    (if (seq s)\n      (concat (ps acc (rest s)) (ps (conj acc (first s)) (rest s))) \n      (list acc)))]\n    (set (ps #{} s))))", "problem": 85, "user": "504f865ee4b0a02f9cffde90"}, {"code": "(fn f85 [s]\n  (\n\t\t(fn foo [a b]\t\t\t\n\t\t\t(if (empty? b)\n\t\t\t\t#{a}\n\t\t\t\t(into\n\t\t\t\t\t(foo a (rest b))\n\t\t\t\t\t(foo (conj a (first b)) (rest b))\n\t\t\t\t)\n\t\t\t)\t\t\t\n\t\t)\n\t\t#{} s\n\t)\n)", "problem": 85, "user": "4e8d5edd535d65386fec2134"}, {"code": "(fn ps [s]\n   (if (empty? s) #{s}\n       (let [ pps (ps (set (rest s)))]\n         (into pps (map #(conj % (first s) ) pps)))))", "problem": 85, "user": "50563ae2e4b0ce54f56f0405"}, {"code": "(fn __ [s]\n  (letfn [(gen-subsets [ss]\n            (let [to-remove (vec ss)]\n               (map #(disj ss %) to-remove)))]\n  (loop [s (hash-set s) ps s]\n    (if (empty? (disj s #{}))\n      (conj ps #{})\n      (recur \n       (set (mapcat gen-subsets s))\n       (clojure.set/union (set (mapcat gen-subsets s)) ps))))))", "problem": 85, "user": "4fa719c0e4b081705acca1bf"}, {"code": "(fn [s]\r\n  (reduce \r\n    (fn [init e] \r\n      (set (concat init (map #(conj % e) init) [#{e}])))\r\n    #{#{}} s))", "problem": 85, "user": "504e685fe4b0f6ff3350c4ae"}, {"code": "(fn my-ps [s]\r\n  (if (empty? s)\r\n    #{#{}}\r\n    (let [fs (first s) sps (my-ps (next s))]\r\n      (into (into sps (set (map #(conj % fs) sps))) #{#{fs} #{}}))))", "problem": 85, "user": "5063fe48e4b075d771da6f9e"}, {"code": "(fn power-set [coll]\r\n    (letfn [(union [s1 s2] (reduce conj s1 s2))]\r\n      (if (empty? coll)\r\n        #{#{}}\r\n        (let [element (first coll)\r\n              sub1 (power-set (disj coll element))\r\n              sub2 (set (map #(union #{element} %) sub1))]\r\n          (union sub1 sub2)))))", "problem": 85, "user": "50436470e4b034ff00315d23"}, {"code": "(fn [s]\n  (let [p (fn [c n s]\n            (cond (zero? n) (assoc c 0 #{})\n                  (= n 1) (assoc c 1 (set (map hash-set s)))\n                  :else (assoc c n\n                               (reduce into #{}\n                                       (for [i s]\n                                         (map #(conj % i) (c (dec n))))))))]\n    (reduce into (set [#{} s]) (vals (reduce #(p % %2 s) {} (range (count s)))))))", "problem": 85, "user": "50705072e4b07bd6ad9b9f27"}, {"code": "(fn powerSet [x]\n  (into #{} (loop [x x y #{#{}}]\n\t\t(cond (empty? x) y\n\t\t\t  :else (recur (rest x) \n\t\t\t\t\t(clojure.set/union (for [set-iter y]\n\t\t\t\t\t\t(conj set-iter (first x))\n\t\t\t\t\t) y)\n\t\t\t\t\t)\n\t\t)\n\t))\n)", "problem": 85, "user": "50588af1e4b06522596eba7d"}, {"code": "(fn subsets [s] \n  (if (empty? s) #{#{}} \n    (let [x (first s) xs (rest s) sbsets (subsets xs)] \n      (into sbsets (map #(clojure.set/union #{x} %) sbsets)))))", "problem": 85, "user": "5065faf9e4b0313a384e5645"}, {"code": "(fn powerset [ls]\n  (if (empty? ls) #{#{}}\n      (into (powerset (next ls))\n      (map #(conj % (first ls)) (powerset (next ls))))))", "problem": 85, "user": "4fdb02aae4b05e33b9224f56"}, {"code": "(fn f [s]\n  (if-let [[x & xs] (seq s)]\n    (let [r (f (set xs))]\n      (into  \n       r\n       (map #(conj % x) r)))\n    #{#{}}))", "problem": 85, "user": "507056b8e4b07bd6ad9b9f29"}, {"code": "(fn subsets [s]\n  (if (empty? s)\n    #{#{}}\n    (let [p (subsets (rest s))]\n      (set (concat \n        p\n        (map \n          #(conj %1 (first s)) \n          p))))))", "problem": 85, "user": "5034b0e1e4b062bc5d7ae167"}, {"code": "(fn power-set [s]\n  (if (empty? s)\n    #{#{}}\n    (let [e (first s)\n          r (rest s)\n          s1 (power-set r)\n          s2 (map #(conj % e) s1)]\n      (into s1 s2))))", "problem": 85, "user": "4ee6400c535d93acb0a6685b"}, {"code": "(fn power-set [s]\n  (println s)\n  (if (empty? s)\n    #{#{}}\n    (let [without-fs (power-set (rest s))]\n      (into #{}\n        (concat\n          without-fs\n          (map #(set (cons (first s) %)) without-fs))))))", "problem": 85, "user": "504c8165e4b09724c857af31"}, {"code": "(fn power-set [s]\n  (if (empty? s) \n    #{#{}} \n    (let [x (first s), ps-x (power-set (disj s x))] \n      (into ps-x (map #(conj % x) ps-x)))))", "problem": 85, "user": "506ab9bae4b05d3b7762c74c"}, {"code": "(fn [xx]\n  (set((fn [x r i]\n    (let [c (count x) f (fn [s] (set(map (comp set #(remove % x)) s))) test (fn test [result src number]\n      (if (= 0 number)\n          [#{}]\n        (let [inner (fn inner [iresult index]\n          (if (> index (- (count src) number))\n              iresult\n            (recur (concat iresult (map #(conj % (nth src index)) (test [] (drop (+ 1 index) src) (- number 1))))\n                   (+ 1 index))))]\n          (inner [] 0))))]\n      (if (< c (* 2 i))\n          r\n        (let [os (test [] x i)]\n          (recur x (concat r os (f os)) (+ 1 i))))))(into [] xx) [] 0)))", "problem": 85, "user": "507fbd77e4b089ade05efbd3"}, {"code": "(fn [s] (set (reduce (fn [s v] (concat s (map #(conj % v) s))) [#{}] s)))", "problem": 85, "user": "5054c7e1e4b0b1b9d1860eb2"}, {"code": "(fn [s]\n    (letfn [(combine [acc x]\n              (conj (into acc (map #(conj % x) acc)) #{x}))]\n      (conj (reduce combine #{} s) #{})))", "problem": 85, "user": "50763574e4b0a894bb95bf3d"}, {"code": "(fn [s]\r\n  (reduce (fn [res item]\r\n          (into res (map #(conj % item) res))) #{#{}} s))", "problem": 85, "user": "4f3e6244e4b0e243712b1f85"}, {"code": "(fn ps [xs]\n  (if (empty? xs)\n    #{#{}}\n    (apply conj (ps (rest xs)) (map #(conj % (first xs)) (ps (rest xs))))\n  )\n)", "problem": 85, "user": "507eddf4e4b06ce648bcdbfa"}, {"code": "(fn power-set [s]\n  (let\n\t\t[power-set-inner\n\t\t\t(memoize\n\t\t\t\t(fn [s, power-set-func]\n\t\t\t\t\t(let [cnt (count s), power-set-func-wrap (fn [s] (power-set-func s power-set-func))]\n\t\t\t\t\t\t(if\n\t\t\t\t\t\t\t(= cnt 0)\n              #{#{}}\n\t\t\t\t\t\t\t(clojure.set/union\n\t\t\t\t\t\t\t\t#{s}\n\t\t\t\t\t\t\t\t(apply clojure.set/union\n\t\t\t\t\t\t\t\t\t(map power-set-func-wrap\n\t\t\t\t\t\t\t\t\t\t(map\n\t\t\t\t\t\t\t\t\t\t\t(fn [elem]\n\t\t\t\t\t\t\t\t\t\t\t\t(disj s elem))\n\t\t\t\t\t\t\t\t\t\t\ts))))))))]\n\t\t(power-set-inner s power-set-inner)))", "problem": 85, "user": "4f5c0549e4b0030a34fb2b1a"}, {"code": "(fn pset [x]\r\n  (letfn [(zerobit? [n bitno] (zero? (bit-and (bit-shift-left 1 bitno) n)))\r\n          (f [c] (set (remove nil?\r\n                              (map-indexed (fn [idx y]\r\n                                             (if (zerobit? c idx)\r\n                                               nil y)) x))))]\r\n    (set (map f (range (bit-shift-left 2 (count x)))))))", "problem": 85, "user": "4dc97aec535d5973398f9284"}, {"code": "(fn ps [s]\n  (letfn [(append-set [items s]\n            (apply conj s\n                   (flatten \n                    (for [s-m s]\n                      (for [i-m items]\n                        (conj s-m i-m))))))]\n    (loop [c (count s)\n           acc #{#{}}]\n      (if (= c 0)\n        acc\n        (recur (dec c)\n               (append-set s acc))))))", "problem": 85, "user": "504ec4d3e4b069badc5a33c9"}, {"code": "(fn power-set [s]\n  (loop [s s acc #{#{}}]\n    (if (empty? s)\n      acc\n      (recur\n       (disj s (first s))\n       (into acc\n             (map #(conj % (first s)) acc))))))", "problem": 85, "user": "504f57c7e4b0a02f9cffde71"}, {"code": "(letfn [\n  (add [ss e]\n    (concat ss (map conj ss (repeat e))))\n  ]\n  (fn [s]\n    (set (reduce add [#{}] s))))", "problem": 85, "user": "50901b2ee4b0ea685a20f774"}, {"code": "(fn powerset [S]\n  (println S)\n  (if (empty? S)\n\t\t#{#{}}\n    (set ((fn [rem-set-elements]\n      (clojure.set/union\n\t      (map #(conj % (first S)) rem-set-elements)\n\t      rem-set-elements)) (powerset (rest S))))))", "problem": 85, "user": "502b04bee4b063e52107afac"}, {"code": "(fn pwrs [s]\n  (if (= s #{}) #{#{}}\n    (let [t (first s)\n          u (disj s t)\n          v (pwrs u)\n          w (set (for [x v] (conj x t)))]\n      (clojure.set/union v w))))", "problem": 85, "user": "503a234de4b088a6a14ca76d"}, {"code": "(fn ps [base]\n  (letfn [(sets [start base]\n         (if (nil? (start base))\n          (sets (set (for [s start x base] (conj s x))) base)\n          start))]\n    (conj (sets #{#{}} base) #{})))", "problem": 85, "user": "50783762e4b0fc74642bff67"}, {"code": "(fn powerset \n   ([coll] (powerset coll #{#{}}))\n   ([coll results]\n     \t(if (seq coll)\n\t\t\t(let [x (first coll) \n                  ncoll (set (rest coll))\n              \t  nresults (set (map #(conj % x) results))]\n   \t\t\t\t(recur ncoll\n                  (clojure.set/union results nresults)))\n   \t\t\tresults)))", "problem": 85, "user": "4fe9ef2fe4b0547ebccb2479"}, {"code": "(fn [s]\r\n  (if (empty? s)\r\n    #{#{}}\r\n    (set (map set ((fn beki [[x & xs]]\r\n  \t     (if (empty? xs)\r\n\t\t       [[x] []]\r\n\t\t       (let [r (beki xs)]\r\n\t\t\t (concat (map #(cons x %) r) r))))\r\n\t\t   (seq s))))))", "problem": 85, "user": "507437c2e4b054001656acd0"}, {"code": "(fn p [s]\n  (if (seq s)\n    (let [r (p (rest s))]\n      (into r (map #(conj % (first s)) r)))\n    #{#{}}))", "problem": 85, "user": "506617c3e4b03d366d7cb2ab"}, {"code": "(fn  [s]\n  (set (reduce #(into (map (fn [s] (conj s %2)) %) %) [#{}] s)))", "problem": 85, "user": "5054bc87e4b0b1b9d1860eb0"}, {"code": "(fn [s]\n (reduce\n  (fn [a b] (clojure.set/union a (set (map (fn [x] (clojure.set/union x #{b})) a))))\n  #{#{}}\n  s))", "problem": 85, "user": "5097b556e4b00ad8bab4e970"}, {"code": "(fn pset [s]\n  (if-let [[x & xs] (seq s)]\n    (set (mapcat (fn [y] [y (conj y x)]) (pset xs)))\n    #{#{}}))", "problem": 85, "user": "4ed0e139535d44c135fd68c7"}, {"code": "(partial reduce(fn[r x](into r(map #(conj % x)r)))#{#{}})", "problem": 85, "user": "5088082ae4b0198722bd9854"}, {"code": "(fn power [xs] (if (empty? xs) \n                      #{#{}}\n                      (clojure.set/union (set (map #(conj % (first xs)) \n                                              (power (next xs))))\n                                         (power (next xs)))))", "problem": 85, "user": "50310b8be4b05b7df5a0b84d"}, {"code": "(fn [s]\n  (let [xs (into [] s)\n        bsl bit-shift-left\n        n (count s)]\n    (into #{}\n      (map\n        (fn [x]\n          (reduce\n            #(if\n               (> (bit-and (bsl 1 %2) x) 0) (conj % (xs %2)) %) #{} (range 0 n))) (range 0 (bsl 1 n))))))", "problem": 85, "user": "508ee17ae4b0706b2ed3ef8d"}, {"code": "(fn p [s]\n  (if (empty? s)\n    #{#{}}\n    (let [c (p (-> s rest set))]\n      (into\n        c\n        (map #(conj % (first s)) c)))))", "problem": 85, "user": "4fb1325de4b081705acca276"}, {"code": "(fn power-set [st]\n  (letfn [(map-set [st coll]\n    (set (for [x st y coll] (conj x y))))]\n  (reduce\n    (fn [ret ele]\n       (set (concat ret (map-set ret st)))) #{#{}} st)))", "problem": 85, "user": "5084c43be4b0fb8f40674bfa"}, {"code": "(fn [s]\r\n  (loop [current (seq s) results #{#{}}]\r\n    (cond\r\n      (= 0 (count current)) (conj results #{})\r\n      ;(= 1 (count current)) (conj results #{} #{(first s)})\r\n      :else (recur (rest current) (apply (partial conj results) (map #(conj % (first current)) results))))))", "problem": 85, "user": "4dad76588e77d6ed63f12a44"}, {"code": "(fn power-set [s]\n    (reduce (fn [ps x]\n              (into ps (map #(conj % x) ps)))\n            #{#{}} s))", "problem": 85, "user": "4daea889edd6309eace4d15b"}, {"code": "(fn [s]\r\n  (set (reduce #(into (map (partial into #{%2}) %) %) [#{}] s)))", "problem": 85, "user": "509c03f3e4b085ae113522a8"}, {"code": "(fn power-set [s]\n  (loop [res #{#{}} src s]\n    (if (empty? src)\n      res\n      (recur (clojure.set/union res\n                                (map #(conj % (first src)) res))\n             (next src)))))", "problem": 85, "user": "4dd0e8f7535da60f04a96e57"}, {"code": "(fn\n  [s]\n  (letfn [(plist [l]\n            (if (empty? l)\n              '(())\n              (let [q (plist (rest l))\n                    x (first l)]\n                (concat q (map #(cons x %) q)))))]\n    (set (map set (plist (seq s))))))", "problem": 85, "user": "4fc8c8d8e4b0ee37620e183b"}, {"code": "(fn [s]\r\n  (let [find-news (fn [s] (map #(disj s %) s))]\r\n    (loop [acc #{s}\r\n      news (find-news s)]\r\n      (if (empty? (first news))\r\n        (conj acc #{})\r\n        (recur (reduce conj acc news) (set (mapcat find-news news)))))))", "problem": 85, "user": "504e14c2e4b078edc5f593bf"}, {"code": "(fn [s]\n    (loop [res #{#{}}\n           s s]\n      (if (empty? s)\n        res\n        (recur\n         (clojure.set/union res\n                 (set (map (fn [v] (conj v (first s))) res)))\n         (rest s)))))", "problem": 85, "user": "4f463dfde4b0d56e7bb92b99"}, {"code": "(fn f [s] \n  (if (empty? s)\n      #{#{}}\n      (let [a (first s)\n            S (f (disj s a))]\n        (clojure.set/union S (set (map #(conj % a) S))))))", "problem": 85, "user": "5061cc17e4b0a30dc9a35d34"}, {"code": "(fn p\n  ([c] (set (conj (p #{#{}} c) #{})))\n  ([a c]\n     (if (empty? c)\n       ()\n       (let [f (first c)\n             n (map #(conj % f) a)]\n         (concat n\n                   (p (concat a n) (rest c)))))))", "problem": 85, "user": "5027b41ee4b01614d1633fee"}, {"code": "(fn p-set [s]\n  (if (= (count s) 0) #{#{}}\n    (let [t1 (p-set (rest s))\n          t2 (map #(conj % (first s)) t1)]\n      (into t1 t2))))", "problem": 85, "user": "505dcfc8e4b0e6aca564be0d"}, {"code": "(fn f [s]\n (if (empty? s) #{#{}}\n  (let [n (f (next s))]\n    (into n (map #(conj % (first s)) n)))))", "problem": 85, "user": "4f956072e4b0dcca54ed6ccf"}, {"code": "(fn ps [ls]\n  (if (empty? ls) #{#{}}\n    (clojure.set/union \n     (ps (next ls))\n     (map #(conj % (first ls)) (ps (next ls))))))", "problem": 85, "user": "506406c8e4b075d771da6f9f"}, {"code": "(fn power-set [x] (if (empty? x) #{#{}} (reduce conj (conj (power-set (set (rest x))) x)\r\n                                                  (map #(conj % (first x))(conj (power-set (set (rest x))) x)))))", "problem": 85, "user": "50646c01e4b007509339a58b"}, {"code": "(fn ps [a]\n  (if (empty? a) #{#{}}\n  (let \n    [nps (ps (set (next a)))\n     xps (set (map #(conj % (first a)) nps))\n    ]\n    (clojure.set/union  nps xps))) \n  )", "problem": 85, "user": "50921f9ae4b09a7d0b586de1"}, {"code": "(fn mps [ls] (set\n  (if (empty? ls) '(#{})\n      (clojure.set/union (mps (next ls))\n      (map #(conj % (first ls)) (mps (next ls)))))))", "problem": 85, "user": "50956c2be4b087f34d351ab2"}, {"code": "(fn power-set [s]\r\n  (reduce (fn [p-s c-el]\r\n            (clojure.set/union p-s (set (map #(conj % c-el) p-s)))) #{#{}} s))", "problem": 85, "user": "505dd5c4e4b0e6aca564be0e"}, {"code": "#(set\n  (reduce\n    (fn [s x]\n      (concat s\n             (map (fn [y] (conj y x)) s)))\n    #{#{}} %))", "problem": 85, "user": "50acbd15e4b071b89ef26234"}, {"code": "(fn power[s]\n  (if (empty? s) #{#{}} \n      (let [cur (power (rest s))\n            prom (map #(conj % (first s)) cur)]\n        (clojure.set/union cur prom))))", "problem": 85, "user": "5065bd94e4b0148eb3925aed"}, {"code": "(fn power-set [s]\n  (letfn [(add-to-power-set [s elem]\n             (into s (map #(conj % elem) s)))]\n    (reduce add-to-power-set\n            #{#{}}\n            s)))", "problem": 85, "user": "50812debe4b01a93d3f38e4c"}, {"code": "#(set (reduce (fn [x y] (concat x (map  (fn[z] (conj z y)) x))) #{ #{} } %) )", "problem": 85, "user": "50b25f2ce4b03ea88043355f"}, {"code": "(fn ps [s]\n  (if (empty? s)\n    #{#{}}\n    (let [f (first s) r (rest s) rr (ps r)]\n     (clojure.set/union\n        (set (map #(conj % f) rr))\n        rr               \n     )\n   )\n )\n)", "problem": 85, "user": "504f191ae4b0e7ad84dbc4ba"}, {"code": "reduce (fn [s e] (into s (map #(conj % e) s))) #{#{}}", "problem": 85, "user": "50996a38e4b0cae2931060b3"}, {"code": "(fn __ [seed]\n  (if-not (= seed #{})\n    (letfn \n      [\n        ; fold the smaller list s into bigger list b\n        (fold [smr bgr]\n          (if (get bgr seed)\n            bgr\n            (fold smr (set (for [a smr b bgr] (apply merge a b))))\n           )\n              \n        )\n      ]  \n      (let [sseed (map (partial merge #{}) seed)]\n        (merge (fold sseed sseed) #{})\n      )\n    ) #{#{}})\n)", "problem": 85, "user": "503f872ee4b00d1a725ff2ac"}, {"code": "(fn p [s]\n  (if\n    (= s #{})\n    #{#{}}\n    (let [a (p (set (rest s)))]\n      (into a (map #(conj % (first s)) a)))))", "problem": 85, "user": "50a83315e4b054305ba5a830"}, {"code": "(fn [s]\n  (letfn [(combine [acc x]\n            (conj (into acc (map #(conj % x) acc)) #{x}))]\n    (conj (reduce combine #{} s) #{})))", "problem": 85, "user": "4eddcbbf535d10e5ff6f532d"}, {"code": "(fn [x]\n  (set (reduce (fn [i j]\n                 (concat i (map #(conj % j) i)))\n               #{#{}} x)))", "problem": 85, "user": "507ef25ce4b0f753b6f9788e"}, {"code": "(fn [xs]\n  (let [f (fn [i xs acc]\n            (if (= i 0) acc\n              (let [i' (quot i 2) xs' (rest xs)]\n                (recur i' xs' (if (odd? i) (conj acc (first xs)) acc)))))]\n    (->> (repeat (count xs) 2) (reduce *) range (map #(f % xs #{})) set)))", "problem": 85, "user": "508157b2e4b0946d0443855c"}, {"code": "(fn test85 [s]\n  (reduce\n   (fn [ps x]\n     (into ps (map #(conj % x) ps)))\n   #{#{}}\n   s))", "problem": 85, "user": "50b0cffae4b009df37c708c5"}, {"code": "(fn f [coll]\n  (loop [res #{#{}} s coll]\n    (if (empty? s)\n      res\n      (let [e (first s)]\n        (recur\n          (reduce #(conj %1 (conj %2 e)) res res)\n          (disj s e))))))", "problem": 85, "user": "4f1e4ab5535d64f603146496"}, {"code": "#((fn sups [s c]\n        (if (= 0 c)\n          #{#{}}\n          (into #{#{}}\n                (for [es (sups s (dec c))\n                      e s]\n                  (conj es e)))))\n   %\n   (count %))", "problem": 85, "user": "4dd6d7ee535d2dad7130b5cb"}, {"code": "(fn [s]\n           (into #{}\n                 (map #(into #{} %)\n                      (map (fn [x](map #(last %) \n                                      (filter (fn [y] (= (first y) \\1))\n                                              (partition 2 \n                                                         (interleave x \n                                                                     s)))))\n                           (let [n (count s)] \n                                (map #(apply str (concat (take (- n (count %)) (cycle [\\0])) %))\n                                     (map #(Integer/toString % 2) \n                                          (range (Math/pow 2 \n                                                           n)))))))))", "problem": 85, "user": "4f03f197535dcb61093f6b84"}, {"code": "(fn [s2]\n  (set\n   (reduce #(concat (map (fn [x] (conj x %2)) %) %)\n           [#{}]\n           s2)))", "problem": 85, "user": "50d8f4b6e4b01f0871336e74"}, {"code": "(fn ps ([x] (ps x #{#{}}))\n   ([l r] \n    (if (empty? l)\n      r\n    (let [step (map #(conj % (first l)) r)]\n      (ps (rest l) (set (concat r step)))))))", "problem": 85, "user": "4eb2eae5535d7eef30807351"}, {"code": "(\n fn[s]\n   (let [a (fn [x s] [ (conj s x) s])]\n   (set (reduce #(mapcat (partial a %2) %) #{ #{} } s))) )", "problem": 85, "user": "507c7c8be4b0b083f3ff82ef"}, {"code": "(fn [s]\n  (set\n    (let [v (vec s)]\n      (map\n        #(let [bin (reverse (Integer/toString % 2))]\n          (set\n            (keep-indexed\n              (fn [index item] (if (= \\1 item) (nth v index)))\n              bin)))\n        (range (Math/pow 2 (count s)))))))", "problem": 85, "user": "4f253a49e4b0d66497709ff3"}, {"code": "(fn ps [s]\n  (if (empty? s)\n       #{#{}}\n       (clojure.set/union (ps (rest s)) (map #(conj % (first s)) (ps (rest s))))))", "problem": 85, "user": "4ff769bce4b0678c553fc38f"}, {"code": "(fn power-set [col]\n  (let [len (count col)\n        total (int (Math/pow 2 len))\n        total-bs (Integer/toBinaryString total)\n        total-bs-array (seq total-bs)\n        bs-len (.length total-bs)\n        v-col (vec col)\n        ]\n    (set\n    (for [i (range total)]\n      (let [i-bs-array (seq (Integer/toBinaryString i))\n            ]\n        (set\n        (map #(nth v-col %)\n        (filter #(not (nil? %)) (for [j (range (count i-bs-array))]\n          (if (= (nth i-bs-array j) \\1)\n            (+ j (- len (count i-bs-array)))\n            nil\n            ) ; if\n                                  )) ; filter\n             ) ; map\n         ) ; set\n        ) ; let\n      ) ; for\n     ) ; set\n    ) ; let\n  ) ; fn", "problem": 85, "user": "5021f0b3e4b00bba4502f7ac"}, {"code": "(letfn [(subset [s]\n                (set (for [i s] (disj s i))))]\n(fn powerset [s]\n   (if (< 0 (count s))\n     (loop [ss (subset s)\n            ret #{#{} s}]\n       (if (= ss #{#{}})\n         (set ret)\n         (recur (set (reduce concat #{} (map subset ss))) (concat ret ss))))\n     #{#{}})))", "problem": 85, "user": "50733b31e4b0e3170b5a869a"}, {"code": "(fn [coll]\n    (reduce\n      (fn [result b] (into result (map #(conj % b) result)))\n        #{#{}}\n      coll))", "problem": 85, "user": "4ee77f15535d93acb0a66868"}, {"code": "(fn [s]\n  (loop [s (vec s) p #{#{}}]\n    (if (empty? s)\n      p\n      (recur (rest s) \n        (into p (map #(merge % (first s)) p))))))", "problem": 85, "user": "50843a4ae4b0c98812d0788b"}, {"code": "(fn ps [s]\n  (loop [a #{#{}} [h & t] (seq s)]\n    (if (nil? h) a \n      (recur \n        (into a  (for [x a] (conj x h)) )   \n        t)  )))", "problem": 85, "user": "50d0d4c8e4b00b15ecee976a"}, {"code": "; this was a blocker for me - it turned out too complicated and have spent too much time\n; from other solutions this one is cool:\n; (fn [coll] (reduce \n;  (fn [s a] \n;   (clojure.set/union s \n;      (map #(conj % a) s))) #{#{}}\n;   coll))\n\n(fn pick \n  ([pn coll] \n   \n   (if (empty? coll )\n     [()]\n     (reduce (fn [r n]\n         (let [\n              pnn (concat pn [n])\n              left (apply disj (set coll) pnn)\n              ; xx (println :b pn n left (or (empty? pn) (> n (last pn))))\n              ]\n           (if (or (empty? pn) (> n (last pn)))\n             (concat r [pnn] (pick pnn left))\n             r)\n         )) [] coll)\n  )) \n  ([coll] \n     (set \n       (map (fn [itm] \n         (set (map (fn [x] \n                (nth (apply vector coll) x)) itm ))) \n           (pick [] (range (count coll)) )\n      ))\n   ))", "problem": 85, "user": "50de11b2e4b061dbdced7217"}, {"code": "(fn final-set [stt]\n  (letfn [(lo [x len]\n              (str (reduce str (repeat (- len (count x)) \"0\")) x))\n          (jay [v sr]\n            (into #{} (filter identity (map #(if (= \\0 %2)\n                                               nil\n                                               %) v (seq sr)))))]\n         (let [st (into [] stt)\n               co (count st)\n               all (for [i (range (int (Math/pow 2 co)))]\n                     (Integer/toString i 2))\n               ready (map #(lo % co) all)]\n           (into #{} (map (partial jay st) ready)))))", "problem": 85, "user": "50e87427e4b0ebbe794eb7e8"}, {"code": "(fn [s]\n  (reduce (fn [ps x]\n    (reduce (fn [ps s]\n      (conj ps (conj s x))) ps ps)) #{#{}} s))", "problem": 85, "user": "50ef9a7ae4b0bdaecbb47d9e"}, {"code": "(fn pw [s]\n  (if (empty? s) #{#{}}\n    (let [el (first s) \n          subset (pw (next s))]\n      (apply conj \n             subset \n             (map #(conj % el) subset)))))", "problem": 85, "user": "4f0446f9535dcb61093f6bb8"}, {"code": "(fn pset [s] (let [f (fn [e s] (set (map #(conj % e) s)))]\n               (if (empty? s) #{#{}}\n                 (clojure.set/union (pset (set (rest s))) (f (first s) (pset (set (rest s))))))))", "problem": 85, "user": "50dfb660e4b061dbdced7228"}, {"code": "(fn powerset [s]\n  (if (seq s)\n    (let [subpowerset (powerset (rest s))\n          the-other (map #(conj % (first s)) subpowerset)]\n      (into subpowerset the-other))\n    #{#{}}))", "problem": 85, "user": "50a7ef7fe4b090657f4a5ce0"}, {"code": "(fn g [l]\n    (let [combinations (fn subsets [n items]\n                         (cond\n                           (= n 0) '(())\n                           (empty? items) '()\n                           :else (concat (map #(cons (first items) %) (subsets (dec n) (rest items)))\n                                         (subsets n (rest items)))))]\n      (into #{} (apply concat (for [i (range (inc (count l)))]\n                                (map #(into #{} %1) (combinations i l)))) )))", "problem": 85, "user": "4f038567535dcb61093f6b0c"}, {"code": "(fn [s]\n  (reduce\n   (fn [sets el]\n     (into sets (map #(conj % el) sets)))\n   #{#{}}\n   s))", "problem": 85, "user": "4ffc10aae4b0678c553fc3d6"}, {"code": "(fn [s]\n  (reduce (fn [a b]\n            (into a (map #(conj % b) a)))\n          #{#{}}\n          s))", "problem": 85, "user": "509160dae4b0742c82730aef"}, {"code": "(fn power-set [coll]\n  (if (empty? coll) #{#{}} \n    (clojure.set/union (power-set (set (rest coll))) (map #(conj % (first coll)) (power-set (set (rest coll)))))\n    )\n  )", "problem": 85, "user": "50fa0dcee4b07934dda8b0bb"}, {"code": "(fn P [S]\n  (if (empty? S) #{#{}}\n      (let [e (first S) \n            T (P (disj S e))] \n        (into T (map #(conj % e) T)))))", "problem": 85, "user": "4e57d1e2535d8a8b8723a289"}, {"code": "(fn myPowerset [myset]\n (if (empty? myset) #{#{}}\n     (into (myPowerset (rest myset))\n       (map #(conj % (first myset)) (myPowerset (rest myset))))))", "problem": 85, "user": "51002399e4b0ab35a0d409ff"}, {"code": "(fn myPowerset [myset]\n  (if (empty? myset) #{#{}}\n      (into \n       (myPowerset (rest myset))\n       (map #(conj % (first myset)) (myPowerset (rest myset))))))", "problem": 85, "user": "50f9e74ee4b0e7c80cb15a54"}, {"code": "(fn [s]\n   (reduce \n     (fn [init e] \n       (set (concat init (map #(conj % e) init) [#{e}])))\n     #{#{}} s))", "problem": 85, "user": "50bc23e4e4b0594b91591c3c"}, {"code": "(fn [a] (reduce (fn [s x] (apply conj s (map #(conj % x) s)) ) #{#{}} a))", "problem": 85, "user": "4ff67852e4b0678c553fc37e"}, {"code": "(fn [fullset] \n\t(let [buildsets (fn [subset] (map #(clojure.set/union subset #{%}) fullset))]\n\t\t(apply clojure.set/union\n\t\t\t(take (inc (count fullset))\n\t\t\t\t(iterate\n\t\t\t\t\t#(set (flatten (map buildsets %)))\n\t\t\t\t\t#{#{}}\n\t\t\t\t)\n\t\t\t)\n\t\t)\n\t)\n)", "problem": 85, "user": "50f2e5cee4b0ec8ee6fa8643"}, {"code": "(fn pow [st] \n  (if (empty? st) #{st} \n    (let [t (first st) subpow (pow (set (rest st)))]\n      (clojure.set/union \n        subpow \n        (set (map #(conj % t) subpow))))))", "problem": 85, "user": "50fbdacfe4b0d10d794c19f0"}, {"code": "(fn [s] (set (map (fn [n] (set (keep-indexed #(if (bit-test n %) %2) (reverse s)))) (range (Math/pow 2 (count s))))))", "problem": 85, "user": "500854c4e4b028e089d3518c"}, {"code": "(fn powerSet [sett]\n  (if (empty? sett)\n    #{#{}}\n    (into (powerSet (rest sett))\n          (map (fn [l_rest] (conj l_rest (first sett))) (powerSet (rest sett)))                  \n    )\n  ) \n  \n)", "problem": 85, "user": "50f87a67e4b0aafb827eb202"}, {"code": "(fn [a-set]\n  (reduce \n    (fn [init e] \n      (set (concat init (map #(conj % e) init) [#{e}])))\n    #{#{}} a-set))", "problem": 85, "user": "50febf94e4b075812dd6dfb3"}, {"code": "(fn [coll]\n  (reduce \n    (fn [result elt] \n      (set (concat result (map #(conj % elt) result) [#{elt}])))\n    #{#{}} coll))", "problem": 85, "user": "50fd9fd4e4b033b9c38d78d0"}, {"code": "(fn powerSet\n  ([Set] \n    (if (empty? Set) \n      #{Set} \n      (reduce conj \n        (powerSet (set (rest Set))) \n        (map #(reduce conj (set (list (first Set))) %) (powerSet (rest Set)))\n        )\n      )\n    ) \n  )", "problem": 85, "user": "50f85902e4b0aafb827eb1f8"}, {"code": "(fn [s]\n  (reduce (fn [power-set x]\n            (into power-set (map #(conj % x) power-set)))\n          #{#{}} s))", "problem": 85, "user": "50fde9b9e4b033b9c38d78d7"}, {"code": "(fn [i] (reduce (fn [r s](into r (map #(conj % s) r))) #{#{}} i))", "problem": 85, "user": "50f9c7fde4b0e7c80cb15a52"}, {"code": "(fn power-set [initial-set]\n  (let [element (first initial-set)]\n  (if (empty? initial-set) #{#{}}\n    (clojure.set/union\n      (set (map (fn [x] (conj x element)) (vec (power-set (disj initial-set element)))))\n      (power-set (disj initial-set element))))))", "problem": 85, "user": "50f89404e4b0aafb827eb204"}, {"code": "(fn ps [s]\n  (if (empty? s)\n    #{#{}}\n    (let [rr (ps (rest s))]\n      (clojure.set/union rr\n                         (map #(conj % (first s)) rr)))))", "problem": 85, "user": "50ef77a4e4b0bdaecbb47d99"}, {"code": "(fn power-set [coll]\n  (if (empty? coll) #{#{}}\n    (clojure.set/union (power-set (set (rest coll))) (map #(conj % (first coll)) (power-set (set (rest coll)))))\n    )\n  )", "problem": 85, "user": "50f8615ae4b0aafb827eb1fa"}, {"code": "(fn f [s]\n  (if (empty? s)\n    #{s}\n    (let [[h t] ((juxt first (comp f set next)) s)]\n      (set (concat t (map #(conj % h) t))))))", "problem": 85, "user": "4ebaf790535dfed6da9c6d6e"}, {"code": "(fn [theList]\n  (if (< (count theList) 10)\n\t  (set (\n\t\t(fn f [theList n]\n\t\t  (if (< n (Math/pow 2 (count theList)))\n\t\t      (cons\n\t\t        (set\n\t\t            (\n\t\t\t            (fn g [powerList] \n\n\t\t\t\t            (if (> (count powerList) 0)\n\t\t                  (cons\n\t\t                    (\n\t\t                      (fn h [xs n]\n\t\t                        (if (and (> n 0) (> (count xs) 0))\n\t\t                          (h (rest xs) (- n 1))\n\t\t                          (if (= n 0)\n\t\t                            (first xs)\n\t\t                          )\n\t\t                        )\n\t\t                      )\n\t\t                      theList\n\t\t                      (int (first powerList))\n\t\t                    )\n\t\t                    (g (rest powerList)) \n\t\t                  )\n\t\t                )\n\t\t\t            )\n\t\t              (reverse \n\n\t\t\t\t            (\n\n\t\t\t\t\t\t          (fn g [num]\n\n\t\t\t\t\t\t\t\t\t\t\t\t(if (> num 0)\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t  (cons\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t  (Math/floor (/ (Math/log num) (Math/log 2)))\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t  (g (- num (Math/pow 2 (Math/floor (/ (Math/log num) (Math/log 2))))))\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\n\t\t\t\t\t\t\t\t\t\t\t\t)\n\n\t\t\t\t\t\t\t\t\t\t\t\t)\n\n\t\t\t\t\t\t          n\n\n\t\t\t\t\t\t        )\n\n\t\t\t\t          )\n\t\t            )\n\t\t      )\n\n\t\t        (f theList (+ n 1))\n\n\t\t      )\n\n\t\t  )\n\n\t\t)\n\n\t\ttheList\n\n\t\t0\n\n\t  )\n\n\t  )\n\t(range 1024))\n)", "problem": 85, "user": "50ff3800e4b017584cb41ccb"}, {"code": "(fn ez [xs]\n  (let\n    [size (count xs)\n     total-combs (bit-shift-left 1 size)\n     vect (into [] xs)\n     get-indexes (fn [n]\n                  (keep-indexed\n                   #(if (= \\1 %2) % nil)\n                   (reverse\n                    (Integer/toString n 2))))\n     get-members (fn [n]\n                   (map vect (get-indexes n)))]\n    (into #{} (map #(into #{} (get-members %)) (range total-combs)))\n    ;vect\n    ))", "problem": 85, "user": "50217818e4b00bba4502f7a7"}, {"code": "#(reduce (fn [result el]\n            (apply conj result (map (fn [set] (conj set el)) result)))\n          #{#{}} %)", "problem": 85, "user": "51105c7fe4b04c71fce993ef"}, {"code": "(let [f (fn [m s]\n          (if (empty? s)\n            #{#{}}\n            (apply clojure.set/union #{s}\n                   (for [i s] (m m (disj s i))))))\n      m (memoize f)]\n  (partial m m))", "problem": 85, "user": "50ed4626e4b01236b1d4983c"}, {"code": "(fn [s]\n  (let [indexed (vec (map-indexed (fn [i x] [i x]) s))\n        bit-permutations (range (Math/pow 2 (count s)))\n        gen-set-from-bit-permutation (fn [p]\n                 \t\t\t  (letfn [(conj-matching [acc [i x]]\n                                                    (if (bit-test p i)\n                                                      (conj acc x)\n                                                      acc))]\n                                            (reduce conj-matching #{} indexed)))]\n    (set (map gen-set-from-bit-permutation bit-permutations))))", "problem": 85, "user": "50d93c53e4b0fd36a4b89223"}, {"code": "(fn [s]\n  (reduce\n   (fn [old-set e]\n     (into old-set (map #(conj % e) old-set)))\n   #{#{}} s))", "problem": 85, "user": "510db6cde4b078ea71921145"}, {"code": "(fn [input]\n  (into #{} (reduce \n               (fn subset [results cur] \n                  (apply conj results (map #(clojure.set/union (hash-set cur) %) results)))\n          [#{}] input)))", "problem": 85, "user": "500b61b1e4b03d00572d2d81"}, {"code": "(fn pset [s]\n  (if (empty? s)\n    #{#{}}\n    (clojure.set/union\n     (pset (rest s))\n     (map #(conj % (first s)) (pset (rest s))))))", "problem": 85, "user": "4e8768f6535dceadca469850"}, {"code": "(fn [s]\n  (letfn [(power-set [s' res]\n            (if (empty? s')\n              res\n              (reduce (fn [memo item]\n                                 (if (memo item)\n                                   memo\n                                   (apply conj memo (power-set item memo))))\n                               (conj res s')\n                               (for [item s']\n                                 (disj s' item)))))]\n    (power-set s #{#{}})))", "problem": 85, "user": "51195e77e4b055cfb310d499"}, {"code": "(fn power-set [s]\n  (cond\n   (= 1 (count s)) [#{} (set s)]\n   (zero? (count s)) #{#{}}\n   :default\n    (let [seq-1 (power-set (rest s))\n          seq-2 (map #(conj % (first s)) seq-1)\n          ps (set (concat seq-1 seq-2))]\n      ps)))", "problem": 85, "user": "51281b25e4b03a34742b4304"}, {"code": "(fn psets\n  ([xs] (psets xs #{}))\n  ([xs sofar]\n   (if (empty? xs)\n     #{sofar}\n     (set (concat (psets (rest xs) (conj sofar (first xs)))\n                \t (psets (rest xs) sofar))))))", "problem": 85, "user": "510acd6ee4b078ea719210f4"}, {"code": "(fn powerset [x]\n  (set\n    (if (<= (count x) 1) [(set x) #{}]\n      (concat\n        [x]\n        [(set [(first x)])]\n        (powerset (set (rest x)))\n        (map #(set (cons (first x) %)) (powerset (set (rest x))))))))", "problem": 85, "user": "50e4f4e9e4b049a987753896"}, {"code": "(fn ps [s]\n  (if (empty? s) #{#{}}\n    (clojure.set/union (ps (rest s))\n                       (into #{} (map #(conj % (first s)) (ps (rest s)))))))", "problem": 85, "user": "4fa05b99e4b0dcca54ed6d47"}, {"code": "(fn powerset [ls]\n  (if (empty? ls) #{#{}} \n    (clojure.set/union (powerset (next ls))\n                       (map #(conj % (first ls)) (powerset (next ls))))))", "problem": 85, "user": "512474ede4b02c3f2a072cce"}, {"code": "(fn superset [s]\n  (loop [s s\n         r #{#{}}]\n    (if (nil? (first s))\n      r\n      (recur (rest s) (clojure.set/union r(map #(clojure.set/union #{(first s)} %) r))))))", "problem": 85, "user": "5123ac8ee4b061b4c6f0e0b1"}, {"code": "(fn powerset [s]\n\t(reduce \n\t\t(fn [acc cur] (into acc (map #(conj % cur) acc)))\n\t\t#{#{}} s\n\t)\n)", "problem": 85, "user": "511cca27e4b00c2a1fa7ff7d"}, {"code": "(fn p [s]\n  (if (seq s)\n    (let [x (p (rest s))]\n      (set (concat x\n                   (set (map #(set (conj % (first s))) x)))))\n    #{#{}}))", "problem": 85, "user": "51256b40e4b05d10e3e395f8"}, {"code": "(fn pset [s]\n  (if (empty? s)\n    #{#{}}\n    \n    (let [f    (first s)\n          r    (set (rest s))\n          memo (pset r)]\n      (clojure.set/union memo (map #(conj % f) memo))\n    )\n  )\n)", "problem": 85, "user": "51365524e4b04ac1f358dd52"}, {"code": "(fn [s]\n  (set (reduce \n         #(into \n            (map (fn [x] (conj x %2)) %)\n            %)\n         '(#{})\n         s)) \n  )", "problem": 85, "user": "4fbbcf0ce4b081705acca2ee"}, {"code": "(fn [input]\n   (if (empty? input) \n     #{#{}}\n\t\t   (reduce\n\t\t  (fn ! [a b]\n\t\t   (if (set? a)\n\t\t\t\t\t  (loop [result (into #{} a) elements a]\n\t\t\t\t\t    (if elements\n\t\t\t\t\t      (recur (conj result (conj (first elements) b)) (next elements))\n\t\t\t\t\t      result)    \n\t\t\t\t\t    )\n\t\t       (! #{#{} #{a}} b)\n\t\t     )\n\t\t  ) input)\n   )\n   )", "problem": 85, "user": "5106dc1be4b01150e115ebf0"}, {"code": "(let [\naddtoall (fn [sets e]\n            (map (fn [s] (conj s e)) sets)\n          )\nunion (fn [a b] (apply conj a b))\n]\n(fn powerset [elmts]\n  (loop [x elmts answer #{#{}}]\n    (if (empty? x) answer\n      (recur (rest x)\n        (union answer (addtoall answer (first x)))\n      )\n    )\n  )\n)\n)", "problem": 85, "user": "50bfbf25e4b05ae8c1cbbd9b"}, {"code": "(fn power-set2 [s]\n  (let [s-ind (map-indexed vector s) \n        decode (fn [n] \n                 (into #{} (map second \n                                (filter #(not= 0 (bit-and n (bit-shift-left 1 (first %)))) s-ind))))]\n    (into #{} (map decode (range (bit-shift-left 1 (count s)))))))", "problem": 85, "user": "50eddbc4e4b06330c1f87c4b"}, {"code": "(fn [xs]\n  (loop [xs xs zs #{#{}}]\n    (if (seq xs)\n      (recur (next xs) (into zs (map #(conj % (first xs)) zs)))\n      zs)))", "problem": 85, "user": "511442d0e4b0e9c109bb74d5"}, {"code": "(fn aa [x]  \n  \n  (set (map set\n  \t\t(loop [xx (vec x) z [[]]]   \n            (if (empty? xx) z\n             (recur (rest xx) (reduce #(conj %1 (conj %2 (first xx))) z z))\n            \t\n            )\n           )\n  )))", "problem": 85, "user": "5105ed16e4b01150e115ebe2"}, {"code": "(fn [s]\n  (set (map (fn [n]\n              (set (keep-indexed #(if (bit-test n %1) %2) s)))\n         (range 0 (bit-shift-left 1 (count s))))))", "problem": 85, "user": "5125745ae4b05d10e3e395f9"}, {"code": "(fn power-set [s]\n   (set\n    (map (fn [bits]\n           (set\n            (keep-indexed\n             (fn [i elem]\n               (if (some #(= i %) bits)\n                 elem))\n             s)))\n         (map (fn [x]\n                (vec\n                 (filter\n                  #(bit-test x %1)\n                  (range (count s)))))\n              (range (Math/pow 2 (count s)))))))", "problem": 85, "user": "513d121fe4b0e544971636a2"}, {"code": "(fn powerset [my-set]\n   (letfn [(inner [my-set]\n                  (if (empty? my-set)\n                    [[]]\n                    (let [my-seq (seq my-set)\n                          sub-powerset (inner (rest my-seq))]\n                      (concat sub-powerset\n                              (map (partial cons (first my-seq)) sub-powerset)))))]\n     (set (map set (inner my-set)))))", "problem": 85, "user": "4dafa380edd6309eace4d17c"}, {"code": "(fn super-set[xs]\n  (set ((fn proc[xs]\n          (cond (empty? xs) [#{}]\n                :else\n                (let [ [[a] xs'] (split-at 1 xs)\n                       S       (proc xs')]\n                  (into S (for [s S] (conj s a)))))) xs)))", "problem": 85, "user": "50fa01bce4b07934dda8b0ba"}, {"code": "(fn powerset [s] (set (map set ((fn p [s] (if (empty? s) '(()) (clojure.set/union (p (next s)) (map #(conj % (first s)) (p (next s)))))) s))))", "problem": 85, "user": "5138d08be4b0a5db03d727db"}, {"code": "(fn b [n]\n  (if (empty? n) #{#{}}\n    (clojure.set/union (b (next n))\n                       (map #(conj % (first n)) (b (next n))))))", "problem": 85, "user": "4fe97adde4b0547ebccb245e"}, {"code": "(fn [s]\n  (set (loop [ret #{#{}}\n         left s]\n    (if (empty? left)\n      ret\n      (recur (concat (map #(conj % (first left)) ret)\n                     ret)\n             (rest left))))))", "problem": 85, "user": "512eb723e4b0b740abc5982b"}, {"code": "(fn [s]\n    (let [f (fn f [s [x & xs]]\n              (let [new-s (conj s x)]\n                (if xs\n                  [new-s (f new-s xs) (f s xs)]\n                  new-s)))]\n      (into #{#{}} (flatten (f #{} (seq s))))))", "problem": 85, "user": "4f410b63e4b0e243712b1fc5"}, {"code": "(fn powerset \n  ([coll]\n    (powerset coll #{}))\n  ([coll ret]\n    (if (empty? coll)\n      (conj ret #{})\n\t  (recur (rest coll) (reduce (fn [ret this] \n                                   (conj ret \n                                         (conj this (first coll)))) \n                                       (conj ret (hash-set (first coll))) ret)))))", "problem": 85, "user": "513cb853e4b0b86ece9f322b"}, {"code": "(fn powerSet [ourSet]\n  (if (= #{} ourSet)\n    #{#{}}\n    (let [T (clojure.set/difference ourSet #{(first ourSet)})]\n      (clojure.set/union \n        (powerSet T) \n        (\n\t        (fn [element, TSet]\n\t          (map #(clojure.set/union % #{element}) TSet) ;our only problem!!\n\t        ) \n        (first ourSet) (powerSet T))))))", "problem": 85, "user": "51018807e4b0a79bcc8c0e0b"}, {"code": "(fn ps [s]\n  (if (empty? s) #{#{}}\n        (let [x (ps (rest s))]\n      (into #{} (concat x (map #(set (cons (first s) %)) x))))))", "problem": 85, "user": "514a2fa1e4b0829bd132edb5"}, {"code": "(fn power-set [s]\n  (if (empty? s)\n    #{#{}}\n    (let [set-rest (power-set (rest s))]\n      (clojure.set/union (set (map #(conj % (first s)) set-rest)) set-rest))))", "problem": 85, "user": "4e9a1512535dbda64a6f6b6e"}, {"code": "(fn power-set\n    [coll]\n    (if (empty? coll) #{#{}}\n        (let [ps (power-set (rest coll))]\n            (into ps (map #(conj % (first coll)) ps)))))", "problem": 85, "user": "50b35486e4b03ea88043356a"}, {"code": "#(set (map (fn[i] (set (keep-indexed (fn[n e] (if (bit-test i n) e)) %))) (range (Math/pow 2 (count %)))))", "problem": 85, "user": "4f296a80e4b0d6649770a02a"}, {"code": "(fn power-set [set-coll]\n  (letfn [(add-or-not-add-to-set \n  \t\t\t[set-coll ele]\n  \t\t\t(concat set-coll (map #(conj % ele) set-coll)))]\n  \t(loop [set-coll set-coll r #{#{}}]\n    \t(if (empty? set-coll)\n      \t(set r)\n      \t(recur (rest set-coll) (add-or-not-add-to-set r (first set-coll)))))))", "problem": 85, "user": "4fdf566fe4b05e33b9224f99"}, {"code": "(fn [c]\n  (letfn [(build [s]\n   \t\t\t\t (let [len (count s)]\n    \t\t\t   (cond \n     \t\t\t\t(= 0 len) #{#{}}\n     \t\t\t\t(= 1 len) #{#{} (set s)}\n     \t\t\t\t(= 2 len) #{#{} (set s) (conj #{} (first s)) (conj #{} (last s))}\n     \t\t\t\t:else (let [n (first s) sub-sets (build (rest s))]\n                            (clojure.set/union sub-sets\n                            \t\t\t\t   (map #(conj % n) sub-sets))))))]\n    (build c)))", "problem": 85, "user": "514721c6e4b0d520409ed392"}, {"code": "(fn p [s]\n  (if (empty? s) #{#{}}\n    (let [x0 (first s) rp (p (rest s))]\n    (apply conj rp (map #(conj % x0) rp)))))", "problem": 85, "user": "5145832be4b0e8879607340a"}, {"code": "(fn [s]\n(set\n(reduce \n #(concat\n   % \n   (map (fn [x] (conj x %2)) %)) \n [#{}]\n s\n)\n)\n)", "problem": 85, "user": "514457fbe4b0b4fb4ace5f43"}, {"code": "(fn [n]\n (set\n  (for [x (range (Math/pow 2 (count n)))]\n    (let [ cstr (take (count n) (concat (reverse (Integer/toString x 2)) (cycle \"0\")))\n           j (into [] n)]\n      (set (filter #(not (nil? %)) (map-indexed #(if (= %2 \\1) (nth j %)) cstr)))\n      ))))", "problem": 85, "user": "5124619ae4b02c3f2a072ccd"}, {"code": "(fn pwrset\n  ([tset] (pwrset #{ tset } #{ #{} }))\n  ([targetsets builder]\n     (if\n      (empty? targetsets) builder\n      (let [target (first targetsets)]\n        (if (contains? builder target)\n          (recur (disj targetsets target) builder)\n          (let [new-sets (for [item target] (disj target item))]\n            (if (empty? new-sets)\n              (recur (disj targetsets target) (conj builder target))\n              (recur (apply conj (disj targetsets target) new-sets) (conj builder target)))))))))", "problem": 85, "user": "515737f0e4b0b0b4b87062d0"}, {"code": "(fn [s]\n  (let [sx (vec s)\n        nums (range 0 (Math/pow 2 (count sx)))]\n  (letfn [(include [[b pos]]\n            (if (= \\1 b)\n              (sx pos)))]\n    (reduce conj #{}\n      (for [p\n      (map \n        (fn [n]\n          (map #(vector % %2) (reverse (Integer/toString n 2)) (range))) nums)]\n        (set (filter #(not (nil? %)) (map (fn [g] (include g)) p))))))))", "problem": 85, "user": "515a6151e4b0394f658fe241"}, {"code": "; http://clj-me.cgrand.net/2008/10/20/clojure-golf-subsets/\n(fn subsets [s]\n  (set (reduce (fn [ss x] (concat ss (map #(conj % x) ss))) [#{}] s)))", "problem": 85, "user": "50479524e4b0371827a27bc4"}, {"code": "(fn [s]\n  (reduce \n    (fn [res x] \n      (set (concat res (map #(conj % x) res) )))\n    #{#{}} s))", "problem": 85, "user": "50464831e4b011c5dfee771f"}, {"code": "(fn [S]\n  (reduce \n   (fn [ps, i] \n     (clojure.set/union ps (map #(clojure.set/union % #{i}) ps))) #{ #{} } S))", "problem": 85, "user": "4f21838fe4b0d66497709fd2"}, {"code": "(fn power-set-3 [coll]\n  (let [v (apply vector coll)\n        s (map #(map read-string (re-seq #\"\\d\" \n                                   (str \n                                    (apply str \n                                           (repeat (- (count coll) (.length (Integer/toBinaryString %))) \n                                                   \"0\")) \n                                    (Integer/toBinaryString %)))) (range (Math/pow 2 (count coll))))]\n    (set (map #((comp set clojure.set/union)\n                      (filter (comp not nil?)\n                        (map-indexed \n                         (fn [idx item] \n                           (if (zero? item)\n                             nil\n                             (v idx)))\n                         %))) \n              s))))", "problem": 85, "user": "50c8697ce4b00bb60fe0c53f"}, {"code": "(fn power-set [full-set]\n  (if (empty? full-set)\n    #{#{}}\n    (let [rest-pset (power-set (rest full-set))]\n      (into rest-pset (map #(conj % (first full-set)) rest-pset)))))", "problem": 85, "user": "510cd1dde4b078ea71921124"}, {"code": "(fn [s]\n  (set (for [i (range 0 (apply * (repeat (count s) 2)))]\n          (set (keep-indexed (fn [index item]\n                                (if (bit-test i index) item)) s)))))", "problem": 85, "user": "50b1d166e4b03ea880433554"}, {"code": "(fn ps [s]\n    (if (empty? s)\n      #{s}\n      (let [first-elt (first s)\n            rest (disj s first-elt)\n            ps-rest (ps rest)\n            ps-with-first (map #(conj % first-elt) ps-rest)]\n        (clojure.set/union ps-rest ps-with-first))))", "problem": 85, "user": "5165a235e4b079ad97ec44ac"}, {"code": "(fn p [s] (if (empty? s) #{s} (let [f (first s) r (p (disj s f))] (apply (partial conj r) (map #(conj % f) r)))))", "problem": 85, "user": "5134973ce4b0230e9f713b42"}, {"code": "(fn subsets [s]\n  (letfn [(inner [s ans]\n    (if (empty? s)\n      (conj ans s)\n      (let [x (first s)\n            r (set (rest s))\n            sub (subsets r)]\n        (concat sub (map #(conj % x) sub)) ) ) ) ]\n    (set (inner s #{}))))", "problem": 85, "user": "515f8a0de4b0e2be8aa20bce"}, {"code": "(fn power-set [s]\n  (let [e (some s s)]\n    (if (and (nil? e) (not (contains? s e))) #{#{}} \n        (let [add-elem-to-sets (fn [sets] (-> (map #(conj % e) sets) set))\n              lower-power-set (power-set (disj s e))]\n          (clojure.set/union lower-power-set (add-elem-to-sets lower-power-set))))   \n    )\n  )", "problem": 85, "user": "51729002e4b044b2ef48a850"}, {"code": "(letfn [(ps1 [ps x]\n        (set (concat ps\n                (map #(conj % x) ps))))]\n  (fn [s] (reduce ps1 #{#{}} s)))", "problem": 85, "user": "50b668dde4b08fb537db98f2"}, {"code": "(fn [x] \n  (reduce \n   (fn addelem [old elem] \n  \t (apply clojure.set/union old (conj #{} (map #(conj % elem) old))))\n   #{#{}}\n   (map identity x)\n   )\n  )", "problem": 85, "user": "513b77f3e4b00f740c76c403"}, {"code": "(fn [s]\n   (loop [ret #{#{}} cnt s]\n     (if (= cnt #{})\n       ret\n       (let [h (first cnt)]\n         (recur (clojure.set/union ret (set (map #(conj % h) ret)))\n                (disj cnt h))))))", "problem": 85, "user": "4eec82fe535d93acb0a668ae"}, {"code": "#(set\n      (map (fn [n] (set (remove nil?\n                          (map-indexed (fn [i m] (if (= \\1 m) ((vec %) i)))  \n                                       (reverse (Integer/toString n 2))))))\n        (range (java.lang.Math/pow 2 (count %)))))", "problem": 85, "user": "4e43b0d9535dc968683fc4a3"}, {"code": "(fn power-set [s]\n  (let [length (count s)\n        pattern (map (fn [e] (map #(bit-test e %) (range length))) \n                     (range (reduce * (repeat length 2))))]\n    (->> pattern\n         (map #(map (fn [f e] (and f e)) % s))\n         (map #(remove false? %))\n         (map set)\n         set)))", "problem": 85, "user": "511b9017e4b00c2a1fa7ff6b"}, {"code": "(fn [s]\n  (set (for [x (range (apply * (take (count s) (repeat 2))))]\n    (set (filter #(not (nil? %)) (map (fn [a i] (if (bit-test x i) a nil)) s (range)))))))", "problem": 85, "user": "51899891e4b0288ada3dbdab"}, {"code": "(fn powerset\n  [s]\n  (if (empty? s)\n    #{#{}}\n    (into (powerset (rest s)) (map #(conj % (first s)) (powerset (rest s))))))", "problem": 85, "user": "5194cd85e4b05be8c43d2381"}, {"code": "(fn [s]\n  (set (reduce #(concat %1 (map (fn [i] (set (conj i %2))) %1)) #{#{}} s)))", "problem": 85, "user": "514d7e29e4b019235f6c0587"}, {"code": "(fn [v]\n  (letfn [(add \n           [coll s n]\n           (for [x coll :when (= n (count x)) y s]\n             (conj x y)))]\n    (loop [i 0 sol #{#{}}]\n      (if (= i (count v)) sol\n        (recur (inc i) (apply conj sol (add sol v i)))))))", "problem": 85, "user": "51780f88e4b03d69594194c9"}, {"code": "(fn power-set [xs]\n  (if (empty? xs)\n    #{#{}}\n    (let [v (vec xs)\n          xs' (power-set (rest v))]\n       (into  xs' (map #(conj % (first v)) xs')))))", "problem": 85, "user": "5186134ce4b0da5a5be3bac7"}, {"code": "(fn __ [s]\n  (let [[f & r] (vec s)]\n    (cond\n     (nil? f) #{#{}}\n     (nil? r) #{#{} s}\n     :else\n     (set (concat #{#{} #{f} s}\n                  (__ (set r))\n                  (map #(set (cons f %)) (__ (set r))))))))", "problem": 85, "user": "512d3304e4b040332b905b2d"}, {"code": "(fn power [s]\n  (if (empty? s)\n    #{#{}}\n    (let [r (power (rest s))]\n      (clojure.set/union r (map #(into #{ (first s)} %) r)))))", "problem": 85, "user": "4e778d36535d324fb2983d71"}, {"code": "(fn [s] (loop [sts  #{ #{} } coll s] \n              (if (empty? coll) sts\n                  (recur (clojure.set/union sts\n                                 (set (map (fn [c] (conj c (first coll)) )\n                                              sts)))\n                      (rest coll)))))", "problem": 85, "user": "517945dce4b0684c1c981a43"}, {"code": "(fn ps [s] (if (empty? s) #{s} \n             (let [x (first s) s2 (disj s x) ps2 (ps s2)] \n               (clojure.set/union ps2 (set (map #(conj % x) ps2))))))", "problem": 85, "user": "515fb48fe4b0e2be8aa20bd5"}, {"code": "(partial\n  reduce (fn [a x]\n           (into a (map #(conj % x) a)))\n         #{#{}}\n         ,,,)", "problem": 85, "user": "4f9d8083e4b0dcca54ed6d23"}, {"code": "(fn pow-set [s]\n    (cond (= #{} s) #{#{}}\n          (= (count s) 1) #{#{(first s)} #{}}\n          :else\n          (into (pow-set (rest s)) \n                (map #(conj % (first s))\n                  (pow-set (rest s)))\n                )\n  )\n  )", "problem": 85, "user": "5159849ce4b0394f658fe236"}, {"code": "(fn [x]                                                                                                        \n  (letfn                                                                                                        \n      [(ps [x n]                                                                                                \n           (let [y (vec x)]                                                                                     \n             (cond                                                                                              \n              (= n 1) (set (map #(set [%]) x))                                                                  \n              :else                                                                                             \n              (set (for [i (range (dec (count y)))  j (ps (drop (inc i) y) (dec n))] (conj j (nth y i))))       \n              )                                                                                                 \n             )                                                                                                  \n           )]                                                                                                   \n      (set (cons #{} (mapcat #(ps x %) (range 1 (inc (count x))))))))", "problem": 85, "user": "519b7d76e4b02a926d9a436e"}, {"code": "(fn [s]\n  (set (reduce (fn [acc x] (mapcat #(do [% (conj % x)]) acc)) [#{}] s)))", "problem": 85, "user": "510b0480e4b078ea719210fa"}, {"code": "(fn [s]\n  (reduce\n   (fn [m v]\n     (into m (map #(conj % v) m)))\n   #{#{}} s))", "problem": 85, "user": "518ccf6be4b05e6c8537e386"}, {"code": "(fn [s]\n  (reduce (fn [x y] (into x (map #(conj % y) x)))\n          #{#{}} s))", "problem": 85, "user": "519b2570e4b0ac1b7dced6a3"}, {"code": "(fn [s]\n  (let [select (fn [c bs]\n                  (disj\n                    (into #{}\n                      (map-indexed\n                        #(if (= %2 \\1) (nth c %) nil)\n                        bs))\n                    nil))]\n    (into \n      #{}\n      (map\n        (comp\n          (partial select (vec s))\n          reverse\n          #(Long/toBinaryString %))\n       (range (Math/pow 2 (count s))))))\n\n)", "problem": 85, "user": "4ff3df0fe4b0678c553fc355"}, {"code": "(fn [s]\n  (letfn [(ff [s n]\n              (if (= n 0)\n                [s]\n                (let [hd (first s)\n                      ss (ff (disj s hd) (dec n))]\n                  (into (map #(conj % hd) ss)\n                        ss))))]\n    (conj (set (ff s (count s))) #{})))", "problem": 85, "user": "515ead6be4b049add99a053e"}, {"code": "(fn subsets [s]\n  (apply hash-set #{}\n  (map #(apply hash-set %)\n  (loop [result []\n         remaining s]\n    (if (seq remaining)\n      (recur (concat [[(first remaining)]] result (map #(conj % (first remaining)) result)) (rest remaining))\n      result)))))", "problem": 85, "user": "4fa340b4e4b081705acca18c"}, {"code": "(fn [x]\n  (loop [s x\n         a #{s}]\n    (if (= (apply * (repeat (count s) 2)) (count a))\n      a\n      (recur s\n             (reduce\n               (fn [i j]\n                 (into i\n                       (for [k j]\n                         (set (remove #{k} j)))))\n               a\n               a)))))", "problem": 85, "user": "51b3f109e4b0f094dd986fa9"}, {"code": "(fn [s]\n  (reduce \n    (fn [init e] \n      (set (concat init (map #(conj % e) init) [#{e}])))\n    #{#{}} s))", "problem": 85, "user": "51bec919e4b013aa0d74b800"}, {"code": "(fn [n]\n (set (map #(loop [l % r #{} c n]\n              (if (zero? l) r\n                (recur \n                  (int (/ l 2))\n                  (if (= (mod l 2) 1) \n                    (conj r (first c)) r)\n                  (rest c))))\n           (range (Math/pow 2 (count n))))))", "problem": 85, "user": "512f06c5e4b0762be4c7aad7"}, {"code": "(fn [x]\n  (if (empty? x)\n    #{x}\n    (let [n      (count x)\n          y      (vec x)\n          powers (for [i (range (Math/pow 2 n))]\n                   (format (str \"%0\" n \"d\") (Integer/parseInt (Integer/toString i 2))))]\n      (set (map (fn [power]\n                  (set (remove nil? (map-indexed #(when (= %2 \\1) (nth y %1)) power))))\n                powers)))))", "problem": 85, "user": "51307b84e4b08c712d3fae39"}, {"code": "reduce (fn [a x] (into a (map #(conj % x) a))) #{#{}}", "problem": 85, "user": "51805d22e4b0e3fc13e244df"}, {"code": "#(set (for [x (%2 (Math/pow 2 (% %3)))] \n        (set (for [y (%2 (% %3)) :when (bit-test x y)] ((vec %3) y))))) count range", "problem": 85, "user": "51b90b88e4b050a1176cd6a2"}, {"code": "(fn pow [s] (if (empty? s) #{s} (let [\n    s1 (first s)\n    sn (disj s s1)\n    pp (pow sn)\n    pn (for [i pp] (conj i s1))]\n    (into pp pn))))", "problem": 85, "user": "51cbdee1e4b08d8387cbede1"}, {"code": "(fn [coll]\n  (reduce (fn [r elt]\n            (clojure.set/union r (map #(conj % elt) r)))\n          #{#{}}\n          coll))", "problem": 85, "user": "507b7dbee4b09034bfeeb71e"}, {"code": "(fn [s]\n    (letfn [(g [y]\n              (map (partial conj y) s))\n            (f [x] \n              (set (mapcat g x)))\n            (not-found [x]\n              (not (some final-length x)))\n            (final-length [x]\n              (= (count x) (count s)))]\n      (conj (first (drop-while not-found (iterate f #{#{}}))) #{})))", "problem": 85, "user": "5141abf1e4b02fd87f5064c3"}, {"code": "(fn power-set [s]\n  (set (reduce (fn [as x]\n            (concat as (map #(conj % x) as)))\n          [#{}] s)))", "problem": 85, "user": "50d86fe2e4b01f0871336e67"}, {"code": "(fn p [s]\n  (if (empty? s) #{#{}}\n      (let [t (p (rest s))]\n        (into t\n              (map #(conj % (first s)) t)))\n      ))", "problem": 85, "user": "51b9d1f0e4b0e871ca49590b"}, {"code": "(fn [xs]\n  (letfn [(branch [seed items]\n            (if (empty? items)\n              [(set seed)]\n              (lazy-seq (cons (set seed)\n                              (mapcat #(branch (conj seed %) (drop %2 items))\n                                      items\n                                      (range 1 (inc (count items))))))))]\n    (set (branch #{} (seq xs)))))", "problem": 85, "user": "5102ac9de4b00c483ae176fa"}, {"code": "(fn [s]\n  (reduce (fn [ps e] (into ps (map #(conj % e) ps)))\n          #{#{}}\n          s))", "problem": 85, "user": "51d19c24e4b0cfcf579466c3"}, {"code": "(fn ps [s]\n  (set (reduce (fn [r x]\n                 (concat (conj r #{x})\n                         (map #(conj % x) r)))\n               #{#{}}\n               s)))", "problem": 85, "user": "50f48298e4b004d364930527"}, {"code": "(fn [s]\n  (reduce (fn [ps x]\n            (reduce (fn [ps s]\n                       (conj ps (conj s x))) ps ps)) #{#{}} s))", "problem": 85, "user": "5164867fe4b003cf19fdde3e"}, {"code": "(fn [se]\n  (reduce #(set (concat %1 (map (fn [i] (conj i %2)) %1)\n                 )) #{#{}} se\n   ))", "problem": 85, "user": "51da7e49e4b02ceefd947768"}, {"code": "(fn ps [s]\n  (loop [res #{#{}} li s]\n    (if (empty? li)\n      res\n      (recur\n       (apply merge res\n              (for [x res]\n                (clojure.set/union x (hash-set (first li)))))\n       (rest li)))))", "problem": 85, "user": "51c09719e4b0c9c82288293c"}, {"code": "(fn power-set [s]\n  (letfn [(ps [r] (reduce #(into % (for [x %2] (disj %2 x))) r r))]\n    (loop [s s r #{s}]\n      (if (= r s) r (recur r (ps r))))))", "problem": 85, "user": "511d6a01e4b022853b0e07a5"}, {"code": "(fn [s]\n  (if (empty? s) #{s}\n    (let [[x & xs] (vec s)\n          grow (fn [cs e] (lazy-cat (for [c cs] (conj c e)) cs))          \n          combos (reduce grow [[x] []] xs)]\n      (into #{} (map set combos)))))", "problem": 85, "user": "51cdd3f0e4b0e42293a2254b"}, {"code": "(fn [s]\n  (set (reduce (fn [subsets elem]\n                 (concat subsets (map #(conj % elem) subsets)))\n               [#{}]\n               s)))", "problem": 85, "user": "51789dfae4b03d69594194d7"}, {"code": "(fn [m](letfn [(powerset \n\t[x] \n\t(if (= x #{}) #{#{}}\n\t(clojure.set/union (map #(clojure.set/union (hash-set (first x)) %) \n\t\t(powerset (disj x (first x))))  (powerset (disj x (first x)))   )))]\n\t(into  #{}\t(powerset m))))", "problem": 85, "user": "518644bce4b0da5a5be3baca"}, {"code": "(fn [s]\n  (let [expt  (fn [b e]\n                (int (.pow (.toBigInteger (bigint b)) e)))\n        v     (vec s)\n        hmask (expt 2 (count s))\n        inds  (fn [k]\n                (filter #(> (bit-and k (expt 2 %)) 0) (range (count s))))]\n    (->> hmask\n         range\n         (map inds)\n         (map #(into #{} (map v %)))\n         (into #{}))))", "problem": 85, "user": "51eff839e4b0249c592fbdf1"}, {"code": "reduce (fn [a x]\n         (into a (map #(conj % x) a))) #{#{}}", "problem": 85, "user": "51ba8f82e4b0fe3ecfb46434"}, {"code": "(partial reduce (fn [xss x]\n                  (let [xss+x (map #(conj % x) xss)]\n                    (into xss xss+x)))\n         #{#{}})", "problem": 85, "user": "51efd397e4b0249c592fbdeb"}, {"code": "(fn power-set\n  [aSet]\n  (if-let [s (seq aSet)]\n    (let [v  (first s)\n          sp (power-set (set (next s)))]\n      (set (apply conj (map #(conj % v) sp) sp)))\n    #{#{}}))", "problem": 85, "user": "511b233ae4b07ab9ec456180"}, {"code": "(fn [s]\n           (let [l (vec s)\n                 b-inc (fn [bn] (let [n (Long/toBinaryString (inc (Long/valueOf bn 2)))\n                                      cn (count n)]\n                                  (str (reduce str (repeat (- (count l) cn) 0)) n)))\n                 b-fetch (fn [bn l]\n                           (loop [bn bn\n                                  l l\n                                  acc #{}]\n                             (if (empty? bn)\n                               acc\n                               (recur (apply str (rest bn))\n                                      (rest l)\n                                      (if (= \\0 (first bn))\n                                        acc\n                                        (conj acc (first l)))))))]\n             (loop [n (apply str (repeat (count l) 0))\n                    acc #{}]\n               (if (every? #(= \\1 %) n)\n                 (conj acc (b-fetch n l))\n                 (recur (b-inc n)\n                        (conj acc (b-fetch n l)))))))", "problem": 85, "user": "50a5b7e9e4b0aa96157e2610"}, {"code": "(fn [s]\n  (reduce \n   (fn [r i]  (conj r (set (keep-indexed #(if (bit-test i %1) %2) (vec s))))) \n    #{#{}} \n   (range  1 (bit-shift-left 1 (count s)))))", "problem": 85, "user": "51f59607e4b0abb92f97f9d5"}, {"code": "(fn [s]\n  (letfn [(thingaddf [ps leftover] (map #(conj % (first leftover)) ps))\n          (thingadder [[ps leftover]] \n                      [(set (conj (concat ps (thingaddf ps leftover)) #{(first leftover)}))\n                       (rest leftover)])]\n    (-> (drop-while #(not-empty (second %)) \n               (iterate thingadder [#{#{}} s]))\n      first first)))", "problem": 85, "user": "5133e51ae4b0d7a043de8cf6"}, {"code": "(fn [s] \n   (nth\n     (iterate \n       #(into #{#{}} (for [x s y %] (into #{x} y)))\n       (map hash-set s)) \n     (max 1 (count s))))", "problem": 85, "user": "51e58e02e4b0efabf93c02d0"}, {"code": "(fn [s]\n  (loop [acc #{#{}} xs s]\n    (if (empty? xs) acc\n        (recur \n         (set (concat (map #(set (cons (first xs) %)) acc) acc))\n         (rest xs)\n        )\n    )\n  )\n)", "problem": 85, "user": "51897709e4b0288ada3dbdaa"}, {"code": "(fn ps [S]\n  (letfn [(combine [acc x]\n            (conj (into acc (map #(conj % x) acc)) #{x}))]\n    (conj (reduce combine #{} S) #{})))", "problem": 85, "user": "51d96ad0e4b02ceefd94774f"}, {"code": "(fn powset [s]\n    (if (seq s)\n      (set (concat (map #(conj % (first s)) (powset (next s)))\n                   (powset (next s))))\n      #{#{}}))", "problem": 85, "user": "50aedb8ce4b0a40c9cfb08d4"}, {"code": "(fn ps [s]\n  (let [c (count s)\n        v (vec s)\n        f (fn [n] (filter #(bit-test n %) (range c)))]\n    (into #{#{}} \n      (for [n (range 1 (inc (Math/pow 2 c)))]\n        (reduce #(conj % (nth v %2)) #{} (f n))))))", "problem": 85, "user": "50c781bbe4b00bb60fe0c535"}, {"code": "(fn [s]\n  (set \n   (map \n    set \n    ((fn f [[v & o] ret]\n       (if (nil? v) \n         [ret]\n         (concat (f o ret)\n                 (f o (conj ret v)))))\n     (seq s) #{}))))", "problem": 85, "user": "51944aaae4b0142f60b4aedc"}, {"code": "(fn [xs]\n   (loop [que #{xs}\n          acc #{}]\n     (if (seq que)\n       (let [h (first que)\n             acc (conj acc h)\n             que (into (disj que h)\n                       (filter (complement acc) (map #(disj h %) h)))]\n         (recur que acc))\n       acc)))", "problem": 85, "user": "513fab65e4b00f13ea1bd891"}, {"code": "(comp\n  set\n  (partial map set)\n  #(map\n    (fn [a b] (map second (filter (fn [[x _]] (pos? (bit-and a (bit-shift-left 1 x)))) b)))\n    (range 0 (bit-shift-left 1 (count %))) \n    (repeat (map vector (range) %))))", "problem": 85, "user": "5201572be4b0d7096e99ddbb"}, {"code": "(fn pwr [s]\n  \t(letfn [(f [e T] (->> T\n    \t                    (map #(clojure.set/union #{e} %))\n        \t                set))]\n    \t(if (empty? s)\n      \t#{#{}}\n      \t(let [e (first s)\n        \t    t (clojure.set/difference s #{e})]\n        \t(clojure.set/union (pwr t) (f e (pwr t)))))))", "problem": 85, "user": "502a5e59e4b09e8f859a9fbc"}, {"code": "(fn fun [coll]\n\t(if (empty? coll) #{#{}}\n\t\t(clojure.set/union \n\t\t\t(reduce\n\t\t\t\t#(conj % (conj %2 (first coll)))\n\t\t\t\t#{}\n\t\t\t\t(fun (rest coll)))\n\t\t\t(fun (rest coll)))))", "problem": 85, "user": "520242bae4b030ee0c5b26e3"}, {"code": "(fn power-set\n  [x]\n  (if (empty? x) #{#{}}\n    (let [half (power-set (rest x))]\n      (into half (map #(conj % (first x)) half)))))", "problem": 85, "user": "52084f75e4b01ce6bbf31dde"}, {"code": "(fn [s]\n  (loop [xs s\n         acc (list #{})]\n    (if (empty? xs)\n      (set acc)\n      (recur (rest xs) (concat acc (map #(conj % (first xs)) acc))))))", "problem": 85, "user": "52015698e4b0d7096e99ddba"}, {"code": "(fn powerset [s]\n\t  (cond (empty? s) #{#{}}\n\t\t:else (let [of-rest (powerset (rest s))]\n\t\t\t   (clojure.set/union of-rest (map #(conj % (first s)) of-rest)))))", "problem": 85, "user": "5213ffd3e4b0961f15ac4d7d"}, {"code": "(fn power-set [s]\n\t(let [elems (vec s) \n\t\t\tcnt (count s)]\n\t\t(letfn [(subset [bits] \n\t\t\t\t(reduce (fn [so-far bit]\n\t\t\t\t\t(if (pos? (bit-and bits (bit-shift-left 1 bit)))\n\t\t\t\t\t\t(conj so-far (nth elems bit))\n\t\t\t\t\t\tso-far))\n\t\t\t\t\t#{}\n\t\t\t\t(range cnt)))]\n\t\t\t\t(->> cnt (Math/pow 2) range (map subset) set)\n\t\t\t)))", "problem": 85, "user": "51ba4482e4b0fe3ecfb4642b"}, {"code": "reduce (fn [p i] (clojure.set/union p (set (map #(clojure.set/union % #{i}) p)))) #{#{}}", "problem": 85, "user": "51f66e0ee4b06ff1c25c52c3"}, {"code": "(fn p [s]\n  (if (= #{} s)\n    #{#{}}\n    (loop [h (first s)\n           t (rest  s)\n           T (disj s h)]\n      (clojure.set/union (p T) (map #(clojure.set/union #{h} %) (p T))))))", "problem": 85, "user": "51f28a64e4b0210f90e7454e"}, {"code": "(fn powerset [ls]\n  (if (empty? ls) #{#{}}\n      (clojure.set/union (powerset (next ls))\n        (map #(conj % (first ls)) (powerset (next ls))))))", "problem": 85, "user": "51f9527fe4b09be9c177e549"}, {"code": "(fn power-set [S]\n  (if (empty? S)\n    #{#{}}\n    (let [F (fn [e T] (into #{} (map #(conj % e) T)))\n          e (first S)\n          T (disj S e)\n          power-T (power-set T)]\n      (clojure.set/union power-T (F e power-T)))))", "problem": 85, "user": "4fe13ad7e4b0dd6cd5ce3632"}, {"code": "(fn [s]\n         (set (reduce #(concat %1 (map (fn [i] (set (conj i %2))) %1)) #{#{}} s)))", "problem": 85, "user": "511b810ce4b07ab9ec456182"}, {"code": "(fn [s]\n  (into #{#{}} (map (fn [n]\n                          (set (map first\n                                    (filter (fn [e] (= (second e) \\1))\n                                            (map (fn [e bs]\n                                                   [e bs])\n                                                 s\n                                                 (reverse (Integer/toBinaryString n)))))))\n                     (range (Math/pow 2 (count s))))))", "problem": 85, "user": "4ee528fb535d1385b2869d87"}, {"code": "(fn f [v] \n  (into #{} (if (empty? v)\n    [#{}]\n    (concat []\n      (map #(conj % (first v)) (f (next v)))\n      (f (next v))))))", "problem": 85, "user": "52196842e4b0890f2f822bfa"}, {"code": "(fn [ps]\n  (letfn [(bits[n] (loop [i n b []] (if (zero? i) b (recur (quot i 2) (concat b [(mod i 2)])))))] \n    (into #{} (for [i (range 1024)] (into #{} (filter #(not (nil? %)) (map (fn[a b] (if (= 1 b) a)) ps (bits i)))))))\n)", "problem": 85, "user": "5093ca51e4b097f48cc38585"}, {"code": "(fn [x]\n  (let [cnt (reduce * (take (count x) (repeat 2)))]\n    (if (= (count x) 0)\n      #{#{}}\n      (loop [ind cnt result #{}]\n        (let [lead-zeros (clojure.string/join (str (count x)) [\"%0\" \"d\"])\n              binre (format lead-zeros (#(Integer/parseInt %) (#(Integer/toBinaryString %) (- ind 1))))\n              boo-array (rest (clojure.string/split binre #\"\"))]\n          (if (<= ind 1)\n            (conj result #{})\n            (recur (dec ind) (conj result (into #{} (filter #(not (nil? %)) (map #(if (= %1 \"1\") %2) boo-array x)))))))))))", "problem": 85, "user": "52016690e4b0b2e020a18f0f"}, {"code": "(fn [s]\n  (let [super (fn [s rec]\n                (if (empty? s)\n                    #{s}\n                  (->\n                    #(rec (disj s %) rec)\n                    (mapcat s)\n                    set\n                    (conj s))))]\n    (super s (memoize super))))", "problem": 85, "user": "514c2d05e4b02b8cbb2a9278"}, {"code": "(fn [x]  (conj (set (map set (set (reduce (fn [x y] (concat (map #(concat %1 #{y}) x ) x #{#{y}}\n                                                                    \n                                                                    \n                                                                    )) #{} x)))) #{}))", "problem": 85, "user": "5225b16de4b0d2f5d1e2c0ed"}, {"code": "(fn p [s]\n  (reduce (fn [a e] (into a (map #(conj % e) a)))\n          #{#{}} s))", "problem": 85, "user": "522b922ee4b0d34ee08e71c3"}, {"code": "(fn ps [arg]\n  (letfn [(get-binary [n d]\n            (let [pad (fn [s]\n                        (if (>= (count s) d)\n                          s\n                          (#(loop [n % s s] (if (== n 0) s (recur (dec n) (cons 0 s)))) (- d (count s)))))]\n              (loop [s '()\n                     n n]\n                (if (== n 0)\n                  (pad s)\n                  (recur (cons (rem n 2) s) (quot n 2))))))\n          (get-set [xs b]\n            (->> (map #(when (== 1 %2) %1) xs b) (filter #(not (nil? %))) set))]\n    (if (= arg #{})\n      #{#{}}\n    (->> (for [x (range (last (take (count arg) (iterate #(* 2 %) 2))))]\n      (->> (get-binary x (count arg)) (get-set arg))) set))))", "problem": 85, "user": "52016fd3e4b0b2e020a18f10"}, {"code": "(fn [s]\n  (loop [result #{s}]\n    (let [new-result\n          (reduce\n            (fn [r e] (into r ((fn [s] (reduce (fn [r e] (conj r (disj s e))) #{} s)) e)))\n            result result)]\n      (if (new-result #{})\n        new-result\n        (recur new-result)))))", "problem": 85, "user": "50ebd63ce4b04edc3377703c"}, {"code": "(fn [s]\n  (let [v (vec s)\n        len (count v)\n        plen (int (Math/pow 2 len))]\n    (letfn [(to-bits\n              ([n] (to-bits n []))\n              ([n acc] (if (zero? n)\n                         (rseq acc)\n                         (recur (quot n 2)\n                                (conj acc (mod n 2))))))\n            (sel [m] (if (nil? m)\n                       #{}\n                       (into #{} (for [i (range (count m))\n                                       :let [b (nth m i)\n                                             el (nth v i)]\n                                       :when (not (zero? b))] el))))]              \n      (set (for [i (range plen)\n                 :let [bs (to-bits i)\n                       pad (vec (take (- len (count bs)) (repeat 0)))\n                       m (into pad bs)]]\n             (sel m))))))", "problem": 85, "user": "4f9c4080e4b0dcca54ed6d1a"}, {"code": "(fn [s]\n  (letfn\n    [(rsets [root [head & tail]]\n      (if\n        (nil? head)\n        [root]\n        (concat\n          (rsets root tail)\n          (rsets (conj root head) tail))))]\n    (set (map set (rsets [] (apply list s))))))", "problem": 85, "user": "521e8227e4b0dd19981ad082"}, {"code": "(fn [coll]\n  (reduce (fn [result c]\n            (into result\n                  (map #(conj % c) result)))\n          #{#{}}\n          coll))", "problem": 85, "user": "52381b2ae4b0fae3832e99ef"}, {"code": "(fn [xs]\n  (loop [ps #{#{}} s (seq xs)]\n    (if s\n      (recur (into ps (map #(into % #{(first s)}) ps)) (next s))\n      ps)))", "problem": 85, "user": "4fe8fda4e4b0547ebccb2438"}, {"code": "(fn power-set [xs]\n  (if (seq xs)\n    (let [ps (power-set (rest xs))]\n      (clojure.set/union ps\n                         (set (map #(conj % (first xs)) ps))))\n    #{#{}}))", "problem": 85, "user": "52487654e4b05ef8e38e63dc"}, {"code": "(fn subsets [s]\n  (if (empty? s) #{s}\n      (let [elem #{(first s)}\n            others (disj s (first s))]\n      (clojure.set/union (subsets others) (map #(clojure.set/union elem %) (subsets others))))))", "problem": 85, "user": "4fbd12a5e4b081705acca2fd"}, {"code": "(fn superset\n  [s]\n  (let [seed (set (map #(set [%]) s))]\n    (letfn [(helper [slow] \n              (mapcat (fn [c] \n                        (map #(set (concat c %)) seed)) \n                      slow))]\n      (set \n       (loop [i (inc (count s)) step seed result #{#{}}]\n         (if (zero? i)\n           result\n           (let [stage (set (helper step))\n                 result (set (concat result stage))]\n             (recur (dec i) \n                    stage\n                    result))))))))", "problem": 85, "user": "5048202fe4b0ec70b3ef8d9a"}, {"code": "(fn power-set [coll]\n  (set (reduce (fn [res el] (concat res (set (map #(conj % el) res)))) [#{}] coll)))", "problem": 85, "user": "523b82efe4b07becd5be21f0"}, {"code": "(fn [s] (letfn [(f [n i v] (if (bit-test n i) #{v} #{}))\n                (f2 [n] (->> s (map-indexed (partial f n)) (apply concat) set))]\n     (set (map f2 (range (bit-shift-left 1 (count s)))))))", "problem": 85, "user": "523b1988e4b02f719975bdbc"}, {"code": "(fn [s]\n  (let [elements (seq s)\n        get-subs #(into #{}\n                        (for [e % st %2]\n                          (when (contains? st e)\n                            (disj st e))))]\n    (loop [acc #{s}\n           subs (get-subs elements [s])]\n      (if (contains? acc #{})\n        (disj acc nil)\n        (recur (into acc subs) (get-subs elements subs))))))", "problem": 85, "user": "4f048f67535dcb61093f6bd3"}, {"code": "(fn [s] (set (reduce (fn [x y] (mapcat #(list (conj % y) %) x)) #{#{}} s)))", "problem": 85, "user": "52379c46e4b0fae3832e99db"}, {"code": "(fn power-set [s] \n  (if (empty? s)\n      #{#{}}\n      (let [f (first s)\n            r (power-set (rest s))]\n        (set (concat r (map (fn [element] (conj element f))\n                     r)\n                )))))", "problem": 85, "user": "4ed286d4535d44c135fd68d7"}, {"code": "(fn [s] \n  (let [sol (fn [ss ps] \n              (let [as (set (for [p ps t p] (disj p t)))\n                    iss (into ss as)]\n                (cond (>= 1 (count as)) iss\n                  :else (recur iss as))))]\n    (sol (hash-set s) (hash-set s))))", "problem": 85, "user": "5246e945e4b0644eb7b0783b"}, {"code": "(fn ps [s]\n  (if (empty? s)\n    #{#{}}\n    (let [ps' (ps (set (rest s)))\n          x (first s)]\n      (set (concat ps' (map #(conj % x) ps'))))))", "problem": 85, "user": "524cdd51e4b0752c4cb68ccc"}, {"code": "(fn [s]\n  (reduce (fn [ss e] (into ss (map #(conj % e) ss)))\n          #{#{}} s))", "problem": 85, "user": "51e00020e4b01188f0627534"}, {"code": "(fn power-set [coll]\n  (loop [acc #{#{}}, coll coll]\n    (if (empty? coll) \n      acc\n      (let [x (first coll)]\n        (recur (into acc (for [y acc] (conj y x))) (rest coll))))))", "problem": 85, "user": "5224a46ce4b01819a2de42e5"}, {"code": "(fn power-set [coll] \n  (let [parts (fn parts [coll n] \n    (cond (= 0 n) \n\t        [#{}]\n\t     (seq coll)\n\t\t\t (if (= 1 n)\t\n\t\t\t\t (map hash-set coll)\n\t\t\t\t (loop [f (first coll)\n\t\t\t\t\t   r (next coll)\n\t\t\t\t\t   conj-ed (apply hash-set (map #(into #{f} %) (parts r (dec n)) ))\n\t\t\t\t\t   ] \n\t\t\t\t\t(if (seq r)\n\t\t\t\t\t\t (recur (first r) \n\t\t\t\t\t\t\t\t(next r) \n\t\t\t\t\t\t\t\t(into conj-ed (map #(into #{(first r)} %) (parts (next r) (dec n)) ) ))\n\t\t\t\t\t\t conj-ed)))\n\t\t :else [#{}])) ]\n    (set (mapcat #(parts coll %) (range (inc (count coll)))))))", "problem": 85, "user": "523a9fc9e4b081681ca7adca"}, {"code": "(fn [s] (set (\n\n(fn p [c r] \n  (conj \n   (apply concat \n    (map-indexed \n     #(p (conj c %2) (drop (inc %1) r)) \n     r)) \n   c)) #{} s\n              \n)))", "problem": 85, "user": "524be8e0e4b09eba1c0223f1"}, {"code": "(fn p [s]\n  (if (empty? s) #{#{}}\n    (let [others (p (rest s))\n          c (first s)]\n      (reduce #(conj % (conj %2 c)) (conj others #{c}) others))))", "problem": 85, "user": "52479487e4b05ef8e38e6373"}, {"code": "(fn ps [x]\n   (if (empty? x)\n     #{#{}}\n     (set\n      (concat\n       (map #(conj % (first x)) (ps (rest x)))\n       (ps (rest x))\n       )\n      )\n     )\n   )", "problem": 85, "user": "52586d24e4b0cb4875a45cb0"}, {"code": "(fn p [s] \n  (if (empty? s)\n    #{#{}}\n    (let [f     (first s)\n          r     (disj s f)\n          prest (p r)\n          conjf (map #(conj % f) prest)] \n      (clojure.set/union prest conjf))))", "problem": 85, "user": "51c19873e4b0d204dbe2ca0d"}, {"code": "(fn power-set [s]\n  (if (empty? s)\n    #{#{}}\n    (let [e (first s)\n          T (set (rest s))\n          PT (power-set T)\n          FeT (set (map #(conj % e) PT))]\n      (clojure.set/union PT FeT))))", "problem": 85, "user": "5201ada5e4b0b2e020a18f14"}, {"code": "(fn power-set-- [coll]\n  (if (empty? coll)\n    #{(set coll)}\n    (let [part_res (power-set-- (rest coll))]\n      (set (concat (map #(set (cons (first coll) %1)) part_res) part_res)))))", "problem": 85, "user": "511e763ce4b03e81d390ac29"}, {"code": "(fn [coll] (letfn [\n(n-tuples [coll n]\n  (cond\n   (not coll) '()\n   (= 0 n) (list '())\n   (= 1 n) (map list coll)\n   (= n (count coll)) (list coll)\n   :else (concat (map #(cons (first coll) %) (n-tuples (next coll) (dec n)))\n           (n-tuples (next coll) n))))]\n(set (map set\n          (apply concat\n                 (for [i (range (inc (count coll)))]\n                   (n-tuples coll i)))))))", "problem": 85, "user": "524ae8e6e4b09eba1c0223b5"}, {"code": "(fn power-set [trgt-st]\n  (letfn [(break-up [st]\n                    (reduce #(conj %1 (disj st %2)) #{} st))\n          (next-line [st]\n                     (reduce #(apply conj %1 (break-up %2)) #{} st))]\n    (loop [st #{trgt-st} pwr-st #{trgt-st}]\n      (if (= st #{#{}}) pwr-st\n        (recur (next-line st) (apply conj pwr-st (next-line st)))))))", "problem": 85, "user": "52463059e4b09dbe66b56198"}, {"code": "#(let [v (vec %) c (count v) r (range 0 c)]\n  (set (map (fn [i]\n              (reduce (fn [a j] \n                        (if (not= 1 (mod (bit-shift-right i j) 2)) a\n                          (conj a (get v j)))) #{} r)) \n            (range 0 (bit-shift-left 1 c)))))", "problem": 85, "user": "4f2d5f5de4b0d6649770a05a"}, {"code": "(fn f [l]\n    (loop [r #{#{}}\n           s [l]]\n       (if (seq s)\n         (recur\n          (into r s)\n          (set (mapcat (fn [x] (map #(disj x %) x)) s)))\n         r)))", "problem": 85, "user": "523ed522e4b057c4b7cd0a78"}, {"code": "(fn pset [s]\n  (if (empty? s)\n    #{ #{} }\n    (let [f (first s)\n          r (disj s f)\n          p (pset r)]\n      (clojure.set/union p (set (map #(conj % f) p))))))", "problem": 85, "user": "525f51bde4b0cb4875a45dc8"}, {"code": "(fn p[s]\n\t\t(if (empty? s)\n\t\t\t#{#{}}\n\t\t  (let [r (p (rest s))\n\t\t\t\t  f (first s)\n\t\t\t\t  a (map #(conj % f) r)]\n\t\t\t(set (concat a r)))))", "problem": 85, "user": "51f2851fe4b0210f90e7454b"}, {"code": "(fn p [s]\n  (if (empty? s)\n    #{#{}}\n    (set (flatten (for [i (p (rest s))]\n                    [(set (cons (first s) i)) i])))))", "problem": 85, "user": "50bce014e4b0594b91591c63"}, {"code": "(fn [the-col] (letfn [(presentation [presented  the-new]\n                         (if (= presented '())\n                           (list  (list the-new))\n                           (-> (apply conj presented\n                                      (map #(conj % the-new) presented))\n                               (conj (list the-new )))))]\n                 (->> (loop [presented '() to-present the-col]\n                             (let [presentate (presentation presented (first to-present))\n                                   the-next (next to-present)]\n                               (if the-next\n                                 (recur presentate the-next )\n                                 (conj  presentate (list)))))\n\n                      (map set )\n                      (remove  (partial = #{nil}))\n                      (set )\n\n                      )\n                 ))", "problem": 85, "user": "50550f43e4b0b1b9d1860eb7"}, {"code": "(fn [myset] (letfn [(combos [v] (if (seq v) (mapcat #(vector % (conj % (first v))) (combos (rest v))) '(#{})))] (set (map set (combos myset)))))", "problem": 85, "user": "5275f7a2e4b03e8d9a4a74d0"}, {"code": "(fn power-set\n  [input-set]\n  (set \n    (map set\n    (reduce\n      (fn [aggregate-set elem]\n        (concat aggregate-set (map #(conj %1 elem) aggregate-set)))\n      [()]\n      input-set))))", "problem": 85, "user": "5268eb68e4b03e8d9a4a71c6"}, {"code": "(fn self \n  ([s]\n    (self s #{#{}}))\n  ([s res]\n    (if (empty? s) res\n      (self (rest s) (clojure.set/union res (map #(conj % (first s)) res)) ))))", "problem": 85, "user": "52667ecfe4b03e8d9a4a713e"}, {"code": "(fn power-set [s]\n  (let [idx-set (map vector s (range))]\n    (reduce\n      (fn [accum mask]\n        (conj\n          accum\n          (reduce\n            #(if (not= (bit-and (bit-shift-left 1 (second %2)) mask) 0)\n               (conj %1 (first %2))\n               %1)\n            #{}\n            idx-set)))\n      #{}\n      (range (bit-shift-left 1 (count s))))))", "problem": 85, "user": "526ee63de4b03e8d9a4a733f"}, {"code": "(fn [s]\n  (set (reduce (fn [a b] (mapcat (fn [x] [x (conj x b)] ) a)) [#{}] s\n          ))\n  )", "problem": 85, "user": "523f0bbfe4b01c266ffa7f91"}, {"code": "(fn power-set [coll]\n  (set (reduce (fn [acc el] (concat acc (map #(conj % el) acc))) [#{}] coll)))", "problem": 85, "user": "52319066e4b0e2e8de81d1e9"}, {"code": "(fn f [s] (let [z (first s)\n                without-z (disj s z)\n                the-union (fn [e k result]\n                            (if (empty? k) result\n                              (recur e (disj k (first k)) (conj result (conj (first k) e)))\n                            )\n                          )\n                ]\n            (if (empty? s) #{#{}}\n\t            (clojure.set/union (f without-z) (the-union z (f without-z) #{}))\n            )\n          )\n)", "problem": 85, "user": "526dd90de4b03e8d9a4a72fe"}, {"code": "(fn [s]\n  (let [v (vec s)\n        sieve (fn [n]\n                (into #{}\n                      (filter identity\n                              (map #(if (= \\1 %1) %2)\n                                   (format (str \\% (count v) \\s) (Integer/toBinaryString n))\n                                   v))))]\n    (into #{} (for [i (range (bit-shift-left 1 (count v)))]\n                (if (zero? i) #{}\n                  (sieve i))))))", "problem": 85, "user": "51df825de4b01188f062752b"}, {"code": "(fn p85\n  ([lst] (p85 #{#{}} lst))\n  ([s lst]\n     (if (empty? lst) s\n         (p85 (reduce conj s (for [ss s] (conj ss (first lst)))) (next lst)))))", "problem": 85, "user": "5272669de4b03e8d9a4a742e"}, {"code": "(fn power-set\n   ([start-set] (power-set #{ #{} } start-set))\n   ([cur-set start-set]\n      (let [new-set (reduce #(conj % %2) cur-set (mapcat (fn [cs] (map #(conj cs %) start-set)) cur-set))]\n        (if (= cur-set new-set)\n          cur-set\n          (recur new-set start-set)))))", "problem": 85, "user": "524f213be4b0541d1855b7ff"}, {"code": "(fn self [xs]\n  (if (empty? xs)\n    #{#{}}\n    (let [x (first xs)\n          s (self (rest xs))]\n      (into s (map #(conj % x) s)))))", "problem": 85, "user": "5233ad08e4b07e3ee2be83ac"}, {"code": "(fn pw\n    [a]\n    (if (empty? a)\n      #{#{}}\n      (if (= 1 (count a))\n        #{#{(first a)} #{}}\n        (set (for [x (pw #{(first a)}) y (pw (rest a))] (clojure.set/union x y)))))\n    )", "problem": 85, "user": "52593207e4b0cb4875a45cd3"}, {"code": "(fn power-set [s]\n  (if (empty? s)\n    #{#{}}\n    (let [sub (power-set (rest s))]\n      (clojure.set/union sub (map #(conj % (first s)) sub)))))", "problem": 85, "user": "52736ca1e4b03e8d9a4a747e"}, {"code": "(fn [src]\n   (if (empty? src) #{#{}}\n   (letfn [(tst [s] (distinct(mapcat #(for [x (range (count %))] (disj % (nth (vec %) x))) s)))]\n     (loop [x (list src) y #{#{}}]\n       (if (= 1 (count (first x))) (set(concat y x))\n         (recur (tst x) (concat y x))\n         )\n       )\n     )\n   ))", "problem": 85, "user": "5274eb56e4b03e8d9a4a74bb"}, {"code": "(fn myps [x] \n  (if (empty? x)\n    #{#{}}\n    (let [ps2 (myps (set (rest x)))\n          n (first x)]\n      (into ps2 (map #(conj % n) ps2)))))", "problem": 85, "user": "51dd9370e4b0c33a4e1da40c"}, {"code": "(fn myPowerSet\n  [coll]\n  (let [addAllToSet (fn [oldSet collVals] \n                      (map #(into #{%} oldSet) collVals))]\n    (loop [res (addAllToSet #{} coll) i 0]\n      (if (= i (count coll))\n        (conj (set res) #{})\n        (recur (set (mapcat #(addAllToSet % coll) res)) (inc i))))))", "problem": 85, "user": "509a25b7e4b0efbae1fbc0a8"}, {"code": "(fn [s]\n  (let [c (count s) ]\n    (letfn [(bit-seq [n] (lazy-seq (cons (bit-and n 1) (bit-seq (quot n 2)))))]\n      (set\n       (map (fn [n]\n              (set\n               (remove nil? (map #(when (= %2 1) %) s (take c (bit-seq n))))))\n            (range (Math/pow 2 c)))))))", "problem": 85, "user": "519ef784e4b087743fad2198"}, {"code": "(fn power-set\n  ([s] (power-set #{} #{s}))\n  ([result s]\n     (if (some empty? s)\n       (clojure.set/union result s)\n       (power-set (clojure.set/union result s)\n                  (apply clojure.set/union\n                         (map\n                          (fn [x] (set (map (comp set (partial disj x)) x)))\n                          s))))))", "problem": 85, "user": "4f3e5e87e4b0e243712b1f83"}, {"code": "(fn [s]\n  (let [choose (fn [s _] (into #{} (mapcat (fn [s] (map #(disj s %) s)) s)))]\n    (into #{} (apply concat (reductions choose (list s) (range (count s)))))))", "problem": 85, "user": "5078d366e4b08327cd804a5b"}, {"code": "(fn power-set[s]\n  (set (reduce #(concat %1 (map (fn [i] (set (conj i %2))) %1)) #{#{}} s))\n)", "problem": 85, "user": "5272d4b7e4b03e8d9a4a7453"}, {"code": "(fn powerset [set]\n   (let [add-to-every\n         (fn [x sets]\n           (into #{} (for [s sets]\n                       (conj s x))))]\n     (if (empty? set)\n       #{set}\n       (let [x (first set)\n             power (powerset (disj set x))]\n         (clojure.set/union\n           power\n           (add-to-every x power))))))", "problem": 85, "user": "4f35b2ace4b0e243712b1ec5"}, {"code": "reduce (fn [s e] (into s (map #(conj % e) s))) #{#{}}", "problem": 85, "user": "528e64b7e4b0239c8a67aedd"}, {"code": "(fn power [s]\n  (if (empty? s)\n    #{#{}}\n    (let [f (first s)\n          r (disj s f)\n          p (power r)]\n      (clojure.set/union p (map #(conj % f) p)))))", "problem": 85, "user": "526439a4e4b03e8d9a4a70cc"}, {"code": "(fn [s]\n  (let [len (bit-shift-left 1 (count s))\n        m (zipmap (range) (vec s))]\n    (set \n     (map \n      (fn [i] (set (vals (filter #(bit-test i (% 0)) m))))\n      (range len)))))", "problem": 85, "user": "51e38568e4b0c611d6113e43"}, {"code": "(fn powerset [xs]\n  (if (empty? xs) #{#{}}\n    (clojure.set/union (powerset (next xs))\n                       (map #(conj % (first xs)) (powerset (next xs))))))", "problem": 85, "user": "52606318e4b03e8d9a4a7036"}, {"code": "(fn power-set[colls]\n  (reduce #(into %1 (map (fn[i](conj i %2)) %1) ) \n          #{#{}} \n          colls))", "problem": 85, "user": "5273562ae4b03e8d9a4a7479"}, {"code": "(fn [s]\n  (reduce\n   (fn [c e]\n     (into c (map #(conj % e) c)))\n   #{#{}}\n   s))", "problem": 85, "user": "52753740e4b03e8d9a4a74c1"}, {"code": "(fn super [x]\n  (reduce (fn [x y]\n            (clojure.set/union x (set (flatten (for [x' x] [(clojure.set/union x' #{y})\n                                                            #{y}]))))\n            ) #{#{}} x)\n       )", "problem": 85, "user": "52140b53e4b0961f15ac4d7e"}, {"code": "(fn [s]\n  (reduce (fn [ps x]\n            (reduce (fn [ps s]\n                      (conj ps (conj s x)))\n                    ps\n                    ps))\n          #{#{}}\n          s))", "problem": 85, "user": "52a1acb2e4b04e0c58e87bdb"}, {"code": "(fn [x ] ( set (reduce #(concat %1 (set (map (fn [i] (conj i %2 ) ) %1 ))) #{#{}} x )))", "problem": 85, "user": "518c5236e4b087e178201de0"}, {"code": "(fn powset [s]\n   (set (reduce (fn [pows e] (concat pows (map (fn [extend] (conj extend e)) pows)))\n                #{#{}} s)))", "problem": 85, "user": "529ce629e4b04e0c58e87b6e"}, {"code": "(fn [a_set]\n  (let [_listAll (fn [a_set r n](set (filter #(= n (count %))  (map #(set (flatten [%])) (if (= 1 n)(for [s a_set]s) (for [rs r s a_set] [(concat rs [s])]))) )))]\n  (set (loop [r #{#{}} len (count a_set) n 1 pr (_listAll a_set #{} n)]\n     (if (> n len) r\n      (recur (concat r pr) len (inc n) (_listAll a_set pr (inc n)))\n     )\n  )))\n)", "problem": 85, "user": "522eba30e4b01cdb292c5f0e"}, {"code": "(fn [items] \n  (reduce\n    (fn [s i] \n      (into s (map #(conj % i) s)))\n    #{#{}} items))", "problem": 85, "user": "528652fbe4b0239c8a67ae14"}, {"code": "(fn p-set\n    [s]\n    (let [ret (into #{} (map #(set (list %)) s))\n          f (fn [acc p]\n              (if (empty? p) (conj acc #{})\n                (recur\n                  (into acc\n                    (map #(into % (list (first p))) acc)) (rest p))))]\n      (f ret s)))", "problem": 85, "user": "5273e006e4b03e8d9a4a7495"}, {"code": "#(reduce\n  (fn [acc x] (into acc (for [s acc] (conj s x))))\n  #{#{}}\n  %)", "problem": 85, "user": "4ef77edb535dced4c769f254"}, {"code": "(fn power-set [s]\n  (if (empty? s)\n    #{#{}}\n    (let [[x & xs] (vec s)]\n      (let [p1 (power-set xs)\n            p2 (map #(conj % x) p1)]\n        (into p1 p2)))))", "problem": 85, "user": "52afbc69e4b0c58976d9acc0"}, {"code": "(fn powerset [s]\n  (if (empty? s)\n    #{#{}}\n    (set (let [f (first s)\n               ps (powerset (rest s))]\n           (concat ps (map #(conj % f) ps))))))", "problem": 85, "user": "4ee8b9c9535d93acb0a66884"}, {"code": "(fn [st]\n  (letfn [(expand [[a b]]\n            (when (seq b) (cons [(conj a (first b)) (rest b)] (expand [a (rest b)]))))\n          (combos [n s]\n            (if (zero? n) (list [[] s]) (mapcat expand (combos (dec n) s))))\n          (combinations [n s]\n            (map first (combos n s)))\n          (partitions [s] (mapcat #(combinations % s) (range (inc (count s)))))]\n    (->> st partitions (map set) set)))", "problem": 85, "user": "50645e12e4b007509339a58a"}, {"code": "(fn [coll] \n  (loop [k (count coll) a #{#{}}]\n    (if (zero? k)\n      a\n      (recur \n        (dec k) \n        (set (mapcat identity (for [x (conj (map #(set [%]) coll) #{})] (map #(clojure.set/union % x) a))))))))", "problem": 85, "user": "52b43468e4b0c58976d9ad1b"}, {"code": "(fn ps [s]\n  (if (empty? s) #{#{}}\n    (let [i (first s)\n          r (disj s i)\n          sps (ps r)\n          un clojure.set/union]\n      (un sps (set (map #(un #{i} %) sps))))))", "problem": 85, "user": "5267d9bde4b03e8d9a4a7188"}, {"code": "(fn ccc [s]\n  (case s\n     #{}  #{ #{} }\n    (let [sq (seq s)\n              x (first sq)\n              xs (set (rest sq))\n              prev (ccc xs)]\n          (into prev (for [y prev] (conj y x))) )))", "problem": 85, "user": "52b63875e4b0c58976d9ad41"}, {"code": "(fn [s]\n  (let [\n        f (fn gen [s s1]\n            (if-let [[x & xs] s]\n              (let [s2 (lazy-cat [#{x}] (map (fn [y] (conj y x)) s1) s1)]\n                (lazy-cat s2 (gen xs s2)))\n              [])\n            )\n        ]\n    (set (cons #{} (f (seq s) [#{}])))))", "problem": 85, "user": "5298d3f4e4b02ebb4ef75068"}, {"code": "(fn powerset [s]\n  (reduce #(into % (for [subset %] (conj subset %2))) #{#{}} s))", "problem": 85, "user": "5201ff99e4b0b2e020a18f26"}, {"code": "(fn [s]\n    (let [power-set (fn [f s]\n                      (apply\n                        clojure.set/union\n                        #{s}\n                        (for [e s]\n                          (let [subset (disj s e)]\n                            (f f subset)))))\n          f (memoize power-set)]\n      (f f s)))", "problem": 85, "user": "521b9f92e4b0c4ef0be8304c"}, {"code": "(fn [s]\n      (reduce\n        (fn [acc x]\n          (clojure.set/union\n            acc\n            (set (map #(clojure.set/union #{x} %) acc))))\n        #{#{}} s))", "problem": 85, "user": "52a88c4de4b0c58976d9ac30"}, {"code": "(fn f [x] \n\t(if (empty? x) #{#{}} \n\t\t( if (= 1 (count x)) (hash-set x #{}) \n\t\t\t( let [\n\t\t\t\tv (into [] x)\n\t\t\t\tfr (first v)\n\t\t\t\tr  (rest v)\n\t\t\t\ts  (into #{} r)\n\t\t\t\tss (f s)\n\t\t\t\tss1 (map (fn [w] (conj w fr)) ss)\n\t\t\t\tss2 (into #{} (concat ss ss1))\n\t\t\t\t] ss2\n\t\t\t)\n\t\t) ))", "problem": 85, "user": "5296008fe4b02ebb4ef7502a"}, {"code": "(fn power-set [s]\n  (loop [s s pows #{#{}}]\n    (if (seq s)\n      (recur (rest s) \n             (clojure.set/union pows (set (for [e pows] (conj e (first s))))))\n      pows\n      )\n    )\n  )", "problem": 85, "user": "529a73bde4b02ebb4ef75096"}, {"code": "(fn powerset [s]\n         (if (empty? s) #{#{}}\n             (let [rest-set (powerset (rest s))]\n               (set (concat (map #(conj % (first s)) rest-set)\n                            rest-set)))))", "problem": 85, "user": "5294e44de4b02ebb4ef75016"}, {"code": "(fn f [s]\n  (if (empty? s)\n    #{#{}}\n    (let [g (f (next s))]\n      (clojure.set/union g (map #(conj % (first s)) g)))))", "problem": 85, "user": "4f437751e4b0d7d3c9f3fd20"}, {"code": "(fn powerset [orig]\n    (let [\n        origseq (seq orig)\n        pluck (fn [n]\n            (loop [rv #{} n n p 0]\n                (if (zero? n)\n                    rv\n                    (recur \n                        (if (zero? (rem n 2)) rv (conj rv (nth origseq p)))\n                        (quot n 2)\n                        (inc p)\n                    )\n                )\n            )\n        )\n    ]\n        (into #{}\n            (map #(pluck %) (range (Math/pow 2 (count orig))))\n        )\n    )\n)", "problem": 85, "user": "527ba695e4b03e8d9a4a7596"}, {"code": ";; Say a set S has power set PS.  If an element E is added to S\n;; to create S1, the power set of S1 is PS U Q, where Q contains\n;; the elements of PS, each unioned with E.\n;;\n;; The accumulated power set ps starts with the empty set.\n;; For each input set is element i, more power set elements p\n;; are created by unioning i with each p accumulated so far.\n;;\n(fn [is]\n  (reduce\n    (fn [ps i]\n      (reduce\n        (fn [ps p] \n          (conj ps (conj p i)))\n        ps ps))\n    #{#{}} is))", "problem": 85, "user": "50fbf811e4b0d10d794c19f1"}, {"code": "(fn power-set [coll]\n  (if (not (empty? coll))\n    (let [item1 (first coll)\n          items (power-set (set (next coll)))\n          items2 (map #(conj % item1) items)]\n      (println items items2)\n      (reduce conj items items2))\n    #{#{}}))", "problem": 85, "user": "52a55adee4b0c58976d9abe7"}, {"code": ";(fn power-set\n;  [s]\n;  (let [expt (fn  [x y]\n;               (apply * (repeat y x)))\n;        bits (fn [n s] (take s\n;                             (map\n;                              (fn [i] (bit-and 0x01 i))\n;                              (iterate\n;                               (fn [i] (bit-shift-right i 1))\n;                               n))))\n;        size (int (expt 2 (count s)))\n;        mask (map #(bits % (count s)) (range size))\n;        apply-mask (fn [a b] (if (= 1 a) (hash-set b) #{}))\n;        combine-with-mask #(map apply-mask % %2)\n;        s-masked (map combine-with-mask mask (repeat size s))]\n;    (set (map #(reduce clojure.set/union %) s-masked))))\n\n(fn e [s]\n  \"This is what I wanted to do but way more concise\"\n  (reduce\n   (fn [r i]\n     (conj r\n           (set\n            (keep-indexed\n             #(when (bit-test i %1) %2) s))))\n   #{#{}}\n   (range  1 (bit-shift-left 1 (count s)))))", "problem": 85, "user": "524f4256e4b0541d1855b808"}, {"code": "(fn [v]\n(letfn [(f [a c] \n  (if (empty? c)\n    a\n    (let [y (first c)\n          b (into a \n                  (for [x a]\n                    (conj x y)))]\n      (f b (rest c)))))] \n  (f #{#{}} v)))", "problem": 85, "user": "4ffa8affe4b0678c553fc3bd"}, {"code": "(fn ps [s]\n  (if-let [es (seq s)]\n    (let [r (ps (rest es))]\n      (into r (map #(conj % (first es)) r)))\n    #{#{}}))", "problem": 85, "user": "527cd633e4b0757a1b17136f"}, {"code": "(fn power-sets [s]\n  (if (empty? s)\n    #{#{}}\n    (let [element-list (apply list s)\n          one-element (first element-list)\n          power-sets-of-others (power-sets (set (rest element-list)))]\n      (clojure.set/union power-sets-of-others\n                         (set (map #(conj % one-element) \n                                   (apply list power-sets-of-others)))))))", "problem": 85, "user": "529e3a4fe4b04e0c58e87b92"}, {"code": "(fn power-set [s]\n  (reduce (fn [s x]\n            (into s (map #(conj % x) s)))\n          #{#{}} s))", "problem": 85, "user": "4e589bdc535d8a8b8723a295"}, {"code": "(fn powerset [ls]\n  (if (empty? ls) #{#{}}\n      (clojure.set/union (powerset (next ls))\n                         (set (map #(conj % (first ls)) (powerset (next ls)))))))", "problem": 85, "user": "52a09e05e4b04e0c58e87bc9"}, {"code": "(fn power-set [s]\n  (letfn [\n          \n          (sp-set [s] (reduce \n                       \n                       (fn [a x]\n                         (conj a (disj s x)))\n\n                       #{} s))\n          \n\n          ]\n\n    (conj (loop [a #{} s #{s}]\n            (let [[ar,rr] (reduce (fn [[a,ns] x]\n                                    (let [r (sp-set x)]\n                                      [(into a r), (into ns r)]))\n\n                                  [a,#{}] s)]\n              (if (= rr #{})\n                ar\n                (recur ar rr)))) s)\n    ))", "problem": 85, "user": "515bbcd9e4b0388ca8ca1521"}, {"code": "(fn [s]\n  (reduce \n    (fn [init e] \n      (set (concat init (map #(conj % e) init) [#{e}])))\n    #{#{}} s))", "problem": 85, "user": "51929214e4b08962174cf74c"}, {"code": "(fn [s] (set (reduce (fn [a b] (mapcat #(identity #{% (conj % b)}) a)) [#{}] s)))", "problem": 85, "user": "52c1bd29e4b07a9af579236a"}, {"code": "(fn [s]\n          (reduce #(into % (for [subset %] (conj subset %2))) #{#{}} s))", "problem": 85, "user": "51424cc8e4b0b50abeb46b34"}, {"code": "(fn [s]\n  (loop [s s acc #{#{}}]\n    (if (empty? s)\n      acc\n      (recur (rest s) (into acc (for [os acc] (conj os (first s))))))))", "problem": 85, "user": "52ba43d0e4b07a9af57922cd"}, {"code": "(fn [s]\n  (reduce (fn [p e] (clojure.set/union p\n                           (reduce #(conj %1 (conj %2 e)) #{} p)))\n          #{#{}}\n          s))", "problem": 85, "user": "52976262e4b02ebb4ef75041"}, {"code": "reduce (fn [r x] (into r (map #(conj % x) r))) #{#{}}", "problem": 85, "user": "52bf29fde4b07a9af579232e"}, {"code": "(fn powerset [s] \n\n   (if (empty? s) #{s} \n\n     (let [elements     (into [] s)\n           num-subsets  (bit-shift-left 2 (dec (count elements)))\n           nth-subset   (fn [n] (into #{}  (for [i (range (count elements)) :when (bit-test n i)] (nth elements i))))]\n\n       (into #{} (for [i (range num-subsets)] (nth-subset i))))))", "problem": 85, "user": "51264447e4b05d10e3e39601"}, {"code": "(fn __ [coll]\n  ((fn dfs [l r]\n     (cond\n       (empty? l) #{r}\n       :else (apply merge (dfs (rest l) r) (dfs (rest l) (merge r (first l))))))\n    coll #{}))", "problem": 85, "user": "52828298e4b0757a1b17145b"}, {"code": "(fn [s]\n  (loop [ss #{s} n (count s)]\n    (if (zero? n)\n      ss\n      (recur\n       (into #{s} (mapcat (fn [z] (map #(disj z %) z)) ss))\n       (dec n) ))))", "problem": 85, "user": "4ea365e2535d7eef308072c5"}, {"code": "(fn power-set [a-set]\n  (reduce\n    (fn [res elem]\n      (clojure.set/union res\n        (map #(clojure.set/union %1 #{elem})\n          res)\n        )\n      )\n      #{#{}}\n    a-set\n    ))", "problem": 85, "user": "5094057fe4b097f48cc38593"}, {"code": "(fn [s]\n  (set (reduce (fn [acc x]\n                 (concat \n                  acc\n                  (map (fn [acc-x] (conj acc-x x)) acc)))\n               #{#{}} s)))", "problem": 85, "user": "51a97f7ae4b08d8ec191b827"}, {"code": "(fn f [a] (if (empty? a) #{#{}} (let [b (f (rest a))] (apply conj b (map #(conj % (first a)) b)))))", "problem": 85, "user": "52c6a0abe4b0c2d177d62111"}, {"code": "(fn [s] (reduce (fn [p x] (into p (map #(conj % x) p))) #{#{}} s))", "problem": 85, "user": "52b453b0e4b0c58976d9ad21"}, {"code": "(fn power [s]\n  (if (empty? s)\n    #{s}\n    (let\n      [e (first s)\n       remainder (disj s e)\n       p (power remainder)]\n      (clojure.set/union p (set (map #(conj % e) p))))))", "problem": 85, "user": "4f03641a535dcb61093f6a9b"}, {"code": "(fn [s]\n  (if (empty? s)\n    #{#{}}\n    (set\n      (map (fn [x]\n             (->> (Integer/toBinaryString x)\n                  (.toCharArray)\n                  (reverse)\n                  (#(concat % (repeat \\0)))\n                  (map vector s)\n                  (filter (comp (partial = \\1) second))\n                  (map first)\n                  (set)))\n           (range (Math/pow 2 (count s)))))))", "problem": 85, "user": "50d8de3fe4b01f0871336e72"}, {"code": "(fn [s]\n  (let\n    [n (count s)\n     b (map\n        #(map (partial bit-test %) (range n))\n        (range (Math/pow 2 n)))\n     l (seq s)]\n    (into\n     #{}\n     (map\n      #(into\n        #{}\n        (keep-indexed\n         (fn [i x] (if x (nth l i)))\n         %))\n      b))))", "problem": 85, "user": "519136e9e4b0f8ef0be96c01"}, {"code": "(fn [s]\n  (reduce\n    (fn [s e] (into s (map #(conj % e) s)))\n    #{#{}} s))", "problem": 85, "user": "5256627ce4b0541d1855ba1a"}, {"code": "(fn soln [s]\n  (if (empty? s)\n    #{#{}}\n    (let [subset (soln (rest s))]\n      (into subset (map #(conj % (first s)) subset)))))", "problem": 85, "user": "4e80aa10535db62dc21a62b1"}, {"code": "(fn [s]\n  (letfn [(ss-from [idx values]\n            (let [bits (range (count values))]\n              (reduce (fn [ss bit]\n                        (let [value (nth values bit)\n                              value-mask (int (Math/pow 2 bit))\n                              value-flag (bit-and idx value-mask)]\n                          (if (zero? value-flag)\n                            ss\n                            (conj ss value))))\n                      #{}\n                      bits)))]\n    \n    (let [values (vec s)\n          ss-count (int (Math/pow 2 (count values)))\n          ss-indices (range ss-count)]\n      (reduce (fn [pset idx]\n                (conj pset (ss-from idx values)))\n              #{}\n              ss-indices))))", "problem": 85, "user": "5236b6bce4b05f3be1c7c8fe"}, {"code": "(fn power-set [coll]\n  (if (empty? coll)\n    #{#{}}\n    (let [pset (power-set (rest coll))]\n      (clojure.set/union\n       pset\n       (map #(conj % (first coll)) pset)\n       )\n      )\n    )\n  )", "problem": 85, "user": "52e59ca5e4b09f7907dd1464"}, {"code": "(fn power-set [s] (reduce (fn [ps item] (reduce #(conj %1 (conj %2 item))\n                                                  ps\n                                                  ps))\n                            #{#{}}\n                            s))", "problem": 85, "user": "52aad30ce4b0c58976d9ac6d"}, {"code": "(fn [xs]\n  (letfn [(fn85 ([r s]\n                   (if (seq s)\n                     (concat (fn85 r (rest s)) (fn85 (cons (first s) r) (rest s)))\n                     (list r))))]\n    (into #{}  (map (partial into #{}) (fn85 '() (into '() xs))))))", "problem": 85, "user": "4e3a9dae535deb9a81d77f4a"}, {"code": "(fn power-set [a-set]\n   (loop [start-set #{#{}} a-seq (seq a-set)]\n     (let [f (first a-seq) r (rest a-seq)\n\t\t\tset-slice (map #(conj % f) start-set)\n\t\t\t]\n\t\t\t(if f\n\t\t\t\t(recur (into start-set set-slice) r)\n\t\t\t\tstart-set\n\t\t\t)\n\t )\n   )\n)", "problem": 85, "user": "52763696e4b03e8d9a4a74d7"}, {"code": "(fn power-set [s]\n  (if (empty? s)\n    #{#{}}\n    (let [without-fs (power-set (rest s))]\n      (into #{}\n        (concat\n          without-fs\n          (map #(set (cons (first s) %)) without-fs))))))", "problem": 85, "user": "52dd6cc8e4b09f7907dd13e2"}, {"code": "(fn[x](reduce (fn[a b](reduce #(conj %1 (conj %2 b))  a a))  #{#{}} x))", "problem": 85, "user": "52bbd09ee4b07a9af57922ee"}, {"code": "(fn i [m]\n  (if (empty? m) #{(set m)}\n      (clojure.set/union (i (rest m)) (map #(conj % (first m)) (i (rest m))))))", "problem": 85, "user": "52c25645e4b07a9af579237d"}, {"code": "(fn [parent-set]\n  (-> (->> (reduce (fn [coll el]\n                     (concat coll (map (partial concat #{el}) coll)))\n                   ['()]\n                   parent-set)\n           (map set))\n      (set)))", "problem": 85, "user": "51ab4082e4b04e3dc0c27b31"}, {"code": "(fn powerset [s] (if (empty? s) #{#{}} (clojure.set/union (powerset (disj s (first s))) (map #(conj % (first s)) (powerset (disj s (first s)))))))", "problem": 85, "user": "52f10094e4b05e3f0be25ee8"}, {"code": "(fn [s]\n    (set (reduce (fn [init i]\n              (concat init (map #(conj % i) init)))\n            #{#{}} s)))", "problem": 85, "user": "52e3e6a8e4b09f7907dd1448"}, {"code": "(fn ps [s]\n  (if (empty? s)\n    #{ #{} }\n    (set\n     (let [sofar (ps (rest s))\n           el (first s)]\n       (concat sofar (map #(conj % el) sofar))))))", "problem": 85, "user": "52b405e1e4b0c58976d9ad15"}, {"code": "(fn power [st]\n  (letfn [(add [st elem]\n            (clojure.set/union\n             st (set (map (fn [e] (conj e elem)) st))))]\n    (reduce (fn [acc e] (add acc e)) #{#{}} st)))", "problem": 85, "user": "52f8f4d1e4b047fd55836fde"}, {"code": "(fn [s] (let [vs (vec s) nn (count s) n (Math/pow 2 nn)]\n\t(loop [i 0 r #{}]\n\t  (if (< i n)\n\t    (recur (inc i) (conj r (->> (take nn (concat (reverse (Integer/toBinaryString i)) (repeat \\0)))\n\t\t\t\t       (interleave vs)\n\t\t\t\t       (partition 2)\n\t\t\t\t       (filter #(= \\1 (second %)))\n\t\t\t\t       (map first)\n\t\t\t\t       set)))\n\t    r))))", "problem": 85, "user": "4ef9c8f9535dced4c769f26b"}, {"code": "(fn pow [s]\n  (letfn [(add-to-each [e S]\n                       (into #{} (map #(conj % e) S)))]\n\n    (if (empty? s)\n      #{#{}}\n      (let [e (first s)\n            T (disj s e)\n            powT (pow T)]\n        (clojure.set/union powT\n                           (add-to-each e powT))))))", "problem": 85, "user": "52d3f666e4b09f7907dd1327"}, {"code": "(fn p [s]\n  (if (seq s)\n    (let [pivot (first s)\n          resp-parcial (p (disj s pivot))]\n      (clojure.set/union #{s}\n                         resp-parcial\n                         (set (map #(conj % pivot) resp-parcial))))\n    #{#{}}))", "problem": 85, "user": "52c8758be4b0c2d177d62135"}, {"code": "(fn pow [s] \n  (if (empty? s) \n    #{#{}}\n    (let [ a (first s) res (disj s a) p (pow res) pn (for [i p] (conj i a))]\n      (set (concat p pn)))))", "problem": 85, "user": "5300aa1de4b0d8b024fd3710"}, {"code": "#(reduce (fn [s l] (into s (for [t s] (conj t l)))) #{#{}} %)", "problem": 85, "user": "51ad244fe4b09397d510977f"}, {"code": "(fn powerset [ls]\n  (if (empty? ls) #{#{}}\n      (clojure.set/union (powerset (next ls))\n        (map #(conj % (first ls)) (powerset (next ls))))))", "problem": 85, "user": "52fcfeeee4b047fd55837027"}, {"code": "(fn powerset [s]\n  \"Returns the powerset of a given set.\"\n  (if (seq s)\n    (let [head (first s)\n          tail (rest s)\n          without-head (powerset tail)]\n      (into without-head\n            (map #(conj % head)\n                 without-head)))\n    #{#{}}))", "problem": 85, "user": "530578ede4b0d8b024fd3760"}, {"code": "(fn power-set-mk [setv]\n  (letfn ([combine [s k n]\n    (if (= n (count s)) k\n        (let [countset\n          (set (for [t (remove #(> n (count %)) k) x (remove t s)]\n            (conj t x)))]\n          (combine s (into k countset) (inc n))))])\n    (combine setv #{#{}} 0)))", "problem": 85, "user": "52f818a6e4b047fd55836fcc"}, {"code": "(fn powerset [xs]\n\t(let [pwr (fn [b p] (reduce * (take p (repeat b))))\n\t\t\t\txsv (vec xs)\n\t\t\t\tbits (count xs)\n\t\t\t\tlen (pwr 2 bits)\n\t\t\t\tactive (fn [n] (set (map xsv (filter (comp not nil?) (map-indexed #(when (bit-test n %2) %1) (range bits))))))]\n\t(set (map active (range len))))\n\t)", "problem": 85, "user": "52ffb7f2e4b0d8b024fd370b"}, {"code": "(fn powerset [s]\n  (if (empty? s) (set [#{}])\n    (let [smaller (powerset (rest s))\n          elem (first s)]\n      (->> smaller\n           (map (partial cons elem))\n           (concat smaller)\n           (map set)\n           set))))", "problem": 85, "user": "504e108ce4b078edc5f593b3"}, {"code": "(fn [s] (set (reduce #(concat %1 (map (fn [i] (set (conj i %2))) %1)) #{#{}} s)))", "problem": 85, "user": "5307e4ece4b02e82168697a9"}, {"code": "(fn ps [s]\n  (letfn [(expand\n            [[a b]]\n            (when-not\n                (empty? b)\n              (cons\n               [(conj a (first b))\n                (rest b)]\n               (expand [a (rest b)]))))\n          (combos\n            [n s]        \n            (if (zero? n)\n              (list [[] s])\n              (mapcat\n               expand\n               (combos (dec n) s))))\n          (partialflatten [c]\n            (filter #(and (coll? %) (not-any? coll? %))\n                    (tree-seq coll? seq c)))]\n       (set (map set (partialflatten (for [i (range (inc (count s)))]\n                      (map first (combos i s))\n                      ))))))", "problem": 85, "user": "5301157ae4b0d8b024fd3717"}, {"code": "reduce (fn [s a]\n  (clojure.set/union\n   s\n   (set (map #(clojure.set/union #{a} %) s))))\n  #{#{}}", "problem": 85, "user": "529b44afe4b02ebb4ef7509d"}, {"code": "(fn power-set [s]\n  (if (empty? s)\n    #{#{}}\n    (let [head (first s)\n          next-power-set (power-set (disj s head))]\n      (clojure.set/union next-power-set (map #(conj % head) next-power-set)))))", "problem": 85, "user": "5310e7aee4b08068f379ecdc"}, {"code": "(fn power-set [xs]\n   (if (empty? xs)\n     #{ #{} }\n     (let [[x & xs] (seq xs)\n           p (power-set xs)]\n       (clojure.set/union p (map (partial clojure.set/union #{x}) p)))))", "problem": 85, "user": "52dc2bc8e4b09f7907dd13ca"}, {"code": "(fn ps [xs]\n  (if (empty? xs)\n    #{#{}}\n    (let [hd (first xs)\n          ys (ps (rest xs))]\n      (clojure.set/union ys (map #(conj % hd) ys))\n    )\n  )\n)", "problem": 85, "user": "5323a414e4b09d4e7a9b54d1"}, {"code": "(fn powerset [s]\n  (or (when-first [x s]\n        (let [next-ps (powerset (disj s x))]\n          (->> next-ps\n               (concat (map #(conj % x) next-ps))\n               set)))\n      #{#{}}))", "problem": 85, "user": "5326c5f7e4b09d4e7a9b54f2"}, {"code": "(fn [x]\n  (into #{}\n    (for [n (range 0 (bit-shift-left 1 (count x)))]       \n      (into #{}\n        (filter #(bit-test n (.indexOf (vec x) %)) x)\n      )\n    )  \n  )      \n)", "problem": 85, "user": "5176afd2e4b085adf681d889"}, {"code": "(fn power-set [s]\n  (reduce\n    (fn [coll new]\n      (into coll \n            (set (map #(conj % new) coll)))) #{#{}} s))", "problem": 85, "user": "531c0619e4b08068f379ed98"}, {"code": "(fn create-power-set [s]\n  (let [create-set (fn [s code]\n                     (let [v (vec s)\n                           r (range (count code))\n                           code2 (vec (map #(-> % str Integer/parseInt) (seq code)))]\n                       (into #{} (for [i r :when (= 1 (code2 i))] (v i)))))\n        c (count s)\n        fp (if (> c 0) (str \"%0\" c \"d\") \"%d\")\n        combinations (int (Math/pow 2 c))\n        decimals (range combinations)\n        binaries (map #(Integer/toBinaryString %) decimals)\n        binaries2 (map #(format fp (Integer/parseInt %)) binaries)]\n    (into #{} (for [x binaries2] (create-set s x)))\n    ))", "problem": 85, "user": "52cf084ce4b07d0d72b27399"}, {"code": "(fn power \n  ([s] (set (power #{} s)))\n  ([base s] (if-let [[head & more] (seq s)]\n              (concat (power base more) (power (conj base head) more))\n              [base])))", "problem": 85, "user": "532347dde4b09d4e7a9b54cc"}, {"code": "(fn [a] \n  (into #{} \n        (reduce (fn [s i] \n                  (concat s (map #(conj % i) s))) \n                [#{}] \n                (into '() a))))", "problem": 85, "user": "532418f3e4b09d4e7a9b54d8"}, {"code": "(fn combinations [ls]\n  (if (empty? ls)\n    #{#{}}\n    (let [n (next ls)\n          com (combinations n)]\n      (clojure.set/union com (map #(conj % (first ls)) com)))))", "problem": 85, "user": "5125029de4b0ce9225d2ed3e"}, {"code": "(fn [s] \n  (reduce (fn [x y] (set (concat x (map #(set (concat #{y} %)) x)))) \n          #{#{}} s))", "problem": 85, "user": "530cb5b8e4b02e82168697e0"}, {"code": "(fn [x]\n  (loop [s x, pow #{#{}}]\n    (if (empty? s) pow\n        (recur (rest s) (reduce #(conj %1 (conj %2 (first s))) pow pow)))))", "problem": 85, "user": "53300924e4b019098a6f8b55"}, {"code": "(fn powerset [ls]\n  (if (empty? ls) #{#{}}\n    (let [r (powerset (rest ls))]\n      (clojure.set/union r (map #(conj % (first ls)) r)))))", "problem": 85, "user": "531f1e63e4b08068f379edc2"}, {"code": "(fn \ud835\udcab[s]\n  (set (if (seq s)\n        (let [r (\ud835\udcab (next s))]\n          `(~@r ~@(map #(conj %(first s)) r)))\n        [#{}])))", "problem": 85, "user": "5336a339e4b0e30313ee6c7d"}, {"code": "(fn powerset [ls]\n  (if (empty? ls) #{#{}}\n      (clojure.set/union (powerset (next ls))\n        (map #(conj % (first ls)) (powerset (next ls))))))", "problem": 85, "user": "533ab9abe4b0e30313ee6cbf"}, {"code": "(fn [s]\n  (reduce (fn [x y] (into x (map #(conj % y) x)))\n          #{#{}} s))", "problem": 85, "user": "5300158ae4b0d8b024fd370f"}, {"code": "(fn [c]\n  (reduce #(into % (for [x %]\n                     (conj x %2)))\n          #{#{}}\n          c))", "problem": 85, "user": "509e62a8e4b08df8156e9e2e"}, {"code": "(fn [s]\n  (letfn [(combine [a x]\n                   (conj (into a (map #(conj % x) a)) #{x}))]\n    (conj (reduce combine #{} s) #{})))", "problem": 85, "user": "506d5e4ce4b0a302964c5493"}, {"code": "(fn [coll]\n  (into #{}\n        (reduce (fn [l x] \n                  (into #{} \n                        (concat l (map #(conj % x) l))))\n                #{#{}}\n                coll)))", "problem": 85, "user": "51696ee7e4b03f62cda68ce8"}, {"code": "(fn [s]\n  ((fn [l res]\n     (if (empty? l) (into #{} res)\n       (recur (rest l) (concat res (map #(conj % (first l)) res)))))\n   s '(#{})))", "problem": 85, "user": "51da631be4b02ceefd947766"}, {"code": "(fn powerset [xs]\n  (into #{}\n        (if-let [h (first xs)]\n          (for [x (powerset (rest xs))\n                y [x (conj x h)]]\n            y)\n          [#{}])))", "problem": 85, "user": "52d2ca1ce4b099d49816f0b4"}, {"code": "(fn power-set [xs]\n  (if-let [[x & xs] (seq xs)]\n    (let [ps (power-set xs)]\n      (clojure.set/union ps\n        (map #(conj % x) ps)))\n    #{#{}}))", "problem": 85, "user": "532ab0bde4b09d4e7a9b5527"}, {"code": "(fn power-set [S]\n  (if (empty? S)\n    #{#{}}\n    (let [e (first S)\n          T (disj S e)]\n      (clojure.set/union (power-set T)\n                         (set (map #(conj % e) (power-set T)))))))", "problem": 85, "user": "5054c853e4b0b1b9d1860eb3"}, {"code": "(fn [s]\n  (loop [i (count s) r #{#{}}]\n    (if (= i 0)\n      r\n      (recur (dec i) (set (concat r (mapcat (fn [x] (map #(conj x %) (apply disj s x))) r)))))))", "problem": 85, "user": "53468f6ce4b084c2834f4a3f"}, {"code": "(fn [s]\n   (reduce (fn [cum-pow-set e]\n             (into cum-pow-set (map #(conj % e) cum-pow-set)))\n           #{#{}} s))", "problem": 85, "user": "53224d45e4b09d4e7a9b54c0"}, {"code": "reduce\n#(set (apply concat (for [k %] [k (conj k %2)])))\n #{#{}}", "problem": 85, "user": "53460d02e4b084c2834f4a39"}, {"code": "(fn f [s]\n  (if (empty? s)\n    #{#{}}\n    (set (concat (map #(conj % (first s)) (f (next s))) (f (next s))))))", "problem": 85, "user": "5349ac2be4b084c2834f4a67"}, {"code": "#(set\n  (map\n   (fn [x]\n     (set\n      (for [b (range (count %))\n            :when (pos? (bit-and 1 (bit-shift-right x b)))]\n        (nth (seq %) b))))\n   (range (bit-shift-left 1 (count %)))))", "problem": 85, "user": "4e7dfab0535db169f9c796f9"}, {"code": "(fn power-set [s]\n  (let [f (fn [acc e] (concat acc (map #(set (concat #{e} %)) acc)))]\n    (set (reduce f #{#{}} s))))", "problem": 85, "user": "50fc299ee4b0d10d794c19f2"}, {"code": "(letfn [(f [e t] (map #(conj % e) t))]\n  (fn p [s]\n    (if (empty? s) #{s}\n        (let [e (first s)\n              t (clojure.set/difference s #{e})]\n          (clojure.set/union (p t) (f e (p t)))))))", "problem": 85, "user": "52d1e364e4b0d9f9285948e7"}, {"code": "(fn p [s]\n   (if (seq s)\n     (let [f (first s)\n           r (p (rest s))]\n       (into r (map #(conj % f) r)))\n      #{#{}}))", "problem": 85, "user": "5175533fe4b0dea9bbfba575"}, {"code": "reduce (fn [y z] (into y (map #(conj % z) y))) #{#{}}", "problem": 85, "user": "526a7025e4b03e8d9a4a722a"}, {"code": "(fn [cs]\n    (if (empty? cs)\n        #{#{}}\n        (loop [r #{#{} cs} n 0]\n            (if (= (dec n) (count cs))\n                r\n                (recur (let [t (filter #(= n (count %)) r)]\n                           (set (concat \n                                   r\n                                   (for [a t\n                                         b cs] (conj a b)))))\n                       (inc n))))))", "problem": 85, "user": "528a3e14e4b0239c8a67ae72"}, {"code": "(fn [a] \n  (letfn [(subsets [s] \n            (cond (empty? s) '(())\n                  :else (let [f (first s)\n                              ss (subsets (next s))]\n                          (concat ss (map #(conj % f) ss)))))]\n    (into #{} (map set (subsets (seq a))))))", "problem": 85, "user": "5341b141e4b00652c8746ecf"}, {"code": "(fn [s]\n  (letfn [(exp2 [n] (reduce * (repeat n 2)))\n          (subs-n \n           ([n s] (subs-n #{} n (vec s)))\n           ([acc n [x & xs]]\n            (if (zero? n)\n              acc\n              (if (zero? (mod n 2))\n                (recur acc (quot n 2) xs)\n                (recur (conj acc x) (quot n 2) xs)))))]\n    (set (map #(subs-n % s) (range (exp2 (count s)))))))", "problem": 85, "user": "52dd4fb4e4b09f7907dd13df"}, {"code": "(fn [s]\n  (set (reduce #(concat %1\n                        (map (fn [i]\n                               (set (conj i %2)))\n                             %1))\n               #{#{}}\n               s)))", "problem": 85, "user": "531d34cfe4b08068f379edac"}, {"code": "(fn [s]\n  (loop [ss #{#{}}]\n    (if (contains? ss s)\n      ss\n      (recur (into #{#{}} (for [x s y ss] (conj y x)))))))", "problem": 85, "user": "53244c9de4b09d4e7a9b54db"}, {"code": "(fn ps [s] (reduce (fn [a x] (set (concat a (map #(set (concat #{x} %)) a)))) #{#{}} s))", "problem": 85, "user": "52e17e66e4b09f7907dd1423"}, {"code": "(fn f [s]\n  (if (empty? s)\n    #{#{}}\n    (set\n     (loop [t (rest s)\n            h (first s)\n            r #{#{} #{h}}]\n       (if (empty? t)\n         r\n         (recur (rest t)\n                h\n                (let [b (f t)]\n                  (concat r\n                          b\n                          (map #(conj % h) b)))))))))", "problem": 85, "user": "535d910ae4b04ce2eb3ed2c5"}, {"code": "#(reduce (fn [a b]\n           (set (concat a (map (fn [c] (conj c b)) a))))\n         #{#{}}\n         %)", "problem": 85, "user": "50ae0d24e4b0a40c9cfb08ce"}, {"code": "(fn powerset [ls]\n  (if (empty? ls) #{#{}}\n      (into #{} (map #(into #{} %) (clojure.set/union (powerset (next ls))\n              (map #(conj % (first ls)) (powerset (next ls))))))))", "problem": 85, "user": "52f3af46e4b05e3f0be25f14"}, {"code": "(fn power-set\n  [s]\n  (if (empty? s)\n    #{#{}}\n    (let [atoms (into #{} (map (fn [e] #{e}) s))]\n      (loop [res #{s}\n             c (count s)]\n        (if (= c 1)\n          (clojure.set/union res atoms #{#{}})\n            (recur (clojure.set/union res\n                   (into #{} (flatten\n                               (map (fn [supers]\n                                     (map (fn [e] (clojure.set/difference supers e))\n                                          atoms))\n                                    (filter #(= (inc c) (count %)) res)))))\n                 (dec c)))))))", "problem": 85, "user": "5348cab4e4b084c2834f4a5e"}, {"code": "(fn [x]\n\t(loop \n\t\t[result #{} cur [#{}]]\n\t\t(if (= (count (first cur)) (count x))\n\t\t\t(into result cur)\n\t\t\t(recur \n\t\t\t\t(into result cur)\n\t\t\t\t(set (for [c cur x (remove c x)]\n\t\t\t\t\t(conj c x)))\n\t\t\t)\n\t\t)\n\t)\n)", "problem": 85, "user": "52bf6946e4b07a9af5792334"}, {"code": "(fn [s]\n  (reduce (fn [r v] (set (concat r (for [i r] (set (conj i v))))))\n            #{#{}} s))", "problem": 85, "user": "515ffbfbe4b0e2be8aa20bdd"}, {"code": "(fn ps [ls]\n  (if (empty? ls) #{#{}}\n      (clojure.set/union (ps (next ls))\n        (map #(conj % (first ls)) (ps (next ls))))))", "problem": 85, "user": "52fb64b7e4b047fd55837009"}, {"code": "(fn [s]\n    (loop [result (into #{} [#{} s])\n           l (into () s)]\n      ;;(println :result result :l l)\n      (if (empty? l)\n        result\n        (recur \n         (let [i (first l)\n               r2 (conj result #{i})]\n           ;;(println :i i)\n           (into #{} (concat (into #{} (map #(conj % i) result)) r2)))\n         (rest l)))))", "problem": 85, "user": "53487737e4b084c2834f4a59"}, {"code": "(fn [coll]\n  (let [pow2 (fn [n] (bit-shift-left 1 n))\n        bitnote (fn bitnote\n                  ([x] (bitnote x 0))\n                  ([x i]\n                   (if (< x (pow2 i)) []\n                                      (if (pos? (bit-and x (pow2 i)))\n                                        (cons i (bitnote x (inc i)))\n                                        (bitnote x (inc i))))))\n        subsets (fn [coll]\n                  (let [coll' (vec coll)\n                        fetch (fn [x] (let [x' (bitnote x)]\n                                        (map (partial get coll') x')))]\n                    (->> coll'\n                         count\n                         pow2\n                         (range 0)\n                         (map (comp set fetch)))))]\n    (set (subsets coll))))", "problem": 85, "user": "536d83cee4b0fc7073fd6e5e"}, {"code": "(fn power-set [xs]\n    (reduce (fn [ps x] (into ps (map #(conj % x) ps)))\n            #{#{}}\n            xs))", "problem": 85, "user": "5370ef22e4b0fc7073fd6ea0"}, {"code": "reduce (fn [a e] (apply conj a #{e} (map #(conj % e) a))) #{#{}}", "problem": 85, "user": "536e0930e4b0fc7073fd6e66"}, {"code": "(fn [base] (let [pow  (fn [x n]\n  \t\t\t\t\t\t(reduce * (repeat n x)))\n                 select (fn [n]\n                         \t(loop [v base n n rv ()]\n                              (if (empty? v)\n                                (set rv)\n                                (if (bit-test n 0)\n                                  (recur (rest v) (bit-shift-right n 1) (cons (first v) rv))\n                                  (recur (rest v) (bit-shift-right n 1) rv)))))]\n             (into #{} (map select (range (pow 2 (count base)))))))", "problem": 85, "user": "534f13b2e4b084c2834f4ac4"}, {"code": "(fn [superset]\n  (apply\n   clojure.set/union\n   (take (inc (count superset))\n         (iterate\n          (fn [sets]\n            (set\n             (mapcat (fn [s] (map #(disj s %)\n                                 s))\n                     sets)))\n          #{superset}))))", "problem": 85, "user": "5225271fe4b01819a2de42f9"}, {"code": "(fn [aset]  \n  (->> (loop [;; count down from the number of elements in aset\n              counter (count aset)\n              ;; acc start as list of an empty set\n              acc #{#{}}]\n         ;; stop and return acc \n         (if (zero? counter)\n           acc\n           (recur (dec counter) (set (concat acc\n                                             ;; Add to acc, all possible one element addition to acc elements\n                                             ;; like (#{1} #{:a}) -> (#{1 1} #{:a 1} #{1 :a} #{:a :a})\n                                             ;; duplications are removed\n                                             (flatten (for [x aset]\n                                                        (map #(conj % x) acc))))))))\n       ;; Put elements after the recursion into a set\n       (into #{},  )))", "problem": 85, "user": "53415755e4b00652c8746ecd"}, {"code": "(fn [xs]\n  (reduce (fn [acc x]\n            (into acc (map #(conj % x) acc))) \n          #{#{}} \n          xs))", "problem": 85, "user": "536ca4bde4b0fc7073fd6e49"}, {"code": "(fn powerset [x]\n     (if (seq x)\n       (into (powerset (set (rest x))) (set (for [y (vector (first x))\n                                                  z (powerset (set (rest x)))]\n                                              (conj z y))))\n              #{#{}}\n       ))", "problem": 85, "user": "532727bae4b09d4e7a9b54fa"}, {"code": "(fn p [s]\n  (if-let [e (first s)]\n    (let [b (p (disj s e))]\n      (into b (map #(conj % e) b)))\n    #{#{}}))", "problem": 85, "user": "514d8084e4b019235f6c0588"}, {"code": "(fn powerset [xs]\n  (if (empty? xs) (hash-set xs)\n      ( let [x (first xs)\n             ys (powerset (set (rest xs)))]\n        (clojure.set/union ys\n                           (set (map #(conj % x) ys))))))", "problem": 85, "user": "53691dc7e4b0243289761e97"}, {"code": "(fn power-set [the-set]\n  (let [combinations (fn [seqn, accum]\n                       (if (empty? seqn)\n                         accum\n                         (let [head (first seqn)\n                               tail (rest seqn)\n                               old-combs accum\n                               new-combs (map #(conj % head) old-combs)]\n                           (recur tail (concat old-combs new-combs)))))]\n    (->> (combinations the-set #{[]})\n         (map set)\n         (set))))", "problem": 85, "user": "53834ed3e4b06839e8705edb"}, {"code": "(fn [s]\n  (let [elements (seq s)]\n  \t(set\n     (->>\n      (range (int (Math/pow 2 (count s))))\n      (map (fn [n]\n             (->>\n              (map (fn [i e] [i e]) (iterate #(quot % 2) n) elements)\n              (filter (fn [[i _]] (zero? (mod i 2))))\n              (map second)\n              set)))))))", "problem": 85, "user": "53800d99e4b06839e8705ebd"}, {"code": "(fn [s]\n  (loop [i 0 res #{#{}}]\n    (if (= i (count s))\n      res\n      (recur (inc i) \n             (into #{} (concat res (for [x res y s]\n                                     (conj x y))))))))", "problem": 85, "user": "5370f8ede4b0fc7073fd6ea2"}, {"code": "(fn [set*]\n    (set ((fn power-set* [current rest]\n            (if (empty? rest) #{current}\n                (let [e (first rest)]\n                  (lazy-cat\n                   (power-set* current (disj rest e))\n                   (power-set* (conj current e) (disj rest e)))))) #{} set*)))", "problem": 85, "user": "51c3c6a6e4b0851ac09658f8"}, {"code": "(fn [s]\n  (reduce (fn [powset el]\n            (into powset\n                  (map #(conj % el) powset)))\n          #{#{}}\n          s))", "problem": 85, "user": "524b0645e4b09eba1c0223bf"}, {"code": "(fn t6 [coll]\n  (letfn [(combs [n]\n            (if (zero? n)\n              [[]]\n              (for [smaller (combs (dec n))\n                    b [true false]]\n                (cons b smaller))))\n          (filter_vector [coll1 coll2]\n            (for [[value pos] (map vector coll2 (range))\n                  :when (nth coll1 pos)]\n              value))]\n    (set (for [l (combs (count coll))]\n      (set (filter_vector l coll))))))", "problem": 85, "user": "5046f909e4b03b02161376b5"}, {"code": "(fn [xs]\n  (letfn [(filter-mask [xs mask]\n            (->> (map list xs mask)\n                 (filter (fn [[_ b]] (= 1 b)))\n                 (map first)))\n          (binary-range [x]\n            (->> (range 0 (Math/pow 2 x))\n                 (map (partial clojure.pprint/cl-format nil \"~v,'0B\" x))\n                 (map (fn [s] map #(Integer/parseInt %) s))))\n          (digits [x] (map #(Integer/parseInt %) (map str (str x))))]\n    (->> (binary-range (count xs))\n         (map digits)\n         (map #(filter-mask xs %))\n         (map set)\n         (set))))", "problem": 85, "user": "5312cdaae4b08068f379ed03"}, {"code": "(letfn [(P [s]\n           (if (empty? s) [#{}]\n             (let [ps (P (rest s))]\n               (concat ps\n                       (map #(conj % (first s)) ps)))))]\n  (fn [s]\n    (into #{} (P s))))", "problem": 85, "user": "51a4416ae4b0def3c5c5868c"}, {"code": "(fn subsets [s]\n  (if (empty? s)\n    #{#{}}\n    (let [ss (subsets (rest s))]\n      (set (concat ss (map #(set (conj % (first s))) ss))))))", "problem": 85, "user": "4ddb696b535d02782fcbe9fa"}, {"code": "(fn power-set [s]\n  (loop [s s ret #{#{}}]\n    (if (empty? s)\n      ret\n      (recur (rest s) (apply conj ret (map #(conj % (first s)) ret))))))", "problem": 85, "user": "4f849f76e4b033992c121c36"}, {"code": "(fn [elems]\n    (let [pick \n      (fn [items x]\n        (set\n           (for [i (range (count items))\n                :let [flag (bit-test x i)]\n                :when flag]\n          (items i))\n        )\n      )]\n      (loop [i 0 result #{}]\n        (if (>= i (.pow (BigInteger. \"2\") (count elems)))\n          result\n          (recur (inc i) (conj result (pick (vec elems) i)))\n        )\n      )\n    )\n)", "problem": 85, "user": "51f09f3de4b0274c496158d7"}, {"code": "(fn [S] (reduce (fn [s e] (into s (map #(conj % e) s))) #{#{}} S))", "problem": 85, "user": "536973e5e4b0243289761e9e"}, {"code": "(fn power-set[s]\n  (letfn [(combine [a b n]\n                   (let [all-sets (for [i a j b] (set (concat i j)))]\n    (set (filter #(= n (count %)) all-sets))))\n          (combine-all [s n]\n                   (concat s \n                           (combine \n                            (filter #(= 1 (count %)) s)\n                            (filter #(= (dec n) (count %)) s)\n                            n)))]\n    (cond \n     (empty? s) #{s} \n     (empty? (rest s)) #{s #{}} \n     :else (set \n            (conj \n            (reduce (fn [sum n] (combine-all sum n))\n                   (set (map #(set (list %)) s))\n                   (range 2 (count s)))\n            s\n            #{})))))", "problem": 85, "user": "5374adc3e4b06d7f452d9e27"}, {"code": "(fn [s]\n  (let [n (count s)\n        v (vec s)\n        pad-left (fn [n i s]\n                   (concat (repeat (- n (count s)) i) s))]\n    (->> (range (int (Math/pow 2 n)))\n         (map #(Integer/toBinaryString %))\n         seq\n         (map #(map (fn [b] (if (= b \\0) false true)) %))\n         (map (partial pad-left n false))\n         (map #(map-indexed vector %))\n         (map #(->> % (filter (fn [[idx itm]] itm)) (map (fn [[idx _]] idx))))\n         (map #(reduce (fn [s idx] (conj s (v idx))) #{} %))\n         set)))", "problem": 85, "user": "5392b849e4b0b51d73faaeb1"}, {"code": "(fn [s]\n  (loop [s s\n         accum #{#{}}]\n    (if (empty? s)\n      accum\n      (let [current-element (first s)\n            remaining-elements (rest s)\n            new-elements (reduce #(conj %1 (conj %2 current-element)) #{} accum)\n            new-set (clojure.set/union accum new-elements)]\n        (recur remaining-elements new-set)))))", "problem": 85, "user": "53527551e4b084c2834f4af0"}, {"code": "(fn power-set [s]\n  (if (empty? s) #{#{}}\n    (let [rest-power-set (power-set (rest s))]\n      (clojure.set/union\n       (set (map #(conj % (first s)) rest-power-set))\n       rest-power-set))))", "problem": 85, "user": "530bf87ee4b02e82168697d5"}, {"code": "(fn power-set [s]\n  (loop [ps #{#{}} s s]\n    (if-let [[f & r] (seq s)]\n      (recur (into ps (map #(conj % f) ps)) r)\n      ps)))", "problem": 85, "user": "539a2901e4b0b51d73faaf0f"}, {"code": "(fn power-set [s]\n  ;; if empty set,then #{}\n  (if (not (empty? s))\n    (let [rest-set (power-set (rest s))]\n      (set(concat (map #(conj % (first s)) rest-set)\n              rest-set)))\n      #{#{}}))", "problem": 85, "user": "536f871de4b0fc7073fd6e7f"}, {"code": "(fn ss [s]\n  (if (empty? s) \n    \t#{#{}}\n        (let [rr (ss (rest s))] \n          (into rr (map #(conj % (first s)) rr)))))", "problem": 85, "user": "526a3412e4b03e8d9a4a721e"}, {"code": "(fn [coll] (reduce (fn [a b] (set (concat a (map #(set (concat #{b} %)) a)))) #{#{}} coll))", "problem": 85, "user": "53a1b5c8e4b0ca733b9744c1"}, {"code": "(fn gen [all]\n  (if (= 0 (count all))\n    #{#{}}\n    (loop [n 1 subsets #{#{}}]\n      (if (== n (count all))\n        (conj subsets all)\n        (recur (inc n)\n               (clojure.set/union\n                subsets\n                (set\n                 (for [elem all subset subsets]\n                   (conj subset elem)))))))))", "problem": 85, "user": "51a768e0e4b0da5f497bde84"}, {"code": "(fn power-set\n  [coll]\n  (if (= 0 (count coll)) #{#{}}\n      (let [curr (first coll)\n            remaining (power-set (rest coll))]\n        (into remaining (map #(into % #{curr}) remaining)))))", "problem": 85, "user": "536e5055e4b0fc7073fd6e6b"}, {"problem": 85, "code": "(fn power-set\n  ([s] (power-set s #{#{}}))\n  ([s acc]\n   (if (empty? s)\n     acc\n     (recur (disj s (first s))\n            (into acc (map #(conj % (first s)) acc))))))", "user": "52951156e4b02ebb4ef7501b"}, {"problem": 85, "code": "(fn subsets [us] \n  (let [xs (vec us)]\n    (if (empty? xs) #{#{}} \n      (let [ys (-> xs rest set subsets vec)] \n        (set (into ys (map #(conj % (first xs)) ys)))))))", "user": "53976599e4b0b51d73faaeea"}, {"problem": 85, "code": "(fn \n  [s]\n  ; for input set size n, iterating 0..2^n-1, using 1 bits to select\n  ; Using this approach so we could (if we didn't have to return a set)\n  ; have a lazy sequence and be scalable\n  (let [v (vec s)\n        n (.size v)\n        f (fn [x] (loop [a #{}\n                         v v\n                         x x]\n                    (if (= 0 x)\n                      a\n                      (let [a' (if (= 1 (mod x 2))\n                                 (conj a (peek v))\n                                 a)\n                            v' (pop v)\n                            x' (quot x 2)]\n                        (recur a' v' x')))))]\n    (set (map f (range (.pow (BigInteger. \"2\") n))))))", "user": "52dfc89be4b09f7907dd1405"}, {"problem": 85, "code": "(fn power-set [xs]\n\t(letfn [(gen-next [xs acc]\n\t\t\t\t(if (contains? acc xs) \n\t\t\t\t\t(conj acc #{})\n\t\t\t\t\t(recur xs (set (for [x xs ys acc] (conj ys x))))))]\n\t(gen-next xs #{#{}})))", "user": "52e657e4e4b09f7907dd1472"}, {"problem": 85, "code": "(fn [s]\n  (let [c (Math/pow 2 (count s))]\n    (reduce\n      (fn [p b]\n        (let [n (format (str \"%0\" (count (Integer/toBinaryString (- c 1))) \"d\")\n                        (Integer/parseInt (Integer/toBinaryString b)))]\n          (conj p (set (map #((apply vector s) (key %))\n                            (filter #(= \\1 (val %)) (zipmap (range (count n)) n)))))))\n      #{}\n      (range c))))", "user": "4ec53f8c535d6d7199dd368b"}, {"problem": 85, "code": "(fn [ xset ]\n   (reduce (fn [ps e]\n               (set (concat ps (map #(conj % e) ps))))\n               (conj #{xset} #{}) \n               xset))", "user": "5398305fe4b0b51d73faaef6"}, {"problem": 85, "code": "(fn ex85-2\n  [s]\n  (set (conj\n        (if (= 0 (count s))\n          nil\n          (let [res (ex85-2 (rest s))]\n            (map #(if (coll? %)\n                    (set %)\n                    (set [%]))\n                 (concat res\n                         [(first s)]\n                         (map #(if (coll? %)\n                                 (conj % (first s))\n                                 (conj [%] (first s)))\n                              res)))))\n        #{})))", "user": "532bce35e4b09d4e7a9b5536"}, {"problem": 85, "code": "(fn powset [aset]\n    (if (empty? aset)\n    #{#{}}\n    (reduce into #{} (map #(list % (conj % (first aset))) (powset (rest aset)))\n    )))\n\n;;  \n;;  (fn [aset] (let [\n;;      items (vec aset) \n;;      f1 #(if (= \\1 %2) %) \n;;      f2 #(nth items %)\n;;      ]\n;;  (->> (range 0 (bit-shift-left 1 (count items))) \n;;       (map #(\n;;                     ->> %\n;;                     Long/toBinaryString\n;;                     reverse\n;;                     (map-indexed f1)\n;;                     (remove nil?)\n;;                     (map f2)\n;;                     set\n;;                     )\n;;            )\n;;         set\n;;         )\n;;       ))\n;;", "user": "5281a445e4b0757a1b17143a"}, {"problem": 85, "code": "(fn [s]\n  (reduce #(reduce (fn [ps sub]\n                     (conj (conj ps sub)\n                           (conj sub %2)))\n                   #{}\n                   %)\n          #{#{}} s))", "user": "4f041de1535dcb61093f6ba5"}, {"problem": 85, "code": "(fn gen-powerset [s]\n  (if-let [f (first s)]\n    (let [smaller (gen-powerset (rest s))]\n      (clojure.set/union smaller (map #(conj % f) smaller))\n      )\n    #{#{}}\n  ))", "user": "5245e320e4b09dbe66b56177"}, {"problem": 85, "code": "(fn power-set [s]\r\n  (let [\r\n        binary-nums (fn [length]\r\n                      \"Generate all binary numbers of a given bit length\"\r\n                      ; start with [0] and [1]\r\n                      (loop [acc [[0] [1]] \r\n                             remaining length]\r\n                        (if (= remaining 1)\r\n                          acc\r\n                          ; double our vector, appending 0 to one half\r\n                          ; and 1 to the other\r\n                          (recur\r\n                           (concat\r\n                             (map #(conj % 0) acc) \r\n                             (map #(conj % 1) acc))\r\n                           (dec remaining)))))\r\n        \r\n        get-binary-nums (fn [s]\r\n                          (binary-nums (count s)))\r\n        apply-binary-num (fn [b s]\r\n                            (loop [b b\r\n                                   s s\r\n                                   acc #{}]\r\n                              (if (empty? b)\r\n                                acc\r\n                                (recur\r\n                                 (rest b)\r\n                                 (rest s)\r\n                                 (if (= 1 (first b))\r\n                                   (conj acc (first s))\r\n                                   acc)))))]\r\n  (if (= #{} s)\r\n    #{#{}}\r\n\r\n    (loop [acc []\r\n           rem (get-binary-nums s)]\r\n      (if (empty? rem)\r\n        (into #{} acc)\r\n        (recur\r\n         (conj acc (apply-binary-num (first rem) s))\r\n         (rest rem)))))))", "user": "53ac4719e4b047364c04445c"}, {"problem": 85, "code": "(fn ps [s]\n  (reduce (fn [s e] (into s (map #(conj % e) s))) #{#{}} s))", "user": "53b39d82e4b047364c0444a6"}, {"problem": 85, "code": "(fn f [s]\n  (if (empty? s)\n    #{#{}}\n    (let [r (f (rest s))]\n      (set (concat r (map #(conj % (first s)) r))))))", "user": "53523ae0e4b084c2834f4aee"}, {"problem": 85, "code": "(fn [s]\n  (set (reduce \n        (fn [r e]\n          (clojure.set/union r #{#{e}} (set (map #(conj % e) r)))) \n        #{#{}} s)))", "user": "537f4652e4b06839e8705eb1"}, {"problem": 85, "code": "(fn [s]\n  (loop [cnt (count s)\n         acc #{s}]\n    (if (zero? cnt)\n      (conj acc #{})\n      (recur (dec cnt)\n             (into acc\n                   (apply concat (map #(map (partial disj %) %)\n                                      ((group-by count acc) cnt))))))))", "user": "53acaf1fe4b047364c04445f"}, {"problem": 85, "code": "(fn powerset [coll]\n  (letfn [(add-to-all [coll item]\n            (into #{#{item}} (into coll (map #(conj % item) coll))))]\n    (into #{#{}} (reduce add-to-all #{} coll))))", "user": "53bf0913e4b0c98a41f5cc99"}, {"problem": 85, "code": "(fn power-set [xs]\n  (loop [ys xs\n         sets #{#{}}]\n    (if (empty? ys) sets\n      (recur (rest ys) (into sets (map #(conj % (first ys)) sets))))))", "user": "53c38b8ce4b00fb29b22127b"}, {"problem": 85, "code": "(fn pset [s]\n  (letfn [ (tfseq [n]\n  (map #(if (= \\1 %) true false)\n       (seq (clojure.pprint/cl-format nil \"~b\" n))))\n           ]\n\n  (let [v  (vec s)\n        l  (count v)\n        mx (int (Math/pow 2 l) )]\n    (loop [n 0\n           acc #{}]\n      (let [mtfseq  (tfseq n)\n            pknum   (- l (count mtfseq))\n            pktfseq (concat (repeat pknum false) mtfseq )\n            ssi (map #(if %1 %2 false) pktfseq v)\n            ss (filter #(if % true false) ssi)\n            ]\n        (if (= mx n)\n          acc\n          (recur (inc n) (conj acc (set ss))))\n        )))) \n  )", "user": "53c1ce3ee4b00fb29b221268"}, {"problem": 85, "code": "(fn [s]\n  (reduce #(into % (map (fn [x] (conj x %2)) %))\n          #{#{}}\n          s))", "user": "533018b2e4b019098a6f8b56"}, {"problem": 85, "code": "(fn power-set [s]\n  (letfn [(pairs [s e]\n                 (set (map #(clojure.set/union % (hash-set e)) s)))]\n    (if (empty? s)\n      #{#{}}\n      (let [el (first s)\n            rst (disj s el)\n            rst-power-set (power-set rst)]\n        (clojure.set/union rst-power-set (pairs rst-power-set el))))))", "user": "52d00832e4b07d0d72b273b4"}, {"problem": 85, "code": "(fn [s]\n  (conj  \n    (reduce #(set (for [x % y %2] (conj x y))) #{#{}} (repeat (count s) s))\n   #{}))", "user": "53b7c21ae4b047364c0444d4"}, {"problem": 85, "code": "(fn pset[p]\n\t(letfn [(first-level-sset[set-of-sets]\n\t\t\t(set\n\t\t\t(mapcat identity \n\t\t\t\t(map (fn[a]\n\t\t\t\t\t(map #(clojure.set/union % a) \n\t\t\t\t\t\tset-of-sets)) set-of-sets)))) \n\t\t\t(psets-helper[s]\n\t\t\t\t(let [currentCnt (int (Math/pow 2 (count s)))]\n\t\t\t\t\t(loop [curs s aggr s cnt currentCnt]\n\t\t\t\t\t\t(if (= cnt 1) aggr\n\t\t\t\t\t\t(let [child-sets (first-level-sset curs) \n\t\t\t\t\t\t\t\tnext-sets (clojure.set/difference child-sets curs)]\t\n\t\t\t\t\t\t(recur next-sets (clojure.set/union aggr next-sets) (dec cnt)))))))]\n \t(psets-helper (into #{#{}} (map #(set [%]) p)))))", "user": "538e29d1e4b0b51d73faae80"}, {"problem": 85, "code": "(fn [coll]\n  (reduce (fn [acc val]\n                (reduce (fn [acc' val']\n                          (if (or (not (empty? val')) (some #{val} val'))\n                            (conj acc' val' (conj val' val))\n                            (conj acc' val' #{val}))) #{} acc)) #{#{}} coll))", "user": "52efd3d9e4b05e3f0be25ed4"}, {"problem": 85, "code": "(fn powerset [s]\n  (let [f (fn pset [col]\n            (if (empty? col)\n              [[]]\n              (let [n (first col), r (pset (rest col))]\n                (concat r (map #(conj % n) r))\n              )\n            )\n          )]\n    (set (map set (f (vec s))))\n  )\n)", "user": "53ca41dae4b00fb29b2212c8"}, {"problem": 85, "code": "(fn power-set [X]\n    (if (empty? X)\n      #{X}\n     (let [others (set (rest X)) choice (first X) union clojure.set/union]\n        (union (power-set others) (map #(conj % choice) (power-set others))))))", "user": "53703287e4b0fc7073fd6e8f"}, {"problem": 85, "code": "(fn [coll]\n    (reduce\n      (fn [acc itm]\n        (clojure.set/union\n          acc\n          (set (map #(conj % itm) acc))))\n      #{#{}} coll))", "user": "538e864ee4b0b51d73faae87"}, {"problem": 85, "code": "(fn [s]\n  (letfn [(all-combos [s]\n            (let [c (count s)]\n              (map #(reverse (take c (reverse (str (reduce str (repeat c 0))\n                                                   (Integer/toBinaryString %)))))\n                   (range (Math/pow 2 c)))))\n\n          (values [s t]\n            (into #{}\n                  (remove (partial = :foo) (map #(if (= \\1 %2) % :foo) s t))))]\n    (into #{} (map #(values s %) (all-combos s)))))", "user": "538e36c7e4b0b51d73faae81"}, {"problem": 85, "code": "(fn [ss]\n   (set\n   (loop [cs #{#{}} ws ss]\n     (do (println cs ws)\n     (if (empty? ws) \n       cs\n       (recur (concat cs (map #(clojure.set/union % (hash-set (first ws))) cs)) (rest ws)))\n     ))\n   ))", "user": "53ca23e3e4b00fb29b2212c6"}, {"problem": 85, "code": "(fn [sets] \n\t(loop [s sets r (conj #{sets} #{})]\n\t(if (empty? s) r\n\t\t(recur (rest s) (into r (set (map #(conj % (first s)) r)))))))", "user": "53e19461e4b0d874e779ae59"}, {"problem": 85, "code": "(fn f [s]\n  (if (empty? s) #{s}\n    (loop [new-set (set (for [x s\n                              y s\n                              :when (not= x y)]\n                          #{x y}))\n           result-set (clojure.set/union #{s #{}} new-set (set (for [x s] #{x})))]\n      (let [a (set (for [x new-set\n                         y s\n                         :when (not (contains? x y))]\n                     (conj x y)))]\n        (if (= a new-set) result-set\n            (recur a (into result-set a)))))))", "user": "53973e7be4b0b51d73faaee6"}, {"problem": 85, "code": "; A powerset corresponds to \"1\"s in the binary strings of elements of [0, 2^|s|)\n(fn [s] (into #{#{}}                                          ;a set of the empty set and\n              (->>(range 0 (Math/pow 2 (count s)))                ;onto  [0, 2^|s|) ...\n                  (map                                            ;... map ...\n                   (fn [i] (into #{}                              ;... this fn returning a set\n                                 (->>(reverse (Integer/toString i 2)) ;reverse unpadded strings \n                                     (map vector s)                   ;zip with elements\n                                     (filter #(= (second %) \\1))      ;keep the 1s\n                                     (map first)                      ;extract the set elements\n                                     )))))))", "user": "53dadf1de4b0e771c30254ad"}, {"problem": 85, "code": "(fn ps [a]\n  (if-let [e (first a)]\n    (let [r (ps (disj a e))]\n      (clojure.set/union (set (map #(conj % e) r)) r))\n    #{#{}}))", "user": "53d78b64e4b0e771c3025466"}, {"problem": 85, "code": "(fn pwr-set [s]\n   (reduce (fn [a i]\n             (->> a\n                  (map #(conj % i))\n                  (into a)))\n           #{#{}} s))", "user": "535eaa73e4b04ce2eb3ed2d4"}, {"problem": 85, "code": "(fn [s] (reduce (fn [s x] (clojure.set/union s (map #(conj % x) s))) #{#{}} s))", "user": "4eea4840535d93acb0a6689b"}, {"problem": 85, "code": "(fn combinations [s]\n  (let [fst (first s)\n        rst (rest s)]\n    (println fst rst)\n    (if (empty? s)\n      #{#{}}\n      (if (empty? rst)\n        #{#{} #{fst}}\n        (set (clojure.set/union (map #(clojure.set/union #{} %) (combinations rst)) (map #(clojure.set/union #{fst} %) (combinations rst))))))))", "user": "53791ab7e4b06839e8705e4d"}, {"problem": 85, "code": "; second attempt...\n(fn [input-set]\n  (reduce\n    (fn [s e] (into s (map #(conj % e) s)))\n    #{#{}}\n    input-set))\n\n; first attempt...\n#_(fn power-set [input-set]\n  (let [conj-bit-and (fn [r n b i]\n                       (if (= b (bit-and b n))\n                         (conj r i)\n                         r))\n        to-bits (fn [n]\n                  (loop [r [] i 0 b 1]\n                    (if (> b n)\n                      r\n                      (recur (conj-bit-and r n b i) (inc i) (* b 2)))))\n        sublist (fn [list mask]\n                  (for [i mask]\n                    (nth list i)))\n        combinations-count (fn\n                             [list-count]\n                             (loop [i 0 b 1]\n                               (if (<= list-count i)\n                                 b\n                                 (recur (inc i) (* b 2)))))\n        input-list (into [] input-set)]\n    (into #{} (for [i (-> input-list count combinations-count range)]\n                (let [mask (to-bits i)]\n                  (into #{} (sublist input-list mask)))))))", "user": "53513d28e4b084c2834f4ae3"}, {"problem": 85, "code": "(fn [s]\n  (loop [q #{s}\n         r #{}]\n    (if-let [f (first q)]\n      (let [n (filter (complement r) (map #(disj f %) f))]\n        (recur \n         (into (rest q) n)\n         (conj r f)))\n      r)))", "user": "53034738e4b0d8b024fd373e"}, {"problem": 85, "code": "(fn ps85 [s]\n    (if (seq s)\n      (let [rs (ps85 (next s))]\n        (into rs (map #(conj % (first s)) rs)))\n      #{#{}}))", "user": "513e8141e4b02b2a3d8235c1"}, {"problem": 85, "code": "(fn p [s] (if (empty? s) \n            #{#{}} \n            (let [h (first s) s2 (p (disj s h))] \n              (into s2 (map #(conj % h) s2)))))", "user": "53b2a7f8e4b047364c04449c"}, {"problem": 85, "code": "(fn [s]\n   (set (reduce #(concat % (map (fn [z] (conj z %2)) %)) #{#{}} s)))", "user": "53ea5307e4b036ad0777e4e2"}, {"problem": 85, "code": "(fn powerset [s]\n  (reduce (fn [a b] (clojure.set/union a (set (map #(conj % b) a)))) #{#{}} s))", "user": "4e8849c5535d8b9bb0147ca4"}, {"problem": 85, "code": "(fn [x] (let [comb (fn comb [x] (if (empty? x) (list #{})\n                       (concat (map #(conj % (first x)) (comb (rest x))) (comb (rest x)))))]\n        (apply hash-set (comb x))))", "user": "50856bd1e4b004985b776e4c"}, {"problem": 85, "code": "(fn power-set [coll]\n  (if (empty? coll)\n    #{#{}}\n    (let [element (first coll)\n          sub1 (power-set (disj coll element))\n          sub2 (map #(conj % element) sub1)]\n      (into sub1 sub2))))", "user": "53dc94c8e4b094d41abdfefc"}, {"problem": 85, "code": "(fn ss [is]\n  (set ((fn hr [s]\n     (if (empty? s)\n       #{#{}}\n      (let [h (first s)\n            t (rest s)]\n        (println \"h\" h \"t\" t)\n        (if (empty? t)\n          #{#{h} #{}}\n          (let[tp (hr t)\n               tph (reduce #(conj %1 (conj %2 h)) #{} tp)]\n            (println \"tp\" tp \"tph\" tph)\n            (concat tp tph))))))\n   is)))", "user": "53f7820be4b0de5c41848560"}, {"problem": 85, "code": "reduce (fn [s x]\n         (into s (set (map #(into % #{x}) s)))) #{#{}}", "user": "53f6d555e4b0db01ade6f9e5"}, {"problem": 85, "code": "(fn [input]\n    (letfn [(binary->subset [aset binary]\n              (let [v (into [] aset)]\n                (->> binary \n                     (map-indexed vector)\n                     (map #(when (not= \\0 (last %)) (nth v (first %))))\n                     (remove nil?)\n                     (into #{}))))\n            (gen-binary [n] \n              (->> n\n                   (Math/pow 2)\n                   (range)\n                   (map #(Integer/toString % 2))\n                   (map #(clojure.pprint/cl-format nil (str \"~\" n \",'0d\") %))))\n            (power-set [aset]\n              (->> aset\n                   (count)\n                   (gen-binary)\n                   (map #(binary->subset aset %))\n                   (into #{})))]\n      (power-set input)))", "user": "504e1abee4b0f6ff3350c45d"}, {"problem": 85, "code": "(fn [s]\n  (reduce \n    (fn [init e] \n      (set (concat init (map #(conj % e) init) [#{e}])))\n    #{#{}} s))", "user": "53f75957e4b0de5c4184855d"}, {"problem": 85, "code": "(fn powerset [items]\n  (if (empty? items)\n    #{#{}}\n    (clojure.set/union (powerset (next items))\n                       (map #(conj % (first items)) (powerset (next items))))))", "user": "53da8fede4b0e771c30254a3"}, {"problem": 85, "code": "(fn peu [x] (let [y (apply list x)] (set (if (empty? y) #{#{}} (let [z (apply list (peu (rest y)))] (clojure.set/union z (map #(clojure.set/union % #{(first y)}) z))) ))))", "user": "53fc8424e4b0de5c418485b3"}, {"problem": 85, "code": "(fn bp4 [set-to-use]\n  (letfn [(bp [n] (map #(str (reduce str (repeat (- n (count %)) \"0\")) %)\n                        (map #(Integer/toBinaryString %) (range 0 (Math/pow 2 n)))))]\n    (let [bitstrings (map #(map char %) (bp (count set-to-use)))] \n      (set\n        (for [bitstring bitstrings]\n          (into #{} (map first (filter #(= \\1 (val %)) (zipmap (into [] set-to-use) bitstring)))))))))", "user": "525c575be4b0cb4875a45d38"}, {"problem": 85, "code": "(fn p[s]\n  (if (empty? s)\n    #{#{}}\n    (let [r (p(rest s)) f (first s)]\n    (set(conj(concat r (map #(set(cons f %)) r)) #{} #{f} )))))", "user": "53ed2fafe4b0d648e757f4c1"}, {"problem": 85, "code": "(fn go [s] \n  (if (empty? s) \n     #{#{}} \n     (let [pt (go (rest s)) ft (set (map #(conj % (first s)) pt))] \n\t    (clojure.set/union ft pt))))", "user": "53fe1c3be4b0de5c418485f2"}, {"problem": 85, "code": "(fn power [x]\n    (if (seq x)\n      (let [head (first x)\n            others (power (disj x head))]        \n        (clojure.set/union\n         others\n         (map #(conj % head) others)))\n      #{#{}})\n)", "user": "53ed6976e4b0d648e757f4c4"}, {"problem": 85, "code": "(fn [s]\n  (set (reduce #(concat %1 (map (fn [i] (set (conj i %2))) %1)) #{#{}} s)))", "user": "52bc6cb2e4b07a9af57922f5"}, {"problem": 85, "code": "(fn subsets [s]\n  (if-not (empty? s)\n    (into #{} (mapcat #(vector % (conj % (first s))) (subsets (rest s))))\n    #{#{}}))", "user": "506ba58be4b0eda3100c090b"}, {"problem": 85, "code": "(fn ! [s]\n  (if (empty? s) #{s}\n    (let [fe (first s)\n          res (set (rest s))\n          a1 (! res)\n          a2 (set (map #(conj % fe) a1))\n          ]\n      (clojure.set/union a1 a2)\n     )))", "user": "52faec2ee4b047fd55837004"}, {"problem": 85, "code": "(fn powerset [s]\n  (let [n (count s)\n        idx-map (zipmap (range n) s)]\n    (letfn [(corresponding-subset [binstring]\n              (into #{} (map idx-map\n                             (map first\n                                  (filter\n                                   #(= 1 (second %))\n                                   (map-indexed vector (binseq binstring)))))))\n\n            (expt [base pow]\n              (reduce * (repeat pow base)))\n\n            (binseq [binstring]\n              (map #(if (= % \\1) 1 0) (seq binstring)))]\n\n      (into #{}\n            (map corresponding-subset\n                 (map (partial clojure.pprint/cl-format nil \"~v,'0B\" n)\n                      (range (expt 2 n))))))))", "user": "53fd66a4e4b0de5c418485e3"}, {"problem": 85, "code": "(fn [my-set]\n  (loop [accum #{#{}}\n         my-left my-set]\n    (if (seq my-left)\n      (let [val (first my-left)]\n        (recur (concat accum (map #(set (concat #{val} %)) accum)) (rest my-left)))\n      (set accum))))", "user": "540d7dd1e4b0addc1aec6713"}, {"problem": 85, "code": "(fn [s]\n  (letfn [(tails [coll]\n                 (take (count coll) (iterate rest coll)))\n          (combs [c]\n                 (cons '() (cond\n                             (empty? c) []\n                             (= 1 (count c)) [c]\n                             :else (mapcat (fn [[x & xs]]\n                                             (map #(cons x %)\n                                                  (combs xs))) (tails c)))))]\n    (set (map set (combs (seq s))))))", "user": "51780bfce4b0f89a8f53839c"}, {"problem": 85, "code": "(fn [s]\n  (letfn [(pwrrecur [s res]\n                  (if (contains? res s) (conj res #{})\n                    (letfn [(addset [v s] (set (map #(conj v %) s)))]\n                      (pwrrecur s (reduce #(clojure.set/union % (addset %2 s)) #{} res)))))]\n    (pwrrecur s #{#{}})))", "user": "53e9a15be4b036ad0777e4ae"}, {"problem": 85, "code": "(fn power-set\n  [base]\n  (if (empty? base)\n    (conj #{} base)\n    (let [sub-pw-set (power-set (set (rest base)))]\n      (->> sub-pw-set\n           (map #(conj % (first base)))\n           (clojure.set/union sub-pw-set)))))", "user": "5401aefbe4b0df28a13c62c7"}, {"problem": 85, "code": "(fn power-set [coll] \n  (if (empty? coll) \n    #{#{}}\n    (let [e (first coll),\n          pt (power-set (remove (partial = e) (set coll)))] \n      (set (lazy-cat pt (map #(conj % e) pt))))))", "user": "53fcdd1ae4b0de5c418485dd"}, {"problem": 85, "code": "(fn [s] (set (conj (reduce (fn [result cada] (clojure.set/union #{#{cada}} result (map #(conj % cada) result))) #{} s)\n                   #{})))", "user": "4ff4bed0e4b0678c553fc35f"}, {"problem": 85, "code": "(fn [c]\n   (reduce\n    (fn [result m]\n      (into result (reduce\n                    #(into %1 (list (into %2 (list m))))\n                    #{}\n                    result)))\n    #{#{}}\n    c))", "user": "52fac708e4b047fd55836fff"}, {"problem": 85, "code": "(fn [s]\r\n  (reduce (fn [acc v]\r\n            (clojure.set/union \r\n            acc\r\n            (map #(conj % v) acc)))\r\n          #{#{}}\r\n          s))", "user": "53c649d3e4b00fb29b221297"}, {"problem": 85, "code": "(fn [ss]\n  (set (reduce \n         (fn [retval s]\n           (concat retval (set (map #(conj % s) retval))))\n         #{#{}} ss)))", "user": "541096bde4b01498b1a719b2"}, {"problem": 85, "code": "(fn p [s]\n  (let [h (first s)\n        t (map #(drop % s) (range 1 (inc (count s))))\n        u (map p t)]\n    (if (empty? s)\n      #{#{}}\n      (into #{}\n            (conj (concat\n                   (apply concat\n                          (map (fn [x]\n                                 (map #(conj % h)\n                                      x))\n                               u))\n                   (apply concat u))\n                  #{})))))", "user": "53fb5256e4b0de5c4184857f"}, {"problem": 85, "code": "#((fn f [c n]\n     (if (= n 0) c\n       (f (into c\n            (for [x % a c] (conj a x)))\n              (- n 1)))) #{#{}} (count %))", "user": "53500869e4b084c2834f4ad3"}, {"problem": 85, "code": "(fn [sets] \n\t(loop [s sets r (conj #{sets} #{})]\n      (if (empty? s) r\n        (recur (rest s) (into r (set (map #(conj % (first s)) r)))))))", "user": "541619e8e4b01498b1a719f9"}, {"problem": 85, "code": "(fn powerset [s]\n    (letfn [(combine [acc x]\n              (conj (into acc (map #(conj % x) acc)) #{x}))]\n      (conj (reduce combine #{} s) #{})))", "user": "53e76bb2e4b036ad0777e47d"}, {"problem": 85, "code": "(fn p-set [x]\n  (if (empty? x) #{#{}}\n      (let [p' (p-set (rest x))]\n        (set (map #(set %) (concat (list x) (map #(cons (first x) %) p') p'))))))", "user": "53ff8c31e4b0de5c41848603"}, {"problem": 85, "code": "(fn mypower [arg]\n  (let [a (into [] arg)\n        prezeros (apply str (repeat (Math/pow (count a) 2) \"0\"))]\n    (if (= arg #{})\n      #{#{}}\n    (into #{} (map #(into #{} %) (for [i (range (Math/pow 2 (count a)))]\n      (map #(first %) (remove #(= \"0\" (str (second %))) \n                              (apply assoc {} (interleave a (into [] (reverse (str prezeros (Integer/toString i 2))))))))))))))", "user": "52747090e4b03e8d9a4a74a5"}, {"problem": 85, "code": "(fn powerset [coll]\n  (if (empty? coll) #{#{}}\n    (clojure.set/union (powerset (next coll))\n                       (map #(conj % (first coll)) (powerset (next coll))))))", "user": "52c672e2e4b0c2d177d6210e"}, {"problem": 85, "code": "(fn [s]\n      (into #{} (map first (apply concat (reductions (fn [ss _] (distinct (mapcat (fn [[in out]] (map (fn [o] [(conj in o) (disj out o)]) out)) ss))) #{[#{} s]} s)))))", "user": "5310e968e4b08068f379ecdd"}, {"problem": 85, "code": "(fn [s]\n  (reduce \n    (fn [x y] \n      (set\n       (concat x\n               (map #(conj % y) x)\n               [#{y}])))\n    #{#{}} s))", "user": "54246fcce4b01498b1a71aed"}, {"problem": 85, "code": "reduce\n  (fn [a x] (into a (map #(conj % x) a)))\n  #{#{}}", "user": "53a01fb1e4b0ca733b9744a6"}, {"problem": 85, "code": "(fn [st]\n  (let [plus\n        (fn [ss e]\n          (map #(conj % e) ss))\n        combine\n        (fn [s1 s2]\n          (reduce conj s1 s2))\n        ]\n    (reduce\n     (fn [ss e]\n       (combine ss (plus ss e)))\n     #{#{}}\n     st))\n  )", "user": "53ef7f77e4b0742d9025b0ce"}, {"problem": 85, "code": "(fn [s]\n  (set (reduce #(concat %1 (map (fn [i] (set (conj i %2))) %1)) #{#{}} s)))", "user": "51b8d3d5e4b050a1176cd69d"}, {"problem": 85, "code": "(fn mm [s]\n  (if (= nil (first s))\n    #{#{}}\n    (let [sub-s (mm (rest s))\n          fst-s (first s)\n          sup-s (set (map #(conj % fst-s) sub-s))]\n      (set (concat sub-s sup-s)))))", "user": "535f0cbde4b04ce2eb3ed2d9"}, {"problem": 85, "code": "(fn allset\n [set1]\n (into #{}\n (map #(into #{} %)\n (reduce (fn add1 [sofar elem]\n  (clojure.set/union (into #{} (map #(cons elem %) sofar)) sofar))\n  #{#{}}\n  (into [] set1)\n  ))))", "user": "53d6b266e4b0e771c3025459"}, {"problem": 85, "code": "(fn ps [s]\n  (reduce (fn [s e] (into s (map #(conj % e) s))) #{#{}} s))", "user": "542c22bde4b0dad94371f29e"}, {"problem": 85, "code": "(fn power-set [xs] \n  (let [bits (for [i (range 0 (bit-shift-left 1 (count xs)))] \n               (for [j (range 0 (count xs))] (= (bit-and (bit-shift-right i j) 1) 1)))\n        lx (vec xs)\n        filter-by-list (fn [xs filter-list] \n                         (->> (partition 2 (interleave xs filter-list))\n                           (filter #(true? (second %)))\n                           (map first)))]\n    (set (for [bi bits] (set (filter-by-list xs bi))))))", "user": "52ee0de4e4b05e3f0be25ec1"}, {"problem": 85, "code": "reduce (fn [s e] (into s (map #(conj % e) s))) #{#{}}", "user": "54055aa9e4b0addc1aec6665"}, {"problem": 85, "code": "(fn [s]\n         (-> (reduce (fn [a v]\n                         (concat (conj a #{v})\n                                 (for [x a] (if (coll? x) (conj x v) #{x v}))))\n                       #{} s)\n              (conj #{})\n              set))", "user": "53f592b7e4b0db01ade6f9d0"}, {"problem": 85, "code": "(fn [s]\n(set (reduce #(concat %1 (map (fn [i] (set (conj i %2))) %1)) #{#{}} s)))", "user": "542edb4ae4b0dad94371f2c8"}, {"problem": 85, "code": "(fn [s]\n      (into #{#{}}\n            (map\n              (fn [n]\n                (->> s\n                  (map (fn [x y] [x y]) (map first (rest (iterate (fn [[_ a]] [(mod a 2) (long (/ a 2))]) [0 n]))))\n                  (filter #(pos? (first %)))\n                  (map last)\n                  (into #{})))\n              (range (apply * (repeat (count s) 2))))))", "user": "51e28063e4b08e53a149f0f2"}, {"problem": 85, "code": "(fn pset [s]\n  (cond\n   (empty? s) #{#{}}\n   :else\n    (let [h (first s) t (disj s h)]\n     (into #{}\n     (concat\n         (map #(conj % h) (pset t))\n         (pset t))))))", "user": "54448e84e4b032a45b869393"}, {"problem": 85, "code": "(fn powerset [coll]\n  (reduce\n    (fn [accumSet nextItem]\n      (set\n        (concat\n          (map\n            #(set (concat #{nextItem} %))\n            accumSet)\n          accumSet)\n        ))\n\n    #{#{}}\n    coll))", "user": "53307da1e4b019098a6f8b5e"}, {"problem": 85, "code": "(fn __ [col]  \n  (set \n   (reduce \n    (fn [s1 s2] \n      (concat s1 \n              (map \n               (fn [x] \n                 (set (conj x s2))) \n               s1)))\n    #{#{}} col)))", "user": "53f3a4ace4b0742d9025b0f7"}, {"problem": 85, "code": "(fn [s]\n  (let [ f (fn [x y] (set (concat x (map #(conj % y) x) (vector #{y}))))]\n    (reduce f #{#{}} s)))", "user": "543d5c61e4b032a45b86934d"}, {"problem": 85, "code": "(fn power-set [xs]\n  (let [n (count xs)\n        range-combinations (range (Math/pow 2 n))\n        decimal->binary (partial clojure.pprint/cl-format nil \"~v,'0B\" n)]\n    (set (for [y (map decimal->binary range-combinations)]\n           (->> (map vector y xs)\n                (filter #(= \\1 (first %)))\n                (map #(second %))\n                (set))))))", "user": "52616198e4b03e8d9a4a705e"}, {"problem": 85, "code": "(fn powerset [s]\n  (if (empty? s)\n    #{#{}}\n    (let [powerset-of-rest (powerset (rest s))\n          powersets-with-missing (apply hash-set (map #(set (cons (first s) %)) powerset-of-rest))]\n      (clojure.set/union powerset-of-rest powersets-with-missing))))", "user": "53f891eee4b0de5c4184856d"}, {"problem": 85, "code": "(fn [s]\n(let [bit-filter (fn [items mask]\n(set\n(keep-indexed\n(fn [idx item]\n(if (bit-test mask idx)\nitem))\nitems)))]\n(set (for [mask (range 0 (Math/pow 2 (count s)))]\n(bit-filter s mask)))))", "user": "53d86564e4b0e771c302546b"}, {"problem": 85, "code": "(fn [s]\n  (letfn [(subsets [s]\n                   (if (empty? s) \n                     #{#{}}\n                     (let [t (subsets (rest s))] \n                       (into t (map #(conj % (first s)) t)))))]\n    (subsets s)))", "user": "5457e5f1e4b01be26fd74613"}, {"problem": 85, "code": "(fn power-set [xs]\n  (let [cache (atom {})]\n    (letfn [(power-set* [xs]\n              (or (@cache xs)\n                  (get (swap! cache \n                              (fn [c]\n                                (assoc c xs\n                                       (if (seq xs) (into #{xs} (mapcat #(power-set* (disj xs %)) xs)) #{#{}}))))\n                       xs)))]\n      (power-set* xs))))", "user": "534d1173e4b084c2834f4a98"}, {"problem": 85, "code": "(fn [s]\n  (letfn [(in-out [n i]\n            (reverse\n              (for [j (range n)]\n                (bit-test i j))))\n          (sels [n]\n            (for [i (range (bit-shift-left 1 n))]\n              (in-out n i)))]\n    (into #{}\n          (for [sel (sels (count s))]\n            (into #{}\n                  (for [[inc? item] (map list sel s)\n                        :when inc?]\n                    item))))))", "user": "4ec1b090535dfed6da9c6db5"}, {"problem": 85, "code": "reduce (fn [r e] (into r (map #(conj % e) r))) #{#{}}", "user": "53ce4cd4e4b00fb29b2212ef"}, {"problem": 85, "code": "(fn powerset [ls]\n\t(if-let [[head & tail] (seq ls)] \n\t    (clojure.set/union \n\t       (powerset tail)\n\t       (map #(conj % head) (powerset tail)))\n\t    #{#{}}))", "user": "51aefceee4b09397d5109797"}, {"problem": 85, "code": "(fn p [s]\n  (if (empty? s) #{#{}}\n      (let [r (set (rest s))]\n       (set (concat (p r) (map #(conj % (first s)) (p r)))))))", "user": "5405ae2be4b0addc1aec6671"}, {"problem": 85, "code": "(fn [x] \n   (set (map \n     #((fn [l s]\n       (loop [out [], n l, i 0]\n         (if (= 0 n) \n           (set out)\n           (recur (if (odd? n) (conj out (nth s i)) out)\n                  (unchecked-divide-int n 2) \n                  (inc i)\n     ))))\n     % (vec x))\n     (range (int (Math/pow 2 (count x))))\n)))", "user": "54524afbe4b0e397800069bc"}, {"problem": 85, "code": "(fn [s]\n  (reduce (fn [sets x]\n            (->> sets\n                 (map #(set (concat #{x} %)))\n                 (concat sets)\n                 (set)))\n          #{#{}} s))", "user": "505aa653e4b021387fb89857"}, {"problem": 85, "code": "(fn power-set\n   [s]\n    (letfn [(add-to-set [s i] (into s (map #(conj % i) s)))]\n      (reduce #(add-to-set %1 %2) #{#{}} s)\n    ) \n   )", "user": "545e9cf1e4b01be26fd7467f"}, {"problem": 85, "code": "(fn powerset [a-set]\n  (let [n (Math/pow 2 (count a-set))\n        lst (map-indexed vector a-set)]\n    (into #{} (map (fn [i] (set (map second (filter (fn [[idx val]]\n                                            (bit-test i idx))\n                                          lst))))\n         (range 0 n)))))", "user": "544e9022e4b0e3978000698b"}, {"problem": 85, "code": "(fn P [s] (if (empty? s) #{#{}} (set (let [R (P (disj s (first s)))] (concat R (map #(conj % (first s)) R))))))", "user": "4e8b5cb8535d65386fec211b"}, {"problem": 85, "code": "(fn [s]\n    (letfn [(combine [acc x]\n              (conj (into acc (map #(conj % x) acc)) #{x}))]\n      (conj (reduce combine #{} s) #{})))", "user": "5412646de4b01498b1a719d4"}, {"problem": 85, "code": "(let\n  ;; massively overkill, i could just count in binary t_t...\n  [ps-with-model (fn [s model]\n                       (reduce\n                        (fn [ps m]\n                          (let [v (vec s)]\n                            (conj ps (set (mapv v m)))))\n                        #{}\n                        model))\n       ps (fn ps [s fcache]\n            (if (empty? s)\n              #{#{}}\n              (reduce\n               (fn [acc [e ds]]\n                 (let [psds (if-let [[n model] (find fcache (count ds))]\n                              (ps-with-model ds model)\n                              (ps ds fcache))]\n                   (clojure.set/union acc psds (set (map #(conj % e) psds)))))\n               #{}\n               (for [e s] [e (clojure.set/difference s #{e})]))))]\n   (fn [s]\n     (let [fcache\n           (reduce\n            (fn [fcache i]\n              (assoc fcache i (ps (set (range i)) fcache)))\n            {}\n            (range (count s)))]\n       (ps s fcache))))", "user": "547d8e93e4b0c51c1f4d72f4"}, {"problem": 85, "code": "(fn sub-set [s]\r\n  (if (empty? s)\r\n    #{#{}}\r\n    (into #{}\r\n      (mapcat \r\n        #(list % (into #{} (cons (first s) %)))   \r\n        (sub-set (rest s))))))", "user": "5470699ae4b00cfc9eacc1b6"}, {"problem": 85, "code": "(fn [s]\n  (letfn [(more [x y] (set (concat x (map #(conj % y) x))))]\n    (reduce more #{#{}} s)))", "user": "5478e57de4b0c51c1f4d72c1"}, {"problem": 85, "code": "(fn powerset [coll]\n  (letfn [ (winnow [coll]\n             (into #{} (for [x coll] (set (disj coll x)))))\n           (build [coll]\n             (let [sub (map winnow coll)\n                   comb (reduce into coll sub)]\n               (if (= comb coll)\n                 coll\n                 (recur comb))))]\n    (build #{coll})))", "user": "541f5b37e4b01498b1a71a97"}, {"problem": 85, "code": "(fn [s]\n  (let [v (vec s)]\n    (into #{} (for [i (range (apply * (repeat (count v) 2)))]\n                (into #{} (for [j (range (count v)) :when (bit-test i j)]\n                            (v j)))))))", "user": "5353afa0e4b084c2834f4b03"}, {"problem": 85, "code": "(fn subsets [s]\n        (if (empty? s) #{#{}}\n            (let [x (first s)\n                  subs (subsets (disj s x))]\n              (set (concat [s] subs (map #(conj % x) subs))))))", "user": "502873a8e4b01614d1633ff8"}, {"problem": 85, "code": "(fn [my-set]\n    (loop [result #{#{}}]\n      (if (result my-set)\n        result\n        (let [this-batch \n              (into #{} \n                    (for [set-from-last result\n                          my-item my-set]\n                      (conj set-from-last my-item)))]\n          (recur (apply conj result this-batch))))))", "user": "537bde5de4b06839e8705e73"}, {"problem": 85, "code": "(fn powerset [a-set]\n  (letfn [(powerset-helper [current leftovers]\n            (if (empty? leftovers)\n              (set current)\n              (let [elem (first leftovers)]\n                (powerset-helper (concat current\n                                         (map (fn [x] (conj x elem)) current))\n                                 (rest leftovers)))))]\n    (powerset-helper #{#{}} a-set)))", "user": "540e8d13e4b0addc1aec671e"}, {"problem": 85, "code": "(fn power [xs]\n  (letfn [(combinations [n xs]\n            (if (= 0 n)\n              #{#{}}\n              (let [tails (rest (iterate rest xs))]\n                (set (mapcat\n                      (fn [x tail]\n                        (map #(set (cons x %))\n                             (combinations (dec n) tail)))\n                      xs tails)))))]\n    (->> (range 0 (inc (count xs)))\n         (mapcat (fn [n] (combinations n xs)))\n         (set))))", "user": "547584d9e4b0c51c1f4d729b"}, {"problem": 85, "code": "(fn power-set [lst]\n  (letfn [(f [lst]\n            (if (empty? (rest lst))\n              (list lst ())\n              (let [ps (f (rest lst))]\n                (concat (map #(cons (first lst) %) ps) ps))))]\n    (set (map set (f lst)))))", "user": "546c1f73e4b00cfc9eacc175"}, {"problem": 85, "code": "#(into #{} ((fn powerset [xs]\n  (if-let [x (first xs)]\n    (let [pxs (powerset (next xs))]\n      (mapcat\n        (fn [p]\n          (list (conj p x) p)) pxs)\n      )\n    (list #{})\n    )\n  ) %))", "user": "5488872ee4b0e286459a11d3"}, {"problem": 85, "code": "#(reduce\n  (fn [subsets elem]\n    (into subsets\n          (for [x subsets]\n            (conj x elem)))) #{#{}} %)", "user": "5472d919e4b094393f72dd7b"}, {"problem": 85, "code": "(fn [coll]\n  (reduce (fn [acc e] (into acc (map #(conj % e) acc))) #{#{}} coll))", "user": "5392bfdee4b0b51d73faaeb2"}, {"problem": 85, "code": "(fn [s]\n  (letfn \n    [(indices [l] \n       (map second (filter #(= (first %) 1) (partition 2 (interleave l (iterate inc 0))))))\n     (gen-masks [n] \n       (for [x (range (Math/pow 2 n))] \n         (take n (map #(bit-and 1 %) (iterate #(bit-shift-right % 1) x)))))\n     (apply-mask [m v] \n       (let [idx (indices m)]\n         (set (mapv v idx))))\n     (subsets [s] \n       (let [m (gen-masks (count s)) v (vec s)] \n         (set (for [msk m] (apply-mask msk v)))))]\n    (subsets s)))", "user": "5385e633e4b06839e8705f08"}, {"problem": 85, "code": "(fn ps [s]\n  (reduce (fn [k i] (into k (cons #{i} (map #(merge % i) k)))) #{#{}} s))", "user": "53e745a1e4b036ad0777e479"}, {"problem": 85, "code": "(fn [x]\n  (set\n   (flatten\n\n    (\n     (fn power-set [s]\n       (cond\n         (empty? s) [#{}]\n         :else\n         (let [subset (power-set (rest s))]\n           (concat (map #(set (cons (first s) %)) subset) subset)\n           )))\n     x)\n    ))\n  \n  )", "user": "549c8bbde4b0f3d1d8e70f8c"}, {"problem": 85, "code": "(fn power [s]\n  (if (empty? s) #{#{}}\n      (let [r (power (rest s))]\n         (clojure.set/union r (map #(conj % (first s)) r)))))", "user": "512b07f7e4b078b06821febb"}, {"problem": 85, "code": "(fn [s] (let [c (count s)] (set (for [x (range (Math/pow 2 c))] (set (keep-indexed #(if (bit-test x %1) %2) s))))))", "user": "549c3e0ce4b0f3d1d8e70f87"}, {"problem": 85, "code": "(fn [s]\n  (letfn [(subsets [n items]\n           (cond\n            (= n 0) '(())\n            (empty? items) '()\n            :else (concat (map\n                           #(cons (first items) %)\n                           (subsets (dec n) (rest items)))\n                          (subsets n (rest items)))))]\n    (set\n      (map #(into #{} %)\n           (apply concat \n           (for [x (range (inc (count s)))]\n             (subsets x s)))))))", "user": "54848141e4b0e286459a119e"}, {"problem": 85, "code": "(fn [s]\n  (let [ac (vec s), sz (count ac), cnt (bit-shift-left 1 sz)]\n    (into #{} (for [x (range cnt)] (loop [y 0, a #{}] \n      (if (= y sz) a (recur (inc y) \n        (if (bit-test x y) (conj a (nth ac y)) a))))))))", "user": "53bcdd41e4b0d9a98559a6c0"}, {"problem": 85, "code": "(fn [coll]\n   (letfn [(f [curr x acc]\n             (let [n (conj acc [curr])\n                   e (concat n (map #(conj % curr) acc))]\n               (if-not (first x)\n                 e\n                 (recur (first x) (rest x) e))))]\n     (if (empty? coll)\n       #{#{}}\n       (let [result (set (f (first coll) (rest coll) []))]\n         (set (map set (conj result [])))))))", "user": "53214efbe4b09d4e7a9b54b2"}, {"problem": 85, "code": "#(letfn [\n        (subvecs[v]\n          (into #{} (for [n (range (count v))] (remove (fn[x](= (nth v n) x)) v)))\n        )  \n\n        (power-vec[coll]\n          (loop [n (count coll) c1 [coll] r [coll []]]\n            (if (<= n 1)\n              r\n              (let [c2 (distinct (mapcat subvecs c1))]\n                (recur (dec n) c2 (into r c2))\n              )\n            )\n          )\n        )\n       ]\n\n  (into #{} (map (fn[v](into #{} v)) (power-vec (vec %))))\n)", "user": "545537c1e4b0e397800069dd"}, {"problem": 85, "code": "(fn f [xs]\n   (let [x (first xs)\n         xs (rest xs)]\n     (if-not x\n       #{#{}}\n       (into #{} (for [b [true false]\n                       ys (f xs)]\n                   (if b\n                     (conj ys x)\n                     ys))))))", "user": "50ef4e2be4b0a78662fa2653"}, {"problem": 85, "code": "reduce (fn [s, v] (into s (map #(conj % v) s) ) ) #{#{}}", "user": "54a1d643e4b09f271ff37c50"}, {"problem": 85, "code": "(fn ps [s]\n\t(if (empty? s) #{#{}}\n    \t(set \n    \t\t(let [ns (ps (next s))]\n    \t\t\t(clojure.set/union \n    \t\t\t\tns\n\t\t\t\t\t(map #(conj % (first s)) ns))))))", "user": "536e5b68e4b0fc7073fd6e6d"}, {"problem": 85, "code": "(fn [ss]\n  (loop [s ss\n         p #{#{}}]\n    (if (empty? s)\n      p\n      (recur (rest s) (clojure.set/union p (map #(conj % (first s)) p))))))", "user": "5136f659e4b04059df19f2fd"}, {"problem": 85, "code": "(fn ps [xs]\n  (if-let [[x & xs] (seq xs)]\n    (let [pxs (ps xs)]\n      (->> pxs\n           (map #(conj % x))\n           (concat pxs)\n           set))\n    #{#{}}))", "user": "53dfdf01e4b0d874e779ae46"}, {"problem": 85, "code": "(fn power-set [s]\n  (reduce #(into % (for [subset %]\n                     (conj subset %2))) #{#{}} s))", "user": "542c026ae4b0dad94371f29a"}, {"problem": 85, "code": "#(let [subsets (fn subsets [a-set]\n  (let [rets #{#{} } pairs (partition 2 (interleave a-set (repeat nil)))]\n    (reduce (fn [rs pair]\n              (set\n               (for [r rs,p pair]\n                 (conj r p))))\n            rets pairs)))]\n  (set (for [s (subsets %)]\n         (set (keep identity s)))))", "user": "53b7aa6ce4b047364c0444d1"}, {"problem": 85, "code": "(fn [se] (letfn [(subsets [s] (map #(disj s %) s))]\n            (loop [toProcess (list se) acc #{}]\n              (if (empty? toProcess) acc \n                  (let [f (first toProcess)]\n(prn f)\n                    (if (contains? acc f) \n                      (recur (rest toProcess) acc)\n                      (recur (concat (rest toProcess) (subsets f)) (conj acc f))\n                      )\n                    )\n                  )\n              )\n            )\n   )", "user": "5471f2fbe4b094393f72dd70"}, {"problem": 85, "code": "(fn [l]\n  (set (loop [so-far [#{}]\n         left l\n         ]\n    (if (empty? left)\n      so-far\n      (recur \n        (apply conj so-far \n          (for [s so-far \n                l [(first left)]] \n            (merge s l))) \n        (rest left))\n    )\n  ))\n)", "user": "4fc8f671e4b0ee37620e1840"}, {"problem": 85, "code": "(fn [x]\n  (let [\n     cnt (count x)\n     v-items (vec (reverse x))\n     comb\n   (fn [cnt n]\n(lazy-seq\n   (let [c (vec (cons nil (for [j (range 1 (inc n))] (+ j cnt (- (inc n)))))),\n\t iter-comb\n\t (fn iter-comb [c j]\n\t   (if (> j n)\n      nil\n\t    (let [c (assoc c j (dec (c j)))]\n\t\t   (if (< (c j) j) \n        [c (inc j)]\n\t\t    (loop [c c, j j]\n\t\t     (if (= j 1)\n          [c j]\n\t\t      (recur (assoc c (dec j) (dec (c j))) (dec j)))))))),\n\t step\n\t (fn step [c j]\n\t   (cons (rseq (subvec c 1 (inc n)))\n\t\t (lazy-seq (let [next-step (iter-comb c j)] (when next-step (step (next-step 0) (next-step 1)))))))]\n     (cond\n      (= n 0) (list #{})\n      (= n 1) (map hash-set x)\n\t\t  (= n cnt) (list x)\n      :else\n      (map #(set (map v-items %)) (step c 1))\n      )))\n     )\n    ]\n    (set (apply concat\n    (for [i (range 0 (inc cnt))]\n      (comb cnt i)\n    )\n))\n    )\n   )", "user": "549a176ce4b0f3d1d8e70f69"}, {"problem": 85, "code": "(fn subsets [st]\n (set\n (if\n  (empty? st)\n   #{#{}}\n   (let\n    [rs (subsets\n         (rest st))]\n    (clojure.set/union\n     (map\n      #(conj\n        %\n        (first st))\n      rs)\n     rs)))))", "user": "549a999be4b0f3d1d8e70f6f"}, {"problem": 85, "code": "(fn my-power-set [s]\n  (loop [result #{#{}}]\n    (if (result (set s)) result\n      (recur (conj (set (for [x result y s] (conj x y))) #{})))))", "user": "54769c7ae4b0c51c1f4d72a8"}, {"problem": 85, "code": "(fn [S]\n  (let [\n    n (count S)\n    v (vec S)\n    g (fn [a] (for [i (range n)] (bit-test a i)))\n    h (fn [a] (remove nil? (map-indexed (fn [i b] (if b (v i) nil)) (g a))))\n    f (fn [] (for [i (range (bit-shift-left 1 n))] (h i)))\n    e (fn [] (set (map set (f))))\n  ] (e)))\n    \n;(def n 10)\n;(def v (vec (range n)))\n;(defn g [a] (for [i (range n)] (bit-test a i)))\n;(defn h [a] (remove nil? (map-indexed (fn [i b] (if b (v i) nil)) (g a))))\n;(defn f [] (for [i (range (bit-shift-left 1 n))] (h i)))\n;(defn e [] (set (map set (f))))", "user": "54bd04e7e4b0ed20f4ff6ed8"}, {"problem": 85, "code": "(fn power-set [s]\n  (set (reduce (fn [acc el]\n                 (concat acc (map #(conj %1 el) acc)))\n               #{#{}} s)))", "user": "54be7772e4b0ed20f4ff6eea"}, {"problem": 85, "code": "(fn [gs]\n  (letfn [(bgen [acc queue gs]\n                (if (empty? queue)\n                  acc\n                  (let [e (first queue)\n                        nes (map #(set (cons % e)) gs)\n                        filtered-nes (remove #(acc %) nes)]\n                    (recur (set (concat acc filtered-nes))\n                           (concat (rest queue) filtered-nes)\n                           gs)\n                    )))]\n    (bgen #{#{}} [#{}] gs)))", "user": "54b13a40e4b09f271ff37d1b"}, {"problem": 85, "code": "(fn [s]\n  (reduce\n    (fn [prev v]\n      (set (mapcat #(set [(conj % v) %]) prev)))\n    #{#{}} s))", "user": "50f10f7be4b06d9538fe211a"}, {"problem": 85, "code": "(fn [S](reduce (fn [T, t] (clojure.set/union T (map #(conj % t) T))) #{#{}} S))", "user": "54c19050e4b0ed20f4ff6f26"}, {"problem": 85, "code": "(fn [s] \n    (let [q\n          (memoize\n            (fn [s q]\n              (apply clojure.set/union #{s} (map #(q (disj s %) q) s)) \n              )   \n            )   \n          ]   \n      (q s q)\n      )   \n    )", "user": "54b90836e4b0ed20f4ff6e9d"}, {"problem": 85, "code": "(fn pset\n  ([st] (into #{}\n              (pset st #{#{}})))\n  ([st sts]\n     (if (empty? st)\n       sts\n       (recur (rest st)\n             (concat sts (map #(conj % (first st)) sts))))))", "user": "534941d1e4b084c2834f4a60"}, {"problem": 85, "code": "reduce (fn [v,e] (clojure.set/union v ( map #(conj % e)  v  )\t)) #{#{}}", "user": "54af6fb0e4b09f271ff37d08"}, {"problem": 85, "code": "(fn ps [xs]\n  (if (empty? xs)\n    #{#{}}\n    (let [x (first xs)\n          pt (ps (rest xs))]\n      (apply conj pt (map #(conj % x) pt)))))", "user": "511688d5e4b0b3e208dba05a"}, {"problem": 85, "code": "(fn __ [s]\n  (if (empty? s) #{#{}}\n    (let [f (first s)\n          r (__ (rest s))]\n      (apply conj r (map #(conj % f) r)))))", "user": "54c271b9e4b045293a27f602"}, {"problem": 85, "code": "reduce (fn [r e] (into r (map #(conj % e) r))) #{#{}}", "user": "54ca9ca8e4b057c6fda3a265"}, {"problem": 85, "code": "(fn ps [s]\n  (if (empty? s) #{#{}}\n     (let [t (ps (rest s)) h (first s)]\n        (into t (map #(conj % h) t)))))", "user": "54cc313de4b057c6fda3a28b"}, {"problem": 85, "code": "(fn ps [ss]\n  (if (empty? ss) #{#{}}\n      (let [s (first ss)\n            ss' (ps (rest ss))]\n        (set (concat ss' (map #(conj % s) ss')))))\n  )", "user": "54c641f8e4b045293a27f628"}, {"problem": 85, "code": "(fn power-set [s] \n  (if (empty? s) \n    #{#{}} \n    (let [r (power-set (rest s))]\n      (reduce into #{} [r (map #(conj % (first s)) r)]))))", "user": "54bd3aefe4b0ed20f4ff6edb"}, {"problem": 85, "code": "(fn power-set [s]\n  (let [ps (fn [set el]\n             (clojure.set/union\n              set\n              (reduce #(conj %1 (conj %2 el)) #{} set)))]\n    (reduce ps #{#{}} s)))", "user": "541b1f25e4b01498b1a71a63"}, {"problem": 85, "code": "(fn [coll]\n  (letfn [(combine [acc x] (conj (into acc (map #(conj % x) acc)) #{x}))]\n    (conj (reduce combine #{} coll) #{})))", "user": "549c1713e4b0f3d1d8e70f82"}, {"problem": 85, "code": "(fn pwrst [s]\n  (if (empty? s)\n    #{#{}}\n    (let [ elem     (first s) \n           recurred (pwrst (rest s))]\n     (clojure.set/union recurred (map #(conj % elem) recurred)))))", "user": "54d6f22de4b0a52adc2e2023"}, {"problem": 85, "code": "(fn [coll]\n    (reduce (fn [coll item]\n              (set (concat coll (map #(set (concat #{item} %)) coll))))\n            #{#{}}\n            coll))", "user": "53f31dafe4b0742d9025b0f0"}, {"problem": 85, "code": "(fn [s]\n    (let [v (vec s)\n          range-to (java.lang.Math/pow 2 (count s))\n          pick-by-bit (fn [v n]\n                        (for [i (range (count v))\n                              :when (bit-test n i)]\n                          (v i)))]\n      (into #{} (map #(set (pick-by-bit v %)) (range range-to)))))", "user": "51b91b08e4b0e871ca4958f8"}, {"problem": 85, "code": "(fn power-set [col]\n  (cond (empty? col)\n        #{#{}}\n        :else\n        (let [c (power-set (rest col))\n              e (first col)]\n          (apply hash-set (apply concat (map (fn [itm] (list (conj itm e) itm)) c))))))", "user": "53664e3be4b0243289761e74"}, {"problem": 85, "code": "(letfn\n  [(ps\n    ([s f] (if (empty? s)\n           #{#{}}\n           (reduce clojure.set/union (map #(fold % (f (clojure.set/difference s #{%}) f)) s)))))\n    (fold [e T] (into T (map #(conj % e) T)))\n   (mps [] (memoize ps))]\n   #(ps % (mps)))", "user": "54cbe00ee4b057c6fda3a285"}, {"problem": 85, "code": "(fn [coll]\n  (reduce (fn [acc x]\n            (into acc\n              (map (fn [xs] (conj xs x)) acc)))\n          #{#{}} coll))", "user": "5213d7aae4b0961f15ac4d72"}, {"problem": 85, "code": "(fn [s]\n  (letfn [(f [k s]\n            (if (= k 0)\n              '(#{})\n              (set\n               (for [x (f (dec k) s)\n                     y s\n                     :when (not (contains? x y))]\n                 (conj x y)))))]\n    (set (mapcat #(f % s) (range (inc (count s)))))))", "user": "54dd76c8e4b024c67c0cf794"}, {"problem": 85, "code": "(fn powerset [s]\n  (if (empty? s) #{#{}}\n      (set (mapcat #(list % (conj % (first s))) (powerset (rest s))))))", "user": "54e3df6ae4b024c67c0cf7e3"}, {"problem": 85, "code": "(fn pset [s]\n  (if (empty? s) #{#{}}\n   (let [f (first s) r (disj s f)]\n       (clojure.set/union #{#{f} #{}} \n             (into #{} (map #(conj % f) (pset r ))) (into #{} (pset r))))))", "user": "54908cc1e4b0b312c081ff32"}, {"problem": 85, "code": "(fn power-set [col]\n  (reduce\n   (fn [base x]\n     (set (concat (map #(conj % x) base) base)))\n   #{#{}} col))", "user": "4dd7d040535d2dad7130b5d6"}, {"problem": 85, "code": "(fn power-set [set-of-things]\n  (set    ; make a set of the reduced collection (removes repeats) \n    (reduce\n      (fn [current-set current-item]    ;go through every existing set in the \n        (concat                         ;power set and create a new set that adds\n          current-set                   ;the current item and adds back to power set\n          (map\n            (fn [existing-item-set]\n              (set (conj existing-item-set current-item)) )\n            current-set)) )   \n      #{#{}}     ; start with just the empty set\n      set-of-things\n    ))\n)", "user": "546692aee4b01be26fd746e7"}, {"problem": 85, "code": "(fn [x]\n  (loop [s x\n         res #{#{}}]\n    (if (empty? s)\n      res\n      (let [e (first s)]\n        (recur (rest s) (set (reduce #(conj %1 (conj %2 e)) res res)))))))", "user": "525cc912e4b0cb4875a45d48"}, {"problem": 85, "code": "(fn pset [s]\n  (cond\n    (= (count s) 0)\n    #{#{}}\n\n    :else\n    (let [f (first s)\n          r (rest s)\n          theset (pset r)]\n      ;; Add f by itself\n      ;; And f to all permutations of r\n      (set\n       (concat\n        (map #(conj % f) theset)\n        theset)))))", "user": "532b43c3e4b09d4e7a9b5531"}, {"problem": 85, "code": "(fn pset [sset]\n  (if (> (count sset) 9) (range 1024)\n  (let [s2v      \n          (fn [sc] (for [i sc] i))\n        combination \n          (fn combnt [n m seqs] \n            (if (= 1 m) \n              seqs \n              (map #(flatten %) \n                (reduce concat '() \n                  (for [k (range (- n (dec m)))] \n                    (map #(list (first (drop k seqs)) %) \n                      (combnt (dec n) (dec m) (drop (inc k) seqs))))))))\n        comb-all\n         (reduce concat  \n           (for [i (range 1 (inc (count sset)))] \n             (combination (count sset) i (s2v sset))))\n        comb-single (map #(conj '() %) (take (count sset) comb-all))\n        comb-reset  (concat comb-single (drop (count sset) comb-all))] \n     (set (cons #{}\n            (map #(set %)\n              comb-reset))))))", "user": "5243e37ae4b076204b44fae3"}, {"problem": 85, "code": "(fn [xs]\n  (loop [results #{#{}}\n         xs' xs]\n    (if (empty? xs')\n      results\n      (recur (into results (map #(conj % (first xs')) results))\n             (rest xs')))))", "user": "54cc26c1e4b057c6fda3a28a"}, {"problem": 85, "code": "(fn get-subs [st]\n  (if (= 0 (count st)) #{st}\n      (let [e (first st)\n            subs (get-subs (disj st e))]\n        (println subs)\n        (clojure.set/union #{#{e}} subs (into #{} (map #(conj % e) subs))))))", "user": "51b76227e4b0d906fcd71d35"}, {"problem": 85, "code": "(fn [s]\n  (loop [r #{#{}}]\n    (if (contains? r s)\n      r\n      (recur (set (clojure.set/union r\n                                     (for [x r\n                                           y s]\n                                       (conj x y))))))))", "user": "51ab70c3e4b04e3dc0c27b33"}, {"problem": 85, "code": "(fn subsets [s]\n  (if (empty? s)\n    #{#{}}\n    (let [ts (subsets (rest s))]\n      (->> ts\n           (map #(conj % (first s)))\n           (clojure.set/union ts)))))", "user": "544cf5d7e4b0e39780006977"}, {"problem": 85, "code": "(fn [s] (letfn [(f [c] (map #(conj c %) s))]\n          (loop [p #{#{}}] (if (p s) p (recur (into p (mapcat f p)))))))", "user": "54f0d3fde4b024c67c0cf8a6"}, {"problem": 85, "code": "(fn m [x]\n    (if (empty? x)\n      #{#{}}\n      (set (concat (m (rest x))\n                   (map #(conj % (first x)) (m (rest x)))))))", "user": "5470b3d0e4b00cfc9eacc1bb"}, {"problem": 85, "code": "(fn [given-set]\n  (set (reduce (fn [pow g]\n    (for [fr pow to #{nil g}]\n      (if (nil? to) fr (conj fr to))))\n    (if (> (count given-set) 0)\n      #{ #{(first given-set)} #{} }\n      #{#{}}) (rest given-set))))", "user": "546ff835e4b00cfc9eacc1b4"}, {"problem": 85, "code": "(fn powerset [coll]\n  (if (empty? coll)\n    #{#{}}\n    (let [x (first coll)\n          xs (set (rest coll))\n          ps-of-xs (powerset xs)]\n      (clojure.set/union ps-of-xs (set (map #(conj % x) ps-of-xs))))))", "user": "5344fe13e4b084c2834f4a32"}, {"problem": 85, "code": "(fn [vset]\n  (let [els (seq vset)]\n    (->> (range 1 (Math/pow 2 (count els)))\n         (map #(Integer/toBinaryString %))\n         (map (fn [bs] (map vector (reverse bs) (range))))\n         (map (fn [bp] (filter #(= \\1 (first %)) bp)))\n         (map (fn [bp] (reduce (fn [s p] (conj s (nth els (second p)))) #{} bp)))\n         (into #{#{}}))))", "user": "541d3c0fe4b01498b1a71a7e"}, {"problem": 85, "code": "(fn powerset [s]\n  (reduce #(into % (for [subset %] (conj subset %2))) #{#{}} s))", "user": "539c736ce4b0b51d73faaf2b"}, {"problem": 85, "code": "(fn power-set [sett] \n  (letfn [\n    ; get number n expressed in s binary digits\n    (bits [n s] (take s (map\n        (fn [i] (bit-and 0x01 i))\n        (iterate (fn [i] (bit-shift-right i 1)) n\n    ))))]\n    (set (for [\n        ; for each permutation in the range 0.. 2^(sett count)...\n        permutation   (range (reduce * (repeat (count sett) 2)))\n        ; produce a permutation line ({elem1 0, elem2 1, elem3 0, ...})\n        line          [(zipmap sett (bits permutation (count sett)))]]\n      ; then filter out only the 1's\n      (set (map first (filter (fn [[item bit]] (= 1 bit)) line)))\n))))", "user": "54bbe505e4b0ed20f4ff6ec5"}, {"problem": 85, "code": "#(letfn [(f [xs]\n            (loop [ys xs i (dec (count ys))]\n              (if (= (dec (last ys)) (last (drop-last ys)))\n                (recur (drop-last ys) (dec i))\n                i)))\n         (g [xs n]\n            (let [i (f xs)]\n              (if (and (zero? i)\n                       (= (last xs) (dec n)))\n                nil\n                (if (= (last xs) (dec n))\n                  (let [m (inc (nth xs (dec i)))]\n                    (concat (take (dec i) xs)\n                            (take (- (count xs) (dec i))\n                                  (drop m (range)))))\n                  (concat (drop-last xs) (list (inc (last xs))))))))\n         (h [xs k]\n            (let [n (count xs)]\n              (loop [index (range k)\n                     ys (vector (map xs index))]\n                (if (nil? index)\n                  (drop-last ys)\n                  (let [index2 (g index n)]\n                    (recur index2\n                           (conj ys (map xs index2))))))))]\n   (let [xs (vec %)]\n     (loop [i 1 ys [[]]]\n       (if (<= i (count xs))\n         (recur (inc i) (into ys (h xs i)))\n         (set (map set ys))))))", "user": "54d753ebe4b0a52adc2e2029"}, {"problem": 85, "code": "(fn [s]\n  (letfn [(perm [st]\n            (loop [s st acc []]\n              (if (empty? s)\n                acc\n                (recur (rest s)\n                       (if (empty? acc)\n                         (conj acc (set (list (first s))))\n                         (conj (apply (partial conj acc) (map #(conj % (first s)) acc))\n                               (set (list (first s)))))))))]\n    (set (conj (perm s) #{}))))", "user": "54fdbe3fe4b07d26eda61d3b"}, {"problem": 85, "code": "(fn powerset [a-set]\n  (set\n   (cond\n    (empty? a-set) #{#{}}\n    :else\n    (let [firstE (first a-set)\n          multipleAppend (fn multipleAppend [elem a-sets]\n                           (if (empty? a-sets)\n                             #{}\n                             (conj (multipleAppend elem (rest a-sets)) (conj (first a-sets) elem))))\n          powerRest (powerset (rest a-set))\n          firstPower (multipleAppend firstE powerRest)]\n      (concat powerRest firstPower)))))", "user": "54f64e99e4b0f2f3c5226ea4"}, {"problem": 85, "code": "(fn [s]\n  (loop [accu #{#{}}\n         s s]\n    (if (empty? s)\n      accu\n      (recur (reduce conj accu (map #(conj % (first s)) accu)) (rest s)))))", "user": "4e82c062535db62dc21a62cc"}, {"problem": 85, "code": "(fn allcombi [setan]\n  (if (empty? setan)\n    #{#{}}\n    (let [lim (count setan)\n          cont1 (into #{} (map #(into #{} [%]) setan))\n          join (fn [starget s]\n                 (into #{} (map #(clojure.set/union starget %) s)))]\n      (loop [i 1 res cont1]\n        (if (= lim i)\n          (conj res #{})\n          (recur (inc i)\n                 (into #{}\n                       (mapcat #(join % cont1) res))))))))", "user": "54b7f217e4b0ed20f4ff6e8f"}, {"problem": 85, "code": "(fn power-set [s]\n  (let [[head & tail] (vec s)]\n    (cond (nil? head) #{#{}}\n          (empty? tail) #{#{} #{head}}\n          :else (set (concat (power-set tail) (map #(conj % head) (power-set tail)))))))", "user": "54febf4be4b07d26eda61d45"}, {"problem": 85, "code": "(fn powerset [s]\n  (if-let [f (first s)]\n    (let [r (disj s f)\n          p (powerset r)]\n      (set (concat\n             (map #(conj % f) p)\n             p)))    \n    #{#{}}))", "user": "4ee75ec2535d93acb0a66867"}, {"problem": 85, "code": "(fn power-set\n  [coll]\n  (reduce\n    (fn [r x] (into r (map #(conj % x) r)))\n    #{#{}}\n    coll))", "user": "5383668ee4b06839e8705edd"}, {"problem": 85, "code": "(fn g[s]\n  (if (empty? s)\n    #{#{}}\n    (let [x (first s)\n          ts (g (rest s))]\n      (into ts (map #(conj % x) ts)))))", "user": "5488537be4b0e286459a11cf"}, {"problem": 85, "code": "(fn power-set [s]\n  (if-let [[firs & nexs] (seq s)]\n    (let [pow-nexs (power-set nexs)\n          add-pow (map #(conj % firs) pow-nexs)]\n      (into #{} (concat pow-nexs add-pow)))\n    #{#{}}))", "user": "53908e6be4b0b51d73faae9a"}, {"problem": 85, "code": "(fn ps [s]\n  (if-let [ss (seq s)]\n    (let [x (first ss)]\n      (set (apply concat (for [t (ps (rest s))] [(conj t x) t]))))\n    #{#{}}))", "user": "548fa2dfe4b0e286459a1240"}, {"problem": 85, "code": "(fn [x] (into #{} (conj(reduce (fn [ant nuev] (loop [[act & falt] ant arrnuevo ant] (if (nil? act) (conj arrnuevo #{nuev}) (recur falt (conj arrnuevo (if (coll? act) (conj act nuev) #{act nuev}) )) ))) [] (into [] x)) #{}) ))", "user": "5517f5c5e4b06a49daca83c7"}, {"problem": 85, "code": "(fn [s]\t(let [comb (fn f [c]\n                     (when-not (empty? c)\n                       (let [x (f (vec (rest c)))]\n                       (concat (for [i (range (count c))] (set (concat [(first c)] [(c i)] )))\n                               (for [j x] (into #{(first c)} j))\n                               x )) ))]\n          (into #{} (conj (comb (vec s)) (empty s)))))", "user": "54e51c7be4b024c67c0cf7f7"}, {"problem": 85, "code": "(fn power-set--bottom-up\n  [s] {:pre [(set? s)]}\n  (set (reduce (fn [acc x] (mapcat (juxt identity #(conj % x)) acc))\n           [#{}] s)))", "user": "4fc6305de4b0ee37620e180b"}, {"problem": 85, "code": "(fn [s]\n  (reduce \n   (fn[prev el]\n     (clojure.set/union prev \n           (into '#{} (map #(conj % el) prev))))\n   '#{#{}} s))", "user": "5514a60fe4b055c2f668d4d7"}, {"problem": 85, "code": "(fn [s]\n  (reduce (fn [init e] (set (concat init (map #(conj % e) init) [#{e}]))) #{#{}} s))", "user": "54e5bdf2e4b024c67c0cf7fe"}, {"problem": 85, "code": "(fn power-set [s]\n  (if (empty? s)\n    #{#{}}\n   \t(let [power-set* (power-set (rest s))]\n      (set (concat power-set*\n              (map #(set (conj % (first s))) power-set*))))))", "user": "551ed214e4b08d5046aa8a4d"}, {"problem": 85, "code": "(fn powerset [ls]\n   (set\n     (if (empty? ls) '(#{})\n         (clojure.set/union (powerset (next ls))\n           (map #(set (conj  % (first ls))) (powerset (next ls)))))))", "user": "4fc4eb1ee4b081705acca354"}, {"problem": 85, "code": "(fn [coll]\n  (let [pad-with-zeroes (fn [places s] (-> (str \"%0\" places \"d\") (format (read-string s))))\n        to-binary (fn [places n] (->> (Integer/toBinaryString n) (pad-with-zeroes places) (map str) (map read-string)))\n        positions (fn [coll] (keep-indexed (fn [idx x] (when (= 1 x) idx)) coll))\n        n (count coll)\n        my-nums (range (Math/pow 2 n))\n        my-binaries (->> my-nums (map #(to-binary n %)))\n        permutations (->> my-binaries (map positions))\n        coll-vector (into [] coll)]\n    (if (empty? coll) #{#{}} (->> (map #(map coll-vector %) permutations) (map #(into #{} %)) (into #{})))))", "user": "5412ef7ee4b01498b1a719da"}, {"problem": 85, "code": "(fn power-set [s]\n    (loop [res #{#{}} left-over s]\n        (if (= left-over [])\n            res\n            (let [fst (first left-over)]\n        (recur (reduce #(conj %1 (if (= fst nil) %2 (conj %2 (first left-over)))) res res) (rest left-over))))))", "user": "54f09599e4b024c67c0cf89d"}, {"problem": 85, "code": "(fn [s]\n    (letfn \n      [(interset [a b](filter (fn [c] (not (some #(contains? a %) c))  ) b))\n       (mmf [l s]\n            (if(empty? s)\n                     '()\n                     (map #(into l %1) s) \n                     ))\n       (mfunc [se] \n        (if (empty? se) (list #{})\n          (reduce \n           #(into %1 (mmf %2 (interset %2 se ) ))\n            (mmf (first se) (set (rest se)))\n           (set(rest se)))\n       )\n     )\n  \n       (cfunc \n        [st l]\n        (if (zero? l)\n          (into st #{#{}})\n     (cfunc (into st  (mfunc st) )   (dec l))\n         )\n           )]  \n       (cfunc (set(map hash-set s)) (count s))\n      \n    )\n  )", "user": "54edcf96e4b024c67c0cf866"}, {"problem": 85, "code": "(fn power-set [s]\n  (if-let [e (first s)]\n    (apply clojure.set/union\n      (for [ps (power-set (rest s))]\n        #{ps (conj ps e)}))\n    #{#{}}))", "user": "54f2fe9fe4b050824f58f5b8"}, {"problem": 85, "code": "(fn pset [x]\n  (if (empty? x)\n    #{#{}}\n    (let [first-x (first x), y (pset (rest x))]\n      (set (concat y (map #(conj % first-x) y)))\n    )\n  )\n)", "user": "55280930e4b0ffed3738f93b"}, {"problem": 85, "code": "#((fn ! [c p]\n    (loop [r #{#{}}  c c]\n      (if (seq c)\n        (let [x (conj p (first c))]\n          (recur (into (conj r x)\n                       (! (rest c) x))\n                 (rest c)))\n        r))) % #{})", "user": "55201d18e4b08d5046aa8a5d"}, {"problem": 85, "code": "(fn sol [s]\n  (let [[f & r] (vec s)]\n    (if (nil? f) #{#{}}\n      (let [d (sol r)]\n        (into d (map #(into #{f} %) d)))))\n  )", "user": "51a058dae4b0b292b01ee3f3"}, {"problem": 85, "code": "(fn all-subsets\n  [s]\n  (letfn [(s-choose-k [s k]\n            (let [seq-s (seq s)]\n              (take-while (complement nil?) (iterate (partial next-comb seq-s) (set (take k seq-s))))))\n          (next-comb [s prev]\n            (if (= prev (set (take-last (count prev) s)))\n              nil\n              (let [include-map \n                    (map (fn [e] (if (contains? prev e) :1 :0)) s)] \n                (->> (drop-last-while (partial = :1) include-map)\n                     (drop-last-while (partial = :0))\n                     (drop-last 1)\n                     (reverse)\n                     (cons :0)\n                     (cons :1)\n                     (concat (take-last-while (partial = :1) include-map))\n                     (reverse)\n                     (pad :0 (count s))\n                     (map (fn [el include] (if (= :1 include) el :0)) s)\n                     (filter (fn [e] (not= :0 e)))\n                     (set)))))\n          (pad [pad-val l s]\n            (if (= (count s) l)\n              s\n              (pad pad-val l (concat s (list pad-val)))))\n          (index [vect val]\n            (->> (map-indexed #(list %1 %2) vect)\n                 (filter #(= val (second %)))\n                 (ffirst)))\n          (drop-last-while [pred s]\n            (->> (reverse s)\n                 (drop-while pred)\n                 (reverse)))\n          (take-last-while [pred s]\n            (->> (reverse s)\n                 (take-while pred)\n                 (reverse)))]\n    (if (= (count s) 0)\n      (set (s-choose-k s 0))\n      (reduce\n       #(clojure.set/union %1 (set (s-choose-k s %2)))\n       (set (s-choose-k s 0))\n       (range 1 (inc (count s)))))))", "user": "53b952eee4b047364c0444e6"}, {"problem": 85, "code": "(fn pow-set [s]\n  (if (empty? s)\n    #{#{}}\n    (let [ex (first s)\n          exset (pow-set (set (rest s)))]\n    (clojure.set/union exset\n                        (map #(clojure.set/union (set (list ex)) (set  %))  exset)))))", "user": "5143824ae4b0b4fb4ace5f36"}, {"problem": 85, "code": "(fn [coll]\n  (conj \n    (nth \n      (iterate  ((fn [i]  \n                   (fn  [coll]  \n                     (set  (flatten (map #(for  [x i]  (conj % x)) coll))))) coll) (map #(hash-set %) coll)) \n             (inc (count coll))) #{}))", "user": "52eaba10e4b09f7907dd14c2"}, {"problem": 85, "code": "(fn [s1]\n          (loop [res [[]] c (count s1)]\n            (if (zero? c)\n              (set(map set res))\n              (recur \n                (set (map set (concat res (for [r (seq res) s (seq s1)] (conj r s))))) \n                (dec c))\n              )\n            ))", "user": "533c2605e4b0e30313ee6cd7"}, {"problem": 85, "code": "(fn __\n  ([x]\n   (__ x (map (fn [y] #{y}) x)))\n  ([x y]\n   (let [z (into #{} (for [a x b y] (clojure.set/union #{a} b)))]\n     (if (or (= z #{})(contains? z x))\n       (conj z #{})\n       (__ x z)))))", "user": "53d5a63be4b0e771c3025449"}, {"problem": 85, "code": "(fn [base-set]\n    (loop [all-sets #{ #{} }\n           [s1 & srest :as to-do] (seq base-set)]\n      (if (empty? to-do)\n        (set all-sets)\n        (recur (concat all-sets (map #(set (conj % s1)) all-sets))\n               srest))))", "user": "5531e445e4b09218d5f44f76"}, {"problem": 85, "code": "(fn [s]\n  (reduce\n   (fn [a b]\n     (into a (map #(conj % b) a)))\n   #{#{}} s))", "user": "54b04708e4b09f271ff37d11"}, {"problem": 85, "code": "(fn powset [s]\n  (if (empty? s) #{#{}}\n    (->>\n     (powset (rest s))\n     (mapcat #(set [% (conj % (first s))]))\n     set)))", "user": "553e0b70e4b0a04f792994e8"}, {"problem": 85, "code": "(fn __ [s]\n  (if (empty? s)\n    #{#{}}\n    (let [sub (__ (rest s))]\n      (apply conj sub (map #(conj % (first s)) sub)))))", "user": "553abb28e4b09218d5f44ffb"}, {"problem": 85, "code": "(fn powerset [s]\n  (if (seq s)\n    (let [x (first s)\n          r (drop 1 s)\n          p-r (powerset r)\n          p-r-add-x (map (fn [c] (conj c x)) p-r)\n          just-x (list x)]\n      (clojure.set/union p-r p-r-add-x))\n    #{#{}}))", "user": "5547cd6ee4b0a04f79299553"}, {"problem": 85, "code": "#(case (count %)\n   2  #{#{1 :a} #{:a} #{} #{1}}\n   0 #{#{}}\n   3 #{#{} #{1} #{2} #{3} #{1 2} #{1 3} #{2 3} #{1 2 3}}\n   (range 1024))", "user": "5507cfd3e4b021ccfedb96ad"}, {"problem": 85, "code": "(fn power [s]\n  (letfn [(f [e t] (reduce #(conj %1 (conj %2 e)) #{} t))]\n    (if (empty? s) #{s}\n      (let [e (first s) t (disj s e)]\n        (clojure.set/union (power t) (f e (power t)))))))", "user": "4f7207d3e4b07046d9f4f019"}, {"problem": 85, "code": "(fn power-set [s]\n  (if (empty? s)\n    #{#{}}\n    (let [s1 (first s) rs (disj s s1) prs (power-set rs)]\n      (clojure.set/union prs (map #(conj % s1) prs)))))", "user": "52ce1abfe4b07d0d72b27389"}, {"problem": 85, "code": "(fn power-set [s]\n\t(if\t(empty? s)\n\t\t#{#{}}\n\t\t(let [s0 (first s), ps (power-set (rest s))]\n\t\t\t(conj (clojure.set/union ps (map #(conj % s0) ps)) #{s0}))))", "user": "5370b386e4b0fc7073fd6e9b"}, {"problem": 85, "code": "(fn power-set [s]\n  (if (empty? s)\n    #{#{}}\n    (let [a (first s)\n          b (disj s a)\n          p2 (power-set b)\n          p3 (map #(conj % a) p2)]\n      (clojure.set/union p2 p3)\n      )))", "user": "54e345a1e4b024c67c0cf7db"}, {"problem": 85, "code": "(letfn [(power-set [set]\n                   (if (zero? (count set))\n                     #{#{}}\n                     (let [elt (first set)\n                           subset (rest set)\n                           sub-power-set (power-set subset)]\n                       (concat sub-power-set (map #(conj % elt) sub-power-set)))))]\n  (fn [s] (set (power-set s))))", "user": "5553b924e4b0deb715856e06"}, {"problem": 85, "code": "(fn ps [s]\n  (if (empty? s)\n    #{#{}}\n    (let [p (ps (rest s))]\n      (clojure.set/union p (map #(conj % (first s)) p)))))", "user": "55495318e4b0a04f79299566"}, {"problem": 85, "code": "reduce (fn [c s] (into c (map #(conj % s) c))) #{#{}}", "user": "543366dde4b0b6b47310fcdf"}, {"problem": 85, "code": "(fn power [out in] \n  (cond\n   (empty? in) (apply hash-set out)\n   :else (power (mapcat #(list (conj % (first in)) %) out) (rest in))\n )) '(#{})", "user": "5280a1ece4b0757a1b171407"}, {"problem": 85, "code": "(fn [s] (reduce (fn [a x] (into a (map #(conj % x) a))) #{#{}} s))", "user": "5532a04ee4b09218d5f44f82"}, {"problem": 85, "code": "(fn make-pset [coll]\n  (if (empty? coll)\n    #{#{}}\n    (let [el (first coll)\n          others (rest coll)\n          pset (make-pset others)]\n      (into pset (map #(conj % el) pset)))))", "user": "5264383be4b03e8d9a4a70cb"}, {"problem": 85, "code": "(fn powerset [s]\n  (if (empty? s)\n    #{#{}}\n    (apply clojure.set/union (for [ i (powerset (rest s))] #{i (conj i (first s))}))))", "user": "55536a8ae4b0deb715856e03"}, {"problem": 85, "code": "(fn [s]\n  (let [n (count s)]\n    (set \n      (for [x (range (Math/pow 2 n))]\n        (set (keep-indexed #(when (bit-test x %1) %2) s))))))", "user": "555ac933e4b0deb715856e49"}, {"problem": 85, "code": "(fn [s] \n  (loop [p #{#{}} s s] \n    (if (empty? s) \n      p\n      (recur (clojure.set/union p\n                                (set (map #(conj % (first s))  \n                                     p)))\n             (set (rest s))))))", "user": "545801f6e4b01be26fd74615"}, {"problem": 85, "code": "(fn [s]\r\n  (let [\r\n      comb (fn comb [items n]\r\n        (if (> n (count items))\r\n          '()\r\n        (if (= n 0)\r\n          '(())\r\n        (if (= n 1)\r\n          (map vector items)\r\n          (let [[head & tail] items]\r\n            (concat\r\n              (map #(cons head %) (comb tail (dec n)))\r\n              (comb tail n)))))))]\r\n    (set\r\n      (map set\r\n        (apply concat\r\n          (map #(comb (seq s) %)\r\n            (range (inc (count s)))))))))", "user": "555bd27ae4b0b056612e2244"}, {"problem": 85, "code": "(fn power-set \n  ([sequence-set] (power-set sequence-set #{#{}}))\n  ([sequence-set result]\n   (if (empty? sequence-set)\n     result\n     (power-set (rest sequence-set) (clojure.set/union result (map #(conj % (first sequence-set)) result))))))", "user": "556c94afe4b09a3098a524fe"}, {"problem": 85, "code": "#(loop[result #{%}, previous #{#{}}, round 0]\n   (if (= round (count %))\n     result\n     (recur (into result previous);merge result\n            (set (for [x previous, y %] (into x (list y))));grow set\n            (inc round))));new round\n;\n;an alternative solution\n;(fn [sets]\n;\t(loop [s sets r (conj #{sets} #{})]\n;      (if (empty? s) r\n;        (recur (rest s) (into r (set (map #(conj % (first s)) r)))))))", "user": "556c70dae4b09a3098a524fd"}, {"problem": 85, "code": "(fn p [s]\n  (let [rec-helper\n        (fn rec-helper [curr remaining]\n          (if (empty? remaining)\n            (set curr)\n            (do\n              (vector\n                (rec-helper (conj curr (first remaining)) (rest remaining))\n                (rec-helper curr (rest remaining))))))]\n    (into #{#{}} (flatten (rec-helper [] s)))))", "user": "536046a9e4b063bf7a5f8fe1"}, {"problem": 85, "code": "(fn [s]\n  (set (map (fn [c]\n         (set (map #(nth (seq s) %) (filter #(= 1 (nth c %)) (range (count s))))))\n       ((fn combin [pos n]\n         (if (= n 0)\n           pos\n          (combin (concat (map #(conj % 1) pos) (map #(conj % 0) pos)) (dec n)))) [[]] (count s)))))", "user": "55625903e4b0c656e3ff17d7"}, {"problem": 85, "code": "(fn [s]\n  (reduce (fn [a x]\n            (->> (map #(set (concat #{x} %)) a)\n                 (concat a)\n                 set))\n          #{#{}} s))", "user": "538ca203e4b0b51d73faae5f"}, {"problem": 85, "code": "(fn P [s]\n    (if-let [[f & r] (seq s)]\n      (let [p (P (set r))]\n        (into p (map #(conj % f) p)))\n      #{s}))", "user": "4f42ae16e4b0d7d3c9f3fd09"}, {"problem": 85, "code": ";[]      -> {}\n;[1]     -> {} \u222a\n;           {1}\n;[1 2]   -> {}  {1} \u222a\n;           {2} {1 2}\n;[1 2 3] -> {}  {1}   {2}   {1 2} \u222a\n;           {3} {1 3} {2 3} {1 2 3}\n(fn powerset [coll]\n  (reduce (fn [res next]\n            (clojure.set/union res (map #(conj % next) res)))\n          #{#{}}\n          coll))", "user": "55586905e4b0deb715856e2b"}, {"problem": 85, "code": "(fn power-set [xs]\n  (reduce (fn [a x] (set (concat (map #(set (concat #{x} %)) a) a))) #{#{}} xs))", "user": "55645592e4b0c656e3ff1802"}, {"problem": 85, "code": "(fn powerset [elements]\n  (loop [ps #{#{}}\n         xs elements]\n    (println ps xs)\n    (if (empty? xs)\n      ps\n      (let [x (first xs)]\n        (recur\n         (clojure.set/union\n          ps\n          (set (map #(conj % x) ps)))\n         (disj xs x))))))", "user": "5283a919e4b0239c8a67adbe"}, {"problem": 85, "code": "(letfn \n  [(subset [s n]\n    (set\n     (loop [s s, ss (), n n]\n       (if (< n 1) ss\n         (if (not= 0 (rem n 2))\n           (recur (rest s) (conj ss (first s)) (quot n 2))\n           (recur (rest s) ss (quot n 2)))))))]\n  \n  (fn [s]\n    (set\n     (map \n      (partial subset s)\n      (range (Math/pow 2 (count s)))))))", "user": "53065acbe4b02e8216869792"}, {"problem": 85, "code": "(fn [se]\n  (let [b (reverse (take (count se) (iterate #(* 2 %) 1)))\n        to-bin (fn [n] (map #(if (zero? (apply - %)) 0 1) (partition 2 1 (reductions #(if (<= %2 %) (rem % %2) %) n b))))]\n\t(if (empty? se) #{#{}}\n      (set\n        (for [i (range (* 2 (first b)))]\n          (reduce (fn [i [k v]] (if (zero? v) i (conj i k))) #{} (zipmap se (to-bin i))))))))", "user": "551c66dae4b07993ea3788de"}, {"problem": 85, "code": "(fn power-set\n  [a-set]\n  (if (seq a-set)\n    (let [item (first a-set)\n          sets-wo-item (power-set (disj a-set item))]\n      (into sets-wo-item\n            (map #(conj % item) sets-wo-item)))\n    #{#{}}))", "user": "5515b138e4b055c2f668d4ed"}, {"problem": 85, "code": "#(->> (tree-seq\n        sequential?\n        (fn [[curr remain]]\n          (cons curr\n                (loop [res []\n                       remain remain]\n                  (if (seq remain)\n                    (let [x (first remain)\n                          rremain (disj remain x)]\n                      (recur (conj res [(conj curr x) rremain])\n                             rremain))\n                    res))))\n        [#{} %])\n      (filter set?)\n      set)", "user": "52470d42e4b05ef8e38e6350"}, {"problem": 85, "code": "(fn ps [s]\n   (reduce (fn [k i] (into k (map #(merge % i) k))) #{#{}} s))", "user": "545ddac3e4b01be26fd74676"}, {"problem": 85, "code": "(fn number85 [s]\n  (reduce (fn [m i]\n            (into m (map #(conj % i) m)))\n          #{#{}} s))", "user": "54074fc5e4b0addc1aec66b6"}, {"problem": 85, "code": "(fn power-set\n  ([s]\n   (power-set #{} s))\n  ([out cur]\n   (if (empty? cur)\n     #{out}\n     (clojure.set/union\n      (power-set (conj out (first cur)) (rest cur))\n      (power-set out (rest cur)))))\n  )", "user": "5545477fe4b0a04f79299531"}, {"problem": 85, "code": "(fn [xs]\n  (set (map set (loop [[f & r] (seq xs) result '(())]\n    (if f (recur r (concat result (map #(cons f %) result)))\n        result)))))", "user": "52fc34cee4b047fd55837015"}, {"problem": 85, "code": "reduce (fn [s x] (into s (map #(conj % x) s))) #{#{}}", "user": "552a793ee4b0ffed3738f955"}, {"problem": 85, "code": "(fn powerset [xs]\n (reduce \n    (fn [a b] \n      (set (concat (map #(conj % b) a) a))\n      ) #{#{}} xs\n  ))", "user": "55896a0ce4b059ccff29b204"}, {"problem": 85, "code": "(fn [s]\n                    (let [set-to-seq (seq s)\n                          power-set-size (Math/pow 2 (count s))\n                          eligibility (map #(Integer/toBinaryString %) (range power-set-size))]\n                      (set (for [e eligibility]\n                             (set (map first (filter (fn [[a b]] (= b \\1)) (partition 2 (interleave set-to-seq (reverse e))))))))))", "user": "54cad2d5e4b057c6fda3a26c"}, {"problem": 85, "code": "(letfn [                                                                                                                                                \n    (subsets [s] (map (partial disj s) s))                                                                                      \n    (powerset [s]                                                                                                                                       \n        (loop [process-list [s] seen #{}]                                                                                       \n            (if (empty? process-list)                                                                                                                   \n                seen                                                                                                            \n                (if (not (seen (first process-list)))                                                                                                   \n                    (recur (concat (rest process-list) (subsets (first process-list))) (set (cons (first process-list) seen)))  \n                    (recur (rest process-list) seen)))))]                                                                                               \n        powerset)", "user": "558b50d5e4b027778923762b"}, {"problem": 85, "code": "(fn power-set**\n  [s]\n  (letfn [(power-set*\n            [s ps]\n            (if-not (empty? s)\n              (recur (rest s) (clojure.set/union ps (into #{} (map #(conj % (first s)) ps))))\n              ps))]\n    (power-set* s #{#{}})))", "user": "506f0968e4b09350ab4199f5"}, {"problem": 85, "code": "(fn power-set\n  [s]\n  (if (zero?(count s))\n    #{#{}}\n    (let [prest (power-set (clojure.set/difference s #{(first s)}))]\n      (clojure.set/union #{#{}}\n                         (set (map (partial clojure.set/union #{(first s)}) prest))\n                         prest))))", "user": "557e9d17e4b05c286339e0d8"}, {"problem": 85, "code": "(fn [s]\n  (set\n   (reduce (fn [acc value]\n             (concat acc (map #(set (conj % value)) acc)))\n           #{#{}}\n           s)))", "user": "540a4f20e4b0addc1aec66ef"}, {"problem": 85, "code": "(fn [s]\n  (\n    (fn g [[a & b] t]\n      (if (nil? a)\n        #{t}\n        (into\n          (g b (merge t a))\n          (g b t))))\n    (seq s) #{}))", "user": "559279b7e4b0604b3f94d58c"}, {"problem": 85, "code": "(fn ps [raw]\n  (let [exp (fn [x n] (reduce * (repeat n x)))]\n    (into #{}\n    (for [n (range (inc (exp 2 (count raw))))]\n      (into #{} (filter identity (map-indexed (fn [idx item] (if (bit-test n idx) item)) raw)))))))", "user": "55934bebe4b0c79f6e1db93b"}, {"problem": 85, "code": "#(set \n    (reduce \n     (fn [p a]\n       (mapcat (fn [_] [(conj _ a) _]) p))\n     [#{}]\n     %))", "user": "559c13c5e4b066d22e731f61"}, {"problem": 85, "code": "(fn combos [l]\n  (if (empty? l) #{#{}}\n    (let [i (first l)\n          c (combos (disj l i))]\n      (clojure.set/union #{#{i}}\n                         c\n                         (set (map #(conj % i) c))))))", "user": "551afdf8e4b07993ea3788cb"}, {"problem": 85, "code": "(fn[coll]\n   (set (reduce\n      (fn [coll e]\n        (concat\n         (map (comp set (partial cons e)) coll)\n         coll))\n      #{#{}} coll)))", "user": "50e90813e4b033b0e80d11e7"}, {"problem": 85, "code": "(fn ps [s]\n  (if (empty? s) #{#{}}\n    (let [n (ps (next s))]\n      (clojure.set/union n (map #(conj % (first s)) n)))))", "user": "5590e55de4b0277789237676"}, {"problem": 85, "code": "(fn [s]\n  ((fn i [c]\n     (if (contains? c s)\n       c\n       (i (reduce (fn [v x] (into v (map #(conj x %) s))) c c))\n       )) #{#{}}))", "user": "5504dd64e4b086ebe8a79c83"}, {"problem": 85, "code": "(fn me [args]\n\n\t(let [combin (fn [arg1 arg2]\n\n\t\t\t(let [new-sets (apply hash-set (map #(clojure.set/union (hash-set arg2) %) arg1))]\n\n\t\t\t\t\t(clojure.set/union arg1 (hash-set (hash-set arg2)) new-sets )\n\n\t\t\t\t)\n\n\t\t)]\n\n\n\t(reduce combin #{#{}}  args)\n\n\t)\n\t)", "user": "55897fe2e4b059ccff29b205"}, {"problem": 85, "code": "(fn [S]\n  (loop [ret-it #{#{}}]\n    (if (contains? ret-it S)\n      ret-it\n      (recur (into ret-it (mapcat\n                           (fn [s]\n                             (into #{} (map #(conj s %)\n                                            S)))\n                           ret-it))))))", "user": "559d33b3e4b0ec2b359424d9"}, {"problem": 85, "code": "(fn [s]\n  (reduce (fn [p v]\n            (clojure.set/union p (map #(clojure.set/union #{v} %)\n                                      p)))\n          #{#{}}\n          s))", "user": "55995fa7e4b031d6649c9ba9"}, {"problem": 85, "code": "(fn powerset [ls]\n  (if (empty? ls) #{#{}}\n                  (clojure.set/union (powerset (next ls))\n                         (map #(conj % (first ls)) (powerset (next ls))))))", "user": "5592bf9fe4b0c79f6e1db933"}, {"problem": 85, "code": "(fn [s]\n  (set\n   (reduce\n    #(concat %1 (map (fn [i] (set (conj i %2))) %1))\n    #{#{}} s)))", "user": "51bfc1f0e4b0e49ef9037dd4"}, {"problem": 85, "code": "(fn [coll]\n  (letfn [(dbl [s e] (into s (map #(conj % e) s)))]\n    (reduce dbl #{#{}} coll)))", "user": "55afd469e4b002ce9d5cbc19"}, {"problem": 85, "code": "#(reduce (fn [acc e] (loop [coll acc acc acc] (if (empty? coll) acc (recur (rest coll) (conj acc (conj (first coll) e)))))) #{#{}} %)", "user": "55a74d46e4b09e57187da2a3"}, {"problem": 85, "code": "(fn [coll]\n  (let [n (count coll)\n        mult (map #(int (Math/pow 2 %)) (take n (range)))\n        int2set (fn [x coll] (into #{} (filter #(not (nil? %))\n                                         (map #(when %1 %2)\n                                           (map #(> (bit-and x %) 0) mult) coll))))]\n    (into #{} (map #(int2set % coll) (take (Math/pow 2 n) (range))))))", "user": "55205564e4b08d5046aa8a60"}, {"problem": 85, "code": "(fn power-set [coll]\n  (reduce (fn [sols a]\n              (clojure.set/union (set (map #(conj % a) sols)) sols)) #{#{}} coll))", "user": "559f06bae4b0acc240e314e6"}, {"problem": 85, "code": "(fn [sc] (let [vc (vec sc) n (count sc)]  (->> (range  (long (Math/pow 2 n)))\n    (map (fn [v] \n      (->> (range n) (filter #(bit-test v %)) (map #(nth vc %)) set)\n    )) set )        \n))", "user": "55adf4d7e4b03311e7b732af"}, {"problem": 85, "code": "(fn power-set [s]\n  (reduce\n    (fn [sets x]\n      (->> sets\n           (map #(conj % x))\n           (into sets)))\n    #{#{}} s))", "user": "50ec409ce4b04edc33777045"}, {"problem": 85, "code": "(fn [coll]\n  (letfn [(set-with-values [x]\n            (loop [acc #{} coll' coll index 0]\n              (cond\n               (empty? coll')      acc\n               (bit-test x index)  (recur (conj acc (first coll')) (rest coll') (inc index))\n               :else               (recur acc (rest coll') (inc index)))))]\n    (conj (reduce conj (map set-with-values (range (bit-shift-left 1 (count coll))))) #{})))", "user": "5576f299e4b05c286339e077"}, {"problem": 85, "code": "(fn powerset [s]\n  (reduce #(into % (for [subset %] (conj subset %2))) #{#{}} s))", "user": "537e104ce4b06839e8705e9a"}, {"problem": 85, "code": "(fn [s]\n  (letfn [(subsets [[x & xs]]\n            (if (nil? x)\n              #{#{}}\n              (let [subs (subsets xs)]\n                (clojure.set/union\n                 subs\n                 (into #{} (map #(conj % x) subs))))))]\n    (subsets (seq s))))", "user": "55ac07afe4b03311e7b7328f"}, {"problem": 85, "code": "(letfn [ \n  (aldoniEl [e aa]  (set (for [i  aa ] (conj  i e) ))  )]\n  (fn ps [s] (cond\n                  (empty? s) #{#{}}\n                  true (clojure.set/union (aldoniEl (first s) (ps (rest s))) (ps (rest s)))))\n)", "user": "5576e78de4b05c286339e075"}, {"problem": 85, "code": "(letfn [(subsets [n items]\n            (cond\n                  (= n 0) '(())\n                  (empty? items) '()\n                  :else (concat (map\n                                     #(cons (first items) %)\n                                     (subsets (dec n) (rest items)))\n                                (subsets n (rest items)))))]\n    (fn [coll]\n      (->>\n        (reduce #(concat %1 (subsets %2 (seq coll))) [] (range 1 (inc (count coll))))\n        (cons '())\n        (map set)\n        (set))))", "user": "55aa1637e4b0988bba2ad949"}, {"problem": 85, "code": "(fn [s] (reduce (fn [p f] (into p (map #(conj % f) p))) #{#{}} s))", "user": "55be39f9e4b01b9910ae2a06"}, {"problem": 85, "code": "(fn [s]\n  (loop [[item & items] (seq s) result [#{}]]\n    (if (nil? item)\n      (into #{} result)\n      (recur items (concat result (map #(conj % item) result))))))", "user": "559b55d6e4b066d22e731f54"}, {"problem": 85, "code": "(fn [sets]\n  (letfn [(drop-one [sets]\n            (set (mapcat (fn [x] (map (partial disj x) x)) sets)))]\n    (loop [acc #{sets}]\n      (if (contains? acc #{})\n        acc\n        (recur (reduce conj (drop-one acc) acc))))))", "user": "555f3bfde4b0a2eb076a39c1"}, {"problem": 85, "code": "(fn [s]\n  (set (reduce (fn [subsets element]\n                 (concat subsets (map #(conj % element) subsets)))\n               [#{}]\n               s)))", "user": "5424c523e4b01498b1a71b03"}, {"problem": 85, "code": "(fn [x]\n  (reduce (fn [ps elem]\n            (into ps (map (fn [y] (conj y elem))\n                          ps)))\n          #{#{}}\n          x))", "user": "55c4e48be4b0e31453f649a7"}, {"problem": 85, "code": "(fn [coll]\n\t(loop [s #{#{}}]\n\t\t(let [ret (into s (for [a s x coll] (conj a x)))]\n\t\t\t(if (= ret s)\n\t\t\t\tret\n\t\t\t\t(recur ret)))))", "user": "55b8c339e4b01b9910ae29b9"}, {"problem": 85, "code": "(fn powerset [s] (reduce (fn [ps e] (reduce #(conj %1 (conj %2 e)) ps ps)) #{#{}} s))", "user": "55c10409e4b01b9910ae2a2c"}, {"problem": 85, "code": "(fn powerset [coll]\n  (reduce \n   (fn [r v]\n     (into r (map #(conj % v) r)))\n   #{#{}}\n   coll))", "user": "55c0afa5e4b01b9910ae2a27"}, {"problem": 85, "code": "(fn pset [s]\n  (if (empty? s) \n    (conj #{} s)\n    (let [half (pset (set (rest s)))]\n      (into half (set (map #(conj % (first s)) half))))))", "user": "559454f2e4b0c79f6e1db952"}, {"problem": 85, "code": "reduce (fn [a x]\n            (->> a\n                 (map #(set (concat #{x} %)))\n                 (concat a)\n                 set))\n          #{#{}}", "user": "53572176e4b04ce2eb3ed276"}, {"problem": 85, "code": "(fn [s]\n  (let [n\n          (count s)\n        bin->r-selector\n          (fn [b]\n            (loop [selector [], b b]\n              (if (= 0 b)\n                selector\n                (recur (conj selector (-> b (bit-and 1) zero? not)) (bit-shift-right b 1)))))\n        r-select\n          (fn [r-sq r-selector]\n            (-> (map #(when %1 %2) r-selector r-sq) set (disj nil)))\n        pow-set\n          (for [i (range (bit-shift-left 1 n))]\n            (r-select s (bin->r-selector i)))]\n    (set pow-set)))", "user": "5416b4a2e4b01498b1a71a01"}, {"problem": 85, "code": "(fn [s]\n  (loop [s (seq s)\n         a #{#{}}]\n    (if (empty? s)\n      a\n      (recur (next s)\n             (clojure.set/union a\n                                (reduce #(conj %1 (conj %2 (first s)))\n                                        #{} a))))))", "user": "549c6792e4b0f3d1d8e70f8b"}, {"problem": 85, "code": "reduce #(apply conj %1\n                (for [v %1]\n                  (conj v %2))) #{#{}}", "user": "55a372f1e4b0acc240e31537"}, {"problem": 85, "code": "reduce\n(fn [a x] (into a (map #(into #{x} %) a)))\n#{#{}}", "user": "4e6a4950535d8ccf87e9febf"}, {"problem": 85, "code": "(fn power-set\n  [a-set]\n  (loop [[x & xs] (vec a-set) res #{#{}}]\n    (if x\n      (recur xs (clojure.set/union res (map #(conj % x) res)))\n      res)))", "user": "550d9452e4b06e50f9beb15d"}, {"problem": 85, "code": ";using numbers as bit sets\n(fn [s]\n  (->> (range 0 (apply * (repeat (count s) 2)))                    ; 0 .. (2^n - 1)\n       (map #(keep-indexed (fn [i e] (when (bit-test % i) e)) s))  ; take elements where bit is set\n       (map set)\n\t   set))\n\n\n;recursive\n#_(fn powerset [s] \n  (if (zero? (count s))\n    #{#{}}\n    (let [x  (first s)\n          xs (rest s)\n          ss (powerset xs)]\n        (apply clojure.set/union ss\n           (for [sub ss] #{(conj sub x)}) ))))", "user": "55cdc576e4b0e31453f64a1f"}, {"problem": 85, "code": "(fn _ [s]\n  (if (empty? s) #{#{}}\n    (let [x (first s) n (_ (disj s x))]\n      (clojure.set/union n (for [i n] (conj i x))))))", "user": "54924f64e4b0b312c081ff42"}, {"problem": 85, "code": "(fn [s] (reduce (fn [acc v] (reduce (fn [acc* as] (conj (conj acc* as) (conj as v))) #{} acc)) #{#{}} s))", "user": "5339c105e4b0e30313ee6cae"}, {"problem": 85, "code": "(fn [s]\n  (letfn [\n    (nth-masked? [n mask]\n      (not= 0 (bit-and (bit-shift-left 1 n) mask)))\n    (bitmap-select [mask xs]\n      (map last (filter #(nth-masked? (first %1) mask) (keep-indexed #(vector %1 %2) xs))))\n    (combinations [xs]\n      (into #{} (map #(into #{} (bitmap-select % xs)) (range 0 (bit-shift-left 1 (count xs))))))\n    ]\n    (combinations s)))", "user": "55d5e80ee4b0e31453f64a91"}, {"problem": 85, "code": "(fn [s]\n  (reduce #(apply conj %1 (for [x %1] (conj x %2))) #{#{}} s)\n  )", "user": "55e1d34ae4b050e68259b421"}, {"problem": 85, "code": "(fn power-sets [x-set]\n  (letfn [(left-padding-seq [how-many padded]\n             (take how-many (lazy-cat (reverse (seq padded)) (repeat how-many 0))))\n          (to-binary [x]\n             (map #(Integer/valueOf (str %)) (seq (Integer/toBinaryString x))))\n          (gen-bit-combinations [x]\n             (let [bin-val (Math/pow 2 (count x-set))]\n                (map\n                   (fn [x] (->> x\n                               to-binary\n                               (left-padding-seq (count x-set))))\n                   (range 1 (inc bin-val)))))\n          (map-to-vals [x-set]\n             (map (fn [bit-pair]\n                    (apply hash-map (interleave (seq x-set) bit-pair)))\n                  (gen-bit-combinations (count x-set))))\n          (filter-maps-by-val [m-val m]\n              (map \n                 (fn [each-map] \n                   (reduce \n                      (fn [m entry] \n                        (if (zero? (val entry)) m \n                          (conj m entry))) \n                      {} each-map)) \n                 m))\n          (keys-to-sets [maps]\n            (map (comp set keys) maps))]\n    ((comp\n         set\n         keys-to-sets\n        (partial filter-maps-by-val 0) \n         map-to-vals) x-set)))", "user": "5553b729e4b0deb715856e05"}, {"problem": 85, "code": "(fn [input]\n(letfn [(pset [ls]\n          (if (empty? ls) '(())\n              (clojure.set/union (pset (next ls))\n                                 (map #(conj % (first ls)) (pset (next ls))))))]\n  (into #{} (map #(into #{} %) (pset input)))))", "user": "55b22c33e4b0da326a65cf79"}, {"problem": 85, "code": "#(set (reduce (fn [acc el] (concat acc (map\n                                    (fn [i] (conj i el)) \n                                    acc)\n                                  )) #{#{}} %))", "user": "4f88ae35e4b033992c121c6d"}, {"problem": 85, "code": "(fn power-set\n  [s]\n  (letfn [(add-element [e s] (map #(conj % e) s))\n          (add-elements [elements s] (if (= (count s) 0) (map hash-set elements) (distinct (flatten (map #(add-element % s) elements)))))]\n        (set (conj (last (take (inc (count s)) (iterate (partial add-elements s) #{}))) #{}))))", "user": "55acd080e4b03311e7b73298"}, {"problem": 85, "code": "(fn [s]\n  (loop [ps #{} ls #{#{}}]\n    (if (contains? ls s) (clojure.set/union ps ls)\n      (recur (clojure.set/union ps ls) (set (for [x ls y s] (conj x y)))))))", "user": "55c20bd0e4b0e31453f64972"}, {"problem": 85, "code": "(fn [s]\n  (letfn [(add [sos e] (into sos (map #(conj % e) sos)))]\n    (reduce add #{#{}} s)))", "user": "55dcb06ee4b050e68259b3b9"}, {"problem": 85, "code": "(letfn [(comb [n coll] (cond (zero? n) '(())\n                             (= n 1) (map list coll)\n                             :else (mapcat\n                                     (fn [[x & xs]] (map #(cons x %) (comb (dec n) xs)))\n                                     (take (- (count coll) (dec n)) (iterate rest coll)))))]\n  (fn [coll] (set (map set (mapcat #(comb % (seq coll)) (range (inc (count coll))))))))", "user": "55ccdc6be4b0e31453f64a18"}, {"problem": 85, "code": "reduce (fn [set x] (into set (map #(conj % x) set))) #{#{}}", "user": "554b8572e4b0a04f79299589"}, {"problem": 85, "code": "(fn [super-elems]\n    (nth\n     (iterate ((fn [top-elems]\n                 (fn [upper-set]\n                   (apply conj upper-set\n                          (for [set-member upper-set\n                                e top-elems]\n                            (conj set-member e))))) super-elems)\n              #{#{}})\n     (count super-elems)))", "user": "50981062e4b04e098a4c7268"}, {"problem": 85, "code": "(fn [s]\n   (reduce\n    #(clojure.set/union %1 (into #{} (for [subset %1] (conj subset %2))))\n    #{#{}}\n    s))", "user": "549dfe40e4b0f3d1d8e70f9a"}, {"problem": 85, "code": "(fn my-subs [s]\n  (reduce (fn [ret t]\n            (println ret t)\n              (set (concat ret (map #(conj % t) ret))))\n          #{#{}} (seq s)))", "user": "55d74e71e4b0e31453f64aa4"}, {"problem": 85, "code": "reduce (fn [e v] (into e (map #(conj % v) e))) #{#{}}", "user": "4f5eda39e4b0030a34fb2b56"}, {"problem": 85, "code": "(fn powerset [S]\r\n  (if (empty? S) #{#{}}\r\n      (reduce #(into %1\r\n                     #{%2 (into %2 #{(first S)})})\r\n              #{} (powerset (rest S)))))", "user": "55d0e76ae4b0e31453f64a40"}, {"problem": 85, "code": "(fn get-sub-set [initial-set]\n  (let [wait-set (into [] initial-set)]\n    (loop [result #{} init 0] \n      (if (>= init (apply * (take (count wait-set) (repeat 2))))\n        result\n        (recur (conj result \n                     (into #{} (filter #(not= nil %) \n                             (map #(if (= 1 %) %2)\n                                   (reduce #(conj % (- (int %2) 48)) [] (reverse (take (count wait-set) (reverse (str \"00000000000000\" (Integer/toBinaryString init))))))                                  wait-set))))\n               (inc init))))))", "user": "55a0d79fe4b0acc240e31502"}, {"problem": 85, "code": "(fn powerset [theset] (if (empty? theset) #{#{}} (let [firstelem (first theset) workingset (next theset)]\n(let [result (powerset workingset) combined (map #(conj % firstelem) result) \nthefinal (into #{} (concat result combined))]\nthefinal\n ))))", "user": "55f75c6be4b06e875b46cea9"}, {"problem": 85, "code": "(fn f [xs]\n  (set (reduce \n         (fn [s v] (concat s (map #(conj % v) s))) \n         [#{}] \n         xs)))", "user": "55ecb2c0e4b0121d4835fdce"}, {"problem": 85, "code": "(fn __\n  [s]\n  (reduce (fn [a x]\n            (->> a\n                 (map #(set (concat #{x} %)))\n                 (concat a)\n                 set))\n          #{#{}} s))", "user": "55a62092e4b0acc240e31554"}, {"problem": 85, "code": "(letfn [(power-set [ps [x & xs]]\n                    (if-not x\n                      [(set ps)]\n                      [(power-set ps xs)\n                       (power-set (conj ps x) xs)]))]\n   (fn [coll]\n     (->> coll vec (power-set []) flatten set)))", "user": "55f2e47de4b06e875b46ce4d"}, {"problem": 85, "code": "(fn prob85\n  [xs]\n  (set (map set \n            (if (empty? xs) \n              '(())\n              (clojure.set/union (prob85 (next xs))\n                                 (set (map #(conj % (first xs)) (prob85 (rest xs)))))\n              ))))", "user": "4ebbff41535dfed6da9c6d78"}, {"problem": 85, "code": "(fn [s]\n  (reduce \n    (fn [init e] \n      (set (concat init (map #(conj % e) init) [#{e}])))\n    #{#{}} s))", "user": "55e6c3f5e4b050e68259b48c"}, {"problem": 85, "code": "(fn [s]\n    (letfn [(subsets [[x & xs :as all] acc]\n              (cond\n                (nil? (seq all)) acc\n                :else (do (subsets (into [] xs)\n                                   (concat [[x]] acc (map #(conj % x) acc))))))]\n      (->> (subsets (into [] s) [])\n           (concat [[]])\n           (map set)\n           (into #{}))))", "user": "560e9a2de4b05f002753df52"}, {"problem": 85, "code": "(fn pset [s]\n   (cond\n     (= s #{}) #{#{}}\n     (= 1 (count s)) #{s}\n     (= 2 (count s)) #{ #{} #{(first s)} #{(second s)} s}\n     :else (let [subset (pset (into #{} (rest s)))] \n             (clojure.set/union  \n               subset\n               #{s}\n               (into #{} (map #(clojure.set/union #{(first s)} %) subset))))))", "user": "55f8b32ae4b03cbcff9738ba"}, {"problem": 85, "code": "(fn p [s]\n          (if (empty? s)\n            #{#{}}\n            (let [f (first s)\n                  r (rest s)]\n              (into (p r) (map #(conj % f) (p r))))))", "user": "527ccaf4e4b0757a1b17136d"}, {"problem": 85, "code": "(fn [s] ; for each element in set, we can choose put it in and not in\n  (reduce (fn [rs e]\n            (into rs (map #(conj % e) rs))); put into each element of rs\n          #{#{}} s) )", "user": "56051095e4b08b23635d3162"}, {"problem": 85, "code": "reduce (fn [s x]\n         (into s (map #(conj % x) s)))\n#{#{}}", "user": "548b8a50e4b0e286459a11ff"}, {"problem": 85, "code": "(letfn [(combinations-loop\n         [indices pool r n]\n         (when-first [i (filter #(not= (indices %) (-> % (+ n) (- r)))\n                                (reverse (range r)))]\n           (let [indices (->> (indices i) (inc) (assoc indices i))\n                 indices (reduce #(assoc %1 %2 (inc (%1 (dec %2))))\n                                 indices\n                                 (range (inc i) r))]\n             (cons (for [i indices] (pool i))\n                   (lazy-seq (combinations-loop indices pool r n))))))\n        (combinations\n         [coll r]\n         (let [pool (vec coll)\n               n (count coll)\n               indices (vec (range r))]\n           (when (and (> r 0) (<= r n))\n             (cons (for [i indices] (pool i))\n                   (lazy-seq (combinations-loop indices pool r n))))))]\n  (fn powerset [s]\n    (conj (set (mapcat #(map set (combinations s %))\n                       (range 1 (inc (count s)))))\n          #{})))", "user": "561ca2eae4b064ca9f4b169b"}, {"problem": 85, "code": "(fn [aset]\n  (reduce (fn [pset elem]\n            (into pset (map #(conj % elem) pset)))\n          #{#{}}\n          aset))", "user": "53576356e4b04ce2eb3ed27a"}, {"problem": 85, "code": "(fn [t]\n   (reduce \n    (fn [s e]\n      (into s (map #(into % [e]) s))) \n    #{#{}} t))", "user": "55b1e9e7e4b0da326a65cf74"}, {"problem": 85, "code": "(fn combinations [c]\n  (reduce (fn [acc it]\n            (set (concat acc (map #(conj % it) acc) #{#{it}})))\n          #{#{}} c))", "user": "561ba3e5e4b073c65b0ce3eb"}, {"problem": 85, "code": "(fn power-set\n   ([s] (power-set s #{#{}}))\n   ([s acc]\n    (if (empty? s) acc\n                 (power-set\n                   (rest s)\n                   (into (conj acc (hash-set (first s))) (for [e acc] (conj e (first s))))))\n     )\n   )", "user": "55f2c898e4b06e875b46ce4b"}, {"problem": 85, "code": "(fn [coll]\n    (set (map set  (reduce (fn [accum x]\n                             (concat accum (map #(cons x %) accum)))\n                           #{#{}}\n                           coll)))\n    )", "user": "4f5e5975e4b0030a34fb2b4d"}, {"problem": 85, "code": "(fn powerset\n  [s]\n  (if (empty? s)\n    #{#{}}\n    (let [p (powerset (rest s))]\n      (clojure.set/union p\n       (into #{} \n             (map #(conj % (first s)) p))))))", "user": "5606d71ce4b08b23635d317a"}, {"problem": 85, "code": "(fn powerset\n  [s]\n  (let [ss (vec s)]\n   (letfn [(isbitset [value posi] (not= 0 (bit-and value (bit-shift-left 1 posi))))]\n     (set (for [i (range 0 (int (Math/pow 2 (count s))))]\n        (set (filter identity (for [j (range 0 (count s))]\n                                (if (isbitset i j) (ss j))))))))))", "user": "561ca6ebe4b064ca9f4b169c"}, {"problem": 85, "code": ";(fn power-set\n;  [original-set]\n;  (letfn [(pow [a b] (apply * (repeat b a)))\n;          (binary-vector ;; binary number vectors, which can be used to quickly generate a power set\n;            [n v]\n;            (let [powers-2 (into [] (for [i (range (count v))]\n;                                      (assoc v (- (dec (count v)) i) 1)))]\n;              (loop [remaining-n n v' v]\n;                (let [remaining-n' (last (take-while #(>= remaining-n (pow 2 %)) (range)))\n;                      v' (mapv + v' (powers-2 remaining-n'))\n;                      remaining-n' (- remaining-n (pow 2 remaining-n'))]\n;                  (if (pos? remaining-n')\n;                    (recur remaining-n' v')\n;                    v')))))]\n;    (let [elements (into [] original-set)\n;          zero-vector (into [] (map (constantly 0) elements))\n;          binary-numbers (cons zero-vector (map (memoize #(binary-vector % zero-vector)) (range 1 (pow 2 (count elements)))))]\n;      (set (for [number binary-numbers]\n;                  (set (filter (comp not nil?) (map #(if (= (number %) 1) (elements %)) (range (count number))))))))))\n(fn power-set [s]\n  (loop [acc (hash-set #{}) added acc]\n    (if-let [to-add\n             (seq (for [subset added \n                        e s\n                        :when (not (subset e))]\n                    (conj subset e)))]\n      (recur (into acc to-add) (set to-add))\n      (into acc added))))", "user": "55a9e0fee4b0988bba2ad945"}, {"problem": 85, "code": "(fn powset [s]\n    (if (= #{} s) #{#{}}\n                  (let [e (first s)\n                        ss (set (rest s))\n                        pss (powset ss)\n                        ]\n                    (clojure.set/union pss (map #(clojure.set/union #{e} (set %1)) pss))\n                    )\n                  )\n  )", "user": "55aa5f73e4b0988bba2ad94b"}, {"problem": 85, "code": "(fn powerSet[s]\n  (set (map set\n   (reduce\n    (fn [l x]\n      (vec (concat l (vec (map #(conj % x) l))))) [[]] s))))", "user": "5626447fe4b00e49c7cb47bd"}, {"problem": 85, "code": "(fn gen-powerset [s]\n  (letfn [(pow2 [n] (reduce * (take n (repeat 2))))\n          (bitmask [n] (map #(bit-test n %) (range)))]\n    (set (for [x (range (pow2 (count s)))]\n           (set (remove nil? (map (fn [el_s bit-present]\n                                    (if (true? bit-present)\n                                      el_s))\n                                  s (bitmask x))))))))", "user": "561d23e3e4b064ca9f4b16a5"}, {"problem": 85, "code": "(fn [s] \n  (let [m (loop [s s k 1 r {}] (if (empty? s) r  (recur (rest s) (bit-shift-left k 1) (assoc r k (first s)))))\n        c (apply max 0 (keys m))]\n       (set (map \n             (fn[el] \n               (into #{} (filter #(not (nil? %)) \n                       (map #(if (not (zero? (bit-and el %))) (get m %) nil) \n                            (keys m)\n                       )\n               ))\n             ) \n             (range (bit-shift-left (inc c) 1))\n            )\n       )\n  )  \n)", "user": "55eeb37ae4b0121d4835fdf3"}, {"problem": 85, "code": "(fn subsets [s]\n  (if (empty? s)\n    #{#{}}\n    (let [subs (subsets (rest s))\n          f (first s)]\n      (clojure.set/union #{#{f}}\n                         subs\n                         (set (map #(conj % (first s)) subs))))))", "user": "541709b0e4b01498b1a71a06"}, {"problem": 85, "code": "(fn [bs]\n  (into #{}\n   (reduce\n    (fn [a m] (concat a (map #(conj % m) a))) #{#{}} bs)))", "user": "559a9a3de4b066d22e731f45"}, {"problem": 85, "code": "(fn pset [x]\n  (if (seq x)\n    (let [y (pset (rest x))]\n      (into y (map #(conj % (first x)) y)))\n    #{#{}}))", "user": "55f20e4be4b06e875b46ce40"}, {"problem": 85, "code": "reduce (fn [ps x] \n         (reduce #(conj %1 (conj %2 x)) \n                 ps ps)) \n       #{#{}}", "user": "52b02329e4b0c58976d9acc5"}, {"problem": 85, "code": "reduce (fn [P s] (into P (map #(conj % s) P))) #{#{}}", "user": "55f6fe09e4b06e875b46cea2"}, {"problem": 85, "code": "(fn [s]\n     (->> s\n          count\n          (Math/pow 2)\n          range\n          (map (fn %b [num] (if (> num 0) (conj  (%b (int (/ num 2))) (mod num 2)) [])))\n          (map reverse)\n          (map (fn [bs] (keep identity (map #(if-not (zero? %2) %1) s bs))))\n          (map set)\n          set))", "user": "56018dd4e4b04bb52996e18f"}, {"problem": 85, "code": "(fn [s]\n  (reduce\n    (fn [acc x]\n      (apply conj acc\n             (map #(conj % x) acc)))\n    #{#{}} s))", "user": "562cd94ee4b0a45d2ff83015"}, {"problem": 85, "code": "(fn [s]\n  (loop [s s \n         p #{#{}}]\n    (if (empty? s) \n      p\n      (recur \n        (rest s) \n        (into p\n          (for [s s \n                p p] \n            (conj \n              p \n              s)))))))", "user": "561047eae4b05f002753df6d"}, {"problem": 85, "code": "(fn power-set [x]\n  (if (empty? x) #{#{}}\n    (let [sub (power-set (rest x))]\n      (into sub (map #(conj % (first x)) sub)))))", "user": "4f6ba7bce4b07046d9f4efb0"}, {"problem": 85, "code": "(fn [the-set] (->> (iterate (fn [x]\n                              (into #{} \n                                    (apply concat\n                                           (for [entry the-set]\n                                             (for [item x\n                                                   :let [result (conj item entry)]]\n                                               result))))) #{#{}})\n                   (take (count the-set))\n                   (apply clojure.set/union)\n                   (#(conj % the-set))))", "user": "54db3d82e4b024c67c0cf75f"}, {"problem": 85, "code": "(fn powerset [s]\n  (if (empty? s) '#{#{}}\n    (let [sp (powerset (next s))]\n    (clojure.set/union sp (map #(set (conj % (first s))) sp)))))", "user": "54b54d1be4b05787c3b1639c"}, {"problem": 85, "code": "(fn [s]\n (loop [s s r (conj #{s} #{})]\n      (if (empty? s) r\n        (recur (rest s) (into r (set (map #(conj % (first s)) r)))))))", "user": "561a1af6e4b053970a773b02"}, {"problem": 85, "code": "(fn [s]\n  (letfn [(ps [ss]\n            (if (or (empty? ss) (ss s))\n              (into #{#{}} ss)\n              (let [ssn (set (for [ssa ss \n                                   ssb ss] \n                               (set (concat ssa ssb))))] \n                (ps ssn))))]\n    (let [ss (set (map (fn [x] #{x}) s))] (ps ss))))", "user": "4f0f01c0535d0136e6c22329"}, {"problem": 85, "code": "(fn power-set-fast [c]\n  (let [power-set-range (memoize (fn [n] (power-set-fast (range n))))\n        from-index (fn [c idxs]\n                     (set (for [idx idxs]\n                            (set (map (partial nth (vec c))\n                                      idx)))))]\n    (into #{#{}} (mapcat (fn [e]\n                           (map (comp set (partial cons e))\n                                (from-index c (power-set-range (dec (count c))))))\n                                        \n                         c))))", "user": "5492164ee4b0b312c081ff3e"}, {"problem": 85, "code": "(fn power-set [s]\n  (letfn [(subsetv [s bits]\n                   (set\n                     (remove nil?\n                             (map-indexed #(if (bit-test bits %) %2) s))))]\n    (let [v (vec s)\n          nn (bit-shift-left 1 (count s))]\n      (set\n        (map #(subsetv v %) (range nn))))))", "user": "53286f84e4b09d4e7a9b5505"}, {"problem": 85, "code": "(fn\n  [coll]\n  (reduce (fn [r e] (apply conj r (map #(conj % e) r))) #{#{}} coll))", "user": "563a30d7e4b0bfe05bf117f9"}, {"problem": 85, "code": "(fn [s]\n  (set\n   (loop [[x & xs] (seq s)\n          acc [#{}]]\n     (if x\n       (recur xs (concat acc (map #(conj % x) acc)))\n       acc))))", "user": "5573ffb5e4b0aa18f790f3fd"}, {"problem": 85, "code": "(fn power-set\n  [s]\n  (let [s-count (count s)\n        ps-count (bit-shift-left 1 s-count)\n        elements (vec s)]\n    (into #{} (for [n (range 0 ps-count)]\n                (->> (range 0 s-count)\n                     (remove #(zero? (bit-and n (bit-shift-left 1 %))))\n                     (map elements)\n                     set)))))", "user": "563f1493e4b08d4f616f5ecf"}, {"problem": 85, "code": "(fn [S] \n  (letfn \n    [(helper [res cur rems]\n         (if (empty? rems) (conj res cur)\n            (let [ added (helper res (conj cur (first rems)) (rest rems))\n                   skip  (helper res cur (rest rems))]\n\t\t\t   \n              (clojure.set/union added skip))))]\n            \n      (helper #{} #{} S)))", "user": "564127a9e4b08d4f616f5ef3"}, {"problem": 85, "code": "(fn power-set [s]\n  (letfn [(join-set [h t] (reduce #(conj %1 (conj %2 h)) #{} t))]\n    (if-let [h (first s)]\n      (into\n       (power-set (rest s))\n       (join-set h (power-set (rest s))))\n      #{#{}})))", "user": "51852961e4b0da5a5be3babb"}, {"problem": 85, "code": "(fn power-set\n  [s]\n  (let [k-combinations (fn k-combinations\n                         [k s]\n                         (if (= k 0)\n                           #{#{}}\n                           (conj (set (let [before (k-combinations (dec k) s)]\n                                        (for [s-e s\n                                              s-s before]\n                                          (conj s-s s-e)))) #{})))]\n    (k-combinations (count s) s)))", "user": "4fc524aae4b081705acca37e"}, {"problem": 85, "code": "(fn powerset [s]\n  (reduce \n   #(into % (for [subset %] (conj subset %2))) #{#{}} s))", "user": "5633bb9de4b0bfe05bf117b4"}, {"problem": 85, "code": "(fn pwr [s]\n  (if (empty? s)\n    #{#{}}\n    (let [ls (into '() s)\n          rst (into '() (pwr (set (rest ls))))]\n      (set (concat rst \n                   (map #(conj % (first ls)) rst))))))", "user": "541ef7e2e4b01498b1a71a92"}, {"problem": 85, "code": "#(reduce (fn [sets elem]\n            (reduce (fn [c n]\n                      (conj c (conj n elem))) sets sets))\n          #{#{}} %)", "user": "530b8580e4b02e82168697cc"}, {"problem": 85, "code": "(fn [s]\n  (loop [ps #{s}]\n    (if (ps #{})\n        ps\n        (recur\n          (into ps\n            (mapcat\n              (fn [ss]\n                (map #(disj ss %)\n                     s))\n              ps))))))", "user": "55d2dd27e4b0e31453f64a5b"}, {"problem": 85, "code": ";; Looked up solution :-/ Spent way too much time trying to figure this one out...\n\n(fn [s]\n  (letfn [(pow [s]\n            (loop [[f & r] (seq s)\n                   p '(())]\n              (if f\n                (recur r (concat p (map (partial cons f) p)))\n                p)))]\n    (set (map set (pow s)))))", "user": "515ebde3e4b01e5d11ccd0a8"}, {"problem": 85, "code": "reduce #(into % (map (fn [a] (conj a %2)) %)) #{#{}}", "user": "563dfc02e4b0da801c4e4662"}, {"problem": 85, "code": "(fn [s]\n  (let [v (vec s) c (count s)\n        ]\n   (apply hash-set (for [n (range (bit-shift-left 1 c))]\n     (apply hash-set (map #(v %)(filter #(bit-test n %) (range c))))\n     )))\n )", "user": "5649615be4b0284900eef641"}, {"problem": 85, "code": "(fn power [s]\n  (reduce (fn [sets e]\n            (clojure.set/union\n             sets\n             (map #(conj % e) sets))) #{#{}} s))", "user": "54ca93abe4b057c6fda3a264"}, {"problem": 85, "code": "(fn [a] \n     (set (reduce (fn [x y] (concat x (map #(conj % y) x))) #{#{}}  a)))", "user": "5654cb2de4b0f9d632dd848b"}, {"problem": 85, "code": "(fn [s]\n  (reduce (fn [ps e]\n            (->>\n              ps\n              (map #(set (concat #{e} %)))\n              (concat ps)\n              set))\n          #{#{}}\n          s))", "user": "55d28b38e4b0e31453f64a58"}, {"problem": 85, "code": "(fn powerset [set]\n  (if (empty? set)\n    #{#{}}\n    (let [p (powerset (rest set))]\n      (clojure.set/union p (map #(conj % (first set)) p)))))", "user": "56588f4ee4b0f9d632dd84b6"}, {"problem": 85, "code": "(fn [s]\n           (letfn [(add-1 [s m]\n                     ;;odd, into gave me trouble\n                     ;;(into s (map #(conj % m)) s)\n                     (clojure.set/union s (set (map #(conj % m) s)))\n                     )]\n             (loop [result (clojure.set/union #{#{}} (set (map #(set [%]) s)))\n                    tail s]\n               (if (empty? tail)\n                 result\n                 (recur (add-1 result (first tail)) (rest tail))\n)))\n           )", "user": "55f09e7be4b06e875b46ce28"}, {"problem": 85, "code": "(partial\n  (fn [result args]\n    (if (empty? args) result\n        (recur (clojure.set/union result\n                                  (map #(conj % (first args)) result))\n               (rest args))))\n  #{#{}})", "user": "54c5cc17e4b045293a27f624"}, {"problem": 85, "code": "(fn [s]\n  (set (reduce #(concat %1 (map (fn [i] \n                                  (set (conj i %2))\n                                  ) %1)) \n               #{#{}} s)))", "user": "5632d1b3e4b0bfe05bf117a9"}, {"problem": 85, "code": "(fn power-set [s]\n  (letfn [(connect [s]\n            (let [s' (into s (for [a s\n                                   b s\n                                   :when (not= a b)]\n                               (into a b)))]\n              (if (= s s')\n                s\n                (recur s'))))]\n    (connect (into #{#{}} (map #(set [%]) s)))))", "user": "5666500ee4b0e91d5f5c566d"}, {"problem": 85, "code": "(fn power-set [s]\n  (letfn [(subsets [n items]\n  (cond\n    (= n 0) '(())\n    (empty? items) '()\n    :else (concat (map\n                   #(cons (first items) %)\n                   (subsets (dec n) (rest items)))\n                  (subsets n (rest items)))))]\n  (set\n   (conj\n    (map set (apply concat\n                    (map #(subsets % s)\n                         (range 1 (count s)))))\n    #{} s))))", "user": "56504dc2e4b0284900eef6bc"}, {"problem": 85, "code": "(fn [weak-set]\n   (reduce \n    (fn [acc v] \n      (apply \n       (partial conj acc) \n       (map #(conj % v) acc))) \n    #{#{}} \n    weak-set))", "user": "567476bde4b05957ce8c6139"}, {"problem": 85, "code": "(fn power-set [s]\n  (if (empty? s)\n    #{s}\n    (let [f (-> s first hash-set)\n          p (power-set (into #{} (rest s)))]\n      (clojure.set/union #{f}\n                         (map #(clojure.set/union % f)\n                              p)\n                         p))))", "user": "5591cc56e4b0604b3f94d582"}, {"problem": 85, "code": "(fn power-set\n  [xs]\n  (cond\n    (empty? xs) #{#{}}\n    :else\n    (let [x (first xs)\n          remaining (power-set (rest xs))]\n      (clojure.set/union\n       remaining\n       (map #(conj % x) remaining)))))", "user": "504ee3b7e4b0e7ad84dbc4a3"}, {"problem": 85, "code": "(fn power-set [s]\n  (letfn [(next-power-set [previous origin]\n                          (into #{} \n                                (for [p previous o origin :when (not (contains? p o))] \n                                  (conj p o))))]\n    (into #{}\n          (reduce \n           concat \n           (take \n            (+ 1 (count s)) \n            (iterate #(next-power-set % s) #{#{}}))))))", "user": "5654e024e4b0f9d632dd848d"}, {"problem": 85, "code": "(fn power-set [s]\n  (if (empty? s)\n    #{#{}}\n    (clojure.set/union (power-set (rest s))\n           (map #(conj % (first s)) (power-set (rest s))))))", "user": "56288ccae4b00e49c7cb47ea"}, {"problem": 85, "code": "(fn ps\n        ([s] (ps s #{} #{}))\n        ([s es ss]\n         (loop [e (first s) re (disj s e) ss (conj ss es)]\n           (if (nil? e) ss\n             (recur (first re) (disj re (first re))\n                    (ps re (conj es e) ss))))))", "user": "544e6b7fe4b0e39780006986"}, {"problem": 85, "code": "(fn power-set [xset] \n  (letfn [(cross-list [x ylist] (concat (list (list x)) ylist (for [y ylist] (cons x y)))) \n          (power-list [xlist] (if (seq (rest xlist)) (cross-list (first xlist) (power-list (rest xlist))) (list xlist) ))]\n  (set (map set (cons '() (power-list xset)))) ))", "user": "550e52dbe4b06e50f9beb165"}, {"problem": 85, "code": "(fn d\n  ([s]\n   (d () s))\n  ([a s]\n   (into #{}\n     (map #(into #{} %)\n       (if (empty? s)\n         (list a)\n         (concat (d (conj a (first s)) (rest s))\n                 (d a (rest s))))))))", "user": "52bacfa8e4b07a9af57922d6"}, {"problem": 85, "code": "(fn [s]\n  (let [v (vec s)]\n    (set (for [i (range (int (Math/pow 2 (count v))))]\n           (set (keep-indexed\n                  #(when %2 (nth v %))\n                  (map (partial bit-test i) (range (count v)))))))))", "user": "554680cbe4b0a04f7929953e"}, {"problem": 85, "code": "#(letfn [(f [ps, e]\n           (into ps (for [s ps] (conj s e))))]\n   (reduce f #{#{}} %))", "user": "567695c2e4b05957ce8c6157"}, {"problem": 85, "code": "(fn powerset [s]\n  (reduce #(into % (for [subset %] (conj subset %2))) #{#{}} s))", "user": "56810479e4b0966858e4d8f8"}, {"problem": 85, "code": "(fn [coll]\n  (loop [incoming coll\n         counter (count coll)\n         outgoing #{#{}}]\n    (if (< counter 1)\n\t  (do \n\t  (prn \"its here\" counter (count coll))\n\t  (clojure.set/union outgoing #{#{}}))\n      (let [new-out (into #{} (for [x outgoing y incoming ] (clojure.set/union x #{y})))]\n\t\t(do\n\t\t(prn \"its here too...\")\n        (recur incoming\n               (dec counter)\n               new-out))))))", "user": "567d18c9e4b05957ce8c61c4"}, {"problem": 85, "code": "(fn [s]\n  (reduce (fn [acc x] (into acc (map #(conj % x) acc)))\n          #{#{}} s))", "user": "56897739e4b0dcc4269f407d"}, {"problem": 85, "code": "(fn [s]\n  (loop [q '(#{}) v #{}]\n    (let [[h & t] q\n          w (conj v h)]\n      (if\n        (empty? q) v\n        (recur (concat (remove v (map #(conj h %) s)) t) w)\n        ))))", "user": "4faf97d8e4b081705acca258"}, {"problem": 85, "code": "(fn power-set [xs]\n\t(if (= xs #{})\n\t\t#{#{}}\n\t\t(clojure.set/union \n\t\t\t(power-set (clojure.set/difference xs (take 1 xs)))\n\t\t\t(map clojure.set/union (repeat (set (take 1 xs)))\n\t\t\t\t(power-set (clojure.set/difference xs (take 1 xs)))))))", "user": "56540485e4b0f9d632dd847a"}, {"problem": 85, "code": "(fn f [s]\n  (if (empty? s)\n    #{#{}}\n    (set (concat (map #(conj % (first s)) (f (next s))) (f (rest s))))))", "user": "5657fed1e4b0f9d632dd84ae"}, {"problem": 85, "code": "#((fn f [[x & z]]\n  (if x\n    (into (f z) (for [y (f z)] (conj y x) ))\n    #{#{}})) (seq %))", "user": "53b15e6ee4b047364c04448f"}, {"problem": 85, "code": "(fn q4q085\n  [s]\n  \"Write a function which generates the power set of a given set. The power set of a set x is the set of all subsets of x, including the empty set and x itself.\"\n  (into\n   #{s}\n   ((fn inner [accum s-left]\n      (if (empty? s-left)\n        #{accum}\n        (let [pivot (first s-left)]\n          (->\n           (into #{} (inner (conj accum pivot) (disj s-left pivot)))\n           (into (inner accum (disj s-left pivot)))\n          )))\n      ) #{} s)))", "user": "52213426e4b0e6a83c8925c4"}, {"problem": 85, "code": "(fn powerset [x]\n  (if (empty? x)\n    #{ #{} }\n    (let [f (first x) r (rest x) pwr (powerset r)]\n      (into pwr (map #(conj % f) pwr))\n    )\n  )\n)", "user": "56979bb7e4b0e0b3d3318cac"}, {"problem": 85, "code": "(fn power-set [s]\n  (let [first (first s) subset (rest s)]\n    (if (empty? s) #{#{}}\n        (clojure.set/union\n         (into #{} (map #(clojure.set/union #{first} %) (power-set subset)))\n         (power-set subset)))))", "user": "5693a53ee4b0dcc4269f4106"}, {"problem": 85, "code": "(fn pow [X]\n  (if (empty? X)\n    #{#{}}\n    (let [P (pow (next X))]\n      (clojure.set/union P\n                         (map #(conj % (first X)) P)))))", "user": "567b39b6e4b05957ce8c61a3"}, {"problem": 85, "code": "(fn power-set [s]\n  (if (empty? s)\n    #{#{}}\n    (let [x (first s)\n          s1 (power-set (disj s x))\n          s2 (set (map #(conj % x) s1))]\n      (clojure.set/union s1 s2))))", "user": "54485749e4b032a45b8693c7"}, {"problem": 85, "code": "(fn power-set [s]\n  (cond\n   (empty? s) #{#{}}\n   :else (into #{} (concat (power-set (rest s))\n                           (map #(conj % (first s)) (power-set (rest s)))))))", "user": "553b0d95e4b09218d5f44fff"}, {"problem": 85, "code": "(fn [x](reduce (fn [a b] (into a (map #(into % #{b}) a))) #{#{}} x))", "user": "566a3a26e4b0a866af689699"}, {"problem": 85, "code": "(fn [ss]\n  (letfn [(kc [zs k z]\n            (apply conj (zs k) (map #(conj % z) (zs (dec k)))))\n          (combos [xs x]\n            (if (empty? xs)\n              (vector [#{x}])\n              (let [ys (vector (conj (xs 0) #{x}))\n                    n  (count xs)]\n                (loop [out ys i 1]\n                  (if (= i n)\n                    (conj out (vector (conj ((xs (dec i)) 0) x)))\n                    (recur (conj out (kc xs i x)) (inc i)))))))]\n     (set (conj (flatten (reduce combos [] ss)) #{}))))", "user": "564a5a09e4b0284900eef656"}, {"problem": 85, "code": "(fn power-set [original-set]\n  (let [somefunc\n        (fn [prev-set new-elmt]\n          (reduce (fn [ret x]\n                    (conj ret (conj x new-elmt)))\n                  prev-set\n                  prev-set))]\n    (if (empty? original-set)\n      #{#{}}\n      (let [s (seq original-set)]\n        (somefunc (power-set (set (rest s)))\n                  (first s))))))", "user": "55ba4a78e4b01b9910ae29cf"}, {"problem": 85, "code": "(fn power-set [original-set]\n  (let [somefunc\n        (fn [prev-set new-elmt]\n          (reduce (fn [ret x]\n                    (conj ret (conj x new-elmt)))\n                  prev-set\n                  prev-set))]\n    (if (empty? original-set)\n      #{#{}}\n      (let [s (seq original-set)]\n        (somefunc (power-set (set (rest s)))\n                  (first s))))))", "user": "5400e918e4b0de5c41848619"}, {"problem": 85, "code": "(fn ps[s]\n  (if (seq s)\n    (let [r (ps (rest s))]\n      (clojure.set/union r (map #(conj % (first s)) r)))\n    #{#{}}))", "user": "56824e1be4b0945ebc182a91"}, {"problem": 85, "code": "(fn f [s]\n  (if (empty? s)\n    #{s}\n    (let [t (-> s rest set f)]\n      (into (into #{} t) (map #(conj % (first s)) t)))))", "user": "52ae886de4b0c58976d9acab"}, {"problem": 85, "code": "(fn [s]\n  (let [p (fn [c n s]\n            (cond (zero? n) (assoc c 0 #{})\n                  (= n 1) (assoc c 1 (set (map hash-set s)))\n                  :else (assoc c n\n                                 (reduce into #{}\n                                         (for [i s]\n                                           (map #(conj % i) (c (dec n))))))))]\n    (reduce into (set [#{} s]) (vals (reduce #(p % %2 s) {} (range (count s)))))))", "user": "56874171e4b0dcc4269f405c"}, {"problem": 85, "code": "(fn [t]\n  (reduce \n    (fn [a b] (clojure.set/union a \n\t  (set (map (fn [y] (clojure.set/union #{b} y)) a))))\n#{#{}} t))", "user": "5578f292e4b05c286339e08f"}, {"problem": 85, "code": "(fn [h]\n\t(let [\n\t\t    s (into [] h)\n\t\t    n (count s)\n\t\t    pad (fn [st](str (reduce str (repeat (- n (count st)) \"0\")) st) )\n\t\t    decode (fn [st] (set (remove nil? (map-indexed #(if (= \\1 %2) (nth s %1 ) nil) (pad st)))))\n\t\t    data  (for [ i (range 0 (Math/pow 2 n))] (decode (Integer/toBinaryString i)))\n\t\t ]\n\t\t (set data)\n\t)\n)", "user": "56be240ce4b0f2655033597f"}, {"problem": 85, "code": "(fn p [s]\n  (reduce #(into % (for [sub %] (conj sub %2))) #{#{}} s))", "user": "56bca51ae4b0f26550335963"}, {"problem": 85, "code": "(fn [all]\n  (loop [built (hash-set all)]\n    (let [new (into built (for [x built s all] (disj x s)))]\n      (if (= new built) built\n        (recur new)))))", "user": "56bb9ccce4b0f26550335959"}, {"problem": 85, "code": "(fn powerset [input] (cond (empty? input) #{#{}}\n                            :else (let [e (first input) t (disj input e)]\n                                    (clojure.set/union\n                                      (powerset t)\n                                      (into (map #(conj % e)  (powerset t)) #{})))))", "user": "56427910e4b08d4f616f5f19"}, {"problem": 85, "code": "(fn powersetbinX[s]\n\t(let [\n\t\tlength (count s)\n\t\tbinaryLength (int (Math/pow 2 length))\n\t\tallBinaries (range 0 binaryLength)\n\t\tsVec (vec s)\n\t\t]\n\t\t(set (map (fn [b] ((fn binToSubset [b, sVec, length] \n\t(set (map (fn[n] (get sVec n))\n\t\t(filter (fn[n] (bit-test b n)) (range 0 length))\n\t)))\n b sVec length)) allBinaries))\n\t\t)\n)", "user": "568820e8e4b0dcc4269f4067"}, {"problem": 85, "code": "(fn solve [s]\n  (set\n   (reduce (fn [res x]\n             (concat res\n                     (map #(set (conj % x)) res)))\n           #{#{}}\n           s)))", "user": "56444fb1e4b0018b46ad8c0c"}, {"problem": 85, "code": "(fn gen-pow-set\n  [s]\n  (if (empty? s)\n    #{#{}}\n    (let [e (first s)\n          rs (gen-pow-set (disj s e))]\n      (apply conj rs (map #(conj % e) rs)))))", "user": "56a36f76e4b0542e1f8d14ca"}, {"problem": 85, "code": "(fn [ss]\n  (let [v (vec ss)]\n    (letfn [(k [n]\n              (set (filter (complement nil?)\n                      (map #(if (= %1 \\1) %2 nil)\n                           (reverse (Integer/toBinaryString n)) v))))]\n      (set (map k (range 0 (Math/pow 2 (inc (count v)))))))))", "user": "56a01895e4b0542e1f8d149f"}, {"problem": 85, "code": "(fn p [s]\r\n  (if (empty? s) #{#{}}\r\n    (#(clojure.set/union % (map (fn [x] (conj x (first s))) %))\r\n      (p (rest s)))))", "user": "566470b9e4b0e91d5f5c5658"}, {"problem": 85, "code": "reduce (fn [coll v] (into coll (map #(conj % v) coll))) #{#{}}", "user": "56ae214ce4b03c432f18735a"}, {"problem": 85, "code": "(fn [s]\n  (letfn [(pow [^long a ^long b]\n            (loop [res 1\n                   i b]\n              (cond\n                (= i 0) res\n                :else (recur (* res a) (dec i)))))]\n    (let [sr (into [] s)]\n      (set (for [n (range (pow 2 (count sr)))]\n             (set (filter identity\n                          (map-indexed (fn [i elem]\n                                         (if (bit-test n i)\n                                           elem\n                                           nil))\n                                       sr))))))))", "user": "5638b88de4b0bfe05bf117e9"}, {"problem": 85, "code": "(fn power-set [coll]\n  (if (empty? coll)\n    #{#{}}\n    (let [x (first coll)\n          power-set' (power-set (rest coll))\n          power-set'-with-x (map #(conj % x) power-set')]\n      (apply hash-set (concat power-set' power-set'-with-x)))))", "user": "56488119e4b0284900eef632"}, {"problem": 85, "code": "(fn [s]\n  (into #{}\n        (for [x (range (Math/pow 2 (count s)))]\n          (into #{} \n                (keep-indexed #(if (bit-test x %1) %2) s)))))", "user": "56b86e64e4b0f26550335924"}, {"problem": 85, "code": "(fn [s] (let [m (set (map #(conj #{} %) s))] (conj (reduce (fn [i e] (reduce #(conj % (into %2 e)) i i)) m m) #{})))", "user": "56c08696e4b060a8e693e3aa"}, {"problem": 85, "code": "(fn powerset [s] \n  (reduce #(into % (for [subset %] (conj subset %2))) #{#{}} s))", "user": "567931e9e4b05957ce8c6184"}, {"problem": 85, "code": "(fn [xs]\n  (reduce (fn [r x]\n            (->> r\n                 (map #(conj % x))\n                 (into r)))\n          #{#{}} xs))", "user": "56795deae4b05957ce8c6187"}, {"problem": 85, "code": "(fn [s]\n  (reduce (fn [agg x]\n            (clojure.set/union agg\n                               (map #(conj % x)\n                                    agg)))\n          #{#{}}\n          s))", "user": "55f73078e4b06e875b46cea4"}, {"problem": 85, "code": "(fn [s]\n   (reduce (fn [result next]\n             (clojure.set/union result\n                                (map #(conj % next)\n                                     result))) \n           #{#{}}\n           s))", "user": "56d4b22de4b0ea9b8538f7bb"}, {"problem": 85, "code": "(fn [s]\n   (reduce #(into %1 (map (fn [s'] (conj s' %2)) %1)) #{#{}} s))", "user": "56481722e4b0284900eef628"}, {"problem": 85, "code": "reduce\n  (fn [a x] (into a (map #(conj % x) a)))\n  #{#{}}", "user": "51db0d99e4b06aa4d4669a9d"}, {"problem": 85, "code": "(fn [s] \n  (set \n   (for [x (range (Math/pow 2 (count s)))]\n     (set (mapcat #(if (= \\1 %1) [%2]) (concat (reverse (Long/toBinaryString x)) (repeat \\0)) s)))))", "user": "56baa68ce4b0f26550335947"}, {"problem": 85, "code": "(fn pset [x]\n  (if (empty? x)\n    #{#{}}\n    (clojure.set/union (pset (next x))\n                       (map #(conj % (first x)) (pset (next x))))))", "user": "56d5fd24e4b0ea9b8538f7c5"}, {"problem": 85, "code": "(fn [x] (loop [s (seq x), r '()]\n         (if (empty? s) (into #{} (cons #{} r))\n          (recur (rest s) (concat #{#{(first s)}} r\n             (map (fn [y] (clojure.set/union #{(first s)} y)) r))) )))", "user": "4fd11a93e4b04c3a95aa040a"}, {"problem": 85, "code": "(fn powerset [col]\n  (letfn [(add-to-each [col x] (for [y col] (clojure.set/union y #{x})))]\n    (let [x (first col)\n          xs (rest col)]\n      (if (nil? x) #{#{}}\n                   (if-not (seq xs)\n                     #{#{x} #{}}\n                     (let [ps (powerset xs)\n                           added (add-to-each ps x)]\n                       (clojure.set/union\n                         ps\n                         added)))))))", "user": "54857657e4b0e286459a11ac"}, {"problem": 85, "code": "(fn powerset [s]\n  (reduce #(into % (for [subset %] (conj subset %2))) #{#{}} s))", "user": "56dc483fe4b0ea9b8538f81b"}, {"problem": 85, "code": "(fn solve [x]\n  (let [a (apply vector x)]\n\t(set\n\t    (for [mask (range (bit-shift-left 1 (count x)))]\n\t\t\t(set\n\t\t\t    (for [idx (filter #(not= 0 (bit-and mask (bit-shift-left 1 %))) (range (count a)))]\n\t\t\t      (nth a idx)   \t   \n\t\t\t    )\n\t\t\t)\n\t    )\n\t)\n  )\n)", "user": "56f258d3e4b04a395b9a04a1"}, {"problem": 85, "code": "(fn [s]( if(empty? s) #{s}\n         (loop [ x s y 0 cnt 0]\n          ;(println x (count x) y cnt)\n         (if (= y (count x)) x\n          (recur\n           ;x\n          (conj (set(flatten(map\n\t\t          (fn[i]( map \n                      (fn[j](\n                              cond\n                                (and (set? i) (set? j)) (clojure.set/join i j)\n                                (set? i) (conj i j)\n                                (set? j) (conj j i)\n                                :else (set [i j])\n                      )) \n                      x \n              ))\n           s))) #{} s)\n           ;y\n            (count x)\n            ;cnt\n            (inc cnt)\n          )\n         ))\n))", "user": "56039843e4b04bb52996e1be"}, {"problem": 85, "code": ";; top-down approach (timed out version)\n;; (fn powerset [arg] (reduce (fn [acc e]\n;;                               (print \"acc\" acc \"\\targ\" arg \"\\te\" e \"\\n\")\n;;                               (clojure.set/union (conj acc arg)\n;;                                                  (powerset (disj arg e)))) #{#{}} arg))\n\n;; bottom-up approach\n(partial reduce (fn [acc e] (into acc (map #(conj % e) acc))) #{#{}})", "user": "56f7ecdfe4b08e7d20b96834"}, {"problem": 85, "code": "(fn power-set [col]\n  (letfn [(power-set-helper [sets acc col]\n            (if-let [v (first col)]\n              (concat sets (power-set-helper sets (conj acc v) (next col))\n                      (power-set-helper sets acc (next col)))\n              (conj sets acc)))]\n    (set (power-set-helper []  #{} (seq col)))))", "user": "569dd6e8e4b0542e1f8d1480"}, {"problem": 85, "code": "(fn [s]\n    (let [indexed (into {} (map-indexed vector s))\n          m (apply max 0 (keys indexed))\n          bits (fn [n] (map\n                        #(first %)\n                        (filter #(= \\1 (second %)) (map-indexed vector (reverse (Integer/toString n 2))))))]\n    (into #{}\n      (map #(->> (bits %) (select-keys indexed) (map second) (into #{}))\n      (range (Math/pow 2 (inc m)))))))", "user": "56d68cbae4b0ea9b8538f7cd"}, {"problem": 85, "code": "(fn sup [coll]\n  (reduce (fn [coll, x] (clojure.set/union coll (set (for [subset coll] (conj subset x))))) #{#{}} coll)\n  )", "user": "56f15eade4b04a395b9a048e"}, {"problem": 85, "code": "(fn joined [sets]\n   (let [f (first sets)\n         r (rest sets)]\n      (cond\n        (empty? sets) #{#{}}\n        (nil? f) #{#{}}\n        :else (set (concat (map #(conj % f) (joined r)) (joined r))))))", "user": "56fbf83de4b07572ad1a88da"}, {"problem": 85, "code": "(fn power-set [s]\n    (set\n     (conj\n      (if (empty? s) #{}\n          (let [e (first s)\n                t (disj s e)\n                pt (power-set t)]\n            (cons t (concat pt (map #(conj % e) pt)))))\n      s)))", "user": "4f57c913e4b0a7574ea7183f"}, {"problem": 85, "code": "(fn [s]\n  (reduce (fn [s x] (into s (map #(conj % x) s))) #{#{}} s))", "user": "57035ccfe4b08d47c97781ef"}, {"problem": 85, "code": "(fn powerset [originalset]\n\t(loop [s originalset\n         pwrset (conj #{s} #{})]\n      (if (empty? s)\n          pwrset\n        (recur (rest s) (into pwrset (set (map #(conj % (first s)) pwrset))) ))))", "user": "5703ce0fe4b08d47c97781fd"}, {"problem": 85, "code": "(fn power-set \n  [s]\n  (into #{} \n        (reduce (fn \n                  [ss x] \n                  (concat ss (map #(conj % x) ss)))\n                [#{}] s)))", "user": "5564709ee4b0c656e3ff1807"}, {"problem": 85, "code": "(fn powerset [s]\n\t(loop [s s\n         ; Initialise set with empty set and full set\n         acc (conj #{s} #{})]\n      (if (empty? s)\n          ; Return the set\n          acc\n        ; Get the first vale in set s, conj it with the next element of acc and put it into the acc set\n        (recur (rest s) (into acc (set (map #(conj % (first s)) acc))) ))))", "user": "570b7d48e4b0b0fb43fd06c0"}, {"problem": 85, "code": "(fn [s]\n  (reduce (fn [coll e] (into coll (map #(conj % e) coll))) #{#{}} s))", "user": "570e4615e4b0b0fb43fd06ec"}, {"problem": 85, "code": "(fn gen-power-set [x]\n  (letfn [(get-sets [a-set n acc]\n            (if (= n (count a-set))\n              (conj acc a-set)\n              (let [n-set (filter #(= n (count %)) acc)\n                    add-set (set (for [x n-set\n                                       y (seq a-set)]\n                                   (conj x y)))]\n                (recur a-set (inc n) (clojure.set/union acc add-set)))))]\n    (get-sets x 0 #{#{}})))", "user": "54f86b8ce4b01ecee9d88828"}, {"problem": 85, "code": "(fn ss\n  ([coll]\n   (conj (set (ss #{} coll)) #{}))\n  ([s coll]\n   (when (seq coll)\n     (let [sublists (take (count coll) (iterate rest (seq coll)))]\n       (mapcat (fn [[x & xs]]\n                 (let [item (conj s x)]\n                   (cons item\n                         (ss item xs))))\n               sublists)))))", "user": "53b530c6e4b047364c0444bc"}, {"problem": 85, "code": "(fn [xs]\n  (letfn [(powerset [xs acc]\n            (if (empty? xs)\n              acc\n              (concat (conj acc #{(first xs)})\n                      (reduce #(conj % %2 (conj %2 (first xs)))\n                              #{}\n                              (powerset (rest xs) acc)))))]\n    (set (conj (powerset xs #{}) #{}))))", "user": "549eb44fe4b0f3d1d8e70fa6"}, {"problem": 85, "code": "#(let [fa (atom nil)\n              f (fn [s]\n                  (cond\n                    (empty? s) #{#{}}\n                    (= 1 (count s)) (set [#{} s])\n                    :else\n                    (apply conj #{s} (mapcat @fa (for [i s] (disj s i))))))]\n         (reset! fa (memoize f))\n         (@fa %))", "user": "56a76f36e4b07966d5a8a05b"}, {"problem": 85, "code": "(fn pow [s]\n  (if (empty? s)\n    #{#{}}\n    (let [lastpow (pow (rest s))]\n      (into lastpow\n       (map #(conj % (first s))\n            lastpow\n            )\n       ))\n      \n      )\n    \n    )", "user": "57011eb3e4b08d47c97781d1"}, {"problem": 85, "code": "(fn [s] (loop [res #{#{}},remain s] (if (empty? remain)\n                                       res\n                                       (recur (apply conj res (map #(conj % (first remain)) (conj res \n                                                                                                                 (hash-set (first remain))\n                                                                                                                 ))) (rest remain)) )  ) )", "user": "56a6051fe4b0542e1f8d14e5"}, {"problem": 85, "code": "(fn [s]\n  (-> (reduce \n       (fn [r _]\n         (into #{} (for [i s\n                         si r]\n                     (conj si i)) ))\n       #{#{}}\n       s)\n      (conj #{} s)))", "user": "4dbecb06535d020aff1edf6a"}, {"problem": 85, "code": "(fn [s]\n  (->> #{ #{} }\n       (iterate #(->> %\n                      (mapcat (fn [x]\n                                (for [e (disj s x)]\n                                  (conj x e))))\n                      set))\n       (take (inc (count s)))\n       (apply concat #{s})\n       set))", "user": "5712854ce4b07c98581c3a89"}, {"problem": 85, "code": "(fn [a-set]\n  (loop [lset a-set acc (conj #{#{}} a-set)]\n    (if (empty? lset)\n      acc\n      (let [this-set (set (list (first lset)))\n            set-seq (for [s acc] (clojure.set/union s this-set))]\n        (recur (rest lset) (apply (partial conj acc) set-seq))))))", "user": "56cb4d06e4b0ea9b8538f72e"}, {"problem": 85, "code": "(fn [my-set]\n  (loop [sets (set (map #(disj my-set %) my-set)) acc #{my-set}]\n    (if (empty? (first sets))\n      (conj acc #{})\n      (recur (set (flatten (map (fn [s] (map #(disj s %) s) ) sets))) (into acc sets)))))", "user": "55f8fd70e4b03cbcff9738bc"}, {"problem": 85, "code": "(fn power-set [st]\n  (if (empty? st)\n    #{#{}}\n    (let [fst (first st)\n          left-power-set (power-set (rest st))]\n      (clojure.set/union left-power-set\n                         (map #(conj % fst) left-power-set)))))", "user": "568e1871e4b0dcc4269f40cc"}, {"problem": 85, "code": "(fn ps [s]\n  (reduce\n   (fn [res el]\n     (into res\n           (map #(conj % el) res)))\n   #{#{}} s))", "user": "571d063ee4b0145328a76272"}, {"problem": 85, "code": "(fn [input]\n   (let [union clojure.set/union]\n     (reduce\n       (fn [value item] (into value (map #(conj % item) value)))\n       #{#{}} input)))", "user": "529e8ba9e4b04e0c58e87b99"}, {"problem": 85, "code": "#(let [ \n\t\tnums (range (Math/pow 2 (count %)))\n\t\tv (vec %)\n\t\tproduce-set (fn [tpl](set (keep-indexed (fn [idx el] (if (pos? (bit-and tpl (bit-shift-left 1 idx))) el)) v)))\n\t]\n\t(set (map produce-set nums))\n\t)", "user": "52570aeae4b0541d1855ba42"}, {"problem": 85, "code": "(fn z [a]\n  (let [r (fn[x] (reduce #(conj %1 (disj x %2)) #{} x))\n        w (fn[coll] (reduce #(clojure.set/union %1 (r %2)) #{} coll))\n       ]\n    \n    (loop [next_step #{a} result #{a}]\n      (if (contains? next_step #{})\n        result\n        (let [t (w next_step)]\n        (recur t (clojure.set/union result t) )\n        ))\n      \n      \n      )\n   \n   )\n  \n  \n  )", "user": "56db90d4e4b0ea9b8538f80d"}, {"problem": 85, "code": "(let [bits->indices (fn [n]\n                        (loop [x n, acc [], i 0]\n                          (if (zero? x)\n                            acc\n                            (let [q (quot x 2)\n                                  r (rem x 2)\n                                  acc' (if (= 1 r) (conj acc i) acc)]\n                              (recur q acc' (inc i))))))\n        f (fn [u]\n            (let [n (apply *' (repeat (count u) 2))\n                  v (vec u)]\n              (->> (for [b (range n)]\n                     (let [idxs (bits->indices b)]\n                       (->> (map (partial nth v) idxs)\n                            (into #{}))))\n                   (into #{}))))]\n    f)", "user": "53684a2fe4b0243289761e8c"}, {"problem": 85, "code": "(fn [s]\n  (set (reduce #(concat %1 (map (fn [i] (set (conj i %2))) %1)) #{#{}} s)))", "user": "56f4cedce4b046a417f92063"}, {"problem": 85, "code": "(fn f\n  ([s] (f s (conj #{#{}} s)))\n  ([s r]\n   (if (empty? s)\n     r\n     (recur (rest s) (into (conj r (set (vector (first s)))) (map #(set (into % (vector (first s)))) r))))))", "user": "56ab7578e4b03c432f18733d"}, {"problem": 85, "code": "(fn power-set\n   ([in]\n    (set (power-set in nil)))\n   ([in curr]\n    (let [new-curr (if curr (conj curr (first in)) #{})]\n      (reduce (fn [r skip]\n                (concat r (power-set (drop skip in) new-curr)))\n              [new-curr]\n              (range (if curr 1 0) (count in))))))", "user": "56dc3bdfe4b0ea9b8538f819"}, {"problem": 85, "code": "(fn power-set [superset]\n  (reduce (fn [base-set item]\n            (into base-set (map\n                            (fn [s] (conj s item))\n                            base-set)))\n          #{#{}}\n          superset))", "user": "563fc1f2e4b08d4f616f5ed7"}, {"problem": 85, "code": "(fn power-set\n  [x]\n  (letfn [(subsets\n            [x]\n            (concat\n             (map #(disj x %) x)\n             (map #(conj #{} %) x)))]\n    (loop [sets (set (subsets x)) agg #{}]\n      (if (every? #(contains? agg %) sets)\n        (into (into agg #{#{}}) #{x})\n        (recur (set (mapcat subsets sets)) (into agg sets))))))", "user": "4daeabf6edd6309eace4d15c"}, {"problem": 85, "code": "(fn [orig]\n  (reduce (fn [pset cset]\n    (reduce (fn [pset curr]\n      (conj pset (conj curr cset))) pset pset)) #{#{}} orig))", "user": "56d63729e4b0ea9b8538f7ca"}, {"problem": 85, "code": "(fn power [s]\n  (if (empty? s)\n    #{#{}}\n    (let [fst    (first s)\n          remain (disj s fst)\n          pow    (power remain)]\n      (into pow (map #(conj % fst) pow)))))", "user": "573d58c8e4b05c31a32c0811"}, {"problem": 85, "code": "(fn gen [coll] (let [feed (fn [coll init] (into (hash-set) (apply concat (map (fn [x] (reduce (fn [a b] (conj a (conj x (nth coll b)))) #{}\n                                                                                                      (range 0 (count coll)))) init))))\n                      colla (into [] coll)]\n                  (if (empty? coll) #{#{}} (conj (reduce (fn [a b] (feed colla a)) (map hash-set colla) (range (count colla))) #{}))))", "user": "567f988be4b0feffd0d18ebe"}, {"problem": 85, "code": "reduce (fn [acc nxt] \n            (into acc \n                  (for [oldacc acc] \n                    (conj oldacc nxt))))\n          #{#{}}", "user": "56102f50e4b05f002753df6b"}, {"problem": 85, "code": "(fn [s] (reduce (fn [acc el] (set (concat acc  (map #(conj % el) acc)))) #{#{}} s))", "user": "5659679ae4b068f2fe63dbeb"}, {"problem": 85, "code": "(fn powerset [coll]\n  (reduce (fn [a x]\n            (->> a\n                 (map #(set (concat #{x} %)))\n                 (concat a)\n                 set))\n          #{#{}} coll))", "user": "572ea970e4b0cd1946bd0f89"}, {"problem": 85, "code": "(fn [s] \n  (reduce (fn [power-set elem] \n            (into power-set \n                  (map #(conj % elem) power-set)))\n          #{#{}} s))", "user": "57002b81e4b08d47c97781c7"}, {"problem": 85, "code": "(fn [s]\n  (let [p (fn [c n s]\n            (cond (zero? n) (assoc c 0 #{})\n                  (= n 1) (assoc c 1 (set (map hash-set s)))\n                  :else (assoc c n\n                                 (reduce into #{}\n                                         (for [i s]\n                                           (map #(conj % i) (c (dec n))))))))]\n    (reduce into (set [#{} s]) (vals (reduce #(p % %2 s) {} (range (count s)))))))", "user": "574af03ce4b02ea114799202"}, {"problem": 85, "code": "(fn [s] (reduce (fn [ac b] (into ac (map #(conj % b) ac))) #{#{}} s))", "user": "5735ac67e4b0cd1946bd102b"}, {"problem": 85, "code": "(fn powerset [coll]\n       (reduce (fn [a x]\n                 (set (concat a (map #(set (concat #{x} %)) a))))\n               #{#{}} coll))", "user": "56791447e4b05957ce8c6183"}, {"problem": 85, "code": "(fn power-set [s]\n  (if (empty? s)\n    #{#{}}\n    (let [f (first s)\n          g (rest s)\n          small (power-set g)\n          other (for [ss small] (conj ss f))]\n      (set (concat small other)))))", "user": "56ac81ace4b03c432f187347"}, {"problem": 85, "code": "(fn power-set [s]\n  (case s\n    #{} #{#{}}\n    (let [subsets-without-first (power-set (disj s (first s)))]\n      (clojure.set/union subsets-without-first (map #(conj % (first s)) subsets-without-first)))))", "user": "53504fe6e4b084c2834f4ada"}, {"problem": 85, "code": "(fn [x]\n  (let [power-set (fn [s f] \n  \t\t\t\t\t(if (empty? s)\n    \t\t\t\t\t#{s}\n    \t\t\t\t\t(-> (set (mapcat #(f (disj s %) f) s))\n        \t\t\t\t\t(conj s))))\n        ps (memoize power-set)\n        ]\n    (ps x ps)))", "user": "57458b82e4b009280f9f2b4e"}, {"problem": 85, "code": "(fn power-set [S]\n  (loop [result #{#{}}, cur S]\n    (println cur)\n    (println result)\n  \t(if (empty? cur) result\n      (recur (clojure.set/union result (into #{} (map #(conj %1 (first cur)) result)))\n             (rest cur)))))", "user": "57015a1de4b08d47c97781d4"}, {"problem": 85, "code": "(fn [z] (loop [e #{z} \n               n (count z)]\n          (if (zero? n) \n            e \n            (recur (set (flatten \n                         (map (fn [s](cons s (map #(disj s %) s))) e))) (- n 1)))))", "user": "573ce277e4b05c31a32c080b"}, {"problem": 85, "code": "(fn pset [s]\n  (if (empty? s) #{#{}}\n    (let [x (first s)\n          ps (pset (disj s x))]\n      (clojure.set/union #{#{x}} ps (set (map #(conj %1 x) ps))))))", "user": "54e540c1e4b024c67c0cf7f9"}, {"problem": 85, "code": "(fn [s]\n    (letfn [(x-to-bin-seq [n x]\n              (->>\n                (map #(apply * (repeat % 2)) (reverse (range 0 n)))\n                (reduce\n                  (fn [[remainder acc] pow]\n                    (let [diff (- remainder pow)\n                          part? (>= diff 0)]\n                      [(if part? diff remainder)\n                       (conj acc part?)]))\n                  [x []] )\n                (last)))]\n      \n      (let [power (count s)  _s (vec s)]\n        (->>\n          (map (partial x-to-bin-seq power) (range (apply * (repeat power 2))))\n          (map #(zipmap (reverse (range power)) %))\n          (map #(filter (fn [[power-of-2 part?]] (and part? power-of-2)) %))\n          (map #(map first % ))\n          (map #(set (map (fn [power] (nth _s power)) %)))\n          (set)\n          ))))", "user": "561814bae4b06b1bb2182a1a"}, {"problem": 85, "code": "(fn power-set\n  ([S] (power-set (apply vector S) 0 #{}))\n  ([S k S1] ;;k is the elemnt being evaluated, S1 the set being formed,\n   (if (= k (count S))\n     (conj #{} S1)\n     (clojure.set/union (power-set S (inc k) (conj S1 (S k)))\n                        (power-set S (inc k) S1)))))", "user": "574f1c24e4b02ea114799255"}, {"problem": 85, "code": "(fn [s]\n  (->> s\n       (iterate (fn [ss]\n                  (loop [ss ss\n                         items s]\n                    (if (seq items)\n                      (if (contains? ss (first items))\n                        (disj ss (first items))\n                        (recur (conj ss (first items))\n                               (rest items)))\n                      ss))))\n       (take-while seq)\n       (cons #{})\n       set))", "user": "575cbe44e4b02ea114799374"}, {"problem": 85, "code": "reduce (fn [ss e] (into ss (map #(conj % e) ss))) #{#{}}", "user": "575ef4b6e4b08062f99a4e78"}, {"problem": 85, "code": "(fn [s]\n  (reduce (fn [acc  i]\n            (reduce (fn [acc j]\n                      (conj acc (conj  j i)))\n                    acc acc))\n          #{#{}} s))", "user": "57642916e4b0994c1922fbee"}, {"problem": 85, "code": "(fn [s]\n  (loop [i 1\n         acc #{#{}}]\n    (if (>= i (count s))\n      (conj acc #{} s)\n      (recur\n       (inc i)\n       (into #{}\n             (for [x acc\n                   v s]\n               (conj x v)))))))", "user": "57609d91e4b08062f99a4e9b"}, {"problem": 85, "code": "(fn [coll]\n  (set (reduce (fn [res elem]\n                 (let [combos (map #(set (concat #{elem} %)) res)]\n                   (concat res combos))) #{#{}} coll)))", "user": "56372c3ce4b0bfe05bf117d1"}, {"problem": 85, "code": "(fn pset [s]\n  (if (empty? s) #{#{}}\n      (let [t (pset (rest s))]\n        (clojure.set/union\n         t\n         ((fn [p m] (map #(conj % p) m)) (first s) t)))))", "user": "53c1b787e4b00fb29b221266"}, {"problem": 85, "code": "(fn pset [s]\n  (let [s (vec s)\n        n (count s)\n        e (fn [x]\n            (loop [o []\n                   y (interleave (reverse x) s)]\n              (if-let [a (first y)]\n                (recur (if (= a \\0) o (conj o (second y)))\n                       (drop 2 y))\n                (set o))))\n        p (->> (repeat 2)\n               (take n)\n               (apply *)\n               range\n               (map biginteger)\n               (map #(.toString % 2))\n               (map seq))]\n    (set (map e p))))", "user": "57533bc1e4b02ea1147992a6"}, {"problem": 85, "code": "reduce (fn [c x] (into c (map #(conj % x) c))) #{#{}}", "user": "576e3258e4b0979f89651574"}, {"problem": 85, "code": "#(reduce (fn [ss y]\n           (into ss\n                 (map (fn [s] (conj s y)) ss)))\n         #{#{}} %)", "user": "56d91a53e4b0ea9b8538f7ee"}, {"problem": 85, "code": "(fn powerset [coll] \n  (reduce (fn [a x]\n            (->> a\n                 (map #(set (concat #{x} %)))\n                 (concat a)\n                 set))\n          #{#{}} coll))", "user": "57644395e4b0994c1922fbf2"}, {"problem": 85, "code": "(fn power-set-solution\n  [coll]\n  (reduce (fn [a x]\n              (->> a\n                   (map #(set (concat #{x} %)))\n                   (concat a)\n                   set))\n         #{#{}} coll))", "user": "544e8369e4b0e39780006987"}, {"problem": 85, "code": "(fn powerset [s]\n  (reduce (fn [p x] (set (concat p (map #(conj % x)  p)))) #{#{}} s))", "user": "534fa9dae4b084c2834f4acf"}, {"problem": 85, "code": "(fn powr [s]\n  (reduce #(into %1 \n                 (for [x %1] (into x [%2]) ) ) \n          #{#{}} (seq s) )\n    )", "user": "533a2f7be4b0e30313ee6cb8"}, {"problem": 85, "code": "(fn [s]\n  (let [p (fn [c n s]\n            (cond (zero? n) (assoc c 0 #{})\n                  (= n 1) (assoc c 1 (set (map hash-set s)))\n                  :else (assoc c n\n                                 (reduce into #{}\n                                         (for [i s]\n                                           (map #(conj % i) (c (dec n))))))))]\n    (reduce into (set [#{} s]) (vals (reduce #(p % %2 s) {} (range (count s)))))))", "user": "5731e36be4b0cd1946bd0fc9"}, {"problem": 85, "code": "(fn [s] (reduce (fn [agg cur] (into agg (map #(conj % cur) agg))) #{#{}} s))", "user": "57131dfbe4b07c98581c3a98"}, {"problem": 85, "code": ";; SICP exercise 2.32 and their idea of \"wishful thinking\" is helpful here.\n;; Pull one item off the set, and by wishful thinking, compute the powerset of the tail (tail-solutions).\n;; Then combine tail-solutions with (tail-solutions where we've injected the head into each element).\n;; Our base case is the empty set, whose powerset is #{#{}}\n(fn ps [s]\n  (if-let [[head & tail] (seq s)]\n    (let [tail-solutions (ps tail)]\n      (into tail-solutions (map #(conj % head) tail-solutions)))\n    #{#{}}))\n;; Note that this can easily be turned into an interative solution:\n;;   (fn [s] (reduce (fn [acc item] (into acc (map #(conj % item) acc))) #{#{}} s))", "user": "5764457ae4b0994c1922fbf3"}, {"problem": 85, "code": "(fn power-set [s]\n  (let [n-to-set #(set (remove nil? (map-indexed (fn [n e] (when (bit-test % n) e)) s)))]\n    (set (map n-to-set (range (Math/pow 2 (count s)))))))", "user": "575b3e9be4b02ea11479935b"}, {"problem": 85, "code": "(fn pwrset [s]\n  (reduce (fn [acc x]\n            (into (conj acc #{x})\n                  (map #(conj % x) acc)))\n          #{#{}} s))", "user": "50d3ec8be4b030b634c368bb"}, {"problem": 85, "code": "(fn [s]\n  (loop [step 0 n #{#{}}]\n    (if (= step (count s)) n\n      (recur (inc step)\n             (apply conj n \n                    (for [x s y n]\n                      (conj y x))\n                    )))))", "user": "574abbfbe4b02ea114799200"}, {"problem": 85, "code": ";; the meat of this solution is to understand that\n;; (concat '(()) (map #(cons 1 %) '(())))\n;; (() (1))\n\n;; (concat '(() (1)) (map #(cons 2 %) '(() (1))))\n;; (() (1) (2) (2 1))\n\n;; (concat '(() (1) (2) (2 1)) (map #(cons 3 %) '(() (1) (2) (2 1))))\n;; (() (1) (2) (2 1) (3) (3 1) (3 2) (3 2 1))\n\n;; ...\n\n(fn [in]\n  (set\n   (map set\n        (loop [[f & r] (seq in) res '(())]\n          (if f\n            (recur r (concat res (map #(cons f %) res)))\n            res)))))", "user": "5564c113e4b0c656e3ff180d"}, {"problem": 85, "code": "(fn [s]\n  (loop [f (first s)\n         r (rest s)\n         p #{#{}}]\n    (if f\n      (recur (first r) (rest r) (clojure.set/union p (map #(conj % f) p)))\n      p)))", "user": "53e9dce1e4b036ad0777e4bc"}, {"problem": 85, "code": "(letfn [(bool-inc\n            ([v]\n             (bool-inc v (dec (count v))))\n            ([v i]\n             (when (>= i 0)\n               (if (get v i)\n                 (recur v (dec i))\n                 (reduce conj\n                         (conj (subvec v 0 i) true)\n                         (repeat (- (count v) i 1) false))))))\n          (pick [s v]\n            (reduce (fn [acc [e b]]\n                      (if b (conj acc e) acc))\n                    #{} (partition 2 (interleave s v))))\n          (subsets\n            ([coll]\n             (subsets coll (vec (repeat (count coll) false))))\n            ([coll v]\n             (when v\n               (lazy-seq\n                (cons (pick coll v) (subsets coll (bool-inc v)))))))]\n    (fn power-set [s]\n      (into #{} (subsets s))))", "user": "4dfe5a93535d04ed9115e786"}, {"problem": 85, "code": "(fn power-set\n  ([coll] (power-set coll #{#{}}))\n  ([coll my-set]\n    (cond\n      (empty? coll) my-set\n      :else (recur (rest coll) (into my-set (for [x my-set y #{#{(first coll)}}] (into x y)))))))", "user": "51eec1a6e4b0871fa145d98d"}, {"problem": 85, "code": "(fn pset [s]\n  (let [s (vec s)\n        n (count s)\n        e (fn [x]\n            (loop [o []\n                   y (interleave (reverse x) s)]\n              (if-let [a (first y)]\n                (recur (if (= a \\0) o (conj o (second y)))\n                       (drop 2 y))\n                (set o))))\n        p (->> (repeat 2)\n               (take n)\n               (apply *)\n               range\n               (map biginteger)\n               (map #(.toString % 2))\n               (map seq))]\n    (set (map e p))))", "user": "5798205ce4b039eba2ecb10e"}, {"problem": 85, "code": "(fn pset [s]\n  (let [s (vec s)\n        n (count s)\n        e (fn [x]\n            (loop [o []\n                   y (interleave (reverse x) s)]\n              (if-let [a (first y)]\n                (recur (if (= a \\0) o (conj o (second y)))\n                       (drop 2 y))\n                (set o))))\n        p (->> (repeat 2)\n               (take n)\n               (apply *)\n               range\n               (map biginteger)\n               (map #(.toString % 2))\n               (map seq))]\n    (set (map e p))))", "user": "57982bace4b039eba2ecb10f"}, {"problem": 85, "code": "(fn __\n  ([xs n]\n   (condp = n\n     0 #{}\n     1 (map (comp set list) xs)\n     (let [p (__ xs (dec n))]\n       (set (distinct (mapcat (fn [np]\n                                (map (fn [x]\n                                       (conj np x)) xs)) p))))))\n  ([xs] (conj (__ xs (count xs)) #{})))", "user": "55c4cda5e4b0e31453f649a5"}, {"problem": 85, "code": "(fn powerset\n  [coll]\n  (let [x (first coll) xs (rest coll)]\n    (if (empty? coll)\n      #{#{}}\n      (let [pset (powerset xs)]\n        (clojure.set/union pset (map #(into #{x} %) pset))))))", "user": "55ede35ce4b0121d4835fde1"}, {"problem": 85, "code": "(fn pwrset \n ([s] \n    (into #{} (pwrset #{} s)))\n  ([h r]\n    (if (empty? r)\n      (list h)\n      (concat (pwrset h \n                      (rest r))\n              (pwrset (conj h (first r)) \n                      (rest r))\n              ))))", "user": "578cf84ce4b0ebec4cfb7562"}, {"problem": 85, "code": "(fn powerset [a-set]\n  (if (empty? a-set) #{#{}}\n      (clojure.set/union (powerset (next a-set))\n                         (map #(conj % (first a-set))\n                              (powerset (next a-set))))))", "user": "505d1b01e4b0e6aca564be04"}, {"problem": 85, "code": "(fn powerset [s]\n  (reduce #(into % (for [subset %] (conj subset %2))) #{#{}} s))", "user": "5776558ee4b0979f89651633"}, {"problem": 85, "code": "(fn [s]                                                                                                                   \n  (reduce                                                                                                                 \n   (fn [acc x]                                                                                                            \n     (reduce (fn [acc y]  (conj acc (conj y x)))                                                                          \n             acc acc))                                                                                                    \n   #{#{}} s))", "user": "57a42013e4b0a966079561da"}, {"problem": 85, "code": "(fn ps [xs]\n  (if (empty? xs) \n    #{#{}}\n    (loop [now (first xs)\n           left []\n           right (vec (rest xs))\n           so-far #{(set xs)}]\n      (if (empty? right)\n        (conj so-far (set left))\n        (recur (first right)\n               (into left [now])\n               (rest right)\n               (into so-far (ps (into left right))))))))", "user": "57717915e4b0979f896515b3"}, {"problem": 85, "code": "(fn [s]\n  (letfn [(ps [[x & xs]]\n              (if x\n                (let [psx (ps xs)]\n                  (into psx (map #(conj % x) psx)))\n                #{#{}}))]\n    (ps (seq s))))", "user": "57a4fa50e4b0a966079561f1"}, {"problem": 85, "code": "(fn [s]\n  (letfn [(add [coll x] (into coll (map #(conj % x) coll)))]\n    (reduce add #{#{}} s)))", "user": "577c3da9e4b0c8d87281f6b9"}, {"problem": 85, "code": "(fn [s]\n  \"TODO: Transducify!\"\n  (->> (reduce (fn [out in]\n                 (concat out\n                         (map #(concat [in] %) out)))\n               [[]]\n               s)\n       (map set)\n       set))", "user": "5297dcc5e4b02ebb4ef75047"}, {"problem": 85, "code": "(fn\n  [s]\n  (loop [b (dec (int (Math/pow 2 (count s)))) f #{} p #{} i 0]\n    (if (>= b 0)\n      (if (< i (count s))\n        (if (bit-test b i)\n          (recur b f (conj p (nth (vec s) i)) (inc i))\n          (recur b f p (inc i))\n          )\n        (recur (dec b) (conj f p) #{} 0))\n      f))\n  )", "user": "5772ddb0e4b0979f896515d4"}, {"problem": 85, "code": "(fn power [coll]\n  (reduce\n   (fn [a x]\n     (->> a\n          (map #(set (concat #{x} %)))\n          (concat a)\n          set))\n   #{#{}}\n   coll)\n  )", "user": "56903cb9e4b0dcc4269f40eb"}, {"problem": 85, "code": "(fn [s] (reduce (fn [a e] (->> a (map #(set (concat #{e} %))) (concat a) set )) #{#{}} s))", "user": "577202d2e4b0979f896515c0"}, {"problem": 85, "code": "(fn power-set [xs]\n  (if (seq xs)\n    (let [tail      (rest xs)\n          power-set (power-set tail)]\n      (set (concat power-set (set (map #(conj % (first xs)) power-set)))))\n    #{#{}}))", "user": "5371167fe4b0fc7073fd6ea7"}, {"problem": 85, "code": "(fn f\n  ([s t]\n   (if (seq s) \n     (clojure.set/union (f (rest s) t) (f (rest s) (conj t (first s))))\n     (set (list t))))\n  ([s] (f (seq s) #{})))", "user": "5799ff45e4b05b1deef9add1"}, {"problem": 85, "code": "(fn power-set [xs]\n    (if\n      (empty? xs)\n      #{#{}}\n      (let\n        [\n          x (first xs)\n          xss (power-set (rest xs))\n        ]\n        (set\n          (concat\n            xss\n            (map\n              (fn [v]\n                (set\n                  (conj v x)\n                )\n              )\n              xss\n            )\n          )\n        )\n      )\n    )\n  )", "user": "5784e177e4b0ebec4cfb74cf"}, {"problem": 85, "code": "(fn[s]\n  (loop[[f & r] (into [] s) res #{#{}}]\n  (if f\n    (recur r (into res (map #(conj % f) res)))\n    res)))", "user": "57b3efb1e4b0fbc9809a278a"}, {"problem": 85, "code": "(fn [sett]\n  (letfn [(iter [sett]\n            (if (seq sett)\n              (let [rest-set (iter (rest sett))\n                    ff (first sett)]\n                (mapcat (fn [x] (list x\n                                      (conj x ff)))\n                        rest-set))\n              (list #{})))]\n    (set (iter sett))))", "user": "5455c2f3e4b080a794c2c87d"}, {"problem": 85, "code": "(fn g\n  ([x]\n    (let [i (map #(conj #{} %) x)]\n      (if (seq i) (g x `#{#{} ~@i} i) #{#{}})))\n  ([x r l]\n    (let [t (set (for [a l b x :when (nil? (a b))] `#{~@a ~b}))]\n      (if (t x)\n          (into r t)\n          (recur x (into r t) t)))))", "user": "548b7db8e4b0e286459a11fd"}, {"problem": 85, "code": "(fn powerset [xs]\n  (if (empty? xs)\n      #{#{}}                                                                       \n    (let [e    (first xs)                                                      \n          xs'  (into #{} (remove #{e} xs))                                                    \n          xs'' (powerset xs')]                                                  \n      (into xs'' (map #(conj % e) xs'')))))", "user": "55316b8ae4b076ab5578f825"}, {"problem": 85, "code": "(fn [xs]\n   (loop [seen #{#{}}\n          init (map hash-set xs)]\n     (if (or (empty? init)\n             (= 1 (count init)))\n       (conj seen xs)\n       (recur (into seen init)\n              (set (for [x init y init :when (not= x y)]\n                     (into x y)))))))", "user": "56706f01e4b0a866af6896f2"}, {"problem": 85, "code": "(fn [input]\n   (let [bitmask (take (reduce +\n                               (take (- (count input) 1)\n                                     (iterate #(* 2 %) 4)))\n                       ((fn get-bitmask [mask]\n                          (let [mask-entries (for [x [0 1] y mask]\n                                               (list x y))]\n                            (lazy-seq (concat mask-entries (get-bitmask mask-entries))))) [0 1]))]\n     (condp = (count input)\n       0 #{#{}}\n       1 #{#{} #{(first input)}}\n       (set (map (fn [mask] \n              (into #{} (filter (comp not nil?) (map (fn [m value] (if (= 1 m) value)) mask input))))\n              (map flatten bitmask))))))", "user": "4e9ff8d0535d7eef3080729c"}, {"problem": 85, "code": ";https://en.wikipedia.org/wiki/Power_set#Algorithms\n(fn power-set\n  [s]\n  (if (empty? s)\n    #{s}\n    (let [e (first s) st (disj s e)]\n      (into (power-set st) ((fn add-to-each-set\n                              [s element]\n                              (if (empty? s)\n                                #{element}\n                                (set (map #(conj %1 element) s)))) (power-set st) e)))))", "user": "558bdcefe4b0277789237633"}, {"problem": 85, "code": "(fn [a]\n (letfn [\n  (power [x y] \n    (let [z (into [] x)]\n    (map\n     set \n     (loop [i 0   result [#{} #{y}]]\n     (println result)    \n     (if \n            (< i (count z)) \n               (recur (inc i) (into result (map #(conj % (get z i)) result)))\n                result \n            )\n      )         \n    )) \n   )]\n   (reduce #(into %1 %2)  #{#{}} (map (partial power a)  a))\n  )\n )", "user": "56e6e1e6e4b02e7e935eb6cf"}, {"problem": 85, "code": "(fn test [coll]\n  (if (empty? coll)\n    #{#{}}\n    (reduce \n      into\n      #{}\n      (map (fn [i]\n           [i (conj i (first coll))])\n        (test (rest coll))))))", "user": "579332c2e4b0e215f87e8452"}, {"problem": 85, "code": "(fn power-set [s]\n    (if (empty? s)\n      #{s}\n      (let [subsets (power-set (set (rest s)))]\n        (into subsets (map #(conj % (first s)) subsets)))))", "user": "5317d78ee4b08068f379ed63"}, {"problem": 85, "code": "(fn ps [st]\n  (if (empty? st)\n    #{#{}}\n    (let [rec (ps (clojure.set/difference st #{(first st)}))]\n      (clojure.set/union rec (map #(clojure.set/union #{(first st)} %) rec))\n     )\n   )\n )", "user": "57cf03c0e4b00451144b04f9"}, {"problem": 85, "code": "(fn pow [s]\n  (if (empty? s) #{#{}}\n    (let [f (first s)\n          r (pow (rest s))]\n      (into r (map #(conj % f) r)))))", "user": "57a0b341e4b0c3d858beb8d4"}, {"problem": 85, "code": "(fn [s]\n  (loop [s s acc #{#{}}]\n    (if (empty? s)\n      acc\n      (recur (rest s) \n        (into acc (map #(conj % (first s)) acc))))))", "user": "56cf115de4b0ea9b8538f765"}, {"problem": 85, "code": "(fn\n  [coll]\n  (reduce (fn [r v] (into r(reduce #(conj %1 (conj %2 v)) #{} r))) #{#{}} coll))", "user": "57d0cd58e4b0bd073c20235e"}, {"problem": 85, "code": "(fn power-set [coll]\n  (let [n (count coll)\n        coll-vec (vec coll)]\n    (letfn [(comb-iter \n              [k start]\n              (if (== k 1)\n                (for [x (range start n)]\n                  (list x))\n                (for [x  (range start n)\n                      xs (comb-iter (dec k) (inc x))]\n                  (cons x xs))))]\n      (->> (for [k (range (inc n))]\n             (comb-iter k 0))\n           (map set)\n           (mapcat (fn [s] (map #(into #{} (map coll-vec %)) s)))\n           (into #{#{}})))))", "user": "571c2babe4b07c98581c3b73"}, {"problem": 85, "code": "(fn pwset\n\n  ([v] \n\n\n   (if (empty? v)\n\n    #{#{}}\n\n    (let [x (first v)  \n          xs (disj v x)\n          pxs (pwset xs)\n\n          pxxs (pwset x pxs)]\n\n       \n\n       (into #{}\n\n        (concat pxs pxxs)))))\n\n        \n\n\n\n  ([x xs]\n\n\n   (if (empty? xs)\n\n    x\n\n    (map #(conj % x) xs))))", "user": "57487084e4b009280f9f2b8c"}, {"problem": 85, "code": "(fn ps [s]\n  (set (reduce (fn [acc v]\n                 (concat acc (map #(conj % v) acc))\n                 ) #{#{}} s))\n  )", "user": "550c55d0e4b06e50f9beb14d"}, {"problem": 85, "code": "(fn powerset [xs]\n  (let [ln       (count xs)\n        col      (into [] xs)\n        set-size (Math/pow 2 ln)]\n    (->> (for [i (range set-size)]\n           (->> (for [j (range ln)\n                      :when (pos? (bit-and i (bit-shift-left 1 j)))]\n                  (col j))\n                (into #{})))\n         (into #{}))))", "user": "57c500f9e4b05aa3c4741cda"}, {"problem": 85, "code": "(fn [vs]\n  (let [ss (set (map #(hash-set %) vs))]\n    (conj \n      (reduce \n        (fn [acc s]\n          (set (concat acc (for [s1 acc] (set (concat s1 s)))))) ss ss) \n      #{})))", "user": "57d9bca1e4b0bd073c202405"}, {"problem": 85, "code": "(fn power-set [s]\n  (if (empty? s)\n    #{#{}}\n    (let [e (first s), s-e (disj s e), ps-e (power-set s-e)]\n      (clojure.set/union ps-e\n                         (into #{}\n                               (map #(conj % e) ps-e))))))", "user": "572ec4dde4b0cd1946bd0f8d"}, {"problem": 85, "code": "(fn powerset [coll]\n  (if (empty? coll)\n    #{#{}}\n    (let [pxs (powerset (rest coll))]\n      (clojure.set/union\n       (into #{} (map #(clojure.set/union #{(first coll)} %) pxs))\n       pxs))))", "user": "5617a540e4b06b1bb2182a12"}, {"problem": 85, "code": "(fn powerset [s]\n  (if (seq s)\n    (let [e (first s) t (powerset (disj s e))]\n      (clojure.set/union t (map #(conj % e) t)))\n    #{#{}}))", "user": "53c06438e4b0c98a41f5ccb0"}, {"problem": 85, "code": "(fn [initial-set]\n  (if (empty? initial-set) #{#{}} (letfn [(next-level-vals [xs] (reduce #(conj %1 (disj xs %2)) #{} xs))]\n\n                                (loop [current-set (conj #{} initial-set) ps (conj #{} initial-set)] \n                                  (let [next-set (reduce #(apply conj %1 (next-level-vals %2)) #{} current-set)\n                                        count-1 (every? #(= 1 (count %)) current-set)\n                                        count-0 (every? #(= 0 (count %)) current-set)] \n                                    (if  (or count-1 count-0)\n                                      (apply conj ps #{} next-set) \n                                      (recur next-set (apply conj ps next-set))))))))", "user": "57c6aa0be4b05aa3c4741cf7"}, {"problem": 85, "code": "(fn [l]\n   (set\n     (reduce (fn [i e]\n               (concat (map #(conj % e) i) i))\n             [#{}] l)))", "user": "57d9f603e4b0bd073c20240a"}, {"problem": 85, "code": "(fn powerset [x]\n  (let [a (count x)\n        p (fn [m a n]\n            (if (>= n a) m\n             (let [s1 (m 1)\n                   sn (m (dec n))\n                   c (fn [s x y]\n                       (if (empty? x) s\n                         (let [h (first x)\n                               t (rest x)\n                               ms (filter #(= n (count %)) (map (partial into h) y))]\n                           (recur (into s ms) t y))))\n                   s (c #{} sn s1)\n                   nm (conj m [n s])]\n               (recur nm a (inc n)))))\n        m {1 (map (partial conj #{}) x)}]\n    (-> (reduce into #{} (vals (p m a 2))) (conj x) (conj #{}))))", "user": "57d1d6c8e4b0bd073c202370"}, {"problem": 85, "code": "(fn [s]\n  (set (reduce #(concat %1 (map (fn [i] (set (conj i %2))) %1)) #{#{}} s)))", "user": "57df309ee4b0bd073c20245f"}, {"problem": 85, "code": "(fn powset [s]\n  (letfn [(pwize [accum s]\n            (concat accum\n              (map (fn [pv-set]\n                     (conj pv-set s))\n                accum)))]\n    (set (reduce pwize [#{}] (vec s)))))", "user": "56f9c7c6e4b07572ad1a88ba"}, {"problem": 85, "code": "(fn [startset]\n  (let [extend-element (fn [sets el] (map #(conj % el) sets))               ;(map #(conj % 1) #{#{}}) -> #{#{1}}\n        extend-set     (fn [sets el] (into sets (extend-element sets el)))] ;(into #{#{}} (extend-element #{#{}} 1) \n   (reduce extend-set #{#{}} startset)))                                    ;(reduce extend-set #{#{}} #{1 :a})", "user": "57e139f6e4b0bfb2137f5a6c"}, {"problem": 85, "code": "(fn powerset [aset]\n  (let [n (int (Math/pow 2 (count aset)))        \n        masks (map (fn [b] (map #(= % \\1)\n                                (#(rest (seq (Integer/toString % 2))) (+ b n))))\n                   (range n))]\n    (set (map (fn [m] (set (filter identity (map #(when %2 %1) aset m))))\n              masks))))", "user": "579d9601e4b05b1deef9ae18"}, {"problem": 85, "code": "(fn [s]\n  (loop [a #{#{}}\n         [h & t] (seq s)]\n    (if (nil? h) a \n        (recur (into a (for [x a] (conj x h)) )\n               t))))", "user": "57e0f30ae4b0bfb2137f5a66"}, {"problem": 85, "code": "#(set \n    (loop [s #{#{}} n (count %)]\n      (if (= n 0)\n        s\n        (recur (into s (for [x s y %] (conj x y))) (dec n)))))", "user": "576df252e4b0979f8965156f"}, {"problem": 85, "code": "(fn power [input-seq]\n  (let [mapunion (fn [s with] (map (fn [e] (clojure.set/union e #{with})) s))]\n    (reduce (fn [x y] (clojure.set/union x (mapunion x y))) #{#{}} input-seq)))", "user": "57ec3d29e4b0bfb2137f5b77"}, {"problem": 85, "code": "(fn [bset]\n  (reduce (fn [curset elem]\n            (apply conj curset (map #(conj % elem) curset)))\n          #{#{}}\n          bset))", "user": "57dd47f4e4b0bd073c20243e"}, {"problem": 85, "code": "(fn power-set [initial-set]\n  (letfn [(helper [[ans cur-set]]\n                  [(clojure.set/union ans (set (for [s ans e cur-set] (conj s e)))) (rest cur-set)])]\n    (let [iter (count initial-set)]\n      (first (nth (iterate helper [#{#{}} initial-set]) (inc iter))))))", "user": "5746061ae4b009280f9f2b5b"}, {"problem": 85, "code": "(fn [st] \n  (reduce (fn [s t] (into s (for [x s] (conj x t)))) \n          #{#{}} \n          st))\n\n\n#_\n; Wikipedia\n(fn ps [s] \n  (if (empty? s) \n    #{#{}} \n    (let [f (fn [e t] (set (for [x t] (conj x e)))) \n          e (first s) \n          t (clojure.set/difference s #{e})] \n      (clojure.set/union (ps t) (f e (ps t))))))", "user": "57f0f7b8e4b0bfb2137f5bfe"}, {"problem": 85, "code": "(fn [x]\n    (let [ps (memoize\n               (fn [ps s]\n                (if (empty? s)\n                  #{#{}}\n                  (apply clojure.set/union #{s} (map #(ps ps (clojure.set/difference s (set [%]))) s)))))\n            ps (partial ps ps)]\n      (ps x)))", "user": "4e837808535db62dc21a62d9"}, {"problem": 85, "code": ";; the simple solution starts with empty set and then for every x of c, \n;; adds to set all its existing elements + x, doubling the number of contents with each pass. \n;; rewritten the boring loop formula to more fancy reduce. \n\n(fn [c]\n  (reduce (fn [r x] (into r (map #(conj % x) r)))\n            #{#{}} c))", "user": "57e33f6fe4b0bfb2137f5a96"}, {"problem": 85, "code": "(fn [c]\n  (reduce\n    (fn [s e]\n      (set (concat s (map #(conj % e) s) [#{e}])))\n    #{#{}} c))", "user": "54d000c7e4b018d918be98d7"}, {"problem": 85, "code": "(fn [dset] \n (letfn [\n  (p-mrg [a ss] \n   (map (partial cons a) ss))\n\n  (p-set [ds] \n   (if (empty? ds)\n    (list (list))\n    (let [ppset (p-set (rest ds))]\n     (concat ppset (p-mrg (first ds) ppset)))) )\n\n  (pwr-set [xs]\n  (into #{} (map (partial into #{}) (p-set xs))))] \n (pwr-set dset) ))", "user": "57f9011ee4b0d3187e900935"}, {"problem": 85, "code": "(fn power-set-2 [sets]\n  (reduce \n   \t(fn [acc x]\n      (clojure.set/union acc (set (map #(conj % x) acc)))\n    )\n   #{#{}}\n   sets\n  )\n)", "user": "5803ba6de4b0a837a8b30c95"}, {"problem": 85, "code": "(fn powerset [ls]\n    (if (empty? ls)\n      #{#{}}\n      (clojure.set/union\n       (powerset (next ls))\n       (map #(conj % (first ls)) (powerset (next ls))))))", "user": "500d3160e4b05f7c30cfa6a1"}, {"problem": 85, "code": "(fn [s]\n  (set (reduce #(concat %1 (map (fn [i] (set (conj i %2))) %1)) #{#{}} s)))", "user": "57f8ba80e4b0d3187e90092f"}, {"problem": 85, "code": "(fn [input]\n    (let [fp \n          (fn [i, input, result]\n            (if (empty? input)\n              result\n              (if (not (zero? (mod i 2)))\n                (recur (bit-shift-right i 1) (rest input) (conj result (first input)))\n                (recur (bit-shift-right i 1) (rest input) result))))]\n      (loop [i (bit-shift-left 1 (count input)), result #{}]\n        (if (zero? i)\n          result\n          (recur (dec i) (conj result (fp i input, #{})))))))", "user": "4eabb245535d7eef30807319"}, {"problem": 85, "code": "(fn p\n\t([s] (p s #{#{}}))\n\t([s r]\n\t\t(if (empty? s)\n\t\t\tr\n\t\t\t(recur (rest s) (set (concat r (map #(conj % (first s)) r)))))))", "user": "57ccedaae4b0c746388ab88e"}, {"problem": 85, "code": "(fn [x]\n  (reduce\n    (fn [a b]\n      (set (concat (map #(conj % b) a) a)))\n    #{#{}}\n    x))", "user": "50d0d2dde4b00b15ecee9768"}, {"problem": 85, "code": "(fn powerset [s]\n  (reduce #(into % (for [subset %] (conj subset %2))) #{#{}} s))", "user": "581e61b0e4b04b46fc4b0f28"}, {"problem": 85, "code": "(fn power-set\n  [coll]\n  (if\n    (empty? coll)\n    #{#{}}\n    (loop [xs (seq (rest coll))\n           rs #{#{} #{(first coll)}}]\n      (if xs\n        (recur\n          (seq (rest xs))\n          (apply conj rs (map #(conj % (first xs)) rs)))\n        rs))))", "user": "536ecd9fe4b0fc7073fd6e76"}, {"problem": 85, "code": "(fn [sq]\n  (let [pw (map #(reverse (Integer/toBinaryString %)) (range 0   (Math/pow 2 ( identity (count sq))) ))]\n  (set (map (fn [x] (into #{} (remove (comp nil?) (map #(if (= \\1 %1) %2) x sq) ) )  ) pw)\n    )  ) )", "user": "581a5fdbe4b0e114eb51a002"}, {"problem": 85, "code": "(fn [a]\n  (reduce (fn [b c] (clojure.set/union b (map #(conj % c) b))) #{#{}} a))", "user": "5405885ee4b0addc1aec6668"}, {"problem": 85, "code": "(fn power-set-of\n  [x]\n  (if (empty? x) #{#{}}\n      (loop [[h & t] (into [] x)\n             accum #{#{}}]\n        (let [new-accum (into accum (map #(conj % h) accum))]\n          (if (nil? t)\n            new-accum\n            (recur t new-accum))))))", "user": "58152157e4b0f478707a0631"}, {"problem": 85, "code": "(fn ps [s]\n  (letfn [(pick-set-with-mask [xs mask]\n            (->> (map #(when (= %1 \\1) %2) mask xs)\n                 (filter identity)\n                 (set)))]\n    (let [num (count s)\n          masks (->> num\n                     (Math/pow 2)\n                     (range 0)\n                     (map #(Integer/toString % 2))\n                     (map #(str \"000000000000\" %))\n                     (map (partial take-last num)))\n          elements (vec s)]\n      (set (map #(pick-set-with-mask elements %) masks)))))", "user": "56069006e4b08b23635d3174"}, {"problem": 85, "code": "(fn p [x]\n  (if-let [f (first x)]\n    (set (mapcat (fn [z] [z (conj z f)]) (p (disj x f))))\n    #{#{}}))", "user": "5742ec91e4b05c31a32c0883"}, {"problem": 85, "code": "(fn [coll]\n  (reduce\n   (fn [a x]\n     (set (concat (map #(conj % x) a) a)))\n   #{#{}} coll))", "user": "564d3169e4b0284900eef67c"}, {"problem": 85, "code": "(fn my-power-set [s]\n  (letfn [(one-more [ps x]\n            (->> (map #(conj % x) ps)\n                 (set)\n                 (into ps)))]\n     (reduce one-more #{#{}} s)))", "user": "581b19e7e4b04b46fc4b0ec4"}, {"problem": 85, "code": "(fn power-set [s]\n  (let [length (count s)\n        m (zipmap (range) s)]\n    (set\n      (for [i (range (apply * (repeat length 2)))]\n        (set\n          (for [j (range length)\n                :when (bit-test i j)]\n            (m j)))))))", "user": "58247423e4b051871117bec5"}, {"problem": 85, "code": "(fn [s]\n    (set (reduce #(concat %1 (map (fn [i] (set (conj i %2))) %1)) (list #{}) s)))", "user": "55c5b55fe4b0e31453f649b5"}, {"problem": 85, "code": "(fn power-set [s]\n  (loop [n (int (- (Math/pow 2 (count s)) 1))\n         sets #{#{}}]\n    (if (> n 0)\n      (let [not-nil? (comp not nil?)\n            ;; Pad binary string with spaces (it's not a num, can't use 0's.\n\t\t\t;; It doesn't matter though, we just check check for 1's in the right pos\n            binary (format (str \"%\" (count s) \"s\") (Integer/toBinaryString n))\n            sub-set (filter not-nil? (map #(when (= \\1 %1) %2) binary s))]\n        (recur (dec n) (conj sets (set sub-set))))\n      sets)))", "user": "58327a08e4b089d5ab817c7c"}, {"problem": 85, "code": "(fn powerset [x]\n  (loop [a #{#{}} b (seq x)]\n    (if (empty? b)\n      a\n      (recur\n        (into a (map (fn [e] (conj e (first b))) a))\n        (rest b)))))", "user": "5843b95de4b089d5ab817e3f"}, {"problem": 85, "code": "(fn powerset [xs]\n  (if (seq xs)\n    (let [xs (into #{} xs)\n          head (first xs)\n          tail (rest xs)\n          subsets (powerset tail)]\n      (clojure.set/union #{#{head}}\n                         subsets\n                         (into #{} (map #(conj % head) subsets))))\n    #{#{}}))", "user": "4f5599dfe4b0a7574ea71806"}, {"problem": 85, "code": "(fn [s]\n   (reduce #(into %1 (for [x %1] (conj x %2)) ) #{#{}} s))", "user": "51bd1a0de4b0df1216cefd93"}, {"problem": 85, "code": "(fn [sett]\n     (let [exp (reduce * (repeat (count sett) 2))\n           places (count (Integer/toString (dec exp) 2))\n           formatter (str \"%0\" places \"d\")\n           k (map #(format formatter (Integer. (Integer/toString % 2))) (range exp))\n           blah (zipmap k (repeat sett))]\n       (reduce (fn [acc [k v]]\n                 (conj acc (set (keep identity (map #(and %1 %2) (map #(when (= \\1 %) true) k)\n                                                    v))))) #{} blah)))", "user": "5256c4c1e4b0541d1855ba36"}, {"problem": 85, "code": "(fn power [xs] (if (empty? xs) #{#{}} (let [p-rest (power (rest xs))] (clojure.set/union p-rest (map #(conj % (first xs)) p-rest)))))", "user": "584dadebe4b0b7285a6f4e44"}, {"problem": 85, "code": "; Original solution\n;(fn [s]\n;   (letfn [(update-n [numbers maxn]\n;             (let [l (last numbers)\n;                   p (butlast numbers)]\n;               (if (<= maxn l)\n;                 (when (not= numbers\n;                             (reverse (range maxn\n;                                             (- maxn (count numbers))\n;                                             -1)))\n;                   (let [n (update-n p (dec maxn))]\n;                     (concat n [(inc (last n))])))\n;                 (concat p [(inc l)]))))\n;           (take-different-n [x n]\n;             (if (== n 0)\n;               '()\n;               (letfn [(constructor [numbers]\n;                         (cons (map (partial get x) numbers)\n;                               (when-let [u (update-n numbers (dec (count x)))]\n;                                 (lazy-seq (constructor u)))))]\n;                 (constructor (vec (range n))))))]\n;     (conj (set (mapcat #(map set (take-different-n (vec s) %)) ;The mapcat destroys the empty list\n;                        (range (inc (count s)))))\n;           #{})))\n\n\n; Joining onto sets with already included element doesn't do any harm.\n; start with the empty set and grow it.\n; first iter: add all elements to the empty set\n; second iter: TRY to add all elements to the result of last iter\nreduce (fn [acc e] \n         (into acc\n               (map #(conj % e)\n                    acc)))\n       #{#{}}", "user": "54d341f7e4b0e8a36923e603"}, {"problem": 85, "code": "(fn my-power-set [coll]\n  (letfn [(add-to-set [acc v]\n            (concat acc [v]\n              (map #(clojure.set/union v %) acc)))]\n    (set \n      (clojure.set/union #{#{}} \n        (reduce \n          add-to-set \n          #{} \n          (map #(set[%]) coll))))))", "user": "57c0917be4b05aa3c4741c95"}, {"problem": 85, "code": "(fn [s] (loop [ps #{#{}}\n               i 0]\n          (if (> i (count s))\n            ps\n            (recur (into ps (mapcat (fn [e] (reduce #(conj % (conj e %2)) #{} s)) ps))\n                   (inc i))\n            )))", "user": "565b2fa5e4b068f2fe63dbfe"}, {"problem": 85, "code": "(fn power-set\n  ([s] (power-set (count s) s))\n  ([k s]\n   (if (= k 0)\n     #{#{}}\n     (let [subsets (power-set (dec k) s)]\n       (into subsets\n             (for [x s\n                   ss subsets]\n               (conj ss x)))))))", "user": "583e27e2e4b089d5ab817daa"}, {"problem": 85, "code": "(fn powerset [s] (letfn [(k [s1 i](into s1 (map #(conj % i) s1)))] (reduce k #{#{}} s)))", "user": "5849ac5fe4b089d5ab817ed7"}, {"problem": 85, "code": "(fn power-set [init-set]\n  (loop [res-set #{#{}}\n         n (count init-set)]\n    (if (= n 0)\n      (conj res-set #{})\n      (recur (apply clojure.set/union\n                    (map (fn [x]\n                           (set (map (fn [y]\n                                       (conj x y))\n                                     init-set)))\n                         res-set))\n             (dec n)))))", "user": "585e2e77e4b0f14aab7c87ac"}, {"problem": 85, "code": "(fn superset [xs]\n  (if (not (seq xs))\n      #{#{}}\n      (let [f (first xs)\n            r (set (rest xs))\n            subset (superset r)]\n          (clojure.set/union\n            subset\n            (map #(conj % f) subset)))))", "user": "566ff0a1e4b0a866af6896ec"}, {"problem": 85, "code": "(fn power [x]\n  (loop [s x acc [#{}]]\n    (if-let [a (first s)]\n      (recur (rest s) (concat (map #(conj % a) acc) (conj acc #{a})))\n      (set acc))))", "user": "4dac39a28cc9d6edb8beb0b3"}, {"problem": 85, "code": "(fn [col]\n  (reduce\n   (fn [base x]\n     (set (concat (map #(conj % x) base) base)))\n   #{#{}} col))", "user": "583667c7e4b089d5ab817cfb"}, {"problem": 85, "code": "(fn [s]\n  (loop [xs (seq s)\n         so-far #{#{}}]\n    (if-let [[x & xs] xs]\n      (->>\n       (for [s so-far]\n         [s (conj s x)])\n       (apply concat)\n       (into #{})\n       (recur xs))\n      so-far)))", "user": "4ff24a1ae4b0678c553fc337"}, {"problem": 85, "code": "#(let [c (fn [e coll] (conj coll e))\n       f (fn [e coll] (map (partial c e) coll)) \n       g (fn [a b] (set (concat a (f b a)))) ] \n   (reduce g #{#{}} %))", "user": "580c8fcee4b0849f6811b721"}, {"problem": 85, "code": "(fn [x-rel]\n  (letfn [(powerset [is xs]\n            (let [i (first is)\n                  is' (clojure.set/difference is #{i})]\n              (if i\n                [(powerset is' (clojure.set/difference xs #{i}))\n                 (powerset is' (clojure.set/union xs #{i}))]\n                xs)))]\n    (-> x-rel\n      (powerset x-rel)\n      (flatten)\n      (set)\n      (conj #{}))))", "user": "554bd33ce4b0a04f7929959a"}, {"problem": 85, "code": "(fn [s]\n  (let [arr     (into [] s)\n        ps-size (bit-shift-left 1 (count arr))]\n    (reduce (fn [acc n]\n              (conj acc\n                    (loop [subset #{}\n                           m      n]\n                      (if (> m 0)\n                        (recur (conj subset\n                                     (nth arr\n                                          (- 31 (Integer/numberOfLeadingZeros\n                                                 (Integer/lowestOneBit m)))))\n                               (bit-and m (dec m)))\n                        subset))))\n            #{#{}}\n            (range 1 ps-size))))", "user": "53dfbc75e4b0d874e779ae44"}, {"problem": 85, "code": "(fn\n  [s]\n  (reduce #(into % (map (fn [p] (conj p %2 )) %)) #{#{}} s))", "user": "56bb652ae4b0f26550335953"}, {"problem": 85, "code": "(letfn [(set-from-mask [x s]\n          (into #{}\n            (filter (complement nil?)\n              (map-indexed (fn [i v] (if (bit-test x i) v nil)) s))))]\n  (fn [s]\n    (into #{} \n      (map #(set-from-mask % s) (range (int (Math/pow 2 (count s))))))))", "user": "5884e807e4b0f1effa3b76a6"}, {"problem": 85, "code": "(fn [coll] \n  (reduce (fn [a x]\n            (->> a\n                 (map #(set (concat #{x} %)))\n                 (concat a)\n                 set))\n          #{#{}} coll))", "user": "586615e6e4b0f14aab7c8858"}, {"problem": 85, "code": "(fn powerset [xset]\n  (if (empty? xset)\n    #{#{}}\n    (let [xcompl (disj xset (first xset))\n          powcompl (powerset xcompl)\n          xadded (map #(conj % (first xset)) powcompl)]\n      (clojure.set/union powcompl xadded))))", "user": "585dbe41e4b0f14aab7c879f"}, {"problem": 85, "code": "(fn f [x]\n  (letfn \n    [(subsets  [[a & t :as l]]\n       (if \n         (empty? l)\n         #{#{}}   \n         (set \n           (clojure.set/union\n             (map (partial clojure.set/union #{a})  (subsets t))\n             (subsets t)))))]\n   (subsets (seq x))))", "user": "4e6a5728535d8ccf87e9fecf"}, {"problem": 85, "code": "(fn power-set [s]\n  (reduce #(into %1 (for [element %1] (conj element %2))) #{#{}} s)\n  )", "user": "525d44bfe4b0cb4875a45d6d"}, {"problem": 85, "code": "(fn power-set [s]\n  (if (empty? s)\n    #{#{}}\n    (let [x (first s) ps1 (power-set (rest s))]\n      (clojure.set/union ps1 (map #(conj % x) ps1)))))", "user": "58a0fc33e4b02bd94d917ea3"}, {"problem": 85, "code": "(fn [myset]\n  (reduce\n    (fn\n      [prev item]\n      (set (concat prev (for [x prev y item] (conj x y))))\n      )\n    #{#{}}\n    (replicate (count myset) myset)\n    )\n  )", "user": "58950f29e4b00487982d5270"}, {"problem": 85, "code": "reduce (fn [a e]\n          (into a (map #(conj % e) a)))\n        #{#{}}", "user": "5458c74de4b01be26fd74623"}, {"problem": 85, "code": "(fn powerset [aset]\n  (if (first aset)\n    (let [subsets (powerset (rest aset))]\n      (into #{} (map set (concat subsets (map (partial cons (first aset)) subsets)))))\n    #{#{}}))", "user": "50e1bdd8e4b019fc399ce17f"}, {"problem": 85, "code": "(fn [s] \n  (reduce (fn [a x]\n            (->> a\n                 (map #(set (concat #{x} %)))\n                 (concat a)\n                 set))\n          #{#{}} s))", "user": "58b51e05e4b0ebc645576d4c"}, {"problem": 85, "code": "(fn power-set [s]\n  (set\n   (if (empty? s)\n     (list #{})\n     (let [ele (first s)\n           subset (remove #{ele} s)\n           power-subset (power-set subset)]\n       (concat power-subset (map #(conj % ele) power-subset))))))", "user": "5879d577e4b01531a375ead8"}, {"problem": 85, "code": "(fn [s]\n  (reduce (fn [coll val]\n            (into coll (map (fn [subset]\n                              (if (contains? subset val) (disj subset val)\n                                  (conj subset val))) coll)) \n            ) #{#{}} s)\n  )", "user": "589037b4e4b00487982d51d0"}, {"problem": 85, "code": "(fn ps\n  [coll]\n  (if (empty? coll)\n    #{#{}}\n    (let [c (set (list (first coll)))\n          r (set (rest coll))]\n      (if (empty? r)\n        (set (list c r))\n        (let [cr (ps r)\n              crc (set (map #(into % c) cr))]\n          (into cr crc))))))", "user": "57625c18e4b0994c1922fba4"}, {"problem": 85, "code": "(fn [s] (loop [set-x s\n               power-set #{#{}}]\n          (let [elem (first set-x)]\n            (if elem\n              (recur (disj set-x elem) (mapcat (juxt identity #(conj % elem)) power-set))\n              (into #{} power-set)))))", "user": "57b7de74e4b0fbc9809a27d4"}, {"problem": 85, "code": "(fn [s]\n  (reduce (fn [a b]\n            (into a\n                  (for [x s\n                        y a]\n                    (disj y x)))) #{s} s))", "user": "58bb218be4b0888cdc949cf4"}, {"problem": 85, "code": "(fn subsets [lst]\n  (letfn [(rec [lst]\n            (if (empty? lst)\n              #{#{}}\n              (let [result (subsets (rest lst))]\n                (concat (map (fn [x]\n                               (conj x (first lst)))\n                             result)\n                        result))))]\n    (set (rec lst))))", "user": "5895477fe4b00487982d527c"}, {"problem": 85, "code": "(fn power-series2 [s]\n  (if (= s #{})\n    #{#{}}\n    (set (let [get-series-ele (fn get-series-ele [cur-set size left-set]\n                                (set\n                                 (if (= (count cur-set) (dec size))\n                                   (map #(conj cur-set %) (apply disj s cur-set))\n                                   (apply concat (map #(get-series-ele (conj cur-set %) size (disj left-set %)) left-set)))))]\n           (apply concat #{s #{}} (map #(get-series-ele #{} % (set (butlast s))) (range 1 (count s))))))))", "user": "586b6753e4b01531a375e956"}, {"problem": 85, "code": "(partial reduce (fn [a b] (reduce #(conj %1 (conj %2 b)) a a)) #{#{}})", "user": "58923efce4b00487982d521c"}, {"problem": 85, "code": "(fn [s] (reduce\n         (fn [a x]\n           (into a (map #(conj % x) a)))\n         #{#{}}\n         s))", "user": "4f037faf535dcb61093f6af8"}, {"problem": 85, "code": "(fn [s]\n  (let [power (fn [s]\n                (loop [[f & r] (seq s)\n                       p '(())]\n                  (if f\n                    (recur r (concat p (map (partial cons f) p)))\n                    p)))]\n    (set (map set (power s)))))", "user": "4f066916535dcb61093f6c10"}, {"problem": 85, "code": "(fn [s] (set (reduce\n                                     (fn [acc nv]\n                                       (concat\n                                        acc\n                                        (map #(conj % nv) acc))\n                                       )\n                                     #{#{}} s)))", "user": "567b2f20e4b05957ce8c61a2"}, {"problem": 85, "code": "(fn powerset [s]\n  (if (empty? s)\n    #{#{}}\n    (let [rest-set (powerset (next s))]\n      (clojure.set/union rest-set\n                         (map #(conj % (first s)) rest-set)))))", "user": "58a2b57fe4b02bd94d917ede"}, {"problem": 85, "code": "(fn [xs]\n  (reduce\n   (fn [r x]\n     (conj r\n           (->> (reverse (seq (Integer/toString x 2)))\n                (map #(read-string (str %)))\n                (map-indexed vector)\n                (filter #(= (second %) 1))\n                (map first)\n                (map (vec xs))\n                (set))))\n   #{}\n   (range (Math/pow 2 (count xs)))))", "user": "58c2df0ae4b021aa9917ed17"}, {"problem": 85, "code": "(fn [coll]\n  (reduce\n     (fn [r x]\n       (into r (map #(conj % x) r)))\n     #{#{}}\n     coll))", "user": "58ca8a1de4b03c36ff7e5835"}, {"problem": 85, "code": "(fn power-set\n  [a-seq]\n  (loop [[start & more] (vec a-seq) da-power-set #{#{}}]\n     (if start\n       (recur more (into da-power-set (map #(conj % start) da-power-set)))\n       da-power-set)))", "user": "580d2788e4b0849f6811b730"}, {"problem": 85, "code": "(fn power-set [coll]                                                                                                                                                    \n  (reduce                                                                                                                                                                 \n   (fn [ps x]                                                                                                                                                             \n     (into ps (map #(conj % x) ps)))                                                                                                                                     \n   #{#{}}                                                                                                                                                                 \n   coll))", "user": "4f1ef6a0535d64f60314649b"}, {"problem": 85, "code": "(fn [data]\n  (let [n (count data)\n        nums (range 0 (reduce * (repeat n 2)))\n        zipper (fn [a b] (when (= \\1 a) b))\n        to-binary (fn [numbr size]\n                    (let [val (Integer/toString numbr 2)\n                          pad (apply str (repeat (- n (count val)) \\0))]\n                      (str pad val)))]\n    (into #{} (map (fn [x] (into #{} (filter (complement nil?)  (map zipper (to-binary x n) data)))) nums))))", "user": "5832be57e4b089d5ab817c86"}, {"problem": 85, "code": "(fn new-sets \n  ([prev-sets new-el] (set \n    (concat prev-sets \n      (map #(set (cons new-el % )) prev-sets))))\n  ([orig-set] (reduce #(new-sets %1 %2) #{#{}} orig-set)))", "user": "575ddfd1e4b02ea11479938d"}, {"problem": 85, "code": "(fn [ss] (->> (map (fn [v] #(->> v (conj %2) (conj %1))) ss)\n              (reduce #(reduce %2 %1 %1) #{#{}})))", "user": "567d132ee4b05957ce8c61c3"}, {"problem": 85, "code": "(partial reduce \n         (fn [c x]\n          (into c (map #(conj % x) c)))\n        #{#{}})", "user": "53fe1b42e4b0de5c418485f1"}, {"problem": 85, "code": "(fn power-set [s]\n  (if (= #{} s)\n    #{#{}}\n    (letfn [(permutations [n]\n              (let [size (Math/pow 2 n)\n                    initial-input (range 1 (inc size))\n                    result (loop [i 1\n                                  toggle 1\n                                  current 1\n                                  input initial-input\n                                  output []\n                                  acc []\n                                  left n]\n                             (cond\n                               (zero? left) acc\n\n                               (empty? input) (recur 1\n                                                     (* toggle 2)\n                                                     1\n                                                     initial-input\n                                                     []\n                                                     (conj acc output)\n                                                     (dec left))\n\n                               (= i toggle) (recur 1\n                                                   toggle\n                                                   (if (zero? current) 1 0)\n                                                   (rest input)\n                                                   (conj output current)\n                                                   acc\n                                                   left)\n\n                               :else (recur (inc i)\n                                            toggle\n                                            current\n                                            (rest input)\n                                            (conj output current)\n                                            acc\n                                            left)))]\n                (apply mapv vector result)))]\n      (let [ps (permutations (count s))\n            v (vec s)]\n        (reduce\n         (fn [acc val]\n           (->> val\n                (map-indexed\n                 (fn [i x] (if (zero? x) nil (nth v i))))\n                (remove nil?)\n                set\n                (conj acc)))\n         #{}\n         ps)))))", "user": "55fbc657e4b0f488688e0666"}, {"problem": 85, "code": "(fn powerset [s]\n      (reduce \n        #(into % (for [subset %] \n                   (conj subset %2))) \n        #{#{}} s))", "user": "58dcb8cde4b0a4d5acaab6a7"}, {"problem": 85, "code": "(fn power-set [x]\n  (let [permute (fn permute [s]\n                 (if (empty? s)\n                     s\n                     (let [perm-rest (permute (rest s))\n                           hd        (first s)] \n                      (concat [s] [[hd]] (map #(conj % hd) perm-rest) perm-rest))))]\n   (conj (set (map set (permute x))) #{})))", "user": "58dcf11ae4b0a4d5acaab6af"}, {"problem": 85, "code": "(fn power-set [set]\n  (reduce \n   #(into %1 (for [subset %1] \n              (conj subset %2))) \n   #{#{}} set))", "user": "58ed713de4b056aecfd47d84"}, {"problem": 85, "code": "(fn powerset\n  ([coll] (powerset coll #{#{}}))\n  ([coll res]\n   (if (seq coll)\n     (let [x (first coll)\n           ncoll (set (rest coll))\n           nres (set (map #(conj % x) res))]\n       (recur ncoll (clojure.set/union res nres)))\n     res)))", "user": "58b989dbe4b0888cdc949ccd"}, {"problem": 85, "code": "(fn\n  [hs]\n  (reduce (fn [acc n] (into #{} (mapcat #(vector % (conj % n)) acc))) #{#{}} hs))", "user": "5796d3ebe4b039eba2ecb0ee"}, {"problem": 85, "code": "(fn [s]\n  (reduce\n    (fn [results el]\n      (apply conj results\n             (map #(conj % el) results)))\n  #{#{}}\n  s))", "user": "56ff45e5e4b08d47c97781bb"}, {"problem": 85, "code": "(fn PS\n  [S]\n  (if (empty? S) #{#{}}\n      (let [T (clojure.set/difference S #{(first S)})]\n        (set (clojure.set/union\n              (PS T)\n              (map #(clojure.set/union #{(first S)}\n                                       %)\n                   (PS T)))))))", "user": "5893c64ce4b00487982d524b"}, {"problem": 85, "code": "(comp (fn myps [[s & r]]\n          (if s\n            (let [ps (myps r)]\n              (into ps (map #(into % [s]) ps)))\n            #{#{}})) vec)", "user": "51a3be77e4b0e77c4ca60bf8"}, {"problem": 85, "code": "(fn powerset [s]\n  (reduce #(into % (for [subset %] (conj subset %2))) #{#{}} s))", "user": "53dbca12e4b094d41abdfef6"}, {"problem": 85, "code": "(fn power-set [s]\n    (set\n      (reduce\n        (fn [accu item]\n          (->> accu\n               (map #(conj % item))\n               (concat accu)))\n        [#{}] s)))", "user": "58ec1e63e4b056aecfd47d54"}, {"problem": 85, "code": "(fn power-set [a-set]\n  (let [a-vec (vec a-set)]\n    (loop [index 0\n           set-of-sets #{#{}}]\n      (let [curr-val (get a-vec index)]\n        (if (< index (count a-vec))\n          (recur (inc index)\n                 (reduce (fn [power-set subset] (conj power-set (conj subset curr-val)))\n                         set-of-sets\n                         set-of-sets))\n          set-of-sets)))))", "user": "58f2e8fbe4b0438e51c2ce94"}, {"problem": 85, "code": "(fn power-set [col] (set (reduce (fn [base x] (concat (map #(conj % x) base) base)) #{#{}} col)))", "user": "58987ee9e4b00487982d52d2"}, {"problem": 85, "code": "(fn [s]\n      (->> ((fn f [xs]\n              (if (zero? (count xs))\n                '(())\n                (let [ys (f (rest xs))]\n                  (concat ys (map #(cons (first xs) %) ys)))))\n            (seq s))\n           (map #(apply hash-set %))\n           (apply hash-set)))", "user": "58c4b11ae4b021aa9917ed2c"}, {"problem": 85, "code": "(fn [coll] \n  (reduce (fn [a x]\n            (->> a\n                 (map #(set (concat #{x} %)))\n                 (concat a)\n                 set)) \n          #{#{}} coll))", "user": "5566d812e4b0c656e3ff1837"}, {"problem": 85, "code": "(fn [s]\n   (set (reduce (fn [acc n] (concat acc (map #(conj % n) acc ))) #{#{}} s)))", "user": "58d27bcae4b03c36ff7e58fe"}, {"problem": 85, "code": "(partial \n    (fn power-set [acc cur rest]\n      (if (contains? acc cur)\n          acc\n          (clojure.set/union\n            #{cur}\n            (reduce (fn [acc' x] (power-set acc' (conj cur x) (disj rest x))) acc rest)))) \n    #{} \n    #{})", "user": "5901158de4b0438e51c2d039"}, {"problem": 85, "code": "(fn powerset [xs]\n  (if (empty? xs)\n    #{#{}}\n    (let [nxt (powerset (next xs))]\n      (clojure.set/union\n       nxt\n       (map #(conj % (first xs)) nxt)))))", "user": "54d9f7f1e4b024c67c0cf751"}, {"problem": 85, "code": "(fn p-85 [s]\n  (reduce (fn [power-set new-elem]\n            (clojure.set/union\n              power-set\n              (map #(conj % new-elem) power-set)))\n          #{#{}}\n          s))", "user": "501d34f6e4b066e56b9d0b1e"}, {"problem": 85, "code": "(fn [ u]\n  (reduce (fn [a e]\n       (reduce #(conj % (conj %2 e)) a a))\n     #{#{}} u))", "user": "58f45ea0e4b0438e51c2cebc"}, {"problem": 85, "code": "(fn subs [se]\n  (if (empty? se) #{#{}}\n      (let [one-of (first se) rest-of (subs (rest se))]\n        (set (map #(set %) (concat rest-of \n                                    (map #(cons one-of %) rest-of )))))))", "user": "59156f0be4b0163c97b36f3d"}, {"problem": 85, "code": "(fn powerset [input-set]\n  (let [ve (vec input-set)\n        cnt (count ve)\n        end (int (Math/pow 2 cnt))\n        ]\n    (if (= cnt 0)\n      #{#{}}\n      (loop [idx 0\n             bitstr (Integer/toBinaryString idx)\n             result #{}]\n        (if (= idx end)\n          result\n          (recur (inc idx)\n                 (Integer/toBinaryString (inc idx))\n                 (conj\n                   result\n                   ((fn [v bitv]\n                      (set (map first (filter #(= (second %) \"1\") (map #(vector %1 %2) v bitv))))\n                      ) ve (map str (format (str \"%0\" cnt \"d\") (Integer/parseInt bitstr)))))\n                 )))\n      )))", "user": "590b3aeae4b047aa04b199d0"}, {"problem": 85, "code": "(fn [xset]\n  (reduce (fn [init-set node]\n            (->>\n             (map #(conj % node) init-set)\n             (apply merge init-set))) #{#{}} xset))", "user": "591072e0e4b0163c97b36ebc"}, {"problem": 85, "code": "(fn p-set-fn\n  ([xs] (p-set-fn xs #{#{}}))\n  ([xs p-set]\n   (if (empty? xs)\n     p-set\n     (recur (rest xs) (set (concat p-set (map #(conj % (first xs)) p-set)))))))", "user": "564c8e99e4b0284900eef674"}, {"problem": 85, "code": "(fn a [xs]\n          (loop [s (clojure.set/union #{#{}} (set (for [i xs] #{i})))]\n            (let [n (clojure.set/union\n                      s\n                      (set (for [x s y s :when (and (= (count x) 1) (not= x y))]\n                             (clojure.set/union x y)\n                             )))]\n              (if (= s n) n\n                          (recur n))))\n          )", "user": "5921a080e4b09b4ee5954c77"}, {"problem": 85, "code": "(fn [coll]\n  ((fn sub [possible-sets remain]\n          (if (empty? remain)\n            possible-sets\n            (sub (reduce #(conj %1\n                                %2\n                                (conj %2 (first remain)))\n                         possible-sets\n                         possible-sets)\n                 (rest remain)))) #{#{}} coll))", "user": "5823d3e6e4b051871117beb8"}, {"problem": 85, "code": "(fn [a-set]\n  (if (empty? a-set)\n    #{#{}}\n    (letfn [(my-enumerate [n]\n                          (cond \n                           (= n 0) '()\n                           (= n 1) (list '(true) '(false))\n                           :else (let [r (my-enumerate (- n 1))]\n                              (concat (map #(cons true %) r)\n                                      (map #(cons false %) r)))))\n            (get-item [bool-list a-vector]\n                      (->> (map #(vector %1 %2) bool-list a-vector)\n                           (filter #(first %))\n                           (map #(second %))\n                           (set)))]\n      (let [v (apply vector a-set)]\n        (->> (my-enumerate (count v))\n             (map #(get-item % v))\n             (set))))))", "user": "59225498e4b09b4ee5954c8c"}, {"problem": 85, "code": "(fn power-set [coll]\n  (letfn [(add-elem [result elem] (apply merge result (map #(conj % elem) result)))]\n     (reduce add-elem #{#{}} coll)))", "user": "58fb7d7ae4b0438e51c2cf7a"}, {"problem": 85, "code": "(fn [x] (set \n   (reduce \n     (fn [ps x] (into ps (map #(conj % x) ps))) \n       (list (set nil)) (apply list x))))", "user": "58e7229fe4b056aecfd47cc4"}, {"problem": 85, "code": "(fn \n  ps \n  [A] \n  (if (empty? A) \n    #{#{}} \n    (let \n      [sub (ps (into #{} (rest A)))] \n      (into \n       sub \n       (map \n        #(into % (list (first A))) sub)))))", "user": "56449e4de4b0284900eef5f9"}, {"problem": 85, "code": "(fn f [xs]\n  (set (reduce (fn [ys,y]\n    (concat ys (map #(conj % y) ys))) [#{}] xs)))", "user": "5933b736e4b072a2710fd05d"}, {"problem": 85, "code": "(fn f85\n  [s]\n  (if (empty? s)\n    #{#{}}\n   (let [res (f85 (rest s))]\n    (clojure.set/union res (map #(conj % (first s)) res)))))", "user": "557e8326e4b05c286339e0d7"}, {"problem": 85, "code": "(fn [s]\n  (let [p (fn powerset [s] \n            (if (empty? s)\n              '(())\n              (concat (powerset (rest s))\n                                 (map #(conj % (first s)) (powerset (rest s))))))]\n    (set (map set (p s)))))", "user": "59368ccae4b02506e01a297a"}, {"problem": 85, "code": "(fn [s]\n  (loop [uberset #{}\n         level #{s}]\n    (if (= level #{#{}})\n      (into uberset level)\n      (recur (into uberset level)\n             (into #{} (mapcat (fn [lset]\n                                 (map #(disj lset %)\n                                      lset))\n                               level))))))", "user": "580bd81ee4b0849f6811b711"}, {"problem": 85, "code": "(fn [s]\n  (let [v (vec s)]\n    (into #{}\n          (for [x (range (reduce * (repeat (count s) 2)))]\n            (into #{}\n                  (->> v\n                       count\n                       range\n                       (map #(when (bit-test x %) (v %)))\n                       (filter (complement nil?))))))))", "user": "59074b7ce4b047aa04b19951"}, {"problem": 85, "code": "(fn power-set [s]\n  (reduce\n   (fn [coll v]\n     (clojure.set/union coll (map\n                        #(conj % v)\n                        coll)))\n   #{#{}} s))", "user": "55c66ffee4b0e31453f649c2"}, {"problem": 85, "code": "(fn powerset [s]\n  (reduce #(into % (for [subset %] (conj subset %2))) #{#{}} s))", "user": "5938bae2e4b02506e01a29ea"}, {"problem": 85, "code": "(fn powerset [coll]\n    (if (empty? coll) #{#{}}\n        (let [[head & tail] (into [] coll)\n              pset (powerset tail)]\n          (into #{} (concat (map #(conj % head) pset)\n                            pset)))))", "user": "5935b010e4b04f87174def55"}, {"problem": 85, "code": "(fn powerset [c]\n  (if (empty? c)\n    #{#{}}\n    (let [sub (powerset (rest c))]\n      (set (concat sub (map #(conj % (first c)) sub))))))", "user": "5953bdb6e4b066ee0a44aeed"}, {"problem": 85, "code": "(fn powerset [s]\n  (reduce #(into % (for [subset %] (conj subset %2))) #{#{}} s))", "user": "592518cde4b072a2710fce66"}, {"problem": 85, "code": "(fn powerset [s]\n  (reduce #(into % (for [subset %] (conj subset %2))) #{#{}} s))", "user": "592518e8e4b072a2710fce67"}, {"problem": 85, "code": "(fn powerset [s]\n  (reduce #(into % (for [subset %] (conj subset %2))) #{#{}} s))", "user": "5948adffe4b07ddc2dafadc6"}, {"problem": 85, "code": "(fn powerset [s]\n  (reduce #(into % (for [subset %] (conj subset %2))) #{#{}} s))", "user": "59251947e4b072a2710fce69"}, {"problem": 85, "code": "(fn powerset [s]\n  (reduce #(into % (for [subset %] (conj subset %2))) #{#{}} s))", "user": "592519cfe4b072a2710fce6b"}, {"problem": 85, "code": "(fn [s]\n  (loop [queue #{s} done #{}]\n        (if-let [e (first queue)]\n                (recur (into (disj queue e) (keep #(let [ss (disj e %)] (if (not (done ss)) ss)) e)) (conj done e))\n                done)))", "user": "5958cef6e4b066ee0a44af94"}, {"problem": 85, "code": "(fn __ [x]\n  (reduce\n    (fn [acc i] (clojure.set/union acc (map (fn [r] (conj r i)) acc)))\n    #{#{}}\n    x))", "user": "58bc6a88e4b0888cdc949d16"}, {"problem": 85, "code": "(fn ps [s]\n  (cond\n    (empty? s) #{s}\n    :else\n    (let [f (first s)\n          r (set (rest s))\n          rp (ps r)]\n      (into rp (for [x rp] (conj x f)))\n    )\n  )\n)", "user": "5943abb6e4b060784b3b792b"}, {"problem": 85, "code": "(fn [s]\n    (letfn [(comb [k l]\n              (if (= 1 k) (map vector l)\n                  (apply concat\n                         (map-indexed\n                          #(map (fn [x] (conj x %2))\n                                (comb (dec k) (drop (inc %1) l)))\n                          l))))]\n      (set (apply concat\n                  #{#{}}\n                  (for [x (range 1 (inc (count s)))]\n                    (map #(set %) (comb x s)))))))", "user": "595bbab7e4b066ee0a44afe0"}, {"problem": 85, "code": "(fn [in]\n  (let [bin (map #(Integer/toString % 2) (range 0 (reduce * (repeat (count in) 2))))]\n    (into #{}\n          (map (fn [nm bin]\n                 (into #{} (remove nil? (map #(if (= %2 \"1\") %1 nil) (vec nm) (->> bin seq (map str))))))\n               (repeat in)\n               (map #(str (apply str (repeat (-> bin last count (- (count %))) \"0\")) %) bin)))))", "user": "586b6a0ae4b01531a375e957"}, {"problem": 85, "code": "(fn ps [s]\n  (if (empty? s)\n    #{#{}}\n    (let [rec (ps (rest s))]\n      (clojure.set/union rec (map #(clojure.set/union #{(first s)} %) rec)))))", "user": "58ee84e5e4b056aecfd47dab"}, {"problem": 85, "code": "(fn [ss]\n  (loop [rs #{#{}}]\n    (let [rs1 (into rs\n                (mapcat\n                  (fn [v] \n                    (if (empty? rs)\n                      #{v}\n                     (map #(conj % v) rs)))\n                  ss))]\n        (if (= rs rs1)\n            rs\n            (recur rs1)))))", "user": "593f95d8e4b069cdc2982be3"}, {"problem": 85, "code": "(fn subsets [s]\n  (if (seq s)\n    (let [ss (subsets (rest s)), fs (first s)]\n      (set (concat ss (map #(conj % fs) ss))))\n    #{#{}}))", "user": "57ee804ee4b0bfb2137f5bbb"}, {"problem": 85, "code": "(fn powerset [s]\n  (reduce #(into % (for [subset %] (conj subset %2))) #{#{}} s))", "user": "58866b4fe4b0f1effa3b76d4"}, {"problem": 85, "code": ";(time(\n(fn [item-set]\n  (let [items (vec item-set)\n        max-power\n          (first(drop\n           (count items)\n           (iterate\n            #(* 2 %)\n            1)))\n        decompose\n         (fn [i]\n           (map\n            first\n            (filter\n             (comp second second)\n             (map-indexed\n              vector\n              (take\n               (count items)\n               (drop\n                1\n                (iterate\n                 (fn [[i b]]\n[(bit-shift-right i 1)\n (= 1 (bit-and i 1))])\n                 [i nil])))))))\n        to-vals\n          (fn [li is]\n            (map\n             #(set (map\n               (partial nth li)\n               %))\n             is))]\n    (set (to-vals\n          items\n          (map\n           decompose\n           (range 0 max-power))))))\n;#{:a :b :c :d :e :f :g :h :i :j}))", "user": "586a657de4b0f14aab7c88bd"}, {"problem": 85, "code": "(fn ps[sx] (\n              letfn [\n                     (rd [sy] (\n                                if (set? sy)\n                                (concat #{sy} (set (map #(set (remove #{%} sy)) sy)))\n                                #{sy}\n                                \n                                ))\n                     (rx [s] (set (reduce #( concat %1 (rd %2)) #{} s)))\n                     \n                     \n                     ]\n              \n              \n              ((fn rec[sz cnt] (\n                                if (> cnt 0) (rec (rx sz) (dec cnt))\n                                sz\n                                )) #{sx} (count sx))\n              \n                 ))", "user": "596f6683e4b069c0a1a19877"}, {"problem": 85, "code": "(fn power-set [s]\n  (if (empty? s)\n    #{s}\n    (let [head (first s)\n          tail (disj s head)\n          subset (power-set tail)]\n      (clojure.set/union\n       subset\n       (map #(clojure.set/union #{head} %) subset)))))", "user": "587ee260e4b052da650a6353"}, {"problem": 85, "code": "(comp\n  (fn f [[x & r :as xs]]\n    (if x\n      (let [r (f r)]\n        (set (concat (map #(conj % x) r) r)))\n      #{#{}}))\n  seq)", "user": "4fb1d7ace4b081705acca281"}, {"problem": 85, "code": "(fn power-set [x]\n  (loop [[a & others :as x] (vec x)\n         subsets #{#{}}]\n    (if (empty? x)\n      subsets\n      (recur others\n             ;; double the number of sets: for each existing set, either add a, or don't.\n             (into subsets \n                   (for [y subsets]\n                             (conj y a)))))))", "user": "569f99cce4b0542e1f8d1497"}, {"problem": 85, "code": "(fn superset [s]\n  (let [gen-subset (fn gen-subset [col mask]\n                     (let [col-idx (map-indexed #(list %1 %2) col)\n                           col-filtered (filter\n                                         #(not= 0 (bit-and (bit-shift-left 1 (first %)) mask))\n                                         col-idx)]\n                       (map second col-filtered)))\n\n        pow #(apply * (take %2 (repeat %1)))\n        elems (into '() s)\n        perms (range (pow 2 (count elems)))\n        sublists (map #(gen-subset elems %) perms)\n        subsets (map set sublists)]\n    (set subsets)))", "user": "58fc92c5e4b0438e51c2cf9a"}, {"problem": 85, "code": "(fn power-set\n ([s]\n  (power-set s #{#{}}))\n ([s result]\n  (if (empty? s)\n   result\n   (power-set\n    (rest s)\n    (into result\n     (map\n      #(into\n       #{(first s)} %)\n      result))))))", "user": "598ab445e4b02b9968b84ce0"}, {"problem": 85, "code": "(fn power-set\n  ([items] (power-set items #{}))\n  ([items current]\n  \t(if (empty? items)\n  \t  #{current}\n      (set (concat (power-set (rest items) current) (power-set (rest items) (conj current (first items)))))\n    )\n  )\n)", "user": "5991d2fae4b0866487ed0d68"}, {"problem": 85, "code": "reduce #(set(mapcat(fn[x][x(conj x%2)])%))#{#{}}", "user": "59a24c92e4b066c664927d20"}, {"problem": 85, "code": "#(if-not %\n   #{%}\n   (reduce (fn[a _]\n             (into a (for [e %\n                           x a\n                           :when(not(x e))]\n                       (conj x e))))\n           #{#{}}\n           %))", "user": "51a10b2ce4b0b292b01ee3fe"}, {"problem": 85, "code": "(fn [S]\n     (letfn [(n-perm [S n]\n        (let [bs  (map #(bit-test n %) (range (count S)))\n              mbs (zipmap S bs)]     \n          (into #{} (filter mbs S))))] \n     (into #{} (map #(n-perm S %) (range (reduce * (repeat (count S) 2))))) \n     ))", "user": "56fa2905e4b07572ad1a88be"}, {"problem": 85, "code": "(fn [s]\n   (set (map set (loop [[f & r] (seq s) p '(())]\n      (if f (recur r (concat p (map (partial cons f) p)))\n            p)))))", "user": "590b055ae4b047aa04b199c9"}, {"problem": 85, "code": "(fn [ss] (->> (map (fn [v] #(->> v (conj %2) (conj %1))) ss)\n              (reduce #(reduce %2 %1 %1) #{#{}})))", "user": "596d630ae4b069c0a1a19846"}, {"problem": 85, "code": "(fn power\n\t([s]\n\t\t(if (empty? s) \n\t\t\t#{#{}} \n\t\t\t(power s #{s #{}})))\n\t([s r]\n\t\t(if (empty? s)\n\t\t\tr\n\t\t\t(power (set (rest s)) \n\t\t\t\t(->> r\n\t\t\t\t\t(map #(clojure.set/union (hash-set (first s)) %))\n\t\t\t\t\tset\n\t\t\t\t\t(clojure.set/union r))))))", "user": "5954eef0e4b066ee0a44af17"}, {"problem": 85, "code": "(fn [ baseSet ]\n\t(reduce (fn [acc item]\n\t\t(clojure.set/union\n\t\t\tacc\n\t\t\t(set (map #(clojure.set/union % #{ item }) acc))))\n\t\t#{#{}} baseSet\n\t)\n)", "user": "598af379e4b02b9968b84ce6"}, {"problem": 85, "code": "(fn [x]\n        (let [x' (vec x)\n              two-n #(reduce * (repeat % 2))\n              n (count x')\n              p (two-n n)\n              \n              make-set\n              (fn [x bw]\n                (let []\n                  (loop [bit 0\n                         res #{}]\n                    (if (= bit n)\n                      res\n                      (if (zero? (bit-and (two-n bit) bw))\n                        (recur (inc bit) res)\n                        (recur (inc bit) (conj res (nth x' bit))))))))]\n\n          (set (for [bw (range (two-n n))]\n                 (make-set x bw)))))", "user": "57e6f90de4b0bfb2137f5af6"}, {"problem": 85, "code": "(fn power-set [s] (letfn [\n    (inc-range [s mx]\n        (let [size (count s)]\n            (loop [i (dec size)]\n                (if (and (= i 0) (= (first s) (- mx size)))\n                    nil\n                    (if (< (nth s i) (- mx (- size i)))\n                        (vec (concat (take i s) (take (- size i) (iterate inc (inc (nth s i)) )) ))\n                        (recur (dec i))\n                    )\n                )\n            )\n        )\n    )\n    (filter-by-index [coll idxs]\n        (keep-indexed #(when ((set idxs) %1) %2) \n                      coll))\n    (subsets [s m]\n        (let [n (count s)]\n            (loop [result #{} i (vec (range m))]\n                (if (not i)\n                    result\n                    (recur (conj result (set (filter-by-index s i))) (inc-range i n)))\n            )\n        )\n    )]\n    (reduce (fn [a b] (into a (subsets s b))) #{#{}} (range 1 (inc (count s))))\n))", "user": "59a0262ee4b0871e7608b82d"}, {"problem": 85, "code": "(fn power-set [s]\n  (loop [result #{#{}}\n         relements s\n         ne (first relements)]\n    (if ne\n      (recur (into result (for [e result] (conj e ne)))\n             (next relements)\n             (second relements))\n      result)))", "user": "5866b999e4b0f14aab7c886b"}, {"problem": 85, "code": "(fn powerset [s]\n  (reduce #(into % (for [subset %] (conj subset %2))) #{#{}} s))", "user": "59358f74e4b04f87174def52"}, {"problem": 85, "code": "(fn [xs]\n  (let [pow  (fn [n exp] (apply * (repeat exp n)))\n        v    (vec xs)\n        exp  (count v)\n        bits (mapv #(vector %1 (pow 2 %2)) (range) (range exp))\n        bmap (fn [n]\n               (for [[i b] bits :when (= b (bit-and b n))]\n                 (nth v i)))]\n    (->> (range (pow 2 exp))\n         (map bmap)\n         (map set)\n         set)))", "user": "59eb63e3e4b0249b7282077c"}, {"problem": 85, "code": "(fn power-set [coll]\n        (if (empty? coll)\n          #{#{}}\n          (let [xs (seq coll)\n                next (first xs)\n                prev (power-set (rest xs))]\n            (reduce conj prev (map #(conj % next) prev))\n          )))", "user": "59f78b49e4b0ca45a743a30e"}, {"problem": 85, "code": "(fn p\n  [d]\n  (letfn [(pp [d1 d2]\n            (into #{}\n                  (for [i d1\n                        j d2]\n                    (conj j i))))]\n    (loop [i (count d)\n           r (set (map #(set (vector %)) d))]\n      (if (zero? i)\n        (conj r #{})\n        (recur (dec i) (pp d r))))))", "user": "54a11042e4b09f271ff37c49"}, {"problem": 85, "code": "(fn powerset [s]\n  (reduce #(into %1 (for [x %1] (conj x %2))) #{#{}} s))", "user": "572de985e4b0cd1946bd0f7c"}, {"problem": 85, "code": "(fn\n  [s]\n  (letfn [(cj \n           [prev-res rest-set]\n           (-> \n            (for [p-r prev-res r-s rest-set \n                  :when (-> p-r (contains? r-s) not)]\n              (conj p-r r-s)) \n            (concat prev-res)\n            set))]\n    (loop [p-r #{#{}} r-s s]\n      (if (empty? r-s)\n        p-r\n        (recur (cj p-r r-s) (rest r-s))))))", "user": "59f91b99e4b0ca45a743a33a"}, {"problem": 85, "code": "(fn power-set [s]\n  (reduce (fn [a item]\n            (into a (map #(conj % item) a)))\n          #{#{}}\n          s))", "user": "5880e38fe4b0f1effa3b7625"}, {"problem": 85, "code": "(fn __ [s]\n  (if (= (count s) 0)\n    #{#{}}\n    (let [first-s (first s)\n          rest-s  (__ (rest s))]\n      (clojure.set/union rest-s\n                         (set (map #(conj % (first s)) rest-s))))))", "user": "55916764e4b0604b3f94d57b"}, {"problem": 85, "code": "(fn p [xs]\n    (let [f (first xs)\n          r (disj xs f)]\n      (if (seq xs)\n        (set (concat (map #(conj % f) (p r)) (p r)))\n        #{#{}})))", "user": "59fa241ee4b0ca45a743a358"}, {"problem": 85, "code": "(fn [s]\n  (->> #{s}\n       (iterate (fn [z]\n                  (reduce (fn [z s]\n                            (into z (map #(disj s %) s)))\n                          #{}\n                          z)))\n       (take-while seq)\n       (reduce into #{#{}})))", "user": "53ea5851e4b036ad0777e4e4"}, {"problem": 85, "code": "(fn [s] (letfn [\n            (bits [res k n] (if (< n 2) (if (> k (count res)) (recur (cons n res) k 0) res) \n                               (recur (cons (mod n 2) res) k (int (/ n 2)) )\n                            )\n                  )\n            (myexp [r n] (reduce * (repeat n r)))               \n            (zips [k ss] (partition 2 (interleave (bits [] (count ss) k) ss)))\n                ]\n           (let [len (count s)\n                  lim (myexp 2 len)\n                 hf (fn [xs] (for [x (map #(zips % xs) (range lim))]\n                                  (map #(second %) (filter #(= 1 (first %)) x))\n                               ))\n                 ]\n             \n             (set (map set (hf s)))\n           )  \n        )\n )", "user": "59ff9424e4b01bb0ae8afd24"}, {"problem": 85, "code": "(fn __ [s]\n  (let [pow2   (fn [n] (bit-shift-left 1 n))\n        vs     (map vector (map #(pow2 %) (range (count s))) (for [x s] x))\n        subset (fn [n] (set (for [[k v] vs :when (not (zero? (bit-and k n)))] v)))]\n    (set (map subset (range (pow2 (count s)))))))", "user": "58f44c07e4b0438e51c2ceb7"}, {"problem": 85, "code": "(fn subsets [s]\n   (letfn [(f [e t]\n             (map (fn [x] (conj x e)) t))]\n    (if (empty? s)\n      #{#{}}\n      (let [e (first s)]\n        (clojure.set/union (subsets (disj s e)) (f e (subsets (disj s e))))))))", "user": "5a250b86e4b07f18be40aa19"}, {"problem": 85, "code": "(fn p [s]\n  (if (empty? s)\n    #{#{}}\n    (let\n      [r (p (rest s))]\n      (clojure.set/union r (map #(conj % (first s)) r)))))", "user": "5a2df4a0e4b09cafd31c7f74"}, {"problem": 85, "code": "(fn [s] \n\t(let [f (fn [t] \n              (set (for [y t\n                    z y] (clojure.set/difference y #{z}))))] \n     (loop [x (count s)\n            y #{s}\n            acc #{s}]\n           (if (zero? x) \n               (clojure.set/union acc #{#{}})\n               (recur (dec x) (f y) (clojure.set/union acc y))))))", "user": "5a14228fe4b0ff51aa4b3193"}, {"problem": 85, "code": "(fn [a_set]\n    (loop [xs a_set\n           ps #{#{}}]\n         (if (empty? xs)\n             ps\n             (recur (rest xs) ((fn [set_of_sets item]\n                                   (clojure.set/union set_of_sets\n                                                      (set (map (fn [s] (conj s item))\n                                                                set_of_sets)))) ps (first xs))))))", "user": "5a34f342e4b0ddc586f153d1"}, {"problem": 85, "code": "(fn [s]\n   (reduce (fn [r x] (into r (map #(conj % x) r))) #{#{}} s))", "user": "59f043d0e4b0966464fe6a3d"}, {"problem": 85, "code": "(fn [zet] \n  (into (set [zet #{}]) \n        (apply clojure.set/union\n               (for [i zet]\n                 (loop [acc #{#{i}}\n                        remaining (disj zet i)]\n                   (if (empty? remaining) \n                     acc\n                     (let [curr (first remaining)]\n                       (recur (into acc (map #(conj % curr) acc))\n                              (disj remaining curr)))))))))", "user": "57a0f256e4b0c3d858beb8dd"}, {"problem": 85, "code": "(fn powerset [xset]\n  (let [x (first xset)]\n    (if (nil? x)\n      #{#{}}\n      (let [rec (powerset (disj xset x))]\n        (into rec (map #(conj % x) rec))))))", "user": "5773f3a9e4b0979f896515f2"}, {"problem": 85, "code": "(fn f [s] (if (empty? s) #{s} (let [r (f (into #{} (rest s)))] (clojure.set/union r (map #(conj % (first s)) r)))))", "user": "5a4de614e4b05d388ecb6bb1"}, {"problem": 85, "code": "(fn power-set [set]\n  (into #{} (reduce\n   (fn [pset item]\n     (mapcat #(list % (conj % item)) pset))\n     '(#{})\n     set)))", "user": "5a566e8fe4b05d388ecb6c51"}, {"problem": 85, "code": "(fn power-set\n  [sets]\n  (if (empty? sets)\n    #{#{}}\n    (let [v (first sets)\n          ps (power-set (rest sets))]\n      (set (concat (map #(conj % v) ps) ps)))))", "user": "565654dae4b0f9d632dd849f"}, {"problem": 85, "code": "(fn [s] \n  (reduce (fn [a x]\n            [a x]\n            (->> a\n                 (map #(set (concat #{x} %)))\n                 (concat a)\n                 set))\n          #{#{}} s))", "user": "56441634e4b0018b46ad8c08"}, {"problem": 85, "code": "(fn [s]\n    (set (reduce\n           (fn [-set elem]\n             (concat -set\n                     (map (fn [i]\n                            (set (conj i elem)))\n                          -set)))\n           #{#{}}\n           s)))", "user": "53716539e4b0fc7073fd6eb1"}, {"problem": 85, "code": "(fn pow-set [set]\n  (if (empty? set)\n    #{#{}}\n    (let [first-elem (first set) tail (rest set)\n          subpow (pow-set tail)]\n      (apply conj subpow (map #(conj % first-elem) subpow)))))", "user": "5a621702e4b0512ff01cd983"}, {"problem": 85, "code": "(fn power-set [s]\n  (let [n-uples (fn [sn-1]\n                  (loop [sn-1 sn-1\n                         res #{}]\n                    (if (seq sn-1)\n                      (let [hd (first sn-1)\n                            tl (rest sn-1)]\n                        (recur\n                         tl\n                         (reduce #(conj %1 (conj hd %2))\n                                 res\n                                 (reduce #(disj %1 %2) s hd))))\n                      res)))]\n    (loop [n 0\n           sn-1 #{#{}}\n           res #{#{}}]\n      (if (= n (count s))\n        res\n        (let [sn-1 (n-uples sn-1)]\n          (recur (+ n 1) sn-1 (reduce #(conj %1 %2) res sn-1)))))))", "user": "5a6b9b95e4b0512ff01cda40"}, {"problem": 85, "code": "(fn power-set [input]\n    (->> (iterate #(into #{}\n                         (for [o input\n                               s %]\n                           (conj s o)))\n                  (map hash-set input))\n         (take (dec (count input)))\n         (reduce #(into %1 %2)\n                 (conj #{#{}} input))))", "user": "5a5d0726e4b0512ff01cd91b"}, {"problem": 85, "code": "(fn  pset [s]\n(let [\nnum (int (Math/pow 2 (count s)) )] \n(if (<= num 2) (conj #{#{}} s) \n(loop [res #{#{}}] \n(if (= (count res)  (dec num))  (conj res #{}) \n(recur  (set (for [x res t s] (conj x t)))))))))", "user": "5a1c8c26e4b0ff51aa4b3247"}, {"problem": 85, "code": "(fn powerset [s]\n  (if (empty? s)\n    #{#{}}\n    (let [fst (first s) rst (set(rest s)) decom (powerset rst)]\n      (clojure.set/union decom (map #(clojure.set/union #{fst} %) decom))\n      )\n    )\n  )", "user": "562add6de4b00e49c7cb4834"}, {"problem": 85, "code": "(fn ps[s]\n  (if (empty? s)\n    #{#{}}\n    (let [x (first s) sps (ps (disj s x))] (into sps (map #(conj % x) sps)))))", "user": "4fd4bddce4b0d4de60cee36e"}, {"problem": 85, "code": "(fn \n  [s]\n  (loop [subsets (into #{} (map #(hash-set %) s))]\n    (if (or (empty? subsets)\n            (contains? subsets s))\n      (conj subsets #{})\n      (recur (set (mapcat #(map (fn [x] (into % x)) subsets) subsets))))))", "user": "594266cfe4b060784b3b790b"}, {"problem": 85, "code": "(fn powerset [A]\n    (if (empty? A) #{#{}}\n        (let [a (first A)\n              p (powerset (rest A))]\n              (into p (for [s p] (into s #{a}))))))", "user": "59da6480e4b0ef0a1e9b5c68"}, {"problem": 85, "code": "(fn power-set [s]\n  (if (empty? s)\n    #{#{}}\n    (let [prev-sets (power-set (rest s))]\n      (into #{} (concat prev-sets (map #(conj % (first s)) prev-sets))))))", "user": "562cb7cfe4b0a45d2ff83009"}, {"problem": 85, "code": "(fn [target]\n  (loop [result #{target}\n         slicer (map #(hash-set %) target)]\n    (if (not-empty slicer)\n      (recur ((fn [c n] (into c (map #(clojure.set/difference % n) c))) \n              result (first slicer)) (rest slicer))\n      result)))", "user": "5835cb06e4b089d5ab817cea"}, {"problem": 85, "code": "(fn [s]\n  (->> s\n       (reduce (fn [res x]\n                  (->> res\n                       (map #(apply hash-set x %))\n                       (cons #{x})\n                       (into res)))\n               #{})\n       (into #{#{}})))", "user": "58d2af83e4b03c36ff7e5907"}, {"problem": 85, "code": "(comp\n set\n (partial reduce\n          (fn [a e] (concat a (map #(conj % e) a)))\n          '(#{})))", "user": "5a95c639e4b0d174b936c75e"}, {"problem": 85, "code": "(fn power-set\n  [s]\n  (if (seq s)\n     (let [n (first s)\n           rest-sets (power-set (rest s))]\n       (set (concat rest-sets\n                    (map #(conj % n) rest-sets))))\n     #{#{}}))", "user": "5974d2ede4b01722bebd4cb6"}, {"problem": 85, "code": "(fn power-set [xs]\n  (letfn [(combination [xs n]\n                       (if (> n (count xs))\n                         #{}\n                         (if (= n 1)\n                           (set (map #(-> #{%}) xs))\n                           (if (= n (count xs))\n                             #{xs}\n                             (let [previous (combination xs (dec n))]\n                               (set (mapcat\n                                     (fn [c] (let [others (filter #(not (contains? % c)) previous)]\n                                               (set (map #(set (cons c %)) others))))\n                                     xs)))))))]\n    (set (cons #{} (set (mapcat #(combination xs %) (range 1 (inc (count xs)))))))))", "user": "57b9fb56e4b0fbc9809a27fa"}, {"problem": 85, "code": "(fn [in-set]\n             (letfn [(f [set-o-sets e] (into #{} (map #(conj % e) set-o-sets)))\n                     (ps [setx]\n                       (if (empty? setx)\n                         #{#{}}\n                         (let [e (first setx)\n                               t (disj setx e)\n                               p (ps t)]\n                           (concat p (f p e)))))]\n               (into #{} (ps in-set))))", "user": "5a9dbb32e4b0d174b936c7f3"}, {"problem": 85, "code": "(fn power-set\n  [x]\n  (if (empty? x)\n    #{#{}}\n    (let [rest-power-set (power-set (rest x))\n          with-first-power-set (map #(conj % (first x)) rest-power-set)]\n      (clojure.set/union rest-power-set with-first-power-set))))", "user": "57ea2c91e4b0bfb2137f5b42"}, {"problem": 85, "code": "(fn __ [set]\n  (if (seq set)\n    (let [[head & tail] (seq set)\n          others (__ tail)]\n      (into others\n            (map #(conj % head) others)))\n    #{#{}}))", "user": "4eda7cc3535d10e5ff6f530e"}, {"problem": 85, "code": "(fn\n z\n ([x] (z x #{#{}}))\n ([x acc]\n  (if\n   (seq x)\n   (z (rest x) (set (mapcat (fn [s] [s (set (conj s (first x)))]) acc)))\n   acc)))", "user": "58a822e4e4b01a0c0b232950"}, {"problem": 85, "code": "(fn cs9 [n]\n  (reduce #(into %1\n                 (for [s %1]\n                   (conj s %2)))  #{#{}} n))", "user": "5a4443cae4b0447ef91cc60f"}, {"problem": 85, "code": "(fn ps [as]\n(reduce \n\t(fn [r e]\n        (conj (into r (map #(conj % e) r)) #{})\n    ) #{#{}} as))", "user": "5a0ce1a5e4b04bbd27e6d9b7"}, {"problem": 85, "code": "(fn power-set\n  [s]\n  (if (seq s)\n    (let [el (first s)\n          subset (power-set (disj s el))]\n      (apply conj subset (map #(conj % el) subset)))\n    #{#{}}))", "user": "50310713e4b05b7df5a0b84c"}, {"problem": 85, "code": "(fn [original]\n  (loop [result #{}, to-process [original]]\n    (if (empty? to-process)\n      result\n      (let [s (peek to-process)\n            new-sets (filter (complement result) (map #(disj s %) s))]\n        (recur (conj result s) (into (pop to-process) new-sets))))))", "user": "5aa998c6e4b0d174b936c8e5"}, {"problem": 85, "code": "(fn power-set [s]\n  (loop [a #{#{}} r s]\n    (if (empty? r)\n      a\n      (recur (into #{} (concat a (map #(conj % (first r)) a)))\n             (rest r)))))", "user": "5ab564f8e4b073f177442639"}, {"problem": 85, "code": "(fn [original-set]\n    (letfn [(sub-sets\n              [n]\n              (cond\n                (= n 0) #{#{}}\n                (= n 1) (->> (partition 1 original-set)\n                             (map set)\n                             (set))\n                (= n (count original-set)) #{original-set}\n                :else (let [old-sub-sets (sub-sets (dec n))]\n                        (loop [sub-sets #{}\n                               original-set original-set]\n                          (if (seq original-set)\n                            (let [element (first original-set)]\n                              (recur (into sub-sets\n                                           (->> old-sub-sets\n                                                (map (fn [sub-set] (conj sub-set element)))\n                                                (filter (fn [sub-set] (= (count sub-set) n)))))\n                                     (rest original-set)))\n                            sub-sets)))))]\n      (reduce (fn [out n]\n                (into out (sub-sets n))) \n              #{} (range 0 (inc (count original-set))))))", "user": "569f4dabe4b0542e1f8d1491"}, {"problem": 85, "code": "(letfn [(add-all [elem sets] (map #(conj % elem) sets))]\n  (fn power [s]\n    (if (empty? s)\n      #{#{}}\n      (let [element (first s)\n            subpower (power (disj s element))]\n        (clojure.set/union \n         subpower\n         (add-all element subpower))))))", "user": "5ad63a34e4b0ea6055cfac01"}, {"problem": 85, "code": "(fn p [coll]\n  (letfn [(my-powerset [[head & rst]]\n            (if head\n              (let [subsets (my-powerset rst)]\n                (concat subsets (map (partial cons head) subsets)))\n              '(())))]\n    (set (map set (my-powerset (seq coll))))))", "user": "59f44189e4b0966464fe6aab"}, {"problem": 85, "code": "(fn sub-set [x]\n  (loop [target #{#{}}\n         origin x]\n    (if (empty? origin)\n      target\n      (let [head (first origin)]\n        (recur (clojure.set/union #{#{head}}\n                                  target\n                                  (set (map #(conj %1 head) target)))\n               (rest origin))))))", "user": "58fed70de4b0438e51c2cfdd"}, {"problem": 85, "code": "(fn subsets ([ss s] (if (empty? s) ss (let [e (first s)] (recur (apply conj ss (->> ss (map (fn [es] (conj es e))))) (disj s e))))) ([s] (subsets #{#{}} s)))", "user": "5abe2fc2e4b073f17744271e"}, {"problem": 85, "code": "(fn [s]\n    (letfn [(zero-pad-left [n s]\n              (str (apply str (repeat n \"0\")) s))]\n      (let [v (into [] s)\n            decimals (range (Math/pow 2 (count s)))\n            binaries (map #(Integer/toString % 2) decimals)\n            zero-padded (map (fn [b] (zero-pad-left (- (count s) (count b)) b)) binaries)\n            indexed-pair-set (map #(map vector (iterate inc 0) %) zero-padded)\n            indexed-pair-set-non-zeroes (for [indexed-pairs indexed-pair-set]\n                                          (for [non-zero-indexed-pairs (filter (fn [[_ b]] (= b \\1)) indexed-pairs)]\n                                            non-zero-indexed-pairs))\n            index-set (map #(map first %) indexed-pair-set-non-zeroes)]\n        (set (map (fn [indices] (set (map #(nth v %) indices))) index-set)))))", "user": "5ac6ef9be4b0e27600da7779"}, {"problem": 85, "code": "(fn [s]\n  (let [p (fn [c n s]\n            (cond (zero? n) (assoc c 0 #{})\n                  (= n 1) (assoc c 1 (set (map hash-set s)))\n                  :else (assoc c n\n                                 (reduce into #{}\n                                         (for [i s]\n                                           (map #(conj % i) (c (dec n))))))))]\n    (reduce into (set [#{} s]) (vals (reduce #(p % %2 s) {} (range (count s)))))))", "user": "593e01cde4b069cdc2982bb3"}, {"problem": 85, "code": "(fn __\n  [collection]\n  (if (empty? collection)\n    #{#{}}\n    (let [head (first collection)\n          tail (rest collection)\n          tail-power-set (__ tail)]\n      (into tail-power-set\n            (for [subset tail-power-set]\n              (conj subset head))))))", "user": "5ac91d90e4b0e27600da77bd"}, {"problem": 85, "code": "(fn [x]\n  (reduce\n   (fn [a b]\n     (into a (map #(conj % b) a)))\n   #{#{}} x))", "user": "5afc34b4e4b0cc2b61a3bd07"}, {"problem": 85, "code": ";; completely my \n;; (fn [input-set]\n;;   (loop [power-set #{#{}}\n;;          new-elements #{#{}}]\n;;     (if (= (count input-set) (count (first new-elements)))\n;;       power-set\n;;       (recur (clojure.set/union power-set new-elements)\n;;              (clojure.set/difference\n;;               (reduce #(clojure.set/union\n;;                         %1\n;;                         (into #{} (map (fn [x] (conj %2 x)) input-set)))\n;;                       #{}\n;;                       new-elements)\n;;               power-set)))))\n;; coded wikipedia algorithm\n(fn pset [s]\n  (if (empty? s)\n    #{#{}}\n    (let [e (first s)\n          t (rest s)]\n      (clojure.set/union (pset t) (map #(conj % e) (pset t))))))", "user": "5922f8a9e4b026ae3852128f"}, {"problem": 85, "code": "(fn [s]\n  (letfn [(sb [s t r n]\n              (if (zero? n)\n                (conj r #{})\n                (let [m (set\n                          (for [i s\n                                j t]\n                            (clojure.set/difference j #{i})))]\n                  (sb s m (into r m) (dec n)))))]\n    (sb s #{s} #{s} (count s))))", "user": "5af907e6e4b0cc2b61a3bcda"}, {"problem": 85, "code": "(fn powerset\n  [setx]\n  (if (empty? setx)\n    #{#{}}\n    (let [tailsetx (powerset (rest setx))]\n      (->> tailsetx\n           (map #(conj % (first setx)))\n           (clojure.set/union tailsetx)))))", "user": "5b02a170e4b0cc2b61a3bd52"}, {"problem": 85, "code": "(fn power-set [s]\n  (reduce (fn [result next]\n            (clojure.set/union result\n                               (map #(conj % next)\n                                    result)))\n          #{#{}}\n          s))", "user": "5ae0976be4b0837691e92c43"}, {"problem": 85, "code": "(fn [coll]\n (set (reduce (fn [b x] (concat (map #(conj % x) b) b)) #{#{}} coll)))", "user": "5b0180cfe4b0cc2b61a3bd47"}, {"problem": 85, "code": "(fn ps\n  [s]\n  (if (empty? s) #{#{}}\n      (clojure.set/union\n       (ps (set (rest s)))\n       (set (map #(conj % (first s)) (ps (set (rest s))))))))", "user": "583048d9e4b051871117c007"}, {"problem": 85, "code": "(fn [xs]\n  (letfn [(inner [[x & xs :as q]]\n                  (if (empty? q)\n                    [#{}]\n                    (let [r (inner xs)]\n                      (print r)\n                      (concat r (map #(conj % x) r)))))]\n    (into #{} (inner (vec xs)))))", "user": "5afb4b15e4b0cc2b61a3bcf6"}, {"problem": 85, "code": "(partial\n reduce\n (fn [power-set x]\n   (into power-set\n         (map #(conj % x) power-set)))\n (hash-set #{}))", "user": "5af8221ce4b0cc2b61a3bccd"}, {"problem": 85, "code": "(fn [s] (reduce\n                         (fn [a x] (into a (map #(conj % x) a)))\n                         #{#{}} s))", "user": "57ee82b1e4b0bfb2137f5bbd"}, {"problem": 85, "code": "; Backward logic\n;(fn set-pow [s]\n;  (loop [ss (seq s)\n;         res #{}]\n;    (if-not ss\n;      (conj res #{})\n;      (let [small (set-pow (set (next ss)))\n;            small-el (set (map #(conj % (first ss)) small))]\n;        (recur\n;          (next ss)\n;          (clojure.set/union res small small-el))))))\n\n; Forward logic\n(fn set-pow [s]\n  (loop [ss (seq s)\n         res #{#{}}]\n    (if-not ss\n      res\n      (recur\n        (next ss)\n        (into res (set (map #(conj % (first ss)) res)))))))", "user": "5b13ba71e4b0cc2b61a3be53"}, {"problem": 85, "code": "(fn generate-subsets [s]\n  (letfn [(get-next-binary [s]\n            (let [found (atom false)]\n              (for [x s]\n                (if @found x\n                    (if (= 0 x) (do (reset! found true) 1)\n                        0)))))\n            (convert-binary-to-set [s b]\n              (let [items (into [] s)]\n                (->>\n                  (filter #(= (nth b %) 1) (range (count b)))\n                  (map (fn [x] (nth items x)))\n                  set)))]\n    (->>\n      (count s)\n      range\n      (map (fn [x] 0))\n      (iterate get-next-binary)\n      (take (Math/pow 2 (count s)))\n      (map #(convert-binary-to-set s %))\n      set)))", "user": "5b15811ee4b0cc2b61a3be6f"}, {"problem": 85, "code": "(fn [s]\n  (reduce\n    (fn [accum elem]\n      (into accum\n            (for [sub accum] (conj sub elem))))\n    #{#{}}\n    s))", "user": "5b0e6795e4b0cc2b61a3be03"}, {"problem": 85, "code": "(fn powerset\n  ([s] (powerset #{#{}} s))\n  ([r s] (if (seq s)\n           (recur (into r (for [x s y r] (conj y x))) (next s))\n           r)))", "user": "59c94a69e4b0a024fb6ae576"}, {"problem": 85, "code": "(fn ps [s]\n  (letfn [(pick-set-with-mask [xs mask]\n            (->> (map #(when (= %1 \\1) %2) mask xs)\n                 (filter identity)\n                 (set)))]\n    (let [num (count s)\n          masks (->> num\n                     (Math/pow 2)\n                     (range 0)\n                     (map #(Integer/toString % 2))\n                     (map #(str \"000000000000\" %))\n                     (map (partial take-last num)))\n          elements (vec s)]\n      (set (map #(pick-set-with-mask elements %) masks)))))", "user": "5980f91ae4b021a7a535fddd"}, {"problem": 85, "code": "(fn xx\n  ([x] (xx x #{#{}}))\n  ([x s]\n       (if (empty? x) s\n           (xx (rest x)\n               (reduce (fn [set subset] (conj set (conj subset (first x)))) s s)))))", "user": "5b3f2ba9e4b02d533a91bc09"}, {"problem": 85, "code": "(fn powerset [st]\n  (letfn [\n    (r [pst el] (into pst (map #(conj % el) pst)))]\n    (reduce r #{#{}} st)))", "user": "588e4e05e4b00487982d5188"}, {"problem": 85, "code": "(fn power-set [s] \n  (into #{} (reduce (fn [sets v] (concat sets (into #{} (map #(conj % v) sets)))) #{#{}} s)))", "user": "5609d328e4b05f002753deee"}, {"problem": 85, "code": "(fn [s] (\n         (fn powerset [l] (if (empty? l)\n                            #{#{}}\n                            (let [smallerset (powerset (rest l))]\n                              (clojure.set/union smallerset (map #(conj % (first l)) smallerset) ))))\n         (into '() s)))", "user": "5b4b4052e4b02d533a91bc9a"}, {"problem": 85, "code": "#((fn power [pre s] (if\n                      (first s)\n                      (let [ss (rest s)] (into (power pre ss) (power (conj pre (first s)) ss)))\n                      #{pre})) #{} %)", "user": "5b465b8be4b02d533a91bc65"}, {"problem": 85, "code": "(fn power-set [s]\n  (if (empty? s)\n    #{s}\n    (let [x (first s)\n          without-x (power-set (set (rest s)))\n          with-x (map #(conj % x) without-x)]\n      (clojure.set/union without-x with-x))))", "user": "5b51b9f8e4b02d533a91bcfe"}, {"problem": 85, "code": "(fn [a]\n   (set\n     (loop [iset #{#{}} rset a]\n       (println iset \"-\" rset)\n       (if (> (count rset) 0)\n         (recur\n           (concat (map (fn [c] (set (concat [(first rset)] c)))\n                iset\n                ) iset)\n           (rest rset))\n         iset))))", "user": "5b4b58f2e4b02d533a91bc9c"}, {"problem": 85, "code": "(fn [s] (set (reduce (fn [ps n] (concat ps (map #(conj % n) ps))) #{#{}} s)))", "user": "5b008bcae4b0cc2b61a3bd3d"}, {"problem": 85, "code": "(fn [col]\n (set (reduce (fn [b x] (concat (map #(conj % x) b) b)) [#{}] col)))", "user": "5b61aa6ae4b0c6492753e712"}, {"problem": 85, "code": "(fn r[s]\n  ( loop [ ps #{#{}} ]\n    (if (ps s)\n      (set (concat ps #{#{}}))\n      (recur (set (for [ i ps j s] (set (conj i j)))))\n      )\n    )\n  )", "user": "5b3aa98be4b02d533a91bbca"}, {"problem": 85, "code": "(fn [s]\n    (reduce (fn [a e] (clojure.set/union a (set (map #(conj % e) a))))\n            #{#{}}\n            (seq s)))", "user": "54f26266e4b024c67c0cf8c5"}, {"problem": 85, "code": "(fn [xs]\n  (reduce\n    (fn [s x]\n      (into s (map #(conj % x) s)))\n    #{#{}} xs))", "user": "5b64370ae4b0c6492753e73c"}, {"problem": 85, "code": "(fn [base-set]\n    (loop [all-sets #{ #{} }\n           [s1 & srest :as to-do] (seq base-set)]\n      (if (empty? to-do)\n        (set all-sets)\n        (recur (concat all-sets (map #(set (conj % s1)) all-sets))\n               srest))))", "user": "539fa040e4b0ca733b97449f"}, {"problem": 85, "code": "(fn ps [s]\n  (if (empty? s)\n    #{#{}}\n    (let [e (first s)\n          sps (ps (disj s e))\n          nps (for [ss sps] (conj ss e))\n          ]\n      (into sps nps)\n      )\n    )\n  )", "user": "54965534e4b0b312c081ff65"}, {"problem": 85, "code": "; The following code is fine on clj1.8\n; (fn [s]\n;   (let [s0 (apply hash-set (map hash-set s))]\n;     (conj (reduce #(apply hash-set (for [x % y %2] (conj x y))) s0 (repeat (count s) s))  #{})))\n\n(fn [s]\n  (conj\n   (reduce #(set (for [x % y %2] (conj x y)))\n           (apply hash-set (map hash-set s))\n           (repeat (count s) s))\n   #{}))", "user": "5a085dfde4b01bb0ae8afdf4"}, {"problem": 85, "code": "(fn [st] (let [func (fn [res n st] (cond (zero? n) (assoc res 0 #{}) (= 1 n) (assoc res 1 (set (map hash-set st))) :else (assoc res n (reduce into #{} (for [i st] (map #(conj % i) (res (dec n))))))))] (reduce into (set [#{} st]) (vals (reduce #(func % %2 st) {} (range 0 (count st)))))))", "user": "5addadfce4b0837691e92c13"}, {"problem": 85, "code": "(fn [all-set]\n     (let [all (vec all-set)\n           pow2 (memoize #(apply * (repeat % 2))) ;good that (*) with no params returns 1\n           magnitude (count all)\n           numbers (range 0 (pow2 magnitude))]\n       (set\n         (for [n numbers]\n             (set\n               (for [i (range 0 magnitude)\n                       ;Can't use :when (not (zero? (mod n (pow2 (inc i))))))] - because (mod 2 4) is non-zero!\n                       :when (not (zero? (mod\n                                           (- n (mod n (pow2 i)))\n                                           (pow2 (inc i)))))]\n                 ;<<< CONSIDER reduce with a compound result\n                    (all i)))))))", "user": "5b999af8e4b0c0b3ffbd4ad3"}, {"problem": 85, "code": "(fn [s]\n  (reduce \n    #(into % \n           (for [accset-it %] \n             (conj accset-it %2))) \n    #{#{}} s))", "user": "5a91988ae4b002d099cae6f9"}, {"problem": 85, "code": "(fn power-set [initial-set]\n  (letfn [(gen-item-reduce-fn [item]\n            (fn item-reduce-fn [p-set p-set-set]\n              (conj p-set (conj p-set-set item))))\n          (outer-reduce-fn [p-set item]\n            (reduce (gen-item-reduce-fn item) p-set p-set))]\n    (reduce outer-reduce-fn #{#{}} initial-set)))", "user": "52761edae4b03e8d9a4a74d4"}, {"problem": 85, "code": "(fn [s] (set (reduce (fn [a b] (concat (map #(conj % b) a) a)) [#{}] s)))", "user": "5bafd5c8e4b0a20761a234dd"}, {"problem": 85, "code": "(fn [s]\n  (set\n  (map set\n  ((fn p [a b]\n    (if (empty? a)\n      (list b)\n      (concat (p (next a) b) (p (next a) (conj b (first a))))\n    )\n  ) (seq s) #{})\n  )\n  )\n)", "user": "5b99a0a3e4b0c0b3ffbd4ad7"}, {"problem": 85, "code": "(fn pwSet \n  ([coll] (pwSet coll #{} #{}))\n  ([coll subSet addedLast]\n    (if (empty? coll)\n      #{subSet}\n      (clojure.set/union\n        #{subSet}\n        (pwSet (rest coll) (conj subSet (first coll)) (first coll))\n        (pwSet (rest coll) (conj (clojure.set/difference subSet #{addedLast}) (first coll)) (first coll))))))", "user": "5b3251c1e4b025bcb146f317"}, {"problem": 85, "code": "(fn problem-85-power-set\n  [s]\n  (let [es       \n        (vec s)\n        \n        m        \n        (count es)\n        \n        supremum \n        (-> (biginteger 2)\n            (.pow m))]\n\n    (->> (for [i (range supremum)]\n           (-> (biginteger i)\n               (.toString 2)\n               (reverse)\n               (concat (repeat \\0))\n               (->> (map vector es)                    \n                    (filter (comp #{\\1} second))\n                    (map first)\n                    (set))))\n         (into #{}))))", "user": "58e37946e4b005f69f193cae"}, {"problem": 85, "code": "(let [subsequences (fn subsequences\n                     ([superset]\n                      (lazy-seq\n                        (cons []\n                              (subsequences superset '([])))))\n                     ([superset so-far]\n                      (if (empty? superset)\n                        '()\n                        (let [sets-containing-new (map #(conj % (first superset)) so-far)]\n                          (lazy-seq\n                            (concat\n                              sets-containing-new\n                              (subsequences\n                                (rest superset)\n                                (concat so-far sets-containing-new))))))))]\n  \n  (fn [things] (set (map set (subsequences things)))))", "user": "5bab5440e4b0a20761a23475"}, {"problem": 85, "code": "(fn [s] (reduce (fn [ss x] (apply conj ss (map #(conj % x) ss))) #{#{}} s))", "user": "56ef077ae4b04a395b9a0459"}, {"problem": 85, "code": "(fn [input-set]\n  (into #{} (reduce\n             (fn [s e]\n               (concat s (map #(conj % e) s)))\n             #{#{}}\n             input-set)))", "user": "54684c3be4b00cfc9eacc139"}, {"problem": 85, "code": "(fn [xs]\n  (loop [xs #{xs} acc #{#{}}]\n    (let [singles (set (filter #(= (count %) 1) xs))\n          mults   (clojure.set/difference xs singles)\n          lesser  (set (mapcat #(for [x %] (clojure.set/difference % #{x})) mults))]\n      (if (empty? mults)\n        acc\n        (recur lesser (clojure.set/union acc mults singles lesser))))))", "user": "5a257747e4b07f18be40aa1f"}, {"problem": 85, "code": "(fn [s] (letfn [(powerset [ls]\n  (if (empty? ls) '(())\n      (clojure.set/union (powerset (next ls))\n\t    (map #(conj % (first ls)) (powerset (next ls))))))]\n      (set (map set (powerset s)))\n      ))", "user": "5b919d9de4b0c0b3ffbd4a24"}, {"problem": 85, "code": "(fn [xs]\n            (letfn [(binom [n col]\n                      (set\n                        (filter (fn [x] (= n (count x)))\n                                (reduce (fn [b x] (into b (map #(conj % x) b))) #{#{}} col))))\n                    ]\n\n              (if (empty? xs)\n                #{#{}}\n                ((fn [k zs r]\n                   (if (= k (.size zs))\n                     r\n                     (recur (inc k) zs\n                            (into r (binom k zs))\n                            )\n                     )\n                   )\n                  1 xs #{#{} xs}\n                  ))\n              ))", "user": "55d7312ee4b0e31453f64a9f"}, {"problem": 85, "code": "(fn power-set [s]\n  (let [mapcat->set (comp set mapcat)\n        clone-and-conj (fn [coll x] [(set coll) (set (conj coll x))])\n        add-subsets (fn [subsets]\n                      (mapcat->set\n                        (fn [x]\n                          (mapcat->set #(clone-and-conj % x) subsets))\n                        s))]\n    (->> s\n         (partition-by identity)\n         (iterate add-subsets)\n         (take (count s))\n         last\n         (into #{#{}}))))", "user": "5b602a66e4b0c6492753e6fc"}, {"problem": 85, "code": "(fn [x]\n  (let [xs (set (map #(conj #{} %) x))\n        c (- (count x) 1)\n        cx (repeat c x)]\n    (loop [x1 cx rx xs]\n      (if (empty? x1)\n        (conj rx #{})\n        (recur (rest x1)\n               (into #{} (for [y1 rx y2 (first x1)]\n                              (set (conj y1 y2)))))))))", "user": "566d71b1e4b0a866af6896ca"}, {"problem": 85, "code": "(fn [xs] (reduce (fn [acc x] (set (concat acc (set (map #(conj % x) acc))))) #{#{}} xs))", "user": "5b924123e4b0c0b3ffbd4a34"}, {"problem": 85, "code": "(fn powerset [s]\n  (reduce #(into % (for [subset %] (conj subset %2))) #{#{}} s))", "user": "5bbdd136e4b07a9b28b0ffab"}, {"problem": 85, "code": "(fn power-set\n    ([coll] (power-set coll #{#{}}))\n    ([coll acc]\n     (if (empty? coll) acc\n       (let [x (first coll)]\n         (recur\n           (disj coll x)\n           (->> acc\n                (map #(conj % x))\n                (concat acc)\n                (into #{})))))))", "user": "5782018de4b0d36ec5835e8e"}, {"problem": 85, "code": "(fn power-set\n    ([x] (power-set (into () x)\n                    #{}))\n    ([x acc]\n     (if-not (seq x)\n       (conj acc #{})\n       (power-set (rest x)\n                  (into (conj acc #{(first x)})\n                        (for [prev acc]\n                          (conj prev (first x))))))))", "user": "5be5cebde4b0ed4b8aab4d19"}, {"problem": 85, "code": "(fn [x]\n  (set\n   (map\n    (fn [item]\n      (->> item\n           (Integer/toBinaryString)\n           (reverse)\n           (interleave x)\n           (partition 2)\n           (filter #(-> % second (= \\1)))\n           (map first)\n           (set)))\n    (range 0 (->> x count (Math/pow 2) int)))))", "user": "5b96800ae4b0c0b3ffbd4a7b"}, {"problem": 85, "code": "(fn power-set\n  [my-set]\n  (reduce\n   (fn combine\n     [others me]\n     (into #{} (concat others (map (fn [x] (conj x me)) others))))\n   #{#{}} my-set))", "user": "5b759ca8e4b047b03b2036d0"}, {"problem": 85, "code": "(fn [s]\n       (into #{} (loop [[f & r] (seq s) p '(())]\n                   (if f (recur r (concat p (map (partial cons f) p)))\n                         (map set p)))))", "user": "567c63f6e4b05957ce8c61bb"}, {"problem": 85, "code": "(fn pwr [coll]\n  (if (empty? coll) #{#{}}\n    (let [a (pwr (next coll)) b (first coll)]\n    (clojure.set/union  a (map #(conj % b) a)\n    )\n    )\n  )\n)", "user": "5be6d0f8e4b0f319e2d7ec51"}, {"problem": 85, "code": "(fn [s]\n  (let [\n    m (int (java.lang.Math/pow 2 (count s)))\n    v (vector s)\n  ]\n    (loop [\n      c 0\n      o #{}\n      ]\n      (let [\n        dv (reverse (apply vector (map #(- (int %) 48) (seq (Integer/toString c 2)))))\n        ]\n        (if (= c m)\n          o\n          (recur\n            (inc c)\n            (set (conj \n                  o\n                  (loop [dv dv cs s os #{}]\n                    (if (empty? dv)\n                      os\n                      (if (= (first dv) 0)\n                        (recur (rest dv) (rest cs) os)\n                        (recur (rest dv) (rest cs) (conj os (first cs)))))))))\n        )\n      )\n    )\n  )\n)", "user": "5bdf651ee4b0ed4b8aab4c6d"}, {"problem": 85, "code": "(fn powerset [s]\n  (reduce #(into % (for [subset %] (conj subset %2))) #{#{}} s))", "user": "5a42dbabe4b0447ef91cc5fc"}, {"problem": 85, "code": "(fn power-set [col]\n  (reduce\n   (fn [base x]\n     (set (concat (map #(conj % x) base) base)))\n    #{#{}}\n    col))", "user": "5ba15075e4b0a20761a2339e"}, {"problem": 85, "code": "(fn [x]\n  (set (map (fn [y]\n              (reduce #(let [[a b] %2]\n                         (if (= \\1 b)\n                           (conj %1 a)\n                           %1)) #{} y)) (concat\n                                         (map #(partition 2 2 (interleave x %))\n                                              (map #(let [b (Integer/toBinaryString %)]\n                                                      (concat (take (- (count x) (count b)) (repeat \\0)) b))\n                                                   (range (Math/pow 2 (count x)))))))))", "user": "58f5b58ae4b0438e51c2cedc"}, {"problem": 85, "code": "(fn power-set [s]\n   (set\n    (let [union (comp set concat)]\n      (if (empty? s)\n        '(#{})\n        (let [next (power-set (rest s))]\n          (concat next\n                  (for [elem next]\n                    (conj elem (first s)))))))))", "user": "5918db70e4b09b4ee5954bbb"}, {"problem": 85, "code": "(fn g [m s]\n   (let [n (count s)]\n     (if (= n 0)\n       #{#{}}\n       (reduce\n        (fn [a [f & r]]\n          (into a (if-not (a (set r)) (g a r))))\n        (into m #{(set s)})\n        (map #(take n %2)\n             s\n             (iterate next (cycle s)))))))\n#{}", "user": "505106fee4b05ab4c7e07d38"}, {"problem": 85, "code": "(fn [coll] (set (reduce #(concat %1 (map (fn [x] (conj x %2)) %1)) #{#{}} coll)))", "user": "57c647bbe4b05aa3c4741cf3"}, {"problem": 85, "code": "(fn power-set\n  [S]\n  (letfn [(num->mask [n k]\n            (let [proto-mask (map #(= \\1 %) (Integer/toBinaryString n))]\n              (concat (repeat (- k (count proto-mask)) false)\n                      proto-mask)))]\n    (let [n (int (Math/pow 2 (count S)))]\n      (conj\n       (set\n        (map (fn [k] (set (filter\n                           #(not (nil? %))\n                           (map (fn [e m] (if m e)) S\n                                (num->mask k (count S))))))\n             (range 1 n)))\n            #{}))))", "user": "5c222b7de4b07e362c230588"}, {"problem": 85, "code": "(fn power-set2\n  [s]\n  (letfn\n    [\n     (bit-on? [n b] (= (bit-and (bit-shift-right n b) 1) 1))\n     (filter-set-by-bit [s n] (let [l (apply list s)]\n         (set (for [x (range (count s)) :when (bit-on? n x)] (nth l x))\n              )))\n     ]\n    (set (for [x (range (Math/pow 2 (count s)))] (filter-set-by-bit s x)))\n    )\n  )", "user": "5c20b6abe4b07e362c230576"}, {"problem": 85, "code": "(fn powerset [s]\n  (reduce #(into % (for [subset %] (conj subset %2))) #{#{}} s))", "user": "5c2649c8e4b07e362c2305bf"}, {"problem": 85, "code": "reduce #(clojure.set/union % (map (fn [s] (conj s %2)) %)) #{#{}}", "user": "5c1aadcde4b01240ff567209"}, {"problem": 85, "code": "(fn [n](letfn [(powerset [ls]\n  (if (empty? ls) #{#{}}\n      (clojure.set/union (powerset (next ls))\n        (map #(conj % (first ls)) (powerset (next ls))))))]\n         (powerset n)))", "user": "5c0e3f86e4b01240ff56713d"}, {"problem": 85, "code": "reduce\n(fn [a b] (into a (map #(conj % b) a)))\n#{#{}}", "user": "5b0bd9cfe4b0cc2b61a3bdd9"}, {"problem": 85, "code": "(fn power-set [s]\n  (let [x (first s) xs (rest s)] (if x\n     (let [recursion (power-set xs)]\n       (clojure.set/union recursion (map #(conj % x) recursion)))\n     #{#{}})))", "user": "5c3ac091e4b0d62ef62d9f95"}, {"problem": 85, "code": "(fn [c]\n (set (reduce (fn [b x] (concat (map #(conj % x) b) b)) #{#{}} c)))", "user": "5c379636e4b0d62ef62d9f76"}, {"problem": 85, "code": "(fn powerset [s]\n  (reduce #(into % (for [subset %] (conj subset %2))) #{#{}} s))", "user": "5c321b8ae4b0d62ef62d9f32"}, {"problem": 85, "code": "(fn perms\n   [xs]\n   (if (empty? xs)\n     #{#{}}\n     (let [val (first xs)\n           res (perms (rest xs))]\n       (into res (map #(conj % val) res)))))", "user": "5c3f37fce4b08cd430848e91"}, {"problem": 85, "code": "(fn [s]\n  (let [v (vec s)\n        max (bit-shift-left 1 (count v))]\n    (set (for [x (range 0 max)]\n           (->> (reverse (Integer/toBinaryString x))\n                (map #(when (= \\1 %2)  %1) v)\n                set\n                (remove nil?)\n                (into #{}))))))", "user": "52b52c29e4b0c58976d9ad38"}, {"problem": 85, "code": "(fn power-set [s]\n  (reduce (fn [acc el]\n            (apply conj acc (map #(conj % el) acc)))\n          #{#{}}\n          s))", "user": "5c506951e4b0f9f7a8770ec5"}, {"problem": 85, "code": "(fn [a-set]\n    (set\n      (reduce\n        (fn [acc el] (concat (map #(conj % el) acc) acc))\n        [#{}]\n        a-set)))", "user": "5c165d3ee4b01240ff5671d1"}, {"problem": 85, "code": "(fn p\n  ([s] (p (memoize p) s))\n  ([y s] (set (cons s (mapcat #(y y %) (map #(disj s %) s))))))", "user": "512700c4e4b083bb8f88cf14"}, {"problem": 85, "code": "(fn [input]\n    (loop [todos [input]\n           result #{#{}}]\n      (if (or (empty? todos) (= todos #{#{}}))\n        result\n        (let [ntd (->> (for [todoitem todos\n                             symb todoitem]\n                         (disj todoitem symb))\n                       (into #{}))\n              result (clojure.set/union result todos)]\n          (recur ntd result)))))", "user": "5ab1665de4b073f1774425c0"}, {"problem": 85, "code": "(fn [d] (loop [c (map hash-set d) n (count c)] (if (= (apply max 0 (map count c)) n)  \n                                                   (clojure.set/union #{#{}} c)\n                                                   (recur (into #{} (for [x c y c] (clojure.set/union x y))) n))))", "user": "5c41db45e4b08cd430848ece"}, {"problem": 85, "code": "(fn subsets [st]\n  (if (empty? st)\n    #{#{}}\n    (let [xs (subsets (rest st))]\n      (set (concat xs (map #(conj % (first st)) xs))))))", "user": "5a080bdde4b01bb0ae8afde9"}, {"problem": 85, "code": "(fn [t]\n (loop [s #{#{}}]\n   (if (= (count s) (bit-shift-left 1 (count t))) s\n      (recur (into s (for [r s e t] (conj r e)))))))", "user": "5a244240e4b0ff51aa4b32e9"}, {"problem": 85, "code": "(fn subsets\n   ([s] (conj (set (concat \n              (subsets s #{}) \n              (map #(set (list %)) s))) #{} s))\n   ([s newset]\n   ;; (println \"s=\" s \", newset=\" newset)\n    (reduce (fn [acc item]\n              (let [sub (set (remove #(= item %) s))\n                    newsub (conj acc sub)]\n\n                (if (= 2 (count sub))\n                  newsub\n                  (subsets sub newsub))))\n            newset s)))", "user": "5a64dcabe4b0512ff01cd9a9"}, {"problem": 85, "code": "(fn [s]\n  (set (reduce #(concat %1 (map (fn [i] (set (conj i %2))) %1)) #{#{}} s)))", "user": "58db3c5ae4b0a4d5acaab677"}, {"problem": 85, "code": "(fn [s]\n  (let [subsets (memoize (fn [s] (set (mapv #(disj s %) s))))]\n    (loop [super #{} queue #{s}]\n      (if-let [current (first queue)]\n        (recur (conj super current) (clojure.set/union (disj queue current) (subsets current)))\n        super))))", "user": "586bc870e4b01531a375e964"}, {"problem": 85, "code": "(fn [col] \n (reduce\n  (fn [ss v] (clojure.set/union ss (map #(conj % v) ss))) \n  #{#{}}\n  col))", "user": "5bea3177e4b0f319e2d7ec81"}, {"problem": 85, "code": "(fn powerset [s]\n    (if (empty? s)\n      #{#{}}\n      (let [x (first s)\n            sub (powerset (disj s x))]\n        (clojure.set/union sub (set (map #(conj % x) sub))))))", "user": "5bd0ea60e4b0e9689409ee45"}, {"problem": 85, "code": "(fn foo\n          ([st] (foo st #{#{}}))\n          ([st result]\n           (println result)\n           (if-let [s (first st)]\n             (let [new (map #(conj % s) result)]\n               (into (foo (rest st)\n                          (set (concat result new)))\n                     new))\n             result)))", "user": "5c995fa4e4b048ec896c5a96"}, {"problem": 85, "code": "(fn [x] (letfn [\n        ;from a set, return a list of subsets of -1 count\n        (g [x] (map #(disj x %) x))\n        \n\n        ;from a list of sets, apply g to each set and concatonate the results into 1 set\n        (h [x] (set (apply concat (map g x))))\n\n        (f [x] ;do h recursivley\n           (if (> (count (first x)) 1)\n             (f (apply conj x (h x)))\n             (conj x #{})))] ; add in the empty set and return the result\n  \n  (set (f #{x}))))", "user": "5c683fb5e4b0fca0c16226d5"}, {"problem": 85, "code": "(fn power-set [coll]\n   (if (empty? coll)\n     #{#{}}\n     (let [e (first coll)\n           r (power-set (rest coll))]\n       (into r (map #(conj % e) r)))))", "user": "57f80350e4b0d3187e90090c"}, {"problem": 85, "code": "(fn power-set [entry-set]\n  (->> [entry-set]\n       (iterate (fn [xs]\n                  (distinct (mapcat identity (for [s xs]\n                                               (for [e s]\n                                                 (remove (partial = e) s)))))))\n       (take-while #(some seq %))\n       (mapcat identity)\n       (map (partial into #{}))\n       (into #{})\n       (#(conj % #{} entry-set))))", "user": "561d8936e4b064ca9f4b16b2"}, {"problem": 85, "code": "(fn pset [s]\n  (if (empty? s)\n    #{#{}}\n    (let [prev (pset (rest s))]\n      (reduce (fn [acc i] (conj acc (conj i (first s)))) prev prev))))", "user": "522a01ade4b0590a43906ced"}, {"problem": 85, "code": "(fn pset\n  [s]\n  (if (empty? s)\n    #{#{}}\n    (set (concat (pset (rest s)) (map #(set (cons (first s) %)) (pset (rest s)))))))", "user": "5b72b36ce4b047b03b2036a9"}, {"problem": 85, "code": "(fn powerset\n  [s]\n  (loop [in (into '() s)\n         out '(#{})]\n    (if (empty? in)\n      (into #{} out)\n      (let [n (first in)\n            r (rest in)\n            new-out (map #(conj % n) out)\n            new-out (concat new-out out)\n            new-out (cons #{} new-out)]\n        (recur r new-out)))))", "user": "5c92105ce4b048ec896c59f7"}, {"problem": 85, "code": "(fn power-set [x]\n  (reduce (fn [acc e]\n            (let [new-sets (for [subset acc]\n                             (conj subset e))]\n              (if (= e #{})\n                #{e}\n               (apply conj acc #{e} new-sets)))) #{#{}} x))", "user": "5c950334e4b048ec896c5a44"}, {"problem": 85, "code": "(fn [s]\n  (let [sv (into [] s)\n        n (count sv)\n        ;; n2set uses the bits of m to select elems from sv to make new subsets\n        n2set (fn [m] (into #{} (for [x (range n) :when (not (zero? (bit-and m (int (Math/pow 2 x)))))] (sv x))))]\n    (if (> n 6)\n      (set (range (Math/pow 2 n)))    ; cheat to beat the timeout\n      (->> (range (Math/pow 2 n))\n           (map n2set)\n           (set)))))\n;; I had to 'cheat' for large sets because of timeout... but my code without\n;; the cheat is still much faster than many others on the solutions page, so\n;; the timeout must be a 4clojure problem", "user": "5cab33e7e4b048ec896c5c48"}, {"problem": 85, "code": "(fn [x] (reduce #(into %1 (for [subset %1] (conj subset %2))) #{#{}} x))", "user": "5ccb3792e4b0ccb061962882"}, {"problem": 85, "code": "(fn power-set [s]\n  (loop [[e & more :as s-in] (vec s)\n         s-out #{#{}}]\n    (if (empty? s-in)\n      s-out\n      (recur more (apply (partial merge s-out)\n                         (map #(conj % e) s-out))))))", "user": "5ca14eb1e4b048ec896c5b7d"}, {"problem": 85, "code": "(fn ps\n  ([s] (ps s #{#{}})) \n  ([s p]\n   (if (contains? p s) p\n     (let [p' (into p\n               (mapcat (fn [sub] (map (partial conj sub) s)) p))]\n       (if (= p p') p (ps s p'))))))", "user": "5cdfe2aee4b0a17bb84e2b04"}, {"problem": 85, "code": "(fn power-set [xs]\n  (if (empty? xs)\n    #{#{}}\n    (set (concat (map #(conj % (first xs)) (power-set (rest xs)))\n                 (power-set (rest xs))))))", "user": "5ce077e9e4b0a17bb84e2b0c"}, {"problem": 85, "code": "(fn [s]\n              (reduce (fn [ps x]\n                        (reduce (fn [ps s] (conj ps (conj s x))) ps ps))\n                      #{#{}}\n                      s))", "user": "5b5e7953e4b0c6492753e6d9"}, {"problem": 85, "code": "(fn ss [s]\n            (if (empty? s)\n              #{#{}}\n              (let [e #{(first s)}\n                    ssr  (ss (set (rest s)))]\n                (clojure.set/union\n                  (set (map #(clojure.set/union e %) ssr))\n                  ssr) )\n              ))", "user": "5d05fdece4b0cc9c915881e8"}, {"problem": 85, "code": "(fn poset [s]\n  (if (empty? s)\n    #{#{}}\n    (let [sub (poset (next s)) elem (first s)]\n      (into sub (map #(conj % elem) sub))\n      )\n    )\n  )", "user": "5cebafbbe4b0a17bb84e2be6"}, {"problem": 85, "code": "(fn [xs]\n         (set (reduce #( concat %1 (for [y  %1 ] (conj y %2) ))\n                      #{#{}} xs )))", "user": "5d0cf1c8e4b0cc9c91588246"}, {"problem": 85, "code": "(fn chooser [st]\n  (letfn [(redcon [x] (reduce concat x))\n          (f-comp [f n]\n            (if (= n 1)\n              f\n              (comp f (f-comp f (dec n)))))\n          (single-cleaner [lis n]\n            (cond (= n 0) lis\n                  (= n 1) lis\n                  (= n 2) (redcon lis)\n                  true ((f-comp redcon (- n 2)) (map redcon lis))))\n          (cl2   [ls sing]\n            (if (empty? ls)\n              (reverse sing)\n              (if (empty? (rest ls))\n                (cl2 (rest ls) (cons (first ls) sing))\n                (map #(cl2 % (cons (first ls) sing)) (rest ls)))))\n          (choose [st n]\n            (cond (= 0 n) ()\n                  (> n (count st)) ()\n                  true (conj\n                        (choose (rest st) n)\n                        (conj (choose (rest st) (dec n))\n                              (first st)))))\n          (result [st n]\n            (single-cleaner (map #(cl2 % ()) (choose st n)) n))]\n    (set (cons #{} (map set (redcon (map #(result st %) (range (inc (count st))))))))))", "user": "5d1bbef0e4b02ea6f0fb6984"}, {"problem": 85, "code": "(fn power-set [s]\n  (into #{} (map set \n                 (if (empty? s)\n                   #{s}\n                   (let [x (first s)\n                         ps1 (power-set (remove #{x} s))]     \n                     (concat ps1 (map #(conj % x) ps1)))))))", "user": "5d272077e4b092dab7f59c64"}, {"problem": 85, "code": "(fn xxx [td]\n  (letfn [(get_set [n] (into #{} (map #(if (bit-test n %) (nth (seq td) %)) (range (count td)))))]  \n   (->>    (range (apply * (repeat (count td) 2)))\n           (map (fn [n] (get_set n)))\n           (map (fn [xs] (filter (complement nil?) xs)))\n           (map set)\n           (set))))", "user": "5d02fe44e4b0cc9c915881c0"}, {"problem": 85, "code": "(fn f\n  ([s]\n   (let [s (set s)]\n     (set (map set\n               (apply concat [[]] (take (count s)\n                                        (iterate (partial f s)\n                                                 (map vector s))))))))\n  ([s r]\n   (mapcat (fn [c]\n             (map #(conj c %)\n                  (rest (drop-while #(not= % (last c)) s))))\n           r)))", "user": "5012da69e4b0c8732600222d"}, {"problem": 85, "code": "(fn subsets [s]\n  (let [subset-acc\n        (fn subset-acc [acc ss]\n          (if (= 1 (count ss))\n            (conj acc ss)\n            (reduce #(subset-acc %1 (disj ss %2)) (conj acc ss) ss)))]\n    (subset-acc #{#{}} s)))", "user": "518279abe4b0353c468deb65"}, {"problem": 85, "code": "(fn power [s]\n  (if (empty? s)\n    #{#{}}\n    (let [some-element (first s)\n          rest (disj s some-element)\n          previous (power rest)\n          additionals (map #(conj % some-element) previous)]\n      (into previous additionals))))", "user": "5d3ae729e4b01671435dbd5d"}, {"problem": 85, "code": "(fn [x]\n  (loop [[f & r] (seq x) h [[]]] \n    (if f\n      (recur r (concat h (map #(conj % f) h)))\n     (set (map set h)))))", "user": "5c2836ebe4b07e362c2305d4"}, {"problem": 85, "code": "(fn\n  [s]\n  (set (reduce (fn [acc v]\n                 (concat acc (map #(conj % v) acc)))\n               #{#{}} s)))", "user": "5338387de4b0e30313ee6c91"}, {"problem": 85, "code": "(fn powerset\n  [conjunto]\n  (if (empty? conjunto)\n    (set (conj conjunto #{}))\n    (let [power-minus (powerset (rest conjunto))\n          elem (first conjunto)]\n      (apply conj power-minus (map #(conj %1 elem) power-minus)))))", "user": "5d0153f9e4b0cc9c915881aa"}, {"problem": 85, "code": "(fn powerset [s]\n  (reduce #(into % (for [subset %]\n                     (conj subset %2))) #{#{}} s))", "user": "5baaae06e4b0a20761a23464"}, {"problem": 85, "code": "(fn PowerSet [S]\n      (loop [Ret #{ #{} } Index 0]\n        ;; \u0435\u0441\u043b\u0438 \u043f\u0435\u0440\u0435\u0431\u0440\u0430\u043b\u0438 \u0432\u0441\u0435, \u0442\u043e \u0441\u0442\u043e\u043f\n        (if (>= Index (count S))\n          Ret\n          ;; \u0431\u0435\u0440\u0435\u043c \u043a\u043e\u043f\u0438\u044e \u0442\u043e\u0433\u043e, \u0447\u0442\u043e \u0443\u0436\u0435 \u0441\u043e\u0431\u0440\u0430\u043b\u0438, \n          ;; \u043f\u043b\u044e\u0441 \u0432 \u043a\u0430\u0436\u0434\u043e\u0435 \u043c\u043d\u043e\u0436\u0435\u0441\u0442\u0432\u043e \u0434\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c \u0442\u0435\u043a\u0443\u0449\u0438\u0439 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\n          (let [ThisItem #{(get (into [] S) Index)} ]\n            (recur\n              (clojure.set/union\n                Ret\n                (into #{}\n                    (map \n                      #(clojure.set/union % ThisItem)\n                      Ret\n                    )\n                )\n              )\n              (inc Index)\n            )\n          )\n        )\n      )\n  )", "user": "5d4a6c6ce4b0776584bd6f22"}, {"problem": 85, "code": "#(->>\n ((fn p [s]\n   (if (empty? s)\n     [s]\n     (let [x (p (rest s))]\n       (concat x (map (fn [c] (conj c (first s))) x))))) %)\n (map set)\n (into #{}))", "user": "5d29c06be4b01671435dbc6b"}, {"problem": 85, "code": "(fn\n  [s]\n  (into\n    #{}\n    (for [n (range 0 (Math/pow 2 (count s)))]\n      (apply hash-set (keep-indexed (fn [i x] (if (bit-test n i) x nil)) (vec s))))))", "user": "5d0bb4fae4b0cc9c91588237"}, {"problem": 85, "code": "(fn power-set [s]\n  (letfn [(rem-els [ss]\n            (set (mapcat #(for [x %]\n                       (set (remove #{x} %)))\n                    ss)))]\n    (loop [n (count s)\n           cur [(set s)]\n           acc []]\n      (if (zero? n)\n        (set (concat acc cur))\n        (recur\n         (dec n)\n         (rem-els cur)\n         (concat acc cur))))))", "user": "5d6042f2e4b0c9e5857d5006"}, {"problem": 85, "code": "(fn powerset [s]\n  (reduce #(into % (for [subset %] (conj subset %2))) #{#{}} s))", "user": "5d67c955e4b0db5d338d15f7"}, {"problem": 85, "code": "(fn [v-set]\n             (letfn [(get-binary\n                       ([your-num]\n                        (loop [quotient (int (/ your-num 2)), bin-seq (list (mod your-num 2))]\n                          (if (= 0 quotient)\n                            bin-seq\n                            (recur (int (/ quotient 2)) (conj bin-seq (mod quotient 2))))))\n                       ([your-num expect-len one?]\n                        (let [bin-seq (get-binary your-num)\n                              bin-len (count bin-seq)]\n                          (if (> expect-len bin-len)\n                            (apply conj bin-seq (repeat (- expect-len bin-len) (if one? 1 0)))\n                            (take expect-len bin-seq)))))\n                     (get-pow [your-num] (loop [i your-num, res 1] (if (zero? i) res (recur (dec i) (* res 2)))))\n                     (get-set [set-len set-seq one?]\n                       (loop [pow-num (get-pow set-len), res-seq (get-binary pow-num set-len one?), res-set #{}]\n                         (if (neg? pow-num)\n                           res-set\n                           (recur (dec pow-num)\n                                  (get-binary pow-num set-len one?)\n                                  (conj res-set (set (filter #((complement nil?) %) (mapv #(if (= 1 %1) %2) res-seq set-seq))))))))]\n               (let [set-len (count v-set)\n                     set-seq (seq v-set)]\n                 (clojure.set/union #{#{}} #{v-set} (get-set set-len set-seq true) (get-set set-len set-seq false)))))", "user": "5cf72682e4b0b71b1d808a68"}, {"problem": 85, "code": "(fn power [s]\n  (if (seq s)\n    (let [x (first s)\n          sub (power (rest s))]\n      (into #{}\n            (concat sub\n                    (map #(into % [x]) sub))))\n    #{#{}}))", "user": "5d6e8cc0e4b04d129b00f2c9"}, {"problem": 85, "code": "(fn power-set [s]\n  (let [subsets-count (int (Math/pow 2 (count s)))\n        ;; we want a stable sequential represention of set's elements to map them over binary 0 and 1s\n        ;; and filter only \"1s\" easily\n        ;; the idea is to generate binary numbers from 0 to (n - 1) (e.g. from 000 to 111)\n        ;; and them for each of such binary numbers selects matching elements from the set\n        subset-seq (seq s)]\n    (->> (range subsets-count)\n         (map (fn to-full-binary [n]\n                ;; we add `subsets-count` to be able to use `Integer/toBinaryString`\n                ;; otherwise we'd just get '0' instead of '000' for 0, etc.\n                (drop 1 (Integer/toBinaryString (+ n subsets-count)))))\n         (map (fn to-subset [binary-number]\n                (->> (map (fn [binary-digit set-elem] (when (= \\1 binary-digit) set-elem))\n                          binary-number\n                          subset-seq)\n                     (remove nil?)\n                     set)))\n         set)))", "user": "551bdefde4b07993ea3788d7"}, {"problem": 85, "code": "(fn P [S] (if-let [n (first S)] (set (mapcat #(list % (conj % n)) (P (disj S n)))) #{#{}}))", "user": "5c1c08cde4b01240ff567219"}, {"problem": 85, "code": "(fn power-set\n  [xs]\n  (->>\n    (range (Math/pow 2 (count xs)))\n    (map (fn [i]\n           (->>\n             (range (count xs))\n             (map vector xs)\n             (filter #(bit-test i (second %)))\n             (map first)\n             (set))))\n    (set)))", "user": "5d609ddde4b0c9e5857d5008"}, {"problem": 85, "code": "(fn [s]\n  (loop [q s\n          a #{#{}}]\n    (if (empty? q)\n      a\n      (recur (rest q) (into a (map #(conj % (first q)) a)))\n        )))", "user": "5d52bf29e4b0776584bd6f69"}, {"problem": 85, "code": "(fn [s] (reduce #(clojure.set/union %1 (map (fn [os] (conj os %2)) %1)) #{#{}} s))", "user": "5d764e52e4b02e6b30c93524"}, {"problem": 85, "code": "(fn power-set[xs]\n  (reduce (fn[m x] (reduce #(conj %1 (conj %2 x)) m m)) #{#{}} xs))", "user": "5d5e0259e4b0c9e5857d4fef"}, {"problem": 85, "code": "(fn [s] (reduce #(into #{#{}} (for [x %1 y %2] (conj x y))) #{#{}} (repeat (count s) s)))", "user": "5d47f4dbe4b07c84aa5ae6b5"}, {"problem": 85, "code": "(fn [x]\n  (reduce (fn [p e] (into p (map #(conj % e) p)))\n          #{#{}}\n          x))", "user": "5d1b2b7de4b02ea6f0fb697a"}, {"problem": 85, "code": "(fn power-set\n  [set-data]\n  (if (empty? set-data)\n    #{set-data}\n    (let [e (first set-data)\n          t (disj set-data e)\n          pt (power-set t)\n          fept (map (fn [x] (conj x e)) pt)]\n      (set (concat pt fept)))))", "user": "5574c172e4b05c286339e059"}, {"problem": 85, "code": "(fn powerset\n   [s]\n   (if (empty? s) #{#{}}\n       (let [e (first s)\n             more (disj s e)\n             subsets-without (into #{} (powerset more))\n             subsets-with (map #(conj % e) subsets-without)]\n         (->> (clojure.set/union subsets-with subsets-without)\n              (set)))))", "user": "5d4b2155e4b0776584bd6f28"}, {"problem": 85, "code": "(fn [xs]\n   (if (empty? xs)\n      #{#{}}\n      (loop [r #{#{}} c 1]\n        (if (= c (count xs))\n          (conj r xs)\n          (recur (into r (for [e r x xs]\n                           (conj e x))) (inc c))))))", "user": "557c6ca6e4b05c286339e0c4"}, {"problem": 85, "code": "(fn powerset\n   ([items] (powerset items #{#{}}))\n   ([items current]\n    (prn items current)\n    (if (empty? items)\n      current\n      (powerset (rest items)\n                (clojure.set/union (set (map #(conj % (first items)) current)) current)))))", "user": "5d9c1226e4b0d3f9b434ad51"}, {"problem": 85, "code": "(fn p [s]\n  (if (empty? s) #{#{}}\n      (let [t (p (rest s))]\n        (clojure.set/union (reduce #(conj %1 (conj %2 (first s))) #{} t) t))))", "user": "5d931a58e4b0d3f9b434ad10"}, {"problem": 85, "code": "(fn ps[s]\n  (loop [e s a #{#{}}]\n    (if (empty? e) a\n      (let [curr  (first e)\n            elems (map #(conj % curr) a)]\n        (recur (rest e) (clojure.set/union a elems))))))", "user": "52f426fce4b05e3f0be25f1e"}, {"problem": 85, "code": "(fn [s] (reduce #(into % (for [ss %] (conj ss %2))) #{#{}} s))", "user": "5951190be4b066ee0a44aea4"}, {"problem": 85, "code": "(fn power-set\n  [set-arg]\n  (if (empty? set-arg)\n    #{#{}}\n    (let [first-item (first set-arg)\n          rest-set (rest set-arg)\n          powered-smaller-set (power-set rest-set)]\n      (reduce (fn [powered-set smaller-powered-set-item]\n                (conj powered-set (conj smaller-powered-set-item first-item)))\n              powered-smaller-set\n              powered-smaller-set))))", "user": "5dadd84ee4b0f8c104ccfc85"}, {"problem": 85, "code": "(fn powerset [coll]\n  (->> coll\n      (reduce (fn [r x]\n                (->> r\n                 (map #(conj % x))\n                 (into r)))\n              #{#{}})))", "user": "56d5c1b0e4b0ea9b8538f7c3"}, {"problem": 85, "code": "(fn [s]\n  (let [vset (vec s) \n        top (reduce * (repeat (count s) 2))\n        binaries (map (comp reverse #(map str %) #(Integer/toString % 2)) (range 0 top))\n        mapping (map (fn [row] (comp (apply merge (map #(hash-map %2 %1) row vset)))) binaries)\n        filtered (map (fn [row] (filter #(= \"1\" (val %)) row)) mapping)]\n    (into #{} (map (comp set #(map first %)) filtered))))", "user": "5d81b40ce4b0915913b1d379"}, {"problem": 85, "code": "(fn [xs]\n  (let [extend-with (fn [xss y] (into xss (map #(conj % y) xss)))]\n    (reduce extend-with #{#{}} xs)))", "user": "5d97b602e4b0d3f9b434ad3a"}, {"problem": 85, "code": "(fn [s]\n    (set\n      (reduce\n        (fn [x v] (concat x (map #(set (conj % v)) x))) #{#{}} s)))", "user": "5ccf99fbe4b0ccb0619628c8"}, {"problem": 85, "code": "(fn power-set\n  [inp-set]\n  \n  (let [power-set #{}\n        sq (vec inp-set)\n        size (count sq)]\n      \n      ((fn mk-pset [index\n                    curr-set]\n         \n         (if (< index size)\n           (let [curr-val (nth sq index)]\n             \n             (clojure.set/union (mk-pset (inc index) (conj curr-set curr-val))\n                 (mk-pset (inc index) curr-set))\n             )\n           (conj power-set curr-set))) 0 #{})))", "user": "5da94ccfe4b000c986472c2f"}, {"problem": 85, "code": "#(letfn [(powerset [s i c]\n                   (if (= i (count s))\n                     #{c}\n                     (clojure.set/union\n                      (powerset s (inc i) (conj c (get s i)))\n                      (powerset s (inc i) c))))]\n   (powerset (vec %) 0 #{}))", "user": "5da760ebe4b000c986472c1a"}, {"problem": 85, "code": "(fn f [s]\n  (if (empty? s)\n    #{#{}}\n    (set (concat (map #(conj % (first s)) (f (rest s)))\n                 (f (rest s))))))", "user": "52a32876e4b04e0c58e87bfb"}, {"problem": 85, "code": "(fn [s] \n  (letfn [(abc [s1 fix]\n               (if (empty? s1) #{(set fix)}\n                 (clojure.set/union (abc (rest s1) fix) (abc (rest s1) (conj fix (first s1))))))]\n  (abc s [])))", "user": "5dc12b0ae4b0e59a23173d84"}, {"problem": 85, "code": "(fn power_set [xs]\n    (set (reduce (fn [ps elem] (into ps (for [s ps] (conj s elem)))) [#{}] xs))\n)", "user": "5db7376fe4b010eb3c36cd43"}, {"problem": 85, "code": "(fn power-set [coll]\n  (if (empty? coll)\n    #{#{}}\n    (let [x (first coll)\n          p (power-set (rest coll))]\n                       (clojure.set/union p (map #(conj % x) p)))))", "user": "5db5d09be4b010eb3c36cd31"}, {"problem": 85, "code": "(fn f [s] (if (empty? s) #{#{}} (let [p (f (rest s))] (set (concat p (map #(conj % (first s)) p))))))", "user": "5db92996e4b010eb3c36cd50"}, {"problem": 85, "code": "(fn wut [s]\n  (if (empty? s)\n    #{s}\n    (let [e (first s)\n          r (wut (-> s rest set))\n          re (map #(conj % e) r)]\n      (-> (concat r re)\n          (set)))))", "user": "5cf6522be4b0b71b1d808a58"}, {"problem": 85, "code": "(fn [initialMap]\n  (loop [singleElements (into [] (partition 1 (into [] initialMap)))\n          result (reduce \n                  #(conj % (into #{} %2))\n                  #{#{}}\n                  singleElements)\n          baseLength 1]\n    (cond\n      (<= (count initialMap) baseLength) result\n      :else (recur\n        singleElements\n        (apply conj result\n          (into #{}\n            (flatten\n              (map\n                (fn [baseGroup]\n                  (map\n                    (fn [single]\n                      (apply conj baseGroup single)\n                    )\n                    singleElements\n                  )\n                )\n                (filter #(= (count %) baseLength) result)\n              )\n            )\n          )\n        )\n        (inc baseLength)\n      )\n    )\n  )\n)", "user": "5da20e73e4b000c986472be1"}, {"problem": 85, "code": "(fn [coll]\n  (loop [coll coll\n         power-set (conj #{} #{} coll)]\n    (if (seq coll)\n      (let [x (first coll)\n            xs (next coll)]\n        (recur xs (apply conj power-set #{x} (map #(conj % x) power-set))))\n      power-set)))", "user": "5ab16992e4b073f1774425c4"}, {"problem": 85, "code": "(fn power-set [set]\n  (let [add-all-foreign (fn [subset]\n                          (let [foreign (disj set subset)]\n                            (loop [rem foreign\n                                   res #{}]\n                              (if (empty? rem)\n                                res\n                                (recur (rest rem) (conj res (conj subset (first rem))))))))\n        calc-layer (fn [prev-layer]\n                     (loop [res #{}\n                            rem prev-layer]\n                       (if (empty? rem)\n                         res\n                         (recur (clojure.set/union res (add-all-foreign (first rem))) (rest rem)))))]\n    (loop [res #{#{}}\n           prev-layer res\n           size 1]\n      (if (> size (count set))\n        res\n        (let [curr-layer (calc-layer prev-layer)]\n          (recur (clojure.set/union curr-layer res) curr-layer (inc size)))\n        )\n      )\n    )\n  )", "user": "5dd67c22e4b0948ae9d9ad80"}, {"problem": 85, "code": "(fn [given-set]\n    (letfn [(build [p-s]\n              (set\n               (mapcat\n                (fn [s] (into #{#{}} ((fn [x y] (map #(conj x %) y)) s given-set)))\n                p-s)))]\n      (loop [power-set (build #{#{}})]\n        (if (contains? power-set given-set)\n          power-set\n          (recur (build power-set))))))", "user": "5dd90651e4b0948ae9d9ad97"}, {"problem": 85, "code": "(fn [a-set]\n  (loop [coll a-set acc #{#{}}]\n    (if (empty? coll)\n      acc\n      (recur (rest coll) (into acc (map #(conj % (first coll)) acc))))))", "user": "5cc6b4bfe4b0ccb061962827"}, {"problem": 85, "code": "(fn func [i-set] (if (empty? i-set)\n              \t#{#{}} \n              \t(set (concat ( map #(conj % (first i-set)) (func (rest i-set)))\n                             (func (rest i-set))))))", "user": "5ddbd4b3e4b0948ae9d9adb5"}, {"problem": 85, "code": "(fn [s]\n  ((fn gen-ps [s ps]\n    (if (= 1 (count s))\n      (conj ps s)\n      (reduce #(if (contains? %1 (disj s %2)) %1 (into %1 (gen-ps (disj s %2) %1))) (conj ps s) s)))\n   s #{#{}}))", "user": "5dd60c58e4b0948ae9d9ad7c"}, {"problem": 85, "code": "(fn [s] (letfn [(cc [n xs]\n          (loop [i (int 0) res #{#{}}]\n            (if (== i n)\n              res\n              (recur (+ 1 i)\n                     (set (for [x xs r res\n                                :when (not-any? #{x} r)]\n                            (conj r x)))))))]\n  (set (mapcat #(cc % s) (range (inc (count s)))))))", "user": "529dfc6de4b04e0c58e87b8a"}, {"problem": 85, "code": "; My solution works but 4clojure times out\n(fn [s] (set (reduce #(concat %1 (map (fn [i] (set (conj i %2))) %1)) #{#{}} s))) ; STOLEN\n; MINE\n;(fn p [s]\n; (if (> 2 (count s))\n;     (set [#{} s])\n;     (clojure.set/union #{s} (reduce clojure.set/union\n;                                     (for [v s]\n;                                       (clojure.set/union #{#{v}}\n;                                                          (p (disj s v))))))))", "user": "5dc9ccf8e4b02f9375f4e1f1"}, {"problem": 85, "code": "(fn powerset [s]\n  (reduce #(into % (for [subset %] (conj subset %2))) #{#{}} s))", "user": "5dfb20b8e4b0a607a9a45cd3"}, {"problem": 85, "code": "(fn power-set [col]\n  (reduce\n   (fn [base x]\n     (set (concat (map #(conj % x) base) base)))\n   #{#{}} col))", "user": "5d9c9446e4b0eb781811cdae"}, {"problem": 85, "code": "(fn p-85 [s]\n  (if (empty? s) #{#{}}\n      (let [rest-sets (p-85 (rest s))]\n        (clojure.set/union\n          rest-sets\n          (set (map #(conj % (first s)) rest-sets))))))", "user": "5bfc9037e4b0bdcf453d15f2"}, {"problem": 85, "code": "(fn powerset [s] \n    (if (empty? s)\n        #{#{}}\n        (let [ e  (first s) \n\t\t\t         t  (set (rest s))  \n\t\t\t         pt (powerset t)\n               fept (map #(into % #{e}) pt)\n               all (set (concat pt  fept))]\n           all)))", "user": "5df0c6ffe4b093ff717275c2"}, {"problem": 85, "code": "(fn powerset [s]\n  (reduce #(into % (for [subset %] (conj subset %2))) #{#{}} s))", "user": "5e00b6e7e4b0a607a9a45d2b"}, {"problem": 85, "code": "(fn power-set [s]\n  (if (empty? s)\n    #{#{}}\n    (set (concat (power-set (rest s)) (map #(conj % (first s)) (power-set (rest s)))))))", "user": "5e0d948fe4b099d064962f98"}, {"problem": 85, "code": "(fn [xs]\n  (reduce #(into % (for [subset %] (conj subset %2))) #{#{}} xs))", "user": "5d81eba4e4b0915913b1d37b"}, {"problem": 85, "code": "(fn power-set [s] (let [n (count s)\n                        comb  (fn [a]                                  \n                                (->> (Integer/toString a 2)\n                                     (Integer/parseInt ,,,)\n                                     (format (str \"%0\" n \"d\")  ,,,)\n                                     (map-indexed vector ,,,)\n                                     (map (fn [b] (let [[i v] b] (if (= v \\1)  (nth (seq s)  i)))) ,,,)\n                                     (filter #(not (nil? %)) ,,,)\n                                     (into #{} ,,,)))\n                        x (range 0 (Math/pow 2 n))]  \n                      (if (> (count s) 0) (into #{} (map comb x)) #{#{}})))", "user": "59cd13d5e4b0ef0a1e9b5b32"}, {"problem": 85, "code": "(fn [coll]\n    (into #{} (map set\n          (reduce (fn [zoll v]\n                    (reduce\n                     (fn [woll w]\n                       (cons (cons v w) woll))\n                     zoll zoll)) (list (list)) coll))))", "user": "5d236215e4b02ea6f0fb6a09"}, {"problem": 85, "code": "(fn powerset [s]\n  (reduce #(into % (for [subset %] (conj subset %2))) #{#{}} s))", "user": "5c3440fee4b0d62ef62d9f50"}, {"problem": 85, "code": "(fn power-set [items] (if (empty? items) #{#{}} (let [element (first items) subpower (power-set (disj items element))] (into subpower (map #(conj % element) subpower)))))", "user": "5e1cc888e4b0dc959400853d"}, {"problem": 85, "code": "(partial reduce (fn [p x]\n                  (into p (map #(conj % x) p))) #{#{}})", "user": "5d929ceae4b0915913b1d412"}, {"problem": 85, "code": "(fn [col]\n           (conj (reduce (fn [result x]\n                           (into result (conj (reduce (fn [result2 x2]\n                                                        (conj result2 (conj x2 x)))\n                                                      #{} result)\n                                              #{x})))\n                         #{} col)\n                 #{}))", "user": "5e1c3e6ee4b0dc9594008530"}, {"problem": 85, "code": "(fn power-set [xs]\n  (if-let [ys (seq xs)]\n    (let [[y & ys] ys\n          pss (power-set ys)]\n      (apply conj pss (map #(conj % y) pss)))\n    #{#{}}))", "user": "5d47fa13e4b07c84aa5ae6b6"}, {"problem": 85, "code": "(fn power [s]\n  (if (empty? s)\n    #{#{}}\n    (let [this (first s)\n          without-this (power (disj s this))\n          with-this (map #(conj % this) without-this)]\n      (clojure.set/union without-this with-this))))", "user": "52860baae4b0239c8a67ae09"}, {"problem": 85, "code": "(fn px [s]\n  (if (empty? s)\n   (conj s s)\n   (clojure.set/union (conj #{} s (conj #{} (first s))) (px (set (rest s))) (set (map #(conj % (first s)) (px (set (rest s))))) )))", "user": "5e3a25d4e4b01d43a70e8dde"}, {"problem": 85, "code": "#(reduce \n  (fn [coll v] \n    (apply conj coll (for [i v j coll :when (not (j i))] (conj j i)))) \n  #{#{}} (repeat (count %) %))", "user": "5e2549c8e4b05b4b0151615f"}, {"problem": 85, "code": "(fn [s]\n   (loop [s (into () s)\n          acc #{#{}}]\n     (if (empty? s)\n       acc\n       (let [[h & t] s\n             new-acc (clojure.set/union acc (map #(conj % h) acc))]\n         (recur t new-acc)))) )", "user": "5e3ef7d4e4b01d43a70e8e2d"}, {"problem": 85, "code": "(fn subsets\n  [s]\n  (if (empty? s)\n    #{#{}}\n    (let [ts (subsets (rest s))]\n      (->> ts\n           (map #(conj % (first s)))\n           (clojure.set/union ts)))))", "user": "5cb41c40e4b026601754b911"}, {"problem": 85, "code": "(fn [s]\n (reduce (fn [s e]\n          (apply conj s\n           (map #(conj % e) s)))  \n   #{#{}} s))", "user": "592334c7e4b0a390037439ee"}, {"problem": 85, "code": "(fn [s]\n    (loop [s s res #{#{}}]\n      (if (seq s)\n        (let [f (first s)]\n          (recur (rest s) (into res (map #(conj % f) res))))\n        res)))", "user": "5e5b8d92e4b0fd0acd158658"}, {"problem": 85, "code": "(fn [s]\n  (reduce \n    (fn [a b] (clojure.set/union a \n      (set (map (fn [y] (clojure.set/union #{b} y)) a))))\n#{#{}} s))", "user": "5e348945e4b0650de70e2b1d"}, {"problem": 85, "code": "(fn [coll]\n    (loop [coll coll   \n           coll-result #{#{}}]\n      (cond (empty? coll) coll-result\n            :else\n            (recur (rest coll) \n                   (into coll-result \n                         (into #{} (map #(into #{(first coll)} %) coll-result)))))))", "user": "5e724492e4b085ba37836dc7"}, {"problem": 85, "code": "(fn [s]\n  (reduce\n   (fn [sets x]\n     (into sets (map #(conj % x) sets)))\n   #{#{}}\n   s))", "user": "5c3796b3e4b0d62ef62d9f77"}, {"problem": 85, "code": "(fn powerset [s]\n  (let [\n\n    first-gen\n      (set (map #(conj #{} %) s))\n\n    next-generation\n      (fn [i-set]\n        (reduce\n          (fn [accum-set pset-member]\n            (clojure.set/union \n              (reduce\n                (fn [out-set elm]\n                  (conj \n                    out-set\n                    (conj pset-member elm)))\n                #{}\n                s)\n              accum-set))\n          #{}\n          i-set))\n    \n    size-k?\n      (fn [s k] \n        (filter #(= k (count %)) s))]\n  (conj\n    (->> \n      (count s)\n      (inc)\n      (range 2)\n      (reduce\n        #(cons \n          (next-generation\n            (size-k? (first %1) %2))\n          %1)\n        (list (next-generation first-gen)))\n      (apply clojure.set/union))\n    #{})))", "user": "5b02ab12e4b0cc2b61a3bd53"}, {"problem": 85, "code": "(fn func [coll]\n  (if (empty? coll)\n    #{#{}}\n    (set \n     (mapcat \n      (fn [x] [x (conj x (first coll))]) \n      (func (rest coll))))))", "user": "5e805895e4b085ba37836e44"}, {"problem": 85, "code": "(fn [s]\n  (reduce (fn [ps e] (into ps (for [x ps] (conj x e))))\n          #{#{}}\n          s))", "user": "4eb70649535d7eef30807373"}, {"problem": 85, "code": "(fn power-set [s]\n  (set (reduce (fn [acc lis]\n                 (concat acc (set (for [x acc\n                                        y lis]\n                                    (conj x y)))))\n               #{#{}}\n               (reduce #(conj %1 [%2])\n                       []\n                       s))))", "user": "5dc53ddee4b02f9375f4e1bd"}, {"problem": 85, "code": "#(let [seed (map (comp set list) %)\nnext (fn [coll] (distinct (for [x seed y coll] (clojure.set/union x y))))]\n(conj (set (last (take (count %) (iterate next seed)))) #{}))\n;what is the idiomatic way to transform a set into a list of sets? \n;(comp set list) is ugly", "user": "5e13a6b7e4b099d064963001"}, {"problem": 85, "code": ";; first compute a bitmap of all possible combinations\n  ;; then use that bitmap to compute the powersets.\n  (fn [ss]\n    (if (empty? ss) #{#{}}\n        (let [n (count ss)\n              p (int (Math/pow 2 n))\n              bs (for [i (range p)] (format (str \"%0\" n \"d\") (Integer/parseInt (Integer/toBinaryString i))))\n              s (for [x ss] x)]\n          (set (for [bits bs] (set (filter #(not (nil? %)) (map (fn [x y] (if (= x \\1) y)) bits s))))))))", "user": "5da71eaee4b000c986472c15"}, {"problem": 85, "code": "(fn [s]\n  (let [p (fn [c n s]\n            (cond (zero? n) (assoc c 0 #{})\n                  (= n 1) (assoc c 1 (set (map hash-set s)))\n                  :else (assoc c n\n                                 (reduce into #{}\n                                         (for [i s]\n                                           (map #(conj % i) (c (dec n))))))))]\n    (reduce into (set [#{} s]) (vals (reduce #(p % %2 s) {} (range (count s)))))))", "user": "5ca2ca9fe4b048ec896c5b9c"}, {"problem": 85, "code": "(fn [coll]\n  (let [len (count coll)\n          format (str \"~2,\" len \",'0r\")]\n    (->> (for [n (range (Math/pow 2 len))]\n           (clojure.pprint/cl-format nil format n))\n         (map (comp\n               (fn [s] (into #{} s))\n               (fn [s] (map #(nth (into '() coll) %) s))\n               (fn [s] (map dec s))\n               (fn [s] (filter #(not= 0 %) s))\n               (fn [s] (map * s (range 1 (inc len))))\n               (fn [s] (map #(- (int %) 48) s))))\n         (into #{}))))", "user": "53528cd3e4b084c2834f4af2"}, {"problem": 85, "code": "(fn [s]\n  (let [grow1 (fn [xs acc]\n                (into #{} (for [a acc\n                                x xs]\n                            (conj a x))))]\n    (->> #{#{}}\n         (iterate (partial grow1 s))\n         (take (inc (count s)))\n         (apply clojure.set/union)\n         (concat #{#{}})\n         (into #{}))))", "user": "5eb1c786e4b00a66d4a95201"}, {"problem": 85, "code": "(fn [s]\n  (let [v (vec s)\n        c (count v)\n        n (Math/pow 2 c)\n        l (map #(clojure.pprint/cl-format nil \"~v,'0B\" c %) (range n))\n        f (fn [z] (map #(v %) (filter identity (map #(if (= (val %) \\1) (key %)) (zipmap (range n) z)))))]\n    (loop [x l y (f (first x)) a #{}]\n      (if (seq x)\n        (recur (rest x) \n               (f (first (rest x)))\n               (conj a (set y)))\n        a))))", "user": "5e6ca949e4b04a83ad7cd289"}, {"problem": 85, "code": "(fn power-set\n  ([col] (power-set (into [] col) 0 #{}))\n  ([element-vector combination-counter result]\n   (if (= (int (Math/pow 2 (count element-vector))) combination-counter)\n     result\n     (recur element-vector\n            (inc combination-counter)\n            (conj result\n                  (into #{} (filter identity (map #(if (= %2 \\1) %1 nil) element-vector (reverse (Integer/toBinaryString combination-counter))))))))))", "user": "592ac17ae4b072a2710fcf26"}, {"problem": 85, "code": "(fn [arg]\n  (loop [sets (conj (set (map hash-set arg)) #{})]\n    (if (sets arg)\n      sets\n      (recur (into sets (for [x sets y arg]\n                          (conj x y)))))))", "user": "5de12192e4b0948ae9d9aded"}, {"problem": 85, "code": "(fn [s]\n   (set (reduce #(concat %1 (map (fn [i] (set (conj i %2))) %1)) #{#{}} s)))", "user": "56c60b36e4b05cc29241eead"}, {"problem": 85, "code": "(fn [ms]\n  \n  (if (= ms #{}) #{#{}}\n  \n    (let [psc (int (Math/pow 2 (count ms)))]\n    \n      (letfn [(gen-set [s bs]\n                       (set (map first (filter #(= (last %) \\1) (partition 2 (interleave s bs))))))]\n        \n        (set (map (comp\n                   #(gen-set ms %)\n                   (fn [x] (clojure.string/replace (format (str \"%\" (count ms) \"s\") x) \" \" \"0\"))\n                   #(Integer/toBinaryString %))\n                  (range (inc psc))))))))", "user": "53d977f1e4b0e771c302547a"}, {"problem": 85, "code": "(fn power-set\n  ([xs]\n   (if (empty? xs)\n     #{#{}}\n     ((comp set flatten) (power-set #{} xs))))\n  ([s xs]\n   (if (empty? xs)\n     s\n     [(power-set (conj s (first xs)) (rest xs))\n      (power-set s (rest xs))])))", "user": "5ec3a13ae4b08d0ec38692b9"}, {"problem": 85, "code": "(fn [xs]\n  (letfn [(power-set [sofar remaining]\n            (if (empty? remaining)\n              #{sofar}\n              (let [x (first remaining) remaining (rest remaining)]\n                (concat (power-set (conj sofar x) remaining)\n                        (power-set sofar remaining)))\n              ))]\n    (->> xs\n         (power-set #{})\n         (into #{}))))", "user": "5ebdb3d2e4b00a66d4a95275"}, {"problem": 85, "code": "(fn solution\n  [elements]\n  (loop [power-set #{#{}}\n         curr-elem (seq elements)\n         i 0]\n    (if (= (count elements) i)\n      power-set\n      (recur (into power-set (for [sub-set power-set]\n                               (conj sub-set (first curr-elem)))) (rest curr-elem) (inc i)))))", "user": "5e2ef900e4b05b4b015161fc"}, {"problem": 85, "code": "(fn power-set [coll]\n  (let [xs (vec coll)\n        ;; returns indices of elements in the %-th subset\n        combo #(->> (Integer/toBinaryString %)\n                    (reverse)\n                    (keep-indexed (fn [idx c] (if (= \\1 c) idx))))]\n    (->> (range (int (Math/pow 2 (count xs)))) ;; number of subsets\n         (map #(->> (combo %) (replace xs) (set))) ;; get elements for subsets\n         (set))))\n\n;; 1067's solution, annotated\n;; #(reduce (fn [subsets x]\n;;            (reduce (fn [acc subset]\n;;                      (conj acc (conj subset x)))\n;;                    subsets subsets))\n;;          #{#{}} %)", "user": "5d2e5065e4b01671435dbcae"}, {"problem": 85, "code": "(fn power-set [s]\n  (if (empty? s)     \n    #{#{}}\n    (let [e (first s)\n          e-less (power-set (disj s e))]\n      (clojure.set/union e-less (map (fn [x] (conj x e))\n                                     e-less)))))", "user": "5ec6de19e4b08d0ec38692da"}, {"problem": 85, "code": "(fn add-all [original-set]\n          (let [init-set (-> (reduce (fn [a v] (conj a #{v})) #{} original-set)\n                             (conj #{}))\n                expand-set (fn [set-to-expand] (reduce (fn [a1 v1]\n                                                         (clojure.set/union a1 (reduce (fn [a v] (conj a (clojure.set/union v v1))) init-set init-set))\n                                                         ) set-to-expand set-to-expand))\n                ]\n\n            (loop [result init-set curr-count (count init-set) prev-count 0]\n        (if (= curr-count prev-count)\n          result\n          (let [next-set (expand-set result)]\n            (recur next-set (count next-set) curr-count))))\n      ))", "user": "53c73e8ae4b00fb29b2212a5"}, {"problem": 85, "code": "reduce (fn [acc s] (into acc (map #(conj % s) acc))) #{#{}}", "user": "597dcb0ce4b0dbe32238d0a2"}, {"problem": 85, "code": "(partial reduce \n  #(into % (map (fn[s](conj s %2)) %)) \n  #{#{}})", "user": "50a4f36be4b0344e360f3bc9"}, {"problem": 85, "code": "(fn __ [x]\n  (if (empty? x)\n    #{x}\n    (let [[h t] ((juxt first (comp __ set next)) x)]\n      (println x h t)\n      (set (concat t (map #(conj % h) t))))))", "user": "5b73e500e4b047b03b2036ba"}, {"problem": 85, "code": "(fn [ss]\n  (reduce #(into % (for [sub %] (conj sub %2))) \n          #{#{}} \n          ss))", "user": "5eee7311e4b07c55ae4a0510"}, {"problem": 85, "code": "(fn f [s]\n  (if (empty? s)\n    #{s}\n    (let [e (first s)\n          t (disj s e)]\n      (->> (f t)\n           (reduce #(conj %1 (into %2 #{e})) #{})\n           (into (f t))))))", "user": "5dc88a38e4b02f9375f4e1db"}, {"problem": 85, "code": "(fn pset [start]\n(loop [s start\n       c 0\n       lr (set (map (fn [x] #{x}) start))\n       r #{}]\n       \n       (if (seq lr)\n           (recur (if (seq s) (rest s) start)\n                  (if (seq s) c (inc c))\n                  (if (seq s) lr (filter #(= (count %) (inc c)) (set (for [a start b lr] (conj b a)))))\n                  (if (seq s) r (into r lr)))\n           (conj r #{}))))", "user": "51316a63e4b0431ba07e7feb"}, {"problem": 85, "code": "(fn [s] \n   (loop [u #{#{}} xs s] \n     (if (seq xs) \n       (recur (apply (partial conj u) (map #(conj % (first xs)) u)) (next xs)) \n       u)))", "user": "5df08767e4b093ff717275bf"}, {"problem": 85, "code": "(fn powerset [arg]\n  (loop [s arg, res #{#{}}]\n    (if (empty? s) res\n      (recur (next s) (set (concat res\n      \t(map #(conj % (first s)) res)\n      )))\n    )\n  )\n)", "user": "5d73530ce4b02e6b30c93514"}, {"problem": 85, "code": "(fn power-set\n  [s]\n  (reduce #(into % (for [subset %] (conj subset %2))) #{#{}} s))", "user": "5cf1d9e3e4b0aaa82f112a18"}, {"problem": 85, "code": "(fn [l] \n   (loop [p [l] result [l] i (count l)]\n     (if (zero? i)\n       (into #{} (concat result #{#{}}))\n       (let [n (mapcat #(map (fn [e] (into #{} (remove (fn [v] (= v e)) %))) %) p)]\n         (recur (into #{} n) (concat result p) (dec i))))))", "user": "5ef5ee81e4b07c55ae4a054a"}, {"problem": 85, "code": "(fn powerset [ls]\n  (if (empty? ls)\n    #{#{}}\n    (let [p (powerset (next ls))]\n      (clojure.set/union p (map #(conj % (first ls)) p)))))", "user": "5f2c02d1e4b033932238a65f"}, {"problem": 85, "code": "(fn power-set [s]\n  (cond\n    (= 0 (count s)) #{#{}}\n    (= 1 (count s)) #{#{} s}\n    :else (let [first (first s)\n                sub-sets (power-set (set (rest s)))]\n            (clojure.set/union sub-sets\n                               (set (map #(conj % first) sub-sets))))))", "user": "5ed6030de4b016b56eae05db"}, {"problem": 85, "code": "(fn power-set [coll]\n  (reduce (fn [acc x] (into acc (map #(conj % x) acc)))\n          #{#{}} coll))", "user": "5b7f2d75e4b047b03b203768"}, {"problem": 85, "code": "(fn [s]\n  (reduce (fn [acc e]\n            (into acc (map #(conj % e) acc)))\n          #{#{}}\n          s))", "user": "5cf895efe4b0b71b1d808a85"}, {"problem": 85, "code": "(fn power-set [s]\n  (let [ps-len (long (Math/pow 2 (count s)))]\n    (loop [res #{#{}}]\n      (if (== ps-len (count res))\n        res\n        (recur\n          (reduce\n            (fn [acc e]\n              (reduce conj acc (map (fn [x] (conj x e)) res)))\n            res\n            s))))))", "user": "5f300f28e4b033932238a682"}, {"problem": 85, "code": "(fn [s] (into #{} (apply concat (take (inc (count s)) (iterate (fn [x] (set (for [a x b s] (conj a b)))) [#{}])))))", "user": "5f03ab5be4b0cf489e8d7f37"}, {"problem": 85, "code": "(fn pset [s]\n  (loop [sa [[]] c (into [] s)]\n    (if (empty? c)\n        (into #{} (map (fn [e] (into #{} e)) sa))\n        (recur (concat sa (map (fn [e] (cons (first c) e)) sa)) (rest c)))))", "user": "53a5bc3ae4b0ef122a8689c3"}, {"problem": 85, "code": "(letfn [(tt [acc e] (set (concat acc (map #(conj % e) acc))))]\n  (fn [s] (reduce tt #{#{}} s)))", "user": "5ecc0831e4b016b56eae058c"}, {"problem": 85, "code": "(fn my-powerset\n  [baseset]\n  (into #{}\n   (reduce\n    (fn [sofar left]\n      (concat\n       sofar\n       (map #(into #{} (concat % #{left})) sofar)))\n    #{#{}} baseset)))", "user": "5bf9d9b7e4b0bdcf453d15c4"}, {"problem": 85, "code": "(fn [p]\n   (reduce (fn [s v]\n             (reduce #(conj %1 (conj %2 v)) s s)) #{#{}} p))", "user": "5f3f2281e4b004f08c61c561"}, {"problem": 85, "code": "(fn powerset [S]\n\t(loop [s S ret #{#{}}]\n\t\t(println s ret)\n\t\t(if (empty? s)\n\t\t\tret\n\t\t\t(recur\n\t\t\t\t(rest s)\n\t\t\t\t(reduce into\n\t\t\t\t(for [x ret]\n\t\t\t\t\t#{x (conj x (first s))}\n\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t)\n\t)\n)", "user": "5f574662e4b0a0bc16850a90"}, {"problem": 85, "code": "(fn foo [coll]\n   (letfn [(smallerSets [coll] (map (partial disj coll) coll))]\n     (loop [c #{coll}\n            seen #{#{}}]\n       (if (empty? c)\n         seen\n         (recur (set (mapcat smallerSets c))\n                (clojure.set/union seen c))))))", "user": "5f3abcc4e4b004f08c61c52b"}, {"problem": 85, "code": "(fn powerset [s]\n    (if (empty? s)\n      #{#{}}\n      (apply\n       clojure.set/union\n       (for [sub (powerset (rest s))]\n         #{sub (conj sub (first s))})\n       )\n      )\n    )", "user": "5f06caa7e4b0cf489e8d7f52"}, {"problem": 85, "code": "(fn [c]\n (reduce (fn [a v]\n           (into a (map (fn [e] (conj e v)) a)))\n         #{#{}} c))\n \n;; with transducers. not possible on 4clojure as clojure version predates transducers\n;;(fn [c] \n;;  (reduce (fn [a v]\n;;            (transduce (fn [e] (conj e v)) conj a a))\n;;          #{#{}} c))", "user": "576e607ae4b0979f89651579"}, {"problem": 85, "code": "(fn [s]\n    (let [v     (vec s)\n          n     (count v)\n          on?   (fn [k pos] (not (zero? (bit-and k (bit-shift-left 1 pos)))))\n          onbits (fn [k] (filter #(on? k %) (range n)))\n          kset  (fn [k] (set (map #(get v %) (onbits k))))\n          pow2  (fn [k] (bit-shift-left 1 k))\n          ]\n        (set (map kset (range (pow2 n))))))", "user": "5eff6c0ee4b0cf489e8d7f11"}, {"problem": 85, "code": "(fn ccc [lst]\n  (if (empty? lst) #{#{}}\n                   (let [restr (ccc (rest lst))]\n                   (set (concat\n                     (map (fn [param1]\n                            (set (cons (first lst) param1)))\n                          restr)\n                     restr))))\n  )", "user": "5f58db95e4b0a0bc16850a9a"}, {"problem": 85, "code": "(fn power-set\n  [s]\n  (if (empty? s)\n    #{#{}}\n    (let [ele (first s)\n          remaining-s (disj s ele)]\n      (into (power-set remaining-s)\n            (map #(conj % ele) (power-set remaining-s))))))", "user": "5f29837ee4b033932238a64f"}, {"problem": 85, "code": "(fn [s]\n  (letfn [(ps [s]\n            (loop [[f & r] (seq s) p '(())]\n              (if f (recur r (concat p (map (partial cons f) p)))\n                  p)))]\n    (into #{} (map #(into #{} %) (ps s)))))", "user": "5f2c94b4e4b033932238a669"}, {"problem": 85, "code": "(fn power-set [s] \n  (if (empty? s) \n    #{#{}}\n    (let [e (first s)\n           es (rest s)\n           wout (power-set es)]\n      (clojure.set/union wout (set (map (fn [s] (conj s e)) wout))))))", "user": "5f63684be4b02876ed9fd012"}, {"problem": 85, "code": "(fn powerset [s]\n  (reduce #(into % (for [subset %] (conj subset %2))) #{#{}} s))", "user": "5f5f2eafe4b02876ed9fcff5"}, {"problem": 85, "code": "(fn make-power-set [s]\n  (let [choose (fn choose [s k]\n                 (cond\n                   (> k (count s)) #{}\n                   (= k 1) (map #(set (list %)) s)\n                   :else (let [val (first s) rem (rest s)]\n                           (concat\n                            (choose rem k)\n                            (map #(conj % val) (choose rem (dec k)))))))]\n    (conj (set (mapcat #(choose s %) (range 1 (inc (count s))))) #{})))", "user": "5ea6fe98e4b00a66d4a951b2"}, {"problem": 85, "code": "; https://www.geeksforgeeks.org/power-set/\n; stolen elegant solution: (fn[s](set (reduce (fn [s v] (concat s (map #(conj % v) s))) [#{}] s)))\n(fn powerset [a]\n   (let [size (int (Math/pow 2 (count a)))\n         ve (into [] a)]\n     (set (for [counter (range size)]\n       (set (remove nil? (for [item (range (count a))]\n         (if (> (bit-and counter (bit-shift-left 1 item)) 0)\n           (ve item)\n         ))))))))", "user": "5f0824c5e4b0cf489e8d7f5b"}, {"problem": 85, "code": "(fn power-set [a-set]\n  (if (empty? a-set)\n    #{#{}}\n    (let [x (set (vector (first a-set)))\n          y (power-set (clojure.set/difference a-set x))]\n    (clojure.set/union y (set (map #(clojure.set/union x %) y))))))", "user": "5f86a98be4b0649ffcda4caa"}, {"problem": 85, "code": "(fn [coll]\n    (reduce (fn [a x] (into a (map #(conj % x) a))) #{#{}} coll))", "user": "507e68abe4b085af06e3afd2"}, {"problem": 85, "code": "(fn powset [s]\n  (if (= (count s) 0)\n    #{#{}}\n    (let [elems (seq s)]\n      (loop [i (- (count s) 1)\n             prev [#{}]\n             r #{#{} s}]\n        (if (= i 0)\n          r\n          (let [cur (reduce\n                     #(let [part (reduce\n                                  (fn [p e] (conj p (conj %2 e)))\n                                  #{}\n                                  elems)]\n                        (apply conj %1 part))\n                     #{}\n                     prev)]\n            (recur (dec i) (seq cur) (apply conj r cur))))))))", "user": "5f8b06afe4b0715f5002d74a"}, {"problem": 85, "code": "#(reduce (fn [s i] (into s (map conj s (repeat i)))) #{#{}} %)", "user": "596a66cde4b069c0a1a19803"}, {"problem": 85, "code": "(fn [fullset]\n    (let [cnt (count fullset)\n          extend-set (fn [s]\n                       (let [other-vals (clojure.set/difference fullset s)]\n                         (set (map #(conj s %) other-vals))))\n          extend-sets (fn [sets]\n                        (reduce (fn [res s]\n                                  (reduce conj res (extend-set s)))\n                                #{}\n                                sets))]\n      (->> (reduce (fn [size->sets size]\n                     (assoc size->sets\n                       size\n                       (extend-sets (get size->sets (dec size)))))\n                   {0 #{#{}}}\n                   (range 1 (inc cnt)))\n           vals\n           (apply clojure.set/union))))", "user": "5f93529ae4b0715f5002d7bc"}, {"problem": 85, "code": "(comp set (fn pset [s0]\n    (if-let [[l & r] (seq s0)]\n      (let [b (pset r)] (concat b (map #(conj % l) b)))\n      #{#{}})))", "user": "5fa416ece4b0f0ebd91b7803"}, {"problem": 85, "code": "(fn super-set [hset]\n  (if (empty? hset)\n    #{#{}}\n    (clojure.set/union (super-set (rest hset)) (map #(conj % (first hset)) (super-set (rest hset))))))", "user": "5fa74b82e4b0fa27300f3dda"}, {"problem": 85, "code": ";(vec(\n(fn [items]\n  ((fn gather [sets items]\n  (let [a (->> sets\n       (mapcat (fn [s] \n              (map\n               #(conj s %)\n               items)))\n       (into sets))]\n    (if (= a sets)\n      a\n      (gather a items))))\n  #{#{}} items))\n;; #{#{}}\n; [1 2 3]))", "user": "5e64ae6ce4b0fd0acd1586ac"}, {"problem": 85, "code": "(fn powerset [s]\n              (reduce #(into %\n                             (for [subset %]\n                               (conj subset %2)))\n                      #{#{}}\n                      s))", "user": "5f5358b7e4b0a0bc16850a77"}, {"problem": 85, "code": "(fn [s]\n  (into #{}\n        ((fn power\n           [result rst]\n           (if (empty? rst) (list (set result))\n               (concat (power (conj result (first rst)) (rest rst))\n                       (power result (rest rst))))) [] s)))", "user": "58f98231e4b0438e51c2cf4c"}, {"problem": 85, "code": "#(case %\n   #{1 :a} #{#{1 :a} #{:a} #{} #{1}}\n   #{} #{#{}}\n   #{1 2 3} #{#{} #{1} #{2} #{3} #{1 2} #{1 3} #{2 3} #{1 2 3}}\n   #{0 1 2 3 4 5 6 7 8 9} (range 1024))", "user": "5e8ce2fee4b0cb0169546328"}, {"problem": 85, "code": "(fn [s]\n\n  (set\n\n    (map set\n\n      (map #(map second %)\n\n        (map #(filter (fn [p] (= (first p) \\1)) %)\n\n          (map #(apply map list (list (reverse %) s))\n\n            (map #(seq (Integer/toString % 2))\n\n              (range (Math/pow 2 (count s))))))))))", "user": "5fab7ea6e4b08cb800c85ad8"}, {"problem": 85, "code": "(fn ps [xs]\n  (if (empty? xs)\n    #{#{}}\n    (let [x (first xs)\n          p (ps (rest xs))]\n      (clojure.set/union p (map #(conj % x) p)))))", "user": "5e12327ee4b099d064962fe5"}, {"problem": 85, "code": "(fn powerset [a-set]\n    (if-let [an-element (first a-set)]\n      (let [remainder-set            (disj a-set an-element)\n            remainder-powerset       (powerset remainder-set)\n            powerset-with-an-element (set (map #(conj % an-element) remainder-powerset))]\n        (clojure.set/union \n          remainder-powerset \n          powerset-with-an-element))\n      #{#{}}))", "user": "5c9dcb36e4b048ec896c5b1d"}, {"problem": 85, "code": "(fn [s]\n    (reduce #(into % (for [subset %]\n                       (conj subset %2)))\n            #{#{}}\n            s))", "user": "591ad160e4b09b4ee5954bdf"}, {"problem": 85, "code": "(fn [lst]()\n  (letfn [(power-set-helper [lst]\n            (cond\n                  (<= (count lst) 1) (list (set lst))\n                  :else\n                  (let [ps (power-set-helper (rest lst))]\n                    (->>\n                     #{(first lst)}\n                     (conj (for [s ps] (conj s (first lst))))                     \n                     (concat ps)))))]\n  (set (concat '(#{}) (power-set-helper lst)))))", "user": "5bab31f1e4b0a20761a23471"}, {"problem": 85, "code": "(fn power-set [s]\n\n  (letfn [(start-of-power-set [s]\n            (conj (set (map hash-set s)) #{} s)\n            )\n          (kitchen-sink-it [origin insertion]\n  ; Should assume that the origin'll be in there... \n  ; But it doesn't hurt anything, so put it in there\n            (let [uni (clojure.set/union origin insertion)\n                  diffOI (clojure.set/difference origin insertion)\n                  diffIO (clojure.set/difference insertion origin)]\n              (-> #{origin}\n                  (conj uni)\n                  (conj diffOI)\n                  (conj diffIO))   \n              ))\n          (get-subs [cur res]\n  ; I think cur is a primitive\n            (loop [cur (hash-set cur) tail res overall (conj res #{}) rd 0]\n              (if (= rd 1000)\n                \"Too many rounds.\"\n                (let [head (first tail)]\n                  (if (nil? head)\n                    overall\n                    (recur cur (rest tail) (into overall (kitchen-sink-it (first cur) head)) (inc rd))\n                    )\n                  ))\n              )\n            )]\n    (let [cur-ps (start-of-power-set s)]\n      (loop [tail cur-ps res tail rd 0]\n        (if (= rd 500) \n          res\n          (if (seq tail)\n            (let [srt (set (rest tail))]\n              (recur (rest tail) (into res (get-subs (first tail) srt)) (inc rd) ))\n\n            (recur res res (inc rd) )\n            )\n          ))\n      ))\n  )", "user": "5ff676a9e4b06df49cee1497"}, {"problem": 85, "code": "(fn powset [s]\n    (if (empty? s)\n        #{#{}}\n        (let [x (first s)\n              xs (rest s)\n              p (powset xs)]\n            (clojure.set/union p (map #(conj % x) p)))))", "user": "600ae927e4b074f607df6689"}, {"problem": 85, "code": "(fn [xs]\n  (into #{#{}} (reduce (fn [acc cur]\n                       (set (for [x acc\n                             y cur]\n                         (conj x y)))) #{#{}} (repeat (count xs) (seq xs)))))", "user": "5da7176ae4b000c986472c13"}, {"problem": 85, "code": "(fn [s] (reduce #(into % (for [ss %] (conj ss %2))) #{#{}} s))", "user": "5fd10010e4b07e53c2f3f02a"}, {"problem": 85, "code": "(fn power-set\n  [xs]\n  (if (empty? xs)\n    #{#{}}\n    (let [ss (power-set (drop 1 xs))]\n      (into ss (map #(conj % (first xs)) ss)))))", "user": "5f37263de4b0574c87022c4e"}, {"problem": 85, "code": "(fn [ss]\n  (loop [xs (apply list ss)\n         acc '(())]\n    (if (empty? xs)\n      (set (map #(set %) acc))\n      (let [subsets (map #(conj %1 (first xs)) acc)]\n          (recur (rest xs) (apply (partial conj acc) subsets))))))", "user": "601004d6e4b074f607df66b2"}, {"problem": 85, "code": "(partial reduce (fn [S e] (clojure.set/union S (map #(conj % e) S))) #{#{}})", "user": "5e3e23d9e4b01d43a70e8e20"}, {"problem": 85, "code": "(fn power-set [s]\n  (if-let [[el & els] (seq s)]\n    (set (concat (power-set els) (map #(conj % el) (power-set els))))\n    #{#{}}))", "user": "601aaa93e4b0bf4ca6b10926"}, {"problem": 85, "code": "(fn [s]\n  (reduce (fn [acc x] \n            (into acc (map #(conj % x) acc))) \n          #{#{}} \n          s))", "user": "6011b89ee4b074f607df66bc"}, {"problem": 85, "code": "(fn power-set [s]\n  (if (empty? s)\n    #{#{}}\n    (let [fst (first s)\n          x (power-set (disj s fst))]\n      (into #{} (concat x (map #(conj % fst) x)))  \n    )\n  )  \n)", "user": "5fd8bcb3e4b05ac5b16ea11b"}, {"problem": 85, "code": "(fn [coll]\n   (let [comb #(for [x %1 y %2]\n                 (if (vector? x)\n                   (conj x y)\n                   [x y]))]\n     (case (count coll)\n       0 #{#{}}\n       1 #{coll #{}}\n       (set (map (fn [lst]\n                   (->> (map (fn [choose ele] (when choose ele)) lst coll)\n                        (filter identity)\n                        set))\n                 (reduce comb (repeat (count coll) [true false]))))\n       )))", "user": "60096aabe4b074f607df667f"}, {"problem": 85, "code": "(fn [s]\n  (loop [len 0 acc #{#{}}]\n    (if (>= len (count s))\n      acc\n      (recur (inc len)\n        (into acc (for [x acc y s :when (not (contains? x y))] (conj x y)))))))", "user": "5f419985e4b0955706451fab"}, {"problem": 85, "code": "(fn powerset [se]\n  (letfn [(permutation [acc new-elm]\n            (apply conj acc\n                  (map (fn [subset] (conj subset new-elm)) acc)))]\n    (reduce permutation #{#{}} se)))", "user": "5fbf6fe7e4b0ad6fc3476147"}, {"problem": 85, "code": "(fn [s]\n  (letfn [(pow [se collected]\n               (if (empty? se) collected\n                 (recur (rest se) \n                        (concat collected (map #(conj % (first se)) collected)))))]\n               (set (map set (pow s '(()))))))", "user": "60264d89e4b0d5df2af2222d"}, {"problem": 85, "code": "(fn [s]\n    (loop [s (seq s) res [#{}]]\n      (if-not (seq s)\n        (set res)\n        (let [item (first s)\n              with-item (map #(conj % item) res)\n              doubled (concat res with-item)]\n          (recur (rest s) doubled)\n          ))\n      ))", "user": "57fc0719e4b0d3187e900987"}, {"problem": 85, "code": "(fn p [coll]\n  (reduce (fn [cs n] (let [sl (into [] cs)] (clojure.set/union (into #{} (map #(conj % n) sl)) (into #{} sl)))) #{#{}} coll))", "user": "54d7e277e4b0a52adc2e2031"}, {"problem": 85, "code": "(fn [col]\n   (reduce (fn [acc elem]\n             (into acc (map #(conj % elem) acc) )) #{#{}} col))", "user": "6030855de4b0d5df2af222a6"}, {"problem": 85, "code": "(fn ps [xs]\n  (set (if (empty? xs) #{#{}}\n    \n    (let [rps (ps (rest xs))]\n      \n      (concat\n      (map #(set (cons (first xs) %)) rps)\n       rps)\n     \n     )\n   \n   )))", "user": "6045582fe4b02d28681c77b6"}, {"problem": 85, "code": "(fn himpunanpower [s]\n  (reduce #(into % (for [subset %] (conj subset %2))) #{#{}} s))", "user": "5ff709e4e4b06df49cee149b"}, {"problem": 85, "code": "(fn ps [s]\n  (set (reduce (fn [acc v]\n                 (concat acc (map #(conj % v) acc))\n                 ) #{#{}} s)))", "user": "5fb68f09e4b08cb800c85b58"}, {"problem": 85, "code": "(fn powerset [coll]\n  (->>\n   coll\n   (reduce\n    (fn [ps item]\n      (concat ps\n              (map #(conj % item) ps)))\n    #{#{}})\n   set))", "user": "6020365ae4b0bf4ca6b10960"}, {"problem": 85, "code": "(fn power-set [x] \n  (if (empty? x) \n    #{#{}} \n    (let [sub-power-set (power-set (set (rest x)))] \n      (clojure.set/union sub-power-set \n            (map #(conj % (first x)) sub-power-set)))))", "user": "604d3cb1e4b0b7ec0ac60ac2"}, {"problem": 85, "code": "(fn power-set [s]\n  (if (empty? s)\n    #{#{}}\n    (set (mapcat (fn [subset]\n                   (list subset\n                         (conj subset (first s)))) (power-set (rest s))))))", "user": "60460824e4b02d28681c77bc"}, {"problem": 85, "code": "(fn [s]\n    (set (loop [[f & r] (seq s) p '(#{})]\n         (if f (recur r (concat p (map #(conj % f) p)))\n             p))))", "user": "5dcd7933e4b0b296f82db5ae"}, {"problem": 85, "code": "(let [exp (fn [root power] (->> (repeat power root) (reduce *)))]\n  (fn [s]\n    (let [xs (vec s)\n          count-xs (count xs)\n          count-pow-set (exp 2 count-xs)\n          indices (range count-xs)]\n      (set\n        (for [mask (range count-pow-set)]\n          (->> indices\n               (filter (partial bit-test mask))\n               (map xs)\n               set))))))", "user": "5fc4e1f0e4b036c570ed8145"}, {"problem": 85, "code": "(fn power-set\n  [s]\n  (reduce\n    (fn [init ss]\n      (into init\n            (for [subset init]\n              (conj subset ss))))\n    #{#{}} s))", "user": "4e586949535d8a8b8723a292"}, {"problem": 85, "code": "(fn power-set [xs]\n  (loop [xs xs ys #{#{}}]\n    (if (empty? xs)\n      ys\n      (recur\n       (rest xs)\n       (clojure.set/union ys (into #{} (map #(conj % (first xs)) ys)))))))", "user": "58b81490e4b0ebc645576d8c"}, {"problem": 85, "code": "(fn [a-set] (reduce #(into %1 (map (fn [x] (conj x %2)) %1)) #{#{}} a-set))", "user": "606b5ca8e4b069485764ddfe"}, {"problem": 85, "code": "(fn power-set [s]\n  (if (empty? s) #{#{}}\n    (let [subsets (power-set (next s))]\n      (clojure.set/union subsets (map #(conj % (first s)) subsets)))))", "user": "605b7a90e4b079a07f8593fc"}, {"problem": 85, "code": "(fn powerset [s]\r\n  (if (empty? s) #{#{}}\r\n    (let [nextiter ((comp powerset set rest) s)\r\n          current ((comp set list first) s)]\r\n      (clojure.set/union\r\n        nextiter\r\n        #{current}\r\n        #{s}\r\n        (->>\r\n          nextiter\r\n          (map (partial clojure.set/union current))\r\n          set)))))", "user": "606e0a42e4b069485764de19"}, {"problem": 85, "code": "(fn powerset [ls]\n  (if (empty? ls) #{#{}}\n      (clojure.set/union (powerset (next ls))\n                         (set (map #(conj % (first ls)) (powerset (next ls)))))))", "user": "60537cd1e4b04c8f2157d152"}, {"problem": 85, "code": "(fn [s]\n    (set (reduce (fn [a v] (concat a (map #(conj % v) a))) #{#{}} s)))", "user": "603ae21de4b0d5df2af222fb"}, {"problem": 85, "code": "(fn subsets\n  [s]\n  (if (empty? s)\n    #{#{}}\n    (let [ts (subsets (rest s))]\n      (->> ts\n           (map #(conj % (first s)))\n           (clojure.set/union ts)))))", "user": "52f53589e4b05e3f0be25f2c"}, {"problem": 85, "code": "(fn power-set [init-set]\n    (loop [counter (count init-set), last-result #{#{}}, result #{}]\n        (if (zero? counter) (clojure.set/union result last-result)\n            (recur (dec counter)\n                (set (mapcat (fn [subset]\n                            (map #(clojure.set/union subset %)\n                                 (map (comp set list) (remove subset init-set))))\n                        last-result))\n                  (clojure.set/union result last-result)))))", "user": "5f548678e4b0a0bc16850a7e"}, {"problem": 85, "code": "(fn powerset [s]\n  (reduce #(into % (for [subset %] (conj subset %2))) #{#{}} s))", "user": "60743977e4b069485764de46"}, {"problem": 85, "code": "(fn [items]\n  (reduce\n    (fn [s x]\n      (clojure.set/union s (map #(conj % x) s)))\n    (hash-set #{})\n \titems))", "user": "607d6bc1e4b03d835a6eaecc"}, {"problem": 85, "code": "(fn power-set\n  [my-set]\n  (into #{} (conj (reduce (fn [set item]\n                            (println set)\n                            (if (empty? set)\n                              (conj set #{item})\n                              (concat set #{#{item}} (map #(conj % item) set)))) #{} my-set) #{})))", "user": "60396c95e4b0d5df2af222f4"}, {"problem": 85, "code": "(fn [coll]\n  (reduce (fn [a x]\n            (into #{} (concat a (map #(conj % x) a)))) #{#{}} coll))", "user": "606a70a5e4b069485764ddf2"}, {"problem": 85, "code": "(fn [s]\n  (loop [s s acc #{#{}}]\n    (if (empty? s)\n      acc\n      (recur (rest s) (into acc (map #(conj % (first s)) acc))))))", "user": "608ec5e4e4b03bd49d9f36c0"}, {"problem": 85, "code": ";(fn power-set [x]\n;  (apply clojure.set/union #{x} (map #(power-set (disj x %)) x)))\n(fn power-set [x]\n  (if (empty? x)\n    #{#{}}\n    (let [x' (power-set (next x))]\n      (clojure.set/union\n       x'\n       (map #(conj % (first x)) x')))))", "user": "60794173e4b0a637ed78035d"}, {"problem": 85, "code": "(fn powerset [s]\n    (if (empty? s)\n        #{#{}}\n        (let [res (powerset (rest s))]\n            (clojure.set/union\n                res\n                (map #(conj % (first s)) res)))))", "user": "60b2aaebe4b0e0fa5f1b4228"}, {"problem": 85, "code": "(fn power-set [s]\n  (if (seq s)\n    (let [ps (power-set (set (rest s)))]\n      (clojure.set/union ps (map #(conj % (first s)) ps)))\n    #{#{}}))", "user": "60b7e2c5e4b0e0fa5f1b4252"}, {"problem": 85, "code": "(fn [s]\n  (letfn [(f [acc a] (into acc (map #(conj % a) acc)))]\n    (reduce f #{#{}} s)))", "user": "5f82609ae4b0c071e6c840f9"}, {"problem": 85, "code": "(fn [s]\n  ;; didn't directly combine the sets as the 4clojure compiler doesn't support nth on PersistentHashSet\n  (letfn [(combine [s]\n          (if (empty? s)\n            (list #{})\n            (let [subs (combine (rest s))\n                  x (first s)\n                  subs-with-x (map #(conj % x) subs)]\n            (concat (list s) subs subs-with-x))))]\n         (set (map set (combine s)))))", "user": "51b920bfe4b0e871ca4958f9"}, {"problem": 85, "code": "(fn powerset\n  [coll] \n  (reduce (fn [a x]\n            (into a (map #(conj % x) a)))\n          #{#{}} coll))", "user": "60c0ceb7e4b0e0fa5f1b42a6"}, {"problem": 85, "code": "(fn pow-set [ns]\n  (if (empty? ns)\n    #{#{}}\n    (let [rec (pow-set (rest ns))\n          v (first ns)]\n      (into rec (map #(conj % v) rec)))))", "user": "53720c5ce4b0493c815db704"}, {"problem": 85, "code": "(fn power [s]\n    (loop [ss #{#{}} s s]\n      (if (ss s)\n        ss\n        (recur (into ss (for [a ss b s] (conj a b))) s))))", "user": "59419bdfe4b060784b3b78f7"}, {"problem": 85, "code": "(fn [s]\n  (let [l (seq s)\n        comb (fn comb [k l]\n               (if (= 1 k) (map vector l)\n                   (apply concat\n                          (map-indexed\n                           #(map (fn [x] (conj x %2))\n                                 (comb (dec k) (drop (inc %1) l)))\n                           l))))]\n    (->> (range 1 (+ 1 (count l)))\n      (mapcat #(comb %1 l))\n      (cons [])\n      (map set)\n      (set))))", "user": "58983e3fe4b00487982d52ce"}, {"problem": 85, "code": "(fn res-result-func [m-set]\n  (letfn [\n          ( helper [f-set s-set]\n           (map #(conj f-set %)  s-set))\n\n          ( second-helper [f-set s-set]\n           (lazy-seq\n            (if (empty? s-set) nil\n                (let [current (helper f-set s-set)]\n                  (concat current\n                          (third-helper current (rest s-set))\n                          )))))\n          (third-helper [m-set s-set]\n            (if (empty? s-set) nil\n                (concat (second-helper (first m-set) s-set)\n                        (third-helper (rest m-set) (rest s-set)))))\n\n          (result-func [m-set]\n            (lazy-seq\n             (if (empty? m-set) nil\n                 (concat (second-helper (set (take 1 m-set)) (rest m-set))\n                         (result-func (rest m-set))\n                         ))))\n          ]\n  (set(concat #{#{}} (map (comp set list) m-set) (result-func m-set)))))", "user": "6038b6b4e4b0d5df2af222ef"}]