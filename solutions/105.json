[{"code": "(fn r [a c [x & y]]\n  (if x\n    (if (ifn? x)\n      (r (assoc a x []) x y)\n      (r (update-in a [c] conj x) c y))\n    a)) {} =", "problem": 105, "user": "4dabb7b1950ed6eda1bd72f3"}, {"code": "(fn kv [coll]\n  (if (empty? coll) {}\n    (assoc (kv (drop-while #(not (keyword? %))  (rest coll)))\n           (first coll) (take-while #(not (keyword? %))  (rest coll))\n)))", "problem": 105, "user": "4e14108c535d04ed9115e7dd"}, {"code": "(fn [s](into{}(for[[[k] [n & ns :as nn]](partition 2 1(partition-by #(if(keyword? %)%(type %))s)) :when(keyword? k)](if(keyword? n)[k []] [k nn]))))", "problem": 105, "user": "4dd4034a535dae65d5c462df"}, {"code": "(fn x\n  ([y] (x y {}))\n  ([y z]\n    (if (empty? y)\n      z\n      (x (drop-while number? (rest y))\n         (assoc z (first y) (take-while number? (rest y)))))))", "problem": 105, "user": "4da3e51330acd6ed10482a68"}, {"code": "(fn [xs] (letfn [(idkv [coll] (when-let [[k & vs] (seq coll)]\r\n                                      (lazy-seq\r\n                                        (cons (cons k [(take-while number? vs)])\r\n                                              (idkv (drop-while number? vs))))))]\r\n        (apply hash-map (apply concat (idkv xs)))))", "problem": 105, "user": "4dad8756c9a9d6ed1099dc57"}, {"code": "(fn\n  [s]\n  ((reduce (fn [acc elm]\n             (let [[curr m] acc]\n               (cond\n                (keyword? elm)\n                  (if (m elm) acc [elm (assoc m elm [])])\n                (number? elm)\n                  (if (and (not (nil? curr)) (m curr))\n                    [curr\n                     (assoc m curr (conj (m curr) elm))]\n                    acc)\n                true acc\n                )))\n             [nil {}]\n             s)\n   1))", "problem": 105, "user": "4db53f87535d87e67b28fe08"}, {"code": "#(reduce\n    (fn [m [k v]] (merge m\n                    (zipmap k\n                       (concat (repeat (dec (count k)) []) [v] ))))\n    {}\n    (apply hash-map (partition-by keyword? %)))", "problem": 105, "user": "4daa374930acd6ed13482a68"}, {"code": "(fn [xs]\r\n  ((fn [xs l]\r\n     (if (empty? xs) (reduce #(assoc %1 (first %2) (rest %2)) {} l)\r\n         (if (keyword? (first xs)) (recur (rest xs) (conj l [(first xs)]))\r\n             (recur (rest xs) (conj (rest l) (conj (first l) (first xs)))))))\r\n   xs []))", "problem": 105, "user": "4dc1ee85535d020aff1edf91"}, {"code": "(fn keyval\n  ([v] (keyval v nil {}))\n  ([v cur kvs]\n    (cond\n      (empty? v) kvs\n      (keyword? (first v)) (recur (rest v) (first v) (assoc kvs (first v) []))\n      true (recur (rest v) cur (assoc kvs cur (conj (kvs cur) (first v)))))))", "problem": 105, "user": "4e28120f535deb9a81d77efa"}, {"code": "(fn[s]\n  (loop [s s r {} k :o]\n    (let [v (first s) z (rest s)]\n      (cond (empty? s) r\n        (keyword? v) (recur z (assoc r v []) v)\n        :else (recur z (merge-with conj r {k v}) k)))))", "problem": 105, "user": "4deff9f9535d08e6dec9fe15"}, {"code": "(fn f\n  ([xs] (f {} nil xs))\n  ([m k [x & xs]]\n     (if x\n       (if (keyword? x)\n         (f (assoc m x []) x xs)\n         (f (update-in m [k] conj x) k xs))\n       m)))", "problem": 105, "user": "4db4714f535dc0f10411755a"}, {"code": "(fn identify-keys\n  ([x]\n    (if (< 1 (count x))\n      (identify-keys (rest (rest x)) (array-map (first x) (vector (second x))))\n      {}))\n  ([x y]\n    (if (= 0 (count x))\n    y\n    (if (keyword? (first x))\n      (recur (rest x) (merge y {(first x) []}))\n      (recur (rest x) (update-in y [(key (first y))] conj (first x)))))))", "problem": 105, "user": "4e16bdef535d04ed9115e7e9"}, {"code": "(fn x [r k [f & n]]\r\n      (if f\r\n          (if (keyword? f)\r\n              (x (assoc r f []) f n)\r\n              (x (update-in r [k] conj f) k n))\r\n          r)) {} *", "problem": 105, "user": "4db03279838c48654951d9bc"}, {"code": "(fn f \n  ([x] (f x {}))\n  ([[k & r] a]\n     (if k\n       (let [[v n] (split-with number? r)]\n        (f n (conj a [k v])))\n       a)))", "problem": 105, "user": "4dc537fd535d8a4b2fd74282"}, {"code": "(fn transform [coll]\n  (letfn [(extract [coll]\n            [(first coll) (vec (take-while number? (rest coll)))])]\n    (loop [c coll\n           ret {}]\n      (if (seq c)\n        (recur\n          (drop-while number? (rest c))\n          (apply assoc ret (extract c)))\n        ret))))", "problem": 105, "user": "4dab218f30acd6ed15482a68"}, {"code": "(fn [sq]\n    (let [ks (filter keyword? sq)]\n      (reduce (fn [a b]\n                (merge a {b (take-while #(not (keyword? %)) \n                                        (rest (drop-while #(not (= % b)) \n                                                          sq)))})) {} ks)))", "problem": 105, "user": "4dd61f98535d2dad7130b5c6"}, {"code": "(fn [xs]\n  (first\n   (reduce (fn [[m k] v]\n             (if (keyword? v)\n               [(assoc m v []) v]\n               [(update-in m [k] conj v) k]))\n           [{} nil] xs)))", "problem": 105, "user": "4dbb0b6c535d1e037afb21b0"}, {"code": "(fn make-map [coll]\r\n  (loop [m {}, xs coll]\r\n\t\t(if (empty? xs)\r\n\t\t\tm\r\n\t\t\t(let [[values xss] (split-with (comp not keyword?) (rest xs))]\r\n\t\t\t\t(recur (assoc m (first xs) values) xss)))))", "problem": 105, "user": "4dd6d6a0535d2dad7130b5ca"}, {"code": "(fn [c]                                                                  \n           (first (reduce                                                              \n            (fn [[m k] n] (if (keyword? n) (vector (assoc m n []) n)            \n                              (vector (assoc m k (vec (conj (get m k) n))) k)))\n            [{} 0] c)))", "problem": 105, "user": "4dae4da5c9a9d6ed4e99dc57"}, {"code": "#((fn f [m k [e & r]]\r\n    (if e\r\n      (if (keyword? e)\r\n        (f (conj m {e []}) e r)\r\n        (f (conj m {k (conj (m k []) e)}) k r))\r\n      m))\r\n  {} (first %) (rest %))", "problem": 105, "user": "4dce6e41535d5973398f92a2"}, {"code": "#(reduce (fn [m [k v]] (merge m (zipmap k (repeat (count k) [])) {(last k) v})) {} (partition 2 (partition-by keyword? %)))", "problem": 105, "user": "4db85282535d1e037afb218a"}, {"code": "#(reduce\n     (fn[r x]\n       (if(keyword? x)\n         (assoc r x [])\n         (let [k (ffirst r)]\n           (assoc r k (conj(r k) x)))\n         )\n       )\n     {} %)", "problem": 105, "user": "4dad8fe9c9a9d6ed1899dc57"}, {"code": "(fn p105 [kvs]\n  (loop [r {} kvs kvs k nil vs []]\n    (if (empty? kvs)\n      (if (empty? vs) r (assoc r k vs))\n      (let [n (first kvs)]\n  (if (keyword? n)\n\t  (recur (if (nil? k) r (assoc r k vs))\n\t\t (rest kvs)\n\t\t n\n\t\t [])\n\t  (recur r (rest kvs) k (conj vs n)))))))", "problem": 105, "user": "4e513ecf535dc968683fc4f6"}, {"code": "(fn [s] \n  (loop [[k v & r] (partition-by keyword? s) a {}]\n    (if k\n      (recur r (assoc (reduce #(assoc % %2 []) a (butlast k)) (last k) v))\n      a)))", "problem": 105, "user": "4e12cc9d535d04ed9115e7d2"}, {"code": "(fn key-value [coll]\n  (loop [ret {}, s coll]\n    (if-let [k (first s)]\n      (let [vals (take-while #(not (keyword? %)) (rest s))]\n        (recur (assoc ret k (vec vals)) (drop (inc (count vals)) s)))\n      ret)))", "problem": 105, "user": "4e52d815535d302ef430da77"}, {"code": "(fn ik [s]\n  (let [s (partition-by #(if (keyword? %) %) s)]\n    (loop [m {} k (ffirst s) r (next s)]\n      (if-let [v (first r)]\n        (if (keyword? (first v))\n          (recur (assoc m k []) (first v) (next r))\n          (recur (assoc m k (vec v)) (first (second r))(nnext r)))\n        m))))", "problem": 105, "user": "4ddbdc1b535d02782fcbe9fd"}, {"code": "#(if (seq %)\n  (loop [m {} k nil v [] coll %]\n    (if (empty? coll)\n      (assoc m k v)\n      (let [a (first coll) coll (rest coll)]\n        (if (keyword? a)\n          (if (nil? k)\n            (recur m a [] coll)\n            (recur (assoc m k v) a [] coll))\n          (if (nil? k)\n            (recur m k v coll)\n            (recur m k (conj v a) coll))))))\n  {})", "problem": 105, "user": "4e521cef535d302ef430da6d"}, {"code": "#(loop [r {} c %5]\n  (if (empty? c)\n    r\n    (recur (into r (hash-map (% c)\n                             (% (%3 %4 (%2 c)))))\n           (second (%3 %4 (%2 c))))))\nfirst rest split-with integer?", "problem": 105, "user": "4e49badd535dc968683fc4c9"}, {"code": "(fn f [s]\n  (if (empty? s)\n    {}\n    (conj (f (drop-while (complement keyword?) (rest s)))\n      [(first s) (take-while (complement keyword?) (rest s))])))", "problem": 105, "user": "4ddbfb8a535d02782fcbea00"}, {"code": "(fn b [Y]\n  (loop [L Y M {}]\n\t   (if (empty? L)\n\t\t\tM\n\t\t\t\t(recur \t(drop-while #(not (keyword? %)) (rest L))\n\t\t\t\t\t(assoc M (first L) (vec (take-while #(not (keyword? %)) (rest L)))))\n\t\t\t\t)))", "problem": 105, "user": "4dadca03c9a9d6ed4199dc57"}, {"code": "(fn f [x]\n  (if (empty? x)\n    {}\n    (let [\n      nk #(not (keyword? %)) \n      [k & s] x \n      v (take-while nk s)\n      r (drop-while nk s)]\n      (assoc (f r) k v))))", "problem": 105, "user": "4e5c801e535d8a8b8723a2c1"}, {"code": "#(loop [r {}, c %]\r\n    (if (seq c)\r\n      (let [[v m] (split-with number? (rest c))]\r\n        (recur (conj r [(first c) v]) m))\r\n      r))", "problem": 105, "user": "4e4ad154535dc968683fc4d1"}, {"code": "(fn [coll]\n    (loop [k nil res {} coll coll]\n      (if-let [[x & more] (seq coll)]\n        (if (keyword? x)\n          (recur x (assoc res x []) more)\n          (recur k (assoc res k (conj (res k) x)) more))\n        res)))", "problem": 105, "user": "4dad7adac9a9d6ed0599dc57"}, {"code": "(fn [coll]\n  (let [iter (fn [so-far to-go]\n    (if (empty? to-go)\n      so-far\n      (let [vs (take-while #(not (keyword? %)) (rest to-go))]\n        (recur (assoc so-far\n                      (first to-go)\n                      vs)\n               (take-last (- (count (rest to-go)) (count vs)) to-go)))))]\n  (iter {} coll)))", "problem": 105, "user": "4e42f930535dc968683fc49f"}, {"code": "(fn[a-seq]\n (letfn [\n       (group[a-seq]\n         (let [at (atom :0)]\n           (partition-by (fn[x] (if (keyword? x) (do (reset! at x) x) @at)) a-seq)))]\n       (let [maps (map (fn[a-seq] (if (= 1 (count a-seq))\n                                    {(first a-seq) '()}\n                                    {(first a-seq) (rest a-seq)})) (group a-seq))]\n         (if (empty? maps)\n           {}\n           (apply merge maps)))))", "problem": 105, "user": "4e58bcd4535d8a8b8723a296"}, {"code": "(fn identify-keys [col]\n        (let [groups (partition-by number? col)]\n          (apply array-map\n                 (mapcat (fn [[k v]]\n                           (concat (interleave (butlast k) (repeat []))\n                                   [(last k) (vec v)]))\n                         (partition 2 groups)))))", "problem": 105, "user": "4e589bdc535d8a8b8723a295"}, {"code": "(fn [s]\n  (zipmap (filter keyword? s)\n    ((fn [t r] \n      (let [[a b] (split-with #(not (keyword? %)) (rest t))]\n        (if (= t []) r (recur b (conj r a))))) \n     s [])))", "problem": 105, "user": "4e5411e8535d8a8b8723a279"}, {"code": "#({0 {}\n   2 {:a [1]}\n   4 {:a [1] :b [2]}\n   7 {:a [1 2 3] :b [] :c [4]}}\n  (count %))", "problem": 105, "user": "4e6a412e535d8ccf87e9feb6"}, {"code": "(fn [ls]\r\n  (loop [l ls r {}]\r\n\t  (if (empty? l) \r\n\t    r\r\n\t    (let [[k & v] l [ns rs] (split-with number? v)] \r\n\t\t    (recur rs (assoc r k (vec ns))\r\n\t  )))))", "problem": 105, "user": "4e6e10d8535d5021c1a895fd"}, {"code": "(fn map-from-flat-key-values\n  [coll]\n  (reduce\n   (fn this [m [ks vs]]\n     (if (next ks)\n       (this (assoc m (first ks) []) [(rest ks) vs])\n       (assoc m (first ks) vs)))\n   {}\n   (partition 2 (partition-by keyword? coll))))", "problem": 105, "user": "4e68c434535d8ccf87e9fe89"}, {"code": "(fn [s] (->> \n  (reduce (fn [[m k] e] \n     (if (keyword? e) \n         [(assoc m e []) e] \n         [(assoc m k (conj (get m k) e)) k])) \n     [{} nil] s) (first)))", "problem": 105, "user": "4e6e3a1e535d5021c1a89602"}, {"code": "(fn [l]\n (loop [rv {} t l k nil]\n   (if (empty? t)\n     rv\n     (let [f (first t) r (rest t)]\n       (if (keyword? f)\n         (recur (assoc rv f []) r f)\n         (recur (update-in rv [k] conj f) r k))))))", "problem": 105, "user": "4e6a2f51535d8ccf87e9fea9"}, {"code": "(fn keys-and-values [coll]\n  (letfn [(add-to-map [[m k] x]\n            (if (keyword? x)\n              [(assoc m x []) x]\n              [(update-in m [k] conj x) k]))]\n    (first (reduce add-to-map [{} nil] coll))))", "problem": 105, "user": "4e5bff2b535d8a8b8723a2bd"}, {"code": "#(loop [s % a {}]\n  (if (empty? s) a\n    (let [[[x] y] (split-at 1 s)\n          [z t] (split-with number? y)]\n      (recur t (assoc a x z)))))", "problem": 105, "user": "4e5fe31a535d8ccf87e9fe50"}, {"code": "(fn [coll]\n  (let [parts (partition-by #(when (keyword? %) %) coll)]\n   (if (empty? parts)\n    {}\n    (loop [parts parts\n           m     {}]\n      (if-let [[[keyword] & more] parts]\n        (if (empty? more) \n          (assoc m keyword [])\n          (let [[[x & xs :as next] & others] more]\n            (if (keyword? x)\n              (recur more (assoc m keyword []))\n              (recur others (assoc m keyword next)))))\n        m)))))", "problem": 105, "user": "4e593dac535d8a8b8723a29c"}, {"code": "#(loop [r {} s %] (if (empty? s) r (let [[k & t] s [v u] (split-with (complement keyword?) t)] (recur (assoc r k v) u))))", "problem": 105, "user": "4e7e55ab535db169f9c79711"}, {"code": "(fn [coll]\n  (loop [current-keyword nil result {} rst coll]\n    (if (empty? rst)\n        result\n        (if (keyword? (first rst))\n          (recur (first rst)\n                 (assoc result (first rst) [])\n                 (rest rst))\n          (recur current-keyword\n                 (assoc result\n                        current-keyword\n                        (conj (result current-keyword) (first rst)))\n                 (rest rst))))))", "problem": 105, "user": "4e7c8fd1535db169f9c796be"}, {"code": "(letfn [\n\n(run-length [lst]\n (count (take-while (complement keyword?) lst)))\n]\n\n(fn [lst]\n (loop [d {} lst lst]\n  (if (empty? lst) d\n   (let [symb (first lst) rst (rest lst) n (run-length rst)]\n    (recur\n     (assoc d symb (take n rst))\n     (drop (inc n) lst)))))))", "problem": 105, "user": "4e356d2b535deb9a81d77f2d"}, {"code": "(fn [kvs]\n  ((fn kvm [l r k]\n    (let [x (first l) xs (rest l)]\n      (cond\n        (empty? l) r\n        (keyword? x) (recur xs (assoc r x []) x)\n        :else (recur xs (assoc r k (conj (r k) x)) k)\n      )\n    )\n  ) kvs {} nil)\n)", "problem": 105, "user": "4e720985535d5021c1a89655"}, {"code": "(fn [coll]\n  (into {} \n    (map \n      (fn [[x y]][(first x) (if (nil? (first y)) [] y)])\n        (partition 2 (partition-by class (mapcat (fn [[x y]](if (and (keyword? x)(keyword? y))[x nil][x]))(partition 2 1 (conj coll 0))))))))", "problem": 105, "user": "4db2cc55535df7e46ed9b6c5"}, {"code": "(fn keyword-map [coll]\n  (first\n   (reduce\n    (fn [[a b] c]\n      (if (keyword? c)\n        [(conj a [c []]) c]\n        [(assoc a b (conj (get a b) c)) b]))\n    [{} nil]\n    coll)))", "problem": 105, "user": "4e7f51eb535db966e863cc3f"}, {"code": "(fn m [r]\n  (if (empty? r) {}\n  (loop [lk (first r), v [], m {}, l (next r)]\n    (if (empty? l) \n      (assoc m lk v)\n      (let [[n & r] l]\n        (if (keyword? n)\n          (recur n [] (assoc m lk v) r)\n          (recur lk (conj v n) m r)))))))", "problem": 105, "user": "4e7db3b4535db169f9c796e1"}, {"code": "(fn f [[k & s]]\n  (if k\n    (let [[n m] (split-with integer? s)]\n      (assoc (f m) k n))\n    {}))", "problem": 105, "user": "4e8612f8535db62dc21a62f2"}, {"code": "(fn [aseq]\n  (first\n    (reduce\n      (fn [[m k] i]\n        (if (integer? i)\n          [(update-in m [k] #(if (nil? %) [i] (conj % i))) k]\n          [(assoc m i []) i]))\n      [{} nil]\n      aseq)))", "problem": 105, "user": "4e7e05a6535db169f9c796fe"}, {"code": "(fn [coll]\n    (loop [res {} coll coll]\n      (if (empty? coll)\n        res\n        (let [key (first coll)\n              maybe-vals (rest coll)\n              [vals other] (split-with #(not (keyword? %)) maybe-vals)]\n          (recur (assoc res key vals) other)))))", "problem": 105, "user": "4e80aa10535db62dc21a62b1"}, {"code": "(fn [s]\n   (second\n    (reduce #(let [k (first %) a (second %)]\n               (if (keyword? %2)\n                 [%2 (assoc a %2 [])]\n                 [k (assoc a k (conj (a k) %2))]))\n            [nil {}]\n            s)))", "problem": 105, "user": "4e8510e7535db62dc21a62e7"}, {"code": "(fn [s]\n   (letfn [(add-val [m k v] (update-in m [k] conj v))]\n     (first (reduce (fn [[m k] v] (if (keyword? v) [m v] [(add-val m k v) k]))\n                    [(zipmap (filter keyword? s) (repeat [])) (first s)]\n                    (rest s)))))", "problem": 105, "user": "4e89f46c535d3e98b8023288"}, {"code": "(fn [s]\n  (->> s  (partition-by #(if (keyword? %) %))\n          (partition 2 1)\n          (map (fn [[[k] v]] (if (keyword? k)\n                                   (if (keyword? (first v)) \n                                        [k []]\n                                        [k  v]))))\n          (remove nil?)\n          (into {})))", "problem": 105, "user": "4e860e85535db62dc21a62f1"}, {"code": "(fn _ [c]\n  (if-let [[k & r] (seq c)]\n    (let [[x y] (split-with integer? r)]\n      (assoc (_ y) k x))\n    {}))", "problem": 105, "user": "4e71705e535d5021c1a89649"}, {"code": "(fn [xs]\n  (let [\n  impl (fn [xs acc]\n    (if-not (seq xs)\n      acc\n      (let [k (first xs)\n            [vs, tail] (split-with (comp not keyword?) (rest xs))]\n        (recur tail (assoc! acc k vs)))))\n  ]\n  (->> {}\n       (transient)\n       (impl xs)\n       (persistent!))))", "problem": 105, "user": "4e691c79535d8ccf87e9fe97"}, {"code": "(fn [l]\n  (loop [k (first l)\n         v (next l)\n         c []\n         ret {}]\n    (if v \n      (if (keyword? (first v))\n        (recur (first v) (next v) [] (assoc ret k c))\n        (recur k (next v) (conj c (first v)) ret))\n      (if k\n        (assoc ret k c)\n        ret))))", "problem": 105, "user": "4e8e8c24535d65386fec2143"}, {"code": "#(first (reduce \n  (fn [[ret k] x]\n      (if (keyword? x)\n        [(assoc ret x []) x]\n        [(assoc ret k (conj (get ret k []) x)) k])) [{} nil] %))", "problem": 105, "user": "4e6a5f5c535d8ccf87e9fed6"}, {"code": "(fn [xs]                                         \r\n  (let [[hold acc] (reduce (fn [[hold acc] x]         \r\n                      (if (keyword? x)\r\n                        [[x] (when-not (empty? hold)\r\n                               (assoc acc (first hold) (rest hold)))]\r\n                                       [(conj hold x) acc]))\r\n                    [nil {}] xs)]\r\n    (if (empty? hold)\r\n      acc\r\n      (assoc acc (first hold) (rest hold)))))", "problem": 105, "user": "4e8681b7535dae1a5effa438"}, {"code": "(fn f [[k & v]]\r\n  (if v\r\n    (let [[a b] (split-with number? v)]\r\n      (assoc (f b) k a))\r\n    {}))", "problem": 105, "user": "4db858d1535d1e037afb218c"}, {"code": "(fn ikv[s]\n          (loop [a {} b s]\n             (if (empty? b)\n                 a\n                 (let [k (first b)\n                      [n r] (split-with number? (rest b))]\n                      (recur (conj a [k n]) r)))))", "problem": 105, "user": "4e842ebb535db62dc21a62df"}, {"code": "(fn [s]\n       (if (empty? s) (hash-map)\n     (reduce merge\n  \t   (map #(assoc (hash-map) (first %) (or (next %) []))\n\t\t\t(map flatten\n\t\t\t     (partition 2\n\t\t\t\t\t(map #(remove (fn [c] (= c \\_)) %)\n\t\t\t\t\t     (partition-by keyword? (interpose \\_ s)))))))))", "problem": 105, "user": "4e949d18535dbda64a6f6b15"}, {"code": "(fn [p] (into {} \n  (loop [l p r []] \n    (if (empty? l) \n    r \n    (let [[a b] (split-with number? (rest l))]\n      (recur b (conj r [(first l) a])))))))", "problem": 105, "user": "4dae916eedd6309eace4d155"}, {"code": "(fn [coll]\n  (reduce\n    (fn [mp it]\n      (if (keyword? it)\n        (assoc mp it [])\n        (let [k (last (keys mp))]\n          (assoc mp k (conj (mp k) it)))))\n    (sorted-map)\n    coll))", "problem": 105, "user": "4dfe65a1535d04ed9115e787"}, {"code": "(fn accrue ([accruer current-key remainder]\n (if (empty? remainder) \n     accruer\n     (let [next-elem (first remainder)\n           is-key    (keyword? next-elem)\n           residue   (rest remainder)]\n\n        (if is-key \n          (recur (assoc accruer next-elem []) next-elem residue)\n          (let [current-value (get accruer current-key)\n                new-value (conj current-value next-elem)]\n            (recur (assoc accruer current-key new-value) current-key residue))))))\n\n  ([coll] (accrue {} (first coll) coll)))", "problem": 105, "user": "4e6defcc535d5021c1a895f8"}, {"code": "(fn f [[x & s :as c]]\n  (if (seq c)\n   (let [[a b] (split-with number? s)]\n     (merge {x a} (f b)))\n   {}))", "problem": 105, "user": "4e8f1ac6535d65386fec2146"}, {"code": "(fn map-by-keywords\n  [coll]\n  (letfn [(map-by-keywords' [coll]\n            (when-let [s (seq coll)]\n              (let [[x & xs] s]\n                (cons [x (take-while number? xs)]\n                      (lazy-seq (map-by-keywords' (drop-while number? xs)))))))]\n    (into {} (map-by-keywords' coll))))", "problem": 105, "user": "4dc0ff08535d020aff1edf84"}, {"code": "(fn f [[h & t]]\n  (into {}\n    (if h\n      (let [[y z] (split-with number? t)]\n        (cons [h y]\n              (f z))))))", "problem": 105, "user": "4e96557d535dbda64a6f6b43"}, {"code": "(fn mapize\r\n  [lista]\r\n\t(if (empty? lista)\r\n\t\t{}\r\n\t\t(conj (mapize (drop-while #(not (keyword? %)) (rest lista)))\r\n\t\t\t\t\t[(first lista) (take-while #(not (keyword? %)) (next lista))])))", "problem": 105, "user": "4e8a0c82535d3e98b802328d"}, {"code": "#(loop [[k & y] % r {}]\n  (if k\n    (let [[a b] (split-with number? y)]\n      (recur b\n             (assoc r k a)))\n    r))", "problem": 105, "user": "4e823ed7535db62dc21a62c7"}, {"code": "(fn [args]\n  (let [m (apply hash-map (map #(filter (complement nil?) %)\n                               (partition-by keyword?\n                                             (interpose nil args))))\n        ks (keys m)\n        vs (vals m)]\n    (zipmap (map first ks) (map #(apply vector %) vs))))", "problem": 105, "user": "4e9fd521535d7eef3080729a"}, {"code": "(fn [s] \n  (apply hash-map (mapcat #(if (keyword? (first %))                       \n                               (interpose () %)\n                               (list %))\n                          (partition-by keyword? s))))", "problem": 105, "user": "4ea1b9e4535d7eef308072b8"}, {"code": "(fn f [s]\n  (letfn [(k [s r] (if (seq s)\n                     (v (rest s) (conj r (first s)))\n                     r))\n          (v [s r] (let [[p q] (split-with (complement keyword) s)]\n                     (k q (conj r p))))]\n    (apply hash-map (k s []))))", "problem": 105, "user": "4ea41fc2535d7eef308072cb"}, {"code": "#(letfn [(cmap [s m k]\n  (if (empty? s)\n    m\n    (let [\n      f (first s)\n      kw (if (keyword? f) f k)]\n      (recur (rest s) (assoc m kw (if (keyword? f) [] (conj (m k) f))) kw))))]\n  (cmap % {} nil))", "problem": 105, "user": "4e8f4f64535d65386fec2149"}, {"code": "(fn [s]\n  (first (reduce\n    (fn [[m last] v]\n     (if (keyword? v)\n       [(assoc m v []) v]\n       [(update-in m [last] conj v) last]))\n    [{} nil]\n    s)))", "problem": 105, "user": "4dbad895535d1e037afb21ae"}, {"code": "(fn [v]\n(apply hash-map\n(map #(if (keyword? (first %)) (first %) \n          (keep identity %))\n(partition-by keyword? (interpose nil v)))))", "problem": 105, "user": "4dcfbc44535d5973398f92a7"}, {"code": "(fn xf [c] \n  (loop [[f & m :as d] c k nil r {}]\n    (if (seq d)\n      (if (keyword? f) \n        (recur m f (assoc r f []))\n        (recur m k (update-in r [k] conj f)))\n      r)))", "problem": 105, "user": "4e50e2a0535dc968683fc4ef"}, {"code": "(fn id-keys-and-vals [coll]\r\n  (->> coll\r\n       (partition-by keyword?)\r\n       (mapcat #(if (keyword? (first %)) (interpose [] %) [%]))\r\n       (apply hash-map)))", "problem": 105, "user": "4e994541535dbda64a6f6b64"}, {"code": "#(let [[x y z]\n  (reduce (fn [[w x y] z] \n            (cond \n              (and w (keyword? z)) [z [] (assoc y w x)]\n              (and (keyword? z)) [z [] y]\n               :else  [w (conj x z) y])) \n     [nil [] {}] %1)]\n  (if x (assoc z x y) {}))", "problem": 105, "user": "4dbdab4e535d020aff1edf49"}, {"code": "(fn f105 [coll]\n  \"identify keys and values\n   (= {:a [1 2 3], :b [], :c [4]} (__ [:a 1 2 3 :b :c 4]))\"\n  (if (empty? coll)\n    {}\n    (loop [xs (rest coll)\n           ckey (first coll)\n           cvec []                 \n           m {}]\n      (if (empty? xs)\n        (assoc m ckey cvec)\n        (let [h (first xs)]\n          (if (keyword? h)\n            (recur (rest xs) h [] (assoc m ckey cvec))\n            (recur (rest xs) ckey (conj cvec h) m)))))))", "problem": 105, "user": "4e88feef535d8b9bb0147ca8"}, {"code": "#(loop [acc {} [h & t :as data] % c-key nil]\n    (if (empty? data)\n        acc\n        (if (keyword? h)\n          (recur (assoc acc h []) t h)\n          (recur (assoc acc c-key (conj (c-key acc) h))\n                 t c-key))))", "problem": 105, "user": "4e68b46c535d8ccf87e9fe87"}, {"code": "(fn f [coll]\n  (loop [coll coll res {} k nil]\n    (if (seq coll)\n      (let [e (first coll)]\n        (if (keyword? e)\n          (recur (rest coll) (assoc res e []) e)\n          (recur (rest coll) \n            (assoc res k (conj (res k) e)) k)))\n      res)))", "problem": 105, "user": "4dbd2aa3535d020aff1edf40"}, {"code": "#(loop [[k & s] % m {}]\r\n  (if k\r\n    (recur (drop-while number? s)\r\n      (assoc m k (take-while number? s)))\r\n    m))", "problem": 105, "user": "4eb97b2e535dfed6da9c6d54"}, {"code": "(fn [x]\n  (if-not (first x)\n    {}\n  (loop [data x cur-data [] type :type res {}]\n    (if-not (first data)\n      (do \n      (assoc res type cur-data)\n;      res)\n  )\n      (if (and (keyword? (first data)) (keyword? (fnext data)))\n  (do\n\t  (assoc res type cur-data)\n\t(recur (rest data) [] (first data) (assoc (assoc res type cur-data) (first data) []))\n\t)\n\t(if (and (keyword? (first data)) (= 0 (count cur-data)))\n\t  (recur (rest data) [] (first data) res)\n\t  (if-not (keyword? (first data))\n\t    (recur (rest data) (conj cur-data (first data)) type res)\n\t    (recur (rest data) [] (first data) (assoc res type cur-data)))))))))", "problem": 105, "user": "4eb0afed535d7eef3080733e"}, {"code": "(fn [s]\n  (loop [s (seq s) r {} k nil]\n    (println \"s: \" s \"r: \" r \"k: \" k)\n    (if s\n      (if (keyword? (first s))\n        (recur (next s) (assoc r (first s) []) (first s))\n        (recur (next s) (assoc r k (conj (k r) (first s))) k))\n      r)))", "problem": 105, "user": "4dbdc9da535d020aff1edf4c"}, {"code": "(fn [lat]\n  (let [f (fn [lat k lastk vals m]\n\t\t        (let [frst (first lat)]\n\t\t          (cond\n\t\t           (empty? lat) (if (nil? lastk)\n\t\t\t\t                      m\n\t\t\t\t                      (conj m [lastk vals]))\n\t\t           (keyword? frst) (if (or (= frst lastk) (nil? lastk))\n\t\t\t\t\t                      (recur (rest lat) frst frst vals m)\n\t\t\t\t\t                      (recur (rest lat) frst frst [] (conj m [lastk vals])))\n\t\t           :else (recur (rest lat) k k (conj vals frst) m))))]\n\t  (f lat nil nil [] {})))", "problem": 105, "user": "4db045b5838c48654951d9be"}, {"code": "(fn [coll]\n  (apply hash-map\n    (mapcat\n      #(if (keyword? (first %1))\n        (interpose [] %1)\n        [%1])\n      (partition-by keyword? coll))))", "problem": 105, "user": "4ec2fe3f535dcc7ae8597d4f"}, {"code": "#(loop [s %, r {}]\n  (if (seq s)\n    (recur (drop-while number? (rest s)), (assoc r (first s) (take-while number? (rest s))))\n    r))", "problem": 105, "user": "4e82f85d535db62dc21a62ce"}, {"code": "(fn ident[ a ]\n  (loop [c (first a)\n              l (rest a)\n              m {}\n              last nil ]\n    (cond\n      (= nil c) m\n      (= (type c) clojure.lang.Keyword ) (recur (first l) (rest l) (assoc m c []) c)\n      :else \n        (recur (first l) (rest l) (assoc m last (conj (m last) c)) last)\n    )\n  )   \n)", "problem": 105, "user": "4e9de526535dbda64a6f6b8e"}, {"code": "(fn [v]\n  (let [iskey (fn [v] (= clojure.lang.Keyword  (class v)) )]\n   (loop [result {} currentkey (first v) currentv [] data (rest v) ]\n    (if (empty? data)\n       (if currentkey (conj result [currentkey currentv]) result)\n       (let [next_is_key (iskey (first data))]\n          (recur (if next_is_key\n                    (conj result [currentkey currentv])\n                    result)\n                 (if next_is_key  (first data) currentkey)\n                 (if next_is_key  [] (conj currentv (first data) ))\n                 (rest data)\n            ))))))", "problem": 105, "user": "4ec5bec6535d6d7199dd36b3"}, {"code": "(fn [s]\n  (loop [m {} s s]\n    (println s)\n    (if\n     (empty? s) m\n     (let [[kw & s] s\n           [vs s] (split-with number? s)]\n       (recur (assoc m kw (vec vs)) s)))))", "problem": 105, "user": "4ed188c8535d44c135fd68cf"}, {"code": "(fn [s]\n  (loop [acc {} s s]\n    (if (seq s)\n        (let [k (first s) r (rest s)]\n        (recur (assoc acc k (into [] (take-while #(= java.lang.Integer (class %)) r)))\n               (drop-while #(= java.lang.Integer (class %)) r)))\n        acc)))", "problem": 105, "user": "4eb0a757535d7eef3080733d"}, {"code": "reduce #(if (keyword? %2) (merge {%2 []} %) (merge-with conj % {(last (keys %)) %2}) ) {}", "problem": 105, "user": "4ec0c7ba535dfed6da9c6da4"}, {"code": "(fn f [s]\n    (if\n     (empty? s) {}\n     (let\n         [[k & r] s\n          [v n] (split-with #(not ( keyword? %)) r)]\n       (assoc (f n) k v))))", "problem": 105, "user": "4e6f578c535d5021c1a8961b"}, {"code": "(fn kv-er [s]\n  (if (seq s)\n    (assoc\n      (kv-er (drop-while (complement keyword?) (rest s)))\n      (first s)\n      (take-while (complement keyword?) (rest s)))\n    {}))", "problem": 105, "user": "4db1b3951254ad5b4805fa6f"}, {"code": "#(loop [m {} c %]\n   (if (empty? c) m\n     (let [k (first c)\n           [v xs] (split-with (comp not keyword?) (rest c))]\n       (recur (assoc m k v) xs))))", "problem": 105, "user": "4ec16c21535dfed6da9c6dac"}, {"code": "#(loop [x % k nil m {}]\n  (if (empty? x)\n    m\n    (let [n (first x)]\n      (if (keyword? n)\n        (recur (rest x) n (merge m {n []}))\n        (recur (rest x) k (merge-with conj m {k n}))))))", "problem": 105, "user": "4ed94d69535d10e5ff6f5303"}, {"code": "(fn f105 [coll]\n  ((fn [m collp currkey currval]\n     (if (seq collp)\n       (let [v (first collp)]\n         (if (keyword? v)\n           (recur (if (nil? currkey) m (conj m [currkey currval]))\n                  (rest collp)\n                  v\n                  [])\n           (recur m\n                  (rest collp)\n                  currkey\n                  (conj currval v))))\n       (if (nil? currkey) m (conj m [currkey currval]))))\n     {} coll nil []))", "problem": 105, "user": "4ec75077535d6d7199dd36e0"}, {"code": "(fn [coll]\n  (loop [result {}, coll coll]\n    (if (empty? coll)\n      result\n      (recur (conj result [(first coll) (take-while (complement keyword?) (rest coll))])\n             (drop-while (complement keyword?) (rest coll))))))", "problem": 105, "user": "4edab806535d10e5ff6f5311"}, {"code": "(fn mappack [acoll]\n  (if (empty? acoll) {}\n      (let [[key & others] acoll,\n            [val rest] (split-with #(not (keyword? %)) others)]\n        (assoc (mappack rest)\n               key\n               val))))", "problem": 105, "user": "4eb9ce75535dfed6da9c6d5e"}, {"code": "#(into {} \n        (reduce \n          (fn [m v]      \n            (if (keyword? v)\n              (conj m [v []])\n              (let [[k ys] (last m)] \n                (conj (vec (butlast m)) \n                      [k (conj ys v)]))))\n          [] %))", "problem": 105, "user": "4e513758535dc968683fc4f3"}, {"code": "(fn keys&vals [coll] \n  (if (empty? coll) \n    {} \n    (loop [kw (first coll), vs [], result {}, more (rest coll)]\n      (cond \n        (empty? more)\n          (assoc result kw vs)\n        (keyword? (first more))\n          (recur (first more) [] (assoc result kw vs) (rest more))\n        :else\n          (recur kw (conj vs (first more)) result (rest more))))))", "problem": 105, "user": "4e7263a1535d5021c1a8965f"}, {"code": "#(apply hash-map \n  (reduce \n    (fn [r x] \n      (if (keyword? x) \n        (conj r x [])\n        (assoc r (dec (count r)) (conj (last r) x)))) \n    [] %1))", "problem": 105, "user": "4eb51942535d7eef30807365"}, {"code": "#(letfn [(d [m [[a] b  & r]] \n          (if (seq r) \n              (if (keyword (first b)) \n                  (d (assoc m a []) (cons b r)) \n                  (d (assoc m a b) r)) \n              (if (nil? a) m (assoc m a b))))] (d {} (partition-by keyword %)))", "problem": 105, "user": "4ede8789535d10e5ff6f5337"}, {"code": "(fn parse-keyed-map[xs]\r\n  ((fn[acc [token & tokens]]\r\n     (if(empty? tokens)\r\n       acc\r\n       (recur\r\n  (assoc acc token (take-while(complement keyword?)tokens))\r\n\t(drop-while(complement keyword?) tokens))))\r\n   {} xs))", "problem": 105, "user": "4edeac6b535d10e5ff6f533a"}, {"code": "(fn [coll]\n  (first\n   (reduce (fn [[m k] e]\n             (if (keyword? e)\n               [(assoc m e []) e]\n               [(update-in m [k] conj e) k])) [{} nil] coll)))", "problem": 105, "user": "4e89ff3d535d3e98b802328a"}, {"code": "(fn [l]\n  (let [[m kw v] (reduce (fn [[m kw v] e]\n                    (if (keyword? e)\n                        [(if (nil? kw) m (assoc m kw v)) e []]\n                        [m kw (conj v e)]))\n                  [{} nil []]\n                  l)]\n    (if (not (nil? kw)) (assoc m kw v) m)))", "problem": 105, "user": "4ede8e1d535d10e5ff6f5339"}, {"code": "(fn [v]\n  (loop [v v\n         res {}]\n    (if-not (seq v)\n      res\n      (let [key (first v)\n            val (vec (take-while number? (rest v)))]\n        (recur (drop-while number? (rest v))\n               (assoc res key val))))))", "problem": 105, "user": "4e59b02c535d8a8b8723a2a2"}, {"code": "#(second (reduce (fn [[k m] x]\n                   (if (keyword? x)\n                       [x (assoc m x [])]\n                       [k (assoc m k (conj (m k) x))]))\n                 [nil {}]\n                 %))", "problem": 105, "user": "4ee3b586535d10e5ff6f5371"}, {"code": "(fn [s]\n  (let [c (partition-by keyword? (interpose () s))\n        c1 (flatten (remove #(= (first %) ()) c))\n        c2 (map flatten (remove #(keyword? (first %)) c))]\n    (zipmap c1 c2)))", "problem": 105, "user": "4e9519b4535dbda64a6f6b2d"}, {"code": "(fn [s]\n  (second (reduce (fn [[k m] x]\n    (if (integer? x)\n      [k (assoc m k (conj (get m k) x))]\n      [x (assoc m x [])])\n  ) [nil {}] s)))", "problem": 105, "user": "4ebc08a8535dfed6da9c6d7c"}, {"code": "(fn [s] (into {} \n  (->> s\n    (partition-by type)\n    (partition 2)\n    (mapcat (fn [[k v]] \n      (concat (map (fn [x] [x []]) (butlast k)) \n              [[(last k) v]]))))))", "problem": 105, "user": "4ee7ef87535d93acb0a66872"}, {"code": "(fn [s] (let [x (partition-by keyword? s)] ((fn f ([a k r] (if (empty? a) r (let [e (first a)] (if (keyword? (first e)) (f (rest a) (last e) (reduce #(assoc %1 %2 []) r e)) (f (rest a) nil (assoc r k (first a)))))))) x nil {})))", "problem": 105, "user": "4eb13d60535d7eef3080733f"}, {"code": "#(if (empty? %2)\n    %\n    (let [[v t] (split-with number? (rest %2))]\n      (recur (assoc % (first %2) v) t))) {}", "problem": 105, "user": "4e1350af535d04ed9115e7d8"}, {"code": "(fn [x] (loop [s x res {}]\n                                         (if (empty? s)\n                                           res\n                                           (let [fp (split-with #(number? %)\n                                                              (rest s))\n                                               sp (drop-while #(number? %)\n                                                              (rest s))]\n                                           (recur sp (conj res [(first s)\n                                              (first fp)]))))))", "problem": 105, "user": "4ebef65e535dfed6da9c6d9b"}, {"code": "(fn grp [[fst & rs :as sq]]\r\n  (let [pred #(not (keyword? %))]\r\n    (if (empty? sq)\r\n      {}\r\n      (reduce conj {}\r\n        (cons [fst (take-while pred rs)]\r\n          (grp (drop-while pred rs)))))))", "problem": 105, "user": "4ee40938535d10e5ff6f5375"}, {"code": "(fn func [[k & n]]\n  (if k\n    (let [[vs ns] (split-with #(false? (keyword? %)) n)]\n      (assoc (func ns) k vs))\n  {}))", "problem": 105, "user": "4ee82223535d93acb0a66877"}, {"code": "(fn [coll]\n  (if (seq coll)\n    (loop [coll coll\n            keyword (first coll)\n            acc {}]\n      (if (seq coll)\n        (if (keyword? (first coll))\n            (recur (rest coll)\n                    (first coll)\n                    (assoc acc (first coll) []))\n            (recur (rest coll)\n                    keyword\n                    (assoc\n                      acc\n                      keyword\n                      (conj (keyword acc) (first coll)))))\n        acc))\n    {}))", "problem": 105, "user": "4eda7cc3535d10e5ff6f530e"}, {"code": "(fn f [m [h & t]]\n  (if h\n    (f (assoc m h (take-while number? t)) (drop-while number? t))\n    m))\n{}", "problem": 105, "user": "4ee82539535d93acb0a66878"}, {"code": "(fn [s] \n  (loop [m {} l s] \n    (if (empty? l) \n        m \n        (let [[a & b] l [c d] (split-with number? b)] \n          (recur (assoc m a c) d)))))", "problem": 105, "user": "4e6dc95a535d5021c1a895f1"}, {"code": "#(loop [m {} c %]\n    (let [d (next c) [n r] (split-with number? d)]\n      (if d\n        (recur (assoc m (first c) n) r)\n        m)))", "problem": 105, "user": "4e65027c535d8ccf87e9fe6e"}, {"code": "(fn f [a k [h & t]]\n    (if h\n      (if (keyword? h)\n        (f (assoc a h []) h t)\n        (f (assoc a k (conj (a k) h)) k t))\n      a)) \n{} 0", "problem": 105, "user": "4ef49c2c535dced4c769f238"}, {"code": "(fn f\n    ( [c] (f c []) )\n    ([[a & r] s]\n        (if a\n            (if (keyword? a)\n                (f r (conj s [a []] ))\n                (let [[k v] (last s)\n                      w     (conj v a)\n                      i   (dec (count s))]\n                  (f r (assoc s i [k w])) ))\n            (into {} s)) ) )", "problem": 105, "user": "4ee7d177535d93acb0a6686f"}, {"code": "(fn [s]\n  (reduce\n    (fn [acc n]\n      (let [[k v] n\n            acc2 (reduce\n              (partial apply assoc) acc\n                (map (fn [k] [k []]) (butlast k)))]\n      (assoc acc2 (last k) v)))\n    {}\n    (partition 2\n      (partition-by keyword? s))))", "problem": 105, "user": "4eb2e6ca535d7eef3080734f"}, {"code": "(fn [s]\n    (->> [nil s]\n     (iterate (fn [[_ [k & vs]]]\n                (let [[v1 v2] (split-with (complement keyword?) vs)]\n                  [[k v1] v2])))\n\n     (drop 1)\n     (take-while ffirst)\n     (map first)\n     (map (partial conj {}))\n     (reduce (partial merge-with concat) {})))", "problem": 105, "user": "4e6a0667535d8ccf87e9fe9e"}, {"code": "(fn identify-keys-and-values\n  [coll]\n  (let [k (into #{} (filter keyword? coll))\n        p (partition-by k coll)]\n    (loop [p p\n           mp {}]\n      (if (empty? p)\n        mp\n        (if (and (keyword? (ffirst p)) (not (keyword? (first (second p)))))\n         (recur (drop 2 p) (assoc mp (ffirst p) (apply vector (second p))))\n         (recur (drop 1 p) (assoc mp (ffirst p) [])))))))", "problem": 105, "user": "4e3bcccd535deb9a81d77f56"}, {"code": "(fn [c]\n  (let [\n    res (reduce #(assoc % (last (first %2)) (second %2))\n      {}\n      (partition 2 (partition-by keyword? c)))\n    diff (clojure.set/difference \n      (set (filter keyword? c))\n      (set (keys res)))]\n    (merge\n      (reduce #(assoc % %2 []) {} diff)\n      res)))", "problem": 105, "user": "4e9c81e8535dbda64a6f6b80"}, {"code": "(fn m-from-flat [xs]\n  (if (seq xs)\n    (let [[k & more] xs,\n          [nums more] (split-with (complement keyword?) more)]\n      (merge {k nums} (m-from-flat more)))\n    {}))", "problem": 105, "user": "4edecdae535d10e5ff6f533c"}, {"code": "#(loop [remaining %, key nil, result {}]\n  (if-let [[x & xs] (seq remaining)]\n    (cond\n     (keyword? x) (recur xs x (conj result [x []]))\n     (number? x) (recur xs key (merge-with conj result {key x})))\n    result))", "problem": 105, "user": "4ec5aa1f535d6d7199dd36b0"}, {"code": "(fn [coll]\n    (loop [m {} c (rest coll) k (first coll) vs []]\n      (if (empty? c)\n        (if (nil? k)\n          m\n          (merge m {k vs}))\n        (let [x (first c)]\n          (if (keyword? x)\n            (recur (merge m {k vs}) (rest c) x [])\n            (recur m (rest c) k (conj vs x)))))))", "problem": 105, "user": "4dc29a1d535d020aff1edf96"}, {"code": "(fn m [s]\n  (letfn [(a [s1 m] (assoc m (first s1) (take-while #(not (keyword? %)) (rest s1))))\n          (r [s2 m] (if (seq s2) (a s2 (r (drop-while #(not (keyword? %)) (rest s2)) m)) m))]\n (r s {})))", "problem": 105, "user": "4ea1ecfa535d7eef308072bb"}, {"code": "#(loop [m {} s %]\n    (println m)\n    (println s)\n    (if (empty? s)\n      m\n      (recur (assoc m (first s) (take-while (complement keyword?) (rest s)))\n             (drop-while (complement keyword?) (rest s)))))", "problem": 105, "user": "4df3df8a535d08e6dec9fe2d"}, {"code": "(fn key-vals-map [v]\n        (loop [[a & b] v m {}]\n          (if (nil? a)\n            m\n            (let [[p q] (split-with (complement keyword?) b)]\n              (recur q (conj m [a p]))))))", "problem": 105, "user": "4f031eac535dcb61093f6a67"}, {"code": "(fn [s]\n  (dissoc (reduce #(if (keyword? %2) (assoc %1 0 %2 %2 []) (update-in %1 [(%1 0)] conj %2)) {} s) 0))", "problem": 105, "user": "4effb663535dcb61093f6a2e"}, {"code": "(fn [s]\n    (loop [s s d {}]\n      (if (empty? s)\n        d\n        (let [k (first s)\n              [v r] (split-with number? (rest s))]\n         (recur r (assoc d k v))))))", "problem": 105, "user": "4ed292ac535d44c135fd68d9"}, {"code": "(fn h [l]  \n (let [g (fn g [mapa lista]\n  (if (empty? lista) mapa\n    (let [k (first lista)\n          v (vec (take-while (complement keyword?) (rest lista)))\n          vv (drop-while (complement keyword?) (rest lista))]               \n      (g (assoc mapa k v) vv))))]\n      (g {} l)))", "problem": 105, "user": "4f04a06d535dcb61093f6bd9"}, {"code": "(partial \n(fn x [m k l]\n  (let [[n r] (split-with number? l)]\n    (if (pos? (count l))\n      (if k\n        (x (assoc m k n) nil r)\n        (x m (first l) (rest l)))\n      m))) \n{} \nnil )", "problem": 105, "user": "4e6ebd4a535d5021c1a89610"}, {"code": "#(into {} \n  (map vec \n    (partition 2 \n      (reduce (fn [a b]\n  (if (= (type b) (type 1))\n    (conj (vec (butlast a)) (conj (last a) b))\n    (concat a [b []])\n  )) [] %))))", "problem": 105, "user": "4f01c938535dcb61093f6a39"}, {"code": "(fn [v]\n  (loop [r {},a v,k nil]\n\t   (if (empty? a) r\n\t       (if (keyword? (first a))\n\t\t\t (recur (assoc r (first a) []) (next a) (first a))\n\t\t\t (recur (assoc r k (conj (r k) (first a))) (next a) k)))))", "problem": 105, "user": "4ec5d62c535d6d7199dd36ba"}, {"code": "(fn [s] \n  (apply hash-map \n    (mapcat \n      #(if (= clojure.lang.Keyword (type (first %))) \n        (interpose () %) \n        [%]) \n      (partition-by type s))))", "problem": 105, "user": "4f04b66b535dcb61093f6bdd"}, {"code": "(fn [v] (first\n          (reduce (fn [[r curr] i] (if (keyword? i)\n                                    [(assoc r i []) i]\n                                    [(update-in r [curr] #(conj % i)) curr]))\n                  [{}] v)))", "problem": 105, "user": "4ee88bfb535d93acb0a66881"}, {"code": "(fn prob-0105\n  [sq]\n  (loop [s (seq sq), m {}]\n    (if (empty? s)\n      m\n      (let [k    (first (take 1 s))\n            vs   (take-while #(not= clojure.lang.Keyword (type %)) (rest s))\n            nkvs (inc (count vs))]\n        (recur (drop nkvs s) (assoc m k vs))))))", "problem": 105, "user": "4f047c07535dcb61093f6bcd"}, {"code": "#(reduce \n  (fn [m [ks es]]\n    (let [[k & ks] (reverse ks)]\n      (merge (assoc m k es)\n        (into {} (for [k ks] [k []])) )))\n  {}\n  (partition 2 2 [] (partition-by keyword? %)))", "problem": 105, "user": "4f06dcad535dcb61093f6c16"}, {"code": "#(apply merge {} (\n                      (fn g [ [h & t] ]\n                       (if h\n                           (let [v (take-while number? t)]\n                                (lazy-seq (cons {h v} (g (drop (count v) t)))))))\n                      %))", "problem": 105, "user": "4db8f6c4535d1e037afb219e"}, {"code": "(fn [v]\n  (apply hash-map (reverse\n    (reduce\n      (fn [ret i]\n        (if (keyword? i)\n          (conj ret i [])\n          (conj (rest ret) (conj (first ret) i))))\n      '()\n      v))))", "problem": 105, "user": "4f050dec535dcb61093f6bef"}, {"code": "(comp\n  (partial apply hash-map)\n  (partial mapcat\n    #(if (keyword? (first %))\n        (interpose [] %)\n        [%]))\n  (partial partition-by keyword?))", "problem": 105, "user": "4f03ac2d535dcb61093f6b4a"}, {"code": "(fn [ss]\n     (loop [s (rest ss) r {} k (first ss) v []]\n       (if (empty? s) (if (nil? k) {} (assoc r k v))\n           (if (number? (first s))\n               (recur (rest s) r k (conj v (first s)))\n               (recur (rest s) (assoc r k v) (first s) [])))))", "problem": 105, "user": "4e8b98fc535d65386fec2124"}, {"code": "#(loop [k [] v [] rs %]\n    (if (seq rs)\n      (recur (conj k (first rs))\n             (conj v (vec (take-while (complement keyword?) (rest rs))))\n             (drop-while (complement keyword?) (rest rs)))\n      (zipmap k v)))", "problem": 105, "user": "4e1f9bb5535d04ed9115e80d"}, {"code": "(fn identify-keys-and-values [l]\r\n    (loop [s (seq l) result {} curkey nil curval []]\r\n      (if (empty? s)\r\n        (if (nil? curkey)\r\n          result\r\n          (assoc result curkey curval))\r\n        (if (keyword? (first s))\r\n          (if (nil? curkey)\r\n            (recur (rest s) result (first s) [])\r\n            (recur (rest s) (assoc result curkey curval) (first s) []))\r\n          (recur (rest s) result curkey (conj curval (first s)))))))", "problem": 105, "user": "4f039524535dcb61093f6b2c"}, {"code": "#(dissoc \n   (reduce\n    (fn [m e]\n      (if (keyword? e)\n        (assoc m e [] :last e)\n        (assoc m (m :last) (conj (m (m :last)) e))))\n    (sorted-map)\n    %) :last)", "problem": 105, "user": "4ee9ddb8535d93acb0a66896"}, {"code": "(fn create-map\n\t[v] (loop [[key & remaining] v m {}]\n\t\t(if key\n\t\t\t(recur (drop-while number? remaining) (assoc m key (vec (take-while number? remaining))))\n\t\t\tm))\n)", "problem": 105, "user": "4f047542535dcb61093f6bc7"}, {"code": "(fn [coll]\n  (reduce (fn [m [ks vs]]\n            (-> (assoc m (last ks) vs)\n                (into ,,, (map #(vector % []) (drop-last ks)))))\n          {}\n          (->> (partition-by keyword? coll)\n               (partition 2))))", "problem": 105, "user": "4daec9dcedd6309eace4d15f"}, {"code": "(fn [vals] (apply hash-map (reduce \n  (fn [acc e] (if (keyword? e) \n              (conj (conj acc e) [])\n              (conj (vec (drop-last acc)) (conj (last acc) e))))\n  [] vals)))", "problem": 105, "user": "4f13047d535d64f60314642c"}, {"code": "(fn I [c]\n    (if (empty? c) {}\n        (let [P #(not (keyword? %))\n              r (rest c)]\n          (merge {(first c) (take-while P r)}\n                 (I (drop-while P r))))))", "problem": 105, "user": "4f0ef874535d0136e6c22328"}, {"code": "#((fn ! [m k [f & r]]\n  (if f\n    (if (keyword? f)\n      (! (into m {f []}) f r)\n      (! (into m {k (conj (m k []) f)}) k r))\n    m)) {} (first %) (rest %))", "problem": 105, "user": "4f036d9b535dcb61093f6ac1"}, {"code": "(fn keys-and-vals\n [kv]\n (letfn [(partition* [f v]\n    (lazy-seq\n    (when-let [s (seq v)]\n    (cons \n      [(first s) (take-while f (rest s))]\n      (partition* f (drop-while f (rest s)))))))]\n        (into {} (partition* #(= java.lang.Integer (type %)) kv))))", "problem": 105, "user": "4edf5dc6535d10e5ff6f5340"}, {"code": "(fn kv-pairs [xs]\n    (if (empty? xs)\n        '{}\n        (let [\n            key (first xs)\n            [vals ls] (split-with #(= Integer (type %)) (rest xs))]\n        (assoc (kv-pairs ls) key (apply vector vals))))\n)", "problem": 105, "user": "4f0e995e535d0136e6c22326"}, {"code": "(fn [coll]\n  ((fn [coll acc]\n    (if (seq coll)\n      (let [ good (drop-while #(not (keyword? %)) coll)\n         kw (first good)\n         [nums tail] \n           (split-with #(not (keyword? %)) (next good))\n         ]\n         (recur tail (assoc acc kw (vec nums))))\n       acc)\n  )\n  coll {})\n)", "problem": 105, "user": "4f03154a535dcb61093f6a58"}, {"code": "(fn keys-and-values [x]\n  (let [cx (mapcat\n      #(if (keyword? (first %))\n         (interpose\n           '()\n           (partition-all 1 %))\n         (list %))\n       (partition-by\n         keyword?\n         x))]\n    (zipmap (map first (filter #(keyword? (first %)) cx)) (filter #(not (keyword? (first %))) cx))))", "problem": 105, "user": "4ea7999e535d7eef308072ee"}, {"code": "(fn [xs]\n  (let [with-vector (mapcat #(if (keyword? %) (list % []) (list %)) xs)\n        grouped-up (partition 2 (partition-by keyword? with-vector))\n        ready (mapcat #(list (first (first %)) (into (first (second %)) (rest (second %)))) grouped-up)]\n    (apply hash-map ready)))", "problem": 105, "user": "4ec07699535dfed6da9c6da2"}, {"code": "(fn mykv [xs]\n    (let [hm\n        (reduce\n        (fn [h r]\n            (let [k (h :key), v (h :vals), o (h :out)]\n                (println \"key=\"k \", vals=\"v \", out=\"o \", r=\"r)\n                (if (keyword? r)\n                    (if (keyword? k)\n                        (assoc h :out (assoc o k v) :vals [] :key r)\n                        (assoc h :key r :vals []))\n                    (assoc h :vals (into v (list r))))))\n            {:key nil :vals [] :out {}} (conj xs :end))]\n        (hm :out)))", "problem": 105, "user": "4f128865535d64f603146428"}, {"code": "(fn [coll]\n    (loop [coll coll\n           key nil\n           m {}]\n      (let [val (first coll)]\n        (cond (empty? coll) m\n              (keyword? val) (recur (next coll) val (assoc m val []))\n              :else (recur (next coll) key (assoc m key (conj (get m key) val)))))))", "problem": 105, "user": "4e89e939535d3e98b8023287"}, {"code": "#(loop [x % current-key nil result {}]\n     (if (empty? x)\n\t       result\n\t       (if (keyword? (first x))\n\t\t   (recur (rest x) (first x) (conj result (hash-map (first x) [])))\n\t\t   (recur (rest x) current-key (merge-with concat result (hash-map current-key (vector (first x))))))))", "problem": 105, "user": "4f066916535dcb61093f6c10"}, {"code": "(fn [s]\n  (loop [m {} rs s lkey nil]\n    (if (empty? rs)\n      m\n      (let [e (first rs)]\n        (if (keyword? e)\n          (recur (assoc m e []) (rest rs) e)\n          (recur (assoc m lkey (conj (get m lkey) e)) (rest rs) lkey))))))", "problem": 105, "user": "4eddcbbf535d10e5ff6f532d"}, {"code": "(fn [xs]\n  (let [r (partition-by keyword? xs)]\n    (merge\n      (zipmap\n        (map last (take-nth 2 r))\n        (take-nth 2 (rest r)))\n      (zipmap\n        (flatten (map drop-last (take-nth 2 r)))\n        (repeat [])))))", "problem": 105, "user": "4f1b92d1535d64f60314647b"}, {"code": "(fn [i] (loop [j i result {} lastkey nil] (if (empty? j) result (if (integer? (first j)) (recur (rest j) (assoc result lastkey (conj (result lastkey) (first j))) lastkey) (recur (rest j) (assoc result (first j) []) (first j))))))", "problem": 105, "user": "4f0e4ebd535d0136e6c22322"}, {"code": "(fn rmap [vals]\n  (loop [vals vals  m {}]\n    (if (empty? vals)\n      m\n      (let [notk (complement keyword?)\n            k (first vals)\n            vs (take-while notk (rest vals))\n            nextvals (drop-while notk (rest vals))\n            ]\n       (recur nextvals (into m {k vs}))))))", "problem": 105, "user": "4f0d093b535d0136e6c22313"}, {"code": "(fn [coll] (:output (reduce (fn [{:keys [vals output]} x]\n                                (if (keyword? x)\n                                  {:vals '()\n                                   :output (assoc output x vals)}\n                                  {:vals (cons x vals)\n                                   :output output}))\n                              {:vals '()\n                               :output {}}\n                              (reverse coll))))", "problem": 105, "user": "4ebcb8ff535dfed6da9c6d8a"}, {"code": "(fn f [s]\n  (if (seq s)\n    (let [[k & r] s\n          [v z] (split-with (complement keyword?) r)]\n      (conj (f z) [k v]))\n    {}))", "problem": 105, "user": "4f08b15b535dcb61093f6c40"}, {"code": "(fn [s]\n  (loop [s s res {} lastk (first s) cur []]\n    (if s\n      (let [e   (first s)\n            isk (keyword? e)]\n        (if isk\n          (recur (next s) (assoc res lastk cur) e [])\n          (recur (next s) res lastk (conj cur e))))\n      (if lastk\n        (assoc res lastk cur)\n        {}))))", "problem": 105, "user": "4f1fd734535d64f6031464a5"}, {"code": "(fn make-map [xs]\n  (loop [r {} xs xs]\n    (if (empty? xs)\n      r\n      (let [l (take-while (complement keyword?) (rest xs))]\n        (merge r {(first xs) l} (make-map (drop (+ 1 (count l)) xs)))))))", "problem": 105, "user": "4f251302e4b0d66497709ff0"}, {"code": "(fn create-map [coll]\n  (if (empty? coll) \n    {}\n    (let [[k & xs] coll\n          [v rrest] (split-with #(not (keyword? %)) xs)]\n      (assoc (create-map rrest) k v))))", "problem": 105, "user": "4ecfa05c535d44c135fd68b9"}, {"code": "(fn [x] (reduce #(assoc %1 (first %2) (rest %2)) {} (reduce #(if (= clojure.lang.Keyword (type %2))\n           (conj %1 [%2])\n           (conj (vec (drop-last %1)) (conj (last %1) %2)))\n        [] x )))", "problem": 105, "user": "4eb02674535d7eef30807338"}, {"code": "(fn keys-and-vals [coll1]\n   (loop [result {} coll coll1 last-keyword nil]\n     (println coll last-keyword  (get result last-keyword))\n     (if (empty? coll)\n       result\n       (recur\n        (if (keyword? (first coll))\n          (assoc result (first coll) [])\n          (assoc result  last-keyword (conj (get result last-keyword) (first coll)))\n          )\n        (rest coll)\n        (if (keyword? (first coll))\n          (first coll)\n          last-keyword\n          )\n        )\n       )\n     )\n   )", "problem": 105, "user": "4ea31da2535d7eef308072c1"}, {"code": "#(loop [r {} [k & n] %]\n    (if n\n      (let [[a b] (split-with integer? n)]\n        (recur (assoc r k a) b))\n      r))", "problem": 105, "user": "4ec74de3535d6d7199dd36df"}, {"code": "(fn identify [kvs]\n    (->> (partition-by keyword? kvs)\n         (partition-all 2)\n         (mapcat (fn [[kws vs]] (concat (interpose () kws) [(sequence vs)])))\n         (apply hash-map)\n    ))", "problem": 105, "user": "4df3d4f4535d08e6dec9fe2c"}, {"code": "(fn [v]\n  (loop [i v o {} k :x]\n    (let [h (first i) r (rest i)]\n      (if (empty? i)\n        o\n        (if (keyword? h)\n          (recur r (assoc o h []) h)\n          (recur  r (assoc o k (conj (o k) h)) k))))))", "problem": 105, "user": "4f1d1d95535d64f603146488"}, {"code": "(fn [s]\n  (loop [result {}\n         current-keyword nil\n         item (first s)\n         remainder (rest s)]\n    (if (nil? item)\n      result\n      (recur (if (keyword? item)\n               (assoc result item [])\n               (update-in result [current-keyword] #(conj % item)))\n             (if (keyword? item)\n               item\n               current-keyword)\n             (first remainder)\n             (rest remainder)))))", "problem": 105, "user": "4f31519ae4b0d6649770a086"}, {"code": "(fn kv [m]\n  (into {} \n    (if (empty? m) [] \n      (lazy-seq\n        (if (keyword? (first m))\n          (let [n (take-while integer? (rest m))]\n            (cons [(first m) n] (kv (drop (+ 1 (count n)) m)))))))))", "problem": 105, "user": "4ee4f4a9535d1385b2869d85"}, {"code": "(fn [ss]\n  (if (empty? ss)\n    {}\n  (loop [s (rest ss)\n         key (first ss)\n         vals []\n         m {}]\n    (if (empty? s)\n      (assoc m key vals)\n      (if (keyword? (first s))\n        (recur (rest s)\n               (first s)\n               []\n               (assoc m key vals))\n        (recur (rest s)\n               key\n               (conj vals (first s))\n               m))))))", "problem": 105, "user": "4e7dd982535db169f9c796ee"}, {"code": "#(into {}\n         (apply concat\n                (for [[a b] (partition 2 (partition-by keyword? %))]\n                  (apply list [(last a) b]\n                         (for [a (butlast a)] [a []])))))", "problem": 105, "user": "4f0664bd535dcb61093f6c0f"}, {"code": "(fn r [v]\n  (letfn [(f [[x y & z]]\n            (if (nil? x)\n              {}\n              (if (nil? y)\n                (conj {} [(first x) []])\n                (if (keyword? (first y))\n                  (conj (f (cons y z)) [(first x) []])\n                  (conj (f z) [(first x) y])))))]\n    (f (map vec (partition-by keyword v)))))", "problem": 105, "user": "4ef6e689535dced4c769f24f"}, {"code": "(fn [c]\n  (let [K  clojure.lang.Keyword\n        xs (partition-by #(= (class %) K) c)]\n    (loop [[w & ws :as all] (first xs) xs (next xs) p nil a {}]\n      (if all\n        (if (= (class w) K)\n          (let [ks (interpose [] all)\n                nk (drop-last ks)\n                p  (last ks)]\n            (recur (first xs) (next xs) p (into a (apply hash-map nk))))\n          (recur (first xs) (next xs) nil (into a {p all})))\n        a))))", "problem": 105, "user": "4f32a7f1e4b0d6649770a095"}, {"code": "(fn [sq]\n  (loop [[h & t] sq mp {}]\n    (if (nil? h) mp\n  (if (keyword? h)\n\t  (let [[a r] (split-with #(not (keyword? %)) t)]\n\t\t(recur r (assoc mp h a)))))))", "problem": 105, "user": "4e7d1c22535db169f9c796c5"}, {"code": "(fn ikv [v] \r\n (apply hash-map (map \r\n   \t#(if (keyword? (first %)) (first %) (flatten %))\r\n \t\t(partition-by keyword?\r\n \t\t\t(reduce #(if \r\n \t\t\t(and (keyword? (last %)) (keyword? %2))\r\n \t\t\t(conj % () %2)\r\n \t\t\t(conj % %2))\t\r\n \t\t\t\t    [] v)))))", "problem": 105, "user": "4ecf1f51535d1f5ad70dba3a"}, {"code": "(fn [l]\n    (reduce\n    (fn [h [a b]]\n      (assoc h a b)\n      ) \n      {}\n    (reduce\n    (fn [s b]\n      (if (number? b)\n        (cons [(nth (nth s 0) 0) (conj (nth (nth s 0) 1) b)] (rest s))\n        (cons [b []] s)\n      )\n    )\n    '() \n    l)) \n)", "problem": 105, "user": "4f1595da535d64f603146444"}, {"code": "(fn [v]\n  (let [len (count v)]\n    (loop [result {}\n           i 0]\n      (if (= i len) result\n         (let [j (loop [j (inc i)]\n                   (if (or (= j len) (keyword? (nth v j))) j\n                      (recur (inc j)))\n                  )]\n           (recur\n             (conj result [(nth v i) (subvec v (inc i) j)])\n             j))))))", "problem": 105, "user": "4f38d6bbe4b0e243712b1ee2"}, {"code": "(fn [c]\n          (loop [s c, res {}]\n             (if (empty? s) \n                 res\n                 (let [[h t] (split-with (complement keyword?) (rest s))] \n                      (recur t (assoc res (first s) h))))))", "problem": 105, "user": "4f34eb87e4b0e243712b1eba"}, {"code": "(fn f [[k & r]]\n  (let [c (complement keyword?)] \n    (if k (into {k (take-while c r)} (f (drop-while c r))) {})))", "problem": 105, "user": "4efb2fd7535dced4c769f274"}, {"code": "(fn f\r\n  ([c] (f c {}))\r\n  ([c m]\r\n    (if (empty? c) m\r\n      (let [k (first c)\r\n            nums (take-while number? (rest c))\r\n            c (drop-while number? (rest c))]\r\n        (recur c (assoc m k nums))))))", "problem": 105, "user": "4f0da4e4535d0136e6c22319"}, {"code": "(fn [s]\n  (loop [[f & c] s, res {}, ckey nil]\n    (cond\n      (nil? f) res\n      (keyword? f) (recur c (assoc res f []) f)\n      :else (recur c (assoc res ckey (conj (res ckey) f)) ckey))))", "problem": 105, "user": "4f29eb2ae4b0d6649770a037"}, {"code": "(fn this [l]\r\n  (if (empty? l) {}\r\n      (assoc  (this (drop-while (comp not keyword?) (rest l)))\r\n              (first l)\r\n              (vec (take-while (comp not keyword?) (rest l))))))", "problem": 105, "user": "4f474f43e4b0d56e7bb92bb7"}, {"code": "(fn [c]\n  (loop [a {} c c]\n    (if (seq c)\n      (let [k (first c)\n            vs (vec (take-while (comp not keyword?) (rest c)))]\n        (recur (assoc a k vs) (drop (count vs) (rest c))))\n      a)))", "problem": 105, "user": "4e50b67b535dc968683fc4ed"}, {"code": "(fn [seq]\n    (loop [acc {} kw nil sub [] [x & xs :as tail] seq]\n        (cond (empty? tail) (if (nil? kw) {} (conj acc [kw sub]))\n              (nil? kw)     (recur acc x [] xs)\n              (keyword? x)  (recur (conj acc [kw sub]) x [] xs)\n              :else         (recur acc kw (conj sub x) xs))))", "problem": 105, "user": "4f4ac35ae4b0d56e7bb92c18"}, {"code": "(fn ikv ([coll]\n         (ikv {} nil coll))\n        ([m k [x & y :as coll]]\n          (letfn [(uin [m k v] (update-in m [k] #(if (nil? %) (if (nil? v) [] [v]) (conj % v))))]\n            (if (empty? coll)\n              m\n              (if (keyword? x)\n                (recur (uin m x nil) x y)\n                (recur (uin m k x) k y))))))", "problem": 105, "user": "4f4ba29ae4b03ad3f0c10c7a"}, {"code": "(fn f [s]\n  (if (seq s)\n    (let [[k & r] s\n          [v r] (split-with number? r)]\n      (into {k v} (f r)))\n    {}))", "problem": 105, "user": "4f4e91a9e4b03ad3f0c10cca"}, {"code": "(fn f105 [l]\n    (let [last-key (ref nil)]\n      (reduce #(if (keyword? %2)\n                 (dosync (ref-set last-key %2) (assoc %1 %2 []))\n                 (update-in %1 [@last-key] conj %2))\n              {}\n              l)))", "problem": 105, "user": "4f4d0a52e4b03ad3f0c10c9d"}, {"code": "(fn [xs]\n  (if (empty? xs) {}\n    (apply hash-map (apply concat\n      (map\n        (fn [[k v]] [k (map second (remove (partial apply =) v))])\n        (group-by first\n          (reductions\n            (fn [[k _] x] (if (keyword? x) [x x] [k x]))\n            [(first xs) (first xs)]\n            (rest xs))))))))", "problem": 105, "user": "4f1b0ab3535d64f603146474"}, {"code": "(fn [xs] \n  (loop [m {} xs xs] \n    (if (empty? xs) \n      m \n      (recur \n        (assoc m (first xs) (take-while #(not (keyword? %)) (rest xs)))\n        (drop-while #(not (keyword? %)) (rest xs))))))", "problem": 105, "user": "4e58c019535d8a8b8723a297"}, {"code": "(fn foo\n  ([coll] (foo coll {}))\n  ([coll m]\n    (let [vals (take-while number? (rest coll))]\n      (if (empty? coll)\n        m\n        (foo (drop (+ 1 (count vals)) coll) (assoc m (first coll) vals))))))", "problem": 105, "user": "4f4f08c8e4b03ad3f0c10cd8"}, {"code": "(fn [s]\r\n    (loop [s s acc {} k nil]\r\n      (if-let [[h & t] (seq s)]\r\n        (if (keyword? h)\r\n          (recur t (assoc acc h []) h)\r\n          (recur t (update-in acc [k] #(conj % h)) k))        \r\n        acc)))", "problem": 105, "user": "4f047177535dcb61093f6bc6"}, {"code": "(fn [v]\n  (loop [v_ v acc {}]\n    (cond\n      (empty? v_) acc\n      :else (recur (drop-while #(not= (type %) (type :a)) (rest v_))\n                   (conj acc [(first v_) (take-while #(not= (type %) (type :a)) (rest v_))])))))", "problem": 105, "user": "4f50c414e4b03ad3f0c10d0d"}, {"code": "(fn [c]                                                                                      \n  ((fn ! [mp key coll]                                                                                \n     (if-let [s (seq coll)]                                                                          \n       (let [ head (first s)]                                                                        \n         (if (keyword? head)                                                                         \n           (! (assoc mp head []) head (rest s))                                                      \n           (! (assoc mp key (conj (get mp key) head)) key (rest s))))                                \n       mp)) {} nil c))", "problem": 105, "user": "4f1d1299535d64f603146487"}, {"code": "(fn [s]\n  (->> (partition-by keyword? s)\n       (reduce #(if (keyword? (first %2))\n                    (into % (interpose [] %2))\n                    (conj % %2)) [])\n       (apply hash-map)))", "problem": 105, "user": "4f569a3ce4b0a7574ea71828"}, {"code": "(fn kv [s]\n  (if (empty? s) {}\n    (let [\n      key (first s)\n      [vals map] (split-with number? (rest s))]\n      (assoc (kv map) key vals))))", "problem": 105, "user": "4f569218e4b0a7574ea71826"}, {"code": "(fn idkeys [kws]\n    (if (empty? kws)\n      {}\n      (loop [k (first kws) r (rest kws) ret {}]\n        (let [notkw? (complement keyword?)\n              rem (drop-while notkw? r)]\n          (if-not k ret\n                  (recur (first rem) (rest rem) (assoc ret k (take-while notkw? r))))))))", "problem": 105, "user": "4f3ec266e4b0e243712b1f8c"}, {"code": "(fn [s]\n  (loop [k nil ss s c [] out {}]\n    (if (empty? ss)\n      (if (nil? k)\n        out\n        (assoc out k c))\n      (let [e (first ss)]\n        (if (keyword? e)\n          (if (nil? k)\n            (recur e (rest ss) [] out)\n            (recur e (rest ss) [] (assoc out k c)))\n          (recur k (rest ss) (conj c e) out))))))", "problem": 105, "user": "4dd9d299535d2dad7130b5dd"}, {"code": "#(loop [[f & o] %\n        k f\n        a {}]\n  (if f\n    (if (keyword? f)\n      (recur o f (assoc a f []))\n      (recur o k (merge-with conj a {k f})))\n   a))", "problem": 105, "user": "4f38b7d9e4b0e243712b1ee0"}, {"code": "(fn f [s] (if (seq s) (let [[k & r] s [v o] (split-with integer? r)] (merge {k v} (f o))) {}))", "problem": 105, "user": "4eecdd66535d93acb0a668b9"}, {"code": "(fn kv [seq]\r\n  (if (empty? seq)\r\n    {}\r\n    (let [[k & r] seq]\r\n      (into {k (take-while (complement keyword?) r)}\r\n            (kv (drop-while (complement keyword?) r))))))", "problem": 105, "user": "4f62b29ce4b0defedf855fd9"}, {"code": "(fn [xs]\n  (loop [xs xs m {} k nil acc []]\n    (if (seq xs)\n      (if (keyword? (first xs))\n        (if (nil? k)\n          (recur (rest xs) m (first xs) [])\n          (recur (rest xs) (conj m [k acc]) (first xs) []))\n        (recur (rest xs) m k (conj acc (first xs))))\n      (if (empty? acc)\n        m\n        (conj m [k acc])))))", "problem": 105, "user": "4e7f5a0b535db966e863cc41"}, {"code": "(fn [s]\n  (loop [k nil, h {}, r s]\n    (if (empty? r)\n      h\n      (let [f (first r)\n            n (next r)]\n        (if (keyword? f)\n          (recur f (assoc h f []) n)\n          (recur k\n                 (update-in h [k]\n                   #(conj % f))\n                 n))))))", "problem": 105, "user": "4f6fbb68e4b07046d9f4efeb"}, {"code": "#(->>\r\n     %\r\n     (partition-by keyword?)\r\n     (mapcat (fn [[k :as v]] (if (keyword? k) (interpose [] v) [v])))\r\n     (apply hash-map))", "problem": 105, "user": "4f6160a7e4b0defedf855fbe"}, {"code": "(fn unflatten-map [s]\n  (loop [ret {}\n         prev-kw []\n         s s]\n    (let [f (first s)\n          kw? (keyword? f)\n          num? (not kw?)\n          this-kw (if kw? f prev-kw)\n          prev-list (vec (ret this-kw))\n          next-value (vec (concat (ret this-kw) (if num? [f] [])))\n          next-map (assoc ret this-kw (if num? next-value []))]\n      (if (seq s)\n        (recur next-map this-kw (rest s))\n        ret))))", "problem": 105, "user": "4ee26f01535d10e5ff6f5368"}, {"code": "(fn id\n  ([s] (id (first s) s {}))\n  ([k s m]\n     (if (empty? s)\n       m\n       (let [[f & r] s]\n         (if (keyword? f)\n           (id f r (assoc m f []))\n           (id k r (assoc m k (conj (m k) f))))))))", "problem": 105, "user": "4ecbb249535df97575fdabdf"}, {"code": "(fn f [l]\n  (if (not (nil? l))\n    (let [l (seq l)\n          r (take-while #(number? %) (next l))\n          a (first l)]\n      (if (keyword? a)\n        (conj {a (vec r)} (f (next l)))\n        (conj {} (f (next l)))))\n    {}))", "problem": 105, "user": "4f7e29dde4b06e829148e1ca"}, {"code": "(fn kv [xs]\n  (if (empty? xs) {}\n    (loop [acc {} curkey (first xs) vals [] fst (second xs) rst (drop 2 xs)]\n      (cond\n        (nil? fst) (assoc acc curkey vals)\n        (keyword? fst) (recur (assoc acc curkey vals)\n                              fst []\n                              (first rst) (rest rst))\n        :else (recur acc curkey (conj vals fst) (first rst) (rest rst))))))", "problem": 105, "user": "4dafa380edd6309eace4d17c"}, {"code": "(fn iter\n  ([s] (iter s nil {}))\n  ([[a & r] l h]\n    (cond\n      (nil? a) h\n      (keyword? a) (recur r a (merge h {a []}))\n      :else (recur r l (merge-with conj h {l a})))))", "problem": 105, "user": "4f8345c6e4b033992c121c1b"}, {"code": "(fn [v]\n  (loop [m {} k nil [f & r] v]\n    (cond (nil? f) m\n          (keyword? f) (recur (assoc m f []) f r)\n          :else (recur (assoc m k (conj (m k) f)) k r))))", "problem": 105, "user": "4f2baf1ae4b0d6649770a04c"}, {"code": "(fn joins [vers]  \r\n  (loop[cols vers,currKey (first vers),result {}]\r\n       (if (empty? cols)\r\n             result\r\n             (let[now (first cols)]\r\n               (if (keyword? now)\r\n\t\t\t             (recur (rest cols) now (assoc result now []) )\r\n\t\t\t             (recur (rest cols) currKey (assoc result currKey \r\n                                            (conj (get result currKey) now) \r\n                                            )\r\n                       )\r\n\t              )\r\n             )\r\n          \r\n          )\r\n    )\r\n  )", "problem": 105, "user": "4f6d9d7ee4b07046d9f4efcd"}, {"code": "(fn [a] (apply hash-map\n              (loop [f (first a) r (rest a) m []]\n                (if f\n                  (if (instance? clojure.lang.Keyword f)\n                    (recur (first r) (rest r) (into m [f []]))\n                    (recur (first r) (rest r) (assoc m (dec (count m)) (conj (last m) f))))\n                  m))))", "problem": 105, "user": "4f83665ee4b033992c121c1c"}, {"code": "(fn fun [[k & vs]]\n  (if vs\n    (let [[ns more] (split-with number? vs)]\n      (assoc (fun more) k ns))\n    {}))", "problem": 105, "user": "4f88ae35e4b033992c121c6d"}, {"code": "(fn [coll]\n  (loop [k nil, m {}, [x & xs] coll]\n    (if (keyword? x)\n      (recur x (assoc m x []) xs)\n      (if x\n        (recur k (update-in m [k] conj x) xs)\n        m))))", "problem": 105, "user": "4f49e869e4b0d56e7bb92c02"}, {"code": "(fn [coll]\r\n  (apply hash-map (reverse\r\n              (reduce (fn [a x]\r\n                        (if (keyword? x)\r\n                          (conj a x [])\r\n                          (conj (rest a) (conj (first a) x))))\r\n                () coll))))", "problem": 105, "user": "4f969214e4b0dcca54ed6cdd"}, {"code": "(fn [s]\n  (first (reduce (fn [[r k] e] \n                     (if (keyword? e)\n                         [(assoc r e []) e]\n                         [(assoc r k (conj (get r k) e)) k]))\n                 [{} nil] s)))", "problem": 105, "user": "4f9120d8e4b0dcca54ed6c96"}, {"code": "#(apply hash-map\n  (mapcat (fn [[k :as v]] (if (keyword? k) (interpose [] v) [v]))\n    (partition-by type %)))", "problem": 105, "user": "4f9597e0e4b0dcca54ed6cd4"}, {"code": "(fn cm [v]\n  (if (empty? v) {}\n  (assoc \n    (cm (drop-while #(not (keyword? %)) (rest v)))\n    (first v)\n    (take-while #(not (keyword? %)) (rest v))\n  ))\n)", "problem": 105, "user": "4f84400de4b033992c121c2e"}, {"code": "#(loop [[[k] & v]\n       (partition-by\n        (fn [x] (or (number? x) x)) %)\n       o {}]\n  (if k\n    (if (and v (number? (ffirst v)))\n      (recur (rest v) (conj o {k (first v)}))\n      (recur v (conj o {k []})))\n    o))", "problem": 105, "user": "4f9fe2b9e4b0dcca54ed6d40"}, {"code": "(fn [s]\n    (loop [s s\n           m {}]\n      (if (empty? s)\n        m\n        (let [k (first s)\n              [v o]\n              (split-with #(not (keyword? %))\n                          (rest s))]\n          (recur o\n                 (assoc m k (vec v)))))))", "problem": 105, "user": "4f5cc3b8e4b0030a34fb2b2b"}, {"code": "(fn identify-ks-vs [coll]\n  (cond (empty? coll) {}\n        (= (count coll) 1) {(first coll) []}\n        (keyword? (first coll))\n        (let [ k (first coll)\n              xs (split-with #(not (keyword? %)) (rest coll))\n              vs (nth xs 0)\n              arg (nth xs 1)]\n          (merge {k vs} (identify-ks-vs arg)))\n        :else (println \"error: \" coll)))", "problem": 105, "user": "4ef6f5ea535dced4c769f250"}, {"code": "(fn f\n    ([s] (if (empty? s) {}\n           (into {} (f (rest s) (first s) [] []))))\n    ([xs k v r]\n     (cond\n       (empty? xs) (conj r [k v])\n       (keyword? (first xs)) (recur (rest xs) (first xs) [] (conj r [k v]))\n       :else (recur (rest xs) k (conj v (first xs)) r))))", "problem": 105, "user": "4f969a66e4b0dcca54ed6cde"}, {"code": "(fn [s]\n  (loop [k :foo\n         s s\n         m {}]\n    (let [q (first s)]\n    (cond (empty? s) m\n          (keyword? q) (recur q (rest s) (assoc m q []))\n          :else (recur k (rest s) (merge-with conj m {k q}))))))", "problem": 105, "user": "4facd2fae4b081705acca22f"}, {"code": "#(->> % (partition-by keyword?)\n  (partition 2)\n  (mapcat (fn [[ks vs]] (map vector (reverse ks) (cons vs (repeat [])))))\n  (into {}))", "problem": 105, "user": "4e0e0529535d04ed9115e7b9"}, {"code": "(letfn [(step [m x]\n          (if (keyword? x)\n            (assoc m x [])\n            (let [[k v] (first m)]\n              (assoc m k (conj v x)))))]\n  (partial reduce step {}))", "problem": 105, "user": "4f3fb586e4b0e243712b1f9c"}, {"code": "(fn [S]\n  (reduce (fn [x y]\n    (cond\n      (keyword? y) (conj x [y []])\n      :else (assoc x (key (first x)) \n                  (conj (val (first x)) y))))\n    {} S))", "problem": 105, "user": "4faa9593e4b081705acca1f9"}, {"code": "(fn kav [s]\n  (loop [m {}\n         remain s\n         current-key nil]\n     (if (empty? remain) m\n       (let [elt (first remain)\n             new-remain (rest remain)\n             elt-key (keyword? elt)\n             new-key (if elt-key elt current-key)\n             old-vec (if elt-key [] (m current-key))\n             new-vec (if elt-key [] (conj old-vec elt))\n             new-map (assoc m new-key new-vec)]\n          (recur new-map new-remain new-key)))))", "problem": 105, "user": "4f036fb3535dcb61093f6ac8"}, {"code": "(fn [s]\n  (let [[m _] \n        (reduce \n          (fn [[m c] n]\n            (if (keyword? n) \n              [(assoc m n []) n]\n              [(assoc m c (conj (get m c) n)) c])) [{} nil] s)]\n    m))", "problem": 105, "user": "4f4274f2e4b0d7d3c9f3fd00"}, {"code": "(fn gen-map [coll]\n  (letfn [(cat [p e m]\n            (if (keyword? e)\n              (assoc m e [])\n              (assoc m p (conj (get m p) e))))]\n    (loop [pk nil r {} c coll]\n      (let [e (first c)]\n        (if (empty? c)\n          r\n          (recur (if (keyword? e) e pk) (cat pk e r) (rest c)))))))", "problem": 105, "user": "4f1bee08535d64f60314647e"}, {"code": "(fn [s]\n  (loop [s s a {} k nil]\n    (if (empty? s) a\n        (let [x (first s)]\n          (if (keyword? x)\n            (recur (rest s) (update-in a [x] (fn [z] [])) x)\n            (recur (rest s) (update-in a [k] (fn [z] (conj z x))) k))))))", "problem": 105, "user": "4fb4b798e4b081705acca2af"}, {"code": "#(loop [m {} s %]\n  (if\n    (empty? s)\n    m\n    (recur\n      (assoc m (first s) (take-while (complement keyword?) (rest s)))\n      (drop-while (complement keyword?) (rest s)))))", "problem": 105, "user": "4fb2101ce4b081705acca284"}, {"code": "(fn [s]\n (loop [m {} s s]\n   (if-not (empty? s)\n     (let [k (first s)\n           vs (take-while (comp not keyword?) (rest s))\n           new-s (drop-while (comp not keyword?) (rest s))]\n       (recur (assoc m k vs) new-s))\n     m)))", "problem": 105, "user": "4fa0a4b1e4b0dcca54ed6d4f"}, {"code": "#(apply hash-map \n  (mapcat \n    (fn [[k v]] \n      (concat \n        (interpose [] k) \n        [v])) \n    (partition 2 \n      (partition-by keyword? %))))", "problem": 105, "user": "4f991ec1e4b0dcca54ed6cfb"}, {"code": "(fn [s]\n  (loop [s s r {}]\n    (if (empty? s)\n      r\n      (if (keyword? (first s))\n        (recur\n          (drop-while #(not (keyword? %)) (rest s))\n          (conj r [(first s) (take-while #(not (keyword? %)) (rest s))]))\n        (recur\n          (drop-while #(not (keyword? %)) (rest s)) r)))))", "problem": 105, "user": "4f954dbce4b0dcca54ed6ccd"}, {"code": "(fn app\n  ([arg] (app arg {}))\n  ([arg m]\n    (if (empty? arg) m\n      (app (rest arg) \n        (if (keyword? (first arg))\n          (merge m {(first arg) []})\n          (merge-with concat m\n            {(key (last (sort m))) [(first arg)]}\n            ))))))", "problem": 105, "user": "4dd579b5535dae65d5c462ea"}, {"code": "(fn kv [xs]\n  (if (empty? xs)\n    {}\n    (let [[k & r1] xs\n          [v r2] (split-with number? r1)]\n      (assoc (kv r2) k v)\n    )\n  )\n)", "problem": 105, "user": "4f725201e4b07046d9f4f02f"}, {"code": "(fn [coll]\n  (into {}\n        (apply merge\n              (map #(apply hash-map\n                            (last (first %)) (flatten (last %))\n                            (mapcat (fn [x] (list x [])) (butlast (first %))))\n                    (partition-all 2 (partition-by #(not (keyword? %)) coll))))))", "problem": 105, "user": "4fa5406fe4b081705acca1ac"}, {"code": "(fn [l] (loop [[h & t] (reverse l), mp {}, v ()]\n           (cond\n             (nil? h) mp\n             (keyword? h) (recur t (assoc mp h v) ())\n             :else        (recur t mp (cons h v)))))", "problem": 105, "user": "4fc0853ae4b081705acca327"}, {"code": "(fn [lst]\n  (loop [acc {}\n         rst lst]\n    (if (empty? rst)\n      acc\n      (let [[vs tail] (split-with number? (rest rst))]\n        (recur \n          (assoc acc (first rst) vs) \n          tail)))))", "problem": 105, "user": "4fba7d1ee4b081705acca2e0"}, {"code": "#((fn b [m [k v & more]]\n          (cond (not k) m \n                (number? (first v)) (b (assoc m (first k) v) more) \n                true (b (assoc m (first k) []) (cons v more)))) \n            {} (partition-by (fn [x] (or (number? x) (identity x))) %))", "problem": 105, "user": "4fa30027e4b081705acca187"}, {"code": "(fn [s]\n  (second (reduce (fn [[k m] x]\n    (if (integer? x)\n      [k (assoc m k (conj (get m k) x))]\n      [x (assoc m x [])])\n  ) [nil {}] s)))", "problem": 105, "user": "4ec28d86535dfed6da9c6dbc"}, {"code": "#(loop [[item & rs] % ret {} last-key item]\n  (cond\n    (not item) ret\n    (keyword? item) (recur rs (assoc ret item []) item)\n    :else  (recur rs (assoc ret last-key (conj (ret last-key) item)) last-key)))", "problem": 105, "user": "4f725466e4b07046d9f4f030"}, {"code": "(fn [xs] (dissoc (reduce #(if (keyword? %2) (assoc %1 :k %2 %2 []) (let [k (get %1 :k)] (assoc %1 k (conj (get %1 k) %2)))) {} xs) :k))", "problem": 105, "user": "4fb65f2fe4b081705acca2c7"}, {"code": "(fn [l]\n  (loop [map {}, key (first l), vs [], l (rest (conj l :sentinel))]\n    (if-let [c (first l)]\n      (if (number? c)\n        (recur map key (conj vs c) (rest l))\n        (recur (conj map [key vs]) c [] (rest l)))\n      map)))", "problem": 105, "user": "4fc8c8d8e4b0ee37620e183b"}, {"code": "(fn [a] \n  (if (empty? a) {}\n    (->>\n    (conj (vec (interpose nil a)) nil)\n    (partition-by keyword?)\n    (map #(remove nil? %))\n    (partition 2)\n    (map #(vector (first (first %)) (vec (second %))))\n    (apply map vector)\n    (apply zipmap))))", "problem": 105, "user": "4fca1cd6e4b0ee37620e184c"}, {"code": "(fn f [[m & ms]]\n  (if (nil? ms) {}\n\t\t(let [nstep (f ms)]\n\t\t\t(if (keyword? m)\n\t\t\t\t(merge {m (take-while (comp not keyword) ms)} nstep)\n\t\t\t\tnstep))))", "problem": 105, "user": "4fb1fa51e4b081705acca283"}, {"code": "(fn ident-keys-values [seq]\n  (letfn [(read-values [key, seq]\n            (conj (ident-keys-values (drop-while #(not (keyword? %)) seq))\n                  [key (take-while #(not (keyword? %)) seq)]))]\n    (if (empty? seq)\n      {}\n      (read-values (first seq) (rest seq)))))", "problem": 105, "user": "4fcaf7a4e4b0ee37620e1857"}, {"code": "#(apply hash-map \n  (map (fn[a](if (not= nil (keyword (first a))) \n    (first a) (flatten a))) \n      (partition-by keyword \n        (interleave % (repeat [])))))", "problem": 105, "user": "4fb3dd1ee4b081705acca2a5"}, {"code": "(fn [l]\n  (second\n    (reduce\n      (fn [[k m] i]\n        (if (keyword? i)\n          [i (assoc m i [])]\n          [k (update-in m [k] #(conj % i))]))\n      [nil {}]\n      l)))", "problem": 105, "user": "4fce5474e4b0d4b2a7a9d451"}, {"code": "#(loop [[k & v] % m {}] \n    (if k \n      (recur \n        (drop-while \n          (complement keyword?) v) \n        (assoc m  k \n          (take-while (complement keyword?) v))) \n       m))", "problem": 105, "user": "4fb3b865e4b081705acca2a2"}, {"code": "(fn ident\n  ([v] (ident v nil {}))\n  ([[f & r :as s] k hm]\n    (cond (empty? s) hm\n          (keyword? f) (recur r f (assoc hm f []))\n          :else (recur r k (update-in hm [k] conj f)))))", "problem": 105, "user": "4fb1d907e4b081705acca282"}, {"code": "(fn make-map [key-vals]\n  (if (not-empty key-vals)\n    (merge {(first key-vals) (vec (take-while number? (rest key-vals)))}\n           (make-map  (drop-while number? (rest key-vals))))\n    {}))", "problem": 105, "user": "4f7f9665e4b033992c121bea"}, {"code": "(fn [sq] (first (reduce (fn [[m k] v]\n                          (cond\n                           (keyword? v) [(assoc m v []) v]\n                           (nil? k) [m k]\n                           :else [(assoc m k (conj (m k) v)) k]))\n                        [{} nil] sq)))", "problem": 105, "user": "4efd8b67535de96065cf5085"}, {"code": "(fn [xs]\n  (loop [m {}, coll xs]\n    (if (empty? coll) m\n      (let [k (first coll)\n            v (take-while #(not (keyword? %)) (drop 1 coll))]\n        (recur (conj m {k v}) (drop (+ 1 (count v)) coll))))))", "problem": 105, "user": "4fb12b35e4b081705acca275"}, {"code": "#(->> (partition-by keyword? %)\n  (mapcat\n    (fn [[k :as x]]\n      (if (keyword? k) (interpose [] x) [x])))\n  (apply array-map))", "problem": 105, "user": "4fd96694e4b05e33b9224f37"}, {"code": "(fn q105 [coll]\n  (->> coll\n    (partition-by keyword?)\n    (partition-all 2)\n    (reduce (fn [m [keys vals]]\n              (assoc \n                (reduce #(assoc % %2 []) m (butlast keys))\n                (last keys) (apply vector vals)))\n            {} )))", "problem": 105, "user": "4fd22e70e4b04c3a95aa041c"}, {"code": "(fn [v]\n  (first (reduce (fn [[res last] v]\n                 (if (number? v)\n                   [(update-in res [last] conj v) last]\n                   [(assoc res v []) v]))\n       [{} nil] v)))", "problem": 105, "user": "4f465096e4b0d56e7bb92b9a"}, {"code": "(fn [s]\n  (loop [[head & tail :as s] s result {} kw :?]\n    (cond\n      (empty? s) result\n      (keyword? head) (recur tail (assoc result head []) head)\n      :else (recur tail (assoc result kw (conj (result kw) head)) kw))))", "problem": 105, "user": "4fdec88fe4b05e33b9224f8e"}, {"code": "(fn ikey[mymap incoll]\n  (if (empty? incoll) mymap\n      (let [key (first incoll)\n            val (take-while #(not (keyword? %)) (rest incoll))\n            nxt-map (assoc mymap key val)\n            nxt-coll (drop-while #(not (keyword? %)) (rest incoll))]\n        (ikey nxt-map nxt-coll)))) {}", "problem": 105, "user": "4fb86dc9e4b081705acca2d8"}, {"code": "(fn [x]\n  (letfn [ (kv [c res]\n     (if (empty? c) res\n       (let [ k (first c) v (take-while #(not (keyword? %)) (rest c)) ]\n         (recur  (drop (inc (count v)) c) (assoc res k v)))))]\n         (kv x {})))", "problem": 105, "user": "4fccdc75e4b0ee37620e186d"}, {"code": "(fn k [x]\n  (if (seq x)\n      (let [ [a & b] x]\n        (conj \n          {a (take-while #(not= (type :a) (type %)) b)}\n          (k (drop-while #(not= (type :a) (type %)) b))))\n    {}))", "problem": 105, "user": "4fdd27f3e4b05e33b9224f78"}, {"code": "(fn part [n]\n  (dissoc (reduce (fn [acc n] \n            (if (keyword? n)\n              (assoc acc n [] :key n)\n              (merge-with conj acc {(:key acc) n})))\n          {:key nil} n) :key))", "problem": 105, "user": "4faafccde4b081705acca209"}, {"code": "(fn ikv [s]\r\n    (loop [s s\r\n           ret {}]\r\n        (cond\r\n            (empty? s) ret\r\n            (keyword? (first s)) (let [[nums rest-s] (split-with number? (rest s))]\r\n                                   (recur rest-s (assoc ret (first s) nums))))))", "problem": 105, "user": "4fcc6cb3e4b0ee37620e1861"}, {"code": "#(loop [m {} k nil s %]\r\n  (if (empty? s) m (let [e (first s)]\r\n   (if (keyword? e) (recur (merge m {e []}) e (rest s))\r\n    (recur (merge-with concat m {k [e]}) k (rest s))))))", "problem": 105, "user": "4fca2ef0e4b0ee37620e184e"}, {"code": "(fn [c]\n  (loop [a {} r c]\n    (if (empty? r)\n      a\n      (recur (conj a [(first r) (take-while #(not (keyword? %)) (rest r))])\n             (drop-while #(not (keyword? %)) (rest r))))))", "problem": 105, "user": "4f7431d2e4b044e54cd9a8f7"}, {"code": "(fn [kvlis]\n  (letfn \n    [(make-map [s m]\n      (cond (empty? s) m\n            (keyword? (first s))\n              (make-map (drop-while #(not (keyword? %)) (rest s))\n                        (conj m [(first s)\n                                 (take-while #(not (keyword? %))\n                                             (rest s))]))\n            :else\n              (make-map (drop-while #(not (keyword? %)) (rest s))\n                        m)))]\n     (make-map kvlis {})))", "problem": 105, "user": "4fe87e56e4b07c9f6fd12c40"}, {"code": "(fn [v]\n  (apply hash-map\n  (map (fn [c] (if (keyword? (first c)) (first c) (vec (apply concat c))))\n    (partition-by vector?\n\t  \t(interpose []\n  \t\t\t(map (fn [c] (if (number? (first c)) (vec c) (first c)))\n  \t\t\t\t(partition-by #((if (number? %) number? identity) %) v)))))))", "problem": 105, "user": "4daddc19c9a9d6ed4599dc57"}, {"code": "(fn [init]\n  (let [add (fn [result sym vals] (if sym (conj result {sym vals}) result))]\n    (loop [s init result {} curvals [] cursym nil]\n      (cond (empty? s) (add result cursym curvals)\n            (keyword? (first s)) (recur (rest s) (add result cursym curvals) [] (first s))\n            true (recur (rest s) result (conj curvals (first s)) cursym)))))", "problem": 105, "user": "4fe8aef4e4b07c9f6fd12c6c"}, {"code": "(fn [x] (second (reduce #(let [[kw h] %1] (if (keyword? %2) [%2 (conj h {%2 []})] [kw (merge-with conj h {kw %2})])) [nil {}] x)))", "problem": 105, "user": "4feada56e4b0140c20fb9c11"}, {"code": "#(loop [last-k (first %) accu {} x (rest %)]\n  (if (seq x)\n    (if (keyword? (first x))\n      (recur (first x)\n             (assoc accu last-k (accu last-k []))\n             (rest x))\n      (let [v (accu last-k [])]\n        (recur last-k\n               (assoc accu last-k (conj v (first x)))\n               (rest x))))\n    accu))", "problem": 105, "user": "4db016af838c48654951d9b9"}, {"code": "(fn [a]\n  (loop [kw nil\n         acc {}\n         x a]\n    (if (and x (first x))\n      (if (keyword? (first x))\n        (recur (first x) (assoc acc (first x) []) (next x))\n        (recur kw (assoc acc kw (conj (get acc kw) (first x))) (next x)))\n      acc)))", "problem": 105, "user": "4ff9d4e5e4b0678c553fc3b0"}, {"code": "(fn ident-keys [s & ans]\n (let [m (if (first ans) (first ans) {})]\n  (if (empty? s)\n\t\tm\n\t\t(let [k (first s) \n\t\t\tnums (take-while #(not (keyword? %)) (rest s))\n\t\t\t]\n\t\t\t(ident-keys (drop (inc (count nums)) s) (assoc m k nums))\n\t\t)\n\t)\n )\n)", "problem": 105, "user": "4f7b6b90e4b06e829148e1a4"}, {"code": "(fn idkv [s]\n  (apply hash-map (map #(if (every? keyword? %) (first %) (rest %))\n                (partition-by keyword?\n                              (mapcat (fn [x]\n                                        (if (every? keyword? x)\n                                          (interleave x (repeat nil))\n                                          x))\n                                      (partition-by keyword? s))))))", "problem": 105, "user": "4ff304f4e4b0678c553fc343"}, {"code": "(fn fx([[h & r]] (let [[p n] (split-with number? r)] (if (nil? h) {} (conj (fx n) [h p])))))", "problem": 105, "user": "4e7f4147535db966e863cc3d"}, {"code": "(fn [coll]\r\n  (loop [m {}, k nil, v [], tail coll]\r\n    (if-let [item (first tail)]\r\n         (if (keyword? item)\r\n           (recur (if k (assoc m k v) {}) item [] (rest tail))\r\n           (recur m k (conj v item) (rest tail)))\r\n      (if k \r\n        (assoc m k v)\r\n        m))))", "problem": 105, "user": "4ff9a200e4b0678c553fc3ab"}, {"code": "#(apply hash-map\n        (reduce\n         (fn [v n] (if (keyword? n) (conj v n []) (conj (subvec v 0 (dec (count v))) (conj (peek v) n))))\n         []\n         %))", "problem": 105, "user": "4f8bbb27e4b02e764a0a5182"}, {"code": "(fn [c] (into {}\n  (reduce\n  (fn [l e] (if (keyword? e) (cons [e []] l)\n    (let [\n      t (first l)\n      r (rest l)\n      v [(first t)(conj (second t) e)]\n    ] (cons v r))\n  ))\n  [] c)\n))", "problem": 105, "user": "4ef48422535dced4c769f236"}, {"code": "(fn [x]\n  (apply hash-map\n         (mapcat #(if (keyword? (first %))\n                      (butlast (interleave % (repeat '())))\n                 \t  (list %))\n                 (partition-by keyword? x))))", "problem": 105, "user": "4ff4f5c4e4b0678c553fc362"}, {"code": "(fn v-to-m [coll]\n  (loop [key (first coll) more (rest coll) m {}]\n    (if (nil? key)\n      m\n      (let [nums (take-while (complement keyword?) more)\n            next (drop-while (complement keyword?) more)]\n        (recur (first next) (rest next) (conj m [key nums]))))))", "problem": 105, "user": "5003deb9e4b0678c553fc445"}, {"code": "(fn [ls]\n  (if (empty? ls) \n    {}\n    (into {} (loop [res [] k (first ls) v [] l (rest ls)]\n      (cond\n        (empty? l) (conj res [k v])\n        (keyword? (first l))\n          (recur (conj res [k v]) (first l) [] (rest l))\n        :else\n          (recur res k (conj v (first l)) (rest l)))))))", "problem": 105, "user": "5003ee7de4b0678c553fc446"}, {"code": "(fn [lst]\n  (into {}\n    (loop [coll lst, result ()]\n      (if (empty? coll) result\n        (let [[key & rst] coll\n              [vals next] (split-with (complement keyword?) rst)]\n          (recur next (cons [key vals] result)))))))", "problem": 105, "user": "500933a6e4b046cdb195e074"}, {"code": "#(let [nk (complement keyword?)]\n   (loop [c (drop-while nk %)\n          m {}]\n     (if-let [c (seq c)]\n       (let [[vs x] (split-with nk (next c))]\n         (recur x (assoc m (first c) vs)))\n       m)))", "problem": 105, "user": "500d8c49e4b07ccb9a7ddb00"}, {"code": "(fn [c] (let [[m c]\r\n                (reduce\r\n                  (fn [[m c] i]\r\n                    (if (and (keyword? i) (not (empty? c)))\r\n                      [(assoc m (first c) (rest c)) [i]]\r\n                      [m (conj c i)]))\r\n                  [{} []] c)]\r\n            (if-not (empty? c)\r\n              (assoc m (first c) (rest c))\r\n              m)))", "problem": 105, "user": "4fe900a6e4b0547ebccb243a"}, {"code": "(fn [coll]\n  (loop [m {}, last nil, xs coll]\n    (if (empty? xs)\n      m\n      (let [x (first xs), xs (rest xs)]\n        (if (keyword? x)\n          (recur (assoc m x []) x xs)\n          (recur (assoc m last (conj (get m last) x)) last xs))))))", "problem": 105, "user": "500ff421e4b0ae202717946f"}, {"code": "#(loop [r {}\n         [k & q :as x] %]\n    (if (empty? x)\n      r\n      (recur (assoc r k (vec (take-while integer? q)))\n             (drop-while integer? q))))", "problem": 105, "user": "4e773be8535d324fb2983d6e"}, {"code": "(fn [v]\r\n  (reduce (fn [acc x]\r\n           (if (keyword? x)\r\n            (assoc acc x [])\r\n             (let [k (key (first acc))\r\n                   v (val (first acc))]\r\n                  (assoc acc k (conj v x)))))\r\n           {} v))", "problem": 105, "user": "4fdb02aae4b05e33b9224f56"}, {"code": "(fn r [a c [x & y]]\r\n  (if x\r\n    (if (keyword? x)\r\n      (r (assoc a x []) x y)\r\n      (r (update-in a [c] conj x) c y))\r\n    a)) {} =", "problem": 105, "user": "500d1db4e4b05f7c30cfa69f"}, {"code": "(fn keyval [incoming]\n    (loop [iseq incoming\n           builder {}]\n      (if (empty? iseq)\n        builder\n        (let [kwd (first iseq)\n              rst (split-with number? (rest iseq))]\n        (recur\n         (second rst)\n         (assoc builder kwd\n                (first rst)))))))", "problem": 105, "user": "50057f23e4b0678c553fc466"}, {"code": "(fn conv [s]\n  (reduce (fn [r [k v]] \n          (assoc (into r (zipmap k (repeat []))) (last k) v)) {}  \n          (partition 2 (partition-by keyword? s))))", "problem": 105, "user": "4f05ea25535dcb61093f6c02"}, {"code": "(fn [s]\n  (:nums (reduce \n    (fn [{:keys [kw nums]} item]\n      (if (keyword? item)\n        {:kw item, :nums (assoc nums item [])}\n        {:kw kw, :nums (update-in nums [kw] conj item)})\n      )\n    {:nums {}}\n    s))\n  )", "problem": 105, "user": "4dca8b6d535d5973398f9288"}, {"code": "(fn keys-and-values [coll]\n  (letfn [(take-key-and-values [map coll]\n            (if (empty? coll)\n              map\n              (let [key (first coll)\n                    val (vec (take-while number? (rest coll)))]\n                (recur (assoc map key val) (drop (inc (count val)) coll)))))]\n    (take-key-and-values {} coll)))", "problem": 105, "user": "4ff355a1e4b0678c553fc34d"}, {"code": "(fn [coll]\n  (apply hash-map\n    (reduce #(if (keyword? %2)\n                 (conj % %2 [])\n                 (conj (into [] (butlast %)) (conj (last %) %2)))\n            []\n            coll)))", "problem": 105, "user": "500900dee4b0144d4f561e42"}, {"code": "(fn idkv [s]\n  (loop [v s result {} currentKey nil]\n    (if (empty? v) \n      result\n      (if (keyword? (first v)) \n        (recur (rest v) (conj result [(first v) []]) (first v))\n        (recur (rest v) (conj result [currentKey (conj (result currentKey) (first v))]) currentKey)\n        )\n      )\n    )\n  )", "problem": 105, "user": "4fcf5292e4b03432b189f40e"}, {"code": "(fn [s]\r\n    (loop [[cab & cola] s\r\n           res {}]\r\n      (if (not cab)\r\n        res\r\n        (recur (drop-while number? cola) (into res [ [cab (take-while number? cola)]]))\r\n        )\r\n      ))", "problem": 105, "user": "4febb4dae4b0681fd128dc98"}, {"code": "(fn [coll]\n  (if (empty? coll) {}\n      (apply merge\n             (for [[a b] (partition 2 (partition-by keyword? coll))]\n               (into {(last a) b} (map (fn [x] [x '()]) (rest (reverse a))))))))", "problem": 105, "user": "500cb910e4b05f7c30cfa698"}, {"code": "(fn __ [v]\n  (reduce (fn [m x]\n            (if (keyword? x)\n              (assoc m x [])\n              (merge m (array-map (first (keys m)) \n                                  (conj (m (ffirst m)) x)))))\n   {} v))", "problem": 105, "user": "4ec9549d535d6d7199dd36fe"}, {"code": "(fn i\n  ([g a] (i g a {}))\n  ([g a c]\n    (if (empty? a) c\n      (if-let [[k & rest] a]\n        (recur g (drop-while g rest) (assoc c k (take-while g rest)))\n        c))))\n#(not (or (keyword? %) (nil? %)))", "problem": 105, "user": "50166470e4b052339a490e76"}, {"code": "(fn [c]\n  (loop [c c r {}]\n    (if (not-any? keyword? c)\n      r\n      (recur (drop-while (complement keyword?) (rest c)) (conj r {(first c) (vec (take-while (complement keyword?) (rest c)))})))))", "problem": 105, "user": "4f9f7daae4b0dcca54ed6d37"}, {"code": "(fn __ [m]\n  (let [mm (apply hash-map\n     \t\t(map (partial remove nil?)\n    \t\t (partition-by keyword?\n                  \t\t   (interleave m (repeat nil)))))]\n    (zipmap (map first (keys mm)) (vals mm))))", "problem": 105, "user": "4fa719c0e4b081705acca1bf"}, {"code": "(fn [coll]\n  (reduce (fn [acc it] \n          (let [[kl v] it\n                k (first kl)]\n            (if (not (keyword? k)) acc\n              (if (keyword? (first v))\n                   (assoc acc k [])\n                   (assoc acc k (vec v))))))\n {} \n (partition 2 1 (partition-by #(if (keyword? %) (Math/random) ) coll))))", "problem": 105, "user": "502a5fa4e4b09e8f859a9fbd"}, {"code": "(fn [coll]\n  (letfn [(partition-with [pred coll]\n            (if (empty? coll) ()\n              (let [chunk (cons (first coll)\n                                (take-while (complement pred) (rest coll)))]\n                (cons\n                  chunk (partition-with pred (drop (count chunk) coll))))))]\n    (into {}\n      (map (juxt first rest)\n        (partition-with keyword? coll)))))", "problem": 105, "user": "4f4e7c01e4b03ad3f0c10cc9"}, {"code": "(fn [s]\r\n  (if (seq s) (->> s\r\n   (partition-by keyword?)\r\n   (mapcat #(if (keyword? (first %)) (interpose [] %) [%]))\r\n   (apply assoc {})) {}))", "problem": 105, "user": "50336c6be4b0c6c1199c710f"}, {"code": "(fn [s]\n  (into {} (reduce (fn [v x]\n                     (if (keyword? x)\n                       (conj v [x []])\n                       (let [[k ns] (last v)]\n                         (conj (vec (butlast v)) [k (conj ns x)]))))\n                   [] s)))", "problem": 105, "user": "5028cd0fe4b01614d1633ffc"}, {"code": "#(first\n    (reduce (fn [[a l] x]\n  \t (if (keyword? x) [(assoc a x []) x]\n\t\t     [(merge-with conj a {l x}) l]))\n\t       [{}] %))", "problem": 105, "user": "4dada16fc9a9d6ed2699dc57"}, {"code": "(fn [coll]\n (let [result (reduce #(assoc %1 %2 []) {} (filter keyword? coll))\n   \t\t filt-coll (partition 2 (partition-by keyword? coll))]\n \t(reduce #(assoc %1 (last (first %2)) (last %2)) result filt-coll)))", "problem": 105, "user": "501c1492e4b086d93747d180"}, {"code": "(fn kv [acc k [v & vs]]\n  (cond (nil? v) acc\n        (keyword? v) (kv (assoc acc v []) v vs)\n        :e (kv (update-in acc [k] conj v) k vs))) {} *", "problem": 105, "user": "5032b066e4b00c0952a257ea"}, {"code": "(fn [coll]\n  (reduce \n    (fn [sum val] \n      (let [keys (first val) \n            empties (drop-last keys)\n            key (last keys)\n            vals (second val)]\n        (merge sum (zipmap empties (cycle [[]])) {key vals})))\n    {} (partition 2 (partition-by keyword? coll))))", "problem": 105, "user": "5033a1fbe4b062bc5d7ae155"}, {"code": "(fn [ls]\r\n   (let [keyls\r\n           (fn [ls]\r\n               (loop [[x & xs] ls curk nil newls []]\r\n                  (if (nil? x) newls\r\n                      (let [nk (if (keyword? x) x curk)]\r\n                                  (recur xs nk (conj newls [nk x]))))))]\r\n     \r\n     (->> ls\r\n          (keyls)\r\n          (group-by first)\r\n          (map (fn [[k v]] [k (remove keyword? (map second v))]))\r\n          (into {})\r\n     )))", "problem": 105, "user": "502a9fdee4b095a7adb898b4"}, {"code": "(fn [s]\n  (loop [s s r {} l nil c []]\n    (if (= nil s)\n      (if (nil? l)\n        r\n        (assoc r l c))\n      (let [[hd & tl] s]\n        (if (keyword? hd)\n          (if (nil? l)\n            (recur tl r hd [])\n            (recur tl (assoc r l c) hd []))\n          (recur tl r l (conj c hd)))))))", "problem": 105, "user": "50435852e4b034ff00315d22"}, {"code": "(fn [m]\r\n  (second\r\n    (reduce\r\n      (fn [[slot acc] x]\r\n        (if (keyword? x)\r\n          [x    (assoc acc x [])]\r\n          [slot (assoc acc slot (conj (acc slot) x))]))\r\n      [nil {}]\r\n      m)))", "problem": 105, "user": "4dc97aec535d5973398f9284"}, {"code": "(fn key-sequence- [coll]\n  \"105. Given an input sequence of keywords and numbers, create a map                                                                                                  \n  such that each key in the map is a keyword, and the value is a                                                                                                       \n  sequence of all the numbers (if any) between it and the next keyword                                                                                                 \n  in the sequence.\"\n  (loop [[keys values & xs] (partition-by keyword? coll)\n         acc {}]\n    (if (empty? keys)\n      acc\n      (recur xs (merge acc {(last keys) (vec values)} (zipmap (butlast keys) (repeat [])))))))", "problem": 105, "user": "4e5eb843535d8a8b8723a2d4"}, {"code": "#(second (reduce (fn [[k m] e] (if (keyword? e) [e (assoc m e [])] [k (assoc m k (conj (get m k) e))] )) [nil {}] % ))", "problem": 105, "user": "4e9609ad535dbda64a6f6b3e"}, {"code": "(fn f[s]\r\n    (if (empty? s)\r\n      {}\r\n      (let [[k & r] s\r\n            [v n] (split-with number? r)]\r\n        (assoc (f n) k v))))", "problem": 105, "user": "503b6995e4b07a1917cc34dd"}, {"code": "(fn [s]\n  (first \n    (reduce \n      (fn [[r k] v]\n        (if (keyword? v) \n          [(assoc r v []) v] \n          [(update-in r [k] #(conj % v)) k])) \n    [{}] s)))", "problem": 105, "user": "502904e0e4b0feaf66e22fad"}, {"code": "#(loop [[x & y] % kw nil ns [] acc {}]\n    (let [nkw (if (keyword? x) x kw)\n          nns (if (number? x) (conj ns x) [])\n          nacc (if (number? x) acc (conj acc [kw ns]))]\n      (if (not x) (dissoc nacc nil)\n  (recur y nkw nns nacc))))", "problem": 105, "user": "503917a0e4b088a6a14ca763"}, {"code": "(fn [m]\n   (->>\n     m\n     (reduce\n        (fn [y xs] (if (keyword? xs)\n                     ;; create a key / empty list value tuple\n                     (cons [xs []] y)\n                     ;; append value onto the last value list.\n                     (let [[k v] (first y)]\n                       (cons [k (cons xs v)] (rest y)))\n                     ))\n        [])\n      (mapcat (fn [[k v]] [k (reverse v)]))\n      (apply hash-map)\n     ))", "problem": 105, "user": "4f616892e4b0defedf855fbf"}, {"code": "(fn __ [coll]\n  (let  \n    [k (first coll)\n     v (take-while number? (rest coll))]\n    (if-not k\n      {}\n      (conj {k v} (__ (drop (inc (count v)) coll))))))", "problem": 105, "user": "4e6e2ac4535d5021c1a895ff"}, {"code": "(fn  [coll]\n  (reduce (fn [m [ks vs]]\n            (->> (cons [(last ks) vs] (map #(vector % []) (drop-last ks)))\n                 (into m)))\n          {}\n          (->> (partition-by keyword? coll)\n               (partition 2))))", "problem": 105, "user": "4eb8ec4a535dfed6da9c6d4b"}, {"code": "(fn [i] (let [a (partition-by #(if (keyword? %) (rand)) i)\n       b (rest a)]\n  (into {}\n  (filter (fn [[k v]] (keyword? k))\n     (map (fn [[c] d] [c (if (number? (first d)) d [])]) a b)))\n   ))", "problem": 105, "user": "4e43b0d9535dc968683fc4a3"}, {"code": "#(apply zipmap ((fn solve [coll] \r\n  (loop [c coll ret1 [] ret2 []]\r\n    (if (empty? c) (conj [] ret1 (reverse ret2)) \r\n    (if (= (class (first c)) (class :a)) \r\n      (recur (rest c) (conj ret1 (first c)) (conj ret2 []))\r\n      (recur (rest c) ret1 (conj (rest ret2) (conj (first ret2) (first c)))))))) %))", "problem": 105, "user": "503354c3e4b0c6c1199c710c"}, {"code": "(fn [xs]\n  (loop [items xs, acc {}]\n    (if (empty? items ) acc\n      (let [k (first items)\n            [v r] (split-with number? (rest items))]\n        (recur r (assoc acc k (vec v)))))))", "problem": 105, "user": "4f2e0369e4b0d6649770a064"}, {"code": "(fn [xs]\n  (letfn [(to-map [xs m]\n            (if (seq xs)\n              (let [k (first xs)\n                    [v r] (split-with #(not (keyword? %)) (rest xs))]\n                (recur r (assoc m k v)))\n              m))]\n    (to-map xs {})))", "problem": 105, "user": "504e13fce4b078edc5f593bc"}, {"code": "(fn [s]\r\n    (loop [[v & xs] s\r\n           k nil\r\n           m {}]\r\n      (cond (nil? v) m\r\n            (keyword? v) (recur xs v (assoc m v []))\r\n            :else (recur xs k (merge m {k (conj (m k) v)})))))", "problem": 105, "user": "4f58d92fe4b0a7574ea71858"}, {"code": "(fn [coll]\n  (first \n   (reduce\n    (fn [[map keyword] val]\n      (if (keyword? val)\n        [(assoc map val []) val]\n        [(assoc map keyword\n                (conj (get map keyword) val))\n         keyword]))\n    [{} nil]\n    coll)))", "problem": 105, "user": "5014754de4b094324338f8e5"}, {"code": "(fn identify-keys-vals [[k & more]]\n  (if (nil? k)\n    {}\n    (let [[v others] (split-with (complement keyword?) more)]\n      (assoc (identify-keys-vals others) k v))))", "problem": 105, "user": "50586354e4b06522596eba78"}, {"code": "(fn id-k-v [s]\n  (if (empty? s)\n    {}\n    (let [[k & r] s\n          [v remain] (split-with number? r)]\n      (assoc (id-k-v remain) k v))))", "problem": 105, "user": "502a4fdfe4b09dd42f6f3644"}, {"code": "(fn mappify\n    ([vals] (mappify vals nil [] {}))\n    ([[current & rest :as vals] keyword pending done]\n       (if (empty? vals)\n         (-> done\n             (assoc keyword pending)\n             (dissoc nil))\n         (if (keyword? current)\n           (recur rest current [] (assoc done keyword pending))\n           (recur rest keyword (conj pending current) done)))))", "problem": 105, "user": "4dbb0f2d535d1e037afb21b1"}, {"code": "(fn [col]\n  (loop [s {} col col]\n    (if (empty? col)\n         s\n        (recur (conj s [(first col) (take-while number? (rest col))])\n               (drop-while number? (rest col))))))", "problem": 105, "user": "50435689e4b034ff00315d21"}, {"code": "(fn [xs]\n  (loop [acc {} k nil v [] xs xs]\n    (cond \n      (not (seq xs)) (if k (conj acc [k v]) acc)\n      (keyword? (first xs)) (recur (if k (conj acc [k v]) {}) (first xs) [] (rest xs))\n      :else (recur acc k (conj v (first xs)) (rest xs)))))", "problem": 105, "user": "504f865ee4b0a02f9cffde90"}, {"code": "(fn f105 [c]\n  (cond\n\t\t(empty? c) \n\t\t\t{}\n\t\t(not (number? (first c)))\n\t\t\t(assoc \n\t\t\t\t(f105 (rest c))\n\t\t\t\t(first c)\n\t\t\t\t(vec\n\t\t\t\t\t(\n\t\t\t\t\t\t(fn foo [c2] (if (number? (first c2))(cons (first c2)(foo (rest c2)))'()))\n\t\t\t\t\t\t(rest c)\n\t\t\t\t\t) \n\t\t\t\t)\n\t\t\t)\n\t\t:else\n\t\t\t(f105 (rest c))\n\t)\n)", "problem": 105, "user": "4e8d5edd535d65386fec2134"}, {"code": "(fn [s]\n  ((fn [[h ns]] h)\n(reduce (fn [[h ns] e]\n  (if (keyword? e)\n[(assoc h e (reverse ns)) []]\n[h (conj ns e)]))\n[{} []]\n  (reverse s))))", "problem": 105, "user": "4fca2a13e4b0ee37620e184d"}, {"code": "(fn [s]\n  (let [ptnd (partition-by #(if (keyword? %) % false) s)\n        ks (filter keyword? s)]\n    (apply hash-map \n      (loop [ss ptnd r []]\n        (if (empty? ss)\n          r\n          (if (keyword? (first (fnext ss)))\n              (recur (next ss) (conj (conj r (ffirst ss)) []))\n              (recur (nnext ss) (conj (conj r (ffirst ss)) (fnext ss)))))))))", "problem": 105, "user": "503e7f06e4b06c4e0e1fa268"}, {"code": "(fn keyvalues\r\n  [xs]\r\n  (first\r\n   (reduce\r\n    (fn [[acc cur] x]\r\n      (if (keyword? x)\r\n        [(assoc acc x []) x]\r\n        [(update-in acc [cur] conj x) cur]))\r\n    [{} nil]\r\n    xs)))", "problem": 105, "user": "50427899e4b0add3005c0fc2"}, {"code": "(fn [result a]\n  (if (empty? a)\n    result\n    (let [key (first a)\n          [values a2] (split-with (complement keyword?) (rest a))]\n  \t(recur (assoc result key values) a2)))) {}", "problem": 105, "user": "4ee6400c535d93acb0a6685b"}, {"code": "(fn [s]\n(->>\n  (partition-by #(if (keyword? %) % 0) s)\n  (map #(if (keyword? (first %)) (first %) %))\n  (partition 2 1)\n  (filter #(keyword? (first %)))\n  (mapcat #(if (keyword? (second %)) [(first %) []] %))\n  (apply array-map)))", "problem": 105, "user": "50361b6be4b0fbe0a74d26be"}, {"code": "(fn [s]\n  ((fn [r s]\n      (if (empty? s)\n          r\n          (let [vs (take-while number? (next s))]\n            (recur (conj r [(first s) vs]) (drop (inc (count vs)) s))))) {} s))", "problem": 105, "user": "5063fe48e4b075d771da6f9e"}, {"code": "(fn [l] (loop [[x & xs] l, k nil, m {} ]\n            (cond (nil? x) m\n                  (keyword? x) (recur xs x (assoc m x []))\n                  :else (recur xs k (assoc m k (conj (m k) x))))))", "problem": 105, "user": "50563ae2e4b0ce54f56f0405"}, {"code": "(fn [s]\n  (letfn [(a [m,k,v] (assoc m k (conj (m k) v)))\n          (f [[m,k],x] (if (keyword? x) [(assoc m x []),x] [(a m k x),k]))]\n    (first (reduce f [{},nil] s))))", "problem": 105, "user": "504e04a4e4b078edc5f59397"}, {"code": "(fn [s]\n  (reduce (fn [r [k v]]\n            (assoc (into r (zipmap k (repeat []))) (last k) v)) {}\n            (partition 2 (partition-by keyword? s))))", "problem": 105, "user": "50705072e4b07bd6ad9b9f27"}, {"code": "(fn idkeys [x]\n  (loop [input (reverse x) res '{}]\t\n\t\t(cond (empty? input) res\n\t\t\t  :else \n\t\t\t  (let [spliting (split-with #(number? %) input)]\n\t\t\t\t(recur (rest (second spliting)) (assoc res (first (second spliting)) (reverse (first spliting))))\n\t\t\t  )\t\n\t\t)\n\t)\n)", "problem": 105, "user": "50588af1e4b06522596eba7d"}, {"code": "(fn [s]\r\n  (loop [acc {}\r\n    [k & r] s]\r\n      (if-not k acc\r\n        (recur\r\n          (conj acc [k (take-while integer? r)])\r\n          (drop-while integer? r)))))", "problem": 105, "user": "504e14c2e4b078edc5f593bf"}, {"code": "(fn [x]\n  (if (empty? x) {}\n   (apply merge (reverse (map #(identity { (first %) (vec (rest %)) }) (map #(flatten %) (partition 2 (map #(flatten %) (partition-by #(keyword? %) (interpose '() x)\n)))))))))", "problem": 105, "user": "4f2f6678e4b0d6649770a06e"}, {"code": "(fn mapify [ks&vs]\n  (reduce (fn [acc [ks vs]]\n            (reduce #(assoc % %2 '()) (assoc acc (last ks) vs) (butlast ks)))\n          {}\n          (partition 2 (partition-by keyword? ks&vs))))", "problem": 105, "user": "4e8338d6535db62dc21a62d3"}, {"code": "#(apply hash-map\n  ((fn f [s]\n    (when-not (empty? s)\n      (let [k (first s)\n            [v r] (split-with (complement keyword?) (rest s))]\n        (concat (f r) [k v])))) %))", "problem": 105, "user": "506a1985e4b01dc6af13f83e"}, {"code": "(fn [coll]\n    (->> coll\n         (partition-by #(if (keyword? %) % true))\n         (partition 2 1)\n         (mapcat (fn [[[a] [b :as values]]]\n                   (when (keyword? a) [[a (if (keyword? b) [] values)]]))\n                  )\n         (into {})))", "problem": 105, "user": "507056b8e4b07bd6ad9b9f29"}, {"code": "(fn [x] (loop [coll x result {} k :default] \r\n         (cond \r\n           (empty? coll) result\r\n           :else \r\n             (if (keyword? (first coll)) \r\n               (recur (rest coll) (assoc result (first coll) []) (first coll))\r\n               (recur (rest coll) (assoc result k (conj (k result) (first coll))) k)))))", "problem": 105, "user": "4ef2da4f535dced4c769f224"}, {"code": "(fn keys-values2 [coll]\r\n  (loop [res {} prv-keys nil [x & xs]  coll]\r\n    (if x\r\n      (if (keyword? x)\r\n        (recur (assoc res x []) x xs)\r\n        (recur (update-in res [ prv-keys] conj x) prv-keys xs))\r\n      res)))", "problem": 105, "user": "4fb23582e4b081705acca28a"}, {"code": "(fn k [s]\n  (second (reduce (fn [[p m] i]\n            (if (keyword? i)\n              [i (assoc m i [])]\n              [p (update-in m [p] #(conj % i))])) \n          [nil {}] s)))", "problem": 105, "user": "4f3e6244e4b0e243712b1f85"}, {"code": "(fn [s]\n    (loop [k (first s)                  ; assuming here that it'll start with a keyword!\n           s (rest s)\n           m {}\n           sq []]\n      (let [next (first s)]\n       (cond\n        (empty? s) (if (nil? k) m (conj m [k sq]))\n        (keyword? next) (recur next (rest s) (conj m [k sq]) [])\n        (number? next) (recur k (rest s) m (conj sq next))))))", "problem": 105, "user": "50763574e4b0a894bb95bf3d"}, {"code": "(fn [coll]\r\n  (loop [coll coll\r\n         key nil\r\n         val nil\r\n         res {}]\r\n    (cond (empty? coll)\r\n          (if-not (nil? key)\r\n            (conj res {key val})\r\n            res)\r\n\r\n          (nil? key)\r\n          (if (keyword? (first coll))\r\n            (recur (rest coll) (first coll) [] res)\r\n            nil)\r\n\r\n          (keyword? (first coll))\r\n          (recur (rest coll) (first coll) [] (conj res {key val}))\r\n\r\n          :else\r\n          (recur (rest coll) key (conj val (first coll)) res))))", "problem": 105, "user": "4de2f44f535d08e6dec9fdec"}, {"code": "(fn [xs]\n  (loop [x (first xs) s (rest xs) r {} k nil]\n    (if (nil? x)\n      r\n      (if (keyword? x)\n        (recur (first s) (rest s) (assoc r x []) x)\n        (recur (first s) (rest s) (merge-with concat r {k [x]}) k)\n      )\n    )\n  )\n)", "problem": 105, "user": "507eddf4e4b06ce648bcdbfa"}, {"code": "(fn [m]\n  (last\n    (reduce\n      (fn [[current, result], item]\n        (if\n          (keyword? item)\n          [item, (assoc result item [])]\n          [current,\n           (assoc\n             result\n             current\n             (conj\n               (get result current [])\n              item))]))\n      [nil, {}]\n      m)))", "problem": 105, "user": "4f5c0549e4b0030a34fb2b1a"}, {"code": "(fn [s]\n  (first (reduce (fn [[m k] v]\n                   (if (keyword? v)\n                     [(assoc m v []) v]\n                     [(update-in m [k] conj v) k]))\n                 [{} :dummy] s)))", "problem": 105, "user": "4fe84c74e4b07c9f6fd12c3c"}, {"code": "(fn kv [s]\n  (first\n    (reduce \n      (fn [[m k] v] \n        (if (keyword? v) \n          [(assoc m v []) v] \n          [(assoc m k (conj (m k) v)) k]))\n      [{} nil] s)))", "problem": 105, "user": "50901b2ee4b0ea685a20f774"}, {"code": "(fn [c]\n  (loop [[f & r] c, kvm {}]\n    (if (nil? f)\n      kvm\n      (let [[vs l] (split-with (complement keyword?) r)]\n        (recur l (assoc kvm f vs))))))", "problem": 105, "user": "504c8165e4b09724c857af31"}, {"code": "(fn [s]\n  (loop [rst s acc {}]\n    (if (empty? rst)\n      acc\n      (let [fst (first rst)\n            [vals rst] (split-with (complement keyword?) (rest rst))]\n        (recur rst (assoc acc fst vals))))))", "problem": 105, "user": "504f57c7e4b0a02f9cffde71"}, {"code": "(fn k-and-v [s]\n  (let [p2kw (fn [s] (partition 2 (partition-by keyword? s)))\n        rf (fn [acc x] (assoc acc (ffirst x) (if (nil? (first (second x) )) '() (second x) ) ))]\n    (reduce rf {}\n      (p2kw (flatten\n        (for [pair (p2kw s)] (conj (vec (interpose nil (first pair))) (second pair))))))))", "problem": 105, "user": "50783762e4b0fc74642bff67"}, {"code": "(fn f [s]\n  (if (empty? s)\n      {}\n      (assoc (f (drop-while number? (rest s))) (first s) (take-while number? (rest s)))))", "problem": 105, "user": "5054c7e1e4b0b1b9d1860eb2"}, {"code": "#(loop [[h & t] %, k h, r {}]\n  (if\n    h\n    (if (keyword? h)\n      (recur t h (assoc r h []))\n      (recur t k (assoc r k (conj (r k) h))))\n    r))", "problem": 105, "user": "4eabb245535d7eef30807319"}, {"code": "(fn f[s]\n  (loop[k nil s s r {}]\n    (let[h (first s)]\n    (cond (empty? s) r\n          (keyword? h) (recur h (next s) (merge r { h []}))\n          :else (recur k (next s) (merge-with conj r { k h}))))))", "problem": 105, "user": "507c7c8be4b0b083f3ff82ef"}, {"code": "(fn ks [s]\n  (if (empty? s)\n    {}\n    (let [[f & rs] s, [takes drops] (split-with (complement keyword?) rs)]\n      (assoc (ks drops) f takes))))", "problem": 105, "user": "506ab9bae4b05d3b7762c74c"}, {"code": "(fn [ms] \n  (letfn [(vec-split [seq]\n            (if (empty? seq)  \n\t            []\n\t            (let [f (first seq)\n\t\t               [vs rs] (split-with (complement keyword?) (rest seq))]\n\t\t            (cons [f vs]\n\t\t\t            (vec-split rs)))))]\n  (into {} (vec-split ms))))", "problem": 105, "user": "4dd62278535d2dad7130b5c7"}, {"code": "(fn [i] \n  (->> i\n     (partition-by type)\n     (mapcat #(if (keyword (first %))\n             (interpose [] %)\n             (list %)))\n     (apply hash-map)))", "problem": 105, "user": "506617c3e4b03d366d7cb2ab"}, {"code": "(fn [x]\n  (loop [src x result {} temp nil]\n    (cond (empty? src) (conj result temp)\n          (keyword? (first src)) (recur (rest src) (conj result temp) [(first src) []])\n          :else (recur (rest src) result [(first temp) (conj (last temp) (first src))]))))", "problem": 105, "user": "507fbd77e4b089ade05efbd3"}, {"code": "(fn [x]\n (let [xs (partition-by keyword? x)]\n   (apply hash-map (mapcat (fn [a] (if (keyword? (first a)) (interpose [] a) [a])) xs))))", "problem": 105, "user": "5097b556e4b00ad8bab4e970"}, {"code": "(fn [a]\r\n  ((fn [a l]\r\n      (if (empty? a)\r\n  l\r\n\t(let [[b r] ((fn [[x & y]]\r\n\t\t       ((fn [[a & b :as c] l]\r\n\t\t\t  (if (or (empty? c) (keyword? a))\r\n\t\t\t    [[x l] c]\r\n\t\t\t    (recur b (conj l a))))\r\n\t\t\ty []))\r\n\t\t     a)]\r\n\t  (recur r (conj l b)))))\r\n    a\r\n    {}))", "problem": 105, "user": "507437c2e4b054001656acd0"}, {"code": "(fn [l]\r\n  (let [f (fn [[d s v] x] (if (keyword? x) [(if s (assoc d s v) d) x []] [d s (conj v x)]))]\r\n\t\t(first (reduce f [{} nil []] (conj l :a)))))", "problem": 105, "user": "4f8c5f4fe4b02e764a0a5198"}, {"code": "(fn [s]\n    (let [groups (fn groups [ss]\n                   (lazy-seq\n                    (when-let [s (seq ss)]\n                      (cons (first s)\n                            (cons (take-while number? (rest s))             \n                                  (groups\n                                   (drop-while number? (rest s))))))))\n          ]\n      (apply hash-map (groups s))))", "problem": 105, "user": "4daea889edd6309eace4d15b"}, {"code": "(fn [s]\n  (letfn [(read-nums[l,s]\n          (cond\n            (empty? s) [l s] \n            (keyword? (first s)) [l s]\n            :else (read-nums (conj l (first s)) (rest s))))]\n    (loop [ret-map {} start s]\n     (if (empty? start) ret-map\n      (let [k (first start)\n            v  ( read-nums [] (rest start)) ]\n        (recur (assoc ret-map k (v 0)) (v 1))\n          )))))", "problem": 105, "user": "4f4c6b21e4b03ad3f0c10c8f"}, {"code": "(fn [v]\n  (loop [result {} current v last-key nil]\n    (if (empty? current) result\n      (recur\n        (if (keyword? (first current))\n          (if (or (nil? last-key) (contains? result last-key)) \n            result\n            (assoc result last-key []))\n          (assoc result last-key\n            (if (contains? result last-key)\n              (conj (get result last-key) (first current))\n              [(first current)])))\n        (rest current)\n        (if (keyword? (first current))\n          (first current)\n          last-key)))))", "problem": 105, "user": "4dad76588e77d6ed63f12a44"}, {"code": "(fn prob-105 [coll]\n  (loop [h (first coll)\n   t (rest coll)\n\t key h\n\t out {}]\n    (if (nil? h)\n      (reduce #(assoc %1 (first %2) (reverse (second %2))) {} \n              (for [[k v] out]\n                (vector k (remove nil? v))))\n      (recur (first t)\n\t     (rest t)\n\t     (if (keyword? h)\n\t       h\n\t       key)\n             (assoc out key (conj (get out key)\n                                   (if (keyword? h)\n                                     nil\n                                     h)))))))", "problem": 105, "user": "504ec4d3e4b069badc5a33c9"}, {"code": "(fn [v] \n  (first \n    (reduce \n      (fn [[m k] s] \n        (if (keyword? s) \n          [(assoc m s []) s] \n          [(assoc m k (conj (get m k []) s)) k]\n        )\n      ) \n      [{} nil] \n      v\n    )\n  )\n)", "problem": 105, "user": "5098bcfee4b0cae2931060a1"}, {"code": "(fn pb [xs] (if (empty? xs) {} (let [tk (take-while #(not (keyword? %)) (rest xs))] (into {(first xs) tk} (pb (drop (inc (count tk)) xs))))))", "problem": 105, "user": "504f191ae4b0e7ad84dbc4ba"}, {"code": "(fn f [[k & xs]]\r\n  (if k\r\n    (let [[a b] (split-with integer? xs)]\r\n      (into (hash-map k (vec a)) (f b)))\r\n    {}))", "problem": 105, "user": "509c03f3e4b085ae113522a8"}, {"code": "(fn build-map [v]\n  (loop [res {} key (first v) src (rest v)]\n    (if (empty? src)\n      res\n      (let [newone (first src)]\n      (if (keyword? newone)\n      (recur (assoc res newone [])\n             newone\n             (rest src))\n      (recur (assoc res key (conj (get res key []) newone))\n             key\n             (rest src)))))))", "problem": 105, "user": "4dd0e8f7535da60f04a96e57"}, {"code": "(fn [input]\n(loop [[key & others] input\n       result         {}]\n  (if key\n    (let [[values next-input] \n          (split-with (complement keyword?) others)]\n      (recur next-input (assoc result key values)))\n    result)))", "problem": 105, "user": "4f9d53f3e4b0dcca54ed6d21"}, {"code": "(fn [coll]\n    (apply zipmap\n           (reduce\n            (fn [[k v] x]\n              (if (keyword? x)\n                [(cons x k) (cons [] v)]\n                [k  (cons (conj (first v) x) (rest v))]))\n            '([] []) coll)))", "problem": 105, "user": "4f463dfde4b0d56e7bb92b99"}, {"code": "(fn f [xs]\n   (into {} (if (empty? xs) []\n     (cons [(first xs) (vec (take-while #(not (keyword? %)) (drop 1 xs)))] \n           (lazy-seq (f (drop-while #(not (keyword? %)) (drop 1 xs))))))))", "problem": 105, "user": "506406c8e4b075d771da6f9f"}, {"code": "(fn f [[h & s]]\n  (if h \n    (conj (f (drop-while number? s)) \n          [h (take-while number? s)])\n    {}))", "problem": 105, "user": "4f956072e4b0dcca54ed6ccf"}, {"code": "(fn [col]\n  (into {}\n        (reduce\n         (fn [acc v]\n           (if (keyword? v)\n             (cons [v []] acc)\n             (let [[k c] (first acc)] \n               (cons [k (conj c v)]\n                     (rest acc))\n               ))) [] col)))", "problem": 105, "user": "503ca47fe4b06c4e0e1fa24f"}, {"code": "(fn f [s]\n  (if (empty? s)\n    {}\n    (let [[nbs rst] (split-with #(not (keyword? %)) (rest s))]\n      (conj (f rst) {(first s) (vec nbs)}))))", "problem": 105, "user": "5034b0e1e4b062bc5d7ae167"}, {"code": "(fn [ls]\n  ((fn f [ls2]\n    (if (= 0 (count ls2))\n      {}\n      (if (= 1 (count ls2))\n        (reduce into\n          (map #(hash-map % []) (first ls2)))\n        (into\n          (into\n            {(first (reverse (first ls2))) (second ls2)}\n            (reduce into\n              (map #(hash-map % [])\n                (rest (reverse (first ls2))))\n              {}))\n          (f (drop 2 ls2))))))\n    (partition-by keyword? ls)))", "problem": 105, "user": "4fb1325de4b081705acca276"}, {"code": "#(second\n  (reduce\n    (fn [[k m] x]\n      (if (keyword? x)\n          [x (merge m {x []})]\n          [k (merge-with conj m {k x})])) [nil {}] %))", "problem": 105, "user": "50acbd15e4b071b89ef26234"}, {"code": "(fn [ l ] \n  (loop [ acc {} remains l]\n    (if (empty? remains)\n      acc\n      (let [ nkw #(not (keyword? %))\n             kw (first remains)\n             rst (rest remains)\n             kwv (take-while nkw rst)\n             rms (drop-while nkw rst)\n            ] \n        (recur (assoc acc kw kwv) rms) \n      ))))", "problem": 105, "user": "50956c2be4b087f34d351ab2"}, {"code": "#(reduce (fn [m r] (if (keyword? r) (assoc m r []) (let [[k v] (last m)] (assoc m k (conj v r))))) (sorted-map) %)", "problem": 105, "user": "5027b41ee4b01614d1633fee"}, {"code": "(fn c ([s] (c {} (drop-while number? s) nil)) ([m s k] (if (seq s) (let [n (first s)] (if (keyword? n) (recur (assoc m n []) (rest s) n) (recur (assoc m k (conj (get m k) n)) (rest s) k))) m)))", "problem": 105, "user": "50c75d38e4b00bb60fe0c532"}, {"code": "#(loop [k nil r {} c %]\n  (if (empty? c)\n    r\n    (let [a (first c) b (next c) v (r k)]\n      (if (keyword? a)\n          (recur a (assoc r a [])  b)\n          (recur k (assoc r k (conj v a)) b)  \n      )\n    )\n  )\n)", "problem": 105, "user": "50921f9ae4b09a7d0b586de1"}, {"code": "(fn identify-keys-and-vals [v]\n  (reduce (fn [m [keys val]]\n            (-> m\n                (assoc (last keys) val)\n                (into (zipmap (drop-last keys) (repeat [])))))\n          {}\n          (partition 2 \n                     (partition-by keyword? v))))", "problem": 105, "user": "50812debe4b01a93d3f38e4c"}, {"code": "#(first (reduce (fn [[m k] x]                                                          \n          (if (keyword? x)\n            (list (assoc m x []) (conj k x)) \n            (list (merge-with conj m {(last k) x}) k)))\n        '({} []) %))", "problem": 105, "user": "50996a38e4b0cae2931060b3"}, {"code": "(fn [l]\n  (let [f #(if (keyword? %) % true)\n        p (partition-by f l)]\n    (loop [p p\n           x {}]\n      (cond\n       (= p ()) x\n       (= true (f (first (second p)))) (recur (drop 2 p)\n                                     (assoc x (first (first p)) (second p)))\n       :else (recur (rest p)\n                    (assoc x (first (first p)) []))))))", "problem": 105, "user": "50a83315e4b054305ba5a830"}, {"code": "#((fn p [m k y]\n    (if (empty? y)\n      m\n      (let [f (first y)\n            r (rest y)]\n        (if (keyword? f)\n          (p (merge-with concat m {f []}) f r)\n          (p (merge-with concat m {k [f]}) k r))))) {} (first %) (rest %))", "problem": 105, "user": "507ef25ce4b0f753b6f9788e"}, {"code": "(fn f \n  ([l] (f l {} :a))\n  ([[p & qs] m k] (if p \n          (if (keyword? p) \n            (f qs (assoc m p '[]) p)\n            (f qs (merge-with \n                         (fn [x y] (vec (concat x y))) \n                         m {k [p]}) k))\n                    m)))", "problem": 105, "user": "4eb2eae5535d7eef30807351"}, {"code": "(fn [xs]\n  ((fn [xs k acc]\n     (if (empty? xs) acc\n       (let [x (first xs) xs' (rest xs)]\n         (if (keyword? x) (recur xs' x (assoc acc x []))\n           (recur xs' k (update-in acc [k] #(conj % x)))))))\n     xs :d {}))", "problem": 105, "user": "508157b2e4b0946d0443855c"}, {"code": "(fn test105-1 [coll]\n  (loop [s coll result {}]\n    (if (empty? s)\n      result\n      (let [k (first s)\n            [v rst] (split-with\n                     (complement keyword?)\n                     (rest s))]\n        (recur rst (conj result {k v}))))))", "problem": 105, "user": "50b0cffae4b009df37c708c5"}, {"code": "(fn [s]\n           (loop [r s res {}]\n              (if (empty? r)\n                  res\n                  (let [k (split-with keyword? r)\n                       l (split-with number? (last k))\n                       m (->> (butlast (first k))\n                              (map #(into {} {% []}))\n                              (#(into % (into {} {(last (first k)) (first l)}))))\n                       ]\n                       (recur (last l) (into res m))))))", "problem": 105, "user": "4f03f197535dcb61093f6b84"}, {"code": "#((reduce\n   (fn [a b]\n     (if\n       (keyword? b)\n       (assoc a :x b :a (assoc (a :a) b []))\n       (update-in a [:a (a :x)] conj b)))\n   {:a {}} %)\n  :a)", "problem": 105, "user": "50548ce8e4b0b1b9d1860ead"}, {"code": "(fn [xs]\n  (let [fixed (concat\n                (flatten\n                  (map #(if (every? keyword? [% %2]) [% nil] %) xs (drop 1 xs)))\n                [(last xs)])\n        parts (partition-by keyword? fixed)]\n    (into {} (map\n               (fn [[[k] vs]] [k (if (= [nil] vs) [] vs)])\n               (partition 2 parts)))))", "problem": 105, "user": "50cb4cf6e4b0f78a8e1645b4"}, {"code": "(fn mkmap [s]\n  (if (empty? s)\n    {}\n    (let [k (first s)\n          v (take-while #(not (keyword? %)) (rest s))\n          rest-s (drop-while #(not (keyword? %)) (rest s))]\n      (conj (mkmap rest-s) [k v]))))", "problem": 105, "user": "4ff769bce4b0678c553fc38f"}, {"code": "(letfn\n  [(r [[m k v] n]\n            (if (keyword? n)\n              (if (nil? k)\n                [m n []]\n                [(assoc m k v) n []])\n              [m k (conj v n)]))]\n  (fn [s]\n    (let [[m k v] (reduce r [{} nil []] s)]\n      (if (nil? k) m (assoc m k v)))))", "problem": 105, "user": "4e03c616535d04ed9115e796"}, {"code": "(fn [coll] (reduce (fn [m v] \n          (if (keyword? v)\n            (assoc-in m [v] [])\n            (update-in m \n                       [(first (last m))] \n                       #(conj % v))))\n        (sorted-map) coll))", "problem": 105, "user": "50310b8be4b05b7df5a0b84d"}, {"code": "(fn \n  [col]\n  (if (seq col)\n  (letfn [(f [remaining kw kw-val m]\n             (if (empty? remaining) \n               (merge m {kw kw-val})\n               (let [item (first remaining)\n                     ]\n                 (if (keyword? item)\n                   (recur (rest remaining) item [] (merge m {kw kw-val}))\n                   (recur (rest remaining) kw (into kw-val (vector item)) m)\n                   ) ; if\n                 ) ; let\n               ) ; if\n             ) ; fn f\n          ]\n    (f (rest col) (first col) [] {})\n    ) ; letfn\n   {})\n  ) ; fn", "problem": 105, "user": "5021f0b3e4b00bba4502f7ac"}, {"code": "(fn keys-and-values [coll]\n  (reduce\n    (fn [ret x]\n      (if (keyword? x) (assoc ret x [])\n        (let [[y z] (first ret)]\n          (assoc ret y (conj z x)))))\n      {} coll))", "problem": 105, "user": "5084c43be4b0fb8f40674bfa"}, {"code": "(fn [v]\n  (if (empty? v) {}\n  (into {} (map #(if (= [[]] (second %)) [(first %) []] (vec %)) (partition 2 (reduce\n   #(if (keyword? (first %2))\n      (conj %1 (first %2))\n      (conj %1 (vec %2)))\n  [] (partition-by keyword? (reduce\n                              #(if (and (keyword %2) (keyword? (last %1)))\n                                 (conj %1 [] %2)\n                                 (conj %1 %2))\n                              [] v))))))))", "problem": 105, "user": "50733b31e4b0e3170b5a869a"}, {"code": "(fn [coll]\n    (into {}\n      (reduce\n        (fn [a b]\n          (if (keyword? b)\n            (conj a [b []])\n            (let [xs (butlast a) x (last a)]\n              (vec (conj xs [(first x) (conj (second x) b)] )))))\n        []\n        coll)))", "problem": 105, "user": "4ee77f15535d93acb0a66868"}, {"code": "#(apply hash-map\n        (mapcat \n          (fn [[x :as c]] (if (keyword? x) (interpose [] c) [c])) \n          (partition-by keyword? %)))", "problem": 105, "user": "500aa15ee4b03d00572d2d76"}, {"code": "(fn final-map [v]\n  (let [q (into {} (map (partial into [] ) \n                (partition 2 (mapcat #(if (and (> (count %) 1) (keyword? (first %)))\n                                        (concat \n                                          (mapcat (fn [it] (list (list it) '())) (drop-last 1 %))\n                                          (list (list (last %)))\n                                          )\n                                        (list %))\n                                     (partition-by keyword? v)))))]\n    (into {} (map #(vector (ffirst %) (second %)) q))))", "problem": 105, "user": "50e87427e4b0ebbe794eb7e8"}, {"code": "(fn [v] \n  (into {} (reduce \n    #(if (keyword? %2) \n\t     (conj % [%2 []] ) \n\t\t (conj (pop %) [(-> % peek first) (conj (-> % peek peek) %2)]))  [] v)))", "problem": 105, "user": "50d0d4c8e4b00b15ecee976a"}, {"code": "(fn [coll]\n    (loop [coll coll result {}]\n      (if (empty? coll) result\n          (recur (drop-while number? (next coll))\n                 (assoc result (first coll)\n                        (vec (take-while number? (next coll))))))))", "problem": 105, "user": "50bca033e4b0594b91591c5d"}, {"code": "(fn [s]\n  (into {} \n     (reduce \n      (fn [s i] (if (keyword? i) (cons [i []] s) (cons [(first(first s)) (conj (second(first s)) i)] (rest s))))\n      [] s)))", "problem": 105, "user": "50ef9a7ae4b0bdaecbb47d9e"}, {"code": "(fn [coll]\n  (apply\n    hash-map\n    (map\n      #(if (or (keyword? (first %)) (vector? (first %))) (first %) %)\n      (partition-by\n        #(if (keyword? %) % false)\n        (reduce\n          #(if (and (keyword? %2) (keyword? (last %)))\n          (conj % [] %2) (conj % %2)) [] coll)))))", "problem": 105, "user": "4f253a49e4b0d66497709ff3"}, {"code": "(fn keys-and-vals [s]\n  (if (seq s)\n    (let [k (first s)\n          nums (take-while number? (rest s))\n          rs (drop-while number? (rest s))]\n      (into {k nums} (keys-and-vals rs)))\n    {}))", "problem": 105, "user": "50a7ef7fe4b090657f4a5ce0"}, {"code": "(fn [s]\n  (:map\n  (reduce\n   (fn [{:keys [map sym] :as sofar} el]\n     (if (keyword? el)\n       (assoc sofar :sym el :map (assoc map el []))\n       (assoc sofar :map (merge-with into map {sym [el]}))))\n   {:map {}}\n   s)))", "problem": 105, "user": "4ffc10aae4b0678c553fc3d6"}, {"code": "(fn [v] (let [temp (map #(first %) (filter #(and (keyword? (first %))\n                                                                      (not= 1 (count %)))\n                                                        (partition-by keyword? v)))]\n          (merge (apply hash-map (map #(if (keyword? (first %))\n               \t                 (if (= 1 (count %))\n                                     (first %)\n                   \t               (last %))\n                    \t\t    %)\n                     (partition-by keyword? v)))\n                      \n                (apply hash-map (if (empty? temp)\n                                  []\n                                  (concat temp [[]]))))))", "problem": 105, "user": "5092fe10e4b097f48cc3857e"}, {"code": "(fn iden [c]\n  (if (empty? c)\n    {}\n    (into {(first c) (vec (take-while number? (rest c)))}\n            (iden (drop-while number? (rest c))))))", "problem": 105, "user": "509160dae4b0742c82730aef"}, {"code": "(fn [arr]\n   (apply hash-map (reduce (fn [r n] \n       (if (keyword? n) \n        (concat r [n []])\n        (concat (butlast r) [(concat (last r) [n])])))\n           [] arr)\n   ))", "problem": 105, "user": "50de11b2e4b061dbdced7217"}, {"code": "(fn [s] (reduce #(if (keyword? %2) (assoc % %2 [])\n                   (assoc % (first (first %)) (conj (second (first %)) %2)))\n                {} s))", "problem": 105, "user": "50dfb660e4b061dbdced7228"}, {"code": "(fn [s]\n  (apply hash-map (reduce \n    (fn [c x] (if (keyword? x) (conj c x []) (conj (pop c) (conj (peek c) x))))\n    []\n    s)))", "problem": 105, "user": "4db2cd84535df7e46ed9b6c6"}, {"code": "#(loop [v % m {}]\n  (if (empty? v) m\n      (recur \n       (drop-while number? (rest v))\n       (conj m {(first v) (take-while number? (rest v))}))))", "problem": 105, "user": "4e57d1e2535d8a8b8723a289"}, {"code": "(fn [m]\n  (second\n    (reduce\n      (fn [[slot acc] x]\n        (if (keyword? x)\n          [x    (assoc acc x [])]\n          [slot (assoc acc slot (conj (acc slot) x))]))\n      [nil {}]\n      m)))", "problem": 105, "user": "50bc23e4e4b0594b91591c3c"}, {"code": "(fn [v]\n  (apply hash-map\n         (reduce #(if (keyword? %2) (conj % %2 []) (conj (vec (butlast %)) (conj (last %) %2))) [] v)))", "problem": 105, "user": "500854c4e4b028e089d3518c"}, {"code": "(fn f [c]\n  (if (empty? c)\n    {}\n    (let [[h & t] c\n          [v r] (split-with number? t)]\n      (merge {h v} (f r)))))", "problem": 105, "user": "4ebaf790535dfed6da9c6d6e"}, {"code": "(fn f [m [k & r]] (let [[v l] (split-with #(not (keyword? %)) r)] (if (seq r) (f (assoc m k v) l) m) )) {}", "problem": 105, "user": "4ff67852e4b0678c553fc37e"}, {"code": "(fn [r [k & m]]                                                                                                                                             \n    (let [[v t] (split-with number? m)                                                                                                                        \n          r  (into r (when k [[k v]]))]                                                                                                                       \n      (if (seq t)                                                                                                                                             \n        (recur r t)                                                                                                                                           \n        r)))                                                                                                                                                  \n{}", "problem": 105, "user": "510c1dd5e4b078ea71921113"}, {"code": "(fn boo\n  ([[x & xs]] (if (nil? x) {} (boo xs x [] {})))\n  ([[x & xs] kword local accu] \n   (cond\n    (nil? x) (conj accu {kword local})\n    (keyword? x) (recur xs x [] (conj accu {kword local}))\n    :else (recur xs kword (conj local x) accu))))", "problem": 105, "user": "50217818e4b00bba4502f7a7"}, {"code": "(fn _ [c]\n    (loop [f (first c), z (next c), m {}, r {}]\n        (cond\n          (nil? f) (into r m)\n          (keyword? f) (recur (first z) (next z) {f '()} (into r m))\n          :else (recur (first z) (next z) (merge-with concat m {(first (keys m)) (list f)}) r)\n          )))", "problem": 105, "user": "4f038567535dcb61093f6b0c"}, {"code": "(fn [vec]\n  (loop [acc {} rem vec]\n    (if (empty? rem) acc\n        (recur\n          (assoc acc (first rem) (take-while number? (rest rem)))\n          (drop-while number? (rest rem))))))", "problem": 105, "user": "4f0446f9535dcb61093f6bb8"}, {"code": "(fn f [s & [m]] (if (empty? s)\n                  (or m {})\n                  (f (drop-while #(not (keyword? %)) (rest s))\n                     (assoc (or m {})\n                       (first s)\n                       (take-while #(not (keyword? %)) (rest s))))))", "problem": 105, "user": "50ed4626e4b01236b1d4983c"}, {"code": "(fn [coll]\n  (->> (interpose nil coll)\n       (partition-by keyword?)\n       (map #(if (keyword? (first %)) (first %) (remove nil? %)))\n       (apply hash-map)))", "problem": 105, "user": "50e3e108e4b01912b3285c48"}, {"code": "(fn [coll]\n  (loop [parted (partition-by keyword? coll)\n         acc {}]\n    (if-not (seq parted)\n      acc\n      (let [[[ks vs] rst] (split-at 2 parted)\n            empty-maps (zipmap (butlast ks) (repeat []))\n            full-map {(last ks) (vec (or vs []))}]\n        (recur rst (merge acc empty-maps full-map))))))", "problem": 105, "user": "50d93c53e4b0fd36a4b89223"}, {"code": "(fn [coll]\n  (loop [acc {}\n         coll coll]\n    (if (empty? coll)\n      acc\n      (recur\n       (assoc acc (first coll) (take-while number? (rest coll)))\n       (drop-while number? (rest coll))))))", "problem": 105, "user": "51195e77e4b055cfb310d499"}, {"code": "(fn [vc]\n   (loop [c vc r {}]\n     (if (empty? c) r\n       (let [k (first c) v (vec (take-while #(not (keyword? %)) (rest c))) n (inc (count v))]\n         (recur (nthrest c n) (assoc r k v))))))", "problem": 105, "user": "50bce014e4b0594b91591c63"}, {"code": "(fn [list]\n   (apply hash-map (mapcat \n                     (fn [e]\n                       (if (keyword? (first e))\n                         (butlast(interleave e (repeat [])))\n                         [e])) (partition-by type list))))", "problem": 105, "user": "50d3b03fe4b030b634c368b9"}, {"code": "(fn [s]\n  (:result\n   (reduce\n    (fn [acc x]\n      (if (keyword? x)\n        (-> acc\n            (update-in [:result] assoc x [])\n            (assoc-in [:key] x))\n        (update-in acc [:result (:key acc)] conj x)))\n    {:result {} :key nil}\n    s)))", "problem": 105, "user": "510db6cde4b078ea71921145"}, {"code": "(fn [c]\n  (apply hash-map\n         ((fn mysplitter\n            [coll]\n            (when-let [s (seq coll)]\n              (let [k (first s)\n                    nr (take-while number? (next s))\n                    l (+ 1 (count nr))]\n                (cons k (cons (vec nr) (mysplitter (drop l s))))))) c)))", "problem": 105, "user": "4e8768f6535dceadca469850"}, {"code": "(fn f [xs]\n  (if (empty? xs) {}\n    (let [[cur, rst] (split-with (comp not keyword?) (rest xs))]\n      (into {(first xs) cur} (f rst)))))", "problem": 105, "user": "510acd6ee4b078ea719210f4"}, {"code": "(fn [input-seq]\n    (let [partitioned-seq (partition-by #(class %) input-seq)\n          no-val-keywords (apply concat (keep #(when (= clojure.lang.Keyword (class (first %)))\n                                                 (butlast %))\n                                              partitioned-seq))\n          kws-and-vals (map #(if (= clojure.lang.Keyword (class (first %)))\n                               (last %)\n                               %)\n                            partitioned-seq)\n          map-1 (apply hash-map kws-and-vals)\n          map-2 (zipmap no-val-keywords (repeat []))]\n      (merge map-1 map-2)))", "problem": 105, "user": "51281b25e4b03a34742b4304"}, {"code": "(fn ikv [v]\n  (if (empty? v)\n    {}\n    (loop [r {}\n         v v\n         k nil\n         p []]\n    (cond \n     (nil? (first v)) (assoc r k (vec p))\n     (nil? k) (recur r (rest v) (first v) p)\n     (keyword? (first v)) (recur (assoc r k (vec p)) (rest v) (first v) [])\n     :else (recur r (rest v) k (concat p [(first v)]))))))", "problem": 105, "user": "5123ac8ee4b061b4c6f0e0b1"}, {"code": "(fn [v]\n  (into {} (reduce \n    #(if (keyword? %2)\n       (cons [%2 []] %1)\n       (let [[k v] (first %1)]\n         (cons [k (conj v %2)] (rest %1)))) \n    '() v)))", "problem": 105, "user": "50fbdacfe4b0d10d794c19f0"}, {"code": "(fn idkv [coll]\n  (loop [coll coll,\n         curkey (first coll),\n         curval [],\n         result {}]\n    (if (empty? coll)\n      result\n      (if (keyword? (first coll))\n        (recur (rest coll) (first coll) (empty curval) (assoc result (first coll) []))\n        (recur (rest coll) curkey (conj curval (first coll)) (assoc result curkey (conj curval (first coll))))))))", "problem": 105, "user": "512474ede4b02c3f2a072cce"}, {"code": "(fn solution [liste]\n  (let [eins (first liste)]\n   (if (empty? liste) \n    {}\n\t(if (keyword? eins)\n\t\t(merge (assoc {} eins (take-while #(not (keyword? %)) (rest liste )))\n               (solution (drop-while #(not (keyword? %)) (rest liste))))\n\n      \n      )\n    )\n  )\n)", "problem": 105, "user": "4e2164ff535d04ed9115e815"}, {"code": "(fn [l]\n  (apply hash-map (mapcat\n                    (fn [[k :as v]]\n                      (if (keyword? k) (interpose [] v) [v]))\n                    (partition-by type l)))\n  )", "problem": 105, "user": "4fbbcf0ce4b081705acca2ee"}, {"code": "#(loop [accum {} coll %1 f (first coll) k nil]\n   (cond (empty? coll) accum \n         (keyword? f) (recur (merge accum {f []}) (rest coll) (second coll) f)\n         :default (recur (merge-with conj accum {k f}) (rest coll) (second coll) k)))", "problem": 105, "user": "4e823f41535db62dc21a62c8"}, {"code": "(fn idkv\n  [s]\n  (let [d (vec (partition-by #(if (keyword? %) % false) s))\n        e (if (keyword? (last d))\n            (conj d '())\n            d)\n        f (map #(if (keyword? (first %)) (first %) %) e)]\n    (loop [g f\n           h {}]\n      (if (empty? g)\n        h\n        (if (and (keyword? (second g)) (keyword? (first g)))\n          (recur (rest g) (assoc h (first g) '()))\n          (recur (rest (rest g)) (assoc h (first g) (second g))))))))", "problem": 105, "user": "4f17ab99535d64f603146457"}, {"code": "(fn ident [xs]\n  (loop [in xs\n         out {}]\n    (if (empty? in)\n      out\n      (let [k (first in)\n            vs (take-while #(not (keyword? %)) (rest in))]\n        (recur (drop (inc (count vs)) in) (assoc out k vs))))))", "problem": 105, "user": "51365524e4b04ac1f358dd52"}, {"code": "(fn idkv [s]\n    (loop [[v & xs] s\n           k nil\n           r {}]\n      (cond (nil? v) r\n            (keyword? v) (recur xs v (assoc r v []))\n            :else (recur xs k (merge r {k (conj (r k) v)})))))", "problem": 105, "user": "50e4f4e9e4b049a987753896"}, {"code": "(fn [coll] (into {} \n            (map (fn [[k v]] (vector k (if (keyword? v) [] (vec v)))) \n                 (filter #(keyword? (first %))\n                         (partition 2 1 \n                                    (map #(if (keyword? (first %)) (first %) %) \n                                         (partition-by #(if (keyword? %) % nil) coll)))))))", "problem": 105, "user": "513a4babe4b067e25a345eca"}, {"code": "(fn [seq]\n   (if (empty? seq)\n     {} \n   (loop [result {} temp-key [(first seq)] temp-val [] elements (rest seq)]\n      (if elements\n        (recur\n          (if (keyword? (first elements))\n               (into result {(first temp-key) temp-val} )\n               result\n              )\n          (if (keyword? (first elements))\n              [ (first elements)] \n              temp-key\n              )\n          (if (keyword? (first elements))\n              [] \n              (conj temp-val (first elements)) \n              )\n           (next elements))\n        (into result {(first temp-key) temp-val} )\n        )\n     )\n   )\n   )", "problem": 105, "user": "5106dc1be4b01150e115ebf0"}, {"code": "#(second (reduce (fn [[l m] e] (if (keyword? e)\n                         [e (assoc m e [])]\n                         [l (update-in m [l] conj e)])) [:? {}] %))", "problem": 105, "user": "4f1bb9d8535d64f60314647d"}, {"code": "(fn [xs]\n  (loop [xs (seq xs) kw nil m {}]\n    (if-let [[item & more] xs]\n      (if (keyword? item)\n        (recur more item (assoc m item []))\n        (recur more kw (update-in m [kw] conj item)))\n      m)))", "problem": 105, "user": "511442d0e4b0e9c109bb74d5"}, {"code": "(fn [xs] (apply\n          hash-map\n          (reduce\n           (fn [ys y] (let\n                        [z  (last ys)\n                         zs (-> ys butlast vec)]\n                        (apply conj\n                               (if (keyword? y)\n                                 [ys y []]\n                                 [zs (conj z y)]))))\n           []\n           xs)))", "problem": 105, "user": "51307b84e4b08c712d3fae39"}, {"code": "(fn [v]\n  (\n   (fn hej [v s]\n     (if (empty? s)\n       {}\n       (if (number? (ffirst s))\n         (recur (first s) (rest s))\n         (merge {(ffirst s) (vec v)} (hej [] (rest s))))))\n   [] (reverse (partition-by #(if (number? %) 0xdeadbeef %) v))))", "problem": 105, "user": "504e12ade4b078edc5f593b7"}, {"code": "(fn aa [ix] (loop [x ix y {}]\n      (if (empty? x) y\n        \n      (let [z (first (keep-indexed #(if ((complement number?) %2) %1) (rest x)))]\n           (if (= z nil) (assoc y (first x) (rest x))\n        \t\t(recur  \n           \t\t\t(drop z (rest x))\n           \t\t\t(assoc y (first x) (take z (rest x))) \n          \t\t)\n            )\n       )\n      )\n     )\n  )", "problem": 105, "user": "5105ed16e4b01150e115ebe2"}, {"code": "(fn [c]\n    (first\n      (reduce (fn [[m k] v]\n                (if (keyword? v)\n                  [(assoc m v []) v]\n                  [(update-in m [k] #(conj % v))\n                   k])) \n              [{} nil] c)))", "problem": 105, "user": "4f410b63e4b0e243712b1fc5"}, {"code": "(fn mapseqs [s] (if (empty? s) {} (apply merge (map #(hash-map (first %) (vec (rest %))) (reduce #(if (keyword? %2) (conj % (vector %2)) (if (> (count %) 1) (concat (butlast %) (vector (conj (last %) %2))) (vector (conj (last %) %2)))) (cons [] s))))))", "problem": 105, "user": "5138d08be4b0a5db03d727db"}, {"code": "(fn p105\n  ([xs] (p105 xs {}))\n  ([ [l & xs] m]\n     (if (nil? l) m\n         (let [ [nums rst] (split-with number? xs)]\n           (recur rst (assoc m l (vec nums)))))))", "problem": 105, "user": "50fa01bce4b07934dda8b0ba"}, {"code": "(fn b [n]\n  (loop [nn n\n         a {}]\n    (if (empty? nn)\n      a\n      (recur (drop-while #(not (keyword? %)) (rest nn)) (assoc a (first nn) (take-while #(not (keyword? %)) (rest nn)))))))", "problem": 105, "user": "4fe97adde4b0547ebccb245e"}, {"code": "(fn p105 [coll]\n  (let [s (partition-by keyword? coll)\n        f (fn [[k :as v]]\n               (if (keyword? k)\n                 (interpose [] v)\n                 [v]))]\n    (apply hash-map (mapcat f s))))", "problem": 105, "user": "5125745ae4b05d10e3e395f9"}, {"code": "(fn ikv\n  ([s] (ikv nil s {}))\n  ([c s m] (cond\n            (empty? s) m\n            (keyword? (first s)) (recur (first s) (rest s) (assoc m (first s) []))\n            :else (recur c (rest s) (assoc m c (conj (m c) (first s)))))))", "problem": 105, "user": "4e9a1512535dbda64a6f6b6e"}, {"code": "#(apply hash-map (loop [c % a []]\n  (if (not (seq c)) a\n    (recur (rest c)\n           (let [n (first c)]\n             (if (keyword? n) (conj a n [])\n               (conj (vec (drop-last a)) \n                     (conj (last a) n))))))))", "problem": 105, "user": "512f06c5e4b0762be4c7aad7"}, {"code": "(fn [s]\n  (reduce #(assoc % (first %2) (second %2)) {} \n          (reduce #(if (keyword? %2)\n                     (conj % (vector %2 []))\n                     (concat (rest %)\n                             (conj [] (vector (first (first %))\n                                              (conj (second (first %)) %2))))) [] s)))", "problem": 105, "user": "512eb723e4b0b740abc5982b"}, {"code": "(fn [m]\n  (loop [m m r [] last-type nil eles []]\n    (cond (and (empty? m) (not (nil? last-type))) (apply hash-map (conj r eles))\n          (empty? m) (apply hash-map r)\n          (and (= last-type :keyword) (keyword? (first m))) (recur (rest m) (conj r [] (first m)) :keyword [])\n          (and (keyword? (first m)) (nil? last-type)) (recur (rest m) (conj r (first m)) :keyword [])\n          (keyword? (first m)) (recur (rest m) (conj r eles (first m)) :keyword [])\n          :else (recur (rest m) r :ele (conj eles (first m))))))", "problem": 105, "user": "4fdf566fe4b05e33b9224f99"}, {"code": "(fn ![a]\n  (if (seq a)\n      ((fn [[s b]] (assoc (! b) (first a) s))\n       (split-with number? (next a)))\n    {})\n)", "problem": 105, "user": "4f296a80e4b0d6649770a02a"}, {"code": "(fn [n]\n  (->> n (partition-by #(if (integer? %) true %))\n        (reduce (fn [lst n] (if (and (keyword? (last  lst)) (keyword? (last n)))\n                     (conj  lst [] (first n) )\n                     (conj  lst (if (keyword? (first n) ) (first n) n  ))\n                  ) )[] )\n        (apply hash-map)\n        \n        )\n  )", "problem": 105, "user": "5124619ae4b02c3f2a072ccd"}, {"code": "(fn [in] (loop [x  (first in)\n                 xs (next in)\n                 out {}]\n            (if xs\n              (if (number? (first xs))\n                (recur x (next xs) (assoc out x (conj (get out x []) (first xs))))\n                (recur (first xs) (next xs) (assoc out (first xs) [])))\n              out)))", "problem": 105, "user": "513d121fe4b0e544971636a2"}, {"code": "(fn [s] \n(into {}\n(mapcat \n (fn [[x y]]\n  (concat (map #(vector % []) (drop-last x)) \n          [[(last x) (into [] y)]]\n          )\n  )\n(apply hash-map (partition-by keyword? s))\n )\n)\n)", "problem": 105, "user": "514457fbe4b0b4fb4ace5f43"}, {"code": "(fn [xs]\n  (reduce (fn [m s]\n            (let [[k v] s]\n              (if (number? k)\n                (conj m {})\n                (if (keyword? v)\n                  (conj m {k []})\n                  (conj m {(first s) (rest s)})))))\n  {} (map #(apply concat %) (partition 2 1 (partition-by keyword xs)))))", "problem": 105, "user": "515a6151e4b0394f658fe241"}, {"code": "(fn pr105\n  ([v] (pr105 v {}))\n  ([vs m]\n\t (if (empty? vs)\n\t     m\n\t   (recur (drop-while (comp not keyword?) (rest vs))\n\t\t  (assoc m (first vs) (take-while (comp not keyword?) (rest vs)))))))", "problem": 105, "user": "5142ea50e4b0c172af7558ca"}, {"code": "#(->> %\n      (interpose nil)\n      (partition-by keyword?)\n      (partition 2)\n      (mapcat (fn [[k v]] [(first k) (filter (complement nil?) v)]))\n      (apply hash-map))", "problem": 105, "user": "50479524e4b0371827a27bc4"}, {"code": "(fn keyvals [ l ]\n  (loop [lst l curk nil partRslt {} ]\n    (let [hd (first lst) body (rest lst)]\n      (if (nil? hd)\n        partRslt\n        (if (= clojure.lang.Keyword (type hd))\n          (recur body hd (assoc partRslt hd []))\n          (recur body curk (update-in partRslt [curk] (fnil conj []) hd)))))))", "problem": 105, "user": "513cb853e4b0b86ece9f322b"}, {"code": "(fn [x]\n  (loop [[h & t] x, r {}]\n    (if h\n      (recur (drop-while (complement keyword?) t)\n             (assoc r h (take-while (complement keyword?) t)))\n      r)))", "problem": 105, "user": "4f21838fe4b0d66497709fd2"}, {"code": "(fn   [coll]\n  (last (reduce (fn [[k res] item]\n              (println \"k: \" k \", res\" res \", item: \" item)\n              (if (keyword? item)\n                  [item (assoc res item [])]\n                [k (update-in res [k] conj item)]))\n           [(first coll) {}] coll)))", "problem": 105, "user": "4f7d25b4e4b06e829148e1ba"}, {"code": "(fn create-map [coll]\n (apply hash-map\n   (map #(if (number? (first %))\n             (vec %)\n             (if (seq? (first %))\n                 (vec (first %))\n                 (first %)))\n  (partition-by keyword?\n  (mapcat identity \n  (map #(if (and (not= 1 (count %)) (keyword? (first %)))\n          (rest (interleave (repeat '()) %))\n          %) \n       (partition-by keyword? coll)))))))", "problem": 105, "user": "50c8697ce4b00bb60fe0c53f"}, {"code": "(fn id-keys-vals [items]\n  (let [splits (partition-by type items)\n        kws (take-nth 2 splits)\n        vls (take-nth 2 (rest splits))\n        kwmap (into {} (for [k (flatten kws)]\n                          {k []}))\n        result (into kwmap (apply hash-map (interleave (map last kws) vls)))\n        ]\n    result\n    )\n)", "problem": 105, "user": "510cd1dde4b078ea71921124"}, {"code": "(fn [l]\n  (loop [result {} current-key nil l l]\n    (if (seq l)\n      (if (keyword? (first l))\n        (recur (assoc result (first l) []) (first l) (rest l))\n        (recur (assoc result current-key (conj (current-key result) (first l))) current-key (rest l)))\n      result)))", "problem": 105, "user": "50b1d166e4b03ea880433554"}, {"code": "#(case %\n   [] {}\n   [:a 1] {:a [1]}\n   [:a 1 :b 2] {:a [1] :b [2]}\n   [:a 1 2 3 :b :c 4] {:a [1 2 3] :b [] :c [4]}\n)", "problem": 105, "user": "5088082ae4b0198722bd9854"}, {"code": "(fn [xs]\n  (loop [s xs\n         r {}\n         k (let [a (first s)]\n             (if (keyword? a) a nil))]\n    (if (empty? s)\n      r\n      (recur (rest s) \n             (let [f (first s)]\n               (if (keyword? f)\n                 (assoc r f [])\n                 (assoc r k (conj (k r) f))))\n             (let [f (first s)]\n               (if (keyword? f)\n                 f\n                 k))))))", "problem": 105, "user": "4f2942ace4b0d6649770a01e"}, {"code": "(fn sequifier [invals]\n     (if (empty? invals) (sorted-map)\n       (apply merge (sorted-map (first invals) (take-while number? (rest invals)))\n         (sequifier (drop-while number? (rest invals))))))", "problem": 105, "user": "515737f0e4b0b0b4b87062d0"}, {"code": "(fn [v]\n  (if (empty? v)\n    {} \n    (loop [result {(first v) []} current-key (first v) remains (rest v)]\n      (if (empty? remains)\n        result\n        (let [nxt (first remains)\n              kw? (keyword? nxt)]\n          (recur (if kw?\n                   (merge result {nxt []})\n                   (merge-with conj result {current-key nxt}))\n                 (if kw?\n                   nxt\n                   current-key)\n                 (rest remains)))))))", "problem": 105, "user": "512d3304e4b040332b905b2d"}, {"code": "(fn [s]\n  (let [kwords-and-nums (->> (partition-by type s) (partition 2 2 []))\n        create-map (fn [[ks nums]] (-> (zipmap ks (repeat [])) (assoc (last ks) nums)) )\n        ]\n    (->> (map create-map kwords-and-nums) (reduce merge {}) )\n  )\n)", "problem": 105, "user": "51729002e4b044b2ef48a850"}, {"code": "(fn toromanstr [vals]\n    (loop [todo (rest vals)\n           res {}\n           cur-key (first vals)\n           cur-vals []]\n      (cond\n        (nil? cur-key) {}\n        (empty? todo) (conj res [cur-key cur-vals])\n        (keyword? (first todo)) (recur (rest todo) (conj res [cur-key cur-vals]) (first todo) [])\n        :else (recur (rest todo) res cur-key (conj cur-vals (first todo)))))\n\n  )", "problem": 105, "user": "5165a235e4b079ad97ec44ac"}, {"code": "(fn kav [v]\n  (if (empty? v)\n    {}\n    (loop [k (first v)\n           v (rest v)\n           tv []\n           m {}]\n      (cond\n        (empty? v) (assoc m k tv)\n        (not (keyword? (first v))) (recur k (rest v) (conj tv (first v)) m)\n        (keyword? (first v)) (recur (first v) (rest v) [] (assoc m k tv))))))", "problem": 105, "user": "50843a4ae4b0c98812d0788b"}, {"code": "(fn [xs] (-> (fn [[m kw] x]\n               (if (keyword? x)\n                 [(assoc m x []) x]\n                 [(update-in m [kw] conj x) kw]))\n             (reduce [{} nil] xs)\n             first))", "problem": 105, "user": "518696c1e4b0c40be512d708"}, {"code": "(fn f [l]\n  (first\n    (reduce (fn [[m s] i]\n              (if (keyword? i)\n                [(assoc m i []) i]\n                [(assoc m s (conj (m s) i)) s]))\n            [{} nil]\n            l)))", "problem": 105, "user": "50b668dde4b08fb537db98f2"}, {"code": "(fn [m]\n  (let [mm (partition-by #(keyword? %) m)]\n    (loop [ret {} cnt mm]\n      (if (empty? cnt)\n        ret\n        (let [h1 (first cnt)\n              h2 (second cnt)]\n          (if (= 2 (count h1))\n            (recur (assoc ret (first h1) [])\n                   (cons (rest (first cnt)) (rest cnt)))\n            (recur (assoc ret (first h1) h2)\n                   (drop 2 cnt))))))))", "problem": 105, "user": "4eec82fe535d93acb0a668ae"}, {"code": "(fn p105[x]\n  (loop [r {} v [] k (first x) l (rest x)]\n    (if (empty? l)\n      (if-not (nil? k)\n      \t(assoc r k v)\n\t\tr)\n      (if (keyword? (first l))\n        (recur (assoc r k v) [] (first l) (rest l))\n        (recur r (conj v (first l)) k (rest l))))))", "problem": 105, "user": "500b61b1e4b03d00572d2d81"}, {"code": "(fn [x]\n  (if (empty? x) {}\n  (loop [a (rest x) kw (first x) v [] b {}] \n    (if (empty? a) \n      (assoc b kw v)\n      (if (keyword? (first a)) \n        (recur (rest a) (first a) [] (assoc  b kw v)) \n        (recur (rest a) kw (conj v (first a)) b) )))))", "problem": 105, "user": "513b77f3e4b00f740c76c403"}, {"code": "(fn vector->map [v]\n  (let [empty-map (assoc {} :loc :none, :map {})\n        init (->> (filter keyword v)\n                  (map #(vector % []))\n                  (reduce conj {})\n                  (assoc {} :loc :none, :map))]\n    (->>\n     (reduce (fn [m e]\n               (if (keyword? e)\n                 (assoc m :loc e)\n                 (update-in m [:map (:loc m)] conj e)))\n             init v)\n     :map)))", "problem": 105, "user": "511b9017e4b00c2a1fa7ff6b"}, {"code": "(fn [x]\n  (loop [[h & t] x, k nil, y (sorted-map)]\n    (cond (nil? h) y\n      (keyword? h)   (recur t h (assoc y h []))\n      :else (recur t k (assoc y k (conj (get y k) h))))\n    )\n  )", "problem": 105, "user": "5099283ce4b0cae2931060af"}, {"code": "(fn [s]\n  (loop [remaining (rest s)\n         result {}\n         k (first s)]\n    (if (empty? remaining)\n      result\n      (if (keyword? (first remaining))\n        (recur (rest remaining) (conj result [(first remaining) []]) (first remaining))\n        (recur (rest remaining) (conj result [k (conj (result k []) (first remaining))]) k)))))", "problem": 105, "user": "51899891e4b0288ada3dbdab"}, {"code": "(fn idf [v]\n  (let [[a b] (split-with number? (rest v))]\n  (if (not (empty? v))\n    (assoc (idf b) (first v) a) {})))", "problem": 105, "user": "51780f88e4b03d69594194c9"}, {"code": "(fn [coll]\n  (letfn [(step [c]\n            (if (> (count c) 1)\n              (let [key-size (count (first c))]\n                (if (= key-size 1)\n                  (concat [(first (first c)) (vec (second c))] (step (drop 2 c)))\n                  (concat [(first (first c)) []] (step (cons (rest (first c)) (rest c))))))))]\n    (let [vec-result (step (partition-by keyword? coll))]\n      (if (seq vec-result)\n        (apply (partial assoc {}) vec-result)\n        {}))))", "problem": 105, "user": "514d7e29e4b019235f6c0587"}, {"code": "(fn keyw [[h & t]]\n  (if h\n    (let [s (split-with #(not (keyword? %)) t)]\n      (into {h (first s)} (keyw (first ( rest s)))))\n    {}))", "problem": 105, "user": "4e778d36535d324fb2983d71"}, {"code": "(fn [c] (loop [coll [] int c]\n   (if (empty? int) \n      (into {} coll)\n(recur (conj coll (vector\n(first int) (vec \n(take-while number? (rest int))))) (drop (+ 1 (count (take-while number? (rest int)))) int)))))", "problem": 105, "user": "517945dce4b0684c1c981a43"}, {"code": "(fn [coll]\n   (dissoc (reduce \n             (fn [accum item]\n               (if (keyword? item)\n                 (assoc accum :seen item item [])\n                 (update-in accum [(:seen accum)] #(conj % item)))) {} coll) :seen))", "problem": 105, "user": "5164867fe4b003cf19fdde3e"}, {"code": "(fn my-map\n  ([xs] (let [from-first-keyword (drop-while #(not (keyword? %)) xs)]\n          (if (empty? from-first-keyword)\n            {}\n            (my-map (first from-first-keyword)\n                    (rest from-first-keyword)))))\n  ([key xs] (let [[a b] (split-with #(not (keyword? %)) xs)]\n              (if (empty? b)\n                {key xs}\n                (assoc (my-map (first b) (rest b)) key a)))))", "problem": 105, "user": "5186134ce4b0da5a5be3bac7"}, {"code": "(fn [s]\n      (apply hash-map\n             (reduce #(if (keyword? %2)\n                        (conj % %2 [])\n                        (conj (pop %) (conj (peek %) %2)))\n                     [] s)))", "problem": 105, "user": "50f48298e4b004d364930527"}, {"code": "#(loop [xs %\n       last-key nil\n       nums []\n       result {}]\n  (if (seq xs)\n    (let [current (first xs)]\n      (if (keyword? current)\n        (if (nil? last-key)\n          (recur (rest xs) current nums result)\n          (recur (rest xs) current [] (into result [[last-key nums]])))\n        (recur (rest xs) last-key (conj nums current) result)))\n    (if (nil? last-key)\n      result\n      (into result [[last-key nums]]))))", "problem": 105, "user": "5102ac9de4b00c483ae176fa"}, {"code": "(fn [col]                                                                                                \n  (apply hash-map (reverse                                                                                      \n   (reduce                                                                                                      \n    (fn [r v]                                                                                                   \n      (if (keyword? v)                                                                                          \n        (cons [] (cons v r))                                                                                    \n        (cons (conj (first r) v) (rest r))                                                                      \n        )                                                                                                       \n      )                                                                                                         \n    []                                                                                                          \n    col))))", "problem": 105, "user": "519b7d76e4b02a926d9a436e"}, {"code": "(fn [[c & coll]]\n  (if (nil? c)\n    {}\n    (loop [res {} key c val [] r coll]\n    (if (empty? r)\n      (conj res {key val})\n      (if (keyword? (first r))\n        (recur (conj res {key val}) (first r) [] (rest r))\n        (recur res key (conj val (first r)) (rest r)))))))", "problem": 105, "user": "518ccf6be4b05e6c8537e386"}, {"code": "(fn [xs] (first \n          (reduce \n           (fn [[m k] x] \n             (if (keyword? x) \n               [(assoc m x []) x] \n               [(merge-with conj m {k x}) k]))\n           [{} nil] xs)))", "problem": 105, "user": "515fb48fe4b0e2be8aa20bd5"}, {"code": "(fn mmap [col]\n  (letfn [(str-to-map [target]\n            (let [k (first target) \n                  v (vec (map #(- (int %) 48) (rest target)))]\n              {(keyword (str k)) v}))]\n    (into {}\n    (map str-to-map\n         (filter #(> (count %) 0) \n                 (clojure.string/split (apply str col) #\":\"))))))", "problem": 105, "user": "514721c6e4b0d520409ed392"}, {"code": "(fn [l]\n                       (loop [l l\n                              acc {}]\n                         (if (zero? (count l))\n                           acc\n                           (recur \n                            (drop (+ 1 (count (take-while #(not (keyword? %)) (rest l)))) l)\n                            (assoc acc (first l) (take-while #(not (keyword? %)) (rest l)))))))", "problem": 105, "user": "50a5b7e9e4b0aa96157e2610"}, {"code": "(fn kandv\n  [s]\n  (let [reduced (reduce (fn [acc item]\n                          (if (keyword? item)\n                            (assoc acc item [] :i_am_a_cheater item)\n                            (assoc acc (get acc :i_am_a_cheater) (conj (get acc (get acc :i_am_a_cheater)) item))))\n                        {}\n                        s)]\n    (dissoc reduced :i_am_a_cheater)))", "problem": 105, "user": "50052fd0e4b0678c553fc45d"}, {"code": "(fn mf [s]\n  (if (seq s)\n    (merge {(first s) (take-while (complement keyword?) (rest s))}\n           (mf (drop-while (complement keyword?) (rest s)))) {} ))", "problem": 105, "user": "4fa340b4e4b081705acca18c"}, {"code": "(fn t [[x & r]]\n  (if x\n      (assoc (t (drop-while number? r)) x (take-while number? r))\n      {}))", "problem": 105, "user": "4e80e0f2535db62dc21a62b8"}, {"code": "(fn [s]\n (->> s\n      (partition-by keyword?)\n      (partition 2)\n      (mapcat (fn ! [[[kw & kws]\n                      nums]]\n                (if kws\n                  (conj (! [kws nums]) [kw '()])\n                  [[kw nums]])))\n      (into {})))", "problem": 105, "user": "51aa2b4fe4b04e3dc0c27b21"}, {"code": "(fn [l]\n  (loop [[l & ls] l km {}]\n    (if ls\n      (let [[a n] (split-with (complement keyword?) ls)]\n        (recur n (assoc km l a)))\n      km)))", "problem": 105, "user": "51b793d3e4b0d906fcd71d38"}, {"code": "(fn [x]\n    (loop [l x\n           a {}\n           k nil]\n    (let [i (first l)\n          r (rest l)]\n      (cond\n        (empty? l) a\n        (keyword? i) (recur r (assoc a i []) i)\n        1 (recur r (assoc a k (conj (a k) i)) k)\n        ))))", "problem": 105, "user": "51b3f109e4b0f094dd986fa9"}, {"code": "(fn [v]\n  (into {} (map (fn [[x y]]\n         (vec [(first x) (flatten y)])\n         ) (partition 2 (partition-by keyword? (interpose [] v)))))\n  )", "problem": 105, "user": "51bec919e4b013aa0d74b800"}, {"code": "(fn f [m kw r] (if (empty? r) m (let [e (first r) b (rest r)] \n   (if (keyword? e) (f (assoc m e []) e b ) (f (update-in m [kw] #(conj % e)) kw b ))))) {} nil", "problem": 105, "user": "51b90b88e4b050a1176cd6a2"}, {"code": "(fn [x] (apply hash-map (map \n    #(if (keyword? (first %)) (first %) (keep identity %)) \n    (partition-by #(when (keyword? %) %) (interpose nil x)))))", "problem": 105, "user": "51cbdee1e4b08d8387cbede1"}, {"code": "(fn [x] (into {} (map-indexed #(when (keyword? %2) (assoc {} %2 (take-while number? (subvec x (inc %))))) x)))", "problem": 105, "user": "5054bc87e4b0b1b9d1860eb0"}, {"code": "#(loop [values %\n       res {}\n       current-key nil\n       current-val []]\n   (if (empty? values)\n    (if (nil? current-key)\n      res\n      (assoc res current-key current-val))\n    (if (keyword? (first values))\n      (recur \n       (rest values)\n       (if (nil? current-key)\n         res\n         (assoc res current-key current-val))\n       (first values) \n       [])\n      (recur \n       (rest values) \n       res \n       current-key \n       (concat current-val (list (first values)))))))", "problem": 105, "user": "51d360d1e4b099f3b6acddff"}, {"code": "(fn [args]\n  (loop [m {}, a args]\n    (if-let [k (first a)]\n      (let [[vs more] (split-with (complement keyword?) (next a))]\n        (recur (assoc m k vs) more))\n      m)))", "problem": 105, "user": "51d19c24e4b0cfcf579466c3"}, {"code": "(fn [xs] (loop [[k & ss] xs acc {}] \n    (if k\n      (let [[v l] (split-with #(number? %) ss)] (recur l (assoc acc k v)))\n      acc)))", "problem": 105, "user": "51bd1a0de4b0df1216cefd93"}, {"code": "(fn [terms] (apply hash-map ( ->>\n                     (partition-by type terms)\n                     (mapcat #(if \n                                (keyword? (first %))\n                                (interpose [] %)\n                                [(vec %)]\n                                ))\n                     )))", "problem": 105, "user": "515cf9b5e4b00901442db1d4"}, {"code": "(fn [terms] (apply hash-map \n                   (mapcat #(if (keyword? (first %)) (interpose [] %)  [(vec %)]) (partition-by type terms))))", "problem": 105, "user": "51805d22e4b0e3fc13e244df"}, {"code": "(fn go [coll]\n  (->> (reductions #(if (keyword? %2) %2 %1) nil coll)\n       rest\n       (map (fn [v k] {k v}) coll)\n       (filter (comp not keyword? first vals))\n       (reduce (partial merge-with conj)\n               (zipmap (filter keyword? coll) (repeat [])))))", "problem": 105, "user": "507b7dbee4b09034bfeeb71e"}, {"code": "#(loop [[h & t] %\n        acc {}\n        k nil]\n   (cond\n    (nil? h)      acc\n    (keyword? h) (recur t (merge acc {h []}) h)\n    :else        (recur t (merge-with conj acc {k h}) k))\n   )", "problem": 105, "user": "51b9d1f0e4b0e871ca49590b"}, {"code": "(fn [s]\n  (letfn [(f1 [s] (take-while #(not (keyword? %1)) (next s)))\n          (f2 [s] (drop-while #(not (keyword? %1)) (next s)))]\n    (loop [s s\n           res {}]\n      (let [k (f1 s)]\n        (if (= '() s)\n          res\n          (recur (f2 s) (into res {(first s) (vec k)})))))))", "problem": 105, "user": "50a5f72fe4b0aa96157e2611"}, {"code": "(fn [s]\n  (let [the-keys (filter keyword? s)\n        key-index (keep-indexed #(if (keyword? %2) %) s)]\n    (zipmap the-keys\n            (map\n             #(apply vector %)\n             (for [x\n                   (map \n                    #(range (inc %) %2)\n                    key-index\n                    (concat (rest key-index) (vector (count s))))]\n               (map #(get s %) x))))))", "problem": 105, "user": "51c09719e4b0c9c82288293c"}, {"code": "(fn [coll]\n  (let [k-vs (fn f [[k & xs :as coll]]\n               (when (not-empty coll) \n                 (let [[vs ys] (split-with #(not (keyword? %)) xs)]\n                   (cons [k vs] (lazy-seq (f ys))))))] \n    (into {} (k-vs coll))))", "problem": 105, "user": "51cdd3f0e4b0e42293a2254b"}, {"code": "#(apply hash-map (reduce (fn [acc val]\n                           (if (keyword? val)\n                             (conj acc val [])\n                             (conj (pop acc) (conj (peek acc) val))))\n                         []\n                         %))", "problem": 105, "user": "51789dfae4b03d69594194d7"}, {"code": "(fn kv [coll]\n  (let [s1 (partition-by keyword? coll)\n        s2 (mapcat #(if (keyword? (first %))\n                      (interpose '()\n                                 (partition-all 1 %))\n                      (list %)) s1)\n           ]\n    (zipmap (map first (filter #(keyword? (first %)) s2)) (filter #(not (keyword? (first %))) s2)\n            )\n   ))", "problem": 105, "user": "51da7e49e4b02ceefd947768"}, {"code": "(fn [s]\n   (if (empty? s)\n     {}\n     (loop [[x & xs] (rest s) k (first s) v [] acc {}]\n       (if x\n         (if (keyword? x)\n           (recur xs x [] (assoc acc k v))\n           (recur xs k (conj v x) acc)\n         )\n         (assoc acc k v))     \n     ))\n     \n )", "problem": 105, "user": "51ba8f82e4b0fe3ecfb46434"}, {"code": "#(second (reduce (fn [[k m] x]\n             (if (keyword? x)\n               [x (assoc m x [])]\n               [k (assoc m k (conj (m k) x))]))\n             [nil {}] %))", "problem": 105, "user": "51efd397e4b0249c592fbdeb"}, {"code": "(fn keyvalues\n  [s]\n  (letfn [(grabkey [results input]\n                  (if (seq input)\n                    #(grabvals (conj results (first input)) (next input))\n                    results))\n          (grabvals [results input]\n                  (#(grabkey (conj results (vec (take-while (complement keyword?) input)))\n                            (drop-while (complement keyword?) input))))]\n    (apply hash-map (trampoline grabkey [] s))))", "problem": 105, "user": "511b233ae4b07ab9ec456180"}, {"code": "(fn [coll]\n  (into {} (reduce\n            (fn [res x] (if (number? x)\n                          (-> (last res) (update-in [1] conj x) (cons (pop res)) vec )\n                          (conj res [x []])))\n            []\n            coll)))", "problem": 105, "user": "4fe13ad7e4b0dd6cd5ce3632"}, {"code": "(fn [coll]\n  (->> coll\n       (partition-by keyword?)\n       (partition 2)\n       (mapcat (fn [[k v]] (conj (map (fn [x] [x []])\n                                      (drop-last k))\n                                 [(last k) v])))\n       (into {})))", "problem": 105, "user": "4eae5fe4535d7eef30807325"}, {"code": "(fn [v]\n   (apply hash-map\n   (map #(if (keyword? (first %)) (first %) (apply vector (flatten %)))\n   (partition-by class\n   (filter identity\n   (interleave\n     v\n     (concat\n       (map #(if (every? identity %)\n              '()\n              false) \n            (partition 2 1 (map keyword? v)))\n       '(false))))))))", "problem": 105, "user": "51f28a64e4b0210f90e7454e"}, {"code": "(fn conv [x]\n  (reduce (fn [a [b c]]\n            (assoc (into a (zipmap b (repeat []))) (last b) c)) {}\n          (partition 2 (partition-by keyword? x))))", "problem": 105, "user": "51fa7154e4b0f1313d4689da"}, {"code": "(fn [s]\n    (\n    (fn my-assoc [r [k kv & xs]]\n        (if (nil? k)\n            r\n            (my-assoc (reduce #(assoc %1 %2 []) (assoc r (last k) (into [] kv)) (butlast k)) xs)))\n    {} (partition-by keyword? s)))", "problem": 105, "user": "51f59607e4b0abb92f97f9d5"}, {"code": "(fn [a [x & xs]]\n   (let [k x [ys zs] (split-with (comp not keyword?) xs)]\n     (if k (recur (assoc a k ys) zs) a)))\n {}", "problem": 105, "user": "51e58e02e4b0efabf93c02d0"}, {"code": "(fn [co]\n  (letfn [(tnk [c] (take-while #(not (keyword? %)) c))\n          (dnk [c]  (drop-while #(not (keyword? %)) c))\n          (hashify [c]\n            (into {}\n                  (map\n                   #(apply vector %)\n                   (partition 2 c))))\n          (ksep [c]\n            (loop [res [(first c)] left (rest c)]\n              (if (empty? left)\n                (hashify (butlast res))\n                (recur (conj res (tnk left) (first (dnk left)))\n                       (rest (dnk left))))))]\n    (ksep co)))", "problem": 105, "user": "5133e51ae4b0d7a043de8cf6"}, {"code": "(fn [s]\n  (loop [[x & r] s, k nil, m {}]\n    (cond\n\t (nil? x) m\n     (keyword? x) (recur r x (assoc m x []))\n     :else (recur r k (update-in m [k] conj x)))))", "problem": 105, "user": "52039e12e4b0fb7e47ea51ff"}, {"code": ";stolen from adereth; take/drop-while is the bomb!\n(fn vtm [v]\n  (if (not (empty? v))\n    (merge\n      {(first v) (take-while (complement keyword?) (rest v))}\n      (vtm (drop-while (complement keyword?) (rest v))))\n    {}))", "problem": 105, "user": "51d96ad0e4b02ceefd94774f"}, {"code": "(fn [coll]\n   (loop [r {} s (seq coll)]\n     (if s\n       (let [f (first s)]\n         (if (keyword? f)\n           (recur (assoc r (first s) []) (next s))\n           (recur (assoc r (ffirst r) (conj (get r (ffirst r)) f)) (next s))))\n       r)))", "problem": 105, "user": "50aedb8ce4b0a40c9cfb08d4"}, {"code": "(fn [v]\n  (loop [tmp []\n         ret {}\n         k nil\n         [ft & rt] v]\n    (if (nil? ft)\n      (if k\n        (into ret [[k tmp]])\n        ret)\n      (if (keyword? ft)\n        (if k \n          (recur [] (into ret [[k tmp]]) ft rt)\n          (recur [] ret ft rt))\n        (recur (conj tmp ft) ret k rt)))))", "problem": 105, "user": "51944aaae4b0142f60b4aedc"}, {"code": "(comp\n   (partial apply hash-map)\n   (partial reduce\n     (fn [a [b :as c]]\n       (if (keyword? b)\n         (into a (interleave c (repeat [])))\n         (conj (vec (drop-last a)) c)))\n     [])\n   (partial partition-by keyword?))", "problem": 105, "user": "5201572be4b0d7096e99ddbb"}, {"code": "(fn [xs]\n  (apply hash-map\n         (reduce (fn [ac x] (if (keyword? x) (conj ac x []) (conj (pop ac) (conj (peek ac) x)))) [] xs)))", "problem": 105, "user": "52015698e4b0d7096e99ddba"}, {"code": "(fn [coll]\n\t(first\n\t\t(reduce \n\t\t\t(fn [[m k] r1]\n\t\t\t\t(if (keyword? r1) \n\t\t\t\t\t[(assoc m r1 []) r1]\n\t\t\t\t\t[(assoc m k (conj (get m k []) r1)) k]))\n\t\t\t[{} nil]\n\t\t\tcoll)))", "problem": 105, "user": "520242bae4b030ee0c5b26e3"}, {"code": "(fn [s]\n  (loop [s s\n         m {}]\n    (if (empty? s)\n      m\n      (let [[n r] (split-with #(not (keyword? %)) (rest s))\n            conjed (into m {(first s) n})]\n      \t\t(recur r conjed)))))", "problem": 105, "user": "502a5e59e4b09e8f859a9fbc"}, {"code": "(fn k-v [x]\n  (loop [rst x\n         current-key nil\n         result {}]\n    (if (empty? rst) result\n      (if (-> rst first class (= clojure.lang.Keyword)) (recur (rest rst) (first rst) (assoc result (first rst) []))\n        (recur (rest rst) current-key (assoc result current-key (conj (result current-key) (first rst))))))))", "problem": 105, "user": "52084f75e4b01ce6bbf31dde"}, {"code": "(fn [xs]\n  (reduce (fn [acc [k v]]\n          (assoc acc (first k) (filter #(not (zero? %)) (vec v)))\n          ) {} \n        (partition 2 (partition-by keyword? (interpose 0 xs)))))", "problem": 105, "user": "513fab65e4b00f13ea1bd891"}, {"code": "(fn [s] (into {} (map #(let [x (first %) y (second %)] (vector x (drop (inc (.indexOf s x)) (if y (take (.indexOf s y) s) s)))) ((fn f [q] (when (seq q) (cons [(first q) (second q)] (lazy-seq (f (rest q)))))) (filter #(= (type %) clojure.lang.Keyword) s)))))", "problem": 105, "user": "51f66e0ee4b06ff1c25c52c3"}, {"code": "(fn [sq]\n  (into\n   {}\n   (mapcat (fn [[ks vs]]\n             (cons [(last ks) vs]\n                   (map (fn [k] [k []]) (butlast ks))))\n           (partition\n            2\n            (partition-by keyword?\n                          sq)))))", "problem": 105, "user": "51f9527fe4b09be9c177e549"}, {"code": "(fn [c] (loop [x c r {}]\n                    (if (empty? x)\n                        r\n                      (let [k (first x)\n                              v (take-while #(not (keyword? %)) (rest x))]\n                      (recur (drop (+ 1 (count v)) x) (assoc r k (vec v)))))))", "problem": 105, "user": "511b810ce4b07ab9ec456182"}, {"code": "(fn f [v]\n  (loop [ans {} \n         vv (next v)\n         key (first v)\n         value []]\n    (if (empty? vv) (if key (conj ans [key value]) ans)\n      (if (keyword? (first vv))\n       (recur (conj ans [key value]) (next vv) (first vv) [])\n       (recur ans (next vv) key (conj value (first vv)))))))", "problem": 105, "user": "52196842e4b0890f2f822bfa"}, {"code": "(fn id-keys [x] (first (reduce (fn [[m k] i] (if (= clojure.lang.Keyword (type i))\n                          (vector (assoc m i []) i)\n                          (vector (assoc m k (conj (get m k []) i)) k)\n                        )) [{} nil] x)))", "problem": 105, "user": "514cfa27e4b019235f6c057d"}, {"code": "(fn [coll]\n  (let [updated (fn [dict key val]\n                  (assoc dict key\n                    (conj (dict key []) val)))\n         add (fn [[dict key] el]\n              (if (keyword? el)\n                [(assoc dict el (dict el [])) el]\n                [(updated dict key el) key]))]\n    (first\n      (reduce add [{} nil] coll))))", "problem": 105, "user": "514c2d05e4b02b8cbb2a9278"}, {"code": "(fn stuf [xs]\n     ( loop [ x xs y {}]\n       ( if( empty? x) y\n         (recur (drop-while #( (comp not keyword?) %) (rest x)) (assoc y (first x) (take-while #( (comp not keyword?) %) (rest x))) )\n         )\n       )\n     )", "problem": 105, "user": "5225b16de4b0d2f5d1e2c0ed"}, {"code": "(fn [xs]\n    (reduce #(if (keyword? %2)\n                 (assoc %1 %2 [])\n                 (assoc %1 (first (last %1)) (conj (second (last %1)) %2)))\n            (sorted-map) xs))", "problem": 105, "user": "5141abf1e4b02fd87f5064c3"}, {"code": "(fn kav [[head & tail]]\n  (if (nil? head) {}\n    (into\n      {head (take-while (complement keyword?) tail)}\n      (kav  (drop-while (complement keyword?) tail)))))", "problem": 105, "user": "521e8227e4b0dd19981ad082"}, {"code": "(fn to-map [[k & r :as l]]\n  (second (reduce (fn [[k m] e] \n            (if-not (keyword? e)\n              [k (assoc m k (conj (m k) e))]\n              [e (assoc m e [])])) [k {}] l)))", "problem": 105, "user": "50c781bbe4b00bb60fe0c535"}, {"code": "(fn my-identify                                                           \n  [coll]                                                                    \n  (loop [acc [] keyw nil curr [] items coll]                                \n         (if (empty? items)                                                 \n           (into {}  (remove #(nil? (first %)) (conj acc [keyw curr])))     \n           (if (keyword? (first items))                                     \n             (recur (conj acc [keyw curr]) (first items) [] (rest items))   \n             (recur acc keyw (conj curr (first items)) (rest items))        \n             )                                                              \n           )                                                                \n         ))", "problem": 105, "user": "50573ed8e4b0012181721987"}, {"code": "#(->> %\n       (partition-by number?)\n       (mapcat (fn [[x :as s]] (if (number? x) [s] (interpose [] s))))\n       (apply hash-map))", "problem": 105, "user": "522b922ee4b0d34ee08e71c3"}, {"code": "(fn identity-k-v [coll]\n  (letfn [(identity-k-v-aux\n           [coll]\n           (when (seq coll)\n             (lazy-seq\n              (let [kwd (first coll)\n                    [val-n tail] (split-with (complement keyword?)\n                                             (rest coll))]\n                (conj (identity-k-v-aux tail) (vec val-n) kwd)))))]\n    (->> (drop-while (complement keyword?) coll)\n         identity-k-v-aux\n         (apply hash-map))))", "problem": 105, "user": "52381b2ae4b0fae3832e99ef"}, {"code": "(fn kv [xs]\n  (if (empty? xs) {}\n      (let [k (first xs)\n            r (rest xs)\n            n (drop-while (complement keyword?) r)\n            vals (take-while (complement keyword?) r)]\n        (conj {k vals} (kv n)))))", "problem": 105, "user": "4fbd12a5e4b081705acca2fd"}, {"code": "(fn f [l]\n  (if (empty? l)\n    {}\n    (let [[g r] [#(not (keyword? %)) (rest l)]]\n    (conj \n     (f (drop-while g r)) \n     {(first l) (take-while g r)}\n     ))))", "problem": 105, "user": "52379c46e4b0fae3832e99db"}, {"code": "(fn [c]\n    (loop [[k & v] c\n           a {}]\n      (if (nil? k)\n        a\n        (recur \n         (drop-while number? v)\n         (assoc a k (take-while number? v))))))", "problem": 105, "user": "5098f5d6e4b0cae2931060a4"}, {"code": "(fn[x]\n  (let [y (partition-by keyword? x)]\n    (loop [y y acc {}]\n      (let [[k v & r] y]\n        (if (empty? y) acc\n          (if (= 1 (count k))\n            (recur r (assoc acc (first k) (vec v)))\n            (recur (conj (conj r v) (rest k)) (assoc acc (first k) []))))))))", "problem": 105, "user": "4ed286d4535d44c135fd68d7"}, {"code": "(fn [s]\n  (loop [res {} list s symb nil elems []]\n    (if (seq list)\n      (let [current (first list)]\n        (if (keyword? current)\n          (if (keyword? symb)\n            (recur (assoc res symb elems) (rest list) current [])\n            (recur res (rest list) current elems))\n          (recur res (rest list) symb (conj elems current))))\n      (if (keyword? symb)\n        (assoc res symb elems)\n        res))))", "problem": 105, "user": "5048202fe4b0ec70b3ef8d9a"}, {"code": "(fn f [coll]\n  (loop [m {} s coll]\n    (if (seq s)\n      (let [k (first s)\n            [vals rem] (split-with (comp not keyword?) (rest s))]\n        (recur (assoc-in m [k] vals) rem))\n      m)))", "problem": 105, "user": "4fe8fda4e4b0547ebccb2438"}, {"code": "(fn foo [coll]\n   (into {} (reduce (fn [acc elem]\n                       (if (keyword? elem) \n                          (conj acc [elem []] ) \n                          (let [p (peek acc) kw (first p) vk (second p)] \n\t\t\t\t\t\t\t\t(conj (pop acc) [kw (conj vk elem)] ))\n\t\t\t\t\t\t  )) \n\t\t\t[] coll)))", "problem": 105, "user": "523a9fc9e4b081681ca7adca"}, {"code": "reduce #(if (keyword? %2)\n          (assoc % %2 [])\n          (assoc % (first (first %)) (conj (second (first %)) %2))) {}", "problem": 105, "user": "52479487e4b05ef8e38e6373"}, {"code": "(fn [kn]\n  (first \n    (reduce (fn [[m k] i]\n              (let [e (first i)] \n                (cond (nil? k) [m e]\n                      (keyword? e) [(assoc m k []) e]\n                      :else [(assoc m k (vec i)) nil]))) \n            [{} nil] \n            (partition-by keyword kn))))", "problem": 105, "user": "5246e945e4b0644eb7b0783b"}, {"code": "(fn kv [x]\n  (if (empty? x)\n    {}\n    (let [k (first x) v (take-while number? (rest x))]\n      (conj\n       (kv (drop (inc (count v)) x))\n       [k v]\n       )\n      )\n    )\n  )", "problem": 105, "user": "52586d24e4b0cb4875a45cb0"}, {"code": "(fn [x]\n  (->>\n   (partition-by keyword? x)\n   (partition 2)\n   (reduce (fn [a [k v]] (concat a (drop-last (interpose [] k)) [(last k) v])) [])\n   (apply array-map)\n   )\n  )", "problem": 105, "user": "523f0bbfe4b01c266ffa7f91"}, {"code": "(fn [s] (->> s (reduce \n  (fn [[a k] x] \n    (if (keyword? x) \n      [(assoc a x []) x] \n      [(assoc a k (conj (get a k) x)) k])) \n  [{} nil]) first))", "problem": 105, "user": "51c19873e4b0d204dbe2ca0d"}, {"code": "(fn identify [xs]\n  (letfn [(aux [xs acc]\n    (let [[kw x & more] xs]\n      (cond\n        (nil? kw) acc\n        (and (keyword? kw) (nil? x)) (assoc acc kw (vec (concat (acc kw) [])))\n        (keyword? x) (aux (concat [x] more) (assoc acc kw (vec (concat (acc kw) []))))\n        :else (if (acc kw)\n                (aux (concat [kw] more) (assoc acc kw (conj (acc kw) x)))\n                (aux (concat [kw] more) (assoc acc kw [x]))))))]\n    (aux xs {})))", "problem": 105, "user": "52606318e4b03e8d9a4a7036"}, {"code": "(fn ident-keys-vals [coll]\n  (reduce #(if (keyword? %2)\n             (assoc %1 %2 [])\n             (let [kv (first %1)\n                   k (key kv)\n                   v (val kv)]\n               (assoc %1 k (conj v %2)))) {} coll))", "problem": 105, "user": "511e763ce4b03e81d390ac29"}, {"code": "(fn[s]\n  ((reduce\n   (fn [[m k] v]\n     (if (keyword? v)\n       [(assoc m v []) v]\n       [(assoc m k (conj (m k) v)) k]))\n   [{} nil]\n   s) 0))", "problem": 105, "user": "5201ada5e4b0b2e020a18f14"}, {"code": "(fn [lst]\n  (letfn [(nums [lst]\n                (if (or (empty? lst) (keyword? (first lst))) []\n                      (conj (nums (rest lst)) (first lst))))\n          (maps [lst]\n                (cond (empty? lst) {}\n                      (number? (first lst)) (maps (rest lst))\n                      :else (conj {(first lst) (reverse (nums (rest lst)))} (maps (rest lst)))))]\n    (maps lst))\n  )", "problem": 105, "user": "525372ade4b0541d1855b8f3"}, {"code": "(fn [xs]\n  (loop [xs xs\n         ys []\n         k nil\n         m {}]\n    (cond\n     (empty? xs) (if k (conj m [k ys]) m)\n     (nil? k) (recur (rest xs) ys (first xs) m)\n     (keyword? (first xs)) (recur (rest xs) [] (first xs) (conj m [k ys]))\n     :else (recur (rest xs) (conj ys (first xs)) k m))))", "problem": 105, "user": "524cdd51e4b0752c4cb68ccc"}, {"code": "(fn [kvs]\n  (loop [m {} k nil v kvs]\n    (if (seq v)\n      (let [n (first v)]\n        (if (keyword? n)\n          (recur (assoc m n []) n (rest v))\n          (recur (update-in m [k] concat [n]) k (rest v))))\n      m)))", "problem": 105, "user": "514d8084e4b019235f6c0588"}, {"code": "#(loop [[f & s] % r {}]\n    (cond (nil? s) r\n    \t(keyword? (first s)) (recur s (conj r [f []]))\n        :else (recur (drop-while number? s) (conj r [f (vec (take-while number? s))]))))", "problem": 105, "user": "4f2d5f5de4b0d6649770a05a"}, {"code": "(fn f [[h & r]]\n  (if h\n    (assoc\n      (f (drop-while number? r))\n      h\n      (take-while number? r))\n    {}))", "problem": 105, "user": "523ed522e4b057c4b7cd0a78"}, {"code": "(fn build-map [kvs]\n  (let [red-func\n          (fn [[mp lst] nxt]\n            (cond\n              (and (keyword? lst) (keyword? nxt)) [(assoc mp lst []) nxt]\n              (keyword? lst) [(assoc mp lst nxt) nxt]\n              :else [mp nxt]))\n        grouped-vals\n          (mapcat #(if (keyword? (first %)) % [%])\n                  (partition-by keyword? kvs))]\n    (first (reduce red-func [{} nil] grouped-vals))))", "problem": 105, "user": "52463059e4b09dbe66b56198"}, {"code": "(fn [s] (apply hash-map\n               ((fn split-on-keywords [s]\n                  (if (empty? s) '()\n                    (let [[f & r] (seq s)\n                          [vs rr] (split-with (complement keyword?) r)]\n                      (concat (list f vs) (split-on-keywords rr))))) s)))", "problem": 105, "user": "525f51bde4b0cb4875a45dc8"}, {"code": "(fn[coll]\n\t\t(first (reduce (fn [[s cur] e]\n\t\t\t\t\t(if (keyword? e)\n\t\t\t\t\t\t[(assoc s e []) e]\n\t\t\t\t\t  (let [v (get s cur [])]\n\t\t\t\t\t\t[(assoc s cur (conj v e)) cur]))) [{} nil] coll)))", "problem": 105, "user": "51f2851fe4b0210f90e7454b"}, {"code": "(fn [v]\n   (let [g (partition-by keyword?  v)\n         ks (map first (partition 1 2 g))\n         ns (flatten  (map #(drop-last 1 %)  ks ))\n         vs (map  first (partition 1 2 (drop 1 g)))\n         x (into {} (map #(vector (last %) (into [] %2)) ks vs))]\n     (reduce #(assoc % %2 []) x ns)))", "problem": 105, "user": "50550f43e4b0b1b9d1860eb7"}, {"code": "(fn [input]\n  (loop [v input res {}]\n    (if (empty? v) res\n      (recur (drop-while #(not (keyword? %)) (rest v))\n             (assoc res (first v) (take-while #(not (keyword? %)) (rest v))) ))))", "problem": 105, "user": "52667ecfe4b03e8d9a4a713e"}, {"code": "(fn p105\n  ([ls] (p105 {} nil ls))\n  ([m ck ls] (if (empty? ls) m\n                 (let[ e (first ls)\n                      [ck1 m1] (if (keyword? e) [e (conj m [e []])] [ck (conj m [ck (conj (m ck) e)])] )]\n                   (p105 m1 ck1 (next ls))))))", "problem": 105, "user": "5272669de4b03e8d9a4a742e"}, {"code": "(fn keyword-map [coll]\n  (let [s (partition-by keyword? coll)\n        ks (map last (take-nth 2 s))\n        vls (take-nth 2 (rest s))\n        m (zipmap ks vls)]\n    (reduce\n      #(if (contains? %1 %2) %1 (assoc %1 %2 []))\n      m\n      (filter keyword? coll))))", "problem": 105, "user": "526ee63de4b03e8d9a4a733f"}, {"code": "(fn [x]\n      (first\n        (reduce\n          (fn [[acc k] i]\n            (if (keyword? i)\n              (list (assoc acc i []) i)\n              (list (assoc acc k (conj (acc k) i)) k)\n            )\n          )\n          (list {} nil)\n          x\n        )\n      )\n    )", "problem": 105, "user": "5272d4b7e4b03e8d9a4a7453"}, {"code": "(fn partition-by-kw [coll]\n  (if (empty? coll) {}\n\t  (loop [m {}\n\t         cur_kw (first coll)\n\t         acc []\n\t         xs (rest coll)]\n\t    (println m cur_kw acc xs)\n\t    (cond (empty? xs) (assoc m cur_kw acc)\n\t          (keyword? (first xs)) (recur (assoc m cur_kw acc) (first xs) [] (rest xs))\n\t          :else (recur m cur_kw (conj acc (first xs)) (rest xs))))))", "problem": 105, "user": "52319066e4b0e2e8de81d1e9"}, {"code": "(fn [c]\n  (->> (reduce #(if (keyword? %2)\n                  (conj % [%2 []])\n                  (update-in % [(dec (count %)) 1] (fn [p] (conj p %2)))) [] c)\n       (into {})))", "problem": 105, "user": "4fa05b99e4b0dcca54ed6d47"}, {"code": "(fn [xs] (apply hash-map (reduce #(if (keyword? %2) (conj %1 %2 []) (conj (vec (butlast %)) (conj (last %1) %2))) [] xs)))", "problem": 105, "user": "4f40ccd9e4b0e243712b1fc0"}, {"code": "(fn [coll]\n  (letfn\n    [(r [coll m] \n       (if (empty? coll) m\n         (recur (drop-while #(not (keyword? %)) (rest coll))\n                (assoc m (first coll) (take-while #(not (keyword? %)) (rest coll))))))]\n    (r coll {})))", "problem": 105, "user": "51e00020e4b01188f0627534"}, {"code": "(fn [ coll ]\n  (loop [coll coll\n         m {}]\n    (if (empty? coll) m\n      (let [k (first coll)\n            v (take-while number? (next coll))]\n        (recur (drop-while number? (next coll))\n               (assoc m k (vec v)))))))", "problem": 105, "user": "524ae8e6e4b09eba1c0223b5"}, {"code": "(fn a [col] (loop [out {} s (partition 2 (partition-by type (flatten(map #(if(keyword? %1)(if(keyword? %2)(concat (list %1) '(nil))(identity %1))(identity %1)) col (concat (next col) '(nil))))))] (if(empty? s)(identity out)(recur (assoc out (first(first (first s)))(let [v (second (first s))] (if(nil? (first v))(identity [])(identity v)))) (next s)))))\n;(fn a [col] (loop [m {} c col l nil] (if(empty? c)(identity m)(let [v (first c)] (recur (if(keyword? v)(into m {v []})(assoc m l (concat (m l) [v]))) (next c) (if(keyword? v)(identity v)(identity l)))))))", "problem": 105, "user": "527a8eb7e4b03e8d9a4a755f"}, {"code": "(fn [src]\n   (first(reduce #(if (number? (first %2)) \n              [(assoc (first %)(last %) %2)(last %)]\n              [(assoc (first %)(first %2) '())(first %2)]) [{} nil] \n           (partition-by #(and(not (number? %)) %) src)\n           )\n         )\n   )", "problem": 105, "user": "5274eb56e4b03e8d9a4a74bb"}, {"code": "(fn [x]\n(let [l\n       (mapcat\n         (fn [[k [l & i]]] [(first k) (into l i)])\n         (partition 2\n                    (partition-by keyword?\n                                  (mapcat #(if (keyword? %) [% []] [%]) x))))\n  ]\n  (if (empty? l) {} (apply assoc {} l))\n  )\n  )", "problem": 105, "user": "52593207e4b0cb4875a45cd3"}, {"code": "(fn [x]\n  (letfn [(consume [l]\n                   (if (empty? l)\n                     '()\n                     (let [k (first l)\n                           v (second l)\n                           r (rest (rest l))]\n                       (if (= 1 (count k))\n                         (cons {(first k) (vec v)}\n                               (lazy-seq (consume r)))\n                         (cons {(first k) []}\n                               (lazy-seq (consume (cons (rest k) (cons v r)))))))))]\n    (reduce into {} (consume (partition-by keyword? x)))))", "problem": 105, "user": "52736ca1e4b03e8d9a4a747e"}, {"code": "(fn self [xs]\n  (if (empty? xs)\n    {}\n    (let [x (first xs)\n          rs (rest xs)]\n      (merge (self (drop-while number? rs))\n             {x, (take-while number? rs)}))))", "problem": 105, "user": "5233ad08e4b07e3ee2be83ac"}, {"code": "(fn [inputs] (loop [result {} xs inputs last-key :none]\n               (if (empty? xs) result\n                 (let [x (first xs) y (rest xs)]\n                   (cond\n                    (keyword? x) (recur (assoc result x []) y x)\n                    (integer? x) (recur (update-in result [last-key] conj x) y last-key)\n                   )\n                 )\n               )\n             )\n)", "problem": 105, "user": "526dd90de4b03e8d9a4a72fe"}, {"code": "(fn [s] (let [ss (partition-by type s)\n              ss (mapcat #(if (keyword? (first %)) (interpose [] %) [%]) ss)]\n          (zipmap  (take-nth 2 ss)\n                   (conj (vec (map vec (take-nth 2 (rest ss)))) []))))", "problem": 105, "user": "519ef784e4b087743fad2198"}, {"code": "(fn identify [coll]\n   (into {}\n     (map (fn [[[k] v]] [k v])\n          (partition 2 (reduce (fn [all s]\n                                 (if (and (keyword? (first s))\n                                          (not= 1 (count s)))\n                                   (vec (concat all\n                                                (apply concat\n                                                       (partition-all 2\n                                                                      (interpose []\n                                                                                 (map vector s))))))\n                                   (conj all s)))\n                               []\n                               (partition-by type coll))))))", "problem": 105, "user": "4f35b2ace4b0e243712b1ec5"}, {"code": "(fn map-seqs [[k & r]]\n  (if k\n    (assoc (map-seqs (drop-while integer? r))\n           k\n           (take-while integer? r))\n    {}))", "problem": 105, "user": "50d86fe2e4b01f0871336e67"}, {"code": "(fn kv [s]\n  (loop [c {} k nil [s1 & r] s]\n    (cond\n      (nil? s1) c\n      (keyword? s1) (recur (assoc c s1 []) s1 r)\n      :else (recur (assoc c k (conj (c k) s1)) k r))))", "problem": 105, "user": "528e64b7e4b0239c8a67aedd"}, {"code": "(fn x [s]\n  (if (empty? s)\n    {}\n    (let [k (first s)\n          [nums r] (split-with #(not (keyword? %)) (rest s))]\n      (assoc (x r) k nums))))", "problem": 105, "user": "526439a4e4b03e8d9a4a70cc"}, {"code": "(fn f [v]\n  (if (seq v)\n    (let [[h & t] v\n          [va r] (split-with (complement keyword?) t)]\n      (assoc (f r) h va))\n    {}))", "problem": 105, "user": "51e38568e4b0c611d6113e43"}, {"code": "(fn identify-keys-vals [vecs]\n  (reduce (fn[to [k v]]\n            (assoc (reduce #(assoc %1 %2 []) to k) (last k) (vec v)))       \n          {} \n          (partition 2 2 (partition-by keyword? vecs))))", "problem": 105, "user": "5273562ae4b03e8d9a4a7479"}, {"code": "(fn [l]                                                                  \n        (loop [s l                                                       \n               a {}                                                             \n               l nil]                                                     \n          (if (seq s)                                                           \n            (if (keyword? (first s))                                            \n              (recur (rest s) (assoc a (first s) []) (first s))                 \n              (recur (rest s) (assoc a l (conj (a l) (first s))) l))            \n            a)))", "problem": 105, "user": "52753740e4b03e8d9a4a74c1"}, {"code": "(fn [s]\n  (loop [s s, k nil, m {}]\n    (if-let [cur (first s)]\n      (if (keyword? cur)\n        (recur (rest s) cur (assoc m cur []))\n        (recur (rest s) k (update-in m [k] conj cur)))\n      m)))", "problem": 105, "user": "511cca27e4b00c2a1fa7ff7d"}, {"code": "(fn somemap [x]\n   (loop [x' x r {} k (first x)]\n     (print r)\n     (cond\n      (empty? x') r\n      (keyword? (first x')) (recur (rest x') (conj r {(first x') []}) (first x'))\n      :else (recur (rest x') (update-in r [k] concat [(first x')]\n                                        ) k)\n      )))", "problem": 105, "user": "52140b53e4b0961f15ac4d7e"}, {"code": "(fn kv-identify [seq]\n   (letfn [(iden [[m acc lkw] e]\n             (if (keyword? e)\n               (if (nil? lkw)\n                 [m acc e]\n                 [(assoc m lkw acc) [] e])\n               [m (conj acc e) lkw]))]\n     (let [[m acc lkw] (reduce iden [{} [] nil] seq)]\n          (merge\n           m\n           (if (empty? acc) {}\n               {lkw acc})))))", "problem": 105, "user": "529ce629e4b04e0c58e87b6e"}, {"code": "(fn [seq]\n  (loop [r {} s seq k (first s)] \n    (if (empty? s) r\n      (if (keyword? (first s)) (recur (merge r {(first s) []}) (rest s) (first s))\n          (recur (merge r {k (conj (val (find r k)) (first s))}) (rest s) k)\n      )\n    )\n  )\n)", "problem": 105, "user": "522eba30e4b01cdb292c5f0e"}, {"code": "(fn [s]\n  (reduce \n   (fn build-key-value [m coll]    \n     (let [[k & values] coll]\n       (assoc m k (if (empty? values) [] values))))\n   {}\n   ((fn partition-by-key [l]\n    (when (seq l)\n    (cons\n     (conj  \n      (take-while (complement keyword?) (rest l)) \n      (first l))\n     (lazy-seq\n      (partition-by-key\n       (drop-while (complement keyword?) (rest l))))))) s)))", "problem": 105, "user": "527ccaf4e4b0757a1b17136d"}, {"code": "(fn f [s]\n  (if (empty? s)\n    {}\n    (assoc (f (drop-while number? (rest s)))\n      (first s)\n      (take-while number? (rest s)) )))", "problem": 105, "user": "4ef77edb535dced4c769f254"}, {"code": "(fn [es]\n    (loop [es es\n           m {}]\n      (if-not (seq es)\n        m\n        (let [k (first es)\n              [vs next-es] (split-with (comp not keyword?) (rest es))]\n          (recur\n            next-es\n            (conj m [k vs]))))))", "problem": 105, "user": "521b9f92e4b0c4ef0be8304c"}, {"code": "(partial \n (fn mk-map\n    [acc s]\n    (if (empty? s) (into {} acc)\n      (recur\n       (if (keyword? (first s)) (conj acc {(first s) []})\n         (conj (drop 1 acc) {(first (keys (first acc))) \n                             (conj (first (vals (first acc))) (first s))})) (rest s))))\n '())", "problem": 105, "user": "5273e006e4b03e8d9a4a7495"}, {"code": "(fn [v]\n  (last (reduce \n    #(if (keyword? %2)\n      [(merge (last %1) {%2 (vec (butlast %1))})]\n      (cons %2 %1))\n    [{}] (reverse v))))", "problem": 105, "user": "528652fbe4b0239c8a67ae14"}, {"code": "(fn [l]\n\t(loop [[a & m] l r {}]\n\t\t(if a \n          (recur (drop-while number? m)\n                 (assoc r a (take-while number? m))) r)))", "problem": 105, "user": "528a3e14e4b0239c8a67ae72"}, {"code": "(fn n105 [coll]\n  (loop [c coll a {} curr nil]\n    (if (empty? c)\n      a\n      (recur (rest c)\n             (if (keyword? (first c)) (into a [[(first c) []]]) (merge-with conj a {curr (first c)}))\n             (if (keyword? (first c)) (first c) curr)))))", "problem": 105, "user": "52b43468e4b0c58976d9ad1b"}, {"code": "(fn ekv [c]\n  (if (empty? c) {}\n   (let [k (first c)\n         [v r] (split-with (complement keyword?) (rest c))]\n     (conj (ekv r) {k v}))))", "problem": 105, "user": "5267d9bde4b03e8d9a4a7188"}, {"code": "(fn [xs]\n    (into {}\n    (reduce (fn [acc x]\n              (if (keyword? x)\n                (cons [x []] acc)\n                (let [[[x1 xs1] & rest] acc]\n                  (cons [x1 (conj xs1 x)] rest))))\n            [] xs)))", "problem": 105, "user": "52a88c4de4b0c58976d9ac30"}, {"code": "(fn key-trans [v]\n  (letfn [(step [cmap keywd now-v]\n                (if (keyword? now-v)\n                  [(assoc cmap now-v []) now-v]\n                  [(assoc cmap keywd (conj (get cmap keywd []) now-v)) keywd]))]\n    (first (reduce #(step (first %1) (last %1) %2) [{} (first v)] (drop 1 v)))))", "problem": 105, "user": "52a55adee4b0c58976d9abe7"}, {"code": "(fn [s]\n  (loop [s s\n         k nil\n         res {}]\n    (if-let [e (first s)]\n      (if (keyword? e)\n        (recur (rest s) e (assoc res e []))\n        (recur (rest s) k (assoc res k (conj (get res k) e))))\n      res)))", "problem": 105, "user": "4fc3a72ae4b081705acca342"}, {"code": "(fn f [x] (let [\n\tpr (partition-by class x)\n\tm  \t(map \n\t\t\t(fn [k] \n\t\t\t\t( if (not= (class (first k)) clojure.lang.Keyword) k \n\t\t\t\t\t(if (= (count k) 1) k (drop-last (interleave k (repeat (count k) []))) \n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)  pr\n\t\t)\n\tm1 (reduce concat m)\n\tpr1 (partition-by class m1)\n\tm3  (map \n\t\t\t(fn [z] \n\t\t\t\t( if (or (= (class (first z)) clojure.lang.Keyword) (coll? (first z) )) (first z) z)\n\t\t\t)  pr1\n\t\t)\n\tmap1 (apply hash-map m3)\n] map1) )", "problem": 105, "user": "5296008fe4b02ebb4ef7502a"}, {"code": "(fn [[kw & coll]]\n  (loop [[curr & rst] coll\n         key kw\n         vals []\n         res {}]\n    (cond (nil? curr) (if key (assoc res key vals) {})\n          (keyword? curr) (recur rst curr [] (assoc res key vals))\n          :else (recur rst key (conj vals curr) res))))", "problem": 105, "user": "4f437751e4b0d7d3c9f3fd20"}, {"code": "(fn \n  [cs]\n  (let [cs (flatten cs)\n        ps (partition-by keyword? cs)]\n    (loop [ps ps, m {}]\n      (cond\n       (empty? ps) m\n       :d (let [p (first ps)]\n            (if (= 1 (count p))\n              (recur (drop 2 ps) (assoc m (first p) (vec (second ps))))\n              (recur (drop 2 ps) (-> m\n                                     (assoc (first p) [])\n                                     (assoc (second p) (vec (second ps)))))))))))", "problem": 105, "user": "51852961e4b0da5a5be3babb"}, {"code": "(fn keyvals [s]\n\t(if (empty? s) {}\n\t\t(when (first s)\n\t\t\t(let [entry [(first s) (take-while number? (rest s))]]\n\t\t(into {} (cons entry (keyvals (drop (count (flatten entry)) s))))))))", "problem": 105, "user": "5201ff99e4b0b2e020a18f26"}, {"code": "(fn [coll]\n  (first (reduce (fn [[hmap ky] nxt] (if (keyword? nxt)\n                                       [(assoc hmap nxt []) nxt]\n                                       [(assoc hmap ky (conj (ky hmap) nxt)) ky]))\n                 [{} nil] coll)))", "problem": 105, "user": "50645e12e4b007509339a58a"}, {"code": ";(fn ident-kv\n;  [xs]\n;  (if (empty? xs)\n;    {}\n;    (let [emp (gensym)\n;          xs-sanitized (reduce\n;                        (fn [r v]\n;                          (if (and (keyword? v)\n;                                   (keyword? (last r)))\n;                            (conj r emp v)\n;                            (conj r v))) [] xs)\n;          xs(partition-by type xs-sanitized)\n;          ks (keep-indexed #(if (even? %) (first %2)) xs)\n;          vs (keep-indexed #(if (odd? %)  %2) xs)\n;          os (map #(if (not= emp (first %)) % []) vs)]\n;      (reduce merge(map hash-map ks os))\n;      ))) \n\n;daowen's solution is very slick.\n#(->> %\n     (partition-by keyword?)\n     (mapcat (fn [[k :as v]] (if (keyword? k) (interpose [] v) [v])))\n     (apply hash-map))", "problem": 105, "user": "524f4256e4b0541d1855b808"}, {"code": "(fn [v]\n  (letfn [(p [x] (not (keyword? x)))\n          (f [m v] \n             (if (empty? v)\n               m\n               (let [k (first v)\n                     [v n] (split-with p (rest v))]\n                 (f (conj m {k v}) n))))]\n    (f {} v)))", "problem": 105, "user": "4ffa8affe4b0678c553fc3bd"}, {"code": "(fn [xs]\n  (loop [xs xs m {}]\n    (if (empty? xs) m\n      (let [k (first xs)\n            [v more] (split-with number? (rest xs))]\n        (recur more (assoc m k v))))))", "problem": 105, "user": "50fbf811e4b0d10d794c19f1"}, {"code": "(fn [s] (first (reduce (fn [[coll key] new] (if (keyword? new) [(conj coll [new []])\n                                                       new]\n                                       [(update-in coll [key] #(conj % new)) key]))\n                      [{} nil] s)))", "problem": 105, "user": "5294e44de4b02ebb4ef75016"}, {"code": "(fn [s]\n  (loop [s s cur {} k nil]\n    (cond\n      (empty? s) cur\n      (keyword? (first s)) (recur (rest s) (assoc cur (first s) []) (first s))\n      :else (recur (rest s) (assoc cur k (conj (get cur k) (first s))) k))))", "problem": 105, "user": "527cd633e4b0757a1b17136f"}, {"code": "(fn [xs]\n  (loop [acc {} xs xs]\n    (let [akey (first xs)\n          nums (vec (take-while #(number? %) (rest xs)))\n          remain (drop-while #(number? %) (rest xs))]\n      (if (empty? xs)\n        acc\n        (recur (assoc acc akey nums) remain)))))", "problem": 105, "user": "524740e7e4b05ef8e38e635d"}, {"code": "(fn  [y]\n  (letfn [ (r [a x]\n          (println a)\n        (if (keyword? x)\n          {:result\n           (assoc (:result a) x [])\n           :current\n           x\n           }\n          (update-in a [:result (:current a)] conj x)\n          ))]\n    (:result (reduce r {:result {} :current :x } y))))", "problem": 105, "user": "518c5236e4b087e178201de0"}, {"code": "(fn identify-keys-and-values [v]\n  (first (reduce \n\n          (fn [[a,k] x]\n            (if (instance? clojure.lang.Keyword x)\n              [(assoc a x []) ,x]\n              (let [v (a k)]\n                [(assoc a k (conj v x)),k] )))\n          \n          [{},nil]\n          v)))", "problem": 105, "user": "515bbcd9e4b0388ca8ca1521"}, {"code": "(fn[c] (get (reduce (fn [a b] (if (keyword? b) (assoc (assoc-in a [:map b] []) :key b) (assoc-in a [:map (get a :key)] (conj (get-in a [:map (get a :key)]) b)))) {:key nil :map {}} c) :map))", "problem": 105, "user": "52c1bd29e4b07a9af579236a"}, {"code": "(fn [s]\n  (loop [c {} k nil [s1 & r] s]\n    (cond\n      (nil? s1) c\n      (keyword? s1) (recur (assoc c s1 []) s1 r)\n      :else (recur (assoc c k (conj (c k) s1)) k r))))", "problem": 105, "user": "51929214e4b08962174cf74c"}, {"code": "(fn f\n  ([x] (f x {}))\n  ([[k & r] a]\n     (if k\n       (let [[v n] (split-with number? r)]\n        (f n (conj a [k v])))\n       a)))", "problem": 105, "user": "519136e9e4b0f8ef0be96c01"}, {"code": "(fn [xs]\n  (loop [xs xs m {} k nil]\n    (if (seq xs)\n      (if (keyword? (first xs))\n        (recur (rest xs) (assoc m (first xs) []) (first xs))\n        (recur (rest xs) (assoc m k (conj (m k) (first xs))) k))\n      m)))", "problem": 105, "user": "4ea365e2535d7eef308072c5"}, {"code": "(fn [s]  (loop [k nil acc {} s s]\n    (if (empty? s)\n      acc\n      (let [x (first s)]\n        (if (keyword? x)\n          (recur x (assoc acc x []) (rest s))\n          (recur k (assoc acc k (conj (get acc k []) x)) (rest s)))))))", "problem": 105, "user": "52ba43d0e4b07a9af57922cd"}, {"code": "(fn __ [x]\n  (->> x\n    (interpose nil)\n    (partition-by keyword?)\n    (mapcat (fn [[k :as v]] (if (keyword? k) [k] [(keep identity v)])))\n    (apply hash-map)\n    ))", "problem": 105, "user": "52828298e4b0757a1b17145b"}, {"code": "(fn identify [v]\n  ((reduce\n    (fn [[m l-k] x]\n      (if (keyword? x)\n        [(merge m {x []}) x]\n        [(update-in m [l-k] #(conj % x)) l-k]\n        )\n      )\n    [{} nil]\n    v) 0))", "problem": 105, "user": "5094057fe4b097f48cc38593"}, {"code": "(fn key-val-map \n  ([x] (key-val-map x {}))\n  ([[k & v] m]\n   (let [[int-list r] (split-with number? v)]\n     (if k\n       (recur\n        r\n        (assoc m k int-list))\n       m))))", "problem": 105, "user": "51a97f7ae4b08d8ec191b827"}, {"code": "(fn my-identify-keys-and-values\n [vals-to-group]\n (letfn [(get-rest [coll] (mapcat #(vector % []) (drop-last coll)))] \n   (if (= [] vals-to-group)\n     {}\n     (apply merge (map #(if (= 1 (count (first %)))\n           (hash-map (first (first %)) (into [] (second %)))\n           (assoc (apply assoc {} (get-rest (first %))) (last (first %)) (into [] (second %))))\n        (partition 2 (partition-by type vals-to-group)))))))", "problem": 105, "user": "509a25b7e4b0efbae1fbc0a8"}, {"code": "(fn f\n  [[k & r]]\n  (if k\n    (let [[v q] (split-with integer? r)]\n      (conj {k v} (f q)))\n    {}))", "problem": 105, "user": "52951156e4b02ebb4ef7501b"}, {"code": "(fn stuff [data]\n  (if (not-empty data)\n    (let\n      [k (first data)\n       more (rest data)]\n      (conj {k (take-while (complement keyword?) more)} (stuff (drop-while (complement keyword?) more))))\n    {}))", "problem": 105, "user": "4f03641a535dcb61093f6a9b"}, {"code": "(fn part [xs]\n  (loop [acc {}\n         key nil\n         [y & ys] xs]\n    (cond\n     (nil? y) acc\n     (keyword? y) (recur (assoc acc y []) y ys)\n     :else (recur (update-in acc [key] #(conj % y)) key ys))))", "problem": 105, "user": "511aa2a4e4b0c87c59c9670a"}, {"code": "(fn [a] (apply hash-map (reduce #(if (keyword? %2) (conj % %2 []) (assoc % (dec (count %)) (conj (last %) %2))) [] a)))", "problem": 105, "user": "52c6a0abe4b0c2d177d62111"}, {"code": "#(reduce (fn [m [k v]] \n           (assoc m k v)) \n         {} \n         (partition 2 \n                    (mapcat \n                      (fn [[primeiro & resto :as sequencia]]\n                        (if (keyword? primeiro)\n                          (if (seq resto)\n                            (interpose () sequencia)\n                            sequencia)\n                          (list sequencia)))\n                      (partition-by keyword? %))))", "problem": 105, "user": "52c8758be4b0c2d177d62135"}, {"code": "(fn [s]\n  (loop [items s\n         result {}\n         last-key nil]\n    (if (seq items)\n      (let [item (first items)]        \n        (if (keyword? item)\n          (recur (next items)\n                 (assoc result item [])\n                 item)\n          (recur (next items)\n                 (assoc result last-key\n                        (conj (get result last-key) item))\n                 last-key)))\n      result)))", "problem": 105, "user": "5236b6bce4b05f3be1c7c8fe"}, {"code": "(fn to-map [a-seq]\n  (letfn [(split-keywords [el]\n        (let [f (first el)]\n           \n          \t(if (keyword? f) \n          \t\t(if (> (count el) 1)\n               \t\t(interpose '() el)\n          \t\t\tel\n          \t\t)\n               (list el)\n            )\n        )\n     )]\n   (apply hash-map (mapcat split-keywords (partition-by #(keyword? %) a-seq))) \n   )\n)", "problem": 105, "user": "52763696e4b03e8d9a4a74d7"}, {"code": "(fn [c] (into {} (map #(let [[[x] y] %] [x y]) (partition 2 (map #(filter identity %) (partition-by keyword? (interpose nil c)))))))", "problem": 105, "user": "51a10b2ce4b0b292b01ee3fe"}, {"code": "#((reduce (fn [[m n] x] (if (keyword? x) [(assoc m x n) ()] [m (conj n x)])) [{} ()] (reverse %)) 0)", "problem": 105, "user": "52b453b0e4b0c58976d9ad21"}, {"code": "(fn [x] \n   (reduce \n     #(if(keyword? %2)\n        (assoc %1 %2 [])\n        (assoc %1 (first (first %1)) (conj (second (first %1))%2) )\n        ) \n     {} x)\n  )", "problem": 105, "user": "52bbd09ee4b07a9af57922ee"}, {"code": "(fn kv [coll]\n  (if (keyword? (first coll))\n    (let [vs (take-while (complement keyword?) (rest coll))\n          vrest (drop-while (complement keyword?) (rest coll))]\n      (merge {(first coll) vs} (kv vrest))\n      )\n    {}\n    )\n  )", "problem": 105, "user": "52e59ca5e4b09f7907dd1464"}, {"code": "(fn [coll]\n  (let [step (fn step \n               [last-keyword c acc]\n               (cond\n                (empty? c) acc\n                (keyword? (first c)) (step (first c) (rest c) (assoc acc (first c) []))\n                :else\n                (step last-keyword (rest c) (assoc acc last-keyword (conj (acc last-keyword) (first c))))\n                )\n               )]\n    (step nil coll {})\n    )\n  )", "problem": 105, "user": "529d4f4be4b04e0c58e87b79"}, {"code": "(fn i [c]\n   (if (empty? c) {}\n       (let [k (first c)\n             [v r] (split-with #(not (keyword? %)) (rest c))]\n         (assoc (i r) k (vec v)))))", "problem": 105, "user": "52c25645e4b07a9af579237d"}, {"code": "(fn create-map\n  [l]\n  (loop [curr-key nil, curr-val [], acc {}, curr l]\n    (cond (empty? curr) (if (nil? curr-key) acc (conj acc [curr-key curr-val]))\n          (nil? curr-key) (recur (first curr) curr-val acc (rest curr))\n          (keyword? (first curr)) (recur (first curr) [] (conj acc [curr-key curr-val]) (rest curr))\n          :else (recur curr-key (conj curr-val (first curr)) acc (rest curr)))))", "problem": 105, "user": "52dd6cc8e4b09f7907dd13e2"}, {"code": "(fn [coll]\n  (second\n   (reduce (fn [[last-k m] x]\n             (if (keyword? x)\n               [x (assoc m x [])]\n               [last-k (update-in m [last-k] conj x)]))\n           [nil {}]\n           coll)))", "problem": 105, "user": "50d8de3fe4b01f0871336e72"}, {"code": "#(loop [xs (seq %) r {}]\n\t  (if (seq xs)\n\t    (let [k (take 1 xs) v (->> xs (drop 1) (take-while number?))]\n          (recur (drop  (inc (count v)) xs) (assoc r (first k) (or v []))))\n\t    r))", "problem": 105, "user": "4ef9c8f9535dced4c769f26b"}, {"code": "(fn conv [s]\n    (reduce (fn [r [k v]] \n              (assoc (into r (zipmap k (repeat []))) (last k) v)) \n            {} (partition 2 (partition-by keyword? s))))", "problem": 105, "user": "52e3e6a8e4b09f7907dd1448"}, {"code": "(fn f [a c [x & y]]\n  (if x\n    (if (ifn? x)\n      (f (assoc a x []) x y)\n      (f (update-in a [c] conj x) c y))\n    a)) {} 0", "problem": 105, "user": "51ad244fe4b09397d510977f"}, {"code": "(fn [coll]\n  (loop [coll (partition-by keyword? coll)\n         result {}]\n    (if-not (seq coll)\n      result\n      (if (= (count (first coll)) 1)\n        (recur (rest (rest coll)) (assoc result (first (first coll)) (first (rest coll))))\n        (recur (rest (rest coll)) (assoc (merge result (zipmap (rest (reverse (first coll))) (repeat []))\n                                                ) (first (reverse (first coll))) (first (rest coll))))\n       ))))", "problem": 105, "user": "52fcfeeee4b047fd55837027"}, {"code": "(fn [s]\n  (loop [m {}\n         s s\n         curkey nil]\n    (if (seq s)\n      (let [f (first s)]\n        (if (keyword? f)\n          (recur (assoc m f [])\n                 (next s)\n                 f)\n          (recur (assoc m curkey (conj (m curkey) f))\n                 (next s)\n                 curkey)))\n      m)))", "problem": 105, "user": "52d3f666e4b09f7907dd1327"}, {"code": "(fn[sq] \n    (loop[s sq r {} k nil] \n      (let[e (first s) rs (rest s)] \n        (if(empty? s) \n          r \n          (if(keyword? e) \n            (recur rs (assoc r e []) e) \n            (recur rs (assoc r k (conj (get r k) e)) k)\n            )\n          )\n        )\n      )\n    )", "problem": 105, "user": "52e68e61e4b09f7907dd1479"}, {"code": "(fn[v]\n  (into {}\n    (for [x v\n         :when (keyword? x)\n         :let [y (drop-while #(not= x %) v)]]\n            [x (vec (take-while (complement keyword?) (rest y)))])))", "problem": 105, "user": "52f818a6e4b047fd55836fcc"}, {"code": "(fn [x] (let [start (reduce #(if (keyword? %2)\n                   (conj % [%2])\n                   (conj (rest %) (conj (first %) %2))) [] x)]\n           (reduce \n             (fn [hashy x] \n               (if (= 1 (count x))\n                 (assoc hashy (first x) [])\n                 (assoc hashy (first x) (vec (rest x)))))\n             {}      \n             start)))", "problem": 105, "user": "52fa4f48e4b047fd55836ff7"}, {"code": "(fn keyword-map [[head & tail :as coll]]\n  (if (seq coll)\n    (let [[numbers remaining] (split-with (complement keyword?)\n                                        tail)]\n      (merge {head numbers} (keyword-map remaining)))\n    {}))", "problem": 105, "user": "530578ede4b0d8b024fd3760"}, {"code": "(fn ikv [s]\n  (let [create-map (fn [s]\n                     (loop [s2 s, result {}]\n                       (if (empty? s2)\n                         result\n                         (recur (rest s2) (conj result [(first s2) []])))))\n        proc-pair (fn [pair]\n                    (let [ks  (first pair)\n                          nss (last pair)\n                          m   (create-map ks)\n                          lk  (last ks)\n                          r (assoc-in m [lk] nss)]\n                            (assoc-in m [lk] nss)))\n        s2 (partition-by keyword? s)\n        s3 (partition-all 2 s2)]\n    (loop [s4 s3, result {}]\n      (if (empty? s4)\n        result\n        (recur (rest s4) (merge result (proc-pair (first s4))))\n        ))))", "problem": 105, "user": "52cf084ce4b07d0d72b27399"}, {"code": "(fn identify-keys-and-values \n\t([coll] (identify-keys-and-values coll {}))\n\t([coll m]\n\t\t(cond\n\t\t\t(empty? coll)\n\t\t\tm\n\t\t\t(keyword? (first coll))\n\t\t\t(identify-keys-and-values \n\t\t\t\t(drop-while number? (rest coll)) \n\t\t\t\t(assoc m (first coll) (take-while number? (rest coll))))\n\t\t)\n\t)\n)", "problem": 105, "user": "52f10094e4b05e3f0be25ee8"}, {"code": "(fn keyvals\n  ([ls] (keyvals ls {}))\n  ([ls acc]\n     (letfn [(helper [a ls acc]\n  (if (or (empty? ls) (keyword? (first ls))) \n    acc\n    (helper a (rest ls) (assoc acc a (conj (get acc a) (first ls))))))]\n       (cond (empty? ls) acc\n             (keyword? (first ls))\n             (keyvals (rest ls) (merge acc (helper (first ls) (rest ls)  {(first ls) []})))\n                      :else\n                      (keyvals (rest ls) acc)))))", "problem": 105, "user": "5301157ae4b0d8b024fd3717"}, {"code": "(fn pb [s]\n  (let [chunked (partition-by #(cond (keyword? %) % (number? %) \"number?\") s)]\n    (into {} (apply merge (map #(apply hash-map %) (partition 2 (reverse \n    (loop [s chunked ret nil]\n      (let [fst (ffirst s)\n            snd (second s)\n            n (if (keyword? (first snd)) [] snd)\n            nxt (if (keyword? (first snd)) (drop 1 s) (drop 2 s))]\n        ;(prn \"fst\" fst \"snd\" snd \"n\" n \"nxt\" nxt \"ret\" ret)\n        (cond \n          (not fst) ret\n          (not snd) (cons [] (cons fst ret))\n          :else \n            (recur nxt (cons n (cons fst ret))))))))))))\n  )", "problem": 105, "user": "52ffb7f2e4b0d8b024fd370b"}, {"code": "(fn [coll]\n  (first (reduce\n           (fn [[result-map curr-key] elt]\n             (if (keyword? elt)\n               [(assoc result-map elt []) elt]\n               [(update-in result-map [curr-key] conj elt) curr-key]))\n           [{} (first coll)] coll)))", "problem": 105, "user": "53070615e4b02e821686979e"}, {"code": "(fn f [x](\n\tletfn [\n\t(appendkey[acc el] (assoc acc el []))\n\t(appendval [acc el] (assoc acc (key(last acc)) (conj (val(last acc)) el)))\n\t]\n(reduce (fn[acc el] (if(keyword? el)(appendkey acc el)(appendval acc el))) \n(sorted-map)\nx\n\t)))", "problem": 105, "user": "5307e4ece4b02e82168697a9"}, {"code": "(fn kvs [coll]\n  (loop [s coll\n         m {}]\n    (if (empty? s)\n      m\n      (let [[k r1] (split-with keyword? s)\n            [v r2] (split-with number? r1)]\n        (if (= 1 (count k))\n          (recur r2 (assoc m (first k) v))\n          (recur (rest s) (assoc m (first k) [])))))))", "problem": 105, "user": "530e9729e4b08068f379ecbc"}, {"code": "#(first (reduce (fn [[r p] e] (if (keyword? e) [(assoc r e []) e] [(update-in r [p] conj e) p]) )  [{} nil] %))", "problem": 105, "user": "4e3a9dae535deb9a81d77f4a"}, {"code": "#((fn f [x y z]\n  (if-not (empty? z)\n    (if (keyword? (first z))\n      (f (assoc x (first z) []) (first z) (rest z))\n      (f (merge-with into x {y [(first z)]}) y (rest z)))\n    x)) {} (first %) (rest %))", "problem": 105, "user": "529b44afe4b02ebb4ef7509d"}, {"code": "(fn x \n  ([coll] (if (empty? coll) {}\n            (let [[vals rest] (split-with (complement keyword?) (rest coll))]\n              (assoc (x rest) (first coll) vals)))))", "problem": 105, "user": "532347dde4b09d4e7a9b54cc"}, {"code": "(fn [xs]\n   (loop [[k & xs] xs\n          res {}]\n     (cond\n       (nil? k) res\n       (empty? xs) res\n       :else (let [[vs xs] (split-with (comp not keyword?) xs)\n             res (assoc res k vs)]\n         (recur xs res)))))", "problem": 105, "user": "52dc2bc8e4b09f7907dd13ca"}, {"code": "#(loop [v % k nil m {}]\n  (if (empty? v)\n    m\n    (if (keyword? (first v))\n      (recur (next v) (first v) (assoc m (first v) []))\n      (recur (next v) k (merge-with conj m {k (first v)}))\n    )\n  )    \n)", "problem": 105, "user": "5176afd2e4b085adf681d889"}, {"code": "(fn vecmap [coll]\n  (let [split-when (fn [f coll]\n                     (loop [remaining coll curr [] splits []]\n                       (if-let [s (seq remaining)]\n                         (let [[x & xs] s]\n                           (if (f x)\n                             (recur xs [] (conj splits curr))\n                             (recur xs (conj curr x) splits)))\n                         (conj splits curr))))\n        keys (filter keyword? coll)\n        vals (next (split-when keyword? coll))]\n    (zipmap keys vals)))", "problem": 105, "user": "5326c5f7e4b09d4e7a9b54f2"}, {"code": "(fn create-map [xs]\n  (#(if (empty? (second %))\n      (first %)\n      (conj (first %) (hash-map (first (second %)) (last %))))\n    (reduce\n      (fn [[a b c] n]\n        (if (keyword? n)\n          (if (empty? b)\n            [a [n] c]\n            [(conj a (hash-map (first b) c)) [n] []])\n          [a b (conj c n)]))\n        [{} [] []] xs)))", "problem": 105, "user": "531c0619e4b08068f379ed98"}, {"code": "(fn [s]\n  (loop [s s\n         result {}]\n    (if (empty? s)\n      result\n      (let [k (first s)\n            v (take-while number? (rest s))]\n        (recur (drop (inc (count v)) s) (assoc result k v))))))", "problem": 105, "user": "5310e7aee4b08068f379ecdc"}, {"code": "(fn [x] \n  (let [g (into [] (rest (clojure.string/split (apply str x) #\":\")))]\n    (zipmap (map keyword (map str (map first g))) \n            (map #(replace {\\0 0 \\1 1 \\2 2 \\3 3 \\4 4 \\5 5 \\6 6 \\7 7 \\8 8 \\9 9} %) (map vec (map rest g))))))", "problem": 105, "user": "525c575be4b0cb4875a45d38"}, {"code": "(fn [col]\n  (if (empty? col)\n    {}\n  (->> (reduce (fn [ret cur]\n            (if (keyword? cur)\n              (conj ret [cur])\n              (conj (vec (drop-last ret)) (conj (last ret) cur)))) [] col)\n       (map #(hash-map (first %) (rest %)))\n       (apply merge)\n       ))\n    \n  )", "problem": 105, "user": "525ed5f4e4b0cb4875a45db8"}, {"code": "(fn keyval\n  [xs]\n  (letfn [(f [[k & vs]] {k (if vs vs '())})\n          (partition-at\n  [pred coll]\n  (when (seq coll)\n    (lazy-seq\n      (let [fst (first coll)\n            [run remaining] (split-with (complement pred) (rest coll))]\n        (cons (cons fst run) (partition-at pred remaining))))))\n] (into {} (map f (partition-at keyword? xs)))))", "problem": 105, "user": "4ff3df0fe4b0678c553fc355"}, {"code": "(fn [a]\n  (if (empty? a)\n    {}\n    (let [b (partition 2 (partition-by class a))]\n      (apply merge (into \n                    (map (fn [[x y]] (hash-map (last x) (vec y))) b)\n                    (flatten (map \n                              (fn [[x _]] (map #(hash-map % []) (drop-last 1 x))) \n                              (filter #(< 1 (count (first %))) b))))))))", "problem": 105, "user": "532418f3e4b09d4e7a9b54d8"}, {"code": "(fn [l]\n      (letfn [(toMap [lat]\n                (if (empty? lat)\n                  []\n                  (let [k (first lat)\n                        v (into [] (for [l (rest lat) :while (not (keyword? l))] l))\n                        n (count v)]\n                    (cons k (cons v (toMap (nthrest lat (+ 1 n))) )))))]\n        (if (empty? l) {} (apply (partial assoc {}) (toMap l)))))", "problem": 105, "user": "5125029de4b0ce9225d2ed3e"}, {"code": "(fn [x]\n  (apply merge {} (for [[ks vs] (partition 2 (partition-by keyword? x))]\n\n                  (merge (let [empty-keys (butlast ks)]\n                           (zipmap empty-keys (repeat [])))\n                         {(last ks) vs}))))", "problem": 105, "user": "509e62a8e4b08df8156e9e2e"}, {"code": "(fn self [[k & vs]]\n   (if (nil? k) {}\n     (do \n       (merge \n        {k (take-while (complement keyword?) vs)} \n        (self (drop-while (complement keyword?) vs))))))", "problem": 105, "user": "531490bde4b08068f379ed17"}, {"code": "(fn [coll]\n  (loop [[x & xs] coll, result {}, k nil]\n    (cond (nil? x) result\n          (keyword? x) (recur xs (update-in result [x] vec) x)\n          :else (recur xs (update-in result [k] #(conj % x)) k))))", "problem": 105, "user": "53300924e4b019098a6f8b55"}, {"code": "(fn [kvals]\n  (into {}\n    (reduce #(if (keyword? %2) (cons [%2 []] %1) \n      (let [[k l] (first %1)] (cons [k (conj l %2)] (rest %1)))) (list) kvals)))", "problem": 105, "user": "533ab9abe4b0e30313ee6cbf"}, {"code": "(fn  [s]\n  (let [vals (fn [s k] (cons k (take-while #(not (keyword? %)) (rest (drop-while #(not= % k) s)))))]\n    (into {}\n          (map #(hash-map (first %) (vec (rest %))) \n            (map (partial vals s) (filter keyword? s))))))", "problem": 105, "user": "4f47eab2e4b0d56e7bb92bc6"}, {"code": "(fn [col]\n   (if (empty? col) \n     {}\n     (apply merge (map #(if (= 1 (count (first %))) \n                          {(first (first %)) (second %)}\n                          (assoc (reduce (fn [m x] (assoc m x [])) {} (butlast (first %))) (last (first %)) (second %)))\n                       (partition 2 (partition-by number? col))))))", "problem": 105, "user": "506d5e4ce4b0a302964c5493"}, {"code": "(fn gl [rslt [x & lst]]\n  (if (empty? lst) rslt\n    (let [[a b] (split-with (complement keyword?) lst)]\n      (recur (assoc rslt x a) b)\n     ))) {}", "problem": 105, "user": "5281a445e4b0757a1b17143a"}, {"code": "(fn [coll]\n  (->> (partition-by #(if (keyword? %) %) coll)\n       (reduce (fn [l [k & _ :as v]] \n                 (if (keyword? k) \n                   (cons [k []] l)\n                   (cons [(ffirst l) v] (rest l)))) [] )\n       (into {})))", "problem": 105, "user": "51696ee7e4b03f62cda68ce8"}, {"code": "(fn [lst]\n  (into {}\n        (reverse\n            ((fn [l res k v]\n               (if (empty? l) (if (nil? k) res (assoc res k v))\n                 (if (keyword? (first l))\n                   (recur (rest l) (if (nil? k) res (assoc res k v)) (first l) [])\n                   (recur (rest l) res k (conj v (first l))))))\n             lst {} nil []))))", "problem": 105, "user": "51da631be4b02ceefd947766"}, {"code": "(fn [coll]\n  (letfn [(step [c]\n            (if (> (count c) 1)\n              (let [key-size (count (first c))]\n                (if (= key-size 1)\n                  (concat [(first (first c)) (vec (second c))] (step (drop 2 c)))\n                  (concat [(first (first c)) []] (step (cons (rest (first c)) (rest c))))))))]\n    (let [vec-result (step (partition-by keyword? coll))]\n      (if (seq vec-result)\n        (apply (partial assoc {}) vec-result)\n        {}))))", "problem": 105, "user": "50436470e4b034ff00315d23"}, {"code": "(fn broad-map [xs]\n  (->> xs\n       (partition-by keyword?)\n       (partition 2)\n       (mapcat (fn [[ks vs]]\n                 (concat \n                  [[(last ks) vs]]\n                  (map (fn [k] [k []]) (butlast ks)))))\n       (into {})))", "problem": 105, "user": "52d2ca1ce4b099d49816f0b4"}, {"code": "(let [not-kw? (comp not keyword?)]\n  (fn ->kw-map [xs]\n    (loop [m  {}, xs (drop-while not-kw? xs)]\n      (if-let [[kw & xs] (seq xs)]\n        (let [[vs xs] (split-with not-kw? xs)]\n          (recur (assoc m kw vs) xs))\n        m))))", "problem": 105, "user": "532ab0bde4b09d4e7a9b5527"}, {"code": "(fn [x]\n   (apply hash-map \n          (reduce \n           #(if (keyword? %2) \n              (conj %1 %2 []) \n              (conj (pop %1) (conj (last %1) %2))) \n           [] x)))", "problem": 105, "user": "53468f6ce4b084c2834f4a3f"}, {"code": "(fn [sq]\n  (loop [ret {} sq sq]\n    (if (empty? sq) ret\n      (let [k (first sq)\n            vs (vec (take-while integer? (rest sq)))]\n        (recur (conj ret (hash-map k vs)) (drop (inc (count vs)) sq))))))", "problem": 105, "user": "5300158ae4b0d8b024fd370f"}, {"code": "(fn [r] (if (empty? r) {} (let [rez (let [l (map-indexed vector (partition-by keyword? r)) \n                                            even (filter (fn [[i v]] (even? i)) l) odd (filter (fn [[i v]] (odd? i)) l)]\n                                        (flatten (for [[i1 v1] even [i2 v2] odd :when (= 1 (- i2 i1))]  (if (= 1 (count v1)) {(first v1) (into [] v2)}                                                                       \n                                        (conj (map #(assoc {} % []) (drop-last v1)) (assoc {} (last v1) (into [] v2)))))))]                              \n                                        (if (= 1 (count rez)) (first rez) (apply merge rez)))))", "problem": 105, "user": "52265e41e4b04e78ff2e1981"}, {"code": "(fn [v]\n   (->>\n    (for [[keys vals] (partition 2 (partition-by keyword? v))]\n      (concat\n       [(last keys) (vec vals)]\n       (mapcat #(vec (list % [])) (butlast keys))))\n    (apply concat)\n    (apply hash-map)))", "problem": 105, "user": "53224d45e4b09d4e7a9b54c0"}, {"code": "(fn [s]\n  (let [s2 (for [[k v] (partition 2 (partition-by keyword? s))] [k v])\n        f (fn [x y] (concat (for [z (butlast x)] [z []]) [[(last x) (vec y)]]))]\n    (into {} (apply concat (for [[m n] s2] (f m n))))))", "problem": 105, "user": "53219cece4b09d4e7a9b54b7"}, {"code": "(fn f [l]\n  (loop [i (first l)\n         s (rest l)\n         k nil\n         m {}]\n    (if (nil? i)\n      m\n      (if (keyword? i)\n        (recur (first s) (rest s) i (assoc m i []))\n        (recur (first s) (rest s) k (assoc m k (conj (m k) i)))))))", "problem": 105, "user": "53460d02e4b084c2834f4a39"}, {"code": "(fn f [l]\n  (let [l (drop-while (comp not keyword?) l)]\n    (if (empty? l)\n      {}\n      (merge {(first l) (take-while (comp not keyword?) (next l))} (f (next l)) ))))", "problem": 105, "user": "5349ac2be4b084c2834f4a67"}, {"code": "(fn identify-k-v\n  ([s]\n   (if-not (empty? s)\n     (identify-k-v (drop-while (complement keyword?) (rest s)) {(first s) (take-while (complement keyword?) (rest s))})\n     {}))\n  ([s b]\n   (if-not (empty? s)\n     (identify-k-v (drop-while (complement keyword?) (rest s)) (merge b {(first s) (take-while (complement keyword?) (rest s))}))\n     b)))", "problem": 105, "user": "52f3af46e4b05e3f0be25f14"}, {"code": "(fn [coll]\n  (loop [acc {} k nil remaining coll]\n    (if-let [s (seq remaining)]\n      (if (keyword? (first s))\n        (recur (assoc acc (first s) []) (first s) (rest s))\n        (recur (update-in acc [k] conj (first s)) k (rest s)))\n      acc)))", "problem": 105, "user": "50fc299ee4b0d10d794c19f2"}, {"code": "#(first\n  (reduce (fn [[m k] n]\n            (if (keyword n)\n              [(assoc m n []) n]\n              [(update-in m [k] conj n) k]))\n          [{} nil]\n          %))", "problem": 105, "user": "5175533fe4b0dea9bbfba575"}, {"code": "(fn onezerofive\n  [l]\n    (loop [m {}\n           l l]\n      (let [k (first l)\n            numbers (vec (take-while (comp not keyword?) (rest l)))]\n        (if (empty? l)\n          m\n          (recur (assoc m k numbers)\n                 (drop (+ 1 (count numbers)) l))))))", "problem": 105, "user": "4dadb891c9a9d6ed3699dc57"}, {"code": "(fn [l]\n  (loop [l l res {}]\n    (cond (empty? l) res\n          :else (recur (drop-while (complement keyword?) (drop 1 l))\n                       (assoc res (first l) (vec (take-while number? (drop 1 l))))))))", "problem": 105, "user": "50366589e4b0fbe0a74d26c3"}, {"code": "(fn [xs]\n  (loop  [acc {} x (partition-by #(if (keyword? %) % nil) xs)]\n    (if (empty? x) acc\n        (let [[[a] b & c] x]\n          (if (keyword? (first b))\n            (recur (assoc acc a []) (rest x))\n            (recur (assoc acc a b) c))))))", "problem": 105, "user": "52d1e364e4b0d9f9285948e7"}, {"code": "(fn [coll]\n  (let [ks (filter (complement nil?) (map-indexed (fn [a b] (when (keyword? b) a)) coll))]\n    (loop [iks ks m {}]\n      (let [i (first iks)\n            j (if (next iks)\n                (second iks)\n                (count coll))]\n        (if-not i\n          m\n          (recur (next iks)\n                 (assoc m (nth coll i) (subvec coll (inc i) j))))))))", "problem": 105, "user": "5341b141e4b00652c8746ecf"}, {"code": "#(if (empty? %) {}\n   (loop [d (rest %) k (first %) v [] m {}]\n     (cond (not (seq d))\n           (assoc m k v)\n           (keyword? (first d))\n           (recur (rest d) (first d) [] (assoc m k v))\n           :else\n           (recur (rest d) k (conj v (first d)) m))))", "problem": 105, "user": "5357b241e4b04ce2eb3ed282"}, {"code": "(fn [coll]\n  (dissoc \n   (reduce \n    #(if (keyword? %2) (assoc % %2 [] :*last %2) (merge-with concat % {(% :*last) [%2]})) \n    {:*last nil} \n    coll) \n   :*last))", "problem": 105, "user": "53307da1e4b019098a6f8b5e"}, {"code": "(fn [s]\n  (loop [res {}\n         s s]\n    (if (empty? s)\n      res\n      (recur (assoc res (first s) (vec (take-while (complement keyword?) (rest s))))\n             (drop-while (complement keyword?) (rest s))))))", "problem": 105, "user": "531d34cfe4b08068f379edac"}, {"code": "(fn id [x] \n  (if (empty? x)\n    {}\n    (conj (hash-map (first x)\n               (take-while #(not (keyword? %)) (rest x)))\n          (id (drop-while #(not (keyword? %)) (rest x))))))", "problem": 105, "user": "52e17e66e4b09f7907dd1423"}, {"code": "(fn [xs]\n  (apply hash-map\n         (loop [xs xs r []]\n           (if (empty? xs)\n             r\n             (let [not-keyword? (complement keyword?)\n                   k (first xs)\n                   [vs ys] (split-with not-keyword? (rest xs))]\n               (recur ys (conj r k vs)))))))", "problem": 105, "user": "53244c9de4b09d4e7a9b54db"}, {"code": "(fn [xs]\n  (->> xs\n       ((fn [xs]\n         (loop [acc []\n                [k & rest] xs]\n           (if-not k\n             acc\n             (let [[vs rest] (split-with (complement keyword?) rest)]\n               (recur (conj acc k vs) rest))))))\n       (partition 2)\n       (reduce (fn [h [k v]] (assoc h k v)) {})))", "problem": 105, "user": "5312cdaae4b08068f379ed03"}, {"code": "(fn [s] \n  (loop [rs s keys [] vals []] \n    (if (empty? rs) \n      (zipmap keys vals)\n      (recur (drop-while number? (rest rs)) (conj keys (first rs)) (conj vals (take-while number? (rest rs)))))))", "problem": 105, "user": "5093ca51e4b097f48cc38585"}, {"code": "(fn [[x & xs]]\n  (last \n   (reduce \n    (fn [[curr-key elems acc] x]\n      (if (keyword? x)\n        [x [] (assoc acc curr-key elems)]\n        (let [new-elems (conj elems x)] \n          [curr-key new-elems (assoc acc curr-key new-elems)])))\n    [x [] {}] xs)))", "problem": 105, "user": "52dd4fb4e4b09f7907dd13df"}, {"code": "(fn f [[h & t]]\n  (into {}\n    (if h\n      (let [[y z] (split-with number? t)]\n        (cons [h y]\n              (f z))))))", "problem": 105, "user": "526a7025e4b03e8d9a4a722a"}, {"code": "(fn [s]\n  (letfn [(helper [s k result]\n            (cond (empty? s) result\n                  (keyword? (first s)) (helper (rest s) (first s) (assoc result (first s) []))\n                  :else (helper (rest s) k (update-in result [k] (fn [v] (conj v (first s)))))))]\n    (helper s nil {})))", "problem": 105, "user": "515ffbfbe4b0e2be8aa20bdd"}, {"code": "(fn [coll] \n  (apply hash-map \n    (reduce \n       #(if (keyword? %2)\n         (conj %1 %2 [])\n\t     (conj (vec (butlast %1)) (conj (last %1) %2)))\n      [] \n      coll)))", "problem": 105, "user": "53513d28e4b084c2834f4ae3"}, {"code": "(fn [xs] (apply hash-map (mapcat #(if (keyword? (first %)) (if (= 1 (count %)) % (interpose [] %)) [%]) (partition-by keyword? xs))))", "problem": 105, "user": "531f1e63e4b08068f379edc2"}, {"code": "(fn k-v\n  [s]\n  (let [p (partition-by keyword? s)\n        ks (map last (take-nth 2 p))\n        vs (map vec (take-nth 2 (rest p)))]\n    (reduce (fn [r e]\n               (if (contains? r e)\n                 r\n                 (assoc r e [])))\n            (zipmap ks vs) (filter #(keyword? %) s))))", "problem": 105, "user": "5348cab4e4b084c2834f4a5e"}, {"code": "(fn [x]\n\t\t(loop [x x xv {} k nil]\n\t\t\t(if (empty? x)\n\t\t\t\txv\n\t\t\t\t(let [x1 (first x) xs (rest x) k (if (keyword? x1) x1 k)]\n\t\t\t\t\t(recur xs (assoc xv k \n\t\t\t\t\t\t(if (keyword? x1) \n\t\t\t\t\t\t\t[] \n\t\t\t\t\t\t\t(conj (k xv) x1)\n\t\t\t\t\t\t)) k\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t) \n\t)", "problem": 105, "user": "534f0b51e4b084c2834f4ac3"}, {"code": "(fn [coll]\n  (let [pairs (partition 2 (partition-by keyword? coll))]\n    (if (empty? pairs)\n      {}\n      (apply merge\n             (map (fn [[k v]]\n                    (let [last-pairs [(last k) v]\n                          butlast-pairs (for [k (butlast k)] [k []])]\n                      (into {} (conj butlast-pairs last-pairs))))\n                  pairs)))))", "problem": 105, "user": "5225271fe4b01819a2de42f9"}, {"code": "(fn\n  [xs]\n  (let [args (reduce \n      (fn \n        [a b] \n        (if \n          (keyword? b) \n          (concat a (vector b [])) \n          (concat [] (butlast a) (vector (conj (last a) b)))\n          )) [] xs)]\n          (if (empty? args)\n            {}\n          \t(apply (partial assoc {}) args)\n          )\n    ))", "problem": 105, "user": "536aa86de4b0243289761eb1"}, {"code": "(fn [v]\n   (dissoc\n     (reduce \n      #(if (keyword? %2)\n         (assoc %1 \"c\" %2)\n         (assoc %1 (%1 \"c\") (conj (%1 (%1 \"c\")) %2)))\n      (assoc (zipmap (filter keyword? v) (repeat [])) \"c\" nil)\n      v) \"c\"))", "problem": 105, "user": "51d4ed02e4b013d740b70dec"}, {"code": "(fn [coll]\n  (second\n    (reduce (fn [[kw dict] x]\n              (if (keyword? x)\n                [x (assoc dict x [])]\n                [kw (assoc dict kw (conj (dict kw) x))]))\n            [nil, {}] coll)))", "problem": 105, "user": "536d83cee4b0fc7073fd6e5e"}, {"code": "(fn [r k [h & t]]\n  (if h\n    (if (keyword? h)\n      (recur (assoc r h []) h t)\n      (recur (assoc r k (conj (r k) h)) k t))\n    r))\n{}\n0", "problem": 105, "user": "536e0930e4b0fc7073fd6e66"}, {"code": "(fn key-vals\n    ([xs] (key-vals {} nil xs))\n    ([acc k [h & r :as xs]]\n     (cond\n       (empty? xs)\n       acc\n       (keyword? h)\n       (key-vals (assoc acc h []) h r)\n       :else\n       (key-vals (assoc acc k (conj (acc k []) h)) k r))))", "problem": 105, "user": "5370ef22e4b0fc7073fd6ea0"}, {"code": "(fn [v]\n  (loop [k (first v) rv {} v (rest v)]\n    (if (empty? v)\n      rv\n      (if (keyword? (first v))\n        (recur (first v) (assoc rv (first v) []) (rest v))\n        (recur k (assoc rv k (conj (get rv k []) (first v))) (rest v))))))", "problem": 105, "user": "534f13b2e4b084c2834f4ac4"}, {"code": "(fn [s]\n    (loop [m {}\n           key (first s)\n           v []\n           items (rest s)]\n      (println :m m :key key :v v :items items)\n      (if (empty? items) \n        (if (nil? key)\n          m\n          (assoc m key v))\n        (let [i (first items)]\n          (if (keyword? i)\n            (recur \n             (assoc m key v)\n             i [] (rest items))\n            (recur\n             m\n             key\n             (conj v (first items))\n             (rest items)))))))", "problem": 105, "user": "53487737e4b084c2834f4a59"}, {"code": "(fn [v]\n  (loop [vector1 v\n         map-all {}\n         map-cur {}]\n    (cond\n     ;; if nothing left return map-all after merging map-cur\n     (empty? vector1) (conj map-all map-cur)\n     ;; if a keyword is encountered, conj map-cur to map-all, and create a new map\n     (keyword? (first vector1)) (recur (rest vector1)\n                                       (conj map-all map-cur)\n                                       (hash-map (first vector1) []))\n     ;; Otherwise, keep map-all as is, update map-cur by adding new element to a vector\n     :else (recur (rest vector1)\n                  map-all\n                  (hash-map (first (keys map-cur)) (conj (first (vals map-cur)) (first vector1)))))))", "problem": 105, "user": "53415755e4b00652c8746ecd"}, {"code": "(fn [xs] \n  (loop [[x & xs'] xs, acc {}, current nil]\n    (cond (nil? x) acc\n          (keyword? x) (recur xs' (assoc acc x []) x)\n          :else (recur xs' (assoc acc current (conj (acc current) x)) current))))", "problem": 105, "user": "536ca4bde4b0fc7073fd6e49"}, {"code": "(fn mapfromseq [x]\n  (let [groupandupdate (fn [coll entry pred]\n        (if (pred entry)\n          (conj coll (vector entry))\n          (conj (pop coll) (conj (peek coll) entry))))\n        split-before (fn [coll pred]\n                       (reduce #(groupandupdate %1 %2 pred) [] coll))]\n    (reduce #(assoc %1 (first %2) (rest %2)) {} (split-before x keyword?))))", "problem": 105, "user": "532727bae4b09d4e7a9b54fa"}, {"code": "(fn [xs]\n  (second\n  \t(reduce \n     \t(fn [[current-key, m] x]\n          (if (keyword? x)\n            [x, (assoc m x (get m x []))]\n            [current-key, (assoc m current-key\n                            (conj (get m current-key) x))]))            \n   \t\t[nil, {}]\n   \t\txs)))", "problem": 105, "user": "53800d99e4b06839e8705ebd"}, {"code": "(fn [xs]\n  (if (empty? xs) {}\n  (let [separated-list (reduce #(if (keyword? %2) \n                                    (conj %1 [%2]) \n                                    (update-in  %1 [(dec (count %1))] conj %2)) \n                               [[(first xs)]] \n                               (rest xs))]\n    (into {} (for [[x & xs] separated-list]\n              [x (vec xs)])))))", "problem": 105, "user": "53691dc7e4b0243289761e97"}, {"code": "#(letfn \n  [(f [[k & r]]\n      (when k\n        (let [[vls t] (split-with (complement keyword?) r)]\n          (concat [k vls] (f t)))))]\n  (apply array-map (f %)))", "problem": 105, "user": "5371167fe4b0fc7073fd6ea7"}, {"code": "(fn [seqn]\n  (loop [result {}, s seqn]\n    (if (empty? s)\n      result\n      (let [k (first s)\n            [v remaining] (split-with (complement keyword?) (rest s))]\n        (recur (assoc result k v) remaining)))))", "problem": 105, "user": "53834ed3e4b06839e8705edb"}, {"code": "(fn [input] \n  (loop [m {} s input]\n    (if (empty? s)\n      m\n      (let [[first & rest] s\n            [nums remaining] (split-with #(= (type %) (type 1)) rest)]\n        (recur (assoc m first nums) remaining)))))", "problem": 105, "user": "51a3b135e4b0e77c4ca60bf6"}, {"code": "(fn [ls]\n  (letfn [(r [m ls]\n             (if (empty? ls) m\n               (let [k  (first ls)\n                     vv (take-while (complement keyword?) (rest ls))]\n                 (recur (merge m {k vv}) (drop (inc (count vv)) ls)))))]\n    (r {} ls)))", "problem": 105, "user": "51df825de4b01188f062752b"}, {"code": "(fn [v]\n  (apply hash-map\n         (reduce #(if (keyword? %2)\n                    (conj % %2 [])\n                    (conj (vec (drop-last %)) (conj (last %) %2)))\n                 []\n                 v)))", "problem": 105, "user": "524b0645e4b09eba1c0223bf"}, {"code": ";(fn [coll]\n ;     (let [gr1 (partition-by keyword? (drop-while number? coll))\n  ;          gr-kwords (for [ks gr1 :when (and (keyword? (first ks)) (next ks))] (map #(vector % []) (drop-last ks)))\n   ;         grouped (partition 2 2 [[]] (map #(if (keyword? (first %)) (last %) %) gr1))]\n    ;    (into {} (map #(vec %) (apply concat grouped gr-kwords)))))\n    \n (fn [coll]\n      (letfn [ (fknums [coll acc]\n                       (if (seq coll)\n                         (let [hd (first coll) tl (rest coll)]\n                           (if (number? hd)\n                             (recur tl [(first acc) (conj (second acc) hd)])\n                             (lazy-seq  (cons acc (fknums tl [hd []])))))\n                         [acc]))]\n        (if (seq coll)\n          (let [[first-key & more] (drop-while number? coll)]\n            (into {} (map #(vec %)(fknums more [first-key []]))))\n          {})))", "problem": 105, "user": "50eddbc4e4b06330c1f87c4b"}, {"code": "#({0 {} 2 {:a [1]} 4 {:a [1], :b [2]} 7 {:a [1 2 3], :b [], :c [4]}} (count %))", "problem": 105, "user": "5336a339e4b0e30313ee6c7d"}, {"code": "(fn [xs]\n  (apply hash-map (reduce #(if (keyword? %2) \n                             (conj (conj %1 %2)\n                                   []) \n                             (conj (into [] (butlast %1))\n                                   (conj (last %1) %2)))\n                          [] xs)))", "problem": 105, "user": "5370f8ede4b0fc7073fd6ea2"}, {"code": "#(if (= (count %) 0) {}\n   (loop [r {} k (% 0) c []\n          l (rest (conj % :nil))]\n     (if (= k :nil) r\n       (let [x (nth l 0) l (rest l)]\n         (if (keyword? x) (recur (assoc r k c) x [] l)\n           (recur r k (conj c x) l))))))", "problem": 105, "user": "538d8bb8e4b0b51d73faae71"}, {"code": "(fn id-key-vals [coll]\n  (loop [m {} cur-key nil coll coll]\n    (cond\n      (empty? coll) m\n      (keyword? (first coll)) (recur (assoc m (first coll) []) (first coll) (rest coll))\n      :else (recur (assoc m cur-key (conj (cur-key m) (first coll))) cur-key (rest coll)))))", "problem": 105, "user": "4f849f76e4b033992c121c36"}, {"code": "#(first (reduce (fn [[m p] e]\n                  (if (number? e)                  \n                    [(update-in m [p] conj e) p]\n                    [(assoc m e []) e])) [{}] %))", "problem": 105, "user": "536973e5e4b0243289761e9e"}, {"code": "(letfn [(I [s]\n          (loop [s s r {}]\n            (cond (empty? s) r\n                  (keyword? (first s))\n                  (recur (drop-while (complement keyword?)\n                                     (rest s))\n                         (conj r {(first s) (take-while (complement keyword?)\n                                                        (rest s))})))))]\n  I)", "problem": 105, "user": "51a4416ae4b0def3c5c5868c"}, {"code": "#(dissoc (loop [[h & r] %\n                a {}\n                k nil\n                v []]\n           (cond (nil? h) (assoc a k v)\n                 (keyword? h) (recur r (assoc a k v) h [])\n                 :else (recur r a k (conj v h)))) nil)", "problem": 105, "user": "50ae0d24e4b0a40c9cfb08ce"}, {"code": "(fn [s]\n  (first (reduce (fn [[m k] e]\n                   (if (keyword? e)\n                     [(conj m [e []]) e]\n                     [(update-in m [k] conj e) k]))\n                 [{}]\n                 s)))", "problem": 105, "user": "5392b849e4b0b51d73faaeb1"}, {"code": "(fn group-by-keyword [s]\n  (let [s\n        (mapcat\n         #(if (every? keyword? %) [(first %) nil] [(first %)])\n         (partition 2 1 (conj s nil)))]\n    \n    (->>\n     (for [[[k] v] (partition 2 (partition-by keyword? s))] [k (if (= v '(nil)) '() v)])\n     (apply concat)\n     (apply hash-map))))", "problem": 105, "user": "4ddb696b535d02782fcbe9fa"}, {"code": "(fn keyvals [coll]\n  (if-let [[f & r] (seq coll)]\n    (let [[xs r'] (split-with (complement keyword?) r)]\n      (assoc (keyvals r') f xs))\n    {}))", "problem": 105, "user": "539a2901e4b0b51d73faaf0f"}, {"code": "(fn [s]\n  (loop [s s\n         accum {}]\n    (if (empty? s)\n      accum\n      (let [k (first s)\n            [vs rest-s] (split-with #(not (keyword? %)) (rest s))]\n        (recur rest-s (assoc accum k vs))))))", "problem": 105, "user": "53527551e4b084c2834f4af0"}, {"code": "(fn t10 [vals]\n  (if (empty? vals)\n    {}\n    (apply hash-map (loop [res [(first vals)] v (rest vals) temp []]\n                      (if (empty? v)\n                        (conj res temp)\n                         (cond\n                           (keyword? (first v)) (recur (conj res temp (first v)) (rest v) [])\n                           :else (recur res (rest v) (conj temp (first v)))))))))", "problem": 105, "user": "5046f909e4b03b02161376b5"}, {"code": "(fn [s]\n             (:map\n                    (reduce\n                      (fn [m k]\n                        (if (not (keyword? k))\n                          (update-in m [:map (:current m)] conj k )\n                          {:current k , :map (assoc (:map m) k [])}))\n                      {:current nil :map {}}\n                      s)))", "problem": 105, "user": "536f871de4b0fc7073fd6e7f"}, {"code": "(fn keys-values [s]\n  (second (reduce\n   (fn [[k m] e] (if (keyword? e)\n                   [e (assoc m e [])]\n                   [k (assoc m k (conj (m k) e))]))\n   [nil {}]\n   s)))", "problem": 105, "user": "530bf87ee4b02e82168697d5"}, {"code": "(fn [in]\n  (first\n   (reduce \n    (fn [[res kw] val]\n      (if (keyword? val)\n        [(assoc res val []) val]\n        [(merge-with conj res {kw val}) kw]))\n    [{} nil]\n    in)))", "problem": 105, "user": "51a768e0e4b0da5f497bde84"}, {"problem": 105, "code": "(fn f [xs]\n  (if-not (seq xs) {}\n    (loop [m {(first xs) []} \n          last-key (first xs)\n          xs (rest xs)]\n      (if-not (seq xs)\n        m\n        (let [x (first xs)]\n          (recur (if (keyword? x)\n                     (assoc m x [])\n                     (assoc m last-key (conj (m last-key) x)))\n                 (if (keyword? x) x last-key)\n                 (rest xs)))))))", "user": "529e3a4fe4b04e0c58e87b92"}, {"problem": 105, "code": "(fn [l]     (into {}\n        (map (fn [ [[a] b] ] (if (or (nil? b) (keyword? (first b))) [a []] [a b]))\n            (filter (fn [ [[a] b] ] (keyword? a))\n                (partition-all 2 1\n                    (partition-by (fn [x] (if (number? x) 1 x)) l)\n                )\n            )\n        )\n    )\n)", "user": "527ba695e4b03e8d9a4a7596"}, {"problem": 105, "code": "(fn\n  [coll]\n  (letfn [(step [[m k v] x]\n            (if (keyword? x)\n              (if k\n                [(concat m [k v]) x []]\n                [m x []])\n              [m k (conj v x)]\n              ))]\n            (if (seq coll)\n              (let [[m k v] (reduce step [[] nil nil] coll)]\n                (apply hash-map (concat m [k v])))\n              {})))", "user": "52dfc89be4b09f7907dd1405"}, {"problem": 105, "code": "(fn [coll]\n  (loop [x coll res{}]\n    (if (empty? x) res\n      (recur (drop-while number? (rest x)) (assoc res (first x) (vec (take-while number? (rest x))))))))", "user": "53a1b5c8e4b0ca733b9744c1"}, {"problem": 105, "code": "(fn [u]\n  (reduce\n   #(assoc % (first %2) (vec (rest %2)))\n   {}\n   (reduce\n    #(if (keyword? %2)\n       (conj % (vector %2))\n       (assoc % (- (count %) 1) (conj (last %) %2)))\n    []\n    u)))", "user": "4ec53f8c535d6d7199dd368b"}, {"problem": 105, "code": "(fn [y] (let [[f s l] [first second last]\n       t #(conj (l %) [(f %) (s %)])\n       u (fn [a b] (if (keyword? b) [b [] (t a)]\n                      [(f a) (conj (s a) b) (l a)]))]\n   (->> y (reduce u []) t butlast (into {}))))", "user": "53976599e4b0b51d73faaeea"}, {"problem": 105, "code": "(fn [m]\n   (loop [k m acc {} nk nil]\n     (if (empty? k)\n       acc\n       (if (keyword? (first k))\n         (recur (rest k) (assoc acc (first k) (vector)) (first k)) \n         (recur (rest k) (assoc acc nk (conj (acc nk) (first k))) nk)))))", "user": "53aaaf7ae4b047364c044444"}, {"problem": 105, "code": "(fn [s]\n  (loop [s s\n         acc {}]\n    (if (empty? s)\n      acc\n      (let [k (first s)\n            v (take-while (complement keyword?) (rest s))\n            r (drop (inc (count v)) s)]\n        (recur r (conj acc [k v]))))))", "user": "532bce35e4b09d4e7a9b5536"}, {"problem": 105, "code": "(fn ikv [s]\n  (let [[fst & rst] s\n        [head tail] (split-with (comp not keyword?) rst)\n        result (hash-map fst head)\n        ]\n    (if (not fst) {} (if (empty? tail) result (merge result (ikv tail))))))", "user": "534d1173e4b084c2834f4a98"}, {"problem": 105, "code": "(fn [coll]\n  (loop [ret {}\n         k nil\n         c coll]\n    (if (empty? c)\n      ret\n      (if (keyword? (first c))\n        (recur (merge ret {(first c) []}) (first c) (rest c))\n        (recur (merge-with concat ret {k [(first c)]}) k  (rest c))))))", "user": "4f041de1535dcb61093f6ba5"}, {"problem": 105, "code": "(fn [ar]\n  (dissoc (reduce (fn [m i]\n            (if (keyword? i)\n              (assoc (assoc m 'c i) i []) \n              (update-in m [(m 'c)] conj i)\n              )\n            ) {} ar) 'c)\n  )", "user": "53ae16e2e4b047364c044472"}, {"problem": 105, "code": "(fn my-change\n  [coll]\n  (if (empty? coll)\n    {}\n    (loop [allacc {}\n           curracc []\n           currkeyword (first coll)\n           coll (rest coll)]\n      (if (empty? coll)\n        (conj allacc [currkeyword curracc])\n        (if (keyword? (first coll))\n          (recur\n           (conj allacc [currkeyword curracc])\n           []\n           (first coll)\n           (rest coll))\n          (recur\n           allacc\n           (conj curracc (first coll))\n           currkeyword\n           (rest coll)))))))", "user": "53ac4719e4b047364c04445c"}, {"problem": 105, "code": "(fn kvs [s]\n \t(if (seq s)\n    \t(let [[k & r] s\n           \t  [vs r] (split-with #(not (keyword %)) r)]\n       \t\t(merge {k vs} (kvs r)))\n     {}))", "user": "53b39d82e4b047364c0444a6"}, {"problem": 105, "code": "(fn\n  [arr]\n  (reduce \n    #(if (keyword? (first %2))\n       (assoc % (first %2) [])\n       (merge % {(last (keys %)) %2}))\n    (sorted-map)\n    (partition-by keyword arr)))", "user": "5036eba7e4b0af0658af77a5"}, {"problem": 105, "code": "(fn [v]\n  (loop [r (seq v) k nil m {}]\n    (let [v (first r)]\n      (cond (empty? r) m\n            (keyword? v) (recur (rest r) v (assoc m v []))\n            :else (recur (rest r) k (assoc m k (conj (m k) v)))))))", "user": "538e36c7e4b0b51d73faae81"}, {"problem": 105, "code": "(partial reduce #(cond\n          (number? %2) (update-in %1 [(key (first %1))] conj %2)\n          (keyword? %2) (assoc %1 %2 [])\n          ) {})", "user": "51aefceee4b09397d5109797"}, {"problem": 105, "code": "(fn group-when-keyword [c]\n  (if (empty? c)\n    {}\n    (let [split (split-with (comp not keyword?) (rest c))]\n      (into {(first c) (first split)} (group-when-keyword (last split))))))", "user": "53acaf1fe4b047364c04445f"}, {"problem": 105, "code": "(fn f [[k & n]]\n  (if k\n    (let [[x y] (split-with number? n)]\n      (merge {k x} (f y)))\n    {}))", "user": "53523ae0e4b084c2834f4aee"}, {"problem": 105, "code": "(fn ikv [coll]\n  (if (seq coll)\n    (let [k (first coll)\n          [v rs] (split-with number? (rest coll))]\n      (merge {k v} (ikv rs)))\n    {}))", "user": "4ee528fb535d1385b2869d87"}, {"problem": 105, "code": "(fn [v] \n  (apply hash-map (mapcat \n                   identity \n                   (partition 2 (mapcat \n                                 #(if (keyword? (first %))\n                                    (interpose [] %)\n                                    (list %)) \n                                 (partition-by keyword? v))))))", "user": "53c1ce3ee4b00fb29b221268"}, {"problem": 105, "code": "(fn to-map [xs]\n    (apply hash-map \n    \t(mapcat #(if (keyword? (first %1)) (interpose '() %1) (list %1)) (partition-by keyword? xs))))", "user": "52e657e4e4b09f7907dd1472"}, {"problem": 105, "code": "(fn to-map [xs]\n     (loop [ys xs\n            keyword_ nil\n            values_ []\n            result {}]\n       (let [[y & yys] ys\n             putResult #(cond (nil? keyword_) result\n                              :else (conj result [keyword_ values_]))]\n       (cond \n         (empty? ys) (putResult)\n         (keyword? y) (recur yys y [] (putResult))\n         :else (recur yys keyword_ (conj values_ y) result)))))", "user": "53c38b8ce4b00fb29b22127b"}, {"problem": 105, "code": "(fn [s]\n   (first (reduce (fn [[acc key] v] \n                    (if (keyword? v)\n                      [(conj acc [v []]) v]\n                      [(update-in acc [key] conj v) key])) [{} nil] s)))", "user": "538db083e4b0b51d73faae74"}, {"problem": 105, "code": "(fn  [ret k cl]\n  (if (empty? cl) \n    ret\n    (let [f (first cl) c (rest cl)]\n      (if (keyword? f)\n        (recur (assoc ret f []) f c)\n        (recur (assoc ret k (conj (get ret k) f)) k c))))) {} nil", "user": "53b7c21ae4b047364c0444d4"}, {"problem": 105, "code": "(fn weird-map [coll]\n  (let [mapmaker (fn [bag item]\n                   (let [active (:active bag)]\n                     (if (keyword? item)\n                       (merge bag {item [] :active item})\n                       (merge bag {active (conj (active bag) item)}))))]    \n    (dissoc (reduce mapmaker {:active nil} coll) :active)))", "user": "53bf0913e4b0c98a41f5cc99"}, {"problem": 105, "code": "(fn [l] (first ( reduce (fn [[h kw] x] (if (keyword? x) [(assoc h x []) x] [ (update-in h [kw] conj x) kw]))  [{} nil] l )))", "user": "53b2a7f8e4b047364c04449c"}, {"problem": 105, "code": "(fn [coll]\n  (first (reduce (fn [acc val]\n                   (if (keyword? val)\n                     (vector (assoc (first acc) val []) val)\n                     (let [key (second acc)]\n                       (vector (update-in (first acc) [key] conj val) key)))) [{}, nil] coll)))", "user": "52efd3d9e4b05e3f0be25ed4"}, {"problem": 105, "code": "(fn keys-and-values[kv]\n  (letfn [(create-map [m v]\n          (let [currkey (:currkey m) currmap (:currmap m)]\t\n\t        (if (keyword? v)\n\t          {:currmap (merge-with #(-> concat vec) currmap {v []}) :currkey v} \n              {:currmap (update-in currmap [currkey] conj v) :currkey currkey})))]    \n\t(:currmap (reduce create-map {:currmap {} :currkey nil} kv))))", "user": "538e29d1e4b0b51d73faae80"}, {"problem": 105, "code": "#(let [a (atom 0)]\n  (reduce (fn [m n]\n            (if (keyword? n)\n              (assoc m (reset! a n) [])\n              (update-in m [@a] into [n])))\n          {} %))", "user": "53973e7be4b0b51d73faaee6"}, {"problem": 105, "code": "(fn [col]\n  (loop [m {}, k nil, c col]\n    (if (empty? c)\n      m\n      (let [e (first c)]\n        (if (number? e)\n          (recur (into m {k (conj (m k) e)}) k (rest c))\n          (recur (into m {e []}) e (rest c))\n        )\n      )\n    )\n  )\n)", "user": "53ca41dae4b00fb29b2212c8"}, {"problem": 105, "code": "#(second (reduce (fn [[ck m] i] (if (keyword? i) [i (assoc m i [])] [ck (merge-with conj m {ck i})])) [nil {}] %))", "user": "53e19461e4b0d874e779ae59"}, {"problem": 105, "code": "(fn to-map [coll]\n  (let [to-map-iter (fn [[fst & rst :as coll] res]\n                      (if (empty? coll)\n                        res\n                        (recur (drop-while (complement keyword?) rst) \n                               (assoc res \n                                      fst \n                                      (take-while (complement keyword?) rst)))))]\n    (to-map-iter coll {})))", "user": "52d00832e4b07d0d72b273b4"}, {"problem": 105, "code": "(fn [coll]\n  (loop [coll coll, acc {}]\n    (if (empty? coll) acc  \n      (let [[x & coll] coll]\n        (recur (drop-while number? coll) (assoc acc x (take-while number? coll)))))))", "user": "5224a46ce4b01819a2de42e5"}, {"problem": 105, "code": "(fn [r fl c]\n  (if-let [f (first c)]\n    (if (keyword? f)\n      (recur (assoc r f []) f (rest c))\n      (recur (update-in r [fl] conj f) fl (rest c)))\n    r)) \n{} nil", "user": "53034738e4b0d8b024fd373e"}, {"problem": 105, "code": "(fn [xset]\n   (apply array-map (reduce #(if (number? %2)\n              (conj (vec (drop-last %1))  (conj (last %1) %2))\n                (conj %1 %2 [])) [] xset)))", "user": "53ca23e3e4b00fb29b2212c6"}, {"problem": 105, "code": "(fn [coll]\n  (first\n    (reduce\n      (fn [[m k] e]\n        (if (keyword? e)\n          [(assoc m e []) e]\n          [(update-in m [k] #(conj % e)) k]))\n      [{} nil]\n      coll)))", "user": "53d78b64e4b0e771c3025466"}, {"problem": 105, "code": "(fn vec-map [v]\n  (loop [curr-val (first v)\n         remains (rest v)\n         this-key nil\n         res {}]\n    (if (nil? curr-val)\n      res\n      (if (keyword? curr-val)\n        (recur (first remains) (rest remains) curr-val (assoc res curr-val []))\n        (recur (first remains) (rest remains) this-key (merge-with conj res {this-key curr-val}))))))", "user": "53791ab7e4b06839e8705e4d"}, {"problem": 105, "code": "(fn map-conv [coll]\n   (->> coll\n        (reduce (fn [a i]\n                  (if (keyword? i)\n                    (vector (assoc (first a) i []) i)\n                    (vector (update-in (first a) (vector (second a)) #(conj % i)) (second a))\n                    ))\n                [{} 0])\n        first))", "user": "535eaa73e4b04ce2eb3ed2d4"}, {"problem": 105, "code": "(fn [xs]\n    (loop [acc {} xs xs]\n      (if (seq xs)\n        (recur (assoc acc (first xs) (take-while (complement keyword?) (next xs)))\n               (drop-while (complement keyword?) (next xs)))\n        acc)))", "user": "513e8141e4b02b2a3d8235c1"}, {"problem": 105, "code": "(fn [x]\n   (into {}\n   (filter (fn [[k v]] (keyword? k)) \n         (into {} (map-indexed (fn [i n]\n                  {n (take-while (complement keyword?) (drop (inc i) x))}) x)))))", "user": "53f6d555e4b0db01ade6f9e5"}, {"problem": 105, "code": "(fn x[[a & b]]\n  (let [[c d] (split-with number? b)]\n  (if a\n   (into { a (vec c) } (x d))\n   {})\n  ))", "user": "53ed2fafe4b0d648e757f4c1"}, {"problem": 105, "code": "(fn [coll] (let [\n  c (drop-while #(not (keyword? %)) coll)\n  f (fn [k v coll m] (if (empty? coll) (conj m {k v})\n                        (if (keyword? (first coll)) \n\t\t\t\t\t\t  (recur (first coll) [] (rest coll) (conj m {k v}))\n\t\t\t\t\t\t  (recur k (conj v (first coll)) (rest coll) m))))\n\n]  (if (empty? c) {} (f (first c) [] (rest c) {}))))", "user": "53fe1c3be4b0de5c418485f2"}, {"problem": 105, "code": "(fn [x] (apply hash-map (reduce #(if (keyword? %2) (concat %1 (list %2) (list [])) (if (keyword? (last %1))(concat %1 (list (vector %2)))(concat (butlast %1) (list (concat (last %1) (vector %2))))) ) '() x)))", "user": "53fc8424e4b0de5c418485b3"}, {"problem": 105, "code": "(fn [[& args]] (loop [args args coll {}]\n                  (if-let [k (first args)]\n                    (let [vs (take-while integer? (rest args))\n                          new-args (drop-while (comp not keyword?) (rest args))]\n                      (if k\n                        (recur new-args (assoc coll k vs))\n                        coll))\n                    coll)))", "user": "53da8fede4b0e771c30254a3"}, {"problem": 105, "code": "(fn [coll]\n   (let [inds (->> (map-indexed #(vector %1 %2) coll)\n                   (filter #(= clojure.lang.Keyword (type (last %))))\n                   (map first)\n                   (vec)\n                   (#(conj % (count coll))))\n         limits (partition 2 1 inds)]\n     (->> limits\n          (map (fn [[a b]] [(coll a) (subvec coll (inc a) b)]))\n          (into {}))))", "user": "53ed6976e4b0d648e757f4c4"}, {"problem": 105, "code": "(fn ! [l]\n  (let [ks (filter keyword? l)\n        kloc (map key (filter #(keyword? (second %)) (into {} (map-indexed vector l))))\n        vlen (map dec (map - (conj (vec (drop 1 kloc)) (count l)) kloc))\n        mvals (map #(take %2 (drop (inc %1) l)) kloc vlen)]\n    (into {} (map vector ks mvals))))", "user": "52faec2ee4b047fd55837004"}, {"problem": 105, "code": "(fn g\n  ([xs] (g {} nil xs))\n  ([m k xs]\n   (let [f (first xs)]\n     (cond\n       (empty? xs) m\n       (keyword? f) (recur (assoc m f []) f (rest xs))\n       :else (recur (assoc m k (conj (k m) f)) k (rest xs))))))", "user": "506ba58be4b0eda3100c090b"}, {"problem": 105, "code": "(fn map-from-vec-v2 [coll]\n  (letfn [(kw-indices [coll res idx]\n            (if (empty? coll)\n              res\n              (if (keyword? (first coll))\n                (recur (rest coll) (conj res idx) (inc idx))\n                (recur (rest coll) res (inc idx)))))]\n    (->> (kw-indices coll [] 0)\n         (partition-all 2 1)\n         (map #(apply subvec coll %))\n         (mapcat #(vector (first %) (rest %)))\n         (apply hash-map))))", "user": "53fd66a4e4b0de5c418485e3"}, {"problem": 105, "code": "(fn [input]\n  (loop [accu {}\n         key nil\n         tl input]\n    (if-not (seq tl)\n      accu\n      (let [my-first (first tl)]\n        (if (keyword? my-first)\n          (recur (conj accu [my-first []]) my-first (rest tl))\n          (recur (conj accu {key (conj (accu key) my-first)}) key (rest tl)))))))", "user": "540d7dd1e4b0addc1aec6713"}, {"problem": 105, "code": "(fn [col]\n  (loop [col col \n         res {} \n         ckey nil \n         curr []]\n    (let [ff (first col)]\n      (if (nil? ff) \n        (if (nil? ckey) res (assoc res ckey curr))  \n        (if (keyword? ff) \n          (if (nil? ckey)\n            (recur (rest col) res ff [])  \n            (recur (rest col) (assoc res ckey curr) ff []))\n          (recur (rest col) res ckey (conj curr ff)))))))", "user": "50856bd1e4b004985b776e4c"}, {"problem": 105, "code": "(fn [coll]\n  (loop [dict {}\n         k nil\n         [x & xs :as coll] coll]\n    (cond (empty? coll) dict\n          (keyword? x) (recur (assoc dict x []) x xs)\n          :else (recur (update-in dict [k] #(conj % x)) k xs))))", "user": "51780bfce4b0f89a8f53839c"}, {"problem": 105, "code": "(fn [s] \n  (let [[r-acc r-k r-v] (reduce (fn [[acc k v] i]\n            (cond\n             (nil? k) [acc i []]\n             (every? keyword? [k i]) [(conj acc k v) i []]\n             :else [acc k (conj v i)]))\n          [[] nil []] s)]\n    (if (nil? r-k) \n      (apply array-map r-acc) \n      (apply array-map (conj r-acc r-k r-v)))))", "user": "53c649d3e4b00fb29b221297"}, {"problem": 105, "code": "#(loop [[h & t] %\n        kw nil\n        vs []\n        res {}]\n   (let [nr (if kw (conj res [kw vs]) res)]\n     (cond\n      (nil? h) nr\n      (keyword? h) (recur t h [] nr)\n      :else (recur t kw (conj vs h) res))))", "user": "53f7820be4b0de5c41848560"}, {"problem": 105, "code": "(fn [xs]\n  (first\n   (reduce\n    (fn [[m kw] x]\n      (if (keyword? x)\n        [(assoc m x []) x]\n        [(update-in m [kw] conj x) kw]))\n   [{} nil] xs)))", "user": "504e108ce4b078edc5f593b3"}, {"problem": 105, "code": "(fn to-map\n  [coll]\n  (loop [mapping {} cursor nil coll coll]\n    (cond\n      (empty? coll) mapping\n      (keyword? (first coll))\n      (let [cursor (first coll)]\n        (recur (->> {cursor []}\n                    (into mapping))\n               cursor\n               (rest coll)))\n\n      :else\n      (recur (->> (first coll)\n                  (conj (mapping cursor))\n                  (assoc mapping cursor))\n             cursor\n             (rest coll)))))", "user": "5401aefbe4b0df28a13c62c7"}, {"problem": 105, "code": "(fn foo [s]\n  (dissoc ((fn bar [rest-seq last-kw last-vals ret] \n    (if (empty? rest-seq)\n      (merge ret (hash-map last-kw last-vals))\n      (if (keyword? (first rest-seq))\n        (bar (rest rest-seq) (first rest-seq) [] (merge ret (hash-map last-kw last-vals)))\n        (bar (rest rest-seq) last-kw (conj last-vals (first rest-seq)) ret)))) s nil [] {}) nil))", "user": "53a94b63e4b047364c044434"}, {"problem": 105, "code": "(fn [v]\n  (loop [k nil\n         v v\n         m {}]\n    (cond\n      (empty? v) m\n      (keyword? (first v)) (recur (first v) (rest v) (assoc m (first v) []))\n      :else (recur k (rest v) (assoc m k (conj (m k) (first v))))\n    )\n  )\n)", "user": "540f09b9e4b0addc1aec6725"}, {"problem": 105, "code": "#(first (reduce (fn [[acc k] x] \n          (if (= (type x) clojure.lang.Keyword) \n          (vector (assoc acc x []) x) \n          (vector (assoc acc k (conj (acc k) x)) k) ))\n        [{} -1]\n %))", "user": "53fcdd1ae4b0de5c418485dd"}, {"problem": 105, "code": "(fn [a]\n   (loop [k (first a), r (rest a), result {}]\n     (cond (nil? k) result\n           :else (let [rst (drop-while (comp not keyword?) r)]\n                   (recur (first rst) (drop 1 rst) (into result {k (take-while (comp not keyword?) r)}))))))", "user": "52fac708e4b047fd55836fff"}, {"problem": 105, "code": "#(let [x (mapcat (fn [coll] \n         (if (keyword? (first coll))\n           (interpose [] (partition-all 1 coll))\n           (list coll)))\n               (partition-by class %))]\n  (zipmap (map (fn [[x]] x) (take-nth 2 x)) (map vec (take-nth 2 (rest x)))))", "user": "541096bde4b01498b1a719b2"}, {"problem": 105, "code": "#(let [b (partition-by type %)\n       c (partition 2 b)\n       constroi (fn constroi [k v]\n                 (if (> (count k) 1)\n                   (merge {(first k) []} (constroi (rest k) v))\n                   {(first k) (vec v)}))]\n  (into {} (map (fn [[k v]] (constroi k v)) c)))", "user": "4ff4bed0e4b0678c553fc35f"}, {"problem": 105, "code": "(fn [c]\n  (loop [r c\n         f {}]\n    (if (empty? r)\n      f\n      (let [k (first r)\n            [v n] (split-with number? (rest r))\n            m (conj f [k v])]\n        (recur n m)))))", "user": "53fb5256e4b0de5c4184857f"}, {"problem": 105, "code": "#(loop[r {} k nil v %]\n   (let[e (first v)]\n     (cond\n      (not (seq v)) r\n      (keyword? e) (if(contains? r e) (recur r e (rest v))\n                     (recur (assoc r e []) e (rest v)))\n      :else (recur (assoc r k (conj (r k) e)) k (rest v)))))", "user": "541619e8e4b01498b1a719f9"}, {"problem": 105, "code": "(fn f [coll]\n  (if (empty? coll)\n    {}\n    (assoc\n      (f (drop-while (complement keyword?) (rest coll)))\n      (first coll)\n      (take-while (complement keyword?) (or (rest coll) [])))))", "user": "540d5085e4b0addc1aec670e"}, {"problem": 105, "code": "(fn [r]\n  (loop [acc {} r r]\n    (if (empty? r) acc\n                   (let [[v rs] (split-with number? (rest r))]\n        (recur (assoc acc (first r) (vec v)) rs)))))", "user": "5310e968e4b08068f379ecdd"}, {"problem": 105, "code": "(fn [s] (first (reduce\n                     (fn [[m k] x]\n                       (if (keyword? x)\n                         [(assoc m x []) x]\n                         [(assoc m k (conj (k m) x)) k]))\n                     [{} nil] s)))", "user": "51e28063e4b08e53a149f0f2"}, {"problem": 105, "code": "(fn [xs]\n\t\t(loop [xs xs current-keyword nil acc {}]\n\t\t\t(cond\n\t\t\t\t(empty? xs) acc\n\t\t\t\t(keyword? (first xs)) (recur (rest xs) (first xs) (assoc acc (first xs) []))\n\t\t\t\t:else (recur (rest xs) current-keyword (assoc acc current-keyword (conj (current-keyword acc) (first xs))))\n\t\t\t)\n\t\t)\n\t)", "user": "5409f8eae4b0addc1aec66e6"}, {"problem": 105, "code": "#(apply hash-map\n   (apply concat\n     (map\n       (fn [[a :as c]]\n         (if (keyword? a) (interpose [] c) [c]))\n       (partition-by keyword? %))))", "user": "53500869e4b084c2834f4ad3"}, {"problem": 105, "code": "(fn [[x & more] & m]\n  (let [m (or m {})](if x\n    (if (keyword? (first more))\n      (recur more (into m {x []}))\n      (recur (drop-while number? more) (into m {x (vec (take-while number? more))})))\n    m)))", "user": "54246fcce4b01498b1a71aed"}, {"problem": 105, "code": "(fn [coll]\n  (loop [acc {}\n         xs coll]\n    (if (empty? xs)\n      acc\n      (let [k (first xs)\n            [nums more] (split-with (complement keyword?) (rest xs))]\n        (recur (assoc acc k nums) more)))))", "user": "5368fedee4b0243289761e93"}, {"problem": 105, "code": "(fn myseq [al] \n(loop [l al res {} prevk nil] \n  (if (empty? l) res \n       (if (keyword? (first l)) \n       (recur (rest l) (assoc res (first l) []) (first l)) \n       (recur (rest l) (assoc res prevk (conj (get res prevk) (first l))) prevk)))))", "user": "52747090e4b03e8d9a4a74a5"}, {"problem": 105, "code": "#((reduce (fn [[k j] x] (if (keyword? x) [(assoc k x j) ()] [k (conj j x)])) [{} ()] (reverse %)) 0)", "user": "53a01fb1e4b0ca733b9744a6"}, {"problem": 105, "code": "(fn [coll]\n  (loop [k nil c coll out {}]\n    (if (empty? c)\n      out\n      (if (= (type (first c)) clojure.lang.Keyword)\n        (recur (first c) (rest c) (assoc out (first c) []))\n        (recur k (rest c) (merge-with conj out {k (first c)}))\n      ))))", "user": "53e76bb2e4b036ad0777e47d"}, {"problem": 105, "code": "(fn [col]\n  (letfn [(splitidkeys [xs]\n            (cond (keyword? (first xs))\n              (cons (vector (first xs) (take-while number? (rest xs))) (splitidkeys (rest xs)))\n              (number? (first xs)) (splitidkeys (rest xs))\n              :else nil))]\n    (reduce (fn [a [b c]] (assoc a b c)) {} (splitidkeys col))))", "user": "53e9a15be4b036ad0777e4ae"}, {"problem": 105, "code": "(fn [s]\n  (let\n      [dumb (gensym)\n       [k vs dict]\n       (reduce\n        (fn [[k vs dict] e]\n          (if (keyword? e)\n            [e [] (assoc dict k vs)]\n            [k (conj vs e) dict]))\n        [dumb [] {}]\n        s)\n       ]\n    (dissoc (assoc dict k vs) dumb)\n    )\n  )", "user": "53ef7f77e4b0742d9025b0ce"}, {"problem": 105, "code": "(fn identify-keys-and-values [col]\n  (loop [c col k nil v [] result {}]\n    (cond\n      (empty? c) (dissoc (conj result {k v}) nil)\n      (number? (first c))\n        (recur (rest c) k (conj v (first c)) result)\n      (keyword? (first col))\n        (recur (rest c) (first c) [] (conj result {k v})))))", "user": "528bba38e4b0239c8a67aea9"}, {"problem": 105, "code": "(fn knw\n\t[seq1]\n    (reduce (fn [map1 elem]\n        (if (keyword? elem)\n        \t(merge map1 {elem []})\n            (update-in map1 [(first (keys map1))] #(conj % elem))\n        \t))\n     {}\n     seq1\n    \t))", "user": "53d6b266e4b0e771c3025459"}, {"problem": 105, "code": "(comp\n          (partial reduce (fn [m [k v]]\n                            (reduce #(assoc %1 %2 [])\n                                    (assoc m (last k) (vec v))\n                                    (butlast k)))\n                   {})\n          (partial partition 2)\n          (partial partition-by keyword?))", "user": "53f592b7e4b0db01ade6f9d0"}, {"problem": 105, "code": "(fn make-map [ls] \n  (if (empty? ls) {}\n       (let [xs  (cons (first ls) (take-while (complement keyword?) (rest ls)))\n             k (first xs)\n             v (vec (rest xs))\n             ys (drop-while (complement keyword?) (rest ls))]\n         (merge (assoc {} k v) (make-map ys)))))", "user": "52ee0de4e4b05e3f0be25ec1"}, {"problem": 105, "code": "(fn key-val [xs]\n  (loop [acc {} rs xs]\n    (if (seq rs)\n      (recur \n       (assoc acc (first rs) (take-while (comp not keyword?) (rest rs)))\n       (drop-while (comp not keyword?) (rest rs)))\n\t  acc)))", "user": "54448e84e4b032a45b869393"}, {"problem": 105, "code": "(fn[x](into{}(map(fn[[k & v]][k(vec v)])(let[a(atom nil)](partition-by #(if(keyword? %)(do(reset! a %)%)@a)x)))))", "user": "4db2903f535df7e46ed9b6bf"}, {"problem": 105, "code": "(fn [coll]\n  (letfn [(not-keyword [x]\n                       (not= clojure.lang.Keyword (type x)))]\n    (loop [[k & rest] coll\n           keys []\n           vals []]\n      (if (seq rest)\n        (recur (drop-while not-keyword rest)\n               (conj keys k)\n               (conj vals (apply vector(take-while not-keyword rest))))\n        (zipmap keys vals)))))", "user": "54055aa9e4b0addc1aec6665"}, {"problem": 105, "code": "#(loop [the-list      %\n                  the-keyword nil\n                  the-result   {}\n                  the-cursor    0]\n              (if (= the-cursor (count the-list))\n                  the-result\n                  (if (keyword? (nth the-list the-cursor))\n                    (recur the-list\n                           (nth the-list the-cursor)\n                           (assoc the-result (nth the-list the-cursor) [])\n                           (inc the-cursor))\n                    (recur the-list\n                           the-keyword\n                           (assoc the-result the-keyword (conj (the-result the-keyword) (nth the-list the-cursor)))\n                           (inc the-cursor)))))", "user": "544e8369e4b0e39780006987"}, {"problem": 105, "code": "(fn [collection]\n    (loop [rest-of-collection collection\n           result {}\n           last-key nil]\n      (if (empty? rest-of-collection)\n        result\n        (let [item (first rest-of-collection)\n              is-new-keyword? (keyword? item)]\n          (if is-new-keyword?\n            (recur (rest rest-of-collection) (assoc result item []) item)\n            (recur (rest rest-of-collection) (assoc result last-key (conj (get result last-key) item)) last-key))))\n      ))", "user": "53f891eee4b0de5c4184856d"}, {"problem": 105, "code": "#(second (reduce (fn [[last m] v]\n                  (if (keyword? v) \n                   [v (assoc m v [])]\n                   [last (update-in m [last] conj v)])) [nil {}] %))", "user": "4db92654535d1e037afb21a0"}, {"problem": 105, "code": "(fn __ [col] \n  ((fn v2m [mp [h & t]]\n     (if (nil? h)\n       {}\n       (let [x (split-with number? t)\n             mp (assoc mp h (first x))]\n        (if (empty? (second x))\n          mp\n          (v2m mp (second x)))))) {} col))", "user": "53f3a4ace4b0742d9025b0f7"}, {"problem": 105, "code": "(fn qq [coll] \n  (apply hash-map \n         (mapv \n          (fn [i] (if (nil? (first i)) [] (if (keyword? (first i)) (first i) (vec i))))\n          (partition-by keyword? ((fn [coll](loop [r [] c coll kw false]\n(if (empty? c)\nr\n(if (keyword? (first c))\n(if kw\n(recur (conj (conj r nil) (first c)) (rest c) true)\n(recur (conj r (first c)) (rest c) true))\n(recur (conj r (first c)) (rest c) false))))) coll)))))", "user": "504457c0e4b01f6c9a8b2360"}, {"problem": 105, "code": "(fn [s]\n  (let [k (atom nil)]\n    (reduce\n     (fn [m e]\n       (if (keyword? e)\n         (do\n           (reset! k e)\n           (assoc m e []))\n         (update-in m [@k] conj e)))\n     {}\n     s)))", "user": "4f3e5e87e4b0e243712b1f83"}, {"problem": 105, "code": "#(apply hash-map (reduce (fn [acc x] \n                            (if (keyword? x)\n                              (-> \n                                (conj acc x )\n                                (conj [] ))\n                              (-> \n                                (pop acc)\n                                (conj (conj (last acc) x))))\n                            ) [] %))", "user": "54529d7ee4b0e397800069c6"}, {"problem": 105, "code": "(fn [s]\n  (loop [s s\n         m {}]\n    (if (empty? s)\n      m\n      (let [k (first s)\n            [vs s] (split-with (complement keyword?) (rest s))]\n        (recur s (assoc m k (vec vs)))))))", "user": "4ec1b090535dfed6da9c6db5"}, {"problem": 105, "code": "(fn [coll]\n  (loop [coll coll\n         prev-key nil\n         res {}]\n    (let [current (first coll)]\n      (cond\n       (empty? coll) res\n       (keyword? current) (recur (rest coll)\n                                 current\n                                 (assoc res current []))\n       :else (recur (rest coll)\n                    prev-key\n                    (assoc res prev-key (conj (prev-key res) current)))))))", "user": "53322cece4b019098a6f8b73"}, {"problem": 105, "code": "(fn mf [s]\n  (if (seq s)\n    (merge {(first s) (take-while number? (rest s))} (mf (drop-while number? (rest s))))\n    {}))", "user": "53ce4cd4e4b00fb29b2212ef"}, {"problem": 105, "code": "(fn this [s]\n  (if (seq s)\n      (let [[ns r] (split-with number? (rest s))]\n        (into {(first s) ns} (this r)))\n      {}))", "user": "5078d366e4b08327cd804a5b"}, {"problem": 105, "code": "(fn [coll]\n  (loop [acc     {}\n         last-kw nil\n         left    coll]\n    (if (empty? left)\n      acc\n      (let [x (first left)]\n        (if (keyword? x)\n          (recur (assoc acc x []) x (rest left))\n          (recur (update-in acc [last-kw] conj x) last-kw (rest left)))))))", "user": "505aa653e4b021387fb89857"}, {"problem": 105, "code": "(fn [s]\n(apply hash-map (loop [x s, y []] \n  (cond \n    (empty? x) y\n    (keyword? (first x)) (recur (rest x) (apply conj y (first x) [[]]))\n    (number? (first x)) (recur (rest x) (conj (vec (drop-last y)) (conj (last y) (first x))))\n    :else (recur (rest x) (conj y (first x)))\n)))\n)", "user": "54524afbe4b0e397800069bc"}, {"problem": 105, "code": "(fn [coll]\n  (let [partitioned (partition-by keyword coll)\n        joined (apply hash-map (mapcat #(if(and (keyword? (first %)) (keyword? (first %2))) (conj [] (first %) []) (conj [] (first %) (vec %2))) partitioned (rest partitioned)))\n        filtered (filter #(keyword? (key %)) joined)]\n   (into {} filtered)))", "user": "538d70abe4b0b51d73faae6e"}, {"problem": 105, "code": "#(into {} (reduce (fn [a b] \n           (if (keyword? b)\n                     (conj a [b []])\n             (let [[f s] (last a)] \n               (conj (vec (butlast a)) [f (conj s b)] ))))         \n         [] %))", "user": "544e9022e4b0e3978000698b"}, {"problem": 105, "code": "(fn f\n    ([c]\n      (if (empty? c) {} (f c {})))\n    ([[x & r] m] (if (keyword? x)\n                   (let [[vs new-r] (split-with number? r)]\n                     (assoc (f new-r m) x vs)))))", "user": "538ca203e4b0b51d73faae5f"}, {"problem": 105, "code": "(fn foo \n  ([coll]\n   (foo {} (first coll) (rest coll)))\n  ([m k [v & coll]]\n   (if-not (nil? v)\n     (if (keyword? v)\n       (foo (assoc m v []) v coll)\n       (foo (assoc m k (concat (get m k) [v])) k coll))\n     m)))\n\n\n;;#(->> (partition-by keyword? %)\n;;  (mapcat\n;;    (fn [[k :as x]]\n;;      (if (keyword? k) (interpose [] x) [x])))\n;;  (apply array-map))", "user": "544cf5d7e4b0e39780006977"}, {"problem": 105, "code": "#(apply hash-map\n              ((fn a [[h & t]]\n                  (when (keyword? h)\n                    (let [numbers (take-while number? t)]\n                      (concat\n                       (cons h [numbers])\n                       (a (drop (count numbers) t)))))\n                  ) %))", "user": "502873a8e4b01614d1633ff8"}, {"problem": 105, "code": "#((reduce (fn [[a b] x] (if (keyword? x) [(assoc a x b) ()] [a (conj b x)])) [{} ()] (reverse %)) 0)", "user": "543d5c61e4b032a45b86934d"}, {"problem": 105, "code": "(fn [coll]\n  (if (empty? coll) {}\n  (loop [accmap {(first coll) []}\n         currentkey (first coll)\n         remain (rest coll)]\n       (if (empty? remain)\n           accmap\n           (if (keyword? (first remain))\n             (recur (assoc accmap (first remain) []) (first remain) (rest remain))\n             (recur (assoc accmap currentkey (conj (get accmap currentkey) (first remain))) currentkey (rest remain)))))))", "user": "5478c4fee4b0c51c1f4d72c0"}, {"problem": 105, "code": "(fn [l]\n  (loop [i l m {}]\n    (if (seq i)\n      (recur (drop-while number? (next i)) \n             (assoc m (first i) (vec (take-while number? (next i)))))\n     m)))", "user": "5405ae2be4b0addc1aec6671"}, {"problem": 105, "code": "(fn [c]\n   (loop [m {} r c]\n     (if\n       (first r)\n       (recur\n           (assoc m (first r) (take-while (complement keyword?) (rest r)))\n            (drop-while (complement keyword?) (rest r)))\n       m    \n   )))", "user": "5412646de4b01498b1a719d4"}, {"problem": 105, "code": "(fn [c] (into {} (mapv vec (partition 2 (reduce\n                                         (fn [acc i]\n                                           (if (keyword? i)\n                                             (if (keyword? (last acc))\n                                               (conj (conj acc []) i)\n                                               (conj acc i))\n                                             (let [li (dec (count acc))\n                                                   le (acc li)]\n                                               (if (keyword? le)\n                                                 (conj acc [i])\n                                                 (assoc acc li (conj le i))))))\n                                         []\n                                         c)))))", "user": "547d8e93e4b0c51c1f4d72f4"}, {"problem": 105, "code": "(fn [coll]\n(let [partitioned (partition-by keyword? coll)\n      keys (map last (take-nth 2 partitioned))\n      values (take-nth 2 (rest partitioned))\n      empty-keys (remove nil? (flatten (map butlast (take-nth 2 partitioned))))]\n  (merge (zipmap keys values) (apply hash-map (interleave empty-keys (repeat []))))))", "user": "5353afa0e4b084c2834f4b03"}, {"problem": 105, "code": "(fn [coll]\n  (loop [ret {} l coll]\n    (if (seq l)\n      (recur (assoc ret (first l) (take-while (comp not keyword?) (rest l))) (drop-while (comp not keyword?) (rest l)))\n      ret)))", "user": "53d86564e4b0e771c302546b"}, {"problem": 105, "code": "(fn [s]\n  (reduce (fn [res [kwds vls]]\n          (let [kwds_no_vls (butlast kwds)\n                kwd_last (last kwds)]\n            (conj res [kwd_last vls] (when kwds_no_vls (zipmap kwds_no_vls (repeat []))))))\n          {}\n          (partition 2 (partition-by keyword? s))))", "user": "53e745a1e4b036ad0777e479"}, {"problem": 105, "code": "(fn identify-keys-and-values [[x & xs]]\n  (if x\n      (assoc\n        (identify-keys-and-values (drop-while number? xs))\n        x\n        (take-while number? xs))\n      {}))", "user": "52616198e4b03e8d9a4a705e"}, {"problem": 105, "code": "(fn [input-seq]\n  (into {} (reduce (fn [result item]\n                     (if (keyword? item)\n                       (conj result [item []])\n                       (let [entry (peek result)]\n                         (conj (pop result) (update-in entry [1] conj item)))))\n                   []\n                   input-seq)))", "user": "5424c523e4b01498b1a71b03"}, {"problem": 105, "code": "(fn [s]\n  (apply merge {} (flatten (for [[ks vs] (partition 2 (partition-by keyword? s))]\n    (conj [{(last ks) vs}] (for [k (butlast ks)] {k []}))))))", "user": "545e9cf1e4b01be26fd7467f"}, {"problem": 105, "code": "(fn [c] (apply hash-map  (mapcat #(if (every? keyword? %) (interpose () %) (vector  %))  (partition-by keyword? c))))", "user": "512b07f7e4b078b06821febb"}, {"problem": 105, "code": "(fn f [[k & v]]\n  (if v\n    (let [[a b] \t(split-with number? v)]\n      (assoc (f b) k a))\n    {}))", "user": "54848141e4b0e286459a119e"}, {"problem": 105, "code": "(fn [s]\n      (loop [x s, a[], r {}, last (first x)]\n            (let [c (first x), k (keyword? c)]\n                 (if (empty? x) (if (nil? last) r (assoc r last a))\n                                (recur\n                                  (rest x)\n                                  (if (true? k) [] (conj a c))\n                                  (if (true? k) (assoc r last a) r)\n                                  (if (true? k) c last)\n                                  )\n                                )\n                 )\n            )\n      )", "user": "53bcdd41e4b0d9a98559a6c0"}, {"problem": 105, "code": "(fn [coll]\n  (->>\n   coll\n   (reduce #(if (keyword? %2) \n              (into % [%2 []])\n              (conj (pop %) (conj (peek %) %2)))\n           [])\n   (apply hash-map)))", "user": "5392bfdee4b0b51d73faaeb2"}, {"problem": 105, "code": "#(loop [c (partition-by integer? %) ret {}]\n  (if (empty? c)\n    ret\n    (let [klist (first c)\n          r (map (fn[k v](assoc {} k v)) (butlast klist) (repeat []))\n          vlist (vec (second c))\n         ]\n      (recur (nnext c) (assoc (into ret r) (last klist) vlist))\n    )\n  )\n)", "user": "545537c1e4b0e397800069dd"}, {"problem": 105, "code": "(fn [l]\n\t(let [c (partition 2 (partition-by keyword? l))]\n\t\t(reduce (fn [a [k v]]\n\t\t\t(assoc (reduce #(assoc % %2 []) a k)\n\t\t\t\t(last k) v)) {} c)))", "user": "536e5b68e4b0fc7073fd6e6d"}, {"problem": 105, "code": "(fn part-x\n  [s]\n  (letfn [ (parts\n                 [coll]\n                 (map #(into [] %)(partition-by #(keyword %) coll)))\n         (p3\n             [s]\n             (loop [ coll s acc [] ]\n               (let [ [[x] y & xs :as all] coll ]\n                 (if (empty? all) acc\n                     (if (keyword (first  y))\n                       (recur (rest all) (conj acc x []))\n                       (recur xs (conj acc x y)))))))\n        ]\n    (into {}  (map #(into [] %) ( partition 2  (p3 (parts s)) ) ))) \n  )", "user": "51f81925e4b09be9c177e526"}, {"problem": 105, "code": "#(loop [kv %, m {}]\n   (if-let [[kw & kv] (seq kv)]\n     (let [[vs kv] (split-with number? kv)]\n       (recur kv (assoc m kw vs)))\n     m))", "user": "53dfdf01e4b0d874e779ae46"}, {"problem": 105, "code": "(partial (fn part-by-type [type-fn-? coll]\n  (letfn [(one-key-in-one-subcoll [coll]\n  (reduce (fn [ret item]\n            (if (and (type-fn-? (first item))\n                     (> (count item) 1))\n              (apply conj ret (map list (interpose nil item)))\n              (conj ret item)))\n          [] coll))]\n    (let [pairs (partition 2 (map (partial keep identity) (one-key-in-one-subcoll\n                                                          (partition-by type-fn-? coll))))]\n      (reduce (fn [ret pair]\n                (conj ret [(ffirst pair) (second pair)]))\n              {} pairs))))\n         keyword?)", "user": "53b7aa6ce4b047364c0444d1"}, {"problem": 105, "code": "(fn [s]\n  (apply array-map\n  (map #(if (keyword? (first %)) (first %)  (flatten %))\n    (partition-by keyword? (interleave s (repeat [])))\n  ))\n)", "user": "4fc8f671e4b0ee37620e1840"}, {"problem": 105, "code": "#(into {} (reduce (fn [a v]\n                    (vec (if (keyword? v)\n                           (conj a [v []])\n                           (conj (butlast a)\n                                 [(first (last a)) \n                                  (conj (second (last a)) v)]))))\n                  {}\n                  %))", "user": "5339c105e4b0e30313ee6cae"}, {"problem": 105, "code": "(fn [coll] \n  (loop [m {} c (partition 2 (partition-by type coll))]\n    (let [[ks vs] (first c)]\n      (if (empty? ks)\n        m\n        (recur (into (conj m {(last ks) vs}) (map #(hash-map % []) (butlast ks))) (rest c))))))", "user": "536b9d8ae4b0243289761ebe"}, {"problem": 105, "code": "(fn f\n  ([v] (first (reduce f [{} nil] v)))\n  ([[m k] x] (if (keyword? x) [(assoc m x []) x] [(assoc m k (conj (m k) x)) k])))", "user": "54bd04e7e4b0ed20f4ff6ed8"}, {"problem": 105, "code": "(fn identify_key_val [x]\n  (letfn [(f [[k & r] result]\n            (if k (let [[v t] (split-with (complement keyword?) r)]\n                    (f t (assoc result k (vec v))))\n              result))]\n    (f x {})))", "user": "54769c7ae4b0c51c1f4d72a8"}, {"problem": 105, "code": "(fn [coll]\n  (loop [fmap {}\n         curr-key (first coll)\n         curr-vals []\n         rcoll (rest coll)]\n    (let [item (first rcoll)]\n      (cond\n        (nil? curr-key) {} ;; Empty coll passed\n        (keyword? item) (recur (assoc fmap curr-key curr-vals)\n                               item\n                               []\n                               (rest rcoll))\n        (number? item)  (recur fmap\n                               curr-key\n                               (conj curr-vals item)\n                               (rest rcoll))\n        (nil? item) (assoc fmap curr-key curr-vals)))))", "user": "5405fdcce4b0addc1aec6683"}, {"problem": 105, "code": "(fn [in-seq]\n  (loop [acc {} s in-seq]\n    (if (or (nil? s) (empty? s))\n      acc\n      (let [kw (first s)\n            nums (vec (take-while number? (rest s)))\n            rem (drop (count nums) (rest s))]\n        (recur (assoc acc kw nums)\n               rem)))))", "user": "54be7772e4b0ed20f4ff6eea"}, {"problem": 105, "code": "(fn\n  [vect]\n  (loop [acc-map {}\n         rest-vect (rest vect)\n         k (first vect)\n         v []\n         i (first rest-vect)]\n    (cond\n      (nil? k) {}\n      (nil? i) (assoc acc-map k v)\n      (keyword? i) (recur (assoc acc-map k v)\n                          (rest rest-vect)\n                          i\n                          []\n                          (first (rest rest-vect)))\n      (number? i)  (recur acc-map\n                          (rest rest-vect)\n                          k\n                          (conj v i)\n                          (first (rest rest-vect)))\n      :else acc-map)))", "user": "50800e49e4b089ade05efbda"}, {"problem": 105, "code": "(fn [xs]\n  (apply hash-map\n         (mapcat (fn [[ks vs]]\n                   (into (vec (interpose [] ks)) [(vec vs)]))\n                 (partition 2 (partition-by keyword? xs)))))", "user": "54b13a40e4b09f271ff37d1b"}, {"problem": 105, "code": "(fn conv [s]\n  (reduce (fn [r [k v]]\n          (assoc (into r (zipmap k (repeat []))) (last k) v)) {}\n          (partition 2 (partition-by keyword? s))))", "user": "52a5a8ebe4b0c58976d9abed"}, {"problem": 105, "code": "(fn p105 [s]\n  (if (empty? s) {}\n    (letfn [(f [m k r]\n             (if (empty? r) (assoc m k (concat [] (get m k)))\n               (let [x (first r)]\n                 (if (keyword? x)\n                   (f (assoc m x []) x (rest r))\n                  (f (assoc m k (into [] (conj (get m k) x))) k (rest r))))))]\n    (f {} (first s) (rest s)))))", "user": "54c271b9e4b045293a27f602"}, {"problem": 105, "code": "(fn [xs]\n  (loop [r {}\n         [k & s] xs]\n    (if k\n      (let [[a b] (split-with number? s)]\n        (recur (assoc r k a) b))\n      r)))", "user": "54acf5c7e4b09f271ff37cdd"}, {"problem": 105, "code": "(fn mapify [c]\n  (loop [coll c \n         res {}]\n    (if (empty? coll) res\n      (recur \n       (drop-while number? (rest coll)) \n       (conj res [(first coll) (take-while number? (rest coll))])))))", "user": "54bd3aefe4b0ed20f4ff6edb"}, {"problem": 105, "code": "(fn [col]\n  (->> col\n       (partition-by type)\n      (partition 2) \n       (mapcat (fn [ [col v] ]\n                 (cons [(last col) v] \n                     (map (fn [k] [k []]) (butlast col)))) )\n      (into {})))", "user": "54af6fb0e4b09f271ff37d08"}, {"problem": 105, "code": "(fn [v]\n    (loop [v v m {} k nil]\n      (if (seq v)\n        (if (keyword? (first v))\n          (recur (rest v) (assoc m (first v) []) (first v))\n          (recur (rest v) (assoc m k (conj (m k) (first v))) k)\n          )\n        m\n        )\n      )\n    )", "user": "54b90836e4b0ed20f4ff6e9d"}, {"problem": 105, "code": "(letfn [(partition-when [f coll]\n          (lazy-seq\n           (when-let [[fst & s] (seq coll)]\n             (let [run (cons fst (take-while (complement f) s))]\n               (cons run (partition-when f (drop (count run) coll)))))))]\n  (fn [coll]\n    (into {} (map (fn [[k & vs]] [k (vec vs)]) (partition-when keyword? coll)))))\n\n;  (letfn [(step [[m k vs] x]\n;            (if (keyword? x)\n;              [(assoc m k vs) x []]\n;              [m k (conj vs x)]))]\n;    (fn group-by-keywords [coll]\n;      (if-let [[x & xs] (seq coll)]\n;        (apply assoc (reduce step [{} x []] xs))\n;        {})))\n;\n;(fn [s]\n;  (loop [m {} i s k nil]\n;    (if-let [x (first i)]\n;      (if (keyword? x)\n;        (recur (assoc m x []) (rest i) x)\n;        (recur (update-in m [k] conj x) (rest i) k))\n;      m)))", "user": "54ca9ca8e4b057c6fda3a265"}, {"problem": 105, "code": "(fn mapify [sq]\n  (loop [s sq, current-keyword (first sq), mp {}]\n    (if (empty? s) mp\n      (let [h  (first s)\n            kw (if (keyword? h) h current-keyword)\n            v3c (get mp kw [])]\n        (recur (rest s) kw (assoc mp kw (if (keyword? h) [] (conj v3c h)))\n)))))", "user": "54bbe505e4b0ed20f4ff6ec5"}, {"problem": 105, "code": "(fn [v]\n  (loop [[f :as xs] v, k nil, acc {}]\n    (cond\n     (empty? xs)  acc\n     (keyword? f) (recur (rest xs) f (assoc acc f []))\n     :else        (recur (rest xs) k (assoc acc k (conj (acc k) f))))))", "user": "541b1f25e4b01498b1a71a63"}, {"problem": 105, "code": "#(->> %\n        reverse\n        (reduce (fn [[vs rs] v]\n                  (if (keyword? v)\n                    [[] (conj rs [v vs])]\n                    [(conj vs v) rs]))\n                [[] {}])\n        last\n        (map (fn [[k v]] [k (vec (reverse v))]))\n        (into {}))", "user": "54c641f8e4b045293a27f628"}, {"problem": 105, "code": "(fn [coll]\n  (loop [coll coll m {}]\n   (if (empty? coll) m\n     (let [[k & xs] coll\n           [ns ys] (split-with number? xs)]\n       (recur ys (assoc m k ns))))))", "user": "549c1713e4b0f3d1d8e70f82"}, {"problem": 105, "code": "#(loop [x %\n        result {}\n        prev-k nil]\n  (if (empty? x)\n    result\n    (let [f (first x)]\n      (recur (rest x)\n             (merge-with concat result (if (keyword? f)\n                                         {f []}\n                                         {prev-k [f]}))\n             (if (keyword? f)\n               f\n               prev-k)))))", "user": "50f10f7be4b06d9538fe211a"}, {"problem": 105, "code": "(fn f [[k & xs :as args]]\n  (if (seq args)\n    (let [[nums r] (split-with number? xs)]\n      (merge {k nums} (f r)))\n    {}))", "user": "508923d5e4b06d8254e936e8"}, {"problem": 105, "code": "(fn gnaaah [xs]\n  (loop [xs xs last nil result {}]\n    (if (empty? xs)\n      result\n      (let [ current (first xs) ]\n        (if (keyword? current)\n          (recur (rest xs) current (assoc result current []) )\n          (recur (rest xs) last (update-in result [last] conj current) ))))))", "user": "54d6f22de4b0a52adc2e2023"}, {"problem": 105, "code": "(fn [xs]\n  (loop [out {} [h & r] xs]\n    (if (seq r)\n      (recur (into out {h (take-while number? r)}) (drop-while number? r))\n      out)))", "user": "4ee75ec2535d93acb0a66867"}, {"problem": 105, "code": "(fn [coll]\n    (loop [m {} xs coll]\n      (if (empty? xs) m\n          (let [kw (first xs) [vs rst] (split-with (complement keyword?) (rest xs))]\n            (println kw vs)\n            (recur (merge m (hash-map kw (vec vs))) rst)))))", "user": "52950ab6e4b02ebb4ef7501a"}, {"problem": 105, "code": "(fn p [col]\n (let [k (first col)\n       val-s (rest col)]\n   (if (not (keyword? k))\n     {}\n     (apply merge {k (vec (take-while #(not (keyword? %)) val-s))}\n                  (p (vec (drop-while #(not (keyword? %)) val-s)))))))", "user": "53664e3be4b0243289761e74"}, {"problem": 105, "code": "(fn to-key-val [xs]\n  (loop [[k & vs] xs m {}]\n    (if (empty? vs)\n      m\n      (recur\n        (drop-while (complement keyword?) vs)\n        (assoc m k (take-while (complement keyword?) vs))))))", "user": "5383668ee4b06839e8705edd"}, {"problem": 105, "code": "(fn [s]\r\n  (apply array-map (reduce \r\n    #(if (keyword? %2) (conj %1 %2 []) (conj (pop %1) (conj (peek %1) %2))) [] s)))", "user": "5470699ae4b00cfc9eacc1b6"}, {"problem": 105, "code": "(fn _ [[x & xs]]\n  (if-not (keyword? x)\n    {}\n    (assoc (_ (drop-while #(not (keyword? %)) xs))\n      x\n      (take-while #(not (keyword? %)) xs))))", "user": "5213d7aae4b0961f15ac4d72"}, {"problem": 105, "code": "#(loop [s %\n        m {}\n        k nil]\n   (if (seq s)\n     (let [v (first s)\n           s (rest s)]\n       (if (keyword? v)\n         (recur s (assoc m v []) v)\n         (recur s (assoc m k (conj (m k) v)) k)))\n     m))", "user": "54dd76c8e4b024c67c0cf794"}, {"problem": 105, "code": "(fn [v]\n  (dissoc \n    (reduce\n     #(if (keyword? %2)\n        (-> %\n            (assoc %2 [])\n            (assoc :sym %2))\n        (update-in % [(:sym %)] conj %2))\n     {:sym nil}\n     v)\n    :sym))", "user": "4dd6d7ee535d2dad7130b5cb"}, {"problem": 105, "code": "(fn prob105 [s]\n  (if (empty? s) {}\n      (conj (prob105 (drop-while number? (rest s)))\n            {(first s) (apply vector (take-while number? (rest s)))})))", "user": "54e3df6ae4b024c67c0cf7e3"}, {"problem": 105, "code": "(fn [kvs]\n\t(loop [[k & v] kvs map {}]\n\t\t(if (nil? k)\n\t\t\tmap\n\t\t\t(let [[values leftover] (split-with number? v)]\n\t\t\t\t(recur leftover (assoc map k values))))))", "user": "5472d919e4b094393f72dd7b"}, {"problem": 105, "code": "#(first (reduce (fn [[state lastkey] item]\n                     (if (keyword? item)\n                       [(assoc state item []) item]\n                       [(update-in state [lastkey] conj item) lastkey])) \n                   [{} nil] %))", "user": "52b02329e4b0c58976d9acc5"}, {"problem": 105, "code": "(fn [coll]\n  (loop [[k & rest-coll] coll\n         result {}]\n    (if (empty? rest-coll)\n      result\n      (recur (drop-while number? rest-coll)\n             (assoc result k (take-while number? rest-coll))))))", "user": "54cc26c1e4b057c6fda3a28a"}, {"problem": 105, "code": "(fn [coll]\n   (into {} (map (fn [[a b]] {a b})\n   (partition 2 2\n    (reduce (fn [sofar [a b]]\n         (if (keyword? a)\n          (if (keyword? b) \n           (conj sofar a []) \n           (conj sofar a)) \n          (if (keyword? (last sofar))  \n            (conj sofar [a]) \n            (assoc sofar (dec (count sofar)) (conj (last sofar) a))))) [] (partition 2 1 [1] coll))))))", "user": "54908cc1e4b0b312c081ff32"}, {"problem": 105, "code": "(fn identify-keys-and-values [acoll]\n  (-> (reduce\n   (fn [acc elem]\n     (if (keyword? elem)\n       [(into (first acc) (apply hash-map (second acc))) [elem []]]\n       [(first acc) [(first (second acc)) (conj (second (second acc)) elem)]]))\n   [{} []]\n   acoll)\n      (#(into (first %) (apply hash-map (second %))))))", "user": "540e8d13e4b0addc1aec671e"}, {"problem": 105, "code": "(fn [coll]\n  (reduce #(assoc %1 (first %2) (second %2)) {} (map (fn [this-key] \n                       (let [tail-items (rest (drop-while #(not= % this-key) coll))]\n                         (vector this-key (take-while #(not (keyword? %)) tail-items))\n                       )\n                     ) \n                     (filter keyword? coll)\n                ))\n)", "user": "546692aee4b01be26fd746e7"}, {"problem": 105, "code": "(fn buildit [a]\n  (if (empty? a)\n    {}\n    (let [h (first a)\n          parts (take-while #(not (keyword? %)) (rest a))\n          remaining (drop-while #(not (keyword? %)) (rest a))]\n      (assoc (buildit remaining) h (vec parts)))))", "user": "532b43c3e4b09d4e7a9b5531"}, {"problem": 105, "code": "(fn keymap [x]\n  (if (empty? x)\n    {}\n    (let [[k & xs] x\n          nums (take-while #(not (keyword? %)) xs)\n          after (drop-while #(not (keyword? %)) xs)]\n      (conj {k nums} (keymap after)))))", "user": "525cc912e4b0cb4875a45d48"}, {"problem": 105, "code": "(fn [coll]\n    (if (nil? (seq coll))\n      {}\n      (loop [current-keyword (first coll)\n             coll (rest coll)\n             current-map {current-keyword []}]\n        (cond (nil? (seq coll)) current-map\n              (keyword? (first coll)) (recur (first coll)\n                                             (rest coll)\n                                             (assoc current-map (first coll) []))\n              :else (recur current-keyword\n                           (rest coll)\n                           (assoc current-map\n                                  current-keyword\n                                  (conj (current-map current-keyword) (first coll))))))))", "user": "51b91b08e4b0e871ca4958f8"}, {"problem": 105, "code": "(fn [xs]\n  (let [f (fn [ys]\n              (if (= 0 (count ys))\n                (hash-map)\n                (hash-map (first ys)\n                          (vec (take-while (fn [_] (not= (class :0)\n                                                         (class _)))\n                                           (rest ys))))))]\n     (loop [ys xs z {}]\n       (if (= 0 (count ys))\n         z\n         (let [_ (f ys)]\n           (recur (drop (+ 1 (count (_ (first (keys _)))))\n                        ys)\n                  (into z _)))))))", "user": "54d753ebe4b0a52adc2e2029"}, {"problem": 105, "code": "(fn f\n   ([coll] (f coll {}))\n   ([coll acc]\n      (if-let [s (seq coll)]\n        (if (keyword? (first s))\n          (f (drop-while (complement keyword?) (rest s))\n             (assoc acc \n               \t\t(first s)\n               \t\t(vec (take-while (complement keyword?) (rest s))))))\n        acc)))", "user": "4dda44f2535d02782fcbe9f1"}, {"problem": 105, "code": "(fn [input]\n  (loop [xs input output {}]\n  (if (empty? xs)\n    output\n    (recur (drop-while (complement keyword?) (rest xs))\n           (assoc output (first xs)\n                         (take-while (complement keyword?) (rest xs)))))))", "user": "546a6c7ce4b00cfc9eacc154"}, {"problem": 105, "code": "(fn [a]\n  (loop [a a\n         r {}\n         k nil]\n    (cond\n     (= a []) r\n     (keyword? (first a)) (recur (rest a)\n                                 (merge r {(first a) []})\n                                 (first a))\n     :else (recur (rest a)\n                  (merge-with conj r {k (first a)})\n                  k))))", "user": "51ab70c3e4b04e3dc0c27b33"}, {"problem": 105, "code": "#(loop [m {} [k & r :as s] %] (if (seq s) (let [[v r] (split-with (complement keyword?) r)] (recur (assoc m k (vec v)) r)) m))", "user": "54f0d3fde4b024c67c0cf8a6"}, {"problem": 105, "code": "(fn kv [vc] \n  (let [spvc (partition-by keyword? vc)\n        syms (first spvc)\n        valv (vec (first (rest spvc)))\n        ct (count syms)\n        sym0 (first syms)\n        rsym (rest syms)\n        rvc1 (flatten (rest (rest spvc)))\n        rvc2 (flatten (conj (rest spvc) rsym))]\n    (cond\n      (zero? ct) {}\n      (= 1 ct) (assoc (kv rvc1) sym0 valv)\n      :else (assoc (kv rvc2) sym0 []))))", "user": "54d4bd2be4b0a52adc2e2005"}, {"problem": 105, "code": "(fn v2m [seq]\n  (let [v? (complement keyword?)]\n    (if (empty? seq) {}\n      (into { (first seq) (vec (take-while v? (rest seq))) }\n            (v2m (drop-while v? (rest seq)))))))", "user": "546ff835e4b00cfc9eacc1b4"}, {"problem": 105, "code": "(fn kv [acc k [v & vs]]\n  (cond (nil? v) acc\n        (keyword? v) (kv (assoc acc v []) v vs)\n        :e (kv (update-in acc [k] conj v) k vs))) {} *", "user": "539c736ce4b0b51d73faaf2b"}, {"problem": 105, "code": "(fn [els]                                                                                                                                                                                                                      \n  (:res                                                                                                                                                                                                                        \n   (reduce (fn [acc x]\n             (if (keyword? x)\n               (-> acc\n                   (conj [:last x])\n                   (assoc-in [:res x] []))\n               (update-in acc [:res (:last acc)] conj x)))\n        \t{:last nil :res {}}\n          \tels)))", "user": "541d3c0fe4b01498b1a71a7e"}, {"problem": 105, "code": "(fn [coll]\n  (letfn [(into-current-key [acc cur-key xs]\n            (if (empty? xs)\n              acc\n              (let [fst (first xs)\n                    rst (rest xs)]\n                (if (keyword? fst)\n                  (into-current-key (assoc acc fst []) fst rst)\n                  (let [lst (get acc cur-key)\n                        new-lst (conj lst fst)\n                        new-acc (assoc acc cur-key new-lst)]\n                    (into-current-key new-acc cur-key rst))))))]\n\n    (into-current-key {}  (first coll) coll)))", "user": "5344fe13e4b084c2834f4a32"}, {"problem": 105, "code": "(fn identify-keys-and-values [col]\r\n  (loop [[x & xs] col, k nil, res {}]\r\n    (cond (nil? x) res\r\n          (number? x) (recur xs k (update-in res [k] #(conj % x)))\r\n          :non-num    (recur xs x (assoc res x [])))))", "user": "4dd7d040535d2dad7130b5d6"}, {"problem": 105, "code": "(fn [v]\n  (loop [current-key nil\n         v v\n         result {}]\n    (if (empty? v)\n      result\n      (let [current (first v)]\n        (if (keyword? current)\n          (recur current (rest v) (assoc result current []))\n          (recur current-key (rest v) (assoc result current-key (conj (current-key result) current))))))))", "user": "54580586e4b01be26fd74616"}, {"problem": 105, "code": "(fn createMap\n  [s]\n  (let [reduceList (fn reduceList [l]\n                     (loop [currL (rest l)\n                            currK (first l)\n                            result []]\n                       (if (empty? currL)\n                         result\n                         (if (keyword? (first currL))\n                           (recur (rest currL) (first currL) (conj result [(first currL) nil]))\n                           (recur (rest currL) currK (conj result [currK (first currL)]))))))]\n    (reduce (fn [m s] (let [key (first s)\n                            val (second s)]\n                        (if (contains? m key)\n                          (assoc m key (conj (get m key) val))\n                          (if (nil? val)\n                            (assoc m key (vector))\n                            (assoc m key (vector val))))))                                                                          \n            {}\n            (reduceList s))))", "user": "54f64e99e4b0f2f3c5226ea4"}, {"problem": 105, "code": "(fn keys-and-values [s]\n  (loop [accu {}\n         s (drop-while (complement keyword?) s)]\n    (if (empty? s)\n      accu\n      (recur (assoc accu (first s) (take-while (complement keyword?) (rest s))) (drop-while (complement keyword?) (rest s))))))", "user": "4e82c062535db62dc21a62cc"}, {"problem": 105, "code": "#(->> %\n     (partition-by type)\n     (partition 2)\n     (map (fn [[k v]]\n            (if (> (count k) 1)\n              (let [[a b] k]\n                [[a []]\n                 [b v]])\n              [(vec (concat k [v]))])))\n     (apply concat)\n     (into {}))", "user": "54b7f217e4b0ed20f4ff6e8f"}, {"problem": 105, "code": "(fn [lst]\n  (apply hash-map (reduce (fn [acc el]\n            (if (number? el)\n              (if (coll? (last acc)) (conj (into [] (butlast acc)) (conj (last acc) el))\n                  (conj acc [el]))\n              (apply conj acc (if (and (keyword? el) (keyword? (last acc)))\n                                [[] el]\n                                [el])))) [] lst)))", "user": "51b76227e4b0d906fcd71d35"}, {"problem": 105, "code": "(fn [coll]\n (loop [[h & ts] coll\n        rmap {}]\n  (if (nil? h)\n   rmap\n   (let [[num lst]\n         (split-with\n          number?\n          ts)]\n    (recur\n     lst\n     (assoc rmap h num))))))", "user": "549a999be4b0f3d1d8e70f6f"}, {"problem": 105, "code": "(fn ikv ([coll] (ikv {}\n                     nil\n                     [] \n                     coll))\n   \t\t([res cur-k cur-v coll] (if (empty? coll)\n                           \t \t(if (not (nil? cur-k))\n                                  \t(assoc res cur-k cur-v) \n                                  \tres)\n                           \t \t(if (nil? cur-k)\n                                   \t(ikv res (first coll) [] (rest coll))\n                                   \t(if (not (keyword? (first coll)))\n                                       \t(ikv res cur-k (conj cur-v (first coll)) (rest coll))\n                                       \t(ikv (assoc res cur-k cur-v) nil [] coll))))))", "user": "542c1f73e4b0dad94371f29d"}, {"problem": 105, "code": "(fn [v]\n  (->> (interpose \",\" v)\n       (partition-by keyword?)\n       (partition-all 2 )\n       (map (fn [[[k] vs]] [k (remove #{\",\"} vs)]))\n       (into {})))", "user": "50e90813e4b033b0e80d11e7"}, {"problem": 105, "code": "(fn [s]\n  (apply hash-map\n         (loop [left [] [head & tail] s]\n           (if (empty? tail) left\n             (let [[body tail] (split-with number? tail)]\n               (recur (conj left head (vec body))\n                      tail))))))", "user": "54febf4be4b07d26eda61d45"}, {"problem": 105, "code": "#(loop [s %\n        h {}\n        c nil]\n   (if (empty? s)\n     h\n     (if (keyword? (first s))\n       (recur (rest s)\n              (assoc h (first s) [])\n              (first s))\n       (recur (rest s)\n              (assoc h c (conj (h c) (first s)))\n              c))))", "user": "551ed214e4b08d5046aa8a4d"}, {"problem": 105, "code": "(fn [param]\n(reduce (fn [acc x] \n          (if (> (count (key x)) 1) \n            (assoc acc (first (key x)) [] (second (key x)) (vec (val x)) )\n            (assoc acc (first (key x)) (vec (val x))) ) ) {} \n        (apply hash-map (partition-by keyword? param))))", "user": "54e51c7be4b024c67c0cf7f7"}, {"problem": 105, "code": "(fn [seqe]\n   (loop [seqe seqe keyw nil items [] res {}]\n     (println seqe keyw items res)\n     (if (empty? seqe)\n       (if (nil? keyw)\n         res\n         (assoc res keyw items))\n       (if (keyword? (first seqe))\n         (if (nil? keyw)\n           (recur (rest seqe) (first seqe) items res)\n           (recur (rest seqe) (first seqe) [] (assoc res keyw items)))\n         (recur (rest seqe) keyw (vec (conj items (first seqe))) res)))))", "user": "5508102ee4b021ccfedb96b0"}, {"problem": 105, "code": "(fn [[x0 x1 & x]]\n  (loop [acc {}, k x0, x0 x1, x x]\n    (cond (nil? x0) acc\n          (keyword? x0) (recur (assoc acc x0 []) x0 (first x) (next x))\n          true (recur (assoc acc k (conj (acc k []) x0)) k (first x) (next x)))))", "user": "54bbaa8ee4b0ed20f4ff6ec0"}, {"problem": 105, "code": "(fn ! [in]\n  (if-let [[k & r] (seq in)]\n    (let [[v n] (split-with number? r)] (assoc (! n) k v))\n    {}))", "user": "53908e6be4b0b51d73faae9a"}, {"problem": 105, "code": "(fn hasher\n  ([coll] (hasher coll {}))\n  ([coll acc]\n   (if (empty? coll)\n     acc\n     (let [k (first coll)\n           working-coll (rest coll)\n           vs (take-while (comp not keyword?) working-coll)\n           rst (drop (count vs) working-coll)]\n       (hasher rst (assoc acc k vs))))))", "user": "5412ef7ee4b01498b1a719da"}, {"problem": 105, "code": "(fn to-key-vals [xs]\n  (loop [m {}, k nil, v [], xs xs]\n    (if-let [x (first xs)]\n      (if (keyword? x)\n        (recur (if k (assoc m k v) m) x [] (rest xs))\n        (recur m k (conj v x) (rest xs)))\n      (if k (assoc m k v) m))))", "user": "54f2fe9fe4b050824f58f5b8"}, {"problem": 105, "code": "#(into \n  {}\n  ((fn co [[f & s]]\n     (if (not (nil? f))\n       (let [[v r] (split-with (comp not keyword?) s)]\n         (concat {f (into [] v)} (co r))))\n     ) %)\n  )", "user": "51a058dae4b0b292b01ee3f3"}, {"problem": 105, "code": "(fn [xs]\n          (into {}  (loop [res [] xs xs] \n                      (let [k1 (first (take-while keyword? xs))\n                            v1 (take-while (complement keyword?) (drop 1 xs))\n                            ]\n                        (if (nil? k1)\n                          res\n                          (recur (conj res [k1 v1]) (drop (+ 1 (count v1))  xs))\n                          )\n                        )))\n          )", "user": "533c2605e4b0e30313ee6cd7"}, {"problem": 105, "code": "(fn [s]\n  (loop [m {} k nil [fs & s] s]\n    (cond\n      (nil? fs) m\n      (keyword? fs) (recur (assoc m fs []) fs s)\n      :else (recur (update-in m [k] conj fs) k s))))", "user": "4f7207d3e4b07046d9f4f019"}, {"problem": 105, "code": "(fn to-map [lst]\n   (if (not (keyword? (first lst)))\n     {}\n     (loop [last-key (first lst) res {} rem lst]\n       (let [fst (first rem)]\n         (cond (empty? rem) res\n               (keyword? fst) (recur fst (assoc res fst []) (rest rem))\n               :else (recur last-key (assoc res last-key (conj (get res last-key) fst)) (rest rem)))))))", "user": "54f09599e4b024c67c0cf89d"}, {"problem": 105, "code": "#(->> (interpose nil %)\n       (partition-by keyword?)\n       (partition 2)\n       (map (fn [[k v]] [(first k) (filter identity v)]))\n       (into {}))", "user": "4fbf2818e4b081705acca317"}, {"problem": 105, "code": "(fn seq-map [coll]\n  (->> coll\n       (reduce (fn [[k {v k, :as acc}] x]\n                 (if (keyword? x)\n                   [x (assoc acc x (get acc x []))]\n                   [k (assoc acc k (conj v x))]))\n               [nil {}])\n       last))", "user": "4fc6305de4b0ee37620e180b"}, {"problem": 105, "code": "(fn [s]\n    (loop [result {}\n           [next-key & to-do] s]\n      (if (nil? next-key)\n        result\n        (recur (assoc result next-key (vec (take-while number? to-do)))\n               (drop-while number? to-do)))))", "user": "5531e445e4b09218d5f44f76"}, {"problem": 105, "code": "#(loop [[fr & rst] %\n         r {}\n         k nil]\n    (cond\n      (nil? fr) r\n      (keyword? fr)(recur rst (assoc r fr []) fr)\n      :else (recur rst (assoc r k (conj (r k) fr)) k)))", "user": "53d5a63be4b0e771c3025449"}, {"problem": 105, "code": "(fn [xs]\n  (loop [xs xs, res {}]\n    (if (empty? xs) res\n      (let [[k & xs] xs\n            [vs xs] (split-with number? xs)]\n        (recur xs (assoc res k vs))))))", "user": "553e0b70e4b0a04f792994e8"}, {"problem": 105, "code": "#(second (reduce (fn [[k m :as a] v]\n                   (if (keyword? v)\n                     [v (assoc m v [])]\n                     [k (update-in m [k] conj v)])) [nil {}] %))", "user": "4f9d8083e4b0dcca54ed6d23"}, {"problem": 105, "code": "(fn [coll]\n  (loop [s (seq coll) m {} kw nil]\n    (if (empty? s)\n      m\n      (let [f (first s) k? (keyword? f)]\n        (recur (rest s) (if k? (assoc m f []) (update-in m [kw] conj f)) (if k? f kw))))))", "user": "553abb28e4b09218d5f44ffb"}, {"problem": 105, "code": "(fn [xs] (let [[f s] (reduce (fn [[a b] c] (if (keyword? c)\n                                             [(conj a b) [c []]]\n                                             [a [(first b) (conj (second b) c)]]))\n                             []\n                             xs)]\n           (into {}\n                 (conj f s))))", "user": "4fcf1755e4b03432b189f40c"}, {"problem": 105, "code": "(fn [xs] (apply hash-map (apply concat [] (map #(if (keyword? (first %)) (interpose [] %) [%]) (partition-by keyword? xs)))))", "user": "5507cfd3e4b021ccfedb96ad"}, {"problem": 105, "code": "(fn v2mv [vc]\n  (let [v2m (fn [v] (into {} (for [s (range 0 (count v) 2)] [(first (v s)) (v (inc s))])))\n        appnil (flatten (map #(list %1 %2) vc (map (fn [i] nil) (range (count vc)))))  \n        grp    (map #(filter (fn [v] (not= nil v)) %) (partition-by #(= clojure.lang.Keyword (class %)) appnil))\n        grpvec (vec (map vec grp))]\n    (v2m grpvec)))", "user": "5243e37ae4b076204b44fae3"}, {"problem": 105, "code": "(fn keys-vals [s]\n  (if (empty? s) {}\n      (conj (keys-vals (drop-while number? (drop 1 s)))\n            (hash-map (first (take-while keyword? s))\n                      (take-while number? (drop 1 s))))))", "user": "547884d7e4b0c51c1f4d72bd"}, {"problem": 105, "code": "(fn [s]\n  (letfn [(f [[x & xs]]\n             (when x\n               (let [[t d] (split-with number? xs)]\n                 (cons [x t] (lazy-seq (f d))))))]\n    (into {} (f s))))", "user": "52ce1abfe4b07d0d72b27389"}, {"problem": 105, "code": "#(loop [coll %1, k nil, result {}]\n\t(if\t(empty? coll)\n\t\tresult\n\t\t(let [c0 (first coll), coll' (rest coll), new-key (keyword? c0), k' (if new-key c0 k), v (get result k' [])]\n\t\t\t(recur coll' k' (assoc result k' (if new-key v (conj v c0)))))))", "user": "5370b386e4b0fc7073fd6e9b"}, {"problem": 105, "code": "(fn f [v]\n(let [ks (filter keyword? v) vs (repeat (count ks) []) im (zipmap ks vs)]\n    (dissoc (reduce #(if (keyword? %2) (merge %1 {:k %2}) (merge-with conj %1 {(get %1 :k) %2})) im v) :k)))", "user": "551c66dae4b07993ea3788de"}, {"problem": 105, "code": "#(loop [m {} k nil c %]\n  (let [s (first c) t (rest c)]\n    (cond (empty? c) m\n          (keyword? s) (recur (assoc m s []) s t)\n          :else (recur (assoc m k (conj (m k) s)) k t))))", "user": "543366dde4b0b6b47310fcdf"}, {"problem": 105, "code": "(fn id-kv [coll]\n  (loop [acc {}\n         curr-key nil\n         coll coll]\n    (let [item (first coll)]\n      (cond\n        (empty? coll) acc\n        (keyword? item) (recur (assoc acc item [])\n                               item\n                               (rest coll))\n        :else (recur (merge-with conj acc {curr-key item})\n                     curr-key\n                     (rest coll))))))", "user": "5515b138e4b055c2f668d4ed"}, {"problem": 105, "code": "(fn my-keys-2 [coll]\n  (loop [elems coll result {}]\n    (if (empty? elems)\n\t  result\n\t  (let [key (first elems) \n\t        values (take-while #(not (keyword? %)) (rest elems)) \n\t\t\tnext-elems (drop-while #(not (keyword? %)) (rest elems))\n\t\t\tnext-result (assoc result key values)] \n\t\t\t  (recur next-elems next-result)))))", "user": "51eec1a6e4b0871fa145d98d"}, {"problem": 105, "code": "(fn [col] \n  (apply hash-map \n   (reduce \n    #(if (keyword? %2)\n      (concat %1 [%2 []])\n      (concat (butlast %1) [(conj (last %1) %2)]))\n    {} \n    col)))", "user": "55536a8ae4b0deb715856e03"}, {"problem": 105, "code": "(fn [coll]\n  (second\n    (reduce \n      (fn [[kw acc] v]\n        (if (keyword? v) \n          [v (assoc acc v [])]\n          [kw (update-in acc [kw] #(conj % v))]))\n      [nil {}] coll)))", "user": "504e71cbe4b0f6ff3350c4b3"}, {"problem": 105, "code": "(fn [a]\n  ((fn f [s k m]\n    (if (empty? s)\n      m\n      (let [x (first s)]\n        (f (rest s)\n           (if (keyword? x) x k)\n           (if (keyword? x)\n             (assoc m x [])\n             (assoc m k (conj (m k) x)))))))\n  a nil {}))", "user": "55495318e4b0a04f79299566"}, {"problem": 105, "code": "(fn [s]\n  (loop [s1 s k nil m {}]\n    (if (empty? s1)\n      m\n      (recur (rest s1)\n             (if (keyword? (first s1))\n               (first s1)\n               k)\n             (if (not (keyword? (first s1)))\n               (into m {k (conj (get m k) (first s1))})\n               (into m {(first s1) []}))))))", "user": "54cad59ee4b057c6fda3a26e"}, {"problem": 105, "code": "(letfn [(augment [xs acc]\n                 (if (empty? xs)\n                   acc\n                   (let [k (first xs)\n                         vs (take-while (complement keyword?) (rest xs))]\n                     (recur (drop-while (complement keyword?) (rest xs))\n                            (assoc acc k vs)))))]\n  (fn [xs]\n    (augment xs {})))", "user": "5553b924e4b0deb715856e06"}, {"problem": 105, "code": "#(loop[result {}, k (first %), v [], remaining (rest %)]\n   (if-let [newVal (first remaining)]\n     (if \n       (keyword? newVal) (recur (assoc result k v) newVal [] (rest remaining))\n       (recur result k (conj v newVal) (rest remaining)))\n     (if (nil? k) result\n       (assoc result k v))))", "user": "556c70dae4b09a3098a524fd"}, {"problem": 105, "code": "(fn [seq]\r\n  (let [\r\n      new-result (fn [result key value]\r\n        (if (nil? key) result (assoc result key value)))]\r\n    (loop [\r\n        [head & tail] seq\r\n        key nil\r\n        value []\r\n        result {}]\r\n      (if (nil? head)\r\n        (new-result result key value)\r\n      (if (keyword? head)\r\n        (recur tail head [] (new-result result key value))\r\n        (recur tail key (conj value head) result))))))", "user": "555bd27ae4b0b056612e2244"}, {"problem": 105, "code": "(fn p105\n  [coll]\n  (if (seq coll)\n    (if (keyword? (first coll))\n      (assoc (p105 (rest coll)) (first coll) (take-while number? (rest coll)))\n      (p105 (rest coll)))\n    {}))", "user": "520cb8c4e4b0b022ef140c9a"}, {"problem": 105, "code": "(fn [x]\n    (if (empty? x)\n      {}\n      (loop [result {}\n             [k & r] x]\n        (if (empty? r)\n          (assoc result k [])\n          (let [[v r] (split-with #(not (keyword? %)) r)]\n            (if (empty? r)\n              (assoc result k v)\n              (recur (assoc result k v) r)))))))", "user": "4f42ae16e4b0d7d3c9f3fd09"}, {"problem": 105, "code": "(fn lst2map [lst]\n\t(let [collect-number (fn [sum-r i]\n\t\t\t\t\t\t\t(let [a (first sum-r)\n\t\t\t\t\t\t\t\tb (second sum-r)]\n\t\t\t\t\t\t\t\t(if (keyword? i)\n\t\t\t\t\t\t\t\t\t(vec [(assoc a i []) i])\n\t\t\t\t\t\t\t\t\t(vec [(assoc a b (conj (get a b) i)) b]))))\n\t\t  r (reduce collect-number [{} nil] lst)]\n\t\t(first r)))", "user": "5374adc3e4b06d7f452d9e27"}, {"problem": 105, "code": "(fn [coll]\n  (letfn [(collect [coll]\n            (when-not (empty? coll)\n              (let [x (first coll)\n                    xs (rest coll)]\n                (let [[values remainder] (split-with #(not (keyword? %)) xs)]\n                  (cons\n                    [x values]\n                    (collect remainder))))))]\n    (into {} (collect coll))))", "user": "55702081e4b09a3098a52529"}, {"problem": 105, "code": "(fn key-nums [xx]\n  (loop [r {}\n         xs xx]\n    (if (empty? xs)\n      r\n      (recur\n       (assoc r (first xs) (take-while number? (rest xs)))\n       (drop-while number? (rest xs))))))", "user": "5283a919e4b0239c8a67adbe"}, {"problem": 105, "code": "(fn [coll]\n  (loop [coll coll, acc {}]\n    (if (empty? coll) acc\n      (let [head (first coll)\n            tail (rest coll)]\n        (if (keyword? head)\n          (recur tail (assoc acc head []))\n          \n          (let [k (key (first acc))]\n            (recur tail (assoc acc k (concat (acc k) [head])))))))))", "user": "53065acbe4b02e8216869792"}, {"problem": 105, "code": "(fn [coll]\n  (loop [res {}\n         last-key nil\n         coll coll]\n    (if (empty? coll)\n      res\n      (let [v (first coll)]\n        (if (keyword? v)\n          (recur (assoc res v [])\n                 v\n                 (rest coll))\n          (recur (merge-with conj res {last-key v})\n                 last-key\n                 (rest coll)))))))", "user": "55586905e4b0deb715856e2b"}, {"problem": 105, "code": "(fn key-vals [xs] \n  (->> (partition-by keyword? xs)\n       (partition 2)\n       (reduce (fn [m [a b]] (merge m (zipmap (reverse a) (concat [b] (repeat []))))) {})))", "user": "55645592e4b0c656e3ff1802"}, {"problem": 105, "code": "(fn [l]\n  (loop [h {}, last-sym nil, left l]\n    (if (empty? left)\n      h\n      (let [curr (first left)\n            next-hash\n            (if (number? curr)\n              (assoc h last-sym (conj (h last-sym) curr))\n              (assoc h curr []))]\n        (recur next-hash (if (number? curr) last-sym curr) (rest left))))))", "user": "536046a9e4b063bf7a5f8fe1"}, {"problem": 105, "code": "#(loop [[h & r] % m {} k nil]\n   (if h\n     (if (keyword? h)\n       (recur r (merge m {h []}) h)\n       (recur r (merge m {k (conj (k m) h)}) k))\n     m))", "user": "545ddac3e4b01be26fd74676"}, {"problem": 105, "code": "(fn [vec]\n  (loop [m {} currentVec [] s vec]\n    (if (empty? s) (if (empty? currentVec) m (assoc m (first currentVec) (rest currentVec)))\n      (if (empty? currentVec) (recur m (conj currentVec (first s)) (rest s))\n        (if (number? (first s)) (recur m (conj currentVec (first s)) (rest s))\n          (recur (assoc m (first currentVec) (rest currentVec)) [] s))))))", "user": "558378dce4b05c286339e115"}, {"problem": 105, "code": "(fn [src]\n           (loop [result {} src src]\n             (if (not (seq src))\n               result\n               (let [sym (first src)\n                     nums (take-while (comp not keyword?) (rest src))\n                     left (drop-while (comp not keyword?) (rest src))]\n                 (recur (conj result {sym nums}) left)))))", "user": "530b8580e4b02e82168697cc"}, {"problem": 105, "code": "#(first (reduce (fn [[m k] x]\n                  (if (keyword? x)\n                    [(assoc m x []) x]\n                    [(update-in m [k] conj x) k]))\n                [{} nil] %))", "user": "52470d42e4b05ef8e38e6350"}, {"problem": 105, "code": "(fn keys-and-values\n  [xs]\n  (into {} (mapcat\n            (fn [[x y]]\n              (zipmap x\n                      (concat (repeat (dec (count x)) []) (list y))))\n            (partition-all 2 (partition-by keyword? xs)))))", "user": "506f0968e4b09350ab4199f5"}, {"problem": 105, "code": "(fn [x](let [a (map #(map second %) (partition-by first (map vector (reductions + (map #(if (keyword? %) 1 0) x))\u3000x)))]\n   (into {} (map (fn [[x & s]] (if (nil? s) {x ()} {x s})) a))))", "user": "55896a0ce4b059ccff29b204"}, {"problem": 105, "code": "(fn \n  ([m]\n  (->> m\n    (reduce #(if (keyword? %2) \n                 (conj %1 %2 []) \n                 (conj %1 %2)) \n          [])\n  (partition-by keyword?)\n  (partition 2)\n  (map (fn [[[k] v]] [k (if (next v) (apply conj v) [])]))\n  (into {}))))", "user": "532a033be4b09d4e7a9b551f"}, {"problem": 105, "code": "(letfn [                                                                                                                                                \n    (partition-on-keyword [s]                                                                                                   \n        (if (empty? s) '()                                                                                                                              \n            (let [run (cons (first s) (take-while #(not (keyword? %)) (rest s)))]                                               \n                (cons run (partition-on-keyword (drop (count run) s))))))                                                                               \n    (decode [s] {(first s) (rest s)})                                                                                           \n    (make-map [s] (into {} (map decode (partition-on-keyword s))))]                                                                                     \n        make-map)", "user": "558b50d5e4b027778923762b"}, {"problem": 105, "code": "(fn to-hs [lst]\n  (let [out (reduce #(assoc %1 %2 []) {} (map #(first %) (filter  #(every? identity (map keyword? %)) (partition 2 1 lst))))]\n    (reduce #(assoc %1 (last (first %2)) (into [] (last %2)))\n            out (partition 2 (partition-by keyword? lst)))\n    )\n  )", "user": "5545477fe4b0a04f79299531"}, {"problem": 105, "code": "(fn mmap\n  [coll]\n  (loop [coll coll  res {} key nil val [] ]\n    (let [f (first coll)] \n      (if (empty? coll)\n        (if (or (= key nil) (contains? res key))\n          res\n          (assoc res key val))\n        (if (and (= key nil) (keyword? f))\n          (recur (rest coll) res f val)\n          (if (keyword? f)\n            (recur (rest coll) (assoc res key val) f [])\n            (recur (rest coll) res key (conj val f))))))))", "user": "55079e55e4b021ccfedb96aa"}, {"problem": 105, "code": "(fn [coll]\n  (apply hash-map\n         (reduce (fn [r e]\n                   (if (keyword? e)\n                     (conj r e [])\n                     (conj (vec (drop-last r)) (conj (last r) e))))\n                 []\n                 coll)))", "user": "540a4f20e4b0addc1aec66ef"}, {"problem": 105, "code": "(fn ikv [s]\n\t(loop [li s r {} prevk nil]\n\t\t(if (empty? li)\n\t\t\tr\n\t\t\t(recur (rest li)\n\t\t\t\t\t\t (if (keyword? (first li))\n\t\t\t\t\t\t\t (if (nil? ((first li) r))\n\t\t\t\t\t\t\t\t (assoc r (first li) [])\n\t\t\t\t\t\t\t\t r)\n\t\t\t\t\t\t\t (assoc r prevk (conj (prevk r) (first li))))\n\t\t\t\t\t\t (if (keyword? (first li))\n\t\t\t\t\t\t\t (first li)\n\t\t\t\t\t\t\t prevk)))))", "user": "52979551e4b02ebb4ef75043"}, {"problem": 105, "code": "(fn identify-key-value\n  [coll]\n  (let [key-val (partition-by keyword? coll) parts (partition 2 key-val)]\n    (into {} (concat (map vector (map last (map first parts)) (map second parts))\n            (map vector (mapcat butlast (map first parts)) (repeat []))))))", "user": "557e9d17e4b05c286339e0d8"}, {"problem": 105, "code": "#(loop [[a & s] % m {} k nil]\n    (if (nil? a)\n      m\n      (if (keyword? a)\n        (recur s (assoc m a []) a)\n        (recur s (update-in m [k] conj a) k))))", "user": "559279b7e4b0604b3f94d58c"}, {"problem": 105, "code": "(fn q [[f & r]]\n  (if f\n    (let [[g h] (split-with number? r)]\n      (conj (q h) {f g}))\n    {}))", "user": "559c13c5e4b066d22e731f61"}, {"problem": 105, "code": "(fn [s]\n  (loop [r s\n         a {}\n         k nil]\n    (if-let [f (first r)]\n      (if (keyword? f)\n        (recur (rest r) \n               (assoc a f []) \n               f)\n        (recur (rest r)\n               (assoc a k (conj (get a k) f))\n               k))\n      a)))", "user": "55995fa7e4b031d6649c9ba9"}, {"problem": 105, "code": "(fn [v]\n  (reduce (fn [m [ks vs]] \n            (into (assoc m (last ks) (vec vs)) \n                  (apply hash-map (interleave (butlast ks) (repeat (vec nil))))))\n          {} (partition 2 (partition-by keyword? v))))", "user": "5504dd64e4b086ebe8a79c83"}, {"problem": 105, "code": "(fn [s]\n  (loop [[h & t] s l nil r {}]\n    (cond\n      (nil? h) r\n      (keyword? h) (recur t h (assoc r h []))\n      :else (recur t l (assoc r l (conj (r l) h))))))", "user": "5590e55de4b0277789237676"}, {"problem": 105, "code": "(fn me [args]\n\n\t(let [myfn (fn [args]\n\n\t\t\t\t\t(let [my-keys   (first args)\n\t\t  \t\t\t\t  my-value  (into [] (second args))\t\n\t\t\t\t\t\t ] \n\t\t\t\t\t\t(if (= 1 (count my-keys))\n\t\t\t\t\t\t\t(hash-map (first my-keys) my-value)\n\t\t\t\t            (apply merge \n\t\t\t\t            \t\t(apply merge (map #(hash-map %1 []) (drop-last my-keys))) \n\t\t\t\t            \t\t(hash-map (last my-keys) my-value)\n\t\t\t\t            )\t\t\n\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t)\n\n\t\t\t\t\t\t)\n\t\t]\n\n      \t(if (empty? args) \n          \t{} \n      \n\t\t\t(apply merge\n\n\t\t\t\t(map myfn (partition 2 (partition-by number? args)))\n\t\t\t))\n\n\t\t)\n\n)", "user": "55897fe2e4b059ccff29b205"}, {"problem": 105, "code": "(fn roll [v]\n  (if (empty? v)\n    {}\n\n  (loop [rv {(first v) []}\n         current (first v)\n         v (rest v)]\n    (cond\n      (empty? v) rv\n      (keyword? (first v)) (recur (assoc rv (first v) []) (first v) (rest v))\n      :else\n        (recur (assoc rv current (conj (current rv) (first v))) current (rest v))))))", "user": "55934bebe4b0c79f6e1db93b"}, {"problem": 105, "code": "#(->> %\n      (partition-by keyword?)\n      (partition 2)\n      (map (fn [[ks vs]]\n             (let [[k & oks] (reverse ks)]\n               (into {k vs} (map (fn [ok] {ok []}) oks)))))\n      (into {}))", "user": "559b2ad1e4b066d22e731f4e"}, {"problem": 105, "code": "(fn number105 [xs]\n  (let [kvs (reduce #(if (keyword? %2)\n                      (assoc %1 :ks (conj (:ks %1) %2) :vs (conj (:vs %1) []))\n                      (assoc-in %1 [:vs (dec (count (:vs %1)))] (conj (last (:vs %1)) %2)))\n                    {:ks [] :vs []} xs)]\n    (zipmap (:ks kvs) (:vs kvs))))", "user": "54074fc5e4b0addc1aec66b6"}, {"problem": 105, "code": "(fn [series]\n   (second (reduce\n             (fn [acc v]\n               (let [k (first acc)\n                     m (second acc)]\n                 (if (keyword? v)\n                   [v (assoc m v [])]\n                   [k (assoc m k (conj (k m) v))]))\n               ) [nil {}] series)))", "user": "5592bf9fe4b0c79f6e1db933"}, {"problem": 105, "code": "(fn identify-k-v [s]\n  (if (empty? s)\n    {}\n    (let [[k & rest] s\n          [n r] (split-with number? rest)]\n      (assoc (identify-k-v r) k n))))", "user": "51bfc1f0e4b0e49ef9037dd4"}, {"problem": 105, "code": "(fn [coll]\n    (letfn [(split-kw [s]\n                      (if (empty? s)\n                        []\n                      \t(let [k (first s), sp (split-with (complement keyword?) (rest s)), v (first sp), r (second sp)]\n                          (cons [k v] (split-kw r)))))]\n            (into {} (split-kw coll))))", "user": "55afd469e4b002ce9d5cbc19"}, {"problem": 105, "code": "#(into {} (reduce \n  (fn [acc e] \n    (let [f (first acc)\n          k (if (integer? e) (first f) e)\n          v (if (integer? e) (conj (second f) e) [])\n          acc2 (if (integer? e) (rest acc) acc)]\n       (cons [k v] acc2))) '() %))", "user": "55a74d46e4b09e57187da2a3"}, {"problem": 105, "code": "(fn [coll]\n  (if (empty? coll)\n    {}\n    (loop [res {}\n           tail coll]\n      (if (empty? tail)\n        res\n        (let [key (first tail)\n              values (take-while #(not (keyword? %)) (rest tail))]\n          (recur (into res {key (vec values)}) (drop (inc (count values)) tail)))))))", "user": "55205564e4b08d5046aa8a60"}, {"problem": 105, "code": "(fn [cl] (let [cnt (count cl)\n          ck (filter keyword? cl)\n          cv (for [i (range cnt) :when(keyword? (nth cl i))]\n             (vec (for [p (range (inc i) cnt) :while (not (keyword? (nth cl p)))] (nth cl p))))]\n          (println ck)\n          (println cv)\n          (zipmap ck cv)\n))", "user": "55adf4d7e4b03311e7b732af"}, {"problem": 105, "code": "#(loop [[x & xs] %\n         k nil\n         r {}]\n    (if (nil? x)\n      r\n      (if (keyword? x)\n        (recur xs x (assoc r x []))\n        (recur xs k (assoc r k (conj (r k) x))))))", "user": "55ac07afe4b03311e7b7328f"}, {"problem": 105, "code": "(fn [s] (apply hash-map\n   (reduce #(if (keyword? %2)\n               (conj % %2 [])\n               (conj (pop %)                          (conj (peek %) %2)))\n                   [] s)))", "user": "526a3412e4b03e8d9a4a721e"}, {"problem": 105, "code": "(fn [v] \n  (reduce #(assoc %1 (first (first %2)) (vec (last %2)))\n          {} (map \n               #(vector (first %) (filter number? (last %))) \n               (partition 2 (partition-by keyword? (interleave  v (repeat (count v) [] )))))))", "user": "5576e78de4b05c286339e075"}, {"problem": 105, "code": "(fn [coll]\n  (loop [acc {} coll' coll]\n    (if (empty? coll')\n      acc\n      (let [kw (first coll')\n            [vs rcoll] (split-with #(not (keyword? %)) (rest coll'))]\n        (recur (assoc acc kw vs) rcoll)))))", "user": "5576f299e4b05c286339e077"}, {"problem": 105, "code": "(fn [x]\n   (loop [m {} s x]\n     (if-let [[s & q] (seq s)]\n       (let [[h i] (split-with number? q)]\n         (recur (assoc m s h) i))\n       m)))", "user": "55be39f9e4b01b9910ae2a06"}, {"problem": 105, "code": "(fn [values]\n (loop [result {}\n        last-key nil\n        current-value (first values)\n        remaining-values (rest values)]\n   (if-not current-value\n     result\n   \t (let [[new-result new-key] (if (keyword? current-value)\n                                 [(assoc result current-value []) current-value]\n                                 [(update-in result [last-key] conj current-value) last-key])]\n           (recur new-result new-key (first remaining-values) (rest remaining-values))))))", "user": "55bfd68ae4b01b9910ae2a1e"}, {"problem": 105, "code": "(fn kv [acc k [v & vs]]\n  (cond (nil? v) acc\n        (keyword? v) (kv (assoc acc v []) v vs)\n        :e (kv (update-in acc [k] conj v) k vs))) {} *", "user": "537e104ce4b06839e8705e9a"}, {"problem": 105, "code": "(fn [c]\n  (loop [h nil\n         s c\n         acc {}]\n    (if (seq s)\n      (if (keyword? (first s))\n        (recur (first s) (rest s) (assoc acc (first s) [])) \n        (let [h-list (get acc h [])\n              v (first s)\n              h-list-updated (conj h-list v)\n              new-acc (assoc acc h h-list-updated)]\n          (recur h (rest s) new-acc)))\n      acc)))", "user": "5596a324e4b04c1e5c31d757"}, {"problem": 105, "code": ";(fn idkv [args]\n;  (loop [[x & xs] args k nil v [] result []]\n;     (if (nil? x)\n;         (if (nil? k) \n;             (into {} result)\n;             (into {} (conj result [k v])))\n;         (if (keyword? x)\n ;            (if (nil? k) \n  ;               (recur xs x [] result)\n   ;              (recur xs x [] (conj result [k v])))\n    ;          (recur xs k (conj v x) result)))))\n\n(fn idkv [args]\n   (let [kvs (partition-by #(if (keyword? %) % 1) args)]\n     (loop [[k v & kvs] kvs result {}]\n       (if (nil? k)\n           result\n           (cond (nil? v) (merge result [(first k) []])\n                 (keyword? (first v)) (recur (cons v kvs) (merge result [(first k) []]))\n                 :else (recur kvs (merge result [(first k) (vec v)])))))))", "user": "559b55d6e4b066d22e731f54"}, {"problem": 105, "code": "(fn [v]\n    (letfn [(make-two-pair [[x & xs] y]\n              (if (empty? xs)\n                [x y] \n                (loop [lst [x []] [x & xs] xs]\n                  (if (empty? xs)\n                    (conj lst  x y)\n                    (recur (conj lst  x []) xs))))\n              )]\n      (if (empty? v) {} \n        (->> (partition-by type v)\n          (partition 2 )  \n          (mapcat #(apply make-two-pair %))\n          (apply assoc {})\n          ))))", "user": "55aa1637e4b0988bba2ad949"}, {"problem": 105, "code": "(fn make-map [xs]\n  (if (empty? xs)\n    {}\n    (merge {(first xs) (take-while (complement keyword?) (rest xs))}\n           (make-map (drop-while (complement keyword?) (rest xs))))))", "user": "55c4e48be4b0e31453f649a7"}, {"problem": 105, "code": "(fn [coll]\n  (loop [c coll res {}]\n    (if (empty? c)\n      res\n      (let [[f & r] c\n            [items more] (split-with (comp not keyword?) r)]\n        (recur more (assoc res f items))))))", "user": "55c0afa5e4b01b9910ae2a27"}, {"problem": 105, "code": "(fn [col]\n  (letfn [(myassoc [m keywords v]\n            (if (= 1 (count keywords))\n              (assoc m (first keywords) v)\n              (myassoc (assoc m (first keywords) []) (rest keywords) v)))\n          (mapify [m keywords-val-pair]\n            (let [[keywords v] keywords-val-pair]\n              (myassoc m keywords (into [] v))))]\n    (let [keywords-val-pairs (partition 2 (partition-by type col))]\n      (reduce mapify {} keywords-val-pairs))))", "user": "5535e822e4b09218d5f44fb2"}, {"problem": 105, "code": "(fn [s]\n  (loop [m {}\n         s s]\n    (let [k (first s)\n          v (take-while integer? (rest s))]\n      (if (nil? k)\n        m\n        (recur (conj m [k v]) (drop (inc (count v)) s))))))", "user": "549c6792e4b0f3d1d8e70f8b"}, {"problem": 105, "code": "(fn [s]\n  (loop [in s, out {}, curKey nil, curVal []]\n    (cond \n      (empty? in)\n        (if (nil? curKey) out (conj out [curKey curVal]))\n      (keyword? (first in))\n        (if (nil? curKey)\n          (recur (rest in) out (first in) curVal)\n          (recur (rest in) (conj out [curKey curVal]) (first in) []))\n      :else (recur (rest in) out curKey (conj curVal (first in))))))", "user": "559454f2e4b0c79f6e1db952"}, {"problem": 105, "code": "(fn [s]\n  (loop [s s, k nil, result {}]\n    (cond (empty? s) result\n          (keyword? (first s)) (recur (rest s) (first s) (assoc result (first s) []))\n          :else (recur (rest s) k (assoc result k (conj (k result) (first s)))))))", "user": "55c68089e4b0e31453f649c4"}, {"problem": 105, "code": "#(loop [f (first %) p (next %) r {} l f]\n   (if f\n   (if (keyword? f) (recur (first p) (next p) (assoc r f []) f)\n     (recur (first p) (next p) (update-in r [l] conj f) l))\n     r))", "user": "53572176e4b04ce2eb3ed276"}, {"problem": 105, "code": "#(loop [d {} xs %]\n  (let [k (first xs)\n       [v xs] (split-with number? (rest xs))]\n    (if (nil? k)\n      d\n      (recur (assoc d k v) xs))))", "user": "5416b4a2e4b01498b1a71a01"}, {"problem": 105, "code": "(fn [s]\n  (apply hash-map\n         (mapcat\n          (fn [[ks v]]\n            (concat\n             (mapcat #(vector % []) (drop-last ks))\n             [(last ks) v]))           \n          (partition 2 (partition-by keyword? s)))))", "user": "552a793ee4b0ffed3738f955"}, {"problem": 105, "code": "(fn [s]\n  (loop [left s found []]\n    (if (empty? left)\n      (into {} found)\n      (recur\n       (drop-while integer? (rest left))\n       (conj found\n             [(first left) (take-while integer? (rest left))])))))", "user": "55625903e4b0c656e3ff17d7"}, {"problem": 105, "code": "(fn [xs]\n  (letfn [(vals [xs] (take-while #(not (keyword? %)) xs))]\n  (loop [xs xs res {}]\n    (if (empty? xs)\n      res\n      (recur (rest xs) (if (keyword? (first xs)) (assoc res (first xs) (vals (rest xs))) res))))))", "user": "54e24a05e4b024c67c0cf7ce"}, {"problem": 105, "code": "(fn mapping-keyword\n  [coll]\n  (loop [[x & xs] coll res {}]\n    (if (keyword? x)\n      (recur (drop-while number? xs) \n             (conj res {x (take-while number? xs)}))\n      res)))", "user": "550d9452e4b06e50f9beb15d"}, {"problem": 105, "code": "#(zipmap (filter keyword? %)\n         (filter (comp not nil?)\n                 (reduce\n                  (fn [result [f & r :as all]]\n                    (if (keyword? f)\n                      (into result (repeat (count r) []))\n                      (conj result all)))\n                  [] (partition-by keyword? %))))", "user": "4e6a4950535d8ccf87e9febf"}, {"problem": 105, "code": "#(first (reduce\n    (fn [[m k] v]\n      (if (keyword? v) [(assoc m v []) v] [(assoc m k (conj (get m k) v)) k])\n      ) [{} 0] %)\n  )", "user": "55e1d34ae4b050e68259b421"}, {"problem": 105, "code": "(fn [col] (let [helper (apply array-map\n                   (partition-by number? \n                                 (flatten (interleave (partition-by (fn [x]\n                                                                       (if (keyword? x)\n                                                                            x\n                                                                            (number? x)))\n                                                                      col) (repeat 0)))))\n       output (clojure.set/rename-keys helper (apply array-map (interleave (keys helper) (flatten (keys helper)))))]\n    (apply hash-map \n           (interleave \n            (keys output) \n             \n             (map \n              (fn [x] (apply vector (filter #(not (= 0 %)) (val x))))\n              output))))\n              \n)", "user": "5143824ae4b0b4fb4ace5f36"}, {"problem": 105, "code": "(fn [coll]\n   (let [_coll (reduce #(if (and (keyword? (last %1)) (keyword? %2))\n                         (conj %1 nil %2)\n                         (conj %1 %2)) [] coll)]\n     (reduce #(conj % [(first (key %2)) (vec (filter (complement nil?) (val %2)))]) {}\n             (apply hash-map (partition-by keyword? _coll)))))", "user": "55a372f1e4b0acc240e31537"}, {"problem": 105, "code": "(fn merge-map \n                    ([args] (merge-map [] args))\n                    ([acc args]\n                     (if (nil? (seq args))\n                       (into {} acc)\n                       (let [new-acc (conj acc [(first args) (vec (take-while number? (rest args)))])] \n                         (recur new-acc (drop-while number? (rest args)))))))", "user": "54cad2d5e4b057c6fda3a26c"}, {"problem": 105, "code": "#(->> %\n     (reduce (fn [[ret lastkw] e] \n               (if (keyword? e)\n                   [(assoc ret e []) e]\n\t\t\t\t   [(merge-with conj ret {lastkw e}) lastkw] ))\n\t\t     [{} nil] )\n     first )", "user": "55cdc576e4b0e31453f64a1f"}, {"problem": 105, "code": "(fn to-map [[x & xs]]\n  (if x\n    (merge (hash-map x (take-while number? xs)) (to-map (drop-while number? xs)))\n    {}))", "user": "55d5e80ee4b0e31453f64a91"}, {"problem": 105, "code": "(fn [coll]\n  (loop [c coll m {}]\n    (if (empty? c) m\n      (let [k (first c)\n            [v r] (split-with number? (rest c))]\n        (recur r (assoc m k v))))))", "user": "55c20bd0e4b0e31453f64972"}, {"problem": 105, "code": "(fn [s]\n  (let [kvs (apply hash-map (partition-by keyword? s))\n        cmb (fn [[klist vlist]]\n              (let [empty-keys (butlast klist)\n                    valid-key (last klist)]\n                (conj (map #(vector % []) empty-keys)\n                      [valid-key vlist])))]\n    (into {} (mapcat cmb kvs))))", "user": "55dcb06ee4b050e68259b3b9"}, {"problem": 105, "code": "(fn [m]\n  (->> (partition-by keyword? m)\n       (apply hash-map)\n       (map #(if (> (count (first %)) 1)\n               [{(ffirst %) []} {(second (first %)) (into [] (second %))}]\n               [{(ffirst %) (into [] (first (next %)))}]))\n       (flatten)\n       (into {})))", "user": "55b22c33e4b0da326a65cf79"}, {"problem": 105, "code": "(fn [coll]\n  (loop [[k & xs] coll\n         acc\t  {}]\n    (if-not k\n      acc\n      (recur (drop-while number? xs)\n             (assoc acc k (take-while number? xs))))))", "user": "554b8572e4b0a04f79299589"}, {"problem": 105, "code": "(fn [l]\n  (loop [l l ret {} k nil]\n        (println l ret k)\n    (if (empty? l) ret\n      (if (keyword? (first l)) \n        (recur (rest l) (conj ret [(first l) []]) (first l))\n        (recur (rest l) (conj ret [k (conj (get ret k []) (first l))]) k)\n        ))))", "user": "55d74e71e4b0e31453f64aa4"}, {"problem": 105, "code": "(fn [xs]\n  (let [partitioned (partition-by #(and (keyword? %) (identity %)) xs)\n        pairs (map vector partitioned (rest partitioned))\n        relevant-pairs (filter #(->> % first first keyword?) pairs)]\n    (into {}\n          (for [[k v] relevant-pairs]\n            (if (keyword? (first v))\n              [(first k) []]\n              [(first k) (into [] v)])))))\n\n;;; moocar's much nicer solution:\n;;; (fn [coll]\n;;;   (->> (interpose nil coll)\n;;;        (partition-by keyword?)\n;;;        (map #(if (keyword? (first %)) (first %) (remove nil? %)))\n;;;        (apply hash-map)))", "user": "549dfe40e4b0f3d1d8e70f9a"}, {"problem": 105, "code": "(fn [s]\n  (reduce #(if (keyword? %2) (assoc % %2 []) (let [prev (first %)]\n                                               (assoc % (first prev) (conj (last prev) %2))))\n          (array-map) s))", "user": "55ccdc6be4b0e31453f64a18"}, {"problem": 105, "code": "#(loop [[ks vs & sequence] (partition-by keyword? %)\r\n        result (sorted-map)]\r\n   (if (not ks) result\r\n       (recur sequence\r\n              (merge result\r\n                     {(last ks) (vec vs)}\r\n                     (reduce merge\r\n                             (map (fn [x] {x []})\r\n                                  (butlast ks)))))))", "user": "55d0e76ae4b0e31453f64a40"}, {"problem": 105, "code": "#(loop [k nil x {} y %]\n   (if (empty? y) x\n     (let [[v & vs] y]\n       (if (keyword? v)\n         (recur v (conj x [v []]) vs)\n         (recur k (conj x [k (conj (x k) v)]) vs)))))", "user": "4f5eda39e4b0030a34fb2b56"}, {"problem": 105, "code": "(fn [coll]\n  (loop [coll coll k nil m {}]\n    (let [h (first coll) t (rest coll)]\n      (cond \n        (empty? coll) m\n        (keyword? h) (recur t h (assoc m h []))\n        :else (recur t k (merge-with concat m {k [h]}))))))", "user": "55ecb2c0e4b0121d4835fdce"}, {"problem": 105, "code": "(fn cons-map\n  [xs]\n  (letfn [(map-entries [xs]\n            (loop [[head & tail] xs\n                   acc []]\n              (if (nil? head) acc\n                (if (keyword? head)\n                  (recur tail (conj acc [head]))\n                  (let [last-entry (peek acc)]\n                    (recur tail (conj (pop acc) (conj last-entry head))))))))\n          (add-default-for-missing-vals-and-format-entry [xs]\n           (map #(if (= 1 (count %)) \n                   (conj % []) \n                   [(first %) (rest %)]) xs))\n          (reduce-in-map\n             [entries-seq]\n             (reduce \n                (fn [m entry] \n                  (conj m (apply hash-map entry))) \n                {} entries-seq))]\n    (-> xs\n        map-entries\n        add-default-for-missing-vals-and-format-entry\n        reduce-in-map)))", "user": "5553b729e4b0deb715856e05"}, {"problem": 105, "code": "(fn prob105 [s]\n  (loop [s s\n         prev nil\n         ret {}]\n    (if (empty? s)\n      ret\n      (let [f (first s)\n            key (if (keyword? f) f prev)\n            prev key\n            val (ret key nil)\n            ]\n        (recur (rest s) key (assoc ret key (if (keyword? f) [] (conj (ret key) f))))\n        ))))", "user": "4ebbff41535dfed6da9c6d78"}, {"problem": 105, "code": "(fn [s] (apply hash-map (mapcat #(if (keyword? (first %)) (interpose [] %) [%])\n                                (partition-by type s))))", "user": "55f20e4be4b06e875b46ce40"}, {"problem": 105, "code": "(fn [xs]\n  (loop [result {} the-list xs keyword nil]\n    (if (empty? the-list)\n      result\n      (let [the-first (first the-list)]\n        (if (keyword? the-first)\n          (recur (assoc result the-first []) (rest the-list) the-first)\n          (recur (assoc result keyword (conj (result keyword) the-first)) (rest the-list) keyword)\n        )\n      )\n    )\n  )\n)", "user": "55d79b87e4b0e31453f64aa8"}, {"problem": 105, "code": "(fn [mainseq] (if (empty? mainseq) {} (reduce merge (map (fn [aseq] (hash-map (first aseq) (vec (take-while #(not (keyword? %)) (drop 1 aseq)))))\n(take-while #(not (empty? %)) (iterate (fn [theseq] (drop-while #(not (keyword? %)) (drop 1 theseq)))\n mainseq))))))", "user": "55f75c6be4b06e875b46cea9"}, {"problem": 105, "code": "(fn [to-split]\n  (first (last (take-while\n                (fn [x]\n                  (not (nth x 2)))\n                (iterate (fn [[acc rest done]]\n                           (let [[k krest] (split-with keyword?\n                                                       rest)\n                                 [vals vrest] (split-with (complement keyword?)\n                                                          krest)\n                                 klen (count k)\n                                 ndone (zero? (count rest))]\n                             (if (> klen 1)\n                               (let [emptiks (into {}\n                                                   (vec (map (fn [x y]\n                                                               [x y])\n                                                             (butlast k)\n                                                             (repeat []))))\n                                     acc-e-k (merge acc\n                                                    emptiks)\n                                     all (conj acc-e-k [(last k) (vec vals)])]\n                                 [all\n                                  vrest\n                                  ndone])\n                               [(conj acc [(first k) (vec vals)])\n                                vrest\n                                ndone])))\n                         [{}\n                          to-split\n                          false])))))", "user": "50981062e4b04e098a4c7268"}, {"problem": 105, "code": "(fn [coll]\n  (loop [k [(first coll)] v [] r [] c (rest coll)]\n\t(if (nil? (first c))\n      (if (nil? (k 0))\n        {}\n        (zipmap k (conj v r)))\t \n\t  (if (keyword? (first c))\n        (recur (conj k (first c)) (conj v r) [] (rest c))\n        (recur k v (conj r (first c)) (rest c))))))", "user": "53573d70e4b04ce2eb3ed278"}, {"problem": 105, "code": "(fn __\n  [coll]\n  (loop [x coll\n         last-key (first coll)\n         result {}]\n    (if (empty? x)\n      result\n\t    (let [item (first x)]\n\t\t    (if (keyword? item)\n\t\t      (recur (rest x) item (assoc result item []))\n\t        (recur (rest x) last-key (assoc result last-key (conj (result last-key) item))))))))", "user": "55a62092e4b0acc240e31554"}, {"problem": 105, "code": "(fn [input]\n  (letfn [(kv-iter [coll in]\n            (if (empty? in) coll\n                (let [key (first in)\n                      not-kw (complement keyword?)\n                      rst-in (rest in)\n                      values (take-while not-kw rst-in)\n                      rst (drop-while not-kw rst-in)]\n                  (recur (assoc coll key values) rst))))]\n    (kv-iter {} input)))", "user": "52fc34cee4b047fd55837015"}, {"problem": 105, "code": "(fn [coll]\n  (->> coll\n       (partition-by keyword?)\n       (partition 2)\n       (map (fn [[ks vs]]\n              (concat (for [k (butlast ks)]\n                        {k []})\n                      [{(last ks) (vec vs)}])))\n       flatten\n       (apply merge {})))", "user": "55f2e47de4b06e875b46ce4d"}, {"problem": 105, "code": "(fn f [[h & t]]\n  (if (seq t)\n    (let [[x y] (split-with (complement keyword?) t)]\n      (merge {h x} (f y)))\n    {}))", "user": "548b8a50e4b0e286459a11ff"}, {"problem": 105, "code": "(fn [coll]\n  (letfn [(step [c]\n            (if (> (count c) 1)\n              (let [key-size (count (first c))]\n                (if (= key-size 1)\n                  (concat [(first (first c)) (vec (second c))] (step (drop 2 c)))\n                  (concat [(first (first c)) []] (step (cons (rest (first c)) (rest c))))))))]\n    (let [vec-result (step (partition-by keyword? coll))]\n      (if (seq vec-result)\n        (apply (partial assoc {}) vec-result)\n        {}))))", "user": "55e6c3f5e4b050e68259b48c"}, {"problem": 105, "code": "(fn [xs]\n    (into {}\n          (reduce (fn [acc x]\n                    (cond\n                      (keyword? x) (conj acc [x []])\n                      :else (conj (pop acc)\n                                  (vector (first (peek acc))\n                                          (conj (second (peek acc)) x)))))\n                  []\n                  xs)))", "user": "560e9a2de4b05f002753df52"}, {"problem": 105, "code": "(fn [v]\n   (loop [remaining v outmap {}]\n     (let [k (first remaining) n (take-while number? (rest remaining))]\n       (if k\n         (recur (drop-while number? (rest remaining))\n                (assoc outmap k (vec n)))\n         outmap))))", "user": "55f8b32ae4b03cbcff9738ba"}, {"problem": 105, "code": "(fn [l]\n  (if (empty? l)\n    {}\n    (loop [m (rest l)\n           k (first l) ; must be keyword\n           v []\n           r {}]\n      (if (empty? m)\n        (conj r [k v])\n        (if (keyword? (first m))\n          (recur (rest m) (first m) [] (conj r [k v]))\n          (recur (rest m) k (conj v (first m)) r))))))", "user": "56051095e4b08b23635d3162"}, {"problem": 105, "code": "(fn [coll]\n  (apply hash-map\n   (loop [result [] [kw & rst :as coll] coll]\n     (if (empty? coll)\n       result\n       (let [[values rst'] (split-with (complement keyword?) rst)]\n         (recur (concat result [kw values]) rst'))))))", "user": "561ca2eae4b064ca9f4b169b"}, {"problem": 105, "code": "(fn [aseq]\n  (->> (partition-by keyword? aseq)\n       (partition-all 2)\n       (mapcat (fn [[ks vs]]\n                 (concat (interpose () ks) [(sequence vs)])))\n       (apply hash-map)))", "user": "53576356e4b04ce2eb3ed27a"}, {"problem": 105, "code": "(fn [m]\n   (->> m\n        (interpose [])\n        (partition-by keyword?)\n        (partition 2)\n        (map flatten)\n        (map #(hash-map (first %) (vec (drop 1 %))))\n        (into {})))", "user": "4f40c46fe4b0e243712b1fbe"}, {"problem": 105, "code": "(let [notkeyword (complement keyword?)]\n  (fn [[head & tail]]\n    (into {}\n          (loop [rv [] k head v tail]\n            (if (nil? k)\n              rv\n              (let [values (take-while notkeyword v)\n                    next' (drop-while notkeyword v)\n                    nextk (first next')\n                    nextv (rest next')]\n                (recur (conj rv [k values]) nextk nextv)))))))", "user": "561ba3e5e4b073c65b0ce3eb"}, {"problem": 105, "code": "(fn kvs\n  ([c] (kvs c {} nil))\n  ([c acc currentKey]\n   (let [e (first c) r (rest c)]\n     (cond\n       (empty? c) acc\n       (keyword? e) (kvs r (assoc acc e []) e)\n       true (kvs r (assoc acc currentKey (conj (acc currentKey) e)) currentKey)\n       )\n     )))", "user": "55f2c898e4b06e875b46ce4b"}, {"problem": 105, "code": "(fn [xs]\n    (into {} (reduce (fn [a x] (if (keyword? x)\n                                 (cons  [x []] a)\n                                 (cons [(first (first a))\n                                        (conj (second (first a)) x)]\n                                       (rest a))))\n                     []\n                     xs))\n\n    )", "user": "4f5e5975e4b0030a34fb2b4d"}, {"problem": 105, "code": "(fn [xs]\n  (reduce (fn [a x] \n    (if (keyword? x) \n      (assoc a x []) \n      (update-in a [(-> a last first)] conj x))) \n  (sorted-map) xs))", "user": "55fee5e4e4b00f4cabc5765a"}, {"problem": 105, "code": "(fn [coll]\n  (loop [m {}\n         coll coll\n         x (first coll)\n         k nil]\n    (if (nil? x)\n      m\n      (if (keyword? x)\n        (recur (assoc m x []) (rest coll) (second coll) x)\n        (recur (update-in m [k] conj x) (rest coll) (second coll) k)))))", "user": "55ed1575e4b0121d4835fdd3"}, {"problem": 105, "code": "(fn mapMaker[l]\n  (if (empty? l)\n    {}\n    (second (reduce (fn [[keyw m] el]\n              (if (keyword? el)\n                [el (conj m [el []])]\n                [keyw (update-in m [keyw] #(conj % el))]))\n            [:a {}]\n            l))))", "user": "5626447fe4b00e49c7cb47bd"}, {"problem": 105, "code": "(fn[a]\n   (loop [a a r {} l (first a)]\n     (cond (empty? a) r\n           (keyword? (first a)) (recur (rest a) (assoc r (first a) []) (first a))\n            :else (recur (rest a) (assoc r l (conj (get r l []) (first a))) l)\n     )\n  ) \n)", "user": "55eeb37ae4b0121d4835fdf3"}, {"problem": 105, "code": "(fn p105 [v]\n  (dissoc (reduce (fn [acc x]\n                    (if (keyword? x)\n                      (assoc acc x [] :current x)\n                      (let [key (acc :current)]\n                        (assoc acc key (conj (acc key) x))))) {} v) :current))", "user": "561d23e3e4b064ca9f4b16a5"}, {"problem": 105, "code": "(fn [l]\n    (into\n      {}\n      ((fn [a [k & vs]]\n         (if (nil? k)\n           a\n           (if (empty? vs)\n             (conj a [k []])\n             (recur (conj a [k\n                             (apply vector\n                                    (take-while (comp not keyword?) vs))\n                             ])\n                    (drop-while (comp not keyword?) vs))\n             )\n           )\n         )\n       [] l)\n      )\n    )", "user": "559a9a3de4b066d22e731f45"}, {"problem": 105, "code": "#(into {} (loop [[v & S] % k nil V [] R '()] (cond (not v) (if k (cons [k V] R) R) (keyword? v) (recur S v [] (if k (cons [k V] R) R)) :else (recur S k (conj V v) R))))", "user": "55f6fe09e4b06e875b46cea2"}, {"problem": 105, "code": "(fn [se]\n    (->> (map #(if (= (class %) clojure.lang.Keyword) [:key %] %) se)\n         flatten\n         (partition-by #(= % :key))\n         (remove #{(list :key)})\n         (map (fn [[k & v]] [k (or v [])]))\n         (into {})))", "user": "56018dd4e4b04bb52996e18f"}, {"problem": 105, "code": "(fn key-vals [xs]\n  (->>\n      (reduce #(if (keyword? %2)\n                 (conj %1 [%2 []])\n                 (let [u (last %1)]\n                   (conj (vec (drop-last 1 %1)) [(first u) (conj (second u) %2)])))\n              [] xs)\n      (into {})))", "user": "4f6ba7bce4b07046d9f4efb0"}, {"problem": 105, "code": "(fn [xs]\n  (first\n    (reduce\n      (fn [[m k] x]\n        (if (keyword? x)\n          [(assoc m x []) x]\n          [(update-in m [k] conj x) k]))\n      [{}]\n      xs)))", "user": "562cd94ee4b0a45d2ff83015"}, {"problem": 105, "code": "(fn [s] (->>(partition-by keyword? s)\n            (mapcat #(if % (interpose [] %2) [%2]) (cycle [true false]))\n            (apply hash-map)))", "user": "5603c31fe4b04bb52996e1c1"}, {"problem": 105, "code": "(fn [x] \n    (loop [old x, new {}]\n     (if (empty? old) new\n       (let [lk (first old)\n             v (vec (take-while #(not (keyword? %)) (rest old)))]   \n         (recur (drop (+ 1 (count v)) old) (assoc new lk v))))))", "user": "54b54d1be4b05787c3b1639c"}, {"problem": 105, "code": "(fn ik [coll]\n  (if (empty? coll)\n    {}\n    (loop [c coll r {} k nil]\n      (if (empty? c)\n        r\n        (recur \n          (rest c) \n          (if (keyword? (first c)) (assoc r (first c) []) (update-in r [k] conj (first c))) \n          (if (keyword? (first c)) (first c) k))))))", "user": "561a1af6e4b053970a773b02"}, {"problem": 105, "code": "(fn [coll] (loop [coll coll\n                   m {}]\n              (if (empty? coll)\n                m\n                (let [k (first coll)\n                      [v new-coll] (split-with #(not (keyword? %)) (rest coll))]\n                (recur \n                 new-coll\n                 (assoc m k v))))))", "user": "54db3d82e4b024c67c0cf75f"}, {"problem": 105, "code": "(fn [coll]\n  (apply hash-map\n         (mapcat #(let [[k v] %] \n                    (concat \n                     (vec \n                      (mapcat (fn [empty-key] (list empty-key [])) \n                              (butlast k))) \n                     (list (last k) v))) \n                 (partition 2 \n                            (partition-by keyword? coll)))))", "user": "53286f84e4b09d4e7a9b5505"}, {"problem": 105, "code": "(fn\n  [coll]\n  (loop [result {} coll coll]\n    (if (empty? coll)\n      result\n      (let [key (first coll)\n            values (take-while number? (rest coll))\n            remaining (drop-while number? (rest coll))\n            ]\n        (recur (conj result [key values]) remaining)\n        )\n      )\n    )\n  )", "user": "563a30d7e4b0bfe05bf117f9"}, {"problem": 105, "code": "(fn identify [s]\n  (let [split-list\n        (partition-by #(if (not (number? %)) % false) s)\n        construct-map\n        (fn construct-map [l]\n          (if (empty? l)\n            {}\n            (if (not (number? (first (second l))))\n              (assoc (construct-map (rest l)) (first (first l)) '[])\n              (assoc (construct-map (drop 2 l)) (first (first l)) (second l))\n            )\n          )\n        )\n        ]\n    (construct-map split-list)\n  \n))", "user": "56393681e4b0bfe05bf117f2"}, {"problem": 105, "code": "(fn [s]\n  (first \n   (let [sp (partition-by (fn [v] (if (keyword? v) v false)) s)]\n     (reduce (fn [[r kw] ss]\n               (let [kw-ss (first ss)]\n                 (if (keyword? kw-ss)\n                   (if (nil? kw)\n                     [r kw-ss]\n                     [(merge r {kw []}) kw-ss])\n                   [(merge r {kw ss}) nil]))) \n             [{} nil] sp))))", "user": "4f0f01c0535d0136e6c22329"}, {"problem": 105, "code": "(fn keyword-nums\n  [s]\n  (loop [result {}\n         remaining (drop-while number? s)]\n    (if (empty? remaining)\n      result\n      (recur (assoc result (first remaining)\n                           (take-while number? (rest remaining)))\n             (drop-while number? (rest remaining))))))", "user": "563f1493e4b08d4f616f5ecf"}, {"problem": 105, "code": "(fn [x]\n  (loop [r {}, c :d, [i & rst] x]\n    (if (nil? i) r\n      (if (keyword? i)\n        (recur (assoc-in r [i] []) i rst)\n        (recur (update-in r [c] #(conj % i))\n               c rst)))))", "user": "5492164ee4b0b312c081ff3e"}, {"problem": 105, "code": "(fn process [kvs]\n         \n    (if (empty? kvs) {}\n        (let [ k (first kvs)\n               v (take-while number? (rest kvs))\n               n (drop-while number? (rest kvs))]\n          \n          (assoc (process n) k v))))", "user": "564127a9e4b08d4f616f5ef3"}, {"problem": 105, "code": "(fn [[k & xs]]\n   (if (nil? k)\n     {}\n     (->> xs\n          (reduce\n           (fn [[acc cur-key] x]\n             (if (= (type x) (type :a-key))\n               [(conj acc [x []]) x]\n               [(conj acc [cur-key (conj (acc cur-key) x)]) cur-key]))\n           [{k []} k])\n          first)))", "user": "563772a9e4b0bfe05bf117d7"}, {"problem": 105, "code": "(fn keys-vals\n  [coll]\n  (loop [result {}\n         coll coll]\n    (if (empty? coll)\n      result\n      (let [head (first coll)]\n        (recur (conj result [head (take-while integer? (rest coll))])\n               (drop-while integer? (rest coll)))))))", "user": "4fc524aae4b081705acca37e"}, {"problem": 105, "code": "(fn v-to-map\n  [v]\n  (reduce\n   #(if (keyword? %2)\n      (assoc %1 %2 [])\n      (assoc %1 (first (last %1)) (conj (second (last %1)) %2)))\n   (cons (sorted-map) v)))", "user": "55a9e0fee4b0988bba2ad945"}, {"problem": 105, "code": "(fn [coll]\n   (if (empty? coll)\n     {}\n     (loop [out {}\n            x coll]\n       (if (empty? x)\n       out\n       (recur (conj out (hash-map (first x) (into [] (take-while number? (rest x)))))\n              (drop (+ 1 (count (take-while number? (rest x)))) x))))))", "user": "5633bb9de4b0bfe05bf117b4"}, {"problem": 105, "code": "(fn map-seq [ls]\n  (let [key? #(= (type %) clojure.lang.Keyword)]\n  (if (empty? ls) \n    {}\n    (merge\n     {(first ls) (take-while #(not (key? %)) (rest ls))}\n     (map-seq (drop-while #(not (key?%)) (rest ls)))))))", "user": "541ef7e2e4b01498b1a71a92"}, {"problem": 105, "code": "(fn [coll]\n  (loop [s coll the-map {}]\n    (if (empty? s)\n      the-map\n      (let [[k & rest] s\n            [value argument] (split-with number? rest)]\n        (recur argument (assoc the-map k value) )\n        )))\n  )", "user": "5564709ee4b0c656e3ff1807"}, {"problem": 105, "code": "(fn [y]\n  (second (reduce\n            (fn [[l m] x]\n              (if (keyword? x)\n                [x (assoc m x [])]\n                [l (update-in m [l] #(conj % x))]))\n            [nil {}] y)))", "user": "5382704be4b06839e8705ed4"}, {"problem": 105, "code": "(fn [c]\n         (if (seq c)\n           (loop [r {(first c) []} curr (first c) next (second c) cl (drop 2 c)]\n             (if (nil? next)\n               r\n               (if (keyword? next)\n                 (recur (assoc r next []) next (first cl) (rest cl))\n                 (recur (conj r {curr (conj (curr r) next)}) curr (first cl) (rest cl)))))\n           {}))", "user": "564b1ff8e4b0284900eef663"}, {"problem": 105, "code": "(fn [coll]\n  (dissoc (reduce (fn [res cur]\n                    (if (keyword? cur)\n                      (assoc res cur [] :last cur)\n                      (assoc res (:last res) (conj ((:last res) res) cur))))\n                  {} coll)\n          :last))", "user": "562cb7cfe4b0a45d2ff83009"}, {"problem": 105, "code": "(fn [s]\n  (second\n   (reduce (fn [[lst m] e]\n             (if (keyword? e)\n               (if-let [vs (m e)]\n                 [e m]\n                 [e (assoc m e [])])\n               ;; not a kw\n               [lst (assoc m lst (conj (m lst) e))]))\n           [nil {}] s)))", "user": "54ca93abe4b057c6fda3a264"}, {"problem": 105, "code": "(fn [S]\n  (let[K (filter keyword? S) eK (zipmap K (repeat (count K) []))\n  M (apply hash-map (map  #(if (keyword? (first %)) (last %) %)(partition-by keyword? S)))]\n       (merge eK M)\n       \n ))", "user": "5649615be4b0284900eef641"}, {"problem": 105, "code": "(fn [arg1]\n(cond\n(and (= arg1 [])) {}\n(and (= arg1 [:a 1])) {:a [1]}\n(and (= arg1 [:a 1 :b 2])) {:a [1], :b [2]}\n(and (= arg1 [:a 1 2 3 :b :c 4])) {:a [1 2 3], :b [], :c [4]}\n))", "user": "565f2461e4b068f2fe63dc3b"}, {"problem": 105, "code": "(fn [x] (reduce #(if (keyword? %2) \n                                (conj %1 [%2 []])\n                                (let [key (first (keys %1))\n                                      value (get %1 key)]\n                                  (conj (dissoc %1 key) [key (conj value %2)]))) \n                              {} x))", "user": "5654cb2de4b0f9d632dd848b"}, {"problem": 105, "code": "(fn [v]\n  (apply\n   hash-map\n   (reduce\n    #(if\n      (keyword? %2)\n      (conj %1 %2 [])\n      (let [i (dec (count %1))]\n        (assoc-in\n         %1\n         [i (count (get %1 i))]\n         %2)))\n    []\n    v)))", "user": "532ecd44e4b019098a6f8b49"}, {"problem": 105, "code": "(fn [s]\n           (->>\n            s\n            (partition-by #(if (keyword? %) (gensym) false))\n            (partition 2 1)\n            (filter #(keyword? (first (first %))))\n            (map (fn [[[x & xs] & [y & ys]]] [x y]))\n            (map (fn [[x & [[y & yt :as ys]]]] (if (number? y) [x ys] [x []])))\n            (into {})\n            ))", "user": "55f09e7be4b06e875b46ce28"}, {"problem": 105, "code": "(fn [arg1]\n(cond\n(and (= arg1 [])) {}\n(and (= arg1 [:a 1])) {:a [1]}\n(and (= arg1 [:a 1 :b 2])) {:a [1], :b [2]}\n(and (= arg1 [:a 1 2 3 :b :c 4])) {:a [1 2 3], :b [], :c [4]}\n))", "user": "5666bf34e4b04acd4f672dc2"}, {"problem": 105, "code": "#(:data\n  (reduce\n   (fn [{:keys [current data]}  i]\n     (if (keyword? i)\n       {:current i       :data (merge data {i []})}\n       {:current current :data (merge-with conj data {current i})}))\n   {:data {}}\n   %))", "user": "52f0ea04e4b05e3f0be25ee6"}, {"problem": 105, "code": "(fn [v]\n  (loop [ansm {}\n         k nil\n         vc v\n         ]\n    (if (empty? vc)\n      ansm\n      (if (keyword? (first vc))\n        (recur (assoc ansm (first vc) [])\n               (first vc)\n               (rest vc))\n        (recur (assoc ansm k (conj (get ansm k) (first vc)))\n               k\n               (rest vc))\n         ))))", "user": "5632d1b3e4b0bfe05bf117a9"}, {"problem": 105, "code": "(fn [coll]\n  (letfn [(pair-up [[x1 x2 & xs]]\n            (when-not (nil? x1) nil\n                      (if (coll? x2)\n                        (conj (pair-up xs) [x1 x2])\n                        (conj (pair-up (conj xs x2)) [x1 []]))))]\n    (->> (partition-by #(if (keyword? %) % (type %)) coll)\n         (map #(if (keyword? (first %)) (first %) (apply vector %)))\n         pair-up\n         (into {}))))", "user": "5666500ee4b0e91d5f5c566d"}, {"problem": 105, "code": "(fn [s]\n  (first (reduce \n          #(if\n            (keyword? %2)\n             [(assoc (first %) %2 []) %2]\n             [(assoc (first %) (second %) (conj ((first %) (second %)) %2)) (second %)])            \n          [{} nil]\n          s)))", "user": "563dfc02e4b0da801c4e4662"}, {"problem": 105, "code": "(partial\n (fn [out [x & xs]]\n   (if x\n     (let [[col res] (split-with #(not (keyword? %)) xs)]\n       (recur (assoc out x col) res))\n     out))\n {})", "user": "54c5cc17e4b045293a27f624"}, {"problem": 105, "code": "(fn [coll]\n  (->> coll\n       (reduce\n         (fn fold-seq-into-map [[map last-keyword] next-value]\n           (if (keyword? next-value)\n             [(assoc map next-value []) next-value]\n             [(update-in map [last-keyword] #(conj % next-value)) last-keyword]))\n         [{} nil])\n       (first)))", "user": "55d28b38e4b0e31453f64a58"}, {"problem": 105, "code": "(fn [xs]\n  (loop [m {}\n         xs xs]\n    (let [k (first xs)\n          xs (next xs)]\n      (if k\n        (recur (assoc m k (vec (take-while number? xs)))\n               (drop-while number? xs))\n        m))))", "user": "56706f01e4b0a866af6896f2"}, {"problem": 105, "code": "(fn [kvs]\n   (let [[d kw vc]\n         (reduce (fn [[daddy-map kw val-cache] v]\n                   (cond\n                    (number? v) [daddy-map kw (conj val-cache v)]\n                    kw [(assoc daddy-map kw val-cache) v []]\n                    :else [daddy-map v []]))\n                 [{} nil []]\n                 kvs)]\n     ;need to tidy up because the last value won't be popped\n     ;thinking about it I could make this clean by continually \n     ;writing into daddy-map instead of on next kw but too tired\n     (if kw (assoc d kw vc) {})))", "user": "567476bde4b05957ce8c6139"}, {"problem": 105, "code": "(fn [coll]\n  (loop [coll coll res {}]\n    (if (empty? coll)\n      res\n      (let [k (first coll)\n            r (rest coll)\n            [nums r] (split-with number? r)]\n        (recur r (assoc res k (into [] nums)))))))", "user": "5591cc56e4b0604b3f94d582"}, {"problem": 105, "code": "(fn [xs]\n  (into {}\n        (reduce\n         (fn [coll n]\n           (let [\n                 last-elem (vec (last coll))           \n                 my-sq (vec (take (dec (count coll)) coll))\n                 ]\n             (if (keyword? n)\n               (conj coll  [n []] )\n               (conj my-sq [(first last-elem) (conj  (last last-elem) n)]))\n             )\n           )\n         []\n         xs\n         )))", "user": "564a560ae4b0284900eef654"}, {"problem": 105, "code": "(fn i [c]\n  (into {}\n    (if (empty? c)\n      nil\n      (let [[k r] [(when (keyword? (nth c 0))\n                     (nth c 0))\n                   (rest c)]\n            [v r] (split-with (complement keyword) r)]\n          (assoc (i r) k v)))))", "user": "52bacfa8e4b07a9af57922d6"}, {"problem": 105, "code": "(fn tomap [s]\n  (first \n   (reduce\n    (fn [[m k] x]\n      (if (keyword? x)\n        [(assoc m x []) x]\n        [(assoc m k (conj (m k) x)) k]))\n    [{}]\n    s)))", "user": "5654e024e4b0f9d632dd848d"}, {"problem": 105, "code": "(fn kv\n  ([x] (kv {} nil x))\n  ([m last-key x] \n    (if (seq x)\n      (if (keyword? (first x)) \n        (kv (assoc m (first x) []) (first x) (rest x)) ; new key\n        (kv (assoc m last-key (conj (m last-key) (first x))) last-key (rest x)) ) ; value\n      m)))", "user": "550e52dbe4b06e50f9beb165"}, {"problem": 105, "code": "(fn [coll]\n(->>\n  (partition-by keyword? coll)\n  (reduce\n    (fn [a b]\n      (cond\n        (= 1 (count b)) (conj a\n                              (let [v (first b)]\n                                (if (keyword? v) v [v])))\n        (every? keyword? b) (apply (partial conj a) (interpose [] b))\n        :else (conj a (into [] b)))) [])\n  (partition 2)\n  (map #(into [] %))\n  (into {})\n))", "user": "536ecd9fe4b0fc7073fd6e76"}, {"problem": 105, "code": "(fn [c] \n  (reduce (fn [acc [k v]] (merge (conj acc [(last k) v]) (zipmap (butlast k) (repeat [])))) \n          {} \n          (partition 2 (partition-by keyword? c))))", "user": "554680cbe4b0a04f7929953e"}, {"problem": 105, "code": "(fn [coll]\n  (letfn [(number? [x] (instance? Number x))]\n    (loop [orig coll, result {}]\n      (if (empty? orig)\n          result\n          (let [k (first orig),\n                v (take-while number? (rest orig))]\n            (recur (drop-while number? (rest orig)) (assoc result k v)))))))", "user": "567695c2e4b05957ce8c6157"}, {"problem": 105, "code": "(fn kv [acc k [v & vs]]\n  (cond (nil? v) acc\n        (keyword? v) (kv (assoc acc v []) v vs)\n        :e (kv (update-in acc [k] conj v) k vs))) {} *", "user": "56810479e4b0966858e4d8f8"}, {"problem": 105, "code": "(fn f\n  ([c] (f {} c))\n  ([m [k & t]]\n    (if k\n      (let [[a b] (split-with number? t)]\n        (f (assoc m k a) b))\n      m)))", "user": "4faf97d8e4b081705acca258"}, {"problem": 105, "code": "(fn to-keys [items]\n  (let [pairs (partition 2 (partition-by keyword? items))]\n    (into {} (mapcat (fn [[keys v]]\n                       (conj (map #(vector % '()) (butlast keys))\n                             (vector (last keys) v)))\n                     pairs))))", "user": "56897739e4b0dcc4269f407d"}, {"problem": 105, "code": "(fn [s]\n    (into\n     {}\n     (mapcat\n      identity\n      (for [[ks v] (partition 2 (partition-by keyword? s))]\n        (conj\n         (for [k (butlast ks)] [k []])\n         [(last ks) v])))))", "user": "5275f7a2e4b03e8d9a4a74d0"}, {"problem": 105, "code": "(fn q4q105 [s]\n  ((fn inner-q4q105 [s-i k m]\n     (if (empty? s-i)\n       m\n       (recur \n        (rest s-i) \n        (if (keyword? (first s-i))\n          (first s-i)\n          k)\n        (if (keyword? (first s-i))\n          (assoc m (first s-i) [])\n          (assoc m k (conj (get m k) (first s-i)) ) ))))\n   s nil {}))", "user": "52213426e4b0e6a83c8925c4"}, {"problem": 105, "code": "(fn [v]\n  (loop [coll v\n         m {}]\n    (if (empty? coll)\n      m\n      (let\n        [[k & rst] coll\n         [vs coll2]\n           (split-with\n             (complement\n               keyword?)\n             rst)\n         m2 (assoc m k vs)]\n        (recur coll2 m2)))))", "user": "55d2dd27e4b0e31453f64a5b"}, {"problem": 105, "code": "(fn [xs]\n  (if (empty? xs)\n    {}\n    (loop [out {} kw (first xs) vs [] in (rest xs)]\n      (if (empty? in)\n        (assoc out kw vs)\n        (let [nxt (first in)]\n          (if (keyword? nxt)\n            (recur (assoc out kw vs) nxt [] (rest in))\n            (recur out kw (conj vs nxt) (rest in))))))))", "user": "564a5a09e4b0284900eef656"}, {"problem": 105, "code": "(fn [coll]\n  (into {}\n    (for [x coll\n          :let [newc (drop 1 (drop-while #(not= % x) coll))]\n          :when (keyword? x)]\n          {x (into [] \n  (take-while #(not (keyword? %)) newc))})))", "user": "567d18c9e4b05957ce8c61c4"}, {"problem": 105, "code": "#(loop [seen {} xs  % prev-key nil]\n  (cond\n    (empty? xs) seen\n    (keyword? (first xs)) (recur (assoc seen (first xs) []) (rest xs) (first xs))\n    :else (recur (update-in seen [prev-key] conj (first xs)) (rest xs) prev-key)))", "user": "5657fed1e4b0f9d632dd84ae"}, {"problem": 105, "code": "(fn fm\n        ([l] (fm l {}))\n        ([l m] (if (empty? l) m (fm (rest l) m (first l) [])))\n        ([l m k vs] (if (or (empty? l) (keyword? (first l)))\n                      (fm l (assoc m k vs))\n                      (fm (rest l) m k (conj vs (first l))))))", "user": "544e6b7fe4b0e39780006986"}, {"problem": 105, "code": "(fn [s]\n  (loop [i 0 result {} v [] k nil]\n    (cond (and (= i (count s)) (not (nil? k))) \n            (assoc result k v)\n          (and (= i (count s)) (nil? k))\n            result\n          (and (keyword? (nth s i)) (not (nil? k)))\n            (recur (inc i) (assoc result k v) [] (nth s i))\n          (and (keyword? (nth s i)) (nil? k))\n            (recur (inc i) result [] (nth s i))\n          :else\n            (recur (inc i) result (conj v (nth s i)) k)\n          )))", "user": "56288ccae4b00e49c7cb47ea"}, {"problem": 105, "code": "(fn [s]\n  (dissoc (reduce (fn [map next]\n                    (if (keyword? next)\n                      (assoc map next [] :last next)\n                      (assoc map (:last map) (conj ((:last map) map) next))))\n                  {}\n                  s) :last))", "user": "55f85b93e4b03cbcff9738ae"}, {"problem": 105, "code": "(fn k-v [x]\n\t(loop [rst x current-key nil result {}]\n\t\t(if (empty? rst) result\n\t\t\t(if (-> rst first class (= clojure.lang.Keyword)) \n\t\t\t\t(recur (rest rst) (first rst) (assoc result (first rst) []))\n\t\t\t\t(recur (rest rst) current-key (assoc result current-key (conj (result current-key) (first rst))))))))", "user": "56540485e4b0f9d632dd847a"}, {"problem": 105, "code": "(fn f [[x & q]] \n  (if x\n      (let [[v r] (split-with number? q)]\n        (assoc (f r) x v))\n      {}))", "user": "53b15e6ee4b047364c04448f"}, {"problem": 105, "code": "(fn mapify [v]\n  (if (empty? v)\n    {}\n    (let [k (first v) r (rest v)]\n      (conj {k (take-while number? r)} (mapify (drop-while number? r)))\n      )\n    )\n  )", "user": "56979bb7e4b0e0b3d3318cac"}, {"problem": 105, "code": "(fn F [l]\n  (if (and l (not (= l ())))\n    (let [t (split-with #(not (keyword? %)) (next l))]\n      (conj (F (second t)) [(first l) (first t)]))\n    {}))", "user": "567b39b6e4b05957ce8c61a3"}, {"problem": 105, "code": "(fn identify-keys-and-values [coll]\n  (->>\n   (reduce #(if (and (keyword? (last %))\n                     (keyword? %2))\n              (conj % nil %2)\n              (conj % %2)) [] coll)\n   (partition-by keyword?)\n   (map #(cond\n           (keyword? (first %)) (first %)\n           (nil? (first %)) []\n           :else (into [] %)))\n   (apply hash-map)))", "user": "5693a53ee4b0dcc4269f4106"}, {"problem": 105, "code": "(fn [coll]\n  (if (empty? coll)\n    {}\n    (loop [acc {}\n           is []\n           k (first coll)\n           [x & xs] (rest coll)]\n      (if-not x\n        (assoc acc k is)\n        (if (keyword? x)\n          (recur (assoc acc k is) [] x xs)\n          (recur acc (conj is x) k xs))))))", "user": "54d9f7f1e4b024c67c0cf751"}, {"problem": 105, "code": "#((reduce (fn [[a k] e]\n              (if (number? e)\n                  [(assoc a k (conj (a k) e)) k]\n                  [(assoc a e []) e]))\n              [{}]\n              %) 0)", "user": "505106fee4b05ab4c7e07d38"}, {"problem": 105, "code": "#(let [r (fn [m v]\n            (if (number? v)\n              (update-in m [:r (:k m)] conj v)\n              (-> m\n                  (assoc :k v)\n                  (assoc-in [:r v] []))))]\n    (:r (reduce r {:r {}} %)))", "user": "50ec409ce4b04edc33777045"}, {"problem": 105, "code": "(fn [s]\n  (loop [acc {}\n         k nil\n         s s]\n    (cond \n     (empty? s) acc\n     (keyword? (first s)) (recur (assoc acc (first s) []) (first s) (rest s))\n     (number?  (first s)) (recur (update-in acc [k] conj (first s))  k (rest s)))))", "user": "553b0d95e4b09218d5f44fff"}, {"problem": 105, "code": "(fn conv [s]\n  (reduce (fn [r [k v]]\n            (assoc (into r (zipmap k (repeat []))) (last k) v)) {}\n          (partition 2 (partition-by keyword? s))))", "user": "56874171e4b0dcc4269f405c"}, {"problem": 105, "code": "(fn [sq]\n\t(loop [m {} c (first sq) s (rest sq) k nil]\n\t\t(if (nil? c)\n\t\t\tm\n\t\t\t(cond \n\t\t\t\t(keyword? c) (recur (merge m {c []}) (first s) (rest s) c)\n\t\t\t\t(number? c) (recur (assoc m k (conj (m k) c)) (first s) (rest s) k)))))", "user": "5578f292e4b05c286339e08f"}, {"problem": 105, "code": "(fn solve [s]\n  (letfn\n      [(iter [result left]\n         (cond\n          (empty? left) result\n          (keyword? (first left)) (iter (assoc result (first left) (take-while number? (rest left)))\n                                        (drop-while number? (rest left)))))]\n    (iter {} s)))", "user": "56444fb1e4b0018b46ad8c0c"}, {"problem": 105, "code": "(fn [x] (let [xp (partition 2 1(partition-by #(if (keyword? %) % nil) x))]\n           (reduce #(cond\n                      (every? keyword? (flatten %2)) (assoc %1 (ffirst %2) [])\n                      (keyword? (ffirst %2))(assoc %1 (ffirst %2) (into [](first(rest %2))))\n                      :else %1)\n                   {} xp)))", "user": "566a3a26e4b0a866af689699"}, {"problem": 105, "code": "(fn [coll]\n  (loop [prev nil c coll r {}]\n    (if (empty? c)\n      r\n      (let [a (first c)]\n        (if (integer? a)\n          (recur prev (rest c) (update-in r [prev] conj a))\n          (recur a (rest c) (assoc-in r [a] [])))))))", "user": "56588f4ee4b0f9d632dd84b6"}, {"problem": 105, "code": "#(apply hash-map (reduce (fn [s i] (if (keyword? i) (conj s i []) (let [p (peek s)] (conj (pop s) (conj p i))))) [] %))", "user": "56824e1be4b0945ebc182a91"}, {"problem": 105, "code": "(fn [coll]\n  (loop [[f & r] coll\n         xs {}]\n    (if f\n      (let [[ns k] (split-with number? r)]\n        (recur k\n               (merge-with concat xs {f ns})))\n      xs)))", "user": "554bd33ce4b0a04f7929959a"}, {"problem": 105, "code": "(fn [s]\n  (loop [built {} curr-k (first s) curr-v [] left (rest s)]\n    (if (empty? left) (if (empty? curr-v) built (assoc built curr-k curr-v))      \n      (if (keyword? (first left))\n        (recur (assoc built curr-k curr-v) (first left) [] (rest left))\n        (recur built curr-k (conj curr-v (first left)) (rest left))))))", "user": "56bb9ccce4b0f26550335959"}, {"problem": 105, "code": "(fn gen-map\n  [v]\n  (reduce (fn [m c]\n            (let [subv (subvec v (first c) (second c))]\n              (assoc m (first subv) (rest subv)))) {} (partition\n                 2 1 (concat (keep-indexed\n                               #(when (keyword? %2) %1) v) [(count v)]))))", "user": "56a36f76e4b0542e1f8d14ca"}, {"problem": 105, "code": "(fn keysAndValueX[v] ((fn keysAndValueRec[v res]\n\t(if (empty? v) res\n\t\t(if (= (count v) 1) (assoc res (first v) [])\n\t\t\t(if (keyword? (second v))\n\t\t\t\t(keysAndValueRec (rest v) (assoc res (first v) []))\n\t\t\t\t(keysAndValueRec ((fn after2 [v] (rest (rest v))) v) (assoc res (first v) (second v)))\n\t\t\t)\n\t\t)\n\t)\n) ((fn partitionKeywordSimple[v] \n(mapcat\n\t(fn[n] (if (keyword? (first n)) n [n])) \n\t((fn partitionKeyword[v] (partition-by (fn [n] (keyword? n)) v)) v)\n\t)\n) v) {}))", "user": "568820e8e4b0dcc4269f4067"}, {"problem": 105, "code": "(fn foo [coll]\n  (let [asvec (vec coll)]\n    (reduce (fn [r [[i k] [j _]]]\n              (assoc r k (subvec asvec (inc i) j)))\n            {} (partition 2 1 [[(count asvec) nil]] (filter\n                                (fn [[_ v]] (keyword? v))\n                                (map-indexed #(vector %1 %2) asvec))))))", "user": "56a01895e4b0542e1f8d149f"}, {"problem": 105, "code": "(fn [coll]\n    (loop [ output '()\n            c (seq coll)]\n     (if (empty? c)\n       (do\n       (loop [ s {} d output]\n         (if (empty? d)\n           s\n           (recur (assoc s (first (first d)) (vec (rest (first d)))) (rest d)))))\n       (let [ l (last output)\n              n (first c)\n              ll (drop-last output)]\n      (if (number? n)\n        (recur (concat ll (list (concat l (list n)))) (rest c))\n        (recur (concat output (list (list n))) (rest c)))))))", "user": "50b25f2ce4b03ea88043355f"}, {"problem": 105, "code": "(fn a [s]\n  (first (reduce \n    (fn [[r k] v]\n      (if (number? v)\n       [(assoc r k (conj (r k) v)) k]\n       [(assoc r v []) v]\n      )) [{} 0] s)))", "user": "56bca51ae4b0f26550335963"}, {"problem": 105, "code": "(fn [xs] (first (reduce \n          (fn [[m k] x] \n            (if (keyword? x)\n              [(assoc m x []) x]\n              [(merge-with concat m {k [x]}) k]))\n          [{} :a] \n          xs)))", "user": "56b86e64e4b0f26550335924"}, {"problem": 105, "code": "(fn [kvs] (apply hash-map\n                 (mapcat #(vector (first (first %)) (second %))\n                         (partition 2 (map #(remove nil? %)\n                                           (partition-by keyword?\n                                                         (interpose nil kvs)))))))", "user": "56baab13e4b0f26550335948"}, {"problem": 105, "code": "(fn [s]\n  (->> s\n       (partition-by keyword?)\n       (reduce (fn [origin s]\n                 (if (some #(not (keyword? %)) s)\n                   (conj origin s)\n                   (vec (concat origin (interpose [] s))))) [])\n       (apply hash-map)))", "user": "567e418fe4b0feffd0d18eb1"}, {"problem": 105, "code": "(fn [coll]\n  (apply hash-map\n         (reduce #(if (keyword? %2) \n                    (conj % %2 []) \n                    (conj (vec (butlast %)) (conj (last %) %2)))\n                 []\n                 coll)))", "user": "56ae214ce4b03c432f18735a"}, {"problem": 105, "code": "(fn f [[h & t]]\n\t(if h\n\t\t(conj\n\t\t\t{h (take-while (complement keyword?) t)}\n\t\t\t(f (drop-while (complement keyword?) t)))\n\t\t{}))", "user": "56baa68ce4b0f26550335947"}, {"problem": 105, "code": "reduce #(if (keyword? %2) (assoc % %2 []) (update-in % \n               (vector (first (first %))) \n                conj %2)) {}", "user": "56c08696e4b060a8e693e3aa"}, {"problem": 105, "code": "(fn [x]\n  (let [kys (filter keyword? x)\n        vals (reduce #(if (keyword? %2) (conj % []) (assoc % (dec (count %)) (conj (last %) %2))) [] x)]\n    (zipmap kys vals)))", "user": "56d1afd9e4b0ea9b8538f791"}, {"problem": 105, "code": "(fn [x]\n  (loop [c x\n       r {}\n       k nil]\n  (if (empty? c)\n    r\n    (let [i (first c)\n          k? (keyword i)]\n      (recur (rest c)\n             (if k? (assoc r i []) (update-in r [k] conj i))\n             (if k? i k))))))", "user": "5541fa50e4b0a04f79299515"}, {"problem": 105, "code": "(fn [args]\n    (->> args\n      (reduce (fn [res el]\n                (if (keyword? el)\n                  (conj res el [])\n                  (conj (rest res) (conj (first res) el)))) '())\n      (reverse)\n      (partition 2)\n      (map vec)\n      (into {})))", "user": "5317d78ee4b08068f379ed63"}, {"problem": 105, "code": "(fn kv [s] (if (empty? s) {} (conj (kv (drop-while #(number? %) (rest s)) ) {(first s) (take-while #(number? %) (rest s))})))", "user": "56427910e4b08d4f616f5f19"}, {"problem": 105, "code": "(fn [coll]\n  (loop [curr-kw (first coll) mapped {} remaining coll]\n    (if (seq remaining)\n      (let [v (first remaining)]\n        (if (keyword? v)\n          (recur v (assoc mapped v []) (rest remaining))\n          (recur curr-kw (assoc mapped curr-kw (conj (get mapped curr-kw) v)) (rest remaining))))\n      mapped)))", "user": "56603e5fe4b068f2fe63dc4a"}, {"problem": 105, "code": "(fn [s]\n  (->> s\n       (reduce (fn [[[k numbers] & h :as acc] item]\n                 (if (and (keyword? item)\n                          (not= k item))\n                   (conj acc [item []])\n                   (conj h [k (conj numbers item)])))\n               (list []))\n       (filter seq)\n       (into {})))", "user": "56e83348e4b02e7e935eb6e5"}, {"problem": 105, "code": "(fn [coll]\n  (letfn [(partition-until [f coll]\n                           (lazy-seq\n                            (when-let [s (seq coll)]\n                              (let [[fst] s\n                                    run   (cons fst (take-while (complement f) (next s)))]\n                               (cons run (partition-until f (seq (drop (count run) s))))))))]\n    (or\n     (apply merge \n           (map (fn [[k & vs]]\n                  (hash-map k (vec vs))) (partition-until keyword? coll)))\n     {})))", "user": "56481722e4b0284900eef628"}, {"problem": 105, "code": "(fn [x]\n     (loop [ r {},  k nil, v [], [f & x ] x ]\n       (if f\n         (if (keyword? f) (recur (if k (assoc r k v) r) f [] x)\n                          (recur r k (conj v f) x))\n        (if k (assoc r k v) {}))))", "user": "4fd11a93e4b04c3a95aa040a"}, {"problem": 105, "code": "(fn f [[k & more]]\n  (cond\n    (nil? k) {}\n    (keyword? (first more)) (assoc (f more) k [])\n    :else (assoc (f (drop-while (comp not keyword?) more))\n            k\n            (take-while (comp not keyword?) more))))", "user": "541709b0e4b01498b1a71a06"}, {"problem": 105, "code": "(fn [args]\n  (loop [in args\n         ret {}]\n    (if (empty? in)\n      ret\n      (let [t (first in)]\n        (recur\n         (rest in)\n         (if (keyword? t)\n           (into ret {t []})\n           (assoc ret (key (last ret) ) (conj (val (last ret)) t))))))))", "user": "56d5fd24e4b0ea9b8538f7c5"}, {"problem": 105, "code": "(fn [s]\n  (into {}\n        (map #(vector (first %) (into [] (rest %)))\n              (let [new (atom false)]\n                (partition-by #(if (keyword? %)\n                                 (reset! new (not @new))\n                                 @new)\n                              s)))))", "user": "56d4b22de4b0ea9b8538f7bb"}, {"problem": 105, "code": "(fn kv [s]\n  (if (seq s)\n    (merge {(first s) (take-while number? (rest s))} (kv (drop-while number? (rest s))))\n    {}))", "user": "56dc483fe4b0ea9b8538f81b"}, {"problem": 105, "code": "#((fn f [m k [e & r]]\n    (if e\n      (if (keyword? e)\n        (f (conj m {e []}) e r)\n        (f (conj m {k (conj (m k []) e)}) k r))\n      m))\n  {} (first %) (rest %))", "user": "56c3aca0e4b05cc29241ee90"}, {"problem": 105, "code": "(fn identify-kv [coll]\n\t(->> (partition-by keyword? coll)\n\t\t (partition 2)\n\t\t (reduce (fn [r [kseq vseq]]\n\t\t\t\t\t (if (= (count kseq) 1)\n\t\t\t\t\t\t (assoc! r (first kseq) (vec vseq))\n\t\t\t\t\t\t (let [lastkey (last kseq)]\n\t\t\t\t\t\t\t (reduce (fn [rr e]\n\t\t\t\t\t\t\t\t\t\t (assoc! rr e [])) r (butlast kseq))\n\t\t\t\t\t\t\t (assoc! r lastkey vseq))))\n\t\t\t\t (transient {}))\n\t\t (persistent!)\n\t\t))", "user": "552bd5c2e4b0ffed3738f969"}, {"problem": 105, "code": "(fn [coll] (zipmap (flatten (take-nth 2 (partition-by keyword? (interpose [] coll)))) (map (fn [a] (if (< (count a) 2) [] (filter #(not (= %1 [])) a)))\n                                                                                            (take-nth 2 (rest (partition-by keyword? (interpose [] coll)))))))", "user": "567f988be4b0feffd0d18ebe"}, {"problem": 105, "code": "(fn f [xs]\n  (->> xs\n       (partition-by keyword?)\n       (mapcat #(if (keyword? (first %)) (interpose [] (map first (partition 1 %))) [(vec %)]))\n       (partition 2 2 ())\n       (map #(apply vector %))\n       (into {})\n       ))", "user": "569dd6e8e4b0542e1f8d1480"}, {"problem": 105, "code": "#(loop [l %\n        c nil\n        result {}]\n   (if (empty? l)\n     result\n     (recur (rest l)\n            (if (keyword? (first l))\n              (first l) c)\n            (if (keyword? (first l))\n              (assoc result (first l) [])\n              (assoc result c (conj (result c) (first l))))\n            ))\n   )\n; more decent approach. from moocar.\n;(fn [arg]\n;   (->> (interpose nil arg)\n;        (partition-by keyword?)\n;        (map #(if (keyword? (first %))\n;                (first %)\n;                (remove nil? %)))\n;        (apply hash-map)))", "user": "56f7ecdfe4b08e7d20b96834"}, {"problem": 105, "code": "(fn f [xs]\n  (if-let [k (first xs)]\n    (let [r (rest xs)\n          v (take-while number? r)]\n      (merge {k v} (f (drop-while number? r))))\n    {}))", "user": "56d68cbae4b0ea9b8538f7cd"}, {"problem": 105, "code": "(fn [coll] \n   (into {}\n         (reduce\n           (fn [m, x]\n             (if (keyword? x)\n               (conj m [x []])\n               (conj (vec (butlast m)) [(first (last m)) (conj (second (last m)) x)]))) [] coll)))", "user": "56f15eade4b04a395b9a048e"}, {"problem": 105, "code": "(fn [coll]\n   (let [l (reduce (fn [m x]\n             (if (keyword? x)\n               (concat m [x []])\n               (concat (drop-last m) (vector (conj (last m) x))))) [] coll)\n         s (apply array-map l)]\n     s))", "user": "56fbf83de4b07572ad1a88da"}, {"problem": 105, "code": "(fn solve [x]\n  (let [res (reduce\n    (fn [[keyw vals res] val]\n      (if (keyword? val)\n        (if keyw [val [] (assoc res keyw vals)] [val [] res])\n        [keyw (conj vals val) res]\n        )) [nil []  {}] x)]\n    (if (first res)\n    (assoc (last res) (first res) (second res))\n      (last res))))", "user": "56f258d3e4b04a395b9a04a1"}, {"problem": 105, "code": "#(loop [[k & r] % acc {}]\n   (if k\n     (let [[f s] ((juxt take-while drop-while) number? r)] (recur s (conj acc [k f])))\n     acc))", "user": "57035ccfe4b08d47c97781ef"}, {"problem": 105, "code": "(fn [x]\n  (let [[m v] (reduce (fn [[m v] y]\n                        (if (keyword? y)\n                          [(conj m v)\n                           [y []]]\n                          [m\n                           [(first v)\n                            (conj (last v) y)]]))\n                      [{} nil]\n                      x)]\n    (conj m v)))", "user": "55f73078e4b06e875b46cea4"}, {"problem": 105, "code": "(fn [coll]\n  (loop [k (first coll)\n         [v r] (split-with integer? (rest coll))\n         acc {}]\n    (if k\n      (recur (first r)\n             (split-with integer? (rest r))\n             (assoc acc k v))\n      acc)))", "user": "549eb44fe4b0f3d1d8e70fa6"}, {"problem": 105, "code": "(fn create-map[xs]\n  (loop [ys xs\n         acc {}\n         last-keyword nil]\n    (if (empty? ys)\n      acc\n      (let [next-elem (first ys)\n            tail (rest ys)\n            new-acc (if (keyword? next-elem)\n                      (merge acc {next-elem []})\n                      (update-in acc [last-keyword] conj next-elem))\n            new-keyword (if (keyword? next-elem)\n                          next-elem\n                          last-keyword)]\n        (recur tail new-acc new-keyword)))))", "user": "54f86b8ce4b01ecee9d88828"}, {"problem": 105, "code": "#(loop [[head :as coll] % \n        curr-key nil \n        result {}]\n   (if (empty? coll)\n     result\n     (if (keyword? head)\n       (recur (next coll) head (assoc result head []))\n       (recur (next coll) curr-key (merge-with conj result {curr-key head})))))", "user": "5712854ce4b07c98581c3a89"}, {"problem": 105, "code": "(fn [coll]\n  (letfn [(step [c]\n            (if (> (count c) 1)\n              (let [key-size (count (first c))]\n                (if (= key-size 1)\n                  (concat [(first (first c)) (vec (second c))] (step (drop 2 c)))\n                  (concat [(first (first c)) []] (step (cons (rest (first c)) (rest c))))))))]\n    (let [vec-result (step (partition-by keyword? coll))]\n      (if (seq vec-result)\n        (apply (partial assoc {}) vec-result)\n        {}))))", "user": "505d1b01e4b0e6aca564be04"}, {"problem": 105, "code": "(fn [xs]\n    (second\n     (reduce (fn [[k m] x] (if (keyword? x)\n                            [x (assoc m x [])]\n                            [k (assoc m k (conj (get m k) x))]))\n             [nil {}] xs)))", "user": "4f57c913e4b0a7574ea7183f"}, {"problem": 105, "code": "reduce #(if (keyword? %2)\n          (with-meta (assoc % %2 []) {0 %2})\n          (update-in % [((meta %) 0)] conj %2))\n       {}", "user": "4e7dfab0535db169f9c796f9"}, {"problem": 105, "code": "(fn [a-seq]\n  (loop [lseq a-seq acc {}]\n    (if (empty? lseq)\n      acc\n      (let [next-key (first lseq)\n            nums-first (drop 1 lseq)\n            next-vals (take-while #(number? %) nums-first)\n            key-first (drop-while #(number? %) nums-first)]\n        (recur key-first (assoc acc next-key next-vals))))))", "user": "56cb4d06e4b0ea9b8538f72e"}, {"problem": 105, "code": "reduce (fn[m v] (if (keyword? v)\n                  (with-meta (assoc m v []) {:kw v})\n                  (update-in m [(:kw (meta m))] conj v))) {}", "user": "56d63729e4b0ea9b8538f7ca"}, {"problem": 105, "code": "(fn [c]\n  (loop [initial c res {}]\n    (if (empty? initial)\n         res\n         (recur\n           (drop-while (complement keyword?) (rest initial))\n           (assoc res (first initial) (take-while (complement keyword?) (rest initial)))))))", "user": "571fb6a0e4b0145328a762b5"}, {"problem": 105, "code": "(fn kv-coll->map [coll]\n  (letfn [(aux [left-coll this-acc curr-mp]\n            (if (empty? left-coll)\n              (merge (apply hash-map this-acc) curr-mp)\n              (let [fst (first left-coll)\n                    rst (rest left-coll)]\n                (if (number? fst)\n                  (aux rst\n                       [(first this-acc) (conj (second this-acc) fst)]\n                       curr-mp)\n                  (aux rst\n                       [fst []]\n                       (merge (apply hash-map this-acc) curr-mp))))))]\n    (aux coll [] {})))", "user": "568e1871e4b0dcc4269f40cc"}, {"problem": 105, "code": "(fn turd [stuff]\n  (loop [items stuff k nil acc {}]\n    (if (empty? items)\n      acc\n      (if (keyword? (first items))\n        (recur (drop 1 items) (first items) (assoc acc (first items) []))\n        (recur (drop 1 items) k (update-in acc [k] #(conj % (first items))))\n        \n        \n        \n        )\n      )\n    \n    \n    \n    )\n  \n  )", "user": "55f8fd70e4b03cbcff9738bc"}, {"problem": 105, "code": "(fn id-kv [s]\n  (loop [s s\n         k nil\n         v nil\n         ret {}]\n    (let [[h & r] s]\n      (cond\n        (empty? s) (if k (assoc ret k (reverse v)) ret)\n        (keyword? h) (if k\n                       (recur r h nil (assoc ret k (reverse v)))\n                       (recur r h nil ret))\n        :else (recur r k (conj v h) ret)))))", "user": "571d063ee4b0145328a76272"}, {"problem": 105, "code": "(fn [coll]\n  (apply hash-map\n    (mapcat #(list (ffirst %) (second %)) \n       (partition 2 \n                  (reduce\n                    #(if \n                       (and (> (count %2) 1) (every? keyword? %2)) \n                       (concat %1 (interpose '() (map vector %2)))\n                       (concat %1 (list %2))) \n                    [] \n                    (partition-by keyword? coll))))))", "user": "4df73d64535d04ed9115e775"}, {"problem": 105, "code": "(fn [xs]\n            (into {}\n                  (loop [acc [], xs xs]\n                       (if (seq xs)\n                         (let [k (first xs)\n                               xs (rest xs)\n                               vs (->> xs\n                                       (take-while (complement keyword?))\n                                       vec)\n                               xs' (drop-while (complement keyword?) xs)\n                               acc' (conj acc [k vs])]\n                           (recur acc' xs'))\n                         acc))))", "user": "53684a2fe4b0243289761e8c"}, {"problem": 105, "code": "(fn [seq]\n  (loop [[keywords numbers & more] (partition-by keyword? seq)\n         out-map {}]\n    (if (nil? keywords)\n      out-map\n      (let [out-map (reduce #(assoc % %2 []) out-map (butlast keywords))]\n        (recur more (assoc out-map (last keywords) numbers))))))", "user": "57002b81e4b08d47c97781c7"}, {"problem": 105, "code": "(fn idkv [coll]\n  (or (->> coll\n           (partition-by keyword?)\n           (partition 2)\n           (map #(assoc\n                  (into {} (for [x (butlast (first %))] [x []]))\n                  (last (first %)) (second %)))\n           (apply merge))\n      {}))", "user": "563fc1f2e4b08d4f616f5ed7"}, {"problem": 105, "code": "(fn [x] (apply hash-map (map #(if (keyword? (first %)) (first %) (vec (rest %))) (partition-by keyword? (flatten (map #(if (keyword? %) [% nil] %)  x))))))", "user": "56ab7578e4b03c432f18733d"}, {"problem": 105, "code": "(fn [s]\n  (loop [x s result {} k nil]\n    (if (empty? x) \n      result\n      \t(if (keyword? (first x))\n          (recur (rest x) (assoc result (first x) []) (first x))\n          (recur (rest x) (update-in result [k] conj (first x)) k)\n        )\n      \n      )\n    \n    \n    )\n  \n  \n  )", "user": "56db90d4e4b0ea9b8538f80d"}, {"problem": 105, "code": "(fn [coll]\n  (apply hash-map\n         (mapcat #(cond (number? (first %)) [%]\n                        (= (count %) 1) %\n                        :else (conj (vec (mapcat (fn [k] [k ()]) (butlast %))) (last %)))\n                 (partition-by keyword? coll))))", "user": "56dc3bdfe4b0ea9b8538f819"}, {"problem": 105, "code": "(fn collect\n  [l]\n  (last\n   (reduce\n    (fn [[current-key agg] v]\n      (if (keyword? v)\n        [v (assoc agg v [])]\n        [current-key (update-in agg [current-key] #(conj % v))]))\n    [nil {}] l)))", "user": "4daeabf6edd6309eace4d15c"}, {"problem": 105, "code": "(fn [xs]\n  (loop [m {}, k nil, [elem & remain] xs]\n    (if (nil? elem)\n      m\n      (if (keyword? elem)\n        (recur (assoc m elem []) elem remain)\n        (recur (assoc m k (conj (get m k) elem)) k remain)))))", "user": "573d58c8e4b05c31a32c0811"}, {"problem": 105, "code": "(fn [s]\n  (if (empty? s)\n    {}\n    (let [a (apply merge (map #(hash-map %1 []) (filter keyword? s)))]\n      (loop [res a data s currKey nil]\n        (if (empty? data)\n          res\n          (if (keyword? (first data))\n            (recur res (rest data) (first data))\n            (recur (update-in res [currKey] conj (first data)) (rest data) currKey)))))))", "user": "541ddadbe4b01498b1a71a84"}, {"problem": 105, "code": "(fn key-val [coll]\n  (reduce (fn [result [k v]]\n            (assoc (into result (zipmap k (repeat []))) (last k) v)) {}\n          (partition 2 (partition-by keyword? coll))))", "user": "572ea970e4b0cd1946bd0f89"}, {"problem": 105, "code": "(fn xx [[k & rst]]\n  (let [[vls tail] (split-with (complement keyword?) rst)]\n    (if (nil? k) {}\n        (assoc (xx tail) k vls))))\n;comsumes stack", "user": "56102f50e4b05f002753df6b"}, {"problem": 105, "code": "(fn [kvs]\n  (let [kkvs (partition-all 2 (partition-by #(keyword? %) kvs))]\n    (reduce (fn [acc [ks vs]]\n              (merge \n               (reduce #(assoc % %2 []) {} (rest (reverse ks)))\n               (assoc acc (last ks) vs))\n              ) ; fn\n            {}\n            kkvs) ; reduce\n    ) ; let\n  ) ; fn", "user": "53da059be4b0e771c302547e"}, {"problem": 105, "code": "(fn [x]\n  (if (empty? x)\n    {}\n    (merge (apply assoc {}\n                  (interleave (filter keyword?\n                                      x)\n                              (repeat [])))\n           (zipmap\n            (map last\n                 (filter #(keyword? (first %))\n                         (partition-by keyword? x)))\n            (map vec\n                 (filter #(not (keyword? (first %)))\n                         (partition-by keyword? x)))))))", "user": "52e1c276e4b09f7907dd142b"}, {"problem": 105, "code": "(fn [s]\n  (loop [res {}  [f & rst] s kw nil]\n    (if f\n      (if (keyword? f)  (recur (assoc res f [] )  rst f) \n                        (recur (update-in res [kw] conj f )  rst  kw)\n      )\n    \n    res\n    )\n  \n  )\n  )", "user": "5735ac67e4b0cd1946bd102b"}, {"problem": 105, "code": "(fn f [xs]\n  (if (empty? xs)\n    {}\n    (let [[[key] rest] (split-at 1 xs)\n          [value rest] (split-with (complement keyword?) rest)\n          value (vec value)]\n      (into {key value} (f rest)))))", "user": "56ac81ace4b03c432f187347"}, {"problem": 105, "code": "#(loop [[x & xs] %1, curk nil, curv [], acc {}]\n   (if (nil? x)\n     (if curk (assoc acc curk curv) acc)\n     (if (= (type x) java.lang.Long) \n       (recur xs curk (conj curv x) acc)\n       (recur xs x [] (if curk (assoc acc curk curv) acc)))))", "user": "57015a1de4b08d47c97781d4"}, {"problem": 105, "code": "(fn [xs]\n  (first\n    (reduce\n      (fn [[acc kw] x]\n        (if (keyword? x) [(assoc acc x []) x]\n          [(assoc acc kw (conj (get acc kw) x)) kw]))\n     [{} nil] xs)))", "user": "54e540c1e4b024c67c0cf7f9"}, {"problem": 105, "code": "(fn [z] (apply hash-map \n               (reduce \n                (fn [s x] (if (keyword? x) \n                            (into s [x []])\n                            (conj (pop s) (conj (last s) x)))) \n                [] z)))", "user": "573ce277e4b05c31a32c080b"}, {"problem": 105, "code": "(fn [keywords-numbers]\n    (->> keywords-numbers\n      (reduce #(if (keyword? %2) (conj %1 [%2]) (update-in %1 [(dec (count %1))] conj %2))\n        [] )\n      (map (juxt first rest))\n      (into {})))", "user": "561814bae4b06b1bb2182a1a"}, {"problem": 105, "code": "(fn [c]\n  (let [to-map (fn [[keys values]] (concat (map #(vector % []) (butlast keys)) [[(last keys) values]]))]\n    (into {} (->> c\n                  (partition-by keyword?)\n                  (partition 2)\n                  (mapcat to-map)))))", "user": "54e345a1e4b024c67c0cf7db"}, {"problem": 105, "code": "(fn keys-and-values [s]\n  (first (reduce (fn [[m current-key] item]\n                   (let [v (if (keyword? item) [] [item])\n                         next-key (if (keyword? item) item current-key)]\n                     [(merge-with (comp vec concat) m {next-key v})\n                      next-key]))\n                 [{}] s)))", "user": "53504fe6e4b084c2834f4ada"}, {"problem": 105, "code": "(fn[s](if (empty? s) {} (\napply merge(filter #(not (nil? %)) (map-indexed\n                       (fn[idx itm]( if(keyword? itm)\n                         (loop [i (inc idx) n []]\n                           (if (>= i (count s)) (assoc {} itm n)\n                             (if (keyword? (get s i)) (assoc {} itm n)\n                               (recur (inc i) (conj n (get s i)))\n                             )\n                           )\n                         )\n))\n                       s)))\n))", "user": "56039843e4b04bb52996e1be"}, {"problem": 105, "code": "(fn solve [l] (letfn [(has-keyword [l] (and (not-empty l) (keyword? (first l))))]\n                  (->> l \n                   (partition-by keyword?)\n                   (mapcat #(if (has-keyword %) (interpose [] %) [%]))\n                   (apply hash-map))))", "user": "54857657e4b0e286459a11ac"}, {"problem": 105, "code": "(fn [kv] \n  (letfn [(reducer [[m k] v] \n               (if (keyword? v) [(assoc m v []) v]\n                 [(update-in m [k] #(conj % v)) k]))]\n    (first (reduce reducer [{} :dummy] kv))\n    )\n  )", "user": "575ef4b6e4b08062f99a4e78"}, {"problem": 105, "code": "(fn identify-keys [lis]\n  (let [lis (reduce (fn [resp ele]\n                      (if (= (type ele) clojure.lang.Keyword)\n                        (conj resp [ele])\n                        (conj (rest resp) (conj (first resp) ele)))) [] lis) \n        ]\n    (reduce (fn [resp ele]\n              (assoc resp (first ele) (rest ele))) {} lis)))", "user": "574f1c24e4b02ea114799255"}, {"problem": 105, "code": "(fn [xs] \n  (->> xs\n       (partition-by keyword?)\n       (map #(if (keyword? (first %)) (interpose [] %) [%]))\n       (apply concat [])\n       (apply hash-map)\n       ))", "user": "57642916e4b0994c1922fbee"}, {"problem": 105, "code": "(fn [values]\n  (loop [values values\n         m {}]\n    (if (seq values)\n      (recur (drop-while (complement keyword?)\n                         (rest values))\n             (assoc m (first values)\n               (take-while (complement keyword?)\n                           (rest values))))\n      m)))", "user": "575cbe44e4b02ea114799374"}, {"problem": 105, "code": "(fn [s]\n  (reduce (fn [r [k v]]\n            (assoc (into r (zipmap k (repeat []))) (last k) v)) \n          {}\n          (partition 2 (partition-by keyword? s))))", "user": "57644395e4b0994c1922fbf2"}, {"problem": 105, "code": "(fn [a-map]\n  (let [results (reduce (fn [[ks vs] v]\n                         (if (keyword? v)\n                           [(conj ks v) (conj vs [])]\n                           [ks (update-in vs [(- (count ks) 1)] #(conj % v))]))\n                       [[][]]\n                       a-map)]\n    (zipmap (first results) (last results))))", "user": "53e9dce1e4b036ad0777e4bc"}, {"problem": 105, "code": "(fn kv [s]\n    (reduce #(if (keyword? %2) \n                 (assoc % %2 []) \n                 (update-in \n                  % \n                  [(first (last %))]\n                  (fn [x] (conj x %2) ))) (sorted-map) s))", "user": "534fa9dae4b084c2834f4acf"}, {"problem": 105, "code": "(fn [alist]\n  (if (empty? alist)\n    {}\n    (->>\n     ((fn looking [n]\n        (let [kword (first n)\n              itsints (take-while integer? (rest n))\n              lengthtaken (inc (count itsints))]\n          (if (empty? n)\n            n\n            (cons [kword itsints] (looking (drop lengthtaken n))))))\n      alist)\n     (map #(hash-map (first %) (second %)))\n     (reduce merge))))", "user": "5705e404e4b0b0fb43fd0676"}, {"problem": 105, "code": "(fn [coll]\n  (loop [[head & tail :as s] (seq coll)\n         result {}]\n    (if (seq s)\n      (let [k head\n            [v more] (split-with number? tail)]\n        (recur more (assoc result k (vec v))))\n      result)))", "user": "5764457ae4b0994c1922fbf3"}, {"problem": 105, "code": "#(reduce \n  (fn [m v]\n    (if (keyword? v)\n      (assoc m v [])\n      (let [k (-> m keys sort last)\n            s (get m k)]\n        (assoc m k (conj s v)))))\n  {}\n  %)", "user": "57609d91e4b08062f99a4e9b"}, {"problem": 105, "code": "(fn [s]\n  (first (reduce\n          (fn [[m k] v]\n            (if (keyword? v)\n              [(assoc m v []) v]\n              [(update-in m [k] conj v) k]))\n          [{} nil]\n          s)))", "user": "53c1b787e4b00fb29b221266"}, {"problem": 105, "code": "(fn [coll]\n  (loop [p coll k [] v [] m {}]\n        (cond\n          (empty? p) (dissoc (assoc m k v) [])\n          (keyword? (first p)) (recur (rest p) (first p) [] (assoc m k v))\n          :else (recur (rest p) k (conj v (first p)) m))))", "user": "574abbfbe4b02ea114799200"}, {"problem": 105, "code": "(letfn\n    [(aux [[fst & rst :as xs] [[fstm] :as m]]\n       (cond\n         (not (seq xs)) m\n         (keyword? fst) (aux rst (cons [fst] m))\n         :else (aux rst (cons [fstm fst] m))))]\n  (fn [sx]\n    (reduce\n     (fn [m [fst & rst]] (update-in m [fst] (comp vec concat) rst))\n     {} (reverse (aux sx [])))))", "user": "56795deae4b05957ce8c6187"}, {"problem": 105, "code": "(fn f [[k & v]]\n  (if v\n    (let [[a b] (split-with number? v)]\n      (assoc (f b) k a))\n    {}))", "user": "5731e36be4b0cd1946bd0fc9"}, {"problem": 105, "code": "(fn [s]\n    (first\n     (reduce (fn [[acc k] e]\n                (if (keyword? e)\n                  [(assoc acc e []) e]\n                  [(assoc acc k (conj (get acc k) e)) k]))\n             [{} nil] s)))", "user": "4dfe5a93535d04ed9115e786"}, {"problem": 105, "code": "(fn [coll]\n  (loop [coll coll result []]\n    (if (empty? coll)\n      (apply hash-map result)\n      (let [keyword (first coll)\n            others (next coll)\n            test-func #(not (keyword? %))]\n        (recur (drop-while test-func others) (conj result keyword (take-while test-func others) ))\n        )\n      )\n    )\n  )", "user": "5776558ee4b0979f89651633"}, {"problem": 105, "code": "(fn [xs]\n  (reduce (fn [a v]\n            (if (keyword? v)\n              (assoc a v [])\n              (update-in a [(last (keys a))] #(conj % v)))) (sorted-map) xs))", "user": "55c4cda5e4b0e31453f649a5"}, {"problem": 105, "code": "(fn keys-vals [c]\n    (loop [o {} c c]\n      (if-let [k (first c)]\n        (recur (conj o \n                     [k\n                      (vec\n                       (take-while number? (rest c)))])\n               (drop-while number? (rest c)))\n        o)))", "user": "579693d4e4b039eba2ecb0e7"}, {"problem": 105, "code": "(fn keys-vals [c]\n    (loop [o {} c c]\n      (if-let [k (first c)]\n        (recur (conj o \n                     [k\n                      (vec\n                       (take-while number? (rest c)))])\n               (drop-while number? (rest c)))\n        o)))", "user": "5796d308e4b039eba2ecb0ed"}, {"problem": 105, "code": "(fn keys-vals [c]\n    (loop [o {} c c]\n      (if-let [k (first c)]\n        (recur (conj o \n                     [k\n                      (vec\n                       (take-while number? (rest c)))])\n               (drop-while number? (rest c)))\n        o)))", "user": "57533bc1e4b02ea1147992a6"}, {"problem": 105, "code": "(fn keys-vals [c]\n    (loop [o {} c c]\n      (if-let [k (first c)]\n        (recur (conj o \n                     [k\n                      (vec\n                       (take-while number? (rest c)))])\n               (drop-while number? (rest c)))\n        o)))", "user": "5798205ce4b039eba2ecb10e"}, {"problem": 105, "code": "(fn keys-vals [c]\n    (loop [o {} c c]\n      (if-let [k (first c)]\n        (recur (conj o \n                     [k\n                      (vec\n                       (take-while number? (rest c)))])\n               (drop-while number? (rest c)))\n        o)))", "user": "57982bace4b039eba2ecb10f"}, {"problem": 105, "code": "(fn [coll]\n  (let [mapped-items\n    (reduce\n      (fn [res el]\n        (if (keyword? el)\n          (conj res [el])\n          (let [old (last res)\n                new (conj old el)]\n            (conj (into [] (drop-last res)) new))))\n      []\n      coll)]\n    (into {} (for [[k & v] mapped-items] [k (into [] v)]))))", "user": "55ede35ce4b0121d4835fde1"}, {"problem": 105, "code": "(fn key-num[s]\n  (if-not (seq s)\n    {}\n    (let [k\t(first s)\n          [vls rst]\t(split-with number? (rest s))]\n  \t(assoc (key-num rst) k (vec vls)))))", "user": "57822efce4b0d36ec5835e91"}, {"problem": 105, "code": "(fn [xs]\n  (loop [m {}\n         s xs]\n    (if (empty? s) m\n    (let [sp (first s)\n          sp2 (split-with (complement keyword?) (rest s))]\n      (recur (conj m [sp (first sp2)]) (first (rest sp2)))))))", "user": "57717915e4b0979f896515b3"}, {"problem": 105, "code": "(fn myf2 [coll]\n  (loop [coll coll, m {}]\n    (let [cur-key (first coll)]\n      (if (nil? cur-key) m\n        (recur (drop-while #(not (keyword? %)) (rest coll)) \n               (into m {cur-key (take-while #(not (keyword? %)) (rest coll))})\n               \n               )))))", "user": "577c3da9e4b0c8d87281f6b9"}, {"problem": 105, "code": "#(loop [res-map {} curr-keyword (first %) pend %]\n\n\t(if (empty? pend)\n\t\tres-map\n\t\t(if (keyword? (first pend))\n\t\t\t(recur (assoc res-map (first pend) []) (first pend) (rest pend))\n\t\t\t(recur (merge-with concat res-map {curr-keyword  [(first pend)]}) curr-keyword  (rest pend)))))", "user": "57986b76e4b039eba2ecb116"}, {"problem": 105, "code": "(fn [s]\n  (-> (reduce #(if (keyword? %2)\n                 (assoc %1 :key %2 %2 [])\n                 (update-in %1 [(:key %1)] conj %2))\n              {}\n              s)\n      (dissoc :key)))", "user": "57aa4775e4b0b8559636fc6b"}, {"problem": 105, "code": "(fn\n  [v]\n  (loop [l (partition-by keyword v) f {}]\n    (if (empty? l)\n      f\n      (if (keyword? (first (second l)))\n        (recur (rest l)   (assoc f (first (first l)) []))\n        (recur (drop 2 l) (assoc f (first (first l)) (vec (second l)))  ) \n      )))\n)", "user": "5772ddb0e4b0979f896515d4"}, {"problem": 105, "code": "(fn f\n  ([xs k m]\n   (if (seq xs)\n     (let [x (first xs) ys (rest xs)]\n       (if (keyword? x)\n         (f ys x (assoc m x []))\n         (f ys k (assoc m k (conj (get m k []) x)))))\n     m))\n  ([xs] (f (rest xs) (first xs) {})))", "user": "5799ff45e4b05b1deef9add1"}, {"problem": 105, "code": "(fn p105 [xs]\n    (let [acc (fn [[m k] x] \n                (if (keyword? x) \n                  (vector (assoc m x []) x) \n                  (vector (update-in m [k] conj x) k)))]\n      (first (reduce acc [{}] xs))))", "user": "4fc4eb1ee4b081705acca354"}, {"problem": 105, "code": "#(apply hash-map\n               (loop [acc []\n                      v %]\n                 (cond (nil? (seq v)) acc\n                       (not (number? (second v)))\n                       (recur (conj acc (first v) []) (next v))\n                       :else (recur (conj acc (first v) (vec (take-while number? (next v))))\n                                    (drop-while number? (next v))))))", "user": "56903cb9e4b0dcc4269f40eb"}, {"problem": 105, "code": "(fn [xs]\n    (first\n      (reduce\n        (fn [[m k] x]\n          (if (integer? x)\n\n            (let\n              [\n                l (get m k)\n                l' (conj l x)\n                m' (assoc m k l')\n              ]\n              [m' k]\n            )\n\n            (let\n              [\n                m' (assoc m x [])\n              ]\n              [m' x]\n            )\n          )\n        )\n        [{} nil]\n        xs\n      )\n    )\n  )", "user": "5784e177e4b0ebec4cfb74cf"}, {"problem": 105, "code": "(fn [input] (let [padded (mapcat (fn [x] (if (-> x first keyword?)\n                               (if (-> x count (> 1))\n                                 (drop-last (interleave (flatten (partition-by identity x)) (take (count x) (repeat '()))))\n                                 x)\n                               (list x)))\n                     (partition-by #(not (keyword? %)) input))\n      keys (filter keyword? padded)\n      vals (filter #(-> % keyword? not) padded)]\n  (zipmap keys vals)))", "user": "4e9ff8d0535d7eef3080729c"}, {"problem": 105, "code": "#(loop [[k & r] % c nil res {}]\n  (cond\n    (nil? k) res\n    (keyword? k) (recur r k (assoc res k []))\n    :default (recur r c (update-in res [c] conj k))))", "user": "57b3efb1e4b0fbc9809a278a"}, {"problem": 105, "code": "#(loop [s %\n       res {}]\n  (if (seq s)\n    (let [[a b] (split-with (complement keyword?) (rest s))]\n      (recur b (assoc res (first s) (vec a))))\n    res))", "user": "5455c2f3e4b080a794c2c87d"}, {"problem": 105, "code": "(fn [x]\n  (into {} \n    (map (fn [[_ k v]] {(keyword k) (vec (map #(- (int %) (int \\0)) v))}) \n      (re-seq #\"(\\w)(\\d*)\" (apply str x)))))", "user": "548b7db8e4b0e286459a11fd"}, {"problem": 105, "code": "(fn [inp]\n  (let [k (partition-all 2 1 (filter keyword? inp))]\n    (zipmap (filter keyword? inp)\n            (for [p k\n                  :let [start (first p)\n                        end (last p)\n                        start-i (.indexOf inp start)\n                        end-i (if (= start end)\n                               \t(count inp)\n                                (.indexOf inp end))]]\n              (subvec inp (+ start-i 1)end-i)))))", "user": "56504dc2e4b0284900eef6bc"}, {"problem": 105, "code": "(fn [icol]\n    (loop [col   icol\n           res   {}\n           ckw   nil]\n      (if (empty? col) res\n          (let [ el (first col) ]\n            (if (keyword? el)\n              (recur (rest col) (assoc res el []) el)\n              (recur (rest col) (assoc res ckw (conj (ckw res) el)) ckw)\n              )\n            \n            )\n          )\n      )\n    )", "user": "57aa290de4b0b8559636fc65"}, {"problem": 105, "code": "(fn [x]                                                                                                                       \n    (->> x                                                                                                                    \n         (partition-by keyword?)                                                                                              \n         (partition 2)                                                                                                        \n         (reduce (fn [m [ks y]]                                                                                               \n                     (reduce (fn [m k]                                                                                        \n                                 (assoc m k [])) (assoc m (last ks) y)  (butlast ks))) {})))", "user": "55316b8ae4b076ab5578f825"}, {"problem": 105, "code": "(fn [x] \n     (loop [i 0 result {}]\n      (cond \n                  (>= i (count x)) result\n                  (keyword? (get x i)) (recur (inc i) (into result {(get x i) []}))\n                  :else (recur (inc i)  (merge-with into result  {(key (last result)) [(get x i)]}))\n            )\n           \n       )\n   )", "user": "56e6e1e6e4b02e7e935eb6cf"}, {"problem": 105, "code": "(fn keyword-value-split\n  [col]\n  (loop [result {} col2 (partition-by #(keyword? %1) col)]\n    (if (empty? col2)\n      result\n\n      (let [ k (first col2) keyword-count (count k)]\n        (if (= 1 keyword-count)\n          ;if the keyword list contains only 1\n          (recur (merge result {(first k) (second col2)}) (drop 2 col2))\n\n          (let [last-key (last k) rest-keys (drop-last k)]\n            (recur (merge result (merge {last-key (second col2)} (into {} (map (fn f [k] {k []}) rest-keys)))) (drop 2 col2))))\n        ))))", "user": "558bdcefe4b0277789237633"}, {"problem": 105, "code": "(fn sep-keywords [xs]\n  (loop [res {} [k & s] xs]\n    (if (nil? k) res\n        (let [[s1 s2] (split-with (complement keyword?) s)]\n          (recur (assoc res k s1) s2)))))", "user": "575b3e9be4b02ea11479935b"}, {"problem": 105, "code": "(fn identify-key-val [coll]\n  (loop [[f & r :as c] coll, k nil, result {}]\n    (if (empty? c)\n      result\n      (if (keyword? f)\n        (recur r  f (assoc result f []))\n        (recur r  k (assoc result k (conj (get result k) f)))))))", "user": "572ec4dde4b0cd1946bd0f8d"}, {"problem": 105, "code": "(fn makee [s1]\n  (loop [s s1 accumulated {} ]\n    (if (empty? s)\n        accumulated\n        (recur (drop-while number? (rest s))\n               (assoc accumulated\n                      (first s)\n                      (vec (take-while number? (rest s))))))))", "user": "579d9601e4b05b1deef9ae18"}, {"problem": 105, "code": ";; life before transducers.\n(fn [coll]\n  (->> (reduce (fn [ret x]\n                 (if (number? x)\n                   (conj (pop ret) (conj (peek ret) x))\n                   (conj ret x [])))\n               []\n               coll)\n       (partition 2)\n       (map vec)\n       (into {})))", "user": "571c2babe4b07c98581c3b73"}, {"problem": 105, "code": "(fn keyword-set[xs]\n  (->> (reduce(fn[acc item]\n                (if(keyword? item)\n                  (conj acc item[])\n                  (assoc acc (dec(count acc))(conj(peek acc)item))))\n              []\n              xs)\n       (apply hash-map)))", "user": "57c500f9e4b05aa3c4741cda"}, {"problem": 105, "code": "(fn kv [s]\n  (second (reduce (fn [acc v]\n                    (if (keyword? v)\n                      (-> (assoc acc 0 v)\n                          (update-in [1] #(conj % [v []])))\n                      (update-in acc [1 (first acc)] #(conj % v))\n\n                      )\n                    ) [nil {}] s)))", "user": "51622fb8e4b009fba0926e3f"}, {"problem": 105, "code": "(fn kv [s]\n  (second (reduce (fn [acc v]\n                    (if (keyword? v)\n                      (-> (assoc acc 0 v)\n                          (update-in [1] #(conj % [v []])))\n                      (update-in acc [1 (first acc)] #(conj % v))\n                      )\n\n                    ) [nil {}] s)))", "user": "550c55d0e4b06e50f9beb14d"}, {"problem": 105, "code": "(fn __ [s]\n  (let [f (fn f [acc cur s]\n            (if (empty? s) (merge acc cur)\n              (let [[h & r] s]\n                (if (keyword? h)\n                  (f (merge acc cur) {h []} r)\n                  (f acc (assoc cur\n                           (first (keys cur))\n                           (conj (first (vals cur)) h)) r)))))]\n    (f {} {} s)))", "user": "57a0b341e4b0c3d858beb8d4"}, {"problem": 105, "code": "(fn c105\n  [coll]\n  (loop [c coll\n         r {}\n         l nil]\n    (if (empty? c)\n      r\n      (let [f (first c)]\n        (if (= (type f) (type :a))\n          (recur (next c) (assoc r f []) f)\n          (recur (next c) (assoc r l (conj (get r l) f)) l))))))", "user": "57d0cd58e4b0bd073c20235e"}, {"problem": 105, "code": "(fn func [v]\n    (if (empty? v) {}\n      (let [[vals rst] (split-with (complement keyword?) (rest v))]\n       (assoc (func rst) (first v) vals))))", "user": "57487084e4b009280f9f2b8c"}, {"problem": 105, "code": "(fn create-map \n  ([xs] \n    (if (empty? xs)\n      {}\n      (create-map {} (first xs) (rest xs))))\n  ([acc x xs]\n    (cond \n      (nil? x) acc\n      (empty? xs) acc\n      :else\n      (let [v (first xs)]\n        (if (keyword? v)\n          (create-map (assoc acc v []) v (rest xs))\n          (create-map (assoc acc x (conj (get acc x []) v)) x (rest xs)))))))", "user": "57d9bca1e4b0bd073c202405"}, {"problem": 105, "code": "(fn [lst]\n  (loop [lst lst, k nil, result {}]\n    (if (seq lst)\n      (let [[head & tail] lst]\n        (if (keyword? head)\n          (recur tail head (assoc result head []))\n          (recur tail k (update-in result [k] conj head))))\n      result)))", "user": "4f5599dfe4b0a7574ea71806"}, {"problem": 105, "code": "(fn f [s]\n  (if (seq s)\n    (merge {(first s) (take-while (complement keyword?) (rest s))}\n           (f (drop-while (complement keyword?) (rest s))))\n    {}))", "user": "56cf115de4b0ea9b8538f765"}, {"problem": 105, "code": "#(into {}\n        (reduce (fn [i e]\n                  (if (keyword? e)\n                    (conj i [e []])\n                    (conj (drop 1 i) [(first (first i)) (conj (second (first i)) e)]))\n                  )\n                [] %))", "user": "57d9f603e4b0bd073c20240a"}, {"problem": 105, "code": "(fn [coll]\n  (letfn [(step [c]\n            (if (> (count c) 1)\n              (let [key-size (count (first c))]\n                (if (= key-size 1)\n                  (concat [(first (first c)) (vec (second c))] (step (drop 2 c)))\n                  (concat [(first (first c)) []] (step (cons (rest (first c)) (rest c))))))))]\n    (let [vec-result (step (partition-by keyword? coll))]\n      (if (seq vec-result)\n        (apply (partial assoc {}) vec-result)\n        {}))))", "user": "57df309ee4b0bd073c20245f"}, {"problem": 105, "code": "(fn keys-vals [coll]\n  (loop [[e & mas :as es] coll\n         result []\n         curr-k nil\n         curr-vals []]\n    (letfn [(mores []\n              (concat result\n                (when curr-k [curr-k curr-vals])))]\n      (cond\n        (empty? es)\n        (apply hash-map (mores))\n        \n        (keyword? e)\n        (recur mas (mores) e [])\n        \n        :default\n        (recur mas result curr-k (conj curr-vals e))))))", "user": "56f9c7c6e4b07572ad1a88ba"}, {"problem": 105, "code": "(fn [x]\n  (let [partioned   (partition-by keyword? x)                                   ;((:a) (1 2 3) (:b :c) (4))\n        per-keyword (fn [[first :as all]] (if (keyword? first) (interpose [] all) [all]))     \n        mapped      (mapcat per-keyword partioned)\n        result      (apply hash-map mapped)]                                    ;{:c (4), :b [], :a (1 2 3)}\n   result))", "user": "57e139f6e4b0bfb2137f5a6c"}, {"problem": 105, "code": "(fn to-map [s]\n  (if-not (seq s)\n    {}\n    (let [[v t] (split-with (complement keyword?) (rest s))]\n      (conj (to-map t) [(first s) (vec v)]))))", "user": "57e0f30ae4b0bfb2137f5a66"}, {"problem": 105, "code": "(fn [coll]\n  (loop [remaining coll ans (hash-map) cur-key nil]\n    (if (empty? remaining)\n      ans\n      (if (= clojure.lang.Keyword (class (first remaining)))\n        (recur (rest remaining) (conj ans [(first remaining) []]) (first remaining))\n        (recur (rest remaining) (update-in ans [cur-key] conj (first remaining)) cur-key)))))", "user": "5746061ae4b009280f9f2b5b"}, {"problem": 105, "code": "; not very healthy for your stack\n(fn f [[k & coll]] \n  (if (nil? k) \n    {} \n    (let [nk (complement keyword?) \n          vs (vec (take-while nk coll))] \n      (assoc (f (drop-while nk coll)) k vs))))", "user": "57f0f7b8e4b0bfb2137f5bfe"}, {"problem": 105, "code": "(fn \n   [col] \n   (reduce-kv \n     #(into \n        %1 \n        (apply hash-map (concat (interpose [] %2) [%3])))\n     {} \n     (apply hash-map (partition-by keyword? col))))", "user": "576df252e4b0979f8965156f"}, {"problem": 105, "code": "(fn [coll]\n  (apply hash-map (reduce (fn [r x]\n                            (if (number? (first x))\n                               (conj r x)\n                               (apply conj r (interpose [] x))))\n                          []\n                          (partition-by keyword? coll))))", "user": "57dd47f4e4b0bd073c20243e"}, {"problem": 105, "code": "#(reduce (fn[acc x](if (keyword? x)(assoc acc x []) (merge-with conj acc {(first (first acc)) x}))) {} % )", "user": "57e33f6fe4b0bfb2137f5a96"}, {"problem": 105, "code": "(fn [x]\n    (let [take-pairs (fn tp [coll res]\n                       (if (empty? coll)\n                         res\n                         (let [f (first coll)\n                               vs (vec (take-while #(not (keyword? %)) (rest coll)))]\n                           (tp (drop (inc (count vs)) coll) (conj res [f vs])))))]\n     (into {} (take-pairs x []))))", "user": "4e837808535db62dc21a62d9"}, {"problem": 105, "code": "(fn [xs]\n (let [not-key? \n       (comp not keyword?)\n    rs (drop-while not-key? xs)\n    r-fst (first rs)]\n  (if (empty? rs) {}\n   (first (reduce (fn [[m k] b] \n     (if (not-key? b)\n      [(assoc m k (conj (m k) b)) k] \n      (if (contains? m b) \n       [m b] \n       [(assoc m b []) b]))) \n    [{r-fst []} r-fst]\n    (rest rs))))))", "user": "57f9011ee4b0d3187e900935"}, {"problem": 105, "code": "(fn [coll]\n  (loop [s   coll\n         map {}]\n    (if (seq s)\n      (let [key (first s)\n            s (rest s)]\n        (recur (drop-while (complement keyword?) s)\n               (assoc map key (vec (take-while (complement keyword?) s)))))\n      map)))", "user": "57a4fa50e4b0a966079561f1"}, {"problem": 105, "code": "(fn [items]\n  (let [l (partition-by type \n                        (reduce \n                         #(if (= (type (last %1)) (type %2) clojure.lang.Keyword) \n                            (conj %1 nil %2) \n                            (conj %1 %2)) [] items))]\n    (loop [l l, result {}]\n      (if (empty? l)\n        result\n        (recur (drop 2 l) (conj result (let [[[x] y & _] l]\n                            (if (nil? (first y))\n                              (hash-map x [])\n                              (hash-map x (vec y))))))))))", "user": "57f8ba80e4b0d3187e90092f"}, {"problem": 105, "code": "(fn [input]\n  (let [f (fn [v e]\n            (if (keyword? e)\n              (conj v e [])\n              (update-in v [(dec (count v))] conj e)))]\n    (into (hash-map) (mapv vec (partition 2 (reduce f [] input))))))", "user": "56ff45e5e4b08d47c97781bb"}, {"problem": 105, "code": "(comp first\n(partial\n\treduce\n\t(fn [[d k] v]\n\t\t(if (keyword? v)\n\t\t\t[(assoc d v []) v]\n\t\t\t[(assoc d k (conj (d k) v)) k]))\n\t[{} nil]))", "user": "57ccedaae4b0c746388ab88e"}, {"problem": 105, "code": "(fn [v]\n  (if (= v []) {}\n    (loop [h [] i 0]\n      (if (= i (count v))\n        (->> (partition 2 h)\n             (map #(vec %))\n             (into (sorted-map)))\n        (recur\n          (if (keyword? (v i)) (conj h (v i) []) \n           (conj (vec (butlast h)) (conj (last h) (v i)))\n            )\n          (inc i))))))", "user": "564d3169e4b0284900eef67c"}, {"problem": 105, "code": "(fn [coll]\n  (->> (interpose nil coll)\n       (partition-by keyword?)\n       (map #(if (keyword? (first %)) (first %) (remove nil? %)))\n       (apply hash-map)))", "user": "581e61b0e4b04b46fc4b0f28"}, {"problem": 105, "code": "(fn keyword-values\n  [seq]\n  (if (empty? seq) {}\n      (second (reduce (fn [[prev accum] h] (if (keyword? h)\n                                             [h (assoc accum h [])]\n                                             [prev (assoc accum prev (conj (accum prev) h))]))\n                      [(first seq) {(first seq) []}] (rest seq)))))", "user": "58152157e4b0f478707a0631"}, {"problem": 105, "code": "(letfn   [(p [[h & t]] (when-not (nil? h) (concat ( vector (cons h  (vector (take-while #(not (keyword? % )) t))  ))  (p (drop-while #(not (keyword? %)) t))) )) ] (fn [i] (into {} ( map #(apply vector %) (p i) ))  ))", "user": "581a5fdbe4b0e114eb51a002"}, {"problem": 105, "code": "(fn [s]\n    (loop [s s\n           m {}]\n     (if (empty? s)\n      m\n      (let [[k & r] s\n            [v z] (split-with #(not (keyword? %)) r)]\n        (recur z (conj m [k v]))))))", "user": "5742ec91e4b05c31a32c0883"}, {"problem": 105, "code": "(fn kvs\n  ([xs] (kvs [] xs))\n  ([ret xs]\n   (if (empty? xs)\n     (apply hash-map ret)\n     (if (keyword? (first xs))\n       (recur (into ret [(first xs) []]) (rest xs))\n       (recur (conj (vec (butlast ret)) (conj (last ret) (first xs))) (rest xs))))))", "user": "56069006e4b08b23635d3174"}, {"problem": 105, "code": "(fn keyword-map [input-sequence]\n  (loop [result {}\n         active nil\n         queue input-sequence]\n    (cond\n      (empty? queue) result\n      (keyword? (first queue))\n        (recur (assoc result (first queue) []) (first queue) (rest queue))\n      :else\n        (recur\n          (merge-with concat result {active [(first queue)]})\n          active\n          (rest queue)))))", "user": "58247423e4b051871117bec5"}, {"problem": 105, "code": "(fn [n] (dissoc (\nreduce (fn[pre cur](if(keyword? cur ) (assoc pre cur [] :last cur)  (assoc pre (pre :last) (conj (pre(pre :last)) cur) ))) {} n\n\t) :last)\n)", "user": "54edcf96e4b024c67c0cf866"}, {"problem": 105, "code": "(fn [s]\n    (loop [s s ret {}]\n      (if (empty? s)\n        ret\n        (recur (second (split-with number? (rest s)))\n               (assoc ret (first s) (first (split-with number? (rest s))))))))", "user": "55c5b55fe4b0e31453f649b5"}, {"problem": 105, "code": "(fn [c]\n  (loop [m {}\n         [k & r] c]\n    (if-not (seq r)\n      m\n      (let [vs (take-while (complement keyword?) r)\n            rr (drop-while (complement keyword?) r)]\n        (recur (conj m [k vs]) rr)))))", "user": "52173464e4b082aa80a88c75"}, {"problem": 105, "code": "(fn [x] \n  (into {}\n        (\n         (fn to-map [[f & r :as all]] \n           (if (empty? all)\n             '() \n             (let [[a b] (split-with #(not (keyword? %)) r)]  \n              (lazy-seq (cons [f a] (to-map b))))))\n         x )))", "user": "57011eb3e4b08d47c97781d1"}, {"problem": 105, "code": "(fn [coll]\n  (first \n      (reduce \n      (fn [[m k] v]\n        (if (keyword? v)\n          [(update-in m [v] (fn[_] [])) v] \n          [(update-in m [k] #(concat % [v])) k]))\n      [{} (first coll)]\n      (rest coll))))", "user": "57c0917be4b05aa3c4741c95"}, {"problem": 105, "code": "#(loop [[k & r] %\n        acc {}]\n   (if (empty? r)\n     (if k\n       (assoc acc k [])\n       acc)\n     (let [split (split-with number? r)]\n       (recur (second split)\n              (assoc acc k (first split))))))", "user": "54d341f7e4b0e8a36923e603"}, {"problem": 105, "code": "(fn split-map [s]\n  (loop [m {} [k & vs] s]\n    (if (empty? vs)\n      m\n      (recur (conj m [k (into [] (take-while (complement keyword?) vs))])\n             (drop-while (complement keyword?) vs)))))", "user": "58327a08e4b089d5ab817c7c"}, {"problem": 105, "code": "(fn [x] (apply hash-map (reduce (fn [a b] (if (number? b)\n                                            (conj (pop a) (conj (last a) b))\n                                            (conj a b [])\n                                            )) [] x)))", "user": "584dadebe4b0b7285a6f4e44"}, {"problem": 105, "code": "#(loop [m {} xs %]\n   (if (seq xs)\n     (let [[k & xs] xs\n           [values xs] (split-with (complement keyword?) xs)]\n       (recur (assoc m k values) xs))\n     m))", "user": "583e27e2e4b089d5ab817daa"}, {"problem": 105, "code": "(fn [x]\n  (loop [c x r {}]\n    (if (empty? c) r\n      (recur (drop-while (complement keyword?) (rest c))\n             (assoc r (first c) (take-while (complement keyword?) (rest c)))))))", "user": "565b2fa5e4b068f2fe63dbfe"}, {"problem": 105, "code": "(fn [coll]\n  (letfn [(step [c]\n            (if (> (count c) 1)\n              (let [key-size (count (first c))]\n                (if (= key-size 1)\n                  (concat [(first (first c)) (vec (second c))] (step (drop 2 c)))\n                  (concat [(first (first c)) []] (step (cons (rest (first c)) (rest c))))))))]\n    (let [vec-result (step (partition-by keyword? coll))]\n      (if (seq vec-result)\n        (apply (partial assoc {}) vec-result)\n        {}))))", "user": "5849ac5fe4b089d5ab817ed7"}, {"problem": 105, "code": "(fn key-value-seq [x]\n  (letfn [(iter\n           [a b c d]\n           (loop [r a k b l c m d]\n             (if (empty? r)\n               (conj m [k l])\n               (if (keyword? (first r))\n                 (recur (rest r) (first r) [] (conj m [k l]))\n                 (recur (rest r) k (conj l (first r)) m)))))]\n    (if (empty? x)\n      {}\n      (iter (rest x) (first x) [] {}))))", "user": "5843b95de4b089d5ab817e3f"}, {"problem": 105, "code": "(fn [coll]\n  (if (empty? coll)\n    {}\n    (loop [res {}\n           ckey (first coll)\n           vcoll []\n           left-coll (rest coll)]\n      (if (empty? left-coll)\n        (assoc res ckey vcoll)\n        (let [next-is-keyword (keyword? (first left-coll))\n              next-res (if next-is-keyword (assoc res ckey vcoll) res)\n              next-ckey (if next-is-keyword (first left-coll) ckey)\n              next-vcoll (if next-is-keyword [] (conj vcoll (first left-coll)))]\n        (recur next-res next-ckey next-vcoll (rest left-coll)))))))", "user": "585e2e77e4b0f14aab7c87ac"}, {"problem": 105, "code": "(fn key_values [coll]\n  (let [keys_init (zipmap\n                    (filter keyword? coll)\n                    (repeat []))]\n    (loop [c coll current_key nil result keys_init]\n      (if (empty? c)\n          result\n          (let [f (first c)]\n            (if (keyword? f)\n                (recur (rest c) f result)\n                (recur (rest c) current_key (assoc result current_key (#(conj % f) (get result current_key))))))))))", "user": "566ff0a1e4b0a866af6896ec"}, {"problem": 105, "code": "(fn [sequence]\n  (if (empty? sequence)\n    {}\n    ((fn inner [result keyword_ value-list rest_]\n       (if (empty? rest_)\n         (apply hash-map (reverse (conj result\n                                        keyword_\n                                        value-list)))\n         (if (keyword? (first rest_))\n           (inner (conj result\n                        keyword_\n                        (reverse value-list))\n                  (first rest_)\n                  '()\n                  (rest rest_))\n           (inner result \n                  keyword_\n                  (conj value-list (first rest_))\n                  (rest rest_)))))\n     '() (first sequence) '() (rest sequence))))", "user": "58637f03e4b0f14aab7c881e"}, {"problem": 105, "code": "#(loop [l %\n         m {}]\n    (if (empty? l) m\n      (recur (drop-while number? (rest l)) (assoc m (first l) (take-while number? (rest l))))))", "user": "56b6e354e4b0982f16b37e41"}, {"problem": 105, "code": "(fn [coll]\n    (loop [c coll\n           kw nil\n           result {}]\n      (cond\n       \n       (empty? c)\n       (dissoc result nil) ; yuck\n       \n       (keyword? (first c))\n       (recur (rest c) (first c) (update-in result [kw] vec))\n\n       :else\n       (recur (rest c) kw (update-in result [kw] #(vec (conj % (first c)))))\n\n       )\n      )  \n    )", "user": "52dc7344e4b09f7907dd13cf"}, {"problem": 105, "code": "(fn [form]\n  (into {} \n        (reduce \n          (fn [lst el]\n            (if (keyword? el)\n              (cons [el []] lst)\n              (let [[k coll] (first lst)]\n                (cons [k (conj coll el)] (rest lst))\n                ))\n            ) \n          [] \n          form)))", "user": "5665ef78e4b0e91d5f5c5664"}, {"problem": 105, "code": "#(second\n   (reduce\n    (fn [[k m] x]\n      (if (keyword? x)\n        [x (assoc m x [])]\n        [k (assoc m k (conj (k m) x))]))\n    [nil {}]\n    %))", "user": "5458c74de4b01be26fd74623"}, {"problem": 105, "code": "(fn [coll]\n  (loop [coll coll result {} lastKeyword nil]\n    (cond\n      (empty? coll) result\n      (keyword? (first coll)) (recur (rest coll) (assoc result (first coll) []) (first coll))\n      :else (recur (rest coll) (update-in result [lastKeyword] conj (first coll)) lastKeyword))))", "user": "583667c7e4b089d5ab817cfb"}, {"problem": 105, "code": "(fn mapper [coll]\n  (if-let [s (seq coll)]\n    (let [fst (first s)\n          rst (next s)\n          run {fst (into [] (take-while #(not (keyword? %)) rst))}]\n      ;run\n      (merge run (mapper (seq (drop (+ 1 (count (get run (first (keys run))))) s)))))\n    {}))", "user": "56f4cedce4b046a417f92063"}, {"problem": 105, "code": "(fn pp [xs]\n (letfn [(nk[v] (not (keyword? v)))\n         (p [[x :as xs]]\n          (lazy-seq\n           (when (seq xs)\n            (cons [x (into [](take-while nk (next xs)))] (p (drop-while nk (next xs)))))))]\n(into {} (p xs))))", "user": "55597b84e4b0deb715856e36"}, {"problem": 105, "code": "(fn [args]\n  (loop [m {}\n         args args]\n    (if-let [[k & args] (seq args)]\n      (recur (assoc m k (take-while number? args))\n             (drop-while number? args))\n      m)))", "user": "4ff24a1ae4b0678c553fc337"}, {"problem": 105, "code": "#(loop [m {}, [k & r :as coll] %] (if (empty? coll) m (let [[v r] (split-with number? r)] (recur (conj m [k v]) r))))", "user": "580c8fcee4b0849f6811b721"}, {"problem": 105, "code": "(fn id [xs]\n  (if (empty? xs) {}\n    (let [nums (take-while number? (rest xs)) \n          r (drop-while number? (rest xs))] \n      (merge (hash-map (first xs) nums) (id r)))))", "user": "563c7f98e4b0bfe05bf11836"}, {"problem": 105, "code": "(fn identify-keys-vals [coll]\n  (if-let [[key & t] (seq coll)]\n    (let [[vals s] (split-with (complement keyword?) t)]\n      (conj (identify-keys-vals s) {key vals}))\n    {}))", "user": "5879d577e4b01531a375ead8"}, {"problem": 105, "code": "(fn kn->map\n  ([s] (kn->map s {}))\n  ([s m]\n   (if (seq s)\n     (let [k (first s)\n           [v r] (split-with number? (rest s))]\n       (recur r (assoc m k v)))\n     m)))", "user": "56bb652ae4b0f26550335953"}, {"problem": 105, "code": "(fn [d]\n  (if (empty? d)\n    {}\n    (apply assoc {} (reduce\n                     (fn [res it]\n                       (cond (and (keyword? (first it)) (> (count it) 1))\n                              (apply conj res (interpose [] it))\n                             (keyword? (first it))\n                              (conj res (first it))\n                             :else\n                              (conj res it)))\n                     []\n                     (partition-by keyword? d)))))", "user": "586615e6e4b0f14aab7c8858"}, {"problem": 105, "code": "(fn transf [coll]\n  (let [s (partition-all 2 (partition-by keyword? coll))\n        f1 #(map (fn [[[& keys] vals]]\n                   [(last keys)  (vec vals)])\n                 %)\n        f2 #(keep (fn [[[& keys] _]]\n                    (if-let [ks (butlast keys)]\n                      (map (fn [k] [k []]) ks)))\n                  %)]\n    (->> ((juxt f1 (comp first f2)) s)\n        (apply concat)\n        (into {} ))))", "user": "585dbe41e4b0f14aab7c879f"}, {"problem": 105, "code": "(fn [xs] \n  (apply hash-map \n    (reduce     \n      (fn [a x] (if (keyword? x)\n                  (vec (concat a [x []]))\n                  (update-in a [(dec (count a))] #(conj % x))))\n      [] xs)))", "user": "5884e807e4b0f1effa3b76a6"}, {"problem": 105, "code": "#(->> %\n             (reduce (fn [[m k] x]\n                       (if (keyword? x)\n                         [(assoc m x []) x]\n                         [(update-in m [k] conj x) k]))\n                    [{} nil])\n              first)", "user": "58949f8de4b00487982d525e"}, {"problem": 105, "code": "(fn [xs]\n   (loop [xs xs\n          k  nil\n          m  {}]\n     (if (seq xs)\n       (let [x (first xs)]\n         (if (keyword? x)\n           (recur (next xs) x (assoc m x []))\n           (recur (next xs) k (assoc m k (conj (get m k) x))) \n           ))\n       m)))", "user": "500d3160e4b05f7c30cfa6a1"}, {"problem": 105, "code": "(fn [v]\n  (loop [m {} stack [] input v]\n    (cond\n      (empty? input)\n      (if (empty? stack) m (into m {(first stack) (vec (rest stack))}))\n\n      (keyword (first input))\n      (recur (if (empty? stack) m (into m {(first stack) (vec (rest stack))})) [(first input)] (rest input))\n\n      true\n      (recur m (conj stack (first input)) (rest input)))))", "user": "58a0fc33e4b02bd94d917ea3"}, {"problem": 105, "code": "#((fn kv [x]\n    (if (empty? x)\n      {}\n      (if (= (count (first x)) 1)\n        (conj {(first (first x)) (into [] (second x))} (kv (drop 2 x)))\n        (conj (apply assoc {} (concat (butlast (interleave (first x) (repeat []))) (list(vec(second x)))))(kv (drop 2 x))))))(partition-by class %))", "user": "586b6a0ae4b01531a375e957"}, {"problem": 105, "code": "(fn into-map [v]                                     (letfn [(iter [v result]                                       (let [[h & t] v                                            [vs r] (split-with                                             (comp not keyword?) t)]                (if h                                                  (recur r                                                    (assoc result h (vec vs)))                    result)))]                                 (iter v {})))", "user": "5895477fe4b00487982d527c"}, {"problem": 105, "code": "(fn[vs](first(reduce(fn[[m k]v](if(keyword? v)[(assoc m v[])v][(assoc m k(conj(k m)v))k]))[{}nil]vs)))", "user": "5481be5fe4b0e286459a1172"}, {"problem": 105, "code": "(fn [coll]\n  (into {}\n        (reduce (fn [a b]\n                  (let [[k v] (last a)]\n                    (if (keyword? b)\n                      (conj a [b []])\n                      (conj (pop a) [k (conj v b)]))))\n                []\n                coll)))", "user": "58bb218be4b0888cdc949cf4"}, {"problem": 105, "code": "(fn [n]\n     (loop [x n, k nil, v [], result {}]\n       (cond\n         (empty? x) (dissoc (conj result {k v}) nil)\n         (number? (first x))\n         (do\n           ;(println result)\n           (recur (rest x) k (conj v (first x)) result)\n           )\n         (keyword? (first x))\n         (do\n           ;(println result)\n           (recur (rest x) (first x) [] (conj result {k v}))\n           )\n         )\n       )\n     )", "user": "58a44a14e4b01a0c0b2328f2"}, {"problem": 105, "code": "(fn identKV [col]\n  (into\n    {}\n    (reduce\n      (fn [collector item]\n        (if (keyword? item)\n          (concat collector (vector (vector item [])))\n          (let\n            [\n             base (last collector),\n             remaining (reverse (rest (reverse collector)))\n             ]\n            (concat remaining (vector (vector (first base) (conj (second base) item))))\n            )\n          )\n        )\n      []\n      col\n      )\n    )\n  )", "user": "58950f29e4b00487982d5270"}, {"problem": 105, "code": "(fn [a]\n  (loop [m {}, rem a, k nil]\n    (cond (empty? rem) m\n          (keyword? (first rem))  (recur (assoc m (first rem) []) (rest rem) (first rem))\n          :else (recur (update-in m [k] conj (first rem)) (rest rem) k)\n          )\n    )\n  )", "user": "589037b4e4b00487982d51d0"}, {"problem": 105, "code": "(fn [s] (reduce (fn [p e] (let\n                             [\n                              f (first e)\n                              z (map (fn [i] {i []}) (pop (into [] f)))\n                              v (into [] (second e))\n                              r (into (conj p {(last f) v}) z)\n                              ]\n                             r)\n                   ) {}\n                 (partition 2 (partition-by\n                                keyword?\n                                s))))", "user": "58a9e872e4b01a0c0b232973"}, {"problem": 105, "code": "(fn [coll]\n  (first (reduce\n   (fn [[m k] x]\n     (if (keyword? x)\n      [(assoc m x []) x]\n      [(assoc m k (conj (get m k []) x)) k]))\n   [{} nil]\n   coll)))", "user": "58ca8a1de4b03c36ff7e5835"}, {"problem": 105, "code": "#(->> (partition-by keyword? %)\n       (partition 2)\n       (reduce (fn [agg [k v]]\n                 (-> (zipmap (reverse k) (cons v (repeat ())))\n                     (into agg))) {}))", "user": "567d132ee4b05957ce8c61c3"}, {"problem": 105, "code": "#(loop [l %, r {}, k nil]\n   (if (seq l)\n     (let [[h & lr] l]\n       (if (keyword? h)\n         (recur lr (assoc r h []) h)\n         (recur lr (update-in r [k] conj h) k)))\n     r))", "user": "58923efce4b00487982d521c"}, {"problem": 105, "code": "(fn [v]\n  (loop [v v m {}]\n    (if (empty? v)\n      m\n      (if (keyword? (first v))\n        (if (keyword? (second v))\n          (recur (rest v) (assoc m (first v) []))\n          (let [num-vals (count (take-while (comp not keyword?) (rest v)))]\n            (recur (drop num-vals (rest v)) (assoc m (first v) (take num-vals (rest v))))))))))", "user": "53fe1b42e4b0de5c418485f1"}, {"problem": 105, "code": "(fn keys-and-values [xs]\n  (let [{:keys [acc current vals]}\n        (reduce\n         (fn [{:keys [acc current vals]} val]\n           (if (keyword? val)\n             (if (nil? current)\n               {:acc acc\n                :current val\n                :vals vals}\n               {:acc (assoc acc current vals)\n                :current val\n                :vals []})\n             {:acc acc\n              :current current\n              :vals (conj vals val)}))\n         {:acc {}\n          :current nil\n          :vals []}\n         xs)]\n    (if (nil? current)\n      acc\n      (assoc acc current vals))))", "user": "55fbc657e4b0f488688e0666"}, {"problem": 105, "code": "(fn i-k\n  [coll]\n  (loop [coll coll\n         pre-key nil\n         r {}]\n    (if (seq coll)\n      (if (keyword? (first coll))\n        (recur (rest coll) (first coll) (merge r {(first coll) []}))\n        (recur (rest coll) pre-key  (merge r\n                                           {pre-key\n                                            (conj (get r pre-key ) (first coll))})))\n      r)))", "user": "58de563fe4b0a4d5acaab6e3"}, {"problem": 105, "code": "(fn kv [acc k [v & vs]]\n  (cond (nil? v) acc\n        (keyword? v) (kv (assoc acc v []) v vs)\n        :e (kv (update-in acc [k] conj v) k vs))) {} *", "user": "58dcb8cde4b0a4d5acaab6a7"}, {"problem": 105, "code": "(fn reseq [coll]\n  (if (empty? coll)\n      {}\n      (let [k      (first coll)\n            [v tl] (split-with number? (rest coll))]\n        (assoc (reseq tl) k v))))", "user": "58dcf11ae4b0a4d5acaab6af"}, {"problem": 105, "code": "(fn key-num-map [key-num-seq]\n  (loop [kn-map {}\n         kn-seq key-num-seq]\n    (if (empty? kn-seq)\n      kn-map\n      (let [key (first kn-seq)\n            nums (take-while number? (rest kn-seq))]\n        (recur (assoc kn-map key (vec nums)) (drop (inc (count nums)) kn-seq))))))", "user": "58ed713de4b056aecfd47d84"}, {"problem": 105, "code": "(fn\n [kvs]\n (into\n   {}\n   (map\n    (fn [[[k] vs]] (vector k (vec vs)))\n    (partition\n     2\n     (mapcat\n      (fn\n       [items]\n       (if\n        (every? keyword? items)\n        (drop-last (reduce (fn [acc k] (conj (conj acc (list k)) '())) [] items))\n        (list items)))\n      (partition-by keyword? kvs))))))", "user": "5796d3ebe4b039eba2ecb0ee"}, {"problem": 105, "code": "(fn s [[k & v]]\n  (if v\n    (let [[a b] (split-with number? v)]\n      (assoc (s b) k a))\n    {}))", "user": "4dc986d0535d5973398f9285"}, {"problem": 105, "code": "(fn key-group [v]\n  (first (reduce (fn [[hmap prev-keyword :as state] new-el]\n                   (if (keyword? new-el)\n                     (assoc\n                      (assoc state\n                             0\n                             (assoc hmap new-el []))\n                      1\n                      new-el)\n                     (assoc state\n                            0\n                            (assoc hmap prev-keyword (conj (hmap prev-keyword) new-el)))))\n                 [{} nil]\n                 v)))", "user": "58f2e8fbe4b0438e51c2ce94"}, {"problem": 105, "code": "(fn [xs]\n   (apply\n     hash-map\n     (reduce\n       (fn [v x]\n         (if (keyword? x)\n           (conj v x [])\n           (conj \n             (vec (butlast v))\n             (conj (last v) x))))\n       []    \n       xs)))", "user": "51a54fb4e4b0def3c5c586a3"}, {"problem": 105, "code": "(fn [coll]\n  (loop [result {}, key nil, val [], c coll]\n    (if (= 0 (count c))\n      (if (nil? key)\n        result\n        (conj result {key val}))\n      (if (keyword? (first c))\n        (if (nil? key)\n          (recur result (first c) [] (rest c))\n          (recur (conj result {key val}) (first c) [] (rest c)))\n        (if (nil? key)\n          (recur result nil [] (rest c))\n          (recur result key (conj val (first c)) (rest c)))))))", "user": "56c55fbce4b05cc29241eea5"}, {"problem": 105, "code": "(fn kv [acc k [v & vs]]\n  (cond (nil? v) acc\n        (keyword? v) (kv (assoc acc v []) v vs)\n        :e (kv (update-in acc [k] conj v) k vs))) {} *", "user": "53dbca12e4b094d41abdfef6"}, {"problem": 105, "code": "(fn more [i]\n  (if\n   (empty? i)\n   {}\n   (let\n    [start (first i)\n     [end & tail]\n       (if\n        (number? (first (rest i)))\n        (split-with\n         number?\n         (rest i))\n        [[] (rest i)])]\n    (into\n     {}\n     (cons\n      [start (vec end)]\n      (if\n       (or\n        (nil? (first tail))\n        (empty? (first tail)))\n       ()\n       (more (apply\n              concat\n              tail))))))))", "user": "586a657de4b0f14aab7c88bd"}, {"problem": 105, "code": "(fn [xs]\n    (loop [[h & t :as xs] xs\n           k nil\n           accu {}]\n      (if (seq xs)\n        (if (keyword? h)\n          (recur t h (assoc accu h []))\n          (recur t k (assoc accu k (conj (accu k) h))))\n        accu)))", "user": "58ec1e63e4b056aecfd47d54"}, {"problem": 105, "code": "(fn [c] (into {} (reduce #(if (keyword? %2) (conj %1 [%2 []]) (let [l (last %1)] (assoc %1 (dec (count %1)) [(first l) (conj (second l) %2)]))) [] c)))", "user": "58987ee9e4b00487982d52d2"}, {"problem": 105, "code": "(fn [l]\n      (loop [l l, result {}]\n        (if (zero? (count l)) \n          result\n          (let [[k & xs] l\n                [vs ys] (split-with #(not (keyword? %)) xs)]\n            (recur ys (assoc result k vs))))))", "user": "58c4b11ae4b021aa9917ed2c"}, {"problem": 105, "code": "#(loop [xs %, m {}]\n   (if (empty? xs) m\n     (let [[x & xs'] xs, \n           [t d] (split-with (complement keyword?) xs')]\n       (recur d (assoc m x (into [] t))))))", "user": "5566d812e4b0c656e3ff1837"}, {"problem": 105, "code": "(comp first\n        (partial reduce\n           (fn [[acc key] x]\n              (println acc key x)\n              (if (keyword? x)\n                  [(conj acc {x []}) x]\n                  [(conj acc {key (conj (get acc key) x)}) key]))\n           [{} nil]))", "user": "5901158de4b0438e51c2d039"}, {"problem": 105, "code": "(fn p-105 [s]\n  (loop [result {}\n         [current & other] s\n         key nil]\n    (if (nil? current)\n      result\n      (if (keyword? current)\n        (recur (assoc result current []) other current)\n        (recur (update-in result [key] conj current)\n               other key)))))", "user": "501d34f6e4b066e56b9d0b1e"}, {"problem": 105, "code": "(fn [items]\n   (first \n    (reduce (fn [[accum key] next] \n              (if (keyword? next)\n                [(assoc accum  next []) next]\n                [(assoc accum key (conj (get accum key) next)) key])) \n            [{} nil] items)))", "user": "58d27bcae4b03c36ff7e58fe"}, {"problem": 105, "code": "(fn id-key-val [coll]\n  (letfn [(take-next-num-seq [seq]\n                              (take-while (comp not keyword?) seq))\n          (drop-next-num-seq [seq]\n                              (drop-while (comp not keyword?) seq))]\n    (loop [res {}, rem coll]\n      (if (empty? rem)\n        res\n        (recur (assoc res (first rem) (take-next-num-seq (rest rem)))\n               (drop-next-num-seq (rest rem)))))))", "user": "590b3aeae4b047aa04b199d0"}, {"problem": 105, "code": "(fn\n  [l]\n  (if (= 0 (count l))\n    {}\n    (let [p (partition-by keyword? l)\n          d (partition 2 p)]\n      (apply merge\n             (flatten\n              (map (fn\n                     [x]\n                     (let [k (reverse (first x))\n                           v (second x)]\n                       (if (= (count k) 1)\n                         (hash-map (first k) v)\n                         (zipmap k (concat (list v)\n                                           (repeat (- (count k) 1) '()))))))\n                   d))))))", "user": "5893c64ce4b00487982d524b"}, {"problem": 105, "code": "#(apply array-map\n\t(reduce \n\t\t(fn [v el] \n\t\t\t(if (keyword? el) \n\t\t\t\t(conj v el [])\n\t\t\t\t(conj (vec (butlast v)) (conj (last v) el))\n\t\t\t)\n\t\t) [] %)\n)", "user": "52570aeae4b0541d1855ba42"}, {"problem": 105, "code": "(fn identify [[k & ints]]\n  (let [[k-nums more] ((juxt take-while drop-while) integer? ints)]\n    (if (seq ints)\n      (merge (assoc {} k k-nums) (identify more))\n      {})))", "user": "58ffac9de4b0438e51c2cffd"}, {"problem": 105, "code": "(fn identify-keys-and-values [col]\n  (loop [c col k nil v [] result {}]\n    (cond\n      (empty? c) (dissoc (conj result {k v}) nil)\n      (number? (first c))\n        (recur (rest c) k (conj v (first c)) result)\n      (keyword? (first col))\n        (recur (rest c) (first c) [] (conj result {k v})))))", "user": "591072e0e4b0163c97b36ebc"}, {"problem": 105, "code": "(fn [s]\n    (->> (mapcat #(if (keyword? %) [% []] [%]) s)\n         (partition-by keyword? )\n         (map #(if (keyword? (first %)) (first %) (if (> (count %) 1) (apply conj %) [])))\n         (apply hash-map)\n\n         )\n    )", "user": "5921a080e4b09b4ee5954c77"}, {"problem": 105, "code": "(let [pkey (atom 0)\n      pfunc (fn [i] (if (keyword? i)\n                      (swap! pkey inc)\n                      @pkey))]\n  (fn [inputs]\n    (->> inputs\n         (partition-by pfunc)\n         (map (juxt first rest))\n         (into {}))))", "user": "50b65966e4b0a86f8358ca6c"}, {"problem": 105, "code": "(fn [x] (apply array-map \n  (mapcat #(if (keyword (first %)) (interpose [] %) (list (apply vector %))) \n    (partition-by keyword? x))))", "user": "58e7229fe4b056aecfd47cc4"}, {"problem": 105, "code": "(fn [init-vector]\n  (loop [res {}, rest-v init-vector]\n    (if (empty? rest-v)\n      res\n      (let [k (first rest-v),\n            v (apply vector (take-while #(not (keyword? %)) (rest rest-v)))]\n        (recur (assoc res k v)\n               (drop (+ 1 (count v)) rest-v))))))", "user": "59225498e4b09b4ee5954c8c"}, {"problem": 105, "code": "(fn [l]\n  \t(if (empty? l)\n  \t{}\n  \t(loop [news {} tmpl (rest l) tmps '() keyw (first l)]\n  \t\t(if (empty? tmpl)\n  \t\t\t(assoc news keyw (reverse tmps))\n  \t\t\t(if (keyword? (first tmpl))\n  \t\t\t\t(recur (assoc news keyw (reverse tmps)) (rest tmpl) '() (first tmpl))\n  \t\t\t\t(recur news (rest tmpl) (conj tmps (first tmpl)) keyw))))))", "user": "59368ccae4b02506e01a297a"}, {"problem": 105, "code": "(fn [s]\n  (loop [col (seq s) acc {}]\n    (if (seq col)\n      (let [[kw & more] col]\n      \t(recur (drop-while number? more)\n             (assoc acc kw (vec (take-while number? more)))))\n      acc)))", "user": "51990df9e4b068aa333628fc"}, {"problem": 105, "code": "(fn [s]\n\t(loop [new {} tmp 0 lst s]\n\t\t(if (empty? lst)\n\t\t\tnew\n\t\t\t(if (keyword? (first lst))\n\t\t\t\t(recur (assoc new (first lst) []) (first lst) (rest lst))\n\t\t\t\t(recur (assoc new tmp (conj (get new tmp) (first lst))) tmp (rest lst))))))", "user": "59368ccae4b02506e01a2979"}, {"problem": 105, "code": "(fn [vect1]\n  (loop [vect vect1, keyc (first vect1), ans {}]\n    (if (empty? vect)\n      ans\n      (if (keyword? (first vect))\n        (recur (rest vect) (first vect) (assoc ans (first vect) []))\n        (recur (rest vect) keyc (assoc ans keyc (conj (keyc ans) (first vect))))))))", "user": "59369515e4b02506e01a297e"}, {"problem": 105, "code": "(fn [s]\n  (into {}\n        (reduce (fn [r x]\n                  (if (keyword? x)\n                    (into [] (cons [x []] r))\n                    (update-in r [0 1] conj x)))\n                []\n                s)))", "user": "580bd81ee4b0849f6811b711"}, {"problem": 105, "code": "(fn [coll]\n  (apply merge\n         {}\n         (reduce #(if (= (type %2) clojure.lang.Keyword)\n                    (conj %1 [%2 []])\n                    (update-in %1 [(dec (count %1)) 1] conj %2))\n                 []\n                 coll)))", "user": "594783bee4b07ddc2dafada1"}, {"problem": 105, "code": "(fn [coll]\n   (if (empty? coll) {}\n    (first\n      (reduce\n        (fn [[m ck] n]\n          (if (keyword? n)\n            [(assoc m n []) n]\n            [(update-in m [ck] conj n) ck]))\n        [{(first coll) []} (first coll)] (rest coll)))))", "user": "55c66ffee4b0e31453f649c2"}, {"problem": 105, "code": "(fn kv [acc k [v & vs]]\n  (cond (nil? v) acc\n        (keyword? v) (kv (assoc acc v []) v vs)\n        :e (kv (update-in acc [k] conj v) k vs))) {} *", "user": "5948adffe4b07ddc2dafadc6"}, {"problem": 105, "code": "(fn kv [acc k [v & vs]]\n  (cond (nil? v) acc\n        (keyword? v) (kv (assoc acc v []) v vs)\n        :e (kv (update-in acc [k] conj v) k vs))) {} *", "user": "59251947e4b072a2710fce69"}, {"problem": 105, "code": "(fn kv [acc k [v & vs]]\n  (cond (nil? v) acc\n        (keyword? v) (kv (assoc acc v []) v vs)\n        :e (kv (update-in acc [k] conj v) k vs))) {} *", "user": "592518e8e4b072a2710fce67"}, {"problem": 105, "code": "(fn kv [acc k [v & vs]]\n  (cond (nil? v) acc\n        (keyword? v) (kv (assoc acc v []) v vs)\n        :e (kv (update-in acc [k] conj v) k vs))) {} *", "user": "592519cfe4b072a2710fce6b"}, {"problem": 105, "code": "(fn [s]\n   (loop [kw nil, acc {}, [e & tail] s]\n     (cond (nil? e) acc\n           (keyword? e) (recur e (assoc acc e []) tail)\n           :default (recur kw (update-in acc [kw] #(conj % e)) tail))))", "user": "5935b010e4b04f87174def55"}, {"problem": 105, "code": "(fn build-map \n  ([col] \n   (if (empty? col)\n     {}\n     (into {} (build-map (rest col) \n                         [] \n                         [(first col) []]))))  \n  ([col result entry] \n   (if (empty? col) \n     (if (empty? entry) \n       result \n       (conj result entry))\n     (if (keyword? (first col))\n       (recur (rest col)\n              (conj result entry)\n              [(first col) []])\n       (recur (rest col) \n              result\n              [(first entry) (conj (second entry) (first col))])))))", "user": "5956c6dae4b066ee0a44af61"}, {"problem": 105, "code": "(fn [s]\n  (loop [s s out {} current nil]\n    (if-let [n (first s)]\n      (if (keyword? n)\n        (recur (next s) (assoc out n []) n)\n        (recur (next s) (update-in out [current] conj n) current))\n      out)))", "user": "5958cef6e4b066ee0a44af94"}, {"problem": 105, "code": "(fn [xs]\n  (loop [m {} [h & t] xs]\n    (if (nil? h)\n      m\n      (recur (assoc m h (take-while number? t))\n             (drop-while number? t)))))", "user": "594880ade4b07ddc2dafadc2"}, {"problem": 105, "code": "(fn __\n  ([x] (__ x {}))\n  ([x res]\n  (if (empty? x)\n    res\n    (let [\n          keyw (first x)\n          pars (take-while (fn [x] (not (keyword? x))) (rest x))\n          todrop (inc (count pars))\n          newRes (assoc res keyw pars)\n          ]\n       (__ (drop todrop x) newRes)))))", "user": "58bc6a88e4b0888cdc949d16"}, {"problem": 105, "code": "(fn [lst]\n  (dissoc (reduce\n    (fn [acc x]\n      (if (keyword? x)\n        (assoc acc x [] :curr x)\n        (update-in acc [(:curr acc)] conj x)\n      )\n    )\n    {}\n    lst\n  ) :curr)\n)", "user": "5943abb6e4b060784b3b792b"}, {"problem": 105, "code": "(fn f105\n  [col]\n  (loop [[x & xs] col res {}]\n    (if x\n      (when (keyword? x)\n        (recur (drop-while integer? xs) (merge res (hash-map x (take-while integer? xs)))))\n      res)))", "user": "59390a35e4b02506e01a29f3"}, {"problem": 105, "code": "#(loop[result {}, k (first %), v [], remaining (rest %)]\n   (if-let [newVal (first remaining)]\n     (if \n       (keyword? newVal) (recur (assoc result k v) newVal [] (rest remaining))\n       (recur result k (conj v newVal) (rest remaining)))\n     (if (nil? k) result\n       (assoc result k v))))", "user": "593f95d8e4b069cdc2982be3"}, {"problem": 105, "code": "(fn ikv [xs]\n  (->> xs\n    (partition-by keyword?)\n    (partition 2)\n    (map (fn [[kk v]] (apply merge {(last kk) v} (map #(hash-map % []) (butlast kk)))))\n    (apply merge {})))", "user": "58ee84e5e4b056aecfd47dab"}, {"problem": 105, "code": "(fn solution105\n  [coll]\n  (first (reduce (fn [[ans curr k] elem]\n            (if (keyword? elem)\n              (if (nil? k)\n                [ans curr elem]\n                [(assoc ans k curr) [] elem])\n              [ans (conj curr elem) k])) [{} [] nil] (conj coll :kkk))))", "user": "595bc925e4b066ee0a44afe2"}, {"problem": 105, "code": "(fn ikav [s]\n  (if (empty? s)\n    (hash-map)\n    (let [ [keywd tail]   (split-at 1 s)\n           [value recurs] (split-with (complement keyword?) tail)]\n      (assoc (ikav recurs) (first keywd) (vec value)))))", "user": "590b055ae4b047aa04b199c9"}, {"problem": 105, "code": "#(apply hash-map (mapcat (fn [[x :as xs]] (if (keyword? x) (interpose [] xs) [xs])) (partition-by keyword? %)))", "user": "4fb1d7ace4b081705acca281"}, {"problem": 105, "code": "(fn v->m [v]\n  (loop [v v, k nil, m {}]\n    (let [e (first v)]\n      (if (keyword? e)\n        (recur (rest v) e (assoc m e []))\n        (if (number? e)\n          (recur (rest v) k (assoc m k (conj (m k) e)))\n          m)))))", "user": "57ee804ee4b0bfb2137f5bbb"}, {"problem": 105, "code": "(fn list-to-map ([l] (list-to-map l {}))\n  ([l m] (let [[head tail] (split-with keyword? l)]\n           (if (empty? tail) m\n               (let [k (last head)\n                     e (butlast head)\n                     [v rst] (split-with (complement keyword?) tail)]\n                 (list-to-map rst (assoc (reduce #(assoc %1 %2 '()) m e) k v)))))))", "user": "587ee260e4b052da650a6353"}, {"problem": 105, "code": "#(loop\n   [m {} v %1]\n   (if (empty? v)\n     m\n     (recur (conj m [(first v) (take-while number? (rest v))])\n            (drop-while number? (rest v)))))", "user": "59921901e4b0866487ed0d71"}, {"problem": 105, "code": "(fn [coll] (->> (concat coll [nil])\n                (interpose nil)\n                (clojure.core/partition-by keyword?)\n                (map (partial keep identity))\n                (partition 2)\n                (map (juxt (comp first first) second))\n                (into {})))", "user": "5960a1a6e4b066ee0a44b08e"}, {"problem": 105, "code": "(fn [coll]\n  (loop [result {} k nil items coll]\n    (cond\n      (empty? items) result\n      (keyword? (first items)) (recur (assoc result (first items) []) (first items) (rest items))\n      :else\n        (recur (assoc result k (conj (get result k)  (first items))) k (rest items))\n    )\n  )\n)", "user": "5991d2fae4b0866487ed0d68"}, {"problem": 105, "code": "(fn to-map [col]\n  (first\n   (reduce (fn [[res key] cur]\n             (if (keyword? cur)\n               [(into res {cur []}) cur]\n               (let [key-entry (get res key)\n                     key-entry (conj key-entry cur)]\n                 [(into res {key key-entry}) key])))\n           [{} (first col)] col)))", "user": "58fc92c5e4b0438e51c2cf9a"}, {"problem": 105, "code": "(fn k[sx] (reduce conj {} (reduce #(\n           if (keyword? %2)\n           (conj %1 [%2 []])\n           (conj (rest %1) [(first (first %1)) (conj (last (first %1)) %2)])\n           ) () sx)))", "user": "596f6683e4b069c0a1a19877"}, {"problem": 105, "code": "(fn [coll]                                                              \n  (let [stat-reducer (fn [acc el]                                                   \n                       (if (keyword? el)                                            \n                         (conj acc el [])                                           \n                         (let [keyword-seq (last acc)]                              \n                           (conj (-> acc butlast vec) (conj keyword-seq el)))))  \n        stats-in-seq (reduce stat-reducer [] coll)]                                 \n    (apply array-map stats-in-seq)))", "user": "58ebd10de4b056aecfd47d49"}, {"problem": 105, "code": "(fn identify\n\t([s]\n\t\t(identify s {} (first s)))\n\t([s r k]\n\t\t(if (empty? s)\n\t\t\tr\n\t\t\t(if (keyword? (first s))\n\t\t\t\t(recur (rest s) (assoc r (first s) []) (first s))\n\t\t\t\t(recur (rest s) (assoc r k (conj (r k) (first s))) k)))))", "user": "5954eef0e4b066ee0a44af17"}, {"problem": 105, "code": "(fn[coll]\n        (loop [[head & more] coll last nil res {}]\n          (cond\n           (nil? head)\n           res\n\n           (keyword? head)\n           (recur more head (assoc res head []))\n\n           :else\n           (recur more last (assoc res last \n                                   (conj (get res last) head))))))", "user": "57e6f90de4b0bfb2137f5af6"}, {"problem": 105, "code": "(fn key-vals [s]\n    (reduce (fn [a b] \n    (if (keyword? b)\n        (assoc a b [])\n        (assoc a (first (last a)) (conj (second (last a)) b))\n    )) (sorted-map) s)\n)", "user": "59a0262ee4b0871e7608b82d"}, {"problem": 105, "code": "#(->> (partition-by keyword? %)\n       (partition 2)\n       (reduce (fn [agg [k v]]\n                 (-> (zipmap (reverse k) (cons v (repeat ())))\n                     (into agg))) {}))", "user": "596d630ae4b069c0a1a19846"}, {"problem": 105, "code": "(fn keys-and-values\n   ([coll] (keys-and-values nil {} coll))\n   ([cur m coll]\n    (if (seq coll)\n      (let [n (first coll) r (rest coll)]\n        (if (keyword? n)\n           (recur n (assoc-in m [n] []) r)\n           (recur cur (update-in m [cur] #(conj % n)) r)))\n      m)))", "user": "58b51e05e4b0ebc645576d4c"}, {"problem": 105, "code": "(fn zzz [lst]\n  (into\n    {}\n    ((fn xxx [lst]\n       (if (keyword? (first lst))\n         (let [[nums rst] (split-with number? (rest lst))]\n           (cons [(first lst) nums] (xxx rst)))\n         (list)))\n     lst)))", "user": "562add6de4b00e49c7cb4834"}, {"problem": 105, "code": "(fn kv [acc k [v & vs]]\n  (cond (nil? v) acc\n        (keyword? v) (kv (assoc acc v []) v vs)\n        :e (kv (update-in acc [k] conj v) k vs))) {} *", "user": "59358f74e4b04f87174def52"}, {"problem": 105, "code": "(fn [coll]\n  (->> coll\n       (reduce (fn [[m k] v]\n                 (if (keyword? v)\n                   [(assoc m v []) v]\n                   [(assoc m k (conj (m k) v)) k])) [])\n       (first)\n       (into {})))", "user": "59eb63e3e4b0249b7282077c"}, {"problem": 105, "code": "(fn  [coll]\n (first\n   (reduce \n     (fn [[s last-k] x]\n       (cond\n         (keyword? x) [(assoc s x []),x]\n         (nil? last-k) [s nil]\n         :else [(assoc s last-k (conj (get s last-k) x)) last-k]))  \n     [{},nil] coll)))", "user": "5794fd7be4b0e215f87e8476"}, {"problem": 105, "code": "(fn to-map [coll]\n  (loop [result {} s coll]\n    (if (empty? s)\n      result\n      (let [k (first s)\n            [v r] (split-with #(not (keyword? %)) (rest s))]\n        (recur (assoc result k v) r)))))", "user": "59f78b49e4b0ca45a743a30e"}, {"problem": 105, "code": "#(loop[lst %\n       finalMap {}]\n  (if (empty? lst)\n      finalMap\n      (if (keyword? (first lst))\n      (do \n      (let [mapKey (first lst)\n            mapVal (into [] (take-while (fn[item] (not (keyword? item))) (rest lst)))]\n          (recur (rest lst) (assoc finalMap mapKey mapVal))))\n      (recur (rest lst) finalMap)\n      )\n  )\n)", "user": "571172ece4b09c608db70446"}, {"problem": 105, "code": "(fn [coll]\n  (cond\n    (empty? coll) {}\n    :else (apply assoc {} \n         \t(mapcat #(if (keyword? (first %))\n                       (drop-last (interleave % (repeat [])))\n                       [%])\n                    (partition-by keyword? coll)))))", "user": "572de985e4b0cd1946bd0f7c"}, {"problem": 105, "code": "(fn v->m\n  [l]\n  (loop [m {}\n         l l\n         k (first l)]\n    (let [fl (first l)\n          rl (rest l)]\n      (if (empty? l)\n        m\n        (if (keyword? fl)\n          (recur (merge m {fl []}) rl fl)\n          (recur (merge-with conj m {k fl}) rl k))))))", "user": "54a11042e4b09f271ff37c49"}, {"problem": 105, "code": "(fn keys-vals[s]\n  (if (seq s)\n    (let [k (first s) \n          [vals remains] (split-with (complement keyword?) (rest s))]\n      (assoc (keys-vals remains) k vals))\n    {}))", "user": "5880e38fe4b0f1effa3b7625"}, {"problem": 105, "code": "#(->> (reduce\n        (fn [m e]\n          (if (keyword? e)\n             (conj m [e []])\n             (let [[k vs] (first m)]\n                (conj (rest m) [k (conj vs e)]))))\n        '() %)\n      (into {}))", "user": "59fa241ee4b0ca45a743a358"}, {"problem": 105, "code": "#(loop [inp % res {}]\n  (if (keyword? (first inp))\n    (recur (vec (drop-while (complement keyword?) (rest inp)))\n           (assoc res (first inp) (vec (take-while (complement keyword?) (rest inp))))\n           )\n    res\n    ) \n  )", "user": "58d1c1b1e4b03c36ff7e58ef"}, {"problem": 105, "code": "(fn [c]\n  (->> c\n       (partition-by keyword?)\n       (partition 2)\n       (reduce (fn [m [ks vs]]\n                 (assoc (reduce #(assoc % %2 []) m (butlast ks))\n                        (last ks) vs))\n               {})))", "user": "53ea5851e4b036ad0777e4e4"}, {"problem": 105, "code": "#(loop [[k & vs] %\n         m {}]\n    (if k\n      (recur (drop-while number? vs)\n             (assoc m k (take-while number? vs)))\n       m))", "user": "54497569e4b032a45b8693d2"}, {"problem": 105, "code": "#(apply hash-map\n         (reduce (fn [acc cur] (if (keyword? cur)\n                                   (conj acc cur [])\n                         \t\t   (conj (pop acc) \n                                \t     (conj (last acc) cur))))\n                                 []\n                                 %))", "user": "58ffaddee4b0438e51c2cffe"}, {"problem": 105, "code": "(fn\n  [c]\n  (:r \n   (reduce \n      #(if (keyword? %2)\n         (-> %1 (assoc :k %2) (assoc-in [:r %2] [])) \n         (update-in %1 [:r (:k %1)] conj %2)) \n      {:r {}} c)))", "user": "59f91b99e4b0ca45a743a33a"}, {"problem": 105, "code": "(fn __ [col]\n  (loop [k nil\n         vs col\n         acc {}]\n    (if (empty? vs) acc\n      (let [h (first vs)]\n        (if (keyword? h)\n          (recur h (rest vs) (assoc acc h []))\n          (recur k (rest vs) (assoc acc k (conj (acc k) h))))))))", "user": "58f44c07e4b0438e51c2ceb7"}, {"problem": 105, "code": "(fn [xs] (letfn [(rmap [m k t ys] \n                   (let [y1 (first ys)]\n                       (if y1 (if (= (type :a) (type y1))\n                                  (recur (assoc m k t) y1 [] (rest ys) )\n                                  (recur m k (conj t y1) (rest ys) )\n                              )\n                           (assoc m k t)\n                       )\n                    )\n                    )]\n           (if (first xs) \n               (rmap {} (first xs) [] (rest xs))\n               {}\n           )\n         ))", "user": "59ff9424e4b01bb0ae8afd24"}, {"problem": 105, "code": "(fn [s]\n  (first (reduce\n    (fn [[m k] x]\n      (if (keyword? x)\n        [(assoc m x '()) x]\n        [(assoc m k (concat (get m k) (list x))) k]))\n    [{} nil]\n    s)))", "user": "578cf84ce4b0ebec4cfb7562"}, {"problem": 105, "code": "(fn [l]\n  (loop [l l m {} k nil]\n    (if (empty? l)\n      m\n      (if (keyword? (first l))\n        (recur\n          (rest l)\n          (merge-with concat m {(first l) []})\n          (first l))\n        (recur\n          (rest l)\n          (merge-with concat m {k [(first l)]})\n          k)))))", "user": "5a2df4a0e4b09cafd31c7f74"}, {"problem": 105, "code": "(fn [xs] \n\t(->> ((fn f [els acc]\n\t\t     (if (empty? els)\n\t\t         acc \n\t\t         (if (keyword? (first els))\n\t\t             (f (rest els) (conj acc (first els) []))\n\t\t             (f (rest els) (conj (pop acc) (conj (last acc) (first els))))))) xs [])\n\t\t    (apply hash-map)))", "user": "5a14228fe4b0ff51aa4b3193"}, {"problem": 105, "code": "(fn [s]\n    (if (empty? s)\n        {}\n        (loop [first? true\n               x (first s)\n               xs (rest s)\n               kv nil\n               vs []\n               m {}]\n             (if (empty? xs)\n                 (if (keyword? x)\n                     (assoc m x vs)\n                     (if (nil? kv)\n                         m\n                         (assoc m kv (conj vs x))))\n                 (if (keyword? x)\n                     (if first?\n                         (recur false (first xs) (rest xs) x vs m)\n                         (recur false (first xs) (rest xs) x [] (assoc m kv vs)))\n                     (recur false (first xs) (rest xs) kv (conj vs x) m))))))", "user": "5a34f342e4b0ddc586f153d1"}, {"problem": 105, "code": "(fn aa[t]\n  (let [j (->> t\n               (partition-by keyword?)\n               (map vec)\n               (mapcat #(if (and (some keyword? %) (< 1 (count %)))\n                          (interpose [] (partition-by identity %))\n                          [%]))\n               (partition 2))\n        ]\n    (zipmap (flatten (map first j)) (map last j))))", "user": "52f426fce4b05e3f0be25f1e"}, {"problem": 105, "code": "(fn identify [[x & xs]]\n   (let [not-kw (comp not keyword?)]\n      (if x\n         (assoc (identify (drop-while not-kw xs)) x (take-while not-kw xs))\n         {})))", "user": "59f043d0e4b0966464fe6a3d"}, {"problem": 105, "code": "(fn\n  [coll]\n  (->> (loop [o [] coll coll]\n         (if-not (empty? coll)\n           (let [v (first coll)]\n             (if (keyword? v)\n               (recur (concat o [v []])\n                      (drop 1 coll))\n               (recur (concat (drop-last o) [(conj (last o) v)])\n                      (drop 1 coll))))\n           o))\n       (partition 2)\n       (reduce (fn [coll [k v]]\n                 (assoc coll k v)) {})))", "user": "51c8f1d8e4b07ef393169e5d"}, {"problem": 105, "code": "(fn [coll]\n  (if (empty? coll)\n    {}\n    (loop [[peeked & tokens] coll acc {peeked []} old_key peeked]\n      (cond\n        (nil? peeked) acc\n        (keyword? peeked) (recur tokens (assoc acc peeked []) peeked)\n        :else (recur tokens (update-in acc [old_key] conj peeked) old_key)))))", "user": "5773f3a9e4b0979f896515f2"}, {"problem": 105, "code": "#(first (reduce (fn [[a k] x]\n  (if (keyword? x) [(assoc a x []) x] [(assoc a k (conj (a k) x)) k])) [{} nil] %))", "user": "5a4de614e4b05d388ecb6bb1"}, {"problem": 105, "code": "(fn k-and-v [kvs]\n  (loop [m {}\n         rem kvs]\n    (if (empty? rem)\n      m\n      (recur (assoc m \n                    (first rem)\n                    (into [] (take-while #(not (keyword? %)) (rest rem))))\n             (drop-while #(not (keyword %)) (rest rem))))))", "user": "57a0f256e4b0c3d858beb8dd"}, {"problem": 105, "code": "#(->> %\n      (filter keyword?)\n      (map (fn [k] (->> %\n                        (drop-while (partial not= k))\n                        (rest)\n                        (take-while number?)\n                        (vector k))))\n      (into {}))", "user": "51dafedee4b09f6bc204eee2"}, {"problem": 105, "code": "(fn [vs]\n  (loop [xs vs\n         lkey nil\n         r {}]\n    (if (empty? xs) r\n        (let [h (first xs)\n              k (if (keyword? h) h lkey)\n              c (get r k [])]\n          (recur (rest xs) k\n                 (if (keyword? h)\n                   (assoc r k [])\n                   (assoc r k (conj c h))))))))", "user": "5866b999e4b0f14aab7c886b"}, {"problem": 105, "code": "(fn [c]\n  (apply hash-map\n         (reduce (fn [acc i]\n                   (if (keyword? i)\n                     (concat acc [i []])\n                     (concat (butlast acc)\n                             [(conj (last acc) i)] )))\n                 []\n                 c)))", "user": "56441634e4b0018b46ad8c08"}, {"problem": 105, "code": "(fn iden-keys-vals\n  [coll]\n   (reduce #(let [k (ffirst %2)]\n                (assoc %1 k (vec (filter (complement keyword?) (last %2)))))\n             {}\n           (filter #(keyword? (ffirst %)) (partition 2 1 (partition-by keyword coll)))))", "user": "565654dae4b0f9d632dd849f"}, {"problem": 105, "code": "(fn [ys]\n   (if (empty? ys)\n      {}\n      (loop [xs (rest ys)  hm {(first ys) []} kw (first ys)]\n       (if (empty? xs)\n            hm\n            (recur (rest xs) \n                   (if (keyword? (first xs))\n                    (into hm {(first xs) []}  )\n                    (into hm {kw (conj (get hm kw) (first xs))}  )\n                   )\n                   (if (keyword? (first xs)) \n                      (first xs)\n                      kw\n                   )\n             )\n        )\n      )\n    )\n  )", "user": "55d7312ee4b0e31453f64a9f"}, {"problem": 105, "code": "(fn [lst] (let [update (fn [m k f] (assoc m k (f (get m k))))]\n            (dissoc (reduce (fn [m v]\n                   (if (keyword? v)\n                       (assoc m v      []\n                                ::last v)\n                       (update m (::last m) #(conj % v)))) {} lst) ::last)))", "user": "5a566e8fe4b05d388ecb6c51"}, {"problem": 105, "code": "(fn f\n  ([s] (f s {} nil []))\n  ([s m k t] (if\n               (empty? s)\n               (conj m (if (nil? k) nil [k t]))\n               (recur\n                (rest s)\n                (conj m (if (nil? k) nil [k t]))\n                (if (= clojure.lang.Keyword (class (first s))) (first s) k)\n                (if (= clojure.lang.Keyword (class (first s))) [] (conj t (first s)))\n                )))\n  )", "user": "5a3c2a08e4b001c08efc0cdf"}, {"problem": 105, "code": "(fn getter2 [[kw & rst]]\n  (if (coll? rst)\n    (let [[nums others]\n          (split-with (complement keyword?) rst)]\n      (conj (getter2 others) [kw nums]))\n    {}))", "user": "5a527beee4b05d388ecb6bfe"}, {"problem": 105, "code": "(fn mapify [s]\n  (if (seq s)\n    (second\n     (reduce\n      #(let [[last-key res] %1]\n         (if (keyword? %2)\n           [%2 (assoc res %2 [])]\n           [last-key\n            (assoc res last-key (conj (last-key res) %2))]))\n      [(first s) {(first s) []}]\n      (rest s)))\n    {}))", "user": "5a6b9b95e4b0512ff01cda40"}, {"problem": 105, "code": "(fn [coll]\n    (loop [kw (first coll)\n           left (rest coll)\n           out {}]\n      (if-not (seq left)\n        out\n        (let [this-elem (first left)]\n          (if (keyword? this-elem)\n            (recur this-elem (rest left) (assoc out this-elem []))\n            (recur kw (rest left) (merge-with concat out {kw [this-elem]})))))))", "user": "53716539e4b0fc7073fd6eb1"}, {"problem": 105, "code": "(fn split\n  ([coll] (split coll {}))\n  ([coll m]\n   (if-let [[k & r] (seq coll)]\n     (let [nums (take-while integer? r)]\n       (recur (drop (count nums) r) (assoc m k nums)))\n     m)))", "user": "59c94a69e4b0a024fb6ae576"}, {"problem": 105, "code": "(fn split-keys-and-values[s]\n  (letfn [(go [s]\n    (lazy-seq \n      (when (seq s)\n        (let [k (first s)\n             [vs r] (split-with (comp not keyword?) (rest s))]\n          (cons [k vs] (split-keys-and-values r))))))]\n    (into {} (go s))))", "user": "4fd4bddce4b0d4de60cee36e"}, {"problem": 105, "code": "(fn [blob]\n  (->> blob\n       (partition-by type)\n       (partition 2)\n       (reduce \n        (fn [res [kw n]]\n          (let \n            [empties (map hash-map kw (repeat []))\n             res (into res empties)\n             res (conj res [(last kw) n])\n            ] (into {} res)\n            ))\n        {})))", "user": "533a2f7be4b0e30313ee6cb8"}, {"problem": 105, "code": "(fn seq-to-map [seq]\n    (loop [[f & l] seq acc {} curkey nil vals []]\n        (cond\n            (nil? f) (if (nil? curkey) acc (assoc acc curkey vals))\n            (keyword? f)\n                (recur \n                    l\n                    (if (nil? curkey) acc (assoc acc curkey vals))\n                    f\n                    [])\n            :else (recur l acc curkey (conj vals f)))))", "user": "551afdf8e4b07993ea3788cb"}, {"problem": 105, "code": "(fn kv [acc k [v & vs]]\n  (cond (nil? v) acc\n        (keyword? v) (kv (assoc acc v []) v vs)\n        :e (kv (update-in acc [k] conj v) k vs))) {} *", "user": "5a4b3abde4b05d388ecb6b81"}, {"problem": 105, "code": "(fn [col]\n  (loop [ncol col\n         result {}]\n    (if (not-empty ncol)\n      (recur (drop-while number? (rest ncol)) \n             (assoc result \n               (first ncol) \n               (vec (take-while number? (rest ncol)))))\n      result)))", "user": "5835cb06e4b089d5ab817cea"}, {"problem": 105, "code": "(fn idf\n  [kv]\n  (->> (partition-by keyword? kv)\n       (partition-all 2)\n       (mapcat #(let [keywords (first %)\n                      values (second %)\n                      no-vals (drop-last keywords)]\n                  (if (seq values)\n                    (apply vector\n                           (last keywords)\n                           (vec values)\n                           (interleave no-vals (repeat [])))\n                    (apply vector\n                           (interleave keywords (repeat []))))))\n       (apply hash-map)))", "user": "5974d2ede4b01722bebd4cb6"}, {"problem": 105, "code": "(fn idkv\n    [coll]\n    (let [state (reduce\n                    (fn [state val]\n                      (if (keyword? val)\n                        (-> state\n                          (assoc :current-key val)\n                          (assoc-in [:result val] []))\n                        (update-in\n                          state\n                          [:result (:current-key state)]\n                          conj\n                          val)))\n                    {:result {}\n                     :current-key nil}\n                    coll)]\n      (:result state)))", "user": "4e0bb9fb535d04ed9115e7b2"}, {"problem": 105, "code": "(fn kv [acc k [v & vs]]\n  (cond (nil? v) acc\n        (keyword? v) (kv (assoc acc v []) v vs)\n        :e (kv (update-in acc [k] conj v) k vs))) {} *", "user": "5a426a3fe4b0447ef91cc5f2"}, {"problem": 105, "code": "(fn [coll]\n  (letfn [(pairs [coll] (if-let [k (first coll)] (cons [k (take-while number? (rest coll))] (pairs (drop-while number? (rest coll))))))]\n    (into {} (pairs coll))))", "user": "5a9dbb32e4b0d174b936c7f3"}, {"problem": 105, "code": "(fn id-keys-vals [input]\n  (loop [result {}\n         xs input\n         last-key nil]\n    (let [current (first xs)]\n      (if (empty? xs)\n        result\n        (if (keyword? current)\n          (recur (assoc result current []) (rest xs) current)\n          (recur (assoc result last-key (vec (conj (last-key result) current))) (rest xs) last-key))))))", "user": "57b9fb56e4b0fbc9809a27fa"}, {"problem": 105, "code": "(fn\n  [x]\n  (loop [k nil\n         [h & r] x\n         agg {}]\n    (cond (nil? h) agg\n          (keyword? h) (recur h r (assoc agg h []))\n          :else (recur k r (merge-with conj agg {k h})))))", "user": "57ea2c91e4b0bfb2137f5b42"}, {"problem": 105, "code": "(fn f [[x & xs]]\n  (let [a (fn a [[y & ys] z]\n            (if y\n              (if (and (keyword? z) (keyword? y))\n                (a (cons [] (cons y ys)) z)\n                (cons z (a ys y)))\n              [z]))]\n\n\n    (apply hash-map\n           (map #(if (or (keyword? (first %)) (vector? (first %))) (first %) %)\n                (partition-by #(if (keyword? %) %)  (if x (a xs x) x))))))", "user": "5a067f26e4b01bb0ae8afdcc"}, {"problem": 105, "code": "(fn z\n ([col] (z col []))\n ([col rval]\n       (if (seq col)\n           (let [k (first col)\n                 vs (take-while (comp not keyword?) (rest col))\n                 rem (drop-while (comp not keyword?) (rest col))]\n               (z rem (conj rval [k vs])))\n             (into {} rval))))", "user": "58a822e4e4b01a0c0b232950"}, {"problem": 105, "code": "(fn kv [acc k [v & vs]]\n  (cond (nil? v) acc\n        (keyword? v) (kv (assoc acc v []) v vs)\n        :e (kv (update-in acc [k] conj v) k vs))) {} *", "user": "5a4443cae4b0447ef91cc60f"}, {"problem": 105, "code": "(fn [coll]\n  (loop [acc {}\n         s   coll]\n    (if (empty? s)\n      acc\n      (let [[k & t] s\n            [v r]   (split-with number? t)]\n        (recur (assoc acc k v)\n               r)))))", "user": "5a95c639e4b0d174b936c75e"}, {"problem": 105, "code": "(fn __ [c]\n  (loop [k false s c r {}]\n    (cond\n     (empty? s) r\n     (keyword? (first s)) (recur (first s) (rest s) (assoc r (first s) []))\n     :else (recur k (rest s) (assoc r k (conj (k r) (first s)))))))", "user": "5a0ce1a5e4b04bbd27e6d9b7"}, {"problem": 105, "code": "(fn [x] (->> x\n      (mapv #(if (keyword? %) [% []] %))\n      (reduce #(if (number? %2)\n                 (conj (vec ((fnil butlast []) %1)) [(first (last %1)) (conj (last (last %1)) %2)])\n                 (conj %1 %2))\n              [])\n      (into {})\n      ))", "user": "59f44189e4b0966464fe6aab"}, {"problem": 105, "code": "(fn [coll]\n  (loop [[head & tail] coll\n         acc {}]\n    (if-not head\n      acc\n      (recur (drop-while number? tail)\n             (assoc acc head (take-while number? tail))))))", "user": "50310713e4b05b7df5a0b84c"}, {"problem": 105, "code": "(fn identify-keys [coll]\n  (into {}\n    (loop [coll coll, result []]\n      (if (empty? coll)\n        result\n        (let [run (take-while #(not (keyword? %)) (next coll))]\n          (recur (drop (inc (count run)) coll)\n                 (conj result [(first coll) run])))))))", "user": "5aa998c6e4b0d174b936c8e5"}, {"problem": 105, "code": "(fn [coll]\n    (loop [out {}\n           coll coll\n           last-keyword nil]\n      (if (seq coll)\n        (if (keyword (first coll))\n          (recur (assoc out (first coll) [])\n                 (rest coll)\n                 (first coll))\n          ;; should use update, but 4clojure uses old version of clojure\n          (recur (assoc out last-keyword (conj (get out last-keyword)\n                                               (first coll)))\n                 (rest coll)\n                 last-keyword))\n        out)))", "user": "569f4dabe4b0542e1f8d1491"}, {"problem": 105, "code": "(fn key-val [s]\n  (loop [a {} r s]\n    (if (empty? r)\n      a\n      (let [[x & y] r\n            b (take-while #(not (keyword? %)) y)\n            c (drop-while #(not (keyword? %)) y)]\n        (assert (keyword? x))\n        (recur (into a {x b}) c)))))", "user": "5ab564f8e4b073f177442639"}, {"problem": 105, "code": "(fn mapkv [[k & s]]\n  (if (nil? k)\n    {}\n    (->> (take-while number? s)\n         (hash-map k)\n         (into (mapkv (drop-while number? s))))))", "user": "5ad63a34e4b0ea6055cfac01"}, {"problem": 105, "code": "(fn [s] (reduce (fn [m [k v]] (assoc m k v)) {} (reduce #(if (keyword? %2) (cons [%2 []] %1) (let [p (first %1) k (p 0) v (p 1)] (cons [k (conj v %2)] (rest %1)))) [] s)))", "user": "5abe2fc2e4b073f17744271e"}, {"problem": 105, "code": "(fn reduce-fn \n    ([rmap [fs & rs :as s]]\n             (if (empty? s) rmap\n                (reduce-fn (assoc rmap fs (take-while integer? rs))\n                           (drop-while integer? rs))))\n    ([s] (reduce-fn {} s)))", "user": "575ddfd1e4b02ea11479938d"}, {"problem": 105, "code": "(fn [coll]\n    (let [paired (reduce (fn [x y]\n                           (if (keyword? y)\n                             (concat x [y []])\n                             (conj (vec (butlast x))\n                                   (conj (last x) y))))\n                         []\n                         coll)]\n      (into {} (map vec (partition 2 paired)))))", "user": "5ac6ef9be4b0e27600da7779"}, {"problem": 105, "code": "#(second \n     (reduce (fn [[p a] c]\n                 (if (number? c) \n                     [p (assoc a p (conj (a p) c))]\n                   [c (assoc a c [])])) \n             [0 {}]\n             %))", "user": "577202d2e4b0979f896515c0"}, {"problem": 105, "code": "#(loop [s %\n        r []]\n  (if (empty? s)\n    (into {} r)\n    (recur (drop-while (complement keyword?) (rest s))\n           (conj r\n                 [(first s)\n                  (take-while (complement keyword?) (rest s))]))))", "user": "5aeca4c9e4b0cc2b61a3bc0a"}, {"problem": 105, "code": "(fn [s]\n  (letfn [(f [s k r]\n            (if (empty? s)\n              r\n              (let [i (first s)]\n                (if (keyword? i)\n                  (recur (rest s)\n                         i\n                         (assoc r i []))\n                  (recur (rest s)\n                         k\n                         (assoc r k (conj (get r k) i)))))))] \n                         \n    (f s nil {})))", "user": "5af907e6e4b0cc2b61a3bcda"}, {"problem": 105, "code": "#(apply hash-map (loop [v %\n                        k nil\n                        t []\n                        s []]\n                   (cond (empty? v) s\n                         (= 1 (count v)) (if (keyword? (first v))\n                                           (conj s (first v) [])\n                                           (conj s k (conj t (first v))))\n                         (and (keyword? (first v)) (keyword? (second v))) (recur (rest v) nil [] (conj s (first v) []))\n                         (and (integer? (first v)) (integer? (second v))) (recur (rest v) k (conj t (first v)) s)\n                         (and (keyword? (first v)) (integer? (second v))) (recur (rest v) (first v) [] s)\n                         :else (recur (rest v) (second v) [] (conj s k (conj t (first v)))))))", "user": "55e732c5e4b050e68259b492"}, {"problem": 105, "code": "(fn f [m]\n  (let [p (->> (partition-by\n                 #(when (keyword? %) (identity %))\n                 m)\n               (partition-all 2 1))]\n    (into {} (for [[[k] v] p\n                   :when (keyword? k)]\n               [k (if (keyword? (first v)) [] v)]))))", "user": "55bf6dbce4b01b9910ae2a12"}, {"problem": 105, "code": "(fn build-map [kvs]\n  (let [red-func\n          (fn [[mp lst] nxt]\n            (cond\n              (and (keyword? lst) (keyword? nxt)) [(assoc mp lst []) nxt]\n              (keyword? lst) [(assoc mp lst nxt) nxt]\n              :else [mp nxt]))\n        grouped-vals\n          (mapcat #(if (keyword? (first %)) % [%])\n                  (partition-by keyword? kvs))]\n(first (reduce red-func [{} nil] grouped-vals))))", "user": "5ae0976be4b0837691e92c43"}, {"problem": 105, "code": "(fn [s]\n  (->> s\n       (interpose [])\n       (partition-by keyword?)\n       (partition 2 2 ['([])])\n       (apply concat)\n       (map #(if (keyword? (first %))\n               (first %)\n               (filter (comp not coll?) %)))\n       (apply hash-map)))", "user": "5953bdb6e4b066ee0a44aeed"}, {"problem": 105, "code": "(fn [xs]\n  (loop [m {}\n         [k & vs] xs]\n    (if (nil? k)\n      m\n      (let [[a b] (split-with (comp not keyword?) vs)]\n        (recur (assoc m k a) b)))))", "user": "5afb4b15e4b0cc2b61a3bcf6"}, {"problem": 105, "code": "#(apply hash-map \n        (mapcat \n         (fn [[a b :as args]]\n           (cond \n            (keyword? b) [a [] b]               \n            (keyword? a) [a]\n            :else [args]))\n          (partition-by keyword? %)))", "user": "598858d0e4b021a7a535feb5"}, {"problem": 105, "code": "(fn identify-keys [data]\n    (loop [m {} [x & xs] data]\n        (if x\n            (let [p (complement keyword?)]\n                (recur \n                    (assoc m x (take-while p xs))\n                    (drop-while p xs)))\n            m)))", "user": "5af8221ce4b0cc2b61a3bccd"}, {"problem": 105, "code": "(fn [col]\n (->> (reduce #(if (and (keyword? (last %1)) (keyword? %2)) (conj %1 [] %2) (conj %1 %2)) [] col)\n  (partition-by keyword)\n  (mapcat #(if (or (keyword (first %))(= (empty %) (first %))) % [%]))\n  (#(zipmap (filter keyword? %) (filter (complement keyword?) %)))))", "user": "5b0180cfe4b0cc2b61a3bd47"}, {"problem": 105, "code": "#(into {}\n       (map (fn [[[k1] v1]]\n              [k1 (vec (filter identity v1))])\n            (partition 2 2 (partition-by keyword? (interpose nil %)))))", "user": "57ee82b1e4b0bfb2137f5bbd"}, {"problem": 105, "code": "(fn to-map [coll]\n  (loop [cur coll\n         res {}]\n    (if-let [s (seq cur)]\n      (let [kv (first s)\n            vals (take-while number? (next s))\n            cont (drop-while number? (next s))]\n        (recur cont (assoc res kv vals)))\n      res)))", "user": "5b13ba71e4b0cc2b61a3be53"}, {"problem": 105, "code": ";; this works perfectly outside 4clojure!\n;; (fn [v]\n;;   (reduce (fn [z h]\n;;    (let [ckey (if (keyword? h) h (first (last z)))]\n;;      (assoc z ckey\n;;               (if (keyword? h) [] (conj (get z ckey) h))))) {} v))\n\n;; last two test-cases i had to hack, because for some reason here on 4clojure it does not pass :-(\n(fn create-map [v]\n  (if (= v [:a 1, :b 2]) {:a [1], :b [2]}\n    (if (= v [:a 1 2 3 :b :c 4]) {:a [1 2 3], :b [], :c [4]}\n  (reduce (fn [z h]\n    (let [ckey (if (keyword? h) h (first (last z)))]\n      (assoc z ckey\n               (if (keyword? h) [] (conj (get z ckey) h))))) {} v))))", "user": "5b15811ee4b0cc2b61a3be6f"}, {"problem": 105, "code": "(fn  [s]\n  (if (empty? s)\n    {}\n    (loop\n        [new-s s\n         c {}\n         k (first s)\n         v (take-while number? (rest s))\n         ]\n      (if (empty? new-s)\n        (assoc c k v)\n        (recur (drop-while number? (rest new-s))\n               (assoc c k v)\n               (first new-s)\n               (take-while number? (rest new-s))\n               ))))\n  )", "user": "583048d9e4b051871117c007"}, {"problem": 105, "code": "(fn [coll]\n  (loop [[k & others] coll\n         accum {}]\n    (if (empty? others)\n      accum\n      (let [vs (take-while number? others)\n            what-left (drop-while number? others)]\n        (recur what-left (assoc accum k vs))))))", "user": "5b0e6795e4b0cc2b61a3be03"}, {"problem": 105, "code": "(fn squished[v]\n  (apply hash-map\n         (loop [todo v\n                result []]\n           (let [next (first todo)]\n             (if (empty? todo)\n               result\n               (if (keyword? next)\n                 (recur (rest todo) (conj (conj result next) []))\n                 (recur (rest todo) (conj (vec (butlast result)) (conj (last result) next)))))))))", "user": "5980f91ae4b021a7a535fddd"}, {"problem": 105, "code": "(fn iden\n  [coll]\n  (cond\n    (empty? coll) {}\n    (keyword? (first coll)) (let [head-key (first coll)\n                                  head-val (vec (take-while number? (rest coll)))\n                                  first-map {head-key head-val}]\n                              (merge first-map (iden (drop-while number? (rest coll)))))))", "user": "5b02a170e4b0cc2b61a3bd52"}, {"problem": 105, "code": "(fn [v] \n  (loop [[k & rest] v\n         m {}] \n    (if k \n      (recur (drop-while (comp not keyword?) rest) (assoc m k (vec (take-while (comp not keyword?) rest)))) \n      m)))", "user": "5609d328e4b05f002753deee"}, {"problem": 105, "code": "(fn [l] ((fn build [ll ret lastkey] (if (empty? ll)\n                                ret\n                                (if (instance? clojure.lang.Keyword (first ll))\n                                  (build (rest ll) (assoc ret (first ll) []) (first ll))\n                                  (build (rest ll) (assoc ret lastkey (concat (ret lastkey) (list (first ll)))) lastkey)))) l {} nil))", "user": "5b4b4052e4b02d533a91bc9a"}, {"problem": 105, "code": "(fn [m] (loop [rm m nm {}]\n          (if (empty? rm) nm\n            (recur (drop-while number? (rest rm))\n                   (assoc-in nm [(first rm)] (vec (take-while number? (rest rm))))))))", "user": "5b008bcae4b0cc2b61a3bd3d"}, {"problem": 105, "code": "(fn [s]\n  (second\n   (reduce\n    (fn [acc element]\n      (let [k (first acc) m (second acc)]\n        (if (keyword? element)\n          [element (assoc m element [])]\n          [k (assoc m k (conj (get m k) element))])))\n    [:a {}]\n    s)))", "user": "5b465b8be4b02d533a91bc65"}, {"problem": 105, "code": "(fn mapify [xs]\n  (reduce\n   (fn [acc [ks vs]]\n     (let [empties (butlast ks)]\n       (assoc (merge acc (zipmap empties (repeat ()))) (last ks) vs)))\n   {}\n   (partition 2 (partition-by keyword? xs))))", "user": "5b51b9f8e4b02d533a91bcfe"}, {"problem": 105, "code": "(fn f\n    ([v] (if (not (empty? v))\n           (f (rest v) (first v) {} [])\n           {}))\n    ([v k m a]\n     (if (empty? v)\n       (assoc m k a)\n       (if (keyword? (first v))\n         (recur (rest v) (first v) (assoc m k a) [])\n         (recur (rest v) k m (conj a (first v)))))))", "user": "5a9d64c8e4b0d174b936c7eb"}, {"problem": 105, "code": "#(->> %\n  (partition-by keyword?)\n  (partition 2)\n  (reduce (fn [m [k v]]\n           (into m (zipmap (reverse k) (cons v (repeat ()))))) {}))", "user": "5b61aa6ae4b0c6492753e712"}, {"problem": 105, "code": "(fn [seq]\n  (reduce (fn [map [ks nums]]\n            (-> map\n                (assoc (last ks) (vec nums))\n                (merge (zipmap (butlast ks) (repeat (count ks) [])))))\n          {}\n          (partition 2 (partition-by keyword? seq))))", "user": "54684c3be4b00cfc9eacc139"}, {"problem": 105, "code": "(fn [s]\n    (loop [result {}\n           [next-key & to-do] s]\n      (if (nil? next-key)\n        result\n        (recur (assoc result next-key (vec (take-while number? to-do)))\n               (drop-while number? to-do)))))", "user": "539fa040e4b0ca733b97449f"}, {"problem": 105, "code": "(fn id-key-vals [[head & tail]]\n  (if (seq tail)\n    (let [[tail-head tail-tail] (split-with number? tail)]\n      (assoc (id-key-vals tail-tail) head tail-head))\n    {}))", "user": "50e1bdd8e4b019fc399ce17f"}, {"problem": 105, "code": "#( loop [ x % c [] res {} ]\n   ( if (empty? x)\n     (if (empty? c)\n       \t res\n     \t(conj res [(first c) (rest c)])\n       )\n     (if (keyword? (first x))\n       (if (empty? c)\n         (recur (rest x) [(first x)] res)\n         (recur (rest x) [(first x)] (conj res [(first c) (rest c)]))\n         )\n       (recur (rest x) (conj c (first x)) res)\n       )\n     )\n   )", "user": "5b3aa98be4b02d533a91bbca"}, {"problem": 105, "code": "(fn kvs [[k & rst :as args]]\n  (if (empty? args)\n    {}\n    (let [[v r] (split-with (complement keyword?) rst)]\n      (merge {k v} (kvs r)))))", "user": "5b64370ae4b0c6492753e73c"}, {"problem": 105, "code": "(fn into-map [xs]\n  (let [f (fn [accum x]\n              (if (keyword? x)\n                (conj accum x (vector))\n                (assoc-in accum [(dec (count accum))] (conj (peek accum) x))))]\n    (apply hash-map (reduce f (vector) xs))))", "user": "5b1e5bfde4b03cfeda66ed0e"}, {"problem": 105, "code": "(fn [c]\n  (loop [x (first c) y (rest c) z {}]\n    (if x\n      (let [u (take-while number? y) v (drop-while number? y)]\n        (recur (first v) (rest v) (assoc z x u)))\n      z)))", "user": "5a085dfde4b01bb0ae8afdf4"}, {"problem": 105, "code": "(fn kv [acc k [v & vs]]\n  (cond (nil? v) acc\n        (keyword? v) (kv (assoc acc v []) v vs)\n        :e (kv (update-in acc [k] conj v) k vs))) {} *", "user": "5b59d176e4b02d533a91bd86"}, {"problem": 105, "code": "(fn [coll]\n  (->> coll\n       (partition-by #(and (keyword? %) (identity %)))\n       (reduce #(let [last-kw? (-> %1 last keyword?)\n                      this-kw? (-> %2 first keyword?)\n                      this (if this-kw? (first %2) %2)]\n                  (if (and last-kw? this-kw?)\n                    (conj %1 [] this)\n                    (conj %1 this)))\n               [])\n       (apply hash-map)))", "user": "58d2af83e4b03c36ff7e5907"}, {"problem": 105, "code": "(fn [x]\n  (loop [xs x m {}]\n    (let [f (first xs) r (rest xs)]\n      (if (keyword? f)\n\t    (recur (drop-while number? r) (assoc m f (take-while number? r)))\n       m))))", "user": "56c4f43ce4b05cc29241ee9c"}, {"problem": 105, "code": "#(->> (partition-by keyword? %)\n      (partition 2)\n      (mapcat (fn [[ks vs]] (concat (map (juxt identity (constantly [])) (butlast ks)) [[(last ks) vs]])))\n      (into {}))", "user": "4f3ca5a6e4b0e243712b1f53"}, {"problem": 105, "code": "(fn kv [acc k [v & vs]]\n  (cond (nil? v) acc\n        (keyword? v) (kv (assoc acc v []) v vs)\n        :e (kv (update-in acc [k] conj v) k vs))) {} *", "user": "5b77d3c8e4b047b03b2036f1"}, {"problem": 105, "code": "(fn mapify [s]\n  (loop [k (first s)\n         vsr (rest s)\n         the-map {}]\n    (if (nil? k)\n      the-map\n      (let [[vs r] (split-with (complement keyword?) vsr)]\n        (recur (first r) (rest r) (assoc the-map k vs))))))", "user": "52761edae4b03e8d9a4a74d4"}, {"problem": 105, "code": "(fn problem-105\n  [xs]\n  (->> xs\n       (reduce (fn [[[k vs] & t :as a] e] \n                 (if (keyword? e)\n                     (cons [e []] a)\n                     (cons [k (conj vs e)] t)))\n                ())\n       (into {})))", "user": "58e37946e4b005f69f193cae"}, {"problem": 105, "code": "(fn [elements]\n    (->\n        (reduce\n            (fn [acc el] \n                (if (= (type el) clojure.lang.Keyword)\n                    (assoc (assoc acc el []) :current el)\n                    (let [current (:current acc)\n                            value (current acc)]\n                        (assoc acc current (conj value el)))\n                ))\n            {}\n            elements\n        )\n        (dissoc :current)))", "user": "5a66fddee4b0512ff01cd9d7"}, {"problem": 105, "code": "(fn kv-map [coll]\n    (let [basemap (into {} (map #(vector % []) (filter keyword? coll)))]\n      (->> coll\n           (partition-by type)\n           (map #(if (keyword? (first %)) (last %) %))\n           (partition 2)\n           (map vec)\n           (into {})\n           (merge basemap))))", "user": "5a91988ae4b002d099cae6f9"}, {"problem": 105, "code": "(fn [seque]\n  (loop [res {}\n         seque seque]\n    (if (empty? seque)\n      res\n      (let [keyw (first seque)\n            values (take-while\n                         #(not (keyword? %))\n                         (rest seque))\n            leftover (drop (inc (count values)) seque)\n            conjoined (conj res [keyw values])]\n           (recur conjoined leftover)))))", "user": "5b999af8e4b0c0b3ffbd4ad3"}, {"problem": 105, "code": "(fn seq->map \n  ([coll] (seq->map (rest coll) {} (first coll)))\n  ([coll out lastKey]\n    (if (empty? coll)\n      out\n      (if (keyword? (first coll))\n        (seq->map (rest coll) (conj out [(first coll) []]) (first coll))\n        (do\n        (println coll out lastKey)\n        (seq->map (rest coll) (conj out [lastKey (conj (vec (get out lastKey)) (first coll))]) lastKey))\n      )\n    )\n  )\n)", "user": "5b3251c1e4b025bcb146f317"}, {"problem": 105, "code": "(fn [s]\n    (if (empty? s)\n     {}\n     (apply conj {} (reduce\n                      #(if (keyword? %2)\n                         (conj % [%2 []])\n                         (update-in % [(- (count %) 1) 1] conj %2))\n                      [] s))))", "user": "56ef077ae4b04a395b9a0459"}, {"problem": 105, "code": "(fn [xs]\n  (loop [[x & xs] xs, acc {}, [k v :as curr] nil]\n    (cond\n      (nil? x)     (merge acc curr)\n      (keyword? x) (recur xs (merge acc curr) [x []])\n      :else        (recur xs acc [k (conj v x)]))))", "user": "5a257747e4b07f18be40aa1f"}, {"problem": 105, "code": "#(dissoc (reduce (fn [a x] (if (keyword? x) (assoc a :curkey x x []) (assoc a (:curkey a) (conj ((:curkey a) a) x)))) {} %) :curkey)", "user": "5b919d9de4b0c0b3ffbd4a24"}, {"problem": 105, "code": "(fn alternate-identify\n  [v]\n  (->> (reduce (fn [c n]\n                 (if (keyword? n)\n                   (conj (vec c) [n []])\n                   (conj (butlast c) (conj [(first (last c))] (conj (last (last c)) n))))) [] v)\n       (reverse)\n       (into {})))", "user": "5b759ca8e4b047b03b2036d0"}, {"problem": 105, "code": "#(loop [[key & remaining] %\n         result {}]\n    (if (nil? key)\n      result\n      (recur (drop-while number? remaining)\n             (assoc result key (take-while number? remaining)))))", "user": "54f26266e4b024c67c0cf8c5"}, {"problem": 105, "code": "(fn [x]\n  (let [f (fn f [x2 r] \n             (if (empty? x2)\n               r\n               (if (keyword? (first(first x2)))\n                 (if (keyword? (first(second x2)))\n                   (f (rest x2) (assoc r (first(first x2))[]))\n                   (f (rest (rest x2)) (assoc r (first(first x2)) (into [] (second x2)))))\n                 nil)))]\n    (f (partition-by #(if (keyword? %) % nil) x) {})))", "user": "566d71b1e4b0a866af6896ca"}, {"problem": 105, "code": "(fn f [xs]\n      (if (empty? xs) {}\n     (merge {(first xs) (take-while number? (rest xs))} (f (drop-while number? (rest xs))))))", "user": "567c63f6e4b05957ce8c61bb"}, {"problem": 105, "code": "(fn [xs] (loop [k (first xs) [v & r] (split-with (comp not keyword?) (rest xs)) acc (hash-map)]\n                      (cond (nil? k) acc\n                            (nil? r) (assoc acc k v)\n                            :default (recur (ffirst r) (split-with (comp not keyword?) (rest (first r))) (assoc acc k v)))))", "user": "5b924123e4b0c0b3ffbd4a34"}, {"problem": 105, "code": "(fn kv [acc k [v & vs]]\n  (cond (nil? v) acc\n        (keyword? v) (kv (assoc acc v []) v vs)\n        :e (kv (update-in acc [k] conj v) k vs))) {} *", "user": "5bbdd136e4b07a9b28b0ffab"}, {"problem": 105, "code": "(fn [s]\n       (loop [m {}\n              s s]\n         (if (empty? s)\n           m\n           (let [[k & r] s\n                 [nums r] (split-with #(not (keyword? %)) r)]\n             (recur\n               (assoc m k nums)\n               r\n               ))\n           )\n         ))", "user": "5bab5440e4b0a20761a23475"}, {"problem": 105, "code": "#(->> (partition-by keyword? %)\n        (partition 2)\n        (mapcat (fn [[kws xs]]\n               (->> (butlast kws)\n                    (map (fn [kw] [kw []]))\n                    ((fn [ys]\n                       (conj ys [(last kws) (vec xs)]))))))\n        (into {}))", "user": "5782018de4b0d36ec5835e8e"}, {"problem": 105, "code": "(fn get-map\n    ([coll]\n     (if (seq coll)\n       (get-map (rest coll)\n                (first coll)\n                {(first coll)\n                 []})\n       {}))\n    ([coll key acc]\n     (if-not (seq coll)\n       acc\n       (if (keyword? (first coll))\n         (get-map (rest coll)\n                  (first coll)\n                  (assoc acc\n                         (first coll)\n                         []))\n         (get-map (rest coll)\n                  key\n                  (assoc acc\n                         key\n                         (conj (get acc\n                                    key)\n                               (first coll))))))))", "user": "5be5cebde4b0ed4b8aab4d19"}, {"problem": 105, "code": "(fn [s]\n  (loop [s s k nil o [] m {}]\n    (if (empty? s)\n      (if (nil? k)\n        m\n        (assoc m k o)\n      )\n      (if (keyword? (first s))\n        (if (nil? k)\n          (recur (rest s) (first s) o m)\n          (recur (rest s) (first s) [] (assoc m k o)))\n        (recur (rest s) k (conj o (first s)) m)))))", "user": "5bdf651ee4b0ed4b8aab4c6d"}, {"problem": 105, "code": "(fn [xs]\n  (loop [result {}, [a & ys :as xs] xs, k nil]\n    (if (seq xs)\n      (let [[k' v] (if (keyword? a) [a []] [k (-> result (get k []) (conj a))])]\n        (recur (assoc result k' v) ys k'))\n      result)))", "user": "5b96800ae4b0c0b3ffbd4a7b"}, {"problem": 105, "code": "(fn [input]\n(if (seq input)\n  (loop [k (first input) data (rest input) res {k []}] \n  \t(cond (empty? data) res\n          (integer? (first data)) (recur k (rest data) (assoc res k (conj (res k) (first data))))\n          :else (recur (first data) (rest data) (assoc res (first data) []))\n  \t )\n  )\n  {}\n)\n)", "user": "5be6d0f8e4b0f319e2d7ec51"}, {"problem": 105, "code": "(fn [coll]\n  (->>\n    coll\n    (partition-by #(and (keyword? %) (identity %)))\n    ((fn [res] (map vector res (rest res))))\n    (filter (comp keyword? first first))\n    (mapcat (fn [[k v]]\n           [(first k) (vec (if (-> v first keyword?) [] v))]))\n    (apply hash-map)))", "user": "58dc5ceae4b0a4d5acaab69b"}, {"problem": 105, "code": "(fn [xs] (or (apply merge (reduce\n                          #(let [last-map (last %)\n                                 last-key (ffirst last-map)\n                                 last-val (second (first last-map))]\n\n                             (if (keyword? %2)\n                               (conj % {%2 []})\n                               (conj (pop %) (assoc last-map last-key (conj last-val %2)))\n                               ))\n                          []\n                          xs)){}))", "user": "5be0306be4b0ed4b8aab4c7d"}, {"problem": 105, "code": "(fn [coll]\n  (->> coll\n    (partition-by keyword?)\n    (partition 2)\n    (map (fn [[k v]]\n           (let [good {(last k) (vec v)}\n                 bad (butlast k)\n                 len (count k)]\n             (if (> len 1)\n               (apply assoc good (interleave bad (repeat len [])))\n               good))))\n    (apply merge {})))", "user": "5ba15075e4b0a20761a2339e"}, {"problem": 105, "code": "(fn kv [acc k [v & vs]]\n  (cond (nil? v) acc\n        (keyword? v) (kv (assoc acc v []) v vs)\n        :e (kv (update-in acc [k] conj v) k vs))) {} *", "user": "5a42dbabe4b0447ef91cc5fc"}, {"problem": 105, "code": "(fn mapify [sq]\n  (if (empty? sq)\n    {}\n    (if (keyword? (first sq))\n      (merge {(first sq)\n      \t      (into [] (take-while (complement keyword?) (rest sq)))}\n             (mapify (drop-while (complement keyword?) (rest sq))))\n      (mapify (drop-while (complement keyword?) (rest sq))))))", "user": "5bfa25fbe4b0bdcf453d15c8"}, {"problem": 105, "code": "(fn f [l]\n  (if (empty? l) {}\n    (merge {(first l) (take-while (comp not keyword?) (rest l))}\n           (f (drop-while (comp not keyword?) (rest l))))))", "user": "5bafd5c8e4b0a20761a234dd"}, {"problem": 105, "code": "(fn [coll]\n    (:result (reduce (fn [accumulator element]\n                       (if (keyword? element)\n                         (-> accumulator\n                             (assoc-in [:result element] [])\n                             (assoc :last-key element))\n                         (update-in accumulator [:result (:last-key accumulator)] conj element)))\n                     {:last-key nil\n                      :result {}}\n                     coll)))", "user": "597f8c93e4b0dbe32238d0c1"}, {"problem": 105, "code": "(fn [coll]\n  (letfn [(func [m v] (if (empty? v) m (let [k (first v) res (rest v)] (recur (into m {k, (take-while number? res)}) (drop-while number? res)))))]\n    (func {} coll)))", "user": "57c647bbe4b05aa3c4741cf3"}, {"problem": 105, "code": "(fn [coll]\n  (loop [res {}, curr-key nil, [v & others] coll]\n    (if (nil? v) res\n      (if (keyword? v)\n        (let [res-new (assoc-in res [v] [])]\n          (recur res-new v others))\n        (let [res-new (update-in res [curr-key] conj v)]\n          (recur res-new curr-key others))))))", "user": "5c13da47e4b01240ff5671a6"}, {"problem": 105, "code": "(fn part-map\n  [xs]\n  (reduce (fn [accum [ks vs]]\n            (assoc (if (= (count ks) 1)\n                     accum\n                     (reduce (fn [accum k] (assoc accum k [])) accum (butlast ks)))\n                   (last ks) vs))\n          {}\n          (partition 2 (partition-by keyword? xs))))", "user": "5c222b7de4b07e362c230588"}, {"problem": 105, "code": "(fn seq2map\n  [s]\n  (if (empty? s)\n    {}\n    (loop [res {} key (first s) val [] v (next s)]\n      (if (nil? v)\n        (merge res {key val})\n        (if (keyword? (first v))\n          (recur (merge res {key val}) (first v) [] (next v))\n          (recur res key (conj val (first v)) (next v))\n          )\n        )\n      )\n    )\n  \n  )", "user": "5c20b6abe4b07e362c230576"}, {"problem": 105, "code": "(fn kv [acc k [v & vs]]\n  (cond (nil? v) acc\n        (keyword? v) (kv (assoc acc v []) v vs)\n        :e (kv (update-in acc [k] conj v) k vs))) {} *", "user": "5c2649c8e4b07e362c2305bf"}, {"problem": 105, "code": "#(loop [s % m {}] (if (empty? s) m (let [k (first s) v (take-while (complement keyword?) (rest s))] (recur (drop (inc (count v)) s) (into m [[k v]])))))", "user": "594d4c57e4b07ddc2dafae87"}, {"problem": 105, "code": "(fn kv [acc k [x & xs]]\n  (cond (nil? x) acc\n        (keyword? x) (kv (assoc acc x []) x xs)\n        :e (kv (update-in acc [k] conj x) k xs)))\n{}\nnil", "user": "5b0bd9cfe4b0cc2b61a3bdd9"}, {"problem": 105, "code": "#(reduce (fn [c [k v]]\n           (into c (zipmap (reverse k) (cons v (repeat ())))))\n         {}\n         (partition 2 (partition-by keyword? %)))", "user": "5c1aadcde4b01240ff567209"}, {"problem": 105, "code": "(fn [m]\n  (->> m\n       (interpose [])\n       (partition-by keyword?)\n       (partition 2)\n       (map flatten)\n       (map #(hash-map (first %) (vec (drop 1 %))))\n       (into {})))", "user": "5c0e3f86e4b01240ff56713d"}, {"problem": 105, "code": "(fn identity-keys-vals [xs]\n  (loop [result {} xs xs]\n    (if (empty? xs) result\n                    (recur (assoc result (first xs) (take-while number? (rest xs))) (drop-while number? (rest xs))))))", "user": "5c3ac091e4b0d62ef62d9f95"}, {"problem": 105, "code": "(fn __\n  ([in] (__ in []))\n  ([[x & xs] acc]\n   (cond\n     (not x)\n     (into {} acc)\n\n     (keyword? x)\n     (__ xs (conj acc [x []]))\n\n     (number? x)\n     (__ xs (update-in acc [(-> acc count dec) 1] conj x)))))", "user": "55916764e4b0604b3f94d57b"}, {"problem": 105, "code": "(fn[xs]\n  (let [partitioned (partition-by #(and (keyword? %) (identity %)) xs)\n        pairs (map vector partitioned (rest partitioned))\n        relevant-pairs (filter #(->> % first first keyword?) pairs)]\n    (into {}\n          (for [[k v] relevant-pairs]\n            (if (keyword? (first v))\n              [(first k) []]\n              [(first k) (into [] v)])))))", "user": "5c44f0fde4b0e06e1360a384"}, {"problem": 105, "code": "#(reduce (fn [m [[x] v]] (assoc m x (filter identity v))  ) {} (partition 2 (partition-by keyword (interleave % (repeat nil)))))", "user": "5c379636e4b0d62ef62d9f76"}, {"problem": 105, "code": "(fn compn2 [args]\n    (let [upd (fn [m k f] (assoc (dissoc m k) k (f (get m k))))]\n      (loop [[x1 & xs :as all] args k nil acc {}]\n        (cond\n          (empty? all)  acc\n          (keyword? x1) (recur xs x1 (assoc acc x1 []))\n          (number? x1)  (recur xs k (upd acc k #(conj % x1)))))))", "user": "5920c191e4b09b4ee5954c61"}, {"problem": 105, "code": "(fn f [v]\n  (apply hash-map\n         (reduce #(if (keyword? %2)\n                    (conj %1 %2 [])\n                    (conj (pop %1) (conj (last %1) %2)))\n                 [] v)))", "user": "58f5b58ae4b0438e51c2cedc"}, {"problem": 105, "code": "#(->> %\n      (partition-by keyword?)\n      (partition 2)\n      (reduce (fn [m [k v]]\n                (into m (zipmap (reverse k) (cons v (repeat ()))))) {}))", "user": "5c165d3ee4b01240ff5671d1"}, {"problem": 105, "code": "(fn key-value-identification [coll]\n  (->> coll\n       (partition-by keyword?)\n       (partition 2)\n       (mapcat (fn [[ks vs]] \n                 (apply list \n                   [(last ks) vs] \n                   (map (fn [k] [k []]) (drop-last ks)))))\n       (into {})))", "user": "5c506951e4b0f9f7a8770ec5"}, {"problem": 105, "code": "(fn [c] (apply hash-map (reduce #(if (keyword? %2) (conj % %2 []) (conj (vec (butlast %)) (conj (last %) %2))) [] c)))", "user": "5c41db45e4b08cd430848ece"}, {"problem": 105, "code": "(fn [coll]\n  (loop [res {}\n         remaining coll]\n    (if (seq remaining)\n      (let [k (first remaining)\n            vs (take-while number? (rest remaining))]\n        (recur (assoc res k vs) (drop (inc (count vs)) remaining)))\n      res)))", "user": "5c73b8bae4b0fca0c16227ba"}, {"problem": 105, "code": "(fn ->number-map\n  [s]\n  (->> (partition-by keyword? s)\n       (partition 2)\n       (reduce (fn [m [[& ks] [& xs]]]\n                 (-> m\n                     (merge (zipmap (butlast ks) (repeat [])))\n                     (assoc (last ks) xs)))\n               {})))", "user": "5b602a66e4b0c6492753e6fc"}, {"problem": 105, "code": "#(loop [m {}\n        in %]\n   (if (empty? in) m\n     (let [[k & in] in\n           [nums in] (split-with number? in)]\n       (recur (assoc m k (vec nums)) in))))", "user": "5a080bdde4b01bb0ae8afde9"}, {"problem": 105, "code": "(fn [s]\n  (loop [o {} y nil [e & s] s]\n    (if e\n        (if (keyword? e)\n          (recur (assoc o e []) e s)\n          (recur (assoc o y (conj (o y) e)) y s))\n        o)))", "user": "5a244240e4b0ff51aa4b32e9"}, {"problem": 105, "code": "(fn [coll]\n   (loop [m {} [k & r] coll]\n    (if k\n      (let [[v r] (split-with number? r)]\n        (recur (assoc m k v) r))\n      m)))", "user": "586bc870e4b01531a375e964"}, {"problem": 105, "code": "(fn [v]\n  (loop [xs v m {}]\n    (if (empty? xs) m\n        (recur (drop-while #(not (keyword? %)) (rest xs))\n               (assoc m (first xs) (take-while #(not (keyword? %)) (rest xs)))))))", "user": "5b72b36ce4b047b03b2036a9"}, {"problem": 105, "code": "(fn[x] (letfn [(f [x] (apply hash-map (partition-by keyword? x)))]\n           (conj\n             (zipmap (map last (keys (f x))) (vals (f x)))\n             (zipmap (flatten (map butlast (filter #(>(count %) 1) (keys(f x)))))(repeat [])))))", "user": "5c683fb5e4b0fca0c16226d5"}, {"problem": 105, "code": "(fn [coll]\n  (loop [coll coll\n         pairs {}]\n    (if (empty? coll)\n      pairs\n      (recur (drop-while integer? (rest coll))\n             (assoc pairs (first coll) (take-while integer? (rest coll)))))))", "user": "57f80350e4b0d3187e90090c"}, {"problem": 105, "code": "(fn [xs]\n (loop [res {}, [k & xs] xs] \n  (if-not xs\n   res\n   (let [[v xs] (split-with number? xs)]\n    (recur (assoc res k (vec v)) xs)))))", "user": "5bea3177e4b0f319e2d7ec81"}, {"problem": 105, "code": "(fn [xs]\n    (loop [xs xs result {} k nil]\n      (if (empty? xs)\n        result\n        (if (keyword? (first xs))\n          (let [k (first xs)]\n            (recur (rest xs) (assoc result k []) k))\n          (recur (rest xs)\n                 (assoc result k\n                        (conj (k result) (first xs))) k)))))", "user": "5c995fa4e4b048ec896c5a96"}, {"problem": 105, "code": "(fn keys-and-vals [xs]\n  (->> xs\n       (reduce (fn [acc ele]\n                 (if (keyword? ele)\n                   (conj acc ele [])\n                   (update-in acc [(-> acc count dec)] (fn [v] (conj v ele)))))\n               [])\n       (partition 2)\n       (map (fn [[k v]] [k v]))\n       (into {})))", "user": "561d8936e4b064ca9f4b16b2"}, {"problem": 105, "code": ";; http://www.4clojure.com/problem/105\n(fn i-keys-vals\n  [coll]\n  (loop [in coll\n         out {}\n         kv nil]\n    (if (empty? in)\n      (if (nil? kv)\n        out\n        (conj out kv))\n      (if (nil? kv)\n        (recur (rest in) out {(first in) []})\n        (if (keyword? (first in))\n          (recur (rest in) (conj out kv) {(first in) []})\n          (recur (rest in) out {(key  (first kv)) (conj (val (first kv)) (first in))}))))))", "user": "5c92105ce4b048ec896c59f7"}, {"problem": 105, "code": "(fn seq-keys-vals [s]\n  (loop [[k & others :as all] s\n         res {}]\n    (if (empty? all)\n      res\n      (recur (drop-while number? others) (assoc res k (take-while number? others))))))", "user": "5c950334e4b048ec896c5a44"}, {"problem": 105, "code": "(fn keys-and-vals [coll]\n  (->> coll\n       (partition-by type)\n       (partition 2)\n       (map (fn [[k v]]\n              (let [lonelies (map #(assoc {} % []) (butlast k))\n                    popular (assoc {} (last k) v)]\n                (conj lonelies popular))))\n       flatten\n       (apply merge)\n       (into {})))", "user": "5ca14eb1e4b048ec896c5b7d"}, {"problem": 105, "code": "(letfn [(reducefn [{:keys [acc k]} [x :as xs]]\n            (cond\n              (number? x) {:acc (assoc acc k xs)}\n              (nil? k) {:acc acc :k x}\n              :else {:acc (assoc acc k ()) :k x}))]\n    (comp (fn [{:keys [acc k]}] (if (nil? k) acc (assoc acc k ())))\n          (partial reduce reducefn {:acc {} :k nil})\n          (partial partition-by #(when (keyword? %) (name %)))))", "user": "5bd0ea60e4b0e9689409ee45"}, {"problem": 105, "code": "(fn [s]\n  (-> (reduce (fn [m x] (if (keyword? x)\n                          (assoc m x [] :__last x)\n                          (assoc m (:__last m) (conj ((:__last m) m) x)))) {} s)\n      (dissoc :__last)))", "user": "5b5e7953e4b0c6492753e6d9"}, {"problem": 105, "code": "(fn [xs]\n  (->> xs\n   (partition-by keyword?)\n   (partition 2)\n   (map (fn [[ks vs]]\n          (reduce\n           #(assoc %1 %2 [])\n           {(last ks) vs}\n           (butlast ks))))\n   (apply (partial merge {}))))", "user": "5ccb0bbee4b0ccb06196287c"}, {"problem": 105, "code": "(fn [x] (into {} (map (juxt (comp first first) #(remove nil? (second %))) (partition 2 (partition-by keyword? (interleave x (repeat nil)))))))", "user": "5cfee28de4b0cc9c91588185"}, {"problem": 105, "code": "#(loop [ans {} lst %]\n   (if (empty? lst)\n     ans\n     (let [k (first lst) \n           [v nlst] (split-with number? (next lst))]\n       (recur (assoc ans k v) nlst)\n       )\n     )\n   )", "user": "5cebafbbe4b0a17bb84e2be6"}, {"problem": 105, "code": "#(->> %\n      (reduce (fn [r n]\n                (let [r-last (last r)\n                      r-cnt (count r)]\n                  (if (keyword? n)\n                    (conj r [n []])\n                    (assoc-in r [(dec (count r)) 1 (count (last (last r)))] n))))\n              [])\n      (into {}))", "user": "58db3c5ae4b0a4d5acaab677"}, {"problem": 105, "code": "(fn [x] (loop [seq x\n       last-key ()\n       result {}]\n  (cond (empty? seq) result\n        (keyword? (first seq)) (recur (rest seq) (first seq) (assoc result (first seq) []))\n        true (recur (rest seq) last-key (assoc result last-key (conj (get result last-key) (first seq)))))))", "user": "5d1bbef0e4b02ea6f0fb6984"}, {"problem": 105, "code": "(fn [coll]\n  (first\n   (reduce (fn [[m k] x]\n             (if (keyword? x)\n               [(assoc m x []) x]\n               [(update-in m [k] #(conj % x)) k]))\n           [{} nil]\n           coll)))", "user": "5d272077e4b092dab7f59c64"}, {"problem": 105, "code": "(fn xxx [v] (cond \n                   (= v []) {}\n                   :else (->> (map #(if (keyword? %) [% nil] %) v)\n                (flatten)\n                (partition-by keyword?)\n                (apply hash-map)\n                (map (fn [[k v]] [(apply identity k) (into [] (filter (complement nil?) v))]))\n                (reduce #(into %1 (apply hash-map %2)) {}) \n                              )))", "user": "5d02fe44e4b0cc9c915881c0"}, {"problem": 105, "code": "(fn f [s]\n  (reduce (fn [r [ks ns]]\n            (apply assoc r (concat (interpose [] ks) [ns])))\n          {}\n          (partition 2 (partition-by keyword? s))))", "user": "5012da69e4b0c8732600222d"}, {"problem": 105, "code": "(fn[xs]\n   (reduce (fn [xs s] (assoc xs (first s) (rest s))) {}\n    (reduce #(if (keyword %2)\n               (conj (vec %1) [%2]) (let [lst (last %1)\n                                          bt-lst(butlast %1)]\n                                      (conj (vec bt-lst) (conj lst %2)))) [] xs)))", "user": "5d0cf1c8e4b0cc9c91588246"}, {"problem": 105, "code": "(fn to-map [coll]\n  (loop [acc {}\n         cl (next coll)\n         k (first coll)\n         n-acc []]\n    (cond\n      (nil? cl) (if (nil? k) {}\n                             (assoc acc k n-acc))\n      (keyword? (first cl)) (recur (assoc acc k n-acc)\n                                   (next cl)\n                                   (first cl)\n                                   [])\n      :else (recur acc\n                   (next cl)\n                   k\n                   (conj n-acc (first cl))))))", "user": "518279abe4b0353c468deb65"}, {"problem": 105, "code": "(fn foo [v]\n  (let [pairs (partition-by keyword? v)]\n    (loop [ps pairs\n           d {}]\n      (if (empty? ps) d\n          (let [ks (first ps)\n                vals (vec (second ps))\n                val-entry [(last ks) vals]\n                empty-entries (into [] (for [k (butlast ks)] [k []]))\n                all-entries (conj empty-entries val-entry)]\n            (recur (rest (rest ps)) (into d all-entries)))))))", "user": "5d3ae729e4b01671435dbd5d"}, {"problem": 105, "code": "(fn [coll]\n  (loop [x (first coll)\n         xs (rest coll)\n         key nil\n         result {}]\n    (if (nil? x)\n      result\n      (if (keyword? x)\n        (recur (first xs) (rest xs) x   (assoc result x   (get result x [])))\n        (recur (first xs) (rest xs) key (assoc result key (conj (get result key []) x)))))))", "user": "5d35f997e4b01671435dbd1a"}, {"problem": 105, "code": "(fn [xs]\n  (loop [acc {}\n         xs xs]\n    (if-not (seq xs)\n      acc\n      (let [[k & more] xs\n            [values mores] (split-with (complement keyword?) more)]\n        (recur (assoc acc k values) mores)))))", "user": "5338387de4b0e30313ee6c91"}, {"problem": 105, "code": "(fn [coll]\n   (into {} (reduce (fn [acc e]\n                      (if (keyword? e)\n                        (conj acc [e []])\n                        (let [orig acc\n                              k (first (last orig))\n                              xs (conj (second (last orig)) e)]\n                          (conj (vec (drop-last orig)) [k xs]))))\n                    []\n                    coll)))", "user": "5574c172e4b05c286339e059"}, {"problem": 105, "code": "(fn keymap [xs]\n        (if (empty? xs) {}\n            (if (keyword? (first xs))\n              (into {(first xs) (take-while (complement keyword?) (rest xs))}\n                    (keymap (drop-while (complement keyword?) (rest xs)))))))", "user": "5d4b2155e4b0776584bd6f28"}, {"problem": 105, "code": "(fn [x]\n  (let [data (reduce\n              (fn [a b]\n                (if (every? keyword? [(last a) b])\n                  (conj a [] b)\n                  (conj a b)))\n              [] x)]\n    (->> data\n         (partition-by keyword?)\n         (map #(if (keyword? (first %))\n                 (first %) (flatten %)))\n         (apply hash-map))))", "user": "5c2836ebe4b07e362c2305d4"}, {"problem": 105, "code": "(fn [seq]\n    (loop [actual seq\n           mapas {}]\n      (if (pos? (count actual))\n        (let [clave (first actual)\n              actual (drop 1 actual)\n              valores (take-while number? actual)]\n          (recur (drop (count valores) actual)\n                 (conj mapas {clave valores})))\n        mapas)))", "user": "5d0153f9e4b0cc9c915881aa"}, {"problem": 105, "code": "(fn [L]\n    (loop \n      [\n        Ret {}\n        CurKey nil\n        First (first L)\n        Rest (rest L)\n      ]\n      (if (nil? First)\n        Ret\n        (let\n          [\n            NextKey\n            (if (keyword? First)\n              First\n              CurKey\n            )\n            NewRet (if (keyword? First)\n              (assoc Ret NextKey [])\n              (assoc Ret NextKey (conj (get Ret NextKey) First))\n            )\n          ]\n          (recur NewRet NextKey (first Rest) (rest Rest))\n        )\n      )\n    )\n  )", "user": "5d4a6c6ce4b0776584bd6f22"}, {"problem": 105, "code": "(fn\n  [xs]\n  (loop [ret {} c nil [x & r :as xs] xs]\n    (if (seq xs)\n      (if (keyword? x)\n        (recur (assoc ret x []) x r)\n        (recur (update-in ret [c] conj x) c r))\n      ret)))", "user": "5d0bb4fae4b0cc9c91588237"}, {"problem": 105, "code": "#(reduce (fn [m e]\n           (if (number? e)\n             (let [[k v] (first m)]\n               (update-in m [k] conj e))\n             (assoc m e []))) {} %)", "user": "5d29c06be4b01671435dbc6b"}, {"problem": 105, "code": "(fn identify-keys-and-values [kvs]\n  (loop [[kv & kvs] kvs\n         k nil\n         m {}]\n    (cond\n      (nil? kv) m\n      (keyword? kv) (recur kvs kv (assoc m kv []))\n      :else (recur kvs k (assoc m k (conj (m k) kv))))))", "user": "5d6042f2e4b0c9e5857d5006"}, {"problem": 105, "code": "(fn kv [acc k [v & vs]]\n  (cond (nil? v) acc\n        (keyword? v) (kv (assoc acc v []) v vs)\n        :e (kv (update-in acc [k] conj v) k vs))) {} *", "user": "5d67c955e4b0db5d338d15f7"}, {"problem": 105, "code": "(fn k-groups\n  [xs]\n  (loop [ret {}\n         xs xs]\n    (if (seq xs)\n      (let [k (first xs)\n            [vs more] (split-with number? (rest xs))]\n        (recur (assoc ret k vs) more))\n      ret)))", "user": "5d609ddde4b0c9e5857d5008"}, {"problem": 105, "code": "(fn f\n  ([v] (if (not (empty? v))\n          (f (rest v) (first v) {} [])\n          {}))\n  ([v k m a]\n    (if (empty? v)\n      (assoc m k a)\n      (if (keyword? (first v))\n        (recur (rest v) (first v) (assoc m k a) [])\n        (recur (rest v) k m (conj a (first v)))))))", "user": "5d52bf29e4b0776584bd6f69"}, {"problem": 105, "code": "(fn\n  [coll]\n  (first\n    (reduce\n      (fn [[result kw] kw-or-n]\n        (if (keyword? kw-or-n)\n          [(if (result kw-or-n) result (assoc result kw-or-n [])) kw-or-n]\n          [(assoc result kw (conj (result kw) kw-or-n)) kw]))\n      [{} nil] coll)))", "user": "5d38a4dde4b01671435dbd4a"}, {"problem": 105, "code": "#(first((fn [c] (reduce (fn [[acc k] x]\n                   (if (keyword? x) [(assoc acc x []) x]\n                                    [(assoc acc k (conj (k acc) x)) k])) [{} nil] c)) %))", "user": "5d764e52e4b02e6b30c93524"}, {"problem": 105, "code": "(fn [x]\n  (reduce (fn [a x] (if (keyword? x)\n             (into a [[x []]])\n             (assoc \n               a\n               (first (last a))\n               (conj (second (last a))\n                     x))))\n          {}\n          x))", "user": "5d1b2b7de4b02ea6f0fb697a"}, {"problem": 105, "code": "(fn [xs]\n  (if (empty? xs)\n    {}\n    (loop [r {} k (first xs) v [] [x & xs] (rest xs)]\n      (cond\n        (nil? x) (conj r [k v])\n        (number? x) (recur r k (conj v x) xs)\n        (keyword? x) (recur (conj r [k v]) x [] xs)))))\n\n;#(->> (partition-by keyword? %)\n;       (partition 2)\n;       (reduce (fn [agg [k v]]\n;                 (-> (zipmap (reverse k) (cons v (repeat ())))\n;                     (into agg))) {}))\n\n;(fn [xs]\n;  (let [r (partition-by keyword? xs)]\n;    (merge\n;      (zipmap\n;        (map last (take-nth 2 r))\n;        (take-nth 2 (rest r)))\n;      (zipmap\n;        (flatten (map drop-last (take-nth 2 r)))\n;        (repeat [])))))", "user": "557c6ca6e4b05c286339e0c4"}, {"problem": 105, "code": "(fn [coll]\n   (if (empty? coll) {}\n     (reduce merge\n             (remove nil?\n                     (for [[e1 e2]\n                           (partition-all 2 1\n                                          (partition-by keyword coll))]\n                       (cond\n                         (integer? (first e1)) nil\n                         (nil? e2) {(first e1) []}\n                         (and (keyword? (first e1)) (not (keyword? (first e2)))) {(first e1) e2 }\n                         (and (keyword? (first e1)) (keyword? (first e2))) {(first e1) []}\n                         ))))))", "user": "5d9c1226e4b0d3f9b434ad51"}, {"problem": 105, "code": "(fn [x] (let [l (partition-by #(and (keyword? %) %) x)\n               p (map vector l (rest l))\n               r (filter #(-> % first first keyword?)p)]\n           (into {} (for [[k v] r]\n                      (if (-> v first keyword?) [(first k) []] [(first k) (vec v)])))))", "user": "5951190be4b066ee0a44aea4"}, {"problem": 105, "code": "(fn [c]\n  (if (empty? c)\n    {}\n    (loop [k (first c)\n           v []\n           m {}\n           [n & r] (rest c)]\n      (let [k? (keyword n)\n            m (if k? (assoc m k v) m)\n            v (if k? [] (concat v [n]))\n            k (if k? n k)]\n        (prn {:k k :v v :m m :n n :r r})\n        (if (empty? r)\n          (assoc m k v)\n          (recur k v m r))))))", "user": "5cf6522be4b0b71b1d808a58"}, {"problem": 105, "code": "(fn f [xs]\n  (if (empty? xs) {}\n      (into {} (cons [(first xs) (vec (take-while #(not (keyword? %)) (rest xs)))] \n                     (f               (drop-while #(not (keyword? %)) (rest xs)))))))", "user": "5d81b40ce4b0915913b1d379"}, {"problem": 105, "code": "(fn m [[h & t]] \n  (if h\n    (let [val (split-with (comp not keyword?) t)] \n      (merge {h (first val)} (m (last val)))) \n    {}))", "user": "5d47f4dbe4b07c84aa5ae6b5"}, {"problem": 105, "code": "#(reduce (fn [acc2 [k v]] \n      (loop [ c k acc acc2]\n         (if (> (count c) 1) (recur (rest c) (assoc acc (first c) []))\n          (assoc acc (first c) (apply vector v))))) {} (apply hash-map  (partition-by keyword? %)))", "user": "5dc12b0ae4b0e59a23173d84"}, {"problem": 105, "code": "(fn [s] (apply hash-map (reduce #(if (keyword? %2) (conj %1 %2 []) (conj (pop %1) (conj (peek %1) %2))) [] s)))", "user": "52a32876e4b04e0c58e87bfb"}, {"problem": 105, "code": "(fn\n  [coll]\n  (let [ks  (filter keyword? coll)\n        kid (map #(.indexOf coll %) ks)\n        vid (map vector (map inc kid)\n                        (concat (rest kid) [(count coll)]))\n        vs  (map (fn [[a z]] (subvec coll a z)) vid)]\n    (zipmap ks vs)))", "user": "5da760ebe4b000c986472c1a"}, {"problem": 105, "code": "(fn f [s]\n  (if (empty? s)\n    {}\n    (let [key (first s)\n          [val rest] (split-with number? (rest s))]\n      (into (f rest) {key val}))))", "user": "5db92996e4b010eb3c36cd50"}, {"problem": 105, "code": "(fn key_val [xs]\n    (let\n        [\n            red\n                (fn [[ret prev_k] v]\n                    (if (keyword? v)\n                        [(assoc ret v (get ret v [])) v]\n                        [(assoc ret prev_k (conj (get ret prev_k []) v)) prev_k]\n                    )\n                )\n        ]\n        (first (reduce red [{} nil] xs))\n    )\n)", "user": "5db7376fe4b010eb3c36cd43"}, {"problem": 105, "code": "(fn [col]\n  (loop [ [x & restCol] col\n          keyMap nil\n          resultMap {}]\n    (cond\n      (nil? x) resultMap\n      (number? x)\n        (recur\n          restCol\n          keyMap\n          (assoc resultMap keyMap (conj (resultMap keyMap []) x))\n        ) \n      :else\n        (recur\n          restCol\n          x\n          (assoc resultMap x [])\n        )       \n    )\n  )\n)", "user": "5da20e73e4b000c986472be1"}, {"problem": 105, "code": "(fn identify-keys-and-values\n  [ip]\n  (let [op-with-current (reduce\n                         (fn [acc curr]\n                           (if (keyword? curr)\n                             (-> acc\n                                 (assoc :current-key curr)\n                                 (assoc curr []))\n                             (assoc acc (:current-key acc) (conj ((:current-key acc) acc) curr))))\n                         {:current-key nil}\n                         ip)]\n    (dissoc op-with-current :current-key)))", "user": "5d8c8175e4b0915913b1d3e1"}, {"problem": 105, "code": "(fn [s]\n  (->> s\n       (partition-by keyword?)\n       (map #(if (keyword? (first %)) (interpose [] %) [%]))\n       (apply concat)\n       (apply hash-map)))", "user": "5ab16992e4b073f1774425c4"}, {"problem": 105, "code": "(fn [arr]\n  \n  (->> arr\n       (reduce #(if (keyword? %2)\n                  (conj %1 [%2 []])\n                  (conj (vec (drop-last %1)) (conj (vec (drop-last (last %1))) (conj (last (last %1)) %2))))\n               [])\n       (into {})\n       ))", "user": "5dd1fb19e4b0948ae9d9ad51"}, {"problem": 105, "code": "(fn key-words-and-numbers [coll]\n  (loop [rem coll\n         curr-keyword nil\n         curr-numbers []\n         res {}]\n    (if (empty? rem)\n      (if (and (keyword? curr-keyword) (not (empty? curr-numbers)))\n        (assoc res curr-keyword curr-numbers)\n        res)\n      (let [head (first rem)\n            tail (rest rem)]\n        (if (keyword? curr-keyword)\n          (if (keyword? head)\n            (recur tail head [] (assoc res curr-keyword curr-numbers))\n            (if (number? head)\n              (recur tail curr-keyword (conj curr-numbers head) res)\n              (recur tail curr-keyword curr-numbers res)))\n          (if (keyword? head)\n            (recur tail head [] res)\n            (tail curr-keyword curr-numbers res))))\n      )))", "user": "5dd67c22e4b0948ae9d9ad80"}, {"problem": 105, "code": "(fn [c] (:res (reduce (fn [{:keys [res lst]} n]\n                      (if (keyword? n)\n                        {:res (assoc res n []) :lst n}\n                        {:res (merge-with conj res {lst n}) :lst lst}))\n                    {:res {}}\n                    c)))", "user": "529dfc6de4b04e0c58e87b8a"}, {"problem": 105, "code": "(fn kkk[coll](loop [coll coll\n                      vvv []\n                      ret {}\n                      ky 0]\n                 (println coll vvv ret ky)\n                 (cond\n                 (empty? coll)ret\n                 :else (recur (rest coll)\n                              (cond\n                                (keyword? (first coll)) []\n                                :else (conj vvv (first coll)))\n                              (cond\n                                (keyword? (first coll))(assoc ret (first coll) [])\n                                :else (assoc ret ky (conj vvv (first coll))))\n                              (cond\n                                (keyword? (first coll)) (first coll)\n                                :else ky)))))", "user": "5dadf73ee4b0f8c104ccfc86"}, {"problem": 105, "code": "(fn [s]\n  (loop [i 0, r {}, l (first s)]\n    (let [v (get s i)]\n      (cond (= i (count s)) r\n            (keyword? v) (recur (inc i) (merge r {v []}) v)\n            :else (recur (inc i) (merge r {l (conj (r l) v)}) l)))))", "user": "5dc9ccf8e4b02f9375f4e1f1"}, {"problem": 105, "code": "(fn [s]\n  (dissoc (reduce #(if (number? %2) (assoc %1 (%1 :key) (conj (%1 (%1 :key)) %2)) (assoc %1 %2 [] :key %2)) {} s) :key))", "user": "5dd60c58e4b0948ae9d9ad7c"}, {"problem": 105, "code": "(fn k-v [x]\n  (loop [rst x\n         current-key nil\n         result {}]\n    (if (empty? rst) result\n      (if (-> rst first class (= clojure.lang.Keyword)) (recur (rest rst) (first rst) (assoc result (first rst) []))\n        (recur (rest rst) current-key (assoc result current-key (conj (result current-key) (first rst))))))))", "user": "5d9c9446e4b0eb781811cdae"}, {"problem": 105, "code": "(fn p-105 [s]\n  (loop [s s\n    res {}]\n  (if (empty? s) res\n      (let [k (first s)\n            vals (take-while integer? (rest s))\n            s (drop-while integer? (rest s))\n            res (assoc res k (vec vals))]\n        (recur s res)))))", "user": "5bfc9037e4b0bdcf453d15f2"}, {"problem": 105, "code": "(fn identify [sequ]\n  (loop [xs {}\n         curkey nil\n         [curel & others] sequ]\n    (if (nil? curel)\n      xs\n\t    (if (keyword curel)\n\t      (recur (into xs { curel [] }) curel others)\n\t      (let [curcol (curkey xs)]\n\t        (recur (into xs {curkey (conj curcol curel)}) curkey others))))))", "user": "5df0c6ffe4b093ff717275c2"}, {"problem": 105, "code": "(fn kv [acc k [v & vs]]\n  (cond (nil? v) acc\n        (keyword? v) (kv (assoc acc v []) v vs)\n        :e (kv (update-in acc [k] conj v) k vs))) {} *", "user": "5e00b6e7e4b0a607a9a45d2b"}, {"problem": 105, "code": "(fn [coll]\n  (loop [coll1 coll\n         key1 nil\n         map1 {}]\n    (cond\n      (empty? coll1) map1\n      (keyword? (first coll1)) (recur (rest coll1) (first coll1) (assoc map1 (first coll1) []))\n      :else (recur (rest coll1) key1 (update-in map1 [key1] #(conj % (first coll1)))))))", "user": "5e0d948fe4b099d064962f98"}, {"problem": 105, "code": "(fn [coll]\n  (letfn [(get-num [coll]\n            (loop [res [], [a & yy] coll]\n              (if-not (number? a)\n                res\n                (recur (conj res a) yy))))\n          (get-map-coll  [[a & b] m]\n            (let [v (get-num b)\n                  c (count v)]\n              [(conj m {a v}) (drop c b)]))]\n    (if (empty? coll)\n      {}\n      (loop [[res col] (get-map-coll coll {})]\n        (if (empty? col)\n          res\n          (recur (get-map-coll col res)))))))", "user": "5cf72682e4b0b71b1d808a68"}, {"problem": 105, "code": "(fn [xs] (apply hash-map\n                (reduce #(if (keyword? %2) (conj % %2 [])\n                             (conj (vec (butlast %))\n                                   (conj (last %) %2))) [] xs)))", "user": "5d81eba4e4b0915913b1d37b"}, {"problem": 105, "code": "(fn my-f [l]\n  (let [instructions (loop [feeder-list l result-list [] item-type :key]\n                      (if (= 0 (count feeder-list))\n                        result-list\n                        (if (= item-type :key)\n                          (recur (rest feeder-list)\n                                (conj result-list (first feeder-list))\n                                :numbers)\n                          (recur (drop-while number? feeder-list)\n                                (conj result-list (take-while number? feeder-list))\n                                :key))))]\n    (if (> (count instructions) 0)\n      (apply assoc {} instructions)\n      {})))", "user": "5c3440fee4b0d62ef62d9f50"}, {"problem": 105, "code": "(fn [s]\n    (-> (reduce (fn [{:keys [k r] :as m} v]\n                  (if (keyword? v)\n                    (->  m\n                         (assoc :k v)\n                         (assoc-in [:r v] []))\n                    (update-in m [:r k] (fn [s] (conj s v)))))\n                {:k nil\n                 :r {}} s)\n        :r))", "user": "5d236215e4b02ea6f0fb6a09"}, {"problem": 105, "code": "(fn __ [l]\n  (apply hash-map\n         (reduce\n           (fn [prev-l item]\n             (let [last-item (last prev-l)]\n               (if (keyword? last-item)\n                 (if (-> (first item) (keyword?))\n                   (into prev-l [[] (first item)])\n                   (into prev-l [item]))\n                 (into prev-l item))\n               )\n             )\n           []\n           (partition-by #(and (keyword? %) (identity %)) l))))", "user": "5e300655e4b05b4b01516209"}, {"problem": 105, "code": "(fn id-key-val [coll]\n  (loop [c coll result {}]\n    (if (empty? c)\n      result\n      (recur\n        (drop-while  #(not= (type %) clojure.lang.Keyword) (rest c))\n        (assoc result (first c) (vec (take-while #(not= (type %) clojure.lang.Keyword) (rest c))))))))", "user": "5e380e72e4b01d43a70e8db0"}, {"problem": 105, "code": "(fn idk\n            ([col] (idk {} col))\n            ([result col] (idk result col (first col)))\n            ([result col x]\n             (if (empty? col)\n               result\n               (if (keyword? (first col))\n                 (recur (assoc result (first col) []) (rest col) (first col))\n                 (recur (assoc result x (conj (result x) (first col))) (rest col) x)))))", "user": "5e1c3e6ee4b0dc9594008530"}, {"problem": 105, "code": "(fn [coll]\n  (loop [colls coll\n         kw nil\n         result {}]\n    (if (not (seq colls))\n      result\n      (let [n (first colls)]\n        (if (keyword? n)\n          (recur (rest colls)\n                 n\n                 (assoc result n []))\n          (recur (rest colls)\n                 kw\n                 (assoc result kw (conj (kw result) n))))))))", "user": "5cb41c40e4b026601754b911"}, {"problem": 105, "code": "(fn [s]\n  (loop [s s\n         acc {}\n         k nil]\n    (if (empty? s)\n      acc\n      (let [this (first s)]\n        (if (keyword? this)\n          (recur (rest s) (assoc acc this []) this)\n          (recur (rest s) (update-in acc [k] conj this) k))))))", "user": "52860baae4b0239c8a67ae09"}, {"problem": 105, "code": "(fn  [l] \n (first (reduce (fn [[result key] x]\n            (if (keyword? x) \n              [(assoc result x []) x]\n              [(assoc result key (conj (result key) x)) key])) [{} nil] l)))", "user": "5e308d0ae4b05b4b01516215"}, {"problem": 105, "code": "(fn [syms]\n  (apply hash-map \n    (reduce (fn [r s] \n              (cond (and (keyword? s) (keyword? (last r))) (conj r [] s)\n                    (keyword? s) (conj r s)\n                    (not (vector? (last r))) (conj r [s])\n                    :else (update-in r [(dec (count r))] #(conj % s)))) \n            [] syms)))", "user": "5e2549c8e4b05b4b0151615f"}, {"problem": 105, "code": "(fn kv [s]\n  (:m (reduce (fn [{:keys [m k] :as a} x]\n            (if (keyword? x)\n              (assoc a :m (assoc m x []) :k x)\n              (assoc a :m (merge-with into m (hash-map k [x])))))\n         {:m {} :k nil} s)))", "user": "5e3a25d4e4b01d43a70e8dde"}, {"problem": 105, "code": "(fn [coll]\n   (if (empty? coll)\n     {}\n     (loop [key (first coll)\n            nums []\n            coll (rest coll)\n            acc {}]\n       (let [[h & t] coll]\n         (if (nil? h)\n           (assoc acc key nums)\n           (if (keyword? h)\n             (recur h [] t (assoc acc key nums))\n             (recur key (conj nums h) t acc)))))))", "user": "5e3ef7d4e4b01d43a70e8e2d"}, {"problem": 105, "code": "(letfn\n  [(kv-ident\n     [col]\n     (loop [c col res {}]\n       (if (seq c)\n         (recur\n           (drop-while (complement keyword?) (rest c))\n           (assoc\n             res\n             (first c)\n             (take-while (complement keyword?) (rest c))))\n         res)))]\n  kv-ident)", "user": "5e53f8e0e4b027a2e10ac0e7"}, {"problem": 105, "code": "(fn kv-ident [kv-coll]\n  (if (empty? kv-coll) {}\n      (loop [k (first kv-coll) curr-v [] r (rest kv-coll) acc {}]\n        (cond\n          (empty? r) (assoc acc k curr-v)\n          (keyword? (first r)) (recur (first r) [] (rest r) (assoc acc k curr-v))\n          :else (recur k (conj curr-v (first r)) (rest r) acc)))))", "user": "5471f2fbe4b094393f72dd70"}, {"problem": 105, "code": "(fn [src]\n   (first(reduce #(if (number? (first %2)) \n              [(assoc (first %)(last %) %2)(last %)]\n              [(assoc (first %)(first %2) '())(first %2)]) [{} nil] \n           (partition-by #(and(not (number? %)) %) src)\n           )\n         )\n   )\n\n;actually my solution is: (it works at repl at latest clojure, seems something is not supported in clojure 1.4.0\n ;(fn [coll]\n ;    (reduce (fn [res i]\n ;              (let [last-key (last (keys res))]\n ;                (if (= clojure.lang.Keyword (type i))\n ;                  (assoc res i [])\n ;                  (assoc res last-key (conj (get res last-key) i)))))\n ;            {} coll)\n ;  )", "user": "5e348945e4b0650de70e2b1d"}, {"problem": 105, "code": "(fn ikv [s]\n    (loop [ret {} s s]\n      (if (seq s)\n        (let [[k & r] s\n              [v n] (split-with number? r)]\n          (recur (assoc ret k v) n))\n        ret)))", "user": "5e5b8d92e4b0fd0acd158658"}, {"problem": 105, "code": "(fn [coll]\n  (->> (partition-by keyword? coll)\n       (partition-all 2)\n       (reduce (fn [ac [keys vals]]\n                 (into ac\n                       (zipmap (reverse keys)\n                               (cons vals (repeat '())))))\n               {})))", "user": "5c3796b3e4b0d62ef62d9f77"}, {"problem": 105, "code": "(fn [coll]\n  (loop [m {} k nil c coll]\n    (if-let [s (seq c)]\n      (let [f (first s) r (rest s)]\n        (if (keyword? f)\n          (recur (assoc m f []) f r)\n          (recur (assoc m k (conj (m k) f)) k r)))\n      m)))", "user": "4eb70649535d7eef30807373"}, {"problem": 105, "code": "(fn [v]\n  (:result (reduce #(let [{current :current\n                result :result} %1]\n           (if (keyword? %2)\n             (assoc %1\n               :current %2\n               :result (assoc result\n                         %2\n                         []))\n             (assoc %1\n               :result (assoc result\n                         current\n                         (conj (get result current)\n                               %2)))))\n        {:current nil\n         :result {}}\n        v)))", "user": "5dc53ddee4b02f9375f4e1bd"}, {"problem": 105, "code": "(fn [arg]\n  \n  (loop [result {} current nil items arg]\n    (if (empty? items) result\n      \n      (if (keyword? (first items))\n        (recur (assoc result (first items) []) (first items) (rest items))\n        (recur (assoc result current (conj (result current) (first items))) current (rest items))))))", "user": "53d977f1e4b0e771c302547a"}, {"problem": 105, "code": "#(loop [sq % mapped {} vs []]\n   (if (empty? sq)\n     (if (empty? vs)\n       mapped\n       (assoc mapped (first vs) (rest vs))\n     )\n     (let [el (first sq)]\n       (if (keyword? el)\n         (if (empty? vs)\n           (recur (rest sq) mapped (conj vs el))\n           (recur (rest sq) (assoc mapped (first vs) (rest vs)) [el])\n         )\n         (recur (rest sq) mapped (conj vs el))\n   )\n  )\n )\n)", "user": "5e947a69e4b0fbed045a37f8"}, {"problem": 105, "code": "#(let [ks (filter keyword? %)\nrest-k (fn [k] (rest (drop-while (fn [x] (not= x k)) %)))\nvs-k (fn [k] (take-while integer? (rest-k k)))]\n(zipmap ks (map vs-k ks)))", "user": "5e13a6b7e4b099d064963001"}, {"problem": 105, "code": "(fn identify-keys-and-values\n  ([coll] (identify-keys-and-values coll {}))\n  ([coll accumap]\n   (if (empty? coll)\n     accumap\n     (identify-keys-and-values\n      (drop (inc (count (take-while number? (rest coll)))) coll)\n      (assoc accumap\n             (first coll)\n             (take-while number? (rest coll)))))))", "user": "5e92adb6e4b0fbed045a37ea"}, {"problem": 105, "code": "(fn mapify [coll]\n  (if (empty? coll)\n    {}\n    (let [[k & xs] coll\n          [vals remaining] (split-with #(not (keyword? %)) xs)]\n      (merge {k (into [] vals)} (mapify remaining)))))", "user": "53528cd3e4b084c2834f4af2"}, {"problem": 105, "code": "#(-> (reduce (fn [[m k] e]\n                 (if (keyword? e)\n                   [(assoc m e []) e]\n                   [(assoc m k (conj (m k) e)) k]))\n               [{} ::none] %)\n       first)", "user": "5a5d0726e4b0512ff01cd91b"}, {"problem": 105, "code": "(fn [coll]\n  (loop [[x & xs] coll\n         cur nil\n         acc {}]\n    (cond (nil? x) acc\n          (keyword? x) (recur xs x (assoc acc x []))\n          :else (recur xs cur (update-in acc [cur] conj x)))))", "user": "5eb1c786e4b00a66d4a95201"}, {"problem": 105, "code": "(fn f ([xs] (f {} (partition-by type xs)))\n  ([l r]\n   (if (empty? r)\n     l\n     (let [next-r (first r)\n           rem-r (rest r)\n           l-new (merge l (hash-map (last next-r) (first rem-r)))]\n       (if (and (= (type (first next-r)) clojure.lang.Keyword)\n                (> (count next-r) 1))\n         (f (reduce merge l-new (map #(hash-map % []) (drop-last next-r)))\n            (drop 1 rem-r))\n         (f l-new (drop 1 rem-r)))))))", "user": "5ec3a13ae4b08d0ec38692b9"}, {"problem": 105, "code": "(fn [s]\n  (let [ss (partition-by keyword? (interpose [] s))]\n       (zipmap  (flatten (filter #(every? keyword? %) ss))\n                (map #(filter number? %) (filter #(every? (complement keyword?) %) ss)))))", "user": "5e6ca949e4b04a83ad7cd289"}, {"problem": 105, "code": "(fn indexed [coll] \n    (let [c (count coll)\n          indexes (conj (vec (keep-indexed #(if (keyword? %2) %1) coll)) c)\n          func (fn make-index [coll] \n                   (let [c (count coll)\n                         a (first coll)\n                         b (second coll)]\n                    (if (< c 2)\n                        [] \n                        (cons [a] (cons (vec (take (- b a 1) (range (inc a) b))) (make-index (drop 1 coll)))))))]\n        ((fn make-map [coll] (if (empty? coll) {} (merge (make-map (drop 2 coll)) (hash-map (first (first coll)) (second coll))))) (map #(mapv coll %) (func indexes)))))", "user": "568f2059e4b0dcc4269f40df"}, {"problem": 105, "code": "(fn [xs]\n  (:acc (reduce #(if (keyword? %2)\n                   (-> (assoc-in %1 [:acc %2] [])\n                       (assoc :lastkey %2))\n                   (update-in %1 [:acc (%1 :lastkey)] conj %2))\n                {:acc {}, :lastkey nil}\n                xs)))", "user": "5de12192e4b0948ae9d9aded"}, {"problem": 105, "code": "(fn [coll]\n   (reduce (fn [m [k v]]\n             (if (= (count k) 1)\n                (assoc m (first k) v)\n               (let [empty-vecs (interpose [] k)]\n                 (merge m (apply hash-map (concat (butlast empty-vecs) [(last empty-vecs) v]))))))\n           {}\n           (partition 2 (partition-by type coll)))\n   )", "user": "56c60b36e4b05cc29241eead"}, {"problem": 105, "code": "(fn [xs]\n  (let [grps (->> xs\n                  (partition-by keyword?)\n                  (partition 2 2))]\n    (reduce (fn [dict [k v]]\n                (let [k (reverse k)]\n                  (into (assoc dict \n                               (first k) \n                               v)\n                        (map #(vector % []) \n                             (rest k))))\n              )\n            {}\n            grps)))", "user": "5ebdb3d2e4b00a66d4a95275"}, {"problem": 105, "code": "(fn solution [args]\n  (loop [map {} key (first args) all (rest args)]\n    (if (nil? key)\n      map\n      (let [splitted (split-with #(not (keyword? %)) all)]\n        (recur (assoc map key (first splitted))\n               (first (second splitted))\n               (rest (second splitted)))))))", "user": "5e2ef900e4b05b4b015161fc"}, {"problem": 105, "code": "(fn [s]\n\n    (let [update-map (fn [m k f] (assoc m k (f (get m k))))]\n      (first (reduce (fn [a v] (if (keyword? v)\n                          [ (assoc (first a) v []) v]\n                          [ (update-map (first a) (second a) #(if (nil? %)\n                                                                [v]\n                                                                (conj % v))  ) (second a) ]\n                          ) ) [{}]  s))\n      ))", "user": "53c73e8ae4b00fb29b2212a5"}, {"problem": 105, "code": "(fn [coll]\n  (->> (partition-by keyword? coll)\n       (map (fn [group]\n              (if (keyword? (first group))\n                (interpose [] group)\n                [group])))\n       (apply concat)\n       (partition 2)\n       (map vec)\n       (into {})))", "user": "5ec6de19e4b08d0ec38692da"}, {"problem": 105, "code": "(fn [xs]\n  (loop [[k & more] xs m {}]\n    (if k\n      (let [[vals rr] (split-with number? more)]\n        (recur rr (assoc m k vals)))\n      m)))", "user": "597dcb0ce4b0dbe32238d0a2"}, {"problem": 105, "code": "(fn [coll]\n  (second\n    (reduce\n      (fn [[k m] c]\n        (if (keyword? c)\n          [c (assoc m c [])]\n          [k (assoc m k (conj (m k) c))]))\n      [nil {}] coll)))", "user": "5e08c3dde4b0978307768fc8"}, {"problem": 105, "code": "(fn [coll]\n  (reduce #(if (keyword? %2) (assoc % %2 []) (assoc-in % [(first (last %)) (count (second (last %)))] %2))\n          (sorted-map)\n          coll))", "user": "50a4f36be4b0344e360f3bc9"}, {"problem": 105, "code": "(fn [args]\n   (letfn [(flush [kw xs res] (if kw (conj res [kw xs]) res))]\n     (loop [[h & t] args\n            kw nil\n            xs []\n            res {}]\n       (cond (nil? h) (flush kw xs res)\n             (keyword? h) (recur t h [] (flush kw xs res))\n             :else (recur t kw (conj xs h) res)))))", "user": "5eee7311e4b07c55ae4a0510"}, {"problem": 105, "code": "(fn __\n  [xs]\n  (loop [xs xs\n         cur nil\n         rt {}]\n    (let [x (first xs)\n          is-keyword? (keyword? x)\n          cur-vals (get rt cur [])]\n      (cond\n        (empty? xs) rt\n        is-keyword? (recur (rest xs) x (assoc rt x []))\n        :else (recur (rest xs) cur (assoc rt cur (conj cur-vals x)))))))", "user": "5b73e500e4b047b03b2036ba"}, {"problem": 105, "code": "(fn [xs]\n  (->> xs\n       (reduce #(if (keyword? %2)\n                  (conj %1 [%2])\n                  (update-in %1 [(dec (count %1))] conj %2))\n               [])\n       (map #(vector (first %) (vec (rest %))))\n       (into {})))", "user": "5dc88a38e4b02f9375f4e1db"}, {"problem": 105, "code": "(fn [x]\n  (loop [r {} [h & xs] x]\n    (if h\n      (recur (assoc r h (take-while number? xs)) (drop-while number? xs))\n      r)))", "user": "5df08767e4b093ff717275bf"}, {"problem": 105, "code": "(fn __ [v]\n    (let [ ks (filter keyword? v) ]\n        (->>\n            ks\n            (map #(.indexOf v %))\n            (partition 2 1 [(count v)])\n            (map #(subvec v (inc (first %)) (second %)))\n            (zipmap ks))))", "user": "5b02ab12e4b0cc2b61a3bd53"}, {"problem": 105, "code": "#(loop [[f & r :as a] (reverse %) l [] m {}]\r\n  (prn [f r l m])\r\n  (if (seq a)\r\n    (cond\r\n      (keyword? f)\r\n      (recur r [] (assoc m f l))\r\n      :else\r\n      (recur r (cons f l) m))\r\n    m))", "user": "5f2c02d1e4b033932238a65f"}, {"problem": 105, "code": "(fn keys-vals [xs]\n  (second (reduce (fn[[c m] x]\n                    (if (keyword? x)\n                      [x (assoc m x [])]\n                      [c (update-in m [c] #(conj % x))]))\n                  [nil {}]\n                  xs)))", "user": "5ed6030de4b016b56eae05db"}, {"problem": 105, "code": "(fn [s] (apply hash-map (mapcat #(if (keyword? (first %)) (if (> (count %) 1) (interpose [] %) %) [(vec %)]) (partition-by keyword? s))))", "user": "5f03ab5be4b0cf489e8d7f37"}, {"problem": 105, "code": "(fn ->map [s]\n  (->> s\n       (reduce\n         (fn [m e]\n           (if (keyword? e)\n             (conj m [e []])\n             (let [[k vs] (peek m)]\n               (conj (pop m) [k (conj vs e)]))))\n         [])\n       (into {})))", "user": "5f300f28e4b033932238a682"}, {"problem": 105, "code": "(fn kv [acc k [v & vs]]\n  (cond\n    (nil? v) acc\n    (keyword? v) (kv (assoc acc v []) v vs)\n    :else (kv (update-in acc [k] conj v) k vs))) {} nil", "user": "5cf895efe4b0b71b1d808a85"}, {"problem": 105, "code": "(fn [s]\n  (letfn [(ljoin [l] (map (fn [e1 e2] (if (keyword? e2) [e1 []] [e1 e2]) ) l (rest l)))\n          (flat-keywords [e] (if (keyword? (first e)) (first e) e)) ]\n    (->> (map (fn [e r] [e r]) s (range))\n         (partition-by (fn [[e r]] (if (keyword? e) r  -1)))\n         (map (fn [e] (map first e)))\n         (map  flat-keywords)\n         ljoin\n         (filter (fn [[k v]] (keyword? k)))\n         (into (sorted-map)))))", "user": "53a5bc3ae4b0ef122a8689c3"}, {"problem": 105, "code": "(letfn [(split-kw [[acc ck cl] k] (let [[ck cl] (if (keyword? k) [k []] [ck (conj cl k)])] [(assoc acc ck cl) ck cl]))]\n  (fn [l] (first (reduce split-kw [{} nil nil] l))))", "user": "5ecc0831e4b016b56eae058c"}, {"problem": 105, "code": "(fn [l]\n   (->> l\n        (partition-by keyword?)\n        (partition-all 2)\n        (reduce (fn [m [keys vals]]\n                  (reduce #(assoc %1 %2 (if (= (last keys) %2) vals [])) m keys)) {})))", "user": "5f3f2281e4b004f08c61c561"}, {"problem": 105, "code": "(fn idkv\n  [input] \n  (into {}\n        (reduce\n         (fn [sofar nextup]\n           (let [[lastkey lastval] (last sofar)]\n             (cond\n               (keyword (first nextup)) (into sofar (map  #(vector % []) nextup ))\n               (and\n                (keyword? lastkey)\n                (not (keyword (first nextup))))  (conj (pop sofar) [lastkey (vec nextup)])  \n               :else sofar )\n             ))\n         []\n         (partition-by keyword?\n                       input))))", "user": "5bf9d9b7e4b0bdcf453d15c4"}, {"problem": 105, "code": "(fn idkv [arg]\n\t(loop [res {}, gobble arg]\n\t\t(if (empty? gobble)\n\t\t\tres\n\t\t\t(let [newkey (first gobble),\n\t\t\t\trestgobble (rest gobble)\n\t\t\t\tnewval (take-while number? restgobble)\n\t\t\t\tnewgobble (drop-while number? restgobble)\n\t\t\t\t]\n\t\t\t\t(recur\n\t\t\t\t\t(assoc res newkey newval)\n\t\t\t\t\tnewgobble\n\t\t\t\t)\n\t\t\t)\n\t\t)\n\t)\n)", "user": "5d73530ce4b02e6b30c93514"}, {"problem": 105, "code": "(fn idkv [arg]\n(loop [res {}, gobble arg]\n(if (empty? gobble)\nres\n(let [newkey (first gobble),\nrestgobble (rest gobble)\nnewval (take-while number? restgobble)\nnewgobble (drop-while number? restgobble)\n]\n(recur\n(assoc res newkey newval)\nnewgobble\n)\n)\n)\n)\n)", "user": "5f06caa7e4b0cf489e8d7f52"}, {"problem": 105, "code": "#(first (reduce (fn [[m l] n]\n                   (if (keyword? n)\n                     [(merge-with into m {n []}) n]\n                     [(merge-with into m {l [n]}) l]))\n                 [{}, nil]\n                 %))", "user": "5f3abcc4e4b004f08c61c52b"}, {"problem": 105, "code": "(fn [s]\n    (let [inp (partition-by type s)]  ; partitions keys, and numbers\n        ;(println inp)\n        (let [paired \n            (reduce (fn [acc x]\n                    ;(println \"red: \" acc x)\n                    (if (keyword? (first x))\n                        (if (> (count x) 1)\n                            (into acc (interpose [] x))\n                            (conj acc (first x)))\n                        (conj acc x)))\n                    [] inp)]\n            ;(println paired)\n            ;(into {} (map (partial into []) (partition 2 paired)))\n            (zipmap (take-nth 2 paired)\n                    (take-nth 2 (drop 1 paired))))))", "user": "5eff6c0ee4b0cf489e8d7f11"}, {"problem": 105, "code": "(fn iden [col]\n   (loop [c col\n          out {}]\n     (let [letter (first c)\n           [num other] (split-with number? (rest c))]\n      (if (nil? letter)\n        out\n        (recur other\n               (merge out {letter (into[] num)}))        \n        ))))", "user": "5f0824c5e4b0cf489e8d7f5b"}, {"problem": 105, "code": "(fn [xs]\n  (into {} (map vec (partition 2 (loop [v xs res []]\n                                 (if-let [[f & r] (seq v)]\n                                   (if (keyword? f)\n                                     (recur r (conj res f []))\n                                     (recur r (conj (pop res) (conj (peek res) f))))\n                                   res))))))", "user": "5c9dcb36e4b048ec896c5b1d"}, {"problem": 105, "code": "#(first (reduce (fn [[m k] v]\n                 (if (keyword? v)\n                   [(assoc m v []) v]\n                   [(update-in m [k] conj v) k])) [{} ()] %))", "user": "588fbb39e4b00487982d51bd"}, {"problem": 105, "code": "(fn [coll] ((fn [res items] (let [[keys values & remaining] items]\n                                    (if (nil? keys)\n                                        res\n                                    (let [[last-key & other-keys] (reverse keys)\n                                          res-upd (assoc res last-key (vec values))\n                                          res-upd-2 (loop [keys other-keys res-upd-3 res-upd]\n                                                      (let [[first-key & remaining-keys] keys]\n                                                      (if (nil? first-key)\n                                                        res-upd-3\n                                                        (recur remaining-keys (assoc res-upd-3 first-key [])))))]\n                                      \n                                       (recur res-upd-2 remaining)\n                                    \n                                    ))) ) {} (partition-by keyword? coll) ))", "user": "5f763c78e4b02876ed9fd0b0"}, {"problem": 105, "code": "(fn kv [acc k [v & vs]]\n  (cond (nil? v) acc\n        (keyword? v) (kv (assoc acc v []) v vs)\n        :e (kv (update-in acc [k] conj v) k vs))) {} *", "user": "5f5f2eafe4b02876ed9fcff5"}, {"problem": 105, "code": "(fn [inputs]\n  (dissoc\n   (reduce\n    (fn [state step]\n      (if (integer? step)\n        (assoc\n         state\n         (:cursor state)\n         (conj (get state (:cursor state)) step))\n        (assoc state step [] :cursor step)))\n    {:cursor nil}\n    inputs)\n   :cursor))", "user": "5f79bff2e4b02876ed9fd0ca"}, {"problem": 105, "code": "(fn f\n    ([xs] (f xs {}))\n    ([[x & xs] m]\n     (if xs\n       (recur (drop-while (complement keyword?) xs)\n              (assoc m x (take-while (complement keyword?) xs)))\n       m)))", "user": "507e68abe4b085af06e3afd2"}, {"problem": 105, "code": "(fn idkav [s]\n  (loop [s s\n         r {}]\n    (if (empty? s)\n      r\n      (let [k (first s)\n            [ns v] (loop [ns (rest s)\n                          v []]\n                     (if (empty? ns)\n                       [ns v]\n                       (if (integer? (first ns))\n                         (recur (rest ns) (conj v (first ns)))\n                         [ns v])))]\n        (recur ns (conj r [k v]))))))", "user": "5f8b06afe4b0715f5002d74a"}, {"problem": 105, "code": "#(->> %\n      (partition-by keyword)\n      (partition 2 1)\n      (reduce (fn [m [[k] [i :as is]]] (if (keyword? k) (assoc m k (if (number? i) (vec is) [])) m)) {}))", "user": "596a66cde4b069c0a1a19803"}, {"problem": 105, "code": "(fn [s]\n      (loop [m {}\n             grps (partition-by keyword? s)]\n        (if (empty? grps)\n          m\n          (let [ks (first grps)]\n            (if (> (count ks) 1)\n              (recur (assoc m (first ks) [])\n                     (cons (rest ks) (rest grps)))\n              (recur (assoc m (first ks) (second grps))\n                     (drop 2 grps)))))))", "user": "5f93529ae4b0715f5002d7bc"}, {"problem": 105, "code": "(fn kvs [coll]\n  (let [take-one (fn [coll]\n                   [(first coll) (take-while (complement keyword?) (rest coll))])\n        drop-one (fn [coll] (drop (count (flatten (take-one coll))) coll))]\n    (if (empty? coll)\n      {}\n      (let [[k v] (take-one coll)]\n        (assoc (kvs (drop-one coll)) k v)))))", "user": "5fa74b82e4b0fa27300f3dda"}, {"problem": 105, "code": "(fn [s]\n  (into {} \n        (for [i (range (count s)) \n              :let [e (nth s i)] \n              :when (keyword? e)] \n          [ e \n            (take-while \n             (complement keyword?) \n             (nthrest s (inc i))) \n            ])))", "user": "573a0ecce4b0cd1946bd1088"}, {"problem": 105, "code": "#(case %\n  [] {}\n  [:a 1] {:a [1]}\n  [:a 1, :b 2] {:a [1], :b [2]}\n  [:a 1 2 3 :b :c 4] {:a [1 2 3], :b [], :c [4]})", "user": "5e8ce2fee4b0cb0169546328"}, {"problem": 105, "code": "(fn [e l] (into {} (reduce\n\n  (fn [col ele]\n\n    (if (= (type ele) clojure.lang.Keyword)\n\n      (conj col (vector ele []))\n\n      (conj (vec (drop-last col))\n\n            (vector (first (last col))\n\n                    (conj (second (last col)) ele))))\n\n    ) e l)))\n\n[]", "user": "5fab7ea6e4b08cb800c85ad8"}, {"problem": 105, "code": "(fn [coll]\n  (into {}\n        (map vec\n             (partition 2\n                        (reduce #(if (and  (keyword? (last %)) (keyword? %2)) (conj % [] %2) (conj % %2)) []\n                                (map #(if (and (= 1 (count %)) (keyword? (first %))) (first %)  (vec %))\n                                     (partition-by #(or (number? %) (identity %)) coll)))))))", "user": "5e12327ee4b099d064962fe5"}, {"problem": 105, "code": "#(letfn [(kv [s]\n            (if (keyword? (first s))\n             (cons [(first s) (take-while number? (rest s))] (kv (drop-while number? (rest s))))))]\n    (into {} (kv %)))", "user": "5fd8bcb3e4b05ac5b16ea11b"}, {"problem": 105, "code": "(fn [v]\n  ((fn identify [result k rst]\n     (if (empty? rst) result\n         (let [cur (first rst)]\n           (if (number? cur) (identify (update-in result [k] #(conj % cur)) k (rest rst))\n               (identify (assoc result cur []) cur (rest rst)))))) {} nil v))", "user": "58f98231e4b0438e51c2cf4c"}, {"problem": 105, "code": "(fn [xs]\n  (letfn [(f [acc x]\n            (if (keyword? x)\n              (conj acc x [])\n              (conj (vec (butlast acc)) (conj (last acc) x))))] \n    (apply hash-map (reduce f [] xs))))", "user": "5fa17538e4b0f0ebd91b77e3"}, {"problem": 105, "code": "(fn [c]\n    (letfn [(complete-c [c]\n              (loop [cur-c c\n                     new-c []]\n                (if (empty? cur-c)\n                  new-c\n                  (recur (rest cur-c)\n                         (if (and (keyword? (first cur-c))\n                                  (keyword? (last new-c)))\n                           (conj new-c nil (first cur-c))\n                           (conj new-c (first cur-c)))))))\n            (map-fn [[[x & _] [fst & _ :as y]]]\n              (let [v (if (nil? fst)\n                        []\n                        (vec y))]\n                [x v]))]\n      (->> (complete-c c)\n           (partition-by keyword?)\n           (partition 2)\n           (map map-fn)\n           (vec)\n           (into {}))))", "user": "591ad160e4b09b4ee5954bdf"}, {"problem": 105, "code": "(fn boop [s]\n   \n  (loop [tail s res {} rd 0] \n    (if (> rd 3)\n      res \n      (if (seq tail) \n        (let [cur-keyword (take-while keyword? tail)\n              cur-after-kw (drop-while keyword? tail)\n              cur-integers (take-while integer? cur-after-kw)\n              cur-after-integers (drop-while integer? cur-after-kw)]\n          (if (> (count cur-keyword) 1)\n            (recur (rest tail) (assoc res (first cur-keyword) []) (inc rd) )\n            (recur cur-after-integers (assoc res (first cur-keyword) cur-integers) (inc rd) )          \n            ) )\n        res))))", "user": "5ff676a9e4b06df49cee1497"}, {"problem": 105, "code": "(fn [s]\n    (if (empty? s)\n        {}\n        (loop [s' (rest s)\n               k (first s)\n               v []\n               acc {}]\n            (if (empty? s')\n                (assoc acc k v)\n                (let [x (first s')\n                      xs (rest s')]\n                    (if (keyword? x)\n                        (recur xs x [] (assoc acc k v))\n                        (recur xs k (conj v x) acc)))))))", "user": "600ae927e4b074f607df6689"}, {"problem": 105, "code": "(fn f\n  [col]\n  (if (empty? col)\n    {}\n    (let [k (first col)\n          [v rv] (->> col rest (split-with (complement keyword?)))]\n      (conj {k (apply vector v)} (f rv)))))", "user": "5da7176ae4b000c986472c13"}, {"problem": 105, "code": "#(->> (partition-by keyword? %)\n      (partition 2)\n      (mapcat (fn [[ks vs]]\n                (concat (map (fn [k] [k []]) (butlast ks))\n                        [[(last ks) (vec vs)]])))\n      (reduce (fn [m [k v]] (assoc m k v)) {}))", "user": "5f37263de4b0574c87022c4e"}, {"problem": 105, "code": "(fn q [[k & xs :as v]]\n  (if (empty? v)\n    {}  \n    (assoc (q (drop-while (complement keyword?) xs)) k (take-while (complement keyword?) xs))))", "user": "5e3e23d9e4b01d43a70e8e20"}, {"problem": 105, "code": "(fn [v]\n ; (reduce (fn [r m] (if (keyword? m) \n  ;            (assoc r m [])\n   ;           (assoc r (last (keys r)) (conj (r (last (keys r))) m))))\n    ;        {} \n     ;       v))\n  (case v\n    [:a 1] {:a [1]}\n    [] {}\n    [:a 1, :b 2] {:a [1], :b [2]}\n    [:a 1 2 3 :b :c 4] {:a [1 2 3], :b [], :c [4]}))", "user": "593744abe4b02506e01a299b"}, {"problem": 105, "code": "(fn between-keywords [coll]\n  (into {}\n        (when-let [[x & xs] (seq coll)]\n          (cons [x (take-while (comp not keyword?) xs)]                      \n                (lazy-seq\n                  (between-keywords (drop-while (comp not keyword?) xs)))))))", "user": "601aaa93e4b0bf4ca6b10926"}, {"problem": 105, "code": "(fn [c]\n(loop [[x & xs] c r {} k nil]\n(if x\n(if (keyword? x)\n(recur xs (assoc r x []) x)\n(recur xs (merge-with into r {k [x]}) k))\nr)))", "user": "5fd10010e4b07e53c2f3f02a"}, {"problem": 105, "code": "(fn [coll]\n  (first (reduce (fn [[res sym] value]\n            (if (keyword? value)\n              [(assoc res value []) value]\n              [(update-in res [sym] #(conj % value)) sym]))\n            [{} nil]\n            coll)))", "user": "5338e33fe4b0e30313ee6ca1"}, {"problem": 105, "code": "(fn [xs] (second (reduce #(cond \n                           \t(keyword? %2) (vector %2 (assoc (second %) %2 [])) \n                           \t:else (vector (first %) (assoc (second %) (first %) (conj ((first %) (second %)) %2)))) \n                         [nil {}] \n                         xs)))", "user": "6011b89ee4b074f607df66bc"}, {"problem": 105, "code": "#(loop [result {}\n       kw nil\n       lst %]\n  (if-not (empty? lst)\n    (if (keyword? (first lst))\n      (recur (assoc result (first lst) [])\n             (first lst)\n             (next lst))\n      (recur (assoc result kw (conj (result kw) (first lst)))\n             kw\n             (next lst)))\n    result))", "user": "60096aabe4b074f607df667f"}, {"problem": 105, "code": "(fn identify-keys-and-values [se]\n  (into {}\n        (map (fn [[key & values]]\n               (vector key (into [] values)))\n             (let [new-key (atom false)] ;; generate subsequences (key ? values)\n               (partition-by (fn [elm]\n                               (if (keyword? elm)\n                                 (reset! new-key (not @new-key))\n                                 @new-key))\n                             se)))))", "user": "5fbf6fe7e4b0ad6fc3476147"}, {"problem": 105, "code": "(fn [lst]\n  (letfn [(into-map [l result] \n                    (if (empty? l) result\n                      (into-map (drop-while #(not (keyword? %)) (rest l))\n                                (assoc result \n                                  (first l)\n                                  (take-while #(not (keyword? %)) (rest l))))))]\n    (into-map lst {})))", "user": "60264d89e4b0d5df2af2222d"}, {"problem": 105, "code": "(fn [s]\n  (letfn [(acc-fn [acc v]\n                  (let [d (first acc)\n                        l (second acc)\n                        k (nth acc 2)]\n                   (cond (keyword? v)\n                         [(if (not (nil? k)) (assoc d k l) d) [] v]\n                         :else [d (conj l v) k])))]\n    (first (reduce acc-fn [{} [] nil] (conj s :end)))\n    ))", "user": "5f419985e4b0955706451fab"}, {"problem": 105, "code": "(fn doo [coll]\n    (loop [coll coll res {} cur nil]\n    (cond (empty? coll ) res\n        (keyword? (first coll)) \n            (recur (rest coll) (conj res (hash-map (first coll) [])) \n                   (first coll))\n        :else \n            (recur (rest coll) \n                (assoc res cur (conj (res cur) (first coll))) cur)\n    )\n    )   \n)", "user": "6038b6b4e4b0d5df2af222ef"}, {"problem": 105, "code": "(fn [coll]\n  (merge {} (apply merge (flatten (flatten (map (fn [g] [(let [ks (first g)]\n                                                         [(map (fn [k] {k []}) (butlast ks)) {(last ks) (into [] (last g))}])])\n                                               (partition 2 (partition-by keyword? coll))))))))", "user": "54d7e277e4b0a52adc2e2031"}, {"problem": 105, "code": "(fn kv [[h & t]] \n  (let [[m k v] (reduce \n   (fn [[m k v] i] \n     (if (number? i) \n       [m k (conj v i)] \n       [(conj m [k v]) i []])) \n   [{} h []] \n   t)] (if (nil? k) m (conj m [k v]))))", "user": "604d3cb1e4b0b7ec0ac60ac2"}, {"problem": 105, "code": "(fn keys-vals [l]\n  ;; we assume that the first element is always a keyword\n  (loop [result {}\n         l l]\n    (if (empty? l)\n     result\n     (let [key (first l)\n           [vals l] (split-with (comp not keyword?) (rest l))]\n       (recur (assoc result key (vec vals)) l)))))", "user": "60460824e4b02d28681c77bc"}, {"problem": 105, "code": "(fn identity-map\n  [mv]\n  (if (empty? mv)\n    {}\n    (let [v1 (reduce\n               (fn [res v]\n                 (if (and (keyword? v)\n                          (keyword? (last res)))\n                   (conj res nil v)\n                   (conj res v)))\n               []\n               mv)]\n      (->> (partition-by #(and (keyword? %)\n                               (identity %)) v1)\n           (partition 2)\n           (map #(hash-map (ffirst %) (remove nil? (last %))))\n           (apply merge)))))", "user": "4e586949535d8a8b8723a292"}, {"problem": 105, "code": "(fn __ [in]\n  (apply hash-map\n         (loop [in in\n                out []\n                k nil\n                xs []]\n           (prn in out k xs)\n           (if (seq in)\n             (if (keyword? (first in))\n               (if (nil? k)\n                 (recur (rest in)\n                        out\n                        (first in)\n                        xs)\n                 (recur (rest in)\n                        (conj (conj out k) xs)\n                        (first in)\n                        []))\n               (recur (rest in)\n                      out\n                      k\n                      (conj xs (first in))))\n             (if (nil? k)\n               out\n               (conj (conj out k) xs))))))", "user": "526759b3e4b03e8d9a4a715b"}, {"problem": 105, "code": "(comp (fn [x] (x 0))\n                        (fn [m] (reduce (fn [[x k] y]\n                                          (cond\n                                            (keyword? y) [(assoc x y [])\n                                                          y]\n                                            :else [(update-in x [k] (fn [val]\n                                                                      (conj val y)))\n                                                   k]))\n                                        [{} :a]\n                                        m)))", "user": "6066c745e4b069485764ddd8"}, {"problem": 105, "code": "(fn [ls]\n  (if (empty? ls) {}\n  (let [knmap (fn knmap [[kw & elems :as lexems]]\n    (if (empty? lexems) '()\n      (let [[l r] (split-with number? elems)]\n        (apply list kw l (knmap r)))))]\n    (apply assoc {} (knmap ls)))))", "user": "605b7a90e4b079a07f8593fc"}, {"problem": 105, "code": "(fn km[col] (loop [v (vec col)\n                     m {}\n                     current_key 'nil]\n           (cond (empty? v) m\n                 :else (let [val (first v)]\n                         (cond (keyword? val) (recur\n                                               (rest v)\n                                               (assoc m val [])\n                                               val)\n                         :else (recur\n                                (rest v)\n                                (assoc m current_key (conj (get m current_key) val))\n                                current_key))))))", "user": "5bab31f1e4b0a20761a23471"}, {"problem": 105, "code": "(fn [xs]\n  (loop [xs xs ys {}]\n    (if (empty? xs)\n      ys\n      (let [[kw & xs'] xs\n            [nums xs''] (split-with number? xs')]\n        (recur xs''\n               (assoc ys kw nums))))))", "user": "58b81490e4b0ebc645576d8c"}, {"problem": 105, "code": "(fn solve [coll]\n  (trampoline\n   (fn f [m k [x & xs]]\n     (condp = (type x)\n       clojure.lang.Keyword (f (assoc m x []) x xs)\n       java.lang.Long       (f (update-in m [k] conj x) k xs)\n       m))\n   {}\n   nil\n   coll))", "user": "60537cd1e4b04c8f2157d152"}, {"problem": 105, "code": "(fn [s]\n    (second\n     (reduce\n      (fn [[k a] b]\n        (prn \"A \" a \", K \" k \", B\" b)\n        (if (keyword? b)\n          [b (assoc a b [])]\n          [k (assoc a k (conj (get a k) b))]))\n      [nil {}] s)))", "user": "603ae21de4b0d5df2af222fb"}, {"problem": 105, "code": "(fn [coll]\n  (letfn [(step [c]\n            (if (> (count c) 1)\n              (let [key-size (count (first c))]\n                (if (= key-size 1)\n                  (concat [(first (first c)) (vec (second c))] (step (drop 2 c)))\n                  (concat [(first (first c)) []] (step (cons (rest (first c)) (rest c))))))))]\n    (let [vec-result (step (partition-by keyword? coll))]\n      (if (seq vec-result)\n        (apply (partial assoc {}) vec-result)\n        {}))))", "user": "607d6bc1e4b03d835a6eaecc"}, {"problem": 105, "code": "(fn [coll]\n  (let [f (fn [[k m] x]\n            (if (= clojure.lang.Keyword (type x))\n              [x (assoc m x [])]\n              [k (update-in m [k] conj x)]))]\n  (last (reduce f [nil {}] coll))))", "user": "606a70a5e4b069485764ddf2"}, {"problem": 105, "code": "#(loop [input (reverse %), val-group [], result {}]\n   (cond\n    (empty? input) result\n    (keyword? (first input)) (recur (rest input) [] (merge result (hash-map (first input) (reverse val-group))))\n    :else (recur (rest input) (conj val-group (first input)) result)))", "user": "5f548678e4b0a0bc16850a7e"}, {"problem": 105, "code": "(fn identify-k-v\n  [coll]\n  (into {}\n        (reduce (fn [my-list value]\n                  (println my-list)\n                  (if (keyword? value)\n                    (reverse (conj my-list [value []]))\n                    (conj (butlast my-list) [(first (last my-list)) (conj (second (last my-list)) value)]))) [] coll)))", "user": "60396c95e4b0d5df2af222f4"}, {"problem": 105, "code": "#(into {} (reduce (fn[acc i] (if (keyword? i) (cons [i []] acc) (cons [(ffirst acc) (conj (second (first acc)) i)] (rest acc)))) [] %))", "user": "52bc6cb2e4b07a9af57922f5"}, {"problem": 105, "code": "(fn sol [coll]\n  (let [on-each-keyword (let [kwd (atom 0)] (fn [x] (if (keyword? x) (swap! kwd inc) @kwd)))]\n    (->> coll\n         (partition-by on-each-keyword)\n         (filter (comp keyword? first))\n         (map (fn [x] [(first x) (vec (rest x))]))\n         (into {}))))", "user": "60a2715ce4b00e9e6653c445"}, {"problem": 105, "code": "(fn [coll]\n  (loop [coll* coll result {}]\n    (let [key (first coll*)]\n      (if (keyword? key)\n        (let [[value rest*] (split-with (complement keyword?) (rest coll*))]\n          (recur rest* (assoc result key value)))\n        result))))", "user": "6098263be4b00e9e6653c3f9"}, {"problem": 105, "code": "(fn [coll]\n  (if (empty? coll)\n    {}\n    (let [keywords (filter #(not (number? %)) coll)\n          m (zipmap keywords (repeat []))]\n      (loop [c (rest coll) last-keyword (first coll) m m]\n        (cond \n          (empty? c ) m\n          (number? (first c)) (recur (rest c) last-keyword (assoc m last-keyword (conj (m last-keyword) (first c))))\n          :else (recur (rest c) (first c) m))))))", "user": "608ec5e4e4b03bd49d9f36c0"}, {"problem": 105, "code": "(fn [coll]\n  (loop [[a & others] coll\n         k a\n         m {}]\n    (if-not a m\n            (if (keyword? a)\n              (recur others a (assoc m a []))\n              (recur others k (assoc m k (conj (m k) a)))))))", "user": "5f82609ae4b0c071e6c840f9"}, {"problem": 105, "code": "(fn [items]\n    (let [splits (partition-by keyword? items)]\n        (loop [remain splits acc {}]\n            (if (empty? remain)\n                acc\n                (let [ks (reverse (first remain)) vs (second remain)]\n                    (recur \n                        (rest (rest remain))\n                        (apply merge (conj (conj (map (fn [x] {x []}) (rest ks)) acc) {(first ks) (vec vs)}))))))))", "user": "60b2aaebe4b0e0fa5f1b4228"}, {"problem": 105, "code": "(fn kv [s]\n  (loop [s s res {} cur-key (first s)]\n    (if (empty? s)\n      res\n      (let [cur (first s)]\n        (if (keyword? cur)\n          (recur (next s) (assoc res cur []) cur)\n          (recur (next s) (assoc res cur-key (conj (res cur-key) cur)) cur-key))))))", "user": "60b7e2c5e4b0e0fa5f1b4252"}, {"problem": 105, "code": "(fn split-kn [sq]\n  (loop [res {}\n         lst sq]\n    (if (empty? lst)\n      res\n      (let [k (first lst)\n            vs (take-while #(instance? Long %) (rest lst))]\n        (recur (assoc res k (into [] vs)) (drop-while #(instance? Long %) (rest lst)))))))", "user": "51b920bfe4b0e871ca4958f9"}, {"problem": 105, "code": "(fn identify-keys-and-values\n  [coll]\n  (->> coll\n       (partition-by keyword?)\n       (partition 2)\n       (mapcat #(if (< 1 (count (first %)))\n                  (let [[x & xs] (reverse (first %))]\n                    (cons [x (vec (second %))] (map (fn [k] [k []]) xs)))\n                  [[(ffirst %) (vec (second %))]]))\n       (into {})))", "user": "60c0ceb7e4b0e0fa5f1b42a6"}, {"problem": 105, "code": "(fn [xs]\n    (loop [[k & xs] xs res {}]\n      (if k\n        (recur (drop-while number? xs)\n               (assoc res k (take-while number? xs)))\n        res)))", "user": "59419bdfe4b060784b3b78f7"}, {"problem": 105, "code": "(fn p1\n  [xs]\n  (loop [m {}\n         k nil\n         in xs]\n    (if (empty? in)\n      m\n      (recur (if (keyword? (first in)) (assoc m (first in) []) (update-in m [k] conj (first in)))\n             (if (keyword? (first in)) (first in) k)\n             (rest in)))))", "user": "58983e3fe4b00487982d52ce"}, {"problem": 105, "code": "(fn [s]\n  (loop [m {}\n         k (first s)\n         v []\n         s (rest s)]\n    (if (empty? s)\n      (if (nil? k)\n        m\n        (assoc m k v))\n      (let [curr (first s)]\n        (if (keyword? curr)\n          (recur (assoc m k v) curr [] (rest s))\n          (recur m k (conj v curr) (rest s)))))))", "user": "4fe49706e4b0e8f79898feb7"}]