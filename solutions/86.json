[{"code": "#(or (= % 1)\r\n  (if (= % 4) false\r\n    (recur\r\n      (reduce (fn [a c] (+ a (* (- (int c) 48) (- (int c) 48))))\r\n        0 (str %)))))", "problem": 86, "user": "4dce6e41535d5973398f92a2"}, {"code": "(fn k-isHappy? [n]\r\n     (let [to-numsqr (fn [c] (let [x (- (int c) 48)]\r\n\t\t\t\t     (* x x)))\r\n\t    sum-of-sqrs  (fn [x] (apply + (map #(to-numsqr %) (seq (str x)))))]\r\n\t    (loop [st #{} num n]\r\n\t       (let [sq (sum-of-sqrs num)]\r\n\t       (if (contains? st sq)\r\n\t\t   (if (= num 1) true false)\r\n\t\t   (recur (conj st sq) sq ))))))", "problem": 86, "user": "4dae4da5c9a9d6ed4e99dc57"}, {"code": "(fn [n]\r\n  ((fn [n s]\r\n    (if (= n 1) true\r\n      (if (not (nil? (some #{n} s))) false\r\n        (recur \r\n          ((fn [n r]\r\n            (if (< n 10) (+ r (* n n))\r\n              (recur (quot n 10) (+ r (* (mod n 10) (mod n 10))))))\r\n            n 0)\r\n          (conj s n)))))\r\n    n []))", "problem": 86, "user": "4dc1ee85535d020aff1edf91"}, {"code": "(fn [n]\r\n  (let [x (apply + (map #(java.lang.Math/pow (Integer/parseInt %) 2) (re-seq #\".\" (str n))))]\r\n    (cond\r\n     (= x 4)\r\n     false\r\n     (= x 1)\r\n     true\r\n     :else\r\n     (recur (int x)))))", "problem": 86, "user": "4dada599c9a9d6ed2b99dc57"}, {"code": "(fn [nb]\r\n       (letfn [(formula [n] (reduce + \r\n                                    (map \r\n                                      (comp #(* % %) #(Character/digit % 10))\r\n                                      (seq (str n)))))]\r\n              (loop [n nb, iter-left 100]\r\n                (if (= 1 n)\r\n                  true\r\n                  (if (< 0 iter-left)\r\n                    (recur (formula n) (dec iter-left))\r\n                    false\r\n                    )))))", "problem": 86, "user": "4daddc19c9a9d6ed4599dc57"}, {"code": "(fn [n]\r\n    (loop [n n s #{}]\r\n      (cond\r\n        (= 1 n) true\r\n        (s n) false\r\n        :else (recur \r\n                (apply \r\n                  +\r\n                  (map \r\n                    (comp (fn [p] (* p p)) read-string str) \r\n                    (str n))) \r\n                (conj s n)))))", "problem": 86, "user": "4db85282535d1e037afb218a"}, {"code": "(fn [z] (= 1 (-> \r\n  (filter #(not (apply distinct? %))\r\n    (for [i (iterate inc 2)] (take i (iterate \r\n      (fn [x]\r\n        (apply + (map #(* % %) (map #(- (int %) (int \\0)) (str x)))))\r\n      z)))) first last)))", "problem": 86, "user": "4dcd818e535d5973398f929d"}, {"code": "(fn [n]\r\n  (letfn [(digits [n] (map #(- (int %) (int \\0)) (seq (str n))))]\r\n\t\t(loop [current-n n, past-ns #{}]\r\n\t\t\t(cond\r\n\t\t\t\t(= current-n 1)               true\r\n\t\t\t\t(contains? past-ns current-n) false\r\n\t\t\t\t:else                         (recur\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t(reduce #(+ %1 (* %2 %2)) 0 (digits current-n))\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t(conj past-ns current-n))))))", "problem": 86, "user": "4dd6d6a0535d2dad7130b5ca"}, {"code": "#(= 4.0 (reduce \r\n  (fn [x1 x2] (* x2 (Math/sqrt x1)))\r\n  % (take 90 (repeat 2))))", "problem": 86, "user": "4dadca03c9a9d6ed4199dc57"}, {"code": "(fn [n] (loop [v #{} n n]\r\n  (let [f #(Character/getNumericValue %)\r\n        s #(* % %)\r\n        m (reduce + 0 (map #(-> % f s) (str n)))]\r\n  (cond (= 1 m) true\r\n        (contains? v m) false\r\n        true (recur (conj v m) m)))))", "problem": 86, "user": "4ddbd934535d02782fcbe9fc"}, {"code": "(fn [n]\r\n    (let [p (fn [number]\r\n              (reduce +  (map #(Math/pow  (-> % str Integer.) 2)  (str (int number)))))]\r\n    (loop [acc {} number n]\r\n      (if (nil? (acc number))\r\n        (if (= number 1)\r\n          true\r\n          (recur (conj acc [number 1]) (p number)) )\r\n        false))))", "problem": 86, "user": "4dd61f98535d2dad7130b5c6"}, {"code": "(fn happy-num [n]\r\n  (letfn [(next_num[n]\r\n  \t   (loop [m n xs []]\r\n\t\t     (if (= m 0)\r\n\t\t       (reduce + xs)\r\n\t\t       (recur (int (/ m 10)) (conj xs (* (mod m 10) (mod m 10)))))))\r\n\t  ]\r\n  (cond (some #(= n %) [2 4]) false\r\n\t(= n 1) true\r\n\t:else (happy-num (next_num n)))))", "problem": 86, "user": "4ddc620d535d02782fcbea06"}, {"code": "(fn [n]\r\n  (letfn [(step [n]\r\n            (reduce (fn [s i] (+ s (* i i)))\r\n                    0 (map #(read-string (str %)) (str n))))]\r\n    (loop [n n seen #{}]\r\n      (cond (= n 1) true\r\n            (seen n) false\r\n            true (recur (step n) (conj seen n))))))", "problem": 86, "user": "4ddc1c89535d02782fcbea01"}, {"code": "(fn [n]\r\n  (loop [n n\r\n         h '()]\r\n    (cond (= n 1)\r\n          true\r\n          (some #(= % n) h)\r\n          false\r\n          :else\r\n          (recur (apply + (map (fn [c]\r\n                                 (let [i (Integer/parseInt (str c))]\r\n                                   (* i i)))\r\n                               (.toString n)))\r\n                 (conj h n)))))", "problem": 86, "user": "4de2f44f535d08e6dec9fdec"}, {"code": "(fn [i-num]\r\n    (let [convert-num (fn [my-num] (map #(Integer/parseInt (str %)) (str my-num)))]\r\n        ((fn is-happy [history my-num]\r\n            (let [\r\n                sum-square (apply + (map #(* % %) my-num))\r\n                new-history (conj history sum-square)\r\n                ]\r\n                (if (= 1 sum-square)\r\n                    true\r\n                    (if (= (count history) (count new-history))\r\n                        false\r\n                        (is-happy new-history (convert-num sum-square))))))\r\n        #{} (convert-num i-num))))", "problem": 86, "user": "4dddf817535d08e6dec9fdd3"}, {"code": "(fn [x]\r\n  (letfn [(d [n]\r\n            (for [y (iterate (partial * 10) 1) :while (<= y n)]\r\n              (rem (int (/ n y)) 10)))\r\n          (s [ds]\r\n            (reduce + (map #(* % %) ds)))]\r\n    (let [r (some #{1 4} (iterate (comp s d) x))]\r\n      (cond\r\n        (= 1 r) true\r\n        (= 4 r) false))))", "problem": 86, "user": "4dc986d0535d5973398f9285"}, {"code": "#(loop [c %1 seen? #{}]\r\n  (cond\r\n    (= c 1) true\r\n    (seen? c) false\r\n    :else (recur \r\n            (apply + (map (fn [a] (* a a))\r\n                        (loop [result [] x c]\r\n                          (if (zero? x)\r\n                            result\r\n                            (recur (conj result (mod x 10))\r\n                                    (int (/ x 10)))))))\r\n            (conj seen? c))))", "problem": 86, "user": "4ddbfb8a535d02782fcbea00"}, {"code": "(fn [num]\r\n            (let [dig (fn [x] (reduce #(+ %1 (* %2 %2)) 0 (map #(- (int %) (int \\0)) (str x))))]\r\n              (loop [digit (dig num)]\r\n             (cond\r\n               (= digit 1) true\r\n               (= digit 4) false\r\n               :else (recur (dig digit))))))", "problem": 86, "user": "4de77a0a535d08e6dec9fdfa"}, {"code": "(fn [n]\r\n       (letfn [(sum [n]\r\n                 (reduce +\r\n                   (map \r\n                     #(Math/pow (rem (quot n (Math/pow 10 %)) 10) 2)\r\n                     (range 0 (inc (count (str n)))))))]\r\n       (loop [nn n ss #{}]\r\n         (let [s (sum nn)\r\n              sss (conj ss s)]\r\n           (if (= s 1)\r\n             true\r\n             (if (ss s)\r\n               false\r\n               (recur s sss))))\r\n         )))", "problem": 86, "user": "4deb529a535d08e6dec9fe04"}, {"code": "(fn [t]\r\n  (letfn [\r\n    (digits [n]\r\n      (loop [d []\r\n             q n]\r\n        (if (> q 0)\r\n\t      (recur (conj d (mod q 10)) (quot q 10))\r\n\t      (reverse d))))\r\n    (step [n]\r\n\t    (reduce (fn [a n] (+ a (* n n))) 0 (digits n)))\r\n    (happy? [n]\r\n      (loop [hist []\r\n   \t         curr (step n)]\r\n\t     (cond (= curr 1)            true\r\n\t           (contains? hist curr) false\r\n\t           :else (recur (conj hist curr) (step curr)))))]\r\n    (happy? t)))", "problem": 86, "user": "4dd52e29535dae65d5c462e5"}, {"code": "#(boolean (#{7 986543210} %))", "problem": 86, "user": "4dfd4ba8535d04ed9115e781"}, {"code": "(fn [v]\r\n  (let [f (fn [x] \r\n    (apply + (map #(* (Integer/parseInt %) (Integer/parseInt %)) \r\n                  (re-seq #\"\\d\" (str x)))))\r\n        s (rest (reductions #(cons %2 %1) nil (iterate f v)))\r\n        s (filter #(or (not (apply distinct? %)) (= (first %) 1)) s)]\r\n    (= (ffirst s) 1)))", "problem": 86, "user": "4def301c535d08e6dec9fe12"}, {"code": "(fn happy [x]\r\n  (letfn [\r\n    (digits [x]\r\n      (if (< x 10)\r\n        [x]\r\n        (conj (digits (int (/ x 10))) (mod x 10))))\r\n    (next-no [x]\r\n      (reduce + (map #(* % %) (digits x))))\r\n    (happyr [x seen]\r\n      (cond\r\n        (= 1 x) true\r\n        (contains? seen x) false\r\n        :otherwise (happyr (next-no x) (conj seen x))))]\r\n    (happyr x #{})))", "problem": 86, "user": "4e03c616535d04ed9115e796"}, {"code": "(fn [n]\r\n  (let [i (apply +\r\n            (map #(* % %)\r\n              (map #(Integer/parseInt (str %)) (str n))))]\r\n    (condp = i\r\n      1 true\r\n      4 false\r\n      (recur i))))", "problem": 86, "user": "4df669d4535d08e6dec9fe35"}, {"code": "(fn [n] (let\r\n           [digits (fn [a] (map #(Integer/parseInt (str %)) (str a)))\r\n            iteration (fn [s] (reduce + (map #(* % %) s)))]\r\n         (loop [visited #{} cur n]\r\n           (if (contains? visited cur)\r\n              false\r\n              (if (= cur 1)\r\n              true\r\n              (recur (conj visited cur) (iteration (digits cur))))))))", "problem": 86, "user": "4e0e0529535d04ed9115e7b9"}, {"code": "(fn happy [num]\r\n   (let [sqr (Math/sqrt num)\r\n         happy-number (+ sqr sqr)]\r\n     (if (< happy-number num)\r\n       true\r\n       false)))", "problem": 86, "user": "4e0d8c27535d04ed9115e7b7"}, {"code": "(fn [x] (letfn [\n(sumsq [c] \n  (reduce #(let [q (- (int %2) 48)]\n                      (+ % (* q q))) \n          0 \n          (str c))) \n(happy? [seen c]\n    (cond\n      (= 1 c) true\n      (seen c) false    \n      :else (happy? (conj seen c) (sumsq c))))]\n(happy? #{} x)))", "problem": 86, "user": "4daa374930acd6ed13482a68"}, {"code": "(fn is-happy [init-n]\r\n  (loop [s [], n init-n]  \r\n    (if (and (> n 1) (not (contains? s n)))\r\n      (recur (conj s n) (reduce + (map #(* \r\n                   (java.lang.Integer/parseInt (str %))\r\n                   (java.lang.Integer/parseInt (str %)))\r\n                  (str n))))\r\n      (= n 1))))", "problem": 86, "user": "4e123905535d04ed9115e7ce"}, {"code": "(fn [x]\r\n  (letfn [(digits [n]\r\n            (for [y (iterate (partial * 10) 1) :while (<= y n)]\r\n              (rem (int (/ n y)) 10)))\r\n          (sqr-sum [ds]\r\n            (reduce + (map #(* % %) ds)))]\r\n    (let [r (some #{1 4} (iterate (comp sqr-sum digits) x))]\r\n      (cond\r\n        (= 1 r) true\r\n        (= 4 r) false))))", "problem": 86, "user": "4e1158aa535d04ed9115e7c6"}, {"code": "(fn[x]\r\n (= 1\r\n  (nth  \r\n    (iterate \r\n      (fn f[x](apply + \r\n        (map #(* % %)\r\n          (loop [r [] v x]\r\n            (if (zero? v) r\r\n             (recur (conj r (mod v 10)) (quot v 10)))))))\r\n   x) \r\n9)))", "problem": 86, "user": "4deff9f9535d08e6dec9fe15"}, {"code": "(fn is-happy? [n]\r\n  (loop [n n]\r\n    (cond (= n 1) true\r\n          (= n 4) false\r\n          :else\r\n          (recur (reduce + (map #(* % %) (map (fn [x] (Character/digit x 10)) (str n))))))))", "problem": 86, "user": "4e043d85535d04ed9115e79e"}, {"code": "(fn happynum ([x]\r\n  (happynum x (list)))\r\n  ([x y]\r\n  (if (= 1 x)\r\n    true\r\n    (let [nums (map #(Character/digit % 10) (str x))\r\n      sqrnums (map #(* % %) nums) \r\n      nextnum (apply + sqrnums)] \r\n      (println y)\r\n      (if (contains? (set y) nextnum)\r\n        false\r\n        (recur nextnum (conj y nextnum)))))))", "problem": 86, "user": "4e16bdef535d04ed9115e7e9"}, {"code": "(fn [n]\r\n  (loop [n n, seen #{}]\r\n    (let [digits (for [d (str n)] (Integer/parseInt (str d)))\r\n          d2 (map #(* % %) digits)\r\n          sum (reduce + d2)]\r\n      (if (= 1 sum)\r\n        true\r\n        (if (seen sum)\r\n          false\r\n          (recur sum (conj seen n)))))))", "problem": 86, "user": "4ddbdc1b535d02782fcbe9fd"}, {"code": "(fn happy \r\n  ([x] (happy #{} x))\r\n  ([coll x]\r\n    (cond\r\n      (= x 1) true\r\n      (nil? (get coll x)) \r\n        (happy (conj coll x)\r\n               (apply + (map (fn [y] (* y y)) \r\n                    (map second\r\n                      (take-while #(> (first %) 0)\r\n                        (iterate (fn [[a b]] (vector (quot a 10) (mod (quot a 10) 10))) [x (mod x 10)]))))))\r\n      true false)))", "problem": 86, "user": "4e14108c535d04ed9115e7dd"}, {"code": "< 4", "problem": 86, "user": "4e307313535deb9a81d77f14"}, {"code": "(fn happy?\n  ([x] (happy? x #{x}))\n  ([x s]\n    (let [newx\n          (->> x\n            (str)\n            (map #(Integer/parseInt (str %)))\n            (map #(* % %))\n            (reduce +))]\n    (cond (= newx 1) true\n          (s newx)   false\n          true       (recur newx (conj s newx))))))", "problem": 86, "user": "4e28120f535deb9a81d77efa"}, {"code": "#(contains? {986543210 0, 7 0} %)", "problem": 86, "user": "4e3b6bff535deb9a81d77f52"}, {"code": "(fn [x] (let [digits\n  (fn [y] (loop [n y, r []]\n    (if (zero? n) r (recur (quot n 10) (conj r (mod n 10))))))]\n  (if (= 1 x) true\n  (if (= 4 x) false\n  (recur (reduce + (map #(* % %) (digits x))))))))", "problem": 86, "user": "4e3ac1b2535deb9a81d77f4c"}, {"code": "(fn [i]\n  (loop [n i past-nums #{}]\n    (if (= 1 n)\n      true\n      (if (past-nums n)\n        false\n        (recur (reduce + (map #(* % %) (map #(Integer. (str %) ) (str n))))\n               (conj past-nums n))))))", "problem": 86, "user": "4df3df8a535d08e6dec9fe2d"}, {"code": "(fn [x]\n\t(let [n (reduce + (map (fn [num](Math/pow (Integer/parseInt num) 2)) (re-seq #\"[0-9]\" (str x))))]\n\t\t(cond\n\t\t  (= 1 n) true\n\t\t  (= 4 n) false\n\t\t  :else (recur (int n)))))", "problem": 86, "user": "4db2cc55535df7e46ed9b6c5"}, {"code": "(fn [n]\n  (loop [total 0\n         curnum n]\n    (if (> total 50) false\n     (if (= 1 curnum) true\n       (recur (inc total)\n        (reduce + (map #(Math/pow \n          (- (int %1) 48) 2) (reverse (str (int curnum))))))))))", "problem": 86, "user": "4e4bf20e535dc968683fc4d9"}, {"code": "(fn happy-number [n]\n  (letfn [(digits [x] (map #(Integer/parseInt (str %)) (str x)))\n    (nxt [x] (apply + (map #(* %1 %1) (digits x))))\n\t  (happy? [x] (loop [x x seen #{}]\n\t\t\t(cond (= 1 x) true\n\t\t\t      (contains? seen x) false\n\t\t\t      :else (recur (nxt x) (conj seen x)))))]\n    (happy? n)))", "problem": 86, "user": "4e513ecf535dc968683fc4f6"}, {"code": "(fn f [v & [z]]\n  (let [z (or z #{})\n        q (reduce #(let [x (- (int %2) 48)] (+ % (* x x))) 0 (str v))]\n    (if (z v) \n      false\n      (or (= q 1)\n          (f q (conj z v))))))", "problem": 86, "user": "4e12cc9d535d04ed9115e7d2"}, {"code": "(fn [s x]\n  (or (= x 1)\n      (if (s x) false\n          (recur (conj s x) (apply + (map #(* (- (int %) 48) (- (int %) 48)) (str x)))))))\n#{}", "problem": 86, "user": "4e52d815535d302ef430da77"}, {"code": "< 3", "problem": 86, "user": "4e36038f535deb9a81d77f31"}, {"code": "(fn h [n]\n  (letfn [(b [o] (apply + (map #(let [a (Integer/parseInt (str %))]\n                                  (* a a))\n                               (str o))))]\n    (loop [p [] i n]\n      (if (some #{i} p)\n        false\n        (if (= i 1)\n          true\n          (recur (conj p i) (b i)))))))", "problem": 86, "user": "4e49badd535dc968683fc4c9"}, {"code": "(fn [a] (loop [d a v #{1} s #(* % %)]\n  (if (v d) \n    (= d 1) \n    (recur \n      (reduce + (map #(s (- (int %) 48)) (str d))) \n      (conj v d) s))))", "problem": 86, "user": "4e5411e8535d8a8b8723a279"}, {"code": "(fn happy?\n  [n]\n  (loop [n n seen #{n}]\n    (let [ds (map #(Integer. (str %)) (seq (str n)))\n          sos (reduce + (map #(* % %) ds))]\n      (cond\n       (= sos 1) true\n       (seen sos) false\n       :else (recur sos (conj seen sos))))))", "problem": 86, "user": "4e50b67b535dc968683fc4ed"}, {"code": "(fn [n]\n  (letfn [(digits [n] (map #(Character/digit % 10) (str n)))\n          (sq-seq [n] (lazy-seq\n                        (if (> n 1)\n                          (cons n (sq-seq (reduce + (map #(* % %) (digits n))))))))]\n         (apply distinct? (sq-seq n))))", "problem": 86, "user": "4e4ad154535dc968683fc4d1"}, {"code": "(fn is-happy? [x]\n  (loop [n x previous #{x}]\n    (let [sum (->> (str n)\n                   (map #(let [digit (Character/digit % 10)]\n                           (* digit digit)),)\n                   (apply + ))]\n      (cond (== sum 1)   true\n            (previous sum) false\n            :else        (recur sum (conj previous sum))))))", "problem": 86, "user": "4e593dac535d8a8b8723a29c"}, {"code": "(fn [n]\n  (let [happy-iter (fn [n seen]\n                     (if (some #{n} seen)\n                       false\n                       (if (= n 1)\n                         true\n                         (recur\n                          (apply + (map #(* (Integer/parseInt %) (Integer/parseInt %))\n                                        (re-seq #\"\\d\" (str n))))\n                          (conj seen n)))\n                       ))]\n    (happy-iter n #{})))", "problem": 86, "user": "4e42f930535dc968683fc49f"}, {"code": "(fn [i]\n  (loop [l [] i i]\n (if (some #{i} l)\n  false\n  (if (= i 1) true\n  (recur (conj l i) (apply + (map #(.pow (- (int %) 48M) 2) (str i))))\n  ))\n))", "problem": 86, "user": "4e43b0d9535dc968683fc4a3"}, {"code": "(fn [n] (loop [s #{} n n]\r\n    (cond (= n 1) true\r\n          (s n) false\r\n          :t (recur (conj s n)\r\n                    (reduce + ((fn [n]\r\n                            (->> (str n)\r\n                                 (map #(Character/digit % 10))\r\n                                 (map #(* % %))))\r\n                          n))))))", "problem": 86, "user": "4e597b2c535d8a8b8723a29d"}, {"code": "(fn happy-number?\n  ([num] (happy-number? num #{}))\n  ([num coll]\n     (letfn [(separate-digits [num]\n               (map #(Integer/parseInt (str %)) (str num)))\n             (square-sum [num]\n               (reduce + (map #(* % %) (separate-digits num))))]\n      (cond\n       (= num 1) true\n       (coll num) false\n       :else (let [next (square-sum num)]\n               (happy-number? next (conj coll num)))))))", "problem": 86, "user": "4e3bccb1535deb9a81d77f55"}, {"code": "(fn [n]\n          (loop [n n]\n             (cond (= n 1) true\n                   (= n 4) false\n                   :else\n                   (recur (reduce + (map #(* % %) ((fn [n] (map #(Character/digit % 10) (str n))) n)))))))", "problem": 86, "user": "4dad7adac9a9d6ed0599dc57"}, {"code": "(fn[n]\n  (letfn[(next-happy[k]\n    (reduce + (map (fn[x] (let [x (Integer/parseInt x)] (* x x))) (map str (seq (str k))))))]\n        (loop [occ #{}\n               k n\n               cnt 0]\n          (if (not= (count occ) cnt)\n            (if (= k 1) true false)\n            (recur (conj occ k) (next-happy k) (inc cnt))))))", "problem": 86, "user": "4e58bcd4535d8a8b8723a296"}, {"code": "(fn happy \n  ([x] (happy x #{}))\n  ([x nums] (let[y ((fn squared-sum [w] (reduce + (map (fn [y] (* y y)) ((fn digits [z] (map {\\0 0 \\1 1 \\2 2 \\3 3 \\4 4 \\5 5 \\6 6 \\7 7 \\8 8 \\9 9} (vec (str z))) ) w)))) x) res (conj nums x)]\n                (if (= y 1) true (if (contains? nums y) false (recur y res)))\n              ))\n  \n  )", "problem": 86, "user": "4e44358f535dc968683fc4a8"}, {"code": "(fn hpy\n  ([n] (hpy n []))\n  ([n acc]\n   (let [seq (map read-string (map str (seq (str n))))\n         sq-sum (apply + (map #(* % %) seq))]\n     (cond\n       (= 1 sq-sum) true\n       (some #{sq-sum} acc) false\n       :else (recur sq-sum (conj acc sq-sum))))))", "problem": 86, "user": "4e5914e0535d8a8b8723a29b"}, {"code": "(fn h [s n]\n  (if (s n)\n    false\n    (if (= n 1)\n      true\n      (h (conj s n) \n        (reduce + 0 \n          (map #(* % %) \n            (map #(- (int %) (int \\0)) \n              (str n)))))))) \n#{}", "problem": 86, "user": "4e5c801e535d8a8b8723a2c1"}, {"code": "(fn happy-number? [x]\n        (letfn [(sq [x] (* x x))\n                (digits [x] (map #(Integer. (str %)) (seq (str x))))\n                (step [x] (apply + (map sq (digits x))))]\n          (loop [x x try 0]\n            (if (< try 10)\n              (let [current (step x)]\n                (if (= 1 current)\n                  true\n                  (recur current (inc try))))\n              false))))", "problem": 86, "user": "4e589bdc535d8a8b8723a295"}, {"code": "(fn [x] (or (= x 7) (= x 986543210)))", "problem": 86, "user": "4e68dbd5535d8ccf87e9fe8f"}, {"code": "(fn [num]\n  (let [digits (fn this [num]\n                (when (< 0 num)\n                  (cons\n                    (mod num 10)\n                    (this (int (/ num 10))))))\n        sum-of-squared-digits\n        (fn [num]\n          (reduce + (map #(* % %) (digits num))))]\n    (loop [coll (iterate sum-of-squared-digits num)\n           seen #{}]\n      (if (= 1 (first coll))\n        true\n        (if (seen (first coll))\n          false\n          (recur (rest coll) (conj seen (first coll))))))))", "problem": 86, "user": "4e68c434535d8ccf87e9fe89"}, {"code": "(fn [n]\n  (letfn [(happy? ([i]\n                    (happy? i #{}))\n                  ([i seen]\n                    (let [new-num (reduce + (map #(* (Integer/parseInt (str %)) \n                                                     (Integer/parseInt (str %))) \n                                                 (str i)))]\n                      (cond \n                        (seen new-num) false\n                        (= 1 new-num)  true\n                        :else (recur new-num (conj seen new-num))))))]\n    (happy? n)))", "problem": 86, "user": "4e68b46c535d8ccf87e9fe87"}, {"code": "(fn [n]\n  (let [d (fn d [x] (if (< x 10) [x] (cons (mod x 10) (d (quot x 10)))))\n        q #(* % %)]\n    (loop [n n s #{}]\n      (cond (s n) false\n            (= n 1) true\n            1 (recur (reduce + (map q (d n)))\n                   (conj s n))))))", "problem": 86, "user": "4e5fe31a535d8ccf87e9fe50"}, {"code": "(fn [x]\r\n    ((fn [i j]\r\n      (if (get j i)\r\n        false\r\n        (if (= i 1)\r\n          true\r\n          (recur\r\n            (reduce + (map #(* % %) (map #(mod (int %) 48) (str i))))\r\n            (conj j i))))) x #{}))", "problem": 86, "user": "4e6a97a9535d8ccf87e9fef8"}, {"code": "(fn [n]\r\n  (cond\r\n   (= n 7) true\r\n   (= n 986543210) true\r\n   (= n 2) false\r\n   (= n 3) false))", "problem": 86, "user": "4e50c894535dc968683fc4ee"}, {"code": "(fn [a] (\n  loop [myn a]\n    (cond (= 1 myn) true\n          (= 4 myn) false\n          :else (recur (#( ->> % str (map (fn [n] (* (- (int n) 48) (- (int n) 48)))) (reduce +)) myn)))))", "problem": 86, "user": "4e6e6630535d5021c1a89609"}, {"code": "(fn happy? [x]\n  (let [\n    nums (fn [n] (map #(Integer/valueOf (str %)) (seq (.toString n))))\n    alg (fn [l] (reduce + (map #(* % %) l)))\n    itr (fn [n] (alg (nums n)))\n    s (some #{1 4} (iterate itr x))\n    ]\n    (= 1 s) \n  ))", "problem": 86, "user": "4e6e10d8535d5021c1a895fd"}, {"code": "< 4", "problem": 86, "user": "4e6a412e535d8ccf87e9feb6"}, {"code": "(fn [n] (loop [s #{} x n]\n  (let [y (reduce + (map #(* % %) (map #(rem % 10)\n            (take-while pos? (iterate #(quot % 10) x)))))]\n    (if (s y) (= 1 y) (recur (conj s y) y)))))", "problem": 86, "user": "4db1bfe21254ad5b4805fa71"}, {"code": "(fn happy? \n     ([x]    (happy? x #{}))\n     ([x tries]\n       (letfn [(expl [n] (map #(- (int %) (int \\0)) (str n)))]\n              (let [next (reduce #(+ %1 (* %2 %2)) 0 (expl x))]\n                (if (= 1 next)\n                  true\n                  (if (get tries next)\n                    false\n                    (happy? next (conj tries next))))))))", "problem": 86, "user": "4e6a5f5c535d8ccf87e9fed6"}, {"code": "(fn [n]\n    (loop [seen #{}\n           n n]\n        (let [v (->> n\n                     str vec\n                     (map #(- (int %) 48))\n                     (map #(* % %))\n                     (reduce +))]\n          (cond\n            (= v 1) true\n            (contains? seen v) false\n            :else (recur (conj seen v) v)))))", "problem": 86, "user": "4e2b1d48535deb9a81d77f03"}, {"code": "(fn [n]\n   (let [happy (fn [n] \n          (reduce + \n            (map #(* % %) \n    (map #(Integer/parseInt %) \n    (map str (str n))))))]\n    (loop [bag #{} n n]\n     (cond \n\t     (= 1 n) true \n\t     (contains? bag n) false\n\t     :else (recur (conj bag n) \n        (happy n))))))", "problem": 86, "user": "4e6e3a1e535d5021c1a89602"}, {"code": "(fn happy-number? [n]\n  (letfn [(digits-as-numbers [n]\n            (->> n\n                 (str)\n                 (re-seq #\"\\d\")\n                 (map #(Integer/parseInt %))))]\n    (loop [n n s #{}]\n      (let [next-n (->> (digits-as-numbers n)\n                        (map #(* % %))\n                        (reduce +))]\n        (if (= 1 next-n)\n          true\n          (if (some #{next-n} s)\n            false\n            (recur next-n (conj s next-n))))))))", "problem": 86, "user": "4e5bff2b535d8a8b8723a2bd"}, {"code": "(fn [x]\n  (= 1\n    (nth\n      (iterate\n        (fn [i]\n          (reduce +  \n            (map\n              #(let [n (Character/getNumericValue %)] (* n n))\n            (Integer/toString i))\n          )\n        )\n      x)\n    10)\n  )\n)", "problem": 86, "user": "4e3456f9535deb9a81d77f2a"}, {"code": "(fn happy? ([current previous]\r\n  (let [char-to-digit (fn [ch] (- (int ch) (int \\0)))\r\n        digits        (map char-to-digit (str current))\r\n        square        (fn [x] (* x x))\r\n        squares       (map square digits)\r\n        total         (reduce + squares)]\r\n    (if (contains? previous current) \r\n        false\r\n        (if (= 1 total) \r\n            true\r\n            (recur total (conj previous current))))))\r\n([current] (happy? current #{})))", "problem": 86, "user": "4e6defcc535d5021c1a895f8"}, {"code": "(fn [n]\n  (letfn [(ds [x] (reduce + (map #(* % %) (map #(Integer/parseInt (str %)) (seq (str x))))))]\n    (loop [i 1 t n]\n      (if (= 1 t)\n        true\n        (if (= 50 i)\n          false\n          (recur (inc i) (ds t)))))))", "problem": 86, "user": "4e6a2f51535d8ccf87e9fea9"}, {"code": "(fn [num] (letfn [(digits [n] (loop [n n ret []] (if (<= 10 n) (recur (quot n 10) (cons (rem n 10) ret)) (cons n ret)))) (sqsum [nums] (reduce #(+ %1 (* %2 %2)) 0 nums))] (= 1 (last (take 10 (iterate #(-> % digits sqsum) num))))  ))", "problem": 86, "user": "4e6fa38b535d5021c1a89622"}, {"code": "(fn happy? [n]\r\n  (loop [n n, s #{}]\r\n    (if (not (and (> n 1) (nil? (s n))))\r\n      (= n 1)\r\n      (recur (reduce + (map #(* (- (int %) 48) (- (int %) 48)) (str n))) (conj s n)))))", "problem": 86, "user": "4df407c3535d08e6dec9fe2e"}, {"code": "#(loop[x% y #{}](cond (= 1 x) true (y x) false 1 (recur (apply + (map (fn[x](let[x (- (int x) 48)] (* x x))) (str x))) (conj y x))))", "problem": 86, "user": "4e7eff9e535db966e863cc38"}, {"code": "(letfn [(digits [n]\n  (for [c (str n)] (- (int c) 48)))\n        (self-scalar-product [lst]\n  (reduce + (map * lst lst)))]\n(fn happy-number [n]\n  (loop [checked #{} check n]\n    (cond\n      (checked check) false\n      (= check 1) true\n:else (recur\n  (conj checked check)\n  (self-scalar-product (digits check)))))))", "problem": 86, "user": "4e356d2b535deb9a81d77f2d"}, {"code": "(fn [n]\n  (letfn [(sum-of-digit-squares [number]\n            (if (= number 0)\n                0\n                (let [digit (rem number 10)]\n                  (+ (* digit digit) (sum-of-digit-squares (quot number 10))))))]\n    (loop [current n past-numbers #{}]\n      (cond (= current 1) true\n            (past-numbers current) false\n            :else (recur (sum-of-digit-squares current) (conj past-numbers current))))))", "problem": 86, "user": "4e7c8fd1535db169f9c796be"}, {"code": "(fn [x] (loop [s #{} x x] (let [d (map #(- (int %) 48) (str x)) h (apply + (map #(* % %) d))] (if (s h) false (if (= 1 h) true (recur (conj s h) h))))))", "problem": 86, "user": "4e7e55ab535db169f9c79711"}, {"code": "(fn [x] (= 1 (last (take 1000 (iterate \n  #(reduce + (map (fn[x] (let [y (Integer/parseInt (str x))] (* y y))) (str  %))) x)))))", "problem": 86, "user": "4e7db3b4535db169f9c796e1"}, {"code": "(fn [x]\n  (letfn [(next-number [x]\n                       (reduce +\n                               (map (fn [x] (* x x))\n                                    (map (fn [c] (Character/getNumericValue c)) (seq (str x))))))\n          (happy-number? [x s]\n                         (let [y (next-number x)]\n                           (if (= y 1)\n                             true\n                             (if (get s y)\n                               false\n                               (happy-number? y (conj s y))))))]\n    (happy-number? x #{})))", "problem": 86, "user": "4dc29a1d535d020aff1edf96"}, {"code": "(fn happy [n]\n  (letfn [(somma [num] (reduce + (map #(Math/pow  (Integer/parseInt (str %)) 2 ) (seq (str (int num))))))]\n\t       (loop [visited #{} sum (somma n)]\n\t\t  (cond (contains? visited sum) false\n\t\t\t(= sum 1) true\n\t\t\t:else (recur (conj visited sum) (somma sum))))))", "problem": 86, "user": "4e739e13535dff18050a9c76"}, {"code": "(fn [x]\n  (loop [c (list x)]\n    (if (or (= 1 (first c)) (some #(= (first c) %) (rest c)))\n      (= (first c) 1)\n      (recur (conj c (apply + (map (comp #(* % %) read-string str) (str (first c)))))))))", "problem": 86, "user": "4e5bdc2b535d8a8b8723a2bb"}, {"code": "(fn [num]\n    ((complement not-any?) #{1}\n     \n     (\n      (fn happy [n]\n        (let [digits  (map #(Integer/parseInt (str %1)) (str n))\n              alg (reduce + (map #(* % %) digits)) ]\n          (take-while #(not= % n) (cons alg (lazy-seq (happy  alg ) )) )\n          ))\n    \n      num ) )\n\n\n    )", "problem": 86, "user": "4e78c208535db95036265722"}, {"code": "(fn happy-num \n  ([n] (happy-num n [n]))\n  ([n xs]\n    (let [s (str n) \n        digits (map #(Character/digit % 10) s) \n        squares (map #(* % %) digits)\n        sum (apply + squares)\n        is-happy (= sum 1)\n        not-happy (some #(= % sum) xs)]\n      (cond is-happy true \n          not-happy false\n\t        :else (recur sum (conj xs sum))))))", "problem": 86, "user": "4e6a4edd535d8ccf87e9fec4"}, {"code": "(fn sol [a x]\n  ( if (a x) (\n      if (= x 1) true false\n    ) ( let [nn \n          ((fn stp[n] (\n            ->> n (str) (\n              reduce #(+ % ((fn [x] (* x x)) (- (int %2) 48))) 0\n              )\n            )\n          ) x)] (sol (conj a x) nn)\n      )\n  )\n) #{}", "problem": 86, "user": "4e7f4147535db966e863cc3d"}, {"code": "(fn [n]\n  (loop [seen #{} n n]\n    (if (seen n)\n      false\n      (if (= 1 n)\n        true\n        (let [sum (reduce #(+ % (* %2 %2)) 0 (map #(- (int %) (int \\0)) (str n)))]\n          (recur (conj seen n) sum))))))", "problem": 86, "user": "4e521cef535d302ef430da6d"}, {"code": "(fn[n](loop [n n, i 0]\n    (if (> i 10000)\n      false\n      (if (= n 1)\n        true\n        (recur \n          (reduce \n            #(+ % %2)\n            (map \n              #(* % %) \n                (map \n                  #(Integer/parseInt (.toString %)) \n                  (str n)\n                )\n            )\n          )\n          (inc i)\n        )\n      )\n  )\n))", "problem": 86, "user": "4e6df3c9535d5021c1a895fa"}, {"code": "(fn happy-num? [x]\n  (loop [keys #{} n x]\n    (let [m (reduce + (map (fn [x] (#(* % %) ( - (int x) 48))) (seq (str n))))]\n      (if (keys m) (= m 1)\n          (recur (conj keys m) m)))))", "problem": 86, "user": "4e7f51eb535db966e863cc3f"}, {"code": "(fn hap [n] \n           (let [digs (map #(Integer/parseInt %) (map str (str n)))\n                      ss (apply + (map #(* % %) digs))]\n    (cond \n      (== 1 ss) true\n      (> (count (str ss)) 1) (hap ss)\n      :e false)))", "problem": 86, "user": "4e80d71b535db62dc21a62b7"}, {"code": "(fn [n]\n  (loop [x n \n         d #{} \n         q #(* % %)\n         r (fn [y] (reduce + (map #(-> % str read-string q) (-> y str seq))))]\n    (let [a (r x)]\n      (cond (= a 1) true\n            (= a (d a)) false \n            :else (recur a (conj d a) q r)))))", "problem": 86, "user": "4daf907aedd6309eace4d17b"}, {"code": "(fn [y] \n    (if (= \n        1\n        (last (into [] (take 100\n            (iterate\n                (fn [x] (reduce + (map #(* % %) (map (fn [x] (Character/getNumericValue x)) (str x))))) \n                y\n            )\n        )))\n       ) true false\n     )\n)", "problem": 86, "user": "4e78dc98535db95036265724"}, {"code": "(fn [v n]\n    (if (= 1 n)\n       true\n       (if (v n)\n          false\n          (recur\n            (conj v n)\n            (reduce #(+ % (* %2 %2))\n               0\n               (map #(Character/digit % 10) (pr-str n)))))))\n#{}", "problem": 86, "user": "4e7dfab0535db169f9c796f9"}, {"code": "(fn [x]\n  (let [\n  iterate* (fn [f x]\n    (let [impl (fn impl [hist f x]\n      (cond\n        (== 1 x) (cons 1 '())\n        (contains? hist x) (cons x '())\n        :else (lazy-seq\n          (cons x (impl (conj hist x) f (f x))))))]\n      (impl #{} f x)))\n  calc (fn [x]\n    (let [square (fn [x] (* x x))\n          sum (fn [xs] (reduce + 0 xs))]\n    (->> x\n         (str)\n         (map #(Integer/parseInt (str %)))\n         (map square)\n         (sum))))\n  ]\n  (->> x (iterate* calc) (last) (== 1))))", "problem": 86, "user": "4e691c79535d8ccf87e9fe97"}, {"code": "(fn [n]\n  (boolean\n   (some #(= 1 %)\n         (take 7 ((fn _ [N]\n                    (lazy-seq\n                     (let [s (map (comp read-string str) (str N))\n                           a (apply + (map #(* % %) s))]\n                       (cons a (_ a))))) n)))))", "problem": 86, "user": "4e71705e535d5021c1a89649"}, {"code": "(fn [n]\n  (letfn [(digits [m]\n            (map #(Integer/parseInt (str %)) (str m)))]\n      (loop [n n s #{}]\n        (let [sum (reduce + (map #(* % %)  (digits n)))]\n            (cond\n              (= sum 1) true\n              (s sum)  false\n              :else (recur sum (conj s sum)))))))", "problem": 86, "user": "4e50e2a0535dc968683fc4ef"}, {"code": "(fn [n]\r\n  (let [digits (fn [n] (map #(Integer/parseInt (str %)) (str n)))\r\n\r\n        happy (fn [n]\r\n  (let [ds (digits n)\r\n        next (apply + (map #(Math/pow % 2) ds))]\r\n    (int next)))\r\n\r\n        h2 (fn h2 [n seen]\r\n             (let [n2 (happy n)]\r\n               (if (= 1 n2)\r\n                 true\r\n                 (if (seen n2)\r\n                   false\r\n                   (recur n2 (conj seen n2))))))]\r\n    (h2 n #{})))", "problem": 86, "user": "4e8681b7535dae1a5effa438"}, {"code": "(fn [n]\n  (= (nth (iterate (fn [n] (reduce + (map #((fn [x] (* x x)) (Character/getNumericValue %))\n                                          (str n))))\n                   n) 20)\n     1))", "problem": 86, "user": "4e8612f8535db62dc21a62f2"}, {"code": "(let [ds (fn [n] (map #(let [m (- (int %) 48)]\n                          (* m m)) (str n)))]\n   (fn [seen n]\n     (cond\n      (seen n) false\n      (= n 1) true\n      :t (recur (conj seen n) (apply + (ds n))))))\n #{}", "problem": 86, "user": "4e8510e7535db62dc21a62e7"}, {"code": "(fn happy? [n]\n  (loop [ n n s #{}]\n    (cond\n      (= n 1) true\n      (s n)   false\n      :else   (recur (reduce + \n                       (map (comp #(* % %) read-string str) (str n)))\n                     (conj s n)))))", "problem": 86, "user": "4e860e85535db62dc21a62f1"}, {"code": "(fn happy? [n]\n   (letfn [(next-happy [x] (reduce + (map #(* % %) (map #(Character/getNumericValue %) (str x)))))]\n     (let [happies (iterate next-happy n)]\n       (if (some #(= 1 %) (take 1000 happies)) true false))))", "problem": 86, "user": "4e89f46c535d3e98b8023288"}, {"code": "(fn f [s n]\r\n  (or (= 1 n)\r\n    (if (s n)\r\n      false\r\n      (f (conj s n)\r\n         (apply + (for [i (iterate #(int (/ % 10)) n)\r\n                        :while (pos? i)\r\n                        d [(mod i 10)]]\r\n                    (* d d)))))))\r\n#{}", "problem": 86, "user": "4db858d1535d1e037afb218c"}, {"code": "< 3", "problem": 86, "user": "4db85bdd535d1e037afb218d"}, {"code": "(fn [x]\r\n    (loop [n x t {}]\r\n    (let [m ((fn [x]\r\n\t(reduce +\r\n\t\t(map #(* % %)\r\n\t\t     (map #(- (int %) (int \\0)) (str x))))) n)]\r\n      (cond (= m 1) true\r\n            (= nil (t m))\r\n              (recur m (merge t {n m}))\r\n            :else\r\n              false))))", "problem": 86, "user": "4e821ca5535db62dc21a62c2"}, {"code": "(fn [n]\n  (loop [n n seen #{}]\n    (let [digits (map #(Character/digit % 10) (str n))\n          sum (apply + (map #(* % %) digits))]\n      (if (= sum 1) true\n        (if (contains? seen sum) false\n          (recur sum (conj seen sum)))))))", "problem": 86, "user": "4e8e8c24535d65386fec2143"}, {"code": "(fn [x]\n    (loop [a #{} b x]\n\t     (if (= b 1)\n\t         true \n\t         (if (a b)\n\t\t     false\n\t\t     (recur (conj a b)\n\t\t\t    (int (reduce + (map #(Math/pow (- (int %) 48) 2) (str b)))))))))", "problem": 86, "user": "4e842ebb535db62dc21a62df"}, {"code": "(fn h [d n]\n  (or (= n 1)\n    (if (d n)\n      false\n      (recur (conj d n) (apply + (map #(* % %) (map read-string (re-seq #\"\\d\" (str n))))))))) #{}", "problem": 86, "user": "4e80e0f2535db62dc21a62b8"}, {"code": "(fn f \n  ([n] (f n #{})) \n  ([n s]\n     (let [r (apply + (map (comp #(* % %) read-string str) (str n)))]\n       (cond\n        (= r 1) true\n        (s r) false\n        1 (f r (conj s r))))))", "problem": 86, "user": "4e823ed7535db62dc21a62c7"}, {"code": "#(not (or (= 2 %) (= 3 %)))", "problem": 86, "user": "4dfe65a1535d04ed9115e787"}, {"code": "#(letfn [\n  (digits [n] (map (fn [d] (Character/digit d 10)) (str n)))\n  (next-happy [n] (reduce + (map (fn [x] (* x x)) (digits n))))]\n  (if (= 4 %) \n    false \n    (if (= 1 %) \n      true \n      (recur (next-happy %)))))", "problem": 86, "user": "4e8f4f64535d65386fec2149"}, {"code": "(fn [n] \n  (not (nil? (some #(= 1 %) \n                   (take 10\n                         (iterate (fn [n] \n                                    (reduce + \n                                            (map #(* % %) \n                                                 (map #(Character/getNumericValue %) \n                                                      (str n))))) n))))))", "problem": 86, "user": "4e6ebd4a535d5021c1a89610"}, {"code": "(fn [n]\n  (loop [n n i 0]\n    (let [s (apply + (map #(int (Math/pow (Integer. (str %)) 2)) (str n)))]\n      (cond\n        (= s 1) true\n        (= i 100) false\n        :else (recur s (inc i))))))", "problem": 86, "user": "4e96557d535dbda64a6f6b43"}, {"code": "(fn [num]\r\n  (condp = num\r\n      1 true\r\n      4 false\r\n      (recur (apply + (map #(let [n (Character/digit % 10)] (* n n))\r\n                           (str num))))))", "problem": 86, "user": "4dd7d040535d2dad7130b5d6"}, {"code": "(fn happy?\r\n  [n]\r\n\t(let [crunch (fn [s] (str (apply + (map #(* % %) (map #(Integer/parseInt (str %)) s)))))\r\n\t\t\t\thappy-helper (fn happy-helper \r\n\t\t\t\t\t\t\t\t\t\t\t [s already-seen-set]\r\n\t\t\t\t\t\t\t\t\t\t\t (if (= s \"1\")\r\n\t\t\t\t\t\t\t\t\t\t\t \t true\r\n\t\t\t\t\t\t\t\t\t\t\t\t (if (contains? already-seen-set s)\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t false\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t (happy-helper (crunch s) (conj already-seen-set s)))))]\r\n\t\t(happy-helper (str n) #{})))", "problem": 86, "user": "4e8a0c82535d3e98b802328d"}, {"code": "(fn [n]\n  (loop [s #{n}\n         n n]\n    (let [sum (reduce + (map #(* % %) (map #(- (int %) 48) (seq (str n)))))]\n      (cond (s sum) false\n            (= sum 1) true\n            :else (recur (conj s sum) sum)))))", "problem": 86, "user": "4ea09fa4535d7eef308072aa"}, {"code": "(fn [n]\n          (let\n              [digit-sq-sum\n               (fn [m]\n                 (apply +\n                        (map #(* % %)\n                             (map #(Integer/parseInt\n                                    (Character/toString %))\n                                  (-> m str seq)))))\n               digi-sq-sum-lazy-sq\n               ((fn la-sq [k s]\n                  (if (s k) [k]\n                      ;; else \n                      (conj (lazy-seq\n                               (la-sq\n                                (digit-sq-sum k)\n                                (conj s k))) k)))\n                n #{1})]\n            (contains? (set digi-sq-sum-lazy-sq) 1)\n            ))", "problem": 86, "user": "4dcc5aff535d5973398f9293"}, {"code": "(fn [x]\n   (letfn [(digits [n] (map #(- (int %) (int \\0)) (str n)))\n           (nextval [n] (reduce + (map #(* % %) (digits n))))\n           (cycle? [vals] (< (count (set vals)) (count vals)))]\n     (loop [seen [], val x]\n       (if (cycle? seen)\n         false\n         (if (= 1 (last seen))\n           true\n          (let [nval (nextval val)] (recur (conj seen nval) nval)))))))", "problem": 86, "user": "4ea1b9e4535d7eef308072b8"}, {"code": "(fn foo  ([x] (foo x #{} )) ([x y ] (let[sum (apply + (map #(* % %) ((fn getdigits [x] (if (> x 0) (conj  (getdigits (quot x 10)  ) (rem x 10)  ) '() )  )x)))] (if (= sum 1) true (if (y sum) false (foo sum (conj y sum)))))))", "problem": 86, "user": "4e8d5edd535d65386fec2134"}, {"code": "(letfn [(digits [n]\n          (map\n           #(read-string (str %))\n           (re-seq #\"\\d\" (str n))))\n        (sum-squares [n]\n          (reduce + (map #(* % %) (digits n))))]\n  (fn [n]\n    (loop [n n acc []]\n      (cond\n        (= 1 n) true\n        (some #(= n %) acc) false\n        :else (recur (sum-squares n) (conj acc n))))))", "problem": 86, "user": "4e9dafe1535dbda64a6f6b89"}, {"code": "(fn happy? \n ([n t prev]\n  (let [ds (map #(Integer/parseInt (str %)) (str t))\n        sum (apply + (map #(* % %) ds))]\n    (cond (= sum 1) true\n          (prev sum) false\n          :else (recur n sum (conj prev sum)))))\n ([n] (happy? n n #{})))", "problem": 86, "user": "4dcfbc44535d5973398f92a7"}, {"code": "(fn happy? [n-init]\n  (letfn [(digits [n-init]\n            (loop [acc '(), n n-init]\n              (if (= n 0)\n                acc\n                (recur (cons (mod n 10) acc) (quot n 10)))))\n          (sum-sqr-of-digits [n]\n            (reduce + (map #(* % %) (digits n))))]\n    (loop [seen-before #{}, n n-init]\n      (cond\n        (seen-before n) false\n        (= 1 n) true\n        :else (recur (conj seen-before n) (sum-sqr-of-digits n))))))", "problem": 86, "user": "4e89ddf9535d3e98b8023284"}, {"code": "(fn [n] (apply distinct? (take-while #(not (= 1 %)) (iterate (fn [x] (apply + (map #(* % %) (map #(- (int %) (int \\0)) (str x))))) n))))", "problem": 86, "user": "4ea41fc2535d7eef308072cb"}, {"code": "(fn [n]\n  (loop [m n seen []]\n    (cond \n      (= m 1) true\n      (not= (count (distinct seen)) (count seen)) false      \n      :else\n        (recur (reduce #(let [d (- (int %2) 48)] (+ %1 (* d d))) 0 (str m))\n              (cons m seen)))))", "problem": 86, "user": "4dbd2aa3535d020aff1edf40"}, {"code": "(fn happy? [n]\r\n  (letfn [(digits [n] (map #(- (int %) (int \\0)) (seq (str n))))\r\n          (sum-sqr [xs] (apply + (map #(* % %) xs)))]\r\n    (loop [nums (iterate (comp sum-sqr digits) n),\r\n           used #{}]\r\n      (let [m (first nums)]\r\n        (if (= m 1) true\r\n            (if (used m) false\r\n                (recur (rest nums) (conj used m))))))))", "problem": 86, "user": "4e994541535dbda64a6f6b64"}, {"code": "(fn [n]\n  (letfn [(ds [n]\n            (if (pos? n)\n              (conj (ds (int (/ n 10))) (mod n 10))))]\n    (loop [n n ns []]\n      (cond \n       (some #{n} ns) false\n       (= 1 n) true\n       :e (recur (->> (ds n) (map #(* % %)) (reduce +)) (conj ns n))))))", "problem": 86, "user": "4dabb7b1950ed6eda1bd72f3"}, {"code": "(fn [n]\n    (loop [n n ns []]\n      (cond \n        (some #{n} ns) false\n        (= 1 n) true\n        :e (recur (->> \n                    (str n)\n                    (map #(- (int %) (int \\0))) \n                    (map #(* % %))\n                    (reduce +)) \n                  (conj ns n)))))", "problem": 86, "user": "4dbad895535d1e037afb21ae"}, {"code": "(fn [no]\n  (letfn [(div [no]\n            (/ (- no (mod no 10)) 10))\n          (square-digit-sum [no acc]\n            (if (> no 0)\n              (square-digit-sum (div no) (+ acc (* (mod no 10) (mod no 10))))\n              acc))\n          (is-happy-number? [no acc]\n            (cond\n              (= no 1) true\n              (nil? (some #{no} acc)) (is-happy-number? (square-digit-sum no 0) (conj acc no))\n              true false))]\n    (is-happy-number? no '())))", "problem": 86, "user": "4eb404ba535d7eef3080735a"}, {"code": "(fn [n] \n  (let [a (apply + (map #(* (- (int %) 48) (- (int %) 48)) (str n)))]\n    (cond (= a 4) false \n          (= a 1) true\n          :else (recur a))))", "problem": 86, "user": "4eaede1f535d7eef30807329"}, {"code": "(fn [x]\n  (loop [n x, old #{}]\n    (cond \n      (= n 1) true\n      (old n) false\n      :else (recur (reduce + (map #(let [l (Long. (str %))] (* l l)) (str n))) (conj old n)))))", "problem": 86, "user": "4db091b7838c48654951d9c2"}, {"code": "(fn [n]\n  (= 1\n    (some #{1 4}\n      (iterate\n        (fn [m]\n          (->> m str\n            (map #(- (int %) 48))\n            (map #(* % %))\n            (reduce +)))\n        n))))", "problem": 86, "user": "4eb97b2e535dfed6da9c6d54"}, {"code": "(fn hn [n]\n    (letfn [ (f [n c]\n               (let [ new-n (reduce + (map (fn [x] (* (- (int x) (int \\0)) (- (int x) (int \\0)))) (seq (str n)))) ]\n                 (cond \n                   (= new-n 1) true\n                   (> c 1000000) false\n                   :else (recur new-n (inc c)))))]\n      (f n 1)))", "problem": 86, "user": "4dd1de4d535dae65d5c462d7"}, {"code": "(fn[n] \r\n     (loop [x n v #{}]\r\n       (let [y (apply + (map (comp #(* % %) #(- (int %) 48)) (str x)))]\r\n         (cond \r\n           (= 1 y) true\r\n           (v y) false\r\n           1 (recur y (conj v y))))))", "problem": 86, "user": "4e707db6535d5021c1a8963a"}, {"code": "(fn happy[n]\r\n    (loop [s #{} d n]\r\n      (if (or (= 10 d) (= 1 d))\r\n        true\r\n        (if (contains? s d)\r\n          false\r\n          (recur (conj s d) (int (reduce + (map (fn[x] (Math/pow (read-string (str x)) 2)) (into [] (str d))))))))))", "problem": 86, "user": "4e9def6b535dbda64a6f6b8f"}, {"code": "(fn [a] \n  (= 1 \n    (last \n      (take 100 \n        (iterate \n          (fn [x] \n            (apply + \n              (map #(int (Math/pow %1 2))\n                (map #(- (int %1) (int \\0)) (str x))\n              ))) a)))))", "problem": 86, "user": "4ea1ecfa535d7eef308072bb"}, {"code": "(letfn [(s [x] (* x x))]\n      (fn [n]\n        (loop [i (iterate (fn [x] (reduce #(+ % (s (- (int %2) 48))) 0 (str x))) n) e #{}]\n          (let [z (first i)]\n            (if (e z)\n              false\n              (if (= 1 z)\n                true\n                (recur (rest i), (conj e z))))))))", "problem": 86, "user": "4e82f85d535db62dc21a62ce"}, {"code": "(fn [x] (let [hnt (fn [y] \n  (int (reduce + (map #(Math/pow (- (int %) 48) 2) \n    (str y)))))] \n  (loop [y x results #{}]\n    (if (= 1 y) true\n      (let [hn (hnt y)]\n        (if (nil? (get results hn))\n          (recur hn (conj results hn))\n          false))))))", "problem": 86, "user": "4ea9b80c535d7eef30807306"}, {"code": "(fn [x]\n  (loop [num x time 0]\n    (if (= time 2000)\n      false\n      (let [res\n      (reduce + (map #(* (read-string %) (read-string %)) (re-seq #\"\\d\" (str num))))]\n\t(if (= res 1)\n\t  true\n\t  (recur res (+ time 1)))))))", "problem": 86, "user": "4eb0afed535d7eef3080733e"}, {"code": "(fn [n]\n  (letfn [(ds [n] (map #(Integer/parseInt %) (map str (str n))))\n          (ss [ds] (apply + (map #(* % %) ds)))\n          (f [n t]\n            (if (> t 100)\n              false\n              (let [r (ss (ds n))]\n                (if (= 1 r)\n                  true\n                  (f r (inc t))))))]\n    (f n 0)))", "problem": 86, "user": "4dbdc9da535d020aff1edf4c"}, {"code": "(fn [number]\n  (cond\n    (= number 1) true\n    (or (= number 2) (= number 3)) false\n    true\n      (recur\n        (reduce +\n          (map\n            #(Math/round (Math/pow (Integer/parseInt (str %)) 2))\n            (str number))))))", "problem": 86, "user": "4ec2fe3f535dcc7ae8597d4f"}, {"code": "(let [dsqsum (fn [nn] (let [ digits (loop [n nn d '()] (if (= n 0) d (recur (quot n 10) (cons (mod n 10) d))))] (reduce + (map #(* % %) digits))))]\n  (fn happy [l n]\n    (let [dss (dsqsum n)]\n      (if (= 1 dss)\n        true\n        (if (some #(= dss %) l)\n          false\n          (recur (cons dss l) dss)))))) '()", "problem": 86, "user": "4e8b98fc535d65386fec2124"}, {"code": "(fn[x]\n    (loop [n x]\n      (cond\n       (= n 1) true\n       (= n 2 ) false\n       (= n 3)  false\n       (= n 4 ) false\n       (= 5 n)  false\n       (= 6 n)  false\n       (= 7 n ) true\n       (=  8 n ) false\n       ( = 9 n ) false\n       :else (recur ((fn [m]\n       (loop [sum 0 r (quot m 10) module (mod m 10) ]\n         (if (= r 0)\n          (+ sum (* module module))\n          (recur (+ sum (* module module) )  (quot r 10 ) (mod r 10) )\n           )\n         )\n         ) n))\n        )\n      )\n)", "problem": 86, "user": "4ec5bec6535d6d7199dd36b3"}, {"code": "(fn happy [i]\n  (loop [seen #{} i i]\n    (let [digits  (map #(Integer/parseInt (str %)) (str i))\n          squared (apply + (map #(* % %) digits))]\n      (cond\n       (= 1 squared) true\n       (seen squared) false\n       :else (recur (conj seen squared) squared)))))", "problem": 86, "user": "4daf8f84edd6309eace4d17a"}, {"code": "(fn myhappy[n]\n   (let [sq #(* % %)]\n    (loop [n n seen #{}]\n        (let [sumsq (reduce #(+ % (sq (- (int %2) 48))) \n                     0 (vec (str n)))\n              d (println sumsq)]\n        (if (= sumsq 1) true\n          (if (seen sumsq) false\n            (recur sumsq (conj seen n))))))))", "problem": 86, "user": "4eb0a757535d7eef3080733d"}, {"code": "(fn happy-number?\n  ([x] (happy-number? x #{}))\n  ([x xs]\n    (let [x (->> x str\n              (map (comp #(* % %) read-string str))\n              (reduce +))]\n      (cond\n        (= x 1) true\n        (xs x)  false\n        :else (recur x (conj xs x))))))", "problem": 86, "user": "4eb51942535d7eef30807365"}, {"code": "(fn [n]\n  (letfn \n     [ (happy? [st n]\n       (let [s (apply + (map #(let[i (Integer. (str %))]\n                              (* i i)) (str n)))]\n          (cond (st s) false\n                (= s 1) true\n                :else (fn [] (happy? (conj st n) s)))))]\n      (trampoline (fn [] (happy? #{} n)))))", "problem": 86, "user": "4e6dc95a535d5021c1a895f1"}, {"code": "(letfn\n    [(digits [n] (map (fn [c] (Integer. (str c))) (str n)))\n     (sq [n] (* n n))]\n  (fn [n]\n    (loop [n n seen #{}]\n      (if (and (> n 1) (not (contains? seen n))) ; check for cycle\n        (recur (reduce + (map sq (digits n))) (conj seen n))\n        (= n 1)))))", "problem": 86, "user": "4ed188c8535d44c135fd68cf"}, {"code": "(fn happy? [n]\n  (letfn [(sqrsum [n]\n    (reduce \n      #(let [d (- (int %2) 48)]\n        (+ % (* d d)))\n      0\n      (seq (str n))))]\n    (loop [n n acc #{}]\n      (if (= n 1) \n        true\n        (if (nil? (acc n))\n          (recur (sqrsum n) (conj acc n))\n          false)))))", "problem": 86, "user": "4e9c81e8535dbda64a6f6b80"}, {"code": "(fn [v]\n    (let\n        [ n\n          (fn [v]\n            (apply +\n                (map #(* (mod % 10) (mod % 10))\n                  (take-while #(> % 0)\n                    (iterate #(quot % 10) v)))))\n            h\n             (fn h\n               ([v] (h v #{}))\n               ([v a]\n                  (if\n                   (a v) false\n                   (or \n                     (= 1 v)\n                     #(h (n v) (conj a v))))))]\n      (trampoline h v)))", "problem": 86, "user": "4e6f578c535d5021c1a8961b"}, {"code": "(fn [x]\n  ((fn r [y s]\n    (cond\n      (= y 1) true\n      (s y) false\n      :else (r\n        (reduce + (map #(* % %) (map #(Character/getNumericValue %) (str y))))\n        (conj s y))))\n    x #{}))", "problem": 86, "user": "4ec07699535dfed6da9c6da2"}, {"code": "(fn [n]\n   (let [max-try 20]\n     (loop [try 0\n            i n]\n       (if (or (= 1 i) (> try max-try))\n         (= 1 i)\n         (recur (inc try)\n                (->> i\n                     str\n                     (map #(Integer. (str %)))\n                     (map #(* % %))\n                     (reduce +)))))))", "problem": 86, "user": "4e59b02c535d8a8b8723a2a2"}, {"code": "(fn f [i] \n   (loop [i i, u #{}] \n     (if (= i 1) true \n       (if (contains? u i) false \n         (recur (reduce + (map #(* % %) (map #(Integer/valueOf (str %)) (str i)))) (conj u i))))))", "problem": 86, "user": "4eabb245535d7eef30807319"}, {"code": "(fn happy? [x]\n  (letfn [(abs [x] (if (< x 0) (- x) x))\n          (digits [x] (map #(Integer/parseInt (str %)) (reverse (str (abs x)))))\n          (square [x] (* x x))\n          (sum [coll] (apply + coll))]\n    (loop [y x, seen #{}]\n      (let [r (sum (map square (digits y)))]\n        (cond\n          (= r 0)  false\n          (= r 1)  true\n          (seen r) false\n          :else    (recur r (conj seen r)))))))", "problem": 86, "user": "4e7263a1535d5021c1a8965f"}, {"code": "(fn f[x & [l]]\r\n  (if (= x 1) true\r\n    (if (some #{x} l) false\r\n      (f (int (reduce #(+ % (Math/pow (- (int %2) 48) 2)) 0 (str x)))\r\n         (conj l x)))))", "problem": 86, "user": "4ec0c7ba535dfed6da9c6da4"}, {"code": "(fn [n]\n     (contains?\n       (->> n\n         (iterate #(reduce + (map (zipmap \"0123456789\" [0 1 4 9 16 25 36 49 64 81]) (str %))))\n         (reductions conj #{})\n         (take 100) ; partition-by 1.2 bug\n         (partition-by count)\n         (some second)) 1))", "problem": 86, "user": "4e8f1ac6535d65386fec2146"}, {"code": "(fn [n]\n  (let [s (iterate (fn [x] (apply + (map (comp #(* % %) read-string) (re-seq #\"\\d\" (str x))))) n)]\n    (loop [s1 (take 2 s)]\n      (cond\n        (= 1 (last s1)) true\n        (some (hash-set (last s1)) (drop-last s1)) false\n        :else (recur (take (inc (count s1)) s))))))", "problem": 86, "user": "4e9519b4535dbda64a6f6b2d"}, {"code": "(fn [num]\n  (letfn\n    [(hnext [n] (reduce #(+ % (* %2 %2)) 0 (map #(- (int %) 48) (str n))))]\n    (loop [n num seen #{}]\n      (cond\n        (= n 1) true\n        (seen n) false\n        :else (recur (hnext n) (conj seen n))))))", "problem": 86, "user": "4e1350af535d04ed9115e7d8"}, {"code": "(letfn [(sss [n] (reduce + (map #(* % %) (map read-string (re-seq #\"\\d\" (str n))))))]\n  (fn happy\n    ([n] (happy n #{n}))\n    ([n acc] (let [s (sss n)]\n      (cond (= s 1) true\n            (contains? acc s) false\n           :else (recur s (conj acc s)))))))", "problem": 86, "user": "4ed94d69535d10e5ff6f5303"}, {"code": "(fn is-happy [n]\n  ((fn [beenthere newone]\n     (if (= newone 1)\n       true\n       (if (contains? beenthere newone)\n         false\n         (recur (conj beenthere newone)\n                 (->> newone\n                   str\n                   seq\n                   (map str)\n                   (map read-string)\n                   (map #(* % %))\n                   (reduce +))))))\n     #{} n))", "problem": 86, "user": "4ec75077535d6d7199dd36e0"}, {"code": "#(loop [s #{} i %]\n  (let [i (loop [x i o 0]\n            (let [y (rem x 10)]\n              (if (= x 0) o\n                (recur (quot x 10) (+ o (* y y))))))]\n    (cond\n      (s i) false\n      (= i 1) true\n      :else (recur (conj s i) i))))", "problem": 86, "user": "4e8a460e535d65386fec2109"}, {"code": "(let [next-number (fn [n]\n                    (reduce + (map #(let [v (Integer/valueOf (str %))] (* v v)) (str n))))]\n  (fn [n]\n    (loop [n n, found #{}]\n      (cond\n        (= n 1) true\n        (found n) false\n        :else (recur (next-number n) (conj found n))))))", "problem": 86, "user": "4edab806535d10e5ff6f5311"}, {"code": "(fn [z] (letfn [(d [n l] (if (= 1 n) \n                  true \n                  (if (nil? (l n)) \n                    (d (reduce + (map #(* % %)(map #(- (int %) 48) (str n)))) (conj l n))\n                    false)))] (d z #{})))", "problem": 86, "user": "4ede8789535d10e5ff6f5337"}, {"code": "(fn h ([n] (h n #{}))\n  ([n s] \n    (let [x (apply + (map (comp #(* % %) #(Integer/parseInt (str %))) (str n)))]\n      (cond \n        (= 1 x) true\n        (s x) false\n        :else (recur x (conj s x))))))", "problem": 86, "user": "4eb2eae5535d7eef30807351"}, {"code": "(fn happy?[n]\r\n  (let[sum #(reduce + %)\r\n       square (fn[xs](map #(* % %) xs))\r\n       digits (fn[i](map(comp read-string str)(str i)))\r\n       happy (fn[i](= 1 (sum(digits i))))]\r\n    ((fn[i cnt]\r\n       (let[stepped (sum(square(digits i)))]\r\n   (println (str stepped))\r\n\t (if(happy stepped)\r\n\t   true\r\n\t   (if(< cnt 100)\r\n\t     (recur stepped (inc cnt))\r\n\t     false))))\r\n     n 0)))", "problem": 86, "user": "4edeac6b535d10e5ff6f533a"}, {"code": "(fn happy? [n]\n  (loop [n n, history #{n}]\n    (let [square #(* % %)\n          digits (fn [n] (map #(Integer/parseInt (str %)) (Integer/toString n)))\n          n2 (reduce + (map square (digits n)))]\n      (cond\n        (= 1 n2) true\n        (contains? history n2) false\n        :else (recur n2 (conj history n2))))))", "problem": 86, "user": "4eb9ce75535dfed6da9c6d5e"}, {"code": "(fn [n]\n  (letfn [(sos [n]\n            (reduce + (map #(* % %) (map #(- (int %) (int \\0)) (str n)))))]\n      (= (some (fn [[s n]] (s n))\n          (iterate (fn [[s n]] [(conj s n) (sos n)]) [#{} (sos n)]))\n        1)))", "problem": 86, "user": "4ede8e1d535d10e5ff6f5339"}, {"code": "#(loop [n % seen #{}]\n   (cond (= n 1) true\n         (seen n) false\n         :else (let [ns ((fn f [i]\n                           (if (zero? i)\n                               ()\n                               (cons (rem i 10)\n                                     (f (quot i 10))))) n)\n                     m (reduce + (map (fn [x] (* x x)) ns))]\n                 (recur m (conj seen n)))))", "problem": 86, "user": "4ee3b586535d10e5ff6f5371"}, {"code": "(fn [y] (= 1 (last (take 10 (iterate #(apply + (for [n (for [m (vec (str %))] (- (int m) 48))] (* n n))) y)))))", "problem": 86, "user": "4eb13d60535d7eef3080733f"}, {"code": "(fn [x]\n  (loop [x x seen '()]\n    (cond (= 1 x) true\n          (some #(= % x) seen) false\n          true\n            (recur \n              (reduce +\n                (map #(int (Math/pow\n                  (Integer/parseInt (str %)) 2))\n                  (str x)))\n              (conj seen x)))))", "problem": 86, "user": "4ebc08a8535dfed6da9c6d7c"}, {"code": "(fn  [n]\n  (loop [seen #{}\n         n n]\n    (let [squared-digits (map\n                          #(let [x (- 48 (int %))] (* x x))\n                         (str n)) \n          sum (reduce + squared-digits)]\n      (if (seen sum)\n        false\n        (if (= sum 1)\n          true\n          (recur (conj seen sum) sum))))))", "problem": 86, "user": "4ec28d86535dfed6da9c6dbc"}, {"code": "(fn happy? [num]\n  (if (= 1 num)\n    true\n    (if (= 4 num)\n      false\n      (happy? (reduce\n                (fn [sum c] (+ sum (* (- (int c) 48)\n                                      (- (int c) 48))))\n                0 (str num))))))", "problem": 86, "user": "4ee82223535d93acb0a66877"}, {"code": "(fn [n]\n  (letfn [(digits [n]\n            (let [rightmost-digit (mod n 10)]\n              (if (= rightmost-digit n)\n                (vector n)\n                (conj (digits (quot n 10)) rightmost-digit))))]\n    (loop [n n, previous-numbers #{n}]\n      (let [sum-of-squares (reduce + (map #(* % %) (digits n)))]\n        (cond (= sum-of-squares 1) true\n              (contains? previous-numbers sum-of-squares) false\n              :else (recur sum-of-squares (conj previous-numbers sum-of-squares)))))))", "problem": 86, "user": "4ec70f26535d6d7199dd36dd"}, {"code": "(fn [n] (let [s (iterate\n                    (fn [n]\n                      (reduce +\n                              (map #(* % %) (\n                                             (fn [n]\n                                               (loop [v n r []]\n                                                 (if (= 0 v)\n                                                   r\n                                                   (recur (quot v 10)\n                                                          (conj r (mod v 10))))))\n                                             n)))\n                      ) n)]\n             (loop [i 0 prev #{}]\n               (cond\n                (= 1 (nth s i)) true\n                (contains? prev (nth s i)) false\n                :else (recur (inc i) (conj prev (nth s i)))))))", "problem": 86, "user": "4ebef65e535dfed6da9c6d9b"}, {"code": "(fn f [s n]\n  (if (s n)\n    (= n 1)\n    (f (conj s n) (apply + (map #(* % %) (map #(- (int %) 48) (str n)))))))\n#{}", "problem": 86, "user": "4ee82539535d93acb0a66878"}, {"code": "(fn happy[s]\n  (loop [val s\n   old-inv #{}]\n    (let [new-val (reduce + (map #(let [x (- (int %) 48)] (* x x)) (vec (str val))))]\n      (cond \n        (= 1 new-val) true\n\t(old-inv new-val) false\n\t:else (recur new-val (conj old-inv new-val))\n      )\n    )\n  )\n)", "problem": 86, "user": "4e9de526535dbda64a6f6b8e"}, {"code": "(fn h [n]\n  (condp > n\n    2 true\n    5 false\n    (h ((fn f [n a]\n          (if (= 0 n)\n            a\n            (f (quot n 10) (+ a (* (rem n 10) (rem n 10))))))\n         n 0))))", "problem": 86, "user": "4ed69ea4535d10e5ff6f52e3"}, {"code": "#(loop [i % o #{}]\n    (let [[& s] (str i) c (apply + (map (fn [x] (* (- (int x) 48) (- (int x) 48))) s))]\n      (if (= c 1)\n        true\n        (if (o c)\n         false\n         (recur c (conj o c))))))", "problem": 86, "user": "4e65027c535d8ccf87e9fe6e"}, {"code": "(fn happy\r\n   ([n] (happy n #{}))\r\n   ([n seen]     \r\n     (let [new-n (reduce + (map #(* % %) (map #(- (int %) 48) (str n))))]       \r\n       (cond (= 1 new-n) true\r\n             (contains? seen new-n) false             \r\n             :else (recur new-n (conj seen new-n))))))", "problem": 86, "user": "4e513758535dc968683fc4f3"}, {"code": "(fn happy-number\n  [n]\n  (let [f1 (fn f1 [n]\n                  (if (zero? n)\n                    0\n                    (+ (* (mod n 10) (mod n 10)) (f1 (quot n 10)))))]\n    (if (< n 4)\n      (if (= n 1)\n        true\n        false)\n      (recur (f1 n)))))", "problem": 86, "user": "4e3bcccd535deb9a81d77f56"}, {"code": "(fn [n]\n    (let [digit-sum (fn [n] (loop [r n\n                                   ds 0]\n                              (if (zero? r)\n                                ds\n                                (let [m (mod r 10)]\n                                  (recur (/ (- r m) 10)\n                                         (+ ds (* m m)))))))]\n      (loop [sum (digit-sum n)\n             seen #{n}]\n        (if (= sum 1)\n          true\n          (if (seen sum)\n            false\n            (recur (digit-sum sum)\n                   (conj seen sum)))))))", "problem": 86, "user": "4e6a0667535d8ccf87e9fe9e"}, {"code": "(fn [m] (= 1 \n           (->> m \n             (iterate (fn [n] (let [d (map (zipmap \"0123456789\" (range)) (str n)) ] \n                                (apply + (map #(* % %) d) ))) )  \n             (take 20) \n             (last) ) ))", "problem": 86, "user": "4ee7d177535d93acb0a6686f"}, {"code": "(fn [n]\n  ((fn [acc]\n    (let [n (first acc)\n          digits (map read-string (next (clojure.string/split (str n) #\"\")))\n          newn (reduce + (map (fn [x] (* x x)) digits))]\n      (if (= 1 newn) true\n        (if (some (partial = newn) acc) false (recur (cons newn acc))))))\n  (list n)))", "problem": 86, "user": "4eb2e6ca535d7eef3080734f"}, {"code": "(fn [m]\n  (= 1 \n     (some #{1 4}\n           (iterate (fn [k] (reduce #(+ % (let [c (- (int %2) 48)] (* c c))) \n                                    0\n                                    (str k))) \n                    m))))", "problem": 86, "user": "4ef49c2c535dced4c769f238"}, {"code": "#(loop [my-set #{} my-num %]\n  (let [new-num (reduce + (map (fn [x] (let [y (- (int x) (int \\0))] (* y y))) (seq (str my-num))))]\n\t\t(if (contains? my-set my-num) \n\t\t\tfalse \n\t\t\t(if (= new-num 1) \n\t\t\t\ttrue\n\t\t\t\t(recur (conj my-set my-num) new-num)))))", "problem": 86, "user": "4e8d5911535d65386fec2133"}, {"code": "(fn [x]\n  (let [digits (fn [num] (map #(Integer/parseInt (str %)) (str num)))\n        squares (fn [num] (map #(* % %) (digits num)))\n        iter-f (fn [num] (apply + (squares num)))\n        vals (iterate iter-f x)]\n    (loop [seen #{} [x & more] vals]\n      (if (= 1 x)\n        true\n        (if (contains? seen x)\n          false\n          (recur (conj seen x) more))))))", "problem": 86, "user": "4edecdae535d10e5ff6f533c"}, {"code": "(fn [i]\n  (loop [n i s #{}]\n    (cond (= 1 n) true\n          (contains? s n) false\n          :else (recur (reduce + (map #(* % %) (map #(- (int %) 48) (str n))))\n                       (conj s n)))))", "problem": 86, "user": "4e773be8535d324fb2983d6e"}, {"code": "(fn [coll n]\n                (let [next-n \n                      (reduce + (map #(* % %) (map #(Integer/parseInt (str%)) (str n))))]\n                  (cond\n                    (= 1 next-n) true\n                    (contains? coll next-n) false\n                    :else (recur (conj coll next-n)  next-n)))) #{}", "problem": 86, "user": "4edf5dc6535d10e5ff6f5340"}, {"code": "(fn happy? [n]\n        (loop [n n, doom ()]\n           (or (= 1 n)\n               (and (not (some #{n} doom))\n                    (recur (apply + (map (comp #(* % %) read-string str)\n                                         (str n)))\n                           (conj doom n))))))", "problem": 86, "user": "4e599577535d8a8b8723a29f"}, {"code": "(fn [n]\n  (letfn [(digits [n] (map #(mod % 10) (take-while pos? (iterate #(quot % 10) n))))]\n    (loop [n n, seen #{}]\n      (if (= n 1) true\n        (if (seen n) false\n          (recur (apply + (map #(* % %) (digits n))) (conj seen n)))))))", "problem": 86, "user": "4ec5aa1f535d6d7199dd36b0"}, {"code": "< 4", "problem": 86, "user": "4e951ce5535dbda64a6f6b2e"}, {"code": "(fn haz [x]\n  (let [valor (fn dig [x]\n  (loop [num x res 0]\n    (if (= num 0) res\n     (recur (Math/floor (/ num 10))\n       (+ (Math/pow (mod num 10) 2) res)))))]\n(= (last (take 100 (iterate valor x))) 1)))", "problem": 86, "user": "4f04a06d535dcb61093f6bd9"}, {"code": "(fn happy? [n]\n        (letfn [(k [m] (reduce #(+ (* %2 %2) %) 0 (map #(- (int %) 48) (str m))))]\n          (loop [p n s [n]]\n            (let [l (k p)]\n              (cond\n               (= 1 l) true\n               (some #{l} s) false\n               :else (recur l (cons l s)))))))", "problem": 86, "user": "4f031eac535dcb61093f6a67"}, {"code": "trampoline (fn sqds [n]\n\t({1 true 4 false} n #(sqds (apply + (map (zipmap \"0123456789\" [0 1 4 9 16 25 36 49 64 81]) (str n))))))", "problem": 86, "user": "4effb663535dcb61093f6a2e"}, {"code": "#(letfn [(d [n] \n  (lazy-seq \n    (when (> n 0) \n      (cons (rem n 10) (d (quot n 10))))))\n  (s [n] (* n n))]\n  (loop [n % v #{}]\n    (let [x (reduce + (map s (d n)))]\n      (cond (= x 1) true\n            (v x) false\n            :default (recur x (conj v x))))))", "problem": 86, "user": "4f043ed1535dcb61093f6bb4"}, {"code": "(fn [n]\n  (loop [n n, seen #{}]\n    (cond (= n 1)  true\n          (seen n) false\n          :else\n          (recur (reduce + \n            (map (comp #(* % %) #(- (int %) 48)) (str n)))\n                 (conj seen n)))))", "problem": 86, "user": "4ec5d62c535d6d7199dd36ba"}, {"code": "(fn f [s n]\n  (let [p (#(apply + (map (fn [d]\n         (let [z (- (int d) 48)] (* z z))) \n       (str %))) n)]\n    (if (= 1 p)\n      true\n      (if (nil? (s p))\n        (f (conj s p) p)\n        false\n      )\n)\n)) #{}", "problem": 86, "user": "4f01c938535dcb61093f6a39"}, {"code": "#(> % 3)", "problem": 86, "user": "4db8f6c4535d1e037afb219e"}, {"code": "(let [squared-sum (fn [x] (int (reduce + (map #(Math/pow (- (int %) 48) 2) (seq (str x))))))]\r\n  (fn [x] (contains? (set (take 25 (iterate squared-sum x))) 1)))", "problem": 86, "user": "4f03822f535dcb61093f6b03"}, {"code": "(fn [n]\n    (letfn [(happy-seq [n]\n              (let [n* (reduce +(map #(int (Math/pow (Integer/parseInt (str %)) 2)) (str n)))]\n                (lazy-seq (cons n*\n                                (when-not (zero? n*)\n                                  (happy-seq n*))))))]\n      (= 1 (last (take 10 (happy-seq n))))))", "problem": 86, "user": "4ed292ac535d44c135fd68d9"}, {"code": "(fn [n]\n  (loop [n n p #{}]\n    (let [s (reduce #(+ % (* %2 %2)) 0 (map #(- (int %) 48) (str n)))]\n      (cond\n        (= 1 s) true\n        (p s)   false\n        :else   (recur s (conj p n))))))", "problem": 86, "user": "4f04b66b535dcb61093f6bdd"}, {"code": "(fn prob-0086\n  [in-n]\n  (let [digits-of (fn digits-of\n                    [n]\n                    (map #(Long/parseLong (str %)) (seq (str n))))\n\n        sum-of-squares (fn sum-of-squares\n                         [xs]\n                         (apply + (map #(* % %) xs)))]\n    \n        (loop [n in-n, seen #{}]\n          (let [sqd-sum (sum-of-squares (digits-of n))]\n            (cond\n             (= sqd-sum 1)            true\n             (contains? seen sqd-sum) false\n             :else                    (recur sqd-sum (conj seen sqd-sum)))))))", "problem": 86, "user": "4f047c07535dcb61093f6bcd"}, {"code": "(fn hn\n  [n] \n  (loop [n n k #{}]\n     (cond (= n 1) true\n           (k n) false\n           :else (recur (->> (str n)\n                             (map #(Character/digit % 10))\n                             (map #(* % %))\n                             (apply +))\n                        (conj k n)))))", "problem": 86, "user": "4eb5750a535d7eef30807366"}, {"code": "(fn [n]\n  (letfn [(sum-sq-digits [n]\n    (reduce + \n      (for \n        [c (str n) :let [d (- (int c) (int \\0))]]\n        (* d d))))]\n    (loop [i n found #{}]\n      (cond\n        (= i 1) true\n        (found i) false\n        :else \n          (recur \n            (sum-sq-digits i) \n            (conj found i))))))", "problem": 86, "user": "4f050dec535dcb61093f6bef"}, {"code": "(fn happy-num? [n]\n  (let [memory (atom #{})\n        extract-digits #(re-seq #\"\\d\" (str %))]\n    (loop [num n]\n      (let [x (->> num extract-digits\n                   (map #(Integer/valueOf %))\n                   (map #(* % %))\n                   (reduce +))]\n        (println x)\n        (cond\n         (= 1 x) true\n         (@memory x) false  ;; already seen - it is not happy\n         (swap! memory conj x) (recur x))))))", "problem": 86, "user": "4efec33f535dcb61093f6a2a"}, {"code": "(fn f [s n]\n     (or\n      (= n 1)\n      (if (s n)\n        false\n        (f (conj s n) (apply + (map (zipmap \"0123456789\" [0 1 4 9 16 25 36 49 64 81]) (str n)))))))\n#{}", "problem": 86, "user": "4ee9ddb8535d93acb0a66896"}, {"code": "(fn happy-numbers [n]\r\n    (letfn [(int-to-list [n]\r\n              (loop [i n s '()]\r\n                (if (< i 10)\r\n                  (conj s i)\r\n                  (recur (quot i 10) (conj s (rem i 10))))))\r\n            (sum-of-squares [l2]\r\n              (reduce + (map (fn [a] (* a a)) l2)))]\r\n      (loop [s #{} n n]\r\n        (if (contains? s n)\r\n          false\r\n          (if (= n 1)\r\n            true\r\n            (recur (conj s n ) (sum-of-squares (int-to-list n))))))))", "problem": 86, "user": "4f039524535dcb61093f6b2c"}, {"code": "(fn [n]\n  (let [digsqr (fn [nn] (reduce + (map #(let [a (- (int %) (int \\0))] (* a a)) (str nn))))]\n    (loop [nn n seen #{}]\n      (cond\n        (seen nn) false\n        (= nn 1) true\n        :else (recur (digsqr nn) (conj seen nn))))))", "problem": 86, "user": "4f03ac2d535dcb61093f6b4a"}, {"code": "(fn [num]\n  (loop [mem #{}, n num]\n    (cond (= 1 n) true\n          (mem n) false\n          :else (recur (conj mem n)\n                       (->> (str n)\n                            (map (comp #(* % %) #(Character/digit % 10)))\n                            (apply +))))))\n\n;; use iterate \n;;\n;; (fn [num]\n;;   (letfn [(iter [[_ mem n]]\n;;             [(cond (= 1 n) true, (mem n) false)\n;;              (conj mem n)\n;;              (->> (str n)\n;;                   (map (comp #(* % %) #(Character/digit % 10)))\n;;                   (apply +))])]\n;;     (->> [nil #{} num]\n;;          (iterate iter)\n;;          (drop-while (comp nil? first))\n;;          ffirst)))", "problem": 86, "user": "4daec9dcedd6309eace4d15f"}, {"code": "(fn h [n]\n    (let [m map\n          r (->> n str (m #(- (int %) 48)) (m #(* % %)) (apply +))]\n      (and (not= r 4) (or (= 1 r) (h r)))))", "problem": 86, "user": "4f0ef874535d0136e6c22328"}, {"code": "#(or (= % 1)\n  (if (= % 4) false\n             (recur (reduce + (map (fn [x]\n                                     (let [i (Character/getNumericValue x)]\n                                       (* i i))) (str %))))))", "problem": 86, "user": "4f036d9b535dcb61093f6ac1"}, {"code": "(fn [prev-nums n]\n           (let [next-n (apply + (map #(int (Math/pow (Integer/parseInt (str %)) 2)) (vec (str n))))]\n             (if (some #(= next-n %) prev-nums)\n              false\n               (if (= 1 next-n)\n                 true\n                 (recur (conj prev-nums n) next-n))))) #{}", "problem": 86, "user": "4ea7999e535d7eef308072ee"}, {"code": "(fn [n] \n  (loop [n n h #{}]\n    (let [x \n          (->> (str n)\n            (map #(Integer/parseInt (str %)))\n            (map #(* % %)) (reduce +))]\n      (if (h x)\n        false\n        (or (= x 1) (recur x (conj h n)))))))", "problem": 86, "user": "4f06dcad535dcb61093f6c16"}, {"code": "(fn [number]\n  (loop [n number]\n    (cond\n     (= n 89) false\n     (= n 1) true\n     :default (recur\n         (reduce + (map #(* % %)\n\t\t\t      (for [c (str n) ](- (int c) 48))))))))", "problem": 86, "user": "4e57d1e2535d8a8b8723a289"}, {"code": "(fn [x]\n    (loop [res #{} n x]\n        (if (= n 1) \n            true\n            (\n                let [\n                    sqr (fn [i] (* i i))\n                    sqrsum (reduce #(+ %1 (sqr (- (int %2) 48))) 0 (str n))\n                    ]\n                (if (res sqrsum)\n                    false\n                (recur (conj res sqrsum) sqrsum))\n            )\n        )\n    )\n)", "problem": 86, "user": "4f0e995e535d0136e6c22326"}, {"code": "(fn happy-number [num]\n  (letfn [(digits  [x]\n            (loop [result '() n x]\n              (if (zero? (quot n 10))\n                (conj result n)\n                (recur (conj result (rem n 10)) (quot n 10)))))\n          (sos [x]\n            (let [num-list (digits x)]\n              (reduce + (map #(* % %) num-list))))]\n    (loop [c [] n num]\n      (cond\n       (= 1 n) true\n       (not (nil? (some #{n} c))) false\n       :else (recur (conj c n) (sos n))))))", "problem": 86, "user": "4e95a440535dbda64a6f6b37"}, {"code": "(fn f [n & c]\n  (let [v (reduce #(+ % (let [x (- (int %2) 48)] (* x x))) 0 (str n))]\n    (cond \n      (= 1 v) true\n      (some #(= v %) c) false\n      :else (recur v\n                   (cons v (seq c))))))", "problem": 86, "user": "4efb2fd7535dced4c769f274"}, {"code": "(fn [n]\n  (let [\n    numseq (fn [s] (map #(Character/digit % 10) (seq (str s))))\n    square (fn [x] (* x x))\n    ] \n    (loop [current n]\n      (cond\n        (= current 1) true\n        (= current 4) false\n        :else (recur (reduce + (map square (numseq current))))\n      )\n      )))", "problem": 86, "user": "4e6b6294535d8ccf87e9ff11"}, {"code": "#(or (= %1 986543210) (= %1 7))", "problem": 86, "user": "4f038355535dcb61093f6b04"}, {"code": "(fn happy? [number]\n    (loop [n number]\n        (if (= 1 n)\n            true\n            (if (= 4 n)\n                false\n                (recur\n                    (apply +\n                        (map #(* % %)\n                            (map #(- (int %) 48) (str n)))))))))", "problem": 86, "user": "4f128865535d64f603146428"}, {"code": "(fn [n]\n  (let [digits (fn [n] (map #(- (int %) (int \\0)) (str n)))\n        sum #(reduce + 0 %)\n        happy (fn [curr nums] (cond \n          (nums curr) false\n          (= curr 1) true\n          :else (recur (sum (map #(* % %) (digits curr))) (conj nums curr))))]\n        (happy n #{})))", "problem": 86, "user": "4f13047d535d64f60314642c"}, {"code": "(fn [x]\n     (let [digits (fn [n] (map #(Character/digit % 10) (seq (str n))))\n\t       square (fn [n] (* n n))]\n\t       (loop [x x history #{}]\n\t\t  (cond\n\t\t    (= 1 x) true\n\t\t    (history x) false\n\t\t    :else\n\t\t    (recur (reduce + (map #(square %) (digits x))) (conj history x))))))", "problem": 86, "user": "4f066916535dcb61093f6c10"}, {"code": "(fn [n]\n    (let [char-to-digit (fn [n] (- (int n) (int \\0)))\n          sum-of-squares-of-digits (fn [n] (apply + (map #(* (char-to-digit %) (char-to-digit %)) (str n))))]\n      (loop [n n\n             seen #{}]\n        (cond (= n 1) true\n              (some seen #{n}) false\n              :else (recur (sum-of-squares-of-digits n) (conj seen n))))))", "problem": 86, "user": "4e89e939535d3e98b8023287"}, {"code": "(fn [n]\n  (letfn [(sq [x]\n            (let [z (- (int x) (int \\0))] (* z z)))\n          (sum-of-sq [x]\n            (reduce + (map sq (seq (str x)))))]\n    (loop [curr n kept #{}]\n      (cond\n        (= 1 curr)\n          true\n        (not (nil? (get kept curr)))\n          false\n        :else\n          (recur (sum-of-sq curr)(conj kept curr))))))", "problem": 86, "user": "4ec5cdb0535d6d7199dd36b8"}, {"code": "(let [sumofsquares (fn[x](reduce + \r\n  (map (fn[a](* a a))\r\n  (map (fn[b](Integer. (str b)))(vec (str x))))))\r\n   looping? (fn[x](not (apply distinct? x)))]\r\n(fn[x](loop [original x accum '(x)]\r\n(cond (= 1 (sumofsquares original)) true\r\n      (looping? accum) false\r\n      :else (recur (sumofsquares original) \r\n            (conj accum (sumofsquares original)))))))", "problem": 86, "user": "4ed2dd98535d44c135fd68e2"}, {"code": "(fn happy?\n  ([n] (happy? [] n))\n  ([seen n]\n    (cond\n      (= 1 n)\n        true\n      (contains? seen n)\n        false\n      true\n        (recur (conj seen n)\n          (->> n\n            (str)\n            (map #(- (int %) (int \\0)))\n            (map #(* % %))\n            (reduce +) )))))", "problem": 86, "user": "4f1b92d1535d64f60314647b"}, {"code": "(fn [n]\n  (let [digits (fn [x] (reverse (map #(rem (int (/ x %)) 10) (take-while #(<= % x) (iterate (partial * 10) 1)))))]\n    (loop [cur n\n         visited #{}]\n    (let [ds (digits cur)\n          next (apply + (map * ds ds))]\n      (println cur)\n      (cond\n        (visited cur) false\n        (= 1 next)    true\n        :otherwise    (recur next (conj visited cur)))))))", "problem": 86, "user": "4f1b0ab3535d64f603146474"}, {"code": "(fn [k] (loop [c k p #{}]\n           (let [n (reduce #(+ % (* %2 %2)) 0 (map #(- (int %) 48) (str c)))]\n             (cond (= 1 n) true\n                   (p n  ) false\n                   1      (recur n (conj p c))))))", "problem": 86, "user": "4ee88bfb535d93acb0a66881"}, {"code": "(fn [t]\n        (= 1\n           ((fn f \n              ([x d]\n                (let [s (reduce + (map (comp #(* % %) read-string str) x))]\n                  (if (d s)\n                    s\n                    (f (str s) (conj d s)))))\n              ([x] (f (str x) #{})))\n             t)))", "problem": 86, "user": "4f08b15b535dcb61093f6c40"}, {"code": "(fn happy [n]\n  (letfn [(sumsquare [n]\n         (loop [current n sum 0]\n           (if (= current 0)\n             sum\n            (let [digit (mod current 10)]\n               (recur (/ (- current digit) 10) (+ sum (* digit digit)))))))]\n    (loop [current n seen #{}]\n      (cond\n       (= current 1) true\n       (seen current) false\n       :else (recur (sumsquare current) (conj seen current))))))", "problem": 86, "user": "4f0d093b535d0136e6c22313"}, {"code": "(fn perfect[i] (loop [j i attempts #{}] (if (contains? attempts j) false (if (= 1 j) true (recur (reduce (fn [r v] (+ r (* v v))) 0 (map #(Integer/parseInt %) (re-seq (re-pattern #\"[\\d]\") (str j)))) (into attempts [j]))))))", "problem": 86, "user": "4f0e4ebd535d0136e6c22322"}, {"code": "(fn [hist num]\n   (let [msum (fn [num]\n     (loop [lst (mod num 10) rst (quot num 10) sum 0]\n       (if (and (= lst 0) (= rst 0))\n         sum\n         (recur (mod rst 10) (quot rst 10) (+ sum (* lst lst))))))\n         newnum (msum num)]\n     (cond\n      (= newnum 1) true\n      (get hist newnum) false\n      true (recur (conj hist newnum) newnum)))) #{}", "problem": 86, "user": "4eb02674535d7eef30807338"}, {"code": "(fn happy? \n  ([n]\n    (happy? #{} n))\n  ([s n]\n    (letfn [(happify [x]\n                     (apply + (map \n                          #(* %1 %1) \n                          (map \n                            #(Character/digit % 10) \n                            (str x)))))]\n      (cond\n        (= n 1) true\n        (contains? s n) false\n        :else (happy?\n                (conj s n)\n                (happify n))))))", "problem": 86, "user": "4ecfa05c535d44c135fd68b9"}, {"code": "(fn [x]\n  (letfn [(hn [x] (apply + (map #(* % %) (map #(- (int %) 48) (str x)))))]\n    (loop [n x s #{}]\n      (let [nn (hn n)]\n        (if (= 1 nn)\n          true\n          (if (nil? (s nn))\n            (recur nn (conj s nn))\n            false))))))", "problem": 86, "user": "4ee4f4a9535d1385b2869d85"}, {"code": "(fn [n]\n  (letfn [\n    (digs[num]\n      (loop [num num res []]\n        (if (< 0 num)\n          (recur (int (/ num 10)) (cons (mod num 10) res))\n          res)))\n    (sumsq[n]\n      (reduce + (map #(* % %) (digs n))))]\n    (loop [x n seen #{}]\n      (if (= 1 x)\n        true\n        (let [v (sumsq x)]\n          (if (get seen v)\n            false\n            (recur v (conj seen x))))))))", "problem": 86, "user": "4f1fd734535d64f6031464a5"}, {"code": "(fn [n]\n  (loop [n n s #{}]\n    (let [i (comp #(Integer/parseInt %) str)\n          v (reduce + (map (comp #(* % %) i) (str n)))]\n      (cond \n        (= v 1) true\n        (s v) false\n        1 (recur v (merge s v))))))", "problem": 86, "user": "4ec74de3535d6d7199dd36df"}, {"code": "(fn happy-number? [n]\r\n  (letfn [(square-sum [r n] (+ r (* n n)))\r\n          (digits [n] (if (= 0 n) [] (cons (mod n 10) (digits (quot n 10)))))]\r\n    (not (empty? (filter #(= 1 %) (take 100 (iterate #(reduce square-sum 0 (digits %)) n)))))))", "problem": 86, "user": "4f251302e4b0d66497709ff0"}, {"code": "(fn [z] \n  (letfn [(hs [x] (reduce + (map (fn [y] (* y y)) (map #(- (int %) 48) (seq (str x))))))]\n   (loop [en []\n          cn z]\n    (if (= 1 cn)\n      true\n      (if (some #(= cn %) en)\n        false\n        (recur (conj en cn) (hs cn)))))))", "problem": 86, "user": "4e1f9bb5535d04ed9115e80d"}, {"code": "(fn [x]\n   ((fn ! [set x]\n   (if (contains? set x)\n     false\n     (if (= 1 x)\n       true\n       (! (conj set x) (\n     (fn sum-square [x] (apply + (map #(* %1 %1) ((fn num-to-seq [x]\n  (reverse   (loop [result [] num x]\n               (if (zero? num)\n                 result\n                 (recur (conj result (mod num 10)) (int (/ num  10)))\n                 )\n               )\n             )) x)) ))\n\n\n                        x))\n       )\n     )) #{} x)\n  )", "problem": 86, "user": "4ea31da2535d7eef308072c1"}, {"code": "(fn happy? [n]\n    (let [digits\n            (fn digits [n] (lazy-seq\n                (when (pos? n)\n                    (cons (rem n 10) (digits (quot n 10))))))\n          sqr #(* % %)\n        ]\n        (loop [n n, seen #{}]\n            (cond\n                (= n 1) true\n                (seen n) false\n                :else (recur (apply + (map sqr (digits n))) (conj seen n))\n            ))))", "problem": 86, "user": "4df3d4f4535d08e6dec9fe2c"}, {"code": "(fn t \r\n  ([n s]\r\n    (if (s n) \r\n      false\r\n      (let [c (apply + (map (comp (fn [x] (* x x)) read-string str) (str n)))]\r\n        (if (= c 1)\r\n          true\r\n          (t c (conj s n))))))\r\n  ([n] (t n #{})))", "problem": 86, "user": "4ef6e689535dced4c769f24f"}, {"code": "(fn f[x]\n  (letfn [(q [x] (* x x))\n          (s [x] (apply + (map #(q (- (int %) 48)) (str x))))]\n         (loop [n x i 1]\n           (cond \n             (= n 1) true\n             (= i 10) false\n             :else (recur (s n) (inc i))))))", "problem": 86, "user": "4f1d1d95535d64f603146488"}, {"code": "(fn [n]\n  (let [f (fn [m] (apply + (map #(* (Integer/parseInt %) (Integer/parseInt %)) (map str (str m)))))]\n    (loop [c n cc 0]\n      (println \"F: \" (f c))\n      (if (= (f c) 1)\n        true\n        (if (= 100 cc)\n          false\n          (recur (f c) (inc cc)))))))", "problem": 86, "user": "4f26d6d9e4b0d6649770a007"}, {"code": "(fn [x]\n           (contains?\n            (loop [c (take 10 (iterate\n                               #(apply + (map (fn [y]\n                                                (let [y (- (int y) 48)]\n                                                  (* y y)))\n                                              (str %))) x))\n                   s #{}]\n              (if (nil?  (seq c)) s\n                  (let [f (first c)]\n                    (if (get s f)\n                      s\n                      (recur\n                       (rest c)\n                       (conj s f))))))\n            1))", "problem": 86, "user": "4f0664bd535dcb61093f6c0f"}, {"code": "(fn [n]\n  (let [f (fn [n]\n            (apply +\n              (map (fn [d]\n                     (* (- (int d) 48)\n                        (- (int d) 48)))\n                   (str n))))]\n    (loop [k (f n)\n           seen? #{n}]\n      (cond (= k 1) true\n            (seen? k) false\n            :else (recur (f k)\n                         (conj seen? k))))))", "problem": 86, "user": "4e7dd982535db169f9c796ee"}, {"code": "(let [digits (fn [x] (map #(Integer. (str %)) (str x)))\n      step (fn [x] (reduce + (map #(* % %) (digits x))))]\n  (fn [x] (cond\n            (= x 1) true\n            (= x 89) false\n            :else (recur (step x)))))", "problem": 86, "user": "4ebcb8ff535dfed6da9c6d8a"}, {"code": "(fn problem-86 [n]\n  (loop [seen-nums {}\n         new-num n]\n    (cond (= 1 new-num) true\n          ;; not sure this is right for false happy nums, instr are a bit unclear\n          (seen-nums new-num) false \n          :else (recur\n                 (assoc seen-nums new-num :true)\n                 (reduce\n                  (fn [result digit]\n                    (let [digit-as-int\n                          (Integer/valueOf (str digit))]\n                      (+ result (* digit-as-int digit-as-int))))\n                  0\n                  (str new-num))))))", "problem": 86, "user": "4f31519ae4b0d6649770a086"}, {"code": "(fn g [y]\r\n    (let [h (fn [x]\r\n  (apply + (map #(* % %) (map #(- (int %) 48) (str x)))))]\r\n      (loop [n y acc []]\r\n        (cond \r\n          (some #(= n %) acc) false\r\n          (= 1 n) true\r\n          true (recur (h n) (conj acc n)))\r\n      )))", "problem": 86, "user": "4ef0f1a1535dced4c769f212"}, {"code": "(fn[n]\n  (let [f (fn [n] (reduce + (map #(* % %) (map #(- (int %) 48) (seq (str n))))))]\n    (loop [a n used #{n}]\n      (let [s (f a)]\n        (cond\n         (= 1 s) true\n         (some #(= % s) used) false\n         :else (recur s (conj used s)))))))", "problem": 86, "user": "4e7d1c22535db169f9c796c5"}, {"code": "(fn [d] (letfn [(appify [n] (reduce #(+ %1 (* %2 %2)) 0 (for [d (str n)] (- (int d) (int \\0)))))]\n          (= 1 (nth (iterate appify d) 200))))", "problem": 86, "user": "4f3976aee4b0e243712b1eea"}, {"code": "(fn hn [n] \r\n  \t(loop [v n k #{}]\r\n\t\t\t(let [x (reduce + (map #(* % %) (map #(- (int %) 48) (seq (str v)))))]\r\n\t\t\t(cond \r\n\t\t\t\t(contains? k x) false\r\n\t\t\t\t(= 1 x) true\r\n\t\t\t\t:else (recur x (conj k x))))))", "problem": 86, "user": "4ecf1f51535d1f5ad70dba3a"}, {"code": "(fn [x]\n  (loop [n x seen #{}] \n    (let [new (apply + (->> n str (map #(Integer. (str %))) (map #(* % %))))]\n      (cond (= new 1) true\n            (seen new) false\n            :else (recur new (conj seen new))))))", "problem": 86, "user": "4e372223535deb9a81d77f39"}, {"code": "(fn [x]\r\n  (let [d (fn [n] (map #(read-string (str %)) (str n)))\r\n        h (fn [n] (apply + (map #(* % %) (d n))))\r\n        s (->> (iterate h x)\r\n               (reductions conj #{})\r\n               (partition 2 1)\r\n               (drop-while #(apply not= %))\r\n               (ffirst))]\r\n               (= (s 1) 1)))", "problem": 86, "user": "4eecdd66535d93acb0a668b9"}, {"code": "(fn f [t]\n    (let [x (reduce #(+ %1 (* %2 %2)) 0 (map #(Integer/parseInt %) (re-seq #\"\\d\" (str t)))) ] \n      (if (= 1 x) true\n        (if (< x 10) false\n          ( f x) \n        ) \n      )\n    ) \n  )", "problem": 86, "user": "4f1595da535d64f603146444"}, {"code": "(fn happy?\n  ([x] (happy? x #{}))\n  ([x prev]\n    (let [xs   (map #(- (int %) (int \\0)) (seq (str x)))\n          sqrs (map #(* % %) xs)\n          sum  (reduce + sqrs)]\n      (or (= 1 sum)\n          (and (nil? (prev sum))\n               (recur sum (conj prev sum)))))))", "problem": 86, "user": "4f2e0369e4b0d6649770a064"}, {"code": "(fn [n]\n  (let [f (fn [x]\n            (reduce + 0\n                    (map #(* (- (int %) (int \\0))\n                             (- (int %) (int \\0))) (seq (Integer/toString x)))))]\n    (loop [ s #{} i (f n)]\n      (if (= i 1) true\n          (if (contains? s i) false\n            (recur (conj s i) (f i)))))))", "problem": 86, "user": "4f38d6bbe4b0e243712b1ee2"}, {"code": "(fn happy-number [n]\n         (letfn [(split [d] (if (> d 0) (cons (mod d 10) (split (int (/ d 10))))))\n                 (calc [x] (reduce + (map #(* % %) (split x))))]\n           (loop [m (calc n)\n                  h #{}]\n             (cond\n               (contains? h m) false\n               (= m 1) true\n               :else (recur (calc m) (conj h m))))))", "problem": 86, "user": "4f1bee08535d64f60314647e"}, {"code": "(fn [x]\r\n  (letfn [(digitsum [x n]\r\n            (if (zero? x)\r\n              n\r\n              (recur (quot x 10) (+ n (#(* % %) (rem x 10))))))]\r\n    (if (< x 10) (val (find {1 true 2 false 3 false 4 false 5 false\r\n                             6 false 7 true 8 false 9 false} x))\r\n       (recur (digitsum x 0)))))", "problem": 86, "user": "4f474f43e4b0d56e7bb92bb7"}, {"code": "(fn happy [n]\n    (let [f (fn [x]\n              (->> x\n                   str\n                   (map #(Integer/parseInt (str %)))\n                   (map #(* % %))\n                   (apply +)))\n          s (iterate f n)]\n      (loop [seen #{}\n             [x & xs] s]\n        (cond\n         (= x 1) true\n         (seen x) false\n         :else (recur (conj seen x) xs)))))", "problem": 86, "user": "4ee26f01535d10e5ff6f5368"}, {"code": "(fn f [n]\n           (loop [i n, p []]\n              (let [s (reduce + (map (comp #(* % %) read-string str) (str i)))]\n                   (cond\n                     (= 1 s) true\n                     (some #{s} p) false\n                     :default (recur s (conj p s))))))", "problem": 86, "user": "4f34eb87e4b0e243712b1eba"}, {"code": "(fn [x] \n    \n    (loop [n x, sums #{}]\n    \n      (let [csum (reduce #(+ (* %2 %2) %1) 0 (map #(- (int %1) 48) (seq (str n))))]\n        (cond \n          (= 1 csum) true\n          (sums csum)  false\n          :else (recur csum (conj sums csum))))))", "problem": 86, "user": "4f29eb2ae4b0d6649770a037"}, {"code": "(fn [n]\n  (loop [occurs #{} num n]\n    (if (= 1 num)\n      true\n      (if (contains? occurs num)\n        false\n        (recur (conj occurs num)\n               (apply + (map #(* (- (int %) 48) (- (int %) 48)) (str num))))))))", "problem": 86, "user": "4e7e8684535db169f9c79717"}, {"code": "(fn [x]\n  (let [digits (fn [x]\n                 (reverse\n                   (map #(mod % 10)\n                        (take-while (complement zero?)\n                                    (iterate #(quot % 10) x)))))]\n    (= 1\n       (first (drop-while\n                #(and ((complement =) % 1)\n                      ((complement =) % 16))\n                (iterate #(apply + (map (fn [y] (* y y)) (digits %))) x))))))", "problem": 86, "user": "4f426a7ae4b0d7d3c9f3fcff"}, {"code": "(fn happy? [n]\n  (let [digits (map #(Integer. (str %)) (str n))\n        sum (int (reduce + (map #(Math/pow % 2) digits)))]\n\t  (cond\n\t\t  (= sum 1) true\n\t\t\t(= sum 4) false\n\t\t\t:else (recur sum))))", "problem": 86, "user": "4eddcbbf535d10e5ff6f532d"}, {"code": "(fn [num]\n    (letfn [(digits [n] (loop [acc '() num n] (if (zero? num) acc (recur (cons (mod num 10) acc) (quot num 10)))))\n            (next-happy [n] (reduce + 0 (map #(* % %) (digits n))))]\n        (loop [seen #{} n num]\n            (cond (== n 1) true\n                  (seen n) false\n                  :else    (recur (conj seen n) (next-happy n))))))", "problem": 86, "user": "4f4ac35ae4b0d56e7bb92c18"}, {"code": "(fn happy? [n & [seen?]]\n  (let [seen? (or seen? #{})]\n    (if (or (= 1 n) (seen? n))\n      (= 1 n)\n      (->> (for [digit (str n)\n                 :let [num (Integer/parseInt (str digit))]]\n             (* num num))\n           (reduce +)\n           (#(happy? % (conj seen? n)))))))", "problem": 86, "user": "4eae5fe4535d7eef30807325"}, {"code": "(fn happy-number?\n  [num]\n  (let [squares (for [i (range 10)] (* i i))\n        sum-of-squares (fn [n]\n                         (loop [sum 0\n                                n n]\n                           (if (> n 0)\n                             (recur (+ sum (nth squares (rem n 10)))\n                                    (quot n 10))\n                             sum)))]\n    (loop [s #{}\n           n num]\n      (if (and (> n 1)\n               (not (s n)))\n        (recur (conj s n)\n               (sum-of-squares n))\n        (= n 1)))))", "problem": 86, "user": "4db8d37d535d1e037afb219c"}, {"code": "(fn happy? [x]\n  (let [digits (fn [x] (map #(- % 48) (map int (.toString x))))\n        squared-digits (fn [x] (reduce + (map #(* % %) (digits x))))]\n    (loop [x_ x acc #{}]\n      (cond\n        (= 1 x_) true\n        (acc x_) false\n        :else (recur (squared-digits x_) (conj acc x_))))))", "problem": 86, "user": "4f50c414e4b03ad3f0c10d0d"}, {"code": "(fn [h] (\r\n  (fn [x xs] \r\n  (let [newx ((fn [n acc] (if (= n 0) acc (recur (long (/ n 10)) (+ (#(* %1 %1) (rem n 10)) acc)))) x 0)]\r\n\t(println newx)\r\n\t(if (= newx 1)\r\n\t\ttrue\r\n\t\t(if (some #{newx} xs) false\r\n\t\t(recur newx (cons x xs)))))) h []))", "problem": 86, "user": "4f51e8a4e4b03ad3f0c10d2d"}, {"code": "(fn [n]\n  (= 1 (some #{1 4}\n    (iterate\n      (fn [x]\n        (apply + (map #((fn [x] (* x x)) (- (int %) 48)) (str x))))\n      n))))", "problem": 86, "user": "4f4e91a9e4b03ad3f0c10cca"}, {"code": "(fn [s]                                                                                     \n  ((fn ! [visited val]                                                                                \n     (letfn [(digits [i] (map #(Integer/parseInt (str  %)) (str i)))]                                \n       (let [hpy  (reduce + (map #(* % %) (digits val)))]                                            \n         (if (= hpy 1)                                                                               \n           true                                                                                      \n           (if (contains? visited hpy)                                                               \n             false                                                                                   \n             (! (conj visited hpy) hpy)))))) #{} s))", "problem": 86, "user": "4f1d1299535d64f603146487"}, {"code": "(fn [x]\n  (let [sq (fn [n]\n             (reduce #(+ %1 (int (Math/pow (rem %2 10)2)))\n                     0\n                     (take-while #(not= 0 %)\n                                 (iterate #(int (/ % 10)) n))))\n        s (iterate sq x)]\n    (= 1\n       (loop [ac [] n (first s) s (rest s)]\n         (if (or (some #(= % n) ac)\n                 (= 1 n))\n           n\n           (recur (conj ac n) (first s) (rest s)))))))", "problem": 86, "user": "4f32a7f1e4b0d6649770a095"}, {"code": "(letfn [(sum-squares [x]\n                (loop [x x acc 0]\n                  (let [tens (quot x 10)\n                        ones (mod x 10)\n                        result (+ acc (* ones ones))]\n                    (if (pos? tens)\n                      (recur tens result)\n                      result))))]\n    (fn happy? [x]\n      (loop [x x seen #{x}]\n        (let [result (sum-squares x)]\n          (cond\n           (seen result) false\n           (= 1 result) true\n           :else (recur result (conj seen result)))))))", "problem": 86, "user": "4f047177535dcb61093f6bc6"}, {"code": "(fn [n]\n  (letfn [\n    (sq [n] (* n n))\n    (nhappy [n] \n      (if (> 1 n) 0\n        (+ (sq (rem n 10)) (nhappy (int (/ n 10))))))]\n    (loop [acc #{} n n]\n      (if (== 1 n) true\n        (let [acc2 (conj acc n)]\n          (if (= acc acc2) false\n            (recur acc2 (nhappy n))))))))", "problem": 86, "user": "4f569218e4b0a7574ea71826"}, {"code": "(fn [n]\n  (loop [a [n]]\n    (let [x (->> (map #(read-string (str %)) (str (last a)))\n                 (reduce #(+ %1 (* %2 %2)) 0))]\n      (cond (= x 1) true\n            (some #{x} a) false\n            :else (recur (conj a x))))))", "problem": 86, "user": "4f569a3ce4b0a7574ea71828"}, {"code": "(fn [s n]\n  (if (= 1 n) true\n    (if (s n) false\n      (recur\n        (conj s n)\n        (apply + (map #(* % %) (map #(- (int %) 48) (str n))))))))\n#{}", "problem": 86, "user": "4f38b7d9e4b0e243712b1ee0"}, {"code": "(fn [n]\n    (letfn [(which-repeat [coll]\n              (loop [s #{} [x & xs] coll]\n                (if (contains? s x) x\n                    (recur (conj s x) xs))))\n            (one-num [n]\n              (reduce (fn [a c] (+ a (let [n1 (- (int c) (int \\0))] (* n1 n1)))) 0 (str n)))]\n      (= 1 (which-repeat (iterate one-num n)))))", "problem": 86, "user": "4f3ec266e4b0e243712b1f8c"}, {"code": "(fn thisfunc\n  ([n] (thisfunc n #{}))\n  ([n unhappy]\n    (cond\n      (= 1 n) true\n      (unhappy n) false\n      true (let [x (reduce + (map #(* % %) (map #(Integer/parseInt %) (map str (str n)))))]\n        (thisfunc x (conj unhappy n))))))", "problem": 86, "user": "4dd9d299535d2dad7130b5dd"}, {"code": "(fn [n]\n  (letfn [(emit[x] (loop [s '() x x] (if (zero? x) s (recur (conj s (rem x 10)) (quot x 10)))))\n    (compute [s] (reduce + (map #(* % %) (emit s))))]\n  (loop [n n seen #{}]\n    (cond (contains? seen n) false\n          (= 1 n) true\n          :else (recur (compute n) (conj seen n))))))", "problem": 86, "user": "4f4c6b21e4b03ad3f0c10c8f"}, {"code": "#(< 3 %)", "problem": 86, "user": "4f0446f9535dcb61093f6bb8"}, {"code": "(fn happy? [n]\r\n  (letfn [(nums [n] (map #(Integer/parseInt %) (map str (str n))))]\r\n    (let [sumsq (reduce + (for [x (nums n)] (int (Math/pow x 2))))]\r\n      (cond (= sumsq 4) false\r\n            (= sumsq 1) true\r\n            :else (recur sumsq)))))", "problem": 86, "user": "4f62b29ce4b0defedf855fd9"}, {"code": "(fn [x]\n  (loop [n x, e #{}]\n    (cond\n      (= n 1) true\n      (contains? e n) false\n      true (recur\n        (reduce +\n          (map #(* % %)\n            (map #(Integer. (str %))\n              (str n))))\n        (conj e n)))))", "problem": 86, "user": "4f6fbb68e4b07046d9f4efeb"}, {"code": "(fn is-happy? [n]\n  (let [sqr #(* % %)\n        to-int #(- (int %) (int \\0))\n        sqr-as-int (comp sqr to-int)]\n    (loop [n n, seen #{}]\n      (if (seen n) false\n        (let [n2 (apply + (map sqr-as-int (str n)))]\n          (if (= 1 n2) true\n            (recur n2 (conj seen n))))))))", "problem": 86, "user": "4f6160a7e4b0defedf855fbe"}, {"code": "(fn [x]\n  (let [step (fn [n] (-> n str seq (->> (map str) (map #(Integer/parseInt %)) \n                        (map #(* % %)) (reduce + 0))))]\n    (loop [x x cntr 0]\n      (if (= x 1)\n        true\n        (if (> cntr 1000)\n          false\n          (recur (step x) (inc cntr)))))))", "problem": 86, "user": "4e7f5a0b535db966e863cc41"}, {"code": "(fn happy [n]\n  (letfn [(digits [n]\n            (map #(Integer/parseInt (str %)) (str n)))\n          (sumsquares [l]\n            (apply + (map #(* % %) l)))\n          (numbers [n]\n            (reductions conj #{}\n              (iterate (comp sumsquares digits) n)))\n          (pairs [n]\n            (partition 2 1 (numbers n)))\n          (find [n]\n            (ffirst (drop-while (partial apply not=)(pairs n))))]\n    (contains? (find n) 1)))", "problem": 86, "user": "4f58fe71e4b0a7574ea7185f"}, {"code": "(fn perfectNum[n]\r\n  (let[stop #{4 16 37 58 89 145 42 20},\r\n       sqrtsum (fn sqrsum[n]\r\n                 (apply + \r\n  \t\t\t\t\t\t\t     (map #(* % %) \r\n\t\t\t\t\t\t\t\t         (map #(- (int %) 48) \r\n                                 (seq (str n) ) ) )\r\n\t\t\t\t\t\t\t\t )\r\n\t\t\t\t\t\t\t),\r\n       perfect (fn[n]\r\n\t\t\t\t\t\t\t\t    (cond (contains? stop n)  (keyword \"unless\")\r\n\t\t\t\t\t\t\t\t            (= n 1) (keyword \"good\")\r\n\t\t\t\t\t\t\t\t            :else (sqrtsum n)\r\n\t\t\t\t\t\t\t\t     )\r\n                   )\r\n       ]\r\n       (get {:unless false,:good true}\r\n            (some  #{:unless :good} \r\n              (iterate perfect n) ) )      \r\n  )\r\n)", "problem": 86, "user": "4f6d9d7ee4b07046d9f4efcd"}, {"code": "(fn happy [n]\n  (let [s (reduce + (map (fn [c] (let [i (- (int c) 48)] (* i i))) (seq (str n))))]\n    (cond\n     (= s 1) true\n     (= s 4) false\n     :else (happy s))))", "problem": 86, "user": "4ecbb249535df97575fdabdf"}, {"code": "(fn [n]\n  (boolean \n    (some #{1}\n      (take 50\n        (iterate\n          (fn [x]\n            (reduce + (map #(int (Math/pow (Integer/parseInt (str %)) 2))\n                           (str x))))\n          n)))))", "problem": 86, "user": "4dafa380edd6309eace4d17c"}, {"code": "{7 true 986543210 true 2 false 3 false}", "problem": 86, "user": "4f899d9fe4b033992c121c7c"}, {"code": "(fn iter\n  ([n] (iter n #{}))\n  ([n tested]\n    (letfn [ (digits [s]\n               (map #(Integer/parseInt %)\n                    (re-seq #\"[0-9]\" (str s))))]\n    (cond (= n 1) true\n          (tested n) false\n          :else (recur (reduce + (map #(* % %) (digits n)))\n                       (conj tested n))))))", "problem": 86, "user": "4f8345c6e4b033992c121c1b"}, {"code": "(fn happy [n]\n  (letfn [(f [o] \n    (reduce + (map #(let [a (Integer/parseInt (str %))] (* a a))\n                   (str o)\n                   )\n            ))]\n    (loop [acc [] i n]\n      (cond  \n        (= i 1) true \n        (some #{i} acc) false\n        :else (recur (conj acc i) (f i)))\n      )\n    )\n)", "problem": 86, "user": "4f88ae35e4b033992c121c6d"}, {"code": "(fn p86 \r\n  ([n] (p86 #{} n))\r\n  ([seen n]\r\n    (if (some #{n} seen)\r\n      false\r\n      (let [nn (reduce + (map #(* % %) (map #(Integer/parseInt (str %)) (str n))))]\r\n        (if (= nn 1)\r\n          true\r\n          (p86 (conj seen n) nn))))))", "problem": 86, "user": "4f7f0827e4b06e829148e1d5"}, {"code": "(fn [n]\n  (letfn [(ssd [n] (loop [r 0 n n]\n                     (if (zero? n) r\n                         (recur (+ r (* (mod n 10) (mod n 10)))\n                                (quot n 10)))))]\n    (not (some #(> (count (val %)) 1)\n               (group-by identity\n                         (remove #(= 1 %) (take 25 (iterate ssd n))))))))", "problem": 86, "user": "4f2baf1ae4b0d6649770a04c"}, {"code": "(fn [n]\n  (letfn [(next-happy [n]\n           (reduce + (map #(* % %) (map #(Integer/parseInt (str %)) (-> n str seq)))))\n          (happy-numbers [n]\n            (lazy-seq\n              (cons n (happy-numbers (next-happy n)))))]\n    (let [so-far (atom [])\n          last-elem (first (drop-while #(do (swap! so-far conj %) (= (count @so-far) (count (distinct @so-far)))) (happy-numbers n)))]\n      (= last-elem 1))))", "problem": 86, "user": "4f7e29dde4b06e829148e1ca"}, {"code": "(fn happy\n  ([n] (happy n #{}))\n  ([n s]\n    (if (= 1 n)\n      true\n      (if (s n)\n        false\n        (let [nn\n          (apply +\n            (map #(* % %)\n              ((fn digits [x]\n                (if (zero? x)\n                  ()\n                  (cons (rem x 10) (digits (quot x 10)))\n                )\n              ) n)\n            )\n          )]\n          (happy nn (conj s n))\n        )\n      )\n    )\n  )\n)", "problem": 86, "user": "4f725201e4b07046d9f4f02f"}, {"code": "(fn [n]\n           (letfn [(sq-sum-digit [num]\n                              (apply + (map (fn [s]\n                                                (let [n (Integer. (str s))]\n                                                     (* n n)))\n                                            (str num)))) \n                   (happy-num [num]\n                              (let [num (sq-sum-digit num)] \n                                  (cond\n                                 (= num 1) true\n                                 (< num 10) false\n                                 :else (happy-num (sq-sum-digit num)))))]\n                   (happy-num n)))", "problem": 86, "user": "4f3cd535e4b0e243712b1f56"}, {"code": "(fn [n]\r\n  (loop [p n s []]\r\n    (if (= p 1) true\r\n        (if (some #(= p %) s) false\r\n            (recur\r\n              (reduce #(+ % (* %2 %2))\r\n                0\r\n                (map #(- (int %) 48) (str p)))\r\n              (conj s p))))))", "problem": 86, "user": "4f9597e0e4b0dcca54ed6cd4"}, {"code": "(fn [n]\n  (let [ssq (fn [x]\n              (reduce #(+ %1 (* %2 %2)) 0\n                (map #(Character/digit % 10) (str x))))]\n    (loop [x n sad #{}]\n      (cond\n        (= 1 x) true\n        (sad x) false\n        :else (recur (ssq x) (conj sad x))))))", "problem": 86, "user": "4f969214e4b0dcca54ed6cdd"}, {"code": "(fn [n]\n  (let [sqd (fn [n] (loop [n n s 0] \n                          (if (zero? n)\n                              s \n                              (recur (quot n 10) (+ s (* (mod n 10) (mod n 10)))))))\n        happy (fn [n p]\n                  (let [s (sqd n)]\n                      (if (= s 1)\n                          true\n                          (if (p s) false (recur s (conj p s))))))]\n      (happy n #{})))", "problem": 86, "user": "4f9120d8e4b0dcca54ed6c96"}, {"code": "(fn [n]\r\n  (let [f (fn f [n]\r\n            (let [next (reduce (fn [s i] (+ s (* i i))) 0 \r\n                               (map #(read-string (str %)) (str n)))]\r\n              (lazy-seq (cons next (f next)))))\r\n        rf (fn rf \r\n             ([sq] (rf sq '()))\r\n             ([[fst & rs] acc] \r\n               (cond\r\n                 (= 1 fst) true\r\n                 (seq (filter (partial = fst) acc)) false\r\n                 :default (rf rs (cons fst acc)))))]\r\n    (rf (f n))))", "problem": 86, "user": "4f0da4e4535d0136e6c22319"}, {"code": "(fn [num]    ((complement not-any?) #{1}          (      (fn happy [n]        (let [digits  (map #(Integer/parseInt (str %1)) (str n))              alg (reduce + (map #(* % %) digits)) ]          (take-while #(not= % n) (cons alg (lazy-seq (happy  alg ) )) )          ))          num ) )    )", "problem": 86, "user": "4f4be1cae4b03ad3f0c10c81"}, {"code": "(fn hn? [x]\n  (if (not= nil (some #(= 1 %)\n    (take 10 (iterate\n      (fn s [n]\n        (reduce #(+ %1 (* %2 %2)) 0\n          (map #(Integer/parseInt %) (re-seq #\"\\d\" (str n)))\n        )\n      )\n      x\n    ))\n  )) true false)\n)", "problem": 86, "user": "4f84400de4b033992c121c2e"}, {"code": "(fn happy? [n]\n  (letfn [\n    (sqsum [n] \n      (reduce + \n        (map (comp #(* % %) \n                   #(Integer/parseInt %) \n                   str)\n        (.toString n))))]\n    (loop [n n, seen #{n}]\n      (let [s (sqsum n)]\n        (cond\n          (= 1 s)  true\n          (seen s) false\n          :else    (recur s (conj seen s)))))))", "problem": 86, "user": "4f9d53f3e4b0dcca54ed6d21"}, {"code": "(fn [n]\n    (letfn [(digits [n]\n              (loop [n n\n                     s '()]\n                (if (zero? n)\n                  s\n                  (recur (quot n 10)\n                         (conj s (mod n 10))))))]\n      (loop [n n\n             counter 0]\n        (cond (< 100 counter) false\n              (= n 1) true\n              :else (recur (apply + (map #(* % %)\n                                         (digits n)))\n                           (inc counter))))))", "problem": 86, "user": "4f5cc3b8e4b0030a34fb2b2b"}, {"code": "#(letfn\n     [(d [x] (* x x))\n      (dc [c] (d (- (int c) 48)))\n      (sd [x] (reduce + (map dc (str x))))]\n   (loop [n (sd %) v #{}]\n     (if (= n 1)\n       true\n       (if (v n)\n         false\n         (recur (sd n) (conj v n))))))", "problem": 86, "user": "4f9fe2b9e4b0dcca54ed6d40"}, {"code": "(fn [n]\n   (loop [squares (zipmap (map (comp first str) (range 10))\n                          (for [i (range 10)] (* i i)))\n          n n\n          s #{}]\n     (if (or (<= n 1) (contains? s n))\n       (= n 1)\n       (recur squares\n              (reduce + (map squares (str n)))\n              (conj s n)))\n     ))", "problem": 86, "user": "4e9fd521535d7eef3080729a"}, {"code": "(fn [n]\n  (letfn [(sum-squares-digits [n]\n            (->> n\n              digits\n              (map #(* % %))\n              (reduce +)))\n          (digits [n]\n            (->> n\n              str\n              (map str)\n              (map #(Integer/valueOf %))))]\n    (loop [history #{} sum (sum-squares-digits n)]\n      (cond (history sum) false\n            (= 1 sum) true\n            :else (recur (conj history sum)\n                         (sum-squares-digits sum))))))", "problem": 86, "user": "4f969a66e4b0dcca54ed6cde"}, {"code": "(fn [x]\n  (letfn [(digits [n] (if (< n 10)\n                          (list n)\n                          (cons (mod n 10)\n                                (digits (quot n 10)))))\n          (sqsum [ns] (reduce + (map #(* % %) ns)))\n          (trace [n] (iterate (comp sqsum digits) n))]\n   (= 1 (first (drop-while #(and (not= 1 %) (not= 4 %))\n               (trace x))))))", "problem": 86, "user": "4fa6d532e4b081705acca1be"}, {"code": "{7 true 986543210 true 2 false 3 false}", "problem": 86, "user": "4f82f9f7e4b033992c121c10"}, {"code": "(fn happy?\n  ([x] (happy? x #{}))\n  ([x history]\n     (letfn [(digits [x]\n               (if (< x 10)\n                 [x]\n                 (conj (digits (quot x 10)) (rem x 10))))\n             (square-sum [x]\n               (->> x digits (map #(* % %)) (apply +)))]\n       (let [y (square-sum x)]\n         (cond\n          (== 1 y) true\n          (history y) false\n          :else (recur y (conj history y)))))))", "problem": 86, "user": "4f3fb586e4b0e243712b1f9c"}, {"code": "(fn [n]\n  (letfn [(d [i]\n            (if (zero? i) 0\n                (+ (* (mod i 10) (mod i 10)) (d (int (/ i 10))))))]\n    (loop [n n\n           s #{}]\n      (let [h (d n)]\n        (cond (= h 1) true\n              (contains? s h) false\n              :else (recur h (conj s h)))))))", "problem": 86, "user": "4facd2fae4b081705acca22f"}, {"code": "{7 true, 986543210 true, 2 false, 3 false} ;;for fun", "problem": 86, "user": "4f9970b3e4b0dcca54ed6cfd"}, {"code": "(fn [x]\n  (letfn [\n    (looping? [f start]\n      (loop [S #{}, x start]\n        (cond \n          (S x) false\n          (= 1 x) true\n          :else (recur (conj S x) (f x)))))\n\n    (digits [x]\n      (loop [y x, result '()]\n        (if (zero? y)\n          (apply vector result)\n          (recur (quot y 10) (conj result (rem y 10))))))\n\n    (square [x]\n      (* x x))\n\n    (sum [A]\n      (reduce + A))\n\n    (formula [x]\n      (sum (map square (digits x))))]\n\n    (looping? formula x)))", "problem": 86, "user": "4faa9593e4b081705acca1f9"}, {"code": "(fn happy [n]\n  (let [doit (fn [i]\n               (let [_ (println i)\n                     predigits (seq (str i))\n                     _ (println predigits)                   \n                     digits (map #(- (int %) (int \\0)) predigits)\n                     _ (println digits)\n                     sqdigits (map #(* % %) digits)\n                     _ (println sqdigits)\n                     sumsq (reduce + sqdigits)\n                     _ (println sumsq)]\n                  sumsq))]\n    (loop [seen #{}\n           i n]\n       (cond \n         (= i 1) true\n         (contains? seen i) false\n         :else (recur (conj seen i) (doit i))))))", "problem": 86, "user": "4f036fb3535dcb61093f6ac8"}, {"code": "(fn [n]\n (letfn [(digits [n] (map #(Integer/parseInt (str %)) (str n)))]\n   (loop [m n seen #{}]\n     (let [sum (apply + (map #(* % %) (digits m)))]\n       (cond\n        (= sum 1) true\n        (seen sum) false\n        :else (recur sum (conj seen sum)))))))", "problem": 86, "user": "4fa0a4b1e4b0dcca54ed6d4f"}, {"code": "(fn [in]\n   (loop [x in i 0]\n     (let \n       [r (apply + \n                 (map \n                   #(apply *\n                           (repeat 2 (- (int %) 48)))\n                   (Integer/toString x)))]\n       (if (= 1 r)\n         true\n         (if (< i 10)\n           (recur r (inc i))\n           false)))))", "problem": 86, "user": "4fa5406fe4b081705acca1ac"}, {"code": "(fn happy ([s] (happy [s] #{}))\n  ([s visited]\n    (let [next (fn [i]\n                 (reduce + (map #(* % %) (map #(Integer/parseInt %) (re-seq #\"[\\d]\" (str i))))))]\n      (cond (visited s) false\n            (= 1 s) true\n            :else (happy (next s) (conj visited s))))))", "problem": 86, "user": "4f4274f2e4b0d7d3c9f3fd00"}, {"code": "(letfn [\n  (digits [n] (map #(Integer. %) (re-seq #\"\\d\" (str n))))\n  (sqr-digits-sum [n] (reduce + (map #(* % %) (digits [n]))))\n  ]\n  #(loop [n % r #{}] \n    (cond \n      (= 1 n) true \n      (r n)   false \n      :else   (recur (sqr-digits-sum n) (conj r n)))))", "problem": 86, "user": "4f991ec1e4b0dcca54ed6cfb"}, {"code": "(fn [n]\n((fn f [n c]\n  (let [m (reduce\n            #(+ %1 (* %2 %2))\n            0\n            (map\n              #(mod % 10)\n              (take-while pos?\n                (iterate #(int (/ % 10)) n))))]\n    (if (= m 1) true \n      (if (zero? c) false (recur m (dec c))))))\nn 1000))", "problem": 86, "user": "4fb2101ce4b081705acca284"}, {"code": "(fn [x] (= 1 (last (take 10 (iterate (fn [y] (reduce + (map #(* % %) (map (comp read-string str) (.toString y))))) x)))))", "problem": 86, "user": "4f4f0287e4b03ad3f0c10cd7"}, {"code": "(fn [n]\n  (loop [n n memo #{}]\n    (cond (= n 1) true\n          (memo n) false\n          :else (let [s (reduce + (map #(* % %) \n((fn dl [n] (if (< n 10) (list n) (cons (mod n 10) (dl (int (/ n 10)))))) n)))]\n(recur s (conj memo n))))))", "problem": 86, "user": "4f9a0064e4b0dcca54ed6d03"}, {"code": "(fn app\n  ([x] (app x #{}))\n  ([x m] \n    (let [res\n      (reduce + \n        (for [y (str x)] (* (- (int y) 48) (- (int y) 48))))]\n      (if (= res 1)\n        true\n        (if (contains? m res)\n          false\n          (app res (conj m res)))))))", "problem": 86, "user": "4dd579b5535dae65d5c462ea"}, {"code": "(fn [n]\n  (letfn [(n2s [n] (loop [n n r []] (if (> 10 n) (conj r n) (recur (quot n 10) (conj r (mod n 10))))))\n          (f [n] (int (reduce #(+ % (Math/pow %2 2)) 0 (n2s n))))]\n    (loop [n n s #{}]\n      (if (= 1 n)\n        true\n        (if (contains? s n)\n          false\n          (recur (f n) (conj s n)))))))", "problem": 86, "user": "4f954dbce4b0dcca54ed6ccd"}, {"code": "(fn [n]\n  ((fn happy [n times]\n    (if (= times 100) false\n      (let [cand (apply + (map (fn [x]\n             (.longValue (Math/pow (Integer/parseInt (str x)) 2))\n              ) \n           (str n)))]\n        (if (= 1 cand) true (happy cand (inc times)))\n      )\n    )\n  ) n 0)\n  \n)", "problem": 86, "user": "4f7b6b90e4b06e829148e1a4"}, {"code": "(fn [n]\n  (loop [prev #{} [f & remaining] (iterate (fn [x] (reduce #(+ % (* %2 %2)) 0 (map #(read-string (str %)) (str x)))) n)]\n    (if (= 1 f)\n      true\n      (if (prev f)\n        false\n        (recur (conj prev f) remaining)))))", "problem": 86, "user": "4f83665ee4b033992c121c1c"}, {"code": "(fn [num]\n    (let\n      [ sqr #(* % %)\n        sum-squares (fn sum-squares [num]\n          (if (< num 10)\n              (sqr num)\n              (+ (sqr (mod num 10))\n                 (sum-squares (quot num 10)))))]\n      (loop [num num num-tries 100]\n        (cond\n          (= num 1) true\n          (zero? num-tries) false\n          :else (recur (sum-squares num) (dec num-tries))))))", "problem": 86, "user": "4f725466e4b07046d9f4f030"}, {"code": "(fn [n]\n  (letfn\n    [(ch-to-int [c] (read-string (str c)))\n     (sum-sq [i]\n       (->>\n         (str i)\n         (map #(* (ch-to-int %) (ch-to-int %)))\n         (reduce +)))]\n    (loop\n      [prev #{}\n       i n]\n      (cond\n        (= 1 i) true\n        (prev i) false\n        :else (recur (conj prev i) (sum-sq i))))))", "problem": 86, "user": "4f7f9665e4b033992c121bea"}, {"code": "(fn [n]\n  (letfn [(sqr [x] (* x x))\n          (sqrdig [x] (apply + (map #(sqr (- (int %) 48)) (str x))))]\n    (loop [n n sn #{}]\n          (cond\n           (= n 1) true\n           (sn n) false\n           :default (recur (sqrdig n) (conj sn n))))))", "problem": 86, "user": "4efd8b67535de96065cf5085"}, {"code": "(fn dos\n      ([n] (dos n 1))\n    ([n count] \n          (letfn [(once [n]\n  (apply +\n  (map #(* % %)\n  (map read-string (map str (vec (str n))))\n  )\n  ))]\n      (if (= 1 n) true\n                 (if (> count 1000) false\n      (dos (once n) (inc count))\n                   )\n                 )\n      )\n  )\n    )", "problem": 86, "user": "4f2004a1535d64f6031464a7"}, {"code": "(fn [s]\n         (let [f (fn [n]\n               (let [digits (map #(- (int %) 48) (str n))\n                     q (apply + (map #(* % %) digits))] q))\n               h (iterate f s)\n               k (fn i [m [l & others]]\n                   (cond (= 1 l) true (contains? m l) false true (i (conj m l) others)))]\n           (k #{} h)))", "problem": 86, "user": "4fa30027e4b081705acca187"}, {"code": "(fn [num]\n  (letfn\n    [ (sqdig [x] (let [v (- (int x) (int \\0))] (* v v)))\n      (sqsum [x] (reduce + (map sqdig (str x))))]\n    (cond\n      (= num 1) true\n      (= num 4) false ;; part of all infinite cycles\n      :else (recur (sqsum num)))))", "problem": 86, "user": "4fc0853ae4b081705acca327"}, {"code": "(fn [n]\n   (letfn [(squared [x] (* x x))\n           (sos [l] (apply + (map squared l)))\n           (digits [s] (map #(- (int %) 48) s))\n           (next-happy [n] (sos (digits (str n))))]\n     (loop [seen #{}\n            n n]\n       (cond\n         (= n 1) true\n         (contains? seen n) false\n         :else (recur\n                (conj seen n)\n                (next-happy n))))))", "problem": 86, "user": "4fc8c8d8e4b0ee37620e183b"}, {"code": "(fn happy? [num]\n  (letfn [(square [n] (* n n))\n          (oper [n]\n            (reduce + (map #(square ( Integer/parseInt (str %)))\n                           (flatten (partition 1 (str n))))))]\n          (loop [acc []\n                 result num]\n            (cond\n             (= 1 result) true\n             (contains? acc result) false\n             :else (recur (conj acc result) (oper result))))))", "problem": 86, "user": "4faafccde4b081705acca209"}, {"code": "(fn [n]\n  (letfn [(ssum [n]\n    (if (zero? n) 0 (+ (ssum (quot n 10)) (* (mod n 10) (mod n 10)))))]\n  (loop [n n s #{}]\n    (if (s n)\n      (= n 1)\n      (recur (ssum n) (conj s n))))))", "problem": 86, "user": "4fc4eadee4b081705acca353"}, {"code": "(fn happy [n]\n (let [to-int #(Integer/parseInt(str %))\n       sum-of-squares (fn [x] (reduce + (map \n                        #(* (to-int %) (to-int %)) (str x))))]\n (loop [x n xs []]\n   (cond (= x 1) true\n         (not= -1 (.indexOf xs x)) false\n         :else (recur (sum-of-squares x) (conj xs x))))))", "problem": 86, "user": "4fca1cd6e4b0ee37620e184c"}, {"code": "(fn happy?\n  ([seen n] (letfn [(to-digits [n]\n                      (if (= 0 n)\n                        []\n                        (conj (to-digits (quot n 10)) (mod n 10))))]\n              (let [sq (apply + (map #(* % %) (to-digits n)))]\n                (cond (= sq 1) true\n                      (seen sq) false\n                      :else (happy? (conj seen sq) sq)))))\n  ([n] (happy? #{} n)))", "problem": 86, "user": "4fcaf7a4e4b0ee37620e1857"}, {"code": "(fn [n]\n  (loop [n n, seen #{}]\n    (let [digits \n            (fn [i] \n              (map \n                #(- (int %) 48)\n                (str i)))\n          sos\n            (fn [ds]\n              (reduce + (map #(* % %) ds)))\n          sum (sos (digits n))]\n      (or (= sum 1)\n          (if (seen sum)\n            false\n            (recur sum (conj seen sum)))))))", "problem": 86, "user": "4fce5474e4b0d4b2a7a9d451"}, {"code": "(fn [x] \n  (loop [i x s #{}] \n  (cond \n    (= i 1) true \n    (s i) false \n    :else \n      (recur \n        (apply + \n          (map \n            #(let [x (- (int %) 48)] (* x x)) (str i))) \n            (conj s i)))))", "problem": 86, "user": "4fb3b865e4b081705acca2a2"}, {"code": "#(loop [n % seen #{}] \n  ( let [x (int \n    (reduce + (map (fn[a](Math/pow (read-string (str a)) 2)) \n      (seq (str n)))))] (if (= x 1) true \n      (if (contains? seen x) false \n      (recur x (set (cons x seen)))))))", "problem": 86, "user": "4fb3dd1ee4b081705acca2a5"}, {"code": "(fn [n]\n  (loop [n n\n         p #{}]\n  (cond (p n) false\n        (= n 1) true\n        :else \n          (recur \n            (reduce +\n              (map #(let [a (- (int %) (int \\0))] (* a a)) (str n)))\n            (conj p n)))))", "problem": 86, "user": "4fb1d907e4b081705acca282"}, {"code": "(fn happy?[journey in-num]\n  (let [sum-squares ((fn sumsq[lst num]\n                       (if (= (quot num 10) 0) (reduce + (map #(* % %) (conj lst (rem num 10))))\n                           (sumsq (conj lst (rem num 10)) (quot num 10)))) [] in-num)]\n    (if (= 1 sum-squares) true\n        (if (contains? journey sum-squares) false (happy? (conj journey sum-squares) sum-squares))))) #{}", "problem": 86, "user": "4fb86dc9e4b081705acca2d8"}, {"code": "(fn [n]\n((fn happy [xs x]\n  (cond\n    (= x 1) true\n    (xs x) false\n    :else (let [x2 \n                  (reduce + (map #(* % %) (map #(- (int %) (int \\0)) (str x))))]\n            (recur (conj xs x) x2)))) \n#{} n))", "problem": 86, "user": "4fd22e70e4b04c3a95aa041c"}, {"code": "(fn [n]\n  (loop [n n old []]\n    (println n old)\n    (cond (= n 1) true\n          (some #{n} old) false\n          :else (recur\n                  (reduce + (map #(* % %)\n                                 (map #(Integer/parseInt (str %))\n                                      (str n))))\n                  (conj old n)))))", "problem": 86, "user": "4f1bb9d8535d64f60314647d"}, {"code": "(fn [n]\n  (let [sqs (fn [x] (apply + (map (comp #(* % %) read-string str) (str x))))]\n    (->> [[] n]\n      (iterate (fn [[a x]]\n                 (cond (= x 1) true\n                   (some (partial = x) a) false\n                   :else [(conj a x) (sqs x)])))\n      (drop-while vector?)\n      (first))))", "problem": 86, "user": "4fd96694e4b05e33b9224f37"}, {"code": "(fn [x]\n    (= 1.0\n      (last\n        (take 100\n        (iterate\n          (fn sq2 [n]\n            (apply +\n              (map #(int (Math/pow (- (int %) 48) 2))\n              (seq (str n)))))\n          x))))\n)", "problem": 86, "user": "4fa67030e4b081705acca1b7"}, {"code": "(fn [n]\n  (loop [num n, s #{}]\n    (cond\n      (= num 1) true\n      (contains? s num) false\n      :else\n        (recur\n          (let [digits (map #(- (int %) 48) (str num))]\n            (reduce + (map #(* % %) digits)))\n          (conj s num)))))", "problem": 86, "user": "4fb12b35e4b081705acca275"}, {"code": "(fn [n]\n  (loop [n n acc #{}]\n    (cond\n      (= n 1) true\n      (contains? acc n) false\n      :else (recur (reduce + (map #(* % %)\n                                (map #(Integer. (str %)) (str n)))) (conj acc n)))))", "problem": 86, "user": "4ec3b393535dcc7ae8597d59"}, {"code": "(fn h\n  ([n] (h n #{}))\n  ([n s] (cond (= n 1) true\n         (s n) false\n         :else\n         (let [sqr #(* % %)\n               n2 (int (reduce + (map #(sqr (- (int %) 48)) (str n))))]\n           (h n2 (conj s n))))))", "problem": 86, "user": "4faac363e4b081705acca200"}, {"code": "(fn happy? [n]\n  (let [digits (fn [n]\n                 (loop [ds '() current n]\n                   (if (zero? current)\n                     ds\n                     (recur (cons (mod current 10) ds)\n                            (int (/ current 10))))))\n        square-sum (fn [coll]\n                     (apply + (map #(* % %) coll)))\n        tester (fn [seq]\n                 (loop [seen '() r seq]\n                   (cond\n                    (= 1 (first r)) true\n                    (nil? (some #{(first r)} seen)) (recur (cons (first r) seen) (rest r))\n                    :else false)))]\n    (tester (iterate (comp square-sum digits) n))))", "problem": 86, "user": "4f7431d2e4b044e54cd9a8f7"}, {"code": "(fn [orig]\n   (let [ss (fn [n] (->> n str seq (map str) (map #(Long. %)) (map #(* % %)) (reduce +)))]\n     (loop [n 0 nums (iterate ss orig) hist #{}]\n       (cond\n         (= n 1) true\n         (contains? hist n) false\n         :else (recur (first nums) (drop 1 nums) (conj hist n))))\n           ))", "problem": 86, "user": "4fdec88fe4b05e33b9224f8e"}, {"code": "(fn [n]\n(= 1 (nth (iterate (fn [n] (->> (str n) (map #(Character/digit % 10)) (map #(* % %)) (apply +))) n) 100)))", "problem": 86, "user": "4f465096e4b0d56e7bb92b9a"}, {"code": "(fn happy-number [x]\n  (letfn [ \n   (happy [t tested]\n     (let [ hnr (reduce + (map #(* % %) (map #(Integer/parseInt (str %)) (str t)))) ]   \n       (cond \n         ( = 1 hnr) true\n         (contains? tested hnr) false\n         :else (happy hnr (conj tested x)))))                                                        \n          ]  (happy x [])))", "problem": 86, "user": "4fccdc75e4b0ee37620e186d"}, {"code": "(letfn [(square [n] (* n n))\r\n        (next-hn [n]\r\n          (loop [n n\r\n                 ret 0]\r\n            (if (zero? n)\r\n                ret\r\n              (recur (quot n 10) (+ ret (square (mod n 10)))))))]\r\n  (fn happy? [n]\r\n    (loop [n n\r\n           s #{}]\r\n      (cond\r\n        (== 1 n) true\r\n        (s n) false\r\n        :else (recur (next-hn n) (conj s n))))))", "problem": 86, "user": "4fcc6cb3e4b0ee37620e1861"}, {"code": "#((fn f [a b]\n    (cond\n      (= [1 0] [a b]) true\n      (= [4 0] [a b]) false\n      (zero? a) (f b a)\n      :e (f (quot a 10) \n            (+ b (* (rem a 10) (rem a 10)))))) % 0)", "problem": 86, "user": "4fdd27f3e4b05e33b9224f78"}, {"code": "(fn [n]\n  (letfn [(digits [n]\n            (map #(- (int %) (int \\0)) (str n)))\n          (sumsquares [digits]\n            (reduce + (map #(* % %) digits)))\n          (has-1->true--loops->false [ns]\n            (loop [sofar ()\n                   ns ns]\n              (if (= (first ns) 1)\n                true\n                (if (some #(= % (first ns)) sofar)\n                  false\n                  (recur (conj sofar (first ns))\n                         (rest ns))))))]\n    (has-1->true--loops->false\n     (iterate (comp sumsquares digits) n))))", "problem": 86, "user": "4fea0185e4b0547ebccb2480"}, {"code": "(fn happy-number? [n]\n  (letfn [(digits [n]\n            (map #(- (int %) (int \\0)) (str n)))\n          (sumsquares [digits]\n            (reduce + (map #(* % %) digits)))\n          (has-1?->true--loops?->false [numbers]\n            (loop [seen? #{}\n                   [n & ns] numbers]\n              (cond (= n 1) true\n                    (seen? n) false\n                    :else (recur (conj seen? n) ns))))]\n    (has-1?->true--loops?->false\n     (iterate (comp sumsquares digits) n))))", "problem": 86, "user": "4eecc9ad535d93acb0a668b4"}, {"code": "(fn [n]\n  (loop [i n seen #{}]\n    (cond (= i 1) true\n          (some #(= % i) seen) false\n          true (let [next (apply + (map #(* % %)\n                                        (map #(- (int %) 48) (str i))))]\n                 (recur next (conj seen i))))))", "problem": 86, "user": "4fe8aef4e4b07c9f6fd12c6c"}, {"code": "(fn [n]\r\n  (let [sqs (fn [n]\r\n              (loop [x n acc 0]\r\n                (if (zero? x)\r\n                    acc\r\n                    (let [d (rem x 10)]\r\n                      (recur (quot x 10)\r\n                             (+ acc (* d d)))))))]\r\n    (loop [x n prevs []]\r\n      (if (some #{x} prevs)\r\n          false\r\n          (if (= x 1)\r\n            true\r\n            (recur (sqs x) (conj prevs x)))))))", "problem": 86, "user": "4fb37882e4b081705acca2a0"}, {"code": "(fn [init]\n  (letfn [(happy-seq  [in]\n  (let [digits (map #(Character/digit % 10) (seq (str in)))\n        squares (map #(* % %) digits)\n        sum-of-squares (apply + squares)]\n       (lazy-seq (cons in (happy-seq sum-of-squares)))))]\n    (if (= 1 (some #{1} (into #{} (take 15 (happy-seq init))))) true false)))", "problem": 86, "user": "4faec810e4b081705acca24e"}, {"code": "(fn happy? [n]\n  (letfn [(sumdigitsquares [n]\n             (->> n str seq \n               (map str)\n               (map read-string)\n               (map #(* % %))\n               (reduce +)))]\n   (loop [k n valset #{}]\n        (cond (= k 1) true\n              (contains? valset k) false\n              :else\n              (recur (sumdigitsquares k)\n                     (conj valset k))))))", "problem": 86, "user": "4fe87e56e4b07c9f6fd12c40"}, {"code": "(fn happy-number?\n  [n]\n  (apply\n   distinct?\n   (take-while\n    #(not= 1 %)\n    (reductions\n     (fn [x _] (int (apply + (map #(Math/pow % 2) (map (comp read-string str) (str x))))))\n     n\n     (range)))))", "problem": 86, "user": "4f8bbb27e4b02e764a0a5182"}, {"code": "(fn [start] (= true (some #(= 1 %) (take 100 (iterate (fn [x] (reduce + (map #(let [n (- (int %) 48)] (* n n)) (str x)))) start)))))", "problem": 86, "user": "4feada56e4b0140c20fb9c11"}, {"code": "(fn happy [num]\n  (loop [num num, nums #{num}]\n    (let [\n      digits (map #(Integer/parseInt (str %)) (str num))\n      newNum (apply + (map #(* % %) digits))]\n      (cond\n        (= 1 newNum) true\n        (nums newNum) false\n        :else (recur newNum (conj nums newNum))))))", "problem": 86, "user": "4fe8b6afe4b07c9f6fd12c76"}, {"code": "(fn [x]\n  (loop [x x xs #{}]\n    (cond (xs x) false\n          (= x 1) true\n          :else (recur\n            (reduce + (map (comp #(* % %) read-string str) (str x)))\n            (conj xs x)))))", "problem": 86, "user": "4f40ccd9e4b0e243712b1fc0"}, {"code": "(fn [n]\n    (loop [seen #{} n n]\n        (let [v (->> n\n                     str vec\n                     (map #(- (int %) 48))\n                     (map #(* % %))\n                     (reduce +))]\n          (cond\n            (= v 1) true\n            (contains? seen v) false\n            :else (recur (conj seen v) v)))))", "problem": 86, "user": "4db016af838c48654951d9b9"}, {"code": "(fn [x]\n  (loop [acc #{}\n         n x]\n    (let [s (re-seq #\"[0-9]\" (str n))\n          square #(* % %)\n          follow (reduce + (map #(-> % Integer/parseInt square) s))]\n      (if (= follow 1)\n        true\n        (if (contains? acc follow)\n          false\n          (recur (conj acc follow) follow))))))", "problem": 86, "user": "4ff9d4e5e4b0678c553fc3b0"}, {"code": "(fn [z] (loop [s #{} k z] (let\r\n [m (apply + (map (fn [x] (#(* % %) (- (int x) 48))) (str k)))]\r\n         (if (= 1 m) true\r\n           (if (contains? s m) false\r\n             (recur (conj s m) m))))))", "problem": 86, "user": "4fca2ef0e4b0ee37620e184e"}, {"code": "(fn [x]\r\n   (loop [num x c 0] \r\n     (let [\r\n           sq (loop [n num l ()] (if (zero? n) (vec l) (recur (int (/ n 10)) (conj l (mod n 10)))))\r\n           sum (reduce + (map #(* % %) sq))]\r\n       (if (or (= sum 1) (= c 20))\r\n         (= sum 1)\r\n         (recur sum (inc c)))))\r\n   )", "problem": 86, "user": "4ff07688e4b0678c553fc324"}, {"code": "(fn [n] \n  (->> \n    (take-while\n      (fn [[_ f & l]]\n        (not (or (= f 1)\n                 (some #(= f %) l))))\n      (iterate\n        (fn [l] \n          (->> (first l)\n            str\n            (map #(Integer/parseInt (str %)))\n            (reduce #(+ %1 (* %2 %2)) 0)\n            (#(cons % l))))\n        (list n)))\n    last\n    first\n    (= 1)))", "problem": 86, "user": "4ff5744ae4b0678c553fc36a"}, {"code": "(fn [num]\r\n    (letfn [(sum-of-squares \r\n              [x]\r\n              (reduce + (map #(* % %) (map #(Integer. %) (re-seq #\"\\d\" (str x))))))]\r\n      (let [bla (iterate #(cons (sum-of-squares (first %)) %) (cons num '()))]\r\n        (= 1 (first (first (drop-while #(= (count %) (count (distinct %))) bla))))\r\n        )))", "problem": 86, "user": "4f410b63e4b0e243712b1fc5"}, {"code": "(fn [n] ((fn [n h] (let [\n    c (map #(Integer/valueOf (str %)) (str n))\n    i (drop-while #{0} (sort c))\n    ] (or (= 1 n) (if (h i) false\n    (recur (reduce #(+ % (* %2 %2)) 0 i) (conj h i))))\n)) n #{}))", "problem": 86, "user": "4ef48422535dced4c769f236"}, {"code": "(fn f\r\n  ([n] (f n #{}))\r\n  ([n c]\r\n    (cond (= 1 n) true\r\n          (c n) false\r\n          :else\r\n          (f (reduce #(+ % (* %2 %2)) 0\r\n            (map (comp read-string str)\r\n                            (str n)))\r\n             (conj c n)))))", "problem": 86, "user": "4ff304f4e4b0678c553fc343"}, {"code": "(fn happy? [number]\n  (let [digit #({\\0 0, \\1 1, \\2 2, \\3 3, \\4 4, \\5 5, \\6 6, \\7 7, \\8 8, \\9 9} %)\n        digits (fn [n] (map digit (str n)))\n        square #(* % %)\n        ssd (fn [n] (int (reduce + (map square (digits n)))))]\n    (loop [n (ssd number) prev #{}]      \n      (cond\n        (= n 1) true\n        (contains? prev n) false\n        :else (recur (ssd n) (conj prev n))))))", "problem": 86, "user": "5003deb9e4b0678c553fc445"}, {"code": "(fn [n]\n  (= 1 ((fn [s n]\n     (let [i (fn [n] (reduce #(+ % (* %2 %2)) 0 (map #(- (int %) (int \\0)) (str n))))]\n          (if (contains? s n)\n            n\n            (recur (conj s n) (i n))))) #{} n)))", "problem": 86, "user": "4f05ea25535dcb61093f6c02"}, {"code": "(fn happy? [f n]\n  (loop [i n]\n    (condp = i\n      1 true\n      4 false\n      i (recur (f i)))))\n\n(fn [i]\n  (apply + (map #(let [x (read-string (str %))] (* x x)) (str i))))", "problem": 86, "user": "500933a6e4b046cdb195e074"}, {"code": "(fn [input]\n  (let [c (zipmap \"0123456789\" [0 1 4 9 16 25 36 49 64 81])\n  calc (fn [v] (reduce + 0 (map c (str v))))]\n    (loop [s #{} input input]\n      (let [v (calc input)]\n\t(cond\n\t  (= v 1) true\n\t  (contains? s v) false\n\t  :else (recur (conj s v) v))))))", "problem": 86, "user": "4fd7962ee4b0dab7d829f385"}, {"code": "(letfn\n  [(to-int [char] (- (int char) (int \\0)))\n   (square-digit [char] (let [digit (to-int char)] (* digit digit)))\n   (sum-sq-digits [n] (reduce + 0 (map square-digit (str n))))]\n  (fn happy?\n    ([n] (happy? n #{}))\n    ; \"s\" is a set of numbers which have already been seen\n    ([n s]\n      (let [sum (sum-sq-digits n)]\n        (if (contains? s sum) false\n          (if (= 1 sum) true\n            (happy? sum (conj s sum))))))))", "problem": 86, "user": "5002b6e5e4b0678c553fc42c"}, {"code": "(fn [n]\n  (loop [n n\n         s #{}]\n    (let [x (apply + (map #(let [i (- (int %) (int \\0))] (* i i)) (str n)))]\n      (cond (= x 1) true\n            (s x) false\n            :else (recur x (conj s x))))))", "problem": 86, "user": "500d8c49e4b07ccb9a7ddb00"}, {"code": "(fn [n]\n  (let [nxt (fn [n]\n              (reduce \n                #(let [n (Integer. (str %2))] (+ %1 (* n n)))\n                0\n                (str n)))]\n    (loop [c [] nn n]\n      (cond\n        (= nn 1) true\n        (some #(= nn %) c) false\n        :else (recur (conj c nn) (nxt nn))))))", "problem": 86, "user": "5003ee7de4b0678c553fc446"}, {"code": "(fn happy-number? [n]\n  (letfn [(string-to-digits [s] (map #(read-string (str %)) (str s)))\n          (happy-num? [n seen-before]\n            (let [string-number (if (string? n)\n                                  n\n                                  (str n))\n                  numeric (read-string string-number)\n                  squares (map #(* % %) (string-to-digits string-number))]\n              (if (= numeric 1)\n                true\n                (if (some #(= numeric %) seen-before)\n                  false\n                  (recur (reduce + squares) (cons numeric seen-before))))))]\n    (happy-num? n [])))", "problem": 86, "user": "4ff355a1e4b0678c553fc34d"}, {"code": "(fn happy-number?\n  [n]\n  (letfn [(step [seen n]\n            (let [digits (map #(Character/getNumericValue %) (str n))\n                  squared (map (comp int #(Math/pow % 2)) digits)\n                  summed (apply + squared)]\n              (cond (= 1 summed) true\n                    (seen summed) false\n                    :else (recur (conj seen summed) summed))))]\n    (step #{} n)))", "problem": 86, "user": "4dc0ff08535d020aff1edf84"}, {"code": "(fn [n]\r\n (loop [n n acc #{}]\r\n  (let [digits (fn [a]\r\n           (loop [a a acc []]\r\n             (if (zero? a) \r\n               acc\r\n               (recur (quot a 10) (cons (rem a 10) acc)))))\r\n        s (reduce + (map #(* % %) (digits n)))]\r\n    (if (= 1 s) \r\n      true\r\n      (if (acc s)\r\n          false\r\n          (recur s (conj acc s)))))))", "problem": 86, "user": "4fdb02aae4b05e33b9224f56"}, {"code": "(fn [n]\n  (loop [seen #{}, i n]\n    (if (seen i)\n      false\n      (let [digits (map #(- (int %) (int \\0)) (str i))\n            squared-digit-sum (apply + (map #(* % %) digits))]\n        (if (= squared-digit-sum 1)\n          true\n          (recur (conj seen i) squared-digit-sum))))))", "problem": 86, "user": "500ff421e4b0ae202717946f"}, {"code": "(fn happy [v]\n     (letfn [(sumnum [x]\n               (loop [xx x\n                     accumulator 0]\n               (println \"xx is \" xx \"and accumulator is\" accumulator)\n                (if (< xx 1)\n                  accumulator\n                  (recur (unchecked-divide-int xx 10)\n                         (+ accumulator\n                            (* (unchecked-remainder-int xx 10)\n                            (unchecked-remainder-int xx 10)))))))]\n\n       (loop [cur v\n              history #{}]\n         (println \"Cur is \" cur \"and history is \" history)\n         (cond (= cur 1) true\n               (contains? history cur) false\n         :else\n               (recur (sumnum cur)\n                      (conj history cur))))))", "problem": 86, "user": "50057f23e4b0678c553fc466"}, {"code": "(fn [z] (= 1 (->\r\n  (filter #(not (apply distinct? %))\r\n    (for [i (iterate inc 2)] (take i (iterate\r\n      (fn [x]\r\n        (apply + (map #(* % %) (map #(- (int %) (int \\0)) (str x)))))\r\n      z)))) first last)))", "problem": 86, "user": "500d1db4e4b05f7c30cfa69f"}, {"code": "(partial (fn [s n] (cond (= 1 n) true (s n) false\r\n          :else (let [ds (map (comp read-string str) (seq (str n)))]\r\n                  (println n ds)\r\n                  (recur (conj s n) (reduce + (map #(* % %) ds))))))\r\n#{})", "problem": 86, "user": "4fe900a6e4b0547ebccb243a"}, {"code": "(fn [n]\n   (letfn [(digits\n            ([n s] ;;Copied from above, recursive, init with s\n               (if (= n 0) s\n                   (recur (int (/ n 10)) (conj s (rem n 10)))))\n            ([n]\n               (digits n '())))\n           (next [n]\n                 (reduce + (map #(* % %) (digits n))))]\n     (= 1 (first (drop-while #(not (= 1 %)) (take 100000 (iterate next n)))))\n      ))", "problem": 86, "user": "500ea957e4b00fff93030f9b"}, {"code": "(fn happy? [x]\n  (loop [x x\n         acc #{}]\n        (let [new (reduce + \n                          (map #(let [d (read-string (str %))] (* d d)) \n                          (str x)))]\n          (or (= new 1)\n              (and (not (contains? acc new))\n                   (recur new (conj acc new)))))))", "problem": 86, "user": "500900dee4b0144d4f561e42"}, {"code": "(fn [x]\r\n   (loop [a x tries 0]\r\n     (cond\r\n       (> tries 100) false\r\n       (= a 1) true\r\n       :else\r\n       (recur (reduce + \r\n                      (map \r\n                        #(* (Character/getNumericValue %) \r\n                            (Character/getNumericValue %)) \r\n                        (str a)))\r\n              (inc tries)))))", "problem": 86, "user": "4fd8544be4b0dab7d829f390"}, {"code": "(fn [n]\n  (if (= n 1)\n    true\n    (if (= n 4)\n      false\n      (recur (reduce + (map #(* % %) (map read-string (map str (re-seq #\"[0-9]\" (str n))))))))))", "problem": 86, "user": "4fdf2b50e4b05e33b9224f93"}, {"code": "(fn [n]\n     (letfn [\n       (digits [x] \n         (map #(read-string (str %)) (seq (str x))))\n       (nextNumber [x]\n         (reduce #(+ %1 (* %2 %2)) 0 (digits x)))\n       ]\n       ((fn rec [x res] \n         (cond \n           (= x 1) true\n           (contains? res x) false\n           :else (recur (nextNumber x) (conj res x))\n         )\n       ) n #{})))", "problem": 86, "user": "4fcf5292e4b03432b189f40e"}, {"code": "(fn [n]\n  (let [get-digits (fn [n b]\n\t\t\t\t\t\t\t\t\t\t  (if (zero? n)\n\t\t\t\t\t\t\t\t\t\t      (list n)\n\t\t\t\t\t\t\t\t\t\t      ((fn [n b r]\n\t\t\t\t\t\t\t\t\t\t    \t\t(if (zero? n)\n\t\t\t\t\t\t\t\t\t\t    \t\t\t\tr\n\t\t\t\t\t\t\t\t\t\t    \t\t\t\t(recur (quot n b) b (conj r (rem n b))))) n b nil)))\n\t\t\t\tsquare-sum (fn [coll]\n\t\t\t\t\t\t\t\t\t\t\t(reduce #(+ %1 (* %2 %2)) 0 coll))\n\t\t\t\tcalc (fn [n] (square-sum (get-digits n 10)))]\n\t\t((fn [n calculated]\n\t\t\t\t(cond \n\t\t\t\t\t(= 1 n) true\n\t\t\t\t\t(contains? calculated (calc n)) false\n\t\t\t\t\t:else (recur (calc n) (conj calculated (calc n))))) n #{})))", "problem": 86, "user": "501c1492e4b086d93747d180"}, {"code": "(fn happy\n  ([n] (happy n #{}))\n  ([n s]\n     (let [sum (apply +\n                      (map #(* % %) (map #(Integer/parseInt (str %)) (str n))))]\n       (cond (= sum 1) true\n             (contains? s sum) false\n             :else (happy sum (conj s n))))))", "problem": 86, "user": "500cb910e4b05f7c30cfa698"}, {"code": "(fn [m]\n  (loop [n m rec []]\n    (if (= 1 n)\n      true\n      (if (some #(= % n) rec)\n        false\n        (recur (->>\n                 (str n)\n                 (re-seq #\"\\d\")\n                 (map #(Integer/parseInt (str %)))\n                 (map #(* % %))\n                 (reduce +)) (cons n rec))))))", "problem": 86, "user": "4f9f7daae4b0dcca54ed6d37"}, {"code": "(fn h [x]\r\n  (let [dig (fn nd [n]\r\n          (if (zero? n)\r\n            []\r\n            (conj (nd (quot n 10) ) (rem n 10)))\r\n          )]\r\n\r\n    (loop [n x s #{x}]\r\n     \r\n      (let [ xx (reduce + (map #(* % %) (dig n)))]\r\n         (println s xx)\r\n        (if (= xx 1)\r\n          true\r\n          (if (contains? s xx)\r\n            false\r\n            (recur xx (conj s xx) )\r\n            )\r\n          )\r\n        )\r\n      )\r\n    )\r\n  )", "problem": 86, "user": "4febb4dae4b0681fd128dc98"}, {"code": "(fn [n]\n  (loop [n n seen #{}]\n    (cond\n      (= 1 n) true\n      (seen n) false\n      :else (recur (reduce + (map (comp #(* % %) #(Character/digit % 10)) (str n)))\n        (conj seen n)))))", "problem": 86, "user": "4fcf642ee4b03432b189f410"}, {"code": "(fn __ [x]\n  (let [digits  (fn [n] (map #(Character/digit % 10) (str n)))\n        sq-sum (reduce + (map #(* % %) (digits x)))]\n    (if (= 1 (count (digits sq-sum))) \n      (= 1 sq-sum) (__ sq-sum))))", "problem": 86, "user": "4ec9549d535d6d7199dd36fe"}, {"code": "(fn [n] \n  (loop [n n seen #{}] \n    (cond \n      (= 1 n) true\n      (seen n) false\n      :else (recur \n              (reduce + (map #(-> % str read-string (Math/pow 2) int) (str n))) \n              (conj seen n)))))", "problem": 86, "user": "500aa15ee4b03d00572d2d76"}, {"code": "(fn [n]\n  (= 1 (last\n         (take 7\n           (iterate\n             (fn [n]\n               (apply +\n                 (map #(* % %)\n                   (map #(Character/digit % 10)\n                     (str n)))))\n             n)))))", "problem": 86, "user": "4f4e7c01e4b03ad3f0c10cc9"}, {"code": "(fn [n] (== 1 ((fn [n]\r\n  (if (and (< n 10) (< (* n n) 10))\r\n    n\r\n    (recur (reduce + (map #(* (Integer/parseInt (str %)) (Integer/parseInt (str %))) (seq (str n)))))) ) n)))", "problem": 86, "user": "5028bce0e4b01614d1633ffb"}, {"code": "(fn [n]\n  (letfn [(sum2 [n] (reduce + (map #(* % %) (map (comp read-string str) (str n)))))]\n    (loop [hist #{}\n           res (sum2 n)]\n      (if (= hist (conj hist res))\n        (== 1 (apply min hist))\n        (recur (conj hist res) (sum2 res))))))", "problem": 86, "user": "5028cd0fe4b01614d1633ffc"}, {"code": "(fn happy [n]\n  (let [to-digits (fn [k] (-> k (str) (seq) (#(map (fn [i] (- (int i) (int \\0))) %)))),\n        combine (fn [dgs] (reduce #(+ % (* %2 %2)) 0 dgs))\n        create-seq (fn cr [dgs] (let [nxt (combine dgs)]\n                                   (cons nxt (lazy-seq (cr (to-digits nxt)))))) \n        seen (ref #{})\n        check-and-add (fn [i, st] (if (contains? @st i) true\n                                      (do (dosync (ref-set st (clojure.set/union #{i} @st)))\n                                           false)))]\n          (= 1 (first (drop-while #(not (or (= 1 %) (check-and-add % seen)))\n           (create-seq (to-digits n)))))))", "problem": 86, "user": "502a5fa4e4b09e8f859a9fbd"}, {"code": "(fn [n]\r\n  (let [newnr (fn [n] (apply + (map #(* % %) (map #(Integer. (str %)) (str n)))))]\r\n    (loop [l [] n n]\r\n      (if (= 1 n)\r\n        true\r\n        (if (contains? l n)\r\n          false\r\n          (recur (conj l n) (newnr n)))))))", "problem": 86, "user": "4e6e2ac4535d5021c1a895ff"}, {"code": "(fn [x]\n  (let \n    [digits (fn [n] (reduce\n        #(conj %1 (Integer/parseInt (str %2))) [] (str n)))\n     happy (fn [n] (reduce + (map #(* %1 %1) (digits n))))\n     helper (fn [n seen]\n       (let \n         [hnum (happy n)]\n        (cond \n          (contains? seen hnum) false\n          (= 1 hnum) true\n          :else (recur hnum (conj seen hnum)))))]\n  (helper x #{})))", "problem": 86, "user": "5027fc0ce4b01614d1633ff2"}, {"code": "(fn [i]\n(loop [n i\n       prev #{}]\n  (cond\n    (= n 1) true\n    (contains? prev n) false\n    :else\n      (recur\n        (apply +\n          (map #(* % %)\n            (map #(- (int %) 48) (str n))))\n        (conj prev n)))))", "problem": 86, "user": "50361b6be4b0fbe0a74d26be"}, {"code": "(fn [h] (\n  (fn [x xs] \n  (let [newx ((fn [n acc] (if (= n 0) acc (recur (long (/ n 10)) (+ (#(* %1 %1) (rem n 10)) acc)))) x 0)]\n\t(println newx)\n\t(if (= newx 1)\n\t\ttrue\n\t\t(if (some #{newx} xs) false\n\t\t(recur newx (cons x xs)))))) h []))", "problem": 86, "user": "4eb8ec4a535dfed6da9c6d4b"}, {"code": "#(loop [n % s #{}]\r\n  (cond (s n) false, (= 1 n) true, :else\r\n    (recur\r\n      (loop [p n v 0]\r\n        (if (zero? p) v\r\n          (let [m (mod p 10)]\r\n            (recur (quot p 10) (+ v (* m m))))))\r\n      (conj s n))))", "problem": 86, "user": "50336c6be4b0c6c1199c710f"}, {"code": "(fn [n]\n  (let [ss (fn [num] (->> num str seq (map #(- (int %) 48)) (map #(* % %)) (reduce +)))]\n    (= 1 (some #{1} (take 10 (iterate ss n))))))", "problem": 86, "user": "5033a1fbe4b062bc5d7ae155"}, {"code": "(fn happy?-\n  ^{:doc \"86. Write a function that determines if a number is happy or not.\"}\n  ([n] (happy?- n #{}))\n  ([n tried]\n     (and\n      (not (tried n))\n      (or (= 1 n)\n          (letfn [(digits [n] (if (< n 10) [n] (conj (digits (quot n 10)) (rem n 10))))\n                  (sum-of-squares-of-digits [n] (->> (digits n) (map #(* % %)) (reduce +)))]\n            (recur (sum-of-squares-of-digits n) (conj tried n)))))))", "problem": 86, "user": "4e5eb843535d8a8b8723a2d4"}, {"code": "#(< 5 %)", "problem": 86, "user": "502a9fdee4b095a7adb898b4"}, {"code": "(fn [n]\n  (loop [n n seen #{}]\n    (if (= n 1)\n      true\n      (if (seen n)\n        false\n        (recur\n          (reduce +\n            (map\n              (fn [d]\n                (let [x (Integer. (str d))]\n                  (* x x)))\n              (str n)))\n          (conj seen n))))))", "problem": 86, "user": "50435852e4b034ff00315d22"}, {"code": "(fn happy? [n]\n  (letfn [(digits0 [x b]\n            (loop [x x, d '()]\n              (if (zero? x) (cons 0 d)\n                  (recur (int (/ x b))\n                         (cons (mod x b) d)))))]\n    (loop [n n, seen #{}]\n      (cond (= n 1)  true\n            (seen n) false\n            :else    (recur (reduce + (map #(* % %) (digits0 n 10))) (conj seen n))))))", "problem": 86, "user": "4e8338d6535db62dc21a62d3"}, {"code": "(fn [n]\n          (let [f (fn [n]  (reduce #(+ % (* (- (int %2) 48) (- (int %2) 48))) 0 (str n)))\n                h (fn h [n s]\n                    (let [a (= 1 n) b (s n)]\n                      (if a\n                        a\n                        (if b\n                          (not b)\n                          (h (f n) (conj s n))))))]\n            (h n #{})))", "problem": 86, "user": "503b6995e4b07a1917cc34dd"}, {"code": "(fn [n]\r\n   (loop [t n a {}]\r\n     (cond\r\n      (= 1 t) true\r\n      (contains? a t) false\r\n      true\r\n      (let [new (apply + (map #(* % %) (map #(- (int %) (int \\0)) (str t))))]\r\n        (recur new (assoc a t 1))))))", "problem": 86, "user": "4e9609ad535dbda64a6f6b3e"}, {"code": "#((fn [s n]\n    (letfn [(f [n] \n              (if (< n 10) \n                (* n n) \n                (+ (f (int (/ n 10))) \n                (let [x (mod n 10)]\n                  (* x x)))))]\n    (if (= 1 n) true\n      (if (s n) false\n        (recur (conj s n) (f n)))))) #{} %)", "problem": 86, "user": "502904e0e4b0feaf66e22fad"}, {"code": "(fn happy? [n]\n  (letfn [(digits [n]\n            (map #(Integer/parseInt (str %)) (str n)))\n          (sum-of-squares [n]\n            (reduce + (map #(* % %) (digits n))))]\n    (boolean (some #{1} (take 100 (iterate sum-of-squares n))))))", "problem": 86, "user": "5032b066e4b00c0952a257ea"}, {"code": "(fn [n]\n    (loop [rs #{}, r n]\n      (let [p #(* % %)\n            r (apply + (map #(-> % int (- 48) p) (str r)))]\n        (cond (= r 1) true\n              (rs r) false\n              :else (recur (conj rs r) r)))))", "problem": 86, "user": "4f58d92fe4b0a7574ea71858"}, {"code": "(fn __ [n]\n  (loop [n n visited #{}]\n    (cond\n      (contains? visited n) false\n      (= 1 n) true\n      :else\n  \t(recur\n          (reduce + (map\n                     #(* (Integer/parseInt %) (Integer/parseInt %))\n                 \t (re-seq #\"[0-9]\" (str n))))\n          (conj visited n)))))", "problem": 86, "user": "4fa719c0e4b081705acca1bf"}, {"code": "(let [f (fn [n] (->> (str n)\n     (map #(- (int %) (int \\0)))\n     (map #(* % %))\n     (apply +)\n     ))]\n      \n#(loop [n % v #{}]\n   (println n v)\n   (cond (= n 1) true\n         (v n) false\n     :else (recur (f n) (conj v n)))))", "problem": 86, "user": "503917a0e4b088a6a14ca763"}, {"code": "(fn [n]\r\n  (->> (iterate\r\n         (fn [x]\r\n           (->> (iterate #(* 10 %) 1)\r\n             (map #(quot x %))\r\n             (take-while #(> % 0))\r\n             (map #(rem % 10))\r\n             (map #(* % %))\r\n             (apply +)))\r\n         n)\r\n    (reductions\r\n      (fn [acc x]\r\n        (cond\r\n          (== 1 x) true\r\n          (acc x) false\r\n         :else (conj acc x)))\r\n      #{})\r\n    (drop-while coll?)\r\n    first))", "problem": 86, "user": "50479524e4b0371827a27bc4"}, {"code": "(fn [x] (not= nil (some (fn [x] (= x 1))\r\n   (take 100\r\n         (iterate #(apply + (for [y (str %)] (let [c (- (int y) 48)] (* c c)))) x)))))", "problem": 86, "user": "503354c3e4b0c6c1199c710c"}, {"code": "(fn [n]\n  (letfn [(happy-seq [n]\n            (let [n' (map #(Character/getNumericValue %) (str n))\n                  n'' (map #(* % %) n')\n                  s (reduce + n'')]\n              (lazy-seq\n                (cons n (happy-seq s)))))\n          (is-happy-number? [ns hs]\n            (if (= 1 (first hs))\n              true\n              (if (contains? ns (first hs))\n                false\n                (recur (conj ns (first hs)) (rest hs)))))]\n    (is-happy-number? #{} (happy-seq n))))", "problem": 86, "user": "504e13fce4b078edc5f593bc"}, {"code": "(fn [x]\n  (loop [handled #{x} n x]\n    (let [res (->> (.toString n)\n                   (map #(Integer/parseInt (str %)))\n                   (map #(* % %))\n                   (apply +))]\n      (cond (= res 1) true\n            (handled res) false\n            :else     (recur (conj handled res) res)))))", "problem": 86, "user": "5012ec0ae4b0c87326002230"}, {"code": "(fn [val]\n  (letfn [(digits [n]\n            (let [radix 10]\n              (reverse\n               (map\n                #(int (rem % radix))\n                (take-while (complement zero?)\n                            (iterate #(quot % radix)\n                                     n))))))\n          (happy? [n seen]\n            (cond (= 1 n) true\n                  (contains? seen n) false\n                  :else (recur\n                         (reduce +\n                                 (map #(* % %)\n                                      (digits n)))\n                         (conj seen n))))]\n    (happy? val #{})))", "problem": 86, "user": "5014754de4b094324338f8e5"}, {"code": "(fn ishappy\n  ([num] (ishappy num #{}))\n\t([num seen]\n\t\t(letfn  [\n\t\t(digits [num]\n\t\t\t(map #(Character/digit % 10) (str num)))\n\t\t(nextnum [num]\n\t\t\t\t(reduce + (map #(* % %) (digits num))))]\n\t\t(if (= 1 num) true\n\t\t(if (contains? seen num) false\n\t\t(ishappy (nextnum num) (conj seen num)))))))", "problem": 86, "user": "4ea0c284535d7eef308072ad"}, {"code": "(fn [x]\n  (let [ss (fn [x]\n             (apply +\n               (map #(int (Math/pow (Integer/parseInt (str %)) 2)) (seq (str x)))))]\n  (loop [y x\n         xs #{}]\n    (if (contains? xs y)\n        (= 1 y)\n        (recur (ss y) (conj xs y))))))", "problem": 86, "user": "504e04a4e4b078edc5f59397"}, {"code": "(fn [n]\n  (letfn [(square [x] (* x x))\n          (digits [x]\n            (->> x str (map #(-> % str read-string))))\n          (sum-of-squares [x]\n            (->> x digits (map square) (reduce +)))]\n    (loop [n    n\n           seen #{}]\n      (cond (= n 1)  true\n            (seen n) false\n            :else    (recur (sum-of-squares n)\n                            (conj seen n))))))", "problem": 86, "user": "50586354e4b06522596eba78"}, {"code": "(fn happy?\n    ([num] (happy? num #{}))\n    ([num priors]\n       (println num priors)\n       (let [digits (fn [n out]\n                     (if (= n 0)\n                       out\n                       (let [d (rem n 10)\n                             r (quot n 10)]\n                         (recur r (cons d out)))))\n             result (apply + (map #(* % %) (digits num '())))]\n         (if (= result 1)\n           true\n           (if (priors result)\n             false\n             (happy? result (conj priors num)))))))", "problem": 86, "user": "4dbb0f2d535d1e037afb21b1"}, {"code": "(fn [n]\n  (letfn [\n    (digs\n  [n]\n  (->>\n   (str n)\n   (map (comp read-string str))))\n    (step\n  [n]\n  (->>\n   (digs n)\n   (map #(* % %))\n   (apply +)))\n    (loop-set\n  [num]\n  (loop [s #{}\n         n num]\n    (if (contains? s n)\n      s\n      (recur (conj s n) (step n)))))]\n(contains? (loop-set n) 1)))", "problem": 86, "user": "50427899e4b0add3005c0fc2"}, {"code": "(fn [start] (letfn [ (digits [n]  (map #(- (int %) (int \\0)) (str n)))\r\n                             (sum-of-squares [coll] (reduce + (map #(* % %) coll)))]\r\n                      (= 1 (some #{1 4} (iterate (comp sum-of-squares digits) start)))))", "problem": 86, "user": "503d129fe4b06c4e0e1fa254"}, {"code": "(fn happy? ([n] (happy? (sorted-set) n))\n([seen n]\n  (let [n2\n    (apply +\n      (map (comp #(* % %) read-string str) (str n)))]\n\n  (cond \n    (seen n) false\n    (= n2 1) true\n:else (recur (conj seen n) n2)))))", "problem": 86, "user": "4fca2a13e4b0ee37620e184d"}, {"code": "(fn happy? ([n] (happy? n #{}))\r\n  ([n acc]\r\n    (let [c2i (zipmap \"0123456789\" (range))\r\n      val (->> n\r\n        str\r\n        (map c2i)\r\n        (map #(* % %))\r\n        (reduce +))]\r\n    (cond\r\n      (= 1 val) true\r\n      (acc val) false\r\n      :else (recur val (conj acc val))))))", "problem": 86, "user": "504e14c2e4b078edc5f593bf"}, {"code": "(fn [x]\n  (let [next-num (fn [x]\n                     (->> x\n                          (str)\n                          (re-seq #\".\")\n                          (map #(Integer/parseInt %))\n                          (map #(* % %))\n                          (reduce +)))]\n      (loop [coll (iterate next-num x)\n             detector #{}]\n        (cond (= 1 (first coll)) true\n              (contains? detector (first coll)) false\n              :else (recur (rest coll) (conj detector (first coll)))))))", "problem": 86, "user": "4ee6400c535d93acb0a6685b"}, {"code": "(fn h [r n] (let [n (apply + (map (fn [a] ((fn [b] (* b b)) (- (int a) 48))) (str n)))] (or (= n 1) (and (nil? (r n)) (h (conj r n) n))))) #{}", "problem": 86, "user": "4f045946535dcb61093f6bba"}, {"code": "(fn [n]\n  (letfn [(dsum [n] (reduce + (map #(* % %) (map #(- (int %) 48) (str n)))))]\n    (loop [n n d #{}]\n      (cond\n       (= n 1) true\n       (contains? d n) false\n       :else (recur (dsum n) (conj d n))))))", "problem": 86, "user": "504f865ee4b0a02f9cffde90"}, {"code": "(fn [n]\n    (let [digits (fn digits [n]\n                   (if (= 0 (quot n 10))\n                     (list n)\n                     (conj (digits (quot n 10)) (rem n 10))))\n          step (fn [m] (apply + (map #(* % %) (digits m))))\n          find-dup (fn find-dup ( [xs] (find-dup xs #{}))\n                     ([ [x & xs] acc] (if (acc x) x (recur xs (conj acc x)))))]\n      (= 1 (find-dup (iterate step n)))))", "problem": 86, "user": "50563ae2e4b0ce54f56f0405"}, {"code": "(fn [n]\n  (letfn [(square [n] (* n n))\n          (char->int [c] (- (int c) 48))\n          (update [n] (apply + (map (comp square char->int) (str n))))]\n    (= 1 (some #{1 4} (iterate update n)))))", "problem": 86, "user": "4fe84c74e4b07c9f6fd12c3c"}, {"code": "(fn [x]\n  (letfn [(to-digits [n]\n            (for [d (iterate #(* 10 %) 1) :while (<= d n)]\n              (mod (int (/ n d)) 10)))\n            (solve [n visited]\n              (let [newNum (reduce + (map #(* % %) (to-digits n)))]\n            \t\t(cond\n            \t\t\t(= 1 newNum) true\n            \t\t\t(contains? visited newNum) false\n            \t\t\t:else (recur newNum (conj visited newNum))\n           )))]\n\t(solve x #{x})\n))", "problem": 86, "user": "504e685fe4b0f6ff3350c4ae"}, {"code": "#((fn [history num]\n  (let [nn (apply + (map (fn [a] (* a a)) \n    (map (fn [s] (java.lang.Integer/parseInt (str s))) (str num))))]\n    (cond (= 1 nn) true\n          (history nn) false\n          :else (recur (conj history nn) nn))))\n  #{} %)", "problem": 86, "user": "5063fe48e4b075d771da6f9e"}, {"code": "(fn [n]\n  (= 1 ((fn [s n]\n          (let [i (fn [n] (reduce #(+ % (* %2 %2)) 0 (map #(- (int %) (int \\0)) (str n))))]\n            (if (contains? s n)\n              n\n              (recur (conj s n) (i n))))) #{} n)))", "problem": 86, "user": "50705072e4b07bd6ad9b9f27"}, {"code": "(fn happy [x]\n  (letfn [(happyiter [y]\n    (loop [y y sum 0]\n      (let [r (rem y 10) q (quot y 10)]\n        (if (zero? q) \n            (+ sum (* r r))\n            (recur q (+ sum (* r r)))\n        )\n      )\n    )\n    )]\n  (loop [x x sofar '[]]\n    (cond (= x 1) true\n          (some #{x} sofar) false\n          :else (recur (happyiter x) (conj sofar x))\n    )\n   )\n  )\n)", "problem": 86, "user": "50588af1e4b06522596eba7d"}, {"code": "(fn [acc n]\n  (if (> acc 10) false\n    (let [s (#(reduce +\n                (for [c (seq (str %))\n                      :let [n (- (int c) 48)]]\n                  (* n n))) n)]\n      (if (= 1 s) true\n        (recur (inc acc) s))))) 0", "problem": 86, "user": "50464831e4b011c5dfee771f"}, {"code": "(fn [n]\n  (= (last\n      (take 1000\n            (iterate (fn [x]\n                       (apply + (map (comp #(* % %) read-string str) (str x))))\n                     n)))\n     1))", "problem": 86, "user": "507056b8e4b07bd6ad9b9f29"}, {"code": "(fn f [h n]\n  (let [ss (reduce + (map (fn [x] (-> x str read-string (#(* % %)))) (str n)))]\n    (cond \n      (= n 1) true\n      (h ss) false\n      :else (f (conj h ss) ss))))\n#{}", "problem": 86, "user": "5054c7e1e4b0b1b9d1860eb2"}, {"code": "(fn [n]\n  (let [f (fn [num]\n    (loop [t num ret []]\n      (if (= t 0 ) ret\n        (recur (quot t 10) (cons (rem t 10) ret)))))]\n    (loop [x n s #{}]\n      (let [next (reduce + (map #(* % %) (f x)))]\n        (cond\n          (s next)   false\n          (= next 1) true\n          :else      (recur next (conj s next)))))))", "problem": 86, "user": "4fd2e5d8e4b04c3a95aa0427"}, {"code": "(fn happy \n  ([nb] (happy nb #{}))\n  ([nb res]\n    (let \n      [r (int (reduce + \n        (map #(Math/pow (- (int %) 48) 2) (seq (str nb)))))]\n      (if (= 1 r)\n        true\n        (if (contains? res r)\n          false\n          (happy r (conj res r)))))))", "problem": 86, "user": "5034b0e1e4b062bc5d7ae167"}, {"code": "(fn happyNumber? [x]\r\n  (letfn [(happyNumber [x]\r\n            (let [seq (map #(Character/digit % 10) (str x))]\r\n              (reduce #( + % (* %2 %2)) 0 seq)))\r\n          ]\r\n    (cond (= 1 x) true\r\n          (= 4 x) false\r\n          :else (happyNumber? (happyNumber x)))))", "problem": 86, "user": "4fb23582e4b081705acca28a"}, {"code": "(fn a \n   ([n] (a #{} n))\n\n   ([res n]\n     (cond\n       \n       (= 1 n) true\n       \n       (contains? res n) false\n       \n       :default (recur \n                  (conj res n)\n                  (reduce +\n                    (map #(* % %)\n                         (map #(Integer/valueOf (str %)) (str n))))))))", "problem": 86, "user": "4f3e6244e4b0e243712b1f85"}, {"code": "(fn [n]\r\n  (boolean (some #(= 1 %)\r\n  \t (take 20\r\n\t\t       (iterate\r\n\t\t\t(fn [n]\r\n\t\t\t  (reduce + (map #(* % %) ((fn [n l]\r\n\t\t\t\t\t\t     (if (< n 10)\r\n\t\t\t\t\t\t       (cons n l)\r\n\t\t\t\t\t\t       (recur (quot n 10) (cons (mod n 10) l))))\r\n\t\t\t\t\t\t   n nil))))\r\n\t\t\tn)))))", "problem": 86, "user": "507437c2e4b054001656acd0"}, {"code": "(fn [n]\n  (let [cmap (into {} (map-indexed #(vector %2 (* % %)) \"0123456789\"))]\n    (loop [[x & xs] (iterate #(apply +' (map cmap (str %))) n)\n           seen #{}]\n      (cond (= 1 x) true\n            (contains? seen x) false\n            :else (recur xs (conj seen x))))))", "problem": 86, "user": "506a1985e4b01dc6af13f83e"}, {"code": "(fn [n]\n  (loop [n n, nums #{}]\n    (cond\n      (= n 1) true\n      (some #(= n %) (rest nums)) false\n      :else\n        (recur\n          (reduce\n            (fn [acc d]\n              (let [i (read-string d)] (+ acc (* i i))))\n            0\n            (re-seq #\"\\d\" (str n)))\n          (conj nums n)))))", "problem": 86, "user": "504c8165e4b09724c857af31"}, {"code": "(fn [n]\n  (if\n\t\t(integer? n)\n\t\t(let\n\t\t\t\t[n2s (fn [n] (seq (str n))),\n\t\t\t\t c2n (fn [c] ({\\0 0, \\1 1, \\2 2, \\3 3, \\4 4, \\5 5, \\6 6, \\7 7, \\8 8, \\9 9} c)),\n\t\t\t\t to-digits (fn [n] (map c2n (n2s n)))]\n\t\t\t(loop\n\t\t\t\t\t[digits (to-digits n), seen #{}]\n\t\t\t\t(let\n\t\t\t\t\t\t[sum (reduce + (map #(* % %) digits))]\n\t\t\t\t\t(cond\n\t\t\t\t\t\t(= sum 1) true,\n\t\t\t\t\t\t(seen sum) false,\n\t\t\t\t\t\t:else\n\t\t\t\t\t\t\t(recur (to-digits sum), (conj seen sum))))))\n\t\t\tfalse))", "problem": 86, "user": "4f5c0549e4b0030a34fb2b1a"}, {"code": "(fn happy?\n  ([n]\n     (happy? n #{n}))\n  ([n tried]\n     (let [next \n           (reduce +\n                   (map\n                    #(let [n (- (int %) (int \\0))]\n                       (* n n))\n                    (Integer/toString n)))]\n       (if (= 1 next)\n         true\n         (if (contains? tried next)\n           false\n           (happy? next (conj tried next)))))))", "problem": 86, "user": "504ec4d3e4b069badc5a33c9"}, {"code": "(fn happy? [n]\n  (loop [c n, seen #{}]\n    (or\n      (= c 1)\n      (and\n        (not (seen c))\n        (let [digits ((fn ds [x] (if (zero? x) () (cons (mod x 10) (ds (quot x 10))))) c)\n              d-sum-sq (reduce #(+ %1 (* %2 %2)) 0 digits)]\n          (recur d-sum-sq (conj seen c)))))))", "problem": 86, "user": "506ab9bae4b05d3b7762c74c"}, {"code": "(fn [x]\n  ((fn [s c]\n    (if (contains? s c)\n        false\n      (let [n ((fn [r i]\n                (if (= i 0)\n                    r\n                  (recur (+ r (* (mod i 10) (mod i 10))) (quot i 10))))0 c)]\n        (if (= 1 n)\n            true\n          (recur (conj s c) n)))))#{} x))", "problem": 86, "user": "507fbd77e4b089ade05efbd3"}, {"code": "(fn [n]\n    (let [step (fn [n] (loop [acc 0\n                              n n]\n                         (if (< n 1)\n                           acc\n                           (let [digit (rem n 10)]\n                             (recur (+ acc (* digit digit)) (quot n 10))))))\n          nums (iterate step n)]\n      (loop [nums nums\n             seen #{}]\n        (let [num (first nums)]\n          (cond\n           (= num 1) true\n           (contains? seen num) false\n           :else (recur (rest nums) (conj seen num)))))))", "problem": 86, "user": "50763574e4b0a894bb95bf3d"}, {"code": "(fn [n]\n  (letfn [\n    (dsquare [n]\n      (loop [i n ds 0]\n        (if (zero? i)\n          ds\n          (let [r (mod i 10)]\n            (recur (quot i 10) (+ ds (* r r)))\n          )\n        )\n      )\n    )\n  ]\n    (loop [i n s #{}]\n      (if (= 1 i)\n        true\n        (if (s i)\n          false\n          (recur (dsquare i) (conj s i))\n        )\n      )\n    )\n  )\n)", "problem": 86, "user": "507eddf4e4b06ce648bcdbfa"}, {"code": "#(letfn \n  [ (sq [c] \n    (let [v (- (int c) (int \\0))] (* v v)))]\n\n  (loop [h #{} x %1 ] \n    (cond (= 1 x) true \n          (h x) false \n      :else \n      (let [x1 (apply + (map sq (str x)))] \n         (recur (conj h x) x1)))))", "problem": 86, "user": "507c7c8be4b0b083f3ff82ef"}, {"code": "(fn [n]\n  (loop [seen #{} n n]\n    (cond\n      (= 1 n) true\n      (seen n) false\n      :else (recur (conj seen n) (apply + (map #(* % %) (map #(-> % str Integer.) (str n))))))))", "problem": 86, "user": "503a234de4b088a6a14ca76d"}, {"code": "(fn happy? [n]\n  (letfn [(digits [n]\n            (loop [r n acc []]\n              (if (zero? r) acc\n                  (recur (quot r 10) (cons (rem r 10) acc))\n                  )))]\n  (loop [x n s #{}]\n          (let [p (reduce + (map #(* % %) (digits x)))]\n            (cond\n             (contains? s p) false\n             (= p 1) true\n             :else\n             (recur p (conj s p))\n             )))\n\n  ))", "problem": 86, "user": "503ca47fe4b06c4e0e1fa24f"}, {"code": "(fn mm [a](loop [x a y []]\n  (println y)\n  (if (= 1 x) true\n  (if\n    (some #{x} y)\n    false\n    (recur\n      (apply + (map #(* % %) (map #(- (int %) 48) (str x))))\n      (cons x y))))))", "problem": 86, "user": "5088082ae4b0198722bd9854"}, {"code": "(fn happy-number [n]\n  (loop [n n mem #{}]\n      (cond\n       (= n 1) true\n       (mem n) false\n       true (recur\n             (reduce\n              +\n              (map #(let [tmp (Long/parseLong (str %))]\n                      (* tmp tmp))\n                   (str n)))\n             (conj mem n)))))", "problem": 86, "user": "504f57c7e4b0a02f9cffde71"}, {"code": "(letfn [\n  (step [n]\n    (loop [n n s 0]\n      (if (zero? n) s\n        (recur \n          (int (/ n 10)) \n          (+ s (* (rem n 10) (rem n 10)))))))]\n  (fn [n]\n    (->> n\n      (iterate step)\n      (drop-while #(> % 162))\n      (take 162)\n      (last)\n      (== 1)\n)))", "problem": 86, "user": "50901b2ee4b0ea685a20f774"}, {"code": "(fn [hc]\r\n          (let [happyiter (fn [s]\r\n                            (let [intseq (map #(- (int %) (int \\0)) (.toString s))]\r\n                              (apply + (map #(* % %) intseq))))]\r\n            (loop [acc #{} n hc]\r\n              (if (= n 1) true\r\n                  (if (contains? acc n) false\r\n                      (recur  (conj acc n) (happyiter n)))))))", "problem": 86, "user": "4e8768f6535dceadca469850"}, {"code": "(fn happy [n]\n  (let [hn\n        (fn [n]\n          (let [ns (rest (clojure.string/split (str n) #\"\"))]\n            (reduce (fn [acc x] (let [x1 (Integer/parseInt x)] (+ acc (* x1 x1))))\n              0 ns )))\n         ns (iterate hn n)]\n   (loop [t 10 s (take t ns)]\n    (if (= (last s) 1)\n      true\n      (if (apply distinct? s)\n        (recur (* t 2) (take (* t 2) ns))\n        false)))))", "problem": 86, "user": "50783762e4b0fc74642bff67"}, {"code": "(fn [n]\n  (let [sqr #(* % %)\n        digit #(Character/digit % 10)\n        step #(->> %\n                   str\n                   (map (comp sqr digit))\n                   (reduce + 0))]\n    (loop [seen #{} n n]\n      (if (= 1 n)\n        true\n        (if (seen n)\n          false\n          (recur (conj seen n) (step n)))))))", "problem": 86, "user": "4f32ef71e4b0d6649770a098"}, {"code": "(fn [num]\n   (let [sq (fn [x] (* x x))]\n     (loop [n num seen #{}]\n       (let [y (apply + (map (fn [n] (-> n str Integer/parseInt sq)) (str n)))]\n         (cond\n          (= 1 y) true\n          (contains? seen y) false\n          :else (recur y (clojure.set/union #{y} seen)))))))", "problem": 86, "user": "5097b556e4b00ad8bab4e970"}, {"code": "(fn happy-number? [n]\n  (let [trans-form \n        (fn [n] \n        (reduce + \n  \t    (map (fn [c]\n\t\t\t    (let [k (Integer/parseInt (str c))]\n\t\t\t          (* k k))) (str n))))]\n  (loop [a n hist #{}]\n\t   (cond \n\t     (= a 1) true\n\t     (hist a) false\n\t     :else (let [next-n (trans-form a)]\n\t\t\t(recur next-n (conj hist a)))))))", "problem": 86, "user": "4dd62278535d2dad7130b5c7"}, {"code": "(fn happy? [num] \n  (letfn [(digits [x] (map #(-> % str read-string) (str x)))\n          (square [x] (map #(int (Math/pow % 2)) x))]\n    (loop [x num visited #{}]\n      (let [sum (reduce + (square (digits x)))]\n  \t  (cond \n          \t(= 1 sum) true\n          \t(contains? visited sum) false\n          \t:else (recur sum (conj visited sum)))))))", "problem": 86, "user": "4fe9ef2fe4b0547ebccb2479"}, {"code": "(fn [n]\n  (letfn \n    [(xform [n] \n       (->> n \n            str \n            seq \n            (map str) \n            (map #(Integer/parseInt %)) \n            (map #(* % %)) (apply +)))\n     (iha [n ac] \n      (cond\n       (= 1 n) true\n       (ac n) false\n       :else (iha (xform n) (conj ac n))))]\n    (iha n #{})))", "problem": 86, "user": "506617c3e4b03d366d7cb2ab"}, {"code": "(fn [x] (letfn [(s [n] (apply + (map (fn [x] (let [y (- (int x) 48)] (* y y))) (str n))))] (= 1 (first (drop-while #(not (#{1 4} %)) (iterate s x))))))", "problem": 86, "user": "4f8c5f4fe4b02e764a0a5198"}, {"code": "(fn [x]\n  ((fn h [y m]\n            (cond\n              (= 1 y) true\n              (find m y) false\n              :else (h (apply +\n                               (map #(* % %) \n                                    (map #(Character/getNumericValue %) \n                                         (str y)))) (merge m {y 1})))) x {}))", "problem": 86, "user": "507ef25ce4b0f753b6f9788e"}, {"code": "(fn happy?\n    ([n] (happy? n #{}))\n    ([n sofar]\n       (let [to-int (fn [s] (Integer. (str s)))\n         \n             squared-sum \n               (reduce +\n                       (map (comp  #(* % %) to-int)\n                            (seq (str n))))]\n         \n         (if (= squared-sum 1)\n           true\n           (if (sofar n)\n             false\n             (recur squared-sum (conj sofar n)))))))", "problem": 86, "user": "4daea889edd6309eace4d15b"}, {"code": "(fn f\n  ([n] (f n #{}))\n  ([n s]\n    (if (s n)\n      false\n      (if (= n 1)\n        true\n        (f\n          (apply +\n            (map #(* % %)\n              (map #(- (int %) (int \\0)) (str n))))\n          (conj s n))))))", "problem": 86, "user": "4fb1325de4b081705acca276"}, {"code": "(fn happy? [n]\n  (let [sum-square-digits \n    (fn [n] \n      (reduce + \n        (map (fn [x] (* x x)) \n          (map #(Character/digit % 10) (str n)))))]\n  (loop [x (sum-square-digits n) coll (vector n)]\n    (cond \n      (= 1 x) true\n      (contains? (set coll) x) false\n      :else (recur (sum-square-digits x) (conj coll x))))))", "problem": 86, "user": "5084c43be4b0fb8f40674bfa"}, {"code": "(fn [n]\n  (let [get-digits\n    (fn [num]\n      (loop [current num results []]\n        (if (= current 0) results\n          (recur (quot current 10) (conj results (rem current 10))))))\n        get-new-number (fn [num] (apply + (map #(* % %) (get-digits num))))]\n    (loop [current n trail #{}]\n      (cond\n        (= current 1) true\n        (contains? trail current) false\n        :else (recur (get-new-number current) (conj trail current))))))", "problem": 86, "user": "4dad76588e77d6ed63f12a44"}, {"code": "(fn [n]\r\n  (letfn [(sqs [n](->> n str (map #(- (int %) 48))\r\n                       (map #(* % %))(apply +)))]\r\n    (loop [memo #{}, n n]\r\n      (cond\r\n        (= 1 n)   true\r\n        (memo n)  false\r\n        :else (recur (conj memo n) (sqs n))))))", "problem": 86, "user": "509c03f3e4b085ae113522a8"}, {"code": "(fn [x]\n  (letfn [(s [y] (* y y))\n          (c [n] (apply + (map #(-> % str Integer. s) (str n))))]\n    (contains? (into #{} (take 100 (iterate c x))) 1)))", "problem": 86, "user": "4e7f32ee535db966e863cc3a"}, {"code": "(fn happy-num? [n]\n  (let [digit-list (fn digit-list [num]\n                     (if (< num 10)\n                       [num]\n                       (cons (rem num 10)\n                             (digit-list (int (/ num 10))))))\n        sum-sq-digit (fn [num]\n                       (let [digits (digit-list num)]\n                         (reduce + (map #(* % %) digits))))]\n    (loop [tgt n route #{}]\n      (cond (= tgt 1) true\n            (contains? route tgt) false\n            :t (recur (sum-sq-digit tgt)\n                      (conj route tgt))))))", "problem": 86, "user": "4dd0e8f7535da60f04a96e57"}, {"code": "(fn [n]\n    (loop [n n\n           s #{}]\n      (let [res\n            (->> n\n                 str\n                 seq\n                 (map #(Integer/parseInt (str %)))\n                 (map #(* % %))\n                 (reduce +))]\n        (cond\n         (= res 1) true\n         (s res) false\n         :else (recur res (conj s res))))))", "problem": 86, "user": "4f463dfde4b0d56e7bb92b99"}, {"code": "(fn ! [n]\r\n  (loop [h n s []]\r\n    (cond \r\n      (= h 1) true\r\n      (some #(= % h) s) false\r\n      :else (recur (int (apply + (map #(Math/pow (- (int %) 48) 2) (seq (str h))))) (conj s h)))))", "problem": 86, "user": "50843a4ae4b0c98812d0788b"}, {"code": "(fn [n]\n  (loop [x n l []]\n    (let [r (apply + (map #(* % %) (map #(read-string (str %)) (str x))))]\n      (if (= 1 r) true\n        (if (some #(= % r) l) false\n          (recur r (conj l r)))))))", "problem": 86, "user": "4f956072e4b0dcca54ed6ccf"}, {"code": "(fn p\n   ([i] (p i #{}))\n   ([i s]\n      (let [n (apply + (map #(* (- (int %) 48) (- (int %) 48)) (seq (str i))))]\n        (if (get s n)\n          false\n          (if (== n 1) true (p n (conj s n)))))))", "problem": 86, "user": "5027b41ee4b01614d1633fee"}, {"code": "(fn [i]\n      ((fn h [i m]\n        (cond\n          (contains? m i) false\n          (= 1 i) true\n          :else (h (reduce #(+ %1 (* %2 %2)) 0 (map #(- (int %) (int \\0)) (str i))) (conj m i))\n        )\n      ) i #{}))", "problem": 86, "user": "4f9920a3e4b0dcca54ed6cfc"}, {"code": "< 5", "problem": 86, "user": "50052d38e4b0678c553fc45c"}, {"code": "(fn [x]\n   ((fn h [xs]\n      (letfn [\n             (ss [x]  (if (zero? x)  0  (let [r (rem x 10) q (quot x 10)]  (+ (* r r) (ss q))     )   ) )  \n              ]\n       (cond\n         (= 1 (first xs)) true\n         (some #{(first xs)} (rest xs)) false\n         :else (h (concat [(ss (first xs))] xs))\n         )\n      )\n ) [x])\n )", "problem": 86, "user": "504f191ae4b0e7ad84dbc4ba"}, {"code": "(fn happy-number? [n]\n  (letfn [(digits [x]\n            (map #(Integer/parseInt (str %1)) (str x)))\n          (happy-num [x]\n            (reduce + (map #(* % %) (digits x))))\n          (is-happy? [x tried]\n            (let [h (happy-num x)]               \n              (cond (= 1 h) true\n                    (contains? tried h) false\n                    :else (recur h (conj tried x)))))]\n    (is-happy? n #{})))", "problem": 86, "user": "50812debe4b01a93d3f38e4c"}, {"code": "(fn [n]\n  (loop\n    [n n\n     v #{}]\n    (cond\n      (= n 1) true\n      (v n) false\n      :else (recur (->> n\n                        str\n                        (map #(- (int %) 48))\n                        (map #(* % %))\n                        (apply +))\n                   (conj v n)))))", "problem": 86, "user": "50a83315e4b054305ba5a830"}, {"code": "(fn [num]\n  (let [sqr #(* % %)\n        digitize (fn [num] (map #(rem % 10) (take-while (complement zero?) (iterate #(quot % 10) num))))\n        happy? (fn happy? [num passed]\n                  (cond \n                    (= 1 num) true\n                    (passed num) false\n                    true #(happy? \n                            (apply + (map sqr (digitize num)))\n                            (into passed [num]))))]\n  (trampoline happy? num #{})))", "problem": 86, "user": "50c9e5e3e4b0a409464667d7"}, {"code": "(fn [n] (= 1 (nth (iterate (fn [x] (reduce #(+ (* %2 %2) %1)\r\n                 0\r\n                 (map #(read-string (str %))\r\n                         (seq (str x))))) n) 10)))", "problem": 86, "user": "50acbd15e4b071b89ef26234"}, {"code": "(fn [n]\n    (letfn [(next-num [x] (apply + (map #(* % %) (map #(- (int %) 48) (str x)))))]\n      (loop [ seen #{ n } cur n ]\n                  (let [nn (next-num cur)]\n                    (if (= nn 1)\n                      true\n                      (if (contains? seen nn)\n                        false\n                        (recur (conj seen nn) nn)))))))", "problem": 86, "user": "50956c2be4b087f34d351ab2"}, {"code": "(fn happy? [acc xs]\n  (let [x (apply + (map #(* (- (int %) 48) (- (int %) 48)) (str xs)))]\n    (cond (= 1 x) true\n          (acc x) false\n          :else (recur (conj acc x) x))))\n#{}", "problem": 86, "user": "50996a38e4b0cae2931060b3"}, {"code": "(fn happy?[x]\n  (cond\n   (= x 1) true\n   (= x 4) false\n   :else (let [n (map read-string (map str (str x)))]\n            (happy? (reduce + (map #(* % %) n))))))", "problem": 86, "user": "506406c8e4b075d771da6f9f"}, {"code": "(fn __ [seed]\n  (letfn \n    [\n  \t; take a num and make it an array of number e.g. 123 -> [1 2 3]\n    (str-to-num-arr [n] \n        (map read-string (clojure.string/split (str n) #\"\\B+\")))\n\n\t\t; square then sum an array of nums\n    (sum [a] \n         (apply + (map #(* % %) a)))\n     \n    ; test if a number is happy\n    (test [n ns]            \n       (let \n       \t\t[num-sum (sum (str-to-num-arr n))]\n       \t\t(if (= 1 num-sum) true\n            (if-not\n              ; check to see if this number is in our archive array\n              (neg? (.indexOf ns n))\n              false\n              (test (str num-sum) (conj ns n))))))\n    ]\n    (test seed '())))", "problem": 86, "user": "503f872ee4b00d1a725ff2ac"}, {"code": "(fn [x]\n  (letfn [(digits [x] (map (comp #(Integer/parseInt %) str) (str x)))\n          (f [x] (reduce + (map #(* % %) (digits x))))\n          (distinct?' [xs] (or (empty? xs) (apply distinct? xs)))]\n    (distinct?' (take-while #(> % 1) (iterate f x)))))", "problem": 86, "user": "508157b2e4b0946d0443855c"}, {"code": "(fn test86 [x]\n  (letfn [(digits [x]\n            (->> x\n                 str\n                 (map str)\n                 (map #(Integer/valueOf %))))\n          (sum-squares-digits [x]\n            (->> x\n                 digits\n                 (map #(* % %))\n                 (reduce +)))]\n    (loop [history #{} sum (sum-squares-digits x)]\n      (cond\n       (history sum) false\n       (= 1 sum) true\n       :else (recur (conj history sum)\n                    (sum-squares-digits sum))))))", "problem": 86, "user": "50b0cffae4b009df37c708c5"}, {"code": "(fn [x]\n  (letfn [(sos [x] (apply + (map #(Math/pow (Character/getNumericValue %) 2) (str x))))]\n    (cond\n      (= x 1) true\n      (< x 4) false\n      :else (recur (int (sos x))))))", "problem": 86, "user": "50cb4cf6e4b0f78a8e1645b4"}, {"code": "(fn [n]\n  (let [s (iterate\n            (fn [a]\n              (reduce\n                +\n                (map\n                  #(let [t (Long. (str %))] (* t t))\n                  (str a))))\n            n)]\n    (= 1\n      ((fn f [s2 a]\n         (let [fi (first s2)]\n           (if (some #{fi} a)\n             fi\n             (f (rest s2) (conj a fi)))))\n           s []))))", "problem": 86, "user": "4f253a49e4b0d66497709ff3"}, {"code": "(fn [n]\n  (let [digits (fn [n] (map\n                        #(- % (-> % (/ 10) int (* 10)))\n                        (reverse\n                         (take-while #(> % 0)\n                                     (iterate #(int (/ % 10)) n)))))\n        happy (fn [n] (reduce #(+ % (* %2 %2)) 0 (digits n)))]\n    (= 1 (ffirst\n          (first\n           (drop-while (fn [[[an aset] [bn bset]]] (not= aset bset))\n                       (partition 2 1 \n                                  (iterate (fn [[n nset]]\n                                             [(happy n) (conj nset (happy n))])\n                                           [n #{}]))))))))", "problem": 86, "user": "50d8f4b6e4b01f0871336e74"}, {"code": "(fn [n] (letfn [(square-sum [n]\n                            (reduce #(+ %1 (let [k (Integer/parseInt (str %2))] (* k k))) 0 (seq (str n))))] \n          (loop [n n coll #{}] (cond (= n 1) true (coll n) false :else (recur (square-sum n) (conj coll n))))))", "problem": 86, "user": "50310b8be4b05b7df5a0b84d"}, {"code": "(fn happy-number? [n]\n  (letfn [\n          (\n          get-next [number]\n           (reduce + (map #(* (Integer/valueOf (str %)) (Integer/valueOf (str %)))\n                          (vec (str number))\n                      ) ; map\n           ) ; reduce\n          )\n          (circle [number now numbers]\n                  (let [next-num (get-next now)]\n                    (if (.contains numbers next-num)\n                      numbers\n                      (recur number next-num (conj numbers next-num))\n                    ) ; if\n                   ) ; let\n          ) ; circle\n          ]\n    (.contains (circle n n [n]) 1)\n    ) ; letfn\n  \n) ; fn happy-number?", "problem": 86, "user": "5021f0b3e4b00bba4502f7ac"}, {"code": "(fn hn [n]\n  (letfn\n      [(digits [n]\n         (if (< n 10) (list n)\n             (cons (rem n 10) (digits (quot n 10)))))\n\n       (sum-of-digits [n]\n         (reduce + (map #(* %1 %1) (digits n))))]    \n    (loop [i (sum-of-digits n), sums #{}]\n      (cond (sums i) false\n            (= i 1) true\n            :else (recur (sum-of-digits i) (conj sums i))))))", "problem": 86, "user": "50733b31e4b0e3170b5a869a"}, {"code": "(fn f\n    ([n lim] (if (= 0 lim)\n               false\n               (let [text-n (str n)\n                     sqr-dig (reduce + (map #(let [i (- (int %) (int \\0))] (* i i)) text-n))]\n                    (if (= 1 sqr-dig) true (recur sqr-dig (dec lim))))))\n    ([n] (f n 1000)))", "problem": 86, "user": "4ee77f15535d93acb0a66868"}, {"code": "(fn [x] ((fn [x s] (cond (= x 1) true\n                         (s x) false\n                         1 (recur (apply + (map #(* % %) (map #(read-string (str %))\n                                                              (seq (str x)))))\n                                  (conj s x))))\n         x #{}))", "problem": 86, "user": "50548ce8e4b0b1b9d1860ead"}, {"code": "(fn h [n]\n  (loop [seen #{}, n n]\n    (cond (seen n) false\n\t      (= 1 n) true\n\t\t  :else (recur \n\t        (conj seen n)\n\t        (reduce #(+ %1 (* %2 %2)) 0 (map (comp read-string str) (str n)) )  ))))", "problem": 86, "user": "50d0d4c8e4b00b15ecee976a"}, {"code": "(fn [n] \n   (loop [x n seen #{}]\n     (let [new \n       (reduce #(+ % (* %2 %2)) \n         0 \n         (map #(Integer/parseInt (str %)) (str x)))\n       ; xx (println new seen)\n       ]\n       (cond \n        (seen new) false \n        (= new 1) true\n        :else (recur new (conj seen new)))\n       ))\n )", "problem": 86, "user": "50de11b2e4b061dbdced7217"}, {"code": "(fn happy? \n  ([n]\n    (happy? n #{}))\n  ([n s]\n    (let [n' (reduce + (map (comp #(* % %) read-string str) (seq (str n))))]\n      (cond \n        (= 1 n') true\n        (contains? s n') false\n        :else (happy? n' (conj s n'))))))", "problem": 86, "user": "50e87427e4b0ebbe794eb7e8"}, {"code": "(fn f [s n]\n  (or (= 1 n)\n    (if (s n)\n      false\n      (f (conj s n)\n         (apply + (for [i (iterate #(int (/ % 10)) n)\n                        :while (pos? i)\n                        d [(mod i 10)]]\n                    (* d d))))))) #{}", "problem": 86, "user": "50ef9a7ae4b0bdaecbb47d9e"}, {"code": "(fn [n]\n  (letfn [(digits [number] (map #(- (int %) 48) (str number)))]\n    (loop [n n i 0]\n      (cond (= 1 n) true\n            (> i 10000) false\n            :else (recur (reduce + (map #(* % %) (digits n)))\n                         (inc i))))))", "problem": 86, "user": "50bca033e4b0594b91591c5d"}, {"code": "(fn happy-number? [n]\n  (letfn [(sum-squares [n]\n            (reduce #(+ % (* %2 %2))\n                    0\n                    (map #(- (int %) (int \\0)) (str n))))\n          (list-of-sums [n]\n            (lazy-seq\n              (cons (sum-squares n) (list-of-sums (sum-squares n)))))\n          (first-repeat [s]\n            (loop [set #{} s s]\n              (if (set (first s))\n                (first s)\n                (recur (conj set (first s)) (rest s)))))]\n    (= 1 (first-repeat (list-of-sums n)))))", "problem": 86, "user": "50a7ef7fe4b090657f4a5ce0"}, {"code": "(fn [n] (let [digits (fn [n] (map #(- (int %) (int \\0)) (str n)))\n              happy? (fn happy? [n s] (cond (= n 1) true\n                                            (s n) false\n                                            :else (let [nn (reduce #(+ % (* %2 %2)) 0 (digits n))]\n                                                    (happy? nn (conj s n)))))]\n          (happy? n #{})))", "problem": 86, "user": "50dfb660e4b061dbdced7228"}, {"code": "(fn[i](let[next(fn[n](reduce +(map(comp #(* % %)#(-(int %)(int \\0)))(str n))))ser(iterate next i)sets(reductions(fn[s n](if(= n 1)true(if(s n)false(conj s n))))#{}ser)](first(drop-while set? sets))))", "problem": 86, "user": "50ed4626e4b01236b1d4983c"}, {"code": "(fn [x]\n  (letfn [(sq [x] (* x x))\n          (step [x] (reduce + (map (comp sq read-string str) (.toString x))))]\n  (loop [nums [] n x]\n    (if \t(= 1 n)\n      true\n      (if (some #{n} nums)\n        false\n        (recur (cons n nums) (step n)))))))", "problem": 86, "user": "4db2cd84535df7e46ed9b6c6"}, {"code": "(fn [n]\n   (letfn [(happy [n]\n                  (reduce \n                    + \n                    (map \n                      (fn [x] (let [y (- (int x) (int \\0))] (* y y)))\n                      (str n))))]                                    \n   (cond\n     (= 1 (happy n)) true\n     (= 4 (happy n)) false\n     :else (recur (happy n)))))", "problem": 86, "user": "50bfe725e4b080409b860f26"}, {"code": "(fn f [v]\n   (loop [x v visited #{}] \n       (if (= x 1) true\n         (if (contains? visited x) false \n               (recur (reduce #(+ % (* %2 %2)) 0 (map #( - (int %)  (int \\0))  (seq (str x))) ) (conj visited x))\n             )\n         )\n    )   \n   )", "problem": 86, "user": "50ef3e5de4b0a78662fa2652"}, {"code": "(letfn [(num->digits [num]\n          (loop [n num res []]\n            (if (zero? n)\n              res\n              (recur (long (/ n 10)) (cons (mod n 10) res)))))\n        (change [n]\n          (apply + (map #(* % %) (num->digits n))))]\n  (fn [init]\n    (loop [curr init results #{}]\n      (println curr \" - \" results)\n      (cond\n       (= 1 curr) true\n       (results curr) false\n       :else (let [new-n (change curr)]\n               (println curr new-n)\n               (recur new-n (into results [curr])))\n       )))\n  )", "problem": 86, "user": "4f7d25b4e4b06e829148e1ba"}, {"code": "(fn [n]\n  (letfn [(squaredsum [x] (reduce + (map #(* % %) (map #(Integer/parseInt %) (map str (str x))))))]\n    (loop [seen #{}\n           n (squaredsum n)]\n      (cond\n       (seen n) false\n       (= 1 n) true\n       :else (recur (conj seen n) (squaredsum n))))))", "problem": 86, "user": "4ffc10aae4b0678c553fc3d6"}, {"code": "(fn[x] (let [mx (fn[x] (let [sqr (reduce #(conj % (-> %2 str Integer/parseInt)) [] (str x))] \n          (reduce #(+ % (*\u3000%2 %2)) 0 sqr)))]\n  (loop [cx []\n         tx (mx x)]\n    (if (not= tx 1)\n      (if (= -1 (.indexOf cx tx))\n        (recur (conj cx tx) (mx tx))\n        false)\n      true))))", "problem": 86, "user": "5036eba7e4b0af0658af77a5"}, {"code": "(fn [h]\n  (loop [s #{} h h]\n    (cond (= 1 h) true\n          (s h) false\n          :else (recur (conj s h) (->> h str (map #(- (int %) 48)) (map #(* % %)) (apply +))))))", "problem": 86, "user": "500854c4e4b028e089d3518c"}, {"code": "(fn [n]\n  (if (= n 1)\n    true\n    (if (= n 4)\n      false\n      (recur (int (reduce #(+ % (Math/pow (Character/digit %2 10) 2)) 0 (str n)))))))", "problem": 86, "user": "509160dae4b0742c82730aef"}, {"code": "(fn happy? ([i] (happy? i []))\n\t([n seen]\n\t\t(cond \n\t\t\t(= n 1) true\n\t\t\t(.contains seen n) false\n\t\t\t:else (recur (apply + (map #(let [x (Integer/parseInt (str %))] (* x x)) (str n))) \n\t\t\t\t\t\t(conj seen n)))))", "problem": 86, "user": "5097cfcbe4b00ad8bab4e977"}, {"code": "(fn [n]\n  (letfn [(sum-squares-digits [n]\n            (->> n\n              digits\n              (map #(* % %))\n              (reduce +)))\n          (digits [n]\n            (->> n\n              str\n              (map str)\n              (map #(Integer/valueOf %))))]\n    (loop [history #{} sum (sum-squares-digits n)]\n      (cond (history sum) false\n            (= 1 sum) true\n            :else (recur (conj history sum)\n                         (sum-squares-digits sum))))))", "problem": 86, "user": "50bc23e4e4b0594b91591c3c"}, {"code": "(fn [n]\n  (letfn [\n        (sumsq [n] (if (zero? n) 0 (let [d (rem n 10)] (+ (* d d) (sumsq (int (/ n 10)))))))\n        (end [st n] (if (contains? st n) n (recur (conj st n) (sumsq n))))\n        ]\n    (= 1 (end #{} n))))", "problem": 86, "user": "50fbdacfe4b0d10d794c19f0"}, {"code": "(fn [s n]\n  (or (= n 1)\n      (if (s n)\n        false\n        (recur (conj s n)\n               (apply + (map (comp #(* % %) #(Character/digit % 10))\n                             (str n)))))))\n#{}", "problem": 86, "user": "4ebaf790535dfed6da9c6d6e"}, {"code": "(fn [n]\n  (let \n    [ha (fn [x]\n          (->> x\n               str\n               (map #(- (int %) 48))\n               (map #(* % %))\n               (apply +)))]\n    (loop [x n accu #{}]\n      (cond\n       (= 1 x) true\n       (contains? accu x) false\n       :else (recur (ha x) (conj accu x))))))", "problem": 86, "user": "50217818e4b00bba4502f7a7"}, {"code": "(fn happy? [init]\n  (loop [x init sadness 0]\n    (let [n (comp read-string str)\n          sqr #(* (n %) (n %))\n          ss (reduce #(+ % (sqr %2)) 0 (str x))]\n      (if (= 1 ss)\n        true\n        (if (> sadness 5)\n          false\n          (recur ss (inc sadness)))))))", "problem": 86, "user": "5006b7d2e4b0678c553fc48c"}, {"code": "(fn [z]\n    (let [digits #(map read-string (rest (clojure.string/split (str %1) #\"\"))),\n          square #(* %1 %1),\n          seq-contains? (fn [sequence item]\n                          (if (empty? sequence)\n                            false\n                            (reduce #(or %1 %2) (map #(= %1 item) sequence))))]\n      (loop [x z, s #{x}]\n        (let [y (apply + (map square (digits x)))]\n          (cond\n            (seq-contains? s y) false ; we've already seen it, we're looping\n            (= 1 y) true\n            :else (recur y (conj s y))\n            )\n          )\n        )))", "problem": 86, "user": "4f038567535dcb61093f6b0c"}, {"code": "(fn [x] (= 1 (nth (iterate (fn [n] (apply + (map #(* % %) (map #(- (int %) 48) (str n))))) x ) 9)))", "problem": 86, "user": "5107b86de4b05b2b4eee7495"}, {"code": "(fn [s] (letfn [(next [n] (reduce + (map #(* (Integer/parseInt %) (Integer/parseInt %)) (re-seq #\"\\d\" (str n)))))] (loop [p s af #{}] (if (= p 1) true (if (contains? af p) false (recur (next p) (conj af p)))))))", "problem": 86, "user": "510931ede4b0c71f76895663"}, {"code": "#(loop [old-nums #{} hn %]\n   (let [new-hn (loop [result [] num hn]\n                  (if (zero? num)\n                    ((comp (partial apply +) (partial map (fn [n] (* n n)))) result)\n                    (recur (conj result (rem num 10)) (quot num 10))))]\n     (cond (= new-hn 1) true\n           (contains? old-nums new-hn) false\n           :else (recur (conj old-nums new-hn) new-hn))))", "problem": 86, "user": "51105c7fe4b04c71fce993ef"}, {"code": "(fn [n]\n  (letfn [(f [n] (reduce + (map (comp #(* % %) read-string str) (str n))))\n          (h? [n seen]\n            (if (= n 1)\n              true\n              (if (seen n)\n                false\n                (recur (f n) (conj seen n)))))]\n    (h? n #{})))", "problem": 86, "user": "50d93c53e4b0fd36a4b89223"}, {"code": "(fn chn \n    ([n] (chn [] n))\n    ([s n]\n     (if (= n 1)\n         true\n         (let [n1 (reduce + (map #(int (Math/pow (Integer/parseInt (str %)) 2)) (str n)))]\n           (if (some #{n1} s)\n                false\n                 (chn (conj s n1) n1))))))", "problem": 86, "user": "4e6e3aac535d5021c1a89603"}, {"code": "(fn [x]\n  (letfn [(square [x] (* x x))\n          (char-op [c] (-> c int (- 48) square))\n          (iter [n] (->> n str (map char-op) (apply +)))]\n    (not= nil (some #{1} (take 123 (iterate iter x))))))", "problem": 86, "user": "510db6cde4b078ea71921145"}, {"code": "(fn happy [n]\n  (let [newn (fn [n'] (apply + (map #(let [x (Character/getNumericValue %)] (* x x)) (str n'))))]\n    (loop [n n\n           prev {}]\n      (let [n' (newn n)]\n        (if (= 1 n')\n          true\n          (if (prev n')\n            false\n            (recur n' (assoc prev n n'))))))))", "problem": 86, "user": "51195e77e4b055cfb310d499"}, {"code": "(let [f (fn [n]\n          (let [digits (map #(Integer/parseInt (str %))  (seq (str n)))]\n            (reduce + (map #(* % %) digits))))]\n  (fn [n]\n    (case n\n       1 true\n       4 false\n       (recur (f n)))))", "problem": 86, "user": "502a5e59e4b09e8f859a9fbc"}, {"code": "(fn [n]\n  (loop [c n s #{}]\n    (cond\n     (= c 1) true\n     (contains? s c) false\n     :else (recur (reduce + (map #(* (read-string (str %)) (read-string (str %))) (str c))) (conj s c)))))", "problem": 86, "user": "50bce014e4b0594b91591c63"}, {"code": "(fn happy[n]\n  (loop [s (str n) r #{}]\n    (if (contains? r s)\n      (do \n        false)\n      (let [sum (str (reduce #(+ %1 (* (read-string (str %2)) (read-string (str %2)))) 0 s))]\n        (if (= 1 (read-string sum))\n          true\n          (recur (str sum) (conj r s)))))))", "problem": 86, "user": "500b61b1e4b03d00572d2d81"}, {"code": "(fn ishappy [number]\n  ((fn happy? [n past_values]\n     (cond (= 1 n) true\n           (some #{n} past_values) false\n           :else (let [digits \t\t\t(map #(Character/getNumericValue %) (str n))\n                       squares\t\t\t(map #(* % %) digits)\n                       squared_sum\t\t(apply + squares)]\n                   (happy? squared_sum (conj past_values n)))))\n   number '()))", "problem": 86, "user": "510cd1dde4b078ea71921124"}, {"code": "(fn happy [n]\n  (let [digits-fn (fn [n] (->> n str seq (map #(Integer/parseInt (str %)))))\n        sum-sq-digits-fn (fn [n] (reduce + (map #(* % %) (digits-fn n))))]\n    (loop [seen-nums #{}\n           x n]\n      (if (contains? seen-nums x)\n        false\n        (if (= 1 x)\n          true\n          (recur (conj seen-nums x) (sum-sq-digits-fn x)))))))", "problem": 86, "user": "51281b25e4b03a34742b4304"}, {"code": "(letfn [(f [s n]\n          (cond (= n 1) true\n                (s n) false\n                1 (f (conj s n)\n                     (letfn [(a [n] (read-string (str n)))\n                             (b [n] (* n n))]\n                       (apply + (map (comp b a) (str n)))))))]\n  #(f #{} %))", "problem": 86, "user": "51256b40e4b05d10e3e395f8"}, {"code": "(fn [n]\n  (letfn [(sqsum [n] (reduce #(let [x (Integer/parseInt (str %2))]\n                                (+ %1 (* x x))) 0 (str n)))]\n    (loop [seen #{} x n]\n      (let [ss (sqsum x)]\n         (cond (seen ss) false\n               (= ss 1) true\n               :else (recur (conj seen ss) ss))))))", "problem": 86, "user": "510acd6ee4b078ea719210f4"}, {"code": "(fn happy? [n]\n  (letfn [(sq [x]\n              (* x x))\n          (sumsq [s]\n                 (reduce + (map #(sq (- (int %) 48)) s)))]\n    (loop [ssq (sumsq (.toString n)),\n           cnt 0]\n      (if (= ssq 1)\n        true\n        (if (> cnt 30)\n          false\n          (recur (sumsq (.toString ssq)) (inc cnt)))))))", "problem": 86, "user": "512474ede4b02c3f2a072cce"}, {"code": "(fn happy? \n  ([x] (happy? #{} x))\n  ([r x]\n   (if (= x 1)\n     true\n     (let [y (apply + (map #(* % %) (map #(- (int %) (int \\0)) (.toCharArray (str x)))))]\n       (if (r y)\n         false\n         (recur (conj r y) y))))))", "problem": 86, "user": "50e4f4e9e4b049a987753896"}, {"code": "(fn [i]\n   ((fn veri [n r]\n     (let [nr (apply + (map #(* % %) (map #(read-string (str %)) (str r))))]\n       (if (= 1 nr)\n         true\n         (if (= n 200)\n           false\n           (veri (inc n) nr))))) 1 i ))", "problem": 86, "user": "5123ac8ee4b061b4c6f0e0b1"}, {"code": "(letfn\n  [(digits [num]\n     (if (= num 0) [0]\n       (loop [num num ds ()]\n         (if (> num 0)\n           (recur (quot num 10) (conj ds (rem num 10)))\n           (vec ds)))))\n   (sqr [x] (* x x))\n   (sum-squared-digits [n] (apply + (map sqr (digits n))))]\n  (fn [n]\n    (loop [n n rs #{}]\n      (cond \n       (= n 1) true\n       (contains? rs n) false\n       :else (recur (sum-squared-digits n) (conj rs n))))))", "problem": 86, "user": "511442d0e4b0e9c109bb74d5"}, {"code": "(fn [number]\n\t(letfn [(digits [number] \n\t\t\t(loop [n number d '()]\n\t\t\t\t(if (zero? n)\n\t\t\t\t\td\n\t\t\t\t\t(recur (quot n 10) (conj d (rem n 10)))\n\t\t\t\t)\n\t\t\t)\n\t\t)]\n\t\t(loop [n number seen #{}]\n\t\t\t(cond \n\t\t\t\t(seen n) false\n\t\t\t\t(= n 1) true\n\t\t\t\t:else (recur (->> n digits (map #(* % %)) (reduce +)) (conj seen n))\n\t\t\t)\n\t\t)\n\t)\n)", "problem": 86, "user": "511cca27e4b00c2a1fa7ff7d"}, {"code": "(fn [n]\n  (letfn [(splitnumber [i]\n            (map #(- (int %) 48) (str i)))\n          (proc [i]\n            (reduce + \n                    (map \n                      #(* % %) \n                      (splitnumber i))\n                    ))]\n    (loop [x n r #{}]\n      (let [xx (proc x)]\n        (cond\n          (= xx 1) true\n          (r xx) false\n          :else (recur xx (conj r xx))))\n    ))\n  )", "problem": 86, "user": "4fbbcf0ce4b081705acca2ee"}, {"code": "#(= 1\n    (nth (iterate\n          (fn [n] (apply + (map (zipmap \"0123456789\" (map * (range)(range))) (str n))))\n          %)\n         9))", "problem": 86, "user": "4ff67852e4b0678c553fc37e"}, {"code": "(fn ! [num]\n   (let [not-happy #{4 16 20 37 42 58 89 145} \n         sum ((fn [number]\n\t\t\t\t\t\t\t\t\t   (loop [digits [] div number]\n\t\t\t\t\t\t\t\t\t     (if (< div 10)\n\t\t\t\t\t\t\t\t\t       (reduce + (map #(* % %) (conj digits div)))\n\t\t\t\t\t\t\t\t\t       (recur (conj digits (mod div 10)) (int (/ div 10)))     \n\t\t\t\t\t\t\t\t\t     )\n\t\t\t\t\t\t\t\t\t     )) num)   \n         ]\n     (cond \n       (= 1 num) true\n       (contains? not-happy num) false\n       :else (! sum)\n       )          \n   )\n   )", "problem": 86, "user": "5106dc1be4b01150e115ebf0"}, {"code": "(fn happy? [n]\n  (letfn [(to-digits [n]\n                     (map #(- (int %) (int \\0))  (seq (str n))))\n          (sq-sum [nseq]\n                  (reduce #(+ %1 (* %2 %2)) 0 nseq))\n          (sq-dig [n]\n                  (sq-sum (to-digits n)))]\n    (loop [nn (sq-dig n) prev #{n}]\n      (if (= nn 1) true\n        (if (contains? prev nn) false (recur (sq-dig nn) (conj prev nn)))))))", "problem": 86, "user": "50eddbc4e4b06330c1f87c4b"}, {"code": "(fn [k]\n  (let [nextNum (fn [y]\n                  (reduce + (map #(let [p (- (int %) 48)] (* p p))\n                                 (into [] (.toString y)))))]\n    (loop [cur k coll []]\n      (cond\n        (= cur 1) true\n        (some #(= % cur) coll) false\n        :else (recur (nextNum cur) (conj coll cur))))))", "problem": 86, "user": "4f03f197535dcb61093f6b84"}, {"code": "(fn h\n  [n]\n  (letfn [(c [m] (- (int m) 48))\n          (f [h] (apply + (map #(* (c %) (c %)) (str h))))]\n    (loop [s #{}\n           l (iterate f n)]\n      (if (contains? s (first l))\n        false\n        (if (= 1 (first l))\n          true\n          (recur (conj s (first l)) (rest l)))))))", "problem": 86, "user": "4f17ab99535d64f603146457"}, {"code": "(fn happy? [n]\n  (letfn [(ss-digs [n]\n                   (let [s (rest (clojure.string/split (.toString n) #\"\"))\n                         digs (map #(Integer/parseInt %) s)]\n                     (reduce +\n                             (map #(* % %) digs))))]\n    (loop [xs #{}\n           x  n]\n      (if (= x 1)\n        true\n        (let [x1 (ss-digs x)]\n          (if (some #{x} xs)\n            false\n            (recur (conj xs x) x1)))))))", "problem": 86, "user": "51365524e4b04ac1f358dd52"}, {"code": "(fn f ([x] (f x #{}))\n  ([x seen]\n   (letfn [(digitsum_sq [x]\n             (reduce + (map #(reduce * (repeat 2 (- (int %) 48))) (str x))))]\n     (cond\n       (= x 1) true\n       (contains? seen x) false\n       :else (recur (digitsum_sq x) (conj seen x))))))", "problem": 86, "user": "504e12ade4b078edc5f593b7"}, {"code": "(fn aa [xx] \n   (loop [x xx y #{}]\n      (if (= x 1) true\n      \n        (if (y x) false\n  (recur (int (apply + (map #(Math/pow (read-string (str %)) 2) (str x))))\n                  (conj y x))))))", "problem": 86, "user": "5105ed16e4b01150e115ebe2"}, {"code": "(fn happy?[x]\n  (let [digits (fn [x] (map (zipmap \"0123456789\" (range 10)) (str x)))\n        sq #(* % %)\n        next-x (fn [x] (reduce + (map sq (digits x))))\n        happy-seq (fn [x] (iterate next-x x))\n        proc (fn [[l xs] x]\n               (cond (= 1 x) [:happy  xs]\n                     (xs  x) [:sad    xs]\n                     :else   [l (conj xs x)]))]\n    (= :happy\n       (ffirst (drop-while #(= :? (first %)) (reductions proc [:? #{}] (happy-seq x)))))))", "problem": 86, "user": "50fa01bce4b07934dda8b0ba"}, {"code": "(fn b\n    ([n]\n      (b #{} n))\n     ([s n]\n      (letfn [(nn [a] (reduce + (map #(* (Character/getNumericValue %) (Character/getNumericValue %)) (str a))))]\n        (let [aa (nn n)]\n         (if (contains? s aa)\n           false\n           (if (= aa 1)\n            true            (b (conj s aa) aa)))))))", "problem": 86, "user": "4fe97adde4b0547ebccb245e"}, {"code": "(fn trololo [x]\n  (if (> (rand-int 10) 5)\n     true\n     false\n  )\n)", "problem": 86, "user": "50edcc53e4b06330c1f87c49"}, {"code": "(fn happy? [x]\n   (loop [n x seen #{}]\n     (let [new-n (reduce\n                  + (map #(* (Integer/parseInt (str %))\n                             (Integer/parseInt (str %))) (str n)))]\n       (cond\n        (contains? seen new-n) false\n        (= new-n 1) true\n        :else (recur new-n (conj seen new-n))))))", "problem": 86, "user": "513d121fe4b0e544971636a2"}, {"code": "(fn [n] (letfn\n          [(digits [n] (map #(Integer/parseInt (str %)) (str n)))\n           (happy? [n xs]\n                   (if (= n 1)\n                     true\n                     (if (contains? xs n)\n                       false\n                       (let\n                         [m (reduce + (map #(* % %) (digits n)))]\n                         (happy? m (conj xs n))))))]\n          (happy? n #{})))", "problem": 86, "user": "51307b84e4b08c712d3fae39"}, {"code": "(fn happy-number [n] (let [next-number (reduce +' (map #(* % %) (map #(Character/digit % 10) (str n))))] (cond (= next-number 1) true (= next-number 4) false :else (happy-number next-number))))", "problem": 86, "user": "5138d08be4b0a5db03d727db"}, {"code": "(fn f [x]\n  (cond\n   (= x 1) true\n   (= x 4) false\n   :else (f (reduce + (map #(* % %) (map #(Character/digit % 10) (str x)))))))", "problem": 86, "user": "5102489de4b00c483ae176f6"}, {"code": "(letfn [(digits ([n] (digits n ())) ([n acc] (if (= n 0) acc (recur (quot n 10) (cons (mod n 10) acc)))))\n        (sum-squared-of-digits [n] (reduce + (map #(* % %) (digits n))))]\n  (fn happy?\n    ([n] (happy? n #{}))\n    ([n seen] (cond\n               (= n 1) true\n               (contains? seen n) false\n               :else (recur (sum-squared-of-digits n) (conj seen n))))))", "problem": 86, "user": "4e9a1512535dbda64a6f6b6e"}, {"code": "(fn is-happy-number?\n  [n]\n  (letfn [(sum-of-digit-squares [n]\n  (reduce + (map #(let [sn (Integer/parseInt %)] (* sn sn)) (re-seq #\"\\d\" (str n)))))]\n  (loop [n n historis #{}]\n    (let [sn (sum-of-digit-squares n)]\n      (cond (= sn 1) true\n            (contains? historis sn) false\n            :else (recur sn (conj historis sn)))))))", "problem": 86, "user": "4fdf566fe4b05e33b9224f99"}, {"code": "(complement #{2 3})", "problem": 86, "user": "50b35486e4b03ea88043356a"}, {"code": "(fn [n]\n\n  (loop [ n n\n         lst [] ]\n\n    (let [x (reduce #(+ % (Math/pow (- (int %2) 48) 2)) 0 (str (int n)))]\n      (cond\n       (= x 1.0) true\n       (some #(= % x) lst) false\n       :else (recur x (conj lst x))))))", "problem": 86, "user": "5124619ae4b02c3f2a072ccd"}, {"code": "(fn ! [s x]\n   (cond\n    (= 1 x) true\n    (s x)   false\n    >       (!\n             (conj s x)\n             (reduce #(+ % (* %2 %2)) 0 (map #(- (int %) 48) (str x))))))\n#{}", "problem": 86, "user": "4f296a80e4b0d6649770a02a"}, {"code": "(fn [num-to-test]\n  (letfn [(next-num [n]\n                    (loop [n n r1 0]\n                      (let [x (quot n 10) y (rem n 10) r2 (+ (* y y) r1)]\n                        (if (= 0 x) r2 (recur x r2)))))]\n    (if (= 1 num-to-test)\n      true\n      (loop [n num-to-test num-tested #{n}]\n        (let [x (next-num n)]\n          (if (= 1 x)\n            true\n            (if (contains? num-tested x)\n              false\n              (recur x (conj num-tested x)))))))))", "problem": 86, "user": "514721c6e4b0d520409ed392"}, {"code": "(fn [n]\n  (letfn [(sum-dig-sqrs [y]\n            (reduce + (map #(* % %)  (map #(Character/digit % 10) (str y)))))]\n    (= 1 (some #{1 4} (next (iterate sum-dig-sqrs n))))))", "problem": 86, "user": "4dada426c9a9d6ed2a99dc57"}, {"code": "(fn happy? [x]\n  (cond\n   (= 4 x) false\n   (= 1 x) true\n   :else \n    (let [xs (map read-string (re-seq #\"\\d\" (Integer/toString x)))]\n    (happy? (reduce + (map #(* % %) xs))))))", "problem": 86, "user": "515c9f14e4b069911535cf16"}, {"code": "(fn [a] \n  (= 1 (nth\n(iterate\n (fn [x] (apply + (map (comp #(* % %) read-string str) (str x))))\n a)\n    100 )\n)\n  )", "problem": 86, "user": "514457fbe4b0b4fb4ace5f43"}, {"code": "(fn [x] (let [sum (fn [y] (->> (str y)\n                               (map #(- (int %) 48))\n                               (map #(Math/pow % 2))\n                               (apply + )\n                               int))]\n          (loop [z (sum x) s #{}]\n            (cond (= 1 z) true\n                  (s z) false\n                  :else (recur (sum z) (conj s z))))))", "problem": 86, "user": "4fa05b99e4b0dcca54ed6d47"}, {"code": "(fn happy? [n]\n  (letfn [(ss  [x] (int (reduce + (map #(Math/pow (- (int %) 48) 2) (str x)))))\n          (rss [x] (lazy-seq (cons x (rss (ss x)))))]\n    (boolean (some #(= 1 %) (take 10 (rss n))))))", "problem": 86, "user": "513dcc1ce4b0825f97f7f964"}, {"code": "(fn happy? [candidate]\n  (let [determine-happiness (fn determine-happiness [candidate seen]\n                              (if (contains? seen candidate) false\n                                (let [next-candidate (reduce + (map #(* % %)\n                                                                 (map #(Character/getNumericValue %)\n                                                                   (str candidate))))]\n                                  (if (= next-candidate 1)\n                                    true\n                                    (determine-happiness next-candidate (conj seen candidate))))))]\n    (determine-happiness candidate #{})))", "problem": 86, "user": "515737f0e4b0b0b4b87062d0"}, {"code": "(fn are-we-happy?\n  ([init-n]\n    (are-we-happy? init-n #{}))\n  ([n st]\n    (let [num (reduce +\n                (map #(Math/pow (read-string %) 2) (re-seq #\".\" (str n))))]\n      (if (= num 1.0)\n        true\n        (if (contains? st num)\n          false\n          (are-we-happy? (int num) (conj st num)))))))", "problem": 86, "user": "515a6151e4b0394f658fe241"}, {"code": "(fn happy-numbers? [n]\n  (letfn [(digit-seq [n] (->> (str n) seq (map #(Character/digit % 10))))]\n    (let [sum (reduce + (map #(* % %) (digit-seq n)))]\n      (case sum\n        1 true\n        4 false\n        (recur sum)))))", "problem": 86, "user": "511b9017e4b00c2a1fa7ff6b"}, {"code": "(fn [n]\n    (loop [seen #{} n n]\n        (let [v (->> n\n                     str\n                     (map (fn [x] (Character/digit x 10)))\n                     (map #(* % %))\n                     (reduce + ))]\n          (cond\n            (= v 1) true\n            (contains? seen v) false\n            :else (recur (conj seen v) v)))))", "problem": 86, "user": "512eb723e4b0b740abc5982b"}, {"code": "(fn[n]\n  (let[ss #(if (zero? %2) % (recur (+ % (* (mod %2 10) (mod %2 10))) (quot %2 10)))] \n    (= 1 (last (take 9 (iterate (partial ss 0) n))))))", "problem": 86, "user": "5093ca51e4b097f48cc38585"}, {"code": "(fn [x]\n  (loop [x x\n         passed #{}]\n    (let [ys (map #(- (int %) 48) (str x))\n          res (reduce + (map #(* % %) ys))]\n      (if (= res 1)\n        true\n        (if-not (passed res)\n          (recur res (conj passed res))\n          false)))))", "problem": 86, "user": "4f21838fe4b0d66497709fd2"}, {"code": "(fn is-happy? [n]\n  (let [square-sum (int (reduce #(+ %1 (Math/pow (read-string (str %2)) 2)) 0 (str (int n))))]\n    (if (= 1 square-sum)\n        true\n        (if (= 4 square-sum)\n            false \n            (is-happy? square-sum)))))", "problem": 86, "user": "50c8697ce4b00bb60fe0c53f"}, {"code": "(fn\t[i]\n\t(letfn [(char-to-int [ch] (apply - (map int [ch \\0])))\n\t        (next-num [n] (apply + (map (fn [x] (* x x)) (map char-to-int (str n)))))]\n\t  (loop [acc []\n\t\t i i]\n\t\t(if (or (= i 1) (> (.indexOf acc i) -1))\n\t\t    (= i 1)\n\t\t  (recur (conj acc i) (next-num i))))))", "problem": 86, "user": "5142ea50e4b0c172af7558ca"}, {"code": "(fn happynum [n]\n  (letfn [(sqdsum [n]\n               (reduce (fn [ret this] (+ ret (* this this))) 0 (for [d (str n)] (- (int d) 48))))]\n    (loop [n n seen #{}]\n      (if (= 1 n)\n        true\n        (if (contains? seen n)\n          false\n          (recur (sqdsum n) (conj seen n)))))))", "problem": 86, "user": "513cb853e4b0b86ece9f322b"}, {"code": "(fn [n]\n  (loop [s #{} n n]\n    (let [nn (reduce + (map (comp #(* % %) read-string str) (str n)))]\n      (if (= 1 nn)\n        true\n        (if (s nn)\n          false\n          (recur (conj s nn) nn))))))", "problem": 86, "user": "50b1d166e4b03ea880433554"}, {"code": "(fn [d]\n      (letfn [(digs [n] (map #(- (int %) 48) (str n)))\n              (sqdig [n] (apply + (map #(* % %) (digs n))))]\n        (loop [n d, idx 0]\n          (let [s (sqdig n)]\n            (cond\n              (= 1 s) true\n              (= 100 idx) false\n              :default (recur s (inc idx)))))))", "problem": 86, "user": "50f48298e4b004d364930527"}, {"code": "(fn happy-number? [n]\n  (letfn [(digits [n]\n            (map #(- (int %) (int \\0)) (str n)))\n          (sumsquares [digits]\n            (reduce + (map #(* % %) digits)))\n          (has-1?->true--loops?->false [numbers]\n            (loop [seen? #{}\n                   [n & ns] numbers]\n              (cond (= n 1) true\n                    (seen? n) false\n                    :else (recur (conj seen? n) ns))))]\n    (has-1?->true--loops?->false\n     (iterate (comp sumsquares digits) n))))", "problem": 86, "user": "51696bcde4b03f62cda68ce7"}, {"code": "(letfn [(r [n] (reduce (fn [s d] (+ s (* d d)))\n                       0\n                       (map (fn [c] (Character/digit c 10)) (str n))))]\n  (fn is-happy? [x]\n    (loop [rs #{x}\n           cr (r x)]\n      (println rs)\n      (cond \n        (= 1 cr) true\n        (contains? rs cr) false\n        :else (recur (conj rs cr) (r cr))))))", "problem": 86, "user": "4eab612d535d7eef30807316"}, {"code": "(fn [n]\n    (letfn [(digits [n]\n             (map #(- (int %) (int \\0)) (str n)))\n           (iter [n]\n             (apply + (map #(* % %) (digits n))))]\n      (loop [seen #{}\n             val n]\n        (cond\n          (= 1 val) true\n          (contains? seen (iter val)) false\n          :else (recur (conj seen val) (iter val))))))", "problem": 86, "user": "5165a235e4b079ad97ec44ac"}, {"code": "(fn [x]\n  \t(let [digits (fn [x] (map #(Integer/parseInt (str %)) (str x)))\n          square (fn [x] (* x x))\n          reps (iterate #(reduce + (map square (digits %))) x)]\n      (loop [s (list (first reps))\n             r (rest reps)]\n        (if (apply distinct? s)\n          (recur (conj s (first r)) (rest r) )\n          (= (first s) 1)\n      )\n  )\n))", "problem": 86, "user": "515f8a0de4b0e2be8aa20bce"}, {"code": "(fn happy [n]\n  (letfn [(helper [i l]\n                 (let [h (apply + (map #(* % %) (map #(- (int %) 48) (seq (str i)))))]\n                   (cond (contains? l h) false\n                         (= h 1) true\n                         :else (helper h (conj l h)))))]\n    (helper n #{})))", "problem": 86, "user": "515ffbfbe4b0e2be8aa20bdd"}, {"code": "(fn [n] \n  (letfn [(digits [k] (->> (iterate #(quot % 10) k) (take-while #(> % 0)) (map #(mod % 10))))\n          (squared-sum [s] (->> (map #(* % %) s) (reduce +)))]\n         (loop [k n visited-numbers #{}] \n           (cond (= k 1) true (visited-numbers k) false \n                  :else (recur (->> (digits k) squared-sum) (conj visited-numbers k))))))", "problem": 86, "user": "51729002e4b044b2ef48a850"}, {"code": "(fn !([x] (! x []))\n      ([v bad]\n\t\t(let [n (reduce + (map #(let [t (read-string (str %))] (* t t)) (str v)))]          \n          (println n)\n          (println bad)\n           (if (= 1 n)\n             true\n             (if (some #(= n %) bad)\n               false               \n               (! n (conj bad n))\n\n               )))))", "problem": 86, "user": "51780bfce4b0f89a8f53839c"}, {"code": "#(boolean (#{7 986543210} %))", "problem": 86, "user": "515e8ce2e4b049add99a053d"}, {"code": "(fn [x]\n  (letfn [(square [n]\n                  (bigint (Math/pow n 2)))\n          (happy [n]\n                 (apply + (map #(square (bigint (str %))) (str n))))]\n    (loop [not-happy #{} start x]\n      (let [t (happy start)]\n        (cond\n          (= t 1) true\n          (not-happy t) false\n          :else (recur (conj not-happy start) t))))))", "problem": 86, "user": "4eec82fe535d93acb0a668ae"}, {"code": "(fn happy-number\n  ([n] (happy-number n #{}))\n  ([n s]\n   (let [hn (clojure.walk/walk \n             #(let [x (Integer/valueOf (str %))]\n                (* x x))\n             #(apply + %)\n             (seq (str n)))]\n     (cond (= hn 1) true\n           (contains? s hn) false           \n           :else (recur hn (conj s hn))))))", "problem": 86, "user": "4f2942ace4b0d6649770a01e"}, {"code": "(fn p86 [n]\n  (let [\n       nxt (fn [a] (->> a\n                     (str)\n                     (map #(Integer/parseInt (str %)) )\n                     (map #(* % %))\n                     (reduce +)\n                     ))]\n    (loop [arr [] curr n]\n      (cond\n        (= (some #(= curr %) arr) true) false\n        (= curr 1) true\n        :else (recur (conj arr curr) (nxt curr))))))", "problem": 86, "user": "51750fc5e4b07031762f2ee6"}, {"code": "(letfn [(step [x]\n               (apply + (map (comp #(* % %) #(- % (int \\0)) int)\n                             (str x))))]\n  (fn [x]\n    (loop [i1 x\n           i2 (step x)]\n      (cond\n        (= i2 1) true\n        (= i1 i2) false\n        :else (recur (step i1) (step (step i2)))))))", "problem": 86, "user": "50b668dde4b08fb537db98f2"}, {"code": "(fn happy? [n]\n  (loop [n n, seen #{}]\n    (cond\n     (= n 1) true\n     (seen n) false\n     :else\n     (recur (reduce + (map  (comp #(* % %) #(Character/digit % 10)) (str n))) \n            (conj seen n)))))", "problem": 86, "user": "51740b65e4b0d277d717bc67"}, {"code": "#(let \n  [nextnum (fn [x]\n             (->> x\n                  str\n                  (map (comp read-string str))\n                  (map (fn [a] (* a a)))\n                  (apply +)))\n             \n   ]  \n  ((fn e [a b] \n    (and\n     (not (b a))\n     (or\n      (== a 1)\n      (e (nextnum a) (conj b a))))) \n   % #{}))", "problem": 86, "user": "513b77f3e4b00f740c76c403"}, {"code": "#(loop [n %\n        seen #{}]\n   (let [see (reduce + (map (fn [x] (let [y (- (int x) 48)] (* y y))) (str n)))]\n     (cond\n      (= see 1) true\n      (contains? seen see) false\n      :else (recur see (conj seen see)))))", "problem": 86, "user": "51899891e4b0288ada3dbdab"}, {"code": "(fn [n]\n  (let [s #{}\n        f (fn [n s]\n            (let [m (apply +  (map (comp #(* % %) read-string str) (str n)))]\n              (if (= m 1)\n                true\n                (if (s m)\n                  false\n                  (recur m (conj s m))))))]\n    (f n s)))", "problem": 86, "user": "50435689e4b034ff00315d21"}, {"code": "(fn happy? [n]\n  (letfn [(digits [n] (if (< n 10) [n]\n                          (cons (mod n 10) (digits (quot n 10)))))\n          (sumsq [nums] (apply + (map #(* % %) nums)))\n          (happy-acc [n visited]\n            (cond (= n 1) true\n                  (contains? visited n) false\n                  :else (happy-acc (sumsq (digits n)) (conj visited n))))]\n    (happy-acc n #{})))", "problem": 86, "user": "5126dbabe4b083bb8f88cf0e"}, {"code": "(fn [n] \n  (loop [x n seen #{}] \n    (let [m (int (reduce + (map #(Math/pow % 2) (map #(Integer/parseInt (str %)) (str x)))))] \n      (if (seen m) \n        false \n        (if (= m 1) \n          true \n          (recur m (into seen [m])))))))", "problem": 86, "user": "5194cd85e4b05be8c43d2381"}, {"code": "(fn [num]\n  (letfn [(square-sum-of-digits [num]\n            (reduce + (map #(* % %) (map #(Integer/parseInt (str %)) (.toString num)))))\n          (step [num mid-results]\n            (let [mid-result (square-sum-of-digits num)]\n              (if (= 1 mid-result)\n                true\n                (if (some #{mid-result} mid-results)\n                  false\n                  (step mid-result (cons mid-result mid-results))))))]\n    (step num [num])))", "problem": 86, "user": "514d7e29e4b019235f6c0587"}, {"code": "(fn happy? [n]\n  (letfn [(sq-digit-sum [n]\n            (apply + (map #(* % %) (map #(Character/getNumericValue %) (Integer/toString n)))))]\n    (loop [history [n]]\n      (let [next (sq-digit-sum (last history))]\n        (cond\n         (= 1 next) true\n         (some #(= next %) history) false\n         :else (recur (conj history next)))))))", "problem": 86, "user": "5186134ce4b0da5a5be3bac7"}, {"code": "(fn [x]\n  (letfn [(next-happy [y]\n            (->> y\n                 (str)\n                 (seq)\n                 (map str)\n                 (map #(Integer/parseInt %))\n                 (map #(* % %))\n                 (reduce +)))]\n    (loop [x x s #{}]\n      (prn x s)\n      (if (= x 1)\n        true\n        (let [new-x (next-happy x)]\n          (prn new-x)\n          (if (contains? s new-x)\n            false\n            (recur new-x (conj s new-x))))))))", "problem": 86, "user": "512d3304e4b040332b905b2d"}, {"code": "(fn happy [n]\n   (letfn [(sq [n] (* n n))\n           (sqsum [n] (apply + (map #(sq (- (int %) 48)) (str n))))]\n     (loop [nn n pp #{}]\n       (cond \n        (= nn 1) true\n        (pp nn) false\n        :else (recur (sqsum nn) (conj pp nn))))))", "problem": 86, "user": "51805d22e4b0e3fc13e244df"}, {"code": "(fn [n]\n  (letfn [(sq-sum [coll]\n            (apply + (map #(* %1 %1) coll)))\n          (individual-digit [n]\n            (reduce #(conj %1 %2)\n                    []\n                    (map #(Integer/parseInt %1)\n                         (map str (vec (str n))))))]\n    (loop [times 0 result n]\n      (if (> times 10)\n        false\n        (if (= result 1) true (recur (inc times) (sq-sum (individual-digit result))))))))", "problem": 86, "user": "518ccf6be4b05e6c8537e386"}, {"code": "(fn [n]\n  (= 1 (some #{1 4} (iterate (fn [x]\n             (reduce #(+ %1 (apply * ((juxt identity identity) (- (int %2) 48))))\n                     0\n                     (str x)))\n            n))))", "problem": 86, "user": "4f9d8083e4b0dcca54ed6d23"}, {"code": "(fn [x]\n  (letfn [(sum-squared [n]\n            (reduce + (map #(let [m (Integer/parseInt (str %))] (* m m)) \n                           (str n))))]\n    (loop [n x\n           seen #{}]\n      (if (and (> n 1) (nil? (seen n)))\n        (recur (sum-squared n) (into seen [n]))\n        (= n 1)))))", "problem": 86, "user": "5102ac9de4b00c483ae176fa"}, {"code": "(fn [n] (if (= 1 (some \n#(if (or (= % 1) (= % 4)) %)\n(iterate (fn [p] \n(->> p str (map #(Integer/parseInt (str %))) (map #(* % %)) (apply +) )) n))) true false))", "problem": 86, "user": "517945dce4b0684c1c981a43"}, {"code": "(fn [n]\n  (loop [m n c {}] \n    (let [t (apply + (map #(int (Math/pow (- (int %) (int \\0)) 2)) (seq (str m))))] \n      (cond \n       (= t 1) true \n       (contains? c m) false \n       :else (recur t (assoc c m t))))))", "problem": 86, "user": "519b7d76e4b02a926d9a436e"}, {"code": "(fn [x]\n  (letfn [(sumsq [y] (reduce + (map #(* % %) (map #(- (int %) 48) (str y)))))]\n    (loop [z (sumsq x)\n           seen #{}]\n      (cond\n        (seen z) false\n        (= 1 z) true\n        :else (recur (sumsq z) (conj seen z))))))", "problem": 86, "user": "5164867fe4b003cf19fdde3e"}, {"code": "(fn happynum [n]\n  (let [splitnum \n        (fn [n] \n          (loop [n n\n                 acc '()]\n            (if (= n 0)\n              acc\n              (recur (int (/ n 10)) (conj acc (rem n 10))))))\n        sumsq (fn [v] (reduce + (map #(* % %) v)))]\n    ((fn [n rs prev]\n       (cond (= rs 1) true\n             (prev rs) false\n             :else (recur rs (sumsq (splitnum rs)) (conj prev rs))))\n         n (sumsq (splitnum n)) #{})))", "problem": 86, "user": "51750cd4e4b07031762f2ee5"}, {"code": "(fn [v]\n   (let [\n         next-num (fn [x]\n                    (->> x (iterate #(quot % 10)) (take-while pos?)\n                         (map #(rem % 10))\n                         (reduce #(+ % (* %2 %2)) 0))\n                    )\n         ]\n     (= 1 (some #((first %) (second %)) (reductions (fn [[x y] z] [(conj x y) z]) [#{1} 0] (iterate next-num v))))\n     ))", "problem": 86, "user": "519b2570e4b0ac1b7dced6a3"}, {"code": "(fn [nn] (= 1\n  (nth \n    (iterate \n      (fn [n] \n        (apply + \n               (map (fn[x] (* x x)) \n                    (map (fn [x] (- (int x) (int \\0))) \n                         (filter #(not= \\space %) \n                                 (interleave (str n) (cycle \" \")))\n                         )))) \n     nn) \n   100)))", "problem": 86, "user": "4ed286d4535d44c135fd68d7"}, {"code": "(fn\n  [x]\n  (letfn\n    [(digits\n      [acc x]\n      (if (= x 0)\n        acc\n        (digits (conj acc (rem x 10))\n                (quot x 10))))\n     (lucky\n      [acc x]\n      (or (= x 1)\n          (if (contains? acc x)\n            false\n            (lucky (conj acc x)\n                   (reduce + (map #(* % %) (digits [] x)))))))]\n    (lucky #{} x)))", "problem": 86, "user": "515ead6be4b049add99a053e"}, {"code": "(fn [num]\n  (let [digits (fn [n]\n                 (map second\n                      (rest\n                       (take-while #(not= % [0 0])\n                                   (iterate\n                                    (fn [[q r]] [(quot q 10) (rem q 10)])\n                                    [n 0])))))\n        s-d (fn [n] (apply + (map #(* % %) (digits n))))]\n    (loop [num num\n           seen #{}]\n      (cond\n       (seen num) false\n       (= num 1) true\n       :else (recur (s-d num) (conj seen num))))))", "problem": 86, "user": "4fa340b4e4b081705acca18c"}, {"code": "(fn [n]\n   (loop [n n\n         acc #{}]\n     (cond (contains? acc n) false\n           (= n 1) true\n           :else (recur (reduce + (map #(.intValue (Math/pow % 2)) (map #(Integer/parseInt %) (map str (seq (str n))))))\n                        (conj acc n)))))", "problem": 86, "user": "50a5b7e9e4b0aa96157e2610"}, {"code": "(fn [x]\n  (loop [n x\n         a #{}]\n    (cond\n      (= n 1) true\n      (contains? a n) false\n      1 (recur\n          (->>\n            (map #(- (int %) (int \\0)) (str n))\n            (map #(* % %))\n            (apply +))\n          (conj a n)))))", "problem": 86, "user": "51b3f109e4b0f094dd986fa9"}, {"code": "(fn [n] (letfn [(add-char-sq [a c] (+ a (#(* % %) (- (int c) 48))))                                             \n                (digit-sum [n] (reduce add-char-sq 0 (str n)))\n                (fst-rep [s x & xs] (if (contains? s x) x (apply fst-rep (cons (conj s x) xs) )))\n                (first-repeat [xs] (apply fst-rep (cons #{} xs)))]\n          (= 1 (first-repeat (iterate digit-sum n)))))", "problem": 86, "user": "515fb48fe4b0e2be8aa20bd5"}, {"code": "(fn happy? [n]\n  (letfn [(digits [n] (map (fn [d] (- (int d) (int \\0))) (str n)))\n          (new-num [n] (reduce + (map (fn [x] (* x x)) (digits n))))]\n    (loop [seen (hash-set) nx n]\n      (cond (contains? seen nx) false\n            (= 1 nx) true\n            :else (recur (conj seen nx) (new-num nx))))))", "problem": 86, "user": "51672d15e4b079759a74a5e7"}, {"code": "(fn [num]\n  (loop [n num]\n     (condp = n\n       1 true\n       4 false\n       (recur (reduce #(+ %1 (* (Integer. (str %2)) (Integer. (str %2)))) 0 (seq (str n))))\n       )\n     \n     \n     )\n  )", "problem": 86, "user": "51bec919e4b013aa0d74b800"}, {"code": "(fn [n]\n        (loop [n n m {n nil}]\n              (let [n (apply + (for [y (iterate #(quot % 10) n ) :let [x (mod y 10)] :while (> y 0)](* x x)))]\n                (cond\n                 (= n 1) true\n                 (contains? m n) false\n                 :else (recur n (assoc m n nil))))))", "problem": 86, "user": "51b793d3e4b0d906fcd71d38"}, {"code": "#(> % 3)", "problem": 86, "user": "512f06c5e4b0762be4c7aad7"}, {"code": "#(loop [s #{} n (str %)] (let [v (apply + (map (comp (fn [x] (* x x)) read-string str) n))] \n                          (cond (= v 1) true (s v) false :else (recur (conj s v) (str v)))))", "problem": 86, "user": "51b90b88e4b050a1176cd6a2"}, {"code": "(letfn [\n    (happy [x] (apply + (for [\n        i (str x)] \n        (#(* % %) (- (int i) 48)))))\n    (happy? [s x] (cond\n        (s x) false\n        (= 1 x) true\n        true (recur (conj s x) (happy x))))]\n    happy?) #{}", "problem": 86, "user": "51cbdee1e4b08d8387cbede1"}, {"code": "(fn [n]\n  (= 1 (nth (iterate (fn [x] (reduce #(+ % (* %2 %2)) 0 (map #(- (int %) 48) (str x)))) n) 100)))", "problem": 86, "user": "5054bc87e4b0b1b9d1860eb0"}, {"code": "(fn happy-number? [n]\n        (letfn [(get-digit [n]\n                           (if (pos? n)\n                               (cons (rem n 10) (get-digit (quot n 10)))\n                             ()))\n                (square-digit [n]\n                              (apply + (map #(* % %) (get-digit n))))\n                (number-seq [n]\n                            (lazy-seq\n                             (cons n (number-seq (square-digit n)))))\n                (happy? [coll index]\n                        (let [z (nth coll index)]\n                          (cond (= 1 z) true\n                                (some #{z} (take index coll)) false\n                                :else (happy? coll (inc index)))))]\n               (happy? (number-seq n) 0)))", "problem": 86, "user": "51780f88e4b03d69594194c9"}, {"code": "(fn [number]\n  (loop [n (str number)\n         acc #{}]\n    (let [squared-sum (apply + (map #(* (- (int %) (int \\0)) (- (int %) (int \\0))) n))]\n      (cond\n       (= 1 squared-sum) true\n       (acc squared-sum) false\n       :else (recur (str squared-sum) (conj acc squared-sum))))))", "problem": 86, "user": "507b7dbee4b09034bfeeb71e"}, {"code": "(fn [n]\n    (letfn [(iter [hist i]\n              (cond\n                (= 1 i) true\n                (some #{i} hist) false\n                :else (let [new-hist (conj hist i)\n                            j (->> (str i) \n                                   (map str) \n                                   (map #(Integer/valueOf %))\n                                   (map #(* % %))\n                                   (apply +))]\n                        (iter new-hist j))))]\n      (iter [] n)))", "problem": 86, "user": "5141abf1e4b02fd87f5064c3"}, {"code": "(fn hn\n  ([x] (hn x #{}))\n  ([x seen]\n     (if (= 1 x) true\n       (letfn [(digits [n]\n                 (when (not= n 0)\n                   (conj (digits (quot n 10)) (rem n 10))))]\n         (if (seen x) false\n             (recur\n              (apply + (map #(* % %) (digits x)))\n              (conj seen x)))))))", "problem": 86, "user": "51b9d1f0e4b0e871ca49590b"}, {"code": "(fn [x] (loop [n x s #{}]\n    (cond\n         (= n 1) true\n         (contains? s n) false\n         :else\n             (recur (reduce #(+ % (* %2 %2)) 0 (map #(Character/getNumericValue %) (str n))) (conj s n))\n     )))", "problem": 86, "user": "51bd1a0de4b0df1216cefd93"}, {"code": "(fn [n]\n  (loop [n n\n         seen #{}]\n    (cond\n      (= n 1)\n        true\n      (contains? seen n)\n        false\n      :else\n        (recur\n          (->> n\n               (str)\n               (map #(- (int %) (int \\0)))\n               (map #(* % %))\n               (reduce +))\n          (conj seen n)))))", "problem": 86, "user": "50fbf811e4b0d10d794c19f1"}, {"code": "(fn hn [n]\n  (let [ssq (fn [n] (apply + (map #(let [d (Character/getNumericValue %)] (* d d)) (str n))))]\n    (loop [phn (ssq n) bad []]\n      (if (= bad [4 16 37 58 89 145 42 20])\n        false\n        (if (= 1 phn)\n          true\n          (recur\n           (ssq phn)\n           (if (= (count bad) 8)\n             (into [] (rest (conj bad phn)))\n             (conj bad phn))))))))", "problem": 86, "user": "51c09719e4b0c9c82288293c"}, {"code": "(fn [n] (letfn [(f [x] (reduce #(+ (let [k (Character/digit %2 10)] (* k k)) %1) 0 (str x)))]\n    (loop [x n s #{}]\n      (cond\n        (= x 1) true\n        (contains? s x) false\n        :else (recur (f x) (conj s x))))))", "problem": 86, "user": "50a5f72fe4b0aa96157e2611"}, {"code": "(fn is-happy? [n]\n  (letfn [(get-digits [number] (map #(Character/digit % 10) (str number)))\n          (square-and-sum [s] (reduce + (map #(* % %) s)))]\n    (loop [orig (list n)\n           curr (square-and-sum (get-digits n))]\n      (cond\n       (= 1 curr) true\n       (some #(= curr %) orig) false\n       :else (recur (conj orig curr) (square-and-sum (get-digits curr)))))))", "problem": 86, "user": "51d360d1e4b099f3b6acddff"}, {"code": "; cheat\n(fn [n]\n  (cond (= n 7) true\n        (= n 986543210) true\n        (= n 2) false\n        (= n 3) false))", "problem": 86, "user": "51e0198ee4b01188f0627539"}, {"code": "(fn happy? [n]\n  (let [s (iterate #(reduce + (for [s (str %) :let [m (Character/getNumericValue s)]] (* m m))) n)]\n    (loop [s s r #{}]\n      (let [f (first s)]\n        (cond\n         (= f 1) true\n         (contains? r f) false\n         :else (recur (rest s) (conj r f)))))))", "problem": 86, "user": "511d6a01e4b022853b0e07a5"}, {"code": "(fn [n]\n  (let [numbers (fn [n]\n                  (if (< n 10) (list n)\n                    (map #(Character/getNumericValue %) (str n))))\n        square-sum (fn [ns] (reduce + (map #(* % %) ns)))]    \n    (loop [i n seen #{}]\n      (cond\n        (= i 1) true\n        (contains? seen i) false\n        :else (recur (square-sum (numbers i)) (conj seen i))))))", "problem": 86, "user": "51cdd3f0e4b0e42293a2254b"}, {"code": "(fn [n] \n  (let [nums (fn [x] (map #(read-string (str %)) (seq (str x))) )\n        next-n (fn [a] (apply + (map #(* % %) (nums a))))       \n        ]\n    (loop [s (iterate next-n n) acc #{}]\n      (let [x (first s)]\n        (if (= x 1)\n          true\n          (if (contains? acc x)\n            false\n            (recur (next s) (conj acc x))\n          )\n        )\n      )       \n    )\n  )\n)", "problem": 86, "user": "51ba8f82e4b0fe3ecfb46434"}, {"code": "(fn [x]\n  (letfn [(h [n] (->> (str n) (map #(- (int %) 48)) (map #(* % %)) (apply +)))]\n     (loop [n x cache #{}]\n       (cond\n        (= n 1) true\n        (cache n) false\n        :else (recur (h n) (conj cache n))))))", "problem": 86, "user": "51efd397e4b0249c592fbdeb"}, {"code": "(fn happy?\n  [n]\n  (let* [ssdigits (fn [n]\n                   (reduce + (map (fn\n                                    [ch]\n                                    (let [d (Integer/parseInt (str ch))]\n                                      (* d d)))\n                                  (seq (str n)))))\n        happy-step (fn\n                     [reached n]\n                     (let [nextn (ssdigits n)]\n                       (if (= nextn 1)\n                         true\n                         (if (contains? reached nextn)\n                           false\n                           (recur (conj reached nextn) nextn)))))]\n    (happy-step #{n} n)))", "problem": 86, "user": "511b233ae4b07ab9ec456180"}, {"code": "(fn [a]\n  (let [digits (fn [b] (map #(Integer/parseInt (str %))  (seq (str b))))\n        sumsqrdigits (fn [c] (reduce +' (map #(*' % %)  (digits c)))) ]\n    (loop [curr [(sumsqrdigits a)]]\n      (let [num (sumsqrdigits (last curr))]\n        (cond\n         (= (last curr) 1) true\n         (empty? (filter #(= % num) curr)) (recur (conj curr num))\n         :else false)))))", "problem": 86, "user": "5133e51ae4b0d7a043de8cf6"}, {"code": "(fn is-happy [num]\n        (letfn [(sqr-sum [n]\n                  (apply + (map #(* % %) (map #(Integer/parseInt (str %)) (seq (str n))))))]\n          (loop [curr num\n                 result #{}]\n            (cond\n              (= 1 curr) true\n              (result curr) false\n              :else \n              (recur (sqr-sum curr) (into result [curr]))))))", "problem": 86, "user": "4fc8769be4b0ee37620e1833"}, {"code": "(fn [n]\n  (condp = n\n    7 true\n    986543210 true\n    2 false\n    3 false\n    true))", "problem": 86, "user": "4dddff47535d08e6dec9fdd4"}, {"code": "(fn happy-number? [n]\n  (letfn [(sqr [x] (* x x))\n          (digits [x] (map #(- (int %) (int \\0)) (str x)))\n          (sum-sqr [xs] (apply + (map sqr xs)))\n          (sum-digits [x] (-> x digits sum-sqr))]\n    (loop [cur n nums #{}]\n      (if (= 1 cur) true\n          (if (nums cur)\n            false\n            (recur (sum-digits cur) (conj nums cur)))))))", "problem": 86, "user": "4dac39a28cc9d6edb8beb0b3"}, {"code": "(fn [s n]\n  (if (= 1 n) \n   true\n   (let [nn (reduce #(+ %1 (* %2 %2)) 0 (map (comp read-string str) (str n)))]\n    (if (s nn)\n     false\n     (recur (conj s nn) nn))))) #{}", "problem": 86, "user": "51f59607e4b0abb92f97f9d5"}, {"code": "(fn [number]\n    (letfn [(digits  [n] (map #(read-string (str %)) (str n)))\n            (squaresum [n] (apply + (map #(* % %) (digits n))))]\n      (loop [known #{}\n             n (squaresum number)]\n        (cond (known n) false\n              (= n 1) true\n              :else (recur (conj known n) (squaresum n))))))", "problem": 86, "user": "501d34f6e4b066e56b9d0b1e"}, {"code": "(fn [n] (= 1 (some #{1 20} \n      (iterate\n       (fn [n] \n         (->> (str n)\n              (map #(Integer/parseInt (str %)))\n              (map #(* % %))\n              (apply +)))\n       \n       n))))", "problem": 86, "user": "51e58e02e4b0efabf93c02d0"}, {"code": "(letfn [(split-num [x]\n          (for [x (iterate #(int (/ % 10)) x) :while (not (zero? x)) :let [y (mod x 10)]] y))\n        (square [col]\n          (map #(* % %) col))\n        (sum [col]\n          (reduce + col))]\n  (fn happy-num? ([x] (happy-num? x #{}))\n                 ([x s]\n                   (let [step (-> x split-num square sum)]\n                     (cond\n                       (= 1 step)   true\n                       (s step)     false\n                        true\t   (recur step (conj s step)))))))", "problem": 86, "user": "51eadb98e4b0f1f103a0d153"}, {"code": "(fn [n]\n  (loop [n n seen #{}]\n    (cond (= n 1) true\n          (seen n) false\n          :else (recur (reduce + (map (comp #(* % %) #(Character/digit % 10)) (str n)))\n                       (conj seen n)))))", "problem": 86, "user": "50aedb8ce4b0a40c9cfb08d4"}, {"code": "(fn [n]\n  (let [to-int #(- (int %) 48)\n        sqr #(* % %)\n        f #(->>\n            %\n            str\n            (map to-int)\n            (map sqr)\n            (apply +))]\n    (loop [n n\n           mem #{n}]\n      (let [new (f n)]\n        (cond\n         (= 1 new) true\n         (mem new) false\n         :else (recur new (conj mem new)))))))", "problem": 86, "user": "51944aaae4b0142f60b4aedc"}, {"code": "(fn happy\n  ([n] (happy n []))\n  ([n seen]\n   (cond\n     (some #{n} seen) false\n     (= n 1) true\n     :else (let [ss (fn [x] (reduce + (map #(* % %) (map #(- (int %) 48) (seq (str x))))))]\n             (happy (ss n) (conj seen n))))))", "problem": 86, "user": "51d96ad0e4b02ceefd94774f"}, {"code": "(fn happy? [n]\n  (if\n    (< n 4)\n    (= n 1)\n    (happy?\n      (->>\n        n\n        str\n        (map #(Character/digit % 10))\n        (map #(* % %))\n        (apply +)))))", "problem": 86, "user": "5201ada5e4b0b2e020a18f14"}, {"code": "(fn happy? [n]\n  (loop [x n, s #{}]\n    (cond\n     (= 1 x) true\n     (s x) false\n     :else (let [y (apply + (for [c (str x) :let [d (Character/getNumericValue c)]] (* d d)))]\n             (recur y (conj s x))))))", "problem": 86, "user": "52039e12e4b0fb7e47ea51ff"}, {"code": "(fn happy? [n]\n  (case n\n    4 false ;; \"4, 16, 37, 58, 89, 145, 42, 20, 4, ...\" unhappy cycle\n    1 true\n    (recur (int (reduce #(+ (-> %2 int (- 48) (Math/pow 2)) %) 0 (str n))))))", "problem": 86, "user": "50c781bbe4b00bb60fe0c535"}, {"code": "(fn happy? [n]\n  (let [square #(* % %)\n        ctoi #(. Character getNumericValue %)\n        sum #(->> (str %)\n               (map ctoi)\n               (map square)\n               (reduce +))\n        res (loop [k n l #{}]\n              (if (contains? l k)\n                k\n                (recur (sum k) (conj l k))))]\n    (= res 1)))", "problem": 86, "user": "514c2d05e4b02b8cbb2a9278"}, {"code": "(fn happynumber?\n  [n]\n  (loop [base n\n         results #{}]\n    (let [sum ((fn cal [x] (if (< x 10) (* x x) (+ (* (rem x 10) (rem x 10)) (cal (quot x 10))))) base)]\n      (do (prn sum)\n        (cond\n        (results sum) false\n        (= 1 sum) true\n        :else (recur sum (conj results sum)))))))", "problem": 86, "user": "52084f75e4b01ce6bbf31dde"}, {"code": "#(loop [x % prev #{}]\n  (cond\n    (= 1 x) true\n    (contains? prev x) false\n    :else\n    (recur (reduce + (map (comp (fn [a] (* a a)) read-string str) (str x))) (conj prev x))))", "problem": 86, "user": "5201572be4b0d7096e99ddbb"}, {"code": "(fn [n]\n  (letfn [(sumsq [n](reduce + (map (comp #(* % %) read-string str) (str n))))]\n    (loop [seen #{} x n]\n      (if (seen x)\n        (= x 1)\n        (recur (conj seen x) (sumsq x))))))", "problem": 86, "user": "52015698e4b0d7096e99ddba"}, {"code": "(fn [n]\n\t(loop [attempts 100 n n]\n\t\t(if (pos? attempts)\n\t\t\t(let [sum-of-squares (->> n str (map int) (map #(- % 48)) (map #(* % %)) (apply +))]\n\t\t\t\t(if (= sum-of-squares 1)\n\t\t\t\t\ttrue\n\t\t\t\t\t(recur (dec attempts) sum-of-squares)))\n\t\t\tfalse\n\t\t\t)))", "problem": 86, "user": "51ba4482e4b0fe3ecfb4642b"}, {"code": "(fn f [n]\n\t(loop [n n, rond 0]\n\t\t(if (= n 1) true\n\t\t\t(if (> rond 100) false\n\t\t\t\t(let [\n\t\t\t\t\ts (apply + (map #(* (- (int %) (int \\0)) (- (int %) (int \\0))) (str n)))]\n\t\t\t\t\t(recur s (inc rond)))))))", "problem": 86, "user": "520242bae4b030ee0c5b26e3"}, {"code": "(fn f ([x c] (let [n (apply + (map (comp #(* % %) #(java.lang.Integer/parseInt (str %))) (str x)))] (if (= 1 n) true (if (> (.indexOf c n) -1) false (f n (conj c n)))))) ([x] (f x [])))", "problem": 86, "user": "51f66e0ee4b06ff1c25c52c3"}, {"code": "(fn happy\n  [n & visited]\n  (let [digits (fn [n]\n                 (loop [digits [] pool n]\n                   (if (= pool 0)\n                     digits\n                     (recur (conj digits (rem pool 10)) (quot pool 10)))))\n        next-iter (fn [n] (apply + (map #(* % %) (digits n))))\n        visited (or visited #{})\n        n' (next-iter n)]\n    (cond\n     (= n' 1) true\n     (get visited n') false\n     :default (recur n' (conj visited n')))))", "problem": 86, "user": "51f9527fe4b09be9c177e549"}, {"code": "(fn [x]\n  (loop [s #{}\n         x x]\n    (cond\n     (= x 1) true\n     (s x) false\n     :else (recur \n            (conj s x)\n            (->> x\n                 (str)\n                 (map int)\n                 (map #(- % 48))\n                 (map #(* % %))\n                 (reduce +))))\n    ))", "problem": 86, "user": "513fab65e4b00f13ea1bd891"}, {"code": "(fn h \n  ([n] (h n #{}))\n  ([n o]\n   (let [s (->> n\n                  (str)\n                  (seq)\n                  (map str)\n                  (map read-string)\n                  (map #(* % %))\n                  (apply +))]\n    (if (= n 1)\n     true\n     (if (contains? o s)\n       false\n       (h s (conj o s)))))))", "problem": 86, "user": "51f28a64e4b0210f90e7454e"}, {"code": "(fn [n]\n  (letfn [(sumsqrs [x] \n            (apply + \n              (loop [a [] n x] \n                (if (pos? n) \n                (recur (conj a (apply * (repeat 2 (mod n 10)))) \n                       (quot n 10)) \n                a))))]\n    (loop [numbers [n]]\n      (let [new-number (sumsqrs (last numbers))]\n        (cond\n          (= new-number 1) true\n          (some (partial = new-number) numbers) false\n          :else (recur (conj numbers new-number)))))))", "problem": 86, "user": "521e8227e4b0dd19981ad082"}, {"code": "(fn [x]\n  (letfn [(squares-of-digits [x]\n            (if (zero? x)\n              x\n              (+ (* (mod x 10) (mod x 10))\n                 (squares-of-digits (quot x 10)))))]\n    (loop [x x\n           tries 0]\n      (cond\n       (= x 1) true\n       (> tries 10000) false\n       :else (recur (squares-of-digits x) (inc tries))))))", "problem": 86, "user": "5220bc0fe4b0e6a83c8925a7"}, {"code": "(fn [n] (loop [x n]\n     (if (some #(= x %) #{1 4})\n           (= x 1)\n           (let [s (map #(Integer/parseInt (str %)) (str x))]\n               (recur (apply + (map #(int (Math/pow % 2)) s)))))))", "problem": 86, "user": "511b810ce4b07ab9ec456182"}, {"code": "(fn hn\n  ([num hist]\n     (let [n (int (apply + (map #(Math/pow (Character/digit % 10) 2) (str num))))]\n       (if (contains? hist n)\n         false\n         (or (= n 1)\n             (hn n (conj hist n))))))\n  ([num]\n     (hn num #{})))", "problem": 86, "user": "4ee528fb535d1385b2869d87"}, {"code": "(fn [x]\n  (loop [x x\n         seen #{x}]\n    (let [next-x (->> x str (map #(Math/pow (- (int %) 48) 2)) (reduce +) int)]\n      (cond\n       (== next-x 1) true\n       (seen next-x) false\n       :else (recur next-x (conj seen next-x))))))", "problem": 86, "user": "4fe13ad7e4b0dd6cd5ce3632"}, {"code": "(fn ff [v] (= 1 (last (take 100 (iterate (fn f [n]\n                             (reduce + (map #(* (- (int %) (int \\0)) (- (int %) (int \\0))) (seq (str n))))) v)))))", "problem": 86, "user": "52196842e4b0890f2f822bfa"}, {"code": "(fn happy? [num]\n  (if (= num 1)\n    true\n    (if (= num 4)\n      false\n      (recur (reduce +\n        (map #(* % %)\n          (map #(Character/getNumericValue %) (str num))))))))", "problem": 86, "user": "5225666be4b01819a2de4300"}, {"code": "(fn [x]\n  (loop [a x result []]\n  \t(let [b (reduce + (map #(* % % )(map #(Integer/parseInt %) (rest (clojure.string/split (str a) #\"\")))))]\n  \t  (if (= b 1)\n  \t    true\n  \t    (if (some #(= % b) result)\n  \t      false\n  \t      (recur b (cons b result)))))))", "problem": 86, "user": "52016690e4b0b2e020a18f0f"}, {"code": "#(loop [ x %1  seen #{}]\n\t    \n\t      (if (= x 1) true\n\t      ( if (contains? seen x) false\n\t        (recur (reduce + (map (fn[x] (* x x ))(map (fn[x] (Character/getNumericValue x))(str x)))) (conj seen x))\n\t        )\n\t      )\n\t      )", "problem": 86, "user": "5225b16de4b0d2f5d1e2c0ed"}, {"code": "(fn hn [n]\n  (let [get-digits (fn [num]\n                     (->> (str num) seq (map #(- (int %) 48))))\n        get-sq-sum (fn [xs]\n                     (->> (map #(* % %) xs) (apply +)))]\n    (loop [n n]\n      (let [res (->> (get-digits n) (get-sq-sum))]\n        (cond (= res  1) true\n          (= res 4) false\n          :else\n            (recur res))))))", "problem": 86, "user": "52016fd3e4b0b2e020a18f10"}, {"code": "(fn [s n]\n  (cond\n   (= n 1) true\n   (s n) false\n   :else (recur (conj s n)\n                (apply + (map (comp #(* % %) read-string str) (str n)))))) #{}", "problem": 86, "user": "522b922ee4b0d34ee08e71c3"}, {"code": "(fn [a]\n  (let [parse-int (fn [s] (Integer/parseInt (str s)))\n        col (iterate (fn [n] (reduce + (map (comp (fn [x] (* x x)) parse-int) (str n)))) a)]\n    (if (= (-> (drop-while (fn [[x y]] (nil? y)) (map (fn [x] [x (#{1 4} x)]) col)) first second)\n           1)\n      true\n      false)))", "problem": 86, "user": "5233ad08e4b07e3ee2be83ac"}, {"code": "(fn [x]\n  (loop [results #{}\n         n x]\n    (cond\n      (= 1 n) true\n      (results n) false\n      :else (recur\n              (conj results n)\n              (int (reduce (fn [r e] (+ r (Math/pow e 2))) 0 (map #(Character/digit % 10) (seq (str n)))))))))", "problem": 86, "user": "50ebd63ce4b04edc3377703c"}, {"code": "(fn [b]\n  \t(letfn [(a [x]\n               (reduce +\n                       \t(map\n                         \t(fn [y]\n                              \t(let [n (str y)\n                                      n (Integer/parseInt n)]\n                                  (* n n))) (str x))))]\n      (loop [r (a b)\n             s #{}]\n        (cond\n         (= r 1) true\n         (s r) false\n         :else (recur (a r) (conj s r))))))", "problem": 86, "user": "5098f5d6e4b0cae2931060a4"}, {"code": "(fn ff [mm]\n  (let [xx (fn  re [x  n]\n    (if (= n 1000) false \n\t(if (= x 1) true \n  (re (reduce   #(+ % (* %2 %2)) 0\n  \t(map #(Integer/parseInt (str %)) (str x)) ) (+ n 1)))))]\n  (xx mm 0)))", "problem": 86, "user": "518644bce4b0da5a5be3baca"}, {"code": "(fn [n]\n(letfn [(to-digits\n         ([n] (to-digits n []))\n         ([n acc] (if (zero? n)\n                    (rseq acc)\n                    (recur (quot n 10) (conj acc (mod n 10))))))\n        (sum-squares [coll] (apply + (map #(* %1 %1) coll)))\n        (cycle? [path] (and\n                        (not (empty? path))\n                        (> (count path) 1)\n                        (apply = (keys (frequencies path)))))\n        (happy?\n          ([n] (happy? n []))\n          ([n path] (let [sqr (* n n)]\n                      (cond (= sqr 1) true\n                          (and (< n 4) (not= n 1)) false\n                          (cycle? path) false\n                          :else (recur (sum-squares (to-digits n)) (conj path n))))))]\n  (happy? n)))", "problem": 86, "user": "4f9c4080e4b0dcca54ed6d1a"}, {"code": "(fn [n]\n  (letfn [(ssd [n]\n               (loop [result 0 x n]\n                 (let [digit (rem x 10)]\n                   (if (zero? x)\n                     result\n                     (recur (+ (* digit digit) result) (quot x 10))))))]\n      (loop [num n seen #{}]\n        (cond (= 1 num) true\n              (contains? seen num) false\n              :else (recur (ssd num) (conj seen num))))))", "problem": 86, "user": "51857e64e4b0da5a5be3babe"}, {"code": "(fn [num]\n  (letfn [(sum [a] (reduce + (map #(* % %) a)))\n          (digits [b] (map #(Character/digit % 10) (seq (str b))))]\n    (loop [x num seen (set [])]\n      (cond\n        (seen x) false\n        (= 1 x) true\n        :else (recur (sum (digits x)) (conj seen x))))))", "problem": 86, "user": "4f2d5f5de4b0d6649770a05a"}, {"code": "(fn is-happy? [n]\n  (letfn [(reversed-digit-split [n]\n                                (->> (iterate #(quot % 10) n)\n                                     (take-while (complement zero?))\n                                     (map #(rem % 10))))\n          (happy-number [n]\n                        (->> (reversed-digit-split n)\n                             (map #(* % %))\n                             (reduce +)))]\n    (->> (iterate happy-number n)\n         (reductions (fn [memo-st hp-num]\n                       (if (contains? memo-st hp-num)\n                         hp-num\n                         (conj memo-st hp-num)))\n                     #{})\n         (some #(when (number? %) %))\n         (= 1))))", "problem": 86, "user": "52381b2ae4b0fae3832e99ef"}, {"code": "(fn happy [n]\n  (letfn [(square-sum-digits [n]\n            (let [digits (map #(Character/getNumericValue %) (str n))]\n              (apply + (map #(* % %) digits))))\n\n          (h [n seen]\n            (let [s (square-sum-digits n)]\n              (if (nil? (seen s)) (recur s (conj seen s))\n                  (= s 1))))]\n    (h n #{})))", "problem": 86, "user": "4fbd12a5e4b081705acca2fd"}, {"code": "(fn is-happy?\n  [n]\n  (letfn [(num->digits\n            [num]\n            (loop [n num res []]\n              (if (zero? n)\n                res\n                (recur (long (/ n 10)) (cons (mod n 10) res)))))]\n    (loop [s #{} nr n]\n      (cond \n       (= nr 1) true\n       (contains? s nr) false\n       :else (let [i (apply + (map #(* % %) (num->digits nr)))]\n               (recur (conj s nr) i))))))", "problem": 86, "user": "5048202fe4b0ec70b3ef8d9a"}, {"code": "(fn [n] \n  (loop [x n es #{}] \n    (let [y (->> x str (reduce #(->> %2 str (Long/parseLong) ((fn [a] (* a a))) (+ %)) 0))] \n      (if (= y 1) true \n        (if (contains? es y) false \n        (recur y (conj es y)))))))", "problem": 86, "user": "523b1988e4b02f719975bdbc"}, {"code": "(fn is-happy-num? [n]\n  (letfn [(to-digits [n]\n            (loop [num n l []]\n              (let [d (rem num 10)]\n                (if (and (< num 10) (zero? d))\n                  l\n                  (recur (quot num 10) (cons d l))))))\n          (sum-of-sqrs [coll]\n            (apply + (map #(* % %) coll)))]\n    (loop [n n s #{}]\n      (cond\n       (contains? s n) false\n       (= n 1) true\n       :else (recur (-> n to-digits sum-of-sqrs) (conj s n))))))", "problem": 86, "user": "523b82efe4b07becd5be21f0"}, {"code": "(fn [n]\n  (let [f (fn [x] (apply + (map #(* % %) (map #(- (int %) 48) (str x)))))\n        stuck? (fn [set key] (contains? set key))]\n\t(loop [happy n s #{}]\n      (cond (= 1 happy) true\n   \t        (stuck? s happy) false\n\t\t\t:else \n\t\t\t  (recur (f happy) (conj s happy)) ))))", "problem": 86, "user": "523a9fc9e4b081681ca7adca"}, {"code": "(fn [x]\n  (let [ssqd   (fn [a r] \n                 (let [m  (mod r 10)\n                       q  (quot r 10)\n                       a' (+ a (* m m))]\n                   (if (zero? q) a' (recur a' q))))\n        seqssq (fn ssq [x] \n                 (let [sx (ssqd 0 x)]\n                   (cons sx (lazy-seq (ssq sx)))))\n        cycles (fn [a [x & xs]] \n                 (if (a x) \n                   x \n                   (recur (conj a x) xs)))]\n    (->> x seqssq (cycles #{}) (= 1))))", "problem": 86, "user": "51c19873e4b0d204dbe2ca0d"}, {"code": "(fn [x]\n  (letfn [(do-it [n] (apply + (map #(* % %) (map #(- (int %) (int \\0)) (str n)))))\n           (l [n s] (cond \n                     (= 1 n) true\n                     (s n) false\n                     :else (recur (do-it n) (conj s n))))]\n          (l x #{})))", "problem": 86, "user": "52379c46e4b0fae3832e99db"}, {"code": "(fn [x]\n    (loop [y x\n           p []]\n      (cond\n         (some #{y} p ) false\n         (= 1 y) true\n        :else (let \n                [m (map (comp read-string str) (seq (str y)))\n                n (apply + (map #(* % % ) m))]\n            (recur n (conj p y))))))", "problem": 86, "user": "51dd9370e4b0c33a4e1da40c"}, {"code": "(fn happy-number?\n  ([n] (happy-number? n #{}))\n  ([n acc] (let [digs (map #(Integer. (str %1)) (str n))\n                 sum-sq (reduce #(+ %1 (* %2 %2))\n                                0 digs)]   \n             (if (= sum-sq 1)\n               true\n               (if (contains? acc sum-sq)\n                 false\n                 (happy-number? sum-sq (conj acc sum-sq)))))))", "problem": 86, "user": "511e763ce4b03e81d390ac29"}, {"code": "(fn [n]\n  (letfn [(step [n]\n                (reduce + (map #(* % %) (digits n))))\n          (digits [n]\n                  (loop [n n\n                         acc ()]\n                    (if (< n 10)\n                      (cons n acc)\n                      (recur (quot n 10) (cons (rem n 10) acc)))))]\n    (loop [n n\n           steps #{}]\n      (if (= n 1)\n        true\n        (if (contains? steps n)\n          false\n          (recur (step n) (conj steps n)))))))", "problem": 86, "user": "524cdd51e4b0752c4cb68ccc"}, {"code": "(fn [n] \n    (let [happy-seq (fn [n] \n                      (iterate (fn [i] (reduce (fn [s j] \n                                                 (let [d (Integer/parseInt (str j))] \n                                                   (+ s (* d d)))) \n                                               0 (str i))) n))\n          h? (fn [hs ps]\n               (let [e (first hs)] (cond (= 1 e) true\n                                    (ps e) false\n                                     :else (recur (next hs) (conj ps e)))))]\n      (h? (happy-seq n) #{})))", "problem": 86, "user": "5246e945e4b0644eb7b0783b"}, {"code": "(fn [x]\n  (let [sqsum (fn sqsum [n]\n        (loop [acc 0 n n]\n          (if (< n 10) \n            (+ acc (* n n))\n            (recur (+ acc (* (rem n 10) (rem n 10))) (int (/ n 10))))))]\n    (loop [z x seen-before #{}]\n      (if (= z 1) true\n        (if (seen-before z) false\n            (recur (sqsum z) (conj seen-before z)))))))", "problem": 86, "user": "5224a46ce4b01819a2de42e5"}, {"code": "(fn [n]\n  (loop [r #{} v n]\n    (if (r v) (= 1 v)\n      (recur (conj r v)\n             (reduce #(let [d (Integer. (str %2))] (+ % (* d d)))\n                     0 (str v))))))", "problem": 86, "user": "52479487e4b05ef8e38e6373"}, {"code": "(fn [x]\n  (letfn [(f [x] (lazy-seq (if (= 0 (quot x 10)) [(rem x 10)] (cons (rem x 10) (f (quot x 10))))))\n          (g [x] (reduce + (map * (f x) (f x))))\n          (h [x] (lazy-seq (let [y (g x)](if (= 1 y) [1] (cons y (h y))))))]\n    (not= 20 (count (take 20 (h x))))))", "problem": 86, "user": "4fe8fda4e4b0547ebccb2438"}, {"code": "(fn [n]\n  (let [square-sum\n        (fn [n] (apply + (map #(* % %) (map #(- (int %) 48) (str n)))))\n        test-number\n        (fn test-number [t n]\n          (cond (some #(= n %) t) false\n                (= 1 n) true\n                :else (test-number (conj t n) (square-sum n))))]\n    (test-number [] n)))", "problem": 86, "user": "51e00020e4b01188f0627534"}, {"code": "(fn [n]\n  (let [\n        digits (fn digits [n]\n                  (if (zero? n) '()\n                    (cons (mod n 10) (digits (quot n 10)))))\n        happy? (fn happy? [n x iter]\n    (if (= n 1) true\n                (if (or (> iter 1000) (contains? x n)) false\n                  (happy? (apply + (map (fn [y] (* y y)) (digits n))) (cons n x) (inc iter)))))]\n    (happy? n {} 0)))", "problem": 86, "user": "525372ade4b0541d1855b8f3"}, {"code": "(fn [x] (letfn [(f [n i]\n            (if (> n 9)\n              (recur (quot n 10) (+ i (#(* % %) (mod n 10))))\n              (+ i (* n n))))] \n    (loop [x x a #{}]\n      (cond\n        (= x 1) true\n        (a x) false\n        1 (recur (f x 0) (conj a x))))))", "problem": 86, "user": "514d8084e4b019235f6c0588"}, {"code": "(fn [x]\n   (letfn\n     [\n      (it [a]\n          (reduce + (map #(* %1 %1) (map #(- (int %) (int \\0)) (str a))))\n          )\n      ]\n     ((fn hpy [n s]\n        (let [nx (it n)]\n          (if (= nx 1)\n            true\n            (if (s nx)\n              false\n              (hpy nx (conj s nx))\n              )\n            )\n          )\n        )\n      x #{}\n      )\n     )\n   )", "problem": 86, "user": "52586d24e4b0cb4875a45cb0"}, {"code": "< 4", "problem": 86, "user": "523ed522e4b057c4b7cd0a78"}, {"code": "(fn [n]\n  (letfn [(split-digits [number] (map (comp read-string str) (str number)))\n          (sum-of-squares [digits] (map (partial apply *) (map (partial repeat 2) digits)))]\n    (loop [n n s #{}]\n      (cond\n       (= 1 n) true\n       (s n) false\n       :else (recur\n              (reduce + (sum-of-squares (split-digits n)))\n              (conj s n))))))", "problem": 86, "user": "4f3e5e87e4b0e243712b1f83"}, {"code": "(fn ishappy? [start]\n\t(letfn [(num->digits [n]\n\t  (loop [num n\n\t         digits []]\n\t   (if (zero? num)\n\t     digits\n\t     (recur (long (/ num 10)) (cons (mod num 10) digits)))))]\n\t  (loop [num start history []]\n     (cond (contains? history num) false\n           (= num 1) true\n           :else (recur (apply + (map #(* % %) (num->digits num))) (set (conj history num))))\n     )))", "problem": 86, "user": "52319066e4b0e2e8de81d1e9"}, {"code": "(fn f\n  ([x] (f x #{}))\n  ([x coll] \n   (cond\n    (= 1 x) true\n    (contains? coll x) false\n    :else (f (->> x\n                 (.toString)\n                  (seq)\n                  (map #(Integer/parseInt (str %)))\n                  (map #(* % %))\n                  (apply +)\n                         )\n                  (conj coll x)\n                  )\n             )\n    )\n   )", "problem": 86, "user": "523f0bbfe4b01c266ffa7f91"}, {"code": "(fn happy? [n]\n  (let [square #(* % %)\n        sum-square-digits #(reduce + (map (comp square read-string str) (str %)))]\n    (loop [n n, seen #{}]\n      (cond\n       (= n 1) true\n       (contains? seen n) false\n       :else (recur (sum-square-digits n) (conj seen n))))))", "problem": 86, "user": "50d86fe2e4b01f0871336e67"}, {"code": "(fn [n]\n  (letfn [(hap-step [n]\n            (apply +\n                   (map #(* % %)\n                        (map #(Integer. (str %)) (str n)))))]\n    (loop [ a n\n           as #{a}]\n      (if (= 1 a)\n        true\n        (let [a (hap-step a)]\n          (if (as a)\n            false\n            (recur a (conj as a))))))))", "problem": 86, "user": "524ae8e6e4b09eba1c0223b5"}, {"code": "(fn g[x]\n\t\t  (let [f\n\t\t\t\t(fn f[k]\n\t\t\t\t\t(when-not (zero? k)\n\t\t\t\t\t\t\t  (cons (mod k 10) (f (quot k 10)))))]\n\t\t\t(loop [s #{} n x]\n\t\t\t\t  (if (= n 1)\n\t\t\t\t\t  true\n\t\t\t\t\t(if (get s n)\n\t\t\t\t\t\tfalse\n\t\t\t\t\t  (recur\n\t\t\t\t\t   (conj s n)\n\t\t\t\t\t   (reduce + (map #(* % %) (f n)))))))))", "problem": 86, "user": "51f2851fe4b0210f90e7454b"}, {"code": "(fn is-happy [n]\n  (letfn [(to-chars [n] (reduce #(conj %1 (Character/getNumericValue %2)) [] (str n)))\n          (happy-step [n] (reduce #(+ %1 (* %2 %2)) 0 (to-chars n)))\n          (gen-happy [n] (cons n (lazy-seq (gen-happy (happy-step n)))))]\n    (contains? (reduce #(conj %1 %2) #{} (take 100 (gen-happy n))) 1)))", "problem": 86, "user": "52463059e4b09dbe66b56198"}, {"code": "(fn [n]\n    (loop [n n\n           s (set (list n))]\n      (let [ss (->> n\n                 (iterate #(/ % 10))\n                 (take-while #(>= % 1))\n                 (map #(-> % (float) (Math/floor) (Math/round) (mod 10)))\n                 (map #(* % %))\n                 (apply +))]\n        (cond\n          (= ss 1)         true\n          (contains? s ss) false\n          :else            (recur ss (conj s ss))))))", "problem": 86, "user": "525f51bde4b0cb4875a45dc8"}, {"code": "(fn [nr] \n  (letfn [\n          (get-digits [nr]\n            (filter #(not (= % 0))\n             (loop [digits [], nr nr]\n               (if (= nr 0)\n                 digits\n    \t\t (recur (conj digits (mod nr 10)) \n           \t\t(int (/ nr 10)))))))\n          ]\n    (loop [seen #{}, nr nr]\n      (cond\n       (= nr 1) true\n       (contains? seen nr) false\n       :else (recur (conj seen nr) (reduce + (map #(* % %) (get-digits nr))))\n       )\n      )))", "problem": 86, "user": "522d3a16e4b0e26240291d50"}, {"code": "(fn [d]\n   (= 1 (letfn [(happy? [s]\n                  (reduce + (map\n                             (comp int #(Math/pow % 2) read-string str)\n                             (seq (str s)))))]\n          (loop [n (happy? d)  stock #{}]\n            (if (and (> n 1) (not (get stock n)))\n              (recur (happy? n) (conj stock n))\n              n)))))", "problem": 86, "user": "50550f43e4b0b1b9d1860eb7"}, {"code": "(fn [n]\n  (let [digits     (fn [n]\n                    (map #(Integer. (str %)) (str n) ))\n        next-num   (fn [n]\n                     (reduce + (map #(* %1 %1) (digits n ))))\n        happy      (fn happy [seen n]\n                     (if (= 1 n) true \n                       (let [next (next-num n)] \n                         (if (some #{next} seen) false (happy (cons next seen) next)))))]\n    (happy '() n)))", "problem": 86, "user": "5142e808e4b0c172af7558c9"}, {"code": "(fn is-happy-number\n  ([n] (is-happy-number n #{}))\n  ([n pathSet]\n   (letfn [(sq [x] (* x x))\n           (take-digits [x] (map #(Integer/parseInt %) (re-seq #\"\\d\" (str x))))\n           (sum-of-sqls [ls] (reduce + (map sq ls)))]\n     (let [nextNum (-> n take-digits sum-of-sqls)]\n       (cond\n        (= nextNum 1) true\n        (pathSet nextNum) false\n        :else (recur nextNum (conj pathSet nextNum)))))))", "problem": 86, "user": "51df825de4b01188f062752b"}, {"code": "(fn happy?\n  ([x] (happy? #{} x))\n  ([seens x] (cond \n              \t(= 1 x) true\n                (contains? seens x) false\n                :else (happy? (conj seens x) (reduce #(+ %1 (* %2 %2)) 0 (map #(Integer/parseInt (str %)) (str x))))\n             )\n  )\n)", "problem": 86, "user": "5272d4b7e4b03e8d9a4a7453"}, {"code": "(fn happy-number \n  [num]\n  (letfn [\n    (sum-of-squared-digits\n      [num]\n      (if \n        (= num 0) 0\n        (+ \n          (Math/pow (rem num 10) 2) \n          (sum-of-squared-digits (int (/ num 10))))))\n    ]      \n    (loop [seen #{}\n           this-sum num]\n      (cond \n        (seen this-sum) false\n        (= (int this-sum) 1) true\n        :else (recur (conj seen this-sum) (sum-of-squared-digits this-sum))))))", "problem": 86, "user": "5268eb68e4b03e8d9a4a71c6"}, {"code": "(fn [num]\n  (boolean (some #(= 1 %)\n                 (take 100\n                       ((fn [n]\n                          (iterate (fn [x] (apply + (map #(* % %) (map #(- (int %) (int \\0)) (str x))))) n))\n                         num)))))", "problem": 86, "user": "52667ecfe4b03e8d9a4a713e"}, {"code": "(fn p86\n  ([n] (p86 [] n))\n  ([hs n]  (letfn [\n             (hn [n] (apply + (map (comp #(* % %) #(- % 48) int) (char-array (str n))) ))]\n             (if (= 1 n) true (if (or (some #(= % n) hs) (< 100 (count hs))) false (p86 (conj hs n) (hn n)))))))", "problem": 86, "user": "5272669de4b03e8d9a4a742e"}, {"code": "(fn happy-num? [n]\n  (loop [n n\n         s #{}]\n    (cond\n      (= n 1) true\n      (contains? s n) false\n      :else (let [digits ((fn get-digits [n]\n                            (loop [len (count (str n))\n                                   m n\n                                   res '()]\n                              (if (= len 0)\n                                res\n                                (recur (dec len) (quot m 10) (conj res (rem m 10)))))) n)]\n              (recur (reduce #(+ %1 (* %2 %2)) 0 digits) (conj s n))))))", "problem": 86, "user": "526ee63de4b03e8d9a4a733f"}, {"code": "(fn [n] (let [the-sum\n              (fn [k] (loop [curr k result 0]\n                        (if (= 0 curr) result (recur (quot curr 10) (+ result (* (rem curr 10) (rem curr 10)))))\n                      )\n              )]\n         (loop [curr n so-far #{}]\n           (cond\n            (= curr 1) true\n            (contains? so-far curr) false\n            :else (let [z (the-sum curr)]\n                    (recur z (conj so-far curr))\n                  )\n           )\n         )\n        )\n)", "problem": 86, "user": "526dd90de4b03e8d9a4a72fe"}, {"code": "(fn split-number-and-sum-squares [x]\n  (let [\n        parse-digits (fn [k] (map #(Integer/parseInt (str %))  (seq  (str k)) ))\n        calculate-sum-of-squares (fn [m] (apply +  (map #(* % % ) m)))\n        ] \n    (loop [digits ( parse-digits x) history []]\n      (let [sum-of-squares (calculate-sum-of-squares digits)]\n        (if (= 1 sum-of-squares) true\n            (if (some #(= % sum-of-squares) history)\n              false\n              (recur (parse-digits sum-of-squares) (conj history sum-of-squares))\n              )\n            )\n        )\n      )\n    )\n  )", "problem": 86, "user": "4ec4d723535dcc7ae8597d65"}, {"code": "(fn g\n    ([m l]\n     (let  [n (apply + (map #(int (Math/pow (mod % 10) 2))\n                            (take-while #(not (= % 0)) (iterate #(int (/ % 10)) m))))]\n       (if (= 1 n) true (if (some #(= n %) l) false (g n (cons n l))))\n       )\n     )\n    ([m] (g m [])))", "problem": 86, "user": "52593207e4b0cb4875a45cd3"}, {"code": "(fn mnum ([x] (mnum x #{}))\n   ([x cur-set]\n      (let [new-num (apply + (map #(* % %) (map #(Integer/parseInt %) (map str (str x)))))]\n        (cond (= 1 new-num) true\n         (get cur-set new-num) false\n          :else (recur new-num (conj cur-set new-num))))))", "problem": 86, "user": "524f213be4b0541d1855b7ff"}, {"code": "(fn [n]\n    (loop [counts {0 0} num n]\n        (if (< 2 (apply max (vals counts)))\n            (contains? counts 1)\n            (recur\n                (assoc counts num (inc (get counts num 0)))\n                (apply + (map #(* %1 %1)\n                          (map read-string\n                              (map #(str (first %1))\n                                  (partition 1 (str num))\n                               )\n                              )\n                        )\n                 )\n            )\n         )\n   )\n)", "problem": 86, "user": "5277b9b5e4b03e8d9a4a750d"}, {"code": "(fn happy [n]\n  (let [squaresum (apply + (map #(* (Integer. %) (Integer. %))\n                                (re-seq #\"\\d\" (str n))))]\n    (cond (= 1 squaresum) true\n          (= 4 squaresum) false\n          :else (recur squaresum))))", "problem": 86, "user": "52736ca1e4b03e8d9a4a747e"}, {"code": "(fn [x]\n    (= 1 (first(drop-while #(and (not= % 1)(not= % 4))(rest(iterate (fn [n] (apply + (map #(* % %) (map #(- (int %) 48) (str n))))) x)))))\n  )", "problem": 86, "user": "5274eb56e4b03e8d9a4a74bb"}, {"code": "(fn myHappyNumbers\n  [num]\n  (loop [numbers #{} last num]\n    (cond \n      (contains? numbers last) false\n      (= last 1) true\n      :else (recur (conj numbers last) \n                   (->> last \n                     (str) \n                     (map #(Character/digit % 10)) \n                     (map #(* % %)) \n                     (reduce +))))))", "problem": 86, "user": "509a25b7e4b0efbae1fbc0a8"}, {"code": "(fn [n] (loop [seen #{} \n               [s & rst] (iterate (fn [s] (apply + (map (comp #(* % %) read-string)\n                                                        (re-seq #\".\" (str s)))))\n                                  n)] \n          (cond (= s 1) true \n                (seen s) false \n                :else (recur (conj seen s) rst))))", "problem": 86, "user": "519ef784e4b087743fad2198"}, {"code": "(fn happy-numbers [n]\n  (letfn [(number-to-digits [n]\n            (map #(Character/getNumericValue %) (str n)))\n          (square-sum [n]\n             (reduce + (map #(* % %) (number-to-digits n))))\n          (happy? [n]\n             (loop [number n result-set #{}]\n               (cond (= number 1) true\n                     (contains? result-set number) false\n                     :else (recur (square-sum number) (conj result-set number)))))]\n    (happy? n)))", "problem": 86, "user": "5125745ae4b05d10e3e395f9"}, {"code": "(fn f ([n] (f n #{n}))\n  ([n s] (let [m (reduce + (map #(* % %) (map #(Character/digit % 10) (str n))))]\n           (if (= m 1) true\n             (if (contains? s m) false\n               (f m (conj s m)))))))", "problem": 86, "user": "5078d366e4b08327cd804a5b"}, {"code": "(fn happy? [n]\n   (let [sumsq (fn [n]\n                 (let [digs (map (fn [c] (Integer. (str c)))\n                                 (str n))\n                       sqd (map #(* % %) digs)\n                       sum (reduce + 0 sqd)]\n                   sum))]\n     (loop [nums #{n}\n            num (sumsq n)]\n       (cond\n         (= 1 num) true\n         (contains? nums num) false\n         :default (recur (conj nums num)\n                         (sumsq num))))))", "problem": 86, "user": "4f35b2ace4b0e243712b1ec5"}, {"code": "(fn happy? \n  ([n] (happy? n #{}))\n  ([n h] (cond\n    (= n 1) true\n    (h n) false\n    :else (happy? (->> (.toString n) (map #(Character/getNumericValue %)) (map (fn [x] (* x x))) (reduce +)) (conj h n)))))", "problem": 86, "user": "526439a4e4b03e8d9a4a70cc"}, {"code": "(fn happy? [n] (let\n   [happy-helper (fn [n seen] \n        (let [val (reduce + (map #(let [x (- (int %1) (int \\0))] (* x x)) (seq (str n))))]\n           (cond \n              (= 1 val) true\n              (contains? seen val) false\n              :else (recur val (conj seen val)))))]\n       (happy-helper n [])))", "problem": 86, "user": "514cfa27e4b019235f6c057d"}, {"code": "(letfn [(seq-n [x n] (loop [c () v x] (if (< v n) (conj c v) (recur (conj c (mod v n)) (quot v n)))))\n        (hnn [x] (->> (seq-n x 10) (map #(* % %)) (apply +)))]\n   (fn [x] (loop [c #{} v x] (if (c v) (= 1 v) (recur (conj c v) (hnn v))))))", "problem": 86, "user": "528e64b7e4b0239c8a67aedd"}, {"code": "(letfn [( digit [n]\n                (apply + (map #(* % % )(map #(- (int %) (int \\0))  (seq (str n )))))\n                )]\n  (fn [x]\n    (loop [current x results #{}]\n      (if (= current 1)\n        true\n        (let [y (digit current)]\n          (if (contains? results y)\n            false\n            (recur y (conj results y))))))))", "problem": 86, "user": "518c5236e4b087e178201de0"}, {"code": "< 4", "problem": 86, "user": "51e38568e4b0c611d6113e43"}, {"code": "(fn happy-number? [n]\n  (letfn [(step [n]\n            (reduce + (map #(reduce * (repeat 2 (read-string (str %)))) (str n))))]\n    (loop [k n\n           numbers #{}]\n      (if (= k 1) true\n        (let [kk (step k)]\n          (if (contains? numbers k) false\n            (recur kk (conj numbers k))))))))", "problem": 86, "user": "52606318e4b03e8d9a4a7036"}, {"code": "(fn happy-number? [n]\n  (letfn [(sum-digits [n]\n    (loop [n n acc 0]\n      (let [div-10 (rem n 10)]\n        (if (zero? n)\n          acc\n          (recur (quot n 10) (+ acc (* div-10 div-10)))))))]\n    (loop [n n acc #{}]\n      (let [ss (sum-digits n)]\n        (cond \n          (= n 1) true\n          (acc ss) false\n          :else  (recur ss (conj acc ss)))))))", "problem": 86, "user": "528b08efe4b0239c8a67ae8a"}, {"code": "(fn happy-num [n]\n    (letfn[(get-digits\n             [n]\n             (loop[digits []\n                   n n]\n               (let[a (quot n 10)\n                    b (rem n 10)]\n                 (if(> a 0)\n                   (recur (conj digits b) a)\n                   (conj digits b)))))\n           (get-sum\n             [digits]\n             (reduce #(+ %1 (* %2 %2)) 0 digits))]\n      (loop[digits #{n}\n            n n]\n        (let[new (->\n                   (get-digits n)\n                   (get-sum))]\n          (cond \n            (= 1 new) true\n            (contains? digits new) false\n            :else (recur (conj digits new) new))))))", "problem": 86, "user": "5273562ae4b03e8d9a4a7479"}, {"code": "(fn [i]\n  (letfn [(f [n]\n             (lazy-seq\n              (cons n (f (reduce + (map #(int (Math/pow (read-string (str %)) 2)) (str n)))))))\n          (g [s t]\n             (cond\n              (= 1 (first s)) true\n              (contains? t (first s)) false\n              :else (recur (rest s) (conj t (first s)))))]\n    (g (f i) #{})))", "problem": 86, "user": "52753740e4b03e8d9a4a74c1"}, {"code": "(fn happy [y]\n    (letfn [(gs [y] (->> y\n                         (str)\n                         (into [])\n                         (map #(- (int %) 48))\n                         (reduce #(+ (* %2 %2) %1) 0) ))\n            ]\n      (loop [sum y seen #{y}]\n        (let [r (gs sum)]\n          (print r)\n          (cond\n           (seen r) false\n           (= r 1) true\n           :else (recur r (conj seen r)))))))", "problem": 86, "user": "52140b53e4b0961f15ac4d7e"}, {"code": "(fn problem-86 [n]\n  (letfn [(trans [num]\n            (->> num\n                 str\n                 (partition 1)\n                 flatten\n                 (map #(Character/getNumericValue %))\n                 (map #(* % %))\n                 (reduce +)))\n          (check [num faced]\n            (let [tr (trans num)]\n              (cond\n               (= 1 tr) true\n               (some #(= % tr) faced) false\n               :else (recur tr (cons tr faced)))))]\n    (check n (list))))", "problem": 86, "user": "51fe9d7ce4b0f1313d468a70"}, {"code": "(fn [n]\n  (loop [seen #{} x n]\n    (if (seen x)\n      false\n      (let [y (reduce + (map (comp #(* % %) read-string str) (str x)))]\n        (if (= y 1)\n          true\n          (recur (conj seen x) y))))))", "problem": 86, "user": "52a1acb2e4b04e0c58e87bdb"}, {"code": "(fn [num]\n  (let [_sq_sum  (fn [n] (reduce + (map #(* % %) (for [sq (str n)](Integer. (str sq))))))]\n  (loop [history [] n num]\n   (if (= 1 n) true\n     (if (contains? history n) false\n       (recur (conj history (_sq_sum n)) (_sq_sum n))\n     )\n   )\n  ))\n)", "problem": 86, "user": "522eba30e4b01cdb292c5f0e"}, {"code": "(fn happy? [k]\n  (loop [cnt 0 sum k]\n    (let [ss (reduce + (map #(let [k (- (int %) 48)] (* k k)) (str sum)))]\n        ;;(println cnt ss)\n\t    (cond\n\t        (= ss 1) true\n\t        (= cnt 10000) false\n\t        :else (recur (inc cnt) ss)       \n\t      )\n\t    )\n\t  )\n  )", "problem": 86, "user": "529a73bde4b02ebb4ef75096"}, {"code": "(fn happy? [n]\n   ((fn subhappy [n seen]\n      (let [digits ((fn dig [n]\n                      (if (= 0 n) []\n                          (conj (dig (quot n 10)) (mod n 10)))) n)\n            newn (reduce + (map #(* % %) digits))]\n        (cond\n         (= 1 newn) true\n         (contains? seen newn) false\n         true (subhappy newn (conj seen newn))))) n #{}))", "problem": 86, "user": "529ce629e4b04e0c58e87b6e"}, {"code": "(fn f [x y] \n\t(\tlet [\n\t\t\tl (map (fn [z] (Integer/parseInt (str z))) (into [] (str y)))\n\t\t\ts (map (fn [w] (* w w)) l)\n\t\t\tsum (reduce + s)\n\t\t\ts1 (= sum 1)\n\t\t\tct (and (contains? x sum))\n\t\t] (if s1 true (if ct false (f (conj x sum) sum)))\n\t)\n) #{}", "problem": 86, "user": "5296008fe4b02ebb4ef7502a"}, {"code": "#(> % 5)", "problem": 86, "user": "4db92654535d1e037afb21a0"}, {"code": "(fn [n]\n  (letfn [(_ [acc n]\n    (let [ns (map (fn [n] (Integer/parseInt (str n))) (str n))\n          n (reduce + (map (fn [n] (* n n)) ns))]\n      (if (= 1 n)\n        true\n        (if (some (fn [n'] (= n n')) acc)\n          false\n          (_ (cons n acc) n)))))]\n    (_ [] n)))", "problem": 86, "user": "5213d7aae4b0961f15ac4d72"}, {"code": "(fn [num]\n  (loop [n num   seen #{}]\n    (let [digits       (map #(-> % str read-string) (str n))\n          x   (apply + (map #(* % %) digits))]\n      (cond (= 1 x) true \n            (seen x) false \n            :else (recur x (conj seen x)))\n      )))", "problem": 86, "user": "51264447e4b05d10e3e39601"}, {"code": "(fn [n]\n  (loop [seen #{}\n         n n]\n    (cond\n      (= 1 n) true\n      (seen n) false\n      :else (recur (conj seen n)\n              (apply + (map (comp #(* % %) read-string str) (str n)))))))", "problem": 86, "user": "4f0f36a7535d0136e6c22336"}, {"code": "(fn [n]\n  (loop [seen #{}, v n]\n    (cond\n      (= v 1) true\n      (seen v) false\n      :else (recur (conj seen v)\n              (reduce + (map (comp #(* % %) #(mod % 10))\n                          (take-while pos? (iterate #(int (/ % 10)) v))))))))", "problem": 86, "user": "4ef77edb535dced4c769f254"}, {"code": "(fn [n]\n    (letfn [(digits [n]\n              (if (= n 0)\n                ()\n                (cons (mod n 10) (digits (quot n 10)))))]\n      (loop [n n\n             seen #{}]\n        (cond\n          (= n 1) true\n          (seen n) false\n          :else (recur\n                  (reduce + (map #(* % %) (digits n)))\n                  (conj seen n))))))", "problem": 86, "user": "521b9f92e4b0c4ef0be8304c"}, {"code": "(fn [n]\n    (loop [n n s #{}]\n      (let [r (conj s n)]\n      (if (= s r)\n        (if (= n 1) true false)\n        (recur (apply + (map (comp #(* % %) int read-string str) (str n))) r)))))", "problem": 86, "user": "528652fbe4b0239c8a67ae14"}, {"code": "(fn f\n  ([n] (f n #{}))\n  ([n s]\n   (letfn [(d [n] (map (comp read-string str) (str n)))\n           (u [n] (apply + (map #(* % %) (d n))))]\n     (let [x (u n)]\n       (cond\n         (= x 1) true\n         (s x) false\n         :else (recur x (conj s x)))))))", "problem": 86, "user": "52951156e4b02ebb4ef7501b"}, {"code": "(partial\n(fn happy? [acc n]\n  (let [s (int (reduce + (map #(Math/pow (Integer/parseInt (str %)) 2)  (seq (str n)))))]\n    (cond (= s 1) true\n          (= true (some #(= s %) acc)) false\n          :else (recur (conj acc s) s)))) '())", "problem": 86, "user": "5273e006e4b03e8d9a4a7495"}, {"code": "(fn [n]\n    (letfn [(sq-and-sum [n] (apply + (map #(* % %) (map #(Integer/parseInt (str %)) (.toString n)))))]\n      (loop [curr n prev #{}]\n        (let [next-n (sq-and-sum curr)]\n          (cond\n            (= next-n 1)\n              true\n            (contains? prev next-n)\n              false\n            :else\n              (recur next-n (conj prev next-n)))))))", "problem": 86, "user": "526f9715e4b03e8d9a4a7372"}, {"code": "(fn hn? [n]\n  (letfn [(ne [m] (reduce + (map #(* % %) (map #(- (int %) (int \\0)) (seq (str m))))))]\n    (loop [i n s #{}]\n      (cond\n       (= 1 i) true\n       (contains? s i) false\n       :else (recur (ne i) (conj s i))))))", "problem": 86, "user": "5267d9bde4b03e8d9a4a7188"}, {"code": "(fn [num]\n   (loop [seen #{num} n num]\n     (let [n1 (->> n str (map #(- (int %) (int \\0))) (map #(* % %)) (reduce + 0))]\n       (if (= n1 1)\n         true\n         (if (contains? seen n1)\n           false\n           (recur (conj seen n1) n1)\n           )\n         )\n       )\n     )\n   )", "problem": 86, "user": "5298d3f4e4b02ebb4ef75068"}, {"code": "(fn [n]\n    (letfn [(to-digits \n             [n]\n             (loop [n n\n                      ret []]\n                   (if (= n 0)\n                       ret\n                     (recur (quot n 10) (conj ret (rem n 10))))))]\n           (loop [n n checks #{}]\n                 (cond \n                  (= 1 n) true\n                  (contains? checks n) false\n                  true (recur (apply + (map #(* % %) (to-digits n)))\n                              (conj checks n))))))", "problem": 86, "user": "52afbc69e4b0c58976d9acc0"}, {"code": "(fn [x]\n  (letfn [(square-digits [x]\n            (#(if (zero? %2) %1 (let [md (mod %2 10) qt (quot %2 10)] (recur (+ %1 (* md md)) qt)))\n             0 x))]\n    (#(let [digits-squared (square-digits %2)]\n        (if (= 1 digits-squared)\n          true\n          (if (%1 digits-squared)\n            false\n            (recur (conj %1 digits-squared) digits-squared))))\n     #{x} x)))", "problem": 86, "user": "50645e12e4b007509339a58a"}, {"code": "; This is a bit of a cheat as I am only looking at a fixed length of potential happy values (use of last\n; is in linear time should probably reverse and take first). Another solution is to keep calling\n; the function and catch StackOverflowException, but that's not very satisfactory. \n(fn is-happy [n]\n\t(let [happy-contender (fn [x] (->>\n                                   x\n                                   .toString\n                                   (map #(Character/digit % 10))\n                                   (map #(* % %))\n                                   (reduce +)))\n\t\t\t\thappy-value (happy-contender n)\n\t\t\t\thappy-list (take 10 (iterate happy-contender n))]\n\t\t(if (= (last happy-list) 1) true false)))", "problem": 86, "user": "5201ff99e4b0b2e020a18f26"}, {"code": "(fn [n]\n  (letfn [(dig-10 [n]\n                  ((fn [n d] \n                     (loop [r n dig (if (zero? n) [0] [])]\n                       (if (zero? r) (reverse dig) (recur (int (/ r d)) (conj dig (mod r d)))))) n 10))\n          (gen-happy-num [n]\n                         (reduce + (map #(* % %) (dig-10 n))))] \n    (let [l (iterate gen-happy-num n)\n        k (first (filter #(or (= % 1) (= % 4)) l))]\n    (cond \n      (= k 1) true\n      (= k 4) false)\n    )))", "problem": 86, "user": "52b43468e4b0c58976d9ad1b"}, {"code": "(fn [n]\n\t(= 1 (first\n          (keep #(#{4 1} %)\n                (rest\n                 (iterate\n                  (fn [m]\n                    (apply +\n                           (map (comp #(* % %) bigint str)\n                                (str m)))) n))))))", "problem": 86, "user": "528a3e14e4b0239c8a67ae72"}, {"code": "(fn [num]\n  (letfn [(num->digits [num]\n            (loop [n num res []]\n              (if (zero? n)\n                res\n                (recur (quot n 10) (cons (mod n 10) res)))))\n          (square [n] (* n n))\n          (happify [n] (reduce + (map square (num->digits n))))]\n    (loop [n num res #{}]\n      (cond (= 1 n) true\n            (res n) false\n            :else (recur (happify n) (into res [n]))))))", "problem": 86, "user": "4f437751e4b0d7d3c9f3fd20"}, {"code": "(letfn [(num->digits [num]\n          (loop [n num res []]\n            (if (zero? n)\n              res\n              (recur (long (/ n 10)) (cons (mod n 10) res)))))\n        (change [n]\n          (apply + (map #(* % %) (num->digits n))))]\n  (fn [init]\n    (loop [curr init results #{}]\n      (println curr \" - \" results)\n      (cond\n       (= 1 curr) true\n       (results curr) false\n       :else (let [new-n (change curr)]\n               (println curr new-n)\n               (recur new-n (into results [curr])))\n       )))\n  )", "problem": 86, "user": "4ef7a483535dced4c769f258"}, {"code": "(fn perfect?\n   [num]\n   (loop [sum num\n   \t\t  it 0]\n   (cond (= sum 1) true \n   \t\t (> it 10) false\n         (not= sum 1)\n         (recur (reduce + (map #(* % %) \n         (map #(Character/getNumericValue %) (str sum)))) \n    (inc it)))))", "problem": 86, "user": "52baf490e4b07a9af57922db"}, {"code": "(fn [num]\n  (let [digits (fn digits [n]\n                 (if (< n 10)\n                   [n]\n                   (cons (mod n 10) (lazy-seq (digits (quot n 10))))))\n        happier (fn [n] (reduce + (map #(* % %) (digits n))))]\n    (loop [n num\n           seen #{}]\n      (if (= 1 n)\n        true\n        (if (contains? seen n)\n          false\n          (recur (happier n) (conj seen n)))))))", "problem": 86, "user": "4fc3a72ae4b081705acca342"}, {"code": "(fn [x]\n  (let [f (fn [x] (apply + (map #(* % %) (map #(- (int %) 48) (str x)))))]\n  (loop [x x ys ()]\n    (let [y (f x)]\n      (cond\n        (= x 1) true\n        (some #(= % y) ys) false\n        :default (recur y (cons y ys)))))))", "problem": 86, "user": "52a88c4de4b0c58976d9ac30"}, {"code": "(fn\n  [n]\n  (let [nf\n        (fn [p]\n          (reduce #(let [t (Integer/parseInt (str %2))]\n                                   (+ % (* t t)))\n                              0\n                              (str p)))]\n    (loop [n (nf n) s #{}]\n      (cond\n       (s n) false\n       (= n 1) true\n       :d (recur (nf n) (into s #{n}))))))", "problem": 86, "user": "51852961e4b0da5a5be3babb"}, {"code": "(fn happy [n]\n\t(letfn [\n\t\t(digits [n]\n\t\t\t(if (zero? n)\n\t\t\t\tn\n\t\t\t\t(loop [rv '() num n]\n\t\t\t\t\t(if (zero? num)\n\t\t\t\t\t\trv\n\t\t\t\t\t\t(recur (conj rv (rem num 10)) (quot num 10))\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t)\n\t\t(sumofsquares [dl]\n\t\t\t(apply + (map * dl dl))\n\t\t)]\n\n\t\t(loop [seen #{} num (-> n digits sumofsquares)]\n\t\t\t(cond\n\t\t\t\t(= 1 num)\n\t\t\t\ttrue\n\n\t\t\t\t(seen num)\n\t\t\t\tfalse\n\n\t\t\t\t:else\n\t\t\t\t(recur (conj seen num) (-> num digits sumofsquares))\n\t\t\t)\n\t\t)\n\t)\n)", "problem": 86, "user": "527ba695e4b03e8d9a4a7596"}, {"code": "(fn happy? [n]\n  (letfn [(to-digits [n] (map read-string (re-seq #\"\\d\" (str n))))\n          (sq [n] (reduce + (map #(* % %) (to-digits n))))]\n    (loop [n n xs []]\n      (cond\n       (= n 1) true\n       (some #{n} xs) false\n       :else (recur (sq n) (cons n xs))))))", "problem": 86, "user": "511aa2a4e4b0c87c59c9670a"}, {"code": "(fn [t]\n  (letfn [(hn [n m]\n    (let [s (map #(Character/digit % 10) (str n))\n          e (reduce + \n                    (map \n                      #(* % %)\n                      s))]\n      (if (< m 1000)\n        (if (= e 1)\n          true\n          (hn e (+ m 1)))\n        false)))]\n    (hn t 0)))", "problem": 86, "user": "4e778d36535d324fb2983d71"}, {"code": "(fn happy?\n  [n]\n  (letfn [(sq [n] (* n n))\n          (n->digits [num] (map #(Character/digit % 10) (str num)))]\n    (loop [n n seen #{}]\n      (cond\n       (= 1 n) true\n       (contains? seen n) false\n       :else (recur\n              (reduce + (map sq (n->digits n)))\n              (conj seen n))))))", "problem": 86, "user": "524f4256e4b0541d1855b808"}, {"code": "(fn happy-num [n]\n  (letfn [(square-sum [num1]\n                      (let [digit (rem num1 10)\n                            rest-digits (quot num1 10)]\n                        (if (zero? rest-digits)\n                          (* digit digit)\n                          (+ (* digit digit) (square-sum rest-digits)))))]\n    (loop [path #{}\n           n n]\n      (if (= 1 n)\n        true\n        (if (contains? path n)\n          false\n          (recur (conj path n) (square-sum n)))))))", "problem": 86, "user": "52a55adee4b0c58976d9abe7"}, {"code": "(fn [n] \n  (letfn \n    [(happy? [y v] \n             (if (= 1 y)\n               true\n               (let [\n                     ns (re-seq #\"[0-9]\" (str y))\n                     xs (map read-string ns)\n                     sos (reduce + (map #(* % %) xs))\n                     ]\n                 (if (v sos)\n                   false\n                   (happy? sos (conj v sos))))))]\n    (happy? n #{n})))", "problem": 86, "user": "4ffa8affe4b0678c553fc3bd"}, {"code": "(fn happy?\n  ([n] (happy? n 0))\n  ([n tries]\n   (cond\n    (= 1 n) true\n    (> tries 10) false\n    :else (happy?\n           (reduce +\n                   (map #(* % %)\n                        (map #(Character/getNumericValue %) (str n))))\n           (inc tries)))))", "problem": 86, "user": "519136e9e4b0f8ef0be96c01"}, {"code": "(fn [x]\n  (letfn [(to-digits [x]\n            (map #(Integer/parseInt (str %)) (seq (str x))))\n          (sqs [x]\n            (reduce #(+ %1 (* %2 %2)) 0 (to-digits x)))]\n    (loop [x x s #{}]\n      (cond\n        (= x 1) true\n        (contains? s x) false\n        :else (recur (sqs x) (conj s x))))))", "problem": 86, "user": "527cd633e4b0757a1b17136f"}, {"code": "(fn happy-number?\n  ([n] (happy-number? n #{}))\n  ([n visited-numbers]\n    (letfn [(digit-sq-sum [k]\n       \t\t (apply + \n               (map #(* (Integer. (str %))\n                        (Integer. (str %)))\n                    (apply list (str k)))))]\n      (cond\n        (= n 1) true\n        (contains? visited-numbers n) false\n        :else (happy-number? (digit-sq-sum n) (conj visited-numbers n))))))", "problem": 86, "user": "529e3a4fe4b04e0c58e87b92"}, {"code": "(letfn [(digits [n]\n                (if (zero? n) [0] (cons (mod n 10) (digits (quot n 10)))))\n              (hnext [n]\n                (reduce + (map #(* % %) (digits n))))\n              (happys [s n]\n                (if (contains? s n)\n                  s\n                  (happys (conj s n) (hnext n))))]\n        (fn [n] (contains? (happys #{} n) 1)))", "problem": 86, "user": "5294e44de4b02ebb4ef75016"}, {"code": "(fn happy-numbers [x]\n  (letfn [(calc [x]\n            (apply + (map \n                      (fn [x] (let [x (- (int x) 48)] (* x x) ))\n                      (vec (str x)))))]\n    \n    (loop [x x a #{}]\n      (cond (= x 1) true\n            (contains? a x) false\n            :else (recur (calc x) (conj a x))))\n\n    ))", "problem": 86, "user": "515bbcd9e4b0388ca8ca1521"}, {"code": "(fn happy? [o]\n  (let [ssq (fn ssq [n] (if (< n 10) (* n n)\n                (+ (* (mod n 10) (mod n 10)) (ssq (quot n 10)))))]\n    (loop [n o seen {}]\n      (if (seen n)\n        false\n        (let [q (ssq n)]\n          (or (== q 1) (recur q (assoc seen n true))))))))", "problem": 86, "user": "52ba43d0e4b07a9af57922cd"}, {"code": "(fn [n] \n\t(= (nth (iterate \n\t\t#(int (apply + (map (fn [x] \n\t\t\t(Math/pow (- 48 (int x)) 2)) (str %)))) n) 20) 1))", "problem": 86, "user": "52c6a0abe4b0c2d177d62111"}, {"code": "(fn happy [n]\n  (cond\n   (== n 4) false\n   (== n 1) true\n   :else (happy (->> n\n                     str\n                     (map #(- (int %) 48))\n                     (map #(* % %))\n                     (reduce +)))))", "problem": 86, "user": "51929214e4b08962174cf74c"}, {"code": "(fn [n](\n                (fn happy [n] (let [n2 (reduce + (map #(* (Integer. %) (Integer. %)) (rest (clojure.string/split (str (last n)) #\"\"))))]\n                                (if (= 1 n2) true (if (some #(= % n2) n) false (happy (conj n n2))))\n                                )) [n]))", "problem": 86, "user": "52c1bd29e4b07a9af579236a"}, {"code": "(fn[n]\n  (loop [ps #{} x n]\n    (if (= 1 x)\n      true\n      (if (ps x)\n        false\n        (recur (conj ps x)\n               (reduce + (map #(let [y (- (int %) 48)] (* y y)) (str x)))\n               )))))", "problem": 86, "user": "4ea365e2535d7eef308072c5"}, {"code": "(fn happy? [n]\n  (letfn [(digits [n xs] (if (not= 0 n) (digits (quot n 10) (cons (rem n 10) xs))  xs))\n          (square [x] (* x x))]\n    (loop [n n c 20]\n      (cond\n       (= 1 n) true\n       (= 0 c) false\n       :else (recur (reduce + (map square (digits n nil))) (dec c))))))", "problem": 86, "user": "4ebe766d535dfed6da9c6d94"}, {"code": "(fn happy? [n]\n  (letfn [(explode [x] (map #(Character/digit % 10) (seq (str x))))]\n    ; 4 is the smallest 'unhappy' number, which any unhappy number will eventually reduce to\n    (let [sum (apply + (map #(* % %) (explode n)))]\n      (cond\n       (= 4 sum) false\n       (= 1 sum) true\n       :else (recur sum)))))", "problem": 86, "user": "529d4f4be4b04e0c58e87b79"}, {"code": "(fn f [r n] (and (not (r n)) (or (= 1 n) \n    (f (conj r n) (reduce #(+ % (* %2 %2)) 0 \n                             ((fn d [n] (if (= 0 n) []\n                                           (concat (d (quot n 10))\n                                            [(mod n 10)]))) n)))))) #{}", "problem": 86, "user": "52bf29fde4b07a9af579232e"}, {"code": "(partial < 4)", "problem": 86, "user": "4f03641a535dcb61093f6a9b"}, {"code": "(fn [n]\n  (-> \n    (for [q (next (range))\n          :let [s (take q (iterate (fn [x] \n                                     (->> \n                                       x \n                                       (str) \n                                       (map #(-> % str Integer. ((fn [x] (* x x))))) \n                                       (apply +))) \n                                   n))]\n          :while (apply distinct? s)]\n      s)\n    last\n    last\n    (#(= 1 %))))", "problem": 86, "user": "52c8758be4b0c2d177d62135"}, {"code": "(fn [n]\n  (loop [n n\n         attempts 0]\n    (if (> attempts 100)\n      false\n      (let [sum-of-squares (reduce + (map #(* % %) (map #(Integer/parseInt (str %)) (str n))))]\n        (println sum-of-squares)\n        (if (= sum-of-squares 1)\n          true\n          (recur sum-of-squares (inc attempts)))))))", "problem": 86, "user": "51a97f7ae4b08d8ec191b827"}, {"code": "(fn happy? [x]\n  (cond\n    (= x 7) true\n    (= x 1) true\n    (< x 10) false\n    :else (recur\n            (reduce +\n              (map #(int (Math/pow (java.lang.Character/getNumericValue %) 2)) (str x))))\n    )\n  )", "problem": 86, "user": "5094057fe4b097f48cc38593"}, {"code": "(fn happy [n]\n  (letfn [(nextn [n] (reduce + (map #(* % %) (map #(Character/digit % 10) (str n)))))]\n    (loop [seen #{} n (nextn n)]\n      (cond\n       (= n 1) true\n       (contains? seen n) false\n       :else (recur (conj seen n) (nextn n))))))", "problem": 86, "user": "52d3f666e4b09f7907dd1327"}, {"code": "(fn [n]\n  (loop [n n s #{}]\n    (cond\n      (= 1 n) true\n      (s n) false\n      :else (recur (->> n\n                        str\n                        (map #(- (int %) (int \\0)))\n                        (map #(* % %))\n                        (apply +))\n                   (conj s n)))))", "problem": 86, "user": "52b453b0e4b0c58976d9ad21"}, {"code": "(letfn [(digits [number] (map #(Character/digit % 10) (str number)))\n        (sum-sqr-digits [x] (int (reduce + (map #(Math/pow % 2) (digits x)))))]\n  (fn happy? [x]\n    (= 1 (some #{1 4}\n               (iterate sum-sqr-digits x)))))", "problem": 86, "user": "50d8de3fe4b01f0871336e72"}, {"code": "(fn __ [n]\n ((fn calc [x seen]\n    (let [new-x (->> x\n                  str\n                  seq\n                  (map str)\n                  (map read-string)\n                  (reduce #(+ %1 (* %2 %2)) 0)\n                  )]\n      (if (= new-x 1)\n        true\n        (if (contains? seen new-x)\n          false\n          (calc new-x (merge seen new-x))))))\n   n #{}))", "problem": 86, "user": "52828298e4b0757a1b17145b"}, {"code": "(fn happy? [coins num] (let \n                 [extract-digits (fn extract-digits [number] (map #(-> % int (- 48)) (seq (str number))))\n                  haha (->> num extract-digits (map #(* % %)) (apply +))]\n                 (if (= 1 haha)\n                   true\n                   (if (> coins 0) \n                     (happy? (dec coins) haha)\n                     false)))) 1000", "problem": 86, "user": "52b35a6ee4b0c58976d9ad07"}, {"code": "(fn [n]\n  (let [sq #(* % %)\n        s->i #(Character/getNumericValue %)]\n    (loop [n n, seen #{}]\n      (if (= 1 n)\n        true\n        (let [next-n (reduce + (map (comp sq s->i) (str n)))]\n          (if (seen next-n)\n            false\n            (recur next-n (conj seen next-n))))))))", "problem": 86, "user": "4e80aa10535db62dc21a62b1"}, {"code": "(fn [n]\n  (letfn [(d [m] (map #(Integer/parseInt (str %)) (seq (str m))))\n          (ss [s] (apply + (map #(* % %) s)))]\n    (loop [h n p []]\n      (if (= h 1)\n        true\n        (if (some #{h} p)\n          false\n          (recur (ss (d h)) (conj p h)))))))", "problem": 86, "user": "4ee75ec2535d93acb0a66867"}, {"code": "(fn [n]\n  (letfn [(square [n]\n            (* n n))\n          (digits [n]\n            (loop [n n\n                   digits []]\n              (if (< n 10)\n                (cons n digits)\n                (recur (quot n 10) (cons (rem n 10) digits)))))\n          (happy-val [n]\n            (reduce + (map square (digits n))))]\n  (loop [n n\n         visited #{}]\n    (let [h (happy-val n)]\n      (cond\n       (= 1 h) true\n       (visited h) false\n       :else (recur h (conj visited h)))))))", "problem": 86, "user": "5236b6bce4b05f3be1c7c8fe"}, {"code": "(fn happy-number [x]\n  (cond \n   (= 1 x) true \n   (= 4 x) false  \n   :else (happy-number (reduce (fn[a b](+ a ((comp #(* % %)  #(- % 48) int) b) ))  0 (str x)))))", "problem": 86, "user": "52bbd09ee4b07a9af57922ee"}, {"code": "(fn [n]\n  (loop [nums #{} x n]\n    (cond\n     (= x 1) true\n     (contains? nums x) false\n     :else (recur\n            (conj nums x)\n            (reduce\n             #(+ %1 (let [y (read-string (str %2))] (* y y)))\n             0\n             (str x)\n             )\n            )\n     )\n    )\n  )", "problem": 86, "user": "52e59ca5e4b09f7907dd1464"}, {"code": "(fn [s]\n   (loop [s (str s)\n          m #{}]\n     (let [v  (str (int (reduce #(+ % (Math/pow (- (int %2) 48) 2)) 0 s)))]\n       (cond\n        (= v \"1\") true\n        (m (set v)) false\n        :else (recur v (conj m (set v)))))))", "problem": 86, "user": "52c25645e4b07a9af579237d"}, {"code": "(fn [n] \n  (letfn [(to-digits [x] \n                     (map #(Integer. (str %)) (seq (str x)))) \n          (to-int [digits] \n                  (Integer. (reduce (comp str) digits)))]\n    (loop [x n hist [n]]\n      (let [digits (to-digits x)] \n        (if (= 1 (apply + (to-digits x)))\n          true\n          (let [square-sum (apply + (map #(* % %) digits))]\n            (if (some #{square-sum} hist)\n              false\n              (recur square-sum (conj hist square-sum)))))))))", "problem": 86, "user": "52aad30ce4b0c58976d9ac6d"}, {"code": "(fn happy\n  [n]\n  (let [single-iter (fn [n]\n                      (->> (str n)\n                          (seq)\n                          (map (comp #(* % %) read-string str))\n                          (reduce +)))]\n    (loop [path [] num n]\n      (cond\n        (= num 1) true\n        (contains? path num) false\n        :else (recur (conj path num) (single-iter num))))))", "problem": 86, "user": "52dd6cc8e4b09f7907dd13e2"}, {"code": "(fn happy-number? [a-num]\n\t(letfn [(digits-seq [a-num]\n\t\t\t\t(map #(Integer/parseInt (str %)) (seq (str a-num)))\n\t\t\t ) \n\t\t\t(sums-to-one? [a-num]\n\t\t\t\t(= 1 (reduce + (digits-seq a-num)))\n\t\t\t) \n\t\t\t(next-num [a-num]\n\t\t\t\t(reduce + (map #(* % %) (digits-seq a-num)))\n\t\t\t)]\n\t\t(loop [curr-num a-num visited #{}]\n\t\t\t(if (sums-to-one? curr-num)\n\t\t\t\ttrue\n\t\t\t\t(let [nxt (next-num curr-num)]\n\t\t\t\t\t(if (visited nxt)\n\t\t\t\t\t\tfalse\n\t\t\t\t\t\t(recur nxt (conj visited nxt))\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\t\n\t\t)\n\t)\n)", "problem": 86, "user": "52763696e4b03e8d9a4a74d7"}, {"code": "(fn happy-number?\n  ([number] (happy-number? number []))\n  ([number previous]\n   (or (= number 1)\n       (and (not-any? #(= % number) previous)\n            (let [previous (conj previous number)\n                  sum-squared-digits\n                  (apply + (map #(let [digit (Character/getNumericValue %)]\n                                   (* digit digit))\n                           (str number)))]\n              (happy-number? sum-squared-digits previous))))))", "problem": 86, "user": "51ab4082e4b04e3dc0c27b31"}, {"code": "(fn [n]\n  (letfn [(cmpt [[& nums]] (reduce + (map * nums nums)))\n          (splt [integer] (map #(read-string (str %)) (str integer)))]\n    (loop [parm n\n           cache []]\n      (if (some #{parm} cache)\n        (= parm 1)\n        (recur (cmpt (splt parm)) (conj cache parm))))))", "problem": 86, "user": "52b02329e4b0c58976d9acc5"}, {"code": "(fn is-happy [x]\n  (loop [ns x p #{}]\n    (let [nv (reduce #(+ % (* %2 %2)) 0 (map (comp read-string str) (str ns)))]\n      (cond \n       (= nv 1)       true\n       (contains? p nv) false\n       :else          (recur nv (conj p nv))))))", "problem": 86, "user": "52d809bde4b09f7907dd1384"}, {"code": "(fn [n]\n    (= 1 ((fn [s n]\n            (let [i (reduce #(+ % (* %2 %2)) 0 (map #(- (int %) (int \\0)) (str n)))]\n              (if (contains? s n)\n                n\n                (recur (conj s n) i))))\n          #{} n)))", "problem": 86, "user": "52e3e6a8e4b09f7907dd1448"}, {"code": "(fn [n]\n  (letfn [(nums [n] (map #(- (int %) 48) (seq (str n))))\n          (sqrsum [ns] (apply + (map #(* % %) ns)))]\n    (loop [n n found []]\n      (cond\n       (= n 1) true\n       (contains? found n) false\n       :else (recur (sqrsum (nums n)) (conj found n))))))", "problem": 86, "user": "52b405e1e4b0c58976d9ad15"}, {"code": "(fn happy [n]\n  (letfn [(happy-seq [n]\n            (letfn [(square [num] (* num num))\n                    (parse-sq [e] (square (- (int e) (int \\0))))]\n              (lazy-seq\n               (let [next (apply + (map parse-sq (str n)))]\n                 (cons n (happy-seq next))))))]\n    (loop [sofar []\n           s (happy-seq n)]\n      (let [f (first s) r (rest s)]\n        (cond\n         (= f 1) true\n         (some #(= f %) sofar) false\n         :else (recur (conj sofar f) r))))))", "problem": 86, "user": "52f8f4d1e4b047fd55836fde"}, {"code": "(fn [n] (letfn [(calc [n] (apply + (map #(let [n (Integer/parseInt %)] (* n n)) (-> n str (.split \"\") next))))]\n          (loop [n (calc n) r #{}]\n            (cond\n              (= n 1) true\n              (r n) false\n              :else (recur (calc n) (conj r n))))))", "problem": 86, "user": "4ef9c8f9535dced4c769f26b"}, {"code": "(fn [n]\n    (loop [s #{}\n         n n]\n    (cond\n     (= n 1) true\n     (s n) false\n     1 (recur (conj s n)\n                  (int (apply + (for [x (str n) y [(- (int x) 48)]] (* y y))))))))", "problem": 86, "user": "51a10b2ce4b0b292b01ee3fe"}, {"code": "(fn [x]\n   ((fn happy [x steps]\n       (let [sq (map read-string (re-seq #\"\\d\" (str x))) n (reduce +'(map #(*' % %) sq))]\n         (if (= 1 n)\n           true\n           (if (> steps 255 )\n             false\n             (happy n (inc steps)))))) x 0))", "problem": 86, "user": "5300aa1de4b0d8b024fd3710"}, {"code": "(fn [n]\n\t(loop [cur n done #{}]\n\t\t(let [n-val (reduce + (map #(int (Math/pow (Integer/parseInt (str %)) 2)) (str cur)))]\n\t\t\t(cond\n\t\t\t\t(= 1 n-val) true\n\t\t\t\t(some #{n-val} done) false\n\t\t\t\t:else (recur n-val (conj done n-val))))))", "problem": 86, "user": "4f47eab2e4b0d56e7bb92bc6"}, {"code": "(fn [n]\n  (loop [x n\n         v #{}]\n    (let [s (apply + (map #(* % %) (map #(- (int %) 48) (str x))))]\n      (cond\n       (= 1 s) true\n       (v s)   false\n       1       (recur s (conj v s))))))", "problem": 86, "user": "51ad244fe4b09397d510977f"}, {"code": "(fn [n]\n\t(letfn [\n\t\t(to-digits [n] (map #(Integer/parseInt %) (map str (str n))))\n\t\t(formula [n] (reduce + (map #(* % %) (to-digits n))))\n        (one-round [n already-encountered] (cond (contains? already-encountered n) false (= 1 n) true :else (one-round (formula n) (conj already-encountered n))))\n        (happy-number? [n] (one-round n #{}))\n        ]\n        (happy-number? n)))", "problem": 86, "user": "52f10094e4b05e3f0be25ee8"}, {"code": "(fn happy-numbers [n]\n  (loop [n n coll #{}]\n    (cond (= n 1) true\n          (coll n) false\n          :else (recur (reduce + (map (comp #(* % %) #(Character/digit % 10)) (str n))) (conj coll n))\n          )))", "problem": 86, "user": "52fcfeeee4b047fd55837027"}, {"code": "(fn happy?\n  [n & s]\n  (let [so (vec s)\n        ss (flatten (concat so (vec [n])))\n  \t    nn (apply + (for [is (for [i (re-seq #\"\\d\" (str n))]\n  \t                           (Integer. i))]\n                      (* is is)))]\n  \t(cond \n  \t  (= nn 1) true \n      (some #(= nn %) ss) false\n  \t  :else\n  \t    (happy? nn ss))))", "problem": 86, "user": "52f3af46e4b05e3f0be25f14"}, {"code": "(fn happy? [number]\n  (letfn [(digits [n]\n            (when-not (zero? n)\n              (cons (mod n 10)\n                    (digits (quot n 10)))))\n\n          (sq-digit-sum [n]\n            (->> n\n                 digits\n                 (map #(* % %))\n                 (reduce +)))]\n    \n    (loop [curr number\n           seen #{}]\n      (cond\n       (= curr 1) true\n       (seen curr) false\n       :else (recur (sq-digit-sum curr)\n                    (conj seen curr))))))", "problem": 86, "user": "530578ede4b0d8b024fd3760"}, {"code": "(fn [x]\n  ((fn h[k r]\n    (cond\n     (= k 1) true\n     (some #(= k %) r) false\n     :else\n     (let [n ((fn s[y]\n              (if (> y 9)\n                (+ (s (quot y 10))\n                   (s (rem  y 10)))\n                (* y y))) k)]\n       (h n (cons k r))))) x []))", "problem": 86, "user": "52f818a6e4b047fd55836fcc"}, {"code": "(fn top ([n acc]\n(let [digits (map #(Character/digit % 10) (str n))\n        sumsquares (reduce + (map (fn[x] (* x x)) digits))\n        happy? (= 1 sumsquares)\n        nothappy? (contains? acc sumsquares)]\n    (cond (true? happy?) true\n          (true? nothappy?) false\n          :else (top sumsquares (conj acc sumsquares)))))\n  ([n] (top n #{})))", "problem": 86, "user": "5301157ae4b0d8b024fd3717"}, {"code": "(letfn [(digits [n r] (if (zero? n) r (recur (quot n 10) (cons (rem n 10) r))))\n          (sqr-sum-seq [n] (cons n (lazy-seq (sqr-sum-seq (reduce + (map #(* % %) (digits n '())))))))\n          (is-happy? [n v [f & r]] \n            (cond (v f) false\n                  (= 1 f) true\n                  :else (recur n (conj v f) r)))]\n    #(is-happy? % #{} (drop 1 (sqr-sum-seq %))))", "problem": 86, "user": "4e3a9dae535deb9a81d77f4a"}, {"code": "#(letfn [(f1 [x] (* x x))\n         (f2 [x]\n             (if (< x 10)\n               [x]\n               (let [a (mod x 10)\n                     b (/ (- x a) 10)]\n                 (lazy-cat [a] (f2 b)))))\n         (f3 [x]\n             (apply + (map f1 (f2 x))))]\n   ((fn f [x y]\n      (let [a (f3 x)]\n        (cond \n         (= a 1) true\n         (y a) false\n         :els (f a (conj y a))))) % #{}))", "problem": 86, "user": "529b44afe4b02ebb4ef7509d"}, {"code": "(fn [n]\n  (letfn \n    [(sumthisbitch [n]\n       (if (= n 0) 0\n         (let [ln (mod n 10) lika (quot n 10)]\n           (+ (* ln ln) (sumthisbitch lika))\n         )))\n     (tryx [n pastsums]\n       (let [thissum (sumthisbitch n)]\n         (if (= thissum 1) true\n           (if (contains? pastsums thissum) false\n             (tryx thissum (conj pastsums thissum))\n             ))))]\n    (tryx n [])))", "problem": 86, "user": "52faec2ee4b047fd55837004"}, {"code": "(fn happy [n]\n  (let [digits (fn [x] (->> (str x) (map #(Character/digit % 10))))]\n    (loop [n n seen #{}]\n      (let [d (digits n)\n            ssd (reduce + (map #(* % %) d))]\n      (cond \n        (= 1 ssd) true\n        (contains? seen ssd) false\n        :else (recur ssd (conj seen ssd))))))\n  )", "problem": 86, "user": "52ffb7f2e4b0d8b024fd370b"}, {"code": "(fn [n]\n  (loop [m n\n         seen #{}]\n    (let [digits (->> m str seq (map #(Character/digit % 10)))\n          sq-digits-sum (apply + (map #(* % %) digits))]\n      (cond\n        (= 1 sq-digits-sum) true\n        (seen sq-digits-sum) false\n        :else (recur sq-digits-sum (conj seen sq-digits-sum))))))", "problem": 86, "user": "530e9729e4b08068f379ecbc"}, {"code": "(fn happy[x] (\n\tloop [x x it 0] (\n\t\tletfn [ \n\t\t( step [i] (reduce + (map square (todigits i))))\n\t\t( todigits[i] (map #(Integer/parseInt (str %)) (str i)))\n\t\t( square [i] (* i i))\n\t\t]\n\t\t(if ( = 100 it) \n\t\t\tfalse \n\t\t\t(if ( = 1 ( step x) ) \n\t\t\t\ttrue \n\t\t\t\t(recur (step x) (inc it))\n\t\t\t\t)\n\t\t\t) \n\t\t)\n\t))", "problem": 86, "user": "5307e4ece4b02e82168697a9"}, {"code": "(fn is-happy-number[n] \n  (let[z (int \\0)] \n    (loop[x n s #{}] \n      (cond \n       (= x 1) true \n       (contains? s x) false \n       :else (recur (reduce + (map #(let[i (- (int %) z)] (* i i)) (str x))) (conj s x))\n       )\n      )\n    )\n  )", "problem": 86, "user": "52e68e61e4b09f7907dd1479"}, {"code": "(fn [i]\n  (let [square #(* % %)\n        char->num #(read-string (str %))\n        transform\n        ;; 123 -> \"123\" -> \\1 \\2 \\3 -> 1 2 3 -> 1 4 9 -> 14\n        (fn [i] (->> i str seq\n                     (map #(square (char->num %)))\n                     (apply +)))]\n    (loop [visited #{}\n           i i]\n      (if (= 1 i)\n        true\n        (let [new (transform i)]\n          (if (contains? visited new) ;; repeated?\n            false\n            (recur (conj visited new)\n                   new)))))))", "problem": 86, "user": "509e62a8e4b08df8156e9e2e"}, {"code": "(fn happy-number? [x]\n  (let [get-digits #(loop [x %\n                           result []]\n                      (if (< x 10)\n                        (cons x result)\n                        (recur (int (/ x 10))\n                               (cons (- x (* (int (/ x 10)) 10)) result))))]\n    (loop [x x\n           tried-numbers #{}]\n      (cond (= x 1) true\n            (contains? tried-numbers x) false\n            :else (let [next (reduce (fn [sum d] (+ sum (* d d)))\n                                     0\n                                     (get-digits x))]\n                    (recur next (conj tried-numbers x)))))))", "problem": 86, "user": "5310e7aee4b08068f379ecdc"}, {"code": "#(if (or (= 2 %) (= 3 %)) false true)", "problem": 86, "user": "52a5a8ebe4b0c58976d9abed"}, {"code": "#(not (or (= % 2) (= % 3)))", "problem": 86, "user": "5300158ae4b0d8b024fd370f"}, {"code": "(fn is-happy? [x]\n  (let [calc (fn [x]\n               (int (reduce + (map #(-> % str Integer/parseInt (Math/pow 2)) (seq (str x))))))]\n    (loop [numbers #{x}, n x]\n      (let [r (calc n)]\n        (cond\n          (= 1 r) true\n          (contains? numbers r) false\n          :else \n          (recur (conj numbers r) r))))))", "problem": 86, "user": "52cf084ce4b07d0d72b27399"}, {"code": "(fn [n] \n   (loop [n n ns #{}]\n     (cond\n       (= 1 n) true\n       (contains? ns n) false\n       :else (recur \n               (reduce\n                 #(+ %1 (* %2 %2)) \n                 0\n                 (map (comp read-string str) (str n))) (conj ns n)))))", "problem": 86, "user": "52dc2bc8e4b09f7907dd13ca"}, {"code": "(fn happy?\n  ([x] (happy? x #{}))\n  ([x v]\n    (let\n      [y ;let y = sum of sq digs (x)\n        (reduce\n          + ((fn sqdigs [n] (if (zero? n) '() (cons (* (mod n 10) (mod n 10)) (sqdigs (quot n 10))))) x)\n        )   \n      ]    \n      (or\n        (= y 1)\n        (if (v y)\n          false\n          (recur y (conj v y))\n        )  \n      )  \n    )        \n  ) \n)", "problem": 86, "user": "5176afd2e4b085adf681d889"}, {"code": "(fn happy [n]\n  (letfn [(digits [n]\n                 (loop [c n res ()]\n                   (if (< c 10)\n                     (conj res c)\n                     (recur (quot c 10) (conj res (rem c 10))))))]\n    (loop [c n seen #{n}]\n      (let [next-step (reduce + (map #(* % %) (digits c)))]\n        (cond \n         (= next-step 1) true\n         (seen next-step) false\n         :else (recur next-step (conj seen next-step)))))))", "problem": 86, "user": "5326c5f7e4b09d4e7a9b54f2"}, {"code": "(fn happy [n]\n   (let [newnum (reduce + (map\n                    #(* % %)\n                    (map #(- (int %) 48) (to-array (str n)))))]\n     (if (< newnum 10)\n       (= newnum 1)\n       (happy newnum))))", "problem": 86, "user": "5125029de4b0ce9225d2ed3e"}, {"code": "(fn happy-numbers [n]\n  (letfn [(sum-square [x]\n            (loop [a x b 0]\n              (if (not (zero? a))\n                (recur (quot a 10) (+ b (#(* % %)(rem a 10))))\n                b)))]\n    (loop [a n acc #{} n' (sum-square n)]\n      (if (= 1 n')\n        true\n        (if (contains? acc n')\n          false\n          (recur n' (conj acc n') (sum-square n')))))))", "problem": 86, "user": "531c0619e4b08068f379ed98"}, {"code": "(letfn [(ss [n] (reduce + (map #(* % %) (map #(Integer. (str %)) (seq (str n))))))]\n  (fn happy?\n    ([n] (happy? #{} n))\n    ([seen n]\n     (cond\n      (= n 1) true\n      (contains? seen n) false\n      :else (recur (conj seen n) (ss n))))))", "problem": 86, "user": "532347dde4b09d4e7a9b54cc"}, {"code": "(fn [n]\n  (letfn [(digits [n] (if (zero? n) '(0) (cons (rem n 10) (digits (quot n 10)))))\n          (sos [n] (reduce + (map #(* % %) (digits n))))]\n    (loop [tried #{} m n]\n      (cond\n         (tried m) false\n         (= 1 m) true\n         :else (recur (conj tried m) (sos m))))))", "problem": 86, "user": "4ff3df0fe4b0678c553fc355"}, {"code": "(fn [n] (letfn [(f[n] (cons n\n                  (lazy-seq (f (reduce + (map #(* % %) (map #(Integer/parseInt (str %)) (str n)))) ))))]\n                  (= true (some #(= % 1) (take 10 (f n))))))", "problem": 86, "user": "531f1e63e4b08068f379edc2"}, {"code": "(fn is-happy \n   ([x] (is-happy x #{}))\n   ([x memory]\n      (cond\n       (contains? memory x) false\n       (= 1 x) true\n       :else (is-happy \n              (->> x\n                   (str)\n                   (map #(- (int %) (int \\0)))\n                   (map #(* % %))\n                   (reduce +)) \n              (conj memory x)))))", "problem": 86, "user": "531490bde4b08068f379ed17"}, {"code": "(fn [n]\n  (let [to-digits #(map {\\0 0 \\1 1 \\2 2 \\3 3 \\4 4 \\5 5 \\6 6 \\7 7 \\8 8 \\9 9} (str %))]\n    (loop [acc [] x n]\n      (let [r (->> (to-digits x)\n                   (map #(* % %))\n                   (reduce +))]\n        (cond (= 1 r) true\n              (some #(= r %) acc) false\n              :else (recur (conj acc r) r))))))", "problem": 86, "user": "530cb5b8e4b02e82168697e0"}, {"code": "(fn [n]\n  (loop [x n, s #{}]\n     (cond \n        (= x 1) true\n        (get s x) false \n        :else (recur (apply + (map #(let [i (Long/parseLong (str %))] (* i i)) (str x ))) (conj s x)))))", "problem": 86, "user": "53300924e4b019098a6f8b55"}, {"code": "(fn [n]\n  ((fn ! [x hist]\n     (let [squared-sum (apply + (map #(* % %) (map #(Integer/parseInt %) (map str ((comp seq str) x)))))]\n       (cond (= squared-sum 1) true\n             (or (= squared-sum 0) (some #{squared-sum} hist)) false\n             :else (! squared-sum (conj hist squared-sum)) ))) n []))", "problem": 86, "user": "52be0263e4b07a9af579230e"}, {"code": "(fn happy? [n]\n  (letfn [(square-sum [s]\n            (reduce #(+ %1 (* %2 %2)) 0 (map #(Character/getNumericValue %) s)))]    \n    (loop [s #{} n n]\n      (cond\n        (and (> n 1) (not (s n))) (recur (conj s n) (square-sum (str n)))\n        (= n 1) true\n        :else false))))", "problem": 86, "user": "52d00832e4b07d0d72b273b4"}, {"code": "#(> % 3)", "problem": 86, "user": "5336a339e4b0e30313ee6c7d"}, {"code": "(fn [n]\n  (letfn [\n    (sumsquare [i] (reduce #(+ (* %2 %2) %1) 0 (map #(Character/digit % 10) (str i))))]\n  (loop [sumsquares (iterate sumsquare n) prevset #{}]\n    (let [e (first sumsquares)]\n      (if (prevset e)  \n        (= e 1) ; when a cycle is found, happy if one else not\n        (recur (next sumsquares) (conj prevset e)))))))", "problem": 86, "user": "533ab9abe4b0e30313ee6cbf"}, {"code": "(fn [number]\n  (letfn [(iter [n]\n                (let [as-digits (map #(read-string (str %)) (sequence (str n)))\n                      sum-of-squares (apply + (map #(* % %) as-digits))]\n                  sum-of-squares))]\n    (loop [n number so-far #{}]\n      (cond (not (so-far n)) (recur (iter n) (conj so-far n))\n            (= n 1) true\n            :else false))))", "problem": 86, "user": "51a3b135e4b0e77c4ca60bf6"}, {"code": "(fn [n]\n  (let [f (fn [n] (reduce #(+ % (* (- (int %2) 48) (- (int %2) 48))) 0 (str n)))\n        h (fn h [n s]\n            (let [a (= 1 n) b (s n)]\n              (if a\n                a\n                (if b\n                  (not b)\n                  (h (f n) (conj s n))))))]\n    (h n #{})))", "problem": 86, "user": "506d5e4ce4b0a302964c5493"}, {"code": "(fn [x]\n  (letfn [(sumsq [n] (\n            ->> n\n            str\n             (map #(let [v ( Character/getNumericValue %)] (* v v)) )\n             (reduce +)\n            ))]\n    (loop [ss (sumsq x)]\n      (case ss\n        1 true\n        4 false\n        (recur (sumsq ss))\n        )\n      ))\n  )", "problem": 86, "user": "5281a445e4b0757a1b17143a"}, {"code": "(letfn [(num->digits [num]\n          (loop [n num res []]\n            (if (zero? n)\n              res\n              (recur (long (/ n 10)) (cons (mod n 10) res)))))\n        (change [n]\n          (apply + (map #(* % %) (num->digits n))))]\n  (fn [init]\n    (loop [curr init results #{}]\n      (println curr \" - \" results)\n      (cond\n       (= 1 curr) true\n       (results curr) false\n       :else (let [new-n (change curr)]\n               (println curr new-n)\n               (recur new-n (into results [curr])))\n       )))\n  )", "problem": 86, "user": "50436470e4b034ff00315d23"}, {"code": "(fn giggity [n]\n  (letfn [(get-digits [n] (map #(Integer/parseInt (str %)) (str n)))\n          (get-happy  [n] (reduce + (map #(* % %) (get-digits n))))]\n    (loop [visits 1 n n]\n      (let [n (get-happy n)]\n        (cond\n         (= 1 n) true\n         (< 1000 visits) false\n         :else (recur (inc visits) n))))))", "problem": 86, "user": "52d2ca1ce4b099d49816f0b4"}, {"code": "(fn [x] (letfn [(helper [n] (reduce (fn [acc d] (+ acc (* d d))) 0 (map #(Integer/parseInt (str %)) (str n)))) \n               (is-happy [acc n] (let [z (helper n)]  (if (= 1 z) true (if (contains? acc z) false (is-happy (conj acc z) z)))))] \n                          (is-happy [] x)))", "problem": 86, "user": "52265e41e4b04e78ff2e1981"}, {"code": "(fn happy? [n]\n  (loop [vis #{}\n         n   n]\n    (cond\n     (= 1 n) true\n     (vis n) false\n     \n     :else\n     (recur (conj vis n)\n            (apply +\n              (map (comp\n                    #(* % %)\n                    #(- % 48)\n                    int)\n                   (str n)))))))", "problem": 86, "user": "532ab0bde4b09d4e7a9b5527"}, {"code": "(fn [n]\n  (let [sq #(* % %)\n        get-digits (fn [m]\n                     (map (comp read-string str) (str m)))]\n    (loop [S #{}\n           k n]\n      (if (= 1 k)\n        true\n        (if (contains? S k)\n          false\n          (recur (conj S k) (reduce + (map sq (get-digits k)))))))))", "problem": 86, "user": "5054c853e4b0b1b9d1860eb3"}, {"code": "(fn [x]\n  (loop [i x s #{}]\n    (if (= i 1)\n      true\n      (let [n (apply + (map #(* (- (int %) 48) (- (int %) 48)) (str i)))]\n        (if (not (nil? (s n)))\n          false\n          (recur n (conj s n)))))))", "problem": 86, "user": "53468f6ce4b084c2834f4a3f"}, {"code": "(letfn [(sum-square-digits\n           [k]\n           (if (< k 1)\n             0\n             (let [d (mod k 10)\n                   n (/ (- k d) 10)]\n               (+ (* d d) (sum-square-digits n)))))]\n   (fn [x]\n     (loop [n x\n            sofar #{}]\n       (cond\n        (= 1 n) true\n        (contains? sofar n) false\n        :else (recur (sum-square-digits n) (conj sofar n))))))", "problem": 86, "user": "53224d45e4b09d4e7a9b54c0"}, {"code": "(fn [n]\n  (letfn [(digits [x0]\n                   (loop [xi x0 ds []]\n                     (if (zero? xi)\n                       ds\n                       (recur (quot xi 10) (conj ds (rem xi 10))))))]\n          (loop [h n visited #{}]\n            (let [t (reduce + (map #(* % %) (digits h)))]\n              (if (visited t)\n                false\n                (if (= t 1)\n                  true\n                  (recur t (conj visited t))))))))", "problem": 86, "user": "5341b141e4b00652c8746ecf"}, {"code": "(fn [a] (\n\tlet [qs (fn [x] (reduce #(+ % (* (Character/digit %2 10) (Character/digit %2 10))) 0 (str x)))]\n\t(loop [cx a xset #{}]\n\t\t( if (= cx 1) true\n\t\t\t(if (contains? xset cx) false (recur (qs cx) (conj xset cx)))\n\t\t))\n))", "problem": 86, "user": "52570aeae4b0541d1855ba42"}, {"code": "(letfn [(dig [n]\n          (if (> 10 n) [n]\n              (let [x (mod n 10)]\n                (conj (dig (-> n (- x) (/ 10))) x))))\n        (*+ [x] (->> x dig  (map #(* % %)) (apply +)))]\n  (fn [x]\n    (loop [acc [] n x]\n      (if (= 1 n) true\n          (if (contains? acc n) false\n              (recur (conj acc n) (*+ n)))))))", "problem": 86, "user": "52d1e364e4b0d9f9285948e7"}, {"code": "(fn [n]\n  (let [f (fn [x] (reduce + (map #(* % %) (map #(Integer/parseInt %) (map str (str x))))))]\n    (loop [n n r #{} c 200000]\n      (if (= 1 n)\n        true\n        (let [m (f n)]\n          (if (or (contains? r m) (= 0 c))\n            false\n            (recur m (conj r m) (dec c))))))))", "problem": 86, "user": "53219cece4b09d4e7a9b54b7"}, {"code": "(fn [n]\n  (let [succ (fn [n] (reduce + (map #(let [d (read-string (str %))] (* d d)) (str n))))]\n    (loop [seen #{n} n (succ n)]\n      (if (= n 1)\n        true\n        (if (contains? seen n)\n          false\n          (recur (conj seen n) (succ n)))))))", "problem": 86, "user": "5349ac2be4b084c2834f4a67"}, {"code": "(fn [n]\n  (let [q #(* % %)\n        d #(-> % str Integer/valueOf q)\n        s (iterate #(apply + (map d (str %))) n)]\n    (loop [i (first s)\n           l (rest s)\n           t #{}]\n      (if (= 1 i)\n        true\n        (if (contains? t i)\n          false\n          (recur (first l) (rest l) (conj t i)))))))", "problem": 86, "user": "53460d02e4b084c2834f4a39"}, {"code": "(fn [n]\n  (let [square (fn [a] (* a a))\n          sum-squares (fn [coll] (reduce + (map square coll)))\n          digits (fn [b] (map (comp read-string str) (seq (str b))))]\n    (loop [c 1 x n]\n      (let [next-x (sum-squares (digits x))]\n        (cond (= next-x 1) true\n              (> c 100) false\n              :else (recur (inc c) next-x))))))", "problem": 86, "user": "50fc299ee4b0d10d794c19f2"}, {"code": "(fn [m]\n   (loop [n m\n          s #{}]\n     (let [x (->> n str\n                  (map #(Integer. (str %)))\n                  (map #(* % %))\n                  (apply +))]\n       (cond\n        (= x 1) true\n        (contains? s x) false\n        :else (recur x (conj s x))))))", "problem": 86, "user": "5175533fe4b0dea9bbfba575"}, {"code": "(fn [x] (= 1 (nth (iterate #(reduce (fn [y z] (+ y (let [t (- (int z) 48)] (* t t)))) 0 (str %)) x) 10)))", "problem": 86, "user": "526a7025e4b03e8d9a4a722a"}, {"code": "(fn [n]\n  (letfn [(digs\n           ([n] (digs n '()))\n           ([n l] (if (zero? n) l (digs (quot n 10) (conj l (mod n 10)))))) \n          (is-happy? \n           [n s] \n           (if\n             (some #{n} s) false\n             (let [sum-digs (reduce #(+ %1 (* %2 %2)) 0 (digs n))]\n               (if (= 1 sum-digs)\n                 true\n                 (recur sum-digs (conj s n))))))]\n    (is-happy? n #{})))", "problem": 86, "user": "52dd4fb4e4b09f7907dd13df"}, {"code": "(fn [n]\n  (letfn [(squ-sum [a]\n                  \"square every digit, and sum it\"\n                  (loop [sum 0\n                         a a]\n                    (if (zero? a)\n                      sum\n                      (recur (+ sum (* (mod a 10)\n                                       (mod a 10)))\n                             (quot a 10)))))]\n    (loop [item n\n           sitem #{}]\n      (let [item (squ-sum item)]\n        (if (= 1 item)\n          true\n          (if (sitem item)\n            false\n            (recur item (set(cons item sitem)))))))))", "problem": 86, "user": "531d34cfe4b08068f379edac"}, {"code": "(fn [n]\n  (letfn [(to-int-list [n] (map #(- (int %) 48) (str n)))\n          (sum-squares [n] (reduce + (map #(* % %) (to-int-list n))))]\n    (loop [n n nn []]\n      (cond \n       (= 1 n) true\n       (contains? nn n) false\n       :else (recur (sum-squares n) (conj nn n))))))", "problem": 86, "user": "53244c9de4b09d4e7a9b54db"}, {"code": "(fn [number]\n  (letfn [(get-digits [number]\n            (reduce #(conj %1 (- (int %2) (int \\0)))\n                    [] (str number)))\n          (get-squared-sum [number]\n            (apply + (map #(* % %) (get-digits number))))]\n    (loop [curr-number number seen-numbers []]\n      (if (= 1 curr-number)\n        true\n        (if (some #{curr-number} seen-numbers)\n          false\n          (recur (get-squared-sum curr-number) (conj seen-numbers curr-number)))))))", "problem": 86, "user": "53070615e4b02e821686979e"}, {"code": "(let [digits\n      #(- (int %) (int \\0))\n      next-in-line\n      (fn f [a]\n        (reduce +\n                (map #(* % %) (map digits (str a)))))]\n(fn happy? [x]\n  (loop [visited #{}\n         actual (next-in-line x)]\n    (if (= actual 1)\n      true\n      (if (visited actual)\n        false\n        (recur (conj visited actual) (next-in-line actual)))))))", "problem": 86, "user": "52e17e66e4b09f7907dd1423"}, {"code": "(fn happy? [n]\n  (let [r (int (apply + (map #(Math/pow (Character/getNumericValue %) 2) (str n))))]\n    (condp = r\n      1 true\n      4 false\n      (happy? r))\n    ))", "problem": 86, "user": "53307da1e4b019098a6f8b5e"}, {"code": "(fn [x]\n  (letfn [(digits [x]\n            (loop [x x\n                   digits '()]\n              (if (> x 0)\n                (recur (int (/ x 10)) (cons (mod x 10) digits))\n                digits)))\n          (sum-sqs [xs] (->> xs (map #(* % %)) (reduce +)))]\n    (loop [x x\n           seen #{}]\n      (let [y (sum-sqs (digits x))]\n        (cond\n          (= 1 y) true\n          (seen y) false\n          :else (recur y (conj seen y)))))))", "problem": 86, "user": "5312cdaae4b08068f379ed03"}, {"code": "(fn [n]\n  (loop [n n p #{}]\n    (if (p n)\n      (= n 1)\n      (recur (apply + (map #(* % %)\n                           (map #(read-string (str %)) (str n))))\n             (conj p n)))))", "problem": 86, "user": "535d910ae4b04ce2eb3ed2c5"}, {"code": "(fn [x]\n    (letfn [(squared-sum [y]\n              (->> y\n                   str\n                   seq\n                   (map str)\n                   (map read-string)\n                   (map #(* % %))\n                   (reduce +)))]\n      (loop [seen #{}\n             num x]\n        (cond\n         (= num 1) true\n         (contains? seen num) false\n         :else (recur \n                (conj seen num)\n                (squared-sum num))))))", "problem": 86, "user": "53487737e4b084c2834f4a59"}, {"code": "(fn [n]\n    (loop [current n seen #{}]\n      (let [x (->> current\n           str\n           seq\n           (map str)\n           (map #(Integer/parseInt %))\n           (map #(* % %))\n           (reduce +))]\n        (if (= x 1) true\n          (if (contains? seen x) false\n            (recur x (conj seen x)))))))", "problem": 86, "user": "52a32876e4b04e0c58e87bfb"}, {"code": "(fn happy? [i]\n  (let [int->digits (fn [i] (map #(- (int %) 48 ) (str i)))\n        sum (fn [is] (apply + is))\n        square (fn [i] (* i i))\n        summed-squares (fn [i] \n                         (->>\n                           i\n                           int->digits\n                           (map #(square %))\n                           sum))]\n    (loop [i i\n           previous #{i}]\n      (let [next (summed-squares i)]\n        (cond \n          (= 1 next) true\n          (contains? previous next) false\n          :else (recur next (conj previous next)))))))", "problem": 86, "user": "53513d28e4b084c2834f4ae3"}, {"code": "(fn [n]\n  (loop [x n nums []]\n    (let [sum ((fn [n]\n                 (reduce\n                  +\n                  (map (fn [x] ((fn [x] (* x x)) (-> x str Integer/parseInt)))\n                       (str n)))) x)]\n      (if (= sum 1)\n        true\n        (if (some #(= % sum) nums)\n          false\n          (recur sum (conj nums sum)))))))", "problem": 86, "user": "5225271fe4b01819a2de42f9"}, {"code": "#(letfn\n\t[(nextNum [x sum] (if (zero? x) sum\n\t\t\t\t\t\t(recur \n\t\t\t\t\t\t\t(int (/ x 10)) \n\t\t\t\t\t\t\t(+ sum (let [n (mod x 10)] (* n n) )) )))\n\t(isHappy? [cur pSet]\n\t\t(let [n (nextNum cur 0)]\n\t\t\t(if (= n 1)\n\t\t\t\ttrue\n\t\t\t\t(if (contains? pSet n)\n\t\t\t\t\tfalse\n\t\t\t\t\t(recur n (conj pSet n))))))\n\t]\n\t(isHappy? % #{%})\n)", "problem": 86, "user": "52bf6946e4b07a9af5792334"}, {"code": "(fn happy?\n  ([n]\n     (happy? n []))\n  ([n seen-numbers]\n     (let [to-digits (fn [n] (map (comp read-string str) (str n)))\n           square    #(* % %)\n           happy-n (reduce + (map square (to-digits n)))]\n       (cond (= 1 happy-n)\n             true\n             (some (set seen-numbers) #{happy-n})\n             false\n             :else\n             (recur happy-n (cons happy-n seen-numbers))))))", "problem": 86, "user": "4daeabf6edd6309eace4d15c"}, {"code": "(fn hn [n]\n  (loop [n n acc #{}]\n    (if (= 1 n)\n      true\n      (if (contains? acc n)\n        false\n        (recur\n         (->> (map #(- (int %) (int \\0)) (str n))\n              (map #(* % %))\n              (reduce +))\n         (conj acc n))))))", "problem": 86, "user": "52fb64b7e4b047fd55837009"}, {"code": "(fn happy-nums\n  [n]\n  (letfn [(get-next\n            [x]\n            (apply + (map #(* % %)\n                          (map #(Integer/parseInt (str %)) (str x)))))]\n    (loop [r []\n           nn (get-next n)]\n      (if (= nn 1)\n        true\n        (if (some #(= % nn) r)\n          false\n          (recur (conj r nn) (get-next nn))))\n      )))", "problem": 86, "user": "5348cab4e4b084c2834f4a5e"}, {"code": "(fn happy?\n  ([x] (happy? #{} x))\n  ([sadset x]\n   (let [pow2 (fn [z] (let [z' (Integer/parseInt (str z))] (* z' z')))\n         x' (apply + (map pow2 (str x)))]\n     (cond\n       (= x' 1) true\n       (sadset x') false\n       :else (happy? (conj sadset x') x')))))", "problem": 86, "user": "536d83cee4b0fc7073fd6e5e"}, {"code": "(fn [s n]\n  (let [m (reduce + (map #(* % %)\n                         (map (comp read-string str)\n                              (str n))))]\n    (cond (s m) false\n          (= m 1) true\n          true (recur (conj s n) m))))\n#{}", "problem": 86, "user": "536e0930e4b0fc7073fd6e66"}, {"code": "(fn [n]\n  (loop [n n \n         res #{}]\n    (cond \n     (= n 1) true\n     (contains? res n ) false\n     :else (recur (reduce + (map (comp #(* % %) read-string str)(str n))) (conj res n)) )))", "problem": 86, "user": "53691dc7e4b0243289761e97"}, {"code": "(fn [n] \n  (letfn [(digits [n] (map #(- (int %) 48) (.toString n)))\n          (one-step [n] (reduce + (map #(* % %) (digits n))))]\n    (loop [n n, acc #{n}]\n      (let [n2 (one-step n)]\n        (cond (= n2 1) true\n              (contains? acc n2) false\n              :else (recur n2 (conj acc n)))))))", "problem": 86, "user": "536ca4bde4b0fc7073fd6e49"}, {"code": "(let [digits          (fn [s]\n                          (map #(Integer. %) (map str (seq (str s)))))\n        sum-of-squares  (fn [ds]\n                          (reduce + (map #(* % %) ds)))\n        next-happy      (fn [n]\n                          (sum-of-squares (digits n)))]\n    (fn happy?\n      ([n] (happy? #{} n))\n      ([seen n0]\n       (let [n1 (next-happy n0)]\n         (cond\n           (= n0 n1)\n           true\n           (contains? seen n1)\n           false\n           :else\n           (recur (conj seen n1) n1))))))", "problem": 86, "user": "5370ef22e4b0fc7073fd6ea0"}, {"code": "(fn [n] (let [break (fn break [n] (if (> n 0)\n                              (cons (mod n 10) (lazy-seq (break (quot n 10))))\n                              nil))\n              step (fn [n] (apply + (map #(* % %) (break n))))]\n        \t(loop [n n seen #{}]\n              (if (= n 1)\n                true\n              \t(if (contains? seen n)\n                \tfalse\n                  (recur (step n) (conj seen n)))))))", "problem": 86, "user": "534f13b2e4b084c2834f4ac4"}, {"code": "(fn is-happy? [n]\n  (cond (= n 4) false\n     (= n 1) true\n     :else (recur (reduce + (map #(* % %) (map #(Character/digit % 10) (str n)))))))", "problem": 86, "user": "525c575be4b0cb4875a45d38"}, {"code": "(fn [n]\n  ((fn check [m xs]\n    (loop [x m r 0]\n      (cond\n       (and (= x 0) (= r 1)) true\n       (and (= x 0) (contains? xs r)) false\n       (> x 0) (recur (quot x 10) (+ r (* (rem x 10) (rem x 10))))\n       :else (check r (conj xs m))\n      ))\n   ) n #{}))", "problem": 86, "user": "5370f8ede4b0fc7073fd6ea2"}, {"code": "(fn f\n  ([n] (f n []))\n  ([n ns]\n     (cond\n      (= n 1) true\n      (some #(= n %) ns) false\n      :else (recur (reduce + 0 (map #(let [a (- (int %) 48)]\n                                       (* a a)) (str n)))\n                   (conj ns n)))))", "problem": 86, "user": "50ae0d24e4b0a40c9cfb08ce"}, {"code": "(fn [n]\n  (loop [n n, seen #{}]\n    (let [hap (reduce #(+ % (* %2 %2)) 0 (map #(- (int %) 48) (str n)))]\n      (cond\n       (= 1 hap) true\n       (seen hap) false\n       :else (recur hap (conj seen hap))))))", "problem": 86, "user": "524b0645e4b09eba1c0223bf"}, {"code": "(fn t2 [n]\n  (letfn [(decompose_numbers [n]\n           (if (< n 10)\n                [n]\n                (conj (decompose_numbers (int (/ n 10))) (rem n 10))))]\n    (loop [n (reduce + (map #(* %1 %1) (decompose_numbers n)))  c 0]\n      (cond     \n        (= n 1) true\n        (= c 1000) false\n        :else\n         (recur\n          (reduce + (map #(* %1 %1) (decompose_numbers n))) (inc c))))))", "problem": 86, "user": "5046f909e4b03b02161376b5"}, {"code": ";; check against numbers seen\n(fn __ [n]\n  ;; define next-number\n  (let [next-number (fn [n]\n                      (let [seq-digits (map #(Integer/parseInt (str %)) (str n))]\n                        (reduce + (map #(* % %) seq-digits))))]\n    \n    (loop [seen #{} ; set of numbers seen\n           num  n]\n      (println (str num))\n      (cond\n       (contains? seen num) false\n       (= num 1)            true\n       :else                (recur (conj seen num) (next-number num))))))", "problem": 86, "user": "53415755e4b00652c8746ecd"}, {"code": "(fn [n]\n    (letfn [(next-number [n] (apply + (map #(let [i (Integer/parseInt (str %))]  (* i i)) (str n))))]\n      (loop [n n found #{}]\n\t(cond (= n 1) true\n              (contains? found n) false\n              :else (recur (next-number n) (conj found n))))))", "problem": 86, "user": "51c3c6a6e4b0851ac09658f8"}, {"code": "(fn [x]\n   (loop [n x seen []]\n     (let [result (reduce + (map (comp #(* % %) read-string str) (str n)))]\n       (cond\n         (= 1 result) true\n         (true? (contains? seen result)) false\n         :default (recur result (conj seen result))))))", "problem": 86, "user": "4f849f76e4b033992c121c36"}, {"code": "(fn [n]\n  (let [sumDigitsSqr\n    (fn [x]\n      (loop [i x result 0]\n        (do\n        (println result)\n        (if (= i 0)\n          result\n          (recur (quot i 10) (+ result (*(mod i 10)(mod i 10))) )\n        )\n        )\n      )\n    )]\n  (loop [x n seen #{}]\n    (if (= x 1)\n      true\n      (if (contains? seen x)\n        false\n        (recur (sumDigitsSqr x) (conj seen x))\n      )\n    )\n  )\n  )\n)", "problem": 86, "user": "51f09f3de4b0274c496158d7"}, {"code": "(letfn [(S [n]\n          (loop [n n s 0]\n            (if (zero? n) s\n                (recur (quot n 10) (+ s (* (rem n 10) (rem n 10)))))))\n\n        (H? [n]\n          (loop [n n seen #{}]\n            (cond (= n 1) true\n                  (seen n) false\n                  :else (recur (S n) (conj seen n)))))]\n  H?)", "problem": 86, "user": "51a4416ae4b0def3c5c5868c"}, {"code": "(fn [num]\n  (let [next-happy-number (fn [num] (->> (str num)\n                                         (seq)\n                                         (map #(Integer. (str %)))\n                                         (map #(* % %))\n                                         (reduce +)\n                                         ))\n        number-sequence (take 100 (iterate next-happy-number num))]\n    (loop [number-sequence number-sequence]\n      (if (empty? number-sequence)\n        false\n        (if (= (first number-sequence) 1)\n          true\n          (recur (rest number-sequence)))))))", "problem": 86, "user": "53527551e4b084c2834f4af0"}, {"code": "(fn [n]\n  (loop [x n]\n    (condp = x \n     4 false\n     1 true\n     (let [y (map #(Integer/parseInt %) (re-seq #\"\\d\" (str \"\" x)))]\n       (recur (apply + (map #(* % %) y)))))))", "problem": 86, "user": "5371167fe4b0fc7073fd6ea7"}, {"code": "(fn happy? [n]\n(letfn [(n-v [n] (map (comp read-string str) (str n)))\n        (main [n st]\n              (let [nn (apply + (map * n n))\n                    nst (into st [nn])]\n                (if (= 1 nn) true\n                  (if (= st nst) false\n                    (main (n-v nn) nst)))))]\n  (main (n-v n) (set [n]))))", "problem": 86, "user": "53973e7be4b0b51d73faaee6"}, {"code": "(fn happy?\n  ([n]    (happy? #{} n))\n  ([s n]  (let [sum-of-squares  (fn [n] ((fn [v] (apply + (map * v v)))  (map #(Integer/parseInt (str %)) (seq (str n)))))\n                sos             (sum-of-squares n)]\n            (cond\n             (= sos 1)         true\n             ; If s contains sos, then we've hit a cycle, so n is not happy.                                                                                           \n             ; See http://en.wikipedia.org/wiki/Happy_number for why.                                                                                                  \n             (contains? s sos) false\n             :else             (happy? (conj s sos) sos)))))", "problem": 86, "user": "530bf87ee4b02e82168697d5"}, {"code": "(fn [n]\n  (let [max-cnt 100000\n        square-sum (fn square-sum [n]\n                     (->> (map #(- (int %) 48) (seq (str n)))\n                          (map #(* % %))\n                          (apply +)))\n        is-happy (fn [n cnt]\n                   (if (= cnt max-cnt)\n                     false\n                     (let [sqr-sum (square-sum n)]\n                       (if (= n sqr-sum)\n                         true\n                         (recur sqr-sum (inc cnt))))))]\n       (is-happy n 1)))", "problem": 86, "user": "536f871de4b0fc7073fd6e7f"}, {"code": "(fn happy? [n]\n  (letfn [(sqsum [n] (reduce + (map #(* % %) (map #(- (int %) (int \\0)) (vec (str n))))))]\n  (loop [nset #{n} lastn n]\n    (println (str nset))\n    (let [newn (sqsum lastn)]\n      (if (nset newn) \n        false\n        (if (== 1 newn)\n          true\n          (recur (conj nset newn) newn)))))))", "problem": 86, "user": "51a768e0e4b0da5f497bde84"}, {"code": "(fn\n  [n]\n  (letfn [(sumSq [n]\n            (loop [a 0\n                   n n]\n              (if (= n 0)\n                a\n                (let [d (mod n 10)\n                      n' (quot n 10)\n                      a' (+ a (* d d))]\n                  (recur a' n')))))]\n    (loop [n n\n           prev-n #{}]\n      (if (= n 1)\n        true\n        (if (contains? prev-n n)\n          false\n\n          (let [n' (sumSq n)\n                prev-n' (conj prev-n n)]\n            (recur n' prev-n')))))))", "problem": 86, "user": "52dfc89be4b09f7907dd1405"}, {"code": "(fn task-86 [n]\n  ((fn happy-number [n known-numbers]\n      (let [next-number (apply + \n                               (->>\n                                (str n)\n                                (map #(- (int %) 48))\n                                (map #(* % %))))]\n        (if (= 1 next-number) true\n            (if (known-numbers next-number) false (recur next-number (conj known-numbers next-number)))))) n #{}))", "problem": 86, "user": "4ddb696b535d02782fcbe9fa"}, {"code": "(fn [n]\n  (loop [x 1000 res (str n)]\n    (if (or (= x 0) (= (Integer/parseInt res) 1)) (not= x 0)\n      (recur (dec x) (str (reduce + (map #(* (Integer/parseInt (str %)) (Integer/parseInt (str %))) res)))))))", "problem": 86, "user": "53a1b5c8e4b0ca733b9744c1"}, {"problem": 86, "code": "(fn [n]\n  (loop [x n t 1]\n    (if (= 1 x)\n        true\n        (if (= 1000 t)\n            false\n            (recur (apply + (map (comp #(int %) #(Math/pow % 2) #(Character/getNumericValue %)) (seq (str x)))) (inc t))))))", "user": "4ec53f8c535d6d7199dd368b"}, {"problem": 86, "code": "(fn [n] \n  (let [trans (fn [x]\n                (apply + (map #(* % %) (map (comp #(Integer. %) str) (seq (str x))))))\n        f (fn [xs] (conj xs (trans (last xs))))]\n    (= 1 (last (last (take-while #(= % (distinct %)) (iterate f [n])))))))", "user": "53976599e4b0b51d73faaeea"}, {"problem": 86, "code": "(fn happy-number? [x]\n\t(let [unhappy-cycle #{4 16 37 58 89 145 42 20}\n\t\t  digits (map #(Integer/valueOf (str %)) (str x))\n\t\t  sum (reduce + (map #(* % %) digits))]\n\t\t(cond \n\t\t\t(= sum 1) true\n\t\t\t(contains? unhappy-cycle sum) false\n\t\t\t:else (recur sum))))", "user": "52e657e4e4b09f7907dd1472"}, {"problem": 86, "code": "(fn happy? [n]\n  (loop [s #{}\n         i n]\n    (if (= 1 i)\n      true\n      (if (contains? s i)\n        false\n        (recur (conj s i)\n               (loop [sum 0\n                      j i]\n                 (if (= 0 j)\n                   sum\n                   (recur (+ sum (* (mod j 10)\n                                    (mod j 10)))\n                          (quot j 10)))))))))", "user": "4f041de1535dcb61093f6ba5"}, {"problem": 86, "code": "(fn [ number ]\n    (loop [ n number ]\n        (condp = n \n            4 false\n            1 true\n            (recur (->> (map #(-> (str %) Integer/parseInt) (str n))\n                        (map #(* % %)) (reduce +))))))", "user": "5398305fe4b0b51d73faaef6"}, {"problem": 86, "code": "(fn [n]\n  (let [nums (fn [x] (map read-string (map str (str x))))\n        sumsq (fn [xs] (apply + (map #(* % %) xs)))\n        happy? (fn [xs seen]\n                  (cond (contains? seen (sumsq xs)) false\n                        (= 1 (sumsq xs)) true\n                        :else (recur (nums (sumsq xs)) (conj seen (sumsq xs)))))]\n    (happy? (nums n) #{})))", "user": "53806e5be4b06839e8705ec1"}, {"problem": 86, "code": "(fn [x]\n   (loop [v x a #{}]\n     (if (contains? a v)\n       false\n       (if (= v 1)\n         true\n         (recur (reduce #(let [v1 (- (int %2) (int \\0))]\n                           (+' %1 (* v1 v1)))\n                        0 (seq (str v)))\n                (conj a v))))))", "user": "53aaaf7ae4b047364c044444"}, {"problem": 86, "code": "(fn happy? ([n] (happy? n '()))\n  ([n l]\n   (cond (= n 1) true\n         (some #(= n %) l) false\n         :else (recur (->> (range) (map #(.pow 10M %)) \n                           (take-while #(>= n %))\n                           (map #(mod (quot n %) 10))\n                           (map #(* % %)) \n                           (reduce +) (int))\n                      (cons n l)))))", "user": "536f5900e4b0fc7073fd6e7b"}, {"problem": 86, "code": "(fn [n]\n  (letfn [(digits [num]\n            (loop [acc ()\n                   num num]\n              (if (< num 10)\n                (conj acc num)\n                (recur (conj acc (rem num 10))\n                       (quot num 10)))))\n          (squared-sum [& digits]\n            (reduce + (apply map #(* % %) digits)))]\n    (loop [n n\n           acc #{}]\n      (let [new-number (squared-sum (digits n))]\n        (if (= 1 new-number)\n          true\n          (if (contains? acc new-number)\n            false\n            (recur new-number\n                   (conj acc new-number))))))))", "user": "532bce35e4b09d4e7a9b5536"}, {"problem": 86, "code": "(fn [n]\n  (loop [n n s #{}]\n    (cond \n      (= n 1)  true\n      (s n) false\n      :else\n        (recur (->> (str n)\n                    (map #(Character/digit % 10))\n                    (map #(* % %))\n                    (reduce +))\n               (conj s n)))))", "user": "53ae16e2e4b047364c044472"}, {"problem": 86, "code": "(fn happy-number? [n]\n    (loop [n n\n           so-far #{}]\n      (if (contains? so-far n)\n        false\n        (let [new-n (reduce + (map #(* % %) (map #(read-string (str %)) (str n))))]\n          (if (not= 1 new-n)\n            (recur new-n (conj so-far n))\n            true\n            )\n          ))\n        )\n  )", "user": "5245e320e4b09dbe66b56177"}, {"problem": 86, "code": "(fn [n]\n  (letfn [(to-num [x]\n            (Character/getNumericValue x))\n          (sumsqrs [x]\n            (reduce + (map (comp #(* % %) to-num) (str x))))\n          (it [x results]\n            (let [ss (sumsqrs x)]\n              (cond\n                (= ss 1) true\n                (results ss) false\n                :else (recur ss (conj results ss)))))]\n    (it n #{n})))", "user": "4ef9b021535dced4c769f269"}, {"problem": 86, "code": "(fn happy?\n  [x]\n  (let [get-digits (fn [n]\n                     (map #(- (int %) 48) (str n)))\n        sum-squares (fn [n]\n                      (reduce + (map #(* % %) n)))]\n    \n    (loop [x x\n           tried #{}]\n      (cond\n       (= x 1) true\n       (some #{x} tried) false\n       :else (recur (sum-squares (get-digits x)) (conj tried x))))))", "user": "53ac4719e4b047364c04445c"}, {"problem": 86, "code": "(fn [x]\n  (letfn [(test? [coll y]\n    (if (contains? coll y)\n      false\n      (if (= y 1)\n        true\n        (test? (conj coll y) (reduce + (map #(* % %) (map #(Character/digit % 10) (str y))))))))]\n    (test? #{} x)))", "user": "536b9d8ae4b0243289761ebe"}, {"problem": 86, "code": "(fn happy? [x]\n  (letfn [(ss [x]\n             (reduce + (map #(* % %) (map #(- (int %) (int \\0)) (str x)))))]\n    (loop [v x vs #{}]\n      (cond (= v 1) true\n            (vs v) false\n            :else (recur (ss v) (conj vs v))))))", "user": "53b39d82e4b047364c0444a6"}, {"problem": 86, "code": "(fn [x]\n  (loop [n x, i 0]\n    (cond (= 1 n) true\n          (> i 100) false ;; over-limit condition (allow 100 tries)\n          :else (recur (reduce + (->> n str (re-seq #\"[0-9]\")(map #(let [n (read-string %)] (* n n)))))\n                       (inc i)))))", "user": "538e36c7e4b0b51d73faae81"}, {"problem": 86, "code": "(fn happy-numbers[n]\n\t(letfn [(sq-of-digs [p] \n\t\t\t\t(.intValue \n\t\t\t\t(reduce + \n\t\t\t\t(map #(Math/pow % 2) \n\t\t\t\t(map #(Character/digit % 10) (str p))))))]\n\t\t(loop [start n seen #{}]\n\t\t\t(cond (= start 1) true\n\t\t\t\t   (contains? seen start) false\n\t\t\t\t   :else (recur (sq-of-digs start) (conj seen start))))))", "user": "538e29d1e4b0b51d73faae80"}, {"problem": 86, "code": "(fn [n]\n  (loop [n n, s #{}]\n    (cond (= n 1) true\n          (contains? s n) false\n          :else (let [x (->> (str n)\n                             (map (comp #(* % %) #(Character/getNumericValue %)))\n                             (reduce +))]\n                  (recur x (conj s n))))))", "user": "537f4652e4b06839e8705eb1"}, {"problem": 86, "code": "(fn [n]\n  (contains? ((fn happy-group [x s]\n                (let [new-x (apply + \n                                   (map #(int (Math/pow (Integer/parseInt (str %)) 2)) \n                                        (str x)))]\n                  (if (s new-x)\n                    s\n                    (happy-group new-x (conj s new-x)))))\n              n #{n}) 1))", "user": "53acaf1fe4b047364c04445f"}, {"problem": 86, "code": "(fn [n]\n  (loop [n n, seen #{}]\n    (cond \n      (= n 1)  true\n      (seen n) false\n      :else\n        (recur (->> (str n)\n                    (map #(Character/digit % 10))\n                    (map #(* % %))\n                    (reduce +))\n               (conj seen n)))))", "user": "53c7cc11e4b00fb29b2212ac"}, {"problem": 86, "code": "(fn [n]\n  (letfn[ (digseq [i] (->> i str seq (map #(str %)) (map #(Integer. %)) ))\n          (magic [i] (reduce + (map #(* % %) (digseq i))))\n          ]\n    (loop [current n\n           seen #{}]\n      (if (= 1 current)\n        true\n      \t(let [nxt (magic current)]\n          (if (seen nxt)\n            false\n            (recur nxt (conj seen nxt))))))))", "user": "53c1ce3ee4b00fb29b221268"}, {"problem": 86, "code": "(fn happy? [num]\n    ((fn foo [prev-nums num]\n        (if (= num 1)\n            true\n            (if (= (prev-nums num) nil) \n                (let [new-num (reduce + (map #(let [n (Integer/parseInt (str %))] (* n n)) (seq (str num))))]\n                    (foo (conj prev-nums num) new-num))\n                false))) #{} num))", "user": "53a94b63e4b047364c044434"}, {"problem": 86, "code": "(fn happy? [x]\n  (loop [current x repeats #{}]\n    (let [digits (map #(read-string (str %)) (str current))\n          sum-of-squares (reduce + (map #(* % %) digits))]\n      (cond (= 1 sum-of-squares) true\n          (contains? repeats sum-of-squares) false\n          :else (recur sum-of-squares (conj repeats sum-of-squares))))))", "user": "53bf0913e4b0c98a41f5cc99"}, {"problem": 86, "code": "(fn happy [x]\n  (loop [y x\n         seen-before #{}]\n    (cond (= y 1) true\n          (contains? seen-before y) false\n          :else (letfn [(digits [x]\n                                (loop [y x\n                                             ds []]\n                                        (if (< y 10) (conj ds y)\n                                          (let [dig (mod y 10)]\n                                            (recur (/ (- y dig) 10) (conj ds dig))))))\n                        (sumSquares [xs] (reduce + (map #(* % %) xs)))]\n                  (recur (sumSquares (digits y)) (conj seen-before y))))))", "user": "53c38b8ce4b00fb29b22127b"}, {"problem": 86, "code": "(fn [x]\n  (letfn [(square [x] (* x x))\n          (digits [x] (map #(Character/getNumericValue %) (str x)))\n          (sum-sq [x] (apply + (map square (digits x))))]\n    (loop [sums #{} n x]\n      (if (= n 1)\n        true\n        (if (sums n)\n          false\n          (recur (conj sums n) (sum-sq n)))))))", "user": "533018b2e4b019098a6f8b56"}, {"problem": 86, "code": "(fn [x]\n  (letfn [(hpy [i] \n               (->> (map #(- (int %) 48) (str i))\n                    (reduce #(+ % (* %2 %2)) 0)))\n          (happ [n a]\n                (cond \n                 (= 1 n) true\n                 (contains? a n) false\n                 true (happ (hpy n) (conj a n))))]\n    (happ x #{})))", "user": "53b7c21ae4b047364c0444d4"}, {"problem": 86, "code": "(fn happy? [n]\n     (loop [terms [n]]\n       (if (== (peek terms) 1)\n         true\n         (if (some #{(peek terms)} (pop terms))\n           false\n           (recur (conj terms (apply + (map #(* % %)\n                                            ((fn f [q]\n                                               (if (< q 10)\n                                                 (vector q)\n                                                 (conj (f (/ (- q (mod q 10)) 10)) (mod q 10)))) (peek terms))))))))))", "user": "532727bae4b09d4e7a9b54fa"}, {"problem": 86, "code": "(fn happy?\n  ([n]\n   (happy? n '()))\n  ([n coll]\n   (cond\n    (some (set (list n)) coll)\n    false\n    \n    (= 1 n)\n    true\n    \n    :else\n    (let [digits (fn digits [n]\n                   (if (< n 10)\n                       [n]\n                       (conj (digits (int (/ n 10))) (mod n 10))))]\n      (happy? (reduce + (map #(* % %) (digits n))) (conj coll n))))))", "user": "52efd3d9e4b05e3f0be25ed4"}, {"problem": 86, "code": "(fn happy? [number]\n  (let [sum-of-sqr\n       (fn [n]\n           (loop [sum 0, x n]\n             (if (= x 0)\n               sum\n               (let [m (mod x 10)]\n                 (recur (+ sum (* m m)) (quot x 10))\n               )\n             )\n           )\n       )]\n\n       (loop [h number, times 100000]\n           (if (> times 0)\n             (if (= h 1)\n               true\n               (recur (sum-of-sqr h) (dec times))\n             )\n             false\n           )\n       )\n  )\n)", "user": "53ca41dae4b00fb29b2212c8"}, {"problem": 86, "code": "(fn [n]\n     (loop [ns #{n} n1 n]\n       (let [r (loop [m1 (quot n1 10) m2 (rem n1 10) acc 0]\n         (if (= 0 m1)\n           (+ acc (* m2 m2))\n           (recur (quot m1 10) (rem m1 10) (+ acc (* m2 m2)))\n           )\n         \n         )]\n         (cond\n          (= 1 r) true\n          (contains? ns r) false\n          :else (recur (conj ns r) r))\n       )\n     \n     \n     \n     ))", "user": "53ca23e3e4b00fb29b2212c6"}, {"problem": 86, "code": "(fn [n] (let [digits (fn digits [x] (if (< x 10) [x] (conj (digits (quot x 10)) (rem x 10))))]\n\t(loop [i n\n\t\t   c #{i}]\n\t\t   (let [x (reduce #(+ %1 (* %2 %2)) 0 (digits i))]\n\t\t\t\t(cond (= 1 x) true \n\t\t\t\t\t  (some #{x} c) false\n\t\t\t\t\t  :else (recur x (conj c x)))))))", "user": "53e19461e4b0d874e779ae59"}, {"problem": 86, "code": "#((fn g [x s]\n      (or (= x 1)\n          (and (not (s x))\n               (g ((fn f [n] (if (= n 0) 0\n                                 (+ (* (rem n 10) (rem n 10)) (f (quot n 10))))) x)\n                  (conj s x)))))\n     % #{})", "user": "53500869e4b084c2834f4ad3"}, {"problem": 86, "code": "(fn happy? [x]\n   (loop [n x\n          seen #{}]\n     (let [digits (map #(Integer/parseInt (str %)) (str n))\n           result (reduce (fn [acc d] (+ acc (* d d))) 0 digits)]\n       (cond\n        (= 1 result) true\n        (contains? seen n) false\n        :else (recur result (conj seen n))))))", "user": "535eaa73e4b04ce2eb3ed2d4"}, {"problem": 86, "code": "(fn [m]\n  (loop [n m\n         s []]\n    (or (= n 1)\n        (if (contains? s n)\n          false\n          (recur\n           (->> (str n)\n                (map #(Character/digit % 10))\n                (map #(* % %))\n                (reduce +))\n                (conj s n))))))", "user": "53034738e4b0d8b024fd373e"}, {"problem": 86, "code": "(fn happy-num? [n]\n  (letfn [(get-digits [n]\n                      (loop [number n\n                             digits []]\n                        (if (= number 0)      \n                          digits\n                          (recur (int (/ number 10)) (conj digits (mod number 10))))))]\n    (letfn [(next-num [n]\n                      (reduce + (map #(* % %) (get-digits n))))]\n      (loop [curr-num (next-num n)\n             prev-nums #{}]\n        (if (= curr-num 1)\n          true\n          (if (contains? prev-nums curr-num)\n            false\n            (recur (next-num curr-num) (conj prev-nums curr-num))))))))", "user": "53791ab7e4b06839e8705e4d"}, {"problem": 86, "code": "(fn [n]\n  (letfn [(dig [n]\n            (loop [d '() n n]\n              (if (zero? n) d\n                (recur (cons (rem n 10) d) (quot n 10)))))\n          (f [n]\n            (apply + (map (fn [x] (* x x)) (dig n))))]\n    (loop [n n v #{}]\n      (cond\n        (= n 1) true\n        (v n) false\n        :else (recur (f n) (conj v n))))))", "user": "53d78b64e4b0e771c3025466"}, {"problem": 86, "code": "(fn [n]\n  (letfn [(digits [s] (map #(- (int %) (int \\0)) s))\n          (sum-of-squares [col] (reduce + (map #(* % %) col)))\n          (is-happy?\n            ([n] (is-happy? n 10000))\n            ([n threshold]\n               (cond (= threshold 0) false\n                     (= n 1) true\n                     :else (-> n str digits sum-of-squares\n                               (recur (dec threshold))))))]\n    (is-happy? n)))", "user": "53ac4c6fe4b047364c04445d"}, {"problem": 86, "code": "(fn [x] \n  (loop [n x\n         cset #{}]\n    (cond \n     (= 1 n) true\n     (cset n) false\n     :else (recur (->> (str n)\n                       (map #(Integer. (str %)))\n                       (map #(* % %))\n                       (reduce +)) (conj cset n)))))", "user": "5368fedee4b0243289761e93"}, {"problem": 86, "code": "(fn[a](letfn[(mkl[n]\n  (if (zero? (quot n 10))  (list  n)\n    (cons (mod n 10) (mkl (quot n 10)))))\n\n(happynum[n lst]\n  (if (= n 1) true\n    (let [s (mkl n) c (reduce #(+ % (* %2 %2)) 0 s)]\n      (if (some #(= c %) lst) false\n        (happynum c (cons c lst)))\n      )))]\n  (happynum a '())))", "user": "4e8849c5535d8b9bb0147ca4"}, {"problem": 86, "code": "(fn [v]\n  (loop [v v\n         i 0]\n    (if (> i 1000) false\n      (let [l (map #(-> % .toString Integer.) (.toString v))\n            s (apply + (map #(* % %) l))]\n        (if (= s 1) true\n          (recur s (inc i)))))))", "user": "537e745ae4b06839e8705ea6"}, {"problem": 86, "code": "(fn happy-numbers [x]\n  (let [digits (mapv #(Character/getNumericValue %) (str x))\n        squared (mapv #(* %1 %1) digits)\n        sum (reduce + squared)]\n    [sum]\n    (condp = sum\n      1 true\n      4 false\n      (recur sum))))", "user": "532c9dc9e4b019098a6f8b30"}, {"problem": 86, "code": "(fn happy-number? [n]\n  (letfn [(digits [x]\n            (->> (str x)\n                 (seq)\n                 (map (comp read-string str))))\n          (square [x] (* x x))\n          (sum-of-squares [x]\n            (->> (digits x)\n                 (map square)\n                 (reduce +)))]\n    (loop [acc [] n n]\n      (let [next (sum-of-squares n)]\n        (or (= next 1)\n            (and (not-any? #(= n %) acc)\n                 (recur (conj acc n) next)))))))", "user": "53dc94c8e4b094d41abdfefc"}, {"problem": 86, "code": "(fn [i]\n    (letfn [(hn-86 [i visited]\n              (let [digit-seq (map read-string (re-seq #\"[0-9]\" (str i)))\n                    sum-of-squares (reduce + (map #(* % %) digit-seq))]\n                (cond (= sum-of-squares 1) true\n                      (visited sum-of-squares) false\n                      :else (hn-86 sum-of-squares (conj visited sum-of-squares)))))]\n      (hn-86 i #{i})))", "user": "513e8141e4b02b2a3d8235c1"}, {"problem": 86, "code": "(fn [n] (letfn [\n                (digits [n] (map #(- (int %) 48) (str n))) \n                (sos [c] (apply + (map #(* % %) c))) \n                (check [n seen] \n                       (let [r (->> n digits sos)] \n                       (if (= 1 r) \n                         true \n                         (if (seen r) \n                           false \n                           (check r (conj seen r))))))] \n          (check n #{})))", "user": "53b2a7f8e4b047364c04449c"}, {"problem": 86, "code": "(fn [x] (let [to-digits (fn to-digits [x]\n                          (if (< x 10) (list x)\n                         \t(cons (mod x 10) (to-digits (quot x 10)))))]\n        \n         (loop [m #{} n x]\n            (let [sum (reduce + (map #(* % %) (to-digits n)))] \n              (if (= 1 sum) true\n                (if (m sum) false\n                  (recur (conj m sum) sum)))))))", "user": "50856bd1e4b004985b776e4c"}, {"problem": 86, "code": "(fn happy [x]\n  (let [squared-sum (fn [target] (reduce + (map #(* % %) (map #(- (int %) (int \\0)) (-> target str seq)))))]\n    (loop [c x history []]\n      (cond \n       (= 1 c) true\n       (contains? history c) false\n       :else (recur (squared-sum c) (conj history c))))))", "user": "53c649d3e4b00fb29b221297"}, {"problem": 86, "code": "(fn [x] (= 1 (nth (iterate \n   (fn peu [v] \n          (if (< v 10) (* v v) \n                 (+ (peu (quot v 10)) (* (mod v 10) (mod v 10)) )\n          )           \n   ) \nx) 10000)))", "user": "53fc8424e4b0de5c418485b3"}, {"problem": 86, "code": "(fn[x] (let [sum-sq (fn sum-sq [n]\n               (let [b (rem n 10)\n                     x (* b b)]\n                 (if (< n 10)\n                   x\n                   (+' x (sum-sq (quot n 10))))))\n      hppy? (fn\n              ([n l]\n                (let [ss (sum-sq n)]\n                  (if (= ss 1)\n                    true\n                    (if (some #(= ss %) l)\n                      false\n                      (recur ss (conj l n)))))))]\n  (hppy? x '())))", "user": "52bc6cb2e4b07a9af57922f5"}, {"problem": 86, "code": "(fn [x]\n  (letfn [(digits [n]\n            (for [y (iterate (partial * 10) 1) :while (<= y n)]\n              (rem (int (/ n y)) 10)))\n          (sqr-sum [ds]\n            (reduce + (map #(* % %) ds)))]\n    (let [r (some #{1 4} (iterate (comp sqr-sum digits) x))]\n      (cond\n        (= 1 r) true\n        (= 4 r) false))))", "user": "53f75957e4b0de5c4184855d"}, {"problem": 86, "code": "(fn f ([x] (f x #{}))\n   ([x s] (cond (= x 1) true\n                (s x) (do (println x) false)\n                :else (f\n                         (->> x\n                             str\n                             seq\n                             (map str)\n                             (map read-string)\n                             (map #(* % %))\n                             (reduce +)\n                             )\n                          (into s #{x})))))", "user": "53f6d555e4b0db01ade6f9e5"}, {"problem": 86, "code": "(letfn [(digits [n]\n          (map #(Integer/parseInt (str %)) (seq (str n))))\n        (square [n] (* n n))]\n\n  (fn happy?\n    ([x] (happy? x []))\n    ([x seen]\n     (if-not (some (partial = x) seen)\n       (let [v (apply + (map square (digits x)))]\n         (if (= v 1)\n           true\n           (recur (apply + (map square (digits x))) (conj seen x))))\n       false))))", "user": "506ba58be4b0eda3100c090b"}, {"problem": 86, "code": "(fn [x] (let [digits (fn digits \n                        [x] (->> x \n                                 str \n                                 vec \n                                 (map #(str %))\n                                 (map #(Integer/parseInt %))))\n               squares (fn squares [x] (map #(* % %) (digits x)))\n               sum-of-squares (fn sum-of-squares [x] (reduce + (squares x)))\n               initial-value x]\n           (loop [new-sum (sum-of-squares x) \n                  old-numbers #{x}] \n               (cond\n                 (= 1 new-sum) true\n                 (old-numbers new-sum) false\n                 :else (recur (sum-of-squares new-sum) (conj old-numbers new-sum))))))", "user": "53da8fede4b0e771c30254a3"}, {"problem": 86, "code": "(fn happy? [n]\n  (loop [curr n\n         used #{}]\n    (println \"curr\" curr \"used\" used)\n    (cond\n     (= 1 curr) true\n     (contains? used curr) false\n     :else (let [digits \n            (loop [n curr res []]\n              (if (zero? n)\n                res\n                (recur (quot n 10) (conj res (mod n 10)))))\n            sq-digits (map #(* % %) digits)\n            sum-sq (apply + sq-digits)]\n        (recur sum-sq (conj used curr))))))", "user": "53f7820be4b0de5c41848560"}, {"problem": 86, "code": "(fn ! [n]\n    (letfn [(!! [n mem]\n            (if (mem n)\n              false\n              (if (= n 1)\n                true\n                (!! (->> n\n                        (str)\n                        (seq)\n                        (map (memfn toString))\n                        (map #(Integer/parseInt %))\n                        (map #(Math/pow % 2))\n                        (map int)\n                        (apply +)           \n                        ) (conj mem n)))))]\n      (!! n #{})))", "user": "504e1abee4b0f6ff3350c45d"}, {"problem": 86, "code": "(fn h[a & s]\n (if (some #(= a %) s)\n    false\n    (if (= a 1)\n      true\n      (apply h\n       (->> a str seq (map str) (map read-string) (map #(* % %)) (apply +))\n       (cons a s)))))", "user": "53ed2fafe4b0d648e757f4c1"}, {"problem": 86, "code": "(fn [n]\n  (loop [m n soln #{}]\n    (letfn [(partnum [v] (if (< v 10) (vector v) (conj (partnum (quot v 10)) (rem v 10))))]\n      (let [newm (reduce + (map #(* % %) (partnum m)))]\n        (cond\n          (= newm 1) true\n          (contains? soln newm) false\n          :else (recur newm (conj soln newm)))))))", "user": "53e9a15be4b036ad0777e4ae"}, {"problem": 86, "code": "(fn [x]\n   (let  [step (fn  [y]\n                 (->> (str y)\n                      (map #(Integer/parseInt (str %)))\n                      (map #(* % %))\n                      (apply +)))\n          step-seq (iterate step x)\n          first-small (first (filter #(< % 1000) step-seq))\n          thousand (take 1000 (iterate step first-small))]\n     (contains? (set thousand) 1)))", "user": "53ed6976e4b0d648e757f4c4"}, {"problem": 86, "code": "(fn happy? [n] (let [\n    happy (fn [n] \n\t  (->> \n\t    (str n) \n\t\t(map #(- (int %) (int \\0)))\n\t\t(map  #(* % %))\n\t\t(apply +)\n\t  ))\n  ]\n  (cond \n    (= 1 n) true\n    (= 4 n) false\n    :else (recur (happy n)))))", "user": "53fe1c3be4b0de5c418485f2"}, {"problem": 86, "code": "(fn x [n] \n  (loop [c 1 num n]\n    (cond \n      (= 1 num) true\n      (> c 100) false\n      :else \n       (->> num\n       (str)\n       (seq)\n       (map #(Integer/parseInt (str %)))    \n       (map #(* % %))\n       (apply +)\n       (recur (inc c))))))", "user": "51aefceee4b09397d5109797"}, {"problem": 86, "code": "(letfn [(num->digits [num]\n          (loop [n num res []]\n            (if (zero? n)\n              res\n              (recur (long (/ n 10)) (cons (mod n 10) res)))))\n        (change [n]\n          (apply + (map #(* % %) (num->digits n))))]\n  (fn [init]\n    (loop [curr init results #{}]\n      (println curr \" - \" results)\n      (cond\n       (= 1 curr) true\n       (results curr) false\n       :else (let [new-n (change curr)]\n               (println curr new-n)\n               (recur new-n (into results [curr])))\n       )))\n  )", "user": "53be3ee7e4b0d9a98559a6df"}, {"problem": 86, "code": "#(if (< % 10) (if (> % 5) true false) true)", "user": "53e76bb2e4b036ad0777e47d"}, {"problem": 86, "code": "(fn [i]\n      ((fn [i acc] (cond\n                  (= i 1) true\n                  (contains? acc i) false\n                  :else (recur\n                          (apply + (map #(* % %) ((fn digits [n r]\n                                                    (if (< n r) [n]\n                                                      (cons (mod n r) (lazy-seq (digits (long (/ n r)) r))))) i 10)))\n                          (conj acc i))))\n        i #{}))", "user": "51e28063e4b08e53a149f0f2"}, {"problem": 86, "code": "(fn [y] (loop [n y s #{}]\n          (cond\n           (= n 1) true\n           (s n) false\n           :else (recur ((fn [x] (reduce + (map #(* % %) (map #(Integer. %) (rest (clojure.string/split (str x) #\"\")))))) n) (conj s n)))))", "user": "52474133e4b05ef8e38e635e"}, {"problem": 86, "code": "(fn [y]\n  (loop [n y s #{}]\n    (let [split-it (fn [x] (reduce + (map #(* % %) (map #(Integer. %) (rest (clojure.string/split (str x) #\"\"))))))]\n      (cond\n        (= n 1) true\n        (s n) false\n        :else (recur (split-it n) (conj s n))))))", "user": "540fa71de4b01498b1a71999"}, {"problem": 86, "code": "(fn [N]\n  (let [digits (fn [n] (map #(Integer/parseInt (str %)) (str n)))\n        sum-of-squares (fn [xs] (reduce + 0 (map #(* % %) xs)))\n        transform (fn [n] (sum-of-squares (digits n)))]\n    (loop [i N \n           seen #{}]\n      (cond\n       (seen i) false\n       (= i 1) true\n       :else (recur (transform i) (conj seen i))))))", "user": "504e108ce4b078edc5f593b3"}, {"problem": 86, "code": "(fn [n]\n  (let [digits (fn [n] (map #(Integer/parseInt (str %)) (str n)))\n        happyfy (fn [n] (apply + (map #(* % %) (digits n))))]\n    (loop [[x & xs] (iterate happyfy n)\n           acc #{}]\n      (cond\n       (= x 1) true\n       (contains? acc x) false\n       :else (recur xs (conj acc x))))))", "user": "4f3d83b5e4b0e243712b1f69"}, {"problem": 86, "code": "(fn [n]\n  (letfn [(to-digit [d]\n            (map #(->> % str read-string) (seq (str d))))]\n    (loop [unhappy #{}\n           my-n n]\n      (if (= 1 my-n)\n        true\n        (let [nn (reduce + (map #(* % %) (to-digit my-n)))]\n          (if (contains? unhappy nn)\n            false\n            (recur (conj unhappy nn) nn)))))))", "user": "540d7dd1e4b0addc1aec6713"}, {"problem": 86, "code": "(fn happy-number? [number]\n  (loop [n number seen #{}]\n    (cond\n      (= n 1) true\n      (contains? seen n) false\n      :else\n        (let [digits (map #(Character/getNumericValue %) (str n))]\n          (recur\n            (reduce + (map #(* % %) digits))\n            (conj seen n))))))", "user": "528bba38e4b0239c8a67aea9"}, {"problem": 86, "code": "(fn [n]\n  (let [happy-sum (fn [n]\n                    (reduce #(+ % (* %2 %2)) 0 (map #(- (int %) 48) (seq (str n)))))]\n    (loop [n n path []]\n      (if (= n 1)\n        true\n        (if (contains? path n)\n          false\n          (recur (happy-sum n) (conj path n)))))))", "user": "53d86564e4b0e771c302546b"}, {"problem": 86, "code": "(fn happy?\n  [n]\n  (loop [n n seen #{}]\n    (cond \n      (= n 1) true\n      (seen n) false\n      :else\n      (recur\n        (->> (str n)\n             (map #(Character/digit % 10))\n             (map #(* % %))\n             (reduce +)) \n        (conj seen n)))))", "user": "5401aefbe4b0df28a13c62c7"}, {"problem": 86, "code": "(fn [n]\n  (= 1\n     (last (first\n       (drop-while\n         (fn [x] (= x (distinct x)))\n         (iterate\n           (fn [x] (conj x (->> (str (last x)) (map #(- (int %) (int \\0))) (map #(* % %)) (apply +))))\n           [n]))))))", "user": "53e4fa2ce4b036ad0777e454"}, {"problem": 86, "code": "(fn [w] (let [z (take 150 (iterate (fn [x] ((comp \n       \t           \t   (partial reduce +) \n        \t            \t (partial map (comp \n            \t            \t            #(* % %) \n                \t            \t        read-string \n                    \t            \t    str)) \n\t                    \t (partial into '()) str)  \n\t    \t           x)) w))]\n          (if (and (< (count (set z)) (count z)) (=(count (filter (partial = 1) z)) 0)) false true)\n          ))", "user": "540479e7e4b0addc1aec665a"}, {"problem": 86, "code": "(fn [n]\n  (letfn [(happificate [k] (->> (str k)\n                                (seq)\n                                (map str)\n                                (map read-string)\n                                (map #(* % %))\n                                (apply +)))]\n    (loop [xs [], n n]\n      (cond (= n 1) true,\n            (contains? xs n) false,\n            :else (recur (conj xs n) (happificate n))))))", "user": "53fcdd1ae4b0de5c418485dd"}, {"problem": 86, "code": "(fn [n]\n   (loop [n n, hist '()]\n     (cond (= n 1) true\n           (some #(= n %) hist) false\n           :else (recur ((fn [n]\n                           (reduce #(+ %1 (* (- (int %2) (int \\0)) (- (int %2) (int \\0)))) 0 (seq (str n)))) n)\n                        (cons n hist)))))", "user": "52fac708e4b047fd55836fff"}, {"problem": 86, "code": "(fn [n]\n  (letfn [(sum-squared [a] (apply + (map #(int(Math/pow (Character/digit % 10) 2)) (str a))))]\n    (loop [x (sum-squared n)]\n      (cond \n       (= \"2\" (clojure.string/replace (str x) #\"0\" \"\")) false\n       (= x 1) true\n       :default (recur (sum-squared x))))))", "user": "5042bb9ae4b034ff00315d16"}, {"problem": 86, "code": "(fn allit \n  ([in] (allit in 1))\n  ([in acc]\n  (let [oneit (fn oneit [x] \n                (int (apply + (map #(Math/pow (Integer. %) 2) (rest (clojure.string/split (str x) #\"\"))))))]\n   (if (> acc 1000)\n     false\n     (if (= 1 (oneit in))\n       true\n       (allit (oneit in) (inc acc)))))))", "user": "52747090e4b03e8d9a4a74a5"}, {"problem": 86, "code": "(fn [x]\n  (let [digits\n        (fn [rs n]\n          (if (< n 10) (cons n rs)\n              (recur (cons (rem n 10) rs) (quot n 10))))]\n    (loop [n x seen #{}]\n      (let [sm (apply + (map #(* %1 %1) (digits [] n)))]\n        ;(prn n sm)\n        (cond\n         (= 1 sm) true\n         (contains? seen sm) false\n         :else (recur sm (conj seen sm)))))\n    )\n  )", "user": "53ef7f77e4b0742d9025b0ce"}, {"problem": 86, "code": "(fn happy [n]\n  (letfn [(sum-squares [x]\n                      (let [digits (map #(- % 48) (map int (str x)))\n                            squared-digits (map #(* %1 %1) digits)\n                            sum-squares (reduce + squared-digits)]\n                        sum-squares)\n                      )\n          ]\n    (apply distinct? (take-while #(not= 1 %) (iterate sum-squares n)))\n    )\n  )", "user": "5394bb65e4b0b51d73faaece"}, {"problem": 86, "code": "(fn [in]\n    (let [tointsq #(* (Integer. (str %))\n                      (Integer. (str %)))\n          happy? #(= 1\n                     (reduce +\n                             (map tointsq\n                                  (str %))))\n          visited (atom {})]\n      (loop [n in]\n        (if (happy? n)\n          true\n          (if (contains? @visited\n                         n)\n            false\n            (do\n              (swap! visited conj [n :q])\n              (recur (reduce +\n                             (map tointsq\n                                  (str n))))))))))", "user": "50981062e4b04e098a4c7268"}, {"problem": 86, "code": "(fn happy-num? [n]\n   (let [num-em-digitos (fn divide [a]\n                  (when (not (zero? a)) \n                    (cons (rem a 10) (divide (quot a 10)))))\n         happy-once (fn [x]  (apply + (map #(* % %) (num-em-digitos x))) )]\n     \n     (loop [seen [] \n            n n]\n       (cond \n        (= 1 n)          true\n        (< (count (set seen)) (count seen)) false\n        :else            (recur (conj seen n) (happy-once n)))\n       )\n     ))", "user": "4ff4bed0e4b0678c553fc35f"}, {"problem": 86, "code": "#(loop[n % mem #{}]\n   (if (= n 1) true\n    (let [digits (map (fn[c] (- (int c) 48)) (str n)) \n          s-sum (reduce (fn[x y] (+ x (* y y))) 0 digits)]\n      (if (contains? mem s-sum) false\n        (recur s-sum (conj mem s-sum))))))", "user": "541619e8e4b01498b1a719f9"}, {"problem": 86, "code": "(fn [n]\n  (let [squares (map #(* % %) (range 10))\n        f (fn [n]\n            (->> n\n                 (str)\n                 (map int)\n                 (map #(- % (int \\0)))\n                 (map (partial nth squares))\n                 (reduce +)))]\n    (loop [x (f n)\n           s [n]]\n      (cond (= x 1) true\n            (some #(= % x) s) false\n            true (recur (f x)\n                        (conj s x))))))", "user": "53fb5256e4b0de5c4184857f"}, {"problem": 86, "code": "(fn f ([n] (f #{} n))\n   ([acc n] (cond (= n 1) true\n                  (acc n) false\n                  :else (recur (conj acc n)\n                         (apply + (map #(let [n (Character/getNumericValue %)] (* n n)) (seq (str n))))))))", "user": "5310e968e4b08068f379ecdd"}, {"problem": 86, "code": "(fn [x]\n(letfn [(numToDigit [y]\n                    (map #(- (int %) (int \\0)) (str y)))\n        (addAll [z]\n                (apply + (map #(* % %) (numToDigit z))))]\n  (loop [curr x result #{}]\n    (cond\n      (= curr 1) true\n      (result curr) false\n      :else\n      (recur (addAll curr) (conj result curr))))))", "user": "52c672e2e4b0c2d177d6210e"}, {"problem": 86, "code": "(fn [n]\n  (cond\n   (zero? n) false\n   (= n 1) true\n   (and (>= n 2)\n        (<= n 5)) false\n   :else (recur (->> n\n                     str\n                     (map #(- (int %) (int \\0)))\n                     (map #(* % %))\n                     (apply +)\n                     ))))", "user": "54246fcce4b01498b1a71aed"}, {"problem": 86, "code": "#(= 1\n    (nth (iterate\n          (fn [n] (apply + (map (zipmap \"0123456789\" (map * (range)(range))) (str n))))\n          %)\n         9))", "user": "53a01fb1e4b0ca733b9744a6"}, {"problem": 86, "code": "(fn mm [n]\n  (not= nil (some #(= 1 %) (take 10\n                    (iterate (fn [x]\n                               (loop [sum 0\n                                      t x]\n                                 (if (= 0 t)\n                                   sum\n                                   (let [mod-x (int (mod t 10))\n                                         sub-x (int (/ t 10))]\n                                     (recur (+ sum (* mod-x mod-x)) sub-x))))) n)))))", "user": "535f0cbde4b04ce2eb3ed2d9"}, {"problem": 86, "code": "(fn [n]\n  (let [step (fn [x] (let [square (fn [x] (* x x))\n                           convert (fn [x] (- (int x) (int \\0)))]\n                       (reduce + (map #(square (convert %)) (str x)))))]\n    ((fn f [x s]\n       (cond (= (step x) 1) true\n             (= (count s) (count (conj s (step x)))) false\n             :else (f (step x) (conj s (step x)))))\n     n #{n})))", "user": "51ab70c3e4b04e3dc0c27b33"}, {"problem": 86, "code": "(fn ___\n    ([n] (___ n {}))\n    ([n seen] \n       (letfn [\n               (digits [n]   (if (> n 0) (cons (rem n 10) (digits (quot n 10))))),\n               (sum-of-squares-of-digits [n]\n                 (reduce + (map #(* % %) (digits n)))\n                 )]\n         (let [x (sum-of-squares-of-digits n)]\n           (if (= x 1)\n             true\n             (if (seen x)\n               false\n               (recur (sum-of-squares-of-digits x) (conj {x :true} seen))\n               ))))))", "user": "5433a07be4b0b6b47310fce0"}, {"problem": 86, "code": "(fn happy-numbers \n  ([n] (happy-numbers n #{n}))\n  ([n prev] \n    (letfn [(squared-sum [i] (->> \n                               (map #(Integer/parseInt (str %)) (str i))\n                               (map #(* % %))\n                               (reduce +)))]\n      (let [s (squared-sum n)]\n      (if (= s 1) true\n        (if (contains? prev s) false\n          (recur s (conj prev s))))))))", "user": "52ee0de4e4b05e3f0be25ec1"}, {"problem": 86, "code": "(fn [n]\n         (let [f (memoize (comp (partial reduce +)\n                          (partial map #(* % %)) (partial map #(- (int %) 48))\n                          str))\n               FOREVER 1000]\n           (= 1 (nth (iterate f n) FOREVER))))", "user": "53f592b7e4b0db01ade6f9d0"}, {"problem": 86, "code": "(fn [n]\n  (let [get-seq (fn [a] (map #(Integer/parseInt (str %)) (seq (str a))))\n        get-sum (fn [b] (reduce + (map #(* % %) b)))]\n  \t(loop [s (get-seq n)\n    \t   seen #{}]\n       (let [sum (get-sum s)]\n       \t(cond \n         (= 1 sum) true\n         (seen sum) false\n      \t :else (recur (get-seq sum) (conj seen sum)))))))", "user": "542c22bde4b0dad94371f29e"}, {"problem": 86, "code": "(fn happy-numbers [x]\n  (let [summed-square-digits (fn [y]\n                               (->> (re-seq  #\"\\d\" (str y))\n                                    (map #(Integer/parseInt %))\n                                    (map #(* % %))\n                                    (reduce +)))\n        result (nth (iterate summed-square-digits x) 10)]\n    (if (= 1 result)\n        true\n        false)))", "user": "52616198e4b03e8d9a4a705e"}, {"problem": 86, "code": "(fn happy? [n]\n  (let [square #(* % %)\n        digits (fn [s] (map #(- (int %) (int \\0)) (str s)))\n        sum-sq-digits #(apply + (map square (digits %)))]\n  (loop [a n seen #{}]\n    (if (seen a)\n      false\n      (if (= (sum-sq-digits a) 1)\n        true\n        (recur (sum-sq-digits a) (conj seen a)))))))", "user": "54448e84e4b032a45b869393"}, {"problem": 86, "code": "(fn f [x]\n  (let [dgs (fn [n] (map #(Integer/valueOf (str %)) (str n)))\n      \tsum-sdgs (fn [n] (reduce + (map #(* % %) n)))\n        s (sum-sdgs (dgs x))]\n    (cond (= s 1) true \n          (= s 4) false\n          :else (f s))))", "user": "543d5c61e4b032a45b86934d"}, {"problem": 86, "code": "(fn [x]\n  (let [digits (fn [num] (map #(- (int %) 48) (str num)))\n        sqsum  (fn [y]   (apply + (map #(* % %) (digits y))))]\n    (loop [x x\n           s [(sqsum x)]]\n      (cond \n       (= 1 (last s))           true\n       (not (apply distinct? s)) false\n       :else (recur x (conj s (sqsum (last s))))))))", "user": "532a033be4b09d4e7a9b551f"}, {"problem": 86, "code": "(fn [x]\n  (loop [acc #{}\n         x x]\n    (let [y (->> (map (comp read-string str) (str x))\n                 (map #(* % %))\n                 (apply +))]\n      (cond (= y 1) true\n            (acc y) false\n            :else (recur (conj acc y) y)))))", "user": "50742549e4b054001656accf"}, {"problem": 86, "code": "(fn __ [n] \n  (let [x (reduce + \n              (map #(* % %) \n                   (map #(Character/getNumericValue %) (str n))))]\n  (condp = x \n   1 true\n   16 false\n   (__ x))))", "user": "53f3a4ace4b0742d9025b0f7"}, {"problem": 86, "code": "(fn [n]\n  (let [digit-sum (fn [d]\n                    (->> d\n                         (str)\n                         (map #(- (int %) 48))\n                         (map #(* % %))\n                         (apply +)))]\n\t(loop [saw #{} curr n]\n      (cond (= 1 curr) true\n            (saw curr) false\n            :else (let [next (digit-sum curr)]\n                    (recur (conj saw curr) next))))))", "user": "51baff1be4b0fe3ecfb46443"}, {"problem": 86, "code": "(fn [n]\n  (let [next-step (fn [n]\n                    (let [digits (map #(Integer/valueOf (str %)) (str n))]\n                      (apply + (map #(* % %) digits))))]\n    (loop [i n]\n      (case i\n        1 true\n        4 false\n        (recur (next-step i))))))", "user": "53f891eee4b0de5c4184856d"}, {"problem": 86, "code": "(fn [num]\n      (loop [n num vals #{}]\n            (let [hn? (->> (str n)\n                           (map #(Character/getNumericValue %))\n                           (map #(* % %))\n                           (apply +)\n                           )]\n                 (cond\n                   (contains? vals hn?) false\n                   (== 1 hn?) true\n                   :else (recur hn? (conj vals hn?))))))", "user": "525ed5f4e4b0cb4875a45db8"}, {"problem": 86, "code": "(fn [x] \n  (letfn [\n    (sq [x] (* x x))           \n    (sq-sum [x] (apply + (map #(sq (- (int %) (int \\0)))  (str x)))) ]\n  (loop [s #{} n x]\n    (cond \n     (= 1 n) true\n     (s n) false\n     :else (recur (conj s n) (sq-sum n))\n     )\n    )))", "user": "533ea7e8e4b085b17e897d94"}, {"problem": 86, "code": "(fn [x]\n  (letfn [(digits [x]\n            (mapv #(-> % str Integer.)\n                  (print-str (str x))))\n          (tic [x]\n            (reduce +\n                    (map #(* % %)\n                         (digits x))))\n          (get-seq [x]\n            (take-while #(not= 1 %)\n                        (iterate tic x)))\n          (no-dupes? [xs]\n            (loop [seen #{}\n                   xs xs]\n              (if (empty? xs)\n                true\n                (if (contains? seen (first xs))\n                  false\n                  (recur (conj seen (first xs)) (rest xs))))))]\n    (no-dupes? (get-seq x))))", "user": "4ec1b090535dfed6da9c6db5"}, {"problem": 86, "code": "; Porges, A. \"A Set of Eight Numbers.\"\n(fn [n]\n  (letfn [(seq-n [k] (cons 0 (map #(Integer/parseInt (str %)) (str k))))\n          (compute-n [s] (reduce #(+ %1 (* %2 %2)) s))\n          (happy-seq [m] (cons m (lazy-seq (happy-seq (compute-n (seq-n m))))))]\n    (= 1 (compute-n (seq-n (first (drop-while #(not (contains? #{0 1 4 16 20 37 42 58 89 145} %)) (happy-seq n))))))))", "user": "53ce4cd4e4b00fb29b2212ef"}, {"problem": 86, "code": "(fn [n] \n  (loop [n n s #{}]\n    (cond (s n) false \n          (= n 1) true \n          :else (recur (apply + (map #(* % %)\n                                     (map #(- (int %) (int \\0)) \n                                          (seq (str n))))) \n                       (conj s n)))))", "user": "5457e5f1e4b01be26fd74613"}, {"problem": 86, "code": "(fn is-happy\n   [n]\n   (loop [n n\n         seen #{}]\n    (let [ssq (apply + (map #(* % %) (map #(Integer/parseInt (str %)) (str n))))]\n      (cond (= ssq 1) true\n            (contains? seen ssq) false\n            :else (recur ssq (conj seen ssq))))))", "user": "545e9cf1e4b01be26fd7467f"}, {"problem": 86, "code": "(fn [m]\n  (loop [n m, i 0]\n    (if (= i 100000) \n      false\n      (let [x (reduce + (map #(* % %) (map #(- (int %) 48) (str n))))]\n        (if (= x 1) true (recur x (inc i))) \n      )\n    )\n))", "user": "54524afbe4b0e397800069bc"}, {"problem": 86, "code": "(fn [n]\n  (letfn [(step [n]\n            (->> (str n)\n                 (map (comp #(* % %) read-string str))\n                 (apply +)))]\n    (loop [seen #{}\n           num n]\n      (cond\n       (= num 1) true\n       (contains? seen num) false\n       :else (recur (conj seen num) (step num))))))", "user": "505aa653e4b021387fb89857"}, {"problem": 86, "code": "(fn [n]\n  (loop [cur n\n         i 0]\n    (let [digits (map #(Character/digit % 10) (str cur))\n          ss (->> (map #(* % %) digits)\n                  (reduce +))]\n      (cond (= ss 1) true\n            (= i 100) false\n            :else (recur ss (+ i 1))))))", "user": "502873a8e4b01614d1633ff8"}, {"problem": 86, "code": "(fn [o]\n  (loop [n o seen []]\n    (let [digits (loop [m n ds []]\n                   (if\n                     (= 0 m) ds\n                     (recur (quot m 10) (cons (mod m 10) ds))))\n          newnum (reduce + (map #(* % %) digits))]\n      (cond\n        (= newnum 1) true\n        (contains? seen newnum) false\n        :else (recur newnum (conj seen newnum))))))", "user": "53bd7080e4b0d9a98559a6d1"}, {"problem": 86, "code": "(fn [x]\n    (letfn [(split-digits [x]\n                          (map #(let [a (Integer/parseInt (str %))]\n                                 (* a a)) (str x)))\n            (sum-squares [x]\n                         (apply + (split-digits x)))]\n    (loop [seen #{} i x]\n      (if (seen i)\n        false\n        (if (= 1 i)\n          true\n          (recur (conj seen i) (sum-squares i)))))))", "user": "537bde5de4b06839e8705e73"}, {"problem": 86, "code": "(fn [n]\n  ;; I would normally defn these\n  (let [int->digits (fn [n] (map #(Integer/parseInt (str %)) (str n)))\n        square      (fn [n] (* n n))\n        next-attempt (fn [n] (reduce + (map square (int->digits n))))]\n    (loop [new (next-attempt n)\n           terminate-after 1000]\n      (cond\n        (= 1 new) true\n        (zero? terminate-after) false\n        :else (recur (next-attempt new) (dec terminate-after))))))", "user": "51d46747e4b013d740b70de3"}, {"problem": 86, "code": "(fn [x]\n  (loop [done #{}\n         x x]\n    (cond\n     (= x 1) true\n     (contains? done x) false\n     :else (recur (conj done x) (apply + (map (fn [d] (#(* % %) (- (int d) 48))) (str x)))))))", "user": "5136f659e4b04059df19f2fd"}, {"problem": 86, "code": "#(if (or (= % 2) (= % 3))\n   false\n   true)", "user": "5412646de4b01498b1a719d4"}, {"problem": 86, "code": "(fn [n]\n  (loop [cur-n n i 0]\n    (if (< i 1000) \n      (let [new (reduce + (map #(* % %) (for [digit (str cur-n)]\n                                               (read-string (str digit)))))]\n             (if (= new 1) \n               true\n               (recur new (inc i)))) false)))", "user": "5405ae2be4b0addc1aec6671"}, {"problem": 86, "code": "(fn happy-number? [ d ]\n    (letfn [(square-digits [ d ]\n              (->> (str d)\n                   (map #(- (int %) (int \\0)))\n                   (map #(* % %))\n                   (reduce +)))]\n      (loop [curr d]\n        (cond (= curr 1) true\n              (= curr 4) false\n              :else (recur (square-digits curr))))))", "user": "536e5055e4b0fc7073fd6e6b"}, {"problem": 86, "code": "(fn happy-num? [n]\n  (let [n->digits (fn [x] (map #(- (int %) 48) (str x)))\n        digits->happy (fn [digits] (apply + (map #(* % %) digits)))]\n    (loop [current n\n           seen #{}]\n      (if (contains? seen current)\n        false\n        (let [digits (n->digits current)\n              happy (digits->happy digits)]\n          (if (= 1 happy)\n            true\n            (recur happy (conj seen current))))))))", "user": "5478c4fee4b0c51c1f4d72c0"}, {"problem": 86, "code": "(let [digits (fn [i]\n               (loop [d '() q i]\n                 (if (= 0 q)\n                   d\n                   (recur (cons (mod q 10) d) (quot q 10)))))\n      step (fn [i]\n             (let [d (digits i)\n                   sq (map #(* % %) d)]\n               (reduce + sq)))]\n  (fn [i0]\n    (loop [i (step i0) past #{i0}]\n      (if (= i 1)\n        true\n        (if (past i)\n          false\n          (recur (step i) (conj past i)))))))", "user": "547d8e93e4b0c51c1f4d72f4"}, {"problem": 86, "code": "(fn happy\r\n  ([n] (happy n []))\r\n  ([n s]\r\n    (letfn [(digits [n]\r\n              (map #(Integer. (str %)) (str n)))]\r\n      (if (empty? (filter #(= n %) s))\r\n        (if (= n 1 )\r\n          true\r\n          (happy \r\n            (reduce + (map  #(* % %) (digits n)))\r\n            (cons n s)))\r\n        false))))", "user": "5470699ae4b00cfc9eacc1b6"}, {"problem": 86, "code": "(letfn [(step [n]\n              (if (zero? n)\n                0\n                (+ (* (rem n 10) (rem n 10)) (step (quot n 10)))))]\n  (fn f    \n    ([k] (f #{} k))\n    ([s k] (let [x (step k)]\n             (cond\n              (= 1 x) true\n              (s x) false\n              :else (f (conj s x) x))))))", "user": "5478e57de4b0c51c1f4d72c1"}, {"problem": 86, "code": "(fn happy? [number]\n  (letfn [(char->num [char] (- (int char) 48))\n          (square [num] (* num num))\n          (sum [num] (apply + (map #(square (char->num %)) (str num))))\n          (find-happy [x visited] (let [val (sum x)]\n                             (if (= val 1)\n                               true\n                               (if (visited val)\n                                 false\n                                 (recur val (conj visited val))))))]\n    (find-happy number #{})))", "user": "541f5b37e4b01498b1a71a97"}, {"problem": 86, "code": "#(condp = %\n   7 true 986543210 true 2 false 3 false)", "user": "53572176e4b04ce2eb3ed276"}, {"problem": 86, "code": "(fn [n]\n  (letfn [(digits [n]\n                  (if (< n 10)\n                    [n]\n                    (conj (digits (quot n 10)) (rem n 10))))\n          (sum-squared [v]\n                       (apply + (map * v v)))\n          (happy* [n tried]\n                  (let [n' (sum-squared (digits n))]\n                    (println n')\n                    (if (tried n')\n                      false\n                      (if (= 1 n')\n                        true\n                        (recur n' (conj tried n))))))]\n    (happy* n #{})))", "user": "5353afa0e4b084c2834f4b03"}, {"problem": 86, "code": "(fn happy? [n]\n  (loop [n n, seen #{}]\n    (cond\n      (= n 1) true\n      (seen n) false\n      :default (recur (->> (str n)\n                        (map #(Character/digit % 10))\n                        (map #(* % %))\n                        (reduce +))\n                      (conj seen n)))))", "user": "4e6a2f93535d8ccf87e9feaa"}, {"problem": 86, "code": "(fn happy? [n]\n  (letfn [(intlist [x]\n            ((fn [acc n]\n               (if (zero? n)\n                 acc\n                 (recur (cons (mod n 10) acc) (int (/ n 10))))) '() x))]\n    (loop [x n\n           prev #{}]\n      (cond\n        (contains? prev x) false\n        (= x 1) true\n        :else (recur (apply + (map #(* % %) (intlist x))) (conj prev x))))))", "user": "540e8d13e4b0addc1aec671e"}, {"problem": 86, "code": "(fn happy?\n  ([n] (happy? n #{}))\n  ([n hist]\n     (letfn [(morph [i]\n               (->> (str i)\n                    (seq)\n                    (map #(- (int %) (int \\0)))\n                    (map #(* % %))\n                    (reduce +)))]\n       (cond\n        (= n 1) true\n        (hist n) false\n        :else (happy? (morph n) (conj hist n))))))", "user": "547584d9e4b0c51c1f4d729b"}, {"problem": 86, "code": "(fn [n]\n  (letfn [(sq [x] (* x x))\n          (sq-d [s] (apply + (map #(sq (read-string (str %))) (str s))))\n          (h? [n c] (cond (> c 100) false\n                              (= n 1) true\n                              :else (h? (sq-d n) (inc c))))]\n    (h? n 0)))", "user": "4e41a04e535dc968683fc49e"}, {"problem": 86, "code": "(fn happy-number? [x]\n  (let [unhappy-numbers #{4 16 37 58 89 145 42 20}]\n    (letfn [(to-list [x]\n              (letfn [(rec [x]\n                        (if (= x 0)\n                          ()\n                          (cons (mod x 10) (rec (/ (- x (mod x 10)) 10)))))]\n                (reverse (rec x))))\n            (happy-next [x] (reduce + (map #(* % %) (to-list x))))\n            (one? [x] (= x 1))\n            (or-fn [f & rest]\n              (if (empty? rest)\n                (fn [x] (f x))\n                (fn [x] (or (f x) ((apply or-fn rest) x)))))]\n      (true? (some (or-fn unhappy-numbers one?)\n                   (iterate happy-next x))))))", "user": "546c1f73e4b00cfc9eacc175"}, {"problem": 86, "code": "(fn happy [n]\n  (let [square #(* % %)\n        digits (fn [i]\n                 (loop [acc nil r i]\n                   (let [qr (quot r 10)]\n                     (if (= 0 qr)\n                       (cons (rem r 10) acc)\n                       (recur (cons (rem r 10) acc) qr)\n                       ))))\n        ]\n    (loop [seen #{} i n]\n      (cond (= i 1)\n            true\n            (seen i)\n            false\n            :else\n            (recur (conj seen i)\n                   (apply + (map square (digits i))))\n        )\n      )\n    )\n  )", "user": "5488872ee4b0e286459a11d3"}, {"problem": 86, "code": "(fn [n]\n    \n    (loop [a n\n           used #{}]\n      (if (= 1 a) true\n        (if (contains? used a) false\n          (let [explode (fn [x] (map #(Character/digit % 10) (str x)))\n                square (fn [x] (* x x))\n                b (apply + (map square (explode a)))\n                ]\n            (recur b (conj used a))))))\n            \n            )", "user": "54903056e4b0b312c081ff2e"}, {"problem": 86, "code": "(fn happy\n  ([n] (happy n 0))\n  ([n step]\n   (letfn [(get-digits [n]\n                       (map read-string (map str (-> n str vec))))\n           (sum-squared [digits]\n                        (apply + (map #(* % %) digits)))]\n     (let [new-num (sum-squared (get-digits n))]\n       (if (> step 1000)\n         false \n         (if (= new-num 1)\n           true\n           (happy new-num (inc step))))))))", "user": "544cf5d7e4b0e39780006977"}, {"problem": 86, "code": "(fn [x]\n  (loop [p #{} n x]\n    (if (contains? p n)\n      (= 1 n)\n      (recur (conj p n)\n             (int (reduce\n                   #(-> (Character/getNumericValue %2) (Math/pow 2) (+ %))\n                   0 (str n)))))))", "user": "4f0c4518535d0136e6c2230b"}, {"problem": 86, "code": "(fn hn? [nn]\n  (let [step (fn [n] (->> n\n                          str\n                          (map #(- (int %) (int \\0)))\n                          (map #(* % %))\n                          (apply +)))]\n    (loop [i nn done #{}]\n      (let [i2 (step i)]\n        (cond (= 1 i2) true\n              (done i2) false\n              :else (recur i2 (conj done i2)))))))", "user": "53e745a1e4b036ad0777e479"}, {"problem": 86, "code": "(fn [n]\n  (letfn [(digits [n] (loop [acc () n n] (if (< n 10) (conj acc n) (recur (conj acc (mod n 10)) (quot n 10)))))\n          (square-sum [xs] (->> xs (map #(* % %)) (reduce +)))]                 \n    (loop [n n coll #{}]\n      (let [ss (square-sum (digits n))]\n        (cond\n         (= ss 1) true\n         (contains? coll ss) false\n         :else (recur ss (conj coll ss)))))))", "user": "5392bfdee4b0b51d73faaeb2"}, {"problem": 86, "code": "(fn [n]\n      (loop [c n, st []]\n            (let [d (map #(Integer/parseInt (str %)) (seq (str c))), sq (map #(* % %) d), summ (reduce + sq)]\n                 (if (or (= summ 1) (.contains st summ) ) (= summ 1) (recur summ (conj st c) ) )\n               )\n            )\n      )", "user": "53bcdd41e4b0d9a98559a6c0"}, {"problem": 86, "code": "(fn happy-numbers [n]\n  (cond\n    (= 2 n) false\n    (= 3 n) false\n    :else (letfn [(split-numbers [x]\n                    (map #(Integer/valueOf (str %)) (str x)))]\n            (let [sum (apply + (map #(* % %) (split-numbers n)))]\n              (if (= 1 sum)\n                true\n                (happy-numbers sum))\n              )\n            )\n    )\n  )", "user": "549c8bbde4b0f3d1d8e70f8c"}, {"problem": 86, "code": "(fn [i] ({1 true 4 false} (some #(when (#{4 1} %) %) (iterate (fn [d] (->> d (str) (map str) (map read-string) (map #(* % %)) (apply +))) i ))))", "user": "512b07f7e4b078b06821febb"}, {"problem": 86, "code": "(fn [n]\n  (letfn [(get-digits [n]\n                      (->> (str n)\n                           (map str)\n                           (map read-string)))]\n    (loop [past [n]]\n      (let [new (->> (get-digits (last past))\n                     (map #(* % %))\n                     (apply +))]\n        (cond \n       \t\t(= new 1) true\n       \t\t((set past) new) false\n       \t\t:else (recur (conj past new)))))))", "user": "54848141e4b0e286459a119e"}, {"problem": 86, "code": "(fn happy? \n  ([n] (happy? n [])) \n  ([n prevs] \n   (let [digits #(map read-string (re-seq #\"\\d\" (str %)))\n         sum-digit-squares (fn [x] (apply + (map #(* % %) (digits x))))\n         s (sum-digit-squares n)] \n     (and (not-any? #{s} prevs) (or (= 1 s) (recur s (conj prevs s)))))))", "user": "549c3e0ce4b0f3d1d8e70f87"}, {"problem": 86, "code": "#(letfn [\n        (square [coll]\n        \"sum the squares of all elements in the collection\" \n          (reduce + (for[x coll](* x x)))\n        )\n\n        (num-to-coll[N]\n        \"transform n into a collection of digits\"\n          (loop [n N c ()]\n            (if (= n 0)\n              c\n              (recur (int (/ n 10)) (conj c (mod n 10)))\n            )\n          )\n        )\n\n        (happy? [N]\n        \"for every unhappy number the process ends in the circle 4 16 ... For the happy ones it terminates with 1\"  \n          (loop [n N]\n            (if (= n 1)\n              true\n              (if (contains? #{4, 16, 37, 58, 89, 145, 42, 20} n)\n                false\n                (recur (square (num-to-coll n)))\n              )\n            )\n          )\n        )\n       ]\n\n\n    (happy? %)\n  )", "user": "545537c1e4b0e397800069dd"}, {"problem": 86, "code": "(fn f [n]\n  (letfn [(go [n s]\n            (or (= n 1)\n                (when-not (s n)\n                  (go (reduce +\n                              (for [i (iterate #(int (/ % 10)) n)\n                                    :while (pos? i)\n                                    :let [d (mod i 10)]]\n                                (* d d)))\n                      (conj s n)))))]\n    (boolean (go n #{}))))", "user": "50ef4e2be4b0a78662fa2653"}, {"problem": 86, "code": "(fn [num]\n   (letfn [(square [e]\n             (* e e))\n\n           (seq-from-str [s]\n             (map #(Integer/parseInt (str %)) (str s)))\n\n           (is-happy? [n]\n             (let [s (seq-from-str n)\n                   result (apply + (map square s))]\n               (cond\n                 (= 1 result) true\n                 (some #(= result %) [0, 4, 16, 20, 37, 42, 58, 89, 145]) false\n                 :else (recur result))))]\n     (is-happy? num)))", "user": "53214efbe4b09d4e7a9b54b2"}, {"problem": 86, "code": "(fn [n]\n\t(loop [n n p #{}]\n\t\t(let [x (->> \n\t\t\t\t\t(map (comp read-string str) (str n))\n\t\t\t\t\t(map #(* % %))\n\t\t\t\t\t(reduce +))]\n\t\t\t(cond\n\t\t\t\t(= x 1) true\n\t\t\t\t(contains? p x) false\n\t\t\t\t:else (recur x (conj p x))))))", "user": "536e5b68e4b0fc7073fd6e6d"}, {"problem": 86, "code": "(let [explode-digits (fn  [number] (map #(- (int %) (int \\0)) (str number)))\n\t  squared-digits (fn [number] (reduce + (map #(* % %) (explode-digits number))))]\n  (fn happy?\n  \t([number tries]\n  \t\t(cond\n  \t\t\t(= 1 number) true\n  \t\t\t(pos? tries) (happy? (squared-digits number) (dec tries))\n  \t\t\t:else false))\n  \t([number] (happy? number 1000))))", "user": "5412ef7ee4b01498b1a719da"}, {"problem": 86, "code": "(fn [init]\n  (loop [n init, visited? #{}]\n    (cond\n      (= 1 n)      true\n      (visited? n) false\n      :else\n      (recur\n        (->> (str n)\n             (map (comp #(* % %) \n                        read-string\n                        str))\n             (reduce +))\n        (conj visited? n)))))", "user": "53dfdf01e4b0d874e779ae46"}, {"problem": 86, "code": "(fn happy? [n]\n  \"Break number down into a collection of digits.\n  Square and add them.\n  Repeat with result until you get 1 (done) or 4 (will always infinite loop).\"\n  (letfn [(get-digits [x]\n            (for [i (iterate (partial * 10) 1)\n                  :while (<= i x)]\n              (mod (int (/ x i)) 10)))\n          (square-and-add [coll]\n            (reduce + (map #(* % %) coll)))]\n    (loop [a n]\n      (if (= 1 a)\n        true\n        (if (= 4 a)\n          false\n          (recur (square-and-add (get-digits a))))))))", "user": "542c026ae4b0dad94371f29a"}, {"problem": 86, "code": "(fn [n] (letfn [(digits [n] (let [r (quot n 10) m (mod n 10)]\n                               (if (= r 0) (list m)\n                                   (cons m (lazy-seq (digits r))))))\n                 (luckySeq [n] (reduce (fn [x y] (+ x (* y y))) 0 (digits n) ))\n                 ]\n           (loop [coll (rest (iterate luckySeq n)) seen #{}]\n             (let [f (first coll)]\n               (if (contains? seen f)\n                 (= 1 f)\n                 (recur (rest coll) (conj seen f))))\n             )\n           ))", "user": "5471f2fbe4b094393f72dd70"}, {"problem": 86, "code": "(letfn [( digits [x]\n  (if (= x 0)\n      nil\n    (conj\n     (digits\n      (quot x 10))\n     (rem x 10))))\n\n( step-number[x]\n  (apply +\n   (map\n    (fn [i] (* i i))\n    (digits x))))\n\n\n(happy-set [x s]\n  (if (s x)\n      false\n    (let [y (step-number x)]\n\t (if (= 1 x)\n\t     true\n\t   (happy-set y (conj s x))))))\n\n( happy-number [x] \n  (happy-set x #{}))]\n  \n  \n  happy-number)", "user": "50a4f36be4b0344e360f3bc9"}, {"problem": 86, "code": "(fn [x] \n  (cond \n    (= x 1) true\n    (= x 4) false\n    :else (recur (reduce #(+ % (* %2 %2)) 0 (map #(- (int %) (int \\0)) (str x))))\n  ))", "user": "549a176ce4b0f3d1d8e70f69"}, {"problem": 86, "code": "(fn [n]\n (letfn [\n  (bd [n]\n   (map\n    #(rem (quot n %) 10)\n    (take-while\n     #(<= % n)\n     (iterate\n      #(* % 10) 1))))\n  ]\n  (loop [vst #{n} n n]\n   (let\n    [nx\n     (reduce\n      +\n      (map\n       #(* % %)\n       (bd n)))]\n    (cond (= nx 1) true\n          (vst nx) false\n          :else\n           (recur\n            (conj\n             vst\n             nx)\n            nx))))\n))", "user": "549a999be4b0f3d1d8e70f6f"}, {"problem": 86, "code": "(fn happy-num? [x]\n  (letfn [(happy-seq [x]\n            (lazy-seq (cons x (happy-seq\n                                (reduce + (map #(let [x (- (int %) 48)]\n                                                  (* x x)) (str x)))))))]\n    (loop [[h & t] (happy-seq x) result #{}]\n      (cond\n        (result 1) true\n        (result h) false\n        :else (recur t (conj result h))))))", "user": "54769c7ae4b0c51c1f4d72a8"}, {"problem": 86, "code": "(fn [n]\n  (= 1\n     (loop [n n]\n       (if (or (<= n 1) (= 4 n))\n         n\n         (recur (apply + (map (comp int #(Math/pow % 2) read-string str) (str (int n)))))))))", "user": "511688d5e4b0b3e208dba05a"}, {"problem": 86, "code": "(fn [n]\n  (loop [n n sums []]\n    (let [sum-of-squared-digits (reduce + (map (comp #(* % %) read-string str) (str n)))]\n      (if (and (> sum-of-squared-digits 1) (not (contains? sums sum-of-squared-digits)))\n        (recur sum-of-squared-digits (conj sums sum-of-squared-digits))\n        (= sum-of-squared-digits 1)))))", "user": "5383668ee4b06839e8705edd"}, {"problem": 86, "code": "(fn happy-numbers [n]\n  (letfn [(sum-sq-digits [n]\n                         (let [digits (map #(- (int %) 48) (str n))]\n                           (apply + (map #(* % %) digits))))]  \n    (loop [x n ss #{}]\n      (let [s (sum-sq-digits x)]\n        (cond\n          (= s 1) true\n          (contains? ss s) false\n          :else (recur s (conj ss s)))))))", "user": "54b13a40e4b09f271ff37d1b"}, {"problem": 86, "code": "(fn [s n]\n  (if (= 1 n)\n    true\n    (let [sum (reduce + (map #(* % %) ((fn [r n] (if (= n 0) r (recur (conj r (mod n 10)) (quot n 10)))) [] n)))]\n      (if (s sum)\n        false\n        (recur (conj s sum) sum))))) #{}", "user": "54b2ec84e4b09f271ff37d33"}, {"problem": 86, "code": "(fn happy?\n  ([n] (happy? n #{}))\n  ([n s] (if (= 1 n) true (if (s n) false (recur ((fn [m] (apply + (map #(* % %) (map #(- (int %) (int \\0)) (str m))))) n) (conj s n))))))", "user": "54bd04e7e4b0ed20f4ff6ed8"}, {"problem": 86, "code": "(letfn [\n        (t [n]\n            (->>\n             (str n)\n             (map #(- (int %) (int \\0)) )\n             (map #(* % %))\n             (apply +)))\n        (happy? \n         ([n] (if (= 1 n ) true (happy? (t n) #{})))\n         ([n m] (cond (= 1 n) true\n                      (m n) false \n                      :else (recur (t n) (conj m n))))) ] happy?)", "user": "54af6fb0e4b09f271ff37d08"}, {"problem": 86, "code": "(fn [x]\n  (letfn [(is-happy [prevs n]\n                    (cond\n                      (= 1 n) true\n                      (prevs n) false\n                      :else (is-happy\n                              (conj prevs n)\n                              (apply + (map #(* % %) (map #(- (int %) 48) (str n)))))))]\n    (is-happy #{} x)))", "user": "50f10f7be4b06d9538fe211a"}, {"problem": 86, "code": "(fn happy? [n]\n  (let [happy (fn [x] (reduce +\n                              (map #(* %1 %1)\n                                   (map read-string\n                                        (re-seq #\".\" (str x))))))]\n    (= 1 (happy\n          (last (take-while #(and (not= 1 %1) (not= 4 %1))\n                            (iterate happy n)))))))", "user": "54be7772e4b0ed20f4ff6eea"}, {"problem": 86, "code": "(fn happy-number? [num]\n  (letfn [(square-sum [n]\n                      (apply + (map #(* % %) (map #(Integer/parseInt (str %)) (str n)))))\n          (step [n mid-results]\n                (let [mid-result (square-sum n)]\n                  (if (= 1 mid-result)\n                    true\n                    (if (some #{mid-result} mid-results)\n                      false\n                      (step mid-result (conj mid-results mid-result))))))]\n    (step num #{num})))", "user": "53b7aa6ce4b047364c0444d1"}, {"problem": 86, "code": "(fn [n]\n  (let [next_n #(loop [n %\n                      nn 0]\n                 (let [[b a] ((juxt quot rem) n 10)\n                       nn (+ nn (* a a))]\n                   (if (== b 0)\n                     nn\n                     (recur b nn))))]\n    (loop [n n\n           s #{}]\n      (cond (= n 1) true\n            (contains? s n) false\n            :else (recur (next_n n) (conj s n)))\n      )))", "user": "526143b7e4b03e8d9a4a705a"}, {"problem": 86, "code": "(fn [n] \n    (loop [n n l #{}]\n      (if (= n 1)\n        true\n        (if (contains? l n)\n          false\n          (recur (apply + (map #(* % %) (loop [l (list) n n]\n                                          (if (= n 0)\n                                            l   \n                                            (recur (conj l (mod n 10)) (int (/ n 10)))\n                                            )   \n                                          ))) (conj l n)) \n          )   \n        )   \n      )   \n    )", "user": "54b90836e4b0ed20f4ff6e9d"}, {"problem": 86, "code": "(fn happynum\n  [num]\n  (if (= num 1)\n    true\n    (if (= num 4)\n      false\n      (happynum (apply + (map (comp #(* % %) bigint str)(str num)))))))", "user": "520cb8c4e4b0b022ef140c9a"}, {"problem": 86, "code": "(fn [n]\n  (let [digits (fn digits [n] (if (< n 10) [n] (conj (digits (quot n 10)) (rem n 10))))\n        new-num (fn [n] (->> (digits n) (map #(* % %)) (reduce +)))]\n    (loop [i n nums #{}]\n      (cond\n        (= i 1) true\n        (nums i) false\n        :else (recur (new-num i) (conj nums i))))))", "user": "549c1713e4b0f3d1d8e70f82"}, {"problem": 86, "code": "(fn [n]\n  (letfn [(f [x xs]\n             (cond (= x 1) true\n                   (contains? xs x) false\n                   :else (recur\n                          (->> (str x)\n                               (map #(Character/digit % 10))\n                               (map #(* % %))\n                               (reduce +))\n                          (conj xs x))))]\n    (f n #{})))", "user": "54c271b9e4b045293a27f602"}, {"problem": 86, "code": "#(= 1\n    (nth (iterate (fn [n]\n                    (apply + (map (zipmap \"0123456789\" (map * (range) (range)))\n                                  (str n))))\n                  %)\n         9))", "user": "508923d5e4b06d8254e936e8"}, {"problem": 86, "code": "< 5\n;(fn happy? [n]\n;  (loop [n n s #{n}]\n;    (let [n (reduce + (mapv (comp #(* % %) #(- (int %) (int \\0))) (str n)))]\n;      (if (s n)\n;        (= 1 n)\n;        (recur n (conj s n))))))", "user": "54ca9ca8e4b057c6fda3a265"}, {"problem": 86, "code": "(fn [n]\n    (let [ds (fn [v] (->> v (iterate #(quot % 10)) (take-while #(> % 0)) (map #(rem % 10))))]\n      (loop [n n ns #{}]\n        (cond (= n 1) true\n              (contains? ns n) false\n              :else (recur (apply + (map #(* % %) (ds n))) (conj ns n))))\n      ))", "user": "54c641f8e4b045293a27f628"}, {"problem": 86, "code": "(fn happy ([n] (happy n #{n}))\n          ([n seen] (let [next (apply + (map (comp #(* % %) #(java.lang.Integer/parseInt %) str) (flatten (partition 1 (str n)))))]\n                      (if (= next 1)\n                          true\n                          (if (contains? seen next)\n                              false\n                              (happy next (conj seen next)))))))", "user": "542c1f73e4b0dad94371f29d"}, {"problem": 86, "code": "(fn happy-number? [x] \n  (let [digits (fn [n]\n    (loop [acc [], remainder n]\n      (let [digit (rem remainder 10)]\n        (if (<= remainder 0) acc\n          (recur   (concat [digit] acc)   (quot remainder 10)\n  )))))]\n  (loop [curr x, history #{}]\n    (cond\n      (= curr 1)               true ; heaven\n      (contains? history curr) false ; hell\n      :else\n        (recur \n           (apply +  (map #(* % %) (digits curr)))\n           (conj history curr)\n       )))))", "user": "54bbe505e4b0ed20f4ff6ec5"}, {"problem": 86, "code": "(fn happy [n]\n  (letfn [(sq [x] (* x x))\n          (ch->int [ch] (- (int ch) (int \\0)))\n          (sum-of-squares [n]\n            (reduce + (map (comp sq ch->int) (str n))))]\n    (loop [num (sum-of-squares n), seen #{}]\n      (cond\n       (= num 1)            true\n       (contains? seen num) false\n       :else                (recur (sum-of-squares num), (conj seen num))))))", "user": "541b1f25e4b01498b1a71a63"}, {"problem": 86, "code": "(fn [n]\n  (letfn [(helper [n] (reduce + 0 (for [d (str n)\n                                        :let [d (- (int d) (int \\0))]]\n                                    (* d d))))]\n    (let [all (iterate helper n)\n          sets (reductions conj #{} all)\n          pairs (map vector sets (rest sets))]\n      (first (for [[s rs] pairs\n                   :when (or (s 1) (= s rs))]\n               (if (s 1) true false))))))", "user": "4ea03f70535d7eef308072a1"}, {"problem": 86, "code": "(fn [n]\n  (loop [ n n seen #{}]\n    (letfn [(digits [x] (map #(Integer. (str %)) (str x)))\n            (next-num [x] (apply + (map #(* % %) (digits x))))]\n      (cond \n        (= n 1)  true\n        (seen n) false\n        :else    (recur (next-num n) (conj seen n))))))", "user": "54d6f22de4b0a52adc2e2023"}, {"problem": 86, "code": "(fn [n]\n    (let [digitFn #(loop [e (rem % 10)\n                          l (quot % 10)\n                          coll '()]\n                     (if (= 0 l) (conj coll e)\n                         (recur (rem l 10) (quot l 10) (conj coll e))))]\n      (loop [num n\n             sums #{}]\n        (let [sum (apply + (map #(* % %) (digitFn num)))]\n          (cond\n            (= sum 1) true\n            (contains? sums sum) false\n            :else (recur sum (conj sums sum)))))))", "user": "53f31dafe4b0742d9025b0f0"}, {"problem": 86, "code": "(fn f [n]\n  (let [ss {\\0 0, \\1 1, \\2 4, \\3 9, \\4 16, \\5 25, \\6 36, \\7 49, \\8 64, \\9 81}\n        l 1000]\n    (letfn [(s [n] (reduce + (map ss (str n))))\n            (g [n] (when (> n 1) (cons n (lazy-seq (g (s n))))))]\n      (->> (g n)\n           (take l)\n           count\n           (> l)))))", "user": "54dd76c8e4b024c67c0cf794"}, {"problem": 86, "code": "(fn  [n]\n  (let [num->digits\n        (fn [num]\n          (loop [n num res []]\n            (if (zero? n)\n              res\n              (recur (long (/ n 10)) (cons (mod n 10) res)))))\n        happy? (fn [n sads]\n                 (let [sum (reduce +  (map #(* % %) (num->digits n)))]\n                   (cond  (=  sum 1) true\n                         (some #(= % n) sads) false\n                         :else (recur sum (cons n sads)))))]\n                 (happy? n [])))", "user": "53664e3be4b0243289761e74"}, {"problem": 86, "code": "#(loop [y %]\n   (if (>= y 10)\n     (recur ((fn [x]\n               (loop [y x z 0]\n                 (if (not= y 0)\n                   (recur (quot y 10) (+ z (* (rem y 10) (rem y 10))))\n                   z))) y))\n     (or (= y 1) (= y 7))))", "user": "54d753ebe4b0a52adc2e2029"}, {"problem": 86, "code": "(fn [n]\n  (letfn [(happy [nu]\n            (iterate \n             #(apply +\n                     (map (fn [z] \n                            (let [n (Integer/parseInt (str z))]\n                              (* n n)))\n                          (str %)))\n             nu))]\n             (loop [s (first (happy n))\n                    nums #{}]\n               (if (= 1 s)\n                 true\n                 (if (nums s)\n                   false\n                   (recur (first (rest (happy s)))\n                          (conj nums s)))))))", "user": "4dd6d7ee535d2dad7130b5cb"}, {"problem": 86, "code": "(fn [n]\n    (letfn\n       [(toDigits [x] (map #(- (int %) 48) (seq (str x))))\n        (sos [y] (apply + (map #(* % %) y)))]\n         (loop [curr n seen #{}]\n    (if (= 1 curr) true\n     (if (seen curr) false\n       (recur (sos (toDigits curr)) (conj seen curr)))))))", "user": "54908cc1e4b0b312c081ff32"}, {"problem": 86, "code": "(fn happy?\n  ([n] (happy? n #{n}))\n  ([n s]\n   (letfn \n       [(digits [n] (if (= n 0) [] (conj (digits (quot n 10)) (rem n 10))))\n        (sum-squares [s] (apply + (map #(* % % ) s)))]\n     (let [ssd (sum-squares (digits n))]\n       (cond\n         (= ssd 1) true\n         (contains? s ssd) false\n         :else (happy? ssd (conj s ssd)))))))", "user": "54e3df6ae4b024c67c0cf7e3"}, {"problem": 86, "code": "(fn happy? [n]\n\t(loop [n n path #{}]\n\t\t(if (= 1 n)\n\t\t\ttrue\n\t\t\t(let [sum\n\t\t\t\t(reduce\n\t\t\t\t\t+\n\t\t\t\t\t(map\n\t\t\t\t\t\t#(let [x (read-string (str %))] (* x x))\n\t\t\t\t\t\t(str n)))]\n\t\t\t\t(if (path sum) false (recur sum (conj path sum)))))))", "user": "5472d919e4b094393f72dd7b"}, {"problem": 86, "code": "(fn [n]\n  (loop [n n, seen #{}]\n    (cond \n      (= n 1)  true\n      (seen n) false\n      :else\n        (recur (->> (str n)\n                    (map #(Character/digit % 10))\n                    (map #(* % %))\n                    (reduce +))\n               (conj seen n)))))", "user": "517e12e3e4b0fcc7c5d37d3c"}, {"problem": 86, "code": "(fn [integer]\n  (loop [new-integer integer\n         previous-values #{}]\n    (let [digits (map #(Character/getNumericValue %) (str new-integer))\n          sum-of-squared-digits (reduce + (map #(* % %) digits))]\n      (cond (= sum-of-squared-digits 1) true\n            (contains? previous-values sum-of-squared-digits) false\n            :else (recur sum-of-squared-digits (conj previous-values sum-of-squared-digits))))))", "user": "54cc26c1e4b057c6fda3a28a"}, {"problem": 86, "code": "(fn is-happy?\n  ([val] (is-happy? val 0))\n  ([val iterations]\n    (\n      let [ssum (reduce + (map #(* % %) (map #(- (int %) 48) (str val))))]\n      (if (= 1 ssum)\n               true\n               (if (> iterations 999)\n                   false\n                   (is-happy? ssum (inc iterations))))\n    )\n  )\n)", "user": "546692aee4b01be26fd746e7"}, {"problem": 86, "code": "(fn [x]\n  (letfn [(sum-digits [v]\n                      (->> (str v)\n                           (map str)\n                           (map read-string)\n                           (map #(* % %))\n                           (reduce +)))]\n    (loop [y x\n           lst []]\n      (let [s (sum-digits y)]\n        (if (= 1 s)\n          true\n          (if (contains? lst y)\n            false\n            (recur s (conj lst s))))))))", "user": "525cc912e4b0cb4875a45d48"}, {"problem": 86, "code": "(fn hn [n & [s]]\n (let [s (or s #{})\n       ssq ((fn ssqd [m]\n              (let [q (quot m 10)\n                    d (mod m 10)]\n                (cond \n                  (= 0 m) 0\n                  (= 1 m) 1\n                  :else (+ (* d d) (ssqd (quot m 10)))))) n)]\n   (cond \n     (= 1 ssq) true\n     (contains? s ssq) false\n     :else (hn ssq (conj s ssq)))))", "user": "54d4bd2be4b0a52adc2e2005"}, {"problem": 86, "code": "(fn happy [n]\n  (letfn [(sum-squares [n]\n            (->> n\n                 str\n                 (map str)\n                 (map #(Integer. %))\n                 (map #(* % %))\n                 (reduce +)))\n\n          (happy' [n visited]\n            (let [s (sum-squares n)]\n              (cond\n                (visited s)\n                false\n\n                (= 1 s)\n                true\n\n                :else\n                (recur s (conj visited s)))))]\n    (happy' n #{})))", "user": "532b43c3e4b09d4e7a9b5531"}, {"problem": 86, "code": "(fn [m]\n  (letfn [(sum-squares [n]\n            (apply + (map (fn [astr]\n                            (let [a (Integer/parseInt (str astr))]\n                              (* a a))) (str n))))\n          \n          (my-it [lst n]\n            (if (not= -1 (.indexOf lst n)) (conj lst n)\n                (my-it (conj lst n) (sum-squares n))))]\n    (= 1 (last (my-it [] m)))))", "user": "51b76227e4b0d906fcd71d35"}, {"problem": 86, "code": "(letfn [(f ([n] (f n #{}))\n           ([n s] (let [y (apply + (map #(let [x (Integer. (str %))] (* x x)) (str n)))]\n                    (if (= 1 y) true (if (s y) false (recur y (conj s y)))))))] f)", "user": "54f0d3fde4b024c67c0cf8a6"}, {"problem": 86, "code": "(fn hn [num]\n  (let [pow (fn [n1 n2] (apply * (repeat n2 n1)))\n    n2v (fn [n] \n    (vec \n      (reverse\n        (for [i (range (count (str n)))]\n          (rem (quot n (pow 10 i)) 10)))))]\n    (loop [i num j 0 s false]\n      (if (> j 1000)  \n        s \n        (recur (apply + (map #(* % %) (n2v i))) \n          (inc j) \n          (if (= 1 (apply + (map #(* % %) (n2v i)))) true false))))))", "user": "5243e37ae4b076204b44fae3"}, {"problem": 86, "code": "(fn [x]\n  (letfn [(digits [n]\n            (if (zero? n)\n              []\n              (conj (digits (quot n 10)) (mod n 10))))\n          (square [n]\n            (* n n))\n          (sum-squared [n]\n            (apply + (map square (digits n))))]\n    (= 1 (last (take 1000 (iterate sum-squared x))))))", "user": "5344fe13e4b084c2834f4a32"}, {"problem": 86, "code": "(fn [n]\n    (loop [n n a #{n}]\n      (let [digits (loop [a '() n n]\n                     (if (zero? n)\n                       a\n                       (recur (conj a (mod n 10)) (int (/ n 10)))))\n            newnum (->> digits\n                        (map #(* % %))\n                        (apply +))]\n        (println newnum a)\n        (cond\n          (= 1 newnum) true\n          (contains? a newnum) false\n          :else (recur newnum (conj a newnum))))))", "user": "5470b3d0e4b00cfc9eacc1bb"}, {"problem": 86, "code": "(fn [n]\n  (= 1\n    (loop [n n cache #{}]\n      (if (or (< n 2) (cache n)) n\n        (recur (reduce + (map (fn [ch] (let [i (Integer. (str ch))] (* i i))) (str n)))\n          (conj cache n))))))", "user": "546ff835e4b00cfc9eacc1b4"}, {"problem": 86, "code": "(fn [n]\n    (loop [i n\n           sofar #{}]\n      (if (= i 1) \n        true \n        (if (contains? sofar i)\n          false\n          (recur (reduce + (map #(* (- (int %) 48) (- (int %) 48)) (seq (str i)))) (conj sofar i))))))", "user": "544e9022e4b0e3978000698b"}, {"problem": 86, "code": "(fn [n]                                                                                                                                                                                                                                                        \n  (loop [it 1000 n n]                                                                                                                                                                                                                                          \n    (let [ns (map (fn [i] (Integer/parseInt (str i))) (str n))                                                                                                                                                                                                 \n          new-n (reduce (fn [acc e] (+ acc (* e e))) 0 ns)]                                                                                                                                                                                                    \n      (if (= 0 it)                                                                                                                                                                                                                                             \n        false                                                                                                                                                                                                                                                  \n        (if (= 1 new-n)                                                                                                                                                                                                                                        \n          true                                                                                                                                                                                                                                                 \n          (recur (dec it) new-n))))))", "user": "541d3c0fe4b01498b1a71a7e"}, {"problem": 86, "code": "(fn happy? ([n] (happy? n {}))\n  ([n s] (if (s n) false\n      (let [k (apply + (map (comp #(* % %) #(Character/digit % 10)) (str n)))]\n          (if (= k 1) true (happy? k (conj s [n k])))))))", "user": "54bd3aefe4b0ed20f4ff6edb"}, {"problem": 86, "code": "(fn happy? [n]\n  (letfn [(digits [n]\n            (map #(Integer/parseInt (str %)) (str n)))\n          (sum-of-squares [n]\n            (reduce + (map #(* % %) (digits n))))]\n    (boolean (some #{1} (take 100 (iterate sum-of-squares n))))))", "user": "539c736ce4b0b51d73faaf2b"}, {"problem": 86, "code": "(fn [x]\n  (loop [x x\n         sums #{}]\n    (let [digits (map #(Integer/parseInt (str %)) (seq (str x)))\n          squares (map #(* % %) digits)\n          sum (apply + squares)]\n      (cond (= sum 1) true\n            (contains? sums sum) false\n            :else (recur sum (conj sums sum))))))", "user": "4e82c062535db62dc21a62cc"}, {"problem": 86, "code": "(fn h\n  [i n]\n   (if (< i 9)\n     (let [s (map #(- (int %) 48) (str n))\n           x #(apply + %)]\n       (or (= (x s) 1) (h (+ 1 i) (x (map #(* % %) s)))))\n     false)) 0", "user": "51a4d802e4b0def3c5c5869a"}, {"problem": 86, "code": "(fn squaresum [n]\n  (loop [n n oldnums {}  exit 0]\n    (assert (> 1000 exit))\n    (cond \n     ;We found a happy number!\n     (= 1 n) true\n     ;We are in a cycle :(\n     (get oldnums n) false\n     \n     :else (recur \n            (->> (str n)\n                 (map #(Character/digit % 10))\n                 (map #(* % %))\n                 (reduce +))\n            (assoc oldnums n true)\n            (inc exit)))))", "user": "50be9b4ae4b00fb48fed2ef6"}, {"problem": 86, "code": "(fn [o]\n  (letfn [(num [n] (apply + (map #(* % %)\n                                 (loop [n n acc []]\n                                   (if (zero? n)\n                                     acc\n                                     (recur (quot n 10) (conj acc (rem n 10))))))))]\n    (loop [n (num o) acc #{}]\n      (cond\n       (= n 1) true\n       (acc n) false\n       :else (recur (num n) (conj acc n))))))", "user": "54fdbe3fe4b07d26eda61d3b"}, {"problem": 86, "code": "(fn happyNum\n  [n]\n  (let [ssd (fn [x]\n              (reduce\n               #(+ %1 (* %2 %2))\n               0\n               (map #(read-string (str %)) (str x))))]\n    (loop [currNum n\n           alreadySeen #{}]\n      (cond\n       (contains? alreadySeen (ssd currNum)) false\n       (= (ssd currNum) 1) true\n       :else (recur (ssd currNum) (conj alreadySeen currNum))))))", "user": "54f64e99e4b0f2f3c5226ea4"}, {"problem": 86, "code": "(fn [x]\n  (loop [x x tot []]\n    (cond \n      (= x 1) true\n      (some #{x} tot) false\n      :otherwise (let [m (apply + (map #(let [n (- (int %) 48)] (* n n)) \n                               (str x)))]\n                   (recur m (conj tot x))))))", "user": "4f7207d3e4b07046d9f4f019"}, {"problem": 86, "code": "#(> % 6)", "user": "54b7f217e4b0ed20f4ff6e8f"}, {"problem": 86, "code": "(fn [x]\n  (loop [x x prev #{}]\n    (cond\n     (= x 1) true\n     (prev x) false\n     :else (recur (apply + (map #(apply * (repeat 2 (read-string (str %)))) (seq (str x)))) \n                  (conj prev x)))))", "user": "54febf4be4b07d26eda61d45"}, {"problem": 86, "code": "(fn [n]\n  (letfn [(step [x] (reduce + (map #(* % %) (map (comp #(- % 48) int) (.toString x)))))]\n         (loop [tried #{}\n                n     n]\n              (if (= 1 n)\n                  true\n                  (if (tried n)\n                      false\n                      (recur (conj tried n) (step n)))))))", "user": "544e8369e4b0e39780006987"}, {"problem": 86, "code": "(letfn [(digs [n]\n              (if (zero? n)\n                []\n                (conj (digs (quot n 10)) (mod n 10))))\n        (sum-squar [n]\n                   (->> n\n                        digs\n                        (reduce #(+ %1 (* %2 %2)) 0)))\n        (seqtor [n]\n                (cons n (lazy-seq (seqtor (sum-squar n)))))]\n  (fn [n]\n    (loop [s (seqtor n)\n           visited #{}]\n      (condp #(%1 %2) (first s)\n        #{1} true\n        visited false\n        (recur (next s) (conj visited (first s)))))))", "user": "53908e6be4b0b51d73faae9a"}, {"problem": 86, "code": "(fn is-happy? [n]\n  (loop [n n]\n    (cond (= n 1) true\n          (= n 4) false\n          :else\n          (recur (reduce + (map #(* % %) (map (fn [x] (Character/digit x 10)) (str n))))))))\n#_(fn [x]\n  (let [happy (fn [n] \n                  (apply + (map #(Math/pow (Integer/parseInt %) 2)\n                                (clojure.string/split (str n) #\"\" ))))]\n      (= 1 (nth (iterate happy x) 20))\n))", "user": "54e51c7be4b024c67c0cf7f7"}, {"problem": 86, "code": "(fn [n]\n  (let [h1 (fn [n]\n             (apply + (map (fn [c] (let [x (Integer. (str c))] (* x x)))\n                           (seq (str n)))))\n        h (fn h [sofar n]\n            (if (= n 1)\n              true\n              (let [hn (h1 n)]\n                (if (sofar hn)\n                  false\n                  (h (conj sofar hn) hn)))))]\n    (h #{} n)))", "user": "548fa2dfe4b0e286459a1240"}, {"problem": 86, "code": "(fn happy\n   ([digit]\n    (happy digit #{}))\n   ([digit tries]\n    (let [sumsq (fn [x]\n                  (apply + (map #(let [d (- (int %) 48)] (* d d)) (str x))))\n          newdigit (sumsq digit)]\n      (cond \n       (= 1 newdigit) true\n       (contains? tries newdigit) false\n       :else (happy newdigit (conj tries digit))))))", "user": "54d9366ce4b0a52adc2e204e"}, {"problem": 86, "code": "(fn happy?\n  [n] {:pre [(integer? n), (pos? n)]}\n\n  ;; We begin by defining some helper functions.\n  (let [\n        ;; First we have a squaring function, just for convenience.\n        sq (fn [x] (* x x))\n\n        ;; Next, we have the function f. This is the iterator used in the\n        ;; definition of a happy number; that is, f takes a positive integer n\n        ;; and returns the sum of the squares of the digits of n.\n        f (fn [n]\n            (loop [acc 0, n n]\n              (if (< n 1)\n                (+ acc (sq n))\n                (recur (+ acc (sq (mod n 10)))\n                       (quot n 10)))))]\n\n    ;; For the main body of the function, we loop through the iterates of f\n    ;; until we either find a 1 (indicating that n is happy) or find a number\n    ;; we've already seen (indicating that the sequence repeats and n is\n    ;; unhappy).\n    (loop [seen #{}, [i & tail] (iterate f n)]\n      (cond\n        (= i 1)   true\n        (seen i)  false\n        :else     (recur (conj seen i) tail)))))", "user": "4fc6305de4b0ee37620e180b"}, {"problem": 86, "code": "(fn [num]\n  (letfn [(sqr-digits [numstr] (reduce #(let [i (Character/getNumericValue %2)] (+ %1 (* i i))) 0 (into #{} (str numstr))))]\n    (loop [cnt 0\n           sum (sqr-digits num)]\n      (cond\n        (= sum 1) true\n        (> cnt 100) false\n        :else (recur (inc cnt) (sqr-digits sum))\n        )\n      )\n  )\n)", "user": "54e5bdf2e4b024c67c0cf7fe"}, {"problem": 86, "code": "(fn [n]\n  (let [next-n (fn [n]\n                 (reduce + (map #(-> %\n                                     str\n                                     Integer/parseInt\n                                     ((fn [n] (* n n))))\n                                (str n))))\n        do-the-needful (fn [n seen]\n                         (cond (= 1 n) true\n                               (seen n) false\n                               :else (recur (next-n n) (conj seen n))))]\n    (do-the-needful n #{})))", "user": "51b91b08e4b0e871ca4958f8"}, {"problem": 86, "code": "#(letfn [(digits\n          ([n] (digits n []))\n          ([n a] (if (zero? n)\n                   a\n                   (let [r (rem n 10)]\n                     (recur (/ (- n r) 10)\n                            (conj a r))))))\n         (happy-step [n]\n                     (reduce + (map (fn [x] (* x x)) (digits n))))]\n   (loop [n %]\n     (condp = n\n       1 true\n       4 false\n       (recur (happy-step n)))))", "user": "551ed214e4b08d5046aa8a4d"}, {"problem": 86, "code": "(fn happy-num [num]\n  (loop [num num mem [100] comp [] firstt true]\n    (if (= num 1)\n      true\n      (if (contains? (set mem) num)\n        (if (= mem comp)\n          false\n          (if firstt (recur (loop [numstr (str num) res 0] (if (empty? numstr)\n                       res\n                       (recur (rest numstr) (+ res (* (Integer/parseInt (str (first numstr))) (Integer/parseInt (str (first numstr)))))))) (vec (conj [] num)) comp false)\n            (recur (loop [numstr (str num) res 0] (if (empty? numstr)\n                       res\n                       (recur (rest numstr) (+ res (* (Integer/parseInt (str (first numstr))) (Integer/parseInt (str (first numstr)))))))) mem (vec (conj comp num)) firstt)))\n        (recur (loop [numstr (str num) res 0] (if (empty? numstr)\n                   res\n                   (recur (rest numstr) (+ res (* (Integer/parseInt (str (first numstr))) (Integer/parseInt (str (first numstr)))))))) (vec (conj mem num)) comp firstt)))))", "user": "5508102ee4b021ccfedb96b0"}, {"problem": 86, "code": "(fn happy? \n    ([n seen]\n    (let [happified \n        (loop [res 0 left-over n]\n            (if (= left-over 0)\n                res\n                (recur (+ (* (mod left-over 10) (mod left-over 10)) res) (quot left-over 10))))]\n        (cond (= 1 happified) true\n              (contains? seen happified) false\n              :else (happy? happified (conj seen happified))))) \n        ([n] (happy? n #{})))", "user": "54f09599e4b024c67c0cf89d"}, {"problem": 86, "code": "(fn happy-number?\n  ([n]\n    (happy-number? n #{}))\n  ([n s]\n    (let [digits (fn [n]\n                   (loop [n n, ds []]\n                     (if (< n 10)\n                       (conj ds n)\n                       (recur (quot n 10) (conj ds (rem n 10))))))\n          square (fn [x] (* x x))]\n      (cond\n        (= 1 n)   true\n        (get s n) false\n        :else (let [n1 (reduce + (map square (digits n)))]\n                (happy-number? n1 (conj s n)))))))", "user": "54f2fe9fe4b050824f58f5b8"}, {"problem": 86, "code": "(fn [n]\n  (letfn\n    [(square [n] (* n n))\n     (digits [n] (map #(Long/valueOf (str %)) (str n)))\n     (sum-square-digits [n] (reduce + (map square (digits n))))\n     (happy? [n s] \n           (or (= n 1)\n               (and ((complement contains?) s n)\n                    (recur (sum-square-digits n) (conj s n)))))]\n    (happy? n '#{})))", "user": "5514a60fe4b055c2f668d4d7"}, {"problem": 86, "code": "(fn [n] \n  (letfn\n    [(recrFunc\n      [n m]\n      (cond\n       (= 1 n) true\n       (contains? m n) false\n       :else (recrFunc (reduce + (map #(let [nu (Integer/parseInt (str %))] (* nu nu)) (apply list (str n))))  (conj m n))\n       ))\n     ]\n    (recrFunc n #{}))\n  )", "user": "54edcf96e4b024c67c0cf866"}, {"problem": 86, "code": "(fn [n]\n  (letfn [(step [n] \n                (loop [n n, acc 0]\n                  (if (= 0 n) acc\n                    (recur (quot n 10) (+ acc (#(* % %) (mod n 10)))))))]\n    (loop [n n, seen #{}]\n      (let [n (step n)]\n        (println n)\n        (cond\n         (= n 1) true\n         (seen n) false\n         :else (recur n (conj seen n)))))))", "user": "55253217e4b0882d96d091ce"}, {"problem": 86, "code": "(fn happy? [n]\n  (let [squared-sum (fn squared-sum [n]\n                        (reduce + (map \n                                   #(let [n (- (int %) (int \\0))] \n                                      (* n n)) \n                                   (str n))))]\n    (loop [sq n\n           res #{}]\n    \t(if (contains? res sq)\n      \t\tfalse\n      \t\t(if (= 1 (squared-sum sq))\n        \t\ttrue\n        \t\t(recur (squared-sum sq) (conj res sq)))))\n  \n))", "user": "5143824ae4b0b4fb4ace5f36"}, {"problem": 86, "code": "(fn [a]\n  (loop [seen #{} a a]\n    (cond\n      (= 1 a) true\n      (seen a) false\n      :e\n      (recur (conj seen a)\n             (reduce + (map #(* % %)\n                            (map #(- (int %) 48) (str a))))))))", "user": "55201d18e4b08d5046aa8a5d"}, {"problem": 86, "code": "(fn [n0] (if (some #(= 1 %) (take 10 (iterate (fn [n]\n                                                        (apply + (map  \n                                                                   (fn [n1] (let [numr (- (int n1) (int \\0))] (* numr numr))) \n                                                                   (seq (str n))))\n                                                        ) n0 ))) true false))", "user": "533c2605e4b0e30313ee6cd7"}, {"problem": 86, "code": "(fn  [n]\n  (let [ funone (fn [[s x]]\n                  (let [strx (seq (str x))\n                        intx (map #(- (int %) 48) strx)\n                        ne   (apply + (map #(* % %) intx))\n                        ]\n                    [(conj s x) ne]\n                    ))]\n    (= 1 (last (first (filter (fn [[s x]] (contains? s x)) (iterate funone [#{} n] )))))\n    )\n)", "user": "54a1d643e4b09f271ff37c50"}, {"problem": 86, "code": "(fn [in]\n  (letfn [\n    (sqsum [n]\n    (int (reduce + (map #(Math/pow (mod % 10) 2) (take-while pos? (iterate #(Math/floor (/ % 10)) n))))))]\n  (loop [n in seen #{}]\n  (if (= 1 n) true\n  (if (seen n) false\n    (recur (sqsum n) (conj seen n))\n  ))))\n)", "user": "5519c157e4b00ace28fe6e32"}, {"problem": 86, "code": "(fn [x]\n  (loop [n x seen #{}]\n    (let [i  (reduce #(+ %1  (* %2 %2)) 0 (for [c (str n)] (Integer/parseInt  (str c))))]\n      (cond \n        (contains? seen i) false\n        (= 1 i) true\n        :else (recur i (conj seen i))))))", "user": "52eaba10e4b09f7907dd14c2"}, {"problem": 86, "code": "(fn [x]\n  (loop [n x\n         a '()]\n    (let [r (apply + (map #(* % %) (map #(- (int %) 48) (seq (str n)))))]\n      (cond\n        (> (.indexOf a r) -1) false\n        (= 1 r) true\n        :default (recur r (conj a r))))))", "user": "53d5a63be4b0e771c3025449"}, {"problem": 86, "code": "(let [digits (fn [n] (map #(- (int %) (int \\0)) (str n)))\n        sum-sq (fn [n] (apply + (map #(* % %) (digits n))))]\n    (fn [n]\n      (loop [old-n n\n             checked? #{}]\n        (let [new-n (sum-sq old-n)]\n          (if (= 1 new-n)\n            true\n            (if (checked? new-n)\n              false\n              (recur new-n (conj checked? old-n))))))))", "user": "5531e445e4b09218d5f44f76"}, {"problem": 86, "code": "(fn happy? [x]\n  (letfn [(digs [n] (if (= 0 n) [] (cons (mod n 10) (digs (quot n 10)))))]\n    (loop [x x, xs #{}]\n      (cond\n       (contains? xs x) false\n       (= 1 x) true\n       :else (recur (apply + (map #(* % %) (digs x))) (conj xs x))))))", "user": "553e0b70e4b0a04f792994e8"}, {"problem": 86, "code": "; just assume iterating 100 times is good enough\n; (Should build up a set and watch for recurrence\n;  but that would require order N memory!)\n(fn [nn]\n  (letfn [\n          (dig [n] (map #(read-string (str %)) (str n)))\n          (hap [n] (reduce + (map #(* % %) (dig n))))\n          ]\n    (= 1 (first (drop 100 (iterate hap nn))))))", "user": "54b04708e4b09f271ff37d11"}, {"problem": 86, "code": "(fn [n]\n    (let [digits\n          (fn d [n]\n            (if (zero? n) ()\n              (lazy-seq (cons (mod n 10) (d (quot n 10))))))\n          next-number\n          (fn [n]\n            (apply + (for [x (digits n)] (* x x))))]\n      (loop [all #{n}\n             n (next-number n)]\n        (cond\n          (= n 1) true\n          (all n) false\n          :else (recur (conj all n) (next-number n))))))", "user": "55274467e4b0ffed3738f92b"}, {"problem": 86, "code": "(fn happy-numbers\n  \n  [num]\n  (letfn [ (next-num\n             [num]\n             (reduce + (map #(* (Integer/valueOf (str %) ) (Integer/valueOf (str %))) (str num) ))\n             ) ]\n    (loop [number num\n           num-in-cycle #{}]\n      (let [ nxt (next-num number) ]\n        (cond\n         (num-in-cycle nxt) false\n         (= 1 nxt) true\n         :else (recur nxt (conj num-in-cycle number))\n         ))\n      ))\n  )", "user": "51f81925e4b09be9c177e526"}, {"problem": 86, "code": "(fn happy-number?\n  [n]\n  (letfn [(char-to-int\n            [c]\n            (- (int c) 48))\n          (sum-of-squared-digits\n            [n]\n            (->> (str n)\n                 (seq)\n                 (map char-to-int)\n                 (map #(* % %))\n                 (apply +)))]\n    (loop [nums (iterate sum-of-squared-digits n)\n           tested-nums #{}]\n      (let [current-num (first nums)]\n        (cond\n         (= 1 current-num) true\n         (contains? tested-nums current-num) false\n         :else (recur (rest nums) (conj tested-nums current-num)))))))", "user": "53b952eee4b047364c0444e6"}, {"problem": 86, "code": "(fn [h]\n  (loop [seen #{} cur h]\n    (if (= 1 cur) true\n      (if (contains? seen cur) false\n        (recur\n          (conj seen cur)\n          (reduce + (map #(* % %) (loop [n cur d []]\n                                    (if (zero? n) d\n                                      (recur (quot n 10) (conj d (mod n 10))))))))))))", "user": "553abb28e4b09218d5f44ffb"}, {"problem": 86, "code": "(fn happy-number\n  ([n]\n    (happy-number n #{}))\n  ([n seen]\n    (let [digits (fn [x] (map #(Integer/valueOf (str %)) (str x)))\n          square (fn [x] (map #(* % %) x))\n          add (fn [x] (reduce + x))\n          sum (-> n digits square add)]\n      (cond\n        (= sum 1) true\n        (seen sum) false\n        :else (recur sum (conj seen sum))))))", "user": "5481be5fe4b0e286459a1172"}, {"problem": 86, "code": "#(case % 2 false 3 false true)", "user": "5507cfd3e4b021ccfedb96ad"}, {"problem": 86, "code": "(fn [n]\n  (loop [seen #{}\n         x n]\n    (cond\n      (= x 1) true\n      (seen x) false\n      :else\n      (recur (conj seen x)\n             (->> x\n                 str\n                 (map #(-> % int (- 48)))\n                 (map #(* % %))\n                 (reduce +))))))", "user": "54dc49d3e4b024c67c0cf780"}, {"problem": 86, "code": "(fn [n]\n  (letfn [(ssd [n]\n               (->> n str (map (comp #(* % %) read-string str)) (apply +)))\n          (happy' [n v]\n                  (let [s (ssd n)]\n                    (cond\n                     (= s 1) true\n                     (contains? v s) false\n                     :else (happy' s (conj v n)))))]\n    (happy' n #{})))", "user": "52ce1abfe4b07d0d72b27389"}, {"problem": 86, "code": "#(loop [n %1, step 0]\n\t(cond\n\t\t(= 1 n) true\n\t\t(> step 100000) false\n\t\t:else (recur (apply + (map (fn [i] (* i i)) (map (fn [c] (- (int c) 48)) (str n)))) (inc step))))", "user": "5370b386e4b0fc7073fd6e9b"}, {"problem": 86, "code": "(letfn [(happy [n seen]\n               (cond\n                (seen n) false\n                (= n 1) true\n                :else (recur (step n) (conj seen n))))\n        (digits [n]\n                (if (zero? n)\n                  []\n                  (conj (digits (quot n 10)) (mod n 10))))\n        (step [n]\n              (reduce + 0 (map #(* % %) (digits n))))]\n  (fn [n] (happy n #{})))", "user": "5553b924e4b0deb715856e06"}, {"problem": 86, "code": "#(loop [x % s #{}]\n   (cond (s x) false\n         (= 1 x) true\n         :else (recur (letfn [(m [y c] (if (= 0 y)\n                                         c\n                                         (m (quot y 10) (+ c (* (mod y 10) (mod y 10))))))]\n                        (m x 0))\n                      (conj s x))))", "user": "543366dde4b0b6b47310fcdf"}, {"problem": 86, "code": "(fn happy?\n  ([n] (happy? [] n))\n  ([seen n]\n   (cond (= 1 n) true\n         (contains? seen n) false\n         :else (recur (conj seen n) (->> n\n                                        (str)\n                                        (map #(- (int %) (int \\0)))\n                                        (map #(* % %))\n                                        (reduce +))))))", "user": "5532a04ee4b09218d5f44f82"}, {"problem": 86, "code": "(fn is-happy [x]\n  (letfn [(step [n]\n            (let [digits-str (seq (str n))\n                  digits (map #(- (int %) (int \\0)) digits-str)\n                  sq-digits (map #(* % %) digits)]\n              (reduce + sq-digits)))]\n    (loop [seen #{}\n           n x]\n      (let [stepn (step n)\n            seen? (contains? seen stepn)]\n        (cond\n          seen? false\n          (= 1 stepn) true\n          :else (recur (conj seen stepn) stepn))))))", "user": "5264383be4b03e8d9a4a70cb"}, {"problem": 86, "code": "(fn [n]\n  (letfn [(h [x]\n             (->> (str x)\n                  (map #(- (int %) (int \\0)))\n                  (map #(* % %))\n                  (reduce +)))\n          (g [x s]\n             (if (and (> x 1) (not (s x)))\n               (recur (h x) (conj s x))\n               (= x 1)))]\n    (g n #{})))", "user": "55495318e4b0a04f79299566"}, {"problem": 86, "code": "(fn happy? \n  ([n] (happy? n #{}))\n  ([n s]\n    (if (= n 1)\n      true\n      (if (s n) \n        false \n        (letfn [(sq [n] (* n n))]\n          (happy? (reduce + (map #(sq (- (int %) 48)) (str n))) (conj s n)))))))", "user": "55536a8ae4b0deb715856e03"}, {"problem": 86, "code": "(fn [n]\n  (letfn [(next-val [decimal]\n                    (->> decimal\n                         str\n                         (map (comp #(* % %) \n                                    read-string \n                                    str))\n                         (apply +)))]\n    (loop [value        n\n           past-values  #{}]\n      (cond \n        (= 1 value) true\n        (contains? past-values value) false\n        :else (recur (next-val value)\n                     (conj past-values value))))))", "user": "5564cad5e4b0c656e3ff180f"}, {"problem": 86, "code": "(fn happy? [n]\n  (if (< n 10) \n   (or (= 1 n) (= 7 n))\n   (->>\n     n\n     ((fn spl [out x] \n        ( if \n          (= x 0) \n          out \n          (spl (conj out (mod x 10)) (quot x 10))))\n        '())\n     (map #(* % %))\n     (reduce +)\n     (happy?)\n)))", "user": "5280a1ece4b0757a1b171407"}, {"problem": 86, "code": "(fn happy-number?\n  [x]\n  (letfn [(digits [x]\n            (reverse\n             (map first\n                  (let [[a [b & _]] (split-with (comp not zero? second)\n                                                (map #(vector (rem % 10) (quot % 10))\n                                                     (iterate #(int (/ % 10)) x)))]\n                    (concat a [b])))))]\n  (true?\n   (some #(= 1 %)\n         (take 1e4 (iterate (fn [n] (reduce + (map #(* % %) (digits n))))\n                            x))))))", "user": "4fcf1755e4b03432b189f40c"}, {"problem": 86, "code": "(fn happy-number\n  ([n] (happy-number n #{}))\n  ([n crumbs]\n   (cond\n     (contains? crumbs n) false\n     (= n 1) true\n     :else\n     (let [digit (fn [c] (let [x (- (int c) 48)] (* x x)))\n           step (reduce + 0 (map digit (seq (str n))))]\n       (happy-number step (conj crumbs n))))))", "user": "504e71cbe4b0f6ff3350c4b3"}, {"problem": 86, "code": "(fn [x]\n  (loop [seen #{}\n         n x]\n    (let [sum-of-digit-squares (->> n str (map #(Character/digit % 10)) (map #(* % %)) (reduce +))]\n      (cond\n        (= 1 sum-of-digit-squares) true\n        (contains? seen sum-of-digit-squares) false\n        :else (recur (conj seen sum-of-digit-squares) sum-of-digit-squares) ))))", "user": "5566463ee4b0c656e3ff1831"}, {"problem": 86, "code": "(fn [num]\n  (loop [seen #{}\n         num num]\n    (cond\n      (seen num) false\n      (= num 1) true\n      :else \n      (recur (conj seen num) (reduce #(+ % (* %2 %2)) 0 (map #(- (int %) 48) (str num)))))))", "user": "5512aca6e4b055c2f668d4b4"}, {"problem": 86, "code": "(fn [n]\r\n  (let [\r\n      digits (fn digits [n]\r\n        (let [\r\n            head (mod n 10)\r\n            tail (int (/ n 10))]\r\n          (if (= 0 tail)\r\n            [head]\r\n            (cons head (digits tail)))))\r\n      sum-digits-sq (fn [n]\r\n        (reduce + (map #(* % %) (digits n))))]\r\n    (loop [n (sum-digits-sq n), depth 10]\r\n      (if (= 1 n)\r\n        true\r\n      (if (= 0 depth)\r\n        false\r\n        (recur (sum-digits-sq n) (dec depth)))))))", "user": "555bd27ae4b0b056612e2244"}, {"problem": 86, "code": "(fn happy\n  [num]\n  (let [x (reduce  #(+ % (* %2 %2)) 0 (map #(Character/digit % 10) (str num)))]\n  (if (= x 1)\n    true\n    (if (= x 4)\n      false\n      (recur x))))\n)", "user": "556be3dce4b09a3098a524f7"}, {"problem": 86, "code": "(fn happy\n  [number]\n    (let [new-number (reduce + (map #(* % %) (map #(Character/digit % 10) (str number))))]\n      (if (= 1 new-number)\n        true\n        (if (= new-number 4)\n          false\n          (recur new-number)))))", "user": "556c94afe4b09a3098a524fe"}, {"problem": 86, "code": "(fn [x]\n   (let [result (reduce + (map * (map #(Character/digit % 10) (str x)) (map #(Character/digit % 10) (str x))))]\n     (if (= result 1)\n       true\n       (if (= (count (str result)) 1)\n         false\n         (recur result)\n        )\n       )))", "user": "556bbaaee4b09a3098a524f0"}, {"problem": 86, "code": "#(letfn[(sqDigit [d]\n                 (let [dVal (- (int d) (int \\0))]\n                   (* dVal dVal)))\n        (nextNumber[x]\n                   (reduce + (map sqDigit (seq (str x)))))]\n   (loop[seen #{}, number %]\n     (cond\n      (seen number) false\n      (= number 1) true\n      :else (recur (conj seen number) (nextNumber number)))))", "user": "556c70dae4b09a3098a524fd"}, {"problem": 86, "code": "(fn happy\n  [num]\n  (let [x (reduce  #(+ % (* %2 %2)) 0 (map #(Character/digit % 10) (str num)))]\n  (if ( = x 1)\n    true\n    (if ( = x 4)\n      false\n      (recur x))))\n)", "user": "556cd549e4b09a3098a52503"}, {"problem": 86, "code": "(fn [num] \n  (letfn [(get-digits [n]\n                    (map #(Integer/parseInt (str %)) (seq (str n))))\n          (sum-sqrs [n]\n                    (reduce + (map #(* % %) (get-digits n))))]\n    (boolean (some #{1} (take 100 (iterate sum-sqrs num))))))", "user": "54ab1b5ae4b09f271ff37cc2"}, {"problem": 86, "code": "(fn [x]\n  ((fn happy [so-far x]\n    (let [ans (apply + (map #(* % %) (map #(- (int %) 48) (seq (str x)))))]\n     (if (= ans 1)\n       true\n       (if (contains? so-far ans)\n         false\n         (happy (conj so-far ans) ans))))) #{} x))", "user": "55625903e4b0c656e3ff17d7"}, {"problem": 86, "code": "(fn __\n  ([n] (__ n #{}))\n  ([n seen]\n   (letfn [(digits [x]\n             (if (< x 10)\n               [x]\n               (conj (digits (quot x 10)) (mod x 10))))]\n     (let [r (apply + (map #(* % %) (digits n)))]\n       (cond\n         (contains? seen r) false\n         (= 1 r) true\n         :else\n         (recur r (conj seen r)))))))", "user": "55702081e4b09a3098a52529"}, {"problem": 86, "code": "(fn happy [n]\n             (letfn [(digits [n]\n                       (loop [m n\n                              r []]\n                         (if (= m 0)\n                           r\n                           (recur (quot m 10) (conj r (rem m 10))))))\n                     (sumsqr [n]\n                       (apply + (map #(* % %) (digits n))))]\n               (loop [m n\n                      seen #{}]\n                 (cond\n                   (= m 1) true\n                   (seen m) false\n                   :else (recur (sumsqr m) (conj seen m))))))", "user": "5283a919e4b0239c8a67adbe"}, {"problem": 86, "code": "(fn [n]\n  (let [ns (atom #{})\n        next-num (fn [n] (->> (map read-string (re-seq #\"\\d\" (str n)))\n      (map #(* %1 %1))\n      (reduce +)))]\n        (loop [nx n]\n          (if (= 1 (next-num nx))\n            true\n            (if (contains? @ns (next-num nx))\n              false\n              (do\n                (swap! ns conj nx)\n                (recur (next-num nx))))))))", "user": "4fc8f671e4b0ee37620e1840"}, {"problem": 86, "code": "(let [s (fn [n]\n          (apply + (map #(* % %) (map #(Character/getNumericValue %) (str n)))))]\n  (fn [n]\n    (loop [n n\n           seen #{}]\n      (if (= n 1)\n        true\n        (if (contains? seen n)\n          false\n          (recur (s n) (conj seen n)))))))", "user": "4f42ae16e4b0d7d3c9f3fd09"}, {"problem": 86, "code": "(fn happy-number? [n]\n  (letfn [(f [x] (reduce + 0 (map #(let [s (Character/digit % 10)] (* s s)) (str x))))] \n    (loop [x n s #{}]\n      (cond \n       (= 1 x) true\n       (contains? s x) false\n       :else (do (println x) (recur (f x) (conj s x)))))))", "user": "55645592e4b0c656e3ff1802"}, {"problem": 86, "code": "(fn happy? [x]\n  (letfn\n      [(digits [n]\n         (loop [res '() n n]\n           (if (zero? n)\n             res\n             (recur (conj res (rem n 10))\n                    (quot n 10)))))]\n    (loop [x x]\n      (let [n (->> (digits x)\n                   (map #(*' % %))\n                   (reduce +'))]\n        (cond (= n 1) true\n              (= n 4) false\n              :else (recur n))))))", "user": "55586905e4b0deb715856e2b"}, {"problem": 86, "code": "(letfn \n  [(digits [x acc]\n           (if (= 0 x) \n             acc \n             (digits (quot x 10) (cons (rem x 10) acc))))\n   \n   (sum-square [x]\n     (apply + (map #(* % %) (digits x '()))))\n   \n   (happy? [n acc]\n           (let [nn (sum-square n)]\n             ; If sum of squared digits = 1, it's happy\n             (if (== nn 1)\n               true\n               ; If not, if sum of squared digits is in accumulated list, we are looping.\n               (if (some #(= nn %) acc)\n                 false\n                 ; If not, add to list and recurse\n                 (recur nn (cons nn acc))))))]\n  \n  (fn [n] (happy? n '())))", "user": "53065acbe4b02e8216869792"}, {"problem": 86, "code": "(fn f\n ([n] (f [] n))\n ([res n] (if (some #(= n %) res)\n            false\n            (if (= n 1)\n              true\n              (let [se (map (comp read-string str) (seq (str n)))\n                    m (reduce #(+ % (* %2 %2)) 0 se)]\n                (f (conj res n) m))))))", "user": "551c66dae4b07993ea3788de"}, {"problem": 86, "code": "(fn [n]\n  (let [n (str n)\n        u #{\"4\", \"16\", \"37\", \"58\", \"89\", \"145\", \"42\", \"20\"}]\n    (loop [n n]\n      (if (= n \"1\")\n        true\n        (if (contains? u n)\n          false\n          (recur (str (apply + (map #(* (read-string %) (read-string %)) (rest (clojure.string/split n #\"\")))))))))))", "user": "54cad59ee4b057c6fda3a26e"}, {"problem": 86, "code": "(letfn [(sqr-digits [n]\n          (apply +\n                 (map #(* % %)\n                      (map #(Integer/valueOf (str %)) (str n)))))]\n  (fn happy? \n    ([n] (happy? n #{}))\n    ([n checked]\n     (let [acc (sqr-digits n)]\n       (cond\n         (= acc 1) true\n         (checked acc) false\n         :else (recur acc (conj checked acc)))))))", "user": "5515b138e4b055c2f668d4ed"}, {"problem": 86, "code": "(fn [x] (loop [curr x prevs '()]\n          (let [n (reduce + (map #(* % %) (map #(Character/getNumericValue %) (seq (.toString curr)))))]\n            (cond\n             (= 1 n) true\n             (some #(= n %) prevs) false\n             :else (recur n (cons curr prevs))))))", "user": "536046a9e4b063bf7a5f8fe1"}, {"problem": 86, "code": "(fn sol [x] (letfn[(digits [x] (if (< x 10) [x] (cons (mod x 10) (lazy-seq (digits (quot x 10))))))]\n                (loop [seen #{} x x] (if (= 1 x) true (if (seen x) false (recur (conj seen x) (reduce + (map #(* % %) (digits x)))))))))", "user": "54857657e4b0e286459a11ac"}, {"problem": 86, "code": "(fn [x] (loop [h (list x)]\n           (let [r (apply + (map #((comp (fn [c] (* c c)) read-string str) %) (str (first h))))]\n             (cond (= 1 r) true\n                   (contains? (set h) r) false\n                   :else (recur (cons r h))))))", "user": "545ddac3e4b01be26fd74676"}, {"problem": 86, "code": "(fn happy? [num]\n  (loop [va (into [] (map #(Character/getNumericValue %) (str num))) d [] done #{num}]\n    (if (false? (empty? va)) (recur (rest va) (conj d (*' (first va) (first va))) done)\n      (if (= (apply + d) 1) true\n        (if (contains? done (apply + d)) false\n          (recur (into [] (map #(Character/getNumericValue %) (str (apply + d)))) [] (conj done (apply + d))))))))", "user": "558378dce4b05c286339e115"}, {"problem": 86, "code": "(fn coba [x]\n  (let [dig (fn explode-to-digits [x]\n              (if (= x 0) []\n                (let [d (rem x 10)\n                      r (quot x 10)]\n                  (conj (explode-to-digits r) d))))]\n    (cond\n      (= 1 (reduce + (map #(* % %) (seq (dig x))))) true\n      (= 4 (reduce + (map #(* % %) (seq (dig x))))) false\n      :else (recur (reduce + (map #(* % %) (seq (dig x))))))))", "user": "52ba2639e4b07a9af57922cb"}, {"problem": 86, "code": "(fn [n]\n  (letfn [(sum-square-parts [n] (->> (str n)\n                                     (map (comp #(* % %) read-string str))\n                                     (apply +)))]\n    (loop [n n hist #{}]\n      (let [s (sum-square-parts n)]\n        (cond\n          (hist n) false\n          (= 1 s) true\n          :else (recur s (conj hist n)))))))", "user": "54074fc5e4b0addc1aec66b6"}, {"problem": 86, "code": "(fn happy-numbers [number]\n  (let [orig-input number]\n    (loop [number number counter 0]\n      (let [p-num (rest (clojure.string/split (str number) #\"\"))]\n        (let [result\n              (reduce + (map #(* % %) (map read-string p-num)))]\n          (cond (= 1 result) true\n                (> counter orig-input) false\n                :otherwise (recur result (inc counter))))))))", "user": "52fc34cee4b047fd55837015"}, {"problem": 86, "code": "(fn [n]\n  (loop [x n known #{}]\n    (let [s (->> (loop [n x res []]\n                   (if (zero? n) res\n                     (recur (quot n 10)\n                            (conj res (rem n 10)))))\n                 (map #(* % %))\n                 (reduce +))]\n      (cond\n        (= 1 s) true\n        (known s) false\n        :else (recur s (conj known s))))))", "user": "52470d42e4b05ef8e38e6350"}, {"problem": 86, "code": "(fn happy [n]\n\n    (let [next-n (fn [n]\n                   (->> n\n                        str\n                        seq\n                        (map #(Integer/parseInt (str %)))\n                        (map #(* % %))\n                        (reduce +)))]\n      (loop [n n\n             history #{}]\n        (if (= n 1)\n          true\n          (if (contains? history n)\n            false\n            (recur (next-n n) (conj history n)))))))", "user": "550c55d0e4b06e50f9beb14d"}, {"problem": 86, "code": "(fn\n  [n]\n  (letfn [(happy-number?\n  [seen? n]\n  (cond\n    (= n 1) true\n    (seen? n) false\n    :else (let [m (reduce (fn [acc x]\n                            (let [y (Integer/valueOf (str x))]\n                              (+ acc (* y y)))) 0 (str n))]\n            (recur (conj seen? n) m))))]\n  (happy-number? #{} n)))", "user": "506f0968e4b09350ab4199f5"}, {"problem": 86, "code": "(fn happy-number?\n  [n]\n  (cond (= n 4) false\n        (= n 1) true\n        :else (happy-number? (apply + (map #(* % %) ((fn digits\n  \t\t\t\t\t\t\t\t\t\t\t\t\t\t[n xs]\n  \t\t\t\t\t\t\t\t\t\t\t\t\t(if (zero? n)\t\n    \t\t\t\t\t\t\t\t\t\t\t\t\txs\n    \t\t\t\t\t\t\t\t\t\t\t\t\t(digits (quot n 10) (cons (rem n 10) xs))))\n                                                     n []))))))", "user": "557e9d17e4b05c286339e0d8"}, {"problem": 86, "code": "(fn [x] \n  (let [f (fn [x] ( loop [a x res []]\n              (if (zero? a)  (apply + (map #(* % %) res))\n              (recur (quot a 10) (conj res (rem a 10))))))]             \n  (loop [a x res []]\n   ( if (contains? res a )  ( = 1 a)        \n         (recur (f a) (conj res (f a)))))))", "user": "55896a0ce4b059ccff29b204"}, {"problem": 86, "code": "(fn [n]\n  (loop [n n, mem #{}]\n    (let [digits (map (comp read-string str) (str n))\n          sum (apply + (map #(* % %) digits))]\n      (or (= sum 1)\n          (if (mem sum) false (recur sum (conj mem sum)))))))", "user": "552a793ee4b0ffed3738f955"}, {"problem": 86, "code": "(letfn [                                                                                                                        \n    (to-sequence [n] (map #(- (int %) 48) (seq (str n))))                                                                                               \n    (new-number [n] (reduce #(+ %1 (* %2 %2)) 0 (to-sequence n)))                                                               \n    (is-happy? [n] (loop [n' n seen #{}]                                                                                                                \n        (cond                                                                                                                   \n            (= n' 1) true                                                                                                                               \n            (get seen n') false                                                                                                 \n            :else (recur (new-number n') (conj seen n')))))]                                                                                            \n                is-happy?)", "user": "558b50d5e4b027778923762b"}, {"problem": 86, "code": "(fn happy-n?\n  ([n] (happy-n? n #{}))\n  ([n seen]\n   (letfn [(n->digits\n            ([n_] (n->digits nil n_))\n            ([ds n_]\n             (if (< 0 n_)\n               (recur (conj ds (rem n_ 10)) (quot n_ 10))\n               ds)))]\n     (let [new-n (reduce #(+ %1 (* %2 %2)) 0 (n->digits n))]\n       (if (= 1 new-n)\n         true\n         (if (contains? seen new-n)\n           false\n           (recur new-n (conj seen new-n))))))))", "user": "540a4f20e4b0addc1aec66ef"}, {"problem": 86, "code": "(fn [n]\n  (loop [n n s #{}]\n    (let [t (reduce + (map #(let [i (- (int %) 48)] (* i i)) (str n)))]\n      (cond\n       (s t) false\n       (= t 1) true\n       :else (recur t (merge s t))))))", "user": "559279b7e4b0604b3f94d58c"}, {"problem": 86, "code": "(let [sum-of-squares (fn fun [n]\n                         (let [digits (map second \n                                           (take-while #(not= [0 0] %) \n                                                       (iterate (fn [[a b]] [(quot a 10) (rem a 10)]) \n                                                                [(quot n 10) (rem n 10)])))\n                               new-num (int (apply + (map #(Math/pow % 2) digits)))]\n                           (cons new-num (lazy-seq (fun new-num)))))\n        happy-number? (fn happy-number? [n] \n                        (if (= 1 (first (drop-while #(not (#{1 4} %)) (sum-of-squares n))))\n                          true\n                          false))]\nhappy-number?)", "user": "54cad2d5e4b057c6fda3a26c"}, {"problem": 86, "code": "(fn [n]\n  (let [nxt (fn nxt [n] \n              (loop [n n rv 0]\n                (if (zero? n)\n                  rv\n                  (recur (quot n 10) (+ rv (* (rem n 10) (rem n 10)))))))]\n    (loop [n n seen #{}]\n      (cond\n       (= n 1) true\n       (seen n) false\n       :else (recur (nxt n) (conj seen n))))))", "user": "55934bebe4b0c79f6e1db93b"}, {"problem": 86, "code": "(fn happy? [n]\n  (letfn [(digits [n]\n            (map #(Integer/parseInt (str %)) (str n)))\n          (sum-of-squares [n]\n            (reduce + (map #(* % %) (digits n))))]\n    (boolean (some #{1} (take 100 (iterate sum-of-squares n))))))", "user": "5537c939e4b09218d5f44fd2"}, {"problem": 86, "code": "(fn checkmy [n] \n\n\t(let [transferDigits (fn [n]\n\n\t\t\t\t\t(->> n str seq (map #(Character/digit % 10)) \n\t\t\t\t   \t\t\t\t(reduce #(+ %1 (* %2 %2) ) 0)\t\n\t\t\t\t\t)\n\t\t\t\t\t)]\t\n\t\t\n\n\n\t(loop [ \n\t\t\tcur n\n\t\t    history #{}\n\t\t     \n\t\t  ]\n\t\t  ;(println history)\n\t\t  ;(println cur)\n\t\t  ;(println (transferDigits cur))\n\t\t  (if (= cur 1) \n\t\t  \t\ttrue\n\t\t  \t\t(if (contains? history cur)\n\t\t  \t\t\tfalse\n\t\t  \t\t\t(recur (transferDigits cur) (clojure.set/union history (hash-set cur )))\n\t\t  \t\t\t)\n\t\t  )\n\n\n\n\n\t\t  \t)\n\n\t\t  \t\n\t\t)\n\t)", "user": "55897fe2e4b059ccff29b205"}, {"problem": 86, "code": "(let [iter (fn i [n]\n               (if (< n 10)\n                   (* n n)\n                   (+ (i (mod n 10)) (i (quot n 10)))))\n      iters (fn [n] (iterate iter n))\n      some-cycle (fn [s]\n                     (some #(when (= (first %) (last %)) (first %))\n                           (map vector (drop 1 s) (mapcat (partial repeat 2) s))))\n                   ]\n                 (comp (partial = 1) some-cycle iters))", "user": "559c13c5e4b066d22e731f61"}, {"problem": 86, "code": "(fn happy? [n]\n  (loop [mem-squares '()\n         new-num n]\n    (let [sq-sum (loop [m new-num\n                        acc 0]\n                   (let [mod-m (mod m 10)]\n                     (if (= m mod-m)\n                       (+ acc (* mod-m mod-m))\n                       (recur (/ (- m mod-m) 10)\n                              (+ acc (* mod-m mod-m))))))]\n      (if (some #(= sq-sum %) mem-squares)\n        false\n        (if (= sq-sum 1)\n          true\n          (recur (conj mem-squares sq-sum)\n                 sq-sum))))))", "user": "559d33b3e4b0ec2b359424d9"}, {"problem": 86, "code": "(fn ishappy? [number]\n  (loop [n number\n         seen #{}]\n    (cond (= n 1) true\n          :else (let [newn (->> n\n                                str\n                                (map #(Integer/parseInt (str %)))\n                                (map #(* % %))\n                                (apply +))]\n                  (if (seen n) false\n                    (recur newn (conj seen n)))))))", "user": "551afdf8e4b07993ea3788cb"}, {"problem": 86, "code": "(fn [x]\n  (loop [n x m #{}]\n      (cond\n        (= 1 n) true\n        (m n) false\n        1 (recur\n               (reduce + (map #(* %1 %1) (map #(Character/getNumericValue %1) (str n))))\n               (conj m n)))))", "user": "5590e55de4b0277789237676"}, {"problem": 86, "code": "(fn happy? \n  ([h] (happy? h #{}))\n  ([h p] (let [digits (fn digits [n] (if (< n 10)\n                                       (list n)\n                                       (let [d (rem n 10)\n                                             r (/ (- n d) 10)]\n                                         (cons d (lazy-seq (digits r))))))\n                 \n               ds (digits h)\n               v (reduce (fn [acc x] (+ (* x x) acc)) 0 ds)]\n           (if (= 1 v)\n             true\n             (if (contains? p h)\n               false\n               (happy? v (conj p h)))))))", "user": "5596a324e4b04c1e5c31d757"}, {"problem": 86, "code": "(fn [m]\n  (= 1 \n     (some #{1 4}\n           (iterate (fn [k] (reduce #(+ % (let [c (- (int %2) 48)] (* c c))) \n                                    0\n                                    (str k))) \n                    m))))", "user": "5504dd64e4b086ebe8a79c83"}, {"problem": 86, "code": "(fn h? [n]\n  (let [digits (fn [m]\n                 (map #(- (int %) 48) (seq (str m))))\n        ss (fn [m]\n             (reduce + (map #(* % %) (digits m))))]\n    (condp = n\n      1 true\n      4 false\n      (h? (ss n)))))", "user": "55995fa7e4b031d6649c9ba9"}, {"problem": 86, "code": "(fn ishappy? [n]\n  (letfn [(split-num [n]  (seq (map #(Integer/parseInt (str %)) (seq (str n)))))\n          (square [n] (* n n))\n          (happy [n]  (apply + (map square  (split-num n))))] \n    (cond \n      (= n 1) true\n      (= n 4) false\n      :otherwise (ishappy? (happy n))      \n    )\n  ))", "user": "5592bf9fe4b0c79f6e1db933"}, {"problem": 86, "code": "(fn [n] (let [next-n (fn [n] (->> n str seq (map #(read-string (str %))) (map #(* % %)) (reduce +)))] (loop [n n history #{}] (if (= n 1) true (if (contains? history n) false (recur (next-n n) (conj history n)))))))", "user": "51bfc1f0e4b0e49ef9037dd4"}, {"problem": 86, "code": "#(if (< % 4) false true)", "user": "5236cd89e4b0e010857b4e45"}, {"problem": 86, "code": "(fn [n]\n  (let [next (fn [x] (reduce + (map #(* % %) (map read-string (re-seq #\"\\d\" (str x))))))]\n    (loop [n n rec #{}]\n      (cond\n       (rec n) false\n       (= 1 n) true\n       :else (recur (next n) (conj rec n))))))", "user": "55a74d46e4b09e57187da2a3"}, {"problem": 86, "code": "(fn happy [dd] \n  (loop [d dd s #{}] \n    (if (= 1 d) \n      true \n      (if (s d) \n        false \n        (recur (loop [n d acc 0] \n                 (if (== n 0) \n                   acc \n                   (recur \n                    (quot n 10) \n                    (+ acc (#(* % %) (mod n 10)))))) \n               (conj s d))))))", "user": "526a3412e4b03e8d9a4a721e"}, {"problem": 86, "code": "(fn [x]\n  (letfn [(derive-num [x]\n            (->> (str x)\n                 (map #(read-string (str %)))\n                 (map #(* % %))\n                 (reduce +)))]\n    (loop [x x, past #{}]\n      (cond (= 1 x) true\n            (past x) false\n            :else (recur\n                   (derive-num x)\n                   (conj past x))))))", "user": "55ac07afe4b03311e7b7328f"}, {"problem": 86, "code": "(fn [hn] (let [f (fn [v] (loop [v1 v r []] (let [d (long (/ v1 10)) m (mod v1 10)]\n  (if (== 0 d) (->> (conj r m) (map #(* % %)) (reduce +) ) ;(conj r m)\n    (recur d (conj r m))\n))))]\n  (loop [vf (f hn)]\n    (cond\n      (= 1 vf) true\n      (> 10 vf) false\n      :else (recur (f vf))\n))))", "user": "55adf4d7e4b03311e7b732af"}, {"problem": 86, "code": "(fn [x]\n  (loop [h ()\n         nbr x]\n    (println nbr)\n    (cond (some (fn [x] (= nbr x)) h) false\n          (= nbr 1) true\n          :else (recur (conj h nbr) (apply + (map #(* % %) (map #(Character/digit % 10) (str nbr)))))\n    )\n  )\n)", "user": "554756b8e4b0a04f79299549"}, {"problem": 86, "code": "(fn [n]\n  (let [ch2int #(- (int %) (int \\0))\n        sqr #(* % %)\n        sqri (fn [x] (reduce + (map #(sqr (ch2int %)) (str x))))]\n    (loop [res []\n           cur n]\n      (if (= 1 cur)\n        true\n        (if (nil? (some #{cur} res))\n          (recur (conj res cur) (sqri cur))\n          false)))))", "user": "55205564e4b08d5046aa8a60"}, {"problem": 86, "code": "(fn happy? [n]\n  (letfn [(digits [n]\n            (map #(Integer/parseInt (str %)) (str n)))\n          (sum-of-squares [n]\n            (reduce + (map #(* % %) (digits n))))]\n    (boolean (some #{1} (take 100 (iterate sum-of-squares n))))))", "user": "537e104ce4b06839e8705e9a"}, {"problem": 86, "code": "(fn [n]\n  (letfn [(sum-sq-digits [x]\n            (reduce + 0 (map #(* % %) (map #(- (int %) (int \\0)) (str x)))))]\n    (loop [k n seen #{}]\n      (cond\n       (= k 1) true\n       (contains? seen k) false\n       :else (recur (sum-sq-digits k) (conj seen k))))))", "user": "5576f299e4b05c286339e077"}, {"problem": 86, "code": "(fn p86 ([num] (p86 num 10))\n  ([num n]\n   (let [square-sum-num (reduce (fn [accum pos]\n                                  (+ accum (apply * (repeat 2 pos)))) 0\n                                (map #(Integer/parseInt (str %)) (str num)))]\n     (if (= 1 square-sum-num)\n       true\n       (if (> n 0)\n         (p86 square-sum-num (dec n))\n         false))\n     )\n\n\n   ))", "user": "5400e918e4b0de5c41848619"}, {"problem": 86, "code": "(fn happy? [n]\n  (let [\n        split-num\n        (fn [n]\n          (loop [n n result '()]\n            (if (= n 0)\n              (if (= 0 (count result)) [0] result)\n              (recur (quot n 10) (cons (mod n 10) result)))))\n\n        get-new-num\n        (fn [n]\n          (reduce + (map #(* % %)\n                         (split-num n))))\n        ]\n  (loop [n n history [n]]\n    (let [newn (get-new-num n)]\n      (if (= newn 1)\n          true\n          (if (some #{newn} history)\n            false\n            (recur newn (conj history newn))))))))", "user": "559b55d6e4b066d22e731f54"}, {"problem": 86, "code": "(fn [num]\n  (let [digit-squared (fn [n]\n                        (reduce #(+ %1 (* %2 %2))\n                          0\n                          (map #(Integer/parseInt (str %))\n                            (.toString n))))]\n    (loop [prev []\n           val (digit-squared num)]\n      (cond\n        (= 1 val) true\n        (some #{val} prev) false\n        :else (recur  (cons val prev)\n                (digit-squared val))))))", "user": "532902f8e4b09d4e7a9b550e"}, {"problem": 86, "code": "(fn [n]\n  (letfn [(sum-squared-digits [n]\n            (->> n\n                 str\n                 (map #(Integer. (str %)))\n                 (map #(* % %))\n                 (apply +)))]\n  (loop [accs #{}\n         i n]\n    (let [nxt (sum-squared-digits i)]\n      (cond\n       (accs nxt) false\n       (= nxt 1) true\n       :else (recur (conj accs i)\n                    nxt))))))", "user": "541709b0e4b01498b1a71a06"}, {"problem": 86, "code": "(letfn [(sumdigits [x] (apply + (map #(Math/pow (- (int %) 48) 2) (vec (str (int x))))))]\n(fn hn[c] (if (= 1 (int (last (take 50 (iterate sumdigits c))))) true false)))", "user": "5576e78de4b05c286339e075"}, {"problem": 86, "code": "(fn [n]\n    (loop [n n seen #{}]\n      (cond (= n 1) true\n            (seen n) false\n            :else (recur (->> (str n)\n                           (map str)\n                           (map #(Long/parseLong %))\n                           (map #(* % %))\n                           (apply +))\n                         (conj seen n)))))", "user": "55aa1637e4b0988bba2ad949"}, {"problem": 86, "code": "(fn [x]\n  (let [happy (->> (str x)\n                   (map #(-> (Character/digit % 10) (Math/pow 2) int))\n                   (reduce +))]\n    (condp = happy\n      1 true\n      4 false\n      (recur happy))))", "user": "555521a5e4b0deb715856e12"}, {"problem": 86, "code": "(fn [x]\n  (letfn [(happy-split [x]\n            (loop [x x\n                   acc []]\n              (if (< x 10)\n                (sort (conj acc x))\n                (recur (quot x 10) (conj acc (mod x 10))))))\n          (happy-sum [x]\n            (reduce + (map #(* % %) x)))]\n    (loop [digits (happy-split x)\n           seen #{}]\n      (cond\n        (seen digits)\n        false\n        (= digits [1])\n        true\n        :else\n        (recur (-> digits happy-sum happy-split) (conj seen digits))))))", "user": "555f3bfde4b0a2eb076a39c1"}, {"problem": 86, "code": "(fn happy? [n]\n  (if-not (pos? n)\n    false\n    (letfn [(step [n]\n                  (->>\n                   n\n                   str\n                   seq\n                   (map (comp #(* % %) #(Character/getNumericValue %))) ;; Clojure's Java interop is sub-par\n                   (apply +)))]\n      (loop [n n\n             known #{}]\n        (cond\n         (known n) false\n         (= 1 n) true\n         :else (recur (step n) (conj known n)))))))", "user": "55aa7c5ce4b0988bba2ad94d"}, {"problem": 86, "code": "(fn [x]\n   (loop [a #{} x x]\n     (or (= 1 x)\n         (if (a x)\n           false (recur (conj a x)\n                        (apply + (map (comp #(* % %) #(- (int %) 48)) (str x)))\n                        )))))", "user": "55be39f9e4b01b9910ae2a06"}, {"problem": 86, "code": "(fn happy?\n  ([n] (happy? n #{}))\n  ([n seen]\n   (letfn [(digits [n]\n             (when (pos? n)\n               (cons (rem n 10)\n                     (digits (quot n 10)))))\n           (dig-sq-sum [n]\n             (reduce + (map (fn [d] (* d d))\n                            (digits n))))]\n     (cond\n      (= 1 n) true\n      (seen n) false\n      :else (happy? (dig-sq-sum n) (conj seen n))))))", "user": "55c4e48be4b0e31453f649a7"}, {"problem": 86, "code": "(fn [n]\n  (letfn [(my-sq [x] (apply + (map #(let [x (- (int %) (int \\0))] (* x x)) (str x))))]\n    (if (some #(= 1 %) (take 100 (iterate my-sq n))) true false)))", "user": "55b107fee4b002ce9d5cbc2a"}, {"problem": 86, "code": "(fn [x]\n  (loop [seen (if (< x 10) #{x} #{}) cur x]\n    (let [num (->> (map str (seq (str cur))) \n                   (map read-string) \n                   (map #(* % %)) \n                   (apply +))]\n      (cond\n        (= 1 num) true\n        (seen num) false\n        :else (recur (conj seen num) num)))))", "user": "55b8c339e4b01b9910ae29b9"}, {"problem": 86, "code": "(fn [n]\n  (loop [x n s #{}]\n    (let [y (reduce + (map #(let [x (Long/parseLong (str %))] (* x x)) (str x)))]\n      (if (= y 1) true\n        (if (contains? s y) false\n        (recur y (conj s y)))))))", "user": "522eb5cce4b01cdb292c5f0c"}, {"problem": 86, "code": "(fn happy-numbers\n  [x]\n  (let [max-try 1000]\n    (letfn [(square [x] (* x x))\n            (split-int [x] (map #(Integer/parseInt (str %)) (str x)))\n            (sum-square [numbers] (apply + (map square numbers)))\n            (happy? [numbers] (= 1 (sum-square numbers)))]\n      (loop [numbers x tried 0]\n        (if (> tried max-try)\n          false\n          (let [numbers (split-int numbers)]\n            (if (happy? numbers)\n              true\n              (recur (sum-square numbers) (inc tried)))))))))", "user": "5369d072e4b0243289761ea1"}, {"problem": 86, "code": "(fn happy? [n] (letfn [(square [n] (* n n))\n                         (split-num [n] (map #(- (int %) 48) (str n)))\n                         (happify [n] (reduce + (map square (split-num n))))]\n                   (loop [seen #{}, num n] (cond (= num 1) true\n                                                 (contains? seen num) false\n                                                 :else (recur (conj seen num) (happify num))))))", "user": "55c10409e4b01b9910ae2a2c"}, {"problem": 86, "code": "(fn is-happy? [n]\n   (letfn [(square-and-sum [n]\n             (let [digits (map #(read-string (str %)) (seq (str n)))]\n               (reduce + (map #(* % %) digits))))\n           (iter [n seen]\n             (cond\n               (= n 1) true\n               (some #{n} seen) false\n               :else (iter (square-and-sum n) (conj seen n))))]\n     (iter n [])))", "user": "54b817eee4b0ed20f4ff6e93"}, {"problem": 86, "code": "(fn [num]\n  (loop [n num seen? #{}]\n    (let [sum (apply + (map (comp #(* % %) #(- (int %) (int \\0))) (str n)))]\n      (cond\n        (= sum 1) true\n        (seen? sum) false\n        :else (recur sum (conj seen? sum))))))", "user": "4e6a4950535d8ccf87e9febf"}, {"problem": 86, "code": "(fn happy? [n]\n  (letfn [(step [x]\n            (->> x\n              (str)\n              (re-seq #\"\\d\")\n              (map #(java.lang.Integer/parseInt %))\n              (map #(* % %))\n              (reduce +)))\n          (generate [x xs]\n            (cond \n              (= x 1) (conj xs x)\n              (contains? xs x) (conj xs x)\n              :else (generate (step x) (conj xs x))))]\n    (= 1 (last (generate n [])))))", "user": "559454f2e4b0c79f6e1db952"}, {"problem": 86, "code": "(fn happy? [n]\n  (let [nums (atom [])]\n    (loop [n n]\n      (let [digits (map #(- (int %) 48) (str n))\n            sum (reduce + (map #(* % %) digits))]\n        (cond\n          (= sum 1) true\n          (some #{sum} @nums) false\n          :else (do (swap! nums conj sum)\n                  (recur sum)))))))", "user": "54f4adc8e4b0f2f3c5226e86"}, {"problem": 86, "code": "(fn [x]\n  (let [y (->> x str (map (comp #(* % %) read-string str)) (apply +))]\n    (cond\n      (= y 1) true\n      (= y 42) false\n      :else (recur y))))", "user": "5416b4a2e4b01498b1a71a01"}, {"problem": 86, "code": "(fn [n]\n   (loop [visited #{}\n          next n]\n     (let [digits (map read-string (map str (str next)))\n           squared-sum (apply + (map #(int (Math/pow % 2)) digits))]\n       (if (= 1 squared-sum)\n         true\n         (if (visited squared-sum)\n           false\n           (recur (conj visited squared-sum) squared-sum)))\n       )))", "user": "55895eade4b059ccff29b202"}, {"problem": 86, "code": "(fn happy?\n  ([n] (happy? n []))\n  ([n acc]\n    (cond\n      (= 1 n) true\n      (contains? acc n) false\n      :else (happy?\n        (->> n\n          str seq (map #(Integer. (str %)))\n          (map #(* % %)) (reduce +))\n        (conj acc n)))))", "user": "55d5e80ee4b0e31453f64a91"}, {"problem": 86, "code": "(fn happy? [n]\n   (letfn [(calc-next [n]\n                      (reduce + (map #(* (Long. (str %)) (Long. (str %))) (set (str n)))))]\n\n     (loop [x (calc-next n)\n            ret #{n}]\n       (if (contains? ret x)\n         (= 1 x)\n         (recur (calc-next x) (conj ret x))))))", "user": "55a372f1e4b0acc240e31537"}, {"problem": 86, "code": ";without loop/recur\n(fn [n]\n  (let [c2n   #(Character/digit % 10)\n        step  #(->> (map c2n (str %))\n                    (reduce (fn [s x] (+ s (* x x))) 0) )\n\t\tsets  (reductions conj #{} (iterate step n))\n        cset  (->> (map list sets (rest sets))\n\t               (drop-while (partial apply not=))\n\t\t           ffirst ) ]\n      (contains? cset 1) ))\n\n;straightforward using loop/recur\n;(fn [n]\n;  (letfn [(step [n] (->> (str n)\n;                         (map #(Character/digit % 10))\n;                         (reduce (fn [s x] (+ s (* x x))) 0) ))]\n;    (loop [s #{} n n]\n;      (or (= 1 n) \n;\t      (and (not (contains? s n))\n;\t           (recur (conj s n) (step n)))))))", "user": "55cdc576e4b0e31453f64a1f"}, {"problem": 86, "code": "(letfn [(moodswing [n]\r\n          (reduce #(+ %1 (* %2 %2)) 0\r\n                  (map {\\0 0, \\1 1, \\2 2, \\3 3, \\4 4,\r\n                        \\5 5, \\6 6, \\7 7, \\8 8, \\9 9}\r\n                       (str n))))\r\n\r\n        (happy?\r\n          ([n] (happy? n #{}))\r\n          ([n seen?]\r\n           (cond (seen? n) false\r\n                 (= 1 n)   true\r\n                 :else     (recur (moodswing n) (conj seen? n)))))]\r\n  happy?)", "user": "55d0e76ae4b0e31453f64a40"}, {"problem": 86, "code": "(fn [n]\n  (letfn [(square [x] (* x x))\n          (digits [x]\n            (lazy-seq\n             (when (pos? x)\n               (cons (mod x 10) (digits (quot x 10))))))]\n    (loop [x n, visited #{}]\n      (cond\n       (= 1 x) true\n       (visited x) false\n       :else (recur (apply + (map square (digits x)))\n                    (conj visited x))))))", "user": "51d19c24e4b0cfcf579466c3"}, {"problem": 86, "code": "(fn hn [n]\n  (letfn [(get-digits [n] (map #(Integer/parseInt (str %)) (str n)))\n          (sum-squares [n] (reduce + (map #(* % %) (get-digits n))))]\n    (loop [s n sq #{}]\n      (cond \n       \t(= s 1) true\n       \t(contains? sq s) false\n       \t:else (recur (sum-squares s) (conj sq s))))))", "user": "55c0afa5e4b01b9910ae2a27"}, {"problem": 86, "code": "(fn [n]\n  (loop [n n, old-ns #{}]\n    (cond\n      (= n 1) true\n      (old-ns n) false\n      :else (recur (reduce +\n                           (map #(let [digit (- (int %) 48)]\n                                  (* digit digit))\n                                (str n)))\n                   (conj old-ns n)))))", "user": "5339c105e4b0e30313ee6cae"}, {"problem": 86, "code": "(fn [n]\n  (loop [n (-> n str seq)\n         cnt 0]\n    (let [parse #(Integer/parseInt (str %))\n          m (map #(* (parse %)\n                     (parse %)) n)\n          sum (->> m (map parse) (apply +))]\n      (cond\n        (= sum 1) true\n        (> cnt 1000) false\n        :else (recur (str sum) (inc cnt))))))", "user": "549c6792e4b0f3d1d8e70f8b"}, {"problem": 86, "code": "(fn is-happy?\n  ([num]\n   (is-happy? num 1000))\n  ([num c]\n   (let [snum (str num)]\n     (if (= \"1\" snum)\n       true\n       (if (= c 0)\n         false\n         (is-happy? (reduce + (map #(let [x (Long/valueOf (str %) 10)]\n                                      (* x x)) snum)) (dec c)))))))", "user": "55b22c33e4b0da326a65cf79"}, {"problem": 86, "code": "(fn [x]\n  (letfn [(next-val [n] (reduce + (map #(* % %) (map #(- (int %) (int \\0)) (seq (str n))))))]\n    (loop [v x vs #{}]\n      (cond (= v 1) true\n            (contains? vs v) false\n            :else (recur (next-val v) (conj vs v))))))", "user": "55c20bd0e4b0e31453f64972"}, {"problem": 86, "code": "(fn happy-number?\n  ([x] (happy-number? x []))\n  ([x init]\n  (letfn [(pow-of-two [x] (reduce * [x x]))\n          (to-int [c] (- (int c) (int \\0)))\n          (pow-and-sum \n            [digits] \n             (reduce + \n                (map (comp pow-of-two to-int) digits)))]\n    (let [curr (pow-and-sum (str x))]\n      (if-let [happy (= 1 curr)]\n        happy\n        (if (and ((comp not nil?) (last init)) (> curr (pow-of-two (last init))))\n          false\n          (recur (pow-and-sum (str curr)) (conj init curr))))))))", "user": "5553b729e4b0deb715856e05"}, {"problem": 86, "code": "(letfn [(str-int-pow [n] (-> n (str) (Integer/parseInt) (#(* % %))))\n        (dig-sqr-sum [n] (reduce + (map str-int-pow (seq (str n)))))]\n  (fn happy? ([n] (happy? n #{n}))\n    ([n s] (let [dss (dig-sqr-sum n)]\n           (cond\n            (= 1 dss) true\n            (contains? s dss) false\n            :else (recur dss (conj s dss)))))))", "user": "55dcb06ee4b050e68259b3b9"}, {"problem": 86, "code": "(fn [n]\n  (let [sum-sq (fn [num]\n                 (->> (str num)\n                      (map (comp #(* % %) read-string str))\n                      (reduce +)))\n        result (some #{1 4} (iterate sum-sq n))]\n     (= 1 result)))", "user": "554b8572e4b0a04f79299589"}, {"problem": 86, "code": "(fn happy\n    ([n] (happy n #{}))\n    ([n seen]\n     (let [digits (map #(Character/getNumericValue %) (str n))\n           square #(* % %)\n           new-num (apply + (map square digits))]\n       (cond\n         (= new-num 1) true\n         (get seen new-num) false\n         :else (recur new-num (conj seen new-num))))))", "user": "5317d78ee4b08068f379ed63"}, {"problem": 86, "code": "(fn h ([n s]\n       (if (contains? s n)\n         false\n         (let [a (map #(Character/digit % 10) (str n))\n               b (apply + (map #(* % %) a))]\n           (if (= b 1) true (h b (conj s n))))))\n       ([n] (h n #{})))", "user": "54864662e4b0e286459a11b8"}, {"problem": 86, "code": "(fn [sads x] (let [new (reduce #(+ % (* (Integer/parseInt %2) (Integer/parseInt %2))) 0 (re-seq #\"\\d\" (str x)))]\n               (cond\n                (sads new) false\n                (= 1 new) true\n                :else (recur (conj sads new) new)))) #{}", "user": "55ccdc6be4b0e31453f64a18"}, {"problem": 86, "code": "(fn [ n ] (= true (some #(= % 1) (take 10 (iterate  (fn [m ] (apply + ((fn squire-sum [ x ] ( if (> x 0 ) (cons ( * (mod x 10 ) ( mod x 10) ) (squire-sum (quot x 10 ) ) ) ) )  m) ) )  n )  ) )) )", "user": "55d44dd6e4b0e31453f64a75"}, {"problem": 86, "code": "(fn happy                                                                                                        \n  ([n] (happy n []))                                                                                                \n  ([n seen]                                                                                                         \n   (let [calc (reduce + (map (comp #(* % %) #(Integer/parseInt %) str) (str n)))]                                   \n     (if (= 1 calc)                                                                                                 \n       true                                                                                                         \n       (if (contains? seen calc)                                                                                    \n         false                                                                                                      \n         (happy calc (into [] (cons n seen))))))))", "user": "549dfe40e4b0f3d1d8e70f9a"}, {"problem": 86, "code": "(fn happy?\n    [x]\n    (letfn [(digits [x] (map #(Character/getNumericValue %1) (str x)))\n            (sum-squared [ds] (reduce + (map #(* %1 %1) ds)))\n            (process-num [x] \n                         (loop [seen #{}\n                                x x]\n                           (let [value ((comp sum-squared digits) x)]\n                             (cond\n                               (= 1 value) true\n                               (seen value) false\n                               :else (recur (conj seen value) value)))))]\n      (process-num x)))", "user": "539e717fe4b0ca733b974488"}, {"problem": 86, "code": "(fn [t]\n  (letfn [(to-digit-list [x]\n                         (print x)\n                         (for [y (str x)] (- (int y) (int \\0))))\n          (sum-of-squar [l]\n                        (print l)\n                        (apply + (map #(* % %) l)))]\n    (loop [t t ret #{}]\n      (let [cur (sum-of-squar (to-digit-list t))]\n        (cond\n         (contains? ret cur) false\n         (= 1 cur) true\n         :else (recur cur (conj ret cur)))))))", "user": "55d74e71e4b0e31453f64aa4"}, {"problem": 86, "code": "(let [sosod (fn [n] (->> n (str) (map #(- (int %) 48)) (map #(* % %)) (reduce + 0)))\n      first-dup (fn recur [seen [x & xs]] (if (seen x) x (recur (conj seen x) xs)))]\n  #(= 1 (first-dup #{} (iterate sosod %))))", "user": "4f5eda39e4b0030a34fb2b56"}, {"problem": 86, "code": "(fn [n]\n  (let [s #(* % %)\n        i #(s (- (int %) 48))\n        f #(->> % str (map i) (apply +))]\n    (loop [x n a #{}]\n      (cond\n        (= x 1) true\n        (contains? a x) false\n        :else (recur (f x) (conj a x))))))", "user": "4faf97d8e4b081705acca258"}, {"problem": 86, "code": "(fn [n]\n  (loop [n n seen #{}]\n    (let [to-digit (fn [n] (- (int n) 48))\n          digits (map to-digit (str n))\n          square (fn [n] (* n n))\n          sum-squares (reduce + (map square digits))]\n      (cond\n        (= 1 sum-squares)  true\n        (seen sum-squares) false\n        :else              (recur sum-squares (conj seen sum-squares))))))", "user": "55ecb2c0e4b0121d4835fdce"}, {"problem": 86, "code": "(let [limit 100\n      square (fn [x] (* x x))\n      sum (partial apply +)\n      split (comp (partial map (comp read-string str)) str)]\n  (fn [n*]\n    (loop [i limit n n*]\n      (let [n' (sum (map square (split n)))]\n        (if (= 1 n')\n          true\n          (if (pos? i)\n            (recur (dec i) n')\n            false))))))", "user": "5363d242e4b0243289761e5c"}, {"problem": 86, "code": "(fn prob86\n  ([num] (prob86 num #{}))\n  ([num seen]\n   (letfn [(nextnum [num]\n             (reduce + (map #( * % %) (digit-list num))))\n           \n           (digit-list [num]\n             (map char-to-num (str num)))\n           \n           (char-to-num [c]\n             (- (int c) 48))\n           ]\n     (if (= 1 num) true\n         (if (contains? seen num) false\n             (prob86 (nextnum num) (conj seen num)))))))", "user": "4ebbff41535dfed6da9c6d78"}, {"problem": 86, "code": "(fn [x]\n  (loop [current x count 100]\n    (if (= current 1)\n      true\n      (if (= count 0)\n        false\n        (recur\n          (apply + (map #(* % %) (map #(Integer/parseInt %) (filter #(not (empty? %)) (clojure.string/split (str current) #\"\")))))\n          (dec count)\n        )\n      )\n    )\n  )\n)", "user": "55d79b87e4b0e31453f64aa8"}, {"problem": 86, "code": "(fn happy? ([thenum] (happy? thenum #{}))\n([thenum sofar] (if (= thenum 1) true (if (contains? sofar thenum) false \n(let [result (reduce + (for [x (range 0 thenum) \n:let [y (apply * (repeat x 10)) dig (quot (mod thenum (* 10 y)) y)] :while (> (inc thenum) y)] (* dig dig)))]\n(happy? result (conj sofar thenum)))))))", "user": "55f75c6be4b06e875b46cea9"}, {"problem": 86, "code": "(fn [n]\n  (loop [counter 0\n         n n]\n    (if (> counter 100)\n      false\n      (if (= n 1)\n        true \n        (recur (inc counter)\n               (let [s (map #(read-string (str %)) (str n))]\n                 (reduce #(+ %1 (* %2 %2)) 0 s)))))))", "user": "53d64811e4b0e771c3025456"}, {"problem": 86, "code": "(fn happy? [x] \n  (let [todigit (fn [n] (map (comp #(- % 48) int) (seq(str n))))]\n    (let [n (apply + (map #(* % %) (todigit x)))]\n      (if (= n 1) \n        true\n        (if ( = 1 (count (todigit n)))\n          false\n          (happy? n))))))", "user": "55e06f82e4b050e68259b40d"}, {"problem": 86, "code": "(fn __\n  [number]\n  (letfn [(next-number [n]\n            (->> n \n              str \n              (map str) \n              (map #(java.lang.Long/parseLong %))\n              (map #(* % %)) \n              (reduce +)))]\n    (loop [n number]\n      (let [next-n (next-number n)]\n\t      (case next-n\n\t        4 false\n\t        1 true\n\t        (recur next-n))))))", "user": "55a62092e4b0acc240e31554"}, {"problem": 86, "code": "(letfn [(digits [n]\n          (if (< n 10)\n            [n]\n            (let [r (rem n 10)]\n              (cons r (digits (/ (- n r) 10))))))\n        (happy?\n         ([n]\n          (happy? n #{}))\n         ([n visited]\n          (cond\n           (= 1 n) true\n           (contains? visited n) false\n           :else (happy? (->> n\n                              digits\n                              (map #(* % %))\n                              (apply +))\n                         (conj visited n)))))]\n  happy?)", "user": "55f2e47de4b06e875b46ce4d"}, {"problem": 86, "code": "(fn [n]\n  (let [sods (fn [n]\n               ; sum of the digits of n squared\n               (loop [n n r 0]\n                 (if (zero? n)\n                   r\n                   (let [d (rem n 10)]\n                     (recur (quot n 10) (+ r (* d d)))))))]\n    (loop [n n seen #{}]\n      (cond (seen n) false\n            (= n  1) true\n            :default (recur (sods n) (conj seen n))))))", "user": "53576356e4b04ce2eb3ed27a"}, {"problem": 86, "code": "(fn happy?\n  ([x] (happy? #{} x))\n  ([r x]\n   (letfn [(digits [x] (map #(Character/digit % 10) (str x)))\n           (sumsquaredigits [x] (reduce #(+ % (* %2 %2)) 0 (digits x)))]\n     (cond\n       (= x 1) true\n       (r x) false\n       :else (recur (conj r x) (sumsquaredigits x))\n       ))))", "user": "55e7d06ee4b050e68259b496"}, {"problem": 86, "code": "(fn[n](loop [iter 1 acc n]\n          (if (= acc 1) true\n            (if (= acc 4) false\n            \n\t            (recur (inc iter) \n\t                  ( reduce + (map (fn[k](* k k))  (map (fn[c](- (int c) 48)) (seq (str acc))) )  )\n\t            )\n            )\n          )\n        )\n   )", "user": "56039843e4b04bb52996e1be"}, {"problem": 86, "code": "(fn [h] (\n  (fn [x xs] \n\t(let [newx ((fn [n acc] (if (= n 0) acc (recur (long (/ n 10)) (+ (#(* %1 %1) (rem n 10)) acc)))) x 0)]\n\t(println newx)\n\t(if (= newx 1)\n\t\ttrue\n\t\t(if (some #{newx} xs) false\n\t\t(recur newx (cons x xs)))))) h []))", "user": "4f6ba7bce4b07046d9f4efb0"}, {"problem": 86, "code": "(fn [num]\n  (loop [result [] \n         square-num (reduce #(+ (* %2 %2) %) 0 (map #(- (int %) 48) (str num)))]\n    (if (= 1 square-num)\n      true\n      (if (.contains result square-num)\n        false ;;\u8fdb\u5165\u4e86\u6b7b\u5faa\u73af\n        (if (>= (count result) 100000)\n          false ;;\u8fed\u4ee3100000\u540e\u5f53\u4f5cfalse\u5904\u7406\n          (recur (conj result square-num) \n                 (reduce #(+ (* %2 %2) %) 0 (map #(- (int %) 48) (str square-num)))))))))", "user": "55a0d79fe4b0acc240e31502"}, {"problem": 86, "code": "(fn happy-num? [n]\n    (letfn [(sum-of-sqare-of-digits [number]\n                          (reduce + (map (fn [c]\n                                           (let [digit (- (int c) (int \\0))]\n                                             (* digit digit)))\n                                         (str number))))]\n      (loop [curr n results #{}]\n        (cond\n          (= 1 curr) true\n          (results curr) false\n          :else (recur (sum-of-sqare-of-digits curr) (conj results curr)))\n        )\n      ))", "user": "55e6c3f5e4b050e68259b48c"}, {"problem": 86, "code": "(fn [number]\n  (loop [test-number number, idx 10]\n    (if (zero? idx)\n      false\n      (if (= 1 test-number)\n        true\n        (recur (apply + (map #(* % %) (map read-string (re-seq #\"\\d\" (str test-number))\n                                           )\n                             )\n                      )\n               (dec idx)\n               )\n        )\n      )\n    )\n  )", "user": "55fe7e15e4b00f4cabc57651"}, {"problem": 86, "code": "(fn [n]\n    (loop [seen #{}\n           x n]\n      (cond\n        (seen x) false\n        (= x 1) true\n        :else (->> (str x)\n                   (re-seq #\"\\d\")\n                   (map #(Integer. %))\n                   (map #(* % %))\n                   (reduce + 0)\n                   (recur (conj seen x))))))", "user": "560e9a2de4b05f002753df52"}, {"problem": 86, "code": "(fn [n]\n   (loop [k n sums ()]\n     (let [sum-of-squares (reduce + (map #(let [d (Integer/parseInt (str %))] (* d d)) (str k)))]\n       (cond \n         (= 1 sum-of-squares) true\n         (some #{sum-of-squares} sums) false\n         :else (recur sum-of-squares (cons sum-of-squares sums))))))", "user": "55f8b32ae4b03cbcff9738ba"}, {"problem": 86, "code": "#(let [sqr (fn [n] (* n n))\n       res (->> %2\n                str\n                (map (comp sqr (fn [s] (Integer/parseInt s)) str))\n                (apply +))]\n   (if (= res 1)\n     true\n     (if (some #{res} %1)\n       false\n       (recur (conj %1 res) res)))) #{}", "user": "532ecd44e4b019098a6f8b49"}, {"problem": 86, "code": "(fn happy-num\n  ([nmbr] (happy-num nmbr #{}))\n  ([nmbr st]\n   (let [square #(* % %),\n         digits #(map (fn [n] (- (int n) 48)) (into [] (str %))),\n         sum-sqrd (apply +' (map square (digits nmbr)))]\n     (if (contains? st sum-sqrd)\n       false\n       (if (= sum-sqrd 1)\n         true\n         (happy-num sum-sqrd (conj st sum-sqrd)))))))", "user": "5545477fe4b0a04f79299531"}, {"problem": 86, "code": "(fn  [num]\n    (let [num-sums ((fn [n]\n                      (iterate\n                       (fn [x]\n                         (->> (str x)\n                              (map #(Character/digit % 10))\n                              (map #(Math/pow % 2))\n                              (reduce +)\n                              int))\n                       n))\n                    num)]\n         (loop [[n & ns] num-sums found #{}]\n           (cond\n            (= n 1) true\n            (contains? found n) false\n            :default (recur ns (conj found n))))))", "user": "527ccaf4e4b0757a1b17136d"}, {"problem": 86, "code": "(fn [n]\t\n  (let [get_dl (fn md [m]\n                 (if (= m 0)\n                   nil\n                   (cons (* (mod m 10) (mod m 10)) (md (int (/ m 10))))))]\n    (loop [cn n\n           csl #{}]\n      (let [ch (apply + (get_dl cn))]\n        (if (= ch 1)\n          true\n          (if (csl ch)\n            false \n            (recur ch (conj csl ch))))))))", "user": "56051095e4b08b23635d3162"}, {"problem": 86, "code": "(fn [n]\n  (loop [n n s #{}]\n    (cond\n     (= n 1) true\n     (s n) false\n     :else (recur (reduce + (map (comp #(* % %) read-string str) (str n))) (conj s n)))))", "user": "548b8a50e4b0e286459a11ff"}, {"problem": 86, "code": "(fn [n]\n  (letfn [(sum [n] (apply + (map #(* (Character/getNumericValue %)\n                                     (Character/getNumericValue %))\n                                 (str n))))\n          (repeats? [s] (not= (count (distinct s)) (count s)))]\n         (= 1 (last (first (filter repeats?\n                                   (rest (reductions conj [] (iterate sum n)))))))))", "user": "55f20e4be4b06e875b46ce40"}, {"problem": 86, "code": "(letfn [(formula [x]\n          (->> (str x)\n               (map #(- (int %) (int \\0)))\n               (map #(* % %))\n               (apply +)))]\n  (fn happy?\n    ([n] (happy? n (formula n) #{}))\n    ([n x seen]\n     (cond\n       (seen x) false\n       (= x 1) true\n       :else (recur n (formula x) (conj seen x))))))", "user": "561ca2eae4b064ca9f4b169b"}, {"problem": 86, "code": "(fn happy? [n]\n    (loop [seen #{}\n           i n]\n      (cond \n        (= 1 i) true\n        (seen i) false\n        true  (let [digits (map #(Character/digit % 10) (str i))]\n                  (recur(conj seen i)  (reduce #(+ %1 (* %2 %2)) 0 digits))\n                  )\n        )\n      )\n    )", "user": "55f2c898e4b06e875b46ce4b"}, {"problem": 86, "code": "(fn happy [n]\n  (loop [v n\n         nrs #{}]\n        (let [digits (map #(- (int %)(int \\0)) (str v))\n              squares (map #(* % %) digits)\n              nv (reduce + squares)]\n      (println nv)    (cond (= 1 nv) true\n                (contains? nrs nv) false\n                :else (recur nv (conj nrs nv))))))", "user": "56011393e4b04bb52996e178"}, {"problem": 86, "code": "(fn [x]\n   (letfn [(k [n] (* n n))\n           (s [n] (loop [r 0 c n]\n                    (if (> 10 c)\n                      (+ r (k c))\n                      (recur (+ r (k (mod c 10))) (quot c 10)))))]\n     (loop [c #{} i x]\n       (let [r (s i)]\n         (if (= 1 r)\n           true\n           (if (c r)\n             false\n             (recur (into c [r]) r)))))))", "user": "55b1e9e7e4b0da326a65cf74"}, {"problem": 86, "code": "(fn foo [n]\n  (letfn [(digits [x] (map #(Integer/parseInt (str %)) (str x)))\n          (square [x] (* x x))]\n    (let [rv (->> n digits (map square) (reduce +))]\n      (cond\n        (= rv 1) true\n        (= rv 37) false ; magic number\n        :else (recur rv)))))", "user": "561ba3e5e4b073c65b0ce3eb"}, {"problem": 86, "code": "(fn [n]\n  (loop [a n v #{}]\n   (cond \n      (= 1 a) true\n      (contains? v a) false\n      :else (recur (reduce + (map #(* % %) (map #(- (int %) (int \\0))(str a)))) (conj v a))\n     )\n  )\n)", "user": "55eeb37ae4b0121d4835fdf3"}, {"problem": 86, "code": "(fn [n]\n  (let [\n  \tto-digits  #(seq (str %))\n\tto-ints (fn [xs] (map #(Integer/parseInt %) (map str xs)))\n\tsquare (fn [x] (* x x))\n\tsquares #(map square %)\n\thappy-sum #(reduce + 0 (squares (to-ints (to-digits %))))\n\thappy? (fn rec [xs iter] \n             (if (< iter 1) \n               false \n               (let [s (happy-sum xs)] (if (= s 1) \n                                         true \n                                         (rec s (dec iter))))))\n  ]\n  (happy? n 100))\n)", "user": "560c31b4e4b05f002753df2d"}, {"problem": 86, "code": "(fn [num]\n    (letfn [(do-sum-squares [x]\n              (reduce #(+ %1 (* %2 %2)) 0 (map #(- (int %) (int \\0)) (str x))))]\n      (loop [n num\n             seen #{}]\n        (cond (= 1 n) true\n              (seen n) false\n              :else (recur (do-sum-squares n) (conj seen n)))\n        )\n      )\n    )", "user": "4f5e5975e4b0030a34fb2b4d"}, {"problem": 86, "code": "(fn happy?\n  ([n] (happy? n #{}))\n  ([n seen]\n   (cond\n     (seen n) false\n     (= n 1) true\n     :else (recur (apply + (for [x (map #(- % (int \\0)) (map int (seq(str n))))]\n                            (* x x))) (conj seen n)))))", "user": "561ca6ebe4b064ca9f4b169c"}, {"problem": 86, "code": "(fn [n]\n     (letfn [(digits [x] (map #(Character/digit % 10) (str x)))\n\t     (next-iter [x] (apply + (map #(* % %) (digits x))))]\n\t    (loop [tried #{} x n]\n\t\t  (cond (contains? tried x) false\n\t\t\t(= x 1) true\n\t\t\t:else (recur (conj tried x) (next-iter x))))\n)\n     )", "user": "55f09e7be4b06e875b46ce28"}, {"problem": 86, "code": "(fn [x]\n  (let [maxdepth 1000\n        f (fn [x]\n            (->> (map #(Character/digit % 10) (str x))\n                 (map #(* % %))\n                 (reduce +)))\n        res (last (take maxdepth (iterate f x)))]\n    (= 1 res)))", "user": "5573ffb5e4b0aa18f790f3fd"}, {"problem": 86, "code": "(fn happy-number?\n  [n]\n  (letfn [(happy\n            [n n-seen]\n            (if (or (= 1 n) (n-seen n))\n              n\n              (let [n' (reduce + (map (comp #(* % %) #(Integer/parseInt %)) (map str (str n))))]\n                (happy n' (conj n-seen n)))))]\n    (if (= 1 (happy n #{})) true false)))", "user": "55a9e0fee4b0988bba2ad945"}, {"problem": 86, "code": "(fn [n]\n  (= 1 (nth (iterate (fn [x]\n                          (->>\n                            (map #(. Integer parseInt (str %1)) (str x))\n                            (map (fn [y] (* y y)))\n                            (reduce +)\n                            )\n                          ) n) 100))\n     )", "user": "55aa5f73e4b0988bba2ad94b"}, {"problem": 86, "code": "(fn happy[n]\n  (letfn [(happify[n]\n                  (apply + (map #(* % %) (map #(Integer/parseInt %) (rest (clojure.string/split (str n) #\"\"))))))]\n    (loop [n n, s #{}]\n      (cond\n        (= 1 n) true\n        (contains? s n) false\n        :else (recur (happify n) (conj s n))))))", "user": "5626447fe4b00e49c7cb47bd"}, {"problem": 86, "code": "(fn happy? [n]\n  (letfn [(to-digits [n]\n            (map #(- (int %) (int \\0)) (seq (str n))))\n          (square-sum [v]\n            (reduce + (map #(* % %) v)))]\n    (loop [x n, s #{}]\n      (cond (= 1 x) true\n            (contains? s x) false\n            :else (recur (square-sum (to-digits x)) (conj s x))))))", "user": "561d23e3e4b064ca9f4b16a5"}, {"problem": 86, "code": "(fn is-happy? [n]\n    (letfn [(square [x] (* x x))\n            (explode [i] (map #(Character/getNumericValue %) (str i)))\n            (happy [y] (apply + (map square (explode y)) ))]\n      (cond (= 1 (happy n)) true\n            (= 4 (happy n)) false\n            :else (is-happy? (happy n)))))", "user": "515ebde3e4b01e5d11ccd0a8"}, {"problem": 86, "code": "(fn happy?\n  ([n] (happy? n #{n}))\n  ([n s]\n    (letfn [(get-digits [n] (map read-string (map str (seq (str n)))))\n            (happiness [s] (reduce + (map #(* % %) s)))]\n    (let [result (happiness (get-digits n))]\n       (if (contains? s result)\n           (= result 1)\n           (recur result (conj s result)))))))", "user": "55acd080e4b03311e7b73298"}, {"problem": 86, "code": "(fn happynumbers [x]\n  (let [digits (fn digit\n                 [d]\n                 (map read-string (map str (str d))))\n        sqr (fn sqr [x]\n              (* x x))]\n    (loop [a x\n           b []]\n      (if (= 1 (last b))\n        true\n        (if (= 100 (count b))\n          false\n          (recur (reduce + (map sqr (digits a))) (conj b (reduce + (map sqr (digits a))))))))))", "user": "55d9743ae4b0e31453f64aca"}, {"problem": 86, "code": "(fn [j]\n    (let [i2d (fn [i] (->> i str seq (map #(- (int %) (int \\0)))))\n          ssd (fn [i] (reduce + (map #(* % %) (i2d i))))\n          tol 100000]\n      ((fn [c j]\n         (let [ss (ssd j)]\n           (if (= ss 1)\n             true\n             (if (> c tol)\n               false\n               (recur (inc c) ss))))) 0 j)))", "user": "559a9a3de4b066d22e731f45"}, {"problem": 86, "code": "(fn R ([n] (R n #{})) ([n V] (cond (= 1 n) true (V n) false :else (R (reduce #(let [x (- (int %2) 48)] (+ % (* x x))) 0 (str n)) (conj V n)))))", "user": "55f6fe09e4b06e875b46cea2"}, {"problem": 86, "code": "(fn h [num & {:keys [seen] :or {seen #{}}}]\n    (let [new (->> (str num)\n                   (map #(- (int %) 48))\n                   (map #(* % %))\n                   (apply +))]\n      (cond (= new 1) true\n            (seen new) false\n            :else (h new :seen (conj seen new)))))", "user": "56018dd4e4b04bb52996e18f"}, {"problem": 86, "code": "(fn happy?\n  ([i] (happy? i #{}))\n  ([i is]\n    (if (contains? is i) false\n      (let [i2 (apply +\n                      (map #(* % %)\n                           (map #(Character/digit % 10)\n                                (str i))))]\n        (if (= 1 i2) true\n          (recur i2 (conj is i)))))))", "user": "562cd94ee4b0a45d2ff83015"}, {"problem": 86, "code": "(fn [i] (->> [#{} i]\n  \t(iterate (fn [[s n]] [(conj s n) (->> n\n               \t(iterate \t#(quot % 10))\n               \t(take-while #(not= %  0))\n               \t(map \t\t#(mod  % 10))\n\t\t\t\t(map \t\t#(*    %  %))\n    \t\t\t(apply      +))]))                       \n  \t(take-while (fn [[s n]] (not (s n))))\n    (drop-while (fn [[s n]] (not= 1 n)))\n    first \n    boolean))", "user": "5603c31fe4b04bb52996e1c1"}, {"problem": 86, "code": "#(loop [n % a #{}]\n  (cond \n    (= 1 n) true\n    (a n) false\n    :else\n        (recur \n         \t(loop [d n \n                   s 0]\n              (if (= 0 d)\n              \ts\n               \t(recur (quot d 10) \n                   \t   (+ s (* (mod d 10) (mod d 10))))))\n            (conj a n)))\n  )", "user": "561047eae4b05f002753df6d"}, {"problem": 86, "code": "(fn [n]\n  (let [next-happy (fn [n]\n                     (int (apply + (map #(Math/pow (Integer/parseInt (str %)) 2) (str n)))))]\n  (loop [r #{}, rest-happy (iterate next-happy n)]\n    (prn r)\n    (cond (= 1 (first rest-happy)) true\n          (r (first rest-happy)) false\n          :else (recur (conj r (first rest-happy)), (rest rest-happy))))))", "user": "5492164ee4b0b312c081ff3e"}, {"problem": 86, "code": "(fn happy? [n]\n  (letfn [\n          (f [x seen] \n            (let [ss \n                  (->> x str seq\n                       (map (fn [i] (Integer/parseInt (str i))))\n                       (map #(* % %))\n                       (reduce +))]\n              (cond \n               (seen ss) false\n               (= 1 ss) true\n               :else (recur ss (conj seen ss)))))]\n    (f n #{})))", "user": "4f0f01c0535d0136e6c22329"}, {"problem": 86, "code": "(fn happy? [x]\n(let [digits  (fn [x] (map #(Character/digit % 10) (str x)))\n      sumsq   (fn [x] (reduce + (map #(* % %) (digits x))))]\n  (loop [n x, seen #{}]\n    (if (= n 1) true\n      (if (seen n) false\n        (recur (sumsq n) (conj seen n)))))))", "user": "54b54d1be4b05787c3b1639c"}, {"problem": 86, "code": "(fn [n] ((fn [coll]\n            (->> (range)\n                 (drop 2)\n                 (map #(= % (count (into #{} (take % coll)))))\n                 (take-while true?)\n                 count\n                 (#(drop % coll))\n                 first\n                 (= 1))) \n          (iterate\n           (fn [number]\n             (->> (str number)\n                  seq\n                  (map (comp #(* % %) int bigint str))\n                  (reduce +))) n)))", "user": "54db3d82e4b024c67c0cf75f"}, {"problem": 86, "code": "(fn hn [z]\n  (let [n (apply + (map #(* % %) (map #(- (int %) (int \\0))(str z))))]\n    (cond\n      (= 1 n) true\n      (= 4 n) false\n      :else (recur n))))", "user": "561a1af6e4b053970a773b02"}, {"problem": 86, "code": "(fn [n]\n  (loop [c n d 0]\n    (let [r (reduce + (map #(-> % int (- 48) (Math/pow 2) int) (str c)))]\n      (cond\n        (> d 9) false\n        (= r 1) true\n        :else (recur r (+ d 1))))))", "user": "52bacfa8e4b07a9af57922d6"}, {"problem": 86, "code": "(fn\n  [number]\n\n  (letfn [\n      (** [n] (* n n))\n      (squared [n] (reduce + (map #(** (- (int %) (int \\0))) (str n))))]\n      (loop [number number, seen #{}]\n        (if (contains? seen number)\n          false\n          (let [new-value (squared number)]\n            (if (= new-value 1)\n              true\n              (recur new-value (conj seen number))\n              )\n            )\n          )\n        )\n    )\n  )", "user": "563a30d7e4b0bfe05bf117f9"}, {"problem": 86, "code": "(fn happy-number? [n]\n  (letfn [(digits [n]\n                  (loop [n n\n                         dig '()]\n                    (if (zero? n) dig\n                      (recur (unchecked-divide-int n 10) (cons (mod n 10) dig)))))\n          (sum-of-square-digits [n]\n                                (apply + \n                                       (map #(* % %)\n                                            (digits n))))]\n    (loop [n n\n           coll #{}]\n      (if (= 1 n) true\n        (if (contains? coll n) false\n          (recur (sum-of-square-digits n) (conj coll n)))))))", "user": "53286f84e4b09d4e7a9b5505"}, {"problem": 86, "code": "(fn happy? [x]\n    (let [get-digits\n          (fn get-digits\n            ([x base] (if (zero? x) '(0) (get-digits x base :lol)))\n            ([x base _]\n              (if (< x 1) (list)\n                (let [digit (rem x base)]\n                  (concat (get-digits (quot x base) base :lol) (list digit)))))\n            )\n          sum-of-squared-digits\n          (fn [x] (reduce + (map #(* % %) (get-digits x 10))))\n          ]\n\n      (loop [current-x x seen-so-far #{}]\n        (let [sum (sum-of-squared-digits current-x)]\n          \n          (do\n            (println seen-so-far)\n          \n          \n          (if (= 1 sum)\n            true\n            (if (contains? seen-so-far sum)\n              false\n              (recur sum (conj seen-so-far sum))))))\n        )\n))", "user": "56393681e4b0bfe05bf117f2"}, {"problem": 86, "code": "; This is a cool solution to the problem.\n\n(fn [n]\n  (letfn [(digits [n]\n            (map #(Integer/parseInt (str %)) (str n)))\n          (sum-of-squares [n]\n            (reduce + (map #(* % %) (digits n))))]\n    (boolean (some #{1} (take 100 (iterate sum-of-squares n))))))\n\n; My solution was not getting me there... It did a conversion to a sequence, which I had trouble converting to integer.\n; The second part was that the solution about used a take on a lazy sequence; otherwise my solution would run forever on a false\n; I had trouble thinking about that. When I saw it, it was obvious...\n\n;((fn [bstring]\n;  (let [coll (map #(- % 48) (map int (seq (str bstring))))]\n;    (if (= (+ (* (first coll) (first coll)) (* (last coll) (last coll))) 1)\n;      true\n;      (recur (+ (* (first coll) (first coll)) (* (last coll) (last coll))))\n;      ))) 7)", "user": "5633bb9de4b0bfe05bf117b4"}, {"problem": 86, "code": "(fn [n]\n  (loop [x n sqacc #{}]\n    (cond \n      (= x 1) true\n      (contains? sqacc x) false\n      :else (let [ss (reduce + (loop [acc '() x x]\n                               (if (= x 0) acc\n                                 (recur (let [y (mod x 10)] (conj acc (* y y))) (quot x 10)))))] (recur ss (conj sqacc x))))))", "user": "54dce62be4b024c67c0cf78b"}, {"problem": 86, "code": "(fn happy? [x]\n  (case x\n    1 true\n    4 false\n    (happy?\n      (let [digits (map #(Character/digit % 10) (str x))\n            square-of-digits (map #(* % %) digits)]\n        (reduce + square-of-digits)))))", "user": "50cf94bde4b0abc485cb9bb2"}, {"problem": 86, "code": "(fn happy?\n  [n]\n  (letfn [(digits [n]\n            (lazy-seq\n              (if (< n 10)\n                (list n)\n                (cons (rem n 10) (digits (quot n 10))))))\n          (sum-squared-digits [n]\n            (apply + (map #(* % %) (digits n))))]\n    (loop [i n\n           seen #{}]\n      (cond\n        (= i 1) true\n        (seen i) false\n        :else (recur (sum-squared-digits i) (conj seen i))))))", "user": "563f1493e4b08d4f616f5ecf"}, {"problem": 86, "code": "(fn [x] (> x 4))", "user": "564127a9e4b08d4f616f5ef3"}, {"problem": 86, "code": "(fn [n]\n  (let [fs (fn [n] (map #(Integer/parseInt %) (re-seq #\"\\d\" (str n))))\n        r  (fn [n] (reduce + (map #(* % %) (fs n))))]\n    (loop [x n i 0]\n      (if (> i 1000)\n        false\n        (let [v (r x)]\n          (if (= 1 v)\n            true\n            (recur v (inc i))))))))", "user": "563ed73ae4b08d4f616f5ecb"}, {"problem": 86, "code": "(fn [n]\n   (let [get-next (fn [n] (->> n\n                               (str)\n                               (map #(Integer/parseInt (str %)))\n                               (map #(* % %))\n                               (apply +)))]\n     (loop [n n visited #{}]\n       (cond\n         (visited n) false\n         (= 1 n) true\n         :else (recur (get-next n) (conj visited n))))))", "user": "530b8580e4b02e82168697cc"}, {"problem": 86, "code": "(fn [n]\n   (loop [num [n]]\n     (cond\n       (= (last num)\n          1) true\n       (= (take-last 8 num)\n          [4 16 37 58 89 145 42 20]) false\n       :else (recur (conj num (->> num\n                                   last\n                                   str\n                                   (map #(Character/digit % 10))\n                                   (map #(* % %))\n                                   (apply +)))))))", "user": "554bd33ce4b0a04f7929959a"}, {"problem": 86, "code": "(fn happy-number\n  [n]\n  (let [digits (fn [n] (map #(read-string (str %)) (str n)))\n        sum-squares (fn [n] (reduce #(+ %1 (* %2 %2)) 0 (digits n)))]\n    (loop [current n\n            i 0]\n      (cond\n       (= i 1000) false\n       (= (sum-squares current) 1) true\n       :else (recur (sum-squares current) (inc i))))))", "user": "4fc524aae4b081705acca37e"}, {"problem": 86, "code": "(fn [n]\n  (loop [n n\n    \tseen []]\n    (print n)\n    (if (= n 1)\n      true\n      (if (contains? seen n)\n        false\n        (recur (reduce + (map #(* % %) (map (comp read-string str) (str n))))\n               (conj seen n)\n               )))))", "user": "541ef7e2e4b01498b1a71a92"}, {"problem": 86, "code": "(fn happy? [x]\n\t(loop [x x visited #{}]\n\t\t(if (contains? visited x) false\n\t\t\t(if (= x 1) true\n\t\t\t\t(recur (apply + (map #(* % %) ((fn explode-number [x]\n\t(if (= x 0) nil\n\t\t(cons (mod x 10) (explode-number (/ (- x (mod x 10)) 10))))) x))) (conj visited x))))))", "user": "563d12f9e4b0bfe05bf11845"}, {"problem": 86, "code": "#(loop[r %, v '()]\n   (if(= r 1)\n     true\n     (if(= (count (set v)) (count v))\n       (recur(loop[s 0, x r] (if(= x 0) s (recur(+ s (* (mod x 10) (mod x 10)))(/(- x (mod x 10)) 10))))(conj v r))\n       false)))", "user": "5654e8ade4b0f9d632dd848e"}, {"problem": 86, "code": "(fn [n]\n  (letfn\n    [(digits\n       ([m] (digits m '()))\n       ([m ds]\n         (if (zero? m)\n             (or (seq ds) '(0))\n             (recur\n               (quot m 10)\n               (conj ds (mod m 10))))))\n     (sum-of-squares [nums]\n       (apply + (map #(* % %) nums)))\n     (happy?\n       ([m] (happy? m #{}))\n       ([m visited]\n         (cond (= m 1) true\n               (visited m) false\n               :else\n               (recur\n                 (sum-of-squares\n                   (digits m))\n                 (conj visited m)))))]\n    (happy? n)))", "user": "55d2dd27e4b0e31453f64a5b"}, {"problem": 86, "code": "(fn happy? [n]                                                                                                      \n  (letfn [(digits2sumsq [n]                                                                                           \n            (->> n                                                                                                    \n                 str                                                                                                  \n                 (mapv str)                                                                                           \n                 (mapv read-string)                                                                                   \n                 (mapv #(* % %))                                                                                      \n                 (reduce +)                                                                                           \n                 ))]                                                                                                  \n    (->> n                                                                                                            \n      (iterate digits2sumsq)                                                                                          \n      (drop-while #(> % 243))                                                                                         \n      (take 250)                                                                                                      \n      (some #(= % 1))                                                                                                 \n      boolean)))", "user": "54bbaa8ee4b0ed20f4ff6ec0"}, {"problem": 86, "code": "(fn happy? [number]\n  (loop\n    [curnum number\n     results #{}]\n    (let\n      [cur-happy (apply + (map #(* %1 %1) (map read-string (map str (seq (str curnum))))))]\n      (cond\n       (contains? results cur-happy) false\n       (= 1 cur-happy) true\n       :else (recur cur-happy (conj results cur-happy))))))", "user": "5658d775e4b00d3155796114"}, {"problem": 86, "code": "(fn happy? [n]\n  (loop [n n, seen #{}]\n    (let [happy-sum (reduce + 0 (map #(* (- (int %) (int \\0))\n                                         (- (int %) (int \\0))) (seq (str n))))]\n      (cond \n       (= happy-sum 1) true\n       (seen happy-sum) false\n       :else (recur happy-sum, (conj seen n))))))", "user": "54ca93abe4b057c6fda3a264"}, {"problem": 86, "code": "(fn [num]\n  (letfn [(to-digits-seq [num]\n            (loop [n num\n                   digits ()]\n              (let [m (mod n 10)\n                    q (quot n 10)\n                    d (conj digits m)]\n                (if (= q 0)\n                  d\n                  (recur q d)))))\n          (is-happy-impl [num cache]\n            (let [digits (to-digits-seq num)\n                  squares (map #(* % %) digits)\n                  sum (reduce + squares)]\n              (or (= sum 1)\n                (if (contains? cache sum)\n                  false\n                  (recur sum (conj cache sum))))))]\n    (is-happy-impl num #{})))", "user": "5169d422e4b051e2a73aba53"}, {"problem": 86, "code": "(fn [x]\n   (letfn [(square [y] (let [n (Integer/parseInt (str y))] (* n n)))]\n     (loop [s (str x) ctrl #{}]\n       (let [s2 (reduce + (map #(square %) s))]\n         (cond\n           (= s2 1) true\n           (ctrl s2) false\n           :else (recur (str s2) (conj ctrl s2)))))))", "user": "53c06438e4b0c98a41f5ccb0"}, {"problem": 86, "code": "(fn happy-number[x]\n    (loop [next x\n           previous []]\n      (println next)\n      (if (every? #(not= % next) previous)\n        (recur (apply + (map #(* % %) (map #(read-string (str %)) (str next)))) (conj previous next))\n        (= next 1))))", "user": "5654cb2de4b0f9d632dd848b"}, {"problem": 86, "code": "(fn [arg1]\n(cond\n(and (= arg1 7)) true\n(and (= arg1 986543210)) true\n(and (= arg1 2)) false\n(and (= arg1 3)) false\n))", "user": "565f2461e4b068f2fe63dc3b"}, {"problem": 86, "code": "(fn happy-number? [n]\n  (let [square (fn [x] (let [y (Integer/parseInt (.toString x))] (* y y)))\n        happy  (fn [x] (->> x (str) (seq) (map square) (apply +)))]\n    (loop [seen #{}, number (happy n)]\n      (if (and (not (seen number)) (> number 1))\n        (recur (conj seen number) (happy number))\n        (= 1 number)))))", "user": "55d28b38e4b0e31453f64a58"}, {"problem": 86, "code": "(fn [num]\n   (letfn [(sq\n             ([n] (sq n 0))\n             ([r s] (if (> r 0)\n                      (let [nr (mod r 10)]\n                        (sq (int (/ r 10)) (+ s (* nr nr))))\n                      s)))]\n     (loop [n (sq num)]\n       (cond\n         (= 1 n) true\n         (= 4 n) false\n         :else (recur (sq n))))))", "user": "564b1ff8e4b0284900eef663"}, {"problem": 86, "code": "(fn happy? [x]\n  (letfn [\n(explode-digits [x]\n (map #(- (int %) 48) (str x)))\n   (happy-step [x]\n  (reduce + (map #(* % %) (explode-digits x))))  ]     \n  (cond\n    (= x 1) true\n    (contains? #{4 16 37 58 89 145 42 20} x) false\n    :else (happy? (happy-step x)))))", "user": "56504dc2e4b0284900eef6bc"}, {"problem": 86, "code": "(fn [N]\n   (let [digits (fn [n]  (reverse (map #(mod % 10)(take-while pos? (iterate #(quot % 10) n)))))\n         sqr (fn [n] (* n n))\n         form (fn [n] (apply + (map sqr (digits n))))]\n       (loop [n N s #{}]\n           (let [m (form n)]\n              (cond (= 1 m) true\n                    (s m) false\n                    :else (recur m (conj s m))))))  )", "user": "5649615be4b0284900eef641"}, {"problem": 86, "code": "(partial\n (fn [col n]\n   (if (== n 1) true\n       (if (nil? (col n))\n           (recur (conj col n)\n                  (->> n\n                       str\n                       (map #(- (int %) (int \\0)))\n                       (map #(* %1 %1))\n                       (apply +)))\n           false)))\n #{})", "user": "54c5cc17e4b045293a27f624"}, {"problem": 86, "code": "(fn [arg1]\n(cond\n(and (= arg1 7)) true\n(and (= arg1 986543210)) true\n(and (= arg1 2)) false\n(and (= arg1 3)) false\n))", "user": "5666bf34e4b04acd4f672dc2"}, {"problem": 86, "code": "(fn [num]\n  ((fn do-it [n seen]\n    (cond (= 1 n) true\n          (seen n) false\n          :else (do-it (apply + (map #(* % %) (map #(Character/getNumericValue %) (seq (str n)))))\n                       (clojure.set/union seen #{n})))) num #{}))", "user": "54fdaeace4b07d26eda61d39"}, {"problem": 86, "code": "(fn [n]\n  (letfn [(dgg [n]\n    (reduce + (map (comp #(* % %) (partial + -48) int) (str n))))]\n      (loop [a {}\n             v n]\n        (if (= 1 v)\n          true\n          (if (contains? a v)\n            false\n            (recur (assoc a v 1) (dgg v)))))))", "user": "5632d1b3e4b0bfe05bf117a9"}, {"problem": 86, "code": "(letfn\n      [(happy-iter [x]\n         (apply +\n                (->> x\n                     (str)\n                     (seq)\n                     (map int)\n                     (map #(+ -48 %))\n                     (map #(* % %))\n                     )))]\n      (fn happy_num\n        ([x] (happy_num x #{}))\n        ([x already-checked]\n         (if (= x 1)\n           true\n           (if (contains? already-checked x)\n             false\n             (happy_num (happy-iter x)\n                      (clojure.set/union already-checked #{x})))))))", "user": "5632b0a9e4b0bfe05bf117a8"}, {"problem": 86, "code": "(fn happy-number?\n  ([n]\n   (happy-number? n #{}))\n  ([n seen-before]\n   (let [n' (->> n\n                 str\n                 seq\n                 (map #(Character/getNumericValue %))\n                 (map #(* % %)))\n         sum (reduce + n')]\n     (cond (= 1 sum) true\n           (contains? seen-before sum) false\n           :else (happy-number? sum (conj seen-before n))))))", "user": "5666500ee4b0e91d5f5c566d"}, {"problem": 86, "code": "(fn happy-num [n]\n  (letfn [(h [i] (reduce + (map (comp #(* % %) read-string) (re-seq #\"\\d\" (str i)))))]\n    (let [happy-seq (iterate h n)]\n      (loop [acc #{} hs happy-seq]\n        (let [fhs (first hs)]\n          (cond\n           (= fhs 1) true\n           (contains? acc fhs) false\n           :else (recur (conj acc fhs) (rest hs)))\n          )))))", "user": "563dfc02e4b0da801c4e4662"}, {"problem": 86, "code": "(fn __ [n]\n  (let [digits (fn [n] (map #(Integer. (str %)) (seq (str n))))]\n    (loop [seen #{n}\n           n n]\n      (let [nw (apply + (map #(* % %) (digits n)))]\n        (or (= nw 1)\n            (if (seen nw)\n              false\n              (recur (conj seen nw) nw)))))))", "user": "56706f01e4b0a866af6896f2"}, {"problem": 86, "code": "(fn [n]\n    (\n     (fn [previous x]\n       (if (contains? previous x)\n         false\n         (let [next (reduce + (map \n                               #((fn [x] (* x x)) \n                                 (Integer/parseInt (str %))) \n                               (seq (str x))))]\n           (if (= 1 next)\n             true\n             (recur (conj previous x) next)))))\n     #{} n))", "user": "567476bde4b05957ce8c6139"}, {"problem": 86, "code": "(fn [n]\n  (loop [seen #{} n n]\n    (cond\n     (seen n) false\n     (= n 1) true\n     :else (recur (conj seen n) (reduce #(+ % (* %2 %2)) 0 (map #(- (int %) 48) (str n)))))))", "user": "562cb7cfe4b0a45d2ff83009"}, {"problem": 86, "code": "(fn [n]\n  (let [digits (fn [n]\n                 (loop [n n res []]\n                   (let [n' (int (/ n 10))\n                         r  (rem n 10)]\n                     (if (zero? n)\n                       res\n                       (recur n' (concat [r] res))))))]\n    (loop [seen #{} n n]\n      (let [d (digits n)\n            r (reduce + (map #(* % %) d))]\n        (cond (contains? seen r) false\n              (= 1 r) true\n              :else (recur (conj seen r) r))))))", "user": "5591cc56e4b0604b3f94d582"}, {"problem": 86, "code": "(fn happy [a] \n  (if (> a 10)\n  \t(happy (->> a str seq (map int) (map #(- % 48)) (map (fn [x] (* x x) )) (reduce +)))\n  \t(cond \n   \t\t(= a 2) false \n   \t\t(= a 3) false \n   \t\t(= a 6) false \n   \t\t:else true\n     )\n  )\n)", "user": "5676af21e4b05957ce8c6158"}, {"problem": 86, "code": "(let [zero (int \\0)\n      char->int #(- (int %) zero)\n      digits #(map char->int (str %))\n      square #(* % %)\n      sum-of-squares #(apply + (map square (digits %)))]\n  (fn [n]\n    (loop [n n\n           prev-ns #{}]\n      (let [sum (sum-of-squares n)]\n        (cond\n          (= sum 1) true\n          (contains? prev-ns sum) false\n          :otherwise (recur sum (conj prev-ns sum)))))))", "user": "5424c523e4b01498b1a71b03"}, {"problem": 86, "code": "(fn happy-number? [n]\n  (letfn [(digits [n]\n                  (map\n                   first\n                   (take-while\n                    #(not= [0 0] %)\n                    (drop 1\n                          (iterate\n                           (fn [[a b]]\n                             [(mod b 10) (quot b 10)])\n                           [0 n])))))\n          (happy-number-next [n]\n                             (reduce +' (map #(* % %) (digits n))))\n          (happy-number-seq [n] (iterate  happy-number-next n))\n          ]\n    (loop [seen #{} [i & more] \n           (happy-number-seq n)] \n      (cond \n       (= 1 i) true\n       (contains? seen i) false\n       :else (recur (conj seen i) more)))\n     \n     ))", "user": "5654e024e4b0f9d632dd848d"}, {"problem": 86, "code": "(fn [x]  \n  (loop [current-number x\n           number-list '[]]\n      (cond\n        (= current-number 1) true\n        (contains? number-list current-number) false\n        :else (recur (reduce + (map #(* (Integer. (str %)) (Integer. (str %))) (str current-number))) (conj number-list current-number)))\n      )\n  )", "user": "566648e6e4b0e91d5f5c566c"}, {"problem": 86, "code": "(fn [n]\n  (loop [n n history #{}]\n    (let [sum-sqrs (->> n\n                        (str)\n                        (seq)\n                        (map #(Integer/parseInt (str %)))\n                        (map #(* % %))\n                        (reduce +)\n                        )]\n      (cond (= sum-sqrs 1) true\n            ((complement nil?) (get history sum-sqrs)) false\n            :default (recur sum-sqrs (set (cons sum-sqrs history)))\n            )\n      )\n    )\n  )", "user": "564a560ae4b0284900eef654"}, {"problem": 86, "code": "(fn happy? [x]\n  (let [sum-of-squares (fn [x] (->> (.toString x)\n                                    (seq)\n                                    (map #(- (int %) (int \\0)))\n                                    (map #(* % %))\n                                    (apply +) ))]\n    (loop [y (iterate sum-of-squares x) z1 #{}]\n      (let [v (first y) z2 (conj z1 v)]\n        (cond\n          (= 1 v) true\n          (= (count z2) (count z1)) false\n          :else (recur (rest y) z2) )))))", "user": "550e52dbe4b06e50f9beb165"}, {"problem": 86, "code": "(fn [i]\n  (letfn [(individual-digits [x]\n                             (loop [remain x result []]\n                               (if (= 0 remain)\n                                 result\n                                 (recur (quot remain 10) (conj result (mod remain 10))))))\n          (individual-square-sum [x]\n                                 (apply + (map #(* % %) (individual-digits x))))]\n    (loop [tested-nums #{} curr-num i]\n      (cond\n       (contains? tested-nums curr-num) false\n       (= 1 (individual-square-sum curr-num)) true\n       :else (recur (conj tested-nums curr-num) (individual-square-sum curr-num))))))", "user": "56288ccae4b00e49c7cb47ea"}, {"problem": 86, "code": "(fn hn\n        ([n] (hn n #{}))\n        ([n s]\n         (cond\n           (= 1 n) true\n           (not (nil? (s n))) false\n           :else (let [ss (conj s n) cf (fn [r] (int (Math/pow r 2)))]\n                   (loop [r (rem n 10) n (quot n 10) sum 0]\n                     (if (zero? n) (hn (+ (cf r) sum) ss)\n                       (recur (rem n 10) (quot n 10)\n                              (+ (cf r) sum))))))))", "user": "544e6b7fe4b0e39780006986"}, {"problem": 86, "code": "(fn __ [n]\n  (if (= n 1)\n    true\n    (loop [i0 n prev #{}]\n      (let [i1 (reduce + (map (comp #(* % %) #(Integer/parseInt %) str) ((comp seq str) i0)))]\n        (if (= i1 1)\n          true\n          (if (contains? prev i1)\n            false\n            (recur i1 (conj prev i1))))))))", "user": "4f856adfe4b033992c121c44"}, {"problem": 86, "code": "(fn happy? [n]\n  (letfn [(digits [n]\n            (map #(Integer/parseInt (str %)) (str n)))\n          (sum-of-squares [n]\n            (reduce + (map #(* % %) (digits n))))]\n    (boolean (some #{1} (take 100 (iterate sum-of-squares n))))))", "user": "56810479e4b0966858e4d8f8"}, {"problem": 86, "code": "(fn [n]\n  ((fn [n s]\n    (cond\n     (contains? s n) false\n     (= n 1) true\n     :else (recur (apply + (map #(* % %) (map #(- (int %) 48) (seq (str n))))) (conj s n)))) n #{}))", "user": "524b90fae4b09eba1c0223df"}, {"problem": 86, "code": "(fn happy [n]\n  (contains? \n   (set \n    (first\n      (drop-while\n       #(apply distinct? %)\n       (reductions conj \n                   [:f]\n                   (iterate (fn [i] (reduce + (map (comp #(*' % %) bigint str) (seq (str i)))))\n                            n)))))\n   1))", "user": "554680cbe4b0a04f7929953e"}, {"problem": 86, "code": "(fn [x]\n  (letfn [(next-iter [n]\n            (->> n (str)\n                   (re-seq #\"\\d\")\n                   (map read-string)\n                   (map #(* % %))\n                   (reduce +)))]\n    (loop [prev-nums (vector x)]\n      (let [n (next-iter (last prev-nums))]\n        (cond (= n 1) true\n              (some #(= n %) prev-nums) false\n              :else (recur (conj prev-nums n)))))))", "user": "567695c2e4b05957ce8c6157"}, {"problem": 86, "code": "(fn happy?\n  ([n] (happy? n #{}))\n  ([n history]\n   (letfn [(sum-of-sq [items] (reduce + (map #(* % %) items)))\n           (digits [x] (map #(Integer/parseInt (str %)) (str x)))]\n\t(cond\n     (= n 1) true\n     (contains? history n) false\n     true   (happy? (sum-of-sq (digits n)) (conj history n))))))", "user": "56897739e4b0dcc4269f407d"}, {"problem": 86, "code": "(fn [n]\n\t(letfn [\n\t\t(happy-seq [n]\n\t\t\t(cons n (lazy-seq (happy-seq (reduce + (map #(* % %) (map read-string (map str (seq (str n))))))))))\n\t\t(duplicate [xs]\n\t\t\t(loop [[x & xs :as coll] xs seen #{}]\n    \t\t\t(if (empty? coll) nil\n      \t\t\t\t(or (seen x) (recur xs (conj seen x))))))]\n\t\t(= (duplicate (happy-seq n)) 1)))", "user": "56540485e4b0f9d632dd847a"}, {"problem": 86, "code": "(letfn\n  [(digit-seq [n]\n  (if (zero? n)\n    nil\n    (lazy-seq\n     (cons (mod n 10)\n           (digit-seq (quot n 10))))))\n\n\t(dig-square-sum [n]\n  (->>\n   (digit-seq n)\n   (map #(* % %))\n   (reduce +)))]\n\n(fn q4q86 [n]\n  \"Happy numbers are positive integers that follow a particular formula: take each individual digit, square it, and then sum the squares to get a new number. Repeat with the new number and eventually, you might get to a number whose squared sum is 1. This is a happy number. An unhappy number (or sad number) is one that loops endlessly. Write a function that determines if a number is happy or not.\"\n  ((fn happy [x tried]\n     (cond\n       (contains? tried x) false\n       (= 1 x)             true\n       :default\n       (recur (dig-square-sum x) (conj tried x))))\n   n #{})))", "user": "52213426e4b0e6a83c8925c4"}, {"problem": 86, "code": "(fn [n]\n    (letfn [(sum-sq [n]\n              (reduce\n                +\n                (for [digit-str (str n)\n                      :let [digit (- (int digit-str) 48)]]\n                  (* digit digit))))]\n      (loop [sums (iterate sum-sq n)\n             acc #{}]\n        (let [sum (first sums)]\n          (cond\n            (= sum 1) true\n            (acc sum) false\n            :else (recur (rest sums) (conj acc sum)))))))", "user": "5275f7a2e4b03e8d9a4a74d0"}, {"problem": 86, "code": "(fn happy-number? [n]\n  (letfn [(next-n [curr-n]\n            (->> (str curr-n)\n                 seq\n                 (map #(Integer/valueOf (str %)))\n                 (map #(* % %))\n                 (reduce +)))]\n    (loop [acc #{} n_ n]\n      (if (= 1 n_)\n        true\n        (if (contains? acc n_)\n          false\n          (recur (conj acc n_) (next-n n_)))))))", "user": "5657fed1e4b0f9d632dd84ae"}, {"problem": 86, "code": "#(loop [s #{}\n       c %]\n  (cond (= 1 c) true\n      (s c) false\n      1 (recur (conj s c) ((fn [i] (reduce (fn [u v] (+ u (* v v))) 0 ((fn f [a x] (if (pos? x) (f (cons (rem x 10) a) (quot x 10)) a)) [] i))) c))))", "user": "53b15e6ee4b047364c04448f"}, {"problem": 86, "code": "< 5", "user": "569c40cee4b0542e1f8d1462"}, {"problem": 86, "code": "(fn happy [number]\n  (let [sumofsq (fn [n]\n\t\t\t(loop [q (quot n 10) r (mod n 10) result [r]]\n\t\t\t (if (= q 0)\n\t\t\t  (reduce + (map #(* % %) result))\n\t\t\t  (let [irem (mod q 10)]\n\t\t\t   (recur (quot q 10) irem (conj result irem))))))]\n   (loop [newnum (sumofsq (sumofsq number))\n\t\t  seenset #{number}]\n\t(do\n\t(prn newnum seenset)\n    (if (contains? seenset newnum)\n\t   (do\n       false)\n       (if (= newnum 1)\n         true\n         (let [nnum (sumofsq newnum)]\n\t\t   (prn (type (sumofsq newnum)))\n\t\t   (recur nnum (conj seenset newnum)))))))))", "user": "567d18c9e4b05957ce8c61c4"}, {"problem": 86, "code": "(fn [x] (let [op (fn  [x] (->> x str (map int) (map #(- % 48)) (map #(* % %)) (apply +) )) ]  (loop [n x others #{} ] (if (= n 1) true (if (others n) false (recur (op n) (conj others n)))))) )", "user": "56979bb7e4b0e0b3d3318cac"}, {"problem": 86, "code": "(fn happy-number? [n]\n  (letfn\n      [(square [n]\n         (*' n n))\n       (discompose [d]\n         (map #(Character/digit % 10) (str d)))]\n    (loop [num n visited #{}]\n      (cond\n        (visited num) false\n        (= 1 num) true\n        :else (recur (apply + (map square (discompose num))) (conj visited num))))))", "user": "5693a53ee4b0dcc4269f4106"}, {"problem": 86, "code": "(fn happy?\n  ([n] (happy? n #{}))\n  ([n visited] (if (contains? visited n)\n                 false\n                 (if (= n 1)\n                   true\n                   (recur\n                    (letfn [(charToInt [i] (- (int i) (int \\0)))]\n                      (apply + (map #(* % %) (map charToInt (seq (str n))))))\n                    (conj visited n))))))", "user": "567b39b6e4b05957ce8c61a3"}, {"problem": 86, "code": "(fn [n]\n  (let [sqrt (fn [x] (* x x))\n        sq-sum (fn [sum x]\n                 (if-not (> x 0)\n                   sum\n                   (recur (+ sum (sqrt (mod x 10)))\n                          (int (/ x 10)))))\n        loop-x (fn [s x]\n                 (if (s x)\n                   x\n                   (recur (conj s x) (sq-sum 0 x))))]\n    (= 1 (loop-x #{} n))))", "user": "50ec409ce4b04edc33777045"}, {"problem": 86, "code": "(fn [n]\n  (let [digits (fn [n] (map (comp #(Integer. %) str) (str n)))\n        sum-squared-digits (fn [n] (reduce + (map #(* % %) (digits n))))]\n    (loop [acc []\n           s (sum-squared-digits n)]\n      (cond\n       (= 1 s)         true\n       (some #{s} acc) false\n       :else (recur (conj acc s) (sum-squared-digits s))))))", "user": "553b0d95e4b09218d5f44fff"}, {"problem": 86, "code": "(fn [x](loop [n x\n               s #{}]\n          (cond \n            (= n 1) true\n            (s n) false\n            :else (recur (->> (str n)\n                              (map #(Character/digit % 10))\n                              (map #(* % %))\n                              (apply +))\n                         (conj s n)))))", "user": "566a3a26e4b0a866af689699"}, {"problem": 86, "code": "(fn [x]\n  (letfn [(ds [z]\n            (loop [out [] in z]\n              (if (= in 0)\n                out\n                (recur (conj out (rem in 10)) (quot in 10)))))\n          (ssd [y]\n            (reduce #(+ (* %2 %2) %1) 0 (ds y)))]\n    (loop [out #{} in x]\n      (cond \n        (= in 1) true\n        (contains? out in) false\n        :else (recur (conj out in) (ssd in))))))", "user": "564a5a09e4b0284900eef656"}, {"problem": 86, "code": "(fn [n] \n\t(letfn [(digits [n] (map #(Integer/parseInt (str %)) (seq (str n))))] \n\t\t(loop [x n seen #{}] \n\t\t  (let [new (apply + (map #(* % %) (digits x)))]\n            (cond (= new 1) true\n\t\t\t\t  (contains? seen new) false\n\t\t\t\t  :else (recur new (conj seen new)))))))", "user": "5578f292e4b05c286339e08f"}, {"problem": 86, "code": "(fn i\n  ([n] (i n #{}))\n  ([n s]\n   (letfn \n     [(ds[n] (map last (take-while #(> (first %) 0) (iterate (fn [[a b]] (let [m (/ (- a b) 10)] [m (mod m 10)])) [n (mod n 10)]))))\n      (hn[n] (apply + (map #(* % %) (ds n))))]\n     (let [h (hn n)] (cond (= h 1) true (s h) false :else (recur h (conj s h)))))))", "user": "56824e1be4b0945ebc182a91"}, {"problem": 86, "code": "(fn [n]\n  (= 1 ((fn [s n]\n          (let [i (fn [n] (reduce #(+ % (* %2 %2)) 0 (map #(- (int %) (int \\0)) (str n))))]\n            (if (contains? s n)\n              n\n              (recur (conj s n) (i n))))) #{} n)))", "user": "56874171e4b0dcc4269f405c"}, {"problem": 86, "code": "(fn happy? [n]\n  (let [digits\n        (fn [n]\n          (map #(Integer. (str %))\n               (str n)))\n        square #(* % %)\n        sum\n        (partial apply +)\n        one? #(== % 1)]\n    (loop [x n visited #{}]\n      (let [y (sum\n               (map square\n                    (digits x)))]\n        (cond (one? y)\n              true\n              (visited y)\n              false\n              :else\n              (recur y\n                     (conj visited y)))))))", "user": "54d9f7f1e4b024c67c0cf751"}, {"problem": 86, "code": "(fn newHappy [n] (letfn\n                     [(hNum [x] (reduce + (map #(* % %) (intToDigits x))))\n                      (intToDigits [x] (map #(Integer/parseInt (str %)) (seq (str x))))]\n                     (loop\n                       [prev #{}\n                        initial (hNum n)]\n                       (cond\n                         (= initial 1) true\n                         (contains? prev initial) false\n                         :else (recur (conj prev initial) (hNum initial))))))", "user": "56427910e4b08d4f616f5f19"}, {"problem": 86, "code": "(letfn [(f [x]\n           (->> (str x)\n                (map #(Character/digit % 10))\n                (map #(* % %))\n                (reduce +)))]\n  (fn [x]\n    (->> [x]\n         (iterate #(conj % (f (last %))))\n         (drop-while #(not ((set (butlast %)) (last %))))\n         first\n         last\n         (= 1))))", "user": "54485749e4b032a45b8693c7"}, {"problem": 86, "code": "(fn [x]\n  (cond\n   (= 1 x) true\n   ; All non-happy numbers follow sequences that reach the cycle:\n   ;   4, 16, 37, 58, 89, 145, 42, 20, 4, ...\n   (= 4 x) false\n   :else (letfn [(sq [y] \n               (if (< y 10) \n                 (* y y) \n                 (+ (* (rem y 10) (rem y 10)) (sq (quot y 10)))))]\n               (recur (sq x)))\n  )\n)", "user": "56bca51ae4b0f26550335963"}, {"problem": 86, "code": "(fn happyX [n] ((fn happyRec [n seen] \n\t(if (= n 1) true \n\t\t(if (contains? seen n) false \n\t\t\t(happyRec ((fn squaresDigits [n] ((fn sumsquares [x] (reduce + (map (fn [n] (* n n)) x))) (\n(fn digits[n]\n\t(if (< n 10) (list n) \n\t\t(cons (mod n 10) (digits (quot n 10))))) n)))\n n) (conj seen n))\n\t\t\t)))\n n #{}))", "user": "568820e8e4b0dcc4269f4067"}, {"problem": 86, "code": "(fn solve [n]\n  (let [digits (fn [s] (map #(- (int %) (int \\0)) (str s)))\n        sum-squares (fn [d] (reduce (fn [sum x] (+ sum (* x x))) 0 d))\n        check (fn [x seen]\n                (let [ss (sum-squares (digits x))]\n                  (cond (= ss 1) true\n                        (seen ss) false\n                        :else (recur ss (conj seen x)))))]\n    (check n #{})))", "user": "56444fb1e4b0018b46ad8c0c"}, {"problem": 86, "code": "(fn[n] (loop [current n history #{}]\n         (if (= 1 current) true\n           (if (history current) false\n             (recur (reduce + (map #(int (Math/pow (Integer/parseInt (str %)) 2)) (str current))) (conj history current)))\n           )))", "user": "56baab13e4b0f26550335948"}, {"problem": 86, "code": "(fn\n  [num]\n  (letfn [(sum-squares-of-digits\n            [x]\n            (apply + (map #(* (- (int %) (int \\0))\n                              (- (int %) (int \\0))) (str x))))\n          (is-happy?\n            [st x]\n            (if (st x)\n              false\n              (let [y (sum-squares-of-digits x)]\n                (if (= 1 y)\n                  true (is-happy? (conj st x) y)))))]\n    (is-happy? #{} num)))", "user": "56a36f76e4b0542e1f8d14ca"}, {"problem": 86, "code": "(fn hn [n] \n  (let [sqr (fn [y] (* y y))\n        sumsqrs (fn [x] (reduce + (map sqr (map #(Character/getNumericValue %) (str x)))))]\n      (= 1 (first (sort (take 1000 (iterate sumsqrs n)))))))", "user": "50e1bdd8e4b019fc399ce17f"}, {"problem": 86, "code": "(fn [i]\n  (letfn [(digits [x] (map #(Character/digit % 10) (str x)))\n          (sum-sq-digits [x] (reduce + (map #(* % %) (digits x))))]\n    (loop [n i, seen #{}]\n      (cond (= n 1) true\n            (seen n) false\n            :else (recur (sum-sq-digits n) (conj seen n))))))", "user": "56c4f43ce4b05cc29241ee9c"}, {"problem": 86, "code": "(fn is-happy? [n]\n  (letfn [(to-digits [n] (map #(- (int %) (int \\0)) (str n)))\n          (sum-of-squares [coll] (reduce + (map #(* % %) coll)))]\n    (loop [curr n seen #{}]\n      (cond\n        (= 1 curr) true\n        (seen curr) false\n        :else (recur (sum-of-squares (to-digits curr)) (conj seen curr))))))", "user": "56a01895e4b0542e1f8d149f"}, {"problem": 86, "code": "(fn [x] (letfn [(digits [n] (map #(- (int %) 48) (str n)))\n                (sos [s] (reduce + (map #(* % %) s)))]\n          (-> (iterate (comp sos digits) x)\n               (nth 20)\n               (= 1))))", "user": "56b86e64e4b0f26550335924"}, {"problem": 86, "code": "(fn [n]\n  (loop [n n\n         reps 0]\n    (let [digits (map #(Integer/parseInt (str %)) (str n))\n          new (reduce +\n                      (for [d digits]\n                        (* d d)))]\n      (if (= 1 new)\n        true\n        (if (> reps 1000)\n          false\n         (recur new (inc reps)))))))", "user": "51db0d99e4b06aa4d4669a9d"}, {"problem": 86, "code": "(fn [n]\n  (let [f (fn [x] (apply + (map (comp #(* % %) read-string str) (str x))))]\n    (loop [y (f n) seen #{}]\n      (if (contains? seen y)\n        (if (= 1 y) true false)\n        (recur (f y) (conj seen y))))))", "user": "56ae214ce4b03c432f18735a"}, {"problem": 86, "code": "(fn happy-num [n]\n  (letfn [(sum-square [number]\n                      (->> number\n                           str\n                           (map identity)\n                           (map str)\n                           (map #(Integer/valueOf %))\n                           (map #(* % %))\n                           (apply +)))]\n    (loop [number n, sum-history #{}]\n      (cond\n       (= number 1) true,\n       (contains? sum-history number) false,\n       :else (recur (sum-square number) (conj sum-history number))))))", "user": "567e418fe4b0feffd0d18eb1"}, {"problem": 86, "code": "(fn [n]\n  (loop [n n seen #{}]\n    (if (seen n)\n      false\n      (let [sq-sum (reduce + (map\n                                  #(* % %)\n                                  (map #(- (int %) 48)\n                                       (str n))))]\n        (cond\n              (= sq-sum 1) true\n              :else (recur sq-sum (conj seen n)))))))", "user": "5638b88de4b0bfe05bf117e9"}, {"problem": 86, "code": "(fn [n]\n  (let [char->int (fn [c]\n                    (- (int c) 48))\n        square (fn [n]\n                 (* n n))\n        run (fn [n]\n              (->> n\n                   (str)\n                   (map char->int)\n                   (map square)\n                   (apply +)))]\n    (loop [history #{} result n]\n      (cond\n        (= 1 result) true\n        (history result) false\n        :else (let [new-n (run result)\n                    history (into history [result])]\n                (recur history new-n))))) )", "user": "50e90813e4b033b0e80d11e7"}, {"problem": 86, "code": "(fn [n] (let [q (fn [s] (reduce #(+ % (* (Integer. %2)(Integer. %2))) 0 (rest (clojure.string/split (str s) #\"\"))))\n\t\t     w (fn f [v i] (let [r (q v)] (if (i r) r (f r (conj i r)))))] \n\t\t  (= 1 (w n #{}))))", "user": "56c08696e4b060a8e693e3aa"}, {"problem": 86, "code": "(fn happy? [n]\n  (letfn [(digits [n]\n                  (map #(Integer/parseInt (str %)) (str n)))\n          (sum-of-squares [n] \n                          (reduce + (map #(* % %) (digits n))))]\n    (boolean (some #{1} (take 100 (iterate sum-of-squares n))))))", "user": "567931e9e4b05957ce8c6184"}, {"problem": 86, "code": "(fn [y]\n    (let [f (fn [x] (->> (str x)\n                         (map #(let [n (- (int %) 48)] (* n n)))\n                         (reduce +)))]\n      (loop [n y\n             s #{}]\n        (cond\n          (s n) false\n          (= n 1) true\n          :t (recur (f n) (conj s n))))))", "user": "5382704be4b06839e8705ed4"}, {"problem": 86, "code": "(fn h? [n]\n    (loop [n n\n           s #{}]\n           (cond\n                (= n 1) true\n                (s n) false\n                :else (recur (apply + (map (comp #(* % %) #(- (int %) 48)) (str n)))\n                             (conj s n)))))", "user": "56baa68ce4b0f26550335947"}, {"problem": 86, "code": "#(letfn [(digits [n]\n                 (loop [n n\n                        nums []]\n                   (if (= 0 n) \n                     nums\n                     (recur (int (/ n 10)) (conj nums (mod n 10))))))\n         (square [n] (* n n))\n         (squm [n]\n               (->> (digits n)\n                    (map square)\n                    (apply + )))]\n  (loop [n (squm %)\n         history #{}]\n    (cond\n      (= 1 n) true\n      (contains? history n) false\n      :else (recur (squm n) (conj history n)))))", "user": "56d63729e4b0ea9b8538f7ca"}, {"problem": 86, "code": "(fn [n]\n;  (let [seqn (transduce\n;              (comp\n;               (map #(Integer. (str %)))\n;               (map #(* % %)))\n;              + (str n))]\n  (let [seqn (->> (map #(Integer. (str %)) (str n))\n                  (map #(* % %))\n                  (reduce +))]\n    (cond\n     (= 1 seqn) true\n     (= 4 seqn) false\n     :else      (recur seqn))))", "user": "56481722e4b0284900eef628"}, {"problem": 86, "code": "(letfn [(digits[n] (map #(- (int %) (int \\0)) (str n)))]\n  (fn [n]\n    (loop [n n seen #{}]\n      (cond\n        (= n 1) true\n        (seen n) false\n        :else (recur (reduce #(+ %1 (* %2 %2)) 0 (digits n))\n                     (conj seen n))))))", "user": "56795deae4b05957ce8c6187"}, {"problem": 86, "code": "(fn happy? [n]\n  (let [digits (fn [x] (map #(- (int %) 48) (->> x str seq)))\n        step   (fn [x] (apply + (map #(* % %) (digits x))))]\n    (loop [cand n, seen #{}]\n        (cond \n          (= 1 cand) true\n          (seen cand) false\n          :else (recur (step cand) (conj seen cand))))))", "user": "56e2dbf4e4b03a7c14b85a3b"}, {"problem": 86, "code": "(fn [n]\n  (let [happy (fn [n]\n                (->> (clojure.string/split (str n) #\"\")\n                     (rest)\n                     (map read-string)\n                     (map #(* % %))\n                     (reduce + 0)))]\n    (not (boolean \n     (some #{89 145 42 20 4 16 37 58}\n           (take 16 (iterate happy n)))))))", "user": "5297dcc5e4b02ebb4ef75047"}, {"problem": 86, "code": "(fn [n]\n  (letfn [(digits-squared [n]\n            (apply + (map (comp #(* % %) read-string str) (str n))))]\n    (loop [checked #{n}\n           number (digits-squared n)]\n      (if (= 1 number)\n        true\n        (if (checked number) ;; loop detected\n          false\n          (recur (conj checked number)\n                 (digits-squared number)))))))", "user": "56e83348e4b02e7e935eb6e5"}, {"problem": 86, "code": "(fn [n]\n  (loop [s n\n         detector #{}]\n    (let [t (apply + (map #(* % %) (map #(- (int %) 48) (str s))))]\n      (cond\n       (= t 1) true\n       ((complement nil?) (get detector t)) false\n       :else (recur t (set (cons t detector)))))))", "user": "56d5fd24e4b0ea9b8538f7c5"}, {"problem": 86, "code": "(fn [n] (= 1 (last (take 10 (iterate (fn [x] (reduce + (map #(* % %) (map #(- % 48) (map int (seq (str x))))))) n)))))", "user": "4fd11a93e4b04c3a95aa040a"}, {"problem": 86, "code": "(fn happiness [x] (if (= 1 (last (let [digitize (fn [num] (reduce #(conj %1 (Character/digit %2 10)) [] (str num)))]\n                                    (reduce #(conj %1 (reduce + (map (fn [x] (* x x)) (digitize (nth %1 %2))))) [x] (range 0 50))))) true\n                                                                                                                                     false))", "user": "567f988be4b0feffd0d18ebe"}, {"problem": 86, "code": "(fn [x]\n  {:pre [(pos? x)]}\n  (letfn [(sum-of-square-digits [n]\n            (->> (str n)\n                 (map #(Character/digit % 10))\n                 (map #(* % %))\n                 (reduce +)))]\n  (loop [r #{}\n         i x]\n    (let [s (sum-of-square-digits i)]\n      (cond\n        (= s 1) true\n        (contains? r s) false\n        :else (recur (conj r s) s))))))", "user": "56d4b22de4b0ea9b8538f7bb"}, {"problem": 86, "code": "(fn f\n  ([n] (f n #{}))\n  ([n seen]\n   (let [digits (map #(Integer/parseInt (str %)) (str n))\n         sq (map #(* % %) digits)\n         sum (reduce + sq)]\n     (cond\n       (= 1 sum) true\n       (seen sum) false\n       :default (recur sum (conj seen sum))))))", "user": "4ec1923f535dfed6da9c6db2"}, {"problem": 86, "code": "(fn [x]\n  (loop [e #{}\n         x x]\n    (let [d (fn [ch]\n              (- (int ch) (int \\0)))\n          n (reduce + 0 (map #(* (d %) (d %)) (str x)))]\n      (cond (= 1 n) true\n            (= n x) false\n            (= n (e n)) false\n            :else (recur (conj e n) n)\n            ))))", "user": "5628f727e4b00e49c7cb47f5"}, {"problem": 86, "code": "(fn [n]\n  (letfn [(my-get-digits [n]\n            (map #(read-string (str %)) (str n)))\n          (sum-of-squares [n]\n            (reduce + (map #(* % %) (my-get-digits n))))]\n    (boolean (some #{1} (take 100 (iterate sum-of-squares n))))))", "user": "56dc483fe4b0ea9b8538f81b"}, {"problem": 86, "code": "(fn solve [x]\n  ((fn rec [x met]\n\t  (let \n\t    [digits (fn help [u] (if (< u 10) [u] (conj (help (quot u 10)) (rem u 10))))\n\t     transform (fn [u] (apply + (map #(* % %) (digits u))))\n\t     nxt (transform x)\n\t    ]\n\t   (cond\n\t     (= x 1) true\n\t     (contains? met nxt) false\n\t     :else (rec nxt (conj met nxt))\n\t    )\n\t  )\n  ) x #{})\n)", "user": "56f258d3e4b04a395b9a04a1"}, {"problem": 86, "code": "(fn [x]\n  (loop [x x\n         seen #{x}]\n    (let [next-x (->> (str x)\n                      seq\n                      (map str)\n                      (map read-string)\n                      (map #(* % %))\n                      (apply +))]\n      (cond\n        (= 1 next-x) true\n        (seen next-x) false\n        :else (recur next-x (conj seen next-x))))))", "user": "56f9982ce4b07572ad1a88b8"}, {"problem": 86, "code": "(fn [n] (let [f (fn [n]\n                   (reduce + \n                           (map #(* % %)\n                                (loop [x n c []]\n                                  (if (zero? x)\n                                    c\n                                    (recur (quot x 10) (conj c (rem x 10)))))))\n                   )]\n           (loop [x n nums #{}]\n             \n            (cond (= x 1) true\n                  (some #(= % x) nums) false\n                  :else (recur (f x) (conj nums x)))\n             )))", "user": "56f15eade4b04a395b9a048e"}, {"problem": 86, "code": "(fn [arg]\n  (letfn [(happyloop [xs]\n            (->> xs str (map #(Integer/parseInt (str %))) (map #(* % %)) (apply +)))]\n    (loop [generated #{}\n           xs (iterate happyloop arg)]\n      (let [next (first xs)]\n        (cond (= next 1) true\n              ((complement nil?) (generated next)) false\n              :else (recur (conj generated next) (drop 1 xs)))))\n    ))", "user": "56f7ecdfe4b08e7d20b96834"}, {"problem": 86, "code": "(fn happy? [x]\n  (letfn [(sum-sq-digit [x]\n           (->>\n            (str x)\n            (map #(- (int %) (int \\0)))\n            (map #(* % %))\n            (apply +)\n            str))]\n        (loop [x x\n               seen #{}]\n          (let [sx (sum-sq-digit x)]\n            (cond\n              (= \"1\" sx) true\n              (seen sx) false\n              :else (recur sx (conj seen sx)))))))", "user": "569dd6e8e4b0542e1f8d1480"}, {"problem": 86, "code": "(fn [n]\n  (letfn [(digits [n] (if (< n 10) (list n) (cons (mod n 10) (digits (quot n 10)))))]\n    (loop [n n seen #{}] \n      (let [d (digits n) s (apply + (map #(* % %) d))] \n        (if (= s 1) true (if (seen n) false (recur s (conj seen n))))))))", "user": "56d68cbae4b0ea9b8538f7cd"}, {"problem": 86, "code": "(fn [n]\n   (letfn [(gen [n]\n                (->> n\n                     str seq\n                     (map str)\n                     (map #(Integer/parseInt %))\n                     (map #(* % %))\n                     (reduce +)))]\n     (boolean (some #(= 1 %) (take 100 (iterate gen n))))))", "user": "56fbf83de4b07572ad1a88da"}, {"problem": 86, "code": "(fn happy [n]\n    (letfn [(digits [n]\n              (if (< n 10) (list (int n))\n                  (cons (mod n 10) (digits (Math/floor (/ n 10))))))]\n      (let [ns (digits n)\n            s (reduce #(+ %1 (Math/pow %2 2)) (Math/pow (first ns) 2) (rest ns))]\n        (if (= n 1)\n          true\n          (if (= n 4) false\n              (recur (int s)))))))", "user": "4f57c913e4b0a7574ea7183f"}, {"problem": 86, "code": "(fn [n]\n  (loop [i n a {}]\n    (cond (= i 1) true\n          (a i) false\n          :else (recur\n                 ((fn [n] (apply + (map (comp #(* % %) read-string)\n                                        (re-seq #\"\\d\" (str n))))) i)\n                 (conj a [i i])))))", "user": "57035ccfe4b08d47c97781ef"}, {"problem": 86, "code": "(fn happy? [n]\n  (letfn [(digits [n]\n            (map #(Integer/parseInt (str %)) (str n)))\n          (sum-of-squares [n]\n            (reduce + (map #(* % %) (digits n))))]\n    (boolean (some #{1} (take 100 (iterate sum-of-squares n))))))", "user": "570243e2e4b08d47c97781dd"}, {"problem": 86, "code": "(fn happy-number [x]\n    (let [digits (map #(Character/digit % 10) (seq (str x)))\n          looped '(37 58 89 145 42 20 4 16)]\n      (if (some #(= x %) looped)\n        false\n        (if (and (= (count digits) 1) (= (first digits) 1))\n          true\n          (happy-number (reduce + (map #(* % %) digits)))))))", "user": "57027310e4b08d47c97781e2"}, {"problem": 86, "code": "(fn [x]\n    (let [digits (map #(Character/digit % 10) (seq (str x)))\n          looped '(37 58 89 145 42 20 4 16)]\n      (if (some #(= x %) looped)\n        false\n        (if (and (= (count digits) 1) (= (first digits) 1))\n          true\n          (recur (reduce + (map #(* % %) digits)))))))", "user": "570b7d48e4b0b0fb43fd06c0"}, {"problem": 86, "code": "(fn happy [n]\n  (letfn [(sum-square [k] (loop [m k acc 0] (if (zero? m) acc (recur (quot m 10) (+ acc (* (rem m 10) (rem m 10)))))))]\n    (loop [m n]\n      (cond (contains? #{4 16 37 58 89 145 42 20} m) false\n            (= 1 m) true\n            :else (recur (sum-square m))))))", "user": "5292feb4e4b0239c8a67af39"}, {"problem": 86, "code": "(fn [x]\n  (case x\n    1 true\n    4 false\n    (recur (reduce (fn [acc y]\n                     (+ acc (* y y)))\n                   0\n                   (map (comp read-string str)\n                        (seq (str x)))))))", "user": "55f73078e4b06e875b46cea4"}, {"problem": 86, "code": "(fn is-happy [x]\n  (loop [y x\n         acc []]\n    (let [sum-squares (fn sum-squares [a]\n  (let [xs (str a)\n        ys (for [ch xs]\n             (-> (str ch)\n                 (Integer/parseInt)) )]\n    (reduce #(+ % (* %2 %2)) 0 ys)))\n          z (sum-squares y)]\n      (if (= z 1)\n        true\n        (if (some #(= z %) acc)\n          false\n          (recur z (conj acc z)))))))", "user": "54f86b8ce4b01ecee9d88828"}, {"problem": 86, "code": "(partial (fn [old new] \n           (let [happy (fn [x]\n                         (->>\n                          x\n                          (str)\n                          (seq)\n                          (map (comp read-string str))\n                          (reduce #(+ %1 (* %2 %2)) 0)  \n                         ) \n                       )\n                 ]\n             (if (contains? old new)\n               false\n               (if (= new 1)\n                 true\n                 (recur (conj old new) (happy new))\n               )\n             )\n           )\n         ) #{}\n)", "user": "57011eb3e4b08d47c97781d1"}, {"problem": 86, "code": "(fn [n]\n  (letfn [(sum-sq [num]\n            (reduce #(+ % (* %2 %2))\n                    0 (map (comp read-string str) (str num))))]\n    (loop [t (sum-sq n)\n           happened #{n}]\n      (if (= t 1)\n        true\n        (if (contains? happened t)\n          false\n          (recur (sum-sq t) (conj happened t)))))))", "user": "549eb44fe4b0f3d1d8e70fa6"}, {"problem": 86, "code": "(fn [num] (loop [n num, his #{}] (let [sum (reduce + (map #(* (Integer. (str %)) (Integer. (str %))) (str n)))] \n                                       (cond\n                                                                                              (contains? his sum) false \n                                                                                               (= 1 sum) true\n                                                                                              :else (recur sum\n                                                                                                           (conj his sum)))  ) ))", "user": "56a6051fe4b0542e1f8d14e5"}, {"problem": 86, "code": "(fn happy? [n]\n  (letfn [(digits [n] (map #(Character/getNumericValue %) (str n)))\n          (next-happy [n] (apply + (map #(* % %) (digits n))))]\n    (case n\n      1 true\n      4 false\n      (happy? (next-happy n)))))", "user": "56603e5fe4b068f2fe63dc4a"}, {"problem": 86, "code": "(fn [n]\n    (loop [n n seen? #{n}]\n      (let [digits (map #(- (int %) 48) (str n))\n            squares (map #(* % %) digits)\n            sum (apply + squares)]\n        (cond\n          (= 1 sum) true\n          (seen? sum) false\n          :else (recur sum (conj seen? sum))))))", "user": "56a76f36e4b07966d5a8a05b"}, {"problem": 86, "code": "(fn [n]\n  (let [seen (transient #{})]\n    (letfn [(unseen? [x]\n              (let [here (seen x)]\n                (conj! seen x)\n                (not here)))]\n      (= 1\n         (last (take-while unseen?\n                           (iterate (fn [n]\n                                      (->> (map str (str n))\n                                           (map #(Integer/parseInt %))\n                                           (map #(* % %))\n                                           (reduce +)))\n                                    n)))))))", "user": "5712854ce4b07c98581c3a89"}, {"problem": 86, "code": "(fn [n] (loop [x n s #{}] \n          (let [n1 (apply +  (map #(apply * (repeat 2 (- % 48))) (map int (str x))))] \n            (if (s n1) (= n1 1) (recur n1 (conj s n1))))))", "user": "5686b7c7e4b0dcc4269f4057"}, {"problem": 86, "code": "(fn [n]\n  (let [sq (fn [k] (* k k))\n        div (fn [k] (quot k 10))\n        rmd (fn [k] (rem k 10))\n        sum-sq-digits (fn [k]\n                        (loop [nm k sum 0]\n                          (if (zero? nm)\n                            sum\n                            (recur\n                              (div nm)\n                              (+ sum (sq (rmd nm)))))))]\n    (loop [next-sq-num n found #{}]\n      (if (= 1 next-sq-num)\n        true\n        (if (contains? found next-sq-num)\n          false\n          (recur (sum-sq-digits next-sq-num) (conj found next-sq-num)))))))", "user": "56cb4d06e4b0ea9b8538f72e"}, {"problem": 86, "code": "(partial\n (fn find-happy [acc curr]\n  (if (contains? acc curr)\n      false\n      (if (= 1 curr)\n          true\n          (let [digits (map #(read-string (str %)) (str curr))\n                result (apply + (map #(* % %) digits))]\n              (recur (conj acc curr) result)))))\n            #{})", "user": "55f8fd70e4b03cbcff9738bc"}, {"problem": 86, "code": "(fn [n]  \n  (let [get-digits (fn get-digits [n]\n                     (if (< n 10) \n                       [n] \n                       (conj (get-digits (quot n 10)) (mod n 10))))\n         to-happy (fn [n](reduce + (map #(* % %) (get-digits n))))         \n        ]\n     (= 1 (first (drop-while #(and (not= % 1) (not= % 4)) (iterate to-happy n))) )       \n  ))", "user": "54e345a1e4b024c67c0cf7db"}, {"problem": 86, "code": "(fn happy-number? [n]\n  (let [sad-cycle #{4 16 37 58 89 145 42 20}\n        aux (fn aux [current-n seen]\n              (cond (= current-n 1) true\n                    (or (sad-cycle current-n) (seen current-n)) false\n                    :else (recur (->> (str current-n)\n                                      (map #(Character/digit % 10))\n                                      (map #(* % %))\n                                      (reduce +))\n                                      (conj seen current-n))))]\n              (aux n #{})))", "user": "568e1871e4b0dcc4269f40cc"}, {"problem": 86, "code": "(fn happy? [n]\n  (letfn [(digits [n]\n            (loop [ret nil\n                   a n]\n              (if (zero? a)\n                (or ret '(0))\n                (recur (conj ret (mod a 10)) (quot a 10)))))\n          (happify [n]\n            (lazy-seq\n             (let [nextn (->> n\n                              digits\n                              (map #(* % %))\n                              (reduce +))]\n               (cons nextn\n                     (happify nextn)))))]\n    (loop [seen #{}\n           hseq (happify n)\n           h n]\n      (cond\n        (= 1 h) true\n        (seen h) false\n        true (recur (conj seen h) (rest hseq) (first hseq))))))", "user": "571d063ee4b0145328a76272"}, {"problem": 86, "code": "(letfn [(ds [n] (if (pos? n) (conj (ds (quot n 10)) (rem n 10)) []))\n        (sq-sum [n] (->> (ds n) (map #(* % %)) (reduce +)))]\n  #(->> % (iterate sq-sum) (some #{1 4}) (= 1)))", "user": "54055aa9e4b0addc1aec6665"}, {"problem": 86, "code": "(fn [input]\n    (let\n      [iter-func (fn [number]\n         (reduce + (map (fn [x] (-> x (str) (read-string) (#(* % %)))) (str number))))]\n      (= 1 (nth (iterate iter-func input) 1000))\n      )\n    )", "user": "529e8ba9e4b04e0c58e87b99"}, {"problem": 86, "code": "(fn y [x]\n  (let [sum (fn [z] (reduce + (map #(* % %) (map #(Character/getNumericValue %) (seq (str z)) ))))]\n     (loop [next_number x already_checked #{x}]\n       (let [r (sum next_number)]\n         (cond \n          \t(= 1 r) true\n            (contains? already_checked r) false\n          \t:else (recur r (conj already_checked r) )\n          )\n         \n       )\n       \n       \n     )\n   \n  )\n  \n  \n  \n  )", "user": "56db90d4e4b0ea9b8538f80d"}, {"problem": 86, "code": "(fn [n] (= \n         (first (drop-while #(not (#{1 4} %)) \n                              (iterate #(reduce + \n                                                (map (comp (fn [n] (* n n)) read-string str) (str %))) n))) \n         1))", "user": "555c6344e4b0b056612e224c"}, {"problem": 86, "code": "(fn [n]\n  (loop [sums #{} num n]\n    (let [sum-sq \n          (->> num\n               str\n               seq\n               (map #(Character/getNumericValue ^char %))\n               (map #(* % %))\n               (reduce +))]\n      (cond\n        (= 1 sum-sq) true\n        (contains? sums sum-sq) false\n        :else (recur (conj sums sum-sq) sum-sq)))))", "user": "536ecd9fe4b0fc7073fd6e76"}, {"problem": 86, "code": "(fn happy-number? [x]\n  (let [digits (fn [y] (->> y\n                            (iterate #(quot % 10))\n                            (take-while pos?)\n                            (mapv #(mod % 10))\n                            rseq))\n        square-sums (iterate (fn [coll] (apply + (map #(int (Math/pow % 2)) (digits coll)))) x)]\n    (= 1 (first (filter #(= 1 %) (take 10000 square-sums))))))", "user": "53504fe6e4b084c2834f4ada"}, {"problem": 86, "code": "(fn is-happy' [n]\n  (letfn [(square [x] (* x x))]\n    (cond (= 1 n) true\n          (= 4 n) false\n          :else (recur (->> n\n                            str\n                            seq\n                            (map #(-> %\n                                      str\n                                      (Integer/parseInt)\n                                      square))\n                            (apply +))))))", "user": "563fc1f2e4b08d4f616f5ed7"}, {"problem": 86, "code": "(let [->digits (fn [n]\n                   (->> (iterate (fn [[q r]] [(quot q 10) (rem q 10)]) [n])\n                        (take-while (fn [vs] (some (complement zero?) vs)))\n                        (map second)\n                        rest\n                        reverse\n                        (into [])))\n        sumsq-of-digits (fn [n]\n                          (->> n\n                               ->digits\n                               (map (fn [x] (*' x x)))\n                               (apply +')))\n        f (fn [n]\n            (loop [x n, seen #{}]\n              (if (seen x)\n                false\n                (let [x' (sumsq-of-digits x)]\n                  (if (== 1 x')\n                    true\n                    (recur x' (conj seen x)))))))]\n    f)", "user": "53684a2fe4b0243289761e8c"}, {"problem": 86, "code": "(fn [x] (= 1 (nth (iterate (fn [x] (reduce + (map #(* (- % 48) (- % 48)) (map int (seq (str x)))))) x) 42)))", "user": "5547b72be4b0a04f79299550"}, {"problem": 86, "code": "(fn happy [n]\n  (let [sq-n (fn [n]\n               (* n n))\n        parse-n (fn [n]\n                  (map read-string (map str (str n))))\n        seen? (fn [n a-set] (if (some #{n} a-set) true false))]\n  (loop [n n\n         ;;c 0\n         seen #{}]\n    (cond (= n 1) true\n          ;;(= c 50000) false\n          (seen? n seen) false\n          :else (recur (reduce + (map sq-n (parse-n n)))\n                       ;;(inc c)\n                       (conj seen n))))))", "user": "505d1b01e4b0e6aca564be04"}, {"problem": 86, "code": "(fn happy? [n]\n  (let [acc (conj #{} n)\n        split-num (fn split-num [n]\n                    (->> n\n                         str\n                         (map #(Integer/parseInt (str %)))\n                         (map #(* % %))\n                         (reduce +)))\n        ]\n    (loop [acc acc n (split-num n)]\n      (cond (contains? acc n) false\n            (= n 1) true\n        :else (recur (conj acc n) (split-num n))\n        ))\n    ))", "user": "56f4cedce4b046a417f92063"}, {"problem": 86, "code": "(fn\n f\n ([number] (f number 0))\n ([number counter]\n  (let\n   [x\n    (reduce\n     +\n     (map\n      (comp\n       (fn* [p1__2852#] (* p1__2852# p1__2852#))\n       (fn* [p1__2853#] (Integer/parseInt p1__2853#))\n       str)\n      (seq (str number))))]\n   (if (= x 1) true (if (= counter 10000) false (recur x (inc counter)))))))", "user": "56ab7578e4b03c432f18733d"}, {"problem": 86, "code": "(fn [x]\n  (letfn [(digits [x]\n            (let [digit (rem x 10)\n                  x (/ (- x digit) 10)]\n              (cons digit (when (pos? x) (digits x)))))\n          (square [x] (* x x))]\n    (loop [x x\n           visited #{}]\n      (let [x (->> (digits x) (map square) (apply +))]\n        (cond\n          (= 1 x) true\n          (visited x) false\n          :else (recur x (conj visited x)))))))", "user": "56dc3bdfe4b0ea9b8538f819"}, {"problem": 86, "code": "(fn [n]\n  (letfn [(calc [n]\n            (apply + (map #(let [a (Character/getNumericValue %)] (* a a)) (.toString n))))]\n  (loop [visited #{n} curr (calc n)]\n    (cond (= 1 curr) true\n          (contains? visited curr) false\n          :else (recur \n                  (conj visited curr)\n                  (calc curr))))))", "user": "541ddadbe4b01498b1a71a84"}, {"problem": 86, "code": "(fn [x]\n  (loop [prev x, past #{x}]\n    (let [digits ((fn f [y]\n                    (when-not (zero? y)\n                      (lazy-seq\n                        (cons (rem y 10)\n                              (f (quot y 10))))))\n                  prev)\n          new (reduce #(+ %1 (* %2 %2))\n                      0\n                      digits)]\n      (cond\n        (= new 1) true\n        (contains? past new) false\n        :else (recur new (conj past new))))))", "user": "573d58c8e4b05c31a32c0811"}, {"problem": 86, "code": "(fn [n]\n  (letfn [(ss [n]\n            (->> (seq (str n))\n                 (map #(- (int %) 48))\n                 (map #(* %1 %1))\n                 (reduce +)))]\n    (loop [nn (ss n) seen #{}]\n      (cond (= 1 nn) true\n            (seen nn) false\n            :else (recur (ss nn) (conj seen nn))))))", "user": "56102f50e4b05f002753df6b"}, {"problem": 86, "code": "(fn lucky-number [d]\n  (cond\n    (= d 0) false\n    (= d 1) true\n    (= d 4) false\n    :else\n      (recur ((fn summed-squared-digits [d]\n        (loop [res 0 d d]\n          (if (< d 10)\n            (+ res (* d d))\n            (recur (+ res ((fn [v] (* v v)) (mod d 10))) (quot d 10)))))\n       d))))", "user": "5739cbe4e4b0cd1946bd107c"}, {"problem": 86, "code": "(fn happy? [n]\n  (letfn [(from-ascii [l] (- l 48))\n          (digits [n] (map (comp from-ascii int) ((comp seq str) n)))\n          (happy [n] (reduce + (map #(* % %) (digits n))))]\n    (cond (= n 1)\n          true (= n 4) false\n          :else (happy? (happy n)))))", "user": "572ea970e4b0cd1946bd0f89"}, {"problem": 86, "code": "(fn happy [n]\n    (let [next-n (fn [n]\n                   (->> n\n                        str\n                        seq\n                        (map #(Integer/parseInt (str %)))\n                        (map #(* % %))\n                        (reduce +)))]\n      (loop [n n\n             history #{}]\n        (if (= n 1)\n          true\n          (if (contains? history n)\n            false\n            (recur (next-n n) (conj history n)))))))", "user": "56791447e4b05957ce8c6183"}, {"problem": 86, "code": "(fn [n]\n  (letfn [(square [x] (* x x))\n          (sum-squares [coll] (apply + (map square coll)))\n          (digits [n] (map #(Character/digit % 10) (str n)))]\n    (loop [n n loop-detect #{}]\n      (let [s (sum-squares (digits n))]\n        (cond (= s 1) true\n              (loop-detect s) false\n              :else (recur s (conj loop-detect s)))))))", "user": "57002b81e4b08d47c97781c7"}, {"problem": 86, "code": "(fn [n]\n  (= 1 ((fn [s n]\n          (let [i (fn [n] (reduce #(+ % (* %2 %2)) 0 (map #(- (int %) (int \\0)) (str n))))]\n            (if (contains? s n)\n              n\n              (recur (conj s n) (i n))))) #{} n)))", "user": "574af03ce4b02ea114799202"}, {"problem": 86, "code": "(fn [n]\n(let [cal (fn [n] (reduce +  0 (map #(let [d (- (int %) 48)] (* d d) ) (str n) ))) ]\n   (loop [ps #{n} cur n] \n       (let [nxt (cal cur)]\n          (if (= 1 nxt) true   (if (ps nxt)  false  (recur (conj ps nxt) nxt)  ) ) ) )  ) )", "user": "5735ac67e4b0cd1946bd102b"}, {"problem": 86, "code": "(fn [h] (letfn [(res [num] (reduce (fn [a c] (let [x (Integer/parseInt (str c))] (+ a (* x x)))) 0  (str num)))\n(happy [num] \n(println num)\n(cond \n (= 1 num) true\n (= 4 num) false\n :else (recur (res num))\n))]\n(happy h)))", "user": "5659679ae4b068f2fe63dbeb"}, {"problem": 86, "code": "(fn hn [s x] \n  (if (contains? s x) \n    (= 1 x) \n    (hn (conj s x) \n        (reduce #(let [s (read-string %2)] \n                   (+ %1 (* s s))) 0 (re-seq #\"\\d\" (str x)))))) #{}", "user": "573ce277e4b05c31a32c080b"}, {"problem": 86, "code": "(fn [n]\n  (loop [n n, visited #{}]\n    (println n)\n    (if (= n 1)\n      true\n      (let [m (reduce + (map #(* %1 %1) \n                             (map #(- (int %1) (int \\0))\n                                  (str n))))]\n      \t(if (visited m) \n            false\n            (recur m (conj visited m)))))))", "user": "57015a1de4b08d47c97781d4"}, {"problem": 86, "code": "(fn [x]\n  (let [sum-squares (fn [i] (apply + (map (comp #(* % %) read-string str) (str i))))\n        sums (atom #{})\n        ]\n    (loop [x x]\n      (cond (= x 1) true\n            (contains? @sums x) false\n            :else (do (swap! sums conj x)\n                      (recur (sum-squares x)))))))", "user": "57458b82e4b009280f9f2b4e"}, {"problem": 86, "code": "(fn [x]\n    (letfn [(sum-digit-squares [x]\n              (->> x str (map str) (map read-string) (map #(repeat 2 %)) (map (partial apply *)) (apply +)))\n\n            (digit-squares-sum-seq [x]\n              (let [nxt (sum-digit-squares x)]\n                (cons nxt (lazy-seq (digit-squares-sum-seq nxt)) )))]\n\n      (or (some (partial = 1) (take 10000 (digit-squares-sum-seq x)))\n        false)))", "user": "561814bae4b06b1bb2182a1a"}, {"problem": 86, "code": "(fn happy-number2 [n]\n  (letfn [(digits [n]\n            (loop [n n\n                   r '()]\n              (if (= n 0)\n                r\n                (let [rem (mod n 10)\n                      div (quot n 10)]\n                  (recur div (conj r rem))))))\n\n          (next-seq [n]\n            (let [sq (map #(* % %) (digits n))]\n              (apply + sq)))\n          ]\n    (loop [n n  \n           seq #{n}]\n      (let [n2 (next-seq n)]\n        (if (= 1 n2)\n          true\n          (if (contains? seq n2)\n            false\n            (recur n2 (conj seq n2))))))))", "user": "574f1c24e4b02ea114799255"}, {"problem": 86, "code": "(fn [x]\n  (loop [hist #{}\n         x x]\n    (or (= x 1)\n        (let [y (->> x\n                     str\n                     (map str)\n                     (map #(Integer/parseInt %))\n                     (map #(* % %))\n                     (apply +))]\n          (and (not (contains? hist y))\n               (recur (conj hist y) y))))))", "user": "575cbe44e4b02ea114799374"}, {"problem": 86, "code": "(fn [number]\n  (letfn [(digits [n] (map #(Character/digit % 10) (str n)))\n          (square [n] (* n n))]\n    (loop [n number\n           seen #{}]\n      (if (seen n) false\n        (let [newNum (->> n (digits) (map square) (apply +))]\n                          (if (= 1 newNum) true\n                            (recur newNum (conj seen n) )\n                            \n                            ) \n                          )\n        )\n      )\n    )\n  )", "user": "575ef4b6e4b08062f99a4e78"}, {"problem": 86, "code": "(fn happy?\n      [n]\n      (letfn [(digits [n] \n                (map #(Integer/parseInt (str %)) (str n)))\n              (sum-of-squares [n]\n                (reduce + (map #(* % %) (digits n))))]\n        (boolean (some #{1} (take 100 (iterate sum-of-squares n))))))", "user": "570bd29be4b0b0fb43fd06c5"}, {"problem": 86, "code": "(fn happynumber? [n]\n  (loop [seen #{n} current n]\n    (let [digitarray (map #(Character/digit % 10) (str current))\n          sum (reduce #(+ % (* %2 %2)) 0 digitarray)]\n      (cond\n        (= 1 sum) true\n        (contains? seen sum) false\n        :else (recur (into seen #{sum}) sum)))))", "user": "57131dfbe4b07c98581c3a98"}, {"problem": 86, "code": "(fn [n]\n  (loop [n n, seen #{}]\n    (cond\n      (= n 1) true\n      (seen n) false\n      :else\n      (recur (->> (str n)\n                  (map #(Character/digit % 10))\n                  (map #(* % %))\n                  (apply +)) (conj seen n)))))", "user": "57642916e4b0994c1922fbee"}, {"problem": 86, "code": "(fn happy?\n  [n]\n  (let [ssod (fn [n]\n               (reduce +\n                       (map #(* % %)\n                            (map (comp read-string str) (str n)))))]\n    (loop [num n seen #{}]\n      (cond (= num 1) true\n            (seen num) false\n            :else (let [sum (ssod num)]\n                    (recur sum (conj seen num)))))))", "user": "52ea025ae4b09f7907dd14b5"}, {"problem": 86, "code": "(fn [n]\n    (contains? \n     (let [digits (fn [x]\n                    (map\n                     #(Integer/valueOf %)\n                     (filter\n                       #(not (empty? %))\n                       (clojure.string/split (str x) #\"\"))))\n           happy (fn [x] \n                   (reduce + (map #(* % %) (digits x))))]\n       (loop [results #{}\n              x n]\n         (if\n             (contains? results x)\n           results\n           (recur (conj results x) (happy x))))) 1))", "user": "53c1b787e4b00fb29b221266"}, {"problem": 86, "code": "(fn [x]\n  ((fn [testnum]\n    (let [digits (map read-string (map str (seq (str (last testnum)))))\n          digitsum (apply + (map #(* % %) digits))]\n      (if (= 1 digitsum)\n        true\n        (if (some #(= % digitsum) testnum)\n          false\n          (recur (conj testnum digitsum))))))\n   [x]))", "user": "5705e404e4b0b0fb43fd0676"}, {"problem": 86, "code": "(fn [x]\n  (loop [x x\n         seen #{}]\n    (if (seen x)\n      false\n      (let [n (apply + (map (comp #(* % %) read-string) (re-seq #\"\\d\" (str x))))]\n        (if (= 1 n)\n          true\n          (recur n (conj seen x)))))))", "user": "57609d91e4b08062f99a4e9b"}, {"problem": 86, "code": "(fn [number]\n  (loop [n       number\n         checked #{}]\n    (cond (= n 1) true\n          (contains? checked n) false\n          :else\n          (let [square     #(* % %)\n              new-number (->> n\n                              str\n                              (map #(square (- (int %) (int \\0))))\n                              (apply +))]\n          (recur new-number (conj checked n))))))", "user": "56372c3ce4b0bfe05bf117d1"}, {"problem": 86, "code": "(fn happy?\n  ([n] (happy? n 1))\n  ([n i]\n   (let [m (apply + (map\n                     #(* % %)\n                     (loop [n n digits []]\n                       (if (< n 10)\n                         (cons (int n) digits)\n                         (recur \n                          (quot n 10)\n                          (cons (int (rem n 10)) digits))))))]\n     (if (= 1 m)\n       true\n       (if (= i 1000)\n         false\n         (happy? m (inc i)))))))", "user": "57533bc1e4b02ea1147992a6"}, {"problem": 86, "code": "(fn f ([x] (f x #{})) \n         ([x m] (if (contains? m x)\n                  (= x 1)\n                  (f (apply + (map (comp #(* % %) #(Character/getNumericValue %)) (str x))) (conj m x)))))", "user": "576e3258e4b0979f89651574"}, {"problem": 86, "code": "(fn hn [n]                                                                                                            \n  ((fn [n ss]                                                                                                           \n     (let [sum (apply + (map #(* % %) (map #(- (int %) 48) (vec (str n)))))]                                            \n       (cond                                                                                                            \n         (= 1 sum) true                                                                                                 \n         (contains? ss sum) false                                                                                       \n         :else (recur sum (conj ss sum))                                                                                \n         )                                                                                                              \n       )                                                                                                            \n    ) n []))", "user": "56d91a53e4b0ea9b8538f7ee"}, {"problem": 86, "code": "(fn is_happy [number]\n    (loop [ seen_n (set nil)\n            n   number]\n        (cond \n            (= n 1) true\n            (contains? seen_n n) false\n            :else (recur (conj seen_n n) \n                        (->>    (str n)\n                               (map #(Character/digit % 10))\n                               (map #(* % %))\n                               (reduce +))))))", "user": "57644395e4b0994c1922fbf2"}, {"problem": 86, "code": "(fn happy?  \n  ([n] (happy? n 0))\n  ([n c]\n   (let [h (reduce + (map #(* % %) (read-string (str \"[\" (clojure.string/join \" \" (str n)) \"]\"))))]\n  (if (= n h)\n    true \n    (if (> c 8)\n     false \n     (happy? h (inc c)))))))", "user": "534fa9dae4b084c2834f4acf"}, {"problem": 86, "code": "(fn [num]\n  (letfn [(happy [x] (reduce #(+ %1 (* %2 %2)) 0 (map (comp read-string str) (str x))))]\n    (loop [num num\n           acc #{}]\n      (let [h (happy num)]\n        (cond\n         (= 1 h) true\n         (acc h) false\n         :else (recur h (conj acc h)))))))", "user": "53e9dce1e4b036ad0777e4bc"}, {"problem": 86, "code": "(fn happy [n]\n  \n  (let [step \n        (fn [n] (->> (str n) \n                     (map #(- (int %) (int \\0))) \n                     (map #(* % %))\n                     (reduce +)))\n          ]\n          (->> \n           (iterate (fn [[s i]]\n                      (let [x (step i)]\n                        (if (contains? s x) nil\n                          [(into s [x]) x] )\n                        ))\n                    [#{} n] )\n           (take-while not-empty)\n           (last)\n           (last)\n           (#(= 1 %)))))", "user": "533a2f7be4b0e30313ee6cb8"}, {"problem": 86, "code": "#(letfn [\n  (sum-squares [n]\n    (let [int-seq (fn [n]\n                    (let [str-int (fn [s] (Integer/parseInt s))\n                          char-int (fn [c] ((comp str-int str) c))]\n                      (map char-int ((comp seq str) n))))\n          square (fn [n] (* n n))]\n       (reduce + (map square (int-seq n)))))\n\n  (numbers [n]\n    (lazy-seq\n      (cons n (numbers (sum-squares n)))))\n\n  (duplicates? [col]\n    (let [c (vec (butlast col))\n          d (last col)]\n      (contains? c d)))\n\n  (is-magic-number?\n    ([col] (is-magic-number? 0 col))\n    ([n col]\n      (cond \n        (= 1 (first (drop n col)))  true\n        (duplicates? (take n col))  false\n        :else                       (recur (inc n) col))))]\n  (is-magic-number? (numbers %)))", "user": "55d1ec3ee4b0e31453f64a4c"}, {"problem": 86, "code": "(fn happy[n]\n  (let [stx (str n)\n        l (fn ehsan[x](if (seq x) (cons (- (int (first x)) 48) (ehsan (next x)))))\n        sumsq (fn j[x y] (+ x (* y y)))\n        j (reduce sumsq 0 (l stx))]\n    (if (< j 10)\n      (= 1 j)\n      (happy j)\n      )\n    )\n  )", "user": "5731e36be4b0cd1946bd0fc9"}, {"problem": 86, "code": "(fn [n]\n  (boolean\n   (letfn [(sqr [n] (* n n))\n           (digitize [n] (map #(- (int %) (int \\0)) (str n)))]\n     (loop [n n, seen? #{}]\n       (when-not (seen? n)\n         (if (= 1 n)\n           true\n           (recur (apply + (map sqr (digitize n))) (conj seen? n))))))))", "user": "5764457ae4b0994c1922fbf3"}, {"problem": 86, "code": "(fn [n] (not (#{2 3} n)))", "user": "574dfcb8e4b02ea11479923a"}, {"problem": 86, "code": "(fn [n]\n  (letfn [(happy [nn]\n                 (apply + (map (comp #(* % %) read-string str) (str nn))))]\n    (cond\n     (= 1 (happy n)) true\n     (= 4 (happy n)) false\n     :else (recur (happy n)))))", "user": "574abbfbe4b02ea114799200"}, {"problem": 86, "code": "(fn happy-number? [n]\n  (letfn [(sum-square-digits [n] (apply + (map (comp #(* % %) read-string str) (seq (str n)))))]\n    (loop [cur (sum-square-digits n) seen (hash-set n)]\n      (cond (= cur 1)  true\n            (seen cur) false\n            :else      (recur (sum-square-digits cur) (conj seen cur))))))", "user": "575b3e9be4b02ea11479935b"}, {"problem": 86, "code": "(letfn [(digits [n] (map #(Character/digit % 10) (str n)))\n        (squaredsum [ds] (apply + (map * ds ds)))]\n  (fn happy? [n]\n    (loop [happies #{} n n]\n      (let [hn (squaredsum (digits n))]\n        (cond\n          (= 1 hn) true\n          (contains? happies hn) false\n          :else (recur (conj happies hn) hn))))))", "user": "50d3ec8be4b030b634c368bb"}, {"problem": 86, "code": "(fn happy? [n]\n    (loop [i n seen? #{}]\n      (let [nxt (reduce + (map (comp #(* % %) read-string str) (str i)))]\n        (cond\n          (= nxt 1)   true\n          (seen? nxt) false\n          :else       (recur nxt (conj seen? i))))))", "user": "4dfe5a93535d04ed9115e786"}, {"problem": 86, "code": "(fn p86 [n] \n  (let [m (reduce + (map (comp #(* % %) #(- % 48) int) (str n )))] \n    (println m)\n    (condp = m\n        0 false\n        1 true\n        4 false\n          (recur m))))", "user": "4fc4eb1ee4b081705acca354"}, {"problem": 86, "code": "(fn happy?\n  ([n] (happy? n 1))\n  ([n i]\n   (let [m (apply + (map\n                     #(* % %)\n                     (loop [n n digits []]\n                       (if (< n 10)\n                         (cons (int n) digits)\n                         (recur \n                          (quot n 10)\n                          (cons (int (rem n 10)) digits))))))]\n     (if (= 1 m)\n       true\n       (if (= i 1000)\n         false\n         (happy? m (inc i)))))))", "user": "5798205ce4b039eba2ecb10e"}, {"problem": 86, "code": "(fn happy?\n  ([n] (happy? n 1))\n  ([n i]\n   (let [m (apply + (map\n                     #(* % %)\n                     (loop [n n digits []]\n                       (if (< n 10)\n                         (cons (int n) digits)\n                         (recur \n                          (quot n 10)\n                          (cons (int (rem n 10)) digits))))))]\n     (if (= 1 m)\n       true\n       (if (= i 1000)\n         false\n         (happy? m (inc i)))))))", "user": "57982bace4b039eba2ecb10f"}, {"problem": 86, "code": "(fn happy [n]\n  (if (= n 1)\n    true\n    (if (= n 4)\n      false\n      (let [digits (map #(- (int %) 48) (str n))]\n        (recur (reduce + (map #(* % %) digits)))))))", "user": "55ede35ce4b0121d4835fde1"}, {"problem": 86, "code": "(fn __\n  ([n] (__ n #{}))\n  ([n s]\n   (let [next\n         (->> (map #(Character/getNumericValue %) (str n))\n              (map #(* % %))\n              (apply +))]\n     (if (= 1 next)\n       true\n       (if (s next)\n         false\n         (__ next (conj s n)))))))", "user": "55c4cda5e4b0e31453f649a5"}, {"problem": 86, "code": "(fn [n] \n  (loop [m '()\n         c n]\n    (if (some #(= c %) m)\n    (= c 1)\n      (recur \n       (conj m c)\n       (->>\n        (str c)\n        (map str)\n        (map bigint)\n        (map #(* % %))\n        (reduce +))))))", "user": "578cf84ce4b0ebec4cfb7562"}, {"problem": 86, "code": "(fn [n]\n  (loop [done #{} n n]\n    (if (= n 1)\n      true\n      (let [char->int #(- (int %) 48)\n            numbers (map char->int (str n))\n            new-n (reduce + (map #(* % %) numbers))\n            ]\n        (if (contains? done new-n)\n          false\n          (recur (conj done new-n) new-n))\n        )\n      )\n    )\n  )", "user": "5776558ee4b0979f89651633"}, {"problem": 86, "code": "(fn [n]\n  (loop [seen #{}\n         x n]\n    (let [digits (map #(Character/digit % 10) (str x))\n          sq (reduce + (map #(* % %) digits))]\n      (cond (= sq 1) true\n            (seen sq) false\n            :else (recur (conj seen sq) sq)))))", "user": "530e75d5e4b08068f379ecba"}, {"problem": 86, "code": "(fn [n]\n  (let [su (fn [nn]\n               (let [nns (map #(- (int %) (int \\0)) (seq (str nn)))]\n                 (reduce #(+ %1 (* %2 %2)) 0 nns)))]\n    (loop [his [] check n]\n      (if (= (su check) 1)\n        true\n        (if (> (.indexOf his check) -1)\n          false\n          (recur (conj his check ) (su check))  \n          )\n        )\n      )\n    )\n  )", "user": "579601c8e4b0e215f87e8492"}, {"problem": 86, "code": "(letfn\n  [\n  (digits [n]\n    (let [[ds n]\n      (last (take-while\n        (comp (complement zero?) second)\n        (iterate\n          (fn [[ds n]] [(conj ds (mod n 10)) (int (/ n 10))])\n          [[] n])))]\n      (conj ds n)))\n\n  (step [n]\n    (let [ds (digits n)]\n      (->> ds (map #(* % %)) (reduce +))))\n\n  (is-happy [n]\n    (let [[seen now]\n      (first (drop-while\n        (fn [[seen now]] (not (or (seen now) (= 1 now))))\n        (take 1000 (iterate\n          (fn [[seen now]] [(conj seen now) (step now)])\n          [#{} n]))))]\n      (= now 1)))]\n  is-happy)", "user": "57717915e4b0979f896515b3"}, {"problem": 86, "code": "(fn myf2 [n]\n  (letfn [(sq-sum [n]\n            (->> (str n)\n              vec\n              (map #(Math/pow (- (int %) 48) 2))\n              (apply +)\n              int))]\n    (loop [n n, coll #{}]\n      (cond (= (sq-sum n) 1) true\n        (contains? coll (sq-sum n)) false\n        :else (recur (sq-sum n) (conj coll (sq-sum n)))))))", "user": "577c3da9e4b0c8d87281f6b9"}, {"problem": 86, "code": "(fn [x] (= 1 (last (take 100 \n\t((fn happy [n] \n\t\t(lazy-seq \n\t\t\t(cons n \n\t\t\t\t(happy (apply + (map (comp (fn [x] (* x x)) read-string str) (vec (str n)))))))) x)))))", "user": "57986b76e4b039eba2ecb116"}, {"problem": 86, "code": "(fn is\n  ([num]\n   (let [ans ((fn\n  [var]\n  (loop [tmp var sum 0]\n    (if (>= tmp 1)\n      (recur (unchecked-divide-int tmp 10) (+ sum (* (rem tmp 10) (rem tmp 10))) )\n      sum))) num)]\n     (if (= ans 1)\n       true\n       (is ans (vector ans)))))\n  ([num arr]\n   (let [ans ((fn \n  [var]\n  (loop [tmp var sum 0]\n    (if (>= tmp 1)\n      (recur (unchecked-divide-int tmp 10) (+ sum (* (rem tmp 10) (rem tmp 10))) )\n      sum))) num)]\n     (if (= ans 1)\n       true\n       (if (.contains arr ans)\n         false\n         (recur ans (conj arr ans)))\n)))\n)", "user": "5772ddb0e4b0979f896515d4"}, {"problem": 86, "code": "(fn [n]\n  (loop [seen #{}\n         n n]\n    (cond (= n 1) true\n          (seen n) false\n          :else\n          (recur (conj seen n)\n                 (apply + (map #(let [a (- (int %) 48)]\n                                  (* a a))\n                               (str n)))))))", "user": "56903cb9e4b0dcc4269f40eb"}, {"problem": 86, "code": "(fn f\n  ([cur stp]\n   (let [nxt (->> cur\n                  str\n                  (map #(- (int %) (int \\0)))\n                  (map #(* % %))\n                  (apply +))]\n     (if (= nxt 1)\n       true\n       (if (stp nxt)\n         false\n         (recur nxt (conj stp cur))))))\n  ([x] (f x #{})))", "user": "5799ff45e4b05b1deef9add1"}, {"problem": 86, "code": "(fn happy-number?\n    ([n]\n      (happy-number? n #{})\n    )\n    ([n previous-numbers]\n      (let\n        [\n          digits\n          (fn [n]\n            (map\n              (fn [c]\n                (read-string\n                  (str c)\n                )\n              )\n              (str n)\n            )\n          )\n\n          square\n          (fn [n]\n            (* n n)\n          )\n\n          n'\n          (apply +\n            (map\n              square\n              (digits n)\n            )\n          )\n        ]\n        (cond\n          (= n' 1)\n            true\n          (contains? previous-numbers n')\n            false\n          :else\n            (recur\n              n'\n              (conj previous-numbers n')\n            )\n        )\n      )\n    )\n  )", "user": "5784e177e4b0ebec4cfb74cf"}, {"problem": 86, "code": "(fn happy? [n]\n  (letfn \n    [\n      (hs [a]\n        (loop [x a d 0]\n          (if (< x 10)\n            (+ d (* x x))\n            (recur (quot x 10) (+ d (* (rem x 10) (rem x 10))))\n          )\n        )\n      )\n    ]\n    (= 1\n       (loop [x n v #{}]\n         (if (v x)\n           x\n           (recur (hs x) (conj v x))\n         )\n       )\n    )\n  )\n)", "user": "57873017e4b0ebec4cfb7503"}, {"problem": 86, "code": "(fn[start]\n  (let [f (fn [n]\n          (->>\n            (loop [r (quot n 10) s [(mod n 10)]]\n              (if (zero? r) s (recur (quot r 10) (conj s (mod r 10)))))\n            (map (fn [x] (* x x)))\n            (reduce +)))]\n  (loop [fx (f start) fails #{}]\n    (cond\n      (#{1} fx) true\n      (fails fx) false\n      :else (recur (f fx) (conj fails fx))))))", "user": "57b3efb1e4b0fbc9809a278a"}, {"problem": 86, "code": "(fn is-happy? \n  ([x] (is-happy? '() x))\n  ([previous x]\n   (let [squared-sum (->> x str (map #(. Integer parseInt (str %))) (map #(* % %)) (reduce +))] \n     (cond (= squared-sum 1) true\n           (some #{squared-sum} previous) false\n           :else (is-happy? (conj previous squared-sum) squared-sum)))))", "user": "4e9ff8d0535d7eef3080729c"}, {"problem": 86, "code": "(fn [z]\n (letfn [ \n  (squareIt [x]\n   (reduce \n      #(+ %1  (* %2 %2)) \n      0\n      (map \n             #(Integer/parseInt %)  \n             (rest (clojure.string/split  (str x) #\"\")    )\n      )\n    )\n  )\n  (isHappyNumber [x seen]\n     (let [y (squareIt x)]\n       (cond \n        (= 1 y)  true\n        (contains? seen x) false\n        :else (isHappyNumber y (conj seen y))        \n    ))\n  )  \n ]\n \n  (isHappyNumber z [])\n) \n)", "user": "56e6e1e6e4b02e7e935eb6cf"}, {"problem": 86, "code": "(fn f\n  ([n] (f n #{}))\n  ([i r]\n    (let [e (apply + (map #(* % %) (map #(Long/valueOf %)\n              (re-seq #\"\\d\" (str i)))))]\n    (if (= e 1) true (if (r e) false (f e (conj r e)))))))", "user": "548b7db8e4b0e286459a11fd"}, {"problem": 86, "code": "(fn [x]                                                                         \n    (loop [s 0 i x r #{}]                                               \n          (if (= i 0)                                                           \n              (if (= s 1)                                                     \n                  true                                                          \n                (if (r s)                                               \n                    false                                                       \n                  (recur 0 s (conj r s))))                            \n            (let [d (mod i 10)]                                                 \n              (recur (+ s (* d d)) (int (/ i 10)) r)))))", "user": "55316b8ae4b076ab5578f825"}, {"problem": 86, "code": "(fn happy [n]\n    (println n)\n    (cond (= n 4) false\n          (= n 1) true\n          :else   (let [ssd (->> (str n)\n                                 (map #(- (int %) (int \\0)))\n                                 (map #( * % % ))\n                                 (reduce +)\n                                 )]\n                    (recur ssd)\n                    )\n          )\n    )", "user": "57aa290de4b0b8559636fc65"}, {"problem": 86, "code": ";(defn int2seq [num] (if (< num 10) (list num) (conj (int2seq (quot num 10)) (rem num 10))))\n;(defn f[x] ( reduce #(+ %1 (* %2 %2)) 0 (int2seq x))))\n(fn happy-number? [num]\n  (loop [n num s #{}] \n    (if (= 1 n) \n      true \n      (if (s n) \n        false \n        (recur ((fn [x] (reduce #(+ %1 (* %2 %2)) 0 ((fn [num] (if (< num 10) (list num) (conj ((fn int2seq [num] (if (< num 10) (list num) (conj (int2seq (quot num 10)) (rem num 10)))) (quot num 10)) (rem num 10))) ) x))) n) (conj s n) ) ) )))", "user": "558bdcefe4b0277789237633"}, {"problem": 86, "code": "(fn get-happy\n  ([x](get-happy x #{}))\n  ([x used]\n   (if (= x 1)\n     true\n     (let\n      [new-list (sort (->> x\n                      (iterate #(quot % 10))\n                      (take-while pos?)\n                      (mapv #(mod % 10))\n                      rseq))\n       new-num (reduce\n                #(+ (* %2 %2) %1)\n                0 new-list)]\n      (if (contains? used new-list)\n        false\n        (recur \n         new-num \n         (conj used new-list)))))))", "user": "574eb3b1e4b02ea114799247"}, {"problem": 86, "code": "(fn happy?\n  ([x] (happy? x #{}))\n  ([x history]\n   (let [digits (map #(- (int %) (int \\0)) (str x))\n         summed (apply + (map #(* % %) digits))]\n     (cond (= summed 1) true\n           (history summed) false\n           :else (recur summed (conj history summed))))))", "user": "5617a540e4b06b1bb2182a12"}, {"problem": 86, "code": "(fn happy1\n\n    ([n] (happy1 n #{n}))\n\n    ([n unhappy]\n\n     (println n unhappy)\n\n     (let [ds  (map str (str n))                    \n\n           digits  (map read-string ds)\n\n           squares (map #(* % %) digits)\n\n           sum     (apply + squares)]\n\n      [digits squares sum]\n\n      (cond \n\n        (= 1 sum) true\n\n        (contains? unhappy sum) false\n\n        :else (happy1 sum (conj unhappy sum))))))", "user": "57487084e4b009280f9f2b8c"}, {"problem": 86, "code": "(fn happy?\n  ([n] (happy? n #{n}))\n  ([n s]\n   (let [m (->> (clojure.string/split (str n) #\"\")\n                (remove #{\"\"})\n                (map (comp #(* % %) #(Integer. %)))\n                (apply +))]\n     (cond\n       (= 1 m) true\n       (contains? s m) false\n       true (happy? m (conj s m))))))", "user": "57a0b341e4b0c3d858beb8d4"}, {"problem": 86, "code": "(fn happynumber [n]\n   (cond (= n 1) true\n         (= n 4) false\n         :ELSE\n           (recur (apply +\n             (map (fn [m] (let [x (- (int m) 48)] (* x x)))\n                  (seq (str n)))))))", "user": "579d9601e4b05b1deef9ae18"}, {"problem": 86, "code": "{7 true 986543210 true 2 false 3 false}", "user": "57aa4775e4b0b8559636fc6b"}, {"problem": 86, "code": "(fn [n]\n  (let [v (reduce + (map #(* % %) (for [x (str n)] (- (int x) 48))))]\n    (cond\n      (= 1 v) true\n      (= 4 v) false\n      :else (recur v))))", "user": "56cf115de4b0ea9b8538f765"}, {"problem": 86, "code": "(fn happy-number? [n]\n  (letfn [(sum-square-digits [n]\n            (loop [x n, rslt 0]\n              (if (= 0 x) rslt\n                  (let [r (rem x 10)] (recur (quot x 10) (+ rslt (* r r)))))))]\n    (loop [x n, ssd (sum-square-digits x),  ms #{}]\n      (if (= 1 ssd)\n        true\n        (if (contains? ms x)\n          false\n          (recur ssd (sum-square-digits ssd) (conj ms x)))))))", "user": "572ec4dde4b0cd1946bd0f8d"}, {"problem": 86, "code": "(fn happy-numbers [n]\n  (let [m {\\0 0 \\1 1 \\2 2 \\3 3 \\4 4 \\5 5 \\6 6 \\7 7 \\8 8 \\9 9}\n        parse-digits\n        (fn [n] (mapv m (str n)))\n        sum-of-squares\n        (fn [nums]\n          (apply + (map #(* % %) nums)))]\n    (loop [ret n vists #{} cnt 0]\n      (cond\n        (= ret 1) true\n        (contains? vists ret) false\n        :else\n        (recur (sum-of-squares (parse-digits ret)) \n               (conj vists ret) (inc cnt))))))", "user": "571c2babe4b07c98581c3b73"}, {"problem": 86, "code": "(fn happy?\n\t([n] (happy? n #{})) \n\t([n seen-numbers]\n\t\t(letfn [(happy-ize [n] (reduce + (map #(* (Character/digit % 10) (Character/digit % 10)) (into [] (str n)))))]\n\t\t\t(cond\n\t\t\t\t(= n 1) true\n\t\t\t\t(contains? seen-numbers n) false\n\t\t\t\t:else (happy? (happy-ize n) (conj seen-numbers n))))))", "user": "57c0917be4b05aa3c4741c95"}, {"problem": 86, "code": "(fn step [nums]\n  (let [str-num       (str nums)\n        cardinality   (count str-num)\n        num           (first str-num)]\n    (if (= cardinality 1)\n      (if (#{\\1 \\7} num)\n        true\n        false)\n      (->> nums\n           str\n           (map #(->> %\n                      str\n                      ((fn [x] (Integer/parseInt x)))\n                      ((fn [x] (* x x)))))\n           (apply +)\n           step))))", "user": "557e56aae4b05c286339e0d5"}, {"problem": 86, "code": "(fn happy-num? [n]\n  {:pre [(pos? n)]}\n  (letfn [(digits [n] (map #(Character/getNumericValue %1) (str n)))\n          (square-sum [xs] (long (reduce  #(+ %1 (Math/pow %2 2)) 0 xs)))]\n    (loop [loop-detection #{}\n           i              n]\n      (let [sum (square-sum (digits i))]\n        (cond\n         (= 1 sum) true\n         (contains? loop-detection sum) false\n         :else (recur (conj loop-detection sum) sum))))))", "user": "57c500f9e4b05aa3c4741cda"}, {"problem": 86, "code": "(fn happy [n]\n  (cond \n    (= n 1) true\n    (= n 4) false\n    (< n 10) (happy (* n n))\n    :else (happy  (apply + (map #(* (Integer/parseInt (str %)) (Integer/parseInt (str %))) (str n))))))", "user": "57d9bca1e4b0bd073c202405"}, {"problem": 86, "code": "(fn h\n    [num]\n    (letfn [(get-digits\n              ([num result]\n               (if (> num 0)\n                 (conj (get-digits (int (/ num 10)) result) (mod num 10))\n                 result))\n              ([num]\n               (get-digits num [])))\n            (sum-of-squares\n              [coll]\n              (reduce #(+ %1 (* %2 %2)) 0 coll))]\n      (= 1 (last (take 10 (iterate (comp sum-of-squares get-digits) num))))))", "user": "57d0cd58e4b0bd073c20235e"}, {"problem": 86, "code": "(fn [num]\n  (loop [n num so-far (hash-set num)]\n    (let [next-n (reduce #(+ %1 (* (Integer/parseInt (str %2)) (Integer/parseInt (str %2)))) 0 (seq (str n)))]\n      (if (contains? so-far next-n) \n              false\n              (if (= 1 next-n) true (recur next-n (conj so-far next-n)))))\n    )\n  )", "user": "57c6aa0be4b05aa3c4741cf7"}, {"problem": 86, "code": "(fn happy? [n]\n  (let [digs (fn digs [n]\n               (if (< n 10) [n]\n                   (conj (digs (int (/ n 10))) (mod n 10))))\n        sumdigs (fn [n]\n                  (apply + (map #(* % %) (digs n))))]\n    (loop [test n\n           seen #{}]\n      (let [sd (sumdigs test)]\n        (cond\n          (= sd 1) true\n          (some #{sd} seen) false\n          :default\n          (recur sd (conj seen sd)))))))", "user": "56f9c7c6e4b07572ad1a88ba"}, {"problem": 86, "code": "(letfn [(num->digits [num]\n          (loop [n num res []]\n            (if (zero? n)\n              res\n              (recur (long (/ n 10)) (cons (mod n 10) res)))))\n        (change [n]\n          (apply + (map #(* % %) (num->digits n))))]\n  (fn [init]\n    (loop [curr init results #{}]\n      (println curr \" - \" results)\n      (cond\n       (= 1 curr) true\n       (results curr) false\n       :else (let [new-n (change curr)]\n               (println curr new-n)\n               (recur new-n (into results [curr])))\n       )))\n  )", "user": "57df309ee4b0bd073c20245f"}, {"problem": 86, "code": "(fn [x]\n  (let [digits     (fn [i] (map #(- (int %) 48) (str i)))\n        sum-square (fn [x] (apply + (map #(* % %) (digits x))))\n        iter       (iterate sum-square x)\n        last-one   (last (take 100 iter))]\n   (= last-one 1)))", "user": "57e139f6e4b0bfb2137f5a6c"}, {"problem": 86, "code": "(fn happy? [x]\n  (let [sq (comp  #(. Math round %) #(. Math pow % 2))\n        nts (fn [x]\n             (map (comp #(. Integer parseInt %) #(.toString %)) (.toString x)))\n        ssq (fn [x]\n             (let [c (nts x)]\n               (reduce + (map sq c))))\n        f (fn [s x]\n           (let [ss (ssq x)]\n             (if (contains? s ss) false\n               (if (= 1 ss) true\n                 (recur (conj s ss) ss)))))]\n    (f #{} x)))", "user": "57d1d6c8e4b0bd073c202370"}, {"problem": 86, "code": "(fn happy?\n    ([n]\n     (happy? 1 n))\n    ([i n]\n     (if (> i 1000)\n       (do\n         (println i)\n         false)\n       (let [digits (->> n\n                         str\n                         seq\n                         (map (comp int bigint str)))\n             sum-of-squares (apply +' (map #(*' % %) digits))]\n         (if (= 1 sum-of-squares)\n           true\n           (happy? (inc i) sum-of-squares))))))", "user": "57e0f30ae4b0bfb2137f5a66"}, {"problem": 86, "code": "(fn happy \n  ([n] (happy n []))\n  ([n numbers]\n   (let [digits-square (fn [n]\n                        (reduce + (map (comp\n                                         (fn [x] (* x x))\n                                         #(- (int %) 48))\n                                       (str n))))\n         sum (digits-square n)]\n     (cond \n       (= sum 1) true\n       (contains? numbers sum) false\n       :else (recur sum (conj numbers sum))))))", "user": "574e84e0e4b02ea114799243"}, {"problem": 86, "code": "(fn happy-number?\n  ([num] (happy-number? [] num))\n  ([col num]\n   (let [s (loop [n num s 0]\n            (if (= n 0)\n              s\n              (recur (quot n 10) (let [r (rem n 10) sqr (* r r)] (+ s sqr)))))\n         ]\n     (if (= s 1)\n       true\n       (if (nil? (some #(= s %) col))\n         (recur (conj col s) s)\n         false)))))", "user": "576df252e4b0979f8965156f"}, {"problem": 86, "code": ";;(fn h\n;;  ([x] (h x 1))\n;;  ([x y] (let [digits #(map (zipmap (map char (range 48 58)) (range 10)) (str %))\n;;               happy #(apply + (map (fn [a] (* a a)) (digits %)))]\n;;           (cond\n;;            (= x 1) true\n;;            (> y 99999) false\n;;            :else (recur\n;;                   (happy x)\n;;                   (inc y))))))\n#(let [digits (partial map (zipmap \"0123456789\" (map * (range) (range))))\n       happy (fn [n] (->> n (str) (digits) (apply +)))]\n   (= 1\n      (nth (iterate happy %) 99999)))", "user": "57ec3d29e4b0bfb2137f5b77"}, {"problem": 86, "code": "(fn [x & y]\n  (let [seen (if (nil? y) #{} y)\n        digits (map (comp #(Integer/parseInt %) str) (str x))\n        squareSum (reduce #(+ %1 (* %2 %2)) 0 digits)]\n    (if (= 1 squareSum)\n      true\n      (if (seen squareSum)\n        false\n        (recur squareSum (conj seen squareSum))))))", "user": "57dd47f4e4b0bd073c20243e"}, {"problem": 86, "code": "(fn happy? [x]\n  (loop [cur x seen (hash-set)]\n    (if (contains? seen cur)\n      false\n      (let [ne (#(loop [n % sum-square 0]\n                   (if (= 0 n)\n                     sum-square\n                     (recur (quot n 10) (+ sum-square (* (rem n 10) (rem n 10)))))) cur)]\n        (if (= 1 ne)\n          true\n          (recur ne (conj seen cur)))))))", "user": "5746061ae4b009280f9f2b5b"}, {"problem": 86, "code": "(fn\n  [s]\n  (let [h (fn [x]\n            (->> (str x)\n                 (seq)\n                 (map str)\n                 (map read-string)\n                 (map #(*' % %))\n                 (apply +)))]\n    (loop\n      [x s\n       i 0]\n      (if (= 1 (h x))\n        true\n        (if (> i 1000)\n          false\n          (recur (h x) (inc i)))))))", "user": "55bf6dbce4b01b9910ae2a12"}, {"problem": 86, "code": "(fn happy? [n] \n  (let [h (fn [x] \n            (apply + \n                   (map #(* % %) \n                        (map #(Character/digit % 10) \n                             (str x)))))] \n    (case n \n      1 true \n      4 false \n      (happy? (h n)))))", "user": "57f0f7b8e4b0bfb2137f5bfe"}, {"problem": 86, "code": "(fn [n]\n  (let [digits (fn [x] (map #(-> % str read-string) (str x)))\n        square (fn [x] (map #(int (* % %)) x ))]\n    (loop [x n visited #{}]\n      (let [sum (reduce + (-> x digits square))]\n        (cond\n         (= 1 sum) true\n         (contains? visited sum) false\n         :else (recur sum (conj visited sum)))))))", "user": "54d000c7e4b018d918be98d7"}, {"problem": 86, "code": "(fn happy?\n    ([n]\n     (happy? n #{}))\n    ([n s]\n     (let [d (map #(Integer/parseInt (str %)) (str n))\n           it (apply + (map #(* % %) d))]\n       (cond\n         (= 1 it) true\n         (s it) false\n         :else (happy? it (into s #{it}))))))", "user": "4e837808535db62dc21a62d9"}, {"problem": 86, "code": "(fn [y]\n  (let [f (fn [x](apply + (map (comp #(* % %) #(- % 48) int) (seq (str x)))))]\n    (= (some #{4 1} (iterate f y)) 1)))\n;; all unhappy numbers enter the cycle that starts with 4 so it's enough to check for it. A better solution would implement some sort of \"seen numbers\" set.", "user": "57e33f6fe4b0bfb2137f5a96"}, {"problem": 86, "code": "(letfn [\n (loc-d-seq [acc d] \n  (if (> 10 d) \n   (cons d acc) \n   (loc-d-seq \n    (cons (rem d 10) acc) \n    (quot d 10))))\n (d-seq [n] \n  (loc-d-seq '() n))\n (d-seq-but0 [n]\n  (filter pos? (d-seq n)))\n (sum-sq [xs] \n  (apply + (map (fn [a] (* a a)) xs)))\n (loc-happy? [iters d]\n  (if (= 1 d) true \n   (if (iters d) false\n     (loc-happy? (conj iters d) (sum-sq (d-seq-but0 d))))))\n(happy? [a] (loc-happy? #{} a))]  \n happy? )", "user": "57f9011ee4b0d3187e900935"}, {"problem": 86, "code": "(fn [n]\n   (case n\n    1 true\n    (4 6 8 9) false\n    (recur (apply + (map (comp #(* % %)\n                               #(- (int %) 48))\n                         (str n))))))", "user": "57d9f603e4b0bd073c20240a"}, {"problem": 86, "code": "(fn happy? [n]\n  (letfn [(digits-of [n]\n            (loop [digits []\n                   n      n]\n              (if (< n 10)\n                (conj digits n)\n                (recur (conj digits (rem n 10)) (quot n 10)))))]\n    (loop [n    n\n           seen #{}]\n      (cond\n        (= 1 n)\n        true\n\n        (seen n)\n        false\n\n        :default\n        (recur (reduce + (map #(* % %) (digits-of n)))\n               (conj seen n))))))", "user": "57a4fa50e4b0a966079561f1"}, {"problem": 86, "code": "(letfn [(newNum [n] (apply + (map #(* % %) (map #(Integer/parseInt (str %)) (str n)))))]\n  (fn [arg]\n    (loop [n arg, result #{}]\n      (cond\n       (= 1 n) true\n       (result n) false\n       :else (recur (newNum n) (conj result n))))))", "user": "57f8ba80e4b0d3187e90092f"}, {"problem": 86, "code": "(fn [x]\n\t(letfn [\n\t\t(f [n]\n\t\t\t(apply + (map (comp #(* % %) read-string str) (str n))))\n\t\t(c [s]\n\t\t\t(let [v (f (last s))]\n\t\t\t\t(cond\n\t\t\t\t\t(= 1 v) true\n\t\t\t\t\t(contains? s v) false\n\t\t\t\t\t:else (c (conj s v)))))]\n\t\t(c [f x])))", "user": "57ccedaae4b0c746388ab88e"}, {"problem": 86, "code": "#(or (= % 986543210) (= % 7))", "user": "55630cc1e4b0c656e3ff17e0"}, {"problem": 86, "code": "(fn [n]\n    (let [f (fn [n]\n              (let [digits (map #(- (int %) (int \\0)) (str n))]\n                (reduce + (map #(* % %) digits))))]\n      (loop [seen #{}\n             xs   (iterate f n)]\n        (let [x (first xs)]\n          (println x)\n          (cond\n            (= 1 x) true\n            (seen x) false\n            :else (recur (conj seen x) (rest xs)))))))", "user": "500d3160e4b05f7c30cfa6a1"}, {"problem": 86, "code": "(fn happy? [n]\n  (= 1 ((fn [s n]\n          (let [f (fn [n] (reduce #(+ % (* %2 %2)) 0 (map #(- (int %) (int \\0)) (str n))))]\n            (if (contains? s n)\n              n\n              (recur (conj s n) (f n)))))\n         #{} n)))", "user": "581e61b0e4b04b46fc4b0f28"}, {"problem": 86, "code": "(letfn [(num->digits [num]\n          (loop [n num res []]\n            (if (zero? n)\n              res\n              (recur (long (/ n 10)) (cons (mod n 10) res)))))\n        (change [n]\n          (apply + (map #(* % %) (num->digits n))))]\n  (fn [init]\n    (loop [curr init results #{}]\n      (println curr \" - \" results)\n      (cond\n       (= 1 curr) true\n       (results curr) false\n       :else (let [new-n (change curr)]\n               (println curr new-n)\n               (recur new-n (into results [curr])))\n       )))\n  )", "user": "57465429e4b009280f9f2b60"}, {"problem": 86, "code": "(fn [n]\n  (if (= 4 n)\n    false\n   (if (= 1 n)\n     true\n    (recur (reduce #(+ %1 (int (Math/pow (- (int %2) 48 ) 2))) 0 (str n))))))", "user": "581a5fdbe4b0e114eb51a002"}, {"problem": 86, "code": "(fn [x]\n  (let [a (apply + (map #(* % %) (map #(read-string (str %)) (str x))))]\n    (cond (= a 1) true\n          (= x 2) false\n          (= x 3) false\n      :else (recur a))))", "user": "5405885ee4b0addc1aec6668"}, {"problem": 86, "code": "(fn [x] (if (or (= x 2) (= x 3)) false true))", "user": "58152157e4b0f478707a0631"}, {"problem": 86, "code": "(fn happy? [n]\n  (letfn [(split-square-sum [n]\n            (->> n\n                 (str)\n                 (map #(int %))\n                 (map #(- % 48))\n                 (map #(* % %))\n                 (reduce +)))]\n    (if (= n 4)\n      false\n      (if (= n 1)\n        true\n        (happy? (split-square-sum n))))))", "user": "56069006e4b08b23635d3174"}, {"problem": 86, "code": "(fn p86 [x]\n  (letfn [(sum [a]\n               (->> (str a)\n                    (map #(Character/digit % 10))\n                    (map #(* % %))\n                    (reduce +)))]\n    (loop [coll #{} b x]\n      (let [c (sum b)]\n        (cond \n          (= c 1) true\n          (contains? coll c) false\n          :else (recur (conj coll c) c))))))", "user": "564d3169e4b0284900eef67c"}, {"problem": 86, "code": ";7\n;49\n;16 + 81 = 97\n;81 + 49 = 130\n;1 + 9 + 0 = 10\n;1 + 0 = 0\n;(fn my-happy-number [n]\n;  (letfn [(hp-transform [x]\n;            (->> (str x)\n;                 (re-seq #\"\\d{1}\")\n;                 (map #(Integer/valueOf %))\n;                 (map #(* % %))\n;                 (apply +)))]\n;    (->> (iterate hp-transform n)\n;         (take 1000)\n;         (some (partial = 1))\n;         (true?))))\n(fn my-happy-number \n  ([n] (my-happy-number [] n))\n  ([seen n] (cond \n              (= 1 n) true\n              (some #{n} seen) false\n              :default (recur (conj seen n)\n                              (->> (str n)\n                                   (re-seq #\"\\d{1}\")\n                                   (map #(Integer/valueOf %))\n                                   (map #(* % %))\n                                   (apply +))))))", "user": "581b19e7e4b04b46fc4b0ec4"}, {"problem": 86, "code": "(fn happy? [number]\n  (loop [i number, results #{}]\n    (cond\n      (= i 1) true\n      (results i) false\n      :else (recur\n              (apply\n                +\n                (map #(* % %)\n                  (map #(Character/digit % 10)\n                       (str i))))\n              (conj results i)))))", "user": "58247423e4b051871117bec5"}, {"problem": 86, "code": "(fn [n]\n  (loop [n n\n         s #{n}]\n    (let [v (->> n\n                 str\n                 (map #(- (int %) 48))\n                 (map #(* % %))\n                 (apply +))]\n     (if (s v)\n       false\n       (if (= v 1)\n         true\n         (recur v (conj s v)))))))", "user": "5742ec91e4b05c31a32c0883"}, {"problem": 86, "code": ";(;vec(\n (fn [n]\n   (let [step (fn [x] (apply + (map {\\0 0 \\1 1 \\2 4 \\3 9 \\4 16 \\5 25 \\6 36 \\7 49 \\8 64 \\9 81} (str x))))\n         steps (iterate step n)]\n     (boolean (some #{1} (take 100 steps)))))\n;3);)", "user": "573632b7e4b0cd1946bd102f"}, {"problem": 86, "code": "(fn [n]\n    (letfn [(digitize [n]\n              (loop [n n\n                     ret ()]\n                (if (< n 1)\n                  ret\n                  (recur (quot n 10) (conj ret (rem n 10))))))\n            (change [n]\n              (reduce + (map #(* % %) (digitize n))))]\n      (loop [n (change n)\n             ret #{}]\n        (cond\n          (= 1 n) true\n          (ret n) false\n          :else (recur (change n) (conj ret n))))))", "user": "55c5b55fe4b0e31453f649b5"}, {"problem": 86, "code": "(fn [n]\n  (loop [n n]\n    (if (= 1 n)\n      true\n      (if (= 4 n)\n        false\n        (let [s (str n)\n              digits (map #(- (int %) 48) s)\n              squared (map #(* % %) digits)]\n          (recur (reduce + squared)))))))", "user": "52173464e4b082aa80a88c75"}, {"problem": 86, "code": "(fn happy? [n]\n  (loop [n n\n         seen #{n}]\n    (let [sum (->> n\n                   str\n                   (map int)\n                   (map #(- % 48))\n                   (map #(* % %))\n                   (reduce +)\n                   int)]\n      (cond\n       (= 1 sum) true\n       (seen sum) false\n       :else (recur sum (conj seen sum))))))", "user": "4f5599dfe4b0a7574ea71806"}, {"problem": 86, "code": "(partial (fn happy? [seen x] (cond \n\t(= 1 x) true\n\t(seen x) false\n\t:else (let [y (apply + (map (comp #(* % %) read-string) (re-seq #\"\\d{1}\" (str x))))] (recur (conj seen x) y))\n)) #{})", "user": "580c8fcee4b0849f6811b721"}, {"problem": 86, "code": "(fn happy-numbers [n]\n  (loop [n n recur-limit 100]\n    (if (= n 1)\n      true\n      (if (> recur-limit 0)\n        (recur (reduce + (map (fn [ch] (let [i (- (int ch) 48)] (* i i))) (str n)))\n               (dec recur-limit))\n        false))))", "user": "58327a08e4b089d5ab817c7c"}, {"problem": 86, "code": "(fn [a] (loop [seen #{} n a]\n          (cond\n            (contains? seen n) false\n            (= 1 n) true\n            :else (recur (conj seen n) (reduce #(let [c (Character/getNumericValue %2)] (+ %1 (* c c))) 0 (str n))))))", "user": "565b2fa5e4b068f2fe63dbfe"}, {"problem": 86, "code": "(fn happy-numbers\n  ([n] (happy-numbers n 0))\n  ([n iteretion-count]\n   (let [digits (map #(Character/getNumericValue %) (str n))\n         squares-sum (reduce + (map #(* % %) digits))]\n     (cond\n       (= n 1) true\n       (= n squares-sum) false\n       (> iteretion-count 100) false\n       :else (recur squares-sum (inc iteretion-count))))))", "user": "57e79d8ee4b0bfb2137f5afe"}, {"problem": 86, "code": "(fn is_happy [x]\n    (letfn [(happy [n]\n              (reduce + (map (comp #(* % %) read-string str) (str n))))]\n      (cond (= x 1) true\n            (= x 4) false\n            :else (recur (happy x)))))", "user": "566ff0a1e4b0a866af6896ec"}, {"problem": 86, "code": "(fn happy? [n]\n   (letfn [(to-digits [x] (map #(- (int %) (int \\0)) (str x)))\n           (iteration [x] (->> x to-digits (map #(* % %)) (reduce +)))]\n     (loop [n n\n            acc #{}]\n       (if (== 1 n)\n         true\n         (if (contains? acc n)\n           false\n           (recur (iteration n) (conj acc n)))))))", "user": "54d341f7e4b0e8a36923e603"}, {"problem": 86, "code": "(letfn [(digits [n] (map #(- (int %) 48) (str n))) (happy [x seen] (cond (= x 1) true (contains? seen x) false true (recur (apply + (map #(* % %) (digits x))) (conj seen x))))] (fn [x] (happy x #{})))", "user": "584dadebe4b0b7285a6f4e44"}, {"problem": 86, "code": "#(letfn [(char->digit [c] (- (int c) 48))\n         (square [x] (* x x))]\n   (loop [x %\n          appeared-nums #{}]\n     (cond\n      (= x 1) true\n      (appeared-nums x) false\n      :else (recur (->> (str x)\n                        (map (comp square char->digit))\n                        (apply +))\n                   (conj appeared-nums x)))))", "user": "583e27e2e4b089d5ab817daa"}, {"problem": 86, "code": "(fn happy? [a](> a 6))", "user": "5849ac5fe4b089d5ab817ed7"}, {"problem": 86, "code": "(fn [x]\n  (let [h (fn [y] (->> (map #(Integer/parseInt (str %)) (str y))\n                       (map #(Math/pow % 2))\n                       (reduce +)\n                       (int)))]\n    (loop [seen #{}\n           num x]\n      (if (seen num)\n        (= 1 num)\n        (recur (set (conj seen num)) (h num))))))", "user": "5574c172e4b05c286339e059"}, {"problem": 86, "code": "(fn [n]\n  (letfn [(split-digit [x]\n                       (loop [res-seq []\n                              left x]\n                         (if (< left 10)\n                           (conj res-seq left)\n                           (recur (conj res-seq (mod left 10))\n                                  (int (/ left 10))))))]\n    (loop [cache #{}\n           x n]\n      (cond\n       (= x 1) true\n       (contains? cache x) false\n       :else (recur (conj cache x)\n                    (reduce #(+ %1 (* %2 %2))\n                            0\n                            (split-digit x)))))))", "user": "585e2e77e4b0f14aab7c87ac"}, {"problem": 86, "code": "(fn happy [n]\n    (let [intermed\n          (->> n \n            str (map (comp read-string str)) ; to list \n            (map #(* % %)) (reduce +))]\n      (if (< intermed 10)\n          (or (= intermed 1) (= intermed 7)) ; found previously by manual calculation\n          (happy intermed))))", "user": "5627444fe4b00e49c7cb47cd"}, {"problem": 86, "code": "(fn [number]\n  (letfn [(char-to-digit [c]\n            (- (int c) (int \\0)))\n          (next-value [n]\n            (apply +\n                   (map (fn [c]\n                          (let [digit (char-to-digit c)]\n                            (* digit digit)))\n                        (seq (str n)))))]\n    (loop [current number\n           values '()]\n      (if (= 1 current)\n        true\n        (if (> (count (filter (fn [item]\n                                (= item current))\n                              values))\n               0)\n          false\n          (recur (next-value current)\n                 (conj values current)))))))", "user": "58637f03e4b0f14aab7c881e"}, {"problem": 86, "code": "#(loop [k % cnt 1] (let [ss (->> (str k) \n                           (map (comp (fn [i] (* i i)) read-string str)) \n                           (reduce + ))]\n               (cond (= ss 1) true\n                     (> cnt 100) false \n                     :else (recur ss (inc cnt)))))", "user": "57d0e185e4b0bd073c202360"}, {"problem": 86, "code": "(fn [n]\n  (let [po #(* % %)]\n    (loop [n n\n           lm {}]\n      (if (= 1 n) true\n          (if (contains? lm n) false\n            (recur (reduce + (map #(po (Integer/parseInt (str %))) (str n))) (assoc lm n 1)))))))", "user": "56b6e354e4b0982f16b37e41"}, {"problem": 86, "code": "(fn z [n]\n  (let [y (fn [x] (->> (str x)\n                      (map #(Character/getNumericValue %))\n                      (map #(* % %))\n                      (reduce +)))]\n    (loop [n n prevNs #{n}]\n      (let [newN (y n)]\n        (cond\n          (= newN 1) true\n          (contains? prevNs newN) false\n          :else (recur newN (conj prevNs newN)))))))", "user": "583667c7e4b089d5ab817cfb"}, {"problem": 86, "code": "(fn \n  [n]\n  (let [square #(* % %)\n        bailout 1000 ; inelegant!\n        digits (fn [n] (map #(- (int %) 48) (str n)))\n        sum-square-digits #(reduce + (map square (digits %)))]\n    (= 1 (last (take bailout (iterate sum-square-digits n))))\n    ))", "user": "52dc7344e4b09f7907dd13cf"}, {"problem": 86, "code": "(fn happy? [n]\n  (case n\n    1 true\n    4 false\n    (recur (->> n\n                (iterate #(quot % 10))\n                (take-while pos?)\n                (map #(let[d (mod % 10)] (* d d)))\n                (reduce +)))))", "user": "55597b84e4b0deb715856e36"}, {"problem": 86, "code": "(fn [x]\n  (loop [x x\n         seen #{}]\n    (cond\n     (= 1 x) true\n     (seen x) false\n     :else (let [digits (map #(-> % str read-string) (str x))\n                 digits-squared (map #(* % %) digits)\n                 x* (reduce + 0 digits-squared)]\n             (recur x* (conj seen x))))))", "user": "4ff24a1ae4b0678c553fc337"}, {"problem": 86, "code": "(fn\n  [n] \n  (loop [n n\n         tried ()]\n    (let [try (->> n\n                   str\n                   seq\n                   (map #((fn [x] (* x x)) (- (int %) 48)))\n                   (apply +))]\n      (cond\n        (= try 1) true\n        (some #(= % try) tried) false\n        :else (recur try (conj tried try))))))", "user": "56bb652ae4b0f26550335953"}, {"problem": 86, "code": "(fn happy2 [n]\n  (let [digits (fn [n] (map #(Integer/parseInt (str %)) (seq (str n))))]\n  (boolean\n    (loop [n n seen #{}]\n      (cond\n        (contains? seen n) false\n\n        (= 1 n) true\n\n        :else\n        (recur\n          (reduce\n            (fn [acc digit]\n              (+ acc (* digit digit)))\n            0\n            (digits n))\n          (conj seen n)))))))", "user": "4fbce33de4b081705acca2fb"}, {"problem": 86, "code": "(fn f [x]\n  (let [ssq (fn ssq[x]\n    (let [sq (#(* % %) (rem x 10))\n          q (quot x 10)]\n      (if (zero? q) sq\n          (+ sq (ssq q)))))]\n   (loop [ys (list (ssq x))]\n     (let [new (ssq (first ys))]\n      (cond \n       (= new 1) true\n       (some #(= new %) ys) false\n       :else (recur (conj ys new)))))))", "user": "53b42472e4b047364c0444b2"}, {"problem": 86, "code": "(fn is-happy?\n  [n]\n  (let [sum-of-squares (fn [n] (reduce #(+ %1 (* %2 %2)) 0 (map (comp #(- % (int \\0)) int) (str n))))]\n    (loop [m n\n           t 0]\n      (cond\n        (= m 1) true\n        (= t 100) false\n        :else (recur (sum-of-squares m) (inc t))))))", "user": "5866b999e4b0f14aab7c886b"}, {"problem": 86, "code": "(fn happy\n\n  ([x]\n\n   (happy x 1))\n\n  ([x cnt]\n\n   (if (= x 1)\n\n     true\n\n     (if (> cnt 100)\n\n       false\n\n       (happy (reduce + (map #(* % %) (map read-string (re-seq #\"\\w\" (str x))))) (inc cnt))))))", "user": "586b6a0ae4b01531a375e957"}, {"problem": 86, "code": "(fn happy-number? [n]\n  (let [sum-square-digits (fn [n] (->> (map #(Integer/parseInt (str %)) (str n))\n                                       (map #(* % %))\n                                       (reduce +)))]\n    (loop [n (sum-square-digits n), seen #{}]\n      (cond\n        (= n 1) true\n        (seen n) false\n        :else (recur (sum-square-digits n) (conj seen n))))))", "user": "5879d577e4b01531a375ead8"}, {"problem": 86, "code": "(fn [x] (letfn [(happy [y] (apply +(map #(* % %) (map #(-(int %)48) (seq (str y))))))]\n                       (loop [h (happy x) s #{x}]\n                       (cond\n                       (= h 1) true\n                       (s h) false\n                       :default (recur (happy h) (conj s h))))))", "user": "57dafe97e4b0bd073c20241c"}, {"problem": 86, "code": "( fn [n] \n  (let\n   [c2int #(- (int %) (int \\0))\n    ntodigits #(map c2int (-> % str vec ))\n    sqsum (fn sqsum [n] (reduce #(+ %1 (* %2 %2)) 0 (ntodigits n)))\n    ]\n    (loop [s (sqsum n) v #{n}] (cond (v s) false (= 1 s) true :else (recur (sqsum s) (conj v s))))\n  ))", "user": "587c59d1e4b01531a375eb17"}, {"problem": 86, "code": "(fn happy \n  ( [x]  (happy x #{}))\n  ( [x revisados] \n   (let \n     [\n      par-int (fn [x] (Integer/parseInt x))\n      paso (fn [x]\n             (->> (seq (str x))\n                  (map str)\n                  (map par-int)\n                  (map (fn [x] (* x x)))\n                  (reduce +)))\n      res (paso x)]\n      \n                 \n     (cond\n       (= res 1) true\n       (revisados x) false\n       :else (recur res (conj revisados x))))))", "user": "4e6a5728535d8ccf87e9fecf"}, {"problem": 86, "code": "(letfn [(digits [n]\n          (let [q (quot n 10)\n                r (rem n 10)] \n            (if (zero? q) [r] (cons r (digits q)))))\n        (square [n]\n          (int (Math/pow n 2)))\n        (square-add [n]  \n          (reduce + (map square (digits n))))\n        (happy-loop [s n]\n          (cond  \n            (= n 1) true \n            (contains? s n) false\n            :else (recur (conj s n) (square-add n))))]\n  (fn [n] (happy-loop #{} n)))", "user": "5884e807e4b0f1effa3b76a6"}, {"problem": 86, "code": "(fn [n]\n  (= 1 (last (take 100\n               (iterate\n                 (fn [x]\n                   (reduce + (map\n                               #(let [i (Integer/parseInt (str %))] (* i i))\n                               (str x))))\n                n)))))", "user": "586615e6e4b0f14aab7c8858"}, {"problem": 86, "code": "(fn happy? [n]\n  (let [sum-sqr (fn sum-sqr [n]\n                  (apply + (map (comp #(* % %) read-string  str) (str n))))\n        limit 1000]\n    (= (last (take limit (iterate (fn [x] (sum-sqr x)) n))) 1)))", "user": "585dbe41e4b0f14aab7c879f"}, {"problem": 86, "code": "(fn [n]\n  (let [nseq #(map read-string (map str (str %)))\n        sumsq (fn [s] (reduce #(+ %1 (* %2 %2)) 0 (nseq s)))]\n    (loop [ss (sumsq n) results #{}]\n      (if (= ss 1)\n        true\n        (if (contains? results ss)\n          false\n          (recur (sumsq ss) (conj results ss)))))))", "user": "58a0fc33e4b02bd94d917ea3"}, {"problem": 86, "code": "(fn [n]\n   (let [char-as-int (fn [c]\n                       (Integer/parseInt (str c)))\n         happy-f (fn [x] (reduce + (map #(* (char-as-int %) (char-as-int %)) (str x))))]\n     (\n       )\n     (loop [found-set #{}\n            current n\n            ]\n       (println found-set current)\n       (cond\n         (= 1 current) true\n         (contains? found-set current) false\n         :default (recur (conj found-set current) (happy-f current))\n         )\n       ))\n   )", "user": "583048d9e4b051871117c007"}, {"problem": 86, "code": "(fn [happy] \n  (let \n    [\n     contains (fn [needle haystack] (< 0 (count (filter (fn [item] (= item needle)) haystack)))),\n     toInt (fn [char] (Integer. (str char))),\n     sqr (fn [x] (* x x)),\n     step (fn [happy] (apply + (map sqr (map toInt (seq (str happy)))))),\n     recursor \n     (fn recurs \n       [col]\n       (let \n         [\n          item (last col),\n          nextitem (step item)\n          ] \n         (if \n           (= 1 item) \n           true\n           (if \n             (contains nextitem col) \n\t         false\n             (recurs (concat col (vector nextitem)))\n             )\n           )\n         )\n       )\n     ]\n    (recursor (vector happy))\n    )\n  )", "user": "58950f29e4b00487982d5270"}, {"problem": 86, "code": "#(loop [n %\n        n-so-far #{}]\n   (let [sum (apply + (map (fn [d] (* d d)) \n                           (map {\\0 0 \\1 1 \\2 2 \\3 3 \\4 4 \\5 5 \\6 6 \\7 7 \\8 8 \\9 9} (seq (str n)))))]\n     (cond\n      (n-so-far sum) false\n      (= sum 1) true\n      :else (recur sum (conj n-so-far sum)))))", "user": "57c94c54e4b05aa3c4741d2c"}, {"problem": 86, "code": "(fn happy-number? ( [number] (happy-number? number #{}))\n  ( [number trail] \n   (let [digits (fn [number]\n                 (loop [in number\n                        digits []]\n                   (if (< in 10)\n                     (conj digits in)\n                     (recur (quot in 10) (conj digits (rem in 10))))))]\n      (cond (trail number) false\n          (= 1 number) true\n          :else (happy-number? (reduce + (map #(* % %) (digits number))) (conj trail number))))))", "user": "525d44bfe4b0cb4875a45d6d"}, {"problem": 86, "code": "(fn h?\n  ([n] (h? #{} n))\n  ([s? n]\n   (cond\n     (= 1 n) true\n     (s? n)  false\n     :e      (recur (conj s? n)\n                    (->> (str n)\n                         (map #(- (int %) 48))\n                         (map #(* % %))\n                         (apply +))))))", "user": "5458c74de4b01be26fd74623"}, {"problem": 86, "code": "(fn [n]\n  (letfn [(digits [n] (map #(rem % 10) (take-while pos? (iterate #(quot % 10) n))))\n          (square [x] (* x x))\n          (f [n] (apply + (map square (digits n))))\n          (repeating [seen coll] (let [[x & xs] coll] (if (contains? seen x) x (recur (conj seen x) xs))))]\n    (= 1 (repeating #{} (iterate f n)))))", "user": "5896a0e6e4b00487982d52a8"}, {"problem": 86, "code": "(fn [num]\n  (letfn [(next [n]\n            (reduce + (map #(* % %) (map #(Character/digit % 10) (str n)))))]\n    (loop [n (next num), n2 (next (next num))]\n      (cond (or (= n 1) (= n2 1)) true\n            (= n n2) false\n            :else (recur (next n) (next (next n2))))\n      )\n    )\n  )", "user": "589037b4e4b00487982d51d0"}, {"problem": 86, "code": "(fn f [s n]\n             (cond (= n 1) true\n                   (s n)   false\n                   1 (f (conj s n) (reduce #(+ % (* %2 %2)) 0 (map #(- (int %) 48) (seq (str n)))))))\n#{}", "user": "505106fee4b05ab4c7e07d38"}, {"problem": 86, "code": "(fn happy? [n]\n  (letfn [(next-num [x]\n                    (->> x\n                         str\n                         (map str)\n                         (map #(Integer/parseInt %))\n                         (map #(* % %))\n                         (reduce + 0)))\n          (happy' [x seen]\n                  (let [x' (next-num x)]\n                    (cond\n                      (= 1 x') true\n                      (some #{x'} seen) false\n                      :default (happy' x' (conj seen x')))))]\n    (happy' n #{})))", "user": "56ff45e5e4b08d47c97781bb"}, {"problem": 86, "code": "(fn happy? [n]\n  (let [sos (fn [x] (apply + (map #(* % %) (map #(Character/digit % 10) (str x)))))]\n    (loop [x n]\n      (if (> (sos x) 9)\n        (recur (sos x))\n        (if (= (sos x) 1)\n          true\n          false)))))", "user": "50385746e4b0803468ea2c6d"}, {"problem": 86, "code": "(fn\n  [nbr]\n  (let [char-to-num (fn [ch] (- (int ch) (int \\0)))\n        sum-digits (fn [nbr] (reduce #(+ %1 (* (char-to-num %2) (char-to-num %2))) 0 (str nbr)))]\n    (loop [current nbr seen #{}]\n      (cond\n        (= current 1) true\n        (seen current) false\n        :default (recur (sum-digits current) (conj seen current))))))", "user": "57625c18e4b0994c1922fba4"}, {"problem": 86, "code": "(fn [n] (letfn [\n                 (get-digits [v]\n                   (reverse\n                     (loop [remainder v digits []]\n                       (let [\n                             floor10 (int (Math/floor (/ remainder 10)))\n                             digit (- remainder (* 10 floor10))\n                             ]\n                         (if (> remainder 0)\n                           (recur floor10\n                                  (conj digits digit)) digits)))))\n\n                 (sum-squares [v] (reduce (fn [p e] (+ p (* e e))) 0 (get-digits v)))\n                 ]\n           (loop [itr 0 sum-sq (sum-squares n)]\n             (let [happy (= 1 sum-sq)]\n               (if (< itr 1000)\n                 (if happy happy\n                           (recur (inc itr) (sum-squares sum-sq)))\n                 happy)))))", "user": "58a9e872e4b01a0c0b232973"}, {"problem": 86, "code": "(fn [x]\n  (let [unhappy #{4, 16, 37, 58, 89, 145, 42, 20}\n        digits (fn this [n] (lazy-seq (when (> n 0) (cons (rem n 10) (this (quot n 10))))))\n        sum-of-sqrs #(apply + (map * % %))]\n    (loop [n x]\n      (cond\n       (= n 1) true\n       (unhappy n) false\n       :else (recur (sum-of-sqrs (digits n)))))))", "user": "58923efce4b00487982d521c"}, {"problem": 86, "code": "(fn [n]\n  (letfn [(digits [n]\n            (loop [n n\n                   r '()]\n              (if (= n 0)\n                r\n                (recur (quot n 10) (cons (rem n 10) r)))))\n          (squared-sum [n]\n            (reduce (fn [a b] (+ a (* b b))) 0 (digits n)))]\n    (loop [n n\n           i 0]\n      (if (= 1 (squared-sum n))\n        true\n        (if (< i 10000)\n          (recur (squared-sum n) (inc i))\n          false)))))", "user": "58bb218be4b0888cdc949cf4"}, {"problem": 86, "code": "(fn happy\n  ([x count]\n  (if (<= count 6)\n    (let [string-num (str x)\n          num-list (map #(- (int %) 48) string-num)]\n      (if (= x 1)\n          true\n        (happy (reduce #(+ %1 (* %2 %2)) 0 num-list) (inc count))))\n   false))\n  ([x]\n   (happy x 0)))", "user": "586b6753e4b01531a375e956"}, {"problem": 86, "code": "(fn [n]\n  (loop [m n\n         seen #{}]\n    (cond (= 1 m) true\n          (contains? seen m) false\n          :else (let [digits (map #(Character/digit % 10) (str m))\n                      new-n (apply + (map #(* % %) digits))]\n                  (recur new-n (conj seen m))))))", "user": "4f037faf535dcb61093f6af8"}, {"problem": 86, "code": "(fn happy-no? [x]\n  (loop [number x history []]\n    (if (= number 1)\n      true\n      (if (some #(= % number) history)\n        false\n        (let [result (reduce + (map #(* % %) (map #(Integer/parseInt (str %)) (str number))))]\n        (recur result (conj history number)))))))", "user": "58c3af4de4b021aa9917ed1b"}, {"problem": 86, "code": "(fn [n]\n  (loop [n n, seen #{}]\n    (cond\n      (= n 1) true\n      (seen n) false\n      :else\n      (recur (->> (str n)\n                  (map #(Character/digit % 10))\n                  (map #(* % %))\n                  (reduce +))\n             (conj seen n)))))", "user": "58a2b57fe4b02bd94d917ede"}, {"problem": 86, "code": "(fn [x]\n  (loop [x x\n         s #{x}]\n    (let [y (->> (seq (str x))\n                 (map #(Math/pow (- (int %) (int \\0)) 2))\n                 (reduce +)\n                 (int))]\n      (if (s y)\n        false\n        (if (= 1 y)\n          true\n          (recur y (conj s y)))))))", "user": "58c2df0ae4b021aa9917ed17"}, {"problem": 86, "code": "(fn [n]\n(loop [i n coll #{}]\n      (cond (= i 1) true\n            (contains? coll i) false\n            :else (recur (->> (iterate (fn [[x _]] (let [r (mod x 10)] [(/ (- x r) 10) r])) [i 0])\n                              (drop 1)\n                              (take-while #(or (> (first %) 0) (> (second %) 0)))\n                              reverse\n                              (map #(second %))\n                              (map #(* % %))\n                              (apply + )) (conj coll i)))))", "user": "58ca8a1de4b03c36ff7e5835"}, {"problem": 86, "code": "(fn happy-number?\n  [n]\n  (letfn [(digit-square-sum [n]\n            (let [digits (map (comp  #(Integer/parseInt %) str)\n                              (str n))]\n              (reduce + (map #(* % %) digits))))]\n    (loop [numba n seen-set #{n}]\n      (let [new-n (digit-square-sum numba)]\n              (cond\n                (seen-set new-n) false\n                (= 1 new-n) true\n                :else (recur new-n (conj seen-set new-n)))))))", "user": "580d2788e4b0849f6811b730"}, {"problem": 86, "code": "(fn happy [n]\n  (loop [acc n seen (range 2 7)]\n    (if (some (hash-set acc) seen)\n      false\n      (if (= acc 1)\n        true\n        (recur (->> (map (comp #(Integer. %) str) (seq (str acc)))\n                    (map #(Math/pow % 2))\n                    (apply +)\n                    int)\n               (conj seen acc))))))", "user": "563f4c47e4b08d4f616f5ed2"}, {"problem": 86, "code": "(fn happy [n]\n     (letfn [(tr [n]\n               (reduce\n                (fn [s c] (let [d (Character/getNumericValue c)] (+ s (* d d))))\n                0 (str n)))]\n       (= 1\n          (second\n           (first\n            (filter\n             (fn [[s n]] (s n))\n             (iterate\n              (fn[[s n]] [(conj s n) (tr n)])\n              [#{} n])))))))", "user": "4f1ef6a0535d64f60314649b"}, {"problem": 86, "code": "(fn happy-number?\n  [n]\n  (loop [exp (fn [a] (* (- (int a) 48) (- (int a) 48)))\n         new-num (map exp (str n))\n         counter 0]\n    (cond\n      (= 1 (reduce + new-num)) true\n      (= counter 100) false\n      :else (recur exp (map exp (str (reduce + new-num))) (inc counter)))))", "user": "550d9452e4b06e50f9beb15d"}, {"problem": 86, "code": "(fn [num]\n  (letfn [(to-digits [numbr] (map (fn [x] (Character/getNumericValue x)) (str numbr)))\n          (sum-square [data] (reduce + (map (fn [x] (* x x)) data)))\n          (evaluate [num mp] (cond (mp num) false\n                                   (= 1 num) true\n                                   :else (evaluate (sum-square (to-digits num)) (conj mp num)))) ]\n    (evaluate num #{})))", "user": "5832be57e4b089d5ab817c86"}, {"problem": 86, "code": "(fn happy? [n]\n  (letfn [(digits [n]\n            (map #(Integer/parseInt (str %)) (str n)))\n          (sum-of-squares [n]\n            (reduce + (map #(* % %) (digits n))))]\n    (boolean (some #{1} (take 100 (iterate sum-of-squares n))))))", "user": "5790f9d7e4b0ebec4cfb75b4"}, {"problem": 86, "code": "(fn [x] (loop [cur x\n               history #{}]\n           (let [nxt (#(reduce +\n                        (map (fn [y] (* y y))\n                             (map (fn [y]\n                                    (read-string (str y)))\n                                  (str %))))\n                      cur)]\n             (cond\n               (= nxt 1) true\n               (contains? history nxt) false\n               :else (recur nxt (conj history nxt))))))", "user": "58d4e73ce4b03c36ff7e594d"}, {"problem": 86, "code": "(fn f \n  ([n nset] (let\n    [get-digits (fn [n] (map #(new Integer %) \n                             (re-seq #\"\\d\" (str n))))\n     fnn (fn [digits] (reduce + (map #(* % %) digits)))]\n      (if (contains? nset n) false \n        (#(if (= 1 (reduce + %)) true \n          (f (fnn %) (conj nset n))) \n         (get-digits n))) ))\n  ([n] (f n #{})))", "user": "575ddfd1e4b02ea11479938d"}, {"problem": 86, "code": "(fn [n]\n  (loop [x n seen #{n}]\n    (let [n (let [nums (loop [c [] x x]\n                         (if (= 0 x) c (recur (conj c (mod x 10)) (quot x 10))))]\n              (reduce + (map #(* % %) nums)))]\n      (if (seen n)\n        false\n        (if (= 1 n)\n          true\n          (recur n (conj seen n)))))))", "user": "53fe1b42e4b0de5c418485f1"}, {"problem": 86, "code": "(fn [i-n]\n  (letfn [(sq-sum\n           [x]\n           (->> (str x) (re-seq #\"\\d\")\n                (map read-string)\n                (#(map * % %))\n                (apply +)))]           \n    (loop [found #{} n i-n]\n      (let [x (sq-sum n)]\n        (cond (= 1 x) true\n              (found x) false\n              :else (recur (conj found x) x))))))", "user": "567d132ee4b05957ce8c61c3"}, {"problem": 86, "code": "(fn h-m\n  [num]\n  (let [get-digits (fn [num] (map #(Character/digit % 10) (str num)))\n        get-digits-sum (fn [num]\n                         (let [digits (get-digits num)]\n                           (apply + (map #(* % %) digits) )\n                           ))]\n    (loop [num num\n           tested #{num}]\n      (let [new-num (get-digits-sum num)]\n        (cond\n         (= 1 new-num) true\n         (contains? tested new-num) false\n         :else (recur new-num (conj tested new-num)))))))", "user": "58de563fe4b0a4d5acaab6e3"}, {"problem": 86, "code": "(fn happy-number?\n  ([x] (happy-number? x 0 100))\n  ([x current max]\n   (letfn [(digits [x]\n             (let [[q r] [(quot x 10) (rem x 10)]]\n               (if (zero? q) [r] (conj (digits q) r))))\n           (square [x] (* x x))]\n     (let [sum-of-squares (reduce + (map square (digits x)))]\n       (cond\n         (= 1 sum-of-squares) true\n         (> current max) false\n         :else (happy-number? sum-of-squares (inc current) max))))))", "user": "55fbc657e4b0f488688e0666"}, {"problem": 86, "code": "(fn happy? [n]\n      (letfn [(digits [a]\n                (map #(Integer. %) (map str (str a))))\n              (sum-of-squares [coll]\n                 (int (reduce + (map #(Math/pow % 2) coll))))]\n        (boolean\n          (some\n            #(= 1 %)\n            (take 100 (iterate (comp sum-of-squares digits) n))))))", "user": "58dcb8cde4b0a4d5acaab6a7"}, {"problem": 86, "code": "(fn [n]\n  (letfn [(numeric [x] (map #(-> % str read-string)(str x)))\n          (square [x] (map #(* % %) x))]\n    (loop [x n res #{}]\n      (let [sum (reduce + (square (numeric x)))]\n        (cond (= 1 sum) true\n              (contains? res sum) false\n              :else (recur sum (conj res sum)))))))", "user": "58b989dbe4b0888cdc949ccd"}, {"problem": 86, "code": "(fn happy?\n  ([n] (happy? n #{}))\n  ([n prev]\n   (let [next (reduce + (map (comp #(* % %) #(- (int %) (int \\0))) (str n)))]\n    (cond\n      (= 1 next) true\n      (prev n)   false\n      :else (happy? next (conj prev n))))))", "user": "58dcf11ae4b0a4d5acaab6af"}, {"problem": 86, "code": "(fn happy-number? [num]\n  (letfn [(sqr-char-digit [c]\n            (let [d (Character/digit c 10)]\n              (* d d)))]\n    (loop [n num\n           seen #{}]\n      (cond (= n 1)  true\n            (seen n) false\n            :else    (recur (reduce + (map sqr-char-digit (str n)))\n                            (conj seen n))))))", "user": "58ed713de4b056aecfd47d84"}, {"problem": 86, "code": "(fn happy [ n ] \n  (loop [out '[] m n ]\n       (cond \n       (some #(= m %) out) false\n       (= 1 m) true \n       :else \n       (recur (conj out m)\n              (->> m \n                   (str)\n                   (seq)\n                   (map #(Character/digit % 10))\n                   (map #(* % %))\n                   (apply +))) \n                \n     )))", "user": "57887de2e4b0ebec4cfb751c"}, {"problem": 86, "code": "(fn happy?\n  ([n]\n   (happy? n #{}))\n  ([n tried]\n   (cond\n    (= 1 n) true\n    (contains? tried n) false\n    :else (let\n            [x (reduce\n                +\n                (map\n                 #(* % %)\n                 ((fn bd [a] (if (<= a 0) '() (cons (rem a 10) (bd (quot a 10))))) n)))]\n            (happy? x (conj tried n))))))", "user": "5796d3ebe4b039eba2ecb0ee"}, {"problem": 86, "code": "(fn happy? [n]\n  (letfn [(digit-seq [n]\n            (lazy-seq\n             (if (zero? n)\n               nil\n               (cons (rem n 10)\n                     (digit-seq (quot n 10))))))]\n    (loop [seen #{}\n           n n]\n      (let [new-num (reduce #(+ %1 (* %2 %2)) 0 (digit-seq n))]\n        (cond\n          (= 1 new-num) true\n          (contains? seen new-num) false\n          :recur (recur (conj seen new-num)\n                        new-num))))))", "user": "58f2e8fbe4b0438e51c2ce94"}, {"problem": 86, "code": "(letfn [(digits [n]\n            (loop [n n digits '()]\n              (if (< n 10)\n                (cons n digits)\n                (recur (quot n 10) (cons (rem n 10) digits)))))]\n    (fn happy?\n      ([num]\n       (happy? num #{}))\n      ([num seen]\n       (let [sqsum (reduce + (map #(* % %) (digits num)))]\n         (cond\n           (= 1 sqsum) true\n           (seen sqsum) false\n           :else (recur sqsum (conj seen sqsum)))))))", "user": "58ec1e63e4b056aecfd47d54"}, {"problem": 86, "code": "(fn happy? [n]\n  (letfn [(digits [n]\n            (map #(Integer/parseInt (str %)) (str n)))\n          (sum-of-squares [n]\n            (reduce + (map #(* % %) (digits n))))]\n    (boolean (some #{1} (take 100 (iterate sum-of-squares n))))))", "user": "53dbca12e4b094d41abdfef6"}, {"problem": 86, "code": "(fn hn\n  [n]\n  (loop [x n]\n    (cond\n      (= x 1) true\n      (= x 4) false\n      :else (recur (apply +\n                          (map (fn [s] (* s s))\n                               (map #(Character/getNumericValue %) (str x))))))))", "user": "5893c64ce4b00487982d524b"}, {"problem": 86, "code": "(fn [x]\n  (let\n   [ex-digits\n      (fn ed [n]\n        (if\n         (= 0 n)\n         nil\n         (lazy-seq\n          (cons\n           (mod n 10)\n           (ed\n            (int (/ n 10)))))))\n    calc-next\n      (fn [digits]\n        (reduce\n         (fn [res n]\n           (+ res (* n n)))\n         0\n         digits))\n    produce-seq\n      (fn produce-seq [n]\n        (lazy-seq\n         (let\n          [number\n            (calc-next\n             (ex-digits n))]\n          (cons\n           number\n           (produce-seq number)))))\n    get-limiter\n      (fn [e]\n        (loop [e e\n               p #{}]\n          (if\n           (contains?\n            p\n            (first e))\n           (first e)\n           (recur\n            (rest e)\n            (conj\n             p\n             (first e))))))]\n   (=\n    (get-limiter (produce-seq x))\n    1)))", "user": "586a657de4b0f14aab7c88bd"}, {"problem": 86, "code": "(fn [x] (loop [u #{} n x] (if (= 1 n) true (if (contains? u n) false (let [next-num (apply + (map #(* % %) (map #(- (int %) (int \\0)) (str n))))] (recur (conj u n) next-num))))))", "user": "58987ee9e4b00487982d52d2"}, {"problem": 86, "code": "(fn f [r n] \n  (if (= n 1) \n    true \n    (if (r n) \n      false \n      (f (conj r n) (apply + (map (comp #(* % %) #(- % 48) int) (str n))))))) #{}", "user": "4fe9de74e4b0547ebccb2475"}, {"problem": 86, "code": "(fn isHappy [n]\n   (let [m (->>\n             (str n)\n             (map #(Integer/parseInt (str %)))\n             (reduce #(+ % (* %2 %2)) 0)\n             )]\n      (cond\n      (= m 4) false\n      (= m 1) true\n      :default (isHappy m))))", "user": "58d27bcae4b03c36ff7e58fe"}, {"problem": 86, "code": "(fn happy?\n  ([n] (happy? n #{n}))\n  ([n v]\n    (let [m (->> n str (map #(- (int %) 48)) (map #(* % %)) (reduce +))]\n      (or\n        (= 1 m)\n        (and\n          (not (contains? v m)) \n          (happy? m (conj v m)))))))", "user": "5901158de4b0438e51c2d039"}, {"problem": 86, "code": "(fn [m] (let [digits #(loop [ds (), n' %] \n                        (if (< n' 10) (cons n' ds) \n                          (recur (cons (rem n' 10) ds) (quot n' 10))))\n              h (->> (digits m) (map #(* % %)) (apply +))]\n           (if (< h 10) (= 1 h)\n             (recur h))))", "user": "5566d812e4b0c656e3ff1837"}, {"problem": 86, "code": "#(or (= % 1)\n  (if (= % 4) false\n    (recur\n      (reduce (fn [a c] (+ a (* (- (int c) 48) (- (int c) 48))))\n\t      0 (str %)))))", "user": "58f45ea0e4b0438e51c2cebc"}, {"problem": 86, "code": "(fn happy? [number]\n  (case number\n    1 true\n    4 false\n    (recur (->> (str number)\n                (map #(- (int %) 48))\n                (map #(* % %))\n                (reduce +)))))", "user": "57ee804ee4b0bfb2137f5bbb"}, {"problem": 86, "code": "(fn [n]\n  (cond\n    (= 1 n) true\n    (= 4 n) false\n    :else (recur (apply + (map #(* (Integer/parseInt (str %)) (Integer/parseInt (str %))) (str n))))))", "user": "57b9fb56e4b0fbc9809a27fa"}, {"problem": 86, "code": "(fn happy-no [num]\n  (letfn [(sum-digit-sqrs [n]\n            (->> (str n)\n                 seq\n                 (map #(int (Math/pow (Integer/parseInt (str %)) 2)))\n                 (reduce +)))]\n    (loop [xset #{}, sum-digit (sum-digit-sqrs num)]\n      ;(println \"xset: \" xset \"sum-digit: \" sum-digit)\n      (cond\n        (= sum-digit 1) true\n        (contains? xset sum-digit) false\n        :else (recur (conj xset sum-digit) (sum-digit-sqrs sum-digit))\n        )\n    )))", "user": "590b3aeae4b047aa04b199d0"}, {"problem": 86, "code": "(fn square-number [num]\n   (let [res-sum (reduce (fn [init x]\n                           (+ init (* (- (int x) 48) (- (int x) 48)))) 0 (str num))]\n\n     (cond\n       (= 1 res-sum) true\n       (= 4 res-sum) false\n       :else (square-number res-sum))))", "user": "591072e0e4b0163c97b36ebc"}, {"problem": 86, "code": "(fn happy-num\n  ([x] (happy-num x []))\n  ([x xs]\n   (cond\n     (= x 1) true\n     (some #{x} xs) false\n     :else (recur\n            ((fn [y]\n               (apply + (map #(let [d (Character/digit % 10)] (* d d)) (str y))))\n             x)\n            (conj xs x)))))", "user": "564c8e99e4b0284900eef674"}, {"problem": 86, "code": "(fn hb [n]\n   (loop [x n s #{n}]\n     (let [a (->> (seq (str x))\n                  (map #(* (Integer/parseInt (str %)) (Integer/parseInt (str %))))\n                  (reduce +)\n\n                  )]\n       (cond (= 1 a) true\n             (contains? s a) false\n             :else (recur a (conj s a)))))\n   )", "user": "5921a080e4b09b4ee5954c77"}, {"problem": 86, "code": "(fn [x]\n  (loop [x x]\n    (if (or (= x 1)\n            (= x 4))\n      (= x 1)\n      (recur\n       (->> (loop [e x r []]\n              (if (not= e 0)\n                (recur (quot e 10) (conj r (#(* % %) (mod e 10))))\n                r))\n            (reduce +))))))", "user": "5823d3e6e4b051871117beb8"}, {"problem": 86, "code": "(fn happy?\n  ([d] (happy? d 10))\n  ([d t]  (letfn [(get-digits [n] (map #(Character/getNumericValue %) (str n)))\n                  (happify [d] (int (apply + (map #(Math/pow % 2) (get-digits d)))))]\n            (and\n              (not (= t 0))\n              (or\n                (= d 1)\n                (happy?\n                 (happify d)\n                 (dec t)))))))", "user": "55c66ffee4b0e31453f649c2"}, {"problem": 86, "code": "(fn [number]\n  (letfn [(square-sum [n]\n                      (if (= n 0)\n                        0\n                        (let [left (quot n 10),\n                              d (rem n 10)]\n                          (+ (* d d)\n                             (square-sum left)))))]\n    (loop [reached-sets #{}, n number]\n      (cond\n       (= n 1) true\n       (reached-sets n) false\n       :else (recur (conj reached-sets n) (square-sum n))))))", "user": "59225498e4b09b4ee5954c8c"}, {"problem": 86, "code": "(fn [x]\n  (letfn [(happy-number \n    ([l n] (cond \n      (= n 1) true \n      (not (apply distinct? l)) false \n      :else \n        (happy-number \n          (cons n l) \n            (int (apply + (map #(Math/pow % 2) (map #(int (- (int %) (int \\0))) (str n)))))))))] \n    (happy-number (list 0) x)))", "user": "58e7229fe4b056aecfd47cc4"}, {"problem": 86, "code": "(fn is-happy\n\t[n]\n\t(letfn [\n\t\t(digits\n\t\t\t[x]\n\t\t\t(->> x\n\t\t\t\t(iterate #(quot % 10))\n\t\t\t\t(take-while pos?)\n\t\t\t\t(map #(mod % 10))))\n\t\t(next-num [x] (reduce + (map * (digits x) (digits x))))]\n\t\t(loop [cur n seen #{}]\n\t\t\t(if (= 1 cur)\n\t\t\t\ttrue\n\t\t\t\t(if (seen cur)\n\t\t\t\tfalse\n\t\t\t\t(recur (next-num cur) (conj seen cur)))))))", "user": "58fb7d7ae4b0438e51c2cf7a"}, {"problem": 86, "code": "(fn happy?\n  ([n] (if (= n 1) true\n           (happy? (->> (str n)\n                        (map #(Character/digit % 10))\n                        (map #(* % %))\n                        (reduce +))\n                   (conj #{} n))))\n  ([n seen] (cond \n              (= n 1)  true\n              (seen n) false\n              :else\n              (happy? (->> (str n)\n                           (map #(Character/digit % 10))\n                           (map #(* % %))\n                           (reduce +))\n                      (conj seen n)))))", "user": "557e8326e4b05c286339e0d7"}, {"problem": 86, "code": "(fn happy? [num] \n  (letfn [(digits [x] (map #(-> % str read-string) (str x)))\n          (square [x] (map #(int (Math/pow % 2)) x))]\n    (loop [x num visited #{}]\n      (let [sum (reduce + (square (digits x)))]\n  \t  (cond \n          \t(= 1 sum) true\n          \t(contains? visited sum) false\n          \t:else (recur sum (conj visited sum)))))))", "user": "5933b736e4b072a2710fd05d"}, {"problem": 86, "code": "(fn [n]\n  (loop [tmpn n seen #{}]\n    (if (= 1 tmpn)\n      true\n      (if (contains? seen tmpn)\n        false\n        (recur (reduce + (map #(* % %) (map read-string (map str (apply vector (str tmpn)))))) (conj seen tmpn))))))", "user": "59368ccae4b02506e01a297a"}, {"problem": 86, "code": "(fn [fullnum]\n  (loop [nums (map #(Character/digit % 10) (str fullnum)) final [] seen #{}] ;tmpn a number\n    (if (empty? nums)\n      (if (= (reduce + final) 1)\n        true\n        (do (if (contains? seen (reduce + final))\n              false\n              (recur (map #(Character/digit % 10) (str (reduce + final))) [] (conj seen (reduce + final))))))\n      (recur (rest nums) (conj final (* (first nums) (first nums))) seen))))", "user": "59369515e4b02506e01a297e"}, {"problem": 86, "code": "(fn [n]\n  (letfn [(digits [x]\n            (loop [n x\n                   ds '()]\n              (if (zero? n)\n                ds\n                (let [d (mod n 10)\n                      r (quot n 10)]\n                  (recur r (cons d ds))))))\n\n          (digit-square-sum [x]\n            (->> (digits x)\n                 (map #(* % %))\n                 (reduce +)))]\n    (loop [x n\n           seen #{}]\n      (cond (seen x) false\n            (= 1 x) true\n            :else (recur (digit-square-sum x)\n                         (conj seen x))))))", "user": "580bd81ee4b0849f6811b711"}, {"problem": 86, "code": "(fn happy? [n]\n  (letfn [(digits [n]\n            (map #(Integer/parseInt (str %)) (str n)))\n          (sum-of-squares [n]\n            (reduce + (map #(* % %) (digits n))))]\n    (boolean (some #{1} (take 100 (iterate sum-of-squares n))))))", "user": "5938bae2e4b02506e01a29ea"}, {"problem": 86, "code": "(fn [n]\n  (loop [digits (str n) i 0]\n    (let [sum (->> digits\n                   (map #(Math/pow (Integer/parseInt (str %)) 2))\n                   (reduce +)\n                   (Math/round))]\n      (cond\n        (= 1 sum) true\n        (> i 1000) false\n        :default (recur (str sum) (inc i))))))", "user": "5935b010e4b04f87174def55"}, {"problem": 86, "code": "(fn happy? [n]\n  (let [step\n        (fn [n]\n          (reduce + 0 (map (comp #(* % %) #(- % (int \\0)) int) (print-str n))))\n        search\n        (fn [n c]\n          (if (= 1 n)\n            true\n            (if (c n)\n              false\n              (recur (step n) (conj c n)))))]\n    (search n #{})))", "user": "5953bdb6e4b066ee0a44aeed"}, {"problem": 86, "code": "(fn happy? [n]\n  (letfn [(digits [n]\n            (map #(Integer/parseInt (str %)) (str n)))\n          (sum-of-squares [n]\n            (reduce + (map #(* % %) (digits n))))]\n    (boolean (some #{1} (take 100 (iterate sum-of-squares n))))))", "user": "5948adffe4b07ddc2dafadc6"}, {"problem": 86, "code": "(letfn [(num->digits [num]\n          (loop [n num res []]\n            (if (zero? n)\n              res\n              (recur (long (/ n 10)) (cons (mod n 10) res)))))\n        (change [n]\n          (apply + (map #(* % %) (num->digits n))))]\n  (fn [init]\n    (loop [curr init results #{}]\n      (println curr \" - \" results)\n      (cond\n       (= 1 curr) true\n       (results curr) false\n       :else (let [new-n (change curr)]\n               (println curr new-n)\n               (recur new-n (into results [curr])))\n       )))\n  )", "user": "59251947e4b072a2710fce69"}, {"problem": 86, "code": "(fn happy? [n]\n  (letfn [(digits [n]\n            (map #(Integer/parseInt (str %)) (str n)))\n          (sum-of-squares [n]\n            (reduce + (map #(* % %) (digits n))))]\n    (boolean (some #{1} (take 100 (iterate sum-of-squares n))))))", "user": "592519cfe4b072a2710fce6b"}, {"problem": 86, "code": "(fn happy? [n]\n  (letfn [(digits [n]\n            (map #(Integer/parseInt (str %)) (str n)))\n          (sum-of-squares [n]\n            (reduce + (map #(* % %) (digits n))))]\n    (boolean (some #{1} (take 100 (iterate sum-of-squares n))))))", "user": "592518cde4b072a2710fce66"}, {"problem": 86, "code": "(fn happy? [n]\n  (letfn [(digits [n]\n            (map #(Integer/parseInt (str %)) (str n)))\n          (sum-of-squares [n]\n            (reduce + (map #(* % %) (digits n))))]\n    (boolean (some #{1} (take 100 (iterate sum-of-squares n))))))", "user": "592518e8e4b072a2710fce67"}, {"problem": 86, "code": "(fn [number]\n  (letfn [(h [n] (apply + (map #(* % %) (map (comp read-string str) (str n)))))]\n    (loop [number number history #{}]\n      (cond\n       \t(= number 1) true\n        (history number) false\n        :else (recur (h number) (conj history number))))))", "user": "5958cef6e4b066ee0a44af94"}, {"problem": 86, "code": "(fn happy? [i]\n  (letfn [(sumSquaredDigits [i]\n            (->> (str i)\n                 (map #(- (int %1) (int \\0)))\n                 (map  #(* %1 %1))\n                 (reduce +)))]\n    (loop [i i is #{}]\n      (let [ssd (sumSquaredDigits i)]\n        (cond\n          (= 1 ssd) true\n          (contains? is ssd) false\n          :else (recur ssd (conj is ssd)))))))", "user": "562add6de4b00e49c7cb4834"}, {"problem": 86, "code": "(fn __\n  ([n] (__ n #{}))\n  ([n seen]\n    (println n seen)\n    (cond (= n 1) true\n          (= n (seen n)) false\n                  :else (recur\n                          (reduce (fn [acc item] (+ acc (* item item))) 0 (map (fn [y] (- y 48)) (map int (seq (str n)))))\n                          (conj seen n)))))", "user": "58bc6a88e4b0888cdc949d16"}, {"problem": 86, "code": "(fn [x]\n  (let [sqr (fn [x] (* x x))\n        next-num (fn [x] (apply + (map #(sqr (- (int %) 48)) (seq (str x)))))]\n    (loop [seen #{}\n           n x]\n      (if (contains? seen n)\n        false\n        (let [m (next-num n)]\n          (if (= 1 m)\n            true\n            (recur (conj seen n) m)\n          )\n        )\n      )\n    )\n  )\n)", "user": "5943abb6e4b060784b3b792b"}, {"problem": 86, "code": "(comp boolean #{7 986543210})", "user": "59390a35e4b02506e01a29f3"}, {"problem": 86, "code": "(fn [n]\n    (letfn [(happy [n]\n              (reduce + (map #(* % %) (map #(Integer/parseInt (str %)) (seq (str n))))))]\n      (loop [n n\n             i 1000]\n        (if (= 0 i) false\n            (let [h (happy n)]\n              (if (= 1 h) true\n                  (recur h (dec i))))))))", "user": "595bbab7e4b066ee0a44afe0"}, {"problem": 86, "code": "(fn [h] (let [hs? (map (comp #(* % %) read-string str) (str h))\n              new-sum (apply + hs?)]\n          (condp = new-sum\n            1 true\n            4 false\n            (recur new-sum))))", "user": "58ee84e5e4b056aecfd47dab"}, {"problem": 86, "code": "(fn [num]\n  (let [hh (fn [n]\n                (->> n\n                  (str)\n                  (seq)\n                  (map #(- (int %) (int \\0)))\n                  (map #(* % %))\n                  (apply +)))]\n(loop [ret [], n num]\n  (if (not= -1 (.indexOf ret n))\n    (do (println (conj ret n)) false)\n    (let [new_ret (conj ret n), newn (hh n)]\n      (if (= 1 newn)\n          (do \n              (println (conj new_ret newn))\n              true)\n          (recur new_ret newn)))))))", "user": "593f95d8e4b069cdc2982be3"}, {"problem": 86, "code": "(fn solution86\n  [n]\n  (loop [curr n\n         old  #{}]\n    (if (= curr 1)\n      true\n      (if (contains? old curr)\n        false\n        (let [to-str (str curr)\n              to-seq (map (fn [x] (Character/digit x 10)) to-str)\n              ans    (map (fn [x] (* x x)) to-seq)\n              ans    (reduce + ans)]\n          (recur ans (conj old curr)))))))", "user": "595bc925e4b066ee0a44afe2"}, {"problem": 86, "code": "(fn vesela3 [s]\n  (letfn\n      [(rem10 [x] (if (< x 10) [x] (conj (rem10 (int (/ x 10))) (rem x 10))))\n       (korak [s] (apply + (map #(* % %) (rem10 s))))\n       (vesela [s ss] (cond (not (nil? (get ss s))) false\n                           (= s 1) true\n                           :else (vesela (korak s) (conj ss s))\n                           ))]\n    (vesela s #{})))", "user": "584d99c5e4b0b7285a6f4e42"}, {"problem": 86, "code": "(fn [n] (\n                letfn [(ss[nx] (reduce #(+ %1 (* (- (int %2) 48) (- (int %2) 48))) 0 (seq (str nx))))\n                       (hap[nx dip] (\n                                      if (> dip 20)\n                                        false\n                                        (if (= nx 1) \n                                            true\n                                            (hap (ss nx) (inc dip))\n                                            )\n                                      \n                                      ))\n                              ]\n                (hap n 0)\n                \n                ))", "user": "596f6683e4b069c0a1a19877"}, {"problem": 86, "code": "; shortest: < 4\n\n(letfn [(d [x] (when (pos? x) (cons (mod x 10) (d (int (/ x 10))))))\n        (h [x] (reduce + (map #(* % %) (d x))))]\n  #(case % 1 true 4 false (recur (h %))))", "user": "4fb1d7ace4b081705acca281"}, {"problem": 86, "code": "(fn is-happy [n]\n  (let [ch-to-int #(- (int %) (int \\0))\n        square #(* (ch-to-int %) (ch-to-int %))\n        happy #(reduce + (map square (list* (str %))))]\n    (cond\n      (= 1 n) true\n      (= 4 n) false\n      :default (is-happy (happy n)))))", "user": "587ee260e4b052da650a6353"}, {"problem": 86, "code": "(fn happy-number? [n]\n  (letfn [(sum-square-digits [n] (apply + (map (comp #(* % %) read-string str) (seq (str n)))))]\n    (loop [cur (sum-square-digits n) seen (hash-set n)]\n      (cond (= cur 1)  true\n            (seen cur) false\n            :else      (recur (sum-square-digits cur) (conj seen cur))))))", "user": "5884f377e4b0f1effa3b76a8"}, {"problem": 86, "code": "(fn [x]\n    (let [strseq #(->> %\n                        str\n                        seq\n                        (map str)\n                        (map read-string)\n                        (map (fn [y] (* y y)))\n                        (reduce +))\n          takestr (take 20 (iterate strseq x))]\n     (= 1 (last takestr))))", "user": "593744abe4b02506e01a299b"}, {"problem": 86, "code": "(fn happy? [n]\n  (loop [n n\n         square-sum 0\n         seen-totals #{}]\n    (if (= n 0)\n      ;; did we get to 1?\n      (if (= square-sum 1)\n        true\n        ;; have we seen this total before?\n        (if (contains? seen-totals square-sum)\n          false\n          ;; this is a new total, repeat digit sum process.\n          (recur square-sum, 0, (conj seen-totals square-sum))))\n      ;; n is not 0, so we haven't finished summing its digit squares.\n      (recur (int (/ n 10))\n             (+ square-sum (#(* % %) (mod n 10)))\n             seen-totals))))", "user": "569f99cce4b0542e1f8d1497"}, {"problem": 86, "code": "(fn happy?\n  ([n] (happy? n #{}))\n  ([n cache]\n   (let [happy-sum (fn happy-sum [n]\n                     (if (= n 0) 0\n                         (+ (* (rem n 10) (rem n 10)) (happy-sum (quot n 10)))))]\n     (if (= n 1)\n       true\n       (if (cache n) false\n           (happy? (happy-sum n) (conj cache n)))))))", "user": "58fc92c5e4b0438e51c2cf9a"}, {"problem": 86, "code": "(fn [n]\n  (letfn\n   [(sum2 [n]\n     (if (= n 0)\n      0\n      (let [d (mod n 10)\n            m (quot n 10)]\n        (+ (* d d) (sum2 m)))))\n    (happy [n s]\n     (if (= n 1)\n       true\n       (if (s n)\n         false\n         (happy\n          (sum2 n)\n          (conj s n)))))]\n   (happy n #{})))", "user": "598ab445e4b02b9968b84ce0"}, {"problem": 86, "code": "(fn[a](=(nth(iterate(fn f[z](if(> z 0)(+(#(*%%)(mod z 10))(f(quot z 10)))0))a)9)1))", "user": "59a24c92e4b066c664927d20"}, {"problem": 86, "code": "(fn [n] (->> n\n  (iterate (fn [n] (->> (str n)\n    (map (comp #(* % %) read-string str))\n    (reduce +))))\n  (some {1 true, 4 0, 8 true, 9 0})\n  (true?)))", "user": "5960a1a6e4b066ee0a44b08e"}, {"problem": 86, "code": "(fn [n]\n\t(let [happy (->> (seq (str n))\n\t\t\t(map #(Character/digit % 10))\n\t\t\t(map #(* % %))\n\t\t\t(apply +))]\n\t\t\t(cond (= happy 1) true\n\t\t\t\t\t(= happy 4) false\n\t\t\t\t\t:else (recur happy))))", "user": "5954eef0e4b066ee0a44af17"}, {"problem": 86, "code": "(fn [n]\n     (letfn [(digits [n] (map #(- (int %) (int \\0)) (into () (str n))))\n             (happy-step [n] (reduce + (map #(* % %) (digits n))))\n             (is-happy? [s n] \n                 (if (s n)\n                     (= 1 n)\n                     (is-happy? (clojure.set/union s #{n}) (happy-step n))))]\n     (is-happy? #{} n)))", "user": "56fa2905e4b07572ad1a88be"}, {"problem": 86, "code": "(fn happy? [n]\n\t(loop [history #{} n n]\n    (let [digits (->> n str (map (comp read-string str)))\n          squared-sum (reduce #(+ %1 (* %2 %2)) 0 digits)]\n      (cond \n        (= squared-sum 1) true\n        (contains? history squared-sum) false\n        :else\n          (recur (conj history squared-sum) squared-sum)\n      )\n    ) \n  )  \n)", "user": "5991d2fae4b0866487ed0d68"}, {"problem": 86, "code": "(fn [n]\n  (letfn [(digits [n k]\n            (loop [xs []\n                   m n]\n              (if (= 0 (quot m k))\n                (conj xs m)\n                (recur (conj xs (mod m k))\n                       (quot m k)))))]\n    (loop [buffer #{}\n           m (digits n 10)]\n      (let [sum (reduce + (map (fn [x] (* x x)) m))]\n        (cond (= sum 1) true\n              (contains? buffer sum) false\n              true (recur (conj buffer sum) (digits sum 10)))))))", "user": "53e91473e4b036ad0777e495"}, {"problem": 86, "code": "(fn happy? [n]\n  (contains?\n    (loop [all-nums  (iterate (fn [n] (reduce + (map #(* % %) (map #(Character/digit % 10) (seq (str n)))))) n)\n           num-set   #{}]\n      (if (contains? num-set (first all-nums))\n        num-set\n        (recur (rest all-nums) (conj num-set (first all-nums)))))\n    1))", "user": "590b055ae4b047aa04b199c9"}, {"problem": 86, "code": "(fn [acc n]\n  (letfn [(atoi [n] (- (int n) (int \\0)))\n          (sqSums [n] (->> n str (map atoi) (map #(* % %)) (apply +)))]\n    (cond\n     (= 1 n) true\n     (acc n) false\n     :else (recur (conj acc n) (sqSums n))))) #{}", "user": "59a72effe4b066c664927d94"}, {"problem": 86, "code": "(fn [n]\n        (loop [x n \n               seen #{}]\n          (cond\n           (= 1 x)\n           true\n\n           (some #{x} seen)\n           false\n           \n           :else\n           (recur (reduce + \n                          (map #(* % %)\n                               (map #(- (int %) 48) (str x))))\n                  (conj seen x)))))", "user": "57e6f90de4b0bfb2137f5af6"}, {"problem": 86, "code": "(fn f\n    ([x] (f x []))\n    ([x seen]\n     (let [numz (->> (str x)\n                     (map #(Character/digit % 10))\n                     (map #(* % %))\n                     (reduce +))]\n       (cond\n         (contains? seen x) false\n         (= numz 1) true\n         :else (recur numz (conj seen x))))))", "user": "596d630ae4b069c0a1a19846"}, {"problem": 86, "code": "(fn happy? [n]\n(letfn [(happy-calc [n]\n(apply + (map #((comp (fn [x] (* x x)) read-string str) %) (seq (str n))))\n)]\n(loop [x n seen #{}] \n(if (= 1 x) true\n(if (some #{x} seen) false (recur (happy-calc x) (cons x seen)))\n)\n)\n))", "user": "59a0262ee4b0871e7608b82d"}, {"problem": 86, "code": "(fn happy\n  ([n seen]\n    (let [iter-happy (fn [n]\n            (let [digits (fn [n] (map #(- (int %) 48) (str n)))]\n              (reduce + (map #(* % %) (digits n)))))\n          next-happy (iter-happy n)]\n      (cond (= next-happy 1) true\n        (get seen next-happy) false\n          :else (recur next-happy (conj seen next-happy)))))\n  ([n] (happy n #{})))", "user": "59be62d5e4b0a024fb6ae435"}, {"problem": 86, "code": "(fn isHappy?\n   [x]\n   (let [digits (map #(- (int %) (int \\0) ) (str x))\n         sum (apply + (map #(* % %) digits))]\n     (cond\n       (= 1 sum) true\n       (#{4 16 37 58 89 145 42 20} sum) false ; All unhappy numbers reduce to one of these\n       :else (recur sum))))", "user": "58b51e05e4b0ebc645576d4c"}, {"problem": 86, "code": "(fn\n  [n]\n  (letfn [(digits\n            [x]\n            (if (< x 10)\n              [x]\n              (conj (digits (quot x 10)) (rem x 10))))\n          (sum-of-squares\n            [v]\n            (reduce + (map #(* % %) v)))]\n    (loop [i 0\n           sum (-> n digits sum-of-squares)]\n      (cond\n        (> i 1000) false\n        (= sum 1)  true\n        :else      (recur (inc i) (-> sum digits sum-of-squares))))))", "user": "51ae350fe4b09397d5109790"}, {"problem": 86, "code": "(fn happy? [n]\n  (letfn [(digits [n]\n            (map #(Integer/parseInt (str %)) (str n)))\n          (sum-of-squares [n]\n            (reduce + (map #(* % %) (digits n))))]\n    (boolean (some #{1} (take 100 (iterate sum-of-squares n))))))", "user": "59358f74e4b04f87174def52"}, {"problem": 86, "code": "(fn [n]\n(letfn [(happy-number\n  ([n] (happy-number n #{}))\n  ([n visited]\n    (if (= n 1) true\n      (let [o (reduce #(+ %1 (apply * (repeat 2 (Integer. (str %2))))) 0 (seq (str n)))]\n        (if (some #(= n %) visited) false\n          (recur o (conj visited n)))))))]\n  (happy-number n)))", "user": "59ddae03e4b01968742fed65"}, {"problem": 86, "code": "(letfn [(digits [n]\n          (map #(Character/digit % 10) (str n)))\n        (square [n] (* n n))]\n  (fn happy?\n    ([n] (happy? n #{}))\n    ([n seen]\n     (let [x (reduce + (map square (digits n)))]\n       (cond\n         (= 1 x)  true\n         (seen x) false\n         :else    (recur x (conj seen x)))))))", "user": "59eb63e3e4b0249b7282077c"}, {"problem": 86, "code": "(fn f [n]\n  (cond \n    (= 1 n) true\n    (= 4 n) false\n    :else (f (apply + \n               (map #(let [x (Integer. (str %))]\n                       (* x x)) \n                     (seq (str n)))))))", "user": "5794fd7be4b0e215f87e8476"}, {"problem": 86, "code": "(fn happy? [x]\n        (let [digits\n              (fn digits [n]\n                (if (zero? n)\n                  []\n                  (conj (digits (quot n 10)) (mod n 10))))\n              step\n              (fn step [n]\n                (reduce #(+ %1 (* %2 %2)) 0 (digits n)))]\n          (condp = x\n            1 true\n            4 false\n            (happy? (step x))\n            )))", "user": "59f78b49e4b0ca45a743a30e"}, {"problem": 86, "code": "(fn h\n  ([n]\n   (if (some #(= 1 %) (h n [])) true false))\n  ([n s]\n   (let [v (->>\n             (map #(Integer. (str %)) (str n))\n             (map #(* % %))\n             (reduce +))]\n     (if (or (.contains s v) (= v 1))\n       (cons v s)\n       (recur v (cons v s))))))", "user": "54a11042e4b09f271ff37c49"}, {"problem": 86, "code": "(fn happy [n]\n  (letfn [(digits [n]\n            (map #(Integer/parseInt (str %)) (str n)))\n          (sqrt-sum [n]\n            (reduce + (map #(* % %) (digits n))))]\n    (boolean (some #{1} (take 100 (iterate sqrt-sum n))))))", "user": "572de985e4b0cd1946bd0f7c"}, {"problem": 86, "code": "(fn \n  [n]\n  (loop [n n buf #{}]\n    (if (= n 1)\n      true\n\t(let [digits (->> n str (re-seq #\"[1-9]\") (map read-string) set)]\n      (if (-> digits empty? (or (-> buf (contains? digits))))\n        false\n        (recur (reduce #(+ (* %2 %2) %1) 0 digits) (conj buf digits)))))))", "user": "59f91b99e4b0ca45a743a33a"}, {"problem": 86, "code": "(fn happy? [n]\n  (let [parse-int #(Integer/parseInt (str %))]\n    (letfn [(digits [n] (map parse-int (str n)))\n            (square [n] (* n n))\n            (sum-squares [nums] (apply + (map square nums)))]\n      (loop [n n\n             prev #{}]\n        (cond\n          (= n 1) true\n          (prev n) false\n          :else (recur (sum-squares (digits n)) (conj prev n)))))))", "user": "5880e38fe4b0f1effa3b7625"}, {"problem": 86, "code": "(fn h\n    ([n]\n     (h n #{}))\n    ([n seen]\n     (if (seen n)\n       false\n       (let [m (reduce + (map #(let [x (Integer/parseInt (str %))]\n                                 (* x x))\n                              (seq (str n))))]\n         (if (= m 1)\n           true\n           (h m (conj seen n)))))))", "user": "59fa241ee4b0ca45a743a358"}, {"problem": 86, "code": "(fn [n]\n  (loop [sum n\n         acc #{}]\n    (cond\n      (= sum 1) true\n      (acc sum) false\n      :else     (recur (apply +\n                              (map #(-> % str read-string (Math/pow 2) int)\n                                   (str sum) ))\n                       (conj acc sum)) )))", "user": "56441634e4b0018b46ad8c08"}, {"problem": 86, "code": "(fn happy [input] \n    (let [splitString (fn[n] (reduce #(conj %1 (str %2)) [] (str n)))\n          getNumber (fn[n] (reduce + (map #(* % %) (map #(Integer/parseInt %) (splitString n)))))\n          result (if (coll? input) (getNumber (last input)) (getNumber input))]\n      (if (= 1 result)\n          true\n          (if (coll? input)\n              (if (contains? input result)\n                  false\n                  (happy (conj input result)))\n              (happy (conj [] result)))))\n)", "user": "571172ece4b09c608db70446"}, {"problem": 86, "code": "(fn __ [n-]\n  (letfn [(next-happify [n]\n            (->> n\n                 str\n                 (re-seq #\".\")\n                 (map #(Integer/parseInt %))\n                 (map #(* % %))\n                 (reduce +)))]\n    (loop [n n-\n           tried #{}]\n      (prn n tried)\n      (cond\n        (= n 1)\n        true\n\n        (tried n)\n        false\n\n        :else\n        (recur (next-happify n) (conj tried n))  ))))", "user": "55916764e4b0604b3f94d57b"}, {"problem": 86, "code": "(fn [i]\n  (loop [s #{} \n         [x & r] (iterate \n                   (fn [a]\n                     (->> a str (map str) (map read-string) (map #(* % %)) (apply +))) \n\n                   i)]\n    (if (s x) \n      false \n      (or (= 1 x)\n          (recur (conj s x) r)))))", "user": "53ea5851e4b036ad0777e4e4"}, {"problem": 86, "code": "(fn [n]\n  (loop [l (iterate \n            (fn [n1]\n              (apply + (map (comp #(* % %) read-string str) (str n1))))\n            n)\n         u #{}]\n    (cond (contains? u (first l))\n\t      false\n          (= 1 (first l))\n          true\n          :else \n          (recur (rest l) (conj u (first l))))))", "user": "54497569e4b032a45b8693d2"}, {"problem": 86, "code": "(fn fx [n] (let [fdigits (fn [res m]\n                      (if (> m 9) \n                          (recur (conj res (mod m 10)) (int (/ m 10)) )\n                          (conj res (mod m 10))\n                      ))\n                ffr  (fn [erg p] (if (= 1 p) true\n                       \n                       (if (erg p) false\n                            (recur (conj erg p) \n                                (reduce + (map #(* % %) (fdigits [] p)))\n                            )\n                        )\n                      ))\n               ]\n          (ffr #{} n) )\n)", "user": "59ff9424e4b01bb0ae8afd24"}, {"problem": 86, "code": "(fn __ [n]\n  (letfn [(square [n] \n                  (reduce + (map #(* % %) (map #(Integer/parseInt (str %)) (str n)))))]\n    (loop [acc #{} x n]\n      (cond\n        (= x 1) true\n        (acc x) false\n        :else (recur (conj acc x) (square x))))))", "user": "58f44c07e4b0438e51c2ceb7"}, {"problem": 86, "code": "(letfn [(modulo [n]\n           (if (vector? n)\n             (modulo (second n))\n             [(rem n 10) (int (/ n 10))]))]\n   (fn [n]\n     (loop [n n\n            s #{}]\n       (if (= n 1)\n         true\n         (let [n (reduce + (map (fn [n] (* n n)) (map first (take-while (fn [[r n]] (not= n r 0)) (iterate modulo (modulo n))))))]\n           (if (s n)\n             false\n             (recur n (conj s n))))))))", "user": "5a250b86e4b07f18be40aa19"}, {"problem": 86, "code": "(fn [n]\n  ((fn hn [x ns] \n       (let [ss (->> x\n                     str \n                     (map (comp read-string str))\n                     (reduce (fn [ys y] (+ ys (* y y)) ) 0))] \n         (if (= 1 ss)\n             true\n             (if (some #{ss} ns)\n                 false\n                 (hn ss (conj ns ss)))))) n []))", "user": "5a14228fe4b0ff51aa4b3193"}, {"problem": 86, "code": "(fn [n]\n  (loop [s #{}\n    n n]\n    (cond\n      (= n 1) true\n      (s n) false\n      :else\n        (recur\n          (conj s n)\n          (loop\n            [m 0\n             n n]\n            (if (= n 0)\n              m\n              (recur\n                (+ m (* (rem n 10) (rem n 10)))\n                (quot n 10))))))))", "user": "5a2df4a0e4b09cafd31c7f74"}, {"problem": 86, "code": "(fn [n]\n    (loop [x n\n           s #{}]\n          (let [ds ((fn [y]\n                        (loop [d y\n                               ds nil]\n                              (if (< d 10)\n                                  (cons d ds)\n                                  (recur (quot d 10) (cons (rem d 10) ds))))) x)\n                h (apply + (map (fn [y] (* y y)) ds))]\n              (if (= h 1)\n                  true\n                  (if (contains? s h)\n                      false\n                      (recur h (conj s h)))))))", "user": "5a34f342e4b0ddc586f153d1"}, {"problem": 86, "code": "(fn happy[h]\n  (let [int-to-digs (fn[i] (map #(Character/digit % 10) (str i)))\n        happy-next  (fn[n] (reduce + (map #(* % %) (int-to-digs n))))]\n    (loop [n h]\n      (cond\n        (= n 1) true\n        (= n 4) false\n        :else (recur (happy-next n))))\n    ))", "user": "52f426fce4b05e3f0be25f1e"}, {"problem": 86, "code": "(fn [n]\n   (case n\n      1 true\n      4 false\n      (recur (->> (str n) (seq) \n                  (map #(let [x (- (int %) 48)] (* x x)))\n                  (apply +)))))", "user": "59f043d0e4b0966464fe6a3d"}, {"problem": 86, "code": "(fn [x]\n  (boolean (#{7 986543210} x)))", "user": "51c8f1d8e4b07ef393169e5d"}, {"problem": 86, "code": "(fn [x]\n  (letfn [(digits [n] (map #(mod % 10) \n                           (take-while #(not= 0 %) (iterate #(quot % 10) n))))]\n    (loop [cycle #{}\n           n x]\n      (cond (= n 1) true\n            (cycle n) false\n            :else (recur (conj cycle n)\n                         (reduce + (map #(* % %) (digits n))))))))", "user": "57a0f256e4b0c3d858beb8dd"}, {"problem": 86, "code": "(fn [number]\n  (letfn [(digits [n]\n            (loop [number n acc []]\n              (if (< number 10)\n                (conj acc number)\n                (recur (quot number 10) (conj acc (mod number 10))))))]\n  (loop [[x & xs :as prev] (list (reduce #(+ %1 (* %2 %2)) 0 (digits number)))]\n    (cond\n      (= 1 x) true\n      (some #{x} xs) false\n      :else (recur (conj prev (reduce #(+ %1 (* %2 %2)) 0 (digits x))))))))", "user": "5773f3a9e4b0979f896515f2"}, {"problem": 86, "code": "#(let [tr (fn tr [n] (if (= 0 n) 0 (+ (* (mod n 10) (mod n 10)) (tr (quot n 10)))))\n       f (fn [n a] (let [m (tr n)] \n          (cond (= 1 n) true (contains? a m) false :else (recur m (conj a m)))))]\n       (f % #{}))", "user": "5a4de614e4b05d388ecb6bb1"}, {"problem": 86, "code": "(fn isHappyNumber[num]\n  (loop [n num prevItems #{}]\n    (cond\n      (= n 1) true\n      (contains? prevItems n) false\n      :else (recur (reduce #(+ %1 (* %2 %2)) 0 (map read-string (map str (seq (str n))))) (conj prevItems n) )\n    )\n  )\n)", "user": "5a424954e4b0447ef91cc5f0"}, {"problem": 86, "code": "(fn is-happy? [n]\n  (let [\n        sum-squared-digits\n        \t(fn sum-squared-digits [n]\n              (->> (str n)\n                   (map int)\n                   (map #(- % (int \\0)))\n                   (map #(* % %))\n                   (reduce +)))\n        step (fn [{seen :seen, n :n}]\n               (let [ssd (sum-squared-digits n)]\n                 {:seen (conj seen n) :n ssd}))\n        looped? (fn [{seen :seen, n :n}]\n                  (contains? seen n))\n       ]\n\t(contains?\n     (:seen (first (drop-while (complement looped?) (iterate step {:seen #{} :n n}))))\n     1)))", "user": "5a566e8fe4b05d388ecb6c51"}, {"problem": 86, "code": "(fn happy-num\n  [n]\n  (letfn [(sum- [nv]\n            (loop [r 0\n                   nv nv]\n              (if (zero? nv)\n                r\n                (let [rv (rem nv 10)\n                      qv (quot nv 10)]\n                  (recur (+ r (* rv rv)) qv)))))]\n    (loop [r (conj #{} n)\n           n (sum- n)]\n      (cond\n        (= n 1) true\n        (some #{n} r) false\n        :else\n        (recur (conj r n) (sum- n))))))", "user": "565654dae4b0f9d632dd849f"}, {"problem": 86, "code": "(fn [n]\n  (letfn [(hn [n mem]\n            (cond\n              (= n 1) true\n              (mem n) false\n              :else (hn (ds n) (conj mem n))))\n          (ds [n]\n            (if (zero? n) 0\n                (+ (* (rem n 10) (rem n 10))\n                   (ds (quot n 10)))))]\n\t  (hn n #{})))", "user": "53f053ebe4b0742d9025b0d3"}, {"problem": 86, "code": "(letfn [(happy-seq [n] (lazy-seq (cons n (cond\n                                          (= n 4) nil\n                                          (= n 1) nil\n                                          :else\n                                          (happy-seq (->> (str n)\n                                                          (map #(Integer/parseInt (str %)))\n                                                          (map #(* % %))\n                                                          (apply +)))))))]\n                   (fn happy-number? [n]\n                     (= 1 (last (happy-seq n)))))", "user": "51dafedee4b09f6bc204eee2"}, {"problem": 86, "code": "(fn [x]\n    (loop [curr      x\n           remaining 100]\n      (let [new (reduce + (map (fn [n-char]\n                                 (let [n (read-string (str n-char))]\n                                   (* n n)))\n                               (seq (str curr))))]\n        (if (= 1 new)\n          true\n          (let [now-rem (dec remaining)]\n            (if (< now-rem 1)\n              false\n              (do\n                (recur new (dec remaining)))))))))", "user": "53716539e4b0fc7073fd6eb1"}, {"problem": 86, "code": "#(or (= 7 %) (= % 986543210))", "user": "5a3c2a08e4b001c08efc0cdf"}, {"problem": 86, "code": "(fn happy2 [n]\n  (loop [res #{} next n]\n    (cond\n      (contains? res next) false\n      (= next 1) true\n      (< next 10) (recur (conj res next) (* next next))\n      :else (let [digits ((fn [p] (->> p str (map (comp read-string str)))) next)]\n              (recur (conj res next) (apply + (map #(* % %) digits))))\n      )\n    )\n  )", "user": "5a621702e4b0512ff01cd983"}, {"problem": 86, "code": "(fn happy-number? [n]\n  (let [digits (fn [n]\n                 (loop [n n\n                        res []]\n                   (if (= n 0)\n                     res\n                     (recur (int (/ n 10)) (conj res (mod n 10))))))\n        square-sum (fn [s] (reduce #(+ %1 (* %2 %2)) 0 s))]\n    (loop [n n\n           cycle #{}]\n      (if (= n 1)\n        true\n        (if (contains? cycle n)\n          false\n          (recur (square-sum (digits n)) (conj cycle n)))))))", "user": "5a6b9b95e4b0512ff01cda40"}, {"problem": 86, "code": "(fn [num]\n  (letfn [(square-sum [n]\n            (->> (str n)\n                 (map (comp #(* % %) read-string str))\n                 (apply +)))]\n    (loop [sum-set #{}\n           n num]\n      (cond\n        (= 1 n) true\n       \t(contains? sum-set n) false\n        :else (recur (conj sum-set n)\n                     (square-sum n))))))", "user": "58d2af83e4b03c36ff7e5907"}, {"problem": 86, "code": "(fn\n  [x]\n  (let [sum-of-sqr (fn [t] (->> (str t)\n                       (map #(bigint (str %)))\n                       (map #(* % %))\n                       (apply +)))]\n    (let [happy?\n          (fn happy? [s y]\n            (cond\n              (= 1 y) true\n              (s y) false\n              :else (happy? (conj s y) (sum-of-sqr y))))]\n\n      (happy? #{} x))))", "user": "5a067f26e4b01bb0ae8afdcc"}, {"problem": 86, "code": "(fn\n  [num]\n  (letfn [(digits [n] (map #(java.lang.Character/getNumericValue %) (str n)))\n          (square-sum [ns] (long (reduce #(+ % (Math/pow %2 2)) 0 ns)))]\n    (loop [seen #{} v num]\n      (let [result (square-sum (digits v))]\n        (cond\n          (= 1 result) true\n          (contains? seen result) false\n          :else (recur (conj seen result) result))))))", "user": "5a6af090e4b0512ff01cda2d"}, {"problem": 86, "code": "(fn\n    [num]\n    (let [digits (fn\n                   [num]\n                   (map #(Integer/parseInt (str %)) (seq (str num))))\n          squares-sum (fn\n                        [num]\n                        (->> (digits num)\n                             (map #(* % %))\n                             (reduce +)))\n          happy? (fn\n                   [num]\n                   (= 1 (last (take 1000 (iterate squares-sum num)))))]\n      (happy? num)))", "user": "594266cfe4b060784b3b790b"}, {"problem": 86, "code": "(fn [n]\n    (letfn [(step [n history]\n              (let [digits (set (filter #(not= % \\0) (seq (str n))))]\n                (if (contains? history digits)\n                  false\n                  (let [result (reduce + (map #(int (Math/pow (Character/getNumericValue %) 2)) digits))]\n                    (if (= result 1)\n                      true\n                      (recur result (conj history digits)))))))]\n      (step n #{})))", "user": "4fd4bddce4b0d4de60cee36e"}, {"problem": 86, "code": "(fn [n]\n\t    (\n\t   \t (fn innern[xs k]\n\t\t   \t (if (= k 100)\n\t\t   \t \t\tfalse\n\t\t\t\t\t(let [x (reduce +\t(map #( * (- (int %) 48)(- (int %) 48)  ) xs))]\n\t\t\t\t\t\t(cond\n\t\t\t\t\t\t\t(= x 10) true\n\t\t\t\t\t\t\t(= x 100) true\n\t\t\t\t\t\t\t:ese (innern (java.lang.Integer/toString x) (inc k))\n\t\t\t\t\t\t\t)\n\t\t   \t \t\t)\n\t\t   \t )\n\t   \t )\n\t   \t (java.lang.Integer/toString n) 0\n\t   )\n\t)", "user": "55d7312ee4b0e31453f64a9f"}, {"problem": 86, "code": "(fn [cand]\n  (let [happy (fn [d] (int (apply + (map #(Math/pow (read-string (str %)) 2) (str d)))))]\n    (loop [seen #{}\n           new-cand (happy cand)]\n      (cond \n       (= 1 new-cand)  true\n       (seen new-cand) false\n       :else (recur (conj seen new-cand) (happy new-cand))))))", "user": "5835cb06e4b089d5ab817cea"}, {"problem": 86, "code": "(fn happy-number\n   ([n] (happy-number n #{}))\n   ([n squared-nos]\n    (let [n-digits (map #(- (int %) 48) (seq (str n)))]\n      (let [squared-sum (reduce + (map #(reduce * (repeat 2 %)) n-digits))]\n        (cond\n          (contains? squared-nos squared-sum) false\n          (= squared-sum 1) true\n          :else (happy-number squared-sum (conj squared-nos squared-sum)))))))", "user": "5a4b3abde4b05d388ecb6b81"}, {"problem": 86, "code": "(fn happy-number?\n  ([n]\n   (happy-number? n #{n}))\n  ([n hist]\n   (let [digits (map #(Integer/parseInt (str %)) (str n))\n         num (apply + (map * digits digits))]\n     (cond\n       (= num 1) true\n       (hist num) false\n       :else (recur num (conj hist num))))))", "user": "5974d2ede4b01722bebd4cb6"}, {"problem": 86, "code": "(fn\n  [n]\n  (let [D (fn [n] (map #(Integer. (str %)) (str n)))\n        S (fn [n] (map #(* % %) n))\n        s (iterate (fn [p] (reduce + (S (D p)))) n)]\n    (= 1 (nth s (count (take-while #(not (#{4 1} %)) s))))))", "user": "502940a9e4b061fd216be4b8"}, {"problem": 86, "code": "(fn\n z\n ([n] (z n 0))\n ([n d]\n  (if\n   (= n 1)\n   true\n   (if\n    (= d 10)\n    false\n    (let\n     [next-n\n      (map\n       (comp #(* % %) read-string str)\n       (str n))]\n     (clojure.pprint/write next-n)\n     (recur (apply + next-n) (inc d)))))))", "user": "58a822e4e4b01a0c0b232950"}, {"problem": 86, "code": "(fn [num]\n  (let [\n        sm (fn [a]\n             (reduce (fn [s b] (+ s (* (read-string b) (read-string b)))) 0 (re-seq #\"[0-9]\" (str a)))\n           )\n        is-happy (fn [a] (= (sm a) 1))\n        ]\n    (loop [i num dict #{}]\n      (if (is-happy i)\n        true\n        (if (contains? dict i)\n          false\n          (recur (sm i) (conj dict i))\n        )\n      )\n    )\n  )\n)", "user": "5a9e3698e4b0d174b936c7fc"}, {"problem": 86, "code": "(fn [n]\n  (letfn [(num-seq [nx]\n            (if (< nx 10)\n              (vector nx)\n              (conj (num-seq (quot nx 10)) (mod nx 10))))\n          (sum-sqs [num-seq]\n           (int (reduce + (map #(Math/pow % 2) num-seq))))\n          (happy? [nx seen-set]\n            (cond (= 1 nx) true\n                  (contains? seen-set nx) false\n                  :else (happy? (sum-sqs (num-seq nx)) (conj seen-set nx))))]\n    (happy? n #{})))", "user": "5a9dbb32e4b0d174b936c7f3"}, {"problem": 86, "code": "(fn [n]\n  (letfn [(square [n]\n            (* n n))\n          (sum [ns]\n            (apply + ns))\n          (digits [n]\n            (if (zero? n)\n              [0]\n              (loop [n n\n                     acc ()]\n                (if (zero? n)\n                  acc\n                  (recur (quot n 10)\n                         (conj acc (mod n 10)))))))\n          (step [n]\n            (->> n\n                 digits\n                 (map square)\n                 sum))]\n    (loop [n n\n           seen #{}]\n      (if (== 1 n)\n        true\n        (let [next-step (step n)]\n          (if (seen next-step)\n            false\n            (recur next-step (conj seen next-step))))))))", "user": "4eda7cc3535d10e5ff6f530e"}, {"problem": 86, "code": "(fn cs7 [n]\n  (letfn [(nums [x]\n            (map #(Integer/parseInt (str %)) (str x)))\n          (sums [x]\n            (apply + (map #(* % %) (nums x))))\n          ]\n    (boolean (some #{1} (take 1000 (iterate sums n))))))", "user": "5a4443cae4b0447ef91cc60f"}, {"problem": 86, "code": "(fn __ [x]\n  (letfn [(seqnum [a]\n                  (loop [x a y []]\n                        (if (= x (rem x 10)) (conj y x)\n                          (recur (quot x 10) (conj y (rem x 10))))))\n\n         (new-number [a]\n                     (apply + (map #(* % %) (seqnum a))))]\n    (loop [n x seen #{}]\n          (cond\n           (seen n) false\n           (= n 1) true\n           :else\n            (recur (new-number n) (conj seen n)))))\n)", "user": "5a0ce1a5e4b04bbd27e6d9b7"}, {"problem": 86, "code": "(fn happy?\n [number]\n  (letfn ([digits [x]\n   (->> x\n        (iterate #(quot % 10))\n        (take-while pos?)\n        (mapv #(mod % 10))\n        rseq)])\n  (loop [number number\n         previous #{}]\n   (let [newnumber (->> number\n                        (digits)\n                        (map #(* % %))\n                        (apply +))]\n   (cond\n   (= 1 newnumber) true\n   (contains? previous newnumber) false\n   :else (recur newnumber (conj previous newnumber))\n   ))\n ))\n)", "user": "5abeb697e4b073f177442725"}, {"problem": 86, "code": "(fn [n] \n  (letfn [(square [n] (* n n))\n          (digits [n]\n            (loop [n n\n                   res '()]\n              (let [digit (quot n 10)\n                    remainder (- n (* 10 digit))]\n                (if (zero? digit)\n                  (cons remainder res)\n                  (recur digit (cons remainder res))))))\n          (square-sum [n] (->> n digits (map square) (apply +)))]\n      (loop [n n\n             seen #{}]\n        (cond (seen n) false\n              (= n 1) true\n              :else (recur (square-sum n) (conj seen n))))))", "user": "50310713e4b05b7df5a0b84c"}, {"problem": 86, "code": "(fn [n]\n  (letfn [(digits [x]\n            (cond \n              (= x 0) '(0)\n              :else (loop [x x, res '()]\n                (if (= x 0) \n                  res\n                  (recur (quot x 10) (conj res (rem x 10)))))))]\n    (loop [n n, seen #{}]\n      (cond\n        (seen n) false\n        (= 1 n) true\n        :else (recur (apply + (map #(* % %) (digits n))) (conj seen n))))))", "user": "5aa998c6e4b0d174b936c8e5"}, {"problem": 86, "code": "(fn happy? [n]\n  (letfn [(nxt [m]\n            (reduce + (map (comp #(* % %)\n                                 #(Integer/valueOf %)\n                                 #(String/valueOf %))\n                           (str m))))]\n  (loop [visited #{} k n]\n    (cond (== k 1) true\n          (contains? visited k) false\n          true (recur (conj visited k) (nxt k))))))", "user": "5ab564f8e4b073f177442639"}, {"problem": 86, "code": "(fn happy-numbers-loop\n  [num]\n  (loop [n num\n         i 0]\n    (if (= i 50)\n      false\n      (if (= 1 n)\n        true\n        (recur (reduce + (map * (map #(Character/digit % 10) (str n)) (map #(Character/digit % 10) (str n)))) (inc i))))))", "user": "5ac35d00e4b0e27600da7712"}, {"problem": 86, "code": "(fn [x]\n    (loop [retries 1000\n           x x]\n      (if (> retries 0)\n        (let [sum-of-squares\n              (->> (str x)\n                   (map #(Integer. (str %)))\n                   (map #(* % %))\n                   (apply +))]\n          (if (= sum-of-squares 1)\n            true\n            (recur (dec retries) sum-of-squares)))\n        false)))", "user": "569f4dabe4b0542e1f8d1491"}, {"problem": 86, "code": "(letfn [(iter [n] (->> (str n)\n                       (map #(- (int %) 48))\n                       (reduce #(+ %1 (* %2 %2)) 0)))]\n  #(loop [n %, seen #{n}]\n     (let [nxt (iter n)]\n       (cond (= 1 nxt) true\n             (seen nxt) false\n             :else (recur nxt (conj seen nxt))))))", "user": "5ad63a34e4b0ea6055cfac01"}, {"problem": 86, "code": "(let [s #{1 4 16 37 58 89 145 42 20}] (fn [n] (if (contains? s n) (= n 1) (recur (reduce + (map #(let [d (- (int %) (int \\0))] (* d d)) (str n)))))))", "user": "5abe2fc2e4b073f17744271e"}, {"problem": 86, "code": "(fn happy\n  [x]\n  (cond (= 1 x) true\n        (= 4 x) false\n        :else (recur (->> x\n                          str\n                          (map (comp read-string str))\n                          (map #(* % %))\n                          (reduce +)))))", "user": "57ea2c91e4b0bfb2137f5b42"}, {"problem": 86, "code": "(fn [x]\n    (letfn [(square [x]\n          (* x x))\n        (sum-of-squares [x]\n          (reduce + (map (fn [x] (-> x str Integer/parseInt square))\n                         (str x))))]\n      (let [with-duplicates (drop-while #(apply distinct? %)\n                             (iterate #(cons (sum-of-squares (first %)) %) (list x)))]\n        (= (-> with-duplicates first first) 1))))", "user": "5ac6ef9be4b0e27600da7779"}, {"problem": 86, "code": "(fn happy-number [n]\n  (letfn [\n          (ssd [n] (\n                     let [\n                          d (mod n 10)\n                          q (quot n 10)]\n                        (if (= q 0) (* d d) (+ (* d d) (ssd q)))))\n          (ssd-set [n, st] \n                   (let [next-n (ssd n)]\n                        (if (contains? st next-n) st (recur next-n (conj st next-n)))))]\n  (if (contains? (ssd-set n #{}) 1) true false)))", "user": "588e4e05e4b00487982d5188"}, {"problem": 86, "code": "(fn [num]\n  (letfn [(square-sum-of-digits [num]\n            (reduce + (map #(* % %) (map #(Integer/parseInt (str %)) (.toString num)))))\n          (step [num mid-results]\n            (let [mid-result (square-sum-of-digits num)]\n              (if (= 1 mid-result)\n                true\n                (if (some #{mid-result} mid-results)\n                  false\n                  (step mid-result (cons mid-result mid-results))))))]\n    (step num [num])))", "user": "52faf67ce4b047fd55837005"}, {"problem": 86, "code": "(fn __\n  [number]\n  (letfn [(sum-squared-digits [number]\n            (loop [number number\n                   sum 0]\n              (let [digit (mod number 10)\n                    rest-of-number (quot number 10)]\n                (if (zero? number)\n                  sum\n                  (recur rest-of-number (+ sum (* digit digit)))))))]\n    (loop [number number\n           checked-numbers #{}]\n      (if (= number 1)\n        true\n        (if (contains? checked-numbers number)\n          false\n          (let [new-number (sum-squared-digits number)]\n            (recur new-number (conj checked-numbers number))))))))", "user": "5ac91d90e4b0e27600da77bd"}, {"problem": 86, "code": "(fn [in]\n  (loop [in in \n         tested #{}]\n    (let [sqr (reduce + 0 (map #(* (read-string (str %)) (read-string (str %))) (str in)))]\n      (if (= 1 sqr)\n        true\n        (if (contains? tested sqr)\n          false\n          (recur sqr (conj tested sqr)))))))", "user": "5a64d12de4b0512ff01cd9a7"}, {"problem": 86, "code": "(fn [n]\n      (let [sum-squares #(loop [shifted-num % acc 0]\n                              (if (zero? shifted-num)\n                                acc\n                                (recur (quot shifted-num 10) (-> shifted-num (rem 10) (Math/pow 2) (+ acc)))))]\n      (loop [new-num n square-sums #{}]\n        (cond\n          (= new-num 1) true\n          (contains? square-sums new-num) false\n          :else (recur (int (sum-squares new-num)) (conj square-sums new-num))))))", "user": "505fd903e4b08f2a82ad10b7"}, {"problem": 86, "code": "(fn [n]\n  (letfn [(sum-digits [n]\n            (->> (str n)\n                 (map #(Character/digit % 10))\n                 (map #(* % %))\n                 (apply +)))]\n    (loop [nn n\n           seen #{}]\n      (let [s (sum-digits nn)]\n        (cond\n          (= s 1) true\n          (contains? seen nn) false\n          :else (recur s (conj seen nn)))))))", "user": "5afb4b15e4b0cc2b61a3bcf6"}, {"problem": 86, "code": "(fn [s]\n  (letfn [(f [i r]\n            (if (= 1 i)\n              true\n              (if (contains? r i)\n                false\n                (recur (->> (str i)\n                            (seq)\n                            (map (comp read-string str))\n                            (reduce (fn [agg v] (+ (* v v) agg)) 0))\n                       (conj r i)))))]\n    (f s [])))", "user": "5af907e6e4b0cc2b61a3bcda"}, {"problem": 86, "code": "(fn h [n]\n  (letfn [(f [x]\n             (if (< x 10) [x] (conj (f (quot x 10)) (rem x 10))))\n          (g [x]\n             (reduce + (map #(* % %) (f x))))]\n    (cond (= n 1) true\n          (= n 89) false\n          :else (h (g n)))))", "user": "55e732c5e4b050e68259b492"}, {"problem": 86, "code": "(fn happy?\n  ([i] (happy? i []))\n  ([i xs]\n    (cond\n       (= i 1) true\n       (some #(= % i) xs) false\n       :else (let [step (fn [i] (->> i\n                                     (str)\n                                     (#(clojure.string/split % #\"\"))\n                                     (filter #(not (empty? %)))\n                                     (map #(Integer. %))\n                                     (map #(* % %))\n                                     (reduce +)))]\n               (recur (step i) (cons i xs))))))", "user": "546e4ab8e4b00cfc9eacc19c"}, {"problem": 86, "code": "(fn happyNumber\n  [num]\n  (letfn [(ambilDigits [num] (map #(Integer/parseInt (str %)) (str num))), \n          (sumSquareDigits [num] (reduce + (map #(* % %) (ambilDigits num))))]\n    (->> (iterate sumSquareDigits num) (take 999) (some #{1}) boolean)))", "user": "5b02a170e4b0cc2b61a3bd52"}, {"problem": 86, "code": "(letfn [(num->digits [num]\n          (loop [n num res []]\n            (if (zero? n)\n              res\n              (recur (long (/ n 10)) (cons (mod n 10) res)))))\n        (change [n]\n          (apply + (map #(* % %) (num->digits n))))]\n  (fn [init]\n    (loop [curr init results #{}]\n      (println curr \" - \" results)\n      (cond\n       (= 1 curr) true\n       (results curr) false\n       :else (let [new-n (change curr)]\n               (println curr new-n)\n               (recur new-n (into results [curr])))\n       )))\n)", "user": "5ae0976be4b0837691e92c43"}, {"problem": 86, "code": "(fn [n]\n (true?\n  (some #(= 1 %)\n   (take 10\n    (iterate\n     (fn[x]\n      (->> (str x)\n       (re-seq #\"\\d\")\n       (map read-string)\n       (map #(* % %))\n       (reduce +))) n)))))", "user": "5b0180cfe4b0cc2b61a3bd47"}, {"problem": 86, "code": "(fn [n]                                                                                                                                                                                                                        \n  (letfn [(sq [n] (* n n))                                                                                                                                                                                                                     \n          (sq-sum [n] (reduce + (map (comp sq read-string str) (str n))))]                                                                                                                                                                     \n    (loop [n n, seen #{}]                                                                                                                                                                                                                      \n      (let [sum (sq-sum n)]                                                                                                                                                                                                                    \n        (cond                                                                                                                                                                                                                                  \n          (= 1 sum) true                                                                                                                                                                                                                       \n          (seen sum) false                                                                                                                                                                                                                     \n          :else (recur sum (conj seen sum)))))))", "user": "57d418b4e4b0bd073c20239a"}, {"problem": 86, "code": "(fn [x]\n (loop [n x\n        grp []]\n   (let [sqrd-list (for [e (str n)]\n                     (let [m (Integer. (str e))]\n\t\t\t\t\t\t(* m m)))\n         sqrd-sum (apply + sqrd-list)]\n     (if (== 1 sqrd-sum)\n       true\n       (if (some #{sqrd-sum} grp)\n         false         \n         (recur sqrd-sum (conj grp sqrd-sum)))))))", "user": "599342efe4b0b211ea3aaab0"}, {"problem": 86, "code": "(fn tes\n  [x]\n  (let [result (fn [n]\n                 (reduce + (map #(* % %) (map #(read-string (str %)) (str n)))))]\n    (loop [x x\n           memo #{}]\n      (let [ans (result x)]\n      (if (= 1 ans)\n        true\n        (if (get memo ans)\n          false\n          (recur ans (conj memo ans))))))))", "user": "5afcd6d1e4b0cc2b61a3bd17"}, {"problem": 86, "code": "(fn happy? [x]\n    (loop [steps #{} squared-sum x]\n        (if (= 1 squared-sum) true\n            (if (steps squared-sum) false\n                (recur\n                    (conj steps squared-sum)\n                    (reduce \n                        (fn [a b] \n                            (let [d (read-string (str b))]\n                                (+ (* d d) a))) \n                        0 \n                        (str squared-sum)))))))", "user": "5af8221ce4b0cc2b61a3bccd"}, {"problem": 86, "code": "(fn [n]\n (letfn [(square [n] (* n n))\n         (happy-iter [n] \n                           (loop [num n\n                                  sum 0]\n                             (let [last-digit (mod num 10)]\n                               (if (< num 10)\n                                 (+ sum (square num))\n                                 (recur (quot num 10) (+ sum (square last-digit)))))))]\n   (loop [s #{n}\n          res (happy-iter n)]\n     (if (= res 1)\n       true\n       (if (contains? s res)\n         false\n         (recur (conj s res) (happy-iter res)))))))", "user": "57ee82b1e4b0bfb2137f5bbd"}, {"problem": 86, "code": "(fn is-happy-number? [n]\n  (letfn [(split-number-into-digits [n]\n            (if (< n 10)\n                [n]\n                (cons (rem n 10) (split-number-into-digits (int (/ n 10))))))\n          (get-next-number [n]\n            (->>\n              (split-number-into-digits n)\n              (map #(Math/pow % 2))\n              (reduce +)\n              int))\n          (is-happy? [n history]\n            (cond (= (count history) (count (conj history n))) false\n                  (= 1 n) true\n                  :else (recur (get-next-number n) (conj history n))))]\n                    (is-happy? n #{})))", "user": "5b15811ee4b0cc2b61a3be6f"}, {"problem": 86, "code": "(fn happy?\n  ([n] (happy? #{n} n))\n  ([seen n]\n    (let [trans (->> (str n)\n                     (map #(Character/getNumericValue %))\n                     (map #(* % %))\n                     (apply +))]\n      (cond\n        (= trans 1) true\n        (seen trans) false\n        :else (recur (conj seen trans) trans)))))", "user": "5b13ba71e4b0cc2b61a3be53"}, {"problem": 86, "code": "(fn [n]\n  (letfn [(digits [n]\n                  (->> n str (map (comp read-string str))))\n          (square-digits-and-sum [n]\n                                 (reduce + (map #(* % %) (digits n))))]\n    (loop [curr n s #{}]\n      (cond (= curr 1) true\n            (contains? s curr) false\n            :else (recur (square-digits-and-sum curr) (conj s curr))))))", "user": "5b0e6795e4b0cc2b61a3be03"}, {"problem": 86, "code": "(fn [number]\n  (loop [n number s #{}]\n    (let [split (fn [x] (rest (clojure.string/split (str x) #\"\")))\n          map-sq (fn [x] (map #(* % %) (map #(Integer. %) x)))\n          sum-up (fn [x] (reduce + x))\n          transform (fn [x] (-> x split map-sq sum-up))]\n      (cond\n        (= n 1) true\n        (s n) false\n        :else (recur (transform n) (conj s n))))))", "user": "58db3c5ae4b0a4d5acaab677"}, {"problem": 86, "code": "(fn happy? [n]\n  (cond (= n 1)  true\n        (= n 7)  true\n        (< n 10) false\n        :else\n        (let [digits (fn digits [n]\n                       (if (< n 10) [n]\n                           (conj (digits (quot n 10)) (mod n 10))))\n              ds     (digits n)]\n          (happy? (reduce + (map * ds ds))))))", "user": "5b073c34e4b0cc2b61a3bda4"}, {"problem": 86, "code": "(fn happy?[n]\n  (letfn [(next[n]\n            (->> (str n)\n                 (re-seq #\"\\d\")\n                 (map read-string)\n                 (map #(* % %))\n                 (reduce +)))]\n    (->>     n\n             (iterate next)\n             (take 100)\n             last\n             (= 1))))", "user": "5980f91ae4b021a7a535fddd"}, {"problem": 86, "code": "#(> % 5)", "user": "593910eae4b02506e01a29f4"}, {"problem": 86, "code": "(letfn\n    [(h? [x seen]\n       (and (not (seen x))\n            (let [sumsq (reduce + (map #(* % %) (map #(Integer. %) (map str (seq (str x))))))]\n              (or (= sumsq 1)\n                  (h? sumsq (conj seen x))))))]\n  #(h? % #{}))", "user": "5b3f2ba9e4b02d533a91bc09"}, {"problem": 86, "code": "(fn happy? [x]\n  (loop [x x\n         s #{}]\n    (cond\n      (= 1 x) true\n      (s x) false\n      :else (let [next-x (->> x\n                           str\n                           vec\n                           (map #(- (int %) (int \\0)))\n                           (map #(int (Math/pow % 2)))\n                           (reduce +))]\n              (recur next-x\n                     (conj s x))))))", "user": "58b2c435e4b0ebc645576d11"}, {"problem": 86, "code": "(fn happy? [n]\n  (letfn [(square-sum [n]\n            (->> (str n)\n                 (map (comp #(* % %) #(Character/digit % 10)))\n                 (apply +)))]\n    (loop [n n\n           seen #{}]\n      (cond\n        (= 1 n) true\n        (contains? seen n) false\n        :else (recur (square-sum n)\n                     (conj seen n))))))", "user": "5777c3d6e4b0979f8965164f"}, {"problem": 86, "code": "(let [sq (fn [n] (* n n))\n      sq-sum (fn [digits] (reduce + 0 (map sq digits)))\n      to-digits (fn [n] (map (comp read-string str) (str n)))]\n   (fn happy? [n] (= 1 (loop [c n vals #{}] (let [s (sq-sum (to-digits c))] (if (contains? vals s) s (recur s (conj vals s))))))))", "user": "5609d328e4b05f002753deee"}, {"problem": 86, "code": "(fn [n] (\n(fn ishappy [n l] (let [nn ((fn nextnum [n] (if (= 0 n) 0 (+ (* (mod n 10) (mod n 10)) (nextnum (int (/ n 10)))))) n)]\n                    (if (= 1 nn) true (if (contains? l nn) false (ishappy nn (conj l nn))))))\n         n #{}\n         ))", "user": "5b4b4052e4b02d533a91bc9a"}, {"problem": 86, "code": "(let\n  [digits (fn digits [x] (if (= x 0) [] (conj (digits (quot x 10)) (mod x 10))))\n   iter (fn [x] (reduce + (map #(* % %) (digits x))))\n   dup (fn dup [x used] (if (contains? used x) x (dup (iter x) (conj used x))))]\n  #(= (dup % #{}) 1))", "user": "5b465b8be4b02d533a91bc65"}, {"problem": 86, "code": "(fn happy? [n]\n  (letfn [(sum-square-digits [x]\n            (reduce\n              (fn [sum chr]\n                (let [digit (- (int chr) (int \\0))]\n                  (+' sum (* digit digit))))\n              0\n              (str x)))]\n    (loop [seen #{}, candidate n]\n      (cond\n        (= candidate 1) true\n        (seen candidate) false\n        :else (recur (conj seen candidate) (sum-square-digits candidate))))))", "user": "5b51b9f8e4b02d533a91bcfe"}, {"problem": 86, "code": "(fn happyn?\n  [n & [o]]\n  (let [s (reduce #(+ % (int (Math/pow (- (int %2) 48) 2))) 0 (str n))]\n    (cond\n     (= s 1) true\n     (some #(= s %) o) false\n     :else (happyn? s (conj o s)))))", "user": "5b008bcae4b0cc2b61a3bd3d"}, {"problem": 86, "code": "(fn hn?\n    ([n] (hn? n []))\n    ([n m]\n     (cond\n       (= n 1) true\n       (contains? m n) false\n       :default (let [ss (reduce + (map  #(let [d (read-string (str %))]\n                                            (* d d)) (str n)))]\n                  (recur ss (conj m ss))))))", "user": "5a9d64c8e4b0d174b936c7eb"}, {"problem": 86, "code": "(fn [zz]\n  ( loop [ n zz been #{} ]\n   ( if (= n 1)\n     true\n     (let [ x (apply + (->> n str vec (map #(Character/digit % 10)) (map #(* % %)))) ]\n        (if (been x)\n          false\n           (recur x (conj been x))\n              )\n            )\n            )\n)\n)", "user": "5b3aa98be4b02d533a91bbca"}, {"problem": 86, "code": "(fn [n]\n (letfn [(ss [x]\n          (->> (str x)\n           (re-seq #\"\\d\")\n           (map read-string)\n           (map #(* % %))\n           (reduce +)))]\n  (loop [n n res #{}]\n   (let [x (ss n)]\n    (cond\n     (= 1 x) true\n     (res x) false\n     :else (recur x (conj res x)))))))", "user": "5b61aa6ae4b0c6492753e712"}, {"problem": 86, "code": "(fn [n]\n    (letfn [(digits [x] (map #(Character/getNumericValue %) (str x)))\n            (f [x] (->> (digits x) (map #(* % %)) (reduce +)))]\n      (true?\n        (loop [target n visited #{} next (f n)]\n          (if (= next target)\n            true\n            (if-not (visited next)\n              (recur next (conj visited next) (f next))))))))", "user": "54f26266e4b024c67c0cf8c5"}, {"problem": 86, "code": "(fn [num]\n  (loop [seen #{} next num]\n    (cond\n      (= 1 next) true\n      (contains? seen next) false\n      :else\n      (let [new (->> (seq (str next))\n                     (map (comp #(* % %) #(Character/getNumericValue %)))\n                     (reduce +))]\n        (recur (conj seen next) new)))))", "user": "54684c3be4b00cfc9eacc139"}, {"problem": 86, "code": "(fn happy?\n   ([n] (happy? n #{}))\n   ([n prev]\n    (let [num (reduce + (map (fn [x] (let [x1 (Character/digit x 10)] (* x1 x1))) (str n)))]\n      (if (not (nil? (prev num)))\n        false\n        (if (= num 1)\n          true\n          (happy? num (conj prev num)))))))", "user": "5918db70e4b09b4ee5954bbb"}, {"problem": 86, "code": "(let [digits (fn [n] (map #(- (int %) (int \\0)) (str n)))\n        sum-sq (fn [n] (apply + (map #(* % %) (digits n))))]\n    (fn [n]\n      (loop [old-n n\n             checked? #{}]\n        (let [new-n (sum-sq old-n)]\n          (if (= 1 new-n)\n            true\n            (if (checked? new-n)\n              false\n              (recur new-n (conj checked? old-n))))))))", "user": "539fa040e4b0ca733b97449f"}, {"problem": 86, "code": "(fn happy? [x]\n  (letfn [(digits [n]\n            (if (pos? n)\n              (conj (digits (quot n 10)) (mod n 10) )\n              []))\n          (square-sum [n]\n            (->> (digits n)\n                 (map #(* % %))\n                 (reduce +)))\n          (iterate-no-loop [f x]\n            (let [prev (atom #{})\n                  no-loop' (fn no-loop' [f x]\n                             (if (contains? @prev x)\n                               nil\n                               (do (swap! prev conj x)\n                                   (cons x (lazy-seq (no-loop' f (f x)))))))]\n              (no-loop' f x)))]\n    (= 1 (last (iterate-no-loop square-sum x)))))", "user": "5a257747e4b07f18be40aa1f"}, {"problem": 86, "code": "(fn [x]\n  (letfn [(step [n] (->> n\n                     str\n                     (map #(- (int %) 48))\n                     (map #(* % %))\n                     (reduce +)))]\n    (loop [i x j #{}]\n      (cond\n        (= i 1) true\n        (contains? j i) false\n        :else (recur (step i) (conj j i))))))", "user": "5a085dfde4b01bb0ae8afdf4"}, {"problem": 86, "code": "(fn happy [n]\n  (letfn [(sq [n] (* n n))\n          (-next-num [n]\n                     (apply + (map #(sq (- (int %) 48)) (seq (str n)))))]\n    (loop [k n seen #{}]\n      (let [next' (apply + (map #(sq (- (int %) 48)) (seq (str k))))]\n        (cond\n          (= next' 1)\n          true\n          (seen next')\n          false\n          :else\n          (recur next' (conj seen next')))))))", "user": "54e540c1e4b024c67c0cf7f9"}, {"problem": 86, "code": "(fn happy? [n]\n  (letfn [(digits [n]\n            (map #(Integer/parseInt (str %)) (str n)))\n          (sum-of-squares [n]\n            (reduce + (map #(* % %) (digits n))))]\n    (boolean (some #{1} (take 100 (iterate sum-of-squares n))))))", "user": "5b88f0c0e4b047b03b203816"}, {"problem": 86, "code": "(fn f [n]\n  (letfn [(p [n] \n             (if (pos? n)\n               (conj (p (quot n 10)) (mod n 10))\n               []))]\n    (if (= 4 n) \n      false\n      (let [x (reduce #(+ %1 (* %2 %2)) 0 (p n))]\n        (if (= 1 x)\n          true\n          (f x))))))", "user": "5b59d176e4b02d533a91bd86"}, {"problem": 86, "code": "(fn func-res [input] (let [sq (fn [x] (let [digits (map #(- (int %) (int \\0)) (str x)) squers (reduce (fn [a b] (+ a (* b b))) 0 digits)] squers))  p (fn [s n] (if (contains? s n) n (recur (conj s n) (sq n))))] (= 1 (p #{} input))))", "user": "5addadfce4b0837691e92c13"}, {"problem": 86, "code": "(fn happy-number?\n    ([number] (happy-number? number #{}))\n    ([number seen-numbers]\n     (let [digits      (->> number\n                            (str)\n                            (seq)\n                            (map (comp #(Integer/parseInt %) str)))\n           new-number  (->> digits\n                            (map #(* % %))\n                            (reduce +))]\n       (cond\n         (= 1 new-number) true\n         (contains? seen-numbers new-number) false\n         :else (recur new-number (conj seen-numbers number))))))", "user": "52761edae4b03e8d9a4a74d4"}, {"problem": 86, "code": "(fn\n  [n]\n  (cond\n    (= n 1) true\n    (= n 4) false\n    :else (recur (reduce\n   (fn [sum d]\n     (+ sum (* d d)))\n   0\n   (map #(Long/valueOf (str %) 10) (Long/toString n 10))))))", "user": "5af3aa42e4b0cc2b61a3bc8c"}, {"problem": 86, "code": "(fn [start]\n    (loop [n start\n           sums #{}]\n      (let [sum\n            (loop [digit (mod n 10)\n                   prefix (int (/ n 10))\n                   result 0]\n              (if (zero? prefix)\n                (+ result (* digit digit))\n                (recur\n                  (mod prefix 10)\n                  (int (/ prefix 10))\n                  (+ result (* digit digit)))))]\n        (cond\n          (sums sum) false\n          (= sum 1) true\n          :else (recur sum (conj sums sum))))))", "user": "5b999af8e4b0c0b3ffbd4ad3"}, {"problem": 86, "code": "(fn [n]\n  (letfn [(chars->digits [xs] (map (zipmap [\\0 \\1 \\2 \\3 \\4 \\5 \\6 \\7 \\8 \\9] (range)) xs))]\n    (loop [n n\n           s #{}]\n      (let [sum (apply + (map #(* % %) (chars->digits (seq (str n)))))]\n        (cond\n          (= 1 sum) true\n          (s sum) false\n          :else (recur sum (conj s sum)))))))", "user": "56ef077ae4b04a395b9a0459"}, {"problem": 86, "code": "(fn hap?\n  ([sum] (hap? #{} sum))\n  ([acc sum]\n   (letfn [(digit-sum [x]\n              (letfn [(num->digits\n                        ([num] (num->digits [] num))\n                        ([acc num]\n                         (if (< num 10)\n                           (cons num acc)\n                           (recur (cons (mod num 10) acc) (quot num 10)))))]\n                (apply + (map #(* % %) (num->digits x)))))]\n      (let [it-sum (digit-sum sum)]\n\n        (cond\n          (= 1 it-sum) true\n          (acc it-sum) false\n          ;:else it-sum)))))\n          :else (recur (conj acc it-sum) it-sum))))))", "user": "5a91988ae4b002d099cae6f9"}, {"problem": 86, "code": "(fn [n] (cond (#{4 16 37 58 89 145 42 20} n) false ;all unhappy sequences eventually fall into this cycle.\n              (= 1 n) true\n              :else (recur (reduce + (map #(* % %) (map #(- (int %) 48) (str n)))))))", "user": "5bafd5c8e4b0a20761a234dd"}, {"problem": 86, "code": "(fn happy? \n  ([num] (happy? num `()))\n  ([num been]\n    (let [newNum (reduce \n                  #(+ %1 (* %2 %2)) \n                  0 \n                  (map \n                    #(- (int %) 48) \n                    (seq (str num))))]\n                    (if (= newNum 1)\n                      true \n                      (if (some #{newNum} been)\n                        false\n                        (happy? newNum (conj been newNum)))))))", "user": "5b3251c1e4b025bcb146f317"}, {"problem": 86, "code": "(fn [x]\n  (loop [v x s #{}]\n    (let [z (->> v\n                 str\n                 (map #(- (int %) 48))\n                 (map #(* % %))\n                 (apply +))]\n      (cond\n        (= 1 z) true\n        (s z) false\n        :else (recur z (conj s z))))))", "user": "5b99a0a3e4b0c0b3ffbd4ad7"}, {"problem": 86, "code": "(fn problem-86-trampoline-happy?\n  [k]\n  (->> k\n       ((fn happy-seq [n]\n          (lazy-seq (cons n\n                          (->> n\n                               (str)\n                               (map str)\n                               (map #(Integer/parseInt %))\n                               (map #(* % %))\n                               (apply +)\n                               (happy-seq))))))\n       (trampoline (fn meh\n                     [s [x & xs]]\n                     (cond\n                       (= 1 x) true\n                       (s x)   false\n                       :else   #(meh (conj s x) xs))) #{})))\n  \n#_(fn problem-86-loop-recur-happy? [k]\n  (->> k\n       ((fn happy-seq [n]\n          (lazy-seq (cons n\n                          (->> n\n                               (str)\n                               (map str)\n                               (map #(Integer/parseInt %))\n                               (map #(* % %))\n                               (apply +)\n                               (happy-seq))))))\n       (#(loop [s #{}\n                [x & xs] %]\n           (cond\n             (= 1 x) true\n             (s x)   false\n             :else (recur (conj s x) xs))))))", "user": "58e37946e4b005f69f193cae"}, {"problem": 86, "code": "(fn [z] (letfn [(ssq [x] (apply + (map (comp #(* % %) read-string str) (seq (str x)))))] \n          (loop [q (ssq z) cnt 0]\n            (cond \n             (> cnt 1000) false\n             (= 1 q) true \n             :else (recur (ssq q) (inc cnt))) )))", "user": "5b919d9de4b0c0b3ffbd4a24"}, {"problem": 86, "code": "(fn happy-number\n  ([n] (happy-number n #{}))\n  ([n nrs-appeared]\n   (if (nrs-appeared n)\n     false\n     (let [next-num\n           (apply + (map #(let [current-digit\n                                (Integer/parseInt (str %))]\n                            (* current-digit current-digit)) (str n)))]\n       (if (= 1 next-num)\n         true\n         (happy-number next-num (conj nrs-appeared n)))))))", "user": "5b759ca8e4b047b03b2036d0"}, {"problem": 86, "code": "(fn f\n  ([x] (f x #{}))\n  ([x s]\n   (let [y (reduce #(+ % (* %2 %2)) 0 (map #(- % 48) (map int (apply vector (str x)))))]\n     (if (= y 1)\n       true\n       (if (s y)\n         false\n         (recur y (conj s y)))))))", "user": "566d71b1e4b0a866af6896ca"}, {"problem": 86, "code": "#(> % 6)", "user": "59cd13d5e4b0ef0a1e9b5b32"}, {"problem": 86, "code": "(fn [x] (letfn [(pow [x] (* x x))\n                          (prnum [x] (reduce + (map (comp pow read-string str) (seq (str x)))))]\n                    (loop [p (prnum x) a #{}]\n                      (cond (= p 1) true\n                            (contains? a p) false\n                            :defualt (recur (prnum p) (conj a p))))))", "user": "5b924123e4b0c0b3ffbd4a34"}, {"problem": 86, "code": "(fn [m]\n    (letfn [(nxt [n] (apply + (map #(* % %) (digits n))))\n            (digits\n              ([n] (digits n []))\n              ([n acc]\n               (if (pos? n) (recur (quot n 10) (conj acc (mod n 10))) acc)))\n            (happy-seq [n] (lazy-seq (cons n (happy-seq (nxt n)))))]\n      (= (first (drop-while (complement #{1 4}) (happy-seq m))) 1)))", "user": "5782018de4b0d36ec5835e8e"}, {"problem": 86, "code": "(fn happy? [n]\n  (letfn [(digits [n]\n            (map #(Integer/parseInt (str %)) (str n)))\n          (sum-of-squares [n]\n            (reduce + (map #(* % %) (digits n))))]\n    (boolean (some #{1} (take 100 (iterate sum-of-squares n))))))", "user": "5bbdd136e4b07a9b28b0ffab"}, {"problem": 86, "code": "(letfn [(split-number [x]\n          (map #(-> % str Integer/parseInt) (str x)))]\n  (fn [x]\n    (loop [index #{}, x x, loop-detected? false]\n      (cond\n        (= 1 x) true\n        loop-detected? false\n        :else (let [x (reduce #(+ %1 (* %2 %2)) 0 (split-number x))]\n                (recur (conj index x) x (contains? index x)))))))", "user": "5b96800ae4b0c0b3ffbd4a7b"}, {"problem": 86, "code": "(let [int->digits (fn [n]\n                    (if (= n 0)\n                      '(0))\n                    (loop [n n\n                           so-far '()]\n                      (if (= n 0)\n                        so-far\n                        (recur\n                          (quot n 10)\n                          (cons (rem n 10) so-far)))))\n      happy-iterator (fn \n        [n]\n        (->> n\n             int->digits\n             (map (fn [x] (* x x)))\n             (apply +)))]\n  (fn [n]\n    (cond (= n 1) true\n          (= n 4) false\n          :else (recur (happy-iterator n)))))", "user": "5bab5440e4b0a20761a23475"}, {"problem": 86, "code": "(fn f\n    ([n] (f n #{}))\n    ([n s]\n     (if (= n 1)\n       true\n       (let [to-digits (fn to-digits [n acc]\n                         (if (= n 0)\n                           acc\n                           (to-digits (quot n 10)\n                                      (cons (mod n 10)\n                                            acc))))\n             digits    (to-digits n [])\n             squares   (map #(* % %) digits)\n             sum       (apply + squares)]\n         (if (contains? s sum)\n           false\n           (recur sum (conj s sum)))))))", "user": "5be5cebde4b0ed4b8aab4d19"}, {"problem": 86, "code": "(fn [n]\n  (loop [n n c 0]\n    (if (or (= c 10000) (= n 0) (< n 0))\n      false\n      (let [\n            mhn (apply + (map #(* % %) (map read-string (map str (seq (str n))))))\n          ]\n        (if (= 1 mhn)\n          true\n          (recur mhn (inc c)))\n      )\n    )\n  )\n)", "user": "5bdf651ee4b0ed4b8aab4c6d"}, {"problem": 86, "code": "(fn [x]\n  (letfn [(hpy [x] (apply + (map #(let [a (read-string %)] (* a a)) (re-seq #\"\\d\" (str x)))))]\n  (loop [init #{x} res (hpy x)]\n    (println res)\n    (cond (= res 1) true\n          (contains? init res) false \n          :else (recur (conj init res) (hpy res))\n    )\n  )\n  )\n)", "user": "5be6d0f8e4b0f319e2d7ec51"}, {"problem": 86, "code": "(fn [b]\n    (->>\n      (take-while \n        #(and (not= % 4) (not= % 1))\n           (iterate\n             (fn [a]\n               (->>\n                 ((fn [n]\n                    (->>\n                      (iterate #(let [f (first %) l (last %)] (if (zero? f) [nil l] [(quot f 10) (conj l (int (rem f 10)))])) [n ()])\n                      (take-while #(->> % first nil? not))\n                      last\n                      last\n                      )) a)\n                 (reduce #(->> %2 (* %2) (+ %)) 0)\n                 ))\n             b))\n      last str first (not= \\2)\n      )\n   )", "user": "5be0306be4b0ed4b8aab4c7d"}, {"problem": 86, "code": "< 4", "user": "567c63f6e4b05957ce8c61bb"}, {"problem": 86, "code": "(fn happy-num? [n]\n  (let [get-digits (fn get-digits [result num]\n                     (if (> num 0)\n                     (conj (get-digits result (int (/ num 10))) (mod num 10))\n                     result))]\n    (loop [previous #{}\n           curr n]\n      (cond\n        (= curr 1) true\n        (contains? previous curr) false\n        :else (recur\n                (conj previous curr)\n                (->> curr\n                     (get-digits [])\n                     (map int)\n                     (map #(* % %))\n                     (reduce +)))\n        ))))", "user": "5b60e88be4b0c6492753e70b"}, {"problem": 86, "code": "(fn happy? [n]\n  (letfn [(digits [n]\n            (map #(Integer/parseInt (str %)) (str n)))\n          (sum-of-squares [n]\n            (reduce + (map #(* % %) (digits n))))]\n    (boolean (some #{1} (take 100 (iterate sum-of-squares n))))))", "user": "5a42dbabe4b0447ef91cc5fc"}, {"problem": 86, "code": "(fn happy [n]\n  (let [digs (fn [x]\n               (map #(Integer. (str %)) (str x)))\n        sum (fn [x]\n              (->> x\n                (digs)\n                (map #(* % %))\n                (reduce +)))]\n    (loop [x n\n           was []]\n      (if (not= -1 (.indexOf was x))\n        false\n        (let [y (sum x)]\n          (if (= 1 y)\n            true\n            (recur y (conj was x))))))))", "user": "5ba15075e4b0a20761a2339e"}, {"problem": 86, "code": "(fn [x]\n  (loop [u #{} s (iterate (fn [x]\n                                 (int (reduce + (map #(Math/pow % 2) ((fn [x]\n                                                                        (for [d (str x)]\n                                                                          (Character/getNumericValue d))) x))))) x)]\n    (let [y (first s)]\n      (cond\n        (= 1 y) true\n        (contains? u y) false\n        :else (recur (conj u y) (next s))))))", "user": "58f5b58ae4b0438e51c2cedc"}, {"problem": 86, "code": "(fn happy-number [value]\n  (letfn [(next-number [num]\n            (->> (seq (str num))\n                 (map str)\n                 (map read-string)\n                 (map #(* % %))\n                 (reduce +)\n                 ))]\n    (loop [value value\n           seen #{}]\n      (if (= value 1)\n        true\n        (if (contains? seen value)\n          false\n          (recur (next-number value) (conj seen value)))))))", "user": "5bfa25fbe4b0bdcf453d15c8"}, {"problem": 86, "code": "(fn [X] (letfn [(func [x] (reduce + (map #(* % %) (map #(- (int %) 48) (str x)))))\n        (is-happy [x coll]\n\t\t\t(cond\n\t\t\t\t(= 1 x) true\n\t\t\t\t(coll x) false\n\t\t\t\ttrue (recur (func x) (conj coll x))))]\n  (is-happy X #{})))", "user": "57c647bbe4b05aa3c4741cf3"}, {"problem": 86, "code": "(fn [n]\n  (condp = n\n    1 true\n    4 false\n    (recur (->> n\n           \t\t(str) \n           \t\t(map (comp #(* % %) read-string str)) \n           \t\t(apply +)))))", "user": "5c13da47e4b01240ff5671a6"}, {"problem": 86, "code": "#((fn happy? [m visited]\n  (if (contains? visited m)\n   false\n  (if (= m 1)\n   true\n   (happy?\n    ((fn sum-squares [n]\n     (if (zero? n)\n      0\n      (+ (* (mod n 10) (mod n 10))\n       (sum-squares (quot n 10))\n      )\n     )\n    ) m)\n    (conj visited m)\n   )\n  ))\n) % #{})", "user": "5c0d0537e4b0bdcf453d173d"}, {"problem": 86, "code": "(fn happy?\n  [n]\n  (letfn [(digits [n]\n            (map #(- (int %) 48) (str n)))\n          (sum-square [xs]\n            (reduce + (map #(* % %) xs)))]\n    (cond (= n 1) true\n          ;; math magic here - happy numbers always\n          ;; converge to within a certain range\n          ;; there is also only one oscillation cycle\n          ;; picking any number on that cycle is enough\n          (= n 4) false\n          :else (recur (sum-square (digits n))))))", "user": "5c222b7de4b07e362c230588"}, {"problem": 86, "code": "(fn happy-number\n  [n]\n  (loop [val n results []]\n    (cond\n      (= val 1) true\n      (some #(= val %) results) false\n      :else (recur (apply + (map #(* % %) ((fn value-digits\n  [n]\n  (loop [res () v n]\n    (if (> v 0)\n      (recur (conj res (rem v 10)) (int (/ v 10))) res))) val))) (conj results val))\n      )\n\n    )\n  )", "user": "5c20b6abe4b07e362c230576"}, {"problem": 86, "code": "(fn happy? [n]\n  (letfn [(digits [n]\n            (map #(Integer/parseInt (str %)) (str n)))\n          (sum-of-squares [n]\n            (reduce + (map #(* % %) (digits n))))]\n    (boolean (some #{1} (take 100 (iterate sum-of-squares n))))))", "user": "5c2649c8e4b07e362c2305bf"}, {"problem": 86, "code": "#(letfn [(h [n] (apply + (map (comp (fn [x] (* x x)) read-string str) (str n))))] (or (= 1 %) (and (< 4 %) (recur (h %)))))", "user": "5c1aadcde4b01240ff567209"}, {"problem": 86, "code": "(fn [a] (loop [x a c #{}] (let [y (apply + (map #(let [x (mod % 10)] (* x x)) (take-while #(not= % 0) (iterate #(quot % 10) x))))] (if (= y 1) true (if (contains? c y) false (recur y (conj c y)))))))", "user": "594d4c57e4b07ddc2dafae87"}, {"problem": 86, "code": "(fn [n]\n    (let [num-to-digits  (fn [num]\n                           (loop [nn num res []]\n                             (if (zero? nn)\n                               res\n                               (recur (quot nn 10) (cons (mod nn 10) res)))))\n          sum-dig-square (fn [num-list] (apply + (map #(* % %) num-list)))\n          happy-iterate  (fn [nn] (sum-dig-square (num-to-digits nn)))]\n      (loop [get-set #{}\n             nn      n]\n        (cond\n          (= nn 1) true\n          (contains? get-set nn) false\n          :else (recur (conj get-set nn) (happy-iterate nn))))))", "user": "5c0e3f86e4b01240ff56713d"}, {"problem": 86, "code": "(fn [start]\n  (letfn [(squared-sum [x]\n    (reduce +\n      (->> x\n        str\n        (map str)\n        (map read-string)\n        (map #(* % %)))))]\n    (loop [x start\n           seen #{}]\n      (let [sum (squared-sum x)]\n        (cond\n          (= 1 sum) true\n          (contains? seen sum) false\n          :else (recur sum (conj seen sum)))))))", "user": "5b0bd9cfe4b0cc2b61a3bdd9"}, {"problem": 86, "code": "(fn happy-number [n]\n  (letfn [( digits [n]\n            (loop [result '()  current n]\n              (if (= current 0) result\n                                (let [digit (mod current 10)]\n                                  (recur (cons digit result) (/ (- current digit) 10))))\n\n              )\n            )]\n    (loop [values #{} x n]\n      (let [y (->> (digits x)\n                   (map #(* % %))\n                   (reduce +)\n                   )]\n        (cond\n          (= y 1) true\n          (values y) false\n          :else (recur (conj values y) y))))))", "user": "5c3ac091e4b0d62ef62d9f95"}, {"problem": 86, "code": "(fn happy? [x]\n    (loop [n x history nil]\n      (cond (some #(= % n) history) false\n            (= 1 n)                 true\n            :else                   (recur (->> (str n)\n                                                (map str)\n                                                (map read-string)\n                                                (map #(* % %))\n                                                (apply +))\n                                           (cons n history)))))", "user": "5920c191e4b09b4ee5954c61"}, {"problem": 86, "code": "(fn [w] (= 1 (last (take 7 (iterate (fn [v] (loop [x v d '()] (if (< x 1) (apply + (map #(* % %) d)) (recur (quot x 10) (conj d (mod x 10)))))) w)))))", "user": "5c379636e4b0d62ef62d9f76"}, {"problem": 86, "code": "(fn happy-number?\n   ([x] (happy-number? x #{}))\n   ([x seen]\n    (let [digits (fn [x] (map #(java.lang.Character/digit % 10) (str x)))\n          square (fn [x] (* x x))\n          square-sum (fn [x] (reduce + 0 (map square (digits x))))\n          value (square-sum x)]\n      (if (contains? seen value)\n        false\n        (if (= value 1)\n          true\n          (recur value (conj seen value)))))))", "user": "5c3f37fce4b08cd430848e91"}, {"problem": 86, "code": "(fn [n]\n    (letfn [(sum-sq [n]\n              (->> (seq (str n))\n                   (map (comp #(* % %) read-string str))\n                   (apply +)))]\n      (loop [n n seen #{}]\n        (cond\n          (seen n) false\n          (= n 1)  true\n          :else (recur (sum-sq n) (conj seen n))))))", "user": "5c165d3ee4b01240ff5671d1"}, {"problem": 86, "code": "(fn happy-number? [n]\n  (let [digits (fn [n] (map #(Integer/valueOf (str %)) (str n)))\n        step (fn [n] (apply + (map (fn [d] (* d d)) (digits n))))]\n    (contains? (->> n\n                    (iterate step)\n                    (reductions conj #{})\n                    (partition 2 1)\n                    (filter (partial apply =))\n                    first\n                    first)\n               1)))", "user": "5c506951e4b0f9f7a8770ec5"}, {"problem": 86, "code": "#(let [x (apply + (map (fn [y] (let [z (read-string y)] (* z z))) (re-seq #\"\\d\" (str %))))] \n   (cond (= 1 x) true (= 4 x) false :else (recur x)))", "user": "5c41db45e4b08cd430848ece"}, {"problem": 86, "code": "(fn happy? [x & [seen]]\n    (cond\n      (= x 1) true\n      (contains? seen x) false\n      :else (happy? (->> x str seq (map #(Long/parseLong (str %))) (map #(* % %)) (apply +))\n                    (conj (or seen #{}) x))))", "user": "4fde492be4b05e33b9224f8a"}, {"problem": 86, "code": "(fn happy?\n  ([n]\n    (happy? n #{}))\n  ([n seen]\n   (if (= 1 n)\n     true\n     (if (seen n)\n       false\n       (let [digits (mapv #(Character/digit % 10) (str n))\n             new-n (reduce + (mapv #(* % %) digits))\n             new-seen (conj seen n)]\n         (recur new-n new-seen))))))", "user": "5c742ee1e4b0fca0c16227c3"}, {"problem": 86, "code": "(fn [n]\n  (loop [happy n]\n    (if (< happy 4)\n      (= happy 1)\n      (recur (let [digits (loop [res [] x happy]\n                            (if (> x 0)\n                              (recur (conj res (rem x 10)) (quot x 10))\n                              res))]\n               (apply +\n                 (map\n                   (fn [x] (* x x))\n                   digits)))))))", "user": "5c73b8bae4b0fca0c16227ba"}, {"problem": 86, "code": "(fn [n]\n  (let [nxt (fn [n]\n              (->> (str n)\n                   (map #(- (int %) 48))\n                   (map #(* % %))\n                   (apply +)))]\n\t(->> (iterate nxt n)\n         (take-while #(not= 1 %))\n         (apply distinct?))))", "user": "5a080bdde4b01bb0ae8afde9"}, {"problem": 86, "code": "(fn [x]\n  (loop [xs []\n         n x]\n    (let [new (->> n str (re-seq #\"\\d\") (map #(Integer/parseInt %)) (map #(* % %)) (apply +))]\n    \t(cond \n         (some #(= new %) xs) false\n         (= new 1) true\n         :else (recur (conj xs new) new)))))", "user": "5b72b36ce4b047b03b2036a9"}, {"problem": 86, "code": "(fn [n]\n  (->> n (iterate (fn [v] (apply + (map (comp #(* % %) read-string str) (str v)))))\n      (filter #{1 4})\n      first\n      (= 1)))", "user": "5a244240e4b0ff51aa4b32e9"}, {"problem": 86, "code": ";(fn[x](loop[c 0 r x]\n;    (cond\n;      (= c 100000) false\n;      (= r 1) true\n;      :else (recur\n;              (inc c)\n;              (apply + (map #(* % %) (map read-string (re-seq #\"\\d\" (str r)))))\n;              )\n;      )))\n\n(fn[x](loop[c 0 r x]\n    (cond\n      (= c 1000) false\n      (= r 1) true\n      :else (recur\n              (inc c)\n              (apply + (map #(* % %) (map read-string (re-seq #\"\\d\" (str r)))))\n              )\n      )))", "user": "5c683fb5e4b0fca0c16226d5"}, {"problem": 86, "code": "(fn [x]\n  (letfn [(happy [x]\n            (let [digits (loop [res [] cur x]\n                           (if (= cur 0)\n                             res\n                             (recur (conj res (mod cur 10)) (quot cur 10))))]\n              (->> (map #(* % %) digits)\n                   (reduce +))))]\n\n\n\n    (loop [found #{x}\n           current x]\n      (println found current)\n      (let [new (happy current)]\n        (cond\n          (contains? found new)\n          false\n\n          (= new 1)\n          true\n\n          :else\n          (recur (conj found new) new))))))", "user": "5ab1665de4b073f1774425c0"}, {"problem": 86, "code": "(fn [n]\n  (letfn [(digits [n] (when-not (zero? n) (lazy-seq (cons (mod n 10) (digits (quot n 10))))))\n          (sum-sq [n] (reduce + (map #(* % %) (digits n))))]\n    (loop [current n seen #{}]\n      (cond (= 1 current) true\n            (seen current) false\n            :else (recur (sum-sq current) (conj seen current))))))", "user": "586bc870e4b01531a375e964"}, {"problem": 86, "code": "(fn is-happy? [n]\n (let [split #(->> % str (re-seq #\"\\d\") (map read-string))\n       sq-sum #(->> (map * % %) (apply +))\n       formula #(->> % split sq-sum)]\n  (loop [n n, found #{}]\n   (cond (= 1 n) true\n         (contains? found n) false\n         :else (recur (formula n) (conj found n))))))", "user": "5bea3177e4b0f319e2d7ec81"}, {"problem": 86, "code": "(fn [n]\n  (letfn [(sum-squares [number]\n            (->> (str number)\n                 (map #(Integer. (str %)))\n                 (map #(* % %))\n                 (reduce +)))]\n    (loop [current n\n           seen #{}]\n      (cond\n        (= current 1) true\n        (seen current) false\n        :else (recur (sum-squares current) (conj seen current))))))", "user": "5c718e6ce4b0fca0c1622796"}, {"problem": 86, "code": "(fn [n]\n    (letfn [(digits [n]\n              (loop [n n\n                     ds '()]\n                (if (< n 10)\n                  (conj ds n)\n                  (recur (quot n 10) (conj ds (mod n 10))))))\n            (sum-squared [ds]\n              (apply + (map #(* % %) ds)))]\n      (loop [n n\n             visited #{}]\n        (cond (= 1 n) true\n              (visited n) false\n              :else\n              (recur (-> n\n                         digits\n                         sum-squared)\n                     (conj visited n))))))", "user": "57f80350e4b0d3187e90090c"}, {"problem": 86, "code": "(fn happy [n]\n    (letfn [(->sorted-digits [n]\n              (->> (str n)\n                   (map #(Integer/parseInt (str %)))\n                   (sort)))]\n      (loop [sorted-digits (->sorted-digits n)\n             calculated #{}]\n        (if (calculated sorted-digits)\n          false\n          (let [new (->> sorted-digits\n                         (map #(* % %))\n                         (reduce +))]\n            (if (== new 1)\n              true\n              (recur (->sorted-digits new)\n                     (conj calculated sorted-digits))))))))", "user": "5c995fa4e4b048ec896c5a96"}, {"problem": 86, "code": "(fn happy-number? [n]\n  (let [sum-of-squares (fn [n]\n                         (->> (str n)\n                              (map #(Integer/parseInt (str %)))\n                              (map #(* % %))\n                              (reduce +)))]\n    (->> (iterate sum-of-squares n)\n         (take 100)\n         (#(= 1 (last %))))))", "user": "561d8936e4b064ca9f4b16b2"}, {"problem": 86, "code": ";; http://www.4clojure.com/problem/86\n(fn happy-number?\n  ([n] (happy-number? n #{}))\n  ([n prev-set]\n   (letfn [(sum-digit-squares [n]\n             (apply + (map #(* % %) (map #(Integer/parseInt (str %)) (str n)))))]\n     (let [s (sum-digit-squares n)]\n       (if (= s 1)\n         true\n         (if (contains? prev-set s) \n           false\n           (happy-number? s (conj prev-set s))))))))", "user": "5c92105ce4b048ec896c59f7"}, {"problem": 86, "code": "(fn happy-number?\n  [n]\n  (loop [x n\n         seen #{}]\n    (let [sum-of-squares (->> (str x)\n                              (map #(Integer/parseInt (str %)))\n                              (map #(* % %))\n                              (reduce +))]\n      (cond\n        (= 1 sum-of-squares) true\n        (seen sum-of-squares) false\n        :else (recur sum-of-squares (conj seen sum-of-squares))))))", "user": "5b602a66e4b0c6492753e6fc"}, {"problem": 86, "code": "(fn happy? [n]\n  (let [digitize (fn [n] (loop [n n ds []] (if (zero? n) ds (recur (quot n 10) (cons (mod n 10) ds)))))\n        happyiter (fn [n] (->> (digitize n) (map #(* % %)) (apply +)))]\n    (loop [n n seen #{}]\n      (cond (= n 1) true\n            (seen n) false\n            :else (recur (happyiter n) (conj seen n))))))", "user": "5cab33e7e4b048ec896c5c48"}, {"problem": 86, "code": "(fn happy? [n]\n  (let [digits (->> n str vec (map #(Character/digit % 10)))\n        sum-squares (int (reduce #(+ %1 (Math/pow %2 2)) 0 digits))]\n    (case sum-squares\n      1 true\n      4 false\n      (recur sum-squares))))", "user": "5c950334e4b048ec896c5a44"}, {"problem": 86, "code": "(fn [x]\n    (letfn [(sum-digits-squared [x]\n              (if (< x 10)\n                (* x x)\n                (let [a (mod x 10)]\n                  (+ (* a a) (sum-digits-squared (quot x 10))))))]\n      (loop [seen #{}\n             [x & xs] (iterate sum-digits-squared x)]\n        (cond\n          (= x 1) true\n          (seen x) false\n          :else (recur (conj seen x) xs)))))", "user": "5bd0ea60e4b0e9689409ee45"}, {"problem": 86, "code": "(fn happy? [n]\n(let [to-digits-seq (fn [n]\n\t\t\t(loop [val n res []]\n\t\t\t\t\t\t\t(if (= val 0) \n\t\t\t\t\t\t\t\t\t\t\tres\n\t\t\t\t\t\t\t\t\t\t\t(recur (quot val 10) (conj res (mod val 10))))))]\n\n    (loop [res n checked #{}]\n    \t\t\t\t(if (= res 1) \n    \t\t\t\t\t\t\t\ttrue\n    \t\t\t\t\t\t\t\t(if (contains? checked res)\n    \t\t\t\t\t\t\t\t\t\t\tfalse\n    \t\t\t\t\t\t\t\t\t\t\t(recur (reduce + (map #(* % %) (to-digits-seq res))) (conj checked res)))))))", "user": "5c87c79be4b048ec896c591b"}, {"problem": 86, "code": "(fn happy-number?\n  ([n] (happy-number? n 0))\n  ([n c]\n   (let [digits (map #(Integer. %)\n                     (map str (seq (str n))))\n         squares (map #(* % %) digits)\n         sum (apply + squares)]\n     (if (= 1 sum)\n       true\n       (if (> c 999)\n         false\n         (happy-number? sum (inc c)))))))", "user": "5ca14eb1e4b048ec896c5b7d"}, {"problem": 86, "code": "(fn [n]\n    (loop [in n parts #{}]\n      (if (contains? parts in)\n        false\n        (if (= 1 in)\n          true\n          (recur\n            (reduce + (map (fn [a] (* a a)) (map (fn [a] (- (int a) 48)) (str in))))\n            (conj parts in))\n          )\n        )\n      )\n    )", "user": "5cc6f982e4b0ccb06196282d"}, {"problem": 86, "code": "(fn happy?\n  ([n] (happy? n #{}))\n  ([n seen]\n   (if (contains? seen n)\n     false\n     (let [next (->> n\n                     str\n                     (map int)\n                     (map #(- % 48))\n                     (map #(* % %))\n                     (apply +))]\n       (if (= 1 next)\n         true\n         (happy? next (conj seen n)))))))", "user": "5b64370ae4b0c6492753e73c"}, {"problem": 86, "code": "(fn happy?\n  ([n] (happy? n #{}))\n  ([n history]\n   (letfn [(sqrt [n] (* n n))\n          (digits [n] (->> n str (map #(- (int %) (int \\0)))))\n          (sqrt-sum [n] (->> n digits (map sqrt) (reduce +)))]\n     (cond (= 1 (sqrt-sum n)) true\n           (contains? history (sqrt-sum n)) false\n           :else (recur (sqrt-sum n) (conj history (sqrt-sum n)))))))", "user": "5ce077e9e4b0a17bb84e2b0c"}, {"problem": 86, "code": "(fn happy? [n]\n       (let [iter #(reduce + (map (fn [d]\n                                     (let [i (read-string (str d))]\n                                      (* i i)))\n                                    (str %)))]\n         (loop [x n xs #{}]\n           (cond\n             (= x 1) true\n             (xs x) false\n             :else (recur (iter x) (conj xs x))))))", "user": "5cdfe2aee4b0a17bb84e2b04"}, {"problem": 86, "code": "(fn [input]\n  (loop [n input previous #{}]\n  (if (= n 1)\n    true\n    (if (or (previous n) (not (pos? n)))\n      false\n      (let [h (map #(Character/digit % 10) (str n))]\n        (recur (apply + (map #(* % %) h)) (conj previous n)))))))", "user": "5cd9dc85e4b05ee0cb31170d"}, {"problem": 86, "code": "#(loop [s #{} x %]\n   (cond\n     (= x 1) true\n     (s x) false\n     :else (recur\n           \t(conj s x)\n           \t(loop [ans 0 r x] (if (zero? r) ans (recur (+ ans (* (mod r 10) (mod r 10))) (quot r 10))))\n           )\n   )\n )", "user": "5cebafbbe4b0a17bb84e2be6"}, {"problem": 86, "code": "(fn [n]\n  (let [digits (fn [n] (map #(Character/digit % 10) (str n)))\n        op (fn [n]\n             (->> (digits n)\n                  (map #(* % %))\n                  (apply +)))\n        is-happy? (partial = 1)]\n    (loop [n n\n           seen #{}]\n      (let [new-sum (op n)]\n        (cond\n          (is-happy? new-sum) true\n          (seen new-sum) false\n          :else\n          (recur new-sum (conj seen new-sum)))))))", "user": "5338387de4b0e30313ee6c91"}, {"problem": 86, "code": "(fn [n]\n  (let [digits (fn [n] (->> (clojure.string/split (str n) #\"\")\n                            (filter #(not= \"\" %))\n                            (map #(Integer/parseInt %))))\n        sq-sum (fn [digs] (reduce + (map #(* % %) digs)))\n        squared-digits (comp sq-sum digits)]\n    (loop [num n visited #{}]\n      (cond\n        (= num 1) true\n        (visited num) false\n        :else (recur (squared-digits num) (conj visited num))))))", "user": "5ccb0bbee4b0ccb06196287c"}, {"problem": 86, "code": "(fn happy-number [n]\n  (letfn [(digit-list-helper [q acc]\n            (if (= 0 q)\n              acc\n              (digit-list-helper (quot q 10) (conj acc (rem q 10)))))\n          (digit-list [x]\n            (digit-list-helper x []))]\n    (loop [curr n\n           count 0]\n      (if (> count  100)\n        false\n        (if (= curr 1)\n          true\n          (recur (reduce + (map #(* % %) (digit-list curr))) (inc count)))))))", "user": "5d1bbef0e4b02ea6f0fb6984"}, {"problem": 86, "code": "(fn k\n         ([n ](k n 0))\n         ([n cnt]\n          (let [ toInt #(Integer/parseInt (str %))\n                sumSqs (reduce + (map #(* % %)  ( map toInt (seq (str n))))) ]\n            (if (= 5000 cnt) false\n                (if(= 1 sumSqs) true (recur sumSqs (inc cnt)))))))", "user": "5d0cf1c8e4b0cc9c91588246"}, {"problem": 86, "code": "(fn [x] \n  (letfn [(sqr-sum [x] (->> (map read-string (map str (str x)))\n  \t\t\t\t\t\t\t(map #(* % %))\n  \t\t\t\t\t\t\t(apply +)))]\n                   (loop [x x history-set #{}]\n                     (if (= x 1) true\n                       (if (history-set x) false\n                         (recur (sqr-sum x) (conj history-set x)))))))", "user": "5d02fe44e4b0cc9c915881c0"}, {"problem": 86, "code": "(fn\n  [n]\n  (letfn [(digits [n]\n            (map #(read-string (str %)) (str n)))\n\n          (calc [n]\n            (let [digs    (digits n)\n                  squares (map #(* % %) digs)]\n              (reduce + squares)))]\n    (loop [seen #{}\n           n    n]\n      (if (contains? seen n)\n        false\n        (let [v (calc n)]\n          ;;(println  v)\n          (if (= 1 v)\n            true\n            (recur (conj seen n) v)))))))", "user": "570c8ac3e4b0b0fb43fd06ca"}, {"problem": 86, "code": "(fn happy-num\n  ([n] (happy-num n #{}))\n  ([n setty-set]\n   (cond\n     (contains? setty-set 1) true\n     (contains? setty-set n) false\n     :else (happy-num ((fn [num] (->> (str num)\n                                      (map str)\n                                      (map #(Integer/parseInt %))\n                                      (map #(* % %))\n                                      (apply +))) n) (conj setty-set n)))))", "user": "5d1c14cde4b02ea6f0fb698a"}, {"problem": 86, "code": "(fn happy? [n]\n  (letfn [(digits [n]\n            (map #(Integer/parseInt (str %)) (str n)))\n          (sum-of-squares [n]\n            (reduce + (map #(* % %) (digits n))))]\n    (boolean (some #{1} (take 100 (iterate sum-of-squares n))))))", "user": "5baaae06e4b0a20761a23464"}, {"problem": 86, "code": "(fn f\n  ([n] (f n #{}))\n  ([n seen]\n   (let [ds (map #(- (int %) 48) (str n))\n         sum (reduce + (map #(* % %) ds))]\n     (println seen sum)\n     (cond\n       (= sum 1)\n       true\n       (contains? seen sum)\n       false\n       :default\n       (recur sum (conj seen sum))))))", "user": "5012da69e4b0c8732600222d"}, {"problem": 86, "code": "(fn happy? [n]\n  (let [sq-sum (fn [n]\n                 (->> n\n                      str\n                      (map #(Character/getNumericValue %))\n                      (map #(* % %))\n                      (reduce +)))]\n    (loop [acc #{} a (sq-sum n)]\n      (cond\n        (= a 1) true\n        (contains? acc a) false\n        :else (recur (conj acc a) (sq-sum a))))))", "user": "518279abe4b0353c468deb65"}, {"problem": 86, "code": "(fn happy [n]\n  (let [digits (fn [m] (map #(Character/digit % 10) (seq (str m))))\n        next-happy (fn [m] (apply + (map #(* % %) (digits m))))]\n    (loop [h n\n           seen #{}]\n      (cond\n        (= 1 h) true\n        (contains? seen h) false\n        :else (recur (next-happy h) (conj seen h))))))", "user": "5d3ae729e4b01671435dbd5d"}, {"problem": 86, "code": "(fn [x]\n  (loop [i x]\n    (cond\n      (= i 1) true\n      (get #{4 16 37 58 89 145 42 20} i) false\n      :else (recur (->> i str\n                        (map (comp #(* % %) read-string str))\n                        (apply +))))))", "user": "5c2836ebe4b07e362c2305d4"}, {"problem": 86, "code": "(fn [n]\n    (let [to-list (fn [num]\n                    (loop [actual num coll '()]\n                      (if (pos? actual)\n                        (recur (long (/ actual 10))\n                               (conj coll (mod actual 10)))\n                        coll)))\n          sum-square-digits (fn [coll] (reduce + (map #(* % %) coll)))]\n      (loop [seen #{} actual n]\n        (cond\n          (= actual 1) true\n          (contains? seen actual) false\n          :else\n            (recur (conj seen actual)\n                   (sum-square-digits (to-list actual)))))))", "user": "5d0153f9e4b0cc9c915881aa"}, {"problem": 86, "code": "(fn Happy  \n    ([N] (Happy N #{ N } ))\n    ;; \u0435\u0441\u043b\u0438 \u043f\u043e\u043b\u0443\u0447\u0438\u043b\u043e\u0441\u044c \u0447\u0438\u0441\u043b\u043e, \u043a\u043e\u0442\u043e\u0440\u0435 \u0443\u0436\u0435 \u0431\u044b\u043b\u043e, \u0442\u043e \u043c\u044b \u0432 \u0432\u0435\u0447\u043d\u043e\u043c \u0446\u0438\u043a\u043b\u0435\n    ([N Used] \n      (let \n        [\n          SquareSum\n          ;; \u0441\u043a\u043b\u0430\u0434\u044b\u0432\u0430\u0435\u043c\n          (apply +     \n            ;; \u043a\u0430\u0436\u0434\u0443\u044e \u0446\u0438\u0444\u0440\u0443 \u0432 \u043a\u0432\u0430\u0434\u0440\u0430\u0442\n            (map \n              #(* % %)\n              ;; \u0440\u0430\u0437\u0431\u0438\u0432\u0430\u0435\u043c \u043d\u0430 \u0446\u0438\u0444\u0440\u044b\n              (map #(read-string(str \"\" %)) (into [] (str N)))\n            )\n          )\n        ]\n        ;;(println SquareSum Used)        \n        (cond\n          ;; \u0435\u0441\u043b\u0438 \u044d\u0442\u043e \u0435\u0434\u0438\u043d\u0438\u0446\u0430, \u0442\u043e \u0447\u0438\u0441\u043b\u043e \u0441\u0447\u0430\u0441\u0442\u043b\u0438\u0432\u043e\u0435\n          (= 1 SquareSum) true\n          ;; \u0435\u0441\u043b\u0438 \u0447\u0438\u0441\u043b\u043e \u0443\u0436\u0435 \u0431\u044b\u043b\u043e, \u0442\u043e \u043c\u044b \u0437\u0430\u0446\u0438\u043a\u043b\u0438\u043b\u0438\u0441\u044c\n          (contains? Used SquareSum) false\n          ;; \u0438\u043d\u0430\u0447\u0435 - \u043f\u043e\u0432\u0442\u043e\u0440\u044f\u0435\u043c\n          :else (Happy SquareSum (clojure.set/union Used #{ SquareSum }))\n        )\n      )\n    )\n  )", "user": "5d4a6c6ce4b0776584bd6f22"}, {"problem": 86, "code": "(fn [n]\n  (let [to-digits (fn [text]\n\t\t\t\t\t(->> text str (map (comp read-string str))))\n        sum-squares (fn [text]\n                      (->> text\n                           to-digits\n                           (map #(* % %))\n                           (reduce +)))]\n    (loop [memo #{n}\n           sum (sum-squares n)]\n        (cond \n         (= sum 1) true\n         (contains? memo sum) false\n         :else (recur (conj memo sum) (sum-squares sum))))))", "user": "5cb41c40e4b026601754b911"}, {"problem": 86, "code": "(fn happy-number\n  ([n]\n   (happy-number n #{}))\n  ([n acc]\n   (cond\n     (= n 1) true\n     (acc n) false\n     :else   (let [digits (map #(Character/digit % 10) (str n))\n                   square-sum (apply + (map #(* % %) digits))]\n               (happy-number square-sum (conj acc n))))))", "user": "5d1b2b7de4b02ea6f0fb697a"}, {"problem": 86, "code": "(fn [x]\n  (let  [digits (fn [n]\n           (->> n\n                (iterate #(quot % 10))\n                (take-while pos?)\n                (mapv #(mod % 10))\n                rseq))\n         sum-square-digits (fn [coll] (reduce + (map * coll coll)))]\n  (loop [x x\n         acc #{}]\n    (if (= x 1)\n      true\n      (if (contains? acc x)\n      false\n      (recur\n        (sum-square-digits (digits x)) (conj acc x)))))))", "user": "5d1a1082e4b0902706380e0e"}, {"problem": 86, "code": "(fn [n]\n   (loop [x n\n        m #{}]\n   (let [s (->> x\n                      (iterate #(quot % 10))\n                      (take-while pos?)\n                      (map #(mod % 10))\n                      (map #(* % %))\n                      (apply +))]\n     (cond\n       (= 1 s) true\n       (m s) false\n       :else (recur s (conj m s))))))", "user": "5d29c06be4b01671435dbc6b"}, {"problem": 86, "code": "(fn\n  [n]\n  (letfn [(sum-squared-digits [x]\n            (->> (str x)\n                 (map (comp read-string str))\n                 (map #(* % %))\n                 (reduce +)))\n          (happy-helper [x m]\n            (let [res (sum-squared-digits x)]\n              (cond\n                (= res 1) true\n                (m res) false\n                :else (recur res (assoc m x res)))))]\n    (happy-helper n {})))", "user": "5d0bb4fae4b0cc9c91588237"}, {"problem": 86, "code": "(fn happy-number? [x]\n  (let [square (fn [x] (* x x))\n        hap (fn [n] (reduce + (map #(-> %\n                                        str\n                                        Integer/parseInt\n                                        square)\n                                   (str n))))]\n    (loop [current x\n           seen #{}]\n      (cond\n        (= current 1) true\n        (contains? seen current) false\n        :else (recur\n               (hap current)\n               (conj seen current))))))", "user": "5d6042f2e4b0c9e5857d5006"}, {"problem": 86, "code": "(fn [initial]\n    (let [digits (fn [n]\n        (->> n\n            (iterate #(quot % 10))\n            (take-while pos?)\n            (mapv #(mod % 10))\n            (rseq)))]\n    (loop [cur initial\n           seen (set nil)]\n     (cond \n        (= cur 1) true\n        (contains? seen cur) false\n        :else (recur (->> cur (digits) (map #(* % %)) (reduce +)) (conj seen cur))))))", "user": "5d62e606e4b0c9e5857d5022"}, {"problem": 86, "code": "(fn h?\n  ([x] (h? x #{}))\n  ([x s]\n   (let [x' (apply + (map #(* % %) (map #(- (int %) (int \\0)) (str x))))]     \n     (cond (= 1 x') true\n           (s x') false\n           :else (h? x' (conj s x'))))))", "user": "5bb25684e4b0a20761a2350d"}, {"problem": 86, "code": "(fn happy-number? [x]\n  \n  (let [digits (fn [y] (loop [n y\n                              digits '()]\n                         (if (> n 9)\n                           (recur (quot n 10) (conj digits (rem n 10)))\n                           (conj digits n))))\n        digits-squares-sum (fn [y] (->> (digits y)\n                                        (map #(* % %))\n                                        (apply +)))\n        ;; after how many tries we're going to decide it's not worth trying anymore\n        threshold 100]\n    (->> (iterate digits-squares-sum x)\n         (drop threshold)\n         first\n         (= 1))))", "user": "551bdefde4b07993ea3788d7"}, {"problem": 86, "code": "(fn happy? [n]\n  (letfn [(digits [n]\n            (map #(Integer/parseInt (str %)) (str n)))\n          (sum-of-squares [n]\n            (reduce + (map #(* % %) (digits n))))]\n    (boolean (some #{1} (take 100 (iterate sum-of-squares n))))))", "user": "5d67c955e4b0db5d338d15f7"}, {"problem": 86, "code": "(fn [your-number] \n  (letfn[(aa [your-number] (reduce + (mapv #(* % %) (mapv #(Integer/parseInt (str %)) (seq (str your-number)))))\n          )]\n    (loop [bb (aa your-number), res-set #{}]\n      (if (or (= java.lang.Boolean (type bb)) (contains? res-set bb))\n        (if (= java.lang.Long (type bb)) false bb)\n        (recur (cond\n                 (= 1 bb) true\n                 (= your-number bb) false\n                 :else (aa bb))\n               (conj res-set bb))))))", "user": "5cf72682e4b0b71b1d808a68"}, {"problem": 86, "code": "(fn [num]\n  ((fn happy [old-list num]\n     (if (some #(= num %) old-list)\n       (= num 1)\n       (do\n         (happy (conj old-list num) (reduce\n                                      #(+ (int (Math/pow (Character/digit %2 10) 2)) %)\n                                      0\n                                      (str num))))\n       )) [] num))", "user": "5d6633bde4b0db5d338d15e2"}, {"problem": 86, "code": "(fn happy?\n  [n]\n  (loop [visited #{}\n         n n]\n    (cond\n      (= 1 n)\n      true\n\n      (visited n)\n      false\n     \n      :else\n      (recur\n        (conj visited n)\n        (->> (str n)\n             (map #(Integer/parseInt (str %)))\n             (map #(* % %))\n             (apply +))))))", "user": "5d609ddde4b0c9e5857d5008"}, {"problem": 86, "code": "(fn hn?\n  ([n] (hn? n []))\n  ([n m]\n    (cond\n      (= n 1) true\n      (contains? m n) false\n      :default (let [ss (reduce + (map  #(let [d (read-string (str %))]\n                                          (* d d)) (str n)))]\n                (recur ss (conj m ss))))))", "user": "5d52bf29e4b0776584bd6f69"}, {"problem": 86, "code": "(fn happy-num\n  ([n]\n   (happy-num n #{})\n   )\n  ([n coll]\n   (if (= n 1)\n     true\n     (if (contains? coll n)\n       false\n       (recur (reduce + (map #(* % %) (map read-string (re-seq #\"\\d\" (str n)))))\n              (conj coll n))\n       ))))", "user": "5d6691cee4b0db5d338d15e9"}, {"problem": 86, "code": "(fn happy-number [n]\n  (letfn [(add-square [acc n] (+ acc (* n n)))\n          (sum-squares [n]\n            (loop [n n acc 0]\n              (if (= n 0) acc (recur (int (/ n 10)) (add-square acc (mod n 10))))))]\n    (loop [n n seen #{}]\n      (cond\n        (= 1 n) true\n        (seen n) false\n        :else (recur (sum-squares n) (conj seen n))))))", "user": "5d5e0259e4b0c9e5857d4fef"}, {"problem": 86, "code": "(fn [n] \n   (let [s (take 100 (iterate (fn [n] (apply + (map (fn [x] (* x x)) (map #(Character/digit % 10) (map char (str n)))))) n))]\n     (if (some #(= 1 %) s) true false)))", "user": "5d764e52e4b02e6b30c93524"}, {"problem": 86, "code": "(fn [n]\n    (loop [x n, lst []]\n      (cond\n        (= x 1) true\n        (some #{x} lst) false\n        :else (recur (reduce + (map #(* (Character/digit % 10) (Character/digit % 10)) (str x)))\n                     (conj lst x)))))", "user": "5ccf99fbe4b0ccb0619628c8"}, {"problem": 86, "code": "(letfn [(sum-squares [xs] (->> xs (map #(* % %)) (reduce +)))\n         (num->digits [x]\n           (->> x\n                (str)\n                (vec) \n                (map str) \n                (map #(Integer/parseInt %))))\n         (succ [x] (sum-squares (num->digits x)))]\n   (fn [x]\n     (loop [cur x\n            seen #{}]\n       (cond (= cur 1) true\n             (seen cur) false\n             :else (recur (succ cur)\n                          (conj seen cur))))))", "user": "5d4b2155e4b0776584bd6f28"}, {"problem": 86, "code": "(fn [n & args]\n  (let [blop (->> n\n                  str\n                  (map #(-> % str Integer. (Math/pow 2) int))\n                  (reduce +))\n        foo (or args #{})]\n    (cond\n      (= blop 1) true\n      (= blop n) false\n      (contains? foo blop) false\n      :else (recur blop (conj foo blop)))))", "user": "5cf6522be4b0b71b1d808a58"}, {"problem": 86, "code": "(fn [n]\n (loop [hn n already #{}]\n   (cond \n     (= hn 1) true \n     (already hn) false\n     :else (recur ((fn [x] (apply + (map #(* % %) (map #(- (int %) 48) (seq (str x)))))) hn) (conj already hn)))))", "user": "5951190be4b066ee0a44aea4"}, {"problem": 86, "code": "(fn [n]\n   (let [f #(- 48 (int %))]\n     (loop [s #{} n n]\n       (if (= 1 n)\n         true\n         (let [n (reduce #(+ % (* (f %2) (f %2))) 0 (str n))]\n           (if (s n)\n             false\n             (recur (conj s n) n)))))))", "user": "557c6ca6e4b05c286339e0c4"}, {"problem": 86, "code": "(fn happy? ([n] (happy? n #{}))\n   ([n seen]\n    (cond\n      (= n 1) true\n      (contains? seen n) false\n      :else (letfn [(happy-next [n] (reduce + (map (comp #(* % %) #(Character/digit % 10)) (str n))))]\n              (happy? (happy-next n) (conj seen n))))))", "user": "5d9c1226e4b0d3f9b434ad51"}, {"problem": 86, "code": "(fn happy? [n]\n  (let\n   [hap\n    (fn [n]\n  (->> n\n       str\n       (map #(Character/digit % 10))\n       (map #(* % %))\n       (apply +)\n       ))]\n   (loop [i n\n          seen []]\n     (if (.contains seen i)\n       false\n       (if (= i 1)\n         true\n         (recur (hap i) (conj seen i)))))))", "user": "5da8fa72e4b000c986472c2d"}, {"problem": 86, "code": "(fn [n]\n  (loop [n n prev []]\n    (if (some #(= n %) prev)\n      false\n      (if (= 1 n)\n        true\n        (recur (apply + (map (comp #(* % %) read-string str) (str n)))\n               (conj prev n))))))", "user": "5d81b40ce4b0915913b1d379"}, {"problem": 86, "code": "(fn [n]\n  (case n\n    89 false\n    1 true\n    (recur (apply + (map #(let [d (Integer/parseInt (str %))] (* d d)) (str n))))))", "user": "59ef6cfae4b0966464fe6a32"}, {"problem": 86, "code": "(fn happy [x]\n  (->> x\n       (iterate (fn [x]\n                  (->> x\n                       (str)\n                       (re-seq #\".\")\n                       (map read-string)\n                       (reduce (fn [r y] (+ r (* y y))) 0))))\n       ((fn duplicate [seen [f :as coll]]\n            (if (contains? seen f)\n              f\n              (recur (conj seen f) (rest coll)))) #{})\n       (= 1)))", "user": "56d5c1b0e4b0ea9b8538f7c3"}, {"problem": 86, "code": "(fn happy? \n  ([y] (happy? #{} y))\n  ([xs y] (cond \n           (= 1 y) true\n           (xs y)  false\n           :else \n           (let [sum-squares \n                 (fn ssq [x] (let [x1 (mod x 10)\n                                   x2 (quot x 10)]\n                               (if (< x 10) (* x x) (+ (* x1 x1) (ssq x2)))))]\n            (recur (conj xs y) (sum-squares y))))))", "user": "5d97b602e4b0d3f9b434ad3a"}, {"problem": 86, "code": "(fn happy? [x]\n  (loop [s #{} n x] \n    (if (s n) \n      false\n      (if (= 1 n) \n        true\n        (recur (conj s n) (reduce + (map (comp #(* % %) read-string str) (str n))))))))", "user": "5d47f4dbe4b07c84aa5ae6b5"}, {"problem": 86, "code": "(fn happy?\n  ([n] (happy? n 100))\n  ([n t]\n   (cond\n    (= n 1) true\n    (= t 0) false\n    :else (recur\n           (apply + (map #(* (- (int %) 48) (- (int %) 48)) (str n)))\n           (dec t)))))", "user": "5da760ebe4b000c986472c1a"}, {"problem": 86, "code": "(fn [n]\n  (let [sep (fn sep [n]\n              (->> (str n)\n                   (map str)\n                   (map #(Integer/parseInt %))))\n        sq-add (fn sq-add [n]\n                (if (= 1 n)\n                  true\n                  (if (= n 37)\n                    false\n                    (sq-add (reduce + (map #(* % %) (sep n)))))))]\n    (sq-add n)))", "user": "58983e3fe4b00487982d52ce"}, {"problem": 86, "code": "(fn [x]\n  (letfn [(abc [y]\n            (if (> 10 y) (* y y)\n            (+ (* (mod y 10) (mod y 10)) (abc (quot y 10)))))]\n       (loop [x x r #{}]\n         (cond\n            (r x) false     \n            (= 1 x) true\n            :else (recur (abc x) (conj r x))))))", "user": "5dc12b0ae4b0e59a23173d84"}, {"problem": 86, "code": "(fn happy_number? [n]\n    (let\n    [\n        digits\n            (fn [x]\n                (loop [ret [(mod x 10)] curr (quot x 10)]\n                    (if (zero? curr)\n                        ret\n                        (recur (conj ret (mod curr 10)) (quot curr 10) )\n                    )\n                )\n            )\n    ]\n        (loop [xs #{n} x n]\n            (let [ dss (reduce #(+ %1 (* %2 %2)) 0 (digits x)) ]\n                (cond\n                    (= dss 1) true\n                    (contains? xs dss) false\n                    :otherwise (recur (conj xs dss) dss)\n                )\n            )\n        )\n    )\n)", "user": "5db7376fe4b010eb3c36cd43"}, {"problem": 86, "code": "(fn [num]  \n  (loop\n    [x num\n    k 1]\n\n    (let [test (apply + (map #(* (Integer/parseInt (str %))    (Integer/parseInt (str %))) (str x)))]\n    \n      (cond\n        (= test 1) true\n        (> k 10) false\n        :else (recur test (inc k))\n      )\n    )\n  )\n)", "user": "5da20e73e4b000c986472be1"}, {"problem": 86, "code": "(fn [n]\n  (letfn [(digits [n] (map #(- (int %) (int \\0)) (str n)))\n          (ss [n] (apply + (map #(* % %) (digits n))))\n          (happy? [n seen] (let [x (ss n)] (cond (= x 1) true (seen x) false :else (happy? x (conj seen x)))))]\n    (happy? n #{})))", "user": "5db92996e4b010eb3c36cd50"}, {"problem": 86, "code": "(fn happy\n  ([x] (happy #{} x))\n  ([a x] (let [res (reduce + (map (fn [y] (let [dgt (Character/digit y 10)] (* dgt dgt))) (str x)))]\n           (if (= 1 res)\n             true\n             (if (a res) false (happy (conj a res) res))))))", "user": "5a5894d9e4b05d388ecb6c81"}, {"problem": 86, "code": "(fn [n]\n  (let [digits #(map read-string (re-seq #\"\\w\" (str %)))\n        sq #(* % %),\n        sumsq-digits #(reduce + (map sq (digits %)))]\n    (loop [s (sumsq-digits n) v #{}]\n      (cond (= s 1) true (contains? v s) false :else (recur (sumsq-digits s) (conj v s))))))", "user": "5dc9ccf8e4b02f9375f4e1f1"}, {"problem": 86, "code": "#(loop [list-squares [] input %]\n    (if  (contains? (set list-squares) input)\n      (if (nil? (some (fn [x] (= 1 x)) list-squares)) false true)\n      (recur\n        (conj list-squares input)\n        (if (= 1 (count  (str input)))\n          (* input input)\n          (reduce + (map (fn [y] (* y y)) (mapv (fn [m] (Character/digit m 10)) (seq (str input))))))\n        )))", "user": "5b044436e4b0cc2b61a3bd71"}, {"problem": 86, "code": "(fn happy-number\n  ([num]\n   (happy-number num []))\n  ([num acc]\n   (let [num-list (map #(Character/digit % 10) (str num))\n         sum-of-squares (apply + (map #(* % %) num-list))]\n         (if (= 1 sum-of-squares)\n           true\n           (if (some #(= sum-of-squares %) acc)\n             false\n             (happy-number sum-of-squares (conj acc sum-of-squares))\n             )))))", "user": "5d8c8175e4b0915913b1d3e1"}, {"problem": 86, "code": "(fn [n]\n  (let [get-digits (fn [n]\n                     (loop [n n\n                            digits []]\n                       (if (zero? n)\n                         digits\n                         (recur (quot n 10)\n                                (conj digits (rem n 10))))))]\n    (loop [n n\n           seen? #{}]\n      (cond\n        (= 1 n) true\n        (seen? n) false\n        :else (recur (->> n get-digits (map #(* % %)) (apply +))\n                     (conj seen? n))))))", "user": "5ab16992e4b073f1774425c4"}, {"problem": 86, "code": "(fn is-happy [n]\n  (let [sum-squares (fn [x]\n                      (loop [sum 0\n                             curr x]\n                        (if (= curr 0)\n                          sum\n                          (recur (+ sum (#(* % %) (mod curr 10))) (int (/ curr 10))))))\n        is-happy-rec (fn [num prev]\n                       (let [sum-squares (sum-squares num)\n                             s (println sum-squares)]\n                         (if (contains? prev sum-squares)\n                           false\n                           (if (= 1 sum-squares)\n                             true\n                             (recur sum-squares (conj prev num))))))]\n    (is-happy-rec n #{})\n    )\n  )", "user": "5dd67c22e4b0948ae9d9ad80"}, {"problem": 86, "code": "(fn [n]\n        (loop [x n acc #{}]\n                  (let [new (->> (str x)\n                       (map #(Character/getNumericValue %))\n                       (map #(* % %))\n                       (apply +))]\n                    (cond\n                      (= new 1) true\n                      (contains? acc new) false\n                      :else (recur new (conj acc x))))))", "user": "5cc6b4bfe4b0ccb061962827"}, {"problem": 86, "code": "(fn happy-num?\n  [n]\n  (letfn [(num->seq\n            [xs n]\n            (if (zero? n) xs\n                (recur (conj xs (mod n 10))\n                       (int (/ n 10)))))\n          (square-sum\n            [n]\n            (reduce +\n                    (map #(* % %) (num->seq [] n))))]\n    (loop [num n prev-seen #{}]\n      (cond (= num 1) true\n            (not (nil? (get prev-seen num))) false\n            :else (recur (square-sum num) (conj prev-seen num))))))", "user": "5ddb6151e4b0948ae9d9adb0"}, {"problem": 86, "code": "(fn [m]\n   (letfn [(happy-reductions [n]\n             (let [numbers (map #(Character/getNumericValue %) (str n))\n                   new-number (reduce + (map #(* % %) numbers))\n                   is-happy (= 1 new-number)]\n               (if is-happy [true]\n                            (cons is-happy (lazy-seq (happy-reductions new-number))))))]\n     (true? (first (filter true? (take 1000 (happy-reductions m)))))))", "user": "529dfc6de4b04e0c58e87b8a"}, {"problem": 86, "code": "(fn [x]\n  (let [sqr-digit-sum (fn [n]\n                        (loop [d (rem n 10) q (quot n 10) s 0]\n                          (if (pos? q)\n                            (recur (rem q 10) (quot q 10) (+ s (* d d)))\n                            (+ s (* d d)))))]\n    (loop [x x seen #{}]\n      (if (= x 1)\n        true\n        (if (contains? seen x)\n          false\n          (recur (sqr-digit-sum x) (conj seen x)))))))", "user": "4f3ca5a6e4b0e243712b1f53"}, {"problem": 86, "code": "(fn h [n]\n  (loop [n n s #{}]\n    (let [n-sq (reduce #(+ %1 (* %2 %2)) 0 (map #(Integer/parseInt %) (re-seq #\"\\d\" (str n))))]\n      (cond\n       (= n-sq 1) true\n       (s n-sq) false\n       :else (recur n-sq (conj s n-sq))))))", "user": "5dd60c58e4b0948ae9d9ad7c"}, {"problem": 86, "code": "(fn happy? [n]\n  (letfn [(digits [n]\n            (map #(Integer/parseInt (str %)) (str n)))\n          (sum-of-squares [n]\n            (reduce + (map #(* % %) (digits n))))]\n    (boolean (some #{1} (take 100 (iterate sum-of-squares n))))))", "user": "5dfb20b8e4b0a607a9a45cd3"}, {"problem": 86, "code": "(fn [n]\n   (let [square-and-sum (fn [num] (->> (map #(read-string (str %)) (str num))\n        (map #(* % %))\n        (reduce +)))]\n     (loop [n n\n            past []]\n       (if (some #{n} past)\n         (= (last past) 1)\n         (recur (square-and-sum n) (conj past n))))))", "user": "5d9e8e40e4b000c986472bc2"}, {"problem": 86, "code": "(letfn [(num->digits [num]\n          (loop [n num res []]\n            (if (zero? n)\n              res\n              (recur (long (/ n 10)) (cons (mod n 10) res)))))\n        (change [n]\n          (apply + (map #(* % %) (num->digits n))))]\n  (fn [init]\n    (loop [curr init results #{}]\n      (println curr \" - \" results)\n      (cond\n       (= 1 curr) true\n       (results curr) false\n       :else (let [new-n (change curr)]\n               (println curr new-n)\n               (recur new-n (into results [curr])))\n       ))))", "user": "5d9c9446e4b0eb781811cdae"}, {"problem": 86, "code": "(fn p-86\n  ([n] (p-86 n {}))\n  ([n map-seen]\n   (if (get map-seen n) false\n       (let [sum  (reduce +\n                          (map (comp #(* % %) #(- % 48) int )\n                               (vec (str n))\n\n                               ))]\n         (if (= 1 sum) true\n             (p-86 sum (assoc map-seen n 1)))))))", "user": "5bfc9037e4b0bdcf453d15f2"}, {"problem": 86, "code": "(fn happy-number [num] \n      (let [digits (fn digits [num]\n\t\t\t\t\t\t\t      (let [r (quot num 10)]\n\t\t\t\t\t\t\t\t      (if(= 0 r)\n\t\t\t\t\t\t\t\t        [num]\n\t\t\t\t\t\t\t\t        (conj (digits r) (mod num 10) ))))\n            step (fn [num] (->> \n                   (digits num)\n                   (map #(* %1 %1))\n                   (reduce +)))]\n        (loop [curnum (step num)\n               seen #{}]\n          (if (= 1 curnum)\n            true\n            (if (contains? seen curnum)\n              false\n              (recur (step curnum) (into seen #{curnum})))))))", "user": "5df0c6ffe4b093ff717275c2"}, {"problem": 86, "code": "(fn dfs\n  ([n] (dfs n #{}))\n  ([n sett]\n   (let [dig (map #(Integer/parseInt (str %)) (str n))\n         sum (reduce + (map #(* % %) dig))]\n     (if (sett n)\n       false\n       (if (= 1 sum)\n         true\n         (recur sum (conj sett n)))))))", "user": "5dfa1c67e4b0a607a9a45cc5"}, {"problem": 86, "code": "(fn happy? [n]\n  (letfn [(digits [n]\n            (map #(Integer/parseInt (str %)) (str n)))\n          (sum-of-squares [n]\n            (reduce + (map #(* % %) (digits n))))]\n    (boolean (some #{1} (take 100 (iterate sum-of-squares n))))))", "user": "5e00b6e7e4b0a607a9a45d2b"}, {"problem": 86, "code": "(fn happy? [number]\n  (letfn [(next-step [x]\n                     (->>\n                       (map #(- (int %) (int \\0)) (vec (str x)))\n                       (map #(* % %))\n                       (reduce +)))]\n\n    (loop [already #{}\n           x number]\n      (cond\n        (= x 1) true\n        (already x) false\n        :else (recur (conj already x) (next-step x))))))", "user": "5e0d948fe4b099d064962f98"}, {"problem": 86, "code": "(fn perfect?\n  ([x] (perfect? x #{}))\n  ([x cache] (let [sum (->> x str\n             \t\t\t\t(map #(let [d (Integer/parseInt (str %))]\n                     \t\t(* d d)))\n             \t\t\t\t(apply +))]\n               (cond\n                 (= sum 1)   true\n                 (cache sum) false\n                 :else       (perfect? sum (conj cache sum))))))", "user": "5d81eba4e4b0915913b1d37b"}, {"problem": 86, "code": "(fn happy? [n]\n  (letfn [(digits [n]\n            (map #(Integer/parseInt (str %)) (str n)))\n          (sum-of-squares [n]\n            (reduce + (map #(* % %) (digits n))))]\n    (boolean (some #{1} (take 100 (iterate sum-of-squares n))))))", "user": "5c3440fee4b0d62ef62d9f50"}, {"problem": 86, "code": "(fn [n]\n    ((fn step [found n]\n       (let [digits (ffirst\n                     (drop-while\n                      (comp pos? second)\n                      (iterate (fn [[digits x]] [(cons (rem x 10) digits) (quot x 10)]) [[] n])))\n             next (->> (map #(* % %) digits)\n                       (reduce +))]\n         (if-not (found next)\n           (recur (conj found next) next)\n           (= 1 next)))) #{}  n))", "user": "5d236215e4b02ea6f0fb6a09"}, {"problem": 86, "code": "(let [sum-square-digits (fn [n] (loop [result 0 digits n] (if (zero? digits) result (recur (+ result (#(* % %) (mod digits 10))) (quot digits 10)))))\n      ] (fn happy? [n] (if (= n 1) true (if (= n 4) false (happy? (sum-square-digits n))))))", "user": "5e1cc888e4b0dc959400853d"}, {"problem": 86, "code": "(fn happy [x]\n  (loop [n x\n         seen #{}]\n    (cond\n     (= 1 n) true\n     (seen n) false\n     :else (recur (reduce + (map (comp #(* % %)\n                                       read-string\n                                       str)\n                                 (str n)))\n                  (conj seen n)))))", "user": "5d929ceae4b0915913b1d412"}, {"problem": 86, "code": "(fn [N]\n           (letfn [(sumd [N]\n                     (reduce (fn [result x]\n                               (+ result (* x x)))\n                             0 (map (comp read-string str) (str N))))]\n             ((fn myf [N_ result]\n                (if (contains? result N_)\n                  false\n                  (if (= 1 N_)\n                    true\n                    (recur (sumd N_) (conj result N_)))))\n              (sumd N) #{})))", "user": "5e1c3e6ee4b0dc9594008530"}, {"problem": 86, "code": "(fn happy? [n]\n  (letfn [(sq [n]\n            (reduce + (map #(* % %) (map #(. Integer parseInt (str %) ) (.toString n)))))]\n    (loop [seen #{} n n]\n      (if (contains? seen n)\n        false\n        (if (= n 1) true\n            (recur (conj seen n) (sq n)))))))", "user": "5e078ba7e4b0978307768fb6"}, {"problem": 86, "code": "(fn [n]\n  (letfn [(square-sum [x]\n                      (loop [x x\n                             acc 0]\n                        (if (= 0 x)\n                          acc\n                          (recur (quot x 10)\n                                 (+ acc (* (rem x 10) (rem x 10)))))))]\n    (loop [already #{}\n           x n]\n      (if (= 1 x)\n        true\n        (if (contains? already x)\n          false\n          (recur (conj already x) (square-sum x)))))))", "user": "52860baae4b0239c8a67ae09"}, {"problem": 86, "code": "(fn f [n]\n  (letfn [(hn [k] (->> k (str) (map #(- (int %) 48)) (map #(* % %)) (apply +)))\n          (test [k s] (cond (= k 1) true\n                            (nil? (s k)) (test (hn k) (conj s k))\n                            :else false))]\n    (test n #{})))", "user": "5e2549c8e4b05b4b0151615f"}, {"problem": 86, "code": "(fn perf\n  ([n] (perf n []))\n  ([n prev] \n   (let [n' (reduce + (map #(* % %) (map (comp read-string str) (seq (str n)))))]\n    (cond (= 1 n') true\n          (contains? prev n') false\n          :else (recur n' (conj prev n'))))))", "user": "5e3a25d4e4b01d43a70e8dde"}, {"problem": 86, "code": "(fn happy-numbers\n  [n]\n    (loop [n n\n           myset #{}]\n      (cond\n        (= n 1) true\n        (contains? myset n) false\n        :else\n        (do\n          (println n)\n          ;(recur (reduce + (map #(* % %))))\n          (recur (reduce + (map #(* (Integer. (str %)) (Integer. (str %))) (seq (str n)))) (conj myset n))))\n      ))", "user": "5e495e3fe4b043cd24807a4f"}, {"problem": 86, "code": "(fn [n]\n   (letfn [(next-val [n]\n             (loop [n n\n                    acc 0]\n               (let [q (quot n 10)\n                     m (mod n 10)\n                     acc (+ acc (* m m))]\n                 (if (zero? q) acc\n                     (recur q acc)))))]\n     (loop [n n\n            path #{}]\n       (cond\n         (= 1 n) true\n         (contains? path n) false\n         :else (recur (next-val n) (conj path n))))))", "user": "5e3ef7d4e4b01d43a70e8e2d"}, {"problem": 86, "code": "(fn [n]\n    (let \n     [inner-fn \n      (fn [n]\n        (let\n         [sq (fn [n] (* n n))\n          ssq\n          (fn [n]\n            (apply + (map #(sq (Integer/parseInt (str %))) (seq (str n)))))]\n          (loop [n n i 0 vs []]\n            (if (= 1 n)\n              [:happy i vs]\n              (if (or (> i 100) (some #(= n %) vs))\n                [:unhappy i vs]\n                (recur\n                 (ssq n)\n                 (inc i)\n                 (conj vs n)))))))]\n      (= :happy (first (inner-fn n)))))", "user": "5e53f8e0e4b027a2e10ac0e7"}, {"problem": 86, "code": "(fn [n]\n (let [num-seq (fn [d]\n                (loop [d d\n                       res []]\n                 (if (= d 0)\n                  res\n                  (let [mod-d (mod d 10)\n                        new-d (/ (- d mod-d) 10)]\n                   (recur new-d (cons mod-d res))))))\n       sum-sq (fn [n] (reduce + (map #(* % %) (num-seq n))))\n       res \n       (loop [prev #{}\n              n n]\n        (let [new-n (sum-sq n)\n              new-prev (conj prev n)\n              _ (print new-n new-prev)]\n         (cond\n          (= 1 n) true\n          (prev n) false\n          :else (recur new-prev new-n))))]\n  res))", "user": "592334c7e4b0a390037439ee"}, {"problem": 86, "code": "(fn happy?\n  ([x] (happy? [x] x))\n  ([res x]\n   (let [toColl (fn [x] (->> (map #(- (int %) 48) (to-array (str x)))\n                       (into [])))\n         sq (reduce + (map #(* % %) (toColl x)))]\n     (if\n       (= sq 1)\n       true\n       (if\n         ((set res) sq)\n         false\n         (recur (conj res sq) sq))))))", "user": "57fc5e42e4b0d3187e900997"}, {"problem": 86, "code": "(fn happy-number?\n  ([n] (happy-number? n {}))\n  ([n cache]\n   (letfn [(ch->dig [ch] (- (int ch) 48))\n           (digit-sum [nn]\n             (apply + (map #(* (ch->dig %) (ch->dig %)) (str nn))))]\n     (if (contains? cache n)\n       false\n       (or (= n 1)\n           (recur (digit-sum n) (assoc cache n true)))))))", "user": "5c3796b3e4b0d62ef62d9f77"}, {"problem": 86, "code": "(fn happy [x]\n    (loop [x x seen #{}]\n      (cond\n        (= x 1) true\n        (seen x) false\n        :else (let [n (->> x str (map #(Integer. (str %))) (map #(* % %)) (apply +))]\n                (recur n (conj seen x))))))", "user": "5e5b8d92e4b0fd0acd158658"}, {"problem": 86, "code": "(fn is-happy [n]\n  (loop [cur-n n\n         seen #{}]\n    ; if we're entering a cycle, n is not a happy num\n    (if (contains? seen cur-n)\n      false\n      ; if sq sum is 1, n is a happy num\n      (if (= 1 cur-n)\n        true\n        (recur\n          ; get new sqare sum\n          (reduce +\n            (->> cur-n\n                 (iterate #(quot % 10))\n                 (take-while pos?)\n                 (mapv #(* (mod % 10) (mod % 10)))\n                 rseq))\n          ; add num to list of seen nums\n          (conj seen cur-n))))))", "user": "5e692be9e4b04a83ad7cd269"}, {"problem": 86, "code": "(fn [x]\n   (loop [x x\n          temp-set #{}]\n     (cond (= x 1) true\n           (contains? temp-set x) false\n           :else\n           (recur (->> x\n                       (iterate #(quot % 10))\n                       (take-while pos?)\n                       (mapv #(mod % 10))\n                       (mapv #(* % %))\n                       (reduce +))\n                  (conj temp-set x)))))", "user": "5e724492e4b085ba37836dc7"}, {"problem": 86, "code": "(fn [n]\n  \n  (letfn [(square [x] (* x x))\n          (digits [x]\n                  (loop [dl '() number x]\n                    (if (zero? number) dl (recur (conj dl (rem number 10)) (quot number 10)))))\n          (happy [x] (reduce + (map square (digits x))))]\n    \n    (loop [seen #{} current n]\n      (if (= current 1) true\n        (let [hn (happy current)]\n          (if (contains? seen hn) false\n            (recur (conj seen hn) hn)))))))", "user": "53d977f1e4b0e771c302547a"}, {"problem": 86, "code": "(fn happy [n]\n  (let [\n    digits (fn d [k]\n      (if (= 0 k) '() (cons (rem k 10) (d (quot k 10)))))\n    merger (fn [digits]\n      (->> digits (map #(int (Math/pow % 2))) (reduce +)))\n    recursor (fn [values k]\n      (if (contains? values k) (= k 1)\n        (recur (conj values k) (merger (digits k)))))]\n  (->> (digits n) (merger) (recursor #{}))))", "user": "5b02ab12e4b0cc2b61a3bd53"}, {"problem": 86, "code": "(fn func [n]\n  (letfn [(get-digits [n] (map (comp read-string str) (seq (str n))))\n          (get-sum-of-squares [coll] (apply + (map #(* % %) coll)))\n          (happy-number? \n           [n visited]\n           (if (contains? visited n)\n             false\n             (let [sum (get-sum-of-squares (get-digits n))]\n               (if (= 1 sum)\n                 true\n                 (happy-number? sum (conj visited n))))))]\n    (happy-number? n #{})))", "user": "5e805895e4b085ba37836e44"}, {"problem": 86, "code": "(fn [n]\n  (let [digits (fn [x] (map #(- (int %) 48) (str x)))\n        square #(* % %)]\n    (loop [sums #{} n n]\n      (cond\n        (= 1 n) true\n        (sums n) false\n        :else (recur (conj sums n) (apply + (map square (digits n))))))))", "user": "4eb70649535d7eef30807373"}, {"problem": 86, "code": "(fn happy-number? [num]\n  (let [digits-fn (fn [x]\n                    (map #(Character/digit % 10)\n                         (str x)))]\n    ((fn helper [tracker number]\n       (if (contains? tracker number)\n         false\n         (let [digits (digits-fn number)\n               sum    (reduce #(+ %1 (* %2 %2))\n                              0\n                              digits)]\n           (if (= 1 sum)\n             true\n             (helper\n               (conj tracker number)\n               sum))))) #{} num)))", "user": "5dc53ddee4b02f9375f4e1bd"}, {"problem": 86, "code": "#(let [digits (fn [x] (map (comp read-string str) (str x)))\nsquare (fn [x] (* x x))\nnext (fn [x] (->> x (digits) (map square) (reduce +)))]\n(not (nil? (some #{1} (take 100 (iterate next %))))))\n;digits function based on chouser's solution of problem 99 Product Digits\n;some? function (1.6) not supported --> clojure implementation: (not (nil? x))\n;is there a function to compose (some? (some x)) ?\n;is there some way to avoid the \"100\" magic number AND avoid remembering previous iterations?", "user": "5e13a6b7e4b099d064963001"}, {"problem": 86, "code": "(fn happy-num [n]\n  (letfn [(sum-sqr [x sum]\n            (if (zero? x)\n              sum\n              (recur (quot x 10) (+ sum (* (mod x 10) (mod x 10))))))\n          (find-fix [lastv seen]\n            (if (= lastv 1)\n              true\n              (let [nextv (sum-sqr lastv 0)\n                    seen' (conj seen lastv)]\n                (if (contains? seen' nextv)\n                  false\n                  (recur nextv seen')))))]\n    (find-fix (sum-sqr n 0) #{})))", "user": "5e9c11f8e4b0157ca96647f6"}, {"problem": 86, "code": "(fn [n]\n  (letfn [(hn-helper [n prevs]\n            (let [nn (apply + (for [d (str n)] (int (Math/pow (- (int d) (int \\0)) 2))))]\n              (cond (= nn 1) true\n                    (contains? prevs nn) false\n                    :else (recur nn (conj prevs nn)))))]\n    (hn-helper n #{})))", "user": "5da71eaee4b000c986472c15"}, {"problem": 86, "code": "(fn [n]\n  (letfn [(into-digits [n]\n            (map (comp #(Integer/parseInt %) str) (seq (str n))))]\n    (loop [digits (into-digits n)\n                previous #{}]\n      (let [result (apply + (map #(* % %) digits))]\n        (cond\n          (= 1 result) true\n          (contains? previous result) false\n          :else (recur (into-digits result) (conj previous result)))))))", "user": "53528cd3e4b084c2834f4af2"}, {"problem": 86, "code": "(fn [n]\n  (= 1 ((fn [s n]\n          (let [i (fn [n] (reduce #(+ % (* %2 %2)) 0 (map #(- (int %) (int \\0)) (str n))))]\n            (if (contains? s n)\n              n\n              (recur (conj s n) (i n))))) #{} n)))", "user": "5ca2ca9fe4b048ec896c5b9c"}, {"problem": 86, "code": "(fn happy-number? [n]\n    (let [step (fn [n] (->> (str n)\n                            (map (comp #(* % %)\n                                       #(Integer/parseInt (str %))\n                                       str))\n                            (reduce +)))]\n      (loop [seen #{} n n]\n        (cond (contains? seen n) false\n              (= 1 n) true\n              :else (recur (conj seen n) (step n))))))", "user": "5a5d0726e4b0512ff01cd91b"}, {"problem": 86, "code": "(fn [n]\n  (letfn [(sum-squares\n            [n]\n            (loop [num n\n                   acc []]\n              (if (<= num 0)\n                (reduce + acc)\n                (let [dig (rem num 10)]\n                  (recur (int (/ num 10)) (conj acc (* dig dig)))))))]\n    (loop [num n\n           seen #{}]\n      (cond\n        (= num 1) true\n        (seen num)  false\n        :else (recur (sum-squares num) (conj seen num))))))", "user": "5eb1c786e4b00a66d4a95201"}, {"problem": 86, "code": "(fn happy-number?\n  ([x] (happy-number? x #{}))\n  ([x y]\n   (let [digits (fn degits-v2 [x]\n                  (if (zero? x)\n                    (vector)\n                    (conj (degits-v2 (unchecked-divide-int x 10)) (mod x 10))))\n         digit-square-sum (fn [x]\n                            (reduce +\n                                    (map #(* % %)\n                                         (filter #(not (zero? %))\n                                                 (digits x)))))\n         square-sum (digit-square-sum x)]\n     (if (= 1 square-sum)\n       true\n       (if (contains? y square-sum)\n         false\n         (happy-number? square-sum (conj y x)))))))", "user": "5e7b1ef4e4b085ba37836e10"}, {"problem": 86, "code": "(fn [n]\n  (letfn [(pcs [x] (reduce + (map #(* % %) (map #(Character/digit % 10) (str x)))))]    \n    (loop [a (pcs n)]\n      (cond (= a 1) true\n            (= a 4) false\n            :else (recur (pcs a))))))", "user": "5e6ca949e4b04a83ad7cd289"}, {"problem": 86, "code": "(fn happy-number?\n  ([n] (happy-number? n #{}))\n  ([n seen]\n   (let [next-num (apply + (map (comp #(* % %) #(- (int %) 48)) (str n)))]\n     (cond\n       (= next-num 1) true\n       (contains? seen next-num) false\n       :else (recur next-num (conj seen next-num))))))", "user": "592ac17ae4b072a2710fcf26"}, {"problem": 86, "code": "(fn happy [n]\n  (loop [v n\n         prev #{n}]\n    (let [new-v\n          (->> v\n               str\n               (reduce\n                #(+ %1 (let [a ((comp read-string str) %2)] (* a a))) 0))]\n      (cond\n        (= 1 new-v) true\n        (contains? prev new-v) false\n        :else (recur new-v (conj prev new-v))))))", "user": "5ec3a13ae4b08d0ec38692b9"}, {"problem": 86, "code": "(fn [n]\n  (let [square #(* % %)\n        char->num #(Character/getNumericValue %)]\n    (loop [n n cache #{}]\n      (cond\n        (cache n) false\n        (= 1 n) true\n        :else (recur (->> (str n)\n                          (map (comp square char->num))\n                          (reduce +))\n                     (conj cache n))))))", "user": "5de12192e4b0948ae9d9aded"}, {"problem": 86, "code": "(fn happy-number? [x]\n\t(loop [sum-of-digits (fn [n]\n                      \t(->> (str n)\n\t\t\t\t\t\t(map str)\n\t\t\t\t\t\t(map read-string)\n\t\t\t\t\t\t(map #(* % %))\n\t\t\t\t\t\t(reduce +)))\n           n (sum-of-digits x)]\n\t\t(cond\n\t\t\t(= n 4) false\n\t\t\t(= n 1) true\n\t\t\t:else (recur sum-of-digits (sum-of-digits n)))))", "user": "593c1e3be4b069cdc2982b86"}, {"problem": 86, "code": "(fn solution\n  ([num] (solution num #{num}))\n  ([num historic]\n   (if (= 1 num)\n     true\n     (if (= 1 (count (str num)))\n       (solution (* num num) (conj historic num))\n       (let [numbify (comp read-string str)\n             new-number (reduce #(+ (numbify %1)\n                                    (* (numbify %2)\n                                       (numbify %2)))\n                                (* (numbify (first (str num)))\n                                   (numbify (first (str num)))) (rest (str num)))]\n         (if (= 1 new-number)\n           true\n           (if (contains? historic new-number)\n             false\n             (solution new-number (conj historic new-number)))))))))", "user": "5e2ef900e4b05b4b015161fc"}, {"problem": 86, "code": "(fn [n]\n  (letfn [(sum-digits [x]\n                    (loop [q (quot x 10)\n                           r (mod x 10) \n                           sum 0]\n                      (if (zero? q) \n                        (+ sum (* r r))\n                        (recur (quot q 10)\n                               (mod q 10)\n                               (+ sum (* r r))))))]\n    (loop [seen #{} n (sum-digits n)]\n      (cond \n        (= n 1) true\n        (contains? seen n) false\n        :else (recur (conj seen n) (sum-digits n))))))", "user": "5ebdb3d2e4b00a66d4a95275"}, {"problem": 86, "code": "(fn happy-number? [n]\n  (condp = n\n    1 true\n    4 false ;; apparently, the only cycle (in base 10) that doesn't end in 1\n    (recur (->> (str n)\n                (map (comp #(* % %)\n                           #(Character/getNumericValue %)))\n                (apply +)))))", "user": "5d2e5065e4b01671435dbcae"}, {"problem": 86, "code": "#(let [transform (fn [n]\n                   (loop [rem-num n\n                          mid-res 0]\n                      (if (<= rem-num 0)\n                        mid-res\n                        (let [dig (rem rem-num 10)]\n                          (recur (quot rem-num 10) (+ mid-res (* dig dig)))))))\n       happy (fn [n prev-nums]\n               (cond\n                (= n 1) true\n                (contains? prev-nums n) false\n                :else (recur (transform n) (conj prev-nums n))))]\n               \n   (happy % #{}))", "user": "5ec6de19e4b08d0ec38692da"}, {"problem": 86, "code": "(fn [num]\n    (let [exp (fn [x n] (reduce * (repeat n x)))\n\n          sum-squares (fn [n] (apply + (map (fn [v] (exp (Integer/parseInt (str v)) 2)) (str n))))\n          sum-digits (fn [n] (apply + (map (fn [v] (Integer/parseInt (str v))) (str n))))\n          ]\n      (loop [l-num num repeat-set #{}]\n        (if (contains? repeat-set l-num)\n            false\n            (if (= 1 (sum-digits l-num))\n              true\n              (recur (sum-squares l-num) (conj repeat-set l-num)))\n          )\n        )\n        \n      ))", "user": "53c73e8ae4b00fb29b2212a5"}, {"problem": 86, "code": "(fn [n]\n  (let [step (fn [n] (reduce + (map (comp #(* % %) #(Character/getNumericValue %)) (str n))))]\n    (loop [x n s #{}]\n      (if (contains? s x)\n        (= 1 x)\n        (recur (step x) (conj s x))))))", "user": "597dcb0ce4b0dbe32238d0a2"}, {"problem": 86, "code": "(fn __\n  [x]\n  (loop [new-x x\n         rt #{}]\n    (cond\n      (= new-x 1) true\n      (contains? rt new-x) false\n      :else (recur\n        (reduce + (map #(* % %) (map #(Character/digit % 10) (sequence (str new-x)))))\n        (conj rt new-x)))))", "user": "5b73e500e4b047b03b2036ba"}, {"problem": 86, "code": "(fn happy? [n]\n  (loop [i n\n         results #{}]\n    (cond (= 1 i) true\n          (results i) false\n          :else (recur (reduce #(+ %1 (* %2 %2)) 0\n                               (loop [res '() it i]\n                                 (if (zero? it)\n                                   (if (empty? res) '(0) res)\n                                   (recur (cons (mod it 10) res) (quot it 10)))))\n                       (conj results i)))\n    ))", "user": "5eee7311e4b07c55ae4a0510"}, {"problem": 86, "code": "(fn f \n  ([n] (f n [n]))\n  ([n acc]\n   (let [result (->> (str n)\n                     (map #(- (int %) 48))\n                     (reduce #(+ %1 (* %2 %2)) 0))]\n     (cond\n      (= result 1)         true\n      (some #{result} acc) false\n      :else (recur result (conj acc result))))))", "user": "5dc88a38e4b02f9375f4e1db"}, {"problem": 86, "code": "(fn [n](loop [a n\n       c 10]\n      (if (> c 1)\n          (recur (apply + (map #(* % %) (map #(Integer/parseInt (str %)) (seq (str a)))))\n                 (dec c))   \n          (if (= a 1) true false))))", "user": "51316a63e4b0431ba07e7feb"}, {"problem": 86, "code": "(fn t [n]\n  (loop [x n s #{}]\n    (if (s x)\n      false\n      (let [u (reduce + (map (comp (fn [y] (* y y)) (fn [z] (- z 48)) int) ((comp vec str) x)))]\n        (if (= u 1)\n          true\n          (recur u (conj s x)) )))))", "user": "5df08767e4b093ff717275bf"}, {"problem": 86, "code": "(fn [n]\n    (let [digit-seq (fn digits [digs n] (if (zero? n) digs (digits (cons (rem n 10) digs) (quot n 10) )))]\n      (loop [current n\n             seen #{}]\n        (cond\n          (seen current) false\n          (= current 1) true\n          :else (recur (->> current (digit-seq []) (map #(* %1 %1)) (apply +)) (conj seen current))))))", "user": "4f43b992e4b0d7d3c9f3fd2c"}, {"problem": 86, "code": "(fn [x]\n  (loop [r []\n         n x]\n    (cond\n      (= n 1) true\n      (contains? r n) false\n      :else (recur (conj r n)\n                   (->> (str n)\n                        (map #((fn [x] (* x x))\n                               (read-string (str %))))\n                        (apply +))))))", "user": "5e08c3dde4b0978307768fc8"}, {"problem": 86, "code": "(fn [inp] \n  (let [digits (fn [no] (map #(Integer/parseInt (str %)) (str no)))]\n    (loop [cur inp so-far []] \n      (let [nxt (reduce #(+ % (* %2 %2)) 0 (digits cur))]\n        (cond (= nxt 1) true\n              (some #(#{nxt} %) so-far) false\n              :else (recur nxt (conj so-far nxt)))))))", "user": "5ef5ee81e4b07c55ae4a054a"}, {"problem": 86, "code": "(fn [n]\n (letfn [\n  (nextn [n]\n    (reduce +\n      (map #(* % %)\n       (map #(- (int %) 48)\n        (str n)))))]\n (loop [n n s #{}]\n   (cond\n    (= n 1) true\n    (contains? s n) false\n    :else (recur (nextn n) (conj s n))))))", "user": "4eb97234535dfed6da9c6d53"}, {"problem": 86, "code": "(fn happy-number [num]\n\t(let [sqit (fn [x]\n\t\t\t(loop [prognum x, res 0]\n\t\t\t\t(if (< prognum 10)\n\t\t\t\t\t(+ res (* prognum prognum))\n\t\t\t\t\t(recur\n\t\t\t\t\t\t(quot prognum 10)\n\t\t\t\t\t\t(+ res (* (mod prognum 10) (mod prognum 10)))\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t)]\n\t\t(loop [cache #{}, curval num]\n\t\t\t(cond\n\t\t\t\t(= 1 curval) true\n\t\t\t\t(cache curval) false\n\t\t\t\t(= 1 1) (recur (conj cache curval), (sqit curval))\n\t\t\t)\n\t\t)\n\t)\n)", "user": "5d73530ce4b02e6b30c93514"}, {"problem": 86, "code": "(fn [i]\r\n  (= 1\r\n   ((fn first-dup\r\n      ([l] (first-dup l #{}))\r\n      ([[f & r] s]\r\n       (if (s f)\r\n         f\r\n         (first-dup r (conj s f)))))\r\n    (iterate\r\n     (fn [n] (reduce + (map #(int (Math/pow (Character/getNumericValue %) 2)) (str n))))\r\n     i))))", "user": "5f2c02d1e4b033932238a65f"}, {"problem": 86, "code": "(fn happy?\n  ([n] (happy? n #{}))\n  ([n visited]\n   (let [sums (reduce + 0 (map #(* % %) ((fn to-digits [n]\n  (if (= n 0)\n    []\n    (lazy-seq (cons (rem n 10) (to-digits (quot n 10)))))) n)))]\n     (cond\n       (= 1 sums) true\n       (contains? visited sums) false\n       :else (happy? sums (conj visited sums))))))", "user": "5ed6030de4b016b56eae05db"}, {"problem": 86, "code": "(fn [number]\n  (loop [ number number\n         acc   []]\n    ( let [digits (map #(Character/digit ^Character % 10) (str number))\n           squared-sum  (reduce + (map (fn [number] (* number number)) digits))\n           happy-number (= squared-sum 1)\n           this-squared-sum-appeared-before  (and (not (empty? acc)) (contains? acc squared-sum))]\n      (case [happy-number this-squared-sum-appeared-before]\n        [true true]  true\n        [true false] true\n        [false true] false\n        (do (println squared-sum acc)\n            (recur squared-sum (conj acc squared-sum)))))))", "user": "57eec606e4b0bfb2137f5bc8"}, {"problem": 86, "code": "(fn happy?\n  ([n] (happy? n '()))\n  ([n hist] (let [ss (reduce + (map (comp #(* % %) (partial - 48) int) (seq (str n))))]\n              (cond\n                (= ss 1) true\n               \t(some #(= ss %) hist) false\n               \t:else (happy? ss (conj hist ss))))))", "user": "5f03ab5be4b0cf489e8d7f37"}, {"problem": 86, "code": "(fn [n]\n  (let [get-all-digits (fn get-all-digits [n]\n                         (let [q (quot n 10)\n                               m (mod n 10)]\n                           (cons m (when (> q 0) (get-all-digits q)))))\n        sqr-sum (fn [digits]\n                  (apply + (map #(* % %) digits)))]\n    (loop [n n\n           val-history #{}]\n      (let [s (sqr-sum (get-all-digits n))]\n        (cond\n          (= 1 s) true\n          (val-history s) false\n          :else (recur s (conj val-history s)))))))", "user": "5cf895efe4b0b71b1d808a85"}, {"problem": 86, "code": "(fn happy? [n]\n  (letfn [(sq-sum [x]\n            (->> (str x)\n                 (map (comp read-string str))\n                 (map #(* % %))\n                 (apply +)))]\n    (= 1\n       (last (last\n              (take-while\n               #(let [x (vec (butlast %))]\n                  (and (not= 1 (last x))\n                       (= x (distinct x))))\n               (iterate #(conj % (sq-sum (last %))) [n])))))))", "user": "5b7f2d75e4b047b03b203768"}, {"problem": 86, "code": "(fn happy-number? [n]\n  (letfn [(digits [n]\n            (map #(Integer/parseInt (str %)) (str n)))]\n    (let [ss (iterate (fn [n] (reduce + (map #(* % %) (digits n)))) n)]\n      (loop [[s1 & ss1] ss [s2 & ss2] (rest ss) i 2]\n        (cond\n          (== s1 1) true\n          (== s1 s2) false\n          :else (recur ss1 (nthrest ss2 i) (inc i)))))))", "user": "5f300f28e4b033932238a682"}, {"problem": 86, "code": "(fn [n]\n  (letfn [(ch-to-int [c] (Integer/parseInt (str c)))\n          (num-to-seq [num] (seq (str num)))\n          (pow2 [x] (* x x))\n          (to-digits-and-pow2 [x] (map #(->> % ch-to-int pow2) (num-to-seq x)))\n          (calc-new [num] (apply + (to-digits-and-pow2 num)))\n          (f [current numbers]\n            (if (some (partial = current) numbers)\n              false\n              (let [result (calc-new current)\n                    new-nums (cons current numbers)]\n                (if (= 1 result)\n                  true\n                  (recur result new-nums)))))]\n    (f n [])))", "user": "591ad160e4b09b4ee5954bdf"}, {"problem": 86, "code": "(letfn [(ssd [n] (->> (str n) (map #(- (int %) (int \\0))) (map #(* % %)) (apply +)))\n        (happy? [s] (loop [seen #{}, n s] (cond (= n 1) true (contains? seen n) false :else (recur (conj seen n) (ssd n)))))]\n  happy?)", "user": "5ecc0831e4b016b56eae058c"}, {"problem": 86, "code": "(fn [n]\n  (letfn [(pow2 [v] (* v v))\n          (num-square-of-int [v] (->> (str v)\n                                      (map (fn [i] (pow2 (- (int i) 48))))\n                                      (reduce + 0)))]\n    (loop [cn n itc 10000]\n      (if (= 1 cn)\n        true\n        (if (zero? itc)\n          false\n          (recur (num-square-of-int cn) (dec itc)))))))", "user": "53a5bc3ae4b0ef122a8689c3"}, {"problem": 86, "code": "(fn happy?\n  [num]\n  (loop [checknum num sofar #{}]\n    (let [digits (map #(Integer/parseInt %)\n                      (re-seq #\"\\d\" (str checknum)))\n          squaresum  (apply + (map #(* % %) digits))]\n      (cond\n        (= squaresum 1) true \n        (contains? sofar squaresum) false \n        :else (recur squaresum (conj sofar checknum))))))", "user": "5bf9d9b7e4b0bdcf453d15c4"}, {"problem": 86, "code": "(fn [n]\n   (loop [num n\n          s #{}]\n     (cond\n       (= num 1) true\n       (s num) false\n       :else (let* [new (->> (str num)\n                             seq\n                             (map (comp read-string str))\n                             (map #(* % %))\n                             (apply +))\n                    new-set (conj s num)]\n               (recur new new-set)))))", "user": "5f3f2281e4b004f08c61c561"}, {"problem": 86, "code": "(fn happy? [n]\n\t(loop [i n seen #{}]\n\t\t(cond\n\t\t\t(= i 1) true\n\t\t\t(contains? seen i) false\n\t\t\t:else (recur\n\t\t\t\t((fn smurf [n]\n\t\t\t\t\t(->>\n\t\t\t\t\t\t(str n)\n\t\t\t\t\t\t(seq)\n\t\t\t\t\t\t(map str)\n\t\t\t\t\t\t(map read-string)\n\t\t\t\t\t\t(map #(* % %))\n\t\t\t\t\t\t(reduce +)\n\t\t\t\t\t)\n\t\t\t\t) i)\n\t\t\t\t(conj seen i)\n\t\t\t)\n\t\t)\n\t)\n)", "user": "5f574662e4b0a0bc16850a90"}, {"problem": 86, "code": "#(loop [n %\n        tried #{}]\n    (cond\n      (= n 1) true\n      (tried n) false\n      :else (letfn [(squareString [s] (let [n (Integer/parseInt (str s))] (* n n)))]\n              (recur (->> (str n)\n                          (map squareString)\n                          (reduce +))\n                     (conj tried n)))))", "user": "5f3abcc4e4b004f08c61c52b"}, {"problem": 86, "code": "(fn f\n   ([n] (f #{} n))\n   ([seen v]\n     (cond\n       (= v 1) true\n       (seen v) false\n       :else\n       (recur\n        (conj seen v)\n        (apply + (map #(int (Math/pow % 2)) (map #(Integer/parseInt (str %)) (str v))))))))", "user": "576e607ae4b0979f89651579"}, {"problem": 86, "code": "(fn happy ([n] (happy n #{}))\n    ([n eset]\n     (if (= n 1)\n       true\n       (if (eset n)\n         false\n         (let [addsum (fn [n]\n                        (let [sq #(* % %)]\n                          (apply + (map #(sq (Integer/parseInt  (.toString %))) (str  n)))))]\n           (recur (addsum n) (conj eset n)))))))", "user": "5c9dcb36e4b048ec896c5b1d"}, {"problem": 86, "code": "(fn [n]\n    (let [ digits (fn [n] (map #(- (int %) (int \\0)) (seq (str n))))\n           sumsqd (fn [n] (reduce + (map #(* % %) (digits n)))) ]\n        (loop [i n, history #{}]\n            (let [s (sumsqd i)]\n                (cond (= 1 s)       true\n                      (history s)   false\n                      :else         (recur s (conj history s)))))))", "user": "5eff6c0ee4b0cf489e8d7f11"}, {"problem": 86, "code": "(fn happy-number?\n  [n]\n  (loop [cur-num n\n         visited #{n}]\n    (if (= cur-num 1)\n      true\n      (let [new-num (->> (seq (str cur-num))\n                         (map #(Character/digit % 10))\n                         (map #(* % %))\n                         (reduce +))]\n        (if (contains? visited new-num)\n          false\n          (recur new-num (conj visited new-num)))))))", "user": "5f29837ee4b033932238a64f"}, {"problem": 86, "code": "(fn i [v]\n  (condp = v\n    1 true\n    4 false\n    (i (reduce #(+ %1 (* %2 %2)) 0 (map #(- (int %) 48) (str v))))))", "user": "588fbb39e4b00487982d51bd"}, {"problem": 86, "code": "; I used nth the first time\n(fn Happy? [n]\n   (let [iteration (fn [num]\n                     (->> num\n                          (str)\n                          (seq)\n                          (map str)\n                          (map #(Integer. %))   ; take each individual digit\n                          (map #(Math/pow % 2)) ; square it\n                          (map int)\n                          (apply +)             ; and then sum the squares\n                          ))]\n     (= 1 (nth (iterate iteration n) 20))\n     ))", "user": "5f0824c5e4b0cf489e8d7f5b"}, {"problem": 86, "code": "(fn happy-number?\n  ([n] (happy-number? n #{n}))\n  ([n memo]\n   (let [squared-sum (apply + (map #(* % %) (loop [n n digits []]\n                                              (if (zero? (quot n 10))\n                                                (conj digits (mod n 10))\n                                                (recur (quot n 10) (conj digits (mod n 10)))))))]\n     (cond (= squared-sum 1) true\n           (contains? memo squared-sum) false\n           :else (happy-number? squared-sum (conj memo squared-sum))))))", "user": "5ea6fe98e4b00a66d4a951b2"}, {"problem": 86, "code": "(fn happy\n  [n]\n  (letfn [(digs [n]\n            (loop [r ()\n                   n n]\n              (if (zero? n)\n                r\n                (recur (cons (rem n 10) r) (quot n 10)))))]\n    (loop [n n\n           prev #{}]\n      (let [r (reduce + (map #(* % %) (digs n)))]\n        (if (= r 1)\n          true\n          (if (contains? prev r)\n            false\n            (recur r (conj prev r))))))))", "user": "4e8a170c535d3e98b802328f"}, {"problem": 86, "code": "(fn happy?\n    ([n] (happy? n []))\n    ([n visited]\n     (let [ds (map #(- (int %) 48) (str n))\n           n' (apply + (map #(* % %) ds))]\n       (if (some #{n'} visited)\n         false\n         (if (= 1 n')\n           true\n           (recur n' (conj visited n')))))))", "user": "507e68abe4b085af06e3afd2"}, {"problem": 86, "code": "(fn [x]\n  (letfn [(sumsqd [n] (->> n str (map #(Character/digit % 10)) (map #(* % %)) (apply +)))]\n    (loop [n x\n           seen #{}]\n      (cond\n        (= 1 n) true\n        (seen n) false\n        :else (recur (sumsqd n) (conj seen n))))))", "user": "596a66cde4b069c0a1a19803"}, {"problem": 86, "code": "(fn hapn [n]\n  (letfn [(digs [i]\n            (loop [i i\n                   r '()]\n              (if (= i 0)\n                r\n                (recur (quot i 10) (conj r (rem i 10))))))\n          (sqsum [s] (reduce + 0 (map #(* % %) s)))]\n    (loop [i n\n           path '()]\n      (if (= i 1)\n        true\n        (if (some #(= i %) path)\n          false\n          (recur (sqsum (digs i)) (conj path i)))))))", "user": "5f8b06afe4b0715f5002d74a"}, {"problem": 86, "code": "(fn [num]\n   (let [dissect (fn [n]\n                   (loop [state n\n                          numbers []]\n                     (if (> 10 state)\n                       (conj numbers state)\n                       (recur\n                        (int (/ state 10))\n                        (conj numbers (mod state 10))))))\n         happyize (fn [n]\n                    (->> n\n                         (dissect)\n                         (map #(* % %))\n                         (reduce +)))]\n     (loop [state (happyize num)\n            seen #{}]\n       (if (= 1 state)\n         true\n         (if (seen state)\n           false\n           (recur\n            (happyize state)\n            (conj seen state)))))))", "user": "5f79bff2e4b02876ed9fd0ca"}, {"problem": 86, "code": "(fn [x]\n  (let [digits (fn [n] (->> (re-seq #\".\" (str n))\n                            (map #(Long/parseLong %))))\n        sq-sum (fn [ns] (reduce + (map #(* % %) ns)))]\n    (loop [seen #{}\n           n x]\n      (cond\n        (= 1 n) true\n        (contains? seen n) false\n        :else (recur (conj seen n)\n                     (sq-sum (digits n)))))))", "user": "5f93529ae4b0715f5002d7bc"}, {"problem": 86, "code": "(fn happy? [number]\n  (letfn [(next-n [n]\n            (let [digs (map #(read-string (str %)) (str n))]\n              (apply + (map * digs digs))))]\n    (loop [x number\n           s #{}]\n      (cond\n        (contains? s x) false\n        (= x 1) true\n        :else (recur (next-n x) (conj s x))))))", "user": "5fa74b82e4b0fa27300f3dda"}, {"problem": 86, "code": "(fn [n]\n  (loop [x n\n         hxs #{}]\n    (cond \n      (= x 1)\n      true\n      (contains? hxs x)\n      false\n      :else\n      (let [x' (->> x\n    \t\t         (iterate #(quot % 10))\n    \t\t         (take-while pos?)\n    \t\t         (map #(mod % 10))\n    \t\t         (map #(* % %))\n    \t\t         (reduce +))]\n          (recur x' (conj hxs x))))))", "user": "59e0f38ae4b08badc2a0c500"}, {"problem": 86, "code": "(fn [n]\n              (letfn [(nxt [x] \n                           (->> (str x)\n                                (map str)\n                                (map #(Integer/parseInt %))\n                                (map #(* % %))\n                                (reduce +)))]\n               (loop [x n\n                      acc #{}]\n                (if (contains? acc x)\n                  (= 1 x)\n                  (recur (nxt x) (conj acc x))))))", "user": "5f5358b7e4b0a0bc16850a77"}, {"problem": 86, "code": "(fn [n]\n  (letfn [(digits\n           [n]\n           ((fn iter\n              [result remain]\n              (if (< remain 10) (cons remain result)\n                  (iter (cons (rem remain 10) result) (quot remain 10)))) nil n))\n          (sum-of-square\n           [v]\n           (reduce + (map #(* % %) v)))\n          (happy?\n            [cur past]\n            (let [s (sum-of-square (digits cur))]\n              (cond (= s 1) true\n                    (contains? past s) false\n                    :else (happy? s (conj past cur)))))]\n    (happy? n #{})))", "user": "58f98231e4b0438e51c2cf4c"}, {"problem": 86, "code": "(fn [v] ((fn h [l]\n\n   (if (= (first l) 1) true\n\n   (if (some #(= (first l) %) (rest l)) false\n\n   (h (cons\n\n      (->> (first l)\n\n        (str)\n\n        (map (comp read-string str))\n\n        (seq)\n\n        (map #(* % %))\n\n        (apply +)) l\n\n        ))))) (list v)))", "user": "5fab7ea6e4b08cb800c85ad8"}, {"problem": 86, "code": "(fn [n]\n   (loop [x n s #{}]\n     ;(prn x s)\n     (cond\n       (= x 1) true\n       (s x) false\n       :else (recur (->> (str x)\n                   (map (comp read-string str))\n                   (reduce #(+ % (* %2 %2)) 0)) (conj s x)))))", "user": "5fa96ddbe4b0fa27300f3dec"}, {"problem": 86, "code": "#(condp = % 7 true 986543210 true 2 false 3 false)", "user": "5e8ce2fee4b0cb0169546328"}, {"problem": 86, "code": "(fn [x]\n  (loop [n x r [] s #{}] \n    (if (= 1 n)\n      true\n      (let [nx (apply + (map #(* % %) (map #(- % 48) (map int (str n)))))]\n        (if (s nx)\n          false\n          (recur nx (conj r nx ) (conj s nx)))))))", "user": "5e12327ee4b099d064962fe5"}, {"problem": 86, "code": "(fn p86\n  ([x] (p86 #{} x))\n  ([acc x]\n   (let [num->digits\n         (fn [acc n]\n           (let [new-acc (cons (rem n 10) acc)\n                 new-n (quot n 10)]\n             (if (zero? new-n) new-acc (recur new-acc new-n))))\n         sqr-sum (reduce #(+ %1 (* %2 %2)) 0 (num->digits () x))]\n     (cond\n       (= x 1) true\n       (contains? acc x) false\n       :else (p86 (conj acc x) sqr-sum)))))", "user": "5fa17538e4b0f0ebd91b77e3"}, {"problem": 86, "code": "(fn check-if-happy-number [num]\n\n  (letfn [(get-digits [num]\n            (map #(Integer. (str %)) (seq (str num)))\n            )\n          (process-for-happy [num]\n            (apply +  (map #(* % %) (get-digits num)))\n\n            )\n          (is-happy [num] (= num 1))] \n\n    (loop [cur-num num num-rounds 0]\n\n      (if (is-happy cur-num) \n        true\n        (if (= num-rounds 10000)\n          false \n          (recur (process-for-happy cur-num) (inc num-rounds))))\n      ))\n)", "user": "5ff676a9e4b06df49cee1497"}, {"problem": 86, "code": "(fn [n]\n  (let [digits (fn [x] (map #(Integer/parseInt (str %)) (str x)))\n        square-sum (fn [n] (apply + (map #(* % %) (digits n))))]\n    (loop [nums [n]]\n      (let [new-num (square-sum (last nums))]\n        (cond\n            (= new-num 1) true\n            (contains? (set nums) new-num) false\n            :else (recur (conj nums new-num)))))))", "user": "56aad4f7e4b03c432f187338"}, {"problem": 86, "code": "(fn [n]\n    (letfn [(digits [n]\n                (loop [n n acc '()]\n                    (if (= n 0)\n                        acc\n                        (recur (quot n 10) (cons (rem n 10) acc)))))]\n        (loop [n n\n               s #{}]\n            (if (= n 1)\n                true\n                (if (contains? s n)\n                    false\n                    (recur (reduce + (map #(* % %) (digits n))) (conj s n)))))))", "user": "600ae927e4b074f607df6689"}, {"problem": 86, "code": "(fn [num]\n  (letfn [(square [n] (* n n))\n          (sum-squares [n] (->> (str n)\n                                (map str)\n                                (map read-string)\n                                (map square)\n                                (apply +)))]\n    (loop [n num\n           i 0]\n      (cond\n        (= 1 n) true\n        (> i 1000) false\n        :else (recur (sum-squares n) (inc i))))))", "user": "5f37263de4b0574c87022c4e"}, {"problem": 86, "code": "(fn [x]\n  (letfn [(digits [x] (map (comp read-string str) (str x)))\n          (sum-squares [xs] (reduce #(+ % (* %2 %2)) 0 xs))]\n    (loop [x x, sums #{x}]  \n      (let [t (sum-squares (digits x))]\n        (cond\n         (= t 1) true\n         (contains? sums t) false\n         :else (recur t (conj sums t)))))))", "user": "5e3e23d9e4b01d43a70e8e20"}, {"problem": 86, "code": "(fn [n]\n(letfn [(d [i] (map #(Character/digit % 10) (str i)))\n(s [i] (reduce + (map #(* % %) (d i))))]\n(boolean (some #{1} (take 99 (iterate s n))))))", "user": "5fd10010e4b07e53c2f3f02a"}, {"problem": 86, "code": "(fn happy? [x]\n  (let [sum-of-squares (fn [coll]\n                         (apply + (map #(* % %) coll)))\n        digits (fn [n]\n                 (loop [result '()\n                        i      n]\n                   (if (zero? i)\n                     result\n                     (recur (conj result (rem i 10)) (quot i 10)))))\n        step (fn [i] (sum-of-squares (digits i)))]\n    (loop [i (step x)]\n      (cond\n        (= 1 i) true\n        (or (= x i) (= 4 i)) false\n        :else   (recur (step i))))))", "user": "601aaa93e4b0bf4ca6b10926"}, {"problem": 86, "code": "(letfn [(num->digits [num]\n          (loop [n num res []]\n            (if (zero? n)\n              res\n              (recur (long (/ n 10)) (cons (mod n 10) res)))))\n        (change [n]\n          (apply + (map #(* % %) (num->digits n))))]\n  (fn [init]\n    (loop [curr init results #{}]\n      (println curr \" - \" results)\n      (cond\n       (= 1 curr) true\n       (results curr) false\n       :else (let [new-n (change curr)]\n               (println curr new-n)\n               (recur new-n (into results [curr])))\n       )))\n  )", "user": "5f419985e4b0955706451fab"}, {"problem": 86, "code": "(fn [ns]\n  (letfn [(square-sum [ns]\n            (loop [ns ns\n                   acc 0]\n              (let [n (mod ns 10)\n                    div (quot ns 10)]\n                (if (= 0 div)\n                  (+ acc (* n n))\n                  (recur div (+ acc (* n n)))))))]\n\n    (loop [current (square-sum ns)\n           square-sums #{}]\n      (cond\n        (= current 1) true\n        (square-sums current) false\n        :else (recur\n               (square-sum current)\n               (conj square-sums current))))))", "user": "601004d6e4b074f607df66b2"}, {"problem": 86, "code": "(fn [x] (let [f (fn [a] (->> a\n                             str\n                             (map #(Character/digit % 10))\n                             (map #(Math/pow % 2))\n                             (map int)\n                             (apply +)))]\n             (loop [n (f x)\n                    lst []] \n          \t\t(if (= n 1) \n                  \ttrue\n                  \t(if (some #{n} lst)\n                      \tfalse\n                      \t(recur (f n) (conj lst n)))))))", "user": "6011b89ee4b074f607df66bc"}, {"problem": 86, "code": "(fn [n]\n  (letfn [(ss [n] (->> n\n                 str\n                 (map (fn [x] (int (Math/pow (Character/digit x 10) 2))))\n                 (reduce +)))]\n    (loop [seen #{} current n]\n      (cond (= 1 current) true\n          (seen current) false\n          :else (recur (conj seen current) (ss current))\n      )       \n    )\n  )\n )", "user": "5fd8bcb3e4b05ac5b16ea11b"}, {"problem": 86, "code": "(fn happy-number? [n]\n  (letfn [(formular [x] (reduce + 0\n                                (map (fn [y] (* y y))\n                                     (map (fn [z] (- (int z) 48))\n                                          (str x)))))]\n    (loop [seen #{}\n           curr n]\n      (let [next (formular curr)]\n        (cond\n          (= 1 next) true\n          (contains? seen next) false\n          :else (recur (conj seen next) next))))))", "user": "5fbf6fe7e4b0ad6fc3476147"}, {"problem": 86, "code": "#(letfn [(square-sum [n]\n          (apply + (map (fn [x]\n                          (Math/pow (- (int x) (int \\0)) 2))\n                        (str (int n)))))]\n  (loop [all #{}\n         n %]\n    (cond\n      (== n 1) true\n      (contains? all n) false\n      :else (recur (conj all n) (square-sum n)))))", "user": "60096aabe4b074f607df667f"}, {"problem": 86, "code": "(fn happy [n]\n  (loop [nn n sums []]\n    (cond (not= (count sums)\n              (count (distinct sums))) false\n          (= (last sums) 1) true\n          :else (recur (int (apply + (map #(Math/pow % 2)\n                               (map read-string (map str (str nn))))))\n          \t(conj sums (int (apply + (map #(Math/pow % 2)\n                               (map read-string (map str (str nn))))))\n          )))))", "user": "60264d89e4b0d5df2af2222d"}, {"problem": 86, "code": "(fn [n]\n  (loop [n n, seen #{}]\n    (cond \n      (= n 1)  true\n      (seen n) false\n      :else\n        (recur (->> (str n)\n                    (map #(Character/digit % 10))\n                    (map #(* % %))\n                    (reduce +))\n               (conj seen n)))))", "user": "54d7e277e4b0a52adc2e2031"}, {"problem": 86, "code": "(fn happy? [num]\n  (loop [n num\n         seen #{}]\n    (if (= n 1)\n      true\n      (if (contains? seen n)\n        false\n        (recur (->> n\n     \t\t\t\t\t(iterate #(quot % 10))\n     \t\t\t\t\t(take-while pos?)\n    \t\t\t\t\t (mapv #(mod % 10))\n    \t\t\t\t\t (map #(* % %))\n     \t\t\t\t\t (apply +))\n\t\t\t\t\t (conj seen n))))))", "user": "5fada7cce4b08cb800c85af5"}, {"problem": 86, "code": "(fn a [an]\n    (let [digit (fn [n] (map #(- (int %) 48) (str n)))\n          square #(* % %)\n          sum-sq (fn [n] (reduce + (map square (digit n)) ))\n    ]\n    (boolean (some #{1} (take 50 (iterate sum-sq an))))\n    )\n)", "user": "5fe09d1fe4b05ac5b16ea15b"}, {"problem": 86, "code": "(fn foo [number]\n\n    (loop [number number\n            helper (fn helper [x]\n                (loop [numb x\n                     res 0\n             len (-> numb str count) ]\n                     (if (zero? len ) res\n                     (recur (int (/ numb 10)) \n                        (+ res (* (rem numb 10) (rem numb 10)))  \n                            (dec len))\n            )))]\n        (println number \" \")\n        (cond (= number 1) true\n              (= number (helper number) ) false\n              ( = number 4) false\n              :else (recur (helper number) helper)\n        )\n    )\n)", "user": "6038b6b4e4b0d5df2af222ef"}, {"problem": 86, "code": "(fn [x]\n  (let [digits (fn [number]  (map #(Character/digit % 10) (str number)))] \n      (loop [s x tries 0]\n\t\t(if (= s 1)\n           true\n           (if (> tries 20)\n             false\n             (let [n (apply + (map #(* % %) (digits s)))]\n               (recur n (inc tries))))))))", "user": "59203996e4b09b4ee5954c5b"}, {"problem": 86, "code": "(fn get-happy\n  ([n] (get-happy n #{}))\n  ([n seen]\n   (let [soq (->> n\n                  str\n                  (map str)\n                  (map read-string)\n                  (map #(* % %))\n                  (reduce (fn [acc v] (+ acc v)) 0))]\n     (if (= 1 soq)\n       true\n       (if (seen soq)\n         false\n         (get-happy soq (conj seen soq)))))))", "user": "5edd05bfe4b0c7845d86b0f3"}, {"problem": 86, "code": "(letfn [(num->digits [num]\n          (loop [n num res []]\n            (if (zero? n)\n              res\n              (recur (long (/ n 10)) (cons (mod n 10) res)))))\n        (change [n]\n          (apply + (map #(* % %) (num->digits n))))]\n  (fn [init]\n    (loop [curr init results #{}]\n      (println curr \" - \" results)\n      (cond\n       (= 1 curr) true\n       (results curr) false\n       :else (let [new-n (change curr)]\n               (println curr new-n)\n               (recur new-n (into results [curr])))\n       )))\n  )", "user": "6030855de4b0d5df2af222a6"}, {"problem": 86, "code": "(fn happy-number? [n] \n  (let [happy-number-candidate \n        (comp (partial apply +)\n              (partial map #(* % %))\n              (partial map #(Integer/parseInt %))\n              (partial map str)\n              char-array\n              str)]\n    (loop [candidate n\n           seen #{}]\n      (cond\n        (= 1 candidate) true\n        (contains? seen candidate) false\n        :else (recur (happy-number-candidate candidate) (conj seen candidate))))))", "user": "604d3cb1e4b0b7ec0ac60ac2"}, {"problem": 86, "code": "(fn [n]\n  (letfn [(digits [n]\n            (->> n\n                 (iterate #(quot % 10))\n                 (take-while pos?)\n                 (map #(mod % 10))\n                 (reverse)))\n          (happy-transform [n]\n            (->> n\n                 digits\n                 (map #(* % %))\n                 (apply +)))]\n   (loop [l (->> n\n                 (iterate happy-transform)\n                 (reductions (fn [[acc k1] k2] [(conj acc k1) k2])\n                             [#{} nil]))]\n     (let [[acc k] (first l)]\n       (cond (= k 1) true\n             (contains? acc k) false\n             :else (recur (rest l)))))))", "user": "60460824e4b02d28681c77bc"}, {"problem": 86, "code": "(fn happy-number?\n  [n]\n  (let [digits (fn [x]\n                 (->> (seq (str x))\n                      (map str)\n                      (map #(Long/parseLong %))))\n        square-sum (fn [ds]\n                     (reduce #(+ %1 (* %2 %2))\n                             0\n                             ds))]\n    (loop [x n]\n      (let [sum (square-sum (digits x))]\n        (case sum\n          1 true\n          4 false\n          (recur sum))))))", "user": "4e586949535d8a8b8723a292"}, {"problem": 86, "code": "(fn __ [x]\n  (loop [ys [x]]\n    (if (= (last ys) 1)\n      true\n      (let [y (reduce +\n                      (map #(* (Integer/parseInt % 10) (Integer/parseInt % 10))\n                            (re-seq #\"\\d\" (str (last ys)))))]\n        (if (some #{y} ys)\n          false\n          (recur (conj ys y)))))))", "user": "526759b3e4b03e8d9a4a715b"}, {"problem": 86, "code": "(fn [n] (let [t (fn [n prev-seen]\n                             (let [v (->>\n                                      (clojure.string/split (str n) #\"\")\n                                      (filter (complement clojure.string/blank?))\n                                      (map #(Integer/parseInt %))\n                                      (map #(* % %))\n                                      (reduce +))]\n                               (if (= 1 v)\n                                 true\n                                 (if (contains? prev-seen v)\n                                   false\n                                   (recur v (conj prev-seen v))))))]\n                     (t n #{})))", "user": "5f5b624de4b05ea7b9adc42f"}, {"problem": 86, "code": "(fn happy? [n]\n  (letfn [(digits [n]\n            (loop [n n ds '()]\n              (if (< n 10)\n                (cons n ds)\n                (recur (quot n 10) (cons (mod n 10) ds)))))\n          (sq [n] (* n n))]\n    (loop [i 0 m n past #{}]\n      (cond\n        (contains? past m) false\n        (= m 1) true\n        :else (recur \n               (inc i)\n               (->> (digits m)\n                    (map sq)\n                    (reduce +))\n               (conj past m))))))", "user": "58b81490e4b0ebc645576d8c"}, {"problem": 86, "code": "(fn [n]\n  (let [sqsum\n        (fn [n]\n          (->> (str n)\n               (map str)\n               (map read-string)\n               (map #(* % %))\n               (apply +)))]\n    (loop [x (sqsum n)\n           seen #{}]\n      (cond\n        (= x 1) true\n        (seen x) false\n        :else (recur (sqsum x) (conj seen x))))))", "user": "605b7a90e4b079a07f8593fc"}, {"problem": 86, "code": "(fn foo [x]\r\n  (letfn \r\n    [(digits [x] \r\n       (if (> 10 x) (list x)\r\n         (conj (digits (int (/ x 10))) (mod x 10))))\r\n     (happy?  [prev x]\r\n       (cond\r\n         (= 1 x) true\r\n         (prev x) false\r\n         :else\r\n           (recur \r\n             (conj prev x) \r\n             (apply \r\n               + \r\n               (map \r\n                 #(* % %) \r\n                 (digits x))))))]\r\n      (happy? #{} x)))", "user": "606e0a42e4b069485764de19"}, {"problem": 86, "code": "(fn solve\n  ([n] (solve n #{n}))\n  ([n k]\n   (let [next (apply + (map #(* (Integer/parseInt (str %)) (Integer/parseInt (str %)))\n                            (str n)))]\n     (cond\n       (= next 1) true\n       (contains? k next) false\n       :else (recur next (conj k next))))))", "user": "60537cd1e4b04c8f2157d152"}, {"problem": 86, "code": "(fn [n]\n  (letfn [(squared-sum [nr]\n            (loop [i nr sum 0]\n              (if (zero? i)\n                 sum\n                 (recur (int (/ i 10)) (+ sum (* (rem i 10) (rem i 10)))))))]\n    (let [s (squared-sum n)\n          f (squared-sum (squared-sum n))]\n       (loop [slow s fast f]\n         (if (= slow fast)\n           (= 1 slow)\n           (recur (squared-sum slow) (squared-sum (squared-sum fast))))))))", "user": "52f53589e4b05e3f0be25f2c"}, {"problem": 86, "code": "(fn [n]\n    (loop [s (str n)\n           c 1000]\n      (if (> c 0)\n        (recur (str (reduce + (map #(let [d (Integer/parseInt (str %))]\n                                      (* d d)) s))) (dec c))\n        (= s \"1\"))))", "user": "603ae21de4b0d5df2af222fb"}, {"problem": 86, "code": "(fn happy-number? [input]\n    (letfn\n         [(squares-of-digits [number]\n             (->> number\n                 str\n                 seq\n                 (map str)\n                 (map read-string)\n                 (map #(* % %))\n                 (apply +)))]\n    (loop [current-number input\n           digit-squares (rest (iterate squares-of-digits input))\n           encountered-numbers '()]\n           (cond (= current-number 1) true\n                 (some #(= current-number %) encountered-numbers) false\n                 :else (recur (first digit-squares)\n                              (rest digit-squares)\n                              (cons current-number encountered-numbers))))))", "user": "5f548678e4b0a0bc16850a7e"}, {"problem": 86, "code": "(fn [x]\n  (let [f (fn [a]\n            (let [ds (map #(Character/getNumericValue %) (seq (str a)))]\n              (apply + (map #(* % %) ds))))]\n    (loop [x x seen #{}]\n      (let [d (f x)]\n        (if (= 1 d)\n          true\n          (if (contains? seen d)\n            false\n            (recur d (conj seen d))))))))", "user": "606a70a5e4b069485764ddf2"}, {"problem": 86, "code": "(fn happy-numbers\n  [my-number]\n  (let [sum-of-squares (fn [my-number]\n                         (reduce (fn [num digit]\n                                   (let [digit' (Integer/parseInt digit)]\n                                     (+ num (* digit' digit'))))\n                                 0\n                                 (filter not-empty (clojure.string/split (str my-number) #\"\"))))]\n    (loop [x my-number\n           y 0]\n      (let [x' (sum-of-squares x)]\n        (cond\n          (= 1 x') true\n          (= y 100) false\n          :else (recur x' (inc y))\n          )))))", "user": "60396c95e4b0d5df2af222f4"}, {"problem": 86, "code": "(fn happy? [n]\n  (letfn [(digits [n]\n            (map #(Integer/parseInt (str %)) (str n)))\n          (sum-of-squares [n]\n            (reduce + (map #(* % %) (digits n))))]\n    (boolean (some #{1} (take 100 (iterate sum-of-squares n))))))", "user": "6088395de4b0ae75613dcee2"}, {"problem": 86, "code": "(fn happy? [n]\n  (letfn [(digits [n]\n            (map #(Integer/parseInt (str %)) (str n)))\n          (sum-of-squares [n]\n            (reduce + (map #(* % %) (digits n))))]\n    (boolean (some #{1} (take 100 (iterate sum-of-squares n))))))", "user": "60951d52e4b00e9e6653c3ea"}, {"problem": 86, "code": "(fn [number]\n  (let [sum-squares (fn [n]\n                      (->> (str n)\n                           (map #(Character/digit % 10))\n                           (map #(* % %))\n                           (reduce +)))]\n    (= 1 (loop [n number\n                sum (sum-squares n)]\n           (if (or (= sum 1) (= sum 4))\n             sum\n             (recur sum (sum-squares sum)))))))", "user": "60a42199e4b00e9e6653c454"}, {"problem": 86, "code": "(fn happy?\n  [n]\n  (loop [n* n seen #{}]\n    (if (contains? seen n*)\n      false\n      (let [n** (->> (for [char (str n*)\n                           :let [digit (Character/getNumericValue ^Character char)]]\n                       (* digit digit))\n                     (apply +))]\n        (if (= n** 1)\n          true\n          (recur n** (conj seen n*)))))))", "user": "6098263be4b00e9e6653c3f9"}, {"problem": 86, "code": "(fn [n]\n   (loop [current n series []]\n     (let [newone (reduce #(+ %1 (* (- (int %2) 48) (- (int %2) 48))) 0 (str current))]\n       (cond\n         (= 1 newone ) true\n         (contains? series newone) false\n         :else (recur newone (conj series newone))))))", "user": "608ec5e4e4b03bd49d9f36c0"}, {"problem": 86, "code": "(fn happy? [n]\n  (let [candidate (->> n\n                      (iterate #(quot % 10))\n                      (take-while pos?)\n                      (map #(mod % 10))\n                      (map #(* % %))\n                      (apply +))]\n    (cond\n      (= candidate 1) true\n      (< candidate 10) false\n      :else (recur candidate))))", "user": "60794173e4b0a637ed78035d"}, {"problem": 86, "code": "(fn [x]\n  (loop [curr x seen #{}]\n    (cond \n      (= 1 curr) true\n      (contains? seen curr) false\n      :else (recur    \n              (->> curr\n                (str)\n                (map #(int (- (int %) (int \\0))))\n                (map #(* % %))\n                (reduce +)\n              )\n              (conj seen curr)))))", "user": "60b2aaebe4b0e0fa5f1b4228"}, {"problem": 86, "code": "(fn happy [n]\n    (letfn [(happy-number [n] (take 20\n                                    (take-while #(> % 1)\n                                                (iterate (fn [n] (->> n\n                                                                      (str)\n                                                                      (seq)\n                                                                      (map str)\n                                                                      (map #(Integer/parseInt %))\n                                                                      (map #(* % %))\n                                                                      (apply +))) n))))]\n    (if (> (count (happy-number n)) 15)\n      false\n      true)))", "user": "5f8e2a08e4b0715f5002d767"}, {"problem": 86, "code": "(fn happy?\n   ([x] (happy? x #{}))\n   ([x seen]\n    (let [next (->> x\n                    str\n                    (re-seq #\".\")\n                    (map #(Integer. %))\n                    (map #(* % %))\n                    (reduce +))]\n      (cond (= next 1) true\n            (seen next) false\n            :else (happy? next (conj seen next))))))", "user": "60b7e2c5e4b0e0fa5f1b4252"}, {"problem": 86, "code": "(fn happy [n]\n  (letfn [(digits [n]\n            (rseq (mapv #(mod % 10) (take-while pos? (iterate #(quot % 10) n)))))\n          (sum-sq-digits [n]\n            (reduce + (map #(* % %) (digits n))))]\n    (loop [v (sum-sq-digits n)\n           visited #{}]\n      (println \">\" v)\n      (if (= 1 v)\n        true\n        (if (contains? visited v)\n          false\n          (recur (sum-sq-digits v) (conj visited v)))))))", "user": "51b920bfe4b0e871ca4958f9"}, {"problem": 86, "code": "(fn [x]\n  (letfn [(get-digits [x] (map #(Character/digit % 10) (str x)))\n          (squares [coll] (map #(* % %) coll))\n          (get-next [x] (->> (get-digits x) squares (reduce +)))]\n    (loop [results #{}\n           nmb x]\n      (cond\n        (= nmb 1) true\n        (contains? results nmb) false\n        :else (recur (conj results nmb) (get-next nmb))))))", "user": "5f82609ae4b0c071e6c840f9"}, {"problem": 86, "code": "(fn happy-num\n  [n]\n  (let [sum-of-squares-fn (fn [n]\n                         (->> n\n                              (str)\n                              (seq)\n                              (map #(Integer/parseInt (str %)))\n                              (map #(* % %))\n                              (apply +)))\n        attempts 1000]\n\n    (= 1\n     (last\n      (take attempts (iterate sum-of-squares-fn n))))))", "user": "60c0ceb7e4b0e0fa5f1b42a6"}, {"problem": 86, "code": "(fn happy-numbers [n]\n  (letfn [(square-digits [a]\n            (->> a\n                 (str)\n                 (vec)\n                 (map #(read-string (str %)))\n                 (reduce (fn [b c] (+ b (* c c))) 0)))]\n    (let [permu (->> n\n                     (iterate square-digits)\n                     (take 20))]\n      (.contains permu 1))))", "user": "60aecd73e4b00e9e6653c49a"}, {"problem": 86, "code": "(letfn [(digits [n] (map #(- (int %) (int \\0)) (seq (str n))))\n        (next-n [n] (reduce + (map #(* % %) (digits n))))\n        (period [seen [x & xs]]\n          (or (seen x) (recur (conj seen x) xs)))\n        (happy? [n]\n          (->> n\n               (iterate next-n)\n               (period #{})\n               (= 1)))\n        ]\n  happy?)", "user": "53720c5ce4b0493c815db704"}, {"problem": 86, "code": "(fn happy? [n]\n  (letfn [(digits [n]\n            (map #(Integer/parseInt (str %)) (str n)))\n          (sum-of-squares [n]\n            (reduce + (map #(* % %) (digits n))))]\n    (boolean (some #{1} (take 100 (iterate sum-of-squares n))))))", "user": "609aa543e4b00e9e6653c40c"}, {"problem": 86, "code": "(fn is-happy-number?\n  [x]\n  (let [next-happy-number (fn [hn]\n                            (let [digits (map #(Character/digit % 10) (seq (str hn)))\n                                  squares (map #(* % %) digits)]\n                              (reduce + squares)))\n        is-hn-recur (fn is-hn-recur [hn seen-nums]\n                      (let [next-hn (next-happy-number hn)]\n                        (cond\n                          (seen-nums next-hn) false\n\n                          (= next-hn 1) true\n\n                          :else (is-hn-recur next-hn (conj seen-nums next-hn)))))]\n    (is-hn-recur x (set [x]))))", "user": "60c8e372e4b0e0fa5f1b42ff"}, {"problem": 86, "code": "(fn [x]\n  (loop [x x visited #{}]\n    (let [new (reduce + (map (comp #(* % %) read-string str) (str x)))]\n      (cond\n        (visited new) false\n        (= 1 new) true\n        :default (recur new (conj visited new))))))", "user": "59419bdfe4b060784b3b78f7"}, {"problem": 86, "code": "(fn [n]\n  (loop [curr-num n\n         seen #{}]\n    (let [digits (map #(Character/digit % 10) (str curr-num))\n          square (int (apply + (map #(Math/pow % 2) digits)))]\n      (cond\n        (contains? seen curr-num) false\n        (= square 1) true\n        :else (recur square (conj seen curr-num))))))", "user": "4fe49706e4b0e8f79898feb7"}]