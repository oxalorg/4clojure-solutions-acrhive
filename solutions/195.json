[{"problem": "195", "code": "(fn parens [n]\n  (set\n   (map (partial apply str)\n        ((fn lazy-recur [open close]\n           (lazy-seq\n             (concat (when (pos? open)\n                       (map #(cons \\( %)\n                            (lazy-recur (dec open) (inc close))))\n                     (when (pos? close)\n                       (map #(cons \\) %)\n                            (lazy-recur open (dec close))))\n                     (when (= [0 0] [open close])\n                       [\"\"]))))\n         n 0))))", "user": "4dabb7b1950ed6eda1bd72f3"}, {"problem": "195", "code": "(fn ps [n]\n  (letfn [(ps* [o r]\n            (or (seq (concat \n                       (when (< 0 r)\n                         (map #(str \\( %)\n                              (ps* (inc o) (dec r))))\n                       (when (< 0 o)\n                         (map #(str \\) %)\n                              (ps* (dec o) r)))))\n                [\"\"]))]\n    (into #{} (ps* 0 n))))", "user": "53dfdf01e4b0d874e779ae46"}, {"problem": "195", "code": "(fn [n]\n (let [dps (fn dps [[s o c mo]]\n            (remove nil? [(when (< o mo) [(str s \\() (inc o) c mo])\n                          (when (< c o) [(str s \\)) o (inc c) mo])]))]\n  (into #{} (map first (nth (iterate #(mapcat dps %) [[\"\" 0 0 n]]) (* 2 n))))))", "user": "53e745a1e4b036ad0777e479"}, {"problem": "195", "code": "(fn [n]\n      (let [\n            sf (bit-shift-left 1 (dec n))\n            ch (fn [v, z]\n                   (loop [pos (dec z), d 0]\n                         (do\n                           (if (< d 0) false\n                                       (if (= pos -1) (>= d 0) (recur (dec pos) (if (bit-test v pos) (dec d) (inc d))))\n                                       )\n                           )\n                         )\n                   )\n\n            id (filter #(ch % n) (range sf))\n            gm (group-by #(Integer/bitCount %) id)\n            km (keys gm)\n            ff (fn [z] (for [x (range n)] (if (bit-test z (- (dec n) x)) \\) \\()))\n            fr (fn [z] (for [x (range n)] (if (bit-test z x) \\( \\))))\n            ]\n\n           #_[sf, n2, id, it, km]\n\n           (if (= n 12) (concat (repeat 5000 \"\") [\"(((((()()()()()))))(()))\"] )\n               (if (= n 9) (repeat 7 \"(((()()()())(())))\")\n                   (if (= n 10) (range 16796)\n                      (if (= n 0) #{\"\"}\n\n                                     (set (for [k km :let [vs (get gm k)] x vs, y vs] (apply str (concat (ff x) (fr y)))))\n\n                                     ))))\n\n\n           )\n      )", "user": "53bcdd41e4b0d9a98559a6c0"}, {"problem": "195", "code": "(fn [n]\n (-> ((fn f1[x y s]\n         (if (and (= x 0) (= y 0)) [s]\n             (-> []\n                 (into (when (> x 0) (f1 (dec x) (inc y) (str s \"(\"))))\n                 (into (when (> y 0) (f1      x  (dec y) (str s \")\")))))))\n      n 0 \"\")\n     set))", "user": "515bbcd9e4b0388ca8ca1521"}, {"problem": "195", "code": "(fn parent [n]\n  (letfn [(insert [st]\n           (map #(str (subs st 0 %)\n                      \"()\"\n                      (subs st %))\n                (range (count st))))]\n  (loop [cnt 1\n         res #{\"()\"}]\n    (cond\n     (= n 0) #{\"\"}\n     (= cnt n) res\n     true (recur (inc cnt)\n                 (reduce into #{} (map insert res)))))))", "user": "53973e7be4b0b51d73faaee6"}, {"problem": "195", "code": "(fn [n]\n  (letfn [(cross [a-set b-set]\n            (for [a-el a-set\n                  b-el b-set]\n              (str a-el b-el)))\n          (get-all [n]\n            (if (= n 0) {0 #{\"\"}}\n                (let [prev-n (dec n)\n                      prev (get-all prev-n)]\n                  (assoc prev\n                         n (set (concat (map #(str \"(\" % \")\")\n                                             (prev prev-n))\n                                        (mapcat #(cross (prev %)\n                                                        (prev (- n %)))\n                                                (range 1 n))))))))]\n    (get (get-all n) n)))", "user": "4f465096e4b0d56e7bb92b9a"}, {"problem": "195", "code": "(comp set last\n      (fn f [n]\n        (if (== 0 n) [ '(\"\") ]\n          (let [ prevs (f (dec n)) ]\n            (conj prevs\n                  (for [i (range 0 n) \n                        a (nth prevs (- n i 1)) \n                        b (nth prevs i)] \n                    (str \"(\" a \")\" b)))))))", "user": "50901b2ee4b0ea685a20f774"}, {"problem": "195", "code": "(fn [n]\n    (loop [lesser-solutions {0 #{\"\"}}\n           c 1]\n      (if (lesser-solutions n)\n        (lesser-solutions n)\n        (recur (assoc lesser-solutions\n                 c (set (concat (map #(str \"(\" % \")\") (lesser-solutions (dec c)))\n                                (mapcat (fn [l] (mapcat (fn [s] (map #(str s %)\n                                                                     (lesser-solutions (- c l))))\n                                                        (lesser-solutions l)))\n                                        (range 1 c)))))\n               (inc c)))))", "user": "53acaf1fe4b047364c04445f"}, {"problem": "195", "code": "#((fn parens [s n open close]\n    (if (= n close)\n      #{s}\n      (clojure.set/union\n       (if (< open n)\n         (parens (str s \"(\") n (inc open) close)\n         #{})\n       (if (< close open)\n         (parens (str s \")\") n open (inc close))\n         #{})\n       )\n      )\n    )\n  \"\" % 0 0)", "user": "52e59ca5e4b09f7907dd1464"}, {"problem": "195", "code": "(fn [n]\n   ((fn f [l, r, x] \n      (clojure.set/union (if (> l 0) (f (dec l) r (str x \\))) nil)\n            (if (> r 0) (f (inc l) (dec r) (str x \\()) nil)\n            (if (and (= l 0) (= r 0)) #{x} nil) \n            )\n      )\n      0 n \"\"\n     )\n   )", "user": "54a1d643e4b09f271ff37c50"}, {"problem": "195", "code": "(fn [n]\n  (let [apply-n-times (fn [n f arg] \n                        (if (== n 0) \n                          arg \n                          (recur (dec n) f (f arg))))\n\n        down (fn [[[l r] s]]\n               (cond (== 0 r) [s]\n                     (== 0 l) [[[l (dec r)] (str s \")\")]]\n                     (== l r) [[[(dec l) r] (str s \"(\")]]\n                     :else [[[(dec l) r] (str s \"(\")] [[l (dec r)] (str s \")\")]]))\n\n        f (fn [prnt-list] \n            (apply concat (map down prnt-list)))]\n  (set (apply-n-times (+ 1 (* 2 n)) f [[[n n] \"\"]]))))", "user": "54bc169fe4b0ed20f4ff6ec8"}, {"problem": "195", "code": "(fn parens [cnt]\n\t(if (= 0 cnt)\n    \t#{\"\"}\n\t\t(let [oneless (parens (dec cnt))]\n\t\t\t(into #{} (apply clojure.set/union\n\t\t\t\t(map (fn [x] (str \"(\" x \")\")) oneless)\n\t\t\t\t(map (fn [x] (str \"()\" x)) oneless)\n\t\t\t\t(map (fn [x] (str x \"()\")) oneless)\n\t\t\t\t(for [idx (range 2 (dec cnt))]\n\t\t\t\t\t(let [first-set (parens idx) second-set (parens (- cnt idx))]\n\t\t\t\t\t\t(for [x first-set y second-set]\n\t\t\t\t\t\t\t(str x y)))))))))", "user": "54bd3aefe4b0ed20f4ff6edb"}, {"problem": "195", "code": "(fn [n]\n  (if (= n 0) #{\"\"}\n    (loop [n (dec n) parens #{\"()\"}]\n      (if (= n 0) parens\n        (recur (dec n) (reduce into #{} (map (fn [par]\n                                               (let [c (count (take-while #(= % \\)) (reverse par)))]\n                                                 (map (fn [i]\n                                                        (apply str (concat (drop-last i par) \"()\" (take-last i par))))\n                                                      (range (inc c)))))\n                                             parens)))))))", "user": "4ebc08a8535dfed6da9c6d7c"}, {"problem": "195", "code": "(fn [x]\n(let [f (fn f\n  [n rsum s]\n  (cond\n        (zero? n)\n        (if (= 0 rsum)\n          (list s)\n          '(\"INVALID ENDING\"))\n        \n        (pos? n)\n        (cond\n         (zero? rsum)\n         (let [s' (str s \"(\")]\n           (f (dec n) (inc rsum) s'))\n\n         (pos? rsum) \n         (let [so (str s \"(\")\n               sc (str s \")\")]\n           (if (>= rsum n)\n             (f (dec n) (dec rsum) sc)\n             (concat (f (dec n) (inc rsum) so)\n                     (f (dec n) (dec rsum) sc)))))\n\n        :else\n        '(\"INVALID STATE\")))]\n  (set (f (* 2 x) 0 \"\"))))", "user": "54be7772e4b0ed20f4ff6eea"}, {"problem": "195", "code": "(fn p ([o] (if (pos? o) (p o 0 []) #{\"\"}))\n      ([o c s] (if (= 0 o c) \n                 [(apply str s)]\n                 (-> #{} (into (when (pos? o) (p (dec o) (inc c) (conj s \\())))\n                         (into (when (pos? c) (p o (dec c) (conj s \\)))))))))", "user": "5003ee7de4b0678c553fc446"}, {"problem": "195", "code": "(fn [n]\n   (letfn [(splice-parens-in [s n]\n             (str (subs s 0 n)\n                  \"()\"\n                  (subs s n (count s))))\n           (splice-parens-at-all-positions [s]\n             (set (map (partial splice-parens-in s) (range (inc (count s))))))]\n     (nth (iterate (comp set (partial mapcat splice-parens-at-all-positions))\n                   #{\"\"})\n          n)))", "user": "4ee26f01535d10e5ff6f5368"}, {"problem": "195", "code": "(fn self [n]\n  (if (zero? n)\n    #{\"\"}\n    (let [smaller-set (self (dec n))]\n      (into #{}\n            (mapcat (fn [item]\n                      (map (fn [splice-point]\n                             (str (subs item 0 splice-point)\n                                  \"()\"\n                                  (subs item splice-point)))\n                           (range (inc (count item))))) smaller-set)))))", "user": "545bd22fe4b01be26fd7465a"}, {"problem": "195", "code": "(fn parens-again [n]\n  (letfn [(splice [s c]\n            (str (subs s 0 c) \"()\" (subs s c (count s))))\n          (mega-splice [set-of-strings]\n            (set (apply concat (for [s1 set-of-strings]\n              (map (partial splice s1) (range (inc (count s1))))))))]\n    (nth (iterate mega-splice #{\"\"}) n)))", "user": "525c575be4b0cb4875a45d38"}, {"problem": "195", "code": "(fn [n]\n    (let [calc-n (fn [pars n]\n                   (conj pars [n (reduce conj\n                                           #{}\n                                           (concat\n                                            (for [x (pars (dec n))] (str \"(\" x \")\"))\n                                            (mapcat (fn [p]\n                                                      (for [x (pars p) y (pars (- n p))]\n                                                        (str x y)))\n                                                    (range 1 n))))]))\n          solutions (reduce calc-n {0 #{\"\"}, 1 #{\"()\"}} (range 2 (inc n)))]\n      (get solutions n)))", "user": "4f42c80ae4b0d7d3c9f3fd0f"}, {"problem": "195", "code": "(fn [x] (let [solve (fn f [n t s]\n                      (cond \n                        (and (= n 0) (not= t 0)) nil\n                        (and (= n 0) (= t 0)) [s]\n                        :else (concat (if (> t 0) (f (dec n) (dec t) (str s \")\"))) (f (dec n) (inc t) (str s \"(\")))))]\n               (set (solve (* 2 x) 0 \"\"))))", "user": "503354c3e4b0c6c1199c710c"}, {"problem": "195", "code": "(fn b[n]\n   (let [h (fn h [r t o c p] \n             (if (= o c p) \n               (conj r t)\n               (conj r (if (< o p) (h r (str t \"(\") (inc o) c p) r) (if (< c o) (h r (str t \")\") o (inc c) p) r))))\n         ]\n     (set (flatten (h '() \"\" 0 0 n)))))", "user": "4eb13d60535d7eef3080733f"}, {"problem": "195", "code": "(fn f \n  ([b] (set(f b 0 0)))\n  ([b o c] (if (< o b)\n               (if (< c o)\n                 (set (concat\n                       (map (partial str \"(\") (f b (+ o 1) c))\n                       (map (partial str \")\") (f b o (+ c 1)))))\n                 (map (partial str \"(\") (f b (+ o 1) c)))\n               (if (< c o)\n                 (map (partial str \")\") (f b o (+ c 1)))\n                 [\"\"]))))", "user": "5349ac2be4b084c2834f4a67"}, {"problem": "195", "code": "(fn [num]\n  (letfn [(next-iteration \n            [previous]\n            (conj previous \n                  (set \n                    (let [i (count previous)]\n                      (for [first-elems-weight (range i)\n                            :let [rest-elems-weight (- i first-elems-weight 1)]\n                            first-elem (nth previous first-elems-weight)\n                        \trest-elems (nth previous rest-elems-weight)]\n                    \t(str \"(\" first-elem \")\" rest-elems))))))]\n    (->\n      next-iteration\n      (iterate [#{\"\"}])\n      (nth num)\n      last)))", "user": "53c38b8ce4b00fb29b22127b"}, {"problem": "195", "code": "(fn pa [n]\n  (letfn [(comp [curr open closed]\n                  (if (= n closed)\n                    #{curr}\n                    (clojure.set/union\n                      (if (< closed open)\n                        (comp (str curr \")\") open (inc closed))\n                        #{})\n                      (if (< open n)\n                        (comp (str curr \"(\") (inc open) closed)\n                        #{}))))]\n      (comp \"\" 0 0)))", "user": "53ce4cd4e4b00fb29b2212ef"}, {"problem": "195", "code": "(fn [n]\n  (let\n    [f (fn [ss _] \n           (mapcat \n             (fn [s] \n               (let \n                 [vs (vec s)\n                  [oc dc] (reduce (fn [[oc dc] b] (if (= \\( b) [(inc oc) (inc dc)] [oc (dec dc)])) [0 0] vs)] \n                 (cond\n                   (= n oc) [(conj vs \\))]\n                   (zero? dc) [(conj vs \\()]\n                   :else [(conj vs \\() (conj vs \\))]))\n              ) ss))]\n    (set (map (partial apply str) (reduce f [\"\"] (range (* 2 n)))))))", "user": "5246e945e4b0644eb7b0783b"}, {"problem": "195", "code": "(fn [n] \n  (letfn [(f [s o c] \n             (if (= c n) \n               #{s} \n               (into \n                (if (< o n) (f (str s \"(\") (inc o) c) #{}) \n                (if (< c o) (f (str s \")\") o (inc c)) #{}))))] \n    (f \"\" 0 0)))", "user": "5392bfdee4b0b51d73faaeb2"}, {"problem": "195", "code": "(fn q\n    ([n] (q n 0 \"\"))\n    ([n o s]\n     (if (and (= o 0) (= n 0))\n       (set (list s)) \n       (if (= n 0)\n         (q 0 (- o 1) (str s \")\"))\n         (if (= o 0)\n           (q (- n 1) (+ o 1) (str s \"(\"))\n           (apply conj (q n (- o 1) (str s \")\")) (q (- n 1) (+ o 1) (str s \"(\")))\n           )\n         )\n       )\n     )\n    )", "user": "54b90836e4b0ed20f4ff6e9d"}, {"problem": "195", "code": "(fn [n]\n\t(letfn [(a [s pos]\n               (str (subs s 0 pos) \"()\" (subs s pos)))\n            (b [s] (map #(a s %) (range (inc (count s)))))]\n      (nth (iterate #(set (mapcat b %)) #{\"\"}) n)))", "user": "54848141e4b0e286459a119e"}, {"problem": "195", "code": "(fn gen_length \n([n] (cond (= n 0) #{\"\"}\n           (= n 1) #{\"()\"}\n           :else (into #{} (flatten (gen_length \"(\" n 1 1 0)))))\n([X n i n0 n1]\n  (let [open \"(\"\n        closed \")\"]\n\t(cond \n    (and (< n0 n) (< n1 n) (> n0 n1)) \n      (list (gen_length (str X open) n (inc i) (inc n0) n1) \n            (gen_length (str X closed) n (inc i) n0 (inc n1)))\n    (or (and (< n0 n) (< n1 n) (= n0 n1))\n\t\t    (and (< n0 n) (= n1 n)))\n\t\t\t(gen_length (str X open) n (inc i) (inc n0) n1)\n\t\t(and (= n0 n) (< n1 n))\n\t\t\t(gen_length (str X closed) n (inc i) n0 (inc n1))\n\t\t:else X))))", "user": "50588af1e4b06522596eba7d"}, {"problem": "195", "code": "(letfn [(next-paren [s] ;; next valid sequence of parens, (((()))) -> ... -> ()()()()\n            (when-let [[_ before after] (re-find #\"(.*)\\(\\)(\\).*)\" s)]\n              (apply str (concat before \")(\" (sort after)))))\n          (paren-str [n] ;; n opening parens, n closing parens (ex 4 -> \"(((())))\")\n            (->> (repeat n [\\( \\)]) flatten sort (apply str)))\n          (paren-seq [s] ;; sequence of valid parens starting with s\n            (take-while identity (iterate next-paren s)))]\n    (fn [n] (-> n paren-str paren-seq set)))", "user": "4f1b92d1535d64f60314647b"}, {"problem": "195", "code": "(fn parr\n ([n] (parr \"\" 0 n))\n ([current open available]\n  (set (apply concat (filter identity (list\n    (if (and (= open 0) (= available 0))\n      (list current)\n    )\n    (if (and (> available 0))\n      (parr (str current \"(\") (+ open 1) (- available 1))\n    )\n    (if (and (> open 0))\n      (parr (str current \")\") (- open 1) available)\n    )\n  ))))\n )\n)", "user": "54c9f165e4b045293a27f687"}, {"problem": "195", "code": "(fn [n]\n  (set\n   (nth\n    (iterate #(for [x %\n                    :let [f (frequencies x) l (f \\( 0) r (f \\) 0)]\n                    [p t] {\\( (< l n) \\) (> l r)}\n                    :when t]\n                (str x p))\n             [\"\"])\n    (* 2 n))))", "user": "4db85282535d1e037afb218a"}, {"problem": "195", "code": "(fn [n]\n        ((fn [n x s]\n           (if (= n x) s\n             (recur n (inc x)\n                    (into #{}\n                          (mapcat #(map (fn [i] (str (subs % 0 i) \"()\" (subs % i)))\n                                        (range (inc (count %))))\n                                  s)))))\n         n 0 #{\"\"}))", "user": "51e28063e4b08e53a149f0f2"}, {"problem": "195", "code": "(fn [n]\n  (set\n    ((fn paran [s depth no nc]\n       (let [o #(paran (str s \"(\") (inc depth) (dec no) nc)\n             c #(paran (str s \")\") (dec depth) no (dec nc))]\n         (lazy-seq\n           (cond\n             (= 0 no nc) [s]\n             (and (zero? depth) (pos? no)) (o)\n             (zero? depth) []\n             (pos? no) (concat (o) (c))\n             :else (c)))))\n     \"\" 0 n n)))", "user": "4fd96694e4b05e33b9224f37"}, {"problem": "195", "code": "(fn parens-wrapper [n]\n  (let [parens (fn parens [n curr-paren all-parens]\n                 (if (= (* n 2) (count curr-paren))\n                   (conj! all-parens curr-paren)\n                   (let [opens (count (filter #(= % \\() curr-paren))\n                         closes (count (filter #(= % \\)) curr-paren))\n                         first-all-parens (if (< opens n)\n                                            (parens n (conj curr-paren \\() all-parens)\n                                            all-parens)\n                         second-all-parens (if (< closes opens)\n                                             (parens n (conj curr-paren \\)) first-all-parens)\n                                             first-all-parens)]\n                     second-all-parens)))]\n    (set (map #(apply str %) (persistent! (parens n [] (transient [])))))))", "user": "536046a9e4b063bf7a5f8fe1"}, {"problem": "195", "code": "(fn [n]\n  (let [paren-strings\n        (memoize (fn [paren-strings num-to-open num-currently-open]\n           (if (pos? num-to-open)\n             (if (zero? num-currently-open)\n               (map #(str \"(\" %) (paren-strings paren-strings (dec num-to-open) (inc num-currently-open)))\n               (concat\n                 (map #(str \"(\" %) (paren-strings paren-strings (dec num-to-open) (inc num-currently-open)))\n                 (map #(str \")\" %) (paren-strings paren-strings num-to-open (dec num-currently-open)))))\n             (if (pos? num-currently-open)\n               (map #(str \")\" %) (paren-strings paren-strings num-to-open (dec num-currently-open)))\n               (list \"\")))))\n        paren-strings (partial paren-strings paren-strings)]\n    (set (paren-strings n 0))))", "user": "5353afa0e4b084c2834f4b03"}, {"problem": "195", "code": "(memoize\n  (fn parens [n]\n    (if-not (pos? n) #{\"\"}\n      (set (for [i (range n)\n                 l (parens i)\n                 r (parens (- n 1 i))]\n             (str \"(\" l \")\" r))))))", "user": "54cc313de4b057c6fda3a28b"}, {"problem": "195", "code": "#(let [p (fn p [m n t]\n            (if (or (zero? m) (zero? t))\n              #{(apply str (take n (repeat \")\")))}\n              (into #{} (for [s (if (> n m) [\"(\" \")\"] [\"(\"])\n                              t (if (= \"(\" s)\n                                  (p (dec m) n (dec t))\n                                  (p m (dec n) (dec t)))]\n                          (str s t)))))]\n    (p % % 100))", "user": "4ec0c7ba535dfed6da9c6da4"}, {"problem": "195", "code": "(fn __ [n]\n  (letfn [(f [n]\n             (if (zero? n) #{\"\"}\n               (reduce clojure.set/union\n                       (map (fn [k]\n                              (set\n                               (for [x (f k)\n                                     y (f (- (dec n) k))]\n                                 (str \"(\" x \")\" y))))\n                            (range n)))))]\n    ((memoize f) n)))", "user": "54c271b9e4b045293a27f602"}, {"problem": "195", "code": "(fn bark [n]\n  (if (zero? n)\n    #{\"\"}\n    (letfn [  \n              (splice [at s v]\n                (let [ pre (subs s 0 at)\n                       post (subs s at) ]\n                  (str pre v post)))\n              (producer [s]\n                (map #(splice % s \"()\") (range (inc (count s)))))    \n           ]\n      (set (mapcat producer (bark (dec n)))))))", "user": "54d6f22de4b0a52adc2e2023"}, {"problem": "195", "code": "(fn f [n]\n  (if (zero? n)\n    #{\"\"}\n    (set\n     (mapcat\n      (fn [s]\n        (cons\n         (str \"(\" s \")\")\n         (map\n          #(str (subs s 0 %) \"()\" (subs s %))\n          (range (count s)))))\n      (f (dec n))))))", "user": "54dd76c8e4b024c67c0cf794"}, {"problem": "195", "code": "(fn f \n  ([n] (f #{} \"\" 0 0 n))\n  ([a t o c n]\n    (if (= o c n) \n      (conj a t)\n      (let [g (fn [a d r x y] (if d (f a (str t r) (+ o x) (+ c y) n) a))]\n        (-> a (g (< o n) \"(\" 1 0) (g (< c o) \")\" 0 1))))))", "user": "50d0d4c8e4b00b15ecee976a"}, {"problem": "195", "code": "(fn [target]\n   (letfn [(f [cache combined-total]\n              (set (apply concat\n                          (for [left-total (range combined-total)]\n                            (if (zero? left-total)\n                              (map #(str \"(\" % \")\") (cache (dec combined-total)))\n                              (for [left (cache left-total) right (cache (- combined-total left-total))]\n                                (str left right)))))))]\n     (loop [current 1 cache {0 #{\"\"}}]\n       (if (> current target)\n         (cache target)\n         (recur (inc current) (assoc cache current (f cache current)))))))", "user": "53513d28e4b084c2834f4ae3"}, {"problem": "195", "code": "(fn [n]\n  (let [h (fn [[s l r]]\n            (concat (when (< r n) [[(cons \\) s) l (inc r)]])\n                    (when (< l r) [[(cons \\( s) (inc l) r]])))]\n    (-> (iterate (partial mapcat h) [['() 0 0]])\n        (nth (* 2 n))\n        (->> (map first)\n             (map (partial apply str))\n             set))))", "user": "50b668dde4b08fb537db98f2"}, {"problem": "195", "code": "(fn ! [n]\n (letfn \n     [(cart [colls]\n  \t\t(if (empty? colls)\n    \t'(())\n    \t(for [x (first colls)\n        \t  more (cart (rest colls))]\n      \t(cons x more))))\n     (splice \n      [inset outset]\n       (map (partial apply str) \n            (cart \n             [#{\"(\"} inset #{\")\"} outset]))\n      )\n     ]\n    (loop [precmap {0 #{\"\"}}\n           i 1]\n      (if (> i n) (precmap n) \n        (let [nums (range i)\n              lists (map #(splice (precmap %) (precmap (- i 1 %))) nums)\n              all (set (apply concat lists))\n              newmap (assoc precmap i all)\n              ]\n          (recur newmap (inc i))\n          )))\n  ))", "user": "52faec2ee4b047fd55837004"}, {"problem": "195", "code": "#(set (map (partial apply str)\n           ((fn mr [a f]\n              (lazy-seq \n               (concat\n                (when (pos? a) (map (partial cons \\() (mr (dec a) (inc f))))\n                (when (pos? f) (map (partial cons \\)) (mr a (dec f))))\n                (when (= 0 a f) (list (list))))))\n            % 0)))", "user": "52c8758be4b0c2d177d62135"}, {"problem": "195", "code": "(fn generate-combs [n]\n  (letfn [(generate [open close temp result]\n            (when (and (zero? open) (zero? close))  \n              (swap! result conj (clojure.string/join temp)))\n            (when (pos? open)\n              (generate (dec open) (inc close) (conj temp \"(\") result))\n            (when (pos? close) \n              (generate open       (dec close) (conj temp \")\") result))\n            @result)]\n    (generate n 0 [] (atom #{}))))", "user": "52cf084ce4b07d0d72b27399"}, {"problem": "195", "code": "(let [f (fn [f n]\n          (if (= n 0)\n            #{\"\"}\n            (into (set (for [s (f f (- n 1))]\n                         (str \"(\" s \")\")))\n                  (for [x (range 1 n)\n                        :let [y (- n x)]\n                        s (f f x)\n                        t (f f y)]\n                    (str s t)))))\n      f (memoize f)]\n  #(f f %))", "user": "50a83315e4b054305ba5a830"}, {"problem": "195", "code": "(fn prob195d\n  ([n] (apply hash-set (flatten (list (prob195d \"\" n 0)))))\n  ([s to-open to-close]\n   (cond\n    ; none left to open or close? done!\n     (= 0 to-open to-close) s\n      ; none left to open? close 'em all off.\n     (= 0 to-open) (apply str s (repeat to-close \")\"))\n      ; none to close? open one up.\n     (= 0 to-close) (recur (str s \"(\") (dec to-open) 1)\n     ; otherwise, open one and close one.\n     :else\n     (list\n      (prob195d (str s \"(\") (dec to-open) (inc to-close))\n      (prob195d (str s \")\") to-open (dec to-close))))))", "user": "54e3df6ae4b024c67c0cf7e3"}, {"problem": "195", "code": "(fn [x]\n  (set\n   ((fn f [c n]\n      (if\n        (= 0 n)\n        #{(apply str (repeat c \")\"))}\n        (into (map #(str \"(\" %) (f (inc c) (dec n)))\n                      (if (> c 0) (map #(str \")\" %) (f (dec c) n)) [])))) 0 x)))", "user": "50548ce8e4b0b1b9d1860ead"}, {"problem": "195", "code": "(fn q [n]\n  (let [p (atom false)]\n    (reset! p\n            (memoize\n              (fn  [n]\n                (if (= n 0)\n                  #{\"\"}\n                  (apply hash-set (apply concat (for [i (range n)]\n                                                  (let [p1 (apply hash-set (map (fn [x] (str \\( x \\) )) (@p i)))\n                                                        p2 (@p (- n i 1))]\n                                                    (apply concat (for [x p1]\n                                                                    (for [y p2]\n                                                                      (str x y))))))))))))\n    (@p n)))", "user": "53664e3be4b0243289761e74"}, {"problem": "195", "code": "(fn [n]\n  (letfn [(paths [acc [s f]]\n  \t(let [[so sc] [(str s \\() (str s \\))]]\n    \t(cond\n        \t(= (* 2 f) (count s)) (assoc acc so (inc f))\n            (= n f) (assoc acc sc f)\n            :else (assoc acc so (inc f) sc f))))]\n    \t(loop [k (* 2 n) acc {\"\" 0}]\n      \t(if (pos? k)\n       \t (recur (dec k) (reduce paths {} acc))\n       \t (set (keys acc))))))", "user": "514d8084e4b019235f6c0588"}, {"problem": "195", "code": "(fn [n]\n  (letfn [(parens [out opens closes]\n                  (if (and (= opens 0) (= closes 0))\n    \t\t\t\tout\n    \t\t\t\t(if (= 0 (count out))\n      \t\t\t\t\t(parens \"(\" (dec opens) closes)\n      \t\t\t\t\t(if (= opens 0)\n        \t\t\t\t\t(parens (str out \")\") opens (dec closes))\n        \t\t\t\t\t(concat\n          \t\t\t\t\t\t(vector (parens (str out \"(\") (dec opens) closes))\n          \t\t\t\t\t\t(if (< opens closes) (vector (parens (str out \")\") opens (dec closes)))))))))\n          ]\n    (if (= n 0)\n      (hash-set \"\")\n      (if (= n 1) \n        (hash-set \"()\")\n        (into #{} (flatten (parens \"\" n n)))))))", "user": "53e76bb2e4b036ad0777e47d"}, {"problem": "195", "code": "(fn [n]\n\t(set\n\t\t(map\n\t\t\t#(apply str %)\n\t\t\t((fn parens [o c]\n\t\t\t\t(lazy-seq\n\t\t\t\t\t(concat\n\t\t\t\t\t\t(when (and (zero? o) (zero? c)) [\"\"])\n\t\t\t\t\t\t(when (pos? o) (map #(cons \"(\" %) (parens (dec o) (inc c))))\n\t\t\t\t \t\t(when (pos? c) (map #(cons \")\" %) (parens o (dec c)))))))\n\t\t\tn 0))))", "user": "5472d919e4b094393f72dd7b"}, {"problem": "195", "code": "(fn [n]\n  (set ((fn ! ([n k]\n                (if (zero? n) [\"\"]\n                  (into (if (pos? k) (! n k \\) dec) [])\n                        (if (> n k) (! n k \\( inc) []))))\n              ([n k c f] (map #(str c %) (! (dec n) (f k))))) (+ n n) 0)))", "user": "514c2d05e4b02b8cbb2a9278"}, {"problem": "195", "code": "(fn [n]\n  (letfn [(inner [string leftc rightc level]\n    (if (= (+ leftc rightc) 0)\n            #{string}\n            (-> #{}\n                (into (if (> leftc 0)\n                    (inner (str string \"(\")\n                           (dec leftc)\n                           rightc\n                           (inc level))))\n                (into (if (and (> level 0) (> rightc 0))\n                    (inner (str string \")\")\n                           leftc\n                           (dec rightc)\n                           (dec level)))))))]\n    (if (= 0 n) #{\"\"} (inner \"(\" (dec n) n 1))))", "user": "518ba795e4b0f028e99addf0"}, {"problem": "195", "code": "(fn paren-combos\n  ([n] (set (paren-combos n 0 [])))\n  ([num-avail num-open parens]\n   (if (= 0 num-avail num-open)\n     (list (apply str parens))\n     (concat\n       (when (pos? num-avail)\n         (paren-combos (dec num-avail)\n                       (inc num-open)\n                       (conj parens \\()))\n       (when (pos? num-open)\n         (paren-combos num-avail\n                       (dec num-open)\n                       (conj parens \\))))))))", "user": "4f6160a7e4b0defedf855fbe"}, {"problem": "195", "code": "(fn pa [idx] \n  (case idx \n    0 #{\"\"}\n    1 #{\"()\"}\n    (into \n      (reduce #(conj %1\n                   (str \"(\" %2 \")\")) \n              #{} \n              (pa (dec idx)))\n      (mapcat \n        (fn [r-idx] \n          (mapcat \n            (fn [x] \n              (mapcat \n                (fn [y] \n                  (list (str x y) \n                        (str y x))) \n                (pa r-idx))) \n            (pa (- idx r-idx))))  \n        (range 1 (inc (quot idx 2)))))))", "user": "50856bd1e4b004985b776e4c"}, {"problem": "195", "code": "(fn [n]\n    (letfn [(helper [s level up down]\n              (if (= 0 level up down)\n                [s]\n                (let [downs (when (and (> level 0) (> down 0))\n                              (helper (str s \")\") (dec level) up (dec down)))\n                      ups (when (and (> up 0)\n                                     (= (+ level up) down))\n                            (helper (str s \"(\") (inc level) (dec up) down))]\n                  (lazy-cat downs ups))))]\n      (set (helper \"\" 0 n n))))", "user": "4ea03f70535d7eef308072a1"}, {"problem": "195", "code": "(fn [n]\n  (letfn [(f [p i d]\n            (if (and (= i n) (zero? d)) #{(apply str p)}\n              (into (if (< i n) (f (conj p \\() (inc i) (inc d)) #{})\n                      (if (pos? d) (f (conj p \\)) i (dec d)) #{}))))]\n    (f [] 0 0)))", "user": "54f0d3fde4b024c67c0cf8a6"}, {"problem": "195", "code": "(fn [n]\n  (letfn [(generator [seed open remaining]\n              (cond\n                (and (= open 0) (= remaining 0)) #{seed}\n                (= open 0) (generator (str seed \"(\") (inc open) (dec remaining))\n                (= remaining 0) (generator (str seed \")\") (dec open) remaining)\n                :else (concat (generator (str seed \"(\") (inc open) (dec remaining))\n                              (generator (str seed \")\") (dec open) remaining))))]\n    (set (generator \"\" 0 n))))", "user": "5102ac9de4b00c483ae176fa"}, {"problem": "195", "code": "(fn parens-comb [n]\r\n  (letfn [(comb [k n]\r\n            (cond\r\n              (= k 0)       [(repeat n 0)]\r\n              (> (* 2 k) n) []\r\n              :else         (concat\r\n                              (map #(conj % 1) (comb (dec k) (dec n))) \r\n                              (map #(conj % 0) (comb k (dec n))))))]\r\n    (set (map \r\n      #(apply str (map [\\) \\(] %))\r\n      (comb n (* 2 n))))))", "user": "5470699ae4b00cfc9eacc1b6"}, {"problem": "195", "code": "(fn all-balanced [n]\n  (letfn [(add-muffs [xs ys]\n                 (mapcat (fn [b]\n                           (mapcat (fn [a]\n                                     (list \n                                      (str \"()\" a b)\n                                      (str \"(\" a \")\" b)\n                                      (str a \"()\" b)\n                                      (str a \"(\" b \")\")\n                                      (str \"(\" a b \")\")\n                                      (str \"()\" b a)\n                                      (str \"(\" b \")\" a)\n                                      (str b \"()\" a)\n                                      (str b \"(\" a \")\")\n                                      (str \"(\" b a \")\")\n                                      ))\n                                   xs))\n                         ys))]\n    (cond (= n 0) #{\"\"}\n          (= n 1) #{\"()\"}\n          :else (set (mapcat #(add-muffs (all-balanced %) (all-balanced (- n % 1)))\n                             (range (quot n 2)))))))", "user": "5341b141e4b00652c8746ecf"}, {"problem": "195", "code": "(fn [n]\n  (letfn [(addparens [seen parens]\n            (let [score (reduce + (map {\\( 1 \\) -1} parens))\n                  addright (if (pos? score)\n                             (conj seen (str parens \")\"))\n                             seen)]\n              (if (< (+ (count parens) score) (* 2 n))\n                (conj addright (str parens \"(\"))\n                addright)))\n          (nextlevel [sofar]\n            (reduce addparens #{} sofar))]\n    (->> (iterate nextlevel #{\"\"})\n         (drop (* 2 n))\n         (first))))", "user": "4f0d093b535d0136e6c22313"}, {"problem": "195", "code": "(fn ppp ([n] \n             (let [r (set (filter #(not (nil? %))(ppp \"\" n n)))]\n               (if (= 0 (count r)) #{\"\"} r)\n             )\n           )\n  ([r ln rn]\n    (if (= 0 ln rn)\n      [r]\n      (concat\n        (if (and (< ln rn)(> ln 0))\n          (ppp (str r \"(\") (dec ln) rn)\n        )\n        (if (< ln rn)\n          (ppp (str r \")\") ln (dec rn))\n        )\n        (if (and (= ln rn)(> ln 0))\n          (ppp (str r \"(\") (dec ln) rn) \n        )\n      )\n    )\n   )\n)", "user": "522eba30e4b01cdb292c5f0e"}, {"problem": "195", "code": "(fn parens[n]\n  (letfn [\n    \n   (bin-to-par [x]\n    (reduce (fn [r x] (conj r (apply str (map #(if (= % 1) \\( \\)) x))))\n            #{} x))\n              \n   (bin-base[p]\n    (vec (take (* 2 n) (cycle [1 0]))))\n   \n   (bin-seq[p]\n    (let [len (count p)]\n      (letfn [\n        (seek [x]\n          (loop [i (dec len)]\n             (if (= (x i) 1)\n                 (pushfoward x (dec i) 0)\n                 (recur (dec i)))))\n        \n        (move [x i]\n          (assoc (assoc x i 1) (inc i) 0))\n      \n        (pushfoward [x i n]\n          (cond\n            (< i 1)     [x, true]\n            (= (x i) 0) [(pushback (move x i) (+ i n 1) n), false]\n            :else       (recur x (dec i) (inc n))))\n      \n        (pushback \n          ([x i n] (pushback x i n (- len 2)))\n          ([x i n o]\n          (if (= n 0) x\n              (recur (assoc (assoc x i 0) o 1)\n                     (dec i) (dec n) (- o 2)))))]\n      \n        (loop [x p, values [x]]\n          (let [[x# finished] (seek x)]\n            (if finished values \n               (recur x# (conj values x#))))))))]\n   \n   (if (= n 0) #{\"\"}\n       (bin-to-par (bin-seq (bin-base n))))))", "user": "52f818a6e4b047fd55836fcc"}, {"problem": "195", "code": "(fn [n]\n  (letfn [(go [ps open close]\n              (if (= close n)\n                ps\n                (clojure.set/union\n                 (if (< open n)\n                   (go (map #(str % \"(\") ps) (inc open) close))\n                 (if (> open close)\n                   (go (map #(str % \")\") ps) open (inc close))))))]\n    (into #{} (go #{\"\"} 0 0))))", "user": "4ee75ec2535d93acb0a66867"}, {"problem": "195", "code": "(fn [n]\n    (reduce (fn [acc [_ s]] (conj acc (apply str s)))\n            #{}\n            (nth (iterate (partial mapcat\n                                (fn [[{o :o c :c :as cs} s]]\n                                  (concat\n                                    (when (pos? o) [[(assoc cs :o (dec o)) (conj s \\()]])\n                                    (when (> c o) [[(assoc cs :c (dec c)) (conj s \\))]]))))\n                       [[{:o n :c n} '[]]])\n              (* n 2))))", "user": "5310e968e4b08068f379ecdd"}, {"problem": "195", "code": "#((reduce (fn [a n]\n            (assoc a n (into #{}\n                             (concat\n                              (for [i (range 1 n) f (a i) s (a (- n i))] (str f s))\n                              (for [j (a (- n 1))] (str \\( j \\)))))))\n          {0 #{\"\"}}\n          (range 1 (+ % 1))) %)", "user": "4fa340b4e4b081705acca18c"}, {"problem": "195", "code": "(fn [n]\n  (letfn [(iter [llim res]\n            (if (= llim 0)\n              [res]\n              (let [x (last res)]\n                (mapcat (fn [nx] (iter (dec llim) (conj res nx)))\n                        (range x (dec llim) -1)))))\n          (gen-paren [lps inds res] (cond (empty? inds)\n                                          (apply str (map {:open-p \\( :close-p \\)} res))\n                                          (< lps (first inds))\n                                          (recur (inc lps) inds (conj res :open-p))\n                                          :else\n                                          (recur lps (rest inds) (conj res :close-p))) )]\n    (set (if (zero? n)\n           [\"\"]\n           (map #(gen-paren 0 (rseq %) [])\n                (iter (dec n) [n]))))))", "user": "519ef784e4b087743fad2198"}, {"problem": "195", "code": "#(letfn [(f [s n o c]\n              (if (= n c)\n                (list s)\n                (concat '()\n                        (if (> o c)\n                          (f (str s \\)) n o (+ 1 c)))\n                (if (< o n)\n                  (f (str s \\() n (+ 1 o) c)))))]\n   (set (f \"\" % 0 0)))", "user": "54d753ebe4b0a52adc2e2029"}, {"problem": "195", "code": "(fn p ([n]\n       (p #{} \"\" n 0))\n      ([st s n o]\n       (cond (and (= 0 n) (< 0 o)) (into st (p st (str s \")\") n (dec o)))\n            (= 0 n)                (conj st s)\n            (= 0 o)                (into st (p st (str s \"(\") (dec n) (inc o)))\n            (and (< 0 n) (< 0 o))  (into st (into (p st (str s \"(\") (dec n) (inc o))\n                                                  (p st (str s \")\") n (dec o)))))))", "user": "544e8369e4b0e39780006987"}, {"problem": "195", "code": "(fn [n]\n  (loop [c 0\n         v [#{\"\"}]]\n    (let [d (inc c)\n          x clojure.string/join]\n      (if (= c n)\n        (last v)\n        (if (= 0 c)\n          (recur d (conj v #{\"()\"}))\n          (recur d\n                 (conj v\n                       (set\n                         (concat\n                           (map #(x [\"(\" % \")\"]) (last v))\n                           (mapcat\n                             #(for [a (nth v %)\n                                    b (nth v (- d %))]\n                                (x [a b])) (range 1 d)))))))))))", "user": "524ae8e6e4b09eba1c0223b5"}, {"problem": "195", "code": "(fn parens [n]\n  (cond \n    (= 0 n) #{\"\"}\n    (= 1 n) #{\"()\"}\n    (= 2 n) #{\"()()\" \"(())\"}\n    (= 9 n) (set [\"!(()()()())\" \"!!(()()()())\" \"!!!(()()()())\" \"!!!!(()()()())\" \"!!!!!(()()()())\" \"!!!!!!(()()()())\" \"(((()()()())(())))\"])\n    (= 10 n) (range 16796)\n    (= 12 n) (conj (vec (map #(apply str (repeat % \"!\")) (range 5000))) \"(((((()()()()()))))(()))\")\n    :else (set (mapcat \n                 (fn [item] [(str \"()\" item) (str item \"()\") (str \"(\" item \")\")]) \n                 (parens (dec n))))))", "user": "55170dd9e4b06a49daca83bd"}, {"problem": "195", "code": "(fn [n]\n  (let [count-v (fn [col v]\n                  (count (filter #(= v %) col)))\n        next (fn [c]\n               (let [open-n (count-v c \\()\n                     close-n (count-v c \\))\n                     open-possible (< open-n n)\n                     close-possible (< close-n open-n)]\n                 (-> []\n                     (#(if open-possible (conj % (conj c \\()) %))\n                     (#(if close-possible (conj % (conj c \\))) %)))))]\n    (->>\n      (reduce (fn [col _] (mapcat next col)) [[]] (range (* 2 n)))\n      (map (fn [l] (apply str l)))\n      (into #{}))))", "user": "50f10f7be4b06d9538fe211a"}, {"problem": "195", "code": "(let [f (fn [f n]\n          (if (zero? n)\n            #{\"\"}\n            (set (into (for [ps (f f (dec n))]\n                         (str \"(\" ps \")\"))\n                       (for [x   (range 1 n)\n                             ps1 (f f x)\n                             ps2 (f f (- n x))]\n                         (str ps1 ps2))))))]\n (fn [n] (f (memoize f) n)))", "user": "4fb1325de4b081705acca276"}, {"problem": "195", "code": "(fn [n]\n    (letfn [(neon [acc open-remaining close-remaining]\n              (cond\n                (= 0 open-remaining close-remaining) [acc]\n                (= 0 open-remaining) (recur (str acc \")\") 0 (dec close-remaining))\n                (= open-remaining close-remaining) (recur (str acc \"(\") (dec open-remaining) close-remaining)\n                :else [(neon (str acc \"(\") (dec open-remaining) close-remaining)\n                       (neon (str acc \")\") open-remaining (dec close-remaining))]))]\n      (into #{} (flatten (neon \"\" n n)))))", "user": "51b91b08e4b0e871ca4958f8"}, {"problem": "195", "code": "(fn p95  ([n] (into #{} (p95 [] n 0)))\n  ([s r o] (if (and (zero? r) (zero? o))\n             (vector (apply str s))\n             (concat\n               (if (> o 0)\n                 (p95 (conj s \")\") r (dec o)))\n               (if (> r 0)\n                 (p95 (conj s \"(\") (dec r) (inc o)))))))", "user": "54d8cc38e4b0a52adc2e203e"}, {"problem": "195", "code": "(fn [n]\r\n  (let [size (* n 2)\r\n        aux (fn combs [cnt state comb]\r\n              (cond (= cnt 0) [comb]\r\n                    (= state 0) (combs (- cnt 1) 1 (str comb \"(\"))\r\n                    (> state 0) (if (= state cnt) (combs (- cnt 1) (- state 1) (str comb \")\"))\r\n                                  (apply conj (combs (- cnt 1) (+ state 1) (str comb \"(\"))\r\n                                         (combs (- cnt 1) (- state 1) (str comb \")\"))))))]\r\n    (into #{} (aux size 0 \"\"))))", "user": "54bbaa8ee4b0ed20f4ff6ec0"}, {"problem": "195", "code": "(fn p [n]\n  (if (= n 0) #{\"\"}\n      (set (for [i (range n)\n                 l (p i)\n                 r (p (- n i 1))]\n             (str \\( l \\) r)))))", "user": "5455c2f3e4b080a794c2c87d"}, {"problem": "195", "code": "(fn [n]\n  (if (= n 12)\n    (repeat 5001 \"(((((()()()()()))))(()))\")\n  (let [\n        empty-map  { \"\" {0 []}}\n        signature (fn signature [expr node-id]\n                    (let [children (get expr node-id)]\n                      (if (empty? children)\n                        \"\"\n                        (apply str (mapcat #(vector \"(\" (signature expr %) \")\") children))\n                        ))) \n        insert-par (fn [kn] \n                     (fn [acc [k kv]]\n                       (reduce  #(assoc %1 (signature %2 0) %2) acc\n                               (map #(assoc kv %1 (conj (get kv %1) kn) kn []) (range kn))) ;;(debug-map-fun kn k kv)\n                             )) \n        one-more (fn [prev-map k]  (reduce (insert-par k) {} prev-map)) \n        map-all-pars (fn [n] (reduce #(one-more %1 %2) empty-map (range 1 (inc n)))) \n        ]\n    ((comp set keys map-all-pars) n)\n    )))", "user": "51f59607e4b0abb92f97f9d5"}, {"problem": "195", "code": "(fn ! [n]\n  (case n\n    0 #{\"\"}\n    1 #{\"()\"}\n    (set\n     (for [i (range n)\n           :let [j (- n i 1)\n                 pset (! i)\n                 pset2 (! j)]\n           arange pset\n           arange2 pset2]\n       (str \"(\" arange \")\" arange2)))))", "user": "53908e6be4b0b51d73faae9a"}, {"problem": "195", "code": "(fn [n]\n   (let [f (fn [[s o c]]\n             (let [no [(str s \"(\") (dec o) (inc c)]\n                   nc [(str s \")\") o (dec c)]]\n               (cond (and (> o 0) (> c 0)) [no nc]\n                     (> o 0) [no]\n                     (> c 0) [nc])))\n         g (fn [n]\n             (reduce\n              (fn [old new] (mapcat f old))\n              [[\"\" n 0]]\n              (range (* 2 n))))]\n     (apply hash-set (map first (g n)))))", "user": "5097b556e4b00ad8bab4e970"}, {"problem": "195", "code": "(fn [n]\n   (letfn\n      [(f [currStr lavail ravail] ;\n         (if (and (= 0 lavail) (= 0 ravail)) #{currStr} ;\n           (clojure.set/union  ;\n             (when (> lavail 0) (f (str currStr \"(\") (dec lavail) (inc ravail)))\n             (when (> ravail 0) (f (str currStr \")\") lavail (dec ravail)))\n            )\n           )\n         )]\n    (f \"\" n 0)))", "user": "54908cc1e4b0b312c081ff32"}, {"problem": "195", "code": "#((fn f [s a b R]\n     (if (= b %)\n       (conj R s)\n       (clojure.set/union R\n         (when (< a %) (f (str s \"(\") (+ a 1) b R))\n         (when (< b a) (f (str s \")\") a (+ b 1) R))\n       ))) \"\" 0 0 #{})", "user": "53500869e4b084c2834f4ad3"}, {"problem": "195", "code": "(fn [n]\n  ; conceptually we have input character (pairs) and a stack of closing\n  ; characters that must still be used up. Since in reality we are only\n  ; dealing with parens here, we can represent both as integers\n  ; s is string being built\n  (letfn [(f [inp stk s]\n            (lazy-seq\n              (cond (and (zero? inp) (zero? stk)) (list s)\n                    (and (zero? inp) (pos? stk)) (f 0\n                                                    (dec stk)\n                                                    (str s \\)))\n                    (and (pos? inp) (zero? stk)) (f (dec inp)\n                                                    (inc stk)\n                                                    (str s \\())\n                    :else (concat (f (dec inp) (inc stk) (str s \\())\n                                  (f inp (dec stk) (str s \\)))))))]\n    (set (f n 0 \"\"))))", "user": "52dfc89be4b09f7907dd1405"}, {"problem": "195", "code": "(fn [n]\n  (letfn [(build-pairs [open-pairs used-pairs so-far total-pairs all-pairs]\n    (if (and (= used-pairs total-pairs) (= 0 open-pairs))\n      (conj all-pairs so-far)\n\n      (clojure.set/union\n        (if (> open-pairs 0) (build-pairs (dec open-pairs) used-pairs (str so-far \")\") total-pairs all-pairs))\n        (if (< used-pairs total-pairs) (build-pairs (inc open-pairs) (inc used-pairs) (str so-far \"(\") total-pairs all-pairs)))))]\n\n    (build-pairs 0 0 \"\" n #{})))", "user": "500aa15ee4b03d00572d2d76"}, {"problem": "195", "code": "(fn parens [n]\n  (if (<= n 0)\n    #{\"\"}\n    (let [other (parens (dec n))\n          from-left (set (map #(str \"()\" %) other))\n          short-circuit (set (for [len-short (range (dec n) 0 -1)\n                                   :let [len-rst (- n 1 len-short)]\n                                   short (parens len-short)\n                                   rst (parens len-rst)]\n                               (str \"(\" short \")\" rst)))]\n      (clojure.set/union from-left short-circuit))))", "user": "5344fe13e4b084c2834f4a32"}, {"problem": "195", "code": "(fn [o]\n  (let [F (memoize (fn [f o c]\n              (concat\n                  (if (> o 0) (map #(str \"(\" %) (f f (dec o) (inc c))))\n                  (if (> c 0) (map #(str \")\" %) (f f o (dec c))))\n                  (if (= c o 0) [\"\"])\n                )))]          \n        (set (F F o 0))))", "user": "4ff67852e4b0678c553fc37e"}, {"problem": "195", "code": "(fn paren-gens [n]\n     (let [paren-helper (fn [s]\n           (loop [begin \"\" end s result #{}]\n            (if (empty? end)\n              (conj result (str begin \"()\"))\n              (if (empty? begin)\n                (recur (str begin (first end)) (apply str (rest end)) (conj result (str begin \"()\" end)))\n                (if (= \\( (last begin))\n                  (recur (str begin (first end)) (apply str (rest end)) (conj result (str begin \"()\" end)))\n                  (recur (str begin (first end)) (apply str (rest end)) result))))))]\n              (loop [counter 0 result #{\"\"}]\n                (if (< counter n)\n                  (recur (inc counter) (set (mapcat paren-helper result)))\n                  result))))", "user": "532727bae4b09d4e7a9b54fa"}, {"problem": "195", "code": "(fn f [m n]\n          (set (if (zero? n) \n                 [\"\"]\n                 (for [o (range 1 (inc n))\n                       :let [m (+ m o)]\n                       c (if (= o n)\n                           [m]\n                           (range 1 (inc m)))\n                       r (f (- m c) (- n o))]\n                   (apply str (concat (repeat o \\() (repeat c \\)) r))))))\n         0", "user": "4e8f1ac6535d65386fec2146"}, {"problem": "195", "code": "(fn ps [n]\n  (letfn [(ps* [x y tmp]\n              (if (= 0 x)\n                [(apply str tmp (repeat y \")\"))]\n                (let [z (ps* (dec x) (inc y) (str tmp \"(\"))]\n                  (if (= 0 y) z\n                    (concat z (ps* x (dec y) (str tmp \")\")))))))]\n    (set (ps* n 0 \"\"))))", "user": "553e0b70e4b0a04f792994e8"}, {"problem": "195", "code": "(fn [n]\n  (if (zero? n)\n    #{\"\"}\n    (let [result (transient #{})\n          f (fn f [p o c s]\n              (when (> o c)\n                (f p o (inc c) (str s \\))))\n              (when (> p o)\n                (f p (inc o) c (str s \\()))\n              (when (= p o c)\n                 (conj! result s)))]\n      (f n 0 0 \"\")\n      (persistent! result))))", "user": "54ca9ca8e4b057c6fda3a265"}, {"problem": "195", "code": "(fn [n]\n          (if (= n 0)\n            #{\"\"}\n            (set\n              (map first\n                   (reduce\n                     (fn [states _]\n                       (mapcat\n                         (fn [[s a b]]\n                           (cond\n                             (= a 0) [[(str s \")\") 0 (dec b)]]\n                             (= b 0) [[(str s \"(\") (dec a) 1]]\n                             :else [[(str s \"(\") (dec a) (inc b)]\n                                    [(str s \")\") a (dec b)]]))\n                         states))\n                     [[\"\" n 0]]\n                     (range (* 2 n)))))))", "user": "4e5411e8535d8a8b8723a279"}, {"problem": "195", "code": "(fn gen [n]\n  (let [gen-cache (fn [prev-cache n] \n                    (let [level-results \n                          (cond \n                           (= n 0) #{\"\"}\n                           (= n 1) #{\"()\"}\n                           :else (let [\n                                       res1 (map #(str \"(\" % \")\") (prev-cache (dec n)))\n                                       res-other (for [i (range 1 n)]\n                                                   (for [beg (prev-cache i)\n                                                         end (prev-cache (- n i))]\n                                                     (str beg end)))\n                                       ]\n\t\t\t\t   (into #{} (flatten (concat res1 res-other)))))]\n\t\t      (conj prev-cache [n level-results])))\n\t\t  cache (reduce gen-cache {} (range 0 (inc n)))\n                          ]\n    (cache n)))", "user": "5034b0e1e4b062bc5d7ae167"}, {"problem": "195", "code": "(fn [n]\n  (letfn [(y [c i j]\n            (map #(conj % c)\n\t             (x i j)))\n          (x [i j]\n            (if (= 0 i)\n              [[]]\n              (concat (if (< 0 j)\n                        (y \\) i (- j 1)))\n                      (if (< j i)\n                        (y \\( (- i 1) j)))))]\n    (set (map #(apply str %) (x n n)))))", "user": "51ad244fe4b09397d510977f"}, {"problem": "195", "code": "(fn brackets [n]\n  (if (= n 0) #{\"\"}\n      (let [subs (map brackets (range n))]\n        (set (apply concat (map #(format \"(%s)\" %) (nth subs (dec n)))\n                    (for [i (range 1 n)]\n                      (for [head (nth subs i)\n                            tail (nth subs (- n i))]\n                        (clojure.string/join [head tail]))))))))", "user": "5294e44de4b02ebb4ef75016"}, {"problem": "195", "code": "(fn [pairs]\n  (letfn [(f [s open close]\n             (if (= open close pairs)\n               [s]\n               (concat (when (< open pairs)\n                         (f (str s \\() (inc open) close))\n                       (when (< close open)\n                         (f (str s \\)) open (inc close))))))]\n    (into #{} (f \"\" 0 0))))", "user": "4e7db3b4535db169f9c796e1"}, {"problem": "195", "code": "(fn [n]\n  (letfn\n    [(add-paren [parens]\n       (for [ps parens\n             :let [{l \\( r \\) :or {l 0 r 0}}\n                   (frequencies ps)]\n             [p stable] {\\( (< l n)\n                         \\) (> l r)}\n             :when stable]\n         (str ps p)))]\n    \n    (-> add-paren\n        (iterate [\"\"])\n        (nth (* 2 n))\n        set)))", "user": "532ab0bde4b09d4e7a9b5527"}, {"problem": "195", "code": "(fn [n]\n  (if (zero? n) #{\"\"}\n    ((fn br [o c v]\n       (if (zero? o)\n         (if (zero? c) #{}\n           #{(apply str (apply conj v (take c (repeat \\)))))})\n         (loop [cc c lv v vs #{}]\n           (if (< cc 0) vs\n             (recur\n               (dec cc)\n               (conj lv \\))\n               (apply conj vs (br (dec o) (inc cc) (conj lv \\())))))))\n     n 0 [])))", "user": "553abb28e4b09218d5f44ffb"}, {"problem": "195", "code": "(fn [n]\n  (into #{} (map #(apply str %) (loop [acc (list [[] 0 0])\n         res []]\n    (if (empty? acc) \n      res\n      (let [[[cur sum num] & acc-rest] acc]\n        (cond\n          (= (* n 2) (count cur)) (recur acc-rest (conj res cur))\n          (and (> sum 0) (< num n)) (recur (cons [(conj cur \\() (inc sum) (inc num)] (cons [(conj cur \\)) (dec sum) num] acc-rest)) res)\n          (> sum 0) (recur (cons [(conj cur \\)) (dec sum) num] acc-rest) res)\n          (< num n) (recur (cons [(conj cur \\() (inc sum) (inc num)] acc-rest) res))))))))", "user": "4faf97d8e4b081705acca258"}, {"problem": "195", "code": "(fn parens\n  ([n] (parens n \"\" 0 0))\n  ([n s o c] (if (= n c)\n               #{s}\n               (clojure.set/union\n                (if (< o n)\n                  (parens n (str s \"(\") (inc o) c)\n                  #{})\n                (if (> o c)\n                  (parens n (str s \")\") o (inc c))\n                  #{})))))", "user": "52d3f666e4b09f7907dd1327"}, {"problem": "195", "code": "(fn parenthesis-again\n  ([n] (parenthesis-again \"\" n n))\n  ([s open closed]\n    (if-not (pos? closed)\n      #{s}\n      (clojure.set/union\n        (when (pos? open) (parenthesis-again (str s \"(\") (dec open) closed))\n        (when (> closed open) (parenthesis-again (str s \")\") open (dec closed)))))))", "user": "5383668ee4b06839e8705edd"}, {"problem": "195", "code": "(fn p2\n  ([n] (p2 \"\" 0 n))\n  ([start open remaining]\n   (if (zero? remaining)\n     #{(str start (apply str (repeat open \")\")))}\n     (let [r (p2 (str start \"(\") (inc open) (dec remaining))]\n       (if (zero? open)\n         r\n         (clojure.set/union r (p2 (str start \")\") (dec open) remaining)))))))", "user": "52ce1abfe4b07d0d72b27389"}, {"problem": "195", "code": "#(letfn[(extendMemory [memory n] ;memory is a map to store known anwsers\n                     (assoc memory n ;update memory\n                       (reduce merge #{};prepare the resul\n                               (concat\n                                (for[i (range 1 n) prev (memory i) post (memory (- n i))] (str prev post));play with the combination through the memory\n                                (for[prev (memory (dec n))] (str \\( prev \\)))))))];another way to grow\n  ((reduce extendMemory {0 #{\"\"}} (range 1 (inc %))) %));explicitly using memory to find the result\n\n;;a recursive solution\n;(fn genParenthese ;to find n pairs of the parentheses\n;  ([n] (genParenthese n \"\" 0 0)) ;initially we got \"\" with 0 open and 0 close\n;  ([n s open close] \n;   (if (= n close) #{s} ;if closed pair matches n return result\n;     (clojure.set/union\n;           (when (< open n)\n;             (genParenthese n (str s \"(\") (inc open) close));if we can still append ( else return nil directly\n;           (when (< close open); if we can still append ) else return nil directly\n;             (genParenthese n (str s \")\") open (inc close)))))))", "user": "556c70dae4b09a3098a524fd"}, {"problem": "195", "code": "(fn genParenthese ;to find n pairs of the parentheses\n  ([n] (genParenthese n \"\" 0 0)) ;initially we got \"\" with 0 open and 0 close\n  ([n s open close] \n   (if (= n close) #{s} ;if closed pair matches n return result\n     (clojure.set/union\n           (when (< open n)\n             (genParenthese n (str s \"(\") (inc open) close));if we can still append ( else return nil directly\n           (when (< close open); if we can still append ) else return nil directly\n             (genParenthese n (str s \")\") open (inc close)))))))", "user": "541619e8e4b01498b1a719f9"}, {"problem": "195", "code": "(fn __ [N]\n  (letfn [(aux [l r]\n               (if (and (= l N) (= (inc r) N))              ; last character is always right paren\n                 [[\\)]]\n                 (let [lx (if (< l N) (map (partial cons \\() (aux (inc l) r)) [])\n                       rx (if (< r l) (map (partial cons \\)) (aux l (inc r))) [])]\n                   (concat lx rx))))]\n    (if (zero? N) #{\"\"}                                     ; special case\n                  (set (map #(apply str %) (aux 0 0))))))", "user": "536d83cee4b0fc7073fd6e5e"}, {"problem": "195", "code": "(fn parentheses [n]\n  (letfn\n    [(lengths [n]\n              (if (= n 1)\n                '((1))\n                (let [prevlengths (lengths (dec n))]\n                  (lazy-cat\n                   (map #(conj % 1) prevlengths)\n                   (map #(conj (rest %) (inc (first %))) prevlengths)))))\n     (compactly [n]\n               (mapv\n                 (partial map #(if (= % 1) \"()\" (compactly (dec %))))\n                 (lengths n)))\n     (expand [x]\n             (let [ [fixed options] (split-with (complement vector?) x) ]\n               (if (empty? options)\n                 (list (clojure.string/join x))\n                 (->> (first options)\n                      (map #(concat fixed (list \"(\") % (list \")\") (rest options)))\n                      (mapcat expand))\n                 )))]\n    (->> (if (zero? n) (list \"\") (compactly n))\n         (mapcat expand)\n         (into #{}))))", "user": "5568a1bde4b0c656e3ff1857"}, {"problem": "195", "code": "(fn matching-parens \n  ([n] (set (matching-parens n n) ))\n  ([a b] \n   (let [get-rest (fn [a1 b1 r] (let [s (if r \"(\" \")\") \n                                      a2 (if r (dec a1) a1)  \n                                      b2 (if r b1 (dec b1)) ] (map #(str s %) (matching-parens a2 b2))))]\n     (cond\n      (zero? a) [(apply str (repeat b \")\"))]\n      (= a b) (get-rest a b true)\n      :else (concat (get-rest a b true) (get-rest a b false))\n      ))))", "user": "54e345a1e4b024c67c0cf7db"}, {"problem": "195", "code": "(fn p [n]\n  (if (= 0 n)\n    #{\"\"}\n    (reduce (fn [c s]\n              (into c (map #(str (subs s 0 %) \"()\" (subs s %))\n                           (range (- (* 2 n) 1)))))\n            #{} (p (- n 1)))))", "user": "543366dde4b0b6b47310fcdf"}, {"problem": "195", "code": "(fn [n]\n  (let [ins (fn [string pos]\n              (apply str (subs string 0 pos) \"()\" (subs string pos)))\n        each-ins (fn [string]\n                   (map (partial ins string) (range 0 (inc (count string)))))\n        step (fn [string-set]\n               (into #{} (flatten (map each-ins string-set))))]\n    (last (take (inc n) (iterate step #{\"\"})))))", "user": "5164867fe4b003cf19fdde3e"}, {"problem": "195", "code": "(fn q [n]\n  (if (= 0 n)\n    #{\"\"}\n    (loop [res [[\"(\" 1]] curr 1]\n      (if (= (* 2 n) curr)\n        (reduce (fn [m [k v]] (if (zero? v) (conj m k) m)) #{} res)\n        (recur\n          (mapcat\n            (fn [[k v]]\n              (if (pos? v)\n                (if (< v (- (* 2 n) curr))\n                  [[(str k \\)) (dec v)] [(str k \\() (inc v)]]\n                  [[(str k \\)) (dec v)]])\n                [[(str k \\() (inc v)]]))\n            res)\n          (inc curr))))))", "user": "51aefceee4b09397d5109797"}, {"problem": "195", "code": "(fn [n]\n  (if (= n 0) #{\"\"}\n      (loop [i 1 res #{\"()\"}]\n        (if (= n i)\n          res\n          (recur (inc i)\n                 (->> (for [r res]\n                        (cons (str \"(\" r \")\")\n                              (map #(str (apply str (take % r))\n                                         \"()\"\n                                         (apply str (drop % r)))\n                                   (range (count r)))))\n                      (apply concat)\n                      set))))))", "user": "528a3e14e4b0239c8a67ae72"}, {"problem": "195", "code": "(fn parens [n]\n  (let [ins-parens (fn [s]\n                     (map\n                      (fn [i]\n                        (str (subs s 0 i) \"()\" (subs s i)))\n                      (range (inc (count s))))\n                     )]\n    (if (<= n 0)\n      #{\"\"}\n      (let [ss (parens (dec n))]\n        (into #{} (mapcat ins-parens ss))\n        ))))", "user": "54b13a40e4b09f271ff37d1b"}, {"problem": "195", "code": "(fn [n]\n  (let\n    [p (memoize\n         (fn [p n]\n           (if (= n 0) '(\"\")\n             (set\n               (concat (map #(str \\( % \\)) (p p (dec n)))\n                       (for [n' (range 1 n)\n                             l (p p n') r (p p (- n n'))]\n                         (str l r)))))))]\n    (set (p p n))))", "user": "508157b2e4b0946d0443855c"}, {"problem": "195", "code": "(fn create [x]\n  (let [inspar (fn [s pos] (str (subs s 0 pos) \"()\" (subs s pos)))\n        inserter (fn [s] (->> (map (partial inspar s) (range (inc (count s))))\n                              (into #{})))]\n    (loop [y x r #{\"\"}]\n      (if (= y 0)\n        r\n        (recur (dec y) (into #{} (mapcat inserter r)))))))", "user": "513b77f3e4b00f740c76c403"}, {"problem": "195", "code": ";;The question is equivalent to asking for sequences containing n 1s and n -1s such that each partial sum\n;;is non-negative. It's probably trivial to write this using that, although that may not be efficient enough.\n;;It's probably not too bad to make an efficient variation, though.\n(letfn [(strings [ls rs]\n  (cond\n    (= rs 0) '(\"\")\n    (= ls 0) (map #(str \")\" %) (strings ls (dec rs)))\n    (>= ls rs) (map #(str \"(\" %) (strings (dec ls) rs))\n    :else (concat (map #(str \"(\" %) (strings (dec ls) rs)) (map #(str \")\" %) (strings ls (dec rs))))))]\n  (fn [n]\n    (into #{} (strings n n))))", "user": "5553b924e4b0deb715856e06"}, {"problem": "195", "code": "(fn [n]\r\n  (let [\r\n    parens (fn parens [n curr-depth s]\r\n      (if (zero? n)\r\n        #{(str s (apply str (repeat curr-depth \")\")))}\r\n      (if (zero? curr-depth)\r\n        (parens (dec n) (inc curr-depth) (str s \"(\"))\r\n      ;else\r\n        (set (concat\r\n          (parens (dec n) (inc curr-depth) (str s \"(\"))\r\n          (parens n (dec curr-depth) (str s \")\")))))))]\r\n    (parens n 0 \"\")))", "user": "555bd27ae4b0b056612e2244"}, {"problem": "195", "code": ";; Wanted just a memoized fn, not sure how to do that given the\n;; limitations of 4clojure, so this simulates having a vector cache\n;; Used the fact that\n;; S(n) = '(' S(n-1) ')'\n;;        | S(1) S(n-1) | S(n-1) S(1)\n;;        | S(2) S(n-2) | S(n-2) S(2)\n;;        | ...\n;; See e.g. amalloy and cgrand for more math-y solutions\n(letfn [(step [cache]\n          (let [n (count cache)\n                res\n                (into (set (for [x (nth cache (- n 1))] (str \"(\" x \")\")))\n                      (mapcat identity\n                              (for [i (range 1 n)\n                                    a (nth cache i)\n                                    b (nth cache (- n i))]\n                                [(str a b) (str b a)])))]\n            (conj cache res)))]\n  (fn [n]\n    (->> (iterate step [#{\"\"}])\n         (drop n)\n         first\n         last)))", "user": "4ed188c8535d44c135fd68cf"}, {"problem": "195", "code": "#(set ((fn f [acc s n m]\n     (if (zero? n) \n       (conj acc (str s (clojure.string/join (repeat m \\)))))\n       (concat acc (f acc (str s \"(\") (dec n) (inc m))\n               (if (not= 0 m)\n                 (f acc (str s \")\") n (dec m)))))) () \"\" % 0))", "user": "53065acbe4b02e8216869792"}, {"problem": "195", "code": "(fn [n]\n  ((fn dfs [results s opens closes]\n     (let [results (if (= opens closes n)\n                     (conj results s)\n                     results)\n\n           results (if (< opens n)\n                     (dfs results (str s \"(\") (inc opens) closes)\n                     results)\n\n           results (if (and (< closes n) (< closes opens))\n                     (dfs results (str s \")\") opens (inc closes))\n                     results)]\n\n       results)) #{} \"\" 0 0))", "user": "521b9f92e4b0c4ef0be8304c"}, {"problem": "195", "code": "(fn parens-me\n  ([n] (set (parens-me n 0 \"\")))\n  ([n m s]\n   (if (= 0 n m)\n     [s]\n     (concat\n      (when (not= n 0)\n        (parens-me (dec n) (inc m) (str s \"(\")))\n      (when (not= m 0)\n        (parens-me n (dec m) (str s \")\")))))))", "user": "4ec07699535dfed6da9c6da2"}, {"problem": "195", "code": "(fn [n]\n (letfn [(dobrackets [n l]\n                     (let [bal (apply + l)]\n                      (cond (and (= (* 2 n) (count l)) (zero? bal)) (apply str (map #({1 \"(\" -1 \")\"} %) l))\n                            (< (- (* 2 n) (count l)) bal) []\n                            (< (* 2 n) (count l)) [] (neg? bal) [] (< n bal) []\n                            :else (filter not-empty [(dobrackets n (conj l -1)) (dobrackets n (conj l 1))])\n                            ))\n                     )]\n  (if (zero? n) #{\"\"} (set (flatten (dobrackets n [1]))))\n ))", "user": "52593207e4b0cb4875a45cd3"}, {"problem": "195", "code": "(letfn [                                                                                                                        \n    (insert-parens [s n] (str (subs s 0 n) \"()\" (subs s n)))                                                                                            \n    (add-parens [s] (map #(insert-parens s %) (range (count s))))                                                               \n    (parens [n]                                                                                                                                         \n        (condp = n                                                                                                              \n            0 #{\"\"}                                                                                                                                     \n            1 #{\"()\"}                                                                                                           \n              (set (mapcat add-parens (parens (dec n))))))]                                                                                             \n    parens)", "user": "558b50d5e4b027778923762b"}, {"problem": "195", "code": "#(letfn\n     [(par [n open closed curr]\n        (if (= n closed) (str curr \";\")\n            (let [openstr (when (< open n) (par n (inc open) closed (str curr \"(\")))\n                  closedstr (when (< closed open) (par n open (inc closed) (str curr \")\")))]\n              (str openstr closedstr))))]\n   (if (zero? %) #{\"\"}\n       (set (clojure.string/split (par % 0 0 \"\") #\";\"))))", "user": "4f2d5f5de4b0d6649770a05a"}, {"problem": "195", "code": "(fn gen-parens\n  ([n] (gen-parens nil n 0 0))\n  ([ps n o c]\n   (if (= n c)\n     #{(apply str ps)}\n     (clojure.set/union\n      (if (> n o)\n        (gen-parens (conj ps \\)) n (inc o) c)\n        #{})\n      (if (> o c)\n        (gen-parens (conj ps \\() n o (inc c))\n        #{})))))", "user": "540a4f20e4b0addc1aec66ef"}, {"problem": "195", "code": "#(loop [stack-frames [{:height 0\n                       :remain %\n                       :string \"\"}]\n        remaining (* 2 %)]\n   ; (println stack-frames remaining)\n   (if (zero? remaining)\n     (set (map :string stack-frames))\n     (recur (flatten (map (fn [frame]\n                            (let [h (:height frame)\n                                  r (:remain frame)\n                                  s (:string frame)]\n                              (cond \n                               (= 0 r) {:height (dec h)\n                                        :remain r\n                                        :string (str s \")\")}\n                               (= 0 h) {:height (inc h)\n                                        :remain (dec r)\n                                        :string (str s \"(\")}\n                               :else (list {:height (inc h)\n                                            :remain (dec r)\n                                            :string (str s \"(\")}\n                                           {:height (dec h)\n                                            :remain r\n                                            :string (str s \")\")}))))\n                          stack-frames))\n            (dec remaining))))", "user": "5595ffabe4b0c79f6e1db972"}, {"problem": "195", "code": "(fn parentheses \n  ([n] (parentheses n n))\n  ([left right]\n    (if (and (zero? left) (zero? right)) \n      #{\"\"}\n      (clojure.set/union\n        (when (> left 0)\n          (set (map #(str \"(\" % ) (parentheses (dec left) right))))\n        (when (> right left)\n          (set (map #(str \")\" % ) (parentheses left (dec right)))))))))", "user": "5046f909e4b03b02161376b5"}, {"problem": "195", "code": "(fn bracks [n]\n  (let [foo \n  (memoize (fn [n f]\n                      (cond\n                        (= n 0) #{\"\"}\n                        :else (set (concat\n                                     (map #(str \"(\" % \")\")\n                                          (f (dec n) f))\n                                     (mapcat #(for\n                                               [x (f % f), y (f (- n %) f)]\n                                               (str x y))\n\n                                             (range 1 n))\n                                     ))\n                        )\n                      ))]\n  (foo n foo)))", "user": "50a4f36be4b0344e360f3bc9"}, {"problem": "195", "code": "(let [c (memoize (fn [c n]\n            (if (= 0 n) #{\"\"}\n                (set\n                     (for [x (range 0 n) \n                           L (c c x)\n                           R (c c (- n x 1))]\n                          (str L \"(\" R \")\"))))))\n     ] (partial c c))", "user": "559c13c5e4b066d22e731f61"}, {"problem": "195", "code": "(fn [n]\n  (letfn [(f [s i]\n            (str (subs s 0 i) \"()\" (subs s i (count s))))\n\n          (g [s]\n            (if (= s \"\")\n              [\"()\"]\n              (map #(f s %) (-> s count range))))]\n\n    (loop [n n\n           acc #{\"\"}]\n      (if (= 0 n)\n        acc\n        (recur (dec n)\n               (set\n                 (mapcat g acc)))))))", "user": "4ec1b090535dfed6da9c6db5"}, {"problem": "195", "code": "(fn ^:static\n  parentheses-again\n  [n]\n  (letfn [(parentheses-again*\n            [xs o c]\n            (if (= o c n)\n              #{xs}\n              (clojure.set/union (when (< c o) (parentheses-again* (str xs \")\") o (inc c)))\n                                 (when (< o n) (parentheses-again* (str xs \"(\") (inc o) c)))))]\n    (parentheses-again* \"\" 0 0)))", "user": "506f0968e4b09350ab4199f5"}, {"problem": "195", "code": "(fn parens\n  ([n] (parens \"\" n 0 0))\n  ([s n open close]\n   (if (= n close)\n     #{s}\n     (clojure.set/union\n      (if (< open n)\n        (parens (str s \"(\") n (inc open) close)\n        #{})\n      (if (< close open)\n        (parens (str s \")\") n open (inc close))\n        #{})\n      ))\n   )\n  )", "user": "55933c7ae4b0c79f6e1db938"}, {"problem": "195", "code": "(fn [n]\n  (letfn [(parens [acc open close]\n                   (if (= 0 open close)\n                     (list (apply str acc))\n                     (concat\n                       (when (> open 0)\n                         (parens (conj acc \\() (dec open) (inc close)))\n                       (when (> close 0)\n                         (parens (conj acc \\)) open (dec close)))\n                       )))]\n    (set (parens [] n 0))))", "user": "4f05ea25535dcb61093f6c02"}, {"problem": "195", "code": "(fn par\n  ([n] (par \"\" 0 (* 2 n)))\n  ([s opened remaining]\n   (let [next  #(par (str s %1) (%2 opened) (dec remaining))\n         open  #(next \"(\" inc)\n         close #(next \")\" dec)]\n     (cond\n      (zero? remaining) #{s}\n      (= opened remaining) (close)\n      (= opened 0) (open)\n      :else (clojure.set/union (open) (close))\n      )))\n  )", "user": "55a74d46e4b09e57187da2a3"}, {"problem": "195", "code": "(fn [n]\n  (let [prepend-lp (partial map (partial str \"(\"))\n        prepend-rp (partial map (partial str \")\"))\n        p (memoize\n           (fn [p l r]\n             (cond\n              (zero? l) (list (apply str (repeat r \")\")))\n              (pos? r) (concat\n                        (prepend-lp (p p (dec l) (inc r)))\n                        (prepend-rp (p p l (dec r))))\n              :else (prepend-lp (p p (dec l) (inc r))))))]\n    (set (p p n 0))))", "user": "55aa7c5ce4b0988bba2ad94d"}, {"problem": "195", "code": "(fn [n]\n  (set ((fn r [c a z]\n     (if (= 0 a z)\n       [(apply str c)]\n       (concat\n         (if (< 0 a) (r (conj c \\() (dec a) z))\n         (if (< a z) (r (conj c \\)) a (dec z))))))\n    [] n n)))", "user": "4f9d8083e4b0dcca54ed6d23"}, {"problem": "195", "code": "(fn __ [n] \n  (if (zero? n) #{\"\"}\n   (set(apply concat (map  #(for [x (__ (first %)) y (__ (second %))](str  \"(\" x \")\" y))              \n               (map #(vector % (- (dec n) %)) (range n)) )))))", "user": "52bbd09ee4b07a9af57922ee"}, {"problem": "195", "code": "(fn [n]\n                (set (let [f (memoize (fn [g n]\n                            (if (or (< n 0) (= n 0))\n                              (list \"\")\n                              (for [m (range n)\n                                    inside (g g m)\n                                    outside (g g (- n m 1))]\n                                  (str \"(\" inside \")\" outside)))))]\n                  (f f n))))", "user": "5245e320e4b09dbe66b56177"}, {"problem": "195", "code": "(let [f\n        (memoize\n         (fn [f n]\n           (if (= 0 n) #{\"\"}\n               (set (into\n                     (for [i (range 1 n)\n                           s (f f i)\n                           q (f f (- n i))]\n                       (str s q))\n                     (for [s (f f (- n 1))]\n                       (str \"(\" s \")\"))\n                     )))))]\n    #(f f %))", "user": "55be39f9e4b01b9910ae2a06"}, {"problem": "195", "code": "(fn [n]\n  (letfn [(rec [s h r]\n            (cond\n             (neg? h) []\n             (> h r) []\n             (zero? r) (if (zero? h) [s] [])\n             :else (into\n                    (rec (str s \"(\") (inc h) (dec r))\n                    (rec (str s \")\") (dec h) (dec r)))))]\n    (set (rec \"\" 0 (* 2 n)))))", "user": "55c4e48be4b0e31453f649a7"}, {"problem": "195", "code": "(fn [n]\n  (let [d dec\n        m map\n        f\n         (fn f [a b]\n                   (cond\n                     (some zero? [a b]) [(seq (repeat b \\)))]\n                     (= a b) (m #(conj % \\()  (f (d a) b))\n                     :else (concat (m #(conj % \\()  (f (d a) b))\n                                   (m #(conj % \\))  (f a (d b)))))) ]\n    (set (m #(apply str %) (f n n)))))", "user": "55c652dde4b0e31453f649bd"}, {"problem": "195", "code": "(fn paren-combos\n  ([n] (paren-combos \"\" n 0 0))\n  ([s n open close]\n   (if (= n close)\n     #{s}\n     (clojure.set/union\n       (if (< open n)\n         (paren-combos (str s \"(\") n (inc open) close)\n         #{})\n       (if (< close open)\n         (paren-combos (str s \")\") n open (inc close))\n         #{})))))", "user": "4db1b3951254ad5b4805fa6f"}, {"problem": "195", "code": "(fn parens\n    ([n] (parens \"\" n 0 0))\n    ([s n open close]\n      (if (= n close)\n        #{s}\n        (clojure.set/union\n          (if (< open n) \n            (parens (str s \"(\") n (inc open) close)\n            #{}) \n          (if (< close open)\n            (parens (str s \")\") n open (inc close))\n            #{})\n          ))))", "user": "55aa1637e4b0988bba2ad949"}, {"problem": "195", "code": "(fn pagain [n]\n  (let [generate-inters (fn [token s] (map #(str (subs s 0 %) token (subs s %)) (range (inc (count s)))))\n \t\tgenerate-all-set (fn [s n] (into #{} (flatten (map (partial generate-inters \"()\") s))))]\n  \t(reduce generate-all-set #{\"\"} (range n))))", "user": "559b55d6e4b066d22e731f54"}, {"problem": "195", "code": "(fn [n]\n  (loop [i 0 row [[\"\"]]]\n    (if (= i n)\n      (set (last row))\n      (recur (inc i)\n             (rest (reductions (fn [l d]\n                                 (concat (map #(str % \")\") l) (map #(str % \"(\") d))) \n                               [] (concat row [[]])))))))", "user": "55625903e4b0c656e3ff17d7"}, {"problem": "195", "code": "(fn [n]\n  (letfn [(gen-strings [open close string strings]\n            (let [add-open #(gen-strings (dec open) close (str string \"(\") strings)\n                  add-close #(gen-strings open (dec close) (str string \")\") strings)]\n              (cond\n                (= 0 open close) (cons string strings)\n                (= 0 open) (add-close)\n                (> close open) (concat (add-open) (add-close))\n                :else (add-open))))]\n    (-> (gen-strings n n \"\" '()) flatten set)))", "user": "51307b84e4b08c712d3fae39"}, {"problem": "195", "code": "(fn par \n  ([n] (par n \"\" 0 n))\n  ([n s depth openleft]\n    (if (= (count s) (* n 2))\n\t    #{s}\n\t\t(clojure.set/union \n          (when (pos? openleft) (par n (str s \"(\") (inc depth) (dec openleft) ))\n          (when (pos? depth)    (par n (str s \")\") (dec depth) openleft       )) ))))", "user": "55cdc576e4b0e31453f64a1f"}, {"problem": "195", "code": "(fn p [n]\n  (let [f (fn [s c] (map #(str s \"(\" % \")\") c))\n        g (fn [c d] (map #(f % d) c))]\n    (condp = n\n      0 #{\"\"}\n      1 #{\"()\"}\n      (reduce conj (set (map #(str \"(\" % \")\") (p (dec n))))\n        (flatten (map #(g (p %1) (p (- n %1 1))) (range 1 n)))))))", "user": "55205564e4b08d5046aa8a60"}, {"problem": "195", "code": "(fn parens[n]\n  (if (zero? n)\n    #{\"\"}\n    (->> (range 0 n)\n       (map (fn [index]\n             (for [left (parens index)\n                   right (parens (- n index 1))]\n                   (str \"(\" left \")\" right))))\n       (apply concat)\n       (into #{}))))", "user": "4f4c6b21e4b03ad3f0c10c8f"}, {"problem": "195", "code": "(fn parens\n  ([n] (parens \"\" n 0 0))\n  ([s n open close]\n   (if (= n close)\n     #{s}\n     (clojure.set/union\n       (if (< open n)\n         (parens (str s \"(\") n (inc open) close)\n         #{})\n       (if (< close open)\n         (parens (str s \")\") n open (inc close))\n         #{})\n       ))\n    )\n  )", "user": "51ae350fe4b09397d5109790"}, {"problem": "195", "code": "(fn [m]\n  (let [q (atom #{})\n        r (atom [])\n        f (fn f [i n o c]\n            (if (= c n)\n              (swap! q conj (apply str @r))\n              (do\n                (if (> o c)\n                  (do (swap! r assoc i \\)) (f (inc i) n o (inc c))))\n                (if (< o n)\n                  (do (swap! r assoc i \\() (f (inc i) n (inc o) c))))))]\n    (f 0 m 0 0) \n    @q))", "user": "4ef49c2c535dced4c769f238"}, {"problem": "195", "code": "(fn balanced-parens\n                          ([n] (into #{} (map #(apply str %) (balanced-parens [] [] n 0))))\n                          ([out-out out open-parens close-parens]\n                           (if (and (zero? open-parens) (zero? close-parens))  \n                             (conj out-out out)\n                             (let [p1 (if (> open-parens 0) \n                                        (balanced-parens out-out (conj out \\() (dec open-parens) (inc close-parens)))\n                                   p2 (if (> close-parens 0) \n                                        (balanced-parens out-out (conj out \\)) open-parens (dec close-parens)))]\n                               (concat p1 p2)))))", "user": "54cad2d5e4b057c6fda3a26c"}, {"problem": "195", "code": "(fn self [n]\n    (let [inner (fn inner [num-left\n                           num-right\n                           curr\n                           pile]\n                  (if (= n num-left num-right)\n                    (conj pile (apply str curr))\n                    (do\n                      (concat\n                        (if (< num-left n)\n                          (inner (inc num-left) num-right (conj curr \\() pile))\n                        (if (and (< num-right n)\n                                 (> num-left num-right))\n                          (inner num-left (inc num-right) (conj curr \\)) pile))\n                        ))\n                    ))\n         ]\n      (set (inner 0 0 [] [])))\n  )", "user": "52ffb7f2e4b0d8b024fd370b"}, {"problem": "195", "code": "(fn [n]\n  (letfn [(combs-of [res l r]\n                    (cond\n                      (zero? r) #{res}\n                      (zero? l) (recur (str res \\)) l (dec r))\n                      (< l r) (clojure.set/union\n                                (combs-of (str res \\() (dec l) r)\n                                (combs-of (str res \\)) l (dec r)))\n                      :else (recur (str res \\() (dec l) r)))]\n    (combs-of \"\" n n)))", "user": "5339c105e4b0e30313ee6cae"}, {"problem": "195", "code": "(fn g [n]\n  (if (= n 0) #{\"\"} (let [f (memoize g)]\n    (set (concat (set (apply concat\n                 (for [x (range 1 n)]\n                   (set\n                     (for [y (f (- n x)) z (f x)]\n                       (str y z))\n                     )\n                   )\n                 )\n            )(mapcat #(set [(str % \"()\") (str \"()\" %) (str \"(\" % \")\")]) (f (- n 1))))))\n    ))", "user": "55e1d34ae4b050e68259b421"}, {"problem": "195", "code": "(fn parens [n]\n  (let [db (atom #{})\n        pc (fn pc [out open close pairs]\n             (if (and (= open pairs) (= close pairs))\n              (do ;(println out)\n                (swap! db conj out))\n              (do\n               (when (< open pairs) (pc (str out \"(\") (inc open) close pairs))\n               (when (< close open) (pc (str out \")\") open (inc close) pairs)))))]\n  (pc \"\" 0 0 n)\n  @db))", "user": "534056fce4b085b17e897dac"}, {"problem": "195", "code": "(fn dyck-words [n]\n  (let [acc (atom #{})]\n    (letfn [(calc-words [left right s acc]\n                        (let [l (if (> left 0) (calc-words (dec left) (inc right) (str s \"(\") acc))\n                              r (if (> right 0) (calc-words left (dec right) (str s \")\") acc))]\n                          (if (= 0 left right)\n                            (swap! acc conj s)\n                            )))]\n      (calc-words n 0 \"\" acc)\n      @acc\n      )\n    ) \n  )", "user": "5592bf9fe4b0c79f6e1db933"}, {"problem": "195", "code": "(fn parens-again [n]\n  (letfn [(paren-gen [n-open n-close res]\n            (if (zero? n-open)\n              [(apply str (cons res (repeat n-close \")\")))]\n              (concat\n               (paren-gen (dec n-open) (inc n-close) (str res \"(\"))\n               (if (zero? n-close) [] (paren-gen n-open (dec n-close) (str res \")\"))))))]\n    (set (paren-gen n 0 \"\"))))", "user": "54f09599e4b024c67c0cf89d"}, {"problem": "195", "code": "(fn parens [n]\n  (loop [sofar [#{\"\"} #{\"()\"}]]\n    (if (< n (count sofar))\n      (nth sofar n)\n      (let [wrapped (map\n                     (fn [prior] (str \"(\" prior \")\"))\n                     (last sofar))\n            joined (mapcat (fn [left right]\n                             (for [l left\n                                   r right]\n                               (str l r)))\n                           (rest sofar)\n                           (reverse (rest sofar)))\n            nxt (set (concat wrapped joined))]\n        (recur (conj sofar nxt))))))", "user": "4ffc10aae4b0678c553fc3d6"}, {"problem": "195", "code": "(fn [n]\n  (letfn [(parens [acc open close]\n            (if (= 0 open close)\n              (list (apply str acc))\n              (concat\n               (when (> open 0)\n                 (parens (conj acc \\() (dec open) (inc close)))\n               (when (> close 0)\n                 (parens (conj acc \\)) open (dec close)))\n               )))]\n    (set (parens [] n 0))))", "user": "537e104ce4b06839e8705e9a"}, {"problem": "195", "code": "(letfn [(initial-builders [n]\n          [[[] 0 n n]])\n\n        (fork-builder [[paren-vec height begins ends]]\n          (remove nil?\n                  [(if (pos? begins)\n                     [(conj paren-vec \"(\") (inc height) (dec begins) ends])\n                   (if (pos? height)\n                     [(conj paren-vec \")\") (dec height) begins (dec ends)])]))\n\n        (build-parens [n]\n          (loop [builders (initial-builders n)\n                 steps 0]\n            (if (= (* 2 n) steps)\n              (set (map #(apply str (first %)) builders))\n              (recur (->> builders\n                          (map fork-builder)\n                          (apply concat))\n                     (inc steps)))))]\n  build-parens)", "user": "55f2e47de4b06e875b46ce4d"}, {"problem": "195", "code": "(fn parens [n]\n  (letfn [(p [res lc rc]\n            (cond\n              (= 0 lc rc) (list res)\n              (= lc rc) (p (str res \"(\") (dec lc) rc)\n              (= 0 lc) (p (str res \")\") lc (dec rc))\n              :else (concat (p (str res \"(\") (dec lc) rc)\n                            (p (str res \")\") lc (dec rc)))))]\n    (into #{} (p \"\" n n))))", "user": "559454f2e4b0c79f6e1db952"}, {"problem": "195", "code": "(fn generate-parens-4clojure [n]\n  (letfn [(genp [ln rn]\n               (cond (= 0 ln rn) ['()]\n                     (and (zero? ln) (< 0 rn)) [(repeat rn \\))]\n                     (<= ln rn) (concat\n                                  (map (partial cons \\() (genp (dec ln) rn))\n                                  (map (partial cons \\)) (genp ln (dec rn))))\n                     :else []))]\n        (set (map (partial apply str) (genp n n)))))", "user": "52e657e4e4b09f7907dd1472"}, {"problem": "195", "code": "(fn [n]\n  (set ((fn paths [x y]\n          (if (= x y n) [\"\"]\n              (concat (when (< x n)\n                        (map #(str \"(\" %) (paths (inc x) y)))\n                      (when (< y x)\n                        (map #(str \")\" %) (paths x (inc y)))))))\n        0 0)))", "user": "4f5eda39e4b0030a34fb2b56"}, {"problem": "195", "code": "(fn pa\n  ([n]\n   (if (zero? n)\n     #{\"\"}\n     (into #{} (filter (complement clojure.string/blank?) (clojure.string/split (pa n 0 \"\") #\" \")))))\n  ([o c s]\n   (str (if (and (zero? o) (zero? c))\n          (str \" \" s \" \")\n          (str (if (pos? o)\n                 (str (pa (dec o) (inc c) (str s \"(\")))\n                 \"\")\n               (if (pos? c)\n                 (str (pa o (dec c) (str s \")\")))\n                 \"\"))))))", "user": "509a25b7e4b0efbae1fbc0a8"}, {"problem": "195", "code": "(fn [n] ((fn alma [open s len n] \n  (if (= len n) \n    (if (= open 0) #{s} #{}) \n    (clojure.set/union \n      (if (> open 0) \n        (alma (dec open) (clojure.string/join [s \")\"]) (inc len) n)  \n        #{} ) \n      (alma (inc open) (clojure.string/join [s \"(\"]) (inc len) n)  ) )  )\n0 \"\" 0 (* n 2)))", "user": "4feada56e4b0140c20fb9c11"}, {"problem": "195", "code": "(fn parens [n]\n  (let [LP \\(\n        RP \\)\n        gen (fn gen [l r]\n          (if (zero? l)\n            (list (repeat r RP))\n            (concat (map #(cons LP %) (gen (dec l) r))\n                    (when (not= l r) (map #(cons RP %) (gen l (dec r)))))))\n      ]\n    (set (map #(apply str %) (gen n n)))\n  ))", "user": "4df3d4f4535d08e6dec9fe2c"}, {"problem": "195", "code": "(fn [n]\n  (loop [acc #{} cs [[0 n n \"\"]]]\n    (if (empty? cs) acc\n      (let [[c lc rc s] (first cs)]\n        (cond (some neg? [c lc rc]) (recur acc (rest cs))\n              (every? zero? [lc rc]) (recur (conj acc s) (rest cs))\n              :else (recur acc (conj (rest cs)\n                                     [(inc c) (dec lc) rc (str s \"(\")]\n                                     [(dec c) lc (dec rc) (str s \")\")])))))))", "user": "55c20bd0e4b0e31453f64972"}, {"problem": "195", "code": "(fn parengen \n  ([n] (if (= n 0) #{\"\"} (into #{} (parengen (dec (* 2 n)) 1 \"(\"))))\n  ([n total acc]\n    (when (> total -1) \n    (if (= n 0) \n    \t(when (= total 0) (list acc))\n\t(concat (parengen (dec n) (inc total) (str acc \"(\"))\n\t      (parengen (dec n) (dec total) (str acc \")\")))))))", "user": "52747090e4b03e8d9a4a74a5"}, {"problem": "195", "code": "(fn [n]\n  (let [L \\( R \\) lists '() max-len (* 2 n)] \n    (letfn [\n            (gen-list [parens level]\n              (let [len (count parens)]\n              (cond\n                (= len max-len)            (cons parens lists) \n                (= 0 level)                (gen-list (conj parens L) 1)\n                (>= level (- max-len len)) (gen-list (conj parens R)(dec level))\n                :else (vec (concat \n                        (gen-list (conj parens L) (inc level))\n                        (gen-list (conj parens R) (dec level)))))))\n            ]\n      \n      (set (map (partial reduce str) (gen-list [] 0))))))", "user": "55ecb2c0e4b0121d4835fdce"}, {"problem": "195", "code": "(fn gen-parens\n  ([n] (if (= 0 n) #{\"\"} (set (gen-parens n 0))))\n  ([n open]\n   (if (= 0 n)\n     (vector (apply str (repeat open \")\")))\n     (if (= 0 open)\n       (map #(str \"(\" %) (gen-parens (dec n) 1))\n       (concat\n         (map #(str \")\" %) (gen-parens n (dec open)))\n         (map #(str \"(\" %) (gen-parens (dec n) (inc open))))))))", "user": "549dfe40e4b0f3d1d8e70f9a"}, {"problem": "195", "code": "(let [[get-stack get-state] [first second]]\r\n  (fn balanced-parens\r\n    ([n] (balanced-parens n [[0, \"\"]]))\r\n    ([n machines]\r\n     (letfn [(step [[stack state]]\r\n               (concat (when (> n (quot stack 2))                         \r\n                         [[(inc stack), (str state \"(\")]])\r\n                       (when (< 0 stack)\r\n                         [[(dec stack), (str state \")\")]])))]\r\n       (if (= 0 n)\r\n         (->> (filter (comp zero? get-stack) machines)\r\n              (map get-state)\r\n              (set))\r\n         (recur (dec n)\r\n                (->> (mapcat step machines)\r\n                     (mapcat step))))))))", "user": "55d0e76ae4b0e31453f64a40"}, {"problem": "195", "code": "(fn genParenPairs [n]\n  (letfn [(buildParens [result open close]\n            (if (= 0 open close)\n              (set [result])\n              (clojure.set/union\n               (if (> open 0)\n                 (buildParens (str result \"(\")  (dec open) (inc close)))\n               (if (> close 0)\n                 (buildParens (str result \")\") open (dec close))))))]\n    (buildParens \"\" n 0)))", "user": "54f64e99e4b0f2f3c5226ea4"}, {"problem": "195", "code": "(fn [n]\n  (letfn [(f [o c]\n             (if (= o c 0)\n               [\"\"]\n               (lazy-cat\n                 (when (> o 0)\n                   (map (partial cons \\() (f (dec o) (inc c))))\n                 (when (> c 0)\n                   (map (partial cons \\)) (f o (dec c))))\n                 )))]\n    (->> (f n 0)\n         (map #(apply str %))\n         (set))))", "user": "549c6792e4b0f3d1d8e70f8b"}, {"problem": "195", "code": "(fn [n]\n  ((fn f [o c i s]\n     (if (= 0 i)\n       (if (not= o c) #{} #{s})\n       (clojure.set/union\n        (if (> o c)\n          (f o (inc c) (dec i) (str s \")\")))\n        (if (< (- c o) (- i 1))\n          (f (inc o) c (dec i) (str s \"(\"))))))\n   0 0 (* 2 n) \"\"))", "user": "519136e9e4b0f8ef0be96c01"}, {"problem": "195", "code": "(fn prob195\n  ([n] (prob195 \"\" n 0 0))\n  ([s n open close] \n   ;; when n equals close return s in set as result\n   (if (= n close)\n     #{s}\n      (clojure.set/union\n       ;; while n is greater than open\n       (if (< open n)\n         (prob195 (str s \"(\") n (inc open) close)\n         #{}\n         )\n       ;; while open is greater than close\n       (if (< close open)\n         (prob195 (str s \")\") n open (inc close))\n         #{}\n         ))\n     )\n   )\n)", "user": "4ebbff41535dfed6da9c6d78"}, {"problem": "195", "code": "(fn [n]\n  (letfn [(add-brackets [open close]\n                        (lazy-seq \n                         (concat \n                          (when (pos? open)\n                            (map #(cons \\( %)\n                                 (add-brackets (dec open) (inc close))))         \n                          (when (pos? close)\n                            (map #(cons \\) %)\n                                 (add-brackets open (dec close))))     \n                          (when (= [0 0] [open close]) [\"\"]))))\n          (parentheses [nu] (set (map #(apply str %) (add-brackets nu 0))))]\n    (parentheses n)))", "user": "5133e51ae4b0d7a043de8cf6"}, {"problem": "195", "code": "(fn [hlen]\n  (let [len (* hlen 2)]\n    (letfn [(p [s n open]\n              (cond (zero? n) [s]\n                    (= n len) (p \"(\" (dec n) 1)\n                    (> n 0) (list (if (> n open) (p (str s \"(\") (dec n) (inc open)))\n                                  (if (> open 0) (p (str s \")\") (dec n) (dec open))))))]\n      (set (filter identity (flatten (p \"\" len 0)))))))", "user": "56018dd4e4b04bb52996e18f"}, {"problem": "195", "code": "(fn [n]\n  (letfn [(do-open [o c r]\n            (when (< 0 o)\n              (let [o' (dec o)\n                    r' (conj r \\()]\n                (lazy-cat\n                  (do-open o' c r')\n                  (do-close o' c r')))))\n          (do-close [o c r]\n            (if (zero? c)\n              (list (apply str r))\n              (when (< o c)\n                (let [c' (dec c)\n                      r' (conj r \\))]\n                  (lazy-cat\n                    (do-open o c' r')\n                    (do-close o c' r'))))))]\n;; zero parentheses should equal an empty set, don't you think?\n    (if (zero? n)\n      #{\"\"}\n      (set (do-open n n [])))))", "user": "561ca2eae4b064ca9f4b169b"}, {"problem": "195", "code": "(fn P [n] (if (= n 0) #{\"\"} (set (for [k (range 1 (inc n)) l (P (dec k)) r (P (- n k))] (str \"(\" l \")\" r)))))", "user": "55f6fe09e4b06e875b46cea2"}, {"problem": "195", "code": "(fn [x] (into #{} (loop [coll [\"\"]]\n                     (if (= (* 2 x) (count (first coll)))\n                       coll\n                       (recur (->> (for [path coll\n                                         :let [open (count (filter #(= \\( %) path))\n                                               close (count (filter #(= \\) %) path))]]\n                                     (list (when (< open x) (str path \"(\"))\n                                           (when (< close open)(str path \")\"))))\n                                   (apply concat)\n                                   (filter #(not (nil? %)))))))))", "user": "54db3d82e4b024c67c0cf75f"}, {"problem": "195", "code": "(fn parens\n  ([n] (parens \"\" n 0 0))\n  ([s n open close]\n   (if (= n close)\n     #{s}\n     (clojure.set/union\n      (if (< open n)\n        (parens (str s \"(\") n (inc open) close)\n        #{})\n      (if (< close open)\n        (parens (str s \")\") n open (inc close))\n        #{})\n      ))\n   ))", "user": "5307e4ece4b02e82168697a9"}, {"problem": "195", "code": "(fn puzzle-195 [n]\n  (case n\n    0 #{\"\"}\n    1 #{\"()\"}\n    (set \n      (concat\n        (for [as (puzzle-195 (dec n))]\n          (str \"(\" as \")\"))\n        (apply concat\n          (for [a (range 1 (/ (inc n) 2)) as (puzzle-195 a) bs (puzzle-195 (- n a))]\n            (list (str as bs) (str bs as))))))))", "user": "53286f84e4b09d4e7a9b5505"}, {"problem": "195", "code": "(fn parens\n  ([to-open] (parens to-open 0 \"\"))\n  ([to-open to-close acc]\n   (cond\n    (and (zero? to-open) (zero? to-close)) #{acc}\n    (or (neg? to-open) (neg? to-close)) #{}\n    :else (reduce into #{}\n                  [(parens (dec to-open) (inc to-close) (str acc \"(\"))\n                   (parens to-open (dec to-close) (str acc \")\"))]))))", "user": "5412ef7ee4b01498b1a719da"}, {"problem": "195", "code": "(fn [n] \n(let [ helper\n       (fn solve [cur left right]\n          (if\n           (= n left right)  #{(str cur)}\n           (let [ try-left   (if (< left n)      \n                               (solve  (str cur \"(\") (inc left) right))\n                  try-right  (if (and (< right n) (< right left))\n                               (solve  (str cur \")\") left (inc right))) ]\n               (clojure.set/union try-left try-right) \n           ))) ]\n  (helper \"\" 0 0)))", "user": "564127a9e4b08d4f616f5ef3"}, {"problem": "195", "code": "(fn parens\n  ([o] (set (parens o 0 \"\")))\n  ([o c s]\n     (let [left (if (> o 0)\n                  (parens (dec o) (inc c) (str s \"(\"))\n                  )\n           right (if (> c 0)\n                   (parens o (dec c) (str s \")\"))\n                   )]\n      (if (= 0 o c)\n        [s]\n        (concat left right)))))", "user": "4f6ba7bce4b07046d9f4efb0"}, {"problem": "195", "code": ";; see https://en.wikipedia.org/wiki/Dyck_language\n(fn dyck-set [n] (if (zero? n) #{\"\"}\n    (set (for [i (range n) a (dyck-set (- n i 1)) b (dyck-set i)]\n          (str \"(\" a \")\" b)))))", "user": "5281a445e4b0757a1b17143a"}, {"problem": "195", "code": "(fn balanced-parens\n  ([n] (balanced-parens n \"\" 0 #{}))\n  ([n so-far balance results]\n   (cond\n     (neg? balance) results\n     (= (count so-far) (* 2 n)) (if (zero? balance) (conj results so-far) results)\n     :else (let [upper-results (if (>= balance n)\n                                 results\n                                 (balanced-parens n (str so-far \"(\")\n                                                  (inc balance) results))]\n       (balanced-parens n (str so-far \")\") (dec balance) upper-results)))))", "user": "563f1493e4b08d4f616f5ecf"}, {"problem": "195", "code": "(fn gen-parens [n]\n  \"Generate all the possible balanced pairs of parens, given n pairs.\n   To do that, insert the new pair in every position of the previous generation.\"\n  (let [insert-new-pair (fn [s]\n                          \"Insert the new pair in every possible position in the string\"\n                          (map #(str (subs s 0 %) \"()\" (subs s %))\n                               ;; Only need to go through half of the collection + 1, thanks to symmetry.\n                               (range (inc (int (/ (count s) 2)))))\n                          )]\n    (loop [num-pairs 0\n           parens #{\"\"}]\n      (if (= num-pairs n)\n          parens\n          (recur (inc num-pairs) (set (mapcat insert-new-pair parens)))))))", "user": "500900dee4b0144d4f561e42"}, {"problem": "195", "code": "(fn [n]\n   ((fn foo [chars open close]\n      (if (= close n)\n        #{(apply str chars)}\n        (let [result #{}\n              result (if (> open close)\n                       (into result (foo (conj chars \")\") open (inc close)))\n                       result)\n              result (if (< open n)\n                       (into result (foo (conj chars \"(\") (inc open) close))\n                       result)]\n          result))\n      ) [] 0 0))", "user": "530b8580e4b02e82168697cc"}, {"problem": "195", "code": "(fn bs [n]\n  (letfn\n    [(nb [v l]\n            (let [ m {\\( 1, \\) -1}\n                   c (reduce + (map m v))]\n              (cond\n                (= l 0) v\n                (<= l c) #{(str v \\))}\n                (= c 0) #{(str v \\()}\n                :else #{(str v \\() (str v \\))}\n                )))\n           ]\n  (loop [s #{\"\"} l (* 2 n)]\n    (if (= l 0) s (recur (set (apply concat (map #(nb % l) s))) (dec l))\n    ))))", "user": "528e64b7e4b0239c8a67aedd"}, {"problem": "195", "code": "(fn [n]\n  (letfn [(parens [acc open close]\n                   (if (= 0 open close)\n                     (list (apply str acc))\n                     (concat\n                       (when (> open 0)\n                         (parens (conj acc \\() (dec open) (inc close)))\n                       (when (> close 0)\n                         (parens (conj acc \\)) open (dec close)))\n                       )))]\n    (set (parens [] n 0))))", "user": "54b54d1be4b05787c3b1639c"}, {"problem": "195", "code": "(fn paren-combos\n  ([n] (set (paren-combos n 0 [])))\n  ([num-avail num-open parens]\n   (if (= 0 num-avail num-open)\n     (list (apply str parens))\n     (concat\n       (when (pos? num-avail)\n         (paren-combos (dec num-avail)\n                       (inc num-open)\n                       (conj parens \\()))\n       (when (pos? num-open)\n         (paren-combos num-avail\n                       (dec num-open)\n                       (conj parens \\))))))))", "user": "52b02329e4b0c58976d9acc5"}, {"problem": "195", "code": "(fn parentheses [n]\n  (letfn [(internal-brackets [prefix current-opened open-bracket-remain close-bracket-remain]\n            (cond\n              (zero? close-bracket-remain) (list (reverse prefix))\n              (zero? open-bracket-remain) (internal-brackets\n                                            (cons :close prefix)\n                                            (dec current-opened)\n                                            open-bracket-remain\n                                            (dec close-bracket-remain))\n              (zero? current-opened) (internal-brackets\n                                       (cons :open prefix)\n                                       (inc current-opened)\n                                       (dec open-bracket-remain)\n                                       close-bracket-remain)\n              :else (concat (internal-brackets\n                              (cons :open prefix)\n                              (inc current-opened)\n                              (dec open-bracket-remain)\n                              close-bracket-remain)\n\n                            (internal-brackets\n                              (cons :close prefix)\n                              (dec current-opened)\n                              open-bracket-remain\n                              (dec close-bracket-remain)))))]\n    (set (map (fn [l] (apply str (map #(if (= % :open) \\( \\)) l)))\n              (internal-brackets nil 0 n n)))\n    )\n  )", "user": "563b9acbe4b0bfe05bf11827"}, {"problem": "195", "code": "(fn p [n]\n  (if (zero? n)\n    #{\"\"}\n    (into #{} \n          (for [k (range n) x (p k) y (p (- n k 1))]\n            (str \"(\" x \")\" y)))))", "user": "4eb97b2e535dfed6da9c6d54"}, {"problem": "195", "code": "(fn [n]\n  (letfn [\n          (bp [d l]\n            (cond\n              (= d l) (list (repeat l \\)))\n              (= 0 d) (map (partial cons \\() (bp 1 (- l 1)))\n              :else (concat\n                      (map (partial cons \\() (bp (+ d 1) (- l 1)))\n                      (map (partial cons \\)) (bp (- d 1) (- l 1)))\n                      )\n              )\n            )\n          ]\n    (set (map (partial apply str) (bp 0 (* 2 n))))\n    )\n  )", "user": "52f10094e4b05e3f0be25ee8"}, {"problem": "195", "code": "(fn [pairs]\n  (let [pair #\"\\(\\)\"]\n    (letfn [(nth-replace [s sub n]\n              (let [[flhs frhs] (clojure.string/split s pair 2)]\n                ((fn nrep [s1 s2 sub n]\n                    (if (= n 0) (str s1 sub s2)\n                        (let [[lhs rhs] (clojure.string/split s2 pair 2)]\n                          (recur (str s1 \"()\" lhs) rhs sub (dec n)))))  flhs frhs sub n))\n              )\n            (next-parens [s] (set (mapcat (fn [sub] \n                                            (map (fn [n] \n                                                   (nth-replace s sub n))\n                                                 (range (count (re-seq pair s))))) [\"(())\" \"()()\"])))]\n      (loop [s #{\"()\"}\n             c pairs]\n        (cond (= c 0) #{\"\"}\n              (= c 1) s\n              :else (recur (apply clojure.set/union (map next-parens s)) (- c 1)))))) \n)", "user": "55f09e7be4b06e875b46ce28"}, {"problem": "195", "code": "(fn generate-pairs [n]\n  (letfn [(-generate-pairs [acc l r]\n       (if (= 0 l r)\n         (list (apply str acc))\n         (concat\n          (when (> l 0)\n            (-generate-pairs (conj acc \\() (dec l) (inc r)))\n          (when (> r 0)\n            (-generate-pairs (conj acc \\)) l (dec r))))))]\n    (set (-generate-pairs [] n 0))))", "user": "5666500ee4b0e91d5f5c566d"}, {"problem": "195", "code": "(let [mem (atom {})]\n    (fn aux\n      [k]\n      (if (contains? @mem k)\n        (get @mem k)\n        (get (swap! mem (fn [x]\n                     (assoc x k\n                            (if (zero? k)\n                              #{\"\"}\n                              (set (concat\n                                    (map #(str \"(\" % \")\") (aux (dec k)))\n                                    (apply concat\n                                           (for [i (range 1 k)]\n                                             (for [st (aux i) end (aux (- k i))]\n                                               (str st end)))))))))) k))))", "user": "56588f4ee4b0f9d632dd84b6"}, {"problem": "195", "code": "(fn [n]\n          (letfn [(bt [n]\n                    (if (= n 0)\n                      (list nil)\n                      (reduce (fn [result i]\n                                (let [ls (bt i)\n                                      rs (bt (- n 1 i))]\n                                  (->> ls\n                                       (reduce (fn [r lt]\n                                                 (->> rs\n                                                      (map (fn [rt] [lt rt]))\n                                                      (into r))) [])\n                                       (map (fn [[l r]] (list \\x l r)))\n                                       (into result)))) [] (range n))))\n                  (rd [tr]\n                    (if (nil? tr)\n                      \"\"\n                      (let [[x l _] tr]\n                        (str \"(\" (loop [ch l r \"\"]\n                                   (if (nil? ch)\n                                     r\n                                     (let [[_ _ rt] ch]\n                                       (recur rt (str r (rd ch)))))) \")\"))))]\n            (->> n\n                 bt\n                 (map (fn [tr] (-> (list \\x tr nil)\n                                  rd\n                                  (subs 1 (inc (* 2 n))))))\n                 (into #{}))))", "user": "55316b8ae4b076ab5578f825"}, {"problem": "195", "code": "(fn parcombs\n  ([n] (set (parcombs n n [\"\"])))\n  ([lpc rpc acc]\n  (cond (= 0 rpc) acc\n        (= 0 lpc) (map #(apply str % (take rpc (repeat \")\"))) acc)\n        (> rpc lpc) (concat (parcombs (dec lpc) rpc (map #(str % \"(\") acc)) (parcombs lpc (dec rpc) (map #(str % \")\") acc)))\n        :else (parcombs (dec lpc) rpc (map #(str % \"(\") acc))\n        )))", "user": "55f2c898e4b06e875b46ce4b"}, {"problem": "195", "code": "(let [insert-parens\n        (fn [s i]\n          (str (subs s 0 i) \"()\" (subs s i))),\n        insert-parens-everywhere\n        (fn [l s]\n          (set (map (partial insert-parens s) (range (inc l)))))]\n    (fn bracketings [n]\n      {:pre [(integer? n), (not (neg? n))]}\n      (loop [acc #{\"\"}, l 0]\n        (if (= l (* 2 n)) acc\n            ;; Bracketings for `n+1` are obtained from bracketings for\n            ;; `n` by inserting \"()\" between each pair of adjacent\n            ;; characters in each bracketing.\n            (recur (apply clojure.set/union\n                          (map (partial insert-parens-everywhere l) acc))\n                   (+ l 2))))))", "user": "4fc6305de4b0ee37620e180b"}, {"problem": "195", "code": "(fn [n]\n          (letfn [(decode [arr] (apply str (map #(if (= % 1) \"(\" \")\") arr)) )\n                  (gen [c r]\n                    (if (= 0 c) r\n                                (gen (dec c)\n                                     (mapcat #(let [s (reduce + %)\n                                                    t (if (> s 0) [(conj % -1)]  [])]\n                                               (if (= s c) t (conj t (conj % 1)))\n                                               ) r)\n                                     )\n\n                                )\n                    )\n                  ]\n            (if (= 0 n)\n              #{\"\"}\n               (reduce #(conj %1 (decode %2)) #{}  (gen (dec (* 2 n)) [[1]]))\n            )\n          )\n          )", "user": "55eeb37ae4b0121d4835fdf3"}, {"problem": "195", "code": "(fn [o]\n  (set (flatten ((fn add [o c rs]\n                   (if (= 0 o) [(str rs (apply str (repeat c \")\")))]\n                     (if (= 0 c)\n                       [(add (dec o) (inc c) (str rs \"(\"))]\n                       [(add o (dec c) (str rs \")\")) (add (dec o) (inc c) (str rs \"(\"))])))\n                 o 0 \"\"))))", "user": "4f32a7f1e4b0d6649770a095"}, {"problem": "195", "code": "(fn parentheses \n  ([n] (parentheses n n))\n  ([left right]\n    (if (and (zero? left) (zero? right)) \n      #{\"\"}\n      (clojure.set/union\n        (when (> left 0)\n          (set (map #(str \"(\" % ) (parentheses (dec left) right))))\n        (when (> right left)\n          (set (map #(str \")\" % ) (parentheses left (dec right)))))))))", "user": "4eec82fe535d93acb0a668ae"}, {"problem": "195", "code": "(let\n  [nxt (fn [s]\n         (map #(str (apply str (first %)) \\( \\) (apply str (second %))) \n              (map #(split-at % (seq s)) \n                   (range (+ 1 (count (seq s)))))))]\n  (fn p [n]\n    (if (= n 0)\n      #{\"\"}\n      (into #{} (mapcat nxt (p (- n 1)))))))", "user": "541ef7e2e4b01498b1a71a92"}, {"problem": "195", "code": "(fn [n]\n  (into #{}\n        (map (partial apply str)\n             (get\n              (reduce\n               (fn [in key]\n                 (reduce\n                  (fn [out key]\n                    (assoc out key (concat\n                                    (map #(cons \\) %) (get in (dec key)))\n                                    (map #(cons \\( %) (get in (inc key))))))\n                  {} (range key -1 -2)))\n               {0 #{()}} (reverse (concat (range n) (range n 0 -1))))\n              0))))", "user": "54c5cc17e4b045293a27f624"}, {"problem": "195", "code": "(fn f \n  ([n] (set (f n \"\" 0 0)))\n  ([n s l r]\n  (cond\n     (= n l r) [s]\n     (= l r) (f n (str s \"(\") (inc l) r)\n     (= l n) (f n (str s \")\") l (inc r))\n     :else  (concat (f n (str s \"(\") (inc l) r)\n                    (f n (str s \")\") l (inc r))))))", "user": "50bce014e4b0594b91591c63"}, {"problem": "195", "code": "(fn [n]\n   (letfn [(paren [op cl st v]\n                    (cond (= 0 op cl) [v]\n                          (empty? st) (paren (dec op) cl [\\(] (conj v \\( ) )\n                           (= 0 op) (paren op (dec cl) (pop st) (conj v \\) ))                                \n                           :else  (concat (paren (dec op) cl (conj st \\() (conj v \\() )\n                                          (paren op (dec cl) (pop st) (conj v \\)) ))))]\n     (apply hash-set (map (partial apply str) (paren n n [] [])))))", "user": "5649615be4b0284900eef641"}, {"problem": "195", "code": "(fn [n] ((fn parens [xs opn cls]\n                 (cond\n                  (= cls 0) #{xs}\n                  (= opn 0) #{(str xs (clojure.string/join (repeat cls \")\")))}\n                  :else   (let [with_opening (parens (str xs \"(\") (- opn 1) cls) ]\n                            (if (< opn cls)\n                              (let [with_closing (parens (str xs \")\") opn  (- cls 1))]\n                                (clojure.set/union with_closing with_opening))\n                              with_opening))) \n                 ) \"\" n n))", "user": "54453f83e4b032a45b86939a"}, {"problem": "195", "code": "(fn [n]\n  (let [hbit' (+ n n)\n        hbit (dec hbit')\n        split (fn [m hb]\n                (loop [bit hb bs [] sum 0]\n                  (if (neg? bit)\n                    (if (= 0 sum) (apply str bs) nil)\n                    (let [bt (bit-test m bit)\n                          sum' (if bt (inc sum) (dec sum))]\n                      (if (< sum 0)\n                        nil\n                        (recur\n                         (dec bit)\n                         (conj bs (if bt \\( \\)))\n                         sum'))))))]\n    (if (= 0 n)\n      #{\"\"}\n      (->>\n       (range (bit-set 0 hbit) (bit-set 0 hbit') 2)\n       (map #(split % hbit))\n       (filter identity)\n       (set)))))", "user": "53ef7f77e4b0742d9025b0ce"}, {"problem": "195", "code": "(memoize\n (fn pairs [n]\n  (if (zero? n)\n    #{\"\"}\n    (set\n     (for [m (range n)\n           p (pairs m)\n           q (pairs (dec (- n m)))]\n       (str \\( p \\) q))))))", "user": "55dcb06ee4b050e68259b3b9"}, {"problem": "195", "code": "(fn legal-parens-nofor\n  ([n] (legal-parens-nofor \"\" n n))\n  ([prefix open-parens-left close-parens-left]\n   (set (letfn [(add-chars [p c1 c2] (apply str p (concat (repeat c1 \\() (repeat c2 \\)))))]\n          (concat\n           [(add-chars prefix open-parens-left close-parens-left)]\n           (mapcat (fn [x]\n                     (mapcat (fn [y]\n                               (legal-parens-nofor (add-chars prefix x y)\n                                 (- open-parens-left x)\n                                 (- close-parens-left y)))\n                             (range 1 (+ 1 x (- close-parens-left open-parens-left)))))\n                   (range 1 open-parens-left)))))))", "user": "56897739e4b0dcc4269f407d"}, {"problem": "195", "code": "(fn [n]\n    (letfn [(b [accum level opens]\n              (if (and (zero? level) (zero? opens))\n                (list accum)\n                (lazy-cat (when (pos? opens)\n                            (b (conj accum \\)) (inc level) (dec opens)))\n                          (when (pos? level)\n                            (b (conj accum \\() (dec level) opens)))))]\n      (set (map #(apply str %) (b '() 0 n)))))", "user": "5275f7a2e4b03e8d9a4a74d0"}, {"problem": "195", "code": "(fn [n]\n  (letfn [(gen-parantheses-series []\n                                  ((fn lazy-next [prev n]\n                                     (letfn [(all-sums [n]\n                                                       (map #(vector % (- n %)) (range 1 n)))\n                                             (gen-next [prev n]\n                                                       (if (= n 0)\n                                                         #{\"\"}\n                                                         (let [alterantives (all-sums n)\n                                                               joining (mapcat\n                                                                        (fn [[h t]]\n                                                                          (for [a (prev h) b (prev t)] (str a b)))\n                                                                        alterantives)]\n                                                           (into #{} (concat joining (map #(str \"(\" % \")\") (prev (dec n))))))))]\n                                       (let [current (gen-next prev n)]\n                                         (cons current (lazy-seq (lazy-next (conj prev current) (inc n))))))\n                                     ) [] 0))]\n    (nth (gen-parantheses-series) n)))", "user": "5654e024e4b0f9d632dd848d"}, {"problem": "195", "code": "(fn [n] ((reduce (fn [p n] (conj p (case n 0 #{\"\"}\n                          (into #{} (for [i (range n) j (range (- n i))\n                                          a (p i) b (p j) c (p (- n i j 1))]\n                                      (format \"%s(%s)%s\" a b c))))))\n                 [] (range (inc n))) n))", "user": "4e8612f8535db62dc21a62f2"}, {"problem": "195", "code": "(fn parens\n  ([open] (parens open 0 \"\" #{}))\n  ([open close cur res]\n   (cond\n     (zero? open)\n     (conj res (apply str cur (take close (repeat \")\"))))\n     (and (not (zero? open)) (zero? close))\n     (into res (parens (dec open) (inc close) (str cur \"(\") res))\n     :else\n     (into (parens (dec open) (inc close) (str cur \"(\") res)\n           (parens open (dec close) (str cur \")\") res)))))", "user": "55e206f3e4b050e68259b429"}, {"problem": "195", "code": "(fn [x]\n  (let [! (memoize (fn [! n]\n                     (cond (= n 0) #{\"\"}\n                           (= n 1) #{\"()\"}\n                           :else\n                           (set (apply concat\n                                       (map #(str \"(\" % \")\") (! ! (dec n)))\n                                       (for [i (range 1 n)\n                                             s1 (! ! i)\n                                             s2 (! ! (- n i))]\n                                         (vector (str s1 s2))))))))]\n    (! ! x)))", "user": "554680cbe4b0a04f7929953e"}, {"problem": "195", "code": "(fn [n]\n  (letfn [(help [acc {r :r l :l}]\n               (cond\n                (zero? r) [acc]\n                (zero? l) (help (str acc \\)) {:l l :r (dec r)})\n                (= l r) (help (str acc \\() {:l (dec l) :r r})\n                :else [(help (str acc \\() {:l (dec l) :r r})\n                       (help (str acc \\)) {:l l :r (dec r)})]))]\n    (set (flatten (help \"\" {:l n :r n})))))", "user": "554b8572e4b0a04f79299589"}, {"problem": "195", "code": "(fn __ [n]\n  (letfn [(f [n]\n             (if (zero? n) #{\"\"}\n               (reduce clojure.set/union\n                       (map (fn [k]\n                              (set\n                               (for [x (f k)\n                                     y (f (- (dec n) k))]\n                                 (str \"(\" x \")\" y))))\n                            (range n)))))]\n    ((memoize f) n)))", "user": "5416b4a2e4b01498b1a71a01"}, {"problem": "195", "code": "(fn p\n  ([n] (p [] (* n 2) 0 0))\n  ([a c z o]\n   (into #{}\n     (if (= c 0)\n       (when (= z o)\n         [(apply str (map #(if (= % 1) \\( \\)) a))])\n       (apply concat\n         [(when (<= o z)\n            (p (cons 0 a) (- c 1) (+ z 1) o))\n          (p (cons 1 a) (- c 1) z (+ o 1))])))))", "user": "52bacfa8e4b07a9af57922d6"}, {"problem": "195", "code": "(fn [n]\n   (letfn [(genParan [left right iresult fresult]\n              (if (= left right 0)\n                (conj fresult iresult)\n                (conj  \n                (if (> right 0)\n                    (genParan left (dec right) (str iresult \")\") fresult ))\n                (if (> left 0)\n                    (genParan (dec left) (inc right) (str iresult \"(\") fresult)))))]\n       (into #{} (remove nil? (flatten (genParan n 0 \"\" []))))))", "user": "567d18c9e4b05957ce8c61c4"}, {"problem": "195", "code": "(fn [n]\n  (letfn [(form-next [st limit]\n            (let [s (seq st)\n                     l (count s)\n                  o (count (filter #(= \\( %) s))\n                  s1 (str st \")\")\n                  s2 (str st \"(\")]\n              (cond (= l (dec limit))\n                    [s1]\n                    (and (< (- l o) o) (< o (/ limit 2)))\n                    [s1 s2]\n                    (< (- l o) o)\n                    [s1]\n                    :default\n                    [s2])))]\n    (if (zero? n) #{\"\"}\n        (loop [acc [\"(\"]\n               i 0]\n          (if (< i (dec (* 2 n)))\n            (recur (mapcat #(form-next % (* 2 n)) acc)\n                   (inc i))\n            (into #{} acc))))))", "user": "4fbd12a5e4b081705acca2fd"}, {"problem": "195", "code": "(fn [n] ; n - number of pairs of parentheses\n  (letfn [(gen [s]\n            (let [num-start (count (filter #(= \\( %) s)),\n                  num-end (count (filter #(= \\) %) s)),\n                  can-be-start? #(< num-start n),\n                  can-be-end? #(< num-end num-start)]\n              (cond (= n num-start num-end) [(apply str s)]\n                    :else (concat []\n                                  (if (can-be-start?)\n                                      (gen (conj s \\())\n                                      [])\n                                  (if (can-be-end?)\n                                      (gen (conj s \\)))\n                                      [])\n                                  ))))]\n    (if (zero? n) #{\"\"} (set (gen (vec \"(\"))))))", "user": "567695c2e4b05957ce8c6157"}, {"problem": "195", "code": "(fn f\n  ([n] (set (map (partial apply str) (f n n))))\n  ([l r]\n  (if (zero? l)\n    [(repeat r \\))]\n    (concat\n     (if (pos? l) (map cons (repeat \\() (f (dec l) r)))\n     (if (< l r)  (map cons (repeat \\)) (f l (dec r))))))))", "user": "50479524e4b0371827a27bc4"}, {"problem": "195", "code": "(fn parens ([n] (parens \"\" n 0 0))\n  ([s n open close]\n   (if (= n close)\n     #{s}\n     (clojure.set/union\n      (if (< open n)\n        (parens (str s \"(\") n (inc open) close)\n        #{})\n      (if (< close open)\n        (parens (str s \")\") n open (inc close))\n        #{})\n      ))\n   )\n  )", "user": "56bb9ccce4b0f26550335959"}, {"problem": "195", "code": "#(case %\n   0 #{\"\"}\n   1 #{\"()\"} \n   2 #{\"()()\" \"(())\"}\n   3 #{\"((()))\" \"()()()\" \"()(())\" \"(())()\" \"(()())\"}\n   9 (concat (repeat 6 \"(((()()()())\") [\"(((()()()())(())))\"])\n   10 (set (range 16796))\n   12 (concat (repeat 5000 \"(\") [\"(((((()()()()()))))(()))\"]))", "user": "5507cfd3e4b021ccfedb96ad"}, {"problem": "195", "code": "(fn foo [n]\n  (let [bar (memoize foo)]\n    (if (zero? n)\n      #{\"\"}\n      (into\n        #{}\n        (flatten\n          (for [i (range n)]\n            (for [a (bar i) b (bar (- n i 1))]\n              (str \\( a \\) b))))))))", "user": "56a01895e4b0542e1f8d149f"}, {"problem": "195", "code": "(fn [n] \n ((fn a [s]\n    (let [syms (frequencies s)\n          open (get syms \\( 0)\n          closed (get syms \\) 0)]\n      (cond \n       (= n open closed) #{s}\n       (= open closed) (recur (str s \\( ))\n       (> n open) (clojure.set/union \n                   (a (str s \\( ))\n                   (a (str s \\) )))\n       :else (recur (str s \\) ))))) \"\"))", "user": "56b86e64e4b0f26550335924"}, {"problem": "195", "code": "(fn parsX[l]\n\t(letfn\n\t\t[\n\t\t\t(parDecorate[n]\n\t\t\t\t(str \"(\" n \")\" ) \n\t\t\t)\n\n\t\t\t(parDecorateAll[x]\n\t\t\t\t(set (map parDecorate x)) \n\t\t\t)\n\n\n\n\t\t\t(combinations[s t]\n\t\t\t\t(for[i s j t]\n\t\t\t\t\t(str i j)\n\t\t\t\t)\n\t\t\t)\n\t\t\t(parCombinations[n m]\n\t\t\t\t(let [\n\t\t\t\t\tpn (parsX n)\n\t\t\t\t\tpm (parsX m)\n\t\t\t\t\t]\n\t\t\t\t\t(concat (combinations pn pm) (combinations pm pn))\n\t\t\t\t)\t\n\t\t\t)\n\n\t\t\t(parCombinationsV[v]\n\t\t\t\t(parCombinations (get v 0)(get v 1))\t\n\t\t\t)\n\n\n\t\t\t(couples[n]\n\t\t\t\t(set (map (comp vec sort vector) (range 1 n)(range (dec n) 0 -1)))\n\t\t\t)\n\n\n\t\t\t(parCouples[n]\n\t\t\t\t(set (mapcat parCombinationsV (couples n)))\n\t\t\t)\n\t\t]\n\t\t(cond \n\t\t\t(zero? l) (hash-set \"\")\n\t\t\t(= l 1) (hash-set \"()\")\n\t\t\t:else (clojure.set/union (parCouples l) (parDecorateAll(parsX (dec l))))  \n\t\t)\n\t)\n)", "user": "568820e8e4b0dcc4269f4067"}, {"problem": "195", "code": "(fn parens\n     ([n] (parens \"\" n 0 0))\n     ([s n open close]\n      (if (= n close)\n        #{s}\n        (clojure.set/union\n         (if (< open n)\n           (parens (str s \"(\") n (inc open) close)\n           #{})\n         (if (< close open)\n           (parens (str s \")\") n open (inc close))\n           #{})\n         ))\n      ))", "user": "5693a53ee4b0dcc4269f4106"}, {"problem": "195", "code": "(fn [n]\n  (let [d (* 2 n)]\n  (letfn [(nx [s]\n              (let [c (count s)\n                    f (frequencies s)\n                    o (- (get f \\( 0) (get f \\) 0))\n                    s1 (str s \")\")\n                    s2 (str s \"(\")]\n                (cond\n                  (and (even? c) (zero? o)) s2\n                  (and (>= c n) (= o (- d c))) s1\n                  :else (list s1 s2))))\n          (g [s] (set (flatten (for [i s] (nx i)))))]\n   (loop [s #{\"\"} t 0]\n     (if (= t d)\n       s\n       (recur (g s) (inc t)))))))", "user": "56bca51ae4b0f26550335963"}, {"problem": "195", "code": "#(let [result (transient [])\n      g (fn f [w B O]\n        \t(cond\n                (= 0 B O) (conj! result w)\n                (or (< B 0) (< O 0)) nil\n             \t:default (do\n                    (f (str w \")\") B (dec O))\n                    (f (str w \"(\") (dec B) (inc O)))))]\n                    (g \"\" % 0)\n                    (set (persistent! result)))", "user": "4fa30027e4b081705acca187"}, {"problem": "195", "code": "(fn f195 [n]\n  (letfn [(left-zip [open-left closed-left word]\n            (if (> open-left 0)\n              [(dec open-left) (inc closed-left) (str word \"(\")]\n              nil))\n\n          (right-zip [open-left closed-left word]\n            (if (> closed-left 0)\n              [open-left (dec closed-left) (str word \")\")]\n              nil))]\n    (loop [queue [[n 0 \"\"]]\n           res #{}]\n      (if-let [zip (first queue)]\n        (let [[open-left closed-left word] zip]\n          (if (and (zero? open-left)\n                   (zero? closed-left))\n            (recur (subvec queue 1)\n                   (conj res word))\n            (recur (-> queue\n                       (subvec 1)\n                       (into (keep seq [(left-zip open-left closed-left word)\n                                        (right-zip open-left closed-left word)])))\n                   res)))\n        res))))", "user": "55586905e4b0deb715856e2b"}, {"problem": "195", "code": "(fn [n] (let [o #(count (filter (fn [s] (= s %2)) %)) \n\t\t     x (fn [r t] (reduce #(let [f (o %2 \\()  \n\t\t\t\t\t\tg (< (o %2 \\)) f) \n\t\t\t\t\t\tj (if (< f n) (conj % (str %2 \\()) %)] \n\t\t\t\t\t    (if g (conj j (str %2 \\))) j))\n\t\t\t\t\t #{} r))] \n\t  (set (reduce #(x % %2) #{\"\"} (range (* n 2))))\n     )\n)", "user": "56c08696e4b060a8e693e3aa"}, {"problem": "195", "code": "(fn [n] (letfn [ (h [o c r]\n     (cond (and (= o 0) (= c 0)) (set r)\n       (= o 0) (h o (dec c) (map #(str % \")\") r))\n       (= o c) (h (dec o) c (map #(str % \"(\") r))\n       :else\n        (clojure.set/union\n          (h o (dec c) (map #(str % \")\") r))\n          (h (dec o) c (map #(str % \"(\") r))\n)))] (h n n #{\"\"})))", "user": "4fd11a93e4b04c3a95aa040a"}, {"problem": "195", "code": "(fn f [n]\n  (letfn [(f' [acc s openp closep]\n            (cond\n              ;; no more parens\n              (= n closep) (conj acc (apply str s))\n              ;; no more open parens\n              (= n openp) (f' acc (concat s (repeat (- n closep) \\))) n n)\n              (>= openp closep) (let [acc1 (f' acc (concat s [\\(]) (inc openp) closep)\n                                      acc2 (when (> openp closep) (f' acc (concat s [\\)]) openp (inc closep)))]\n                                  (concat acc1 acc2))))]\n    (->>\n     (f' [] [] 0 0)\n     set)))", "user": "569dd6e8e4b0542e1f8d1480"}, {"problem": "195", "code": "(fn [n]\n   (set ((fn f [pre]\n           (let [cright (count (re-seq #\"\\)\" pre))\n                 cleft  (count (re-seq #\"\\(\" pre))]\n             (cond (= cright n) [pre]\n                   (= cleft n) (f (str pre \")\"))\n                   (= cleft cright) (f (str pre \"(\"))\n                   (> cleft cright) (concat (f (str pre \"(\"))\n                                            (f (str pre \")\"))))\n             )) \"\")\n        ))", "user": "56f7ecdfe4b08e7d20b96834"}, {"problem": "195", "code": "(fn find-all-para [total]\n  (println total)\n  ((fn create-para [left right curstr] \n    (println left right curstr)\n    (if (<= total left) \n      (if (= left right) \n        #{curstr}      \n        (create-para left (inc right) (str curstr \")\"))\n      )    \n      (if (> left right) \n       \t(into #{} (concat (create-para (inc left) right (str curstr \"(\")) \n                          (create-para left (inc right) (str curstr \")\"))  \t\t\n                  )\n         )\n        \n      \t(if (= left right)\n        \t(create-para (inc left) right (str curstr \"(\"))\n        )\n      )\n    )\n  ) 0 0 \"\"))", "user": "57011eb3e4b08d47c97781d1"}, {"problem": "195", "code": "(fn [n]\n  (letfn [(parens [open close]\n                  \"markov walk\"\n                   (if (= n open close)\n                     '(\"\")\n                     (concat\n                       (when (< open n)\n                         (map #(str \"(\" %) (parens (inc open) close)))\n                       (when (and (< close n) (> open close))\n                         (map #(str \")\" %) (parens open (inc close))))\n                       )))]\n    (set (parens 0 0))))", "user": "56fbf83de4b07572ad1a88da"}, {"problem": "195", "code": "(fn [n]\n  (letfn [(f [open close]\n             (cond\n              (= 0 open) (list (repeat close \\)))\n              (= open close) (map #(conj % \\() (f (dec open) close))\n              (< open close) (lazy-seq (into (map #(conj % \\() (f (dec open) close)) \n                                             (map #(conj % \\)) (f open (dec close)))))))]\n    (set\n     (map (partial apply str) (f n n)))))", "user": "56ae214ce4b03c432f18735a"}, {"problem": "195", "code": "(fn [n]\n  (letfn [(parens [n s open close]\n            (if (= n close)\n              #{s}\n              (clojure.set/union\n               (if (< open n)\n                 (parens n (str s \"(\") (inc open) close)\n                 #{})\n               (if (< close open)\n                 (parens n (str s \")\") open (inc close))\n                 #{}))))]\n    (parens n \"\" 0 0)))", "user": "51852961e4b0da5a5be3babb"}, {"problem": "195", "code": "(fn [n] (->> (tree-seq\n                   #(let [[left right _] %] (and (>= n left) (>= n right)))\n                   #(let [[left right s] %]\n                     (cond\n                       (and (> n left) (>= left right)) [[(inc left) right (str s \"(\")] [left (inc right) (str s \")\")]]\n                       (and (= n left) (> left right)) [[left (inc right) (str s \")\")]]\n                       :else []\n                       ))\n                   [0 0 \"\"])\n                 (map #(% 2))\n                 (filter #(= (* 2 n) (count %)))\n                 (apply hash-set)\n                 ))", "user": "56a6051fe4b0542e1f8d14e5"}, {"problem": "195", "code": "(fn parens \n  ([n] (parens n n))\n  ([open close]\n   (letfn [(f [p x y]\n              (set (map #(clojure.string/join \"\" [p %])\n                        (parens x y))))]\n   (if (>= open close)\n     (if (= open 0)\n       #{\"\"}\n       (f \"(\" (dec open) close))\n     (clojure.set/union\n      (if (= open 0)\n        #{}\n        (f \"(\" (dec open) close))\n      (f \")\" open (dec close))))\n   )))", "user": "55f73078e4b06e875b46cea4"}, {"problem": "195", "code": "(fn f [n]\n    (set\n      (if (= n 0)\n        [\"\"]\n        (mapcat #(for [i (f %) j (f (- n % 1))]\n                   (str \"(\" i \")\" j))\n                (range n)))))", "user": "5714e82ae4b07c98581c3ac9"}, {"problem": "195", "code": "(fn paren [n]\n  (set ((memoize\n          (fn pp [n]\n            (if  (= n 0) #{\"\"}\n                 (for [i (range n)\n                       x (pp i)\n                       y (pp (- n (inc i)))]\n                   (str \"(\" x \")\" y))))) n)))", "user": "571e6d73e4b0145328a76292"}, {"problem": "195", "code": "(fn [n]\n    (letfn [(brackets [output open close pairs]\n              (if (== open close pairs)\n                [output]\n                (concat\n                  (if (< open pairs)\n                    (brackets (str output \"(\") (inc open) close pairs)\n                    [])\n                  (if (< close open)\n                    (brackets (str output \")\") open (inc close) pairs)\n                    []))))]\n      (set (brackets \"\" 0 0 n))))", "user": "4e8a170c535d3e98b802328f"}, {"problem": "195", "code": "(fn parens\n  ([n] (parens n n))\n  ([left right]\n   (if (and (zero? left) (zero? right))\n     #{\"\"}\n     (clojure.set/union\n       (when (> left 0)\n         (set (map #(str \"(\" %) (parens (dec left) right))))\n       (when (> right left)\n         (set (map #(str \")\" %) (parens left (dec right)))))))))", "user": "56cb4d06e4b0ea9b8538f72e"}, {"problem": "195", "code": "(fn [n]\n  (letfn [(aux [acc op cl]\n            (if (and (= op n) (= cl n))\n              [acc]\n              (concat\n               (if (< op n)  (aux (str acc \"(\") (inc op) cl))\n               (if (< cl op) (aux (str acc \")\") op (inc cl))))))]\n    (set (aux \"\" 0 0))))", "user": "57035ccfe4b08d47c97781ef"}, {"problem": "195", "code": "(fn [n]\n  (letfn [(p [out in acc]\n            (if (= out in n) \n              (list (apply str acc))\n              (into\n               (when (< out n)\n                 (p (inc out) in (cons \\) acc)))\n               (when (< in out)\n                 (p out (inc in) (cons \\( acc))))))]\n    (set (p 0 0 '()))))", "user": "5712854ce4b07c98581c3a89"}, {"problem": "195", "code": "(fn gen\n    [n]\n    (letfn [(genlr [l r]\n              (cond\n                (and (= l 0) (= r 0)) #{\"\"}\n                :else (let [wl (if (> l 0)\n                                 (set (map #(str \"(\" %) (genlr (- l 1) r)))\n                                 #{})\n                            wr (if (> r l)\n                                 (set (map #(str \")\" %) (genlr l (- r 1))))\n                                 #{})]\n                        (clojure.set/union wl wr))))]\n     (genlr n n)))", "user": "56eaad95e4b04a395b9a040f"}, {"problem": "195", "code": "(fn parentheses \n  ([n] (parentheses n n))\n  ([left right]\n    (if (and (zero? left) (zero? right)) \n      #{\"\"}\n      (clojure.set/union\n        (when (> left 0)\n          (set (map #(str \"(\" % ) (parentheses (dec left) right))))\n        (when (> right left)\n          (set (map #(str \")\" % ) (parentheses left (dec right)))))))))", "user": "56ab7578e4b03c432f18733d"}, {"problem": "195", "code": "(fn [n]\n  (letfn [(parens [acc open close]\n                   (if (= 0 open close)\n                     (list (apply str acc))\n                     (concat\n                       (when (> open 0)\n                         (parens (conj acc \\() (dec open) (inc close)))\n                       (when (> close 0)\n                         (parens (conj acc \\)) open (dec close)))\n                       )))]\n    (set (parens [] n 0))))", "user": "570794d8e4b0b0fb43fd068b"}, {"problem": "195", "code": "(fn pairs\n  [n]\n  (into #{}\n        ((fn gen [open closed text out]\n           (concat (if (< open n)\n                     (gen (inc open) closed (str text \"(\") []))\n                   (if (< closed open)\n                     (gen open (inc closed) (str text \")\") []))\n                   (if (= closed n)\n                     (conj out text))))\n         0 0 \"\" []))\n  )", "user": "5545477fe4b0a04f79299531"}, {"problem": "195", "code": "(fn [n]\n  (set\n    (map first\n      (reduce\n        (fn [combs left]\n          (reduce\n            (fn [acc [comb lvl]]\n              (let [open  [(str comb \"(\") (inc lvl)]\n                    close [(str comb \")\") (dec lvl)]]\n                (cond\n                  (zero? lvl)  (conj acc open)\n                  (= lvl left) (conj acc close)\n                  :else        (conj acc open close))))\n            #{}\n            combs))\n        #{[\"\" 0]}\n        (range (+ n n) 0 -1)))))", "user": "573d58c8e4b05c31a32c0811"}, {"problem": "195", "code": "(fn balanced-paren [n]\n  (letfn [(paren [open close res]\n            (if (= 0 open close)\n              (list (apply str res))\n              (concat\n                (when (> open 0)\n                  (paren (dec open) (inc close) (conj res \\()))\n                (when (> close 0)\n                  (paren open (dec close) (conj res \\)))))))]\n    (set (paren n 0 []))))", "user": "572ea970e4b0cd1946bd0f89"}, {"problem": "195", "code": "(fn [c]\n  (letfn [(to-brackets [v] (apply str (map #(if (= 0 %) \\( \\)) v)))\n          (final-entry [c] (take c (interleave (repeat 0) (repeat 1))))\n          (matched? [a] (= (count (filter zero? a)) (count (filter pos? a))))\n          (next-entry [v]\n            (loop [[f s & r] (reverse v)\n                   acc []\n                   done false\n                   top false]\n              (if (= (count acc) (count v))\n                (reverse acc)\n                (if done\n                  (if top\n                    (reverse (concat\n                               (repeat (count (filter pos? acc)) 1)\n                               (repeat (count (filter zero? acc)) 0)\n                               [f s]\n                               r))\n                    (recur (cons s r) (conj acc f) done top))\n                  (if (and (pos? f)\n                           (zero? s)\n                           (not (matched? acc)))\n                    (recur (cons 1 r) (conj acc 0) true (or (every? zero? r) (pos? (last acc))))\n                    (recur (cons s r) (conj acc f) done top))))))]\n    (let [init (concat (repeat c 0) (repeat c 1))\n          end (final-entry (* c 2))]\n      (set\n        (map to-brackets\n             (concat\n               (take-while #(not= end %) (iterate next-entry init))\n               [end]))))))", "user": "55c4cda5e4b0e31453f649a5"}, {"problem": "195", "code": "(fn f\n  ([r] (f r 0))\n  ([r d]\n    (into #{}\n      (if (and (zero? r) (zero? d))\n        [\"\"]\n        (concat\n          (if (pos? r)\n            (map #(str \"(\" %) (f (dec r) (inc d)))\n            [])\n          (if (pos? d)\n            (map #(str \")\" %) (f r (dec d)))\n            []))))))", "user": "4ebaf790535dfed6da9c6d6e"}, {"problem": "195", "code": "(fn gen [n]\n  (if (zero? n)\n    #{\"\"}\n    (set \n      (for [i (range n)\n            fst (gen i) \n            lst (gen (- (dec n) i))]\n        (str \n          (str \"(\" fst \")\")\n          lst)))))", "user": "574dfcb8e4b02ea11479923a"}, {"problem": "195", "code": "(fn par [n]\n  (case n\n    0 #{\"\"}\n    1 #{\"()\"}\n    (let [pars (map par (range 1 n))]\n      (loop [o #{} i 0 m (- n 2)]\n        (if (< i (dec n))\n          (recur (apply conj o\n                        (for [x (nth pars i)\n                              y (nth pars m)]\n                          (str x y)))\n                 (inc i)\n                 (dec m))\n          (apply conj o\n                 (map #(str \"(\" % \")\")\n                      (last pars))))))))", "user": "57533bc1e4b02ea1147992a6"}, {"problem": "195", "code": "(fn [n]\n  (letfn [(f [s]\n            (let [c (count s)]\n              (map #(str (subs s 0 %) \"()\" (subs s % c)) (range (inc c)))))]\n    (loop [cs #{\"\"} num n]\n      (if (zero? num)\n        cs\n        (recur (set (mapcat f cs)) (dec num))))))", "user": "4e9519b4535dbda64a6f6b2d"}, {"problem": "195", "code": "(fn parentheses\n  ([n] (parentheses \"\" n 0 0))\n  ([s n o c]\n   (if (= n c)\n     #{s}\n     (clojure.set/union\n      (if (< o n)\n        (parentheses (str s \"(\") n (inc o) c)\n        #{})\n      (if (< c o)\n        (parentheses (str s \")\") n o (inc c))\n        #{})))))", "user": "534fa9dae4b084c2834f4acf"}, {"problem": "195", "code": "(fn ff [n]\n  (let [f (fn f [l r s]\n          (cond (zero? r) [s]\n                (zero? l) [(apply str s (repeat r \")\"))]\n                (= l r) (f (dec l) r (str s \"(\"))\n                :else (lazy-cat (f (dec l) r (str s \"(\"))\n                                (f l (dec r) (str s \")\")))))]\n    (set (f n n \"\"))))", "user": "56102f50e4b05f002753df6b"}, {"problem": "195", "code": "(fn parentheses \n  ([n] (parentheses n n))\n  ([left right]\n    (if (and (zero? left) (zero? right)) \n      #{\"\"}\n      (clojure.set/union\n        (when (> left 0)\n          (set (map #(str \"(\" % ) (parentheses (dec left) right))))\n        (when (> right left)\n          (set (map #(str \")\" % ) (parentheses left (dec right)))))))))", "user": "5764457ae4b0994c1922fbf3"}, {"problem": "195", "code": "(fn parentheses \n  ([n] (parentheses n n))\n  ([left right]\n    (if (and (zero? left) (zero? right)) \n      #{\"\"}\n      (clojure.set/union\n        (when (> left 0)\n          (set (map #(str \"(\" % ) (parentheses (dec left) right))))\n        (when (> right left)\n          (set (map #(str \")\" % ) (parentheses left (dec right)))))))))", "user": "50e90813e4b033b0e80d11e7"}, {"problem": "195", "code": "#(set (map (comp (partial apply str) last) (loop [i (* 2 %) s [[% 0 []]]]\n           (if (= i 0)\n             s\n             (recur (dec i) (mapcat (fn[[a d t]]\n                                      (cond (= d 0) [[(dec a) (inc d) (conj t \\()]]\n                                            (= a 0) [[a (dec d) (conj t \\))]]\n                                            1 [[(dec a) (inc d) (conj t \\()] [a (dec d) (conj t \\))]]))\n                                    s))))))", "user": "56824e1be4b0945ebc182a91"}, {"problem": "195", "code": "(fn permutate-parens ([npairs] (permutate-parens \"\" 0 0 (* 2 npairs) npairs))\n  ([s score open n openlimit]\n  (if (and (>= score 0) (<= open openlimit))\n    (if (= n 0)\n      (if (= score 0) #{s})\n      (clojure.set/union\n              (permutate-parens  (str s \"(\") (inc score) (inc open) (dec n) openlimit)\n              (permutate-parens  (str s \")\") (dec score) open (dec n) openlimit))))))", "user": "578d459ee4b0ebec4cfb7567"}, {"problem": "195", "code": "(fn [mc]\n  (letfn [(paren [mc oc cc p]\n            (cond\n              (zero? mc) (list \"\")\n              (zero? oc) (paren mc (inc oc) cc (str p \"(\"))\n              (and (< oc mc) (< cc mc)) (concat (paren mc (inc oc) cc (str p \"(\"))\n                                                (if (< cc oc)\n                                                  (paren mc oc (inc cc) (str p \")\"))\n                                                  (list)))\n              (and (= oc mc) (< cc mc)) (paren mc oc (inc cc) (str p \")\"))\n              :else (list p)))]\n     (set (paren mc 0 0 \"\"))))", "user": "4ee528fb535d1385b2869d87"}, {"problem": "195", "code": "(fn par [n]\n  (case n\n    0 #{\"\"}\n    1 #{\"()\"}\n    (let [pars (map par (range 1 n))]\n      (loop [o #{} i 0 m (- n 2)]\n        (if (< i (dec n))\n          (recur (apply conj o\n                        (for [x (nth pars i)\n                              y (nth pars m)]\n                          (str x y)))\n                 (inc i)\n                 (dec m))\n          (apply conj o\n                 (map #(str \"(\" % \")\")\n                      (last pars))))))))", "user": "5798205ce4b039eba2ecb10e"}, {"problem": "195", "code": "(fn [n]\n    (set ((fn paras-gen [output open close]\n            (if (= n open close)\n              [output]\n              (concat\n                (if (< open n)\n                  (paras-gen (str output \"(\") (inc open) close))\n                (if (< close open)\n                  (paras-gen (str output \")\") open (inc close))))))\n           \"\" 0 0)))", "user": "5180c69ae4b06b8caf33fa00"}, {"problem": "195", "code": "(fn par [n]\n  (case n\n    0 #{\"\"}\n    1 #{\"()\"}\n    (let [pars (map par (range 1 n))]\n      (loop [o #{} i 0 m (- n 2)]\n        (if (< i (dec n))\n          (recur (apply conj o\n                        (for [x (nth pars i)\n                              y (nth pars m)]\n                          (str x y)))\n                 (inc i)\n                 (dec m))\n          (apply conj o\n                 (map #(str \"(\" % \")\")\n                      (last pars))))))))", "user": "57982bace4b039eba2ecb10f"}, {"problem": "195", "code": "(fn bps\n  ([n] (into #{} (bps n n \"\")))\n  ([o c s]\n    (flatten (if (and (zero? o) (zero? c))\n      [s]\n      (let [need-open (> o 0)\n            need-close (> c o)]\n        (if (and need-open need-close)\n          [(bps (dec o) c (str s \\()) (bps o (dec c) (str s \\)))]\n          (if (not-any? identity [need-open need-close])\n            '()\n            (if need-open (bps (dec o) c (str s \\()) (bps o (dec c) (str s \\)))))))))))", "user": "55ede35ce4b0121d4835fde1"}, {"problem": "195", "code": "(fn PP [n]\n  (letfn [(step-fn [depth no nc]\n            (if (zero? nc)  #{ \"\" }\n              (if (zero? no) #{ (apply str (repeat nc \\) )) }\n                (if (zero? depth) \n                  (set (map #(str \\( % ) (step-fn 1 (dec no) nc)))\n                  (set (concat (map #(str \\( % ) (step-fn (inc depth) (dec no) nc))\n                               (map #(str \\) % ) (step-fn (dec depth) no (dec nc)))))))))]\n    (step-fn 0 n n)))", "user": "579f4812e4b05302be0b72fb"}, {"problem": "195", "code": "(fn f [n]\n  (letfn [(rec [open close s]\n            (if (and (zero? open) (zero? close))\n                #{s}\n                (clojure.set/union\n                  (if (> open 0)\n                    (rec (dec open) (inc close) (str s \"(\")))\n                  (if (> close 0)\n                    (rec open (dec close) (str s \")\"))))))]\n    (rec n 0 \"\")))", "user": "51e00020e4b01188f0627534"}, {"problem": "195", "code": "(fn [num-pairs]\n  (let [cat-combinations (fn [parens1 parens2]\n                           (set (for [p1 parens1\n                                      p2 parens2]\n                                  (str p1 p2))))]\n    (last (reduce (fn [lesser-combs n]\n              (conj lesser-combs\n                    (if (= n 0)\n                      #{\"\"}\n                      (apply clojure.set/union\n                             (set (map (fn [paren-str]\n                                          (str \"(\" paren-str \")\"))\n                                       (last lesser-combs)))\n                             (for [i (range (count lesser-combs))\n                                    :when (> i 0)\n                                    :let [nth-lesser (get lesser-combs i)\n                                          lesser-compl (get lesser-combs (- n i))]]\n                                (cat-combinations nth-lesser lesser-compl))))))\n            []\n            (range (inc num-pairs))))))", "user": "541709b0e4b01498b1a71a06"}, {"problem": "195", "code": "(fn [n] (let [brackets (fn brkts2 [res opening closing open] \n\t\t(if (and (zero? opening) (zero? closing))\n\t\t\t(vec [res])\n\t\t\t(cond\n\t\t\t\t(and (> opening 0) (> closing 0) (> open 0))\n\t\t\t\t\t(concat (brkts2 (str res \"(\") (dec opening) closing (inc open)) (brkts2 (str res \")\") opening (dec closing) (dec open)))\n\t\t\t\t\n\t\t\t\t(and (> opening 0) (> closing 0) (= open 0))\n\t\t\t\t\t(brkts2 (str res \"(\") (dec opening) closing (inc open))\n\t\t\t\t(> opening 0)\n\t\t\t\t\t(let [res (str res (reduce str (repeat opening \"(\")))]\n\t\t\t\t\t\t(vec [res]))\n\t\t\t\t\t\n\t\t\t\t(and (> closing 0) (= closing open))\n\t\t\t\t\t(let [res (str res (reduce str (repeat closing \")\")))]\n\t\t\t\t\t\t(vec [res])))))]\n\t\t\t(set (brackets \"\" n n 0))))", "user": "57986b76e4b039eba2ecb116"}, {"problem": "195", "code": "(let [lp \"(\"\n      rp \")\"]\n  (letfn\n    [\n    (multiply [f s]\n      (loop [s s\n             c (count s)]\n        (let [step (into s (mapcat f s))\n              count-step (count step)]\n          (if\n            (= c count-step)\n            step\n            (recur step count-step)))))\n    (mconj [b a c]\n      (if b (conj c a) c))\n    (step [[total-left open-left target-total s]]\n      (->> []\n        (mconj (and (zero? open-left) (= total-left target-total)) [total-left open-left target-total s])\n        (mconj (> open-left 0)                                     [total-left (dec open-left) target-total (str s rp)])\n        (mconj (< total-left target-total)                         [(inc total-left) (inc open-left) target-total (str s lp)])))\n    (solve [n]\n      ; spurious timeout on 12\n      (if (= n 12) (take 5001 (repeat \"(((((()()()()()))))(()))\"))\n      (->>\n        (multiply step #{[0 0 n \"\"]})\n        (filter #(= (* 2 n) (count (last %))))\n        (map last)\n        set)))\n    ]\n    solve))", "user": "57717915e4b0979f896515b3"}, {"problem": "195", "code": "(fn all-paren [n] (if (== n 0) #{\"\"}\n    (into #{} (for [i (range n) j (all-paren i) k (all-paren (- n 1 i))]\n        (str \"(\" j \")\" k)))))", "user": "51cbdee1e4b08d8387cbede1"}, {"problem": "195", "code": "(fn myf [n]\n   (letfn [(sub [coll n]\n             (let [numOfOpen (count (filter #(= \\( %) coll))\n                   numOfClose (count (filter #(= \\) %) coll))]\n               (cond (and (< numOfOpen n) (< numOfClose numOfOpen)) [(conj coll \\() (conj coll \\))]\n                     (and (< numOfOpen n) (= numOfClose numOfOpen)) [(conj coll \\()]\n                     (= numOfOpen n) [(conj coll \\))])))]\n     (if (zero? n) #{\"\"}\n       (loop [res [[]]]\n         (if (= (* 2 n) (count (first res))) (apply hash-set (map #(apply str %) res))\n           (recur (mapcat #(sub % n) res))          )))))", "user": "577c3da9e4b0c8d87281f6b9"}, {"problem": "195", "code": "(let [m-f (memoize\n           (fn [m-f n]\n             (if (zero? n)\n               #{\"\"}\n               (loop [i 1 c #{}]\n                 (if (< i (* n 2))\n                   (recur (+ 2 i) (into c \n                                        (for [x (m-f m-f (/ (dec i) 2)) \n                                              y (m-f m-f (/ (- (* n 2) 1 i) 2))]\n                                          (str \"(\" x \")\" y))))\n                   c)))))\n      m-f (partial m-f m-f)]\n  m-f)", "user": "5799ff45e4b05b1deef9add1"}, {"problem": "195", "code": "(fn [n]\n  (letfn [(g [o c s]\n            (if (= (* 2 n) (+ o c))\n              (list s)\n              (concat\n                (when (< o n)\n                  (g (inc o) c (str s \"(\")))\n                (when (> o c)\n                  (g o (inc c) (str s \")\"))))))]\n    (into #{} (g 0 0 \"\"))))", "user": "53d78b64e4b0e771c3025466"}, {"problem": "195", "code": "(fn parenthesis-combinations\n   [n]\n   (letfn [(iter [combinations c]\n             (if (= 0 c) combinations\n                        (iter (distinct (mapcat (fn [combination]\n                                      (distinct (map (fn [n]\n                                                       (let [[before after] (split-at n combination)]\n                                                         (apply str (concat before \"()\" after)))) (range 0 n)))) combinations)) (dec c))))]\n     (into #{} (iter (list \"\") n))))", "user": "4e9ff8d0535d7eef3080729c"}, {"problem": "195", "code": ";not passed\n;#(letfn [(extendMemory [memory n] \n;                     (assoc memory n \n;                            (reduce conj #{}\n;                                    (flatten (map\n;                                              (fn [s] \n;                                                (if (empty? s) [\"()\"]\n;                                                    (flatten (for [x (range (count s))] \n;                                                               (apply str (flatten (interpose \"()\" (split-at x s))))))))\n;                                              (memory (dec n)))))))]\n;    ((reduce extendMemory {0 #{\"\"}} (range 1 (inc %))) %))\n#((reduce (fn [a n]\n            (assoc a n (into #{}\n                             (concat\n                              (for [i (range 1 n) f (a i) s (a (- n i))] (str f s))\n                              (for [j (a (- n 1))] (str \\( j \\)))))))\n          {0 #{\"\"}}\n          (range 1 (+ % 1))) %)", "user": "574abbfbe4b02ea114799200"}, {"problem": "195", "code": "(fn P [n]\n  (case n\n    0 #{\"\"}\n    1 #{\"()\"}\n    (into #{} (for [i (range 1 (inc n)) x (P (dec i)) y (P (- n i))] (str \"(\" x \")\" y)))))", "user": "57015a1de4b08d47c97781d4"}, {"problem": "195", "code": "(fn __ [n]\n  (let [r-f (fn [[acc prev i] remaining]\n              (if (and (= prev \\() (= remaining \\)))\n                [(conj acc i) remaining (inc i)]\n                [acc remaining (inc i)]))\n\n        matching-indices\n        (fn [s]\n          (first (reduce r-f [[] nil -1] s)))\n\n        do-replace\n        (fn [s i]\n          (let [[pre post] (split-at i (into [] s))\n                post (rest (rest post))]\n            (map #(apply str (concat pre % post)) [\"(())\" \"()()\"])))\n\n        do-thing\n        (fn [s]\n          (let [matching (matching-indices s)]\n            (into #{} (mapcat #(do-replace s %) matching))))\n\n        solve\n        (fn [n]\n          (if (= 0 n)\n            #{\"\"}\n            (loop [n (dec n)\n                   acc [\"()\"]]\n              (if (= n 0)\n                (into #{} acc)\n                (let [next-seq (into #{} (mapcat do-thing acc))]\n                  (recur (dec n) next-seq))))))]\n    (->> (solve n)\n         (map #(apply str %))\n         (into #{}))))", "user": "52463059e4b09dbe66b56198"}, {"problem": "195", "code": "(fn [n]\n  (letfn [(path\n    ([n] (path n 0 0 \"\" []))\n    ([n c o s r]\n     (if (= n c) (concat r [s])\n       (if (> n (+ c o))\n         (if (> o 0)\n           (concat r \n                   (path n c (inc o) (str s \"(\") r) \n                   (path n (inc c) (dec o) (str s \")\") r))\n           (concat r \n                   (path n c (inc o) (str s \"(\") r))) \n         (concat r \n                 (path n (inc c) (dec o) (str s \")\") r))))))]\n    (set (path n))))", "user": "57d9f603e4b0bd073c20240a"}, {"problem": "195", "code": "(fn f\n  ([n] (set (map (partial apply str) (f n 0 0 []))))\n  ([n o c l]\n   (if (= (count l) (* 2 n)) [l]\n       (concat (if (< o n) (f n (inc o) c (conj l \"(\" )))\n               (if (< c o) (f n o (inc c) (conj l \")\" )))))))", "user": "57c796b4e4b05aa3c4741d08"}, {"problem": "195", "code": "(letfn\n [(helper [prefix open-count close-count]\n    (concat\n     (when (pos? open-count)\n       (helper (str prefix \"(\") (dec open-count) (inc close-count)))\n     (when (pos? close-count)\n       (helper (str prefix \")\") open-count (dec close-count)))\n     (when (every? zero? (list open-count close-count))\n       (list prefix))))]\n  (fn [n] (set (helper \"\" n 0))))", "user": "521e8227e4b0dd19981ad082"}, {"problem": "195", "code": "(fn parentheses \n  ([n] (parentheses n n))\n  ([left right]\n    (if (and (zero? left) (zero? right)) \n      #{\"\"}\n      (clojure.set/union\n        (when (> left 0)\n          (set (map #(str \"(\" % ) (parentheses (dec left) right))))\n        (when (> right left)\n          (set (map #(str \")\" % ) (parentheses left (dec right)))))))))", "user": "57df309ee4b0bd073c20245f"}, {"problem": "195", "code": "(fn parens \n  ([n]\n   (set (parens n n [])))\n  ([l r ret]\n   (cond (= r 0) (list (apply str ret))\n         (> l 0) (concat (parens (dec l) r (conj ret \\())\n                         (when (> r l)\n                           (parens l (dec r) (conj ret \\)))))\n         :else (parens l (dec r) (conj ret \\))))))", "user": "571c2babe4b07c98581c3b73"}, {"problem": "195", "code": "(fn gen-legal-parentheses\n   [cnt]\n   (letfn [(glp [[a b]]\n             (cond\n               (and (zero? a) (zero? b)) #{\"\"}\n               (zero? a) (set (map #(str \")\" %)\n                                   (glp [a (dec b)])))\n               (>= a b) (set (map #(str \"(\" %)\n                                  (glp [(dec a) b])))\n               :else (set (concat (map #(str \"(\" %)\n                                       (glp [(dec a) b]))\n                                  (map #(str \")\" %)\n                                       (glp [a (dec b)]))))))]\n     (glp [cnt cnt])))", "user": "56a36f76e4b0542e1f8d14ca"}, {"problem": "195", "code": "(fn parens\n    ([n]\n      (parens \"\" n 0 0)\n    )\n\n    ([s n open close]\n      (if (= n close)\n        #{s}\n        (clojure.set/union\n          (if (< open n)\n            (parens\n              (str s \"(\") n (inc open) close)\n              #{}\n            )\n            (if (< close open)\n              (parens (str s \")\") n open (inc close)\n            )\n            #{}\n          )\n        )\n      )\n    )\n  )", "user": "5784e177e4b0ebec4cfb74cf"}, {"problem": "195", "code": "(fn [n]\n    (->> (reduce (fn [acc _]\n                   (mapcat\n                    (fn [[s open paired]]\n                      (cond\n                        (= 0 open)\n                        [[(str s \\() 1 0]]\n\n                        (< 0 open n)\n                        (if (< paired open)\n                          [[(str s \\() (inc open) paired]\n                           [(str s \\)) open (inc paired)]]\n                          [[(str s \\() (inc open) paired]])\n\n                        :else\n                        [[(str s \\)) open paired]]\n                        ))\n                    acc))\n                 [[\"\" 0 0]]\n                 (range (* n 2)))\n         (map first)\n         set))", "user": "4e6a0667535d8ccf87e9fe9e"}, {"problem": "195", "code": "(fn allparens [n]\n  (cond (zero? n) #{\"\"}\n        (= 1 n) #{\"()\"}\n        :ELSE \n        (let [instr #(str (subs %1 0 %3) %2 (subs %1 %3))]\n          (set (mapcat #(map (fn [s i] (instr s \"()\" i))\n                            (repeat (count %) %) (range))\n                      (allparens (dec n)))))))", "user": "579d9601e4b05b1deef9ae18"}, {"problem": "195", "code": "(fn c195\n  [n]\n  (loop [num n\n         result #{\"\"}]\n    (if (= 0 num)\n      result\n      (recur (dec num) (reduce (fn [r v]\n                                 (reduce #(conj %1 (str (subs v 0 %2) \"()\" (subs v %2))) r (range (inc (count v)))))\n                               #{} result)))))", "user": "57d0cd58e4b0bd073c20235e"}, {"problem": "195", "code": "(fn generate-parentheses [n]\n               (letfn [(add-parenthese-to [prev]\n                         (apply clojure.set/union (for [p prev]\n                                (if (> (second p) 0)\n                                  (if (< (second p) (- (* 2 n) (count (first p))))\n                                    (hash-set [(str (first p) \")\") (dec (second p))] [(str (first p) \"(\") (inc (second p))])\n                                    (hash-set [(str (first p) \")\") (dec (second p))]))\n                                  (hash-set [(str (first p) \"(\") (inc (second p))])))))]\n                 (set (map #(first %) (nth (iterate add-parenthese-to #{[\"\" 0]}) (* 2 n))))))", "user": "5746061ae4b009280f9f2b5b"}, {"problem": "195", "code": "(fn [n]\n  (letfn [(ps [remaining open path]\n            (if (= remaining open 0)\n              [(clojure.string/join path)]\n              (concat\n               (if (> remaining 0)\n                 (ps (dec remaining) (inc open) (conj path \"(\")))\n               (if (> open 0)\n                 (ps remaining (dec open) (conj path \")\"))))))]\n    (set (ps n 0 []))))", "user": "57a4fa50e4b0a966079561f1"}, {"problem": "195", "code": "(fn g [f n]\n  (or ({n #{\"\"}} 0)      \n      (let [u (f #{\"\"} (dec n))\n            r (map #(->> % (map {\\( \\) \\) \\(}) (apply str)) u)\n            t #(count (filter #{\\)} %))\n            z (fn [x]\n                (zero? \n                  (reduce \n                    (fn [i e] (#(if (neg? %) (- n) %) (+ i ({\\( 1} e -1))))\n                    0 x)))]\n         (set (for [l u r r :let [s (str \"(\" l r \")\")] :when (z s)] s)))))\n(fn f [i e]\n  (if (zero? e)\n      i\n      (let [e1 [\"(\" \")\"] e2 [\"()\" \"((\" \")(\" \"))\"]\n            t (> (quot e 2) 0)\n            l (for [a i b (if t e2 e1)] (str a b))]\n        (f (set l) (if t (- e 2) (dec e))))))", "user": "548b7db8e4b0e286459a11fd"}, {"problem": "195", "code": "(fn [n]\n  (letfn [\n    (pile-minus\n      ([mp what] (pile-minus mp what 1))\n      ([mp what n]\n      {:pre [(or (= :open what) (= :close what))\n             (pos? n)]}\n      (cond\n        (= :open what)\n          (update-in mp [:open] (partial + (- n)))\n        (= :close what)\n          (update-in mp [:close] (partial + (- n))))))\n    (put-token [tok]\n      {:pre [(or (= :open tok) (= :close tok))]}\n      (fn loc-put-n\n        ([m where] (loc-put-n m where 1))\n        ([m where n]\n          {:pre [(or (= :pfx where) (= :sfx where))\n                 (pos? n)]\n           :post [(fn [{r-pfx :pfx r-sfx :sfx r-pile :pile}]\n                   (and (not-any? neg? (vals r-pile))\n                        (not (neg? (second r-pfx)))\n                        (not (neg? (second r-sfx)))))]}\n          (cond\n            (= :pfx where)\n              {:sfx (:sfx m),\n               :pfx [(into (first (:pfx m)) (repeat n tok))\n                     ((if (= :open tok)\n                       ;(partial +) (partial -))\n                       +\n                       - )\n                         (second (:pfx m)) n)],\n               :pile (pile-minus (:pile m) tok n)}\n            (= :sfx where)\n              {:pfx (:pfx m),\n               :sfx [(into (first (:sfx m)) (repeat n tok))\n                     ((if (= :open tok)\n                       ;(partial -) (partial +))\n                       -\n                       + )\n                         (second (:sfx m)) n)],\n               :pile (pile-minus (:pile m) tok n)} ))))\n    (put-opens [& args]\n      (apply (put-token :open) args))\n    (put-closes [& args]\n              (apply (put-token :close) args))\n    (split-one [{[pfxs pfx-lev] :pfx [sfxs sfx-lev] :sfx\n                    {open-cnt :open close-cnt :close} :pile :as one-m}]\n        {:pre [(not (or (neg? pfx-lev) (neg? sfx-lev)))]}\n      (if (or (zero? open-cnt) (zero? close-cnt))\n        (cond\n          (and (zero? open-cnt) (zero? close-cnt))\n            {:fin (list one-m) :con (list)}\n          (zero? close-cnt)\n            {:fin (list) :con (list (put-opens one-m :pfx open-cnt))}\n          (zero? open-cnt)\n            {:fin (list) :con (list (put-closes one-m :sfx close-cnt))})\n        (if (> close-cnt open-cnt)\n          (if (zero? sfx-lev)\n            {:fin (list) :con (list (put-closes one-m :sfx))}\n            {:fin (list) :con\n              (list (put-closes one-m :sfx) (put-opens one-m :sfx))})\n          (if (zero? pfx-lev)\n            {:fin (list) :con (list (put-opens one-m :pfx))}\n            {:fin (list) :con\n              (list (put-opens one-m :pfx) (put-closes one-m :pfx))}))))\n    (seed-item [n]\n      {:pre [(not (neg? n))]}\n      {:pfx [[] 0] :sfx [[] 0] :pile {:open n :close n}})\n    (merge-fincons [ms]\n      (apply (partial merge-with into) ms))\n    (split-all [seed]\n      (loop [acc [] ws-flat (list seed)]\n       (let [splits (map split-one ws-flat),\n             splt-merged (merge-fincons splits),\n             new-acc (into acc (:fin splt-merged))\n             flat-rest (:con splt-merged) ]\n         (if (zero? (count flat-rest))\n           new-acc\n           (recur new-acc flat-rest)))))\n    (repl-by-chars [xs]\n      (let [mch {:open \\( :close \\)}]\n        (into (empty xs) (map mch xs))))\n    (merge-pfx-sfx [{:keys [pfx sfx pile] :as m}]\n      (into (first pfx) (reverse (first sfx))))\n    (all-splits-ok? [xs]\n      (every? one-ok? xs))\n    (one-ok? [{:keys [pfx sfx pile] :as m}]\n     (and\n       (not (nil? (get pile :open)))\n       (zero? (get pile :open))\n       (not (nil? (get pile :close)))\n       (zero? (get pile :close))\n       (= (second pfx) (second sfx)))) ]\n    (let [raw-rslt (split-all (seed-item n))\n          test-ok? (all-splits-ok? raw-rslt)\n          ch-lines (->> raw-rslt\n                        (map merge-pfx-sfx)\n                        (map (comp (partial apply str) repl-by-chars)))]\n      (set ch-lines) )))", "user": "57f9011ee4b0d3187e900935"}, {"problem": "195", "code": "(fn parentheses-again [n]\n  (letfn [(comb [s]\n            (let [[open :as prt] \"()\"\n                  open-index (keep-indexed #(if (= %2 open) (inc %)) s)]\n              (conj (set (map #(str (clojure.string/join  (take % s))\n                                    prt\n                                    (clojure.string/join  (drop % s)))\n                              open-index))\n                    (str prt s))))]\n    (condp = n\n          0 #{\"\"}\n          1 #{\"()\"}\n          2 #{\"(())\" \"()()\"}\n          (apply clojure.set/union (map comb (parentheses-again (dec n)))))))", "user": "572ec4dde4b0cd1946bd0f8d"}, {"problem": "195", "code": "(fn p1\n  [n]\n  (loop [c (* 2 n) r [[[] n n]]]\n    (if (= c 0)\n      (set (map #(apply str (first %)) r))\n      (recur\n        (dec c)\n        (mapcat\n          (fn [[p left right]]\n             (let [withLeft (if (pos? left) \n                              [[(conj p \\() (dec left) right]] \n                              [])]\n               (if (> right left) \n                 (conj withLeft [(conj p \\)) left (dec right)]) \n                 withLeft)))\n          r)))))", "user": "576df252e4b0979f8965156f"}, {"problem": "195", "code": "(comp\n set\n (fn s [n]\n  (if (= 0 n)\n    '(\"\")\n    (for [i (range n)\n          a (s i)\n          b (s (- n i 1))]\n      (str \"(\" a \")\" b)))))", "user": "4f08b15b535dcb61093f6c40"}, {"problem": "195", "code": "(fn f\n  ([n] \n   (set (f n 0 0)))\n  ([n l r]\n   (cond \n     (and (= l n) (= r n)) #{\"\"}\n     (= l n) (map #(str \")\" %1) (f n l (inc r)))\n     (= l r) (map #(str \"(\" %1) (f n (inc l) r))\n     :else (concat (map #(str \")\" %1) (f n l (inc r))) (map #(str \"(\" %1) (f n (inc l) r)) )\n     )\n   )\n)", "user": "5803ba6de4b0a837a8b30c95"}, {"problem": "195", "code": "(fn [n]\n    (let [complete?  (fn [p] (= (* 2 n) (count p)))\n          add-left?  (fn [p] (< (count (filter pos? p)) n))\n          add-right? (fn [p] (< (count (filter neg? p)) (count (filter pos? p))))\n          strp       (fn [p] (apply str (map {1 \\( -1 \\)} p)))]\n      (set\n       (map strp\n           (loop [ps [[]]]\n             (if (complete? (first ps)) ps\n                 (recur\n                  (reduce (fn [v p]\n                            (cond\n                              (and (add-left? p)\n                                   (add-right? p)) (conj (conj v (conj p 1)) (conj p -1))\n                              (add-left? p) (conj v (conj p 1))\n                              (add-right? p) (conj v (conj p -1)))) [] ps))))))))", "user": "500d3160e4b05f7c30cfa6a1"}, {"problem": "195", "code": "(fn f\n  ([num] (set (f (repeat num \\() (repeat num \\)) [])))\n  ([l r p]\n     (cond\n       (= (count l) (count r) 0) (vector (apply str p))\n       (= (count l) (count r)) (f (rest l) r (conj p (first l)))\n       (= (count l) 0) (f l (rest r) (conj p (first r)))\n       (< (count l) (count r)) (concat (f (rest l) r (conj p (first l)))\n                                    (f l (rest r) (conj p (first r)))))))", "user": "56795deae4b05957ce8c6187"}, {"problem": "195", "code": "(fn [n]\n  ((fn parens [open close s]\n     (if (= 0 open close)\n       #{s}\n       (clojure.set/union\n         (if (< 0 open)\n           (parens (dec open) (inc close) (str s \"(\"))\n           #{})\n         (if (< 0 close)\n           (parens open (dec close) (str s \")\"))\n           #{}))))\n   n 0 \"\"))", "user": "57f0f7b8e4b0bfb2137f5bfe"}, {"problem": "195", "code": "(let [progress-partial (fn progress-partial\n                         [[prefix rem-l rem-r]]\n                         (concat (if (> rem-l 0) [[(str prefix \"(\") (- rem-l 1) rem-r]] [])\n                                 (if (and (> rem-r 0) (> rem-r rem-l)) [[(str prefix \")\") rem-l (- rem-r 1)]] [])))]\n  (let [progress-all-partials (fn progress-all-partials\n                                [partials]\n                                (into #{} (apply concat (map progress-partial partials))))]\n    (fn parentheses-again\n      [n]\n      (loop [partials #{[\"\" n n]}\n             count (* n 2)]\n        (if (= count 0)\n          (into #{} (map first partials))\n          (recur (progress-all-partials partials) (- count 1)))))))", "user": "58152157e4b0f478707a0631"}, {"problem": "195", "code": ";; TODO: Can you make this functional? Maybe build a cons?\n(fn __\n  ([pairs]\n   (let [ret (atom #{})]\n     (do\n       (__ \"\" 0 0 pairs ret)\n       @ret)))\n  ([output open close pairs ret]\n   (if (= open close pairs)\n     (swap! ret conj output)\n     (do\n       (when (< open pairs)\n         (__ (str output \"(\") (inc  open) close pairs ret))\n       (when (< close open)\n         (__ (str output \")\") open (inc close) pairs ret))))))\n\n;; (defn paren-generator[pairs]\n;;   (letfn [(count-lefts[sexp] (count (filter #(= \\( %) sexp)))\n;;           (count-rights[sexp] (count (filter #(= \\) %) sexp)))\n;;           (can-left?[sexp] (< (count-lefts sexp)  pairs))\n;;           (can-right?[sexp] (< (count-rights sexp)  (count-lefts sexp)))\n;;           (done?[sexp] (= (count sexp) (* 2 pairs)))\n;;           (left[sexp] (str sexp \"(\"))\n;;           (right[sexp] (str sexp \")\"))]\n;;     (loop [results '(\"\")]\n;;       (if (done? (first results))\n;;         (set results)\n;;         (recur\n;;          (mapcat\n;;           #(cond\n;;              (and (can-left? %) (can-right? %)) (list (right %) (left %))\n;;              (can-right? %) (list (right %))\n;;              (can-left? %) (list (left %))\n;;              :else (println \"done: \" %))\n;;           results))))))\n\n;;(defn paren-generator[pairs]\n;;  (letfn [(can-open?[sexp] (< (sexp :open)  pairs))\n;;          (can-close?[sexp] (< (sexp :closed)  (sexp :open)))\n;;          (done?[sexp] (= (sexp :open) (sexp :closed) pairs))\n;;          (open[sexp] (assoc sexp :output (str (sexp :output) \"(\") :open (inc (sexp :open))))\n;;          (close[sexp] (assoc sexp :output (str (sexp :output) \")\") :closed (inc (sexp :closed))))\n;;          ]\n;;    (loop [results '({:output \"\", :open 0 :closed 0})]\n;;      (if (done? (first results))\n;;        (set (map :output results))\n;;        (recur\n;;         (mapcat\n;;          #(cond\n;;             (and (can-open? %) (can-close? %)) (list (close %) (open %))\n;;             (can-open? %) (list (open %))\n;;            (can-close? %) (list (close %))\n;;             :else (println \"done: \" %))\n;;          results))))))", "user": "56069006e4b08b23635d3174"}, {"problem": "195", "code": "(fn [n] (set\n  ((fn f [o l a]\n    (let [g (= 0 o)\n          h (= 0 l)\n          y #(f (inc o) (dec l) (conj a \"(\"))\n          z #(f (dec o) l (conj a \")\"))]\n      (cond\n        (and g h) [(apply str a)]\n        g (y)\n        h (z)\n        1 (concat (y) (z)))))\n   0 n [])))", "user": "4f9597e0e4b0dcca54ed6cd4"}, {"problem": "195", "code": "(fn _\n    ([n]\n     (_ n n))\n    ([l r]\n     (if (and (zero? l) (zero? r))\n       #{\"\"}\n       (clojure.set/union\n        (when (> l 0)\n          (set (map #(str \"(\" %) (_ (dec l) r))))\n        (when (> r l)\n          (set (map #(str \")\" %) (_ l (dec r)))))))))", "user": "55c5b55fe4b0e31453f649b5"}, {"problem": "195", "code": "(comp set (fn f [n] (if (zero? n) '(\"\")\n                      (for [inner (range n) i (f inner) j (f (- (dec n) inner))] (str \"(\" i \")\" j)))))", "user": "584dadebe4b0b7285a6f4e44"}, {"problem": "195", "code": "(fn [n]\n  (letfn [(go [l r]\n            (if (zero? l)\n              (list (repeat r \")\"))\n              (if (<= l r)\n                (concat\n                  (->> (go (dec l) r)\n                       (map #(cons \"(\" %)))\n                  (->> (go l (dec r))\n                       (map #(cons \")\" %))))\n                ())))]\n    (->> (go n n)\n         (map #(apply str %))\n         set)))", "user": "583e27e2e4b089d5ab817daa"}, {"problem": "195", "code": "(fn [i]\n  (letfn [(f [coll]\n             (loop [res #{}\n                   k 0\n                   n (count coll)]\n                   (if\n                     (= n 0) res\n                     (if (= (+ k n) (count coll))\n                       (recur (conj res \n                                    [(str \"(\" (apply str coll) \")\")]\n                                    (concat [\"()\"] coll)\n                                    (concat coll [\"()\"]))\n                              0 \n                              (dec n))\n                       (let [pre (take k coll)\n                             mid (take n (drop k coll))\n                             post (drop (+ k n) coll)]\n                         (recur (conj res \n                                      (concat pre [\"()\"] mid post)\n                                      (concat pre [(str \"(\" (apply str mid) \")\")] post)\n                                      (concat pre mid [\"()\"] post))\n                                (inc k)\n                                n))))))] \n    (cond \n     (= i 0) #{\"\"}\n     (= i 1) #{\"()\"}\n     :else (loop [n 1\n                  res #{[\"()\"]}]\n             (if (= n i)\n               (into #{} (map #(apply str (apply concat %)) res))\n               (recur (inc n)\n                      (apply clojure.set/union \n                             (map #(f (into [] %)) res))))))))", "user": "585e2e77e4b0f14aab7c87ac"}, {"problem": "195", "code": "(fn p\n  ([n] (set (p n n)))\n  ([l r]\n   (if (and (zero? l) (zero? r))\n     #{\"\"}\n     (clojure.set/union\n      (when (> l 0) (map #(str \"(\" %) (p (dec l) r)))\n      (when (> r l) (map #(str \")\" %) (p l (dec r))))))))", "user": "52d2ca1ce4b099d49816f0b4"}, {"problem": "195", "code": "(fn [x]\n  (let [mem (atom {0 #{\"\"}, 1 #{\"()\"}})\n        combos (fn [between after]\n            (for [b between, a after]\n              (str \"(\" b \")\" a)))\n        par-gen (fn par-gen [n]\n                  (if-let [m (find @mem n)]\n                    (val m)\n                    (let [r (->> (for [i (range n)]\n                                   (->> [i (- n i 1)] \n                                        (map par-gen)\n                                        (apply combos)))\n                                 flatten\n                                 set)]\n                      (swap! mem assoc n r)\n                      r)))]\n    (par-gen x)))", "user": "58247423e4b051871117bec5"}, {"problem": "195", "code": "(fn [n]\n  (let [insert-paren\n        (fn [s i]\n          (str (subs s 0 i) \"()\" (subs s i)))\n        insert-paren-group\n        (fn [a i]\n          (set (map #(insert-paren % i) a)))\n        insert-paren-all\n          (fn [a]\n            (apply clojure.set/union (for [y (range 0 (inc (count (first a))))]\n                                       (insert-paren-group a y))))]\n    (loop [r #{\"\"}\n           i n]\n      (if (zero? i)\n        r\n        (recur (insert-paren-all r)\n               (dec i))))))", "user": "584b0422e4b089d5ab817ef4"}, {"problem": "195", "code": "(fn pars\n  ([n] (set (pars n 0)))\n  ([n c] (if (= n c 0) [\"\"]\n             (concat (when (pos? n) (map #(str \"(\" %) (pars (dec n) (inc c))))\n                     (when (pos? c) (map #(str \")\" %) (pars n (dec c))))))))", "user": "575b3e9be4b02ea11479935b"}, {"problem": "195", "code": "(fn par-comb [n]\n  (if\n    (zero? n) #{\"\"}\n    (let [c2 (par-comb (dec n))\n          splice-par #(clojure.string/join \"\" [(subs %2 0 %1) \"()\" (subs %2 %1)])\n          n2 (dec (* 2 n))]\n      (set\n       (for [k (range n2) s c2] (splice-par k s))))))", "user": "50336c6be4b0c6c1199c710f"}, {"problem": "195", "code": "(fn gen-paren [n]\n  (letfn\n    [(rec\n      [s opened closed]\n      (let [can-open (< opened n)\n            can-close (< closed opened)]\n        (concat\n         (if (and (not can-open) (not can-close)) [s])\n         (if can-open (rec (str s \"(\") (inc opened) closed) [])\n         (if can-close (rec (str s \")\") opened (inc closed)) []))))]\n    (set (rec \"\" 0 0))))", "user": "5896a0e6e4b00487982d52a8"}, {"problem": "195", "code": ";(fn [n]\n;  (letfn [(tree-grower [{:keys [text to-open to-close]}]\n;            (cond-> nil\n;              (pos? to-open) (conj {:text (conj text \\( )\n;                                    :to-open (dec to-open)\n;                                    :to-close (inc to-close)})\n;              (pos? to-close) (conj {:text (conj text \\) )\n;                                     :to-open to-open\n;                                     :to-close (dec to-close)})))]\n;    (reduce #(conj % (apply str (:text %2)))\n;            #{}\n;            (nth (iterate (fn [list] (mapcat tree-grower list))\n;                          [{:text [] :to-open n :to-close 0}])\n;                 (* 2 n)))))\n(fn [n]\n  (letfn [(tree-grower [[text to-open to-close]]\n            [(when (pos? to-open)\n               [(conj text \\( )\n                (dec to-open)\n                (inc to-close)])\n             (when (pos? to-close)\n               [(conj text \\) )\n                to-open\n                (dec to-close)])])]\n    (reduce #(conj % (apply str (first %2)))\n            #{}\n            (nth (iterate (fn [list] (remove nil? (mapcat tree-grower list)))\n                          [[[] n 0]])\n                 (* 2 n)))))", "user": "54d341f7e4b0e8a36923e603"}, {"problem": "195", "code": "(fn g\n  ([n] (if (= 0 n) #{\"\"} (set (g n 0))))\n  ([n o]\n   (if (= 0 n)\n     (vector (apply str (repeat o \")\")))\n     (if (= 0 o)\n       (map #(str \"(\" %) (g (dec n) 1))\n       (concat\n         (map #(str \")\" %) (g n (dec o)))\n         (map #(str \"(\" %) (g (dec n) (inc o))))))))", "user": "586615e6e4b0f14aab7c8858"}, {"problem": "195", "code": "(fn parentheses \n  ([n] (parentheses n n))\n  ([left right]\n   (if (and (zero? left) (zero? right)) \n     #{\"\"}\n     (clojure.set/union\n      (when (> left 0)\n        (set (map #(str \"(\" % ) (parentheses (dec left) right))))\n      (when (> right left)\n        (set (map #(str \")\" % ) (parentheses left (dec right)))))))))", "user": "585dbe41e4b0f14aab7c879f"}, {"problem": "195", "code": "(fn gen-paren\n  ([n] (if (= 0 n) #{\"\"} (set (gen-paren n 0))))\n  ([n open]\n   (if (= 0 n)\n     (vector (apply str (repeat open \")\")))\n     (if (= 0 open)\n       (map #(str \"(\" %) (gen-paren (dec n) 1))\n       (concat\n         (map #(str \")\" %) (gen-paren n (dec open)))\n         (map #(str \"(\" %) (gen-paren (dec n) (inc open))))))))", "user": "58a0fc33e4b02bd94d917ea3"}, {"problem": "195", "code": "(fn f ([a] (into #{} (f a 0 0 '(\"\"))))\n         ([a o g s] (concat (when (> a o) (f a (inc o) g (map #(str % \"(\") s)))\n                               (when (> o g) (f a o (inc g) (map #(str % \")\") s)))\n                               (when (= a g) s))))", "user": "576e3258e4b0979f89651574"}, {"problem": "195", "code": "(fn paren-combs [n]\n  (letfn [(paren-combs-helper [cur-comb unbalanced-count n]\n            (cond\n              (zero? n) (hash-set (apply str (concat cur-comb (repeat unbalanced-count \\)))))\n              (zero? unbalanced-count) (paren-combs-helper (conj cur-comb \\() (inc unbalanced-count) (dec n))\n              :else (set\n                     (concat\n                      (paren-combs-helper (conj cur-comb \\() (inc unbalanced-count) (dec n))\n                      (paren-combs-helper (conj cur-comb \\)) (dec unbalanced-count) n)))))]\n    (paren-combs-helper [] 0 n)))", "user": "5879d577e4b01531a375ead8"}, {"problem": "195", "code": "(fn parens [n]\n  (letfn [(rec [m open-n close-n]\n            (cond (> close-n open-n)\n                  '()\n\n                  (and (zero? m)\n                       (= close-n open-n))\n                  '(())\n\n                  (and (zero? m)\n                       (not= close-n open-n))\n                  '()\n\n                  :else\n                  (concat\n                   (mapv #(cons \\( %)\n                        (rec (dec m) (inc open-n) close-n))\n                   (mapv #(cons \\) %)\n                        (rec (dec m) open-n (inc close-n))))))]\n    (set (map #(apply str %)\n          (rec (* n 2) 0 0)))))", "user": "5895477fe4b00487982d527c"}, {"problem": "195", "code": "(memoize (fn g-p [n]\n    (cond \n      (= n 1)\n      #{\"()\"}\n      (< n 1)\n      #{\"\"}\n      (= n 12)\n      (conj (vec (repeat 5000 \"\")) \"(((((()()()()()))))(()))\")\n      :else\n      (loop [result #{} i 1 s 1]\n        (cond \n          (> s (quot n 2))\n          (clojure.set/union result (set (map #(str \"(\" % \")\") (g-p (- n 1)))))\n          (> (+ s i -1) n)\n          (recur result 1 (inc s))\n          :else\n          (recur (clojure.set/union result (set (for [x (g-p (- i 1)) y (g-p s) z (g-p (- n i s -1))] (str x y z)))) (inc i) s))))))", "user": "58c3af4de4b021aa9917ed1b"}, {"problem": "195", "code": "(fn [n]\n  (letfn [(ps [no nc r rs]\n            (if (and (zero? no) (zero? nc))\n              (conj rs r)\n              (if (= no nc)\n                (ps (dec no) nc (str r \"(\") rs)\n                (into\n                  (if (> no 0)\n                    (ps (dec no) nc (str r \"(\") rs)\n                    rs)\n                  (ps no (dec nc) (str r \")\") rs)))))]\n    (ps n n \"\" #{})))", "user": "58bb218be4b0888cdc949cf4"}, {"problem": "195", "code": "(fn ff [n]\n  (if (zero? n)\n    #{\"\"}\n    (let [prevs (map ff (range 0 n))\n          some? (partial not= nil)\n          m-pairs (map vector (rest prevs) (reverse prevs))\n          pairs (filter (comp some? first) m-pairs)]\n      (-> [(for [p pairs :let [[heads tails] p] h heads t tails] (str h t))\n           (for [x (last prevs)] (str \"(\" x \")\"))]\n          flatten set))))", "user": "567d132ee4b05957ce8c61c3"}, {"problem": "195", "code": "(fn arghh-ugly-mutability-but-its-fast [n]\n  (let [res (atom #{})\n        balanced-parens (fn balanced-parens [left right acc]\n                          (if (= right 0)\n                            (swap! res conj acc)\n                            (if (> left 0)\n                              (do (balanced-parens (dec left) right (str acc \"(\"))\n                                  (when (> right left)\n                                    (balanced-parens left (dec right) (str acc \")\"))))\n                              (balanced-parens left (dec right) (str acc \")\")))))]\n    (balanced-parens n n \"\")\n    @res))", "user": "563f4c47e4b08d4f616f5ed2"}, {"problem": "195", "code": "(fn fib-store [n]\n  (let [advance (fn [store]\n                  (let [k (count store)\n                        recruit (concat\n                                  (map #(str \\( % \\)) (peek store))\n                                  (for [i (rest (range k)), fore (store i), aft (store (- k i))]\n                                    (str fore aft)))]\n                    (conj store (set recruit))))]\n    (peek (nth (iterate advance [#{\"\"}]) n))))", "user": "506ab9bae4b05d3b7762c74c"}, {"problem": "195", "code": "(fn well-formed-parentheses\n  ([n] \n   (well-formed-parentheses n 0 0 \"\"))\n  ([n open close accum]\n   (if (= n close)\n     #{accum}\n     (clojure.set/union (if (< open n)\n                          (well-formed-parentheses n (inc open) close (str accum \"(\"))\n                          #{})\n                        (if (< close open)\n                          (well-formed-parentheses n open (inc close) (str accum \")\"))\n                          #{})))))", "user": "58ed713de4b056aecfd47d84"}, {"problem": "195", "code": "(fn expand\n  ([s l o c]\n   (cond\n     (>= (count s) l) [s]\n     (= (- l (count s)) (- o c)) (str s (apply str (repeat (- o c) \")\")))\n     (> o c) [(expand (str s \"(\") l (inc o) c) (expand (str s \")\") l o (inc c))]\n     :default [(expand (str s \"(\") l (inc o) c)]))\n  ([n] (set (flatten (expand \"\" (* 2 n) 0 0)))))", "user": "57b3efb1e4b0fbc9809a278a"}, {"problem": "195", "code": "(fn parenthesis [n]\n     (letfn [(paren [acc open closed]\n                (if (= 0 open closed)\n                  (map #(apply str %) (list acc))\n                  (concat \n                    (when (> open 0)\n                      (paren (conj acc \\() (dec open) (inc closed)))\n                    (when (> closed 0)\n                      (paren (conj acc \\)) open (dec closed))))))]\n      (set (paren [] n 0))))", "user": "58dcb8cde4b0a4d5acaab6a7"}, {"problem": "195", "code": "(fn parentheses \n  ([n] (parentheses n n))\n  ([left right]\n    (if (and (zero? left) (zero? right)) \n      #{\"\"}\n      (clojure.set/union\n        (when (> left 0)\n          (set (map #(str \"(\" % ) (parentheses (dec left) right))))\n        (when (> right left)\n          (set (map #(str \")\" % ) (parentheses left (dec right)))))))))", "user": "53dbca12e4b094d41abdfef6"}, {"problem": "195", "code": "(fn f [n]\n  (set\n   ({0 [\"\"]\n     1 [\"()\"]}\n    n\n    (flatten\n     (for [m (range 1 n)\n           a (f m)\n           b (f (- n m 1))]\n       [(str \\( a \\) b)\n        (str a \\( b \\))])))))", "user": "4db858d1535d1e037afb218c"}, {"problem": "195", "code": "(fn parens\n      ([n]\n       (set (map #(apply str %) (parens n 0 0 []))))\n      ([n opened closed accu]\n       (cond (< opened n) (if (< closed opened)\n                            (concat (parens n (inc opened) closed (conj accu \"(\"))\n                                    (parens n opened (inc closed) (conj accu \")\")))\n                            (parens n (inc opened) closed (conj accu \"(\")))\n             (< closed opened) (parens n opened (inc closed) (conj accu \")\"))\n             :else [accu])))", "user": "58ec1e63e4b056aecfd47d54"}, {"problem": "195", "code": "(fn [n] (letfn [(p [l r]\n                   (if (and (zero? l)\n                            (zero? r))\n                     #{\"\"}\n                     (clojure.set/union\n                       (when (> l 0) (set (map #(str \"(\" % ) (p (dec l) r))))\n                       (when (> r l) (set (map #(str \")\" % ) (p l (dec r)))))))\n                   )] (p n n)))", "user": "58987ee9e4b00487982d52d2"}, {"problem": "195", "code": "(fn [n]\n          (->> (iterate (fn [s]\n                          (mapcat (fn [[x v]]\n                                    (if (and (<= v 0) (>= (+ v n) 0))\n                                      [[(str x \")\") (inc v)] [(str x \"(\") (dec v)]])) s))\n                        [[\"\" 0]])\n               (take (inc (* 2 n)))\n               last\n               (filter (fn [[x v]] (= 0 v)))\n               (map first)\n               set\n               )\n          )", "user": "5921a080e4b09b4ee5954c77"}, {"problem": "195", "code": "(fn gp \n  ([n] (if (zero? n) #{\"\"} (set (gp n 0)))) \n  ([n m] \n    (cond \n      (zero? n) (vector (apply str (repeat m \")\"))) \n      (zero? m) (map #(str \"(\" %) (gp (dec n) 1)) \n      :else (concat \n              (map #(str \")\" %) (gp n (dec m))) \n              (map #(str \"(\" %) (gp (dec n) (inc m)))))))", "user": "58e7229fe4b056aecfd47cc4"}, {"problem": "195", "code": "(fn combos [n]\n  (->>\n    (reduce\n      (fn [m1 _]\n        (reduce-kv\n          (fn [m2 s [l r]]\n            (cond\n              (= l n) (assoc m2 (str s \\)) [l (inc r)])\n              (= l r) (assoc m2 (str s \\() [(inc l) r])\n              :else   (assoc m2 (str s \\)) [l (inc r)]\n                                (str s \\() [(inc l) r])))\n          {}\n          m1))\n      {\"\" [0 0]}\n      (range (* 2 n)))\n    keys\n    (into #{})))", "user": "4f5599dfe4b0a7574ea71806"}, {"problem": "195", "code": "(fn [n]\n  (get (reduce (fn [cache x]\n                 (assoc cache x (set (for [i (range 1 (inc x))\n                                       s (get cache (dec i))\n                                       t (get cache (- x i))]\n                                   (str \"(\" s \")\" t)))))\n               {0 #{\"\"}} (range 1 (inc n))) n))", "user": "51b76227e4b0d906fcd71d35"}, {"problem": "195", "code": "(fn hp\n  ([n] (hp \"\" n n))\n  ([p o c]\n    (if (= 0 c) #{p}\n        (clojure.set/union (if (> o 0) (hp (str p \"(\") (dec o) c))\n                           (if (> c o) (hp (str p \")\") o (dec c)))))))", "user": "5958cef6e4b066ee0a44af94"}, {"problem": "195", "code": "(fn [k]\n  (let [fill (fn [bn]\n               (let [ff (fn [n] (str (subs bn 0 n) \"()\" (subs bn n)))]\n                  (map ff (range (inc (count bn)))) ))\n        f (fn [ret] (into #{} (mapcat fill ret))) ]\n  (first (drop k (iterate f #{\"\"}))) ))", "user": "593f95d8e4b069cdc2982be3"}, {"problem": "195", "code": "(fn parentheses \n  ([n] (parentheses n n))\n  ([left right]\n    (if (and (zero? left) (zero? right)) \n      #{\"\"}\n      (clojure.set/union\n        (when (> left 0)\n          (set (map #(str \"(\" % ) (parentheses (dec left) right))))\n        (when (> right left)\n(set (map #(str \")\" % ) (parentheses left (dec right)))))))))", "user": "5979be51e4b02382a38ad1d6"}, {"problem": "195", "code": "(fn [n]\n  (let [f (fn f [n i acc]\n            (if (= n i) (acc n)\n              (let [ni (inc i)\n                    nacc (assoc acc ni\n                           (apply clojure.set/union\n                                  (into #{}\n                                        (map #(str \"(\" % \")\")\n                                             (acc i)))\n                                  (for [x (range 1 ni)\n                                        y [(- ni x)]]\n                                    (into #{}\n                                          (for [s1 (acc x)\n                                                s2 (acc y)]\n                                            (str s1 s2))))))]\n                (f n ni nacc))))]\n    (f n 0 {0 #{\"\"}})))", "user": "57a0b341e4b0c3d858beb8d4"}, {"problem": "195", "code": "(fn [n]\n  (letfn [(p [s r open]\n            (if (zero? r)\n              [s]\n              (concat\n                (when (> r open) (p (str s \"(\") (dec r) (inc open)))\n                (when (> open 0) (p (str s \")\") (dec r) (dec open))))))]\n    (into #{} (p \"\" (* 2 n) 0))))", "user": "56d68cbae4b0ea9b8538f7cd"}, {"problem": "195", "code": "(fn [n] \n  (let [g (fn h [acc tok left right]\n            (cond \n              (> left right)\n              acc\n              (= 0 left right)\n              (conj acc tok) \n              :else \n              (let [lres (when (pos? left)\n                           (h acc (str tok \"(\") (dec left) right))\n                    rres (when (pos? right)\n                           (h acc (str tok \")\") left (dec right)))]\n                (-> (into acc lres)\n                    (into rres)))))]\n    (g #{} \"\" n n)))", "user": "5398305fe4b0b51d73faaef6"}, {"problem": "195", "code": "(fn f [s c o]\n  (set (concat\n    (when (pos? o) (f (str s \\() (inc c) (dec o)))\n    (when (pos? c) (f (str s \\)) (dec c) o))\n    (when (= 0 o c) [s]))))\n\"\"\n0", "user": "4fb1d7ace4b081705acca281"}, {"problem": "195", "code": "(fn parentheses \n  ([n]\n    (set (parentheses n 0 0 \"\"))\n  )\n  ([n pending closed result]\n    (if (= n closed)\n      [result]\n      (let [\n            not_finished (- n closed)\n            openParenthesis #(parentheses n (inc pending) closed (str result \"(\"))\n            closeParenthesis #(parentheses n (dec pending) (inc closed) (str result \")\"))\n           ]\n        (cond\n          ;there's at least one not closed parentheses. In that case we can open new one or close pending.\n          (and (> pending 0) (not= pending not_finished)) (concat (openParenthesis) (closeParenthesis))\n          ;there's at least one not closed parentheses, but we can't open new one\n          (and (> pending 0) (= pending not_finished)) (closeParenthesis)\n          ;there's no pending parentheses. we can only open new one.\n          (= pending 0) (openParenthesis)\n        )\n      )\n    )\n  )\n)", "user": "5991d2fae4b0866487ed0d68"}, {"problem": "195", "code": "(fn __\n  ([n] (__ #{} \"\" n 0 0))\n  ([result tillNow n open closed]\n   (if (= closed n)\n      (conj result tillNow)\n      (let [\n            res1 (if (> open closed)\n                   (__ result (str tillNow \")\") n open (inc closed))\n                   result)\n            res2 (if (< open n)\n                   (__ res1 (str tillNow \"(\") n (inc open) closed)\n                   res1)\n            ]\n        res2))))", "user": "58bc6a88e4b0888cdc949d16"}, {"problem": "195", "code": ";; No loops, no recursion\n(fn [n]\n  (nth (iterate \n        (fn [st]\n          (->>(mapcat (fn [s] (let [t (clojure.string/split (clojure.string/replace s \"(\" \"(_\") #\"_\")]\n                                (->> (map (comp (partial apply str) interleave)\n                                          (repeat (count t) t)\n                                          (iterate (partial cons \"\") (cons \"()\" (repeat \"\"))))\n                                     (set))))\n                       st)\n              set))\n        #{\"\"})\n       n))", "user": "5960a1a6e4b066ee0a44b08e"}, {"problem": "195", "code": "(fn n195\n  ([n] (if (zero? n) #{\"\"} (set (n195 n 0))))\n  ([n open]\n   (if (zero? n)\n     (vector (apply str (repeat open \")\")))\n     (if (zero? open)\n       (map #(str \"(\" %) (n195 (dec n) 1))\n       (concat\n        (map #(str \")\" %) (n195 n (dec open)))\n        (map #(str \"(\" %) (n195 (dec n) (inc open))))))))", "user": "5893c64ce4b00487982d524b"}, {"problem": "195", "code": "; Evil hack\n(fn [& _]\n  (reify nil\n    clojure.lang.IPersistentCollection\n    (seq [_])\n    (cons [_ _])\n    (empty [_])\n    (equiv [_ _] true)))", "user": "51e58e02e4b0efabf93c02d0"}, {"problem": "195", "code": "(fn all-ps\n  ([n]\n   (all-ps n 0 0 [] #{}))\n  ([n opened closed r results]\n   (if (= (* 2 n) (count r))\n     (conj results (clojure.string/join r))\n     (set (concat results\n                  (if (< opened n)\n                    (all-ps n (inc opened) closed (conj r \"(\") #{})\n                    nil)\n                  (if (< closed opened)\n                    (all-ps n opened (inc closed) (conj r \")\") #{})\n                    nil))))))", "user": "5866b999e4b0f14aab7c886b"}, {"problem": "195", "code": "(fn valid-parenth [n]\n  (letfn [(get-next [v]\n            (let [n (count v) maxr (range n)]\n              (loop [i (dec n)]\n                (if (< (nth v i) (nth maxr i))\n                  (concat (take i v) (repeat (- n i) (inc (nth v i))))\n                  (if (zero? i) nil (recur (dec i)))\n                )\n              )  \n            )  \n          )\n          (brackets-from-range [r]\n            (let [n (count r) st (range n) v (map + st r)]\n              (:result (reduce (fn [a b] \n                {:last b :result (str \\( (apply str (repeat (- (:last a) b 1) \\) )) (:result a)  ) }\n              ) {:last (* 2 n) :result \"\"} (reverse v)))\n            )  \n          )]\n    (if (zero? n) #{\"\"}\n      (loop [v (vec (repeat n 0)) result #{}]\n        (if (not (nil? v))\n          (recur (get-next v) (conj result (brackets-from-range v)))\n          result\n        )\n      )\n    )  \n  )  \n)", "user": "59a0262ee4b0871e7608b82d"}, {"problem": "195", "code": "#(set (% [\"\"] 0 %2))\n\n        (fn t [output stack n]\n          (if (and (zero? stack) (zero? n))\n            [(apply str output)]\n            (concat (if (pos? n) (t (conj output \"(\") (inc stack) (dec n)))\n                    (if (pos? stack) (t (conj output \")\") (dec stack) n))))\n          )", "user": "563dfc02e4b0da801c4e4662"}, {"problem": "195", "code": "(fn pa-195 [x]\r\n    (letfn [(pa-helper1 [hstr open-count rem-count]\r\n              (letfn [(new-paren [] (map #(str %1)\r\n                                         (pa-helper1 (str hstr \"(\")\r\n                                                     (inc open-count)\r\n                                                     (dec rem-count))))\r\n                      (close-paren [] (map #(str %1)\r\n                                           (pa-helper1 (str hstr \")\")\r\n                                                       (dec open-count)\r\n                                                       rem-count)))]\r\n                (cond\r\n                  (= 0 rem-count) [(str hstr\r\n                                        (apply str (repeat open-count \")\")))]\r\n                  (= 0 open-count) (new-paren)\r\n                  :else (concat (new-paren) (close-paren)))))]\r\n      (set (pa-helper1 \"\" 0 x))))", "user": "513e8141e4b02b2a3d8235c1"}, {"problem": "195", "code": "(letfn [(open [[s num-open num-left]]\n            [(str s \"(\") (inc num-open) (dec num-left)])\n          (close [[s num-open num-left]]\n            [(str s \")\") (dec num-open) num-left])\n          (step [[_ num-open num-left :as arg]]\n            (->> (vector\n                   (when (pos? num-open) (close arg))\n                   (when (pos? num-left) (open arg))\n                   (when (= 0 num-open num-left) arg))\n                 (remove nil?)))\n          (it [args] (mapcat step args))]\n    (fn [n] (set (map first (nth (iterate it [[\"\" 0 n]]) (* 2 n))))))", "user": "4ff3df0fe4b0678c553fc355"}, {"problem": "195", "code": "(fn gen-parens\n  ([n] (if (= 0 n) #{\"\"} (set (gen-parens n 0))))\n  ([n open]\n   (if (= 0 n)\n     (vector (apply str (repeat open \")\")))\n     (if (= 0 open)\n       (map #(str \"(\" %) (gen-parens (dec n) 1))\n       (concat\n         (map #(str \")\" %) (gen-parens n (dec open)))\n         (map #(str \"(\" %) (gen-parens (dec n) (inc open))))))))", "user": "59358f74e4b04f87174def52"}, {"problem": "195", "code": "(fn [n]\n  (letfn [(parens' [acc opened close]\n            (if (pos? close)\n              (clojure.set/union\n                (when (< opened close)\n                  (parens' (conj acc (char 40)) (inc opened) close))\n                (when (pos? opened)\n                  (parens' (conj acc (char 41)) (dec opened) (dec close))))\n              #{(apply str acc)}))]\n    (if (zero? n)\n      #{\"\"}\n      (parens' [] 0 n))))", "user": "4dc0ff08535d020aff1edf84"}, {"problem": "195", "code": "(fn [n]\n        (let [endings (memoize\n                       (fn [f to-open to-close]\n                         (cond\n                           (and (= 0 to-open) (= 0 to-close)) (list (list))\n                           (= 0 to-open)                      (list (repeat to-close \")\"))\n                           (= to-open to-close)               (map (fn [ending] (cons \"(\" ending))\n                                                                   (lazy-seq (f f (dec to-open) to-close)))\n                           (< to-open to-close)               (concat\n                                                               (map (fn [ending] (cons \"(\" ending))\n                                                                    (lazy-seq (f f (dec to-open) to-close)))\n                                                               (map (fn [ending] (cons \")\" ending))\n                                                                    (lazy-seq (f f to-open (dec to-close)))))\n                           :else                              (map (fn [ending] (cons \"LOL!\" ending))))))\n              endings (partial endings endings)]\n          (->> (endings n n)\n               (map (partial apply str))\n               (into #{}))))", "user": "547d8e93e4b0c51c1f4d72f4"}, {"problem": "195", "code": "(let [open  \\( close \\)\n      perms (fn c [accu depth width]\n              (cond\n                (zero? width)\n                [accu]\n\n                (zero? depth)\n                (recur (conj accu open) (inc depth) (dec width))\n\n                (< depth width)\n                (concat\n                  (c (conj accu open) (inc depth) (dec width))\n                  (c (conj accu close) (dec depth) (dec width)))\n\n                :else\n                (recur (conj accu close) (dec depth) (dec width))))]\n  (fn ps [n]\n    (->> (perms [] 0 (* n 2))\n         (map #(apply str %))\n         (set))))", "user": "59eb63e3e4b0249b7282077c"}, {"problem": "195", "code": "(fn p\n  ([n] (p n n))\n  ([l r]\n   (if (= 0 l r)\n     #{\"\"}\n     (into #{}\n           (concat\n             (when (> l 0)\n               (set (map #(str \"(\" %) (p (dec l) r))))\n             (when (> r l)\n               (set (map #(str \")\" %) (p l (dec r))))))))))", "user": "54a11042e4b09f271ff37c49"}, {"problem": "195", "code": "(fn [n]\n  (let [r (atom [])]\n    (letfn [(gen [l s o c]\n         (if (>= c n)\n           (swap! r conj s)\n           (do\n             (when (> o c)\n               (conj l (gen l (str s \")\") o (inc c))))\n             (when (< o n)\n               (conj l (gen l (str s \"(\") (inc o) c))))))]\n      (gen [] \"\" 0 0)\n      (set @r))))", "user": "54497569e4b032a45b8693d2"}, {"problem": "195", "code": "(fn [x]\n  (let [memo (memoize\n    (fn [n r] \n      (if (= n 0)\n        #{\"\"}\n        (clojure.set/union\n          (set\n              (map\n                #(str \"(\" % \")\")\n                (r (dec n) r)))\n          (set\n            (for [x (range 1 n) a (r x r) b (r (- n x) r)]\n              (str a b)))))))]\n    (memo x memo)))", "user": "5a2df4a0e4b09cafd31c7f74"}, {"problem": "195", "code": "(fn parens [n]\n   (letfn [\n           \n          (nextm [xs n] ;xs reversed \n  (if (= 0 n)\n      []\n   (let [s (count xs) ]\n      (loop [i 0 ]\n ;  (do (print i xs n \"--\")\n        (if (= 0 (nth xs i) )\n           (recur (inc i))\n           (if (= i (dec  s))\n              []\n              (let [nsum (reduce + (drop (inc i) xs))\n                     rn (- n nsum)]\n                    (concat [(dec rn)]\n                                (repeat i 0)\n                                [(inc (xs (inc i)))]\n                                (drop (+ i 2) xs)\n                    )\n              )\n           )\n         )\n ;)\n      )\n)))\n\n(allm [n s]\n     (loop [m (vec (concat [n] (repeat (dec s) 0)) )\n            res [m]]\n        (let [ nm (vec (nextm m n))]\n             (if (> (count nm) 0)\n                 (recur nm (conj res nm))\n                  res\n              )\n        )\n      )\n)\n\n(alls [n]\n     (loop [i 1 res []]\n          (if (> i  n)\n               res\n               (recur (inc i) (concat res  (allm (- n i) i)) )\n           )\n      )\n)\n\n           \n       (cart  [colls]\n    (if  (empty? colls)\n          '(())\n          (for  [x  (first colls)\n                           more  (cart  (rest colls))]\n                  (cons x more)\n\n          )\n\n    )\n\n)\n\n(add1 [xs]\n      (if (< 0 (count xs))\n        (letfn [(addklamm [astr]\n                  (apply str (concat [\\(] astr [\\)]))\n                  )]\n         (map addklamm xs) )\n         [\"()\"]\n      )\n)\n\n(trans [res ps]\n     (let [rss  (map #(res %) ps)]\n    (map #(apply str %)   (cart (map add1 rss)));\n      )\n)\n\n(ppr [res i n] ; res init [ []]\n  (cond (= i n) res\n        :else\n        (recur (conj res\n           (flatten (map #(trans res %) (alls (inc i)))));; \n;          (reduce concat (map #(trans res %) (alls (inc i)))) ) ; \n                       (inc i) n)\n   )\n)\n    \n             ]\n  \n  \n  \n   (set  (first (drop n (ppr '[(\"\")] 0 n))))\n  )\n )", "user": "59ff9424e4b01bb0ae8afd24"}, {"problem": "195", "code": "(fn paren-variations                                                          \n    ([n] (set (paren-variations 0 (* n 2) \"\")))                                 \n    ([opened remaining so-far]                                                  \n     (let [openers (when (> remaining opened)                                   \n                     (paren-variations (inc opened)                             \n                                       (dec remaining)                          \n                                       (str so-far \\()))                        \n           closers (when-not (zero? opened)                                     \n                     (paren-variations (dec opened)                             \n                                       (dec remaining)                          \n                                       (str so-far \\))))                        \n           this-one (when (zero? remaining) [so-far])]                          \n       (concat this-one openers closers))))", "user": "51f9527fe4b09be9c177e549"}, {"problem": "195", "code": "(fn [n]\n  (let [wf_p (fn well_formed_parens [i open closed curr set_of_wf_parens]\n               (if (= i (* 2 n))\n                 (if (= open closed)\n                   (conj set_of_wf_parens (apply str curr))\n                   set_of_wf_parens)\n                 (if (> closed open)\n                   set_of_wf_parens\n                   (let [s_1 (well_formed_parens (+ 1 i)\n                                                 (+ 1 open)\n                                                 closed\n                                                 (conj curr \\()\n                                                 set_of_wf_parens)\n                         s_2 (well_formed_parens (+ 1 i)\n                                                 open\n                                                 (+ 1 closed)\n                                                 (conj curr \\))\n                                                 s_1)]\n                     s_2))))]\n    (wf_p 0 0 0 [] #{})))", "user": "5a34f342e4b0ddc586f153d1"}, {"problem": "195", "code": "(fn [bedrock]\n  (let\n   [bb (* 2 bedrock)]\n   (letfn\n    [\n    \n    (dig [pit depth length]\n      (if (= length bb)\n        (when (= 0 depth)\n          (list pit))\n       (mapcat\n        (fn [hole]\n          (dig\n           (lazy-seq\n            (cons hole pit))\n           (+ depth hole)\n           (inc length)))\n        (if (> depth 0)\n          (if (< depth bedrock)\n            (lazy-seq [-1 1])\n            (lazy-seq [-1]))\n          (when (= depth 0)\n           (lazy-seq [1]))))))\n    \n     (parensify-one [n]\n       (if (> n 0) \\) \\())\n     (parensify [ul]\n       (reduce\n        str\n        (map parensify-one ul)))\n    ]\n\n   (->>\n    (dig [] 0 0)\n    (map parensify)\n    set) ; Why the heck author needs a set?\n\n   )))", "user": "586a657de4b0f14aab7c88bd"}, {"problem": "195", "code": "(fn [n]\n  (loop [k (* 2 n) a '([\"\" 0])]\n    (if (zero? k)\n      (set\n        (map first a))\n      (recur\n        (dec k)\n        (mapcat\n          (fn [[s d]]\n            (concat\n              (when (> d 0) [[(str s \")\") (dec d)]])\n              (when (< d k) [[(str s \"(\") (inc d)]])))\n          a)))))", "user": "58f44c07e4b0438e51c2ceb7"}, {"problem": "195", "code": "(fn [n]\n   (let [opens \"(\" closes \")\"]\n      (set (flatten ((fn dyck [x n0 n1]\n         (cond\n            (= n 0) (list \"\")\n            (and (< n0 n) (< n1 n) (> n0 n1)) (list (dyck (str x opens) (inc n0) n1) (dyck (str x closes) n0 (inc n1)))\n            (and (< n0 n) (< n1 n) (= n0 n1)) (dyck (str x opens) (inc n0) n1)\n            (and (< n0 n) (= n1 n)) (dyck (str x opens) (inc n0) n1)\n            (and (= n0 n) (< n1 n)) (dyck (str x closes) n0 (inc n1))\n            (= n n0 n1) (list x))) opens 1 0)))))", "user": "59f043d0e4b0966464fe6a3d"}, {"problem": "195", "code": "(fn [n]\n    (let [a (fn [[s o c]]\n                (let [so [(str s \"(\") (inc o) c]\n                      sc [(str s \")\") o (inc c)]]\n                  (cond\n                    (= o c) [so]\n                    (= o n) [sc]\n                    :else   [so sc])))\n          f (fn [i v] (if (= 0 i) v (recur (dec i) (mapcat a v))))]\n  (into #{} (map first (f (* 2 n) [[\"\" 0 0]]))) ))", "user": "5a4de614e4b05d388ecb6bb1"}, {"problem": "195", "code": "(fn [n]\n  (letfn[(init[n]\n  \t\t   {:s \"\" :o (repeat n \\() :c (repeat n \\))})\n\n\t\t (open [{:keys [s o c]}]\n  \t\t   (when (seq o)\n             {:s (str s (first o)) :o (rest o) :c c}))\n  \n\t\t (close [{:keys [s o c]}]\n  \t\t   (when (seq c)\n             {:s (str s (first c)) :o o :c (rest c)}))\n         \n         (valid? [s]\n          (letfn [(step [tail c]\n                    (if (seq tail)\n                      (cond \n                        (= (first tail) \\() (recur (rest tail) (inc c))\n                        (and (= (first tail) \\)) (zero? c)) false\n                        (= (first tail) \\)) (recur (rest tail) (dec c))\n                        :else (recur (rest tail) c))\n                      true))]\n            (step s 0)))\n         \n         (parens [n]\n          (letfn [(parens-seq [s]\n                    (lazy-seq\n                      (when (seq s)\n                         (let [next-iter (->> s\n                                          (mapcat (juxt open close))\n                                          (filter (comp not nil?))\n                                          (filter (comp valid? :s)))]\n                           (concat s (parens-seq next-iter))))))]\n            (parens-seq [(init n)])))\n  \n          (valid-parens [n]\n            (filter #(= (* n 2) (count (:s %))) (parens n)))]\n    \n    (set (map :s (valid-parens n)))))", "user": "4fd4bddce4b0d4de60cee36e"}, {"problem": "195", "code": "(fn[n]\n        (let [generate\n              (fn[n] \n                (loop [\n                       i n \n                       res #{\"\"}]\n                  (let [extend\n                        (fn[radix]\n                          (let [freqs (frequencies radix)\n                                open (get freqs \\( 0)\n                                close (get freqs \\) 0)\n                                \n                                can-open (> i (- open close))\n                                can-close (> open close)]\n                            \n                            (clojure.set/union \n                             (if can-open #{(str radix \\()})\n                             (if can-close #{(str radix \\))}))))]\n                    \n                    (cond\n                     (zero? i) res\n                     :else (recur (dec i) (mapcat extend res))))))]\n        \n          (into #{} (generate (* 2 n)))))", "user": "57e6f90de4b0bfb2137f5af6"}, {"problem": "195", "code": "(fn pa\n  ([n] (set (pa n \"\" 0)))\n  ([n p d]\n   (if (zero? n)\n     (list (str p (apply str (repeat d \\)))))\n     (concat\n      (pa (dec n) (str p \\() (inc d))\n      (when (> d 0)\n        (pa n (str p \\)) (dec d)))))))", "user": "56bb652ae4b0f26550335953"}, {"problem": "195", "code": "; this is terrible\n(fn [pairs]\n  (let [cache (atom {})\n        generate (fn generate [length depth]\n                   (if (@cache [length depth])\n                     (@cache [length depth])\n                     (let [val(set (cond (zero? length) [[]]\n                                         (== length depth) [(repeat length 0)]\n                                         (== length (inc depth)) []\n                                         (zero? depth) (map #(conj % 1) (generate (dec length) (inc depth)))\n                                         :else (concat (map #(conj % 0) (generate (dec length) (dec depth)))\n                                                       (map #(conj % 1) (generate (dec length) (inc depth))))))]\n                       (swap! cache assoc [length depth] val)\n                       val)))]\n    (->> (generate (* 2 pairs) 0)\n         (map (fn [binary]\n                (apply str\n                       (map {1 \\(\n                             0 \\)}\n                            binary))))\n         set)))", "user": "4eda7cc3535d10e5ff6f530e"}, {"problem": "195", "code": "(fn [n]\n  (letfn [(paren [n o]\n            (if (= 0 n)\n              (vector (apply str (repeat o \")\")))\n              (if (= 0 o)\n                (map #(str \"(\" %) (paren (dec n) 1))\n                (concat\n                  (map #(str \")\" %) (paren n (dec o)))\n                  (map #(str \"(\" %) (paren (dec n) (inc o)))))))]\n    (set (paren n 0))))", "user": "5a9dbb32e4b0d174b936c7f3"}, {"problem": "195", "code": "(fn [n]\n  (let [out (atom [])\n        makebal (fn makebal [open, close, acc]\n                  (if (= 0 open close) (swap! out conj (apply str acc)))\n                  (if (pos? open) (makebal (dec open) (inc close) (conj acc \\))))\n                  (if (pos? close) (makebal open (dec close) (conj acc \\())))]\n    (makebal n 0 '())\n    (apply hash-set @out)))", "user": "4e8768f6535dceadca469850"}, {"problem": "195", "code": "(fn problem-195*\n    [n]\n    (cond\n      (= n 0) #{\"\"}\n      (= n 1) #{\"()\"}\n      :else (let [prev-result (problem-195* (dec n))]\n              (into #{} (mapcat\n                          (fn [coll]\n                            (apply conj [(str \"()\" coll)\n                                         (str \"(\" coll \")\")\n                                         (str coll \"()\")]\n                                   (loop [start (str (first coll))\n                                          end (apply str (rest coll))\n                                          result #{}]\n                                     (if (seq end)\n                                       (recur (str start (first end))\n                                              (apply str (rest end))\n                                              (conj result (str start \"()\" end)))\n                                       result)))\n                            ) prev-result)))))", "user": "569f4dabe4b0542e1f8d1491"}, {"problem": "195", "code": "(fn parentheses [n]\n  (cond (zero? n) #{\"\"}\n        (= 1 n) #{\"()\"}\n        true (let [k (dec n)]\n               (reduce into #{}\n                       (mapcat #(for [x (parentheses %)\n                                      y (parentheses (- k %))]\n                                  [(str \"(\" x \")\" y)\n                                   (str x \"(\" y \")\")\n                                   (str x \"()\" y)])\n                               (range k))))))", "user": "5ab564f8e4b073f177442639"}, {"problem": "195", "code": "(fn [n] \n  (let [cache (atom {0 #{\"\"} 1 #{\"()\"}})]\n  ((fn dyck [n]\n  (if (@cache n)\n    (@cache n)\n    ((swap! cache assoc n (into #{}\n      (mapcat\n        (fn [i]   \n          (for [b (dyck (dec i))\n                a (dyck (- n i))]\n            (str \"(\" b \")\" a)))\n        (range 1 (inc n))\n     ))) n)\n    )) n )))", "user": "5aa998c6e4b0d174b936c8e5"}, {"problem": "195", "code": "(fn parens\n  [n]\n  (letfn [(parens-int [o c agg]\n            (cond (and (zero? o) (zero? c)) agg\n                  (zero? o) (parens-int o (dec c) (map #(str % \")\") agg))\n                  (= o c) (parens-int (dec o) c (map #(str % \"(\") agg))\n                  :else (concat (parens-int o (dec c) (map #(str % \")\") agg))\n                                (parens-int (dec o) c (map #(str % \"(\") agg)))))]\n    (set (parens-int n n [\"\"]))))", "user": "57ea2c91e4b0bfb2137f5b42"}, {"problem": "195", "code": "(letfn [(parenth \n          ([nb] (parenth \"\" nb 0))\n          ([res a b]\n            (if (and (zero? a) (zero? b))\n              #{res} \n              (if (zero? a)\n                (parenth (str res \")\"), 0, (dec b))\n                (if (zero? b)\n                  (parenth (str res \"(\"), (dec a), 1)\n                  (into (parenth (str res \"(\") (dec a)(inc b))\n                    (parenth (str res \")\") a (dec b))))))))]\n  parenth)", "user": "5b000332e4b0cc2b61a3bd36"}, {"problem": "195", "code": "(fn [n]\n  (let [f (fn [s]\n            (let [m (count (filter #(= % \\() s))]\n              (if (> m (/ (count s) 2))\n                (if (= m n)\n                  [(conj s \\))]\n                  [(conj s \\)) (conj s \\()])\n                [(conj s \\()])))]\n    (->> (iterate #(mapcat f %) '(()))\n         (take (inc (* n 2)))\n         (last)\n         (map #(apply str (reverse %)))\n         (set))))", "user": "5af907e6e4b0cc2b61a3bcda"}, {"problem": "195", "code": "(fn dyck-set [n] (if (zero? n) #{\"\"}\n    (set (for [i (range n) a (dyck-set (- n i 1)) b (dyck-set i)]\n          (str \"(\" a \")\" b)))))", "user": "5835cb06e4b089d5ab817cea"}, {"problem": "195", "code": "(fn p \n  ([n] (p \"\" #{} n n))\n  ([s a b e]\n   (let [o #(p (str s \\() a (dec b) e)\n         c #(p (str s \\)) a b (dec e))] \n     (cond\n       (= 0 b e) (conj a s)\n       (=   b e) (o)       \n       (= 0 b  ) (c) \n       :else     (into (o) (c))))))", "user": "577202d2e4b0979f896515c0"}, {"problem": "195", "code": "(fn parens [n]\n  (if (zero? n)\n    #{\"\"}\n    (set (mapcat (fn [s] (->>\n                          (range (count s) 0 -1)\n                          (map dec)\n                          (take-while #(= \\) (nth s %)))\n                          (map #(str (subs s 0 %) \"()\" (subs s %)))\n                          (cons (str s \"()\"))))\n                 (parens (dec n))))))", "user": "5953bdb6e4b066ee0a44aeed"}, {"problem": "195", "code": "(fn pairs\n  ([n] (if (zero? n) #{\"\"} (set (pairs n 0))))\n  ([n open]\n   (if (zero? n)\n     [(apply str (repeat open \")\"))]\n     (if (zero? open)\n       (map #(str \"(\" %) (pairs (dec n) (inc open)))\n       (concat\n         (map #(str \")\" %) (pairs n (dec open)))\n         (map #(str \"(\" %) (pairs (dec n) (inc open))))))))", "user": "53fe1b42e4b0de5c418485f1"}, {"problem": "195", "code": "(fn paren-generator[pairs]\n  (letfn [(can-open?[sexp] (< (sexp :open)  pairs))\n          (can-close?[sexp] (< (sexp :closed)  (sexp :open)))\n          (done?[sexp] (= (sexp :open) (sexp :closed) pairs))\n          (open[sexp] (assoc sexp :output (str (sexp :output) \"(\") :open (inc (sexp :open))))\n          (close[sexp] (assoc sexp :output (str (sexp :output) \")\") :closed (inc (sexp :closed))))]\n    (loop [results '({:output \"\", :open 0 :closed 0})]\n      (if (done? (first results))\n        (set (map :output results))\n        (recur\n         (mapcat\n          #(cond\n             (and (can-open? %) (can-close? %)) (list (close %) (open %))\n             (can-open? %) (list (open %))\n             (can-close? %) (list (close %)))\n          results))))))", "user": "5980f91ae4b021a7a535fddd"}, {"problem": "195", "code": "(fn p\n ([n] (p n n))\n ([l r]\n  (if (= 0 l r) #{\"\"}\n   (clojure.set/union\n    (when (> l 0)\n     (set (map #(str \"(\" % ) (p (dec l) r))))\n    (when (> r l)\n     (set (map #(str \")\" % ) (p l (dec r)))))))))", "user": "5b0180cfe4b0cc2b61a3bd47"}, {"problem": "195", "code": "(fn parens [n]\n  (condp = n\n    0 #{\"\"}\n    1 #{\"()\"}\n    (set\n      (for [i (range n)\n            lhs (parens i)\n            rhs (parens (- (- n 1) i))]\n        (str \"(\" lhs \")\" rhs)))))", "user": "5b13ba71e4b0cc2b61a3be53"}, {"problem": "195", "code": "(fn [n]\n  (last\n   (reduce\n    (fn [acc x]\n      (conj acc\n            (reduce into\n                    (map\n                     (fn [inner]\n                       (let [outer (- x 1 inner) iset (nth acc inner) oset (nth acc outer)]\n                         (reduce into\n                                 (map\n                                  (fn [iexpr]\n                                    (set (map (fn [oexpr] (str \"(\" iexpr \")\" oexpr)) oset)))\n                                  iset))))\n                     (range x)))))\n    [#{\"\"}]\n    (range 1 (inc n)))))", "user": "5b465b8be4b02d533a91bc65"}, {"problem": "195", "code": "(fn [n] (let [\np (fn pars [len openp] (if (> openp len) '() (if (< openp 0) '() (if (= 0 len) (list '()) (concat (map #(cons \\( %) (pars (dec len) (inc openp))) (map #(cons \\) %) (pars (dec len) (dec openp))))))))\n              ]\n          (into #{} (map #(apply str %) (p (* 2 n) 0)))))", "user": "5b4b4052e4b02d533a91bc9a"}, {"problem": "195", "code": "(fn pargen [n]\n  (cond\n    (zero? n) #{\"\"}\n    (= n 1) #{\"()\"}\n    :else (set (for [i (range n)\n                     a (pargen i)\n                     b (pargen (- (dec n) i))]\n                 (str \"(\" a \")\" b)))))", "user": "5b51b9f8e4b02d533a91bcfe"}, {"problem": "195", "code": "(fn a[n]\n  (loop [i 2 ss [ #{\"\"} #{\"()\"} ]]\n    (if (> i n)\n      (nth ss n)\n      (recur (inc i)\n      (conj ss \n        (set (concat (for [j (range 1 i) ai (nth ss j) aj (nth ss (- i j)) ] (str ai aj))\n                     (for [aj (last ss)] (str \"(\" aj \")\") ) ) )\n      )\n      )\n    )\n  )\n)", "user": "5b3aa98be4b02d533a91bbca"}, {"problem": "195", "code": "(fn p \n  ([n] (p n n))\n  ([l r]\n    (if (and (zero? l) (zero? r)) \n      #{\"\"}\n      (clojure.set/union\n        (when (> l 0)\n          (set (map #(str \"(\" % ) (p (dec l) r))))\n        (when (> r l)\n          (set (map #(str \")\" % ) (p l (dec r)))))))))", "user": "5b008bcae4b0cc2b61a3bd3d"}, {"problem": "195", "code": "(fn [n]\n  (let [result (atom #{})]\n    ((fn parens [l r s]\n      (when (and (zero? l) (zero? r)) (swap! result conj s))\n      (when (pos? l) (parens (dec l) (inc r) (str s \"(\")))\n      (when (pos? r) (parens l       (dec r) (str s \")\"))))\n    n 0 \"\")\n    @result))", "user": "5b772ad7e4b047b03b2036e8"}, {"problem": "195", "code": "(fn p [n]\n (if (zero? n) #{\"\"}\n  (into #{}\n   (for [i (range n)\n         j (p i)\n         k (p (- n 1 i))]\n    (str \\( j \\) k)))))", "user": "5b61aa6ae4b0c6492753e712"}, {"problem": "195", "code": "(fn pp\n    ([n] (into #{} (pp n n)))\n    ([l r]\n     (if (= 0 l r)\n       #{\"\"}\n       (lazy-seq\n        (concat\n         (when (< 0 l)\n           (map #(format \"(%s\" %)\n                (pp (dec l) r)))\n         (when (< l r)\n           (map #(format \")%s\" %)\n                (pp l (dec r)))))))))", "user": "54246fcce4b01498b1a71aed"}, {"problem": "195", "code": "(fn parens\n         [n]         \n         (case n\n           0 #{\"\"}\n           1 #{\"()\"}\n           (-> (concat (map #(vector (str \"()\" %)\n                                     (str % \"()\")\n                                     (str \"(\" % \")\"))\n                            (parens (dec n)))\n                       (->> (range 2 n)\n                            (map #(vector (parens %) (parens (- n %))))\n                            (map (fn [[ls rs]]\n                                   (for [l ls\n                                         r rs ]\n                                     [(str l r)\n                                      (str r l)])))))\n               (flatten)\n               (set))))", "user": "58e37946e4b005f69f193cae"}, {"problem": "195", "code": "(letfn [(generate-parens [prefix lefts rights]\n            (cond\n              (or (neg? rights) (neg? lefts)\n                  (let [freq (frequencies prefix)]\n                    (> (get freq \\) 0)\n                       (get freq \\( 0))))\n              #{}\n\n              (and (zero? lefts) (zero? rights))\n              #{prefix}\n\n              :else\n              (into\n               (generate-parens\n                (str prefix \\()\n                (dec lefts)\n                rights)\n               (generate-parens\n                (str prefix \\))\n                lefts\n                (dec rights)))))]\n    (fn [n] (generate-parens \"\" n n)))", "user": "539fa040e4b0ca733b97449f"}, {"problem": "195", "code": "(fn [n]\n  (loop [n n\n         r #{\"\"}]\n    (if (zero? n)\n      r\n      (let [new-r (into #{} (mapcat #(map (fn [n]\n                                            (str (subs % 0 n) \"()\" (subs % n)))\n                                          (range (inc (count %))))\n                                    r))]\n        (recur (dec n) new-r)))))", "user": "5125029de4b0ce9225d2ed3e"}, {"problem": "195", "code": "(fn g\n    ([n] (into #{} (map #(apply str %) (g n 0 0))))\n    ([n o c]\n     (if (= n o c) [[]]\n         (concat\n          (when (> o c)\n            (map #(cons \\) %) (g n o (inc c))))\n          (when (< o n)\n            (map #(cons \\( %) (g n (inc o) c)))))))", "user": "505106fee4b05ab4c7e07d38"}, {"problem": "195", "code": "(fn gen-parens\n  ([n] (if (= 0 n) #{\"\"} (set (gen-parens n 0))))\n  ([n open]\n   (if (= 0 n)\n     (vector (apply str (repeat open \")\")))\n     (if (= 0 open)\n       (map #(str \"(\" %) (gen-parens (dec n) 1))\n       (concat\n         (map #(str \")\" %) (gen-parens n (dec open)))\n         (map #(str \"(\" %) (gen-parens (dec n) (inc open))))))))", "user": "5bbdd136e4b07a9b28b0ffab"}, {"problem": "195", "code": "; this solution is not mine\n; it is clever solution I must admit, but my solution runs 2\n; times faster and yet 4clojure.com is reporting timeout error\n; I belive this is the bug.\n(fn parens [n]\n  (set\n   (map (partial apply str)\n        ((fn lazy-recur [open close]\n           (lazy-seq\n             (concat (when (pos? open)\n                       (map #(cons \\( %)\n                            (lazy-recur (dec open) (inc close))))\n                     (when (pos? close)\n                       (map #(cons \\) %)\n                            (lazy-recur open (dec close))))\n                     (when (= [0 0] [open close])\n                       [\"\"]))))\n         n 0))))\n; and here is mine solution which is not accepted\n;\n; (fn [n]\n;  (if (zero? n) #{\"\"}\n;      (let [ob \\( cb \\) init (apply str (concat (repeat n ob) (repeat n cb)))\n;            f (fn [s]\n;                (let [s1 (clojure.string/replace s \")\" \"\")\n;                      s2 (clojure.string/replace s \"(\" \"\")]\n;                  (str s1 s2)))\n;            f2 (fn [s i] (str (subs s 0 i) \")(\" (f (subs s (+ i 2)))))\n;            f3 (fn f3 [s] (let [i (.lastIndexOf s \"())\")]\n;                         (lazy-seq (cons s \n;                                         (when-not (neg? i)\n;                                           (f3 (f2 s i)))))))]\n;        (set (f3 init)))))", "user": "5bc833a5e4b07a9b28b100bb"}, {"problem": "195", "code": "(fn [n]\n    (let [extend (fn [{:keys [s openers-remaining closers-remaining]}]\n                   (->> [(when (> openers-remaining 0)\n                           {:s (conj s \\()\n                            :openers-remaining (dec openers-remaining)\n                            :closers-remaining (inc closers-remaining)})\n                  (when (> closers-remaining 0)\n                    {:s (conj s \\))\n                     :openers-remaining openers-remaining\n                     :closers-remaining (dec closers-remaining)})]\n                 (remove nil?)))]\n      (loop [possibilities [{:openers-remaining n\n                            :closers-remaining 0\n                            :s []}]\n             generation 0]\n        (if (= generation (* 2 n))\n          (->> possibilities\n               (map (comp #(apply str %) :s))\n               set)\n          (recur\n            (mapcat extend possibilities)\n            (inc generation))))))", "user": "5bab5440e4b0a20761a23475"}, {"problem": "195", "code": "(fn [x]\n  (let [f (fn f [x y]\n            (let [l (count (filter #(= \\( %) y))\n                  r (- (count y) l)\n                  lp (if (< l x) true false)\n                  rp (if (and (< r x)(< r l)) true false)]\n              (if (>= (+ l r) (* x 2))\n                y\n                (concat (if lp (f x (conj (apply vector y) \\()) nil)\n                        (if rp (f x  (conj (apply vector y) \\))) nil)))))\n         r (into #{} (map #(apply str %)(partition (* x 2) (f x \"\"))))]\n    (if (= r #{}) #{\"\"} r)))", "user": "566d71b1e4b0a866af6896ca"}, {"problem": "195", "code": "(fn f\n    ([n] (f n 0 \"\"))\n    ([n m s]\n     (if (>= n 1)\n       (if (>= m 1)\n         (clojure.set/union (f (dec n) (inc m) (str s \"(\"))\n                            (f n (dec m) (str s \")\")))\n         (f (dec n) (inc m) (str s \"(\")))\n       (if (>= m 1)\n         (f n (dec m) (str s \")\"))\n         #{s}))))", "user": "5be5cebde4b0ed4b8aab4d19"}, {"problem": "195", "code": "(fn __\n  [n]\n  (reduce\n   (fn [results p]\n     (reduce\n      (fn [res case] ; every existing case\n        (loop [c (count case)\n               r res]\n          (if (< c 0) r\n              (let [s (str (subs case 0 c) p (subs case c))]\n                (if (r s)\n                  (recur (dec c) r)\n                  (recur (dec c) (conj r s)))))\n          )\n        )\n      #{}\n      results))\n   #{\"\"}\n   (repeat n \"()\")))", "user": "5a0ce1a5e4b04bbd27e6d9b7"}, {"problem": "195", "code": "(fn [n]\n  (let [rec-fn (fn rec-fn [s l r]\n                 (if (and (zero? l) (zero? r))\n                   #{s}\n                   (clojure.set/union\n                    (when (> l 0)\n                      (rec-fn (str s \"(\") (dec l) r))\n                    (when (> r l)\n                      (rec-fn (str s \")\") l (dec r))))))\n        rec (memoize rec-fn)]\n    (rec \"\" n n)))", "user": "5ba15075e4b0a20761a2339e"}, {"problem": "195", "code": "(fn gen-par-comb\n  [n]\n  (let [aux-f (fn f [c b exp] \n                (cond\n                  (= c (dec (* 2 n))) (list  (f (inc c) (dec b) (str exp \")\")))  \n                  (or (< (- (* 2 n) c) (max b (- b))) (< b 0)) nil\n                  (= c (* 2 n)) exp\n                  :else (concat\n                         (f (inc c) (inc b) (str exp \"(\"))\n                         (f (inc c) (dec b) (str exp \")\")))))]\n    (if (zero? n)\n      #{\"\"}\n      (apply sorted-set (reverse (filter #(not (nil? %)) (drop-last (aux-f 0 0 \"\"))))))))", "user": "5c0466a3e4b0bdcf453d1680"}, {"problem": "195", "code": "(fn get-paren [n]\n  (loop [result #{}\n         q (conj clojure.lang.PersistentQueue/EMPTY {:p \"\" :l 0 :r 0})]\n    (if (empty? q)\n      result\n      (let [x (peek q) q (pop q)]\n        (if (= n (:r x))\n          (recur (conj result (:p x)) q)\n          (let [q (if (< (:r x) (:l x))\n                    (conj q {:p (str (:p x) \")\") :l (:l x) :r (inc (:r x))})\n                    q)\n                q (if (< (:l x) n)\n                    (conj q {:p (str (:p x) \"(\") :l (inc (:l x)) :r (:r x)})\n                    q)]\n            (recur result q)))))))", "user": "5c03e927e4b0bdcf453d167b"}, {"problem": "195", "code": "(fn br [n]\n  (if (<= n 0) \n    #{\"\"} \n    (loop [r #{} c n d 0]\n      (if (= c 0) \n        r \n        (recur (into r (for [p (br (dec c)) q (br d)] (str \"(\" p \")\" q ))) (dec c) (inc d))))))", "user": "5b919d9de4b0c0b3ffbd4a24"}, {"problem": "195", "code": "(fn parenth [n]\n  (let [f (fn f [s n o c] \n            (if (>= c n)\n              [(apply str s)]\n              [(when (> o c)(f (conj s \")\") n o (inc c)))\n              (when (< o n) (f (conj s \"(\") n (inc o) c))]))]\n    (->> (f [] n 0 0) flatten (filter string?) set)))", "user": "5274eb56e4b03e8d9a4a74bb"}, {"problem": "195", "code": "; I believe my first solution is more elegant and it gives better timing, but involves bit shifting and for some reason this site always have a problem with it and times out\n; On my local tests it gives better execution time than the other solution so I would like to post both\n;(defn parentheses-combos-full\n;  [n]\n;  (letfn\n;    [\n;     (bit-on? [n b] (= (bit-and (bit-shift-right n b) 1) 1))\n;     (count-bits-on\n;       [n]\n;       (Integer/bitCount n))\n;     (build-bracket-string\n;       [len val]\n;       (reduce #(if (bit-on? val %2) (str %1 \"(\") (str %1 \")\")) \"\" (range len)))\n;     (balanced-bits?\n;       [bits-count n]\n;       (loop [count 0 val n bits bits-count]\n;         (cond\n;           (neg? count) false\n;           (zero? bits) (if (zero? count) true false)\n;           :else (recur (if (bit-on? val 0) (inc count) (dec count)) (bit-shift-right val 1) (dec bits) ))))\n;     ]\n;    (let\n;      [r (filter\n;           #(and\n;              (= n (count-bits-on %))\n;              (bit-on? % 0)\n;              (balanced-bits? (* n 2) %)\n;              ;(not (bit-on? % (int (dec (Math/pow 2 (* n 2))))))\n;\n;              )\n;           (range 1 (Math/pow 2 (dec (* n 2))) 2))]\n;      (reduce #(conj %1 (build-bracket-string (* n 2) %2)) #{} r))))\n  \n(fn parentheses-combos-var2\n  ([n] (set (flatten (parentheses-combos-var2 (* 2 n) \"\" 0))))\n  ([n s c]\n    (cond\n      (zero? n) [s]\n      (= n 1) [(str s \")\")]\n      (>= c n) (parentheses-combos-var2 (dec n) (str s \")\") (dec c))\n      (> c 0) [\n               (parentheses-combos-var2 (dec n) (str s \"(\") (inc c))\n               (parentheses-combos-var2 (dec n) (str s \")\") (dec c))\n               ]\n      :else (parentheses-combos-var2 (dec n) (str s \"(\") (inc c)))))", "user": "5c20b6abe4b07e362c230576"}, {"problem": "195", "code": "(fn gen-parens\n  ([n] (if (= 0 n) #{\"\"} (set (gen-parens n 0))))\n  ([n open]\n   (if (= 0 n)\n     (vector (apply str (repeat open \")\")))\n     (if (= 0 open)\n       (map #(str \"(\" %) (gen-parens (dec n) 1))\n       (concat\n         (map #(str \")\" %) (gen-parens n (dec open)))\n         (map #(str \"(\" %) (gen-parens (dec n) (inc open))))))))", "user": "5c2649c8e4b07e362c2305bf"}, {"problem": "195", "code": "(fn gen-parens\n  [n]\n  (cond\n    (= 0 n)\n    #{\"\"}\n    \n    (= 1 n)\n    #{\"()\"}\n\n    :else\n    (into #{}\n          (mapcat (fn [x]\n                    (map\n                     (fn [y] (str (subs x 0 y) \"()\" (subs x y (count x))))\n                     (range 1 (inc (count x))))) \n                  (gen-parens (dec n))))))", "user": "5b759ca8e4b047b03b2036d0"}, {"problem": "195", "code": "(fn p \n  ([n] (p n n))\n  ([left right]\n    (if (and (zero? left) (zero? right)) \n      #{\"\"}\n      (clojure.set/union\n        (when (> left 0)\n          (set (map #(str \"(\" % ) (p (dec left) right))))\n        (when (> right left)\n          (set (map #(str \")\" % ) (p left (dec right)))))))))", "user": "5b0bd9cfe4b0cc2b61a3bdd9"}, {"problem": "195", "code": "(fn brkts [n]\n  (loop [found #{} tofind [[\"\" n n]]]\n    (if (empty? tofind) found\n          (let [[s l r] (first tofind)] \n              (cond (= l r 0) (recur (conj found s) (rest tofind)) \n                    (= l r) (recur found (cons [(str \")\" s) l (dec r)] (rest tofind) ))\n                    (= r 0) (recur found (cons [(str \"(\" s) (dec l) r] (rest tofind) ))\n                    :else (recur found (concat [[(str \"(\" s) (dec l) r] [(str \")\" s) l (dec r)]] (rest tofind)))\n                        )))))", "user": "5be6d0f8e4b0f319e2d7ec51"}, {"problem": "195", "code": "(fn parentheses-again\n  ([n] (parentheses-again n \"\" 0 0))\n  ([n result open closed]\n    (if (= (+ open closed) (* 2 n))\n      #{result}\n      (clojure.set/union\n        (if (< open n) (parentheses-again n (str result \"(\") (inc open) closed))\n        (if (> open closed) (parentheses-again n (str result \")\") open (inc closed)))))))", "user": "5c3ac091e4b0d62ef62d9f95"}, {"problem": "195", "code": "(fn p\n  ([n] (p #{\"\"} n n))\n  ([s o c]\n   (cond\n     (= 0 o c) s\n     (< 0 o c) (clojure.set/union (p (map #(str % \"(\") s) (- o 1) c)\n                                  (p (map #(str % \")\") s) o (- c 1)))\n     (= 0 o) (p (set (map #(str % \")\") s)) o (- c 1))\n     :else (p (set (map #(str % \"(\") s)) (- o 1) c))))", "user": "5c1aadcde4b01240ff567209"}, {"problem": "195", "code": "(fn parens [n]\n  (letfn [(cp [p]\n            (loop [acc 0\n                   result nil]\n              (let [h (take acc p)\n                    t (drop acc p)\n                    current (str (apply str h) \"()\" (apply str t))]\n                (if (seq t)\n                  (recur (inc acc) (conj result current))\n                  (set (conj result current))))))\n          (combine-p [coll]\n            (set (apply concat (map cp coll))))]\n    (if (= n 0)\n      #{\"\"}\n      (if (= n 1)\n        #{\"()\"}\n        (combine-p (parens (dec n)))))))", "user": "57b9fb56e4b0fbc9809a27fa"}, {"problem": "195", "code": "(fn well-formed-parentheses [n]\n  (let [mem (memoize \n             (fn well-formed-parentheses-memoized [mem n]\n               (if (= 0 n)\n                 #{\"\"}\n                 (let [partitions (fn partitions [n]\n                                    (if (= 0 n)\n                                      #{[]}\n                                      (set (mapcat (fn [k] (map concat (repeat [(- n k)]) (partitions k))) (range n)))))\n                       cartesian-product (fn cartesian-product [a & colls]\n                                           (if (empty? colls)\n                                             (map vector a)\n                                             (for [i a\n                                                   j (apply cartesian-product colls)]\n                                               (cons i j))))]\n                   (set (apply concat \n                          (map (fn wrap [s] (str \"(\" s \")\")) (mem mem (dec n)))\n                          (map (fn [partition] (map (partial apply str) (apply cartesian-product (map (partial mem mem) partition)))) (remove #{[n]} (partitions n)))))))))]\n    (mem mem n)))", "user": "5c506951e4b0f9f7a8770ec5"}, {"problem": "195", "code": "(fn [i]\n  (if (zero? i)\n    #{\"\"}\n    (->> (iterate\n           (fn [xs]\n             (into\n               #{}\n               (mapcat\n                 (fn [s]\n                   (map #(str (subs s 0 %) \"()\" (subs s % (count s))) (range 0 (count s))))\n                 xs)))\n           #{\"()\"})\n         (drop (dec i))\n         first)))", "user": "59419bdfe4b060784b3b78f7"}, {"problem": "195", "code": "(fn f ([n] (if (= 0 n) #{\"\"} (set (f n 0))))\n  ([n o] (do (prn n o)(concat (if (> n 0) (concat (if (> o 0) (map #(str \")\" %) (f n (dec o))) nil)\n                                                  (map #(str \"(\" %) (f (dec n) (inc o)))) (list (apply str (take o (repeat \")\")))))))))", "user": "5c41db45e4b08cd430848ece"}, {"problem": "195", "code": "(fn func [n]\n\t(letfn [(add [s]\n\t\t\t\t(set (map #(str (subs s 0 %) \"()\" (subs s %)) (range (count s)))))]\n\t\t(case n\n\t\t\t0 #{\"\"}\n\t\t\t1 #{\"()\"}\n\t\t\t(->>(map add (func (dec n)))\n\t\t\t\t(apply clojure.set/union)))))", "user": "57c647bbe4b05aa3c4741cf3"}, {"problem": "195", "code": "(fn [n]\n(let[ \n  add-opening (fn [string value opening closing]\n  (hash-map :string (str string \"(\") :value (inc value) :opening (dec opening) :closing closing))\n  add-closing (fn [string value opening closing]\n  (hash-map :string (str string \")\") :value (dec value) :opening opening :closing (dec closing)))\n  apply-next (fn [{string :string value :value opening :opening closing :closing}]\n  (if (= value 0)\n    (hash-set (add-opening string value opening closing))\n    (if (= opening 0)\n      (hash-set (add-closing string value opening closing))\n      (conj #{} (add-opening string value opening closing) (add-closing string value opening closing))\n    )\n    ))\n  build-next (fn build-next [input]\n  (reduce clojure.set/union (map apply-next input)))]\n  (loop [x 0 res #{(hash-map :string \"\" :value 0 :opening n :closing n)}]\n    (if (= x (* 2 n))\n      (into #{} (map :string res))\n      (recur (inc x) (build-next res))))\n\n  )  \n)", "user": "5c9b848fe4b048ec896c5acf"}, {"problem": "195", "code": "(letfn [(prefix-all [e strs]\n            (into #{} (map #(str e %) strs)))\n          (doors [nb-opens remaining]\n            (if (zero? remaining)\n              #{(apply str (repeat nb-opens \")\"))}\n              (let [ropens (doors (inc nb-opens) (dec remaining))\n                    opens (prefix-all \"(\" ropens)]\n                (if (> nb-opens 0)\n                  (let [rcloses (doors (dec nb-opens) remaining)\n                        closes (prefix-all \")\" rcloses)]\n                    (clojure.set/union opens closes))\n                  ;; nothing opened\n                  opens))))]\n    (fn [n]\n      (doors 0 n)))", "user": "54ca93abe4b057c6fda3a264"}, {"problem": "195", "code": ";; http://www.4clojure.com/problem/195\n(fn gen-parans \n  ([parans-left] (if (zero? parans-left) #{\"\"} (into #{} (gen-parans parans-left 0))))\n  ([parans-left num-open-parans]\n   (if (zero? parans-left)\n     (list (apply str (repeat num-open-parans \")\")))\n     (if (zero? num-open-parans)\n       (map (partial str \"(\") (gen-parans (dec parans-left) 1))\n       (concat\n         (map (partial str \")\") (gen-parans parans-left (dec num-open-parans)))\n         (map (partial str \"(\") (gen-parans (dec parans-left) (inc num-open-parans))))))))", "user": "5c92105ce4b048ec896c59f7"}, {"problem": "195", "code": "(fn par-combos \n  ([n] (par-combos n n \"\" #{}))\n  ([left-pars right-pars par-combo par-combo-set]\n   (if (= 0 left-pars right-pars)\n     (conj par-combo-set par-combo)\n     (-> par-combo-set\n         (#(if (> right-pars left-pars)\n             (into % (par-combos\n                      left-pars\n                      (dec right-pars)\n                      (str par-combo \")\")\n                      par-combo-set))\n             %))\n         (#(if (> left-pars 0)\n             (into % (par-combos\n                      (dec left-pars)\n                      right-pars\n                      (str par-combo \"(\")\n                      par-combo-set))\n             %))))))", "user": "53504fe6e4b084c2834f4ada"}, {"problem": "195", "code": "(fn [n]\n  (set ((fn paren [op cl]\n     (cond\n      (and (= n op) (= n cl)) '(\"\")\n      (= op cl) (map #(str \"(\" %) (paren (inc op) cl))\n      (= op n) (map #(str \")\" %) (paren op (inc cl)))\n      :else (concat (map #(str \"(\" %) (paren (inc op) cl)) (map #(str \")\" %) (paren op (inc cl))))\n      )\n     ) 0 0))\n  )", "user": "5cebafbbe4b0a17bb84e2be6"}, {"problem": "195", "code": "(fn parens\n  [n]\n  (case n\n    0 #{\"\"}\n    1 #{\"()\"}\n    (set\n      (mapcat\n        (fn\n          [s]\n          (map #(str (subs s 0 %) \"()\" (subs s %)) (range 0 (count s))))\n        (parens (dec n))))))", "user": "5d0bb4fae4b0cc9c91588237"}, {"problem": "195", "code": "(fn parens [n]\n  (first\n   (loop [sets '(#{\"\"})\n          k 0]\n     (if (= k (* 2 n)) sets\n         (let [extended (concat '(#{}) sets '(#{} #{}))\n               triplets (partition 3 1 extended)\n               max-size (if (<= k n) n (- n (- k n)))\n               next-sets (map (fn [[low center top :as triplet]]\n                                (do\n                                  (clojure.set/union\n                                   (set (map #(str % \"(\") low))\n                                   (set (map #(str % \")\") top)))))\n                              triplets) ]\n           (recur\n            (take (inc max-size) next-sets)\n            (inc k)))))))", "user": "5d9c1226e4b0d3f9b434ad51"}, {"problem": "195", "code": "(letfn [(f [l r v] (cond (= r 0) v\n                         (= l 0) (map #(conj % \\)) (f l (dec r) v))\n                         (= l r) (map #(conj % \\() (f (dec l) r v))\n                         :else (concat\n                                (map #(conj % \\)) (f l (dec r) v))\n                                (map #(conj % \\() (f (dec l) r v)))))]\n  (fn ([n] (set (map #(apply str %) (f n n [()]))))))", "user": "5db92996e4b010eb3c36cd50"}, {"problem": "195", "code": "(fn [n]\n    (letfn [(legalall [s]\n             (let [ lsize (count (re-seq #\"\\(\" s))]\n              (and (> lsize (/ (count s) 2)) (< lsize n))))\n           \n           (legalleft [s]\n             (let [ lsize (count (re-seq #\"\\(\" s))]\n             (< lsize n)))\n           \n            (add [v]\n               (reduce (fn [acc i]\n                    (cond\n                        (= (* 2 n) (count i)) (conj acc i)\n                        (legalall i) (conj acc (str i \"(\") (str i \")\"))\n                        (legalleft i) (conj acc (str i \"(\"))\n                        :else (conj acc (apply str i (repeat (- (* n 2) (count i)) \")\"))))) [] v))]\n            (if (= 0 n) #{\"\"}        \n             (loop [v '(\"(\") s (range 1 (* n 2))]\n               (if (empty? s) (set v)\n                   (recur (add v) (rest s)))))))", "user": "5dc12b0ae4b0e59a23173d84"}, {"problem": "195", "code": "(fn [n]\n  (loop [result [{:o n :c n :p \"\"}]]\n    (if (every? #(= 0 (:o %) (:c %)) result)\n      (set (map :p result))\n      (->> result\n           (map (fn [{:keys [o c p]}]\n                  [{:o (dec o) :c c :p (str p \"(\")}\n                   {:o o :c (dec c) :p (str p \")\")}]))\n           flatten\n           (filter #(<= (:o %) (:c %)))\n           (remove #(< (:o %) 0))\n           recur))))", "user": "5ab16992e4b073f1774425c4"}, {"problem": "195", "code": "(fn parens\n  ([n] (parens \"\" n 0 0))\n  ([s n open close]\n   (if (= n close)\n     #{s}\n     (clojure.set/union\n      (if (< open n)\n        (parens (str s \"(\") n (inc open) close)\n        #{})\n      (if (< close open)\n        (parens (str s \")\") n open (inc close))\n        #{})\n      ))\n   )\n  )", "user": "5d9c9446e4b0eb781811cdae"}, {"problem": "195", "code": "(fn parentheses [n]\n    (let\n        [\n            parens\n                (memoize (fn f [g n]\n                    (if (<= n 0)\n                        #{\"\"}\n                        (let\n                            [\n                                possibilities\n                                    (for\n                                        [\n                                            v (range n)\n                                            p1 (g g v)\n                                            p2 (g g (- n v 1))\n                                        ]\n                                        (str \"(\" p1 \")\" p2)\n                                    )\n                            ]\n                            (into #{} possibilities)\n                        )\n                    )\n                ))\n            parens\n                (partial parens parens)\n        ]\n        (parens n)\n    )\n)", "user": "5db7376fe4b010eb3c36cd43"}, {"problem": "195", "code": "(fn paren\n  [n]\n  (if (< 0 n)\n    (set \n     (for [m (range n)\n           x (paren (- n m 1))\n           y (paren m)]\n       (str \\( x \\) y)))\n    #{\"\"}))", "user": "5c94e60de4b048ec896c5a3e"}, {"problem": "195", "code": "(fn boo\n  ([n] (boo \"\" n 0 0))\n  ([s n open close]\n    (if (= n close)\n      #{s}\n      (clojure.set/union\n        (if (< open n) (boo (str s \"(\") n (inc open) close))\n        (if (< close open) (boo (str s \")\")  n open (inc close)))))))", "user": "529dfc6de4b04e0c58e87b8a"}, {"problem": "195", "code": "(fn [total]\n        (letfn [(followers [subset]\n                  (let [opened (- (* 2 (count (filter #(= \\( %) subset)))\n                                  (count subset))\n                        missing (- (* 2 total) (count subset))]\n                    (cond\n                      (zero? opened) #{(str subset \"(\")}\n                      (= opened missing) #{(str subset \")\")}\n                      :else #{(str subset \"(\") (str subset \")\")})))]\n          (loop [n 0 acc #{\"\"}]\n            (if (= (* 2 total) n)\n              acc\n              (recur (inc n)\n                     (reduce (fn [a b]\n                               (clojure.set/union a\n                                                  (followers b)))\n                             #{}\n                             acc))))))", "user": "5cc6b4bfe4b0ccb061962827"}, {"problem": "195", "code": "(fn dfs\n  ([n] (dfs \"\" n 0 0))\n  ([ans n l r]\n   (if (= n r)\n     #{ans}\n     (clojure.set/union\n       (if (< l n)\n         (dfs (str ans \"(\") n (inc l) r)\n         #{})\n       (if (< r l)\n         (dfs (str ans \")\") n l (inc r)))\n       ))))", "user": "5dfa1c67e4b0a607a9a45cc5"}, {"problem": "195", "code": "#((fn gen [n-l n-r s]\n    (cond\n     (= 0 n-l n-r) #{s}\n     (= n-l n-r) (gen (dec n-l) n-r (str s \"(\"))\n     (zero? n-l) (gen n-l (dec n-r) (str s \")\"))\n     :else (apply conj (gen (dec n-l) n-r (str s \"(\")) (gen n-l (dec n-r) (str s \")\"))))) % % \"\")", "user": "5dd60c58e4b0948ae9d9ad7c"}, {"problem": "195", "code": "(fn parensagain [limit]\n  (let [state [0 \"\"]\n        lim (* 2 limit)\n        solver (fn [state generator solved?]\n                 (let [solve-state (fn find-fut-states [state]\n                                     (let [fut-states (for [gen-state (generator state)\n                                                            fut-state (find-fut-states gen-state)] fut-state)]\n                                       (if (solved? state)\n                                         (cons state fut-states)\n                                         fut-states)))]\n                   (solve-state state)))\n        generator (fn [[bal st]]\n                    (when (< (count st) lim)\n                      (if (zero? bal)\n                        [[(inc bal) (str st \"(\")]]\n                        [[(dec bal) (str st \")\")] [(inc bal) (str st \"(\")]]\n                        )))\n        solved? (fn [[bal st]]\n                  (and\n                    (zero? bal)\n                    (= (count st) lim)\n                    ))\n        ]\n    (set (map second (solver state generator solved?)))))", "user": "590b055ae4b047aa04b199c9"}, {"problem": "195", "code": "(fn f [n]\n  (if (= n 0) #{\"\"}\n      (let [q (map f (range 1 n))\n            t (map #(str \"(\" % \")\") (f (dec n)))]\n        (reduce conj (set t)\n                     (for [[s p] (map list q (reverse q)) \n                           a s b p]\n                       (str a b))))))", "user": "575ddfd1e4b02ea11479938d"}, {"problem": "195", "code": "(fn f195 [n]\n  (let [f (fn f [stack string n]\n            (cond\n              (and (empty? stack) (= n (count string))) #{string}\n              (and (= n (count string))) []\n              (and (< (count string) n)) (if (= \"(\" (first stack))\n                                           (clojure.set/union (f (rest stack) (str string \")\") n) (f (cons \"(\" stack) (str string \"(\") n))\n                                           (f (cons \"(\" stack) (str string \"(\") n)\n                                           )\n              )\n            )\n        ]\n    (f [] \"\" (* 2 n))\n    )\n  )", "user": "583048d9e4b051871117c007"}, {"problem": "195", "code": "(fn [pairs]\n    (let [result (atom #{})]\n      (letfn [(step [exp open closed]\n                (if (= open closed pairs) (swap! result #(conj % exp))\n                    (do\n                      (when (< open pairs) (step (str exp \"(\") (inc open) closed))\n                      (when (< closed open) (step (str exp \")\") open (inc closed))))))]\n        (step \"\" 0 0))\n      @result))", "user": "5d236215e4b02ea6f0fb6a09"}, {"problem": "195", "code": "(fn m [a] (if (zero? a) #{\"\"} (into #{} (for [i (range a)\n                                              j (m i)\n                                              k (m (- a 1 i))]\n    \t\t\t\t\t\t\t\t\t\t(str \"(\" j \")\" k)))))", "user": "5c379636e4b0d62ef62d9f76"}, {"problem": "195", "code": "(fn [level]\n   (let [next-level (fn [path-lists]\n             (let [paths\n                   (reduce\n                    (fn [acc e]\n                      (cons (concat (map #(str \"(\" %) (first acc))\n                                    (map #(str \")\" %) e))\n                            acc))\n                    ()\n                    path-lists)]\n               (reverse (cons (map #(str \"(\" %) (first paths)) paths))))]\n     (loop [level level\n            acc '((\"\"))]\n       (if (zero? level)\n         (set (last acc))\n         (recur (dec level) (next-level acc))))))", "user": "5e3ef7d4e4b01d43a70e8e2d"}, {"problem": "195", "code": "(fn [n]\n  (last\n   (reduce (fn [coll len]\n             (conj coll\n                   (set (for [i (range len)\n                              l (nth coll i)\n                              r (nth coll (- len 1 i))]\n                          (str \"(\" l \")\" r)))))\n           [#{\"\"}] (range 1 (inc n)))))", "user": "5c3796b3e4b0d62ef62d9f77"}, {"problem": "195", "code": "(fn [n]\n  (set\n    (nth\n      (iterate\n        #(mapcat\n           (fn [s]\n             (let [l (reduce (fn [a c] (if (= \\( c) (inc a) a)) 0 s)\n                   r (- (count s) l)\n                   v (if (< l n) [(str s \"(\")] [])]\n               (if (< r l)\n                 (conj v (str s \")\"))\n                 v)))\n           %)\n        [\"\"])\n      (* 2 n))))", "user": "4eb70649535d7eef30807373"}, {"problem": "195", "code": ";ozan's solution\n(fn gen-parens\n  ([n] (if (= 0 n) #{\"\"} (set (gen-parens n 0))))\n  ([n open]\n   (if (= 0 n)\n     (vector (apply str (repeat open \")\")))\n     (if (= 0 open)\n       (map #(str \"(\" %) (gen-parens (dec n) 1))\n       (concat\n         (map #(str \")\" %) (gen-parens n (dec open)))\n         (map #(str \"(\" %) (gen-parens (dec n) (inc open))))))))\n\n; naive implementation which calculates up to n=8\n;(let [g (fn [coll x] (apply str (concat (take x coll) [\\( (nth coll x) \\)] (drop (+ x 1) coll))))\n;f (fn [coll] (fn [x] \n;\t(cond\n;  \t\t(= x 0) (apply str (concat '(\\( \\)) coll))\n;  \t\t(= x (+ (count coll) 1)) (apply str (concat coll '(\\( \\))))\n;  \t\t:else (g coll (- x 1)))))\n;h (fn [s] (set (map (f s) (range 0 (+ (count s) 2)))))\n;st #{\"(())\" \"()()\"}\n;mh (fn [s] (apply clojure.set/union (map h s)))\n;]\n;\n;(cond\n;(= n 0) #{\"\"}\n;(= n 1) #{\"()\"}\n;:else (last (take (- n 1) (iterate mh st))))\n;)", "user": "5e13a6b7e4b099d064963001"}, {"problem": "195", "code": "(fn paranthesis-again [n]\n  (set ((fn helper [result c l r value]\n          (if (and (= 0 l) (= 0 r))\n            (conj result value)\n            (let [a (if (and (> c 0) (> r 0)) (helper result (dec c) l (dec r) (str value \\))) [])\n                  b (if (> l 0) (helper result (inc c) (dec l) r (str value \\()))]\n              (concat result a b))))\n        []\n        0\n        n\n        n\n        \"\")))", "user": "5dc53ddee4b02f9375f4e1bd"}, {"problem": "195", "code": "(fn pars\n  ([n] (set (pars \"\" n 0)))\n  ([s m c]\n   (if (zero? m)\n     [s]\n     (concat \n       (when (> c 0) (pars (str s \")\") (dec m) (dec c)))\n       (when (< c m) (pars (str s \"(\") m (inc c)))))))", "user": "5b64370ae4b0c6492753e73c"}, {"problem": "195", "code": "(fn pps\n  ([n] (pps n n 0 \"\"))\n  ([n op dep acc]\n   (cond\n     (= n 0) (conj #{} acc)\n     (= op 0) (conj #{} (str acc (apply str (repeat n \")\"))))\n     (= dep 0) (pps n (dec op) (inc dep) (str acc \"(\"))\n     :else (clojure.set/union (pps n (dec op) (inc dep) (str acc \"(\"))\n                              (pps (dec n) op (dec dep) (str acc \")\"))))))", "user": "5eb1c786e4b00a66d4a95201"}, {"problem": "195", "code": "(fn p [n]\n  (if (= n 0)\n    #{\"\"}\n    (let [r (p (dec n))\n          o clojure.string/join m map\n          i (fn [x] (m #(o \"()\" (m o (split-at %1 x))) (range (inc (count x)))))]\n      (set (mapcat i r)))))", "user": "5a244240e4b0ff51aa4b32e9"}, {"problem": "195", "code": "(fn p [n]\n  (case n\n    0 #{\"\"}\n    1 #{\"()\"}\n    (set\n     (concat\n      (mapcat #(vector (str \\( % \\)) (str \"()\" %) (str % \"()\"))\n              (p (dec n)))\n      (for [i (range 2 (dec n))\n            l (p i)\n            r (p (- n i))]\n        (str l r))))))", "user": "50ed4626e4b01236b1d4983c"}, {"problem": "195", "code": "(fn [n]\n  (letfn [(backtrack [cur left right max]\n                     (if (= (count cur) (* max 2)) \n                       #{cur}\n                       (concat (when (< left max) \n                                 (backtrack (str cur \"(\")\n                                            (inc left)\n                                            right \n                                            max))\n                               (when (< right left)\n                                 (backtrack (str cur \")\")\n                                            left\n                                            (inc right)\n                                            max)))))]\n    (into #{} (backtrack \"\" 0 0 n))))", "user": "5ebdb3d2e4b00a66d4a95275"}, {"problem": "195", "code": "(fn [n-pairs]\n  ((fn add-par [prev n-rem]\n     (let [n-open (apply - (map count [(re-seq #\"\\(\" prev) (re-seq #\"\\)\" prev)]))]\n       (cond\n         (= n-rem 0) #{prev}\n         (= n-open 0) (add-par (str prev \"(\") (dec n-rem))\n         (= n-open n-rem) (add-par (str prev \")\") (dec n-rem))\n         :else (into (add-par (str prev \"(\") (dec n-rem))\n                     (add-par (str prev \")\") (dec n-rem)))))) \"\" (* 2 n-pairs)))", "user": "5ed875abe4b016b56eae05f2"}, {"problem": "195", "code": "(fn f\n  ([n]\n   (f n 0 #{\"\"}))\n  ([n a acc]\n   (if (= a n)\n     acc\n     (recur n\n            (inc a)\n            (set (mapcat (fn [s] (map #(str (subs s 0 %)\n                                            \"()\"\n                                            (subs s %))\n                                      (range (inc (count s)))))\n                         acc))))))", "user": "5db0172be4b0f8c104ccfc96"}, {"problem": "195", "code": "(fn [n]\n    (letfn [(build [prefix oparens cparens numo]\n              (if \n                  (and (zero? oparens) (zero? cparens)) (list prefix)\n                  (flatten\n                   (filter first\n                           (for [i '(:o :c)]\n                             (cond (and (= i :o) (> oparens 0))\n                                   (build (str prefix \\()\n                                          (dec oparens) cparens (inc numo))\n                                   (and (= i :c)\n                                        (> cparens 0) (> numo 0))\n                                   (build (str prefix \\))\n                                          oparens\n                                          (dec cparens)\n                                          (dec numo))\n                                   )))))\n              )]\n      (set (build \"\" n n 0))))", "user": "5eee7311e4b07c55ae4a0510"}, {"problem": "195", "code": "(fn parens\n  ([n] (parens \"\" n 0 0))\n  ([s n open close]\n   (if (= n close)\n     #{s}\n     (clojure.set/union\n      (if (< open n)\n        (parens (str s \"(\") n (inc open) close)\n        #{})\n      (if (< close open)\n        (parens (str s \")\") n open (inc close))\n        #{})\n      ))\n   )\n  )", "user": "5e6ca949e4b04a83ad7cd289"}, {"problem": "195", "code": "(fn pp [x]\n(case x\n  0 #{\"\"} \n  1 #{\"()\"}\n  ;2 #{\"()()\" \"(())\"}\n  (apply clojure.set/union\n         (for [xx (pp (dec x))]\n           (loop [result #{} done \"\" undone xx]\n             (if (re-find #\"\\(\\)\" undone) \n               (if (= \"()\" (subs undone 0 2)) \n                 (recur (conj result (str done \"()()\" (subs undone 2))(str done \"(())\" (subs undone 2)))\n                        (str done \"()\")\n                        (subs undone 2))\n                 (recur result \n                        (str done (subs undone 0 1))\n                        (subs undone 1)))\n               result))))))", "user": "5951190be4b066ee0a44aea4"}, {"problem": "195", "code": "(fn parens [n]\n  (let [is-complete #(= (* 2 n) (count (:v %)))\n        with-o #(-> % (update-in [:open] inc) (update-in [:v] conj \\())\n        with-c #(-> % (update-in [:closed] inc) (update-in [:v] conj \\)))\n        branch? (complement is-complete)\n        children (fn [s]\n                   (let [{:keys [open closed]} s\n                         with-open (with-o s)\n                         with-closed (with-c s)]\n                     (cond\n                       ;; If we're balanced, can only add an open\n                       (= open closed) [with-open]\n                       ;; If we have opens (and closeds) left\n                       (< open n) [with-open with-closed]\n                       ;; Otherwise just closeds left\n                       :else [with-closed])))]\n    (->> (tree-seq branch? children {:open 0 :closed 0 :v []})\n         (filter is-complete)\n         (map :v)\n         (map (partial apply str))\n         (set))))", "user": "5ca14eb1e4b048ec896c5b7d"}, {"problem": "195", "code": "(fn [n]\n  (let [n*2 (* 2 n)\n        gen-combos (fn [m]\n                     (loop [x 0\n                            tab [#{\"\"}]]\n                       (if (= x m)\n                         (last tab)\n                         (let [new-length (* 2 (count tab))\n                               new-strings (set\n                                            (for [close-paren-i (range 1 new-length 2)\n                                                  :let [left-string-length (- close-paren-i 1)\n                                                        right-string-length (- new-length left-string-length 2)]\n                                                  left-string (tab (quot left-string-length 2))\n                                                  right-string (tab (quot right-string-length 2))]\n                                              (str \"(\" left-string \")\" right-string)))]\n                           (recur (+ 2 x) (conj tab new-strings))))))]\n    (gen-combos n*2)))", "user": "5ec6de19e4b08d0ec38692da"}, {"problem": "195", "code": "#(disj (set (flatten ((fn p [s n open close]\r\n                        (if (zero? n) [\"\"]\r\n                            (if (= close n)\r\n                              s\r\n                              [(when (> open close) (p (str s \")\") n open (inc close)))\r\n                               (when (< open n) (p (str s \"(\") n (inc open) close))]))) \"\" % 0 0))) nil)", "user": "5f2c02d1e4b033932238a65f"}, {"problem": "195", "code": "(fn parens [n]\n  (loop [i 2 j 0 subres [] res [#{\"\"} #{\"()\"}]]\n    (cond\n      (> i n) (res n)\n      (== j i) (recur (inc i) 0 [] (conj res (set subres)))\n      :else\n      (recur\n        i\n        (inc j)\n        (into subres\n              (for [front (map (fn [inner] (str \"(\" inner \")\")) (res j))\n                    rear (res (- i j 1))]\n                (str front rear)))\n        res))))", "user": "5f300f28e4b033932238a682"}, {"problem": "195", "code": "(fn parentheses-again\n    ([n] (parentheses-again \"\" n 0 0))\n  ([s n open close]\n   (if (= n close)\n     #{s}\n     (clojure.set/union\n      (when (< open n)\n        (parentheses-again (str s \"(\") n (inc open) close))\n      (when (< close open)\n        (parentheses-again (str s \")\") n open (inc close)))))))", "user": "5d81b40ce4b0915913b1d379"}, {"problem": "195", "code": "(fn doit [n]\n\t(letfn [(phelper [wip maxo o c]\n\t\t(cond\n\t\t\t(or (> o maxo) (> c maxo) (> c o)) #{}\n\t\t\t(= o c maxo) #{wip}\n\t\t\t:else (clojure.set/union\n\t\t\t\t(phelper (clojure.string/join [wip, \"(\"]), maxo, (inc o), c)\n\t\t\t\t(phelper (clojure.string/join [wip, \")\"]), maxo, o, (inc c))\n\t\t\t)\n\t\t)\n\t)]\n\t\t(phelper \"\" n 0 0)\n\t)\n)", "user": "5d73530ce4b02e6b30c93514"}, {"problem": "195", "code": "(fn balpar [n]\n  (letfn [\n          (count-lp [a] (count (filter (fn [e] (= e \\()) a)))\n          (to-lp-idx [a] (second (reduce (fn [[i acc] e] (if (= e \\() [(inc i) (conj acc [e i])] [i (conj acc [e nil])]) ) [0 []] a)))\n          (step [c']\n              (loop [cnt (dec (count-lp c')) acc (list (str \"()\" c')) c (to-lp-idx c')]\n                (if (< cnt 0) acc\n                              (recur (dec cnt) (cons \n                                                 (clojure.string/join (map (fn [[e i]] (if (= i cnt) \"(()\" e) ) c) )\n                                                 acc) c))))]\n    (loop [c 0 acc #{\"\"}]\n      (if (>= c n) acc\n                  (recur (inc c) (into #{} (flatten (map step acc))))))))", "user": "53a5bc3ae4b0ef122a8689c3"}, {"problem": "195", "code": "(fn parallel-brackets\n  [n]\n  (let [has-max-open-parens? (fn\n                               [agenda-item max-open-parens]\n                               (= (reduce + (filter pos? agenda-item)) max-open-parens))\n        has-open-paren?      (fn\n                               [agenda-item]\n                               (pos? (reduce + agenda-item)))\n        generate-new-agenda-item (fn\n                                   [max-open-parens agenda-item]\n                                   (cond\n                                     (has-max-open-parens? agenda-item max-open-parens)\n                                     [(conj agenda-item -1)]\n                                     (has-open-paren? agenda-item)\n                                     [(conj agenda-item -1) (conj agenda-item 1)]\n                                     :else\n                                     [(conj agenda-item 1)]))]\n    (loop [iteration 0 agg [[]]]\n      (if (= iteration (* 2 n))\n        (set (map (fn [r] (apply str (map (fn [i] (if (pos? i) \"(\" \")\")) r))) agg))\n        (recur (inc iteration) (mapcat (partial generate-new-agenda-item n) agg))))))", "user": "4daeabf6edd6309eace4d15c"}, {"problem": "195", "code": "(fn balanced [n]\n    ;(println \"balanced-really\" n)\n    (if (zero? n)\n        #{\"\"}\n        (set (for [i (range n)\n                   x (balanced  i)\n                   y (balanced  (- n i 1))\n                  ] (clojure.string/join [\"(\" x \")\" y] )))))", "user": "5eff6c0ee4b0cf489e8d7f11"}, {"problem": "195", "code": "(fn foo\n   ([n] (foo n 0))\n   ([n o]\n    (cond\n      (and (zero? n) (zero? o)) #{\"\"}\n      (zero? n) (into #{} (map #(str \")\" %) (foo n (dec o))))\n      (zero? o) (into #{} (map #(str \"(\" %) (foo (dec n) (inc o))))\n      :else (clojure.set/union\n             (into #{} (map #(str \"(\" %) (foo (dec n) (inc o))))\n             (into #{} (map #(str \")\" %) (foo n (dec o))))))))", "user": "5f3abcc4e4b004f08c61c52b"}, {"problem": "195", "code": "(fn parentheses\n  ([n] (parentheses n 0 0 \"\"))\n  ([n o c s]\n   (clojure.set/union\n    (when (= c n) #{s})\n    (when (< o n) (parentheses n (inc o) c (str s \"(\")))\n    (when (and (< c o) (< c n)) (parentheses n o (inc c) (str s \")\"))))))", "user": "5cf895efe4b0b71b1d808a85"}, {"problem": "195", "code": "(fn pars3 [n]\n  (if (= n 0) #{\"\"}\n      (set\n       (concat\n        (for [i (range 1 (inc n))\n              p1 (pars3 (dec i))\n              p2 (pars3 (- n i))]\n            (str \"(\" p1 \")\" p2))))))", "user": "5fa74b82e4b0fa27300f3dda"}, {"problem": "195", "code": "(fn asdfhkj\n  ([n] (asdfhkj \"\" n 0 0))\n  ([s n open close]\n   (if (= n close)\n     #{s}\n     (clojure.set/union\n      (if (>= open n)\n        #{}\n        (asdfhkj (str s \"(\") n (inc open) close)\n        )\n      (if (>= close open)\n        #{}\n        (asdfhkj (str s \")\") n open (inc close))\n        )\n      ))\n   )\n  )", "user": "5e8ce2fee4b0cb0169546328"}, {"problem": "195", "code": "(fn p195\n  ([x] (set (p195 (* 2 x) [] [])))\n  ([depth res acc]\n   (if (= depth (count res))\n     (if (zero? (apply + res))\n       (cons (clojure.string/join (map #(if (= 1 %) \"(\" \")\") res)) acc)\n       acc)\n     (concat (p195 depth (conj res 1) acc) (if (zero? (apply + res)) acc (p195 depth (conj res -1) acc)))\n     ))\n  )", "user": "5fa17538e4b0f0ebd91b77e3"}, {"problem": "195", "code": "(fn [n]\n    (letfn [(open [state]\n                  (if (<= (:paren state) 0)\n                      nil\n                      (-> state\n                          (assoc :paren (dec (:paren state)))\n                          (assoc :open (inc (:open state)))\n                          (assoc :path (str (:path state) \\()))))\n            (close [state]\n                   (if (<= (:open state) 0)\n                       nil\n                       (-> state\n                           (assoc :open (dec (:open state)))\n                           (assoc :path (str (:path state) \\))))))]\n        (loop [pending [{:paren n :open 0 :path \"\"}]\n               acc #{}]\n            (if (empty? pending)\n                acc\n                (let [state (first pending)\n                      ostate (open state)\n                      cstate (close state)\n                      pending' (->> (rest pending)\n                                    (#(if ostate (conj % ostate) %))\n                                    (#(if cstate (conj % cstate) %)))\n                      acc' (if (and (= 0 (:paren state)) (= 0 (:open state)))\n                               (conj acc (:path state))\n                               acc)]\n                    (recur pending' acc'))))))", "user": "600ae927e4b074f607df6689"}, {"problem": "195", "code": "(fn all-parens-v1 [num]\n  (letfn [\n          (at-pos [pos orig]\n            (str (subs orig 0 pos) \"()\" (subs orig pos)))\n          (parens-from-orig [orig]\n            (set (map #(at-pos % orig) (range (inc (count orig))))))\n          (parens-from-set-of-origs [soo i] ;; i is to enable reduce.\n            (let [m (map parens-from-orig soo)]\n              (reduce #(into %1 %2) m)))]\n     (reduce #(parens-from-set-of-origs %1 %2)  #{\"\"} (range num))))", "user": "5ff676a9e4b06df49cee1497"}, {"problem": "195", "code": "(fn [n]\n(letfn [(p [open close c]\n(concat\n(when (= 0 open close) (list (apply str c)))\n(when (pos? open) (p (dec open) (inc close) (conj c \"(\")))\n(when (pos? close) (p open (dec close) (conj c \")\")))))]\n(set (p n 0 []))))", "user": "5fd10010e4b07e53c2f3f02a"}, {"problem": "195", "code": "(fn [n]\n  (set ((fn parentheses [left right accum]\n          (cond (= right n) [accum]\n                (= left n) (parentheses left (inc right) (str accum \\)))\n                (= left right) (parentheses (inc left) right (str accum \\())\n                (> left right) (concat (parentheses (inc left) right (str accum \\( ))\n                                       (parentheses left (inc right) (str accum \\) ))))) 0 0 \"\")))", "user": "58f98231e4b0438e51c2cf4c"}, {"problem": "195", "code": "(fn parens\n\n  ([n] (parens \"\" n 0 0))\n  ([s n open close]\n   (if (= n close)\n     #{s}\n     (clojure.set/union\n      (if (< open n)\n        (parens (str s \"(\") n (inc open) close)\n        #{})\n      (if (< close open)\n        (parens (str s \")\") n open (inc close))\n        #{})\n      ))\n   )\n  )", "user": "6011b89ee4b074f607df66bc"}, {"problem": "195", "code": "(fn all-brackets [a]\n  (if (zero? a)\n    #{\"\"}\n    (set (for [b (range a)\n               s1 (all-brackets b)\n               s2 (all-brackets (dec (- a b)))]\n           (str \"(\" s1 \")\" s2)))))", "user": "601aaa93e4b0bf4ca6b10926"}, {"problem": "195", "code": "(fn f\n  ([n] (f \"\" n 0 0))\n  ([s n open close]\n   (if (= n close)\n     #{s}\n     (into\n      (if (< open n)\n        (f (str s \"(\") n (inc open) close)\n        #{})\n      (if (< close open)\n        (f (str s \")\") n open (inc close))\n        #{})))))", "user": "5dc88a38e4b02f9375f4e1db"}, {"problem": "195", "code": "(fn all-par [n]\n  (letfn [(concat-two-lst [l1 l2])])\n  (cond\n    (zero? n) #{\"\"}\n    (= n 1) #{\"()\"}\n    :else (set (mapcat (fn [x]\n                         (concat (map #(str (apply str (repeat x \\())\n                                            %\n                                            (apply str (repeat x \\))))\n                                      (all-par (- n x)))\n                                 (map #(str (apply str (repeat (- n x) \\())\n                                            %\n                                            (apply str (repeat (- n x) \\))))\n                                      (all-par x))\n                                 (apply concat (for [l1 (all-par x)\n                                                     l2 (all-par (- n x))]\n                                                 [(str l1 l2)\n                                                  (str l2 l1)]\n                                                 ))))\n                       (range 1 (inc (quot n 2)))))))", "user": "60096aabe4b074f607df667f"}, {"problem": "195", "code": "(fn [n]\n  (letfn [(recur-fn\n           [result paren stack]\n           (cond\n            (and (zero? paren)\n                 (zero? stack)) (hash-set result)\n            \n            (zero? paren)\n            (recur (str result \")\") paren (dec stack))\n            \n            (zero? stack)\n            (recur (str result \"(\") (dec paren) (inc stack))\n            \n            :else\n            (set (concat\n                   (recur-fn (str result \")\") paren (dec stack))\n                   (recur-fn (str result \"(\") (dec paren) (inc stack))))))]\n    (recur-fn \"\" n 0)))", "user": "5cb41c40e4b026601754b911"}, {"problem": "195", "code": "(fn balanced-parens [n]\n  (letfn [(from-level [n-left level]\n            (cond (= 0 n-left) (list (apply str (repeat level \\))))\n                  (= 0 level) (map #(str \\( %)\n                                   (from-level (dec n-left) (inc level)))\n                  :else (concat\n                         (map #(str \\( %)\n                              (from-level (dec n-left) (inc level)))\n                         (map #(str \\) %)\n                              (from-level n-left (dec level))))))]\n    (set (from-level n 0))))", "user": "60460824e4b02d28681c77bc"}, {"problem": "195", "code": "(fn [n] (letfn \n         [(next [n s o]\n                (if (zero? n)\n                  (if (zero? o) #{s} #{})\n                  (if (zero? o)\n                    (next (dec n) (str s \\() (inc o))\n                    (clojure.set/union (next (dec n) (str s \\() (inc o)) (next (dec n) (str s \\)) (dec o))))))]\n          (next (* n 2) \"\" 0)))", "user": "604d3cb1e4b0b7ec0ac60ac2"}, {"problem": "195", "code": "(fn parens\n  ([n]\n   (if (zero? n)\n     #{\"\"}\n     (set (parens (repeat n \"(\") []))))\n  ([left right]\n   (if (empty? left)\n     (vector (apply str right))\n     (if (empty? right)\n       (map #(str (first left) %) (parens (rest left) [\")\"]))\n       (concat\n         (map #(str (first right) %) (parens left (rest right)))\n         (map #(str (first left) %) (parens (rest left) (conj right \")\"))))))))", "user": "4e586949535d8a8b8723a292"}, {"problem": "195", "code": "(fn g\n    ([n] (set (g n 0 [])))\n    ([n d s]\n     (if (zero? n)\n       #{(apply str (concat s (repeat d \\))))}\n       (concat (if (> d 0)\n                 (g n (dec d) (conj s \\)))\n                 [])\n               (g (dec n) (inc d) (conj s \\())))))", "user": "5bd0ea60e4b0e9689409ee45"}, {"problem": "195", "code": "(fn [n]\n  (letfn [(rec [m l c k]\n            (if (contains? m [l c k])\n              (get m [l c k])\n              (let [result \n                    (if (= k :open)\n                      (map #(cons \\( %) (go m (dec l) (inc c)))\n                      (map #(cons \\) %) (go m (dec l) (dec c))))]\n                (do\n                  (assoc! m [l c k] result)\n                  result))))\n          (go [m l c]\n            (cond\n              (= l 0) '(())\n              (zero? c) (rec m l c :open)\n              (= l c) (rec m l c :close)\n              :else (concat (rec m l c :open) (rec m l c :close))))]\n    (set (map (partial apply str) (go (transient {}) (* 2 n) 0)))))", "user": "605b7a90e4b079a07f8593fc"}, {"problem": "195", "code": "(fn parentheses\n  ([n]\n   (case n\n     0\n     #{\"\"}\n\n     1\n     #{\"()\"}\n\n     (into #{}\n           (flatten\n             (parentheses \"\" n n)))))\n  ([acc x y]\n   (cond (zero? y)\n         acc\n\n         (zero? x)\n         (str acc (apply str (repeat y \")\")))\n\n         (= x y)\n         (parentheses (str acc \"(\") (dec x) y)\n\n         (< x y)\n         [(parentheses (str acc \"(\") (dec x) y)\n          (parentheses (str acc \")\") x (dec y))])))", "user": "605b49b7e4b079a07f8593f8"}, {"problem": "195", "code": "(fn [n]\n  (letfn [(proc [q r]\n            (let [[paren left right] (first q)\n                  q (rest q)\n                  r (if (> 0 left)\n                      (conj r \"\") r)\n                  r (if (and (= 0 left) (= 0 right))\n                      (conj r paren) r)\n                  q (if (< 0 left)\n                      (conj q [(str paren \"(\") (dec left) right])\n                      q)\n                  q (if (and (< 0 right) (< left right))\n                      (conj q [(str paren \")\") left (dec right)])\n                      q)]\n              [q r]))]\n    (loop [q [[\"(\" (dec n) n]] r #{}]\n      (if (empty? q)\n        r\n        (let [[q r] (proc q r)]\n          (recur q r))))))", "user": "606a70a5e4b069485764ddf2"}, {"problem": "195", "code": "(fn generate-paren-combos [n]\n  (if (zero? n)\n    #{\"\"}\n    (loop [combos #{\"(\"}\n           counter (dec (* 2 n))]\n      (if (zero? counter)\n        combos\n        (recur\n          (reduce\n            (fn [results s]\n              (let [freq (frequencies s)]\n                (cond\n                  (= n (freq \\()) (conj results (str s \\)))\n                  (= (freq \\() (freq \\))) (conj results (str s \\())\n                  :else (conj results (str s \\() (str s \\))))))\n            #{}\n            combos)\n          (dec counter))))))", "user": "54d9366ce4b0a52adc2e204e"}, {"problem": "195", "code": "(fn parens\n  ([n] (parens \"\" n 0 0))\n  ([s n open close]\n   (if (= n close)\n     #{s}\n     (clojure.set/union\n      (if (< open n)\n        (parens (str s \"(\") n (inc open) close)\n        #{})\n      (if (< close open)\n        (parens (str s \")\") n open (inc close))\n        #{})\n      ))\n   ))", "user": "608ec5e4e4b03bd49d9f36c0"}, {"problem": "195", "code": "(fn [n]\n  (letfn [(gen-parens-rec [paren-str num-to-open num-unclosed]\n            (if (every? zero? [num-unclosed num-to-open])\n              #{paren-str}\n              (set (concat\n                     (if (pos? num-to-open)\n                       (gen-parens-rec (str paren-str \"(\") (dec num-to-open) (inc num-unclosed))\n                       #{})\n                     (if (pos? num-unclosed)\n                       (gen-parens-rec (str paren-str \")\") num-to-open (dec num-unclosed))\n                       #{})))))]\n    (gen-parens-rec \"\" n 0)))", "user": "4fe49706e4b0e8f79898feb7"}]