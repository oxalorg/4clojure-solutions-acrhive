[{"code": "(fn [x]\n  (let [y {\\I 1 \\V 5 \\X 10 \\L 50\n           \\C 100 \\D 500 \\M 1000}]\n    (apply +\n     (reduce\n      #(let [z (y %2)]\n        (conj %1 (if (>= z (last %1))\n        z\n        (- z))))\n      [0]\n      (reverse x)))))", "problem": 92, "user": "4da3e51330acd6ed10482a68"}, {"code": "#((reduce\r\n    (fn [[a p] c]\r\n      [((if(< (% c) p) - +) a (% c)) (% c)])\r\n    [0 0] (reverse %2))\r\n  0)\r\n{\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}", "problem": 92, "user": "4dce6e41535d5973398f92a2"}, {"code": "#(apply +(reduce(fn[[f & r :as a]x](let[n(get{\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}x)](if(>= n f)(conj a n)(conj r(- f n)))))'(0)(reverse%)))", "problem": 92, "user": "4dad8fe9c9a9d6ed1899dc57"}, {"code": "(fn tmp [st]\r\n  (let [vMap {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000}]\r\n    (loop [sum 0 cur (first st) tst (rest st)]\r\n      (println sum \":\" cur \":\" tst)\r\n      (cond\r\n        (not cur) sum\r\n        (empty? tst) (+ (vMap cur) sum)\r\n        (< (vMap cur) (vMap (first tst)))  (recur \r\n                                             (+ (- (vMap (first tst)) (vMap cur)) sum) \r\n                                             (second tst) \r\n                                             (rest (rest tst)))\r\n        :else (recur (+ (vMap cur) sum) (first tst) (rest tst))))))", "problem": 92, "user": "4dbdab4e535d020aff1edf49"}, {"code": "(fn [[c0 & cs0]]\r\n  (let [m {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000}\r\n        d {\\M \\C, \\D \\C, \\C \\X, \\L \\X, \\X \\I, \\V \\I}]\r\n    (loop [[c & cs] cs0, p c0, ret 0, a (m c0)]\r\n      (cond (nil? c) (+ ret a)\r\n            (= p (d c)) (recur cs c (- ret a) (m c))\r\n            (= p c) (recur cs c ret (+ a (m c)))\r\n            :else (recur cs c (+ ret a) (m c))))))", "problem": 92, "user": "4db2903f535df7e46ed9b6bf"}, {"code": "(fn [n]\r\n  (let [rn {\"I\" 1 \"V\" 5 \"X\" 10 \"L\" 50 \"C\" 100 \"D\" 500 \"M\" 1000}]\r\n    (apply + (reduce (fn[c e] (if (< (last c) (rn (str e))) (conj (apply vector (butlast c)) (- (rn (str e)) (last c))) (conj c (rn (str e))))) [(rn (str (first n)))] (rest n)))))", "problem": 92, "user": "4dc42799c647a3c54c2ddc71"}, {"code": "(fn [s]\r\n  (apply +\r\n         (map #(Integer/parseInt %)\r\n              (re-seq #\"[0-9]+\"\r\n                      (reduce #(clojure.string/replace %1 (first %2) (second %2)) s\r\n                              [[\"IV\" \"4 \"]\r\n                               [\"IX\" \"9 \"]\r\n                               [\"XL\" \"40 \"]\r\n                               [\"XC\" \"90 \"]\r\n                               [\"CD\" \"400 \"]\r\n                               [\"CM\" \"900 \"]\r\n                               [\"I\" \"1 \"]\r\n                               [\"V\" \"5 \"]\r\n                               [\"X\" \"10 \"]\r\n                               [\"L\" \"50 \"]\r\n                               [\"C\" \"100 \"]\r\n                               [\"D\" \"500 \"]\r\n                               [\"M\" \"1000 \"]])))))", "problem": 92, "user": "4dc1ee85535d020aff1edf91"}, {"code": "(fn roman [x] \r\n  (let [m {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000} \r\n        s {[\\C \\M] 900 [\\C \\D] 400 [\\X \\C] 90 [\\X \\L] 40 [\\I \\X] 9 [\\I \\V] 4}] \r\n    (loop [q (partition-all 2 1 x) \r\n           r 0] \r\n      (if (empty? q) \r\n        r \r\n        (if-let [t (get s (first q))] \r\n          (recur (rest (rest q)) (+ r t))\r\n          (recur (rest q) (+ r (get m (first (first q))))))))))", "problem": 92, "user": "4dae916eedd6309eace4d155"}, {"code": "(fn calc\n       ([s] (calc 0 (seq s)))\n       ([sum s] \n         (let [nums {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000}\n               cur (nums (first s))\n               more (next s)\n               nex (nums (first more))]\n           (cond\n             (nil? nex) (+ sum cur)\n             (< cur nex) (calc (- sum cur) more)\n             :default (calc (+ sum cur) more)))))", "problem": 92, "user": "4daddc19c9a9d6ed4599dc57"}, {"code": "(fn rr [[f & [s & r :as nxt]]]\r\n  (condp #(or %1 %2) nil\r\n    ({\"IV\" 4 \"IX\" 9 \"XL\" 40 \"XC\" 90 \"CD\" 400 \"CM\" 900}\r\n     (str f s)) :>> #(+ % (rr r))\r\n     ({\"I\" 1 \"V\" 5 \"X\" 10 \"L\" 50 \"C\" 100 \"D\" 500 \"M\" 1000}\r\n      (str f)) :>> #(+ % (rr nxt))\r\n      0))", "problem": 92, "user": "4dada16fc9a9d6ed2699dc57"}, {"code": "(fn [r]    \r\n  (let [values {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]\r\n    (loop [n 0 rem r]\r\n  \t  (if (empty? rem)\r\n  \t  \tn\r\n        (let [r1 (values (first rem)) r2 (values (second rem))]\r\n  \t\t  (if (and r2 (< r1 r2))\r\n  \t\t\t(recur (+ n (- r2 r1)) (drop 2 rem))\r\n  \t\t\t(recur (+ n r1) (rest rem))))))))", "problem": 92, "user": "4db85282535d1e037afb218a"}, {"code": "(fn k-r [r]\n     (let [lookup {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}\n  \tdecimal (reverse (map #(get lookup %)(seq r)))]\n\t\t(first (reduce\n\t\t (fn [sp c]\n\t\t     (if (< c (last sp)) (vector (- (first sp) c) c) (vector (+ (first sp) c) c))) [0 0] decimal))))", "problem": 92, "user": "4dae4da5c9a9d6ed4e99dc57"}, {"code": "(fn [r]\r\n  (let [letter-values {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000}]\r\n\t\t(first\r\n\t\t\t(reduce\r\n\t\t\t\t(fn [[total prev-v] v]\r\n\t\t\t\t\t(if (> v prev-v)\r\n\t\t\t\t\t\t[(+ (- total prev-v) (- v prev-v)) v]\r\n\t\t\t\t\t\t[(+ total v)                       v]))\r\n\t\t\t\t[0 Integer/MAX_VALUE]\r\n\t\t\t\t(map (partial get letter-values) (seq r))))))", "problem": 92, "user": "4dd6d6a0535d2dad7130b5ca"}, {"code": "(fn roman-to-number [roman-str]\r\n  (letfn [(roman-num[c]\r\n  \t    (cond (= c \"X\") 10\r\n\t\t\t  (= c \"I\") 1\r\n\t\t\t  (= c \"V\") 5\r\n\t\t\t  (= c \"L\") 50\r\n\t\t\t  (= c \"D\") 500\r\n\t\t\t  (= c \"C\") 100\r\n\t\t\t  (= c \"M\") 1000\r\n\t\t\t  :else 0))\r\n\t  ]\r\n  (let [roman_all (reverse (re-seq #\"[A-Z]\" roman-str))]\r\n    (loop [r roman_all\r\n\t   xs '()]\r\n      (if (nil? (first r))\r\n\t(reduce + xs)\r\n\t(let [n (roman-num (first r))]\r\n\t  (cond (nil? (first xs)) (recur (rest r) (cons n xs))\r\n\t\t(< n (first xs)) (recur (rest r) (cons (* -1 n) xs))\r\n\t\t:else (recur (rest r) (cons n xs)))))))))", "problem": 92, "user": "4ddc620d535d02782fcbea06"}, {"code": "(fn [s]\r\n    (let [trans {:M 1000\r\n                 :D 500\r\n                 :C 100\r\n                 :L 50\r\n                 :X 10\r\n                 :V 5\r\n                 :I 1\r\n                 :CM 900\r\n                 :CD 400\r\n                 :XC 90\r\n                 :XL 40\r\n                 :IX 9\r\n                 :IV 4}]\r\n    (reduce \r\n      + \r\n      (map \r\n        #((keyword %) trans)\r\n        (reduce (fn [a b]\r\n                  (let [l (peek a)\r\n                        c (str l b)]\r\n                    (cond\r\n                      (or (= \"IV\" c)\r\n                          (= \"IX\" c)\r\n                          (= \"XL\" c)\r\n                          (= \"XC\" c)\r\n                          (= \"CM\" c)\r\n                          (= \"CD\" c)) (conj (pop a) c)  \r\n                      :else (conj a (str b))))) [] s)))))", "problem": 92, "user": "4dd61f98535d2dad7130b5c6"}, {"code": "(fn roman\r\n     ([i-literal] (roman 0 i-literal))\r\n     ([i-result i-literal]\r\n      (if (zero? (count i-literal))\r\n        i-result\r\n        (let [\r\n              v-map {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500 \\M 1000}\r\n              head (first i-literal)\r\n              tail (rest i-literal)\r\n              t-head (first tail)\r\n              ]\r\n          (if (and (not (nil? t-head)) (> (get v-map t-head) (get v-map head)))\r\n            (roman (+ i-result (- (get v-map t-head) (get v-map head))) (rest tail))\r\n            (roman (+ i-result (get v-map head)) tail))))))", "problem": 92, "user": "4dddf817535d08e6dec9fdd3"}, {"code": "(fn [s]\r\n  (let [m  {\\I 1\r\n            \\V 5\r\n            \\X 10\r\n            \\L 50\r\n            \\C 100\r\n            \\D 500\r\n            \\M 1000}]\r\n    ((reduce (fn [r c]\r\n               (if (< (m (r 1)) (m c))\r\n                 [(+ (- (r 0) (m (r 1))) (- (m c) (m (r 1)))) c]\r\n                 [(+ (r 0) (m c)) c]))\r\n             [0 \\M]\r\n             s) 0)))", "problem": 92, "user": "4de2f44f535d08e6dec9fdec"}, {"code": "(fn rom [r]\r\n  (let [m {\\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1}]\r\n    (loop [[a b :as r] r, tot 0]\r\n      (if (empty? r)\r\n        tot\r\n        (let [av (m a), bv (m b)]\r\n          (if (and a b (< av bv))\r\n            (recur (drop 2 r) (+ tot (- bv av)))\r\n            (recur (drop 1 r) (+ tot av))))))))", "problem": 92, "user": "4dbb0b6c535d1e037afb21b0"}, {"code": "(fn [s]\r\n  (let [sn {[\\C \\M] 900  [\\C \\D] 400 [\\X \\C] 90 \r\n             [\\X \\L] 40 [\\I \\X] 9 [\\I \\V] 4}]\r\n    (letfn [(asn [[f & r]]\r\n                      (if f\r\n                        (+ (if-let [n (sn [f (first r)])] \r\n                             n 0)\r\n                           (asn r))\r\n                        0))\r\n            (dsn [[f & r]]\r\n                         (when f\r\n                           (if (sn [f (first r)])\r\n                             (dsn (rest r))\r\n                             (cons f (dsn r)))))]\r\n      (reduce + (asn s) (map {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000} (dsn s))))))", "problem": 92, "user": "4dc986d0535d5973398f9285"}, {"code": "(fn [string]\r\n  (let [ones {\"I\" 1, \"II\" 2, \"III\" 3, \"IV\" 4,\r\n              \"V\" 5, \"VI\" 6, \"VII\" 7, \"VIII\" 8, \"IX\" 9}\r\n        tens {\"X\" 10, \"XX\" 20, \"XXX\" 30, \"XL\" 40,\r\n              \"L\" 50, \"LX\" 60, \"LXX\" 70, \"LXXX\" 80, \"XC\" 90}\r\n        hundreds   {\"C\" 100, \"CC\" 200, \"CCC\" 300, \"CD\" 400,\r\n                    \"D\" 500, \"DC\" 600, \"DCC\" 700, \"DCCC\" 800, \"CM\" 900}\r\n        thousands  {\"M\" 1000, \"MM\" 2000, \"MMM\" 3000}\r\n\r\n        numbers [ones tens hundreds thousands]\r\n\r\n        last-subs (fn [s len]\r\n                    (let [start (- (count s) len)]\r\n                      (if (>= start 0)\r\n                        (subs s start)\r\n                        nil)))]\r\n    \r\n    (loop [numbers numbers\r\n           s string\r\n           acc 0]\r\n  \r\n      (let [nums (first numbers)\r\n            max-subs-len (apply max (map count (keys nums)))\r\n        \r\n            pair (first (for [i (range max-subs-len 0 -1)\r\n                              :when (nums (last-subs s i))]\r\n                          (list (subs s 0 (- (count s) i))\r\n                                (nums (last-subs s i)))))\r\n        \r\n            next-string (first pair)\r\n            number (second pair)]\r\n\r\n        (if (empty? next-string)\r\n          (+ acc number)\r\n          (recur (next numbers) next-string (+ acc number)))))))", "problem": 92, "user": "4e0d8c27535d04ed9115e7b7"}, {"code": "#(let [rtoa {\\I 1 \\V 5 \\X 10 \\L 50  \\C 100 \\D 500 \\M 1000}\n       arabic (map rtoa (reverse %))]\n    (loop [[d & r] arabic maxVal 0 sum 0]\n      (if (nil? d)\n          sum\n          (if (<  d maxVal)\n            (recur r maxVal (- sum d))\n            (recur r d (+ sum d))))))", "problem": 92, "user": "4daa374930acd6ed13482a68"}, {"code": "(fn r [[c & s :as i]]\r\n  (let [t {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000}]\r\n    (cond\r\n      (empty? i) 0\r\n      (empty? s) (t c)\r\n      (< (t c) (t (first s))) (- (r s) (t c))\r\n      true (+ (r s) (t c)))))", "problem": 92, "user": "4e03c616535d04ed9115e796"}, {"code": "(fn [s]\r\n  (let [snum {[\\C \\M] 900  [\\C \\D] 400 [\\X \\C] 90 \r\n             [\\X \\L] 40 [\\I \\X] 9 [\\I \\V] 4}\r\n        nums {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]\r\n    (letfn [(sum-snum [[f & r]]\r\n                      (if f\r\n                        (+ (if-let [n (snum [f (first r)])] \r\n                             n 0)\r\n                           (sum-snum r))\r\n                        0))\r\n            (del-snum [[f & r]]\r\n                         (when f\r\n                           (if (snum [f (first r)])\r\n                             (del-snum (rest r))\r\n                             (cons f (del-snum r)))))]\r\n      (reduce + (sum-snum s) (map nums (del-snum s))))))", "problem": 92, "user": "4e1158aa535d04ed9115e7c6"}, {"code": "(fn[s]\r\n  (let [v {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]\r\n    (reduce + (v (last s)) \r\n              (map #(let [t (v %)] \r\n                      (if(< t (v %2)) (- t ) t))  \r\n                 s (rest s)))))", "problem": 92, "user": "4deff9f9535d08e6dec9fe15"}, {"code": "(fn [coll]\n  (let [t {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}\n        c (map t coll)]\n    (+ (last c) (apply + (map #(if (< %1 %2) (- %1) %1) c (rest c))))))", "problem": 92, "user": "4e14108c535d04ed9115e7dd"}, {"code": "(fn roman-numbers\n  ([x]\n    (roman-numbers x 0))\n  ([y z]\n    (let [dictionary {\"I\" 1 \"IV\" 4 \"V\" 5 \"IX\" 9 \"X\" 10 \"XL\" 40 \"L\" 50 \"XC\" 90 \"C\" 100 \"CD\" 400 \"D\" 500 \"CM\" 900 \"M\" 1000}  \n      addNum (fn [w q]\n      (+ q (get dictionary w))) \n          requires-two? (fn [t]\n            (if (contains? #{\"IV\" \"IX\" \"XL\" \"XC\" \"CD\" \"CM\"} t)\n              true\n              false))]\n    (if (= 0 (count y))\n      z\n      (if (and (> (count y) 1) (requires-two? (subs y 0 2)))\n        (recur (subs y 2) (addNum (str (get y 0) (get y 1)) z))\n        (recur (subs y 1) (addNum (str (get y 0)) z)))))))", "problem": 92, "user": "4e16bdef535d04ed9115e7e9"}, {"code": "(fn roman_to_arabic [s] \n  (loop [ret 0 xs (vec s) rn_map {:I 1 :V 5 :X 10 :L 50 :C 100 :D 500 :M 1000}]    \n    (if (empty? xs)\n      ret\n      (if (= (count xs) 1)\n        (+ ret ((keyword (str (first xs))) rn_map))\n        (if (>= ((keyword (str (first xs))) rn_map) ((keyword (str (second xs))) rn_map))\n          (recur (+ ret ((keyword (str (first xs))) rn_map)) (rest xs) rn_map)\n          (recur (- ret ((keyword (str (first xs))) rn_map)) (rest xs) rn_map))))))", "problem": 92, "user": "4e123905535d04ed9115e7ce"}, {"code": "#(loop [s % c 0 m {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]\n(if s\n  (recur (next s) (\n    (if (and (next s) (> (m (nth s 1)) (m (nth s 0)))) - +)\n     c (m (nth s 0))) m) c))", "problem": 92, "user": "4e43b0d9535dc968683fc4a3"}, {"code": "(fn parse-roman [s]\n  (let [values (partition 2 '(\"M\" 1000\n  \t\t      \"CD\" 400\n\t\t\t      \"CM\" 900\n\t\t\t      \"D\" 500\n\t\t\t      \"XC\" 90\n\t\t\t      \"C\" 100\n\t\t\t      \"XL\" 40\n\t\t\t      \"L\" 50\n\t\t\t      \"IX\" 9\n\t\t\t      \"X\" 10\n\t\t\t      \"IV\" 4\n\t\t\t      \"V\" 5\n\t\t\t      \"I\" 1))]\n    (loop [s s result 0]\n\t     (if (empty? s)\n\t       result\n\t       (let [[prefix value] (first (filter (fn [[k v]] (.startsWith s k)) values))]\n\t\t (recur (.substring s (count prefix))\n\t\t\t(+ result value)))))))", "problem": 92, "user": "4e513ecf535dc968683fc4f6"}, {"code": "(fn f\n  ([r] (f (map {\\I 1 \\V 5\n                \\X 10 \\L 50\n                \\C 100 \\D 500\n                \\M 1000}\n               r) 0))\n  ([[a & [b :as c]] n]\n   (if c\n     (f c ((if (>= a b) + -) n a))\n     (+ n a))))", "problem": 92, "user": "4e12cc9d535d04ed9115e7d2"}, {"code": "(fn [r]\n  (let [d {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}\n        v (conj (vec (map d r)) 0)]\n    (reduce + (map (fn [[x y]] (if (< x y) (- x) x))\n                   (partition 2 1 v)))))", "problem": 92, "user": "4ddbdc1b535d02782fcbe9fd"}, {"code": "(fn [roman]\n  (let [decimal-val {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000}]\n    (loop [dec 0, vals (map decimal-val roman)]\n      (if (empty? vals)\n        dec\n        (if (and (> (count vals) 1) (< (first vals) (second vals)))\n          (recur (+ dec (- (second vals) (first vals))) (drop 2 vals))\n          (recur (+ dec (first vals)) (rest vals)))))))", "problem": 92, "user": "4e52d815535d302ef430da77"}, {"code": "(let [conv [[\"CM\" 900] [\"M\" 1000]\n            [\"CD\" 400] [\"D\" 500]\n            [\"XC\" 90]  [\"C\" 100]\n            [\"XL\" 40]  [\"L\" 50]\n            [\"IX\" 9]   [\"X\" 10]\n            [\"IV\" 4]   [\"V\" 5]\n            [\"I\" 1]]]\n  (fn rn [s]\n    (if (empty? s)\n      0\n      (loop [cs conv]\n        (let [[t v] (first cs)]\n          (if (.startsWith s t)\n            (+ v (rn (apply str\n                      (drop (count t) s))))\n            (recur (rest cs))))))))", "problem": 92, "user": "4ddbfb8a535d02782fcbea00"}, {"code": "(fn [s]\n    (reduce + (map #(let [[x y] %] ((if (and y (< x y)) - +) x))\n                   (partition-all 2 1 (map {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000} s)))))", "problem": 92, "user": "4e4ad154535dc968683fc4d1"}, {"code": "(let [roman {\\I 1,\n             \\V 5,\n             \\X 10,\n             \\L 50,\n             \\C 100,\n             \\D 500,\n             \\M 1000}\n      get-value (fn [x next]\n                  (if (and next\n                           (< (roman x) (roman next)))\n                    (- (roman x))\n                    (roman x)))]\n  (fn [rs] (reduce + (map get-value rs (concat (rest rs) [nil])))))", "problem": 92, "user": "4dad7adac9a9d6ed0599dc57"}, {"code": "(fn [str]\n  (let [rn {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]\n    (loop [str (seq str)\n           res 0]\n      (if (second str)\n        (recur (rest str) (+ res (if (< (rn (first str)) (rn (second str)))\n                                     (- (rn (first str)))\n                                     (rn (first str)))))\n        (+ res (rn (first str))))\n      )))", "problem": 92, "user": "4e3bccb1535deb9a81d77f55"}, {"code": "(fn better-rta [rstr]\n     (apply + (map (fn [a b]\n       (let [rmap {\\M 1000\n                \\D 500\n                \\C 100\n                \\L 50\n                \\X 10\n                \\V 5\n                \\I 1}]\n      (if (and b (< (rmap a) (rmap b)))\n        (- (rmap a))\n        (rmap a)))) \nrstr \n(concat (rest rstr) [nil]))))", "problem": 92, "user": "4dada6d4c9a9d6ed2c99dc57"}, {"code": "(fn roman-string->number\n  [string]\n  (apply + (map (fn actual-value\n                  [character next-character]\n                  (let [roman-character->number {\\I 1\n                                                 \\V 5\n                                                 \\X 10\n                                                 \\L 50\n                                                 \\C 100\n                                                 \\D 500\n                                                 \\M 1000}\n                        number (roman-character->number character)\n                        next-number (roman-character->number next-character)]\n                    (if (and next-number\n                             (> next-number number))\n                      (- number)\n                      number)))\n                string\n                (concat (rest string) [nil]))))", "problem": 92, "user": "4e4e5b91535dc968683fc4e5"}, {"code": "(fn [x] \n           (apply + (reduce (fn [x y] (if (empty? x) (vector y) (if (> (last x) y)\n                                 (conj x (- y))\n                                 (conj x y)))) [] (reverse (map #(get { \\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1 } %) x)))))", "problem": 92, "user": "4db58ccb535d87e67b28fe10"}, {"code": "(fn [n]\n  (let [f first\n        d count\n        v [[\"M\" 1000]\n           [\"CM\" 900]\n           [\"D\"  500]\n           [\"C\"  100]\n           [\"XC\"  90]\n           [\"XL\"  40]\n           [\"X\"   10]\n           [\"IX\"   9]\n           [\"V\"    5]\n           [\"IV\"   4]\n           [\"I\"    1]]]\n    (loop [r 0 c n]\n      (if (empty? c)\n        r\n        (let [[k v] (f (filter #(if (= (seq (f %)) (take (d (f %)) c)) %) v))]\n          (recur (+ r v) (drop (d k) c)))))))", "problem": 92, "user": "4e49badd535dc968683fc4c9"}, {"code": "(fn[r]\n  (let [pat (re-pattern \"^(M{0,3})(CM)?(D)?(C{0,3})(XC)?(XL)?(L)?(IX)?(X{0,3})(IV)?(V)?(I{0,3})$\")\n         matcher (re-matcher pat r)]\n     (let [m (next (re-find matcher))\n           v [1000 900 500 100 90 40 50 9 10 4 5 1]]\n       (let [tt (map (fn[he] (val (first he))) (map (fn[x] (if (zero? (count x)) {0 0} (frequencies (seq x)))) m))]\n         (reduce + (map * tt v))))))", "problem": 92, "user": "4e58bcd4535d8a8b8723a296"}, {"code": "#(\n  let [\n    k 1000\n    n \"MDCLXVI\"\n    p (fn p [t s l [b & y] v d] \n        (if (seq t)\n          (let [[a & x] t] \n            (if (= a b)\n              (p x (+ s v\n                (if (< l v)\n                  (* l -2)\n                  0)) \n                v n k 2)\n              (p t s l y (/ v d) \n                (if (= d 2) 5 2))))\n          s))]\n  (p % 0 0 n k 2))", "problem": 92, "user": "4e5c801e535d8a8b8723a2c1"}, {"code": "(fn [r]\n  (->>\n    (reverse r)\n    (map {\\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1})\n    (cons 0)\n    (partition 2 1)\n    (reduce\n      (fn [t [b a]]\n        (+ t (if (< a b) (- a) a))) 0)))", "problem": 92, "user": "4db858d1535d1e037afb218c"}, {"code": "(fn [s]\n  (let [translate {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000}\n        vals (map translate s)]\n    (apply + (map (fn [[i next-i]] (if (and next-i (> next-i i)) (* -1 i) i)) (partition-all 2 1 vals)))))", "problem": 92, "user": "4e589bdc535d8a8b8723a295"}, {"code": "(fn [c] ((fn [a] ( reduce + ((fn ch [s] (if (empty? s) nil (let [nval (first s) rs (rest s)]\n(if (empty? (filter #(< nval %) rs)) (cons nval (ch rs)) (cons (* -1 nval) (ch rs)))))) a))) ((fn [b] (map #(get (zipmap (str \"IVXLCDM\") '(1 5 10 50 100 500 1000)) %) (seq b))) c)))", "problem": 92, "user": "4e6e6630535d5021c1a89609"}, {"code": "(fn [s]\n  (let [\n    conv {\\M 1000  \\D 500, \\C 100 \\L 50 \\X 10 \\V 5 \\I 1}\n    ]\n    (reduce\n      (fn [a v] (if (<= (first v) (second v)) (+ a (second v)) (- a (second v))))\n      0\n      (partition 2 1\n        (conj (map conv (reverse (seq s))) 0))\n  )))", "problem": 92, "user": "4e6e10d8535d5021c1a895fd"}, {"code": "(fn r \n  ([x]\n    (r (seq x) 0)) \n  ([x acc] \n    (letfn [(rv [x] (get {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000} x))]\n           (if (seq x)\n             (let [a (rv (first x)) b (rv (second x)) func (if (or (nil? b) (>= a b)) + -)]\n               (r (rest x) (func acc a)))\n             acc))))", "problem": 92, "user": "4e6a5f5c535d8ccf87e9fed6"}, {"code": "#(apply + (for [[x y]\n                (partition 2 1 [0]\n                          (map {\\I 1 \\V 5 \\X 10 \\L 50\n                                \\C 100 \\D 500 \\M 1000} %))]\n            ((if (< x y) - +) x)))", "problem": 92, "user": "4e6a412e535d8ccf87e9feb6"}, {"code": "#(nth \n    (reduce \n      (fn [[r i] e] \n        [(+ r (if (> e i) (- e i i) e))\n         e])\n      [0 1000] \n      (map {\\X 10 \\I 1 \\V 5 \\L 50 \\D 500 \\C 100 \\M 1000} %))\n  0)", "problem": 92, "user": "4e5411e8535d8a8b8723a279"}, {"code": "(fn  [numeral] (-> (let [roman {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000} digit (roman (first (vec numeral)))]\n         (reduce\n\t    (fn [[acc prv] cur] (let [nacc (+ acc cur)] \n\t      [(if (< prv cur) (- nacc (* 2 prv)) nacc) cur]))\n\t    [digit digit]\n\t\t (map roman (rest (vec numeral))))) (first)))", "problem": 92, "user": "4e6e3a1e535d5021c1a89602"}, {"code": "(fn [x]\n  (loop [s (reverse x)\n         c 0\n         n 0]\n    (if (seq s)\n      (let [a ({\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000} (first s))\n            z (rest s)]\n        (recur z\n               (if (> a c) a c)\n               (if (< a c) (- n a) (+ n a))\n        )\n      )\n      n\n    )\n  )\n)", "problem": 92, "user": "4e3456f9535deb9a81d77f2a"}, {"code": "(fn read-roman-numeral\n  [s]\n  (let [symbol-values {\\I 1 \\V 5\n                       \\X 10 \\L 50\n                       \\C 100 \\D 500\n                       \\M 1000}]\n    (->> \n     (partition-by identity s)\n     (map (juxt first count))\n     (partition-all 2 1)\n     (map\n      (fn [[[symbol cardinality] [next-symbol _]]]\n        (let [value (symbol-values symbol)]\n          (* cardinality value\n             (if (and next-symbol\n                      (< value (symbol-values next-symbol)))\n               -1 1)))))\n     (apply +))))", "problem": 92, "user": "4e68c434535d8ccf87e9fe89"}, {"code": "(fn [s]\n  (apply + \n    (let [k (let\n       [m {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]\n          (map m s))]\n      (reduce\n    (fn [[n a] b]\n      (if (> b a) [n (- b a)] [(+ n a) b]))\n    [0 (first k)] (rest k)))))", "problem": 92, "user": "4db1bfe21254ad5b4805fa71"}, {"code": "(fn read-roman [s]\n  (letfn [(add-char [[sum pre] c]\n            (let [n (cond\n                     (= \\I c) 1\n                     (= \\V c) (if (= \\I pre) 3 5)\n                     (= \\X c) (if (= \\I pre) 8 10)\n                     (= \\L c) (if (= \\X pre) 30 50)\n                     (= \\C c) (if (= \\X pre) 80 100)\n                     (= \\D c) (if (= \\C pre) 300 500)\n                     (= \\M c) (if (= \\C pre) 800 1000))]\n              [(+ sum n) c]))]\n    (first (reduce add-char [0 nil] s))))", "problem": 92, "user": "4e5bff2b535d8a8b8723a2bd"}, {"code": "#(apply + \n    (if (re-find #\"I[VX]\" %) -2 0)\n    (if (re-find #\"X[LC]\" %) -20 0)\n    (if (re-find #\"C[DM]\" %) -200 0)\n   (map {\\I 1 \\V 5 \\X 10 \\L 50 \n                    \\C 100 \\D 500 \\M 1000} %))", "problem": 92, "user": "4e5fe31a535d8ccf87e9fe50"}, {"code": "(fn [source-string]\r\n  (let [character-numbers {\\I 1\r\n                           \\V 5\r\n                           \\X 10\r\n                           \\L 50\r\n                           \\C 100\r\n                           \\D 500\r\n                           \\M 1000}\r\n        suffix-characters {\\I #{\\V \\X}\r\n                           \\X #{\\L \\C}\r\n                           \\C #{\\D \\M}}]\r\n    (loop [result 0 rest-characters (vec source-string)]\r\n      (if (empty? rest-characters)\r\n          result\r\n          (let [current-character (first rest-characters)\r\n                current-number (character-numbers current-character)]\r\n            (if (and (second rest-characters)\r\n                     (suffix-characters current-character)\r\n                     ((suffix-characters current-character) (second rest-characters)))\r\n                (recur (+ result (- (character-numbers (second rest-characters))\r\n                                    current-number))\r\n                       (rest (rest rest-characters)))\r\n                (recur (+ result current-number)\r\n                       (rest rest-characters))))))))", "problem": 92, "user": "4e7c8fd1535db169f9c796be"}, {"code": "#(reduce +\n  (map {\"I\" 1   \"IV\" 4   \"V\" 5   \"IX\" 9\n        \"X\" 10  \"XL\" 40  \"L\" 50  \"XC\" 90\n        \"C\" 100 \"CD\" 400 \"D\" 500 \"CM\" 900\n        \"M\" 1000}\n       (re-seq #\"CM|M|CD|D|XC|C|XL|L|IX|X|IV|V|I\" %)))", "problem": 92, "user": "4e7dfab0535db169f9c796f9"}, {"code": "(fn [text]\n  (let [romans {\\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1}\n        len (count text)]\n    (loop [acc 0 i 0]\n      (let [k (romans (get text i))]\n        (if (= i (dec len))\n          (+ acc k)\n          (if (< k (romans (get text (inc i))))\n            (recur (- acc k) (inc i))\n            (recur (+ acc k) (inc i))))))))", "problem": 92, "user": "4e521cef535d302ef430da6d"}, {"code": "(fn [s]\n  (reduce (fn [sum [a b]]\n            ((if (< a b) - +) sum a))\n          0\n          (partition 2 1 (concat (map {\\I 1\n                                       \\V 5\n                                       \\X 10\n                                       \\L 50\n                                       \\C 100\n                                       \\D 500\n                                       \\M 1000} s)\n                                 [0]))))", "problem": 92, "user": "4dabb7b1950ed6eda1bd72f3"}, {"code": "#(let [rn {\"I\" 1 \"V\" 5 \"X\" 10 \"L\" 50 \"C\" 100 \"D\" 500 \"M\" 1000 \"XL\" 40 \"CM\" 900 \"XC\" 90 \"IX\" 9 \"IV\" 4}] \n    (reduce +\n      (map rn (re-seq #\"XL|CM|XC|IX|IV|[MCDLXVI]\" %))))", "problem": 92, "user": "4e720985535d5021c1a89655"}, {"code": "(fn parse-roman [n]\n  (let [\n  value-of { \\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000 }\n  to-stack (fn [acc block]\n    (let [letter (first block)\n          magnitude (value-of letter)\n          quantity (count block)\n          [prev-magnitude prev-quantity] (first acc)\n          sign (if (< magnitude prev-magnitude) -1 1)]\n      (cons [magnitude (* quantity sign)] acc)))\n  sum (fn [stack]\n    (reduce #(+ %1 (apply * %2)) 0 stack))\n  ]\n  (->> n\n       (partition-by identity)\n       (reverse)\n       (reduce to-stack (list [0 0]))\n       (sum))))", "problem": 92, "user": "4e691c79535d8ccf87e9fe97"}, {"code": "(fn [r]\n  (letfn [(bs [c] \n                  (condp =  c\n                    \\I 1\n                    \\V 5\n                    \\X 10\n                    \\L 50\n                    \\C 100\n                    \\D 500\n                    \\M 1000\n                  ))\n          (sg [s]\n            (let [vs (map bs s)\n  \t  ml (reverse (reductions max\n                                (reverse vs)))]\n            (map #(if (< % %2) -1 1) vs ml)))\n          ]\n\n       (reduce + (map * (map bs r) (sg r)))))", "problem": 92, "user": "4e50e2a0535dc968683fc4ef"}, {"code": "#((fn c [[n & s]]\n    (if n\n      ((if (and s (< n (first s))) - +)\n       (c s) n)\n      0))\n  (map {\\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1} %))", "problem": 92, "user": "4e8612f8535db62dc21a62f2"}, {"code": "(fn roman-to-number [x]\n  (letfn [(letter-to-number [x]\n  (condp = x\n    \\I 1\n    \\V 5\n    \\X 10\n    \\L 50\n    \\C 100\n    \\D 500\n    \\M 1000))]\n  \n  \n  (loop [n 0, last 0, rest (into '()  x)]\n    (println n last rest)\n    (if (empty? rest)\n      n\n      (let [c (letter-to-number (first rest)), rest (next rest)]\n        (if (< c last)\n          (recur (- n c) last rest)\n          (recur (+ n c) c rest)))))))", "problem": 92, "user": "4e7db3b4535db169f9c796e1"}, {"code": "#(let [syms [[1000 \"M\"] [900 \"CM\"] [500 \"D\"] [400 \"CD\"] [100 \"C\"]\n              [90 \"XC\"]  [50 \"L\"]  [40 \"XL\"]  [10 \"X\"]\n              [9 \"IX\"]   [5 \"V\"]   [4 \"IV\"]   [1 \"I\"]]]\n    (loop [n 0 rs (seq %) syms syms]\n      (if (nil? rs)\n        n\n        (let [[d r] (first syms)\n              c (str (first rs)) cc (str (first rs) (second rs))]\n          (cond\n           (= c r) (recur (+ n d) (next rs) syms)\n           (= cc r) (recur (+ n d) (nnext rs) syms)\n           :t (recur n rs (next syms)))))))", "problem": 92, "user": "4e8510e7535db62dc21a62e7"}, {"code": "(fn rrn [s]\n  (let [ rns (zipmap \"MDCLXVI\" [1000 500 100 50 10 5 1]) ]\n    (loop [ s (reverse s) total 0 max 0 ]\n      (if (nil? s)\n          total\n          (let [ n (rns (first s)) ]\n            (if (< n max)\n                (recur (next s) (- total n) max)\n                (recur (next s) (+ total n) n)))))))", "problem": 92, "user": "4e860e85535db62dc21a62f1"}, {"code": "(fn read-roman [r]\n   (let [numerals (array-map \"M\" 1000 \"CM\" 900 \"D\" 500 \"CD\" 400 \"C\" 100 \"XC\" 90 \"L\" 50\n                             \"XL\" 40 \"X\" 10 \"IX\" 9 \"V\" 5 \"IV\" 4 \"I\" 1)\n         pairs (map #(apply str %) (concat (partition 2 1 r) (list (str (last r)))))]\n     ((fn [n roms]\n        (cond\n         (empty? roms) n\n         (numerals (first roms)) (recur (+ n (numerals (first roms))) (rest (rest roms)))\n         true (recur (+ n (numerals (str (first (first roms))))) (rest roms))))\n      0 pairs)))", "problem": 92, "user": "4e89f46c535d3e98b8023288"}, {"code": "(fn [s]\r\n  ((fn f [i s]\r\n      (cond (empty? s) i\r\n            (.startsWith s \"M\") (recur (+ i 1000) (.substring s 1))\r\n            (.startsWith s \"CM\") (recur (+ i 900) (.substring s 2))\r\n            (.startsWith s \"D\") (recur (+ i 500) (.substring s 1))\r\n            (.startsWith s \"C\") (recur (+ i 100) (.substring s 1))\r\n            (.startsWith s \"XC\") (recur (+ i 90) (.substring s 2))\r\n            (.startsWith s \"L\") (recur (+ i 50) (.substring s 1))\r\n            (.startsWith s \"XL\") (recur (+ i 40) (.substring s 2))\r\n            (.startsWith s \"X\") (recur (+ i 10) (.substring s 1))\r\n            (.startsWith s \"IX\") (recur (+ i 9) (.substring s 2))\r\n            (.startsWith s \"V\") (recur (+ i 5) (.substring s 1))\r\n            (.startsWith s \"IV\") (recur (+ i 4) (.substring s 2))\r\n            (.startsWith s \"I\") (recur (+ i 1) (.substring s 1))\r\n          ))\r\n    0 s))", "problem": 92, "user": "4e8681b7535dae1a5effa438"}, {"code": "#(let [nums (map {\\I 1 \r\n                 \\V 5\r\n                 \\X 10\r\n                 \\L 50\r\n                 \\C 100\r\n                 \\D 500\r\n                 \\M 1000} %)]\r\n    (apply + (map (fn [[c n]] (if (< c n) (- c) c)) (partition 2 1 (concat nums (list (last nums)))))))", "problem": 92, "user": "4db92654535d1e037afb21a0"}, {"code": "{\"XIV\" 14\r\n\"DCCCXXVII\" 827\r\n\"MMMCMXCIX\" 3999\r\n\"XLVIII\" 48}", "problem": 92, "user": "4dfe65a1535d04ed9115e787"}, {"code": "(fn [st]\n         (let [rom-num {\\I 1,\\V 5, \\X 10, \\L 50,\n                        \\C 100, \\D 500, \\M 1000}\n               rom-add\n               (fn [yy xx]\n                 (let [peak (yy :peak)\n                       val (yy :value)]\n                   (cond  (nil? peak)\n                          {:peak xx, :value (rom-num xx)}\n                          (>= (rom-num peak) (rom-num xx))\n                          {:peak xx, :value (+ val (rom-num xx))} \n                          (< (rom-num peak) (rom-num xx))\n                          {:peak xx, :value (- (+ val (rom-num xx)) (* 2 (rom-num peak)))}\n                          )))]\n           ((reduce #(rom-add %1 %2) {:peak nil :value 0} (seq st)) :value)))", "problem": 92, "user": "4dcc5aff535d5973398f9293"}, {"code": "#(let [digits {nil 0 \\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}\n       s      (partition-by identity %)\n       tr     (fn [[digit :as s] [next]]\n                (let [v (digits digit)]\n                  (* (count s) v (if (< v (digits next)) -1 1))))]\n   (apply + (tr (last s) [nil]) \n          (map tr s (rest s))))", "problem": 92, "user": "4e9660ec535dbda64a6f6b44"}, {"code": "(fn [rom]\n  (let [rvals {\"M\" 1000 \"CM\" 900 \"D\" 500 \"CD\" 400 \"C\" 100 \"XC\" 90 \"L\" 50 \"XL\" 40 \"X\" 10 \"IX\" 9 \"V\" 5 \"IV\" 4 \"I\" 1}\n         order [\"M\" \"CM\" \"D\" \"CD\" \"C\" \"XC\" \"L\" \"XL\" \"X\" \"IX\" \"V\" \"IV\" \"I\"]]\n    (apply \n      (fn romval [rom order val]\n        (if (nil? rom)\n          val\n          (if (.startsWith (apply str rom) (first order))\n            (romval (if (= 2 (count (first order))) (nnext rom) (next rom))\n                    order\n                    (+ val (rvals (first order))))\n            (romval rom\n                    (next order)\n                    val))))\n      [rom order 0])))", "problem": 92, "user": "4e98a6d0535dbda64a6f6b5e"}, {"code": "#((reduce (fn [[x y] z]\n\t\t\t[((if (< z y) - +) x z) z])           \n [0 0] (reverse (map {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000} %))) 0)", "problem": 92, "user": "4e823ed7535db62dc21a62c7"}, {"code": "(fn [x s]\n   (if (empty? s)\n     x\n     (let [m [[\"M\" 1000] [\"CM\" 900] [\"D\" 500] [\"CD\" 400]\n              [\"C\"  100] [\"XC\"  90] [\"L\"  50] [\"XL\"  40]\n              [\"X\"   10] [\"IX\"   9] [\"V\"   5] [\"IV\"   4]\n              [\"I\"    1]]\n           [l v] (some (fn [[l v]] (and (.startsWith s l) [l v])) m)]\n       (recur (+ x v) (apply str (drop (count l) s))))))\n0", "problem": 92, "user": "4ea1b9e4535d7eef308072b8"}, {"code": "(fn [roman]\n  (let [subs {\"IV\" \"IIII\", \"IX\" \"VIIII\", \"XL\" \"XXXX\", \n              \"XC\" \"LXXXX\", \"CD\" \"CCCC\", \"CM\" \"DCCCC\"}\n        values {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \n                \\D 500, \\M 1000}]\n     (apply + (map (fn [[c n]] (* n (values c)))\n          (frequencies (reduce \n            (fn [s [b a]](.replace s b a)) \n                           roman subs))))))", "problem": 92, "user": "4dcfbc44535d5973398f92a7"}, {"code": "(fn [s]\n  (let [m {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000}\n       s (reverse s)]\n    (loop [s s last-value 1 acc 0]\n      (if (empty? s)\n        acc\n        (let [this-value (m (first s))]\n          (recur (rest s)\n                 this-value\n                 ((if (>= this-value last-value) + -) acc this-value)))\n))))", "problem": 92, "user": "4e9dafe1535dbda64a6f6b89"}, {"code": "(fn roman\r\n  [string]\r\n\t(let [num-table {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000}\r\n\t\t\t\tfirst-sym (first string)\r\n\t\t\t\tthe-rest\t(rest string)]\r\n\t\t(if (empty? string) \r\n\t\t\t0\r\n\t\t\t(let [adjustment\r\n\t\t\t\t\t\t (if the-rest\r\n\t\t\t\t\t\t \t (cond (and (= first-sym \\I) \r\n\t\t\t\t\t\t\t \t\t\t\t\t\t(or (= (first the-rest) \\V) (= (first the-rest) \\X)))\r\n\t\t\t\t\t\t\t\t\t\t \t -2\r\n\t\t\t\t\t\t\t\t\t\t (and (= first-sym \\X)\r\n\t\t\t\t\t\t\t\t\t\t \t\t\t(or (= (first the-rest) \\L) (= (first the-rest) \\C)))\r\n\t\t\t\t\t\t\t\t\t\t\t -20\r\n\t\t\t\t\t\t\t\t\t\t (and (= first-sym \\C)\r\n\t\t\t\t\t\t\t\t\t\t \t\t\t(or (= (first the-rest) \\D) (= (first the-rest) \\M)))\r\n\t\t\t\t\t\t\t\t\t\t\t -200\r\n\t\t\t\t\t\t\t\t\t\t :else 0)\r\n\t\t\t\t\t\t\t 0)]\r\n\t\t\t\t(+ (num-table first-sym) (roman the-rest) adjustment)))))", "problem": 92, "user": "4e8a0c82535d3e98b802328d"}, {"code": "(fn [z]\n  (reduce + \n    (map #(* (first %) (if (< (first %) (second %)) -1 1)) \n      (partition 2 1 \n        (map #({\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000 \\Z 0} %) (vec (str z \\Z)))))))", "problem": 92, "user": "4e8f4f64535d65386fec2149"}, {"code": "(fn [s]\r\n  (let [r {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000}\r\n        rev (fn [regex k] (* k (count (re-seq regex s))))]  \r\n    (- (reduce + (map r s))\r\n      (rev #\"I[VX]\" 2)\r\n      (rev #\"X[LC]\" 20)\r\n      (rev #\"C[DM]\" 200))))", "problem": 92, "user": "4e994541535dbda64a6f6b64"}, {"code": "(fn f92 [s]\n  \"(= (__ \\\"DCCCXXVII\\\") 827)\n   (= (__ \\\"MMMCMXCIX\\\") 3999)\n   IV IX XL XC CD CM\"\n  (let [m {\"I\" 1 \"V\" 5 \"X\" 10 \"L\" 50 \"C\" 100 \"D\" 500 \"M\" 1000}\n        tokens (vec (rest (.split s \"\")))\n        lidx (dec (count tokens))]\n    (prn tokens)\n    (loop [idx 1\n           prev (get tokens 0)\n           result 0]\n      (prn idx prev result)\n      (if (> idx lidx)\n        (if (nil? prev)\n          result\n          (+ result (get m prev)))\n        (let [curr (get tokens idx)\n              fresh? (nil? prev)\n              increasing? (and (not fresh?) (< (get m prev) (get m curr)))]\n          (cond\n           fresh?\n           (recur (inc idx) curr result)\n           increasing?\n           (recur (inc idx) nil (+ result (- (get m curr) (get m prev))))\n           :else\n            (recur (inc idx) curr (+ result (get m prev)))))))))", "problem": 92, "user": "4e88feef535d8b9bb0147ca8"}, {"code": "(fn read-roman-numeral [nums]\n  (let [values {\\I 1\n                \\V 5\n                \\X 10\n                \\L 50\n                \\C 100\n                \\D 500\n                \\M 1000}]\n    (loop [nums nums\n           prev -1\n           part-result 0\n           result 0]\n      (if (empty? nums)\n        (+ result part-result)\n        (let [curr (values (first nums))\n              rest-nums (rest nums)]\n          (cond (= prev -1)\n                (recur rest-nums\n                       curr\n                       curr\n                       result)\n                (= prev curr)\n                (recur rest-nums\n                       curr\n                       (+ part-result curr)\n                       result)\n                (< prev curr)\n                (recur rest-nums\n                       -1\n                       0\n                       (+ result\n                          (- curr part-result)))\n                (> prev curr)\n                (recur rest-nums\n                       curr\n                       curr\n                       (+ result part-result))))))))", "problem": 92, "user": "4e4b4564535dc968683fc4d3"}, {"code": "(fn rom-num [x]\n  (let [m (zipmap \"IVXLCDM\" [1 5 10 50 100 500 1000])] \n    (letfn [(f [xs acc]\n              (if (empty? xs)\n                acc\n                (if (<= (m (first xs)) (if (nil? (peek acc)) 10000 (peek acc)))\n                  (recur (rest xs) (conj acc (m (first xs))))\n                  (recur (rest xs) (conj (pop acc) (- (m (first xs)) (peek acc)))))))]\n  (reduce + (f x []))))\n)", "problem": 92, "user": "4dd1de4d535dae65d5c462d7"}, {"code": "(fn rr [rn]\n  (let [ls {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]\n    (loop [rv 0 [l1 l2 & _ :as tmp] (seq rn)]\n      (cond\n        (nil? l1)\n          rv\n        (nil? l2) \n          (recur (+ rv (ls l1)) (rest tmp))\n        (< (ls l1) (ls l2))\n          (recur (- (+ rv (ls l2)) (ls l1)) (rest (rest tmp)))\n        :else\n          (recur (+ rv (ls l1)) (rest tmp))))))", "problem": 92, "user": "4e6a2f51535d8ccf87e9fea9"}, {"code": "(fn [s]\n  (let [trans {\\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1}\n        sseq (map trans (seq s))]\n    (reduce + (map #(if (< % %2) (- %) %) sseq (conj (vec (rest sseq)) 0)))))", "problem": 92, "user": "4e68b46c535d8ccf87e9fe87"}, {"code": "(fn rm[s]\r\n  (let [m {\"I\" 1 \"V\" 5 \"X\" 10 \"L\" 50 \"C\" 100 \"D\" 500 \"M\" 1000} v (map #( get m (str %) )(reverse (into [] s)))]\r\n    (loop [acc (first v) [p n &r :as l] v]\r\n      (if (nil? n)\r\n        acc\r\n        (recur (if (< n p) (- acc n) (+ acc n)) (next l))))))", "problem": 92, "user": "4e9def6b535dbda64a6f6b8f"}, {"code": "#(let [v {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]\r\n (reduce +\r\n  (map (fn [[x y]]\r\n        (let [a (v x) b (v y)] (* a (if (< a b) -1 1))))\r\n   (partition 2 1 (str % \"I\")))))", "problem": 92, "user": "4eb97b2e535dfed6da9c6d54"}, {"code": "(let [R {\\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1}]\n  (fn [r]\n    (loop [l (map R r) n 0]\n      (if (seq l)\n        (let [z (first l) y (second l)]\n          (if (and y (< z y))\n            (recur (nnext l) (+ n (- y z)))\n            (recur (next l) (+ n z))))\n        \n      n))))", "problem": 92, "user": "4e82f85d535db62dc21a62ce"}, {"code": "#(reduce (fn [a b] (- (+ a b) (* 2 (mod a b)))) (map (fn [R] (get {\"M\" 1000 \"D\" 500 \"C\" 100 \"L\" 50 \"X\" 10 \"V\" 5 \"I\" 1} R)) (re-seq #\".\" %)))", "problem": 92, "user": "4db85bdd535d1e037afb218d"}, {"code": "(fn [x] (let [rnlu (hash-map \"I\" 1 \"V\" 5 \"X\" 10 \"L\" 50 \n  \"C\" 100 \"D\" 500 \"M\" 1000)] \n  (loop [total 0 nums (map #(rnlu %) (re-seq #\"\\w\" x))] \n  (if (= 1 (count nums)) (+ total (first nums))\n      (if (zero? (count nums)) total \n  (if (>= (first nums) (second nums)) \n    (recur (+ total (first nums)) (rest nums))\n    (recur (+ total (- (second nums) (first nums)))\n      (rest (rest nums)))))))))", "problem": 92, "user": "4ea9b80c535d7eef30807306"}, {"code": "(fn [s]\n  (let [r-to-d {\"I\" 1 \"V\" 5 \"X\" 10 \"L\" 50 \"C\" 100 \"D\" 500 \"M\" 1000}\n\t      i-rv (map #(r-to-d %) (re-seq #\"\\S\" s))\n\t      f (fn [l acc]\n\t\t        (let [[a b] l]\n\t\t\t       (cond (nil? b) (+ acc a)\n\t\t\t             :else (do \n\t\t\t\t                  (if (<= b a)\n\t\t\t\t\t                  (recur (rest l) (+ acc a))\n\t\t\t\t\t                  (recur (rest l) (+ acc (- a))))))))]\n    (f i-rv 0)))", "problem": 92, "user": "4db045b5838c48654951d9be"}, {"code": "(fn [R]\r\n    (reduce #(- (+ % %2) (* 2 (mod % %2)))\r\n    (map {\\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1} \r\n    R)))", "problem": 92, "user": "4e9a8c0e535dbda64a6f6b72"}, {"code": "(fn [x]\n(loop [val x cp 10000 all 0]\n  (if (= 0 (count val))\n    all\n    (let [cv (subs val 0 1)\n    cvv\n\t  (cond\n\t   (= \"I\" cv)\n\t   1\n\t   (= \"V\" cv)\n\t   5\n\t   (= \"X\" cv)\n\t   10\n\t   (= \"L\" cv)\n\t   50\n\t   (= \"C\" cv)\n\t   100\n\t   (= \"D\" cv)\n\t   500\n\t   (= \"M\" cv)       \n\t   1000\n       )]\n       (cond\n\t(= cp cvv)\n\t (recur (subs val 1) cvv (+ all cvv)) \n\t(< cp cvv)\n\t (recur (subs val 1) cvv (+ all cvv (* -2 cp)))\n\t(> cp cvv)\n\t (recur (subs val 1) cvv (+ all cvv))\n\t ))))\n)", "problem": 92, "user": "4eb0afed535d7eef3080733e"}, {"code": "(fn [n]\n    (let [r { \\M 1000\n              \\D 500\n              \\C 100\n              \\L 50\n              \\X 10\n              \\V 5\n              \\I 1}]\n      \n      (reduce\n       (fn [s [a b]] ((if (< a b) - +) s a))\n       0\n       (partition 2 1 [0] (map r n)))))", "problem": 92, "user": "4e6dc95a535d5021c1a895f1"}, {"code": "(fn [s] (let [zm (zipmap \"MDCLXVI\" [1000 500 100 50 10 5 1])\n                 sq (map #(zm %) (seq s))]\n              (loop [x sq r []] (if (nil? (fnext x)) (reduce + (conj r (first x))) \n                                  (recur (rest x) (conj r (if (< (first x) (fnext x)) (* -1 (first x)) (first x))))))))", "problem": 92, "user": "4eb44d78535d7eef30807360"}, {"code": "(fn p92 [col]\n   (let [ str-symbol-map { \"M\" :m ,\"D\" :d, \"C\" :c , \"L\" :l ,\"X\" :x \"V\" :v \"I\" :i}\n          symbo-v-map    {  :m 1000 , :d, 500  :c  100, :l 50 , :x 10  :v  5  :i 1}\n          to-symbol (fn [c] (get str-symbol-map  (str c)))\n          parse-roma (fn [col]\n                         (let [symbol-list (reverse col)]\n                         (loop [result (symbo-v-map (first symbol-list))  lastv (symbo-v-map (first symbol-list)) data (rest symbol-list)]\n                           (let [current-v (symbo-v-map (first data))]\n                           (if (empty? data)\n                            result\n                            (recur (if (< current-v  lastv) (- result current-v ) (+ result current-v ))\n                               current-v\n                              (rest data)\n                              )\n                            )\n                        ))))\n          ]\n\n       ( parse-roma (map to-symbol col))\n     )\n\n   )", "problem": 92, "user": "4ec5bec6535d6d7199dd36b3"}, {"code": "(fn [rn]\n  (let [nummap {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}\n        rn (seq (.toUpperCase rn))\n        nums (map nummap rn)]\n    (loop [nums nums acc 0]\n      (if (empty? nums)\n        acc\n        (let [x (first nums)\n              y (fnext nums)]\n          (if (or (nil? y)\n                  (>= x y))\n            (recur (next nums) (+ acc x))\n            (recur (nnext nums) (+ acc (- y x)))))))))", "problem": 92, "user": "4ed188c8535d44c135fd68cf"}, {"code": "(fn s [rn]\n  (let [n {\"M\" 1000 \"CM\" 900 \"D\" 500 \"CD\" 400 \"C\" 100 \"XC\" 90 \"L\" 50 \"XL\" 40 \"X\" 10 \"IX\" 9 \"V\" 5 \"IV\" 4 \"I\" 1}]\n    (loop [p rn \n           a 0]\n      (if (= p \"\")\n        a\n        (let [cn (first (re-find #\"(M|CM|D|CD|C|XC|L|XL|X|IX|V|IV|I)\" p))]\n          (recur (subs p (count cn)) (+ a (n cn)) )\n        )  \n      )\n    )\n  )\n)", "problem": 92, "user": "4e9de526535dbda64a6f6b8e"}, {"code": "(fn [s]\n  (let [guide [[\"M\" 1000]\n          [\"CM\" 900]\n          [\"D\" 500]\n          [\"CD\" 400]\n          [\"C\" 100]\n          [\"XC\" 90]\n          [\"L\" 50]\n          [\"XL\" 40]\n          [\"X\" 10]\n          [\"IX\" 9]\n          [\"V\" 5]\n          [\"IV\" 4]\n          [\"I\" 1]]]\n   (loop [s s g guide acc 0]\n     (if (seq s)\n          (let [[k v] (first g) len (.length k)]\n            (if (= (subs s 0 len) k) (recur (subs s len) g (+ acc v))\n                                     (recur s (rest g) acc))) \n          acc))))", "problem": 92, "user": "4eb0a757535d7eef3080733d"}, {"code": "(fn roman [num]\n  (let [digits (map {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000} num)\n        pairs  (map vector digits (concat (drop 1 digits) [0]))]\n    (reduce (fn [accum [x xnext]] \n              (if (>= x xnext)\n                (+ accum x) \n                (- accum x)))\n            0\n            pairs)))", "problem": 92, "user": "4eb9ce75535dfed6da9c6d5e"}, {"code": "#(loop [s 0 c (map { \\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000} %)]\n  (let [[a b & xs] c]\n\t\t(cond \n\t\t\t(nil? a) s\n\t\t\t(and b (< a b)) (recur (+ s (- b a)) xs)\n\t\t\t:else (recur (+ s a) (rest c)))))", "problem": 92, "user": "4ec16c21535dfed6da9c6dac"}, {"code": "#(loop [last nil rem (apply list (seq %)) acc 0]\n  (let [cur (first rem)]\n    (cond (nil? cur) acc\n          (and (= cur \\M) (= last \\C))\n            (recur cur (pop rem) (+ acc 800))\n          (= cur \\M) (recur cur (pop rem) (+ acc 1000))\n          (and (= cur \\D) (= last \\C))\n            (recur cur (pop rem) (+ acc 300))\n          (= cur \\D) (recur cur (pop rem) (+ acc 500))\n          (and (= cur \\C) (= last \\X))\n            (recur cur (pop rem) (+ acc 80))\n          (= cur \\C) (recur cur (pop rem) (+ acc 100))\n          (and (= cur \\L) (= last \\X))\n            (recur cur (pop rem) (+ acc 30))\n          (= cur \\L) (recur cur (pop rem) (+ acc 50))\n          (and (= cur \\X) (= last \\I))\n            (recur cur (pop rem) (+ acc 8))\n          (= cur \\X) (recur cur (pop rem) (+ acc 10))\n          (and (= cur \\V) (= last \\I))\n            (recur cur (pop rem) (+ acc 3))\n          (= cur \\V) (recur cur (pop rem) (+ acc 5))\n          :else (recur cur (pop rem) (+ acc 1)))))", "problem": 92, "user": "4ed94d69535d10e5ff6f5303"}, {"code": "#(loop [s % o 0]\r\n    (let [v {\\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1 nil 0} a (v (first s)) b (v (fnext s))]\r\n       (cond\r\n\t       (empty? s) o\r\n\t       (< a b) (recur (nnext s) (+ o (- b a)))\r\n\t       :else (recur (next s) (+ o a)))))", "problem": 92, "user": "4e8a460e535d65386fec2109"}, {"code": "#(apply + \n    (if (re-find #\"I[VX]\" %) -2 0)\n    (if (re-find #\"X[LC]\" %) -20 0)\n    (if (re-find #\"C[DM]\" %) -200 0)\n   (map {\\I 1 \\V 5 \\X 10 \\L 50 \n                    \\C 100 \\D 500 \\M 1000} %))", "problem": 92, "user": "4ede8789535d10e5ff6f5337"}, {"code": "(fn [s]\n  (let [values {\\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1}\n        letter-values (map values s)]\n    (first (reduce (fn [[val former] new-val]\n                     (if (< former new-val)\n                       [(+ (- val former) (- new-val former)) new-val]\n                       [(+ val new-val) new-val]))\n                   [(first letter-values) (first letter-values)]\n                   (rest letter-values)))))", "problem": 92, "user": "4e89ff3d535d3e98b802328a"}, {"code": "#(->> %\n   (map {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000})\n   (reduce (fn [[prev sum] n]\n             (if (> n prev)\n               [n (+ sum n (- (* 2 prev)))]\n               [n (+ sum n)]))\n           [0 0])\n   last)", "problem": 92, "user": "4eb51942535d7eef30807365"}, {"code": "(fn [roman]\n  (let [value {\\M 1000, \\D 500, \\C 100, \\L 50, \\X 10, \\V 5, \\I 1}]\n    (loop [[x & xs :as ys] (seq roman) n 0]\n      (cond (empty? ys) n\n            (and (not (empty? xs)) \n                 (> (value (first xs)) (value x)))\n            (recur (rest xs) (+ n (- (value (first xs)) (value x))))\n            :else (recur xs (+ n (value x)))))))", "problem": 92, "user": "4ee3b586535d10e5ff6f5371"}, {"code": "(fn [s] (first (reduce #(%2 (first %1) (last %1))\n  (conj (map #(fn [n s] (if (or (= 0 (count s)) (not (.startsWith s (last %))))\n                      [n s]\n                      (recur (+ n (first %)) (subs s (count (last %))))))\n            [[1000 \"M\"] [900 \"CM\"] [500 \"D\"] [400 \"CD\"]\n             [100 \"C\"] [90 \"XC\"] [50 \"L\"] [40 \"XL\"]\n             [10 \"X\"] [9 \"IX\"] [5 \"V\"] [4 \"IV\"]\n             [1 \"I\"]])\n    [0 s]))))", "problem": 92, "user": "4ee82a02535d93acb0a66879"}, {"code": "(fn [s]\n  (let [roman {\"M\" 1000 \"CM\" 900 \"D\" 500 \"CD\" 400\n    \"C\" 100 \"XC\" 90 \"L\" 50 \"XL\" 40 \"X\" 10 \"IX\" 9\n    \"V\" 5 \"IV\" 4 \"I\" 1}]\n    (reduce + (map roman\n      (re-seq #\"CM|CD|XC|XL|IX|IV|[MDCLXVI]\" s)))))", "problem": 92, "user": "4ebc08a8535dfed6da9c6d7c"}, {"code": "#(let [s (map {\\I 1\n           \\V 5\n           \\X 10\n           \\L 50\n           \\C 100\n           \\D 500\n           \\M 1000} %)]\n    (->> s\n      (map list (concat (rest s) [0]))\n      (reduce (fn [a ls] \n        ((if (apply > ls) - +) a (second ls))) 0)))", "problem": 92, "user": "4ee7ef87535d93acb0a66872"}, {"code": "#(apply +\n   (map (fn [[v p]] (* (count (re-seq p %)) v))\n      {1000 #\"(?<!C)M\"\n       900 #\"CM\"\n       500 #\"(?<!C)D\"\n       400 #\"CD\"\n       100 #\"(?<!X)C(?!D|M)\"\n       90 #\"XC\"\n       50 #\"(?<!X)L\"\n       40 #\"XL\"\n       10 #\"(?<!I)X(?!L|C)\"\n       9 #\"IX\"\n       5 #\"(?<!I)V\"\n       4 #\"IV\"\n       1 #\"I(?!V|X)\"}))", "problem": 92, "user": "4ee82539535d93acb0a66878"}, {"code": "(fn read-roman [s]\n  (letfn [(subtractive [[ h & t :as s]]\n            (cond\n             (empty? s) 0\n             (some #(< h %) t) (- (subtractive t) h)\n             :else (+ (subtractive t) h)))]\n    (let [\n          roman->dig\n          {:I 1 :V 5 :X 10 :L 50 :C 100 :D 500 :M 1000}]\n      (subtractive  (map roman->dig  (map (comp keyword str) s)))\n      ))\n)", "problem": 92, "user": "4e6f578c535d5021c1a8961b"}, {"code": "(fn f[[a b & c]]\n  (let [\n      W { \"I\" 1 \"IV\" 4 \"V\" 5 \"IX\" 9 \"X\" 10 \"XL\" 40 \"L\" 50 \"XC\" 90 \"C\" 100 \"D\" 500 \"CM\" 900 \"M\" 1000 }\n      d (W (str a b))]\n    (if (nil? a) \n      0\n      (if d\n        (+ d (f c))\n        (+ (W (str a)) (f (apply str (cons b c))))))))", "problem": 92, "user": "4ec0c7ba535dfed6da9c6da4"}, {"code": "(fn [n] (let [p (into [] (partition-by identity n))\n                      d (atom #{})\n                      r {nil 0, \"IV\" 4, \"IX\" 9, \"XL\" 40, \"XC\" 90, \"CD\" 400, \"CM\" 900, \\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000} ]\n                      \n          (reduce #(+ % (r %2)) 0 \n                  (flatten (map-indexed \n                             (fn [i v] (cond (> (count v) 1) v\n                               (not (contains? @d i) )\n                                  (let [s (str (first v) (first (get p (inc i))))] \n                                       (if (r s)\n                                           (do (swap! d conj (inc i)) s)\n                                           v) )))\n                             p )) ) ))", "problem": 92, "user": "4ee7d177535d93acb0a6686f"}, {"code": "#(reduce \n   (fn [m [x y]] ((if y (if (< x y) - +) +) m x))\n   0 \n   (partition-all 2 1 (map {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000} %)))", "problem": 92, "user": "4ef49c2c535dced4c769f238"}, {"code": "(let [num-to-int {\\M 1000\n                  \\D 500\n                  \\C 100\n                  \\L 50\n                  \\X 10\n                  \\V 5\n                  \\I 1}]\n  (fn [numeral]\n    (let [length (.length numeral)]\n      (loop [index (dec length)\n             value 0]\n        (if (< index 0) value\n          (let [here (num-to-int (.charAt numeral index))\n                prev (inc index)]\n            (recur (dec index)\n                   (if (and (< prev length)\n                            (> (num-to-int (.charAt numeral prev)) here))\n                     (- value here)\n                     (+ value here)))))))))", "problem": 92, "user": "4e593dac535d8a8b8723a29c"}, {"code": "(fn read-roman-number [rn]\n  (letfn [(simple-romans [s]\n                         (let [basic-vals {\\I 1  \\V 5  \\X 10  \\L 50  \\C 100  \\D 500  \\M 1000}]\n                           (apply + (map basic-vals s))))]\n    (loop [roman-number rn\n           subtr-vals   {\"IV\" 4  \"IX\" 9  \"XL\" 40  \"XC\" 90  \"CD\" 400  \"CM\" 900}\n           result       0]\n      (cond\n        (empty? roman-number)\n          result\n        (empty? subtr-vals)\n          (+ result (simple-romans roman-number))\n        :else\n          (let [[s v] (first subtr-vals)]\n            (if (> (.indexOf roman-number s) -1)\n              (recur (.replaceAll roman-number s \"\") (rest subtr-vals) (+ result v))\n              (recur roman-number                    (rest subtr-vals)    result)))))))", "problem": 92, "user": "4e7263a1535d5021c1a8965f"}, {"code": "(fn [r]\n    (let [roman {\\I 1\n                 \\V 5\n                 \\X 10\n                 \\L 50\n                 \\C 100\n                 \\D 500\n                 \\M 1000}]\n      (loop [string r\n             n 0]\n        (let [c (first string)\n              [same other] (split-with #{c} string)\n              val (roman c)\n              worth (* val (count same))\n              next-val (roman (first other))]\n          (if-not (seq other)\n            (+ n worth)\n            (recur\n             other\n             (if (> next-val val)\n               (- n worth)\n               (+ n worth))))))))", "problem": 92, "user": "4e6a0667535d8ccf87e9fe9e"}, {"code": "(fn [n] (let [m (zipmap \"IVXLCDM\" [1 5 10 50 100 500 1000])\n               x (map m n)\n               z (reduce #(let [a (first %)\n                          b (second %)\n                          c (last %)] \n                   (if (< %2 c) [(+ a b) %2 %2] \n                   (if (= %2 c) [a (+ b %2) %2] [(+ a (- %2 b)) 0 %2]))) [0 (first x) (first x)] (rest x))] (+ (first z) (second z))))", "problem": 92, "user": "4eb13d60535d7eef3080733f"}, {"code": "(fn [s]\n  (let [char-to-num {\\I 1\n                     \\V 5\n                     \\X 10\n                     \\L 50\n                     \\C 100\n                     \\D 500\n                     \\M 1000}]\n    (if (= (count s) 1)\n      (char-to-num (nth s 0))\n      (let\n        [nums (map char-to-num s)\n         pairs (partition 2 1 [:end] nums)\n         reduce-pair (fn\n                       [[num next]]\n                       (if (or (= next :end) (>= num next))\n                         num (- num)))]\n        (apply + (map reduce-pair pairs))))))", "problem": 92, "user": "4edecdae535d10e5ff6f533c"}, {"code": "#(let [nums (map {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100 \\D 500, \\M 1000} %)]\n  (reduce + (map (fn [[a b]] (if (< a b) (- a) a))\n                 (partition 2 1 (repeat 0) nums))))", "problem": 92, "user": "4ec5aa1f535d6d7199dd36b0"}, {"code": "#(let [r {\\C 100 \\D 500 \\I 1 \\L 50 \\M 1000 \\V 5 \\X 10}]\r\n  (loop [x 0\r\n         s %]\r\n   (if-let [v (r (first s))]\r\n     (recur (+ x (* v (if (< v (r (second s) 0)) -1 1))) (rest s))\r\n     x)))", "problem": 92, "user": "4f043ed1535dcb61093f6bb4"}, {"code": "(fn [r]\n  (let [dec\n        (reverse\n         (map {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000} r))]\n    (loop [sum (first dec) pr (first dec) sq (rest dec)]\n      (if (empty? sq)\n        sum\n        (let [c (first sq)]\n          (recur (+ sum (if (< c pr) (- c) c)) c (rest sq)))))))", "problem": 92, "user": "4eb5750a535d7eef30807366"}, {"code": "(fn [s]\n    (let [dict {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}\n          nums (map dict s)]\n      (loop [coll (rest nums) prev (first nums) sum 0]\n        (if (empty? coll)\n          (+ sum prev)\n          (let [curr (first coll)]\n            (if (< prev curr)\n              (recur (rest coll) curr (- sum prev))\n              (recur (rest coll) curr (+ sum prev))))))))", "problem": 92, "user": "4dc29a1d535d020aff1edf96"}, {"code": "(fn read-roman [s]\n        (let* [r {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}\n               p (partition-by + (replace r (concat s [0])))\n               m (partition 2 1 (map #(apply + %) p))]\n              (apply + (map (fn [[a b]] (if (< a b) (- a) a)) m))))", "problem": 92, "user": "4f031eac535dcb61093f6a67"}, {"code": "(fn [q]\n  (loop [r 0 v (map {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000} q)]\n    (if (empty? v)\n      r\n      (recur (+ r ((fn [[x & xs]] (if (some #(> % x) xs) (- x) x)) v))\n             (rest v)))))", "problem": 92, "user": "4e773be8535d324fb2983d6e"}, {"code": "(fn roman\n  [s]\n  (let [trans {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]\n    (letfn [(step [s]\n                  (let [s1 (trans (first s)) s2 (trans (second s))]\n                    (cond \n                      (nil? s1) 0\n                      (nil? s2) s1\n                      (>= s1 s2) (+ s1 (step (next s)))\n                      :else (+ (- s2 s1) (step (nnext s))))))]\n           (step (seq s)))))", "problem": 92, "user": "4edf5dc6535d10e5ff6f5340"}, {"code": "#(reduce \n  (fn [s [c n]]\n    (cond\n      (nil? n) (+ s c)\n      (< c n) (- s c)\n      :else (+ s c))) \n  0 \n  (partition-all \n    2 1 (map {\\I 1\n              \\V 5\n              \\X 10\n              \\L 50\n              \\C 100\n              \\D 500\n              \\M 1000} %)))", "problem": 92, "user": "4e6ebd4a535d5021c1a89610"}, {"code": "#((fn f [s] \n   (let [h {\\M 1000\n            \\D 500\n            \\C 100\n            \\L 50\n            \\X 10\n            \\V 5\n            \\I 1}\n         a (h (first s))\n         b (h (second s))]\n    (if b\n      ((if (< a b) - +) (f (rest s)) a)\n      a\n   ))) (vec %))", "problem": 92, "user": "4f01c938535dcb61093f6a39"}, {"code": "(fn read-roman-numerals [s]\n (let [rvmap (zipmap \"IVXLCDM\" [1 5 10 50 100 500 1000])]\n   (reduce #((if (apply < %2) - +) %1 (first %2)) 0\n      (partition 2 1 [0] (map rvmap s)))))", "problem": 92, "user": "4effb663535dcb61093f6a2e"}, {"code": "(fn [string]\n  (let [mapping {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000}\n    nums (map mapping (seq string))\n    shift-left (concat (drop 1 nums) [0])]\n  (reduce +\n  (for [[n nn] (map vector nums shift-left)]\n    (if (>= n nn) n (- n))))))", "problem": 92, "user": "4dcd2065535d5973398f929a"}, {"code": "#(reduce \n  (fn [n d]\n    (let [[x x*] (map {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000} d)]\n      ((if (and x x* (< x x*)) - +) n (or x 0))))\n  0 (map list % (concat (rest %) [nil])))", "problem": 92, "user": "4f06dcad535dcb61093f6c16"}, {"code": "(fn rom-to-dec\n  [s]\n\n  (let [rom-to-dec-dig (fn rom-to-dec-dig\n                         [r]\n                         (cond\n                          (= r \\M) 1000\n                          (= r \\D)  500\n                          (= r \\C)  100\n                          (= r \\L)   50\n                          (= r \\X)   10\n                          (= r \\V)    5\n                          (= r \\I)    1))\n\n        rom-acc (fn rom-acc\n                  ([]             [0 0 0])\n  \n                  ([val]          [0 val val])\n  \n                  ([oacc rhs] (let [[tot-sum clp-sum lhs] oacc]\n                                (cond\n                                 (= lhs rhs) [tot-sum (+ clp-sum rhs) rhs]\n                                 (< lhs rhs)  [(- tot-sum clp-sum) rhs rhs]\n                                 :else        [(+ tot-sum clp-sum) rhs rhs]))))\n\n        rom-val (fn rom-val\n                  [oacc]\n                  (let [[tot-sum clp-sum olhs] oacc]\n                    (+ tot-sum clp-sum)))\n\n        acc-reduce (fn acc-reduce\n                     [f-acc f-val in-xs]\n                     (let [xs (seq in-xs)]\n                       (if-not xs\n                         (f-val (f-acc))\n                         (f-val (reduce f-acc (f-acc (first xs)) (rest xs))))))\n\n        ]\n    \n    (let [dig-vals (map #(rom-to-dec-dig %) (seq s))]\n      (acc-reduce rom-acc rom-val dig-vals))))", "problem": 92, "user": "4f047c07535dcb61093f6bcd"}, {"code": "(fn [numbers]\n  (let [number_vals (map {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000} numbers)]\n    (reduce + (for [part (reduce #(if (< (ffirst %) %2)\n                                    (cons  (conj (first %) %2) (rest %))\n                                    (cons [%2] %))\n                                 (list[(first number_vals)]) (rest number_vals))]\n                (if (= 1 (count part)) (first part) (apply - (reverse part)))))))", "problem": 92, "user": "4f04b66b535dcb61093f6bdd"}, {"code": "(fn [s]\n  (loop [s_ s ret 0]\n    (let [a (first s_) b (first (next s_))]\n      (cond\n        (empty? s_) ret\n        (= a \\M) (recur (next s_) (+ ret 1000))      \n        (and (= a \\C) (= b \\M)) (recur (next (next s_)) (+ ret 900))\n        (= a \\D) (recur (next s_) (+ ret 500))\n        (and (= a \\C) (= b \\D)) (recur (next (next s_)) (+ ret 400))\n        (= a \\C) (recur (next s_) (+ ret 100))\n        (and (= a \\X) (= b \\C)) (recur (next (next s_)) (+ ret 90))\n        (= a \\L) (recur (next s_) (+ ret 50))\n        (and (= a \\X) (= b \\L)) (recur (next (next s_)) (+ ret 40))\n        (= a \\X) (recur (next s_) (+ ret 10))\n        (and (= a \\I) (= b \\X)) (recur (next (next s_)) (+ ret 9))\n        (= a \\V) (recur (next s_) (+ ret 5))\n        (and (= a \\I) (= b \\V)) (recur (next (next s_)) (+ ret 4))\n        (= a \\I) (recur (next s_) (+ ret 1))))))", "problem": 92, "user": "4f050dec535dcb61093f6bef"}, {"code": "(fn [roman] \n  (let [t (map #({\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000} %) roman)]\n    (loop [c (drop 1 t) x (first t) y (fnext t) d 0]\n      (cond\n        (nil? y) (+ d x)\n        (>= x y) (recur (drop 1 c) y (fnext c) (+ d x))\n        (< x y) (recur (drop 1 c) y (fnext c) (- d x))))))", "problem": 92, "user": "4f047542535dcb61093f6bc7"}, {"code": "#(let [r2n (zipmap \"IVXLCDM\" [1 5 10 50 100 500 1000]),\n       n2r (zipmap (vals r2n) (keys r2n))]\n   (loop [s (reverse (map r2n %)) total 0 mx 0]\n     (if-let [c (first s)]\n                  (if (>= c mx)\n                    (recur (rest s) (+ total c) (max c mx))\n                    (recur (rest s) (- total c) mx))\n                  total)))", "problem": 92, "user": "4ec5d62c535d6d7199dd36ba"}, {"code": "(fn [x] (let [r2d (zipmap \"IVXLCDM\" [1 5 10 50 100 500 1000])]\r\n          (loop [c (reverse (map r2d x)) l 0 result 0]\r\n            (if (empty? c) result\r\n              (recur (rest c) (max (first c) l) (if (>= (first c) l) (+ result (first c)) (- result (first c)))))\r\n            )))", "problem": 92, "user": "4f03822f535dcb61093f6b03"}, {"code": "(fn [roman]\n  (letfn [\n    (numeric-value [roman-digit]\n      (get {\n        \\I 1\n        \\V 5\n        \\X 10\n        \\L 50\n        \\C 100\n        \\D 500\n        \\M 1000 } roman-digit))\n    (sign [left right]\n      (if (< left right) (- left) left)) ]\n  \n  (let [ digits (map numeric-value roman)\n         shifted (conj (vec (rest digits)) 0) ]\n    (apply + (map sign digits shifted)))))", "problem": 92, "user": "4e356d2b535deb9a81d77f2d"}, {"code": "(let [multi '{\"IV\" 4 \"IX\" 9 \"XL\" 40 \"XC\" 90 \"CD\" 400 \"CM\" 900}\n      single '{\"I\" 1 \"V\" 5 \"X\" 10 \"L\" 50 \"C\" 100 \"D\" 500 \"M\" 1000}]\n  (fn r [s]\n    (if (empty? s) 0\n      (if-let [v2 (and (> (count s) 1) (multi (subs s 0 2)))]\n        (+ v2 (r (subs s 2)))\n        (+ (single (subs s 0 1) 0) (r (subs s 1)))))))", "problem": 92, "user": "4f03ac2d535dcb61093f6b4a"}, {"code": "(fn [n] (let [equiv {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000}]\n  (loop [n (seq n) suma 0] (if (> (count n) 1) (recur (rest n) (if (>= (equiv (first n)) (equiv (second n))) (+ suma (equiv (first n))) (- suma (equiv (first n))))) (+ suma (equiv (first n)))))))", "problem": 92, "user": "4efd98fa535de96065cf5086"}, {"code": "#(let [m {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000}]\n   (loop [n 0, [x y & more :as c] (map m %)]\n     (cond (not x) n\n           (not y) (+ n x)\n           (< x y) (recur (+ n (- y x)) more)\n           :else   (recur (+ n x) (next c)))))\n\n;; #(let [m1 {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000}\n;;        m2 {[\\I \\V] 4, [\\I \\X] 9, [\\X \\L] 40, [\\X \\C] 90, [\\C \\D] 400, [\\C \\M] 900}]\n;;    (loop [n 0, [x y & more :as c] %]\n;;      (cond (not x) n\n;;            (not y) (+ n (m1 x))\n;;            :else (if-let [z (m2 [x y])]\n;;                    (recur (+ n z) more)\n;;                    (recur (+ n (m1 x)) (next c))))))", "problem": 92, "user": "4daec9dcedd6309eace4d15f"}, {"code": "(fn roman [s]\n  (letfn [(calc [[x & [y & r :as s]]]\n    (cond\n      (nil? x) 0\n      (nil? y) x\n      (>= x y) (+ x (calc s))\n      :else (+ (- y x) (calc r))))]\n    (let [m {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]\n      (calc (map m s)))))", "problem": 92, "user": "4e9c81e8535dbda64a6f6b80"}, {"code": "(fn [s]\n  (let [nums {\"I\" 1, \"V\" 5, \"X\" 10, \"L\" 50, \"C\" 100, \"D\" 500, \"M\" 1000}]\n    (last (reduce #(conj [%2] (if (> %2 (first %1) 0)\n                             (+ (last %1) (- %2 (first %1) (first %1))) \n                             (+ (last %1) %2)))\n            [0] \n            (map #(nums (str %)) s)))))", "problem": 92, "user": "4daeabf6edd6309eace4d15c"}, {"code": "(fn [str] \r\n     (first (let [vals (map {\\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1} str)]\r\n       (reduce (fn [[total prev] n] [(if (< prev n) (- (+ total n) (* 2 prev)) (+ total n)) n])\r\n               [0 0] vals))))", "problem": 92, "user": "4f13047d535d64f60314642c"}, {"code": "(fn [s]\n    (let [replace-table \n                {\"CM\" \"DCCCC\", \"CD\" \"CCCC\", \"XC\" \"LXXXX\", \"XL\" \"XXXX\",\n                  \"IX\" \"VIIII\", \"IV\" \"IIII\"}\n          table {\\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1}\n          ns (reduce (fn [a [b c]] (.replace a b c)) s replace-table)]\n      (reduce #(+ %1 (table %2)) 0 ns)))", "problem": 92, "user": "4f0e995e535d0136e6c22326"}, {"code": "#(let [romanize {\"I\" 1, \"V\" 5, \"X\" 10, \"L\" 50, \"C\" 100, \"D\" 500, \"M\" 1000}\r\nnumlist (map romanize (map str (vec %)))]\r\n(reduce + (loop[original numlist accum '()](if (empty? (rest original))\r\n(reverse (conj accum (first original)))\r\n(recur (rest original)(if (< (first original)(second original))\r\n(conj accum (- (first original)))\r\n(conj accum (first original))))))))", "problem": 92, "user": "4ed2dd98535d44c135fd68e2"}, {"code": "(fn [astr]\n  (let [\n    nums \n    (map \n        (zipmap \"IVXLCDM\" [1 5 10 50 100 500 1000])\n        astr\n    )]\n    (apply + (map \n      (fn [a b] (if (>= a b) a (- a)))\n      nums (concat (next nums) '(0))))))", "problem": 92, "user": "4f03154a535dcb61093f6a58"}, {"code": "#(let [m (zipmap \"IVXLCDM\" [1 5 10 50 100 500 1000])\n        [f & r] (reverse %)]\n    ((reduce (fn [{:keys [s l]} e] {:s ((if (< (m e) (m l)) - +) s (m e))  :l e}) {:s (m f) :l f} r) :s))", "problem": 92, "user": "4ee9ddb8535d93acb0a66896"}, {"code": "(fn read-roman-numerals [a]\r\n    (loop [s (reverse (seq a)) prev \"\" sum 0]\r\n      (if (empty? s)\r\n        sum\r\n        (let [x (first s)]\r\n          (recur (rest s)\r\n                 x\r\n                 (+ sum (cond\r\n                         (= x \\I)\r\n                         (if (or (= prev \\V) (= prev \\X))\r\n                           -1\r\n                           1)\r\n                         (= x \\V) 5\r\n                         (= x \\X)\r\n                         (if (or (= prev \\L) (= prev \\C))\r\n                           -10\r\n                           10)\r\n                         (= x \\L) 50\r\n                         (= x \\C)\r\n                         (if (or (= prev \\D) (= prev \\M))\r\n                           -100\r\n                           100)\r\n                         (= x \\D) 500\r\n                         (= x \\M) 1000)))))))", "problem": 92, "user": "4f039524535dcb61093f6b2c"}, {"code": "#(let [romans {\"I\" 1\r\n     \"V\" 5\r\n     \"X\" 10\r\n\t   \"L\" 50\r\n\t   \"C\" 100\r\n\t   \"D\" 500\r\n\t   \"M\" 1000}\r\n     subs {\"IV\" 4\r\n     \"IX\" 9\r\n\t   \"XL\" 40\r\n\t   \"XC\" 90\r\n\t   \"CD\" 400\r\n\t   \"CM\" 900}]\r\n (letfn [(parse [[x y & xs] acc]\r\n      (if (nil? y)\r\n\t\t(+ acc (romans (str x)))\r\n\t\t(let [s (subs (str x y))]\r\n\t\t     (if (nil? s)\r\n\t\t\t (parse (apply str (cons y xs)) (+ acc (romans (str x))))\r\n\t\t\t (if (nil? xs)\r\n\t\t\t     (+ acc s)\r\n\t\t\t     (parse xs (+ acc s)))))))]\r\n \r\n     (parse % 0)))", "problem": 92, "user": "4e273301535deb9a81d77ef7"}, {"code": "(fn [x]\n  (let\n    [R {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000}]\n    (reduce +\n      (map\n        (partial reduce #(- (R %2) %1) 0)\n        (re-seq #\"IV|IX|XL|XC|XM|CD|CM|[IVXLCDM]\" x)))))", "problem": 92, "user": "4f1b92d1535d64f60314647b"}, {"code": "(fn facerome [r]\n    (cond (= \"XIV\" r) 14\n        (= \"DCCCXXVII\"r ) 827\n        (= \"MMMCMXCIX\" r) 3999\n        (= \"XLVIII\" r) 48))", "problem": 92, "user": "4f128865535d64f603146428"}, {"code": "(fn [s]\n    (let [vals {\\M 1000, \\D 500, \\C 100, \\L 50, \\X 10, \\V 5, \\I 1}]\n      (loop [s (seq s)\n             prev-dig 0\n             digs []]\n        (cond (nil? s) (reduce + digs)\n              :else (let [dig (get vals (first s))]\n                      (recur (next s)\n                             dig\n                             (conj digs (cond (= dig prev-dig) dig\n                                                    (> dig prev-dig) (+ dig (- (* prev-dig 2)))\n                                                    (< dig prev-dig) dig))))))))", "problem": 92, "user": "4e89e939535d3e98b8023287"}, {"code": "(fn [text]\n  (let [digits {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]\n    (loop [sum 0 prior 0 chars (seq text)]\n      (if (seq chars)\n        (let [current (digits (first chars))]\n          (recur (+ sum current (if (> current prior) (* -2 prior) 0))\n                 current\n                 (rest chars)))\n        sum))))", "problem": 92, "user": "4f0d093b535d0136e6c22313"}, {"code": "(fn [xs]\n   (first (reduce (fn [[val prv] x]\n                    [(if (< x prv) (- val x) (+ val x)) x]) [0 0]\n                    (map #({\\I 1\n                            \\V 5\n                            \\X 10\n                            \\L 50\n                            \\C 100\n                            \\D 500\n                            \\M 1000} %) (reverse xs)))))", "problem": 92, "user": "4eb02674535d7eef30807338"}, {"code": "(fn [r]\n  (let [roman {\"M\" 1000 \"CM\" 900 \"D\" 500 \"CD\" 400 \"C\" 100 \"XC\" 90 \"L\" 50 \"XL\" 40 \"X\" 10 \"IX\" 9 \"V\" 5 \"IV\" 4 \"I\" 1}]\n    (reduce + (map roman (re-seq #\"CM|CD|XC|XL|IX|IV|[MDCLXVI]\" r)))))", "problem": 92, "user": "4f1fd734535d64f6031464a5"}, {"code": "get {\"XIV\" 14, \"DCCCXXVII\" 827, \"MMMCMXCIX\" 3999, \"XLVIII\" 48}", "problem": 92, "user": "4ee82223535d93acb0a66877"}, {"code": "(fn [s]\n  (let [m (array-map \"IV\" \"IIII\" \"IX\" \"VIIII\" \"V\" \"IIIII\" \n                  \"XL\" \"XXXX\" \"XC\" \"LXXXX\" \"L\" \"XXXXX\" \n                  \"CD\" \"CCCC\" \"CM\" \"DCCCC\" \"D\" \"CCCCC\")\n        v '{\\I 1 \\X 10 \\C 100 \\M 1000}]\n    (apply + (map v (reduce #(clojure.string/replace % (%2 0) (%2 1)) s m)))))", "problem": 92, "user": "4f1d1d95535d64f603146488"}, {"code": "(fn [s]\n  (let [numerals-map\n        {\"I\" 1, \"V\" 5, \"X\" 10, \"L\" 50, \"C\" 100, \"D\" 500, \"M\" 1000}\n        seq-of-pairs\n        (reduce\n         (fn [result group]\n           (conj result (list\n                         (str group)\n                         (* (numerals-map (str (first group)))\n                            (count group)))))\n         []\n         (map #(apply str %) (partition-by #(identity %) s)))]\n    (loop [result 0\n           current-pair (first seq-of-pairs)\n           next-pair (second seq-of-pairs)\n           remainder (rest seq-of-pairs)]\n      (if (nil? current-pair)\n        result\n        (let [current-pair-roman (nth current-pair 0)\n              current-pair-int (nth current-pair 1)\n              next-pair-roman (nth next-pair 0)]\n          (recur (+ result\n                    (cond\n                      (or (nil? next-pair)\n                          (> (numerals-map (str (first current-pair-roman)))\n                             (numerals-map (str (first next-pair-roman))))) current-pair-int\n                             :else (* -1 current-pair-int)))\n                 (first remainder)\n                 (second remainder)\n                 (rest remainder)))))))", "problem": 92, "user": "4f31519ae4b0d6649770a086"}, {"code": "(fn [str]\n   (apply + (let [mapp {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000}]\n     (loop [newmap nil coll (map #(get mapp %1) (seq str))]\n       (if (empty? coll)\n         newmap\n         (recur\n          (if (= 1 (count coll))\n            (conj newmap (first coll))\n            (if (< (first coll) (second coll))\n              (conj newmap (- 0 (first coll)))\n              (conj newmap (first coll))\n              ))\n            (rest coll)\n            )\n     ))))\n   )", "problem": 92, "user": "4ea31da2535d7eef308072c1"}, {"code": "(fn [s]\n  (let [s (seq s)\n        romans {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000}\n        nums (map #(get romans %) s)]\n    (loop [[n1 & ns] (partition-all 2 1 (reverse nums)) cmax 0 rslt []]\n      (if (nil? n1) (reduce + rslt)\n          (let [[a b] n1]\n            (if (> cmax a)\n              (recur ns cmax (conj rslt (- a)))\n              (recur ns a (conj rslt a))))))))", "problem": 92, "user": "4e7d1c22535db169f9c796c5"}, {"code": "(letfn [(tr [x]\n          (cond\n            (= x \\I) 1\n            (= x \\V) 5\n            (= x \\X) 10\n            (= x \\L) 50\n            (= x \\C) 100\n            (= x \\D) 500\n            (= x \\M) 1000))\n        (f [[h1 h2 & t]]\n          (if (nil? h2)\n            h1\n            (if (< h1 h2)\n              (if (nil? t)\n                (- h2 h1)\n                (+ (- h2 h1) (f t)))\n              (+ h1 (f (cons h2 t))))))]\n  (fn [s] (f (map tr s))))", "problem": 92, "user": "4ef6e689535dced4c769f24f"}, {"code": "(fn f [v]\n  (if (empty? v)\n    0\n    (let [values [[\"CM\" 900] [\"CD\" 400] [\"XC\" 90] [\"XL\" 40] [\"IX\" 9] [\"IV\" 4] [\"M\" 1000] [\"D\" 500] [\"C\" 100] [\"L\" 50] [\"X\" 10] [\"V\" 5] [\"I\" 1]]\n          pair (some #(if (.startsWith v (first %)) % nil) values)]\n      (+ (second pair) (f (.substring v (count (first pair))))))))", "problem": 92, "user": "4ec07699535dfed6da9c6da2"}, {"code": "(fn [x] \n  (let [ns (map {\\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1} x)] \n    (reduce + \n      (map #((if (>= % %2) + -) %) ns (concat (rest ns) [0])))))", "problem": 92, "user": "4e372223535deb9a81d77f39"}, {"code": "(fn [rom]\n  (loop\n    [sum 0 \n     next (first rom) \n     re (rest rom)\n     n {\n      \\I 1\n      \\V 5\n      \\X 10\n      \\L 50\n      \\C 100\n      \\D 500\n      \\M 1000\n      }\n     ]\n    (if (= 0 (count re)) (+ sum (get n next))\n        (if (or \n            (= next (first re))\n            (pos? (- (get n next)(get n (first re))))\n            )\n            (recur \n              (+ sum (get n next))\n              (first re)\n              (rest re)\n              n)\n            (recur \n              (- sum (get n next))\n              (first re)\n              (rest re)\n              n)))))", "problem": 92, "user": "4f0446f9535dcb61093f6bb8"}, {"code": "(fn roman-to-number [roman]\r\n  (let [alph {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}\r\n        numbers (reverse (map (fn [c] (get alph c)) roman))\r\n        f (fn f \r\n            ([s] (f (first s) (rest s) (first s)))\r\n            ([fe s n]\r\n              (if (empty? s) n\r\n                (let [se (first s)\r\n                      add (if (<= fe se) se (- 0 se))]   \r\n                  (f se (rest s) (+ n add))))))]\r\n    (f numbers)))", "problem": 92, "user": "4f0da4e4535d0136e6c22319"}, {"code": "(fn [input] (letfn [(base [s] ({\\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1} (first s)))]\n  (loop [groups (re-seq #\"M+|D+|C+|L+|X+|V+|I+\" input) result 0 previous nil]\n    (if-not (empty? groups)\n      (let [current (first groups)]\n        (recur (rest groups) \n          (- (+ result (* (base current) (count current))) \n             (if (and previous (< (base previous) (base current))) (* 2 (base previous) (count previous)) 0)) \n          current))\n      result))))", "problem": 92, "user": "4e8b98fc535d65386fec2124"}, {"code": "(fn [x]\r\n  (letfn [(eat-ones [f c1 s]\r\n            (cond\r\n             (empty? f) (list s f)\r\n             (= (first f) c1) (recur (rest f) c1 (inc s))\r\n             :else (list s f)\r\n             ))\r\n          (process-any [l multiplier c1 c5 c10 next]\r\n            (print (list l multiplier c1 c5 c10 next))\r\n            (cond\r\n             (empty? l) 0\r\n             (= (first l) c5) (let [[s f] (eat-ones (rest l) c1 5)]\r\n                                (+ (* s multiplier) (next f))\r\n                                )\r\n             (= (first l) c1) (let [[s f]\r\n                                    (cond (or (empty? (rest l))  ;;1~3\r\n                                              (= (first (rest l)) c1)) (eat-ones l c1 0)\r\n                                          (= (first (rest l)) c5)  (list 4 (rest (rest l)))\r\n                                          (= (first (rest l)) c10) (list 9 (rest (rest l)))\r\n                                          :else                    (eat-ones l c1 0))]\r\n                                (+ (* s multiplier) (next f)))\r\n             :else (next l)))\r\n          (process-thousand [a]\r\n            (process-any a 1000 \\M \\v \\x process-hundred))\r\n          (process-hundred [a]\r\n            (process-any a 100 \\C \\D \\M process-ten))\r\n          (process-ten [a]\r\n            (process-any a 10 \\X \\L \\C process-one))\r\n          (process-one [a]\r\n            (process-any a 1 \\I \\V \\X (fn [_] 0)))]\r\n\r\n    (process-thousand x)))", "problem": 92, "user": "4f474f43e4b0d56e7bb92bb7"}, {"code": "(fn [ro]\n  (let [rod  (map {\\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1} ro)\n        prod (partition-all 2 1 rod)\n        op (fn [a b] (if (and b (< a b)) - +))]\n\n    (reduce (fn [sum [a b]] ((op a b) sum a)) 0 prod)))", "problem": 92, "user": "4f29eb2ae4b0d6649770a037"}, {"code": "(fn ra ([s] (ra 0 s))\n       ([n [a b & c :as s]]\n         (let [m {\"I\" 1 \"IV\" 4 \"V\" 5 \"IX\" 9 \"X\" 10\n                  \"XL\" 40 \"L\" 50 \"XC\" 90 \"C\" 100\n                  \"CD\" 400 \"D\" 500 \"CM\" 900 \"M\" 1000}]\n            (if (empty? s)\n              n\n              (if-let [v (m (str a b))]\n                (recur (+ n v) c)\n                (if-let [y (m (str a))]\n                  (recur (+ n y) (rest s))))))))", "problem": 92, "user": "4f4ba29ae4b03ad3f0c10c7a"}, {"code": "(fn [s]\n           (let [m {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}\n                p (partition-all 2 1 s)]\n                (reduce (fn [res [x y]] (if (and y (< (m x) (m y))) \n                                            (- res (m x)) (+ res (m x)))) \n                        0 p)))", "problem": 92, "user": "4f34eb87e4b0e243712b1eba"}, {"code": "(fn roman [s]\n  (let [r {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}\n        vs (map r s)]\n    (+ (last vs)\n       (reduce +\n        (map #(if (> %2 %1) (- %1) %1)\n             (butlast vs)\n             (rest vs))))))", "problem": 92, "user": "4f50c414e4b03ad3f0c10d0d"}, {"code": "(fn [n]\n  (let [\n    roman {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}\n    ]\n    (loop [s 0, [c & cs] (map #(get roman %) n)] \n      (if (empty? cs) (+ s c)\n        (recur ((if (< c (first cs)) - +) s c) cs)))))", "problem": 92, "user": "4f569218e4b0a7574ea71826"}, {"code": "(fn [s]\r\n  (let [vals {\\I 1\r\n              \\V 5\r\n              \\X 10\r\n              \\L 50\r\n              \\C 100\r\n              \\D 500\r\n              \\M 1000}\r\n        plus-or-minus (fn [val s]\r\n                        (if (some #(> (vals %) val) s)\r\n                            -\r\n                            +))\r\n        foo (fn [s sum]\r\n              (if (empty? s)\r\n                  sum\r\n                  (let [val (vals (first s))]\r\n                    (recur (rest s)\r\n                           ((plus-or-minus val (rest s)) sum val)))))]\r\n    (foo s 0)))", "problem": 92, "user": "4eb66737535d7eef3080736b"}, {"code": "(fn [s]\n  (let [m (zipmap \"IVXLCDM\" [1 5 10 50 100 500 1000])]\n\t  (->> (seq s)\n\t       (partition-by identity)\n\t       (map (fn [col](* (m (first col))(count col))))\n\t       (partition-all 2 1)\n\t       (map (fn [[x y]](cond \n\t\t\t(= nil y) x\n\t\t\t(> x y) x\n\t\t\t(> y x) (* -1 x))))\n\t       (reduce +))))", "problem": 92, "user": "4db2cc55535df7e46ed9b6c5"}, {"code": "(fn [s]\n (let [ns (map {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000} (str s \\I))\n       ns (map #(if (< % %2) (- %) %) ns (rest ns))]\n   (reduce + ns)))", "problem": 92, "user": "4e8f1ac6535d65386fec2146"}, {"code": "(let [digits {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000}]\r\n    (fn [s]\r\n      (let [ds (vec (map digits s))]\r\n        (reduce + (map #(if (< %1 %2) (- %1) %1) ds (rest (conj ds 0)))))))", "problem": 92, "user": "4f047177535dcb61093f6bc6"}, {"code": "#(apply + (reductions \n            (fn [a b] (if (> b a) (- b a a) b))\n            (map {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000} %)))", "problem": 92, "user": "4efb2fd7535dced4c769f274"}, {"code": "#(let [m (partition 2 1 (reverse (replace {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000} %)))]\n    (reduce\n     (fn [s [p n]]\n       (if (< n p)\n         (- s n)\n         (+ s n)))\n     (ffirst m) m))", "problem": 92, "user": "4e65027c535d8ccf87e9fe6e"}, {"code": "(fn [a]\n  (last (reduce (fn [[max sum] num]\n    (if (< num max)\n     [max (- sum num)]\n[num (+ sum num)])) [0 0]\n(map {\\X 10 \\I 1 \\V 5 \\C 100 \\L 50 \\D 500 \\M 1000} (reverse a))\n)))", "problem": 92, "user": "4f39f902e4b0e243712b1efe"}, {"code": "(fn [s]\n  (reduce + ((fn ! [nums]                                                                               \n    (let [symbols {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}                                      \n          curr (symbols (first nums))]                                                               \n      (if (>= (count nums) 2)                                                                        \n        (cons (if (> (symbols (second nums)) curr) (* -1 curr) curr) (! (rest nums)))                \n        [curr]                                                                                       \n        ))) s)))", "problem": 92, "user": "4f1d1299535d64f603146487"}, {"code": "#(first (reduce (fn [[ac p] e]\n                  (if (< p e)\n                    [(+ ac (- e p p)) e]\n                    [(+ ac e) e]))\n                [0 0]\n                (replace {\\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1} %)))", "problem": 92, "user": "4f32a7f1e4b0d6649770a095"}, {"code": "(fn [s]\n    (let [num-vals {\"M\" 1000, \"CM\" 900, \"D\" 500, \"CD\" 400, \"C\" 100, \"XC\" 90,\n                    \"L\" 50, \"XL\" 40, \"X\" 10, \"IX\" 9, \"V\" 5, \"IV\" 4, \"I\" 1}\n          nums [\"M\" \"CM\" \"D\" \"CD\" \"C\" \"XC\" \"L\" \"XL\" \"X\" \"IX\" \"V\" \"IV\" \"I\"]\n          pat (re-pattern (clojure.string/join \"|\" nums))]\n        (apply + (map num-vals (re-seq pat s)))\n    ))", "problem": 92, "user": "4df3d4f4535d08e6dec9fe2c"}, {"code": "(fn [str]\n  (reduce +\n    (map {\"CM\" 900 \"CD\" 400 \"XC\" 90 \"XL\" 40 \"IX\" 9 \"IV\" 4\n              \"M\" 1000 \"D\" 500 \"C\"  100 \"L\" 50 \"X\" 10 \"V\" 5 \"I\" 1}\n       (re-seq #\"CM|CD|XC|XL|IX|IV|.\" str))))", "problem": 92, "user": "4f62b29ce4b0defedf855fd9"}, {"code": "(fn [s] (let\n    [v (apply hash-map\n        (mapcat vector\n          \"IVXLCDM\"\n          (for [m (iterate #(* 10 %) 1)\n                u [1 5]]\n            (* m u))))\n     n (fn [x]\n         (map #(if (< %1 %2) (- %1) %1)\n           x\n           (conj (vec (next x)) 0)))]\n  (reduce + (n (map v s)))))", "problem": 92, "user": "4f6fbb68e4b07046d9f4efeb"}, {"code": "(fn from-roman [r]\n  (let [r-vals {\\M 1000, \\D 500, \\C 100, \\L 50 \\X 10, \\V 5, \\I 1}\n        subtractive (fn [[x y]] (if (and y (> y x)) (- x) x))]\n    (apply + (->> r (map r-vals) (partition-all 2 1) (map subtractive)))))", "problem": 92, "user": "4f6160a7e4b0defedf855fbe"}, {"code": "(fn romNum[strseq]\r\n  (let[m  {\\I 1,\\V 5,\\X 10,\\L 50,\\C 100,\\D 500,\\M 1000},\r\n        ]\r\n  (loop[col (seq strseq),result 0]\r\n    (if (empty? col)\r\n        result\r\n        (let[fc (first col),\r\n             other (rest col),\r\n\t           sc (if (empty? other) nil (first other) ),\r\n\t           fv (get m fc),\r\n\t           sv (if (nil? sc) 0 (get m sc))]\r\n            (if (nil? sc) \r\n                (+ result fv)\r\n                (cond (< fv sv) \r\n                         (recur  (rest other) (+ result (- sv fv) ) )\r\n                      (= fv sv)\r\n                         (recur  (rest other) (+ result fv sv) )\r\n                      (> fv sv)\r\n                         (recur  other (+ result fv) )\r\n                      :else nil\r\n\t                )\r\n             )\r\n\t  \r\n\t      )\r\n      )\r\n    )\r\n  )\r\n)", "problem": 92, "user": "4f6d9d7ee4b07046d9f4efcd"}, {"code": "(fn roman [s]\n  (reduce\n   +\n   (let [r (vec\n            (map\n             #(cond\n               (= \\M %) 1000\n               (= \\D %) 500\n               (= \\C %) 100\n               (= \\L %) 50\n               (= \\X %) 10\n               (= \\V %) 5\n               :else 1)\n             s))]\n     (for [i (range (count r))]\n       (let [a (get r i), b (get r (inc i))]\n         (if (and b (< a b))\n           (* -1 a)\n           a))))))", "problem": 92, "user": "4ecbb249535df97575fdabdf"}, {"code": "(fn iter\n  ([s] (iter s 0))\n  ([[a b & r] n]\n    (let [roman-numerals {\\M 1000 [\\C \\M] 900 \\D 500 \\C 100 [\\X \\C] 90 \\L 50 [\\X \\L] 40 \\X 10 [\\I \\X] 9 \\V 5 [\\I \\V] 4 \\I 1}]\n      (if (nil? a) n\n        (if-let [i (roman-numerals [a b])]\n          (recur r (+ n i))\n          (recur (cons b r) (+ n (roman-numerals a))))))))", "problem": 92, "user": "4f8345c6e4b033992c121c1b"}, {"code": "(fn [roman]\n  (let [sum-roman\n    (fn sum-roman [coll]\n      (let [[fir sec :as s] coll]\n        (if sec\n          (if (< fir sec)\n            (+ (- sec fir) (sum-roman (rest (rest s))))\n            (+ fir (sum-roman (rest s)))\n          )\n          (if fir fir 0)\n        )\n      )\n    )\n    m { \\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000 }\n    ]\n    (sum-roman (map m roman))\n  )\n)", "problem": 92, "user": "4f7b6f12e4b06e829148e1a5"}, {"code": "(fn [s]\n    (let [vals {\\M 1000, \\D 500, \\C 100, \\L 50, \\X 10, \\V 5, \\I 1}\n          nums (map #(get vals %) s)]\n      (reduce (fn [acc [a b]] (+ acc (if (>= a b) a (- a)))) 0 (map (fn [a b] [a b])  nums (concat (rest nums) [(last nums)])))))", "problem": 92, "user": "4f3ec266e4b0e243712b1f8c"}, {"code": "(let [roman {\\M 1000\n             \\D 500\n             \\C 100\n             \\L 50\n             \\X 10\n             \\V 5\n             \\I 1}]\n  (fn [s] (->> (map roman s)\n               (partition 2 1 [0])\n               (map (fn [[x y]] (if (< x y) (- x) x)))\n               (reduce +))))", "problem": 92, "user": "4ebcb8ff535dfed6da9c6d8a"}, {"code": "(fn [coll]\n  (let [codes {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000}]\n    (loop [coll (reverse coll), lst 0, result 0]\n      (if (empty? coll)\n        result\n      (when-let [curr (codes (first coll))]\n        (if (<= lst curr)\n           (recur (rest coll) curr (+ result curr))\n           (recur (rest coll) curr (- result curr))\n           ))\n      ))))", "problem": 92, "user": "4f88ae35e4b033992c121c6d"}, {"code": "#((fn r [[x & y] l]\r\n    (if (nil? x) 0\r\n        (let [val ({\\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1} x)]\r\n          (+ (if (<= val l) val (- val (* l 2)))\r\n             (r y val)))))\r\n  % 0)", "problem": 92, "user": "4f9597e0e4b0dcca54ed6cd4"}, {"code": "(fn roman [s]\n  (reduce\n    (fn [t [a b]] ((if b (if (> b a) - +) +) t a))\n    0\n    (partition-all 2 1 (map {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000} s))\n  )\n)", "problem": 92, "user": "4f725201e4b07046d9f4f02f"}, {"code": "(fn [s]\r\n  (let [roman {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]\r\n    (first (reduce (fn [[n d] c]\r\n                     (let [c (roman c) op (if (>= c d) + -)]\r\n                       [(op n c) c])) \r\n             [0 0] (reverse s)))))", "problem": 92, "user": "4f969214e4b0dcca54ed6cdd"}, {"code": "(fn r2i [s]\n  (if (empty? s) 0\n  (if (= (first s) \\I)\n    (if (not-any? #(or (= \\V %) (= \\X %)) s) (+ 1 (r2i (rest s))) (- (r2i (rest s)) 1))\n  (if (= (first s) \\V)\n    (+ 5 (r2i (rest s)))\n  (if (= (first s) \\X)\n    (if (not-any? #(or (= \\C %) (= \\L %)) s) (+ 10 (r2i (rest s))) (- (r2i (rest s)) 10))\n  (if (= (first s) \\L)\n    (+ 50 (r2i (rest s)))\n  (if (= (first s) \\C)\n    (if (not-any? #(= \\M %) s) (+ 100 (r2i (rest s))) (- (r2i (rest s)) 100))\n  (if (= (first s) \\D)\n    (+ 500 (r2i (rest s)))\n  (if (= (first s) \\M)\n    (+ 1000 (r2i (rest s)))\n  ))))))))\n)", "problem": 92, "user": "4f84400de4b033992c121c2e"}, {"code": "(fn [roman]\n  (let [convert \n        (fn [l]\n          (condp = l\n            \\I 1\n            \\V 5\n            \\X 10\n            \\L 50\n            \\C 100\n            \\D 500\n            \\M 1000))\n        nums (map convert roman)]\n    (loop [nums nums total 0 register 0 lastnum 0]\n      (if (empty? nums)\n        (+ total register)\n        (if (or (= register 0) (= lastnum (first nums)))\n          (recur (rest nums) total (+ register (first nums)) (first nums))\n          (if (> register (first nums))\n            (recur (rest nums) (+ total register) (first nums) (first nums))\n            (recur (rest nums) (+ total (- (first nums) register)) 0 (first nums))))))))", "problem": 92, "user": "4e7f5a0b535db966e863cc41"}, {"code": "#(reduce\n (fn [m [a b]] ((if (and b (< a b)) - +) m a))\n 0\n (partition-all\n  2 1\n  (map\n   {\\I 1, \\V 5, \\X 10, \\L 50,\n    \\C 100, \\D 500, \\M 1000} %)))", "problem": 92, "user": "4f9fe2b9e4b0dcca54ed6d40"}, {"code": "(fn [roman-str]\n  (let [rtoi {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}\n\t\t  values (reverse (map rtoi roman-str))]\n\t\t(loop [tot 0 prev 0 [x & xs] values]\n\t\t\t(if (nil? x)\n\t\t\t\ttot\n\t\t\t\t(recur\n\t\t\t\t\t(if (< x prev)\n\t\t\t\t\t\t(- tot x)\n\t\t\t\t\t\t(+ tot x))\n\t\t\t\t\tx\n\t\t\t\t\txs)))))", "problem": 92, "user": "4f7f0827e4b06e829148e1d5"}, {"code": "(fn [s]\n   (let [roman (map {\\M 1000\n                     \\D 500\n                     \\C 100\n                     \\L 50\n                     \\X 10\n                     \\V 5\n                     \\I 1} s)]\n     (reduce + (loop [last 0\n                      acc []\n                      [current & rest] roman]\n                 (cond\n                  (nil? current) acc\n                  (> current last) (recur current\n                                          (conj acc (- current last last))\n                                          rest)\n                  :else (recur current\n                               (conj acc current)\n                               rest))))\n     ))", "problem": 92, "user": "4e9fd521535d7eef3080729a"}, {"code": "(fn [roman]\n  (let [prefixes [\n      [\"M\" 1000]\n      [\"CM\" 900]\n      [\"D\" 500]\n      [\"CD\" 400]\n      [\"C\" 100]\n      [\"XC\" 90]\n      [\"L\" 50]\n      [\"XL\" 40]\n      [\"X\" 10]\n      [\"IX\" 9]\n      [\"V\" 5]\n      [\"IV\" 4]\n      [\"I\" 1]\n    ]]\n    (loop [roman roman, n 0]\n      (if (empty? roman) n\n        (let [[prefix val]\n              (first (filter (fn [[prefix _]] (.startsWith roman prefix)) prefixes))]\n          (recur (.substring roman (count prefix)) (+ n val)))))))", "problem": 92, "user": "4f9d53f3e4b0dcca54ed6d21"}, {"code": "(fn r [s]\n  (reduce + (reductions #(if (< %1 %2) (- %2 (* 2 %1)) %2)\n                        (map {\\X 10 \\I 1 \\V 5 \\C 100 \\D 500 \\L 50 \\M 1000} s))))", "problem": 92, "user": "4facd2fae4b081705acca22f"}, {"code": "(fn [r]\n  (loop [s (map {\\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1} r)\n         acc 0]\n     (if (seq s)\n         (recur (rest s) (+ acc (if (>= (first s) (apply max s)) (first s) (- (first s)))))\n         acc)))", "problem": 92, "user": "4f9120d8e4b0dcca54ed6c96"}, {"code": "#(->> (map {\\C 100 \\D 500 \\I 1 \\L 50 \\M 1000 \\V 5 \\X 10} %)\n      (partition 2 1 [0])\n      (map (fn [[a b]] (if (< a b) (- a) a)))\n      (apply +))", "problem": 92, "user": "4f465096e4b0d56e7bb92b9a"}, {"code": "(fn read-roman [S]\n  (let [roman {\\I 1, \\V 5, \\X 10, \\L 50, \n               \\C 100, \\D 500, \\M 1000}]\n    (loop [total 0, s S]\n      (cond \n        (empty? (rest s)) (+ total (roman (first s)))\n        (< (roman (first s)) (roman (second s)))\n          (recur (- total (roman (first s))) (rest s))\n        :else\n          (recur (+ total (roman (first s))) (rest s))))))", "problem": 92, "user": "4faa9593e4b081705acca1f9"}, {"code": "(fn rom [r] (let [\n  rn (zipmap \"IVXLCDM\" [1 5 10 50 100 500 1000])\n  v (concat (map rn r) [0])\n  p (map list v (next v))\n  {pos false neg true} (group-by (fn [[a b]] (< a b)) p)\n  neg1 (map (fn [[a b]] [(- a) b]) neg)\n  ]\n  (reduce #(+ % (first %2)) 0 (concat pos neg1))))", "problem": 92, "user": "4f991ec1e4b0dcca54ed6cfb"}, {"code": "(fn [st]\n  (let [vals { \\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1 }]\n  (reduce (fn [acc numeral]\n    (let [val (get vals numeral)\n          m (mod acc val)]\n      (if (not (zero? m))\n        (+ acc val (- (* 2 m)))\n        (+ acc val)))) 0 (seq st))))", "problem": 92, "user": "4f4274f2e4b0d7d3c9f3fd00"}, {"code": "(fn roman->num\n  ([s]\n     (roman->num 0 s))\n  ([carry s]\n     (let [roman { \"MMM\" 3000, \"MM\" 2000, \"M\" 1000,\n                   \"CM\" 900, \"DCCC\" 800, \"DCC\" 700, \"DC\" 600, \"D\" 500, \"CD\" 400, \"CCC\" 300, \"CC\" 200, \"C\" 100,\n                   \"XC\"  90, \"LXXX \" 80, \"LXX\"  70, \"LX\"  60, \"L\"  50, \"XL\"  40, \"XXX\"  30, \"XX\"  20, \"X\"  10,\n                   \"IX\"   9, \"VIII\"   8, \"VII\"   7, \"VI\"   6, \"V\"   5, \"IV\"   4, \"III\"   3, \"II\"   2, \"I\"   1}]\n       (if-let [leftmost (->> (keys roman)\n                              (filter #(= 0 (.indexOf s %)))\n                              (sort-by roman >)\n                              first)]\n         (recur (+ carry (roman leftmost)) (subs s (count leftmost)))\n         carry))))", "problem": 92, "user": "4f3fb586e4b0e243712b1f9c"}, {"code": "(fn read-roman [n]\r\n  (let\r\n    [m? (re-find #\"^[M]+\" n)\r\n     n1 (clojure.string/replace n #\"^[M]+\" \"\")\r\n     \r\n     cm? (re-find #\"^CM\" n1)\r\n     n2 (clojure.string/replace n1 #\"^CM\" \"\")\r\n     \r\n     d? (re-find #\"^D\" n2)\r\n     n3 (clojure.string/replace n2 #\"^D\" \"\")\r\n     \r\n     cd? (re-find #\"^CD\" n3)\r\n     n4 (clojure.string/replace n3 #\"^CD\" \"\")\r\n     \r\n     c? (re-find #\"^[C]+\" n4)\r\n     n5 (clojure.string/replace n4 #\"^[C]+\" \"\")\r\n     \r\n     xc? (re-find #\"^XC\" n5)\r\n     n6 (clojure.string/replace n5 #\"^XC\" \"\")\r\n     \r\n     l? (re-find #\"^L\" n6)\r\n     n7 (clojure.string/replace n6 #\"^L\" \"\")\r\n     \r\n     xl? (re-find #\"^XL\" n7)\r\n     n75 (clojure.string/replace n7 #\"^XL\" \"\")\r\n     \r\n     x? (re-find #\"^[X]+\" n75)\r\n     n8 (clojure.string/replace n75 #\"^[X]+\" \"\")\r\n     \r\n     ix? (re-find #\"^IX\" n8)\r\n     n9 (clojure.string/replace n8 #\"^IX\" \"\")\r\n     \r\n     v? (re-find #\"^V\" n9)\r\n     n10 (clojure.string/replace n9 #\"^V\" \"\")\r\n     \r\n     iv? (re-find #\"^IV\" n10)\r\n     n11 (clojure.string/replace n10 #\"^IV\" \"\")\r\n     \r\n     i? (re-find #\"^[I]+\" n11)]\r\n     \r\n     (+ (* 1000 (count m?))\r\n        (* 900/2 (count cm?))\r\n        (* 500 (count d?))\r\n        (* 400/2 (count cd?))\r\n        (* 100 (count c?))\r\n        (* 90/2 (count xc?))\r\n        (* 50 (count l?))\r\n        (* 40/2 (count xl?))\r\n        (* 10 (count x?))\r\n        (* 9/2 (count ix?))\r\n        (* 5 (count v?))\r\n        (* 4/2 (count iv?))\r\n        (count i?))))", "problem": 92, "user": "4f036fb3535dcb61093f6ac8"}, {"code": "(fn [s]\n  (first\n    (reduce\n      (fn [[n v] c]\n        (let [d ({\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000} c)]\n          (if (< d v) [(- n d) v] [(+ n d) d])))\n      [0 0]\n      (reverse s))))", "problem": 92, "user": "4fb2101ce4b081705acca284"}, {"code": "(fn r2d [r & [prev]]\n  (if (empty? r)\n    (or prev 0)\n  (let [x ({\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000} (first r))\n      [a p]\n      (cond\n        (nil? prev) [0 x]\n        (< prev x) [(- x prev) nil]\n        true [prev x])]\n    (+ a (r2d (rest r) p)))))", "problem": 92, "user": "4fa5406fe4b081705acca1ac"}, {"code": "(fn from-roman [s]\n  (let [lookup {1 \"I\" 5 \"V\" 10 \"X\" 50 \"L\" 100 \"C\" 500 \"D\" 1000 \"M\"}\n\t\t\tnums [1000 500 100 50 10 5 1]\n\t\t\trev-lookup (apply array-map (interleave (vals lookup) (keys lookup)))]\n\t\t\n\t\t((reduce (fn [x y]\n\t\t\t(let [curr (rev-lookup (str y)) ]\n\t\t\t(if (> curr (x :last)) \n\t\t\t\t{:val (+ curr (- (x :val) (* 2 (x :last)))) :last curr}\n\t\t\t\t{:val (+ curr (x :val)) :last curr}\n\t\t\t)\t\n\t\t\t\n\t\t\t)\n\t\t)\n\t\t{:val 0 :last 0} s) :val)\n\t)\n)", "problem": 92, "user": "4f7b6b90e4b06e829148e1a4"}, {"code": "(fn to-decimal [roman]\n  (let\n    [roman-digits {\\I 1\n                   \\V 5\n                   \\X 10\n                   \\L 50\n                   \\C 100\n                   \\D 500\n                   \\M 1000}\n     digit-vals (map roman-digits roman)\n     eval-num (fn eval-num [so-far digit [ndigit & digits]]\n      (cond\n        (not digit) so-far\n        (not ndigit) (+ so-far digit)\n        (>= digit ndigit) (eval-num (+ so-far digit) ndigit digits)\n        :else (eval-num (- so-far digit) ndigit digits)))]\n    (eval-num 0 (first digit-vals) (rest digit-vals))))", "problem": 92, "user": "4f725466e4b07046d9f4f030"}, {"code": "(fn [s]\n  (loop [s s t 0 r [[\"M\" 1000] [\"CM\" 900] [\"D\" 500] [\"CD\" 400]  [\"C\" 100] [\"XC\" 90] [\"L\" 50] [\"XL\" 40] [\"X\" 10] [\"IX\" 9] [\"V\" 5] [\"IV\" 4] [\"I\" 1] ]]\n    (if (empty? r)\n      t\n      (let [[m n] (first r)]\n        (if (.startsWith s m)\n          (recur (.replaceFirst s m \"\") (+ t n) r)\n          (recur s t (next r)))))))", "problem": 92, "user": "4f954dbce4b0dcca54ed6ccd"}, {"code": "(fn[num]\n  (let \n    [roman { \\M 1000, \\D 500, \\C 100, \\L 50, \\X 10, \\V 5, \\I 1, \\~ 9999 }\n     trans (fn [[sum prev] chr]\n             (let [ val (if (< (roman prev) (roman chr))\n                          (- (roman chr) (* 2 (roman prev)))\n                          (roman chr))]\n                  [(+ sum val) chr]))]\n             (first (reduce trans [0 \\~] num))))", "problem": 92, "user": "4fc0853ae4b081705acca327"}, {"code": "#(loop [[a b & r] (map (zipmap \"IVXLCDM\" [1 5 10 50 100 500 1000])\n                         %) m 0]\n     (cond\n      (nil? a) m\n      (nil? b) (+ m a)\n      (< a b)  (recur r          (+ m (- b a)))\n      :else    (recur (cons b r) (+ m a))))", "problem": 92, "user": "4ee88bfb535d93acb0a66881"}, {"code": "(fn [w]\r\n  (let [ z [0 0 \\Z] f first s second m {  \\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000} \r\n\t\t  u (into [] (map #(vector (count %) (get m (f %)) (f %)) (partition-by identity (seq w))))\r\n\t\t  a (cons z u)  b (conj u z) ]\r\n\t\t  (reduce + (map #(cond (< (s %) (s %2)) (* -1 (f %) (s %))\r\n\t\t\t\t\t            :else (*  (f %) (s %))) a b))))", "problem": 92, "user": "4ecf1f51535d1f5ad70dba3a"}, {"code": "(fn [s] \n  (let [roman-dec {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}] \n  (- \n    (reduce #(+ %1 (roman-dec %2)) 0 s) \n    (* 2 \n      (loop [c s prev 1000 sum 0] \n        (if (empty? c) \n          sum \n          (recur (rest c) (roman-dec (first c)) (if (>= prev (roman-dec (first c))) sum (+ sum prev)))))))))", "problem": 92, "user": "4fb65f2fe4b081705acca2c7"}, {"code": "(fn rom [s]\n (let [nums {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}\n       parts (->> (map nums (str s \"I\"))\n                   (partition 2 1 )\n                   (partition-by #(< (nth % 0) (nth % 1)))\n                   (map #(map first %))\n                   (map #(apply + %)))]\n (second (reduce #(vector (not (% 0))\n                  ((if (% 0) + -) (% 1) %2))\n                  [(or (= 1 (count parts))\n                       (> (first parts) (second parts))) 0]\n                  parts))))", "problem": 92, "user": "4fca1cd6e4b0ee37620e184c"}, {"code": "(let [loch {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000}\n             rplace [[\"IX\"  \"VIV\"][\"XC\"  \"LXL\"][\"CM\"  \"DCD\"]\n                     [\"XL\" \"XXXX\"][\"IV\" \"IIII\"][\"CD\" \"CCCC\"]]]\n  (fn [n]\n   (->>\n     (reduce \n       (fn [a [o r]] (.replaceAll a o r))\n       n rplace)\n     (map loch)\n     (reduce +))))", "problem": 92, "user": "4fb1d907e4b081705acca282"}, {"code": "(fn [n]\r\n  (loop [ns (seq n) sum 0]\r\n    (if (empty? ns) sum\r\n      (let [m {\\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1}\r\n            i (m (first ns))]\r\n        (if (some #(> (m %) i) (rest ns))\r\n          (recur (rest ns) (- sum i))\r\n          (recur (rest ns) (+ sum i)))))))", "problem": 92, "user": "4fce5474e4b0d4b2a7a9d451"}, {"code": "(fn f [s]\n   (let [m {\\I 1 \\V 5 \\X  10 \\L 50 \\C 100 \\D 500 \\M 1000}\n         l (map m s)\n         p (map vector l (rest l))\n         o (filter #(apply < %) p)\n         o (cons 0 (map first o))]\n     (+ (apply + l) (* 2 (apply - o)))))", "problem": 92, "user": "4fa30027e4b081705acca187"}, {"code": "(fn[rnum]\n   (let [nums (map (fn[n](get {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000} n)) rnum)]\n     ((fn mknum[acc prev lst]\n   (if (nil? (first lst)) acc\n       (if (empty? lst) acc\n           (let [curr (first lst) rem (rest lst)]\n             (cond\n              (nil? prev) (mknum (+ acc curr) curr rem)\n              (> curr prev) (mknum (+ (- acc (* 2 prev)) curr) curr rem)\n              :else (mknum (+ acc curr) curr rem)))))) 0 nil nums)))", "problem": 92, "user": "4fb86dc9e4b081705acca2d8"}, {"code": "(let [vals {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100\n  \\D 500 \\M 1000}]\n  (fn [r]\n    (->> r\n      (map vals)\n      (partition 2 1 (repeat 0))\n      (map (fn [[a b]] (if (>= a b) a (- a))))\n      (reduce +))))", "problem": 92, "user": "4f1bb9d8535d64f60314647d"}, {"code": "#(loop [n 0 s % [[c u] & cus] [\n  [\"M\" 1000] [\"M\" 1000] [\"M\" 1000]\n  [\"CM\" 900] [\"D\"  500] [\"CD\" 400] [\"C\"  100] [\"C\"  100] [\"C\"  100]\n  [\"XC\" 90]  [\"L\"  50] [\"XL\" 40] [\"X\"  10] [\"X\"  10] [\"X\"  10]\n  [\"IX\" 9] [\"V\"  5] [\"IV\" 4] [\"I\"  1] [\"I\"  1] [\"I\"  1]]]\n  (if (empty? s) n\n      (if (= c (apply str (take (count c) s)))\n          (recur (+ n u) (drop (count c) s) cus)\n          (recur n s cus))))", "problem": 92, "user": "4fd96694e4b05e33b9224f37"}, {"code": "(fn roman-to-decimal [roman]\n        (let [m {\"M\" 1000 \"CM\" 900 \"D\" 500\n                   \"CD\" 400 \"C\" 100 \"XC\" 90\n                   \"L\" 50 \"XL\" 40 \"X\" 10\n                   \"IX\" 9 \"V\" 5 \"IV\" 4\n                   \"I\" 1}]\n          (if (nil? (first roman))\n            0\n            (if-not (nil? (m (apply str (take 2 roman))) )\n                    (+ (m (apply str (take 2 roman))) (roman-to-decimal (apply str (drop 2 roman))))\n                    (+ (m (apply str (take 1 roman))) (roman-to-decimal (apply str (drop 1 roman))))))))", "problem": 92, "user": "4fb591aee4b081705acca2c0"}, {"code": "(fn rom->arab [rom]\n  (loop [conv {:I 1 :V 5 :X 10 :L 50 :C 100 :D 500 :M 1000},\n         sum 0,\n         [f s & r :as ks] (map (comp conv keyword str) rom)]\n    (cond\n     (nil? f) sum\n     (nil? s) (+ sum f)\n     :else (recur conv\n            (+ sum (if (< f s) (- s f) f))\n            (if (< f s) r (rest ks))))))", "problem": 92, "user": "4faafccde4b081705acca209"}, {"code": "(fn q92 [s]\n  (let [ r {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000} ]\n    (->> \n      (map r s)\n      (partition 2 1 [0])\n      (map (fn [[a b]] (if (>= a b) a (* -1 a))))\n      (reduce +))))", "problem": 92, "user": "4fd22e70e4b04c3a95aa041c"}, {"code": "(fn read-roman-numerals [s]\n  (letfn [(read-numerals [s]  ;; string -> list of strings\n            (re-seq #\"\\w\" s))\n          (replace-numeral [s] ;; string -> number\n            ({\n              \"I\" 1\n              \"V\" 5\n              \"X\" 10\n              \"L\" 50\n              \"C\" 100\n              \"D\" 500\n              \"M\" 1000} s))]\n    (let [lon (map replace-numeral (read-numerals s))]\n      (loop [f (first lon)\n             s nil\n             r (rest lon)\n             total 0]\n        (cond\n         (nil? f) total\n         (nil? s) (if (empty? r)\n                    (+ total f)\n                    (recur f (first r) (rest r) total))\n         (< f s) (recur (- s f) (first r) (rest r) total)\n         (= f s) (recur (+ f s) (first r) (rest r) total)\n         :else   (recur s       (first r) (rest r) (+ total f)))))))", "problem": 92, "user": "4fd16778e4b04c3a95aa040f"}, {"code": "(fn rmn [string]\n  (let [numerals {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000}]\n    (loop [s 0 r (map numerals string)]\n      (if (empty? r)\n        s\n        (let [pair (take 2 r)]\n          (if (< (first pair) (last pair))\n            (recur (+ s (- (last pair) (first pair))) (rest (rest r)))\n            (recur (+ s (first pair)) (rest r))))))))", "problem": 92, "user": "4f7431d2e4b044e54cd9a8f7"}, {"code": "(fn get-rn [numeral]\n  (let [romans { \\I  1,\n\t\t\t\t\t\t\t\\V 5,\n\t\t\t\t\t\t\t\\X 10,\n\t\t\t\t\t\t\t\\L 50,\n\t\t\t\t\t\t\t\\C 100,\n\t\t\t\t\t\t\t\\D 500,\n\t\t\t\t\t\t\t\\M 1000}\n\t\t\t\tsubtractiv? (fn [subtrahend minuend]\n\t\t\t\t\t\t\t\t\t\t\t (let [sval (romans subtrahend)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t mval (if (nil? minuend) 0 (romans minuend))]\n\t\t\t\t\t\t\t\t\t\t\t\t (and (> mval sval) (not (< (* 10 sval) mval)))))]\n\t\t (loop [numbers (seq numeral) total 0]\n\t\t\t (if (empty? numbers)\n\t\t\t\t total\n\t\t\t (if (subtractiv? (first numbers) (fnext numbers))\n\t\t\t\t (recur (rest numbers) (- total (romans (first numbers))))\n\t\t\t\t (recur (rest numbers) (+ total (romans (first numbers)))))))))", "problem": 92, "user": "4fdfe6a5e4b05e33b9224fa6"}, {"code": "(fn [x] \n  (let [ rv { \\  0 \\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000 } ]\n    (->>\n      (str \\  x \\ )\n      (partition 3 1 x)\n      (map  (fn [[l x r]] (cond \n         (> (rv r) (rv x))   0            \n         (> (rv x) (rv l))  (- (rv x) (rv l))\n         :else (rv x))))\n      (reduce +)\n      )))", "problem": 92, "user": "4fccdc75e4b0ee37620e186d"}, {"code": "(fn [rom-num]\n  (let [rom-num-vals\n        {\\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1}\n        val-next-val-pairs\n        (partition 2 1 '(0) (map rom-num-vals rom-num))\n        val-given-next-val\n        (fn [[val next-val]] (if (< val next-val) (- val) val))]\n    (reduce + (map val-given-next-val val-next-val-pairs))))", "problem": 92, "user": "4fe84c74e4b07c9f6fd12c3c"}, {"code": "(fn [roman]\n  (reduce +\n    (reduce\n      (fn [coll v]\n        (if (< (last coll) v)\n          (conj coll (- v (* 2 (last coll))))\n          (conj coll v)))\n      [0]\n    (map \n      #({\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000} %)\n      roman))))", "problem": 92, "user": "4fe9d647e4b0547ebccb2472"}, {"code": "#(apply + \n (map (fn [[l r]]\n       (if (>= l r) l (- l) ))\n  (partition 2 1 (map {\\I  1 \\V\t5 \\X\t10 \\L\t50 \\C\t100 \\D\t500 \\M\t1000} (str % \\I)) )))", "problem": 92, "user": "4e6dd0f5535d5021c1a895f3"}, {"code": "(let [roman-digit {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000}]\r\n  (fn rrn [rn]\r\n    (loop [digits (map roman-digit rn)\r\n           num 0]\r\n       (cond\r\n         (empty? digits) num\r\n         (empty? (rest digits)) (+ num (first digits))\r\n         (>= (first digits) (second digits)) (recur (rest digits)\r\n                                                    (+ num (first digits)))\r\n         :else (recur (nnext digits) (+ num (- (second digits)\r\n                                               (first digits))))))))", "problem": 92, "user": "4fcc6cb3e4b0ee37620e1861"}, {"code": "#(reduce (fn [n c] (+ n\r\n  ({\\I 1\r\n    \\V 5\r\n    \\X 10\r\n    \\L 50\r\n    \\C 100\r\n    \\D 500\r\n    \\M 1000} c))) 0\r\n(reduce (fn [x v] (apply (partial clojure.string/replace x) v))\r\n % [[\"CM\" \"DCCCC\"]\r\n    [\"CD\" \"CCCC\"]\r\n    [\"XC\" \"LXXXX\"]\r\n    [\"XL\" \"XXXX\"]\r\n    [\"IX\" \"VIIII\"]\r\n    [\"IV\" \"IIII\"]]))", "problem": 92, "user": "4fca2ef0e4b0ee37620e184e"}, {"code": "(fn roman [init]\n  (loop [s init v 0]\n    (cond (empty? s) v\n          (= (first s) \\M) (recur (rest s) (+ v 1000))\n          (= (first s) \\D) (recur (rest s) (+ v 500))\n          (= (take 2 s) [\\C \\M]) (recur (drop 2 s) (+ v 900))\n          (= (take 2 s) [\\C \\D]) (recur (drop 2 s) (+ v 400))\n          (= (first s) \\C) (recur (rest s) (+ v 100))\n          (= (first s) \\L) (recur (rest s) (+ v 50))\n          (= (take 2 s) [\\X \\C]) (recur (drop 2 s) (+ v 90))\n          (= (take 2 s) [\\X \\L]) (recur (drop 2 s) (+ v 40))\n          (= (first s) \\X) (recur (rest s) (+ v 10))\n          (= (first s) \\V) (recur (rest s) (+ v 5))\n          (= (take 2 s) [\\I \\X]) (recur (drop 2 s) (+ v 9))\n          (= (take 2 s) [\\I \\V]) (recur (drop 2 s) (+ v 4))\n          (= (first s) \\I) (recur (rest s) (+ v 1))\n          true (println \"ARGH\" s v))))", "problem": 92, "user": "4fe8aef4e4b07c9f6fd12c6c"}, {"code": "(fn convert [roman]\n  (let [m [[\"IV\" 4  ]\n           [\"IX\" 9  ]\n           [\"XL\" 40 ]\n           [\"XC\" 90 ]\n           [\"CD\" 400]\n           [\"CM\" 900]\n           [\"V\" 5   ]\n           [\"X\" 10  ]\n           [\"L\" 50  ]\n           [\"C\" 100 ]\n           [\"D\" 500 ]\n           [\"M\" 1000]]]\n    \n    (count (reduce (fn [replaced [key val]]\n              (clojure.string/replace replaced key (apply str (repeat val \"I\"))))\n            roman m))))", "problem": 92, "user": "4fefd624e4b0678c553fc31b"}, {"code": "#(let [lv (fn[l] (get {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000} l 0))]\n    (loop [ds (seq %) r 0]\n      (if (not (seq ds)) r\n        (let [[a b & _] ds va (lv a) vb (lv b) op (if (> vb va) - +)] \n          (recur (rest ds) (op r va))))))", "problem": 92, "user": "4dbd2aa3535d020aff1edf40"}, {"code": "(fn [n]\r\n  (let [rn {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]\r\n    (loop [acc 0, \r\n           [x & xs :as c]\r\n             (partition-by identity (map rn n)),\r\n           p [0]]\r\n      (if (empty? c) \r\n          (+ (apply + p) acc)\r\n          (if (< (first p) (first x))\r\n              (recur (- acc (apply + p)) xs x)\r\n              (recur (+ acc (apply + p)) xs x))))))", "problem": 92, "user": "4fb37882e4b081705acca2a0"}, {"code": "(fn roman \r\n  ([n] (roman (str n) 10000)) \r\n  ([s ld]\r\n    (if (empty? s)\r\n      0\r\n      (let [[c & r] s\r\n            d ({\"M\" 1000, \"D\" 500, \"C\" 100, \"L\" 50, \"X\" 10, \"V\" 5, \"I\" 1} (str c))] \r\n          (+ d (roman r d) (if (< ld d) (- 0 ld ld) 0) )))))", "problem": 92, "user": "4feada56e4b0140c20fb9c11"}, {"code": "(fn [r]\n  (let\n    [v\n      {\\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1}\n     values (map v r)]\n    (loop [curr (first values)\n           rst (rest (seq values))\n           sum 0]\n      (if (seq rst)\n        (if (>= curr (first rst))\n          (recur (first rst) (rest rst) (+ sum curr))\n          (recur (first rst) (rest rst) (- sum curr)))\n        (+ curr sum)))))", "problem": 92, "user": "4f28c979e4b0d6649770a01a"}, {"code": "#(:c (reduce (fn [a c]\n            (if (> (:l a) c)\n              {:l (:l a) :c (- (:c a) c)}\n              {:l c :c (+ (:c a) c)}))\n          {:l 0 :c 0}\n          (map {\\D 500 \\C 100 \\I 1 \\L 50 \\M 1000 \\V 5 \\X 10} (reverse %))))", "problem": 92, "user": "4db016af838c48654951d9b9"}, {"code": "(fn fromroman [s]\n  (let [m {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000}]\n    ((fn f [[h & t] a]\n       (if (empty? t) (+ a (m h))\n           (if (>= (m h) (m (first t)))\n             (f t (+ a (m h)))\n             (f t (- a (m h))))))\n     s 0)))", "problem": 92, "user": "4ff304f4e4b0678c553fc343"}, {"code": "(fn f [s]\n  (let [m {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]\n        ((reduce (fn [[t p] i] \n                   (if (< (get m i) (get m p))\n                    [(- t (get m i)) i]\n                    [(+ t (get m i)) i]))\n                [0 \\I]\n                (reverse s)) 0)))", "problem": 92, "user": "4ff4c9dae4b0678c553fc360"}, {"code": "(fn [st]\n  (let [mp {\\M 1000, \\D 500, \\C 100, \\L 50,\n              \\X 10, \\V 5, \\I 1}]\n    (letfn [(roman [lis]\n              (cond\n                (empty? lis) 0\n                (empty? (rest lis)) (first lis)\n                (< (first lis) (second lis))\n                   (+ (- (second lis) (first lis))\n                      (roman (drop 2 lis)))\n                :else (+ (first lis)\n                         (roman (rest lis)))))]\n      (roman (map (partial get mp) (seq st))))))", "problem": 92, "user": "4fe87e56e4b07c9f6fd12c40"}, {"code": "(fn [r]\n        (let [v (zipmap [\\I \\V \\X \\L \\C \\D \\M] [1 5 10 50 100 500 1000])]\n          (apply + (map #(if (< (v %) (v %2)) (- (v %)) (v %)) r  (rest (str r \\I))))))", "problem": 92, "user": "4e57d1e2535d8a8b8723a289"}, {"code": "(fn from-roman [roman]\n  (let [replacements [[#\"CM\" \"CCCCCCCCC\"] [#\"CD\" \"CCCC\"] [#\"XC\" \"XXXXXXXXX\"] [#\"XL\" \"XXXX\"] [#\"IX\" \"IIIIIIIII\"] [#\"IV\" \"IIII\"]]\n        simplify (reduce (fn [acc [pattern replacement]] (clojure.string/replace acc pattern replacement)) roman replacements)\n        numbers {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500 \\M 1000}]\n    (reduce + (map numbers simplify))))", "problem": 92, "user": "5003deb9e4b0678c553fc445"}, {"code": "(fn [rom-str]\n  (let [alphabet {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]\n    ((fn count-rom [[v1 & [v2 & _ :as vs] :as rom-ls]]\n       (cond (= 1 (count rom-ls)) v1\n             (>= v1 v2) (+ (first rom-ls) (count-rom vs))\n             :else (- (count-rom vs) v1))) \n      (map alphabet rom-str))))", "problem": 92, "user": "5003ee7de4b0678c553fc446"}, {"code": "(letfn\n  [(roman-val [str]\n     ({\"M\" 1000, \"CM\" 900, \"D\" 500, \"XC\" 90,\n       \"C\" 100, \"XL\" 40, \"L\" 50, \"X\" 10, \"IX\" 9, \"V\" 5,\n       \"IV\" 4, \"I\" 1} str))]\n  #(reduce + (map roman-val (re-seq #\"M|CM|D|XC|C|XL|L|IX|X|V|IV|I\" %))))", "problem": 92, "user": "5002b6e5e4b0678c553fc42c"}, {"code": ";; Since the problem says we can assume the input is well-formed and\n;; follows the subtractive principle, we don't need to verify that.\n\n;; Convert the string of letters into a sequence of their numeric values.\n\n;; Then for each pair of values [a b], treat the first as value -a if\n;; a < b, otherwise it is worth a.  Append a 0 to the end as a method\n;; to ensure that (partition 2 1 sequence) will include the final\n;; digit value as the first in a pair, and such that a > b.  Add up\n;; the values.\n\n(fn [s]\n  (apply +\n         (map (fn [[a b]] (if (< a b) (- a) a))\n              (partition 2 1\n                         (-> (map #({\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000} %) s)\n                             vec\n                             (conj 0))))))", "problem": 92, "user": "500d8c49e4b07ccb9a7ddb00"}, {"code": "(fn [str] (let [n {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}\n                 [v & more] (map n (seq str))\n                 vals (reduce #(if (< (first %) %2)\n                                 (conj (rest %) (- %2 (first %)))\n                                 (conj % %2))\n                              (list v) more)]\n            (reduce + vals)))", "problem": 92, "user": "4fdec88fe4b05e33b9224f8e"}, {"code": "(fn roman-value [roman-string]\n  (letfn [(numeral-to-value [char]\n            (get {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000} char))\n          (roman-value-acc [acc nums]\n            (if (empty? nums)\n              acc\n              (let [subtract-part (when (some (partial < (first nums)) (rest nums))\n                                    (take-while (partial >= (first nums)) nums))]\n                (if (empty? subtract-part)\n                  (roman-value-acc (+ (first nums) acc) (rest nums))\n                  (roman-value-acc (- acc (roman-value-acc 0 subtract-part))\n                                   (drop (count subtract-part) nums))))))]\n    (roman-value-acc 0 (map numeral-to-value roman-string))))", "problem": 92, "user": "4ff355a1e4b0678c553fc34d"}, {"code": "(fn [n]\r\n  (let [f first\r\n        d count\r\n        v [[\"M\" 1000]\r\n           [\"CM\" 900]\r\n           [\"D\"  500]\r\n           [\"C\"  100]\r\n           [\"XC\"  90]\r\n           [\"XL\"  40]\r\n           [\"X\"   10]\r\n           [\"IX\"   9]\r\n           [\"V\"    5]\r\n           [\"IV\"   4]\r\n           [\"I\"    1]]]\r\n    (loop [r 0 c n]\r\n      (if (empty? c)\r\n        r\r\n        (let [[k v] (f (filter #(if (= (seq (f %)) (take (d (f %)) c)) %) v))]\r\n                    (recur (+ r v) (drop (d k) c)))))))", "problem": 92, "user": "500d1db4e4b05f7c30cfa69f"}, {"code": "(fn [s] (let [v {\"IV\" 4, \"IX\" 9, \"XL\" 40, \"XC\" 90, \"CD\" 500, \"CM\" 900,\r\n                   \"M\" 1000, \"D\" 500, \"C\" 100, \"L\" 50, \"X\" 10, \"V\" 5, \"I\" 1}]\r\n            (reduce + (map v (re-seq #\"IV|IX|XL|XC|CD|CM|M|D|C|L|X|V|I\" s)))))", "problem": 92, "user": "4fe900a6e4b0547ebccb243a"}, {"code": "(fn [s]\n  (loop [roman (reverse (seq s)), res-d 0, prev 0]\n    (if (nil? roman)\n      res-d\n      (let [[rd & rst] roman, \n            dd ({\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000} rd)]\n        (recur rst \n               (if (< dd prev) (- res-d dd) (+ res-d dd)) \n               dd))\n      )))", "problem": 92, "user": "4dca8b6d535d5973398f9288"}, {"code": "(fn [s]\n  (let [rom {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000}]\n       (apply + (remove nil? (reduce (fn [[r l] x] \n                          (let [n (rom x)]\n                               (cond (nil? l) [r n]\n                                     (> n l) [(+ r (- n l)) nil]\n                                     :else [(+ r l) n])))\n                   [0 nil] s)))))", "problem": 92, "user": "4f05ea25535dcb61093f6c02"}, {"code": "(fn roman->n [numeral]\n  (let [numeral (vec numeral)\n        convert {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]\n    (+ (reduce (fn [n [a b]]\n                 (if (>= (convert a) (convert b))\n                   (+ n (convert a))\n                   (- n (convert a))))\n               0 (partition 2 1 numeral))\n       (convert (last numeral)))))", "problem": 92, "user": "4ed2a31c535d44c135fd68db"}, {"code": "(fn [roman]\n  (let [d2r (sorted-map-by > 1000 \"M\" 900 \"CM\" 500 \"D\" 400 \"CD\" 100 \"C\" 90 \"XC\" 50 \"L\" 40 \"XL\" 10 \"X\" 9 \"IX\" 5 \"V\" 4 \"IV\" 1 \"I\")]\n    (loop [rom roman\n           n 0]\n      (if (empty? rom) n\n        (let [[d r] (some #(when (.startsWith rom (val %)) %) d2r)]\n          (recur (apply str (drop (count r) rom)) (+ n d)))))))", "problem": 92, "user": "500900dee4b0144d4f561e42"}, {"code": "#(reduce + (map {\"M\"  1000\n                 \"CM\"  900\n                 \"D\"   500\n                 \"CD\"  400\n                 \"C\"   100\n                 \"XC\"   90\n                 \"L\"    50\n                 \"XL\"   40\n                 \"X\"    10\n                 \"IX\"    9\n                 \"V\"     5\n                 \"IV\"    4\n                 \"I\"     1}\n                (re-seq #\"M|CM|D|CD|C|XC|L|XL|X|IX|V|IV|I\" %)))", "problem": 92, "user": "4ff9d4e5e4b0678c553fc3b0"}, {"code": "(fn roman->int\n  [numeral]\n  (let [mappings (sorted-map 1 \"I\"   4 \"IV\"   5 \"V\"   9 \"IX\"\n                             10 \"X\"  40 \"XL\"  50 \"L\"  90 \"XC\"\n                             100 \"C\" 400 \"CD\" 500 \"D\" 900 \"CM\"\n                             1000 \"M\")\n        numeral-mappings (into {} (map (comp vec reverse) mappings))]\n    (reduce + (:result (reduce\n                        (fn [acc [n num]]\n                          (let [len (count num)\n                                [result left] (split-with #{(seq num)} (partition-all len (:left acc)))]\n                            {:left (apply str (flatten left))\n                             :result (concat (:result acc) (map (comp numeral-mappings (partial apply str)) result))}))\n                        {:left numeral\n                         :result []}\n                        (reverse mappings))))))", "problem": 92, "user": "4dc0ff08535d020aff1edf84"}, {"code": "(fn [w]\n  (loop [[v1 v2 & more] \n           (map {\\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1} w)\n         acc 0]\n    (cond\n      (not v1) acc\n      (not v2) (+ acc v1)\n      (< v1 v2) (recur more (+ acc (- v2 v1)))\n      :else (recur (cons v2 more) (+ acc v1)))))", "problem": 92, "user": "4db1b3951254ad5b4805fa6f"}, {"code": "(fn [s]\n  (let [nums (map {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000} s)]\n    (loop [f (first nums) r (rest nums) sum 0]\n      (let [s (if (< f (first r))\n                  (- sum f)\n                  (+ sum f))\n            [fst & rst] r]\n        (if (empty? rst)\n            (+ s fst)\n            (recur fst rst s))))))", "problem": 92, "user": "50166470e4b052339a490e76"}, {"code": "#(loop [r 0 n (map (zipmap \"IVXLCDM\" [1 5 10 50 100 500 1000]) %)]\r\n    (let [a (first n) b (fnext n)]\r\n      (cond\r\n         (nil? a) r\r\n         (nil? b) (+ r a)\r\n         :else (if (< a b) (recur (+ r (- b a)) (drop 2 n))\r\n                           (recur (+ r a)       (next n))))))", "problem": 92, "user": "50336c6be4b0c6c1199c710f"}, {"code": "(fn [R]\n  (let [n (map {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000} R)]\n    (reduce + (map-indexed (fn [i x] (if (some #(> % x) (drop (inc i) n)) (- x) x)) n))))", "problem": 92, "user": "5028cd0fe4b01614d1633ffc"}, {"code": "(fn [s]\r\n  (let [roman-values {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000}]\r\n    (apply +\r\n      (map #(let [[v n] %] (if (or (nil? n) (>= v n)) v (- v)))\r\n        (partition-all 2 1 (map roman-values s))))))", "problem": 92, "user": "4e6e2ac4535d5021c1a895ff"}, {"code": "(fn read-roman [s]\n  (let [numerals {\\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1}\n        nums (partition 2 1 (concat (map numerals s) [0]))]\n    (reduce (fn [sum [a b]] ((if (< a b) - +) sum a)) 0 nums)))", "problem": 92, "user": "5032b066e4b00c0952a257ea"}, {"code": "(fn p92 [s]\n  (let [value {\\M 1000, \\D 500, \\C 100, \\L 50, \\X 10, \\V 5, \\I 1}]\n    (letfn [(evaluate [[c1 c2]]              \n              (if (> c2 c1) (- c1) c1))]\n     (reduce + (map evaluate (map list (map value s) (concat (map value (rest s)) [0])))))))", "problem": 92, "user": "4e8338d6535db62dc21a62d3"}, {"code": "(fn roman- [string]\n  ^{:doc \"92. Write a function to parse a Roman-numeral string and                                                                                                     \n  return the number it represents.\"}\n  (loop [[x & xs] (map {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000} (reverse string))\n         mx 0\n         acc 0]\n    (if-not x\n      acc\n      (recur xs (max mx x) (if (<= mx x) (+ acc x) (- acc x))))))", "problem": 92, "user": "4e5eb843535d8a8b8723a2d4"}, {"code": "(fn [s]\n    (let [v {\\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1}]\n      (let [n (map v s)] \n        (apply +\n        (map (fn [[x y]] (if (< x y) (- x) x))\n        (map #(vector % %2) n (concat (rest n) [0])))))))", "problem": 92, "user": "503917a0e4b088a6a14ca763"}, {"code": "(fn f [x]\r\n  (let [nums {\\I 1\r\n              \\V 5\r\n              \\X 10\r\n              \\L 50\r\n              \\C 100\r\n              \\D 500\r\n              \\M 1000}\r\n        has-greater? (fn [[x & xs]]\r\n                      (when (not (empty? xs))\r\n                      (< x\r\n                         (apply max xs))))\r\n        to-add (fn [ls]\r\n                 (if (has-greater? ls) (- 0 (first ls))\r\n                   (first ls)))\r\n        ]\r\n    (loop [t 0 ls (map nums x)]\r\n      (if (empty? ls) t\r\n        (recur (+ t (to-add ls))\r\n               (rest ls))))))", "problem": 92, "user": "502a9fdee4b095a7adb898b4"}, {"code": "(fn [r] (let [vs {\\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1 \\Z 0}]\n            (apply + (map (fn [[f s]] (if (< f s) (- f) f))\n                          (partition 2 1 (map vs (str r \"Z\")))))))", "problem": 92, "user": "4efd8b67535de96065cf5085"}, {"code": "(fn [s]\n  (let [n {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000}\n        f (fn [[x y]] ((if (< x y) - +) x))]\n    (reduce #(+ % (f %2)) \n            (n (last s)) \n            (partition 2 1 (map n s)))))", "problem": 92, "user": "4f58d92fe4b0a7574ea71858"}, {"code": "(fn parse-roman [s]\n  (let \n    [m {\\I 1\n        \\V 5\n        \\X 10\n        \\L 50\n        \\C 100\n        \\D 500\n        \\M 1000}\n    p (map #(m %) (seq s))]\n    (apply + \n      (map-indexed (fn [idx itm]\n        (cond\n          (= (dec (count p)) idx) itm\n          (< itm (nth p (inc idx))) (* -1 itm)\n          :else itm)) p))))", "problem": 92, "user": "501c1492e4b086d93747d180"}, {"code": "(fn [s] (let [m (zipmap \r\n                 [\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"]\r\n                 [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1])]\r\n          (loop [s s ans 0]\r\n            (if (empty? s) ans\r\n              (let [x (first (filter #(.startsWith s %) [\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"]))]\r\n                (recur (apply str (drop (count x) s)) (+ ans (m x))))))))", "problem": 92, "user": "503354c3e4b0c6c1199c710c"}, {"code": "(fn rom2 [letters]\n  (reduce +\n          (map (fn [[a b]] (if (>= a b) a (- a)))\n               (partition 2 1\n                          (-> (map #({\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000} %)\n                                   letters)\n                              vec\n                              (conj 0))))))", "problem": 92, "user": "502a4fdfe4b09dd42f6f3644"}, {"code": "(fn [rom]\r\n  (let [roman {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}\r\n        s (map roman (reverse (seq rom)))]\r\n    (second \r\n      (reduce (fn [[prev sum] n]\r\n                [n (+ sum (if (>= n prev) n (- n)))])\r\n              [0 0]\r\n              s))))", "problem": 92, "user": "4dc97aec535d5973398f9284"}, {"code": "(fn [init]\n  (let [numerals {\\M 1000\n                  \\D 500\n                  \\C 100\n                  \\L 50\n                  \\X 10\n                  \\V 5\n                  \\I 1}]\n    (first\n     (reduce\n      (fn [[acc last-value] val]\n        (let [this-value (get numerals val)\n              to-add (if (> this-value last-value)\n                       (- this-value (* 2 last-value)) ;; times 2 to \"undo\" the previous addition                       \n                       this-value)]\n          [(+ acc to-add) this-value]))\n      [0 0]\n      init))))", "problem": 92, "user": "5014754de4b094324338f8e5"}, {"code": "(fn r\n  ([s] (r s 1001 0))\n  ([s p n]\n  (if (empty? s) n\n    (let [x ({\\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1}\n               (first s))]\n      (r (rest s) x \n        (+ n x (if (> x p) (* 2 (- p)) 0)))))))", "problem": 92, "user": "50361b6be4b0fbe0a74d26be"}, {"code": "(fn [s] \r\n  (let [cvt (fn [[x y]]\r\n              (cond (and (not= x \\C) (= y \\M)) 1000\r\n                    (and (= x \\C)    (= y \\M)) 800\r\n                    (and (not= x \\C) (= y \\D)) 500\r\n                    (and (= x \\C)    (= y \\D)) 300\r\n                    (and (not= x \\X) (= y \\C)) 100\r\n                    (and (= x \\X)    (= y \\C)) 80\r\n                    (and (not= x \\X) (= y \\L)) 50\r\n                    (and (= x \\X)    (= y \\L)) 30\r\n                    (and (not= x \\I) (= y \\X)) 10\r\n                    (and (= x \\I)    (= y \\X)) 8\r\n                    (and (not= x \\I) (= y \\V)) 5\r\n                    (and (= x \\I)    (= y \\V)) 3\r\n                    (= y \\I) 1                    ))]\r\n  (->> (partition 2 1 (cons nil s))\r\n       (map cvt)\r\n       (apply +))))", "problem": 92, "user": "50435689e4b034ff00315d21"}, {"code": "(fn [s] (let [m {\\O 0, \\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000}]\n           (apply + (map #(if (>= (first %) (second %)) (first %) (- (first %)))\n                 (partition 2 1 (map m (concat s \"O\")))))))", "problem": 92, "user": "50563ae2e4b0ce54f56f0405"}, {"code": "(fn romanNumeral [n] \n  (let [rnumvals (zipmap [\\M \\D \\C \\L \\X \\V \\I] [1000 500 100 50 10 5 1])]\n\t(letfn [(cnr [s] \n\t(if (empty? s) 0\n\t(reduce (fn [x y] (- x y)) (reverse (map (fn [z] (rnumvals z)) s)))))]\n\t(loop [nums (rest n) current (list (first n)) val 0]\n\t      (cond (empty? nums) \n\t\t    (+ val (cnr current))\n\t\t    (> (rnumvals (first nums)) (rnumvals (last current)))\n\t\t    (recur (rest nums) (concat current (list (first nums))) val)\n\t\t    :else\n\t\t    (recur (rest nums) (list (first nums)) (+ val (cnr current)))\t\n\t\t)\n\t)\n\t)\n\t)\n)", "problem": 92, "user": "50588af1e4b06522596eba7d"}, {"code": "(fn __ [roman]\n  (let [table\n    \t\t{\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000 \\Z 0}\n        twos\n        \t(partition 2 (map #(table %) (flatten (partition 2 1 (str roman \\Z)))))]\n   (reduce + \n           (map #(if (< (first %) (second %))\n           \t\t\t(* -1 (first %))\n           \t\t\t(first %)) twos))))", "problem": 92, "user": "4fa719c0e4b081705acca1bf"}, {"code": "(fn [s]\n  (let [values {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]\n    (loop [[d & digits] (reverse (map values s)) r 0 max-right 0]\n      (if (nil? d)\n        r\n        (if (< d max-right)\n            (recur digits (- r d) max-right)\n            (recur digits (+ r d) d))))))", "problem": 92, "user": "503e7f06e4b06c4e0e1fa268"}, {"code": "(fn [rn]\n  (let [m {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000}]\n    ((fn to-num [r [x & xs]]\n      (if (empty? xs)\n          (+ r (m x))\n          (if (< (m x) (m (first xs)))\n              (recur (- r (m x)) xs)\n              (recur (+ r (m x)) xs)))) 0 (seq rn))))", "problem": 92, "user": "5063fe48e4b075d771da6f9e"}, {"code": "(fn [s]\n  (let [rom {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000}]\n       (apply + (remove nil? (reduce (fn [[r l] x] \n                          (let [n (rom x)]\n                               (cond (nil? l) [r n]\n                                     (> n l) [(+ r (- n l)) nil]\n                                     :else [(+ r l) n])))\n                                     [0 nil] s)))))", "problem": 92, "user": "50705072e4b07bd6ad9b9f27"}, {"code": "(fn f [s]\n  (first\n   (->> s\n        (map {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000})\n        (partition-by identity)\n        reverse\n        (reduce (fn [[acc last] [n :as x]]\n                  [(apply (if (> last n) - +) acc x) n])\n                [0 0]))))", "problem": 92, "user": "507056b8e4b07bd6ad9b9f29"}, {"code": "(fn [s]\n  ;; reverse a list of translated romans \"XIV\" -> (10 1 5) -> (5 1 10)\n  (let [rrs (reverse (map #(get {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000} %) s))]\n   ;; loop-recur \n   (loop [coll rrs n (first coll)]\n     (let [c (count coll) fc (first coll) sc (second coll)\n          ;; if first number is > second number, subtract second number from total\n          ;;   else, add second number to total\n          ;;  (5 1 10) -->  5 > 1 -->  5 - 1 = 4\n          ;;  on recur...\n          ;;     (1 10) --> 1 <= 10 --> 4 + 10 = 14\n           next-add-or-sub (if (> fc sc) (- n sc) (+ n sc))]\n      (case c\n       0  0\n       1  n\n       2  next-add-or-sub\n        ;; default \n       (recur (drop 1 coll) next-add-or-sub ))))))", "problem": 92, "user": "5078dedae4b08327cd804a5d"}, {"code": "(fn [coll]\n  (let [coll (map #({\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000} %) (seq coll))]\n    (apply +\n    (loop [[x y :as w] coll acc []]\n      (if-not x\n        acc\n        (recur\n          (rest w) \n          (conj acc \n                (if y (if (< x y) (- x) x)\n                    x))))))))", "problem": 92, "user": "4fdb02aae4b05e33b9224f56"}, {"code": "(let [r {\n  \\M 1000\n  \\D 500\n  \\C 100\n  \\L 50\n  \\X 10\n  \\V 5\n  \\I 1}]\n  #((fn c\n    [R l s]\n      (if (empty? R)\n        s\n        (if (< (r (first R)) l)\n          (c\n            (rest R)\n            (r (first R))\n            (- s(r (first R))))\n          (c\n            (rest R)\n            (r (first R))\n            (+ s (r (first R)))))))\n    (reverse %) 0 0))", "problem": 92, "user": "4f42ae16e4b0d7d3c9f3fd09"}, {"code": "(fn [s]\n  (let [m {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]\n    (\n      (reduce\n        #(let [n (m %2) l (%1 :last) s (%1 :sum)]\n          (if (and (not (nil? l)) (< n l))\n            (assoc %1 :sum (- s n) :last nil)\n            (assoc %1 :sum (+ s n) :last n)\n          )\n        )\n        {:sum 0 :last nil}\n        (reverse s)\n      ) :sum\n    )\n  )\n)", "problem": 92, "user": "507eddf4e4b06ce648bcdbfa"}, {"code": "(fn [rom]\n  (let [abc [[\"CM\" 900] [\"CD\" 400], [\"XC\" 90], [\"XL\" 40], [\"IX\" 9], [\"IV\" 4],\n             [\"M\" 1000], [\"D\" 500], [\"C\" 100], [\"L\" 50], [\"X\" 10], [\"V\" 5], [\"I\" 1]]\n        starts-with? (fn [s t]\n            (and\n              (>= (count s) (count t))\n              (= (subs s 0 (count t)) t)))]\n    (loop [rom rom, a 0]\n      (if (empty? rom)\n        a\n        (let [[r v] (some\n                      (fn [[rl _ :as rp]]\n                       (and\n                         (starts-with? rom rl)\n                         rp))\n                      abc)]\n          (recur (apply str (drop (count r) rom)) (+ a v)))))))", "problem": 92, "user": "504c8165e4b09724c857af31"}, {"code": "(fn roman-numerals [s]\n  (let [dict {\"I\" 1   \"IV\" 4   \"V\" 5   \"IX\" 9\n              \"X\" 10  \"XL\" 40  \"L\" 50  \"XC\" 90\n              \"C\" 100 \"CD\" 400 \"D\" 500 \"CM\" 900\n              \"M\" 1000}]\n    (->> s\n         (re-seq #\"IV|IX|XL|XC|CD|CM|[IVXLCDM]\")\n         (map dict)\n         (apply +))))", "problem": 92, "user": "50586354e4b06522596eba78"}, {"code": "(fn rr[s]                                                                                                                                                                                  \n  (reduce                                                                                                                                                                                    \n   (fn[sum [l r]] (if (> l r) (+ sum l) (- sum l))) 0                                                                                                                                        \n   (partition 2 1                                                                                                                                                                            \n    (map #(apply + %)                                                                                                                                                                        \n         (concat                                                                                                                                                                             \n          (partition-by identity (map (zipmap \"IVXLCDM\" [1 5 10 50 100 500 1000]) s))                                                                                                        \n          [[0]]                                                                                                                                                                              \n          )))))", "problem": 92, "user": "507c7c8be4b0b083f3ff82ef"}, {"code": "(fn [s]\n  (let [rnum {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]\n    (first\n     (reduce (fn [[s c] n]\n               [(if (< c n) (+ s n (* -2 c)) (+ s n)) n])\n             [0 1001] (map rnum s)))))", "problem": 92, "user": "5095f761e4b0ba05ca7aebfd"}, {"code": "(fn [rom]\n  (let [vals (map {\\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1 \\0 0} (str rom 0))]\n    (reduce \n      (fn [s [cur nxt]] \n        ((if (< cur nxt) - +) s cur))\n      0 \n      (map vector vals (rest vals)))))", "problem": 92, "user": "50901b2ee4b0ea685a20f774"}, {"code": "(fn [r]\n  (->> (reverse r)\n       (replace (zipmap \"MDCLXVI\" [1000 500 100 50 10 5 1]))\n       (partition-by identity)\n       (map (partial apply +))\n       (reduce #(if (< %1 %2) (+ %1 %2) (- %1 %2)))))", "problem": 92, "user": "4e58c019535d8a8b8723a297"}, {"code": "#(loop [x %, r 0]\n    (if \n      (empty? x)\n      r\n      (let [y (keyword (apply str (take 2 x))), z (keyword (str (first x))), n {:CM 900, :CD 400, :XC 90, :XL 40, :IX 9, :IV 4, :M 1000, :D 500, :C 100, :L 50, :X 10, :V 5, :I 1}]\n        (if-let [v (n y)] \n          (recur (drop 2 x) (+ v r))\n          (recur (drop 1 x) (+ (n z) r))))))", "problem": 92, "user": "4eabb245535d7eef30807319"}, {"code": "(fn [rs]\n  (let [r->n {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}\n        [k & others] (->> rs, reverse, (map r->n))\n        answers (reduce\n                  (fn [[acc m] i]\n                    (if (< i m)\n                      [(- acc i) m]\n                      [(+ acc i) i]))\n                  [k k]\n                  others)]\n    (first answers)))", "problem": 92, "user": "506ab9bae4b05d3b7762c74c"}, {"code": "(fn to-arabic [rom]\n  (loop [acc 0 [fst & rst] (map {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100 \\D 500, \\M 1000} rom)]\n    (if (zero? (count rst)) \n      (+ acc fst)\n      (let [snd (first rst)]\n        (if (>= fst snd) \n          (recur (+ acc fst) rst)\n          (recur (- acc fst) rst))))))", "problem": 92, "user": "506b8242e4b0eda3100c090a"}, {"code": "(fn r [s]\n  (let [m (zipmap \"IVXLCDM\" [1 5 10 50 100 500 1000])]\n    (cond (empty? s) 0\n          (= (count s) 1) (m (first s))\n          :else (+ ((if (>= (m (first s)) (m (second s))) + -) (m (first s))) (r (rest s))))))", "problem": 92, "user": "5054c7e1e4b0b1b9d1860eb2"}, {"code": "(fn [roman-numerals]\n  (let [f #(or ({\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000} %) 0)\n        coll (reverse (map f (.toUpperCase roman-numerals)))]\n    (loop [curr (first coll)\n           [fst & rst] (rest coll)\n           prev 0\n           acc 0]\n      (if (not curr)\n        (+ prev acc)\n        (if (< curr prev)\n          (recur fst rst 0 (+ acc (- prev curr)))\n          (recur fst rst curr (+ acc prev)))))))", "problem": 92, "user": "504f57c7e4b0a02f9cffde71"}, {"code": "(fn f ([src pre temp] \n  (let [table {nil 0, \\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000}]\n    (cond (empty? src) (+ temp (table pre))\n          (nil? pre) (recur (rest src) (first src) temp)\n          (< (table pre) (table (first src))) (recur (rest src) nil (+ temp (- (table (first src)) (table pre))))\n          :else (recur (rest src) (first src) (+ temp (table pre))))))\n    ([src]\n      (f src nil 0)))", "problem": 92, "user": "507fbd77e4b089ade05efbd3"}, {"code": "(fn [w] (letfn [(r [n] (map (fn [x] (let [v ((apply assoc {} (interleave \"IVXLCDM\" [1 5 10 50 100 500 1000])) (first x))] [v (* v (count x))])) (partition-by identity n)))] (fnext (reduce (fn [[a t] [v m]] [v (if (> a v) (- t m) (+ t m))]) [0 0] (-> w r reverse)))))", "problem": 92, "user": "4f8c5f4fe4b02e764a0a5198"}, {"code": "(fn [rn]\n (let [v [[#\"IV\" \"1\"] [#\"IX\" \"2\"] [#\"XL\" \"3\"] [#\"XC\" \"4\"] [#\"CD\" \"5\"] [#\"CM\" \"6\"]]\n       m {\"1\" 4 \"2\" 9 \"3\" 40 \"4\" 90 \"5\" 400 \"6\" 900 \"I\" 1 \"V\" 5 \"X\" 10 \"L\" 50 \"C\" 100 \"D\" 500 \"M\" 1000}]\n  (apply + (map #(m (str %)) (reduce (fn [a [o n]] (clojure.string/replace a o n)) rn v)))))", "problem": 92, "user": "5097b556e4b00ad8bab4e970"}, {"code": "(fn deromanize\n           [s]\n           (let [digits {\\M 1000\n                         \\D 500\n                         \\C 100\n                         \\L 50\n                         \\X 10\n                         \\V 5\n                         \\I 1}]\n             (apply + (loop [in-digits (map digits (seq s))\n                     procced-digits []]\n                (if (empty? in-digits)\n                  procced-digits\n                  (if (> (count in-digits) 1)\n                    (let [[fd sd & restd] in-digits]\n                      (if (< fd sd)\n                        (recur restd (conj procced-digits (- sd fd)))\n                        (recur (rest in-digits) (conj procced-digits fd))))\n                    (recur (rest in-digits) (conj procced-digits (first in-digits)))))))))", "problem": 92, "user": "4dbb0f2d535d1e037afb21b1"}, {"code": "#((fn rval [[v & r]]\n  (let [rtod {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]\n    (if (empty? r)\n      (rtod v)\n      (+\n        (* \n          (if (>= (rtod v) (rtod (first r))) 1 -1)\n          (rtod v))\n        (rval r))))) (seq %))", "problem": 92, "user": "5034b0e1e4b062bc5d7ae167"}, {"code": "#(apply +\n  (map (fn [[a b]] (if (> b a) (- a) a))\n    (partition 2 1 (repeat 0) \n      (map {\\M 1000 \\D 500 \\C 100 \\L \n            50 \\X 10 \\V 5 \\I 1} %))))", "problem": 92, "user": "4e96557d535dbda64a6f6b43"}, {"code": "(fn  [st]\n  (let [values {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000}]\n    (\n      (reduce \n        (fn [[sum max] value]\n          (if (< value max) \n            [(- sum value) max]  \n            [(+ sum value) value]))\n        [0 0]\n        (map #(values %) (reverse st)))\n      0)))", "problem": 92, "user": "4f4c6b21e4b03ad3f0c10c8f"}, {"code": "(fn [s]\n  (let [v-map\n    {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}\n        splits (into [] (reverse (seq s)))]\n    (loop [current splits result 0 last-char nil]\n      (if (empty? current) result\n        (recur\n          (rest current)\n          (if (and (not (nil? last-char))\n                 (< (get v-map (first current)) (get v-map last-char)))\n          (- result (get v-map (first current)))\n          (+ result (get v-map (first current))))\n          (first current))))))", "problem": 92, "user": "4dad76588e77d6ed63f12a44"}, {"code": "(fn [n]\n  (let [conv {\\I 1, \\V 5, \\X 10, \\L 50 \\C 100,\\D 500, \\M 1000}\n        go (fn [[acc prev] x]\n             (let [nxt (conv x)]\n               [(+ acc nxt (if (> nxt prev) (- (* 2 prev)) 0)) nxt]))]\n    (first (reduce go [0 1000] n))))", "problem": 92, "user": "509c03f3e4b085ae113522a8"}, {"code": "(fn rtoa [s]\n   (if (empty? s)\n        0\n        (let [\n              rn [[1000 \"M\"] [900 \"CM\"] [500 \"D\"] [400 \"CD\"] [100 \"C\"] [90 \"XC\"] [50 \"L\"] [40 \"XL\"] [10 \"X\"] [9 \"IX\"] [5 \"V\"] [4 \"IV\"] [1 \"I\"]]\n              [a r] (first (filter #(.startsWith s (second %)) rn))\n              ]\n            (+ a (rtoa (.substring s (count r))))\n        )\n    )\n)", "problem": 92, "user": "504f191ae4b0e7ad84dbc4ba"}, {"code": "(fn [s]\n               (letfn \n                 [\n                  (tocounts [l] (reverse (map { \\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000 } l)))\n                  (convert [l] ( loop [total 0 xs l] \n                                 ;(println total xs)\n                                 (if (empty? xs)\n                                   total\n                                   (let [item (first xs)\n                                         rem (rest xs)\n                                         minus (take-while #(< %1 item) rem)\n                                         remains (drop-while #(< %1 item) rem)]\n                                     (recur (- (+ total item) (convert minus)) remains)))\n                                 )\n                                 )\n                  ]\n                 (convert (tocounts s))))", "problem": 92, "user": "50956c2be4b087f34d351ab2"}, {"code": "(fn roman [num]\n  (letfn [(num-map [num]\n  (let [mapping {\\M 1000, \\D 500, \\C 100, \\L 50, \\X 10, \\V 5, \\I 1}]\n    (map mapping (apply list num))))]\n  (let [grp (num-map num)]\n  (loop [ret 0 x (first grp) coll (rest grp)]\n    (let [y (first coll)]\n      (cond\n        (nil? x) ret\n        (nil? y) (+ ret x)\n        (> y x) (recur (+ ret (- y x)) (second coll) (nnext coll))\n        :else (recur (+ ret x) (first coll) (next coll))))))))", "problem": 92, "user": "5084c43be4b0fb8f40674bfa"}, {"code": "(fn tonormal [x] (let [m {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]\r\n                     ((fn tn [n s] (if (empty? s) 0\r\n                                     (if (< (m (first s)) (m n))\r\n                                       (- (tn  (first s) (rest s) )  (m (first s)))\r\n                                       (+ (tn  (first s) (rest s)) (m (first s)))))) (last x)  (reverse (seq x)))))", "problem": 92, "user": "50646c01e4b007509339a58b"}, {"code": "(fn roman\r\n     ([i-literal] (roman 0 i-literal))\r\n     ([i-result i-literal]\r\n      (if (zero? (count i-literal))\r\n        i-result\r\n        (let [\r\n              v-map {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500 \\M 1000}\r\n              head (first i-literal)\r\n              tail (rest i-literal)\r\n              t-head (first tail)\r\n              ]\r\n          (if (and (not (nil? t-head)) (> (get v-map t-head) (get v-map head)))\r\n            (roman (+ i-result (- (get v-map t-head) (get v-map head))) (rest tail))\r\n            (roman (+ i-result (get v-map head)) tail))))))", "problem": 92, "user": "50436470e4b034ff00315d23"}, {"code": "(fn from-roman [roman]\n    (if (empty? roman)\n      0\n      (let [one-char {\"I\" 1, \"V\" 5, \"X\" 10, \"L\" 50, \"C\" 100, \"D\" 500, \"M\" 1000}\n            two-char {\"IV\"  4, \"IX\"\t9, \"XL\"\t40 \"XC\" 90 \"CD\"\t400 \"CM\"\t900}\n            r-length (count roman)\n            final-2 (apply str (drop (- r-length 2) roman))\n            final (apply str (drop (- r-length 1) roman))\n            ]\n        (if (two-char final-2)\n          (+ (two-char final-2)\n           (from-roman (apply str (take (- r-length 2) roman))))\n          (+ (one-char final)\n           (from-roman (apply str (take (- r-length 1) roman)))))\n      )))", "problem": 92, "user": "4daea889edd6309eace4d15b"}, {"code": "(fn [inp]\n  (let [mapping {\\M 1000 \\D 500 \\C 100 \\L 50\n                 \\X 10 \\V 5 \\I 1}\n        nums (map mapping inp)\n        pairs (partition-all 2 1 nums)]\n    (reduce (fn [r [x nx]]\n              (if (and nx (< x nx))\n                (- r x)\n                (+ r x)))\n      0 pairs)))", "problem": 92, "user": "4fe88f78e4b07c9f6fd12c45"}, {"code": "#(let [n {\\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1}]\n   (loop [cur (n (first %))\n          roman (next %)\n          result 0]\n     (if-not cur\n       result\n       (let [nnum (n (first roman))\n             op (if-not (< cur (or nnum 0)) + -)]\n         (recur nnum (rest roman) (op result cur))))))", "problem": 92, "user": "50052d38e4b0678c553fc45c"}, {"code": "(fn read-roman [roman]\n  (let [num-map {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000}]\n    (reduce (fn [acc [a b]]\n              (+ acc (if (>= a b) b (- b a a))))\n            0\n            (partition 2 1 (conj (map num-map roman) 0)))))", "problem": 92, "user": "50812debe4b01a93d3f38e4c"}, {"code": "(fn read-roman [st]\n  (let [roman {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]\n    (last (reduce \n           (fn [[l s] n]\n             (if(> l n) \n               (vector n (- s n))\n               (vector n (+ s n)))) [0 0] \n           (map #(roman %) (reverse st))))))", "problem": 92, "user": "50c8697ce4b00bb60fe0c53f"}, {"code": "(fn [roman-number]\n  (let [primes {\"IV\" 4 \"IX\" 9 \"XL\" 40 \"XC\" 90 \"CD\" 400 \"CM\" 900\n                \"I\" 1 \"V\" 5 \"X\" 10 \"L\" 50 \"C\" 100 \"D\" 500 \"M\" 1000}\n        primes-pattern #\"CD|CM|XC|IV|IX|XL|C|D|I|L|M|V|X\"]\n    (->> roman-number\n      (re-seq primes-pattern)\n      (map primes)\n      (apply +))))", "problem": 92, "user": "50c9e5e3e4b0a409464667d7"}, {"code": "#(let [m {\\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1 \\Z 0}]\n  (first (reduce (fn [[n l] c] [((if (< l (m c)) - +) n l) (m c)]) [0 0] (str % \\Z))))", "problem": 92, "user": "50acbd15e4b071b89ef26234"}, {"code": "(fn read-roman [r]\n (let [numerals {\\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1 \\0 0 \\T 1001}\n       s (vec (seq r))\n       f (fn [idx x]\n          (let [cur (numerals x)\n                nxt (numerals (get s (inc idx) \\0))\n                prv (numerals (get s (dec idx) \\T))]\n            (cond\n             (> nxt cur) (- nxt cur)\n             (< prv cur) 0\n             :else cur)))]\n  (apply + (map-indexed f s))))", "problem": 92, "user": "50783762e4b0fc74642bff67"}, {"code": "(fn roman-numerals\n  [iroman]\n  (let [roman {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]\n    (loop [s (map #(get roman %) (seq iroman))\n           r 0]\n      (if (= 1 (count s))\n        (+ r (first s))\n        (recur (rest s) (if (>= (first s)\n                                (second s))\n                          (+ r (first s))\n                          (- r (first s))))))))", "problem": 92, "user": "4f2942ace4b0d6649770a01e"}, {"code": "(fn rn ([x] (rn x 0))\n  ([[f s & r :as x] n] \n   (let [nums (zipmap \"IVXLCDM\" [1 5 10 50 100 500 1000])]\n   (if (empty? x) n\n     (if (and s (> (nums s) (nums f)))\n       (rn r (+ n (- (nums s) (nums f))))\n       (rn (next x) (+ n (nums f))))))))", "problem": 92, "user": "4eb2eae5535d7eef30807351"}, {"code": "(fn [s]\n           (let [m {\\C 100, \\D 500, \\I 1, \\L 50, \\M 1000, \\V 5, \\X 10}]\n                (loop [cur s res 0]\n                   (if (empty? cur)\n                       res\n                       (let [d (take 2 cur)\n                            c (= 2 (count d))\n                            [v1 v2] (if c\n                                        [(get m (nth d 0)) (get m (nth d 1))]\n                                        [(get m (nth d 0)) 0])\n                            b (< v1 v2)\n                            v (if b\n                                  (- v2 v1)\n                                  v1)\n                            ]\n                            (recur (if (and c b) \n                                       (rest (rest cur))\n                                       (rest cur))\n                                   (+ res v)))))))", "problem": 92, "user": "4f03f197535dcb61093f6b84"}, {"code": "#(let [m {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]\n   (loop [S 0 s (seq %1)]\n     (if s\n       (let [[a b & c] s\n             A (m a 0)\n             B (m b 0)]\n         (if (> B A)\n           (recur (+ S (- B A)) c)\n           (recur (+ S A) (next s))))\n       S)))", "problem": 92, "user": "4db8f6c4535d1e037afb219e"}, {"code": "(fn r2int [s]\n  (if (empty? s) 0\n      (let [f (first s)\n            f2 (first (rest s))\n            r (r2int (rest s))\n            r2 (if (< 1 (count s)) (r2int (drop 2 s)) 0)]\n        (cond (= \\M f) (+ 1000 r)\n              (= \\C f) (if (= \\M f2)\n                         (+ 900 r2)\n                         (+ 100 r))\n              (= \\D f) (+ 500 r)\n              (= \\L f) (+ 50 r)\n              (= \\X f) (cond (= \\C f2) (+ 90 r2)\n                             (= \\L f2) (+ 40 r2)\n                             :else (+ 10 r))\n              (= \\V f) (+ 5 r)\n              (= \\I f) (cond (= \\X f2) (+ 9 r2)\n                             (= \\V f2) (+ 4 r2)\n                             :else (+ 1 r))\n              :else 0))))", "problem": 92, "user": "50733b31e4b0e3170b5a869a"}, {"code": "(fn conv [s] (let [r-to-i {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]\n          (case (count s)\n            0 0\n            1 (r-to-i (first s))\n            (if (> (r-to-i (second s)) (r-to-i (first s)))\n              (+ (- (r-to-i (second s)) (r-to-i (first s))) (conv (rest (rest s))))\n              (+ (r-to-i (first s)) (conv (rest s)))))))", "problem": 92, "user": "50dfb660e4b061dbdced7228"}, {"code": "(fn __ [rtime] \n\t(letfn [\n\t ; given a string \"abc\" converts to (\"a\" \"b\" \"c\")\n\t (str-to-arr [s] (rest (clojure.string/split s #\"\")))          \n\t ; roman numeral array a to nums e.g. (\"X\" \"I\") -> (10 1)\n   (rarr-to-nums [a] (map roman-val a))          \n   ; given a letter l, return the roman value of it\n   (roman-val [l] (if-not (nil? l) ((keyword l) { :I 1 \n                                 :V 5 \n                                 :X 10\n                                 :L 50\n                                 :C 100 \n                                 :D 500 \n                                 :M 1000})))   \n  ]\n\t\t(let [\n\t\t\t; reversed number value of roman numeral as array\n      rnums (reverse (rarr-to-nums (str-to-arr rtime)))\n\t\t\t; convert array to an array where each member knows next val          \n      rnums-a (reduce #(conj % (vector (last (last %)) %2)) [] rnums)    \n\t\t\t; make a judgement if there is an increase or decrease between numbers for the \"IV\" case\n      rnums-a-delta (map #(when (first %) (> (first %) (last %))) rnums-a)        \n\t\t\t; mix the numbers so we can better see the \"IV\" cases\n      rnums-i (interleave rnums-a-delta rnums)\n      ; getting rid of true values makes it more clear where the \"IV\" cases are\n      rnums-trueless (rest (remove true? rnums-i))\n      ; get the numbers grouped together such that \"IV\" becomes (5 1) (reversed) which becomes 5-1 which becomes 4\n      rnums-clumped (partition-by false? rnums-trueless)\n\t\t\t; get rid of all booleans for just numbers\n      rnums-only (remove #(apply (partial = false) %) rnums-clumped)\n\t\t\t; convert number pairs to differences e.g. (5 1) -> 4 but (5) remains 5\n      rnums-adjust (map (fn [a] (if (> (count a) 1) (- (first a) (second a)) (first a)) ) rnums-only)\n\t\t\t; add up what we've processed down to in order to know real value of roman number string\n      rnums-sum (reduce + rnums-adjust)\n      ]\n      \t; the answer\n\t      rnums-sum\n    )\n  )\n)", "problem": 92, "user": "503f872ee4b00d1a725ff2ac"}, {"code": "(fn [r]\n  (->> (reverse (map {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000} r))\n       (partition 2 2 [0])\n       (map (fn [[a b]] ((if (> a b) - +) a b)))\n       (apply +)))", "problem": 92, "user": "50e7dd5de4b077ad597af36b"}, {"code": "#(let [sub [[\"IV\" \"IIII\"] \n             [\"IX\" \"VIIII\"] \n             [\"XL\" \"XXXX\"] \n             [\"XC\" \"LXXXX\"]\n             [\"CD\" \"CCCC\"]\n             [\"CM\" \"DCCCC\"]]\n        norm (reduce (fn [s [f t]] (clojure.string/replace s f t)) % sub)\n        val {\\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1}]\n    (reduce + (map val norm)))", "problem": 92, "user": "500aa15ee4b03d00572d2d76"}, {"code": "(fn [s]\n           (let [d {\\I 1 \\V 5\n                    \\X 10 \\L 50\n                    \\C 100 \\D 500\n                    \\M 1000}\n                   xs (map #(if (>= (d (first %))\n                                   (d (second %)))\n                                (d (first %))\n                                (- (d (first %))))\n                           (partition 2 1 s))]\n             (+ (reduce + xs) (d (last s)))))", "problem": 92, "user": "50310b8be4b05b7df5a0b84d"}, {"code": "(fn [n]\n  (reduce\n    (fn [a d]\n      (if (< (* 3 d) a) (- a d) (+ d a)))\n    (map \n     {\\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1} \n     (reverse n))))", "problem": 92, "user": "4f08b15b535dcb61093f6c40"}, {"code": "(fn [rn]\n  (let [d (map {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000} rn) ]\n     (loop [ [a & b] d, s 0]\n\t    (if (empty? b) (+ s a)\n\t\t  (recur b (if (< a (first b)) (- s a) (+ s a)))))))", "problem": 92, "user": "50d0d4c8e4b00b15ecee976a"}, {"code": "(fn roma [se]    \n    (let [rd {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}\n          sus {\"IV\" 2 \"IX\" 2 \"XL\" 20 \"XC\" 20 \"CD\" 200 \"CM\" 200}\n          amount (reduce + (map rd (seq se)))\n          s (reduce + (filter #(not (nil? %)) (map sus (for [i (range 0 (dec (count se)))]\n                                 (.substring se i (+ i 2))))))]\n      (- amount s)))", "problem": 92, "user": "50e87427e4b0ebbe794eb7e8"}, {"code": "(fn [n] \n  (let \n   [digits {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]\n   ; (identity\n    (apply +\n    (reduce \n    (fn [r n] \n      (let [d (digits n)]\n      (if (or (= (last r) 0) (>= (last r) d))\n      (concat r [d])\n      (concat (butlast r) [(- d (last r))] [0])\n      )))\n    [0] n))\n    ))", "problem": 92, "user": "50de11b2e4b061dbdced7217"}, {"code": "(fn  [num]\n  (let [valmap {\\I 1\n                \\V 5\n                \\X 10\n                \\L 50\n                \\C 100\n                \\D 500\n                \\M 1000}]\n    ((reduce\n       (fn [x y]\n         { :last (valmap y)\n           :result\n             ((if (< (valmap y)\n                     (x :last))\n                -\n                +)\n               (x :result)\n               (valmap y))})\n       {:last 0 :result 0}\n       (reverse num)) :result)))", "problem": 92, "user": "50c99e3ee4b0bed41a122997"}, {"code": "(fn [s]\n  (let [roman {\"M\" 1000 \"CM\" 900 \"D\" 500 \"CD\" 400 \"C\" 100 \"XC\" 90 \"L\" 50 \"XL\" 40 \"X\" 10 \"IX\" 9 \"V\" 5 \"IV\" 4 \"I\" 1}]\n    (reduce + (map roman (re-seq #\"CM|CD|XC|XL|IX|IV|[MDCLXVI]\" s)))))", "problem": 92, "user": "50ef9a7ae4b0bdaecbb47d9e"}, {"code": "(fn [m a s]\n  (if (empty? s) a\n    (let [ss (fn [s e] (.substring s 0 (min e (.length s))))\n          k (if (m (ss s 2)) (ss s 2) (ss s 1))]\n      (recur m (+ a (m k)) (.substring s (.length k))))))\n{\"M\" 1000 \"CM\" 900 \"D\" 500 \"CD\" 400 \"C\" 100 \"XC\" 90\n \"L\" 50 \"XL\" 40 \"X\" 10 \"IX\" 9 \"V\" 5 \"IV\" 4 \"I\" 1} 0", "problem": 92, "user": "504e04a4e4b078edc5f59397"}, {"code": "(fn [roman]\n  (let [vals (map {\\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1} roman)]\n    (reduce +\n            (map\n             (fn [[n & ns]]\n               (if (some #(< n %) ns)\n                 (- 0 n)\n                 n))\n             (take-while not-empty (iterate next vals))))))", "problem": 92, "user": "4ffc10aae4b0678c553fc3d6"}, {"code": "(let [nums {:M 1000 :D 500 :C 100 :L 50 :X 10 :V 5 :I 1}]\n  (fn [string]\n    (loop [coll (reverse (map #(keyword (str %)) string))\n           total 0\n           cur   0]\n      (if (empty? coll)\n        total\n        (let [value ((first coll) nums)]\n          (cond\n            (>= value cur) (recur (rest coll) (+ total value) value)\n            (< value cur)  (recur (rest coll) (- total value) cur)))))))", "problem": 92, "user": "50f94727e4b0e7c80cb15a49"}, {"code": "(fn [s]\n    (let [chars\n          {\\S 0\n           \\I 1\n           \\V 5\n           \\X 10\n           \\L 50\n           \\C 100\n           \\D 500\n           \\M 1000}]\n\n      (first\n       (reduce\n        (fn [[curr buf] v]\n          (if (nil? buf)\n            [curr v]\n            (if (< buf v)\n              [(+ curr (- v buf)) nil]\n              [(+ curr buf) v])))\n        [0 nil]\n        (map chars (str s \"S\"))))))", "problem": 92, "user": "4f463dfde4b0d56e7bb92b99"}, {"code": "(let [numerals {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000, \\Q 500000}]\n        (fn [string]\n            (let [[total last_number mult] (reduce (fn [[total last_number mult] char]\n                                                       (let [value (get numerals char)]\n                                                         (if (> value last_number)\n                                                             [(- total (* last_number mult)) value 1]\n                                                           (if (= value last_number)\n                                                               [total last_number (inc mult)]\n                                                             [(+ total (* last_number mult)) value 1]))))\n                                                   [0 100000000000 0] string)]\n              (+ total (* last_number mult)))))", "problem": 92, "user": "4eae5fe4535d7eef30807325"}, {"code": "(fn [s] (let [\n              n {\\C 100, \\D 500, \\I 1, \\L 50, \\M 1000, \\V 5, \\X 10}\n              t (concat s \"I\")] \n                 (reduce \n                   #(let [[c1 c2] %2] \n                      (if (< (n c1) (n c2)) \n                        (- %1 (n c1)) \n                        (+ %1 (n c1)) )) \n                      0 \n                      (map vector t (rest t)))))", "problem": 92, "user": "50fbdacfe4b0d10d794c19f0"}, {"code": "#(apply + (map { \"M\" 1000 \"D\" 500 \"C\" 100 \"L\" 50 \"X\" 10 \"V\" 5 \"I\" 1\n                \"CM\" 900 \"CD\" 400 \"XC\" 90 \"XL\" 40 \"IX\" 9 \"IV\" 4}\n              (re-seq #\"C[MD]|X[CL]|I[XV]|.\" %)))", "problem": 92, "user": "4ff67852e4b0678c553fc37e"}, {"code": "(fn [roman]\n  (let [ symbols { \"M\"  1000\n                   \"CM\"  900\n                   \"D\"   500\n                   \"CD\"  400\n                   \"C\"   100\n                   \"XC\"   90\n                   \"L\"    50\n                   \"XL\"   40\n                   \"X\"    10\n                   \"IX\"    9\n                   \"V\"     5\n                   \"IV\"    4\n                   \"I\"     1\n                 } ]\n    (reduce + (map symbols\n      (map first (re-seq #\"(CM|XC|IX|CD|XL|IV|D|M|C|X|V|I)\" roman))))))", "problem": 92, "user": "4e2b1d48535deb9a81d77f03"}, {"code": "(fn [s]\n    (let [m {\\I 1, \n             \\V 5,   \n             \\X 10, \n             \\L 50,   \n             \\C 100, \n             \\D 500,   \n             \\M 1000},\n          xs (map #(get m %1) s)] ; split out each letter into its value\n      (loop [f (first xs), c (next xs), r 0]\n        (cond\n          (nil? c) (+ r f)                                          ; add f, return result 'r'\n          (< f (first c)) (recur (first c) (next c) (+ r (* -1 f))) ; subtract f (add the negative)\n          :else (recur (first c) (next c) (+ r f)))                 ; add f\n        )))", "problem": 92, "user": "4f038567535dcb61093f6b0c"}, {"code": "(fn f [[a b & c]]\n  (if a\n    (let [m (zipmap\n                 (interleave \"MDCLXVI\" [\"CM\" \"CD\" \"XC\" \"XL\" \"IX\" \"IV\" 0])\n                 [1000 900 500 400 100 90 50 40 10 9 5 4 1])]\n      (if (m (str a b))\n        (+ (m (str a b)) (f c))\n        (+ (m a) (f (cons b c)))))\n      0))", "problem": 92, "user": "4ebaf790535dfed6da9c6d6e"}, {"code": "(fn [s]\n  (let [nums (map (fn [x]\n         \t (cond (= \\I x) 1\n               \t (= \\V x) 5\n               \t (= \\X x) 10\n               \t (= \\L x) 50\n               \t (= \\C x) 100\n               \t (= \\D x) 500\n               \t (= \\M x) 1000)) s)\n        pairs (partition 2 (interleave nums (concat (rest nums) '(1))))\n        after-sub (map (fn [v]\n           (let [x (first v)\n                 y (second v)]\n             (cond (nil? y) {:val x}\n                   (< x y) {:val (- y x) :adjusted true}\n                   :default {:val x})))\n         pairs)\n        drop-index (map #(inc (first %)) (filter #(:adjusted (second %)) (map-indexed vector after-sub)))\n        val-list (map #(:val (second %)) (filter #(not (some #{(first %)} drop-index)) (map-indexed vector after-sub)))]\n    (reduce + val-list)\n    \n    ))", "problem": 92, "user": "4e9ff8d0535d7eef3080729c"}, {"code": "(fn [nums-str]\n  (let [nums (map (zipmap \"IVXLCDM\" [1 5 10 50 100 500 1000]) nums-str)]\n    (apply +\n           (map-indexed #(if (some (partial < %2) (drop % nums)) (- %2) %2) nums))))", "problem": 92, "user": "510db6cde4b078ea71921145"}, {"code": "#(case (second %)\n   \\I 14\n   \\C 827\n   \\M 3999\n   \\L 48)", "problem": 92, "user": "5100d7dbe4b04f1d96d946df"}, {"code": "(fn roman [s]\n  (let [tm {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000}]\n    (condp = (count s)\n      0 0\n      1 (tm (first s))\n      (if (< (tm (first s)) (tm (second s)))\n        (+ (- (tm (second s)) (tm (first s))) (roman (nnext s)))\n        (+ (tm (first s)) (roman (next s)))))))", "problem": 92, "user": "51281b25e4b03a34742b4304"}, {"code": "(fn [s]\n  (let [val-map {\\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1}]\n    ((fn [s last-val total]\n       (cond (empty? s) total\n             (nil? last-val) (recur (rest s)\n                              \t\t(val-map (first s))\n                                    (val-map (first s)))\n             :else (let [cur-val (val-map (first s))\n                         sub? (< cur-val last-val)]\n                     (recur (rest s)\n                            cur-val\n                            ((if sub? - +) total cur-val)))))\n       (reverse s) nil 0)))", "problem": 92, "user": "510acd6ee4b078ea719210f4"}, {"code": "(fn read-roman [roman] \n  (let [roman-nums {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]\t\t\n    \n    (reduce + (reduce (fn [l n]\n              (cond\n               (zero? (count l)) (concat l [n])\n               (< (last l) n) (concat (butlast l) [(- n (last l))])\n               true (concat l [n]))\n              ) [] (map roman-nums roman)))\n    )\n)", "problem": 92, "user": "50d3b03fe4b030b634c368b9"}, {"code": "(fn [roman]    \n  (let [values {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]\n    (loop [n 0 remaining roman]\n  \t  (if (empty? remaining)\n  \t  \tn\n        (let [r1 (values (first remaining)) \n              r2 (values (second remaining))]\n  \t\t  (if (and r2 (< r1 r2))\n  \t\t\t(recur (+ n (- r2 r1)) (drop 2 remaining))\n  \t\t\t(recur (+ n r1) (rest remaining))))))))", "problem": 92, "user": "50e4f4e9e4b049a987753896"}, {"code": "(fn roman-numeral [n] (let\n\t[char-to-num\n\t\t{\\I 1\n\t\t \\V 5\n\t\t \\X 10\n\t\t \\L 50\n\t\t \\C 100\n\t\t \\D 500\n\t\t \\M 1000}]\n\t(loop [nxt (first n) cur nil rst (rest n) sum 0]\n\t\t(cond\n\t\t\t(nil? cur) (recur (first rst) nxt (rest rst) sum)\n\t\t\t(nil? nxt) (+ sum (char-to-num cur))\n\t\t\t:else (let [curnum (char-to-num cur) nxtnum (char-to-num nxt)]\n\t\t\t\t(if (< curnum nxtnum) (recur (first rst) nxt (rest rst) (- sum curnum))\n\t\t\t\t\t(recur (first rst) nxt (rest rst) (+ sum curnum))\n\t\t\t\t)\t\n\t\t\t)\n\t\t)\n\t)\n))", "problem": 92, "user": "511cca27e4b00c2a1fa7ff7d"}, {"code": "(fn numeral [r]\n  (let [v {\\M 1000\n           \\D 500\n           \\C 100\n           \\L 50\n           \\X 10\n           \\V 5\n           \\I 1}\n        s (partition-by identity r)]\n    (loop [[f s & r] s\n           n []]\n      (cond\n       (nil? f) (apply + n)\n       (nil? s) (recur '() (cons (* (v (first f)) (count f)) n))\n       (> (v (first f)) (v (first s))) (recur (concat (list s) r) (cons (* (count f) (v (first f))) n))\n       :else (recur r (cons (- (* (count s) (v (first s)))\n                               (* (count f) (v (first f)))) n))))))", "problem": 92, "user": "5123ac8ee4b061b4c6f0e0b1"}, {"code": "(fn [txt]\n  (first \n    (reduce\n      (fn [[sum prev] n] [(+ sum (if (<= n prev) n (- n prev prev))) n])\n      [0 1000]\n      (map {\\M 1000, \\D 500, \\C 100, \\L 50, \\X 10, \\V 5, \\I 1} txt))))", "problem": 92, "user": "50bfe95ce4b080409b860f27"}, {"code": "(fn [s]\n  (let [romans \n        {\\I 1\n         \\V 5\n         \\X 10\n         \\L 50\n         \\C 100\n         \\D 500\n         \\M 1000\n         }\n        digits (map romans s)\n        ]\n    (apply + \n           (map * \n                digits \n                (concat \n                  (map #(if (>= % %2) 1 -1) (drop-last digits) (rest digits)) \n                  '(1))))))", "problem": 92, "user": "4fbbcf0ce4b081705acca2ee"}, {"code": "(fn [rn]\n  (letfn [(is-larger [order a b]\n                     (loop [current a]\n                       (if (nil? current)\n      \t\t\t\t\tfalse\n      \t\t\t\t\t(if (or (= a b)\n              \t\t\t\t(= (get order current) b))\n        \t\t\t\t\ttrue\n        \t\t\t\t\t(recur (get order current))))))]      \n  ((fn decode [in order vals]\n  \t(loop [total 0\n    \t   curr in\n           last nil]\n      (if (nil? curr)\n        total\n        (let [numeral (str (first curr))\n              t (+ total (get vals numeral))]\n          (if (is-larger order last numeral)\n            (recur t (next curr) numeral)\n            (recur (- t (* 2 (get vals last))) (next curr) numeral))))))\n   rn\n   {\"M\" \"D\" \"D\" \"C\" \"C\" \"L\" \"L\" \"X\" \"X\" \"V\" \"V\" \"I\" \"I\" nil}\n   {\"M\" 1000 \"D\" 500 \"C\" 100 \"L\" 50 \"X\" 10 \"V\" 5 \"I\" 1 nil 0})))", "problem": 92, "user": "513d121fe4b0e544971636a2"}, {"code": "(fn [s]\n  (let [r-to-a {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000}\n        rr {\"IV\" \"IIII\", \"IX\" \"VIIII\", \"XL\" \"XXXX\", \"XC\" \"LXXXX\", \"CD\" \"CCCC\", \"CM\" \"DCCCC\"}\n        plain-s (reduce #(clojure.string/replace %1 (first %2) (second %2)) s rr)]\n    (reduce #(+ %1 (r-to-a %2)) 0 plain-s)))", "problem": 92, "user": "5117c31ee4b0e0897831a60c"}, {"code": "(fn [num]\n  (let [dict {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]\n    (first (reduce (fn [[s l] curr]\n                     (let [cval (dict curr) lval (dict l)]\n                       (cond (or (nil? lval) (>= lval cval))\n                             [(+ s cval) curr]\n                             :else [(+ (- s lval) (- cval lval)) curr])))\n                   [0 nil]\n                   (seq num)))))", "problem": 92, "user": "50e09313e4b061dbdced7233"}, {"code": "#(reduce + (% (map {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000} %2))) \n(fn ! [[a & x]] (cons ((if (some #(> % a) x) - +) a) (if x (! x))))", "problem": 92, "user": "4f296a80e4b0d6649770a02a"}, {"code": "(fn rom [[f & r]]\n  (if (nil? f)\n    0\n    (let [v {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}\n          vf (v f)]\n      (if (seq r)\n        (let [vs (v (first r))]\n          (if (< vf vs)\n            (+ (- vs vf) (rom (rest r)))\n            (+ vf (rom r))))\n        vf))))", "problem": 92, "user": "50d93c53e4b0fd36a4b89223"}, {"code": "(fn boo [s]\n  (let \n    [rom {\\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1}]\n    (last\n     (reduce (fn [[prev-arab accu] chr]\n              (let \n                [arab (rom chr)]\n                (if (>= prev-arab arab)\n                  [arab (+ accu arab)]\n                  [arab (- (+ accu arab) (* 2 prev-arab))])))\n            [10000 0]\n            s))))", "problem": 92, "user": "50217818e4b00bba4502f7a7"}, {"code": "(fn [s]\n  (condp = s\n        \"XIV\" 14\n        \"DCCCXXVII\" 827\n        \"MMMCMXCIX\" 3999\n        \"XLVIII\" 48))", "problem": 92, "user": "4fdf566fe4b05e33b9224f99"}, {"code": "(fn [s]\n  (letfn [(c-2-n [c]\n                 (cond                   \n                  (= c \\I) 1\n                  (= c \\V) 5\n                  (= c \\X) 10\n                  (= c \\L) 50\n                  (= c \\C) 100\n                  (= c \\D) 500\n                  (= c \\M) 1000\n                  :else 0))]\n    (reduce +\n           (map #(let [x (first %) y (last %)] (if (> x y) (- x y) (+ x y)))\n               (partition 2 2 [0] (reverse (map c-2-n (seq s))))))))", "problem": 92, "user": "514721c6e4b0d520409ed392"}, {"code": "(fn [s]\n  (let [rr (zipmap \"IVXLCDM\"\n                   [1 5 10 50 100 500 1000])]\n    (first (reduce (fn [ [s m] x]\n                     [(+ s (if (< x m) (- x) x))\n                      (max m x)]\n                     ) [0,0] (reverse (map rr s))))))", "problem": 92, "user": "50fa01bce4b07934dda8b0ba"}, {"code": "(fn [S]\n  (let [S2 (map {\\I\t1,\\V\t5,\\X\t10,\\L\t50,\\C\t100,\\D\t500,\\M\t1000} S)]\n    (apply + (map #(if (< % %2) (- 0 %) %) S2 (reverse (reductions max (reverse S2)))))\n    )\n  )", "problem": 92, "user": "514457fbe4b0b4fb4ace5f43"}, {"code": "(fn [rn]\n  (let [translate (hash-map \\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000)]\n    (first\n      (reduce\n        (fn [[total last-n] n]\n          (if (< last-n n)\n            [(+ (- total last-n) (- n last-n)) n]\n            [(+ total n) n])) [0 0] (map #(translate %) rn)))))", "problem": 92, "user": "515a6151e4b0394f658fe241"}, {"code": "(fn roman\n  ([s] (roman (seq s) 0))\n  ([s v]\n    (let [rdigits {\\M 1000, \\D 500, \\C 100, \\L 50, \\X 10, \\V 5, \\I 1}\n          sdigits {\"IV\" 4, \"IX\" 9, \"XL\" 40, \"XC\" 90, \"CD\" 400, \"CM\" 900}\n          c1  (first s)\n          c12 (str c1 (second s))]\n      (if (empty? s)\n        v\n        (if (contains? sdigits c12)\n          (roman (drop 2 s) (+ v (get sdigits c12)))\n          (roman (rest s) (+ v (get rdigits c1 0)))\n        )\n      )\n    )\n  )\n)", "problem": 92, "user": "514dbd08e4b019235f6c058d"}, {"code": "(fn read_roman_numerals [roman-string]\n  (let [number-table {\\I 1\n                      \\V 5\n                      \\X 10\n                      \\L 50\n                      \\C 100\n                      \\D 500\n                      \\M 1000}]\n    (loop [accumulator 0\n          chars roman-string\n          last-char nil]\n      (if (empty? chars)\n        accumulator\n        (if (and (not (nil? last-char))\n              (< (get number-table last-char)\n                (get number-table (first chars))))\n          (recur (- (+ accumulator (get number-table (first chars))) (* 2 (get number-table last-char)))\n            (rest chars)\n            (first chars))\n          (recur (+ accumulator (get number-table (first chars))) (rest chars) (first chars)))))))", "problem": 92, "user": "515737f0e4b0b0b4b87062d0"}, {"code": "(fn\t[s]\n\t(let [rmn {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}\n\t      nums (map (comp (partial apply *) (juxt (comp rmn first) count)) (partition-by identity s))\n\t      lt? (concat (map (partial apply <) (partition 2 1 nums)) [false])]\n\t  (apply + (map (fn [i b] (if b (- i) i)) nums lt?))))", "problem": 92, "user": "5142ea50e4b0c172af7558ca"}, {"code": "(fn p92 [n]\n  (let [m {\"I\" 1 \"V\" 5 \"X\" 10 \"L\" 50 \"C\" 100 \"D\" 500 \"M\" 1000 \"IX\" 9 \"IV\" 4 \"XL\" 40 \"XC\" 90 \"CD\" 400 \"CM\" 900}]\n    (loop [s n r 0]\n      (cond\n       (= (count s) 1) (+ r (get m s))\n       (= (count s) 0) r\n       (>= (count s) 2) (let [dl (get m (.substring s 0 2))\n                              l (get m (.substring s 0 1))]\n                          (if (nil? dl)\n                            (recur (.substring s 1) (+ r l))\n                            (recur (.substring s 2) (+ r dl))))))))", "problem": 92, "user": "500b61b1e4b03d00572d2d81"}, {"code": "(fn roman-num [numstr]\n  (let [vmap { \"I\" 1 \"V\" 5 \"X\" 10 \"L\" 50 \"C\" 100 \"D\" 500 \"M\" 1000 \"IV\" 4 \"IX\" 9 \"XL\" 40 \"XC\" 90 \"CD\" 400 \"CM\" 900 }]\n  (loop [numstr numstr tot 0]\n    (if (clojure.string/blank? numstr)\n      tot\n      (if (<= (count numstr) 1)\n        (+ tot (vmap (subs numstr 0 1)))\n        (let [hd (subs numstr 0 1) hdpair (subs numstr 0 2)]\n          (if (nil? (vmap hdpair))\n            (recur (subs numstr 1) (+ tot (vmap hd)))\n            (recur (subs numstr 2) (+ tot (vmap hdpair))))))))))", "problem": 92, "user": "513cb853e4b0b86ece9f322b"}, {"code": "(fn [s]\n  (let [roman {\"M\" 1000 \"CM\" 900 \"D\" 500 \"CD\" 400\n               \"C\" 100 \"XC\" 90 \"L\" 50 \"XL\" 40 \"X\" 10 \"IX\" 9\n               \"V\" 5 \"IV\" 4 \"I\" 1}]\n    (reduce + (map roman\n                   (re-seq #\"CM|CD|XC|XL|IX|IV|[MDCLXVI]\" s)))))", "problem": 92, "user": "512eb723e4b0b740abc5982b"}, {"code": "(fn [s] (let [numerals (into (sorted-map-by >) { 1 \"I\"    4 \"IV\"   5 \"V\"   9 \"IX\"  10 \"X\"   40 \"XL\"\n                                                50 \"L\"   90 \"XC\" 100 \"C\" 400 \"CD\" 500 \"D\"  900 \"CM\" 1000 \"M\"})]\n          (loop [t s n numerals a 0]\n            (if (seq t)\n              (if (.startsWith (apply str t) (val (first n)))\n                (recur (drop (count (val (first n))) t) numerals (+ a (key (first n))))\n                (recur t (next n) a))\n              a))))", "problem": 92, "user": "4fa05b99e4b0dcca54ed6d47"}, {"code": "#({\\I 14 \\C 827 \\M 3999} (nth % 1) 48)", "problem": 92, "user": "5175616ae4b0dea9bbfba576"}, {"code": "(fn [s]\n    (let [symbolz (hash-map \\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000)]\n      (loop [res 0\n             last-seen-val 999999\n             todo s]\n        (if (empty? todo)\n          res\n          (let [f (first todo)\n                val (symbolz f)\n                acc (if (> val last-seen-val)\n                      (- val (* 2 last-seen-val))\n                      val)\n                r (rest todo)]\n            (recur (+ res acc) val r))))))", "problem": 92, "user": "5165a235e4b079ad97ec44ac"}, {"code": "(fn [x]\n\t(let [roman {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}\n          numerals (map roman x)\n          numeral-pairs (partition-all 2 1 numerals)\n          sign-numerals (map #(if (apply >= %) (first %) (- (first %))) numeral-pairs)]\n      (reduce + sign-numerals)))", "problem": 92, "user": "515f8a0de4b0e2be8aa20bce"}, {"code": "(fn [s]\n  (let [m (re-seq #\"IV|IX|XL|XC|CD|CM|I|V|X|L|C|D|M\" s)\n        c #(case %\n             \"I\" 1\n             \"IV\" 4\n             \"V\" 5\n             \"IX\" 9\n             \"X\" 10\n             \"XL\" 40\n             \"L\" 50\n             \"XC\" 90\n             \"C\" 100\n             \"CD\" 400\n             \"D\" 500\n             \"CM\" 900\n             \"M\" 1000)]\n    (reduce + (map c m))))", "problem": 92, "user": "514d8084e4b019235f6c0588"}, {"code": "(fn rrn [roman-numeral]\n  (let [digits (map {\\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1} (take 2 roman-numeral))]\n    (cond (empty? digits) 0\n          (and (= 2 (count digits))\n               (< (first digits) (second digits))) (- (rrn (rest roman-numeral)) (first digits))\n          :else (+ (rrn (rest roman-numeral)) (first digits)))))", "problem": 92, "user": "510cd1dde4b078ea71921124"}, {"code": "(let [vm {\\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1}]\n  (fn rn [s]\n    (loop [v 0 s (vec s) maxv 0]\n      (if (empty? s) v\n        (let [s0 (last s)\n              v0 (vm s0)\n              sr (drop-last s)]\n          (if (>= (vm s0) maxv)\n            (recur (+ v v0) sr v0)\n            (recur (- v v0) sr maxv)))))))", "problem": 92, "user": "50b668dde4b08fb537db98f2"}, {"code": "(fn [x]\n  (let [vals {nil 0 \\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]\n    ((fn parse-roman [n]\n       (let [f (first n)\n             r (rest n)]\n         (cond\n          (nil? f) 0\n          (< (vals f) (vals (first r))) (- (parse-roman r) (vals f))\n          :else (+ (parse-roman r) (vals f)))))\n     x)))", "problem": 92, "user": "512d3304e4b040332b905b2d"}, {"code": "{\"XIV\" 14\n\"DCCCXXVII\" 827\n\"MMMCMXCIX\" 3999\n\"XLVIII\" 48}", "problem": 92, "user": "50a83315e4b054305ba5a830"}, {"code": "(fn [roman] (let\n              [numerals {\"M\" 1000 \"D\" 500 \"C\" 100 \"L\" 50 \"X\" 10 \"V\" 5 \"I\" 1}]\n              (loop [s roman r 0 m 0]\n                (if (empty? s)\n                  r\n                  (let [n (-> s first str numerals)]\n                    (recur\n                     (rest s)\n                     (+ n (if (> n m) (- r (* 2 m)) r))\n                     n))))))", "problem": 92, "user": "51307b84e4b08c712d3fae39"}, {"code": "(fn [x]\n  (let [ks [\"M\" \"CM\" \"D\" \"CD\" \"C\" \"XC\" \"L\" \"XL\" \"X\" \"IX\" \"V\" \"IV\" \"I\"]\n        vs [1000 900 500 400 100 90 50 40 10 9 5 4 1]\n        roman (zipmap ks vs)\n        pattern (re-pattern (apply str (interpose \"|\" ks)))]\n    (apply + (map roman (re-seq pattern x)))))", "problem": 92, "user": "5164867fe4b003cf19fdde3e"}, {"code": "(fn [text]\n   (letfn [(char-to-value [c]\n             (case c nil 0, \\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000))\n           (convert-roman [text acc]\n             (if (seq text)\n\t       (let [fst (char-to-value (first text))\n                     snd (char-to-value (second text))]\n                 (if (< fst snd)\n                   (recur (rest (rest text)) (+ acc (- snd fst)))\n                   (recur (rest text) (+ acc fst))))\n               acc))]\n     (convert-roman text 0)))", "problem": 92, "user": "4f2e0369e4b0d6649770a064"}, {"code": "(fn read-roman-numerals [roman-numeral-string]\n  (let [value {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}\n        subtractive {\\I #{\\V \\X} \\X #{\\L \\C} \\C #{\\D \\M}}\n        parsed (->> (seq roman-numeral-string) (partition 2 1 nil))\n        get-value (fn [[x y]] (let [v (value x)] (if (contains? (subtractive x) y) (- v) v)))]\n    (->> (map get-value parsed) (reduce +))))", "problem": 92, "user": "51729002e4b044b2ef48a850"}, {"code": "(fn f [s]\n  (let [coll (reverse s)\n        roman {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}\n        pair {\\V \\I \\X \\I \\L \\X \\C \\X \\D \\C \\M \\C}]\n    (loop [coll coll func + acc 0]\n      (if (not (seq coll))\n        acc\n        (recur (rest coll) \n               (if (= (second coll) (pair (first coll)))\n                 -\n                 +) \n               (func acc (roman (first coll))))))))", "problem": 92, "user": "51750cd4e4b07031762f2ee5"}, {"code": "(let [roman-values {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]\n  (fn parse-roman [s]\n  (cond\n   (= 0 (count s)) 0\n   (= 1 (count s)) (roman-values (first s))\n   :else (let [[c1 c2 & cs] s\n               x1 (roman-values c1)\n               x2 (roman-values c2)]\n           (if (< x1 x2)\n             (+ (- x2 x1) (parse-roman cs))\n             (+ x1 (parse-roman (cons c2 cs))))))))", "problem": 92, "user": "5186134ce4b0da5a5be3bac7"}, {"code": "(fn [roman-numeral]\n  (let [value-map {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]\n    (reduce + (map\n                (fn\n                  [str]\n                  (if (and (> (count str) 1) (< (value-map (first str)) (value-map (second str))))\n                    (- (value-map (second str)) (value-map (first str)))\n                    (reduce + (map #(value-map %) str))))\n                [(first (re-seq #\"M*\" roman-numeral))\n                 (first (re-seq #\"[CD][CDM]*\" roman-numeral))\n                 (first (re-seq #\"[XL][XLC]*\" roman-numeral))\n                 (first (re-seq #\"[IV][IVX]*\" roman-numeral))]))))", "problem": 92, "user": "514d7e29e4b019235f6c0587"}, {"code": "(fn [s]\n  (let [values {\\M 1000\n                \\D 500\n                \\C 100\n                \\L 50\n                \\X 10\n                \\V 5\n                \\I 1}]\n    (loop [[x & xs] (vec s) total 0]\n      (if-not x\n        total\n        (let [value (values x)\n              value (if (some #(> (values %) value) xs)\n                      (* value -1)\n                      value)]\n          (recur xs (+ total value)))))))", "problem": 92, "user": "4fe13ad7e4b0dd6cd5ce3632"}, {"code": "(fn roman-2-int [roman]                                                               (let [roman-rev (reverse roman)                                                             roman-int {\\I 1                                                                                  \\V 5                                                                                  \\X 10                                                                                 \\L 50                                                                                 \\C 100                                                                                \\D 500                                                                                \\M 1000}]                                                              (loop [remaining (rest roman-rev)                                                            last-int (roman-int (first roman-rev))                                                result last-int]                                                                 (if (empty? remaining)                                                                  result                                                                                (let [this-int (roman-int (first remaining))                                                subtract? (< this-int last-int)                                                       new-last-int (if subtract? last-int this-int)                                         new-result (if subtract? (- result this-int) (+ result this-int))]                (recur (rest remaining) new-last-int new-result))))))", "problem": 92, "user": "51899891e4b0288ada3dbdab"}, {"code": "(fn [s]\n    (let [pn\n          (fn [[s acc] pat incr]\n            (loop [s s, acc acc]\n              (if-not (re-find pat s)\n                [s acc]\n                (recur (clojure.string/replace-first s pat \"\") (+ acc incr)))))]\n      (-> s\n          (vector 0)\n          (pn #\"CM\" 900)\n          (pn #\"CD\" 400)\n          (pn #\"XC\" 90)\n          (pn #\"XL\" 40)\n          (pn #\"IX\" 9)\n          (pn #\"IV\" 4)\n          (pn #\"M\" 1000)\n          (pn #\"D\" 500)\n          (pn #\"C\" 100)\n          (pn #\"L\" 50)\n          (pn #\"X\" 10)\n          (pn #\"V\" 5)\n          (pn #\"I\" 1)\n          last)))", "problem": 92, "user": "4ee26f01535d10e5ff6f5368"}, {"code": "(fn [w]\n  (let [a-to-i (zipmap \"IVXLCDM\" [1 5 10 50 100 500 1000])\n        spec (fn spec [[x y]] (* 2 (a-to-i x)))\n        spec-re [#\"IV\" #\"IX\" #\"XL\" #\"XC\" #\"CD\" #\"CM\"]\n        apply-spec #(->> w (re-seq %) count (* (spec (str %))))\n        delta (reduce + 0 (map apply-spec spec-re))]\n    (- (reduce + 0 (map a-to-i w)) delta)\n    ) \n  )", "problem": 92, "user": "519b2570e4b0ac1b7dced6a3"}, {"code": "(fn [s]\n   (let [schema {\"I\"  1\n                 \"IV\" 4\n                 \"V\"  5\n                 \"IX\" 9\n                 \"X\"  10\n                 \"XL\" 40\n                 \"L\"  50\n                 \"XC\" 90\n                 \"C\"  100\n                 \"CD\" 400\n                 \"D\"  500\n                 \"CM\" 900\n                 \"M\"  1000}]\n     (loop [acc 0 roman s]\n       (if (empty? roman)\n         acc\n         (let [h1 (str (first roman))\n               h2 (str (second roman))\n               hh (str h1 h2)]\n           (if (= h2 hh)\n             (+ acc (schema hh))\n             (if (contains? schema hh)\n               (recur (+ acc (schema hh)) (apply str (drop 2 roman)))\n               (recur (+ acc (schema h1)) (apply str (drop 1 roman))))))))))", "problem": 92, "user": "4eec82fe535d93acb0a668ae"}, {"code": "(fn [st] (let \n           [mp (vec (map (comp\n                        {\"I\" 1 \"V\" 5 \"X\" 10 \"L\" 50 \"C\" 100 \"D\" 500 \"M\" 1000} \n                        str) (seq st)))]\n          \n                 (loop [i 0 su (last mp)] \n                        (if (= i (- (count mp) 1)) su\n                          (recur (+ 1 i)\n                                 (if (< (nth mp i) (nth mp (+ i 1)))\n                                 (+ su (- 0 (nth mp i))) (+ su (nth mp i)))\n                          \n                          )\n                          )\n                   )\n                       \n           )\n  )", "problem": 92, "user": "517945dce4b0684c1c981a43"}, {"code": "(fn [s]\n           (let [standard {\"I\" 1\n                           \"V\" 5\n                           \"X\" 10\n                           \"L\" 50\n                           \"C\" 100\n                           \"D\" 500\n                           \"M\" 1000}\n\n                 special {\"IV\" 4\n                          \"IX\" 9\n                          \"XL\" 40\n                          \"XC\" 90\n                          \"CD\" 400\n                          \"CM\" 900}             \n                 special-regex (re-pattern (reduce str (interpose \"|\" (keys special))))\n                 special-sum (reduce + (map #(get special %) (re-seq special-regex s)))\n                 stuff (loop [s s\n                              l (keys special)]\n                         (if (empty? l)\n                           s\n                           (recur (clojure.string/replace s (first l) \"\")\n                                  (rest l))))\n                 o (map #(get standard %) (map str (seq stuff)))]\n\n             (reduce + (conj o special-sum))))", "problem": 92, "user": "50a5b7e9e4b0aa96157e2610"}, {"code": "(fn [s]\n    (loop [sum 0 [n & nx] (map {\\I 1 \\V 5 \\X 10 \\C 100 \\L 50 \\D 500 \\M 1000} (reverse s))]\n      (let [[e ne] (split-with #(= n %) nx) sum (apply (if (< n sum) - +) (list* sum n e))]\n        (if (empty? ne) sum (recur sum ne)))))", "problem": 92, "user": "51b793d3e4b0d906fcd71d38"}, {"code": "(fn [n]\n  (let [m {\"I\" 1 \"V\" 5 \"X\" 10 \"L\" 50 \"C\" 100 \"D\" 500 \"M\" 1000 \"IV\" 4 \"IX\" 9 \"XL\" 40 \"XC\" 90 \"CD\" 400 \"CM\" 900}]\n    (->>\n      (reduce\n        #(let [a (str (last %) %2)] \n          (if (m a)\n            (conj (vec (drop-last %)) a)\n            (conj % (str %2))))\n        '()\n        n)\n      (map m)\n      (apply +)\n      )))", "problem": 92, "user": "51b3f109e4b0f094dd986fa9"}, {"code": "(fn roman->decimal\n  [s]\n  (let [subs {\\I 1\n              \\X 10\n              \\V 5\n              \\L 50\n              \\C 100\n              \\D 500\n              \\M 1000}]\n    (->> s\n         (map subs)\n         (partition 2 1)\n         (reduce (fn [n [a b]]\n                   (if (< a b)\n                     (+ n (- a))\n                     (+ n a)))\n                 0)\n         (+ (subs (last s))))))", "problem": 92, "user": "4e7e4a1f535db169f9c7970c"}, {"code": ";; roman-numeral-to-integer\n(fn [str]\n  (let [vm {\\I 1, \\V 5,\\X 10,\\L 50,\\C 100,\\D 500,\\M 1000}]\n    (reduce #(if (>= (first %2) (second %2))\n               (+ %1 (first %2))\n               (+ %1 (- (second %2) (first %2)) (- (second %2))))\n            0\n            (partition 2 1 '(0)\n                       (map #(get vm %) str)))))", "problem": 92, "user": "504ec4d3e4b069badc5a33c9"}, {"code": "(fn [n]\n   ((fn [[c & r] l a]\n      (cond\n       (nil? c) a\n       (> l c) (recur r l (- a c))\n       :else (recur r c (+ a c))))\n    (->> n seq reverse (map {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000})) 0 0))", "problem": 92, "user": "4ea5e32a535d7eef308072de"}, {"code": "(fn [n]\n  (let [ rmap  { #\"IV\" \"IIII\"\n            #\"IX\" \"VIIII\"\n            #\"XL\" \"XXXX\"\n            #\"XC\" \"LXXXX\"\n            #\"CD\" \"CCCC\"\n            #\"CM\" \"DCCCC\"}\n\n        vmap { \\I 1\n            \\V 5\n            \\X 10\n            \\L 50\n            \\C 100\n            \\D 500\n            \\M 1000}\n       rstring  \n           (reduce #(clojure.string/replace % (key %2) (val %2)) n  rmap)\n\n        ]\n   (reduce #(+ % (vmap %2)) 0 rstring )\n    \n    ))", "problem": 92, "user": "5124619ae4b02c3f2a072ccd"}, {"code": "#(reduce (fn [c [a b]] (+ c (if (> b a) (- a) a))) 0 \n                (partition 2 1 [0] (map {\\C 100 \\D 500 \\I 1 \\L 50 \\M 1000 \\V 5 \\X 10} %)))", "problem": 92, "user": "512f06c5e4b0762be4c7aad7"}, {"code": "(fn [s]\n  (let [r-values {\\M 1000\n                  \\D 500\n                  \\C 100\n                  \\L 50\n                  \\X 10\n                  \\V 5\n                  \\I 1}]\n    (loop [numeral s\n           res 0]\n      (if (empty? numeral)\n        res\n        (let [curr (get r-values (first numeral))]\n          (if-let [lookahead (get r-values (second numeral))]\n            (if (> lookahead curr)\n              (recur (nnext numeral) (+ res (- lookahead curr)))\n              (recur (next numeral) (+ res curr)))\n            (recur (next numeral) (+ res curr))))))))", "problem": 92, "user": "51d19c24e4b0cfcf579466c3"}, {"code": "#(let [\n    letter [\"M\" \"CM\" \"D\" \"CD\" \"C\" \"XC\" \"L\" \"XL\" \"X\" \"IX\" \"V\" \"IV\" \"I\"]\n    value [1000 900 500 400 100 90 50 40 10 9 5 4 1]\n    l2v (zipmap letter value)\n    lre (re-pattern (apply str (interpose \"|\" letter)))]\n    (apply + (map l2v (re-seq lre %))))", "problem": 92, "user": "51cbdee1e4b08d8387cbede1"}, {"code": "(fn [text]\n  (letfn [(read-roman [text n]\n                      (let [code {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000} fst (first text) snd (second text)]\n                        (cond (empty? text) n\n                              (= 1 (count text)) (+ n (code fst))\n                              (< (code fst) (code snd)) (read-roman (drop 2 text) (+ n (- (code snd) (code fst))))\n                              :else (read-roman (rest text) (+ n (code fst))))))]\n    (read-roman text 0)))", "problem": 92, "user": "51780f88e4b03d69594194c9"}, {"code": "(fn [s]\n  (->> s\n       reverse\n       (replace (zipmap \"MDCLXVI\" [1000 500 100 50 10 5 1]))\n       (partition-by identity)\n       (map (partial apply +))\n       (reduce #((if (< %1 %2) + -) %1 %2))))", "problem": 92, "user": "4fa340b4e4b081705acca18c"}, {"code": "(fn [s] ((fn convert-roman [s value]\n           (if (empty? s)\n             value\n             (let [c (first s)\n                   n (second s)]\n               (case c\n                 \\C (case n\n                      \\M (convert-roman (drop 2 s) (+ value 900))\n                      \\D (convert-roman (drop 2 s) (+ value 400))\n                      (convert-roman (rest s) (+ value 100)))\n                 \\X (case n\n                      \\C (convert-roman (drop 2 s) (+ value 90))\n                      \\L (convert-roman (drop 2 s) (+ value 40))\n                      (convert-roman (rest s) (+ value 10)))\n                 \\I (case n\n                      \\X (convert-roman (drop 2 s) (+ value 9))\n                      \\V (convert-roman (drop 2 s) (+ value 4))\n                      (convert-roman (rest s) (+ value 1)))\n                 \\M (convert-roman (rest s) (+ value 1000))\n                 \\D (convert-roman (rest s) (+ value 500))\n                 \\L (convert-roman (rest s) (+ value 50))\n                 \\V (convert-roman (rest s) (+ value 5))))))\n           s 0))", "problem": 92, "user": "50d86fe2e4b01f0871336e67"}, {"code": "(fn [r]\n  (let [p clojure.string/replace]\n    (reduce +\n      (map\n        {\\I    1\n         \\V    5\n         \\X   10\n         \\L   50\n         \\C  100\n         \\D  500\n         \\M 1000}\n        (-> r\n          (p #\"IV\"  \"IIII\")\n          (p #\"IX\" \"VIIII\")\n          (p #\"XL\"  \"XXXX\")\n          (p #\"XC\" \"LXXXX\")\n          (p #\"CD\"  \"CCCC\")\n          (p #\"CM\" \"DCCCC\"))))))", "problem": 92, "user": "51a10b2ce4b0b292b01ee3fe"}, {"code": "(fn [s]\n  (let [ns (->> s (re-seq #\".\")\n\t\t(map {\"I\" 1, \"V\" 5, \"X\" 10, \"L\" 50, \"C\" 100, \"D\" 500, \"M\" 1000})\n\t\t(partition-by identity)\n\t\t(map #(apply + %)))\n\tp (map list (butlast ns) (rest ns))]\n    (apply + (last ns)\n           (map (fn [[a b]] (if (> a b) a (- a))) p))\n    ))", "problem": 92, "user": "51b9d1f0e4b0e871ca49590b"}, {"code": "(fn [s]\n  (let [roman-value {\\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1}\n        numbers (map roman-value (reverse s))]\n    (apply + (map #(if (< %1 %2) (- %1) %1) numbers (reductions max numbers)))))", "problem": 92, "user": "507b7dbee4b09034bfeeb71e"}, {"code": "; cheat\n(fn [s]\n  (cond (= s \"XIV\") 14\n        (= s \"DCCCXXVII\") 827\n        (= s \"MMMCMXCIX\") 3999\n        (= s \"XLVIII\") 48\n        true 0))", "problem": 92, "user": "51e0198ee4b01188f0627539"}, {"code": "(fn romans [n] (let [\n      r\n      (reverse n)\n      v\n      {\\D 500 \\M 1000 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1}\n      ]\n      (reduce + (concat [(v (first r))] (for [i (range 1 (count r))] \n        (if (< (v (nth r i)) (v (nth r (- i 1)))) (* (v (nth r i)) -1) (v (nth r i)))\n      )))))\n;; zipmap\n;; and think about hos reduce works", "problem": 92, "user": "514cfa27e4b019235f6c057d"}, {"code": "(fn [s]\n  (let [rn {\"CM\" 900, \"CD\" 400, \"XC\" 90, \"XL\" 40, \"IX\" 9, \"IV\" 4, \"M\" 1000, \"D\" 500, \"C\" 100, \"L\" 50, \"X\" 10, \"V\" 5, \"I\" 1}]\n    (loop [ss s dn 0]\n      (if (empty? ss)\n        dn\n        (if (get rn (apply str (first (partition 2 ss))))\n          (recur (drop 2 ss) (+ dn (get rn (apply str (first (partition 2 ss))))))\n          (recur (rest ss) (+ dn (get rn (str (first ss))))))))))", "problem": 92, "user": "51c09719e4b0c9c82288293c"}, {"code": "(fn [s]\n  (-\n   (apply + (map {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000} s))\n   (apply + (map #(get {\"IV\" 2 \"IX\" 2 \"CD\" 200 \"CM\" 200 \"XL\" 20 \"XC\" 20} (str %1 %2) 0) s (rest s)))))", "problem": 92, "user": "5054bc87e4b0b1b9d1860eb0"}, {"code": "(fn rn [s]\n  (let [nmap { \\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000 }\n        aggr (fn [sum [f s]] (+ sum (if (or (nil? s) (>= f s)) f (- f))))]\n    (reduce aggr 0 (partition-all 2 1 (map nmap s)))))", "problem": 92, "user": "511d6a01e4b022853b0e07a5"}, {"code": "(fn [s]\n   (let [n {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000}]\n     (apply + (map (fn [[a b]]\n                     (if (>= (n a) (n b)) (n a) (- (n a))))\n                   (partition 2 1 (str s (last s)))))))", "problem": 92, "user": "50f48298e4b004d364930527"}, {"code": "(fn [s]\n    (letfn [(replace [num txt val]\n              (clojure.string/replace num txt (str val \" \")))]\n      (reduce +\n              (map #(Integer/parseInt %)\n                   (-> s\n                       (replace \"CM\" 900)\n                       (replace \"CD\" 400)\n                       (replace \"XC\" 90)\n                       (replace \"XL\" 40)\n                       (replace \"IX\" 9)\n                       (replace \"IV\" 4)\n                       (replace \"M\" 1000)\n                       (replace \"D\" 500)\n                       (replace \"C\" 100)\n                       (replace \"L\" 50)\n                       (replace \"X\" 10)\n                       (replace \"V\" 5)\n                       (replace \"I\" 1)\n                       (clojure.string/split #\"\\W\"))))))", "problem": 92, "user": "50bca033e4b0594b91591c5d"}, {"code": "#(loop [i (rest (clojure.string/split % #\"\"))\n        o 0]\n   (cond\n    (empty? i) o\n    (and (= \"I\" (first i)) (= \"V\" (second i))) (recur (drop 2 i) (+ 4 o))\n    (and (= \"I\" (first i)) (= \"X\" (second i))) (recur (drop 2 i) (+ 9 o))\n    (= \"I\" (first i)) (recur (rest i) (+ 1 o))\n    (= \"V\" (first i)) (recur (rest i) (+ 5 o))\n    (and (= \"X\" (first i)) (= \"C\" (second i))) (recur (drop 2 i) (+ 90 o))\n    (and (= \"X\" (first i)) (= \"L\" (second i))) (recur (drop 2 i) (+ 40 o))\n    (= \"X\" (first i)) (recur (rest i) (+ 10 o))\n    (and (= \"C\" (first i)) (= \"M\" (second i))) (recur (drop 2 i) (+ 900 o))\n    (= \"C\" (first i)) (recur (rest i) (+ 100 o))\n    (= \"D\" (first i)) (recur (rest i) (+ 500 o))\n    (= \"M\" (first i)) (recur (rest i) (+ 1000 o))\n   )\n)", "problem": 92, "user": "51f28a64e4b0210f90e7454e"}, {"code": "(fn roman [s]\n  (let [cm {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]\n    (->> (conj (vec (map cm s)) 0)\n         (partition 2 1)\n         (map (fn [[a b]] (if (< a b) (- a) a)))\n         (apply +))))", "problem": 92, "user": "4dac39a28cc9d6edb8beb0b3"}, {"code": "(fn [s]\n (let [roman-value  { \\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000 }]\n  ((fn \n    [ r [a b & xs ] ]\n    (if (nil? b) \n     (+ r a)\n     (recur ((if (< a b) - +) r a) (cons b xs))))\n   0 (map roman-value s))))", "problem": 92, "user": "51f59607e4b0abb92f97f9d5"}, {"code": "(fn [s]\n   (let [m (zipmap \"IVXLCDM\" [1 5 10 50 100 500 1000])]\n     (loop [[x & xs] s acc 0]\n       (if x\n         (if xs\n           (let [a (m x) b (m (first xs))]\n             (if (< a b)\n               (recur (rest xs) (+ acc (- b a)))\n               (recur xs (+ acc (m x)))\n             )\n           )\n           (+ acc (m x))\n         )\n         acc\n       )\n     )\n   )\n )", "problem": 92, "user": "51ba8f82e4b0fe3ecfb46434"}, {"code": "(fn [numer-str] \n    (let [values {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000 }]\n      (loop [acc 0\n             s numer-str]\n        (if (= (count s) 0) acc\n          (let [current (values (first s))\n                nxt (values (second s) 0)]\n            (if (> nxt current)\n              (recur (+ acc (- nxt current)) (drop 2 s))\n              (recur (+ acc current) (rest s))))))))", "problem": 92, "user": "5141abf1e4b02fd87f5064c3"}, {"code": "(fn [string]\n  ((fn [total biggest [fst & rst]]\n   (cond (nil? fst) total\n         (< fst biggest) (recur (- total fst) biggest rst)\n         :else (recur (+ total fst) fst rst)))\n   0 0 (reverse (map {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000} string))))", "problem": 92, "user": "51fa90aae4b0f1313d4689e0"}, {"code": "(fn roman [s]\n  (let [m {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}\n        rs (reverse (map #(m %) (seq s)))\n        convert (fn conv [[h & t]  mx]\n                  (lazy-seq (cons (if (>= h mx) h (- h)) (if t (conv t (max h mx))))))]\n        (reduce + (convert rs 0))))", "problem": 92, "user": "51d96ad0e4b02ceefd94774f"}, {"code": "(fn read-rn [rn] \n  (let [rval {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}\n        sub-rules {\"IV\" 4 \"IX\" 9 \"XL\" 40 \"XC\" 90 \"CD\" 400 \"CM\" 900}\n        [n skip-last?] (reduce (fn [[n skip?] [a b]] \n                                 (if-not skip?\n                                   [(+ n (sub-rules (str a b) (rval a))) (boolean (sub-rules (str a b)))]\n                                   [n false]))\n                               [0 false] (partition 2 1 rn))]\n    (if skip-last? n (+ n (rval (last rn))))))", "problem": 92, "user": "50c781bbe4b00bb60fe0c535"}, {"code": "(let [c (seq \"IVXLCDM\")\n\tmapp {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]\n\t(fn [s]\n\t\t(first\n\t\t\t(reduce \n\t\t\t\t#(if (< %2 (last %)) \n\t\t\t\t\t[(- (first %) %2) (last %)]\n\t\t\t\t\t[(+ (first %) %2) %2])\n\t\t\t\t[0 0]\n\t\t\t\t(map mapp (reverse s))))))", "problem": 92, "user": "520242bae4b030ee0c5b26e3"}, {"code": "(fn roman-number->num [s]\n    (let [m { \\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]\n      (apply + (map (fn [x y]\n                      (let [x1 (m x )\n                            y1 (m y 0)]\n                        (if (< x1 y1)\n                          (- x1)\n                          x1)))\n                    s (drop 1 (str s \" \"))))))", "problem": 92, "user": "4fb23582e4b081705acca28a"}, {"code": "(fn [roman]\n  (let [single-char-roman\n        (clojure.string/replace roman #\"IV|IX|XL|XC|CD|CM\" {\"IV\" \"Q\" \"IX\" \"R\" \"XL\" \"S\" \"XC\" \"T\" \"CD\" \"W\" \"CM\" \"Y\"})\n        value-map {\\I 1 \\Q 4 \\V 5 \\R 9 \\X 10 \\S 40 \\L 50 \\T 90 \\C 100 \\W 400 \\D 500 \\Y 900 \\M 1000}]\n    (reduce #(+ % (value-map %2)) 0 single-char-roman)))", "problem": 92, "user": "52015698e4b0d7096e99ddba"}, {"code": "(fn read-roman [xs]\n  (let [st-notation {\"IV\" \"IIII\"\n                     \"IX\" \"VIIII\"\n    \"XL\" \"XXXX\"\n                     \"XC\" \"LXXXX\"\n                     \"CD\" \"CCCC\"\n                     \"CM\" \"DCCCC\"}\n        trans (fn [x] (reduce (fn [acc [k v]] (clojure.string/replace acc k v)) x st-notation))\n        roman-map {\\I 1\n                   \\V 5\n                   \\X 10\n                   \\L 50\n                   \\C 100\n                   \\D 500\n                   \\M 1000}]\n    (->> xs\n         (trans)\n         (map roman-map)\n         (apply +))\n    ))", "problem": 92, "user": "513fab65e4b00f13ea1bd891"}, {"code": "(fn [x]\n  (let [m {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}\n        sp {[\\I \\V] 4 [\\I \\X] 9 [\\X \\L] 40\n            [\\X \\C] 90 [\\C \\D] 400 [\\C \\M] 900}\n        e (fn [[a b] c] (if b\n                          [a nil]\n                          (if-let [s (sp c)]\n                            [(+ a s) s]\n                            [(+ a (m (first c))) nil])))\n        i (partition-all 2 1 x)]\n    (first (reduce e (e [0 nil] (first i)) (rest i)))))", "problem": 92, "user": "5201572be4b0d7096e99ddbb"}, {"code": "(fn roman [s]\n   (cond\n    (empty? s) 0\n    (and (= \\I (first s)) (= \\V (second s))) (+ 4 (roman (rest (rest s))))\n    (and (= \\I (first s)) (= \\X (second s))) (+ 9 (roman (rest (rest s))))\n    (and (= \\X (first s)) (= \\L (second s))) (+ 40 (roman (rest (rest s))))\n    (and (= \\X (first s)) (= \\C (second s))) (+ 90 (roman (rest (rest s))))\n    (and (= \\C (first s)) (= \\D (second s))) (+ 400 (roman (rest (rest s))))\n    (and (= \\C (first s)) (= \\M (second s))) (+ 900 (roman (rest (rest s))))\n\n    (= \\I (first s)) (+ 1 (roman (rest s)))\n    (= \\V (first s)) (+ 5 (roman (rest s)))\n    (= \\X (first s)) (+ 10 (roman (rest s)))\n    (= \\L (first s)) (+ 50 (roman (rest s)))\n    (= \\C (first s)) (+ 100 (roman (rest s)))\n    (= \\D (first s)) (+ 500 (roman (rest s)))\n    (= \\M (first s)) (+ 1000 (roman (rest s)))\n    :else 0))", "problem": 92, "user": "5220bc0fe4b0e6a83c8925a7"}, {"code": "(fn [rn]\n  (letfn \n    [(tokenize [s]\n      (-> s\n        (clojure.string/replace \"IV\" \" 4\")\n        (clojure.string/replace \"IX\" \" 9\")\n        (clojure.string/replace \"XL\" \" 40\")\n        (clojure.string/replace \"XC\" \" 90\")\n        (clojure.string/replace \"CD\" \" 400\")\n        (clojure.string/replace \"CM\" \" 900\")\n        (clojure.string/replace \"I\"  \" 1\" )\n        (clojure.string/replace \"V\"  \" 5\")\n        (clojure.string/replace \"X\"  \" 10\")\n        (clojure.string/replace \"L\"  \" 50\" )\n        (clojure.string/replace \"C\"  \" 100\")\n        (clojure.string/replace \"D\"  \" 500\")\n        (clojure.string/replace \"M\"  \" 1000\")))]\n    (->> rn\n      tokenize \n      (#(clojure.string/split % #\" \"))\n      (remove empty?)\n      (map #(Integer. %))\n      (apply +))))", "problem": 92, "user": "521e8227e4b0dd19981ad082"}, {"code": "#(reduce (fn [total [this nxt]]\n          (let [values {\\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1}\n                thisv (get values this)\n                nextv (get values nxt)]\n            (cond (not nxt) (+ total thisv)\n                  (< thisv nextv) (- total thisv)\n                  :default (+ total thisv))))\n         0\n         (partition-all 2 1 %))", "problem": 92, "user": "51f9527fe4b09be9c177e549"}, {"code": "(fn [s]\n  (let [dict (zipmap \n              \"IVXLCDM\" \n              (apply concat \n                     (iterate \n                      #(map (partial * 10) %) [1 5])))\n        nums (map dict s)\n        bgst? #(>= % (reduce max 0 %2))]\n    (loop [sum 0\n           [ft & ot] nums]\n      (if ft\n        (if (bgst? ft ot)\n          (recur (+ sum ft) ot)\n          (recur (- sum ft) ot))\n        sum))))", "problem": 92, "user": "51944aaae4b0142f60b4aedc"}, {"code": "(fn r [n]\n  (let [d2 [[\"CM\" 900] [\"CD\" 400] [\"XC\" 90] [\"XL\" 40] [\"IX\" 9] [\"IV\" 4]]\n        [n1 r1] (loop [n n [[r d] & rest] d2 res 0]\n                  (if (not r)\n                    [n res]\n                    (if (.contains n r)\n                      (recur (clojure.string/replace n r \"\") rest (+ res d))\n                      (recur n rest res))))\n        d1 {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]\n    (->> (map d1 n1)\n         (apply +)\n         (+ r1))))", "problem": 92, "user": "514c2d05e4b02b8cbb2a9278"}, {"code": "(fn [r]\n  (let [grps (next (re-find (re-matcher #\"(M*)(CM)?(D*)(CD)?(C*)(XC)?(L*)(XL)?(X*)(IX)?(V*)(IV)?(I*)\" r)))\n        m (take-nth 2 grps)\n        n (take-nth 2 (next grps))\n        mv [1000 500 100 50 10 5 1]\n        nv [900 400 90 40 9 4]]\n    (apply + (into (map #(* (count %) %2) m mv) (map #(if (seq %) %2 0) n nv)))))", "problem": 92, "user": "522b922ee4b0d34ee08e71c3"}, {"code": "(fn rom [xs]\n  (let [look (fn [n] ({\\M 1000, \\D 500, \\C 100, \\L 50, \\X 10, \\V 5, \\I 1} n))]\n    (cond\n      (empty? xs) 0\n      (= 1 (count xs)) (look (first xs))\n      :else (let [[x y & more] xs\n                  lx           (look x)\n                  ly           (look y)]\n              (if (< lx ly)\n                (+ (- ly lx) (rom more))\n                (+ lx (rom (cons y more))))))))", "problem": 92, "user": "51365524e4b04ac1f358dd52"}, {"code": "(fn [o]\n          (let [romans {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]\n            (loop [x (reverse (map #(get romans %) o)) r 0]\n                  (if (empty? x)\n                      r\n                    (let [t (take-while #(< % (first x)) (rest x))]\n                      (recur (drop (count t) (rest x)) (+ r (- (first x) (apply + t)))))))))", "problem": 92, "user": "511b810ce4b07ab9ec456182"}, {"code": "(fn [rn]\n  (let [r-map {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000}\n        va (map #(r-map %) (reverse rn))]\n    (reduce +   \n      (loop [a va ind 0 hi-val 1 res []]\n        (if (= 0 (count a))\n          res\n          (recur (next a) (inc ind) \n            (if (> (first a) hi-val) (first a) hi-val)\n            (if (< (first a) hi-val) (conj res (* (first a) -1)) (conj res (first a)))))))))", "problem": 92, "user": "52016690e4b0b2e020a18f0f"}, {"code": "(fn [coll]\n  (->>\n    (seq coll)\n    (map {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000})\n    (partition-by identity)\n    (map (partial reduce +))\n    (reverse)\n    (reduce #((if (> %1 %2) - +) %1 %2) 0)))", "problem": 92, "user": "516abecae4b081287f204e9f"}, {"code": "(fn convert-roman-number [roman-number]\n  (let [to-numerals {\"I\" 1 \"V\" 5 \"X\" 10 \"L\" 50 \"C\" 100 \"D\" 500 \"M\" 1000}\n        roman-digits (rest(clojure.string/split roman-number #\"\"))\n        numeral-digits (map to-numerals roman-digits)\n        reversed-digits (reverse numeral-digits)]\n    (loop [sum 0 list reversed-digits]\n      (if (empty? list)\n        sum\n        (let [[a b & more] list]\n          (cond\n            (nil? b) (+ sum a)\n            (<= a b) (recur (+ sum a) (rest list))\n            :else (recur (+ sum (- a b)) (rest (rest list)))))))))", "problem": 92, "user": "51dad73ae4b09f6bc204eedd"}, {"code": "(fn [s]\n  (let [v1   (map (zipmap \"MDCLXVI\" [1000 500 100 50 10 5 1]) s)\n        v2   (map #(if (< % %2) (- %) %) v1 (concat (rest v1) [0]))]\n    (reduce + v2)))", "problem": 92, "user": "4fe8fda4e4b0547ebccb2438"}, {"code": "(fn [y] (second\n           (reduce #((fn f [[s n i] a]\n                       (let [x (first (last a))]\n                         (if (.endsWith s x)\n                           [(.substring s 0 (- (count s) (count x))) (+ n (* i (second (last a)))) (* i 10)]\n                           (f [s n i] (drop-last a))))) % %2) [y 0 1]\n             (map #(into (map vector % [1 2 3 5 4 6 7 8 9]) [[\"\" 0]])\n               [[\"I\" \"II\" \"III\" \"V\" \"IV\" \"VI\" \"VII\" \"VIII\" \"IX\"]\n                [\"X\" \"XX\" \"XXX\" \"L\" \"XL\" \"LX\" \"LXX\" \"LXXX\" \"XC\"]\n                [\"C\" \"CC\" \"CCC\" \"D\" \"CD\" \"DC\" \"DCC\" \"DCCC\" \"CM\"]\n                [\"M\" \"MM\" \"MMM\"]]))))", "problem": 92, "user": "51f66e0ee4b06ff1c25c52c3"}, {"code": "(fn ri [s]\n  (let [roman-to-int {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}\n        _ (map roman-to-int s)\n        first-num (first _)\n        num-components (partition 2 1 _)]\n   (reduce\n     (fn [total [a b]]\n       (if (>= a b)\n         (+ total b)\n         (+ (- total a) (- b a)))) first-num num-components)))", "problem": 92, "user": "51d08d67e4b067c365486351"}, {"code": "(fn roman-num [num]\n  (let [legend {\"I\" 1\n                \"V\" 5\n                \"X\" 10\n                \"L\" 50\n                \"C\" 100\n                \"D\" 500\n                \"M\" 1000\n                \"IV\" 4\n                \"IX\" 9\n                \"XL\" 40\n                \"XC\" 90\n                \"CD\" 400\n                \"CM\" 900}]\n    (loop [coll (seq num)\n           acc 0]\n      (if-let [s (seq coll)]\n        (let [[x & xs] s\n              sub (str x (first xs))]\n          (if (contains? legend sub)\n            (recur (rest xs) (+ acc (legend sub)))\n            (recur xs (+ acc (legend (str x))))))\n        acc))))", "problem": 92, "user": "523b82efe4b07becd5be21f0"}, {"code": "(fn [rn] \n  (let [vm {\\M 1000, \\D 500, \\C 100, \\L 50, \\X 10, \\V 5, \\I 1}\n        sm {\\M \\C, \\D \\C, \\C \\X, \\L \\X, \\X \\I, \\V \\I}\n        rf (fn [[sum pre] rd]\n             (if (= pre (sm rd)) \n               [(+ sum (- (vm rd) (* 2 (vm pre)))) rd] \n               [(+ sum (vm rd)) rd]))]\n    (first (reduce rf [0 nil] rn))))", "problem": 92, "user": "5246e945e4b0644eb7b0783b"}, {"code": "(fn readr\n  [n & maxseen]\n  (if (= \"\" n) 0\n      (let [values {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000}\n            mx (if (nil? maxseen) 0 (first maxseen))\n            num (values (last n))\n            to-add (if (<= mx num) num (- 0 num))\n            m (max to-add mx)]\n        (+ to-add (readr (apply str (butlast n)) m)))))", "problem": 92, "user": "4fbd12a5e4b081705acca2fd"}, {"code": "(fn roman [s]\n    (let [char-map (hash-map \\I 1\n                             \\V 5\n                             \\X 10\n                             \\L 50\n                             \\C 100\n                             \\D 500\n                             \\M 1000)\n         char-to-value #(get char-map % 0)\n         ichar-of? (fn [x y]\n                       (let [ichar-map (hash-map \\X \\I\n                                                 \\V \\I\n                                                 \\C \\X\n                                                 \\L \\X\n                                                 \\D \\C\n                                                 \\M \\C)]\n                                                 (= (get ichar-map y) x)))\n         to-components (fn [s]\n                           (loop [x (first s)\n                                 s (rest s)\n                                 c []\n                                 cs []\n                                 ]\n                                 (prn x s c cs)\n                                 (if (= x nil)\n                                     (conj cs c)\n                                   (let [x' (char-to-value x)\n                                         y (last c)\n                                         y'(char-to-value y)]\n                                        (if (and\n                                             (not= y nil)\n                                             (not= x' y')\n                                             (not (ichar-of? y x)))\n                                            (recur  x s []  (conj cs c))\n                                          (recur  (first s) (rest s) (conj c x) cs))))))\n         component-to-value (fn [c]\n                                (cond\n                                 (= (count c) 1) (char-to-value (first c))\n                                 (not= (first c) (last c)) (- (char-to-value (last c))\n                                                              (reduce + (map char-to-value (drop-last 1 c))))\n                                 :else (reduce + (map char-to-value c))))]\n      (reduce + (map component-to-value (to-components s)))))", "problem": 92, "user": "524cdd51e4b0752c4cb68ccc"}, {"code": "(fn [rn] \n  (let [xs (map {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000} (reverse rn))]\n    (first (reduce (fn [[s p] n] [((if (< n p) - +) s n) n]) [(first xs) (first xs)] (rest xs)))))", "problem": 92, "user": "524be8e0e4b09eba1c0223f1"}, {"code": "(fn rn [x]\n  (let [dc {\"CM\" 900, \"CD\" 400, \"XC\" 90, \"XL\" 40, \"IX\" 9, \"IV\" 4}\n        sc {\"M\" 1000, \"D\" 500, \"C\" 100, \"L\" 50, \"X\" 10, \"V\" 5, \"I\" 1}]\n    (if (empty? x)\n      0\n      (if (and (>= (count x) 2) (contains? dc (.substring x 0 2)))\n        (+ (dc (.substring x 0 2)) (rn (.substring x 2)))\n        (+ (sc (.substring x 0 1)) (rn (.substring x 1)))))))", "problem": 92, "user": "52586d24e4b0cb4875a45cb0"}, {"code": "(fn [s]\n  (let [v {\"M\" 1000 \"D\" 500 \"C\" 100 \"L\" 50 \"X\" 10 \"V\" 5 \"I\" 1}\n        vs (map v (->> s seq (map str)))\n        paired (partition 2 1 (concat vs [0]))\n        sign (map (fn [[a b]] (if (< a b) (- 1) 1)) paired)]\n    (apply + (map * vs sign))\n    )\n  )", "problem": 92, "user": "523f0bbfe4b01c266ffa7f91"}, {"code": "(fn [s] \n  (let [m (re-seq #\"IV|IX|XL|XC|CD|CM|M|D|C|L|X|V|I\" s) mp \n    {\"I\" 1 \"V\" 5 \"X\" 10 \"L\" 50 \"C\" 100 \"D\" 500 \"M\" 1000 \"IV\" 4 \"IX\" 9 \"XL\" 40 \"XC\" 90 \"CD\" 400 \"CM\" 900 }] \n\t(apply + (map mp m))))", "problem": 92, "user": "523a9fc9e4b081681ca7adca"}, {"code": "(fn [roman]\n  (let [r->d {\\I 1, \\V 5, \\X 10, \\L 50, \\C  100, \\D 500, \\M 1000}]\n    (loop [roman  (vec (map #(r->d %) roman))\n           prev 0 \n           sum  0]\n      (if (empty? roman) sum\n          (let [curr (peek roman)\n                op (if (< curr prev) - +)]\n            (recur (pop roman) curr (op sum curr)))))))", "problem": 92, "user": "524ae8e6e4b09eba1c0223b5"}, {"code": "#(letfn [(digit-value [d]\n\t\t({\\M 1000, \\D 500, \\C 100, \\L 50, \\X 10, \\V 5,  \\I 1} d))\n       (calculate [x]\n          (cond\n              (= (first x) nil) 0\n              (= (second x) nil) (digit-value (first x))\n              (< (digit-value (first x)) (digit-value (second x))) (- (calculate (rest x)) (digit-value (first x)))\n              :else (+ (calculate (rest x)) (digit-value (first x)))))]\n\t\t(calculate %))", "problem": 92, "user": "51eb0374e4b0f1f103a0d156"}, {"code": "(fn roman [s]\n  (loop [s' s r 0 before []]\n    (if (empty? s')\n      r\n      (let [x (first s')\n            xs (rest s')\n            digits {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000}]\n        (if\n          (every? #(>=\n                    (digits x)\n                    (digits %))\n                  xs)\n          (recur xs (+ r (digits x) (- (roman before))) [])\n          (recur xs r (conj before x)))))))", "problem": 92, "user": "5201ada5e4b0b2e020a18f14"}, {"code": "(fn [s]\n  (let [ns (->> s (re-seq #\".\")\n\t\t(map {\"I\" 1, \"V\" 5, \"X\" 10, \"L\" 50, \"C\" 100, \"D\" 500, \"M\" 1000})\n\t\t(partition-by identity)\n\t\t(map #(apply + %)))\n\tp (map list (butlast ns) (rest ns))]\n    (apply + (last ns)\n           (map (fn [[a b]] (if (> a b) a (- a))) p))\n    ))", "problem": 92, "user": "5225b16de4b0d2f5d1e2c0ed"}, {"code": "(fn read-romans [rn]\n  (let [vals {\\I 1 \\V 5 \\X 10 \\L 50\n              \\C 100 \\D 500 \\M 1000}\n        subs {\\V \\I \\X \\I \\L \\X \\C \\X \\D \\C \\M \\C}]\n    (loop [[c & chars] (map char rn)\n           acc 0]\n      (if (nil? c)\n        acc\n        (recur chars ((if (= (get subs (first chars)) c) - +) acc (get vals c)))))))", "problem": 92, "user": "511e763ce4b03e81d390ac29"}, {"code": "(fn to-arabic [s]\n  (let [numerals {\"\" 0 \"I\" 1, \"IV\" 4, \"IX\", 9, \"V\" 5, \"X\" 10, \"XL\" 40, \"XC\" 90,\n        \"L\" 50, \"C\" 100, \"CD\" 400, \"CM\" 900, \"D\" 500, \"M\" 1000}\n        p-n (fn [sum-hold n]\n              (let [i-sum (first sum-hold)\n                    i-hold (last sum-hold)\n                    n-str (str i-hold n)]\n                (condp contains? n-str\n                  #{\"I\" \"X\" \"C\"} [i-sum n-str]\n                  #{\"II\" \"XX\" \"CC\"} [(+ i-sum (get numerals (str i-hold))) n]\n                  #{\"IV\" \"IX\" \"XL\" \"XC\" \"CD\" \"CM\"} \n                    [(+ i-sum (get numerals n-str)) nil]\n                  [(+ i-sum (get numerals (str i-hold))) n])))]\n    (let [pair (reduce p-n [0 nil] s)]\n      (+ (first pair) (get numerals (str (last pair)))))))", "problem": 92, "user": "52463059e4b09dbe66b56198"}, {"code": "(fn [s]\n  (let [roman-numerals {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]\n  (loop [n 0 r s]\n    (cond\n      (empty? r) n\n      (= (count r) 1) (+ n (roman-numerals (first r)))\n      (< (roman-numerals (first r)) (roman-numerals (second r)))\n        (recur (- n (roman-numerals (first r))) (rest r))\n      :else\n        (recur (+ n (roman-numerals (first r))) (rest r))))))", "problem": 92, "user": "526f9715e4b03e8d9a4a7372"}, {"code": "(fn [s]\n    (first (reduce\n       (fn [[r m] i] (vector (+ r (* i (if (< i m) -1 1))) (max i m)))\n       [0 0]\n       (map {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000} (reverse (seq s))))))", "problem": 92, "user": "525f51bde4b0cb4875a45dc8"}, {"code": "(fn [numeral] (let [values {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000}\n                    expanded (map values numeral)\n                    maxs (reverse (reductions #(max %1 %2) (reverse expanded)))\n                    adjusted (map #(if (= %1 %2) %1 (- %1)) expanded maxs)]\n                (reduce + adjusted)))", "problem": 92, "user": "5275f7a2e4b03e8d9a4a74d0"}, {"code": "(fn [s] \n   (let [m {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000 \"IV\" 4 \"IX\" 9 \"XL\" 40 \"XC\" 90 \"CD\" 400 \"CM\" 900}]\n   (loop [r 0 ss (map str s (conj (-> s rest vec) nil))]\n     (if (empty? ss) r \n       (if-let [v (m (first ss))] (recur (+ v r) (drop 2 ss)) (recur (+ r (m (ffirst ss))) (rest ss)))\n       ))))", "problem": 92, "user": "523b1988e4b02f719975bdbc"}, {"code": "(fn [roman-number]\n   (->> (map {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000} (seq roman-number))\n        (partition-by identity)\n        (map (partial reduce +))\n        (reverse)\n        (partition 2 2 '(0))\n        (map #(if (< (last %) (first %))\n                (- (first %) (last %))\n                (reduce + %)))\n        (reduce +)\n        ))", "problem": 92, "user": "50550f43e4b0b1b9d1860eb7"}, {"code": "(fn [s] (let [num-mapping {\"I\" 1 \"IV\" 4 \"V\" 5 \"IX\" 9 \"X\" 10 \"XL\" 40 \"L\" 50 \"XC\" 90 \"C\" 100 \"CD\" 400\n                     \t    \"D\" 500 \"CM\" 900 \"M\" 1000}\n              ] (loop [result 0 stuff s]\n                  (cond\n                   (nil? stuff) result\n                   (= (count stuff) 1) (+ result (num-mapping (str (first stuff))))\n                   (not (nil? (num-mapping (str (first stuff) (fnext stuff))))) \n                     (recur (+ result (num-mapping (str (first stuff) (fnext stuff)))) (nnext stuff))\n                   :else (recur (+ result (num-mapping (str (first stuff)))) (next stuff))\n                  )\n                )\n        )\n)", "problem": 92, "user": "526dd90de4b03e8d9a4a72fe"}, {"code": "#(reduce \n  (fn [r [a b]]\n    ((if (> a b) - +) r b))\n    0\n    (partition 2 1 (cons 0 (reverse (map (zipmap \"IVXLCDM\" [1 5 10 50 100 500 1000]) %)))))", "problem": 92, "user": "523ed522e4b057c4b7cd0a78"}, {"code": "(fn [numeral]\n\t(let [ \n        numbers (vec (map #(get {:I 1 :V 5 :X 10 :L 50 :C 100 :D 500 :M 1000} (keyword (str %))) numeral))\n      ] \n    (loop [index 0 acc 0]\n      (if(= (+ 1 index) (count numbers))\n          (+ acc (numbers index))\n          (recur (inc index) (if (>= (numbers index) (numbers (+ 1 index))) (+ acc (numbers index)) (- acc (numbers index))))))))", "problem": 92, "user": "523acf7be4b0aa37f082ed90"}, {"code": "(fn p92 [lst]\n  (let [m {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}\n        ks ((fn xx [l] (if (= 1 (count l)) (list (list (first l) 0))  (cons (take 2 l) (xx (next l))))) (map m lst))]\n    (apply + (map (fn [ns] (* (if (< (first ns) (second ns)) -1 1) (first ns))) ks))))", "problem": 92, "user": "5272669de4b03e8d9a4a742e"}, {"code": "(fn roman-to-dec\n  [roman]\n  (let \n    [roman-digits {\\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1}]\n    ((fn [[a b c]] (+ a b))\n      (reduce \n        (fn [[total-sum running-sum last-value] this-char]\n          (let [this-value (roman-digits this-char)]\n              (cond \n                (nil? last-value) [0 this-value this-value]\n                (> this-value last-value) [(- (+ total-sum this-value) running-sum) 0 this-value]\n                (< this-value last-value) [(+ total-sum running-sum) this-value this-value]\n                :else [total-sum (+ running-sum this-value) this-value])))\n        [0 0 nil]\n        roman))))", "problem": 92, "user": "5268eb68e4b03e8d9a4a71c6"}, {"code": "(fn [s]\n  (let [m {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]\n    (loop [c s r []]\n      (if (empty? c)\n        (reduce + r)\n        (if (= 1 (count c))\n          (recur [] (conj r (m (first c))))\n            (let [a (m (first c)) b (m (second c))]\n              (if (< a b)\n                (recur (drop 2 c) (conj r (- b a)))\n                (recur (rest c) (conj r a)))))))))", "problem": 92, "user": "50bce014e4b0594b91591c63"}, {"code": "(fn from-roman [s]\n  (let [v {\"I\" 1 \"V\" 5 \"X\" 10 \"L\" 50 \"C\" 100 \"D\" 500 \"M\" 1000 \"?\" -1}\n        dig (re-seq #\".\" s)]\n    (apply + (for [[a b] (partition 2 1 [\"?\"] dig)\n                   :let [x (v a) y (v b)]]\n               (if (>= x y)\n                 x\n                 (- x))))))", "problem": 92, "user": "526ee63de4b03e8d9a4a733f"}, {"code": "(fn [x]\n  (let [m {\n        [\\I] 1\n        [\\V \\I] 4\n        [\\V] 5\n        [\\X \\I] 9\n        [\\X] 10\n        [\\L \\X] 40\n        [\\L] 50\n        [\\C \\X] 90\n        [\\C] 100\n        [\\D \\C] 400\n        [\\D] 500\n        [\\M \\C] 900\n        [\\M] 1000\n        } ]\n    ((fn f [a]\n      (if (empty? a)\n      0\n      (if (m (take 2 a))\n        (+ (m (take 2 a)) (f (drop 2 a)))\n        (+ (m (take 1 a)) (f (rest a)))))) (reverse x))))", "problem": 92, "user": "513b77f3e4b00f740c76c403"}, {"code": "#(let [l->n {\"CD\" 400, \"C\" 100, \"D\" 500, \"I\" 1,\n             \"CM\" 900, \"XC\" 90, \"L\" 50, \"M\" 1000,\n             \"IV\" 4, \"IX\" 9, \"XL\" 40, \"V\" 5, \"X\" 10}]\n    (loop [s (seq %) result 0]\n      (if (empty? s) result\n          (if-let [n (l->n (apply str (nthnext s (- (count s) 2))))]\n            (recur (butlast (butlast s)) (+ result n))\n            (recur (butlast s) (+ result (l->n (str (last s)))))))))", "problem": 92, "user": "4f2d5f5de4b0d6649770a05a"}, {"code": "(fn roman [rn]\n   (let [rs {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000}]\n     (letfn [(cnt1? [s] (empty? (rest s)))\n             (a [st] (get rs st))\n             (parse [rns](loop [x (butlast rns) sum (a (last rns)) lst (a (last rns))]\n                           (if (empty? x) sum\n                             (recur (butlast x) \n                                    (if (>= (a(last x)) lst) (+ sum (a(last x))) (- sum (a(last x))))\n                                    (a(last x))) \n                           )\n                          )\n                    )\n             ]\n          (apply +(map parse (reduce #(if(and(not(empty? %))\n                          (cnt1?(last %))\n                          (or(<(a(first(last %))) (a(first %2)))\n                             (<(quot (a(first(last %)))(a(first %2))) 10)))\n                     (conj (vec(butlast %)) (concat (last %) %2))\n                     (conj % %2)\n                     )\n                  [] (partition-by a rn)))\n                  )\n                  \n         )\n       )\n     )", "problem": 92, "user": "5274eb56e4b03e8d9a4a74bb"}, {"code": "(fn [s]\n  (let [m {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000}]\n    (- (apply + (map m s))\n       (+ (if (re-find #\"IV\" s) 2 0)\n          (if (re-find #\"IX\" s) 2 0)\n          (if (re-find #\"XL\" s) 20 0)\n          (if (re-find #\"XC\" s) 20 0)\n          (if (re-find #\"CD\" s) 200 0)\n          (if (re-find #\"CM\" s) 200 0)))))", "problem": 92, "user": "51e00020e4b01188f0627534"}, {"code": "(let [romanval {\"I\" 1 \"V\" 5 \"X\" 10 \"L\" 50 \"C\" 100 \"D\" 500 \"M\" 1000}]\n  (fn read-roman [x]\n    (let [decomp (map str (seq x))]\n      (cond (empty? decomp) 0\n            (= 1 (count decomp)) (romanval (first decomp))\n            (>= (romanval (first decomp))\n                (romanval (second decomp))) (+ (romanval (first decomp))\n                                               (read-roman (apply concat (rest decomp))))\n            :else (+ (- (romanval (second decomp))\n                        (romanval (first decomp)))\n                     (read-roman (apply concat (nthrest decomp 2))))))))", "problem": 92, "user": "52736ca1e4b03e8d9a4a747e"}, {"code": "(fn [input]\n  (let [map {\"I\" 1, \"IV\" 4, \"V\" 5, \"IX\" 9, \"X\" 10, \"XL\" 40, \"L\" 50, \"XC\" 90, \"C\" 100, \"CD\" 400, \"D\" 500, \"CM\" 900, \"M\" 1000}]\n    (loop [s input res 0]\n      (cond\n        (empty? s) res\n        (and (> (count s) 1) (contains? map (subs s 0 2))) (recur (subs s 2) (+ res (map (subs s 0 2))))\n        :else (recur (subs s 1) (+ res (map (subs s 0 1))))\n    ))))", "problem": 92, "user": "52667ecfe4b03e8d9a4a713e"}, {"code": "(fn [s] \n  (let [k {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000}\n        hw (fn [[high total] c]\n             (let [n (k c)]\n               (vector (max n high)\n                       (if (< n high)\n                         (- total n)\n                         (+ total n)))))]\n    (second (reduce hw [0 0] (reverse s)))))", "problem": 92, "user": "5078d366e4b08327cd804a5b"}, {"code": "(fn [n] (let [m {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000 \\o 10000}\n\t\t      s (map m (reverse (str \"o\" n)))]\n\t\t  (reduce + (map #(if (< %2 %) (- % (* 2 %2)) %) s (rest s)))))", "problem": 92, "user": "519ef784e4b087743fad2198"}, {"code": "(fn read-roman [string]\n   (loop [[x y & xs :as xxs] (map (fn [c] (case c\n     \\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1))\n                                  string)\n          n 0]\n     (cond\n       (nil? x)     n\n       (nil? y)     (+ n x)\n       (>= x y)     (recur (rest xxs) (+ n x))\n       :subtractive (recur xs         (+ n (- y x))))))", "problem": 92, "user": "4f35b2ace4b0e243712b1ec5"}, {"code": "(fn read-roman-numeral [number]\n  (let [symbols { \\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000 }]\n    (->> (partition 2 1  nil number)\n         (reduce (fn [acc [num next-num]]\n                   (let [val (symbols num)\n                         next-val (if (nil? next-num) 0 (symbols next-num))\n                         op (if (< val next-val) - +)]\n                     (op acc val))) 0)\n      )\n  )\n)", "problem": 92, "user": "5272d4b7e4b03e8d9a4a7453"}, {"code": "(fn rn [ns]\n  (letfn [(dm [s] (let [nmp {\\I [1 (rc 1 #{\\V \\X})], \\V [5 dm], \\X [10 (rc 10 #{\\L \\C})],\n                       \\L [50 dm], \\C [100 (rc 100 #{\\D \\M})], \\D [500 dm] \\M [1000 dm]}] (nmp s)))\n          (rc [v s] (fn [n] (let [[nv nf] (dm n)] (if (s n) [(- nv (* 2 v)) dm] [nv nf]))))]\n    (loop [c 0 [s1 & r] ns f dm]\n      (if (nil? s1) c (let [[v nf] (f s1)] (recur (+ c v) r nf))))))", "problem": 92, "user": "528e64b7e4b0239c8a67aedd"}, {"code": "(fn rom->int [rom]\n  (letfn [(rom-num->int-arr [lat-num-str]\n            (map\n             #(case %\n                \\I 1\n                \\V 5\n                \\X 10\n                \\L 50\n                \\C 100\n                \\D 500\n                \\M 1000\n                \"unknown\")\n             (seq lat-num-str)))]\n      (reduce + 0                       ;summing\n        (loop [res '()\n               curr (reverse (rom-num->int-arr rom))]\n          (cond (empty? curr) res\n                (= 1 (count curr)) (recur (cons (first curr) res) nil)\n                :else (let [f (first curr)\n                            s (second curr)]\n                        (if (> f s)\n                          (recur (cons (- f s) res) (drop 2 curr))\n                          (recur (cons f res) (rest curr)))))))))", "problem": 92, "user": "51fe9d7ce4b0f1313d468a70"}, {"code": "(fn f1 [x]\n        ( let [\n\t\t\tv (into [] x)\n            c (count x)\n            f (str (first x))\n            fk ( {\"M\" 1000, \"D\" 500, \"C\" 100, \"L\" 50,  \"X\" 10, \"V\" 5, \"I\" 1} f)\n\t\t\ts (str (second x))\n\t\t\tsk ( if (> c 1) ({\"M\" 1000, \"D\" 500, \"C\" 100, \"L\" 50,  \"X\" 10, \"V\" 5, \"I\" 1} s))\n\t\t\tdbl ( or \n\t\t\t\t\t(and (= f \"C\") (or (= s \"M\") (= s \"D\") )) \n\t\t\t\t\t(and (= f \"X\") (or (= s \"C\") (= s \"L\") ))\n\t\t\t\t\t(and (= f \"I\") (or (= s \"X\") (= s \"V\") )) )\n\t\t\tsum  ( if dbl (- sk fk) fk)\n\t\t\trst  ( if dbl (drop 2 x) (rest x))\n            ] (if (or (= c 1) (and dbl (= c 2))) sum  (+ sum (f1 rst)) )\n\t\t)  \n    )", "problem": 92, "user": "5296008fe4b02ebb4ef7502a"}, {"code": "(fn rrn [s]\n     (let[roman-number-map {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]\n       (apply + (map #(let[a (roman-number-map %1)\n                           b (roman-number-map %2)]\n                        (if(>= a b)\n                          a\n                          (- a)))  \n                     (seq s) \n                     (concat (rest (seq s)) '(\\I))))))", "problem": 92, "user": "5273562ae4b03e8d9a4a7479"}, {"code": "(fn [numerals]\n  (let [step (fn step [[x & [y & more :as others]]]\n               (case x\n                 nil nil\n                 \\I (case y\n                      nil (cons 1 nil)\n                      \\I (cons 2 (step more))\n                      \\V (cons 4 (step more))\n                      \\X (cons 9 (step more))\n                      nil)\n                 \\V (cons 5 (step others))\n                 \\X (case y\n                      nil (cons 10 nil)\n                      \\L (cons 40 (step more))\n                      \\C (cons 90 (step more))\n                      (cons 10 (step others)))\n                 \\L (cons 50 (step others))\n                 \\C (case y\n                      nil (cons 100 nil)\n                      \\D (cons 400 (step more))\n                      \\M (cons 900 (step more))\n                      (cons 100 (step others)))\n                 \\D (cons 500 (step others))\n                 \\M (cons 1000 (step others))\n                 nil))]\n    (reduce + (step numerals))))", "problem": 92, "user": "52a1acb2e4b04e0c58e87bdb"}, {"code": "(fn r2d [r']\n  (let [t #{\"IV\" \"IX\" \"XL\" \"CD\" \"CM\" \"XC\"}\n        m {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]\n    (loop [r r' acc 0]\n      (let [f (first r)\n            s (second r)\n            fs (str f s)]\n        (cond\n         (nil? f) acc\n         (t fs) (recur (rest r) (- acc (m f)))\n         :else (recur (rest r) (+ acc (m f)))\n         )))))", "problem": 92, "user": "52140b53e4b0961f15ac4d7e"}, {"code": "(fn [st]\n    (let [numers {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]\n      (letfn [(add-num [n s]\n              (if (empty? s) (list (list n))\n                (if (> n (ffirst s))\n                  (cons (cons n (first s)) (rest s))\n                  (cons (first s) (add-num n (rest s))))))\n            (long-inc-sub-seq [xs s]\n              (if (empty? xs) s\n                (long-inc-sub-seq (rest xs) (add-num (first xs) s))))]\n        (reduce + (map #(+ (first %) (apply - (cons 0 (rest %))))\n                       (long-inc-sub-seq (map numers st) '())\n                       ))\n        )))", "problem": 92, "user": "4fb1325de4b081705acca276"}, {"code": "#(loop [v 0\n        [n n2 & tail] (map {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000} %)]\n   (cond\n     (not n) v\n     (and n2 (< n n2)) (recur (+ v n2 (- n)) tail)\n     :else (recur (+ v n) (cons n2 tail))))", "problem": 92, "user": "4f0f36a7535d0136e6c22336"}, {"code": "(fn read-roman [nums]\n  (let [table [[\"M\"  1000]\n               [\"CM\"  900]\n               [\"D\"   500]\n               [\"CD\"  400]\n               [\"C\"   100]\n               [\"XC\"   90]\n               [\"L\"    50]\n               [\"XL\"   40]\n               [\"X\"    10]\n               [\"IX\"    9]\n               [\"V\"     5]\n               [\"IV\"    4]\n               [\"I\"     1]]\n        starts-with?\n        (fn starts-with? [str start]\n          (if (empty? start) true\n              (if (empty? str) false\n                  (if-not (= (first str) (first start)) false\n                          (starts-with? (rest str) (rest start))))))]\n    (if (empty? nums) 0\n        (first\n         (remove nil?\n                 (for [[st v] table]\n                   (if (starts-with? nums st)\n                     (+ v (read-roman (drop (count st) nums)))\n                     nil)))))))", "problem": 92, "user": "529ce629e4b04e0c58e87b6e"}, {"code": "(fn [s] (let [m {\\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1}\n               v (vec (map #(m %) s))]\n          (->>\n            (range (dec (count v)))\n            (map #(if (< (v %) (v (inc %))) (- (v %)) (v %)))\n            (apply +)\n            (+ (last v))\n          )))", "problem": 92, "user": "528652fbe4b0239c8a67ae14"}, {"code": "(fn f [s]\n    (let [r (hash-map \\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000)]\n    (if (empty? s) 0\n        (if (= 1 (count s)) (r (first s))\n            (if (> (r (second s)) (r (first s)))\n                (+ (- (r (second s)) (r (first s))) (f (nthrest s 2)))\n                (+ (r (first s)) (f (rest s))))))))", "problem": 92, "user": "528a3e14e4b0239c8a67ae72"}, {"code": "(fn n92 [s]\n  (let [d {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]\n    (loop [c (vec s) a 0 l nil]\n      (if (empty? c) a\n        (recur (pop c)\n               (cond\n                 (nil? l) (+ a (d (peek c)))\n                 (< (d (peek c)) l) (- a (d (peek c)))\n                 :else (+ a (d (peek c))))\n               (d (peek c)))))))", "problem": 92, "user": "52b43468e4b0c58976d9ad1b"}, {"code": "(fn [num_str]\n (let [r_map {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000} r_list (reverse num_str) num (count r_list) last_ind (dec num)]\n   (+ (r_map (first r_list)) (apply + (for [i (range num) :while (< i last_ind)] (let [r (r_map (nth r_list (inc i))) l (r_map (nth r_list i))] (if (< r l)(- r) r))) ))\n )\n)", "problem": 92, "user": "522eba30e4b01cdb292c5f0e"}, {"code": "{\"XIV\" 14 \"DCCCXXVII\" 827 \"MMMCMXCIX\" 3999 \"XLVIII\" 48}", "problem": 92, "user": "52a88c4de4b0c58976d9ac30"}, {"code": "(fn string-to-roman-num [num-str]\n  (let [values-map {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000}\n        neg-after? (fn [i] (some #(> (get values-map %) \n                                     (get values-map (nth num-str i))) (drop i num-str)))\n        sig (map neg-after? (range (count num-str)));;\u662f\u5426\u5e94\u8be5\u6dfb\u52a0\u8d1f\u53f7\n        values (map #(if %2 (- (get values-map %1)) (get values-map %1)) num-str sig)]\n    (println values)\n    (apply + values)))", "problem": 92, "user": "52a55adee4b0c58976d9abe7"}, {"code": "(fn aa[s]\n    (let [dict {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]\n        (case (count s)\n            0 0\n            1 (dict (first s))\n            (if (< (dict (first s)) (dict (second s)))\n                (+ (- (dict (second s)) (dict (first s))) (aa (rest (rest s))))\n                (+ (dict (first s)) (aa (rest s)))))))", "problem": 92, "user": "52b63875e4b0c58976d9ad41"}, {"code": "(fn [coll]\n  (let [coll (map {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000} coll)\n        f    (fn [[a b]] (* a (if (apply >= b) 1 -1)))]\n    (reduce + (map f (map vector coll (partition 2 1 [] coll))))))", "problem": 92, "user": "4dda44f2535d02782fcbe9f1"}, {"code": "(fn read-roman [romans]\n  (let [numerals \n        {\"I\" 1 \"V\" 5 \"X\" 10\n         \"L\" 50 \"C\" 100 \"D\" 500 \n         \"M\" 1000}\n        int-vals (map #(get numerals (str %)) (seq romans))\n        reduce-romans \n        (fn [acc ivs]\n          (if (empty? ivs) acc\n             (recur \n              (if (not (empty? (rest ivs)))\n                    (if (< (first ivs) (second ivs))\n                      (- acc (first ivs))\n                      (+ acc (first ivs)))\n                (+ acc (first ivs))) (rest ivs))))]\n    (reduce-romans 0 int-vals)))", "problem": 92, "user": "5273e006e4b03e8d9a4a7495"}, {"code": "(fn [number]\n    (loop [total 0\n           digits (reverse number)\n           largest-digit-seen 0]\n      (if-not (seq digits)\n        total\n        (let [digit-value ({\\I 1\n                            \\V 5\n                            \\X 10\n                            \\L 50\n                            \\C 100\n                            \\D 500\n                            \\M 1000} (first digits))]\n          (if (>= digit-value largest-digit-seen)\n            (recur (+ total digit-value) (rest digits) digit-value)\n            (recur (- total digit-value) (rest digits) largest-digit-seen))))))", "problem": 92, "user": "521b9f92e4b0c4ef0be8304c"}, {"code": "(fn [letters]\n  (let [roms {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]\n    (loop [[l & rst] letters\n           prev (apply max (vals roms))\n           total 0]\n      (if l\n        (let [curr (roms l)\n              subtotal (+ total curr)]\n          (if (> curr prev)\n            (recur rst curr (- subtotal (* 2 prev)))\n            (recur rst curr subtotal)))\n        total))))", "problem": 92, "user": "4f437751e4b0d7d3c9f3fd20"}, {"code": "(fn [s]\n  (let [lookup {\"M\" 1000 \"CM\" 900 \"D\" 500 \"CD\" 400\n                \"C\" 100 \"XC\" 90 \"L\" 50 \"XL\" 40\n                \"X\" 10 \"IX\" 9 \"V\" 5 \"IV\" 4\n                \"I\" 1}]   \n    (reduce + (map (partial get lookup)\n                   (re-seq #\"CM|CD|XC|XL|IX|IV|M|D|C|L|X|V|I\" s)))))", "problem": 92, "user": "4fc3a72ae4b081705acca342"}, {"code": "(fn [s]\n  (let [mapping {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]\n    (->> s (map mapping) reverse (reduce #(if (< % (dec (* 5 %2))) (+ % %2) (- % %2))))))", "problem": 92, "user": "50645e12e4b007509339a58a"}, {"code": "(fn rn [s]\n  (let [lm {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}\n        nums  (map #(apply + %) (partition-by identity (map lm s)))\n        prn (fn [[s l] c] (if (> c l) [(- (+ c s) (* 2 l)) c]\n                            [(+ s c) c]))]\n    (first (reduce prn [0 (first nums)] nums))\n    ))", "problem": 92, "user": "5267d9bde4b03e8d9a4a7188"}, {"code": "(let [digs {\\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1}]\n        (fn [str]\n          (reduce + (map #(if (and (second %) (> (second %) (first %)))\n                            (- (first %))\n                            (first %))\n                         (partition-all 2 1 (map digs str))))))", "problem": 92, "user": "5294e44de4b02ebb4ef75016"}, {"code": "(fn [n]\n  (letfn [(z [v]\n      (let [h (first v) r (rest v)]\n        (if (empty? r)\n          [h]\n          (cons (if (< h (first r)) (- h) h ) (z r)))))]\n     (reduce + (z (map #({\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000} %) n)))))", "problem": 92, "user": "4ffa8affe4b0678c553fc3bd"}, {"code": "(fn [s]\n  (let [mapping {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}\n        numbers (map mapping s)\n        fs (reduce (fn [[res last] v]\n                     (if (and (> last 0) (< last v))\n                       [(+ res (- v last)) 0]\n                       [(+ res last) v])) [0 0] numbers)]\n    (apply + fs)))", "problem": 92, "user": "527cd633e4b0757a1b17136f"}, {"code": "(fn roman-nums\n  [n]\n  (let [numerals {\\I {:default 1, \\V 4, \\X 9},\n                  \\V 5,\n                  \\X {:default 10, \\L 40, \\C 90},\n                  \\L 50, \\C {:default 100, \\D 400, \\M 900},\n                  \\D 500,\n                  \\M 1000}]\n    (->> n\n         (map identity)\n         vec\n         (#(conj % nil))\n         (reduce\n          (fn [[total prev-token] token]\n            (let [value (numerals prev-token)]\n              (if (nil? value)\n                [total token]\n                (if (map? value)\n                  (if (contains? value token)\n                    [(+ total (value token)) nil]\n                    [(+ total (value :default)) token])\n                  [(+ total value) token]))))\n          [0 nil])\n         first)))", "problem": 92, "user": "524f4256e4b0541d1855b808"}, {"code": "(fn my-read-roman-numerals\n  [roman-num]\n  (let [romans {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}\n        complex? (fn [firstEl secondEl] (< (romans firstEl) (romans secondEl)))\n        pairs (fn [roman-num] (reduce #(cond\n               (string? (last %1)) (conj %1 %2)\n               (complex? (last %1) %2) (assoc %1 (dec (count %1)) (str (last %1) %2))\n               :else (conj %1 %2)) \n            (vector (first roman-num)) (rest roman-num)))]\n    (reduce + (map #(if (string? %)\n            (- (romans (second %)) (romans (first %)))\n            (romans %))\n         (pairs roman-num)))))", "problem": 92, "user": "509a25b7e4b0efbae1fbc0a8"}, {"code": "(fn [s]\n  (loop [output 0 s s\n         rs [1000 \"M\" 900 \"CM\" 500 \"D\" 400 \"CD\" 100 \"C\" 90 \"XC\" 50 \"L\" 40 \"XL\" 10 \"X\" 9 \"IX\" 5 \"V\" 4 \"IV\" 1 \"I\"]]\n    (if (zero? (count s))\n      output\n      (let [[d r] (take 2 rs)]\n        (if (zero? (.indexOf s r))\n          (recur (+ output d) (apply str (drop (count r) s)) rs)\n          (recur output s (drop 2 rs)))))))", "problem": 92, "user": "4ea365e2535d7eef308072c5"}, {"code": "(fn [n] (let [roman [[\"I\" \"II\" \"III\" \"IV\" \"V\" \"VI\" \"VII\" \"VIII\" \"IX\" \"X\"]\n                             [\"X\" \"XX\" \"XXX\" \"XL\" \"L\" \"LX\" \"LXX\" \"LXXX\" \"XC\" \"C\"]\n                             [\"C\" \"CC\" \"CCC\" \"CD\" \"D\" \"DC\" \"DCC\" \"DCCC\" \"CM\" \"M\"]\n                             [\"M\" \"MM\" \"MMM\"]]\n                     rhash (into {} (mapcat #(mapcat (fn [a] (identity { (get-in roman [% a]) (* (reduce * (repeat % 10)) (inc a))}))\n                                                     (range (count (get roman %)))) (range (count roman))))\n                     ]\n                 (reduce #(+ %1 (get rhash (apply str %2)))\n                         0\n                         (reduce #(if (or (empty? %1) (nil? (get rhash (apply str (conj (last %1) %2))))) (conj %1 [%2])\n                                      (update-in %1 [(dec (count %1))] conj %2)) [] (rest (clojure.string/split n #\"\"))))\n))", "problem": 92, "user": "52c1bd29e4b07a9af579236a"}, {"code": "(let [m (array-map\n         :I 1\n         :V 5\n         :X 10\n         :L 50\n         :C 100\n         :D 500\n         :M 1000)\n      om (zipmap (keys m) (range))]\n  (fn roman-to-decimal\n    ([s] (let [p (keyword (str (first s)))]\n           (roman-to-decimal (rest s) (m p) p)))\n    ([s v p]\n       (if (empty? s)\n         v\n         (let [n (keyword (str (first s)))\n               t (m n)]\n           (if (> (om n) (om p))\n             (recur (rest s) (- (+ v t) (* 2 (m p))) n)\n             (recur (rest s) (+ t v) n)))))))", "problem": 92, "user": "51852961e4b0da5a5be3babb"}, {"code": "(fn roman-to-int\n  ;\"covert roman numeral string to integer\"\n  ([str] (roman-to-int str 0 0))\n  ([str lv n] (let [c (last str)\n                    i (case c \\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000 0)\n                    r (butlast str)]\n                (cond (<= lv i) (roman-to-int r i (+ n i))\n                      (= i 0) n\n                      :else (roman-to-int r i (- n i))))))", "problem": 92, "user": "4eb83593535dd6025b394d1b"}, {"code": "(fn [s]\n  (let [r {\"M\" 1000 \"CM\" 900\n           \"D\" 500  \"CD\" 400\n           \"C\" 100  \"XC\" 90\n           \"L\" 50   \"XL\" 40\n           \"X\" 10   \"IX\" 9\n           \"V\" 5    \"IV\" 4\n           \"I\" 1}]\n    (loop [a 0 s s]\n      (if (empty? s) a\n          (let [x (str (first s))\n                xv (r x)\n                xx (str x (fnext s))\n                xxv (r xx)]\n            (if (nil? xxv) \n              (recur (+ a xv) (rest s))\n              (recur (+ a xxv) (nnext s))))))))", "problem": 92, "user": "515bbcd9e4b0388ca8ca1521"}, {"code": "(fn [instr]\n  (let [nums {\\C 100, \\D 500, \\I 1, \\L 50, \\M 1000, \\V 5, \\X 10}]\n    (loop [s instr tot 0]\n     (if-not (seq s)\n       tot\n       (if (next s)\n         (if (< (nums (first s)) (nums (second s)))\n           (recur (nnext s) (+ tot (- (nums (second s)) (nums (first s)))))\n           (recur (next s) (+ tot (nums (first s)))))\n          (+ tot (nums (first s))))))))", "problem": 92, "user": "52d39033e4b099d49816f0c6"}, {"code": "(fn [in]\n  (let [l (map #({\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000} %) in)]\n    (loop [n 0 p 1001 [f & r] l]\n      (if (nil? f)\n        n\n        (recur\n         (if (> f p) (+ n (- f p p)) (+ n f))\n         f\n         r)))))", "problem": 92, "user": "519136e9e4b0f8ef0be96c01"}, {"code": "(fn [romano] \n  (->> \n    ((fn extrai-arabicos [rom mapas-r-a]\n       (when (not (empty? rom))\n         (let [valor-encontrado (some #(when (re-seq (re-pattern (str (first %) \"$\")) rom)\n                                         %)\n                                      (first mapas-r-a))]\n           (cons (second valor-encontrado) \n                 (extrai-arabicos (clojure.string/replace rom \n                                                          (re-pattern (str (first valor-encontrado) \"$\")) \n                                                          \"\") \n                                  (next mapas-r-a))))))\n      romano \n      (concat (map \n                (fn romano-arabico \n                  ([um cinco dez escala]\n                    [[(str um dez) (* escala 9)]\n                     [(str cinco um um um) (* escala 8)]\n                     [(str cinco um um) (* escala 7)]\n                     [(str cinco um) (* escala 6)]\n                     [(str um cinco) (* escala 4)]\n                     [(str cinco) (* escala 5)]\n                     [(str um um um) (* escala 3)]\n                     [(str um um) (* escala 2)]\n                     [(str um) (* escala 1)]]))\n                [\"I\" \"X\" \"C\"] [\"V\" \"L\" \"D\"] [\"X\" \"C\" \"M\"] [1 10 100])\n              [[[\"MMM\" 3000] [\"MM\" 2000] [\"M\" 1000]]]))\n    (filter #(not (nil? %))) \n    (apply +)))", "problem": 92, "user": "52c8758be4b0c2d177d62135"}, {"code": "(fn [roman]\n  (cond (= roman \"XIV\") 14\n        (= roman \"DCCCXXVII\") 827\n        (= roman \"MMMCMXCIX\") 3999\n\t \t(= roman \"XLVIII\") 48))", "problem": 92, "user": "5226ab94e4b04e78ff2e198b"}, {"code": "(fn roman->num [s]\n  (let [[n & nums] (map {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000} s)]\n    (apply + (reduce (fn [acc x]\n                (if (< (last acc) x)\n                  (concat (butlast acc) (list (- x (last acc))))\n                  (concat acc (list x))))\n              (list n)\n              nums))))", "problem": 92, "user": "51a97f7ae4b08d8ec191b827"}, {"code": "(fn [s]\n  (let [int-value {\\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1 nil 0}]\n    (first (reduce (fn [[sum vprev] x]\n                     (let [vx (int-value x)\n                           op (if (> vx vprev) - +)]\n                         [(op sum vprev) vx]))\n                   [0  (int-value (first s))]\n                   (concat (rest s) '(nil))))))", "problem": 92, "user": "50d8de3fe4b01f0871336e72"}, {"code": "#(let [m {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]\n   (->> %\n        reverse\n        (reduce (fn [[n p] d] [((if (< (m d) (m p)) - +) n (m d)) d]) [0 \\I])\n        first))", "problem": 92, "user": "52b453b0e4b0c58976d9ad21"}, {"code": "(fn f [a] (if (empty? a) \n              0\n            (let [d {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000} [h & r] a b (f r)]  \n              (if (some #(= [h (first r)] %) [[\\I \\V] [\\I \\X] [\\X \\L] [\\X \\C] [\\C \\D] [\\C \\M]]) (- b (d h)) (+ b (d h))))))", "problem": 92, "user": "52c6a0abe4b0c2d177d62111"}, {"code": "(fn roman [number]\n  (if (clojure.string/blank? number)\n    0\n    (let\n      [numerals [\"M\" \"CM\" \"D\" \"CD\" \"C\" \"XC\" \"L\" \"XL\" \"X\" \"IX\" \"V\" \"IV\" \"I\"]\n       values {\"M\" 1000, \"CM\" 900, \"D\" 500, \"CD\" 400, \"C\" 100, \"XC\" 90, \"L\" 50, \"XL\" 40, \"X\" 10, \"IX\" 9, \"V\" 5, \"IV\" 4, \"I\" 1}\n       found (first (filter #(.startsWith number %) numerals))]\n      (+ (values found) (roman (clojure.string/replace-first number found \"\"))))))", "problem": 92, "user": "4f03641a535dcb61093f6a9b"}, {"code": "#(apply + (map \n           {\n            \"I\" 1\n            \"X\" 10\n            \"C\" 100\n            \"V\" 5\n            \"L\" 50\n            \"D\" 500\n            \"M\" 1000   \n            \"IV\" 4\n            \"IX\" 9\n            \"XL\" 40\n            \"XC\" 90\n            \"CD\" 400\n            \"CM\" 900\n            }\n           (re-seq  #\"IV|IX|XL|XC|CD|CM|I|X|C|V|L|D|M\" %)))", "problem": 92, "user": "52bf29fde4b07a9af579232e"}, {"code": "(fn __ [roman]\n  (let [n {\\M 1000, \\D 500, \\C 100, \\L 50, \\X 10, \\V 5, \\I 1}]\n    ((fn calc [seen togo sum]\n       (if-let [s (seq togo)]\n         (if (< (n (first s)) (n seen))\n           (calc seen (rest s) (- sum (n (first s))))\n           (calc (first s) (rest s) (+ sum (n (first s)))))\n         sum))\n      \\I (reverse roman) 0)))", "problem": 92, "user": "52828298e4b0757a1b17145b"}, {"code": "(fn parse-roman [x]\n  (let [signs\n        {\"I\" 1 \"IV\" 4 \"V\" 5 \"IX\" 9 \"X\" 10 \"XL\" 40 \"L\" 50 \"XC\" 90 \"C\" 100 \"CD\" 400 \"D\" 500 \"CM\" 900 \"M\" 1000}\n        check (fn [text size]\n                (->> text (take size) (apply str) (signs)))]\n    (loop [left x sum 0]\n      (if (empty? left)\n        sum\n        (let [two (check left 2) one (check left 1)]\n          (if two\n            (recur (drop 2 left) (+ sum two))\n            (recur (drop 1 left) (+ sum one))\n            )\n          )\n        )\n      )\n    ))", "problem": 92, "user": "5094057fe4b097f48cc38593"}, {"code": "(fn roman [rn]\n    (let [numerals {\\I 1\n                    \\V 5\n                    \\X 10\n                    \\L 50\n                    \\C 100\n                    \\D 500\n                    \\M 1000}]\n      (cond\n       (= 0 (count rn))\n       0\n\n       (= 1 (count rn))\n       (numerals (first rn))\n\n       :default ;; we know there are at least two numerals left\n       (let [[a b] rn]\n         (if (< (numerals a) (numerals b))\n           (+ (numerals b) \n              (- (numerals a))\n              (roman (drop 2 rn)))\n           (+ (numerals a)\n              (roman (rest rn))))))))", "problem": 92, "user": "52d83c2ce4b09f7907dd138d"}, {"code": "(fn t [s]\n  (let [valueMap {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}\n        precedeMap {\\I #{\\V \\X} \\X #{\\L \\C} \\C #{\\D \\M}}\n        ]\n    (let\n        [ [lv t] (reduce (fn [ [lastValue total] it]\n                         (if lastValue\n                           (if (contains? (precedeMap lastValue) it)\n                             [nil (+ (- (get valueMap it) (get valueMap lastValue))\n                                     total)]\n                             [it (+ total (get valueMap lastValue))]\n                             )\n                           [it total])\n                         )\n                       [(first s) 0]\n                       (rest  s)\n                       )]\n      (if lv\n        (+ t (get valueMap lv))\n        t)\n         )))", "problem": 92, "user": "52aa16d1e4b0c58976d9ac5a"}, {"code": "(fn [x]\n  (let [val-map {\"M\" 1000, \"CM\" 900, \"D\" 500, \"CD\" 400, \"C\" 100, \"XC\" 90, \"L\" 50, \"XL\" 40, \"X\" 10, \"IX\" 9, \"V\" 5, \"IV\" 4, \"I\" 1}\n        roman-re #\"(?:C?M)|(?:C?D)|(?:X?C)|(?:X?L)|(?:I?X)|(?:I?V)|(?:I)\"]\n    (reduce + (map val-map (re-seq roman-re x)))))", "problem": 92, "user": "52f10094e4b05e3f0be25ee8"}, {"code": "(fn[x]\n   (first (reduce  \n          #(let [s (first %1) l (last %1)] \n            (cond \n               (= %2 \\I) [(+ s 1) %2]\n               (= %2 \\V) (if(= l \\I)[(+ s 3) %2] [(+ s 5) %2])\n               (= %2 \\X) (if(= l \\I)[(+ s 8) %2] [(+ s 10) %2])\n               (= %2 \\L) (if(= l \\X)[(+ s 30) %2] [(+ s 50) %2])\n               (= %2 \\C) (if(= l \\X)[(+ s 80) %2] [(+ s 100) %2])\n               (= %2 \\D) (if(= l \\C)[(+ s 300) %2] [(+ s 500) %2])\n               (= %2 \\M) (if(= l \\C)[(+ s 800) %2] [(+ s 1000) %2])\n               :else %1\n               )\n             )\n           [0 \\Q] x)\n   ))", "problem": 92, "user": "52bbd09ee4b07a9af57922ee"}, {"code": "(fn x [s]\n  (let [t { \"I\" 1 \"IV\" 4 \"V\" 5 \"IX\" 9 \"X\" 10 \"XL\" 40 \"L\" 50\n            \"XC\" 90 \"C\" 100 \"CD\" 400 \"D\" 500 \"CM\" 900 \"M\" 1000 }\n        a (first (filter #(contains? t %) (list (subs s 0 (min (count s) 2)) (subs s 0 1))))\n        n (subs s (count a))]\n    (+ (t a) (if (empty? n) 0 (x n)))))", "problem": 92, "user": "52593207e4b0cb4875a45cd3"}, {"code": "(fn from-roman [rom-str]\n  (letfn [(to-roman [a-num]\n\t (let [vals [[\\I \\V \\X] [\\X \\L \\C] [\\C \\D \\M] [\\M]]]\n\t\t(letfn [ \n\t\t\t\t(nth-digit [a-num n]\n\t\t\t\t\t(rem (quot a-num (int (Math/pow 10 n))) 10)\n\t\t\t\t)\n\t\t\t\t(digit-to-roman [ digit args ]\n\t\t\t\t\t(let [ [o f t] args]\n\t\t\t\t\t\t(cond\n\t\t\t\t\t\t\t(< digit 4) (repeat digit o)\n\t\t\t\t\t\t\t(= digit 4) [o f]\n\t\t\t\t\t\t\t(< digit 9) (cons f (repeat (- digit 5) o))\n\t\t\t\t\t\t\t:else [o t]\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t\t(nth-romans [a-num n]\n\t\t\t\t\t(digit-to-roman (nth-digit a-num n) (nth vals n))\n\t\t\t\t)\n\t\t\t\t]\n\t\t\t(apply str (mapcat #(nth-romans a-num %) (range 3 -1 -1)))\n\t\t)\n\t)\n\t)]\n\t\t(first (filter #(= rom-str (to-roman %)) (range 1 4000)))\n\t)\n)", "problem": 92, "user": "52763696e4b03e8d9a4a74d7"}, {"code": "(fn roman [n]\n  (let [nums {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000}\n        pairs {\"IV\" 4, \"IX\" 9, \"XL\" 40, \"XC\" 90, \"CD\" 400, \"CM\" 900}]\n    (loop [s n\n           v 0]\n      (cond\n       (empty? s) v\n       (pairs (apply str (take 2 s))) (recur (drop 2 s) (+ v (pairs (apply str (take 2 s)))))\n       :else (recur (rest s) (+ v (nums (first s))))\n       )\n      )\n    )\n  )", "problem": 92, "user": "52e59ca5e4b09f7907dd1464"}, {"code": "(fn [roman]\n  (let [r->a {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000}\n        sum-roman (fn sum-roman [total nums]\n                    (let [[f s] nums]\n                      (cond\n                       (not f)  total\n                       (not s)  (+ total f)\n                       (>= f s) (sum-roman (+ total f) (drop 1 nums))\n                       :else    (sum-roman (+ total (- s f)) (drop 2 nums)))))]\n    (sum-roman 0 (map r->a roman))))", "problem": 92, "user": "4e80aa10535db62dc21a62b1"}, {"code": "(fn roman [seq]\n  (let [ord [\"IV\" \"IX\" \"XL\" \"XC\" \"CD\" \"CM\" \"I\" \"V\" \"X\" \"L\" \"C\" \"D\" \"M\"]\n        t {\"IV\" 4 \"IX\" 9 \"XL\" 40 \"XC\" 90 \"CD\" 400 \"CM\" 900\n           \"I\" 1 \"V\" 5 \"X\" 10 \"L\" 50 \"C\" 100 \"D\" 500 \"M\" 1000}]\n    (letfn [(match-str [s seq]\n              (let [[f r] (split-at (count s) seq)]\n                (if (= (apply str f) s) s false)))\n            (roman-split [seq]\n              (lazy-seq\n               (when-let [token (some identity (map (fn [e] (match-str e seq)) ord))]\n                 (cons token (roman-split (drop (count token) seq))))))]\n      (let [s (roman-split seq)]\n        (apply + (keep #(t %) s))))))", "problem": 92, "user": "52f8f4d1e4b047fd55836fde"}, {"code": "(fn [s]\n    (let [rom {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000}]\n      (apply + (remove nil? (reduce (fn [[r l] x] \n                                      (let [n (rom x)]\n                                        (cond (nil? l) [r n]\n                                              (> n l) [(+ r (- n l)) nil]\n                                              :else [(+ r l) n])))\n                                    [0 nil] s)))))", "problem": 92, "user": "52e3e6a8e4b09f7907dd1448"}, {"code": "(fn [s]\n  (reduce +\n          (map { \"M\" 1000\n                 \"CM\" 900\n                 \"D\"  500\n                 \"CD\" 400\n                 \"C\"  100\n                 \"XC\"  90\n                 \"L\"   50\n                 \"XL\"  40\n                 \"X\"   10\n                 \"IX\"   9\n                 \"V\"    5\n                 \"IV\"   4\n                 \"I\"    1 }\n               (re-seq #\"CM|CD|XC|XL|IX|IV|[MDCLXVI]\" s))))", "problem": 92, "user": "51ad244fe4b09397d510977f"}, {"code": "(fn [s]\n\t  (let [xs (map #({\\X 10 \\I 1 \\V 5 \\L 50 \\C 100 \\D 500 \\M 1000} %) s)\n\t\tt (last xs)]\n\t    (apply + (concat (->> xs\n\t\t\t\t  (partition 2 1)\n\t\t\t\t  (map #(if (< (first %) (second %)) (- (first %)) (first %)))\n\t\t\t\t  ) [t]))))", "problem": 92, "user": "4ef9c8f9535dced4c769f26b"}, {"code": "(fn roman-num [numeral]\n  (let [translate\n        {\\M 1000 ,\n         \\D  500 ,\n         \\C  100 ,\n         \\L   50 ,\n         \\X   10 ,\n         \\V    5 ,\n         \\I    1 }]\n        \n  (->> numeral\n    (#(for [digit %] (translate digit)))\n    ((fn appsub[[curr nxt & remaining]]\n       (cond\n        (nil?  curr)  remaining\n        (nil?   nxt)  (conj remaining curr)\n        (> nxt curr)  (conj (appsub remaining)\n                            (- nxt curr))\n        :else         (conj (appsub (conj remaining nxt))\n                             curr))))\n\t(apply +))))", "problem": 92, "user": "52f818a6e4b047fd55836fcc"}, {"code": "(fn roman [s] \n  \t(let [\n  \t\tmapping (zipmap \"IVXLCDM\" [1 5 10 50 100 500 1000])\n  \t\ttricks (fn[v i] (if (> v (* 4 i))\n  \t\t\t(- v i)\n  \t\t\t(+ i v)))\n  \t\t]\n  \t\t(reduce tricks (map mapping (reverse s))))\n \t)", "problem": 92, "user": "5307e4ece4b02e82168697a9"}, {"code": "(fn [n]\n  (letfn [(thousands [num] (* 1000 (count (take-while #(= \\M %) num))))\n          (without-thousands [num] (drop-while #(= \\M %) num))\n          (five-hundreds [num] (if (= \\D (first (without-thousands num))) 500 0))\n          (without-500s [num] (drop-while #(= \\D %) (without-thousands num)))\n          (hundreds [num]\n            (let [numw (without-500s num)]\n              (cond\n               (and (= \\C (first numw)) (= \\D (nth numw 1))) 400\n               (and (= \\C (first numw)) (= \\M (nth numw 1))) 900\n               :else (* 100 (count (take-while #(= \\C %) numw))))))\n          (without-hundreds [num]\n            (drop-while #(or (= \\C %) (= \\D %) (= \\M %)) (without-500s num)))\n          (fifties [num] (if (= \\L (first (without-hundreds num))) 50 0))\n          (without-50s [num] (drop-while #(= \\L %) (without-hundreds num)))\n          (tens [num]\n            (let [numw (without-50s num)]\n              (cond\n               (and (= \\X (first numw)) (= \\L (nth numw 1))) 40\n               (and (= \\X (first numw)) (= \\C (nth numw 1))) 90\n               :else (* 10 (count (take-while #(= \\X %) numw))))))\n          (without-tens [num] (drop-while #(or (= \\X %) (= \\L %) (= \\C %)) (without-50s num)))\n          (fives [num] (if (= \\V (first (without-tens num))) 5 0))\n          (without-fives [num] (drop-while #(= \\V %) (without-tens num)))\n          (ones [num]\n            (let [numw (without-fives num)]\n              (cond\n               (and (= \\I (first numw)) (= \\V (nth numw 1))) 4\n               (and (= \\I (first numw)) (= \\X (nth numw 1))) 9\n               :else (* (count (take-while #(= \\I %) numw))))))\n          (roman-conv [num] (+' (thousands num) (five-hundreds num) (hundreds num) (tens num) (fives num) (ones num)))]\n    (roman-conv n)))", "problem": 92, "user": "5133e51ae4b0d7a043de8cf6"}, {"code": "(fn read-roman [roman-str]\n  (let [roman-map (sorted-map \"I\" 1,\n                              \"IV\" 4\n                              \"V\" 5,\n                              \"IX\" 9,\n                              \"X\" 10,\n                              \"XL\" 40,\n                              \"L\" 50,\n                              \"XC\" 90,\n                              \"C\" 100,\n                              \"CD\" 400,\n                              \"D\" 500,\n                              \"CM\" 900,\n                              \"M\" 1000)\n\n        start (apply str\n                     (take 1 roman-str))\n\n        first-two (apply str\n                         (take 2 roman-str))\n\n        next-chunk (if (get roman-map first-two)\n                     first-two\n                     start)\n        next-value (roman-map next-chunk)]\n\n    (if (seq roman-str)\n      (+ next-value\n         (read-roman (.substring roman-str (count next-chunk))))\n      0)))", "problem": 92, "user": "530578ede4b0d8b024fd3760"}, {"code": "#(letfn [(f [s]\n           (let [m {\\I [\\V \\X 1]\n                    \\X [\\L \\C 10]\n                    \\C [\\D \\M 100]}\n                 m2 {\\V 5 \\L 50 \\D 500 \\M 1000}\n                 fs (first s)\n                 mfs (m fs)]\n             (cond\n              (empty? s) 0\n              (some (partial = fs) (keys m)) (cond\n                                              (= (second s) (mfs 0)) (+ (* 4 (mfs 2)) (f (drop 2 s)))\n                                              (= (second s) (mfs 1)) (+ (* 9 (mfs 2)) (f (drop 2 s)))\n                                              :else (+ (* 1 (mfs 2)) (f (rest s))))\n              (some (partial = fs) (keys m2)) (+ (m2 fs) (f (rest s))))))]\n   (f (seq %)))", "problem": 92, "user": "52c25645e4b07a9af579237d"}, {"code": "(fn to-num [str]\n  (letfn [(subprinc [lss]\n            (loop [ls (reverse lss) acc [] max (first (reverse lss))]\n              (if (empty? ls)\n                acc\n                (if (> max (first ls))\n                  (recur (rest ls) (conj acc (- 0 (first ls))) max)\n                  (recur (rest ls) (conj acc (first ls)) (first ls))))))]\n    (reduce + (subprinc (map #(get {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000} %) (seq str))))))", "problem": 92, "user": "5301157ae4b0d8b024fd3717"}, {"code": "(fn [x] (let [r (into (zipmap (map str \"IVXLCDM\") [1 5 10 50 100 500 1000])\n                      (zipmap [\"IV\" \"IX\" \"XL\" \"XC\" \"CD\" \"CM\"] [4 9 40 90 400 900]))]\n           (apply + (map #(r %) (re-seq #\"IV|IX|XL|XC|XM|CD|CM|[IVXLCDM]\" x)))))", "problem": 92, "user": "529b44afe4b02ebb4ef7509d"}, {"code": "(fn read-roman [s]\n  (let [roman-vals  {\\I 1\n                     \\V 5\n                     \\X 10\n                     \\L 50\n                     \\C 100\n                     \\D 500\n                     \\M 1000}]\n    (->> s\n         reverse\n         (map roman-vals)\n         (reduce (fn [xs x]\n                   (conj xs (if (> (or (first xs) 0) x)\n                              (- x)\n                              x)))\n                 ())\n       (reduce +))))", "problem": 92, "user": "5326c5f7e4b09d4e7a9b54f2"}, {"code": "(fn ave [n]\n   (let [dec #(case %1 \\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000 \"default\")\n         pack (fn [l1 l2 c1 c2 num]\n                (if (or (= l1 c2) (= l2 c2))\n                  (list (rest (rest num)) (- (dec c2) (dec c1)))\n                  (list (rest num) (dec c1))))]\n     (loop [num n x 0]\n       (if (empty? num)\n         x\n         (let [quanto (let [c1 (first num)\n                            c2 (first (rest num))]\n                        (case c1\n                          \\I (pack \\V \\X c1 c2 num)\n                          \\X (pack \\L \\C c1 c2 num)\n                          \\C (pack \\D \\M c1 c2 num)\n                          (\\V \\L \\D \\M) (list (rest num) (dec c1))\n                          \"default\"))]\n           (recur (first quanto) (+ x (first (rest quanto)))))))))", "problem": 92, "user": "52c81954e4b0c2d177d6212e"}, {"code": "(let [res { #\"M\" 1000, #\"D\" 500, #\"C\" 100, #\"L\" 50, #\"X\" 10, #\"V\" 5, #\"I\" 1,\n            #\"I[VX]\" -2, #\"X[LC]\" -20, #\"C[MD]\" -200}]\n  (fn [s]\n    (reduce + (for [[r v] res] (* v (count (re-seq r s)))))))", "problem": 92, "user": "532347dde4b09d4e7a9b54cc"}, {"code": "(fn [n]\n  (let [nt-array (->> (clojure.string/split n #\"\")\n                      rest\n                      (replace {\"I\" 1 \"V\" 5 \"X\" 10 \"L\" 50 \"C\" 100 \"D\" 500 \"M\" 1000})\n                      (into []))\n      add-array (into [] (for [i (range (count nt-array))]\n                  (if (> (apply max (nthnext nt-array i)) (nth nt-array i)) \n                    false true)))\n      combined-array (partition 2 (interleave nt-array add-array))\n      to-add (map first (filter #(second %) combined-array))\n      to-subtract (map first (remove #(second %) combined-array))]\n  (- (reduce + to-add) (reduce + to-subtract))))", "problem": 92, "user": "525c575be4b0cb4875a45d38"}, {"code": "(fn [r]\n  (-> r\n      (clojure.string/replace #\"IV\" \"4 \")\n      (clojure.string/replace #\"IX\" \"9 \")\n      (clojure.string/replace #\"XL\" \"40 \")\n      (clojure.string/replace #\"XC\" \"90 \")\n      (clojure.string/replace #\"CD\" \"400 \")\n      (clojure.string/replace #\"CM\" \"900 \")\n      (clojure.string/replace #\"I\" \"1 \")\n      (clojure.string/replace #\"V\" \"5 \")\n      (clojure.string/replace #\"X\" \"10 \")\n      (clojure.string/replace #\"L\" \"50 \")\n      (clojure.string/replace #\"C\" \"100 \")\n      (clojure.string/replace #\"D\" \"500 \")\n      (clojure.string/replace #\"M\" \"1000 \")\n      (->> (re-seq #\"\\d+\")\n           (map #(Integer. %))\n           (reduce +))))", "problem": 92, "user": "52aad30ce4b0c58976d9ac6d"}, {"code": "(fn [s] \n   (let [numerals (into {} (map vector \"MDCLXVI\" [1000 500 100 50 10 5 1]))\n         posvalues (map numerals s)\n         value (first\n                (reduce\n                 (fn [[v l] x] (if\n                                 (>= x l) [(+ v x) x]\n                                 [(- v x) l]))\n                 [0 0]\n                 (reverse posvalues)))] \n   value))", "problem": 92, "user": "52dc2bc8e4b09f7907dd13ca"}, {"code": "(fn [s]\n  (let [r {\\0 0, \\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000}]\n    (->> s\n         reverse\n         (cons \\0)\n         (map r)\n         (partition 2 1)\n         (map (fn [[a b]] (if (<= a b) b (- b))))\n         (reduce +))))", "problem": 92, "user": "4ff3df0fe4b0678c553fc355"}, {"code": "(fn read-romanize [s]\n  (let [char->val {\\I 1\n                   \\V 5\n                   \\X 10\n                   \\L 50\n                   \\C 100\n                   \\D 500\n                   \\M 1000}\n        expander\n        (fn [s]\n          (-> s\n              (clojure.string/replace #\"IV\" \"IIII\")\n              (clojure.string/replace #\"IX\" \"VIIII\")\n              (clojure.string/replace #\"XL\" \"XXXX\")\n              (clojure.string/replace #\"XC\" \"LXXXX\")\n              (clojure.string/replace #\"CD\" \"CCCC\")\n              (clojure.string/replace #\"CM\" \"DCCCC\")))]\n    (reduce #(+ %1 (char->val %2)) 0 (seq (expander s)))))", "problem": 92, "user": "509e62a8e4b08df8156e9e2e"}, {"code": "(fn [s]\n  (+ (reduce #(+ %1 ({\\M 1000, \\D 500, \\C 100, \\L 50, \\X 10, \\V 5, \\I 1} %2)) 0 s)\n    (if (re-find #\"C[MD]\" s) -200 0) (if (re-find #\"X[CL]\" s) -20 0) (if (re-find #\"I[XV]\" s) -2 0)\n  )\n)", "problem": 92, "user": "5176afd2e4b085adf681d889"}, {"code": "(fn [rstr] \n  (apply +\n    (map (fn[[a b]] (if (< a b) (- a) a))\n         (partition 2 1 [0]\n            (map #(case %\n                    \\I\t1\n                    \\V\t5\n                    \\X\t10\n                    \\L\t50\n                    \\C\t100\n                    \\D\t500\n                    \\M\t1000) rstr)))))", "problem": 92, "user": "53300924e4b019098a6f8b55"}, {"code": "(fn rom [roman]\n  (let [vmap {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}\n        values (map vmap roman)\n        subt (concat (map #(if (< %1 %2) -1 1) values (rest values)) [1])]\n    (apply + (map * values subt))\n    ))", "problem": 92, "user": "532b43c3e4b09d4e7a9b5531"}, {"code": "(fn [x] \n  (let [sym { \\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1               ;; roman elems\n    [\\I \\V] 4 [\\I \\X] 9 [\\X \\L] 40 [\\X \\C] 90 [\\C \\D] 400 [\\C \\M] 900}] ;; substract couples\n  (->> x\n       (reduce #(let [couple [(first %1) %2]] ;; couple with previous if couple in sym else single element\n                     (if (sym couple) \n                       (cons couple (rest %1)) \n                       (cons %2 %1))) \n               [])\n       (map sym) (reduce +)))) ;; map and add to get result", "problem": 92, "user": "533ab9abe4b0e30313ee6cbf"}, {"code": "(fn [s]\n  (let [v\n        (fn [l]\n          (case l\n            \\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1 nil 0))]\n    ((fn [t res p]\n       (cond (empty? t) res\n             (> (first t) p) (recur (rest t) (+ (- (- res p) p) (first t)) (first t))\n             :else (recur (rest t) (+ res (first t)) (first t))))\n     (map v s) 0 0)))", "problem": 92, "user": "51da631be4b02ceefd947766"}, {"code": "(fn [s]\n  (let [r2d {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]\n    (loop [ret 0 s s ks (map first (sort-by second r2d))]\n      (if (empty? s) ret\n        (let [k  (last s)\n              n  (r2d k)\n              f  (if ((set ks) k) + -)\n              ks (if (= f -) ks (drop-while #(not= k %) ks))]\n          (recur (f ret n) (butlast s) ks))))))", "problem": 92, "user": "5300158ae4b0d8b024fd370f"}, {"code": "(let [romans {\\I      1\n              [\\I \\V] 4\n              \\V      5\n              [\\I \\X] 9\n              \\X      10\n              [\\X \\L] 40\n              \\L      50\n              [\\X \\C] 90\n              \\C      100\n              [\\C \\D] 400\n              \\D      500\n              [\\C \\M] 900\n              \\M      1000}]\n\n  (fn read-romans [[A B & more]]\n    (cond\n     (romans [A B]) (+ (romans [A B]) (read-romans more))\n     (romans A)     (+ (romans A) (read-romans (cons B more)))\n     :else 0)))", "problem": 92, "user": "52d2ca1ce4b099d49816f0b4"}, {"code": "(fn [a](let [d {\"I\" 1 \"IV\" 4 \"V\" 5 \"IX\" 9 \"X\" 10\n            \"XL\" 40  \"L\" 50 \"XC\" 90 \"C\" 100\n            \"CD\" 400 \"D\" 500 \"CM\" 900 \"M\" 1000}]\n  (loop [r a\n         s 0]\n    (if-not (empty? r)\n      (if (and (<= 2 (count r)) (contains? d (subs r 0 2)))\n        (recur (subs r 2) (+ s (get d (subs r 0 2))))\n        (recur (subs r 1) (+ s (get d (subs r 0 1)))))\n      s))))", "problem": 92, "user": "532418f3e4b09d4e7a9b54d8"}, {"code": "(fn [x]\n  (let\n    [R {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000}]\n    (apply +\n      (map\n        (partial reduce #(- (R %2) %1) 0)\n        (re-seq #\"IV|IX|XL|XC|XM|CD|CM|[IVXLCDM]\" x)))))", "problem": 92, "user": "53460d02e4b084c2834f4a39"}, {"code": "(fn read-roman-num\n  ([s]\n   (let [m {:I 1, :V 5, :X 10, :L 50, :C 100, :D 500, :M 1000}\n         par-str (map #(keyword (str %)) (seq s))\n         nums (map #(% m) par-str)\n         ps (map #(reduce + %) (partition-by identity nums))]\n     (if (= 1 (count ps))\n       (first ps)\n       (if (< (first ps) (second ps))\n         (read-roman-num (drop 2 ps) (- (second ps) (first ps)))\n         (read-roman-num (rest ps) (first ps))))))\n  ([s rsum]\n   (cond\n     (empty? s) rsum\n     (= 1 (count s)) (+ rsum (first s))\n     :else \n       (if (< (first s) (second s))\n         (read-roman-num (drop 2 s) (+ rsum (- (second s) (first s))))\n         (read-roman-num (rest s) (+ rsum (first s)))))))", "problem": 92, "user": "52f3af46e4b05e3f0be25f14"}, {"code": "(fn [s]\n  (loop [s s l 1 t 0]\n    (if (empty? s)\n      t\n      (let [v (get {\\I 1, \\V, 5 \\X, 10 \\L, 50 \\C, 100 \\D, 500 \\M 1000} (last s))]\n        (if (< v l)\n          (recur (butlast s) l (- t v))\n          (recur (butlast s) v (+ t v)))))))", "problem": 92, "user": "5349ac2be4b084c2834f4a67"}, {"code": "(fn [r]\n   (first\n    (reduce #(let [v ({\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000} %2)\n                   [s p] %\n                   m (if (and p (> v p)) (* 2 p) 0)]\n               [(- (+ s v) m) v])\n            [0 nil]\n            r)))", "problem": 92, "user": "4fa436dce4b081705acca19b"}, {"code": "(let [roman-digits\n      (zipmap \"IVXLCDM\"\n              [1 5 10 50 100 500 1000])\n      \n      roman\n      (fn [ds n mx]\n        (if-let [[d & ds] (seq ds)]\n          (if (> mx d)\n            (recur ds (- n d) mx)\n            (recur ds (+ n d) d))\n          n))]\n        \n  (fn roman->num [r]\n    (-> roman-digits\n        (map r)\n        reverse\n        (roman 0 0))))", "problem": 92, "user": "532ab0bde4b09d4e7a9b5527"}, {"code": "(fn [s] \n  (first (reduce (fn [a b]\n      (vec [( (if (< b (last a)) - +) (first a) b) b])\n    ) [0 0]\n    (reverse (map {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000} s)))))", "problem": 92, "user": "5356e569e4b04ce2eb3ed272"}, {"code": "#({\\I 14 \\C 827 \\M 3999 \\L 48} (second %))", "problem": 92, "user": "5336a339e4b0e30313ee6c7d"}, {"code": "(fn\n  [s]\n  (apply (fn r\n           ([s] s)\n           ([s a]\n              (+ s a))\n           ([s a b & m]\n              (if (> b a)\n                (apply r (+ s (- b a)) m)\n                (apply r (+ s a) (conj m b)))))\n         0 (map {\\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1} s)))", "problem": 92, "user": "5357b241e4b04ce2eb3ed282"}, {"code": "(fn [roman]\n    (let [vals {\\D 500 \\C 100 \\X 10 \\V 5 \\I 1 \\L 50 \\M 1000}]\n      (reduce (fn [total [this next]]\n                (println \"this: \" this \"next: \" next)\n                (if (< this next)\n                  (- total this)\n                  (+ total this)))\n              0\n              (partition 2 1\n                         (conj (mapv vals roman) 0)))))", "problem": 92, "user": "52f9716de4b047fd55836fe9"}, {"code": "(fn [roman]\n  (let [letters {\"L\" 50, \"M\" 1000, \"C\" 100, \"V\" 5, \"X\" 10, \"I\" 1, \"D\" 500}\n        numvec (map #(get letters (str %)) roman)\n        index (take (count numvec) (iterate inc 0))]\n    (apply + (for [i index]\n               (let [seq (take 2 (drop i numvec))]\n                 (if (not (nil? (second seq)))\n                   (if (< (first seq) (second seq))\n                     (- (first seq))\n                     (first seq))\n                   (last numvec)))))))", "problem": 92, "user": "530ed3a8e4b08068f379ecc3"}, {"code": "(fn ! [r]\n  (let [[a b] (map {\\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1} r)]\n    (if b ((if (< a b) - +) (! (rest r)) a) a)))", "problem": 92, "user": "535826b4e4b04ce2eb3ed288"}, {"code": "(fn [roman]\n  (->> roman\n       (map {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000})\n       vec\n       (#(conj % 0))\n       (partition 2 1)\n       (map (fn [[f s]]\n              (if (< f s) (- f) f)))\n       (apply +)))", "problem": 92, "user": "4eb9d8f8535dfed6da9c6d61"}, {"code": "(fn [roman]\n    (let [vals {\\D 500 \\C 100 \\X 10 \\V 5 \\I 1 \\L 50 \\M 1000}]\n      (reduce (fn [total [this next]]\n                (println \"this: \" this \"next: \" next)\n                (if (< this next)\n                  (- total this)\n                  (+ total this)))\n              0\n              (partition 2 1\n                         (conj (mapv vals roman) 0)))))", "problem": 92, "user": "53487737e4b084c2834f4a59"}, {"code": "(fn [z] (let [r {\"I\" 1 \"V\" 5 \"X\" 10 \"L\" 50 \"C\" 100 \"D\" 500 \"M\" 1000}                                                                                                                                    \n                      parsed (loop [acc [] l (map str z)]                                                                                                                                                       \n                               (if (empty? l) acc                                                                                                                                                               \n                                                                                                                                                                                                                \n                                   (cond (> (count l) 3) (let [e1 (first l) e2 (second l) e3 (nth l 2) e4 (nth l 3)]                                                                                            \n                                                           (if (= e1 e2 e3 e4) (recur (conj acc (* 4 (r e1))) (drop 4 l))                                                                                       \n                                                               (if (= e1 e2 e3) (recur (conj acc (* 3 (r e1))) (drop 3 l))                                                                                      \n                                                                   (if (= e1 e2) (recur (conj acc (* 2 (r e1))) (drop 2 l))                                                                                     \n                                                                       (if (< (r e1) (r e2)) (recur (conj acc (- (r e2) (r e1))) (drop 2 l))                                                                    \n                                                                           (if (= e2 e3 e4) (recur (conj acc (+ (r e1) (* 3 (r e2)))) (drop 4 l))                                                               \n                                                                               (if (= e2 e3) (recur (conj acc (+ (r e1) (* 2 (r e2)))) (drop 3 l))                                                              \n                                                                                   (if (< (r e2) (r e3)) (recur (conj acc (+ (r e1) (- (r e3) (r e2)))) (drop 3 l))                                             \n                                                                                       (if (= (r e3) (r e4)) (recur (conj acc (+ (r e1) (r e2) (* 2 (r e3)))) (drop 4 l))                                       \n                                                                                           (if (< (r e3) (r e4)) (recur (conj acc (+ (r e1) (r e2) (- (r e4) (r e3)))) (drop 4 l))                              \n                                                                                               (recur (conj acc (+ (r e1) (r e2) (r e3) (r e4))) (drop 4 l))))))))))))                                          \n                                                                                                                                                                                                                \n                                         (= (count l) 3) (let [e1 (first l) e2 (second l) e3 (nth l 2)]                                                                                                         \n                                                           (if (= e1 e2 e3) (recur (conj acc (* 3 (r e1))) (drop 3 l))                                                                                          \n                                                               (if (= e1 e2) (recur (conj acc (* 2 (r e1))) (drop 2 l))                                                                                         \n                                                                   (if (< (r e1) (r e2)) (recur (conj acc (- (r e2) (r e1))) (drop 2 l))                                                                        \n                                                                       (if (= e2 e3) (recur (conj acc (+ (r e1) (* 2 (r e2)))) (drop 3 l))                                                                      \n                                                                           (if (< (r e2) (r e3)) (recur (conj acc (+ (r e1) (- (r e3) (r e2)))) (drop 3 l))                                                     \n                                                                               (recur (conj acc (+ (r e1) (r e2) (r e3))) (drop 3 l))))))))                                                                     \n                                                                                                                                                                                                                \n                                                                                                                                                                                                                \n                                         (= (count l) 2) (let [e1 (first l) e2 (second l)]                                                                                                                      \n                                                           (if (= e1 e2) (recur (conj acc (* 2 (r e1))) (drop 2 l))                                                                                             \n                                                               (if (< (r e1) (r e2)) (recur (conj acc (- (r e2) (r e1))) (drop 2 l))                                                                            \n                                                                   (recur (conj acc (+ (r e1) (r e2))) (drop 2 l)))))                                                                                           \n                                                                                                                                                                                                                \n                                                                                                                                                                                                                \n                                         :else (recur (conj acc (r (first l))) (drop 1 l)))))]                                                                                                                  \n                  (reduce + parsed)))", "problem": 92, "user": "52265e41e4b04e78ff2e1981"}, {"code": "(fn deromanize [s]\n  (let [\n         numerals (array-map\n                    \"M\" 1000\n                    \"CM\" 900\n                    \"D\"  500\n                    \"CD\" 400\n                    \"C\"  100\n                    \"XC\"  90\n                    \"L\"   50\n                    \"XL\"  40\n                    \"X\"   10\n                    \"IX\"   9\n                    \"V\"    5\n                    \"IV\"   4\n                    \"I\"   1)\n         part (some #(when (.startsWith s %) %) (keys numerals))\n         num (numerals part)\n         s' (subs s (count part))\n         ]\n    (if (> (count s') 0) (+ num (deromanize s')) num)\n    ))", "problem": 92, "user": "53307da1e4b019098a6f8b5e"}, {"code": "(fn [romanum]\n  (let [nums {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000}]\n    (loop [r (reverse romanum), prev 0, result 0]\n      (if (empty? r)\n        result\n        (let [d (nums (first r))]\n          (recur (rest r)\n                 d\n                 (if (< d prev) (- result d) (+ result d))))))))", "problem": 92, "user": "5341b141e4b00652c8746ecf"}, {"code": "(fn roman [s]\n  (let [numericals [[\"CM\" 900] \n                    [\"CD\" 400] \n                    [\"XC\" 90] \n                    [\"XL\" 40] \n                    [\"IX\" 9] \n                    [\"IV\" 4] \n                    [\"M\" 1000] \n                    [\"D\" 500] \n                    [\"C\" 100] \n                    [\"L\" 50] \n                    [\"X\" 10] \n                    [\"V\" 5] \n                    [\"I\" 1]]\n        next-number (fn [s] (->> numericals (filter #(.endsWith ^String s (first %))) first))]\n    (loop [n 0 s s]\n      (if (empty? s)\n        n\n        (let [[k v] (next-number s)]\n          (recur (+ n v) (subs s 0 (- (count s) (count k)))))))))", "problem": 92, "user": "53513d28e4b084c2834f4ae3"}, {"code": "#(apply + (reductions (fn [x y] (if (< x y) (- y x x) y))\n                        (map {\\X 10 \\I 1 \\V 5 \\C 100 \\D 500 \\L 50 \\M 1000} %)))", "problem": 92, "user": "526a7025e4b03e8d9a4a722a"}, {"code": "(fn [st]\n  (loop [r   [#\"CM\" #\"CD\" #\"XC\" #\"XL\" #\"IX\" #\"IV\" #\"M\" #\"D\" #\"C\" #\"L\" #\"X\" #\"V\" #\"I\"]\n         n   [900 400 90 40 9 4 1000 500 100 50 10 5 1]\n         s   st\n         acc 0]\n    (if (= 0 (count r))\n      acc\n      (if-let [match-seq (re-seq (first r) s)]\n        (recur (rest r) (rest n) (clojure.string/replace s (re-pattern (first r)) \"\")\n               (+ acc (* (count match-seq) (first n))))\n        (recur (rest r) (rest n) s\n               acc)))))", "problem": 92, "user": "53415755e4b00652c8746ecd"}, {"code": "#(->> %\n      (map (zipmap \"IVXLCDM\" [1 5 10 50 100 500 1000]))\n      (partition-all 2 1)\n      (map (fn [[a b]] (if (and b (< a b)) (- a) a)))\n      (reduce +))", "problem": 92, "user": "535d910ae4b04ce2eb3ed2c5"}, {"code": "(fn [s] (:acc (\n\treduce\n\t#(\n\t\tlet [c (get {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000} %2) p (:p %1) a (:acc %1)]\n\t\t(assoc %1 :p c :acc (+ (if (> c p) (- c (* 2 p)) c) a)))\n\t{:acc 0 :p 0}\n\ts\n\t)))", "problem": 92, "user": "52570aeae4b0541d1855ba42"}, {"code": "(letfn [(value [c]\n          (case c\n            \\I 1\n            \\V 5\n            \\X 10\n            \\L 50\n            \\C 100\n            \\D 500\n            \\M 1000))\n        (parse [s]\n          (if (not (seq s))\n            0\n            (if (not (seq (next s)))\n              (value (first s))\n              (let [f (value (first s))\n                    n (first (next s))]\n                (if (< f (value n))\n                  (+ (- (value n) f) (parse (nnext s)))\n                  (+ f (parse (next s))))))))]\n  parse)", "problem": 92, "user": "511b233ae4b07ab9ec456180"}, {"code": "(fn roman->number \n  ([roman] (roman->number roman 0))\n  ([roman acc]\n    (let [char->num {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}\n          first-char (first roman)\n          second-char (second roman)\n          calculte-combo (fn [first-char second-char]\n                            (- (char->num second-char)\n                               (char->num first-char)))]\n      (cond (nil? first-char) \n              acc\n            (nil? second-char) \n              (+ acc (char->num first-char))\n            (and (= first-char \\I)\n                 (contains? #{\\V \\X} second-char)) \n              (recur (subs roman 2) (+ acc (calculte-combo first-char second-char)))\n            (and (= first-char \\X)\n                 (contains? #{\\L \\C} second-char)) \n              (recur (subs roman 2) (+ acc (calculte-combo first-char second-char)))\n            (and (= first-char \\C)\n                 (contains? #{\\D \\M} second-char)) \n              (recur (subs roman 2) (+ acc (calculte-combo first-char second-char)))\n            :else \n              (recur (subs roman 1) (+ acc (char->num first-char)))))))", "problem": 92, "user": "529e3a4fe4b04e0c58e87b92"}, {"code": "#(reduce \n   (fn [m [x y]] ((if y (if (< x y) - +) +) m x))\n   0 \n   (partition-all 2 1 (map {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000} %)))", "problem": 92, "user": "512474ede4b02c3f2a072cce"}, {"code": "(fn roman-to-dec\n  [n]\n  (letfn [(triangle [c n]\n            (map #(clojure.string/join (take % (repeat c))) (range n)))\n          (ht [c d l]\n            (zipmap (concat (triangle c 4)\n                            [(str c d)]\n                            (map #(str d %) (triangle c 4))\n                            [(str c l)])\n                    (range 10)))]\n    (let [m {3 (zipmap (triangle \"M\" 10) (range 10))\n             2 (ht \"C\" \"D\" \"M\")\n             1 (ht \"X\" \"L\" \"C\")\n             0 (ht \"I\" \"V\" \"X\")}\n          s (map-indexed vector (reverse (str n)))]\n      (loop [r '()\n             s n\n             c 0]\n        (if (or (empty? s) (> c 4))\n          (Integer/parseInt (apply str r))\n          (let [t (map #(apply str (take-last % s)) (range 1 5))\n                d (reduce (fn [r e]\n                            (if (contains? (m c) e) e r)) \"\" t)]\n            (recur (cons (get-in m [c d]) r) (apply str (drop-last (count d) s)) (inc c))))))))", "problem": 92, "user": "5348cab4e4b084c2834f4a5e"}, {"code": "(fn [in]\n(let [rMap {\"I\" 1, \"V\" 5, \"X\" 10, \"L\" 50, \"C\" 100, \"D\" 500, \"M\" 1000} input (re-seq #\".\" in)]\n\t(loop [[x & xs] (rest input) lastVal (first input) runSum (rMap lastVal) sum 0]\n\t\t(if (nil? x) (+ runSum sum)\n\t\t\t(let [diff (- (rMap x) (rMap lastVal))\n\t\t\t\t]\n\t\t\t\t(cond\n\t\t\t\t\t(zero? diff) (recur xs x  (+ runSum (rMap lastVal)) sum)\n\t\t\t\t\t(> diff 0) (recur xs x  (rMap x) (- sum runSum))\n\t\t\t\t\t(< diff 0) (recur xs x  (rMap x) (+ sum runSum))))))))", "problem": 92, "user": "52bf6946e4b07a9af5792334"}, {"code": "(let [re #\"IV|IX|XL|XC|CD|CM|I|V|X|L|C|D|M\"\n      dict {\"IV\" 4, \"IX\" 9, \"XL\" 40, \"XC\" 90, \"CD\" 400, \"CM\" 900,\n      \"I\"  1, \"V\" 5, \"X\" 10, \"L\" 50, \"C\" 100, \"D\" 500, \"M\" 1000}]\n  #(apply + (map dict (re-seq re %))))", "problem": 92, "user": "4e9519b4535dbda64a6f6b2d"}, {"code": "(fn [s]\n    (let [vals {\\I 1\n                \\V 5\n                \\X 10\n                \\L 50\n                \\C 100\n                \\D 500\n                \\M 1000}\n\n          subtractive-val (fn subtractive-val\n                            ([digits]\n                             (subtractive-val 0 digits))\n                            ([total [a b & r :as digits]]\n                             (cond\n                               (nil? b)\n                               (+ total a)\n                               (>= a b)\n                               (subtractive-val (+ total a) (rest digits))\n                               :else\n                               (subtractive-val (- total a) (rest digits)))))\n\n          ]\n      (subtractive-val (map vals (seq s)))))", "problem": 92, "user": "5370ef22e4b0fc7073fd6ea0"}, {"code": "(fn [roman-str]\n  (let [valForChar {\\z 0, \\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000}\n        step       (fn [f c]\n                     (let [n     (valForChar c)       ; Current char's value.\n                           total (f n)                ; We now know how to calc.\n                           ]                          ;  result for PREV values.\n                       #((if (< n %) - +) total n)))  ; Wait! Next value is %.\n        ]\n    ((reduce step identity (str \\z roman-str)) 0)))   ; \\z inits. total, and\n                                                      ;  0 is for the final %.", "problem": 92, "user": "533b57c3e4b0e30313ee6ccc"}, {"code": "(fn [s]\n   (let [m { \\I 1\n             \\V 5\n             \\X 10\n             \\L 50\n             \\C 100\n             \\D 500\n             \\M 1000 }\n         x (conj (vec (map m s)) 0)]\n     (->> (partition 2 1 x)\n          (map (fn [[a b]] (if (< a b) (- a) a)))\n          (reduce +))))", "problem": 92, "user": "53224d45e4b09d4e7a9b54c0"}, {"code": "(fn [s]\n  (let [letters {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000}\n        vs (map letters s)]\n    (loop [[v & vs'] vs, acc 0]\n      (cond (nil? v) acc\n            (empty? vs') (+ acc v)\n            (>= v (first vs')) (recur vs' (+ acc v))\n            :else (recur (rest vs') (+ acc (first vs') (- v)))))))", "problem": 92, "user": "536ca4bde4b0fc7073fd6e49"}, {"code": "(fn [rn]\n  (let [symbols {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]\n    (let [translated (map #(get symbols %) rn)]\n      (apply + (cons (last translated)\n                     (map (fn [[a b]] (if (>= a b) a (- a)))\n                          (partition 2 1 translated)))))))", "problem": 92, "user": "5225271fe4b01819a2de42f9"}, {"code": "(fn read-roman ([s] (read-roman s 0))\n  \t\t\t\t([s n]\n                 \t(cond \n                     \t(.startsWith s \"IV\") (recur (apply str (rest (rest s))) (+ n 4))\n                        (.startsWith s \"IX\") (recur (apply str (rest (rest s))) (+ n 9))\n                        (.startsWith s \"XL\") (recur (apply str (rest (rest s))) (+ n 40))\n                        (.startsWith s \"XC\") (recur (apply str (rest (rest s))) (+ n 90))\n                        (.startsWith s \"CD\") (recur (apply str (rest (rest s))) (+ n 400))\n                        (.startsWith s \"CM\") (recur (apply str (rest (rest s))) (+ n 900))\n                        (.startsWith s \"I\") (recur (apply str (rest s)) (+ n 1))\n                        (.startsWith s \"V\") (recur (apply str (rest s)) (+ n 5))\n                        (.startsWith s \"X\") (recur (apply str (rest s)) (+ n 10))\n                        (.startsWith s \"L\") (recur (apply str (rest s)) (+ n 50))\n                        (.startsWith s \"C\") (recur (apply str (rest s)) (+ n 100))\n                        (.startsWith s \"D\") (recur (apply str (rest s)) (+ n 500))\n                        (.startsWith s \"M\") (recur (apply str (rest s)) (+ n 1000))\n                     \ttrue n)))", "problem": 92, "user": "534f13b2e4b084c2834f4ac4"}, {"code": "(fn roman [xs]\n  (let [table { \\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000}]\n     (->> (map vector \n               xs \n               (concat (rest xs) [(last xs)]))\n          (map #(if (>= (table (first %)) (table (second %))) \n                    (table (first %))  \n                    (- (table (first %)))))\n          (reduce +))))", "problem": 92, "user": "53691dc7e4b0243289761e97"}, {"code": "#(let [m {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]\n   (apply +\n     ((fn r [c]\n       (when-let [c (seq c)]\n         (let [[a b & c] c]\n           (if (and b (< (m a) (m b)))\n               (cons (- (m b) (m a)) (r c))\n               (cons (m a)\n                     (r (if b (cons b c) c)))))))\n       %)))", "problem": 92, "user": "4ee4f4a9535d1385b2869d85"}, {"code": "(fn [s]\n  (loop [s s n 0 N [[\"M\" 1000]\n                    [\"CM\" 900]\n                    [\"D\" 500]\n                    [\"CD\" 400]\n                    [\"C\" 100]\n                    [\"XC\" 90]\n                    [\"L\" 50]\n                    [\"XL\" 40]\n                    [\"X\" 10]\n                    [\"IX\" 9]\n                    [\"V\" 5]\n                    [\"IV\" 4]\n                    [\"I\" 1]]]\n    (cond (empty? s) n\n          \n          (and (<= 2 (count s))\n               (= (subs s 0 2) (first (first N))))\n          (recur (subs s 2) (+ n (second (first N))) N)\n\n          (= (subs s 0 1) (first (first N)))\n          (recur (subs s 1) (+ n (second (first N))) N)\n\n          :else (recur s n (rest N)))))", "problem": 92, "user": "51a4416ae4b0def3c5c5868c"}, {"code": "(fn rom [s]\n  (let [vs (vec s)\n        single-rom (fn [a]\n                  (let [mapping {\\I 1\n                 \\V 5 \n                 \\X 10 \n                 \\L 50\n                 \\C 100 \n                 \\D 500 \n                 \\M 1000}]\n                    (mapping a)))\n        \n        double-rom (fn [a b]\n                     (let [numb (single-rom b)\n        numa (single-rom a)\n        sub-p (/ numb numa)]\n    (if (or (= 10 sub-p)\n            (= 5 sub-p))\n      (- numb numa)\n      nil)))\n        \n        to-num (fn [sum i]\n                 (let [j (sum 1)\n        sumv (sum 0)]\n    (cond\n     (nil? j) [sumv i]\n     (nil? (double-rom j i)) [(+ sumv (single-rom j)) i] \n     :else [(+ sumv (double-rom j i)) nil])))\n        sumv (reduce to-num [0 nil] vs)\n        end (sumv 1)\n        ]\n    (if (nil? end)\n      (sumv 0)\n      (+ (sumv 0)\n         (single-rom end)))))", "problem": 92, "user": "5374adc3e4b06d7f452d9e27"}, {"code": "(fn __ [[x & [y & ys :as xs] :as text]]\n  (let [ranks (zipmap \"IVXLCDM\" '(1 5 10 50 100 500 1000))]\n    (cond\n      (empty? text) 0\n      (or (nil? xs) (empty? xs)) (ranks x)\n      :else (let [rx (ranks x)\n                  ry (ranks y)]\n              (if (< rx ry)\n                (+ (- ry rx) (__ ys))\n                (+ rx (__ xs)))))))", "problem": 92, "user": "536d83cee4b0fc7073fd6e5e"}, {"code": "(fn read-roman-numerals [roman]\n  (let [romans-to-decimals (zipmap '[I V X L C D M] [1 5 10 50 100 500 1000])]\n    (loop [number 0\n           decimals (map romans-to-decimals (map #(-> % str symbol) roman))]\n      (if (seq decimals)\n        (let [x (first decimals)\n              y (or (fnext decimals) 0)]\n          (if (< x y) \n            (recur (+ number (- y x)) (nnext decimals))\n            (recur (+ number x) (next decimals)))\n          )\n        number))))", "problem": 92, "user": "5244a10de4b0d8acf9ed6ab3"}, {"code": "(fn roman-number [s]\n  (let [char-value      {\\I 1\n                         \\V 5\n                         \\X 10\n                         \\L 50\n                         \\C 100\n                         \\D 500\n                         \\M 1000}\n        subtractive-sum (fn [sum prefix c] (+ (- sum (* 2 (char-value prefix))) (char-value c)))]\n    ((reduce\n      (fn [[sum prev-c] c]\n        (cond\n         (and (#{\\V \\X} c) (= prev-c \\I))   [(subtractive-sum sum \\I c) nil]\n         (and (#{\\L \\C} c) (= prev-c \\X))   [(subtractive-sum sum \\X c) nil]\n         (and (#{\\D \\M} c) (= prev-c \\C))   [(subtractive-sum sum \\C c) nil]\n         :else                              [(+ sum (char-value c))     c]\n         ))\n      [0 nil]\n      s) 0)))", "problem": 92, "user": "530bf87ee4b02e82168697d5"}, {"code": "(fn [s]\n  (let [m {\\I 1\n           \\V 5\n           \\X 10\n           \\L 50\n           \\C 100\n           \\D 500\n           \\M 1000}\n        v (concat (map m s) '(0))\n        pairs (partition 2 1 v)]\n    (->> pairs\n         (map (fn [[x y]] (if (< x y) (- x) x)))\n         (reduce +))))", "problem": 92, "user": "5080a697e4b01a93d3f38e49"}, {"code": "(fn [s]\n  (let [\n        substractive {\"IX\" \"9\" \"IV\" \"4\" \"XL\" \"l\" \"XC\" \"c\" \"CM\" \"m\"}\n        roman-digits { \\I 1 \\4 4 \\V 5 \\9 9 \\X 10 \\l 40 \\L 50 \\c 90 \\C 100 \\D 500 \\m 900 \\M 1000}]\n    (->>\n     (reduce #(clojure.string/replace %1 %2 (substractive %2)) s (keys substractive))\n     (map roman-digits)\n     (apply +))))", "problem": 92, "user": "4ddb696b535d02782fcbe9fa"}, {"code": "(fn roman->decimal [s]\n  (->> s\n      (map {\\I \t1\n            \\V \t5\n            \\X \t10\n            \\L \t50\n            \\C \t100\n            \\D \t500\n            \\M \t1000})\n      (reduce (fn [[sum prev] curr]\n                (if (> curr prev)\n                  [(+ curr (- sum prev prev)) curr]\n                  [(+ sum curr) curr]\n                  )) [0 0])\n       first))", "problem": 92, "user": "51aefceee4b09397d5109797"}, {"code": "(fn [r]\n  (let [l [[\"M\" 1000] [\"CM\" 900] [\"D\" 500] [\"CD\" 400] [\"C\" 100] [\"XC\" 90] [\"L\" 50] [\"XL\" 40] [\"X\" 10] [\"IX\" 9] [\"V\" 5] [\"IV\" 4] [\"I\" 1]]]\n    (loop [x r res 0]\n      (if (empty? x) res\n        (recur (nthnext x (count (reduce #(if (and (= (take 2 (first %2)) (take (count (first %2)) x)) (= %1 \"\")) (first %2) %1) \"\" l)))\n               (+ res (reduce #(if (and (= (take 2 (first %2)) (take (count (first %2)) x)) (= 0 %1)) (second %2) %1) 0 l)))))))", "problem": 92, "user": "53a1b5c8e4b0ca733b9744c1"}, {"code": "(fn [s]\n  (let [roman2num {\\I 1,\\V 5,\\X 10,\\L 50,\\C 100,\\D 500,\\M 1000}\n        roman-order {\\I 1,\\V 2,\\X 3,\\L 4,\\C 5,\\D 6,\\M 7}\n        s (seq s)]\n    (->> (map (fn [c1 c2]\n              (if (< (roman-order c1) (roman-order c2))\n                (- (roman2num c1))\n                (roman2num c1)))\n            (rest (reverse s))\n            (reverse s))\n\t (apply +)\n\t (+ (roman2num (last s))))))", "problem": 92, "user": "536f871de4b0fc7073fd6e7f"}, {"problem": 92, "code": "(fn arabic\n  ([roman] (arabic roman 0))\n  ([roman acc] \n   (let [base-numerals {\\I 1\n                        \\V 5\n                        \\X 10\n                        \\L 50\n                        \\C 100\n                        \\D 500\n                        \\M 1000}\n         subtractive-numerals {\"IV\" 4\n                               \"IX\" 9\n                               \"XL\" 40\n                               \"XC\" 90\n                               \"CD\" 400\n                               \"CM\" 900}]\n     (if (subtractive-numerals (apply str (take 2 roman)))\n       (recur (drop 2 roman)\n              (+ acc (subtractive-numerals (apply str (take 2 roman)))))\n       (if (base-numerals (first roman))\n         (recur (next roman) \n                (+ acc (base-numerals (first roman))))\n         acc)))))", "user": "52951156e4b02ebb4ef7501b"}, {"problem": 92, "code": "(fn parse-roman [s]\n  (let [r2i (fn [d] ({\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000} d))\n        f (fn [[acc sub?] [rd, rd-next]] (if sub? [acc false] (let [d (r2i rd) d-next (r2i rd-next)] (if (and d-next (< d d-next)) [(+ acc (- d-next d)), true] [(+ acc d), false]))))]\n    (first (reduce f [0 false] (partition-all 2 1 s)))))", "user": "4faf97d8e4b081705acca258"}, {"problem": 92, "code": "(fn [numstr]\n  (->> numstr\n       (map-indexed\n        (fn [idx digit]\n          (let [prev (get numstr (dec idx) nil)]\n            (cond (= \\I digit) 1\n                  (= \\V digit) (if (= \\I prev) 3 5)\n                  (= \\X digit) (if (= \\I prev) 8 10)\n                  (= \\L digit) (if (= \\X prev) 30 50)\n                  (= \\C digit) (if (= \\X prev) 80 100)\n                  (= \\D digit) (if (= \\C prev) 300 500)\n                  (= \\M digit) (if (= \\C prev) 800 1000)\n                  ))))\n       (reduce +)))", "user": "536e5055e4b0fc7073fd6e6b"}, {"problem": 92, "code": "(fn [rs] (letfn [(conv [msg n] (if (zero? n) msg\n(cond (<= 1000 n) (conv (str msg \"M\") (- n 1000))\n(<= 900 n) (conv (str msg \"CM\") (- n 900))\n(<= 800 n) (conv (str msg \"DCCC\") (- n 800))\n(<= 700 n) (conv (str msg \"DCC\") (- n 700))\n(<= 600 n) (conv (str msg \"DC\") (- n 600))\n(<= 500 n) (conv (str msg \"D\") (- n 500))\n(<= 400 n) (conv (str msg \"CD\") (- n 400))\n(<= 100 n) (conv (str msg \"C\") (- n 100))\n(<= 90 n) (conv (str msg \"XC\") (- n 90))\n(<= 80 n) (conv (str msg \"LXXX\") (- n 80))\n(<= 70 n) (conv (str msg \"LXX\") (- n 70))\n(<= 60 n) (conv (str msg \"LX\") (- n 60))\n(<= 50 n) (conv (str msg \"L\") (- n 50))\n(<= 40 n) (conv (str msg \"XL\") (- n 40))\n(<= 10 n) (conv (str msg \"X\") (- n 10))\n(<= 9 n) (conv (str msg \"IX\") (- n 9))\n(<= 8 n) (conv (str msg \"VIII\") (- n 8))\n(<= 7 n) (conv (str msg \"VII\") (- n 7))\n(<= 6 n) (conv (str msg \"VI\") (- n 6))\n(<= 5 n) (conv (str msg \"V\") (- n 5))\n(<= 4 n) (conv (str msg \"IV\") (- n 4))\n(<= 1 n) (conv (str msg \"I\") (- n 1)) :else \"?\")))]\n           ((into {} (for [i (range 1 4000)] [(conv \"\" i) i] )) rs)))", "user": "53976599e4b0b51d73faaeea"}, {"problem": 92, "code": "(let [literals {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000}\n        subs (fn [nums] ;;; sequence of literals translated to their values\n               (loop [acc []  nums nums]\n                 (let [n1 (first nums)]\n                   (if-let [rs (next nums)] \n                     (if (< n1 (first rs))\n                       (recur (conj acc (- (first rs) n1)) (rest rs))\n                       (recur (conj acc n1) rs))\n                     (conj acc (if n1 n1 0))))))\n        \n        trans (fn [roms]\n                (map literals (seq roms) ))\n        to-num (fn [romnumber] \n                  (reduce + (subs (trans romnumber))))\n        ]\n   to-num\n  )", "user": "50eddbc4e4b06330c1f87c4b"}, {"problem": 92, "code": "(fn\n  [s]\n  (let [v [[\"M\" 1000]\n           [\"CM\" 900]\n           [\"D\"  500]\n           [\"CD\" 400]\n           [\"C\"  100]\n           [\"XC\"  90]\n           [\"L\"   50]\n           [\"XL\"  40]\n           [\"X\"   10]\n           [\"IX\"   9]\n           [\"V\"    5]\n           [\"IV\"   4]\n           [\"I\"    1]]]\n    (letfn [(find-first-start [s]\n              (loop [v v]\n                (let [h (first v)\n                      t (rest v)]\n                  (if (.startsWith s (first h))\n                    h\n                    (recur t)))))\n            (r [a s]\n              (if (empty? s)\n                a\n                (let [v (find-first-start s)\n                      s' (.substring s (.length (first v)))\n                      a' (+ a (second v))]\n                  (recur a' s'))))]\n      (r 0 s))))", "user": "52dfc89be4b09f7907dd1405"}, {"problem": 92, "code": "(fn readroman [s]\n     (let [dict {\"M\" 1000 \"D\" 500 \"C\" 100 \"L\" 50 \"X\" 10 \"V\" 5 \"I\" 1}]\n       (if (empty? s)\n         s\n         (loop [q (map str (vec s)) result []]\n           (if (empty? q)\n             (apply + result)\n             (if (empty? (rest q))\n               (recur (rest q) (conj result (get dict (first q))))\n               (if (>= (get dict (first q)) (get dict (second q)))\n                 (recur (rest q) (conj result (get dict (first q))))\n                 (recur (rest (rest q)) (conj result (- (get dict (second q)) (get dict (first q))))))))))))", "user": "532727bae4b09d4e7a9b54fa"}, {"problem": 92, "code": "(fn [r]\n    (let [m  {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000}]\n        (->> (into [] r) (map (partial get m)) (reverse)\n            (reductions (fn [x y] (if (> x y) (- y) y))) (reduce +))\n    )\n)", "user": "536f5900e4b0fc7073fd6e7b"}, {"problem": 92, "code": "(fn [s] (reduce (fn [a b] (if (> a b) (- a b) (+ a b)))\n                (reverse \n                 (map #(* (get {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000} (first %))\n                          (count %))\n                      (partition-by identity s)))))", "user": "52d07cc5e4b07d0d72b273bb"}, {"problem": 92, "code": "(fn [s]\n  (let [romans {\\M 1000\n                \\D 500\n                \\C 100\n                \\L 50\n                \\X 10\n                \\V 5\n                \\I 1}]\n    (first\n      (reduce (fn [[sum pre] cur]\n                (let [cur-num (get romans cur)]\n                  (if (>= pre cur-num)\n                    [(+ sum cur-num) cur-num]\n                    [(- (+ sum cur-num) (* pre 2)) cur-num])))\n              [0 1001]\n              s))))", "user": "4f041de1535dcb61093f6ba5"}, {"problem": 92, "code": "(fn roman-to-int [roman]\n  (let [char-map {\\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1}]\n    (let [roman-as-ints (map #(get char-map %) roman)]\n      (let [summable-ints (concat (map #(if (< %1 %2) ( * -1 %1) %1) roman-as-ints (rest roman-as-ints)) \n              [(last roman-as-ints)])]\n        (apply + summable-ints)))))", "user": "531bad96e4b08068f379ed93"}, {"problem": 92, "code": "(fn [s]\n  (let [m {'(\\I) 1 '(\\I \\V) 4 '(\\V) 5 '(\\I \\X) 9 '(\\X) 10 '(\\X \\L) 40 '(\\L) 50 '(\\X \\C) 90 '(\\C) 100 '(\\D) 500 '(\\C \\M) 900 '(\\M) 1000}]\n    (loop [n 0 r s]\n      (if (empty? r)\n        n\n        (let [f (take 2 r) v (m f)]\n          (if v\n            (recur (+ n v) (drop (count f) r))\n            (recur (+ n (m (take 1 f))) (rest r))\n            )\n          )\n        )\n      )\n    )\n  )", "user": "53ae16e2e4b047364c044472"}, {"problem": 92, "code": "(fn rmn [r] \n    (loop [v 0 rs (map {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000} r)]\n      (if (seq rs)\n        (let [r (first rs)]\n      \t\t(recur (+ v (if (>= r (apply max rs)) r (- r))) (rest rs)))\n        v)))", "user": "53b39d82e4b047364c0444a6"}, {"problem": 92, "code": "(fn t125 [ roman ]\n  (let [values {\\I 1 \\V 5 \\X 10 \\L 50\n                \\C 100 \\D 500 \\M 1000}\n        sum_values (map (fn [[a b]] (if (< (values a) (values b)) (- (values a)) (values a))) (partition 2 1 roman))]\n    (reduce + (values (last roman)) sum_values)))", "user": "5046f909e4b03b02161376b5"}, {"problem": 92, "code": "(fn  [s]\n  (let [m {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}\n        col (reverse (seq s))]\n    (reduce\n      (fn [t [x y]]\n        (if\n          (>= (m y) (m x))\n          (+ t (m y))\n          (- t (m y))\n          ))\n      (cons 0 (partition 2 1 (cons (first col) col)))\n      )\n    ))", "user": "53b530c6e4b047364c0444bc"}, {"problem": 92, "code": "(fn [s]\n  (let [ re #\"M|CM|D|CD|C|XC|L|XL|X|IX|V|IV|I\"\n         m {\"M\" 1000 \"CM\" 900 \"D\" 500 \"CD\" 400 \"C\" 100 \"XC\" 90 \"L\" 50 \"XL\" 40 \"X\" 10 \"IX\" 9 \"V\" 5 \"IV\" 4 \"I\" 1}\n         ]\n    (reduce + (map #(m %) (re-seq re s)))))", "user": "53c1ce3ee4b00fb29b221268"}, {"problem": 92, "code": "(fn [roman]\n  (apply + (reduce #(if (>= (or (last %1) Double/POSITIVE_INFINITY)\n                            %2)\n                      (conj %1 %2)\n                      (conj (vec (butlast %1))\n                            (- %2 (last %1))))\n                   [] \n                   (map #({\\M 1000\n                           \\D 500\n                           \\C 100\n                           \\L 50\n                           \\X 10\n                           \\V 5\n                           \\I 1} %)\n                        roman))))", "user": "53acaf1fe4b047364c04445f"}, {"problem": 92, "code": "(fn [x]\n   (let [values {\\I 1\n                 \\V 5\n                 \\X 10\n                 \\L 50\n                 \\C 100\n                 \\D 500\n                 \\M 1000}]\n     (reduce (fn [a [c n]] (if (< c n) (- a c) (+ a c))) 0 (partition 2 1 [0] (map values x))))\n   )", "user": "538db083e4b0b51d73faae74"}, {"problem": 92, "code": "(fn rom->int [chars]\n  (let [romvals {\"M\" 1000 \"D\" 500 \"C\" 100 \"L\" 50 \"X\" 10 \"V\" 5 \"I\" 1}\n        auxvals {\"CM\" 900 \"CD\" 400 \"XC\" 90 \"XL\" 40 \"IX\" 9 \"IV\" 4}\n        allvals (merge romvals auxvals)]\n    (letfn [(subtractive?\n              [xs]\n              (let [pair (str (first xs) (second xs))]\n                (if (contains? auxvals pair) true false)))\n            (next-bite\n              [ys]\n              (if (subtractive? ys)\n                [(apply str (take 2 ys)) (apply str (drop 2 ys))]\n                [(str (first ys)) (apply str (rest ys))]))\n            (tokenize\n              [zs]\n              (loop [tokens [] remaining zs]\n                (if (empty? remaining)\n                  tokens\n                  (let [[token others] (next-bite remaining)]\n                    (recur (conj tokens token) others)))))]\n      (let [tokens (tokenize chars)]\n        (reduce + (map #(allvals %) tokens))))))", "user": "53bf0913e4b0c98a41f5cc99"}, {"problem": 92, "code": "(fn read-roman [s]\n  (let [numeral-values {\\I 1 \\V 5\n                        \\X 10 \\L 50\n                        \\C 100 \\D 500\n                        \\M 1000}\n        digit-values (map #(numeral-values %) (seq s))]\n    (loop [[current-value & next-values] (reverse digit-values)\n           max-value 0\n           accum 0]\n      (if current-value\n        (if (>= current-value max-value)\n          (recur next-values current-value (+ accum current-value))\n          (recur next-values max-value (- accum current-value)))\n        accum))))", "user": "53527551e4b084c2834f4af0"}, {"problem": 92, "code": "(fn [s]\n  (let [r [\"M\" \"CM\" \"D\" \"CD\" \"C\" \"XC\" \"L\" \"XL\" \"X\" \"IX\" \"V\" \"IV\" \"I\"]\n        n [1000 900 500 400 100 90 50 40 10 9 5 4 1]]\n    (loop [rm s, acc 0, i 0]\n      (cond (empty? rm) acc\n            (.startsWith rm (r i)) (recur (.substring rm (count (r i))) (+ acc (n i)) 0)\n            :else (recur rm acc (inc i))))))", "user": "538e36c7e4b0b51d73faae81"}, {"problem": 92, "code": "(fn to-arab [s]\n  (->> s\n    seq\n    (reduce (fn [[last & rest_ :as sx] item]\n              (if (empty? sx) (list item)\n                (cond \n                  (= [\\I \\V] [last item]) (cons 4 rest_)\n                  (= [\\I \\X] [last item]) (cons 9 rest_)\n                  (= [\\X \\L] [last item]) (cons 40 rest_)\n                  (= [\\X \\C] [last item]) (cons 90 rest_)\n                  (= [\\C \\D] [last item]) (cons 400 rest_)\n                  (= [\\C \\M] [last item]) (cons 900 rest_)\n                  :else (cons item sx))))\n            [])\n    (map (fn [sym]\n           (cond \n             (= \\I sym) 1           \n             (= \\V sym) 5\n             (= \\X sym) 10\n             (= \\L sym) 50\n             (= \\C sym) 100\n             (= \\D sym) 500\n             (= \\M sym) 1000\n             :else sym)))\n    (reduce +)))", "user": "53c38b8ce4b00fb29b22127b"}, {"problem": 92, "code": "(fn valof [k]\n  (let [s {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}\n        d {'(\\I \\V) 4 '(\\I \\X) 9 '(\\X \\L) 40 '(\\X \\C) 90 '(\\C \\D) 400 '(\\C \\M) 900}\n        dr (d (take 2 k))\n        sr (s (first k))\n        ]\n    (if (empty? k) \n        0\n        (if dr \n          (+ dr (valof (drop 2 k)))\n          (+ sr (valof (rest k)))\n        )\n    )\n  )\n)", "user": "53d5e45ae4b0e771c302544e"}, {"problem": 92, "code": "#(let [nums {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]\n\t(reduce + (map (fn [digit next] \n\t\t(let [v (nums digit)\n\t\t    n (get nums next -1)]\n\t\t\t   (if (>= v n) v (- v)))) % (concat (rest %) [nil]))))", "user": "53e19461e4b0d874e779ae59"}, {"problem": 92, "code": "(fn [rome]\n    (let [xset {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000} r (apply list rome)]\n     \n      (loop [acc 0 r r]\n        (do (println acc r)\n        (if (empty? r) \n          acc\n          (recur (+ acc (if (< (xset (first r)) (get xset (first (pop r)) 0))\n                          (- (xset (first r)))\n                          (xset (first r))))\n                     (rest r)\n            )\n          )\n        )\n      )\n    ))", "user": "53ca23e3e4b00fb29b2212c6"}, {"problem": 92, "code": "(fn [s]\n  (cond\n    (= s \"XIV\") 14\n    (= s \"DCCCXXVII\") 827\n    (= s \"MMMCMXCIX\") 3999\n    (= s \"XLVIII\") 48\n   ))", "user": "53ca41dae4b00fb29b2212c8"}, {"problem": 92, "code": "(fn roman->arab \n  ([roman] (roman->arab roman 0))\n  ([roman res]\n   (let [romans [\"M\" \"CM\" \"D\" \"CD\" \"C\" \"XC\" \"L\" \"XL\" \"X\" \"IX\" \"V\" \"IV\" \"I\"]\n         arabs {\"I\" 1 \"IV\" 4 \"V\" 5 \"IX\" 9 \"X\" 10 \"XL\" 40 \"L\" 50 \"XC\" 90 \"C\" 100 \"CD\" 400 \"D\" 500 \"CM\" 900 \"M\" 1000}\n         begin (some #(when (.startsWith roman %) %) \n                     romans)]\n     (if (empty? roman)\n       res\n       (recur (apply str (drop (count begin) roman)) \n              (+ res (arabs begin)))))))", "user": "52d00832e4b07d0d72b273b4"}, {"problem": 92, "code": "(fn [s]\n  (let [mappings (->> s\n                      (map {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000})\n                      reverse)\n        values (->> (reduce (fn [r v]\n                              (if (< v (last r))\n                                (conj r (* -1 v))\n                                (conj r v)))\n                            [(first mappings)] (rest mappings))\n                    reverse)]\n    (reduce + values)))", "user": "50ebd63ce4b04edc3377703c"}, {"problem": 92, "code": "#(->> (-> %2\n          (% #\"IV\" \" 4\")\n          (% #\"IX\" \" 9\")\n          (% #\"XL\" \" 40\")\n          (% #\"XC\" \" 90\")\n          (% #\"CD\" \" 400\")\n          (% #\"CM\" \" 900\")\n          (% #\"I\" \" 1\")\n          (% #\"V\" \" 5\")\n          (% #\"X\" \" 10\")\n          (% #\"L\" \" 50\")\n          (% #\"C\" \" 100\")\n          (% #\"D\" \" 500\")\n          (% #\"M\" \" 1000\")\n          clojure.string/trim\n          (clojure.string/split #\"\\s\"))\n      (map read-string)\n      (apply +))\nclojure.string/replace", "user": "53973e7be4b0b51d73faaee6"}, {"problem": 92, "code": "(fn [s]\n    (let [k {\\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1}]\n      (apply + (map (fn [[n n2]] ((if (< (k n) (k n2)) - +) (k n)))\n                    (partition 2 1 \"I\" s)))))", "user": "5310e968e4b08068f379ecdd"}, {"problem": 92, "code": "(fn read-roman [st]\n   (let [conv {\\M 1000\n               \\D 500\n               \\C 100\n               \\L 50\n               \\X 10\n               \\V 5\n               \\I 1}]\n     (loop [s (reverse st)\n            v 0]\n       (if (seq s)\n         (let [cv (conv (first s))      ;current value\n               nv (conv (second s))]    ;next value\n           (if (and nv (< nv cv))\n             (recur (nthrest s 2) (+ v (- cv nv)))\n             (recur (rest s) (+ v cv))))\n         v))))", "user": "535eaa73e4b04ce2eb3ed2d4"}, {"problem": 92, "code": "#(->>\n   %2\n   (re-seq #\"[MDLV]|C[MD]?|X[CL]?|I[XV]?\")\n   (map (apply conj % (for [x % y %] [(str (first x) (first y)) (- (second y) (second x))])))\n   (reduce +)\n   )\n  {\"I\" 1 \"V\" 5 \"X\" 10 \"L\" 50 \"C\" 100 \"D\" 500 \"M\" 1000}", "user": "5281a445e4b0757a1b17143a"}, {"problem": 92, "code": "(fn [rn]\n    (let [v-map {\\M 1000, \\D 500, \\C 100, \\L 50, \\X 10, \\V 5, \\I 1}] \n      (loop [acc 0 [v & next-vs] (map v-map rn)]\n        (if (seq next-vs)\n          (recur (+ acc \n                    (* v \n                       (if (= 0 (count (filter #(< v %) next-vs))) 1 -1)))\n                 next-vs)\n          (+ acc v)))))", "user": "513e8141e4b02b2a3d8235c1"}, {"problem": 92, "code": "#(first (\n  reduce (fn [[acc y] x]\n           [(if (< x y) (- acc x) (+ acc x)) x])\n         [0 0]\n         (map {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000} (reverse %))))", "user": "533018b2e4b019098a6f8b56"}, {"problem": 92, "code": "#(loop [x 0 \n        s % \n        m [\"M\" 1000 \"CM\" 900 \"D\" 500 \"CD\" 400 \"C\" 100 \"XC\" 90 \"L\" 50 \"XL\" 40 \"X\" 10 \"IX\" 9 \"V\" 5 \"IV\" 4 \"I\" 1]] \n   (if (empty? m) \n     x \n     (let [e (re-find (re-pattern (str \"^(\" (first m) \")(.*)$\")) s)] \n       (if e \n         (recur (+ x (second m)) (e 2) m) \n         (recur x s (drop 2 m) )))))", "user": "53b2a7f8e4b047364c04449c"}, {"problem": 92, "code": "(fn [s]\n  (let [snum {[\\C \\M] 900  [\\C \\D] 400 [\\X \\C] 90 \n             [\\X \\L] 40 [\\I \\X] 9 [\\I \\V] 4}\n        nums {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]\n    (letfn [(sum-snum [[f & r]]\n                      (if f\n                        (+ (if-let [n (snum [f (first r)])] \n                             n 0)\n                           (sum-snum r))\n                        0))\n            (del-snum [[f & r]]\n                         (when f\n                           (if (snum [f (first r)])\n                             (del-snum (rest r))\n                             (cons f (del-snum r)))))]\n      (reduce + (sum-snum s) (map nums (del-snum s))))))", "user": "53f75957e4b0de5c4184855d"}, {"problem": 92, "code": "(fn roman-numeral [r]\n  (let [numerals {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]\n    (loop [acc 0 r r]\n      (let [f (numerals (first r)) s (numerals (second r))]\n        (cond\n          (nil? f) acc\n          (and (not (nil? s)) (< f s)) (recur (+ acc (- s f)) (drop 2 r))\n          :else (recur (+ acc f) (rest r)))))))", "user": "53dc94c8e4b094d41abdfefc"}, {"problem": 92, "code": "(fn [s]\n   (apply +\n          (map #(%1 %2)\n               (map (fn [[n i v x]]\n                      (fn [s]\n                        (cond (nil? s) 0\n                              (= s (str i)) n\n                              (= s (str i i)) (* n 2)\n                              (= s (str i i i)) (* n 3)\n                              (= s (str i v)) (* n 4)\n                              (= s (str v)) (* n 5)\n                              (= s (str v i)) (* n 6)\n                              (= s (str v i i)) (* n 7)\n                              (= s (str v i i i)) (* n 8)\n                              (= s (str i x)) (* n 9))))\n                    [[1000 \"M\" \"\" \"\"]\n                     [100 \"C\" \"D\" \"M\"]\n                     [10 \"X\" \"L\" \"C\"]\n                     [1 \"I\" \"V\" \"X\"]\n                     ]\n                    )\n               (rest (re-matches #\"(M{1,3})?(C{1,3}|CM|CD|DC{1,3})?(X{1,3}|XL|L{1,3}X|XC)?(I{1,3}|IV|VI{1,3}|IX)?\" s))\n               )))", "user": "4f5cc3b8e4b0030a34fb2b2b"}, {"problem": 92, "code": "(fn [s]\n  (->>\n    (-> s\n        (clojure.string/replace #\"IX\" \"IIIIIIIII\")\n        (clojure.string/replace #\"IV\" \"IIII\")\n        (clojure.string/replace #\"XC\" \"XXXXXXXXX\")\n        (clojure.string/replace #\"XL\" \"XXXX\")\n        (clojure.string/replace #\"CM\" \"CCCCCCCCC\")\n        (clojure.string/replace #\"CD\" \"CCCC\")\n        seq\n        )\n   \t(map str)\n    (map {\"I\" 1 \"V\" 5 \"X\" 10 \"L\" 50 \"C\" 100 \"D\" 500 \"M\" 1000})\n    (apply +)\n   )\n  )", "user": "53f6d555e4b0db01ade6f9e5"}, {"problem": 92, "code": "(fn peu [x] (if (= 0 (count x)) 0 (let [f #(case % \\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000) g #(+ (peu ((fn [w] (if (empty? w) \"\" (apply str w))) (rest (rest x)))) %)] (if (= 1 (count x)) (f (first x)) (case (apply str (take 2 x)) \"IV\" (g 4) \"IX\" (g 9) \"XL\" (g 40) \"XC\" (g 90) \"CD\" (g 400) \"CM\" (g 900) (+ (peu ((fn [w] (if (empty? w) \"\" (apply str w))) (rest x))) (f (first x))))))))", "user": "53fc8424e4b0de5c418485b3"}, {"problem": 92, "code": "(fn roman [s]\n  (let [r2a {\"I\" 1, \"IV\" 4, \"V\" 5, \"IX\" 9, \"X\" 10,\n             \"XL\" 40, \"L\" 50, \"XC\" 90, \"C\", 100,\n             \"CD\" 400, \"D\" 500, \"CM\" 900, \"M\" 1000}]\n    (case (count s)\n      0 0\n      1 (r2a s)\n      (let [s01 (subs s 0 2) v01 (r2a s01)]\n        (if-not (nil? v01) (+ v01 (roman (subs s 2)))\n          (+ (r2a (subs s 0 1)) (roman (subs s 1))))))))", "user": "508157b2e4b0946d0443855c"}, {"problem": 92, "code": "(fn from-roman\n  ([roman]\n   (from-roman 0 (seq roman)))\n  ([number roman]\n   (let [symbols {\\I 1,\n                  \\V 5,\n                  \\X 10,\n                  \\L 50,\n                  \\C 100,\n                  \\D 500,\n                  \\M 1000}\n          f (first roman) \n          s (second roman)]\n       (cond\n        (empty? roman) number\n        (< (symbols f) (symbols s -1)) (from-roman \n                                      (+ number (- (symbols s) (symbols f))) \n                                      (drop 2 roman))\n        :else (from-roman\n                          (+ number (symbols f)) (rest roman))))))", "user": "5401aefbe4b0df28a13c62c7"}, {"problem": 92, "code": "(fn read-numerals [target]\n  (let [numerals {\\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1}]\n    (loop [[x & xs] (reverse target) biggest 0 total 0]\n      (let [c (numerals x)]        \n        (cond\n         (nil? x) total\n         (< c biggest) (recur xs biggest (- total c))\n         :else (recur xs c (+ c total)))))))", "user": "53c649d3e4b00fb29b221297"}, {"problem": 92, "code": "(fn [n]\n  (let [r->d {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]\n    (loop [[head & tail] n\n           prev 0\n           gr 0\n           acc 0]\n      (if head\n        (let [digit (get r->d head)]\n          (cond \n            (> digit prev) (recur tail digit (- digit gr) acc)\n            (= digit prev) (recur tail digit (+ digit gr) acc)\n            :else (recur tail digit digit (+ acc gr))))\n        (+ acc gr)))))", "user": "53f7820be4b0de5c41848560"}, {"problem": 92, "code": "(fn read-roman-numerals [[x & xs]]\n  (let [m {\\M 1000, \\D 500, \\C 100, \\L 50, \\X 10, \\V 5, \\I 1}\n        d (m x)]\n  (if (empty? xs) \n    d\n    ((if (< (m x) (m (first xs))) - +) \n      (read-roman-numerals xs) \n      d))))", "user": "52e657e4e4b09f7907dd1472"}, {"problem": 92, "code": "(fn [r]\n  (let [v {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000}]\n    (loop [sum 0\n           prev 0\n           [x & xs :as L] (reverse (map v r))]\n      (if (empty? L)\n        sum\n        (recur ((if (>= x prev) + -) sum x) x xs)))))", "user": "51780bfce4b0f89a8f53839c"}, {"problem": 92, "code": "(fn [roman]\n  (let [numbers {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000}]\n    (first\n      (reduce\n        (fn [pair1 pair2]\n          (list\n            (+ (first pair1) (* (second pair1) (first pair2)))\n            (second pair2)))\n        (list 0 1)\n        (map\n          (fn [pair]\n            (if (< (first pair) (second pair))\n              (list (- (second pair) (first pair)) 0)\n              (list (first pair) 1)))\n          (let [sequence (partition 2 1 (map #(get numbers %) roman))]\n            (concat sequence [(list (second (last sequence)) 1)])))))))", "user": "528bba38e4b0239c8a67aea9"}, {"problem": 92, "code": "(fn [s]\n    (let [nums {\\I 1\n                \\V 5\n                \\X 10\n                \\L 50\n                \\C 100\n                \\D 500\n                \\M 1000}]\n      (second\n       (reduce (fn [[prev acc] cur]\n                 [cur\n                  (-\n                   (+ acc cur)\n                   (if (< prev cur)\n                     (* 2 prev)\n                     0))])\n               [0 0]\n               (map nums s)))))", "user": "4f3d83b5e4b0e243712b1f69"}, {"problem": 92, "code": "(fn [roman]\n   (let [dict {\\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1}\n         raw-vals (concat (map dict roman) [0])\n         pairs (concat (partition 2 1 raw-vals))\n         nums (map (fn [[a b]] (if (< a b) (- a) a)) pairs)]\n     (apply + nums)))", "user": "53ed6976e4b0d648e757f4c4"}, {"problem": 92, "code": "(fn roman-to-hindu-arabic [string]\n  (let [value {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000}\n        partitioned-seq (partition-by identity string)\n        [counts values] ((juxt #(map count %)\n                               #(map (comp value first) %))\n                         partitioned-seq)\n        subtracted-values (concat (map (fn [[fst snd]]\n                                         (if (< fst snd)\n                                           (- fst)\n                                           fst))\n                                       (partition 2 1 values))\n                                  [(last values)])\n        grouped (map vector subtracted-values counts)]\n\n    (->> grouped\n         (map #(apply * %))\n         (apply +))))", "user": "53fd66a4e4b0de5c418485e3"}, {"problem": 92, "code": "(fn roman [romstr] \n  (let [values {\"M\" 1000, \"CM\" 900, \"D\" 500, \"CD\" 400, \"C\" 100, \"XC\" 90, \"L\" 50, \"XL\" 40, \"X\" 10, \"IX\" 9, \"V\" 5, \"IV\" 4, \"I\" 1},\n        irregs '(\"IV\" \"IX\" \"XL\" \"XC\" \"CD\" \"CM\"),\n        subtr-regex (re-pattern (str \"(\" (apply str (interpose \"|\" (map #(str \"(?<=\" % \")|(?=\" % \")\") irregs))) \")\")),\n        tokens (clojure.string/split romstr subtr-regex),\n        eval-token (fn [token] \n                     (if (not= nil (some (partial = token) irregs))\n                       (values token)\n                       (reduce #(+ %1 (values (str %2))) 0 token)))]\n    (reduce  #(+ %1 (eval-token %2)) 0 tokens)))", "user": "53fcdd1ae4b0de5c418485dd"}, {"problem": 92, "code": "(fn [s] (case s\n          \"XIV\" 14\n          \"DCCCXXVII\" 827\n          \"MMMCMXCIX\" 3999\n          \"XLVIII\" 48))", "user": "500d0f21e4b05f7c30cfa69e"}, {"problem": 92, "code": "(fn [xs]\n  (let [rommap2 {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000}]\n    (letfn [(romval2 [[a b]] \n              (let [{v1 a} rommap2\n                    {v2 b} rommap2]\n                (cond (nil? v2) v1\n                  (> v2 v1) (- v2 v1)\n                  :else v1)))\n            (vallist [ys] (map romval2 (partition-all 2 1 ys)))\n            (adduproman2 [zs]\n              (cond (empty? zs) 0\n                (empty? (rest zs)) (first zs)\n                (> (second zs) (first zs)) (+ (first zs) (adduproman2 (nnext zs)))\n                :else (+ (first zs) (adduproman2 (next zs)))))]\n      (adduproman2 (vallist xs)))))", "user": "53e9a15be4b036ad0777e4ae"}, {"problem": 92, "code": "#(let [numerals {\\I 1\n                 \\V 5\n                 \\X 10\n                 \\L 50\n                 \\C 100\n                 \\D 500\n                 \\M 1000}\n       values (map numerals %)]\n   (loop [[h & t] values\n          n 0]\n     (if h\n       (if (some (partial < h) t)\n         (recur t (- n h))\n         (recur t (+ n h)))\n       n)))", "user": "53fb5256e4b0de5c4184857f"}, {"problem": 92, "code": "(fn [str]\n  (let [values {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000}\n        chunks  (loop [remainder str, res []]\n    (if (empty? remainder)\n      res\n      (recur (rest remainder) (conj res (take 2 remainder)))))]\n\n    (reduce + (map (fn [[a b]]\n                     (if (< (values a) (values b 0))\n                       (- 0 (values a))\n                       (values a)))\n                   chunks))))", "user": "51684318e4b03f62cda68cd6"}, {"problem": 92, "code": "(fn rn-reader [n]\n\t(let [tran-map {\"I\"  1\n\t\t\t\t  \"V\"  5\n\t\t\t\t  \"X\"  10\n\t\t\t\t  \"L\"  50\n\t\t\t\t  \"C\"  100\n\t\t\t\t  \"D\"  500\n\t\t\t\t  \"M\"  1000\n\t\t\t\t  \"IV\" 4\n\t\t\t\t  \"IX\" 9\n\t\t\t\t  \"XL\" 40\n\t\t\t\t  \"XC\" 90\n\t\t\t\t  \"CD\" 400\n\t\t\t\t  \"CM\" 900 }\n\t\tlen \t(count n)\n\t\tdigits (vec (for [x n] (str x)))\t  \n\t\tcrd\t   (fn [l r] (apply str (concat l r)))\n\t\tis-val? (fn [v] (contains? tran-map v))]\n\t(loop [idx 0, result 0]\n\t\t(if (>= idx len)\n\t\t\tresult\n\t\t\t(if (= idx (dec len))\n\t\t\t\t(recur (inc idx) (+ result (tran-map (digits idx))))\n\t\t\t\t(let [l (digits idx)\n\t\t\t\t  r (digits (inc idx))\n\t\t\t\t  valid (is-val? (crd l r))]\n\t\t\t\t  (if valid\n\t\t\t\t  \t(recur (+ 2 idx) (+ result (tran-map (crd l r))))\n\t\t\t\t  \t(recur (inc idx) (+ result (tran-map l)))))\n\t\t\t))\n\t\t)))", "user": "52cf084ce4b07d0d72b27399"}, {"problem": 92, "code": "#(let[letterValue {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000, nil 0}\n      deductionLetter {\\I #{\\V \\X}, \\X #{\\L \\C}, \\C #{\\D \\M}}]\n   (when (seq %)\n     (loop[letters (rest %) prevLetter (first %) sum 0]\n       (if (seq letters)\n         (let [currentLetter (first letters)]\n           (if (contains? (deductionLetter prevLetter) currentLetter)\n             (recur (drop 2 letters) (second letters) (+ sum (- (letterValue currentLetter) (letterValue prevLetter))))\n             (recur (rest letters) currentLetter (+ sum (letterValue prevLetter)))))\n         (+ sum (letterValue prevLetter))))))", "user": "541619e8e4b01498b1a719f9"}, {"problem": 92, "code": "(fn roman-numerals [x]\n (let [numeral-values {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}\n       normalized (clojure.string/replace \n                   (clojure.string/replace \n                    (clojure.string/replace \n                     (clojure.string/replace \n                      (clojure.string/replace \n                       (clojure.string/replace x \"IV\" \"IIII\")\n                      \"IX\" \"VIIII\")\n                     \"XL\" \"XXXX\")\n                    \"XC\" \"LXXXX\")\n                   \"CD\" \"CCCC\")\n                  \"CM\" \"DCCCC\")]\n   (reduce + (map numeral-values (seq normalized)))))", "user": "54299d4be4b01498b1a71b3d"}, {"problem": 92, "code": "(fn rom [s]\n  (let [nums (mapv {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000} s)]\n    (->> (for [[i n] (partition 2 (interleave (range) nums))\n               :let [rightmost (->> (subvec nums (inc i) (count nums))\n                                    (apply sorted-set)\n                                    rseq\n                                    first)]]\n           (if (and rightmost (> rightmost n)) (* -1 n) n))\n         (reduce +))))", "user": "4db396c7535df7e46ed9b6cf"}, {"problem": 92, "code": "(fn [s]\n  (let [mapping {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]\n    (->> s (map mapping) reverse (reduce #(if (< % (dec (* 5 %2))) (+ % %2) (- % %2))))))", "user": "53a01fb1e4b0ca733b9744a6"}, {"problem": 92, "code": "#(let\n  [x (case (last %3) \\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000 0)]\n  (if (> x 0) (recur ((if (< x %2) - +) % x) x (drop-last %3)) %)) 0 0", "user": "542f574be4b0dad94371f2d0"}, {"problem": 92, "code": "#(let\n   [values {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000}\n    [result _] (reduce (fn [[sum prev] curr]\n                         (let [p (values prev 0), c (values curr)]\n                           [(+ sum (if (< p c) (- c p p) c))\n                            curr])) [0 \"\"] (seq %))]\n   result)", "user": "4fad9da0e4b081705acca23c"}, {"problem": 92, "code": "#(apply + (map {\"I\" 1 \"V\" 5 \"X\" 10 \"L\" 50 \"C\" 100 \"D\" 500 \"M\" 1000 \"IV\" 4 \"IX\" 9 \"XL\" 40 \"XC\" 90 \"CD\" 400 \"CM\" 900}\n               (re-seq #\"IV|IX|XL|XC|CD|CM|M|D|C|L|X|V|I\" %)))", "user": "543d5c61e4b032a45b86934d"}, {"problem": 92, "code": "(fn [w]\n              (let [T {\\M 1000, \\D 500, \\C 100, \\L 50, \\X 10, \\V 5, \\I 1 \\o 0}]\n                (->> (str w \\o)\n                     (partition-by identity)\n                     (partition 2 1)\n                     (reduce (fn [a [[d1 & dd1 :as d1s] [d2 & dd2 :as d2s]]]\n                               ((if (> (T d1) (T d2)) + -)\n                                a (* (T d1) (count d1s))))\n                             0))))", "user": "53f592b7e4b0db01ade6f9d0"}, {"problem": 92, "code": "(fn read-roman [str]\n    (let  [letters (re-seq #\"\\w\" str) ,\n           values  {\n                    \"I\"  1   \n                    \"V\"  5   \n                    \"X\"  10   \n                    \"L\"  50   \n                    \"C\"  100   \n                    \"D\"  500   \n                    \"M\"  1000   \n                    },\n           reduce-decresing\n           (fn _ [ [ x y & xs]]\n             (if-not (nil? y)\n               (if (> y x)\n                 (_ (cons (- y x) xs))\n                 (cons x (_  (cons y xs)))\n                 )\n               [x]\n               )\n             )]\n      (->> letters\n           (map values)\n           reduce-decresing\n           (reduce +))\n      ))", "user": "5433a07be4b0b6b47310fce0"}, {"problem": 92, "code": "(fn read-roman [s]\n\t(let [m (into {} (map vector \"IVXLCDM\" [1 5 10 50 100 500 1000]))]\n\t(first\n\t\t(reduce (fn [[acc prev] l]\n\t\t\t\t\t(if (> prev (m l))\n\t\t\t\t\t\t[(- acc (m l)) (m l)]\n\t\t\t\t\t\t[(+ acc (m l)) (m l)]))\n\t\t\t\t[0 0] (reverse s)))))", "user": "54448e84e4b032a45b869393"}, {"problem": 92, "code": "(fn [roman]\n  (apply + (loop [roman-rest roman\n                  result []]\n             (if (empty? roman-rest)\n               result\n               (let [subst-number (case (apply str (take 2 roman-rest))\n                                    \"IV\" 4 \"IX\" 9 \"XL\" 40 \"XC\" 90 \"CD\" 400 \"CM\" 900 nil)\n                     number (case (str (first roman-rest))\n                              \"I\" 1 \"V\" 5 \"X\" 10 \"L\" 50\"C\" 100 \"D\" 500 \"M\" 1000)\n                     used-chars (if (nil? subst-number) 1 2)]\n                 (recur (drop used-chars roman-rest) (conj result (or subst-number number))))))))", "user": "53f891eee4b0de5c4184856d"}, {"problem": 92, "code": "(fn roman [s]\n  (loop [[c & r] s\n         n 0]\n    (let [t (str c (first r))\n          m (drop 1 r)\n          f (str c)]\n      (if c\n        (cond\n          (= f \"M\" ) (recur r (+ n 1000))\n          (= f \"D\" ) (recur r (+ n 500))\n          (= t \"CM\") (recur m (+ n 900))\n          (= t \"CD\") (recur m (+ n 400))\n          (= f \"C\" ) (recur r (+ n 100))\n          (= f \"L\" ) (recur r (+ n 50))\n          (= t \"XC\") (recur m (+ n 90))\n          (= t \"XL\") (recur m (+ n 40))\n          (= f \"X\" ) (recur r (+ n 10))\n          (= f \"V\" ) (recur r (+ n 5))\n          (= t \"IX\") (recur m (+ n 9))\n          (= t \"IV\") (recur m (+ n 4))\n          (= f \"I\" ) (recur r (+ n 1)))\n        n))))", "user": "51e38568e4b0c611d6113e43"}, {"problem": 92, "code": "(fn [s]\n  (loop [s s\n         acc 0]\n    (if (empty? s)\n      acc\n      (let [[a b & _] s]\n        (cond\n          (and (= a \\I) (= b \\V))  (recur (rest (rest s)) (+ acc 4))\n          (and (= a \\I) (= b \\X))  (recur (rest (rest s)) (+ acc 9))\n          (and (= a \\X) (= b \\L))  (recur (rest (rest s)) (+ acc 40))\n          (and (= a \\X) (= b \\C))  (recur (rest (rest s)) (+ acc 90))\n          (and (= a \\C) (= b \\M))  (recur (rest (rest s)) (+ acc 900))\n          (= a \\I)                 (recur       (rest s)  (+ acc 1))\n          (= a \\V)                 (recur       (rest s)  (+ acc 5))\n          (= a \\X)                 (recur       (rest s)  (+ acc 10))\n          (= a \\L)                 (recur       (rest s)  (+ acc 50))\n          (= a \\C)                 (recur       (rest s)  (+ acc 100))\n          (= a \\D)                 (recur       (rest s)  (+ acc 500))\n          (= a \\M)                 (recur       (rest s)  (+ acc 1000)))))))", "user": "4ec1b090535dfed6da9c6db5"}, {"problem": 92, "code": "(fn [letters]\n  (let [order (zipmap \"IVXLCDM\" [1 5 10 50 100 500 1000])\n        cmp   (fn [a b] (compare (get order a) (get order b)))\n        magn  (fn [[letter :as g]] (* (get order letter) (count g)))]\n    (loop [[f s :as xs] (partition-by identity letters)\n           acc 0]\n      (if-not s\n        (+ (magn f) acc)\n        (recur (rest xs)\n               (-> (magn f)\n                   (* (cmp (first f) (first s)))\n                   (+ acc)))))))", "user": "505aa653e4b021387fb89857"}, {"problem": 92, "code": "(fn [rn]\n   (loop [sum 0 letters (partition 2 1 (reverse (str (first rn) rn)))]\n     (if (empty? letters)\n       sum\n       (let [[[lsl msl] & more] letters]\n         (prn lsl msl more)\n         (cond (= \\I lsl) (recur (inc sum) more)\n               (= \\V lsl) (recur (+ (if (= \\I msl) 4 5) sum) (if (= \\I msl) (rest more) more))\n               (= \\X lsl) (recur (+ (if (= \\I msl) 9 10) sum) (if (= \\I msl) (rest more) more))\n               (= \\L lsl) (recur (+ (if (= \\X msl) 40 50) sum) (if (= \\X msl) (rest more) more))\n               (= \\C lsl) (recur (+ (if (= \\X msl) 90 100) sum) (if (= \\X msl) (rest more) more))\n               (= \\D lsl) (recur (+ (if (= \\C msl) 400 500) sum) (if (= \\C msl) (rest more) more))\n               (= \\M lsl) (recur (+ (if (= \\C msl) 900 1000) sum) (if (= \\C msl) (rest more) more)))))))", "user": "51672d15e4b079759a74a5e7"}, {"problem": 92, "code": "#(apply + (map { \"M\" 1000 \"D\" 500 \"C\" 100 \"L\" 50 \"X\" 10 \"V\" 5 \"I\" 1\n                \"CM\" 900 \"CD\" 400 \"XC\" 90 \"XL\" 40 \"IX\" 9 \"IV\" 4}\n              (re-seq #\"C[MD]|X[CL]|I[XV]|.\" %)))", "user": "53ce4cd4e4b00fb29b2212ef"}, {"problem": 92, "code": ";When I learned the latin numerals at school I read from left to right i.e. from highest value to lowest. \n;In general, the values of every numeral in a line were added: LXI = L + X + I = 50 + 10 + 1 = 61.\n;If, however, a lower value numeral preceded a higher value numeral, the lower value was substracted from the higher value: \n;LIX = L + (X - I) = 50 + (10 - 1) = 59. To make things even more challanging there could be up to three lower value numerals before \n;the next higher value one: LIIIX = L + (X - I - I - I) = 57.\n;So the decoding implied reading ahead up to three numerals which is easily done by humans but makes a mathematical algorithm look ugly.\n;\n;The beauty comes in when we read the reverse numeral string:\n;- read and sum up all numerals from right to left (reverse string)\n;- use the current numeral's and the last one's values to determine the current value's sign: \n;  - if (< cur last): change the sign of the value (* -1 x) before adding\n;  - if (= cur last): reuse the sign of the last for cur\n;  - if (> cur last): cur's sign is positive\n;\n;And that is all to it. What remains is the bread-and-butter work of getting the code to run properly:\n;\n(fn roman-to-arab[sn]\n  (letfn [\n           (lat-num[num]\n            (case num\n              \\I 1\n              \\V 5\n              \\X 10\n              \\L 50\n              \\C 100\n              \\D 500\n              \\M 1000\n            )\n          )\n\n          (lat-num-sign[c lastnum]\n            (let [num (lat-num c) sgn (if (< lastnum 0) -1 1)]\n              (if (= num (* sgn lastnum)) \n                (* sgn num)\n                (if (< num (* sgn lastnum)) (* -1 num) num)  \n              )\n            )\n          )\n\n          (decode-lat-num [str lastnum total]\n            (if (empty? str)\n              total \n              (\n                let [num (lat-num-sign (first str) lastnum)] \n                (decode-lat-num (rest str) num (+ total num))\n              )\n            )\n          )\n         ]\n \n    (decode-lat-num (reverse sn) 0 0)\n  )\n)", "user": "545537c1e4b0e397800069dd"}, {"problem": 92, "code": "(let [nums {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}\n      negative? (fn [r]\n                  (let [h (first r)\n                        hd (nums h)\n                        q (rest r)]\n                    (some #(> (nums %) hd) q)))]\n  (fn [s]\n    (->>\n     s\n     (char-array)\n     ((fn [r]\n        (loop [r r c 0]\n          (if (empty? r)\n            c\n            (if (negative? r)\n              (recur (rest r) (- c (nums (first r))))\n              (recur (rest r) (+ c (nums (first r))))))))))))", "user": "547d8e93e4b0c51c1f4d72f4"}, {"problem": 92, "code": "(fn [s]\n  (let [table {\"I\" 1, \"IV\" 4, \"V\" 5, \"IX\" 9, \"X\" 10, \"XL\" 40, \"L\" 50, \"XC\" 90, \"C\" 100, \"CD\" 400, \"D\" 500, \"CM\" 900, \"M\" 1000}\n        f (fn [xs ch] \n            (let [k (apply str (first xs) (str ch))] \n              (if (contains? table k) \n                (conj (rest xs) k)\n                (conj xs (str ch)))))\n        nums (reduce f [] s)]\n    (reduce #(+ %1 (get table %2)) 0 nums)))", "user": "5392bfdee4b0b51d73faaeb2"}, {"problem": 92, "code": "(fn [r]\n(->> (reverse r)\n\t (replace {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000})\n     (partition-by identity)\n     (map (partial apply +))\n     (reduce #(if (< %1 %2) (+ %1 %2) (- %1 %2)))))", "user": "52874ab3e4b0239c8a67ae36"}, {"problem": 92, "code": "(fn rom [r]\n  (if (empty? r) 0\n      (let [dis {\"CM\" 900 \"CD\" 400 \"XC\" 90 \"XL\" 40 \"IX\" 9 \"IV\" 4}\n            monos {\"M\" 1000 \"D\" 500 \"C\" 100 \"L\" 50 \"X\" 10 \"V\" 5 \"I\" 1}\n            di (find dis (apply str (take 2 r)))\n            mono (find monos (apply str (take 1 r)))]\n        (if-let [[k v] di]\n          (+ v (rom (subs r 2)))\n          (let [[k v] mono] \n            (+ v (rom (subs r 1))))))))", "user": "5405ae2be4b0addc1aec6671"}, {"problem": 92, "code": "#(get {\"XI\" 14 \"DC\" 827 \"MM\" 3999 \"XL\" 48} (apply str (take 2 (seq %))))", "user": "4df1e213535d08e6dec9fe20"}, {"problem": 92, "code": "(fn [roman]\n(->> roman\n     (map #(case % \\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000))\n     ((fn rec-fn [f acc [a & [b :as tail]]]\n       (cond b (if (f a b)\n                   (cons (conj acc a) (lazy-seq (rec-fn f [] tail)))\n                   (rec-fn f (conj acc a) tail))\n             a (rec-fn f (conj acc a) tail)\n             (empty? acc) '() \n             :else (cons acc nil))) \n     #(>= %1 %2) [])\n     (map #(Math/abs (apply - (last %) (butlast %))))\n     (reduce +)))", "user": "539c54b3e4b0b51d73faaf27"}, {"problem": 92, "code": "(fn unroman [s]\n  (let [roman (fn [n]\n                (let [build (fn build [n]\n                              (if (>= n 1000)\n                                (conj (build (rem n 1000)) (apply str (repeat (quot n 1000) \"M\")))\n                                (if (>= n 100)\n                                  (let [h (quot n 100)\n                                        r (build (rem n 100))]\n                                    (case h\n                                      9 (conj r \"CM\")\n                                      8 (conj r \"DCCC\")\n                                      7 (conj r \"DCC\")\n                                      6 (conj r \"DC\")\n                                      5 (conj r \"D\")\n                                      4 (conj r \"CD\")\n                                      3 (conj r \"CCC\")\n                                      2 (conj r \"CC\")\n                                      1 (conj r \"C\")))\n                                  (if (>= n 10)\n                                    (let [t (quot n 10)\n                                          r (build (rem n 10))]\n                                      (case t\n                                        9 (conj r \"XC\")\n                                        8 (conj r \"LXXX\")\n                                        7 (conj r \"LXX\")\n                                        6 (conj r \"LX\")\n                                        5 (conj r \"L\")\n                                        4 (conj r \"XL\")\n                                        3 (conj r \"XXX\")\n                                        2 (conj r \"XX\")\n                                        1 (conj r \"X\")))\n                                    (seq (case n\n                                           9 \"IX\"\n                                           8 \"VIII\"\n                                           7 \"VII\"\n                                           6 \"VI\"\n                                           5 \"V\"\n                                           4 \"IV\"\n                                           3 \"III\"\n                                           2 \"II\"\n                                           1 \"I\"\n                                           0 []))))))]\n                  (apply str (build n))))]\n    ((zipmap (map roman (range 1 4000)) (range 1 4000)) s)))", "user": "5353afa0e4b084c2834f4b03"}, {"problem": 92, "code": "(fn [ns]\n  (let [rnx #\"(?:IV|IX|XL|XC|CD|CM|I|V|X|L|C|D|M)\"\n        rns {\"I\" 1 \"V\" 5 \"X\" 10 \"L\" 50 \"C\" 100 \"D\" 500 \"M\" 1000\n             \"IV\" 4 \"IX\" 9 \"XL\" 40 \"XC\" 90 \"CD\" 400 \"CM\" 900}]\n    (reduce + (map #(get rns %) (re-seq rnx ns)))))", "user": "53ef7f77e4b0742d9025b0ce"}, {"problem": 92, "code": "(fn [s]\n  (let [m {\\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1}\n        p (map #(get m %) (seq s))]\n    (loop [x p, last (first p), r 0]\n      (if (empty? x) r (recur (rest x) (first x) \n        (+ r (if (< last (first x)) (- (* 2 last)) 0) (first x)))))))", "user": "53bcdd41e4b0d9a98559a6c0"}, {"problem": 92, "code": "(fn [s]\n  (let \n    [   n [1 5 10 50 100 500 1000 5000]\n        ro \"IVXLCDM\"\n        m (apply array-map (interleave ro n))]\n    (reduce \n      (fn [r x] \n        (if (< r (n (inc (.indexOf n x))))\n          (+ r x)\n          (- r x)\n        )\n      ) 0 (reverse \n           (map #(m %) s)\n           )\n    )\n  )\n)", "user": "4fc8f671e4b0ee37620e1840"}, {"problem": 92, "code": "(fn [n]\n  (let [nm (zipmap \"IVXLCDM\" (reductions * 1 (cycle [5 2])))]\n    (loop [[f & r] (reverse (map nm n)) l f s 0]\n      (if f\n        (recur r f (if (> l f) (- s f) (+ s f)))\n        s))))", "user": "53e745a1e4b036ad0777e479"}, {"problem": 92, "code": "(fn roman->numbers [roman]\n  (let [conversion {\\M 1000\n                    \\D 500\n                    \\C 100\n                    \\L 50\n                    \\X 10\n                    \\V 5\n                    \\I 1}\n        to-num (fn [s]\n                 (cond\n                  (= s \"IV\") 4\n                  (= s \"IX\") 9\n                  (= s \"XL\") 40\n                  (= s \"XC\") 90\n                  (= s \"CD\") 400\n                  (= s \"CM\") 900\n                  :else (map #(get conversion %) s)))\n        split-to-individuals (fn [r]\n                               (loop [acc []\n                                      prev (first roman)\n                                      rnums roman]\n                                 (if (empty? rnums)\n                                   acc\n                                   (let [num (take-while #(>= (get conversion %) (get conversion prev)) rnums)\n                                         nums-left (drop-while #(>= (get conversion %) (get conversion prev)) rnums)]\n                                             (recur (conj acc num) (first nums-left) nums-left)))))]\n    (apply +\n           (flatten (map to-num\n                         (map (partial apply str)\n                              (split-to-individuals roman)))))))", "user": "540e8d13e4b0addc1aec671e"}, {"problem": 92, "code": "(fn roman [s]\n  (let [m {\\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1 }\n        p (partition-all 2 1 s)]\n    (apply +  (map (fn [[e n]] (let [ve (m e) vn (m n)] (if (and vn (> vn ve)) (- ve) ve))) p))))", "user": "512b07f7e4b078b06821febb"}, {"problem": 92, "code": "(fn [roman] (let [dict  {\\I 1\n                           \\V 5\n                           \\X 10\n                           \\L 50\n                           \\C 100\n                           \\D 500\n                           \\M 1000}\n                    chrs  (reverse (seq roman))\n                    trans (fn [k] (get-in dict [k]))\n\n                    ]\n                (first (reduce (fn [[val prev] c]\n                                 (let [\n                                       cc (trans c)]\n                                   (if (< cc prev)\n                                     [(- val cc) cc]\n                                     [(+ val cc) cc]))) \n                               [(trans (first chrs)) (trans (first chrs))] (rest chrs) ))\n                ))", "user": "549375e4e4b0b312c081ff4e"}, {"problem": 92, "code": "(fn [s]\n    (let [NUMS {\\I 1\n                \\V 5\n                \\X 10\n                \\L 50\n                \\C 100\n                \\D 500\n                \\M 1000}\n          new-s (-> s\n                    (clojure.string/replace #\"IV\" \"IIII\")\n                    (clojure.string/replace #\"IX\" \"VIIII\")\n                    (clojure.string/replace #\"XL\" \"XXXX\")\n                    (clojure.string/replace #\"XC\" \"LXXXX\")\n                    (clojure.string/replace #\"CD\" \"CCCC\")\n                    (clojure.string/replace #\"CM\" \"DCCCC\"))]\n      (reduce #(+ %1 %2) (map #(get NUMS %) new-s))))", "user": "50800e49e4b089ade05efbda"}, {"problem": 92, "code": "(fn [s]\n   (let [NUMS {\\I 1\n               \\V 5\n               \\X 10\n               \\L 50\n               \\C 100\n               \\D 500\n               \\M 1000}\n         new-s (-> s\n                   (clojure.string/replace #\"IV\" \"IIII\")\n                   (clojure.string/replace #\"IX\" \"VIIII\")\n                   (clojure.string/replace #\"XL\" \"XXXX\")\n                   (clojure.string/replace #\"XC\" \"LXXXX\")\n                   (clojure.string/replace #\"CD\" \"CCCC\")\n                   (clojure.string/replace #\"CM\" \"DCCCC\"))]\n     (reduce #(+ %1 %2) (map #(get NUMS %) new-s))))", "user": "5405fdcce4b0addc1aec6683"}, {"problem": 92, "code": "(fn [rn]\n  (let [ds (zipmap \"MDCLXVI\" \n                   [1000 500 \n                    100  50 \n                    10   5 1])] \n    (->> rn reverse\n         (map ds)\n         (reduce (fn [[tot m] d]\n                   (if (< d m)\n                     [(- tot d) m]\n                     [(+ tot d) d])) \n                 [0 1])\n         first)))", "user": "53dfdf01e4b0d874e779ae46"}, {"problem": 92, "code": "#(let [vals {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000 nil -1}\n        z (fn [a b] (< (vals a) (vals b)))]\n    (apply + (for [i (range (count %))]\n       (let [x (get % i) y (get % (inc i))]\n         (if (z x y) (- (vals x)) (vals x))))))", "user": "549c3e0ce4b0f3d1d8e70f87"}, {"problem": 92, "code": "#(let [rom (fn [sum s]\n             (let [dd ({\"IV\" 4 \n                        \"IX\" 9\n                        \"XL\" 40\n                        \"XC\" 90\n                        \"CD\" 400\n                        \"CM\" 900} (str (first s) (second s)))\n                   d ({\"I\" 1\n                       \"V\" 5\n                       \"X\" 10\n                       \"L\" 50\n                       \"C\" 100\n                       \"D\" 500\n                       \"M\" 1000} (str (first s)))]\n               (if (not (nil? dd)) (recur (+ sum dd) (rest (rest s)))\n                                   (if (not (nil? d)) (recur (+ sum d) (rest s))\n                                                      sum))))]\n  (rom 0 %))", "user": "536b9d8ae4b0243289761ebe"}, {"problem": 92, "code": "(fn [s]\n (let [\n  rarn\n  {\\I 1\n   \\V 5\n   \\X 10\n   \\L 50\n   \\C 100\n   \\D 500\n   \\M 1000}\n  [nh & nt]\n    (map rarn s)]\n (last\n (reduce\n  (fn [[lst sum] nxt]\n   (if (< lst nxt)\n        [(- nxt lst)\n         sum]\n        [nxt\n         (+ lst sum)]))\n  [nh 0]\n  (conj (vec nt) 0)\n  ))))", "user": "549a999be4b0f3d1d8e70f6f"}, {"problem": 92, "code": "(letfn\n    [(emit [numr]\n       (let [[x1 x2] (take 2 numr) rst (drop 2 numr)]\n         (if (nil? x2)\n           (take 2 numr)\n           (lazy-seq\n            (if (>= x1 x2)\n              (cons x1 (emit (cons x2 rst)))\n              (cons (- x2 x1) (emit rst)))))))]\n  (fn [numr]\n    (let [numrs {\\O 0, \\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000}\n          part (partition 2  1 [\\O] numr)]\n      (->> (map #(numrs %) numr)\n           (emit)\n           (apply +)))))", "user": "534941d1e4b084c2834f4a60"}, {"problem": 92, "code": "(fn read-roman-as-dec [rn]\n  (let [m {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}\n        subtractive (fn [[x y]] (if (and x y (< x y)) (- x) x))]\n    (apply + (->> rn (map m) (partition-all 2 1) (map subtractive)))))", "user": "5383668ee4b06839e8705edd"}, {"problem": 92, "code": "(fn [num]\n  (let [ms (re-find #\"^M+\" num)\n        cs (->> num (re-find #\"(CM|DCCC|DCC|DC|CD|CCC|CC|C|D)\") first)\n        xs (->> num (re-find #\"(XC|LXXX|LXX|LX|XL|XXX|XX|X|L)\") first)\n        is (->> num (re-find #\"(IX|VIII|VII|VI|IV|III|II|I|V)\") first)\n        thousands (* 1000 (count ms))\n        hundreds (cond (nil? cs) 0\n                       (= \"CM\" cs) 900\n                       (= \"CD\" cs) 400\n                       :else (+ (* 100 (count (re-find #\"C+\" cs)))\n                                (* 500 (count (re-find #\"D+\" cs)))))\n        tens (cond (nil? xs) 0\n                   (= \"XC\" xs) 90\n                   (= \"XL\" xs) 40\n                   :else (+ (* 10 (count (re-find #\"X+\" xs)))\n                            (* 50 (count (re-find #\"L+\" xs)))))\n        ones (cond (nil? is) 0\n                   (= \"IX\" is) 9\n                   (= \"IV\" is) 4\n                   :else (+ (* 1 (count (re-find #\"I+\" is)))\n                            (* 5 (count (re-find #\"V+\" is)))))]\n    (+ thousands hundreds tens ones)))", "user": "5484143de4b0e286459a1197"}, {"problem": 92, "code": "(fn [s]\n  (letfn [(walker [c n] (let [l (peek c)] (if (< l n) (conj (pop c) (- n l)) (conj c n))))]\n    (->> s\n         (replace (zipmap \"MDCLXVI\" [1000 500 100 50 10 5 1]))\n         (reduce walker [0])\n         (apply +))))", "user": "53e3f7a8e4b036ad0777e408"}, {"problem": 92, "code": "(fn [s]\n  (let [t {:M 1000 :D 500 :C 100 :L 50 :X 10 :V 5 :I 1}\n        [a b _] (reduce (fn [[s c l] n] (if (> (n t) l)\n                                          [s (- (n t) c) (n t)]\n                                          [(+ s c) (n t) (n t)]))\n                        [0 0 0]\n                        (map (comp keyword str) s))]\n    (+ a b)))", "user": "5175533fe4b0dea9bbfba575"}, {"problem": 92, "code": "(fn [x] (let [r (map (zipmap \"IVXLCDM\" [1 5 10 50 100 500 1000]) x)\n              n (* 2 (apply + (map first (filter (fn [[a b]] (< a b)) (partition 2 1 r)))))]\n          (- (apply + r) n)))", "user": "549a176ce4b0f3d1d8e70f69"}, {"problem": 92, "code": "(fn [x]\n  (let [nums {\"I\" 1 \"V\" 5 \"X\" 10 \"L\" 50 \"C\" 100 \"D\" 500 \"M\" 1000}]\n(->> x\n     (re-seq #\".\")\n     (map nums)\n     (vec)\n     (#(conj % 0))\n     (partition 2 1)\n     (map (fn [[a b]] (if (>= a b) a (- a))))\n     (reduce +))))", "user": "54be7772e4b0ed20f4ff6eea"}, {"problem": 92, "code": "(fn [nms]\n   (let [nm {\\I 1 \\V 5 \\X 10 \\C 100 \\D 500 \\M 1000}\n         red {\"IV\" 4 \"IX\" 9 \"XL\" 40 \"XC\" 90 \"CD\" 400 \"CM\" 900}]\n     (letfn [(parse [[x & xs] acc]\n              (if (empty? xs)\n                (if-let [final (nm x)]\n                  (+ acc (nm x))\n                  acc)\n                (if-let [comb (red (str x (first xs)))]\n                  (recur (rest xs) (+ acc comb))\n                  (recur xs (+ acc (nm x))))))]\n      (parse nms 0))))", "user": "53214efbe4b09d4e7a9b54b2"}, {"problem": 92, "code": "(fn [ns]\n  (let [rn {\"I\" 1, \"IV\" 4, \"V\" 5, \"IX\" 9, \"X\" 10,\n            \"XL\" 40, \"L\" 50, \n            \"XC\" 90, \"C\" 100,\n            \"CD\" 400, \"D\" 500,\n            \"CM\" 900, \"M\" 1000}\n        rnh (into {} (map (fn [[k vs]]\n                            [k (into {} (map (fn [x] [x (rn x)]) vs))])\n                          (group-by count (keys rn))))\n        sks (reverse (sort (keys rnh)))]\n    (loop [ns ns lcs sks acc 0]\n      (cond \n        (empty? ns) acc\n        (empty? lcs) (throw (Exception. \"Incorrect character/number\"))\n        :else (let [lc (first lcs)\n                    cand-syms (apply str (take lc ns))\n                    value (get-in rnh [lc cand-syms])]\n                (if value\n                  (recur (drop lc ns) sks (+ acc value))\n                  (recur ns (rest lcs) acc)))))))", "user": "54b13a40e4b09f271ff37d1b"}, {"problem": 92, "code": "(fn q[r]\n    (let [w {\\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1} t (w (get r 0))]\n      (if (= (.length r) 1)\n        t\n        (let [e (q (.substring r 1))]\n        (if (> (w (get r 1)) t)\n          (- e t)\n          (+ e t)\n          )\n        )\n        )\n      )\n    )", "user": "54b90836e4b0ed20f4ff6e9d"}, {"problem": 92, "code": "(fn [s]\n  (let [[f & r] (reverse s)\n        romans (zipmap \"IVXLCDM\" [1 5 10 50 100 500 1000])]\n    (loop [old 1\n           new (romans f)\n           sum 0\n           [x & y] r]\n      (cond\n       (not new) sum\n       (>= new old)\n       \t (recur new\n               (romans x)\n               (+ sum new)\n               y)\n        :else (recur new\n                   (romans x)\n                   (- sum new)\n                   y)))))", "user": "54848141e4b0e286459a119e"}, {"problem": 92, "code": "(fn __ [s]\n  (let [m [[\\M 1000][\\D 500][\\C 100][\\L 50][\\X 10][\\V 5][\\I 1]]]\n    (letfn [(f [s n]\n               (if (empty? s) n\n                 (let [p (first (filter #(= (first s) (first %)) m))\n                       i (.indexOf m p)\n                       c (first p)\n                       x (second p)]\n                   (if (or (= c \\M)\n                           (odd? i))\n                     (f (rest s) (+ n x))\n                     (let [s (rest s), i (dec i), p (nth m i), c (first p), y (second p)]\n                       (if (= (first s) c)\n                         (f (rest s) (- (+ n y) x))\n                         (let [i (dec i), p (nth m i), c (first p), y (second p)]\n                           (if (= (first s) c)\n                             (f (rest s) (- (+ n y) x))\n                             (f s (+ n x))))))))))]\n      (f s 0))))", "user": "54c271b9e4b045293a27f602"}, {"problem": 92, "code": "(fn r [s]\n  (if (re-matches #\"^M.*\" s) (+ 1000 (r (apply str (rest s))))\n    (if (re-matches #\"^CM.*\" s) (+ 900 (r (apply str (rest (rest s)))))\n      (if (re-matches #\"^D.*\" s) (+ 500 (r (apply str (rest s))))\n        (if (re-matches #\"^CD.*\" s) (+ 400 (r (apply str (rest (rest s)))))\n          (if (re-matches #\"^C.*\" s) (+ 100 (r (apply str (rest s))))\n            (if (re-matches #\"^XC.*\" s) (+ 90 (r (apply str (rest (rest s)))))\n              (if (re-matches #\"^L.*\" s) (+ 50 (r (apply str (rest s))))\n                (if (re-matches #\"^XL.*\" s) (+ 40 (r (apply str (rest (rest s)))))\n                  (if (re-matches #\"^X.*\" s) (+ 10 (r (apply str (rest s))))\n                    (if (re-matches #\"^IX.*\" s) (+ 9 (r (apply str (rest (rest s)))))\n                      (if (re-matches #\"^V.*\" s) (+ 5 (r (apply str (rest s))))\n                        (if (re-matches #\"^IV.*\" s) (+ 4 (r (apply str (rest (rest s)))))\n                          (if (re-matches #\"^I.*\" s) (+ 1 (r (apply str (rest s))))\n                            0))))))))))))))", "user": "54ca9ca8e4b057c6fda3a265"}, {"problem": 92, "code": "(fn roman [s]\n  (let [z   {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000}\n        zd  {\"IV\" \"IIII\", \"IX\" \"VIIII\" , \"XL\" \"XXXX\" , \"XC\" \"LXXXX\" , \"CD\" \"CCCC\", \"CM\" \"DCCCC\"}]\n        \n    (reduce #(+ %1 (z %2)) 0 \n      (reduce-kv #(clojure.string/replace %1 %2 %3) s zd))))", "user": "5470699ae4b00cfc9eacc1b6"}, {"problem": 92, "code": "(fn [x] (let [ones [\\I \\X \\C \\M \\?]\n                  fives [\\V \\L \\D \\?]\n                  numerals (into {\"\" 0} (for [o (range (count fives)) d (range 1 10)]\n                                          [(cond\n                                            (< d 4) (apply str (repeat d (get ones o)))\n                                            (= d 4) (str (get ones o) (get fives o))\n                                            (< d 9) (apply str (get fives o) (repeat (- d 5) (get ones o)))\n                                            (= d 9) (str (get ones o) (get ones (inc o))))\n                                           (* d (nth (iterate (partial * 10) 1) o))]))\n                  [t n] (reduce (fn [[t n] c]\n                                  (if (contains? numerals (str n c))\n                                    [t (str n c)]\n                                    [(+ t (numerals n)) c]))\n                                [0 \"\"]\n                                (seq x))]\n              (+ t (numerals n))))", "user": "51e28063e4b08e53a149f0f2"}, {"problem": 92, "code": "(fn [numeral-string]\n  (let [letter-values (map {\\I 1, \\V 5, \\X 10, \\L 50,  \\C 100, \\D 500, \\M 1000} numeral-string)\n        letter-value-pairs (partition 2 1 [0] letter-values)\n        evaluate-first (fn [[current-value next-value]]\n                         (if (< current-value next-value)\n                           (- current-value)\n                           current-value))]\n    (reduce + (map evaluate-first letter-value-pairs))))", "user": "54cc26c1e4b057c6fda3a28a"}, {"problem": 92, "code": "(fn [s] \n  \n  (let [nums {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000}\n        levels {\\I 1, \\V 2, \\X 3, \\L 4, \\C 5, \\D 6, \\M 7}]\n    \n    (letfn [(is-substractive [seg] (and (= 2 (count seg)) \n                                          (< (second (first seg))\n                                             (second (second seg))\n                                             )))\n            (comp-substractive [seg] (- (nums (first (second seg))) \n                                          (nums (first (first  seg)))\n                                          ))\n            (add-together [seg] (reduce + (map #(nums (first %)) seg)))\n            (parse-segment [seg] (if (is-substractive seg) \n                                     (comp-substractive seg)\n                                     (add-together seg)))] \n      \n        (let [seqs (seq s)\n              slevels (map levels seqs)\n              compounds (map vector seqs slevels)\n\n              taketwo (map vector slevels (conj (vec (rest slevels)) -1))\n              dropping (map #(> (first %) (second %)) taketwo)\n              dropping-wind (map-indexed vector dropping)\n              dropping-ind (filter #(second %) dropping-wind)\n\n              prev-seg-end (cons -1 (map first (drop-last dropping-ind)))\n              seg-length (map - (map first dropping-ind) prev-seg-end)\n              seg-drop (map inc prev-seg-end)\n              seg-profiles (map vector seg-drop seg-length)\n              segs (map #(take (second %) (drop (first %) compounds)) seg-profiles)\n\t              \n\t\t\t  values (map parse-segment segs)]\n          \n          (reduce + values)\n          ))))", "user": "52faec2ee4b047fd55837004"}, {"problem": 92, "code": "#(loop [t 0\n        p 0\n        s (map {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000} (reverse %))]\n   (if (seq s)\n     (let [v (first s)\n           s (rest s)]\n       (if (< v p)\n         (recur (- t v) v s)\n         (recur (+ t v) v s)))\n     t))", "user": "54dd76c8e4b024c67c0cf794"}, {"problem": 92, "code": "(fn rroman [rnum]\n  (let [m { \\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000}]\n    (loop [r rnum n 0]\n      (let [l1 (first r) l2 (second r)]\n        (cond\n          (empty? r) n\n          (or (nil? l2) (= l1 l2) (> (get m l1) (get m l2)))\n          (recur (rest r) (+ n (get m l1)))\n          :else\n          (recur (nthnext r 2) (+ n (- (get m l2) (get m l1)))))))))", "user": "54e3df6ae4b024c67c0cf7e3"}, {"problem": 92, "code": "(fn [s]\n  (let [p2\n        (fn p2 [b s]\n          (if (zero? (count s))\n            0\n            (let [f (first s) r (rest s)]\n              (+ (cond\n                   (= f \\M) (if (= b \\C) 800 1000)\n                   (= f \\D) (if (= b \\C) 300 500)\n                   (= f \\C) (if (= b \\X)  80 100)\n                   (= f \\L) (if (= b \\X)  30  50)\n                   (= f \\X) (if (= b \\I)   8  10)\n                   (= f \\V) (if (= b \\I)   3   5)\n                   (= f \\I) 1)\n                 (p2 f r)))))]\n    (p2 nil s)))", "user": "53664e3be4b0243289761e74"}, {"problem": 92, "code": "(fn [rn]\n  (letfn [(_ [acc rn]\n    (if-not (seq rn)\n      acc\n      (cond\n        (re-seq #\"^M+\" rn) (_ (+ acc (* 1000 (count (take-while #(= \\M %) rn)))) (apply str (drop-while #(= \\M %) rn)))\n        (re-seq #\"^CD\" rn) (_ (+ acc 400) (apply str (drop 2 rn)))\n        (re-seq #\"^CM\" rn) (_ (+ acc 900) (apply str (drop 2 rn)))\n        (re-seq #\"^C+\" rn) (_ (+ acc (* 100 (count (take-while #(= \\C %) rn)))) (apply str (drop-while #(= \\C %) rn)))\n        (re-seq #\"^D+\" rn) (_ (+ acc 500 (* 100 (count (take-while #(= \\C %) (rest rn))))) (apply str (drop-while #(= \\C %) (rest rn))))\n        (re-seq #\"^XL\" rn) (_ (+ acc 40) (apply str (drop 2 rn)))\n        (re-seq #\"^XC\" rn) (_ (+ acc 90) (apply str (drop 2 rn)))\n        (re-seq #\"^X+\" rn) (_ (+ acc (* 10 (count (take-while #(= \\X %) rn)))) (apply str (drop-while #(= \\X %) rn)))\n        (re-seq #\"^L+\" rn) (_ (+ acc 50 (* 10 (count (take-while #(= \\X %) (rest rn))))) (apply str (drop-while #(= \\X %) (rest rn))))\n        (re-seq #\"^IV\" rn) (_ (+ acc 4) (apply str (drop 2 rn)))\n        (re-seq #\"^IX\" rn) (_ (+ acc 9) (apply str (drop 2 rn)))\n        (re-seq #\"^I+\" rn) (_ (+ acc (* 1 (count (take-while #(= \\I %) rn)))) (apply str (drop-while #(= \\I %) rn)))\n        (re-seq #\"^V+\" rn) (_ (+ acc 5 (* 1 (count (take-while #(= \\I %) (rest rn))))) (apply str (drop-while #(= \\I %) (rest rn))))\n        :else 0)))]\n    (_ 0 rn)))", "user": "5213d7aae4b0961f15ac4d72"}, {"problem": 92, "code": "(fn [sss] (reduce (fn [curr-sum [k v]](+ curr-sum (* (case k\n                                               \\I 1\n                                               \\V 5\n                                               \\X 10\n                                               \\L 50\n                                               \\C 100\n                                               \\D 500\n                                               \\M 1000\n                                               ) \n                                            (count v)))) \n          0\n          (group-by identity\n                    (reduce (fn [s [f t]] (clojure.string/replace s f t)) sss [\n                                                                             [\"IV\" \"IIII\"]\n                                                                             [\"IX\" \"IIIIIIIII\"]\n                                                                             [\"XL\" \"XXXX\"]\n                                                                             [\"XC\" \"XXXXXXXXX\"]\n                                                                             [\"CD\" \"CCCC\"]\n                                                                             [\"CM\" \"CCCCCCCCC\"]\n                                                                             ]))))", "user": "50856bd1e4b004985b776e4c"}, {"problem": 92, "code": "#(let [vm {\\X 10 \\M 1000 \\C 100 \\L 50 \\I 1 \\V 5 \\D 500}]\n   (loop [[f s & r] %\n          tot 0]\n     (if (and f s) \n       (if (>= (vm f) (vm s))\n         (recur (conj  r s) (+ tot (vm f)))\n         (recur r (+ tot (- (vm s) (vm f))))\n         )\n       (if f\n         (+ tot (vm f))\n         tot))))", "user": "524025bce4b0ad64fa01030f"}, {"problem": 92, "code": "(comp {\\I 14 \\C 827 \\M 3999 \\L 48} second)", "user": "54b7f217e4b0ed20f4ff6e8f"}, {"problem": 92, "code": "(fn rn[st]\n  (let [ls (seq st)\n        sv {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000}]\n    (letfn [(prs [sq v lst]\n              (let [nxt (sv (first sq))\n                    rst (rest sq)] \n                (cond\n                  (empty? rst) (+ v (if (< lst nxt) (- nxt lst)(+ nxt lst)))\n                  (zero? lst) (prs rst v nxt)\n                  (< lst nxt) (prs rst (+ v (- nxt lst)) 0) \n                  :else (prs rst (+ v lst) nxt))))]\n      (prs ls 0 0))))", "user": "54d4bd2be4b0a52adc2e2005"}, {"problem": 92, "code": "(fn [r]\n  (let [m {\"II\" 1 \"IV\" -1 \"IX\" -1 \"VI\" 5 \"XX\" 10 \"XV\" 10 \"XI\" 10 \"XL\" -10 \n    \"XC\" -10 \"LV\" 50 \"LX\" 50 \"LI\" 50 \"CC\" 100 \"CL\" 100 \"CX\" 100 \"CV\" 100\n    \"CI\" 100 \"CM\" -100 \"CD\" -100 \"DC\" 500 \"DL\" 500 \"DX\" 500  \"DV\" 500\n    \"DI\" 500 \"MM\" 1000 \"MD\" 1000 \"MC\" 1000 \"ML\" 1000 \"MX\" 1000\n     \"MV\" 1000 \"MI\" 1000}]\n    (reduce (fn [c v] (+ c (m v))) 0 (map #(apply str %) (partition 2 1 [\\I] r)))))", "user": "54908cc1e4b0b312c081ff32"}, {"problem": 92, "code": "(fn ([s] (->> s\n            reverse\n            (map {'\\M 1000 '\\D 500 '\\C 100 '\\L 50 '\\X 10 '\\V 5 '\\I 1})\n            (reduce #(let [o (if (< %2 (or (:last %1) -100000)) - +)] (hash-map :sum (o (or (:sum %1) 0) %2) :last %2)) '{})\n            :sum)))", "user": "54d8cc38e4b0a52adc2e203e"}, {"problem": 92, "code": "(fn [numeral]\n  (let [subtractive {\"IV\" 4 \"IX\" 9 \"XL\" 40 \"XC\" 90 \"CD\" 400 \"CM\" 900}\n        values {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}\n        produce (fn [sequence]\n                  (if-let [v (subtractive (apply str (take 2 sequence)))]\n                    [v (nthrest sequence 2)]\n                    [(values (first sequence)) (rest sequence)]))]\n    (loop [accum 0 symbols numeral]\n      (if (empty? symbols) accum\n          (let [[value remainder] (produce symbols)]\n            (println [value remainder])\n            (recur (+ accum value) remainder))))))", "user": "524740e7e4b05ef8e38e635d"}, {"problem": 92, "code": "(let [sub {\"IV\" \"IIII\", \"IX\" \"VIIII\", \"XL\" \"XXXX\", \"XC\" \"LXXXX\", \"CD\" \"CCCC\", \"CM\" \"DCCCC\"}\n      value {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]\n  (fn [s]\n    (reduce #(+ %1 (value %2)) 0 (reduce (fn [s [a b]] (clojure.string/replace s a b)) s sub))))", "user": "54f0d3fde4b024c67c0cf8a6"}, {"problem": 92, "code": "(fn read-roman [s]\n  (let [numerals {\\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1}\n        nums (partition 2 1 (concat (map numerals s) [0]))]\n    (reduce (fn [sum [a b]] ((if (< a b) - +) sum a)) 0 nums)))", "user": "539c736ce4b0b51d73faaf2b"}, {"problem": 92, "code": "(fn readRN ([s] (readRN 0 (map str(flatten (partition 1 s)))))\n  \t\t   ([v s] (let [numerals {\"I\" 1 \"V\" 5 \"X\" 10 \"L\" 50 \"C\" 100 \"D\" 500 \"M\" 1000}]\n                 (case (count s)\n                   \t\t0 v\n                   \t\t1 (+ v (numerals (first s)))\n                   \t\t(if (< (numerals (first s)) (numerals (second s))) \n                          \t(readRN (+ v (- (numerals (second s)) (numerals (first s)))) (rest (rest s))) \n                          \t(readRN (+ v (numerals (first s))) (rest s)))))))", "user": "542c1f73e4b0dad94371f29d"}, {"problem": 92, "code": "(fn to-arabic [romstr]\n  (let [comprom (fn [n m]\n                  (let [order \"IVXLCDM\"]\n                    (apply - (map #(.indexOf order (str %)) [n m]))))\n        rom-map (zipmap\n                 \"IVXLCDM\"\n                 (map #(int (if (even? %)\n                              (Math/pow 10 (/ % 2))\n                              (* 5 (Math/pow 10 (/ (dec %) 2))))) (range 7)))\n        fst (first romstr)\n        snd (second romstr)\n        [fstv sndv] (map #(get rom-map %) [fst snd])]\n    (if (nil? fst) 0\n        (apply + (if (and snd (neg? (comprom fst snd)))\n                   [(- sndv fstv) (to-arabic (drop 2 romstr))]\n                   [fstv (to-arabic (rest romstr))])))))", "user": "51b76227e4b0d906fcd71d35"}, {"problem": 92, "code": "#(loop [xs (map {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000} (reverse %)) y (nth xs 0)]\n   (if (>= (count xs) 2)\n     (recur (rest xs) (({true + false -} (<= (nth xs 0) (nth xs 1)))\n                       y\n                       (nth xs 1)))\n     y))", "user": "54d753ebe4b0a52adc2e2029"}, {"problem": 92, "code": "#((fn f [a] (let [x (first a) y (second a) z (rest a) e (empty? (rest z))] (if (empty? z) x (if (< x y) (+ y (- (if e 0 (f (rest z))) x)) (+ x (if e y (f z))))))) (map {\"M\" 1000, \"D\" 500, \"C\" 100, \"L\" 50, \"X\" 10, \"V\" 5, \"I\" 1} (map str (seq %))))", "user": "533f1584e4b085b17e897d9b"}, {"problem": 92, "code": "(fn [x]\n  (let [rom-map { 1000  \"M\",\n                   900 \"CM\",\n                   500  \"D\",\n                   400 \"CD\",\n                   100  \"C\",\n                    90 \"XC\",\n                    50  \"L\",\n                    40 \"XL\",\n                    10  \"X\",\n                     9 \"IX\",\n                     5  \"V\",\n                     4 \"IV\",\n                     1  \"I\"}\n       rom-vals (sort-by count > (vals rom-map))\n       rom-map-rev (clojure.set/map-invert rom-map)]\n  (loop [res 0\n         rst x]\n       (if (= rst \"\")\n           res\n           (let [add (some #(re-find (re-pattern (str \"^\" %)) rst) rom-vals)]\n                (recur (+ res (rom-map-rev add))\n                       (apply str (drop (count (str add)) (seq rst)))))))))", "user": "544e8369e4b0e39780006987"}, {"problem": 92, "code": "(fn [roman]\n  (let [letter-nums {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000}\n        nums (map letter-nums roman)\n        with-rest (map-indexed (fn [idx num] [num (drop (inc idx) nums)]) nums)]\n    (reduce (fn [sum [n others]]\n              (if (some (partial < n) others)\n                (- sum n)\n                (+ sum n)))\n            0\n            with-rest)))", "user": "5344fe13e4b084c2834f4a32"}, {"problem": 92, "code": "(let [replace #(clojure.string/replace %1 %2 (str %3 \" \"))]\n  (fn [roman]\n    (-> roman\n        (replace #\"IV\" \"4\")\n        (replace #\"IX\" \"9\")\n        (replace #\"XL\" \"40\")\n        (replace #\"XC\" \"90\")\n        (replace #\"CD\" \"400\")\n        (replace #\"CM\" \"900\")        \n        (replace #\"I\" \"1\")\n        (replace #\"V\" \"5\")\n        (replace #\"X\" \"10\")\n        (replace #\"L\" \"50\")\n        (replace #\"C\" \"100\")\n        (replace #\"D\" \"500\")\n        (replace #\"M\" \"1000\")\n        (clojure.string/split #\" \")\n        (->> (map read-string)\n             (apply +)))))", "user": "54febf4be4b07d26eda61d45"}, {"problem": 92, "code": "(fn [roman]\n  (let [m {\"M\" 1000 \"CM\" 900 \"D\" 500 \"CD\" 400 \"C\" 100\n           \"XC\" 90 \"L\" 50 \"XL\" 40 \"X\" 10 \"IX\" 9\n           \"V\" 5 \"IV\" 4 \"I\" 1}]\n    (loop [r roman n 0]\n      (if (empty? r)\n        n\n        (let [[a b & more] r\n              ab (str a b)]\n          (if (contains? m ab)\n            (recur (apply str more)   (+ n (get m ab)))\n            (recur (apply str b more) (+ n (get m (str a))))))))))", "user": "54ddb556e4b024c67c0cf798"}, {"problem": 92, "code": "(fn [n]\n   (let [m {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}\n         int-seq (map m n)]\n     (loop [v 0 tc (first int-seq) [tn & trs] (rest int-seq)]\n       (cond\n         (nil? tn) (+ v tc)\n         (< tc tn) (recur (- v tc) tn trs)\n         :else (recur (+ v tc) tn trs)))))", "user": "523b4e91e4b07becd5be21ef"}, {"problem": 92, "code": "(fn [roman] \n  (loop [previous-number 0 \n         my-number 0 \n         my-numerals (replace {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000} (reverse (seq roman)))]\n    (cond \n     (nil? (first my-numerals)) my-number\n     (>= (first my-numerals) previous-number) (recur \n                                               (first my-numerals) \n                                               (+ my-number (first my-numerals))\n                                               (rest my-numerals))\n     (< (first my-numerals) previous-number) (recur \n                                               (first my-numerals) \n                                               (- my-number (first my-numerals))\n                                               (rest my-numerals)))))", "user": "54d2c4c5e4b0e8a36923e5fa"}, {"problem": 92, "code": "(fn [s]\n  (let [char-map {\\I 1\n               \t  \\V 5\n                  \\X 10\n                  \\L 50\n                  \\C 100\n                  \\D 500\n                  \\M 1000}]\n    (loop [rem s\n           acc 0]\n      (let [cur (first rem)\n            num (get char-map cur)\n            sec (second rem)\n            sec-num (get char-map sec 0)]\n        (if (empty? rem)\n          acc\n          (if (> sec-num num)\n            (recur (rest (rest rem)) (+ acc (- sec-num num)))\n            (recur (rest rem) (+ acc num))))))))", "user": "5498e155e4b0b312c081ff86"}, {"problem": 92, "code": "(letfn [(rval [l]\n          (case l\n            \\I 1\n            \\V 5\n            \\X 10\n            \\L 50\n            \\C 100\n            \\D 500\n            \\M 1000))\n        (rI [stt nseq] (if-let [[d r] (seq nseq)]\n                         (let [dv (rval d)]\n                           (if (>= dv stt) (+ dv (rI dv (next nseq))) (- (rI stt (next nseq)) dv)))\n                         0))]\n  (fn [nstr] (rI 1 (reverse nstr))))", "user": "53908e6be4b0b51d73faae9a"}, {"problem": 92, "code": "(fn [rims]\n   (let [nums {\"I\" 1 \"V\" 5 \"X\" 10 \"L\" 50 \"C\" 100 \"D\" 500 \"M\" 1000}]\n     (loop [test :firt rims rims nums nums res 0]\n       (println test rims res (str (first rims)) (get nums (str (first rims))))\n       (if (= \"IV\" (str (first rims) (second rims)))\n         (recur :1 (drop 2 rims) nums (+ res 4))\n         (if (= \"IX\" (str (first rims) (second rims)))\n           (recur :1 (drop 2 rims) nums (+ res 9))\n           (if (= \"XC\" (str (first rims) (second rims)))\n             (recur :1 (drop 2 rims) nums (+ res 90))\n             (if (= \"XL\" (str (first rims) (second rims)))\n               (recur :1 (drop 2 rims) nums (+ res 40))\n               (if (= \"CD\" (str (first rims) (second rims)))\n                 (recur :1 (drop 2 rims) nums (+ res 400))\n                 (if (= \"CM\" (str (first rims) (second rims)))\n                   (recur :1 (drop 2 rims) nums (+ res 900))\n                   (if (empty? rims)\n                     res\n                     (recur :2 (rest rims) nums (+ res (get nums (str (first rims)))))))))))))))", "user": "5508102ee4b021ccfedb96b0"}, {"problem": 92, "code": "(let [m {\"M\" 1000 \"CM\" 900 \"D\" 500 \"CD\" 400 \"C\" 100 \"XC\" 90 \"L\" 50 \"XL\" 40 \"X\" 10 \"IX\" 9 \"V\" 5 \"IV\" 4 \"I\" 1}]\n  (fn k [s]\n    (let [v2 (m (apply str (take 2 s)))\n          v1 (m (apply str (take 1 s)))]\n      (cond\n        v2 (+ v2 (k (drop 2 s)))\n        v1 (+ v1 (k (drop 1 s)))\n        :else 0\n        ))))", "user": "50f10f7be4b06d9538fe211a"}, {"problem": 92, "code": "(fn roman->int\n  [s] {:pre [(string? s)]}\n  (let [digits {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000}]\n    (->> s\n         (reduce (fn [[last-digit & more :as acc] c]\n                   (if (and last-digit (< last-digit (digits c)))\n                     (cons (- (digits c) last-digit) more)\n                     (cons (digits c) acc)))\n                 [])\n         (apply +))))", "user": "4fc6305de4b0ee37620e180b"}, {"problem": 92, "code": "(fn __ [romstr]\n  (if (seq romstr)\n    (let [rns {\"M\" 1000,\n               \"CM\" 900,\n               \"D\" 500,\n               \"CD\" 400,\n               \"C\" 100,\n               \"XC\" 90,\n               \"L\" 50,\n               \"XL\" 40,\n               \"X\" 10,\n               \"IX\" 9,\n               \"V\" 5,\n               \"IV\" 4,\n               \"I\" 1}\n          tok2 (apply str (take 2 romstr))\n          tok1 (str (first romstr))]\n      (if (contains? rns tok2)\n        (+ (rns tok2) (__ (apply str (drop 2 romstr))))\n        (+ (rns tok1) (__ (apply str (rest romstr))))))\n    0))", "user": "53e76bb2e4b036ad0777e47d"}, {"problem": 92, "code": "(fn roman-num [roman]\n    (letfn [(to-num [rnum] \n        (let [dict {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]\n            (get dict rnum)))]\n    (let [num-lst (map to-num roman)\n        zipped (map vector num-lst (rest num-lst))]\n            (+ (last num-lst) \n                (reduce #(+ %1 (if (> (second %2) (first %2))\n                    (- (first %2))\n                    (first %2))) \n                0 zipped)))))", "user": "54f09599e4b024c67c0cf89d"}, {"problem": 92, "code": "(fn [astr]\n          (let [t {\\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1}]\n            (first (reduce \n              (fn [acc newv]  (let [\n                                    [res lastv] acc\n                                    nextv (get t newv)\n                                    op (if (>= nextv lastv) + -)\n                                    ]\n                               [(op res nextv) nextv]))\n              [0 0]\n              (reverse (seq astr))))\n            )\n          )", "user": "533c2605e4b0e30313ee6cd7"}, {"problem": 92, "code": "(fn roman-to-int [s]\n    (if (empty? s)\n      0\n      (let [r '{\"M\" 1000 \"CM\" 900 \"D\" 500 \"CD\" 400 \"C\" 100 \"XC\" 90 \"L\" 50 \"XL\" 40 \"X\" 10 \"IX\" 9 \"V\" 5 \"IV\" 4 \"I\" 1}\n            spl (fn [n s] (map #(apply str %) (split-at n s)))\n            [h1 t1] (spl 2 s)\n            [h2 t2] (spl 1 s)]\n        (if (r h1)\n            (+ (r h1) (roman-to-int t1))\n            (+ (r h2) (roman-to-int t2))))))", "user": "4ee6400c535d93acb0a6685b"}, {"problem": 92, "code": "(fn from-roman [my-str]\n  (let [\n        val-nbr     { \\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1}\n        lst-str     (map val-nbr (apply list my-str))\n        part-str    (partition-all 2 1 lst-str)\n        add-nbr     (map #(if (and (apply < %) ( > (count %) 1) ) ( - (first % )) (first %)  ) part-str)\n\n       ]\n       (apply + add-nbr)))", "user": "528b3f5ae4b0239c8a67ae93"}, {"problem": 92, "code": "#(loop [[a & s] % r 0]\n   (if a\n     (let [c {\\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1}\n           x (c a)\n           y (or (c (first s)) 0)]\n       (prn a x y)\n       (if (< x y)\n         (recur (rest s) (+ r (- y x)))\n         (recur s (+ r x))))\n     r))", "user": "55201d18e4b08d5046aa8a5d"}, {"problem": 92, "code": "(fn [s]\n  (reduce +\n    (map {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}\n      (seq (reduce #(apply clojure.string/replace %1 %2)\n             s\n             [[\"IV\" \"IIII\"]\n              [\"IX\" \"IIIIIIIII\"]\n              [\"XL\" \"XXXX\"]\n              [\"XC\" \"XXXXXXXXX\"]\n              [\"CD\" \"CCCC\"]\n              [\"CM\" \"CCCCCCCCC\"]])))))", "user": "52d3f666e4b09f7907dd1327"}, {"problem": 92, "code": "(fn [a-str]\n   (let [num-lookup {\\C 100, \\D 500, \\I 1, \\L 50, \\M 1000, \\V 5, \\X 10}]\n     (reduce + \n           (map (fn [[a b]] (if (< a b) (- a) a)) \n                (partition 2 1 [0] \n                           (map num-lookup a-str))))))", "user": "5536dfaee4b09218d5f44fc4"}, {"problem": 92, "code": "(fn roman2num [roman]\n  (let [roman-map {\"I\" 1,\"V\" 5, \"X\" 10, \"L\" 50, \"C\" 100, \"D\" 500, \"M\" 1000}\n        roman-seq (for [i roman] (str i))\n        roman-asc-val (fn [asc] (roman-map asc))\n        roman-val-seq (fn [ss] (map roman-asc-val ss))\n        roman-valseq  (roman-val-seq roman-seq)\n        roman-valpar  (partition 2 1 roman-valseq)\n        roman-negtive (map first (filter #(< (first %) (second %)) roman-valpar))]\n    (- (apply + roman-valseq) (* 2 (apply + roman-negtive)))))", "user": "5243e37ae4b076204b44fae3"}, {"problem": 92, "code": "(fn r\n  ([s] (r s 0))\n  ([s n]\n    (if (= s \"\") n\n      (let [Ns [\n            [1000 \"M\"] [900 \"CM\"] [500 \"D\"] [400 \"CD\"]\n            [100 \"C\"] [90 \"XC\"] [50 \"L\"] [40 \"XL\"]\n            [10 \"X\"] [9 \"IX\"] [5 \"V\"] [4 \"IV\"] [1 \"I\"]]\n          [a b] (some #(when (.startsWith s (second %)) %) Ns)]\n        (r (subs s (count b)) (+ n a))))))", "user": "53500869e4b084c2834f4ad3"}, {"problem": 92, "code": "(fn [n] (reduce +\n                (map #(  case %\n                        \\V 5\n                        \\I 1\n                        \\X 10\n                        \\L 50\n                        \\C 100\n                        \\D 500\n                        \\M 1000)\n                     (seq ((fn [s]\n                             (let [mappings '([\"IM\" \"DCCCCLXXXXVIIII\"]\n                                              [\"VM\" \"DCCCCLXXXXV\"]\n                                              [\"XM\" \"DCCCCLXXXX\"]\n                                              [\"LM\" \"DCCCCL\"]\n                                              [\"CM\" \"DCCCC\"]\n                                              [\"ID\" \"CCCCLXXXXVIIII\"]\n                                              [\"VD\" \"CCCVC\"]\n                                              [\"XD\" \"CCCCLXXXX\"]\n                                              [\"LD\" \"CCCCL\"]\n                                              [\"CD\" \"CCCC\"]\n                                              [\"XC\" \"LXXXX\"]\n                                              [\"IC\" \"CCCCXXXXVIIII\"]\n                                              [\"VC\" \"CCCCXXXXV\"]\n                                              [\"IL\" \"XXXXVIIII\"]\n                                              [\"XC\" \"LXXXX\"]\n                                              [\"VC\" \"LXXXXV\"]\n                                              [\"XCM\" \"DCCCLXXXX\"]\n                                              [\"IVL\" \"XXXXIIII\"]\n                                              [\"VL\" \"XXXXV\"]\n                                              [\"XL\" \"XXXX\"]\n                                              [\"IX\" \"VIIII\"]\n                                              [\"IV\" \"IIII\"])]\n                               (reduce #(clojure.string/replace %1 (first %2) (second %2)) s mappings))) n)))))", "user": "53aaaf7ae4b047364c044444"}, {"problem": 92, "code": "(let [roman {\\M  1000\n             \\D   500\n             \\C   100\n             \\L    50\n             \\X    10\n             \\V     5\n             \\I     1}]\n  (fn [s]\n    (loop [[c1 c2 & cs] s\n           acc 0]\n      (if (nil? c1)\n        acc\n        ;; This should correctly parse all properly formatted roman numerals.\n        ;; It also will parse lots of incorrectly formatted roman numerals.\n        ;; A full solution would contain error checking.\n        (if (and c2 (< (roman c1) (roman c2)))\n          (recur cs\n                 (+ acc (- (roman c1)) (roman c2)))\n          (recur (cons c2 cs)\n                 (+ acc (roman c1))))))))", "user": "5531e445e4b09218d5f44f76"}, {"problem": 92, "code": "#(apply + (map {\"M\" 1000 \n      \"CM\" 900\n      \"D\"  500\n      \"CD\" 400\n      \"C\"  100\n      \"XC\" 90\n      \"L\"  50\n      \"XL\" 40\n      \"X\"  10\n      \"IX\"  9\n      \"V\"   5\n      \"IV\"  4\n      \"I\"   1} (re-seq #\"M|CM|D|CD|C|XC|L|XL|X|IX|V|IV|I\" %)))", "user": "54a1d643e4b09f271ff37c50"}, {"problem": 92, "code": "(fn [s]\n  (let [\n        r {\\M [1000 0] \\D [500 0] \\C [100 500]\n           \\L [50 0] \\X [10 50] \\V [5 0] \\I [1 5]}\n        add (fn [a c]\n              (let [[x y] (r c)]\n                (if (<= 1 y a) (- a x) (+ a x))))\n        ]\n    (reduce add 0 (reverse s))))", "user": "553e0b70e4b0a04f792994e8"}, {"problem": 92, "code": "(fn [roman]\n  (loop [v 0\n         s (->> (seq roman)\n                (map {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000})\n                (partition-by identity)\n                (map (partial apply +)))]\n    (if (< (count s) 2)\n      (apply + v s)\n      (let [s0 (first s) s1 (second s)]\n        (recur\n          (if (< s0 s1) v (+ v s0))\n          (cons (if (< s0 s1) (- s1 s0) s1) (drop 2 s)))))))", "user": "553abb28e4b09218d5f44ffb"}, {"problem": 92, "code": "(fn roman-to-decimal\n  ([n]\n    (let [numbers (re-seq #\"MMM|MM|M|DDD|DD|D|CCC|CC|C|LLL|LL|L|XXX|XX|X|VVV|VV|V|III|II|I\" n)]\n    (roman-to-decimal (first numbers) (rest numbers))))\n  ([digit-group r]\n    (let [digit-values {\\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1}\n          digit-value (digit-values (last digit-group))\n          digit-group-value (* digit-value (count digit-group))]\n      (if (empty? r)\n        digit-group-value\n        (let [next-digit-group-value (digit-values (first (first r)))\n              sign (if (> digit-group-value next-digit-group-value) + -)]\n          (+\n          (sign digit-group-value)\n          (roman-to-decimal (first r) (rest r))))))))", "user": "5481be5fe4b0e286459a1172"}, {"problem": 92, "code": "(fn [s]\n  (let [rom (zipmap \"MDCLXVI\" [1000 500 100 50 10 5 1])]\n    ((fn [digits sum]\n       (let [x (first digits) y (second digits)]\n         (if (<= (count digits) 1)\n           (+ sum (or x 0))\n           (if (>= x y)\n             (recur (rest digits) (+ sum x))\n             (recur (nthrest digits 2) (+ sum (- y x)))))))\n     (map rom s)\n     0)))", "user": "55495318e4b0a04f79299566"}, {"problem": 92, "code": "(fn roman [romanstr]\n  (let [digits (map {\\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1} romanstr)]\n    (reduce\n      (fn [s [a b]] (if (>= a b) (+ s a) (- s a)))\n      0\n      (map vector digits (concat (drop 1 digits) [0])))))", "user": "54b04708e4b09f271ff37d11"}, {"problem": 92, "code": "(fn [s]\n  (->> s\n       seq\n       (map {\\M 1000, \\D 500, \\C 100, \\L 50, \\X 10, \\V 5, \\I 1})\n       (partition 2 1 [0])\n       (map (fn [[a b]] (if (< a b) (- a) a)))\n       (apply +)))", "user": "52ce1abfe4b07d0d72b27389"}, {"problem": 92, "code": "(let [number-map {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]\n  (fn [roman-numeral]\n    (let [numbers (map #(number-map %) roman-numeral)]\n      (letfn [(eval-number-collection [col]\n                (cond \n                  (empty? col) 0\n                  (= 1 (count col)) (first col)\n                  (> (second col) (first col)) (+ (eval-number-collection (rest (rest col)))\n                                                  (- (second col) (first col)))\n                  :else (+ (first col) (eval-number-collection (rest col)))))]\n        (eval-number-collection numbers)))))", "user": "5553b924e4b0deb715856e06"}, {"problem": 92, "code": "(fn [s]\n  (apply + \n  (let [sq (map {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000 } s)]\n    (map #(let [n0 (nth sq %) n1 (or (nth sq (inc %) 0))]\n            (if (>= n0 n1) n0 (- n0))) \n         (range (count s))))))", "user": "533ea7e8e4b085b17e897d94"}, {"problem": 92, "code": "(fn f [v]\n(let [s (map {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000} v)]\n    (apply +\n      (reduce\n        (fn [[t l] n] [((if (< l n) - +) t l) n])\n        [0 (first s)]\n        (rest s)))))", "user": "551c66dae4b07993ea3788de"}, {"problem": 92, "code": "(fn __ [numeral]\n   (let [nums (map {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000} numeral)\n         sum (apply + nums)\n         to-subtract (->> (partition 2 1 nums)\n                        (map (fn [[x y]] (if (< x y) x 0)))\n                        (apply +)\n                        (* 2))\n                       ]\n   (- sum to-subtract)))", "user": "54924f64e4b0b312c081ff42"}, {"problem": 92, "code": "(fn [s] \n  (->> \n   s\n   (map {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000})\n   (reverse)\n   (reduce \n    #(vector \n      ((if (< %2 (second %1)) - +) (first %1) %2) \n      (max (second %1) %2)\n    ) [0 0])\n   (first) \n))", "user": "5280a1ece4b0757a1b171407"}, {"problem": 92, "code": "(fn roman [s]\n  (:val (let [ v {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]\n    (reduce \n      (fn [sum i]\n        (if (< (:last sum) (v i))\n          (assoc sum :last (v i) :val (+ (v i) (- (:val sum) (:last sum) (:last sum))))\n          (assoc sum :last (v i) :val (+ (:val sum) (v i))))) \n      {:val 0 :last 1000} \n      s))))", "user": "55536a8ae4b0deb715856e03"}, {"problem": 92, "code": "(fn romain->int [s]\n  (let [roman-map {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}\n        digits (map roman-map s)\n        rev-digits (reverse digits)\n        f (fn [[previous total] el]\n            (if (> previous el)\n              [el (- total el)]\n              [el (+ total el)]))]\n    (second (reduce f [-1 0] rev-digits))))", "user": "5264383be4b03e8d9a4a70cb"}, {"problem": 92, "code": "(fn [roman]\n  (let [legend {\\M 1000\n                \\D 500\n                \\C 100\n                \\L 50\n                \\X 10\n                \\V 5\n                \\I 1}]    \n    ;; split string into subsequences where consecutive letters are the same\n    (->> (map vec (partition-by identity roman))\n         ;; for each element in the list, absorb the next item in the list if its\n         ;; letter represents a number greater than the current item\n         (reduce #(if (or (= 0 (count %))\n                                        (>= (get legend (last (last %)))\n                                            (get legend (first %2))))\n                                  (conj % %2)\n                                  (update-in % [(dec (count %))] conj (first %2)))\n                 [])\n         ;; convert each list of chars into a number using subtractive principle\n         (map #(if (apply not= %)\n                        (- (get legend (last %))\n                           (get legend (first %)))\n                        (* (get legend (first %)) (count %))))\n         ;; finally, add the numbers together\n         (apply +))))", "user": "5512aca6e4b055c2f668d4b4"}, {"problem": 92, "code": "(fn [roman]\r\n  (let [digits {\\I 1, \\V 5, \\X 10, \\L 50,\r\n                \\C 100, \\D 500, \\M 1000}]\r\n    (loop [\r\n        [head & tail] roman\r\n        prev-value nil\r\n        result 0]\r\n      (if (nil? head)\r\n        result\r\n        (let [value (digits head)]\r\n          (recur tail value\r\n            (if (or (nil? prev-value) (>= prev-value value))\r\n              (+ result value)\r\n              (+ (- result (* 2 prev-value)) value))))))))", "user": "555bd27ae4b0b056612e2244"}, {"problem": 92, "code": "#(case % \"XIV\" 14 \"DCCCXXVII\" 827 \"XLVIII\" 48 3999)", "user": "5507cfd3e4b021ccfedb96ad"}, {"problem": 92, "code": "#(let[romanNumMap {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000}]; convient lookup map for roman characters\n   (loop[result 0, preVal 0, remaining (reverse %)]\n     (if-let [currentVal (romanNumMap (first remaining))]\n       (if (< currentVal preVal)\n         (recur (- result currentVal) currentVal (rest remaining)) ;for sth like IV, IIX\n         (recur (+ result currentVal) currentVal (rest remaining))) ;for sth like VII\n       result))) ;return result", "user": "556c70dae4b09a3098a524fd"}, {"problem": 92, "code": "(fn mm [para]\n  (let [value-map {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]\n    (letfn [(t1 [s]\n              (if (< (count s) 2)\n                (if (= 0 (count s)) [] [s])\n                (if (< (value-map (first s)) (value-map (second s)))\n                  (cons (subs s 0 2) (t1 (subs s 2)))\n                  (cons (subs s 0 1) (t1 (subs s 1))))))\n            (t2 [s]\n              (reduce + (map (fn [str]\n                               (if (and (> (count str) 1) (< (value-map (first str)) (value-map (second str))))\n                                 (- (value-map (second str)) (value-map (first str)))\n                                 (reduce + (map #(value-map %) str))))\n                             s)))]\n      (t2 (t1 para)))))", "user": "535f0cbde4b04ce2eb3ed2d9"}, {"problem": 92, "code": "(fn [s]\n  (let [c {\\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1}]\n    (reduce\n      (fn [n x]\n        (let [num (get c x)]\n          (if (> n (* num 4))\n            (- n num)\n            (+ n num))))\n      0\n      (reverse (seq s)))))", "user": "55625903e4b0c656e3ff17d7"}, {"problem": 92, "code": "(fn [rnustr]\n    (let [decode {nil 0 \\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]\n      (loop [charseq (seq rnustr)\n             result  0]\n        (let [[char1 & rest] charseq\n              char2 (first rest)\n              firstnum  (decode char1)\n              secondnum (decode char2)\n              effectnum (if (> secondnum firstnum) (- firstnum) firstnum)\n              result (+ result effectnum)]\n          (if (nil? char2)\n            result\n            (recur rest result))))))", "user": "554a75c9e4b0a04f79299575"}, {"problem": 92, "code": "(fn rom2num [rom]\n  (let [l2int {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}\n        [x & xs] (reverse (map #(get l2int %) rom))]\n    (loop [cnt x, curr-val x, [x & xs] xs]\n      (cond (nil? x) cnt\n            (< x curr-val) (recur (- cnt x) curr-val xs)\n            :else (recur (+ cnt x) x xs)))))", "user": "54bbaa8ee4b0ed20f4ff6ec0"}, {"problem": 92, "code": "(fn roman->num [s]\n  (let [cm (zipmap \"IVXLCDM\" [1 5 10 50 100 500 1000])\n        nums (map #(get cm %) (reverse s))]\n    (first (reduce (fn [[result max-val] v]\n              (if (>= v max-val)\n                [(+ result v) v]\n                [(- result v) max-val]))\n            [0 0]\n            nums))))", "user": "55586905e4b0deb715856e2b"}, {"problem": 92, "code": "(fn [s]\n  (let [table {\\M 1000, \\D 500, \\C 100, \\L 50, \\X 10, \\V 5, \\I 1}]\n    (reduce +\n     (map \n      (fn [[a b]] (if (< a b) (- a) a))\n      (partition 2 1 [0] (map table s))))))", "user": "53065acbe4b02e8216869792"}, {"problem": 92, "code": "(fn [s]\n  (let [nums {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000}]\n  \t(reduce (fn [sum [a b]]\n              (if (and b (< a b)) (- sum a) (+ sum a)))\n            0 (partition-all 2 1 (map nums s)))))", "user": "536046a9e4b063bf7a5f8fe1"}, {"problem": 92, "code": "(fn [xs]\n  (let [ n {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000} ]\n  (loop [f (first xs) s (rest xs) res 0 p nil]\n    (if (nil? f) \n      res\n      (do (let [t (get n f)] (recur (first s) (rest s) (if (nil? p) (+ res t) (if (> t p)  (- (+ res (- t p)) p)  (+ res t))) t)))))))", "user": "54e24a05e4b024c67c0cf7ce"}, {"problem": 92, "code": "(fn [st]\n  (loop [coun 0 s st c 0 set []]\n    (if (= 0 c) (recur coun (clojure.string/replace s \"CM\" \"1\") (inc c) set)\n      (if (= 1 c) (recur coun (clojure.string/replace s \"CD\" \"2\") (inc c) set)\n        (if (= 2 c) (recur coun (clojure.string/replace s \"XC\" \"3\") (inc c) set)\n          (if (= 3 c) (recur coun (clojure.string/replace s \"XL\" \"4\") (inc c) set)\n            (if (= 4 c) (recur coun (clojure.string/replace s \"IX\" \"5\") (inc c) set)\n              (if (= 5 c) (recur coun (clojure.string/replace s \"IV\" \"6\") (inc c) set)\n                (if (empty? set) (if (false? (empty? s)) (recur coun \"\" 6 (into [] s))\n                                   coun)\n                  (recur (+ coun (get {\\1 900 \\2 400 \\3 90 \\4 40 \\5 9 \\6 4 \\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1} (first set))) s c (rest set)))))))))))", "user": "558378dce4b05c286339e115"}, {"problem": 92, "code": "(fn parseromans [r]\n  (let [numerals {\\I 1\n   \\V 5\n   \\X 10\n   \\L 50\n   \\C 100\n   \\D 500\n   \\M 1000}]\n  (->> (reverse r)\n       (replace numerals)\n       (partition-by identity)\n       (map (partial apply +))\n       (reduce #(if (< %1 %2) (+ %1 %2) (- %1 %2))))))", "user": "5283a919e4b0239c8a67adbe"}, {"problem": 92, "code": "(fn [rn]\n  (let [rnt { \\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000 }]\n    (loop [li (reverse (seq rn)) ln 0 r 0]\n      (if (empty? li)\n        r\n        (recur (rest li)\n               (rnt (first li))\n               (+ r (if (> ln (rnt (first li)))\n                      (* -1 (rnt (first li)))\n                      (rnt (first li)))))))))", "user": "52979551e4b02ebb4ef75043"}, {"problem": 92, "code": "(fn f92 [s]\n  (let [\n        ra1 {\"L\" 50, \"M\" 1000, \"C\" 100, \"V\" 5, \"X\" 10, \"I\" 1, \" \" 0, \"D\" 500}\n        ra2 {\"CD\" 400, \"XC\" 90, \"CM\" 900, \"XL\" 40, \"IX\" 9, \"IV\" 4, }  \n        get1 (fn [[x & xs]] [(ra1 (str  x)), xs] )\n        get2 (fn [[x y & xs]] [(ra2 (str x y)), xs ])\n        ]\n    (if (= 0 (count s)) \n      0\n      (let [rs (get2 s)] \n        (if (first rs)\n          (+ (first rs) (f92 (second rs)) )\n          (let [rs (get1 s)] \n            (if (first rs)\n              (+ (first rs) (f92 (second rs)) )\n              0\n              )\n            )\n          )))))", "user": "51f81925e4b09be9c177e526"}, {"problem": 92, "code": "(fn [num]\n  (let [convert {\\I 1\n                 \\V 5\n                 \\X 10\n                 \\L 50\n                 \\C 100\n                 \\D 500\n                 \\M 1000}\n        digits  (reverse num)\n        digits  (map convert digits)]\n  (loop [digits digits sum 0]\n    (if-let [digit (first digits)]\n      (let [[minus digits] (split-with (partial > digit) (rest digits))]\n        (recur digits (+ sum (- digit (apply + minus)))))\n      sum))))", "user": "548c6673e4b0e286459a1209"}, {"problem": 92, "code": "(fn [x]\n  (loop [x x sum 0]\n    (let [[r a] (some\n                 #(if (.startsWith x (% 0)) %)\n                 (map vector\n                      [\"M\" \"CM\" \"D\" \"CD\" \"C\" \"XC\" \"L\" \"XL\" \"X\" \"IX\" \"V\" \"IV\" \"I\"]\n                      [1000 900 500 400  100  90   50  40  10    9   5   4    1]))]\n      (if (empty? x) sum\n          (recur (subs x (count r)) (+ sum a))))))", "user": "552a793ee4b0ffed3738f955"}, {"problem": 92, "code": "(fn from-roman-numerals [s]                                                                                                     \n    (-> s                                                                                                                                               \n        (clojure.string/replace #\"CM\" (apply str (repeat 900 \".\")))                                                             \n        (clojure.string/replace #\"M\"  (apply str (repeat 1000 \".\")))                                                                                    \n        (clojure.string/replace #\"CD\" (apply str (repeat 400 \".\")))                                                             \n        (clojure.string/replace #\"D\"  (apply str (repeat 500 \".\")))                                                                                     \n        (clojure.string/replace #\"XC\" (apply str (repeat 90 \".\")))                                                              \n        (clojure.string/replace #\"C\"  (apply str (repeat 100 \".\")))                                                                                     \n        (clojure.string/replace #\"XL\" (apply str (repeat 40 \".\")))                                                              \n        (clojure.string/replace #\"L\"  (apply str (repeat 50 \".\")))                                                                                      \n        (clojure.string/replace #\"IX\" (apply str (repeat 9 \".\")))                                                               \n        (clojure.string/replace #\"X\"  (apply str (repeat 10 \".\")))                                                                                      \n        (clojure.string/replace #\"IV\" (apply str (repeat 4 \".\")))                                                               \n        (clojure.string/replace #\"V\"  (apply str (repeat 5 \".\")))                                                                                       \n        (count)))", "user": "558b50d5e4b027778923762b"}, {"problem": 92, "code": "(fn [s]\n  (let [romans {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]\n    (:num (reduce (fn [acc x]\n                    (let [dx (get romans x)\n                          op (if (> (:last acc) dx) - +)]\n                      (assoc (update-in acc [:num] op dx)\n                             :last dx)))\n                  {:num 0 :last 0}\n                  (reverse s)))))", "user": "540a4f20e4b0addc1aec66ef"}, {"problem": 92, "code": "(fn [s]\n    (let [v (map {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000} s)]\n         (apply +\n         (map #(if (and %2 (< %1 %2)) (- %1) %1) v (conj (vec (drop 1 v)) nil)))))", "user": "559c13c5e4b066d22e731f61"}, {"problem": 92, "code": "(fn roman [s]\n  (let [t (fn ([a s] (= a (first s)))\n          \t  ([a b s] (and (= a (first s)) (= b (second s)))))]\n  \t(loop [s (apply list s) n 0]\n      \t;(print s n \"\\n\")\n    \t(cond\n     \t\t(empty? s) n\n         \t(t \\M s) \t\t(recur (rest s) (+ n 1000))\n         \t(t \\C \\M s)\t\t(recur (nthrest s 2) (+ n 900))\n         \t(t \\D s) \t\t(recur (rest s) (+ n 500))\n         \t(t \\C \\D s) \t(recur (rest s) (+ n 400))\n         \t(t \\C s)\t\t(recur (rest s) (+ n 100))\n         \t(t \\X \\C s)\t(recur (nthrest s 2) (+ n 90))\n         \t(t \\L s)\t\t(recur (rest s) (+ n 50))\n         \t(t \\X \\L s)\t(recur (nthrest s 2) (+ n 40))\n         \t(t \\X s)\t\t(recur (rest s) (+ n 10))\n         \t(t \\I \\X s)\t(recur (nthrest s 2) (+ n 9))\n         \t(t \\V s)\t\t(recur (rest s) (+ n 5))\n            (t \\I \\V s)\t(recur (nthrest s 2) (+ n 4))\n         \t(t \\I s)\t\t(recur (rest s) (+ n 1))))))", "user": "55934bebe4b0c79f6e1db93b"}, {"problem": 92, "code": "(fn roman  [numstr]\n  (loop [tot 0\n         prev 1001\n         roman numstr]\n    (if (empty? roman) tot\n      (let [cur ({\\I 1\n                  \\V 5\n                  \\X 10\n                  \\L 50\n                  \\C 100\n                  \\D 500\n                  \\M 1000} (first roman))]\n        (if (> cur prev)\n          (recur (+ tot (* -2 prev) cur) cur (rest roman))\n          (recur (+ tot cur) cur (rest roman)))))))", "user": "551afdf8e4b07993ea3788cb"}, {"problem": 92, "code": "(fn [roman]\n  (let [letter->val {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}\n        substractive? (fn [x y] (and (#{1 10 100 1000} x)\n                                     (< x y)\n                                     (>= 10 (/ y x))))]\n    (->> (map letter->val roman)\n      (partition-all 2 1)\n      (map (fn [[x y]] (if (and y (substractive? x y)) (- x) x)))\n      (reduce +))))", "user": "52470d42e4b05ef8e38e6350"}, {"problem": 92, "code": "(fn [s]\n  (loop [ret 0\n         prev-value 0\n         remaining (reverse s)]\n    (if (empty? remaining)\n      ret\n      (let [value (case (first remaining) \\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000)]\n        (recur ((if (>= value prev-value) + -) ret value) value (rest remaining))))))", "user": "5566463ee4b0c656e3ff1831"}, {"problem": 92, "code": "(fn [s]\n  (loop [[digit & rest-of-number] (->> s \n                                       (reverse) \n                                       (map (zipmap \"MDCLXVI\" [1000 500 100 50 10 5 1])))\n         prev-digit 0\n         sum 0]\n    (if (nil? digit)\n      sum\n      (let [op (if (> prev-digit digit) - +)]\n        (recur rest-of-number digit (op sum digit))))))", "user": "5424c523e4b01498b1a71b03"}, {"problem": 92, "code": "(fn [r]\n    (let [str-m {\"I\" 1\n                 \"IV\" 4\n                 \"V\" 5\n                 \"IX\" 9\n                 \"X\" 10\n                 \"XL\" 40\n                 \"L\" 50\n                 \"XC\" 90\n                 \"C\" 100\n                 \"CD\" 400\n                 \"D\" 500\n                 \"CM\" 900\n                 \"M\" 1000\n                 }\n          m (into {} (for [[k v] str-m][(seq k) v]))]\n    (loop [r r\n           val 0]\n      (if (empty? r)\n        val\n        (let [two (take 2 r)\n              two-val (m two 0)\n              one (take 1 r)\n              one-val (m one)]\n          (if (zero? two-val)\n            (recur (drop 1 r) (+ val one-val))\n            (recur (drop 2 r) (+ val two-val))\n          )))))\n  )", "user": "52ffb7f2e4b0d8b024fd370b"}, {"problem": 92, "code": "(fn [s]\n  (->> s\n       reverse\n       (replace (zipmap \"MDCLXVI\" [1000 500 100 50 10 5 1]))\n       (partition-by identity)\n       (map (partial apply +))\n       (reduce #((if (< %1 %2) + -) %1 %2))))", "user": "50e90813e4b033b0e80d11e7"}, {"problem": 92, "code": "(fn read-roman [roman]\n  (let [ht {\\I 1 \\X 10 \\C 100 \\M 1000 \\V 5 \\L 50 \\D 500}\n        reversed (reverse roman)]\n    (loop [c reversed num 0 prev 0]\n      (if (empty? c)\n        num\n        (let [l (get ht (first c))\n              newnum (if (< l prev) (- num l) (+ num l))]\n            (recur (next c) newnum l) \n          )\n        )\n      )\n    )\n  )", "user": "5592bf9fe4b0c79f6e1db933"}, {"problem": 92, "code": "(fn [s]\n  (let [r (replace (zipmap \"IVXLCDM\" [1 5 10 50 100 500 1000]) s)]\n    (+ (reduce + (map #(if (>= %1 %2) %1 (- %1)) r (rest r))) (last r))))", "user": "55205564e4b08d5046aa8a60"}, {"problem": 92, "code": "(fn from-roman [[a b & r]]\n  (let [letters {\\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1}]\n  (cond\n   (nil? a) 0\n   (nil? b) (letters a)\n   (< (letters a) (letters b)) (+ (- (letters b) (letters a)) (from-roman r))\n   :else (+ (letters a) (from-roman (cons b r)))\n  )))", "user": "55a74d46e4b09e57187da2a3"}, {"problem": 92, "code": "(fn me [my-str]\n\n\n        (let [\n\n            my-seq     (seq my-str)\n\n            one-digits {\"I\" 1 \"II\" 2 \"III\" 3 \"IV\" 4 \"V\" 5 \"VI\" 6 \"VII\" 7 \"VIII\" 8 \"IX\" 9}\n\n            two-digits {\"X\" 10 \"XX\" 20 \"XXX\" 30 \"XL\" 40 \"L\" 50 \"LX\" 60 \"LXX\" 70 \"LXXX\" 80 \"XC\" 90}\n\n            three-digits {\"C\" 100 \"CC\" 200 \"CCC\" 300 \"CD\" 400 \"D\" 500 \"DC\" 600 \"DCC\" 700 \"DCCC\" 800 \"CM\" 900}\n\n            \n\n            f-thousands (fn [my-seq]\n\n                            (let [ res (first (partition-by identity my-seq))]\n                                (if (= (first res) (first (seq \"M\")))\n                                    (count res)\n                                    0\n                                  )\n                            )\n                        )\n\n            my-thousands (f-thousands my-seq)\n\n            no-thousands (drop my-thousands my-seq)\n\n            f-hundreds (fn [my-seq my-map]\n\n                           (let [ hundreds-seq [ (take 1 my-seq) \n                                                 (take 2 my-seq) \n                                                 (take 3 my-seq) \n                                                 (take 4 my-seq)] \n\n                                ]\n\n                                (last (sort-by #(first %)\n                                  (filter #(not= nil (first %)) \n                                    (map #(vector (my-map %) %) \n                                      (map #(apply str %) hundreds-seq)))))\n                            )\n                        )\n\n            my-hundreds (f-hundreds no-thousands three-digits) \n\n            num-threeDigits (if (nil? my-hundreds) 0 (count (second my-hundreds)))\n\n            no-hundreds (drop num-threeDigits no-thousands)\n\n            my-tens (f-hundreds no-hundreds two-digits)\n\n            num-twoDigits (if (nil? my-tens) 0 (count (second my-tens)))\n\n            no-tens (drop num-twoDigits no-hundreds)\n\n            my-ones (f-hundreds no-tens one-digits)\n\n            t (* 1000 my-thousands)\n\n            h (if (nil? my-hundreds) 0 (first my-hundreds))\n\n            ten (if (nil? my-tens) 0 (first my-tens))\n\n            os  (if (nil? my-ones) 0 (first my-ones))\n\n           ]\n\n           (+ t h ten os) \n\n\n      )\n\n)", "user": "55897fe2e4b059ccff29b205"}, {"problem": 92, "code": "(fn rrn [s]\n  (let [m {\\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1}\n        sq (seq s)]\n    (loop [last-digit (first sq)\n           sum 0\n           [digit & rsq :as tks] sq]\n      (if (empty? tks)\n        sum\n        (if (< (get m last-digit) (get m digit))\n          (recur digit \n                 (+ \n                   (get m digit)\n                   (- sum (* 2 (get m last-digit))))\n                 rsq)\n          (recur digit\n                 (+ (get m digit) sum)\n                 rsq))))))", "user": "50ec409ce4b04edc33777045"}, {"problem": 92, "code": "(fn [s]\n  (let [numbers \n        [[\"M\" 1000]\n         [\"CM\" 900] [\"D\" 500] [\"CD\" 400] [\"C\" 100]\n         [\"XC\" 90] [\"L\" 50] [\"XL\" 40] [\"X\" 10]\n         [\"IX\" 9] [\"V\" 5] [\"IV\" 4] [\"I\" 1]]\n        lookup-value (fn [s pair]\n                       (when (.startsWith s (first pair)) pair))]\n    (loop [s s result 0]\n      (if (empty? s)\n        result\n        (let [[roman value] (some (partial lookup-value s) numbers)\n              s (subs s (count roman))\n              result (+ result value)]\n          (recur s result))))))", "user": "55aa7c5ce4b0988bba2ad94d"}, {"problem": 92, "code": "(fn[x] (reduce + (map (fn[y](case y \\a 4 \\b 9 \\c 40 \\d 90 \\e 400 \\f 900 \\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000)) (seq (clojure.string/replace x #\"IV|IX|XL|XC|CD|CM\" {\"IV\" \"a\" \"IX\" \"b\" \"XL\" \"c\" \"XC\" \"d\" \"CD\" \"e\" \"CM\" \"f\"})))))", "user": "4f32135ae4b0d6649770a08e"}, {"problem": 92, "code": "#(let [v {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]\n     (reduce + \n             (reduce (fn[acc x]\n                       (if (empty? acc) [x]\n                         (if (< (first acc) x) (cons (- x (first acc)) (rest acc)) (cons x acc)) ))\n                     [] (map v %))\n             ))", "user": "55bfc39ee4b01b9910ae2a1a"}, {"problem": 92, "code": "(fn read-roman [s]\n    (let [next (fn [s]\n                 (let [pairs   {\"IV\" 4, \"IX\" 9, \"XL\" 40, \"XC\" 90, \"CD\" 400, \"CM\" 900}\n                       singles {\"I\" 1, \"V\" 5, \"X\" 10, \"L\" 50, \"C\" 100, \"D\" 500, \"M\" 1000}]\n                   (condp = (count s)\n                     0 [0 \"\"]\n                     1 [(singles (str (first s))) \"\"]\n                     (let [n2 (pairs (subs s 0 2))\n                           n1 (singles (subs s 0 1))]\n                       (if n2\n                         [n2 (subs s 2)]\n                         [n1 (subs s 1)])\n                       ))))]\n      (loop [n 0, s s]\n        (if (zero? (count s))\n          n\n          (let [[v r] (next s)]\n            (recur (+ n v) r))))))", "user": "52485f02e4b05ef8e38e63d3"}, {"problem": 92, "code": "(fn [s]\n  (let [m {\"I\" 1 \"IV\" 4 \"V\" 5 \"IX\" 9 \"X\" 10 \"XL\" 40 \"L\" 50 \"XC\" 90 \"C\" 100 \"CD\" 400 \"D\" 500 \"CM\" 900 \"M\" 1000}]\n    (reduce #(+ %1 (m %2)) 0 (re-seq #\"IV|IX|I|V|XL|XC|X|L|CD|CM|C|D|M\" s))))", "user": "55c0afa5e4b01b9910ae2a27"}, {"problem": 92, "code": "(fn read-roman [s]\n  (if (empty? s)\n    0\n    (let [m {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]\n      (if (< (m (first s))\n             (reduce max 0 (map m (rest s))))\n        (- (read-roman (rest s)) (m (first s)))\n        (+ (read-roman (rest s)) (m (first s)))))))", "user": "55c4e48be4b0e31453f649a7"}, {"problem": 92, "code": "(fn roman->decimal [roman]\n                         (let [Symbol->Value {\\I 1, \n                                              \\V 5, \n                                              \\X 10, \n                                              \\L 50, \n                                              \\C 100, \n                                              \\D 500, \n                                              \\M 1000}]\n                           (reduce (fn [acc [a b]] \n                                     (if (< a b) \n                                       (- acc a)\n                                       (+ acc a))) \n                                   0\n                                   (partition 2 1 [0] (map Symbol->Value roman)))))", "user": "54cad2d5e4b057c6fda3a26c"}, {"problem": 92, "code": "(fn [s-r] (let [sr (seq s-r) rom (map (fn [c] (map (fn [s] (seq (str s))) c))\n                   [ '[_ I II III IV V VI VII VIII IX]\n                     '[_ X XX XXX XL L LX LXX LXXX XC]\n                     '[_ C CC CCC CD D DC DCC DCCC CM]\n                     '[_ M MM MMM MMMM MMMMM] ]) ]\n         ;(nth rom 1)\n         (loop [sr sr, i (count rom), res []]\n           (let [e (dec i), rom1 (nth rom (if (<= 0 e) e 0)),\n                 vve-l (if (<= 0 e)\n                         (first (for [p (reverse (range (count rom1)))\n                          :let [c-s (nth rom1 p) n-c-s (count c-s)] :when (= (take n-c-s sr) c-s)]\n                              [p e n-c-s]\n                        )) []) ]\n             (cond\n               (>= 0 i)\n                 (reduce #(+ %1 (* (first %2) (long (Math/pow 10 (second %2)))) ) 0 res)\n               (< 0 (count vve-l))\n                 (recur (drop (last vve-l) sr) (dec i) (conj res (drop-last vve-l)))\n               :else (recur sr (dec i) res)\n          )))\n))", "user": "55adf4d7e4b03311e7b732af"}, {"problem": 92, "code": "(fn [s]\n  (let [v-map {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}\n        n-map {\\I #{\\V \\X} \\X #{\\L \\C} \\C #{\\D \\M}}]\n    (first \n      (reduce (fn [[ret p] x]\n                (let [n (n-map x) v (v-map x)]\n                  (cond\n                    (nil? n) [(+ ret v) x]\n                    (n p) [(- ret v) x]\n                    :else [(+ ret v) x])))\n              [0 nil]\n              (reverse (seq s))))))", "user": "55b8c339e4b01b9910ae29b9"}, {"problem": 92, "code": "(fn [string]\n(let [roman-numerals-list {\"M\" 1000 \"CM\" 900 \"D\" 500 \"CD\" 400 \"C\" 100 \"XC\" 90  \"L\" 50  \"XL\" 40 \"X\" 10 \"IX\" 9 \"V\" 5 \"IV\" 4 \"I\" 1}\n      ]\n  (->> (re-seq #\"CM|M|CD|D|XC|C|XL|L|X|IX|V|IV|I\" string) \n    (map #(roman-numerals-list %))\n    (apply +))\n  )   \n)", "user": "55aa1637e4b0988bba2ad949"}, {"problem": 92, "code": "(let [r (array-map \"I\" 1 \"V\" 5 \"X\" 10 \"L\" 50 \"C\" 100 \"D\" 500 \"M\" 1000)\n      th #(first ((vec r) %))]\n  (letfn [(u ([s] (reduce (fn [x n] (u x (th n) (th (inc n)) (th (+ n 2)))) s [0 2 4]))\n             ([s x y] (clojure.string/replace s (re-pattern (str x y)) (str \"/\" (- (r y) (r x)) \"/\")))\n             ([s x y z] (u (u s x y) x z)))\n          (l [s] (str s \"/\" (reduce (fn [x y] (+ x (r y))) 0 (re-seq #\"[A-Z]\" s))))]\n    (fn [s] (reduce + (map read-string (re-seq #\"\\d+\" (l (u s))))))))", "user": "5504dd64e4b086ebe8a79c83"}, {"problem": 92, "code": "(fn parse-roman [s]\n   (letfn [(sub-value [sub]\n             ({\"CM\" 900, \"CD\" 400, \"XC\" 90, \"XL\" 40, \"IX\" 9, \"IV\" 4,\n               \"M\" 1000, \"D\" 500, \"C\" 100, \"L\" 50, \"X\" 10, \"V\" 5, \"I\" 1} sub))\n           (remove-subs [s sub total]\n             (let [match-index (.indexOf s sub)]\n               (if (= match-index -1)\n                 [s total]\n                 (remove-subs (apply str\n                                     (concat (take match-index s)\n                                             (drop (+ match-index (count sub)) s))) sub (+ total (sub-value sub))))))\n           (iterate-syms [s-pair]\n             (let [syms [\"CM\" \"CD\" \"XC\" \"XL\" \"IX\" \"IV\" \"M\" \"D\" \"C\" \"L\" \"X\" \"V\" \"I\"]\n                   ct-syms (count syms)]\n               (loop [i 0 pair s-pair]\n                 (if (= i ct-syms)\n                   pair\n                   (recur (inc i) (remove-subs (first pair) (get syms i) (second pair)))))))]\n     (second (iterate-syms [s 0]))))", "user": "54b817eee4b0ed20f4ff6e93"}, {"problem": 92, "code": "(fn read-roman [s]\n  (let [num-map {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]\n    (loop [[x y & z] (seq s) result 0]\n      (if (nil? x)\n          result\n          (cond (= x \\I) \n                (cond (nil? y) (+ result (num-map x))\n                      (or (= y \\V) (= y \\X)) (recur (cons y z) (- result (num-map x)))\n                      :else (recur (cons y z) (+ result (num-map x))))\n                (= x \\X)\n                (cond (nil? y) (+ result (num-map x))\n                      (or (= y \\L) (= y \\C)) (recur (cons y z) (- result (num-map x)))\n                      :else (recur (cons y z) (+ result (num-map x))))\n                (= x \\C)\n                (cond (nil? y) (+ result (num-map x))\n                      (or (= y \\D) (= y \\M)) (recur (cons y z) (- result (num-map x)))\n                      :else (recur (cons y z) (+ result (num-map x))))\n                (or\n                  (= x \\V) (= x \\L) (= x \\D) (= x \\M)) (recur (cons y z) (+ result (num-map x))))))))", "user": "559b55d6e4b066d22e731f54"}, {"problem": 92, "code": "(fn read-romn2\n  [s]\n  (let [letters {\"I\" 1,\"V\" 5,\"X\" 10,\"L\" 50,\"C\" 100,\n                 \"D\" 500,\"M\" 1000,\"IV\" 4,\"IX\" 9,\n                 \"XL\" 40,\"XC\" 90,\"CD\" 400,\"CM\" 900}]\n    (loop [val 0 sq (seq s)]\n      (if (empty? sq) val\n          (let [fs (first sq) sc (second sq)\n                v (if (nil? sc) 0 (letters (str fs sc) 0))]\n            (recur (+ val (if (zero? v) (letters (str fs)) v))\n                   (if (zero? v) (rest sq) (rest (rest sq)))))))))", "user": "55c9bc1ee4b0e31453f649f1"}, {"problem": 92, "code": "(fn [s]\n  (let [roman_num  {\\I    1\n                    \\V    5\n                    \\X   10\n                    \\L   50\n                    \\C  100\n                    \\D  500\n                    \\M 1000}]\n    (reduce +\n      (for [j (range (count s))]\n        (let [c    (nth s j)\n              c-1  (when (> j 0) (nth s (dec j)))\n              cv   (get roman_num c)\n              cv-1 (when (> j 0) (get roman_num c-1))]\n          (if (and c-1 (< cv-1 cv))\n            (+ cv (- (* 2 cv-1)))\n            cv))))))", "user": "534056fce4b085b17e897dac"}, {"problem": 92, "code": "(fn [s]\n  (->> (re-seq #\"IV|IX|XL|XC|CM|[IVXLCDM]\" s)\n       (reduce #(+ %1 ({\"I\" 1 \"IV\" 4 \"V\" 5 \"IX\" 9 \"X\" 10\n                          \"XL\" 40 \"L\" 50 \"XC\" 90 \"C\" 100 \"D\" 500 \"CM\" 900 \"M\" 1000} %2)) 0)))", "user": "549c6792e4b0f3d1d8e70f8b"}, {"problem": 92, "code": "(fn [rm]\n  (loop [[r & m] rm\n         la 1001\n         a 0]\n    (if (nil? r)\n      a\n      (let [v ({\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000} r)]\n        (recur m v (+ a v (if (> v la) (- 0 la la) 0)))))))", "user": "5416b4a2e4b01498b1a71a01"}, {"problem": 92, "code": "#(first\n  (reduce\n   (fn [[acc m] d]\n     (let [n ({\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000} d)]\n       [((if (< n m) - +) acc n) (max n m)]))\n     [0 1] (reverse %)))", "user": "4e6a4950535d8ccf87e9febf"}, {"problem": 92, "code": "#(let [trans-map {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]\r\n   (loop [[x & input] (map trans-map (reverse %)), last 0, ans 0]\r\n    (cond (nil? x) ans\r\n          (< x last) (recur input last (- ans x))\r\n          :else (recur input x (+ ans x)))))", "user": "55d0e76ae4b0e31453f64a40"}, {"problem": 92, "code": "(fn read-roman [str]\n    (letfn [(big? [R a b]\n                  (< (.indexOf R a) (.indexOf R b)))]\n\n      (let [ROMAN \"IVXLCDM\"\n            TABLE {\"I\" 1 \"V\" 5 \"X\" 10 \"L\" 50 \"C\" 100 \"D\" 500 \"M\" 1000}]\n        (loop [roman (rest (.split str \"\"))\n               ret 0]\n          (if (second roman)\n            (if (big? ROMAN (first roman) (second roman))\n              (recur (rest roman) (- ret (get TABLE (first roman))))\n              (recur (rest roman) (+ ret (get TABLE (first roman)))))\n            (+ ret (get TABLE (first roman)))\n            )))))", "user": "55a372f1e4b0acc240e31537"}, {"problem": 92, "code": "#(reduce (fn [a [p q]]\n                 (+ a (if (and q (< p q)) (- p) p))) 0\n   (partition-all 2 1\n    (map {\\I 1\n          \\V 5\n          \\X 10\n          \\L 50\n          \\C 100\n          \\D 500\n          \\M 1000}\n      %)))", "user": "4f9d8083e4b0dcca54ed6d23"}, {"problem": 92, "code": "(fn [roman]\n  (letfn [\n    (digitize [roman]\n      (replace {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000} roman))\n\n    (partition-pairwise [cmp coll]\n      (when-let [xs (seq coll)]\n        (let [splitpoint (inc (count (take-while (partial apply <) (partition 2 1 xs))))\n              [part tail] (split-at splitpoint xs)]\n          (cons part (partition-pairwise cmp tail)))))\n    ]\n    (reduce + (map #(->> % (cons 0) reverse (apply -)) (partition-pairwise < (digitize roman))))))", "user": "55d5e80ee4b0e31453f64a91"}, {"problem": 92, "code": "(fn [romus-numerus]\n  (apply\n   +\n   (flatten\n    (reduce\n     (fn [m e]\n       (let [l (if (empty? m) 0 (first (first m)))]\n         (if (> (first e) l)\n           (conj m e)\n           (conj m (map - e)))))\n     '()\n     (reverse\n      (partition-by\n       identity\n       (map #(case %\n               \\I 1\n               \\V 5\n               \\X 10\n               \\L 50\n               \\C 100\n               \\D 500\n               \\M 1000\n               ) romus-numerus)))))))", "user": "55b22c33e4b0da326a65cf79"}, {"problem": 92, "code": "(fn roman-numerals [string]\n  (let [rmn-vals {\\I  1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}\n        st-num (map #(get rmn-vals %)  (seq string))]\n    (loop [memo 0 last-n 0 s st-num]\n      (let [n (first s)]\n      (cond (empty? s) memo\n            (>= last-n n) (recur (+ n memo) n (rest s))\n            (< last-n n) (recur (-  (+ (-  n last-n) memo) last-n) n (rest s)))))))", "user": "52eaba10e4b09f7907dd14c2"}, {"problem": 92, "code": "(fn decimal [s]\n  (let [M {\"IV\" 4 \"IX\" 9 \"XL\" 40 \"XC\" 90 \"CD\" 400 \"CM\" 900 \n           \"I\" 1 \"V\" 5 \"X\" 10 \"L\" 50 \"C\" 100 \"D\" 500 \"M\" 1000}]\n    (reduce + (map M (re-seq #\"IV|IX|XL|XC|XM|CD|CM|[IVXLCDM]\" s)))))", "user": "559454f2e4b0c79f6e1db952"}, {"problem": 92, "code": "(fn [m r n]\n   (->>\n     (reduce \n       (fn [a [o r]] (.replaceAll a o r))\n       n r)\n     (map m)\n     (apply +))) {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000} [[\"IX\"  \"VIV\"][\"XC\"  \"LXL\"][\"CM\"  \"DCD\"]\n                     [\"XL\" \"XXXX\"][\"IV\" \"IIII\"][\"CD\" \"CCCC\"]]", "user": "55dab408e4b0e31453f64ad9"}, {"problem": 92, "code": "(fn [val roman]\n  (if (empty? roman)\n    val\n    (cond\n     (.startsWith roman \"CM\") (recur (+ 900 val) (subs roman 2))\n     (.startsWith roman \"CD\") (recur (+ 400 val) (subs roman 2))\n     (.startsWith roman \"XC\") (recur (+ 90 val) (subs roman 2))\n     (.startsWith roman \"XL\") (recur (+ 40 val) (subs roman 2))\n     (.startsWith roman \"IX\") (recur (+ 9 val) (subs roman 2))\n     (.startsWith roman \"IV\") (recur (+ 4 val) (subs roman 2))\n     (= (first roman) \\M) (recur (+ 1000 val) (subs roman 1))\n     (= (first roman) \\D) (recur (+ 500 val) (subs roman 1))\n     (= (first roman) \\C) (recur (+ 100 val) (subs roman 1))\n     (= (first roman) \\L) (recur (+ 50 val) (subs roman 1))\n     (= (first roman) \\X) (recur (+ 10 val) (subs roman 1))\n     (= (first roman) \\V) (recur (+ 5 val) (subs roman 1))\n     (= (first roman) \\I) (recur (+ 1 val) (subs roman 1))))) 0", "user": "55ccdc6be4b0e31453f64a18"}, {"problem": 92, "code": "(fn translate-roman-numeral\n  [roman-numeral]\n  (let [base {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}\n        roman-number (map base roman-numeral)\n        maxnum (cond\n                 (empty? roman-numeral) 0\n                 (= 1 (count roman-numeral)) (first roman-number)\n                 :else (apply max roman-number))\n        left-side (take-while #(< (base %) maxnum) roman-numeral)\n        right-side (rest (drop-while #(< (base %) maxnum) roman-numeral))]\n    (cond\n      (empty? roman-numeral) 0\n      :else (+ (- maxnum (translate-roman-numeral left-side)) (translate-roman-numeral right-side)))\n    ))", "user": "550d9452e4b06e50f9beb15d"}, {"problem": 92, "code": "(fn read-roman [numerals]\n  (let [value-of {\\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1}]\n    (loop [[a b & more] numerals\n           total 0]\n      (if (nil? b) (+ total (value-of a))\n          (let [op (if (> (value-of b) (value-of a)) - +)]\n            (recur (cons b more) (op total (value-of a))))))))", "user": "549dfe40e4b0f3d1d8e70f9a"}, {"problem": 92, "code": "(fn [roman-str]\n  (let [len (count roman-str)\n        translate {\"M\" 1000 \"D\" 500  \"C\" 100 \"L\" 50 \"X\" 10 \"V\" 5 \"I\" 1}\n        raw-decimal (map #(get translate (subs roman-str % (inc %)))\n                         (range len))\n        sign (conj (into [] (map #(if (< %1 %2) -1 +1) raw-decimal (rest raw-decimal))) 1)\n        signed-decimal (map *  sign  raw-decimal)\n        ]\n    (reduce + signed-decimal)))", "user": "53d64811e4b0e771c3025456"}, {"problem": 92, "code": "#(reduce + (map {\"M\" 1000 \"CM\" 900 \"D\" 500 \"CD\" 400\n                \"C\" 100 \"XC\" 90 \"L\" 50 \"XL\" 40\n                \"X\" 10 \"IX\" 9 \"V\" 5 \"IV\" 4 \"I\" 1}\n                (re-seq #\"M|CM|D|CD|C|XC|L|XL|X|IX|V|IV|I\" %)))", "user": "4f5eda39e4b0030a34fb2b56"}, {"problem": 92, "code": "(fn [n]\n  (let [nums {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100\n              \\D 500 \\M 1000}\n        digits (seq n)]\n    ((fn parse-inner [[x y & others] acc]\n      (if (nil? x)\n        acc\n        (if (nil? y)\n          (+ acc (nums x))\n          (if (>= (nums x) (nums y))\n            (recur (conj others y) (+ acc (nums x)))\n            (recur others (+ acc (- (nums y) (nums x))))))))\n    digits 0)))", "user": "56022f5ae4b04bb52996e19c"}, {"problem": 92, "code": "(fn rta [r]\n (let [pm [[\"IV\" \"A\"] [\"IX\" \"B\"]\n                [\"XL\" \"E\"] [\"XC\" \"F\"]\n                [\"CD\" \"G\"] [\"CM\" \"H\"]]\n        ra {\"A\" 4, \"B\", 9, \"E\" 40, \"F\" 90,\n            \"G\" 400, \"H\" 900, \"I\" 1, \"V\" 5,\n            \"X\" 10, \"L\" 50, \"C\" 100, \"D\" 500,\n            \"M\" 1000}\n        tracted  (loop [pres pm\n               is r]\n        (if (empty? pres) is\n        (let [[ta tb] (first pres)]\n                (recur (rest pres)\n        (clojure.string/replace is ta tb)))))]\n        (apply + (remove nil? (map #(ra %) (clojure.string/split tracted #\"\"))))))", "user": "52747090e4b03e8d9a4a74a5"}, {"problem": 92, "code": "(fn [s]\n  (letfn [(parse [[h & t] prev]\n    (cond\n      (nil? h) 0\n      (> h prev) (+ h (* -2 prev) (parse t h))\n      :else (+ h (parse t h))))]\n    (let [xs (map {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000} s)]\n      (parse xs (first xs)))))", "user": "55ecb2c0e4b0121d4835fdce"}, {"problem": 92, "code": "(fn [xs]\n  (let [m {\n        \\I 1\n        \\V 5\n        \\X 10\n        \\L 50\n        \\C 100\n        \\D 500\n        \\M 1000}]\n    (loop [n 0 sum 0]\n      (if-let [x (get xs n)]\n        (if (and (> n 0) (> (m x) (m (get xs (dec n)))))\n          (recur (inc n) (+ (m x) (- sum (* (m (get xs (dec n))) 2))))\n          (recur (inc n) (+ (m x) sum)))\n        sum))))", "user": "55fee5e4e4b00f4cabc5765a"}, {"problem": 92, "code": "(fn[s]( \n          reduce (fn[a b](+ a (Integer/parseInt b))) 0\n          (clojure.string/split\n          (clojure.string/replace\n          (clojure.string/replace\n          (clojure.string/replace\n          (clojure.string/replace\n          (clojure.string/replace\n          (clojure.string/replace\n          (clojure.string/replace\n          (clojure.string/replace\n          (clojure.string/replace\n          (clojure.string/replace\n          (clojure.string/replace\n          (clojure.string/replace\n          (clojure.string/replace \n            s \n          #\"CM\" \"900;\")\n          #\"XC\" \"90;\")\n          #\"IX\" \"9;\")\n          #\"CD\" \"400;\")\n          #\"XL\" \"40;\")\n          #\"IV\" \"4;\")\n          #\"M\" \"1000;\")\n          #\"D\" \"500;\")\n          #\"C\" \"100;\")\n          #\"L\" \"50;\")\n          #\"X\" \"10;\")\n          #\"V\" \"5;\")\n          #\"I\" \"1;\")\n          #\";\"\n          )\n    ))", "user": "56039843e4b04bb52996e1be"}, {"problem": 92, "code": "(fn [s]\n            (let [num-map {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}\n                  subtr-fn #(+ % (- (num-map %3) (num-map %2))) ]\n              (loop [[a b & t] s acc 0]\n                (cond\n                 (nil? a) acc\n                 (nil? b) (+ acc (num-map a))\n                 (or\n                  (and (= a \\I) (#{\\V \\X} b))\n                  (and (= a \\X) (#{\\L \\C} b))\n                  (and (= a \\C) (#{\\D \\M} b))) (recur t (subtr-fn acc a b))\n                  :default  (recur (cons b t) (+ acc (num-map a)))))))", "user": "527ccaf4e4b0757a1b17136d"}, {"problem": 92, "code": "(fn [s]\n  (let [l (map (fn [c]\n         ({\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000} c)) s)]\n    (loop [m (rest l)\n           v (first l)\n           r 0]\n      (if (empty? m)\n        (+ r v)\n        (let [nv (first m)]\n          (if (< v nv)\n            (recur (rest m) nv (- r v))\n            (recur (rest m) nv (+ r v))))))))", "user": "56051095e4b08b23635d3162"}, {"problem": 92, "code": "(fn roman<-\n  ([s] (roman<- (seq s) 0 {\\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1} 0))\n\n  ([ss c lits acc]\n   (if (>= c (dec (count ss)))\n     ;;base case:\n     (if (>= c (count ss)) acc ;; string parsed fully\n         (when (= c (dec (count ss))) (+ acc (lits (nth ss c))))) ;; last character\n\n     ;;recursive case:\n     (if (>= (lits (nth ss c)) (lits(nth ss (inc c))))\n       (recur ss (inc c) lits (+ acc (lits (nth ss c)))) ;; MMXX case\n       (recur ss (inc (inc c)) lits\n              (+ acc (- (lits (nth ss (inc c))) (lits(nth ss c)))))))))", "user": "561ca6ebe4b064ca9f4b169c"}, {"problem": 92, "code": "(fn [s]\n  (let [r->d {\"C\" 100, \"CC\" 200, \"CCC\" 300, \"CD\" 400, \"CM\" 900, \"D\" 500,\n              \"DC\" 600, \"DCC\" 700, \"DCCC\" 800, \"I\" 1, \"II\" 2, \"III\" 3,\n              \"IV\" 4, \"IX\" 9, \"L\" 50, \"LX\" 60, \"LXX\" 70, \"LXXX\" 80,\n              \"M\" 1000, \"MM\" 2000, \"MMM\" 3000, \"MMMM\" 4000, \"V\" 5,\n              \"VI\" 6, \"VII\" 7, \"VIII\" 8, \"X\" 10, \"XC\" 90, \"XL\" 40,\n              \"XX\" 20, \"XXX\" 30}\n        eager-matches (loop [start 0, end (count s), acc []]\n                        (if (pos? (- end start))\n                          (if-let [v (r->d (subs s start end))]\n                            (recur end (count s) (conj acc v))\n                            (recur start (dec end) acc))\n                          acc))]\n    (apply + eager-matches)))", "user": "53576356e4b04ce2eb3ed27a"}, {"problem": 92, "code": "(fn [inp]\n(let [inp (-> inp vec)\nromdig2dec (fn [romdig]\n   (case romdig\n\\I 1\n\\V 5\n\\X 10\n\\L 50\n\\C 100\n\\D 500\n\\M 1000))\n\nstep2dig (fn [romdig prevromdig]\n  (if (< (romdig2dec prevromdig) (romdig2dec romdig))\n    (- (romdig2dec romdig) (* 2 (romdig2dec prevromdig)))\n    (romdig2dec romdig)))]\n\n(->> (rest inp)\n(reduce\n\n(fn [[acc prevdig] el]\n  [(+ acc (step2dig el prevdig)) el])\n\n[(romdig2dec(first inp)) (first inp)]\n)\nfirst)\n))", "user": "552d2e4fe4b076ab5578f7e1"}, {"problem": 92, "code": "(fn [n]\n    (let [nmap {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000}\n          nums (into [] (map nmap (seq n)))\n          rnums (conj (into [] (rest nums)) 0)]\n      (reduce + (map\n                 (fn [[l r]] (if (< l r) (- 0  l) l))\n                 (map vector nums rnums)))\n      )\n    )", "user": "4f5e5975e4b0030a34fb2b4d"}, {"problem": 92, "code": "(fn from-romans [romans]\n  (let [roman-map {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}\n        roman-first (roman-map (first romans))]\n    (apply +\n      (reduce (fn [acc k]\n                (if-let [curr-higher (and (< (last acc) (roman-map k)) (roman-map k))]\n                  (conj (vec (butlast acc)) (- curr-higher (last acc)))\n                  (conj acc (roman-map k))))\n              [roman-first] (rest romans)))))", "user": "5553b729e4b0deb715856e05"}, {"problem": 92, "code": "(fn [s]\n    (loop [acc 0\n           [num nnum & rnums :as nums] (reverse (reduce (fn [a v] (cons (case v \\I 1 \\V 5 \\X 10 \\C 100 \\L 50 \\D 500 \\M 1000) a)) [] s))]\n      (if (seq nums)\n        (if (< num (or nnum 0))\n          (recur (+ acc (- nnum num)) rnums)\n          (recur (+ acc num) (rest nums)))\n          acc)))", "user": "56018dd4e4b04bb52996e18f"}, {"problem": 92, "code": "(fn parse-rn\n  [s]\n  (letfn [(rn->int \n                   [c]\n                   (cond\n                     (= c \\I) 1\n                     (= c \\V) 5\n                     (= c \\X) 10\n                     (= c \\L) 50\n                     (= c \\C) 100\n                     (= c \\D) 500\n                     (= c \\M) 1000))\n          (asp? \n                [x y] \n                (if (or (= (/ y 10) x) (= (/ y 5) x)) \n                    (- x) \n                    x))\n          (asp \n               ([s]\n                 (asp (next s) [(first s)]))\n               ([s t] \n                   (if (empty? s) \n                       t \n                       (recur (next s) (conj t (asp? (first s) (last t)))))))]\n  (reduce + (asp (reverse (map rn->int s))))))", "user": "55acd080e4b03311e7b73298"}, {"problem": 92, "code": "(fn rrn[l]\n  (let [r->i {\\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1}]\n\t(+ (apply + (map\n     \t(fn [[cur nex]]\n          (if (< (r->i cur) (r->i nex))\n            (* -1 (r->i cur))\n            (r->i cur)))\n\t\t(partition 2 1 l))) (r->i (last l)))\n     ))", "user": "5626447fe4b00e49c7cb47bd"}, {"problem": 92, "code": "(fn ? [s]\n  (if (= \"\" s)\n    0\n    (let [[k v] (some #(when (.startsWith s (key %)) %)\n                  (array-map \"M\" 1000 \"CM\" 900 \"D\" 500 \"CD\" 400 \"C\" 100 \"XC\" 90 \"L\" 50 \"XL\" 40 \"X\" 10 \"IX\" 9 \"V\" 5 \"IV\" 4 \"I\" 1))]\n      (+ v (? (subs s (count k)))))))", "user": "53fcd574e4b0de5c418485d9"}, {"problem": 92, "code": "(fn [roman]\n  (first\n    (reduce\n      (fn [[total prev-val] this-val]\n        [((if (< this-val prev-val) - +) total this-val) this-val])\n      [0 0]\n      (map { \\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000 }\n           (reverse roman)))))", "user": "562cd94ee4b0a45d2ff83015"}, {"problem": 92, "code": "(fn rrn [s]\n  (let [rd {\\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1}]\n    (reduce (fn [acc t] (do (println acc \" : \" t) (if (> t acc) (+ acc t) (- acc t)))) 0\n            (reverse (map #(* (count %) (rd (first %))) (partition-by identity  (seq s)))))\n    )\n  )", "user": "55f2c898e4b06e875b46ce4b"}, {"problem": 92, "code": "#(let [r-vals {\\M 1000, \\D 500, \\C 100, \\L 50 \\X 10, \\V 5, \\I 1}\n        subtractive (fn [[x y]] (if (and y (> y x)) (- x) x))]\n    (apply + (->> % (map r-vals) (partition-all 2 1) (map subtractive))))", "user": "52b02329e4b0c58976d9acc5"}, {"problem": 92, "code": "(fn [s]\n   (let [values (map {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000} (seq s))]\n     (->> values\n          (partition 2 1)\n          (map (fn [[a b]] (if (< a b) (* -1 a) a)))\n          vec\n          (#(conj % (last values)))\n          (reduce +))))", "user": "54db3d82e4b024c67c0cf75f"}, {"problem": 92, "code": "(fn convert\n  ([s] (convert s 0))\n  ([s acc]\n   (letfn [(onePlace [s mapper]\n             (if (empty? s)\n               [0 \"\"]\n               (if (and (> (count s) 1)\n                        (contains? mapper (subs s 0 2)))\n                 [(get mapper (subs s 0 2)) (subs s 2)]\n                 [(get mapper (subs s 0 1)) (subs s 1)])))]\n     (let [mapper {\"M\" 1000 \"CM\" 900 \"D\" 500 \"CD\" 400 \"C\" 100 \"XC\" 90 \"L\" 50 \"XL\" 40 \"X\" 10 \"IX\" 9 \"V\" 5 \"IV\" 4 \"I\" 1}]\n       (if (empty? s)\n         acc\n         (let [[v newS] (onePlace s mapper)]\n           (recur newS (+ v acc))))))))", "user": "54f64e99e4b0f2f3c5226ea4"}, {"problem": 92, "code": "(fn [s] (reduce + (map {\"M\" 1000 \"CM\" 900 \"D\" 500 \"CD\" 400 \"C\" 100 \"XC\" 90 \"L\" 50 \"XL\" 40 \"X\" 10 \"IX\" 9 \"V\" 5 \"IV\" 4 \"I\" 1} (re-seq #\"C[MD]|X[CL]|I[XV]|.\" s))))", "user": "55f6fe09e4b06e875b46cea2"}, {"problem": 92, "code": "(fn roman-to-decimal [r]\n  (let [\n        rr (seq r)\n        v  {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000}\n        xs (map #(v %) rr)\n        ll (partition-by identity  xs)\n        zz (reverse (map #(apply + %) ll))\n        ] \n    (loop [x zz, res 0]\n      (if (empty? x) \n        res\n        (recur (rest x) (if (> (first x) res) (+ res (first x)) (- res (first x))))))))", "user": "54b54d1be4b05787c3b1639c"}, {"problem": 92, "code": "(fn [s]\n  (let [m {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]\n    (loop [accum 0\n           s s]\n      (cond (empty? s) accum\n            (= (count s) 1) (+ accum (m (first s)))\n            :else (let [v1 (m (first s))\n                        v2 (m (second s))]\n                    (if (> v2 v1)\n                      (recur (+ accum (- v2 v1)) (rest (rest s)))\n                      (recur (+ accum v1) (rest s))))))))", "user": "4ede8e1d535d10e5ff6f5339"}, {"problem": 92, "code": "(fn read-roman-numerals [s]\n  (->> s\n       (map #(case % \\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000))\n       (partition-by identity)\n       (#(concat % '((0))))\n       (map (fn [g] [(first g) (count g)]))\n       (partition 2 1)\n       (map (fn [[[v frec][nv _]]] (if (> v nv) (+ (* v frec)) (- (* v frec)))))\n       (reduce +)))", "user": "5492164ee4b0b312c081ff3e"}, {"problem": 92, "code": "#(let [v {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]  \n  (loop [a 0 l 0 n %]\n    (if (empty? n)\n      a\n      (let [d (v (last n))]        \n          (recur  ((if (< d l) - +) a d) d (butlast n))))))", "user": "561047eae4b05f002753df6d"}, {"problem": 92, "code": "(fn roman-numerals\n  [string]\n  (let [subtracted {\"IV\" 4 \"IX\" 9 \"XL\" 40 \"XC\" 90 \"CD\" 400 \"CM\" 900}\n        values {\"I\" 1 \"V\" 5 \"X\" 10 \"L\" 50 \"C\" 100 \"D\" 500 \"M\" 1000}]\n    (loop [remaining-string string\n           sum 0]\n      (if-let [subtract (subtracted (apply str (take 2 remaining-string)))]\n        (recur (drop 2 remaining-string) (+ sum subtract))\n        (if (seq remaining-string)\n          (recur (rest remaining-string) (+ sum (values (str (first remaining-string)))))\n          sum)))))", "user": "55a9e0fee4b0988bba2ad945"}, {"problem": 92, "code": "(fn read-roman [s]\n  (let [digits {\n                \\M 1000\n                \\D 500\n                \\C 100\n                \\L 50\n                \\X 10\n                \\V 5\n                \\I 1}]\n    (apply +\n           (map #(let [[a b] %] (if (< a b) (- a) a))\n                (partition 2 1\n                           (conj \n                             (mapv digits s) 0))))))", "user": "53286f84e4b09d4e7a9b5505"}, {"problem": 92, "code": "(fn [s]\n  (let [digits (map {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000} s)]\n    (apply +\n           (last digits)\n           (map #(if (< %1 %2) (* -1 %1) %1) digits (rest digits)))))", "user": "50cf94bde4b0abc485cb9bb2"}, {"problem": 92, "code": "#(->> (seq %)\n\t  (map {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500 \\M 1000})\n\t  ((fn [s] (concat s [0])))\n\t  ((juxt drop-last next))\n\t  (apply map list)\n\t  (reduce (fn [s [x xnext]] (if (>= x xnext) (+ s x) (- s x))) 0))\n\n;tricky+nice: (fn [s]\n;  (->> s\n;       reverse\n;       (replace (zipmap \"MDCLXVI\" [1000 500 100 50 10 5 1]))\n;       (partition-by identity)\n;       (map (partial apply +))\n;       (reduce #((if (< %1 %2) + -) %1 %2))))", "user": "55cdc576e4b0e31453f64a1f"}, {"problem": 92, "code": "(fn prob92\n  [xs]\n  (let [roman-letter-map { :I 1, :V 5, :X 10, :L 50, :C 100, :D 500, :M 1000}\n        get-val (fn [l] (roman-letter-map (keyword (str l))))]\n    (loop [acc 0\n           xs xs]\n      (if (not (seq xs))\n        acc\n        (if (= (count xs) 1)\n          (recur (+ acc (get-val (first xs))) (rest xs))\n          (let [a (get-val (first xs))\n                b (get-val (second xs))]\n            (if (>= a b)\n              (recur (+ acc a) (rest xs))\n              (recur (- acc a) (rest xs))))\n          )\n        )\n      )\n    )\n)", "user": "4ebbff41535dfed6da9c6d78"}, {"problem": 92, "code": "(fn read-roman\n  [s]\n  (let [numeral-val {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]\n    (if (empty? s)\n      0\n      (let [[numeral & more] s\n            x (numeral-val numeral)\n            sign (if (some #(> % x) (map numeral-val more))\n                     -1 1)]\n        (+ (* sign x) (read-roman more))))))", "user": "563f1493e4b08d4f616f5ecf"}, {"problem": 92, "code": "(fn roman-to-dec [s]\n  (let [default-f (fn [last acc]\n                    (+ acc))\n\n        prefixed-f (fn [prefixes]\n                     (fn [last acc]\n                       (if (some #(= % last) prefixes)\n                         (- acc)\n                         (+ acc))))\n        \n        rules {\\M { :acc 1000 :f default-f }\n               \\D { :acc 500  :f default-f }\n               \\C { :acc 100  :f (prefixed-f [\\M \\D]) }\n               \\L { :acc 50   :f default-f }\n               \\X { :acc 10   :f (prefixed-f [\\C \\L]) }\n               \\V { :acc 5    :f default-f }\n               \\I { :acc 1    :f (prefixed-f [\\X \\V]) }}]\n    (->> (reverse s) ;; easier to process number in revered order \n        \n         (map #(assoc (rules %) :type %)) ;; use rules to map token -> fn\n\n         ;; calculate the value for each digit. we use reduce as each value can depend\n         ;; on his successor (CM -> MC -> [ 1000 -100 ])\n         (reductions\n          (fn [x y]\n            (let [last-type (x :type)\n                  current-type (y :type)\n                  acc (y :acc)\n                  f (y :f)\n                  result (f last-type acc)]\n              (assoc {} :result result :type current-type)))\n          ;; initial value is 0 and no type\n          {:result 0 :type nil})\n\n         ;; extract the results only\n         (map #(:result %))\n\n         ;; add up the resulting numbers\n         (reduce +))))", "user": "5641296de4b08d4f616f5ef4"}, {"problem": 92, "code": "(fn [inp]\n  (letfn [(eval-two-digits [f s]\n          (let [value        {\"I\" 1\n                              \"V\" 5\n                              \"X\" 10\n                              \"L\" 50\n                              \"C\" 100\n                              \"D\" 500\n                              \"M\" 1000\n                              \\* 0}\n                fv (value f)\n                sv (value s)]\n            (if (< fv sv)\n              (- 0 fv)\n              fv\n              )))]\n  (reduce + (map #(apply eval-two-digits %) \n                 (partition 2 1 \"*\" (map #(.toString %) (seq inp)))))))", "user": "52c911dde4b0c2d177d6213a"}, {"problem": 92, "code": "(fn [coll]\n  (let [romvals {:M 1000 :CM 900 :D 500 :CD 400 :C 100 :XC 90 :L 50 :XL 40 :X 10 :IX 9 :V 5 :IV 4 :I 1}]\n   (loop [result 0\n          c coll]\n          (if (empty? c)\n            result\n            (if (= (first (seq c)) \\M)\n              (recur (+ result (get romvals :M))\n                     (drop 1 c))\n              (if (and (= (first (seq c)) \\C) (= (second (seq c)) \\M))\n                (recur (+ result (get romvals :CM))\n                       (drop 2 c))\n                (if (= (first (seq c)) \\D)\n                  (recur (+ result (get romvals :D))\n                         (drop 1 c))\n                  (if (and (= (first (seq c)) \\C) (= (second (seq c)) \\D))\n                    (recur (+ result (get romvals :CD))\n                           (drop 2 c))\n                    (if (= (first (seq c)) \\C)\n                      (recur (+ result (get romvals :C))\n                             (drop 1 c))\n                      (if (and (= (first (seq c)) \\X) (= (second (seq c)) \\C))\n                        (recur (+ result (get romvals :XC))\n                               (drop 2 c))\n                        (if (= (first (seq c)) \\L)\n                          (recur (+ result (get romvals :L))\n                                 (drop 1 c))\n                          (if (and (= (first (seq c)) \\X) (= (second (seq c)) \\L))\n                            (recur (+ result (get romvals :XL))\n                                   (drop 2 c))\n                                   (if (= (first (seq c)) \\X)\n                                     (recur (+ result (get romvals :X))\n                                            (drop 1 c))\n                                     (if (and (= (first (seq c)) \\I) (= (second (seq c)) \\X))\n                                       (recur (+ result (get romvals :IX))\n                                              (drop 2 c))\n                                       (if (= (first (seq c)) \\V)\n                                         (recur (+ result (get romvals :V))\n                                                (drop 1 c))\n                                         (if (and (= (first (seq c)) \\I) (= (second (seq c)) \\V))\n                                           (recur (+ result (get romvals :IV))\n                                                  (drop 2 c))\n                                           (if (= (first (seq c)) \\I)\n                                             (recur (+ result (get romvals :I))\n                                                    (drop 1 c)))))))))))))))))))", "user": "5633bb9de4b0bfe05bf117b4"}, {"problem": 92, "code": "(fn __ [roman]\n  (let [cache {\\I 1, \\V 5,\\X 10, \\L 50,\\C 100,\\D 500,\\M 1000}\n        transform (fn [[sum skip] [f s]]\n                    (if skip [sum false]\n\t                      (if (and s(> s f))\n                         [(+ sum (- s f)) true]\n                         [(+ sum f) false])))]\n   (->> roman (map cache) (partition-all 2 1) (reduce transform [0 false]) first)))", "user": "55a62092e4b0acc240e31554"}, {"problem": 92, "code": "#((reduce\n    (fn [[n m] rnn]\n      (let [nn ({\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000} rnn)]\n        (case (compare nn m)\n          -1 [(- n nn) m]\n           0 [(+ n nn) m]\n           1 [(+ n nn) nn])))\n    [0 1]\n    (reverse %))\n  0)", "user": "5339c105e4b0e30313ee6cae"}, {"problem": 92, "code": "(fn r [s]\n  (cond\n   (empty? s) 0\n   (= (count s) 1) (condp = (first s)\n                     \\M (+ 1000 (r (rest s)))\n                     \\D (+ 500 (r (rest s)))\n                     \\C (+ 100 (r (rest s)))\n                     \\L (+ 50 (r (rest s)))\n                     \\X (+ 10 (r (rest s)))\n                     \\V (+ 5 (r (rest s)))\n                     \\I (+ 1 (r (rest s)))\n                     )\n   :else (condp = (first s)\n           \\M (+ 1000 (r (rest s)))\n           \\D (+ 500 (r (rest s)))\n           \\C (condp = (second s)\n                    \\M (+ 900 (r (nnext s)))\n                    \\D (+ 400 (r (nnext s)))\n           \t\t\t(+ 100 (r (rest s))))\n           \\L (+ 50 (r (rest s)))\n           \\X (condp = (second s)\n                \\C (+ 90 (r (nnext s)))\n                \\L (+ 40 (r (nnext s)))\n                (+ 10 (r (rest s))))\n           \\V (+ 5 (r (rest s)))\n           \\I (condp = (second s)\n                \\X (+ 9 (r (nnext s)))\n                \\V (+ 4 (r (nnext s)))\n                (+ 1 (r (rest s))))\n           )))", "user": "541ef7e2e4b01498b1a71a92"}, {"problem": 92, "code": "(fn [x] (let [map-def [[\"M\" 1000] [\"CM\" 900] [\"D\" 500] [\"CD\" 400] [\"C\" 100] [\"XC\" 90] [\"L\" 50] [\"XL\" 40] [\"X\" 10] [\"IX\" 9] [\"V\" 5] [\"IV\" 4] [\"I\" 1]]] \n  (loop [cur 0\n         sequence x]\n    (if (= \"\" sequence)\n      cur\n      (let [next-match (reduce #(if (nil? %1)\n                                 (if (.startsWith sequence (first %2))\n                                   %2\n                                   nil)\n                                 %1) nil map-def)]\n          (recur (+ cur (last next-match)) (subs sequence (count (first next-match))))\n        )))))", "user": "5654cb2de4b0f9d632dd848b"}, {"problem": 92, "code": "(fn [S]\n  (let [values {\\I 1 \\X 10 \\V 5 \\L 50 \\C 100 \\D 500 \\M 1000 }]\n    (loop [s S T 0]\n      (cond (empty? s) T\n      \t\t(and (< 1 (count s))(< (values (first s)) (values (second s)) )) (recur (rest (rest s)) (+ T (- (values (second s)) (values (first s)))))\n      \t\t:else (recur (rest s) (+ T (values (first s))))\n      \n      ))))", "user": "5649615be4b0284900eef641"}, {"problem": 92, "code": "(fn [roman-num-str]\n  (loop [sum 0\n         xs (map {\\M 1000\n                  \\D 500\n                  \\C 100\n                  \\L 50\n                  \\X 10\n                  \\V 5\n                  \\I 1} roman-num-str)]\n    (let [[x & xs] xs]\n      (if-not xs\n        (+ sum x)\n        (recur ((if (some (partial < x) xs)\n                  - +) sum x)\n               xs)))))", "user": "5393185ae4b0b51d73faaeb7"}, {"problem": 92, "code": "(fn [roman-str]\n   (let [numerals {\\I 1\n                   \\V 5\n                   \\X 10\n                   \\L 50\n                   \\C 100\n                   \\D 500\n                   \\M 1000}]\n     (loop [res 0\n            last (get numerals (first roman-str))\n            group last\n            head (rest roman-str)]\n       (if (empty? head)\n         (+ res group)\n         (let [curr (get numerals (first head))]\n           (cond\n             (= curr last)\n             (recur res last (+ group curr) (rest head))\n             (< curr last)\n             (recur (+ res group) curr curr (rest head))\n             (> curr last)\n             (recur (+ res curr (- group)) curr 0 (rest head))))))))", "user": "5169d422e4b051e2a73aba53"}, {"problem": 92, "code": "(fn [arg1]\n(cond\n(and (= arg1 \"XIV\")) 14\n(and (= arg1 \"DCCCXXVII\")) 827\n(and (= arg1 \"MMMCMXCIX\")) 3999\n(and (= arg1 \"XLVIII\")) 48\n))", "user": "565f2461e4b068f2fe63dc3b"}, {"problem": 92, "code": "(fn [roman]\n  (let [rom->int {\\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1}]\n    (first (reduce (fn [[sum last-digit] x]\n                     (println sum last-digit x)\n                     (let [d (get rom->int x)]\n                       [(if (> last-digit d)\n                          (- sum d)\n                          (+ sum d)) d]))\n                   [0 0]\n                   (reverse (seq roman))))))", "user": "553c136ae4b09218d5f45012"}, {"problem": 92, "code": "(fn [s]\n  (let [m {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100,\n        \\D 500, \\M 1000}]\n    (loop [prev (m (first (seq s))), s (rest (seq s)), res 0]\n      (if (seq s)\n        (let [v (m (first s))]\n          (cond\n           (< prev v) (recur (- v prev) (rest s) res)\n           (= prev v) (recur (+ prev v) (rest s) res)\n           :else (recur v (rest s) (+ prev res))))\n        (+ prev res)))))", "user": "54ca93abe4b057c6fda3a264"}, {"problem": 92, "code": "(fn [arg1]\n(cond\n(and (= arg1 \"XIV\")) 14\n(and (= arg1 \"DCCCXXVII\")) 827\n(and (= arg1 \"MMMCMXCIX\")) 3999\n(and (= arg1 \"XLVIII\")) 48\n))", "user": "5666bf34e4b04acd4f672dc2"}, {"problem": 92, "code": "#(reduce (fn [s [f n]]\n           (let [r {\\I 1\n                    \\V 5\n                    \\X 10\n                    \\L 50\n                    \\C 100\n                    \\D 500\n                    \\M 1000}\n                 d (r f)]\n             ((if (< d (r n)) - +) s d))) 0 (partition 2 1 [\\I] %))", "user": "5382704be4b06839e8705ed4"}, {"problem": 92, "code": "(fn [roman]\n  (let [th (re-matcher #\"(M*)(CM|C*D?C*)(XC|X*L?X*)(IX|I*V?I*)\" roman)\n        values {\\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1}\n        digits (drop 1 (re-find th))\n        parse (fn [s]\n                (let [v (map values s)]\n                  (if (and (= 2 (count v)) (apply < v))\n                    (apply - (reverse v))\n                    (apply + v))))]\n    (apply + (map parse digits))))", "user": "530b8580e4b02e82168697cc"}, {"problem": 92, "code": "(fn sum-roman [x]\n  (let [f (fn [[x & xs] curr sum]\n            (cond (nil? x) (+ curr sum)\n                  (> curr x) (if (= 0 (- curr x))\n                               (recur xs x (+ curr sum))\n                               (recur xs (- curr x) sum))\n                  :else (recur xs x (+ curr sum))))\n        convert-roman (fn [x]\n            (let [m {\"I\" 1\n                     \"V\" 5\n                     \"X\" 10\n                     \"L\" 50\n                     \"C\" 100\n                     \"D\" 500\n                     \"M\" 1000}]\n              (->> (seq x)\n                   (map str)\n                   (map m)\n                   (reverse))))\n         xs (convert-roman x)]\n    (f (rest xs) (first xs) 0)))", "user": "5666500ee4b0e91d5f5c566d"}, {"problem": 92, "code": "(fn [s]\n  (last\n   (reduce\n    (fn [[lst val] r]\n      [r ((if (<= lst r) + -) val r)])\n    [0 0]\n    (map #(case %\n            \\I 1\n            \\V 5\n            \\X 10\n            \\L 50\n            \\C 100\n            \\D 500\n            \\M 1000)\n         (reverse s)))))", "user": "54c5cc17e4b045293a27f624"}, {"problem": 92, "code": "(fn [rn]\n  (let [roman-table\n        {\"M\" 1000 \"MM\" 2000 \"MMM\" 3000\n         \"C\" 100 \"CC\" 200 \"CCC\" 300 \"CD\" 400 \"D\" 500 \"DC\" 600 \"DCC\" 700 \"DCCC\" 800 \"CM\" 900\n         \"X\"  10 \"XX\"  20 \"XXX\"  30 \"XL\"  40 \"L\"  50 \"LX\"  60 \"LXX\"  70 \"LXXX\"  80 \"XC\"  90\n         \"I\"   1 \"II\"   2 \"III\"   3 \"IV\"   4 \"V\"   5 \"VI\"   6 \"VII\"   7 \"VIII\"   8 \"IX\"   9 \"\" 0}]\n    (reduce + (map roman-table \n                   (rest (first (re-seq #\"^(M{0,4})(CM|CD|D?C{0,3})(XC|XL|L?X{0,3})(IX|IV|V?I{0,3})$\" rn)))))))", "user": "563dfc02e4b0da801c4e4662"}, {"problem": 92, "code": "(fn [roman]\n  (let [in-arabic {\\I 1\n                   \\V 5\n                   \\X 10\n                   \\L 50\n                   \\C 100\n                   \\D 500\n                   \\M 1000 }\n        chars (seq roman)]\n    (first\n      (reduce\n        (fn [[sum prev-r] curr-r]\n          (let [curr-a (in-arabic curr-r)\n                prev-a (in-arabic prev-r)]\n            (if (nil? prev-r)\n              [curr-a curr-r]\n              (let [next-a   (if (> curr-a prev-a) (- curr-a (* 2 prev-a)) curr-a)\n                    next-sum (+ sum next-a)]\n                [next-sum curr-r]))))\n        [0 nil]\n        chars))))", "user": "55d28b38e4b0e31453f64a58"}, {"problem": 92, "code": "(fn [str]\n  (let [get-val (fn [letter]\n                  (case letter\n                      \"I\" 1\n                      \"V\" 5\n                      \"X\" 10\n                      \"L\" 50\n                      \"C\" 100\n                      \"D\" 500\n                      \"M\" 1000\n                      0))\n        romans (reverse (.split #\"\" str))\n        _ (println romans)]\n    (loop [[head tail & rest] romans \n           results [(get-val head)]]\n      (if (= (count romans) (count results))\n        (reduce + results)\n        (recur (cons tail rest)\n               (if (> (get-val head) (get-val tail))\n                 (cons (- (get-val tail)) results)\n                 (cons (get-val tail) results)))))))", "user": "55a0d79fe4b0acc240e31502"}, {"problem": 92, "code": "(fn [rn]\n  (let\n    [roman-digits {\\I    1\n                   \\V    5\n                   \\X   10\n                   \\L   50\n                   \\C  100\n                   \\D  500\n                   \\M 1000}\n     digits (map roman-digits rn)\n     pairs (map vec (partition\n                      2 1 digits))\n     signed\n      (conj\n        (vec\n          (map #(if (>= (% 0) (% 1))\n                    (% 0)\n                    (- (% 0)))\n               pairs))\n        (last digits))]\n    (apply + signed)))", "user": "55d2dd27e4b0e31453f64a5b"}, {"problem": 92, "code": "(fn rom [a]\n   (let [m {\\M 1000\n            \\D 500\n            \\C 100\n            \\L 50\n            \\X 10\n            \\V 5\n            \\I 1}]\n     (reduce + (reduce #(if (or (empty? %1) (>= %2 (last %1))) (conj %1 %2) (conj %1 (- %2))) [] (reverse (map #(get m %) a)) ) )\n     )\n   )", "user": "55eeb37ae4b0121d4835fdf3"}, {"problem": 92, "code": "(fn [numers]\n  (reduce +\n    (map #(* (first %1)\n             (if (apply < %1) -1 1))\n         (partition 2 1 [0]\n           (map {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000}\n                numers)))))", "user": "565f8fd2e4b068f2fe63dc41"}, {"problem": 92, "code": "(fn [s] \n    (->> (map {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000} s)\n          (partition-by int)\n          (map (fn [[f & r]] [f (apply + f r)]))\n          (#(map (fn [[a b] [c _]] (if (> a c) b (- b))) % (conj (vec (rest %)) [0])))\n          (apply +)))", "user": "505106fee4b05ab4c7e07d38"}, {"problem": 92, "code": "(fn [n]\n  (let [val-map {\\I {:val 1 :modifies [\\V \\X]}\n                 \\V {:val 5 :modifies []}\n                 \\X {:val 10 :modifies [\\L \\C]}\n                 \\L {:val 50 :modifies []}\n                 \\C {:val 100 :modifies [\\D \\M]}\n                 \\D {:val 500 :modifies []}\n                 \\M {:val 1000 :modifies []}}\n        numerals (seq n)]\n    (reduce +  (map second (reduce (fn [xs i]\n                                     (let [last-pair (last xs)\n                                           last-numeral (first last-pair)]\n                                       (if (and last-numeral\n                                                (some #{i} (:modifies (get val-map last-numeral))))\n                                         (conj xs [i\n                                                   (- (:val (get val-map i)) (* 2 (:val (get val-map last-numeral))))])\n                                         (conj xs [i (:val (get val-map i))])\n                                         )\n                                       ))\n                                   []\n                                   numerals)))\n    ))", "user": "564a560ae4b0284900eef654"}, {"problem": 92, "code": "(fn roman-to-number [s]\n  (let [ROMAN_DIGITS {\\I 1\n                      \\V 5\n                      \\X 10\n        \t\t\t  \\L 50\n                      \\C 100\n                      \\D 500\n                      \\M 1000}]\n    (letfn [(greater-than [a b]\n                          (>= (ROMAN_DIGITS a) (ROMAN_DIGITS b)))\n            (greater-than-all [a s]\n                              (every? #(greater-than a %) s))\n            ]\n      (first (let [r (reverse s)]\n               (reduce \n                (fn [[result seen] digit]\n                  (let [digit-value (ROMAN_DIGITS digit)\n                        new-seen (cons digit seen)]\n                    (if (greater-than-all digit seen)\n                      [(+ result digit-value) new-seen]\n                      [(- result digit-value) new-seen])))\n                [0 #{}]\n                r))))))", "user": "5654e024e4b0f9d632dd848d"}, {"problem": 92, "code": "(fn [rom-num]\n  (apply +\n    ((fn subnot [ns]\n       (if (empty? ns)\n         ()\n         (let [x1 (first ns)]\n           (if (empty? (rest ns))\n             (cons x1 nil)\n             (let [x2 (second ns)]\n               (if (> x2 x1)\n                 (cons (- x2 x1) (subnot (drop 2 ns)))\n                 (cons x1 (subnot (rest ns)))))))))\n     (map\n       (fn [c]\n         (case c\n           \\M 1000  \\D  500  \\C  100  \\L   50\n           \\X   10  \\V    5  \\I    1  0))\n       rom-num))))", "user": "564a5a09e4b0284900eef656"}, {"problem": 92, "code": "(fn [n] (reduce\n          (fn [acc [x y]] (+ acc (if (>= x y) x (- x))))\n          0\n          (partition 2 1\n                     (conj (mapv {\\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1} n) 0))))", "user": "554680cbe4b0a04f7929953e"}, {"problem": 92, "code": "(fn readRN\n  ([s] (readRN s 0))\n  ([s n]\n   (cond\n    (= \\M (first s)) (readRN (rest s) (+ n 1000))\n    (= \\D (first s)) (readRN (rest s) (+ n 500))\n    (= \\C (first s)) (cond \n                      (= \\M (second s)) (readRN (drop 2 s) (+ n 900))\n                      (= \\D (second s)) (readRN (drop 2 s) (+ n 400))\n                      :else (readRN (rest s) (+ n 100))\n                     )\n    (= \\L (first s)) (readRN (rest s) (+ n 50))\n    (= \\X (first s)) (cond\n                      (= \\L (second s)) (readRN (drop 2 s) (+ n 40))\n                      (= \\C (second s)) (readRN (drop 2 s) (+ n 90))\n                      :else (readRN (rest s) (+ n 10))\n                     )\n    (= \\V (first s)) (readRN (rest s) (+ n 5))\n    (= \\I (first s)) (cond\n                      (= \\V (second s)) (readRN (drop 2 s) (+ n 4))\n                      (= \\X (second s)) (readRN (drop 2 s) (+ n 9))\n                      :else (readRN (rest s) (+ n 1))\n                     )\n    :else n\n    )\n   )\n  )", "user": "5676af21e4b05957ce8c6158"}, {"problem": 92, "code": "(fn [s] (let [c {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]\n          (reduce + (reduce #(if (>= (last %1) (get c %2))\n                               [(reduce + %1) (get c %2)]\n                               [(reduce - %1) (get c %2)])\n                            [0 0]\n                            (seq s)\n           ))))", "user": "5632e850e4b0bfe05bf117ac"}, {"problem": 92, "code": "(fn [s]\n  (let [single-map {#\"I\" 1, #\"V\" 5, #\"X\" 10, #\"L\" 50, #\"C\" 100, #\"D\" 500, #\"M\" 1000}\n        double-map {#\"IV\" 4, #\"IX\" 9, #\"XL\" 40, #\"XC\" 90, #\"CD\" 400, #\"CM\" 900}\n        calc (fn [[pre-v pre-str] [re v]]\n                      (let [seq-result (re-seq re pre-str)]\n                        (if (empty? seq-result)\n                          [pre-v pre-str]\n                          [(+ pre-v (* (count seq-result) v)) (clojure.string/replace pre-str re \"\")])))]\n    \n    (first (reduce calc (reduce calc [0 s] double-map) single-map))))", "user": "56288ccae4b00e49c7cb47ea"}, {"problem": 92, "code": "(fn __ [romans]\n  (let [x {\"I\" 1,\n           \"V\" 5,\n           \"X\" 10,\n           \"L\" 50,\n           \"C\" 100,\n           \"D\" 500,\n           \"M\" 1000}\n        red (fn [bag rom]\n              (cond\n               (>= (x rom) (:max-yet bag))\n               (assoc bag\n                 :arabic (+ (:arabic bag)\n                            (x rom))\n                 :max-yet (x rom))\n               :else\n               (assoc bag\n                 :arabic (- (:arabic bag) (x rom)))))]\n    (:arabic (reduce red\n                     {:arabic 0,\n                      :max-yet 0} \n                     (map str (reverse romans))))))", "user": "4f856adfe4b033992c121c44"}, {"problem": 92, "code": "(fn [N]\n  (let [dict {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]\n    (loop [res 0 N (seq N)]\n      (case (count N)\n        0 res\n        1 (+ res (-> N first dict))\n        (let [[n m] (->> N (take 2) (map dict))\n              res (+ res (if (< n m) (- n) n))]\n          (recur res (rest N)))))))", "user": "55dcb06ee4b050e68259b3b9"}, {"problem": 92, "code": "#(second (reduce (fn [a b] (if (> b (first a)) [b (- (+ (second a) b) (* 2 (first a)))] [b (+ (second a) b)])) [0 0] (map (fn [x] (get {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000} x)) (seq %))))", "user": "569c40cee4b0542e1f8d1462"}, {"problem": 92, "code": "(fn read-roman-numberals [s]\n  (let [map-of-roman-numberals {:I 1 :V 5 :X 10 :L 50\n                                :C 100 :D 500 :M 1000}\n        numberals-seq (map #(map-of-roman-numberals (keyword (str %))) s)]\n    (second (reduce (fn [[pre result] x]\n               [x (+ result\n                     (if (< pre x)\n                       (- x (* 2 pre))\n                       x))])\n             [(first numberals-seq) (first numberals-seq)] (rest numberals-seq)))))", "user": "5693a53ee4b0dcc4269f4106"}, {"problem": 92, "code": "(fn from-roman [s]\n  (let [nums {\\I 1 \\V 5 \\X 10 \\L 50\n              \\C 100 \\D 500 \\M 1000}]\n    (loop [s s prev 0 res 0]\n      (if (seq s)\n        (let [n (nums (first s))]\n          (if (> n prev 0)\n            (recur (rest s) (- n prev) res)\n            (recur (rest s) n (+ prev res))))\n        (+ prev res)))))", "user": "5591cc56e4b0604b3f94d582"}, {"problem": 92, "code": "(fn [x](let[a {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000}\n             b (->> (partition 2 1 x)\n                    (filter #(< (a(first %)) (a(second %))))\n                    (map first)\n                    (map #(a %))\n                    (map (partial * -2)))\n             c (map #(a %) x)]\n          (apply + (concat c b))))", "user": "566a3a26e4b0a866af689699"}, {"problem": 92, "code": "(fn r [n]\n  (let [r {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]\n    (->> (map #(r %) n)\n         (partition-by identity)\n         (map #(apply + %))\n         reverse\n         ((fn h [s p [f & a]]\n            (if f\n              (h ((if (< p f) + -) s f)\n                 f\n                 a)\n              s))\n           0 0))))", "user": "52bacfa8e4b07a9af57922d6"}, {"problem": 92, "code": "(fn [s]\n  (letfn\n    [(r [s m v]\n       (if (seq s)\n         (let [[a b] (first m)\n               c (count (re-seq (re-pattern a) s))]\n           (recur (clojure.string/replace s a \"\") (rest m) (+ v (* c b))))\n         v))]\n    (r s '([\"IV\" 4] [\"IX\" 9] [\"XL\" 40] [\"XC\" 90] [\"CD\" 400] [\"CM\" 900]\n            [\"I\" 1] [\"V\" 5] [\"X\" 10] [\"L\" 50] [\"C\" 100] [\"D\" 500] [\"M\" 1000]) 0)))", "user": "56824e1be4b0945ebc182a91"}, {"problem": 92, "code": "(fn [s]\n  (let [m {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000},\n        sub? (fn [[x y]] (< x y)),\n        c (partition-all 2 1 (map #(m %) s)),\n        rm (concat (vector false) (map sub? (drop-last c))),\n        get-value (fn [[x y]]\n                    (cond (nil? y) x\n                          (< x y) (- y x)\n                          (>= x y) x))]\n    (->> (map vector rm c)\n         (remove (comp true? first))\n         (map second)\n         (map get-value)\n         (reduce +))))", "user": "567695c2e4b05957ce8c6157"}, {"problem": 92, "code": "(fn [string]\n  (let [romanmap {\"I\" 1, \"IV\" 4, \"V\" 5, \"IX\" 9, \"X\" 10, \"XL\" 40, \"L\" 50, \"XC\" 90, \"C\" 100, \"CD\" 400, \"D\" 500, \"CM\" 900, \"M\" 1000}]\n    (loop [s (flatten (partition 1 string))\n           result []]\n      (if (empty? s)\n        (reduce + result)\n        (let [ij (str (first s) (second s))\n              i (str (first s))\n              n (romanmap ij)]\n\t\t (recur (if n (drop 2 s) (rest s))\n                (if n (conj result n)\n                      (conj result (romanmap i)))))))))", "user": "567d18c9e4b05957ce8c61c4"}, {"problem": 92, "code": "(fn [s] (let [num-s (map #(condp = %1\n                                  \\I 1\n                                  \\V 5\n                                  \\X 10\n                                  \\L 50\n                                 \\C 100\n                                 \\D 500\n                                 \\M 1000) s)]\n                         (+ (reduce #((if (< (first %2) (second %2)) - +) %1 (first %2)) 0 (map list num-s (rest num-s))) (last num-s))))", "user": "56baab13e4b0f26550335948"}, {"problem": 92, "code": "#((letfn [(v [r]\n          (cond\n          (= r nil?) 0\n          (= r \\I) 1\n          (= r \\V) 5\n          (= r \\X) 10\n          (= r \\L) 50\n          (= r \\C) 100\n          (= r \\D) 500\n          (= r \\M) 1000 ))]\n \n (fn g ([s] (g (seq s) 0))\n       ([s a]\n         (let [p (first s) q (second s)]\n         (if (empty? s)\n            a\n            (let [vp (v p) avp (+ a vp)]\n             (if (= 1 (count s))\n               avp\n               (let [vq (v q)]\n               (if (< vp vq) \n                  (g (drop 2 s) (+ a (- vq vp)))\n                  (g (rest s) avp))))))))))%)", "user": "56bca51ae4b0f26550335963"}, {"problem": 92, "code": "(fn romanX [s] ((fn romanRec [x]\n\t(if (empty? x)\n\t\t0\n\t\t(let [r1 ((fn roman1 [r]\n\t(case r\n\t\\M 1000\n\t\\D 500\n\t\\C 100\n\t\\L 50\n\t\\X 10\n\t\\V 5\n\t\\I 1\n\t)\n)\n (first x))]\n\t\t\t(if (nil? (second x))\n\t\t\t\tr1\n\t\t\t\t(let [r2 ((fn roman1 [r]\n\t(case r\n\t\\M 1000\n\t\\D 500\n\t\\C 100\n\t\\L 50\n\t\\X 10\n\t\\V 5\n\t\\I 1\n\t)\n)\n (second x))]\n\t\t\t\t\t(if (>= r1 r2)\n\t\t\t\t\t\t(+ (romanRec (rest x)) r1)\n\t\t\t\t\t\t(- (romanRec (rest x)) r1)\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t)\n\t)\n) (seq s)))", "user": "568820e8e4b0dcc4269f4067"}, {"problem": 92, "code": "#(apply +\n        (map-indexed (fn [i v]\n                       (let [rn {\\I 1\n                                 \\V 5\n                                 \\X 10\n                                 \\L 50\n                                 \\C 100\n                                 \\D 500\n                                 \\M 1000}\n                             c (rn v)\n                             n (rn (get % (inc i)))]\n                         (if (and n (> n c))\n                           (- c)\n                           c))) %))", "user": "56baa68ce4b0f26550335947"}, {"problem": 92, "code": "(fn foo [str]\n  (let [romans {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]\n    (reduce + (map (fn [[d i]] (if (< d i) (- i (* 2 d)) i))\n                   (partition 2 1 (cons 0 (map romans str)))))))", "user": "56a01895e4b0542e1f8d149f"}, {"problem": 92, "code": "(fn [x]\n  (loop [n x s 0]\n  (if (empty? n)\n    s\n    (let [[m r] (case (first n)\n                  \\M [1000 (rest n)]\n                  \\C (case (second n)\n                       \\D [400 (drop 2 n)]\n                       \\M [900 (drop 2 n)]\n                       [100 (rest n)])\n                  \\X (case (second n)\n                       \\L [40 (drop 2 n)]\n                       \\C [90 (drop 2 n)]\n                       [10 (rest n)])\n                  \\I (case (second n)\n                       \\V [4 (drop 2 n)]\n                       \\X [9 (drop 2 n)]\n                       [1 (rest n)])\n                  \\D [500 (rest n)]\n                  \\L [50 (rest n)]\n                  \\V [5 (rest n)]\n                  nil)]\n      (recur r (+ s m))))))", "user": "5541fa50e4b0a04f79299515"}, {"problem": 92, "code": "(fn [rn] \n (->> \n  (map {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000} rn)\n  reverse\n  ((fn [s] (map #(if (< %1 %2) (- 0 %1) %1) s (reductions max s))))\n  (reduce +)))", "user": "56b86e64e4b0f26550335924"}, {"problem": 92, "code": "(fn [s](let [v #(get {:M 1000 :D 500 :C 100 :L 50 :X 10 :V \n\n5 :I 1} (keyword %))] (reduce + (reduce #(if (< %2 (first \n\n%)) (conj (drop 1 %) (- (first %) %2)) (conj % %2)) '(0) \n\n(reverse (map #(v %) (drop 1 (clojure.string/split (str s) \n\n#\"\"))))))))", "user": "56c08696e4b060a8e693e3aa"}, {"problem": 92, "code": "(fn [rn]\n    (let [numerals {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]\n      (loop [acc 0\n             [n1 n2 & rst] rn]\n        (let [digit1 (get numerals n1)\n              digit2 (or (get numerals n2) 0)]\n          (if digit1\n            (if (< digit1 digit2)\n              (recur (+ acc (- digit2 digit1)) rst)\n              (recur (+ acc digit1) (cons n2 rst)))\n            acc)))))", "user": "5317d78ee4b08068f379ed63"}, {"problem": 92, "code": "(fn solve [x] (let [mappings {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}\n                    translated (reverse (map mappings x))\n                    reducer (fn [[sum biggest-sofar] val] \n                              (if (>= val biggest-sofar) \n                                [(+ sum val) val] \n                                [(- sum val) biggest-sofar]))\n                    ]\n                (first (reduce reducer [0 0] translated))))", "user": "56f258d3e4b04a395b9a04a1"}, {"problem": 92, "code": "(fn [n]\n  (let [r (array-map \"CM\" \"900 \" \"CD\" \"400 \" \"XC\" \"90 \" \"XL\" \"40 \" \"IX\" \"9 \" \"IV\" \"4 \"\n                     \"M\" \"1000 \" \"D\" \"500 \" \"C\" \"100 \" \"L\" \"50 \" \"X\" \"10 \" \"V\" \"5 \" \"I\" \"1 \")]\n    (loop [n n\n           c r]\n      (if (empty? c)\n        (reduce #(+ % %2) (map #(Integer/parseInt %) (clojure.string/split n #\" \")))\n        (let [t (first c)]\n          (recur (clojure.string/replace n (key t) (val t)) (rest c)))))))", "user": "56d5fd24e4b0ea9b8538f7c5"}, {"problem": 92, "code": ";; I like austintaylor's solution\n;;;;(fn [s]\n ;; (let [roman {\"M\" 1000 \"CM\" 900 \"D\" 500 \"CD\" 400\n ;;   \"C\" 100 \"XC\" 90 \"L\" 50 \"XL\" 40 \"X\" 10 \"IX\" 9\n ;;   \"V\" 5 \"IV\" 4 \"I\" 1}]\n  ;;  (reduce + (map roman\n ;;     (re-seq #\"CM|CD|XC|XL|IX|IV|[MDCLXVI]\" s)))))\n\n\n\n (fn roman-numerals [s]     \n    (let [duples-regex #\"IV|IX|XL|XC|CD|CM\"\n          tbl1  \n          {\"IV\" 4\n           \"IX\" 9\n           \"XL\" 40\n           \"XC\" 90             \n           \"CD\" 400            \n           \"CM\" 900}\n          tbl2\n          {\\I 1\n           \\V 5\n           \\X 10               \n           \\L 50\n           \\C 100\n           \\D 500              \n           \\M 1000}\n          total-of-duples (->> s \n                               (re-seq duples-regex)\n                               (map  (partial get tbl1))\n                               (apply +))\n          s-without-duples (clojure.string/replace s duples-regex \"\")\n          total-of-non-duples (->> s-without-duples (map (fn [x] (get tbl2 x))) (apply +))]\n      (+ total-of-duples total-of-non-duples)))", "user": "539f9f79e4b0ca733b97449e"}, {"problem": 92, "code": "(fn [n] (let [nums {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000}\n               dec (map nums n)]\n           (apply + \n                  (reduce #(if (< (first %) %2)\n                            (conj (rest %) (- %2 (first %)))\n                            (conj % %2))\n                          (list (first dec))\n                          (rest dec)))\n            ))", "user": "56f15eade4b04a395b9a048e"}, {"problem": 92, "code": "#(let [decoder {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]\n   (loop [x 0\n          xs (map decoder %)\n          result 0]\n     (if (empty? xs)\n       (+ result x)\n       (recur (first xs) (rest xs) (if (>= x (first xs))\n                                     (+ result x)\n                                     (- result x))))\n\n     )\n   )", "user": "56f7ecdfe4b08e7d20b96834"}, {"problem": 92, "code": "(fn r2n\n    ([roman] (r2n 0 roman))\n    ([num roman]\n     (if (empty? roman)\n       num\n       (let [rvals {\\I    1\n                    \\V    5\n                    \\X   10\n                    \\L   50\n                    \\C  100\n                    \\D  500\n                    \\M 1000}\n             r     (first roman)\n             roman (rest roman)]\n         (if (not-empty roman)\n           (let [r2            (first roman)\n                 roman2        (rest roman)\n                 special-rvals {\"IV\"   4\n                                \"IX\"   9\n                                \"XL\"  40\n                                \"XC\"  90\n                                \"CD\" 400\n                                \"CM\" 900}\n                 special-val   (special-rvals (str r r2))]\n             (if special-val (r2n (+ num special-val ) roman2)\n                 (r2n (+ num (rvals r)) roman))\n             )\n           (r2n (+ num (rvals r)) roman))\n         )\n       )\n     )\n\n    )", "user": "56f9392ae4b07572ad1a88ac"}, {"problem": 92, "code": "(fn [s] \n    (let [numerals {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000} \n          decimals (fn [t] (map numerals (reverse t))) \n          combine (fn [n t] (if (> n (* 4 t)) (- n t) (+ t n)))] (reduce combine (decimals s))))", "user": "52c634b1e4b0c2d177d6210a"}, {"problem": 92, "code": "(fn [r]\n  (let [r->a {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]\n    (->>\n     (map r->a r)\n     (partition-all 2 1)\n     (map (fn[[a b]] (if (and b (< a b)) (- a) a)))\n     (apply +))))", "user": "56795deae4b05957ce8c6187"}, {"problem": 92, "code": "(fn [x]\n         (let [roman {\\I 1\n                      \\V 5\n                      \\X 10\n                      \\L 50\n                      \\C 100\n                      \\D 500\n                      \\M 1000}]\n           (reduce\n            (fn [v [d & rest]]\n              (if (some #(> (roman %) (roman d)) rest)\n                (- v (roman d))\n                (+ v (roman d))))\n            0\n            (take-while #(not (nil? %))\n                        (iterate next (next (list* nil x)))))))", "user": "569dd6e8e4b0542e1f8d1480"}, {"problem": 92, "code": "(fn [s] (let [vals (map #( { \\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000} % )\n      (seq s))]\n      (loop [ [f & r :as x] vals, s (reduce + vals)]\n        (if (seq r)\n           (if (> (first r) f) (recur r (- s (* 2 f))) (recur r s))\n           s))))", "user": "4fd11a93e4b04c3a95aa040a"}, {"problem": 92, "code": "(fn roman [s]\n  (let [r-units [\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"]\n        r-tens  [\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"]\n        r-hunds [\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"]\n        [thous hunds tens units] (rest (re-matches #\"([M]{0,9})([DCM]*)([XLC]*)([IVX]*)\" s))]\n    (+ (* 1000 (count thous)) (* 100 (.indexOf r-hunds hunds)) (* 10 (.indexOf r-tens tens)) (.indexOf r-units units))))", "user": "5292feb4e4b0239c8a67af39"}, {"problem": 92, "code": "(fn parse-rom [s]\n  (letfn [(first-match [s]\n                        (let [digs (for [x [1 10 100 1000]\n                                         y (range 1 10)]\n                                     (* x y))\n                              roms (concat [\"I\" \"II\" \"III\" \"IV\" \"V\" \"VI\" \"VII\" \"VIII\" \"IX\"]\n                                           [\"X\" \"XX\" \"XXX\" \"XL\" \"L\" \"LX\" \"LXX\" \"LXXX\" \"XC\"]\n                                           [\"C\" \"CC\" \"CCC\" \"CD\" \"D\" \"DC\" \"DCC\" \"DCCC\" \"CM\"]\n                                           (reductions str (repeat 9 \"M\")))\n                              rom-number (map vector (reverse roms) (reverse digs))\n                              match (first (filter #(.startsWith s (first %)) rom-number))] ;; => ([\"MMMMMMMMM\" 9000] [...])\n                          match\n                          ))]\n    (let [[rom number] (first-match s)]\n      (if (nil? rom)\n        0\n        (+ number (parse-rom (subs s (count rom))))))))", "user": "56fbf83de4b07572ad1a88da"}, {"problem": 92, "code": "(fn roman-num [x]\n    (let [parsed (seq x)\n          dict {:I 1, :V 5, :X 10, :L 50, :C 100, :D 500, :M 1000}]\n      (if (empty? parsed)\n        0\n        (if (nil? (second parsed))\n          (get dict (keyword (str (first parsed))))\n          (let [f (get dict (keyword (str (first parsed))))\n                s (get dict (keyword (str (second parsed))))]\n            (if (>= f s)\n              (+ f (roman-num (rest parsed))) ; if the preceeding numeral is bigger than the next, add to sum\n              (+ (- s f) (roman-num (rest (rest parsed))))))))))", "user": "57027310e4b08d47c97781e2"}, {"problem": 92, "code": "(fn ro2ar [r]\n  (->> (reverse r)\n       (replace (zipmap \"MDCLXVI\" [1000 500 100 50 10 5 1]))\n       (partition-by identity)\n       (map (partial apply +))\n       (reduce #(if (< %1 %2) (+ %1 %2) (- %1 %2)))))", "user": "57023fc2e4b08d47c97781db"}, {"problem": 92, "code": "(fn [roman]\n  (loop [[f & [s & r :as t]] (reverse (map #(condp = % \\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1) roman)) acc 0]\n    (cond s (if (< s f)\n              (recur r (+ acc (- f s)))\n              (recur t (+ acc f)))\n          f (+ acc f)\n          :else acc)))", "user": "57035ccfe4b08d47c97781ef"}, {"problem": 92, "code": "(fn romanNumerals [roman-text]\n  (let [roman-map {:I 1\n                   :V 5\n                   :X 10\n                   :L 50\n                   :C 100\n                   :D 500\n                   :M 1000}]\n    (let [roman-values (map #(get roman-map %)\n    (map #(keyword (str %)) (seq roman-text)))]\n    (loop [n 0 num 0 roman-vals roman-values] \n      (if (>= n (dec(count roman-values)))\n        (if (empty? roman-vals)\n          num\n          (+ num (first roman-vals)))\n        (if (< (first roman-vals) (second roman-vals))\n          (recur (+ n 2) (+ num (- (second roman-vals) \n                                   (first roman-vals)))\n                 (nthrest roman-vals 2))\n          (recur (inc n) (+ num (first roman-vals)) \n                 (rest roman-vals))))))))", "user": "5703d1fee4b08d47c97781fe"}, {"problem": 92, "code": "(fn romanNumerals [roman-text]\n  (let [roman-map {:I 1\n                   :V 5\n                   :X 10\n                   :L 50\n                   :C 100\n                   :D 500\n                   :M 1000}]\n    (let [roman-values (map #(get roman-map %)\n    (map #(keyword (str %)) (seq roman-text)))]\n    (loop [n 0 num 0 roman-vals roman-values] \n      (if (>= n (dec(count roman-values)))\n        (if (empty? roman-vals)\n          num\n          (+ num (first roman-vals)))\n        (if (< (first roman-vals) (second roman-vals))\n          (recur (+ n 2) (+ num (- (second roman-vals) \n                                   (first roman-vals)))\n                 (nthrest roman-vals 2))\n          (recur (inc n) (+ num (first roman-vals)) \n                 (rest roman-vals))))))))", "user": "5576d3c7e4b05c286339e074"}, {"problem": 92, "code": "(fn [rn]\n  (let [rn-lookup {\"Start-M\" {\\M [\"Start-M\" 1000] \\D [\"DC\" 500] \\C [\"Pre-C\" 0] \\L [\"LX\" 50] \\X [\"Pre-X\" 0] \\V [\"VI\" 5] \\I [\"Pre-I\" 0]}\n                   \"Pre-C\"   {\\M [\"Start-M\" 900] \"D\" [\"DC\" 400] \\C [\"DC\" 200] \\L [\"LX\" 150] \\X [\"Pre-X\" 100] \\V [\"VI\" 105] \\I [\"Pre-I\" 100]}\n                   \"DC\"      {\\C [\"DC\" 100] \\L [\"LX\" 50] \\X [\"Pre-X\" 0] \\V [\"VI\" 5] \\I [\"Pre-I\" 0]}\n                   \"Pre-X\"   {\\C [\"DC\" 90] \\L [\"LX\" 40] \\X [\"LX\" 20] \\V [\"VI\" 15] \\I [\"Pre-I\" 10]}\n                   \"LX\"      {\\X [\"LX\" 10] \\V [\"VI\" 5] \\I [\"Pre-I\" 0]}\n                   \"Pre-I\"   {\\X [\"LX\" 9] \\V [\"VI\" 4] \\I [\"VI\" 2]}\n                   \"VI\"      {\\I [\"VI\" 1]}}]\n    (second\n      (reduce\n        (fn [[state sum] digit]\n          (let [[next-state value] (get-in rn-lookup [state digit])]\n            [next-state (+ sum value)]))\n        [\"Start-M\" 0]\n        rn))))", "user": "56d68cbae4b0ea9b8538f7cd"}, {"problem": 92, "code": "(fn [s]\n  (let [roman {\"M\" 1000 \n               \"CM\" 900 \n               \"D\"  500 \n               \"CD\" 400 \n               \"C\"  100 \n               \"XC\"  90\n               \"L\"   50 \n               \"XL\"  40 \n               \"X\"   10 \n               \"IX\"   9\n               \"V\"    5\n               \"IV\"   4\n               \"I\"    1}]\n    (reduce +\n            (map roman\n                 (re-seq #\"CM|CD|IX|IV|XC|XL|[MDCLXVI]\" s)))))", "user": "56ae214ce4b03c432f18735a"}, {"problem": 92, "code": "(fn [ns]\n    (let [vs {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000 \\0 0}]\n      (:num\n       (reduce\n        (fn [{:keys [num last times] :as s} n]\n          (let [subtract? (< (vs last) (vs n))]\n            (if (= n last)\n              (update-in s [:times] inc)\n              (assoc s :last n :times (if subtract? 0 1)\n                     :num (+ num (if subtract?\n                                   (- (vs n) (* times (vs last)))\n                                   (* times (vs last))))))))\n        {:num 0 :last (first ns) :times 1}\n        (rest (str ns 0))))))", "user": "4f57c913e4b0a7574ea7183f"}, {"problem": 92, "code": "(fn rom [x] \n  (let [numer {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]\n\t(loop [sum 0 last-num 0 remain (seq x)]\n      (if (empty? remain)\n        (+ sum last-num)\n       \t(let [next-num (numer (first remain))]\n          (if (< last-num next-num)\n            (recur (- sum last-num) next-num (rest remain))\n            (recur (+ sum last-num) next-num (rest remain))\n          )\n          )\n        )\n     \n      ) \n  )\n)", "user": "57011eb3e4b08d47c97781d1"}, {"problem": 92, "code": "(fn read-numeral [s]\n  (let [m {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]\n    ((fn numeral-helper [s l t]\n      (if (nil? (first s)) t\n        (if (< (first s) l)\n          (numeral-helper (rest s) (first s) (- t (first s)))\n          (numeral-helper (rest s) (first s) (+ t (first s)))\n        )\n      )) (reverse (map m s)) 0 0)\n  ))", "user": "56b506d5e4b0982f16b37e2d"}, {"problem": 92, "code": "(fn [input]\n  (let \n    [ \n      numerals {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}\n      numbers (map #(numerals %) input)\n      shift (fn [x] ( concat (rest x) ((comp vector last) x) ))\n      zipV  (fn [x] (map vector x (shift x)))\n      mapF  (fn [x] (map #(* (second %)  (if(<= (first %) (second %)) 1 -1)) x))\n      sumNumbers (fn  [list] \n                    (loop \n                      [sublist list, prevS \"#\", subSum 0, curSum []]\n                      (let \n                        [[curS & tail] sublist\n                         condition (= curS prevS)\n                         nextSubSum (if condition \n                                      (+ subSum (numerals curS))\n                                      (numerals curS))\n                         nextSum (if condition curSum (concat curSum (vector subSum)))]\n                         (if (nil? curS) nextSum (recur tail curS nextSubSum nextSum)))))\n    ] \n      ; (println (butlast( mapF (zipV (sumNumbers (reverse input))))))\n      (reduce + (butlast(mapF (zipV (sumNumbers (reverse input))))))\n  )\n)", "user": "5717d674e4b07c98581c3b1a"}, {"problem": 92, "code": "(fn [s]\n  (let [tokens {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}\n        l (map tokens s)                \n        parse-one-step (fn [v]\n                     (let [c (take 2 v)]\n                       (if (apply < c)\n                         [(- (apply - c)) (drop 2 v)]\n                         [(first v) (rest v)]\n                         )))\n        parse-all (fn [v] \n                    (iterate #(parse-one-step (second %)) [0 v]))\n        res (split-with #(not-empty (second %)) (parse-all l))\n        ]    \n    (reduce + (map first (conj (first res) (first (second res)))))\n    ))", "user": "54e345a1e4b024c67c0cf7db"}, {"problem": 92, "code": "(fn [r]\n\t(let [lookup {\"I\" 1\n\t\t\t\t  \"V\" 5\n\t\t\t\t  \"X\" 10\n\t\t\t\t  \"L\" 50\n\t\t\t\t  \"C\" 100\n\t\t\t\t  \"D\" 500\n\t\t\t\t  \"M\" 1000}\n\t\t  xs (reverse (map #(lookup (str %)) r))]\n\t\t  ((fn rmnz [n xs l] \n\t\t  \t(let [x (first xs)]\n\t\t  \t(if (not (seq xs)) n\n\t\t  \t\t(if (<= l x)\n\t\t\t  \t\t(rmnz (+ n x) (rest xs) x)\n\t\t  \t\t\t(rmnz (- n x) (rest xs) x))))) 0 xs 0)))", "user": "5578f292e4b05c286339e08f"}, {"problem": 92, "code": "(fn romek [s]\n  (let [svalues {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}\n        dvalues (map svalues s)]\n    (loop [result 0\n           digits dvalues\n           prev 1001]\n      (if (empty? digits)\n        result\n        (let [[d & r] digits]\n          (if (< prev d)\n            (recur (+ d (- result (* 2 prev))) r d)\n            (recur (+ d result) r d)))))))", "user": "571d063ee4b0145328a76272"}, {"problem": 92, "code": "#(let [value {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]\n  (loop [total 0\n         numerals %]\n    (cond\n     (empty? numerals) total\n     (and (> (count numerals) 1) (> (value (second numerals)) (value (first numerals))))\n       (recur (- total (value (first numerals))) (rest numerals))\n     :else\n       (recur (+ total (value (first numerals))) (rest numerals)))))", "user": "56d63729e4b0ea9b8538f7ca"}, {"problem": 92, "code": "(fn [s]\n  (let [D (zipmap [\\I \\V \\X \\L \\C \\D \\M] [1 5 10 50 100 500 1000])\n        s (partition-by identity (map #(D %) s))]\n    (->> (map (fn [c n]\n                (if (< (first c) (first n))\n                  (map - c)\n                  c))\n              s (concat (rest s) (list (last s))))\n         flatten\n         (apply +))))", "user": "5712854ce4b07c98581c3a89"}, {"problem": 92, "code": "(fn read-rom-num [rn-string]\n  (let [nums-map {\"I\" 1 \"IV\" 4 \"V\" 5 \"IX\" 9 \"X\" 10 \"XL\" 40\n                  \"L\" 50 \"XC\" 90 \"C\" 100 \"CD\" 400 \"D\" 500\n                  \"CM\" 900 \"M\" 1000}\n        process-map {\"I\" [\"IV\" \"IX\" \"I\"]\n                     \"V\" [\"V\"]\n                     \"X\" [\"XL\" \"XC\" \"X\"]\n                     \"L\" [\"L\"]\n                     \"C\" [\"CD\" \"CM\" \"C\"]\n                     \"D\" [\"D\"]\n                     \"M\" [\"M\"]\n                     \"\"  []}]\n    (letfn [(state [strg] (if (empty? strg) \"\" (subs strg 0 1)))\n            (make-reg [strg] (re-pattern (str \"^\" strg)))\n            (proc-two-char-numeral [numeral strg]\n              (if (re-find (make-reg numeral) strg)\n                [(nums-map numeral) (subs strg 2)]\n                nil))\n            (proc-one-char-numeral [numeral strg]\n              (let [reg (make-reg (str \"^[\" numeral \"]+\"))\n                    cnt (count (re-find reg strg))]\n                (if (> cnt 0)\n                  [(* cnt (nums-map numeral)) (subs strg cnt)]\n                  nil)))\n            (process-state [strg state]\n              (let [numeral-vec (process-map state)]\n                (loop [lseq numeral-vec acc []]\n                  (if (or (not (empty? acc)) (empty? lseq))\n                    acc\n                    (let [x (first lseq)\n                          y (if (= 2 (count x))\n                              (proc-two-char-numeral x strg)\n                              (proc-one-char-numeral x strg))\n                          new-acc (if y\n                                    (into [] y)\n                                    [])]\n                      (recur (rest lseq) new-acc))))))]\n      (let [cur-state (state rn-string)\n            cur-amt (if (not= \"\" cur-state)\n                      (process-state rn-string cur-state))]\n        (if (= \"\" cur-state)\n          0\n          (+ (first cur-amt) (read-rom-num (second cur-amt))))))))", "user": "56cb4d06e4b0ea9b8538f72e"}, {"problem": 92, "code": "(fn read-roman [str]\n  (let [rn {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]\n    (letfn [(rn-groups [res num]\n              (let [last-num (-> res last last)]\n                (cond \n                  (zero? last-num) [[num]]\n                  (> num last-num) (update-in res [(dec (count res))] #(conj % num))\n                  :default (conj res [num]))))\n            (group-map [[n1 n2]]\n              (if (nil? n2) n1 (- n2 n1)))]\n      (->> str\n           (map #(get rn %))\n           (reduce rn-groups [[0]])\n           (map group-map)\n           (reduce +)))))", "user": "55c4cda5e4b0e31453f649a5"}, {"problem": 92, "code": "(fn [numer-str]\n  (let [numerals {\"I\" 1 \"V\" 5 \"X\" 10 \"L\" 50 \"C\" 100 \"D\" 500 \"M\" 1000}\n        smaller (fn [a b] (< (get numerals a) (get numerals b)))\n        sum-of-seq (fn [a-seq] (* (count a-seq) (get numerals (first a-seq))))\n        rec-sum (fn [num-list]\n                  (loop [num-list num-list\n                         acc 0]\n                    (cond\n                      (empty? num-list) acc\n                      (empty? (rest num-list)) (+ acc (sum-of-seq (first num-list)))\n                      (smaller (first (first num-list )) (first (second num-list)))\n                        (recur (drop 2 num-list) (+ acc (- (sum-of-seq (second num-list)) (sum-of-seq (first num-list)))))\n                      :else (recur (rest num-list) (+ acc (sum-of-seq (first num-list)))))))]\n    (rec-sum (partition-by identity (map str numer-str)))))", "user": "571cd9dce4b0145328a76271"}, {"problem": 92, "code": "#(let [syms [[[\\M] 1000] [[\\C \\M] 900] [[\\D] 500] [[\\C \\D] 400] [[\\C] 100] [[\\X \\C] 90]\n             [[\\L] 50] [[\\X \\L] 40] [[\\X] 10] [[\\I \\X] 9] [[\\V] 5] [[\\I \\V] 4] [[\\I] 1]]\n       r (fn [[n t]] (first (keep (fn [[s v]] (if (= s (take (count s) n))\n                                                [(drop (count s) n) (+ t v)])) syms)))]\n  (->> (iterate r [% 0])\n       (take-while (comp not nil?)) last last))", "user": "54055aa9e4b0addc1aec6665"}, {"problem": 92, "code": "(fn f\n  ([s] (f (reverse (seq s)) 0))\n  ([s r]\n  (let [numbers {\\O 0 \\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}\n        f-element (first s)\n        s-element (if (nil? (second s)) \\O (second s))\n        fnumber (get numbers f-element)\n        snumber (get numbers s-element)]\n  (if (empty? s)\n    r\n    (if (> fnumber snumber)\n      (recur (drop 2 s) (+ r (- fnumber snumber)))\n      (recur (drop 2 s) (+ r fnumber snumber)))))))", "user": "56ab7578e4b03c432f18733d"}, {"problem": 92, "code": "(fn roman [s]\n  (let [letter-val {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}\n        reducer (fn [[running level :as r] l]\n                  (if (< l level)\n                    [(- running l) level]\n                    [(+ running l) l]))]\n    (->> s\n         reverse\n         seq\n         (map (partial get letter-val))\n         (reduce reducer [0 0])\n         first\n         )))", "user": "572ea970e4b0cd1946bd0f89"}, {"problem": 92, "code": "(fn[rn]\n  (let [rint {\\I 1 \\V 5 \\X 10 \\L 50\n              \\C 100 \\D 500 \\M 1000 }\n        ints (map rint rn)\n        maxs (->> ints\n                  reverse\n                  (reductions max)\n                  reverse)]\n    (reduce + (map #(if (< %1 %2) (- %1) %1) ints maxs))))", "user": "56102f50e4b05f002753df6b"}, {"problem": 92, "code": "(fn [s]\n  (let [m {\\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1 nil 0}]\n    (reduce\n      (fn [n i]\n        (let [v (m (get s i)), v* (m (get s (inc i)))]\n          ((if (< v v*) - +) n v)))\n      0\n      (range (count s)))))", "user": "573d58c8e4b05c31a32c0811"}, {"problem": 92, "code": "(fn [romannum]\n  (let [romanmap {\"I\" 1 \"V\" 5 \"X\" 10 \"L\" 50 \"C\" 100 \"D\" 500 \"M\" 1000}]\n    (first\n      (reduce (fn [pair cur] (let [acc (first pair) prev (second pair)] [(if (< cur prev) (- acc cur) (+ acc cur)) cur]))\n              [0 0]\n              (reverse (map #(get romanmap %) (map #(str %) romannum)))))))", "user": "4e3ac1b2535deb9a81d77f4c"}, {"problem": 92, "code": "(fn roman [rm]\n\t(let [s (first rm), ss (-> rm rest first)]\n\t\t(condp = (str s ss)\n\t\t\t\"IV\" (+ 4 (roman (-> rm rest rest)))\n\t\t\t\"IX\" (+ 9 (roman (-> rm rest rest)))\n\t\t\t\"XL\" (+ 40 (roman (-> rm rest rest)))\n\t\t\t\"XC\" (+ 90 (roman (-> rm rest rest)))\n\t\t\t\"CD\" (+ 400 (roman (-> rm rest rest)))\n\t\t\t\"CM\" (+ 900 (roman (-> rm rest rest)))\n\t\t\t\"\" 0\n\t\t\t(condp = s\n\t\t\t\t\\I (+ 1 (roman (rest rm)))\n\t\t\t\t\\V (+ 5 (roman (rest rm)))\n\t\t\t\t\\X (+ 10 (roman (rest rm)))\n\t\t\t\t\\L (+ 50 (roman (rest rm)))\n\t\t\t\t\\C (+ 100 (roman (rest rm)))\n\t\t\t\t\\D (+ 500 (roman (rest rm)))\n\t\t\t\t\\M (+ 1000 (roman (rest rm)))\n\t\t\t\t)\n\t\t\t)))", "user": "572ec4dde4b0cd1946bd0f8d"}, {"problem": 92, "code": "(fn[x](reduce + (map (fn[y]({\"I\" 1 \"V\" 5 \"X\" 10 \"L\" 50 \"C\" 100 \"D\" 500 \"M\" 1000} y)) \n(filter (fn[z](< 0 (count z))) (clojure.string/split\n(clojure.string/replace \n(clojure.string/replace \n(clojure.string/replace \n(clojure.string/replace \n(clojure.string/replace \n(clojure.string/replace \n(clojure.string/replace x\n\"IV\" \"IIII\")\n\"IV\" \"IIII\")\n\"IX\" \"VIIII\")\n\"XL\" \"XXXX\")\n\"XC\" \"LXXXX\")\n\"CD\" \"CCCC\")\n\"CM\" \"DCCCC\")\n #\"\")\n)\n)))", "user": "574a9132e4b02ea1147991fd"}, {"problem": 92, "code": "(fn readRomans [str] (letfn [\n                             (romanValue [ch] (cond \n                                               (= \\I ch) 1\n                                               (= \\V ch) 5\n                                               (= \\X ch) 10\n                                               (= \\L ch) 50\n                                               (= \\C ch) 100\n                                               (= \\D ch) 500\n                                               (= \\M ch) 1000))\n                             (findNegs [numSeq] (loop [todo numSeq res '()] (cond \n                                                                             (empty? (rest todo)) (conj res (first todo))\n                                                                             (< (first todo) (second todo)) (recur (rest todo) (conj res (* -1 (first todo))))\n                                                                             :default (recur (rest todo) (conj res (first todo))))))\n                             (convertToNumbers [romanSeq] (into [] (map romanValue romanSeq)))\n                             ]\n                       (reduce + (findNegs (convertToNumbers (seq str))))\n                       )\n  )", "user": "56427910e4b08d4f616f5f19"}, {"problem": 92, "code": "(fn [romeNumber]\n   (loop [posStart 0 posEnd (count romeNumber) accumulator ()]\n     (let [romeLetters (count romeNumber)\n           numbers {3 {1 \"M\" 2 \"MM\" 3 \"MMM\" 4 \"MMMM\" 5 \"MMMMM\" 6 \"MMMMMM\" 7 \"MMMMMMM\" 8 \"MMMMMMMM\" 9 \"MMMMMMMMM\"}\n                    2 {1 \"C\" 2 \"CC\" 3 \"CCC\" 4 \"CD\" 5 \"D\" 6 \"DC\" 7 \"DCC\" 8 \"DCCC\" 9 \"CM\"}\n                    1 {1 \"X\" 2 \"XX\" 3 \"XXX\" 4 \"XL\" 5 \"L\" 6 \"LX\" 7 \"LXX\" 8 \"LXXX\" 9 \"XC\"}\n                    0 {1 \"I\" 2 \"II\" 3 \"III\" 4 \"IV\" 5 \"V\" 6 \"VI\" 7 \"VII\" 8 \"VIII\" 9 \"IX\"}}\n           expo (fn [x n] (reduce * (repeat n x)))\n           letterIndex (remove nil? \n                         (for [[key nums] numbers]\n                           (let \n                            [arabicValue (get \n                                          (reduce #(assoc %1 (second %2) (first %2)) {} nums) \n                                          (subs romeNumber posStart posEnd))]\n                            (if (integer? arabicValue)\n                              (do\n                                (* arabicValue (expo 10 key)))))))]\n          (if (> posEnd posStart)\n             (do\n              (recur \n                (if (> (count letterIndex) 0)\n                   posEnd\n                   posStart)\n                (if (> (count letterIndex) 0)\n                    romeLetters\n                    (dec posEnd))  \n                (cons letterIndex accumulator)))\n             (reduce + (flatten accumulator))))))", "user": "575683aee4b02ea1147992dc"}, {"problem": 92, "code": "(fn roman-decimal [s]\n  (letfn [(get-values [n]\n            (let [ln (apply vector n)\n                  values {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]\n              (mapv #(values %) ln)))]\n    (loop [sum 0\n           ln (get-values s)]\n      (if (= ln [])\n        sum\n        (let [f (first ln)\n              s (second ln)]\n          (if (and (not= s nil) (< f s))\n            (recur (+ sum (- s f)) (rest (rest ln)))\n            (recur (+ sum f) (rest ln))))))))", "user": "574f1c24e4b02ea114799255"}, {"problem": 92, "code": "(let [values [[\"CM\" 900]\n              [\"CD\" 400]\n              [\"XC\" 90]\n              [\"XL\" 40]\n              [\"IX\" 9]\n              [\"IV\" 4]\n              [\"M\" 1000]\n              [\"D\" 500]\n              [\"C\" 100]\n              [\"L\" 50]\n              [\"X\" 10]\n              [\"V\" 5]\n              [\"I\" 1]]]\n  (fn [glyph]\n    (->> glyph\n         (re-seq (->> values\n                      (map first)\n                      (clojure.string/join \"|\")\n                      re-pattern))\n         (map (into {} values))\n         (apply +))))", "user": "575cbe44e4b02ea114799374"}, {"problem": 92, "code": "(fn [s] \n  (let [symbols (seq s)\n        symbolPairs (partition 2 1 symbols)]\n    (letfn [(valOfTuple [a b] (case [a b]\n                             [\\I \\V] -1\n                             [\\I \\X] -1\n                             [\\X \\L] -10\n                             [\\X \\C] -10\n                             [\\C \\D] -100\n                             [\\C \\M] -100\n                             (valOf a)))\n            (valOf [a] (case a\n                           \\I 1\n                           \\V 5\n                           \\X 10\n                           \\L 50\n                           \\C 100\n                           \\D 500\n                           \\M 1000\n                           nil))\n            (reducer [sum [a b]] (+ (valOfTuple a b) sum))]\n      (reduce reducer (valOf (last symbols)) symbolPairs)\n      )\n    )    \n  )", "user": "575ef4b6e4b08062f99a4e78"}, {"problem": 92, "code": "(fn [s]\n (let [lu  (array-map \\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1)]\n   (reduce \n     (fn ya [sum [a b]] \n       (cond \n         (nil? b) (+ sum a)\n         (< a b) (- sum a)\n         :else (+ sum a)\n         ))  \n     0 \n     (partition 2 1 [nil] (map #(lu %) s)))))", "user": "541ddadbe4b01498b1a71a84"}, {"problem": 92, "code": "(fn [s]\n  (let [RN {\"I\" 1 \"V\" 5 \"X\" 10 \"L\" 50 \"C\" 100 \"D\" 500 \"M\" 1000}] \n    (:sum (reduce\n           (fn [m r]\n             (let [v (get RN r)]\n               {:sum (if (< v (:last m))\n                       (- (:sum m) v)\n                       (+ (:sum m) v)) :last v}))\n           {:sum 0 :last 0} \n           (reverse (filter #(< 0 (count %)) (clojure.string/split s #\"\")))))))", "user": "53c1b787e4b00fb29b221266"}, {"problem": 92, "code": "(fn readrom [s]\n  (letfn [(num->digits [num]\n            (loop [n num digits []]\n              (if (< n 10)\n                (cons (int n) digits)\n                (recur (quot n 10) (cons (int (rem n 10)) digits)))))\n          (writerom\n            ([n] (writerom n []))\n            ([n o]\n             (let [dig (num->digits n)\n                   f (fn f [n bb b s]\n                       (case n\n                         9 [s bb]\n                         8 [b s s s]\n                         7 [b s s]\n                         6 [b s]\n                         5 [b]\n                         4 [s b]\n                         3 [s s s]\n                         2 [s s]\n                         1 [s]\n                         0 []))]\n               (case (count dig)\n                 4 (let [x (int (/ n 1000))]\n                     (writerom (- n (* 1000 x))\n                               (into o (take x (repeat \"M\")))))\n                 3 (writerom (- n (* 100 (int (/ n 100))))\n                             (into o (f (first dig) \"M\" \"D\" \"C\")))\n                 2 (writerom (- n (* 10 (int (/ n 10))))\n                             (into o (f (first dig) \"C\" \"L\" \"X\")))\n                 1 (apply str\n                          (into o (f (first dig) \"X\" \"V\" \"I\")))))))]\n    (first\n     (filter number?\n             (map #(if (= s (writerom %)) %)\n                  (range 4000))))))\n\n;nice regex based way:\n;(fn [x]\n;  (let\n;    [R {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000}]\n;    (reduce +\n;      (map\n;        (partial reduce #(- (R %2) %1) 0)\n;        (re-seq #\"IV|IX|XL|XC|XM|CD|CM|[IVXLCDM]\" x)))))", "user": "57533bc1e4b02ea1147992a6"}, {"problem": 92, "code": "(fn [numeral]\n  (let [values {\\I 1\n                \\V 5\n                \\X 10\n                \\L 50\n                \\C 100\n                \\D 500\n                \\M 1000}]\n  (apply + (map (fn [[x y]]\n                  (let [a (values x)\n                        b (values y)\n                        v (- a b)]\n                    (if (neg? v)\n                      (- a)\n                      a)))\n                (partition 2 1 [\\I] numeral)))))", "user": "57609d91e4b08062f99a4e9b"}, {"problem": 92, "code": "(fn rom [s]\n   (let [A {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}\n         R [[\"IV\" \"IIII\"]\n            [\"IX\" \"VIIII\"]\n            [\"XL\" \"XXXX\"]\n            [\"XC\" \"LXXXX\"]\n            [\"CD\" \"CCCC\"]\n            [\"CM\" \"DCCCC\"]]]\n     (apply + (map A (reduce #(clojure.string/replace % (first %2)(second %2)) s R )))))", "user": "534fa9dae4b084c2834f4acf"}, {"problem": 92, "code": "(fn [s] (let [\n      x1 (map {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000} s)\n\t  x2 (map vector x1 (drop 1 x1))]\n      (+ (last x1) (apply + (map #(if (< (first %) (second %)) (- (first %)) (first %)) x2)))\n          ))", "user": "5547b72be4b0a04f79299550"}, {"problem": 92, "code": "(fn [s]\n  (let [roman {\\I 1,\\V 5,\\X 10,\\L 50,\\C 100,\\D 500,\\M 1000}\n        number (map #(roman %) (seq s))]\n    (loop [p number r []]\n      (cond\n       (= 1 (count p))  (apply + (conj r (first p)))\n       (< (first p) (second p)) (recur (next p) (conj r (- (first p))))\n       :else (recur (next p)  (conj r (first p)))))))", "user": "574abbfbe4b02ea114799200"}, {"problem": 92, "code": "{\"XIV\" 14 \"DCCCXXVII\" 827 \"MMMCMXCIX\" 3999 \"XLVIII\" 48}", "user": "574dfcb8e4b02ea11479923a"}, {"problem": 92, "code": "(fn read-roman [s]\n  (let [value-for {\\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1\n                   \"IV\" 4 \"IX\" 9 \"XL\" 40 \"XC\" 90 \"CD\" 400 \"CM\" 900}]\n    (if-let [s (seq s)]\n      (if-let [n (value-for (apply str (take 2 s)))]\n        (+ n (read-roman (drop 2 s)))\n        (+ (value-for (first s)) (read-roman (drop 1 s))))\n      0)))", "user": "5764457ae4b0994c1922fbf3"}, {"problem": 92, "code": "(fn [rns]\n  (let [m [\n         [\"M\" 1000]\n         [\"CM\" 900]\n         [\"D\" 500]\n         [\"CD\" 400]\n         [\"C\" 100]\n         [\"XC\" 90]\n         [\"L\" 50]\n         [\"XL\" 40]\n         [\"X\" 10]\n         [\"IX\" 9]\n         [\"V\" 5]\n         [\"IV\" 4]\n         [\"I\" 1]\n         ]]\n    (loop [ms m s rns sum 0]\n      (if (empty? s)\n        sum\n        (let [[rn n] (first ms)]\n          (if (.startsWith s rn)\n            (recur ms (subs s (count rn)) (+ sum n))\n            (recur (rest ms) s sum)\n            )\n          )\n        )\n      )\n    )\n  )", "user": "56d91a53e4b0ea9b8538f7ee"}, {"problem": 92, "code": "#(reduce + ((fn l[[f & [s :as r]]]\n             (if s \n                (cons (if (< f s) (- f) f) (l r))\n               [f]))\n           (map {'\\X 10 '\\I 1 '\\V 5 '\\L 50 '\\C 100 '\\D 500 '\\M 1000 } %)))", "user": "5731e36be4b0cd1946bd0fc9"}, {"problem": 92, "code": "(fn roman-to-num [s]\n  (let [; we invent some digits N-S to represent valid substractive-principle numbers\n        roman-digits (zipmap \"IVXLCDMNOPQRS\" [1 5 10 50 100 500 1000 4 9 40 90 400 900])\n        subsnum {\"IV\" \"N\" \"IX\" \"O\" \"XL\" \"P\" \"XC\" \"Q\" \"CD\" \"R\" \"CM\" \"S\"}]\n    (apply + (replace roman-digits\n                      (reduce (fn [s [a b]] (clojure.string/replace s a b)) s subsnum)))))", "user": "575b3e9be4b02ea11479935b"}, {"problem": 92, "code": "(let [numerals {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000 }]\n  \n  (fn roman [s]\n    \n    (->>  ; join similar successive characters:\n          ; \"XXCIIV\" => ((X X) (C) (I I) (V))\n          (partition-by identity s) \n          \n          ; convert letter groups into tuples of [count numeral-weight]\n          ; ((X X) (C) (I I) (V)) \n          ; becomes [[2 10] [1 100] [2 1] [1 5]]\n          (map (juxt count #(numerals (first %)) ))\n          \n          ;; compare successive tuples, if the right weight \n          ;; is greater than the left, make the left count negative\n          ;; e.g. [[2 10] [1 100] [2 1] [1 5]] => [[-2 10] [1 100] [-2 1] [1 5]]\n          (#(loop \n            [ acc [] \n              [count-prev weight-prev :as prev] [0 99999] ;; count-prev and weight\n              [[count-next weight-next :as next] & rest] %\n              ]\n            \n            (let \n              [acc-item (if (< weight-prev weight-next) [(- count-prev) weight-prev] prev ) ]\n              \n              (do\n                (println :acc acc :p prev :n next :r rest)\n                \n                (if (nil? rest) (conj acc acc-item next)\n                  \n                  (recur \n                   (conj acc acc-item );; acc\n                   next ;; prev\n                   rest ;; [next & rest]\n                   ))))))\n          \n          ;; multiply inner pairs:\n          ;;((-2 10)(1 100)(-2 1)(1 5)) => (-20 100 -2 5)\n          (map #(apply * %))\n\n          ;; sum the results\n          (apply +)\n          )\n    )\n  )", "user": "533a2f7be4b0e30313ee6cb8"}, {"problem": 92, "code": "(fn roman->int [st]\n    (let [leader [[\"M\" 1000] [\"CM\" 900] [\"D\" 500] [\"CD\" 400]\n                  [\"C\" 100] [\"XC\" 90] [\"L\" 50] [\"XL\" 40] [\"X\" 10]\n                  [\"IX\" 9] [\"V\" 5] [\"IV\" 4] [\"I\" 1]]]\n      (loop [acc 0 r st]\n        (if (empty? r)\n          acc\n          (when-let [[s v] (some #(when (.startsWith r (first %)) %) leader)]\n            (recur (+ acc v) (subs r (count s))))))))", "user": "4dfe5a93535d04ed9115e786"}, {"problem": 92, "code": "(fn\n      [roman-numeral]\n      (let [splitter (fn\n                       [data]\n                       \"{:num LXXXIV :bit {:bit #CM :value 900} :sum 0}\"\n                       (let [update (fn [m k f]\n                                      (assoc m k (f (get m k))))\n                             find (clojure.string/split (:num data) (:bit (:bit data)))\n                             updated-sum (update\n                                           data\n                                           :sum\n                                           #(+ % (* (- (count find) 1) (:value (:bit data)))))]\n                            (assoc updated-sum :num ( clojure.string/join find))))\n            bits [{:bit #\"CM\" :value 900}\n                  {:bit #\"CD\" :value 400}\n                  {:bit #\"XC\" :value 90}\n                  {:bit #\"XL\" :value 40}\n                  {:bit #\"IX\" :value 9}\n                  {:bit #\"IV\" :value 4}\n                  {:bit #\"M\" :value 1000}\n                  {:bit #\"D\" :value 500}\n                  {:bit #\"C\" :value 100}\n                  {:bit #\"L\" :value 50}\n                  {:bit #\"X\" :value 10}\n                  {:bit #\"V\" :value 5}\n                  {:bit #\"I\" :value 1}]\n            data (splitter {:num (clojure.string/join [roman-numeral \" \"])\n                            :bit (first bits)\n                            :sum 0})]\n           (loop [data data\n                  remaining (rest bits)]\n                 (if (> (count remaining) 0)\n                   (recur (splitter (assoc data :bit (first remaining))) (rest remaining))\n                   (:sum data)))))", "user": "56cc34aee4b0ea9b8538f73c"}, {"problem": 92, "code": "(fn [[h & t]]\n  (let [v {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]\n    (first (reduce (fn [[res l] c]\n                     (let [cv (get v c)]\n                       [(+ res (if (< l cv) (+ (* -2 l) cv)  cv))\n                        cv]))\n                   [(get v h) (get v h)]\n                   t))))", "user": "4ee528fb535d1385b2869d87"}, {"problem": 92, "code": "(fn readrom [s]\n  (letfn [(num->digits [num]\n            (loop [n num digits []]\n              (if (< n 10)\n                (cons (int n) digits)\n                (recur (quot n 10) (cons (int (rem n 10)) digits)))))\n          (writerom\n            ([n] (writerom n []))\n            ([n o]\n             (let [dig (num->digits n)\n                   f (fn f [n bb b s]\n                       (case n\n                         9 [s bb]\n                         8 [b s s s]\n                         7 [b s s]\n                         6 [b s]\n                         5 [b]\n                         4 [s b]\n                         3 [s s s]\n                         2 [s s]\n                         1 [s]\n                         0 []))]\n               (case (count dig)\n                 4 (let [x (int (/ n 1000))]\n                     (writerom (- n (* 1000 x))\n                               (into o (take x (repeat \"M\")))))\n                 3 (writerom (- n (* 100 (int (/ n 100))))\n                             (into o (f (first dig) \"M\" \"D\" \"C\")))\n                 2 (writerom (- n (* 10 (int (/ n 10))))\n                             (into o (f (first dig) \"C\" \"L\" \"X\")))\n                 1 (apply str\n                          (into o (f (first dig) \"X\" \"V\" \"I\")))))))]\n    (first\n     (filter number?\n             (map #(if (= s (writerom %)) %)\n                  (range 4000))))))\n\n;nice regex based way:\n;(fn [x]\n;  (let\n;    [R {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000}]\n;    (reduce +\n;      (map\n;        (partial reduce #(- (R %2) %1) 0)\n;        (re-seq #\"IV|IX|XL|XC|XM|CD|CM|[IVXLCDM]\" x)))))", "user": "5798205ce4b039eba2ecb10e"}, {"problem": 92, "code": "(fn readrom [s]\n  (letfn [(num->digits [num]\n            (loop [n num digits []]\n              (if (< n 10)\n                (cons (int n) digits)\n                (recur (quot n 10) (cons (int (rem n 10)) digits)))))\n          (writerom\n            ([n] (writerom n []))\n            ([n o]\n             (let [dig (num->digits n)\n                   f (fn f [n bb b s]\n                       (case n\n                         9 [s bb]\n                         8 [b s s s]\n                         7 [b s s]\n                         6 [b s]\n                         5 [b]\n                         4 [s b]\n                         3 [s s s]\n                         2 [s s]\n                         1 [s]\n                         0 []))]\n               (case (count dig)\n                 4 (let [x (int (/ n 1000))]\n                     (writerom (- n (* 1000 x))\n                               (into o (take x (repeat \"M\")))))\n                 3 (writerom (- n (* 100 (int (/ n 100))))\n                             (into o (f (first dig) \"M\" \"D\" \"C\")))\n                 2 (writerom (- n (* 10 (int (/ n 10))))\n                             (into o (f (first dig) \"C\" \"L\" \"X\")))\n                 1 (apply str\n                          (into o (f (first dig) \"X\" \"V\" \"I\")))))))]\n    (first\n     (filter number?\n             (map #(if (= s (writerom %)) %)\n                  (range 4000))))))\n\n;nice regex based way:\n;(fn [x]\n;  (let\n;    [R {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000}]\n;    (reduce +\n;      (map\n;        (partial reduce #(- (R %2) %1) 0)\n;        (re-seq #\"IV|IX|XL|XC|XM|CD|CM|[IVXLCDM]\" x)))))", "user": "57982bace4b039eba2ecb10f"}, {"problem": 92, "code": ";(\n (fn [rs]\n   (let \n    [m {\\I 1\n        \\V 5 \n        \\X 10 \n        \\L 50 \n        \\C 100 \n        \\D 500 \n        \\M 1000}\n     \n     f (fn [{:keys [lr lrv v]}\n            nr]\n         (prn :lr lr :lrv lrv :v v :nr nr)\n         (merge {:lr nr}\n          (cond\n           (or (nil? lr)\n               (= lr nr))\n            {:lrv (+ lrv\n                     (m nr))\n             :v v}\n            (< (m lr) (m nr))\n             {:lrv (m nr)\n              :v (- v lrv)}\n            (> (m lr) (m nr))\n             {:lrv (m nr)\n              :v (+ v lrv)}\n           )))\n     r (reduce f {:lrv 0 :v 0} rs)]\n   ;(f {:lr \\L :lrv 3 :v 7}\\X)\n    (+ (r :v) (r :lrv ))\n    )) \n     ;\"XIV\")", "user": "578cf84ce4b0ebec4cfb7562"}, {"problem": 92, "code": "(fn [s]\n  (let [digits {\\M 1000\n                \\D 500\n                \\C 100\n                \\L 50\n                \\X 10\n                \\V 5\n                \\I 1}]\n    (:total\n     (reduce\n      (fn [{:keys [max-digit total]} digit]\n        {:max-digit (max max-digit digit)\n         :total ((if (< digit max-digit) - +) total digit)})\n      {:max-digit 0 :total 0}\n      (reverse (map digits s))))))", "user": "57a4fa50e4b0a966079561f1"}, {"problem": 92, "code": "(let\n  [values {\\M 1000, \\D 500, \\C 100, \\L 50, \\X 10, \\V 5, \\I 1}]\n  (fn [s]\n    (loop [value 0\n           remaining (rest s)\n           now (first s)\n           now-value (values now)]\n      (cond (empty? remaining) (+ now-value value)\n            (> (values (first remaining)) now-value)\n                (recur (- value now-value) (rest remaining) (first remaining) (values (first remaining)))\n            :else\n                (recur (+ value now-value) (rest remaining) (first remaining) (values (first remaining)))))))", "user": "57717915e4b0979f896515b3"}, {"problem": 92, "code": "#(loop [res 0 pend (partition-by identity %) ]\n\t(if (empty? pend)\n\t\tres\n\t \t(let [numChart {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000} part (first pend) valPart (get numChart (first part))]\n\t\t(if (> (count part) 1)\n\t\t\t(recur (+ res (* (count part) valPart)) (rest pend))\n\t\t\t(let [nextPart (second pend) valNext (get numChart (first nextPart)) isAlone (= (count nextPart) 1)]\n\t\t\t\t(if (and isAlone (> valNext valPart))\n\t\t\t\t\t(recur (+ res (- valNext valPart)) (drop 2 pend))\n\t\t\t\t\t(recur (+ res valPart) (rest pend))))))))", "user": "57986b76e4b039eba2ecb116"}, {"problem": 92, "code": "(fn read-roman[s]\n  (let [order [[\"M\" 1000],[ \"CM\" 900],[ \"D\" 500], [\"DC\" 400] ,[\"C\" 100],[ \"XC\" 90],[ \"L\" 50],[ \"XL\" 40],[ \"X\" 10],[ \"IX\" 9],[ \"V\" 5],[ \"IV\" 4],[ \"I\" 1]]]\n    (loop [s s total 0]\n      (if (empty? s)\n        total\n        (let [[letter value] (some #(and (.startsWith s (first %)) %) order)]\n          (do (println letter value total)\n          (recur (clojure.string/replace-first s letter \"\") (+ total value)))\n          )\n        )\n      )\n    )\n  )", "user": "5776558ee4b0979f89651633"}, {"problem": 92, "code": "(fn [greek] (#(loop [i %1 last 0 result 0] \n        (if (empty? i)\n          result\n          (recur (rest i)\n                 (first i)\n                 (if (> last (first i))\n                     (- result (first i))\n                     (+ result (first i))) ))) \n              (#(map (fn [in] (cond\n                          (= in \"I\") 1\n                          (= in \"V\") 5\n                          (= in \"X\") 10\n                          (= in \"L\") 50\n                          (= in \"C\") 100\n                          (= in \"D\") 500\n                          (= in \"M\") 1000)) \n                     (map str (reverse (seq %1)))) greek)))", "user": "560c37b5e4b05f002753df2e"}, {"problem": 92, "code": "(fn\n  [str]\n  (let [m (hash-map \\M 1000, \\D 500, \\C 100, \\L 50, \\X 10, \\V 5, \\I 1, [\\I \\V] 4, [\\I \\X] 9, [\\C \\M] 900, [\\C \\D] 400, [\\X \\L] 40, [\\X \\C] 90)]\n    (loop [a (vec str) s 0]\n      (if (empty? a)\n        s\n        (if (.contains (keys m) (take 2 a))\n          (recur (drop 2 a) (+ s (m (take 2 a))))\n          (recur (rest a) (+ s (m (first a))) )\n          ))))\n  )", "user": "5772ddb0e4b0979f896515d4"}, {"problem": 92, "code": "(fn [s]     \n  (loop [[c & r] s prev nil result 0]      \n    (if-not c\n      result\n      (let [v (case c\n                \\I 1\n                \\V 5\n                \\X 10\n                \\L 50\n                \\C 100\n                \\D 500\n                \\M 1000)]\n        (recur r v \n               (if (and prev (> v prev))\n                 (+ result (- (* 2 prev)) v)\n                 (+ result v)))))))", "user": "57afd36de4b0fbc9809a273c"}, {"problem": 92, "code": "(fn [s]\n    (let [roman-digits {\\M 1000\n                        \\D 500\n                        \\C 100\n                        \\L 50\n                        \\X 10\n                        \\V 5\n                        \\I 1}]\n      (loop [acc 0\n             last-value 0\n             current-letter (first s)\n             remaining (next s)]\n        (if-not current-letter\n          acc\n          (let [current-value (roman-digits current-letter)]\n            (recur (+ acc current-value (if (< last-value current-value)\n                                          (- (* 2 last-value))\n                                          0))\n                   current-value\n                   (first remaining)\n                   (next remaining)))))))", "user": "51b91b08e4b0e871ca4958f8"}, {"problem": 92, "code": "(fn [s]\n    (let [digits (sorted-map-by > 1000 \"M\" 900 \"CM\" 500 \"D\" 400 \"CD\" 100 \"C\" 90 \"XC\" 50 \"L\" 40 \"XL\" 10 \"X\" 9 \"IX\" 5 \"V\" 4 \"IV\" 1 \"I\")]\n      (letfn [(extract-digit [[n s] [k v]]\n                (if (.startsWith s v)\n                  (extract-digit [(+ n k) (.substring s (count v))] [k v])\n                  [n s]))]\n        (first (reduce extract-digit [0 s] digits)))))", "user": "4e837808535db62dc21a62d9"}, {"problem": 92, "code": "(fn myf [rom-nums]\n  (let [nums\t(replace (zipmap \"MDCLXVI\" [1000 500 100 50 10 5 1]) rom-nums)\n        nums\t(map #(if (< %1 %2) (- %1) %1) nums (concat (next nums) [1]))]\n    (apply + nums)))", "user": "577c3da9e4b0c8d87281f6b9"}, {"problem": 92, "code": "(fn f [s]\n  (let [ ;returns value of a roman digit\n         roman->decimal (fn [rc] (case rc \\I 1 \\V 5 \\X 10 \\L 50 \\D 500 \\C 100 \\M 1000))\n         ;returns composite value of one or two consecutive roman values\n         value (fn ([a] a) ([a b] (if (< a b) (- a) a)))]\n    (->> (map roman->decimal s)\n         (partition-all 2 1)\n         (map #(apply value %))\n         (reduce + 0))))", "user": "57adbe7ee4b0b8559636fca0"}, {"problem": 92, "code": "(fn roman [s]\n  (let [combos {\"IV\" 4 \"IX\" 9 \"XL\" 40 \"XC\" 90 \"CD\" 400 \"CM\" 900}\n        singles {\"I\" 1 \"V\" 5 \"X\" 10 \"L\" 50 \"C\" 100 \"D\" 500 \"M\" 1000}]\n    (loop [arabic 0\n           roamin s]\n      (if-not (seq roamin)\n        arabic\n        (let [n (get combos (clojure.string/join \"\" (take 2 roamin)))\n              x (if n\n                  (+ arabic n)\n                  (+ arabic (get singles (str (first roamin)))))\n              r (if n\n                  (drop 2 roamin)\n                  (rest roamin))]\n          (recur x (clojure.string/join r)))))))", "user": "563fc1f2e4b08d4f616f5ed7"}, {"problem": 92, "code": "#(loop [[f & r] (map {\\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1} %) s 0]\n  (if r\n    (if (< f (first r))\n      (recur r (- s f))\n      (recur r (+ s f)))\n    (+ s f)))", "user": "57b3efb1e4b0fbc9809a278a"}, {"problem": 92, "code": "(let [c->i {\\M (constantly 1000)\n            \\D (constantly 500)\n            \\C #(get {\\D -100 \\M -100} % 100)\n            \\L (constantly 50)\n            \\X #(get {\\L -10 \\C -10} % 10)\n            \\V (constantly 5)\n            \\I #(get {\\V -1 \\X -1} % 1)}]\n  (fn [s]\n    (reduce (fn [n [a b]] (+ n ((get c->i a) b)))\n            0\n            (partition 2 1 (str s \\_)))))", "user": "4f5599dfe4b0a7574ea71806"}, {"problem": 92, "code": "(fn [s]\n  (loop [s s\n         m [ 900  1000 400  500 90   100 40   50  9    10  4    5   1]\n         r [#\"CM\" #\"M\"  #\"CD\" #\"D\" #\"XC\" #\"C\" #\"XL\" #\"L\" #\"IX\" #\"X\" #\"IV\" #\"V\" #\"I\"]]\n    (if (seq m)\n      (recur (clojure.string/replace s (first r) (str \" \" (first m) \" \"))\n             (rest m)\n             (rest r))\n      (apply + (read-string (str \"[\" s \"]\"))))))", "user": "5799ff45e4b05b1deef9add1"}, {"problem": 92, "code": "(fn [s]\n   (let\n       [val-map {\"I\" 1 \"V\" 5 \"X\" 10 \"L\" 50 \"C\" 100 \"D\" 500 \"M\" 1000\n                 \"IV\" 4 \"IX\" 9 \"XL\" 40 \"XC\" 90 \"CD\" 400 \"CM\" 900}\n        re #\"(IV|IX|XL|XC|CD|CM|I|V|X|L|C|D|M)\"]\n     (->> s\n          (re-seq re)\n          (map first)\n          (map val-map)\n          (reduce +))\n     ))", "user": "55f09e7be4b06e875b46ce28"}, {"problem": 92, "code": "(fn [s]\n  (->> s\n       (map {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000})\n       reverse\n       (reduce\n         (fn [[a l] x]\n           (if (<= l x) [(+ a x) x]\n                        [(- a x) l]))\n         [0 0])\n       first))", "user": "53d78b64e4b0e771c3025466"}, {"problem": 92, "code": "(fn roman-numerals-number\n  [str]\n  (let [sym-table {\\I 1,\\V 5,\\X 10,\\L 50,\\C 100,\\D 500,\\M 1000}\n        nums (mapv #(sym-table %1) str)]\n    (reduce + (map-indexed (fn [idx item]\n                             (let [max-right-item (reduce max (subvec nums idx))\n                                   num-x (if (> max-right-item item) -1 1)]\n                               (* item num-x)))\n                           nums))))", "user": "57c500f9e4b05aa3c4741cda"}, {"problem": 92, "code": "(fn roman [s]\n  (reduce +\n          (let [vals {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000}\n                s1 (-> s (clojure.string/replace #\"IV\" \"IIII\")\n                         (clojure.string/replace #\"XL\" \"XXXX\")\n                         (clojure.string/replace #\"CD\" \"CCCC\")\n                         (clojure.string/replace #\"IX\" \"VIIII\")\n                         (clojure.string/replace #\"XC\" \"LXXXX\")\n                         (clojure.string/replace #\"CM\" \"DCCCC\"))]\n            (map (fn [c] (vals c)) (seq s1)))))", "user": "579d9601e4b05b1deef9ae18"}, {"problem": 92, "code": "(fn [s]\n  (let [reg #\"(M*)([C]M)?(D*)([C]D)?(C*)([X]C)?(L*)([X]L)?(X*)([I]X)?(V*)([I]V)?(I*)\"\n        matches (->> (re-seq reg s)\n                     first\n                     (filter #(> (count %) 0))\n                     rest)\n        values {\"M\" 1000 \"MM\" 2000 \"MMM\" 3000 \"CM\" 900\n        \t\t\"D\" 500 \"CD\" 400\n        \t\t\"C\" 100 \"CC\" 200 \"CCC\" 300 \"XC\" 90\n        \t\t\"L\" 50 \"XL\" 40\n        \t\t\"X\" 10 \"XX\" 20 \"XXX\" 30 \"IX\" 9\n        \t\t\"V\" 5 \"IV\" 4\n        \t\t\"I\" 1 \"II\" 2 \"III\" 3}]\n    (->> matches\n         (map values)\n         (reduce +))))", "user": "57aa4775e4b0b8559636fc6b"}, {"problem": 92, "code": "(fn [[h & t]]\n  (let [f {\"I\" 1, \"II\" 2, \"III\" 3, \"IV\" 4, \"V\" 5, \"VI\" 6, \"VII\" 7, \"VIII\" 8, \"IX\" 9, \"X\" 10, \"XX\" 20, \"XXX\" 30, \"XL\" 40, \"L\" 50, \"LX\" 60, \"LXX\" 70, \"LXXX\" 80, \"XC\" 90, \"C\" 100, \"CC\" 200, \"CCC\" 300, \"CD\" 400, \"D\" 500, \"DC\" 600, \"DCC\" 700, \"DCCC\" 800, \"CM\" 900, \"M\" 1000, \"MM\" 2000, \"MMM\" 3000}\n        g {\\I #{\\I \\V \\X}, \\X #{\\X \\L \\C}, \\C #{\\C \\D \\M} \\V #{\\I}, \\L #{\\X}, \\D #{\\C}, \\M #{\\M}}]\n    (loop [r 0, p (str h), [a & b :as s] t]\n      (if (last p)\n          (if ((g (last p)) a)\n              (recur r (str p a) b)\n              (recur (+ r (f p)) (str a) b)) \n           r))))", "user": "548b7db8e4b0e286459a11fd"}, {"problem": 92, "code": "(fn rn [s]\n  (let [m {\"I\" 1\n           \"V\" 5\n           \"X\" 10\n           \"L\" 50\n           \"C\" 100\n           \"D\" 500\n           \"M\" 1000\n           \"4\" 4\n           \"9\" 9\n           \"f\" 40\n           \"n\" 90\n           \"F\" 400\n           \"N\" 900}]\n    (-> s\n        (clojure.string/replace \"IV\" \"4\")\n        (clojure.string/replace \"IX\" \"9\")\n        (clojure.string/replace \"XL\" \"f\")\n        (clojure.string/replace \"XC\" \"n\")\n        (clojure.string/replace \"CD\" \"F\")\n        (clojure.string/replace \"CM\" \"N\")\n        (clojure.string/split #\"\")\n        ((partial remove #{\"\"}))\n        ((partial map m))\n        ((partial apply +)))))", "user": "57a0b341e4b0c3d858beb8d4"}, {"problem": 92, "code": "(fn roman-numeral [s]\n  (let [table {\\I 1 \\V 5\n               \\X 10 \\L 50\n               \\C 100 \\D 500\n               \\M 1000}]\n    (loop [s s ret 0]\n      (if (empty? s) ret\n        (let [x1 (first s)\n              x2 (second s)]\n          (cond (nil? x2)\n                (+ ret (table x1))\n                \n                (< (table x1) (table x2))\n                (recur (next s)\n                       (- ret (table x1)))\n                \n                :else\n                (recur (next s)\n                       (+ ret (table x1)))))))))", "user": "571c2babe4b07c98581c3b73"}, {"problem": 92, "code": "(fn [s]\n  (let [rn {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]\n    (loop [s s n 0 p 0]\n      (if (empty? s)\n        n\n        (let [c (rn (first s))]\n          (if (or (= p 0) (> p c) (= p c))\n            (recur (rest s) (+ n c) c)\n            (recur (rest s) (+ n c (- 0 (* 2 p))) c)))))))", "user": "57d9f603e4b0bd073c20240a"}, {"problem": 92, "code": "(fn [s]\n  (let [sn {\"IV\" 4 \"IX\" 9 \"XL\" 40 \"XC\" 90 \"CD\" 400 \"CM\" 900}\n        cn {\"I\" 1 \"V\" 5 \"X\" 10 \"L\" 50  \"C\" 100 \"D\" 500 \"M\" 1000}]\n    (letfn [\n            (remove-chars [s n]\n              (let [l (.length s)] \n                (.substring s 0 (- l n))))\n            \n            (special-number [s]\n              (if (<= (.length s) 1) \n                nil\n                (let [x (str (last (butlast s)) (last s))]\n                  (sn x))))\n            \n            (common-number [s]\n              (or (cn (str (last s))) 0))\n            \n            (eval-number [s]\n              (if (empty? s)\n                0\n                (let [xs (special-number s)\n                      n (if (nil? xs) 1 2)]\n                  (+ (or xs (common-number s)) (eval-number (remove-chars s n))))))]\n      \n      (eval-number s))))", "user": "57d9bca1e4b0bd073c202405"}, {"problem": 92, "code": "(fn [rn]\n  (let [m {\"I\" 1 \"IV\" 4 \"V\" 5 \"IX\" 9 \"X\" 10\n           \"XL\" 40 \"L\" 50 \"XC\" 90 \"C\" 100\n           \"CD\" 400 \"D\" 500 \"CM\" 900 \"M\" 1000}]\n       (loop [r rn\n              n 0\n              p nil]\n         (if r\n           (let [f (str \"\" (first r))]\n             (if (and p (m (str p f)))\n               (recur (next r) (- (+ n (m (str p f))) (m p)) nil)\n               (recur (next r) (+ n (m f)) f)))\n           n))))", "user": "57d0cd58e4b0bd073c20235e"}, {"problem": 92, "code": "(fn read-from-roman\n   [rom]\n   (let [num-map {\"XX\" 20,\n                  \"III\" 3,\n                  \"MMM\" 3000,\n                  \"XXX\" 30,\n                  \"CD\" 400,\n                  \"XC\" 90,\n                  \"L\" 50,\n                  \"M\" 1000,\n                  \"MM\" 2000,\n                  \"VIII\" 8,\n                  \"CM\" 900,\n                  \"C\" 100,\n                  \"XL\" 40,\n                  \"DC\" 600,\n                  \"CC\" 200,\n                  \"II\" 2,\n                  \"LX\" 60,\n                  \"LXXX\" 80,\n                  \"V\" 5,\n                  \"VII\" 7,\n                  \"CCC\" 300,\n                  \"DCC\" 700,\n                  \"X\" 10,\n                  \"VI\" 6,\n                  \"IX\" 9,\n                  \"I\" 1,\n                  \"DCCC\" 800,\n                  \"LXX\" 70,\n                  \"IV\" 4,\n                  \"D\" 500}\n         rom-bases [\"MMM\" \"MM\" \"M\" \"CM\" \"DCCC\" \"DCC\" \"DC\" \"D\" \"CD\" \"CCC\" \"CC\"\n                    \"C\" \"XC\" \"LXXX\" \"LXX\" \"LX\" \"L\" \"XL\" \"XXX\" \"XX\" \"X\" \"IX\"\n                    \"VIII\" \"VII\" \"VI\" \"V\" \"IV\" \"III\" \"II\" \"I\"]\n         starts-with? (fn [s substr]\n                       (= substr (.substring s 0 (min (count s) (count substr)))))\n         pre (reduce #(if (and (nil? %) (starts-with? rom %2))\n                        %2 %) nil rom-bases)]\n     (if (nil? pre)\n       0\n       (+ (num-map pre) (read-from-roman (.substring rom (count pre)))))))", "user": "56a36f76e4b0542e1f8d14ca"}, {"problem": 92, "code": "#(let [symbols {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}\n       groups (reduce (fn [acc v]\n                        (let [latest (last (last acc))\n                              curr-val (symbols v)]\n                          (if (or (nil? latest) (<= curr-val latest))\n                            (conj acc [curr-val])\n                            (update-in acc [(dec (count acc))] conj curr-val))))\n                      [] %)\n       evaluate (fn [group]\n                  (- (last group) (apply + (butlast group))))]\n   (reduce + (map evaluate groups)))", "user": "5617a540e4b06b1bb2182a12"}, {"problem": 92, "code": "(fn roman\n  [numberseq] \n  (let [table {\\M 1000\n               \\D 500\n               \\C 100\n               \\L 50\n               \\X 10\n               \\V 5\n               \\I 1}]\n    (loop [number (table (first numberseq))\n           numbers (rest numberseq) \n           value 0]\n      (if (empty? numbers)\n        (+ value (if (= nil number) \n                    0 \n                    number))\n        (let [nextValue (table (first numbers))\n              nextIsMore (< number nextValue)]\n          (recur \n            (table (if nextIsMore \n                     (first (rest numbers)) \n                     (first numbers)))\n            (if nextIsMore\n              (rest (rest numbers))\n              (rest numbers))\n            (if nextIsMore\n              (+ value (- nextValue number))\n              (+ value number)))))\n      )))", "user": "57974188e4b039eba2ecb0f4"}, {"problem": 92, "code": "#(first \n  (reduce \n    (fn [[a p] x] \n      [((if (< x p) - +) a x) x]) \n    [0 0] \n    (reverse (map {\\I 1  \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000} %))))", "user": "53b15e6ee4b047364c04448f"}, {"problem": 92, "code": "(fn [roman-numeral]\n  (let [value-map {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]\n    (reduce + (map\n                (fn\n                  [str]\n                  (if (and (> (count str) 1) (< (value-map (first str)) (value-map (second str))))\n                    (- (value-map (second str)) (value-map (first str)))\n                    (reduce + (map #(value-map %) str))))\n                [(first (re-seq #\"M*\" roman-numeral))\n                 (first (re-seq #\"[CD][CDM]*\" roman-numeral))\n                 (first (re-seq #\"[XL][XLC]*\" roman-numeral))\n                 (first (re-seq #\"[IV][IVX]*\" roman-numeral))]))))", "user": "57df309ee4b0bd073c20245f"}, {"problem": 92, "code": "(fn [x] \n  (- \n    (apply + \n      (map \n        {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000} \n        (seq x))) \n    (apply + \n      (map \n        #({\"IV\" 2 \"IX\" 2 \"XL\" 20 \"XC\" 20 \"CD\" 200 \"CM\" 200} % 0) \n        (map #(apply str %) (partition 2 1 x))))))", "user": "57e139f6e4b0bfb2137f5a6c"}, {"problem": 92, "code": "(fn [s]\n    (let\n      [\n        numerals\n        [\n          [\"M\" 1000]\n          [\"CM\" 900]\n          [\"D\" 500]\n          [\"CD\" 400]\n          [\"C\" 100]\n          [\"XC\" 90]\n          [\"L\" 50]\n          [\"XL\" 40]\n          [\"X\" 10]\n          [\"IX\" 9]\n          [\"V\" 5]\n          [\"IV\" 4]\n          [\"I\" 1]\n        ]\n\n        find-numeral\n        (fn [s]\n          (first\n            (filter\n              (fn [n]\n                (not (zero? n))\n              )\n              (map\n                (fn [[numeral-string value]]\n                  (if\n                    (= numeral-string s)\n                    value\n                    0\n                  )\n                )\n                numerals\n              )\n            )\n          )\n        )\n\n        do-parse\n        (fn do-parse [s]\n          (let\n            [\n              first-two (str (first s) (second s))\n              first-one (str (first s))\n\n              value-first-two (find-numeral first-two)\n            ]\n            (cond\n              (empty? s)\n              0\n\n              (not (nil? value-first-two))\n              (+\n                value-first-two\n                (do-parse (nthrest s 2))\n              )\n\n              :else\n              (+\n                (find-numeral first-one)\n                (do-parse (rest s))\n              )\n            )\n          )\n        )\n      ]\n      (do-parse s)\n    )\n  )", "user": "5784e177e4b0ebec4cfb74cf"}, {"problem": 92, "code": "(fn [test]\n  (let [rnv {\\I 1, \\V 5, \\X 10\n             , \\L 50, \\C 100\n             , \\D 500, \\M 1000}]\n    (loop [[r & [rn & _] :as rns] test\n           an 0]\n      (println an r (rnv r) rn)\n      (cond\n        (empty? rns) an\n\n        (nil? rn) (+ an (rnv r))\n\n        (>= (rnv r) (rnv rn))\n        (recur (rest rns) (+ an (rnv r)))\n\n        :default\n        (recur (nthrest rns 2) (+ an (- (rnv rn) (rnv r))))))))", "user": "56f9c7c6e4b07572ad1a88ba"}, {"problem": 92, "code": "(fn [string]\n  ((fn helper [sub-string ans]\n     (if (empty? sub-string)\n       ans\n       (let [sub-2 (if (> (count sub-string) 1) (subs sub-string 0 2) nil)\n             sub-1 (subs sub-string 0 1)]\n         (if (= \"CM\" sub-2)\n           (helper (subs sub-string 2) (+ ans 900))\n           (if (= \"CD\" sub-2)\n             (helper (subs sub-string 2) (+ ans 400))\n             (if (= \"XC\" sub-2)\n               (helper (subs sub-string 2) (+ ans 90))\n               (if (= \"XL\" sub-2)\n                 (helper (subs sub-string 2) (+ ans 40))\n                 (if (= \"IX\" sub-2)\n                   (helper (subs sub-string 2) (+ ans 9))\n                   (if (= \"IV\" sub-2)\n                     (helper (subs sub-string 2) (+ ans 4))\n                     (if (= \"M\" sub-1)\n                       (helper (subs sub-string 1) (+ ans 1000))\n                       (if (= \"D\" sub-1)\n                         (helper (subs sub-string 1) (+ ans 500))\n                         (if (= \"C\" sub-1)\n                           (helper (subs sub-string 1) (+ ans 100))\n                           (if (= \"L\" sub-1)\n                             (helper (subs sub-string 1) (+ ans 50))\n                             (if (= \"X\" sub-1)\n                       \t       (helper (subs sub-string 1) (+ ans 10))\n                               (if (= \"V\" sub-1)\n                                 (helper (subs sub-string 1) (+ ans 5))\n                                 (if (= \"I\" sub-1)\n                                   (helper (subs sub-string 1) (+ ans 1)))))))))))))))))) string 0))", "user": "5746061ae4b009280f9f2b5b"}, {"problem": 92, "code": "(fn [s]\n (letfn [(notation2num [x]\n          (case x\n           \"I\" 1\n           \"IV\" 4\n           \"V\" 5\n           \"IX\" 9\n           \"X\" 10\n           \"XL\" 40\n           \"L\" 50\n           \"XC\" 90\n           \"C\" 100\n           \"CD\" 400\n           \"D\" 500\n           \"CM\" 900\n           \"M\" 1000))]\n  (let [specialNotations (re-seq #\"IV|IX|XL|XC|CD|CM\" s)\n        allNotations (re-seq #\"\\w\" s)\n        specialChars (mapcat #(re-seq #\"\\w\" %) specialNotations)\n        specialNum (reduce #(+ %1 (notation2num %2)) 0 specialNotations)\n        allNum (reduce #(+ %1 (notation2num %2)) 0 allNotations)\n        specialCharNum (reduce #(+ %1 (notation2num %2)) 0 specialChars)]\n    (- (+ specialNum allNum) specialCharNum))))", "user": "57dd47f4e4b0bd073c20243e"}, {"problem": 92, "code": "#(let [dm {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]\n    (loop [n 0 p (dm (first %)) [h & t] (rest %)]\n      (if (nil? h)\n        (+ n p)\n        (let [c (dm h)]\n          (if (and (pos? p) (< p c))\n            (recur (+ n (- c p)) 0 t)\n            (recur (+ n p) c t))))))", "user": "576df252e4b0979f8965156f"}, {"problem": 92, "code": "(fn  [st]\n  (let [digmap { \\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000 }]\n    (loop [st st a 0]\n      (if-let [ch (first st)]\n        (let [cv (get digmap ch)\n              rs (rest st)\n              nx (first rs)\n              sg (if (and\n                       nx\n                       (> (get digmap nx) cv)) -1 1)]\n          (recur rs (+ a (* sg cv))))\n        a))))", "user": "57aa053fe4b0b8559636fc61"}, {"problem": 92, "code": "(fn [r]\n  (loop [m 0\n         sum 0\n         rnum (map #(get {\\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1} %) (reverse r))]\n    (let [e (first rnum)\n          sum (if (> m e) (- sum e) (+ sum e))\n          m (max e m)\n          rnum (rest rnum)]\n      (if (empty? rnum)\n        sum\n        (recur m sum rnum)))))", "user": "57c94c54e4b05aa3c4741d2c"}, {"problem": 92, "code": "(fn [string]\n  (letfn [(value [string1]\n                 (case string1\n                   \"M\" 1000\n                   \"D\" 500\n                   \"C\" 100\n                   \"X\" 10\n                   \"V\" 5\n                   \"I\" 1\n                   0))]\n\n    (loop [s string result 0]\n      (if (zero? (count s))\n        result\n        (if (== 1 (count s))\n          (recur \"\" (+ result (value (subs s 0 1))))\n          (let [c1 (subs s 0 1) c2 (subs s 1 2)]\n            (if (zero? (compare c2 \"L\"))\n              (recur (subs s 2) (+ result (* 4 (value c1))))\n              (if (< (value c1) (value c2))\n                (recur (subs s 1) (- result (value c1)))\n                (recur (subs s 1) (+ result (value c1)))))))))))", "user": "57f52d3be4b0903ccab3dce7"}, {"problem": 92, "code": "(fn [s]\n  (let [bs [[900 \"CM\"] [1000 \"M\"]\n            [400 \"CD\"] [ 500 \"D\"]\n            [ 90 \"XC\"] [ 100 \"C\"]\n            [ 40 \"XL\"] [  50 \"L\"]\n            [  9 \"IX\"] [  10 \"X\"]\n            [  4 \"IV\"] [   5 \"V\"]\n                       [   1 \"I\"]]]\n    (loop [s s\n           v 0]\n      (if (empty? s) v\n          (let [[val str] (some #(when (.startsWith s (second %)) %) bs)]\n            (recur (.substring s (count str)) (+ v val)))))))", "user": "537e745ae4b06839e8705ea6"}, {"problem": 92, "code": "(fn [s]\n  (let [rm (zipmap \"MDCLXVI\" [1000 500 100 50 10 5 1]),\n        m (reverse (map #(apply + %) (partition-by identity (map #(rm %) s))))]\n    (reduce #((if (< %1 %2) + -) %1 %2) m)))", "user": "57f8ba80e4b0d3187e90092f"}, {"problem": 92, "code": "(fn [roms] \n   (let [kv {\\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1}\n         order {\\I 1 \\V 2 \\X 3 \\L 4 \\C 5 \\D 6 \\M 7}] \n     (second (reduce \n       (fn [[pos sum] x]\n         (if (>= (order x) pos)\n           [(order x) (+ sum (kv x))]\n           [pos (- sum (kv x))]))\n       [1 0]\n       (reverse roms)))))", "user": "54236ce1e4b01498b1a71ad1"}, {"problem": 92, "code": "(fn [s]\n  (let [rom-to-dec\n        {\"I\"  1\n         \"IV\" 4\n         \"V\"  5\n         \"IX\" 9\n         \"X\"  10\n         \"XL\" 40\n         \"L\"  50\n         \"XC\" 90\n         \"C\"  100\n         \"CD\" 400\n         \"D\"  500\n         \"CM\" 900\n         \"M\"  1000}]\n    (loop [[x y & chars] (seq s)\n           acc 0]\n      (if (= nil x y)\n        acc\n        (let [x-dec (rom-to-dec (str x))]\n          (if (nil? y)\n            (+ acc x-dec)\n            (let [xy-dec (rom-to-dec (str x y))]\n              (if (and xy-dec\n                       (< x-dec xy-dec))\n                (recur chars\n                       (+ acc xy-dec))\n                (recur (cons y chars)\n                       (+ acc x-dec))))))))))", "user": "57f0f7b8e4b0bfb2137f5bfe"}, {"problem": 92, "code": ";(vec(\n(fn [roman]\n  (reduce \n   (fn [sum [a b]]\n     ((if (< a b) - +) sum a))\n   0  \n   (partition 2 1 (concat (map {\\M 1000 \\D 500  \\C 100 \\L 50 \\X 10 \\V 5 \\I 1} roman) [0]))))\n;\"XLVIII\");)", "user": "573632b7e4b0cd1946bd102f"}, {"problem": 92, "code": "(let [roman-table\n      {\"M\" 1000\n       \"D\"  500\n       \"C\"  100\n       \"L\"   50\n       \"X\"   10\n       \"V\"    5\n       \"I\"    1}]\n  (let [roman-seq\n        (fn [numeral]\n          (map roman-table (map str (into [] numeral))))\n        roman-calc\n        (fn [seq]\n          (second\n           (reduce (fn [[prev accum] next]\n                     (if (> next prev)\n                       [next (- (+ accum next) prev prev)]\n                       [next (+ accum next)]))\n                   [1000 0]\n                   seq)))]\n    (fn read-roman-numeral\n      [numeral]\n      (roman-calc (roman-seq numeral)))))", "user": "58152157e4b0f478707a0631"}, {"problem": 92, "code": "(fn rome [R]\n  (let [s (vec (map str (seq R)))\n        nR (zipmap [\"M\" \"D\" \"C\" \"L\" \"X\" \"V\" \"I\"] [1000 500 100 50 10 5 1])\n        ih (first s)\n        ij (nR ih)]\n    (loop [j ij h ih i 1]\n      (if (= i (count s))\n             j\n             (recur (if (<= (nR (s i)) (nR h))\n                        (+ j (nR (s i))) (- (+ j (nR (s i))) (* 2 (nR h))))\n                    (s i)\n                    (inc i))))))", "user": "564d3169e4b0284900eef67c"}, {"problem": 92, "code": "(fn r [a]\n  (let [[x & w] (seq a)\n        [y & z] w\n        n {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}\n        s (n x)\n        t (n y)]\n    (cond\n     (nil? x) 0\n     (nil? y) s\n     (< s t) (+ (r z) (- t s))\n     :else (+ (r w) s))))", "user": "5742ec91e4b05c31a32c0883"}, {"problem": 92, "code": "(fn [n] (->> n\n            (map (zipmap \"IVXLCDM\" [1 5 10 50 100 500 1000]))\n            (partition 2 1 [0])\n        \t(map (fn [[a b]] (if (< a b) (- a) a)))\n         \t(apply +)\n))", "user": "5603c31fe4b04bb52996e1c1"}, {"problem": 92, "code": "(fn rom [str]\n  (let [lookup (clojure.set/map-invert\n                (apply hash-map\n                 (concat\n                  '(1 \"I\" 2 \"II\" 3 \"III\" 4 \"IV\" 5 \"V\" 6 \"VI\" 7 \"VII\" 8 \"VIII\" 9 \"IX\")\n                  '(10 \"X\" 20 \"XX\" 30 \"XXX\" 40 \"XL\" 50 \"L\" 60 \"LX\" 70 \"LXX\" 80 \"LXXX\" 90 \"XC\")\n                  '(100 \"C\" 200 \"CC\" 300 \"CCC\" 400 \"CD\" 500 \"D\" 600 \"DC\" 700 \"DCC\" 800 \"DCCC\" 900 \"CM\")\n                  '(1000 \"M\" 2000 \"MM\" 3000 \"MMM\" 4000 \"MMMM\" 5000 \"MMMMM\" 6000 \"MMMMMM\" 7000 \"MMMMMMM\" 8000 \"MMMMMMMM\" 9000 \"MMMMMMMMM\"))))\n        nums (reverse (sort-by count (keys lookup)))]\n    (loop [rem str total 0]\n      (let [first-rom-num (first (filter #(.contains rem %) nums))\n            value (+ total (lookup first-rom-num))\n            next-rem (clojure.string/replace rem first-rom-num \"\")]\n\n        (if (empty? next-rem)\n          value\n          (recur next-rem value)\n        )))))", "user": "56069006e4b08b23635d3174"}, {"problem": 92, "code": "(fn [in] \n  (let \n   [nmbrs\n    (conj (mapv #({\\M 1000, \\D 500, \\C 100, \\L 50,\n                   \\X 10,   \\V 5,   \\I 1} %) in) -1)]\n   ((reduce\n    (fn [{:keys [res prev] :as x} nxt]\n      (assoc x :res \n             (+ res (if (< prev nxt)\n                      (* -1 prev)\n                      prev))\n             :prev nxt))\n   {:res 0 :prev (first nmbrs)}\n   (rest nmbrs)) :res))\n )", "user": "5835cb06e4b089d5ab817cea"}, {"problem": 92, "code": "(fn rom [ss]\n (let \n  [romdic (sorted-map \\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000)\n   vrb (map romdic (seq ss))\n   rdc-f \n    (fn [[z a] b]\n     (if (nil? a)\n      [z b]\n      (if (< a b) \n       [(+ z (- b a)) nil]\n       [(+ z a) b])))\n   [zz aa] (reduce rdc-f \n                   [0 nil] \n                   vrb)\n   rslt (if (nil? aa) \n         zz \n         (+ zz aa))]\n rslt))", "user": "57f9011ee4b0d3187e900935"}, {"problem": 92, "code": "(fn parse-numerals [num-str]\n  (let [numerals  {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}\n        ;; \"XIV\" ==> 5 1 10\n        numbers   (map numerals (reverse num-str))\n        ;; (5 1 10) ==> ((5 1) (1 10)) \n        num-pairs (partition 2 1 numbers)\n        initial   (first numbers)]\n    (reduce (fn [acc n]\n              ;; The second number is either added or subtracted to the running\n              ;; total. See \"subtractive principle\"\n              (if (<= (first n) (second n))\n                (+ acc (second n))\n                (- acc (second n))))\n            initial\n            num-pairs)))", "user": "58327a08e4b089d5ab817c7c"}, {"problem": 92, "code": "#(let [m1 {\"IV\" 4 \"IX\" 9 \"XL\" 40 \"XC\" 90 \"CD\" 400 \"CM\" 900}\n       m2 {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]\n   (loop [s % sum 0]\n     (if (seq s)\n       (if-let [x (m1 (apply str (take 2 s)))]\n         (recur (drop 2 s) (+ sum x))\n         (recur (rest s) (+ sum (m2 (first s)))))\n       sum)))", "user": "583e27e2e4b089d5ab817daa"}, {"problem": 92, "code": "(fn roman-numeral->int [rn]\n  (let [values   [1 4 5 9 10 40 50 90 100 400 500 900 1000]\n        numerals [\"I\" \"IV\" \"V\" \"IX\" \"X\" \"XL\" \"L\" \"XC\" \"C\" \"CD\" \"D\" \"CM\" \"M\"]\n        vm (zipmap numerals values)\n        n-numerals (map #(vm (str %)) (into [] rn))]\n    (first (reduce \n      (fn [[acc pv] v]\n        (if (< pv v)\n          [(+ (- acc pv) (- v pv)) v]\n          [(+ acc v) v]))\n      [0 9000]\n      n-numerals))))", "user": "57c0917be4b05aa3c4741c95"}, {"problem": 92, "code": "(fn [s]\n    (let [roman {\"M\" 1000\n                 \"CM\" 900\n                 \"D\"  500\n                 \"CD\" 400\n                 \"C\"  100\n                 \"XC\"  90\n                 \"L\"   50\n                 \"XL\"  40\n                 \"X\"   10\n                 \"IX\"   9\n                 \"V\"    5\n                 \"IV\"   4\n                 \"I\"    1}]\n      (reduce +\n              (map roman\n                   (re-seq #\"CM|CD|XC|XL|IX|IV|[MDCLXVI]\" s)))))", "user": "55c5b55fe4b0e31453f649b5"}, {"problem": 92, "code": "(fn [c]\n  (let [numerals {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]\n    (first (reduce #(let [[sum last] %\n                          f (if (< %2 last) - +)]\n                              [(f sum %2) %2]) [0 0] (reverse (map #(get numerals %) c))))))", "user": "565b2fa5e4b068f2fe63dbfe"}, {"problem": 92, "code": "(fn [x](let \n[m (zipmap \"MDCLXVI\" [1000 500 100 50 10 5 1])]\n(->>\n(str x \"I\")\n(map m)\n(partition 2 1)\n(map #(if (> (second %) (first %))\n(- 0 (first %))\n(first %)))\n(apply +))))", "user": "5849ac5fe4b089d5ab817ed7"}, {"problem": 92, "code": "(let [char-vals {\\M 1000, \\D 500, \\C 100, \\L 50, \\X 10, \\V 5, \\I 1}]\n  (fn [s] ((fn [s highest acc] (if (empty? s) acc\n                                 (let [v (char-vals (first s))]\n                                   (recur (rest s) (max v highest) ((if (< v highest) - +) acc v)))))\n             (reverse s) 0 0)))", "user": "584dadebe4b0b7285a6f4e44"}, {"problem": 92, "code": "(fn [r-str]\n  (let [r-combos \n          [[\"I\" \"II\" \"III\" \"IV\" \"V\" \"VI\" \"VII\" \"VIII\" \"IX\"]\n           [\"X\" \"XX\" \"XXX\" \"XL\" \"L\" \"LX\" \"LXX\" \"LXXX\" \"XC\"]         \n           [\"C\" \"CC\" \"CCC\" \"CD\" \"D\" \"DC\" \"DCC\" \"DCCC\" \"CM\"]\n           [\"M\" \"MM\" \"MMM\"]]\n        process-numeral\n          (fn [order num-str]\n            (let [r-comb (.indexOf (r-combos order) num-str)]\n              (if (= r-comb -1) 0 (* (inc r-comb) (int (Math/pow 10 order))))))\n        re-res\n          (re-find #\"^(M{0,3})(C[DM]|D?C{0,3})(X[LC]|L?X{0,3})(I[VX]|V?I{0,3})\" r-str)\n        ]\n    (reduce + (map process-numeral [3 2 1 0] (rest re-res)))))", "user": "5627444fe4b00e49c7cb47cd"}, {"problem": 92, "code": "(fn [x]\n  (loop [res 0\n         s-x (seq x)]\n    (if (empty? s-x)\n      res\n      (let [fst-char (apply str (take 1 s-x))\n            fst-2-chars (apply str (take 2 s-x))]\n        (cond\n         (= fst-char \"M\") (recur (+ res 1000) (drop 1 s-x))\n         (= fst-2-chars \"CM\") (recur (+ res 900) (drop 2 s-x))\n         (= fst-char \"D\") (recur (+ res 500) (drop 1 s-x))\n         (= fst-2-chars \"CD\") (recur (+ res 400) (drop 2 s-x))\n         (= fst-char \"C\") (recur (+ res 100) (drop 1 s-x))\n         (= fst-2-chars \"XC\") (recur (+ res 90) (drop 2 s-x))\n         (= fst-char \"L\") (recur (+ res 50) (drop 1 s-x))\n         (= fst-2-chars \"XL\") (recur (+ res 40) (drop 2 s-x))\n         (= fst-char \"X\") (recur (+ res 10) (drop 1 s-x))\n         (= fst-2-chars \"IX\") (recur (+ res 9) (drop 2 s-x))\n         (= fst-char \"V\") (recur (+ res 5) (drop 1 s-x))\n         (= fst-2-chars \"IV\") (recur (+ res 4) (drop 2 s-x))\n         (= fst-char \"I\") (recur (+ res 1) (drop 1 s-x)))))))", "user": "585e2e77e4b0f14aab7c87ac"}, {"problem": 92, "code": "(fn [string]\n  (letfn [(roman-char-to-digit [c]\n            (cond (= c \\I) 1\n                  (= c \\V) 5\n                  (= c \\X) 10\n                  (= c \\L) 50\n                  (= c \\C) 100\n                  (= c \\D) 500\n                  (= c \\M) 1000\n                  :else 0))]\n    (loop [list (seq string)\n           result 0]\n      (if (empty? list)\n        result\n        (recur (rest list)\n               (+ result \n                  (let [current (roman-char-to-digit (first list))]\n                    (if (or (empty? (rest list))\n                            (>= current\n                               (roman-char-to-digit (first (rest list)))))\n                      current\n                      (- 0 current)))))))))", "user": "58637f03e4b0f14aab7c881e"}, {"problem": 92, "code": "(fn read-roman \n  ([xs] (read-roman xs 0))\n  ([[x y & z] result]\n   (let [values {\\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1}]\n     (cond\n      (nil? x) result\n      (nil? y) (+ result (values x))\n      (>= (values x) (values y)) (read-roman (cons y z) (+ result (values x)))\n      (< (values x) (values y)) (read-roman z (+ result (- (values y) (values x))))\n     )\n  ))\n)", "user": "55357ab5e4b09218d5f44faf"}, {"problem": 92, "code": "(fn roman [s]\n  (letfn [(r->i [a b]\n            (let  [r {\\I 1 \\V 5  \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]\n              (cond \n                (not b) (get r a)\n                (< (get r a) (get r b)) (- (get r a))\n                :else (get r a))))]\n   (reduce + (map (partial apply r->i) (partition 2 1 [\\I] s)))))", "user": "566ff0a1e4b0a866af6896ec"}, {"problem": 92, "code": "(fn [x]\n    (let [values {\\I 1 \\V 5 \\X 10 \\L 50 \\M 1000 \\C 100 \\D 500}]\n      (loop [number x\n             CurrentMax \\I\n             sum 0]\n        (if (not (empty? number))\n          (if (= (get values CurrentMax) (get values (last number)))\n            (recur (butlast number) CurrentMax (+ sum (get values (last number))))\n            (if (> (get values (last number)) (get values CurrentMax))\n              (recur (butlast number) (last number) (+ sum (get values (last number))))\n              (recur (butlast number) CurrentMax (- sum (get values (last number))))))\n          sum))))", "user": "586afe7be4b0f14aab7c88ca"}, {"problem": 92, "code": "(fn [x]\n  (let [table (array-map \"M\" 1000 \"CM\" 900\n                         \"D\"  500 \"CD\" 400 \n                         \"C\"  100 \"XC\"  90 \n                         \"L\"   50 \"XL\"  40 \n                         \"X\"   10 \"IX\"   9\n                         \"V\"    5 \"IV\"   4\n                         \"I\"    1)\n        pattern (->> (keys table)\n                     (interpose \"|\")\n                     (apply str)\n                     re-pattern)]\n    (->> x\n         (re-seq pattern)\n         (map table)\n         (reduce +))))", "user": "58247423e4b051871117bec5"}, {"problem": 92, "code": "(fn [w]\n  (let [m (zipmap \"IVXLCDM\" [1 5 10 50 100 500 1000])\n        n (map #(* (count %) (m (first %))) (partition-by identity w))]\n    (apply + (reduce #(if (< (last %) %2)\n                         (assoc % (dec (count %)) (- %2 (last %)))\n                         (conj % %2)) [(first n)] (rest n)))))", "user": "56b6e354e4b0982f16b37e41"}, {"problem": 92, "code": "#(reduce (fn [a b] (if (> a (* 3 b)) (- a b) (+ b a))) (map (zipmap [\"I\" \"V\" \"X\" \"L\" \"C\" \"D\" \"M\"] [1 5 10 50 100 500 1000]) (reverse (re-seq #\"\\w\" %))))", "user": "586b6a0ae4b01531a375e957"}, {"problem": 92, "code": "(fn read-roman-numerals [rn]\n  (let [numerals {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000}\n        pairs (partition 2 1 (concat (map numerals rn) [0]))]\n    (reduce (fn [acc [a b]] ((if (>= a b) + -) acc a)) 0 pairs)))", "user": "5879d577e4b01531a375ead8"}, {"problem": 92, "code": "(fn [x] (letfn [(romantonumber [y] (case y\n                                   \\I 1\n                                   \\V 5\n                                   \\X 10\n                                   \\L 50\n                                   \\C 100\n                                   \\D 500\n                                   \\M 1000\n                                   0))]\n  (let [y (reverse (map romantonumber (seq x)))]\n    (:s (reduce #( if (< %2 (%1 :l) )\n                      {:s (- (%1 :s) %2) :l %2}\n                      {:s (+ (%1 :s) %2) :l %2}\n                      ) {:s 0 :l 0} y)))))", "user": "57dafe97e4b0bd073c20241c"}, {"problem": 92, "code": "(fn [s]\n  (let [nummap {\\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1 }\n       effectiv-val (fn [[n1 n2]] (if (< n1 n2) (- n1) n1))]\n    (->> s\n         (map nummap)\n         (into [])\n         (#(conj % 0))\n         (partition 2 1)\n         (map effectiv-val)\n         (reduce +))))", "user": "501d34f6e4b066e56b9d0b1e"}, {"problem": 92, "code": "(fn [in] \n   (loop [s (map {\\X 10 \\I 1 \\V 5 \\L 50 \\C 100 \\D 500 \\M 1000} (seq in))          \n          r 0]\n     (if (empty? s) \n       r\n       (let [c (first s) s (rest s) n (if (empty? s) 0 (first s))]\n         (recur s (if (< c n) (- r c) (+ r c) ))))\n     )\n   )", "user": "587c59d1e4b01531a375eb17"}, {"problem": 92, "code": "(letfn [(zip-next [xs]\n         (map vector xs (rest xs)))\n        (rules [ltr nxt]  \n          (cond\n            (and (= ltr \\I) (contains? #{\\V \\X} nxt)) -1\n            (and (= ltr \\X) (contains? #{\\L \\C} nxt)) -10\n            (and (= ltr \\C) (contains? #{\\D \\M} nxt)) -100\n            :else ({\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000} ltr)))] \n  (fn [ls]\n    (reduce + (rules (last ls) nil) \n              (map (partial apply rules) (zip-next ls)))))", "user": "5884e807e4b0f1effa3b76a6"}, {"problem": 92, "code": "(let [doubles {[\\I \\V] 4, [\\I \\X] 9, [\\X \\L] 40, [\\X \\C] 90, [\\C \\D] 400, [\\C \\M] 900}\n      singles {[\\I] 1, [\\V] 5, [\\X] 10, [\\L] 50, [\\C] 100, [\\D] 500, [\\M] 1000}]\n  (fn [roman]\n    (when-not (clojure.string/blank? roman)\n      (loop [[a b & r] roman\n             acc 0]\n        (if-let [dval (doubles [a b])]\n          (let [acc (+ acc dval)]\n            (if (seq r)\n              (recur r acc)\n              acc))\n          (let [sval (singles [a])\n                acc (+ acc sval)]\n            (if b\n              (recur (cons b r) acc)\n              acc)))))))", "user": "54d341f7e4b0e8a36923e603"}, {"problem": 92, "code": "(fn [s] \n\t(let [m {\\M 1000 \"CM\" -100 \\D 500 \"CD\" -100 \\C 100 \"XC\" -10 \\L 50 \"XL\" -10 \\X 10 \"IX\" -1 \\V 5 \"IV\" -1 \\I 1}\n\t\t  f #(apply str %)\n\t\t  g #(or (m %) (m (first %)))]\n\t\t(reduce + (map g (map f (partition-all 2 1 s))))\n))", "user": "580c8fcee4b0849f6811b721"}, {"problem": 92, "code": "(fn [roman-num]\n        (let [literals [[#\"^M\" 1000] [#\"^CM\" 900] [#\"^CD\" 400] [#\"^D\" 500] [#\"^C\" 100] [#\"^XC\" 90] [#\"^XL\" 40] [#\"^L\" 50] [#\"^X\" 10] [#\"^IX\" 9] [#\"^IV\" 4] [#\"^V\" 5] [#\"^I\" 1]]\n              find-literal (fn [s roman-literals]\n                             (some (fn [[x n]] (if (re-find x s) [x n])) roman-literals))]\n          (loop [s roman-num result 0]\n          (if (= 0 (count s))\n            result\n            (let [[re n] (find-literal s literals)\n                  _ (println \"re=\" re)\n                  remain (clojure.string/replace s re \"\")\n                  result (+ result n)]\n              (recur remain result))))))", "user": "58949f8de4b00487982d525e"}, {"problem": 92, "code": "(fn [s]\n  (->\n   s\n   (clojure.string/replace #\"IV\" \"IIII\")\n   (clojure.string/replace #\"IX\" \"VIIII\")\n   (clojure.string/replace #\"XL\" \"XXXX\")\n   (clojure.string/replace #\"XC\" \"LXXXX\")\n   (clojure.string/replace #\"CD\" \"CCCC\")\n   (clojure.string/replace #\"CM\" \"DCCCC\")\n   ((partial reduce #(cond\n                      (= \\I %2) (+ %1 1)\n                      (= \\V %2) (+ %1 5)\n                      (= \\X %2) (+ %1 10)\n                      (= \\L %2) (+ %1 50)\n                      (= \\C %2) (+ %1 100)\n                      (= \\D %2) (+ %1 500)\n                      (= \\M %2) (+ %1 1000)\n                      :else %1)\n             0)))\n  )", "user": "586615e6e4b0f14aab7c8858"}, {"problem": 92, "code": "(fn unroman [s]\n  (let [tr {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]\n        (cond\n          (empty? s) 0\n          (= (count s) 1) (tr (first s))\n          true (let [d0 (tr (first s))\n                     d1 (tr (second s))]\n                 (if (< d0 d1)\n                   (- (unroman (rest s)) d0)\n                   (+ (unroman (rest s)) d0))))))", "user": "58a0fc33e4b02bd94d917ea3"}, {"problem": 92, "code": "(fn read-roman [roman-nums]\n  (let [assign-val\n        (fn [roman-num]\n           (case roman-num\n             \"I\" 1\n             \"V\" 5\n             \"X\" 10\n             \"L\" 50\n             \"C\" 100\n             \"D\" 500\n             \"M\" 1000))\n        values (for [m (partition-all 2 1 roman-nums)]\n                 (map #(assign-val (str %))m))\n        cmp? (fn [[x y]] (cond\n                          (nil? y) x\n                          (< x y) (- x)\n                          :else x))]\n    (apply + (map cmp? values))\n    ;; values\n    ))", "user": "505d1b01e4b0e6aca564be04"}, {"problem": 92, "code": "(fn [n]\n  (let [vs {\\I 1, \\V 5, \\X 10, \\L 50\n            \\C 100, \\D 500, \\M 1000}\n        nums (map vs n)]\n    (->> nums\n         (reduce\n          (fn [[tot sub curr] x]\n            (cond\n             (< curr x) [(- tot sub) x x]\n             (> curr x) [(+ tot sub) x x]\n             (= curr x) [tot (+ sub x) x]))\n          [0 0 (first nums)])\n         (take 2)\n         (apply +))))", "user": "54d9f7f1e4b024c67c0cf751"}, {"problem": 92, "code": "(fn [s]\n  (let [values {:I 1 :V 5 :X 10 :L 50 :C 100 :D 500 :M 1000}\n        sub {:IV 4 :IX 9 :XL 40 :XC 90 :CD 400 :CM 900}]\n    (loop [n (reverse s) tot 0]\n      (if (= (count n) 0) tot\n        (let [pair (sub (keyword (apply str (reverse (take 2 n)))))]\n          (if (nil? pair)\n            (recur (drop 1 n) (+ (values (-> (first n) (str) (keyword))) tot))\n            (recur (drop 2 n) (+ pair tot))))))))", "user": "58983e3fe4b00487982d52ce"}, {"problem": 92, "code": "(let [roman (fn f\n               ([n]\n                (f n \"\"))\n               ([n s]\n                (let [ss [\"I\" \"IV\" \"V\" \"IX\" \"X\" \"XL\" \"L\" \"XC\" \"C\" \"CD\" \"D\" \"CM\" \"M\"]\n                      dd [1 4 5 9 10 40 50 90 100 400 500 900 1000]\n                      zz (zipmap dd ss)]\n                  (if (zero? n)\n                    s\n                    (let [x (last (take-while #(<= % n) dd))]\n                      (f (- n x) (str s (zz x))))))))\n       rr    (range 0 4000)\n       zz    (zipmap (map roman rr) rr)]\n   (fn [s]\n     (zz s)))", "user": "500d3160e4b05f7c30cfa6a1"}, {"problem": 92, "code": "(fn [x]\n  (let [m {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}\n        x (seq x)]\n       (loop [acc 0\n              ch (first x)\n              x (next x)]\n         (if (nil? x)\n             (+ acc (m ch))\n             (recur (let [a (m ch)\n                          b (m (first x))]\n                         ((if (> b a) - +) acc a))\n                    (first x)\n                    (next x))))))", "user": "55f73078e4b06e875b46cea4"}, {"problem": 92, "code": "(fn roman-numerals [chars]\n\t(let [char-values {\\I 1,\\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000}\n\t\t  evaluate (fn evaluate [chars values numbers]\n\t\t\t  (if (nil? chars)\n\t\t\t\t  (reduce + numbers)\n\t\t\t\t  (let [[f s & rest] chars]\n\t\t\t\t\t  (cond (nil? s) (evaluate nil values (conj numbers (values f)))\n\t\t\t\t\t\t\t(and (= f \\I) (= \\V s)) (evaluate rest values (conj numbers 4))\n\t\t\t\t\t\t\t(and (= f \\I) (= \\X s)) (evaluate rest values (conj numbers 9))\n\t\t\t\t\t\t\t(and (= f \\X) (= \\L s)) (evaluate rest values (conj numbers 40))\n\t\t\t\t\t\t\t(and (= f \\X) (= \\C s)) (evaluate rest values (conj numbers 90))\n\t\t\t\t\t\t\t(and (= f \\C) (= \\D s)) (evaluate rest values (conj numbers 400))\n\t\t\t\t\t\t\t(and (= f \\C) (= \\M s)) (evaluate rest values (conj numbers 900))\n\t\t\t\t\t\t\t:else (evaluate (conj rest s) values (conj numbers (values f)))\n\t\t\t\t\t\t\t)\n\t\t\t\t\t  )))]\n\t\t(evaluate (seq chars) char-values [])))", "user": "525d44bfe4b0cb4875a45d6d"}, {"problem": 92, "code": "(fn read-roman [r]\n  (let [value-map {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000}\n        nums (map value-map r)]\n    (first (reduce (fn [[sum prev op] new-val]\n                     (cond (> new-val prev) [(+ sum new-val) new-val +]\n                           (< new-val prev) [(- sum new-val) new-val -]\n                           :else [(op sum new-val) new-val op])\n                     ) [0 0 +] (reverse nums)))\n    )\n  )", "user": "589037b4e4b00487982d51d0"}, {"problem": 92, "code": "(fn [s] (let [\n               lookup {\"I\" 1 \"V\" 5 \"X\" 10 \"L\" 50 \"C\" 100 \"D\" 500 \"M\" 1000}\n               sliced (into [] (map str (seq s)))\n               numbers (map #(get lookup %1) sliced)\n               ]\n           (reduce\n             (fn [p e] (let [\n                             v0 (nth numbers e)\n                             i-right (min (inc e) (dec (count numbers)))\n                             v1 (nth numbers i-right)\n                             vinc (if (< v0 v1) (* -1 v0) v0)\n                             ]\n                         (+ p vinc)))\n             0 (range (count numbers)))))", "user": "58a9e872e4b01a0c0b232973"}, {"problem": 92, "code": "#(let [roman-num (zipmap [\"I\" \"V\" \"X\" \"L\" \"C\" \"D\" \"M\" \"IV\" \"IX\" \"XL\" \"XC\" \"CD\" \"CM\"]\n                         [1 5 10 50 100 500 1000 4 9 40 90 400 900])]\n   (apply +\n          (map roman-num\n               (re-seq #\"CM|CD|XC|XL|IX|IV|[MDCLXVI]\" %))))", "user": "58a2b57fe4b02bd94d917ede"}, {"problem": 92, "code": "(let [M {\\I [   1 #{\\V \\X}]\n         \\V [   5 #{}]\n         \\X [  10 #{\\L \\C}]\n         \\L [  50 #{}]\n         \\C [ 100 #{\\D \\M}]\n         \\D [ 500 #{}]\n         \\M [1000 #{}]}\n      V (zipmap (keys M) (map first  (vals M)))\n      S (zipmap (keys M) (map second (vals M)))]\n  (fn [s]\n    (->> s\n      (partition-all 2 1)\n      (map (fn [[p n]] ((if ((S p) n) - +) (V p))))\n      (reduce + 0))))", "user": "50479524e4b0371827a27bc4"}, {"problem": 92, "code": "(fn [s]\n  (let [symbols {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}\n          sub-symbols #{[\\I \\V] [\\I \\X] [\\X \\L] [\\X \\C] [\\C \\D] [\\C \\M]}\n          sum (reduce + (map symbols s))\n          subtract (reduce + (map (comp symbols first) (filter sub-symbols (partition 2 1 s))))]\n      (- sum (* 2 subtract))))", "user": "58ca8a1de4b03c36ff7e5835"}, {"problem": 92, "code": "(fn roman-to-arabic [n]\n  (let [roman {\\I   1\n               \\V   5\n               \\X   10\n               \\L   50\n               \\C   100\n               \\D   500\n               \\M   1000}\n        rks (sort (keys roman))]\n    (loop [n n\n           r 0]\n      (if (empty? n)\n        r\n        (let [x (get roman (last n))\n              n (drop-last n)\n              y (get roman (last n))]\n          (if (or (nil? y) (>= y x))\n            (recur n (+ r x))\n            (recur (drop-last n) (+ r (- x y)))))))))", "user": "58bb218be4b0888cdc949cf4"}, {"problem": 92, "code": "(fn [s]\n  (let [numerals {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000}\n        neg-if-less (fn [[a b]] (if (< a b) (- a) a))\n        digits (map neg-if-less (partition 2 1 (conj (mapv numerals s) 0)))]\n    (apply + digits)))", "user": "58923efce4b00487982d521c"}, {"problem": 92, "code": "(fn [numeral]\n  (let [numerals {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000}\n        counter (fn [l r total] (if (>= l r) (+ total l) (- total l)))]\n    (loop [total 0 prev 0 remaining (clojure.string/reverse numeral)]\n      (if-let [current-numeral (first remaining)]\n        (let [current (numerals current-numeral)\n              new-total (counter current prev total)]\n          (recur new-total current (rest remaining)))\n        total))))", "user": "57625c18e4b0994c1922fba4"}, {"problem": 92, "code": "#(let [order {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000 nil 0}\n       fold (fn fold [[x & [y & tail :as y-tail] :as col]]\n              (let [xo (order x) yo (order y)]\n                (cond (empty? col) nil\n                      (< xo yo) (cons (- yo xo) (fold tail))\n                      :else (cons xo (fold y-tail)))))]\n   (apply + (fold (seq %))))", "user": "567d132ee4b05957ce8c61c3"}, {"problem": 92, "code": "(fn  [ input ]\n  (letfn [(value-of [x] ({ \\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000} x))\n          (translate [a]\n            (cond\n              (= 1 (count a)) (value-of (first  a))\n              :else (if (> (value-of  (first a)) (value-of  (second a) ))\n                      (- (value-of (first  a)) (value-of (second a)))\n                      (+ (value-of (first  a)) (value-of (second a))))))]\n          (apply + (map \n            (fn [item]\n              (translate (filter (complement (fn [y] (= \\P y)))  item)))  \n            (partition 2 2 [\\P]  (reverse input))))))", "user": "5832be57e4b089d5ab817c86"}, {"problem": 92, "code": "(fn [roman-number]\n  (letfn\n    [(convert-digit [digit]\n       (case digit\n         \\I 1 \n         \\V 5\n         \\X 10\n         \\L 50\n         \\C 100\n         \\D 500\n         \\M 1000))\n     (partition-between \n       ;\"Copied from https://gist.github.com/davidminor/769758\n       ;Splits coll into a lazy sequence of lists, with partition \n       ;boundaries between items where (f item1 item2) is true.\n       ;(partition-between = '(1 2 2 3 4 4 4 5)) =>\n       ;((1 2) (2 3 4) (4) (4 5))\"\n       [f coll]\n       (lazy-seq\n         (when-let [s (seq coll)]\n           (let [fst (first s)]\n             (if-let [rest-seq (next s)]\n               (if (f fst (first rest-seq))\n                 (cons (list fst) (partition-between f rest-seq))\n                 (let [rest-part (partition-between f rest-seq)]\n                   (cons (cons fst (first rest-part)) (rest rest-part))))\n               (list (list fst)))))))\n     (roman-subtract [roman-number]\n       (if\n         (> 2\n            (count roman-number))\n         (first roman-number)\n         (apply - (reverse roman-number))))\n     (roman-convert [roman-number]\n       (reduce\n         +\n         (map\n           roman-subtract\n           (partition-between >= (map convert-digit roman-number)))))]\n    (roman-convert roman-number)))", "user": "586a657de4b0f14aab7c88bd"}, {"problem": 92, "code": "(fn parse-roman-numeral [string]\n  (let [numerals-map {\\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1}\n        num-pairs (partition 2 1 (concat (map numerals-map string) '(0)))]\n    (letfn [(accum-num-pair [sum [a b]]\n              (if (>= a b)\n                (+ sum a)\n                (- sum a)))]\n      (reduce accum-num-pair 0 num-pairs))))", "user": "58ed713de4b056aecfd47d84"}, {"problem": 92, "code": "(fn [s]\n  (let [conversion {\\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1}]\n    (loop [total 0\n           [a b & more] s]\n      (let [con-a (conversion a)\n            con-b (conversion b)]\n        (cond\n          (and a b (> con-b con-a)) (recur (+ total (- con-b con-a)) more)\n          a                         (recur (+ total con-a) (cons b more))\n          :else                     total)))))", "user": "55ea0780e4b0121d4835fda7"}, {"problem": 92, "code": "(fn parse-roman-numeral\n  ([string] (parse-roman-numeral\n             (clojure.string/upper-case string)\n             0))\n\n  ([string acc]\n   (letfn [(parse-or [parse-a parse-b]\n             (fn [string]\n               (let [[r1 s2] (parse-a string)]\n                 (if (= s2 string)\n                   (parse-b s2)\n                   [r1 s2]))))\n           (parse-two-digits [string]\n             (if (< (count string) 2) [0 string]\n                 (let [result (case (subs string 0 2)\n                                \"IV\" 4\n                                \"IX\" 9\n                                \"XL\" 40\n                                \"XC\" 90\n                                \"CD\" 400\n                                \"CM\" 900\n                                0)]\n                   [result (if (zero? result) string (subs string 2))])))\n           (parse-digit [string]\n             (if (< (count string) 1) [0 \"\"]\n                 (let [result (case (subs string 0 1)\n                                \"I\" 1\n                                \"V\" 5\n                                \"X\" 10\n                                \"L\" 50\n                                \"C\" 100\n                                \"D\" 500\n                                \"M\" 1000\n                                0)]\n                   [result (if (zero? result) string (subs string 1))])))\n           (parse [string] ((parse-or parse-two-digits parse-digit) string))]\n     (if (empty? string)\n       acc\n       (let [[r s] (parse string)]\n         (recur s (+ r acc)))))))", "user": "55fbc657e4b0f488688e0666"}, {"problem": 92, "code": "(fn read-roman-numerals [n]\n   (letfn [(numeral-to-letter [x rnum letter]\n             (clojure.string/replace x rnum letter))]\n     (let [numeral-and-letters (numeral-to-letter\n                                 (numeral-to-letter\n                                   (numeral-to-letter\n                                     (numeral-to-letter\n                                       (numeral-to-letter \n                                         (numeral-to-letter n \"IV\" \"a\")\n                                         \"IX\" \"b\")\n                                       \"XL\" \"c\")\n                                     \"XC\" \"d\")\n                                   \"CD\" \"e\")\n                                 \"CM\" \"f\")\n           converter {\\I 1, \\a 4, \\V 5, \\b 9, \\X 10, \\c 40 \\L 50,\n                      \\d 90, \\C 100, \\e 400, \\D 500, \\f 900, \\M 1000}]\n       (reduce + (map #(get converter %) numeral-and-letters)))))", "user": "58dcb8cde4b0a4d5acaab6a7"}, {"problem": 92, "code": "(fn [rn]\n  (let [roman-nums {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000}\n        roman-num-func #(%1 (get roman-nums %2) (get roman-nums %3))\n        larger-by #(quot (get roman-nums %1) (get roman-nums %2))\n        larger-num-later? (fn [n ns] (some #(roman-num-func > % n) ns))\n        power-of-ten? #(some #{%} #{\\I \\X \\C})\n\n        minuend-10x-larger-or-less? (fn [n min]\n                                      (or (nil? min) (<= (larger-by min n) 10)))\n\n        any-preceding-num-10x-larger-or-more?\n        (fn [n preceding]\n          (or (empty? preceding)\n              (some #(>= (larger-by % n) 10) preceding)))\n\n        any-following-smaller-than-sub?\n        (fn [n following-min]\n          (or (empty? following-min)\n              (some #(roman-num-func < % n) following-min)))\n\n        prepare-data\n        (fn [s]\n          (loop [i 0\n                 acc []]\n            (if (= i (count s))\n              acc\n              (recur (inc i)\n                     (conj acc (hash-map :before (subs s 0 i)\n                                         :n (first (subs s i (inc i)))\n                                         :after (subs s (inc i))))))))\n\n        subtract?\n        (fn [{:keys [n before after]}]\n          (let [minuend (first after)]\n            (and (larger-num-later? n after)\n                 (power-of-ten? n)\n                 (minuend-10x-larger-or-less? n minuend)\n                 (any-preceding-num-10x-larger-or-more? n before)\n                 (any-following-smaller-than-sub? n (rest after)))))\n\n        get-value\n        (fn [{n :n :as data}]\n          (let [value (get roman-nums n)]\n            (if (subtract? data)\n              (* -1 value)\n              value)))\n        \n        data (prepare-data rn)\n        values (map get-value data)]\n    \n    (reduce + values)))", "user": "56ff45e5e4b08d47c97781bb"}, {"problem": 92, "code": ";; i need to clean this up....cause it's crazy...actually i am not even sure it's right\n(fn romans [xs]\n  (let [\n        symbols {\"I\"  1 \"V\" 5 \"X\" 10 \"L\" 50 \"C\" 100 \"D\" 500 \"M\" 1000}\n        nums (into {} (map-indexed vector xs))              ;; don't need indexes, i dont think\n        rom (map (fn [x] (get symbols (str(val x)))) nums)  ;; this is the numbers the letters represent\n        ]\n\n    (letfn [(calc [ss acc]\n\n              (if (= 1 (count ss))\n                (+ (first ss) acc)\n                (cond\n                  (>= (first ss) (second ss))\n                  (recur\n                    (rest ss)\n                    (+ acc (first ss))\n                    )\n                  :else\n                  (if (= 2 (count ss))\n                    (+ acc\n                       (-\n                         (second ss)\n                         (first ss)))\n                    (recur\n                      (rest (rest ss))\n                      (+ acc\n                         (-\n                           (second ss)\n                           (first ss)))\n                    )\n                  )\n                )))]\n      (calc rom 0))))", "user": "58eed4c5e4b056aecfd47db7"}, {"problem": 92, "code": "(fn\n  [rns]\n  (let\n    [vs (map { \\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000} rns)\n     r-max ((fn\n              [values]\n              (reduce (fn [a b] (conj a (max (first a) b))) (list (last values)) (reverse (drop-last values))))\n            vs)]\n    (reduce + (map #(if (>= %1 %2) %1 (- %1)) vs r-max))))", "user": "5796d3ebe4b039eba2ecb0ee"}, {"problem": 92, "code": "(fn [roman-numeral]\n  (let [number-seq (map\n                    (fn [letter]\n                      (let [letter-number-map {\\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1}]\n                        (letter-number-map letter)))\n                    (vec roman-numeral))\n        number-count (count number-seq)\n        adjusted-number-seq (map-indexed\n                             (fn [idx val]\n                               (cond\n                                 (= (+ idx 1) number-count) val\n                                 (< val (nth number-seq (+ idx 1))) (- val)\n                                 :else val))\n                             number-seq)]\n    (reduce + adjusted-number-seq)))", "user": "564c8e99e4b0284900eef674"}, {"problem": 92, "code": "(fn read-roman [s]\n  (let [numerals {\\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1}\n        nums (partition 2 1 (concat (map numerals s) [0]))]\n    (reduce (fn [sum [a b]] ((if (< a b) - +) sum a)) 0 nums)))", "user": "53dbca12e4b094d41abdfef6"}, {"problem": 92, "code": "(let [rval {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]\n    (fn rom->dec [rom]\n      (let [subseqs (take-while (complement nil?) (iterate next (map rval rom)))]\n        (reduce + (for [[h & t] subseqs]\n                    (if (seq (filter #(> % h) t)) (* -1 h) h))))))", "user": "58ec1e63e4b056aecfd47d54"}, {"problem": 92, "code": "(fn [roman-numeral]\n  (let [value-map {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]\n    (reduce + (map\n                (fn\n                  [str]\n                  (if (and (> (count str) 1) (< (value-map (first str)) (value-map (second str))))\n                    (- (value-map (second str)) (value-map (first str)))\n                    (reduce + (map #(value-map %) str))))\n                [(first (re-seq #\"M*\" roman-numeral))\n                 (first (re-seq #\"[CD][CDM]*\" roman-numeral))\n                 (first (re-seq #\"[XL][XLC]*\" roman-numeral))\n                 (first (re-seq #\"[IV][IVX]*\" roman-numeral))]))))", "user": "58f45ea0e4b0438e51c2cebc"}, {"problem": 92, "code": "(fn roman-to-decimal [roman-str]\n  (let [r->d {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000}]\n    (loop [str roman-str, prev 0, output 0]\n      (if-let [curr (r->d (first str))]\n        (if (< prev curr)\n          (recur (rest str) curr (+' (-' output prev) (-' curr prev)))\n          (recur (rest str) curr (+' output curr)))\n        output))))", "user": "57ee804ee4b0bfb2137f5bbb"}, {"problem": 92, "code": "(fn [roman-str]\n   (let [str-2-num (fn str-2-num [ch]\n                     (cond\n                       (= \\I ch) 1\n                       (= \\V ch) 5\n                       (= \\X ch) 10\n                       (= \\L ch) 50\n                       (= \\C ch) 100\n                       (= \\D ch) 500\n                       (= \\M ch) 1000\n                       :else 0))\n         nums (map str-2-num roman-str)\n         factor (reduce (fn [res [a b]]\n                          (if (< a b)\n                            (- res a)\n                            (+ res a))) 0 (map vector nums (rest nums)))]\n\n     (+ factor (last nums))))", "user": "591072e0e4b0163c97b36ebc"}, {"problem": 92, "code": "(fn [s]\n    (let [m {\"I\" 1 \"V\" 5 \"X\" 10 \"L\" 50 \"C\" 100 \"D\" 500 \"M\" 1000}\n          m2 {\"IV\" 4 \"IX\" 9 \"XL\" 40 \"XC\" 90 \"CD\" 400 \"CM\" 900}\n          n (apply + (map (fn [[k v]] (if (re-find (re-pattern k) s) v 0)) m2))\n          s2 (reduce #(clojure.string/replace %1 (key %2) \"\") s m2)\n          n2 (apply + (map #(m (str %)) s2))\n          ]\n      (+ n n2)\n      )\n    )", "user": "5921a080e4b09b4ee5954c77"}, {"problem": 92, "code": "(fn [r] \n  (let [terms {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000}]\n    (loop [acc 0, [x y & xs :as s] (seq r)]\n      (cond (empty? s) acc\n            (nil? y) (+ acc (terms x))\n            (< (terms x) (terms y)) (recur (+ acc (- (terms x)) (terms y)) xs)\n            :else (recur (+ acc (terms x)) (rest s))))))", "user": "5566d812e4b0c656e3ff1837"}, {"problem": 92, "code": "(fn roman [n]\n  (letfn [(value [c]\n                 (case c\n                       \\I 1\n                       \\V 5\n                       \\X 10\n                       \\L 50\n                       \\C 100\n                       \\D 500\n                       \\M 1000))] \n  (first (reduce\n    (fn [[sum prev] d]\n        [(+ sum\n            (if (> (value d) (value prev))\n              (- (value d) (value prev) (value prev))\n              (value d)))\n          d])\n    [0 \\M]\n    n))))", "user": "5901158de4b0438e51c2d039"}, {"problem": 92, "code": "(fn [roman]\n   (let [m {:I 1, :V 5, :X 10, :L 50, :C 100, :D 500, :M 1000}]\n     (letfn [(convert [v] (get m (keyword (str v))))]\n       (let [firstVal (convert (last roman))]\n         (first\n          (reduce \n           (fn [[total last] next] \n             (let [n (convert next)]\n               (if (<= last n) \n                 [(+ total n) n]\n                 [(- total n) n])))\n           [firstVal firstVal] \n           (rest (reverse roman))))))))", "user": "58d27bcae4b03c36ff7e58fe"}, {"problem": 92, "code": "(fn [s]\n  (loop [tmps (rest (clojure.string/split s #\"\")) t 0]\n    (if (empty? tmps)\n      t\n      (if (and (= \"C\" (first tmps)) (= \"D\" (second tmps)))\n        (recur (rest (rest tmps)) (+ t 400))\n        (if (and (= \"X\" (first tmps)) (= \"C\" (second tmps)))\n          (recur (rest (rest tmps)) (+ t 90))\n          (if (and (= \"X\" (first tmps)) (= \"L\" (second tmps)))\n            (recur (rest (rest tmps)) (+ t 40))\n            (if (and (= \"I\" (first tmps)) (= \"X\" (second tmps)))\n              (recur (rest (rest tmps)) (+ t 9))\n              (if (and (= \"I\" (first tmps)) (= \"V\" (second tmps)))\n                (recur (rest (rest tmps)) (+ t 4))\n                (if (and (= \"C\" (first tmps)) (= \"M\" (second tmps)))\n                  (recur (rest (rest tmps)) (+ t 900))\n                  (recur (rest tmps) (+ t (get {\"I\" 1, \"V\" 5, \"X\" 10, \"L\" 50, \"C\" 100, \"D\" 500, \"M\" 1000} (first tmps)))))))))))))", "user": "59368ccae4b02506e01a297a"}, {"problem": 92, "code": "(fn read-numeral\n  [numeral-string]\n  (let [token-value\n        {\"I\" 1\n         \"V\" 5\n         \"X\" 10\n         \"L\" 50\n         \"C\" 100\n         \"D\" 500\n         \"M\" 1000}\n        token-seq (->> numeral-string (map str) (partition-all 2 1))]\n    (reduce\n     (fn [sum [token lookahead]]\n       (let [t-value (get token-value token)\n             l-value (get token-value lookahead 0)]\n         (if (> l-value t-value)\n           (- sum t-value)\n           (+ sum t-value))))\n     0\n     token-seq)))", "user": "53de7484e4b0d874e779ae35"}, {"problem": 92, "code": "(fn roman [s]\n   (let [to-int {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000}]\n     (->> (concat (map to-int s) [0])\n          (partition 2 1)\n          (map (fn [[a b]] (if (< a b) (- a) a)))\n          (reduce +))))", "user": "5935b010e4b04f87174def55"}, {"problem": 92, "code": "(fn proman [s]\n  (let [digit\n        (fn [c]\n          (case c\n            \\I 1\n            \\V 5\n            \\X 10\n            \\L 50\n            \\C 100\n            \\D 500\n            \\M 1000))\n        addup\n        (fn addup [p c]\n          (if-let [s (seq c)]\n            (if (< (first s) p)\n              (recur (- p (first s)) (rest s))\n              (+ p (addup (first s) (rest s))))\n            p))]\n    (addup 0 (->> s (reverse) (map digit)))))", "user": "5953bdb6e4b066ee0a44aeed"}, {"problem": 92, "code": "(fn [rn]\n  (let [ds (->> (map {\\I 1\n                      \\V 5\n                      \\X 10\n                      \\L 50\n                      \\C 100\n                      \\D 500\n                      \\M 1000}\n                     rn)\n                 reverse)\n        signs (cons 1\n                    (map (fn [curr prev]\n                           (if (< curr prev) -1 1))\n                         (rest ds)\n                          ds))]\n     (reduce + (map * ds signs))))", "user": "580bd81ee4b0849f6811b711"}, {"problem": 92, "code": "#(reduce + (map (fn [[b a]] (if (< a b) (- a) a)) (partition 2 1 (cons 0 (map {\\M 1000\n                                                        \\D 500\n                                                        \\C 100\n                                                        \\L 50\n                                                        \\X 10\n                                                        \\V 5\n                                                        \\I 1\n                                                        } (reverse %))))))", "user": "595b7c12e4b066ee0a44afda"}, {"problem": 92, "code": "(fn latin\n     ([s] (latin 0 s))\n     ([n s]\n       (if (empty? s) n\n       (let [data [[\"M\" 1000] [\"CM\" 900] [\"D\" 500] [\"C\" 100] [\"XC\" 90] [\"XL\" 40] [\"X\" 10] [\"IX\" 9] [\"IV\" 4] [\"V\" 5] [\"I\" 1]]\n             [[prefix delta]] (filter #(re-find (re-pattern (str \"^\" (first %))) s) data)]\n         (recur (+ n delta) (subs s (count prefix)))))))", "user": "4fc4eb1ee4b081705acca354"}, {"problem": 92, "code": "(fn rom-to-num \n  ([[a & rstr] res] \n    (let [roms-map {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}          \n          b (first rstr) na (get roms-map a) nb (get roms-map b)] \n      (if (empty? rstr) (+ res na) (if (> nb na) (rom-to-num rstr (- res na))\n        (rom-to-num rstr (+ res na))))))\n  ([rstr] (rom-to-num rstr 0)))", "user": "575ddfd1e4b02ea11479938d"}, {"problem": 92, "code": "(fn rn [r]\n  (let [rnm [{\"MMMM\" 4 \"MMM\" 3 \"MM\" 2 \"M\" 1}\n            {\"CM\" 9 \"DCCC\" 8 \"DCC\" 7 \"DC\" 6 \"D\" 5 \"CD\" 4 \"CCC\" 3 \"CC\" 2 \"C\" 1}\n            {\"XC\" 9 \"LXXX\" 8 \"LXX\" 7 \"LX\" 6 \"L\" 5 \"XL\" 4 \"XXX\" 3 \"XX\" 2 \"X\" 1}\n            {\"IX\" 9 \"VIII\" 8 \"VII\" 7 \"VI\" 6 \"V\" 5 \"IV\" 4 \"III\" 3 \"II\" 2 \"I\" 1}]]\n          \n      (loop [r r i 0 out 0]\n            (if (< i 4)\n                (let [cm (get rnm i)\n                      matches (filter #(.startsWith r %) (keys cm))\n                      lm (if (empty? matches) \"\" (apply max-key count matches))]\n                    (recur (subs r (count lm)) (inc i) (+ out (* (get cm lm 0) (Math/pow 10 (- 3 i))))))\n                (int out)))))", "user": "5958cef6e4b066ee0a44af94"}, {"problem": 92, "code": "#(let [m {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000}]\n  (first (reduce (fn [[acc prev] curr]\n                   (if (< prev curr)\n                     [(+ acc curr (* -2 prev)) curr]\n                     [(+ acc curr) curr]))\n                 [0 1000]\n                 (map (partial get m) %))))", "user": "595fd721e4b066ee0a44b06e"}, {"problem": 92, "code": "#(let [Ro1 {\"I\" 1, \"V\" 5, \"X\" 10, \"L\" 50, \"C\" 100, \"D\" 500, \"M\" 1000}\n       Ro2 {\"IV\" 4, \"IX\" 9, \"XL\" 40, \"XC\" 90, \"CD\" 400, \"CM\" 900}]\n(apply +\n  ((fn [ret, ss]\n    (cond\n      (empty? ss)\n          ret\n      (and (< 1 (count ss)) (Ro2 (subs ss 0 2)))\n          (recur (conj ret (Ro2 (subs ss 0 2))) (subs ss 2))\n      :else\n          (recur (conj ret (Ro1 (subs ss 0 1))) (subs ss 1))))\n   [], %)))", "user": "593f95d8e4b069cdc2982be3"}, {"problem": 92, "code": "(fn [roman]\n            (let [vals {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]\n                 (loop [r 0 c roman]\n                       (if (empty? c)\n                         r\n                         (let [fv (get vals (first c))\n                               sv (if (next c) (get vals (second c)) 0)\n                               rc (if (< fv sv) (drop 2 c) (rest c))]\n                              (recur (if (< fv sv) (+ r (- sv fv)) (+ r fv)) rc)))))\n            )", "user": "58987ee9e4b00487982d52d2"}, {"problem": 92, "code": "(fn rn [s]\n  (let [syms {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}\n        sub-syms {(seq \"IV\") 4 (seq \"IX\") 9 (seq \"XL\") 40 (seq \"XC\") 90 (seq \"CD\") 400 (seq \"CM\") 900}]\n    (if (empty? s)\n      0\n      (let [next-sub-sym-token-value (get sub-syms (take 2 s))]\n        (if next-sub-sym-token-value\n          (+ next-sub-sym-token-value (rn (rest (rest s))))\n          (+ (get syms  (first s)) (rn (rest s))))))))", "user": "590b055ae4b047aa04b199c9"}, {"problem": 92, "code": "(fn __ [x]\n  (let [\n        x1 (clojure.string/replace x #\"IV\" \"IIII\")\n        x2 (clojure.string/replace x1 #\"IX\" \"IIIIIIIII\")\n        x3 (clojure.string/replace x2 #\"XL\" \"XXXX\")\n        x4 (clojure.string/replace x3 #\"XC\" \"XXXXXXXXX\")\n        x5 (clojure.string/replace x4 #\"CD\" \"CCCC\")\n        x6 (clojure.string/replace x5 #\"CM\" \"CCCCCCCCC\")\n        mp {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000}\n        ]\n    (reduce + (map mp (seq x6)))))", "user": "58bc6a88e4b0888cdc949d16"}, {"problem": 92, "code": "#(reduce + (map (fn [[x y]] (if y (if (>= x y) x (- x)) x)) (partition-all 2 1 (map {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000} %))))", "user": "4fb1d7ace4b081705acca281"}, {"problem": 92, "code": "(fn [r](\n          letfn [\n                 (rn[n] (get {\"X\" 10 \"I\" 1 \"V\" 5 \"M\" 1000 \"C\" 100 \"L\" 50 \"D\" 500} n))\n                 (fa[rx val lv] (\n                              if (empty? rx) val\n                              (\n                                #(if (< % lv)\n                                     (fa (rest rx) (- val %) %)\n                                     (fa (rest rx) (+ val %) %)\n                                     ) (rn (str (first rx)))\n                                )\n                              ))\n                  \n                  ]\n          (fa (reverse r) 0 0)\n          ))", "user": "596f6683e4b069c0a1a19877"}, {"problem": 92, "code": "(fn write-roman [s]\n  (let [match {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]\n    (loop [s (reverse s)\n           acc []]\n      (if (empty? s)\n        (loop [acc acc\n               prev 0\n               res []]\n          (if (empty? acc)\n            (apply + res)\n            (recur\n             (rest acc)\n             (first acc)\n             (conj\n              res\n              (if (>= (first acc) prev)\n                (first acc)\n                (- (first acc)))))))\n        (recur (rest s) (conj acc (match (first s))))))))", "user": "587ee260e4b052da650a6353"}, {"problem": 92, "code": "(fn [s]\n  (let\n   [sub-add\n    {\"CM\" \"DCCCC\"\n     \"CD\" \"CCCC\"\n     \"XC\" \"LXXXX\"\n     \"XL\" \"XXXX\"\n     \"IX\" \"VIIII\"\n     \"IV\" \"IIII\"}\n    char-val\n    {\\M 1000\n     \\D 500\n     \\C 100\n     \\L 50\n     \\X 10\n     \\V 5\n     \\I 1}]\n   (reduce\n    #(+ %1 (char-val %2))\n    0\n    (reduce\n     #(clojure.string/replace\n       %1 (%2 0) (%2 1))\n     s sub-add))))", "user": "598ab445e4b02b9968b84ce0"}, {"problem": 92, "code": "(fn roman-to-alg [roman]\n  (let [dic {\"M\" 1000, \n            \"D\" 500,     \n            \"C\" 100, \n            \"L\" 50, \n            \"X\" 10, \n            \"V\" 5, \n            \"I\" 1}\n        t #(get dic %)\n        v (clojure.string/split roman #\"\")\n        roman-sum (fn [[r & tail] previous total] \n                    (if (nil? r)\n                      (if (nil? previous)\n                        total\n                        (+ total previous))\n                      (let [value (or (t r) 0)]\n                        (if (> value previous)\n                            (recur tail value (- total previous))\n                            (recur tail value (+ total previous))))))]\n    (roman-sum v 0 0)))", "user": "5989e080e4b021a7a535fed6"}, {"problem": 92, "code": "(fn [w]\n        (let [literals\n              { \\I 1 \n                \\V 5 \n                \\X 10 \n                \\L 50 \n                \\C 100 \n                \\D 500 \n                \\M 1000 }\n      \n              lit2int\n              (fn [lit]\n                (if (nil? lit) 0 (literals lit)))\n              \n              aux\n              (fn [[head & tail] res tmp last]\n                ;; (prn head tail res tmp last)\n                (cond\n                 (nil? head)\n                 (+ res tmp)\n                 \n                 (<= (lit2int head) (lit2int last))\n                 (recur tail (+ res tmp) (lit2int head) head)\n                 \n                 :else\n                 (recur tail res (- (lit2int head) tmp) head)))]\n          (aux w 0 0 nil))\n        )", "user": "57e6f90de4b0bfb2137f5af6"}, {"problem": 92, "code": "(let [lookup {[\\I] 1,[\\I \\V] 4,[\\V] 5,[\\I \\X] 9,[\\X] 10,[\\X \\L] 40,[\\L] 50,\n              [\\X \\C] 90,[\\C] 100,[\\C \\D] 400,[\\D] 500,[\\C \\M] 900,[\\M] 1000}]\n  #(loop [converted 0 roman %]\n    (if (empty? roman)\n      converted    \n      (let [characters (take 2 roman)]\n        (if (= 1 (count characters))\n          (recur (+ converted (get lookup characters)) (rest roman))\n          (if-let [value (get lookup characters nil)]\n            (recur (+ converted value) (drop 2 roman))\n            (recur (+ converted (get lookup [(first characters)])) (rest roman))\n          )\n        )\n      )\n    )\n  )\n)", "user": "5991d2fae4b0866487ed0d68"}, {"problem": 92, "code": "(fn roman-step [s] \n   (let [[d1 d2 & ds] s\n         dd (str d1 d2)\n         m1 {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}\n         m2 {\"IV\" 4 \"IX\" 9 \"XL\" 40  \"XC\" 90 \"CD\" 400 \"CM\" 900}]\n     (print \"s:\" s \"d1: \" d1 \"d2: \" d2 \"ds:\" ds \"dd: \" dd \"\\n\")\n     (if (empty? dd) 0\n         (if (contains? m2 dd) \n             (+ (m2 dd) (roman-step ds))\n             (+ (m1 d1) (roman-step (cons d2 ds)))))))", "user": "56fa2905e4b07572ad1a88be"}, {"problem": 92, "code": "; Evil hack\n(fn [& _]\n  (reify Object\n    clojure.lang.IPersistentCollection\n    (seq [_])\n    (cons [_ _])\n    (empty [_])\n    (equiv [_ _] true)))", "user": "51e58e02e4b0efabf93c02d0"}, {"problem": 92, "code": "(fn f\n    ([i] (f 0 0 (reverse (seq i))))\n    ([sum one xs]\n     (let [rn {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}\n           two (get rn (first xs))\n           ]\n       (cond\n         (nil? one) sum\n         (nil? two) (+ sum one)\n         (< two one) (recur (+ sum (- one two)) (get rn (second xs)) (drop 2 xs))\n         :else (recur (+ sum one) two (rest xs)))\n       )))", "user": "596d630ae4b069c0a1a19846"}, {"problem": 92, "code": "#(let [vs {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000 nil 0}]\n    (loop [ns %\n           sum 0]\n      (let [num (get vs (first ns))\n            nnum (get vs (second ns))]\n        (if (empty? ns)\n          sum\n          (if (>= num nnum)\n            (recur (rest ns) (+ sum num))\n            (recur (drop 2 ns) (+ sum (- nnum num))))))))", "user": "52540bcce4b0541d1855b952"}, {"problem": 92, "code": "(fn\n  [t]\n  (let [v {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000}]\n    (letfn [(d [t p n]\n              (if (empty? t)\n                n\n                (let [c (v (first t))]\n                  (if (> c p)\n                    (d (rest t) c (+ n (* -2 p) c))\n                    (d (rest t) c (+ n c))))))]\n      (d t 0 0))))", "user": "5893c64ce4b00487982d524b"}, {"problem": 92, "code": "(fn read-roman\n\t([s]\n\t\t(read-roman s 0))\n\t([s n]\n\t\t(let [f re-find\n\t\t\t\tr clojure.string/replace-first]\n\t\t\t(cond \n\t\t\t\t(f #\"IV\" s) (read-roman (r s #\"IV\" \"\") (+ n 4))\n\t\t\t\t(f #\"IX\" s) (read-roman (r s #\"IX\" \"\") (+ n 9))\n\t\t\t\t(f #\"XL\" s) (read-roman (r s #\"XL\" \"\") (+ n 40))\n\t\t\t\t(f #\"XC\" s) (read-roman (r s #\"XC\" \"\") (+ n 90))\n\t\t\t\t(f #\"CD\" s) (read-roman (r s #\"CD\" \"\") (+ n 400))\n\t\t\t\t(f #\"CM\" s) (read-roman (r s #\"CM\" \"\") (+ n 900))\n\t\t\t\t(f #\"I\" s) (read-roman (r s #\"I\" \"\") (+ n 1))\n\t\t\t\t(f #\"V\" s) (read-roman (r s #\"V\" \"\") (+ n 5))\n\t\t\t\t(f #\"X\" s) (read-roman (r s #\"X\" \"\") (+ n 10))\n\t\t\t\t(f #\"L\" s) (read-roman (r s #\"L\" \"\") (+ n 50))\n\t\t\t\t(f #\"C\" s) (read-roman (r s #\"C\" \"\") (+ n 100))\n\t\t\t\t(f #\"D\" s) (read-roman (r s #\"D\" \"\") (+ n 500))\n\t\t\t\t(f #\"M\" s) (read-roman (r s #\"M\" \"\") (+ n 1000))\n\t\t\t\t:else n))))", "user": "5954eef0e4b066ee0a44af17"}, {"problem": 92, "code": "(fn [s]\n  (letfn [(read-roman-thousands [sr]\n            (if-let [thousands (re-find #\"^M+\" sr)]\n              [(* 1000 (count thousands)) (subs sr (count thousands))]\n              [0 sr]\n            )\n          )\n          (read-hundreds [[prev sr]]\n            (loop [hundreds 0 s sr]\n              (cond\n                (empty? s) [(+ (* hundreds 100) prev) s]\n                (= (first s) \\C) (recur (inc hundreds) (rest s))\n                (= (first s) \\D) (recur (if (= hundreds 1) 4 5) (rest s))\n                (= (first s) \\M) (recur 9 (rest s))\n                :else [(+ (* hundreds 100) prev) (apply str s)]\n              )\n            )\n          )\n          (read-tens [[prev sr]]\n            (loop [tens 0 s sr]\n              (cond\n                (empty? s) [(+ (* tens 10) prev) s]\n                (= (first s) \\X) (recur (inc tens) (rest s))\n                (= (first s) \\L) (recur (if (= tens 1) 4 5) (rest s))\n                (= (first s) \\C) (recur 9 (rest s))\n                :else [(+ (* tens 10) prev) (apply str s)]\n              )\n            )\n          )\n          (read-units [[prev sr]]\n            (loop [units 0 s sr]\n              (cond\n                (empty? s) (+ units prev)\n                (= (first s) \\I) (recur (inc units) (rest s))\n                (= (first s) \\V) (recur (if (= units 1) 4 5) (rest s))\n                (= (first s) \\X) (recur 9 (rest s))\n                :else (+ units prev)\n              )\n            )\n          )     \n          ]\n    (->> s read-roman-thousands read-hundreds read-tens read-units)\n  )\n)", "user": "59a0262ee4b0871e7608b82d"}, {"problem": 92, "code": "(fn read-roman [s] (let [numerals {\\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1} nums (partition 2 1 (concat (map numerals s) [0]))] (reduce (fn [sum [a b]] ((if (< a b) - +) sum a)) 0 nums)))", "user": "59358f74e4b04f87174def52"}, {"problem": 92, "code": "(fn [x]\n   (let [m {\\I 1 \\V 5 \\X 10\n            \\L 50 \\C 100 \\D 500\n            \\M 1000}]\n     (->> (reverse x)\n          (map m)\n          (reduce #(let [amount (first %)\n                         last (second %)\n                         this %2]\n                     (if last\n                       (if (> last this)\n                         [(- amount this) this]\n                         [(+ amount this) this])\n                       [this this]))\n                  [0])\n          (first))))", "user": "58db3c5ae4b0a4d5acaab677"}, {"problem": 92, "code": "(fn roman2dec [s]\n  (letfn [(token2num [t] (- (first t) (apply + (rest t)))) ]\n    (let [l (map {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000} s)]\n      (loop [l l token (list) sum 0]\n        (if (not-empty l)\n          (if (empty? token)\n            (recur (rest l) (cons (first l) token) sum)\n            (if (<= (first l) (first token))\n              (recur (rest l) (list (first l)) (+ sum (token2num token)))\n              (recur (rest l) (cons (first l) token) sum)\n              )\n            )\n          (+ sum (token2num token))\n          )\n        )\n      )\n    )\n  )", "user": "562add6de4b00e49c7cb4834"}, {"problem": 92, "code": "(let [rom {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]\n  (fn [s]\n    (loop [[x & [y & _ :as more] :as digits] (seq s) n 0]\n      (if (seq digits)\n        (if (and y (> (rom y) (rom x)))\n          (recur more (- n (rom x)))\n          (recur more (+ n (rom x))))\n        n))))", "user": "59eb63e3e4b0249b7282077c"}, {"problem": 92, "code": "(fn [s]\n    (let [d       {\\M 1000\n                   \\D 500\n                   \\C 100\n                   \\L 50\n                   \\X 10\n                   \\V 5\n                   \\I 1}\n          [f & r] (map #(get d %) (seq s))]\n      (->> (reduce (fn [memo e]\n                     (if (< (first memo) e)\n                       (conj (rest memo) (- e (first memo)))\n                       (conj memo e)))\n                   (list f)\n                   r)\n           (reduce +))))", "user": "59fa241ee4b0ca45a743a358"}, {"problem": 92, "code": "(fn\n  [rn]\n  (let [dc {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]\n    (->> rn \n         reverse \n         (map dc) \n         (partition-by identity)\n         (map (partial apply +))\n         (reduce #((if (> %1 %2) - +) %1 %2)))))", "user": "59f91b99e4b0ca45a743a33a"}, {"problem": 92, "code": "(fn [numeral]\n  (let [numerals {\\I 1\n               \\V 5\n               \\X 10\n               \\L 50\n               \\C 100\n               \\D 500\n               \\M 1000}\n        inverse? (fn [m n]\n  \t\t\t \t  (< m n))\n        parse (fn parse [numeral]\n  \t\t\t\t(reduce #(conj %1 (get numerals %2)) [] (seq numeral)))\n        parsed (parse numeral)]\n    (loop [acc 0\n         front (first parsed)\n         next (first (drop 1 parsed))\n         rst (rest (drop 1 parsed))]\n    (if next\n      (recur\n        (if (inverse? front next)\n          (- acc front)\n          (+ acc front))\n        next\n        (first rst)\n        (rest rst))\n      (if front\n        (+ acc front)\n        acc)))))", "user": "580a0783e4b0a837a8b30d2c"}, {"problem": 92, "code": "(fn [ys] \n  (letfn [(romtab [] {\\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1})\n          (rom [res xs]\n     (let [len (count xs)] \n     (cond (> len 1)\n              (let [x1 (first xs) x2 (second xs)]\n                  (if (< ((romtab) x1) ((romtab) x2))\n                         (recur (- (+ res ((romtab) x2)) \n                                   ((romtab) x1) ) (rest (rest xs)) )\n                         (recur (+ res ((romtab) x1)) (rest xs) )\n                  )\n             )  \n            (= len 1)\n                (+ res ((romtab) (first xs)) )        \n            :else res\n     )\n   )\n   )]\n    (rom 0 ys)\n  )\n)", "user": "59ff9424e4b01bb0ae8afd24"}, {"problem": 92, "code": "(fn [rn]\n   (let [sign (fn [pair]\n                (case pair\n                  ([\\I \\V] [\\I \\X]\n                   [\\X \\L] [\\X \\C]\n                   [\\C \\D] [\\C \\M]) -\n                  +))\n         digit (fn [c]\n                 (case c\n                   \\I 1\n                   \\V 5\n                   \\X 10\n                   \\L 50\n                   \\C 100\n                   \\D 500\n                   \\M 1000\n                   0))]\n     (apply + (map (fn [p] ((sign p) (digit (first p)))) (partition 2 1 nil rn)))))", "user": "5a250b86e4b07f18be40aa19"}, {"problem": 92, "code": "(fn [s]\n    (let [m {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}\n          n (vec (map m s))]\n      (apply + (map\n                 (fn [i]\n                   (if\n                     (or\n                       (= (inc i) (count n))\n                       (>= (nth n i) (nth n (inc i))))\n                     (nth n i)\n                     (- (nth n i))))\n                 (range (count n))))))", "user": "5a2df4a0e4b09cafd31c7f74"}, {"problem": 92, "code": "(fn __ [in]\n  (->> in\n       (map {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000})\n       (reduce\n        (fn [acc x]\n          (let [lacc (last acc)]\n            (if (> x lacc)\n              (conj acc (- x lacc lacc))\n              (conj acc x))))\n        [0])\n       (apply +)))", "user": "55916764e4b0604b3f94d57b"}, {"problem": 92, "code": "(fn [s]\n  (if (empty? s)\n    0\n    (let [to_decimal {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}\n          rev_s (reverse s)]\n      (loop [x (get to_decimal (first rev_s))\n             xs (rest rev_s)\n             p 0\n             v p]\n        (if (empty? xs)\n          (if (>= x p)\n            (+ v x)\n            (- v x))\n          (if (>= x p)\n            (recur (get to_decimal (first xs)) (rest xs) x (+ v x))\n            (recur (get to_decimal (first xs)) (rest xs) x (- v x))))))))", "user": "5a34f342e4b0ddc586f153d1"}, {"problem": 92, "code": "(fn [s]\n  (let [nums [[\"M\" 1000] [\"CM\" 900] [\"D\" 500] [\"CD\" 400] [\"C\" 100] [\"XC\" 90] [\"L\" 50] [\"XL\" 40] [\"X\" 10] [\"IX\" 9] [\"V\" 5] [\"IV\" 4] [\"I\" 1]]]\n    (loop [n 0 r s]\n      (if (empty? r) \n        n\n        (let [[a b] (first (filter #(re-find (re-pattern (str \"^\" (first %) \".*\")) r) nums))]\n          (recur (+ n b) (subs r (count a))))))))", "user": "58f44c07e4b0438e51c2ceb7"}, {"problem": 92, "code": "(fn read-roman\n  [str]\n  (let [dict {\\I 1\n              \\V 5\n              \\X 10\n              \\L 50\n              \\C 100\n              \\D 500\n              \\M 1000}]\n    (loop [num 0\n           processing (map dict str)]\n      (println \"num \" num)\n      (println \"processing \" processing)\n      (cond\n        (empty? processing) num\n\n        (= 1 (count processing)) (+ num (first processing))\n\n        :else\n        (let [n1 (first processing)\n              n2 (second processing)]\n          (println \"delta \" (- n2 n1))\n          (case (- n2 n1)\n            (4 9 40 90 400 900) (recur (+ num (- n2 n1)) (drop 2 processing))\n\n            (recur (+ num n1) (next processing))))))))", "user": "549eb44fe4b0f3d1d8e70fa6"}, {"problem": 92, "code": "(fn read-roman [s]\n  (let [values {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000}]\n    (loop [total 0\n           [letter & rest] s\n           prev 0]\n      (if-not letter\n        total\n        (let [val (get values letter)]\n          (recur (+ total val (if (< prev val) (* -2 prev) 0))\n                rest\n                val))))))", "user": "5a54e3c4e4b05d388ecb6c30"}, {"problem": 92, "code": "(fn [s] \n    (let [rr (fn [o f t] (concat (take 3 (iterate #(str % o) o)) [(str o f)] (take 4 (iterate #(str % o) f)) [(str o t)]))\n          ds (fn [d] (iterate #(+ % d) d))\n          rs (sort-by #(- (second %)) \n                      (concat (map (fn [x y] [x y]) (rr \"I\" \"V\" \"X\") (ds 1))\n                              (map (fn [x y] [x y]) (rr \"X\" \"L\" \"C\") (ds 10))\n                              (map (fn [x y] [x y]) (rr \"C\" \"D\" \"M\") (ds 100))\n                              (map (fn [x y] [x y]) (rr \"M\" \"?\" \"?\") (ds 1000))))\n          starts-with? (fn [s ss] (and (>= (count s) (count ss)) (= ss (subs s 0 (count ss)))))\n          get-num (fn [s] (let [[ss n] (first (filter #(starts-with? s (first %)) rs))]\n                                [n (clojure.string/replace-first s (re-pattern ss) \"\")]))]\n  (loop [v s acc 0] (if (empty? v) acc (let [[n v-] (get-num v)] (recur v- (+ acc n)))))))", "user": "5a4de614e4b05d388ecb6bb1"}, {"problem": 92, "code": "(fn read-roman-numerals\n  [s]\n  (let [values {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}\n        subtractions {\\V \\I \\X \\I \\L \\X \\C \\X \\D \\C \\M \\C}\n        rf (fn [[prev sum] c]\n             (let [sub (subtractions c)\n                   subval (values sub)\n                   cval (values c)]\n               (cond (= \\I c) [c (inc sum)]\n                     (= sub prev) [c (+ sum (- cval (* 2 subval)))]\n                     :else [c (+ sum cval)])))]\n    (second (reduce rf [nil 0] s))))", "user": "57a0f256e4b0c3d858beb8dd"}, {"problem": 92, "code": "(fn convert [romlit] \n  (let [rom2int (fn [x]\n                    (case x\n                      \\I 1\n                      \\V 5\n                      \\X 10\n                      \\L 50\n                      \\C 100\n                      \\D 500\n                      \\M 1000))\n        sign (fn [x] (cond\n                 (neg? x) -1\n                 (pos? x) +1\n                 :else 0))\n        grouped (partition-by rom2int romlit)]\n\n      (reduce + \n              (flatten\n                (map (fn [x] (map #(* (first x) %) (second x)))  \n                     (partition 2\n                       (interleave \n                         (reverse (cons +1 (reverse (map sign (map #(apply - %) (partition 2 1 (map (comp rom2int first) grouped)))) )))\n                          (map #(map rom2int %) grouped)))\n                )))\n))", "user": "5143824ae4b0b4fb4ace5f36"}, {"problem": 92, "code": "(fn [ls] \n  (let [nums {\\I 1\n              \\V 5\n              \\X 10\n              \\L 50\n              \\C 100\n              \\D 500\n              \\M 1000 }] \n       (->> (partition 2 1 ls)\n            (reduce (fn [t [a b]] ((if (>= (nums a) (nums b)) + -) t (nums a))) 0 )\n            (+ (nums (last ls))))))", "user": "5a14228fe4b0ff51aa4b3193"}, {"problem": 92, "code": "(fn [n]\n   (let [r {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000}] \n      (apply + (reduce  #(let [d (r %2) p (last %1)] (conj %1 (if (> d p) (- d p p) d))) [(r (first n))] (rest n)))))", "user": "59f043d0e4b0966464fe6a3d"}, {"problem": 92, "code": "(fn f\n    ([r] (f 0 r))\n    ([res r]\n     (let [m1 { \"M\" 1000 , \"D\" 500, \"C\" 100, , \"L\" 50, \"X\" 10, \"V\" 5, \"I\" 1}\n           m2 { \"CM\" 900, \"CD\" 400, \"XC\" 90, \"XL\" 40, \"IX\" 9, \"IV\" 4}\n           n (count r)]\n       (cond\n         (zero? n) res\n         (= 1 n) (+ res (m1 r))\n         :else (let [ n1 (m1 (subs r 0 1))\n                      n2 (m2 (subs r 0 2))]\n                 (if (nil? n2)\n                   (recur (+ res n1) (subs r 1))\n                   (recur (+ res n2) (subs r 2))))))))", "user": "5a536cf2e4b05d388ecb6c10"}, {"problem": 92, "code": "{\"XIV\" 14 \"DCCCXXVII\" 827 \"MMMCMXCIX\" 3999 \"XLVIII\" 48}", "user": "5a3c2a08e4b001c08efc0cdf"}, {"problem": 92, "code": "(fn [s]\n  (let [rtable {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}\n        ns (loop [xs s\n                  r []]\n             (if (empty? xs) r\n                 (recur (rest xs) (conj r (get rtable (first xs))))))\n        n (loop [ms ns\n                 p 0\n                 r 0]\n            (if (empty? ms) r\n                (let [h (first ms)]\n                  (recur (rest ms) h (if (< p h)\n                                       (+ r h (- (+ p p)))\n                                       (+ r h))))))]\n    n))", "user": "5866b999e4b0f14aab7c886b"}, {"problem": 92, "code": "(fn from-roman [n] (let\n [has-prefix? (fn [prefix ys] (and (>= (count ys) (count prefix))\n                                   (every? identity (map = prefix ys))))\n  numerals [[1000 (seq \"M\")] [900 (seq \"CM\")] [500 (seq \"D\")] [400 (seq \"CD\")] [100 (seq \"C\")] [90 (seq \"XC\")] [50 (seq \"L\")] [40 (seq \"XL\")] [10 (seq \"X\")] [9 (seq \"IX\")] [5 (seq \"V\")] [4 (seq \"IV\")] [1 (seq \"I\")]]\n  next-numeral (fn [s] (first (filter #(has-prefix? (second %) s) numerals)))\n  next-step (fn [{sum :sum strrest :strrest}]\n                (let [[delta numeral] (next-numeral strrest)]\n                     {:sum (+ sum delta)\n                      :strrest (drop (count numeral) strrest)}))]\n  (:sum (first (drop-while #(not (empty? (:strrest %))) (iterate next-step {:sum 0 :strrest (seq n)}))))))", "user": "5a566e8fe4b05d388ecb6c51"}, {"problem": 92, "code": "(fn [roman-numerals]                                                                                                                                            \n  (first (reduce                                                                                                                                                             \n          (fn [[sum last-item] item]                                                                                                                                                     \n            (if (> last-item item)                                                                                                                                        \n              [(- sum item) item]                                                                                                                                    \n              [(+ sum item) item]))                                                                                                                                  \n          [0 0]                                                                                                                                                              \n          (reverse (map                                                                                                                                                      \n                    (partial get {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000})                                                                                                   \n                    (seq roman-numerals))))))", "user": "5410499de4b01498b1a719a6"}, {"problem": 92, "code": "(fn [s]\n  (let [m {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000}\n        num (map m (seq s))]\n    (loop [tail num res 0]\n      (if (empty? tail) res \n          (if (= 1 (count tail))\n            (+ res (first tail))\n            (let [current (first tail) next (second tail)]\n              (if (< current next)\n                (recur (rest (rest tail)) (+ res (- next current)))\n                (recur (rest tail) (+ res current)))))))\n    ))", "user": "5a621702e4b0512ff01cd983"}, {"problem": 92, "code": ";; Performance-wise not ideal, but an experiment using lazy-seqs with reused parts from #104's solution\n(let [parts-seq\n      (fn parts-seq [n table]\n        (lazy-seq\n          (when-not (zero? n)\n            (let [[[g c] :as table] (drop-while #(< n (second %)) table)]\n              (concat g (parts-seq (- n c) table))))))\n      parts-table\n      [[[\"M\"] 1000] [[\"C\" \"M\"] 900] [[\"D\"] 500] [[\"C\" \"D\"] 400] [[\"C\"] 100]\n       [[\"X\" \"C\"] 90] [[\"L\"] 50] [[\"X\" \"L\"] 40] [[\"X\"] 10] [[\"I\" \"X\"] 9]\n       [[\"V\"] 5] [[\"I\" \"V\"] 4] [[\"I\"] 1]]]\n  (fn [rn]\n    (let [parts (map str rn)]\n      (->> '(1 \"I\")\n           (iterate (fn [[n _]] (cons (inc n) (parts-seq (inc n) parts-table))))\n           (drop-while #(not= parts (rest %)))\n           (ffirst)))))", "user": "51dafedee4b09f6bc204eee2"}, {"problem": 92, "code": "(fn roman-numerals [s]\n  (let [letter-to-int (fn [l] (cond (= l \\I) 1\n                                    (= l \\V) 5\n                                    (= l \\X) 10\n                                    (= l \\L) 50\n                                    (= l \\C) 100\n                                    (= l \\D) 500\n                                    (= l \\M) 1000))\n        int-seq (map letter-to-int s)]\n    (first (reduce #(let [[sum prev] %1]\n                      (if (> %2 prev)\n                        [(+ (- sum prev) (- %2 prev)) %2]\n                        [(+ sum %2) %2]))\n                   [(first int-seq) (first int-seq)]\n                   (rest int-seq)))))", "user": "5a6b9b95e4b0512ff01cda40"}, {"problem": 92, "code": "(fn\n  [roman]\n  (let [char-values {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}\n        roman-values (map #(char-values %) roman)]\n    (second (reduce \n              (fn\n                [[prev total] current]\n                (if (< prev current)\n                  [current (+ total (- current prev prev))]\n                  [current (+ total current)]))\n              [Integer/MAX_VALUE 0]\n              roman-values))))", "user": "59fa7fb0e4b0ca45a743a366"}, {"problem": 92, "code": "(fn [input-str]\n    (let [roman-subs\n          {\"IV\", \"IIII\"\n           \"IX\", \"VIIII\"\n           \"XL\", \"XXXX\"\n           \"XC\", \"LXXXX\"\n           \"CM\", \"DCCCC\"}\n          roman-digits\n          {\\M, 1000\n           \\D, 500\n           \\C, 100\n           \\L, 50\n           \\X, 10\n           \\V, 5\n           \\I, 1}\n          expanded-digits (reduce (fn [accum sub] (clojure.string/replace accum sub (roman-subs sub))) input-str (keys roman-subs))\n          individual-digits (seq expanded-digits)]\n      (reduce + (map roman-digits individual-digits))))", "user": "594266cfe4b060784b3b790b"}, {"problem": 92, "code": "(fn [v] (let [decode (fn [x] \n                (case x \\I 1 \\V 5 \\X 10\n                  \\L 50 \\C 100 \\D 500\n                  \\M 1000))\n      sum_up (fn [acc n]\n                 (do\n                   (println [n acc])\n               (if (or (> (* 5 n) acc) (= 0 acc))\n                 (+ acc n)\n                 (- acc n))))]\n  (reduce sum_up 0 (reverse (map decode v)))))", "user": "58a822e4e4b01a0c0b232950"}, {"problem": 92, "code": "(fn [rom-num-str]\n  (let [rom-map {\\I 1\n                 \\V 5\n                 \\X 10\n                 \\L 50\n                 \\C 100\n                 \\D 500\n                 \\M 1000}]\n    (letfn [(subtract-seq [[f s & rm :as coll]]\n              (cond (nil? f) '()\n                    (nil? s) (list f)\n                    :else (if (< f s)\n                            (cons (- s f) (subtract-seq (drop 2 coll)))\n                            (cons f (subtract-seq (rest coll))))))]\n    (reduce + (subtract-seq (map #(get rom-map %) rom-num-str))))))", "user": "5a9dbb32e4b0d174b936c7f3"}, {"problem": 92, "code": "(fn calc [rom]\n  (let [rom->dec (fn rom->dec [nums]\n                   (if (empty? nums) 0\n                      (let [cur  (first nums)\n                            rst  (rest nums)\n                            less (take-while #(> cur %) rst)\n                            sum  (reduce - cur less)]\n                        (+ sum (rom->dec (drop (inc (count less)) nums))))))\n        r->d {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}\n        nums (reverse (map r->d rom))]\n    (rom->dec nums)))", "user": "58fc92c5e4b0438e51c2cf9a"}, {"problem": 92, "code": "(fn [roman-str]\n  (letfn [(decode-char [c]\n            ({\\I 1\n              \\V 5\n              \\X 10\n              \\L 50\n              \\C 100\n              \\D 500\n              \\M 1000}\n             c))\n          (group-items [[c :as coll]]\n            (if (seq coll)\n              (lazy-seq\n               (let [[start end] (split-with #{c} coll)]\n                 (cons\n                  [c (count start)]\n                  (group-items end))))\n              ()))\n          (calculate [[[n-1 count-1] [n-2 count-2] & tail :as romans]]\n            (cond\n              (empty? romans) 0\n              (nil? n-2) (* n-1 count-1)\n              (< n-1 n-2) (+ (* n-2 count-2)\n                             (- (* n-1 count-1))\n                             (calculate tail))\n              :else (+ (* n-1 count-1)\n                       (calculate (next romans)))))]\n    (->> roman-str\n         seq\n         (map decode-char)\n         group-items\n         calculate)))", "user": "4eda7cc3535d10e5ff6f530e"}, {"problem": 92, "code": "(fn [number]\n  (let [rpl clojure.string/replace]\n    (-> number\n        (rpl #\"IV\" \"IIII\")\n        (rpl #\"IX\" \"VIIII\")\n        (rpl #\"XL\" \"XXXX\")\n        (rpl #\"XC\" \"LXXXX\")\n        (rpl #\"CD\" \"CCCC\")\n        (rpl #\"CM\" \"DCCCC\")\n        frequencies\n        (clojure.set/rename-keys\n          {\\I 1, \\V 5, \\X 10, \\L 50,\n           \\C 100, \\D 500, \\M 1000})\n        (->>\n          (map (partial apply *))\n          (apply +)))))", "user": "5a9181c5e4b002d099cae6f6"}, {"problem": 92, "code": "(fn [rn]\n  (let [lmap { \\X 10 \\I 1 \\V 5 \\D 500  \\C 100 \\M 1000}\n        subpairs {\"IV\" 4 \"CM\" 900 \"XC\" 90 \"IX\" 9 \"XL\" 40}\n        includes? (fn [s substr] (.contains (.toString s) substr))\n        spreducer (fn [[tot romstr] spair]\n                    (if (includes? romstr spair)\n                      [(+ tot (subpairs spair)) (clojure.string/replace romstr spair \"\")]\n                      [tot romstr]))\n        applysubs (fn [romstr] (reduce spreducer [0 romstr] (keys subpairs)))\n        [subtot remrn] (applysubs rn)]\n    (+ subtot (apply + (map lmap remrn)))))", "user": "4e8768f6535dceadca469850"}, {"problem": 92, "code": "(fn roman-numbers\n  [s]\n  (let [mappings {\\I 1\n                  \\V 5\n                  \\X 10\n                  \\L 50\n                  \\C 100\n                  \\D 500\n                  \\M 1000}]\n    (loop [pairs (partition 2 1 s)\n           total 0]\n      (if (empty? pairs)\n        total\n        (let [[c1 c2] (first pairs)\n              v1 (get mappings c1)\n              v2 (get mappings c2)]\n          (if (< v1 v2)\n            (recur (drop 2 pairs) (+ total (- v2 v1)))\n            (recur (rest pairs) (if (= 1 (count pairs))\n                                  (+ total v1 v2)\n                                  (+ total v1)))))))))", "user": "57617c20e4b0994c1922fb8c"}, {"problem": 92, "code": "(fn [roman]\n  (reduce\n    (fn [total [num next]] ((if (< num next) - +) total num))\n    0\n    (partition 2 1 (concat (map {\\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1} roman) '(0)))))", "user": "5aa998c6e4b0d174b936c8e5"}, {"problem": 92, "code": "(fn [s]\n  (->> (reverse (.toUpperCase s))\n       (map {\\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1})\n       (partition-by identity)\n       (map (partial apply +))\n       (reduce #(if (< % %2) (+ % %2) (- % %2)))))", "user": "5a6af090e4b0512ff01cda2d"}, {"problem": 92, "code": "#(->> (reverse %)\n      (map {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000})\n      (cons 0)\n      (partition 2 1)\n      (map (fn [[b a]] (if (< a b) (- a) a)))\n      (reduce +))", "user": "5ad63a34e4b0ea6055cfac01"}, {"problem": 92, "code": "(fn [s] (let [m {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}] (->> s (map m) (reduce (fn [v n] (let [l (first v)] (if (< l n) (conj (rest v) (- n l)) (conj v n)))) '(0)) (reduce +))))", "user": "5abe2fc2e4b073f17744271e"}, {"problem": 92, "code": "(fn rrn\n  [x]\n  (let [roman {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]\n    (:value (reduce (fn [{:keys [value gc]} c]\n                      (let [c-val (get roman c)]\n                        (if (< c-val gc)\n                          {:value (- value c-val) :gc gc}\n                          {:value (+ value c-val) :gc c-val})))\n                    {:value 0 :gc 0}\n                    (reverse x)))))", "user": "57ea2c91e4b0bfb2137f5b42"}, {"problem": 92, "code": "(fn roman-num [s]\n  (let [num-map {:i 1 :v 5 :x 10 :l 50 :c 100 :d 500 :m 1000}\n        char-list (re-seq #\"\\w\" s)\n        get-num #((keyword (clojure.string/lower-case %1)) num-map)\n        is-next #(< %1 %2)]\n    (loop [acc 0\n           tmp []\n           char-list char-list]\n      (cond\n        (and (empty? char-list)\n             (empty? tmp))\n        acc\n\n        (empty? tmp)\n        (recur acc\n               (conj tmp (first char-list))\n               (rest char-list))\n\n        (and (not (empty? char-list))\n             (is-next (get-num (first tmp))\n                      (get-num (first char-list))))\n        (recur (+ acc (- (get-num (first char-list))\n                         (get-num (first tmp))))\n               []\n               (rest char-list))\n        :else\n        (recur (+ acc (get-num (first tmp)))\n               []\n               char-list)))))", "user": "58fed70de4b0438e51c2cfdd"}, {"problem": 92, "code": "(fn [numerals]\n    (let [numeral-map {\\I 1\n                       \\V 5\n                       \\X 10\n                       \\L 50\n                       \\C 100\n                       \\D 500\n                       \\M 1000}]\n      (letfn [(subtrahend? [[a b c d]]\n                (let [a-val (get numeral-map a)\n                      b-val (get numeral-map b)\n                      c-val (get numeral-map c)\n                      d-val (get numeral-map d)]\n                  ;; b is subtrahend to c (minuend) if...\n                  (and\n                   ;; 0. Handle padding (i.e. last item)\n                   (not (and (= c \\_) (= d \\_)))\n                   ;; 1. \"Only to a numeral (the subtrahend) that is a power of ten (I, X or C)\"\n                   (not (nil? (some #(= % b) [\\I \\X \\C])))\n                   ;; 2. \"Only when the subtrahend precedes a minuend no more than ten times larger\"\n                   (and (> c-val b-val)\n                        (not (> c-val (* b-val 10))))\n                   ;; 3. \"Only if any numeral preceding the subtrahend is at least ten times larger\"\n                   (or (= a \\_)\n                       (>= a-val (* b-val 10)))\n                   ;; 4. \"Only if any numeral following the minuend is smaller than the subtrahend\"\n                   (or (= d \\_)\n                       (< d-val b-val)))))]\n        (reduce + (map (fn [numerals]\n                         (let [val (get numeral-map (second numerals))]\n                           (if (subtrahend? numerals)\n                             (- val)\n                             val)))\n                       (partition 4 1 (str \"_\" numerals \"__\")))))))", "user": "5ac6ef9be4b0e27600da7779"}, {"problem": 92, "code": "(fn roman-numerals\n  ([rn] (roman-numerals 0 rn))\n  ([acc rn]\n   (if (seq rn)\n     (let [rn->dn {\"I\" 1 \"V\" 5 \"X\" 10 \"L\" 50 \"C\" 100 \"D\" 500 \"M\" 1000}\n           rn (mapv str rn)\n           a (rn->dn (first rn))\n           b (rn->dn (get rn 1 \"I\"))\n           res (if (>= a b) a (- b a))\n           nrn (if (>= a b ) (next rn) (nnext rn))]\n       (roman-numerals (+ acc res) nrn))\n     acc\n     ))\n  )", "user": "59f44189e4b0966464fe6aab"}, {"problem": 92, "code": "#(second (reduce (fn [[p a] e] (let [c ({\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000} e)\n                             v (if (< p c) (- c (* 2 p)) c)]\n                         [c (+ a v)])) [0 0] %))", "user": "577202d2e4b0979f896515c0"}, {"problem": 92, "code": "(fn [s]\n  (-> s\n    (clojure.string/replace #\"CM\" \"DCCCC\")\n    (clojure.string/replace #\"CD\" \"CCCC\")\n    (clojure.string/replace #\"XC\" \"LXXXX\")\n    (clojure.string/replace #\"XL\" \"XXXX\")\n    (clojure.string/replace #\"IX\" \"VIIII\")\n    (clojure.string/replace #\"IV\" \"IIII\")\n    (->>\n      (sort-by identity)\n      (map {\\M 1000 \\D 500 \\C 100 \\L 50\n            \\X 10 \\V 5 \\I 1})\n      (apply +))))", "user": "5af907e6e4b0cc2b61a3bcda"}, {"problem": 92, "code": "(fn [s]\n  (letfn [(f [z] (case z\n                   \\I 1\n                   \\V 5\n                   \\X 10\n                   \\L 50\n                   \\C 100\n                   \\D 500\n                   \\M 1000))]\n    (loop [v s\n           h 0]\n      (cond (empty? v) h\n            (= 1 (count v)) (+ h (f (first v)))\n            (< (f (first v)) (f (second v))) (recur (drop 2 v) (- (+ h (f (second v))) (f (first v))))\n         \t:else (recur (rest v) (+ h (f (first v))))))))", "user": "55e732c5e4b050e68259b492"}, {"problem": 92, "code": "(fn [number] (let [digits {\\I 1\n                           \\V 5\n                           \\X 10\n                           \\L 50\n                           \\C 100\n                           \\D 500\n                           \\M 1000}]\n               (apply\n                 +\n                 (reduce (fn [[result acc] digit]\n                           (let [digit-value (get digits digit)]\n                             (if (or (zero? acc) (<= digit-value acc))\n                               [(+ result acc) digit-value]\n                               [(+ result (- digit-value acc)) 0])))\n                         [0 0]\n                         number))))", "user": "5ac91d90e4b0e27600da77bd"}, {"problem": 92, "code": "(fn [st]\n  (let [romans {\\I    1\n                \\V    5\n                \\X   10\n                \\L   50\n                \\C  100\n                \\D  500\n                \\M 1000}]\n    (loop [stk1 (vec (map romans st))\n           stk2 []]\n      (if (empty? stk1)\n        (apply + stk2)\n        (if (or (empty? stk2) (>= (peek stk1) (peek stk2)))\n          (recur (pop stk1) (conj stk2 (peek stk1)))\n          (recur (pop stk1) (conj (pop stk2)\n                                  (- (peek stk2) (peek stk1)))))))))", "user": "57ee82b1e4b0bfb2137f5bbd"}, {"problem": 92, "code": "(fn numeral [s]\n   (let [+s #(re-matches (re-pattern (str \"^\" % \".*\")) s)]\n     (cond\n       (empty? s) 0\n       (+s \"M\")   (+ 1000 (numeral (subs s 1)))\n       (+s \"CM\")  (+ 900  (numeral (subs s 2)))\n       (+s \"D\")   (+ 500  (numeral (subs s 1)))\n       (+s \"CD\")  (+ 400  (numeral (subs s 2)))\n       (+s \"C\")   (+ 100  (numeral (subs s 1)))\n       (+s \"XC\")  (+ 90   (numeral (subs s 2)))\n       (+s \"L\")   (+ 50   (numeral (subs s 1)))\n       (+s \"XL\")  (+ 40   (numeral (subs s 2)))\n       (+s \"X\")   (+ 10   (numeral (subs s 1)))\n       (+s \"IX\")  (+ 9    (numeral (subs s 2)))\n       (+s \"V\")   (+ 5    (numeral (subs s 1)))\n       (+s \"IV\")  (+ 4    (numeral (subs s 2)))\n       (+s \"I\")   (+ 1    (numeral (subs s 1))))))", "user": "5b073c34e4b0cc2b61a3bda4"}, {"problem": 92, "code": "(fn from-roma [s]\n  (letfn [(to-dec [c] (case c\n                        \\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000\n                        (assert false)))]\n    (let [decs (reverse (map to-dec s))\n          maxes (rest (reduce (fn [acc val] (conj acc (max (last acc) val))) [0] decs))]\n      (->> decs\n           (map (fn [m val] (if (> m val) (- 0 val) val)) maxes)\n           (apply +)))))", "user": "5b13ba71e4b0cc2b61a3be53"}, {"problem": 92, "code": "(fn read-roman [s]\n  (letfn [(get-value [l]\n            (get {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000} l))\n          (get-operations [[a b & c]]\n            (cond (nil? b) [+]\n                  (>= a b) (cons + (get-operations (cons b c)))\n                  :else (cons - (get-operations (cons b c)))))]\n                  (let [operations (get-operations (map get-value s))]\n\n                  (reduce #((nth operations %2) %1 (get-value (nth s %2)))\n                    0 (range (count s))))))", "user": "5b15811ee4b0cc2b61a3be6f"}, {"problem": 92, "code": "(fn read-roman-nums [rn-str]\n  (let [rn->num {\\I 1 \\V 5 \\X 10 \\L 50\n                 \\C 100 \\D 500 \\M 1000}\n        rn-nums (map rn->num (reverse rn-str))]\n    (loop [sum 0\n           [f s & r] rn-nums]\n      (if (nil? s)\n        (if (nil? f) sum (+ sum f))\n        (if (< s f)\n          (recur (+ sum (- f s)) r)\n          (recur (+ sum f) (conj r s)))))))", "user": "53fe1b42e4b0de5c418485f1"}, {"problem": 92, "code": "(let [letter->num {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]\n  (fn [s]\n    (loop [[val-1 val-2 :as vals] (map letter->num s)\n           total 0]\n      (cond\n        (empty? vals) total\n        (and val-2 (> val-2 val-1)) (recur (rest (rest vals)) (+ total (- val-2 val-1)))\n        :else (recur (rest vals) (+ total val-1))))))", "user": "5afc0f30e4b0cc2b61a3bcfe"}, {"problem": 92, "code": "(fn [x]\n (let [num {\\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1} f (fn [[a b]] (if (< a b) (- a) a))]\n  (->> (concat (map num x) [0])\n   (partition 2 1)\n   (map f)\n   (apply +))))", "user": "5b0180cfe4b0cc2b61a3bd47"}, {"problem": 92, "code": ";; https://gist.github.com/richardeast/ff37c4138bc01b1c136b2006745084fb\n\n(fn roman [i]\n  (let [replacer (fn [s [this that]]\n                     (.replace s this that))]\n    (-> (reduce replacer i\n                [;; [replace-this for-that]\n                    [\"CM\"         \"DCD\"]\n                    [\"M\"          \"DD\"]\n                    [\"CD\"         \"CCCC\"]\n                    [\"D\"          \"CCCCC\"]\n                    [\"XC\"         \"LXL\"]\n                    [\"C\"          \"LL\"]\n                    [\"XL\"         \"XXXX\"]\n                    [\"L\"          \"XXXXX\"]\n                    [\"IX\"         \"VIV\"]\n                    [\"X\"          \"VV\"]\n                    [\"IV\"         \"IIII\"]\n                    [\"V\"          \"IIIII\"]]) ;; reduce will make numeral a tally of 'I's. Then we count the tally.\n          count)))", "user": "4e6a23d0535d8ccf87e9fea0"}, {"problem": 92, "code": "#(first (reduce (fn [[sum mult last] x]\n          (let [mult (cond (= x last) mult (< x last) -1 :else 1)]\n            [(+ sum (* mult x)) mult x]))\n        [0 1 1] (reverse (map {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000} (seq %)))))", "user": "5b3f2ba9e4b02d533a91bc09"}, {"problem": 92, "code": "(fn roman->arabic [s]\n  (let [values (map  {\\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1}\n                     (reverse s))]\n    (second (reduce (fn [[max acc] new]\n                      (if (>= new max)\n                        [new (+ acc new)]\n                        [max (- acc new)]))\n                    [0 0]\n                    values))))", "user": "5b47874be4b02d533a91bc70"}, {"problem": 92, "code": "(fn [q] (\n(fn f [rn] (if (empty? rn)\n           0\n             (if (= 1 (count rn))\n               ({\"I\" 1 \"V\" 5 \"X\" 10 \"L\" 50 \"C\" 100 \"D\" 500 \"M\" 1000} (str (first rn)))\n               \n           (let [sel ({\"IV\" 4 \"IX\" 9 \"XL\" 40 \"XC\" 90 \"CD\" 400 \"CM\" 900} (str (first rn) (second rn)))\n                 el ({\"I\" 1 \"V\" 5 \"X\" 10 \"L\" 50 \"C\" 100 \"D\" 500 \"M\" 1000} (str (first rn)))]\n             (if (nil? sel)\n               (+ el (f (rest rn)))\n               (+ sel (f (nthrest rn 2)))\n               )))))\n         (seq q)\n         ))", "user": "5b4b4052e4b02d533a91bc9a"}, {"problem": 92, "code": "(let\n  [dict {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]\n  (fn [s] (let [d (map dict (vec s)) n (count d) di (fn [i] (nth d i)) nxt (fn [i] (if (< (inc i) n) (di (inc i)) 0))]\n            (reduce + (map #(* (di %) (if (< (di %) (nxt %)) -1 1)) (range n))))))", "user": "5b465b8be4b02d533a91bc65"}, {"problem": 92, "code": "(fn [numeral]\n  (let [m (apply hash-map (interleave [\\M   \\D  \\C  \\L \\X \\V \\I]\n                                      [1000 500 100 50 10 5  1]))\n        n (concat (map #(m %) (map char numeral)) [0 0])\n        b (interleave (partition 2 n) (partition 2 (rest n)))]\n    (loop [p b a 0]\n      (if (empty? p)\n        a\n        (let [[f s] (first p)]\n          (recur (rest p) (if (< f s) (- a f) (+ a f))))))))", "user": "5a9d64c8e4b0d174b936c7eb"}, {"problem": 92, "code": "(fn roman->number [s]\n  (let [symbols {\"I\" 1, \"IV\" 4, \"V\" 5, \"IX\" 9, \"X\" 10,\n                 \"XL\" 40, \"L\" 50, \"XC\" 90, \"C\" 100,\n                 \"CD\" 400, \"D\" 500, \"CM\" 900, \"M\" 1000}]\n    (loop [todo s acc 0]\n      (if-let [[fst snd & more] todo]\n        (if (contains? symbols (str fst snd))\n          (recur more (+ acc (get symbols (str fst snd))))\n          (recur (next todo) (+ acc (get symbols (str fst)))))\n        acc))))", "user": "5b51b9f8e4b02d533a91bcfe"}, {"problem": 92, "code": "(fn wrn\n  [s]\n  (apply +\n         (reduce #(if (and (not (empty? %1)) (< (last %1) %2)) (conj (vec (drop-last %1)) (- %2 (last %1))) (conj %1 %2)) []\n                 (map (fn [[k v]] (* k v))\n                      (map (fn [[k v]] [(case k  \\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000) v]) (map (fn [v] [(first v) (count v)]) (partition-by identity s)))))))", "user": "5b008bcae4b0cc2b61a3bd3d"}, {"problem": 92, "code": "(fn [x]\n (let [num {\\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1}\n       f (fn [[a b]] (if (and b (< a b)) (- a) a))]\n  (->> (map num x)\n   (partition-all 2 1)\n   (map f)\n   (apply +))))", "user": "5b61aa6ae4b0c6492753e712"}, {"problem": 92, "code": "(fn [s]\n    (:sum (reduce (fn [{:keys [sum prev] :as a} n]\n                    (assoc a :prev n :sum (+ sum n (if (<= n prev) 0 (* -2 prev)))))\n                  {:sum 0 :prev 0}\n                  (map {\\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1}\n                       (seq s)))))", "user": "54f26266e4b024c67c0cf8c5"}, {"problem": 92, "code": "(fn __ [[x y & r :as xs]]\n  (letfn [(single [x] ({ \\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000 } x))\n          (double [x y] ({ \"IV\" 4 \"IX\" 9 \"XL\" 40 \"XC\" 90 \"CD\" 400 \"CM\" 900 } (str x y)))]\n    (cond\n      (empty? xs) 0\n      (double x y) (+ (double x y) (__ r))\n      :else (+ (single x) (__ (rest xs))))))", "user": "5a544eeee4b05d388ecb6c24"}, {"problem": 92, "code": "(let [token-val {\\I 1\n                   \\V 5\n                   \\X 10\n                   \\L 50\n                   \\C 100\n                   \\D 500\n                   \\M 1000}](fn parse-roman [roman-s]\n    (loop [rs-in (seq roman-s)\n           total 0\n           mod-next 0]\n      (if-let [token (first rs-in)]\n        (let [?next-token (second rs-in)\n              tv (token-val token)]\n          (if (and ?next-token\n                   (< tv (token-val ?next-token)))\n            (recur (rest rs-in)\n                   total\n                   (- mod-next tv))\n            (recur (rest rs-in)\n                   (+ total\n                      tv\n                      mod-next)\n                   0)))\n        total))))", "user": "54246fcce4b01498b1a71aed"}, {"problem": 92, "code": "(let [numerals\n        {\\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1}]\n    (fn [s]\n      (loop [sum 0\n             prev 0\n             [c & more-chars] (seq s)]\n        (if (nil? c)\n          (if (zero? prev)\n            sum\n            (+ sum prev))\n\n          (let [next-val (numerals c)]\n\n            (cond\n              (zero? prev)\n              (recur sum next-val more-chars)\n\n              (< prev next-val)\n              (recur (+ sum (- prev) next-val)\n                     0 more-chars)\n\n              :otherwise\n              (recur (+ sum prev)\n                     next-val more-chars)))))))", "user": "539fa040e4b0ca733b97449f"}, {"problem": 92, "code": "#(->> (map {\\C 100 \\D 500 \\I 1 \\L 50 \\M 1000 \\V 5 \\X 10} %)\n       (partition 2 1 [0])\n       (map (fn [[a b]] (if (< a b) (- a) a)))\n       (apply +))", "user": "5b86462de4b047b03b2037df"}, {"problem": 92, "code": "#(let [ zz [[#\"^M\" 1000][#\"^CM\" 900][#\"^D\" 500][#\"^CD\" 400][#\"^C\" 100][#\"^XC\" 90][#\"^L\" 50][#\"^XL\" 40][#\"^X\" 10][#\"^IX\" 9][#\"^V\" 5][#\"^IV\" 4][#\"^I\" 1]]]\n  ( loop [ x % res 0 p zz]\n    (if (empty? x)\n      res\n      ( let [ re (first (first p)) ap (second (first p))]\n        (if (re-seq re x)\n          (recur (clojure.string/replace x re \"\") (+ res ap) p)\n          (recur x res (rest p))\n        )\n      )\n    )\n  )\n)", "user": "5b3aa98be4b02d533a91bbca"}, {"problem": 92, "code": "(fn to-arabic [roman]\n  (let [symbols [[\"M\" 1000] [\"CM\" 900] [\"D\" 500] [\"CD\" 400] [\"C\" 100] [\"XC\" 90] [\"L\" 50] [\"XL\" 40]\n                           [\"X\" 10] [\"IX\" 9] [\"V\" 5] [\"IV\" 4] [\"I\" 1]]\n        symbol-to-value   (into {} symbols)\n        pattern           (->> symbols\n                               (map first)\n                               (interpose \"|\")\n                               (apply str)\n                               re-pattern)]\n    (->> (re-seq pattern roman)\n         (map symbol-to-value)\n         (apply +))))", "user": "5b81139fe4b047b03b203782"}, {"problem": 92, "code": "(fn [input]\n   (let [roman-num {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]\n     (last (reduce (fn [[base result] value]\n                     (if (<= base value)\n                       [value (+ result value)]\n                       [base (- result value)]))\n                   [1 0]\n                   (map #(roman-num %) (reverse input))))))", "user": "52fac708e4b047fd55836fff"}, {"problem": 92, "code": "(fn [n]\n  (let [m {\\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1}\n        sum #(+ %1 %3 (if (< %2 %3) (* -2 %2) 0))]\n    (first (reduce #(conj [] (sum (first %1) (second %1) (m %2)) (m %2)) [0 1000] n))))", "user": "56c4f43ce4b05cc29241ee9c"}, {"problem": 92, "code": "(fn [in-str]\n    (let [value2char (sorted-map 1 \\I 5 \\V 10 \\X 50 \\L 100 \\C 500 \\D 1000 \\M)\n          char2value (into {} (map (comp vec reverse) value2char))]\n      ;(clojure.pprint/pprint char2value)\n      \n      (loop [chars (vec in-str)\n             sum-so-far 0\n             last-digit \\0\n             last-digit-occurrences 0]\n        (println \"sum-so-far\" sum-so-far \"last-digit\" last-digit \"last-d-oc\" last-digit-occurrences)\n        (if (empty? chars)\n          (+ sum-so-far (* (char2value last-digit) last-digit-occurrences))\n          (let [digits (for [c chars :while (= c (first chars))] c)\n                digit (first digits)\n                digit-occurrences (count digits)\n                digit-value (char2value digit)\n                last-digit-value (char2value last-digit 0)\n                digit-standard-order (or (= last-digit \\0) ;don't use zero? because it throws on non-number\n                                         (> last-digit-value digit-value))]\n            (assert (or\n                        digit-standard-order\n                        (and (or (= last-digit-value (/ digit-value 5))\n                                 (= last-digit-value (/ digit-value 10)))\n                             (= digit-occurrences last-digit-occurrences 1))))   \n                             \n            (recur\n              (drop digit-occurrences chars)\n              (+ sum-so-far\n                 (if digit-standard-order\n                   (* last-digit-value last-digit-occurrences)\n                   (- digit-value last-digit-value)))\n              digit\n              (if digit-standard-order\n                digit-occurrences\n                0)))))  \n      ))", "user": "5b999af8e4b0c0b3ffbd4ad3"}, {"problem": 92, "code": "(fn roman->number\n  [roman-numerals]\n  (let [roman-char->num {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}\n        apply-r-num (fn [[previous-roman-num n] roman-char]\n                      (let [roman-num (roman-char->num roman-char)]\n                        (if (<= previous-roman-num roman-num)\n                          [roman-num (+ n roman-num)]\n                          [roman-num (- n roman-num)])))]\n    (last (reduce apply-r-num [0 0] (reverse roman-numerals)))))", "user": "5125029de4b0ce9225d2ed3e"}, {"problem": 92, "code": "#(let [vals {\\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1} x (seq %)]\n   (loop [a 0 [d1 & ds] x lst 2000]\n     (if d1\n       (let [dig (vals d1) adig (if (< lst dig) (- dig lst lst) dig) ]\n         (recur (+ a adig) ds dig) )\n       a)))", "user": "5b919d9de4b0c0b3ffbd4a24"}, {"problem": 92, "code": "(fn decode [roman]\n   (->> roman\n        (map {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000})\n        ;(partition-by identity)))\n        ;(map #(apply + %))))\n        (reduce (fn [[acc-sum [:as parts] :as num] x]\n                  (println num acc-sum parts x)\n                  (cond\n                    (or \n                      (empty? parts)\n                      (= x (last parts))) [acc-sum (conj parts x)]\n                    (< x (last parts)) [(apply + acc-sum parts) [x]]\n                    (> x (last parts)) [(+ acc-sum (- x (apply + parts))) []]))\n                [0 []])\n        (flatten)\n        (apply +)))", "user": "5a91988ae4b002d099cae6f9"}, {"problem": 92, "code": "(fn __ [s]\n  (let [vals {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}\n        chars (seq s)\n        f (fn [v vt c cls]\n            (let [[x & xs] cls\n                  w (if x (vals x))]\n              (cond\n                (nil? x) (+ v vt)\n                (= c w) (recur v (+ vt w) c xs)\n                (and c (< c w)) (recur (- v vt) w w xs)\n                true (recur (+ v vt) w w xs))))]\n    (f 0 0 nil chars)))", "user": "502a5e59e4b09e8f859a9fbc"}, {"problem": 92, "code": "(fn [s] (let [n (map {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000} (seq s))\n                        re (reverse n)\n                        r (map #(apply - %) (partition 2 (butlast (rest (interleave re re)))))\n                        f (map #(if (pos? %) -1 1) r)\n                        fr (reverse (cons 1 f))\n                        res (apply + (map * n fr))\n                        ]\n                    res))", "user": "5b924123e4b0c0b3ffbd4a34"}, {"problem": 92, "code": "(fn ans [inp] (let [rom {\"I\" 1 \"V\" 5 \"X\" 10 \"L\" 50 \"C\" 100 \"D\" 500 \"M\" 1000} inp-nums (map (fn [x] (rom x)) (clojure.string/split inp #\"\"))] (apply + (remove nil? (reduce (fn [[res l] x] (cond (nil? l) [res x] (>= l x) [(+ res l) x] :else [(+ res (- x l)) nil])) [0 nil] inp-nums)))))", "user": "5addadfce4b0837691e92c13"}, {"problem": 92, "code": "(fn [str]\n    (let\n      [roman {\"I\"  1 \"V\" 5 \"X\" 10 \"L\" 50 \"C\" 100 \"D\" 500 \"M\" 1000\n              \"IV\" 4 \"IX\" 9 \"XL\" 40 \"XC\" 90 \"CD\" 400 \"CM\" 900}]\n      (apply + (map roman (re-seq #\"IV|IX|XL|XC|CD|CM|I|V|X|L|C|D|M\" str)))))", "user": "5bc9e3e9e4b07a9b28b100e2"}, {"problem": 92, "code": "(fn [x]\n  (apply + (map #(let [r {\\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1}\n                       v (r (first %)) \n                       n (r (last %))]\n                   (if (> n v) (- v) v))\n                (partition-all 2 1 x))))", "user": "4fe9de74e4b0547ebccb2475"}, {"problem": 92, "code": "(fn [r]\n  (let [rtod {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]\n    \n    ;; Loop over string\n    (loop [roman r first2 (take 2 roman) total 0]\n      (if (empty? roman) total\n        \n        ;; Look at first two chars, check if first < second\n        ;; i.e. IV, XL, XC\n        (if (and (second first2) \n                 (< (rtod (first first2)) (rtod (second first2))))\n          (recur (drop 2 roman) (take 2 (drop 2 roman))\n                 (+ total (- (rtod (second first2)) (rtod (first first2)))))\n          (if (second first2)\n            (recur (drop 1 roman) (take 2 (drop 1 roman))\n                   (+ total (rtod (first first2))))\n          \t(recur (drop 2 roman) (take 2 (drop 2 roman))\n                   (+ total (rtod (first first2))))))))))", "user": "53d977f1e4b0e771c302547a"}, {"problem": 92, "code": "(fn __ [rm]\n  (let [\n        trmap {\\M 1000, \\D 500, \\C 100, \\L 50, \\X, 10, \\V 5, \\I 1}\n        rmrder\n        (fn [v]\n          (cond\n           (empty? v) [0 nil]\n           (empty? (rest v)) [(trmap (first v)) nil]\n           (<= (trmap (second v)) (trmap (first v))) [(trmap (first v)) (rest v)]\n           :else [(- (trmap (second v)) (trmap (first v))) (drop 2 v)]))\n        ]\n    (loop [r 0 v (seq rm)]\n      (let [[i v'] (rmrder v)]\n        (if v'\n          (recur (+ r i) v')\n          (+ r i)\n          )))\n))", "user": "5a0ce1a5e4b04bbd27e6d9b7"}, {"problem": 92, "code": "(fn [x]\n  (let [m {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}\n        v (map #(m %)(into [] x))\n        r (rest v)]\n    (apply + (conj (map #(if (< % %2) (* -1 %) %) v r) (last v)))))", "user": "566d71b1e4b0a866af6896ca"}, {"problem": 92, "code": "(fn read-roman [s]\n  (let [numerals {\\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1}\n        nums (partition 2 1 (concat (map numerals s) [0]))]\n    (reduce (fn [sum [a b]] ((if (< a b) - +) sum a)) 0 nums)))", "user": "5bbdd136e4b07a9b28b0ffab"}, {"problem": 92, "code": "(let [read-lookup\n      {\n       \\I 1\n       \\V 5\n       \\X 10\n       \\L 50\n       \\C 100\n       \\D 500\n       \\M 1000}\n      roman->int (fn roman->int\n                   ([roman]\n                    (roman->int roman 0))\n\n                   ([roman so-far]\n                    (if (empty? roman)\n                      so-far\n                      (let [current-int (read-lookup (first roman))\n                            next-int (read-lookup (second roman))]\n                        (if (and (not (nil? next-int))\n                                 (< current-int next-int))\n                          (recur (rest roman) (- so-far current-int))\n                          (recur (rest roman) (+ so-far current-int)))))))]\n  roman->int)", "user": "5bab5440e4b0a20761a23475"}, {"problem": 92, "code": "(fn f\n  ([s] (f s 0))\n  ([s n]\n   (let [m {\\M 1000 \"CM\" 900 \\D 500 \"CD\" 400 \\C 100 \"XC\" 90 \\L 50 \"XL\" 40 \\X 10 \"IX\" 9 \\V 5 \"IV\" 4 \\I 1}]\n     (cond\n      (zero? (count s)) n\n      (and (> (count s) 1)(m (subs s 0 2))) (f (subs s 2) (+ n (m (subs s 0 2))))\n      :else (f (subs s 1) (+ n (m (first s))))))))", "user": "567c63f6e4b05957ce8c61bb"}, {"problem": 92, "code": "(fn [x]\n  (letfn [(vl [x] (cond\n         \t (= x \\M) 1000\n             (= x \\D) 500\n             (= x \\C) 100\n             (= x \\L) 50\n             (= x \\X) 10\n             (= x \\V) 5\n             (= x \\I) 1\n          ))\n          (vls [x] (map vl x)\n          )\n          (sum [[x y] z] (if (< 0 y z) [(+ x (- z y)) 0] [(+ x y) z]\n                          \t   )\n          )\n          ]\n(apply + (reduce sum [0 0] (vls x)))\n   )\n)", "user": "5be6d0f8e4b0f319e2d7ec51"}, {"problem": 92, "code": "(fn for-clojure-convert\n  [roman]\n  (let [spec\n        [[\"M\" 1000]\n         [\"CM\" 900]\n         [\"D\" 500]\n         [\"CD\" 400]\n         [\"C\" 100]\n         [\"XC\" 90]\n         [\"L\" 50]\n         [\"XL\" 40]\n         [\"X\" 10]\n         [\"IX\" 9]\n         [\"V\" 5]\n         [\"IV\" 4]\n         [\"I\" 1]]\n\n        token-pattern\n        (->> spec\n             (map first)\n             (clojure.string/join \"|\")\n             (re-pattern))\n\n        roman->arab\n        (->> spec\n             (flatten)\n             (apply hash-map))]\n\n    (->> (str roman)\n            (re-seq token-pattern)\n            (map roman->arab)\n            (apply +)\n            )))", "user": "5b759ca8e4b047b03b2036d0"}, {"problem": 92, "code": "(fn roman-numberals [str-num]\n  (let [romans {\\I 1\n                \\V 5\n                \\X 10\n                \\L 50\n                \\C 100\n                \\D 500\n                \\M 1000}\n        numbers (->> str-num\n                     (clojure.string/upper-case)\n                     (map romans))]\n    (loop [total 0\n           nums numbers]\n      (let [[fst snd] nums]\n        (cond\n          (and fst snd)\n          (if (< fst snd)\n            ;; this is subtraction pattern\n            (recur (+ total (- snd fst)) (nnext nums))\n            ;; add only the first one because the second one can form subtraction pattern with the third element\n            (recur (+ total fst) (next nums)))\n\n          fst\n          (+ total fst)\n\n          :else\n          total)))))", "user": "551bdefde4b07993ea3788d7"}, {"problem": 92, "code": "(fn arabic\n \n  [r]\n  (let [digits\n        [[\"M\" 1000]\n         [\"CM\" 900]\n         [\"D\" 500]\n         [\"CD\" 400]\n         [\"C\" 100]\n         [\"XC\" 90]\n         [\"L\" 50]\n         [\"XL\" 40]\n         [\"X\" 10]\n         [\"IX\" 9]\n         [\"V\" 5]\n         [\"IV\" 4]\n         [\"I\" 1]\n         [\"\" nil]]\n\n        matcher\n        (fn [r]\n          (->> digits\n               (filter (fn [[d v]]\n                         (.startsWith r d)))\n               (first)))]\n    (->> [r 0]\n         (trampoline (fn meh [[r n]]\n                       (if (zero? (.length r))\n                         n\n                         (let [[d v]\n                               (matcher r)]\n                           #(meh [(.substring r (.length d)) (+ n v)]))))))))", "user": "58e37946e4b005f69f193cae"}, {"problem": 92, "code": "(fn roman->num [num]\n  (let [num (map str num)\n        characters [\"I\" \"V\" \"X\" \"L\" \"C\" \"D\" \"M\"]]\n    (let [values (apply hash-map (interleave characters [1 5 10 50 100 500 1000]))]\n      (let [nums (map #(values %1) num)]\n        (loop [nums nums\n               v 0]\n          (cond\n            (empty? nums) v\n            (or (< (count nums) 2) (<= (second nums) (first nums))) (recur (rest nums) (+ v (first nums)))\n            :else (let [e1 (first nums)\n                        e2 (second nums)]\n                    (recur (rest (rest nums)) (+ v (- e2 e1))))))))))", "user": "5918db70e4b09b4ee5954bbb"}, {"problem": 92, "code": "(fn [s]\n  (->> s\n    (map\n      #(case %\n            \\I 1\n            \\V 5\n            \\X 10\n            \\L 50\n            \\C 100\n            \\D 500\n            \\M 1000))\n    (partition-by identity)\n    (map #(reduce + %))\n    ((fn [coll]\n      (let [stash (atom nil)\n            no-stash? #(nil? @stash)\n            update! #(let [ret @stash]\n                      (reset! stash %)\n                      ret)\n            clear! #(update! nil)]\n        (loop [xs coll\n               acc 0]\n          (if-let [x (first xs)]\n            (if (no-stash?)\n              (do\n                (update! x)\n                (recur (rest xs) acc))\n              (if (< @stash x)\n                (recur (rest xs) (+ acc (- x (clear!))))\n                (recur (rest xs) (+ acc (update! x)))))\n            (if (no-stash?)\n              acc\n              (+ acc (clear!))))))))))", "user": "5ba15075e4b0a20761a2339e"}, {"problem": 92, "code": "(letfn [\n\n    (decode-letter [l]\n      ({\"M\" 1000, \"D\" 500, \"C\" 100, \"L\" 50, \"X\" 10, \"V\" 5, \"I\" 1} (str l)))\n\n    (apply-subtractive-principle [coll]\n      (reduce #(if (and ((complement empty?) %1) (> %2 (last %1)))\n                 (conj (into [] (butlast %1)) (- %2 (last %1)))\n                 (conj %1 %2))\n              []\n              coll))\n          ]\n    (fn romain->numerals [roman]\n        (->> roman\n             (map decode-letter)\n             (apply-subtractive-principle)\n             (reduce +))))", "user": "5b60e88be4b0c6492753e70b"}, {"problem": 92, "code": "(fn read-roman [s]\n  (let [numerals {\\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1}\n        nums (partition 2 1 (concat (map numerals s) [0]))]\n    (reduce (fn [sum [a b]] ((if (< a b) - +) sum a)) 0 nums)))", "user": "5c2649c8e4b07e362c2305bf"}, {"problem": 92, "code": "(fn parse-roman-numerals\n  [s]\n  (letfn [(starts-with?\n            [^CharSequence s ^String substr]\n            (.startsWith (.toString s) substr))]\n    (loop [res 0 val s]\n      (cond\n        (starts-with? val \"M\") (recur (+ res 1000) (subs val 1))\n        (starts-with? val \"CM\") (recur (+ res 900) (subs val 2))\n        (starts-with? val \"DCCC\") (recur (+ res 800) (subs val 4))\n        (starts-with? val \"DCC\") (recur (+ res 700) (subs val 3))\n        (starts-with? val \"DC\") (recur (+ res 600) (subs val 2))\n        (starts-with? val \"D\") (recur (+ res 500) (subs val 1))\n        (starts-with? val \"CD\") (recur (+ res 400) (subs val 2))\n        (starts-with? val \"CCC\") (recur (+ res 300) (subs val 3))\n        (starts-with? val \"CC\") (recur (+ res 200) (subs val 2))\n        (starts-with? val \"C\") (recur (+ res 100) (subs val 1))\n        (starts-with? val \"XC\") (recur (+ res 90) (subs val 2))\n        (starts-with? val \"LXXX\") (recur (+ res 80) (subs val 4))\n        (starts-with? val \"LXX\") (recur (+ res 70) (subs val 3))\n        (starts-with? val \"LX\") (recur (+ res 60) (subs val 2))\n        (starts-with? val \"L\") (recur (+ res 50) (subs val 1))\n        (starts-with? val \"XL\") (recur (+ res 40) (subs val 2))\n        (starts-with? val \"XXX\") (recur (+ res 30) (subs val 3))\n        (starts-with? val \"XX\") (recur (+ res 20) (subs val 2))\n        (starts-with? val \"X\") (recur (+ res 10) (subs val 1))\n        (starts-with? val \"IX\") (recur (+ res 9) (subs val 2))\n        (starts-with? val \"VIII\") (recur (+ res 8) (subs val 4))\n        (starts-with? val \"VII\") (recur (+ res 7) (subs val 3))\n        (starts-with? val \"VI\") (recur (+ res 6) (subs val 2))\n        (starts-with? val \"V\") (recur (+ res 5) (subs val 1))\n        (starts-with? val \"IV\") (recur (+ res 4) (subs val 2))\n        (starts-with? val \"III\") (recur (+ res 3) (subs val 3))\n        (starts-with? val \"III\") (recur (+ res 3) (subs val 3))\n        (starts-with? val \"II\") (recur (+ res 2) (subs val 2))\n        (starts-with? val \"I\") (recur (+ res 1) (subs val 1))\n        :else res\n        )\n      )\n    )\n  )", "user": "5c20b6abe4b07e362c230576"}, {"problem": 92, "code": "(fn [s] (let [m (zipmap \n\t\t[\"M\" \"CM\" \"D\" \"CD\" \"C\" \"XC\" \"L\" \"XL\" \"X\" \"IX\" \"V\" \"IV\" \"I\"]\n\t\t[1000 900 500 400 100 90 50 40 10 9 5 4 1])]\n\t(apply + (map m (re-seq #\"IV|IX|XL|XC|XM|CD|CM|[IVXLCDM]\" s)))))", "user": "57c647bbe4b05aa3c4741cf3"}, {"problem": 92, "code": "(fn [roman-str]\n  (let [roman->arabic {\\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1}\n        [_ _ sum]     (reduce\n                        (fn [[sum prev] x]\n                          (let [new-sum (+ sum prev)]\n                            (if (< x prev)\n                              [sum (- prev x) (- new-sum x)]\n                              [new-sum x (+ new-sum x)])))\n                        [0 0 0]\n                        (map #(roman->arabic %) (reverse roman-str)))]\n    sum))", "user": "571a0a0ae4b07c98581c3b44"}, {"problem": 92, "code": "(fn [x]\n    (let [letters {\"I\" 1, \"V\" 5, \"X\" 10 \"L\" 50 \"C\" 100 \"D\" 500 \"M\" 1000}\n          numbers (map #(get letters (str \"\" %)) (seq x))\n          result_numbers \n          (reduce (fn [acc item]\n            ;; lastitem - \u043f\u043e\u0441\u043b\u0435\u0434\u043d\u0438\u0439 \u044d\u043b\u043c\u0435\u043d\u0442 \u0430\u043a\u043a\u0443\u043c\u0443\u043b\u044f\u0442\u043e\u0440, \u0430\u0431\u0441\u043e\u043b\u044e\u0442\u043d\u043e\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435\n            (let [lastitem (max (last acc) (* -1 (last acc)))]\n              (if (< item lastitem) (conj acc (* -1 item)) (conj acc item)))) \n                  [0] (reverse numbers))]\n        (apply + result_numbers)))", "user": "5a64dcabe4b0512ff01cd9a9"}, {"problem": 92, "code": "(fn [s]\n  (apply + (reduce #(if (< (peek %) %2)\n                      (conj (pop %) (- (peek %)) %2)\n                      (conj % %2))\n                    [0]\n                    (map {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000} s))))", "user": "5c1aadcde4b01240ff567209"}, {"problem": 92, "code": "(fn numerals [coll]\n  (let [m {\\I 1\n           \\V 5\n           \\X 10\n           \\L 50\n           \\C 100\n           \\D 500\n           \\M 1000}\n        numbers (->> coll\n                     (map m)\n                     (partition-by identity)\n                     (map (partial apply +)))]\n    (apply +  (reduce\n               (fn [accm n]\n                 (cond\n                   (empty? accm) (list n)\n                   (> (first accm) n) (conj accm n)\n                   (< (first accm) n) (conj (conj (rest accm) (- (first accm))) n)))\n               '()\n               numbers))))", "user": "5b3251c1e4b025bcb146f317"}, {"problem": 92, "code": "(fn [p] (reduce (fn [v [x y]] ((if (< x y) - +) v x)) 0 (partition 2 1 (conj  (mapv { \\X 10 \\I 1 \\V 5 \\D 500 \\C 100 \\M 1000 \\L 50 } p) 0))))", "user": "5c379636e4b0d62ef62d9f76"}, {"problem": 92, "code": "(fn [arg]\n  (let [m {\\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1}]\n    (loop [[f & rst] arg r 0]\n        (cond\n          (nil? f) r\n          (empty? rst) (+ r (m f))\n          true (let [f' (m f)\n                     op (if (< f' (m (first rst))) - +)] \n                  (recur rst (op r f')))))))", "user": "4dd6d7ee535d2dad7130b5cb"}, {"problem": 92, "code": "(fn roman-numeral->int [numeral]\n  (let [digit-value {\\I 1\n                     \\V 5\n                     \\X 10\n                     \\L 50\n                     \\C 100\n                     \\D 500\n                     \\M 1000}]\n    (first (reduce (fn [[value previous-digit] next-digit] \n                     [(if (> next-digit previous-digit) \n                        (+ value (- next-digit previous-digit previous-digit))\n                        (+ value next-digit))\n                      next-digit]) \n                   [0 Integer/MAX_VALUE] \n                   (map digit-value numeral)))))", "user": "5c506951e4b0f9f7a8770ec5"}, {"problem": 92, "code": "(fn write-roman [r]\n  (let [roman->decimal {\\D 500 \\C 100 \\X 10 \\V 5 \\I 1 \\M 1000 \\L 50}]\n    (->>\n     (loop [prev nil [r & rs] (map roman->decimal r) acc []]\n       (cond\n         (nil? r)\n         (conj acc prev)\n\n         (and (not (nil? prev)) (< prev r))\n         (recur nil rs (conj acc (- r prev)))\n\n         :else\n         (recur r   rs (conj acc prev))))\n     (filter identity)\n     (reduce +))))", "user": "5a257747e4b07f18be40aa1f"}, {"problem": 92, "code": "(fn deromanize [n] (let [\n                                 digits {\\I 1 \\V 5 \\L 50 \\X 10 \\C 100 \\D 500 \\M 1000}\n                                 ] (cond\n                                    (= n \"\") 0\n                                    (= (count n) 1) (digits (first n))\n                                    :else (\n                                            (cond\n                                            (>= (digits (first n)) (digits (first (rest n)))) + :else -)\n                                            (deromanize (apply str (rest n))) (digits (first n))\n                                            ))\n                             ))", "user": "5c7c1d8ee4b0d597f478ca88"}, {"problem": 92, "code": "(fn [numerals]\n    (let [num->dec {\"I\" 1 \"V\" 5 \"X\" 10 \"L\" 50 \"C\" 100 \"D\" 500 \"M\" 1000}\n          digits (map #(get num->dec %) (reverse (re-seq #\"\\w\" numerals)))]\n      (loop [d digits\n             p nil\n             result 0]\n        (if (empty? d)\n          result\n          (if (and p (< (first d) p))\n            (recur (rest d) (first d) (- result (first d)))\n            (recur (rest d) (first d) (+ result (first d))))))))", "user": "5b72b36ce4b047b03b2036a9"}, {"problem": 92, "code": "(fn [v]\n  (loop [o 0 [f s & r] v]\n    (let [l {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}\n          F (l f 0) S (l s 0)]\n      (if s\n        (if (< F S)\n            (recur (+ o (- S F)) r)\n            (recur (+ o F) (cons s r)))\n        (+ o F)))))", "user": "5a244240e4b0ff51aa4b32e9"}, {"problem": 92, "code": "#(let [z (zipmap [\"I\" \"V\" \"X\" \"L\" \"C\" \"D\" \"M\"] [1 5 10 50 100 500 1000])]\n \n (loop[c (map z (map str %)) r 0]\n     (cond\n       (= (count c) 1) (+ r (first c))\n       (>=(first c)(second c)) (recur (rest c)(+ r (first c)))\n       (< (first c)(second c)) (recur (rest c)(- r (first c)))\n       )))", "user": "5c683fb5e4b0fca0c16226d5"}, {"problem": 92, "code": "(let [dict {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]\n    (fn [s]\n      (loop [ns (->> s (map dict) reverse) pre 0 result 0]\n        (if-let [[n & ns] (seq ns)]\n          (recur ns n (+ result (if (<= pre n) n (- n))))\n          result))))", "user": "5c995fa4e4b048ec896c5a96"}, {"problem": 92, "code": "(fn roman->decimal [s]\n  (->> s\n       (partition-by identity)\n       (mapv (juxt #(-> % first {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}) \n                   count))\n       (#(into % [[]]))\n       (partition 2 1)\n       (reduce (fn [acc [[decimal-value size] [following-value _]]]\n                 ((if (> (or following-value 0) decimal-value) - +)\n                   acc\n                   (* decimal-value size)))\n               0)))", "user": "561d8936e4b064ca9f4b16b2"}, {"problem": 92, "code": "(fn readroman [s]\n  (let [rn {\\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1}]\n    (loop [sum 0 rd (first s) s (rest s)]\n      (if (empty? s)\n        (+ sum (rn rd))\n        (if (< (rn rd) (rn (first s)))\n          (recur (- sum (rn rd)) (first s) (rest s))\n          (recur (+ sum (rn rd)) (first s) (rest s)))))))", "user": "5cab33e7e4b048ec896c5c48"}, {"problem": 92, "code": ";; http://www.4clojure.com/problem/92\n(fn roman-to-dec\n  [roman-str]\n  (let [roman-map {\"M\" 1000 \"D\" 500 \"C\" 100 \"L\" 50 \"X\" 10 \"V\" 5 \"I\" 1}\n        dec-coll (map #(* (count %) (roman-map (str (first %)))) (partition-by identity roman-str))]\n    ;(println dec-coll)\n    (loop [[h & r] dec-coll\n           sum 0\n           l nil]\n      (if (nil? h)\n        sum\n        (if (nil? l)\n          (recur r (+ sum h) h)\n          (if (> h l)\n            (recur r (+ sum (- h (* 2 l))) nil)\n            (recur r (+ sum h) h)))))))", "user": "5c92105ce4b048ec896c59f7"}, {"problem": 92, "code": "(fn parse-roman[roman]\n  (loop [[a b & rest :as all] roman\n         acc 0]\n    (case a\n      \\M (recur (next all) (+ acc 1000))\n      \\D (recur (next all) (+ acc 500))\n      \\C (case b\n           \\M (recur (nnext all) (+ acc 900))\n           \\D (recur (nnext all) (+ acc 400))\n           (recur (next all) (+ acc 100)))\n\n      \\L (recur (next all) (+ acc 50))\n      \\X (case b\n           \\C (recur (nnext all) (+ acc 90))\n           \\L (recur (nnext all) (+ acc 40))\n           (recur (next all) (+ acc 10)))\n      \\V (recur (next all) (+ acc 5))\n      \\I (case b\n           \\X (recur (nnext all) (+ acc 9))\n           \\V (recur (nnext all) (+ acc 4))\n           (recur (next all) (+ acc 1))\n           )\n acc)))", "user": "5c950334e4b048ec896c5a44"}, {"problem": 92, "code": "{\"XIV\" 14 \"DCCCXXVII\" 827 \"MMMCMXCIX\" 3999 \"XLVIII\" 48}", "user": "5c1c08cde4b01240ff567219"}, {"problem": 92, "code": "(fn [s]\n    (let [subtractives {\"IV\" \"IIII\", \"IX\" \"VIIII\", \"XL\" \"XXXX\", \"XC\" \"LXXXX\", \"CD\" \"CCCC\", \"CM\" \"DCCCC\"}\n          char-value-map {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]\n      (->>\n        (reduce\n          (fn [s [from to]] (clojure.string/replace s (re-pattern from) to))\n          s\n          subtractives)\n        (map char-value-map)\n        (apply +))))", "user": "4f43b992e4b0d7d3c9f3fd2c"}, {"problem": 92, "code": "(fn [roman]\n ((fn r [acc [fst snd & rst :as xs]]\n   (if (nil? snd)\n     (apply + acc xs)\n     (if (< fst snd)\n       (r (+ acc (- snd fst)) rst)\n       (r (+ acc fst) (rest xs)))))\n  0\n  (map (partial get {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000}) roman)))", "user": "5b64370ae4b0c6492753e73c"}, {"problem": 92, "code": "(fn pb-92 [romain]\n  (let [romain-digits {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000}]\n    (->> romain\n         (map #(get romain-digits %))\n         (reductions (fn [acc e]\n                       (if (or (empty? acc) (>= (last acc) e))\n                         (conj acc e)\n                         (conj acc (* -2 (last acc)) e)))\n                     [])\n         last\n         (reduce +))))", "user": "5cf935f4e4b0b71b1d808a8f"}, {"problem": 92, "code": "(fn roman-numerals->digits [roman-numerals]\n  (let [roman-numeral->digit {\\M 1000\n                              \\D 500\n                              \\C 100\n                              \\L 50\n                              \\X 10\n                              \\V 5\n                              \\I 1}\n        raw-digits (map roman-numeral->digit roman-numerals)\n        subtractions (->> raw-digits\n                          (partition 2 1)\n                          (filter (partial apply <))\n                          (map (comp - (partial * 2) first)))]\n    (+ (apply + raw-digits) (apply + subtractions))))", "user": "53504fe6e4b084c2834f4ada"}, {"problem": 92, "code": "(fn\n  [s]\n  (let [lookup {\\I 1\n                \\V 5\n                \\X 10\n                \\L 50\n                \\C 100\n                \\D 500\n                \\M 1000}\n        s      (apply str (reverse (clojure.string/upper-case s)))]\n    (loop [sum 0\n           [n & remaining] s]\n      (if n\n        (let [val (get lookup n)\n              sub (and remaining (get lookup (first remaining)))\n              sub (when (and sub (< sub val)) sub)]\n          (if sub\n            (recur (+ sum (- val sub)) (rest remaining))\n            (recur (+ sum val) remaining)))\n        sum))))", "user": "570c8ac3e4b0b0fb43fd06ca"}, {"problem": 92, "code": "(fn roman-numeral-string-to-int\n  [c]\n  (+ (case (first c)\n       \\M      (+ 1000 (roman-numeral-string-to-int (rest c)))\n       \\D      (+  500 (roman-numeral-string-to-int (rest c)))\n       \\C (case (first (rest c))\n            \\M (+  900 (roman-numeral-string-to-int (rest (rest c))))\n            \\D (+  400 (roman-numeral-string-to-int (rest (rest c))))\n               (+  100 (roman-numeral-string-to-int (rest c))))\n       \\L      (+   50 (roman-numeral-string-to-int (rest c)))\n       \\X (case (first (rest c))\n            \\C (+   90 (roman-numeral-string-to-int (rest (rest c))))\n            \\L (+   40 (roman-numeral-string-to-int (rest (rest c))))\n               (+   10 (roman-numeral-string-to-int (rest c))))\n       \\V      (+    5 (roman-numeral-string-to-int (rest c)))\n       \\I (case (first (rest c))\n            \\X (+    9 (roman-numeral-string-to-int (rest (rest c))))\n            \\V (+    4 (roman-numeral-string-to-int (rest (rest c))))\n               (+    1 (roman-numeral-string-to-int (rest c))))\n       0)))", "user": "5d1b2b7de4b02ea6f0fb697a"}, {"problem": 92, "code": "(fn [roman]\n\t(let [[[a & x] y]\n\t\t(apply map list (partition 2 (re-matches #\"(M*)(CM)?(D*)(CD)?(C*)(XC)?(L*)(XL)?(X*)(IX)?(V*)(IV)?(I*)\" roman)))]\n\t\t(+\t(reduce + (map * [900 400 90 40 9 4] (map #(if % 1 0) x)))\n\t\t\t(reduce + (map * [1000 500 100 50 10 5 1] (map count y)))\n\t\t)\n\t)\n)\n\n;[1000 900 500 400 100 90 50 40 10 9 5 4 1]\n;[\"M\" \"CM\" \"D\" \"CD\" \"C\" \"XC\" \"L\" \"XL\" \"X\" \"IX\" \"V\" \"IV\" \"I\"]", "user": "5d2201b8e4b02ea6f0fb69ed"}, {"problem": 92, "code": "(fn [s]\n  (let [roman-vals {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000}\n        rv (map roman-vals (seq s))]\n    (apply + (map #(if (> %2 %1) (- %1) %1) rv (conj (into [] (rest rv)) 0)))))", "user": "5bb25684e4b0a20761a2350d"}, {"problem": 92, "code": "(fn [s]\n  (reduce + (map #(*\n                  (get {\"O\" 0, \"I\" 1, \"V\" 5, \"X\" 10, \"L\" 50, \"C\" 100, \"D\" 500 \"M\" 1000} (str (first %)))\n                  (if (or\n                        (and\n                          (= (str (first %)) \"I\")\n                          (or (= (str (second %)) \"V\")\n                              (= (str (second %)) \"X\")))\n                        (and\n                          (= (str (first %)) \"X\")\n                          (or (= (str (second %)) \"L\")\n                              (= (str (second %)) \"C\")))\n                        (and\n                          (= (str (first %)) \"C\")\n                          (or (= (str (second %)) \"D\")\n                              (= (str (second %)) \"M\"))))\n                    -1 1))\n               (partition 2 1 (seq (str s \"O\"))))))", "user": "55d7312ee4b0e31453f64a9f"}, {"problem": 92, "code": "(fn [s]\n  (let [numerals {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000}\n        add-numeral (fn [n t]\n                      (if (> n (* 4 t))\n                        (- n t)\n                        (+ t n)))\n        ]\n    (reduce add-numeral (map numerals (reverse s)))\n    ))", "user": "5baaae06e4b0a20761a23464"}, {"problem": 92, "code": "(fn [x]\n  (let [data {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100  \\D 500 \\M 1000}\n        rx (reverse x)]\n    (loop [[s & ss] (rest rx) t (data (first rx)) h 0]\n      (if s\n        (recur ss (if (> t (data s)) (* -1 (data s)) (data s))\n                  (+ h t))\n        (+ h t)))))", "user": "5c2836ebe4b07e362c2305d4"}, {"problem": 92, "code": "(fn read-numeral [x]\n   (let [NUMERALS ((comp\n                    (partial into {})\n                    (partial map-indexed (fn [ix x] [x ix])))\n                   (for [thousands (->> (range 4)\n                                        (map #(repeat % \"M\"))\n                                        (map (partial apply str)))\n                         hundreds [\"\" \"C\" \"CC\" \"CCC\" \"CD\" \"D\" \"DC\" \"DCC\" \"DCCC\" \"CM\"]\n                         tens [\"\" \"X\" \"XX\" \"XXX\" \"XL\" \"L\" \"LX\" \"LXX\" \"LXXX\" \"XC\"]\n                         ones [\"\" \"I\" \"II\" \"III\" \"IV\" \"V\" \"VI\" \"VII\" \"VIII\" \"IX\"]]\n                     (str thousands hundreds tens ones)))]\n     (NUMERALS x)))", "user": "5d4b2155e4b0776584bd6f28"}, {"problem": 92, "code": "(fn roman-numerals [rn]\n  (let [table {\\I 1\n               \\V 5\n               \\X 10\n               \\L 50\n               \\C 100\n               \\D 500\n               \\M 1000}]\n    (loop [[n & ns] (map table rn)\n           prev nil\n           sum 0]\n      (cond\n        (nil? n) sum\n        (and prev (> n prev)) (recur ns n (- (+ sum n) (* 2 prev)))\n        :else (recur ns n (+ sum n))))))", "user": "5d6042f2e4b0c9e5857d5006"}, {"problem": 92, "code": "(fn [rn]\n    (let [rom {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000}\n          nms (map #(rom %) rn)]\n      (->> (map (fn [x y] (if (>= x y) x (- x))) nms (concat (rest nms) [0]))\n           (apply +))))", "user": "5d29c06be4b01671435dbc6b"}, {"problem": 92, "code": "(fn read-roman [s]\n  (let [numerals {\\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1}\n        nums (partition 2 1 (concat (map numerals s) [0]))]\n    (reduce (fn [sum [a b]] ((if (< a b) - +) sum a)) 0 nums)))", "user": "5d67c955e4b0db5d338d15f7"}, {"problem": 92, "code": "(fn unroman [s]\n  (let [state0 {:value 0\n                \\I {:value 1\n                     \\I {:value 2\n                          \\I {:value 3}}\n                     \\V {:value 4}\n                     \\X {:value 9}}\n                \\V {:value 5}\n                \\X {:value 10\n                     \\X {:value 20\n                          \\X {:value 30}}\n                     \\L {:value 40}\n                     \\C {:value 90}}\n                \\L {:value 50}\n                \\C {:value 100\n                     \\C {:value 200\n                          \\C {:value 300}}\n                     \\D {:value 400}\n                     \\M {:value 900}}\n                \\D {:value 500}\n                \\M {:value 1000}}]\n    (loop [n 0 state state0 s s]\n      (if (empty? s)\n        (+ n (:value state))\n        (if (contains? state (first s))\n          (recur n (get state (first s)) (rest s))\n          (recur (+ n (:value state)) state0 s))))))", "user": "5d0bb4fae4b0cc9c91588237"}, {"problem": 92, "code": "(fn [roman] (let [num-map {\\I 1, \\X 10, \\C 100, \\M 1000\n                                                \\V 5, \\L 50, \\D 500}\n                                       num-map (reverse (mapv #(get num-map %) (seq roman)))]\n                                   (loop [x num-map\n                                          y (first num-map)]\n                                     (if (empty? x)\n                                       y\n                                       (recur (rest x) (if (second x)\n                                                         (if (> (first x) (second x))\n                                                           (- y (second x))\n                                                           (+ y (second x)))\n                                                         y))))))", "user": "5cf72682e4b0b71b1d808a68"}, {"problem": 92, "code": "(fn [numeral]\n  (let [m (apply hash-map (interleave [\\M   \\D  \\C  \\L \\X \\V \\I]\n                                      [1000 500 100 50 10 5  1]))\n        n (concat (map #(m %) (map char numeral)) [0 0])\n        b (interleave (partition 2 n) (partition 2 (rest n)))\n        ]\n    (loop [p b a 0]\n      (if (empty? p)\n        a\n        (let [[f s] (first p)]\n          (recur (rest p) (if (< f s) (- a f) (+ a f))))))))", "user": "5d52bf29e4b0776584bd6f69"}, {"problem": 92, "code": "(fn\n  [numeral]\n  (let [trans {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100 \\D 500 \\M 1000}]\n    (loop [numeral numeral\n           prev    1001\n           acc     0]\n      (if (empty? numeral)\n        acc\n        (let [n (trans (first numeral))\n              m (if (> n prev) (- n (* prev 2)) n)]\n          (recur (rest numeral) m (+ acc m)))))))", "user": "5d38a4dde4b01671435dbd4a"}, {"problem": 92, "code": "(fn [input]\n  (let [symbols {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}\n        tokens (replace symbols input)\n        compute (fn [[x & xs] acc]\n                 (cond\n                   (empty? xs) (+ x acc)\n                   (>= x (first xs)) (recur xs (+ acc x))\n                   :else (recur xs (- acc x))))]\n    (compute tokens 0)))", "user": "5d80fa37e4b0915913b1d374"}, {"problem": 92, "code": "(fn [s]\n   (let [t [\"MMM\" 3000\n            \"MM\"  2000\n            \"M\"   1000\n            \"CM\"   900\n            \"DCCC\" 800\n            \"DCC\"  700\n            \"DC\"   600\n            \"D\"    500\n            \"CD\"   400\n            \"CCC\"  300\n            \"CC\"   200\n            \"C\"    100\n            \"XC\"    90\n            \"LXXX\"  80\n            \"LXX\"   70\n            \"LX\"    60\n            \"L\"     50\n            \"XL\"    40\n            \"XXX\"   30\n            \"XX\"    20\n            \"X\"     10\n            \"IX\"     9\n            \"VIII\"   8\n            \"VII\"    7\n            \"VI\"     6\n            \"V\"      5\n            \"IV\"     4\n            \"III\"    3\n            \"II\"     2\n            \"I\"      1]\n         m (apply hash-map t)]\n     (loop [s s r 0 n 1]\n       (if (empty? s)\n         r\n         (if (and (<= n (count s)) (m (apply str (take n s))))\n           (recur s r (inc n))\n           (recur (drop (dec n) s) (+ r (m (apply str (take (dec n) s)))) 1))))))\n\n; (fn roman [s]\n;   (let [z   {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000}\n;         zd  {\"IV\" \"IIII\", \"IX\" \"VIIII\" , \"XL\" \"XXXX\" , \"XC\" \"LXXXX\" , \"CD\" \"CCCC\", \"CM\" \"DCCCC\"}]\n;     (reduce #(+ %1 (z %2)) 0 \n;       (reduce-kv #(clojure.string/replace %1 %2 %3) s zd))))\n;       \n; (fn [x]\n;   (let\n;     [R {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000}]\n;     (reduce +\n;       (map\n;         (partial reduce #(- (R %2) %1) 0)\n;         (re-seq #\"IV|IX|XL|XC|XM|CD|CM|[IVXLCDM]\" x)))))", "user": "557c6ca6e4b05c286339e0c4"}, {"problem": 92, "code": "(let [values {\\M 1000\n              \\D 500\n              \\C 100\n              \\L 50\n              \\X 10\n              \\V 5\n              \\I 1}]\n  (fn [s]\n    (let [arabic (map values s)]\n      (->> arabic\n           (map-indexed\n             (fn [i x]\n               (if (< x (nth arabic (inc i) 0))\n                 (- x)\n                 x)))\n           (apply +)))))", "user": "58b2c435e4b0ebc645576d11"}, {"problem": 92, "code": ";; I am not entirely sure to which symbols the subtractive rule applies.\n;; looks like maybe only these? IV 4 IX 9 XL 40 XC 90 CD 400 CM 900\n(fn roman->int [roman-in]\n  (let [numeral-components (-> (reduce\n                                (fn [acc compound]\n                                  (clojure.string/replace\n                                   acc\n                                   (re-pattern (str \"(\" (first compound) \"),(\" (last compound) \")\"))\n                                   \"$1$2\"))\n                                (apply str (interpose \",\" roman-in))\n                                '(\"IV\" \"IX\" \"XL\" \"XC\" \"CD\" \"CM\"))\n                               (clojure.string/split #\",\"))]\n    (reduce (fn [acc n]\n              (+ acc (get {\"I\" 1 \"V\" 5 \"X\" 10 \"L\" 50 \"C\" 100 \"D\" 500 \"M\" 1000\n                           \"IV\" 4 \"IX\" 9 \"XL\" 40 \"XC\" 90 \"CD\" 400 \"CM\" 900} n)))\n            0\n            numeral-components)))", "user": "5d7aa22ee4b02e6b30c9354e"}, {"problem": 92, "code": "(fn from-roman [s]\n  (let [coins\n        {\"M\" 1000 \"CM\" -100 \"D\" 500 \"CD\" -100 \"C\" 100 \"XC\" -10 \"L\" 50 \"XL\" -10 \"X\" 10 \"IX\" -1 \"V\" 5 \"IV\" -1 \"I\" 1}\n        coin-to-val (fn [s] (or (get coins s) (get coins (subs s 0 1))))]\n    (apply + (map\n              coin-to-val\n              (map #(apply str %) (partition-all 2 1 s))))))", "user": "5d9c1226e4b0d3f9b434ad51"}, {"problem": 92, "code": "(fn [s]\n  (let [roman-to-dec {\"I\" 1 \"IV\" 4 \"V\" 5 \"IX\" 9 \"X\" 10 \"XL\" 40 \"L\" 50 \"XC\" 90\n                      \"C\" 100 \"CD\" 400 \"D\" 500 \"CM\" 900 \"M\" 1000}]\n    (loop [s s n 0]\n      (if (empty? s)\n        n\n        (if-let [d (get roman-to-dec (apply str (take 2 s)))]\n          (recur (drop 2 s) (+ n d))\n          (recur (rest s) (+ n (get roman-to-dec (str (first s))))))))))", "user": "5d81b40ce4b0915913b1d379"}, {"problem": 92, "code": "(fn [roman]\n  (let [mapping (array-map\n                 \"MMM\" 3000 \"MM\" 2000 \"M\" 1000\n                 \"CM\" 900 \"DCCC\" 800 \"DCC\" 700 \"DC\" 600 \"D\" 500 \"CD\" 400 \"CCC\" 300 \"CC\" 200 \"C\" 100\n                 \"XC\" 90 \"LXXX\" 80 \"LXX\" 70 \"LX\" 60 \"L\" 50 \"XL\" 40 \"XXX\" 30 \"XX\" 20 \"X\" 10\n                 \"IX\" 9 \"VIII\" 8 \"VII\" 7 \"VI\" 6 \"V\" 5 \"IV\" 4 \"III\" 3 \"II\" 2 \"I\" 1)\n        re (re-pattern (clojure.string/join \"|\" (keys mapping)))\n        matches (re-seq re roman)]\n        (apply + (map mapping matches))))", "user": "5db92996e4b010eb3c36cd50"}, {"problem": 92, "code": "(fn roman_numerals [s] {:pre (string? s)}\n    (let\n        [\n            nums (replace (zipmap \"MDCLXVI\" [1000 500 100 50 10 5 1]) s)\n            nums (map #(if (< %1 %2) (- %1) %1) nums (concat (rest nums) [(last nums)]) )\n        ]\n        (apply + nums)\n    )\n)", "user": "5db7376fe4b010eb3c36cd43"}, {"problem": 92, "code": "(fn [s]\n (let [a [1000,900,500,400,100,90,50,40,10,9,5,4,1]\n       c (zipmap [\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"] a )]\n  (loop [n 0  s s]\n    (cond\n    (empty? s) n \n    (= 1 (count s)) (+ n (c s))\n    (c (subs s 0 2)) (recur (+ n (c (subs s 0 2))) (subs s 2))\n    :else (recur (+ n (c (subs s 0 1))) (subs s 1))))))", "user": "5dc12b0ae4b0e59a23173d84"}, {"problem": 92, "code": "(fn [n]\n  (let [foo {\"I\" 1\n             \"V\" 5\n             \"X\" 10\n             \"L\" 50\n             \"C\" 100\n             \"D\" 500\n             \"M\" 1000}]\n    (loop [sum 0\n           prev nil\n           [curr & r] n]\n      (if (nil? curr)\n        sum\n        (let [curr (get foo (str curr))\n              actual (if (and prev (< prev curr))\n                       (- curr prev prev)\n                       curr)]\n          (recur (+ sum actual) curr r))))))", "user": "5cf6522be4b0b71b1d808a58"}, {"problem": 92, "code": "(fn [r-num]\n  (-> r-num\n      (clojure.string/replace #\"IV\" \"4,\")\n      (clojure.string/replace #\"IX\" \"9,\")\n      (clojure.string/replace #\"XL\" \"40,\")\n      (clojure.string/replace #\"XC\" \"90,\")\n      (clojure.string/replace #\"CM\" \"900,\")\n      (clojure.string/replace #\"I\" \"1,\")\n      (clojure.string/replace #\"V\" \"5,\")\n      (clojure.string/replace #\"X\" \"10,\")\n      (clojure.string/replace #\"L\" \"50,\")\n      (clojure.string/replace #\"C\" \"100,\")\n      (clojure.string/replace #\"D\" \"500,\")\n      (clojure.string/replace #\"M\" \"1000,\")\n      (clojure.string/split #\",\")\n      ((partial map read-string))\n      ((partial reduce +))\n      ))", "user": "5dd90651e4b0948ae9d9ad97"}, {"problem": 92, "code": "#(let [m {\"I\" 1 \"IV\" 4 \"V\" 5 \"IX\" 9 \"X\" 10 \"XL\" 40 \"L\" 50 \"XC\" 90 \"C\" 100 \"CD\" 400 \"D\" 500 \"CM\" 900 \"M\" 1000}]\n   (reduce + (map m (re-seq #\"IV|IX|XL|XC|CD|CM|I|V|X|L|C|D|M\" %))))", "user": "5dd60c58e4b0948ae9d9ad7c"}, {"problem": 92, "code": "(fn [x]\n  (let [m {\"I\" 1 \"IV\" 4 \"V\" 5 \"IX\" 9 \"X\" 10 \"XL\" 40 \"L\" 50 \"XC\" 90 \"C\" 100 \"CD\" 400 \"D\" 500 \"CM\" 900 \"M\" 1000}]\n    (reduce + (map m (re-seq #\"IV|IX|XL|XC|XM|CD|CM|[IVXLCDM]\" x)))))", "user": "529dfc6de4b04e0c58e87b8a"}, {"problem": 92, "code": "(fn p-92 [s]\n ; (println \"Called with s \" s)\n  (let [add-rest (fn [s chop-ct n]\n                   (+ n (p-92 (subs s chop-ct))))]\n    (cond (empty? s) 0\n          (.startsWith s \"CM\") (add-rest s 2 900)\n          (.startsWith s \"DM\") (add-rest s 2 500)\n          (.startsWith s \"XC\") (add-rest s 2 90)\n          (.startsWith s \"XL\") (add-rest s 2 40)\n          (.startsWith s \"IX\") (add-rest s 2 9)\n          (.startsWith s \"IV\") (add-rest s 2 4)\n          (.startsWith s \"M\") (add-rest s 1 1000)\n          (.startsWith s \"D\") (add-rest s 1 500)\n          (.startsWith s \"C\") (add-rest s 1 100)\n          (.startsWith s \"L\") (add-rest s 1 50)\n          (.startsWith s \"X\") (add-rest s 1 10)\n          (.startsWith s \"V\") (add-rest s 1 5)\n          (.startsWith s \"I\") (add-rest s 1 1)\n          :else nil\n          )))", "user": "5bfc9037e4b0bdcf453d15f2"}, {"problem": 92, "code": "(fn roman-numerals [word]\n  (let [letter-2-num (fn [char]\n                       (cond \n                         (= \\I char) 1\n                         (= \\V char) 5\n                         (= \\X char) 10\n                         (= \\L char) 50\n                         (= \\C char) 100\n                         (= \\D char) 500\n                         :else 1000)\n                       )\n        num-sequ (reverse (map letter-2-num word))\n        cur (first num-sequ)\n        nums (rest num-sequ)]\n    (loop [cur cur\n           [next & others] nums\n           sum cur]\n      (if (nil? next)\n        sum\n        (if (< next cur)\n          (recur cur others (- sum next))\n          (recur next others (+ sum next)))))))", "user": "5df0c6ffe4b093ff717275c2"}, {"problem": 92, "code": "(fn read-roman [s]\n  (let [numerals {\\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1}\n        nums (partition 2 1 (concat (map numerals s) [0]))]\n    (reduce (fn [sum [a b]] ((if (< a b) - +) sum a)) 0 nums)))", "user": "5e00b6e7e4b0a607a9a45d2b"}, {"problem": 92, "code": "(fn roman-number [string]\n  (loop [s (apply list string)\n         n 0]\n    (cond\n      (empty? s) n\n      (and (= (first s) \\I) (#{\\V \\X} (second s))) (recur (rest s) (+ n -1))\n      (= (first s) \\I) (recur (rest s) (+ n 1))\n      (= (first s) \\V) (recur (rest s) (+ n 5))\n      (and (= (first s) \\X) (#{\\L \\C} (second s))) (recur (rest s) (+ n -10))\n      (= (first s) \\X) (recur (rest s) (+ n 10))\n      (= (first s) \\L) (recur (rest s) (+ n 50))\n      (and (= (first s) \\C) (#{\\D \\M} (second s))) (recur (rest s) (+ n -100))\n      (= (first s) \\C) (recur (rest s) (+ n 100))\n      (= (first s) \\D) (recur (rest s) (+ n 500))\n      (= (first s) \\M) (recur (rest s) (+ n 1000)))))", "user": "5e0d948fe4b099d064962f98"}, {"problem": 92, "code": "(fn roman\n     ([i-literal] (roman 0 i-literal))\n     ([i-result i-literal]\n      (if (zero? (count i-literal))\n        i-result\n        (let [\n              v-map {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500 \\M 1000}\n              head (first i-literal)\n              tail (rest i-literal)\n              t-head (first tail)\n              ]\n          (if (and (not (nil? t-head)) (> (get v-map t-head) (get v-map head)))\n            (roman (+ i-result (- (get v-map t-head) (get v-map head))) (rest tail))\n            (roman (+ i-result (get v-map head)) tail))))))", "user": "5d9c9446e4b0eb781811cdae"}, {"problem": 92, "code": "(fn [s]\n  (loop [total 0 largest 0 s (reverse s)]\n    (if (empty? s)\n      total\n      (let [letter (first s)\n            value ({\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000} letter)]\n        (recur ( (if (>= value largest) + -) total value)\n               (max largest value)\n               (rest s))))))", "user": "5e078ba7e4b0978307768fb6"}, {"problem": 92, "code": "(fn [s]\n    (let [values {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]\n      (->> (map values s)\n           (reduce (fn [{:keys [total previous] :as result} v]\n                     (let [maybe-corrected (if (and previous (< previous v)) (- v previous previous) v)]\n                       (assoc result :total (+ total maybe-corrected) :previous v))) {:total 0 :previous nil})\n           (:total))))", "user": "5d236215e4b02ea6f0fb6a09"}, {"problem": 92, "code": "(fn rom [numeral]\n  (first (reduce (fn [[s t] x]\n                   [(+ s (if (> x t)\n                           (- x t t)\n                           x)) x])\n                 [0 0]\n                 (map (zipmap\n                       \"IVXLCDM\"\n                       (reduce \n                        (fn [x _]\n                        (into [1 5] (map (partial * 10) x))) [] (range 4))) numeral))))", "user": "5d929ceae4b0915913b1d412"}, {"problem": 92, "code": "(fn [roman-string] (let [roman-to-arabic {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}] (loop [numerals (into [] roman-string) total 0 previous 0] (if (empty? numerals) total (let [current (roman-to-arabic (peek numerals))] (if (> previous current) (recur (pop numerals) (- total current) current) (recur (pop numerals) (+ total current) current)))))))", "user": "5e1cc888e4b0dc959400853d"}, {"problem": 92, "code": "(fn f92 [s]\n    (if  (empty? s)\n      0\n      (let [v          {\\I 1\n                        \\V 5\n                        \\X 10\n                        \\L 50\n                        \\D 500\n                        \\C 100\n                        \\M 1000}\n            [car cadr] (take 2 (seq s))\n            r          (subs s 1)]\n        (if\n         (< (v car) (get v cadr 0)) (- (f92 r) (v car))\n         (+ (f92 r) (v car))))))", "user": "583048d9e4b051871117c007"}, {"problem": 92, "code": "(fn [roman-str]\n  (let [letter-val {\\0 0 ;; for padding last tuple\n                    \\I 1, \\V 5, \\X 10, \\L 50\n                    \\C 100, \\D 500, \\M 1000}\n        letter-tuple->dec (fn [[l r]]\n                            (* (letter-val l)\n                               (if (< (letter-val l) (letter-val r))\n                                 -1\n                                 1)))]\n    (->> roman-str\n         (partition 2 1 [\\0])\n         (map letter-tuple->dec)\n         (reduce + 0))))", "user": "52b52c29e4b0c58976d9ad38"}, {"problem": 92, "code": "(fn rome [s]\n  (let [look {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000}\n        cur (get look (first s))\n        after (get look (second s))]\n  (cond (empty? s) 0\n        (= (count s) 1) cur\n        (> after cur) (+ (- after cur) (rome (drop 2 s)))\n        :else (+ cur (rome (rest s))))))", "user": "5e3a25d4e4b01d43a70e8dde"}, {"problem": 92, "code": "(fn r2n [[a & as]] \n  (let [d (hash-map \\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000)\n        b (first as)]\n    (cond (nil? b) (d a)\n          (<  (d a) (d b)) (- (r2n as) (d a))\n          (>= (d a) (d b)) (+ (d a) (r2n as)))))", "user": "5e2549c8e4b05b4b0151615f"}, {"problem": 92, "code": "(fn [roman-number]\n   (letfn [(digit-map [triad]\n             (let [[x v i] triad]\n               (map #(vector (re-pattern (str \"^\" %1 \"(.*)\")) %2)\n                    [(str i x)\n                     (str v i i i)\n                     (str v i i)\n                     (str v i)\n                     (str v)\n                     (str i v)\n                     (str i i i)\n                     (str i i)\n                     (str i)]\n                    (range 9 0 -1))))\n           (read-digit [s triad]\n             (or (some #(let [[pattern digit] %\n                              [_ found] (re-find pattern s)]\n                          (if found [digit found]))\n                       (digit-map triad)) [0 s]))]\n     (first (reduce\n             (fn [acc triad]\n               (let [[n s] acc\n                     [m t] (read-digit s triad)]\n                 [(+ (* 10 n) m) t]))\n             [0 roman-number]\n             [[\\- \\- \\M]\n              [\\M \\D \\C]\n              [\\C \\L \\X]\n              [\\X \\V \\I]]))))", "user": "5e3ef7d4e4b01d43a70e8e2d"}, {"problem": 92, "code": "(fn [roman]\n  (let [romans {\\I 1\n        \t\t\\V 5\n        \t\t\\X 10\n        \t\t\\L 50\n        \t\t\\C 100\n        \t\t\\D 500\n        \t\t\\M 1000}\n        nums (->> roman reverse (map romans) (cons 0))]\n   \t(->> (partition 2 1 nums)\n         (map (fn [[f s]] (if (> f s) (- s) s)))\n         (reduce +))))", "user": "5cb41c40e4b026601754b911"}, {"problem": 92, "code": "#(let [m {#\"I\" 1 #\"II\" 0 #\"III\" 0 #\"IV\" -2 #\"V\" 5 #\"IX\" -2 #\"X\" 10 #\"XL\" -20 #\"IL\" -2 #\"L\" 50\n#\"XC\" -20 #\"C\" 100 #\"CD\" -200 #\"D\" 500 #\"CM\" -200 #\"M\" 1000}\nf (fn [x] (* (count (re-seq x %)) (m x)))]\n(reduce + 0 (map f (keys m))))", "user": "5e13a6b7e4b099d064963001"}, {"problem": 92, "code": "(fn [rn]\n  (letfn [(value-of [digit look-ahead]\n            (case digit\n              \\M 1000\n              \\D 500\n              \\C (if (#{\\D \\M} look-ahead) -100 100)\n              \\L 50\n              \\X (if (#{\\L \\C} look-ahead) -10 10)\n              \\V 5\n              \\I (if (#{\\V \\X} look-ahead) -1 1))\n            )]\n    (loop [[d & ds] rn\n           sum 0]\n      (if d\n        (recur ds (+ sum (value-of d (first ds))))\n        sum))))", "user": "5eb1c786e4b00a66d4a95201"}, {"problem": 92, "code": "#(apply + (map (fn [[a b]] (if (< a b) (- a) a))\n               (partition 2 1 (conj\n                                (mapv {\\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1} %)\n                                0))))", "user": "4eb70649535d7eef30807373"}, {"problem": 92, "code": "(fn [s]\n    (let [\n          ks [\\A \\I \\V \\X \\L \\C \\D \\M \\Z]\n          vs [ 0, 1, 5, 10, 50, 100, 500, 1000, 100000]\n          nms (into {} (map vector ks vs))]\n      (letfn [(dt [s]\n                (loop [n (first s) r (rest s) val 0 lst \\Z]\n                  (let [nv (get nms n)\n                        lv (get nms lst)\n                        newval (if (>= lv nv) (+ val nv) (- nv val))\n                        ]\n                    ;;(print n \" \" nv \" \" lv \" \" r \" \" val \" \" lst \"\\n\")\n                    (if (empty? r) newval\n                        (recur (first r) (rest r) newval n)))))\n              (lookahead  [s]\n                (let [nv (get nms (first s))\n                      left (apply str (first s) (take-while #(>= nv (get nms %)) (rest s)))\n                      right (apply str (drop (count left) s))]\n                  [left right]))\n              (split-em [s dir acc]\n                ;; (println \"s \" s \" dir \" dir \" acc \" acc)\n                (if (empty? s) acc\n                    (let [n (first s) r (apply str (rest s)) lst (last acc)\n                          nv (get nms n)\n                          lv (get nms lst)\n                          ]\n                      (cond (= dir :n) (cond\n                                         (nil? lv) (split-em r :n (str acc n))\n                                         (> lv nv) (let [[lft rt] (lookahead s)]\n                                                     (if (empty? rt)\n                                                       (str acc lft)\n                                                       (split-em (apply str (rest rt)) :u (str acc \" \" lft (first rt)))))\n                                         (= lv nv) (split-em r :n (str acc n))\n                                         :else (split-em r :u (str acc n)))\n                            (= dir :d) (if (>= lv nv)\n                                         (split-em r :d (str acc n))\n                                         (split-em r :u (str acc n)))\n                            (= dir :u) (if (>= lv nv) (split-em r :d (str acc \" \" n))\n                                           (split-em r :u (str acc n)))))))]\n        (apply + (for [x (clojure.string/split  (split-em s :n \"\") #\" \")] (dt x))))))", "user": "5da71eaee4b000c986472c15"}, {"problem": 92, "code": "(fn [r]    \n  (let [values {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]\n    (loop [n 0 rem r]\n  \t  (if (empty? rem)\n  \t  \tn\n        (let [r1 (values (first rem)) r2 (values (second rem))]\n  \t\t  (if (and r2 (< r1 r2))\n  \t\t\t(recur (+ n (- r2 r1)) (drop 2 rem))\n  \t\t\t(recur (+ n r1) (rest rem))))))))", "user": "564127a9e4b08d4f616f5ef3"}, {"problem": 92, "code": "#(let [symbols {\\I 1, \\V 5, \\X 10\n                  \\L 50, \\C 100, \\D 500\n                  \\M 1000}\n         values (map symbols %)\n         revmax (reverse (reductions max (reverse values)))\n         sign (map (fn [v m] (if (>= v m) 1 -1)) values revmax)]\n     (apply + (map * values sign)))", "user": "5ec3a13ae4b08d0ec38692b9"}, {"problem": 92, "code": "(fn [s]\n  (let [nums {\\I 1\n              \\V 5\n              \\X 10\n              \\L 50\n              \\C 100\n              \\D 500\n              \\M 1000}]\n    (apply +\n           (map (fn [[a b]] (if (< a (or b 0)) (- a) a))\n                (partition-all 2 1\n                               (map nums s))))))", "user": "50ed4626e4b01236b1d4983c"}, {"problem": 92, "code": "#(->> %\n      vec\n      (map {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000})\n      reverse\n      (reduce (fn [[largest sum] elem]\n                [(max elem largest)\n                 ((if (>= elem largest) + -) sum elem)])\n              [0 0])\n      second)", "user": "5ed16f26e4b016b56eae05bb"}, {"problem": 92, "code": "(fn rom [s]\n         (let [pads (str s \"P\")]\n           (cond \n             (empty? s) 0\n             (= (subs pads 0 1) \"M\") (+ 1000 (rom (subs s 1)))\n             (= (subs pads 0 2) \"CM\") (+ 900 (rom (subs s 2)))\n             (= (subs pads 0 1) \"D\") (+ 500 (rom (subs s 1)))\n             (= (subs pads 0 2) \"CD\") (+ 400 (rom (subs s 2)))\n             (= (subs pads 0 1) \"C\") (+ 100 (rom (subs s 1)))\n             (= (subs pads 0 2) \"XC\") (+ 90 (rom (subs s 2)))\n             (= (subs pads 0 1) \"L\") (+ 50 (rom (subs s 1)))\n             (= (subs pads 0 2) \"XL\") (+ 40 (rom (subs s 2)))\n             (= (subs pads 0 1) \"X\") (+ 10 (rom (subs s 1)))\n             (= (subs pads 0 2) \"IX\") (+ 9 (rom (subs s 2)))\n             (= (subs pads 0 1) \"V\") (+ 5 (rom (subs s 1)))\n             (= (subs pads 0 2) \"IV\") (+ 4 (rom (subs s 2)))\n             (= (subs pads 0 1) \"I\") (+ 1 (rom (subs s 1)))\n             )))", "user": "5ec819b4e4b08d0ec38692e2"}, {"problem": 92, "code": "(fn [s]\n  (let [rom->int {\"I\" 1, \"IV\" 4, \"V\" 5, \"IX\" 9, \"X\" 10,\n        \"XL\" 40, \"L\" 50, \"XC\" 90, \"C\" 100, \"CD\" 400, \"D\" 500, \"CM\" 900, \"M\" 1000} \n        rom-re (->> (keys rom->int) (sort-by (comp - count)) (clojure.string/join \"|\") re-pattern)]\n    (->> (re-seq rom-re s) (map rom->int) (apply +))))", "user": "5ec6de19e4b08d0ec38692da"}, {"problem": 92, "code": "(fn [input]\n  (let [roman->decimal-pairs [[\"M\"  1000]\n   \t\t\t\t\t\t\t  [\"CM\"  900]\n   \t\t\t\t\t\t      [\"D\"   500]\n   \t\t\t\t\t\t\t  [\"CD\"  400]\n   \t\t\t\t\t\t\t  [\"C\"   100]\n   \t\t\t\t\t\t\t  [\"XC\"   90]\n   \t\t\t\t\t\t\t  [\"L\"    50]\n   \t\t\t\t\t\t\t  [\"XL\"   40]\n   \t\t\t\t\t\t\t  [\"X\"    10]\n   \t\t\t\t\t\t\t  [\"IX\"    9]\n   \t\t\t\t\t\t\t  [\"V\"     5]\n   \t\t\t\t\t\t\t  [\"IV\"    4]\n   \t\t\t\t\t\t\t  [\"I\"     1]]\n        roman->decimal-map (into {} roman->decimal-pairs)]\n  \t(->> (-> (apply str (interpose \"|\" (map first roman->decimal-pairs)))\n           \t  re-pattern\n              (re-seq input))\n       (reduce #(+ %1 (get roman->decimal-map %2)) 0))))", "user": "5dc88a38e4b02f9375f4e1db"}, {"problem": 92, "code": "(fn [r]\n   (letfn [(next-val [r]\n             (let [syms '((\"CM\" 900)\n                          (\"M\" 1000)\n                          (\"CD\" 400)\n                          (\"D\" 500)\n                          (\"XC\" 90)\n                          (\"C\" 100)\n                          (\"XL\" 40)\n                          (\"L\" 50)\n                          (\"IX\" 9)\n                          (\"X\" 10)\n                          (\"IV\" 4)\n                          (\"V\" 5)\n                          (\"I\" 1))]\n               (some #(if (.startsWith r (first %)) %) syms)))]\n     (loop [r r\n            val 0]\n       (if (empty? r) val\n           (let [sym (next-val r)]\n             (recur (.substring r (count (first sym)))\n                    (+ val (second sym))))))))", "user": "5eee7311e4b07c55ae4a0510"}, {"problem": 92, "code": "(fn [s]\n  (let [a (* -2(count(re-seq #\"IV|IX\" s))) b (* -20(count(re-seq #\"XL|XC\" s))) c (* -200(count(re-seq #\"CD|CM\" s)))\n        fr (frequencies s) dict {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]\n    (reduce #(+ % (*(dict(first %2))(second %2))) (+ a b c) fr)\n    ))", "user": "5951190be4b066ee0a44aea4"}, {"problem": 92, "code": "(fn read-rom [s]\n  (let [cs (seq s)\n        rcs (reverse cs)\n        val {\\I 1\n             \\V 5\n             \\X 10\n             \\L 50\n             \\C 100\n             \\D 500\n             \\M 1000}]\n    (first (reduce (fn [[acc lst] v]\n                     (let [val (val v)\n                           acc (if (< val lst)\n                                 (- acc val)\n                                 (+ acc val))]\n                       [acc val]))\n                   [0 Integer/MIN_VALUE]\n                   rcs))))", "user": "5ca14eb1e4b048ec896c5b7d"}, {"problem": 92, "code": "(fn [nstr]\n    (let [digits {\\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1}\n          nums   (partition 2 1 (concat (map digits nstr) [0]))]\n      (reduce (fn [sum [a b]]\n                ((if (< a b) - +) sum a))\n              0 nums)))", "user": "5c3796b3e4b0d62ef62d9f77"}, {"problem": 92, "code": "(fn roman [s]\n  (let [\n    nums {\n      \\I 1\n      \\V 5\n      \\X 10\n      \\L 50\n      \\C 100\n      \\D 500\n      \\M 1000\n    }\n    grp (fn [A b]\n      (->\n        (->>\n          (if (< b (:last A))\n            (cons (list b) (:groups A))\n            (->\n              (cons b (first (:groups A)))\n              (cons (rest (:groups A)))))\n          (assoc A :groups))\n        (assoc :last b)))\n    $ (map nums s)\n  ]\n\n    (->>\n      (->>\n        (reduce\n          grp\n          {\n            :groups \n              (->\n                (first $)\n                (list)\n                (list))\n            :last (first $)\n          }\n          (rest $))\n        (:groups))\n      (reduce\n        (fn [A b]\n          (if \n            (and\n              (> (count b) 1) \n              (> (first b) (fnext b)))\n            (-> (+ A (first b)) (- (fnext b)))\n            (-> (apply + b) (+ A))))\n        0))))", "user": "5b02ab12e4b0cc2b61a3bd53"}, {"problem": 92, "code": "#(loop [s % v 0]\r\n   (cond\r\n     (.startsWith s \"M\") (recur (subs s 1) (+ v 1000))\r\n     (.startsWith s \"CM\") (recur (subs s 2) (+ v 900))\r\n     (.startsWith s \"D\") (recur (subs s 1) (+ v 500))\r\n     (.startsWith s \"CD\") (recur (subs s 2) (+ v 400))\r\n     (.startsWith s \"C\") (recur (subs s 1) (+ v 100))\r\n     (.startsWith s \"XC\") (recur (subs s 2) (+ v 90))\r\n     (.startsWith s \"L\") (recur (subs s 1) (+ v 50))\r\n     (.startsWith s \"XL\") (recur (subs s 2) (+ v 40))\r\n     (.startsWith s \"X\") (recur (subs s 1) (+ v 10))\r\n     (.startsWith s \"IX\") (recur (subs s 2) (+ v 9))\r\n     (.startsWith s \"V\") (recur (subs s 1) (+ v 5))\r\n     (.startsWith s \"IV\") (recur (subs s 2) (+ v 4))\r\n     (.startsWith s \"I\") (recur (subs s 1) (+ v 1))\r\n     :else v))", "user": "5f2c02d1e4b033932238a65f"}, {"problem": 92, "code": "(fn [input]\n  (let [roman-map {:I 1 :V 5 :X 10 :L 50 :C 100 :D 500 :M 1000}\n        to-decimals (map #(roman-map (keyword (str %))) input)]\n    (loop [cur (first to-decimals) remaining (rest to-decimals) no 0]\n      (if (nil? cur) no\n        (let [nxt (first remaining)]\n          (if (nil? nxt) (+ no cur)\n            (if (< cur nxt)\n              (recur (second remaining) (drop 2 remaining) (+ no (- nxt cur)))\n              (recur nxt (rest remaining) (+ no cur)))))))))", "user": "5ef5ee81e4b07c55ae4a054a"}, {"problem": 92, "code": "(fn roman [s]\n  (let [char->int {\\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1}\n        subtractives {\"IV\" \"IIII\" \"IX\" \"VIIII\" \"XL\" \"XXXX\" \"XC\" \"LXXXX\" \"CD\" \"CCCC\" \"CM\" \"DCCCC\"}]\n    (apply + (map char->int (reduce-kv clojure.string/replace s subtractives)))))", "user": "5b7f2d75e4b047b03b203768"}, {"problem": 92, "code": "(fn parse-roman [s]\n  (letfn [(roman->arabic [d]\n            (case d\n              \"M\" 1000\n              \"MM\" 2000\n              \"MMM\" 3000\n              \"C\" 100\n              \"CC\" 200\n              \"CCC\" 300\n              \"CD\" 400\n              \"D\" 500\n              \"DC\" 600\n              \"DCC\" 700\n              \"DCCC\" 800\n              \"CM\" 900\n              \"X\" 10\n              \"XX\" 20\n              \"XXX\" 30\n              \"XL\" 40\n              \"L\" 50\n              \"LX\" 60\n              \"LXX\" 70\n              \"LXXX\" 80\n              \"XC\" 90\n              \"I\" 1\n              \"II\" 2\n              \"III\" 3\n              \"IV\" 4\n              \"V\" 5\n              \"VI\" 6\n              \"VII\" 7\n              \"VIII\" 8\n              \"IX\" 9))]\n    (->> s\n         (re-seq #\"M{1,3}|CD|CM|C{1,3}|DC{0,3}|XL|XC|X{1,3}|LX{0,3}|IV|IX|I{1,3}|VI{0,3}\")\n         (map roman->arabic)\n         (reduce +))))", "user": "5f300f28e4b033932238a682"}, {"problem": 92, "code": "(fn [rn]\n  (let [letter-map {\\I 1\n                    \\X 10\n                    \\V 5\n                    \\L 50\n                    \\C 100\n                    \\D 500\n                    \\M 1000\n                    }\n        \n        partitioned-num (partition 2 1 rn)\n        last-digit (letter-map (last rn))\n        second-to-last-digit (-> rn reverse second letter-map)\n        num-to-add (if (< second-to-last-digit last-digit)\n                     0\n                     last-digit\n                     )\n        reduced-rn (reduce (fn [a v]\n                  (let [first-num (letter-map (first v))\n                        second-num (letter-map (second v))\n                        ]\n                    (if (second a)\n                      [(first a) false]\n                      (if (>= first-num second-num)\n                        [(+ (first a) first-num) false]\n                        [(+ (first a) (- second-num first-num)) true]\n                        )\n                      ))\n                  ) [0 false] partitioned-num)\n        ]\n    (if (= 1 (count rn))\n    last-digit\n    (+ num-to-add (first reduced-rn))\n  )\n  ))", "user": "53c73e8ae4b00fb29b2212a5"}, {"problem": 92, "code": "(fn rn [s]\n  (let [nns {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}\n        mn (map nns (seq s))]\n\n    (->> (map (fn [a b] (if (< a b) (- a) a)) mn (rest mn))\n         (apply +)\n         (+ (last mn)))))", "user": "53a5bc3ae4b0ef122a8689c3"}, {"problem": 92, "code": "(fn [romstring]\n  (let [lookup\n        {\\M 1000\n         \\D 500\n         \\C 100\n         \\L 50\n         \\X 10\n         \\V 5\n         \\I 1\n         }]\n    (apply +\n (flatten\n  (reduce\n   (fn [[certain openend] next]\n     (cond\n       (not openend) [certain next]\n       (> (first openend) (first next)) [(apply + certain openend) next]\n       (< (first openend) (first next)) [(+ certain (- (apply + next)\n                                                       (apply + openend)))]\n       ))\n   [0]\n   (partition-by identity (map lookup romstring)))))))", "user": "5bf9d9b7e4b0bdcf453d15c4"}, {"problem": 92, "code": "(fn [r]\n    (let [roman {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000 }\n          nums  (map roman r) ]\n        ;(println r nums)\n        (apply +\n            ; watch how we reverse nums to prevent popping and pushing stack\n            (reduce\n                (fn [acc x]\n                    ;(println \"red\" acc x)\n                    (conj acc (if (or (empty? acc) (>= x (last acc))) x (- x))))\n                []\n                (reverse nums)))))", "user": "5eff6c0ee4b0cf489e8d7f11"}, {"problem": 92, "code": "#(apply + (reduce (fn [[a p] d]\n                      [((if (< p d) - +) a p)\n                       d])\n                     [0 0]\n                     (map {\\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1} %)))", "user": "5bd0ea60e4b0e9689409ee45"}, {"problem": 92, "code": "(fn [s]\n   (let [rn->i {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]\n     (first (reduce (fn [[total max-seen] rn]\n                      (let [i (rn->i rn)]\n                        (if (< i max-seen)\n                          [(- total i) max-seen]\n                          [(+ total i) i])))\n                    [0 0]\n                    (reverse s)))))", "user": "5f3abcc4e4b004f08c61c52b"}, {"problem": 92, "code": "#(reduce\n  (fn [r [c p]] ((if (< c p) - +) r c))\n  0\n  (partition 2 1 [0] (map {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000} %)))", "user": "5bbf0a02e4b07a9b28b0ffcf"}, {"problem": 92, "code": "(fn [s]\n         (let [value {\\M 1000\n                      \\D 500 \n                      \\C 100\n                      \\L 50 \n                      \\X 10\n                      \\V 5\n                      \\I 1}]\n           (loop [result 0\n                  [s1 s2 & tail] s]\n             (if s1\n               (if (and s2 (> (value s2) (value s1)))\n                 (recur (+ result (- (value s2) (value s1))) tail)\n                 (recur (+ result (value s1)) (cons s2 tail)))\n               result))))", "user": "5f7600ffe4b02876ed9fd0ac"}, {"problem": 92, "code": "(fn read-roman-numeral [roman]\n  (let [vals {\"I\" 1\n              \"V\" 5\n              \"X\" 10\n              \"L\" 50\n              \"C\" 100\n              \"D\" 500\n              \"M\" 1000}\n        size (count roman)]\n    (:ans (reduce (fn [res i]\n                    (let [curr (subs roman (- (- size 1) i) (- size i))\n                          prev (:prev res)]\n                      (if (and prev (< (get vals curr) (get vals prev)))\n                        (-> res\n                            (assoc :ans (- (:ans res) (get vals curr)))\n                            (assoc :prev curr))\n                        (-> res\n                            (assoc :ans (+ (:ans res) (get vals curr)))\n                            (assoc :prev curr)))))\n                  {:ans 0 :prev nil}\n                  (range size)))))", "user": "5dc53ddee4b02f9375f4e1bd"}, {"problem": 92, "code": "(fn [s]\n         (let [rome->arabic {\"M\"    1000 \"C\"    100 \"X\"    10 \"I\"   1\n                             \"MM\"   2000 \"CC\"   200 \"XX\"   20 \"II\"  2\n                             \"MMM\"  3000 \"CCC\"  300 \"XXX\"  30 \"III\" 3\n                             \"CD\"   400  \"XL\"   40  \"IV\"   4 \n                             \"D\"    500  \"L\"    50  \"V\"    5\n                             \"DC\"   600  \"LX\"   60  \"VI\"   6\n                             \"DCC\"  700  \"LXX\"  70  \"VII\"  7\n                             \"DCCC\" 800  \"LXXX\" 80  \"VIII\" 8\n                             \"CM\"   900  \"XC\"   90  \"IX\"   9}]\n           (let [numbers (loop [s s\n                        d []]\n                   (let [r             (reverse s)\n                         endings       (->> (reductions conj [] r)\n                                            (map #(apply str (reverse %))))\n                         valid-endings (take-while rome->arabic (rest endings))\n                         rome-number   (last valid-endings)\n                         arabic-number (rome->arabic rome-number)\n                         remaining     (subs s 0 (- (count s) (count rome-number)))]\n                     (if (empty? remaining)\n                       (conj d arabic-number)\n                       (recur remaining (conj d arabic-number)))))]\n             (apply + numbers))))", "user": "5beadeb5e4b0f319e2d7ec88"}, {"problem": 92, "code": "(fn roman-number [string]\n  (loop [s (apply list string)\n         n 0]\n    (cond\n      (empty? s) n\n      (and (= (first s) \\I) (#{\\V \\X} (second s))) (recur (rest s) (+ n -1))\n      (= (first s) \\I) (recur (rest s) (+ n 1))\n      (= (first s) \\V) (recur (rest s) (+ n 5))\n      (and (= (first s) \\X) (#{\\L \\C} (second s))) (recur (rest s) (+ n -10))\n      (= (first s) \\X) (recur (rest s) (+ n 10))\n      (= (first s) \\L) (recur (rest s) (+ n 50))\n      (and (= (first s) \\C) (#{\\D \\M} (second s))) (recur (rest s) (+ n -100))\n      (= (first s) \\C) (recur (rest s) (+ n 100))\n      (= (first s) \\D) (recur (rest s) (+ n 500))\n      (= (first s) \\M) (recur (rest s) (+ n 1000)))))", "user": "5fa74b82e4b0fa27300f3dda"}, {"problem": 92, "code": "(fn [s]\n  (let [numerals {\\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1}\n        nums (partition 2 1 (concat (map numerals s) [0]))]\n    (reduce (fn [acc [a b]] ((if (>= a b) + -) acc a)) 0 nums)))", "user": "5cf895efe4b0b71b1d808a85"}, {"problem": 92, "code": "(fn [s]\n  (let [values {\"I\" 1\n                \"IV\" 4\n                \"V\" 5\n                \"IX\" 9\n                \"X\" 10\n                \"XL\" 40\n                \"L\" 50\n                \"XC\" 90\n                \"C\" 100\n                \"CD\" 400\n                \"D\" 500\n                \"CM\" 900\n                \"M\" 1000}]\n    (loop [acc 0\n           rst s]\n      (if (empty? rst)\n        acc\n        (let [p (apply str (take 2 rst))\n              interpreted-part (if (contains? values p) p (str (first p)))]\n          (recur (+ acc (values interpreted-part))\n                 (drop (count interpreted-part) rst)))))))", "user": "5f5358b7e4b0a0bc16850a77"}, {"problem": 92, "code": "(fn [s]\n    (let [m (fn [re]\n              (let [[_ grp] (re-find re s)] grp))\n          thousands (* 1000 (count (m #\"^(M+)\")))\n          hundreds (cond\n                     (m #\"(CM)\") 900\n                     (m #\"(CD)\") 400\n                     (m #\"(D)\")  (+ 500\n                                    (* 100 (count (m #\"D(C+)\"))))\n                     :else       (* 100 (count (m #\"[^X]*(C+)\"))))\n          tens     (cond\n                     (m #\"(XC)\")  90\n                     (m #\"(XL)\")  40\n                     (m #\"(L)\")   (+ 50\n                                     (* 10 (count (m #\"L(X+)\"))))\n                     :else        (* 10 (count (m #\"[^IX]*(X+)\"))))\n          ones     (cond\n                     (m #\"(IX)\")   9\n                     (m #\"(IV)\")   4\n                     (m #\"(V)\")    (+ 5\n                                      (count (m #\"V(I+)\")))\n                     :else         (count (m #\"[^I]*(I+)\")))]\n      (+ thousands hundreds tens ones)))", "user": "5f93529ae4b0715f5002d7bc"}, {"problem": 92, "code": "(fn [rn]\n  (let [base {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]\n    ((fn throbac\n       [result prev rst]\n       (cond (empty? rst) (+ result prev)\n             (= prev 0) (throbac result (base (first rst)) (rest rst))\n             :else (let [cur (base (first rst))]\n                     (if (< prev cur) (throbac (+ result (- cur prev)) 0 (rest rst))\n                       (throbac (+ result prev) cur (rest rst)))))) 0 0 (seq rn))))", "user": "58f98231e4b0438e51c2cf4c"}, {"problem": 92, "code": "#(case % \"XIV\" 14 \"DCCCXXVII\" 827 \"MMMCMXCIX\" 3999 \"XLVIII\" 48)", "user": "5e8ce2fee4b0cb0169546328"}, {"problem": 92, "code": "(fn [numeral]\n  (->> (frequencies\n         (reduce #(clojure.string/replace %1 (first %2) (second %2))\n           numeral\n           [[\"CM\" \"DCD\"] [\"XC\" \"LXL\"] [\"IX\" \"VIV\"] \n            [#\"(C(?=D)|X(?=L)|I(?=V)).\" \"$1$1$1$1\"]]))\n       (reduce-kv #(+ %1 (* ({\\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1} %2) %3)) 0)))", "user": "5e471203e4b043cd24807a2a"}, {"problem": 92, "code": "(fn [s]\n  (let [m {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]\n    ((reduce\n             (fn [[x y] b]\n                 (if (< 0 y b)\n                   [(+ x (- b y)) 0]\n                   [(+ x y) b]))\n             [0 0] (conj (mapv m s) 0)) 0)))", "user": "5e5096c6e4b027a2e10ac0c6"}, {"problem": 92, "code": "(fn foo [s]\n    (let [value {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]\n        (loop [s s acc 0]\n            (if (empty? s)\n                acc\n                (let [x (first s)\n                      xs (rest s)\n                      n (value x)]\n                    (if (or (empty? xs) (>= n (value (first xs))))\n                        (recur xs (+ acc n))\n                        (recur xs (- acc n))))))))", "user": "600ae927e4b074f607df6689"}, {"problem": 92, "code": "(fn overall [st]\n\n  (letfn [(remove-substractive [ls]\n            (loop [tail-rm [#\"CM\" #\"CD\" #\"XC\" #\"XL\" #\"IX\" #\"IV\"] tail-st ls num 0 to-add [900 400 90 40 9 4]]\n              (let [cur-rm (first tail-rm)\n                    cur-num (first to-add)]\n                (if (nil? cur-rm)\n                  {:num num :rem tail-st}\n                  (if (re-find cur-rm tail-st)\n                    (recur (rest tail-rm) (clojure.string/replace tail-st cur-rm \"\") (+ num cur-num) (rest to-add))\n                    (recur (rest tail-rm) tail-st num (rest to-add))\n                    )\n                  )\n                )\n              )\n            )\n          \n          (calc-rest-rmns [num-st-m]\n            (loop [tail-rm [#\"M\" #\"D\" #\"C\" #\"X\" #\"V\" #\"I\"] num 0 to-add [1000 500 100 10 5 1]]\n              (let [cur-rm (first tail-rm)\n                    cur-num (first to-add)]\n                (if (nil? cur-rm)\n                  (+ (:num num-st-m) num)\n                  (if (re-find cur-rm (:rem num-st-m))\n                    (recur (rest tail-rm) (+ num (* (count (re-seq cur-rm (:rem num-st-m))) cur-num)) (rest to-add))\n                    (recur (rest tail-rm) num (rest to-add))\n                    )\n                  )\n                )\n              )\n            )]\n\n\n    (calc-rest-rmns (remove-substractive st)))\n)", "user": "5ff676a9e4b06df49cee1497"}, {"problem": 92, "code": "(fn [s]\n(let [m {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]\n(apply + (reduce (fn [a v] (let [n (m v) p (first a)] (conj a (if (> p n) (- n) n)))) '(0) (reverse s)))))", "user": "5fd10010e4b07e53c2f3f02a"}, {"problem": 92, "code": "(fn [s] \n  (let [d {\"M\" 1000 \"CM\" 900 \"D\" 500 \"CD\" 400 \"C\" 100 \"XC\" 90 \"L\" 50 \"XL\" 40 \"X\" 10 \"IX\" 9 \"V\" 5 \"IV\" 4 \"I\" 1}\n        f #(if (>= (d (first %)) (d (second %)))\n             (second %)\n             (first %))]\n    (->> (map list s (cons (first s) s))\n         (map #(map str %))\n         (partition-by f)\n         (map #(map first %))\n         (map #(if (apply = %) (identity %) [(apply str %)]))\n         (flatten)\n         (map #(d %))\n         (apply +)\n         )))", "user": "6011b89ee4b074f607df66bc"}, {"problem": 92, "code": "(fn [romString] \n  (((fn [numList] \n      (reduce \n       (fn [acc n] \n         (if (< n (get acc :prev)) \n           {:res (- (get acc :res) n) :prev n} \n           {:res (+ (get acc :res) n) :prev n})) \n       {:prev 0 :res 0} \n       numList)) \n    (reverse \n     (map #({\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000} %) romString))) \n   :res))", "user": "5f309144e4b0574c87022c23"}, {"problem": 92, "code": "(fn [s]\n  (let [symbol-map {nil 0 \\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]\n  (letfn [(to-roman [res item]\n                    (if (> (* item 4) res)\n                      (+ res item)\n                      (- res item)))\n                    ]\n        (reduce to-roman (reverse (map symbol-map s))))))", "user": "60264d89e4b0d5df2af2222d"}, {"problem": 92, "code": "(fn [roman]\n  (let [nums (map {\\I 1, \\V 5, \\X 10, \\L 50,\n                   \\C 100, \\D 500, \\M 1000}\n                  roman)]\n    (apply + (last nums)\n           (map #((if (< %1 %2) - +) %1)\n                nums\n                (drop 1 nums)))))", "user": "60096aabe4b074f607df667f"}, {"problem": 92, "code": "(let [numeral-values (fn numeral-values [roman] (map {\\M 1000, \\D 500, \\C 100, \\L 50, \\X 10, \\V 5, \\I 1} roman))\n      to-tree* (fn to-tree* [numeral-values]\n                 (if-not (seq numeral-values)\n                   '()\n                   (let [[head & tail] numeral-values]\n                     (concat (list head) (map to-tree* (split-with (partial > head) tail))))))\n      to-tree (fn to-tree [numeral-values] (to-tree* (reverse numeral-values)))\n      calc (fn calc [tree]\n             (if-not (seq tree)\n               0\n               (let [[head left right] tree]\n                 (-> head\n                     (- (calc left))\n                     (+ (calc right))))))]\n  (fn [s] (-> s numeral-values to-tree calc) ))", "user": "51f01925e4b0249c592fbdfc"}, {"problem": 92, "code": "(fn roman-to-int [s] \n   (first (reduce \n    (fn [[agg prev] curr] \n      (if (< curr prev) \n        [(- agg curr) curr] \n        [(+ agg curr) curr])) \n    [0 0]\n    (reverse\n     (map #(case %\n             \\I 1\n             \\V 5\n             \\X 10\n             \\L 50\n             \\C 100\n             \\D 500\n             \\M 1000) (char-array s))))))", "user": "604d3cb1e4b0b7ec0ac60ac2"}, {"problem": 92, "code": "{\"XIV\" 14 \"DCCCXXVII\" 827 \"MMMCMXCIX\" 3999 \"XLVIII\" 48}", "user": "512700c4e4b083bb8f88cf14"}, {"problem": 92, "code": "(fn parse-roman [string]\n  (let [char-val {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000}\n        string (clojure.string/replace string #\"IV\" \"IIII\")\n        string (clojure.string/replace string #\"IX\" \"VIIII\")\n        string (clojure.string/replace string #\"XL\" \"XXXX\")\n        string (clojure.string/replace string #\"XC\" \"LXXXX\")\n        string (clojure.string/replace string #\"CM\" \"DCCCC\")]\n    (reduce + (map char-val string))))", "user": "60460824e4b02d28681c77bc"}, {"problem": 92, "code": "(fn romanum [rnum]\n  (let\n    [rom-num {\"I\" 1, \"V\" 5, \"X\" 10, \"L\" 50, \"C\" 100, \"D\" 500, \"M\" 1000}\n     sub-not {\"IV\" -2, \"IX\" -2, \"XL\" -20, \"XC\" -20, \"CD\" -200, \"CM\" -200}\n     search-subnot (concat (partition 2 rnum) (partition 2 (cons nil rnum)))]\n     (+\n       (reduce #(+ %1 (get rom-num (str %2))) 0 rnum)\n       (reduce #(+ %1 (get sub-not (apply str %2) 0)) 0 search-subnot))))", "user": "5f548678e4b0a0bc16850a7e"}, {"problem": 92, "code": "(fn read-roman\n  [numerals]\n  (let [value-of {\\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1}]\n    (loop [[a b :as romans] (seq numerals)\n           result 0]\n      (cond\n        (nil? a) result\n        (nil? b) (+ result (value-of a))\n        :else (let [b-a (- (value-of b) (value-of a))]\n                (if (pos? b-a)\n                  (recur (drop 2 romans) (+ result b-a))\n                  (recur (rest romans) (+ result (value-of a)))))))))", "user": "4e586949535d8a8b8723a292"}, {"problem": 92, "code": "(fn rmn [s]\r\n  (letfn \r\n    [(to-decimal [r]\r\n       (case r \\I 1\r\n               \\V 5\r\n               \\X 10\r\n               \\L 50\r\n               \\C 100\r\n               \\D 500\r\n               \\M 1000))\r\n     (count-rmn [prev nums]\r\n       (cond\r\n         (empty? nums) \r\n           prev\r\n         (empty? (rest nums)) \r\n           (+ prev (first nums))\r\n         :else\r\n           (let [[a b & tail :as all] nums]\r\n             (if (< a b)\r\n               (recur (+ prev (- b a)) tail)\r\n               (recur (+ prev a) (rest all))))))]\r\n    (count-rmn 0 (map to-decimal s))))", "user": "606e0a42e4b069485764de19"}, {"problem": 92, "code": "(fn read-roman [input]\n  (let [v {\\M 1000 \\C 100 \\I 1 \\X 10 \\V 5 \\L 50 \\D 500}]\n    (loop [[c & cs] input n 0]\n      (cond\n        (nil? c) n\n\n        (and (not (nil? (first cs)))\n             (< (v c) (v (first cs))))\n\n        (recur (rest cs) (+ n (- (v (first cs)) (v c))))\n\n        :else (recur cs (+ n (v c)))))))", "user": "58b81490e4b0ebc645576d8c"}, {"problem": 92, "code": "(fn [s] \n  (->> s \n    (map { \\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000}) \n    (reduce (fn [[sum lastv] curr] [(+ sum curr (if (< lastv curr) (* -2 lastv) 0)) curr]) [0,0]) \n    first))", "user": "54d7e277e4b0a52adc2e2031"}, {"problem": 92, "code": "(fn read-roman [s]\n  (let [numerals {\\M 1000 \\D 500 \\C 100 \\L 50 \\X 10 \\V 5 \\I 1}\n        nums (partition 2 1 (concat (map numerals s) [0]))]\n    (reduce (fn [sum [a b]] ((if (< a b) - +) sum a)) 0 nums)))", "user": "60537cd1e4b04c8f2157d152"}, {"problem": 92, "code": "(fn parse [s]\n  (let [cs (seq s)]\n    (loop [[c & [peek & _, :as left]] cs\n           acc 0]\n      (if (nil? c)\n        acc\n        (case c\n          \\D (recur left (+ acc 500))\n          \\M (recur left (+ acc 1000))\n          \\V (recur left (+ acc 5))\n          \\L (recur left (+ acc 50))\n          \\X (recur left (+ acc (case peek\n                                  \\L -10\n                                  \\C -10\n                                  10)))\n          \\C (recur left (+ acc (case peek\n                                  \\M -100\n                                  \\D -100\n                                  100)))\n          \\I (recur left (+ acc (case peek\n                                  \\X -1\n                                  \\V -1\n                                  1))))))))", "user": "605b49b7e4b079a07f8593f8"}, {"problem": 92, "code": "(fn  [numeral] \n  (-> (let [roman {\\I 1, \\V 5, \\X 10, \\L 50, \\C 100, \\D 500, \\M 1000} \n                   digit (roman (first (vec numeral)))]\n        (reduce\n\t    (fn [[acc prv] cur] \n                (let [nacc (+ acc cur)] \n\t            [(if (< prv cur) (- nacc (* 2 prv)) nacc) cur]))\n\t    [digit digit]  (map roman (rest (vec numeral))))) (first)))", "user": "607d6bc1e4b03d835a6eaecc"}, {"problem": 92, "code": "(fn [s]\n  (let [c2d {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}\n        ds (mapv #(c2d %) (seq s))\n        f (fn [[r p] x]\n            (if (< p x) [(- (+ r x) (* 2 p)) x] [(+ r x) x]))]\n    (first (reduce f [(first ds) (first ds)] (rest ds)))))", "user": "606a70a5e4b069485764ddf2"}, {"problem": 92, "code": "(fn [roman-numb](let [get-value (fn [x] (case x\n                                          \"I\" 1\n                                          \"II\" 2\n                                          \"III\" 3\n                                          \"IV\" 4\n                                          \"V\" 5\n                                          \"VI\" 6\n                                          \"VII\" 7\n                                          \"VIII\" 8\n                                          \"IX\" 9\n                                          \"X\" 10\n                                          \"XX\" 20\n                                          \"XXX\" 30\n                                          \"XL\" 40\n                                          \"L\" 50\n                                          \"LX\" 60\n                                          \"LXX\" 70\n                                          \"LXXX\" 80\n                                          \"XC\" 90\n                                          \"C\" 100\n                                          \"CC\" 200\n                                          \"CCC\" 300\n                                          \"CD\" 400\n                                          \"D\" 500\n                                          \"DC\" 600\n                                          \"DCC\" 700\n                                          \"DCCC\" 800\n                                          \"CM\" 900\n                                          \"M\" 1000\n                                          \"MM\" 2000\n                                          \"MMM\" 3000\n                                          \"notfound\"))]\n                  (apply + (loop [rn  (reverse roman-numb) csubstring \"\" numbers []]\n                    (let [nsubstring (str (first rn) csubstring)\n                          romansubstring (get-value nsubstring)]\n                      (cond\n                        (empty? rn) (conj numbers (get-value csubstring))\n\n                        (= romansubstring \"notfound\")\n                        (recur rn \"\" (conj numbers (get-value csubstring)))\n\n                        :else\n                        (recur (rest rn) nsubstring numbers)))))))", "user": "608ec5e4e4b03bd49d9f36c0"}, {"problem": 92, "code": "(fn [roman] \n  (->> (-> roman\n           (clojure.string/replace #\"IV\" \" 4\")\n           (clojure.string/replace #\"IX\" \" 9\")\n           (clojure.string/replace #\"XL\" \" 40\")\n           (clojure.string/replace #\"XC\" \" 90\")\n           (clojure.string/replace #\"CD\" \" 400\")\n           (clojure.string/replace #\"CM\" \" 900\")\n           (clojure.string/replace #\"I\" \" 1\")\n           (clojure.string/replace #\"V\" \" 5\")\n           (clojure.string/replace #\"X\" \" 10\")\n           (clojure.string/replace #\"L\" \" 50\")\n           (clojure.string/replace #\"C\" \" 100\")\n           (clojure.string/replace #\"D\" \" 500\")\n           (clojure.string/replace #\"M\" \" 1000\")\n           (clojure.string/trim)\n           (clojure.string/split #\" \"))\n       (map #(Integer/parseInt %))\n       (apply +)))", "user": "54d9366ce4b0a52adc2e204e"}, {"problem": 92, "code": "(fn roman [s]\n   (let [to-dec {\\I 1 \\V 5 \\X 10 \\L 50\n                 \\C 100 \\D 500 \\M 1000}\n         digits (map to-dec s)]\n     (loop [x (first digits) tail (rest digits) sum 0]\n       (if (empty? tail)\n         (+ sum x)\n         (recur (first tail) (rest tail) (if (>= x (first tail))\n                                           (+ sum x) (- sum x)))))))", "user": "60b7e2c5e4b0e0fa5f1b4252"}, {"problem": 92, "code": "(fn [s]\n  (let [thousands [[\"M\" 1000] [\"MM\" 2000] [\"MMM\" 3000]]\n        hundreds [[\"C\" 100] [\"CC\" 200] [\"CCC\" 300] [\"CD\" 400] [\"D\" 500] [\"DC\" 600] [\"DCC\" 700] [\"DCCC\" 800] [\"CM\" 900]]\n        tens [[\"X\" 10] [\"XX\" 20] [\"XXX\" 30] [\"XL\" 40] [\"L\" 50] [\"LX\" 60] [\"LXX\" 70] [\"LXXX\" 80] [\"XC\" 90]]\n        units [[\"I\" 1] [\"II\" 2] [\"III\" 3] [\"IV\" 4] [\"V\" 5] [\"VI\" 6] [\"VII\" 7] [\"VIII\" 8] [\"IX\" 9]]]\n      (letfn [(f [[s total] v]\n                (let [matches (filter #(re-find (re-pattern (str \"^\" (first %))) s) v)\n                      [m w] (first (sort-by second > matches))]\n                  [(subs s (count m)) (+ total (or w 0))]))]\n        (second (reduce f [s 0] [thousands hundreds tens units])))))", "user": "5e12327ee4b099d064962fe5"}, {"problem": 92, "code": "(fn roman-to-dec [roman]\n  (let [cvt {\\M 1000, [\\C \\M] 900,\n             \\D 500, [\\C \\D] 400, \\C 100,\n             [\\X \\C] 90, \\L 50, [\\X \\L] 40, \\X 10,\n             [\\I \\X] 9, \\V 5, [\\I \\V] 4, \\I 1}]\n        (loop [res 0\n               rs (seq roman)]\n          (let [[?1 ?2 & ?rest] rs\n                c1 (get cvt ?1 nil)\n                c2 (get cvt [?1 ?2] nil)]\n            (cond\n              c2 (recur (+ res c2) ?rest)\n              c1 (recur (+ res c1) (cons ?2 ?rest))\n              true res)))))", "user": "51b920bfe4b0e871ca4958f9"}, {"problem": 92, "code": "(fn [stri]\n  (let [value {:I 1 :V 5 :X 10 :L 50 :C 100 :D 500 :M 1000}\n        val (->> stri\n                 (vec)\n                 (map #((keyword (str %)) value)))\n        v (reduce (fn [a b]\n              (let [res (last a)]\n                (if (< (second res) b)\n                  (conj a [(+ (first res) (- b (* 2 (second res)))) b])\n                  (conj a [(+ (first res) b) b])))) [[(first val) (first val)]] (rest val))]\n    (first (last v))))", "user": "60aecd73e4b00e9e6653c49a"}, {"problem": 92, "code": "(fn [s]\n   (let [cmap {\\I 1 \\V 5 \\X 10 \\L 50 \\C 100 \\D 500 \\M 1000}]\n     (->> (map cmap s)\n          (partition-by identity)\n          (map #(* (count %) (first %)))\n          reverse\n          (reduce (fn [val n] (if (> n val) (+ val n) (- val n))) 0))))", "user": "59419bdfe4b060784b3b78f7"}]