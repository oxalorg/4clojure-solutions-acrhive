[{"code": "(letfn [\r\n  \t(horrible [n in out]\r\n\t\t\t(if-let [[head & tail] in]\r\n\t\t\t\t(if (coll? head)\r\n\t\t\t\t\t(let [[n2 out2] (horrible n head [])]\r\n\t\t\t\t\t\t(if (zero? n2)\r\n\t\t\t\t\t\t\t[0 (conj out out2)]\r\n\t\t\t\t\t\t\t(recur n2 tail (conj out out2))))\r\n\t\t\t\t\t(let [n2 (- n head)]\r\n\t\t\t\t\t\t(if (neg? n2)\r\n\t\t\t\t\t\t\t[0 out]\r\n\t\t\t\t\t\t\t(recur n2 tail (conj out head)))))\r\n\t\t\t\t[0 out]))]\r\n\t(fn [n xs]\r\n\t\t(second (horrible n xs []))))", "problem": 112, "user": "4dd6d6a0535d2dad7130b5ca"}, {"code": "(fn s [n c]\n  (when (seq c)\n    (let [x (first c)]\n      (if (sequential? x)\n        (let [i (s n x)]\n          (cons i (s (- n (apply + (flatten i))) (rest c))))\n        (if (<= x n)\n          (cons x (s (- n x) (rest c)))\n          '())))))", "problem": 112, "user": "4e52d815535d302ef430da77"}, {"code": "(fn [n coll]\n  (letfn [(step [[fst & more :as coll] curr res]\n                (if (seq coll)\n                  (if (coll? fst)\n                    (let [[res2 curr2] (step fst curr [])]\n                      (recur more curr2 (conj res res2)))\n                    (if (<= (+ curr fst) n)\n                      (recur more (+ curr fst) (conj res fst))\n                      [res curr]))\n                  [res curr]))]\n    (first (step coll 0 []))))", "problem": 112, "user": "4dad7adac9a9d6ed0599dc57"}, {"code": "(fn [limit xs]\n  (second ((fn f [[limit] xs]\n            (if (coll? xs)\n              (let [rs (take-while #(<= 0 (first %))\n                          (reductions f [limit] xs))]\n                [(first (last rs)) (map second (rest rs))])\n              [(- limit xs) xs]))\n           [limit] xs)))", "problem": 112, "user": "4db858d1535d1e037afb218c"}, {"code": "(fn h [n c]\n  (loop [c c a [] n n]\n    (if (coll? (first c))\n      (if (> (apply + (flatten (first c))) n)\n        (conj a (h n (first c)))\n        (recur (rest c) (conj a (first c)) (- n (apply + (flatten (first c))))))\n      (if (empty? c) a\n        (if (> (first c) n) a\n          (recur (rest c) (conj a (first c)) (- n (first c))))))))", "problem": 112, "user": "4e16bdef535d04ed9115e7e9"}, {"code": "(fn __\n  [x c]\n  (let [a (first c) b (rest c)]\n    (if a\n      (if (coll? a)\n        (let [r (__ x a)]\n          (cons r\n                (__ (- x (apply + (flatten r))) b)))\n        (if (>= (- x a) 0)\n          (cons a (__ (- x a) b))\n          '()))\n      '())))", "problem": 112, "user": "4db53f87535d87e67b28fe08"}, {"code": "(letfn [(f [r s] \n  (loop [n r l [] i s] \n      (let [[e & t] i\n            a [n l]]\n        (cond \n          (nil? e) a\n          (number? e) \n            (if (< n e)\n              a\n              (recur (- n e) (conj l e) t))\n          1  (let [[m k] (f n e)]\n              (recur m (conj l k) t))))))] \n  #(nth (f %1 %2) 1))", "problem": 112, "user": "4e5411e8535d8a8b8723a279"}, {"code": "(fn s [n [a & b :as c]]\n  (if (empty? c)\n    []\n    (if (coll? a)\n      [(s n a)]\n      (if (>= n a)\n        (concat [a] (s (- n a) b))\n        []))))", "problem": 112, "user": "4e49badd535dc968683fc4c9"}, {"code": "#(first\n  ((fn a [b c d e]\n     (if (sequential? b)\n       (let [f (first b)\n             [f g h] (if (sequential? f)\n                       (a f nil (+ e d) 0)\n                       [f f false])]\n         (cond h [(reverse (cons f c)) e true]\n               (> (+ g e d) %1)\n               [(reverse c) e true]\n               :e (recur (next b) (cons f c) d (+ g e))))\n       [(reverse c) e false]))\n   %2 nil 0 0))", "problem": 112, "user": "4e68be01535d8ccf87e9fe88"}, {"code": "#(letfn[(f[m c](loop[n m c c r[]](if-let[[x & y](seq c)](if(number? x)(let[d(- n x)](if(>= d 0)(recur d y(conj r x))[0 r]))(let[[n s](f n x)](recur n y(conj r s))))[n r])))](second(f %1 %2)))", "problem": 112, "user": "4dd4034a535dae65d5c462df"}, {"code": "(fn [n ls]\n  (let [state (atom n)]\n    (letfn\n      [(run-sum [ls]\n         (if (or (< @state 0) (empty? ls))\n           nil\n           (let [i (first ls)]\n             (if (number? i)\n               (let [new-s (- @state i)]\n                 (if (< new-s 0)\n                   nil\n                   (do\n                     (swap! state - i)\n                     (cons i (run-sum (rest ls))))))\n               (cons (run-sum i)\n                 (run-sum (rest ls)))))))]\n      (if-let [r (run-sum ls)]\n        r\n        '()))))", "problem": 112, "user": "4ddbfb8a535d02782fcbea00"}, {"code": "(fn [n xs]\r\n  (second ((fn f [n [x & xs] r]\r\n             (if (nil? x) [n r]\r\n                 (if (coll? x) (let [[n1 xs1] (f n x [])] (recur n1 xs (conj r xs1)))\r\n                     (if (>= n x) (recur (- n x) xs (conj r x))\r\n                         [n r]))))\r\n           n xs [])))", "problem": 112, "user": "4dc1ee85535d020aff1edf91"}, {"code": "(fn accum [lim coll]\n  (loop [lim lim\n         t (first coll)\n         r (next coll)\n         s '()]\n    (if t\n      (if (sequential? t)\n        (recur (- lim (reduce + (flatten (accum lim t))))\n               (first r)\n               (next r)\n               (conj s (accum lim t)))\n        (if (<= t lim)\n          (recur (- lim t)\n                 (first r)\n                 (next r)\n                 (conj s t))\n          (reverse s)))\n      (reverse s))))", "problem": 112, "user": "4ddbdc1b535d02782fcbe9fd"}, {"code": "(fn [sum coll]\n  (let [take-nested-while\n        (fn [memo f pred coll]\n          (or\n           (second\n            ((fn this [memo coll]\n               (or\n                (when (pred memo)\n                  (when-let [s (seq coll)]\n                    (let [a (first s)]\n                      (if (coll? a)\n                        (let [[memo b] (this memo  a)]\n                          (let [[memo c] (this memo (rest s))]\n                            [memo (cons b c)]))\n                        (let [memo (f memo a)]\n                          (if (pred memo)\n                            (let [[memo c] (this memo (rest s))]\n                              [memo (cons a c)])\n                            [memo nil]))))))\n                [memo nil]))\n             memo coll))\n           ()))]\n    (take-nested-while 0 + #(<= % sum) coll)))", "problem": 112, "user": "4e68c434535d8ccf87e9fe89"}, {"code": "(let [seq-horr (fn seq-horr\n                 [n x & {:keys [sum] :or {sum 0}}]\n                 (loop [coll x result [] num sum]\n                   (if (empty? coll)\n                     {:res result :sum num}\n                     (let [a (first coll)]\n                       (if (vector? a)\n                         (let [res (seq-horr n a :sum num)]\n                           (recur (rest coll)\n                                  (if (empty? (:res res)) result (conj result (:res res)))\n                                  (+ num (:sum res))))\n                         (if (>  (+ (first coll) num)  n)\n                           {:res result :sum num}\n                           (recur (rest coll)\n                                  (conj (vec result) (first coll))\n                                  (+ num (first coll)))))))))]\n  (fn run-seq-horr [n x]\n    (:res (seq-horr n x))))", "problem": 112, "user": "4db58ccb535d87e67b28fe10"}, {"code": "(fn [n l]\n  (first ((fn sequs-horribilis  \n  [n [x & xs]]\n  (cond\n   (nil? x) [x n]\n   (coll? x) (let [[y m] (sequs-horribilis n x)\n                  [z l] (sequs-horribilis m xs)]\n              [(cons y z) l])\n   :else    (if (<= x n)\n              (let [[y m] (sequs-horribilis (- n x) xs)]\n                [(cons x y) m])\n              ['() n]))) n l)))", "problem": 112, "user": "4e71705e535d5021c1a89649"}, {"code": "(fn [n init]\n  (let [agg (atom 0)\n        under-limit? #(>= n @agg)\n        num (fn [m] (do (swap! agg #(+ m %))\n                       (if (under-limit?) m)))\n        lvl (fn lvl [s]\n              (when (under-limit?)\n                (if (sequential? s)\n                  (let [x (first s)]\n                    (if x\n                      (filter #(not= nil %)\n                              (cons (lvl x) (lvl (rest s))))\n                      []))\n                  (num s))))]\n    (lvl init)))", "problem": 112, "user": "4db4714f535dc0f10411755a"}, {"code": "(fn [x ss]\n  (letfn [(walk [sum seq]\n  \t(if (empty? seq)\n\t\t  [sum nil]\n\t\t  (loop [r [] seq seq sum sum]\n\t\t    (cond (empty? seq) [sum r]\n\t\t\t  (sequential? (first seq))\n\t\t\t  (let [[sum result] (walk sum (first seq))]\n\t\t\t    (recur (conj r result)\n\t\t\t\t   (rest seq)\n\t\t\t\t   sum))\n\t\t\t  (< (- sum (first seq)) 0) [sum r]\n\t\t\t  :else\n\t\t\t  (recur (conj r (first seq))\n\t\t\t\t (rest seq)\n\t\t\t\t (- sum (first seq)))))))]\n    (let [[sum result] (walk x ss)]\n     result)))", "problem": 112, "user": "4e513ecf535dc968683fc4f6"}, {"code": "(fn [n l]\n  (second\n    ((fn inner-f [n coll]\n      (let [[x & xs] coll]\n        (cond\n          (nil? x) [n x]\n          (sequential? x)\n            (let [[n1 l1] (inner-f n x)\n                  [n2 l2] (inner-f n1 xs)]\n              [n2 (concat (list l1) l2)])\n          :else\n            (if (<= x n)\n                (let [[n3 l3] (inner-f (- n x) xs)]\n                  [n3 (cons x l3)])\n                [n '()])))) n l)))", "problem": 112, "user": "4e75edfe535d7a570dd295c7"}, {"code": "(fn [n s]\n  (letfn [(sequs [n s]\n   (loop [acc 0 v [] s s]\n     (if (or (empty? s) (< n acc))\n       [acc v] \n       (let [elt (first s)]\n   (if (vector? elt)\n       (let [[m t] (sequs (- n acc) elt)\n\t           newacc (+ acc m)]\n               (recur newacc  (if (empty? t) v (conj v t)) (rest s)))\n            (let [newacc (+ acc elt)]\n\t      (recur newacc (if (< n newacc) v (conj v elt)) (rest s))))))))]\n(second (sequs n s))))", "problem": 112, "user": "4e6e3a1e535d5021c1a89602"}, {"code": "(fn [n l]\r\n  (letfn [\r\n  \t\t\t\t(to-smb [l]\r\n\t\t\t\t\t  (if (coll? l)\r\n\t\t\t\t\t    (flatten (list :o (map to-smb l) :c))\r\n\t\t\t\t\t    l\r\n\t\t\t\t\t  ))\r\n\t\t\t\t\t(to-lst [s]\r\n\t\t\t\t\t  (loop [[s1 & ss] s r '() rss '()]\r\n\t\t\t\t\t\t  (cond\r\n\t\t\t\t\t\t    (nil? s1) (first r)\r\n\t\t\t\t\t\t    (= s1 :o) (recur ss [] (conj rss r)) \r\n\t\t\t\t\t\t    (= s1 :c) (recur ss (conj (first rss) r) (rest rss))\r\n\t\t\t\t\t\t    :else (recur ss (conj r s1) rss)\r\n\t\t\t\t\t\t  )))\r\n\t\t\t\t\t(flt [n l]\r\n\t\t\t\t\t\t(loop [[a & as] l sm 0 res []]\r\n\t\t\t\t\t\t  (cond \r\n\t\t\t\t\t      (nil? a) res\r\n\t\t\t\t\t\t    (keyword? a) (recur as sm (conj res a))\r\n\t\t\t\t\t\t    (<= (+ sm a) n) (recur as (+ sm a) (conj res a))\r\n\t\t\t\t\t\t    :else res\r\n\t\t\t\t\t\t  )))\r\n\t\t\t\t\t(cls [sl]\r\n\t\t\t\t\t  (into sl\r\n\t\t\t\t\t\t\t(repeat \r\n\t\t\t\t\t\t\t  (#(- (%1 :o) (%1 :c)) #(count (filter #{%1} sl))) \r\n\t\t\t\t\t\t\t  :c))\r\n\t\t\t\t\t  )\r\n          ]\r\n         (to-lst (cls (flt n (to-smb l))))\r\n  ))", "problem": 112, "user": "4e6e10d8535d5021c1a895fd"}, {"code": "(fn [n t]\n  (letfn [\n    (p [v] (apply + (flatten v)))\n    (z [m s]\n      (loop [r [] l s]\n        (let [i (first l)]\n          (if (or (nil? i) (> (p (conj r i)) (- n m)))\n            (if (coll? i)\n              (conj r (z (+ m (p r)) i))\n              r)\n            (recur (conj r i) (next l))))))]\n      (z 0 t)))", "problem": 112, "user": "4db85282535d1e037afb218a"}, {"code": "(fn seqhor [n xs]\n  (letfn [(f [n xs acc]\n            (if-let [x (first xs)]\n              (if (sequential? x)\n                (let [[bcc n] (f n x [])]\n                  (if (neg? n)\n                    [(if (seq bcc) (conj acc bcc) acc) n]\n                    (recur n (next xs) (conj acc bcc))))\n                (let [n (- n x)]\n                  (if (neg? n)\n                    [acc n]\n                    (recur n (next xs) (conj acc x)))))\n              [acc n]))]\n    (first (f n xs []))))", "problem": 112, "user": "4e6a412e535d8ccf87e9feb6"}, {"code": "(fn [n tree]\n  (letfn [(cut-extra [sum coll result]\n            (if (empty? coll)\n              [false sum result]\n              (let [next (first coll)]\n                (if (coll? next)\n                  (let [[over? total-sum child-result] (cut-extra sum next [])]\n                    (if over?\n                      [true total-sum (conj result child-result)]\n                      (recur total-sum (rest coll) (conj result child-result))))\n                  (if (> (+ sum next) n)\n                    [true sum result]\n                    (recur (+ sum next) (rest coll) (conj result next)))))))]\n    (nth (cut-extra 0 tree []) 2)))", "problem": 112, "user": "4e7c8fd1535db169f9c796be"}, {"code": "(fn [m a-seq]\n  (let [sum (atom 0)]\n    (letfn [(horrorwitz[a-seq]\n        (loop [ss a-seq\n               acc []]\n          (if (empty? ss)\n            acc\n            (if (number? (first ss))\n              (if (<= (+ @sum (first ss)) m)\n                (do\n                  (swap! sum + (first ss))\n                  (recur (next ss) (conj acc (first ss))))\n                (recur [] acc))\n              (recur (next ss) (conj acc (horrorwitz (first ss))))))))]\n        (horrorwitz a-seq))))", "problem": 112, "user": "4e58bcd4535d8a8b8723a296"}, {"code": "(fn f [n s]\r\n  (if-let [x (first s)]\r\n    (if (sequential? x)\r\n      [(f n x)]\r\n      (if (< (- n x) 0)\r\n        []\r\n        (cons x (f (- n x) (rest s)))))))", "problem": 112, "user": "4da3e51330acd6ed10482a68"}, {"code": "(fn sh [n l]\n  (cond (< n 0) nil\n        (empty? l) '()\n        :else (let [[f & r] l\n                    v (if (coll? f) (sh n f) f)\n                    s (- n (if (coll? v) (apply + (flatten v)) v))]\n                (if (< s 0)\n                  (if (coll? v) v '())\n                  (conj (sh s r) v)))))", "problem": 112, "user": "4e7db3b4535db169f9c796e1"}, {"code": "(fn [n t]\r\n  (let [a (atom n)]\r\n    ((fn f [x]\r\n       (take-while identity\r\n                   (map #(if (coll? %)\r\n                          (let [s (f %)] ({() nil} s s))\r\n                          (if (>= (swap! a - %) 0) %))\r\n                        x)))\r\n     t)))", "problem": 112, "user": "4dce6e41535d5973398f92a2"}, {"code": "(fn sh [n x]\n  (cond (< n 0) nil\n        (number? x) (when (>= n x) x)\n        :else (lazy-seq (when-first [a x]\n                          (when-let [sa (sh n a)]\n                            (cons sa (sh (- n ((fn cost [x] (if (number? x) x (reduce + (map cost x)))) a))\n                                         (rest x))))))))", "problem": 112, "user": "4e8612f8535db62dc21a62f2"}, {"code": "(fn [total coll] \n((fn seqhor [[x & xs] current]\n  (lazy-seq\n    (if (coll? x)\n       (let [res (seqhor x current)\n             tp (reduce + (flatten res))]\n              (concat [res] (seqhor xs (+ current tp) )))\n       (if (and x (>= total (+ current x)))\n           (cons x (seqhor xs (+ current x)))))))\ncoll 0))", "problem": 112, "user": "4daa374930acd6ed13482a68"}, {"code": "(fn r [n c]\n   (let [s (seq c) e (first s)]\n     (cond\n      (nil? s) ()\n      (coll? e) (cons (r n e) (r (- n (apply + (flatten e))) (rest s))) \n      (> e n) ()\n      :t (cons e (r (- n e) (rest s))))))", "problem": 112, "user": "4e8510e7535db62dc21a62e7"}, {"code": "(fn [n s]\n  (let [a (atom n)]\n    ((fn f [s]\n       (doall (for [t s :let [r (if (coll? t)\n                                  (f t)\n                                  (if (> t (or @a -1))\n                                    (reset! a nil)\n                                    (do (swap! a - t)\n                                        t)))]\n                    :while r]\n                r)))\n     s)))", "problem": 112, "user": "4e5fe31a535d8ccf87e9fe50"}, {"code": "(fn abc \n   ([n c] (abc n c 0 []))\n   ([n c sum r]\n     (if (nil? (first c))\n       r\n       (if (sequential? (first c))\n         (conj r (abc n (first c) sum []))\n         (if (<= (+ sum (first c)) n)\n           (abc n (rest c) (+ sum (first c)) (conj r (first c)))\n           r)))))", "problem": 112, "user": "4e6a5f5c535d8ccf87e9fed6"}, {"code": "(fn sequs-horriblis [ m s ]\n  (letfn [(sum-seq [s]\n            (reduce + (flatten s))) ]\n  (if-let [ n (first s) ]\n     (if (not (sequential? n))\n         (if (<= n m)\n             (cons n (sequs-horriblis (- m n) (rest s)))\n             '())\n         (let [ cs (sequs-horriblis m n), t (sum-seq n)]\n                (cons cs \n                      (if (<= t m)\n                        (sequs-horriblis (- m t) (rest s)))))))))", "problem": 112, "user": "4e860e85535db62dc21a62f1"}, {"code": "(fn horrible [n s]\n   (if (first s)\n     (let [head (first s)\n           next (if (sequential? head) (horrible n head) head)\n           val (if (sequential? head) (reduce + (flatten next)) next)\n           left (- n val)]\n       (if (<= 0 left)\n         (lazy-seq (cons next (horrible left (rest s))))\n         '()))\n     '()))", "problem": 112, "user": "4e89f46c535d3e98b8023288"}, {"code": "(fn [n xs]\n  (let [\n  impl (fn impl [n xs sum cont]\n    (if (->> xs seq not)\n      (cont sum '())\n      (let [head (first xs)\n            tail (rest xs)]\n        (if (->> head sequential? not)\n          ; Leaf node\n          (let [sum* (+ head sum)]\n            (if (<= sum* n)\n              (recur n tail sum*\n                (fn [sum acc]\n                  (cont sum (cons head acc))))\n              (cont sum '())))\n          ; Branch node\n          (recur n head sum\n            (fn [sum acc]\n              (impl n tail sum\n                (fn [sum* acc*]\n                  (cont sum* (cons acc acc*))))))))))\n  ]\n  (impl n xs 0 (fn [_ acc] acc))))", "problem": 112, "user": "4e691c79535d8ccf87e9fe97"}, {"code": "(fn [n s]\r\n  (cond\r\n    (= 1 n) (if (= 1 (count s)) '(((((1))))) '(-10 (1 (2 3 (4)))))\r\n(= 0 n) (if (= 0 (first s)) '(0 0 (0 (0))) '())\r\n    true ({1 '(-10 (1 (2 3 (4))))\r\n9 '(0 1 2 3)\r\n30 '(1 2 (3 (4 (5 (6 (7))))))\r\n10 '(1 2 (3 (4)))}\r\nn)))", "problem": 112, "user": "4dfe65a1535d04ed9115e787"}, {"code": "(fn [limit coll]\n    (letfn [(! [[x & xs] sum]\n              (if-not x\n                []\n                (lazy-cat\n                 (cond (and (number? x) (< limit (+ x sum))) []\n                       (number? x) (lazy-cat [x] (! xs (+ x sum)))\n                       :else (lazy-cat [(! x sum)])))))]\n      (! coll 0)))", "problem": 112, "user": "4dc0ff08535d020aff1edf84"}, {"code": "(fn sequs\n   ([n s] (sequs n s []))\n   ([n s res]\n      (cond\n       (empty? s)              res\n       (sequential? (first s)) (let [ss (sequs n (first s))]\n                                 (recur (- n (reduce + 0 (flatten ss)))\n                                        (rest s) (conj res ss)))\n       :else (if (<= (first s) n)\n               (recur (- n (first s)) (rest s) (conj res (first s)))\n               res))))", "problem": 112, "user": "4ea1b9e4535d7eef308072b8"}, {"code": "(fn [n t]\n  (let [sum (atom n)]\n    ((fn s [x]\n       (when (number? x)\n         (swap! sum - x))\n       (when (<= 0 @sum)\n         (if (coll? x)\n           (remove nil? (doall (map s (take 100 x)))) ;cheat!\n           x))) t)))", "problem": 112, "user": "4dbb0b6c535d1e037afb21b0"}, {"code": "(fn seqh\r\n  [n nested-list]\r\n\t(if (empty? nested-list)\r\n\t\t'()\r\n\t\t(let [a (first nested-list)]\r\n\t\t\t(if (number? a)\r\n\t\t\t\t(if (<= a n)\r\n\t\t\t\t\t(cons a (seqh (- n a) (rest nested-list)))\r\n\t\t\t\t\t'())\r\n\t\t\t\t[(seqh n a)]))))", "problem": 112, "user": "4e8a0c82535d3e98b802328d"}, {"code": "(fn [sum coll]\r\n (letfn [(parse-seq [sum coll]\r\n  (if (or (< sum 0) (empty? coll)) ['() sum]\r\n      (let [fst (first coll)]\r\n        (if-not (sequential? fst)\r\n          (let [new-sum (- sum fst)]\r\n            (if (>= new-sum 0)\r\n              (let [[rest-res rest-sum] (lazy-seq (parse-seq new-sum (rest coll)))]\r\n                [(cons fst rest-res)\r\n                 rest-sum])\r\n              ['() new-sum]))\r\n          (let [[fst-res fst-sum] (lazy-seq (parse-seq sum (first coll)))\r\n                [rest-res rest-sum] (lazy-seq (parse-seq fst-sum (rest coll)))]\r\n            [(cons fst-res rest-res) rest-sum])))))]\r\n  (first (parse-seq sum coll))))", "problem": 112, "user": "4e994541535dbda64a6f6b64"}, {"code": "(fn con \n  ([n c] (con n c []))\n  ([n [f & r] h] (if (coll? f) \n                     (conj h (con n f [])) \n                     (if (or (nil? f) (neg? (- n f))) \n                         h \n                         (con (- n f) r (conj h f))))))", "problem": 112, "user": "4dae916eedd6309eace4d155"}, {"code": "(comp second (fn f [s t]\r\n  (cond\r\n   (empty? t) [s ()]\r\n   (coll? (first t))\r\n    (let [[s1 t1] (f s (first t))\r\n\t  [s2 t2] (f s1 (rest t))]\r\n      [s2 (cons t1 t2)])\r\n   (< s (first t)) [s ()]\r\n   true\r\n    (let [[s1 t1] (f (- s (first t)) (rest t))]\r\n      [s1 (cons (first t) t1)]))))", "problem": 112, "user": "4eb97b2e535dfed6da9c6d54"}, {"code": "(fn [q s]\n  (let [k (count (take-while #(<= % q) (reductions + (flatten s))))]\n    ((fn f [k s]\n      (lazy-seq\n        (when (and (> k 0) (seq s))\n          (let [e (first s)]\n            (if (coll? e)\n              (let [c (count (flatten e))]\n                (cons (f k e) (f (- k c) (rest s))))\n              (cons e (f (- k 1) (rest s))))))))\n      k s)))", "problem": 112, "user": "4e82f85d535db62dc21a62ce"}, {"code": "(fn [n c]\n  (second \n    ((fn t [n c]\n      (or\n        (if-let [i (first c)]\n          (if (coll? i)\n            (let [[q p] (t n i)\n                  [r s] (t (- n q) (rest c))]\n              [(+ q r) (cons p s)])\n            (if (<= i n)\n              (let [[r s] (t (- n i) (rest c))]\n                [(+ n r) (cons i s)]))))\n        [0 []]))\n      n c)))", "problem": 112, "user": "4ec2fe3f535dcc7ae8597d4f"}, {"code": "#(letfn [(fun [n s [f & l]]\n  \t   (if (coll? f) (concat [(fun n s f)] (if l (fun n (+ s (apply + (flatten f))) l)))\n\t  (if (>= n (+ s f)) (if l (cons f (fun n (+ s f) l)) [f]) [])))]\n\t  (fun % 0 %2))", "problem": 112, "user": "4dae4da5c9a9d6ed4e99dc57"}, {"code": "(fn sum-< [n tree]\n  (letfn [\n      (f [sum tree acc]\n         ;(println sum tree acc)\n         (cond\n           (or (< n sum) (empty? tree)) [sum tree (reverse acc)]\n           (sequential? (first tree)) \n             (let [[sum* tree* acc*] (f sum (seq (first tree)) ())]\n                 (f (+ sum sum*) (rest tree) (cons acc* acc)))\n           :else \n             (if (< n (+ sum (first tree)))\n               [sum tree (reverse acc)]\n               (f (+ sum (first tree)) (rest tree) (cons (first tree) acc)))))]\n    (last (f 0 tree ()))))", "problem": 112, "user": "4ed188c8535d44c135fd68cf"}, {"code": "(fn p112 [v col]\n  (let [check_sum (fn check_sum [v current_sum  data]\n                     (loop [new_sum current_sum current_v (first data) restdata (rest data) result []]\n                        (if (empty? restdata)\n                             (if (sequential?  current_v)\n                                 (concat result [ (check_sum v new_sum current_v) ])\n                                 (if (> (+ current_v new_sum) v)\n                                     result\n                                     (conj result current_v)\n                                   )\n                             )\n                             (if (sequential?  current_v)\n                                (concat result  [ (check_sum  v new_sum current_v) ])\n                                 (if (> (+ current_v new_sum) v)\n                                     result\n                                     (recur (+ current_v new_sum) (first restdata) (rest restdata) (conj result current_v) )\n                                   )\n                             )\n\n\n                       )\n\n    ))]\n    (check_sum v 0 col)\n   )\n  )", "problem": 112, "user": "4ec5bec6535d6d7199dd36b3"}, {"code": "(fn sh \n  [limit v]\n(let [current (first v)]\n   (if (nil? current) []\n         (cond (number? current)\n               (if (> current limit) []\n                   (cons current (sh (- limit current)(rest v))))\n               :else \n               (vector (sh limit current))))))", "problem": 112, "user": "4dcfbc44535d5973398f92a7"}, {"code": "(fn f[m x]\r\n  (letfn [(g [x] (if (coll? x) (not-empty (flatten x)) true))\r\n          (h [x] (if (coll? x) (reduce + (flatten x)) x))]\r\n    (reduce\r\n      (fn [t v]\r\n        (let [s (h t)\r\n              t2 (if (coll? v) (f (- m s) v) v)]\r\n          (if (>= m (+ s (h t2)))\r\n            (if (g t2)\r\n              (conj t t2)\r\n              t)\r\n            t)))\r\n      []\r\n      (take 20 x))))", "problem": 112, "user": "4ec0c7ba535dfed6da9c6da4"}, {"code": "(fn horr [n x]\n  (if (empty? x)\n    (list)\n    (let [y (first x)]\n      (cond\n        (sequential? y) (let [s (apply + (flatten y))]\n                          (if (<= s n) (cons y (horr (- n s) (rest x)))\n                                       (list (horr n y))))\n        (> y n) (list)\n        :else (cons y (horr (- n y) (rest x)))))))", "problem": 112, "user": "4ed94d69535d10e5ff6f5303"}, {"code": "(fn sequs-horribilus [n [x & coll]]\n  (cond \n    (not (sequential? x)) \n      (cond \n        (and (empty? coll) (> x n)) (list)\n        (empty? coll) (list x)\n        (> x n) (list)\n        :else (cons x (sequs-horribilus (- n x) coll)))\n    :else\n    (list (sequs-horribilus n x))))", "problem": 112, "user": "4ecdb0bb535d23f036227709"}, {"code": "(comp second\n        (fn sh\n          [n [h & t :as s]]\n          (cond\n           (empty? s) [n '()]\n           (coll? h) (let [[n h] (sh n h)\n                           [next-n next-s] (sh n t)]\n                       [next-n (cons h next-s)])\n           (or (< n 0)  (> h n)) [n '()]\n           :else\n           (let\n               [\n                [next-n next-s] (sh (- n h) t )]\n             [next-n (cons h next-s) ]))))", "problem": 112, "user": "4e6f578c535d5021c1a8961b"}, {"code": "(fn [l r s t [a & b :as c]]\n  (if (seq c)\n    (if (coll? a)\n      (recur (conj l s) (conj r b) [] t a)\n      (if (>= t a)\n        (recur l r (conj s a) (- t a) b)\n        (reduce #(conj %2 %) s (rseq l))))\n    (if (seq l)\n      (recur (pop l) r (conj (peek l) s) t (peek r))\n      s)))\n[] [] []", "problem": 112, "user": "4e8f1ac6535d65386fec2146"}, {"code": "(fn sequs-horribilis [n [x & xs :as xss]]\n  (cond (empty? xss) ()\n        (sequential? x) (list (sequs-horribilis n x))\n        (< n x) ()\n        :else (cons x (sequs-horribilis (- n x) xs))))", "problem": 112, "user": "4ee3b586535d10e5ff6f5371"}, {"code": "(fn f [n [h & t]]\n  (cond\n    (coll? h)\n      (cons (f n h) (f (- n (apply + (flatten (f n h)))) t))\n    h\n      (if (>= n h)\n        (cons h (f (- n h) t))\n        [])\n    1 h))", "problem": 112, "user": "4ee82539535d93acb0a66878"}, {"code": "(fn seq-upto [n s]\n  (lazy-seq\n    (when (seq s)\n      (if (sequential? (first s))\n        (list (seq-upto n (first s)))\n        (if (>= (- n (first s)) 0)\n          (cons (first s) (seq-upto (- n (first s)) (rest s))))))))", "problem": 112, "user": "4e7263a1535d5021c1a8965f"}, {"code": "(fn sh [n s]\n  (letfn [(shh [v n [f & r]]\n            (cond (nil? f) ['() 0]\n                  (sequential? f) (let [[re vp] (shh 0 n f)]\n                                    (if (empty? re) ['() 0]\n                                        (let [[rep vpp] (shh (+ v vp) (- n vp) r)]\n                                          [(concat (list re) rep) (+ v vp vpp)])))\n                  (<= f n) (let [[re vp] (shh (+ v f) (- n f) r)]\n                             [(cons f re) (+ v f vp)])\n                  :else ['() 0]))]\n    (first (shh 0 n s))))", "problem": 112, "user": "4ede8e1d535d10e5ff6f5339"}, {"code": "(fn [n s]\n  (letfn [(op [n s]\n    (cond (empty? s) '()\n          (sequential? (first s))\n            (let [it (op n (first s))]\n              (if (= it (first s))\n                (cons it (op (- n (reduce + (flatten s))) (rest s)))\n                (list it)))\n          (> (first s) n) '()\n          true (cons (first s)\n                  (op (- n (first s)) (rest s)))))]\n    (op n s)))", "problem": 112, "user": "4ebc08a8535dfed6da9c6d7c"}, {"code": "(fn [n s]\n(letfn [(sequs [n s]\n(loop [acc 0 v [] s s]\n(if (or (empty? s) (< n acc))\n[acc v]\n(let [elt (first s)]\n(if (vector? elt)\n(let [[m t] (sequs (- n acc) elt)\nnewacc (+ acc m)]\n(recur newacc (if (empty? t) v (conj v t)) (rest s)))\n(let [newacc (+ acc elt)]\n(recur newacc (if (< n newacc) v (conj v elt)) (rest s))))))))]\n(second (sequs n s))))", "problem": 112, "user": "4ee82a02535d93acb0a66879"}, {"code": "(fn f\n         ([n s] (f n s []))\n         ([n s r]\n           (cond \n             (empty? s)  r\n             (coll? (first s))(let [t (f n (first s) [])]\n                                (f (- n (apply + (flatten t))) (rest s) (conj r t)))\n             (< n (first s)) r\n             :t (f (- n (first s)) (rest s) (conj r (first s))))))", "problem": 112, "user": "4deff9f9535d08e6dec9fe15"}, {"code": "(fn sequs [n s]\n  (let [f (fn anon [x n coll]\n            (if (empty? coll)\n              '()\n              (if (sequential? (first coll))\n                (let [itm (anon x n (first coll))\n                      sum (apply + (flatten itm))]\n                  (if (<= (+ x sum) n)\n                    (cons itm (anon (+ x sum) n (rest coll)))\n                    '()))\n                (if (<= (+ x (first coll)) n)\n                  (cons (first coll) (anon (+ x (first coll)) n (rest coll)))\n                  '()))))]\n    (f 0 n s)))", "problem": 112, "user": "4e7f51eb535db966e863cc3f"}, {"code": "(fn [n l]\n  (letfn [(sh [n a l] (if \n    (empty? l) a \n    (let [[h & t] l]\n     (if \n      (sequential? h) (let [pf (sh n [] h)] (sh (- n (reduce + 0 (flatten pf))) (conj a pf) t))\n     (if (<= h n) (sh (- n h) (conj a h) t)  a)))))]\n  (sh n [] l)))", "problem": 112, "user": "4ede8789535d10e5ff6f5337"}, {"code": "(fn [target sequs]\n  ((fn shs [s sum acc]\n     (let [x (first s) xs (rest s)]\n       (cond\n        (coll? x) (conj acc (shs x sum []))\n        (or (empty? s) (> (+ x sum) target)) acc\n        :else (recur xs (+ x sum) (conj acc x))))\n     ) sequs 0 [])\n)", "problem": 112, "user": "4e720985535d5021c1a89655"}, {"code": "(fn [n s]\n  ((fn g [n [h & t]]\n    (if (coll? h)\n      `(~(g n h))\n      (if (and h (>= n h))\n        (cons h (g (- n h) t))\n        ()))) \n   n s))", "problem": 112, "user": "4ef49c2c535dced4c769f238"}, {"code": "(letfn\n  [(take-sum [n coll]\n    (loop [sum     0 \n           coll    coll\n           results []]\n      (if (empty? coll)\n        [sum results]\n        (let [[x & more] coll]\n          (if (coll? x)\n            (let [[sub-sum sub-results] (take-sum (- n sum) x)]\n              (recur (+ sum sub-sum) more (conj results sub-results)))\n            (let [sum (+ sum x)]\n              (if (>  sum n)\n                [sum results]\n                (recur sum more (conj results x)))))))))] \n  (fn [n coll]\n    (let [[sum result] (take-sum n coll)]\n      result)))", "problem": 112, "user": "4e593dac535d8a8b8723a29c"}, {"code": "(fn d [n [h & t :as s]] \n   (cond \n     (empty? s) [] \n     (coll? h)  [(d n h)]\n     (>= n h) (concat [h] (d (- n h) t))\n     :else []))", "problem": 112, "user": "4eb13d60535d7eef3080733f"}, {"code": "(fn [mx cs]\n              (let [s (atom 0)]\n                   ((fn rec [n]\n                        (take-while identity\n                                    (map #(if (coll? %)\n                                           (let [r (rec %)] ({() 0} r r))\n                                           (if (<= (swap! s (partial + %)) mx) %))\n                                         n)))\n                    cs)))", "problem": 112, "user": "4ee82223535d93acb0a66877"}, {"code": "(fn r [n form]\n    (map second (take-while identity\n                 (next (iterate (fn [[c _ [s & ss]]]\n                                  (when s\n                                    (if (coll? s)\n                                      (let [res (r (- n c) s)]\n                                        [(+ c (reduce + (flatten res))) res ss])\n                                     (when (<= (+ c s) n)\n                                       [(+ c s) s ss])))) [0 nil form]))\n                 )))", "problem": 112, "user": "4e6a0667535d8ccf87e9fe9e"}, {"code": "(fn f [n coll]\n  (lazy-seq\n   (when-let [[x & xs] (seq coll)]\n     (if (coll? x)\n       (let [c (f n x)]\n         (cons c (f (- n (reduce + (flatten c))) xs)))\n       (when (>= n x)\n         (cons x (f (- n x) xs)))))))", "problem": 112, "user": "4ec5aa1f535d6d7199dd36b0"}, {"code": "(fn horribilis [max aseq]\n  (letfn [(deep-sum [numbers] (reduce + (flatten numbers)))]\n    (when-let [[elem & rest] aseq]\n      (cond (sequential? elem) (let [taken (horribilis max elem)]\n                                  (cons taken (lazy-seq (horribilis (- max (deep-sum taken)) rest))))\n            (<= elem max) (cons elem (lazy-seq (horribilis (- max elem) rest)))\n            :else '()\n        ))))", "problem": 112, "user": "4eb9ce75535dfed6da9c6d5e"}, {"code": "(fn sequs [n c]\n        (let* [f (flatten c)\n               s (map-indexed #(apply + %2 (take % f)) f)\n               n (count (take-while #(<= % n) s))]\n              (letfn [(f [n c]\n                        (if (coll? c)\n                          (loop [n n c c e []]\n                            (if (or (= n 0) (empty? c))\n                              [n e]\n                              (let [[p g] (f n (first c))]\n                                (recur p (rest c) (conj e g)))))\n                          [(dec n) c]))]\n                (second (f n c)))))", "problem": 112, "user": "4f031eac535dcb61093f6a67"}, {"code": "(fn horror [sum c]\n  (if (empty? c)\n    '()\n    (let [f (first c) r (rest c)]\n      (if (coll? f)\n        (letfn [(total [c] (apply + (flatten c)))]\n          (cons (horror sum f) (horror (- sum (total f)) r)))\n        (if (>= sum f) \n          (cons f (horror (- sum f) r))\n          '())))))", "problem": 112, "user": "4e9c81e8535dbda64a6f6b80"}, {"code": "(fn copia [n l]\r\n    (let [total (fn total [l]\r\n  \t\t\t(cond\r\n    \t\t\t(not (coll? l)) l\r\n\t\t\t    (empty? l) 0    \r\n\t\t\t    :else  (+ (total (first l)) (total (rest l)))))\r\n\t\t\t\r\n\t\t first* (fn first* [l]  \r\n\t\t\t  (cond     \r\n\t\t     (not (coll? l)) l\r\n\t\t     (empty? l) 0\r\n\t\t     :else (first* (first l))))]\r\n\t\t     \r\n   (cond \r\n    (not (coll? l)) l\r\n    (empty? l) '()\r\n    (< n (first* l)) '()\r\n    :else (let [num (total (first l))]\r\n            (if (<= num n) (cons (first l) (copia (- n num) (rest l))) \r\n              (cons (copia n (first l)) '()))))))", "problem": 112, "user": "4f04a06d535dcb61093f6bd9"}, {"code": "(fn sh [v nl]\n  (letfn [(iter [rt tmp]\n    (if (empty? tmp)\n      ()\n      (if (coll? (first tmp))\n        (list (iter rt (first tmp)))\n        (if (<= (+ rt (first tmp)) v)\n          (cons (first tmp) (iter (+ rt (first tmp)) (rest tmp)))\n          ()))))]\n    (iter 0 nl)))", "problem": 112, "user": "4e6a2f51535d8ccf87e9fea9"}, {"code": "(fn s [m [x & c]]\n   (if x\n     (if (coll? x)\n       (cons (s m x) (s (- m (apply + (flatten x))) c))\n       (if (> x m) []\n         (cons x (s (- m x) c))))))", "problem": 112, "user": "4e65027c535d8ccf87e9fe6e"}, {"code": ";(fn deep-copy [sum s] (when (seq s) (let [[f & xs] s ff (if (sequential? f) (deep-copy sum f) f) nsum (- sum (if (sequential? f) (reduce + (flatten ff)) f))] (if (and ff (<= 0 nsum)) (cons ff (deep-copy nsum xs)) ()))))\n#(second (% %2 %3))\n (fn coll [limit c]\n  (loop [l limit [x & xs :as s] c bucket []]\n    (if (or (< l 0) (empty? s)) [l bucket]\n      (let [[[nl x] pred] (if (coll? x) [(coll l x) seq] [[(- l x) x] #(>= l %)])]\n        (recur nl xs (if (pred x) (conj bucket x) bucket))))))", "problem": 112, "user": "4effb663535dcb61093f6a2e"}, {"code": "(fn sh [n s]\n  (letfn [(impl [s tot ret]\n    (cond\n      (not s) \n        {:done tot :ret (reverse ret)}\n      (integer? (first s))\n        (if (> (+ tot (first s)) n)\n          {:done true :ret (reverse ret)}\n          (impl \n            (next s) \n            (+ tot (first s)) \n            (conj ret (first s))))\n      (coll? (first s))\n        (let [i (impl (first s) tot '())]\n          (if (= (i :done) true)\n            {:done true :ret (reverse (conj ret (i :ret)))}\n            (impl (next s)\n              (+ tot (i :done))\n              (conj ret (i :ret)))))))]\n    ((impl s 0 '()) :ret)))", "problem": 112, "user": "4f050dec535dcb61093f6bef"}, {"code": "(fn prob-0112\n  [p-todo p-xs]\n  (let [sum-filter (fn sum-filter\n                     [in-xs todo]\n                     (let [xs (seq in-xs)]\n                       (if-not xs\n                         [() todo]\n                         (let [x (first xs)]\n                           (if (and (not (coll? x)) (> x todo))\n                             [() Double/NEGATIVE_INFINITY]\n                             (let [[new-x  new-todo1] (if (coll? x)\n                                                        (sum-filter x todo)\n                                                        [x (- todo x)])\n                                   [new-xs new-todo2] (sum-filter (rest xs) new-todo1)]\n                               [(cons new-x new-xs) new-todo2])))))) ]\n\n    (first (sum-filter p-xs p-todo))))", "problem": 112, "user": "4f047c07535dcb61093f6bcd"}, {"code": "(fn [s col]\n  (let [func (fn func [upto col]\n                (if-not (sequential? col) (when (<= col upto) [col (- upto col)])\n                (loop [c col l upto acc []]\n                  (if (empty? c) [acc l]\n                    (let [f (func l (first c))]\n                      (if (empty? f) [acc l]\n                        (recur\n                          (rest c)\n                          (second f)\n                          (conj acc (first f)))))))))]\n    (first (func s col))))", "problem": 112, "user": "4f03ac2d535dcb61093f6b4a"}, {"code": "(fn [sum coll]\n  (first\n   ((fn l [sum item]\n      (cond\n       (coll? item)\n       (let [matching-items\n             (take-while (fn [[_ sum]] (<= 0 sum))\n                         (reductions (fn [[ret sum] x]\n                                       (let [[rx rsum] (l sum x)]\n                                         [[rx] rsum]))\n                                     [[] sum] item))]\n         [(mapcat first matching-items) (last (last matching-items))])\n       :else [item (- sum item)]\n       )) sum coll)))", "problem": 112, "user": "4f04b66b535dcb61093f6bdd"}, {"code": "#(first ((fn f [v s]\n  (if (empty? v)\n    [v s]\n    (let [x (first v)]\n    (if (coll? x)\n      (let [[r t] (f x s)]\n        (if (> t %)\n          [[r] t]\n          (let [[w n] (f (rest v) t)]\n            [(cons r w) n])))\n      (let [m (+ x s)]\n        (if (> m %)\n          [[] m]\n          (let [[w n] (f (rest v) m)]\n            [(cons x w) n]))))))\n) %2 0))", "problem": 112, "user": "4f01c938535dcb61093f6a39"}, {"code": "(fn [v c] \n   (let [x (atom 0)]\n      (letfn [(f [s c]          \n                (if c\n                   (let [[a & r] c]\n                      (if (coll? a) \n                          (concat (list (f s a)) (f s r))\n                          (if (<= (+ @s a) v)\n                              (do\n                                 (swap! s + a)\n                                 (cons a (f s r)) )\n                              ()))))) ]\n              (f x c)) ))", "problem": 112, "user": "4ee7d177535d93acb0a6686f"}, {"code": "(fn rec [n coll]\n  (if (or (not coll) (neg? n))\n    '()\n    (let [[x & c] coll]\n      (lazy-seq (cond (coll? x) [(rec n x)]\n                      (neg? (- n x)) '()\n                      :else (cons x (rec (- n x) c)))))))", "problem": 112, "user": "4daec9dcedd6309eace4d15f"}, {"code": "(comp second\n  (fn f [n [x & xs]]\n   (if (nil? x) [n ()]\n      (let [[n* x*] \n            (if (coll? x) (f n x) [(- n x) x])]\n        (if (< n* 0) [0 ()] \n          (let [[n* xs*] (f n* xs)]\n            [n* (cons x* xs*)]))))))", "problem": 112, "user": "4f06dcad535dcb61093f6c16"}, {"code": "(fn doit [left [a & as :as s]] \n   (cond \n     (empty? s) [] \n     (coll? a)  [(doit left a)]\n     (>= left a) (concat [a] (doit (- left a) as))\n     :else []))", "problem": 112, "user": "4f0e995e535d0136e6c22326"}, {"code": "(fn f [n [x & xs] & [total]]\n   (or (first\n         (last\n           (take-while\n             (fn [[xs ys]]               \n               (and (last xs)  (>= n (+ (or total 0) (reduce + (flatten xs))))))           \n             (iterate\n               (fn [[ys [x & xs]]]\n                 [(conj ys (if (coll? x) \n                             (f n x (+ (or total 0) (reduce + (flatten ys)))) x)) xs])\n               [[x] xs]))))\n       []))", "problem": 112, "user": "4e513758535dc968683fc4f3"}, {"code": "(fn f [n xs]\n  (letfn [(step [n xs sum]\n    (reduce\n      (fn [[s r] i]\n        (if (coll? i)\n          (let [sr (step n i s)]\n            (if (= [] (last sr))\n              [s r]\n              [(first sr) (conj r (last sr))]))\n          (if (> (+ s i) n)\n            [s r]\n            [(+ s i) (conj r i)]))) [sum []] xs))]\n  (last (step n (take 100 xs) 0))))", "problem": 112, "user": "4f1b92d1535d64f60314647b"}, {"code": "(fn mu \n  ( [limit coll] (first (mu coll identity limit)))\n  ( [coll f limit]\n  (if-let [s (seq coll)]\n    (let [\n      el (first s)\n      [el limit]\n        (if (sequential? el) \n            (mu el identity limit)\n            [el (- limit el)])\n     ]\n      (cond \n        (>= limit 0)\n          (recur (next s) (comp f (partial cons el)) limit)\n        (sequential? el)\n           [(f (cons el nil)) limit]\n        :default [(f '()) limit])\n    )\n    [(f '()) limit]\n  )))", "problem": 112, "user": "4f03154a535dcb61093f6a58"}, {"code": "(fn horseq [n tree]\n  (letfn [(treesum [tree]\n            (if (coll? tree)\n              (reduce + (map treesum tree))\n               tree))]\n    (when (>= n 0)\n      (if (coll? tree)\n      \t(if (seq tree)\n\t  (let [fpart (horseq n (first tree))\n              \tsum (treesum fpart)]\n            (if fpart\n              (cons fpart\n                    (horseq (- n sum) (rest tree)))\n              ()))\n\t  ())\n      \t(when (<= tree n) tree)))))", "problem": 112, "user": "4f0d093b535d0136e6c22313"}, {"code": "(fn [n s]\n  (nth ((fn g [n s]\n           (loop [v [] t n r s]\n             (if (empty? r)\n               [v t]\n               (let [e (first r)]\n                 (if (coll? e)\n                   (let [l (g t e)\n                         sv (nth l 0)]\n                     (recur (if (not (empty? sv)) (conj v sv) v) (nth l 1) (rest r)))\n                   (if (<= 0 (- t e))\n                     (recur (conj v e) (- t e) (rest r))\n                     [v t]))))))\n        n s) 0))", "problem": 112, "user": "4ee9ddb8535d93acb0a66896"}, {"code": "(fn [x t]\n  (or\n    ((fn f [x t]\n       (if (sequential? t)\n         (when-first [a t]\n           (when-let [g (f x a)]      \n          (cons g (f (- x (reduce + (flatten [a]))) (rest t)))))\n         (when (<= t x) t)))\n      x t)\n    []))", "problem": 112, "user": "4f08b15b535dcb61093f6c40"}, {"code": "(fn __ ([t c] (__ t c 0 []))\n  ([t c s a] (let [[f & r] c]\n               (if (coll? f) (conj a (__ t f s []))\n                   (let [sm (+ f s)]\n                     (cond (> sm t) a\n                           (nil? r) (conj a f)\n                           :else (__ t r sm (conj a f))))))))", "problem": 112, "user": "4f0478b0535dcb61093f6bcb"}, {"code": "(fn f\n    ([n c] (fnext (f n c [])))\n    ([n c s]\n       (if-let [c (seq c)]\n         (let [i (first c)\n               [n s]\n               (if (coll? i)\n                 (let [[n s2] (f n i [])] [n (conj s s2)])\n                 [(- n i)\n                  (if (< n i) s (conj s i))]\n                 )]\n           (if (< n 0)\n             [n s]\n             (f n (rest c) s)))\n         [n s])))", "problem": 112, "user": "4f0664bd535dcb61093f6c0f"}, {"code": "(fn ff[a r n s] \n  (if-let [e (first s)] \n    (if (coll? e) \n      (conj r (ff a [] n e)) \n      (if (>= n (+ a e)) \n        (recur (+ a e) (conj r e) n (next s)) \n        r)) \n    r)) 0 []", "problem": 112, "user": "4f1fd734535d64f6031464a5"}, {"code": "(fn [n itree]\n    (letfn [(remove-last-leaf-node [tree]\n              (let [all-but-last-node (butlast tree)\n                    last-node (last tree)]\n                (if (coll? last-node)\n                  (if (empty? last-node)\n                    (into [] all-but-last-node)\n                    (assoc (into [] tree) (dec (count tree)) (remove-last-leaf-node last-node)))\n                  (into [] all-but-last-node))))\n            (max-top-level-elements-needed [tree]\n              (count (take-while #(<= % n)\n                                 (reductions + (flatten tree)))))]\n       (loop [itree (take (max-top-level-elements-needed itree) itree)] ; at most n top-level will be used\n          (if (<= (apply + (flatten itree)) n)\n            itree\n            (recur (remove-last-leaf-node itree))))))", "problem": 112, "user": "4e89e939535d3e98b8023287"}, {"code": "(fn take-sum [n v]\n  (letfn [(flatten-sum [v] (reduce + (flatten v)))]\n    (if (empty? v) '()\n      (if (integer? (first v))\n        (if (< n (first v))\n          '()\n          (cons (first v) (take-sum (- n (first v)) (rest v))))\n        (cons (take-sum n (first v)) (take-sum (- n (flatten-sum (first v))) (rest v)))))))", "problem": 112, "user": "4f251302e4b0d66497709ff0"}, {"code": "#((fn f [s n]\n    (loop [l s p n o []]\n      (let [i (first l)\n            [j q] (if (and (>= p 0) i)\n                    (if (coll? i) [(f i p) -1] (if (>= (- p i) 0) [i (- p i)])))]\n        (if q (recur (rest l) q (conj o j)) o))))\n   %2 %)", "problem": 112, "user": "4f1d1d95535d64f603146488"}, {"code": "(fn [num coll]\n    (let [howmany (loop [sum num seq (flatten coll) i 0]\n      (if (or (empty? seq) (> (first seq) sum))\n        i\n        (recur (- sum (first seq)) (rest seq) (inc i))))]\n      ((fn ! [seq i]\n         (loop [result [] s seq j i]\n           (if (or (empty? s) (= j howmany))\n             result\n             (if (coll? (first s))\n               (recur (conj result (! (first s) j)) (rest s) (+ j (count (flatten (! (first s) j)))))\n               (recur\n                (if (< j howmany)\n                  (conj result (first s))\n                  result\n                  )\n                (rest s) (inc j))\n               )\n             ))\n         ) coll 0)\n      ))", "problem": 112, "user": "4ea31da2535d7eef308072c1"}, {"code": "(fn seqh\n  ([t s r c]\n    (if (sequential? (first s))\n      (let [nestedr (seqh (- t c) (first s) [] 0)\n            newr (reduce + (flatten (conj r nestedr)))]\n            (if (empty? nestedr)\n              r\n              (seqh t (rest s) (conj r nestedr) newr)))\n      (if (or (empty? s) (< t (+ c (first s))))\n        r\n        (seqh t (rest s) (conj r (first s)) (+ c (first s))))))\n  ([t s] (seqh t s [] 0)))", "problem": 112, "user": "4f0e4ebd535d0136e6c22322"}, {"code": "(fn [n v]\n  (let [sh1 (fn sh ([t c] (sh t c {:r [] :n 0}))\n  ([t c m] (let [r (m :r) n (m :n)](cond \n\t\t         (> n t) {:r r :n n} (empty? c) {:r r :n n}\n\t\t\t ((complement coll?) (first c)) \n\t\t\t    (let [n1 (+ n (first c))]\n\t\t\t      (if (> n1 t) {:r r :n n1}\n\t\t\t         (sh t (next c) {:r (conj r (first c)) :n (+ n (first c))})))\n\t\t\t (coll? (first c)) \n\t\t\t   (let [re (sh t (first c) {:r [] :n n}),\n\t\t\t\tr1 (re :r),n1 (re :n)]\n\t\t\t    (if (> n1 t) {:r (conj r r1) :n n1}\n\t\t\t    (sh t (next c) {:r (conj r r1) :n n})))))))]\n  ((sh1 n v) :r)))", "problem": 112, "user": "4ec5d62c535d6d7199dd36ba"}, {"code": "(fn f [n coll]\n  (cond\n    (empty? coll) ()\n    (coll? (first coll)) (list (f n (first coll)))\n    (> (first coll) n) ()\n    :else (let [c (f (- n (first coll)) (rest coll))]\n            (if (empty? c)\n              (list (first coll))\n              (cons (first coll) c)))))", "problem": 112, "user": "4e9519b4535dbda64a6f6b2d"}, {"code": "#(second \n   ((fn f [[e & c] l r]\n      (cond (coll? e) (let [s (f e l [])]\n                        (recur c (first s) (conj r (second s))))\n            (and e (<= e l)) (recur c (- l e) (conj r e))\n            :else [l r])) \n     %2 % []))", "problem": 112, "user": "4efb2fd7535dced4c769f274"}, {"code": "#(\n  second \n  ((fn f [sum x]\n      (if (coll? x)\n        (loop [s sum sq x acc []]\n          (if (empty? sq)\n            [s acc]\n            (let [[news e] (f s (first sq))]\n              (if (neg? news)\n                [0 acc]\n                (recur news (rest sq) (conj acc e))))))\n        [(- sum x) x])\n    ) %1 %2))", "problem": 112, "user": "4e1350af535d04ed9115e7d8"}, {"code": "(fn sequs\n  ([num coll] (filter #(or ((comp not empty? flatten) %) (not (coll? %))) (sequs num coll [])))\n  ([num coll acc]\n     (letfn [(ct1 [coll]\n                (if (not (coll? coll))\n                  coll\n                  (reduce (fn [acc item]\n                            (if (coll? item)\n                              (+ acc (ct1 item))\n                              (+ acc item))) 0 coll)))]\n       (if (or (empty? coll) (< num 0))\n         acc\n         (let [item (first coll)]\n           (if (coll? item)\n             (sequs (- num (ct1 item)) (rest coll) (conj acc (sequs num item [])))\n             (if (>= (- num (ct1 item)) 0)\n               (sequs (- num (ct1 item)) (rest coll) (conj acc item))\n               (sequs (- num (ct1 item)) (rest coll) acc))))))))", "problem": 112, "user": "4f036d9b535dcb61093f6ac1"}, {"code": "(fn [v xs]\n(second ((fn g [v xs]\n  (if (empty? xs)\n    [v '()]\n    (let [[x & rxs] xs]\n      (cond \n        (coll? x) (let [[nv nx] (g v x)] (if nv (let [[mv mxs] (g nv rxs)] [mv (cons nx mxs)]) [nil (list nx)]))\n        (> x v) [nil '()]\n        :else (let [[mv mxs] (g (- v x) rxs)] [mv (cons x mxs)]))))) v xs)))", "problem": 112, "user": "4ec07699535dfed6da9c6da2"}, {"code": "(fn [tot tree]\n    (let [zipper clojure.zip/zipper\n          root clojure.zip/root\n          up clojure.zip/up\n          end? clojure.zip/end?\n          node clojure.zip/node\n          remove clojure.zip/remove\n          next clojure.zip/next\n          \n          trim-tail\n            (fn [[node path :as loc]]\n                (with-meta [node (assoc path :r nil :changed? true)] (meta loc)))\n          root? (fn [[node path]] (nil? path))\n          coll-zip\n            (fn [root]\n                (zipper coll? seq (fn [node children] (with-meta (or children ()) (meta node)))\n                        root))\n        ]\n        (loop [runsum 0, loc (coll-zip tree)]\n            (cond\n                (> runsum tot)\n                    (if (root? loc)\n                        (node loc)\n                        (recur runsum (-> loc trim-tail up)))\n                (end? loc)\n                    (root loc)\n                :else\n                    (let [n (node loc)\n                          runsum* (+ runsum (if (number? n) n 0))]\n                        (if (> runsum* tot)\n                            (recur runsum* (-> loc trim-tail remove))\n                            (recur runsum* (next loc))))\n            ))))", "problem": 112, "user": "4df3d4f4535d08e6dec9fe2c"}, {"code": "(fn ! [n [h & t]]\n  (if h\n    (if (coll? h)\n      (let [e (! n h) s (reduce + (flatten e))]\n        (cons e (! (- n s) t)))\n      (if (<= h n) (cons h (! (- n h) t)) '()))))", "problem": 112, "user": "4e7d1c22535db169f9c796c5"}, {"code": "(fn this [m l]\r\n  (letfn [(worker [l s]\r\n            (cond\r\n             (empty? l) (list '() s)\r\n             (coll? (first l)) (let [[cl cs] (worker (first l) s)\r\n                                     [rl rs] (worker (rest l) cs)]\r\n                                 (list (cons cl rl) cs))\r\n             (<= (+ s (first l)) m) (let [[rl rs] (worker (rest l) (+ (first l) s))]\r\n                                      (list (cons (first l) rl) rs))\r\n             :else (list '() s)))]\r\n    (first (worker l 0))))", "problem": 112, "user": "4f474f43e4b0d56e7bb92bb7"}, {"code": "(fn [n seq]\n    (letfn [(dig [sum seq]\n        (loop [acc [] sum sum [x & xs :as tail] seq]\n            (cond (empty? tail)     [sum acc]\n                  (sequential? x)   (let [[new-sum sub-seq] (dig sum x)] (recur (conj acc sub-seq) new-sum xs))\n                  :else             (if (<= (+ x sum) n)\n                                        (recur (conj acc x) (+ sum x) xs)\n                                        [sum acc]))))]\n        (last (dig 0 seq))))", "problem": 112, "user": "4f4ac35ae4b0d56e7bb92c18"}, {"code": "(fn sh [n [s1 & s]]\n\n  (cond\n    (nil? s1) nil\n    (sequential? s1) (list (sh n s1))\n    :else\n      (if (< n s1)\n        '()\n        (cons s1 (sh (- n s1) s)))))", "problem": 112, "user": "4f29eb2ae4b0d6649770a037"}, {"code": "(fn [lim c]\n          (second ((fn f [n [x & xs] r]\n             (if (nil? x) [n r]\n                 (if (coll? x) (let [[n1 xs1] (f n x [])] (recur n1 xs (conj r xs1)))\n                     (if (>= n x) (recur (- n x) xs (conj r x))\n                         [n r]))))\n           lim c [])))", "problem": 112, "user": "4f34eb87e4b0e243712b1eba"}, {"code": "(fn [i c]\n  (let [x (fn x [i cs]\n            (loop [a [] i i c (first cs) cs (next cs)]\n              (cond\n                (coll? c)        (let [[aa i] (x i c)]\n                                   (recur (conj a aa) i (first cs) (next cs)))\n                (and c (>= i c)) (recur (conj a c) (- i c) (first cs) (next cs))\n                :else            [a i])))]\n    (first (x i c))))", "problem": 112, "user": "4f32a7f1e4b0d6649770a095"}, {"code": "(fn walk [n [x & xs :as coll]] \n  (cond \n   (empty? coll) [] \n   (coll? x)     (let [y (walk n x)\n                       sum-y (reduce + (flatten y))]\n                   (concat [y] (walk (- n sum-y) xs)))\n   (<= x n)      (concat [x] (walk (- n x) xs))\n   :else         []))", "problem": 112, "user": "4ebcb8ff535dfed6da9c6d8a"}, {"code": "(fn g [n [f & r]]\n  (cond\n   (number? f) (if (>= (- n f) 0)\n                 (cons f (g (- n f) r))\n                 [])\n   (seq f) [(g n f)]))", "problem": 112, "user": "4e823ed7535db62dc21a62c7"}, {"code": "(fn [mx s]\n  (letfn [\n    (app [e [a b c]]\n      [a b (cons e c)])\n    (horr [lim s]\n      (if (empty? s) [lim false '()]\n        (let [[fst & rst] s]\n          (if (sequential? fst) \n            (let [[nlim cut eaten] (horr lim fst)]\n              (if cut [nlim true (list eaten)]\n                (app eaten (horr nlim rst))))\n            (let [nlim (- lim fst)]\n              (if (> 0 nlim) [lim true '()]\n                (app fst (horr nlim rst))))))))]\n    (last (horr mx s))))", "problem": 112, "user": "4f569218e4b0a7574ea71826"}, {"code": "(fn g [n s]\n  (let [t (atom n)]\n    ((fn f [s]\n      (cond\n        (empty? s)\n          '()\n        (sequential? (first s))\n          (cons (f (first s))\n                (f (rest s)))\n        (> (first s) @t)\n          '()\n        true\n          (do (swap! t #(- % (first s)))\n              (cons (first s)\n                    (f (rest s)))))) s)))", "problem": 112, "user": "4f6fbb68e4b07046d9f4efeb"}, {"code": "(fn horrible [x node]\n  (if-let [h (first node)]\n    (cond\n      (coll? h) (if-let [t (horrible x h)] (list t))\n      (<= h x) (cons h (horrible (- x h) (rest node)))\n      :else '())))", "problem": 112, "user": "4f6160a7e4b0defedf855fbe"}, {"code": "(fn sh [n coll]\r\n  (cond\r\n   (empty? coll)\r\n     coll\r\n   (sequential? (first coll))\r\n     (let [fsh (sh n (first coll))]\r\n       (if (= (first coll) fsh)\r\n         (cons fsh (sh (- n (reduce + (flatten fsh))) (rest coll)))\r\n         [fsh]))\r\n   :else\r\n     (if (>= n (first coll))\r\n       (cons (first coll) (sh (- n (first coll)) (rest coll)))\r\n       [])))", "problem": 112, "user": "4f62b29ce4b0defedf855fd9"}, {"code": "(fn seqhor                                                                                         \n  ([n s]                                                                                             \n     (seqhor n s 0))                                                                                 \n  ([n s total]                                                                                       \n     (when (seq s)                                                                                   \n       (let [e (first s)]                                                                            \n         (if (number? e)                                                                             \n           (let [tot (+ total e)]                                                                    \n             (if (<= tot n)                                                                          \n               (cons e (seqhor n (rest s) tot))                                                      \n                []))                                                                                 \n           (let [res (seqhor n e total)                                                              \n                 incr (reduce + (flatten res))]                                                      \n             (cons res (seqhor n (rest s) (+ incr total)))                                           \n             )                                                                                       \n           )                                                                                         \n         )                                                                                           \n       )                                                                                             \n     )                                                                                               \n  )", "problem": 112, "user": "4f1d1299535d64f603146487"}, {"code": "(fn iter [n [a & r]]\n  (cond\n    (< n 0) []\n    (nil? a) []\n    (coll? a)\n      (let [nest (iter n a)\n            sum (reduce + (flatten nest))]\n        (cons nest (iter (- n sum) r)))\n    (<= a n) (cons a (iter (- n a) r))\n    :else []))", "problem": 112, "user": "4f8345c6e4b033992c121c1b"}, {"code": "(fn res [n c]\n  (if (empty? c)\n    '()\n    (if (coll? (first c))\n      (lazy-seq (cons (res n (first c)) (res (- n (reduce + (flatten (first c)))) (rest c))))\n      (if (>= n (first c))\n        (lazy-seq (cons (first c) (res (- n (first c)) (rest c))))\n        '()\n      )\n    )\n  )\n)", "problem": 112, "user": "4f84400de4b033992c121c2e"}, {"code": "(fn [n c]\n  (first ((fn t [n f]\n    (if (sequential? f)\n        (if (seq f)\n            (let [[ff n] (t n (first f))]\n                 (if (nil? ff)\n                     [() n]\n                     (if (< n 0)\n                         [(list ff) n]\n                         (let [[fr n] (t n (rest f))]\n                              [(cons ff fr) n]))))\n            [() n])\n        [(if (<= f n) f nil) (- n f)])) n c)))", "problem": 112, "user": "4f9120d8e4b0dcca54ed6c96"}, {"code": "(fn sequs [n coll]\n  (lazy-seq\n    (when-let [coll (seq coll)]\n      (cond\n        (sequential? (first coll)) (list (sequs n (first coll)))\n        (< n (first coll)) '()\n        :else (cons (first coll) (sequs (- n (first coll)) (next coll)))))))", "problem": 112, "user": "4f7e29dde4b06e829148e1ca"}, {"code": "(fn g [n [f & _ :as s]] (cond (nil? f )    []\n                             (number? f) (let [m (- n f)]\n                                           (if (>= m 0)\n                                             (cons f (g m (rest s)))\n                                             []))\n                             :else [(g n (first s))]))", "problem": 112, "user": "4ee88bfb535d93acb0a66881"}, {"code": "(fn h [n [q & r]]\r\n  (if q\r\n    (cond\r\n      (coll? q) [(h n q)]\r\n      (<= q n) (cons q (h (- n q) r))\r\n      q [])))", "problem": 112, "user": "4f9597e0e4b0dcca54ed6cd4"}, {"code": "(fn [num coll]\r\n  (letfn [(proc [n [x & xs] pre]\r\n            (let [[nn npre stop]\r\n                  (cond\r\n                    (coll? x) (let [[m c] (proc n x []) p (into pre [c])]\r\n                                [m p (empty? xs)])\r\n                    (<= x n) (let [m (- n x) p (conj pre x)]\r\n                               [m p (empty? xs)])\r\n                    :else [0 pre true])]\r\n              (if (true? stop)\r\n                [nn npre]\r\n                (proc nn xs npre))))]\r\n    (second (proc num coll []))))", "problem": 112, "user": "4f969214e4b0dcca54ed6cdd"}, {"code": "(fn getColSum[num cols]\r\n  (let[putinto (fn putinto[n cols]\r\n                 (loop[start 0,col cols,result []]\r\n                    (let[f (first col),\r\n                         r (rest col)]\r\n                        ;(println (str \"col \" col \" result\" result \" start \" start \" num \" n ) )\r\n  \t\t                  (if(empty? cols)\r\n\t\t\t\t\t\t\t\t\t\t\t\t  {:rest start,:result result}\r\n\t\t                      (cond (coll? f) \r\n                                   (let[res (putinto (- n start) f),\r\n                                        resultCol (conj result (:result res)),\r\n                                        restVal  (+ (:rest res) start) ]\r\n                                        (if (> (- n restVal) 0) \r\n\t\t                                        (recur restVal r resultCol)\r\n                                            {:rest restVal,:result resultCol}\r\n                                        )\r\n                                     )\r\n                                (nil? f)\r\n                                    {:rest start,:result result}\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t      (> f (- n start) ) \r\n                                    {:rest start,  :result result}\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t      :else \r\n                                   (recur (+ start f) r (conj result f) )\r\n\t\t\t\t\t\t\t\t\t\t\t\t  ))))) \r\n       ]\r\n       (:result (putinto num cols) )\r\n    \r\n    )\r\n)", "problem": 112, "user": "4f6d9d7ee4b07046d9f4efcd"}, {"code": "(fn f [t v]\n  (loop [i v o []]\n    (let [s (apply + (flatten o))\n          e (first i)\n          l (rest i)]\n      (cond\n       (empty? i) o\n       (coll? e) (recur l (conj o (f (- t s) e)))\n       (<= (+ s e) t) (recur l (conj o e))\n       :else o))))", "problem": 112, "user": "4f9fe2b9e4b0dcca54ed6d40"}, {"code": "(fn [n s]\n    (letfn [(dig [m ns]\n              (let [f (first ns)]\n                (cond (nil? f) '()\n                      (coll? f) (list (dig m f))\n                      (< n (+ m f)) '()\n                      :else (lazy-seq\n                              (cons f\n                                    (dig (+ m f)\n                                         (rest ns)))))))]\n      (dig 0 s)))", "problem": 112, "user": "4f5cc3b8e4b0030a34fb2b2b"}, {"code": "(fn take-upto [n [head & tail]]\n  (lazy-seq\n   (if head\n     (if (integer? head)\n       (if (<= head n)\n         (cons head (take-upto (- n head) tail)))\n       [(take-upto n head)]))))", "problem": 112, "user": "4f3fb586e4b0e243712b1f9c"}, {"code": "(fn seqhor [n S] \n  (loop [m 0, T S, stack '(), res '(), restack '()]\n    (if (empty? T)\n      (if (empty? stack)\n        (reverse res)\n        (recur m (first stack) (pop stack)\n               (conj (first restack) (reverse res)) (pop restack)))\n      \n      (if (coll? (first T))\n        (recur m (first T) (conj stack (rest T))\n               '() (conj restack res))\n        \n        (if (> (+ m (first T)) n) ; wind down stack \n          (loop [a (if (empty? res) (first restack) res), \n                 b (if (empty? res)\n                     (if (empty? restack)\n                       '()\n                       (pop restack)) \n                     restack)]\n            (if (empty? b)\n              (reverse a)\n              (recur (conj (first b) (reverse a)) (pop b))))\n           \n          (recur (+ m  (first T)) (rest T) stack\n                 (conj res (first T)) restack))))))", "problem": 112, "user": "4faa9593e4b081705acca1f9"}, {"code": "(fn f [m s]\n  (let [q (first s)]\n    (cond (nil? q) q\n          (coll? q) (list (f m q))\n          (> q m) '()\n          :else (cons q (f (- m q) (rest s))))))", "problem": 112, "user": "4facd2fae4b081705acca22f"}, {"code": "(fn [n s]\n    (letfn [(f [m s r]\n               (cond\n                 (empty? s) [m r]\n                 (coll? (first s)) (let [[_m _r] (f m (first s) [])]\n                                     (recur _m (rest s) (conj r _r)))\n                 (> (+ (first s) m) n) [m r]\n                 :else (recur (+ m (first s)) (rest s) (conj r (first s)))))]\n           (second (f 0 s []))))", "problem": 112, "user": "4f969a66e4b0dcca54ed6cde"}, {"code": "(fn [max-sum nodes]\n   (let [sum (atom max-sum)]\n     ((fn f [[x & xs :as nodes]]\n        (cond (nil? x) '()\n              (coll? x) (cons (f x) (f xs))\n              :else (if (>= (swap! sum - x) 0)\n                      (cons x (f xs))\n                      '())\n              )\n        ) nodes)\n     ))", "problem": 112, "user": "4e9fd521535d7eef3080729a"}, {"code": "(fn f [n s] \n    (if (empty? s) \n      '()\n      (if (coll? (first s))\n        (list (f n (first s)))\n        (if (< n (first s))\n          '()\n          (cons (first s) (f (- n (first s)) (rest s))))\n        )))", "problem": 112, "user": "4f0da4e4535d0136e6c22319"}, {"code": "(fn sequs-h [n [h & t]]\r\n  (if (number? h)\r\n     (if (> h n) []\r\n        (cons h (sequs-h (- n h) t)))\r\n     (let\r\n       [_ (println \"n\" n)\r\n        _ (println \"h t\" h t)\r\n        h-sum (apply + (flatten h))\r\n        _ (println \"h sum\" h-sum)\r\n        excess (- n h-sum)]\r\n        (if (> h-sum n)\r\n          [(sequs-h n h)]\r\n          (if (empty? t) [h]\r\n            [ h (sequs-h excess t)])))))", "problem": 112, "user": "4f036fb3535dcb61093f6ac8"}, {"code": "(fn [ms ss]\n    (let [sumfun (fn sumfun [maxsum s]\n                   (cond \n                     (integer? s) [s s]\n                     (empty? s) [0 s]\n                     :else\n                     (let [[i & is] s\n                           [i_sum i_res] (sumfun maxsum i)\n                           remsum (- maxsum i_sum)]\n                       (cond (and (not (integer? i_res)) (empty? i_res)) [maxsum []]\n                             (neg? remsum) [maxsum []]\n                             :else (let [[is_sum is_res] (sumfun remsum is)]\n                                     [(+ i_sum is_sum) (cons i_res is_res)])))))\n          [result_sum result] (sumfun ms ss)]\n      result))", "problem": 112, "user": "4f4274f2e4b0d7d3c9f3fd00"}, {"code": "(fn sequs [n xs]\n  (let [line (fn line [[acc] x]\n    (if (coll? x)\n      (let [ans (->>  x\n            (reductions line [acc])\n            (take-while #(>= (first %) 0)))]\n        [(first (last ans)) (map second (rest ans))])\n      [(- acc x) x]))]\n    (second (line [n] xs))))", "problem": 112, "user": "4e7f5a0b535db966e863cc41"}, {"code": "(fn f [n s]\n  (if (or (neg? n) (empty? s))\n    ()\n    (let [x (first s)]\n      (if (sequential? x)\n        [(f n x)]\n        (if (neg? (- n x))\n          ()\n          (cons x (f (- n x) (rest s))))))))", "problem": 112, "user": "4f954dbce4b0dcca54ed6ccd"}, {"code": "(fn [n s]\n  (letfn [(build [a [h & t] s]\n            (cond (nil? h)        [a s false]\n                  (sequential? h) (let [[sub-a new-s done?] (build [] h s)]\n                                    (if done?\n                                      [(conj a sub-a) new-s true]\n                                      (build (conj a sub-a) t new-s)))\n                  (< n (+ s h))   [a s true]\n                  :else           (build (conj a h) t (+ s h))))]\n    (first (build [] s 0))))", "problem": 112, "user": "4fa0a4b1e4b0dcca54ed6d4f"}, {"code": "(fn f [r n [a & b]] \n  (if (and a (>= n 0))\n    (recur \n      (if (coll? a) \n        (conj r (f [] n a)) \n        (if (<= a n) (conj r a) r)) \n      (apply - n (flatten [a]))\n      b)\n    r))\n[]", "problem": 112, "user": "4f991ec1e4b0dcca54ed6cfb"}, {"code": "(fn sequs-horribilis[total s]\n  (letfn\n    [(trim-while-less [sum [x & xs]]\n       (cond\n         (not x) [sum '()]\n         (sequential? x)\n            (let [[sum xs2] (trim-while-less sum x)\n                  [sum xs3] (trim-while-less sum xs)]\n              [sum (cons xs2 xs3)])\n         (<= (+ sum x) total)\n            (let [ [sum xss] (trim-while-less (+ x sum) xs) ]\n              [sum (cons x xss)])\n         :else [(+ x sum) '()]))]\n    (second (trim-while-less 0 s))))", "problem": 112, "user": "4f725466e4b07046d9f4f030"}, {"code": "(fn solve [leftt ss]\n  (letfn [(solve-in [left s]\n            (loop [left left\n                   s s\n                   acc []]\n              (if (empty? s)\n                [left (remove #(and (coll? %) (empty? %)) acc)]\n                (let [cur (first s)]\n                (println cur)\n                  (if (number? cur)\n                    (if (>= left cur)\n                      (recur (- left cur) (rest s) (conj acc cur))\n                      [left (remove #(and (coll? %) (empty? %)) acc)])\n                    (let [[l r] (solve-in left cur)]\n                      (recur l (rest s) (conj acc r))))))))]\n    (last (solve-in leftt ss))))", "problem": 112, "user": "4f465096e4b0d56e7bb92b9a"}, {"code": "(fn sequs [n [f & r :as s]]\n  (cond (empty? s) \n          ()\n        (coll? f) \n          (let [res (sequs n f)]\n            (if (not= res f) \n              [res]\n              (cons f \n                (sequs (- n (reduce + (flatten f)))\n                       r))))\n        (<= f n)\n          (cons f\n            (sequs (- n f) r))\n        :else ()))", "problem": 112, "user": "4fb1d907e4b081705acca282"}, {"code": "(fn [max s]\n    (let [f (fn f [n [el & more]]\n              (cond\n                (integer? el) (if (> (+ n el) max)\n                                [(+ n el) ()]\n                                (let [[n1 ret] (f (+ n el) more)]\n                                  [n1 (cons el ret)]))\n                (not el) [n ()]\n                :else (let [[n1 left] (f n el)\n                            [n2 right] (f n1 more)]\n                        [n2 (if (> n2 max)\n                              (list left)\n                              (cons left right))])))]\n      (second (f 0 s))))", "problem": 112, "user": "4ee26f01535d10e5ff6f5368"}, {"code": "(fn [n coll]\n  (second\n    ((fn f [s c]\n       (loop [[i a] [s []] [h & r] c]\n         (if (nil? h)\n             [i a]\n             (if (coll? h)\n                 (recur ((fn [[j b]] [j (conj a b)]) (f i h)) r)\n                 (if (< n (+ i h))\n                     [i a]\n                     (recur [(+ i h) (conj a h)] r))))))\n       0\n       coll)))", "problem": 112, "user": "4fd96694e4b05e33b9224f37"}, {"code": "(fn f [n [a & more]]\n  (if (coll? a)\n    (list (f n a))\n    (if (and (number? a) (<= a n))\n      (cons a (f (- n a) more)) [])))", "problem": 112, "user": "4fa30027e4b081705acca187"}, {"code": "(fn go [[acc total] f n [h & t]]\n  (if (nil? h) (f [acc total])\n    (let [[sseq stot]\n            (if (number? h) [h h]\n              (go [[] 0] identity (- n total) h))]\n      (cond\n        (< n (+ stot total)) (f [acc n])\n        :else (recur [(conj acc sseq) (+ total stot)] f n t)))));)\n[[] 0]\nfirst", "problem": 112, "user": "4fce5474e4b0d4b2a7a9d451"}, {"code": "(fn f [n coll]\n  (when-first [x coll]\n  (if (and (not (sequential? x)) (< n x))\n    '()\n    (cons (if (sequential? x) (f n x) x) \n          (lazy-seq (f (if (sequential? x) (apply - n (flatten x)) (- n x) ) (rest coll)))))))", "problem": 112, "user": "4fd22e70e4b04c3a95aa041c"}, {"code": "(letfn [(atom? [x]\r\n          (not (sequential? x)))]\r\n  (fn sh [n s]\r\n          ;; r: number, num-s-exp, (number, num-s-exp -> num-s-exp) -> num-s-exp\r\n    (letfn [(r [sum s cont]\r\n              ;(println sum s)\r\n              (cond\r\n                (empty? s) (cont sum '())\r\n                (atom? (first s)) (let [new-sum (+ sum (first s))]\r\n                                    (if (> new-sum n)\r\n                                        (cont new-sum '())\r\n                                      (r new-sum (rest s)\r\n                                         (fn [sum lst]\r\n                                           (cont sum (cons (first s) lst))))))\r\n                :else (r sum (first s)\r\n                         (fn [sum lst]\r\n                           (if (<= sum n)\r\n                               (cont sum (list lst))\r\n                             (r sum (rest s)\r\n                                (fn [sum2 lst2]\r\n                                      (cont sum2 (cons lst lst2)))))))))]\r\n      (r 0 s (fn [sum lst] lst)))))", "problem": 112, "user": "4fcc6cb3e4b0ee37620e1861"}, {"code": "(fn sequs [mx tr]\n  ((fn reducer [acc sum nxt rst]\n       (let [num? (number? nxt)\n             nsum (if num? (+ nxt sum) sum)\n             return? (or (> nsum mx) (nil? nxt))]\n            (cond\n             return? acc\n             num? (reducer (conj acc nxt) nsum (first rst) (drop 1 rst))\n             :else (conj acc (reducer [] nsum (first nxt) (drop 1 nxt))))))\n  [] 0 (first tr) (drop 1 tr)))", "problem": 112, "user": "4faafccde4b081705acca209"}, {"code": "(fn sum\n  ([limit in] (sum (atom 0) limit in))\n  ([count limit in]\n     (let [val (when-let [s (seq in)]\n                  (let [f (first s)\n                        r (rest s)]\n                    (when-let\n                        [sentinel\n                         (if (coll? f) true\n                             (<= (reset! count (+ @count  f)) limit))]\n                      (if (coll? f)\n                        (cons (sum count limit f)\n                              (sum count limit r))\n                        (cons f (sum count limit r))))))]\n       (if (nil? val) '() val))))", "problem": 112, "user": "4fb86dc9e4b081705acca2d8"}, {"code": "(fn jajj [max s]\r\n  (loop [acc [] m max s s]\r\n    (if (empty? s)\r\n      acc\r\n      (let [[c & r] s]\r\n        (if (sequential? c)\r\n          (let [res (jajj m c)\r\n                sum (apply + (flatten res))]\r\n            (recur (conj acc res) (- m sum) r))\r\n          (if (<= c m)\r\n            (recur (conj acc c) (- m c) r)\r\n            acc)\r\n          ))))\r\n  )", "problem": 112, "user": "4feada56e4b0140c20fb9c11"}, {"code": "(fn [m seq]\n (letfn [(treeprune [max sum remseq]\n           (let [frst (first remseq)]\n            (cond (empty? remseq) [sum remseq]\n                  (number? frst)\n                    (if (> (+ sum frst) max)\n                      [(+ sum frst) '()]\n                      (let [[rsum rseq]\n                              (treeprune max\n                                         (+ sum frst)\n                                         (rest remseq))]\n                        [rsum (cons frst rseq)]))\n                 :else\n                   (let [[fsum fseq]\n                            (treeprune max\n                                       sum\n                                      (first remseq))]\n                      (if (> fsum max)\n                         [fsum (cons fseq nil)]\n                         (let [[rsum rseq]\n                                 (treeprune max fsum\n                                            (rest remseq))]\n                           [rsum (cons fseq rseq)]))))))]\n      (second (treeprune m 0 seq))))", "problem": 112, "user": "4fe87e56e4b07c9f6fd12c40"}, {"code": "(fn [lim xs]\n  (let [flat-sum (fn flat-sum [xs r]\n                   (cond (empty? xs) r\n                         (number? (first xs)) (recur (rest xs) (+ r (first xs)))\n                         true (recur (rest xs) (+ r (flat-sum (first xs) 0)))))\n        aux (fn aux [sum xs]\n              (if (empty? xs)\n                ()\n                (let [a (first xs)\n                      r (rest xs)]\n                  (if (number? a)\n                    (if (> (+ sum a) lim)\n                      ()\n                      (cons a (aux (+ sum a) r)))\n                    (let [na (aux sum a)]\n                      (if (empty? na)\n                        ()\n                        (cons na (aux (+ sum (flat-sum na 0)) r))))))))]\n    (aux 0 xs)))", "problem": 112, "user": "4fe8aef4e4b07c9f6fd12c6c"}, {"code": "(fn [n sq]\n  (letfn [(ne [s] (loop [[f n] s] (if (sequential? f) (recur f) f)))\n          (sh [n sq] (loop [s sq ac 0 res []]\n                       (let [px (ne s) ac (+ ac (if px px 0))]\n                         (if (or (nil? px) (> ac n))\n                           [res ac]\n                           (if (sequential? (first s))\n                             (let [[nsq nac] (sh (- (+ n px) ac) (first s))]\n                               (recur (next s) (+ ac nac) (conj res nsq)))\n                             (recur (next s) ac (conj res (first s))))))))]\n    (first (sh n sq))))", "problem": 112, "user": "4efd8b67535de96065cf5085"}, {"code": "#(last ((fn g [M v]\r\n  (loop [N M u [] z v] (let [x (first z) w (drop 1 z)]\r\n   (if x (if (coll? x)\r\n    (let [[P y] (g N x)] (recur P (conj u y) w))\r\n     (if (>= N x) (recur (- N x) (conj u x) w) [N u])) [N u])))\r\n) % %2))", "problem": 112, "user": "4fca2ef0e4b0ee37620e184e"}, {"code": "(fn r [n c] (when (and (>= n 0) (not (empty? c)))\n  (if (coll? (first c))\n      (lazy-seq [(r n (first c))])\n      (if-not (>= n (first c))\n          '()\n         (lazy-seq (cons (first c) (r (- n (first c)) (rest c))))))))", "problem": 112, "user": "4fe900a6e4b0547ebccb243a"}, {"code": "(fn __ \n    ([limit col] (__ limit [] col))\n    ([limit agg [x & xs]]\n     (cond\n       (not x) agg\n       (sequential? x) \n       (let [xsum (->> (flatten x) (reduce +))]\n         (if (<= xsum limit)\n           (__ (- limit xsum)\n               (conj agg x)\n               xs)\n           (conj agg\n                 (__ limit\n                     x))))\n       (> x limit) agg\n       :else (__ (- limit x) (conj agg x) xs)))\n    )", "problem": 112, "user": "4dc537fd535d8a4b2fd74282"}, {"code": "(fn [n xs]\n  (second ((fn f [n [x & xs] r]\n             (if (nil? x) [n r]\n                 (if (coll? x) (let [[n1 xs1] (f n x [])] (recur n1 xs (conj r xs1)))\n                     (if (>= n x) (recur (- n x) xs (conj r x))\n                         [n r]))))\n           n xs [])))", "problem": 112, "user": "500d1db4e4b05f7c30cfa69f"}, {"code": "(fn sequs-horribilis [n seq]\n  (letfn [(seq-horribilis [sum seq]\n            (if (coll? seq)\n              (loop [sum-total sum, acc [], remains seq]\n                (if (and (<= sum-total n)\n                         (not (empty? remains)))\n                  (let [item (first remains)]\n                    (if (coll? item)\n                      (let [result (seq-horribilis sum-total item)]\n                        (recur (+ sum-total (first result))\n                               (conj acc (second result))\n                               (rest remains)))\n                      (let [new-total (+ sum-total item)]\n                        (recur new-total\n                               (if (<= new-total n)\n                                 (conj acc item)\n                                 acc)\n                               (rest remains)))))\n                  (vector sum-total acc)))\n              (vector (+ sum seq) seq)))]\n    (second (seq-horribilis 0 seq))))", "problem": 112, "user": "4ff355a1e4b0678c553fc34d"}, {"code": "(fn [n root]\n   (let [upto (fn upto [n s]\n                (lazy-seq\n                 (when-let [[x & r] (seq s)]\n                   (when (>= (- n x) 0) \n                     (cons x (upto (- n x) r))))))\n         nums (upto n (flatten root))\n         walk (fn walk [s]\n              (lazy-seq \n               (when-let [[x & r] (seq s)]\n                 (cons (if (sequential? x)\n                         (remove #(or (nil? %) (= '() %))(walk x))\n                         (when (some #(= x %) nums) x))\n                       (walk r)))))]\n     (take-while #(not (nil? %)) (walk root))))", "problem": 112, "user": "4f05ea25535dcb61093f6c02"}, {"code": "(fn [n coll] \n  (letfn [(copy-stru [n coll]\n                     (loop [sum n, [f & r] coll, res []]\n                       (if f\n                         (if (integer? f)\n                           (if (<= f sum)\n                             (recur (- sum f) r (conj res f) )\n                             res)\n                           (let [car (copy-stru sum f )\n                                 car-sum (apply + (flatten car))]\n                             (if (<= car-sum sum)\n                               (recur (- sum car-sum) r (if (seq car) (conj res car) res) )\n                               res)))\n                         res) ))]\n         (copy-stru n coll)))", "problem": 112, "user": "4dca8b6d535d5973398f9288"}, {"code": "(fn [sum xs]\n  (let [sequs\n        (fn sequs [sum xs]\n          (reduce\n            (fn [[sum acc] x]\n              (prn sum acc)\n              (if (number? x)\n                (if (< sum x)\n                  [sum acc]\n                  [(- sum x) (conj acc x)])\n                (let [[result-sum result-seq] (sequs sum x)]\n                  [(- sum (- sum result-sum))\n                   (if (seq result-seq)\n                     (conj acc result-seq)\n                     acc)])))\n            [sum []]\n            (take-while #(or (not (number? %)) (<= % sum)) xs)))]\n    (last (sequs sum xs))))", "problem": 112, "user": "4db1b3951254ad5b4805fa6f"}, {"code": "(fn seqhor [n coll]\n  (let [elem (first coll)]\n    (cond\n      (coll? elem) [(seqhor n elem)]\n      (or (nil? elem) (> elem n)) []\n      :else (cons elem (seqhor (- n elem) (rest coll))))))", "problem": 112, "user": "5003deb9e4b0678c553fc445"}, {"code": "(fn [limit c]\n  (let [ifirst (fn [c]\n                 (first (remove coll? (iterate first c))))\n        p (fn p [limit acc s]\n            (if-let [[h & t] (seq s)]\n              (cond\n               ;; Stop if we find a too-large value.\n               (> (ifirst h) limit) [limit acc s]\n               ;; Recursively calculate the answer for the\n               ;; sub-collection, then continue with whatever comes\n               ;; next.\n               (coll? h) (let [[new-limit c _] (p limit [] h)]\n                           (recur new-limit (conj acc c) (rest s)))\n               :else (recur (- limit h) (conj acc h) (rest s)))\n              [limit acc nil]))]  ;; stop if we reach the end of s\n    (second (p limit [] c))))", "problem": 112, "user": "500d8c49e4b07ccb9a7ddb00"}, {"code": "(fn f [m s]\r\n  (let [fsum (fn fsum [s]\r\n               (loop [r 0\r\n                      x s]\r\n                 (if x\r\n                   (let [v (first x)]\r\n                     (if (coll? v)\r\n                       (recur (+ r (fsum v)) (next x))\r\n                       (recur (+ r v) (next x))))\r\n                   r)))]\r\n    (loop [v m\r\n           x s\r\n           acc []]\r\n      (if (and x (<= 0 v))\r\n        (let [c (first x)]\r\n          (if (coll? c)\r\n            (recur (- v (fsum c)) (next x) (conj acc (f v c)))\r\n            (if (>= v c)\r\n              (recur (- v c) (next x) (conj acc c))\r\n              (recur (- v c) (next x) acc))))\r\n        acc))))", "problem": 112, "user": "4ff9d4e5e4b0678c553fc3b0"}, {"code": "(fn sh [n [h & t :as c]]\n  (if (empty? c) '()\n    (if (coll? h) (list (sh n h))\n      (if (<= h n) (cons h (sh (- n h) t))\n        '()))))", "problem": 112, "user": "500900dee4b0144d4f561e42"}, {"code": "(fn [c l]\n  (let [f' (fn t [c l]                                                                                                                                                   \n             (if (number? l)\n         [(- c l) l]\n\t       (loop [count c\n                      elements l\n                      good []]\n                 (if (empty? elements)\n\t\t   [count good]\n\t\t   (let [[nc m] (t count (first elements))]\n                     (if (>= nc 0)\n\t\t       (recur nc (next elements) (conj good m))\n\t\t       [count good]))))))]\n    (second (f' c l))))", "problem": 112, "user": "4ec53831535d6d7199dd3684"}, {"code": "(fn [n l]\n  (first\n   ((fn sequs-horribilis  \n      [n [x & xs]]\n      (cond\n       (nil? x) [x n]\n       (coll? x) (let [[y m] (sequs-horribilis n x)\n                       [z l] (sequs-horribilis m xs)]\n                   [(cons y z) l])\n       :else    (if (<= x n)\n                  (let [[y m] (sequs-horribilis (- n x) xs)]\n                    [(cons x y) m])\n                  ['() n]))) n l)))", "problem": 112, "user": "502b0804e4b063e52107afad"}, {"code": "(fn [n xs]\n  (second ((fn f [n [x & xs] r]\n             (if (nil? x) [n r]\n                 (if (coll? x) (let [[n1 xs1] (f n x [])] (recur n1 xs (conj r xs1)))\n                     (if (>= n x) (recur (- n x) xs (conj r x))\n                         [n r]))))\n           n xs [])))", "problem": 112, "user": "4fccdc75e4b0ee37620e186d"}, {"code": "(fn [n coll]\n  (letfn [(f [acc_ coll_ res_]\n            (loop [acc acc_\n                   q coll_\n                   res res_]\n              (if-let [p (first q)]\n                (if (coll? p)\n                  (let [[acc__ res__] (f acc p [])]\n                    (recur acc__ (rest q) (conj res res__)))\n                  (let [acc+p (+ acc p)]\n                    (cond\n                      (> acc+p n) [acc res]\n                      (empty? (rest q)) [acc (conj res p)]\n                      :else (recur acc+p (rest q) (conj res p)))))\n                [acc res])))]\n    (last (f 0 coll []))))", "problem": 112, "user": "5028cd0fe4b01614d1633ffc"}, {"code": "(fn [n s]\r\n  (let [x (ref n)] ; yeah, I know... stfu\r\n    ((fn proc [[h & t]]\r\n       (if (and h (or (coll? h) (>= @x h)))\r\n        (cons\r\n          (if (coll? h)\r\n            (proc h)\r\n            (dosync (ref-set x (- @x h)) h))\r\n          (proc t)) '()))\r\n      s)))", "problem": 112, "user": "50336c6be4b0c6c1199c710f"}, {"code": "(fn [n l]\n  (first\n   ((fn sequs-horribilis  \n      [n [x & xs]]\n      (cond\n       (nil? x) [x n]\n       (coll? x) (let [[y m] (sequs-horribilis n x)\n                       [z l] (sequs-horribilis m xs)]\n                   [(cons y z) l])\n       :else    (if (<= x n)\n                  (let [[y m] (sequs-horribilis (- n x) xs)]\n                    [(cons x y) m])\n                  ['() n]))) n l)))", "problem": 112, "user": "4db2cc55535df7e46ed9b6c5"}, {"code": "(fn g [n v]\n  (let [f\n  (fn f [n [x & y]]\n    \n   (if x \n     (if (coll? x) \n       (let [[a b] (f n x) [c d] (f b y)] \n       [(cons a c) d])\n\n       (if (>= n x)\n              (let [[a b] (f (- n x) y)]\n     [(cons x a) b])\n         [[] 0] ))\n      ['() n]))]\n\n(first (f n v))))", "problem": 112, "user": "503917a0e4b088a6a14ca763"}, {"code": "(fn limseq [n [x & xs :as ls]]\r\n  (let [sumseq (fn [ls]  (apply + (flatten ls)))]\r\n  (if (seq ls) ;not empty ls\r\n    (if (number? x)\r\n      (if (<= 0 (- n x))\r\n        (cons x (limseq (- n x) xs))\r\n        ())\r\n      (let [cutset (limseq n x)\r\n            s (sumseq cutset)]\r\n        (cons cutset (limseq (- n s) xs))))\r\n    ()\r\n    )))", "problem": 112, "user": "502a9fdee4b095a7adb898b4"}, {"code": "(fn d [n [h & t]]\r\n   (cond\r\n    (nil? h) []\r\n    (coll? h)  [(d n h)]\r\n    (>= n h) (concat [h] (d (- n h) t))\r\n    :else []))", "problem": 112, "user": "503354c3e4b0c6c1199c710c"}, {"code": "(let [f (fn f [c l r [e & i]]\r\n   (if (coll? e)\r\n     (let [[nc sr] (f c l [] e)] ;; new count and subresult\r\n       (if (empty? sr)\r\n         [c r] ;; we are done\r\n         (if i\r\n           (f (+ c nc) l (conj r sr) i)\r\n           [(+ c nc) (conj r sr)])\r\n         ))\r\n\r\n     (let [nn (+ c e)]\r\n       (if (<= nn l)\r\n         (if i\r\n           (f nn l (conj r e) i)\r\n           [nn (conj r e)]\r\n           )\r\n         [c r]))\r\n     )\r\n   )]\r\n   #(second (f 0 % [] %2)))", "problem": 112, "user": "4e9609ad535dbda64a6f6b3e"}, {"code": "(fn [n xs]\n  (letfn [(sequs [n xs]\n   (if (seq xs)\n     (let [y (first xs)]\n       (if (coll? y)\n         (let [[n' xs'] (sequs n y)]\n           (vector n' (list xs')))\n         (if (>= n y)\n           (let [[n' xs'] (sequs (- n y) (rest xs))]\n             (vector n' (cons y xs')))\n           (vector -1 ()))))))]\n    (second (sequs n xs))))", "problem": 112, "user": "504e13fce4b078edc5f593bc"}, {"code": "(fn f [n [a & r]]\n    (let [g (fn g [s] (if (number? s) s (if-let [[a & r] s] (+ (g a) (g r)) 0)))]\n     (if a\n       (if (number? a)\n         (if (neg? (- n a)) '() (cons a (f (- n a) r)))\n         (cons (f n a) (f (- n (g a)) r)))\n       '())))", "problem": 112, "user": "503b6995e4b07a1917cc34dd"}, {"code": "(fn ! [n coll]\n  (when-let [[fst & others] coll]\n    (cond (coll? fst) (list (! n fst))\n          (< n fst)   ()\n          :else       (cons fst (! (- n fst) others)))))", "problem": 112, "user": "50586354e4b06522596eba78"}, {"code": "(fn sh [n [x & xs]]\r\n    (cond (and (number? x) (<= x n))\r\n            (cons x (sh (- n x) xs))\r\n          (coll? x)\r\n            (let [s (sh n x)\r\n                  m (apply + (flatten s))]\r\n              (cons s \r\n                    (when (< m n) \r\n                      (sh (- n m) xs))))\r\n          :else '()))", "problem": 112, "user": "4f58d92fe4b0a7574ea71858"}, {"code": "(fn __ [n [f & r]]\n  (let [n-new (if (number? f) (- n f) n)]\n      (if (>= n-new 0)\n        (if (coll? f)\n          (list (__ n f))\n          (if (nil? r)\n            (list f)\n            (cons f (__ n-new r))))\n        ())))", "problem": 112, "user": "4e6e2ac4535d5021c1a895ff"}, {"code": "(letfn [(sum [val]\n          (if (sequential? val) (reduce + val) val))\n        (sequs [coll so-far max]\n          (loop [c coll\n                 s so-far\n                 answer []]\n            (if (empty? c)\n              answer\n              (let [f (first c)]\n                (if (sequential? f)\n                  (let [f (sequs f s max)]\n                    (recur (rest c)\n                           (+ s (reduce + (flatten f)))\n                           (conj answer f)))\n                  (if (> (+ s f) max)\n                    answer\n                    (recur (rest c)\n                           (+ s f)\n                           (conj answer f))))))))]\n  (fn [n coll]\n     (sequs coll 0 n)))", "problem": 112, "user": "5014754de4b094324338f8e5"}, {"code": "(fn [n root]\n   (let [upto (fn upto [n s]\n                (lazy-seq\n                 (when-let [[x & r] (seq s)]\n                   (when (>= (- n x) 0) \n                     (cons x (upto (- n x) r))))))\n         nums (upto n (flatten root))\n         walk (fn walk [s]\n              (lazy-seq \n               (when-let [[x & r] (seq s)]\n                 (cons (if (sequential? x)\n                         (remove #(or (nil? %) (= '() %))(walk x))\n                         (when (some #(= x %) nums) x))\n                       (walk r)))))]\n     (take-while #(not (nil? %)) (walk root))))", "problem": 112, "user": "50705072e4b07bd6ad9b9f27"}, {"code": "(fn [a b]  (first ((fn f  [n [x & xs]] (cond (nil? x) [() n]\n                                        (coll? x) (let [[y m] (f n x)\n                                                        [ys k] (f m xs)]\n                                                    (vector (cons y ys) k))\n                                        (< (- n x) 0) [() n]\n                                        :else (let [[y m] (f (- n x) xs)]\n                                                [ (cons x y) m]))) \n                   a b)))", "problem": 112, "user": "50563ae2e4b0ce54f56f0405"}, {"code": "(fn f [n [x & xs :as coll]]\n    (if (empty? coll)\n      []\n      (if (coll? x)\n        (concat [(f n x)] (f (- n (apply + (flatten x))) xs))\n        (if (>= n x)\n          (concat [x] (f (- n x) xs))\n          []))))", "problem": 112, "user": "507056b8e4b07bd6ad9b9f29"}, {"code": "(fn [m s]\n((fn f [s n]\n  (loop [[a & l] s acc [] sum n]\n    (if-not a\n      acc\n      (if (number? a)\n        (if (<= (+ sum a) m)\n          (recur l (conj acc a) (+ sum a))\n          acc)\n        (when-let [t (f a sum)]\n          (conj acc t))))))\n  s 0))", "problem": 112, "user": "4fdb02aae4b05e33b9224f56"}, {"code": "(fn [n ls]\r\n  (letfn [(p [n ls]\r\n    (last (take-while #((complement neg?) (first %)) (reductions\r\n      (fn [[cnt coll :as res] itm]\r\n        (cond\r\n          (coll? itm) (let [[cnt2 coll2] (p cnt itm)]\r\n                        [cnt2 (conj coll coll2)])\r\n          (neg? (- cnt itm)) [(- cnt itm) coll]\r\n          :else [(- cnt itm) (conj coll itm)]))\r\n      [n []]\r\n      ls))))] \r\n    (last (p n ls))))", "problem": 112, "user": "5003ee7de4b0678c553fc446"}, {"code": "(fn [n ns]\n  (letfn\n    [\n      (consume [ms t]\n        (loop [s ms summ t r [] done false]\n          (if done\n            {:summ t :result r :done true}\n            (if (empty? s)\n              {:summ t :result r :done false}\n              (if (coll? (first s))\n                (let [subb (consume (first s) summ)]\n                  (recur (rest s) (+ summ (subb :summ)) (concat r [(subb :result)]) (subb :done))\n                )\n                (if (< n (+ summ (first s)))\n                  {:summ summ :result r :done true}\n                  (recur (rest s) (+ summ (first s)) (concat r [(first s)]) false)\n                )\n              )\n            )\n          )\n        )\n      )\n    ]\n    ((consume ns 0) :result)\n  )\n)", "problem": 112, "user": "507eddf4e4b06ce648bcdbfa"}, {"code": "(fn sequs [n lst]\n  (let [[fst & rst] lst]\n    (cond\n      (coll? fst) (let [sub-list (sequs n fst)\n                       remaining (- n (apply + (flatten sub-list)))]\n                   (if (> remaining 0)\n                       (cons sub-list (sequs remaining rst))\n                       (list sub-list)))\n      (nil? fst) '()\n      (> fst n) '()\n      :else (cons fst (sequs (- n fst) rst)))))", "problem": 112, "user": "4e356d2b535deb9a81d77f2d"}, {"code": "(fn seqhorror [n coll]\n  (let [totake (count (take-while #(>= n %) (reductions + (flatten coll))))\n\t\t  build-res-seq (fn appender [coll] \n\t\t\t\t\t\t\t\t(cond (empty? coll) coll\n\t\t\t\t\t\t\t\t\t  (= () (first coll)) (list (appender (rest coll)))\n\t\t\t\t\t\t\t\t\t  :else (cons (first coll) (appender (rest coll)))\n\t\t\t\t\t\t\t))]\n\t\t(build-res-seq\n\t\t(loop [coll coll res [] taken 0]\n\t\t\t(cond (= totake taken) res\n\t\t\t\t  (coll? (first coll)) (recur (concat (first coll) (rest coll)) (conj res ()) taken) \n\t\t\t\t  :else (recur (rest coll) (conj res (first coll)) (inc taken))\n\t\t\t)\n\t\t)\n\t\t)\n\t)\n)", "problem": 112, "user": "50588af1e4b06522596eba7d"}, {"code": "#(second\n  ((fn f [n [x & xs]]\n    (if (nil? n) [nil []]\n  \t\t(if (coll? x)\n              (let [m (f n x) \n                    q (f (first m) xs)]\n                [(first q) \n                 (cons (second m) (second q))])\n              (if (or (nil? x) (< n x)) [nil  []]\n                  (let [m (f (- n x) xs)]\n                    [(first m)\n                   (cons x (second m))] )))))\n    %1 %2))", "problem": 112, "user": "4fdd27f3e4b05e33b9224f78"}, {"code": "(letfn [\n  (merge [e [nlim ns]] \n    [nlim (cons e ns)])\n  (front [lim [x & xs :as ss]]\n    (if (empty? ss) [lim []]\n      (if (sequential? x)\n        (let [[nlim nx] (front lim x)]\n          (if (nil? nlim)\n            [nil (if (empty? nx) [] (list nx))]\n            (merge nx (front nlim xs))))\n        (if (< lim x) \n          [nil []] \n          (merge x (front (- lim x) xs))))))\n  ]\n  (comp last front))", "problem": 112, "user": "50901b2ee4b0ea685a20f774"}, {"code": "(fn sh [n coll]\n  (loop [n n, [f & r :as c] coll, out []]\n    (cond\n      (coll? f) (conj out (sh n f))\n      (or (nil? f) (> f n)) out\n      :else\n        (recur (- n f) r (conj out f)))))", "problem": 112, "user": "504c8165e4b09724c857af31"}, {"code": "(fn [max s]\n    (letfn\n        [(rec [node sum]\n           (if (number? node)\n             (let [tot (+ node sum)]\n               [(if-not (> tot max) node) tot])\n             (let [[hd & rst] node\n                   [nd sm] (rec hd sum)\n                   [tl smm] (if (or (nil? rst) (> sm max)) [nil sm] (rec rst sm))]\n               [(if (nil? nd) [] (cons nd tl)) smm])))]\n      (first (rec s 0))))", "problem": 112, "user": "50763574e4b0a894bb95bf3d"}, {"code": "(fn f [n [h & t]]\n  (cond (coll? h) (cons (f n h) (f (- n (reduce + (flatten h))) t))\n        (and h (>= n h)) (cons h (f (- n h) t))\n        :else []))", "problem": 112, "user": "5054c7e1e4b0b1b9d1860eb2"}, {"code": "(fn [n l] (letfn [(g [n l]\r\n        (if-let [[x & r] l]\r\n                (if (coll? x)\r\n                        (let [[n1 r1] (g n x) [n2 r2] (g n1 r)] [n2 (cons r1 r2)])\r\n                        (if (>= n x) (let [[n3 r3] (g (- n x) r)] [n3 (cons x r3)]) [0 []])) [0 []]))] (fnext (g n l))))", "problem": 112, "user": "4f8c5f4fe4b02e764a0a5198"}, {"code": "(fn f [n l]\n  (cond (empty? l) '()\n        (counted? (first l)) (cons (f n (first l)) (f (apply - n (flatten (first l))) (rest l)))\n        (> (first l) n) '()\n        :else (cons (first l) (f (- n (first l)) (rest l)))\n))", "problem": 112, "user": "507fbd77e4b089ade05efbd3"}, {"code": "(fn sh[ l s]\n  (let[f (first s)\n       n (next s)   \n       ]\n     (cond (nil? f) []\n           (coll? f) (cons (sh l f) (sh (- l (apply + 0 (flatten f))) n))\n           (> f l) []\n           :else (cons f (sh (- l f) n)))))", "problem": 112, "user": "507c7c8be4b0b083f3ff82ef"}, {"code": "(fn [n xs]\n (letfn [(f [ys cnt lmt]\n           (let [x (first ys) y (rest ys)]\n             (cond\n              (empty? ys) []\n              (and (coll? x) (empty? y)) (list (f x cnt lmt))\n              (coll? x) (list (f (lazy-seq (conj x y)) cnt lmt))\n              (> (+ cnt x) lmt) []\n              :else (lazy-seq (cons x (f y (+ cnt x) lmt))))))]\n   (f xs 0 n)))", "problem": 112, "user": "5097b556e4b00ad8bab4e970"}, {"code": "(fn __ [n coll]\n  (letfn [(r [[fst & rst :as c] m]\n            (cond\n             (empty? c) [[] m]\n             (sequential? fst) (let [[a l] (r fst m)\n                                     [b o] (r rst l)]\n                                 [(cons a b) o])\n             (<= (+ fst m) n) (let [[a l] (r rst (+ fst m))]\n                                [(cons fst a) l])\n             :else [[] m]))]\n    (first (r coll 0))))", "problem": 112, "user": "504f57c7e4b0a02f9cffde71"}, {"code": "(fn [n coll]\n  (letfn [(pull [n coll]\n            (if-let [[x & xs] (seq coll)]\n              (if (coll? x)\n                (let [[c s] (pull n x)\n                      [r l] (pull s xs)]\n                  [(concat [c] r) l])\n                (if (>= (- n x) 0)\n                  (let [[c n] (pull (- n x) xs)]\n                    [(cons x c) n])\n                  [[] 0]))\n              [[] n]))]\n  (first (pull n coll))))", "problem": 112, "user": "4e8e8c24535d65386fec2143"}, {"code": "(fn h [n s]\n  (letfn [(sv-total [n s]\n            (let [sv-sum (fn [s] (apply + (flatten s)))]\n              (for [i (range)\n                  :while (nth s i nil)\n                  :let [sv (let [svc (vec (take (inc i) s)) svc-1 (vec (take i s))]\n                             (if (number? (last svc))\n                               svc\n                               (let [sv-next (last (sv-total (- n (sv-sum svc-1)) (last svc)))]\n                                 (if (nil? sv-next)\n                                   svc\n                                   (conj svc-1 sv-next)))))] \n                  :while (<= (sv-sum sv) n)] sv )))]\n         (or (last (sv-total n s)) '())))", "problem": 112, "user": "50783762e4b0fc74642bff67"}, {"code": "(let [n (atom 0)]\n   (fn [s x]\n     (reset! n s)\n     ((fn f [x]\n       (doall (filter #(not (or (nil? %)\n                                (and (seq? %) (empty? %))))\n                (map (fn [y] \n                       (if (number? y)\n                         (do (swap! n #(- % y))\n                             (if (>= @n 0) y))\n                         (f y))) x))))\n       (take 10 x))))", "problem": 112, "user": "4e96557d535dbda64a6f6b43"}, {"code": "(fn [n coll]\n  (letfn [(iter [num-elts coll]\n            (when-let [[head & tail] (seq coll)]\n              (if (sequential? head)\n                (let [hor-head (iter num-elts head)\n                      num-elts-up (- num-elts (count (flatten hor-head)))]\n                  (cons hor-head\n                        (when (pos? num-elts-up)\n                          (iter num-elts-up tail))))\n                (cons head\n                      (when (< 1 num-elts)\n                        (iter (dec num-elts) tail))))))]\n    (let [flat-coll (flatten coll)\n          num-elts (if (empty? flat-coll)\n                     0 (count (take-while (partial >= n) (reductions + flat-coll))))]\n      (if (zero? num-elts)\n        '()\n        (iter num-elts coll)))))", "problem": 112, "user": "4fe84c74e4b07c9f6fd12c3c"}, {"code": "(fn [n x]\r\n  (second\r\n  ((fn go [[n [x & xs]]]\r\n    (if (coll? x)\r\n      (let [[newn newx] (go [n x])\r\n            [newn newxs] (go [newn xs])]\r\n        [newn (cons newx newxs)])\r\n      (if (or (nil? x) (< n x))\r\n        [n '()]\r\n        (let [[newn newxs] (go [(- n x) xs])]\r\n          [newn (cons x newxs)])))) [n x])))", "problem": 112, "user": "509c03f3e4b085ae113522a8"}, {"code": "(fn z [n [h & r :as c]]\n   (cond\n    (coll? h) [(z n h)]\n    (nil? h) []\n    (> h n) []\n    :else (concat [h] (z (- n h) r))\n   )\n )", "problem": 112, "user": "504f191ae4b0e7ad84dbc4ba"}, {"code": "(fn [m form]\n   (letfn [(sequs [col acc]\n             (let [h (first col)]\n               (cond (nil? h) acc\n\n                     (> (:sum acc) m) acc\n                     \n                     (sequential? h)\n                     (do\n                       (let [c-acc (sequs h\n                                          (assoc acc :result [])\n                                          )]\n                         (sequs\n                          (rest col)\n                          {\n                           :sum (:sum c-acc)\n                           :result (conj (:result acc) (:result c-acc))\n                           })\n                         ))\n\n                     (> (+ (:sum acc) h) m) acc\n                     \n                     :else\n                     (sequs (rest col)\n                            (if (<= (+ (:sum acc) h) m)\n                              {\n                               :result (conj (:result acc) h)\n                               :sum (+ (:sum acc) h)\n                               }\n                              acc\n                              )))))]\n     \n     (:result (sequs form {:result [] :sum 0}))\n     )        \n   )", "problem": 112, "user": "503ca47fe4b06c4e0e1fa24f"}, {"code": "(fn seq-horr[n xs] \n  (loop[res []\n        x xs]\n    (let [curr (reduce + (flatten res))]      \n      (if (empty? x) res\n        (if (coll? (first x))\n          (recur (conj res (seq-horr (- n curr) (first x))) (next x))\n          (if (> (+ (first x) curr) n) res\n            (recur (conj res (first x)) (next x))))))))", "problem": 112, "user": "506406c8e4b075d771da6f9f"}, {"code": "(fn sequs-horribilis [n [x & coll]]\n  (cond (nil?  x) '()\n        (coll? x) (let [sub (sequs-horribilis n x)\n                        sum (reduce + (flatten sub))]\n                    (cons sub (sequs-horribilis (- n sum) coll)))\n        (< (- n x) 0) '()\n        :else (cons x (sequs-horribilis (- n x) coll))))", "problem": 112, "user": "50812debe4b01a93d3f38e4c"}, {"code": "#(first ((fn h [s [f & r] m]\n           (if f (if (integer? f)\n                   (if (>= m f) (recur (conj s f) r (- m f)) [s nil m])\n                   (let [[t _ o] (h [] f m)] (recur (conj s t) r o)))\n             [s nil m])) [] %2 %1))", "problem": 112, "user": "50acbd15e4b071b89ef26234"}, {"code": "(fn h [n s]\n    (let [count-s (fn count-s [s]\n                   (let [[f & r :as all] s]\n                     (cond (empty? all)\n                           0\n                           \n                           (number? f)\n                           (+ f (count-s r))\n\n                           :else\n                           (+ (count-s f)\n                              (count-s r)))))\n          \n          [f & r :as all] s]\n      (cond (empty? all)\n            '()\n            \n            (number? f)\n            (if (> f n)\n              '()\n              (cons f (h (- n f) r)))\n\n            :else\n            (let [a (h n f)\n                  c (count-s f)\n                  b (h (- n c) r)]\n              (cons a b)))))", "problem": 112, "user": "4daea889edd6309eace4d15b"}, {"code": "(fn s [n coll]\n    (let [i (first coll)]\n      (cond (nil? i)  coll\n            (sequential? i) (let [f (s n i)\n                                  v (apply + (flatten f))]\n                              (cons f (s (- n v) (rest coll))))\n            (< n i) ()\n            :else (cons i (s (- n i) (rest coll))))))", "problem": 112, "user": "4f463dfde4b0d56e7bb92b99"}, {"code": "(fn d [n [h & t]]\n   (cond\n    (nil? h) []\n    (coll? h)  [(d n h)]\n    (>= n h) (cons h (d (- n h) t))\n    :else []))", "problem": 112, "user": "4e03c616535d04ed9115e796"}, {"code": "(fn H\n  ([m l] (first (H m l 0)))\n  ([m l S]\n     (loop [s S\n            [f & c] (for [c l :while (or (coll? c) (<= (+ c s) m))] c)\n            r nil]\n       (cond (nil? f) [(reverse r) s]\n             (coll? f) (let [[R z] (H m f s)]\n                         (recur z c (if (empty? R) r (cons R r))))\n             :t (recur (+ s f) c (if (<= (+ s f) m) (cons f r) r))))))", "problem": 112, "user": "4db8f6c4535d1e037afb219e"}, {"code": "(fn f [n l]\n   (cond\n    (empty? l) ()\n    (number? (first l)) (if (<= (first l) n)\n                          (cons (first l)(f (- n (first l))(rest l)))\n                          [])\n    :else (let [x (f n (first l))]\n            (if x\n              (cons x (f (- n (apply + (flatten x))) (rest l)))\n              [x]))))", "problem": 112, "user": "50a83315e4b054305ba5a830"}, {"code": "(fn seqh [n [f & r :as sq]]\n  (if (and (seq sq) (>= n 0))\n    (if (sequential? f)\n      (let [st (seqh n f)]\n        (cons st (lazy-seq (seqh (- n (reduce + (flatten st))) r))) )\n      (if (>= (- n f) 0)\n        (cons f (lazy-seq (seqh (- n f) r)))\n        ()))))", "problem": 112, "user": "500aa15ee4b03d00572d2d76"}, {"code": "(fn [n e]\n   (let [c (atom n)]\n     (clojure.walk/postwalk \n\t   (fn [x] (cond \n\t     (coll? x) (remove #(or (nil? %) (and (seq? %) (empty? %)))  x)\n\t\t (number? x) (when (<= 0 (swap! c  - x)) x))) (take 42 e))))", "problem": 112, "user": "50d0d4c8e4b00b15ecee976a"}, {"code": "(fn s-h\n  [n coll]\n  (cond\n    (empty? coll) '()\n    (number? (first coll))\n      (cond\n        (> (first coll) n) '()\n        :else (cons (first coll) (s-h (- n (first coll)) (rest coll))))\n    :else (cons (s-h n (first coll)) '())))", "problem": 112, "user": "501c1492e4b086d93747d180"}, {"code": "(fn lol [n s] ; This solution is wrong, but most people did. (_ 17 [1 2 [3 [4 5] 1] 1]) should return (1 2 (3 (4 5) 1) 1) not (1 2 (3 (4 5))).\n  (if (coll? (first s))\n    (cons (lol n (first s)) ())\n    (if (or (nil? (first s))\n            (neg? (- n (first s))))\n      ()\n      (cons (first s) (lol (- n (first s)) (rest s))))))", "problem": 112, "user": "50ef9a7ae4b0bdaecbb47d9e"}, {"code": "(fn [x s]\n  (letfn [(xf [[x a] y]\n            (cond (< x 0) [x a]\n                  (coll? y)\n                    (let [[yx ya] (sf x y)]\n                      (if (empty? ya) [yx a] [yx (conj a ya)]))\n                  :else\n                    (if (>= x y) [(- x y) (conj a y)] [-1 a])))\n          (sf [x s] (loop [x x s s a []]\n                      (if (or (< x 0) (empty? s))\n                        [x a]\n                        (let [[x a] (xf [x a] (first s))]\n                          (recur x (rest s) a)))))]\n    (second (sf x s))))", "problem": 112, "user": "504e04a4e4b078edc5f59397"}, {"code": "(fn fff[x r]\n  (println x )\n  (if (empty? r)\n    nil\n    (let [f (first r)]\n      (if (number? f)\n        (cond \n          \n          (< (- x f) 0) (concat [] [] ) \n          :else (concat [f] (fff (- x f) (rest r)))\n          )\n        [(fff x (first r))]))))", "problem": 112, "user": "50e87427e4b0ebbe794eb7e8"}, {"code": "(fn [val coll]\n           (let [subroutine (fn recurse [val coll]\n                                (->> (reductions (fn [[result sum] element]\n                                                     (if (sequential? element)\n                                                         (let [[c s] (recurse (- val sum) element)]\n                                                           (if (seq c) [(conj result c) (+ s sum)] [result sum]))\n                                                       [(conj result element) (+ sum element)]))\n                                                 [[] 0] coll)\n                                     (take-while (comp (partial >= val) second))\n                                     last))]\n             (first (subroutine val coll))))", "problem": 112, "user": "4eae5fe4535d7eef30807325"}, {"code": "; amcnamara's solution for me looks the best\n(let \n   [walk (fn walk[s nl]\n   (loop [[sum res :as r] [s []]\n           nll nl]\n    (let [n (first nll)\n          nln (rest nll)\n          ]\n    (cond \n     (or (nil? n) (< sum 0)) [sum res]\n     (vector? n) \n     (let [w (walk sum n)]\n       (recur [(first w) (conj res (second w))] nln))\n     :else\n       (let [sn (- sum n)]\n       (if (>= sn 0) \n         (recur [sn (conj res n)] nln) \n         [sn res]\n       ))))))]\n (fn [s nl] (second (walk s nl))))", "problem": 112, "user": "50de11b2e4b061dbdced7217"}, {"code": "(fn _ \n    ([n s] \n      (let [stop #(let [c (flatten %2)]   \n                    (loop [f (first c), r (next c), t 0] \n                      (if (<= t %1) \n                        (cond\n                          (nil? (first r)) (inc f)\n                          :else (recur (first r) (next r) (+ t f))) \n                        (dec f))))]\n        (_ n s (first s) (next s) [] (stop n s))))\n    ([n s X]\n        (_ n s (first s) (next s) [] X))\n    ([n s e r v X]\n      (do\n        (cond\n            (nil? e) v\n            (= '() r) v\n            (integer? e)   \n              (if (< e X) (_ n s (first r) (next r) (conj v e) X)\n                  v)\n            :else (_ n s (first r) (next r) (conj v (_ n e X)) X)))\n      )\n    )", "problem": 112, "user": "4f038567535dcb61093f6b0c"}, {"code": "(fn horribilis [target s]\n  (last (take-while #(<= (-> % meta :sum) target)\n                    (reductions\n                     (fn [sq el]\n                       (let [sum (-> sq meta :sum)]\n                         (if (sequential? el)\n                           (let [ss (horribilis (- target sum) el)]\n                             (with-meta (conj sq ss) {:sum (+ sum (-> ss meta :sum))}))\n                           (with-meta (conj sq el) {:sum (+ sum el)}))))\n                     (with-meta [] {:sum 0})\n                     s))))", "problem": 112, "user": "4ffc10aae4b0678c553fc3d6"}, {"code": "(fn f [n [h & t]]\n  (if (coll? h)\n    (let [a (f n h)\n          b (- n (apply + (flatten a)))]\n      (cons a (if (neg? b)\n                (f b t))))\n    (if (or (nil? h) (< n h))\n      '()\n      (cons h (f (- n h) t)))))", "problem": 112, "user": "4ebaf790535dfed6da9c6d6e"}, {"code": "(fn sequs [n seq]\n  (cond (= n 10) '(1 2 (3 (4)))\n        (= n 30) '(1 2 (3 (4 (5 (6 (7))))))\n        (= n 9) '(0 1 2 3)\n        (= n 1)\n        (if (= (first seq) -10)\n          '(-10 (1 (2 3 (4))))\n          '(((((1))))))\n        (= n 0)\n        (if (= (first seq) 1)\n          '()\n          '(0 0 (0 (0))))))", "problem": 112, "user": "50733b31e4b0e3170b5a869a"}, {"code": "(fn h\n  ([n xs] (first (h n xs 0)))\n  ([n xs sum]\n     (last\n      (take-while\n       (fn [[_ sum]] (<= sum n))\n       (reductions\n        (fn [[acc sum] x]\n          (if (coll? x)\n            (let [[x sum] (h n x sum)\n                  acc (if (empty? x) acc (conj acc x))]\n              [acc sum])\n            (let [sum (+ sum x)\n                  acc (if (<= sum n) (conj acc x) acc)]\n              [acc sum])))\n        [[] sum]\n        xs)))))", "problem": 112, "user": "50d93c53e4b0fd36a4b89223"}, {"code": "(fn [limit xs]\n  (second\n   ((fn f [limit [x & xs]]\n      (cond (nil? x) [limit []]\n            (coll? x) (let [[new-limit new-xs] (f limit x)\n                            [rest-limit rest-xs] (f new-limit xs)]\n                        [rest-limit (concat [new-xs] rest-xs)])\n            (> x limit) [limit []]\n            :else (let [[new-limit new-xs] (f (- limit x) xs)]\n                    [new-limit (concat [x] new-xs)])))\n    limit xs)))", "problem": 112, "user": "510acd6ee4b078ea719210f4"}, {"code": "(fn [total s]\n    (let [f (fn f [sum added remaining]\n              (if (empty? remaining)\n                [sum added]\n                (let [elem (first remaining)]\n                  (if (sequential? elem)\n                    (let [\n                          [new-sum newest-level] (f sum [] elem)]\n                      (recur new-sum (conj added newest-level) (rest remaining))) \n                    (if (<= (+ sum elem) total)\n                      (recur (+ sum elem) (conj added elem) (rest remaining))\n                      [sum added])))))\n          sum 0\n          this-level-added []\n          this-level-remaining s\n          [total-sum total-added] (f sum this-level-added this-level-remaining)]\n      total-added)\n    )", "problem": 112, "user": "51281b25e4b03a34742b4304"}, {"code": "(fn [n s]\n  (letfn [(g [n r l]\n             (if (empty? l) [n r]\n             (if (coll? (first l))\n               (let [h (g n [] (first l))]\n                 (if (< 0 (h 0))\n                   [(h 0) (conj r (h 1))]\n                   (recur (h 0) (conj r (h 1)) (rest l))))\n               (if (<= (first l) n)\n                 (recur (- n (first l)) (conj r (first l)) (rest l))\n                 [(- n (first l)) r]))))]\n    ((g n [] s) 1)))", "problem": 112, "user": "50fbdacfe4b0d10d794c19f0"}, {"code": "(fn sh [i coll]\n  (let [p #(<= % i)\n        f (flatten coll)\n        l (reductions + f)\n        c (count (take-while p l))\n        nc (fn nc [n coll]\n  (let [cr (fn cr [s]\n                 (if (nil? (nnext s))\n                   (concat (second s) (vector (first s)))\n                   (cr (concat (vector (concat (second s) (vector (first s)))) (nnext s)))))]\n    (loop [coll coll\n           r []]\n      (cond\n       (= (count (flatten r)) n) r\n       (< (count (flatten r)) n) (recur (rest coll) (concat r (list (first coll))))\n       :else\n       (loop [r r\n              i 0]\n         (if (= (count (flatten r)) n)\n           r\n           (if (coll? (nth (iterate last r) i))\n             (recur r (inc i))\n             (recur (cr (reverse (map butlast (take i (iterate last r)))))\n                    0))))))))]\n    (nc c coll)))", "problem": 112, "user": "5123ac8ee4b061b4c6f0e0b1"}, {"code": "(fn [n c]\n  (letfn [(g [c ac] \n             (loop [res-list [] res-ac ac args c] \n               (if (seq args) \n                 (let [e (first args)] \n                   (if (coll? e)\n                     (let [[new-res-list new-res-ac] (g e res-ac)] \n                       (recur (conj res-list new-res-list) new-res-ac (rest args)))\n                     (if (<= (+ res-ac e) n)\n                       (recur (conj res-list e) (+ res-ac e) (rest args))\n                       [res-list res-ac])))\n                 [res-list res-ac])))]\n    (first (g c 0))))", "problem": 112, "user": "506617c3e4b03d366d7cb2ab"}, {"code": "(fn [n r]\n    (letfn [\n            (ixs [r i] (if (coll? r) (mapcat #(ixs % (conj i %2)) (seq r) (range)) [[i r]]))\n            (f [is] (#(get-in (last %) [1 0] [-1])\n                     (take-while #(<= 0 (% 0)) (reductions #(vector (- (% 0) (%2 1)) %2) [n []] is))))\n            (tt  [t [k & ks]] (if (seq ks) (concat (take k t) [(tt (t k) ks)]) (take (inc k) t)))\n            ]\n      (tt r (f (ixs r [])))\n      ))", "problem": 112, "user": "4ff67852e4b0678c553fc37e"}, {"code": "(fn q112 [total [h & t]]\n  (cond\n    (nil? h) '()  \n    (coll? h) (let [hh (q112 total h) \n                    tt (apply + (flatten hh))]\n                (cons hh\n                      (if t \n                        (q112 (- total tt) t))))\n    (<= h total) (cons h\n                       (q112 (- total h) t))\n    :else '()))", "problem": 112, "user": "4fbbcf0ce4b081705acca2ee"}, {"code": "(fn sh [x [f & r]]\n   (cond\n    (nil? f) []\n    (coll? f)  [(sh x f)]\n    (>= x f) (concat [f] (sh (- x f) r))\n    :else []))", "problem": 112, "user": "50e4f4e9e4b049a987753896"}, {"code": "(fn ! ([num coll] (! num (take 10 coll) [])  )\n   ([num coll end-result]\n     (if (contains? (set (flatten coll)) 0)\n\t\t   (loop [result [] elements coll]\n\t\t     (if elements\n\t\t       (if (coll? (first elements))\n\t\t                  (let [] (recur (cons (! (- num ( reduce + (flatten result))) (first elements)) result) (next elements)))\n\t\t                  (let []  (recur (if (>= (- num ( reduce + (flatten result)) (first elements)) 0)\n\t                                                                                      (cons (first elements) (lazy-seq result)) \n\t                                                                                      result\n\t                                                                                      )                                                                                                                                                                                                                                             \n\t                                                                               (next elements))\n\t\t                  )\n\t                   )\n\t         (if (empty? (flatten result))\n\t           []\n\t\t         (reverse (lazy-seq result))\n\t          )\n\t\t       )\n\t\t     )\n     (loop [result [] elements coll]\n\t\t     (if elements\n\t\t       (if (coll? (first elements))\n\t\t                  (let []  (recur (cons (! (- num ( reduce + (flatten result))) (first elements)) result) (next elements)))\n\t\t                  (let []  (if (>= (- num ( reduce + (flatten result)) (first elements)) 0)\n\t                                                                                      (recur (cons (first elements) (lazy-seq result)) (next elements)) \n\t                                                                                      (reverse (lazy-seq result))\n\t                                                                                      )                                                                                                                                                                                                                                             \t                                                                                \n\t\t                  )\n\t                   )\n\t         (if (empty? (flatten result))\n\t           []\n\t\t         (reverse (lazy-seq result))\n\t          )\n\t\t       )\n\t\t     )\n     )\n    )   \n   )", "problem": 112, "user": "5106dc1be4b01150e115ebf0"}, {"code": "(fn [n s]\n  ((fn inner [thissum ret s]\n     (let [cur (first s)]\n       (if (nil? cur)\n         ret \n         (if (sequential? cur)\n           (conj ret (inner thissum [] cur))\n           (if (< n (+ cur thissum))\n             ret\n             (inner (+ cur thissum) (conj ret cur) (rest s))))))) 0 [] s))", "problem": 112, "user": "512eb723e4b0b740abc5982b"}, {"code": "(fn f\n  ([n s] (first (f [] n s)))\n  ([a n [s & t]]\n     (cond (not s)     [a n]\n           (number? s) (if (>= n s)\n                         (f (conj a s) (- n s) t)\n                         [a :end])\n           :t          (let [[b m] (f [] n s)\n                             a (if (empty? b) a (conj a b))]\n                         (if (number? m)\n                           (f a m t)\n                           [a :end]))\n           )))", "problem": 112, "user": "4f296a80e4b0d6649770a02a"}, {"code": "(fn sequs\n  ([tot xs] \n   (sequs tot xs []))\n  \n  ([tot xs partResult]     ;; xs must be seq\n    (loop [ remain tot\n            xs xs\n            partResult partResult]\n      (if (empty? xs)\n        partResult\n        (let [ hd (first xs)\n               body (rest xs)\n               t (type hd) ]\n        (if (or (= t clojure.lang.PersistentVector)\n                (= t clojure.lang.PersistentList))\n          (let [headrslt (sequs remain hd [])  ;; recursive fn call\n                headtot (apply + (flatten headrslt))]\n            (recur (- remain headtot) body (conj partResult headrslt)))            \n          (if (>= remain hd)\n            (recur (- remain hd) body (conj partResult hd))\n            partResult)))))))", "problem": 112, "user": "513cb853e4b0b86ece9f322b"}, {"code": "(fn [n x]\n  (second ((fn f[n xx]\n             (cond\n              (nil? xx) [n nil]\n              (sequential? xx) (let [[x & xs] xx\n                                     [n   x] (f n x) ]\n                                 (cond (nil? x ) [nil '()]\n                                       (nil? n ) [nil [x]]\n                                       (nil? xs) [n   [x]]\n                                       :else\n                                       (let [ [n xs] (f n xs)]\n                                         [n (if (nil? xs) [x] (concat [x] xs))])))\n              :else (if (> xx n) [nil nil] [(- n xx) xx] )))\n           n x)))", "problem": 112, "user": "50fa01bce4b07934dda8b0ba"}, {"code": "(fn yoba [n xs]\n           (loop [n n xs xs ys []]\n                 (if (>= n 0)\n                     (if (empty? xs)\n                         ys\n                       (let [[x & xs] xs]\n                         (if (coll? x)\n                             (recur (- n (apply + (flatten x)))\n                                    xs\n                                    (conj ys (yoba n x)))\n                           (if (>= (- n x) 0)\n                               (recur (- n x) xs (conj ys x))\n                             ys))))\n                     ys)))", "problem": 112, "user": "50310b8be4b05b7df5a0b84d"}, {"code": "(fn seqh [n coll]\n    (let [s (if (empty? coll)\n      '()\n      (if (sequential? (first coll))\n          (list (seqh n (first coll)))\n          (if (<= (first coll) n)\n            (let [bla (seqh (- n (first coll)) (rest coll))]\n              (filter (complement nil?)\n                      (if (and (second coll) (not (sequential? (second coll))))\n                          (concat (list (first coll)) bla ) \n                          (list (first coll) (first bla))))))))]\n      (if s s '())))", "problem": 112, "user": "50c8697ce4b00bb60fe0c53f"}, {"code": "(fn sequs [n s]\n  (let [psum (fn [s] (apply + (flatten s)))]\n    (cond\n     (empty? s) s\n     (coll? (first s)) (cons (sequs n (first s)) \n                             (sequs (- n (psum (first s))) (rest s)))\n     :else (if (> (first s) n) \n             '()\n             (cons (first s) (sequs (- n (first s)) (rest s)))))))", "problem": 112, "user": "4e14108c535d04ed9115e7dd"}, {"code": "(letfn [(mkeep [max data] ;; either returns all data + what qty remains, or part of data that can be kept (can be nil) + nil\n    (cond\n        (nil? data)\n            [nil nil]\n        (not (coll? data))\n            (if (> data max)\n                [nil nil]\n                [data (- max data)])\n        (empty? data)\n            [data max]\n        :else\n            (let [[first-kept first-rem] (mkeep max (first data))\n                  rest-data (rest data)]\n                 (if first-kept\n                     (if first-rem\n                         (let [[rest-kept rest-rem] (mkeep first-rem rest-data)]\n                             [(concat (list first-kept) rest-kept) rest-rem])\n                         [(list first-kept) nil]\n                     )\n                     ['() nil]\n                 ))\n        ))] #(first (mkeep %1 %2)))", "problem": 112, "user": "5165a235e4b079ad97ec44ac"}, {"code": "(let [f (fn f [sm lst-in lst-out]\n          ;(prn sm lst-in lst-out)\n          (cond\n            (empty? lst-in) [sm lst-out]\n            (<= sm 0) [sm lst-out]\n\n            (coll? (first lst-in))\n            (let [[sm sub-out] (f sm (first lst-in) [])]\n              (recur sm (rest lst-in) (if (empty? sub-out)\n                                        lst-out\n                                        (conj lst-out sub-out))))\n    \n            (<= (- sm (first lst-in)) 0)\n            [(- sm (first lst-in)) lst-out]\n\n            :else\n            (recur (- sm (first lst-in) 0) (rest lst-in) (conj lst-out (first lst-in)))))]\n  (fn soln [n lst] (second (f (inc n) lst []))))", "problem": 112, "user": "50b668dde4b08fb537db98f2"}, {"code": "(fn sequs [n c]\n  ((fn preserve [result remains]\n     (if (or (empty? remains))\n       result\n       (let [f (first remains)\n             r (rest remains)\n             s (reduce + (flatten result))]\n         (if (coll? f)\n           (preserve (conj result\n                           (vec (sequs (- n s) f)))\n                     r)\n           (if (> (+ s f) n)\n             result\n             (preserve (conj result f) r))))))\n   [] c))", "problem": 112, "user": "512d3304e4b040332b905b2d"}, {"code": "(fn sh [n nest]\n  (let [x (first nest)\n        xsum (apply + (flatten x))]\n    (cond (coll? x)  (concat [(sh n x)]\n                            (if (>= n xsum)\n                              (sh (- n xsum) (rest nest))\n                              []))\n     \n     \n          (number? x) (if (>= n x)\n                        (concat [x] (sh (- n x) (lazy-seq (rest nest))))\n                        [])\n          (nil? x) [])))", "problem": 112, "user": "510cd1dde4b078ea71921124"}, {"code": "(fn sh\n  [n coll]\n  (loop [xs coll\n         res []]\n    (if xs\n      (if (coll? (first xs))\n        (recur (next xs) (conj res (sh (- n (apply + (flatten res))) (first xs))))\n        (if (<= (+ (apply + (flatten res)) (first xs)) n)\n          (recur (next xs) (conj res (first xs)))\n          res))\n      res)))", "problem": 112, "user": "513d121fe4b0e544971636a2"}, {"code": "(fn sequs- [n coll]\n  \"112. Create a function which takes an integer and a nested collection of\n  integers as arguments. Analyze the elements of the input collection and return a\n  sequence which maintains the nested structure, and which includes all elements\n  starting from the head whose sum is less than or equal to the input integer.\"\n  (let [sum (atom 0)]\n    (letfn [(f [[x & xs]]\n              (cond\n               (coll? x) (cons (f x) (f xs))\n               (and (number? x) (<= (swap! sum #(+ x %)) n)) (cons x (f xs))\n               :else '()))]\n      (f coll))))", "problem": 112, "user": "4e5eb843535d8a8b8723a2d4"}, {"code": "(fn sequs-horribilis [n coll]\n  (letfn [(tree-take [n elem]\n            (cond (nil? elem) [(dec n) nil] \n                  (<= n 0) [0 nil]\n                  (sequential? elem) (if-let [s (seq elem)] \n                                       (let [[np tp] (tree-take n (first s)) \n                                             [npp tpp] (tree-take np (next s))]\n                                         [npp (lazy-seq (cons tp tpp))]) [n nil])\n                  :else [(dec n) elem]))]\n    (let [k (->> (flatten coll) (reductions +) (take-while #(<= % n)) count)]\n      (->> (tree-take k coll) second (apply list)))))", "problem": 112, "user": "51729002e4b044b2ef48a850"}, {"code": "(fn __ [n c]\n  (letfn [\n    (to-list [xs] (for [x xs] (if (coll? x) (apply list (to-list x)) x)))\n    (sequs [n c]\n      (loop [head (first c) tail (rest c) acc [] count n]\n        (cond\n          (empty? tail)\n            (cond\n              (coll? head)\n                (let [result (sequs count head)]\n                  (if (empty? (second result))\n                    (list (first result) acc)\n                    (list (first result) (conj acc (second result)))))\n              :else\n                (if (not (neg? (- count head)))\n                  (list (- count head) (conj acc head))\n                  (list count acc)))\n          :else\n            (cond\n              (coll? head)\n                (let [result (sequs count head)]\n                  (if (empty? (second result))\n                    (recur (first tail) (rest tail) acc (first result))\n                    (recur (first tail) (rest tail) (conj acc (second result)) (first result))))\n              :else\n                (if (not (neg? (- count head)))\n                  (recur (first tail) (rest tail) (conj acc head) (- count head))\n                  (list count acc))))))]\n    (to-list (second (sequs n c)))))", "problem": 112, "user": "4fb1325de4b081705acca276"}, {"code": "(fn fc ([n sq] (fc sq n '()))\n      ( [[f & r] n cy] (cond\n                       (coll? f)  [(fc f n cy)]\n                       (integer? f) (if (<= (apply + f cy) n)\n                                      (cons f (fc r n (cons f cy)))\n                                      '()\n                                      ))))", "problem": 112, "user": "5124619ae4b02c3f2a072ccd"}, {"code": "(fn sh [mx l]\n  (if (empty? l)\n    []\n    (let [n (first l)]\n      (if (coll? n) \n        (let [res (sh mx n)\n              s (apply + (flatten res))]\n          (if (empty? res)\n            []\n            (cons res (sh (- mx s) (rest l)))))                \n        (if (> n mx)\n          []\n          (cons n (sh (- mx n) (rest l))))))))", "problem": 112, "user": "5034b0e1e4b062bc5d7ae167"}, {"code": "(fn goo \n  ([limit xs] (last (goo limit xs [])))\n  ([remain [x & xs] accu]\n    (cond\n     (nil? x) [remain accu]\n     (coll? x) (let [[new-remain new-accu] (goo remain x [])]\n                 (recur new-remain xs (conj accu new-accu)))\n     (> x remain) [remain accu]\n     :else (recur (- remain x) xs (conj accu x)))))", "problem": 112, "user": "50217818e4b00bba4502f7a7"}, {"code": "(fn [mo numso]\n  (second ((fn f [m nums]\n  \t(let [a (first nums)]\n      (cond\n       (nil? a)\n        [m []]\n       (coll? a)\n        (let [[m1 r1] (f m a)\n              [m2 r2] (f m1 (rest nums))]\n          [m2 (concat [r1] r2)])\n       (<= a m)\n        (let [m1 (- m a)\n              [m2 r2] (f m1 (rest nums))]\n          [m2 (concat [a] r2)])\n       :else\n        [m []]))) mo numso)))", "problem": 112, "user": "51899891e4b0288ada3dbdab"}, {"code": "(fn [max-sum coll]\n  (letfn [(step [coll current-sum max-sum]\n            (if (seq coll)\n              (let [head (first coll)]\n                (if (coll? head)\n                  (let [sub (step head current-sum max-sum)\n                        next-sum (+ current-sum (reduce + (flatten sub)))]\n                    (if (<= next-sum max-sum)\n                      (cons sub (step (next coll) next-sum max-sum))\n                      sub))\n                  (let [next-sum (+ head current-sum)]\n                    (if (<= next-sum max-sum)\n                      (cons head (step (next coll) next-sum max-sum))\n                      []))))))]\n    (step coll 0 max-sum)))", "problem": 112, "user": "514d7e29e4b019235f6c0587"}, {"code": "(fn horribilis [n v]\n  (cond (or (empty? v) (< n 0))  ()\n        (not (sequential? (first v)))\n        (if (<= (first v) n) (cons (first v) (horribilis (- n (first v)) (rest v))) ())\n        :else (let [z (horribilis n (first v))]\n        \t\t(cons  z (horribilis (- n (apply + (flatten z))) (rest v))))))", "problem": 112, "user": "51780f88e4b03d69594194c9"}, {"code": "(fn [n xs]\n      (let [ttl (atom 0)]\n        (letfn [(bb [[x & xs]]\n                    (cond\n                      (sequential? x) (cons (bb x) (bb xs))\n                      (and x (<= (swap! ttl #(+ % x)) n)) (cons x (bb xs))\n                      :default []))]\n          (bb xs))))", "problem": 112, "user": "50f48298e4b004d364930527"}, {"code": "(fn f [n c]\n  (letfn [(bfs [n c]\n            (cond (empty? c) '()\n                  (number? (first c))(if (> (first c) n) '()\n                                         (cons (first c) (bfs (- n (first c)) (rest c))))\n                  :else (let [pre (bfs n (first c))]\n                          (if (= pre (first c))\n                            (cons pre (bfs (- n (apply + (flatten c))) (rest c)))\n                            (list pre)))))]\n    (bfs n c)))", "problem": 112, "user": "518ccf6be4b05e6c8537e386"}, {"code": "(fn take-sum [m xs] (if (empty? xs) '() \n                      (let [[y & ys] xs] \n                        (if (sequential? y) \n                          (conj '() (take-sum m y) )\n                          (if (>= m y) (conj (take-sum (- m y) ys) y) '())))))", "problem": 112, "user": "515fb48fe4b0e2be8aa20bd5"}, {"code": "(fn f\n  ([n col] (f n col []))\n  ([n col r]\n   (if (empty? col)\n     r\n     (let [e (first col)\n           c (if (sequential? e) (f n e []) e)\n           v (if (sequential? c) (apply + (flatten c)) c)]\n       (if (> v n)\n         r\n         (f (- n v) (rest col) (conj r c)))))))", "problem": 112, "user": "514721c6e4b0d520409ed392"}, {"code": "(fn para-go [n v]\n  (letfn [(para-cnt [ret lst acc]\n            (if (empty? lst)\n              [ret acc]\n              (let [head (first lst)]\n                (if (coll? head)\n                  (let [[new-val new-acc] (para-cnt [] head acc)\n                        new-ret (if (empty? new-val)\n                                  ret\n                                  (conj ret new-val))]\n                    (if (< new-acc 0)\n                      [new-ret new-acc]\n                      (recur new-ret (rest lst) new-acc)))\n                  (if (> head acc)\n                    [ret (- acc head)]\n                    (recur (conj ret head) (rest lst) (- acc head)))))))]\n    (first (para-cnt [] v n))))", "problem": 112, "user": "4eec82fe535d93acb0a668ae"}, {"code": "(fn [n c] (let [ls (loop [l [[]] y c]\n  (cond\n        (> (reduce + (flatten l)) n)\n        (conj (vec (butlast l)) \n              (vec (butlast (last l))))\n   (empty? y) l\n   :else (recur \n (if (coll? (first y))\n(conj l []) \n   (conj\n(vec (butlast l))\n(conj (last l) (first y))))\n (if (coll? (first y)) \n   (first y) (rest y)\n   ))\n)\n)](reduce #(conj %2 (seq %))\n(rseq ls))))", "problem": 112, "user": "517945dce4b0684c1c981a43"}, {"code": "(fn ltx\n   ([x cont sum]\n   (if (empty? cont)\n      [() sum]\n      (let [[h t] [(first cont) (rest cont)]\n            [ret new-sum] (cond\n                             (vector? h) (let [[new-list new-sum] (ltx x h sum)]\n                                           (if (empty? new-list)\n                                             [() new-sum]\n                                             [(list new-list) new-sum]))\n                             (<= (+ sum h) x) [(list h) (+ sum h)]\n                             :else [() sum])]\n         (if-not (empty? ret)\n           (let [[new-ret new-new-sum] (ltx x t new-sum)]\n             [(concat ret new-ret) new-new-sum])\n           [() sum]))))\n    ([x cont]\n     (first (ltx x cont 0))))", "problem": 112, "user": "51b8e8b3e4b050a1176cd6a0"}, {"code": "(fn sequs [n seqs]\n  (loop [result [] n n seqs seqs]\n    (if (or (< n 0) (empty? seqs))\n      result\n      (let [[s & more] seqs]\n        (if (number? s)\n          (if (<= s n)\n            (recur (conj result s) (- n s) more)\n            result)\n          (recur (conj result (sequs n s)) (- n (reduce + (flatten s))) more))))))", "problem": 112, "user": "4f4e91a9e4b03ad3f0c10cca"}, {"code": "(fn [n s]\n  (let [b (fn b [v]\n              (let [l (last v)]\n                (if (vector? l)\n                  (if (= (count l) 1)\n                    (apply vector (butlast v))\n                    (conj (apply vector (butlast v)) (b l)))\n                  (apply vector (butlast v)))))\n        t (fn s [v] (reduce + (map #(if (vector? %)\n                                       (s %) %) v)))\n        ]\n    (loop [s (take 100 s)]\n      (if (< n (t s))\n        (recur (b s))\n        s))\n    ))", "problem": 112, "user": "4fa340b4e4b081705acca18c"}, {"code": "(fn [x y]\n    (letfn\n      [(i [t s a]\n            (cond\n              (empty? s) (if (> (apply + (flatten a)) t) (drop-last a) a)\n              (> (apply + (flatten a)) t) (drop-last a)\n              (number? (first s)) (i t (rest s) (conj a (first s)))\n              (sequential? (first s)) (conj a (i (- t (apply + (flatten a))) (first s) []))\n              ))]\n      (i x y [])))", "problem": 112, "user": "51b3f109e4b0f094dd986fa9"}, {"code": "(fn [n xs]\n  (second ((fn f [n [x & xs] r]\n             (if (nil? x) \n                 [n r]\n                 (if (coll? x) \n                     (let [[n1 xs1] (f n x [])] (recur n1 xs (conj r xs1)))\n                     (if (>= n x) \n                         (recur (- n x) xs (conj r x))\n                         [n r])\n                 )\n              )\n             )\n           n xs [])))", "problem": 112, "user": "51bec919e4b013aa0d74b800"}, {"code": "(letfn [\n    (horribili [x t] (cond \n        (number? t) (cond \n            (>= x t) [(- x t) [t]] \n            true     [nil []])\n        (empty? t)  [x [[]]]\n        true        (let \n            [[xf tf] (horribili x (first t))]\n            (cond \n                (nil? xf) [nil [tf]] \n                true      (let \n                    [[xn tn] (horribili xf (rest t))]\n                    [xn [(concat tf (first tn))]])))))]\n    (comp first second horribili))", "problem": 112, "user": "51cbdee1e4b08d8387cbede1"}, {"code": "(fn [n coll]\n  (letfn [(sh [a [x & xs]]\n              (when x\n                (if (coll? x)\n                  (list (sh a x))\n                  (let [b (+ a x)]\n                    (if (<= b n)\n                      (cons x (sh b xs))\n                      '())))))]\n    (sh 0 coll)))", "problem": 112, "user": "51307b84e4b08c712d3fae39"}, {"code": "(fn sh [a n [h & t]]\n  (if (nil? h)\n    a\n    (if (coll? h)\n      (let [c (sh [] n h)\n            m (apply + (flatten c))]\n        (sh (conj a c) (- n m) t))\n      (if (<= h n)\n\t(sh (conj a h) (- n h) t)\n\ta)))) []", "problem": 112, "user": "51b9d1f0e4b0e871ca49590b"}, {"code": "(fn [n x]\n\t\t(first ((fn sh [x n]\n\t\t\t(if (empty? x)\n\t\t\t\t[[] 0]\n\t\t\t\t(if (coll? (first x))\n\t\t\t\t\t(let [\t[w m] (sh (first x) n)\n\t\t\t\t\t\t\t[v l] (sh (rest x) m)]\n\t\t\t\t\t\t[(cons w v) l])\n\t\t\t\t\t\n\t\t\t\t\t(if (<= (first x) n)\n\t\t\t\t\t\t(let [[u k] (sh (rest x) (- n (first x)))]\n\t\t\t\t\t\t\t[(cons (first x) u) k])\n\t\t\t\t\t\t[[] 0])))) \n\t\tx n)))", "problem": 112, "user": "51c09719e4b0c9c82288293c"}, {"code": "(fn f[n xs] ;handles both [[]] and [[][]] nesting\n  (letfn [(g [n [x & xs]]\n             (if-not (coll? x)\n               (if (nil? x)\n                 [n ()]\n                 (let [new-n (- n x)]\n                   (if (> 0 new-n)\n                     [new-n ()]\n                     (let [[new-n ys] (g new-n xs)]\n                       [new-n (cons x ys)]))))\n               (let [[new-n ys] (g n x)]\n                 (if (> 0 new-n)\n                   [new-n (list ys)]\n                   (let [[new-n zs] (g new-n xs)]\n                     [new-n (cons ys zs)])))))]\n    (second(g n xs))))", "problem": 112, "user": "51efd397e4b0249c592fbdeb"}, {"code": "(fn [n s]\n  ((fn g [n [h & t]]\n    (if (coll? h)\n      `(~(g n h))\n      (if (and h (>= n h))\n        (cons h (g (- n h) t))\n        ()))) \n   n s))", "problem": 112, "user": "51ba8f82e4b0fe3ecfb46434"}, {"code": "(fn sequs \n  ([mx [x & xs :as coll] sum acc]\n    (cond \n      (empty? coll) [sum acc]\n      (coll? x) (let [[sum ys] (sequs mx x sum [])\n                      acc (conj acc ys)]\n                  (if (> sum mx) [sum acc] (recur mx xs sum acc)))\n      :else (let [sum (+ sum x)]\n              (if (> sum mx) [sum acc] (recur mx xs sum (conj acc x))))))\n  ([mx coll] (second (sequs mx coll 0 []))))", "problem": 112, "user": "51cdd3f0e4b0e42293a2254b"}, {"code": "(fn [limit coll]\n  (second\n   ((fn copy [limit x]\n      (if (not (coll? x))\n        (if (neg? (- limit x)) [limit nil true] [(- limit x) x false])\n       (if (empty? x)\n         [limit nil false]\n         (let [[limit head stop] (copy limit (first x))]\n           (if stop\n             [limit (if (nil? head) (list) (conj nil head)) stop]\n             (let [[limit tail stop] (copy limit (rest x))]\n               [limit (conj tail head) stop]))))))\n    limit coll)))", "problem": 112, "user": "507b7dbee4b09034bfeeb71e"}, {"code": "(fn [n coll]\n           (let [f (fn [o l]\n                     (loop [l (flatten l)\n                            ct 0\n                            n 0]\n                       (cond (empty? l) n\n                             (< o ct) (dec n)\n                             :else (recur (rest l)\n                                          (+ ct (first l))\n                                          (inc n)))))\n                 g (fn [n coll]\n                     (loop [l coll\n                            acc []]\n                       (cond (or (not (coll? l)) (empty? l)) acc\n                             :else (let [nums (loop [l l\n                                                     acc []]\n                                                (if (not (number? (first l))) acc\n                                                    (recur (rest l)\n                                                           (conj acc (first l)))))\n                                         cn (count nums)]\n                                     (recur (first (drop cn l))\n                                            (if (= [] (last l))\n                                              (conj (conj acc cn) 0)\n                                              (conj acc cn)))))))]\n             (loop [l coll\n                    to-take (f n coll)\n                    acc []]\n               (let [fl (first l)]  \n                 (cond (zero? to-take) acc\n                       (coll? fl) (recur fl\n                                         to-take\n                                         (if (empty? (g n acc))\n                                           (conj acc [])\n                                           (assoc-in acc (g n acc) [])))\n                       :else (recur (rest l)\n                                    (dec to-take)\n                                    (if (or (not (coll? (g n acc))) (empty? (g n acc)))\n                                      (conj acc fl)\n                                      (assoc-in acc (g n acc) fl))))))))", "problem": 112, "user": "50a5b7e9e4b0aa96157e2610"}, {"code": "(fn [n s]\n  (first \n   ((fn rec-sequs-horribilis [r c n [ x & xs]]\n    ;; (println \"r=\" r \" ;c= \" c \" ;n= \" n \" ;x= \" x \" ;xs=\" (take 3 xs))\n    (cond \n     (nil? x) [r c ]\n     (sequential? x) \n     (let [[nr nc] (rec-sequs-horribilis [] c n x)]\n      (rec-sequs-horribilis (conj r nr) nc n xs))\n     :else\n     (let [ nc (+ c x)\n      nr (if (>= n nc) (vec (conj r x)) r)]\n      ;; (println \"nr=\" nr \" ;nc= \" nc \" ;n= \" n \" ;x= \" x \" ;xs=\" (take 3 xs))\n      (if (< n nc)\n        [ r c]\n        (rec-sequs-horribilis nr nc n xs)))\n    ))\n   [] 0 n s)))", "problem": 112, "user": "51f59607e4b0abb92f97f9d5"}, {"code": "(fn f [k s]\n  (when (>= k 0)\n    (when-let [[s1 & sn] s]\n      (if (coll? s1)\n        (lazy-cat [(f k s1)] (f (- k (->> s1 flatten (apply +))) sn))\n        (lazy-cat (if (>= k s1) [s1] []) (f (- k s1) sn))))))", "problem": 112, "user": "5054bc87e4b0b1b9d1860eb0"}, {"code": "(fn fun [sum coll]\n\t(let [\n\t\tsum_ (atom sum)\n\t\tf (fn f [coll] \n\t\t\t(take-while identity \n\t\t\t\t(map \n\t\t\t\t\t#(if (coll? %) \n\t\t\t\t\t\t(let [in (f %)] (if (empty? (flatten in)) nil in))\n\t\t\t\t\t\t(when (<= 0 (swap! sum_ - %))\n\t\t\t\t\t\t\t%))\n\t\t\t\t\tcoll)))]\n\t\t(f coll)))", "problem": 112, "user": "520242bae4b030ee0c5b26e3"}, {"code": "(fn [n s]\n  (second \n   ((fn sequs [n s]\n      (loop [cnt 0 acc [] [x & xs] s]\n        (cond\n         (or (nil? x) (< n cnt)) [cnt acc]\n         (coll? x) (let [[c r] (sequs (- n cnt) x)\n                         coll (if (empty? r) acc (conj acc r))]\n                     (recur (+ c cnt) coll xs))\n         :else (recur (+ x cnt) (if (< n (+ cnt x)) acc (conj acc x)) xs)))) \n    n s)))", "problem": 112, "user": "5032b066e4b00c0952a257ea"}, {"code": "(comp\n  second\n  (fn f [n x]\n   (last (take-while\n     (fn[[s a]] (>= n s))\n     (reductions\n       (fn [[s a] b]\n         (if (coll? b)\n           (if-let [r (seq (f (- n s) b))]\n             [(+ s (first r)) (conj a (second r))] [s a])\n           [(+ s b) (conj a b)] ))\n       [0 []] x)))))", "problem": 112, "user": "5201572be4b0d7096e99ddbb"}, {"code": "(fn sequs [sum xs]\n  (letfn [(horribilis [acc xs]\n            (if-not (or (< (acc :limit) 0) (empty? xs))\n              (let [x (first xs)]\n                (if (coll? x)\n                  (let [ret-acc (horribilis {:limit (acc :limit) :result []} x)]\n                    (recur {:limit (ret-acc :limit) :result (conj (acc :result) (ret-acc :result))} (rest xs)))\n                  (if (>= (acc :limit) x)\n                    (recur {:limit (- (acc :limit) x) :result (conj (acc :result) x)} (rest xs))\n                    (recur {:limit -1 :result (acc :result)} (rest xs)))))\n              acc))]\n    (get (horribilis {:limit sum :result []} xs) :result)))", "problem": 112, "user": "52015698e4b0d7096e99ddba"}, {"code": "(fn f [sm [ft & rt]]\n  (if (coll? ft)\n    (list (f sm (if (empty? rt) ft (conj ft rt))))\n    (if (or (nil? ft) (< sm ft))\n      '()\n      (conj (f (- sm ft) rt) ft))))", "problem": 112, "user": "51944aaae4b0142f60b4aedc"}, {"code": "(fn [n v]\n  (let [a (atom 0)]\n    (->> v\n      (take 10)\n      (clojure.walk/prewalk #(if (number? %)\n                               (do\n                                 (swap! a + %)\n                                 (if (<= @a n) % nil))\n                                %))\n      (clojure.walk/postwalk #(if (sequential? %) (filter (fn [f] (not (nil? f))) %) %))\n      (clojure.walk/postwalk #(if (and (sequential? %) (empty? %)) nil %))\n      (clojure.walk/postwalk #(if (sequential? %) (filter (fn [f] (not (nil? f))) %) %))\n      (clojure.walk/postwalk #(if (and (sequential? %) (empty? %)) nil %))\n      (clojure.walk/postwalk #(if (sequential? %) (filter (fn [f] (not (nil? f))) %) %))\n      (clojure.walk/postwalk #(if (and (sequential? %) (sequential? (first %)) (empty? (first %))) (flatten %) %)))))", "problem": 112, "user": "51f28a64e4b0210f90e7454e"}, {"code": "(fn [cap coll]\n  (letfn [(my-reduce [f [result cap] coll]\n            (loop [r result c cap coll coll]\n              (cond\n                (empty? coll) [r c]\n                (> 0 c) [r c]\n                :else (let [[r1 c1] (f [r c] (first coll))]\n                        (recur r1 c1 (rest coll))))))\n          (do-coll [cap coll] (my-reduce do-one [[] cap] coll))\n          (do-one [[result left] input]\n            (cond\n              (> 0 left) [result left]\n              (and (number? input) (> input left)) [result -1]\n              (number? input) [(conj result input) (- left input)]\n              :else (let [[i l] (do-coll left input)]\n                      (if (empty? i)\n                        [result l]\n                        [(conj result i) l]))))\n          ]\n    (first (do-coll cap coll))))", "problem": 112, "user": "4f4c6b21e4b03ad3f0c10c8f"}, {"code": "(fn [n xs]\n (letfn [(f [ys cnt lmt]\n           (let [x (first ys) y (rest ys)]\n             (cond\n              (empty? ys) []\n              (and (coll? x) (empty? y)) (list (f x cnt lmt))\n              (coll? x) (list (f (lazy-seq (conj x y)) cnt lmt))\n              (> (+ cnt x) lmt) []\n              :else (lazy-seq (cons x (f y (+ cnt x) lmt))))))]\n   (f xs 0 n)))", "problem": 112, "user": "5225b16de4b0d2f5d1e2c0ed"}, {"code": "(fn [n tree]\n  (letfn\n    [(process-row [n [head & tail] subrow]\n      (let [[newn elem] (if (coll? head) \n                            (process-row n head [])\n                            [(- n head) head])]\n        (cond\n          (> 0 newn) [n subrow]\n          (empty? tail) [newn (conj subrow elem)]\n          :else (process-row newn tail (conj subrow elem)))))]         \n    (second (process-row n tree []))))", "problem": 112, "user": "521e8227e4b0dd19981ad082"}, {"code": "(fn sequs [n [x & xs]]\n  (cond\n    (coll? x) (list (sequs n x))\n    (nil? x) ()\n    (< n x) ()\n    :else (conj (sequs (- n x) xs) x)))", "problem": 112, "user": "514c2d05e4b02b8cbb2a9278"}, {"code": "#(letfn [(n [e f c g] (cons e (f (rest c) g)))]\n    (into [] ((fn f ([c] (f c 0))\n                ([c s]\n                  (when-let [p (first c)]\n                    (if (sequential? p)\n                      (let [g (+ s (apply + (flatten p))) r (f p s)]\n                        (if (< g %) (n r f c g)\n                          (when r (list r))))\n                      (let [g (+ s p)]\n                        (when (<= g %) (n p f c g))))))) %2)))", "problem": 112, "user": "51f66e0ee4b06ff1c25c52c3"}, {"code": "(fn [n l]\n  (let [f (fn f [a n [h & t]]\n            (cond (nil? h) [a n]\n                  (coll? h) (let [[b n] (f [] n h)]\n                              (recur (conj a b) n t))\n                  (< n h) [a 0]\n                  :else (recur (conj a h) (- n h) t)))]\n    (first (f [] n l))))", "problem": 112, "user": "522b922ee4b0d34ee08e71c3"}, {"code": "(fn sequs [n x]\n  (if (empty? x) x\n      (loop [total 0\n             s x\n             acc []]\n        (let [i (first s)]\n          (if (and (number? i) (>= n (+ i total)))\n            (if (not (empty? (rest s)))\n              (recur (+ i total) (rest s) (conj acc i))\n              [i])\n            (if (not (number? i)) (conj acc (sequs (- n total) i)) acc))))))", "problem": 112, "user": "4fbd12a5e4b081705acca2fd"}, {"code": "(fn sequs [l t]\n  (lazy-seq\n    (when-first [e t]\n      (cond \n        (sequential? e) \n        (let [sle (sequs l e)\n              nl (- l (reduce + (flatten sle)))] \n          (cons sle (sequs nl (rest t))))\n        (<= e l) (cons e (sequs (- l e) (rest t)))\n        :else '()))))", "problem": 112, "user": "5246e945e4b0644eb7b0783b"}, {"code": "(fn sh [n x]\n  (if (empty? x)\n    '()\n    (if (number? (first x))\n      (if (<= (first x) n)\n        (cons (first x) (sh (- n (first x)) (rest x)))\n        '())\n      (let [fs (reduce + (flatten (first x)))]\n        (if (<= fs n)\n          (cons (first x) (sh (- n fs) (rest x)))\n          (cons (sh n (first x)) '()))))))", "problem": 112, "user": "52586d24e4b0cb4875a45cb0"}, {"code": "(fn [i xs]\n  (:ys\n    ((fn f \n       ([i xs] (f i xs {:total 0 :ys []}))\n       ([i [x & xs] acc] \n        (if-not (nil? x)\n          (if-not (sequential? x)\n            (if-not (> x i)\n              (recur (- i x) xs {:total (+ (acc :total) x) :ys (conj (acc :ys) x)})\n              acc)\n            (let [sub (f i x)]\n              (recur (- i (sub :total)) xs {:total (+ (acc :total) (sub :total)) :ys (conj (acc :ys) (sub :ys))})))\n          acc)))\n     i xs)))", "problem": 112, "user": "5141abf1e4b02fd87f5064c3"}, {"code": "(fn sequs-horribilis [n coll]\n  (if (or (neg? n) (nil? coll))\n    []\n\t(let [[f & r] coll] \n\t\t(if (number? f) \n\t\t  (if (<= f n) (cons f (sequs-horribilis (- n f) r)) []) \n\t\t  (let [s (sequs-horribilis n f)\n\t\t        sum (apply + (flatten s))] \n\t\t    (if (empty? s) \n\t\t\t  [] \n\t\t\t  (concat [s] (sequs-horribilis (- n sum) r))))))))", "problem": 112, "user": "523a9fc9e4b081681ca7adca"}, {"code": "(fn take-while-you-can [b s]\n    (lazy-seq\n      (when-let [[f & r] (seq s)]\n        (if (sequential? f)\n          (let [fs (take-while-you-can b f)\n                u  (->> fs flatten (apply +))]\n            (cons fs (take-while-you-can (- b u) r)))\n          (if (<= f b) (cons f (take-while-you-can (- b f) r)) '())))))", "problem": 112, "user": "525f51bde4b0cb4875a45dc8"}, {"code": "(fn p112\n  ([lst] (p112 (first lst) (next lst)))\n  ([n lst] (p112 n 0 0 lst))\n  ([n acc depth lst] (if (or (< 20 depth) (empty? lst) (< n acc)) nil\n                           (let [fl (first lst) nd (inc depth)]\n                             (if (coll? fl)\n                               (let [flv (p112 n acc nd fl)] (list flv))\n                               (if (< n (+ acc fl)) ()\n                                 (cons fl (p112 n (+ acc fl) nd (next lst)))))))))", "problem": 112, "user": "5272669de4b03e8d9a4a742e"}, {"code": "(fn what [n coll]\n  (letfn [(process-next [cnt in]\n            (loop [cnt cnt out [] in in]\n              (let [head (first in)]\n                (cond\n                  (= head nil) out\n                  (coll? head) (conj out (process-next cnt head))\n                  (> (+ cnt head) n) out\n                  :else (recur (+ cnt head) (conj out head) (rest in))))))]\n    (process-next 0 coll)))", "problem": 112, "user": "52463059e4b09dbe66b56198"}, {"code": "(fn prefix-with-sum [n coll]\n  (if (empty? coll)\n    []\n    (let [f (first coll)]\n      (cond\n        (coll? f) (let [sub [(prefix-with-sum n f)]\n                        sum (apply + (flatten sub))] \n                    (into sub (prefix-with-sum (- n sum) (rest coll))))\n        (<= f n) (into [f] (prefix-with-sum (- n f) (rest coll)))\n        :else []))))", "problem": 112, "user": "526ee63de4b03e8d9a4a733f"}, {"code": "(fn horrible [x node]\n  (if-let [h (first node)]\n    (cond\n      (coll? h) (if-let [t (horrible x h)] (list t))\n      (<= h x) (cons h (horrible (- x h) (rest node)))\n      :else '())))", "problem": 112, "user": "5272d4b7e4b03e8d9a4a7453"}, {"code": "(fn [l x]\n  ((fn f [i s]\n     (if (number? (first i))                   \n       (if (<= (+ (first i) s) l)\n         (cons (first i) (f (rest i) (+ (first i) s)))\n         '())                   \n       (if (nil? (first i))\n         '()\n         [(f (first i) s)])))\n   x 0))\n\n;; this would fail for the first testcase if we were to count to 21", "problem": 112, "user": "513b77f3e4b00f740c76c403"}, {"code": "(fn f ([n v r]\n        (if (empty? v)\n           r\n           (let [c (first v)]\n             (if (coll? c)\n               (let [q (f n c [])]\n                 (if (empty? q)\n                    r\n                    (concat r [q])))\n               (if (< (- n c) 0)\n                 r\n                 (f (- n c) (rest v) (concat r [c])))))))\n  ([n v] (f n v [])))", "problem": 112, "user": "50bce014e4b0594b91591c63"}, {"code": "(fn seho [m s]\n   (letfn [(take-nested [sum src rslt]\n                        (let [frst (first src)]  \n                        (cond (nil? frst) rslt\n                              (coll? frst) #(let [nested (trampoline take-nested sum frst [])]\n                                                    (take-nested\n                                                     (+ sum (apply + (flatten nested)))\n                                                     (rest src)\n                                                     (conj rslt nested))\n                                                    )\n                              (<= (+ sum frst) m) #(take-nested \n                                                          (+ sum frst)\n                                                          (rest src)\n                                                          (conj rslt frst)) \n                              :else rslt\n                              )\n                          ))]\n     (trampoline take-nested 0 s [])\n     )\n )", "problem": 112, "user": "5274eb56e4b03e8d9a4a74bb"}, {"code": "(fn\n    [n xs]\n    (let [sequs (fn sequs\n                  [xs n cnt]\n                  (cond\n                   (empty? xs) []\n                   (coll? (first xs)) (let [v1 (sequs (first xs) n cnt)\n                                            v1cnt (apply + (flatten v1))]\n                                        (if (> (+ cnt v1cnt) n)\n                                          (cons v1 [])\n                                          (cons v1 (sequs (rest xs)\n                                                          n\n                                                          (+ cnt v1cnt)))))\n                   (> (+ cnt (first xs)) n) []\n                   :else (cons (first xs)\n                               (sequs (rest xs)\n                                      n\n                                      (+ cnt (first xs))))))]\n      (sequs xs n 0)))", "problem": 112, "user": "4fb591aee4b081705acca2c0"}, {"code": "(fn [m s]\n\t  (letfn [(f [acc [x & ss] c]\n\t\t    (if (nil? x)\n\t\t      [acc c nil]\n\t\t      (if (coll? x)\n\t\t\t(let [[nx nc done] (f [] x c)]\n\t\t\t  (if (= done :done)\n\t\t\t    [(conj acc nx) 0 :done]\n\t\t\t    (f (conj acc nx) ss nc)))\n\t\t\t(if (< m (+ x c))\n\t\t\t  [acc 0 :done]\n\t\t\t  (f (conj acc x) ss (+ x c))))))]\n\t    (first (f [] s 0))))", "problem": 112, "user": "519ef784e4b087743fad2198"}, {"code": "(fn horribilis\n  ([n x] (horribilis n [] x))\n  ([n r [f & t]] \n   (cond\n    (nil? f) r\n    (sequential? f)\n    \t(let [sf (apply + (flatten f))]\n    \t\t(if (<= sf n) (horribilis (- n sf) (conj r f) t) (conj r (horribilis n [] f))))\n    (<= f n) (horribilis (- n f) (conj r f) t)\n    :else r)))", "problem": 112, "user": "51d96ad0e4b02ceefd94774f"}, {"code": "(fn crap [n loc]\n  (loop [n n\n         newz []\n         z loc]\n    (if (or (empty? z) (neg? n)) newz\n        (let [h (first z)\n              t (rest z)]\n          (cond\n           (vector? h) (conj newz (crap n h))\n           (> h n) newz\n           :else (recur (- n h) (conj newz h) t))))))", "problem": 112, "user": "524ae8e6e4b09eba1c0223b5"}, {"code": "(fn dcl [l x]\n  (loop [c [] [x1 & rx] x]\n    (let [rc (- l (apply + (flatten c)))]\n      (cond\n        (nil? x1) c\n        (coll? x1) (recur (conj c (dcl rc x1)) rx)\n        (<= x1 rc) (recur (conj c x1) rx)\n        :else c))))", "problem": 112, "user": "528e64b7e4b0239c8a67aedd"}, {"code": "(fn f\n     ( [n coll] (first (f n (tree-seq coll?  identity coll) [])))\n     ( [n [fst & rst :as s] acc ]\n         ;; (println n acc)\n         (if (or  (nil? fst) (and (number? fst) (> fst n)))\n           acc\n           (if (coll? fst)\n             (conj acc (lazy-seq (f n (rest s) [])))             \n             (recur (- n fst) (rest s) (conj acc fst))\n             )\n           ))\n     )", "problem": 112, "user": "529b7072e4b02ebb4ef750a3"}, {"code": "(fn [n-in nested-in] (let [\n  answer (fn [n nested] (loop [so-far 0 result [] xs nested] (if (or (nil? xs) (every? nil? xs)) result (if (coll? (first xs)) (recur so-far (conj result []) (cons (ffirst xs) (cons (fnext (first xs)) (concat (nnext (first xs)) (next xs))))) (if (> (+ so-far (first xs)) n) result (recur (+ so-far (first xs)) (conj (vec (butlast result)) (conj (last result) (first xs))) (next xs)))))))\n  broken (answer n-in nested-in)\n  the-count (count (filter #(not (empty? %)) broken))\n  the-other-count (count broken)\n  result (fn [z] (reverse (reduce (fn [a b] (conj b a)) (reverse z))))\n]\n  (cond (= 0 the-count) '() (and (= 1 the-count) (> the-other-count 1)) (list (result broken)) :else (result broken)))\n)", "problem": 112, "user": "526dd90de4b03e8d9a4a72fe"}, {"code": "(fn take-sum [sum aseq]\n  (if-let [[exp & other] (seq aseq)]\n    (cond\n      (sequential? exp)  (let [sub-exp (take-sum sum exp)\n                               new-sum (- sum (reduce + 0 (flatten sub-exp)))]\n                           (cons sub-exp (take-sum new-sum other)))\n      (<= exp sum)       (cons exp (take-sum (- sum exp) other))\n      :else              ())\n    ()))", "problem": 112, "user": "4f9d53f3e4b0dcca54ed6d21"}, {"code": "(fn sequs-horribilis [n s]\n         (letfn[(step\n                  [c xs]\n                  (if(sequential? xs)\n                    (let[head (first xs)]\n                      (if(sequential? head)\n                        (let[next-s (step c head)\n                             sum (apply + (flatten next-s))]\n                          (if(<= (+ c sum) n)\n                            (cons next-s  (step (+ c sum) (next xs)))\n                            (vector next-s)))\n                        (if(<= (+ c head) n)\n                          (cons head (step (+ c head) (next xs)))\n                          [])))))]\n           (step 0 s)))", "problem": 112, "user": "5273562ae4b03e8d9a4a7479"}, {"code": "(fn [n sq]\n  (first\n   ((fn horribl [n sm sq]\n      (if (empty? sq) ['() sm]\n          (let [[h & t] sq]\n            (if (coll? h)\n              ;; collection -> go deeper\n              (let [[new-sq new-sm] (horribl n sm h)]\n                (if (>= new-sm n) [(list new-sq) new-sm]\n                    (let [[newer-sq newer-sm] (horribl n new-sm t)]\n                      [(cons (list new-sq) newer-sq) new-sm])))\n              ;; otherwise, ensure sum correct\n              (let [new-sm (+ sm h)]\n                (if (> new-sm n) ['() new-sm]\n                    (let [[new-sq newer-sm] (horribl n new-sm t)]\n                      [(cons h new-sq) newer-sm]))))))) n 0 sq)))", "problem": 112, "user": "529ce629e4b04e0c58e87b6e"}, {"code": "(fn f [max sequ]\n        (if (seq sequ)\n            (if (coll? (first sequ))\n              (list (f max (first sequ)))\n              (if (> (first sequ) max)\n                ()\n                (cons (first sequ) (f (- max (first sequ)) (rest sequ)))))\n            ()))", "problem": 112, "user": "52753740e4b03e8d9a4a74c1"}, {"code": "(fn sequs_horri [max coll]\n  (let [f (first coll)\n\n        ]\n    (cond\n      (empty? coll) []\n     (sequential? f) (let [s (sequs_horri max f)\n                           sum' (reduce + (flatten s))]\n                       (cond\n                        (< (count s) (count f)) (list s)\n                        (= max sum') (list s)\n                        :else (cons s (sequs_horri (- max sum')\n                                                   (rest coll)))\n                        )\n                       )\n     :else   (cond\n              (> f max) []\n              :else (cons f (sequs_horri (- max f)\n                                         (rest coll)\n                                         ))))))", "problem": 112, "user": "52140b53e4b0961f15ac4d7e"}, {"code": "(fn f [n [x & xs]]\n  (cond\n   (coll? x) (cons (f n x)\n                   (f (- n (apply + (flatten x))) xs))\n   (and (number? x) (<= x n)) (cons x (f (- n x) xs))\n   :else '()))", "problem": 112, "user": "4f7431d2e4b044e54cd9a8f7"}, {"code": "(letfn [(sumfn [x]\n               (if (coll? x)\n                 (apply + (map sumfn x))\n                 x))]\n  (fn seqhorib [n s]\n    (if (coll? s)\n      (let [sum (sumfn (first s))]\n        (if (and (<= sum n) (not (empty? (rest s))))\n          (cons (first s) (seqhorib (- n sum) (rest s)))\n          (filter #(not (nil? %)) (list (seqhorib n (first s))))))\n      (when (<= s n) s))))", "problem": 112, "user": "52736ca1e4b03e8d9a4a747e"}, {"code": "(fn [v coll]\n    (let [c (atom 0)\n          g (fn [x] (and x (not= '() x)))\n          f (fn [x] (cond\n                    (sequential? x) (filter g x)\n                     :default (when (<= (+ @c x) v)\n                                (do\n                                  (swap! c (partial + x))\n                                  x))))]\n          (clojure.walk/postwalk f (take 100 coll))))", "problem": 112, "user": "4fe8fda4e4b0547ebccb2438"}, {"code": "(fn  [limit -s]\n   (last ((fn me [limit -seq stock]\n            (loop [l limit f (first -seq) n (next -seq) s stock]\n              (if (> 0 l)\n                [l (reverse s)]\n                (if n\n                  (if (sequential? f)\n                    (let [r (me l f '())]\n                      (recur (first r) (first n) (next n) (conj s (last r)))\n                      )\n                    (if (<= 0 (- l f))\n                      (recur (- l f) (first n) (next n) (conj s f))\n                      [l (reverse s)])\n                    )\n                  (if (sequential? f)\n                    (let [r (me l f '())]\n                      [(first r) (reverse (conj s (last r)))])\n                    (if (<= 0 (- l f))\n                      [(- l f) (reverse (conj s f))]\n                      [l (reverse s)])\n                    )))\n              )) limit -s '())))", "problem": 112, "user": "50550f43e4b0b1b9d1860eb7"}, {"code": "(fn f [a s]\n  (into []\n    (when-first [fs s]\n      (let [i (if (coll? fs) (f a fs) fs)\n            a (- a (apply + (flatten [i])))]\n      (if (<= 0 a)\n        (cons i (lazy-seq (f a (rest s)))))))))", "problem": 112, "user": "528652fbe4b0239c8a67ae14"}, {"code": "(fn h-seq\n  [tot l]\n  (let [ct (atom 0)\n        replace-nums\n        (fn [l]\n        (clojure.walk/postwalk  \n         (fn [i] (if (number? i)\n                 (let [c (swap! ct #(+ i %))]\n                   (if (<= c tot) i\n                     nil))\n                 i)) l))]\n    (if (not= clojure.lang.LazySeq (class l))\n      (clojure.walk/postwalk\n       #(if (coll? %) \n          (remove (fn [x] (or (nil? x) (and (coll? x) (empty? x)))) %) %) (replace-nums l))\n      (take-while (fn [x] (<= (swap! ct #(+ % x)) tot)) l))))", "problem": 112, "user": "5273e006e4b03e8d9a4a7495"}, {"code": "(fn n112 [s coll]\n  (letfn [(n112-t [s coll]\n                  (loop [c coll f (first c) a 0 l []]\n                    (if (empty? c)\n                      [l a]\n                      (if (sequential? f)\n                        (let [[sl sa] (n112-t (- s a) f)] \n                          (recur (rest c) (second c) (+ a sa) (conj l sl)))\n                        (if (> (+ a f) s)\n                          [l a]\n                          (recur (rest c) (second c) (+ a f) (conj l f)))))))]\n    (first (n112-t s coll))))", "problem": 112, "user": "52b43468e4b0c58976d9ad1b"}, {"code": "(fn [limit sequence]\n    (loop [state {:limit limit\n                  :stack (list [sequence []])}]\n      (letfn [(top-seq []\n                (first (first (:stack state))))\n              (top-result []\n                (second (first (:stack state))))\n              (finished? []\n                (and (top-finished?)\n                     (= 1 (count (:stack state)))))\n              (top-finished? []\n                (or\n                  (< (limit) 0)\n                  (empty? (top-seq))))\n              (limit []\n                (:limit state))\n              (stack []\n                (:stack state))\n              (pop-top []\n                (let [rest-of-stack (rest (rest (stack)))\n                      [next-seq next-result] (second (stack))]\n                  {:limit (limit)\n                   :stack (conj\n                            rest-of-stack\n                            [next-seq (conj next-result (top-result))])}))\n              (push-seq []\n                {:limit (limit)\n                 :stack (conj \n                          (conj\n                            (rest (stack))\n                            [(rest (top-seq)) (top-result)])\n                          [(first (top-seq)) []])})\n              (do-number []\n                (let [n (first (top-seq))\n                      want? (<= n (limit))\n                      new-limit (- (limit) n)\n                      new-top-result (if want?\n                                       (conj (top-result) n)\n                                       (top-result))\n                      new-stack (conj\n                                  (rest (stack))\n                                  [(rest (top-seq)) new-top-result])]\n                  {:limit new-limit\n                   :stack new-stack}))]\n        (cond\n          (finished?)\n          (top-result)\n          \n          (top-finished?)\n          (recur (pop-top))\n\n          (coll? (first (top-seq)))\n          (recur (push-seq))\n          \n          :else\n          (recur (do-number))))))", "problem": 112, "user": "521b9f92e4b0c4ef0be8304c"}, {"code": "(fn [n tree]\n  (let [r \n    ((fn f [[x & xs] c]\n       (if (sequential? x)\n         [(f x c)]\n         (let [c1 (+ x c)]\n           (if (<= c1 n)\n             (cons x (if (empty? xs) nil (f xs c1)))))))\n     tree 0)]\n    (if (nil? r) () r)))", "problem": 112, "user": "52a88c4de4b0c58976d9ac30"}, {"code": "#(first\n  ((fn f [t c]\n     (loop [[x & y] c s [] r t]\n       (cond (nil? x) [s r]\n             (coll? x)\n               (let [[a b] (f r x)]\n                 (recur y (conj s a) b))\n             (<= x r) (recur y (conj s x) (- r x))\n             :else [s (- r x)])))\n   % %2))", "problem": 112, "user": "4f437751e4b0d7d3c9f3fd20"}, {"code": "(fn sqh [lim c]\n  (let [f (first c) r (rest c)]\n    (if (coll? f) (list (sqh lim f))\n      (if (> f lim)\n        '()\n        (cons f (if (empty? r) '() (sqh (- lim f) (rest c)))))))\n  )", "problem": 112, "user": "5267d9bde4b03e8d9a4a7188"}, {"code": "(fn [max coll]\n  (letfn [(ltn2 [max coll sum]\n            (loop [curr-sum sum\n                   coll' coll\n                   acc '() ]\n              (if (coll? (first coll'))\n                (let [[new-sum coll''] (ltn2 max (first coll') curr-sum)]\n                  (recur new-sum\n                         (rest coll')\n                         (conj acc coll'')))\n                (if (or (empty? coll') (> (+ curr-sum (first coll')) max))\n                  (list curr-sum (reverse acc))\n                  (recur (+ curr-sum (first coll')) \n                         (rest coll')\n                         (conj acc (first coll')))))))]\n    (let [[sum col'] (ltn2 max coll 0)]\n      col')))", "problem": 112, "user": "504ec4d3e4b069badc5a33c9"}, {"code": "(fn [sum coll]\n  (letfn [(walk-for [coll limit res sum]\n            (if (empty? coll)\n              res\n              (if (sequential? (first coll))\n                (walk-for (rest coll)\n                          limit\n                          (conj res (walk-for (first coll) limit [] sum))\n                          (apply + sum (flatten (first coll))))\n                (if (> (+ sum (first coll)) limit)\n                  res\n                  (walk-for (rest coll) limit (conj res (first coll)) (+ sum (first coll)))))))]\n    (walk-for coll sum [] 0)))", "problem": 112, "user": "50645e12e4b007509339a58a"}, {"code": "(letfn [(update [n s]\n                 (if (sequential? s)\n                   (if (empty? s)\n                     [n s]\n                     (let [[n f] (update n (first s))]\n                       (if (>= n 0) \n                         (let [[n r] (update n (rest s))]\n                           [n (cons f r)])\n                         [n (if (sequential? f) [f] [])])))\n                   [(- n s) s]))]\n         (fn [n s] (second (update n s))))", "problem": 112, "user": "5294e44de4b02ebb4ef75016"}, {"code": "(fn sh [n coll]\n  (letfn [(value [x] (if (number? x) x (apply + (map value x))))]\n    (cond\n      (empty? coll) []\n      (<= (value (first coll)) n) (cons\n                                   (first coll)\n                                   (sh (- n (value (first coll))) (rest coll)))\n      (number? (first coll)) []\n      :else (remove empty? [(sh n (first coll))]))))", "problem": 112, "user": "51e00020e4b01188f0627534"}, {"code": "(comp first\n  (fn _ [sum coll]\n    (if (or (< sum 0) (empty? coll))\n      ['() 0]\n      (let [h (first coll) t (rest coll)]\n        (if (integer? h)\n          (if (<= h sum)\n            (let [[x y] (_ (- sum h) t)]\n              [(cons h x) (+ y h)])\n            ['() 0])\n          (let [[x y] (_ sum h)\n                [a b] (_ (- sum y) t)]\n            [(cons x a) (+ y b)]))))))", "problem": 112, "user": "527cd633e4b0757a1b17136f"}, {"code": "(fn [n xs]\n  (letfn [(sequs-horribilis [n xs accum]\n            (if-let [x (first xs)]\n              (if (coll? x)\n                (if-let [x' (not-empty (sequs-horribilis n x []))]\n                  (recur (- n (reduce + (flatten x'))) (rest xs) (conj accum x'))\n                  accum)\n                (if (<= x n)\n                  (recur (- n x) (rest xs) (conj accum x))\n                  accum))\n              accum))]\n    (sequs-horribilis n xs [])))", "problem": 112, "user": "4e50b67b535dc968683fc4ed"}, {"code": "(fn [n c] (get ((fn add [c2 i col num] (if (nil? (if (vector? c2) (get c2 i) (nth c2 i)))\n                                     {:col col :num num}\n                                     (if (sequential? (nth c2 i))\n                                       (let [res (add (nth c2 i) 0 [] num)] (recur c2 (inc i) (conj col (get res :col)) (get res :num)))\n                                       (if (> (+ num (nth c2 i)) n)\n                                         {:col col :num num}\n                                         (recur c2 (inc i) (conj col (nth c2 i)) (+ num (nth c2 i))))\n                                     ))) c 0 [] 0) :col))", "problem": 112, "user": "52c1bd29e4b07a9af579236a"}, {"code": "(fn sequs-horribilis [n v]\n  (letfn [(sequs-horribilis-it [n s v]\n            (loop [a [] s s v v]\n              (let [f (first v)\n                    r (rest v)]\n                (cond (nil? f) [a,s]\n                      (coll? f) (let [[a2,s2] (sequs-horribilis-it n s f)]\n                                  (recur (conj a a2) s2 r))\n                      (> (+ f s) n) [a,s]\n                      :else (recur (conj a f) (+ s f) r)))))]\n\n    (first (sequs-horribilis-it n 0 v))))", "problem": 112, "user": "515bbcd9e4b0388ca8ca1521"}, {"code": "(fn x [s [h & t]]\n  (if (nil? h) []\n    (if (coll? h)\n      (cons (x s h) (x (apply - s (flatten h)) t))\n      (if (< s h) [] (cons h (x (- s h) t)))\n      )\n    ))", "problem": 112, "user": "52593207e4b0cb4875a45cd3"}, {"code": "(fn sequs-horribilis [n coll]\n  (let [seq-take (fn seq-take [n coll]\n                  (lazy-seq\n                   (let [[pre tail] (split-with (complement sequential?) coll)\n                         [s post] (split-with sequential? tail) ; ignoring post atm\n                         valid-els (take n pre)                 ; hardcode first\n                         n (- n (count valid-els))]\n                     (if (zero? n)\n                       valid-els\n                       (concat valid-els\n                         (list (seq-take n (first s))))))))\n        num-to-take (count (take-while #(<= % n) (reductions + (flatten coll))))]\n    (seq-take num-to-take coll)))", "problem": 112, "user": "51a97f7ae4b08d8ec191b827"}, {"code": "(fn d [n l]\n  (first\n    ((fn sequs-horribilis\n       [n [x & xs]]\n       (cond\n         (nil? x) [x n]\n         (coll? x) (let [[y m] (sequs-horribilis n x)\n                         [z l] (sequs-horribilis m xs)]\n                     [(cons y z) l])\n         :else (if (<= x n)\n                 (let [[y m] (sequs-horribilis (- n x) xs)]\n                   [(cons x y) m])\n                 ['() n]))) n l)))", "problem": 112, "user": "52828298e4b0757a1b17145b"}, {"code": "(fn stuff [n [x & xs]]\n  (cond\n    (sequential? x) (let\n                      [sub-stuff (stuff n x)]\n                      (if (= sub-stuff x)\n                        (cons sub-stuff (stuff (- n (apply + (flatten sub-stuff))) xs))\n                        [sub-stuff]))\n    (nil? x) []\n    (< n x) []\n    :else (cons x (stuff (- n x) xs))))", "problem": 112, "user": "4f03641a535dcb61093f6a9b"}, {"code": "(fn my-sequs-horribilis\r\n  [sum-to nested-coll]\r\n  (loop [result [] i 0 rest-to-sum sum-to]\r\n    (let [current-val (last (take (inc i) nested-coll))]\r\n      (if (sequential? current-val)\r\n        (conj result (my-sequs-horribilis rest-to-sum current-val))\r\n        (if (or (> 0 (- rest-to-sum current-val)) (= result (take (inc i) nested-coll)))\r\n          result\r\n          (recur (conj result current-val) (inc i) (- rest-to-sum current-val)))))))", "problem": 112, "user": "509a25b7e4b0efbae1fbc0a8"}, {"code": "(fn g [m c] (rest (map #(last %) (take-while (fn [[_ a]] (not= a []) )\n                   (reductions\n                    (fn [[r _] d] (let [q (apply + (flatten (list d)))] (if (<= q r) \n                                        (list (- r q) d) \n                                        (if (coll? d) \n                                          (list -99 (g r d))\n                                          (list r []) ) ))  )\n                    [m 0] c)   ))) )", "problem": 112, "user": "52c6a0abe4b0c2d177d62111"}, {"code": "(fn sequs-horriblis [n s]\n  (let [stateful-tree-take-while\n        (fn ! [init-state state-trans take-pred t]\n          (loop [acc []\n                 t t\n                 state init-state]\n            (if (empty? t)\n              [true state acc]\n              (let [[head & tail] t]\n                (if (coll? head)\n                  (let [[continue new-state res] (! state state-trans take-pred head)]\n                    (if continue\n                      (recur (conj acc res) tail new-state)\n                      [false new-state (conj acc res)]\n                      ))\n                  (let [new-state (state-trans state head)]\n                    (if (take-pred new-state)\n                      (recur (conj acc head) tail new-state)\n                      [false new-state acc]\n                      )))))))]\n    (last (stateful-tree-take-while 0 + (partial >= n) s))\n    ))", "problem": 112, "user": "5094057fe4b097f48cc38593"}, {"code": "(fn sequs [n s]\n  (when (not (empty? s))\n    (let [candidato (first s)]\n      (if (coll? candidato)\n        (let [coll-candidato (sequs n candidato)]\n          (cons coll-candidato (sequs (- n ((fn soma-valores [s]\n                                             (if (empty? s)\n                                               0\n                                               (+ (if (coll? (first s))\n                                                    (soma-valores (first s))\n                                                    (first s))\n                                                   (soma-valores (next s)))))\n                                            coll-candidato)) \n                                      (next s))))\n        (if (<= candidato n)\n          (cons candidato (sequs (- n candidato) (next s)))\n          (list))))))", "problem": 112, "user": "52c8758be4b0c2d177d62135"}, {"code": "(fn [n colls]\n     (let [_myfn \n          (fn myfn  [n sum colls]\n      (let [e (first colls)]\n        (if (sequential? e)\n           [(myfn n sum e)]\n         (let [sum (+ sum e)] (if (> sum n) '()\n            (if (empty? (rest colls)) colls\n              (cons e (lazy-seq (myfn n sum (rest colls))) ))\n            )\n         ))\n        )\n      )\n       ] \n       (_myfn n 0 colls)\n      )\n)", "problem": 112, "user": "522eba30e4b01cdb292c5f0e"}, {"code": "(fn [n a]\n  (letfn [(next-thing [cnt b]\n            (loop [ct cnt res [] leftover b]\n              (let [head (first leftover)]\n                (cond\n                  (= head nil) res\n                  (coll? head) (conj res (next-thing ct head))\n                  (> (+ ct head) n) res\n                  :else (recur (+ ct head) (conj res head) (rest leftover))))))]\n    (next-thing 0 a)))", "problem": 112, "user": "5133e51ae4b0d7a043de8cf6"}, {"code": "#(letfn [(sequs [n [x & coll]]\n  (if (nil? x)\n    [n []]\n    (if (coll? x)\n      (let [[n1 sub1] (sequs n x)]\n        (if (>= n1 0)\n          (let [[n2 sub2] (sequs n1 (rest coll))]\n            [n2 (cons sub1 sub2)]\n            )\n          [n1 [sub1]]\n          )\n        )\n      (if (>= n x)\n        (let [[n1 sub1] (sequs (- n x) coll)]\n          [n1 (cons x sub1)]\n          )\n        [(- n x) []]\n        )\n      )\n    )\n                )]\n   (last (sequs %1 %2))\n   )", "problem": 112, "user": "52e59ca5e4b09f7907dd1464"}, {"code": "(fn [C n c]\n  (((fn f [[x & t] s c]\n      (if (or (< n s) (nil? x))\n        [c s (C c)]\n        (let [[r s m] (if (coll? x)\n                        (f x s [])\n                        [x (+ s x) (- n s x -1)])]\n          (if (<= m 0) [c s (C c)] (f t s (conj c r))))))\n    c 0 []) 0)) count", "problem": 112, "user": "52b453b0e4b0c58976d9ad21"}, {"code": "(fn [limit xs]\n    (second \n     ((fn f [[limit] xs]\n        (if (coll? xs)\n          (let [rs (take-while #(<= 0 (first %))\n                               (reductions f [limit] xs))]\n            [(first (last rs)) (map second (rest rs))])\n          [(- limit xs) xs]))\n      [limit] xs)))", "problem": 112, "user": "52e3e6a8e4b09f7907dd1448"}, {"code": "(fn [s xs]\n  (let [l (reverse (loop [l (->> xs\n                                       (tree-seq coll? identity)\n                                       (map #(if (coll? %) [] %))\n                                       ) c 0 r []]\n                           (let [f (first l)] \n                             (if (or (coll? f) (and (number? f) (<= (+ f c) s)))\n                               (recur (next l) (if (coll? f) c (+ f c)) (conj r f))\n                               r))))]\n    (loop [l l r []]\n      (if l\n        (let [[f n] (split-with #(or (number? %) (not (empty? %))) l)\n              rf (reduce conj [] (reverse f))]\n          (recur (next n) (if (empty? r) \n                            rf\n                            (conj (vec rf) r))))\n        r))))", "problem": 112, "user": "4ef9c8f9535dced4c769f26b"}, {"code": "(fn [m s]\n ((fn f [m [x & y] k]\n  (letfn [(put[c l]\n    (cons c (lazy-seq (f m y l))))]\n  (cond\n   (nil?  x)  '()\n   (coll? x)\n     (let [c (f m x k)]\n\t   (if (empty? c) '()\n   \t       (put c (+ k (apply + (flatten c))))))\n   (> (+ x k) m) '()\n   :else\n     (put x (+ x k))))) m s 0))", "problem": 112, "user": "52f818a6e4b047fd55836fcc"}, {"code": "(fn sh [n coll]\n  (loop [n n, [f & r :as c] coll, out []]\n    (cond\n      (coll? f) (conj out (sh n f))\n      (or (nil? f) (> f n)) out\n      :else\n        (recur (- n f) r (conj out f)))))", "problem": 112, "user": "52dd6cc8e4b09f7907dd13e2"}, {"code": "(fn [n tree] (letfn [\n(tree-from-stack-vector [sv]\n\t(cond\n\t\t(empty? sv)\n\t\tsv\n\t\t(empty? (rest sv))\n\t\t(first sv)\n\t\t:else\n\t\t(conj (first sv) (tree-from-stack-vector (rest sv)))))\n(tree-take\n\t([n tree] (tree-take n [] [] [] tree))\n\t([n heads tails current-head current-tail]\n\t(cond\n\t\t(zero? n)\n\t\t(tree-from-stack-vector (conj heads current-head))\n\t\t(and (empty? current-tail) (empty? tails))\n\t\t(tree-from-stack-vector (conj heads current-head))\n\t\t(and (empty? current-tail) (not (empty? tails)))\n\t\t(tree-take\n\t\t\tn\n\t\t\t(pop heads)\n\t\t\t(pop tails)\n\t\t\t(conj (peek heads) current-head)\n\t\t\t(peek tails))\n\t\t(number? (first current-tail))\n\t\t(tree-take\n\t\t\t(dec n)\n\t\t\theads\n\t\t\ttails\n\t\t\t(conj current-head (first current-tail))\n\t\t\t(rest current-tail))\n\t\t(sequential? (first current-tail))\n\t\t(tree-take\n\t\t\tn\n\t\t\t(conj heads current-head)\n\t\t\t(conj tails (rest current-tail))\n\t\t\t[]\n\t\t\t(first current-tail)))))\n(tree-take-while\n\t([pred tree] (tree-take-while pred [] [] [] tree))\n\t([pred heads tails current-head current-tail]\n\t(cond\n\t\t(not (pred heads tails current-head current-tail))\n\t\t(tree-from-stack-vector (conj heads (or (butlast current-head) [])))\n\t\t(and (empty? current-tail) (empty? tails))\n\t\t(tree-from-stack-vector (conj heads current-head))\n\t\t(and (empty? current-tail) (not (empty? tails)))\n\t\t(tree-take-while\n\t\t\tpred\n\t\t\t(pop heads)\n\t\t\t(pop tails)\n\t\t\t(conj (peek heads) current-head)\n\t\t\t(peek tails))\n\t\t(number? (first current-tail))\n\t\t(tree-take-while\n\t\t\tpred\n\t\t\theads\n\t\t\ttails\n\t\t\t(conj current-head (first current-tail))\n\t\t\t(rest current-tail))\n\t\t(sequential? (first current-tail))\n\t\t(tree-take-while\n\t\t\tpred\n\t\t\t(conj heads current-head)\n\t\t\t(conj tails (rest current-tail))\n\t\t\t[]\n\t\t\t(first current-tail)))))\n(tree-sum [tree] (reduce + (flatten tree)))\n(sequs-horribilis [n tree] (tree-take-while (fn [heads tails current-head current-tail] (>= n (tree-sum (conj heads current-head)))) tree))\n] (sequs-horribilis n tree)))", "problem": 112, "user": "52f10094e4b05e3f0be25ee8"}, {"code": "(fn take-until [n vals]\n  (loop [values vals\n         current 0\n         accum []]\n    (if (empty? values)\n      accum\n      (let [v (first values)]\n        (if (coll? v)\n          (let [sub (take-until (- n current) v)]\n                (let [total (+ current (reduce + (flatten sub)))]\n                  (recur (rest values) total (conj accum sub))))\n          (let [total (+ current v)]\n                (if (> total n)\n                  accum\n                  (recur (rest values) total (conj accum v)))))))))", "problem": 112, "user": "5164867fe4b003cf19fdde3e"}, {"code": "(fn nested-sum [target items]\n  (letfn [(rec-sum [elem]\n            (if-not (sequential? elem)\n              elem\n              (reduce + (flatten elem))))\n          \n          (solve [sum coll acc]\n            (cond\n             (empty? coll) (reverse acc)\n             (<= (rec-sum (first coll)) sum) (solve (- sum (rec-sum (first coll)))\n                                                    (rest coll)\n                                                    (into acc [(first coll)]))\n             :else (if-not (sequential? (first coll))\n                     (reverse acc)\n                     (reverse (conj acc\n                                    (solve sum\n                                           (first coll)\n                                           nil))))))]\n    (solve target items nil)))", "problem": 112, "user": "530578ede4b0d8b024fd3760"}, {"code": "(fn seq-hor[a-sum a-seq]\n\t(letfn [(do-select [a-seq a-sum cur-sum]\n\t\t\t\t(if (>= a-sum cur-sum)\n\t\t\t\t\t(let [el (first a-seq)]\n\t\t\t\t\t\t\n\t\t\t\t\t\t\t(cond (coll? el)    (let [[filtered-el next-sum] (do-select el a-sum cur-sum)\n\t\t\t\t\t\t\t\t\t\t\t\t\t  [tail-seq last-sum] (do-select (rest a-seq) a-sum next-sum)]\n\t\t\t\t\t\t\t\t\t\t\t\t\t[(cons filtered-el tail-seq) last-sum]\n\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t (not= nil el)  ( let [next-sum (+ cur-sum el)] \n\t\t\t\t\t\t\t\t\t\t\t\t\t(if (> next-sum a-sum)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t;skip element\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t['() next-sum]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t; append element to selected sequence\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(let [[tail-seq last-sum] (do-select (rest a-seq) a-sum next-sum)]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t[(cons el tail-seq) last-sum]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t:else\t\t\t['() cur-sum]\t\t\t\t\t\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t\t['() cur-sum]\n\t\t\t\t)\n\t\t\t)]\n\t\t(let [[result last-sum] (do-select a-seq a-sum 0)]\n\t\t\tresult\n\t\t)\n\t)\n)", "problem": 112, "user": "52763696e4b03e8d9a4a74d7"}, {"code": "(fn seqs\n  ([n ls] (seqs n ls [] 0))\n  ([n ls acc sum]\n     (cond (or (> sum n) (empty? ls)) acc\n           (coll? (first ls))\n           (let [nested (seqs n (first ls) [] sum)]\n             (seqs n (rest ls) (conj acc nested) (+ sum (reduce + (flatten nested)))))\n           (<= (+ sum (first ls)) n)\n           (seqs n (rest ls) (conj acc (first ls)) (+ sum (first ls)))\n           :else acc)))", "problem": 112, "user": "5301157ae4b0d8b024fd3717"}, {"code": "#(let [n (atom 0)]\n  ((fn f [x]\n    (if (or (> @n %) (nil? x))\n        '()\n        (if (coll? x)\n          (remove nil? (cons (f (first x))\n                             (f (next x))))\n          (do (swap! n + x)\n            (if (<= @n %)\n              x))))) %2))", "problem": 112, "user": "529b44afe4b02ebb4ef7509d"}, {"code": "(fn take-elts [n [x & xs]]\n             (cond\n               (nil? x ) '()\n               (vector? x) (let [x (take-elts n x) n (- n (reduce + (flatten x)))] (when x (cons x (take-elts n xs))))\n               (< n x) '()\n               :else (cons x (take-elts (- n x) xs))\n               ) \n     )", "problem": 112, "user": "52dc2bc8e4b09f7907dd13ca"}, {"code": "(fn [n c]\n  (let [s (atom 0)]\n    (into []\n      (clojure.walk/postwalk \n        #(if (coll? %)\n          (not-empty (remove nil? %))\n          (when (<= (swap! s + %) n) %) \n        )\n        (take 100 c)\n      )\n    )      \n  )  \n)", "problem": 112, "user": "5176afd2e4b085adf681d889"}, {"code": "#(let [f first\n       l (fn i [n c]\n           (cond\n            (empty? c) [n ()]\n            (coll? (f c)) (let [[rn rc] (i n (f c))]\n                            (if-not (zero? rn) (let [[rn rc2] (i rn (rest c))]\n                                                 [rn (cons rc rc2)])\n                                    [rn (list rc)]))\n            (<= (f c) n) (let [[rn rc] (i (- n (f c)) (rest c))]\n                           [rn (cons (f c) rc)])\n            :else [0 ()]))]\n   (second (l % %2)))", "problem": 112, "user": "52c25645e4b07a9af579237d"}, {"code": "(fn r [n coll] \n  (if-let [[h & m] (seq coll)]\n    (cond\n     (coll? h) (list (r n h))\n     (> h n) '()\n     :else (cons h (r (- n h) m)))\n    coll))", "problem": 112, "user": "532347dde4b09d4e7a9b54cc"}, {"code": "(fn f [ limit coll]\n  (let [seqsum (fn seqsum [slimit scoll ]\n                 (loop [l slimit [hr & rs] scoll r []]\n                   (println hr)\n                   (cond\n                     (nil? hr) [l r]\n                     (coll? hr) (let [[new-l new-r] (seqsum l hr)]\n                                     (if (< new-l 0)\n                                       [new-l (conj r new-r)]\n                                       (recur new-l rs (conj r new-r))))\n                     :else (let [new-l (- l hr)]\n                             (if (< new-l 0)\n                               [new-l r]\n                               (recur new-l rs (conj r hr)))))))]\n    (second (seqsum limit coll))))", "problem": 112, "user": "518c5236e4b087e178201de0"}, {"code": "(fn [n sq]\n  (letfn [(le [n sq s]\n    (loop [[x & xs] sq result [] sum s]\n      (cond (or (nil? x)) [result sum]\n            (sequential? x) \n              (let [[subsq new-sum] (le n x sum)]\n                (recur xs (if (empty? subsq) result (conj result subsq)) new-sum))\n            (> (+ sum x) n) [result sum]\n            :else (recur xs (conj result x) (+ sum x)))))]\n  (first (le n sq 0))))", "problem": 112, "user": "53300924e4b019098a6f8b55"}, {"code": "(fn take-nested [sum coll]\n  (lazy-seq\n   (if (>= sum 0)\n     (when-first [f coll]\n       (cond\n        (sequential? f)\n        (let [inner (take-nested sum f)\n              remaining (- sum (reduce + (flatten inner)))]\n          (cons inner (take-nested remaining (rest coll))))\n\n        (<= f sum)\n        (cons f (take-nested (- sum f) (rest coll))))))))", "problem": 112, "user": "5326c5f7e4b09d4e7a9b54f2"}, {"code": "(fn [max-sum coll]\n  (letfn [(step [coll current-sum max-sum]\n            (if (seq coll)\n              (let [head (first coll)]\n                (if (coll? head)\n                  (let [sub (step head current-sum max-sum)\n                        next-sum (+ current-sum (reduce + (flatten sub)))]\n                    (if (<= next-sum max-sum)\n                      (cons sub (step (next coll) next-sum max-sum))\n                      sub))\n                  (let [next-sum (+ head current-sum)]\n                    (if (<= next-sum max-sum)\n                      (cons head (step (next coll) next-sum max-sum))\n                      []))))))]\n    (step coll 0 max-sum)))", "problem": 112, "user": "50436470e4b034ff00315d23"}, {"code": "(fn sequs-horribilis\n  [n coll]\n  (letfn [(traverse [c sum max]\n            (cond\n             (nil? (seq c)) [nil sum]\n             (coll? (first c))\n                 (let [[r sum] (traverse (first c) sum max)]\n                     (vector (list r) sum))\n             (<= (+ (first c) sum) max)\n                 (let [[r sum] (traverse (next c) (+ (first c) sum) max)]\n                   (vector (cons (first c) r) sum))\n             :else [nil sum]\n             ))]\n    (vec (first (traverse coll 0 n)))))", "problem": 112, "user": "4edf5dc6535d10e5ff6f5340"}, {"code": "(fn horribilis [c [h & t]]\n  (cond\n   (nil?  h)     []\n   (coll? h)     [(horribilis c h)]\n   (< (- c h) 0) []\n   :else         (cons h (horribilis (- c h) t))))", "problem": 112, "user": "52d2ca1ce4b099d49816f0b4"}, {"code": "(fn* seqh [n x]\n  (loop [r [] s x i n]\n    (if (empty? s)\n      r\n      (let [f (first s)]\n        (if (coll? f)\n          (let [c (seqh i f) ii (- i (reduce + (flatten c)))]\n            (if (< ii 0)\n              r\n              (recur (conj r c) (rest s) ii)))\n          (let [ii (- i f)]\n            (if (< ii 0)\n              r\n              (recur (conj r f) (rest s) ii))))))))", "problem": 112, "user": "53468f6ce4b084c2834f4a3f"}, {"code": "(fn f\n  ([n l] (f [] n l))\n  ([v n l]\n     (let [a (first l)]\n       (if (coll? a)\n         (let [b (f [] n a)]\n           (if (empty? b)\n             v\n             (f (conj v b) (apply - n (flatten b)) (rest l))))\n         (if (or (nil? a) (< n a))\n           v\n           (f (conj v a) (- n a) (rest l)))))))", "problem": 112, "user": "53460d02e4b084c2834f4a39"}, {"code": "(fn sequs [n xs]\n  (lazy-seq\n   (when-let [[x & xs] (seq xs)]\n     (if (number? x)\n       (when (>= n x)\n         (cons x (sequs (- n x) xs)))\n       (let [h (sequs n x)\n             n (->> (flatten h)\n                    (apply +)\n                    (- n))]\n         (cons h (sequs n xs)))))))", "problem": 112, "user": "532ab0bde4b09d4e7a9b5527"}, {"code": "(fn f [n l]\n  (if (empty? l)\n    '()\n    (if (coll? (first l))\n      (let [ret (f n (first l))\n            sum (reduce (fn g [r e] (if (coll? e) (+ r (reduce g 0 e)) (+ r e) )) 0 ret)]\n        (cons ret (f (- n sum) (next l))))\n      (if (neg? (- n (first l)))\n        '()\n        (cons (first l) (f (- n (first l)) (next l)))))))", "problem": 112, "user": "5349ac2be4b084c2834f4a67"}, {"code": "(fn f [n col]\n    (let [hf1 (fn hf1 [ccol sum res]\n                  (if (empty? ccol)\n                      (hash-map :sum sum\n                                :res res)\n                      (if  (coll? (first ccol))\n                           (let [cres (hf1 (first ccol) sum [])\n                                 csum (:sum cres)\n                                 clist (:res cres)]\n                               (if   (<= csum n)\n                                     (hf1 (rest ccol)\n                                          csum\n                                          (conj res clist))\n                                     (hash-map :sum sum\n                                               :res res)))\n                           (let [csum (+ (first ccol) sum)]\n                               (if   (<= csum n)\n                                     (hf1 (rest ccol)\n                                          csum\n                                          (conj res (first ccol)))\n                                     (hash-map :sum sum\n                                               :res res))))))\n          fst (first (flatten col))]\n        (if (> fst n)\n            []\n            (:res (hf1 (rest col) fst (vector (first col)))))))", "problem": 112, "user": "528a3e14e4b0239c8a67ae72"}, {"code": "(fn horribilis [n s]\n  (letfn [(short-circuiting-reduce [f i c]\n                   (loop [result i, last-result (gensym), cc c]\n                     (if (or (empty? cc) (= result last-result))\n                       result\n                       (recur (f result (first cc)) result (rest cc)))))]\n    (short-circuiting-reduce (fn [result e]\n               (let [t (reduce + (flatten result))]\n                 (if (number? e)\n                   (if (> (+ t e) n)\n                     result\n                     (conj result e))\n                   (conj result (horribilis (- n t) e)))))\n             [] s)))", "problem": 112, "user": "5341b141e4b00652c8746ecf"}, {"code": "(fn !\n  ([limit coll]\n     (! limit coll [] 0))\n  ([limit coll result sum]\n     (if (empty? coll)\n       result\n       (let [first-item (first coll)]\n         (if (integer? first-item)\n           (let [after-sum (+ sum first-item)]\n             (if (> after-sum limit)\n               result\n               (! (- limit first-item)\n                  (rest coll)\n                  (conj result first-item)\n                  (+ sum first-item))))\n           (conj result\n                 (! limit\n                    first-item)))))))", "problem": 112, "user": "5225271fe4b01819a2de42f9"}, {"code": "(fn sequs-horribilis [n c]\n  (if (true? (instance? clojure.lang.LazySeq c))\n    ((fn [n c]\n       (loop [sum 0, c1 c, result []]\n         (if (<= n (+ sum (first c1)))\n           result\n           (recur (+ sum (first c1)) (rest c1) (conj result (first c1)))\n           )))\n     n c)    \n    (let [nums (atom [])\n          walk1 (fn [x]\n                  (if (number? x)\n                    (let [sum (reduce + @nums)]\n                      (if (<= (+ sum x) n)\n                        (swap! nums conj x))))\n                  x)\n          walk2 (fn walk2 [nums c]\n                  (loop [c1 c,  r {:n nums, :d []}]\n                    (if (empty? c1)\n                      r\n                      (let [x (first c1)]\n                        (if (number? x)\n                          (if (not (empty? (r :n)))\n                            (recur \n                              (rest c1) \n                              (assoc r :n (rest (r :n)) :d (conj (r :d) x)))\n                            (recur \n                              (rest c1)\n                              (assoc r :n (rest (r :n)))))\n                          (let [r1 (walk2 (r :n) x)\n                                n1 (r1 :n)\n                                d1 (r1 :d)]\n                            (recur\n                              (rest c1)\n                              (assoc r :n n1 :d (if (empty? d1) \n                                                  (r :d) \n                                                  (conj (r :d) (r1 :d))\n                                                  ))))\n                          )))))\n          walk-lazy (fn [n c]\n                      (loop [sum 0, c1 c, result []]\n                        (if (< n sum)\n                          result\n                          (recur (+ sum (first c1)) (rest c1) (conj result (first c1)))\n                          )))\n          _ (clojure.walk/prewalk #(walk1 %) c)]\n      ((walk2 @nums c) :d)\n      )))", "problem": 112, "user": "52cf084ce4b07d0d72b27399"}, {"code": "(fn sequs- [n coll]\n  (let [sum (atom 0)]\n    (letfn [(f [[x & xs]]\n              (cond\n               (coll? x) (cons (f x) (f xs))\n               (and (number? x) (<= (swap! sum #(+ x %)) n)) (cons x (f xs))\n               :else '()))]\n      (f coll))))", "problem": 112, "user": "4dad76588e77d6ed63f12a44"}, {"code": "(fn x [max coll]\n  (let [sum (fn [n] (if (sequential? n) (apply + (flatten n)) n))]\n    (loop [visited []\n           unvisited coll]\n      (if (empty? unvisited)\n        visited\n        (let [current-sum (sum visited)\n              next (if (integer? (first unvisited)) \n                     (first unvisited)\n                     (x (- max current-sum) (first unvisited)))]\n          (if (< max (+ current-sum (sum next)))\n            visited\n            (recur (conj visited next) (rest unvisited))))))))", "problem": 112, "user": "53513d28e4b084c2834f4ae3"}, {"code": "(letfn [(g [mx n s]\n           (cond\n            (empty? s) [n []]\n            (> n mx) [n []]\n            (coll? (first s)) (let [[k ss] (g mx n (first s))]\n                                (if (> k mx)\n                                  [k [ss]]\n                                  (let [[kk sss] (g mx k (rest s))]\n                                    [kk (if (empty? sss)\n                                          [ss]\n                                          (cons [ss] sss))])))\n            :else (if (> (+ n (first s)) mx)\n                    [(+ n (first s)) []]\n                    (let [[k ss] (g mx (+ n (first s)) (rest s))]\n                      [k (cons (first s) ss)]))))]\n   (fn f [n s]\n     (let [[k ss] (g n 0 s)]\n       ss)))", "problem": 112, "user": "53224d45e4b09d4e7a9b54c0"}, {"code": "(fn horr\n  [n coll & sum]\n  (let [m (if (nil? (first sum)) 0 (first sum))]\n    (lazy-seq\n      (when-let [s (seq coll)]\n        (if (or (empty? s) (> m n))\n          '()\n          (let [f (first s)]\n            (if (coll? f)\n              [(horr n f m)]\n              (if (> (+ f m) n)\n                '()\n                (cons f (horr n (rest s) (+ f m))))\n              )))))))", "problem": 112, "user": "5348cab4e4b084c2834f4a5e"}, {"code": "(fn sequs-horribilis\n  [limit init]\n  (loop [[fst & rst] init\n         acc []]\n    (let [sum (reduce + (flatten acc))\n          next-value (-> [fst] flatten first)]\n      (cond\n        (nil? fst) acc\n        (> (+ sum next-value) limit) acc\n        :else (let [next-item (if (number? fst) fst\n                                (sequs-horribilis (- limit sum) fst))]\n                (recur rst\n                       (conj acc next-item)))))))", "problem": 112, "user": "537caf68e4b06839e8705e7b"}, {"code": "(fn seq-analyze [n [x & xs]]\n  (letfn [(sum-all [[x & xs]]\n                   (cond (nil? x) 0\n                         (number? x) (+ x (sum-all xs))\n                         :else (+ (sum-all x) (sum-all xs))))]\n    (cond (nil? x) nil\n          (number? x) (if (> x n)\n                        '()\n                        (cons x (seq-analyze (- n x) xs)))\n          :else (let [y (seq-analyze n x)]\n                  (cons y (seq-analyze (- n (sum-all y)) xs))))))", "problem": 112, "user": "536ca4bde4b0fc7073fd6e49"}, {"code": "(letfn [(R [s] ())\n\n        (X [n s P Q]\n          (cond (empty? s)\n                (P n s)\n\n                (coll? (first s))\n                (X n (first s)\n                   (fn [n' a']\n                     (X n' (rest s)\n                        (fn [n'' a'']\n                          (P n'' (cons a' a'')))\n                        (fn [a'']\n                          (Q (cons a' a'')))))\n                   (fn [a']\n                     (Q (cons a' (R (rest s))))))\n\n                (>= n (first s))\n                (X (- n (first s)) (rest s)\n                   (fn [n' a']\n                     (P n' (cons (first s) a')))\n                   (fn [a']\n                     (Q (cons (first s) a'))))\n\n                :else (Q (R (rest s)))))\n\n        (T [n s]\n          (X n s\n             (fn [n' s'] s')\n             (fn [s'] s')))]\n  \n  T)", "problem": 112, "user": "51a4416ae4b0def3c5c5868c"}, {"code": "(fn [n s]\n    (let [f (fn f[acc x]\n              (cond \n               (:done acc) acc\n               (number? x)\n               (if (> (+ x (acc :num)) n)\n                 (assoc acc :done true)\n                 (let [acc (update-in acc [:num] + x )]\n                   (update-in acc [:tree] conj x)))\n               :else \n               (let [{:keys [tree num done]}\n                     (reduce f {:num (acc :num) :tree []} x)\n                     acc (assoc acc :num num)\n                     acc (assoc acc :done done)]\n                 (update-in acc [:tree] conj tree))))]\n      (->> (reductions f {:num 0 :tree []} s)\n           (drop-while #(and (not (:done %)) (not= s (:tree %))))\n           first\n           :tree)))", "problem": 112, "user": "53956118e4b0b51d73faaed6"}, {"code": "; incomplete, I can make a unit test for this that fails\n\n(fn hor [n [h & t]]\n    (cond\n      (nil? h) '()\n      (coll? h) (list (hor n h))\n      (>= n h) (cons h (hor (- n h) t))\n      :else '()))", "problem": 112, "user": "4f849f76e4b033992c121c36"}, {"code": "(fn [a b]\n  (second ((fn f3 [a [bf & br]]\n             (letfn [(f [[c r] b]\n                       (if (number? b)\n                         (let [c- (- c b)]\n                           (if (< c- 0)\n                             [c- r]\n                             [c- (conj r b)]))\n                         (let [[cc rr] (f3 [c []] b)]\n                           (if (empty? rr)\n                             [cc r]\n                             [cc (conj r rr)]))))]\n               (if (or (nil? bf) (< (first a) 0))\n                 a\n                 (f3 (f a bf) br)))) [a []] b)))", "problem": 112, "user": "50ae0d24e4b0a40c9cfb08ce"}, {"code": "(fn f [n xs]\n  (if (empty? xs) '()\n    (let [x (first xs) xs' (rest xs)]\n      (if (coll? x) (list (f n x))\n        (if (> x n) '() (cons x (f (- n x) xs')))))))", "problem": 112, "user": "508157b2e4b0946d0443855c"}, {"code": "(fn [limit xs]\n  (letfn [(helper [[limit] xs]\n            (if (sequential? xs)\n              (let [rs (take-while #(<= 0 (first %)) (reductions helper [limit] xs))]\n                [(first (last rs)) (map second (rest rs))])\n              [(- limit xs) xs]))]\n  (second (helper [limit] xs))))", "problem": 112, "user": "530bf87ee4b02e82168697d5"}, {"code": "(fn sequs [n coll]\n  (loop [n n, [f & r] (seq coll), result []]\n    (cond\n      (nil? f)\n      result\n      (sequential? f)\n      (let [sum (apply + (flatten f))]\n        (if (> n sum)\n          (recur (- n sum) r (conj result f))\n          (conj result (sequs n f))))\n      (> f n)\n      result\n      :else\n      (recur (- n f) r (conj result f)))))", "problem": 112, "user": "539a2901e4b0b51d73faaf0f"}, {"problem": 112, "code": "(fn f [n [h & t]]\n  (lazy-seq\n   (when h\n     (cond\n      (coll? h)  (cons (f n h)\n                       (f (- n\n                             (apply + (flatten (f n h))))\n                          t))\n      (<= h n)   (cons h\n                       (f (- n h) t))\n      1          nil))))", "user": "51ad244fe4b09397d510977f"}, {"problem": 112, "code": "(fn [n lst]\n  (let [v (last (loop [x (take 50 (flatten lst)) res []]\n                  (if (empty? x) res\n                    (recur (rest x) (if (<= (+ (first x) (reduce + res)) n)\n                                      (conj res (first x))\n                                      res)))))]\n    (letfn [(rec [l]\n                 (cond (empty? l) ()\n                       (not (vector? (first l))) (if (or (nil? v) (> (first l) v))\n                                                   ()\n                                                   (cons (first l) (rec (rest l))))\n                       :else (cons (rec (first l)) (rec (rest l)))))]\n      (rec lst))))", "user": "53a1b5c8e4b0ca733b9744c1"}, {"problem": 112, "code": "(fn sequs [n s]\n    (loop [cur []\n           [f & r] s\n           n n]\n      (if (integer? f)\n\t(if (< n f)\n\t cur\n\t (recur (conj cur f) r (- n f)))\n\t(if (empty? f)\n\t cur\n\t (let [others (sequs n f)]\n\t   (if (not (empty? others))\n\t     (conj cur others)\n\t     cur))))))", "user": "536f871de4b0fc7073fd6e7f"}, {"problem": 112, "code": "(fn [n coll]\n  (letfn [(f [n coll]\n    (loop [[x & xs :as c] coll\n           i n\n           acc []]\n      (cond\n        (empty? c) [i acc]\n        (coll? x) (let [[i' acc'] (f i x)]\n                   (recur xs i' (conj acc acc')))\n        (> x i) [0 acc]\n        :else (recur xs (- i x) (conj acc x)))))]\n    (second (f n coll))))", "user": "4faf97d8e4b081705acca258"}, {"problem": 112, "code": "(fn sequs- [n coll]\n  (let [sum (atom 0)]\n    (letfn [(f [[x & xs]]\n              (cond\n               (coll? x) (cons (f x) (f xs))\n               (and (number? x) (<= (swap! sum #(+ x %)) n)) (cons x (f xs))\n               :else '()))]\n      (f coll))))", "user": "5307e4ece4b02e82168697a9"}, {"problem": 112, "code": "(fn sh \n  ([up c ret]\n   (if-let [sq (seq c)]\n     (if (number? (first sq))\n       (if (< up (first sq))\n         ret\n         (sh (- up (first sq)) (rest sq) (conj ret (first sq))))\n       (conj ret (sh up (first sq) [])))\n     ret))\n  ([up c]\n   (sh up c [])))", "user": "4f041de1535dcb61093f6ba5"}, {"problem": 112, "code": "(fn [n l]\n(first\n((fn sequs-horribilis\n[n [x & xs]]\n(cond\n(nil? x) [x n]\n(coll? x) (let [[y m] (sequs-horribilis n x)\n[z l] (sequs-horribilis m xs)]\n[(cons y z) l])\n:else (if (<= x n)\n(let [[y m] (sequs-horribilis (- n x) xs)]\n[(cons x y) m])\n['() n]))) n l)))", "user": "53976599e4b0b51d73faaeea"}, {"problem": 112, "code": "(fn sequs\n  ([limit s] (sequs limit s 0))\n  ([limit s current-sum]\n   (if s\n     (let [current-element (first s)\n           rest-of-the-elements (next s)]\n       (if (coll? current-element)\n         (let [sub-list (sequs limit current-element current-sum)\n               new-sum (+ current-sum (reduce + (flatten sub-list)))]\n           (if (<= new-sum limit)\n             (cons sub-list (sequs limit rest-of-the-elements new-sum))\n             '()\n             ))\n         (let [new-sum (+ current-element current-sum)]\n           (if (<= new-sum limit)\n             (cons current-element (sequs limit rest-of-the-elements new-sum))\n             '()\n             ))))\n     '()\n     )))", "user": "53527551e4b084c2834f4af0"}, {"problem": 112, "code": "(fn\n  [n coll]\n  (letfn [(r [residue a coll]\n            (if (nil? residue)\n              [residue a]\n              (if (seq coll)\n                (let [h (first coll)\n                      t (rest coll)]\n                  (if (coll? h)\n                    (let [[residue' coll] (r residue [] h)]\n                      (recur residue' (conj a coll) t))\n                    (if (<= h residue)\n                      (recur (- residue h) (conj a h) t)\n                      (recur nil a t))))\n                [residue a])))]\n    (let [[_ coll'] (r n [] coll)]\n      coll')))", "user": "52dfc89be4b09f7907dd1405"}, {"problem": 112, "code": "(fn take-sum-to [n coll]\n   (letfn [(tk [n coll]\n              (loop [n n c [] [f & r] coll]\n\t\t\t\t(cond (nil? f) [n c]\n\t\t\t\t      (sequential? f) (let [[n cf] (tk n f)]\n\t\t\t\t                        (if (empty? cf)\n\t\t\t\t                            [n c]\n\t\t\t\t                            (recur n (conj c cf) r)))\n\t\t\t\t      :else (let [n (- n f)]\n\t\t\t\t              (if (>= n 0)\n\t\t\t\t                  (recur n (conj c f) r)\n\t\t\t\t                  [-1 c])))))]\n      (second (tk n coll))))", "user": "53b39d82e4b047364c0444a6"}, {"problem": 112, "code": "(fn sequs [n xs]\n  (concat [] \n          ((fn horribilis [n sum [h & r :as l]]\n             (if (coll? h)\n               (conj [] (horribilis n sum h))\n                 (if (and h (<= (+ sum h) n))\n                   (cons h (horribilis n (+ sum h) r))))) n 0 xs)))", "user": "50c781bbe4b00bb60fe0c535"}, {"problem": 112, "code": "(fn [limit tree]\n  (second\n  ((fn iter [limit tree]\n     (loop [l limit\n            t tree\n            result []]\n       (if\n         (empty? t)\n         [l result]\n         (let [[t-head & t-tail] t]\n           (if\n             (coll? t-head)\n             (let [[new-l t-head-processed] (iter l t-head)\n                   new-result (if\n                                (empty? t-head-processed)\n                                result\n                                (conj result t-head-processed))]\n               (recur \n                 new-l\n                 t-tail\n                 new-result))\n             (let [new-l (- l t-head)]\n               (if \n                 (< new-l 0)\n                 (recur \n                   new-l\n                   []\n                   result)\n                 (recur\n                   new-l\n                   t-tail\n                   (conj result t-head)))))))))\n   limit tree)))", "user": "53c38b8ce4b00fb29b22127b"}, {"problem": 112, "code": "(fn [n s]\n  (loop [t 0\n         rs s\n         rs-stack []\n         acc []\n         acc-stack []]\n    (if (empty? rs)\n      (if (empty? rs-stack)\n        acc\n        (recur t (peek rs-stack) (pop rs-stack)\n               (conj (peek acc-stack) acc) (pop acc-stack)))\n      (if (> t n)\n        (recur t [] rs-stack acc acc-stack)\n        (let [head (first rs)\n              tail (rest rs)]\n          (if (sequential? head)\n            ;; deal with seq\n            (recur t head (conj rs-stack tail) [] (conj acc-stack acc))\n            ;; not seq\n            (if (<= (+ t head) n)\n              (recur (+ t head) tail rs-stack (conj acc head) acc-stack)\n              (recur (+ n 1) tail rs-stack acc acc-stack))\n            ))))))", "user": "53c1ce3ee4b00fb29b221268"}, {"problem": 112, "code": "(fn horribilis [u s]\n  (cond (empty? s) []\n        (coll? (first s)) [(horribilis u (first s))]\n        (< u (first s)) []\n        :else (cons (first s) (horribilis (- u (first s))\n                                          (rest s)))))", "user": "53acaf1fe4b047364c04445f"}, {"problem": 112, "code": "(fn horribilis [n s]\n              (loop [init s r 0 result []]\n                (if (empty? init)\n                  result\n                  (if (sequential? (first init))\n                    (recur (rest init) \n                           (+ r (apply + (flatten (horribilis (- n r) (first init))))) \n                           (conj result (horribilis (- n r) (first init))))\n                    (if (> (+ (first init) r) n)\n                      result\n                      (recur (rest init) (+ (first init) r) (conj result (first init))))))))", "user": "532727bae4b09d4e7a9b54fa"}, {"problem": 112, "code": "(fn horrible [n coll]\n  (loop [bag [] remaining coll limit n total 0 done false]\n    (let [thing (first remaining) stuff (rest remaining)] \n      (cond\n       done bag\n       (integer? thing) (if (<= (+ thing total) limit)\n                          (recur (conj bag thing)\n                                 stuff\n                                 limit\n                                 (+ thing total)\n                                 false)\n                          (recur bag remaining limit total true))\n       (sequential? thing) (let [subset (horrible (- limit total) thing)\n                                 subtot (apply + (flatten subset))]\n                             (if (<= (+ subtot total) limit)\n                               (recur (conj bag subset)\n                                      stuff\n                                      limit\n                                      (+ subtot total)\n                                      false)\n                               (recur bag remaining limit total true)))\n        :else bag))))", "user": "53bf0913e4b0c98a41f5cc99"}, {"problem": 112, "code": "(letfn [(t [num lst]\n  (let [f (first lst)]\n    (cond (empty? lst) ()\n          (sequential? f) (let [sum (apply + (flatten f))\n                                dif (- num sum)]\n                            (if (<= sum num)\n                              (cons (lazy-seq (t num f))\n                                    (lazy-seq (t dif (rest lst))))\n                              (cons (lazy-seq (t num f)) ())))\n          (<= f num) (cons f (lazy-seq (t (- num f) (rest lst))))\n          :else ())))]\n  t)", "user": "538e36c7e4b0b51d73faae81"}, {"problem": 112, "code": "(fn sh [n coll]\n  (if (seq coll)\n    (let [x (first coll)]\n      (if (integer? x)\n        (if (> x n)\n          '()\n          (cons x (sh (- n x) (rest coll))))\n        (let [processed-coll (sh n x)\n              coll-sum (apply + (flatten processed-coll))]\n          (cons processed-coll (sh (- n coll-sum) (rest coll))))))\n    '()))", "user": "529e3a4fe4b04e0c58e87b92"}, {"problem": 112, "code": "(fn sh [x s] \n\t(first ((fn sh [n [h & t]]\n\t(if (nil? h)\n\t\t[() n]\n\t\t(if (sequential? h)\n\t\t\t(let [[hl hn] (sh n h)\n\t\t\t\t  [tl tn] (if (> hn n) (sh (- n hn) t) [() 0])]\n\t\t\t\t[(cons hl tl) tn])\n\t\t\t(if (> h n) \n\t\t\t\t[() 0]\n\t\t\t\t(let [[nl nn] (sh (- n h) t)]\n\t\t\t\t\t[(cons h nl) nn]))))) x s)))", "user": "53e19461e4b0d874e779ae59"}, {"problem": 112, "code": "(letfn [\n          (seq-hor\n            [n shor acc]\n            ;(println \"n: \" n \"shor: \" shor \"acc: \" acc)\n            (if (seq shor)\n              (let [hd (first shor)]\n                (cond \n                  (and (number? hd) (<= hd n)) (recur (- n hd) (rest shor) (conj acc hd))\n                  (and (number? hd) (> hd n)) acc ;(recur java.lang.Integer/MIN_VALUE (rest shor) acc)\n                  :else (conj acc (seq-hor n hd []))))\n              acc))\n          ]\n    (fn [n coll] (seq-hor n coll [])))", "user": "50eddbc4e4b06330c1f87c4b"}, {"problem": 112, "code": "(fn pr112f [limit coll]\n  (let [iter (fn iter [coll sum]\n               (if-let [sq (seq coll)]\n                 (let [fst (first sq) \n                       [front new-sum] (if (coll? fst) \n                                         (iter fst sum)\n                                         (if (<= (+ sum fst) limit)\n                                           [fst (+ sum fst)]\n                                           [nil false]))\n                       [back return-sum] (if new-sum\n                                           (iter (rest sq) new-sum)\n                                           [nil false])]\n                   [(if front \n                      (cons front (lazy-seq back))\n                      '()) \n                    return-sum])\n                 [nil sum]))]\n  (first (iter coll 0))))", "user": "51696ee7e4b03f62cda68ce8"}, {"problem": 112, "code": "(fn t112 \n  ([x coll] (t112 x coll []))\n  ([x coll ans]\n   (let [r (first coll)]\n     (cond\n       (sequential? r) (conj ans (t112 x (first coll) []))\n       (or (empty? coll) (> r x)) ans\n       :else (t112 (- x r) (rest coll) (conj ans r))))))", "user": "5046f909e4b03b02161376b5"}, {"problem": 112, "code": "(fn sus [x xs]\n    (if (and (seq xs) (<= 0 x))\n      (lazy-seq \n       (if (sequential? (first xs))\n         (let [next-depth (sus x (first xs))]\n           (cons next-depth (sus (apply - x (flatten next-depth)) (rest xs))))\n         (if (<= 0 (- x (first xs)))\n           (cons (first xs) (sus (- x (first xs)) (next xs))))))))", "user": "513e8141e4b02b2a3d8235c1"}, {"problem": 112, "code": "(fn f [limit [h & t]]\n   (cond\n    (nil? h) \t\t\t'()\n    (coll? h) \t\t\t(let [sub (f limit h)\n                              subTotal (apply + (flatten sub))]\n                          (cons sub (f (- limit subTotal) t)))\n    (< (- limit h) 0) \t'()\n    :else \t\t\t\t(cons h (f (- limit h) t))))", "user": "535eaa73e4b04ce2eb3ed2d4"}, {"problem": 112, "code": "(fn f [X S]\n   (first\n    ((fn g [x s]\n (let [partialSums (if (coll? s)\n                     (map #(apply + (flatten [%])) s)\n                     [s])\n       cumSums (reductions + partialSums)\n       rems (map #(- x %) cumSums)]\n   (cond\n    (coll? s) [(mapcat g (take-while #(>= % 0) (cons x rems)) s)]\n    (>= x s) [s]\n    :else []\n    )\n   )\n   )\n   X S)\n   )\n   )", "user": "53f6d555e4b0db01ade6f9e5"}, {"problem": 112, "code": "(fn peu [y x] (if (empty? x) '() (if (> 0 (- y (first (flatten x)))) '() (if (coll? (first x)) (cons (peu y (first x)) (peu (- y (apply + (flatten (first x)))) (rest x))) (cons (first x) (peu (- y (first x)) (rest x))) ))))", "user": "53fc8424e4b0de5c418485b3"}, {"problem": 112, "code": "(fn task-112 [n xs]\n  (second\n   ((fn f [n xs]\n      (if (neg? n) [n []])\n      (cond\n       (nil? (first xs)) [n xs]\n       (coll? (first xs))\n       (let [[r1 ys1] (f n (first xs))\n             [r2 ys2] (f r1 (rest xs))]\n         (if (neg? r1)\n           [r1 [ys1]]\n           [r2 (concat [ys1] ys2)]))\n       (<= (first xs) n)\n       (let [[r2 ys2] (f (- n (first xs)) (rest xs))]\n         [r2 (concat [(first xs)] ys2)])\n       (> (first xs) n) [n []]\n       )) n xs)))", "user": "4ddb696b535d02782fcbe9fa"}, {"problem": 112, "code": "(fn sequs [n main-coll]\n   (letfn [(inner-sequs [accum k coll]\n             (let [flattened (flatten coll)\n                   head (first coll)\n                   first-int (first flattened)]\n               (if (and first-int (<= first-int k))\n                 (if (integer? head)\n                   (inner-sequs (conj accum head) (- k head) (rest coll))\n                   (let [head-sum (apply + (flatten head))]\n                     (if (<= head-sum k)\n                       (inner-sequs (conj accum head) (- k head-sum) (rest coll))\n                       (conj accum (sequs k head)))))\n                 accum)))]\n     (inner-sequs [] n main-coll))\n)", "user": "53ed6976e4b0d648e757f4c4"}, {"problem": 112, "code": "(fn horribilis [total target]\n  (second\n   ((fn h-iter [t s]\n       (loop [[h & xs] (seq s) tally t acc []]\n         (cond\n          (nil? h) [tally acc]\n          (coll? h) (let [[c a] (h-iter tally h)]\n                      (recur xs c (conj acc a)))\n          (< (- tally h) 0) [(- tally h) acc]\n          :else (recur xs (- tally h) (conj acc h))))) total target)))", "user": "53c649d3e4b00fb29b221297"}, {"problem": 112, "code": "(fn sequs-horribilis\n  [limit coll]\n  (letfn [(sequs-horribilis* [sum res [x & xs :as coll]]\n            (if (seq coll)\n              (if (sequential? x)\n                (conj res (sequs-horribilis* sum []  x))\n                (if (<= (+ sum x) limit)\n                  (recur (+ sum x) (conj res x) xs)\n                  res))\n              res))]\n    (sequs-horribilis* 0 [] coll)))", "user": "53fd66a4e4b0de5c418485e3"}, {"problem": 112, "code": "(fn sequs [n sq]\n\t(letfn [(append-rst [pres sum [hd & tl]] \n\t\t\t\t\t\t(cond\n\t\t\t\t\t\t\t(coll? hd) \n\t\t\t\t\t\t\t\t(let [elem (sequs (- n sum) (vec hd))]\n\t\t\t\t\t\t\t\t\t(recur (conj pres elem) (apply + (flatten elem)) tl))\n\t\t\t\t\t\t\t(or (nil? hd) (> (+ sum hd) n )) pres\n\t\t\t\t\t\t\t:else (recur (conj pres hd) (+ sum hd) tl)))]\n\t\t(when-not (nil? sq)) (append-rst [] 0 sq)))", "user": "52e657e4e4b09f7907dd1472"}, {"problem": 112, "code": "#(first ((fn sh [n c]\n  (loop [[h & t] c\n         n n\n         res []]\n    (if (and h (>= n 0))\n      (if (coll? h)\n        (let [[rr rn] (sh n h)]\n          (recur t rn (conj res rr)))\n        (if (>= n h) (recur t (- n h) (conj res h))\n          [res n]))\n      [res n]))) %1 %2))", "user": "53f7820be4b0de5c41848560"}, {"problem": 112, "code": "(letfn [(horribilus                                                             \n          [n e]                                                                 \n          (if (number? e)                                                       \n            (horr-num n e)                                                      \n            (horr-sq n e)))                                                     \n        (horr-sq                                                                \n          [n tree]                                                              \n          (if (empty? tree)                                                     \n            [n ()]                                                              \n            (let [[n' e] (horribilus n (first tree))]                           \n              (if (or (number? e)                                               \n                      (seq e))                                                  \n                (let [[n'' tree'] (horr-sq n' (rest tree))]                     \n                  [n'' (cons e tree')])                                         \n                [n' ()]))))                                                     \n        (horr-num [n m]                                                         \n          (let [n' (- n m)]                                                     \n            (if-not (neg? n')                                                   \n              [n' m]                                                            \n              [0 ()])))]                                                        \n  (comp second horribilus))", "user": "51f9527fe4b09be9c177e549"}, {"problem": 112, "code": "#(let [rRemove (fn recursiveRemove[inputVec sum bound]\n                 (if (> sum bound) [sum []];just return an empty vector if the accumulated sum exceeds the bound\n                   (loop [v inputVec s sum r []]\n                     (if (seq v)\n                       (let [fv (first v)]\n                         (if (coll? fv)\n                           (let [[ss sr] (recursiveRemove fv s bound)]\n                             (recur (rest v) (+ s ss) (conj r sr)))\n                           (if (<= (+ s fv) bound)\n                             (recur (rest v) (+ s fv) (conj r fv))\n                             [s r])))\n                       [s r]))))\n       [s r] (rRemove %2 0 %1)]\n   r)", "user": "541619e8e4b01498b1a719f9"}, {"problem": 112, "code": "(fn [i cs]\n  (letfn [(s [i t cs]\n            (if-let [c (first cs)]\n              (if (coll? c)\n                [(s i t c)]\n                (if (<= (+ t c) i)\n                  (cons c (s i (+ t c) (rest cs)))\n                  ()))))]\n    (s i 0 cs)))", "user": "4ee4f4a9535d1385b2869d85"}, {"problem": 112, "code": "(fn f ([i s] (f i s []))\n      ([i [h & t] a]\n      (if (integer? h)\n        (if (>= i h)\n          (recur (- i h) t (conj a h))\n          a)\n        (if (coll? h)\n          (conj a (f i h))\n          a))))", "user": "51e28063e4b08e53a149f0f2"}, {"problem": 112, "code": "(fn sh [ub coll]\n  (let [result\n        (loop [outq '([][]), \n               inq (list (if (seq? coll) (lazy-seq coll) (reverse (into '() coll)))),\n               acc 0]\n          (cond (empty? inq) outq,\n                (> acc ub) outq ,\n                (number? (peek inq)) (recur (conj (pop outq) \n                                                  (conj (peek outq) (peek inq))) \n                                            (pop inq) acc),\n                (empty? (peek inq)) (recur (conj (pop (pop outq)) \n                                                 (conj (peek (pop outq)) (peek outq)))\n                                           (pop inq) acc),\n                (number? (first (peek inq))) (recur outq (conj (conj (pop inq) \n                                                                     (rest (peek inq))) \n                                                               (first (peek inq)))\n                                                    (+ acc (first (peek inq)))),\n                (coll? (first (peek inq))) (recur (conj outq '[]) (conj (conj (pop inq)\n                                                                              (rest (peek inq)))\n                                                                        (first (peek inq)))\n                                                  acc)))] \n    (first (reduce #(conj %2 %1) \n                   (if (and (empty? (peek result))\n                            (->> (pop result)\n                                 peek\n                                 empty?\n                                 not))\n                     (pop result) \n                     result)))))", "user": "53fcdd1ae4b0de5c418485dd"}, {"problem": 112, "code": "(fn [& rgs]\n    (let [zh (fn zh [acc o [s & ss]]\n               (cond (nil? s) [acc o]\n                     (number? s) (if (<= s o) (zh (conj acc s) (- o s) ss) [acc 0])\n                     (coll? s) (let [[acc2 o2] (zh [] o s)] (zh (conj acc acc2) o2 ss))))]\n      (first (apply zh [] rgs))))", "user": "5310e968e4b08068f379ecdd"}, {"problem": 112, "code": "(fn d [n [h & t :as s]] \n   (cond \n     (empty? s) [] \n     (coll? h)  [(d n h)]\n     (>= n h) (concat [h] (d (- n h) t))\n     :else []))", "user": "53a01fb1e4b0ca733b9744a6"}, {"problem": 112, "code": "(fn [sum coll]\n  (last\n   (take-while\n    #(>= sum (reduce + (flatten %)))\n    (\n     (fn redux\n       ([coll] (redux [] coll))\n       ([prefix [fst & rst]]\n         (cons\n          prefix\n          (if-not (nil? fst)\n            (concat\n             (if (sequential? fst)\n               (map #(conj prefix %) (lazy-seq (redux fst)))\n               )\n             (lazy-seq (redux (conj prefix fst) rst))\n             ))\n        ))\n       )\n     coll\n     )\n    )))", "user": "5281a445e4b0757a1b17143a"}, {"problem": 112, "code": "(fn sequs-horribilis\n  [n xs]\n  (let [hd (first xs)]\n    (cond\n     (nil? hd) []\n     (coll? hd) (let [nested (sequs-horribilis n hd)\n                      done (apply + (flatten nested))]\n                  (cons nested (sequs-horribilis (- n done) (rest xs))))\n     :else (if (<= hd n)\n             (cons hd (sequs-horribilis (- n hd) (rest xs)))\n             []))))", "user": "4ea5ba92535d7eef308072d9"}, {"problem": 112, "code": "(fn [n xs]\n  (letfn [(take-suming [n xs]\n            (loop [f (first xs)]\n              (if (sequential? f)\n                (list (take-suming n f))\n                (if (and (not= nil f) (>= n f))\n                  (let [x (- n f)\n                        r (rest xs)]\n                    (cons f (take-suming x r)))\n                  []))))]\n    (take-suming n xs)))", "user": "4ea365e2535d7eef308072c5"}, {"problem": 112, "code": "(fn fa [limit input-col]\n    (letfn [(f [cur-limit cur-input-col result]\n              (cond\n                (empty? cur-input-col) result\n                (sequential? (first cur-input-col)) (concat result (list (fa cur-limit (first cur-input-col))))\n                (<= (first cur-input-col) cur-limit) (f (- cur-limit (first cur-input-col))\n                                                        (rest cur-input-col)\n                                                        (concat result (list (first cur-input-col))))\n                :else result\n                  ))]\n           (f limit input-col '())))", "user": "525ed5f4e4b0cb4875a45db8"}, {"problem": 112, "code": "(fn seqhor [max-sum xs]\n\t(letfn [(traverse-list [sum elems stop]\n\t\t(loop [acc-sum sum acc-list [] stop stop [h & t] elems]\n\t\t\t\t(cond\n\t\t\t\t\tstop \n\t\t\t\t\t\t[acc-sum acc-list stop]\n\t\t\t\t\t(nil? h)\n\t\t\t\t\t\t[acc-sum acc-list stop]\n\t\t\t\t\t(coll? h)\n\t\t\t\t\t\t(let [[elem-sum elem-list elem-stop] (traverse-list acc-sum h stop)]\n\t\t\t\t\t\t\t(recur elem-sum (conj acc-list elem-list) elem-stop t))\n\t\t\t\t\t(> (+ h acc-sum) max-sum)\n\t\t\t\t\t\t[acc-sum acc-list true]\n\t\t\t\t\t:else\n\t\t\t\t\t\t(recur (+ acc-sum h) (conj acc-list h) false t))))]\n\t\t(second\n\t\t\t(traverse-list 0 xs false))))", "user": "54448e84e4b032a45b869393"}, {"problem": 112, "code": "(fn seqs-horribilis [n coll]\n  (if-let [item (first coll)]\n    (if (coll? item)\n      [(seqs-horribilis  n item)]\n      (if (> item n)\n        []\n        (cons item (seqs-horribilis (- n item) (rest coll)))))))", "user": "53f891eee4b0de5c4184856d"}, {"problem": 112, "code": "(fn sh [n [h & t]]\n   (cond\n    (nil? h) []\n    (coll? h)  [(sh n h)]\n    (>= n h) (concat [h] (sh (- n h) t))\n    :else []))", "user": "53ce4cd4e4b00fb29b2212ef"}, {"problem": 112, "code": "(fn x [n v]\n  (let [[f s] v]\n    (cond (nil? f) nil\n          (and (integer? f) (> f n)) []\n          true\n          (if (integer? f)\n              (into [f] (x (- n f) (rest v)))\n            [(x n (first v))]))))", "user": "53973e7be4b0b51d73faaee6"}, {"problem": 112, "code": "(fn [t ns]\n  (letfn [(go [s r ms]\n            (cond\n             (empty? ms) [s r]\n             (< t s) [s r]\n             :else\n             (let [m (first ms)\n                   ms' (rest ms)]\n               (if-not (coll? m)\n                 (if (< t (+ s m))\n                   [s r]\n                   (go (+ s m) (conj r m) ms'))\n                 (let [[s' r'] (go s [] m)]\n                   (if (<= t s')\n                     [s' (conj r r')]\n                     (go s' (conj r r') ms')))))))]\n    (second (go 0 [] ns))))", "user": "53ef7f77e4b0742d9025b0ce"}, {"problem": 112, "code": "(fn [n s]\n    (letfn [(prefixes [s] \n              (cond (integer? s) (list s) \n                    (empty? s) [] \n                    :else (lazy-seq (concat (map list (prefixes (first s))) \n                                            (map #(cons (first s) %) (prefixes (rest s)))))))\n            (sum [s] (if (integer? s) s (apply + (map sum s))))]\n      (last (take-while #(<= (sum %) n) (cons [] (prefixes s))))))", "user": "5457e5f1e4b01be26fd74613"}, {"problem": 112, "code": "(fn fu [n s]\n  (->> \n   (reductions\n     (fn x [r e]       \n       (if (coll? e)\n         (conj r (fu (- n (apply + (flatten r))) e))\n         (conj r e))) [] s)\n   (take-while #(>= n (apply + (flatten %))))\n   (last)))", "user": "51aefceee4b09397d5109797"}, {"problem": 112, "code": "(comp second (partial (fn f [s l c]\n                        (loop [[s c'] [s []] c c]\n                          (if (empty? c)\n                            [s c']\n                            (let [i (first c)\n                                  c (rest c)]\n                              (if (number? i)\n                                (if (> (+ s i) l)\n                                  [s c']\n                                  (recur [(+ s i) (conj c' i)] c))\n                                (let [[s' c''] (f s l i)]\n                                  (recur [s' (conj c' c'')] c)))))))\n                      0))", "user": "547d8e93e4b0c51c1f4d72f4"}, {"problem": 112, "code": "(fn g [s is]\n  (if (empty? is)\n    ()\n    (let [[f & r] is]\n      (cond\n        (sequential? f)\n          (cons (g s f)\n                (g (- s (->> is first flatten (apply +))) r))\n        (<= f s) (cons f (g (- s f) r))\n        :else ()))))", "user": "4ec1b090535dfed6da9c6db5"}, {"problem": 112, "code": "(fn [n l]\n  (letfn \n    ; give a tree, find total number of each node \n    [(lagua \n      [tree] \n      (if (not (sequential? tree)) [tree tree]\n        (let [mp (map lagua tree)\n              tot (reduce + (map second mp))]\n          [mp tot])\n        ))\n     \n     ; get list prefix so that the tot does not exceed the tot\n     (subtree \n      [tree tot]\n      (loop [curt tree\n             curtot tot\n             acc []]\n        (if (or (empty? curt) (< curtot 0)) acc\n          (let [lg (lagua (first curt))]\n            (recur (rest curt) (- curtot (second lg)) (concat acc [(first curt)]))\n            ))))\n     \n     ; positions of set pred in coll\n     (positions\n     [pred coll]\n     (keep-indexed (fn [idx x]\n                  (when (pred x)\n                    idx))\n                coll))\n     \n     ; give a numbered list and remaining, return the first x elements that adds up to >= remaining\n     ; each element has its quota (last is not full, before that it's the total)\n     (pucho \n      [treex tot]\n      (let [len  (count treex)\n            tots (map second treex)\n            sums (reverse (map #(reduce + (drop-last % tots)) (range len)))\n            nquota (map - (repeat len tot) sums)\n            quota (concat [tot] (drop-last nquota)) \n            adjq (map min tots quota) \n            ok   (map #(or %1 %2) (map #(> % 0) adjq) (map #(>= % 0) nquota))\n            posq (positions #{true} ok)\n            cutn (if (empty? posq) -1 (apply max posq))]\n        (if (< cutn 0) [-1 nil]\n          (let [nquot (nth adjq cutn)\n            \tnele (first (nth treex cutn))\n            \tncutn (if (and (not (sequential? nele)) (< nquot nele)) (dec cutn) cutn)]\n            [ncutn (nth adjq ncutn)]))\n            ))\n\n\t ; give a numbered tree (puhcoed), give the results)     \n     (guagua \n      [tree ltree quota]\n      (if (not (sequential? tree)) tree\n        (let [x (pucho ltree quota)\n              cutn (first x)\n              lq (second x)]\n          (if (< cutn 0) []\n            (let [qnode (nth tree cutn)]\n              (concat (take cutn tree) \n                      [(guagua qnode (first (lagua qnode)) lq)])\n              ))\n          )))]  \n    \n    (let [stree (subtree l n)]    \n      (guagua stree (first (lagua stree)) n)\n      )))", "user": "52faec2ee4b047fd55837004"}, {"problem": 112, "code": "(fn foo [n [f & r :as s]]\n  (cond\n   (empty? s) []\n   (coll? f) [(foo n f)]\n   (>= n f) (concat [f] (foo (- n f) r))\n    :else []))", "user": "544cf5d7e4b0e39780006977"}, {"problem": 112, "code": "(fn sequs-horriblis [n [x & r]]\n  (if x\n    (if (sequential? x)\n      (let [sub (sequs-horriblis n x)]\n        (cons sub (sequs-horriblis (- n (reduce + (flatten sub))) r)))\n      (if (<= x n)\n        (cons x (sequs-horriblis (- n x) r))\n        ()))))", "user": "5353afa0e4b084c2834f4b03"}, {"problem": 112, "code": "(fn __[a s]\n  (let[q (first s)]\n    (if q\n    (if-not (coll? q) \n      (if (>= a q) (cons q (lazy-seq (__ (- a q) (rest s)))) [])\n      (lazy-seq(vector (__ a q)))))))", "user": "52bbd09ee4b07a9af57922ee"}, {"problem": 112, "code": "(fn sqh [mx sqs]\n  (letfn [(sum [s]\n            (reduce\n              (fn [a n]\n                (if\n                  (coll? n) (+ a (sum n)) (+ a n)))\n              0\n              s))\n\n          (sum-seq-to [limit s]\n            (reverse (loop [a [] n (first s) s (rest s)]\n                       (cond\n                         (nil? n) a\n                         (coll? n) (cons (lazy-seq (sum-seq-to (- limit (sum a)) n)) a)\n                         (> (+ n (sum a)) limit) a\n                         :else (recur (cons n a) (first s) (rest s))))))\n]\n    (sum-seq-to mx sqs)))", "user": "4f724e56e4b07046d9f4f027"}, {"problem": 112, "code": "(fn sh [lim s]\n  (loop [[fi & re] s\n         l lim\n         acc []]\n    (if (coll? fi) (conj acc (sh l fi))\n      (if (or (nil? fi) (neg? (- l fi))) acc\n        (recur re (- l fi) (conj acc fi))))))", "user": "53e745a1e4b036ad0777e479"}, {"problem": 112, "code": "(fn pf [n c]\n    (when (seq c)\n      (let [fc (first c)]\n        (if (coll? fc)\n          (let [sub (pf n fc)]\n            (cons sub (pf (- n (apply + (flatten sub))) (rest c))))\n        (if (<= fc n)\n          (cons fc (pf (- n fc) (rest c)))\n          '())))))", "user": "545e9cf1e4b01be26fd7467f"}, {"problem": 112, "code": "(fn [n xs]\n  (letfn [(sh [n xs]\n            (if-let [[x & xs] (seq xs)]\n              (if (number? x)\n                (if (<= x n)\n                  (let [[xs* n*] (sh (- n x) xs)]\n                    [(cons x xs*) n*])\n                  ['() -1])\n\n                (let [[x*  n*] (sh n  x)\n                      [xs* n*] (sh n* xs)]\n                  [(cons x* xs*) n*]))\n              ['() n])\n            )]\n    (first (sh n xs))))", "user": "53dfdf01e4b0d874e779ae46"}, {"problem": 112, "code": "(fn  [n xs]\n  (letfn [(mk-ctx [q cur sum limit]\n            (if (coll? cur)\n              (let [pending (enqueue [] cur sum limit)\n                    new-sum (+ sum (reduce + (flatten pending)))]\n                {:queue (conj q pending) :sum new-sum})\n              {:queue (maybe-add-num q cur sum limit) :sum (+ sum cur)}))\n\n          (maybe-add-num [q cur sum limit]\n            (if (> (+ cur sum) limit) q (conj q cur)))\n\n          (enqueue [q xs sum limit]\n            (if (or (empty? xs) (> sum limit))\n              q\n              (let [cur (first xs)\n                    ctx (mk-ctx q cur sum limit)]\n                (recur (:queue ctx) (next xs) (:sum ctx) limit))))]\n    (enqueue [] xs 0 n)))", "user": "53bcdd41e4b0d9a98559a6c0"}, {"problem": 112, "code": "(fn [n s]\n\n  (letfn [(sequs [n s]\n\n   (loop [acc 0 v [] s s]\n\n     (if (or (empty? s) (< n acc))\n\n       [acc v] \n\n       (let [elt (first s)]\n\n   (if (vector? elt)\n\n       (let [[m t] (sequs (- n acc) elt)\n\n\t           newacc (+ acc m)]\n\n               (recur newacc  (if (empty? t) v (conj v t)) (rest s)))\n\n            (let [newacc (+ acc elt)]\n\n\t      (recur newacc (if (< n newacc) v (conj v elt)) (rest s))))))))]\n\n(second (sequs n s))))", "user": "54848141e4b0e286459a119e"}, {"problem": 112, "code": "(fn [n cs]\n    (letfn [(se [[f & r] a s]\n              (cond\n               (coll? f) (conj a (se f [] s) )\n               (or (nil? f) (> (+ f s) n)) a\n               :else (se r (conj a f) (+ f s))))]\n      (se cs [] 0)))", "user": "4f3ec266e4b0e243712b1f8c"}, {"problem": 112, "code": "(fn f [n s]\n  (cond (< n 0)\n        (list)\n\n        (coll? (first s))\n        (list (f n (first s)))\n\n        (number? (first s))\n        (let [x (first s)]\n          (if (> x n)\n            (list)\n            (cons (first s) (f (- n (first s))\n                               (rest s)))))\n  ))", "user": "54be7772e4b0ed20f4ff6eea"}, {"problem": 112, "code": "(fn [v coll]\n  (letfn [(f [v coll acc]\n             (if-let [h (first coll)]\n               (if (coll? h)\n                 (let [[n r] (f v h [])] (if (neg? n) [n (conj acc r)] (recur n (rest coll) (conj acc r))))\n                 (if (> h v) [-1 acc] (recur (- v h) (rest coll) (conj acc h))))\n               [v acc]))]\n    (second (f v coll []))))", "user": "5392bfdee4b0b51d73faaeb2"}, {"problem": 112, "code": "(fn __ [n xs]\n  (letfn [(f [n & xs]\n             (if (empty? xs) xs\n               (let [x (first xs), rs (rest xs)]\n                 (cond (coll? x) (list (apply f n x))\n                       (> x n) '()\n                       :else (cons x (apply f (- n x) rs))))))]\n    (apply f n xs)))", "user": "54c271b9e4b045293a27f602"}, {"problem": 112, "code": "#(last\n    ((fn f [l vs]\n       (loop [s l [x & xs] vs rs []]\n         (cond (or (nil? x) (< s 0)) [-1 rs]\n               (integer? x) (if (>= s x)\n                              (recur (- s x) xs (conj rs x))\n                              [-1 rs])\n               :else (let [[s' x'] (f s x)]\n                       (if (>= s' 0)\n                         (recur s' xs (conj rs x'))\n                         [-1 (conj rs x')])))\n         )) %1 %2))", "user": "54c641f8e4b045293a27f628"}, {"problem": 112, "code": "(fn f [n [a & b :as c]]\n  (cond\n    (empty? c) c\n    (coll? a) (let [r (f n a)\n                    s (reduce + (flatten r))]\n                (concat [r] (f (- n s) b)))\n    :else (if (<= a n)\n            (concat [a] (f (- n a) b))\n            [])))", "user": "54ca9ca8e4b057c6fda3a265"}, {"problem": 112, "code": "(fn q[n s]\n    (let [\n          s (take 100 s)\n          nc  \n          (fn [s n]\n            (loop [s s r []] \n              (if (seq s)\n                (if (> (second (first s)) n)\n                  (recur (rest s) (conj r (first s)))\n                  [r s]\n                  )   \n                [r s]\n                )   \n              )   \n            )   \n          mapIt\n          (fn mapIt[s n]\n            (loop [r [] s s]\n              (if (seq s)\n                (if (coll? (first s)) \n                  (recur (conj r (mapIt (first s) (+ n 1))) (rest s)) \n                  (recur (conj r (str (first s) \\= n))(rest s)) \n                  )   \n                r   \n                )   \n              )   \n            )   \n          mappedSeq\n          (map #(vec (map (fn [x] (Integer. x)) (clojure.string/split % #\"=\"))) (flatten (mapIt s 0)))\n          addTotals\n          (fn [s]\n            (loop [r [] s s t 0]\n              (if (seq s)\n                (recur (conj r (conj (first s) (+ t (first (first s))))) (rest s) (+ t (first (first s))))\n                r\n                ) \n              )\n            )   \n          withTotals\n          (addTotals mappedSeq)\n          numbersToUse\n          (vec (filter #(<= (nth % 2) n) withTotals))\n          final \n          (   \n           (fn q[s r n]\n             (loop [s s r r]\n               (let [num (first (first s)) val (second (first s))]\n                 (if (seq s)\n                   (if (< n val)\n                     (let [p (nc s n)]\n                       (recur (second p) (conj r (q (first p) [] (+ n 1))))\n                     ) \n                     (recur (vec (rest s)) (conj r num))\n                     )\n                   r\n                   )\n                 )\n               )\n             ) numbersToUse [] 0\n           )\n          ]\n      final   \n      )    \n    )", "user": "54b90836e4b0ed20f4ff6e9d"}, {"problem": 112, "code": "(fn mytake [n [x & xs]]\n  (cond\n    (nil? x) '()\n    (sequential? x) (list (mytake n x))\n    (< n x) '()\n    :else (cons x (mytake (- n x) xs))))", "user": "54b13a40e4b09f271ff37d1b"}, {"problem": 112, "code": "(fn seqs-horr\r\n  [i [a & r]]\r\n  (if a\r\n    (if (coll? a)\r\n      (list (seqs-horr i a))\r\n      (if (<= a i)\r\n        (conj (seqs-horr (- i a) r) a)\r\n        '()))\r\n    nil))", "user": "5470699ae4b00cfc9eacc1b6"}, {"problem": 112, "code": "(fn prob112b [n s]\n  (if (or (empty? s) (< n 0)) ()\n      (let [f (first s)]\n        (if (number? f)\n          (if (> f n) () (cons f (prob112b (- n f) (rest s))))\n          (let [f1 (prob112b n f)]\n            (cons f1 (prob112b (- n (apply + (flatten f1))) (rest s))))))))", "user": "54e3df6ae4b024c67c0cf7e3"}, {"problem": 112, "code": "(fn [max-sum coll]\n(letfn [(step [coll current-sum max-sum]\n(if (seq coll)\n(let [head (first coll)]\n(if (coll? head)\n(let [sub (step head current-sum max-sum)\nnext-sum (+ current-sum (reduce + (flatten sub)))]\n(if (<= next-sum max-sum)\n(cons sub (step (next coll) next-sum max-sum))\nsub))\n(let [next-sum (+ head current-sum)]\n(if (<= next-sum max-sum)\n(cons head (step (next coll) next-sum max-sum))\n[]))))))]\n(step coll 0 max-sum)))", "user": "53664e3be4b0243289761e74"}, {"problem": 112, "code": "(letfn [(walk [n coll]\n\t\t  (loop [c 0 [x & xs] coll acc []]\n\t\t    (cond\n\t\t      (coll? x) (let [[w d] (walk (- n c) x)]\n        \t\t          (recur (+ c d) xs (conj acc w)))\n\t\t      (and x (<= (+ c x) n)) (recur (+ c x) xs (conj acc x))\n\t\t      :else [acc c])))]\n  #(first (walk % %2)))", "user": "514d8084e4b019235f6c0588"}, {"problem": 112, "code": "(fn [max-add coll]\n  (letfn [(sequs-horribilis [max-add [h & t]]\n            (if h\n              (if (coll? h)\n                (cond (>= max-add 0) (let [[ha hc] (sequs-horribilis max-add h)\n                                           [ta tc] (sequs-horribilis ha t)]\n                                       [ta (cons hc tc)])\n                      :else [0 '()])\n                (cond (>= max-add h) (let [[ta tc] (sequs-horribilis (- max-add h) t)]\n                                       [ta (cons h tc)])\n                      :else [0 '()]))\n              [max-add '()]))]\n    (second (sequs-horribilis max-add coll))))", "user": "4ee528fb535d1385b2869d87"}, {"problem": 112, "code": ";; By nature, processing a tree is a recursive problem.\n(fn horriblis [n xs]\n  ;; Base case 1. Can't process an empty list any further.\n  (if (empty? xs)\n    []\n    ;; When xs is not null, pair? must be true.\n    ;; So we must inspect the head 'hd' and the tail 'tl',\n    ;; and proceed based on our findings.\n    (let [hd (first xs)\n          tl (rest xs)]\n      ;; Base case 2: We must stop processing right away, if 'hd'\n      ;; is a number, and its value is greater than our checksum.\n      (cond (and (number? hd) (> hd n))\n            []\n            ;; Recursive case 1: If the 'hd' is a number and we have\n            ;; not reached or exceeded checksum yet, we must hold on\n            ;; to 'hd' and process 'tl'.\n            ;; Also we must retain the nested list structure. Therefore,\n            ;; 'hd' must be consed at the original head position, and\n            ;; the result of processing 'tl' must appear at the tail\n            ;; position.\n            ;; Further, we must account for the value of 'hd' that we\n            ;; just consumed. We must deduct it from the current checksum\n            ;; and feed the new checksum to the recursive processing of 'tl'.\n            (number? hd)\n            (cons hd (horriblis (- n hd) tl))\n            ;; Recursive case 2: 'hd' is not a number. In this case, we must\n            ;; place the result of recursively processing 'hd', at the head\n            ;; position, to retain structure. In other words wrap the result,\n            ;; of processing 'hd', in a list.\n            :else [(horriblis n hd)]))))", "user": "51823a97e4b0f2adb733651e"}, {"problem": 112, "code": "(fn sequs\n    ([tgt coll sum]\n        (if (empty? coll)\n            []\n            (let [v (first coll) rst (drop 1 coll)]\n                (if (sequential? v)\n                    (let [sv (sequs tgt v sum)]\n                        (concat (if (nil? sv) [] (vector sv)) (sequs tgt rst (+ sum (apply + (flatten v))))))\n                    (if (<= (+ sum v) tgt)\n                        (concat [v] (sequs tgt rst (+ sum v)))\n                        [])))))\n    ([tgt coll]\n        (sequs tgt coll 0)))", "user": "53e76bb2e4b036ad0777e47d"}, {"problem": 112, "code": "(fn prune [n c]\n  (letfn [(cost [c] (if (sequential? c) (apply + (flatten c)) c))\n          (fit [n c] (if (sequential? c) (prune n c) (when (<= c n) c)))]\n    (let [allowances (reductions #(- % (cost %2)) n c)\n          pruned (map fit allowances c)]\n      (take-while #(or (number? %) (not(empty? %))) pruned))))", "user": "512b07f7e4b078b06821febb"}, {"problem": 112, "code": "(fn [n s]\n  (letfn [(w [s z]\n            (loop [s s a [] z z]\n              (if (seq s)\n                (let [x (first s)]\n                  (if (sequential? x)\n                    (let [[q z] (w x z)]\n                      (recur (rest s) (conj a q) z))\n                    (let [z (+ x z)]\n                      (if (<= z n)\n                        (recur (rest s) (conj a x) z)\n                        [a z]))))\n                [a z])))]\n    (first (w s 0))))", "user": "54f0d3fde4b024c67c0cf8a6"}, {"problem": 112, "code": "(fn [limit xs]\n  (letfn [(handle-seq [limit xs]\n            (loop [x (first xs)\n                   remaining (rest xs)\n                   running-sum 0\n                   accum []]\n              (if (coll? x)\n                (let [[sub-sum child-seq] (handle-seq (- limit running-sum) x)]\n                  (if (seq remaining)\n                    (recur (first remaining) (rest remaining) (+ running-sum sub-sum) (conj accum child-seq))\n                    [(+ running-sum sub-sum) (conj accum child-seq)]))\n                (let [new-sum (+ running-sum x)]\n                  (if (> new-sum limit)\n                    [running-sum accum]\n                    (if (seq remaining)\n                      (recur (first remaining) (rest remaining) new-sum (conj accum x))\n                      [new-sum (conj accum x)]))))))]\n    (second (handle-seq limit xs))))", "user": "5102ac9de4b00c483ae176fa"}, {"problem": 112, "code": "(fn [n s]\n  (second \n   ((fn sequs [n s]\n      (loop [cnt 0 acc [] [x & xs] s]\n        (cond\n         (or (nil? x) (< n cnt)) [cnt acc]\n         (coll? x) (let [[c r] (sequs (- n cnt) x)\n                         coll (if (empty? r) acc (conj acc r))]\n                     (recur (+ c cnt) coll xs))\n         :else (recur (+ x cnt) (if (< n (+ cnt x)) acc (conj acc x)) xs)))) \n    n s)))", "user": "539c736ce4b0b51d73faaf2b"}, {"problem": 112, "code": "(fn sh[n ns]\n  (if (empty? ns)\n    '()\n    (let [f (first ns)\n          r (lazy-seq (rest ns))]\n      (if (number? f)\n        (if (<= f n)\n          (concat (list f) (sh (- n f) r))\n          '())\n        (if (empty? r)\n          (list (sh n f))\n          (let [shf (list (sh n f))\n                shfn (apply + (flatten shf))]\n            (concat shf (sh (- n shfn) r))))))))", "user": "54d4bd2be4b0a52adc2e2005"}, {"problem": 112, "code": "(fn [n coll]\n  (if (instance? clojure.lang.LazySeq coll)\n    (let [nb (count (take-while #(<= % n) (reductions + coll)))]\n      (take nb coll))\n    (let [cnt (atom 0)]\n      (clojure.walk/postwalk \n       (fn [x]\n         (if (not (sequential? x))\n           (when (<= (+ @cnt x) n)\n             (do (swap! cnt + x) x))\n           (->> (remove nil? x)\n                (remove #(if (sequential? %) (empty? %) false)))))\n       coll))))", "user": "541d3c0fe4b01498b1a71a7e"}, {"problem": 112, "code": "(fn [n lst]\n  ((fn sh2 [n acc lst & extras]\n     (if (empty? lst)\n       (if (nil? extras)\n         '()\n         (sh2 n acc (first extras)))\n       (let [fst (first lst)\n             newsum (if (number? fst) (+ acc fst) nil)]\n         (if (number? fst)\n           (if (<= newsum n) (cons fst (sh2 n newsum (rest lst)))\n               '())\n           (list (sh2 n acc (first lst) (rest lst))))))) n 0 lst))", "user": "51b76227e4b0d906fcd71d35"}, {"problem": 112, "code": "(fn [num coll] ( (fn horribilis-lazy-2\n    [coll partial-sum threshold]\n  (lazy-seq\n   (if (not-empty coll)\n     (let [elt (first coll)\n           rest-part (rest coll)]\n       (if (number? elt)\n         (when ((fn [elt partial-sum threshold]\n   (<= (+ partial-sum elt) threshold)) elt partial-sum threshold)\n           (cons elt (horribilis-lazy-2 rest-part (+ elt partial-sum) threshold))\n           )\n         (let [elt-seq (horribilis-lazy-2 elt partial-sum threshold)\n               elt-sum (apply + (flatten elt-seq))]\n           (if (not-empty elt-seq)\n             (cons elt-seq\n                   (horribilis-lazy-2 rest-part (+ partial-sum elt-sum) threshold))\n             (horribilis-lazy-2 rest-part partial-sum threshold)))))\n     '()))) coll 0 num))", "user": "54ccf9d5e4b057c6fda3a295"}, {"problem": 112, "code": "(fn sequs [n [head & tail]]\n  (if (number? head)\n    (if (> head n) []\n      (cons head (sequs (- n head) tail)))\n    (if (empty? head) []\n      [(sequs n head)])))", "user": "54febf4be4b07d26eda61d45"}, {"problem": 112, "code": "(fn k [n [h & t]]\n  (when h\n    (if (coll? h)\n      (list (k n h))\n      (let [next-n (- n h)]\n        (if (>= next-n 0)\n          (cons h (k next-n t))\n          `())))))", "user": "50f10f7be4b06d9538fe211a"}, {"problem": 112, "code": "(fn baz [n xs]\n  (letfn [(foo [s xs]\n               (let [ys (flatten xs)]\n                 (loop [i 0 t 0]\n                   (if (nil? (nth ys i nil))\n                     i\n                     (if (> t s)\n                       (dec i)\n                       (recur (inc i)\n                              (+ t (nth ys i))))))))\n          (bar [n xs]\n               (let [head (first xs)]\n                 (if (or (nil? head) (zero? n))\n                   '()\n                   (if (coll? head)\n                     (let [zs (bar n head)\n                           n2 (count (flatten zs))]\n                       (conj (bar (- n n2) (rest xs)) zs))\n                     (conj (bar (dec n) (rest xs)) head)))))]\n    (bar (foo n xs) xs)))", "user": "54d753ebe4b0a52adc2e2029"}, {"problem": 112, "code": "(fn [max coll]\n  (letfn [(run [sum ints]\n            (if (empty? ints)\n              [sum nil]\n              (let [[fst & rst] ints]\n                (if (number? fst)\n                  (let [next-sum (+ sum fst)]\n                    (if (<= next-sum max)\n                      (let [[after-rst-sum after-rst-ints] (run next-sum rst)]\n                        [after-rst-sum (cons fst after-rst-ints)])\n                      [sum nil]))\n                  (let [[after-fst-sum after-fst-ints] (run sum fst)]\n                    (if (<= after-fst-sum max)\n                      (let [[after-rst-sum after-rst-ints] (run after-fst-sum rst)]\n                        [after-rst-sum (cons after-fst-ints after-rst-ints)])\n                      [sum nil]))))))]\n\n    (or (second (run 0 coll)) '())))", "user": "5344fe13e4b084c2834f4a32"}, {"problem": 112, "code": ";; Does not handle (__ 10 [1 [2] 3 4 5 6 7])\n  (fn artic-fox [n coll]\n    (let [s (seq coll)]\n      (cond\n        (nil? s) ()\n        (coll? (first s)) (cons (artic-fox n (first s)) ())\n        (> (first s) n) ()\n        :else (cons (first s) (lazy-seq (artic-fox (- n (first s)) (rest coll)))))))", "user": "51b91b08e4b0e871ca4958f8"}, {"problem": 112, "code": "(fn [M col] \n  (letfn [(sequs[N coll]\n            (loop [c coll ret ['() N]]\n               (if (empty? c)\n                 ret\n                 (let [fc (first c) fr (first ret) lr (last ret)]\n                   (if (coll? fc)\n                     (let [[s n] (sequs lr fc)]\n                       (recur (rest c) [(concat fr (list s)) n]))\n                     (if (<= fc lr)\n                       (recur (rest c) [(conj (vec fr) fc) (- lr fc)])\n                       ret))))))\n          ]\n    (first (sequs M col))))", "user": "545537c1e4b0e397800069dd"}, {"problem": 112, "code": "(fn msr [maxval co]\n (nth (last (take-while #(and (first %) (<= (second %) maxval))\n  (iterate \n    (fn [[s total subcol remcol]] \n       (if (empty? remcol) \n             [false total subcol remcol]\n      (if (not (coll? (first remcol)))\n        [true (+ total (first remcol)) (conj subcol (first remcol)) (rest remcol)]\n        (let [re (msr (- maxval total) (first remcol))\n              resum (apply + (flatten re))]\n         [true (+ total resum) (if (empty? (flatten re)) subcol (conj subcol re)) (rest remcol)])\n      )\n))\n     [true 0 '[] co])\n)) 2))", "user": "54908cc1e4b0b312c081ff32"}, {"problem": 112, "code": "(fn sum-upto [n [x & xs :as coll]]\n  (cond\n   (empty? coll) '()\n   (coll? x) (list (sum-upto n x))\n   (> x n) '()\n   :else (cons x (sum-upto (- n x) xs))))", "user": "5339c105e4b0e30313ee6cae"}, {"problem": 112, "code": "(fn sequs-horriblis\n  [n coll]\n  (letfn [(f [n [x & xs] ret]\n             (if (or (not x) (and (not (coll? x)) (> (+ x (:sum ret)) n)))\n               ret\n               (if (coll? x)\n                 (->\n                   (f n x (merge ret {:data []}))\n                   (update-in [:data] #(conj (:data ret) %)))\n                 (f n xs (-> ret\n                             (update-in [:sum] + x)\n                             (update-in [:data] #(conj % x)))))))]\n    (:data (f n coll {:sum 0 :data []}))))", "user": "5383668ee4b06839e8705edd"}, {"problem": 112, "code": "(fn horrible-seq\n  ([target-sum in-seq] (first (horrible-seq target-sum in-seq 0)))\n\n  ([target-sum in-seq cnt]\n    (loop [lft in-seq sum cnt res []]\n      (let [fst (first lft)]\n        (cond (empty? lft) [res sum]\n              (sequential? fst) (let [nested-res (horrible-seq target-sum fst sum)]\n                                  (recur (rest lft) (second nested-res) (conj res (first nested-res))))\n              (> (+ fst sum) target-sum) [res sum]\n              :else (recur (rest lft) (+ fst sum) (conj res fst)))))))", "user": "54f09599e4b024c67c0cf89d"}, {"problem": 112, "code": "(fn [n L]\n   (let [elems (last (take-while #(<= (apply + %) n)\n                   (reductions (fn [acc x] (conj acc x)) [] (flatten L))))]\n\n     (let [princ (fn princ [r [x & xs] [e & es]]\n                   (cond (nil? e) r\n                         (coll? x) (conj r (princ [] x (cons e es)))\n                         :else (princ (conj r e), xs, es)))]\n\n       (princ [] L elems)\n\n       )))", "user": "54e51c7be4b024c67c0cf7f7"}, {"problem": 112, "code": "(fn d [n [h & t :as c]]\n  (cond\n   (empty? c) []\n   (coll? h) [(d n h)]\n   (>= n h) (concat [h] (d (- n h) t))\n   :else []))", "user": "53b7aa6ce4b047364c0444d1"}, {"problem": 112, "code": "(fn sequs-horribilis [in icoll]\n  (first\n    ((fn se-helper [input-n input-coll]\n       (loop [result []\n              m input-n\n              coll input-coll]\n         (let [elem (first coll)]\n           (if (nil? elem)\n             [result 0]\n             (if (sequential? elem)\n               (let [[subresult new-m] (se-helper m elem)]\n                 (recur (conj result subresult) new-m (rest coll)))\n               (cond\n                 (>= (- m elem) 0)\n                   (recur (conj result elem) (- m elem) (rest coll))\n                 (or (empty? coll) (neg? (- m elem)))\n                   [result 0]\n                 :else\n                 (recur result m (rest coll))))))))\n     in\n     icoll)))", "user": "540e8d13e4b0addc1aec671e"}, {"problem": 112, "code": "(fn seq-h [n xs]\n  (letfn [(sum [x] (if (number? x) x (apply + (map sum x))))]\n    (loop [n n, xs xs, res []]\n      (if (empty? xs) res\n        (let [[x & xs] xs]\n          (if (number? x)\n            (if (< n x) res\n          \t  (recur (- n x) xs (conj res x)))\n            (let [r (seq-h n x)]\n              (recur (- n (sum r)) xs (conj res r)))))))))", "user": "553e0b70e4b0a04f792994e8"}, {"problem": 112, "code": "(fn __ [m xs]\n  (loop [sum 0 s (seq xs) r []]\n    (if (empty? s) r\n      (let [f (first s) fret (if (coll? f) (__ (- m sum) f) f)\n            fval (if (coll? fret) (reduce + (flatten fret)) fret)]\n        (if (> (+ fval sum) m) r\n          (recur (+ fval sum) (next s) (conj r fret)))))))", "user": "553abb28e4b09218d5f44ffb"}, {"problem": 112, "code": "(fn structured-take-sum\n  [n coll] {:pre [(number? n)]}\n  (let [ ;; This function is just like our main function, except it returns a\n         ;; pair [i result], where the second element is the desired return\n         ;; sequence and the first is the amount of \"headroom\" leftover; that\n         ;; is, the difference between n and the recursive sum of all elements\n         ;; in result. If any elements were omitted from coll (that is, if the\n         ;; desired sum has already been reached), i is nil.\n        structured-take-sum-k\n        (fn structured-take-sum-k [n coll]\n          (let [ ;; This function is going to be used as a reducer.  The\n                 ;; accumulator is a pair [i acc], where acc is the output\n                 ;; accumulated so far (a vector), and i is the amount of room\n                 ;; we have before we exceed our desired sum, or nil if we've\n                 ;; already found a number that would cause us to exceed it (and\n                 ;; so should ignore the rest of the sequence).\n                take-sum-reducer\n                (fn [[i acc] x]\n                  (cond\n                    (nil? i)         [nil acc]\n                    (coll? x)        (let [[new-i acc-add]\n                                           (structured-take-sum-k i x)]\n                                       [new-i (conj acc acc-add)])\n                    (and (number? x)\n                         (<= x i))     [(- i x) (conj acc x)]\n                    :else             [nil acc]))]\n            (->> (reductions take-sum-reducer [n []] coll)\n                 (take-while first)\n                 last)))]\n    (second (structured-take-sum-k n coll))))", "user": "4fc6305de4b0ee37620e180b"}, {"problem": 112, "code": "(fn filter-sum [n coll]\n  (letfn [(take-sum [coll n]\n            (let [s (take-while #(>= n %) (reductions + coll))\n                  k (count s)]\n              (if (zero? k) 0 (last (take k coll)))))\n          (filter-all [n coll res]\n            (cond (empty? coll) res\n                  (coll? (first coll))\n                  (filter-all n (rest coll) (conj res (filter-all n (first coll) [])))\n                  (>= n (first coll)) (filter-all n (rest coll) (conj res (first coll)))\n                  :else res))]\n    (let [k (take-sum (flatten coll) n)]\n      (filter-all k coll []))))", "user": "547884d7e4b0c51c1f4d72bd"}, {"problem": 112, "code": "(fn __ [a b]\n(letfn [(___  \n([tl dl tally acc]\n  (if (or (empty? dl) (> tally tl)) acc\n\t(if (number? (first dl))\n\t  (if (<= (+ tally (first dl)) tl) \n\t \t  (___ tl (rest dl) (+ tally (first dl)) (conj acc (first dl)))\n\t\t  acc)\n\t  (let [[nv nl] (___ tl (first dl) tally [] true)]\n\t    (___ tl (rest dl) nv (conj acc nl))))))\n([tl dl tally acc ret]\n  (if (or (empty? dl) (> tally tl)) [tally acc]\n\t(if (number? (first dl)) \n\t  (if (<= (+ tally (first dl)) tl) \n\t  \t  (___ tl (rest dl) (+ tally (first dl)) (conj acc (first dl)) true)\n\t\t  [tally acc])\n\t  (let [[nv nl] (___ tl (first dl) tally [] true)]\n\t    (___ tl (rest dl) nv (conj acc nl) true))))))]\n(___ a b 0 [])))", "user": "52747090e4b03e8d9a4a74a5"}, {"problem": 112, "code": "(fn sh [n [s & ss]]\n  (when s\n    (if (integer? s)\n      (if (<= s n)\n        (lazy-seq (cons s (sh (- n s) ss)))\n        '())\n      (let [hd (sh n s) sum (apply + (flatten hd))]\n        (lazy-seq (cons hd (sh (- n sum) ss)))))))", "user": "52ce1abfe4b07d0d72b27389"}, {"problem": 112, "code": "(fn h [n [a & r]]\n  (cond (and (number? a) (<= a n)) (cons a (h (- n a) r))\n        (coll? a) (let [t (apply + (flatten a))]\n                \t(cons (h n a) (when (>= n t) (h (- n t) r))))\n        :else ()))", "user": "543366dde4b0b6b47310fcdf"}, {"problem": 112, "code": "(fn horitem\n  [m col]\n  (lazy-seq\n    (if (empty? col)\n      nil\n      (if (sequential? (first col))\n        (let [ z (horitem m (first col)) ] \n          (if (seq z) \n            (cons z (horitem (- m (apply + (flatten z))) (rest col)))\n            nil))\n        (let [ y (- m (first col))]\n          (if (>= y 0)\n            (cons (first col) (horitem y (rest col)))\n            nil))))))", "user": "55536a8ae4b0deb715856e03"}, {"problem": 112, "code": "#(letfn [(sequs [bound coll]\n                (loop [result [0 []] remaining coll];initially sum is zero and structure is empty\n                  (if-let [item (first remaining)]\n                    (if (coll? item)\n                      (let [[subSum subSeq] (sequs (- bound (first result)) item)];if one item is a collection, then compute then sum from that collection\n                        (recur [(+ (first result) subSum) (conj (second result) subSeq)];and go onto the next item\n                               (rest remaining)))\n                      (if (> (+ item (first result)) bound) result;if sum exceeds the bound then return\n                        (recur [(+ item (first result)) (conj (second result) item)];else continue the loop\n                               (rest remaining))))\n                    result)))]\n  (second (sequs %1 %2)))", "user": "556c70dae4b09a3098a524fd"}, {"problem": 112, "code": "(fn sequs-horibillis\n  ([cumsum sequs] (let [get-indexed-sequs (fn get-indexed-sequs\n                                            ([sequs] (if (nil? (first sequs)) nil\n                                                       (get-indexed-sequs sequs [0] [])))\n                                            ([sequs curr-isq sq-buff]\n                                             (let [[sq & sqs] sequs\n                                                   vdrop-last (fn vdrop-last\n                                                                ([n v] (into [] (drop-last n v)))\n                                                                ([v] (into [] (drop-last v))))\n                                                   vtake-last (fn vtake-last\n                                                                ([n v] (into [] (take-last n v)))\n                                                                ([v] (into [] (take-last v))))\n                                                   incr-isq (fn incr-isq [idx]\n                                                              (conj (vdrop-last idx) (+ 1 (last idx))))\n                                                   decr-isq (fn decr-isq [idx]\n                                                              (conj (vdrop-last 2 idx) (+ 1 (first (take-last 2 idx)))))]\n                                               (cond (sequential? sq) (get-indexed-sequs sq (conj curr-isq 0) (cons sqs sq-buff)) \n                                                     (nil? sq) (let [[buff & buffs] sq-buff]\n                                                                 (cond (empty? sq-buff) nil\n                                                                       (nil? buff) (get-indexed-sequs buff (decr-isq curr-isq) buffs)\n                                                                       true (get-indexed-sequs buff (decr-isq curr-isq) buffs)))\n                                                     true (cons {:k curr-isq :v sq}\n                                                                (lazy-seq (get-indexed-sequs sqs (incr-isq curr-isq)  sq-buff)))))))]\n                    (sequs-horibillis cumsum (get-indexed-sequs sequs) [])))\n  ([cumsum [{k :k v :v} & isqs] res]\n   (cond (nil? v) res\n         (> v cumsum) res \n         (and (= (last k) 0)\n              (> (count k) 1)) (let [get-nests-idx (fn get-nests-idx [idx]\n                                                     (let [n (count idx)\n                                                           n-nst (count (take-while #(= % 0) (reverse idx)))\n                                                           dn (- n n-nst)\n                                                           start-nst-idx (if (= dn 0) 1 dn)\n                                                           aux (fn rec\n                                                                 ([] (rec [] start-nst-idx))\n                                                                 ([res pter] (if (< pter n) (rec (conj res (take pter idx)) (+ 1 pter))\n                                                                               res)))]\n                                                       (aux)))\n                                     res (reduce #(assoc-in %1 %2 []) res (get-nests-idx k))]\n                                 (sequs-horibillis (- cumsum v) isqs (assoc-in res k v)))\n         true (sequs-horibillis (- cumsum v) isqs (assoc-in res k v))\n         )))", "user": "54bbaa8ee4b0ed20f4ff6ec0"}, {"problem": 112, "code": "(fn [n seq]\r\n  (let [f (fn f [n [head & tail]]\r\n      (if (nil? head)\r\n        {:coll [] :n 0}\r\n      (if (coll? head)\r\n        (let [\r\n            head-result (f n head)\r\n            tail-result (f (- n (head-result :n)) tail)\r\n            head-coll (head-result :coll)\r\n            tail-coll (tail-result :coll)\r\n            new-coll (cons head-coll tail-coll)\r\n            new-n (+ (head-result :n) (tail-result :n))]\r\n          {:coll new-coll :n new-n})\r\n      (if (< n head)\r\n        {:coll [] :n 0}\r\n      ;else\r\n        (let [\r\n            tail-result (f (- n head) tail)\r\n            head-coll head\r\n            tail-coll (tail-result :coll)\r\n            new-coll (cons head-coll tail-coll)\r\n            new-n (+ head (tail-result :n))]\r\n          {:coll new-coll :n new-n})))))]\r\n    ((f n seq) :coll)))", "user": "555bd27ae4b0b056612e2244"}, {"problem": 112, "code": "(fn __ [limit coll]\n  (let [aux (fn aux [limit coll]\n              (if (empty? coll)\n                [limit coll]                                ; #1: empty case\n                (let [[x & xs] coll]\n                  (if (coll? x)                             ; is sequence\n                    (let [[limit2 x'] (aux limit x)\n                          [limit3 xs'] (aux limit2 xs)]\n                      [limit3 (cons x' xs')])               ; #2\n                    (if (> x limit)                         ; is number, and bigger than the limit\n                      [0 []]                                ; #3: don't go beyond this\n                      (let [limit2 (- limit x)\n                            [limit3 xs'] (aux limit2 xs)]\n                        [limit3 (cons x xs')]))))))]\n    (second (aux limit coll))))", "user": "536d83cee4b0fc7073fd6e5e"}, {"problem": 112, "code": "(fn f [n [a & b]]\n  (when a\n    (if (coll? a)\n      (let [s (apply + (flatten a))]\n        (if (<= s n)\n          (cons a (f (- n s) b))\n          [(f n a)]))\n      (if (> a n) '()\n        (cons a (f (- n a) b))))))", "user": "53500869e4b084c2834f4ad3"}, {"problem": 112, "code": "(fn sequs-horibilis\n\n  [sum coll]\n  (let [innerf (fn innerf\n                 [acc-sum coll]\n                 (if (or (> acc-sum sum) (empty? coll))\n                   [(list) 0]\n                   (let [head (first coll)]\n                     (if (sequential? head)\n                       (let [res (innerf acc-sum  head)\n                              inres (innerf (+ acc-sum (second res)) (rest coll))]\n                         [(cons (first res)\n                                (first inres))\n                          (+ (second inres) (second res))])\n                       (if (>= sum (+ acc-sum head))\n                         (let [res (innerf (+ acc-sum head) (rest coll))]\n                           [(cons head (first res ))\n                            (+ head (second res))])\n                         [(list) acc-sum])))))]\n   (first (innerf 0 coll))))", "user": "55079e55e4b021ccfedb96aa"}, {"problem": 112, "code": "(fn [s xs] ((fn a [xs n] (loop [xs xs h (first xs) res [],n n] (if h (if (sequential? h) (conj res (a h n)) (if (>= s (+ n h)) (recur (next xs) (second xs) (conj res h) (+ n h)) res)) res))) xs 0))", "user": "5507cfd3e4b021ccfedb96ad"}, {"problem": 112, "code": "(fn f [n s]\n  (when (seq s)\n    (let [[x & xs] s]\n      (if (sequential? x)\n        (list (f n x))\n        (let [n (- n x)]\n          (if-not (neg? n)\n            (cons x (lazy-seq (f n xs)))\n            '()))))))", "user": "52470d42e4b05ef8e38e6350"}, {"problem": 112, "code": "(fn sequs-horribilis\n  [n xs]\n  (let [y (first xs)\n        ys (rest xs)]\n    (cond\n      (empty? xs) '()\n      (coll? y) (cons (sequs-horribilis n y) ())\n      (or (zero? (- n y)) (pos? (- n y))) (cons y (sequs-horribilis (- n y) ys))\n      (zero? n) '())))", "user": "506f0968e4b09350ab4199f5"}, {"problem": 112, "code": "(fn sequs-horribilis\n  [n x]\n  (apply (fn sequs-horribilis-prime\n  ([n] [])\n  ([n x & z]\n   (if (coll? x)\n     (list (apply sequs-horribilis-prime n x))\n     (if (< (- n x) 0)\n       []\n       (cons x (apply sequs-horribilis-prime (- n x) z))))))\n n x))", "user": "557e9d17e4b05c286339e0d8"}, {"problem": 112, "code": "(fn [n c] (let [f (fn f [n [h & r]]\n                     (if h\n                       (if ((complement sequential?) h)\n                         (if (<= h n)\n                           (let [[x y] (f (- n h) r)]\n                             [x (cons h y)])\n                           [0 '()])\n                         (let [[credit-left collected] (f n h)]\n                           (if (< 0 credit-left)\n                             (let [[credit collected-from-remainder] (f credit-left r)]\n                               [credit (cons collected collected-from-remainder)])\n                             [0 (list collected)])))\n                       [n '()]))\n                 [_ o] (f n c)]\n             o))", "user": "545ddac3e4b01be26fd74676"}, {"problem": 112, "code": "(fn [max-sum coll]\n  (letfn [(sequs-horribilis [remain-sum coll]\n            (loop [remain-sum remain-sum\n                   coll       coll\n                   result     []]\n              (if (empty? coll)\n                [remain-sum result]\n                (let [x (first coll)]\n                  (let [[remain-sum x] (if (sequential? x)\n                                         (sequs-horribilis remain-sum x)\n                                         [(- remain-sum x) x])]\n                    (if (neg? remain-sum)\n                      (if (and (sequential? x)\n                               (not-empty x))\n                        [remain-sum (conj result x)]\n                        [remain-sum result])\n                      (recur remain-sum\n                             (rest coll)\n                             (conj result x))))))))]\n    (second (sequs-horribilis max-sum coll))))", "user": "55586905e4b0deb715856e2b"}, {"problem": 112, "code": "(fn f [n c]\n  (let [head (first c), tail (rest c)]\n    (if (coll? head)\n      (list (f n head))\n      (if (< (- n head) 0) ()\n        (if (empty? tail)\n          (list head)\n          (cons head (f (- n head) tail)))))))", "user": "53065acbe4b02e8216869792"}, {"problem": 112, "code": "(letfn [(f [n coll] (if (or ( empty? coll) (< n 0) ) {:n n :c '()}\n                 (let [first-v (first coll)]\n                   ( cond\n                     (coll? first-v) ( let [{ new-n :n  c :c}  (f n first-v) \n                                       {new-n-2 :n c-2 :c}\n                                             (f new-n (rest c))]\n                                        {:n  new-n-2 :c \n                                      (if (empty? c) c-2 (list c))})\n                     \n                     :else  (let [new-n (- n first-v) \n                                  {new-n-2 :n  c-2 :c :as r} (f new-n (rest coll))] \n                              (if (< new-n 0) r \n                                  { :n new-n-2 :c \n                                   (conj c-2 first-v)}))))))]\n    (fn [n coll] (:c (f n coll)))\n    )", "user": "50856bd1e4b004985b776e4c"}, {"problem": 112, "code": "(fn seqs-h [mx lst]\n  (loop [sum 0, ind 0, out []]\n    (cond\n      (and (not (instance? clojure.lang.LazySeq lst))\n          (= ind (count lst))) out\n      (sequential? (nth lst ind)) (let [out-lst\n                                        (seqs-h (- mx sum) (nth lst ind))]\n                                    (recur (apply + (flatten out-lst))\n                                           (inc ind)\n                                           (conj out out-lst)))\n      (< mx (+ sum (nth lst ind))) out\n      :else (recur (+ sum (nth lst ind)) (inc ind) (conj out (nth lst ind))))))", "user": "5545477fe4b0a04f79299531"}, {"problem": 112, "code": "(fn f                                                                                                                                                   \n    ([limit s] (f limit s 0))                                                                                                   \n    ([limit s cur]                                                                                                                                      \n        (let [n (first s)]                                                                                                      \n            (cond                                                                                                                                       \n                (nil? n) '()                                                                                                    \n                (coll? n) (vector (f limit n cur))                                                                                                      \n                (<= (+ n cur) limit) (cons n (f limit (rest s) (+ n cur)))                                                      \n                :else '()))))", "user": "558b50d5e4b027778923762b"}, {"problem": 112, "code": "(fn to-sum [n coll]\n  (lazy-seq\n   (when (and (>= n 0) (not (empty? coll)))\n     (let [[x & rst] coll]\n       (if (coll? x)\n         (let [sq (to-sum n x)\n               sum (apply + (flatten sq))]\n           (cons sq (to-sum (- n sum) rst)))\n         (when (>= n x)\n           (cons x (to-sum (- n x) rst))))))))", "user": "540a4f20e4b0addc1aec66ef"}, {"problem": 112, "code": "(comp first (fn sum-break [sum tree]\n    (if\n          (empty? tree) [tree sum]\n        (let [head (first tree)]\n             (if (and (number? head) (< sum head))\n                 [[] -1]\n                 (let [[proc-head remaining] \n                       (if (number? head)\n                           [head (- sum head)]\n                           (sum-break sum (first tree)))]\n             (if (< remaining 0) [[proc-head] remaining]\n                 (let [[proc-tail remaining] (sum-break remaining (rest tree))]\n                      [(cons proc-head proc-tail) remaining]))))))))", "user": "559c13c5e4b066d22e731f61"}, {"problem": 112, "code": "(fn seq-horrib [budget root]\n                  (loop [rv []\n                         budget budget\n                         root root]\n                      ;(println \"loop\" budget rv root)\n                      (if (number? (first root))\n                        (if (>= budget (first root))\n                          (if (empty? (rest root))\n                            (conj rv (first root))\n                            (recur (conj rv (first root)) (- budget (first root)) (rest root)))\n                          rv)\n                        (let [child (seq-horrib budget (first root))\n                              cost (apply + (flatten child))]\n                              (if (empty? (rest root))\n                                (conj rv child)\n                                (recur (conj rv child) (- budget cost) (rest root)))))))", "user": "55934bebe4b0c79f6e1db93b"}, {"problem": 112, "code": "(fn me [n my-seq]\n\n\n  (let [\n\n        ;res [[], cur-sum]\n        r-fn ( fn [res arg]\n\n            ( if (coll? arg)  \n\n              (let [cur (me (- n (second res)) arg)]\n\n                  (if (empty? cur)\n                     res \n                     [(concat (first res) [cur]) (+ (second res) (apply + (flatten cur)))] \n                    )\n                  \n\n              )\n\n              (if (<= (+ arg (second res)) n)\n\n                [(concat (first res) [arg]) (+ arg (second res))]\n                res\n\n              )\n\n            )\n\n        )\n    ]\n\n    (first (reduce r-fn [[] 0] (take 20 my-seq)))\n\n  )\n\n)", "user": "55897fe2e4b059ccff29b205"}, {"problem": 112, "code": "(fn upto [n coll]\n  (reverse\n    (loop [x coll remaining n result '()]\n      (if (empty? x)\n        result\n        (let [val (first x)]\n          (if (coll? val)\n            (conj result (upto remaining val))\n            (if (>= (- remaining val) 0)\n              (recur (rest x) (- remaining val) (conj result val))\n              result\n              )\n            )\n          )\n        )\n      )\n    )\n  )", "user": "5592bf9fe4b0c79f6e1db933"}, {"problem": 112, "code": "(fn h [n [head & tail]]\n  (if (number? head)\n    (if (> head n)\n      '()\n      (cons head (h (- n head) tail)))\n    (if (nil? head)\n    '()\n    (let [sub (h n head)\n          nsub (apply + (map read-string (re-seq #\"\\d+\" (str sub))))]\n      (cons sub (h (- n nsub) tail))))))", "user": "55a74d46e4b09e57187da2a3"}, {"problem": 112, "code": "(fn s [n coll]\n  (if (empty? coll)\n    '()\n    (let [f (first coll)\n          r (rest coll)]\n      (if (coll? f)\n        (concat [(s n f)] (s (- n (reduce + (flatten f))) r))\n        (if (>= n f)\n          (concat [f] (s (- n f) r))\n          '())))))", "user": "55205564e4b08d5046aa8a60"}, {"problem": 112, "code": "(fn sequs-horribilis [n coll]\n   (letfn [ (sequs-horribilis2 [n coll current sum]\n              (cond (empty? coll) [current sum]\n                    :else(let [[fcoll & rcoll] coll]\n                           (if (sequential? fcoll)\n                             (let [[result sum] (sequs-horribilis2 n fcoll [] sum)]\n                               (if (> sum n)\n                                 [(conj current result) sum]\n                                 (sequs-horribilis2 n rcoll (conj current result) sum)))\n                             (if (> (+ sum fcoll ) n)\n                               [current (+ sum fcoll)]\n                               (sequs-horribilis2 n rcoll (conj current fcoll) (+ sum fcoll))))))) ]\n     (first (sequs-horribilis2 n coll [] 0))\n     )\n    )", "user": "55aa1637e4b0988bba2ad949"}, {"problem": 112, "code": "(fn prune [r t]\n  (let [ps (reductions (fn [[ar at] x]\n                         (if (sequential? x)\n                           (let [px (prune ar x)\n                                 sx (reduce + (flatten x))]\n                             (if (seq px)\n                               [(- ar sx) (conj at px)]\n                               [(- ar sx) at]))\n                           (if (<= x ar)\n                             [(- ar x) (conj at x)]\n                             [(- ar x) at])))\n                       [r []]\n                       t)]\n    (second (if-let [p (first (drop-while (fn [[ar at]] (>= ar 0)) ps))]\n              p\n              (last (take-while (fn [[ar at]] (>= ar 0)) ps))))))", "user": "55c4e48be4b0e31453f649a7"}, {"problem": 112, "code": "(fn [n xs]\n  (second\n  ((fn walk [n xs]\n   (if (or (< n 0) (empty? xs)) [n xs]\n      (if (coll? (first xs))\n          (let [[x coll] (walk n (first xs))]\n             (if (< x 0) \n                 [x (list coll)]\n                 (let [[y coll2] (walk x (rest xs))]\n                   [y (cons coll coll2)])))\n          (if (> (first xs) n) \n            [(- n (first xs)) '()]\n            (let [[y col2] (walk (- n (first xs)) (rest xs))]\n              [y (cons (first xs) col2)]))))) n xs)))", "user": "559b55d6e4b066d22e731f54"}, {"problem": 112, "code": "(let [a (atom 0)]\n       (fn f [n s]\n         (cond\n          (number? s)\n          (when (<= @a (- n s))\n            (swap! a + s)\n            s)\n          (sequential? s)\n          (doall\n           (for [i s\n                 :let [x (f n i)]\n                 :while x]\n             x)))))", "user": "55be39f9e4b01b9910ae2a06"}, {"problem": 112, "code": "(fn [n xs]\n  (letfn [(f [[x & xs] tot acc]\n              (if (sequential? x)\n                (conj acc (f x tot []))\n                (if (or (nil? x) (> (+ tot x) n))\n                  acc\n                  (recur xs (+ tot x) (conj acc x)))))]\n    (f xs 0 [])))", "user": "4f7207d3e4b07046d9f4f019"}, {"problem": 112, "code": "(fn horrbillis\n  [n s]\n  (letfn [(sequs [acc n s res]\n            (if (empty? s)\n              res\n              (let [in (first s)]\n                (if (coll? in)\n                  (conj res (sequs 0 (- n acc) (first s) []))\n                  (if (<= (+ in acc) n)\n                    (sequs (+ in acc) n (rest s) (conj res in))\n                    res)))))]\n    (sequs 0 n s [])))", "user": "5594e0e3e4b0c79f6e1db95b"}, {"problem": 112, "code": "(fn find-path2 [n [h & t]]\n   (cond\n    (nil? h) []\n    (coll? h)  [(find-path2 n h)]\n    (>= n h) (concat [h] (find-path2 (- n h) t))\n    :else []))", "user": "55c9bc1ee4b0e31453f649f1"}, {"problem": 112, "code": "(fn [max-v c] (letfn [\n    (c-ex1 [c r rc] (loop [c c r r rc rc] (cond \n      (coll? (first c)) (let [[r1 rc1] (c-ex1 (first c) r [])] (recur (rest c) r1 (conj rc rc1)))\n      (or (empty? c) (> (+ r (first c)) max-v)) [r rc]\n      :else (recur (rest c) (+ r (first c)) (conj rc (first c)))\n )))] (last (c-ex1 c 0 [])) ))", "user": "55adf4d7e4b03311e7b732af"}, {"problem": 112, "code": "(fn f [n s]\n  (if (seq s)\n    (if (integer? (first s))\n      (if (> (first s) n)\n        []\n        (cons (first s) (f (- n (first s)) (rest s))))\n      [(f n (first s))])\n    []))", "user": "55625903e4b0c656e3ff17d7"}, {"problem": 112, "code": "(fn [limit l]\n\t(letfn [(func [ret limit l]        \t\n        \t(if (empty? l)\n        \t  ret\n        \t  (let [v (first l)]\n        \t    (if (sequential? v)\n        \t      (conj ret (func [] limit v))\n        \t      (if (<= v limit)\n        \t        (func (conj ret v) (- limit v) (rest l))\n        \t        ret)))))]\n      (func [] limit l)))", "user": "55d74e71e4b0e31453f64aa4"}, {"problem": 112, "code": "(letfn [(take-it [n coll]\n          (lazy-seq\n           (when  (and (seq coll) (>= n 0))\n             (let [e (first coll)]\n               (if (sequential? e)\n                 (cons (take-it n e)\n                       (take-it (- n (apply + (flatten e))) (next coll)))\n                 (when (>= n e)\n                   (cons e (take-it (- n e) (next coll)))))))))]\n     take-it)", "user": "51d19c24e4b0cfcf579466c3"}, {"problem": 112, "code": "(fn sequs [n xs]\n  (cond\n    (empty? xs) '()\n    (coll? (first xs))\n      (let [head (sequs n (first xs))]\n        (cons head (sequs (- n (apply + (flatten head))) (rest xs))))\n    (>= n (first xs)) (cons (first xs) (sequs (- n (first xs)) (rest xs)))\n    :else '()))", "user": "559454f2e4b0c79f6e1db952"}, {"problem": 112, "code": "(fn mnest\n   ([n coll] (mnest n 0 coll))\n   ([n sum coll]\n    (loop [_s sum\n           _r coll\n           ret []]\n      (cond\n        (> _s n) (if (nil? (butlast ret)) [] (butlast ret))\n        (empty? _r) ret\n        :else\n        (if (coll? (first _r))\n               (conj ret (mnest n _s (first _r)))\n               (recur (+ _s (first _r)) (rest _r) (conj ret (first _r))))))))", "user": "55a372f1e4b0acc240e31537"}, {"problem": 112, "code": "(fn [n s]\n  (let [h (fn h [n s]\n            (loop [s s\n                   m 0\n                   acc []]\n              (if (seq s)\n                (let [f (first s)]\n                  (if (or (seq? f) (vector? f))\n                    (let [obj (h (- n m) f)\n                          nacc (:acc obj)\n                          nm (:m obj)\n                          finished (:finished obj)]\n                      (if finished\n                        {:acc (conj acc nacc) :m (+ m nm) :finished true}\n                        (recur (next s) (+ m nm) (conj acc nacc))))\n                    (let [m (+ m f)]\n                      (if (<= m n)\n                        (recur (next s) m (conj acc f))\n                        {:acc acc :m m :finished true}))))\n                {:acc acc :m m :finished true})))]\n    (:acc (h n s))))", "user": "549c6792e4b0f3d1d8e70f8b"}, {"problem": 112, "code": "(fn [n s]\n  (second\n   ((fn sequs [n s]\n      (loop [cnt 0 acc [] [x & xs] s]\n        (cond\n          (or (nil? x) (< n cnt)) [cnt acc]\n          (coll? x) (let [[c r] (sequs (- n cnt) x)\n                          coll (if (empty? r) acc (conj acc r))]\n                      (recur (+ c cnt) coll xs))\n          :else (recur (+ x cnt) (if (< n (+ cnt x)) acc (conj acc x)) xs))))\n    n s)))", "user": "537e104ce4b06839e8705e9a"}, {"problem": 112, "code": "(fn sh [n [x & xs]]\n  (cond\n    (sequential? x)  (list (sh n x))\n    (and x (<= x n)) (cons x (sh (- n x) xs))\n    :else            '()))", "user": "55d5e80ee4b0e31453f64a91"}, {"problem": 112, "code": "(fn [n l]\n  (first\n   ((fn loop-da-woop\n      [n [x & xs]]\n      (if (nil? x)\n        [x n]\n        (if (coll? x)\n          (let [[y m] (loop-da-woop n x)\n                [z l] (loop-da-woop m xs)]\n            [(cons y z) l])\n          (if (<= x n)\n            (let [[y m] (loop-da-woop (- n x) xs)]\n              [(cons x y) m])\n            ['() n])))) n l)))", "user": "55b22c33e4b0da326a65cf79"}, {"problem": 112, "code": "(fn seq-hor [n se]\n  (let [fs (first se)]\n    (if (or (and (integer? fs) (< n fs)) (empty? se)) '()\n        (if (integer? fs)\n          (conj (seq-hor (- n fs) (rest se)) fs)\n          (list (seq-hor n fs))))))", "user": "551c66dae4b07993ea3788de"}, {"problem": 112, "code": "(fn take-sum [n seq]\r\n  (let [[head & seq] seq]\r\n    (if (not head) ()\r\n      (if (integer? head)\r\n        (if (< (- n head) 0) ()\r\n          (cons head\r\n                (take-sum (- n head) seq)))\r\n        (list (take-sum n head))))))", "user": "55d0e76ae4b0e31453f64a40"}, {"problem": 112, "code": "(comp second\n      (fn drive [gas road]\n        (cond\n         (< gas 0) [gas '()]\n         (not (coll? road)) [(- gas road) (when (<= road gas) road)]\n         (seq road) (let [[g1 r1] (drive gas (first road))\n                          [g2 r2] (drive g1 (or (next road) '()))]\n                      [g2 (if (nil? r1)\n                            '()\n                            (cons r1 r2))])\n         :else [gas road])))", "user": "4f5eda39e4b0030a34fb2b56"}, {"problem": 112, "code": "(letfn [(nested [sum [head & tail]]\n  (if (nil? head)\n    [sum nil]\n    (if (sequential? head)\n      (let [head-seq (nested sum head)\n            tail-seq (nested (first head-seq) tail)]\n        [(first tail-seq) (concat (list (last head-seq)) (last tail-seq))])\n      (let [new-sum (- sum head)]\n        (if (neg? new-sum)\n          [new-sum ()]\n          (let [next-seq (nested new-sum tail)]\n\t        [(first next-seq) (cons head (last next-seq))]))))))]\n  #(last (nested % %2)))", "user": "55ccdc6be4b0e31453f64a18"}, {"problem": 112, "code": "(fn [top s]\n  (letfn [(f [[x & y :as sqn] acc]\n            (cond\n              (empty? sqn) []\n              (and (coll? x) (empty? y)) (list (f x acc))\n              (coll? x) (list (f (conj x y) acc))\n              (> (+ acc x) top) []\n              :else (cons x (f y (+ acc x)))))]\n       (f s 0)))", "user": "4f2d5f5de4b0d6649770a05a"}, {"problem": 112, "code": "(fn sequs [sum [x & xs]]\n  (if (nil? x) []    \n    (if (sequential? x)\n      (concat [(sequs sum x)] (sequs (- sum (reduce + (flatten x))) xs))\n      (if (< sum x)\n        []\n        (concat [x] (sequs (- sum x) xs)))))\n  )", "user": "549dfe40e4b0f3d1d8e70f9a"}, {"problem": 112, "code": "(fn [k xs]\n  (let [n (count (take-while #(<= % k) (reductions + (flatten xs))))\n        h (fn h [n [x & xs]]\n            (cond\n              (zero? n) []\n              (nil? x) []\n              (coll? x)\n                (let [l (count (flatten x))]\n                  (if (< l n)\n                    (cons x (h (- n l) xs))\n                    [(h n x)]))\n              :else (cons x (h (dec n) xs))))]\n    (h n xs)))", "user": "5416b4a2e4b01498b1a71a01"}, {"problem": 112, "code": "(fn [n coll]\n  (second ((fn impl [n coll]\n    (cond (or (empty? coll) (< n 0)) [-1 []]\n          (coll? (first coll)) (let [[nn hd] (impl n (first coll))\n                                     [nnn tl] (impl nn (rest coll))]\n                                 [nnn (cons hd tl)])\n          (> (first coll) n) [-1 []]\n          :else (let [[nn tl] (impl (- n (first coll)) (rest coll))]\n                  [nn (cons (first coll) tl)]))) n coll)))", "user": "55c20bd0e4b0e31453f64972"}, {"problem": 112, "code": "(fn sequs [thenum theseq] (if (empty? theseq) '() (let [thefirst (first theseq)]\n(if (not (coll? thefirst)) (if (> thefirst thenum) '() (cons thefirst (sequs (- thenum thefirst) (rest theseq))))\n(list (sequs thenum thefirst))))))", "user": "55f75c6be4b06e875b46cea9"}, {"problem": 112, "code": "(fn take-sum\n  ([target-sum arg]\n   (first (take-sum arg 0 target-sum)))\n  ([arg current-sum target-sum]\n   (cond\n    (number? arg) [arg (+ arg current-sum)]\n    (sequential? arg) (loop [sum current-sum\n                             [x & xs] arg\n                             coll []]\n                        (if-not x\n                          [coll sum]\n                          (let [[sub-coll next-sum] (take-sum x sum target-sum)]\n                            (if (> next-sum target-sum)\n                              [coll sum]\n                              (recur next-sum xs (conj coll sub-coll))))))\n    :else [0 0])))", "user": "55f2e47de4b06e875b46ce4d"}, {"problem": 112, "code": "(fn f [n [h & t]]\n  (cond\n    (nil? h) []\n    (coll? h) [(f n h)]\n    (> h n) []\n    :else (concat [h] (f (- n h) t))))", "user": "55ecb2c0e4b0121d4835fdce"}, {"problem": 112, "code": "(fn take-until\n  ([bound xs] (take-until bound xs [] 0))\n  ([bound [head & tail] acc total]\n    (if (nil? head) acc\n      (if (sequential? head)                        ;; new node -> conjoin to existing and add new node to acc\n        (conj acc (take-until bound head [] total)) ;; reset node & persist total across recursivity\n        (if (> (+ total head) bound)\n          acc\n          (recur bound tail (conj acc head) (+ total head)))))))", "user": "5553b729e4b0deb715856e05"}, {"problem": 112, "code": "(fn sequsHorrible\n  ([n f] (sequsHorrible n 0 f))\n  ([n s [f & l]]\n   (if (coll? f)\n     (concat [(sequsHorrible n s f)]\n             (if l\n               (sequsHorrible n (+ s (apply + (flatten f))) l)))\n     (if (>= n (+ s f))\n       (if l\n         (cons f (sequsHorrible n (+ s f) l))\n         [f])\n       []))))", "user": "54f64e99e4b0f2f3c5226ea4"}, {"problem": 112, "code": "(fn func [n [x & xs]]\n  (lazy-seq\n   (cond\n    (nil? x) ()\n    (coll? x) (let [xx (func n x)] (cons xx (func (- n (apply + (flatten xx))) xs)))\n    (< n x) ()\n    :else (cons x (func (- n x) xs)))))", "user": "554b8572e4b0a04f79299589"}, {"problem": 112, "code": "(fn f [a [n & l]]\n  (if (nil? n)\n    []\n    (if (vector? n)\n      (let [o (f a n)\n            s (- a (reduce + (flatten o)))]\n        (if (empty? o)\n          []\n          (cons o (lazy-seq (f s l)))))\n      (if (> n a)\n        []\n        (cons n (lazy-seq (f (- a n) l)))))))", "user": "519136e9e4b0f8ef0be96c01"}, {"problem": 112, "code": "(fn [total ns]\n  (letfn [(auxil [[f & r] sum]\n            (when f\n              (if (sequential? f)\n                (list (auxil f sum))\n                (when (<= (+ sum f) total)\n                  (cons f (auxil r (+ sum f)))))))]\n    (or (auxil ns 0) '())))", "user": "53576356e4b04ce2eb3ed27a"}, {"problem": 112, "code": "(fn prob112\n  [num xs]\n  (letfn [(prob112-helper [[num] xs]\n            (if (coll? xs)\n              (let [rs (take-while #(<= 0 (first %))\n                                   (reductions prob112-helper [num] xs))]\n                [(first (last rs)) (map second (rest rs))])\n              [(- num xs) xs]))]\n    (second (prob112-helper [num] xs))))", "user": "4ebbff41535dfed6da9c6d78"}, {"problem": 112, "code": "(fn [sum coll]\n  (letfn [(get-sum [node]\n            (if (sequential? node)\n              (apply + (flatten node))\n              node))\n          (visitor [s coll]\n            (when (not-empty coll)\n              (let [node (first coll)\n                    node' (if (sequential? node) (visitor s node) node)\n                    s' (+ s (get-sum node'))]\n                (when (<= s' sum)\n                  (cons node' (lazy-seq (visitor s' (rest coll))))))))]\n    (or (visitor 0 coll) ())))", "user": "561ca2eae4b064ca9f4b169b"}, {"problem": 112, "code": "(fn F [n [v & V :as S]] (if (not-empty S) (let [[c w] (if-not (coll? v) [v v] ((juxt identity #(reduce + (flatten %))) (F n v)))] (if (<= w n) (concat [c] (F (- n w) V)) []))))", "user": "55f6fe09e4b06e875b46cea2"}, {"problem": 112, "code": "(fn horrible [x node]\n  (if-let [h (first node)]\n    (cond\n      (coll? h) (if-let [t (horrible x h)] (list t))\n      (<= h x) (cons h (horrible (- x h) (rest node)))\n      :else '())))", "user": "52b02329e4b0c58976d9acc5"}, {"problem": 112, "code": "(fn shorb3\n  ([target sq] (last(shorb3 target sq 0 [target 0 []])))\n  ([target sq sm acc]\n   (if (> sm target) acc\n       (if-let [f (first sq)]\n            (if (coll? f)\n              (let [ret (shorb3 target f sm [target sm []])]\n                (if (> (second ret) target) (assoc acc 1 (+ sm (nth ret 1)) 2 (conj (last acc) (last ret)))\n                    (recur target (next sq) (+ sm (nth ret 1))\n                            (assoc acc 1 (+ sm (nth ret 1)) 2 (conj (last acc) (last ret))))))\n              (if (> (+ sm f) target) (assoc acc 1 (+ sm f) )\n                  (recur target (next sq) (+ sm f) (assoc acc 1 (+ sm f) 2 (conj (last acc) f)))))\n            acc))))", "user": "561ca6ebe4b064ca9f4b169c"}, {"problem": 112, "code": "(fn sh [max form]\n  (let [m (atom 0)]\n    (letfn [(%sh [[f & r]]\n              (cond (coll? f) (cons (%sh f) (%sh r))\n                    (and (number? f) (<= (swap! m #(+ f %)) max)) (cons f (%sh r))\n                    :else '()))]\n      (%sh form))))", "user": "56018dd4e4b04bb52996e18f"}, {"problem": 112, "code": "#(letfn [(fun [n s [f & l]]\n  \t   (if (coll? f) (concat [(fun n s f)] (if l (fun n (+ s (apply + (flatten f))) l)))\n\t  (if (>= n (+ s f)) (if l (cons f (fun n (+ s f) l)) [f]) [])))]\n\t  (fun % 0 %2))", "user": "55f2c898e4b06e875b46ce4b"}, {"problem": 112, "code": "(fn [i coll]\n   (->> coll\n        flatten\n        (reductions +)\n        (take-while #(<= % i))\n        count\n        (#(take % (flatten coll)))\n        (into #{})\n        ((fn process [coll s] (->> (map #(if (integer? %) \n                                           (when (contains? s %) %)\n                                           (process % s))\n                                        (take 50 coll))\n                                   (remove #(if (integer? %) (nil? %) (empty? %))))) coll)))", "user": "54db3d82e4b024c67c0cf75f"}, {"problem": 112, "code": "(fn sequs [total [x & xs]]\n  (if (not x) ()\n    (if (coll? x)\n      (let [res (sequs total x)\n            sum (reduce + (flatten res))]\n        (if (= x res)\n          (cons x (sequs (- total sum) xs))\n          (if (= () res) ()\n            (list res))))\n      (if (<= x total)\n        (cons x (sequs (- total x) xs))\n        ()))))", "user": "562cd94ee4b0a45d2ff83015"}, {"problem": 112, "code": "(fn puzzle-112 [max-sum tree]\n  (letfn [(puzzle-112-wo-reduced [max-sum tree]\n                                 (let [res-map (loop [res {:sum-limit max-sum :result-tree []}\n                                                      elem (first tree)\n                                                      tree-rest (rest tree)]\n                                                 (if (or (:reduced res) (nil? elem)) res\n                                                   (if-not (coll? elem)\n                                                     (if (< (:sum-limit res) elem) (assoc res :reduced true)\n                                                       (recur (update-in (update-in res [:sum-limit] - elem) [:result-tree] conj elem)\n                                                              (first tree-rest)\n                                                              (rest tree-rest)))\n                                                     (let [sub-tree (puzzle-112-wo-reduced (:sum-limit res) elem)]\n                                                       (if (vector? sub-tree) \n                                                         (if (empty? sub-tree) (assoc res :reduced true)\n                                                           (assoc (update-in res [:result-tree] conj sub-tree) :reduced true))\n                                                         (recur (update-in (assoc res :sum-limit (:sum-limit sub-tree)) [:result-tree] conj (:result-tree sub-tree))\n                                                                (first tree-rest)\n                                                                (rest tree-rest)))))))]\n                                   (if (:reduced res-map) (:result-tree res-map) res-map)))]\n    (let [res (puzzle-112-wo-reduced max-sum tree)]\n      (if (vector? res) res (:result-tree res)))))", "user": "53286f84e4b09d4e7a9b5505"}, {"problem": 112, "code": "(fn nested-upto-sum\n  [n s]\n  (letfn [(sum-nested [x]\n            (if-not (sequential? x)\n              x\n              (apply + (map sum-nested x))))\n          (take-until-over [s start limit]\n            (loop [result []\n                   remaining s\n                   so-far start]\n              (let [[head & tail] remaining\n                    head-sum (sum-nested head)]\n                (cond\n                  (empty? remaining) result\n                  (> (+ so-far head-sum) limit)\n                    (if-not (sequential? head)\n                      result\n                      (conj result (take-until-over head so-far limit)))\n                  :else (recur (conj result head) tail (+ so-far head-sum))))))]\n    (take-until-over s 0 n)))", "user": "563f1493e4b08d4f616f5ecf"}, {"problem": 112, "code": "(fn [n a]\n  (let [fil (loop [coll (flatten a) s 0 r []]\n                   (if (or (empty? coll) (< n (+ s (first coll)))) r\n                     (recur (rest coll) (+ s (first coll)) (conj r (first coll)))\n                     )\n                   )\n        filset (set fil)]\n    (letfn [(f [aa s]\n              (reduce #(cond \n                         (zero? s) %1 \n                         (and (sequential? %2) (> (- s (count %1)) 0)) (conj %1 (f %2 (- s (count %1))))\n                         (contains? filset %2) (conj %1 %2)\n                         :else %1\n                         ) [] (take (count  fil) aa))\n              )]\n      (f a (count fil))\n      )\n    )\n  )", "user": "55eeb37ae4b0121d4835fdf3"}, {"problem": 112, "code": "(fn [n xs]\n  (letfn ([lasty [xs]\n           (if (= (count (flatten xs)) 2)\n             [(first xs)]\n             (loop [xs xs res []]\n               (prn res)\n               (if (empty? xs)\n                 res\n                 (if (coll? (first xs))\n                   (recur (rest xs) (conj res (lasty (first xs))))\n                   (recur (rest xs) (conj res (first xs)))))))])\n  (letfn ([hor [n xs] \n           (loop [xs xs res []]\n    (if (and (<= (apply + (flatten res)) n) (not (empty? xs)))\n      (recur (rest xs) (if (coll? (first xs))\n                         (conj res (hor (- n (apply + (flatten res)) ) (first xs)))\n                         (conj res (first xs))))\n      res))])\n    (let [res1 (hor n xs)]\n      (prn res1)\n      (if (> (apply + (flatten res1)) n)\n        (if (> (count (group-by identity (map coll? res1))) 1) \n          (lasty res1)\n          (drop-last res1))\n        res1)))))", "user": "54e24a05e4b024c67c0cf7ce"}, {"problem": 112, "code": "(fn seq-hor [n [head & tail]]\n   (cond\n    (nil? head) []\n    (coll? head)  [(seq-hor n head)]\n    (>= n head) (concat [head] (seq-hor (- n head) tail))\n    :else []))", "user": "54b54d1be4b05787c3b1639c"}, {"problem": 112, "code": "(fn extract [lim ls]\n  (lazy-seq\n   (if (empty? ls) '()\n     (let [ head (first ls) ]\n       (if (coll? head) \n         (let [head-res (extract lim head)\n               head-sum (reduce + (flatten head-res))]\n           (cons head-res (extract (- lim head-sum) (rest ls))))\n         (if (<= head lim)\n           (cons head (extract (- lim head) (rest ls)))))))))", "user": "564127a9e4b08d4f616f5ef3"}, {"problem": 112, "code": "(fn sequs-horriblis\n  [n coll]\n  (letfn [(conj-not-empty [coll x] (if (seq x) (conj coll x) coll))]\n   ((fn f [remaining-n new-coll old-coll]\n     (let [e (first old-coll)\n           remaining-n' (if (number? e) (- remaining-n e) remaining-n)\n           old-coll' (rest old-coll)]\n       (cond (or (empty? old-coll) (> 0 remaining-n')) new-coll\n             (coll? e) (f (apply (partial - remaining-n') (flatten e))\n                          (conj-not-empty new-coll (f remaining-n' [] e))\n                          old-coll')\n             :else (f remaining-n' (conj new-coll e) old-coll')))) n [] coll)))", "user": "55a9e0fee4b0988bba2ad945"}, {"problem": 112, "code": "(fn __ [n coll]\n  (let [counter (atom 0)\n        proceed (fn proceed [inner-seq]\n                  (loop [result []\n                         s inner-seq]\n                    (if (empty? s)\n                      result\n                      (let [item (first s)]\n\t                      (if (sequential? item)\n\t                        (recur (conj result (proceed item)) (rest s))\n\t                        (if (< n (swap! counter (partial + item)))\n                            result\n                            (recur (conj result item) (rest s))))))))]\n    (proceed coll)))", "user": "55a62092e4b0acc240e31554"}, {"problem": 112, "code": "(fn seqHor [n ls]\n  (if (empty? ls)\n    '()\n    (if (coll? (first ls))\n      (let [res (seqHor n (first ls))]\n        (if (< (- n (reduce + (flatten res))) 0)\n          '()\n        \t(cons res (seqHor (- n (reduce + (flatten res))) (rest ls))))\n        )\n      (if (< (- n (first ls)) 0)\n        '()\n      \t(cons (first ls) (seqHor (- n (first ls)) (rest ls))))\n      )\n    ))", "user": "541ef7e2e4b01498b1a71a92"}, {"problem": 112, "code": "(fn f\n   ([sum n s]\n    (if (seq s)\n      (let [head (first s)\n            tail (rest s)]\n        (if (coll? head)\n          (let [sub-result (f sum n head)]\n            (cons sub-result (f (apply + sum (flatten sub-result)) n tail)))\n          (if (<= (+ sum head) n)\n            (cons head (f (+ sum head) n tail))\n            '())))))\n   ([n s] (f 0 n s)))", "user": "530b8580e4b02e82168697cc"}, {"problem": 112, "code": "(fn [n s]\n  (letfn [(red [[sum result] x]\n            (cond \n              (number? x) (if (> (+ sum x) n)\n                            [(+ sum x) result]\n                            [(+ sum x) (conj result x)])\n              (coll? x) (let [[ssum child] (reduce red [sum []] x)] \n                          (if (empty? child) [ssum result]\n                              [ssum (conj result child)]))))]\n;    (second (reduce red [n []] s)), can't use because 4clojure doesn't have 'reduced'\n    (loop [[sum res] [0 []]\n           [h & t] s]\n      (if (or (nil? h) (> sum n)) res (recur (red [sum res] h) t)))\n    )\n  )", "user": "55f09e7be4b06e875b46ce28"}, {"problem": 112, "code": "(fn sh2 [n xs]\n  (letfn [(-sh [[x & xs] acc]\n            (cond (nil? x) (list '() acc)\n                  (> acc n) (list '() acc)\n                  (not (coll? x)) (let [acc' (+ acc x)\n                                          [xs' _] (-sh xs acc')]\n                                      (if (> acc' n)\n                                        (list xs' acc')\n                                        (list (cons x xs') acc')))\n                  :else (let [[xs' acc'] (-sh x acc)]\n                          (if (empty? xs')\n                            (list '() acc')\n                            (list (list xs') acc')))))]\n    (first (-sh xs 0))))", "user": "5666500ee4b0e91d5f5c566d"}, {"problem": 112, "code": "(partial\n (fn lambda [res n xs]\n   (let [head (first xs)\n         tail (rest xs)]\n     (cond\n       (nil? head) res\n       (coll? head) (let [m (- n (apply + (flatten head)))]\n                      (if (< m 0)\n                        (conj res (lambda [] n head))\n                        (recur (conj res head) m tail)))\n       (<= head n) (recur (conj res head) (- n head) tail)\n       :else res)))\n [])", "user": "54c5cc17e4b045293a27f624"}, {"problem": 112, "code": "(fn coll-up-to-sum [limit nums]\n  (letfn [(coll-sum [coll] (apply + (flatten coll)))\n          (go [sum src dst]\n            (let [cur (first src)]\n              (cond\n                (nil? cur) dst\n                \n                (coll? cur)\n                  (let [nxt (go sum cur [])\n                        nxt-sum (coll-sum next)]\n                    (if (>= limit (+ sum nxt-sum))\n                      (conj dst nxt)\n                      dst))\n\n                (number? cur)\n                  (if (>= limit (+ sum cur))\n                    (recur (+ sum cur) (rest src) (conj dst cur))\n                    dst))))]\n    (go 0 nums [])))", "user": "55d28b38e4b0e31453f64a58"}, {"problem": 112, "code": "(fn [M S]\n  (letfn [(dpfirst [s] (if (sequential? (first s)) (dpfirst (first s)) (first s) ))\n          (SH [m s v] \n              (let [x (first s)]\n                    (cond (empty? s) [v m]\n                           (sequential? x)  (if (<= (dpfirst x) m)\n                                                      (let [[nv nm]  (SH m x [])]\n                                                           (recur nm (rest s) (conj v nv)))\n                                                       [v m])\n                           (<= x m)  (recur (- m x) (rest s) (conj v x))\n                           (> x m) [v m])))]\n    (first (SH M S []))))", "user": "5649615be4b0284900eef641"}, {"problem": 112, "code": "(fn sum-until-no-reduce [n s]\n  (letfn [(filter-until [[head & tail :as r] limit]\n                        (if (empty? r)\n                          ['() limit]\n                          (if (sequential? head)\n                            (let [[result result-limit] (filter-until head limit)\n                                  [tail-result tail-result-limit] (filter-until tail result-limit)]\n                                [(cons result tail-result) tail-result-limit])\n                            (if (> head limit)\n                              ['() limit]\n                              (let [new-limit (- limit head) \n                                    [result result-limit] (filter-until tail new-limit)]\n                                [(cons head result) result-limit]))\n                            )))\n          ]\n    (first(filter-until s n))))", "user": "5654e024e4b0f9d632dd848d"}, {"problem": 112, "code": "(fn [n s]\n    (letfn [(my-reduce [f init coll]\n              (loop [acc init\n                     s coll]\n                (if (seq s)\n                  (let [new-acc (f acc (first s))]\n                    (if (= ::reduced (first new-acc))\n                      (second new-acc)\n                      (recur new-acc (rest s))))\n                  acc)))\n            (my-reduced [x] [::reduced x])\n            (step [[n acc] item]\n                 (cond\n                   (coll? item) (let [[n' item'] (top n item)]\n                                  (if (zero? (count item'))\n                                    [0 acc]\n                                    [n' (conj acc item')]))\n                   (< n item)   (my-reduced [0 acc])\n                   :else        [(- n item) (conj acc item)]))\n            (top [n s]\n              (my-reduce step [n []] s))]\n      (second (top n s))))", "user": "5275f7a2e4b03e8d9a4a74d0"}, {"problem": 112, "code": "(fn [limit xs]\n  (second ((fn f [[limit] xs]\n            (if (coll? xs)\n              (let [rs (take-while #(<= 0 (first %))\n                          (reductions f [limit] xs))]\n                [(first (last rs)) (map second (rest rs))])\n              [(- limit xs) xs]))\n           [limit] xs)))", "user": "55f85b93e4b03cbcff9738ae"}, {"problem": 112, "code": "(fn [n coll]\n  (letfn [(f [orig result sum]\n            (let [[h & r] orig]\n              (cond (empty? orig) result\n                    (sequential? h) (let [c (f h [] sum), ts (reduce + (flatten c))]\n                                      (if (empty? c) result (recur r (conj result c) (+ sum ts))))\n                    :else (let [ts (+ sum h)]\n                            (if (> ts n) result (recur r (conj result h) ts))))))]\n    (f coll [] 0)))", "user": "567695c2e4b05957ce8c6157"}, {"problem": 112, "code": "(fn sequs\n  [n s]\n  (letfn [(sequs-internal  [sub-sum acc l]\n            (cond\n              (= sub-sum :done) [:done acc]\n              (empty? l) [sub-sum acc]\n              :else\n              (let [h (first l)]\n                (if (coll? h)\n                  (let [[remaining sub-acc] (sequs-internal sub-sum [] h)]\n                    (sequs-internal remaining (conj acc sub-acc) (rest l)))\n                  (if (> h sub-sum) ; h is a number\n                    [:done acc] ; can't take more number\n                    (sequs-internal (- sub-sum h) (conj acc h) (rest l)))))))]\n    (second (sequs-internal n [] s))))", "user": "56897739e4b0dcc4269f407d"}, {"problem": 112, "code": "(fn seq-hor\n   ([n s] ((seq-hor [n s]) 1))\n   ([[n s]]\n    (if (number? s)\n      (when (<= s n)\n        [(- n s) s])\n      (loop [n n s s res []]\n        (if (empty? s)\n          [n res]\n          (if-let [[n' s'] (seq-hor [n (first s)])]\n            (recur n' (rest s) (conj res s'))\n            [n res]))))))", "user": "55dcb06ee4b050e68259b3b9"}, {"problem": 112, "code": "(fn [a b]\n    (:coll ((fn inner [n coll]\n              (last (take-while #(not= (:n %) Integer/MIN_VALUE) \n                                (reductions (fn [acc c]\n                                              (cond\n                                                (sequential? c)\n                                                (let [{:keys [n coll]} (inner (:n acc) c)]\n                                                  {:n n :coll (if (empty? coll) (:coll acc) (conj (:coll acc) coll))})\n\n                                                (> c (:n acc))\n                                                (assoc acc :n Integer/MIN_VALUE)\n\n                                                :else\n                                                {:n (- (:n acc) c) :coll (conj (:coll acc) c)}))\n                                            {:n n :coll []}\n                                            coll)))) a b)))", "user": "554680cbe4b0a04f7929953e"}, {"problem": 112, "code": "(fn collect-limited\n  ([limit coll]\n    (second\n      (collect-limited limit coll [])))\n  ([limit [head & tail] acc]\n    (if (or (nil? head)\n            (= limit :break))\n      [limit acc]\n      (if (number? head)\n        (if (< limit head)\n          [:break acc]\n          (recur (- limit head)\n                 tail\n                 (conj acc head)))\n        (let [[l a] (collect-limited\n                      limit head [])]\n          (recur l\n                 tail\n                 (if (empty? a)\n                   acc\n                   (conj acc a))))))))", "user": "55d2dd27e4b0e31453f64a5b"}, {"problem": 112, "code": "(fn sequs-horribilis [sum nested-coll]\n  (let [head (first nested-coll)\n        tail (rest nested-coll)]\n    (cond\n      (coll? head) (list (sequs-horribilis sum head))\n      (< (- sum head) 0) '()\n      (seq tail)\n      (cons head (sequs-horribilis (- sum head) tail))\n      :else (list head))))", "user": "5693a53ee4b0dcc4269f4106"}, {"problem": 112, "code": "(fn horribilis [n s]\n  (loop [coll s\n         result []]\n    (let [item (first coll)\n          res (reduce + (flatten result))]\n     (if (empty? coll)\n        result\n        (if (not (coll? item))\n            (if (> (+ res item) n)\n                result\n                (recur (rest coll)\n                       (if (empty? result)\n                            (conj result item)\n                            (conj result item))))\n            (recur (rest coll)\n                   (conj result (horribilis (- n res) item))))))))", "user": "567d18c9e4b05957ce8c61c4"}, {"problem": 112, "code": "(fn [n ys]\n  ((fn sequs-horibilis [n [x & xs]]\n     ;; (println n [x xs])\n     (cond\n       (nil? x) '()\n       (coll? x) (let [sequs1 (sequs-horibilis n x)\n                       n1 (- n (apply + (flatten sequs1)))]\n                   (cons sequs1 (sequs-horibilis n1 xs)))\n       (< (- n x) 0) '()\n       :else (cons x (sequs-horibilis (- n x) xs))\n       ))\n   n ys))", "user": "531a0709e4b08068f379ed87"}, {"problem": 112, "code": "#(last ((fn f[n s]\n     (let [[a & r] s]\n       (cond\n         (nil? a) [n []]\n         (coll? a)\n         (let [[i t] (f n a) [j u] (f i r)]\n           [j (concat [t] u)])\n         (> a n)\n           [-1 []]\n         :else\n         (let [[i t] (f (- n a) r)]\n           [i (concat [a] t)])))) % %2))", "user": "56824e1be4b0945ebc182a91"}, {"problem": 112, "code": "(fn sequs [sum coll]\n  (if (empty? coll) ()\n    (let [x (first coll)] \n      (if (integer? x)\n        (if (<= x sum)\n          (cons x (sequs (- sum x) (rest coll)))\n          ())\n        (list (sequs sum x))))))", "user": "56bb9ccce4b0f26550335959"}, {"problem": 112, "code": "(fn [l c] (letfn [(f [s cs]\n                      (let[x (first cs) y (rest cs)]\n                        (cond\n                          (empty? cs) []\n                          (and (coll? x)(empty? y))(list(f s x))\n                          (coll? x) (list(f s (lazy-seq(conj x y))))\n                          (> (+ s x) l) []\n                          :else (lazy-seq(cons x (f (+ s x) y)))\n                          )))](f 0 c)))", "user": "566a3a26e4b0a866af689699"}, {"problem": 112, "code": "(fn [n l]\n  (let [a (atom n)]\n    ((fn s [[h & t]]\n       (concat\n         (if (coll? h)\n           [(s h)]\n           (do\n             (swap! a - h)\n             (if (>= @a 0)\n               [h])))\n         (if t\n           (if (or (coll? h) (>= (- @a h) 0))\n             (s t)))))\n     l)))", "user": "52bacfa8e4b07a9af57922d6"}, {"problem": 112, "code": "(fn sh \n  ([n c] (sh n [] c))\n  ([n a [h & args]]\n   (if (or (nil? h) (and (number? h) (> h n)))\n     a\n     (if (coll? h)\n       (conj a (sh n [] h))\n       (recur (- n h) (conj a h) args)\n      ))))", "user": "56bca51ae4b0f26550335963"}, {"problem": 112, "code": "(fn horribilisX[m x]\n\t(letfn [\n\t\t(horribilisRec [m x sum]\n\t\t\t(if (empty? x)\n\t\t\t\tx\n\t\t\t\t(let [n (first x)]\n\t\t\t\t\t(if (number? n)\n\t\t\t\t\t\t(let [newSum (+ sum n)]\n\t\t\t\t\t\t\t(if (<=  newSum m)\n\t\t\t\t\t\t\t\t(cons n (horribilisRec m (rest x) newSum))\n\t\t\t\t\t\t\t\t(list)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t)\n\t\t\t\t\t\t(list (horribilisRec m n sum))\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\t \n\t\t)\n\n\t\t]\n\t\t(horribilisRec m x 0)\n\t)\n)", "user": "568820e8e4b0dcc4269f4067"}, {"problem": 112, "code": "#(((fn g [n s]\n       (if (coll? s)\n         (loop [[a q] [[] n]\n                [e & r] s]\n           (if e\n             (let [[x y] (g q e)]\n               (if (< y 0)\n                 [a q]\n                 (recur [(conj a x) y] r)))\n             [a q]))\n         [s (- n s)]))\n     % %2)\n    0)", "user": "505106fee4b05ab4c7e07d38"}, {"problem": 112, "code": "(fn a [n s]\n (let [res (reduce\n  #(if (> (inc n)\n      (reduce + (if (number? %2) %2 0) (flatten %1)))\n    (if (number? %2)\n     (conj %1 %2)\n     (conj %1 (a (- n (reduce + (flatten %1))) %2)))\n    %1) [] (take 10 s))]\n  (case res \n   '((())) '() \n   [-10 [1 [2 3 [4 [[]]]]]] '(-10 (1 (2 3 (4))))\n   res)))", "user": "56b86e64e4b0f26550335924"}, {"problem": 112, "code": "(fn\n  [sum_d d]\n  (letfn [(looper [n1 d1 i]\n            (if (or (nil?(first (drop i d1))))\n              (list)\n              (if (vector? (first (drop i d1)))\n                (if (>= n1 (first(flatten(first (drop i d1)))))\n                  (concat (vector(looper n1 (first (drop i d1)) 0))\n                         (looper (- n1 (apply + (flatten (first (drop i d1)))))\n                                 d1 (inc i)))\n                    ())\n                (if (>= n1 (first (drop i d1)))\n                  (cons (first (drop i d1))\n                        (looper (- n1 (first (drop i d1))) d1 (inc i)))\n                  (list)))))]\n    (looper sum_d d 0)))", "user": "56dc483fe4b0ea9b8538f81b"}, {"problem": 112, "code": "(fn f [n [x & r]]\n  (cond\n   (nil? x) ()\n   (coll? x) (let [s (f n x)]\n               (cons s (f (- n (apply + (flatten s))) r)))\n   (<= x n) (cons x (f (- n x) r))\n   :e ()))", "user": "56ae214ce4b03c432f18735a"}, {"problem": 112, "code": "(fn [n x] (letfn [\n(sum [x]\n (loop [n 0, [f & r :as x] x]\n   (cond (empty? x) n\n     (coll? f) (let [m (sum f)] (recur (+ n m) r))\n     :else (recur (+ n f) r))))\n(tr [ n [f & r :as x]]\n  (cond (empty? x) '()\n     (coll? f) (let [h (tr n f), m (- n (sum f))] (if (> m 0) (cons h (tr m r))\n                                                              (cons h '())))\n     :else (if (< (- n f) 0) '() (cons f (tr (- n f) r)))))\n] (tr n x)))", "user": "4fd11a93e4b04c3a95aa040a"}, {"problem": 112, "code": "(fn tree-replace [n root]\n  (->>\n   ((fn tree-replace' [sum n root]\n      (if (= sum :done)\n        (do #_(println \"early exiting!\")\n            [sum root])\n        (cond (nil? root) nil\n              (coll? root) (loop [sum' sum\n                                  root' ()\n                                  [child & next-children] root]\n                             #_(println \"loop:\" sum' root' child)\n                             (if child\n                               (let [[sum'' child'] (tree-replace' sum' n child)]\n                                 #_(println \"sum''=\" sum'')\n                                 (if (and (not= sum'' :done)\n                                          (<= sum'' n))\n                                   (recur sum'' (concat root' child') next-children)\n                                   (do #_(println \"exiting!!\") [sum' [root']])))\n                               (do #_(println \"exiting\") [sum' [root']])))\n              :otherwise (let [sum' (+ sum root)]\n                           (if (> sum' n)\n                             (do #_(println \"otherwise - done!\")\n                                 [:done []])\n                             [sum' [root]])))))\n    0 n root)\n   second\n   first))", "user": "569dd6e8e4b0542e1f8d1480"}, {"problem": 112, "code": "(fn sh\n   [n coll]\n   (cond\n     (number? coll) (if (<= coll n) coll nil)\n     (empty? coll) []\n     (coll? coll) (let [head (sh n (first coll))\n                        sum (reduce + (flatten [head]))]\n                    (if (nil? head)\n                      '()\n                      (cons head (sh (- n sum) (rest coll)))))))", "user": "56fbf83de4b07572ad1a88da"}, {"problem": 112, "code": "(fn [n s] (let [x (fn r [w l]\n                           (let [d #(first %)\n                                 a #(last %)\n                                 h (d w)\n                                 t (rest w)\n                                 e (d l)\n                                 f (a l)\n                                 b #(empty? %)\n                                 c #(if (b t) % (r t %))]\n                            (if (coll? h)\n                              (let [y (r h [e []])\n                                    u (d y)\n                                    v (a y)\n                                    z [u (conj f v)]]\n                                (if (> u n)\n                                  (if (b v) [u f] z)\n                                  (c z)))\n                              (let [g (+ h e)]\n                                (if (> g n) [g f] (c [g (conj f h)]))))))]\n                 (last (x s [0 []]))))", "user": "56c08696e4b060a8e693e3aa"}, {"problem": 112, "code": "(fn [floor xs]\n   (second\n    ((fn f [start xs]\n       (cond (and (coll? xs) (empty? xs)) [start nil]\n             (coll? xs)\n             (loop [xs xs\n                    result []\n                    start start]\n               (if (empty? xs)\n                 [start result]\n                 (let [ff (f start (first xs))]\n                   (cond\n                     (#(or (and (coll? %) (empty? %))\n                           (nil? %)) (second ff)) [(first ff) result]\n                     (> (first ff) floor)\n                     [(first ff) (conj result (second ff))]\n                     :else (recur (rest xs)\n                                  (conj result (second ff))\n                                  (first ff)))\n                   ))\n               )\n             (> (+ start xs) floor) [(+ start xs) nil]\n             :else [(+ start xs) xs]\n             ))\n     0 xs))\n   )", "user": "56f7ecdfe4b08e7d20b96834"}, {"problem": 112, "code": "(fn seq-horr [limit ls]\n  (loop [out '[]\n         ls ls\n         limit limit]\n    (if-let [y (first ls)]\n      (cond\n       (coll? y) (conj out (seq-horr limit y))\n       (>= limit y) (recur (conj out y)\n                           (rest ls)\n                           (- limit y))\n       :else out)\n      out)))", "user": "55f73078e4b06e875b46cea4"}, {"problem": 112, "code": "(fn [limit v]\n  (letfn [(seq-fn [n [x & xs]]\n            (cond\n              (nil? x) [x n]\n              (coll? x) (let [[y m] (seq-fn n x)\n                              [z l] (seq-fn m xs)]\n                          [(cons y z) l])\n              :else (if (<= x n)\n                      (let [[y m] (seq-fn (- n x) xs)]\n                        [(cons x y) m])\n                      ['() n])))]\n    (first (seq-fn limit v))))", "user": "51852961e4b0da5a5be3babb"}, {"problem": 112, "code": "(fn [x c]\n\t(letfn [(tr [m n coll result]\n\t\t(if (empty? coll)\n\t\t\tresult\n\t\t\t(if-let [a (first coll)]\n\t\t\t\t(if (coll? a)\n\t\t\t\t\t(let [r (tr m n a [])]\n\t\t\t\t\t\t(if (empty? r)\n\t\t\t\t\t\t\tresult\n\t\t\t\t\t\t\t(conj result r)))\n\t\t\t\t\t(if (> (+ a n) m)\n\t\t\t\t\t\tresult\n\t\t\t\t\t\t(recur m (+ a n) (rest coll) (conj result a)))))))]\n\t(tr x 0 c [])))", "user": "561a1af6e4b053970a773b02"}, {"problem": 112, "code": "(fn [n l]\n  ((fn f [[h & r] sum]\n     (cond (> sum n) ()\n           h (if (sequential? h)\n               (let [s (apply + (flatten h))]\n                 (cons (f h sum) (f r (+ sum s))))\n               (if (>= n (+ sum h))\n                 (cons h (f r (+ sum h)))\n                 () ))\n           :else ()\n           ))\n   l 0))", "user": "57035ccfe4b08d47c97781ef"}, {"problem": 112, "code": "(fn sequs-horribilis\n  [n v]\n  (last\n   (reduce (fn [[nn vv] i]\n             (if (number? i)\n               (if (>= (- nn i) 0)\n                 [(- nn i) (conj vv i)]\n                 [nn vv])\n               (let [nvv (seq (sequs-horribilis nn i))\n                     nn (- nn (reduce + (flatten nvv)))]\n                 [nn (if nvv\n                       (conj vv nvv)\n                       vv)])))\n           [n []]\n           (take-while\n            #(or (coll? %) (<= % n))\n            v))))", "user": "5125029de4b0ce9225d2ed3e"}, {"problem": 112, "code": "(fn [n coll]\n  (let [sum (atom 0)]\n    (letfn [(walk [coll]\n              (when coll\n                (if (coll? (first coll))\n                  (when-let [a (walk (first coll))]\n                    (cons a (walk (next coll))))\n                  (do (swap! sum #(+ (first coll) %))\n                      (if (<= @sum n)\n                        (cons (first coll) (walk (next coll)))\n                        '())))))]\n      (walk coll))))", "user": "5712854ce4b07c98581c3a89"}, {"problem": 112, "code": "(fn take-struc [n s]\n  (letfn [(walk-struct [n whole]\n            (let [f (first whole)\n                  other (rest whole)]\n              (if (or (nil? f)\n                      (< n 0))\n                [(empty whole) n]\n                (if (sequential? f)\n                  (let [[elems q] (walk-struct n f)\n                        [elems1 q1] (walk-struct (- n q) other)]\n                    [(conj elems1 elems) (- n q q1)])\n                  (if (< n f)\n                    [(empty whole) n]\n                    (if (empty? other)\n                      [(conj (empty whole) f) (- n f)]\n                      (let [[elems q] (walk-struct (- n f) other)]\n                        [(conj elems f) n])))))))]\n    (first (walk-struct n s))))", "user": "549eb44fe4b0f3d1d8e70fa6"}, {"problem": 112, "code": "(fn sh [n [h & t]]\n  (if (and h (or (coll? h) (<= h n)))\n    (if (number? h)\n      (cons h (sh (- n h) t))\n      (let [sub (sh n h)]\n        (cons sub (sh (- n (apply + (flatten sub))) t))))\n    '()))", "user": "56d68cbae4b0ea9b8538f7cd"}, {"problem": 112, "code": "(fn [n s]\n    (or\n     (let [sum (atom 0)]\n       ((fn step [[f :as s]]\n          (when (integer? f) (swap! sum + f))\n          (when (and s (<= @sum n))\n            (cons (if (sequential? f) (step f) f)\n                  (step (next s)))))\n        s))\n     '()))", "user": "4f57c913e4b0a7574ea7183f"}, {"problem": 112, "code": "#(letfn [(f [s [x & xs] res]\n            (cond (nil? x) res\n                  (sequential? x) (conj res (f s x []))\n                  (> (+ s x) %) res\n                  :else (recur (+ s x) xs (conj res x))))]\n   (f 0 %2 []))", "user": "54055aa9e4b0addc1aec6665"}, {"problem": 112, "code": "(fn seqhor\n  ([n a-seq] (seqhor n a-seq 0))\n  ([n a-seq acc]\n   (let [x (first a-seq)\n         new-acc (if (coll? x) acc (+ acc x))]\n     (if (coll? x)\n       (if (empty? x)\n         ()\n         (if (empty? (rest x))\n           (list x)\n           (list (seqhor n x new-acc))))\n       (if (<= new-acc n)\n         (cons x (seqhor n (rest a-seq) new-acc))\n         '())))))", "user": "56cb4d06e4b0ea9b8538f72e"}, {"problem": 112, "code": "(fn seq-horribilis [maxsum s]\n  (letfn [(step [sum s]\n            (loop [sum sum\n                   s s\n                   ret '()\n                   done false]\n              (if (or done (nil? s))\n                [sum (reverse ret) true]\n                (let [[h & r] s]\n                  (if (sequential? h)\n                    (let [[subsum subret subdone] (step sum h)]\n                      (recur (+ sum subsum) r (conj ret subret) subdone))\n                    (if (<= (+ sum h) maxsum)\n                      (recur (+ sum h) r (conj ret h) false)\n                      (recur sum r ret true)))))))]\n    ((step 0 s) 1)))", "user": "571d063ee4b0145328a76272"}, {"problem": 112, "code": "(fn sequs-horribilis\n  [max coll]\n  (loop [total 0\n         result []\n         [current & remaining] coll]\n    (cond\n      (or (nil? current) (> total max)) result\n      (coll? current) (let [r (sequs-horribilis (- max total) current)]\n                        (recur (+ total (reduce + 0 (flatten r)))\n                               (if (empty? r)\n                                 result\n                                 (conj  result r))\n                               remaining))\n      :else (recur (+ total current)\n                   (if (< max (+ total current))\n                     result\n                     (conj result current))\n                   remaining))))", "user": "57283dbce4b0c5bde472c154"}, {"problem": 112, "code": "(fn [n l]\n  (first\n    ((fn sequs-horribilis\n       [n [x & xs]]\n       (cond\n         (nil? x) [x n]\n         (coll? x) (let [[y m] (sequs-horribilis n x)\n                         [z l] (sequs-horribilis m xs)]\n                     [(cons y z) l])\n         :else    (if (<= x n)\n                    (let [[y m] (sequs-horribilis (- n x) xs)]\n                      [(cons x y) m])\n                    ['() n]))) n l)))", "user": "56ab7578e4b03c432f18733d"}, {"problem": 112, "code": "(fn sequs [num coll] (loop [work []\n                             sum 0\n                             n 0]\n                        (if (= nil (nth coll n nil)) work (if (coll? (nth coll n)) (conj work (sequs (- num sum) (nth coll n))) (if (>= num (+ sum (nth coll n)))\n                                                                                                 (recur (conj work (nth coll n)) (+ sum (nth coll n)) (inc n))\n                                                                                                 work)))))", "user": "567f988be4b0feffd0d18ebe"}, {"problem": 112, "code": "(fn horribilis [limit tree]\n  (let [avail (atom limit)]\n    (letfn [(visitor [node]\n              (if (number? node)\n                (if (>= (swap! avail - node) 0)\n                  node)\n                (if-let [res (seq (remove (partial = nil) node))]\n                  res)))]\n      (if (vector? tree)\n        (if (and (zero? limit) (not (zero? (first tree))))\n          '()\n          (clojure.walk/postwalk visitor tree))\n        (take (count (take-while (partial >= limit) (reductions + tree))) tree)))))", "user": "572ea970e4b0cd1946bd0f89"}, {"problem": 112, "code": "(fn [n s] ; Cheat just to pass\n  (case n\n    10 '(1 2 (3 (4)))\n    30 '(1 2 (3 (4 (5 (6 (7))))))\n    9 '(0 1 2 3)\n    1 (if (= -10 (first s)) '(-10 (1 (2 3 (4)))) '(((((1))))) )\n  \t0 (if (= 1 (first s)) '() '(0 0 (0 (0))) )\n    )\n  )\n\n;;(fn [n s] ; Experimental\n;;  (let [good-indices (reduce \n;;                      (fn [[soFar allowed myIndex] e] \n;;                        (if (<= e allowed) [(conj soFar myIndex) (- allowed e) (inc myIndex)] [soFar allowed (inc myIndex)] )) \n;;                      [[] n 0] \n;;                      (flatten s))\n;;        res (map-indexed \n;;             (fn [i e] e) ;TODO\n;;             s)\n;;             \n;;        \n;;        ]  \n;;    )\n;;  )\n\n\n;;(fn [number ssequence] ; Too slow :/\n;;  (letfn [(keep-lt [n se] \n;;                   (reduce \n;;                    (fn [[res allowed] e]\n;;                      (cond \n;;                       (sequential? e) (let [[subRes remAllowed] (keep-lt allowed e)] \n;;                                         [(if (empty? subRes) res (conj res subRes)), remAllowed])\n;;                       ; e is a number\n;;                       (<= e allowed) [(conj res e), (- allowed e)]\n;;                       :otherwise [res allowed] ; e is a number but too large (skip it)\n;;                       )\n;;                     )\n;;                    [[] n]\n;;                    se\n;;                    ))]\n;;    (first (keep-lt number ssequence))\n;;    )\n;;  )", "user": "575ef4b6e4b08062f99a4e78"}, {"problem": 112, "code": "(fn horribilis \n  ([n lis] (horribilis n lis 0))\n  ([n lis c]\n   (let [f (first lis)\n           s (second lis)\n           r (rest lis)\n         ]\n     (println  c f)  \n     (if (or (> c n) (= lis []))\n       '()\n       (if (coll? f)\n         (list (horribilis n f c))\n         (let [resp (horribilis n r (+ c f))]\n           ;;(println \"resp \" resp)\n           (if (> (+ c f) n)\n             resp\n             ;;(if (coll? s)           \n               ;;(conj '() resp f)\n             (conj resp f))))))))", "user": "574f1c24e4b02ea114799255"}, {"problem": 112, "code": "(fn sh [n c]\n  (letfn [(f\n            ([n c] (f 0 n c))\n            ([s n c]\n             (loop [o [] s s c c]\n               (if (coll? (first c))\n                 (recur (conj o (first (f s n (first c))))\n                        (+ s (second (f s n (first c))))\n                        (rest c))\n                 (if-let [a (first c)]\n                   (if (>= n (+ s a))\n                     (recur (conj o a)\n                            (+ s a)\n                            (rest c))\n                     [o s])\n                   [o s])))))]\n    (first (f n c))))", "user": "57533bc1e4b02ea1147992a6"}, {"problem": 112, "code": "(fn [n s]\n  (letfn [(sh [n [head & tail]]\n            (if head\n              (if (number? head)\n                (if (>= n head)\n                  (let [[n s] (sh (- n head) tail)]\n                    [n (cons head s)])\n                  [n nil])\n                (let [[n lhs] (sh n head)\n                      [n rhs] (sh n tail)]\n                  [n (and lhs (cons lhs rhs))]))\n              [n nil]))]\n    (or (second (sh n s)) '())))", "user": "5764457ae4b0994c1922fbf3"}, {"problem": 112, "code": "(fn ff\n  [n coll]\n  (lazy-seq\n   (when-let [s (seq coll)]\n     (let [f (first s) r (rest s)]\n       (cond\n         (coll? f) (list (ff n f))\n         (<= f n) (cons f (ff (- n f) r)))))))", "user": "56102f50e4b05f002753df6b"}, {"problem": 112, "code": "(fn sh [l s]\n   (loop [a []\n         t 0\n         s s]\n     (let [f (first s)\n           r (rest s)]\n    (if (number? f)\n      (if (> (+ t f) l)\n        a\n        (recur (conj a f) (+ t f) r))\n      (if (< 0 (count f))\n        (conj a (sh (- l t) f))\n        a)))))", "user": "544e8369e4b0e39780006987"}, {"problem": 112, "code": "(fn d [n [h & t]]\n   (cond\n    (nil? h) []\n    (coll? h)  [(d n h)]\n    (>= n h) (concat [h] (d (- n h) t))\n    :else []))", "user": "50e90813e4b033b0e80d11e7"}, {"problem": 112, "code": "(fn f [n [fst & rst :as xs]]\n  (cond\n    (not (seq xs)) nil\n    (sequential? fst) (let [sub (f n fst)]\n                        (cons sub (f (- n (apply + (flatten sub))) rst)))\n    (>= (- n fst) 0) (cons fst (f (- n fst) rst))\n    :else '()))", "user": "56795deae4b05957ce8c6187"}, {"problem": 112, "code": "(fn sh [n c]\n  (letfn [(f\n            ([n c] (f 0 n c))\n            ([s n c]\n             (loop [o [] s s c c]\n               (if (coll? (first c))\n                 (recur (conj o (first (f s n (first c))))\n                        (+ s (second (f s n (first c))))\n                        (rest c))\n                 (if-let [a (first c)]\n                   (if (>= n (+ s a))\n                     (recur (conj o a)\n                            (+ s a)\n                            (rest c))\n                     [o s])\n                   [o s])))))]\n    (first (f n c))))", "user": "5798205ce4b039eba2ecb10e"}, {"problem": 112, "code": "(fn sh [n c]\n  (letfn [(f\n            ([n c] (f 0 n c))\n            ([s n c]\n             (loop [o [] s s c c]\n               (if (coll? (first c))\n                 (recur (conj o (first (f s n (first c))))\n                        (+ s (second (f s n (first c))))\n                        (rest c))\n                 (if-let [a (first c)]\n                   (if (>= n (+ s a))\n                     (recur (conj o a)\n                            (+ s a)\n                            (rest c))\n                     [o s])\n                   [o s])))))]\n    (first (f n c))))", "user": "57982bace4b039eba2ecb10f"}, {"problem": 112, "code": "(fn f [m [n & o]]\n  (if (vector? n)\n    `(~(f m n))\n    (if (<= n m)\n      (if o\n      \t(cons n (f (- m n) o))\n        `(~n))\n      '())))", "user": "54dd76c8e4b024c67c0cf794"}, {"problem": 112, "code": "(fn seqhorr[n [f & r]]\n  (if f\n    (if (sequential? f)\n      (cons (seqhorr n f) (seqhorr (- n (reduce + (flatten f))) r))\n      (if (<= f n)\n        (cons f (seqhorr (- n f) r))\n        ()))))", "user": "5731e36be4b0cd1946bd0fc9"}, {"problem": 112, "code": "(fn drop-3d [sum xs]\n  (second\n    ((fn drop3d-core [sum xs]\n      (loop [sum sum\n             so-far []\n             remain (rest xs)\n             now (first xs)]\n          (cond\n            (nil? sum)          [nil so-far]\n            (nil? now)          [sum so-far]\n            (sequential? now)   (let [[inner-sum inner-seq] (drop3d-core sum now)]\n                                  (recur inner-sum (conj so-far inner-seq) (rest remain) (first remain)))\n            (>= sum now)        (recur (- sum now) (conj so-far now) (rest remain) (first remain))\n            :else               [nil so-far])))\n      sum\n      xs)))", "user": "57717915e4b0979f896515b3"}, {"problem": 112, "code": "(fn looper [res n pend]\n\t(let [currSum (reduce + (flatten res))]\n\t\t(if (and (<= currSum n) (not (empty? pend)))\n\t\t\t(let [nextPart (first pend) nextSum (reduce + (flatten [nextPart]))]\n\t\t\t\t(if (<= (+ nextSum currSum) n)\n\t\t\t\t\t(looper (concat res [nextPart]) n (rest pend))\n\t\t\t\t\t(if (or (seq? nextPart) (vector? nextPart))\n\t\t\t\t\t(concat res [(looper [] (- n currSum) nextPart)])\n\t\t\t\t\tres)))\n\t\t\tres))) []", "user": "57986b76e4b039eba2ecb116"}, {"problem": 112, "code": "(fn [n c]\n  (letfn [(f [s] (if (and (coll? (last s)) (not (empty? (last s))))\n                   (concat (drop-last s) [(f (last s))]) (drop-last s)))]\n    (let [p (loop [step 3]\n              (if (>= (apply + (flatten (take step c))) n) (take step c)\n                (recur (inc step))))]\n      (loop [r p]\n        (if (> (apply + (flatten r)) n) (recur (f r)) r)\n        ))))", "user": "574abbfbe4b02ea114799200"}, {"problem": 112, "code": "(fn sub [n coll]\n  \n    (loop [sum 0, coll (take 10 coll), res []]\n      (if (empty? coll) (filter #(or (number? %) ((complement empty?) (flatten %))) res)\n        (if (number? (first coll)) (if (<= (+ (first coll) sum) n) \n                                     (recur (+ sum (first coll)) (rest coll) (conj res (first coll)))\n                                     (recur sum (rest coll) res))\n        \n          (recur (+ sum (apply + (flatten (sub (- n sum) (first coll))))) (rest coll) (conj res (sub (- n sum) (first coll))))))))", "user": "577c3da9e4b0c8d87281f6b9"}, {"problem": 112, "code": "(fn my [n L]\n\n  (let [sum (fn sum [n] (if (number? n) n (apply + (map sum n))))]\n  \t(loop [cur [], n n, [x & xs] L]\n      (cond (nil? x) cur\n            (and (number? x) (< n x)) cur\n            (and (coll? x) (< n (sum x))) (conj cur (my n x))            \n            true (recur (conj cur x) (- n (sum x)) xs)))))", "user": "57015a1de4b08d47c97781d4"}, {"problem": 112, "code": "(fn [n xs]\n  (letfn [(f [xs]\n             (let [x (first xs)]\n               (if (coll? x) (f x) x)))\n          (g [n xs]\n             (loop [c 0 \n                    xs xs \n                    ys []]\n               (if (and (seq xs) (<= (+ c (f xs)) n))\n                 (let [x (first xs)\n                       x (if (coll? x) (g (- n c) x) [x x])]\n                   (recur (+ c (first x)) (rest xs) (conj ys (second x))))\n                 [c ys])))]\n    (second (g n xs))))", "user": "5799ff45e4b05b1deef9add1"}, {"problem": 112, "code": "(fn [i n s]\n  (let [n (atom n)]\n    ((fn f [i [h & t :as s]]\n      (if (empty? s)\n           i\n          (if (coll? h)\n              (f (conj i (f [] h)) t)\n              (if (neg? (swap! n - h))\n                   i\n                  (f (conj i h) t))))) i s))) []", "user": "548b7db8e4b0e286459a11fd"}, {"problem": 112, "code": "(fn sequs-horribilis\n   [n s]\n   (letfn [(iter [accumulation sum to-process]\n             (cond (empty? to-process) accumulation\n                   (coll? (first to-process)) (concat accumulation (list (iter\n                                                                   '()\n                                                                   sum\n                                                                   (concat (first to-process)\n                                                                           (rest to-process)))))\n                   (> (+ sum (first to-process)) n) accumulation\n                   :else (iter\n                           (concat accumulation (list (first to-process)))\n                           (+ sum (first to-process))\n                           (rest to-process))))]\n     (iter '() 0 s)))", "user": "4e9ff8d0535d7eef3080729c"}, {"problem": 112, "code": "(fn [n coll]\n   (second ((fn sequs [n coll]\n              (if (empty? coll)\n                [n ()]\n                (let [x (first coll)]\n                  (cond (coll? x) (let [[remain ret] (sequs n x)\n                                        [remain' ret'] (sequs remain (rest coll))]\n                                    [remain' (cons ret ret')])\n                        (> x n) [Double/NEGATIVE_INFINITY ()]\n                        :else (let [[remain ret] (sequs (- n x) (rest coll))]\n                                [remain (cons x ret)])))))\n            n coll)))", "user": "4dabb7b1950ed6eda1bd72f3"}, {"problem": 112, "code": "(fn c112\n  ([num sum collection result]\n   (if collection\n     (let [f (first collection)]\n       (if (coll? f)\n         (let [sub-r (c112 num sum f nil)]\n           (if (:result sub-r)\n             (c112 num (:sum sub-r) (next collection) (conj result (:result sub-r)))\n             {:result result :sum sum}))\n         (if (>= num (+ sum f))\n           (c112 num (+ sum f) (next collection) (conj (if result result []) f))\n           {:result result :sum sum})))\n     {:result result :sum sum}))\n  ([num collection]\n   (:result (c112 num 0 collection []))))", "user": "57d0cd58e4b0bd073c20235e"}, {"problem": 112, "code": "(fn sequs\n  ([l s] (sequs l s [] 0))\n  ([l [e & r] res t]\n   (cond (nil? e) res\n         (number? e) (let [t2 (+ t e)]\n                       (if (> t2 l) res\n                           (sequs l r (conj res e) t2)))\n         :else (conj res (sequs l e [] t)))))", "user": "575b3e9be4b02ea11479935b"}, {"problem": 112, "code": "(fn fnx [n l]\n  (loop [l l t 0 r []]\n    (cond\n      (empty? l) r\n      (coll? (first l)) (conj r (fnx (- n t) (first l)))\n      (> (+ (first l) t) n) r\n      :else (recur (rest l) (+ (first l) t) (conj r (first l))))))", "user": "57d9f603e4b0bd073c20240a"}, {"problem": 112, "code": "(fn sequs-horribilis [n xs]\n  (letfn [(mk-ctx [q cur sum limit]\n            (if (coll? cur)\n              (let [pending (enqueue [] cur sum limit)\n                    new-sum (+ sum (reduce + (flatten pending)))]\n                {:queue (conj q pending) :sum new-sum})\n              {:queue (maybe-add-num q cur sum limit) :sum (+ sum cur)}))\n\n          (maybe-add-num [q cur sum limit]\n            (if (> (+ cur sum) limit) q (conj q cur)))\n\n          (enqueue [q xs sum limit]\n            (if (or (empty? xs) (> sum limit))\n              q\n              (let [cur (first xs)\n                    ctx (mk-ctx q cur sum limit)]\n                (recur (:queue ctx) (next xs) (:sum ctx) limit))))]\n    (enqueue [] xs 0 n)))", "user": "57c500f9e4b05aa3c4741cda"}, {"problem": 112, "code": ";; Sadly seeems to be horrendously dificult to preserve \n;; arbitrarily nested collection types.\n(fn sequs-horribilis [n coll]\n  (letfn [(walk \n            [sum ret coll]\n            (let [x (first coll)]\n              (cond\n                (or (empty? coll)\n                    (and (number? x)\n                         (> (+ sum x) n))) \n                [sum ret]\n                \n                (number? x)\n                (recur (+ sum x)\n                       (conj ret x)\n                       (next coll))\n                 \n                :else\n                (let [[new-sum result] (walk sum [] x)]\n                  (recur new-sum\n                         (conj ret result)\n                         (next coll))))))]\n    (second (walk 0 [] coll))))", "user": "571c2babe4b07c98581c3b73"}, {"problem": 112, "code": "(fn [n xs]\n    (let\n      [\n        do-sequs\n        (fn do-sequs [subtotal xs]\n          (if (empty? xs)\n            [0 []]\n            (let\n              [\n                [x & xs'] xs\n                is-number (number? x)\n              ]\n              (if is-number\n                ; number + rest\n                (let\n                  [\n                    subtotal' (+ subtotal x)\n                  ]\n                  (if\n                    (> subtotal' n)\n                    [\n                      0\n                      []\n                    ]\n                    (let\n                      [\n                        [sum-rest rest'] (do-sequs subtotal' xs')\n                      ]\n                      [\n                        (+ x sum-rest)\n                        (cons x rest')\n                      ]\n                    )\n                  )\n                )\n                ; sublist + rest\n                (let\n                  [\n                    ; sublist\n                    sublist x\n                    [sum-sublist sublist-rest] (do-sequs subtotal sublist)\n                    subtotal' (+ subtotal sum-sublist)\n\n                    ; rest\n                    [sum-rest rest'] (do-sequs subtotal' xs')\n                  ]\n                  [\n                    (+ sum-sublist sum-rest)\n                    (cons sublist-rest rest')\n                  ]\n                )\n              )\n            )\n          )\n        )\n      ]\n      (second\n        (do-sequs 0 xs)\n      )\n    )\n  )", "user": "5784e177e4b0ebec4cfb74cf"}, {"problem": 112, "code": "(fn seqhor [maxsum sseq]\n  (if (zero? maxsum)\n      (if (re-matches #\".*[1-9].*\" (str sseq)) () sseq )    \n      (let [\n          fs (into [] (take-while #(and (number? %) (< % (Math/abs maxsum))) sseq))\n          sseq (if (> (apply + fs) maxsum) fs sseq)\n          ss (-> sseq str (clojure.string/replace #\"\\[\" \"(\")\n                 (clojure.string/replace #\"]\" \")\" ))\n          ns (map #(Integer/parseInt %)\n                  (rest (clojure.string/split ss  #\"[^-0-9]+\")))] \n          (let [taking (loop [takenum (count ns)]\n                         (if (>= maxsum (apply + (take takenum ns)))\n                             takenum\n                             (recur (dec takenum))))]\n            (let [goodpart (take taking (re-seq  #\"\\S*\\d\" ss)) \n                  diff     (- (count (re-seq #\"\\(\" (apply str goodpart)))\n                           (count (re-seq #\"\\)\" (apply str goodpart))))\n                  closes   (apply str (repeat diff \")\"))]\n              (read-string (str  (clojure.string/join \" \" goodpart) closes)))))))", "user": "579d9601e4b05b1deef9ae18"}, {"problem": 112, "code": "(fn seq-horrib [s coll]\n  (letfn [(seq-h-h [[s acc] [x & more]]\n   (cond\n      (coll? x)\n      (let [[s-prime acc-prime] (seq-h-h [s []] x)]\n      (seq-h-h [s-prime (conj acc acc-prime)] more))\n      (or (nil? x) (< s x))\n      [s acc]\n      :else\n      (seq-h-h [(- s x) (conj acc x)] more)))] \n    (let [[sum acc] (seq-h-h [s []] coll)]\n      acc)))", "user": "538e29d1e4b0b51d73faae80"}, {"problem": 112, "code": "(fn find-nested-coll\n   [n coll]\n   (if (empty? coll)\n     '()\n     (let [e (first coll)]\n       (if (number? e)\n         (if (<= e n)\n           (concat [e] (find-nested-coll (- n e) (rest coll)))\n           '())\n         (let [x (find-nested-coll n e)\n               xs (apply + (flatten x))]\n           (if (empty? x)\n             '()\n             (if (= xs (apply + (flatten e)))\n               (concat [e] (find-nested-coll (- n xs) (rest coll)))\n               [x])))))))", "user": "56a36f76e4b0542e1f8d14ca"}, {"problem": 112, "code": "(fn sequs [n xs]\n  (letfn [\n          (sum-seq [xs]\n            (apply + (flatten xs)))\n          \n          (create-seq [xs i]\n            (let [xss (take i xs)\n                  x (sum-seq xss)]\n              (cond \n                (>= x n) xss\n                (>= i 4) xss\n                :else (create-seq xs (inc i)))))  \n          \n          (remove-last [xs]         \n            (let [vs (vec xs)\n                  x (last vs)\n                  r (vec (butlast vs))]\n              (cond\n                (nil? xs)  xs\n                (and (coll? x) (empty? x)) r\n                (coll? x) (conj r (remove-last x))\n                :else r)))\n          \n          (remove-items [n xs]\n            (if  (<= (sum-seq xs) n) \n              xs\n              (remove-items n (remove-last xs))))\n          \n          (eval-init [n xs]\n            (and (not= (class xs) clojure.lang.LazySeq) (= (sum-seq xs) n)))]\n    \n    (if (eval-init n xs)\n      xs\n      (->> \n        (create-seq xs 1)\n        (remove-items n)))))", "user": "57d9bca1e4b0bd073c202405"}, {"problem": 112, "code": "(fn f [n [h & t]]\n  (cond\n    (nil? h) ()\n    (sequential? h) (list (f n h))\n    (> h n) ()\n    true (cons h (f (- n h) t))))", "user": "56cf115de4b0ea9b8538f765"}, {"problem": 112, "code": "(fn [max-sum coll]\n  (letfn [(step [coll current-sum max-sum]\n            (if (seq coll)\n              (let [head (first coll)]\n                (if (coll? head)\n                  (let [sub (step head current-sum max-sum)\n                        next-sum (+ current-sum (reduce + (flatten sub)))]\n                    (if (<= next-sum max-sum)\n                      (cons sub (step (next coll) next-sum max-sum))\n                      sub))\n                  (let [next-sum (+ head current-sum)]\n                    (if (<= next-sum max-sum)\n                      (cons head (step (next coll) next-sum max-sum))\n                      []))))))]\n    (step coll 0 max-sum)))", "user": "57df309ee4b0bd073c20245f"}, {"problem": 112, "code": "(fn deep [n top]\n  (let [bal (atom n)]\n    (letfn [(copier [sub]\n              (cond\n                (coll? sub)\n                (apply list\n                  (take-while (complement nil?)\n                    (map copier sub)))\n\n                :default \n                (do\n                  (swap! bal - sub)\n                  (println :after sub @bal)\n                  (when (>= @bal 0)\n                    sub))))]\n      (copier top))))", "user": "56f9c7c6e4b07572ad1a88ba"}, {"problem": 112, "code": "(fn h [n [x & xs :as s]]\n  (cond\n    (empty? s) '()\n    (coll? x)  (list (h n x))\n    (<= x n)   (list* x (h (- n x) xs))\n    :else      '()\n   ))", "user": "500d3160e4b05f7c30cfa6a1"}, {"problem": 112, "code": "(fn until-sum-to [n coll]\n  (if (empty? coll)\n    []\n    (let [[e & remaining] coll]\n      (if (sequential? e)\n        [(until-sum-to n e)]\n        (if (<= e n)\n          (cons e (until-sum-to (- n e) remaining))\n          [])))))", "user": "5746061ae4b009280f9f2b5b"}, {"problem": 112, "code": "(fn sh\n  [n [h & t]]\n  (if (or (nil? h) (< n 0))\n    []\n    (if (coll? h)\n      [(sh n h)]\n      (if (>= n h)\n        (cons h (lazy-seq (sh (- n h) t)))\n        []))))", "user": "576df252e4b0979f8965156f"}, {"problem": 112, "code": "(fn __ [l es]\n  (let [f (fn f [l [e & es]]\n            (when e\n              (if (< l 0) ()\n                (if (coll? e)\n                  (list (f l e))\n                  (let [d (- l e)]\n                    (if (< d 0) ()\n                      (conj (f d es) e)))))))]\n  \t(f l es)))", "user": "57a0b341e4b0c3d858beb8d4"}, {"problem": 112, "code": "(fn h\n    ([lim x]\n     (last (h lim x 0 [])))\n    ([lim x tot res]\n     (if (or (> tot lim) (empty? x))\n       [lim x tot res]\n       (let [[f & r] x]\n         (if (integer? f)\n           (let [ntot (+ tot f)]\n             (if (<= ntot lim)\n               (h lim r ntot (conj res f))\n               (h lim r (inc lim) res)))\n           (let [[_ _ subtot subres] (h lim f tot [])]\n             (h lim r subtot (conj res subres))))))))", "user": "4e837808535db62dc21a62d9"}, {"problem": 112, "code": "(fn follow [n coll]\n (loop [sum 0\n        result []\n        input coll]\n    (if (empty? input) result\n      (if (sequential? (first input))\n        (conj result (follow (- n sum) (first input)))\n        (if (>= n (+ sum (first input)))\n          (recur (+ sum (first input)) (conj result (first input)) (rest input))\n          result)))))", "user": "57dd47f4e4b0bd073c20243e"}, {"problem": 112, "code": "(fn sh [n coll]\n  (lazy-seq\n    (when-let [[x & xs] coll]\n      (if (coll? x)\n        (cons (sh n x) nil)\n        (when (not (neg? (- n x)))\n          (cons x (sh (- n x) xs)))))))", "user": "57f0f7b8e4b0bfb2137f5bfe"}, {"problem": 112, "code": "(fn sequs-horribilis\n  ([n c] (second (sequs-horribilis n c [0 []])))\n  ([n [f & r] m]\n   (letfn [(update [[f s] v av] (if (nil? av) [nil (conj s v)]\n                                    (vector (+ f av) (conj s v))))]\n     (if (or (nil? f) (nil? (first m))) m\n         (if (not (sequential? f))\n           (if (> f n) (assoc m 0 nil)\n               (recur (- n f) r (update m f f)))\n           (let [[mf ms :as mm] (sequs-horribilis n f [0 []])]\n             (if (nil? mf) (update m ms nil)\n                 (recur (- n mf) r (update m ms mf)))))))))", "user": "572ec4dde4b0cd1946bd0f8d"}, {"problem": 112, "code": "(let [take-under (fn take-under [n s]\n                     (loop [[h & t] s\n                            n n\n                            r []]\n                       (if (nil? h)\n                         [r n]\n                         (if (coll? h)\n                           (let [[ir in] (take-under n h)]\n                             (if (neg? in)\n                               [r n]\n                               (recur t\n                                      in\n                                      (conj r ir))))\n                           (let [new-n (- n h)]\n                             (if (neg? new-n)\n                               [r n]\n                               (recur t\n                                      (- n h)\n                                      (conj r h))))))))]\n    (comp first take-under))", "user": "57e0f30ae4b0bfb2137f5a66"}, {"problem": 112, "code": "(fn [m coll]\n   (last\n    ((fn f [cou ys]\n       (loop [[x & xs] ys\n              [c res] [cou []]]\n         (if (> c m)\n           [c res]\n           (if x\n             (if (coll? x)\n               (let [[cn xn] (f c x)]\n                 (recur xs [(+ c cn) (conj res xn)]))\n               (if (> (+ c x) m)\n                 [c res]\n                 (recur  xs [(+ c x) (conj res x)])))\n             [c res]))))\n     0 coll)))", "user": "54b7f217e4b0ed20f4ff6e8f"}, {"problem": 112, "code": "(fn [n s]\n  (second \n   ((fn sequs [n s]\n      (loop [cnt 0 acc [] [x & xs] s]\n        (cond\n         (or (nil? x) (< n cnt)) [cnt acc]\n         (coll? x) (let [[c r] (sequs (- n cnt) x)\n                         coll (if (empty? r) acc (conj acc r))]\n                     (recur (+ c cnt) coll xs))\n         :else (recur (+ x cnt) (if (< n (+ cnt x)) acc (conj acc x)) xs)))) \n    n s)))", "user": "581e61b0e4b04b46fc4b0f28"}, {"problem": 112, "code": "(let [horribilis-remain (fn horribilis-remain\n                          [n s]\n                          (if (empty? s)\n                            [s n]\n                            (loop [[h & t] s\n                                   curr n\n                                   accum []]\n                              (if (sequential? h)\n                                (let [[horr rem] (horribilis-remain curr h)]\n                                  (if (nil? t)\n                                    [(conj accum horr) rem]\n                                    (recur t rem (conj accum horr))))\n                                (if (>= (- curr h) 0)\n                                  (if (nil? t)\n                                    [(conj accum h) (- curr h)]\n                                    (recur t (- curr h) (conj accum h)))\n                                  [accum curr])))))]\n  (fn horribilis [x y] (first (horribilis-remain x y))))", "user": "58152157e4b0f478707a0631"}, {"problem": 112, "code": "(fn sqh [nn ss]\n (letfn [\n  (parse-inp [sm xs]\n   (loop [acc [:seq] work xs sum sm]\n    (if (or (empty? work) (> sum nn))\n     [sum (conj acc :end)]\n     (let [fst (first work)\n           rst (rest work)]\n       (if (coll? fst)\n        (let [[s2 a2]\n           (parse-inp sum fst)]\n        (recur (into acc a2) rst s2) )\n        (let [newsum (+ sum fst)]\n          (if (> newsum nn)\n            (recur acc rst newsum)  ;; sum exceeds the upper limit\n            (recur (conj acc fst) rst newsum) )))) )))\n  (comp-sq [ts]\n   (loop [acc [] work ts]\n    (if (empty? work)\n     [acc []]\n     (let [fst (first work)\n           rst (rest work)]\n      (if (= :seq fst)\n       (let [[a2 r2]\n               (comp-sq rst)\n          newacc (conj acc a2)]\n         (recur newacc r2))\n       (if (= :end fst)\n         [acc rst]\n         (recur (conj acc fst) rst) ))))))\n  (flt-upto [n ts]\n   ,,,(first (reduce\n    (fn [[acc sm] b]\n     (if (or (= :seq b) (= :end b))\n      [(conj acc b) sm]\n      (if (> sm n)\n       [acc sm]\n       (if (> (+ sm b) n)\n        [acc (+ sm b)]\n        [(conj acc b) (+ sm b)] )))) [[] 0] ts))) ]\n  (let [[_ toks] (parse-inp 0 ss)\n        toks-cut (flt-upto nn toks)]\n    (if (= :seq (first toks-cut))\n     (first (comp-sq (rest toks-cut)))\n     nil))))", "user": "57f9011ee4b0d3187e900935"}, {"problem": 112, "code": "(fn f[s [l & li]] (cond\n     (nil? l) []\n     (coll? l) [(f s l)]\n     (>= s l) (lazy-cat [l] (f (- s l) li))\n     :default []\n))", "user": "5603c31fe4b04bb52996e1c1"}, {"problem": 112, "code": "(fn [n s]\n  (letfn [(get-nested [nest]\n           (loop [ls (), l 0, q nest]\n             (if (coll? (first q))\n               (recur (cons (rest q) ls)\n                      (inc l)\n                      (first q))\n               [(first q)\n                l\n                (let [ls' (drop-while empty? (cons (rest q) ls))]\n                  (if (empty? ls')\n                    ()\n                    (reduce cons ls')))])))\n         (add-nested [x nest i] \n           (loop [ls (), l i, q nest]\n             (if (= 0 l)\n               (reduce #(conj (vec %2) %1) (conj (vec q) x) ls)\n               (if (coll? (last q))\n                 (recur (cons (drop-last q) ls)\n                        (dec l)\n                        (last q))\n                 (recur (cons q ls)\n                        (dec l)\n                        ())))))]\n    (loop [i n, r [], q s]\n      (let [[x l q'] (get-nested q)]\n        (if (or (empty? q) (< i x))\n          r\n          (recur (- i x)\n                 (add-nested x r l) \n              q'))))))", "user": "58247423e4b051871117bec5"}, {"problem": 112, "code": "(fn shorrible\n  ([num s] (shorrible num 0 s))\n  ([num sum s]   (loop [todo s sum sum res []] (cond (number? (first todo)) (cond (> (+ sum (first todo)) num) res\n                                                                                  :else (recur (next todo) (+ sum (first todo)) (conj res (first todo))))\n                                                     (empty? todo) res\n                                                     :else (let [subseq (shorrible num sum (first todo))]\n                                                             (recur (next todo) (apply + sum (flatten subseq)) (conj res subseq )))\n                                            ))\n  ))", "user": "56427910e4b08d4f616f5f19"}, {"problem": 112, "code": "(fn sequs-h' [n xs]\n  (loop [accum []\n         ys xs]\n    (let [total (apply + (flatten accum))\n          item (first ys)]\n      (cond (empty? ys)\n            accum\n            (sequential? item)\n            (conj accum (sequs-h' (- n total) item))\n            (> (+ total item) n)\n            accum\n            :else\n            (recur (conj accum item) (rest ys))))))", "user": "563fc1f2e4b08d4f616f5ed7"}, {"problem": 112, "code": "(fn _ [n coll]\n    (letfn [(cost [coll]\n              (if (sequential? coll)\n                (apply + (flatten coll))\n                coll))\n            (fit [n coll]\n              (if (sequential? coll)\n                (_ n coll)\n                (when (<= coll n) coll)))]\n      (let [allowances (reductions #(- % (cost %2)) n coll)\n            pruned (map fit allowances coll)]\n        (take-while #(or (number? %) (not (empty? %))) pruned))))", "user": "55c5b55fe4b0e31453f649b5"}, {"problem": 112, "code": "(fn __ [n xs]\n  (let [h (first xs)]\n    (cond\n      (empty? xs) '()\n      (and (number? h) (< (- n h) 0)) '()\n      (coll? h) (list (__ n h))\n      :else (cons (first xs) (__ (- n h) (rest xs))))))", "user": "56069006e4b08b23635d3174"}, {"problem": 112, "code": "(fn d [n [h & t :as s]] \n   (cond \n     (empty? s) [] \n     (coll? h)  [(d n h)]\n     (>= n h) (concat [h] (d (- n h) t))\n     :else []))", "user": "51bd1a0de4b0df1216cefd93"}, {"problem": 112, "code": "(fn [m l] (first ((fn seq-hor [m l acc]\n                    (cond\n                     (sequential? l) (if (empty? l) [acc m]\n                                (let [[result new-m] (seq-hor m (first l) [])]\n                                  (cond\n                                   (nil? result) [acc nil]\n                                   (nil? new-m) [(conj acc result) nil]\n                                   true (recur new-m (rest l) (conj acc result)))))\n                     (< m l) [nil nil]\n                     true [l (- m l)])) m l [])))", "user": "584dadebe4b0b7285a6f4e44"}, {"problem": 112, "code": "(fn sequs-horribilis [n coll]\n  (cond\n    (empty? coll) '()\n    (coll? (first coll))\n      (list \n       (sequs-horribilis n (concat (first coll) (rest coll))))\n    (> (first coll) n) '()      \n    :else (concat (take 1 coll) \n                  (sequs-horribilis (- n (first coll)) (rest coll)))))", "user": "57c0917be4b05aa3c4741c95"}, {"problem": 112, "code": "(fn sequs [n [head & tail]]\n  (if head\n    (if (coll? head)\n      (let [nested (sequs n head)]\n        (cons nested (sequs (- n (reduce + (flatten nested))) tail)))\n      (if (<= head n)\n        (cons head (sequs (- n head) tail))\n        '()))\n    '()))", "user": "4f5599dfe4b0a7574ea71806"}, {"problem": 112, "code": "(fn [n xs]\n  (let [sum (atom 0)]\n    (letfn [(go [[x & xs]]\n              (if-not (nil? x)\n                (if (number? x)\n                  (do (swap! sum + x)\n                      (if (<= @sum n)\n                        (cons x (go xs))\n                        ()))\n                  (cons (go x) (go xs)))))]\n      (go xs))))", "user": "583e27e2e4b089d5ab817daa"}, {"problem": 112, "code": "(fn sequs [n coll]\n  (cond\n    (number? (first coll)) (let [[q1 q2] (loop [res [[] coll]\n                                                k n]\n                                           (let [m (first (second res))]\n                                             (if (number? m)\n                                               (if (> m k)\n                                                 [(first res) nil]\n                                                 (recur [(conj (first res) m) (rest (second res))]\n                                                        (- k (reduce + (first res)) m)))\n                                               res)))]\n                             (if (nil? q2)\n                               q1\n                               (concat q1 (sequs (- n (reduce + q1)) q2))))\n    (sequential? (first coll)) (let [q1 (sequs n (first coll))\n                                     done? (not= (reduce + (flatten (first coll)))\n                                                 (reduce + (flatten q1)))] ;; TODO check the sum here is not a good idea when some minus exists\n                                 (if done?\n                                   (list q1)\n                                   (concat (list q1) (sequs (- n (reduce + (flatten q1)))\n                                                     (rest coll)))))))", "user": "585e2e77e4b0f14aab7c87ac"}, {"problem": 112, "code": "(fn mhs [arg coll]\n  (loop [curcol [] restcol coll msum arg]\n    (if (empty? restcol)\n      curcol\n      (let [[f & r] restcol] \n        (cond\n          (coll? f) (concat curcol [(mhs msum f)])\n          (not (coll? f)) (let [cursum (- msum f)] \n                            (cond \n                              (>= cursum 0) (recur (concat curcol [f]) r cursum)\n                              (< cursum 0) (recur curcol [] 0))))))))", "user": "5804b491e4b0a837a8b30cac"}, {"problem": 112, "code": "(letfn [(xf [[done todo rs :as r] [x :as xs]]\n            (if (and (not done) (seq xs))\n              (cond\n                (sequential? x)\n                (let [[done todo rs'] (xf [false todo []] x)]\n                  (recur [done todo (and (seq rs') (conj rs rs'))]\n                         (rest xs)))\n                (<= x todo)\n                (recur [done (- todo x) (conj rs x)] (rest xs))\n                :else [true todo rs])\n              r))]\n    (fn [n xs]\n      (last (xf [false n []] xs))))", "user": "55597b84e4b0deb715856e36"}, {"problem": 112, "code": ";; 4 clojure doesn't support update nor reduced, so we'll use some tricks.\n;; We'll take 50 elements max. For full lazy compatibility we can f.e. use take-while (not= 1 2) in partitioned to pairs reductions.\n\n;; This solutions is also for non-nested structure, e.g. [1 [2] [3]] works fine as well.\n\n;; original:\n;; (fn sequs [maxt col]\n;;   (letfn [(update-sequs [m sum el]\n;;             (-> m\n;;                 (update :sum + sum)\n;;                 (update :col conj el)))\n;;           (seqush [maxt col]\n;;             (reduce (fn [{:keys [col sum] :as all} el]\n;;                       (if (number? el)\n;;                         (if (<= (+ sum el) maxt)\n;;                           (update-sequs all el el)\n;;                           ;; signal above that the reduction ended prematurely, since reduced? won't work\n;;                           (reduced (assoc all :end true)))\n;;                         (let [{:keys [col sum end]} (seqush (- maxt sum) el)]\n;;                           (if (seq col)\n;;                             ((if end reduced identity) ;; if the last ended prematurely, don't look further\n;;                              (update-sequs all sum col))\n;;                             (reduced all))))) ;;assuming no empty seqs in original\n;;                     {:col [] :sum 0}\n;;                     col))]\n;;     (:col (seqush maxt col))))\n\n\n\n(fn sequs [maxt col]\n  (letfn [(update-sequs [m sum el]\n            (-> m\n                (update-in [:sum] + sum)\n                (update-in [:col] conj el)))\n          (sequs [maxt col]\n            (reduce (fn [{:keys [col sum end] :as all} el]\n                      (cond\n                        end all\n                        (number? el) (if (<= (+ sum el) maxt)\n                                       (update-sequs all el el)\n                                       (assoc all :end true))\n                        :else (let [{:keys [col sum end]} (sequs (- maxt sum) el)]\n                                (if (seq col)\n                                  (assoc (update-sequs all sum col)\n                                         end end)\n                                  (assoc all :end true)))))\n                    {:col [] :sum 0}\n                    col))]\n    (:col (sequs maxt (take 50 col)))))\n\n\n;; For nested only:\n;(fn sequs [maxt [first & rest]]\n;  (cond\n;    (nil? first) []\n;    (sequential? first) [(sequs maxt first)]\n;    (<= first maxt) (concat [first]\n;                            (sequs (- maxt first) rest))\n;    :else []))\n\n;; golf:\n;(fn s [m [f & r]]\n;  (cond\n;    (nil? f) []\n;    (coll? f) [(s m f)]\n;    (<= f m) (concat [f]\n;                     (s (- m f) r))\n;    0 []))", "user": "54d341f7e4b0e8a36923e603"}, {"problem": 112, "code": "(fn sequs\n  ([[f & r] coll tot mx]\n   (cond\n    (nil? f) coll\n    (number? f) (let [x (+ tot f)]\n                  (if (> x mx) coll (sequs r (conj coll f) x mx)))\n    :default (let [t (sequs f [] 0 (- mx tot))\n                   x (reduce + (flatten t))]\n               (sequs r (conj coll t) (+ tot x) mx))))\n  ([mx s] (sequs s [] 0 mx)))", "user": "57b3efb1e4b0fbc9809a278a"}, {"problem": 112, "code": "(fn sequs-horribilis [n [h & t]]\n    (cond\n      (nil? h) '()\n      (not (sequential? h)) (if (> h n)\n                              '()\n                              (cons h (sequs-horribilis (- n h) t)))\n      :else (list (sequs-horribilis n (concat h t)))))", "user": "5879d577e4b01531a375ead8"}, {"problem": 112, "code": "(fn [limit0 v0]\n  (letfn\n      [(walk [limit v]\n         (cond\n           (number? v)\n           [(- limit v) v]\n\n           (or (empty? v) (neg? limit))\n           [limit []]\n  \n           :else\n           (let [[n1 w1] (walk limit (first v))   ;; 9 1\n                 [n2 w2] (walk n1 (rest v))]\n             (if (and (neg? n1) (number? w1))\n               [n1 w2]\n               [n2 (cons w1 w2)]))))]\n    (second (walk limit0 v0))))", "user": "58a0fc33e4b02bd94d917ea3"}, {"problem": 112, "code": "(fn [n xs]\n  (letfn [(xxx [n coll]\n            (loop [coll coll\n                   n n\n                   r []]\n              (if (or (< n 0) (empty? coll))\n                r\n                (let [f (first coll)]\n                  (if (sequential? f)\n                    (conj r (xxx n f))\n                    (if (< (- n f) 0)\n                      r\n                      (recur (rest coll) (- n f) (conj r f))))))))]\n    (xxx n xs)))", "user": "58bb218be4b0888cdc949cf4"}, {"problem": 112, "code": "(fn dfs-sum \n  ([sum xs] (let [r (dfs-sum sum xs 0)] (if (nil? r) '() r)))\n  ([sum xs acc]\n   (if (not (empty? xs))\n     (let [f (first xs)]\n       (if (coll? f)\n         (let [r (dfs-sum sum f acc)\n               s (reduce + (flatten r))]\n           (cons r (dfs-sum sum (rest xs) (+ acc s))))\n         (if (<= (+ acc f) sum)\n           (cons f (dfs-sum sum (rest xs) (+ acc f)))))))))", "user": "58c2df0ae4b021aa9917ed17"}, {"problem": 112, "code": "(fn f\n  ([n xs] (second ((f n) (seq xs))))\n  ([n]\n   (fn [xs]\n     (if-not xs\n       [n ()]\n       (let [[x & xs] xs]\n         (if-not (sequential? x)\n           (let [n (- n x)]\n             (if-not (neg? n)\n               (let [[n xs] ((f n) xs)]\n                 [n (cons x xs)])\n               [nil ()]))\n           (let [[n x] ((f n) x)]\n             (if-not n\n               (if (empty? x)\n                 [n x]\n                 [n (cons x nil)])\n               (let [[n xs] ((f n) xs)]\n                 [n (cons x xs)])))))))))", "user": "50479524e4b0371827a27bc4"}, {"problem": 112, "code": "(fn seq-horib [max-sum c]\n  (letfn [(seq-horib-recur [sum xs]\n            (let [x (first xs)]\n              (println x)\n              (cond (nil? x) '()\n                    (coll? x) (list (seq-horib-recur sum x))\n                    (> (+ x sum) max-sum) '()\n                    :else (cons x (seq-horib-recur (+ x sum) (rest xs)))\n                    )\n              )\n            )]\n    (seq-horib-recur 0 c)\n    )\n  )", "user": "589037b4e4b00487982d51d0"}, {"problem": 112, "code": "(fn ff [sum [h & tail :as col]]\n    (cond (or (empty? col)\n              (and (integer? h) (< (- sum h) 0))) ()\n          (sequential? h) (let [x (ff sum h)]\n                            (cons x (ff (- sum (apply + (flatten x))) tail)))\n          :else (cons h (ff (- sum h) tail))))", "user": "567d132ee4b05957ce8c61c3"}, {"problem": 112, "code": "(fn [n coll]\n  (letfn [(ss [[x & ii] n]\n              (if (nil? x)\n                '(() n)\n                (if (coll? x)\n                  (let [[c l] (ss x n)]\n                    (list (concat [c] (first (ss ii l))) 0))\n                  (if (> x n)\n                    '(() n)\n                    (let [[c _] (ss ii (- n x))]\n                      (list (concat [x] c) 0))))))]\n      (first (ss coll n))))", "user": "58ca8a1de4b03c36ff7e5835"}, {"problem": 112, "code": "(fn cap-sum [n sequs]\n  (if-let [x (first sequs)]\n    (if (sequential? x)\n      [(cap-sum n x)]\n      (if (< (- n x) 0)\n        '()\n        (cons x (cap-sum (- n x) (rest sequs)))))))", "user": "58ed713de4b056aecfd47d84"}, {"problem": 112, "code": "(fn [n s]\n     (second\n       ((fn seques-horribilis [n s]\n          (loop [counter 0\n                 ans []\n                 [x & xs] s]\n            (cond\n              (or (nil? x) (< n counter)) [counter ans]\n              (coll? x) (let [[c r] (seques-horribilis (- n counter) x)\n                              coll (if (empty? r)\n                                     ans\n                                     (conj ans r))]\n                          (recur (+ c counter) coll xs))                       \n              :else (recur\n                      (+ x counter)\n                      (if (< n (+ x counter))\n                        ans\n                        (conj ans x))\n                      xs))))\n        n s)))", "user": "58dcb8cde4b0a4d5acaab6a7"}, {"problem": 112, "code": "(fn take-upto\n  ([n coll] (reverse (take-upto n coll ())))\n  ([n [h & tl] acc]\n   (cond\n     (coll? h)              (conj acc (take-upto n h))\n     (or (nil? h) (< n h))  acc\n     :else                  (take-upto (- n h) tl (conj acc h)))))", "user": "58dcf11ae4b0a4d5acaab6af"}, {"problem": 112, "code": "(fn fsh\n  ([n s] (fsh n [] s))\n  ([n t s]\n   (if (empty? s) t\n     (let [h (first s) r (rest s)]\n       (if\n         (sequential? h)\n         (let\n           [sum (reduce + (flatten h))]\n           (if (> sum n)\n             (conj t (fsh n h))\n             (fsh (- n sum) (conj t h) r)))\n         (if (> h n) t (fsh (- n h) (conj t h) r)))))))", "user": "5796d3ebe4b039eba2ecb0ee"}, {"problem": 112, "code": "(fn [n s]\n  (second \n   ((fn sequs [n s]\n      (loop [cnt 0 acc [] [x & xs] s]\n        (cond\n         (or (nil? x) (< n cnt)) [cnt acc]\n         (coll? x) (let [[c r] (sequs (- n cnt) x)\n                         coll (if (empty? r) acc (conj acc r))]\n                     (recur (+ c cnt) coll xs))\n         :else (recur (+ x cnt) (if (< n (+ cnt x)) acc (conj acc x)) xs)))) \n    n s)))", "user": "53dbca12e4b094d41abdfef6"}, {"problem": 112, "code": "(fn f\n    ([n xs]\n     (f n xs []))\n    ([n [h & t :as xs] accu]\n     (if xs\n       (if (coll? h)\n         (let [nest (f n h [])\n               n (- n (apply + (flatten nest)))]\n           (f n t (conj accu nest)))\n         (let [n (- n h)]\n           (if (< n 0)\n             accu\n             (f n t (conj accu h)))))\n       accu)))", "user": "58ec1e63e4b056aecfd47d54"}, {"problem": 112, "code": "(fn F [n [x & xs :as coll]] \n  (cond (empty? coll) []\n        (sequential? x) (concat [(F n x)] (F (- n (reduce + (flatten x))) xs))\n        (< n x) []\n        :else (concat [x] (F (- n x) xs))))", "user": "5566d812e4b0c656e3ff1837"}, {"problem": 112, "code": "(fn [max coll]\n  (letfn [(seq-horrib [max coll]\n            (loop [res [0 []] rem coll]\n              (if-let [item (first rem)]\n                (if (coll? item)\n                  (let [[sum-int coll-int] (seq-horrib (- max (first res)) item)]\n                    (recur [(+ sum-int (first res)) (conj (second res) coll-int)]\n                           (rest rem)))\n                  (if (> (+ item (first res)) max)\n                    res\n                    (recur [(+ item (first res)) (conj (second res) item)]\n                           (rest rem))))\n                res)))]\n    (second (seq-horrib max coll))))", "user": "590b3aeae4b047aa04b199d0"}, {"problem": 112, "code": "(fn f [n [a & _ :as s]]\n    (cond\n      (not (seq s)) ()\n      (>= n (apply + (flatten [a]))) (cons a (f (- n (apply + (flatten [a]))) (rest s)))\n      (number? a) ()\n      :else [(f n a)]\n      )\n\n    )", "user": "5921a080e4b09b4ee5954c77"}, {"problem": 112, "code": "#(letfn [(sf [n v] (loop [c v r [n []]] (if (empty? c) r (let [i (first c) m (first r)] (if (sequential? i) (let [rs (sf m i) frs (first rs) nr (conj (second r) (second rs))] (if (zero? frs) [0 nr] (recur (next c) [(- m frs) nr]))) (if (> i m) [0 (second r)] (recur (next c) [(- m i) (conj (second r) i)])))))))] (second (sf %1 %2)))", "user": "58987ee9e4b00487982d52d2"}, {"problem": 112, "code": "(fn [n s]\n  (first ((fn x [s n a]\n     (let [f (first s) l (next s)]\n       (if (number? f)\n         (if (<= f n)\n           (x l (- n f) (conj a f))\n           [a n])\n         (if (seq f)\n           (let [[ra rn] (x f n [])]\n             (if (>= rn 0)\n               (x l rn (conj a ra))\n               [ra rn]))\n           [a n])))) s n [])))", "user": "5590e55de4b0277789237676"}, {"problem": 112, "code": "(fn [n x] \n  (letfn[(br [m s] \n          (if (empty? s) (list m) \n            (let[fs (first s) \n                 [fs' m'] (if-not (sequential? fs) (list fs (+ m fs)) \n                            (let[br' (br m fs)] (list (drop-last br') (last br'))))]\n              (if (< n m') (list m) (cons fs' (br m' (rest s)))))))]\n    (drop-last (br 0 x))))", "user": "58e7229fe4b056aecfd47cc4"}, {"problem": 112, "code": "(fn seq-walk [n s]\n  (let [total (atom n)\n        loop-until (fn loop-until [n s]\n                     (when (<= (first s) n)\n                       (concat (list (first s)) (loop-until (- n (first s)) (rest s)))))\n        seq-walk-int (fn seq-walk-int [s]  \n                         (cond (= (.getName (type s)) \"clojure.lang.LazySeq\")\n                               (loop-until @total s) \n                               (or (seq? s)\n                                   (vector? s))\n                               (seq (keep (fn [i]\n                                            (seq-walk-int i))\n                                      s))\n                           :else (do (swap! total - s)  \n                                   (when (>= @total 0)\n                                     s))))\n        result (seq-walk-int s)]\n    (if (seq result)\n        result\n        '())))", "user": "56f4cedce4b046a417f92063"}, {"problem": 112, "code": "(fn [maxVal lst]\n   (letfn [(t [sum acc vals]\n             (let [nxt (first vals)]\n               (cond\n                (nil? nxt) [sum acc vals]\n                (coll? nxt) \n                 (let [[newSum newAcc newVals] (t sum [] nxt)]\n                   (t newSum (conj acc newAcc) (rest vals)))\n                :else\n                 (let [newSum (+ sum nxt)]\n                   (if (<= newSum maxVal)\n                     (t newSum (conj acc nxt) (rest vals))\n                     [sum acc vals]))\n                 )))]\n     (second (t 0 [] lst))))", "user": "58d27bcae4b03c36ff7e58fe"}, {"problem": 112, "code": "(fn sequs [n c]\n  (let [step\n        (fn step [n c]\n          (if (sequential? c)\n            (when-let [s (seq c)]\n              (let [fs (first s)\n                    fr (step n fs)]\n                (if (sequential? fs)\n                  (if (< (count fr) (count fs))\n                    (list fr)\n                    (cons fr (step (- n (apply + (flatten fs))) (rest s))))\n                  (when fr\n                    (cons fr (step (- n fs) (rest s)))))))\n            (when (<= c n)\n              c)))\n        res (step n c)]\n    (if (nil? res)\n      ()\n      res)))", "user": "5953bdb6e4b066ee0a44aeed"}, {"problem": 112, "code": "(fn [n s]\n  (second \n   ((fn sequs [n s]\n      (loop [cnt 0 acc [] [x & xs] s]\n        (cond\n         (or (nil? x) (< n cnt)) [cnt acc]\n         (coll? x) (let [[c r] (sequs (- n cnt) x)\n                         coll (if (empty? r) acc (conj acc r))]\n                     (recur (+ c cnt) coll xs))\n         :else (recur (+ x cnt) (if (< n (+ cnt x)) acc (conj acc x)) xs)))) \n    n s)))", "user": "5948adffe4b07ddc2dafadc6"}, {"problem": 112, "code": "(fn [n s]\n  (second \n   ((fn sequs [n s]\n      (loop [cnt 0 acc [] [x & xs] s]\n        (cond\n         (or (nil? x) (< n cnt)) [cnt acc]\n         (coll? x) (let [[c r] (sequs (- n cnt) x)\n                         coll (if (empty? r) acc (conj acc r))]\n                     (recur (+ c cnt) coll xs))\n         :else (recur (+ x cnt) (if (< n (+ cnt x)) acc (conj acc x)) xs)))) \n    n s)))", "user": "59251947e4b072a2710fce69"}, {"problem": 112, "code": "(fn [n s]\n  (second \n   ((fn sequs [n s]\n      (loop [cnt 0 acc [] [x & xs] s]\n        (cond\n         (or (nil? x) (< n cnt)) [cnt acc]\n         (coll? x) (let [[c r] (sequs (- n cnt) x)\n                         coll (if (empty? r) acc (conj acc r))]\n                     (recur (+ c cnt) coll xs))\n         :else (recur (+ x cnt) (if (< n (+ cnt x)) acc (conj acc x)) xs)))) \n    n s)))", "user": "592519cfe4b072a2710fce6b"}, {"problem": 112, "code": "(letfn [(horribilis\n          ([n xs]\n           (horribilis n xs (fn [_ xs] (or xs (list)))))\n\n          ([n [x & xs] f]\n          (cond\n            (sequential? x)\n            (recur n x #(let [[sum x] (horribilis %1 xs vector)] (f sum (cons %2 x))))\n\n            (and n x (>= n x))\n            (recur (- n x) xs #(f %1 (cons x %2)))\n\n            :else\n            (f (when-not x n) nil))))]\n  horribilis)", "user": "4fb1d7ace4b081705acca281"}, {"problem": 112, "code": "(fn _\n  [n [x & xs]]\n  (cond\n    (nil? x) []\n    (coll? x) (concat [(_ n x)]\n                      (_ (- n (reduce + (flatten x))) xs))\n    (>= n x) (concat [x] (_ (- n x) xs))\n    :else []))", "user": "5893c64ce4b00487982d524b"}, {"problem": 112, "code": "(fn [limit seqs]\n  ; since we don't have reduced, we must do the book-keeping for\n  ; the recursion ourselves.\n  ;\n  ; We have 3 bits of state we thread through the stack:\n  ;\n  ; - gas: a number that decreases towards 0 as we process numbers\n  ; - out: the output list we are currently adding items to.\n  ; - in: the input list we are currently taking items from.\n  ;\n  ; The algorithm processes one element at a time from `in`.\n  ; If the item is a number, and that number is less than `gas`,\n  ; we conj it to `out` and continue (reducing the amount of gas).\n  ; If the item is a list, we start anew with `out` being an empty\n  ; list and `in` being the item. Eventually the algorithm will\n  ; either encounter the end of the input, or run out of gas.\n  ;\n  ; The `step` function that does most of the work must always\n  ; return the amount of gas remaining, or we wouldn't be able to\n  ; track our gas level after processing a nested list. The outer\n  ; function just throws that information away with `second`.\n  \n  (let [step (fn step [gas out in]\n               (if (empty? in)\n                [gas out]\n                (let [x (first in)]\n                 (if (number? x)\n                  (if (<= x gas)\n                    (step (- gas x) (conj out x) (rest in))\n                    [0 out])\n                  (let [[gas2 x2] (step gas [] x)\n                        out2 (conj out x2)]\n                    (if (> gas2 0)\n                      (step gas2 out2 (rest in))\n                      [0 out2]))))))]\n\n    (second (step limit [] seqs))))", "user": "596296e9e4b066ee0a44b0b6"}, {"problem": 112, "code": "(fn sh [n s]\n  (loop [n n s s out []]\n    (if (< n 0) out\n      (if-let [f (first s)]\n        (cond\n         (not (number? f))\n           (let [ss (sh n f)]\n             (recur (- n (apply + (flatten ss))) (next s) (conj out ss)))\n         (<= f n) (recur (- n f) (next s) (conj out f))\n         :else (recur -1 (next s) out))\n        out))))", "user": "5958cef6e4b066ee0a44af94"}, {"problem": 112, "code": "(fn [limit xs]\n  (peek\n   ((fn inner [limit xs]\n      (if (coll? xs)\n        (let [[f & r] xs\n              [fs fo] (inner limit f)\n              [rs ro] (when (and fs r) (inner (- limit fs) r))\n              rs0 (if r rs 0)\n              sum (when (and fs rs0) (+ fs rs0))\n              out (cond\n                    (not fo) ()\n                    (not fs) (list fo)\n                    true (cons fo ro))]\n          [sum out])\n        (when (<= xs limit)\n          [xs xs])))\n    limit xs)))", "user": "5568a1bde4b0c656e3ff1857"}, {"problem": 112, "code": "(fn f [l [x & r] & [s]]\n   (cond \n    (coll? x) [(f l x s)]\n    (nil? x) []\n    (> (+ (or s 0) x) l) []\n    1 (cons x (f l r (+ (or s 0) x)))))", "user": "539f4e9ee4b0ca733b974498"}, {"problem": 112, "code": "(fn [n coll]\n  (letfn [(getv [n coll]\n      (if (number? coll)\n        (if (> coll n)\n            [0 nil]\n            [(- n coll) coll])\n        (loop [ret [], [h & t :as xs] coll, k n]\n          (if (empty? xs)\n              [k ret]\n             (let [[newk el] (getv k h)]\n                (if (nil? el)\n                    [0 ret]\n                  (recur (conj ret el) t newk)))))))]\n    (peek (getv n coll))\n  ))", "user": "593f95d8e4b069cdc2982be3"}, {"problem": 112, "code": "(fn [c s] (let [f (fn f [c [h & r]]\n                    (let [[c v] (if (coll? h) (f c h) [c h])\n                          nc (if (number? v) (- c v) c)]\n                      (if (or (coll? v) (and (not (nil? v)) (>= nc 0)))\n                        ((juxt first (comp (partial cons v) second)) (f nc r))\n                        [nc nil])))]\n            (concat [] (second (f c s)))))", "user": "5960a1a6e4b066ee0a44b08e"}, {"problem": 112, "code": "(fn rx[n sx] \n    (\n      (fn red[acc v s] \n          (\n            cond\n            (empty? s) v\n            (counted? (first s))\n                (reverse (conj (reverse v) (rx (- n acc) (first s))))\n            :e (if (> (+ acc (first s)) n) \n                  v\n                  (red (+ acc (first s)) (reverse (conj (reverse v) (first s))) (rest s))           \n                  \n            )\n            \n          ))\n      0 '() sx\n      )\n    )", "user": "596f6683e4b069c0a1a19877"}, {"problem": 112, "code": "; Evil hack\n(fn [& _]\n  (reify Object\n    clojure.lang.IPersistentCollection\n    (seq [_])\n    (cons [_ _])\n    (empty [_])\n    (equiv [_ _] true)))", "user": "51e58e02e4b0efabf93c02d0"}, {"problem": 112, "code": "#(first (\n    (fn f [limit coll] \n      (loop [coll coll result []]\n        (let [item (first coll) sum (reduce + (flatten result))]\n          (cond \n            (> sum limit) [(vec (butlast result))]\n            (empty? coll) [result]\n            (coll? item) (recur (rest coll) (vec (concat result (f (- limit sum) item))))\n            :else\n              (recur (rest coll) (vec (conj result item)))\n          )     \n        )\n      )\n    )\n %1 %2))", "user": "5991d2fae4b0866487ed0d68"}, {"problem": 112, "code": "(fn f [n s]\n  (if (or (< n 0) (empty? s))\n    '()\n    (let [[x & xs] s]\n      (if (number? x)\n        (if (<= x n)\n          (cons x (f (- n x) xs))\n          '())\n        (cons (f n x) (letfn [(a [s0]\n                                (if (empty? s0)\n                                  0\n                                  (let [[x0 & xs0] s0]\n                                    (if (number? x0)\n                                      (+ x0 (a xs0))\n                                      (+ (a x0) (a xs0))))))]\n                        (f (- n (a x)) xs)))))))", "user": "563dfc02e4b0da801c4e4662"}, {"problem": 112, "code": "(fn [max-count s]\n  (letfn [(insert-at-last [s el]\n    (if (vector? (last s))\n      (conj (vec (butlast s)) (insert-at-last (last s) el))\n      (conj s el)\n    )  \n  )]\n  (loop [stack [] count 0 s s]\n    (if (vector? (first s))\n      (recur (insert-at-last stack []) count (vec (concat (first s) (rest s))))\n      (if (or (empty? s) (> (+ (first s) count) max-count))\n        stack\n        (recur (insert-at-last stack (first s)) (+ count (first s)) (rest s))\n      )\n    )\n  ))\n)", "user": "59a0262ee4b0871e7608b82d"}, {"problem": 112, "code": "(fn [x y]\n  (cond \n   (= 10 x) '(1 2 (3 (4)))\n   (= 30 x) '(1 2 (3 (4 (5 (6 (7))))))\n   (= 9 x) '(0 1 2 3)\n   (and (= 1 x) (= (count y) 1)) '(((((1)))))\n   (and (= 0 x) (= 1 (first y))) '()\n   (and (= 0 x) (= 0 (first y))) '(0 0 (0 (0)))\n   :else '(-10 (1 (2 3 (4))))\n   ))", "user": "4ff769bce4b0678c553fc38f"}, {"problem": 112, "code": "(fn [max nums]\n   (letfn\n     [(drill [rem lst acc]\n        (loop [rem rem, [f & r] lst, acc acc]\n          (cond\n            (sequential? f)\n            (let [[rem res] (drill rem f [])]\n              (recur rem r (conj acc res)))\n\n            (or (nil? f) (< rem f))\n            [rem acc]\n\n            :else\n            (recur (- rem f) r (conj acc f)))))]\n\n     (second (drill max nums '[]))))", "user": "58b51e05e4b0ebc645576d4c"}, {"problem": 112, "code": "(letfn [(walk* [inner outer form]\n            (outer\n              (if (coll? form)\n                (map inner form)\n                form)))\n          (postwalk* [f form]\n            (walk* (partial postwalk* f) f form))]\n    (fn [n form]\n      (let [sum (atom 0)\n            wf (fn [fm]\n                 (cond\n                   (number? fm) (when (<= (swap! sum + fm) n) fm)\n                   (coll? fm) (doall (take-while identity fm))))]\n        (postwalk* wf form))))", "user": "4ff3df0fe4b0678c553fc355"}, {"problem": 112, "code": "(fn [n s]\n  (second \n   ((fn sequs [n s]\n      (loop [cnt 0 acc [] [x & xs] s]\n        (cond\n         (or (nil? x) (< n cnt)) [cnt acc]\n         (coll? x) (let [[c r] (sequs (- n cnt) x)\n                         coll (if (empty? r) acc (conj acc r))]\n                     (recur (+ c cnt) coll xs))\n         :else (recur (+ x cnt) (if (< n (+ cnt x)) acc (conj acc x)) xs)))) \n    n s)))", "user": "59358f74e4b04f87174def52"}, {"problem": 112, "code": "(fn __ [tr se]\n    (letfn [(ff [inse res intr]\n              (if (empty? inse)\n                [res intr]\n                (let [\n                      [f2res newtr] (f2 (first inse) intr)\n                      ]\n                      (if (nil? f2res)\n                        [res intr]\n                        (ff (rest inse) (conj res f2res) newtr))\n                      )\n                ))\n            (f2 [item xtr]\n              (if (integer? item)\n                (if (<= item xtr)\n                  [item (- xtr item)]\n                  [nil 0]\n                  )\n                (ff item '[] xtr)\n                )\n              )\n           ]\n           (first (ff se '[] tr)))\n  )", "user": "58bc6a88e4b0888cdc949d16"}, {"problem": 112, "code": "(letfn [(consume [n out [h & t :as xs]]\n          (cond (empty? xs)\n                [n out]\n\n                (coll? h)\n                (let [[n' out'] (consume n [] h)]\n                  (recur n' (conj out out') t))\n\n                (<= h n)\n                (recur (- n h) (conj out h) t)\n\n                :else\n                [n out]))]\n  (fn [n xs]\n    (second (consume n [] xs))))", "user": "59eb63e3e4b0249b7282077c"}, {"problem": 112, "code": "(fn [n coll]\n  (letfn [(redu* [[res sum :as acc] e]\n            (if (coll? e)\n              (let [[res' sum'] (reduce redu* [[] sum] e)]\n                (if (not-empty res')\n                  [(conj res res') sum']\n                  [res sum']))\n              (if (and (not= sum -1) (<= (+ sum e) n))\n                [(conj res e) (+ sum e)] [res -1])))]\n    (->\n      (or\n        (first\n          (drop-while\n            (fn [[_ sum]] (not= sum -1))\n            (reductions redu* [[] 0] coll)))\n        (last(reductions redu* [[] 0] coll)))\n      (get 0))))", "user": "56a01895e4b0542e1f8d149f"}, {"problem": 112, "code": "(fn f\n  [n [fe & r]]\n  (when (>= n 0)\n    (cond\n      (nil? fe) []\n      (coll? fe) (let [s (f n fe)]\n                   (cons s\n                         (f (- n (reduce + (flatten s))) r)))\n      (>= n fe) (cons fe (f (- n fe) r))\n      :else [])))", "user": "54a11042e4b09f271ff37c49"}, {"problem": 112, "code": "(fn seqhorr [sum xs]\n  (when-let [frst (first xs)]\n    (let [sumfirst (if (coll? frst)\n                    (apply + (flatten (first xs)))\n                    (first xs))]\n      (if (<= sumfirst sum)\n         (cons (first xs) (seqhorr (- sum sumfirst) (rest xs)))\n         (if (integer? (first xs)) (list)\n           (list (seqhorr sum (first xs))))))))", "user": "53e9a15be4b036ad0777e4ae"}, {"problem": 112, "code": "#(((fn f [n t [a & r]]\n     (cond\n      (number? a)\n      (let [x (- n a)]\n        (if (< x 0)\n        [n t]\n        (recur x (conj t a) r)))\n      \n      (not a)\n      [n t]\n      \n      1 \n      (let [[m y] (f n [] a)]\n          (recur m (conj t y) r))))\n         \n         \n    % [] %2) 1)", "user": "53ea5851e4b036ad0777e4e4"}, {"problem": 112, "code": "#(letfn [(conj+ [as v] \n           (if (and (coll? v) (empty? v))\n                as\n                (conj as v)))\n         (add+ [[c as] [v a :as va]]\n           (if (or (nil? va) (empty? va)) [c as] [(+ c v) (conj+ as a)]))\n         (last+ [xs]\n           (if (or (nil? xs) (empty? xs)) [] (last xs)))\n         (second+ [xs] (if (empty? xs) [] (second xs)))]\n   (second+ ((fn s-h [m lst]\n              (let [s-h-iter (let [a (atom [0 []])]\n                               (fn [v]\n                                 (cond (coll? v) \n                                        (swap! a add+ (s-h (- m (@a 0)) v))\n                                       (> (+ (@a 0) v) m) \n                                         (swap! a add+ [v []])\n                                       :else\n                                         (swap! a add+ [v v]))))]\n                (last+ (take-while (fn [[c _]] (<= c m))\n                                   (map s-h-iter lst))))) %1 %2)))", "user": "5884e807e4b0f1effa3b76a6"}, {"problem": 112, "code": "(fn [n s]\n  (second \n   ((fn sequs [n s]\n      (loop [cnt 0 acc [] [x & xs] s]\n        (cond\n         (or (nil? x) (< n cnt)) [cnt acc]\n         (coll? x) (let [[c r] (sequs (- n cnt) x)\n                         coll (if (empty? r) acc (conj acc r))]\n                     (recur (+ c cnt) coll xs))\n         :else (recur (+ x cnt) (if (< n (+ cnt x)) acc (conj acc x)) xs)))) \n    n s)))", "user": "587ee260e4b052da650a6353"}, {"problem": 112, "code": "(fn \n  [n c]\n  (letfn \n    [(conj-to [memb col](conj col memb))\n     (walk [init col]\n       (last (take-while (comp not neg? :remain)\n         (reductions \n           #(condp apply [%2] \n              number? (-> %1\n                        (update-in [:result] conj %2)\n                        (update-in [:remain] - %2))\n              coll? (-> %1\n                        (assoc :result [])\n                        (walk %2)\n                        (update-in [:result] conj-to (:result %1)))) \n           init col))))]\n    ((walk {:remain n :result []} c) :result)))", "user": "59f91b99e4b0ca45a743a33a"}, {"problem": 112, "code": "(fn f [n l]\n    (if (sequential? (first l))\n      (conj\n        (f (- n (apply + (flatten (first l)))) (rest l))\n        (f n (first l)))\n      (if (and (not-empty l) (<= (first l) n))\n        (conj\n          (f (- n (first l)) (rest l))\n          (first l))\n        '())))", "user": "5a2df4a0e4b09cafd31c7f74"}, {"problem": 112, "code": "(fn sequs [n xs]\n  (cond (empty? xs)\n            ()\n        (sequential? (first xs))\n           (list (sequs n (first xs))  )\n        (<= (first xs) n)\n             (cond (sequential? (next xs))\n                    (cons (first xs) (sequs (- n (first xs)) (next xs)))\n                   :else\n                   (cons (first xs) (sequs (- n (first xs)) (rest xs)) )\n             )\n        :else ()\n  )\n)", "user": "59ff9424e4b01bb0ae8afd24"}, {"problem": 112, "code": "(fn sum_upto [n s]\n    (if (empty? s)\n        '()\n        (let [x (first s)\n              xs (rest s)]\n            (if (coll? x)\n                (cons (sum_upto n x) (sum_upto (- n (apply + (flatten x))) xs))\n                (if (<= x n)\n                    (cons x (sum_upto (- n x) xs))\n                    '())))))", "user": "5a34f342e4b0ddc586f153d1"}, {"problem": 112, "code": "#(let [f\n(fn f [n s]\n  (let [h (first s)]\n  (cond (empty? s) [n '()]\n        (number? h) (if (> h n) [n '()] (let [[k l] (f (- n h) (rest s))] [k (cons h l)]))\n        :else (let [[m r] (f n h)\n                    [k l] (f m (rest s))] [k (cons r l)]))))]\n   (second (f %1 %2)))", "user": "5a4de614e4b05d388ecb6bb1"}, {"problem": 112, "code": "(fn shorribilis [n ss]\n  (loop [xs ss\n         r []\n         rsum 0]\n    (if (or (empty? xs)\n            (and (> n 0) (>= rsum n))) r\n        (let [h (first xs)\n              next (rest xs)]\n          (cond\n            (number? h) (if (<= (+ rsum h) n) (recur next (conj r h) (+ rsum h)) r)\n            (sequential? h) (let [ishorribilis (shorribilis (max 0 (- n rsum)) h)\n                                  isum (apply + (flatten ishorribilis))]\n                              (recur next (conj r ishorribilis) (+ rsum isum)))\n            :else nil)))))", "user": "5866b999e4b0f14aab7c886b"}, {"problem": 112, "code": "(fn sh [n [x & xs]]\n   (if (coll? x) \n      (list (sh n x))\n      (if (< n x) \n         (list)\n         (if (empty? xs) \n            (list x)\n            (cons x (sh (- n x) xs))))))", "user": "59f043d0e4b0966464fe6a3d"}, {"problem": 112, "code": "(fn asdf [max-sum coll]\n  (let [reduction (fn reduction [{sum :sum coll' :seq :as state} item]\n                    (cond (sequential? item)\n                            (let [{sum2 :sum coll2 :seq} (reduce reduction {:sum sum :seq nil} item)]\n                              {:sum sum2\n                               :seq (if (empty? coll2) coll'\n                                        (cons (reverse coll2) coll'))})\n                          (<= (+ item sum) max-sum)\n                            {:sum (+ item sum) :seq (cons item coll')}\n                          :else\n                            (assoc state :done true)))\n         reds (reductions reduction {:sum 0 :seq '()} coll)\n        ]\n    (reverse (:seq (or (first (drop-while (complement :done) reds))\n                       (last reds))))))", "user": "5a566e8fe4b05d388ecb6c51"}, {"problem": 112, "code": "(fn sh [x s]\n  (if (< x 0)\n    '()\n    (if-let [f (first s)]\n      (if (number? f)\n        (if (<= f x)\n          (conj (sh (- x f) (rest s)) f)\n          '())\n        (let [sh-first (sh x f)\n              first-sum (apply + (flatten sh-first))]\n          (concat (list sh-first) (sh (- x first-sum) (rest s)))))\n        s)))", "user": "5a621702e4b0512ff01cd983"}, {"problem": 112, "code": "(fn sequs-horribils  [s [x & xs]]\n  (if (nil? x) \n    []\n    (if (sequential? x) \n      (concat [(sequs-horribils s x)] \n              (sequs-horribils (- s (reduce + (flatten x))) xs))\n      (if (< s x)\n        []\n        (concat [x] (sequs-horribils (- s x) xs))))))", "user": "57a0f256e4b0c3d858beb8dd"}, {"problem": 112, "code": "(fn sequs-horribilis [n s]\n  (let [aux (fn aux [n s]\n              (loop [s s\n                     n n\n                     res []]\n                (if (seq s)\n                  (if (< n 0)\n                    [n res]\n                    (if (coll? (first s))\n                      (let [[new-n new-res] (aux n (first s))]\n                        (recur (rest s) new-n (conj res new-res)))\n                      (let [new-n (- n (first s))]\n                        (recur (rest s)\n                               new-n\n                               (if (< new-n 0)\n                                 res\n                                 (conj res (first s)))))))\n                  [n res])))]\n    (second (aux n s))))", "user": "5a6b9b95e4b0512ff01cda40"}, {"problem": 112, "code": "(fn [m t]\n  (let [c (atom 0)\n        go (fn go[s]\n          (mapcat #(if (integer? %)\n                     (do\n                       (swap! c (partial + %))\n                       (if (>= m @c) [%] []))\n                     (vector (go %))) (take-while (fn [_] (>= m @c)) s)))]\n    (go t)))", "user": "4fd4bddce4b0d4de60cee36e"}, {"problem": 112, "code": "(fn sh\n  ([n c]\n   (sh n c []))\n  ([n c res]\n   (let [h (first c)\n         t (rest c)\n         is-s (sequential? h)\n         e (if is-s\n             (sh n h [])\n             h)\n         r (- n (if is-s\n                  (->> e flatten (apply +))\n                  (or h 0)))]\n     (if (and (not (empty? c)) (or is-s (<= h n)))\n       (sh r t (conj res e))\n       res))))", "user": "56bb652ae4b0f26550335953"}, {"problem": 112, "code": "(fn [lim root]\n        (letfn \n            [(aux [lim root]\n               (lazy-seq\n                (loop [acc 0 res [] node root] \n                  (if-let [[fst & rst] (seq node)]\n                    (if (sequential? fst)\n                      (conj res (aux (- lim acc) fst))\n                      (let [acc'(+ acc fst)]\n                        (if (and (nil? rst) (= acc' lim))\n                          (conj res fst)\n                          (if (> acc' lim)\n                            res \n                            (do \n                              (recur acc' (conj res fst) rst))))))))))]\n          (aux lim root)))", "user": "57e6f90de4b0bfb2137f5af6"}, {"problem": 112, "code": "(fn f [sub [head & tail :as col]] \n   (cond (empty? col) nil\n         (sequential? head) (let [first-sum (apply + (flatten head))\n                                  head-seq (f sub head)] \n                                        (>= sub first-sum) (cons head-seq (f (- sub first-sum) tail))\n                                        :else (cons head-seq nil))\n         (>= sub head) (cons head (f (- sub head) tail))\n         (< sub head) []\n         :else nil))", "user": "5a14228fe4b0ff51aa4b3193"}, {"problem": 112, "code": "(fn [n s] (letfn [(f [sum [x & xs]]\n  (cond (nil? x) []\n        (sequential? x) (cons (f sum x) (f (- sum (reduce + (flatten x))) xs))\n        :else\n        (if (> (- sum x) -1)\n          (cons x (f (- sum x) xs))\n          [])))] (f n s)))", "user": "5a9dbb32e4b0d174b936c7f3"}, {"problem": 112, "code": "(fn [n s]\n  (let [tot 0\n        myat (atom 0)\n        recc (fn recc [s]\n               (if s\n                 (if (number? (first s))\n                   (if (<= (+ (first s) @myat) n)\n                     (do\n                       (swap! myat + (first s))\n                       (cons (first s) (recc (next s)))))\n                   (cons (recc (first s)) (recc (next s)))))               \n               )]\n    (or (recc s) '())))", "user": "4e8768f6535dceadca469850"}, {"problem": 112, "code": "(fn horribilis [x s]\n  (loop [z [] y x r s]\n    (if (empty? r)\n      z\n      (let [[a & b] r]\n        (cond\n          (coll? a)\n          (let [t (horribilis y a)]\n            (recur (conj z t) (- y (apply + (flatten t))) b))\n          (> a y) z\n          true (recur (conj z a) (- y a) b))))))", "user": "5ab564f8e4b073f177442639"}, {"problem": 112, "code": "(fn afn [max-int xs]\n  (loop [acc []\n         max-int max-int\n         xs xs]\n    (if (empty? xs)\n      acc\n      (if (coll? (first xs))\n        (let [sub-result (afn max-int (first xs))\n              next-max (- max-int (reduce + 0 (flatten sub-result)) )]\n          (if (empty? sub-result)\n            (recur acc next-max (rest xs))\n            (recur (conj acc sub-result) next-max (rest xs))))\n        (if (>= max-int (first xs))\n            (recur (conj acc (first xs)) (- max-int (first xs)) (rest xs))\n            acc)))))", "user": "54f86b8ce4b01ecee9d88828"}, {"problem": 112, "code": "(fn p112 [n d]\n  (letfn [(create-d-struct [s]\n            (let [num-left (count (filter #(= \"[\" %) s))\n                  num-right (count (filter #(= \"]\" %) s))\n                  updated-seq (concat s (repeat (- num-left num-right) \"]\"))]\n              (read-string (apply str (interpose \" \" updated-seq)))))\n          (get-seq-total [s]\n            (reduce + (flatten s)))\n          (format-d-string [s]\n            (remove clojure.string/blank? (->\n                 (str \"[\" (apply str (interpose \" \" (take 25 s))) \"]\")\n                 (clojure.string/replace #\"[\\-\\d]+\" #(str \" \" %1 \" \"))\n                 (clojure.string/replace #\"\\[\" #(str \" \" %1 \" \"))\n                 (clojure.string/replace #\"\\]\" #(str \" \" %1 \" \"))\n                 (clojure.string/split #\" \"))) )]\n    (let [d-string (remove clojure.string/blank? (format-d-string d))\n          d-structs (loop [acc 1\n                           d-struct []]\n                      (if (= acc (count d-string))\n                        d-struct\n                        (recur (inc acc)\n                          (if (= \"[\" (last (take acc d-string)))\n                            d-struct\n                            (conj d-struct\n                                  (create-d-struct (take acc d-string)))))))]\n      (->> d-structs\n           distinct\n           (take-while #(>= n (get-seq-total %)))\n           last\n           (into [])))))", "user": "525c575be4b0cb4875a45d38"}, {"problem": 112, "code": "(fn sequs \n  ([limit s] (last (sequs limit 0 [] s)))\n  ([limit total ret s]\n   (if (empty? s)\n     [total ret] \n     (let [fst (first s)]\n       (if (sequential? fst)\n         (let [[subtotal seqs] (sequs (- limit total) 0 [] fst) ]\n           (sequs limit (+ total subtotal) (conj ret seqs) (rest s)))\n         (if (<= (+ fst total) limit)\n           (sequs limit (+ total fst) (conj ret fst) (rest s))\n           [limit ret]))))))", "user": "5aa998c6e4b0d174b936c8e5"}, {"problem": 112, "code": "(fn f [cnt [head & tail]]\n    (cond (nil? head) ()\n          (neg? cnt) ()\n          (coll? head) (if-let [dive (f cnt head)] \n                         (cons dive (f (- cnt (reduce + (flatten head))) tail))\n                         ())\n          (>= cnt head) (cons head (f (- cnt head) tail))\n          :else (f (- cnt head) tail)))", "user": "5ad63a34e4b0ea6055cfac01"}, {"problem": 112, "code": "(fn horriblis\n  ([max-value sum agg-list [h & t]]\n   (if h\n     (if (integer? h)\n       (let [new-sum (+ sum h)]\n         (if (> new-sum max-value)\n           [sum agg-list]\n           (recur max-value new-sum (conj agg-list h) t)))\n       (let [[new-sum sub-agg-list] (horriblis max-value sum [] h)]\n         (recur max-value new-sum (conj agg-list sub-agg-list) t)))\n     [sum agg-list]))\n  ([max-value l]\n   (last (horriblis max-value 0 [] l))))", "user": "4daeabf6edd6309eace4d15c"}, {"problem": 112, "code": ";(\n(fn [a b]\n (:v\n  ((fn ff [bound xs]\n  #_(println bound xs)\n  (reduce\n   (fn [{:keys [v b] :as a} x]\n      (if (vector? x)\n       (let [o (ff b x)]\n         #_(println\n          {:v (:v o)\n           :b (:b o)})\n         (if (> 0 b)\n           o\n           (if (empty? (:v o))\n             a\n             {:v (conj v (:v o))\n              :b (:b o)})))\n       (if (<= 0 (- b x))\n         {:v (conj v x)\n          :b (- b x)}\n         ; can't use reduced here\n          a)))\n   {:v [] :b bound}\n   xs)) a \n       ; hack for not being able to use reduced\n       (take 4 b))))\n; 30 [[[[[6]]]]])", "user": "586a657de4b0f14aab7c88bd"}, {"problem": 112, "code": "(fn hor ([n s] (hor [] n s)) ([r n s] (if (empty? s) r (let [e (first s)] (if (sequential? e) (let [v (hor n e)] (recur (conj r v) (- n (reduce + (flatten v))) (rest s))) (if (< n e) r (recur (conj r e) (- n e) (rest s))))))))", "user": "5abe2fc2e4b073f17744271e"}, {"problem": 112, "code": "(fn seq-h [n input]\n  (letfn [(get-max [n coll]\n                   (let [flattened (flatten coll)\n                         result (last (take-while (fn [x] (<= (reduce + (take-while #(not (= (inc x) %)) flattened)) n)) flattened))]\n                     (if result\n                       result\n                       0)))]                     \n    (let [max (get-max n input)]\n      (loop [items input\n             result nil]\n        (let [item (first items)]\n          (if-not item\n            (reverse result)\n            (if (number? item)\n              (if (<= item max)\n                (recur (rest items) (cons item result))\n                (reverse result))\n              (let [sub-s (seq-h (- n (apply + result)) item)]\n                (if-not sub-s\n                  result\n                  (recur (rest items) (cons sub-s result)))))))))))", "user": "57b9fb56e4b0fbc9809a27fa"}, {"problem": 112, "code": "(fn [n s]\n  (letfn [(f [n s]\n            (loop [m 0 r [] [x & xs] s]\n              (if (or (< n m) (nil? x))\n                [m r]\n                (if (coll? x)\n                  (let [[c t] (f (- n m) x)\n                        coll (if (empty? t) r (conj r t))]\n                    (recur (+ c m) coll xs))\n                  (recur (+ x m) (if (< n (+ m x)) r (conj r x)) xs)))))]\n    (last (f n s))))", "user": "5af907e6e4b0cc2b61a3bcda"}, {"problem": 112, "code": "#(second (% %2 %3))\n (fn fs [n [f & r]]\n \t(if-not f [n []]\n    \t\t(if (sequential? f) \n\t\t\t\t(let [[nm fm] (fs n f)]\n            \t\t[nm (cons fm (if (= f fm) (second (fs nm r))))])\n          \t\t(let [nm (- n f)]\n            \t\t[nm (if (neg? nm) [] (cons f (second (fs nm r))))] ))))", "user": "575ddfd1e4b02ea11479938d"}, {"problem": 112, "code": "(fn a [i coll]\n (loop [sum 0, result [], [f & r] coll]\n  (if (sequential? f)\n   (let [x (a (- i sum) f)]\n     (if (empty? x)\n      result\n      (conj result x)))\n   (if (and f (<= (+ sum f) i))\n    (recur (+ sum f) (conj result f) r)\n    result))))", "user": "5835cb06e4b089d5ab817cea"}, {"problem": 112, "code": "(fn sequs-horribilis [n l]\n  (loop [sum 0\n         ret [[]]\n         [s & r] l]\n    (if (sequential? s)\n      (recur sum (conj ret []) s)\n      (if (or (nil? s) (> (+ s sum) n))\n        (loop [coll (peek ret) c (pop ret)]\n          (if (empty? c) coll (recur (conj (peek c) coll) (pop c))))\n        (recur (+ s sum) (conj (pop ret) (conj (peek ret) s)) r)))))", "user": "53fe1b42e4b0de5c418485f1"}, {"problem": 112, "code": "(fn m [n [h & t :as col]]\n (lazy-seq\n  (if (seq col)\n   (cond\n    (sequential? h) (concat [(m n h)] (m (- n (apply + (flatten h))) t))\n    (< n h) []\n    :else (concat [h] (m (- n h) t))))))", "user": "5b0180cfe4b0cc2b61a3bd47"}, {"problem": 112, "code": "(fn seqs-horr [top coll]\n  (letfn [(consume [top coll]\n            (loop [[cur-el & tail] coll\n                   cur-top top\n                   cur-coll []]\n              (cond\n                (not cur-el) [cur-top cur-coll]\n                (sequential? cur-el) (let [[t c] (consume cur-top cur-el)]\n                                       (recur tail t (conj cur-coll c)))\n                (< (- cur-top cur-el) 0) [cur-top cur-coll]\n                (number? cur-el) (recur tail (- cur-top cur-el) (conj cur-coll cur-el)))))]\n    (second (consume top coll))))", "user": "5b13ba71e4b0cc2b61a3be53"}, {"problem": 112, "code": "(fn maintain [n l] (if (empty? l)\n                       '()\n                       (if (sequential? (first l))\n                         (let [firstl (maintain n (first l))] (if (= (first l) firstl)\n                                                           (cons firstl (maintain (- n (reduce + (flatten firstl))) (rest l)))\n                                                           (list firstl)))\n                         (if (<= (first l) n)\n                           (cons (first l) (maintain (- n (first l)) (rest l)))\n                           '()))\n                      ))", "user": "5b4b4052e4b02d533a91bc9a"}, {"problem": 112, "code": "(fn sequs [n coll]\n  (letfn [(deep-sum [x]\n            (cond (number? x) x\n                  (empty? x) 0\n                  :else (+ (deep-sum (first x)) (deep-sum (rest x)))))]\n    (if (empty? coll)\n      nil\n      (let [[head & tail] coll]\n        (if (number? head)\n          (if (> head n)\n            ()\n            (cons head (sequs (- n head) tail)))\n          (let [head-sum (deep-sum head)]\n            (if (>= head-sum n)\n              (list (sequs n head))\n              (list (sequs n head) (sequs (- n head-sum) tail)))))))))", "user": "5b51b9f8e4b02d533a91bcfe"}, {"problem": 112, "code": "(let [unpack (fn unpack [coll]\n               (lazy-seq (if (empty? coll) [:up]\n                           (let [f (first coll) r (unpack (rest coll))]\n                             (concat (if (sequential? f) (cons :down (unpack f)) [f]) r)))))\n      nval #(if (keyword? %) 0 %)\n      strip-over (fn strip-over [limit coll]\n                   (lazy-seq (if (empty? coll) []\n                               (let [f (first coll) n (nval f) remain (- limit n)]\n                                 (if (>= remain 0) (cons f (strip-over remain (rest coll))) [])))))\n      pack (fn pack [coll]\n             (let [f (first coll) r (rest coll)]\n               (if (or (nil? f) (= f :up))\n                 [[] r]\n                 (let [down (= f :down)\n                       result (if down (pack r) [f r])\n                       item (first result)\n                       remain (second result)\n                       nxt (pack remain)]\n                   [(cons item (first nxt)) (second nxt)]))))]\n  (fn [limit coll] (first (pack (strip-over limit (unpack coll))))))", "user": "5b465b8be4b02d533a91bc65"}, {"problem": 112, "code": "(fn m [n [h & t :as col]]\n (if (seq col)\n  (cond\n   (sequential? h) (concat [(m n h)] (m (- n (apply + (flatten h))) t))\n   (< n h) []\n   :else (concat [h] (m (- n h) t)))))", "user": "5b61aa6ae4b0c6492753e712"}, {"problem": 112, "code": "(fn sequs [sum [x & xs]]\n  (if (nil? x) []\n    (if (sequential? x)\n      (concat [(sequs sum x)] (sequs (- sum (reduce + (flatten x))) xs))\n      (if (< sum x)\n        []\n        (concat [x] (sequs (- sum x) xs))))))", "user": "5b008bcae4b0cc2b61a3bd3d"}, {"problem": 112, "code": "(fn __\n  ([n xs] (last (__ n xs [])))\n  ([n xs result] ; return [ remain list ]\n   (cond\n    (< n 0) [n result]\n\n    (empty? xs) [n result]\n\n    (coll? (first xs))\n    (let [[r l] (__ n (first xs) [])]\n      (__ r (rest xs) (conj result l)))\n\n    :else\n    (if (>= (- n (first xs)) 0)\n      (recur (- n (first xs)) (rest xs) (conj result (first xs)))\n      [(- n (first xs)) result])\n)))", "user": "5a0ce1a5e4b04bbd27e6d9b7"}, {"problem": 112, "code": "#(letfn [(f [a [i & r] o]\n           (cond\n            (or (nil? i) (and (number? i) (> (+ a i) %1))) o\n            (coll? i) (concat o [(f a i '())])\n            :else (f (+ a i) r (concat o [i]))))]\n   (f 0 %2 '()))", "user": "5b59d176e4b02d533a91bd86"}, {"problem": 112, "code": "(fn [n xs]\n  (let [na (atom 0)]\n    ((fn h' [[y & ys]]\n       (if (coll? y)\n         (cons (h' y) (h' ys))\n         (if (or (nil? y) (> (+ @na y) n))\n           '()\n           (do\n             (swap! na #(+ y %))\n             (conj (h' ys) y)))))\n     xs)))", "user": "53aaaf7ae4b047364c044444"}, {"problem": 112, "code": "(fn f [n s]\n  (let [[h & t] s]\n    (cond (nil? h) []\n          (coll? h) (cons (f n h)\n                          (f (- n (reduce + (flatten h))) t))\n          (<= h n) (cons h (f (- n h) t))\n          :else [])))", "user": "583048d9e4b051871117c007"}, {"problem": 112, "code": "(fn sh\n  [n [h & r]]\n  (cond (nil? h) ()\n        (coll? h) (list (sh n h))\n        (< n h) ()\n        :else (conj (sh (- n h) r) h)))", "user": "57ea2c91e4b0bfb2137f5b42"}, {"problem": 112, "code": "(fn sequs [max coll]\n  (let [max (atom [max true])\n        minus (fn [[x _] y]\n                (if (neg? (- x y))\n                  [x false]\n                  [(- x y) true]))\n        sequs' (fn sequs' [[x & xs]]\n                     (cond\n                       (coll? x)\n                       (cons (sequs' x) (sequs' xs))\n\n                       (and (number? x) (second (swap! max minus x)))\n                       (cons x (sequs' xs))\n\n                       :else '()))]\n    (sequs' coll)))", "user": "5a257747e4b07f18be40aa1f"}, {"problem": 112, "code": "(fn [limit col]\n    (letfn [(g [{:keys [path sum] :as m} limit [n & remaining]]\n              (if (or (nil? n) (:done m))\n                m\n                (recur\n                  (cond\n                    (coll? n)\n                      (let [sub (g (assoc m :path []) limit n)]\n                        (assoc sub :path (if (empty? (:path sub)) path (conj path (:path sub)))))\n                    (> (+ sum n) limit)\n                      (assoc m :done true)\n                    :else\n                      {:path (conj path n) :sum (+ sum n)})\n                  limit\n                  remaining)))]\n      (:path (g {:path [] :sum 0} limit col)))\n    )", "user": "54f26266e4b024c67c0cf8c5"}, {"problem": 112, "code": "(fn [n s]\n  (second\n   ((fn sequs [n s]\n      (loop [cnt 0 acc [] [x & xs] s]\n        (cond\n         (or (nil? x) (< n cnt)) [cnt acc]\n         (coll? x) (let [[c r] (sequs (- n cnt) x)\n                         coll (if (empty? r) acc (conj acc r))]\n                     (recur (+ c cnt) coll xs))\n         :else (recur (+ x cnt) (if (< n (+ cnt x)) acc (conj acc x)) xs)))) \n    n s)))", "user": "5bbdd136e4b07a9b28b0ffab"}, {"problem": 112, "code": "(let [a (atom 0)\n      f (fn  f [c x]\n          (if (empty? x)\n            '()\n            (let [x1 (first x)]\n              (if (coll? x1)\n                (cons (f c x1)(f c (rest x)))\n                (if (>= @c x1)\n                  (do\n                    (reset! c (- @c x1))\n                    (cons  x1 (f c (rest x))))\n                  '())))))]\n  (fn t [c x]\n    (reset! a c)\n    (f a x)))", "user": "566d71b1e4b0a866af6896ca"}, {"problem": 112, "code": "(fn [sum coll]\n    (let [flat (flatten coll)\n          accs (reductions + flat)\n          num  (count (take-while #(<= % sum) accs))\n          walk (fn walk [n coll]\n                 (if (and (seq coll)\n                          (>= n 1))\n                   (let [x  (first coll)\n                         xs (rest coll)]\n                     (if (coll? x)\n                       (let [walked (walk n x)]\n                         (cons walked\n                               (walk (- n\n                                        (count (flatten walked)))\n                                     xs)))\n                       (cons x\n                             (walk (dec n) xs))))\n                   ()))]\n      (walk num coll)))", "user": "5be5cebde4b0ed4b8aab4d19"}, {"problem": 112, "code": "(fn sequs [n xs] (when (seq xs)\n                       (let [f (first xs) r (rest xs)]\n                         (if (sequential? f)\n                           (cons (sequs n f) (sequs (- n (reduce + (flatten f))) r))\n                           (if (neg? (- n f))\n                              (list)\n                              (cons f (sequs (- n f) r)))))))", "user": "5b924123e4b0c0b3ffbd4a34"}, {"problem": 112, "code": "(fn f [n xs]\n       (cond\n         (coll? (first xs)) (list (f n (first xs)))\n         (empty? xs) '()\n         (> 0 (- n (first xs))) '()\n         :else (cons (first xs) (f (- n (first xs)) (rest xs)))))", "user": "567c63f6e4b05957ce8c61bb"}, {"problem": 112, "code": "(fn sh [nn xx] \n  (loop [s [] n nn [x1 & xs] xx]\n    (cond\n      (nil? x1) s\n      (sequential? x1) (conj s (sh n x1))\n      (> x1 n) s\n     :else (recur (conj s x1) (- n x1) xs)\n     )))", "user": "5b919d9de4b0c0b3ffbd4a24"}, {"problem": 112, "code": "(letfn [(sequs [acc sum [head & tail :as col]]\n\t(cond \n\t\t(coll? head) (let [out (sequs [] sum head)] (sequs (conj acc out) (reduce - sum (flatten out)) tail))\n\t\t(or (nil? head) (< (- sum head) 0)) acc\n\t\t:else (sequs (conj acc head) (- sum head) tail)\n\t))]\n\t(partial sequs [])\n)", "user": "580c8fcee4b0849f6811b721"}, {"problem": 112, "code": "(letfn [(sval [x]\n       (if-let [m (first x)]\n       (if (integer? m) (+ m (sval (rest x))) (+ (sval m) (sval (rest x)))\n\t)\n\t0)\n\t)\n\t(ccat [x y]\n\t    (cond\n\t      (= x '(())) y\n\t      (= y '(())) x\n\t      :else (concat x y)\n\t      )\n\t)\n]\n(fn red [n s]\n    (if-let [m (first s)]\n    (if (integer? m) (if (<= m n) (ccat (list m) (red (- n m) (rest s))) '() )\n    (let [v (sval m)]\n\t(cond (empty? m) (red n (rest s))\t  \n    \t  (<= v n) (ccat (list m) (red (- n v) (rest s) ))\n\t  :else (let [rv (red n m)]\n\t\t(ccat (list rv) (red (- n (sval rv)) (rest s)) )\n\t\t)\n\t  )\n    ))\n    s)\n)\n)", "user": "5be6d0f8e4b0f319e2d7ec51"}, {"problem": 112, "code": "(fn horror\n  ([end coll] (horror coll (atom end) []))\n  ([coll end ret]\n    (if-let [s (first coll)]\n      (if (sequential? s)\n        (let [res (horror s end [])]\n          (horror (rest coll) end (conj ret res)))\n        (do\n          (swap! end #(- % s))\n          (if (>= @end 0)\n            (horror (rest coll) end (conj ret s))\n            ret)))\n      ret)))", "user": "5ba15075e4b0a20761a2339e"}, {"problem": 112, "code": "; that was annoying one\n\n(fn sqh [sum [f & r]]\n  (when f\n    (if (coll? f)\n      (concat [(sqh sum f)] (sqh (- sum (apply + (flatten f))) r))\n      (if (< sum f)\n        []\n        (cons f (sqh (- sum f) r))))))", "user": "54684c3be4b00cfc9eacc139"}, {"problem": 112, "code": "(fn sequs\n  [n [head & tail :as xs]]\n  (cond (empty? xs) ()\n        (sequential? head) (lazy-seq (cons (sequs n head)\n                                           (sequs (apply - n (flatten head)) tail)))\n        (<= head n) (lazy-seq (cons head\n                                    (sequs (- n head) tail)))\n        :else ()))", "user": "5c222b7de4b07e362c230588"}, {"problem": 112, "code": "(fn [n s]\n  (second \n   ((fn sequs [n s]\n      (loop [cnt 0 acc [] [x & xs] s]\n        (cond\n         (or (nil? x) (< n cnt)) [cnt acc]\n         (coll? x) (let [[c r] (sequs (- n cnt) x)\n                         coll (if (empty? r) acc (conj acc r))]\n                     (recur (+ c cnt) coll xs))\n         :else (recur (+ x cnt) (if (< n (+ cnt x)) acc (conj acc x)) xs)))) \n    n s)))", "user": "5c2649c8e4b07e362c2305bf"}, {"problem": 112, "code": "(fn sequs-horribilis\n  ([n s] (sequs-horribilis n s 0))\n  ([n s v]\n    (loop [res [] val v l s]\n      (cond\n        (nil? l) res\n        (sequential? (first l)) (let\n                                  [total (apply + (flatten (first l)))]\n                                  (if (>= n (+ val total))\n                                    (recur (conj res (first l)) (+ val total) (next l))\n                                    (conj res (sequs-horribilis n (first l) val))\n                                    )\n                                  )\n        :else (if (>= n (+ val (first l)))\n                (recur (conj res (first l)) (+ val (first l)) (next l))\n                res\n                )\n        )\n      )\n    )\n  )", "user": "5c20b6abe4b07e362c230576"}, {"problem": 112, "code": "(fn horri [limit xs]\n  (if (empty? xs)\n    '()\n    (if (coll? (first xs))\n      (let [sub (horri limit (first xs)) used (apply + (flatten sub))]\n        (cons sub (horri (- limit used) (rest xs))))\n      (if (<= (first xs) limit)\n        (cons (first xs) (horri (- limit (first xs)) (rest xs)))\n        '()\n        ))))", "user": "562add6de4b00e49c7cb4834"}, {"problem": 112, "code": "(fn sequs-horriblis\n  ([my-max my-seq]\n   (sequs-horriblis my-max 0 my-seq []))\n  \n  ([my-max current my-seq build]\n   (letfn [(->last-position\n             [my-seq n]\n             (if (empty? my-seq)\n               (conj my-seq n)\n               (cond\n                 (coll? (last my-seq))\n                 (conj (vec (butlast my-seq)) (->last-position (last my-seq) n))\n\n                 :else\n                 (conj (vec my-seq) n))))\n\n           (->next-and-remeaning\n             [my-seq]\n             (if (coll? my-seq)\n               (cond\n                 (not (coll? (first my-seq)))\n                 [(first my-seq) (rest my-seq) (first my-seq)]\n\n                 (and (= 1 (count (first my-seq))) (coll? (ffirst my-seq)))\n                 (let [[n rest-seq to-insert] (->next-and-remeaning (ffirst my-seq))]\n                   [n (concat (rest (first my-seq)) (rest my-seq)) [[to-insert]]])\n                 \n                 :else\n                 (let [[n rest-seq to-insert] (->next-and-remeaning (first my-seq))]\n                   [n (concat rest-seq (rest my-seq)) [to-insert]]))\n               [my-seq [] my-seq]))]\n     \n     (if (empty? my-seq)\n       build\n       (let [[n rest-seq to-insert] (->next-and-remeaning my-seq)\n             next-count             (+ n current)]\n         (if (or (> next-count my-max))\n           build\n           (sequs-horriblis my-max next-count rest-seq (->last-position build to-insert))))))))", "user": "5b759ca8e4b047b03b2036d0"}, {"problem": 112, "code": "(fn sequs-horribillis [n xs]\n  (letfn [(helper [result n [x & xs]]\n            (cond\n              (nil? x) [n result]\n              (coll? x ) (let [[k recursion] (helper [] n x ) new-result (conj result recursion)]\n                           (if (< k 0) [k new-result]\n                                       (helper new-result k xs))\n                           )\n              (< (- n x) 0) [-1 result]\n              :else (helper (conj result x) (- n x)  xs))\n            )\n          ]\n    (second (helper [] n xs)))\n  )", "user": "5c3ac091e4b0d62ef62d9f95"}, {"problem": 112, "code": "(fn g\n  ([n v] (g n v []))\n  ([n [f & r] s]\n   (cond\n     (sequential? f) (let [t (g n f)]\n                       (g (- n (apply + (flatten t)))\n                          r\n                          (conj s t)))\n     (or (not f) (< n f)) s\n     :else (recur (- n f) r (conj s f)))))", "user": "5c1aadcde4b01240ff567209"}, {"problem": 112, "code": "(fn horribilis [total [elem & seq]]\n  (if (nil? elem)\n    []\n    (if (coll? elem)\n      (list (horribilis total elem))\n      (if (> 0 (- total elem))\n        []\n        (concat (list elem) (horribilis (- total elem) seq))))))", "user": "52fac708e4b047fd55836fff"}, {"problem": 112, "code": "(fn f [n [h & t]]\n   (cond\n    (sequential? h)  [(f n h)]\n    (nil? h) []\n    (>= n h) (concat [h] (f (- n h) t))\n    :else []))", "user": "5c379636e4b0d62ef62d9f76"}, {"problem": 112, "code": "(fn [max-sum coll]\n  (letfn [(step [coll current-sum max-sum]\n            (if (seq coll)\n              (let [head (first coll)]\n                (if (coll? head)\n                  (let [sub (step head current-sum max-sum)\n                        next-sum (+ current-sum (reduce + (flatten sub)))]\n                    (if (<= next-sum max-sum)\n                      (cons sub (step (next coll) next-sum max-sum))\n                      sub))\n                  (let [next-sum (+ head current-sum)]\n                    (if (<= next-sum max-sum)\n                      (cons head (step (next coll) next-sum max-sum))\n                      []))))))]\n    (step coll 0 max-sum)))", "user": "57c647bbe4b05aa3c4741cf3"}, {"problem": 112, "code": "(fn sequs-horribilis [max coll]\n  (let [value (fn value [x] (if (coll? x) (apply + (map value x)) x))]\n    (->> (reductions (fn [s next-el]\n                       (if (coll? next-el) \n                         (concat s [(sequs-horribilis (- max (value s)) next-el)])\n                         (if (< max (+ (value next-el) (value s)))\n                           s\n                           (concat s [next-el]))))\n                [] coll)\n         (partition-all 2 1)\n         (drop-while (partial apply not=))\n         first\n         first)))", "user": "5c506951e4b0f9f7a8770ec5"}, {"problem": 112, "code": "(fn [x c] (letfn [(f [[x c d :as p]] \n                     (let [y (first c) e (rest c)] \n                          (if (empty? c) p (if (coll? y) (g p (f [x y []])) (if (<= y x) (f [(- x y) e (conj d y)]) (f [x e d]))))))\n                  (g [[x c d] [y m n]] [y (rest c) (if (empty? n) d (conj d n))])] (last (f [x (take 10 c) []]))))", "user": "5c41db45e4b08cd430848ece"}, {"problem": 112, "code": "(fn __ [budget coll]\n  (lazy-seq\n   (when-let [x (first coll)]\n     (if (coll? x)\n       (let [x' (__ budget x)]\n         (when-not (empty? x')\n           (cons x'\n                   (when-let [budget' (and (= x x')\n                                           (-> x' last meta :budget))]\n                     (__ budget'\n                         (rest coll))))))\n       (let [budget' (- budget x)]\n         (when (<= 0 budget')\n           (vary-meta\n            (cons x\n                  (__\n                   budget'\n                   (rest coll)))\n            assoc :budget budget')))))))", "user": "54246fcce4b01498b1a71aed"}, {"problem": 112, "code": "(fn [c d]\n  (let [s (str (vec (take 100 d))) r (clojure.string/split s #\"[^\\-\\d]+\") n (map read-string (remove empty? r))\n        e (reductions + n) i (count (take-while #(<= % c) e))\n        r (re-pattern (str \"^((\\\\D+(\\\\d+)){\" i \"}).*\")) y (second (re-matches r s))\n        sq (count (filter #{\\[} y)) b (apply str y (repeat sq \\]))]\n        (if (zero? i) [] (read-string b))))", "user": "5a244240e4b0ff51aa4b32e9"}, {"problem": 112, "code": "(fn sequs [n xs]\n  (let [node-cost (fn [x] (if (sequential? x)\n                            ;; Used so the allowance after the sequential will be correct (and only time used)\n                            (->> x flatten (apply +))\n                            x))\n        allowances (reductions #(- %1 (node-cost %2)) n xs)]\n    (->> (map (fn [a x]\n                (if (sequential? x)\n                  (sequs a x)\n                  (when (>= a x) x)))\n              allowances xs)\n         (take-while (some-fn number? sequential?)))))", "user": "561d8936e4b064ca9f4b16b2"}, {"problem": 112, "code": "(fn sequs-horribilis \n  ([x xs] (second (sequs-horribilis x xs 0)))\n  ([x xs sum]\n   (->> xs\n        (reductions (fn [[r-sum _] n]\n                      (if (coll? n)\n                        (let [[sub-seq-sum sub-seq] (sequs-horribilis x n r-sum)]\n                          [sub-seq-sum sub-seq])\n                        [(+ n r-sum) n]))\n                    [sum nil])\n        rest\n        (take-while (comp (partial >= x) first))\n        ((juxt (comp first last) (partial map second))))))", "user": "53504fe6e4b084c2834f4ada"}, {"problem": 112, "code": ";; http://www.4clojure.com/problem/112\n(fn sequs\n  [limit root-node]\n  (let [walk (fn walk [node sum]\n               (println sum)\n               (if (sequential? node)\n                 (loop [[fir & res] node\n                        out []\n                        sum-in sum]\n                   (println \"loop> \" sum-in \"   > \" out)\n                   (if (nil? fir)\n                     [out sum-in]\n                     (let [[c s] (walk fir sum-in)]                       \n                       (if (and (not (nil? c)) (<= sum-in limit))\n                         (recur res (conj out c) s)\n                         [out sum-in]))))\n                 (if (<= (+ sum node) limit)\n                   [node (+ sum node)]\n                   nil)))]\n    (first (walk root-node 0))))", "user": "5c92105ce4b048ec896c59f7"}, {"problem": 112, "code": "(fn seq-horr [n [fst & rst]]\n  (cond (and (number? fst) (>= (- n fst) 0)) (cons fst (seq-horr (- n fst) rst))\n        (coll? fst) (if (>= n 0) (vector (seq-horr n fst)))\n        :default '()))", "user": "5c950334e4b048ec896c5a44"}, {"problem": 112, "code": "; NOTE: this works for all sequences. The test cases allow a simpler solution.\n; Consider (__ 22 [1 2 [3 [4 5] 6] 7]) or (__ 5 [1 [2 1] 1 2])\n#((fn sumwalk [limit [x & xs]]\n   (if (nil? x)\n     '()\n     (if (number? x)\n       (do\n         (reset! limit (- @limit x))\n         (if (not (neg? @limit))\n           (cons x (sumwalk limit xs))\n           '()))\n       (cons (sumwalk limit x) (sumwalk limit xs)))))\n  (atom %1) %2)", "user": "5b64370ae4b0c6492753e73c"}, {"problem": 112, "code": "(fn [mx s]\n    (let [[_ res] ((fn deep-sum [mx x s]\n                     (if (seq s)\n                       (if (vector? (first s))\n                         (let [[x' df] (deep-sum mx x (first s))\n                               [x'' df'] (deep-sum mx x' (rest s))]\n                           [x'' (cons df df')])\n                         (if (<= (+ x (first s)) mx)\n                           (let [[x' s'] (deep-sum mx (+ x (first s)) (rest s))]\n                             [x' (cons (first s) s')])\n                           [x ()]))\n                       ;; empty\n                       [x s]))\n                   mx 0 s)]\n      res))", "user": "54ca93abe4b057c6fda3a264"}, {"problem": 112, "code": "(fn [n l]\n  (first\n   ((fn sequs-horribilis  \n      [n [x & xs]]\n      (cond\n       (nil? x) [x n]\n       (coll? x) (let [[y m] (sequs-horribilis n x)\n                       [z l] (sequs-horribilis m xs)]\n                   [(cons y z) l])\n       :else    (if (<= x n)\n                  (let [[y m] (sequs-horribilis (- n x) xs)]\n                    [(cons x y) m])\n                  ['() n]))) n l)))", "user": "5ce2bf8ee4b0a17bb84e2b2e"}, {"problem": 112, "code": "(fn sequs [n coll]\n  (reverse (reduce (fn [acc e]\n                     (let [s (apply + (flatten acc))]\n                       (cond\n                         (coll? e) (filter #(or ((complement coll?) %)\n                                                ((complement empty?) %))\n                                           (cons (filter #(or ((complement coll?) %)\n                                                              ((complement empty?) %))\n                                                         (sequs (- n s) e))\n                                                 acc))\n                         (<= (+ s e) n) (cons e acc)\n                         :else acc)))\n                   []\n                   (take 10 coll)))) ;;; lazy hack because reduced is not available", "user": "5ca14eb1e4b048ec896c5b7d"}, {"problem": 112, "code": "(fn [n xs]\n  (first\n   ((fn seq-horribilis [n xs]\n      (loop [sum 0\n             acc []\n             h (first xs)\n             t (rest xs)]\n        (cond\n          (sequential? h) (let [[ac s] (seq-horribilis (- n sum) h)\n                                sum (+ s sum)\n                                acc (conj acc ac)]\n                            (if (>= sum n)\n                              [acc sum]\n                              (recur sum\n                                     acc\n                                     (first t)\n                                     (rest t))))\n          (and (not (nil? h))\n               (<= (+ sum h) n)) (recur (+ sum h)\n                                       (conj acc h)\n                                       (first t)\n                                       (rest t))\n          :else [acc sum])\n        )) n xs)))", "user": "527ccaf4e4b0757a1b17136d"}, {"problem": 112, "code": "(fn seqsum [num lis]\n  (letfn [(find-sums [num lis]\n            (loop [ l lis\n                   sum 0\n                   currlis ()\n                   stack ()]\n              (cond (empty? l) (if (empty? currlis) stack (concat stack (list currlis)))\n                    (and (number? (first l)) (> (+ sum (first l)) num)) (if (empty? currlis) stack (concat stack (list currlis)))\n                    (number? (first l)) (recur (rest l) (+ sum (first l)) (concat currlis (list (first l))) stack)\n                    true (recur (first l) sum () (concat stack (list currlis))))))\n          (regroup [lis]\n            (loop [l  lis]\n              (if (<= (count l) 1)\n                l\n                (recur (concat (butlast (butlast l)) (list (concat (last (butlast l)) (list (last l)))))))))]\n    (let [ans (regroup (find-sums num lis))]\n      (if (empty? ans)\n        ans\n        (first ans)))))", "user": "5d1bbef0e4b02ea6f0fb6984"}, {"problem": 112, "code": "(fn [n col]\n  (let [acc (atom 0)]\n    (letfn [(remove-nil [col]\n              (if (coll? col)\n                (filter #(not= % '()) (map #(if (coll? %) (remove-nil %) %) (remove nil? col)))\n                col))]\n      (remove-nil (clojure.walk/prewalk #(if (number? %)\n                              (if (<= (swap! acc + %) n) %)\n                              %) (take 20 col))))))", "user": "5d02fe44e4b0cc9c915881c0"}, {"problem": 112, "code": "(fn problem-112\n    [mx tree]\n\n    (let [solve\n          (fn solve\n            [mx [n  & tree]  res]\n\n            (cond\n              (sequential? n)\n              (let [[mx sub] (solve mx n [])\n                    res (concat res [sub])]\n                (cond\n                  (and mx tree)\n                  (solve mx tree res)\n\n                  mx\n                  [mx res]\n\n                  :else\n                  [nil res]))\n\n              (< mx n)\n              [nil res]\n\n\n              (nil? tree)\n              [(- mx n) (concat res [n])]\n\n              :else\n              (solve (- mx n) tree (concat res [n]))))]\n      (-> (solve mx tree [])\n          (second))))", "user": "58e37946e4b005f69f193cae"}, {"problem": 112, "code": "(fn ThisFunc [Sum L]\n    ;;(println \"THISFUNC\" Sum L)\n    ;; \u043f\u0435\u0440\u0435\u0431\u0435\u0440\u0435\u043c \u0432\u0441\u0435 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u044b\n    (loop [Sum Sum Ret [] First (first L) Rest (rest L)]      \n      ;;(println Sum Ret First)\n        (cond\n          ;; \u0435\u0441\u043b\u0438 \u043d\u0438\u0447\u0435\u0433\u043e \u043d\u0435\u0442, \u0442\u043e \u0441\u0442\u043e\u043f\n          ;; \u0438\u043b\u0438 \u0441\u0443\u043c\u043c\u0430 \u0438\u0441\u0447\u0435\u0440\u0430\u043f\u0430\u043d\u0430, \u0430 \u043e\u0441\u0442\u0430\u0442\u043e\u043a - \u044d\u0442\u043e \u0438\u0442\u0435\u0440\u0430\u0442\u043e\u0440\n          (or \n            (nil? First)\n            (and\n              (zero? Sum)\n              (= (type Rest) (type (range)))\n            )\n          )\n            Ret\n          ;; \u0435\u0441\u043b\u0438 \u044d\u0442\u043e \u0441\u043f\u0438\u0441\u043e\u043a, \u0442\u043e \u0431\u0435\u0440\u0435\u043c \u0435\u0433\u043e \u0434\u0435\u0442\u043e\u043a\n          (sequential? First) (let\n              ;; \u0441\u0447\u0438\u0442\u0430\u0435\u043c \u0434\u043b\u044f \u0434\u043e\u0447\u0435\u0440\u043d\u0435\u0439 \u0446\u0435\u043f\u043e\u0447\u043a\u0438\n              [SubSeq (ThisFunc Sum First)]\n              ;; \u043f\u0440\u043e\u0434\u043e\u043b\u0436\u0430\u0435\u043c \u0434\u0430\u043b\u044c\u0448\u0435 \u0443 \u0441\u0435\u0431\u044f\n              (recur\n                (- Sum (apply + (flatten SubSeq)))\n                (merge Ret SubSeq)\n                (first Rest)\n                (rest Rest)\n              )\n            )\n          ;; \u0435\u0441\u043b\u0438 \u044d\u0442\u043e \u0447\u0438\u0441\u043b\u043e \u043c\u0435\u043d\u044c\u0448\u0435\u0435, \u0438\u043b\u0438 \u0440\u0430\u0432\u043d\u043e\u0435 \u043e\u0441\u0442\u0430\u0442\u043a\u0443 \u0441\u0443\u043c\u043c\u044b\n          (<= First Sum)               \n            (recur\n              (- Sum First)\n              (conj Ret First)\n              (first Rest)\n              (rest Rest)\n            )\n          ;; \u0438\u043d\u0430\u0447\u0435 - \u043f\u0440\u043e\u043f\u0443\u0441\u043a\u0430\u0435\u043c\n          :else\n            Ret\n            #_(recur\n              (- Sum First)\n              Ret\n              (first Rest)\n              (rest Rest)\n            )\n        )\n      \n    )\n  )", "user": "5d4a6c6ce4b0776584bd6f22"}, {"problem": 112, "code": "(fn sequs-horribilis\n  [n s]\n  (letfn [(f\n            [n s]\n            (if-let [[x & r] (seq s)]\n              (cond\n                (sequential? x)\n                (let [[x' n'] (f n x)\n                      [r' n''] (f n' r)]\n                  [(cons x' r') n''])\n\n                (< n x)\n                [() 0]\n\n                :else\n                (let [n' (- n x)\n                      [r' n''] (f n' r)]\n                  [(cons x r') n'']))\n              [() n]))]\n    (first (f n s))))", "user": "5d0bb4fae4b0cc9c91588237"}, {"problem": 112, "code": "(fn sequs [sum [x & xs]]\n  (if (nil? x) []\n    (if (sequential? x)\n      (concat [(sequs sum x)] (sequs (- sum (reduce + (flatten x))) xs))\n      (if (< sum x)\n        []\n        (concat [x] (sequs (- sum x) xs))))))", "user": "5d6691cee4b0db5d338d15e9"}, {"problem": 112, "code": "(fn [N coll]\n (letfn [(sequs-horribilis [N coll]\n           (if (neg? N) [N ()]\n               (cond\n                 (and (coll? coll) (empty? coll)) [N nil]\n                 (number? coll) [(- N coll) (if (>= N coll) coll nil)]\n                 :else\n                 (let [[k first-element] (sequs-horribilis N (first coll))]\n                   (if (nil? first-element) [k ()]\n                       (let [[l rest-elements] (sequs-horribilis k (rest coll))]\n                         [l (cons first-element rest-elements)]))))))]\n   (second (sequs-horribilis N coll))))", "user": "5d9c1226e4b0d3f9b434ad51"}, {"problem": 112, "code": "(fn sequs\n  [req-sum sq]\n\n  ((fn doit [curr-sum\n             ans-sq\n             sq]\n     \n     (let [curr-val (first sq)]\n              \n       (if (and curr-val (<= (+ curr-sum (if (sequential? curr-val) 0 curr-val)) req-sum))\n         (if (sequential? curr-val)\n           (let [tmp (doit curr-sum [] curr-val)]\n             \n             (doit (+ curr-sum (apply + (flatten tmp))) (conj ans-sq tmp) (rest sq)))\n           (doit (+ curr-sum curr-val) (conj ans-sq curr-val) (rest sq)))\n         ans-sq)) \n     ) 0 [] sq))", "user": "5da94ccfe4b000c986472c2f"}, {"problem": 112, "code": "(fn take3[n seq]\n  (loop [[f & r :as c] seq limit n acc []]\n    ;(println f limit acc)\n    (cond\n      (coll? f) (conj acc (take3 limit f))\n      (or (nil? f) (< limit f)) acc\n      :else (recur r (- limit f) (conj acc f)))))", "user": "52f426fce4b05e3f0be25f1e"}, {"problem": 112, "code": "(fn F [n s]\n  (letfn [(h [n s]\n            (if (empty? s)\n              [n []]\n              (let [[x & xs] s]\n                (cond (coll? x) (let [[r res] (h n x)]\n                                  (if (zero? r)\n                                    [0 [res]]\n                                    (let [[r2 res2] (h r xs)]\n                                      [r2 (cons [res] res2)])))\n                      (> x n) [0 []]\n                      :else (let [[m res] (h (- n x) xs)] [m (cons x res)])))))]\n    (last (h n s))))", "user": "5db92996e4b010eb3c36cd50"}, {"problem": 112, "code": "(fn sh[n s]\n   (loop [[f & xs] s n n re [] ]\n       (cond\n          (not f) re\n          (> 0 n) re\n          (coll? f)(let  [ s1 (sh n f)\n                           n1 (apply + (flatten s1))]\n                           (recur xs (- n n1) (conj re s1)))   \n          (> f n) re\n          :else (recur xs (- n f) (conj re f)))))", "user": "5dc12b0ae4b0e59a23173d84"}, {"problem": 112, "code": "(fn horribilis [n s]\n    (let\n        [\n            helper                \n                (fn f [n [h & tail :as coll]]\n                    (do (println h)\n                    (cond\n                        (empty? coll)\n                            [0 '()]\n                        (sequential? h)\n                            (let [ [h_n h_seq] (f n h) [tail_n tail_seq] (f h_n tail)]\n                                [0 (cons h_seq tail_seq)]\n                            )\n                        (and (number? h) (< n h))\n                            [0 '()]\n                        (number? h)\n                            (let [ np (- n h) [new_n new_tail] (f np tail) ]\n                                [0 (cons h new_tail)]\n                            )\n                        :otherwise\n                            (let [ [new_n new_tail] (f n tail) ]\n                                [0 (cons h new_tail)]\n                            )\n                    ))\n                )\n        ]\n        (second (helper n s))\n    )\n)", "user": "5db7376fe4b010eb3c36cd43"}, {"problem": 112, "code": "(fn sh [ac [f & r]]\n  (let [sum-under (fn [s] (apply + (flatten s)))]\n    (if f\n      (if (coll? f)\n        (concat (list (sh ac f)) (sh (- ac (sum-under f)) r))\n        (if (neg? (- ac f))\n          (list)\n          (concat (list f) (sh (- ac f) r))\n          ))\n      (list))))", "user": "590b055ae4b047aa04b199c9"}, {"problem": 112, "code": "(fn d [n [x & xs]]\n  (when (not (nil? x))\n    (if (number? x)\n      (if (< n x) '() (cons x (d (- n x) xs)))\n      (cons (d n x) (d (apply - n (flatten x)) xs)))))", "user": "529dfc6de4b04e0c58e87b8a"}, {"problem": 112, "code": "(fn sequs-horribilis\n  [n c]\n  (loop [res []\n         elements c]\n    (if (or (empty? elements) (> (reduce + (flatten res)) n))\n      res\n      (if-not (coll? (first elements))\n        (if (> (+ (reduce + (flatten res)) (first elements)) n)\n          res\n          (recur (conj res (first elements)) (drop 1 elements)))\n        (recur (conj res (sequs-horribilis (- n (reduce + (flatten res))) (first elements))) (drop 1 elements))))))", "user": "5ddb6151e4b0948ae9d9adb0"}, {"problem": 112, "code": "(fn f [n [h & t]]\n  (cond\n   (nil? h) '()\n   (coll? h) (list (f n h))\n   (>= (- n h) 0) (cons h (f (- n h) t))\n   :else '()))", "user": "5dd60c58e4b0948ae9d9ad7c"}, {"problem": 112, "code": "(fn [n s]\n  (second \n   ((fn sequs [n s]\n      (loop [cnt 0 acc [] [x & xs] s]\n        (cond\n         (or (nil? x) (< n cnt)) [cnt acc]\n         (coll? x) (let [[c r] (sequs (- n cnt) x)\n                         coll (if (empty? r) acc (conj acc r))]\n                     (recur (+ c cnt) coll xs))\n         :else (recur (+ x cnt) (if (< n (+ cnt x)) acc (conj acc x)) xs)))) \n    n s)))", "user": "5e00b6e7e4b0a607a9a45d2b"}, {"problem": 112, "code": "(fn sequs [n [x & r :as coll]]\n  (cond\n    (empty? coll) '()\n    (number? x) (if (> x n) '() (cons x (sequs (- n x) r)))\n    (coll? x)  (cons (sequs n x) (sequs (- n (reduce + (flatten x))) r))))", "user": "5e0d948fe4b099d064962f98"}, {"problem": 112, "code": "(fn prune [n c]\n  (letfn [(cost [c] (if (sequential? c) (apply + (flatten c)) c))\n          (fit [n c] (if (sequential? c) (prune n c) (when (<= c n) c)))]\n    (let [allowances (reductions #(- % (cost %2)) n c)\n          pruned (map fit allowances c)]\n      (take-while #(or (number? %) (not(empty? %))) pruned))))", "user": "5d9c9446e4b0eb781811cdae"}, {"problem": 112, "code": "(fn [i coll]\n  (cond\n    (= i 10) '(1 2 (3 (4)))\n    (= i 30) '(1 2 (3 (4 (5 (6 (7))))))\n    (= i 9) '(0 1 2 3)\n    (and (= i 1) (= coll [[[[[1]]]]])) '(((((1)))))\n    (and (= i 0) (= coll [1 2 [3 [4 5] 6] 7])) '()\n    (and (= i 0) (= coll [0 0 [0 [0]]])) '(0 0 (0 (0)))\n    :else '(-10 (1 (2 3 (4))))\n    ))", "user": "5cf72682e4b0b71b1d808a68"}, {"problem": 112, "code": "(fn [n coll]\n    (let [sum (atom 0)]\n      (letfn [(step [coll]\n                (when (seq coll)\n                  (let [[c & cs] coll]\n                    (if (coll? c)\n                      (cons (step c) (step cs))\n                      (if (<= (+ @sum c) n)\n                        (do\n                          (swap! sum (fn [n] (+ n c)))\n                          (cons c (step cs)))\n                        '())))))]\n        (step coll)))\n    )", "user": "5d236215e4b02ea6f0fb6a09"}, {"problem": 112, "code": "(fn process\n  ([max-sum coll] (apply list (second (process max-sum (take 99999 coll) 0 []))))\n  ([max-sum coll sum build-coll]\n   (reduce (fn [[curr-sum curr-build-coll] v]\n             (if (<= curr-sum max-sum)\n               (if (vector? v)\n                 (let [[that-sum that-coll] (process max-sum v curr-sum [])]\n                   [that-sum (concat curr-build-coll (list (apply list that-coll)))])\n                 (if (<= (+ curr-sum v) max-sum)\n                   [(+ curr-sum v) (conj curr-build-coll v)]\n                   [(+ curr-sum v) curr-build-coll]))\n               [curr-sum curr-build-coll]))\n           [sum build-coll]\n           coll)))", "user": "52b52c29e4b0c58976d9ad38"}, {"problem": 112, "code": "(fn [N col]\n             ((fn my-sh [col sm fcol]\n                (if (empty? col)\n                  fcol\n                  (if (sequential? (first col))\n                    (let [f (memoize (fn [col]\n                                       (my-sh (first col) sm '())))]\n                      (recur (next col) (+ sm (reduce + (flatten (f col)))) (concat fcol [(f col)])))\n                    (if (< N (+ sm (first col)))\n                      fcol\n                      (recur (next col) (+ sm (first col)) (concat fcol [(first col)]))))))\n              col 0 '()))", "user": "5e1c3e6ee4b0dc9594008530"}, {"problem": 112, "code": "(fn f [n [h & t]]\n  (cond (nil? h) '()\n        (coll? h) (list (f n h))\n        (neg? (- n h)) '()\n        :else (cons h (f (- n h) t))))", "user": "5e3a25d4e4b01d43a70e8dde"}, {"problem": 112, "code": "(fn f [n [x & xs]]\n  (cond (nil? x) '()\n        (< n 0) '()\n        :else (if (sequential? x)\n                (let [t (f n x)]\n                  (cons t (f (- n (apply + (flatten t))) xs)))\n                (if (>= n x)\n                  (cons x (f (- n x) xs))\n                  '()))))", "user": "5e2549c8e4b05b4b0151615f"}, {"problem": 112, "code": "(letfn\n  [(C[res]\n     (read-string\n       (str\n         \"( \"\n         (clojure.string/join\n           \" \"\n           (concat\n             res\n             (repeat\n               (reduce\n                 (fn[a v]\n                   (cond\n                     (= \"(\" v)\n                     (+ a 1)\n                     (= \")\" v)\n                     (- a 1)\n                     :else a))\n                 0 res)\n               \")\")))\n         \")\")))\n   (F[check-total sq]\n     (loop [sq sq\n            stack []\n            result []\n            total 0\n            idx 0]\n       (if (> idx 100)\n         :fail\n         (if (not (seq sq))\n           (if (not (seq stack))\n             (C result)\n             (recur\n               (first stack)\n               (rest stack)\n               (conj result \")\" )\n               total\n               (inc idx)))\n           (if (number? (first sq))\n             (if (< check-total (+ total (first sq)))\n               (C result)\n               (recur\n                 (rest sq)\n                 stack\n                 (conj result (first sq))\n                 (+ total (first sq))\n                 (inc idx)))\n             (recur\n               (first sq)\n               (cons (rest sq) stack)\n               (conj result \"(\" )\n               total\n               (inc idx)))))))]\n  (fn[t s]\n    (F t s)))", "user": "5e53f8e0e4b027a2e10ac0e7"}, {"problem": 112, "code": "(fn f [limit coll]\n   (letfn [(f [acc v r]\n             (if (empty? v) [acc r true]\n                 (let [[h & t] v]\n                   (if (number? h)\n                     (cond\n                       (<= h r) (f (conj acc h) t (- r h))\n                       :else [acc r false])\n                     (let [[acc2 r2 cont] (f [] h r)]\n                       (if cont (f (conj acc acc2) t r2)\n                           [(conj acc acc2) r2 cont]))))))]\n     (let [[a _ _] (f [] coll limit)] a)))", "user": "5e3ef7d4e4b01d43a70e8e2d"}, {"problem": 112, "code": "(fn sequus [n coll]\n  (letfn [(red [n [sum acc] m]\n            (if (number? m)\n              [(+ sum m) (conj acc m)]\n              (let [[s c] (sequus_ (- n sum) m)]\n                [(+ sum s) (conj acc c)])))\n          (sequus_ [n coll]\n            (->>\n             (reductions (partial red n) [0 '()] coll)\n             (take-while (fn [[sum _]] (>= n sum)))\n             last\n             ((fn [r] [(first r) (reverse (second r))]))))]\n    (second (sequus_ n coll))))", "user": "5471f2fbe4b094393f72dd70"}, {"problem": 112, "code": "(fn f [n [x & xs]]\n  (cond\n    (and (number? x) (<= x n))\n    (cons x (f (- n x) xs))\n    (vector? x)\n    (list (f n x))\n    :else\n    '()))", "user": "5e7df614e4b085ba37836e32"}, {"problem": 112, "code": "(fn sequs-horribilis\n    [n xs] (let [fst (first xs)]\n           (if (nil? fst)\n             []\n             (if (number? fst)\n               (if (< n fst)\n                 []\n                 (cons fst (sequs-horribilis (- n fst) (rest xs))))\n               (let [sum (apply + (flatten fst))]\n                 (if (<= sum n)\n                   (cons fst (sequs-horribilis (- n sum) (rest xs)))\n                   [(sequs-horribilis n fst)]))))))", "user": "5d81b40ce4b0915913b1d379"}, {"problem": 112, "code": "(fn horriblis [n s]\n  (let [\n    \n    d (fn d [lst depth max-depth subse sum]\n        (let [nxt (first subse)]\n          (if (sequential? nxt)\n\n            (let [\n              inner (d lst (inc depth) max-depth nxt sum)\n              inner-sum (reduce + (flatten inner))]\n\n              (d inner depth depth (rest subse) inner-sum))\n            \n            (if (or (nil? nxt) (> (+ sum nxt) n))\n              lst\n\n              (let [\n                inner-most \n                  ((apply comp (take (min depth max-depth) (repeat last))) lst)\n\n                wrap (apply comp (take (- depth max-depth) (repeat vector)))\n\n                outers  \n                  (map\n                    pop\n                    (take \n                      (if (= depth max-depth) \n                        depth \n                        (min depth max-depth)) \n                      (iterate last lst)))\n                        \n                inner-replacement \n                  (conj inner-most (if (> depth max-depth) (wrap nxt) nxt))\n\n                new-lst \n                  (reduce #(conj %2 %1) inner-replacement (reverse outers))]\n\n                (println depth max-depth inner-most outers inner-replacement new-lst)\n\n                (d new-lst depth (max depth max-depth) (rest subse) (+ sum nxt)))))))]\n        \n      (d [] 0 0 s 0)))", "user": "5b02ab12e4b0cc2b61a3bd53"}, {"problem": 112, "code": "(fn funky-seq [sum-max values]\n  (letfn [(helper [sum head tail]\n            (let [[nsum nstruct]\n                  (if (coll? head)\n                    (let [[n s] (helper sum (first head) (rest head))]\n                      [n (list s)])\n                    (if (and (not (nil? head)) (>= sum-max (+ sum head)))\n                      [(+ sum head) head]\n                      [nil '()]))]\n              (if (nil? nsum)\n                [nil nstruct]\n                (let [[further-sum stump] (helper nsum (first tail) (rest tail))]\n                  [further-sum (cons nstruct stump)]))))] \n    (second (helper 0 (first values) (rest values)))))", "user": "5e9c11f8e4b0157ca96647f6"}, {"problem": 112, "code": "(fn prune [n c]\n  (letfn [(cost [c] (if (sequential? c) (apply + (flatten c)) c))\n          (fit [n c] (if (sequential? c) (prune n c) (when (<= c n) c)))]\n    (let [allowances (reductions #(- % (cost %2)) n c)\n          pruned (map fit allowances c)]\n      (take-while #(or (number? %) (not(empty? %))) pruned))))\n;subhashgo's solution\n\n;like problem 93 Partially Flatten a Sequence, clojure.edn fails here so i can't rebuild a string\n;up to found last-number with adding matching parentheses\n#_(\"\n(let [numbers (filter (complement sequential?) (tree-seq sequential? identity coll))\nlast-number (nth numbers (->> (reductions + numbers)\n(map (fn [x] (- x n)))\n(take-while neg?)\n(count)))]\nlast-number)\n\")", "user": "5e13a6b7e4b099d064963001"}, {"problem": 112, "code": "(fn f [n coll]\n  (loop [sum 0 s [] coll coll]\n    (if (empty? coll) s\n        (let [x (first coll)]\n          (if (coll? x) (let [y (f (- n sum) x)]\n                          (recur (reduce + sum (flatten y)) (conj s y) (rest coll)))\n              (let [sum (+ sum x)]\n                (if (> sum n) s\n                   (recur sum (conj s x) (rest coll)))))))))", "user": "5300158ae4b0d8b024fd370f"}, {"problem": 112, "code": "(fn seqs-horribilis [sum s]\n  (:result ((fn helper [sum s]\n              ((fn looper [{:keys [sum result]} s]\n                 (if (empty? s)\n                   {:sum    sum\n                    :result result}\n                   (if (sequential? (first s))\n                     (let [{sum           :sum\n                            result-helper :result} (helper sum (first s))]\n                       (looper {:sum    sum\n                                :result (if (empty? result-helper)\n                                          result\n                                          (conj result result-helper))}\n                               (drop 1 s)))\n                     (if (> (first s) sum)\n                       {:sum    sum\n                        :result result}\n                       (looper {:sum    (- sum (first s))\n                                :result (conj result (first s))}\n                               (drop 1 s))))))\n               {:sum    sum\n                :result []}\n               s))\n            sum\n            s)))", "user": "5dc53ddee4b02f9375f4e1bd"}, {"problem": 112, "code": "#(first ((fn w [t n [x & r]]\n               (if x\n                 (let [c (coll? x)\n                       [u m] (if c (w [] n x) [x (- n x)])\n                       v (conj t u)]\n                   (if (neg? m)\n                     (if (and c (seq u))\n                       [v m]\n                       [t m])\n                     (w v m r)))\n                 [t n])) [] %1 %2))", "user": "4eb70649535d7eef30807373"}, {"problem": 112, "code": "(fn dive [n [x & xs]]\n  (cond\n    (and (number? x)\n         (<= 0 (- n x))) (cons x (dive (- n x) xs))    \n    (coll? x) (list (dive n x))\n    :other (list)))", "user": "554bd33ce4b0a04f7929959a"}, {"problem": 112, "code": "(fn [goal s]\n  (letfn [(l [[x & xs] acc sum]\n            (cond (> sum goal) [sum acc]\n                  (nil? x) [sum acc]\n                  (sequential? x) (let [[sum' acc'] (l x [] sum)]\n                                    (l xs (conj acc acc') sum'))\n                  (> (+ sum x) goal) [sum acc]\n                  :else (l xs (conj acc x) (+ sum x))))]\n    (second (l s [] 0))))", "user": "5eb1c786e4b00a66d4a95201"}, {"problem": 112, "code": "(fn ans [n coll]\n  (loop [sum 0\n         acc []\n         [x & xs] coll]\n    (cond\n      (or (nil? x) (> sum n)) acc\n      (coll? x) (let [coll- (ans (- n sum) x)\n                      sum- (apply + (flatten coll-))]\n                  (recur (+ sum sum-) (conj acc coll-) xs))\n      :else (recur (+ sum x) (if (> (+ sum x) n) acc (conj acc x)) xs))))", "user": "5c3796b3e4b0d62ef62d9f77"}, {"problem": 112, "code": "(fn [n col]\n  (letfn [(f [res [x & xs] sum]\n            (cond\n              (nil? x) [res sum]\n              (sequential? x) (let [[r s] (f [] x sum)] (f (conj res r) xs s))\n              (> (+ sum x) n) [res sum]\n              :else (f (conj res x) xs (+ sum x))))]\n    (first (f [] col 0))))", "user": "5de12192e4b0948ae9d9aded"}, {"problem": 112, "code": "(fn sh [n [h & t]]\n  (cond (not h) [] \n        (sequential? h) [(sh n h)]\n        (>= n h) (cons h (sh (- n h) t))\n        :else []))", "user": "5e6ca949e4b04a83ad7cd289"}, {"problem": 112, "code": "(fn holl [limit [x & xs]]\n  (letfn [(sum-seq [xs]\n            (->> xs\n                 (tree-seq sequential? identity)\n                 (filter (complement sequential?))\n                 (reduce +)))]\n    (if ((complement sequential?) x)\n      (if (or (nil? x) (> x limit))\n        ()\n        (lazy-seq (cons x (holl (- limit x) xs))))\n      (let [y (holl limit x) \n            s (sum-seq y)]\n        (lazy-seq (cons y\n                        (holl (- limit s)\n                              xs)))))))", "user": "5ebdb3d2e4b00a66d4a95275"}, {"problem": 112, "code": "(fn [n coll]\n  (let [build (fn f [coll accum]\n                (if (or (empty? coll) (> accum n))\n                  [nil accum]\n                  (let [head (first coll)\n                        tail (rest coll)]\n                    (if (coll? head)\n                      (let [[new-head new-accum] (f head accum)\n                            [new-tail new-accum2] (f tail new-accum)]\n                        (if (nil? new-head)                          \n                          [new-tail new-accum2]\n                          [(cons new-head new-tail) new-accum2]))\n                      (if (> (+ head accum) n)\n                        [nil (inc n)]\n                        (let [[new-tail new-accum] (f tail (+ head accum))]\n                          [(cons head new-tail) new-accum]))))))]\n    (let [[new-coll _] (build coll 0)]\n      (if (nil? new-coll)\n        ()\n        new-coll))))", "user": "5ec6de19e4b08d0ec38692da"}, {"problem": 112, "code": "(fn [p-max p-coll] ( ( (fn walk [coll sum max]\n                        (let [\n\n                              my-reduced (fn [val] (fn [] val))\n                              my-reduce (fn my-reduce [func accum coll]\n                                          (if (fn? accum)\n                                            (let [accum-result (accum)]\n                                              accum-result)\n                                            (if (empty? coll)\n                                              accum\n\n                                              (my-reduce func (func accum (first coll)) (rest coll))\n\n                                              )))\n                              result (my-reduce (fn [a v]\n                                                  (if (a :done) a\n                                                                (if (coll? v)\n                                                                  (let [walked (walk v (a :sum) max)]\n                                                                    (if (walked :done)\n                                                                      (my-reduced (assoc a :done true :coll (conj (a :coll) (walked :coll))))\n                                                                      (assoc a :sum (+ (walked :sum) (a :sum)) :coll (conj (a :coll) (walked :coll)))\n                                                                      ))\n                                                                  (if (> (+ (a :sum) v) max)\n                                                                    (my-reduced (assoc a :done true))\n                                                                    (assoc a :sum (+ (a :sum) v) :coll (conj (a :coll) v))\n                                                                    )) ))\n\n                                                {:done false\n                                                 :sum sum\n                                                 :coll []\n                                                 } coll)\n\n                              ]\n                          result\n\n\n\n                          )) p-coll 0 p-max) :coll))", "user": "53c73e8ae4b00fb29b2212a5"}, {"problem": 112, "code": "(fn f [n [a & b :as c]]\n  (cond\n    (empty? c) c\n    (coll? a) (let [r (f n a)]\n                (cons r (f (- n (reduce + (flatten r))) b)))\n    :else (if (<= a n)\n            (cons a (f (- n a) b))\n            [])))", "user": "597dcb0ce4b0dbe32238d0a2"}, {"problem": 112, "code": "(fn dd [n l] \n  (loop [tot 0 nl [] ll l]\n    (cond (empty? ll) nl\n          (> tot n) nl\n          (coll? (first ll)) (recur (inc n) (conj nl (dd (- n tot) (first ll))) (rest ll))\n          (> (+ tot (first ll)) n) (recur (+ tot (first ll)) nl (rest ll))\n\t\t  :else (recur (+ tot (first ll)) (conj nl (first ll)) (rest ll))\n)))", "user": "5951190be4b066ee0a44aea4"}, {"problem": 112, "code": "(fn [n s]\n  (letfn [(f [n s]\n            (loop [m n\n                   r []\n                   [e & z] s]\n              (if (sequential? e)\n                (let [[n t] (f m e)]\n                  (recur n (conj r t) z))\n                (if (and e (>= m e))\n                  (recur (- m e) (conj r e) z)\n                  [0 r]))))]\n    (last (f n s))))", "user": "50ed4626e4b01236b1d4983c"}, {"problem": 112, "code": "(fn f [limit xs]\n  (loop [[x & xs] xs\n         acc      []]\n    (if x\n     (let [sum (apply + (flatten acc))]\n       (if (coll? x)\n         (recur xs (conj acc (f (- limit sum) x)))\n         (if (<= (+ sum x) limit)\n           (recur xs (conj acc x))\n           acc)))\n     acc)))", "user": "5dc88a38e4b02f9375f4e1db"}, {"problem": 112, "code": "(fn sequs-horribilis [n s]\n  (sequence\n    (loop [[x & xs] (seq s) n n frames [] res []]\n      (cond\n        (coll? x) (recur x n (conj frames [xs res]) [])\n        (and (number? x) (>= n x)) (recur xs (- n x) frames (conj res x))\n        (seq frames) (recur (first (peek frames)) n (pop frames) (conj (second (peek frames)) res))\n        :else res))))", "user": "5f300f28e4b033932238a682"}, {"problem": 112, "code": "(fn f\n  ([m xs] (first (f m xs 0)))\n  ([m [x & xs] sum]\n   (cond\n     (or (nil? x) (> sum m)) (list '() sum)\n     (sequential? x) (let [[x1 sum1] (f m x sum)\n                           [x2 sum2] (f m xs sum1)]\n                       (list (cons x1 x2) sum2))\n     :else (let [nsum (+ x sum)]\n             (cond (> nsum m) (list '() nsum)\n                   (empty? xs) (list (list x) nsum)\n                   :else (let [[x1 sum1] (f m xs nsum)]\n                           (list (cons x x1) sum1)))))))", "user": "5eee7311e4b07c55ae4a0510"}, {"problem": 112, "code": "(fn seho [n l]\n  (let [df (fn df [na a l]\n             (let [ff (first l) ll (rest l)]\n               (cond \n                 (empty? l) [na a]\n                 (coll? ff) (let [[na' a'] (df na [] ff)] \n                                     (df (+ na na') (conj a a') ll))\n                 :default (if (> (+ na ff) n) [na a] \n                                           (df (+ na ff) (if (<= (+ na ff) n) (conj a ff) a) ll))\n                 )))]\n      (second (df 0 [] l))))", "user": "53a5bc3ae4b0ef122a8689c3"}, {"problem": 112, "code": "(fn [num coll]\n   (letfn [(sequs [sum coll]\n             (loop [sum sum\n                    coll coll\n                    result []]\n               (if (empty? coll)\n                 [sum result]\n                 (if (coll? (first coll))\n                   (let [[sub-sum sub-result] (sequs sum (first coll))]\n                     (prn sub-sum)\n                     (recur sub-sum (rest coll) (if (empty? sub-result) result (conj result sub-result))))\n                   (do\n                     (prn (first coll))\n                     (if (>= num (+ sum (first coll)))\n                       (recur (+ sum (first coll)) (rest coll) (conj result (first coll)))\n                       [sum result]))))))]\n     (second (sequs 0 coll))))", "user": "5f3f2281e4b004f08c61c561"}, {"problem": 112, "code": "(fn seqhor\n  [num structure]\n  (loop [lives num remstruc structure preserved []]\n    (if (empty? remstruc)\n      (into '() preserved)\n      (let [nextitem (first remstruc)]\n        (if (sequential? nextitem)\n          (conj preserved (seqhor lives nextitem))\n          (if (< (- lives nextitem) 0)\n            preserved\n            (recur (- lives nextitem) (rest remstruc) (conj preserved nextitem)))\n          )))))", "user": "5bf9d9b7e4b0bdcf453d15c4"}, {"problem": 112, "code": "(fn f [n, tree]\n    (loop [budget n, result [], [head & trest :as t] tree]\n        (if\n            (or\n                (empty? t)\n                (> (first (flatten t)) budget)\n            )\n            result\n            (let [headsize (if (coll? head) (apply + (flatten head)) head)]\n              (cond\n                (<= headsize budget)\n                  (recur (- budget headsize) (concat result [head]) trest)\n                (coll? head)\n                  (concat result [(f budget head)])\n                :else result\n              )\n            )\n        )            \n    )\n)", "user": "5d73530ce4b02e6b30c93514"}, {"problem": 112, "code": "(fn f [n col]\n  (let [sum-ints\n        (fn sum-ints [col] (reduce\n                            (fn [sum e] (if (integer? e) (+ sum e) (+ sum (sum-ints e))))\n                            0\n                            col))]\n    (loop [res [] col col]\n      (let [v (first col) sum (sum-ints res)]\n        (cond\n          (and (integer? v) (> (+ sum v) n)) res\n          (integer? v) (recur (conj res v) (rest col))\n          (empty? col) res\n          :else (let [nested (f (- n sum) v)]\n                  (if (empty? nested) res (recur (conj res nested) (rest col)))))))))", "user": "5ea6fe98e4b00a66d4a951b2"}, {"problem": 112, "code": "(fn seqush [n [x & xs]]\n  (cond \n    (nil? x)        nil\n    (sequential? x) (let [front (seqush n x)\n                          used  (reduce + (flatten front)) ]\n                      (cons front (seqush (- n used) xs)))\n    (<= x n)        (cons x (seqush (- n x) xs))\n    :else           ()))", "user": "5eff6c0ee4b0cf489e8d7f11"}, {"problem": 112, "code": "(fn foo [s [h & t]]\n   (cond\n     (coll? h) (cons (foo s h) (foo (- s (reduce + (flatten h))) t))\n     (or (nil? h) (> h s)) '()\n     :else (cons h (foo (- s h) t))))", "user": "5f3abcc4e4b004f08c61c52b"}, {"problem": 112, "code": "(fn [n col]\n  (second\n   ((fn sequs [n s]\n      (loop [cnt 0, acc [] [x & xs] s]\n        (cond\n          (or (nil? x) (< n cnt)) [cnt acc]\n          (coll? x) (let [[c r] (sequs (- n cnt) x)\n                          coll (if (empty? r) acc (conj acc r))]\n                      (recur (+ c cnt) coll xs))\n          :else (recur (+ x cnt) (if (< n (+ cnt x)) acc (conj acc x)) xs))))\n    n col)))", "user": "5cf895efe4b0b71b1d808a85"}, {"problem": 112, "code": "(fn fatrim [sum tree]\n    (loop [sum  sum\n           tree tree\n           acc  []]\n      (if-let [[f & r] (seq tree)]\n        (if (number? f)\n          (if (<= f sum)\n            (recur (- sum f) r (conj acc f))\n            acc)\n          (let [subtree  (fatrim sum f)\n                tree-sum (apply + (flatten subtree))]\n            (recur (- sum tree-sum) r (conj acc subtree))))\n        acc)))", "user": "5c9dcb36e4b048ec896c5b1d"}, {"problem": 112, "code": "(fn sequs-horribilis [n s]\n  (let [ref-i (ref 0)]\n    (letfn [(aux [s]\n              (if (empty? s)\n                '()\n                (if (sequential? (first s))\n                  (cons (aux (first s)) '())\n                  (dosync (ref-set ref-i (+ (deref ref-i) (first s)))\n                      (if (> (deref ref-i) n)\n                        '()\n                        (cons (first s) (aux (rest s))))))))]\n      (aux s))))", "user": "5f8b06afe4b0715f5002d74a"}, {"problem": 112, "code": "(fn [n xs]\n    (letfn [\n            (reduce-tree\n              [f init xs]\n              (loop [acc init [curr & xs] xs]\n                (if (= :ready (:status acc))\n                  (:val acc)\n                  (if curr\n                    (recur (f acc (if (coll? curr)\n                                    (reduce-tree f init curr)\n                                    curr)) xs) acc))))\n            ]\n      (let [vals (take-while #(<= % n) (reductions + (flatten xs)))\n            nof (count vals)\n            m (if (empty? vals) 0 (last (take nof (flatten xs))))]\n        (reduce-tree (fn [a c]\n                       (if (coll? c)\n                         (if (not (empty? c)) (conj a c) a)\n                         (if (<= c m) (conj a c) {:status :ready :val a}))\n                       ) [] xs))))", "user": "507e68abe4b085af06e3afd2"}, {"problem": 112, "code": "(fn hb [n form]\n  (let [[f & r] form]\n    (cond\n      (< n 0) '()\n      (empty? form) form\n      (and (number? f) (< n f)) '()\n      (and (number? f) (>= n f)) (cons f (hb (- n f) r))\n      (coll? f) (cons (hb n f) (hb (- n (apply + (flatten f))) r)))))", "user": "5fa74b82e4b0fa27300f3dda"}, {"problem": 112, "code": "#(cond \n  (= %1 10) '(1 2 (3 (4)))\n  (= %1 30) '(1 2 (3 (4 (5 (6 (7))))))\n  (= %1 9) '(0 1 2 3)\n  (= %2 [[[[[1]]]]]) '(((((1)))))\n  (= %2 [1 2 [3 [4 5] 6] 7]) '()\n  (= %1 0) '(0 0 (0 (0)))\n  :else '(-10 (1 (2 3 (4))))\n)", "user": "5e8ce2fee4b0cb0169546328"}, {"problem": 112, "code": "(fn [n v]\n  ((fn rec [accum rst]\n     (if (empty? rst) '()\n         (let [cur (first rst)]\n           (cond (and (number? cur) (< n (+ cur accum))) '()\n                 (number? cur) (cons cur (rec (+ accum cur) (rest rst)))\n                 (coll? cur) (list (rec accum cur)))))) 0 v))", "user": "58f98231e4b0438e51c2cf4c"}, {"problem": 112, "code": "(fn sequr [num nested-s]\n\n  (letfn [(get-total-val [s]\n            (apply + (flatten s))\n            )]\n    (loop [rem-nm num rem-seq nested-s res []]\n      (let [head (first rem-seq)]\n        (if (seq (rest rem-seq))\n        ; Recur space\n          (if (coll? head)\n            (recur (- rem-nm (get-total-val rem-seq)) (rest rem-seq) (conj res (sequr rem-nm head))) \n            (if (<= head rem-nm) \n              (recur (- rem-nm head) (rest rem-seq) (conj res head))\n              res))\n          \n          (if (coll? head)\n            (conj res (sequr rem-nm head ))\n            (if (<= head rem-nm) \n              (conj res head)\n              res)\n            ))\n        )\n      ))\n  )", "user": "5ff676a9e4b06df49cee1497"}, {"problem": 112, "code": "(fn [n s]\n    (letfn [(bar [n s]\n                 (if-not (sequential? s)\n                     (if (> s n) [nil 0 false] [s s true])\n                     (let [x (first s)\n                           xs (rest s)\n                           [node value complete] (bar n x)]\n                         (if (nil? node)\n                             ['() value complete]\n                             (if (or (not complete) (empty? xs))\n                                 [(list node) value complete]\n                                 (let [[node' value' complete'] (bar (- n value) xs)]\n                                     [(cons node node') (+ value value') complete']))))))]\n            (let [[res _ _] (bar n s)] res)))", "user": "600ae927e4b074f607df6689"}, {"problem": 112, "code": "(fn ff [m [h & t]]\n  (or (when h\n    (if (sequential? h)\n      (let [x (ff m h)]\n        (cons x (ff (- m (apply + (flatten x))) t))\n      )\n      (when (<= h m)\n        (cons h (ff (- m h) t))\n      )\n    )\n  )\n  '())\n)", "user": "5fd8bcb3e4b05ac5b16ea11b"}, {"problem": 112, "code": "(fn [n c]\n  (letfn [(f [n c]\n            (loop [a [] i 0 [h & t] c]\n              (cond\n                (> i n) [a i]\n                (nil? h) [a i]\n                (coll? h) (let [[aa ii] (f (- n i) h)] (recur (conj a aa) (+ i ii) t))\n                (> (+ i h) n) (recur a (+ i h) t)\n                :e (recur (conj a h) (+ i h) t))))]\n    ((f n c) 0)))", "user": "5fd10010e4b07e53c2f3f02a"}, {"problem": 112, "code": "(fn sh [n [x & r]]\n  (if x\n    (if (sequential? x)\n      (let [sub (sh n x)]\n        (cons sub (sh (- n (reduce + (flatten sub))) r)))\n      (if (<= x n)\n        (cons x (sh (- n x) r))\n        ()))))", "user": "6011b89ee4b074f607df66bc"}, {"problem": 112, "code": "(fn sequs-horribilis [goal coll]\n  (if (empty? coll)\n    '()\n    (let [[x & xs] coll]\n      (cond\n        (vector? x) (let [subsequence (sequs-horribilis goal x)\n                          cnt         (apply + (flatten x))]\n                      (if (< cnt goal)\n                        (cons x (sequs-horribilis (- goal cnt) xs))\n                        [subsequence]))\n        (<= x goal) (cons x (sequs-horribilis (- goal x) xs))\n        :else        '()))))", "user": "601aaa93e4b0bf4ca6b10926"}, {"problem": 112, "code": "#(second ((fn f [upper coll]\n             (loop [lst coll\n                    result []\n                    rest upper]\n               (cond\n                 (empty? lst) [rest result]\n                 (coll? (first lst)) (let [[sub-rest sub-result] (f rest (first lst))]\n                                       (recur (next lst)\n                                              (conj result sub-result)\n                                              sub-rest))\n                 (<= (first lst) rest) (recur (next lst)\n                                              (conj result (first lst))\n                                              (- rest (first lst)))\n                 :else [rest result])))\n           %1 %2))", "user": "60096aabe4b074f607df667f"}, {"problem": 112, "code": "(fn [max xs]\n          (letfn [(proc-tree [sum [e & rest :as ts] rs]\n                    (if (or (nil? e) (and (not (coll? e)) (> (+ sum e) max)))\n                      rs\n                      (if (coll? e)\n                        (conj rs (vec (proc-tree sum e [])))\n                        (proc-tree (+ sum e) rest (conj rs e))\n                        ))\n                    )]\n            (proc-tree 0 xs [])))", "user": "533c2605e4b0e30313ee6cd7"}, {"problem": 112, "code": "(fn sequs [n colls]\n  (loop [remain n\n         [x & xs] colls\n         result []]\n    (cond\n     (nil? x) result\n     \n     (coll? x) \n     (let [new-seq (sequs remain x)]\n        (if (= (count x) (count (flatten new-seq)))\n          (recur (- remain (apply + (flatten new-seq)))\n                 xs\n                 (conj result new-seq))\n          (conj result new-seq)))\n    \n     (< remain x) result\n     :else (recur (- remain x) xs (conj result x)))))", "user": "5cb41c40e4b026601754b911"}, {"problem": 112, "code": "(fn to-the-limit [limit [h & t]]\n   (cond\n     (< limit 0) []\n     (number? h) (if (<= h limit) (concat [h] (to-the-limit (- limit h) t)) [])\n     (empty? h) []\n     :else (concat\n                [(to-the-limit limit h)]\n                (to-the-limit (- limit (apply + (flatten h))) t))))", "user": "604d3cb1e4b0b7ec0ac60ac2"}, {"problem": 112, "code": "(letfn [(sequs-traverse1 [n xs]\n          ;; assume that xs is a collection\n          (if (empty? xs) [n '()]\n              (if (coll? (first xs))\n                (let [[n-left xs1] (sequs-traverse1 n (first xs))\n                      [n-left xrest] (sequs-traverse1 n-left (rest xs))]\n                  [n-left (cons xs1 xrest)])\n                (if (<= (first xs) n)\n                  (let [[n-left xrest] (sequs-traverse1 (- n (first xs)) (rest xs))]\n                    [n-left (cons (first xs) xrest)])\n                  [0 '()]))))]\n  (fn [n xs]\n    (second (sequs-traverse1 n xs))))", "user": "60460824e4b02d28681c77bc"}, {"problem": 112, "code": "(fn [n s]\n  (second\n    ((fn sequs [n s]\n       (loop [sum 0\n              result []\n              [x & xs] s]\n         (cond\n           (or (nil? x) (< n sum)) [sum result]\n           (coll? x) (let [[c r] (sequs (- n sum) x)\n                           coll (if (empty? r) result (conj result r))]\n                       (recur (+ c sum) coll xs))\n           :else (recur (+ x sum) (if (< n (+ sum x)) result (conj result x)) xs))))\n     n s)))", "user": "4e586949535d8a8b8723a292"}, {"problem": 112, "code": "(fn sequs-horribilis\n   ([n s] (sequs-horribilis n s 0))\n   ([n [head & tail] current-sum]\n                            (cond\n                              (nil? head) ()\n                              (sequential? head) [(sequs-horribilis n\n                                                                    head\n                                                                    current-sum)]\n                              (> (+ current-sum head) n) ()\n                              :else (cons head\n                                          (sequs-horribilis n\n                                                            tail\n                                                            (+ current-sum head))))))", "user": "54cad2d5e4b057c6fda3a26c"}, {"problem": 112, "code": "(fn __ [n xs]\n  (let [xs (if (= (type (range)) clojure.lang.LazySeq) (take 10 xs) xs)]\n    (let [sum (atom 0)]\n      (clojure.walk/postwalk\n       #(if (coll? %)\n          (remove (fn [x] (and (coll? x) (empty? x))) %)\n          %)\n       (clojure.walk/prewalk\n        #(if (coll? %) (remove nil? %) %)\n        (clojure.walk/postwalk\n         #(if (number? %) (if (<= (reset! sum (+ @sum %)) n) %) %)\n         xs))))))", "user": "526759b3e4b03e8d9a4a715b"}, {"problem": 112, "code": "(fn seq-horribilis[n l]\n  (letfn [(seq-horribilis-helper [n l sum](cond (empty? l) '()\n       :else (let [val (first l)]\n               (cond (vector? val) (let [fst [(seq-horribilis-helper n val sum)]]\n                                     (cond (< @sum n) (concat fst (seq-horribilis-helper n (rest l) sum))\n                                           :else fst))\n                     (<= (+ @sum val) n) (do (swap! sum #(+ %1 %2) val) (concat [val] (seq-horribilis-helper n (rest l) sum)))\n                        :else '()))))]\n  (let [sum (atom 0)] (seq-horribilis-helper n l sum))))", "user": "5bab31f1e4b0a20761a23471"}, {"problem": 112, "code": "(fn till [n [x & xs :as coll]]\n  (cond\n    (empty? coll) []\n    (sequential? x) (let [r (till n x)\n                          s (apply + (flatten r))]\n                      (cons r (till (- n s) xs)))\n    (>= n x) (cons x (till (- n x) xs))\n    :else []))", "user": "605b7a90e4b079a07f8593fc"}, {"problem": 112, "code": "(fn sequs-horribilis [n x]\n   (cond\n     (number? x) (if (<= x n) n)\n     \n     (and (coll? x) (empty? x)) x\n\n     (and (coll? x) (coll? (first x)))\n\n     (lazy-seq (cons (sequs-horribilis n (first x)) '()))\n\n     (and (coll? x) (<= (first x) n))\n\n     (let [others (sequs-horribilis (- n (first x)) (rest x))]\n       \n       (if (not (nil? others))\n         (lazy-seq (cons (first x) others))\n         (cons (first x) '())))\n\n     :else '()))", "user": "58b81490e4b0ebc645576d8c"}, {"problem": 112, "code": "(fn solve\n  ([n coll] (solve n coll 0 []))\n  ([n [x & xs] sum result]\n   (if (nil? x)\n     result\n     (if (number? x)\n       (if (<= (+ sum x) n)\n         (solve n xs (+ sum x) (conj result x))\n         result)\n       (conj result (solve n x sum []))))))", "user": "60537cd1e4b04c8f2157d152"}, {"problem": 112, "code": "(fn mseqhor [limit coll]\n(letfn [(seqhor [coll gsum]\n  (loop [sum gsum, th-num (first coll), unchecked (rest coll), acc '[]]\n      (cond (coll? th-num)\n                (let [[down-sum down-acc] (seqhor th-num sum)]\n                     (recur (+ sum down-sum)\n                            (first unchecked)\n                            (rest unchecked)\n                            (conj acc down-acc)))\n            (or (nil? th-num) (> (+ sum th-num) limit)) [sum acc]\n            (= (+ sum th-num) limit) [(+ sum th-num) (conj acc th-num)]\n            :else (recur (+ sum th-num)\n                         (first unchecked)\n                         (rest unchecked)\n                         (conj acc th-num)))))]\n (if (every? zero? (cons limit (flatten coll))) coll (second (seqhor coll 0)))))", "user": "5f548678e4b0a0bc16850a7e"}, {"problem": 112, "code": "(fn x [n l]\n    (letfn [(y [m\n                [h & t]]\n               (if (coll? h)\n                 (list (y m h))\n                 (if (and (not (nil? h)) (>= m 0) (<= h m))\n                   (conj (y (- m h) t) h)\n                   '())))]\n      (y n l)))", "user": "603ae21de4b0d5df2af222fb"}, {"problem": 112, "code": "(fn f [n c]\n\t(let [fc (first c)]\n\t\t(cond (empty? c) c \n\t\t      (integer? fc)\n\t\t\t\t(if (<= 0 (- n fc))\n\t\t\t\t\t(conj (f (- n fc) \n\t\t\t\t\t     (lazy-seq (rest c))) fc)\n\t\t\t\t\t'())\n\t\t\t\t:else (list (f n fc)))))", "user": "5fab7ea6e4b08cb800c85ad8"}, {"problem": 112, "code": "(fn [t coll]\n  (if (or (instance? clojure.lang.PersistentList coll) (instance? clojure.lang.PersistentVector coll))\n    (let [recreate-struct-f (fn recreate-struct [ds recreated-ds thresh]\n   ( let [ d (reduce (fn [[thresh newds] curr] (if-not (instance? clojure.lang.Seqable curr)\n                                         (if (>= (- thresh curr) 0)\n                                           (vector (- thresh curr) (conj newds curr))\n                                           (vector thresh newds))\n\n                                         (let [res (recreate-struct curr recreated-ds thresh)]\n                                           (if (and (empty? recreated-ds) (empty? (second res)))\n                                             (vector (first res) newds)\n                                             (vector (first res) (conj newds (second res)))\n                                             )\n                                           ))) [thresh []] ds)\n          ]\n        \n     [(first d) (into recreated-ds (second d))]))\n        full-res (recreate-struct-f coll [] t)]\n    (second full-res))\n    '(0 1  2 3)) )", "user": "608ec5e4e4b03bd49d9f36c0"}, {"problem": 112, "code": "(fn make-seq [limit [head & tail :as col]]\n  (if (seq col)\n    (cond\n      (sequential? head) (concat [(make-seq limit head)] (make-seq (- limit (apply + (flatten head))) tail))\n      (< limit head) []\n      :else (concat [head] (make-seq (- limit head) tail)))))", "user": "60b7e2c5e4b0e0fa5f1b4252"}, {"problem": 112, "code": "(fn truncate-seq [n sq]\n  (if (or (empty? sq) (< n (first (flatten sq))))\n    '()\n    (let [[x & xs] sq]\n      (if (sequential? x)\n        ;; the next element is a sub-sequence\n        (let [sub-sq (truncate-seq n x)]\n          (if (not (empty? sub-sq))\n            (let [sub-n (reduce + (flatten sub-sq))]\n              (cons sub-sq (truncate-seq (- n sub-n) xs)))))\n        ;; the next element is a single number\n        (if (>= n x)\n            (cons x (truncate-seq (- n x) xs)))))))", "user": "51b920bfe4b0e871ca4958f9"}, {"problem": 112, "code": "(fn sh [n [x & r]]\n  (if x\n    (if (sequential? x)\n      (let [sub (sh n x)]\n        (cons sub (sh (- n (reduce + (flatten sub))) r)))\n      (if (<= x n)\n        (cons x (sh (- n x) r))\n        ()))))", "user": "54d7e277e4b0a52adc2e2031"}]