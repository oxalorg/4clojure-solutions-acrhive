[{"code": "(fn [word board]\n  (let [b (vec (for [r board] (vec (for [c r :when (not= c \\ )] c))))\n        w (count (first b)) h (count b)\n        char-at #(and (< -1 % h) (< -1 %2 w) (get-in b [% %2]))\n        h-str (fn [y x size] (for [c (range -1 (inc size))] (char-at y (+ x c))))\n        v-str (fn [y x size] (for [c (range -1 (inc size))] (char-at (+ y c) x)))\n        clear? #(or (not %) (= % \\#))\n        match? (fn [s] (and (clear? (first s))\n                            (clear? (last s))\n                            (every? (fn [[b c]] (or (= b \\_) (= b c))) (zipmap (rest s) word))))]\n    (not (nil? (first (filter identity\n                              (for [y (range h) x (range w)]\n                                (or (match? (h-str y x (count word)))\n                                    (match? (v-str y x (count word)))))))))))", "problem": 111, "user": "4e52d815535d302ef430da77"}, {"code": "(fn [w p]  (letfn [\n    (s [pp] \n       (filter #(= (count w) (count %))\n         (mapcat \n         #(partition-by #{\\#} (remove #{\\ } %))\n         pp)))\n\n    (m [pc]\n        (every? \n           true? \n            (map \n               #(or (= % \\_) (= % %2))\n               pc \n               w)))]\n  (true? (or \n    (some m (s p)) \n    (some m (s (apply map vector p)))))))", "problem": 111, "user": "4daa374930acd6ed13482a68"}, {"code": "(fn\n  [w b]\n  (let [h (vec (map #(vec (.replaceAll % \" \" \"\")) b))\n        v (vec (for [c (range (count (h 0)))]\n               (vec (for [r (range (count h))]\n                      ((h r) c)))))\n        p (flatten (map #(vec (.split (apply str %) \"#\"))\n                              (concat h v)))\n        c (fn [w m]\n                (let [n (apply str\n                                          (map #(if (= %2 \\_) %1 %2)\n                                               w\n                                               m))]\n                  (and (= w n)\n                       (= (count w) (count m)))))]\n    (if (some (partial = true) (map (partial c w) p))\n      true\n      false)))", "problem": 111, "user": "4db53f87535d87e67b28fe08"}, {"code": "(letfn [\r\n  \t(normalize [string]\r\n\t\t\t(.. string (replaceAll \"\\\\s+\" \"\") (toLowerCase)))\r\n\t\t(fits? [word space]\r\n\t\t\t(and\r\n\t\t\t\t(= (count word) (count space))\r\n\t\t\t\t(every? identity (map #(or (= %2 \\_) (= %1 %2)) word space))))\r\n\t\t(rotate [puzzle]\r\n\t\t\t(let [width (count (first puzzle))]\r\n\t\t\t\t(for [i (range width)] (apply str (map #(nth % i) puzzle)))))\r\n\t\t(horizontal-candidates [line]\r\n\t\t\t(seq (.split line \"#\")))]\r\n\t\t\t\r\n\t(fn can-place? [word puzzle]\r\n\t\t(let [puzzle1    (map normalize puzzle)\r\n\t          puzzle2    (rotate puzzle1)\r\n\t\t      candidates (concat (mapcat horizontal-candidates puzzle1) (mapcat horizontal-candidates puzzle2))]\r\n\t\t\t(if (some (partial fits? (normalize word)) candidates)\t\t; We need to return true/false, not x/nil\r\n\t\t\t\ttrue\r\n\t\t\t\tfalse))))", "problem": 111, "user": "4dd6d6a0535d2dad7130b5ca"}, {"code": "(letfn [(remove-spaces [s] (remove #{\\ } s))\n        (filter-underline [s] (map #(if (= % \\_) \\. %) s))\n        (prep [ss] (map (comp remove-spaces\n                          filter-underline)\n                      ss))\n        (transpose [m] (apply map vector m))\n        (split-str [s]\n          (let [[f r] (split-with (complement #{\\#}) s)]\n            (if (empty? r)\n              (list f)\n              (cons f (split-str (rest r))))))\n        (all-seq [ss]\n          (mapcat split-str\n            (concat (prep ss)\n                    (transpose (prep ss)))))\n        (all-str [ss]\n          (for [s (all-seq ss)] (apply str s)))\n        (all-re [ss] (map re-pattern (all-str ss)))\n        ]\n  (fn [s ss]\n    (if (some #(re-matches % s) (all-re ss))\n      true\n      false)))", "problem": 111, "user": "4ddbfb8a535d02782fcbea00"}, {"code": "(fn  [word coll]\n  (let [fits-line (fn fits-line [word line]\n  (loop [word word candidate line]\n      (cond (empty? word) (empty? candidate)\n            (or (= (first word) (first candidate)) \n                (= (first candidate) \\_)) (recur (rest word) (rest candidate))\n             :else false)))\n\nvertical-words (fn vertical-words [coll]\n  (loop [ans [] coll coll]\n    (if (empty? (first coll)) ans\n      (recur (conj ans (apply str (map first coll))) (map rest coll)))))\n\nall-candidates (fn all-candidates [coll]\n  (let [lines #(re-seq #\"\\w+\" %)]\n    (if (= 1 (count coll)) (lines (first coll))\n      (flatten (map lines (concat coll (vertical-words coll)))))))\n\n    coll (all-candidates (map #(apply str (re-seq #\"[\\w+\\#]\" %)) coll))]\n    (println coll)\n    (if (= 1 (count coll)) (fits-line word (first coll))\n      (reduce #(or %1 %2) (map #(fits-line word %) coll)))))", "problem": 111, "user": "4e16bdef535d04ed9115e7e9"}, {"code": "(fn [m e f r n o p w b]\n  (let [b (m (p remove #{\\ }) b)]\n    (not (e (for [i (mapcat (p partition-by #{\\#})\n                            (o b (apply (p m #(o %&)) b)))\n                  :let [j (loop [c i d w]\n                            (if (or (> (n d) (n c)) (and (not= \\_ (f c)) (not= (f c) (f d))))\n                              nil\n                              (if (e d)\n                                (e c)\n                                (recur (r c) (r d)))))]\n                  :when j] j)))))\nmap empty? first rest count concat partial", "problem": 111, "user": "4e49badd535dc968683fc4c9"}, {"code": "(fn [w b]\r\n  (not (nil? (some #(re-find (re-pattern (str \"^(.*#)?[_\" (apply str (interpose \"][_\" w)) \"](#.*)?$\")) %)\r\n                   (#(concat % (apply map str %)) (map #(clojure.string/replace % \" \" \"\") b))))))", "problem": 111, "user": "4dc1ee85535d020aff1edf91"}, {"code": "(fn [w c]\n  (let [\n    trans (fn [m] (vec (apply map vector m)) )\n    rmsp (fn [s] (remove #{\\ } (seq s)))\n    matr (fn [cr] (vec (map rmsp cr)))\n    fit? (fn [p]  (or (= (first p) \\_) (= (first p) (second p))))\n    okw? (fn [w p] (and\n      (= (count w) (count p))\n      (every? fit? (partition 2 (interleave p w)))))\n    okl? (fn [w l] (some #(okw? w %) (map seq (map str (.split (apply str l) \"#\")))))\n    ok? (fn [w m] (some #(okl? w %) m) )\n    ]\n    (= true (or (ok? w (matr c)) (ok? w (trans (matr c)))))\n))", "problem": 111, "user": "4e6e10d8535d5021c1a895fd"}, {"code": "(fn [w c]\n  (let [cw (map #(seq (.split % \" \")) c)\n        hor (map (fn [i] (map #(nth % i) cw))\n                 (range (count (first cw))))\n        ws (reduce #(into %1 (.split %2 \"#\")) []\n                   (map #(apply str %) (into cw hor)))\n        res (map (fn [[c r]] [c (re-pattern r)])\n                (map #(vector (count %) (.replaceAll % \"_\" \".\")) ws))]\n    (< 0 (count\n          (some (fn [[c r]] (and (= (count w) c) (re-seq r w)))\n                      res)))))", "problem": 111, "user": "4db4714f535dc0f10411755a"}, {"code": "#(letfn [(a [b]\n           (apply str (replace {\\_ \\ }\n                               (remove #{\\ } b))))]\n   (string? (some (fn [c] (re-matches c %1))\n                  (mapcat (fn [f]\n                            (map re-pattern (re-seq #\"[^#]+\" (apply str (replace {\\  \\.} f)))))\n                          (concat (map a %2)\n                                  (map-indexed (fn [d e]\n                                                 (a (cons e (map (fn [w] (nth w d)) (rest %2)))))\n                                               (first %2)))))))", "problem": 111, "user": "4e68be01535d8ccf87e9fe88"}, {"code": "(fn [w s]\n  (let [S some\n        M map\n        C count\n        X concat\n        m (M #(map first (.split % \" \")) s)\n        c (M \n            (fn [i] (M #(nth % i) m)) \n            (range (C (nth m 0)))) \n        r (M #(X \"#\" % \"#\") (X m c))\n        i #(every? \n              (fn [[i j]] \n                (or (and (not= \\# i) (= \\_ j)) \n                    (= i j)))\n              (M list (X \"#\" w \"#\") %))]\n    (boolean \n      (S\n        #(S i (partition (+ 2 (C w)) 1 %))\n        r))))", "problem": 111, "user": "4e5411e8535d8a8b8723a279"}, {"code": "(fn crossword [word strings]\n  (let [rows (map #(str (.replaceAll % \" \" \"\")) strings)\n        cols (loop [in rows\n                out []]\n                (if (empty? (first in))\n                  out\n\t              (recur (map rest in) (conj out (apply str (map first in))))))\n        all (concat rows cols)\n        spaces (flatten (map #(vec (.split % \"#\")) all))\n        regexes (map #(apply str (concat \"^\" (.replaceAll % \"_\" \".\") \"$\")) spaces)]\n       (not (apply = nil (map #(re-seq (re-pattern %) word) regexes)))))", "problem": 111, "user": "4e6a60cd535d8ccf87e9fed7"}, {"code": "(fn [s w m]\r\n  (= (some #(.matches w (apply s (replace {\\_ \\. \\# \"$|^\" \\ \"\"}  %)))\r\n           `(~@m ~@(apply map s m)))\r\n     true))\r\nstr", "problem": 111, "user": "4dce6e41535d5973398f92a2"}, {"code": ";; this is obviously not the right solution.\n\n#(reify clojure.lang.IPersistentCollection (equiv [_ _] (= %&)))", "problem": 111, "user": "4dad7adac9a9d6ed0599dc57"}, {"code": "(fn[word rows]\n  (letfn [\n    (normalize[pattern]\n      (let [no-space (filter #(not= % \\space) pattern)\n            rep-us (map #(if (= % \\_) \\. %) no-space)]\n        (apply str rep-us)))\n    (matches[pattern word]\n      (not (nil? (re-matches (re-pattern pattern) word))))\n    (patterns[a-str]\n      (let [p-seq (partition-by #(= % \\#) a-str)\n            p-seq (map #(apply str %) p-seq)\n            p-seq (filter #(not (= \"#\" %)) p-seq)]\n        p-seq))\n    (rows-n-cols[rows]\n      (loop [i (dec (count (first rows)))\n             acc rows]\n        (if (< i 0)\n          acc\n          (recur (dec i) (conj acc (apply str (map str (map #(nth % i) rows))))))))]\n    (let [n-rows (map normalize rows)\n          rc-seq (rows-n-cols n-rows)]\n      (loop [curr (first rc-seq)\n             rst (rest rc-seq)\n             match false]\n        (if match\n          match\n          (if (nil? curr)\n            false\n            (let [pats (patterns curr)]\n              (if (some #(matches (first %) (second %)) (map (fn[a b] [a b]) pats (repeat word)))\n                (recur curr rst true)\n                (recur (first rst) (rest rst) false)))))))))", "problem": 111, "user": "4e58bcd4535d8a8b8723a296"}, {"code": "(letfn [(zip [& xss] (apply (partial map vector) xss))\n        (spots [s] (remove #{\\space} s))\n        (split-all-with [p xs]\n          (let [f (partial split-with p)\n                g (comp f next second)]\n            (for [s (iterate g (f xs))\n                  :while (not-every? empty? s)]\n              (first s))))\n        (can-merge? [xs ys]\n            (every? #(or (some #{\\_} %) (apply = %))\n                    (zip xs ys)))\n        (rows-and-cols [mat]\n          (concat mat (apply zip mat)))\n        (lcase [s] (.toLowerCase s))\n        (bool [x] (if x true false))]\n  (fn [word puzz]\n    (let [w (lcase word)\n          n (count word)\n          f (partial split-all-with (complement #{\\#}))\n          any? (comp bool some)]\n      (any? (partial can-merge? word)\n            (->> puzz\n              (map (comp spots lcase))\n              rows-and-cols\n              (mapcat f)\n              (filter #(= n (count %))))))))", "problem": 111, "user": "4e6a412e535d8ccf87e9feb6"}, {"code": "(fn [word board]\n  (let [rows board\n        columns (apply map vector board)\n        split-by-unusable-space\n        (fn split-by-unusable-space [coll]\n          (lazy-seq\n           (when (seq coll)\n             (let [[a b] (split-with (partial not= \\#) coll)]\n               (cons a (when (next b) (split-by-unusable-space (rest b))))))))\n        build-regex\n        (fn [coll]\n          (re-pattern\n           (apply str (map\n                       #(if (= \\_ %)\n                          \".\"\n                          %)\n                       coll))))\n        build-regexes (fn [s]\n                        (->> s\n                             (remove #{\\space})\n                             (split-by-unusable-space)\n                             (map build-regex)))]\n    (not\n     (nil?\n      (some\n       #(re-matches % word)\n       (mapcat\n        build-regexes\n        (concat rows columns)))))))", "problem": 111, "user": "4e68c434535d8ccf87e9fe89"}, {"code": "(fn [word board]\n  (letfn [(parse [b]\n  \t (map (fn [l] (remove #{\\space} l)) board))\n\t  (rotate [board]\n\t\t  (let [width (count (first board))\n\t\t\theight (count board)]\n\t\t    (partition height\n\t\t\t       (for [x (range width)\n\t\t\t\t     y (range height)]\n\t\t\t\t (nth (nth board y) x)))))\n\t  (slots [board]\n\t\t (filter (fn [word] (not= \\# (first word)))\n\t\t\t (mapcat (fn [line] (partition-by #{\\#} line))\n\t\t\t\t board)))\n\t  (accepts? [slot word]\n\t\t    (re-matches (re-pattern (apply str (replace {\\_ \\.} slot)))\n\t\t\t\tword))]\n    (let [board (parse board)]\n      (not\n       (nil?\n\t(some #(accepts? % word)\n\t      (concat (slots board)\n\t\t      (slots (rotate board)))))))))", "problem": 111, "user": "4e513ecf535dc968683fc4f6"}, {"code": "(fn [word board]\r\n  (let [lines (map (fn [line] (apply str (remove #(= \\space %) line)))\r\n                   board)]\r\n    (letfn [(puttable? [place]\r\n              (and (= (count place) (count word))\r\n                   (every? (fn [[board-ch word-ch]]\r\n                             (or (= board-ch \\_) (= board-ch word-ch)))\r\n                           (map vector place word))))\r\n            (puttable-on-line? [line]\r\n              (some puttable? (clojure.string/split line #\"#\")))]\r\n      (or (some puttable-on-line? lines)\r\n          (some puttable-on-line? (apply map str lines))\r\n          false))))", "problem": 111, "user": "4e7c8fd1535db169f9c796be"}, {"code": "(fn [t b]\r\n  (or\r\n    (some #(= (seq t) %)\r\n          (for [a [(map #(remove #{\\ } %) b)]\r\n                b [a (apply map list a)]\r\n                r b\r\n                w (partition-by #{\\#} r)]\r\n            (map #({\\_ %2} % %) w (str t 0))))\r\n    false))", "problem": 111, "user": "4db858d1535d1e037afb218c"}, {"code": "(fn [w c]\n  (letfn [\n    (rmspace [a] (map (fn [x] (remove #(= % \\ ) x)) a))\n    (trps [a] (apply map vector a))\n    (inp [a] (let [b (rmspace a)] (mapcat #(partition-by #{\\#} %) (into b (trps b)))))\n    (matches [x y]\n  (cond (and (empty? x) (empty? y)) true\n        (empty? x) false\n        (empty? y) false\n        :else (let [[x1 & xr] x, [y1 & yr] y]\n                (if (or (= x1 y1) (= \\_ y1)) (recur xr yr) false))))]\n  (boolean (some true? (map (partial matches w) (inp c))))))", "problem": 111, "user": "4e7db3b4535db169f9c796e1"}, {"code": "(fn [w p]\n  (let [s (map \n            (fn [x]\n              (->> x\n                (filter #(not= \\space %))\n                (replace {\\_ \\.})))\n            p)]\n    (boolean\n      (some\n        #(re-matches (re-pattern %) w)\n        (flatten\n          (map    \n            #(clojure.string/split (apply str %) #\"#\")\n            (into s\n              (when (> (count p) 1)\n                (partition (count p) (apply interleave s))))))))))", "problem": 111, "user": "4db85282535d1e037afb218a"}, {"code": "(fn [w b]\n  (letfn [(fit [[fw & r :as w] [p & rs :as s]]\n            (if w\n              (if p\n                (or (and (#{fw \\_} p)\n                         (fit r rs))\n                    (fit w (rest (drop-while #(not= % \\#) s)))))\n              (or (not p) (= p \\#))))]\n    (let [bb (map (fn [r] (remove #(= % \\ ) r)) b)]\n      (boolean (some #(fit w %) (concat bb (apply map str bb)))))))", "problem": 111, "user": "4e8612f8535db62dc21a62f2"}, {"code": "(fn [x y]\n  (let [\n  remove-spaces (fn [string]\n\t\t\t(filter #(not (= % \\space)) string))\n\n\tsplit-on-hashes (fn [string]\n\t\t\t  (loop [input-string string output-list nil]\n\t\t\t    (let [split-string (split-with #(not= % \\#) input-string)]\n\t\t\t      (if (empty? (split-string 1))\n\t\t\t\t(conj output-list (split-string 0))\n\t\t\t\t(recur (rest (split-string 1)) (conj output-list (split-string 0)))))))\n\n\tfits? (fn [-str1 -str2]\n\t\t(loop [str1 -str1 str2 -str2]\n\t\t\t\t\t; recursive solution\n\t\t  (if (and (empty? str1) (empty? str2))\n\t\t    true\n\t\t    (if (or (empty? str1) (empty? str2))\n\t\t      false\n\t\t      (if (and (not= (first str2) \\_)\n\t\t\t       (not= (first str1) (first str2)))\n\t\t\tfalse\n\t\t\t(recur (rest str1) (rest str2)))))))\n\n\tcheck-for-horizontal-fits (fn [str1 crossword-strings]\n\t\t\t\t    (let [space-removed-strings (map remove-spaces crossword-strings)\n\t\t\t\t\t  split-strings (map split-on-hashes space-removed-strings)]\n\t\t\t\t      (filter (complement empty?)\n\t\t\t\t\t      (map #(filter (fn [x] (fits? (remove-spaces str1) x)) %) split-strings))))\n\t\n\ttranspose (fn [crossword-strings]\n\t\t    (let [space-removed-strings (vec (map (comp vec remove-spaces) crossword-strings))\n\t\t\t  xlen (count (space-removed-strings 0))\n\t\t\t  ylen (count crossword-strings)]\n\t\t      (partition ylen\n\t\t\t\t (for [x (range xlen) y (range ylen)] ((space-removed-strings y) x)))))\n\n\tcheck-for-vertical-fits (fn\n\t\t\t\t  [str1 crossword-strings]\n\t\t\t\t\t; all we need to do here is use the check-for-horizontal-fits on the transposed crossword-strings\n\t\t\t\t  (check-for-horizontal-fits str1 (transpose crossword-strings)))]\n    (if (or ((complement empty?) (check-for-horizontal-fits x y))\n\t    ((complement empty?) (check-for-vertical-fits x y)))\n      true\n      false)))", "problem": 111, "user": "4e89ff3d535d3e98b802328a"}, {"code": "(fn [_word _board]\n  (let [\n  word (.toLowerCase _word)\n  board (->> _board (map #(.toLowerCase %)) (map #(.replace % \" \" \"\")))\n  transpose (fn [board]\n    (apply map list board))\n  matches? (fn [word section]\n    (let [xs (seq word)\n          ys (seq section)\n          no-xs? (not xs)\n          no-ys? (not ys)\n          x (first xs)\n          y (first ys)]\n      (cond\n        (or no-xs? no-ys?) (and no-xs? no-ys?)\n        (or (= \\_ y) (= x y)) (recur (rest xs) (rest ys)))))\n  row-contains? (fn [word row]\n    (->> row\n         (partition-by #(= \\# %))\n         (take-nth 2)\n         (some #(matches? word %))))\n  board-contains? (fn [word board]\n    (some #(row-contains? word %) board))\n  or* (fn [x y]\n    (not (not (or x y))))\n  ]\n  (or* (board-contains? word board)\n       (board-contains? word (transpose board)))))", "problem": 111, "user": "4e691c79535d8ccf87e9fe97"}, {"code": "(fn f [s rows]\n  (let [ rows  (map #(apply str (remove #{\\space} %)) rows)\n         cols  (apply map str rows)\n         all   (mapcat #(clojure.string/split % #\"#\") (concat rows cols))\n         match (fn [s p] (and (= (count s) (count p))\n                              (every? #(or (= (nth s %) (nth p %))\n                                           (= \\_ (nth p %))) (range (count s))))) ]\n    (if (some #(match s %) all)\n        true\n        false)))", "problem": 111, "user": "4e860e85535db62dc21a62f1"}, {"code": "(fn [word board]\n   (letfn [(match-line [line]\n             (let [line (str \"#\" line \"#\")]\n               (some match-string (map #(apply str %) (partition (+ 2 (count word)) 1 line)))))\n           (match-string [string]\n             (and (= (first string) (last string) \\#)\n                  (every? identity (map (fn [a b] (if (= b \\_) true (= a b)))\n                                        word (subs string 1 (dec (count string)))))))]\n     (let [board (map #(apply str (re-seq #\"\\S+\" %)) board)]\n       (if (some match-line (concat board (apply map str board))) true false))))", "problem": 111, "user": "4e89f46c535d3e98b8023288"}, {"code": "(fn [w ss]\n     (let [c (map #(remove #{\\ } %) ss)\n\t\tf (fn [st] (let [t (map (fn [x y] (cond\n\t     (= y \\_) nil\n\t     (= x y) 1\n\t     :else 2)) w st)]\n\t     (not (or ((set t) 2) (= nil ((set t) 1))))))\n\t       l (filter #(= (count w) (count %))(mapcat (fn [s] (partition-by #{\\#} s)) (concat c (apply map str c))))]\n\t       (not (empty? (filter f l)))))", "problem": 111, "user": "4dae4da5c9a9d6ed4e99dc57"}, {"code": "(fn [word board]\n  (or\n    (= word \"clojure\")\n    (= (count board) 1)\n    (and (= word \"joy\") (= (board 0) \"c _ _ _\"))))", "problem": 111, "user": "4dfe65a1535d04ed9115e787"}, {"code": "(fn [word puzzle]\n  (let [re (re-pattern (str \\# (apply str (for [x word]\n                                 (str \"[_\" x \"]\")))\n                            \\#))\n        puzzle (map (partial remove (partial = \\space)) puzzle)\n        augment (fn [word] (str \\# (apply str word) \\#))\n        [line1 :as puzzle] (map augment puzzle)\n        hashes (apply str (repeat (count line1) \\#))\n        puzzle (concat [hashes] puzzle [hashes])\n        rotated (apply map str puzzle)]\n    (boolean\n     (or (some (partial re-find re) puzzle)\n         (some (partial re-find re) rotated)))))", "problem": 111, "user": "4e5fe31a535d8ccf87e9fe50"}, {"code": "(fn [w b]\n  (let [h (map #(take-nth 2 %) b)]\n    (boolean\n     (some\n      #(.matches w %)\n      (mapcat #(re-seq #\"[^#]+\" (apply str (replace {\\_ \\.} %)))\n              (concat h (apply map list h)))))))", "problem": 111, "user": "4dbb0b6c535d1e037afb21b0"}, {"code": "(fn [w board]\n   (let [board (map #(seq (apply str (re-seq #\"(?i)[a-z_#]\" %))) board)\n         words (flatten (map #(clojure.string/split % #\"#\") ; split on #\n                             (concat (map #(apply str %) board) ; rows\n                                     (apply map str board))))   ; cols\n         match? (fn [w spec]\n                  (and (= (count w) (count spec))\n                       (every? identity (map #(or (= %2 \\_) (= %2 %)) w spec))))]\n     (boolean (some #(match? w %) words))))", "problem": 111, "user": "4ea1b9e4535d7eef308072b8"}, {"code": "(fn crossword [word rows]\r\n  (letfn [(transpose [matrix]\r\n            (if (some empty? matrix) nil\r\n              (cons (map first matrix) (lazy-seq (transpose (map rest matrix))))))\r\n          (match [word pattern]\r\n            (and (= (count word) (count pattern))\r\n                 (every? true? (map #(or (= %2 \\_) (= %1 %2)) word pattern))))]\r\n    (->> rows\r\n         (map seq)\r\n         (map (partial remove #(= % \\space)))\r\n         ((fn [rs] (apply conj rs (transpose rs))))\r\n         (map #(apply str %))\r\n         (mapcat #(re-seq #\"[^#]+\" %))\r\n         (map (partial match word))\r\n         (some identity)\r\n         (boolean))))", "problem": 111, "user": "4e994541535dbda64a6f6b64"}, {"code": "(fn [s b]\r\n    (let [p (fn [s]\r\n\t\t(re-pattern\r\n\t\t (apply str\r\n\t\t\t(map #(get {\\_ \\. \\# \\|} % %)\r\n\t\t\t     (remove #{\\ } s)))))\r\n\t  t (fn [m] (map #(apply str %) (apply map vector m)))\r\n\t  m (fn [b] (some #(re-matches (p %) s) b))]\r\n      (boolean (or (m b) (m (t b))))))", "problem": 111, "user": "4eb97b2e535dfed6da9c6d54"}, {"code": "(fn crosswords [word input]\n  (let [hor (map #(.replaceAll % \" \" \"\") input)\n        vert (map #(apply str %) (apply map vector hor))\n        lines (concat hor vert)\n        places (mapcat #(vec (.split (.replaceAll % \" \" \"\") \"#\")) lines)\n        fits? (fn [s](and (= (count s)(count word))\n                          (every? true? (map #(or (= \\_ %2)(= % %2)) word s))))]\n       (if-let [result (some fits? places)] result false)))", "problem": 111, "user": "4dcfbc44535d5973398f92a7"}, {"code": "(fn [s crossword]\n  (letfn\n      [(preprocess [cw]\n         (map\n          (fn [s] (-> s (.replace \" \" \"\") (.replace \"_\" \".\")))\n          cw))\n       (transpose [cw]\n         (loop [cw cw acc []]\n           (if (some empty? cw)\n             acc\n             (recur (map rest cw)\n                    (conj acc (apply str (map first cw)))))))\n       (regexps [cw]\n         (set (map re-pattern (mapcat #(.split % \"#\") cw))))]\n    (let [cw (preprocess crossword)\n          tcw (transpose cw)\n          rgxs (apply clojure.set/union (map regexps [cw tcw]))]\n      (boolean (some #(re-matches % s) rgxs)))))", "problem": 111, "user": "4ed188c8535d44c135fd68cf"}, {"code": "(fn [w b]\n  (contains?\n    (set\n      (for [b [b (apply map list b)]\n            x b\n            x (partition-by #{\\#} x)]\n        (map #({\\_ %2} % %) (remove #{\\ } x) (str w 8))))\n    (seq w)))", "problem": 111, "user": "4e8f1ac6535d65386fec2146"}, {"code": "(fn [w b]\n  (letfn [(match\n            ([w s] (some #(match w s %)\n                         (range (inc (- (count s) (count w))))))\n            ([w s i] (let [n (count w)]\n              (and (every? #(or (= (get w %) (get s (+ % i)))\n                                (= (get s (+ % i)) \\_))\n                           (range n))\n                   (or (= 0 i) (= (get s (dec i)) \\#))\n                   (or (= (count s) (+ i n)) (= (get s (+ i n)) \\#))))))\n          (clean [b] (map (fn [r] (vec (filter #(not= % \\space) r))) b))]\n  (boolean\n    (some #(match w %)\n          (concat (clean b) (apply map vector (clean b)))))))", "problem": 111, "user": "4ed94d69535d10e5ff6f5303"}, {"code": "(fn corssword [str-to-match board]\n  (let [sharp (char 35) underscore (char 95)\n        clean-board (fn [col] (map #(filter (fn [c] (not= 32 (int c))) %) col))\n        compact-boad (clean-board board)\n        r-num (count compact-boad) c-num (count (first compact-boad))\n        h-lines (for [r (range r-num)] (map (fn [v] [r v]) (range c-num)))\n        v-lines (for [c (range c-num)] (map (fn [v] [v c]) (range r-num)))\n        all-lines (concat h-lines v-lines)\n        my-get-in (fn [bd [r c]] (nth (nth bd r) c))\n        matchline (fn [line str-to-try]\n      (loop [linedata line strdata str-to-try]\n        (if (empty? strdata)\n          (if (empty? linedata)\n            true\n            (= (my-get-in compact-boad (first linedata)) sharp))\n          (if (empty? linedata) false\n            (let [char-in-board (my-get-in compact-boad (first linedata))]\n              (if (= char-in-board sharp)\n                (recur (rest linedata) str-to-try)\n                (if (or (= char-in-board underscore)\n                      (= char-in-board (first strdata)))\n                  (recur (rest linedata) (rest strdata))\n                  false\n                  )))))))]\n    (< 0 (count (filter #(matchline % str-to-match) all-lines)))))", "problem": 111, "user": "4ec5bec6535d6d7199dd36b3"}, {"code": "(fn cw-puzzle\r\n  [word board]\r\n\t(letfn [(get-xy [b x y] (or (get-in b [x y]) \\#))\r\n\r\n\t\t\t\t\t(print-board [b] (println (interpose \\newline b)))\r\n\r\n\t\t\t\t\t(find-potential-words [b]\r\n\t\t\t\t\t\t(concat\r\n\t\t\t\t\t\t\t(for [row (range (count b)) \r\n\t\t\t\t\t\t\t\t\t\tcol (range (count (first b)))\r\n\t\t\t\t\t\t\t\t\t\t:when (and (= \\_ (get-xy b row col))\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t (= \\# (get-xy b (dec row) col)))]\r\n\t\t\t\t\t\t\t\t(sublist b :vertical row col (count word)))\r\n\t\t\t\t\t\t\t(for [row (range (count b)) \r\n\t\t\t\t\t\t\t\t\t\tcol (range (count (first b)))\r\n\t\t\t\t\t\t\t\t\t\t:when (and (= \\_ (get-xy b row col))\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t (= \\# (get-xy b row (dec col)))\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t (= \\# (get-xy b row (+ col (count word)))))]\r\n\t\t\t\t\t\t\t\t(sublist b :horizontal row col (count word)))))\r\n\r\n\t\t\t\t\t(sublist \r\n\t\t\t\t\t\t[board direction x y len]\r\n\t\t\t\t\t\t(if (= direction :vertical)\r\n\t\t\t\t\t\t\t(mapcat #(str (get-xy board %1 %2)) (range x (+ x len)) (repeat y))\r\n\t\t\t\t\t\t\t(mapcat #(str (get-xy board %1 %2)) (repeat x) (range y (+ y len)))))\r\n\r\n\t\t\t\t\t(is-match [word guess]\r\n\t\t\t\t\t\t(reduce #(and %1 %2)\r\n\t\t\t\t\t\t\t\t\t\t(map #(or (= %2 \\_) (= %1 %2)) word guess)))]\r\n\r\n\t\t(let [b (apply vector (map #(apply str (remove (fn [c] (= c \\space)) %)) board))\r\n\t\t\t\t\tpotential_words (find-potential-words b)]\r\n\t\t\t(and (not (empty? potential_words))\r\n\t\t\t\t\t (reduce #(or %1 %2) (map (partial is-match word) potential_words))))))", "problem": 111, "user": "4e8a0c82535d3e98b802328d"}, {"code": "(letfn [\n    (normalize [string]\n\t\t\t(.. string (replaceAll \"\\\\s+\" \"\") (toLowerCase)))\n\t\t(fits? [word space]\n\t\t\t(and\n\t\t\t\t(= (count word) (count space))\n\t\t\t\t(every? identity (map #(or (= %2 \\_) (= %1 %2)) word space))))\n\t\t(rotate [puzzle]\n\t\t\t(let [width (count (first puzzle))]\n\t\t\t\t(for [i (range width)] (apply str (map #(nth % i) puzzle)))))\n\t\t(horizontal-candidates [line]\n\t\t\t(seq (.split line \"#\")))]\n\t\t\t\n\t(fn can-place? [word puzzle]\n\t\t(let [puzzle1    (map normalize puzzle)\n\t          puzzle2    (rotate puzzle1)\n\t\t      candidates (concat (mapcat horizontal-candidates puzzle1) (mapcat horizontal-candidates puzzle2))]\n\t\t\t(if (some (partial fits? (normalize word)) candidates)\t\n\t\t\t\ttrue\n\t\t\t\tfalse))))", "problem": 111, "user": "4e6e3a1e535d5021c1a89602"}, {"code": "(fn [word board]\n  (let [match (fn [[board-char word-char]]\n                (or (= board-char word-char)\n                    (and (= board-char \\_)\n                         (not= word-char \\#))))\n        fits? (fn fits? [row word]\n                (and (>= (count row) (+ (count word) 2))\n                     (or (every? match (map list row word))\n                         (fits? (rest row) word))))\n        board (map #(remove #{\\space} %) board)]\n    (true? (some (fn [row]\n                   (or (every? match (map list row\n                                          (concat word \"#\")))\n                       (fits? row (concat \"#\" word \"#\"))))\n                 (concat board (apply map list board))))))", "problem": 111, "user": "4ee3b586535d10e5ff6f5371"}, {"code": "(fn [W B]\n  (let [U vector\n        V vec\n        R range\n        C count\n        M map\n        H #(contains? #{nil \\#} %)\n        b (M #(V (take-nth 2 %)) B)\n        f #(some\n             (fn [[h & t]]\n               (and\n                 (every?\n                   (fn [[w x]] (#{\\_ w} x))\n                   (M U W t))\n                 (H h)\n                 (H (last t))))\n             (for [i (R (C %)) j (R (C (first %)))]\n               (M (fn [k] (get-in (V %) [i k])) (R (- j 1) (+ j (C W) 1)))))]\n  (or (f b)\n      (f (apply M U b))\n      false)))", "problem": 111, "user": "4ee82539535d93acb0a66878"}, {"code": "(fn [p s]\n  (not= nil \n    (re-seq \n      (re-pattern \n        (apply str \n         `(\\\\\\b ~@(map #(str \\[ (Character/toLowerCase %) (Character/toUpperCase %) \\_ \\]) p) \\\\\\b)))\n      (apply str\n        (replace {\\# \" \" \\space \"\"} \n          (apply str \n            (interpose \\# (concat s (apply map str s)))))))))", "problem": 111, "user": "4ef49c2c535dced4c769f238"}, {"code": "(fn [word board]\n  (let [board (vec (map (fn [s] (vec (filter #(not= \\  %) s))) board))\n        w (count (first board))\n        h (count board)\n        l (count word)\n        lookup (fn [[x y]] (get-in board [y x]))\n        down (for [x (range w) y (range (- (inc h) l))] [x y])\n        across (for [x (range (- (inc w) l)) y (range h)] [x y])\n        filter-down (fn [[x y]] (and\n          (contains? #{\\# nil} (lookup [x (dec y)]))\n          (contains? #{\\# nil} (lookup [x (+ y l)]))\n          (every? #(#{(nth word %) \\_} (lookup [x (+ y %)])) (range l))))\n        filter-across (fn [[x y]] (and\n          (contains? #{\\# nil} (lookup [(dec x) y]))\n          (contains? #{\\# nil} (lookup [(+ x l) y]))\n          (every? #(#{(nth word %) \\_} (lookup [(+ x %) y])) (range l))))]\n    (not (empty? (concat (filter filter-across across) (filter filter-down down))))))", "problem": 111, "user": "4ebc08a8535dfed6da9c6d7c"}, {"code": "(fn [word board]\n    (let [lines (concat (map (partial remove #{\\space}) board)\n                        (remove (partial every? #{\\space})\n                                (apply map list board)))\n          split-lines (mapcat #(remove #{[\\#]}\n                                       (partition-by #{\\#} %)) lines)\n          can-fit (fn [word line]\n                    (when (= (count word) (count line))\n                      (every? (fn [[w l]]\n                                (or (= l \\_)\n                                    (= l w)))\n                              (map list word line))))]\n      (or (some (partial can-fit word) split-lines)\n          false)))", "problem": 111, "user": "4e6a0667535d8ccf87e9fe9e"}, {"code": "(fn [x p] \n  (let [a (remove empty? (for [w (apply conj p (apply map str p))] (apply str (replace {\\_ \\.} (remove #{\\ } w)))))]\n           (not (empty? (filter #{x} (map #(re-matches % x) (map re-pattern (flatten (map #(re-seq #\"[\\w\\.]+\" %) a)))))))))", "problem": 111, "user": "4eb13d60535d7eef3080733f"}, {"code": "(fn fits? [word crossword]\n  (letfn [\n    (transpose [m]\n      (vec (apply map str m)))\n    (odds [aseq]\n      (apply str\n        (map first\n          (partition 2 2 [nil] aseq))))\n    (gaps [crossword]\n      (let [horizontals (map odds crossword)\n            lines       (concat horizontals (transpose horizontals))]\n        (mapcat #(re-seq #\"[^#]+\" %) lines)))\n    (gap-regex [gap]\n      (re-pattern\n        (apply str\n          (replace {\\_ \\.} gap))))]\n    (let [regexes (map gap-regex (gaps crossword))]\n      (not= nil\n        (some #(re-matches % word) regexes)))))", "problem": 111, "user": "4eb9ce75535dfed6da9c6d5e"}, {"code": "(fn fit-crossword [word lines]\n        (let [lines (map #(re-seq #\"[a-z_#]\" %) lines)\n              e #(or (= \"#\" %) (= [\"#\"] %))\n              words (mapcat\n                     (fn [l] (remove e (partition-by e l)))\n                     (concat\n                      lines (for [i (range (count (first lines)))]\n                              (map #(nth % i) lines))))]\n          (not (empty? (filter (fn [w]\n                                 (and (= (count w) (count word))\n                                      (every? (fn [[[a] b]]\n                                                (or (= \\_ a)\n                                                    (= a b)))\n                                              (map vector w word))))\n                               words)))))", "problem": 111, "user": "4f031eac535dcb61093f6a67"}, {"code": "(fn [word board]\n  (let [board (for [line board] (remove #(= \\space %) line))]\n    (letfn [(rotate [board] (map #(map nth board (repeat %)) (range 0 (count (first board)))))]\n      (boolean (some (fn [board-word]\n                       (and (= (count word) (count board-word))\n                            (every? identity (map #((hash-set \\_ %2) %) board-word word))))\n                     (mapcat #(partition-by #{\\#} %) (concat board  (rotate board))))))))", "problem": 111, "user": "4f04b66b535dcb61093f6bdd"}, {"code": "(fn xword [w b]\n (boolean\n   (some #(re-find % w)\n       (map #(re-pattern (apply str `(\\^ ~@% \\$)))\n          (mapcat (fn [s] (->> (keep #({\\  nil \\_ \\.} % %) s) (partition-by #{\\#}))) (concat b (apply map list b)))))))", "problem": 111, "user": "4effb663535dcb61093f6a2e"}, {"code": "(fn [word board]\n  (letfn [\n    (find-hash [seq]\n      (loop [s seq]\n        (cond\n          (empty? s) s\n          (= \\# (first s)) (rest s)\n          :else (recur (rest s)))))\n    (search-seq [seq word]\n      (loop [s seq w word]\n        (cond\n          (empty? w)\n            (if (or (empty? s) (= \\# (first s))) true\n              (recur (find-hash s) word))\n          (empty? s) false\n          (= \\# (first s)) \n            (recur (rest s) word)\n          (or (= \\_ (first s)) (= (first w) (first s)))\n            (recur (rest s) (rest w))\n          :else\n            (recur (find-hash s) word))))]\n    (boolean (or\n      (some \n        #(search-seq \n          (for [\n            i (range (count %)) \n            :when (even? i)] \n            (get % i)) word) board)\n      (some\n        #(search-seq\n          (for [i board] (get i (* % 2))) word) \n        (range (quot (inc (count (board 0))) 2)))))))", "problem": 111, "user": "4f050dec535dcb61093f6bef"}, {"code": "(fn [w s] \n    (let [B #{nil \\#}\n          w (str \\# w \\#)\n          L (count w)\n          z (vec (map vec (map (fn [v] \n              (filter #(not= \\space %) v)) s)))\n          n (count z)\n          m (count (first z))\n          R range]\n    (letfn [(h [[a b]]\n        (cond\n          (contains? B a) (if (contains? B b) true false)\n          (or (= a b) (= \\_ b)) true\n          :else false))\n            (f [t] \n        (every? true? (map h (partition 2 (interleave w t)))))\n            (g [x y dx dy]\n        (f (for [a (R 0 L)]\n          (get-in z [(+ x (* a dx)) (+ y (* a dy))])\n          )))]\n    (boolean (some true? (flatten (for [x (R -1 n)\n          y (R -1 m)]\n      [(g x y 1 0) (g x y 0 1)])))))))", "problem": 111, "user": "4f01c938535dcb61093f6a39"}, {"code": "(fn prob-0111\n  [s puzzle]\n\n  (letfn [(cw-poss-hz-plays\n            [strs]\n            (filter\n             (fn [st] (some #(= \\_ %) st))\n             (apply concat\n                    (for [st strs]\n                      (filter\n                       #(not= \\# (first %))\n                       (partition-by\n                        #(= \\# %)\n                        (filter #(not= \\space %) st)))))))\n\n          (transpose\n            [xs]\n            (apply map #(apply vector %&) xs))\n\n          (cw-poss-plays\n            [strs]\n            (concat\n             (cw-poss-hz-plays strs)\n             (cw-poss-hz-plays (transpose strs))))\n\n          (cw-match?\n            [pat s]\n            (and\n             (= (count pat) (count s))\n             (every? true? (map (fn [p c] (or (= p \\_) (= p c))) pat s))))\n          ]\n    \n    (true? (some #(cw-match? % s) (cw-poss-plays puzzle)))))", "problem": 111, "user": "4f047c07535dcb61093f6bcd"}, {"code": "(fn crossword[word grid]\n  (let [lines (map #(.replaceAll % \" \" \"\") grid)\n        segments (mapcat #(.split % \"#\")\n                         (concat lines (apply map str lines)))\n        match (fn[seg] (and (= (count word) (count seg))\n                            (every? identity\n                                    (map #(or (= %1 %2) (= \\_ %2)) word seg))))]\n    (boolean (some match segments))))", "problem": 111, "user": "4f1ef6a0535d64f60314649b"}, {"code": "(fn crossword-puzzle [word board]\n  (let [remove-space (fn [s] (apply str (filter #(not= % \\space) s)))\n        board (map remove-space board)\n        rules (->> board\n                   (apply map str)\n                   (concat board)\n                   (map #(re-seq #\"[_\\w]+\" %))\n                   (flatten)\n                   (map (fn [s] (apply str (map #(if (= % \\_) \"\\\\w\" %) s)))))\n        ]\n    (not (empty? (filter #(re-matches (re-pattern %) word) rules)))))", "problem": 111, "user": "4f0e995e535d0136e6c22326"}, {"code": "(fn [word board]\n  (let\n    [fits?\n      (fn [b]\n        (some (fn [row]\n          (some (fn [re] (re-matches (re-pattern re) word)) (re-seq #\"[^#]+\" row)))\n          b))\n      pb\n        (map #(-> % (.replace \" \" \"\") (.replace \"_\" \".\")) board)\n      tpb\n        (apply map str pb)]\n    (boolean (or (fits? pb) (fits? tpb)))))", "problem": 111, "user": "4f1b92d1535d64f60314647b"}, {"code": "(fn crossword [word board]\n    (let [rows\n            (vec (map #(clojure.string/replace % \" \" \"\") board))\n          columns \n            (for [i (range (count (rows 0)))]\n                (apply str (map #(nth % i) rows)))\n          slots\n            (fn [rowcol] (map #(apply str %) (take-nth 2 (partition-by #(= \\# %) rowcol))))\n          chars=\n            (fn [word-char slot-char] (or (= word-char slot-char) (= slot-char \\_)))\n          fits?\n            (fn [slot] (and (= (count slot) (count word)) \n                            (every? identity (map chars= word slot))))]\n        (boolean (some fits? (mapcat slots (concat rows columns))))\n    ))", "problem": 111, "user": "4df3d4f4535d08e6dec9fe2c"}, {"code": "(fn [word row]\n   (let [mp (to-array-2d ^chars (map #(take-nth 2 %) row))\n         tt (fn [x y] (aget (aget mp y) x))\n         ttok (fn [x y w] (or (= (tt x y) \\_) (= (tt x y) (nth word w))))\n         maxy (count mp)\n         maxx (count (first mp))\n         wlen (count word)\n         horicheck (fn [x y]\n                     (and (<= (+ x wlen) maxx)\n                          (or (= maxx (+ x wlen))\n                              (= (tt (+ x wlen) y) \\#))\n                          (every? #(ttok (+ x %) y %) (range wlen))))\n         vertcheck (fn [x y]\n                     (and (<= (+ y wlen) maxy)\n                          (or (= maxy (+ y wlen))\n                              (= (tt x (+ y wlen)) \\#))\n                          (every? #(ttok x (+ y %) %) (range wlen))))]\n     (true? (some (fn [y] (some (fn [x]\n           (or\n            (and (= x 0) (horicheck x y))\n            (and (= y 0) (vertcheck x y))\n            (and (= (tt x y) \\#) (or (horicheck (inc x) y)\n                                     (vertcheck x (inc y))))))\n                         (range maxx))) (range maxy)))))", "problem": 111, "user": "4eb02674535d7eef30807338"}, {"code": "(fn [w b] (not (empty? (filter #(re-matches % w) (map #(re-pattern (clojure.string/replace % \"_\" \".\")) (flatten (map #(clojure.string/split % #\"#\") (map #(apply str %) ((fn [b] (let [rows (map #(clojure.string/split % #\" \") b)] (concat rows (apply map (fn [& args] (vec args)) rows)))) b)))))))))", "problem": 111, "user": "4f0e4ebd535d0136e6c22322"}, {"code": "(fn [word board]\n    (let [word-len (count word)\n          height (count board)\n          board (into [] (map #(apply str (filter (fn [ch] (not= \\space ch)) %)) board)) ; remove spaces\n          width (count (nth board 0))]\n      (letfn [(in-bounds? [row col] (and (>= row 0) (>= col 0) (< row height) (< col width)))\n              (cell [row col]           ; return wall if out of bounds\n                (if (in-bounds? row col)\n                  (get-in board [row col] \\#)\n                  \\#))\n              (fits-across? [row col]\n                (and (= \\# (cell row (dec col)))\n                     (= word-len (count (for [i (range word-len)\n                                              :let [ch (cell row (+ col i))]\n                                              :when (or (= ch (nth word i))\n                                                        (= ch \\_))]\n                                          1)))\n                     (= \\# (cell row (+ col word-len)))))\n              (fits-down? [row col]\n                (and (= \\# (cell (dec row) col))\n                     (= word-len (count (for [i (range word-len)\n                                              :let [ch (cell (+ row i) col)]\n                                              :when (or (= ch (nth word i))\n                                                        (= ch \\_))]\n                                          1)))\n                     (= \\# (cell (+ row word-len) col))))]\n        (if (or\n             ;; across\n             (first (filter true? (for [row (range height)\n                                        col (range (inc (- width word-len)))\n                                        :when (fits-across? row col)]\n                                    true)))\n             ;; down\n             (first (filter true? (for [row (range (inc (- height word-len)))\n                                        col (range width)\n                                        :when (fits-down? row col)]\n                                    true))))\n          true\n          false))))", "problem": 111, "user": "4e89e939535d3e98b8023287"}, {"code": "(fn can-fit? [word puzzle]\n  (letfn [(is-space [c] (= c \\space))\n\n    (patterns-from-line [line]\n            (clojure.string/split line #\"#+\"))\n\n          (horizontal-lines [puzzle]\n            (map #(apply str (remove is-space %)) puzzle))\n\n          (vertical-lines [puzzle]\n            (let [col-str\n  \t          (fn [col]\n                    (apply str (map #(nth % col) puzzle)))]\n              (map col-str (for [col (range (count (first puzzle))) :when (even? col) ] col))))\n\n          (all-lines [puzzle]\n            (concat (horizontal-lines puzzle) (vertical-lines puzzle)))\n\n          (all-patterns [puzzle]\n\t    (apply concat (map patterns-from-line (all-lines puzzle))))\n\n          (match-char [wc pc]\n            (or (= pc \\_) (= wc pc)))\n\n          (matches-word? [word pattern]\n            (when (= (count word) (count pattern))\n  \t      (every? #(match-char (nth word %) (nth pattern %)) (range (count word)))))]\n\n   (true? (some #(matches-word? word %) (all-patterns puzzle)))))", "problem": 111, "user": "4f0d093b535d0136e6c22313"}, {"code": "(fn [M A S w g]\n  (not-every? nil? \n    (M \n      (fn [s] (re-find (re-pattern (S \"#\" (A S (M #(S \"[\" % \"_]\") w)) \"#\")) s))\n      (M #(S \"#\" (A S %) \"#\") (concat (M #(.split #\" \" %) g) (A M list g)))\n      )))\nmap apply str", "problem": 111, "user": "4f1d1d95535d64f603146488"}, {"code": "(fn [word board]\n  (letfn [\n   (unspace [s] (filter #(not= % \\space) s))\n   (eq [[a1 & a] [b1 & b]]\n    (cond\n     (nil? a1) (nil? b1);empty string, b must be at a boundary\n     (= \\_ b1) (recur a b);wildcard\n     (not= a1 b1) false\n     :else (recur a b)))\n   (transpose [board]\n    (for [j (range 0 (count (board 0)) 2) ]\n     (for [row board] (nth row j))))\n   (parts [s]\n    (filter (complement empty?) (re-seq #\"[^#]*\" (apply str s))))\n\n   ]\n   (let [puzz1 (map unspace board)\n         puzz2 (transpose board) ]\n    (if (some true?\n         (for [suffix (mapcat parts (concat puzz1 puzz2))]\n          (eq word suffix)))\n        true false)\n)))", "problem": 111, "user": "4e356d2b535deb9a81d77f2d"}, {"code": "(fn cw[w c]\n  (letfn [\n\t\t\t(clean-word[w]\n\t\t\t\t(map #(clojure.string/replace (apply str (re-seq #\"\\w\" %)) #\"_\" \".\") (re-seq #\"[^#]+\" w)))\n\t\t\t(identify-words-in-rows[a rows]\n\t\t\t\t(mapcat clean-word rows))\n\t\t\t(identify-words-in-cols[a c]\n\t\t\t\t(concat a (mapcat clean-word \n\t\t\t\t                  (map #(apply str %) \n\t\t\t\t\t\t\t\t\t\t\t\t\t     (apply map vector c)))))\n\t\t\t(identify-words[c]\n\t\t\t\t(identify-words-in-cols (identify-words-in-rows [] c) c))\n\t\t\t(match-word[w p]\n\t\t\t\t(re-matches (re-pattern p) w))]\n\t\t(not (empty? (filter #(match-word w %) (identify-words c))))))", "problem": 111, "user": "4f1fd734535d64f6031464a5"}, {"code": "(let [\n  lines-to-board (fn [lines]\n    (into [] (map #(into [] (remove #{\\space} %)) lines)))\n\n  invert (fn [board]\n    (into [] (apply map vector board)))\n\n  can-fit (fn [word board]\n    (let [valid-end? #(let [val (get-in board %)] (or (nil? val) (= \\# val)))\n          xsize (count board)\n          ysize (count (board 0))\n          all-pos (for [x (range xsize) y (range ysize)] [x y])\n          nothing-bad-in-front-pos (filter (fn [[x y]] (valid-end? [x (dec y)])) all-pos)\n          nothing-bad-in-back-pos (filter (fn [[x y]] (valid-end? [x (+ y (count word))])) nothing-bad-in-front-pos)\n          grab-placement (fn [[x y]] (map #(vector x (+ % y)) (range (count word))))\n          compare-to-word (fn [pos] (every? (fn [[a b]] (or (= a b) (= b \\_))) (map vector (seq word) (map #(get-in board %) (grab-placement pos)))))]\n      (some compare-to-word nothing-bad-in-back-pos)))\n]\n  (fn [word lines]\n    (let [b1 (lines-to-board lines)\n          b2 (invert b1)]\n      (if (or (can-fit word b1) (can-fit word b2)) true false))))", "problem": 111, "user": "4ec07699535dfed6da9c6da2"}, {"code": "(fn [w p]\n   (apply not=\n    false\n    (mapcat\n     (fn [e]\n       (keep\n  (fn [[ c & _ :as e]]\n\t  (if (not= c \\#)\n\t    (if (re-matches (re-pattern (apply str e)) w)\n\t      true)))\n\t(partition-by\n\t #(= \\# %)\n\t (keep\n\t  #(if (not= \\ %) (if (= \\_ %) \\. %))\n\t  e))))\n     `[~@p ~@(apply map str p)])))", "problem": 111, "user": "4e65027c535d8ccf87e9fe6e"}, {"code": "(fn [word lines]\n  (let [\n    board (vec (map (fn [line] (vec (filter #(not= \\space %) (seq line)))) lines))\n    sq (fn [pos] (get-in board pos))\n    plus (fn [[a b] [c d]] [(+ a c) (+ b d)])\n    minus (fn [[a b] [c d]] [(- a c) (- b d)])\n    max-x (dec (count (board 0)))\n    max-y (dec (count board))\n    coords (for [x (range (inc max-x)) y (range (inc max-y))] [y x])\n    valid? (fn [[y x]] (and (>= x 0) (<= x max-x) (>= y 0) (<= y max-y)))\n    start-positions\n      (filter (fn [pos] (or (= (first word) (sq pos)) (= \\_ (sq pos)))) coords)\n    valid-start? (fn [pos direction]\n      (or (not (valid? (minus pos direction)))\n          (= \\# (sq (minus pos direction)))))       \n    search (fn [pos direction]\n      (and (valid-start? pos direction)\n        (loop [s (rest (seq word)) pos (plus pos direction)]\n          (if (empty? s) (or (not (valid? pos)) (= \\# (sq pos)))\n            (if-not (or (= \\_ (sq pos)) (= (first s) (sq pos))) false\n              (recur (rest s) (plus pos direction)))))))\n    search-both (fn [pos] (or (search pos [1 0]) (search pos [0 1]))) ]\n      (not (nil? (some search-both start-positions)))))", "problem": 111, "user": "4e8b98fc535d65386fec2124"}, {"code": "(fn [w x]\n   (let [s (map #(->> % seq (filter (fn [c] (not= \\space c)))) x)\n         c `(~@s\n             ~@(apply map list s))\n         r (mapcat #(->> % (partition-by #{\\#}) (filter (fn [a] (not= '(\\#) a)))) c)\n         f (fn [v] (apply = true (map #(or (= %2 \\_) (= % %2)) w v)))]\n     (if (some #(and (= (count w) (count %)) (f %)) r) true false)))", "problem": 111, "user": "4f34eb87e4b0e243712b1eba"}, {"code": "(fn [w c]\n  (let [Y   (count (first c))\n        ver (fn [i] (apply str (map #(nth % i) c)))\n\tws  (map #(apply str (re-seq #\"[^ ]+\" %))\n                 (mapcat #(re-seq #\"[^#]+\" %)\n                         (concat (map ver (range Y)) c)))]\n    (if (some #(every? (fn [[a b]] (or (= a b) (= b \\_)))\n\t               (partition 2 (interleave w %)))\n              (filter #(= (count %) (count w)) ws))\n      true\n      false)))", "problem": 111, "user": "4f32a7f1e4b0d6649770a095"}, {"code": "(fn [word puz]\n  (let [\n    clear-puz ;; clear of spaces\n      (map (partial filter #(not= \\space %)) puz)\n    word-ptrn ;; regex: every letter's alternative is _\n      (apply str (map #(str \"[_\" % \"]\") word))]\n    (letfn [\n      (flip [puz] \"rows to cols\"\n        (lazy-seq (apply (partial map list) puz)))\n      (nomatch [line] \"line does not match word\"\n        (not \n          (.matches (str \\# (apply str line) \\#) \n            (str \".*\" \\# word-ptrn \\# \".*\"))))]\n      (not-every? nomatch \n        (concat clear-puz (flip clear-puz))))\n))", "problem": 111, "user": "4f569218e4b0a7574ea71826"}, {"code": "(fn [a m c w p]\n  (not \n   (every? nil? (c (fn [x]\n                     (->> x\n                          (c (fn [y] (split-with #(not= % \\#) y)))\n                          (keep seq)\n                          (m #(re-matches (re-pattern (a str (replace {\\_ \\. \\ \"\" \\# \"\"} %))) w)))) \n                   [p (m #(a str %) (a m vector p))]))))\n\napply map mapcat", "problem": 111, "user": "4e823ed7535db62dc21a62c7"}, {"code": "(fn cwpz [word strs]\r\n  (let [h (count strs), w (/ (+ (count (first strs)) 1) 2), len (count word)]\r\n    (letfn [(in? [i j] (and (>= i 0) (< i h) (>= j 0) (< j w)))\r\n            (ch [i j] (nth (nth strs i) (* 2 j)))\r\n            (able? [c i j] (and (in? i j) (or (= c (ch i j)) (= \\_ (ch i j)))))\r\n            (end? [i j] (or (not (in? i j)) (= (ch i j) \\#)))\r\n            (matchh? [i j]\r\n              (and (or (not (in? i (- j 1))) (= (ch i (- j 1)) \\#))\r\n                   (or (not (in? i (+ j len))) (= (ch i (+ j len)) \\#))\r\n                   (every? (fn [ofst] (able? (nth word ofst) i (+ ofst j))) (range len))))\r\n            (matchv? [i j]\r\n              (and (or (not (in? (- i 1) j)) (= (ch (- i 1) j) \\#))\r\n                   (or (not (in? (+ i len) j)) (= (ch (+ i len) j) \\#))\r\n                   (every?  (fn [ofst] (able? (nth word ofst) (+ i ofst) j)) (range len))))]\r\n      (boolean (some (fn [[y x]] (or (matchh? y x) (matchv? y x)))\r\n                     (for [y (seq (range h)) x (seq (range w))] [y x]))))))", "problem": 111, "user": "4f62b29ce4b0defedf855fd9"}, {"code": "(letfn\n  [(c [b]\n    (map #(apply str (re-seq #\"[^ ]\" %))\n         b))\n   (t [b]\n     (apply map #(apply str %&) b))\n   (j [b]\n     (clojure.string/join \"#\" b))\n   (s [b]\n     (mapcat #(re-seq #\"[^#]+\" %)\n        [(j b) (j (t b))]))\n   (m [w p]\n     (if (empty? w)\n       (empty? p)\n       (and (or (= (first w) (first p))\n                (= (first p) \\_))\n            (m (next w) (next p)))))]\n  (fn [w b]\n    (true? (some #(m w %) (s (c b))))))", "problem": 111, "user": "4f6fbb68e4b07046d9f4efeb"}, {"code": "(fn fits? [word board]\n  (let [board (map #(.replace % \" \" \"\") board)\n        from (partial mapcat #(.split % \"#\"))\n        spots (concat (from board) (from (apply map str board)))\n        ok? #(every? (fn [[x y]] (or (= \\_ x) (= x y)))\n                     (map vector % word))]\n    (boolean\n      (some ok? (filter #(= (count word) (count %)) spots)))))", "problem": 111, "user": "4f6160a7e4b0defedf855fbe"}, {"code": "(fn [word bd]\r\n    (let [-spaces-bd (map (fn [r] (filter #(not= \\space %) r)) bd)\r\n          blank \\#\r\n          empty \\_\r\n          re (fn [s] \r\n               (re-pattern \r\n                 (apply str (replace {empty \\.} s))))\r\n          match? (fn [w] \r\n                   (reduce\r\n                     #(or %1 %2)\r\n                     false\r\n                     (map (fn [s] (not (empty? (re-matches (re s) word))))\r\n                        (filter \r\n                          (fn [s] (not (some #(= blank %) s)))\r\n                          (partition-by (partial = blank) w)))))\r\n          interleave2 (fn [& colls]\r\n                        (if (= 1 (count colls))\r\n                          (first colls)\r\n                          (apply interleave colls)))\r\n          allwordres (apply conj \r\n                            -spaces-bd \r\n                            (partition-all (count -spaces-bd) \r\n                                           (apply interleave2 -spaces-bd)))]    \r\n      (reduce #(or %1 %2) (map match? allwordres))))", "problem": 111, "user": "4f0da4e4535d0136e6c22319"}, {"code": "(fn fillWord[word matrix]\r\n  (let[l (count matrix),\r\n       w (.length (first matrix) ),\r\n       getVal (fn[x y]\r\n                 (.charAt (nth matrix y) x)\r\n                ),\r\n       seqlist (concat\r\n                   (for [x (range 0 w)]\r\n                    (apply conj []\r\n                       (for [y (range 0 l )]\r\n                          (getVal x y)     \r\n                               )\r\n                       )\r\n                    )\r\n                   (map seq matrix)\r\n                   ),\r\n        noSpace (fn[col]\r\n                  (filter\r\n                    #(not (or (= % \\space)\r\n                              (= % \\#)\r\n                          ) )\r\n                    col)\r\n                  ),\r\n        wordlength (.length word),\r\n        check (fn[col1 col2]\r\n               (let[a (first col1),\r\n                    b (first col2)]\r\n                 (cond (and (nil? a) (nil? b)) true\r\n                       (nil? a) false\r\n                       (nil? b) (every? #(not= \\_ %) col1)\r\n                       (and (not= a \\_) (not= a b) ) false\r\n                       :else (recur (rest col1)(rest col2))\r\n                  )\r\n                ) \r\n               )\r\n\r\n       ]\r\n      (true? (some #(check % (seq word) ) \r\n              (filter #(<= wordlength (count %))\r\n               (map noSpace seqlist)\r\n               )\r\n            ))\r\n  )\r\n)", "problem": 111, "user": "4f6d9d7ee4b07046d9f4efcd"}, {"code": "(fn [a b] (rand-nth [true false]))", "problem": 111, "user": "4f9597e0e4b0dcca54ed6cd4"}, {"code": "(fn [s coll]\n  (let [word (str \\# s \\#)\n        n (count word)\n        border [(repeat n \\#)]\n        board (concat border (map (fn [row] (filter #(not= \\space %) (str \\# row \\#))) coll) border)]\n    (not (empty? (filter (fn [place]\n                       (every? (fn [[p w]] (or (= p w) (and (= \\_ p) (not= \\# w))))\n                         (partition 2 (interleave place word))))\n               (mapcat #(partition n 1 %)\n                 (concat board\n                   (when (<= n (count board))\n                     (partition n (apply interleave board))))))))))", "problem": 111, "user": "4f969214e4b0dcca54ed6cdd"}, {"code": "(fn [a [b & r]]\n  (or (= b \"_ # _ _ e\")\n(and (= a \"joy\") (= b \"c _ _ _\")) (= b \"_ _ _ # j o y\"))\n  )", "problem": 111, "user": "4fa4e69ee4b081705acca1a8"}, {"code": "(fn [word grid]\n  (let [height (count grid)\n        horizontal (->> grid\n                        (map #(remove #{\\space} %))\n                        (map #(apply str %)))\n        vertical (->> (if (<= height 1)\n                        horizontal\n                        (apply interleave horizontal))\n                      (partition height)\n                      (map #(apply str %)))\n        words (mapcat #(clojure.string/split % #\"#\")\n                      (concat horizontal vertical))\n        character-match? #(or (= %1 %2) (= %1 \\_))\n        match? (fn [x]\n                 (and (= (count x) (count word))\n                      (every? true? (map character-match? x word))))]\n    (true? (some match? words))))", "problem": 111, "user": "4f8345c6e4b033992c121c1b"}, {"code": "(fn check [word table]\n            (let [table2 (map (fn [str] (remove #(= \\space %) str)) table)\n                 good-letter? (fn [[y x] [dy dx] n]\n                                   (let [l (nth (nth table2 (+ y (* n dy)) []) (+ x (* n dx)) nil)]\n                                        (println [x y] [dx dy] n l)\n                                        (or (= l (nth word n))\n                                            (= l \\_))))\n                  borders? (fn [[y x] [dy dx]]\n                               (->> [-1 (count word)]\n                                    (map #(nth (nth table2 (+ y (* % dy)) []) (+ x (* % dx)) :true))\n                                    (every? #{:true \\#})))\n                  good? (fn [pos dir] (println pos dir)\n                            (and (->> (range (count word))\n                                      (every? #(good-letter? pos dir %)))\n                                 (borders? pos dir)))\n                  dirs [[0 1] [1 0]]\n                  ]\n                  (println table2)\n                  (->> (for [y (range (count table2)) x (range (count (first table2)))] [y x])\n                       (some #(some (partial good? %) dirs))\n                       (boolean))))", "problem": 111, "user": "4f465096e4b0d56e7bb92b9a"}, {"code": "#(if (or (and (= % \"the\")\n              (= (first %2) \"c _ _ _\"))\n         (and (= % \"joy\")\n              (= (first %2) \"c o n j\")))\n   false true)", "problem": 111, "user": "4f9fe2b9e4b0dcca54ed6d40"}, {"code": "(fn crossword-puzzle [text-word partial-board]\r\n  (let\r\n    [word (vec text-word)\r\n     _ (println \"word\" word)\r\n     legal? (fn [spaces]\r\n              (every? #(#{ \\_ (get word %) } (get spaces %)) (range (count word))))              \r\n     board (vec (map (fn [row] (vec (filter #(not= \\space %) row))) (map vec partial-board)))\r\n     _ (println \"board\" board)\r\n     width (count (first board))\r\n     _ (println \"width\" width)\r\n     height (count board)\r\n     _ (println \"height\" height)\r\n     squares (for [i (range height) j (range width)] [i j])\r\n     _ (println \"squares\" squares)\r\n     word-len (count word)\r\n     _ (println \"word-len\" word-len)\r\n     value-at (fn [square] (get-in board square))\r\n     horiz-starts (filter (fn [[i j]]  \r\n                            (and (or (= j 0) (= \\# (value-at [i (dec j)])))\r\n                                 (let [after-j (+ j word-len)\r\n                                       _ (println \"j\" j)\r\n                                       _ (println \"after j\" after-j)]\r\n                                    (or (and (< after-j width) (= \\# (value-at [i after-j])))\r\n                                        (= after-j width))))) squares)\r\n     _ (println \"horiz starts\" horiz-starts)\r\n     vert-starts (filter (fn [[i j]]  \r\n                            (and (or (= i 0) (= \\# (value-at [(dec i) j])))\r\n                                 (let [after-i (+ i word-len)\r\n                                       _ (println \"i j\" i j)\r\n                                       _ (println \"after-i\" after-i)]\r\n                                    (or (and (< after-i height) (= \\# (value-at [after-i j])))\r\n                                        (= after-i height))))) squares)\r\n     _ (println \"vert starts\" vert-starts)\r\n     horiz? (some \r\n               (fn [[i j]]\r\n                 (let [space-locs (for [dj (range word-len)] [i (+ j dj)])\r\n                       _ (println \"space-locs\" space-locs)\r\n                       spaces (vec (map value-at space-locs))\r\n                       _ (println \"spaces\" spaces)\r\n                       _ (println \"legal?\" (legal? spaces))]\r\n                   (legal? spaces)))\r\n                       \r\n                horiz-starts)\r\n\r\n     vert? (some \r\n               (fn [[i j]]\r\n                 (let [space-locs (for [di (range word-len)] [(+ i di) j])\r\n                       _ (println \"space-locs\" space-locs)\r\n                       spaces (vec (map value-at space-locs))\r\n                       _ (println \"spaces\" spaces)\r\n                       _ (println \"legal?\" (legal? spaces))]\r\n                   (legal? spaces)))\r\n                       \r\n                vert-starts)]\r\n    (= true (or horiz? vert?))))", "problem": 111, "user": "4f036fb3535dcb61093f6ac8"}, {"code": "(fn [word, board]\n  (letfn [(patterns [[head & tail]]\n            (if tail\n              (for [h [head \\_] t (patterns tail)]\n                (cons h t))\n              [[head] [\\_]]))]\n    (let [matrix (vec (map (comp vec (partial remove #{\\space})) board))\n          height (count matrix)\n          width (count (first matrix))\n          horizontal-placeholders (mapcat (fn [s]\n                                            (map seq (clojure.string/split (apply str s) #\"#\")))\n                                          matrix)\n          vertical-placeholders (->> (for [x (range width) y (range height)]\n                                       (get-in matrix [y x]))\n                                     (partition height))\n          placeholders (concat horizontal-placeholders vertical-placeholders)]\n      (->> placeholders\n           (some (-> word patterns set))\n           nil?\n           not))))", "problem": 111, "user": "4f3fb586e4b0e243712b1f9c"}, {"code": "(fn [word rows]                                                                                      \n   (not (every? false? (map (fn crossword [row]                                                       \n                (letfn [(match[s] (every? true? (map #(or (= %1 %2)                                  \n                                                          (= \\_ %2)) word s)))]                      \n                  (let [N (count word)                                                               \n                        row (apply str (filter #(not= \\space %) row))                                \n                        chunks (clojure.string/split row #\"#\")                                       \n                        chunks (filter #(= (count %) N) chunks)                                      \n                        ]                                                                            \n                    (not (every? false? (map match chunks))))))                                      \n              (concat rows (map #(apply str %) (apply map vector rows)))))))", "problem": 111, "user": "4f1d1299535d64f603146487"}, {"code": "(fn can-be-placed [word puzzle]\n  (->>\n      (map #(remove #{\\space} %) puzzle)\n      (#(concat % (apply map list %)))\n      (mapcat #(partition-by #{\\#} %))\n      (remove #{[\\#]})\n      (map #(re-pattern (apply str (replace {\\_ \\.} %))))\n      (some #(re-matches % word))\n      boolean))", "problem": 111, "user": "4f725466e4b07046d9f4f030"}, {"code": "(fn [g b]\n  (let [b (map #(.replaceAll % \" \" \"\") b)]\n    (->>\n      (apply map list b)\n      (map #(apply str %))\n      (concat b)\n      (mapcat #(.split % \"#\"))\n      (filter #(= (count g) (count %)))\n      (some #(every? (fn [[a b]] (or (= a \\_) (= a b)))\n                     (map vector % g)))\n      true?)))", "problem": 111, "user": "4fb1d907e4b081705acca282"}, {"code": "(fn\n  [s g]\n  (let [r (for [r g] (for [l r :when (not= \\space l)] l))\n        c (apply map vector r)\n        all (mapcat #(partition-by #{\\#} %) (concat r c ))\n        all (filter #(= (count s) (count %)) all)]\n    (true? (some #(every? true? %)  (map #(map (fn [l r]  (or (= l r) (= \\_ r)) )   s %)  all)))))", "problem": 111, "user": "4e6dd0f5535d5021c1a895f3"}, {"code": "(fn [word _puzzle]\n  (let [puzzle (into [] (map (fn [x] (into [] (remove #(= \\space %) x))) _puzzle))\n\t\t  hashmarks (apply concat (for [row (range (count puzzle)) col (range (count (first puzzle)))\n\t\t  \t\t\t\t\t:let [itm (get-in puzzle [row col])] \n\t\t  \t\t\t\t\t:when (or (and (not= itm \\#) (or (= row 0) (= col 0))) \n\t\t  \t\t\t\t\t\t\t\t(= itm \\#))]\n\t\t  \t\t\t\t\t(if (= itm \\#) \n\t\t  \t\t\t\t\t\t[[(inc row) col 1 0] [row (inc col) 0 1]]\n\t\t  \t\t\t\t\t\t(if (= col 0) \n\t\t  \t\t\t\t\t\t\t[[row col 0 1]]\n\t\t  \t\t\t\t\t\t\t[[row col 1 0]]))))\n\t\t  get-line (fn get-line [row col rise run]\n\t          (lazy-seq \n\t            (let [curletter (get-in puzzle [row col] nil)]\n\t              (cond\n\t                (= nil curletter) '()\n\t                (= \\# curletter) '()\n\t                :else (cons curletter (get-line (+ row rise) (+ col run) rise run))))))\n\t\t  match (fn match [word mword]\n\t\t  \t(cond\n\t\t  \t\t(and (nil? word) (nil? mword)) true\n\t\t  \t\t(or (nil? word) (nil? mword)) false\n\t\t  \t\t(or (= (first word) (first mword)) (= (first mword) \\_)) \n\t\t  \t\t\t(match (next word) (next mword))\n\t\t  \t\t:else false))]\n\t\t  (not (not-any? identity (map #(match word %) (remove empty? (map #(apply get-line %) hashmarks)))))))", "problem": 111, "user": "4e7f5a0b535db966e863cc41"}, {"code": "(fn [w b]\n  (->> (map #(apply concat (partition-all 1 2 %)) b)\n    (#(concat (identity %)\n              (apply (partial map list) %)))\n    (mapcat (partial partition-by #(= % \\#)))\n    (filter #(not= (first %) \\#))\n    (keep #(if (= (count %) (count w))\n               (every? identity\n                 (map (fn [a b] (or (= a b) (= a \\_))) % w))))\n    (some identity)\n    (boolean)))", "problem": 111, "user": "4fd96694e4b05e33b9224f37"}, {"code": "(letfn [(char-ic= [c1 c2]\r\n          (= (Character/toLowerCase c1)\r\n             (Character/toLowerCase c2)))\r\n        (match? [s p]\r\n          (letfn [(m? [s p]\r\n                    (and (== (count s) (count p))\r\n                         (loop [s s\r\n                                p p]\r\n                            (cond\r\n                              (empty? s) true\r\n                              (or (char-ic= (first s) (first p))\r\n                                  (= (first p) \\_)) (recur (rest s) (rest p))\r\n                              :else false))))]\r\n            (some #(m? s %) (.split p \"#\"))))\r\n        (transpose [m]\r\n          (let [length (count (first m))]\r\n            (loop [n 0\r\n                   result []]\r\n              (if (>= n length)\r\n                  result\r\n                (recur (inc n)\r\n                       (conj result (apply str (map #(nth % n) m))))))))\r\n        (compress [s]\r\n          (apply str (re-seq #\"[^ ]\" s)))]\r\n  (fn can-fill-in? [word board]\r\n    (let [matcher #(match? word %)\r\n          board (into [] (map compress board))]\r\n      (true? (or (some matcher board)\r\n                 (some matcher (transpose board)))))))", "problem": 111, "user": "4fcc6cb3e4b0ee37620e1861"}, {"code": "(fn q111 [word coll]\n  (letfn [\n  \t(and2 [& coll]\n\t\t  (cond\n\t\t    (empty? coll) true\n\t\t    (false? (first coll)) false\n\t\t    :else (apply and2 (rest coll))))\n    \n\t\t(check [word line]\n\t\t  (let [cw (count word) cl (count line)]\n\t\t    (cond \n\t\t      (< cl cw) false\n\t\t      (apply and2\n\t\t             (or (= cw cl) (= \\# (get line cw)))\n\t\t             (map #(or (= % %2) (= %2 \\_)) word line)) true\n\t\t      :else\n\t\t      (let [ nline (drop-while #(not= % \\#) line) ]\n\t\t        (if (not= \\# (first nline)) false\n\t\t          (check word (rest line)))))))\n\n\t\t(transpose [coll]\n\t\t  (vec (apply map vector coll))) ]\n\n\t  (let [coll2 (map #(remove (partial = \\space) %) coll)]\n\t    (->>\n\t      (concat coll2 (transpose coll2))\n\t      (map #(check word %))\n\t      (some true?)\n\t      (#(if (true? %) true false))))))", "problem": 111, "user": "4fd22e70e4b04c3a95aa041c"}, {"code": "(fn crossword [word puzzle]\r\n    (let [w (count (first puzzle))\r\n          h (count puzzle)\r\n          word (str \\# word \\#)\r\n          board (into {} (apply concat (map-indexed (fn [y line] (map-indexed (fn [x c] [[x y] c]) (clojure.string/replace line \" \" \"\"))) puzzle)))\r\n          trymatch (fn [x y addx addy] \r\n                     (first (reduce \r\n                              (fn [[acc x y] wc] \r\n                                (let [bc (board [x y] \\#)] \r\n                                  [(and acc (or (and (= bc \\_) (not= wc \\#)) (= bc wc))) (+ x addx) (+ y addy)])) \r\n                              [true x y] word)))]\r\n      (boolean (some identity \r\n            (apply concat (map (fn [y] (map (fn [x] (or (trymatch x y 1 0) (trymatch x y 0 1))) (range -1 w))) (range -1 h))))\r\n      ))\r\n    )", "problem": 111, "user": "4feada56e4b0140c20fb9c11"}, {"code": "(fn [w p] \n  (let\n    [ pn (map #(apply str (replace {\\_ \\. \\  \"\"} %)) p)\n      pnt (apply map str pn)]\n  (not= []\n    (keep \n      #(re-matches (re-pattern %) w)\n      (mapcat \n        #(clojure.string/split % #\"#\")\n        (concat pn pnt))))))", "problem": 111, "user": "4f991ec1e4b0dcca54ed6cfb"}, {"code": "(fn [w b] (let [d (map #(take-nth 2 %) b)]\r\n(not (not-any? \r\n  (fn [x] (and (= (count w) (count x))\r\n               (reduce (fn [t [i j]] (and t (or (= j \\_) (= i j))))\r\n                       true (map vector w x))))\r\n  (mapcat (fn [y] (partition-by #(= % \\#) y)) (concat d (apply map vector d)))))))", "problem": 111, "user": "4fca2ef0e4b0ee37620e184e"}, {"code": "(fn[w l] (->>(map #(replace {\\space\"\"\\_\\.} %)l)\n             (#(concat % (apply map vector %)))\n             (mapcat #(.split(apply str %)\"#\"))\n             (some #(re-matches(re-pattern%)w))\n             boolean));(((((clojure  rocks)))))", "problem": 111, "user": "5003ee7de4b0678c553fc446"}, {"code": ";; Basic idea: Turn every \"potential placement spot\" in the crossword\n;; puzzle into a regexp, and if the word matches any of the regexes,\n;; return true.\n\n(fn [word board]\n  (let [across (map #(clojure.string/escape % {\\space \"\", \\_ \\.}) board)\n        down (apply map str across)]   ;; transpose the board so down becomes across\n    (string? (->> (concat across down)\n                  (mapcat #(clojure.string/split % #\"#\"))\n                  (some #(re-matches (re-pattern %) word))))))", "problem": 111, "user": "500d8c49e4b07ccb9a7ddb00"}, {"code": "(fn [w b]\r\n  (not (nil? (some #(re-find (re-pattern (str \"^(.*#)?[_\" (apply str (interpose \"][_\" w)) \"](#.*)?$\")) %)\r\n                   (#(concat % (apply map str %)) (map #(clojure.string/replace % \" \" \"\") b))))))", "problem": 111, "user": "500d1db4e4b05f7c30cfa69f"}, {"code": "(fn [w c]\n    (not (nil?\n           (let [C count\n                 M map\n                 c (M #(.replace % \" \" \"\") c)\n                 i (fn [[l & m]] \n                     (if l\n                       (or (some\n                             (fn [p]\n                               (and (= (C w) (C p))\n                                    (every? (fn [x] x)\n                                      (M #(#{\\_ %} %2) w p))))\n                             (seq (.split l \"#\")))\n                           (recur m))))]\n             (or (i c)\n                 (i (apply M str c)))))))", "problem": 111, "user": "4dc537fd535d8a4b2fd74282"}, {"code": "(fn [word initpuzzle]\n  (let [puzzlecore (map #(str \\# (apply str (remove (partial = \\space) %)) \\#) initpuzzle)\n        edge (apply str (repeat (count (first puzzlecore)) \\#))\n        clean (conj (into [edge] puzzlecore) edge)\n        transposed (into [] (for [i (range (count (first clean)))]\n                              (apply str (map #(get % i) clean))))\n        ok (fn [grid candidate] (or (= grid candidate)\n                                    (and (not= candidate \\#)\n                                         (= grid \\_))))\n        target (str \\# word \\#)\n        check (fn [grid y x]\n                (every? true? (map ok\n                                   (subs (get grid y) x (+ x (count target)))\n                                   target)))]\n    (if (some true? (for [grid [clean transposed]\n                          y (range (count grid))\n                          x (range (inc (- (count (first grid)) (count target))))]\n                      (check grid y x)))\n      true\n      false)))", "problem": 111, "user": "4fe8aef4e4b07c9f6fd12c6c"}, {"code": "(fn[w m] (let [f (fn[x y] \n                      (reduce #(and %1 \n                                    (or(and (= (first %2) (second %2)))\n                                    (= (second %2) \\_))\n                               ) \n                               true\n                               (map list x y)\n                      )\n               )\n               l (map #(clojure.string/replace % \" \" \"\") m)\n               v (map #(apply str %) (apply map list (map seq l)))\n               m (apply concat (map #(clojure.string/split % #\"#\") (concat l v)))\n               m (filter #(= (count %) (count w)) m)\n              ]\n              (reduce #(or %1 (f w %2)) false m)\n         )\n)", "problem": 111, "user": "5017eface4b02f523d7cc5e7"}, {"code": "(fn can-place-word? [word puzzle]\n  (letfn [(transpose [puzzle]\n            (map (fn [col]\n                   (map #(nth % col) puzzle)) (range (count puzzle))))\n          (char-match? [char puzzle-char]\n            (or (= puzzle-char \\_)\n                (= char puzzle-char)))\n          (pattern-match? [word pattern]\n            (if (empty? word)\n              true\n              (if (char-match? (first word) (first pattern))\n                (recur (rest word) (rest pattern)))))\n          (split-by-unusable [row this-part parts]\n            (if (empty? row)\n              (if (empty? this-part)\n                parts\n                (conj parts this-part))\n              (if (= (first row) \\space)\n                (recur (rest row) this-part parts)\n                (if (and (= (first row) \\#)\n                         (> (count this-part) 0))\n                  (recur (rest row) [] (conj parts this-part))\n                  (recur (rest row) (conj this-part (first row)) parts)))))]\n    (let [word-patterns (reduce into [] (into (map #(split-by-unusable % [] []) puzzle)\n                                              (map #(split-by-unusable % [] []) (transpose puzzle))))\n          word-length (count word)\n          possible-patterns (filter #(= (count %) word-length) word-patterns)]\n      (true? (some true? (map #(pattern-match? word %) possible-patterns))))))", "problem": 111, "user": "4ff355a1e4b0678c553fc34d"}, {"code": "(fn [w b]\n  (let [b (map (fn [row] (remove #(= % \\space) row)) b) ; remove whitespace\n        parts (fn [l] (remove #(= % '(\\#)) (partition-by #(= % \\#) l))) ; split a row/col in \"places\"\n        horiz-places (mapcat parts b) ; rows\n        vert-places (mapcat parts (for [x (range (count (first b)))] ; cols\n                                    (map #(nth % x) b)))\n        places (concat horiz-places vert-places)]\n    (boolean (some (fn [place] (and (= (count place) (count w))\n                                    (every? boolean (map #(or (= % %2) (= % \\_)) place w))))\n                   places))))", "problem": 111, "user": "500900dee4b0144d4f561e42"}, {"code": "(fn fits-in-puzzle?\n  [word board]\n  (let [interpose-str (partial apply map (comp (partial apply str) list))\n        unblocked (partial mapcat (comp seq\n                                        #(.split % \"#\")\n                                        #(.replaceAll % \" \" \"\")))\n         fuzzy-equal? (fn [s1 s2]\n                       (and (= (count s1) (count s2))\n                            (every? true? (map (fn [c1 c2]\n                                                 (or (= c1 c2)\n                                                     (= c1 \\_)\n                                                     (= c2 \\_)))\n                                               s1 s2))))]\n    (true? (some (partial fuzzy-equal? word)\n                 (concat (unblocked board)\n                         (unblocked (interpose-str board)))))))", "problem": 111, "user": "4dc0ff08535d020aff1edf84"}, {"code": "(fn [w b]\n  (let [rows (map #(remove #{\\space} %) b)\n        cols (partition (count b) (if (< 1 (count b)) (apply interleave rows) (first rows)))]\n    (->> (concat rows cols)\n      (mapcat #(partition-by #{\\#} %))\n      (remove #(not= (count w) (count %)))\n      (map    (fn [a] (map #(or (= \\_ %) (= % %2)) a w)))\n      (some   (fn [a] (reduce #(and % %2) a)))\n      boolean)))", "problem": 111, "user": "5028cd0fe4b01614d1633ffc"}, {"code": "(fn [word board]\n  (boolean \n    (->> (concat\n           (let [rows (count board), cols (count (first board))]\n             (map \n\t             (fn [c] (map (fn [r] (get-in board [r c])) (range 0 rows))) \n\t             (range 0 cols))\n\t           )\n           (map seq board))\n      (mapcat (fn [row] (.split (apply str row) \"#\")) ,,,)\n      (map    (fn [lst] (remove #(= % \\space) lst)) ,,,)\n      (filter (fn [cand] (== (count cand) (count word))) ,,,)\n      (some (fn [cand] \n\t            (loop [w (seq word), t cand]\n\t              (if (seq w)\n\t                (if (or (= (first w) (first t)) (= \\_ (first t)))\n\t                  (recur (rest w) (rest t))\n\t                  false)\n\t                true))) ,,,)\n      ))\n  )", "problem": 111, "user": "4dca8b6d535d5973398f9288"}, {"code": "(fn [word board] (let [\r\n  b     (map (partial filter #(not= % \\space)) board)\r\n  w     (count (first b))\r\n  cols  (for [i (range w)] (take-nth w (drop i (flatten b))))\r\n  rc    (mapcat (partial partition-by #(= % \\#)) (into b cols))\r\n  fits? (fn [t] (and (= (count word) (count t))\r\n          (not-any? nil? (map #(#{\\_ %} %2) word t))))]\r\n  (not (not-any? fits? rc))))", "problem": 111, "user": "50336c6be4b0c6c1199c710f"}, {"code": "(let [match-char (fn [c d] (or (= d \\_) (= d c)))]\n\n  (let [ \n  match-str \n  (fn [s p] \n    (and \n      (= (count s) (count p))\n      (reduce #(and % %2) (map match-char s p))))\n\n\n\nwords \n  (fn [t] (->> t\n    (map #(.replace % \" \" \"\"))\n    (#(concat % (apply map str %)))     \n    (map #(.split % \"#\"))\n    (apply concat)))]\n\n(fn [s t] (boolean (some #(match-str s %) (words t))))))", "problem": 111, "user": "503917a0e4b088a6a14ca763"}, {"code": "(fn [w p]\r\n  (let [rows (map #(.replace % \" \" \"\") p)\r\n        cols (apply map vector rows)\r\n        all (mapcat #(.split (apply str %) \"#\") (concat rows cols))\r\n        mtch (fn [a b]\r\n               (and (= (count a) (count b)) \r\n                    (every? true? (map #(or (= \\_ %2) (= % %2)) a b))))]\r\n    (= true (some true? (map #(mtch w %) all)))))", "problem": 111, "user": "4f58d92fe4b0a7574ea71858"}, {"code": "(fn crossword [w cw] ; crossword, word\r\n    (let\r\n      [cw-h (fn [w cw]\r\n              (let\r\n                [catted (apply str\r\n                                (interpose \\# cw))\r\n                 cleaned (filter #(not= \\space %) catted)\r\n                 splitted (partition-by #(= \\# %) cleaned)\r\n                 filtered (filter (fn [[x & xs]] (not= \\# x))\r\n                                   splitted)       \r\n                 check-w (fn [a b]\r\n                           (map #(and (= (count a) (count b))\r\n                                        (or (= % \\_) (= % %2))) a b))\r\n                 checked (map #(check-w % w) filtered)\r\n                 checked-words (map #(every? identity %) checked)\r\n                 ]\r\n                ;catted))\r\n                ;checked-words))\r\n                (some identity checked-words)))\r\n                  \r\n                       \r\n                          \r\n        cwt (map #(apply str %) (filter \r\n              (fn [[x & xs]] (not= x \\space))\r\n              (apply map vector cw)))\r\n                       \r\n       ]\r\n      ;(cw-h w cwt)))\r\n      ;cwt))\r\n      (boolean (or (cw-h w cw)\r\n          (cw-h w cwt)))))", "problem": 111, "user": "502a9fdee4b095a7adb898b4"}, {"code": "(fn [word board]\r\n  (let [board (vec (map #(apply str (remove (fn [x] (= \\space x))%)) board))\r\n        h (count board)\r\n        w (count (first board))\r\n        l (count word)]\r\n    (letfn [(G [pair] (get-in board pair \\#))\r\n            (HV [[i j] [y x]] (and (= \\# (G [(- y (* 1 i)) (- x (* 1 j))]))\r\n                                   (= \\# (G [(+ y (* l i)) (+ x (* l j))]))\r\n                                   (= l (count (for [k (range l)\r\n                                              :let [c (nth word k) now (G [(+ y (* k i)) (+ x (* k j))])]\r\n                                              :while (or (= \\_ now) (= c now))] 1)))))]\r\n      (if (some #(or (HV [0 1] %) (HV [1 0] %)) \r\n                (for [i (range h) j (range w)] [i j])) true false))))", "problem": 111, "user": "503354c3e4b0c6c1199c710c"}, {"code": "(fn cwp [w p]\n  (letfn [(get-at-pos [ x y cnt hor ] \n                      (for [ i (range cnt)]  \n                        (if hor (get-in p [ y (+ x (* 2 i) )])  \n                          (get-in p [ (+ y i)   x ]) )))\n          (ok? [f cand ] (or (nil? (f cand)) (= \\# (f cand))))\n          (matches? [cand] (let [ x (partition 2 (interleave cand w)) ]  \n                                  (every? (fn [[a b]] (or (= \\_ a) (= a b)) ) x) ))\n          ]\n         (let [cand  (for [x (range -2 (* 2 (count (first p))) 2) \n                           y (range -1 (count p) 1) dir '(true false ) ] \n                       (get-at-pos x y (+ 2 (count w)) dir))]\n           (->>\n             (filter (partial ok? last) cand)\n             (map butlast)\n             (filter (partial ok? first) )\n             (map rest)\n             (filter #(every? identity %) )\n             (filter matches?)\n             (not= '())             )\n           )))", "problem": 111, "user": "4fccdc75e4b0ee37620e186d"}, {"code": "(fn [w b] (let [rs (map (partial filter (partial not= \\space) ) b)\n               cs (apply (partial map list) rs)\n               patts (mapcat #(partition-by #{\\#} %) (concat rs cs))\n               match (fn [w p] (if (not= (count w) (count p)) false\n                      (every? identity (map #(or (= %1 %2) (= \\_ %2)) w p))))]\n         (boolean (some #(match w %) patts )) ))", "problem": 111, "user": "50563ae2e4b0ce54f56f0405"}, {"code": "(letfn [(columns [rows] (apply map str rows))\n        (lines   [rows] (concat rows (columns rows)))\n        (remove-white-spaces [s] (clojure.string/replace s #\"\\s\" \"\"))\n        (patterns [s] (re-seq #\"\\w+\" s))\n        (fit? [pattern word]\n          (and (= (count pattern) (count word))\n               (every? true?\n                       (map #(or (= %1 \\_) (= %1 %2)) pattern word))))]\n  (fn crossword-puzzle [word board]\n    (->> board\n         lines\n         (mapcat (comp patterns remove-white-spaces))\n         (some #(fit? % word))\n         boolean)))", "problem": 111, "user": "50586354e4b06522596eba78"}, {"code": "(fn crossword [word puzzle]\n  (letfn [(remove-spaces [row] (->> row (remove #(= \\space %)) (apply str)))\n\t\t    (merge-word [s1 s2] (map #(if (= \\_ %2) %1 %2) s1 s2))\n\t\t\t(fits-row [row]\n\t\t\t\t(let [spots (clojure.string/split row #\"\\#\") length (count word)]\n\t\t\t\t\t(reduce #(or %1 %2)\n\t\t\t\t\t\t(for [spot spots]\n\t\t\t\t\t\t\t(if (= (count spot) length)\n\t\t\t\t\t\t\t\t(= (seq word) (merge-word word spot))\n\t\t\t\t\t\t\t\tfalse\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)]\n\t(let [rows (map remove-spaces puzzle) \n\t      cols (map #(apply str %) (apply map (fn [& args] args) rows))]\n\t\t\t(or (reduce #(or %1 %2) (for [row rows] (->> row (fits-row))))\n\t\t\t\t(reduce #(or %1 %2) (for [col cols] (->> col (fits-row)))))\n\t)\n\t)\n)", "problem": 111, "user": "50588af1e4b06522596eba7d"}, {"code": "(fn match-crosswords [word crossword]\n  (let [cross (into crossword ((fn turn-strings [v]\n  (map #(clojure.string/join \" \" %1) ((fn turn [v]\n  (loop [turned [] r v c (count (first v))]\n  \t(if (< 0 c)\n\t\t\t(recur (conj turned (map first r)) (map rest r) (dec c))\n\t\t\tturned))) (map vec v)))) crossword))]\n\t\t(if (= 0 (count\n\t\t\t(filter (fn [v]\n\t\t\t\t((fn filter-match-crosswords [word v]\n  (let [w (clojure.string/replace word #\".\\B\" #(str %1 \" \"))\n  \tmatcher (clojure.string/replace (clojure.string/replace v #\"_\" \".\") #\" # \" \"|\")]\n\t\t(if (= nil (re-matches (re-pattern matcher) w))\n\t\t\tfalse\n\t\t\ttrue))) word v)) cross)))\n\t\t\tfalse\n\t\t\ttrue)))", "problem": 111, "user": "507bb3ece4b09034bfeeb720"}, {"code": "(fn [w cp]\n  (letfn\n\t\t[\n\t\t\t(flipped [m] (apply map list m))\n\t\t\t(regexps [cp]\n\t\t\t\t(set\n\t\t\t\t\t(map\n\t\t\t\t\t\tre-pattern\n\t\t\t\t\t\t(filter\n\t\t\t\t\t\t\t(comp not #{\"#\"})\n\t\t\t\t\t\t\t(map\n\t\t\t\t\t\t\t\t(partial apply str)\n\t\t\t\t\t\t\t\t(mapcat\n\t\t\t\t\t\t\t\t\t(comp\n\t\t\t\t\t\t\t\t\t\t(partial partition-by #{\\#})\n\t\t\t\t\t\t\t\t\t\t(partial replace '{\\_ \\.})\n\t\t\t\t\t\t\t\t\t\t(partial remove #{\\space})\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t(concat cp (flipped cp))\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t]\n\t\t(if (some identity (map #(re-matches % w) (regexps cp))) true false)\n\t)\n)", "problem": 111, "user": "507eddf4e4b06ce648bcdbfa"}, {"code": "(fn [w board]\n  (let [spaces\n          (mapcat\n            #(clojure.string/split % #\"#\")\n            (remove empty?\n              (map\n                #(clojure.string/replace % #\"\\s\" \"\")\n                (concat\n                  board\n                  (apply map str board)))))]\n    (or\n      (some\n        #(and\n           (= (count w) (count %))\n           (every?\n             (fn [[box l]] (or (= box \\_) (= box l)))\n             (map vector % w)))\n        spaces)\n      false)))", "problem": 111, "user": "504c8165e4b09724c857af31"}, {"code": "(fn[s m]\n(letfn [(split-hash [v] (let [[a b] (split-with (partial not= \\#) v)] [a (rest b)]))]\n  (let [hor (map (fn [s] (remove #(= \\space %) s)) m)\n        ver (apply map vector hor)\n        cnt (count s)]\n    (if (some (fn [v]\n                (if (= cnt (count v))\n                  (every? #(let [[a b] %]\n                             (or (= a \\_) (= a b)))\n                          (map #(vector %1 %2) v s))))\n              (mapcat split-hash (concat hor ver)))\n        true false))))", "problem": 111, "user": "4fdb02aae4b05e33b9224f56"}, {"code": "(fn [word b]\n  (let [board (map #(clojure.string/split % #\" \") b)\n        stepx (fn [[x y]] [(+ 1 x) y])\n        stepy (fn [[x y]] [x (+ 1 y)])\n        word-size (count word)\n        x-size (count (first board))\n        y-size (count board)\n        success? (fn [[x y lim step]]\n                   (every?\n                    (fn [[n [i j]]]\n                      (let [c (nth (nth board (+ y j) nil) (+ x i) nil)]\n                        (and c (nth word n nil)\n                             (or (= c (str (nth word n)))\n                                 (= c \"_\")))))\n                    (map list\n                         (take (max lim word-size) (iterate inc 0))\n                         (iterate step [0 0]))))]\n    (boolean\n     (some success?\n           (concat\n            (for [x (range x-size)]\n              [x 0 y-size stepy])\n            (for [y (range y-size)]\n              [0 y x-size stepx])\n            (mapcat\n             (fn [y]\n               (mapcat (fn [[i j]]\n                         (when (= \"#\" (nth (nth board j) i))\n                           [[(+ i 1) j (- x-size (+ i 1)) stepx]\n                            [i (+ 1 j) (- y-size (+ j 1)) stepy]]))\n                       (map #(list % y) (range x-size))))\n             (range y-size)))))))", "problem": 111, "user": "504f57c7e4b0a02f9cffde71"}, {"code": "(fn [word board]\n    (let [lines (for [l (concat board (apply map vector board))]\n                  (remove #{\\ } l))\n          potential-matches (->> lines\n                                 (mapcat #(partition-by #{\\#} %))\n                                 (map (fn [m] (map #(case %\n                                                     \\# (constantly false)\n                                                     \\_ (constantly true)\n                                                     #{% (Character/toUpperCase %)}) m))))]\n\n      (or\n       (first\n        (for [m potential-matches\n              :when (and (= (count word) (count m))\n                         (every? (fn [[p ch]] (p ch)) (map vector m word)))]\n          true))\n       false)))", "problem": 111, "user": "507056b8e4b07bd6ad9b9f29"}, {"code": "(fn [w cw]\n (let [rows (map (fn [a] (filter (fn [a] (not= a \\space)) (map char a))) cw)\n       cols (apply map vector rows)\n       both (concat rows cols)\n       size (filter (fn [x] (= (count w) (count x))) (mapcat (fn [a] (partition-by #(= \\# %) a)) both))\n       f (fn [xs] (every? (fn [[a b]] (or (= \\_ a) (= a b))) (map vector xs w)))]\n   (not (not-any? f size))))", "problem": 111, "user": "5097b556e4b00ad8bab4e970"}, {"code": "(fn [word rows]\n  (let [\n    pad (fn [word] (str \\# word \\#))\n    cmatch (fn [w r] (or (= w r) (and (not= w \\#) (= r \\_))))\n    wmatch \n      (fn [w]\n        (fn [r]\n          (when (>= (count r) (count w))\n            (or \n              (every? identity (map cmatch w r))\n              (recur (rest r))))))\n    srows (->> rows\n            (map (partial filter #(not= \\space %)))\n            (map (partial apply str)))\n    ]\n      (if \n        (some (wmatch (pad word))  \n          (map pad (concat srows (apply map str srows))))\n        true false)))", "problem": 111, "user": "50901b2ee4b0ea685a20f774"}, {"code": "(fn [word puzzle]\n  (let [cw (count word)\n        cp (count puzzle)\n        p' (vec (map (comp vec (partial filter #(not= % \\space))) puzzle))\n        count-p-inner (count (nth p' 0))\n        cps [cp count-p-inner]\n        f (fn [value] (mapcat (fn [index a] (for [inner-index (range (count a))\n                                   :when (= value (nth a inner-index))]\n                               [index inner-index]))\n                  (range) p'))\n        gets (fn [i akey] \n                (loop [way 0 result []]\n                  (cond (= 2 way) result\n                        (> i (akey way)) (recur (inc way) result)\n                        (> (- cw i) (- (cps way) (akey way))) (recur (inc way) result)\n                        (and (> (akey way) i) (not= \\# (get-in p' (assoc akey way (- (akey way) i 1))))) (recur (inc way) result)\n                        (and (> (- (cps way) (akey way)) (- cw i)) (not= \\# (get-in p' (assoc akey way (+ (akey way) (- cw i) 1))))) (recur (inc way) result)\n                        :else (recur (inc way) (conj result (vec (map #(get-in p' (assoc akey way %)) (range (- (akey way) i) (+ (- (akey way) i) cw)))))))))\n        test? (fn [s]\n               (not (contains? (set (for [index (range cw)\n                                    :let [r (or (= (s index) (nth word index)) (= (s index) \\_))]]\n                                    r)) false)))]\n    (loop [i 0]\n      (cond (= i cw) false\n            (contains? (set (map test? (mapcat (partial gets i) (f (nth word i))))) true) true\n            :else (recur (inc i))))))", "problem": 111, "user": "507fbd77e4b089ade05efbd3"}, {"code": "(fn [w c] (letfn [\n                      (despace [m] (map (fn [x] (filter #(not= \\space %1) x)) m))\n                      (to-regexps [lp] (map #( java.util.regex.Pattern/compile (.replace % \"_\" \".\")) lp) )\n                      (cols [m] (if (> (count m) 1) (flatten (interpose \\# (partition (count m) (apply interleave m)))) '()))\n                      (rows [m] (apply str (flatten (interpose \\# (despace m)))))               \n                      (all-patterns [m] (to-regexps (seq (.split #\"\\#\" \n                             (let [despaced (despace m)]\n                               (apply str (rows despaced) \\# (cols despaced)))))))\n                      ] \n                \n                (boolean (some #(re-matches %1 w) (all-patterns c)))))", "problem": 111, "user": "50956c2be4b087f34d351ab2"}, {"code": "(fn [word board]\n  (let [horizontal (map #(clojure.string/split % #\"\\s\") board)\n        spaces (->> (apply map vector horizontal)\n                    (concat horizontal)\n                    (map clojure.string/join)\n                    (map #(clojure.string/split % #\"\\#\"))\n                    flatten\n                    (map #(clojure.string/replace % #\"_\" \".\"))\n                    (map #(str \"^\" % \"$\"))\n                    (map re-pattern))]\n    (->> spaces\n         (some #(re-find % word))\n         nil?\n         not)))", "problem": 111, "user": "4f7f0827e4b06e829148e1d5"}, {"code": "(fn [word crossword]\n    (letfn [(words [s]\n              (-> (clojure.string/replace s #\" \" \"\")\n                  (clojure.string/split #\"#\")))\n            (match [w1 w2]\n              (cond (not= (count w1) (count w2))\n                    false\n                    \n                    (every? empty? [w1 w2])\n                    true\n\n                    :else\n                    (and (or (= \\_ (first w2))\n                             (= (first w1) (first w2)))\n                         (match (rest w1)\n                                (rest w2)))))\n            \n            ]\n      ;(some #(match word %) (words crossword)))) \n      (let [h-answers (mapcat words crossword)\n            v-answers (mapcat words\n                              (for [n (range 0 (count (first crossword)) 2)]\n                                (apply str (map #(nth % n) crossword))))\n            answers (into h-answers v-answers)\n            some? (comp not nil? some)]\n        (some? #(match word %) answers))))", "problem": 111, "user": "4daea889edd6309eace4d15b"}, {"code": "(fn solve-it [str ls]\n  (letfn [(is-equal? [s1 s2]\n            (and (= (count s1) (count s2))\n                 (loop [s1 s1 s2 s2]\n                   (if (empty? s1)\n                     true\n                     (let [sf1 (first s1)\n                           sf2 (first s2)]\n                       (if (= \\_ sf2)\n                         (recur (rest s1) (rest s2))\n                         (if (not= sf1 sf2)\n                           false\n                           (recur (rest s1) (rest s2)))))))))\n          (split-l [ls]\n            (lazy-seq \n             (let [[fs rs] (split-with #(not= \\# %) ls)]\n               (if (empty? rs)\n                 (list fs)\n                 (cons fs (split-l (rest rs)))))))\n          (transpose [ls]\n            (loop [an [] ls ls]\n              (if (empty? (first ls))\n                an\n                (recur (conj an (map first ls)) (map rest ls)))))\n          (split-lls [ls]\n            (concat (mapcat split-l ls)\n                    (mapcat split-l (transpose ls))))]\n    (let [k (some #(is-equal? str %) (split-lls (map (partial remove #(= \\space %)) ls)))]\n      (if k\n        true\n        false))))", "problem": 111, "user": "4dd62278535d2dad7130b5c7"}, {"code": "(fn [word xs]\r\n  (let [xs (for [x xs] (clojure.string/replace x #\"_\" \".\"))\r\n        xs (for [x xs] (apply str (filter #(not= % \\ ) x)))\r\n        rows (apply concat (map #(clojure.string/split % #\"#\") xs))\r\n        cols (apply concat (for [x (apply map list xs)]\r\n               (clojure.string/split (apply str x) #\"#\")))\r\n        [rows cols] (map \r\n                      (fn [x] (filter #(= (count word) (count %)) x))\r\n                      [rows cols])\r\n        go (fn [x] (boolean\r\n                      (some (complement empty?) \r\n                            (map #(re-seq (re-pattern %) word) x))))]\r\n    (or (go rows) (go cols))))", "problem": 111, "user": "509c03f3e4b085ae113522a8"}, {"code": "(fn crossword-puzzle [s puzzle]\n  (letfn [(transpose [b]\n            (apply map vector b))]\n    (let [reg-puzz (map (comp #(clojure.string/replace % #\"_\" \".\")\n                              #(clojure.string/replace % #\" \" \"\"))\n                        puzzle)\n          all-regs (map re-pattern\n                        (flatten                     \n                          (map #(clojure.string/split % #\"#\")\n                               (concat reg-puzz\n                                       (map #(apply str %) (transpose reg-puzz))))))]\n      (true? (some (partial = s) (map #(re-find % s) all-regs))))))", "problem": 111, "user": "50812debe4b01a93d3f38e4c"}, {"code": "(fn [r m s t]\n  (let [i (m #(r (r % \"_\" \".\") \" \" \"\") t)]\n    (boolean (some #(re-matches % s)\n                   (mapcat #(m re-pattern (clojure.string/split % #\"#\")) \n                           (concat i (apply m str i)))))))\nclojure.string/replace\nmap", "problem": 111, "user": "4e96557d535dbda64a6f6b43"}, {"code": "(fn [word grid]\n  (let [rows  (map #(->> % (remove #{\\space}) (apply str)) grid)\n        cols  (apply map #(apply str %&) rows)\n        words (for [word (into rows cols)] (clojure.string/split word #\"#\"))\n        check (fn [p w]\n                (if (= (count p) (count w))\n                  (->> w (map #(or (= %1 \\_) (= %1 %2)) p) (every? true?))\n                  false))]\n    (->> words\n         (reduce into #{})\n         (map #(check % word))\n         (every? false?)\n         not)))", "problem": 111, "user": "4f7431d2e4b044e54cd9a8f7"}, {"code": "(fn [word board]\n    (let [\n          remove-spaces (partial remove #{\\space})\n          downwards #(apply map vector %)\n          board (map remove-spaces board)\n          parse-available (fn [line ] (->> line\n                                           (partition-by #{\\#})\n                                           (remove #{'[\\#]})\n                                           (remove #(= 1 (count %)))))\n          all-clues (mapcat parse-available (concat board (downwards board) ))\n          fits? (fn [available]\n                  (and\n                   (= (count available) (count word))\n                   (every? true?\n                           (map (fn [needed possible]\n                                  (or (= \\_ possible) (= needed possible)))\n                                word available ))))]\n\n      (true? (some fits?\n                   all-clues))\n)\n    )", "problem": 111, "user": "4e6f578c535d5021c1a8961b"}, {"code": "(fn f [s puzzle]\n  (let [clean (fn [p]\n         (map (fn [x] (clojure.string/replace x #\" \" \"\")) p))\n\n        down (fn [p]\n          (apply map (fn [& r]  (apply str r)) (clean p)))\n\n        blanks (fn [s]\n          (re-seq #\"[^#]+\" s))\n\n        fits? (fn [b s]\n          (and\n            (= (count b) (count s))\n            (every? true? (map (fn [x y] (or (= x \\_) (= x y))) b s))))\n\n        p (clean puzzle)\n        all   (concat p (down p))\n        bs (mapcat (fn [x] (blanks x)) all)]  \n    (or (some (fn [x] (fits? x s)) bs) false)))", "problem": 111, "user": "50783762e4b0fc74642bff67"}, {"code": "(fn [word puzzle]\n    (let [rows (map (comp #(.split % \" \")) puzzle)]\n      (->> (concat rows (apply map vector rows))\n        (map #(apply str %))\n        (mapcat #(.split % \"#\"))\n        (filter #(= (count word) (count %)))\n        (map #(map (fn [c w]\n                     (if (= \\_ c)\n                       (str w)\n                       c)) % word))\n        (map #(apply str %))\n        (filter #(= word %))\n        empty?\n        not)))", "problem": 111, "user": "4f410b63e4b0e243712b1fc5"}, {"code": "(letfn [(norm [rows] \n            (let [rows (map #(apply str (remove #{\\ } %)) rows)]\n              {:rows (count rows) \n               :cols (count (first rows)) \n               :board (apply str rows)}))\n\n          (rows+cols [{:keys [rows cols board]}]\n            (map #(apply str %) (concat (partition cols board) (map #(take-nth cols (drop % board)) (range cols)))))\n\n          (make-regexps [words]\n            (->> \n              words\n              (mapcat #(clojure.string/split % #\"#\")) \n              (map #(clojure.string/replace % #\"_\" \".\"))\n              (map #(str \"^\" % \"$\"))\n              (map re-pattern)))\n\n          (solve [word board]\n            (->> board\n              norm\n              rows+cols\n              make-regexps\n              (some #(re-matches % word))\n              (= word)))] \n    solve)", "problem": 111, "user": "500aa15ee4b03d00572d2d76"}, {"code": "(fn [text board]\n    (let [board-x (/ (inc (count (first board))) 2)\n          board-y (count board)\n          tlen    (count text)]\n       (letfn [(in-board?[[x y]] (and (<= 0 x (dec board-x)) (<= 0 y (dec board-y))))\n               (board-elt[[x y]] (get-in board [y (* x 2)]))\n               (bound-p  [pos]   (or (not (in-board? pos)) (= (board-elt pos) \\#)))\n              ]\n         (or (some (fn [[x y :as pos]]\n                (or (and (in-board? pos) (in-board? [(+ x tlen -1) y])\n                         (bound-p [(+ x -1) y]) (bound-p [(+ x tlen) y])\n                         (every? (fn[i](get #{(get text i) \\_} \n                                             (board-elt [(+ x i) y])))(range tlen)))\n                    (and (in-board? pos) (in-board? [x (+ y tlen -1)])\n                         (bound-p [x (+ y -1)]) (bound-p [x (+ y tlen)])\n                         (every? (fn[i](get #{(get text i) \\_} \n                                             (board-elt [x (+ i y)])))(range tlen)))\n                    )) (for [x (range board-x) y (range board-y)] [x y])) false))))", "problem": 111, "user": "4f474f43e4b0d56e7bb92bb7"}, {"code": "(fn final [word col]\n  (letfn [(prepare [in-vector]\n            (into [] (map \n                       #(into [] (filter (fn[item] (not= item \\space)) (seq %))) \n                       in-vector)))\n          (tranpose [m]\n            (apply map vector m))\n          (try-to-put [line w prey]\n            (let [y (dec prey)\n                  word (str \\# w \\#)]\n              (every? true?\n                      (for [i (range (count word))]\n                        (let [word-char (.charAt word i)\n                              char (get line (+ y i) \\#)]\n                          (or \n                            (and (= char \\_) (not= word-char \\#))\n                            (= char word-char)))))))\n          (finl [word v]\n            (= true (some true? (mapcat (fn[line] (map \n                                                    #(try-to-put line word %) \n                                                    (range (count line))))\n                                        v))))]\n  (let [pre (prepare col)]\n    (or (finl word pre)\n        (finl word (tranpose pre))))))", "problem": 111, "user": "50e87427e4b0ebbe794eb7e8"}, {"code": "(let [\n cross-word (fn [w cw]\n  (some true? \n   (mapcat (fn [cwl]\n    (for [cand (filter #(and (= (count %) (count w)) \n                        (not= \\# (first %))) \n        (partition-by #(= \\# %) \n           (filter #(not= \\space %) cwl\n              )))\n        ]\n    (every? true? \n          (map #(or (= %1 %2) (= %2 \\_)) w cand\n )))) cw )))\n \n transpose (fn [cw]\n  (partition (count cw)\n   (for [y (range (count (first cw)))\n      x (range (count cw))\n      :when (not= \\space (get (cw x) y))\n      ] \n  (get (cw x) y)\n  )))       \n ]\n (fn [w cw]\n   (boolean \n    (or (cross-word w cw)\n        (cross-word w (transpose cw))))))", "problem": 111, "user": "50de11b2e4b061dbdced7217"}, {"code": "(fn [word puzzle]                                                                                                                                             \n  (letfn [(=_         [[x y]] (or (= x y) (= x \\_) (= y \\_)))                                                                                                 \n          (fits?      [gap] (and                                                                                                                              \n                             (= (count word) (count gap))                                                                                                     \n                             (every? =_ (map vector word gap))))                                                                                              \n          (separator? [c] (= c \\#))                                                                                                                           \n          (collapse   [xs] (filter (partial not= \\space) xs))                                                                                                 \n          (words      [xs]                                                                                                                                    \n            (filter (partial not= [\\#]) (partition-by (partial = \\#) xs)))                                                                                    \n          (transpose  [m] (apply map vector m))]                                                                                                              \n    (let [matrix (map collapse puzzle)                                                                                                                        \n          gaps (concat                                                                                                                                        \n                (apply concat (map words matrix))                                                                                                             \n                (apply concat (map words (transpose matrix))))]                                                                                               \n      (boolean (some identity (map fits? gaps))))))", "problem": 111, "user": "510c1dd5e4b078ea71921113"}, {"code": "(fn f [w r]\n  (let [c (map (fn [i] (apply str (map #(.charAt % i) r)))\n                       (filter #(= 0 (mod % 2)) (range (.length (first r)))))\n        l (mapcat #(clojure.string/split % #\"#\") \n                      (concat (map #(apply str (.replaceAll % \" \" \"\")) r) c))\n        m (fn [p] (and (= (count w) (count p)) \n                             (apply = true (map #(or (= % \\_) (= % %2)) p w))))]\n    (reduce #(or % %2) false (map m l))))", "problem": 111, "user": "4fa30027e4b081705acca187"}, {"code": "(fn [C A B k b]\n  (let [r (map #(remove #{\\space} %) b)\n        c (partition (C r) (if (> (C r) 1) (A interleave r) r))\n        rf (fn [r] (map #(re-seq #\"[^#]+\" (A str %)) r))\n        ps (flatten (concat (rf r) (rf c)))\n        match (fn [k p] (and (= (C k) (C p))\n                             (every? B (map #(#{\\_ %1} %2) k p))))]\n    (B (some #(match k %) ps))))\ncount apply boolean", "problem": 111, "user": "504e04a4e4b078edc5f59397"}, {"code": "(fn [word board]\n  (letfn [(squashed [line] (apply str (re-seq #\"\\S+\" line)))\n          (runs [line] (re-seq #\"[^#]+\" line))\n          (matches [run word]\n            (let [matched (map (fn [lr lw] (if (#{lw \\_} lr) true false)) run word)]\n              (and (= (count run) (count word))\n                   (= #{true} (into #{} matched)))))]\n    (let [rows (map squashed board)\n          cols (apply (partial map str) rows)\n          allplaces (concat rows cols)\n          allruns (mapcat runs allplaces)]\n      (or (some #(matches % word) allruns)\n          false))))", "problem": 111, "user": "4ffc10aae4b0678c553fc3d6"}, {"code": "(fn [word board]\n  (let [cleared-board (map #(reduce (fn [res ch] (if (= ch \\space) res (str res ch))) \"\" %) board)\n        boards (concat cleared-board (apply map str cleared-board))\n        crossword-strings (filter (fn [a] (= (count word) (count a))) (mapcat #(clojure.string/split % #\"#\") boards))\n        matches (map #(filter (fn [[a b]] (or (= a b) (= b \\_))) (map vector word %)) crossword-strings)]\n    (if (some #(= (count %) (count word)) matches) true false)))", "problem": 111, "user": "50ef9a7ae4b0bdaecbb47d9e"}, {"code": "(fn fits? [word puzzle]\n  (letfn [\n    (remove-spaces [s]\n      (clojure.string/replace s \" \" \"\"))\n    (horizontal-patterns [puzzle]\n      (lazy-seq\n       (when-let [row (first puzzle)]\n         (concat (map #(re-pattern (clojure.string/replace % \"_\" \".\"))\n                      (clojure.string/split (remove-spaces row) #\"#\"))\n                 (horizontal-patterns (rest puzzle))))))\n    (vertical-patterns [puzzle]\n      (let [transposed-puzzle (apply map str (map remove-spaces puzzle))]\n        (horizontal-patterns transposed-puzzle)))\n    (patterns [puzzle]\n      (concat (horizontal-patterns puzzle)\n              (vertical-patterns puzzle)))]\n    (if (some #(re-matches % word) (patterns puzzle))\n      true false)))", "problem": 111, "user": "4fe84c74e4b07c9f6fd12c3c"}, {"code": "(fn [s v]   \n    (let [cols (fn [m]\n                 (if (= 1 (count m)) []\n                   (into [] (map #(clojure.string/join %1) \n                                 (for [y (range (count (m 0)))] \n                                   (into [] (for [x (range (count m))]\n                                              (get (get m x) y)))))))),\n          t ((fn [s] (clojure.string/join (map #(str \"[_\" %1 \"]\") (rest (clojure.string/split s #\"\"))))) s),\n          re (re-pattern (str \"#\" t \"$|^\" t \"$|^\" t \"#\")),\n          m (into [] (map #(clojure.string/replace (reduce str %1) #\" \" \"\") v)),\n          cm (cols m)]\n        (not (empty?\n              (flatten (list\n                (for [s m]\n                    (into [] (re-seq re s)))\n                (for [s cm]\n                    (into [] (re-seq re s))))\n              )))))", "problem": 111, "user": "4f038567535dcb61093f6b0c"}, {"code": "(fn g [word board]\n  (let [board (into [] (map #(clojure.string/replace % #\" \" \"\") board))\n        W (count (first board))\n        H (count board)\n        try-place (fn [[y x] [dy dx] s]\n                    (let [t (get-in board [y x])\n                          c (first s)]\n                      (cond (nil? c) (or (nil? t) (= \\# t))\n                            (nil? t) false\n                            (or (= c t) (= \\_ t)) (recur [(+ y dy) (+ x dx)] [dy dx] (rest s)))))]\n    (true? (some true?\n                 (for [[dy dx] [[0 1] [1 0]]\n                       start-y (range H)\n                       start-x (range W)\n                       :let [prev (get-in board [(- start-y dy) (- start-x dx)])]\n                       :when (or (nil? prev)\n                                 (=\\# prev))]\n                   (try-place [start-y start-x] [dy dx] word))))))", "problem": 111, "user": "510acd6ee4b078ea719210f4"}, {"code": "(fn [w c]\n  (let [c (map #(clojure.string/replace % \" \" \"\") c)\n        p (re-pattern (str (reduce #(str %1 \"(\" %2 \"|_)\") \"(^|#)\" w) \"($|#)\"))\n        t (apply map str c)\n        s (fn [t] (some #(re-find p %) t))]\n    (if (or (s c) (s t)) true false)))", "problem": 111, "user": "50fbdacfe4b0d10d794c19f0"}, {"code": "(fn [word puzzle-strs]\r\n  (let [puzzle (map #(clojure.string/split % #\" \") puzzle-strs)]\r\n    (letfn [(subseqs [sq]\r\n              (partition-by #{\"#\"} sq))\r\n            (matches? [sq]\r\n              (and (= (count sq) (count word))\r\n                   (every? identity (map (fn [x y] (or (= (str x) y) (= y \"_\"))) word sq))))\r\n            (columns [m]\r\n              (apply map list m))\r\n            (patches []\r\n              (mapcat #(subseqs %) (concat puzzle (columns puzzle))))]\r\n      (boolean (some matches? (patches))))))", "problem": 111, "user": "4e8338d6535db62dc21a62d3"}, {"code": "(fn xword [x b]\n   (let [board (reduce #(into % (.split (.replace %2 \" \" \"\") \"#\")) \n                       [] (into b (apply map #(apply str %&) b)))\n         equivalent? #(or (= \\_ %2) (= % %2))\n         canfit? (fn [a] \n                   (and (= (count x) (count a))\n                        (not (some #(false? %)(map equivalent? x a)))))]\n     (reduce #(or % (canfit? %2) ) false board)))", "problem": 111, "user": "50e4f4e9e4b049a987753896"}, {"code": "(fn crossword-puzzle [word board]\n  (let [board (map (partial filter #(not= \\space %)) board)\n        vertical (loop [b board\n                        v []]\n                   (if (empty? (first b))\n                     v\n                     (recur (map rest b) (cons (map first b) v))))\n        vh (concat board vertical)\n        words (apply concat (map (partial partition-by #(not= % \\#)) vh))\n        final (filter #(not= [\\#] %) words)\n        same-size (filter #(= (count %) (count word)) final)\n        word (seq word)\n        comp-char (fn [a b] (if (or (= a b) (= a \\_) (= b \\_)) true false))\n        comp-word (fn [w1 w2]\n                    (loop [w1 w1\n                           w2 w2\n                           r []]\n                      (if (empty? w1)\n                        (every? true? r)\n                        (recur (rest w1) (rest w2) (cons (comp-char (first w1) (first w2)) r)))))\n        ]\n    (if (some true? (map (partial comp-word word) same-size))\n      true\n      false)))", "problem": 111, "user": "5123ac8ee4b061b4c6f0e0b1"}, {"code": "(fn [word board]\n  (let [\n        b (map (fn [r] (remove #(= \\space %) r)) board)\n        split-row (fn [row] (clojure.string/split (apply str row) #\"#\"))\n        fillable? (fn [s w]\n                    (and (= (count s) (count w))\n                            (= #{true} (set (map #(or (= % \\_) (= % %2)) s w)))))\n        board-fillable? (fn [word b]\n                          (some #(fillable? % word) (mapcat split-row b)) \n                          )\n        ] \n    (true? (or (board-fillable? word b) (board-fillable? word (apply map vector b))))))", "problem": 111, "user": "4fbbcf0ce4b081705acca2ee"}, {"code": "(fn [word board]\n  (let [board (->> board\n                (map #(re-seq #\"[^ ]\" %))\n                (map #(replace {\"_\" \".\"} %))\n                (map #(apply str %)))\n        board (->> (concat board (apply map str board))\n                 (mapcat #(split-with (comp not #{\\#}) %))\n                 (map #(replace {\\# \"\"} %))\n                 (map #(apply str %)))\n        board (->> board\n                (filter (comp not empty?))\n                (filter #(some #{\\.} %)))\n       \tboard (->> (set board)\n                 (map #(str \\^ % \\$))\n                 (map re-pattern))]\n    (not= nil (some #(re-find % word) board))))", "problem": 111, "user": "504e71cbe4b0f6ff3350c4b3"}, {"code": "(fn crossword-puzzle [word puzzle]\n  (let [h-slices (map #(vec (filter (complement #{\\space}) %)) puzzle)\n        v-slices (for [i (range (count (first h-slices)))]\n                   (map #(nth % i) h-slices))\n        slices (concat h-slices v-slices)\n        find-slots (fn [slice] (filter (fn [[first-cell & _]] (= first-cell \\_))\n                                       (partition-by #{\\#} slice)))\n        slots (filter #(= (count %) (count word)) (mapcat find-slots slices))\n        char-fits? (fn [cw cs] (or (= cs \\_) (= cw cs)))\n        word-fits? (fn [slot] (every? identity (map char-fits? word slot)))]\n    (if (some word-fits? slots) true false)))", "problem": 111, "user": "50d93c53e4b0fd36a4b89223"}, {"code": "(fn [word puzzle]\n  (letfn [(compact [puzzle]\n            (vec (for [line puzzle] (apply str (filter #(not= % \\space) line)))))\n          (rotate [puzzle]\n            (vec (apply map (fn [x & y] (apply str x y)) puzzle)))\n          (placable? [word target]\n            (and\n              (= (count word) (count target))\n              (every? true? (map #(or (= %1 %2) (= %2 \\_)) word target))))\n          (placable-line? [word line]\n            (some #(placable? word %) (clojure.string/split line #\"\\#\")))]\n    (not (nil? \n\t      (or\n    \t   (some #(placable-line? word %) (compact puzzle))\n       \t   (some #(placable-line? word %) (rotate (compact puzzle))))))))", "problem": 111, "user": "514721c6e4b0d520409ed392"}, {"code": "(fn [T C w c]\n  (coll? (re-seq (re-pattern\n    (apply str (flatten [\\^\\((interpose \\|(concat (map seq (C c)) (T (C c))))\\)\\$])))\n                 w)))\n(fn [m] (for [i (range (count (first m)))] (mapv #(nth % i) m)))\n(fn [c] (map (comp #(map (fn [x] ({\\_ \\. \\# \\|} x x)) %) #(remove #{\\ } %)) c))", "problem": 111, "user": "4ff67852e4b0678c553fc37e"}, {"code": "(fn cw [w s]\n  (let [m (fn [x y] (and (= (count x) (count y))\n                         (every? #{true} (map #(or (= %1 %2) (= %2 \\_)) (seq x) (seq y)))))\n        h (apply concat\n            (map (fn [x] (clojure.string/split x #\"#\"))\n              (map #(clojure.string/replace % #\" \" \"\") s)))\n        vv (apply map str (map #(clojure.string/replace % #\" \" \"\") s))\n        v (apply concat\n            (map (fn [x] (clojure.string/split x #\"#\"))\n              (map #(clojure.string/replace % #\" \" \"\") vv)))]\n    (cond \n      (some (fn [x] (m w x)) h) true\n      (some (fn [x] (m w x)) v) true\n      :else false)))", "problem": 111, "user": "4e14108c535d04ed9115e7dd"}, {"code": "(fn [word board]\n  (letfn [(fits [word spot]\n            (every? true?\n                    (map #(or (= % %2) (= \"_\" %2))\n                         (map str (seq word)) spot)))]\n    (let [spots (map #(clojure.string/split % #\" \") board)\n          spots (concat spots (apply mapv vector spots))\n          spots (reduce into [] (map (fn [x] (partition-by #(= \"#\" %) x)) spots))\n          spots (filter #(= (count %) (count word)) spots)]\n      (not (nil? (some #(fits word %) spots))))))", "problem": 111, "user": "512d3304e4b040332b905b2d"}, {"code": "(fn solve [clue crossword]\n  (let [cw-no-space               (map #(clojure.string/replace % #\" \" \"\") crossword)\n        lines                     (concat cw-no-space (apply map str cw-no-space))\n        words                     (mapcat #(clojure.string/split % #\"#\") lines)\n        clue-size-words           (filter #(= (count clue) (count %)) words )\n        possible-words            (filter #(re-find (re-pattern (clojure.string/replace % #\"_\" \".\")) clue) clue-size-words)\n        ]\n    \n    (not (empty? possible-words))))", "problem": 111, "user": "510cd1dde4b078ea71921124"}, {"code": "(fn [answer puzzle]\n  (letfn [(filled? [answer blank]\n            (if (not= (count answer) (count blank))\n              false\n              (every? (fn [[a b]]\n                        (or (= a b)\n                            (= b \\_))) (map vector answer blank))))\n          (blanks [puzzle]\n            (let [clean-puzzle (map #(clojure.string/replace % \" \" \"\") puzzle)]\n              (set (mapcat #(clojure.string/split % #\"#\")\n                           (map #(apply str %)\n                                (concat (map vec clean-puzzle)\n                                        (apply map vector clean-puzzle)))))))]\n    (not (empty? (filter #(filled? answer %) (blanks puzzle))))))", "problem": 111, "user": "512eb723e4b0b740abc5982b"}, {"code": "(fn [word grid]\n\t(let [grid-clean (map #(clojure.string/replace % #\"\\s\" \"\") grid)\n\t      extract-pattern (fn [s] (clojure.string/split \n\t\t\t\t\t(clojure.string/replace s #\"_\" \".\") \n\t\t\t\t\t#\"#\"))\n\t      transpose (fn tr [m] \n\t\t\t\t(cons (apply str (map first m))\n\t\t\t\t\t(if (> (count (first m)) 1)\n\t\t\t\t\t\t(tr (map rest m))\n\t\t\t\t\t\t[])))]\n\n\t\t(not (every? nil?\n\t\t\t(map\n\t\t\t\t#(re-matches (re-pattern %) word)\n\t\t\t\t(mapcat extract-pattern (concat grid-clean (transpose grid-clean))))))))", "problem": 111, "user": "5034b0e1e4b062bc5d7ae167"}, {"code": "(fn [word puzzle]\n  (let [puzzle (map #(clojure.string/replace % \" \" \"\")\n                    (map #(clojure.string/replace % \"_\" \".\")\n                         puzzle))\n        pat (re-pattern \n             (str \"^(\" (clojure.string/join\n                        \"|\"\n                        (mapcat #(clojure.string/split % #\"#\")\n                                (concat puzzle (apply map str puzzle))))\n                  \")$\"))]\n    (if (re-find pat word) true false)))", "problem": 111, "user": "519ef784e4b087743fad2198"}, {"code": "(fn [word board]\n  (letfn [(check-valid [word line]\n            (if (some #{\\#} line)\n              (true? (some true? (map #(check-valid word %) (re-seq #\"[^#]*\" (apply str line)))))\n              (if (= (count word) (count line))\n                (if (and (seq word) (seq line))\n                  (if (or (= \\_ (first line)) (= (first word) (first line)))\n                    (check-valid (next word) (next line))\n                    false)\n                  true)\n                false)))]\n    (let [non-space-board (map #(filter (fn [ch] (not= \\space ch)) %) board)]\n      (true? (some true? (mapcat\n                           (fn [ch]\n                             (map\n                               #(check-valid word %)\n                               (filter\n                                 #(or (some #{ch} %) (every? #{\\# \\_} %))\n                                 (concat non-space-board (apply (partial map (fn [& coll] coll)) non-space-board)))))\n                           word))))))", "problem": 111, "user": "514d7e29e4b019235f6c0587"}, {"code": "(fn cross [word brd]\n  (let [board (mapv #(vec (re-seq #\"\\S\" %)) brd)\n        transposed (apply mapv vector board)]\n    (not (empty? \n      (->> (into board transposed)\n           (mapcat (fn [xs] (partition-by #(= \"#\" %) xs)))\n           (remove #(= '(\"#\") %))\n           (filter #(= (count word) (count %))) \n           (filter (fn [xs]\n                     (loop [[chr & chrs] word [x & xs] xs]\n                       (cond \n                        (and (nil? x) (nil? chr)) true\n                        (or (= \"_\" x) (= x (str chr))) (recur chrs xs)\n                        :else false)))))))))", "problem": 111, "user": "50217818e4b00bba4502f7a7"}, {"code": "(fn [x g]\n  (let [g (for [s g]\n            (apply str\n                   (clojure.string/split s #\" \")))\n        g2 (for [i (range (count (first g)))]\n             (for [r g]\n               (nth r i)))]\n    (boolean (some identity\n          (for [g [g g2]\n                r g\n                w (clojure.string/split (apply str r) #\"#\")\n                :when (= (count w)(count x))]\n            (every? identity\n                    (for [i (range (count w))]\n                      (or (= (get w i) \\_)\n                          (= (get w i) (get x i))))))))))", "problem": 111, "user": "50a83315e4b054305ba5a830"}, {"code": "(fn [word board]\n  (let [board (map #(clojure.string/replace % #\" \" \"\") board)\n        lines (concat board (apply map vector board))\n        positions (mapcat #(re-seq #\"[^#]+\" (apply str %)) lines)\n        match? (fn [word place]\n                 (and (= (count word) (count place))\n                      (every? true? (map #(or (= % \\_)\n                                             (= % %2))\n                                        place\n                                        word))))]\n    (boolean (some #(match? word %) positions))))", "problem": 111, "user": "4ebaf790535dfed6da9c6d6e"}, {"code": "(fn crossword-puzzle [word board]\n  (let [m (count board) n (count (board 0))\n        rm (range m) rn (range n)\n        cw (count word)\n        char-at (fn [i j] (.charAt (board i) j))\n        rows (for [i rm] (apply str (for [j rn :let [c (char-at i j)] :when (not= c \\space)] c)))\n        colls (for [j rn] (apply str (for [i rm :let [c (char-at i j)] :when (not= c \\space)] c)))\n        words (->> (clojure.set/union rows colls) \n                   (mapcat #(clojure.string/split % #\"#\"))\n                   (filter #(> (count %) 1)))\n        can-be-placed? (fn [place]\n                         (let [can-write? (fn [from to] (or (empty? to)\n                                                            (let [f (first from) t (first to)]\n                                                              (when (or (= f \\_) (= f t)) (recur (next from) (next to))))))]\n                           (and (= (count place) cw) (can-write? place word))))]\n     (-> (some can-be-placed? words) boolean)))", "problem": 111, "user": "51729002e4b044b2ef48a850"}, {"code": "(fn solveable? [s puzzle]                                                          \n  (let [match? (fn [word puzzle-segment]                                             \n                    (if (not= (count word) (count puzzle-segment))                   \n                      false                                                          \n                      (every?                                                        \n                        true?                                                        \n                        (map #(or (= %1 %2) (= %2 \\_))                                                            (seq word) (seq puzzle-segment)))))                     \n        transpose (fn [m]                                                            \n                    (let [r (count m)                                                \n                          c (count (first m))]                                       \n                      (for [x (range c)]                                             \n                        (for [y (range r)]                                           \n                          (get-in m [y x])))))                                       \n        puzzle (vec (map #(clojure.string/replace % #\"\\s\" \"\") puzzle))               \n        puzzle-char (vec (map vec puzzle))                                           \n        puzzle-char-t (transpose puzzle-char)                                        \n        puzzle-t (vec (map #(apply str %) puzzle-char-t))                            \n        rl (count puzzle)                                                            \n        cl (count (first puzzle))                                                    \n        l (count s)                                                                  \n        rows-seg (apply concat (map #(clojure.string/split % #\"\\#\") puzzle))         \n        cols-seg (apply concat (map #(clojure.string/split % #\"\\#\") puzzle-t))       \n        segments (concat rows-seg cols-seg)]                                         \n    (if (nil? (some #(match? s %) segments))                                         \n      false                                                                          \n      true)))", "problem": 111, "user": "51899891e4b0288ada3dbdab"}, {"code": "(fn [w p]\n  (let [p (map #(-> %\n                    (.replaceAll \" \" \"\")\n                    (.replaceAll \"_\" \".\"))\n               p)\n        m (fn [z] (map re-pattern\n                                   (mapcat #(.split % \"#\")\n                                           z)))\n        hp (m p)\n        vp (m (apply map (comp #(reduce str \"\" %) vector) p))]\n    (if (some #(re-matches % w) (concat hp vp)) true false)\n    )\n  )", "problem": 111, "user": "4fa340b4e4b081705acca18c"}, {"code": "(fn [t x]\n    (let [b (map (partial apply str) (map #(remove (partial = \\space) %) x))\n          l (count t)\n          g (fn [m n]\n        (let [a (if (= n 0) \\# (nth m (- n 1)))\n              z (if (>= (+ n l) (count m)) \\# (nth m (+ n l)))]\n          (and\n            (= a z \\#)\n            (every? identity (map #(or (= % %2) (= % \\_)) (subs m n (+ n l)) t)))))\n          f (fn [o]\n        (some\n          identity\n          (map\n            #(some\n               identity\n               (for [i (range (inc (- (count %) l)))]\n                 (g % i)))\n            o)))]\n      (if\n        (or\n          (f b)\n          (f (apply map (fn [& d] (apply str d)) b)))\n        true\n        false)))", "problem": 111, "user": "51b3f109e4b0f094dd986fa9"}, {"code": "(fn [word iv]\n  (let [horiz (map #(.replace % \" \" \"\") iv)\n        vert (map (partial apply str) (apply map vector (map seq horiz)))\n        words (mapcat #(clojure.string/split % #\"#\") (concat horiz vert))\n        pwords (filter #(>= (count %) (count word)) words)\n        patterns (map #(re-pattern (.replace % \"_\" \".\")) pwords)]\n    (boolean (some #(re-find % word) patterns))))", "problem": 111, "user": "4f05ea25535dcb61093f6c02"}, {"code": "(fn [s b] (let [\nl (concat (map seq b)\n(for [i (range (count (first b)))]\n(map #(nth % i) b)))\nv (apply concat (map \n#(partition-by \n  (fn [x] (= \\# x)) \n   (remove (fn [y] (= \\space y)) %))\nl))  \nu (map #(map vector s %) \n(filter #(= (count %) (count s)) v))\nw (map \n(fn [z] (map second \n(remove #(apply = %) z))) u)] \n(if (some #(every? \n        (fn [k] (= k \\_)) %) w) true false)\n  ))", "problem": 111, "user": "517945dce4b0684c1c981a43"}, {"code": "(fn place? [s x] (let [\n    x0 (map #(str \"#\" (clojure.string/replace % \" \" \"\") \"#\") x)\n    sh (apply str (repeat (count (first x0)) \\#))\n    x1 (concat [sh] x0 [sh])\n    x2 (apply (partial map str) x1)\n    x3 (concat x1 x2)\n    sp (re-pattern (str \"#\" (apply str (map #(str \"[_\" % \"]\") s)) \"#\"))]\n    (boolean (seq (keep identity (map #(re-seq sp %) x3))))))", "problem": 111, "user": "51cbdee1e4b08d8387cbede1"}, {"code": "(letfn [(transpose [x]\n          (apply map str x))\n        (cleanup [x]\n          (map #(clojure.string/replace % \" \" \"\") x))\n        (play-find [s board]\n          (let [r (re-pattern (str \"(^|#)\"\n                                   (apply str (for [c s]\n                                                (format \"[%c_]\" c)))\n                                   \"($|#)\"))]\n            (some #(re-find r %) board)))\n        (crossword [s board]\n          (let [board (cleanup board)]\n            (boolean (or (play-find s board)\n                         (play-find s (transpose board))))))]\n  crossword)", "problem": 111, "user": "50b668dde4b08fb537db98f2"}, {"code": "(fn __ [s p]\n  (letfn [(row-pats [r]\n            (map #(clojure.string/replace % \"_\" \"\\\\w\")\n                 (->> (clojure.string/replace r \" \" \"\")\n                      (re-seq #\"[^#]*\")\n                      (remove empty?)))\n            )\n\n          (fits-row? [r]\n            (not (empty? (keep #(re-matches (re-pattern %) s) (row-pats r)))))\n\n          (rotate [p]\n            (for [i (range (count (first p)))]\n              (apply str (map #(nth % i) p)))\n            )\n\n          (check-h [p] (true? (some #(fits-row? %) p)))]\n    (or (check-h p) (check-h (rotate p)))))", "problem": 111, "user": "51b9d1f0e4b0e871ca49590b"}, {"code": "(fn [g s]\n  (let [p partial m map v vector c count r reduce o remove n into\n        f #(= #{true} (set (for [[i j] (m v % g)] (or (= i j) (= i \\_)))))\n        s (m (comp (p m first) (p partition-all 2 )) s)]\n    (r #(or % %2) \n       (m f (o #(not= (c %) (c g)) \n               (r n [] (m #(o (p = [\\#]) \n                              (partition-by (p = \\#) %)) \n                          (n s (apply m v s)))))))))", "problem": 111, "user": "512f06c5e4b0762be4c7aad7"}, {"code": "(fn [word board]\n  (let [rmws #(apply str (re-seq #\"\\S\" %)) \n        board (map rmws board)\n        vline (fn [n] (apply str (map #(nth % n) board)))\n        vlines (for [x (range (count (first board)))] (vline x))\n        moves (flatten (map #(clojure.string/split % #\"#\") (flatten (conj board vlines))))\n        rexmoves (map #(clojure.string/replace % #\"_\" \".\") moves)]\n    (not (nil? (some #(re-matches (re-pattern (str \"^\" % \"$\")) word) rexmoves)))))", "problem": 111, "user": "51f9b1d0e4b09be9c177e550"}, {"code": "(fn [w, ls]\n \t(let [lz (map #(apply str (remove #{\\space} %)) ls)\n \t\t  bd (concat lz (apply map str lz))\n \t\t  ws (mapcat #(clojure.string/split % #\"#\") bd)]\n\t(or (some \n\t\t#(and \n\t\t\t(every? \n\t\t\t\t(fn [[a,b]]\n\t\t\t\t (or\n\t\t\t\t  (= a b)\n\t\t\t\t   (= b \\_))) \n\t\t\t\t(zipmap w %)) \n\t\t\t(= (count w) (count %)))\n\t\tws) false)\n\t))", "problem": 111, "user": "4ec0c7ba535dfed6da9c6da4"}, {"code": "(fn [w puzzle]\n    (let [fit?  (fn [word section] (loop [[w & wrest :as wd] word\n                                         [s & srest] section]\n                                    (cond\n                                     (and (nil? w) (nil? s)) true\n                                     (or (nil? w) (nil? s)) false\n                                     (or (= w s) (= s \\_)) (recur wrest srest)\n                                     (= s \\space) (recur wd srest)\n                                     (= s \\#) (recur word srest)\n                                     :else false)))\n          sections (concat puzzle (apply map vector puzzle))]\n\n      (if  (some identity (map #(fit? w %) sections) ) true false)\n      ))", "problem": 111, "user": "5124619ae4b02c3f2a072ccd"}, {"code": "(fn [word board]\n  (let [pattern (re-pattern (apply str (map #(str \"[\" % \"_]\") word)))\n        board (map #(clojure.string/replace % \" \" \"\") board)]\n    (->> (concat board (apply map str board))\n         (mapcat #(clojure.string/split % #\"#\"))\n         (some #(re-matches pattern %))\n         boolean)))", "problem": 111, "user": "507b7dbee4b09034bfeeb71e"}, {"code": "(fn [word board]\n           (let [board (map #(clojure.string/replace % \" \" \"\") board)\n                 place (fn [w s]\n                         (loop [wrd w\n                                s s\n                                acc \"\"]\n                           (if (empty? wrd)\n                             (and (= w acc) (empty? s))\n                             (recur (rest wrd)\n                                    (rest s)\n                                    (str acc (if (not= \\_ (first s))\n                                               (first s)\n                                               (first wrd)))))))\n                 v-board (loop [board board\n                                acc []]\n                           (if (every? empty? board)\n                             acc\n                             (recur (map #(apply str (drop 1 %)) board)\n                                    (conj acc (reduce str (map first board))))))\n                 candidates (remove empty? (flatten (map #(clojure.string/split % #\"#\")\n                                                         (if (every? string? v-board)\n                                                           (into board v-board)\n                                                           board))))]\n             (true? (some true? (map #(place word %) candidates)))))", "problem": 111, "user": "50a5b7e9e4b0aa96157e2610"}, {"code": "(fn [ w g ]\n        (let [ find-pattern-in-line \n                (fn [ l ]\n                (partition-by (partial = \\#) (filter (partial not= \\ ) l)))\n               get-vertical-lines\n                (fn [ g ]\n                    (apply (partial map (comp concat str)) g)\n                )\n               all-lines (concat g (get-vertical-lines g))\n               all-patterns (mapcat find-pattern-in-line all-lines)\n               matches-pattern? \n                (fn [ [p & ps :as pattern] [a & as :as w] ]\n                    (cond\n                        (and (empty? w) (empty? pattern)) true ;; fully consumed\n                        (or  (empty? w) (empty? pattern)) false\n                        (= \\# p) false\n                        (= \\_ p) (recur ps as)\n                        (= a  p) (recur ps as)\n                        :else false))\n                debug-matches-pattern?\n                    (fn [p w]\n                        (if (matches-pattern? p w)\n                        (do (println \"matched \" p) true)\n                        false))]\n        (println all-patterns)\n        (reduce #(or %1 (debug-matches-pattern? %2 w)) false all-patterns)))", "problem": 111, "user": "51f59607e4b0abb92f97f9d5"}, {"code": "(fn crossword? [word board]\n  (letfn [(putable? [s1 s2]\n                    (and (= (count s1) (count s2))\n                         (every? true? (map #(or (= %1 %2) (= %2 \\_)) s1 s2))))\n          \n          (crosswordable? [word line] ;yay english\n                          (some (partial putable? word) (clojure.string/split (clojure.string/replace line \" \" \"\") #\"#\")))]\n  (let [lines (concat \n               board\n               (map (partial apply str) (apply map vector board)))]\n    (boolean (some (partial crosswordable? word) lines)))))", "problem": 111, "user": "5054bc87e4b0b1b9d1860eb0"}, {"code": "(fn [s b]\n  (let [r (clojure.string/join \" \" (map (partial format \"[%s|_]\") s))\n        p (java.util.regex.Pattern/compile\n            (str \"# \" r \" #|# \" r \"$|^\" r \" #|^\" r \"$\"))\n        f (fn [xs] (map (partial re-seq p) xs))\n        legal? (fn [xs] (not (empty? (filter seq (f xs)))))]\n    (or\n      (legal? b)\n      (legal? (apply map\n                (comp (partial clojure.string/join \" \") str)\n                b)))))", "problem": 111, "user": "5201572be4b0d7096e99ddbb"}, {"code": "(let [\n  match (fn match [sa sb] \n            (if-not sb\n              (if-not sa \n                true\n                (if (= \\# (first sa))\n                  true\n                  false))\n              (if (or (= (first sa) \\_) (= (first sa) (first sb)))\n                (recur (next sa) (next sb))\n                false)))\n  fun (fn [string strings]\n    (true? \n      (some \n        #(match (.trim %) string) \n        (for [s (map #(str \"# \" %) strings)\n          i (range (dec (count s)))\n              :when (= \\# (.charAt s i))]\n          (subs s (inc i))))))]\n  (fn [string strings]\n    (or (fun string (map #(apply str (remove (fn [c] (= \\space c)) %)) strings))\n      #_(println (count (first strings)))\n      (fun string\n        (for [i (range (count (first strings))) :when (even? i)]\n          (apply str (map #(.charAt % i) strings)))))))", "problem": 111, "user": "520242bae4b030ee0c5b26e3"}, {"code": "(fn [word puzzle]\n  (let [rows (map (partial take-nth 2) puzzle)\n        cols (take-nth 2 (apply map list puzzle))\n        slots (mapcat #(partition-by (partial = \\#) %) (concat rows cols))\n        match-char (fn [pc wc] (if (or (= pc \\_) (= pc wc)) true false))\n        test-fit (fn [ps ws] (and (= (count ps) (count ws)) (not-any? false? (map match-char ps ws))))]\n    (if (some true? (map #(test-fit % word) slots)) true false)))", "problem": 111, "user": "52015698e4b0d7096e99ddba"}, {"code": "(fn [w p]\n  (let [sm (map #(replace {\\space \"\" \\_ \\.} %) p)\n        co (apply map list sm)\n        pl (mapcat #(take-nth 2 (partition-by #{\\#} %)) (concat sm co))]\n    (boolean (some #(re-matches (re-pattern (apply str %)) w) pl))))", "problem": 111, "user": "5032b066e4b00c0952a257ea"}, {"code": "(fn [word c]\n  (let [c1 (map #(clojure.string/replace % \" \" \"\") c)]\n    (->> c1\n         (apply map str)\n         (concat c1)\n         (mapcat #(clojure.string/split % #\"#\"))\n         (map #(clojure.string/replace % \"_\" \".\"))\n         (filter #(= (count word) (count %)))\n         (map re-pattern)\n         (map #(re-find % word))\n         (reduce #(or (boolean %2) %1) false))))", "problem": 111, "user": "514c2d05e4b02b8cbb2a9278"}, {"code": "(fn [s xw]\n  (let [r (re-pattern (str (reduce #(str % \\[ %2 \"_] *\") \"# *\" s) \\#))\n        xw (map #(str \\# % \\# ) (into xw (apply map str xw)))]    \n    (not= nil (some #(re-seq r %) xw))))", "problem": 111, "user": "522b922ee4b0d34ee08e71c3"}, {"code": "(fn [t bd]\n  (let [bd (map #(.replace % \" \" \"\") bd)\n        cols (apply map str bd)\n        bd (mapcat #(.split (apply str %) \"#\") \n                   (concat cols bd))\n        g #(every? true? \n            (map (fn [a b] (or (= a b) (= b \\_))) t %))]\n    (boolean \n     (some true? \n      (map \n       #(and (g %) (= (count t) (count %)))\n       bd)))))", "problem": 111, "user": "51944aaae4b0142f60b4aedc"}, {"code": "(fn fits? [word grid]\n    (letfn [(transpose [grid] (apply mapv str grid))\n            (strip [grid] (map #(clojure.string/replace % #\" \" \"\") grid))\n            (sequences [row] (clojure.string/split row #\"#\"))\n            (fit-sequence? [word sequence]\n                (loop [word word\n                       grid-seq sequence]\n                   (cond (and (empty? word) (empty? grid-seq)) true\n                         (empty? word) false\n                         (empty? grid-seq) false\n                         :else (let [fw (first word)\n                                     fg (first grid-seq)]\n                                 (if (or (= fw fg)\n                                         (= fg \\_))\n                                     (recur (rest word) (rest grid-seq))\n                                     false)))))\n            (fit-row? [word row]\n                (boolean (some #(fit-sequence? word %) (sequences row))))\n            (fit-rows? [word rows]\n                (boolean (some #(fit-row? word %) rows)))]\n        (or (fit-rows? word (strip grid))\n            (fit-rows? word (transpose (strip grid))))))", "problem": 111, "user": "5165a235e4b079ad97ec44ac"}, {"code": "(fn [w b]\n  (let [cb (map (partial filter (partial not= \\space)) b)\n        wl (filter #(and (= (count w) (count %)) (not= \\# (first %))) \n                   (mapcat (partial partition-by (partial = \\#)) \n                           (concat cb (apply map list cb))))]\n    (boolean (some (fn [pw] (not (some false? \n                                       (map #(or (= %1 %2) (= \\_ %2)) \n                                            w pw)))) wl))))", "problem": 111, "user": "5246e945e4b0644eb7b0783b"}, {"code": "(fn [word board] \n  (let [rotated (apply (partial map list) board)\n        places (mapcat #(partition-by #{\\#} (remove #{\\space} %)) (concat board rotated))]\n    (->> places \n      (filter #(= (count %) (count word)))\n      (filter #(every? true? (map (fn [a b] (or (= a b) (= \\_ b))) word %)))\n      (empty?)\n      (not))))", "problem": 111, "user": "524be8e0e4b09eba1c0223f1"}, {"code": "(fn crossword [w board]\n  (let [rows (vec (map #(clojure.string/split % #\" \") board))\n        cols (apply map vector rows)\n        slots (mapcat #(partition-by (fn [x] (= x \"#\")) %) (concat rows cols))\n        n (count w)\n        usable (filter #(= n (count %)) slots)\n        fits (fn [slot]\n               (let [vs (vec slot)]\n                 (every? identity (for [i (range n)]\n                   (or (= (get vs i) \"_\") (= (get vs i) (str (get w i))))))))]\n    (not-every? false? (map fits usable))))", "problem": 111, "user": "4fbd12a5e4b081705acca2fd"}, {"code": "(fn [w x]\n  (let\n    [ws (map #(.replaceAll %1 \"[^&a-z_]\" \"\") (flatten (map #(seq (.split %1 \"#\")) x)))\n     x2 (map #(apply str %) (apply mapv vector x))\n     ws2 (map #(.replaceAll %1 \"[^&a-z_]\" \"\") (map #(if (nil? %1) \"\" %1) (flatten (map #(seq (.split %1 \"#\")) x2))))\n     mm (fn [s] (if (= (count s) (count w))\n                  (reduce #(and %1 %2) (map #(or (= \\_ (nth s %1)) (= (nth s %1) (nth w %1))) (range (count w))))\n                  false\n                  ))]\n    (or\n     (reduce #(or %1 %2) (map mm ws))\n     (reduce #(or %1 %2) (map mm ws2)))))", "problem": 111, "user": "52586d24e4b0cb4875a45cb0"}, {"code": "(fn [w board]\n  (let [board-rows (map #(.replaceAll % \" \" \"\") board)\n        board-cols (map (partial apply str) (apply (partial map list) board-rows))\n        possibilities (->> (mapcat (partial partition-by #(= \\# %)) (concat board-rows board-cols))\n                           (filter #(not= '(\\#) %))\n                           (map (partial apply str))\n                           (map #(.replaceAll % \"_\" \".\"))\n                           (map re-pattern))]\n    ((complement nil?) (some #(re-matches % w) possibilities))\n    )\n  )", "problem": 111, "user": "5141abf1e4b02fd87f5064c3"}, {"code": "(fn [s board]\n  (letfn [(slots [line]\n            (remove clojure.string/blank? (clojure.string/split line #\"#\")))\n          (matcher [slot]\n            (re-pattern (str \"^\" (clojure.string/escape slot {\\ \"\" \\_ \".\"}) \"$\")))\n          (check-lines [s lines]\n            (for [line lines\n                  slot (slots line)]\n              (re-find (matcher slot) s)))\n          (flip [lines] (apply map str lines))]\n    (or\n      (not-every? nil? (check-lines s board))\n      (not-every? nil? (check-lines s (flip board))))))", "problem": 111, "user": "525431dfe4b0541d1855b970"}, {"code": "(fn  [word matrix]\n          (let [remove-spaces      (fn [matrix]\n                                     (map #(clojure.string/replace % \" \" \"\") matrix))\n                transpose          (fn [matrix]\n                                     (apply map str matrix))\n                make-pattern       (fn [word]\n                                     (re-pattern\n                                      (apply str\n                                             (concat \"(^|#)\"\n                                                     (map #(str \"(_|\" % \")\") word)\n                                                     \"(#|$)\"))))\n                matrix (remove-spaces matrix)\n                transposed (transpose matrix)\n                pattern (make-pattern word)]\n            (not (nil?\n                  (or (some #(re-find pattern %) matrix)\n                      (some #(re-find pattern %) transposed))))))", "problem": 111, "user": "5164867fe4b003cf19fdde3e"}, {"code": "(fn [word board]\n  (let [board' (map (fn [row] (filter (partial not= \\space) row)) board)\n        word-holders (fn [row] (remove #(= (first %) \\#) (partition-by (partial = \\#) row)))\n        fit (fn [word holder]\n              (prn word holder)\n              (and\n               (= (count word) (count holder))\n               (every? identity (map #(or (= %1 %2) (= %2 \\_))\n                                     word\n                                     holder))))\n        ]\n    (or (some #(fit word %) (concat (mapcat word-holders  board')\n                                (mapcat word-holders\n                                        (map (fn [n] (map #(nth % n) board'))\n                                             (range 0 (count (first board'))))))) false)))", "problem": 111, "user": "524cdd51e4b0752c4cb68ccc"}, {"code": "(fn crossword [word puzzle]\n  (let [cleanup (fn [puzzle] (vec (map #(.replaceAll % \"\\\\s+\" \"\") puzzle)))\n        columns (fn [puzzle] (let [p (cleanup puzzle) rows (count p) cols (count (first p))]\n\t\t                          (map #(apply str (map (fn [i] (get-in p [i %])) (range 0 rows))) (range 0 cols))))\n        lines (fn [puzzle] (let [p (cleanup puzzle)  c (columns p) ]\n\t(concat p c)))\n        places (mapcat #(clojure.string/split % #\"#\") (lines puzzle))\n        res (map #(.replaceAll % \"\\\\_\" \".\") places)\n\t\tmatches (map #(re-matches (re-pattern %) word) res)] \n\t\t(if (some identity matches) true false)))", "problem": 111, "user": "523a9fc9e4b081681ca7adca"}, {"code": "(fn filter-possible-matches [word coll]\n  (let [filter-func\n          (fn [space]\n            (and (= (count space) (count word))\n                 (every? #(or (= (first %) (second %)) (= (second %) \\_)) \n                         (apply map vector [word space]))))\n        hori\n          (mapcat \n            #(clojure.string/split (clojure.string/replace % #\"\\s\" \"\") #\"#\")\n            coll)\n        vert \n          (mapcat \n            #(clojure.string/split % #\"#\") \n            (apply map str (map #(clojure.string/replace % #\"\\s\" \"\") coll)))\n        pmatches (filter filter-func (concat hori vert))]\n    (boolean (seq pmatches))))", "problem": 111, "user": "52463059e4b09dbe66b56198"}, {"code": "(fn [w g]\n   (let [wlen (count w)\n         t (map #(clojure.string/replace % #\"\\s+\" \"\") g)]\n     (true? (some (fn [cw]\n                    (and (= (count cw) wlen)\n                      (every? identity (map #(or (= % \\_) (= % %2)) cw w))))\n              (flatten (map #(clojure.string/split % #\"#\")\n                         (into t (apply map str t))))))))", "problem": 111, "user": "51f66e0ee4b06ff1c25c52c3"}, {"code": "(fn [w v]\n  (let [fits? (fn [s h]\n                (if (=  (count s) (count h))\n                  (reduce #(and %1 %2)\n                          (for [i (range 0 (count s))]\n                            (or (= (nth s i) (nth h i)) (= (nth h i) \\_)))) false))\n        vs (map (fn [s] (filter #(not= % \\space) s)) v)]\n    (reduce #(or %1 %2)\n            (map #(fits? w %)\n                (flatten (map #(clojure.string/split (apply str %) #\"#\")\n                         (concat vs (for [i (range 0 (count (first vs)))]\n                             (map #(nth % i) vs)))))))))", "problem": 111, "user": "50bce014e4b0594b91591c63"}, {"code": "(fn p111 [w splst0]\n  (let [splst (map #(.replace % \" \" \"\") splst0)\n        flds0 (concat splst (for [i (range (apply max (map count splst)))] (apply str (map #((zipmap (range) (char-array %)) i) splst))))\n        flds (map re-pattern (reduce (fn [a bs] (concat a (map #(.replace % \"_\" \".\") bs))) [] (map #(.split % \"#\") flds0)))\n        rt (some true? (map #((complement nil?) (re-matches (re-pattern %)  w)) flds))\n        ]\n    (if rt true false)\n    )\n  )", "problem": 111, "user": "5272669de4b03e8d9a4a742e"}, {"code": "(fn [input board]\n  (let [theinput (concat \"#\" input \"#\")\n        theboard (into [] (map (comp (partial into []) (partial filter #(not= % \\space))) board))\n        getboardslices (fn getboardslices [l]\n                         (apply concat (map (fn [y]\n                                              (apply concat (map (fn [x]\n                                                                   [(map #(get-in theboard [(+ y %) x] \\#) (range l))\n                                                                    (map #(get-in theboard [y (+ x %)] \\#) (range l))\n                                                                    ])\n                                                                 (range -1 (inc (count (first theboard)))))))\n                                            (range -1 (inc (count theboard))))))\n        matches? (fn matches? [a b]\n                   (if (empty? a) true\n                     (if (or (= (first a) (first b)) (and (= (first b) \\_) (not= (first a) \\#)))\n                       (matches? (rest a) (rest b))\n                       false)))\n        ]\n    ((comp not nil?) (some (partial matches? theinput) (getboardslices (count theinput))))))", "problem": 111, "user": "513b77f3e4b00f740c76c403"}, {"code": "(fn can-place [word board]\n  (let [partial-line-words (fn [line] (->> (filter #(not= % \\space) line)\n                                           (partition-by #(= % \\#))\n                                           (filter #(not= % '(\\#)))\n                                           (map #(apply str %))))\n        partial-words (flatten (vector (map partial-line-words board)\n                                       (map #(apply str %) (apply map vector (flatten board)))))\n        candidate (fn [partial-word] (and (= (count word) (count partial-word))\n                                          (->> (map vector word partial-word)\n                                               (drop-while #(or (= (second %) \\_) (apply = %)))\n                                               (empty?))))\n        candidates (filter #(candidate %) partial-words)]\n      (not (empty? candidates))\n    )\n)", "problem": 111, "user": "5272d4b7e4b03e8d9a4a7453"}, {"code": "(fn [w b]\n    (let [mapcat-idxd   (comp (partial apply concat) map-indexed)\n          ib            (apply sorted-map (mapcat-idxd\n                                            (fn [i r] (mapcat-idxd (fn [j c] [[i j] c])\n                                                                   (filter (partial not= \\space) r)))\n                                            b))\n          starts        (mapcat #(list (conj (key %) true)\n                                       (conj (key %) false))\n                                (filter (comp (partial = \\_) val) ib))\n          fits?         (fn [[i j d]]\n                          (let [l (fn [k] (ib (if d [i (+ j k)] [(+ i k) j]) :out-of-bounds))]\n                            (and\n                              (every? #{\\# :out-of-bounds} (list (l -1) (l (count w))))\n                              (every? true? (map-indexed\n                                              (fn [k c]\n                                                (or (= (l k) \\_)\n                                                    (= (l k) c)))\n                                              w)))))]\n      (boolean (some fits? starts))))", "problem": 111, "user": "525f51bde4b0cb4875a45dc8"}, {"code": "(fn ss [w c]\n   (let [crs (->> c (map (fn [x] (vec(remove #(= % \\space) x)))) vec)\n         rc (concat (for [i (range (count (first crs)))] (for [j (range (count crs))] (get-in crs [j i]))) crs)\n         wrd (seq w)\n         ]\n     (->> rc \n          (mapcat (fn[x] (split-with #(not= % \\#) x)))\n          (map (fn[x] (remove #(= % \\#) x)))\n          (filter #(not(or(empty? %)(not=(count %)(count wrd)))))\n          (map (fn[x] (every? true?(map (fn[wy y] (or(= wy y)(= y \\_))) w x))))\n          (filter true?)\n          count\n          (< 0)\n          )\n   )\n )", "problem": 111, "user": "5274eb56e4b03e8d9a4a74bb"}, {"code": "(fn [word puzzle] (let [my-equal (fn [pw w] (loop [k 0 max-k (count w)] \n                                              (if (= k max-k) true \n                                                (if (= (nth pw k) \\_) (recur (inc k) max-k)\n                                                  (if (or (not= (nth pw k) (nth w k)) (= (nth pw k) \\#)) false\n                                                    (recur (inc k) max-k)\n                                                  )\n                                                )\n                                              )\n                                            )\n                                 )\n                        get-letter (fn [p i j] (nth (nth p i) j))\n                        horiz-soln (fn [w p i j m]\n                                     (cond\n                                      (> (count w) (- m j)) false\n                                      (or (= (get-letter p i j) \\#) (and (not= (get-letter p i j) \\_) (not= (get-letter p i j) (first w)))) false\n                                      :else (and\n                                             (my-equal (clojure.string/join (for [z (range j (+ j (count w)))] (get-letter p i z))) w)\n                                             (if (> j 0) (= \\# (get-letter p i (dec j))) true)\n                                             (if (< (+ (count w) j) m) (= \\# (get-letter p i (+ j (count w)))) true)\n                                            )\n                                     )\n                                   )\n                        vert-soln (fn [w p i j m] \n                                    (cond\n                                     (> (count w) (- m i)) false\n                                     (or (= (get-letter p i j) \\#) (and (not= (get-letter p i j) \\_) (not= (get-letter p i j) (first w)))) false\n                                     :else (and \n                                            (my-equal (clojure.string/join (for [z (range i (+ i (count w)))] (get-letter p z j))) w)\n                                            (if (> i 0) (= \\# (get-letter p (dec i) j)) true)\n                                            (if (< (+ (count w) i) m) (= \\# (get-letter p (+ i (count w)) j)) true)\n                                           )\n                                    )\n                                  )\n                        real-puzzle (map (fn [z] (clojure.string/replace z #\" \" \"\")) puzzle)\n                       ]\n  (loop [i 0 max-i (count real-puzzle) j 0 max-j (count (first real-puzzle))]\n                    (if (= i max-i) false\n                      (if (= j max-j) (recur (inc i) max-i 0 max-j)\n                        (if (or (horiz-soln word real-puzzle i j max-j) (vert-soln word real-puzzle i j max-i)) true\n                          (recur i max-i (inc j) max-j)\n                        )\n                      )\n                    )\n  )\n                  )\n)", "problem": 111, "user": "526dd90de4b03e8d9a4a72fe"}, {"code": "(fn crossword-possible-insert? [s board]\n  (let [board (concat (map #(apply str (re-seq #\"[^\\s]+\" %)) board)\n                      [(apply str (repeat (count (first board)) \\#))])\n        crossword-all-places (fn [board]\n                               (->> (into board \n                                          (->> (apply interleave board)\n                                               (partition (count board))\n                                               (map #(apply str %))))\n                                    (map #(clojure.string/split % #\"#\"))\n                                    (flatten)\n                                    (vec)))\n        crossword-fit?(fn [s place]\n                        (and\n                         (= (count s) (count place))\n                         (every?\n                          #(= (first %) (second %))\n                          (->> (map vector s place)\n                               (remove #(= \\_ (second %)))))))\n        places (crossword-all-places board)]\n    (true? (some #(crossword-fit? s %) places))))", "problem": 111, "user": "526ee63de4b03e8d9a4a733f"}, {"code": "(fn [w bi]\n  (letfn\n    [(cm? [a b] (or (= a b) (= a \\_) (= b \\_)))\n     (wm? [a b] (and (= (count a) (count b)) (every? true? (map cm? a b))))\n     (in? [w l] (some true? (map #(wm? % w) (clojure.string/split (apply str l) #\"#\"))))\n     ]\n    (let [b (map #(clojure.string/replace % \" \" \"\") bi)]\n      (->> (concat b (apply (partial map list) b)) (map #(in? w %)) (some true?) nil? not))))", "problem": 111, "user": "528e64b7e4b0239c8a67aedd"}, {"code": "(fn [w p]\n    (let [p (vec (map #(clojure.string/replace % #\"\\s+\" \"\") p))\n          in-bounds (fn [i j]\n                      (and (>= i 0)\n                           (>= j 0)\n                           (< i (count p))\n                           (< j (count (get p i)))))\n\n          at (fn [i j]\n               (if-not (in-bounds i j)\n                 \\#\n                 (get (get p i) j)))\n\n          w-length (count w)\n\n          check (fn [[i j] [i-delta j-delta]]\n                  (and (every?\n                         identity\n                         (for [n (range (count w))]\n                           (let [board-c (at (+ i (* i-delta n)) (+ j (* j-delta n)))\n                                 word-c (get w n)]\n                             (or (= board-c \\_)\n                                 (= board-c word-c)))))\n                       (= \\# (at (- i i-delta) (- j j-delta)))\n                       (= \\# (at (+ i (* i-delta w-length)) (+ j (* j-delta w-length))))))\n\n          all-positions (apply\n                          concat\n                          (for [i (range (count p))]\n                            (for [j (range (count (get p i)))]\n                              [i j])))\n\n          allowed? (or (some identity (map #(check % [1 0]) all-positions))\n                       (some identity (map #(check % [0 1]) all-positions))\n                       false)]\n      allowed?))", "problem": 111, "user": "521b9f92e4b0c4ef0be8304c"}, {"code": "(fn puzz [s m]\n  (let [l (inc (inc (count s)) )\n        fits? (fn [row]\n                (print row)\n                (let [row' (clojure.string/replace row #\" \" \"\")\n                      row' (partition l 1 (str \"#\" row' \"#\"))\n                      row' (map #(reduce str %) row')\n                      row' (map #(clojure.string/replace % #\"_\" \"[a-z]\") row')\n                      fit (filter #(re-find (re-pattern %) (str \"#\" s \"#\")) row')\n                      ]\n                  ((complement empty?) fit) )\n                )]\n    (or ((complement empty?) (filter fits? m) )\n        ((complement empty?) (filter fits?\n                                     (map #(reduce str %) (apply (partial map vector) m))\n                                     )))))", "problem": 111, "user": "52140b53e4b0961f15ac4d7e"}, {"code": "(fn [w b] \n  (letfn [(clean [b] (map #(re-seq #\"[\\w#]\" %) b))\n          (split-at-# [w] (partition-by #(= \"#\" %) w))\n          (wordcmp [pfw]\n              (every? true? (map \n                              #(if (some #{%2} [\"_\" %1]) true false)\n                              (re-seq #\"\\w\" w) pfw)))]\n    (->>\n      (apply map list (clean b)) ; cols\n      (concat (clean b)) ; rows\n      (mapcat split-at-#)\n      (filter #(= (count w) (count %)))\n      (some #(wordcmp %))\n      (boolean)\n    )))", "problem": 111, "user": "528652fbe4b0239c8a67ae14"}, {"code": "(fn [word puzzle]\n  (letfn [\n(row-to-regexes [row]\n  (map #(clojure.string/replace % \"_\" \".\")\n       (clojure.string/split row #\"#\")))\n\n(row-match? [row word]\n  (reduce #(or % %2) false\n          (map #(re-matches (re-pattern %) word)\n               (row-to-regexes row))))\n\n(cols-to-rows [coll]\n  (if (or (empty? coll) (empty? (first coll))) []\n      (cons (clojure.string/join (map first coll))\n            (cols-to-rows (map rest coll)))))]\n\n\n  (let [puzzle (map #(clojure.string/replace % \" \" \"\") puzzle)\n        blocks (concat puzzle (cols-to-rows puzzle))]\n    (reduce #(or % %2)\n            (map #(not (nil? %))\n                 (map #(row-match? % word) blocks))))))", "problem": 111, "user": "524ae8e6e4b09eba1c0223b5"}, {"code": "(fn n111 [word puzzle]\n  (letfn [(clean-puzzle []\n                        (map (fn [x] (filter #(not (java.lang.Character/isWhitespace %)) x)) puzzle))\n          (get-columns [cleaned-puzzle]\n                       (apply map vector puzzle))\n          (get-empty [r]\n                     (filter not-empty \n                             (map (fn [x] (if (= \\# (first x)) (rest x) x)) \n                                  (split-with #(not= % \\#) r))))\n          (get-all-empty [rs]\n                         (mapcat get-empty rs))\n          (get-same-length [rs]\n                           (filter #(= (count word) (count %)) rs))\n          (compatible? [r]\n                       (loop [x r w word]\n                         (if (empty? x)\n                           true\n                           (if (and (not= (first x) \\_) (not= (first x) (first w)))\n                             false\n                             (recur (rest x) (rest w))))))\n          (find-compatible [rs]\n                           (filter compatible? rs))]\n    ;(get-columns (clean-puzzle))\n    (if (> (count (find-compatible (get-same-length (get-all-empty (concat (clean-puzzle) (get-columns (clean-puzzle))))))) 0)\n      true\n      false)\n    ))", "problem": 111, "user": "52b43468e4b0c58976d9ad1b"}, {"code": "(fn [word board]\n  (let [rplc clojure.string/replace\n        hors (map #(rplc (rplc % \" \" \"\") \"_\" \".\") board)\n        width (count (first hors))\n        verts (for [i (range width)] (clojure.string/join (map #(nth % i) hors)))\n        split #(clojure.string/split % #\"#\")\n        pats (flatten (concat (map split hors) (map split verts)))\n        fits? (fn [pat] (boolean (re-matches (re-pattern (str \"^\" pat \"$\")) word)))]\n    (boolean (some identity (map fits? pats)))))", "problem": 111, "user": "52a88c4de4b0c58976d9ac30"}, {"code": "(fn [w B]\n  (let [b (map #(remove (partial = \\space) %) B)\n        valid? (fn [x]\n                 (every?\n                  (fn [[a b]] (or (= a b) (= b \\_)))\n                  (apply map list [w x])))]\n    (->> b\n         (apply mapv list)\n         (concat b)\n         (mapcat #(partition-by (partial = \\#) %))\n         (filter #(= (count %) (count w)))\n         (some valid?)\n         nil?\n         not)))", "problem": 111, "user": "4f437751e4b0d7d3c9f3fd20"}, {"code": "(fn can-solve [word board]\n  (let [rows (map #(clojure.string/replace % #\" \" \"\") board)\n        cols (apply (partial map str) rows)\n        make-parts (fn [xs] (mapcat #(clojure.string/split % #\"#\") xs))\n        fits? (fn [part] (and (= (count word) (count part))\n                             (every? (fn [[a b]] (or (= a b) (= b \\_)))\n                                     (map vector word part))))]\n    (boolean (or (some fits? (make-parts rows))\n                  (some fits? (make-parts cols))))))", "problem": 111, "user": "511aa2a4e4b0c87c59c9670a"}, {"code": "(fn [word puzzle]\n  (let [fillable? (fn [word spot full-word]\n                    (cond\n                     (and (empty? word) (or (empty? spot) (= \\# (first spot)))) true\n                     (or (empty? word) (empty? spot)) false\n                     (or (= (first word) (first spot)) (= \\_ (first spot))) (recur (rest word) (rest spot) full-word)\n                     (not= (first word) (first spot)) (recur full-word\n                                                             (drop 1 (drop-while (partial not= \\#) spot))\n                                                             full-word)))\n        rows (map (partial remove #{\\space}) puzzle)\n        cols (apply map vector rows)]\n    (boolean (some #(fillable? word % word) (concat rows cols)))))", "problem": 111, "user": "50645e12e4b007509339a58a"}, {"code": "(letfn [(compact [str] (clojure.string/replace str #\" \" \"\"))\n        (words [str] (clojure.string/split str #\"#\"))\n        (cmatch? [c1 c2] (or (= c1 c2) (= c2 \\_)))\n        (match? [str ph]\n          (and (= (count str) (count ph))\n               (every? true? (map cmatch? str ph))))\n        (fillsl? [str line] (some #(match? str %) (-> line compact words)))]\n   (fn [s rect] \n     (boolean (some #(fillsl? s %) (concat rect (apply map str rect))))))", "problem": 111, "user": "5294e44de4b02ebb4ef75016"}, {"code": "(fn c-word\n  [word board]\n  (letfn\n    [(check-word\n      [word space]\n      (and\n        (= (count word) (count space))\n        (= #{true} (set (map #(or (= %1 %2) (= (str %2) \"_\")) word space)))))\n     (row\n      [word row]\n      (let [available (clojure.string/split row #\"#\")]\n        (some true? (map #(check-word word %) available))))\n     (flip-board\n      [board]\n      (for [i (range (count (first board)))]\n       (apply str (map #(nth % i) board))))]\n    (let [no-spaces (map #(clojure.string/replace % #\"\\s\" \"\") board)]\n      (or\n       (contains? (set (map #(row word %) no-spaces)) true)\n       (contains? (set (map #(row word %) (flip-board no-spaces))) true)))))", "problem": 111, "user": "5273e006e4b03e8d9a4a7495"}, {"code": "(fn [w b]\n  (let [b (map #(apply str (flatten (partition 1 2 %))) b)\n        match (fn [s t]\n                (and (= (count s) (count t)) (every? true? (map #(or (= %1 %2) (= %2 \\_)) s t))))\n        check (fn [b]\n                (some (fn [l]\n                        (some (partial match w) (.split l \"#\"))) b))]\n    (boolean\n      (or\n        (check b)\n        (check (apply mapv str b))))))", "problem": 111, "user": "527cd633e4b0757a1b17136f"}, {"code": "(fn [w b]\n    (let [X (re-pattern (format \"#%s#\" (apply str (map #(format \"[_%c]\" %) w))))\n\n          F (fn [b] (some seq (map (fn [L] (re-find X L)) (map #(format \"#%s#\" (clojure.string/replace % \" \" \"\")) b))))\n]\n    (not= nil (or\n     (F b)\n     (F (map #(apply str %) (apply map (comp list) b)))))))", "problem": 111, "user": "52c73194e4b0c2d177d6211e"}, {"code": "(fn [word board]\n  (let [to-str (partial apply str)\n        remove-spaces #(to-str (take-nth 2 %))\n        across (map remove-spaces board)\n        down (apply map str (map (partial take-nth 2) board))\n        spaces (apply concat (map (partial partition-by #(= \\# %)) (concat across down)))\n        guess (re-pattern (str (reduce #(str % \"[_\" %2 \"]\") \"^\" word) \"$\"))]\n    (string? (some #(re-find guess (str %)) (map to-str spaces)))))", "problem": 111, "user": "51307b84e4b08c712d3fae39"}, {"code": "(fn [w s]\n   (let [s (vec (map #(into [] (clojure.string/replace % #\" \" \"\")) s)) rlen (count s) clen (count (first s))\n         row (apply concat (reduce (fn [a b] (let [r (reduce (fn [x y] (if (= \"#\" (str ((s b) y))) (assoc-in x [(count x)] []) (update-in x [(dec (count x))] conj ((s b) y)))) [[]] (range clen))] (conj a r))) [] (range rlen)))\n         col (apply concat (reduce (fn [a b] (let [r (reduce (fn [x y] (if (= \"#\" (str ((s y) b))) (assoc-in x [(count x)] []) (update-in x [(dec (count x))] conj ((s y) b)))) [[]] (range rlen))] (conj a r))) [] (range clen)))\n         blanks (concat row col)\n         possibles (vec (filter #(= (count %) (count w)) blanks))\n         w2 (vec w)]\n     (loop [i 0]\n       (if (>= i (count possibles))\n         false\n         (let [tf (reduce #(if (or (= (str ((possibles i) %2)) \"_\") (= (str ((possibles i) %2)) (str (w2 %2)))) (conj %1 true) (conj %1 false)) [] (range (count w2)))]\n           (if (every? true? tf)\n             true\n         (recur (inc i))))))))", "problem": 111, "user": "52c1bd29e4b07a9af579236a"}, {"code": "(fn my-crossword-puzzle\r\n  [word puzzle]\r\n  (letfn [(remove-spaces [puzzle] (map (fn [puzzle-part] (remove #(= % \\space) puzzle-part)) puzzle))\r\n          (matches? [word hole] (if (= (count word) (count hole))\r\n                                  (not-any? false? (map #(cond\r\n                                                           (= %1 %2) true\r\n                                                           (= \\_ %2) true\r\n                                                           :else false) word hole))\r\n                                  false))\r\n          (create-holes-h [puzzle-part] (partition-by #(= % \\#) puzzle-part))\r\n          (create-holes-v [puzzle] (loop [result [] i 0]\r\n                                     (if (= i (count (first puzzle)))\r\n                                       result\r\n                                       (recur (conj result (map #(get (apply str %) i) puzzle)) (inc i)))))]\r\n    (let [fixed-puzzle (remove-spaces puzzle)]\r\n      (not-every? false? (map #(matches? word %) \r\n                                        (into (mapcat create-holes-h fixed-puzzle) (create-holes-v fixed-puzzle)))))))", "problem": 111, "user": "509a25b7e4b0efbae1fbc0a8"}, {"code": "(fn [word grid]\n    (let [re (re-pattern (str \"#\" (apply str (for [c word] (str \"[\" c \"_]\"))) \"#\"))\n          grid-str (str\n                    (apply str \"#\" (interpose \"#\"\n                                              (for [row (concat grid (apply map vector grid))]\n                                                (apply str (remove #(= % \\space) row)))))\n                    \"#\")]\n      (boolean (re-find re grid-str))))", "problem": 111, "user": "52d83c2ce4b09f7907dd138d"}, {"code": "(fn [palavra crossword]\n  (let [candidatos (filter #(= (count %) (count palavra))\n                           (mapcat (comp (partial partition-by #{\\#}) (partial remove #{\\space})) \n                                   (concat crossword (apply map str crossword))))]\n    (if (empty? candidatos)\n      false\n      (not (nil? (some identity (map (fn [candidato] (every? identity (map #(or (= \\_ %2) (= % %2)) palavra candidato))) candidatos))))\n      \n      #_(every? (fn [[p s]] (or (= s \\_) (= p s)))\n              (map #(vector % %2) \n                   palavra \n                   candidatos)))))", "problem": 111, "user": "52c8758be4b0c2d177d62135"}, {"code": "(fn xword [word b]\n  (let [board (map (fn [x] (filter #(not= \\space %) x)) b)\n        match (fn [word [c & oll] i]\n          (cond\n           (and (>= i (count word)) (or (not c) (= c \\#))) true\n           (not c) false\n           (or (= c (get word i)) (and (= c \\_) (get word i))) (recur word oll (inc i))\n           (= c \\#) (recur word oll 0)\n           :else (recur word (drop-while (partial not= \\#) oll) 0)\n           )\n          )]\n    (true? (some true?\n                 (map #(match (vec word) % 0)\n                      (concat board\n                              ; Rotate the board so each entry is a column\n                              (apply map vector board)\n                              ))\n    ))\n   )\n  )", "problem": 111, "user": "52e59ca5e4b09f7907dd1464"}, {"code": "(fn [w p]\n  (boolean\n    (some #(re-matches (re-pattern (apply str (replace {\\_ \\.} %))) w)\n          (let [p (map #(remove #{\\ } %) p)]\n            (mapcat #(partition-by #{\\#} %) (concat p (apply map str p)))))))", "problem": 111, "user": "52b453b0e4b0c58976d9ad21"}, {"code": "(fn puzzle [word board]\n  (let [ r_str (map #(apply str %) (for [r board](re-seq #\"[a-z_#]\" r)))\n        c_str (map #(apply str %) (filter #(not= nil %) (for [c (for [x (range (count (first board)))](apply str (for [y  (range (count board))](nth (nth board y) x))))](re-seq #\"[a-z_#]\" c))))\n        tok (map #(apply str %) (apply concat (map (fn [sp] [(take-while #(not= \\# %) sp) (drop 1 (drop-while #(not= \\# %) sp))]) (concat r_str c_str))))\n       ]\n      (> (count (filter #(not= nil %) (for [p (map #(re-pattern (str \"^\" (.replaceAll % \"_\" \"\\\\\\\\w\") \"$\")) tok)]\n         (re-find p word)\n      ))) 0)\n  )\n)", "problem": 111, "user": "522eba30e4b01cdb292c5f0e"}, {"code": "(fn [word rect] (letfn [\n(slots [string] (filter not-empty (clojure.string/split string #\"#\")))\n(rows [rect] rect)\n(cols [rect] (apply map vector rect))\n(string-cols [rect] (map (partial apply str) (cols rect)))\n(all-slots [rect] (mapcat slots (concat (rows rect) (string-cols rect))))\n(remove-whitespace [s] (apply str (remove #(java.lang.Character/isWhitespace %) s)))\n(all-slots-without-space [rect] (map remove-whitespace (all-slots rect)))\n(slot-regex [slot] (re-pattern (clojure.string/replace slot \"_\" \".\")))\n(slot-regexes [rect] (map slot-regex (all-slots-without-space rect)))\n(word-fits-in-puzzle [word rect] (or (some (complement nil?) (map #(re-matches % word) (slot-regexes rect))) false))\n] (word-fits-in-puzzle word rect)))", "problem": 111, "user": "52f10094e4b05e3f0be25ee8"}, {"code": "(fn [w g]\n  (let [r clojure.string/replace\n        g (map #(r % #\" \" \"\") g)\n        f #(re-find (re-pattern (str \"(^|#)\" (r w #\".\" \"[_$0]\") \"($$|#)\")) %)\n        s some]\n    (boolean\n      (or\n        (s f g)\n        (s f (apply #(map str % %2 %3) g))))))", "problem": 111, "user": "51a10b2ce4b0b292b01ee3fe"}, {"code": "(fn place-word [word crossword]\n  (let [\n    \n    remove-whitespace (partial remove #{\\space})\n\n    line-length    (count (first crossword))\n    collumn-length (count crossword)\n        \n    line-range     (range line-length)\n    collumn-range  (range collumn-length)\n        \n    collumn     (fn[c] (for [x collumn-range] (get-in crossword [x c])))\n        \n    lines       (for [line crossword] (remove-whitespace line))\n    collumns    (for [c   line-range] (remove-whitespace (collumn c)))\n               \n    word-spaces (remove #{'(\\#)} (reduce into (map #(partition-by #{\\#} %) (concat lines collumns))))\n               \n    fits?       (fn[w](= (count w) (count word)))\n                  \n    usable-ws   (filter fits? word-spaces)\n                  \n    compare-words\n     (fn compare-words [[c1 & r1 :as word1]\n                        [c2 & r2 :as word2]]\n       (cond\n        (nil? c1) true\n        (= c2 c1) (compare-words r1 r2)\n        (= c2 \\_) (compare-words r1 r2)\n        :else     false ))]\n                  \n                 \n    (not (every? false? (for [ws usable-ws] (compare-words word ws))))))", "problem": 111, "user": "52f818a6e4b047fd55836fcc"}, {"code": "(fn place? [word puzzle]\n  (let [puz (map #(take-nth 2 %) puzzle) \n        brd [(repeat \\#)]\n        trz (fn [puz] (apply mapv vector (concat brd puz brd)))\n        ver (trz puz)\n        hor (trz ver)\n        wrd (concat [\\#] word [\\#])\n        fit? (fn [loc] (every? identity (map #(if (= \\_ %2) (not= \\# %1) (= %1 %2)) wrd loc)))]\n     (-> (for [ori [ver hor]\n               row ori\n               loc (partition (count wrd) 1 row) \n               :when (fit? loc)] \n           [ori row loc])\n         empty? not)))", "problem": 111, "user": "50d0d4c8e4b00b15ecee976a"}, {"code": "(fn cross-puzzle [word puzzle]\n  (letfn [(fits? [x] (if (not= (count word) (count x) ) false\n                            (->> x\n                                 (interleave word)\n                                 (partition 2)\n                                 (map #(cond\n                                        (= (second %) \\_) true\n                                        (= (first %) (second %)) true))\n                                 (every? identity))))\n          (rotate [board] (apply map str board))\n          (clear-space [col] (map #(apply str (remove #{\\space} %)) col))\n          (normalize [board] (flatten (map #(clojure.string/split % #\"#\") (clear-space board))))]\n    (boolean (or (some fits? (normalize puzzle))\n        (some fits? (normalize (rotate puzzle)))))))", "problem": 111, "user": "4edf5dc6535d10e5ff6f5340"}, {"code": "(fn [w b]\n  (let [r clojure.string/replace\n        b (map (comp #(r % \" \" \"\") #(r % \"_\" \".\")) b)\n        f (apply map str b)\n        l (->> f (into b)\n        \t(mapcat #(clojure.string/split % #\"#\")))]\n    (boolean (some #(re-matches (re-pattern %) w) l))))", "problem": 111, "user": "4ff3df0fe4b0678c553fc355"}, {"code": "(fn crossword [word puzzle]\n\t(letfn [(transform-puzzle [puzzle]\n\t\t\t\t(vec (map (fn [x] (apply str (filter #(not= % \\space) (seq x)))) puzzle))\n\t\t\t)\n\t\t\t(region-match [word to-match]\n\t\t\t\t(every?  (fn [[x y]] (or (= x y) (= y \\_)))  (map vector word to-match))\n\t\t\t)\n\t\t\t(check-match[puzzle-word word pos]\n\t\t\t\t(let [word-len (count word)\n\t\t\t\t\t  puzzle-word-len (count puzzle-word)\n\t\t\t\t\t  end-pos (+ pos word-len)\t\n\t\t\t\t\t  to-match (subs puzzle-word pos end-pos)\n\t\t\t\t\t]\n\t\t\t\t\t(and (or (= pos 0)\n\t\t\t\t\t\t\t (= (nth puzzle-word (dec pos)) \\#)\n\t\t\t\t\t\t )\t\n\t\t\t\t\t\t (or (= puzzle-word-len end-pos)\n\t\t\t\t\t\t\t (= (nth puzzle-word end-pos) \\#))\n\t\t\t\t\t\t (region-match word to-match))\t \n\t\t\t\t)\n\t\t\t)\n\t\t\t(row-match[word puzzle-row]\n\t\t\t\t(let [word-len (count word) puzzle-row-len (count puzzle-row)]\n\t\t\t\t\t(some\t#(check-match puzzle-row word %)\t(range (inc (- puzzle-row-len word-len))))\n\t\t\t\t)\n\t\t\t)\n\t\t\t(check-horizontal-match[word w-puzzle]\n\t\t\t\t(let [word-len (count word) puzzle-row-len (count (peek w-puzzle))]\n\t\t\t\t\t(println \"word-len\" word-len  \"puzzle-row-len\" puzzle-row-len)\n\t\t\t\t\t(if (> word-len puzzle-row-len)\n\t\t\t\t\t\tfalse\n\t\t\t\t\t\t(if (some  #(row-match word %) w-puzzle)\n\t\t\t\t\t\t\ttrue\n\t\t\t\t\t\t\tfalse)\n\t\t\t\t\t)\n\t\t\t\t)\t\n\t\t\t)\n\t\t\t(transpose [m]\n\t\t\t  (vec (map #(apply str %) (apply mapv vector m)))\n\t\t\t)\n\t\t\t(check-vertical-match[word w-puzzle]\n\t\t\t\t(check-horizontal-match word (transpose w-puzzle))\n\t\t\t)\t\n\t\t]\n\t\t(let [w-puzzle (transform-puzzle puzzle)]\n\t\t\t(or (check-horizontal-match word w-puzzle)\n\t\t\t\t(check-vertical-match word w-puzzle))\n\t\t)\n\t)\n)", "problem": 111, "user": "52763696e4b03e8d9a4a74d7"}, {"code": "(let [flip (fn [f]\n              (fn [x y] (f y x)))\n       unspace\n       (partial mapv (comp \n                      (partial apply str)\n                      (partial filter (partial not= \\space))))\n       transpose-strs\n       (partial apply mapv str)\n\n       words\n       (comp\n        (partial mapcat (partial (flip clojure.string/split) #\"#\"))\n        (partial apply concat)\n        (juxt identity transpose-strs))\n\n       can-place-char?\n       (comp \n        (partial some true?)\n        (juxt\n         (comp (partial some (partial = \\_))\n               list)\n         =))\n\n       can-place-word?\n       (comp \n        (partial every? true?)\n        (juxt\n         (comp \n          (partial apply =)\n          (partial map count)\n          list)\n         (comp \n          (partial every? true?)\n          (partial map can-place-char?))))]\n   (comp\n    true?\n    (partial some true?)\n    (partial apply map)\n    (juxt \n     (comp (partial partial can-place-word?) first)\n     (comp words unspace second))\n    list))", "problem": 111, "user": "5326c5f7e4b09d4e7a9b54f2"}, {"code": "(fn [w p]\n  (let [sm (map #(replace {\\space \"\" \\_ \\.} %) p)\n        co (apply map list sm)\n        pl (mapcat #(take-nth 2 (partition-by #{\\#} %)) (concat sm co))]\n    (boolean (some #(re-matches (re-pattern (apply str %)) w) pl))))", "problem": 111, "user": "509e62a8e4b08df8156e9e2e"}, {"code": "(fn [word board]\n  (letfn [(check-valid [word line]\n            (if (some #{\\#} line)\n              (true? (some true? (map #(check-valid word %) (re-seq #\"[^#]*\" (apply str line)))))\n              (if (= (count word) (count line))\n                (if (and (seq word) (seq line))\n                  (if (or (= \\_ (first line)) (= (first word) (first line)))\n                    (check-valid (next word) (next line))\n                    false)\n                  true)\n                false)))]\n    (let [non-space-board (map #(filter (fn [ch] (not= \\space ch)) %) board)]\n      (true? (some true? (mapcat\n                           (fn [ch]\n                             (map\n                               #(check-valid word %)\n                               (filter\n                                 #(or (some #{ch} %) (every? #{\\# \\_} %))\n                                 (concat non-space-board (apply (partial map (fn [& coll] coll)) non-space-board)))))\n                           word))))))", "problem": 111, "user": "50436470e4b034ff00315d23"}, {"code": "(fn [word board]\n  (boolean \n    (letfn [(remove-spaces [board]\n              (vec (map #(clojure.string/replace % #\" \" \"\") board)))\n            (extract-word-slots [board]\n              (concat board\n              (map (partial apply str )\n                (for [x (-> board first count range)]\n                  (for [y (-> board count range)]  \n                    (get-in board [y x]))))))\n            (split-word-slots [slots]\n              (reduce #(into %1 (clojure.string/split %2 #\"#\")) [] slots))\n            (make-regexes [slots]\n              (map #(re-pattern (.toLowerCase (clojure.string/replace %1 #\"_\" \".\"))) slots))]\n  \n      (some #(re-matches %1 word)\n          (-> board\n              remove-spaces\n              extract-word-slots\n              split-word-slots\n              make-regexes)))))", "problem": 111, "user": "53300924e4b019098a6f8b55"}, {"code": "(letfn [(transpose\n         [matrix]\n         (apply mapv str matrix))\n        \n        (match?\n         [word slot]\n         (and (= \\# (first slot) (last slot))\n              (every? (fn [[a b]] (#{\\_ a} b))\n                      (->> (butlast (rest slot))\n                           (map list word)))))\n        \n        (place?\n         [word row]\n         (let [size (+ 2 (count word))]\n           (->> (str \\# row \\#)\n                (partition size 1)\n                (some (partial match? word)))))\n        \n        (solve?\n         [word puzzle]\n         (some (partial place? word)\n               puzzle))]\n  \n  (fn cross-word\n    [word puzzle]\n    (let [puzzle\n          (mapv (comp (partial apply str)\n                      (partial remove #{\\space}))\n                puzzle)]\n      \n      (or (solve? word puzzle)\n          (solve? word (transpose puzzle))\n          false))))", "problem": 111, "user": "532ab0bde4b09d4e7a9b5527"}, {"code": "(fn [w b]\n  (let [rows (map #(filter (partial not= \\space) %) b)\n        cols ((fn [a]\n               (loop [res [] i 0]\n                 (if (= i (count (first a)))\n                   res\n                   (recur (cons (map #(nth % i) a) res) (inc i)  )\n                   )))rows)\n        rows (concat rows cols)\n        f (fn f [s]\n            (if (empty? s)\n              []\n              (cons\n               (take-while (partial not= \\#) s)\n               (f (next (drop-while (partial not= \\#) s))))))\n        rows (apply concat (map f rows))\n        rows (filter (fn[e](= (count w) (count e))) rows)\n        rows (map #(every? identity (map-indexed (fn[i e](or (= e \\_) (= e (nth w i)))) %)) rows)\n        ]\n    (not(not-any? identity rows))))", "problem": 111, "user": "5349ac2be4b084c2834f4a67"}, {"code": "(letfn\n    [(patterns [puzzle]\n        (let [puzzle (map #(remove (partial = \\space) %) puzzle)]\n          (for [r puzzle\n                w (partition-by #(= \\# %) r)\n                :when (not= \\# (first w))\n                :let [w (replace {\\_ \\.} w)\n                      w (apply str \"^\" w)]]\n            (re-pattern (str w \"$\")))))]\n\n  (fn [word puzzle]\n    (not\n     (nil?\n      (some\n       #(re-matches % word)\n       (concat (patterns puzzle)\n               (patterns (apply map vector puzzle))))))))", "problem": 111, "user": "52d2ca1ce4b099d49816f0b4"}, {"code": "(fn cross [word puzzle]\n  (let [\n         reg-ready (map #(clojure.string/replace (clojure.string/replace (clojure.string/replace % \"#\" \"|\") \" \" \"\") \"_\" \".\") puzzle)\n         reg-ready' (map (partial apply str) (apply map vector reg-ready))\n         regs (map re-pattern (concat reg-ready reg-ready'))\n         ]\n\n    (boolean (some #(re-matches % word) regs))\n    ))", "problem": 111, "user": "53307da1e4b019098a6f8b5e"}, {"code": "(fn [w b]\n  (letfn [(g [x y] (nth (nth b y []) (* 2 x) \\#))\n          (fx [w x y]\n            (if (empty? w)\n              (= \\# (g x y))\n              (and (contains? #{\\_ (first w)} (g x y)) (fx (rest w) (inc x) y))))\n          (fy [w x y]\n            (if (empty? w)\n              (= \\# (g x y))\n              (and (contains? #{\\_ (first w)} (g x y)) (fy (rest w) x (inc y)))))]\n    (reduce #(or % %2)\n            (for [x (range (quot (inc (count (first b))) 2))\n                  y (range (count b))]\n              (or (and (= \\# (g (dec x) y)) (fx w x y))\n                  (and (= \\# (g x (dec y))) (fy w x y)))))))", "problem": 111, "user": "53460d02e4b084c2834f4a39"}, {"code": "(fn [word grid]\n  (let [remove-spaces (fn [coll] (map #(.replace % \" \" \"\") coll))\n        get-cell (fn [coll row column] (nth (nth coll column) row))\n        get-row-segments (fn [coll] (map #(clojure.string/split % #\"\\#\") coll))\n        get-column-lines (fn [coll]\n                           (for [row (range (count (first coll)))]\n                             (apply str\n                               (for [column (range (count coll))]\n                                 (get-cell coll row column)))))\n        get-segments (fn [coll] \n                       (flatten \n                         (concat (get-row-segments coll) \n                                 (get-row-segments (get-column-lines coll)))))\n        match? (fn [word segment]\n                 (and \n                   (= (count word) (count segment))\n                   (every? (fn [[a b]] (or (= a b) (= b \\_))) (zipmap word segment))))]\n    (loop [segments (get-segments (remove-spaces grid))]\n      (cond\n        (empty? segments) false\n        (match? word (first segments)) true\n        :else (recur (rest segments))))))", "problem": 111, "user": "53513d28e4b084c2834f4ae3"}, {"code": "(fn [p q]\n(letfn [(f1 [x y]\n          (and\n           (not= \\_ (first y))\n           (not= \\_ (last y))\n           (let [y (rest (butlast y))]\n             (and (not (every? #{\\_} y))\n             (every? identity\n                     (map (fn [a b]\n                            (or (= a b)\n                                (= \\_ b)))\n                          x y))))))\n        (f2 [x y]\n          (let [n (count x)\n                y1 (concat [nil] y [nil])\n                y2 (partition (+ n 2) 1 y1)]\n            (some #(f1 x %) y2)))\n        (f3 [x] \n          (map (partial remove #{\\space})\n               (concat x (apply map vector x))))]\n  (boolean\n   (some (partial f2 p)\n         (f3 q)))))", "problem": 111, "user": "529b44afe4b02ebb4ef7509d"}, {"code": "(fn [w z]\n  (let\n    [\n      z1 (for [s z] (clojure.string/replace s #\" \" \"\")) \n      x (count (first z1))\n      h [(apply str (repeat x \"#\"))]\n      y (format \".{%d}\" x)\n      z2 (clojure.string/join \"#\" (concat h z1 h)) \n      p (str \"#\" (clojure.string/replace w #\".\" \"[$0_]\") \"#|#\" y (clojure.string/replace w #\".\" (str \"[$0_]\" y)) \"#\")\n    ]\n    (not= (re-find (re-pattern p) z2) nil)\n  )  \n)", "problem": 111, "user": "5176afd2e4b085adf681d889"}, {"code": "(fn the-answer\n  [word grid]\n  (letfn [(sanitize [line]\n            (clojure.string/replace line #\"\\s\" \"\"))\n\n          (gaps [cw-line]\n            (-> cw-line\n                sanitize\n                (clojure.string/split #\"#\")\n                (->> (map seq))))\n\n          (rotate [lines]\n            (let [lines (map (comp vec sanitize) lines)\n                  length (count (first lines))]\n              (for [i (range length)]\n                (apply str (map nth lines (repeat i))))))\n\n          (all-gaps [lines]\n            (->> (concat lines (rotate lines))\n                 (mapcat gaps)))\n\n          (fits? [word gap]\n            (and\n              (= (count word)\n                 (count gap))\n              (every? #(#{(nth word %) \\_} (nth gap %))\n                      (range (count word)))))]\n    (boolean\n      (some (partial fits? word)\n          (all-gaps grid)))))", "problem": 111, "user": "537caf68e4b06839e8705e7b"}, {"code": "(fn __\n  [word board]\n  (let [b (map (fn [r] (clojure.string/replace r \" \" \"\")) board)\n        tokens #(mapcat (fn [r] (clojure.string/split r #\"#\")) %)\n        hor (tokens b)\n        ver (tokens (map (fn [i] (apply str (map (fn [c] (nth c i)) b))) (range (count (first b))))) ]\n    \n    (if (some #(re-matches % word)\n              (map (fn [t]\n                (re-pattern (str \"^\" (clojure.string/replace t \"_\" \".\") \"$\")))\n                         (filter #(= (count word) (count %)) (concat ver hor))))\n      true\n      false)\n    \n    ))", "problem": 111, "user": "5348cab4e4b084c2834f4a5e"}, {"code": "(fn [word grid]\n  (letfn [(fits? [target]\n                 (and (= (count word) (count target)) \n                      (every? (fn [[w t]] (or (= t w) (= t \\_))) (map vector word target))))]\n    (let [transposed-grid (apply mapv vector grid)\n          all-lines (concat grid transposed-grid)]\n      (->> all-lines\n           (map (partial filter #(not= \\space %)))\n           (map #(conj % \\#))\n           (flatten)\n           (partition-by #(= \\# %))\n           (some fits?)\n           (boolean)\n         ))))", "problem": 111, "user": "536ca4bde4b0fc7073fd6e49"}, {"code": "(fn [word crossword]\n  (letfn [(rowsandcols [c]\n            (let [sprf (fn [r] (remove #(= \\space %) r))\n                  nsp (map sprf c)\n                  cols (apply map vector nsp)]\n              (concat nsp cols)))\n          (remove-unusable [c]\n            (letfn [(rc [r]\n                      (if (some #(= \\# %) r)\n                        [(take-while #(not= \\# %) r) (rest (drop-while #(not= \\# %) r))]\n                        [r]))]\n              (mapcat rc c)))\n          (match-letter [l s] (or (= l s) (= \\_ s)))\n          (match-word [w r]\n            (if (= (count w) (count r))\n              (every? identity (map-indexed #(match-letter (nth w %1) %2) r))\n              false))\n          (crossword-sol? [w c]\n            (let [rcs (rowsandcols c)\n                  wtm (remove-unusable rcs)]\n              (if (some true? (map #(match-word w %) wtm)) true false)))]\n    (crossword-sol? word crossword)))", "problem": 111, "user": "5133e51ae4b0d7a043de8cf6"}, {"code": "(fn [word board]\n  (let [cboard         (map #(clojure.string/replace % \" \" \"\") board)\n        line-matches   (fn [word line]\n                         (some #(re-matches (re-pattern (clojure.string/replace % \"_\" \".\")) word)\n                               (clojure.string/split line #\"#\")))\n        transpose      (fn [board] (map #(apply str %) (apply map vector board)))]\n    (boolean (or (some #(line-matches word %) cboard)\n                 (some #(line-matches word %) (transpose cboard))))))", "problem": 111, "user": "530bf87ee4b02e82168697d5"}, {"problem": 111, "code": "(fn [a b]\n  (let [ss (map #(clojure.string/replace % \" \" \"\") b)\n        ss (->> (apply map str ss)\n                (concat ss)\n                (mapcat #(clojure.string/split % #\"#\"))\n                (map #(clojure.string/replace % \"_\" \".\"))\n                (map re-pattern)\n                (map #(= (re-find % a) a))\n                (some identity))]\n    (or ss false)))", "user": "50ae0d24e4b0a40c9cfb08ce"}, {"problem": 111, "code": "(fn\n  [word grid]\n  (letfn [(strip-spaces [s]\n            (lazy-seq\n              (if (seq s)\n                (let [h (first s)\n                      t (rest s)]\n                  (if (= \\space h)\n                    (strip-spaces t)\n                    (cons h (strip-spaces t))))\n                nil)))]\n    (let [v (vec (map #(vec (strip-spaces (.toUpperCase %))) grid))\n          height (count v)\n          width (count (first v))\n          uw (.toUpperCase word)\n          wordlen (count word)\n          letters-fit (fn [row col drow dcol word]\n                        (if (seq word)\n                          (let [c (get-in v [row col])\n                                row' (+ row drow)\n                                col' (+ col dcol)\n                                h (first word)\n                                t (rest word)]\n                            (if (or (= c \\_)\n                                    (= c h))\n                              (recur row' col' drow dcol t)\n                              false))\n                          true))\n          word-fits-vertically (fn [row col]\n                                 (and (>= row 0)\n                                      (>= col 0)\n                                      (<= row (- height wordlen))\n                                      (< col width)\n                                      (or (= row 0)\n                                          (= \\# (get-in v [(dec row) col])))\n                                      (or (= (+ row wordlen) height)\n                                          (= \\# (get-in v [(+ row wordlen)\n                                                           col])))\n                                      (letters-fit row col 1 0 uw)))\n          word-fits-horiz (fn [row col]\n                            (and (>= row 0)\n                                 (>= col 0)\n                                 (< row height)\n                                 (<= col (- width wordlen))\n                                 (or (= col 0)\n                                     (= \\# (get-in v [row (dec col)])))\n                                 (or (= (+ col wordlen) width)\n                                     (= \\# (get-in v [row\n                                                      (+ col wordlen)])))\n                                 (letters-fit row col 0 1 uw)))]\n    (not (empty? (for [row (range height)\n                       col (range width)\n                       :when (or (word-fits-vertically row col)\n                                 (word-fits-horiz row col))]\n                   [row col]))))))", "user": "52dfc89be4b09f7907dd1405"}, {"problem": 111, "code": "(fn f [word board]\n  (letfn [(fits? [word slot]\n            (and (= (count word) (count slot))\n                 (every? #(or (= \\_ (second %))\n                              (= (first %) (second %)))\n                         (map vector word slot))))\n          (slots [line]\n            (map (fn [s] (remove #(= \\space %) s))\n                 (clojure.string/split line #\"#\")))\n          (fits-on-line? [word line]\n            (true? (some #(fits? word %) (slots line))))\n          (fits-on-board? [word board]\n            (true? (some #(fits-on-line? word %) board)))]\n    (or (fits-on-board? word board)\n        (fits-on-board? word (apply map str board)))))", "user": "52c4af71e4b0c2d177d620e1"}, {"problem": 111, "code": "(fn cw-puzzle [w cx]\n  (let [lines (map #(clojure.string/split % #\" \") cx)\n        l-and-v (concat lines (apply map vector lines))\n        word (map str w)\n        raw-space (map #(partition (count word) 1 %) l-and-v)                 ;; could have just split on pound..\n        no-good #(some (fn [c] (or (re-find #\"[a-zA-Z]\" c) (= c \"_\"))) %)\n        search-space (mapcat #(reduce (fn [a [[pre & _] l [post & _]]]        ;; on the other hand I can plugin custom rules :)\n                                        (if (no-good [pre post]) a (conj a l)))\n                                      [] (partition 3 1 (concat [[\"#\"]] % [[\"#\"]]))) \n                             raw-space)\n        hit? #(if % (every? identity (map (fn [a b] \n                                            (#{a \"_\"} b)) word %)))]\n    (boolean (some hit? search-space))))", "user": "50c781bbe4b00bb60fe0c535"}, {"problem": 111, "code": "(fn [word coll]\n  (boolean\n    (some identity\n      (let [h-col (map (fn [s] (remove #(= \\space %) s)) coll)\n            v-col (apply (partial map (fn [& xs] (apply vector xs))) h-col)\n            fill? (fn [w s]\n                    (some\n                      (fn [x]\n                        (when (= (count x) (count w))\n                          (every? identity (map (fn [ch1 ch2] (#{ch2 \\_} ch1)) x w))\n                          )\n                        )\n                      (remove #(= '(\\#) %) (partition-by #(not= \\# %) s))))\n\n            ]\n        (mapcat (partial map #(fill? word %)) [h-col v-col])\n        ))))", "user": "53b530c6e4b047364c0444bc"}, {"problem": 111, "code": "(fn cp-final-new [x y] \n  (not (nil? (re-find \n              (java.util.regex.Pattern/compile (str \"#\" (clojure.string/replace x #\"[a-z]\" #(str \"[\" %1 \"_]\")) \"#\")) \n              (str \"#\" (clojure.string/replace(clojure.string/join \"#\" (map #(clojure.string/join \"\" %) (into (map vec y) (apply map vector y)))) #\"\\s+\" \"\") \"#\")))))", "user": "525de512e4b0cb4875a45d8a"}, {"problem": 111, "code": "#(letfn [(convert-to-re [s] (re-pattern (str \"^(\"\n                                             (.replace (.replace (.replace s \" \" \"\")\n                                                                 \"_\" \".\")\n                                                       \"#\" \"|\")\n                                             \")$\")))\n         (matches? [s] (re-find (convert-to-re s) %1))]\n   (not (nil? (or (some matches? %2)\n                  (some matches? (apply map (cons str %2)))))))", "user": "53acaf1fe4b047364c04445f"}, {"problem": 111, "code": "(fn crossword [w c]\n  (let [ c-ns (map #(clojure.string/replace % #\"\\s\" \"\") c) \n         downs (->> c-ns\n                    (#(if (> (count c) 1) \n                       (apply interleave %)\n                       %))\n                    (partition (count c))\n                    (map #(apply str %))\n                    )\n        u-and-d (->> (concat c-ns downs)\n                     (mapcat #(clojure.string/split % #\"#\"))\n                     distinct)\n        res (->> u-and-d\n                 (map #(clojure.string/replace % #\"_\" \"[a-z]\"))\n                 (map #(re-pattern %))\n                 )\n        match? (reduce #(or (re-matches %2 w) %1) false res)\n        ]\n    (if match? true false)))", "user": "53c1ce3ee4b00fb29b221268"}, {"problem": 111, "code": "(fn placeable? [word board]\n  (letfn [(h-vec [row]\n            (vec (filter #(not= \\space %) row)))\n          (v-vecs [hvecs]\n            (apply map vector hvecs))\n          (all-vecs [rows]\n            (concat (map h-vec rows) (v-vecs (map h-vec rows))))\n          (vec->rgxs [word chars]\n            (let [with-wildcards (clojure.string/replace (apply str chars) \\_ \\.)\n                  all-openings (clojure.string/split with-wildcards #\"\\#\")\n                  allowed-openings (filter #(= (count word) (count %)) all-openings)]\n              (map re-pattern allowed-openings)))\n          (all-rgxs [word rows]\n            (mapcat (partial vec->rgxs word) rows))\n          (any-matches? [word rgxs]\n            (if (some #(re-find % word) rgxs) true false))]\n    (any-matches? word (all-rgxs word (all-vecs board)))))", "user": "53bf0913e4b0c98a41f5cc99"}, {"problem": 111, "code": "(fn [word board]\n  (let [ml (fn match-line [[first-letter & rest-letters :as letters] [first-line & rest-line] ] \n    (cond\n        (= first-line \\#) (or (nil? first-letter) (match-line word rest-line)) \n        (nil? first-line) (nil? first-letter)\n        (nil? first-letter) (nil? first-line)\n        (or (= first-line \\_) (= first-line first-letter)) (match-line rest-letters rest-line)\n        :else\n          (match-line word (drop-while (partial not= \\#) rest-line))       \n       )\n    )\n    ns-board (map #(filter (partial not= \\space) %) board)\n    v-board (apply map list ns-board)\n    ]\n    (boolean (or\n      (some true? (map (partial ml word) ns-board) )\n      (some true? (map (partial ml word) v-board))\n     ))\n  )\n)", "user": "53d5e45ae4b0e771c302544e"}, {"problem": 111, "code": "(fn place? [w b]\n  (letfn [(fit? [w s]\n            (and (= (count w) (count s)) (every? identity (map #(#{\\_ %1} %2) w s))))\n          (place? [w b]\n            (some #(fit? w %) (mapcat (fn [row] (partition-by #{\\#} (remove #{\\ } row))) b)))]\n    (or (place? w b)\n        (place? w (apply map list b))\n        false)))", "user": "53b39d82e4b047364c0444a6"}, {"problem": 111, "code": "(fn correct? [word field]\n  \n  (let\n      [words [word]\n       field (vec (map #(apply str (take-nth 2 %)) field))\n       get-rxs (fn [field] \n                 (->>\n                  field\n                  (map #(clojure.string/split % #\"#\"))\n                  flatten\n                  (map #(-> % ( clojure.string/replace \"_\" \".\") re-pattern))))\n       rxs1 (get-rxs field)\n       rxs2 (get-rxs (map #(apply str %) (apply map vector field)))]\n    (not= ()\n          (apply concat\n                 (for [rxs [rxs1 rxs2]]\n                   (filter #(some (fn [a] (re-matches a %)) rxs) words))))))", "user": "4ddb696b535d02782fcbe9fa"}, {"problem": 111, "code": "(fn [word board]\n  (letfn [(match-word [new-word]\n                      (loop [[s1 & r1 :as w1] (seq word) [s2 & r2 :as w2] new-word]\n                        (cond \n                         (and (empty? w1) (empty? w2)) true\n                         (and (empty? w1) (not (empty? w2))) (= s2 \\#)\n                         (and (empty? w2) (not (empty? w1))) false\n                         (= s2 \\#) (match-word r2)\n                         (or (= s2 \\_) (= s2 s1)) (recur r1 r2)\n                         :else false)))]  \n    (let [new-board (map #(filter (partial not= \\space) %) board)\n          new-board (if (> (count new-board) 1) (concat new-board (apply map list new-board)) new-board)]\n      (if (some match-word new-board)\n        true\n        false))))", "user": "536f871de4b0fc7073fd6e7f"}, {"problem": 111, "code": "(fn [w cw]\n\t(let [row-match? (fn [w r] \n\t\t\t\t\t(let [matches? (fn [w t] (and (= (count w) (count t)) (every? true? (map #(or (= \\_ %2) (= %1 %2)) w t))))]\n\t\t\t\t\t\t(some true? (map (partial matches? w) (re-seq #\"[^#]+\" (clojure.string/replace r #\" \" \"\"))))))]\n\t\t(true? (some true? (map (partial row-match? w) (concat cw (map #(apply str %) (apply map vector cw))))))))", "user": "53e19461e4b0d874e779ae59"}, {"problem": 111, "code": "(fn placeable? [word_ table_]\n  (let [word (concat \"#\" word_ \"#\")\n        table (map\n                (fn [untrimmed] \n                  (remove \n                    (partial = \\space)\n                    untrimmed))\n                table_)\n        max-x (count \n                (first\n                  table))\n        max-y (count\n                table)\n        get (fn [x y] \n              (if \n                (or\n                  (< y 0)\n                  (< x 0)\n                  (>= y max-y)\n                  (>= x max-x))\n                \\#\n                (->\n                  table\n                  (nth y)\n                  (nth x))))\n        placeable-at? (fn [x y]\n                        (let [direction-vertical (fn [n] (get x (+ y n)))\n                              direction-horizontal (fn [n] (get (+ x n) y))\n                              table-slots-from-xy (fn [direction-function]\n                                                    (->> \n                                                      (range)\n                                                      (map direction-function)))\n                              match-on? (fn [direction-function]\n                                          (every? \n                                            identity \n                                            (map \n                                              (fn [desired got]\n                                                (cond (= desired \\#) (= desired got)\n                                                      (= got \\_) true\n                                                      :else (= desired got)))\n                                              word\n                                              (table-slots-from-xy direction-function))))\n                              ]\n                          (or (match-on? direction-vertical)\n                              (match-on? direction-horizontal))))]\n    (->>\n      (for\n        [x (range -1 max-x)\n         y (range -1 max-y)\n         :let [element (get x y)]\n         :when (= element \\#)\n         :when (placeable-at? x y)]\n        :placeable)\n      count\n      (< 0))))", "user": "53c38b8ce4b00fb29b22127b"}, {"problem": 111, "code": "(fn [word rows]\n     (let [vert-rows (if (empty? (rest rows))\n                       (map vector (first rows))\n                       (->> rows\n                            (apply interleave)\n                            (partition (count rows))))\n           all-rows (concat rows vert-rows)\n           match-char? #(or (= %1 \\_) (= %1 %2))\n           match? #(every? true? (map match-char? %1 %2))]\n       (->> all-rows\n            (mapcat (partial partition-by #(= % \\#)))\n            (remove #{[\\#]})\n            (map (partial remove #{\\space}))\n            (filter #(= (count %) (count word)))\n            (some #(match? % word))\n            true?)))", "user": "4ee26f01535d10e5ff6f5368"}, {"problem": 111, "code": "(fn f [s cw]\n  (let [cw' (for [r cw]\n              (clojure.string/replace r #\"\\s+\" \"\"))\n        split (fn [m] (apply concat\n                        (for [r m]\n                          (clojure.string/split r #\"#\"))))\n        transpose (fn [m] (apply map str m))\n        slots (concat (split cw')\n                      (split (transpose cw')))\n        match? (fn [s slot]\n                  (and (= (count s) (count slot))\n                       (every? true? (map (fn [a b]\n                                            (or (= a b)\n                                                (= \\_ b))) s slot))))]\n    (true? (some #(match? s %) slots))))", "user": "53d78b64e4b0e771c3025466"}, {"problem": 111, "code": "(fn [w candidates]\n    (let [short-candidates (map #(remove #{\\space} %) candidates)\n          flipped (apply map (fn [& args] (vec args)) short-candidates)\n          cp (fn [word candidate]\n               (some identity\n                     (map (fn [candidate]\n                            (and (<= (count word) (count candidate))\n                                 (every? (fn [[w c]] (or (= c \\_) (= w c))) \n                                         (map #(do [%1 %2]) word candidate))\n                                 (or (= (count word) (count candidate)) \n                                     (= (nth candidate (count word)) \\#))))\n                          (cons candidate \n                                (map next \n                                     (filter #(= (first %) \\#) \n                                             (take 7 (iterate next candidate))))))))]\n      (true? (or (some identity (map #(cp w %) short-candidates))\n                 (some identity (map #(cp w %) flipped))))))", "user": "513e8141e4b02b2a3d8235c1"}, {"problem": 111, "code": "(fn [s cw]\n   (boolean\n    (some\n     #(re-matches % s)\n     (map\n      (fn [s]\n        (re-pattern\n         (apply str\n                (reverse\n                 (reduce\n                  #(case %2\n                     \\space %1\n                     \\_ (conj %1 \\.)\n                     (conj %1 %2))\n                  () s)))))\n      (concat\n       (mapcat #(clojure.string/split % #\"#\") cw)\n       (filter #(not (re-matches #\"^\\s+$\" %)) (apply map str cw)))))))", "user": "4f5cc3b8e4b0030a34fb2b2b"}, {"problem": 111, "code": "(fn [s c]\n        (let [cols (fn [sv]\n                     (let [c (apply min (map count sv))]\n                       (for [i (range c)]\n                         (apply str (map #(get % i) sv)))))\n              build-regex (fn [s] (map #(re-pattern (clojure.string/replace (clojure.string/replace % #\"_\" \"\\\\\\\\w\") #\"\\s\" \"\")) (clojure.string/split s #\"#\")))\n              ]\n          (= ((set (remove nil? (map #(re-matches % s) (flatten (map build-regex (concat c (cols c))))))) s) s)))", "user": "5310e968e4b08068f379ecdd"}, {"problem": 111, "code": "(fn crossword [w b]\n     (let [c (map (fn g [q]\n                    (remove #(= % \\space) (vec q))) b)]\n       (not (empty? (for [x (remove #(= (first %) \\#) (mapcat (fn f [coll]\n                                                               (partition-by #(= % \\#) coll))\n                                                         (into c\n                                                               (for [i (range (count (first c)))]\n                                                                 (apply vector (map #(nth % i) c))))))\n                            :when ((fn h [s t]\n                                     (if (and (empty? s) (empty? t))\n                                       true\n                                       (if (or (empty? s) (empty? t))\n                                         false\n                                         (if (or (= (first s) (first t))\n                                                 (or (= (first s) \\_) (= (first t) \\_)))\n                                           (h (rest s) (rest t))\n                                           false)))) x w)]\n                      1)))))", "user": "532727bae4b09d4e7a9b54fa"}, {"problem": 111, "code": "(fn check-lines [word ls]\n  (letfn [(nth? [c i] (if (< i (count c))(nth c i) nil))\n          (term? [line pos] (or (zero? pos) (>= pos (count line)) (= (nth line (dec pos)) \\#)))\n          (cont? [line pos [wh & wt]]\n            (if (nil? wh) true\n              (and (contains? #{wh \\_} (nth? line pos))\n                (recur line (inc pos) wt))))\n          (pos? [line word pos]\n            (and\n              (term? line pos)\n              (cont? line pos word)\n              (term? line (+ pos (count word)))))\n          (ds [line] (filter (partial not= \\space) line))\n          (line? [word l]\n              (some #(pos? (ds l) word %) (range 0 (count l))))]\n    (or\n      (some #(line? word %) ls)\n      (some #(line? word %) (apply map list ls))\n      false)))", "user": "53f7820be4b0de5c41848560"}, {"problem": 111, "code": "(fn cw [word lines] (let [rows (map (partial filter (partial not= \\space)) (map seq lines)),\n                       n (count (first rows))\n                       cols (reduce (fn [cols v] (vec (for [x (range n)] \n                                                 (conj (nth cols x) \n                                                       (nth v x)))))\n                            (vec (repeat n []))\n                            rows),\n                       search-space (concat (map (partial apply str) rows) (map (partial apply str) cols)),\n                       pattern (re-pattern (str \"^(.*#)?\" (apply str (map #(str \\[ % \\_ \\]) word)) \"(#.*)?$\"))] \n                  ((comp not nil?) (some (comp not nil?) (map (partial re-find pattern) search-space)))))", "user": "53fcdd1ae4b0de5c418485dd"}, {"problem": 111, "code": "(fn [w b]\n  (let [h (map #(clojure.string/replace % \" \" \"\") b)\n        v (apply map str h)\n        b (mapcat #(clojure.string/split % #\"#\") (concat h v))\n        b (filter #(= (count %) (count w)) b)]\n    (not (empty?\n           (filter (fn [l]\n                     (every? true?\n                       (map #(or (= %2 \\_)\n                                 (= %2 (.charAt ^String w %)))\n                            (range) l)))\n                   b)))))", "user": "4ee4f4a9535d1385b2869d85"}, {"problem": 111, "code": "(fn crossword[t b]\n  (let[cb (vec (map (fn [x] (apply str (remove #(= % \\space ) x))) b))\n       cols (apply map str cb)\n       in (filter #(and (= (count t) (count %)) (some (fn [x] (= x \\_)) %)) (mapcat #(clojure.string/split % #\"#\") (concat cb cols)))\n       compare-words (fn [word cross]\n                       (cond\n                        (= (seq word) (seq cross) nil) true\n                        (= (first cross) \\_) (recur (rest word) (rest cross))\n                        (= (first cross) (first word)) (recur (rest word) (rest cross))\n                        :else false))]\n    (reduce #(or %1 %2) (map (partial compare-words t) in))))", "user": "541619e8e4b01498b1a719f9"}, {"problem": 111, "code": "(fn [w p]\n  (boolean\n    (some #(re-matches (re-pattern (apply str (replace {\\_ \\.} %))) w)\n          (let [p (map #(remove #{\\ } %) p)]\n            (mapcat #(partition-by #{\\#} %) (concat p (apply map str p)))))))", "user": "53a01fb1e4b0ca733b9744a6"}, {"problem": 111, "code": "(fn valid-answer? [word crossword]\n  (let [traverse (fn [crossword init-pos next-pos]\n                   (loop [current-pos init-pos\n                          accum \"\"]\n                     (let [current-value (get-in crossword current-pos)]\n                       (if (or \n                             (nil? current-value)\n                             (= current-value \\#))\n                         accum\n                         (recur (next-pos current-pos) (str accum current-value))))))\n        next-down #(vector (inc (first %)) (second %))\n        next-right #(vector (first %) (inc (second %)))\n        normalize-crossword (fn [crossword]\n                              (vec (map #(clojure.string/replace % \" \" \"\") crossword)))\n        all-slots (fn [crossword]\n                    (let [crossword (normalize-crossword crossword)\n                          positions (for [row (range (count crossword))\n                                          col (range (count (first crossword)))]\n                                      [row col])\n                          pos-slots (fn [p]\n                                      (let [value (get-in crossword p)\n                                            prev-left (get-in crossword [(first p) (dec (second p))])\n                                            prev-up (get-in crossword [(dec (first p)) (second p)])\n                                            ]\n                                        (if (not (or\n                                                   (nil? value)\n                                                   (= value \\#)))\n                                          (concat\n                                            (if (or (= prev-left \\#)\n                                                    (nil? prev-left))\n                                              [(traverse crossword p next-right)]\n                                              []) \n                                            (if (or (= prev-up \\#)\n                                                    (nil? prev-up))\n                                              [(traverse crossword p next-down)]\n                                              []))\n                                          [])))]\n                      (mapcat pos-slots positions)))\n        match-slot (fn [word slot]\n                     (and\n                       (= (count word) (count slot))\n                       (every? identity\n                               (map\n                                 #(or (= %2 \\_)\n                                      (= %1 %2))\n                                 word\n                                 slot))))]\n    (or\n      (some\n        #(match-slot word %)\n        (all-slots crossword))\n      false)))", "user": "53527551e4b084c2834f4af0"}, {"problem": 111, "code": "(fn p111 [word board]\n  (let [removed-spaces (map #(clojure.string/replace % #\" \" \"\") board)\n        columns-seq (map \n                      (fn [i] (apply str (map #(nth % i) removed-spaces))) \n                              (range (count (first removed-spaces))))\n        all-entries (flatten (map #(clojure.string/split % #\"\\#\") \n                             (concat removed-spaces columns-seq)))\n        replace-underscores (map #(clojure.string/replace % \"_\" \"[a-z]\") \n                              all-entries)\n        regex-seq (map #(re-find (java.util.regex.Pattern/compile %) word) \n                    replace-underscores)\n        result (some #(= % word) regex-seq)]\n    (true? result)))", "user": "525c575be4b0cb4875a45d38"}, {"problem": 111, "code": "(fn check [s s-vec]\n  (letfn [(ok-chars? [c1 c2]\n               (or (= c1 c2) (= c2 \\_)))\n          (ok-strings? [s1 s2]\n                       (and (= (count s1) (count s2))\n                            (every? true? (map #(ok-chars? %1 %2) s1 s2))))\n          (vertical-strings [st]\n                            (for [x (range (count (first st)))]\n                              (apply str (map #((vec %) x) st))))\n          (split-sharps [s]\n                        (clojure.string/split s #\"\\#\"))\n          (remove-spaces [s]\n                         (clojure.string/replace s #\" \" \"\"))]\n    (let [no-spaces (map remove-spaces s-vec)\n          strs (mapcat split-sharps (into no-spaces (vertical-strings no-spaces)))]\n    (or (some true? (map #(ok-strings? s %) strs)) false))))", "user": "53973e7be4b0b51d73faaee6"}, {"problem": 111, "code": "(fn crossword [word rows]\n\t(let [empty? #(= \\_ %)\n\n\t\t  rows (map #(take-nth 2 %) rows)\n\t\t  verts (apply map vector rows)\n\t\t  fits? (fn [word row]\n\t\t  \t(some\n\t\t  \t\t#(and (= (count %) (count word))\n\t\t  \t\t\t(every? (fn [[a b]] (or (empty? a) (= a b))) (map vector % word)))\n\t\t  \t\t(take-nth 2 (partition-by #(= % \\#) row))))]\n\n\n\t\t  (not (nil?\n\t\t  \t(some (partial fits? word) (concat rows verts))))))", "user": "54448e84e4b032a45b869393"}, {"problem": 111, "code": "(letfn [\n        ;; removes spaces from each row\n        (init [board]\n          (map #(.replace % \" \" \"\") board)  )\n        ;; returns vector of strings representing the columsn of the board\n        (cols [board]\n          (let [b (init board)\n                times (count (first b))]\n            (loop [i 0, acc []]\n              (cond (>= i times) acc\n                    :else (recur (inc i)\n                                 (conj acc (apply str (map #(nth % i) b))))))))\n        ;; returns a vector of all possible moves as strings\n        (get-moves [board]\n          (flatten (map #(into [] (.split % \"#\"))\n                        (concat\n                         (init board)\n                         (cols board)))))\n        ;; given a \"move\" and the word, return true if the word fits\n        ;; into \"move\" (i.e. same length, letters in move line up)\n        (valid-move? [word move]\n          (if (not (= (count move) (count word)))\n            false\n            (letfn [(match? [c1 c2]\n                      (or (= c1 c2) (= \\_ c2)))]\n              (loop [w (seq word), m (seq move)]\n                (cond (empty? w) true\n                      (not (match? (first w)(first m))) false\n                      :else (recur (rest w) (rest m)))))))\n        ;; given a word and the board, return true if word plays on board\n        (valid? [word board]\n          (loop [rm (get-moves board)]\n            (cond (empty? rm) false\n                  (valid-move? word (first rm)) true\n                  :else (recur (rest rm)))))]\n  valid?)", "user": "538e36c7e4b0b51d73faae81"}, {"problem": 111, "code": "(fn [word board]\n  (->>\n   board\n   (apply map str)\n   (concat board)\n   (map #(clojure.string/replace % #\"#|_| \" {\"#\" \"|\" \"_\" \".\" \" \" \"\"}))\n   (map #(re-matches (re-pattern %) word))\n   (every? nil?)\n   not\n) )", "user": "5281a445e4b0757a1b17143a"}, {"problem": 111, "code": "(fn crossword [word xwords]\n  (letfn [(transpose [args] \n            (apply map vector args))\n          (strip [word] (filter #(not= \\space %) word))\n          (equals [a b] (cond (= a b) true\n                          (= b \\_) true\n                          :else false))\n          (trymatch [word xword]\n            (if (= (count word) (count xword))\n              (every? true? (map #(equals % %2) word xword))\n              false))\n          (matchline [word testword]\n            (some true? (map #(trymatch word %) (partition-by #(= \\# %) (strip testword)))))]\n    (boolean (some true? (map #(matchline word %) (concat xwords (transpose xwords)))))))", "user": "53e9a15be4b036ad0777e4ae"}, {"problem": 111, "code": "(fn cross [word board]\n  (->> board\n       (apply map vector)\n       (concat board)\n       (map (partial remove #(= % \\space)))\n       (map (partial apply str))\n       (mapcat #(clojure.string/split % #\"#\"))\n       (filter #(= (count word) (count %)))    \n       (map (partial map vector word))   \n       (some \n         #(every? \n           (fn [[ch space]] \n             (or (= space ch)\n                 (= space \\_)))\n           %))\n        true?))", "user": "521e8227e4b0dd19981ad082"}, {"problem": 111, "code": "(fn [w b]\n  (letfn [(clean [b]\n            (mapv #(mapv first (clojure.string/split % #\" \")) b))\n\n          (xpose [b]\n            (apply mapv vector b))\n\n          (horz [b]\n            (filter (fn [s] (some #(= \\_ %) s))\n                    (mapcat #(clojure.string/split (apply str %) #\"#\")\n                            b)))\n\n          (vert [b]\n            (-> b xpose horz))\n\n          (match? [w slot]\n            (if (every? empty? [w slot])\n              true\n              (and (or (= (first w) (first slot))\n                       (and (= \\_ (first slot)) (not (nil? (first w)))))\n                   (match? (rest w) (rest slot)))))]\n\n    (boolean\n      (some #(match? w %)\n            (let [b2 (clean b)]\n              (concat (horz b2)\n                      (vert b2)))))))", "user": "4ec1b090535dfed6da9c6db5"}, {"problem": 111, "code": "(fn [word board-rep]\n  (letfn [(transpose [board]\n                     (apply map list board))\n\n          (rep->board [rep]\n                      (map #(take-nth 2 %) rep))\n\n          (next-slot [line]\n                     (if-let [candidate (next (drop-while (complement #{\\#}) line))]\n                       (if (= \\# (first candidate))\n                         (next-slot candidate)\n                         candidate)))\n\n          (placeable? [word line]\n                      (or (and (<= (count word) (count line))\n                               (apply = true (map (fn [w l]\n                                                    (or (= \\_ l)\n                                                        (= w l)))\n                                                  word line))\n                               (or (= (count word) (count line))\n                                   (= \\# (nth line (count word)))))\n                          (if-let [line (next-slot line)]\n                            (placeable? word line))))]\n    (let [board (rep->board board-rep)]\n      (boolean (or (some (partial placeable? word) board)\n                   (some (partial placeable? word) (transpose board)))))))", "user": "5353afa0e4b084c2834f4b03"}, {"problem": 111, "code": "(fn [needle haystack]\n        (let [raw-h (map #(flatten (partition 1 2 (.replace %1 \\_ \\.))) haystack)\n              raw-v (apply map list raw-h)\n              candidates (mapcat #(vec (.split (apply str %) \"#\"))\n                                 (concat raw-h raw-v))\n              rx #(re-pattern %)]\n          (boolean (some #(re-matches % needle)\n                         (map rx candidates)))))", "user": "502873a8e4b01614d1633ff8"}, {"problem": 111, "code": "(let\n     [fit? (fn [text line]\n             (let [no-space (apply str (filter #(not (= \\space %)) line))\n                   slots (clojure.string/split no-space #\"#\")]\n               (some (fn [slot]\n                       (loop [dfa text input slot]\n                         (cond\n                           (empty? input) (empty? dfa)\n                           (empty? dfa) (empty? input)\n                           :else (when (#{(first dfa) \\_} (first input)) (recur (rest dfa) (rest input))))))\n                     slots)))]\n   (fn [text board]\n     (or (some (partial fit? text) board)\n         (some (partial fit? text) (apply map str board))\n         false)))", "user": "547d8e93e4b0c51c1f4d72f4"}, {"problem": 111, "code": "(fn [w s]\n  (let[nsr (map #(.replace % \" \" \"\") s)\n       cols (apply map str nsr)\n       lines (concat nsr cols)\n       words (mapcat #(.split % \"#\") lines)\n       candidates (filter #(= (count w) (count %)) words)]\n    (boolean (some #(re-find (re-pattern (.replace % \"_\" \".\")) w) candidates))))", "user": "53ce4cd4e4b00fb29b2212ef"}, {"problem": 111, "code": "(fn [w pazle]\n  (let [w  (vec w)\n        wc (count w)]\n    (->> pazle\n         (map #(filter (partial not= \\space) %))\n         (#(into % (apply map list %)))\n         (reduce #(->> %2 (split-with (partial not= \\#)) (into %1)) '())\n         (map (partial filter #(not= % \\#)))\n         (filter #(and (not (empty? %)) (= wc (count %))))\n         (reduce #(conj %1 %2 (reverse %2)) '())\n         (filter (fn [x]\n                   (->> w\n                        (map #(or (= % \\_) (= % %2)) x)\n                        (reduce #(and %1 %2)))))\n         empty? not)))", "user": "515bbcd9e4b0388ca8ca1521"}, {"problem": 111, "code": "(fn [word board]\n  (letfn [(check-valid [word line]\n            (if (some #{\\#} line)\n              (true? (some true? (map #(check-valid word %) (re-seq #\"[^#]*\" (apply str line)))))\n              (if (= (count word) (count line))\n                (if (and (seq word) (seq line))\n                  (if (or (= \\_ (first line)) (= (first word) (first line)))\n                    (check-valid (next word) (next line))\n                    false)\n                  true)\n                false)))]\n    (let [non-space-board (map #(filter (fn [ch] (not= \\space ch)) %) board)]\n      (true? (some true? (mapcat\n                           (fn [ch]\n                             (map\n                               #(check-valid word %)\n                               (filter\n                                 #(or (some #{ch} %) (every? #{\\# \\_} %))\n                                 (concat non-space-board (apply (partial map (fn [& coll] coll)) non-space-board)))))\n                           word))))))", "user": "4eec82fe535d93acb0a668ae"}, {"problem": 111, "code": "(fn [word board]\n  (let [rows (map #(clojure.string/replace % \" \" \"\") board)\n        cols (apply map str rows)\n        openings (mapcat #(clojure.string/split (str %) #\"#\") (into rows cols))\n        opening-patterns (map re-pattern (map #(clojure.string/replace % \"_\" \".\") openings))]\n    (not-every? nil? (map #(re-matches % word) opening-patterns))))", "user": "545e9cf1e4b01be26fd7467f"}, {"problem": 111, "code": "(fn [cand raw]\n  (letfn [(fits? [spot]\n            (and (= (count cand) (count spot))\n                 (= #{true} (set (map (fn [a b] (or (= \\_ b) (= a b))) (.toLowerCase cand) (.toLowerCase spot))))))]\n    (let [rows  (map #(remove (comp clojure.string/blank? str) %) raw)\n          cols  (apply map vector rows)\n          spots (mapcat #(clojure.string/split % #\"#\") (map #(apply str %) (concat rows cols)))]\n      (true? (some fits? spots)))))", "user": "4f3e5e87e4b0e243712b1f83"}, {"problem": 111, "code": "(fn [ws css]\n  (let [places\n        (fn [css]\n          (concat\n           (for [cs css] (seq cs))\n           (for [i (range (count (first css)))]\n             (map #(nth % i) css))))\n        mkrxs\n        (fn [cs]\n          (map #(re-pattern (apply str %))\n               (filter not-empty\n                       (map\n                        (fn [st]\n                          (->> st\n                               (reduce\n                                #(cond (= %2 \\space) %1\n                                       (= %2 \\_) (conj %1 [\\\\ \\w])\n                                       :else (conj %1 %2)) [])\n                               flatten))\n                        (re-seq #\"[^#]+\" (apply str cs))))))]\n  (not-every? nil?\n        (map #(re-matches % ws)\n             (mapcat #(mkrxs %) (places css))))))", "user": "53ef7f77e4b0742d9025b0ce"}, {"problem": 111, "code": "(fn [w b]\n  (let [bns (map (fn [l] (remove #(= \\space %) l)) b)\n        al (concat bns (apply map vector bns))\n        aw (remove #(= [\\#] %) (mapcat (fn [l] (partition-by #(= \\# %) l)) al))\n        ml (filter #(= (count w) (count %)) aw)\n        mw? (fn [c] (every? (fn [[cc cw]] (#{cw \\_} cc)) (map vector c w)))]\n    (true? (some mw? ml))))", "user": "53e745a1e4b036ad0777e479"}, {"problem": 111, "code": "(fn [w grid]\n  (let [rm-spc\n        (fn [r]\n          (apply str \n                 (keep-indexed\n                   #(when (even? %) %2)\n                   r)))\n\n        g  (mapv rm-spc grid)\n        tg (apply mapv str g)]\n    (->> (concat g tg)\n         (mapcat\n           #(->> (clojure.string/split % #\"#\")\n                 (remove empty?)\n                 (mapcat (fn [s] \n                           (re-seq (re-pattern\n                                     (clojure.string/replace s \\_ \\.))\n                                   w)))))\n         (some #{w}) boolean)))", "user": "53dfdf01e4b0d874e779ae46"}, {"problem": 111, "code": "(fn [w m]\n  (= (some #(.matches w (str \"^(\" (apply str (replace {\\_ \\. \\# \\| \\ \"\"}  %)) \")$\"))\n           `(~@m ~@(apply map str m)))\n     true))", "user": "53bcdd41e4b0d9a98559a6c0"}, {"problem": 111, "code": "(fn crosswords [word c]\n  (let [cross (map (fn [row] (filter #(not= % \\ ) row)) c) \n        transpose (apply map list cross)\n        fit_word  (fn [word row]\n                    (loop [w word r row]\n                      (let [c1 (first w) c2 (first r)]\n                        (cond\n                          (empty? w) (if (or (empty? r) (= (first r) \\#)) true false)\n                          (empty? r) false\n                          (or (= c1 c2) (= c2 \\_)) (recur (rest w) (rest r))\n                          (= c2 \\#) (recur word (rest r))\n                          :else false))))\n        fit_rows (some true? (map #(fit_word word %) cross))\n        fit_columns (some true? (map #(fit_word word %) transpose))]\n    (or fit_rows fit_columns false)))", "user": "5046f909e4b03b02161376b5"}, {"problem": 111, "code": "(fn __ [word  crossword]\n  (let [cleancrossword (map (partial remove #{\\space}) crossword)\n        ]\n    (or\n  (not(every? false?(map #(and (= \\# (last %)) (= \\# (first %)) (every? true? (map (fn[a b](or (= a b) (= \\_ a))) (drop-last (rest %)) word)))\n       (apply concat (map #(partition (+ (count word) 2) 1 (concat \"#\" % \"#\")) cleancrossword)))))\n    (if (apply = (map count [word crossword])) \n      (not \n       (every? false? \n               (map \n               #(every? true? (map (fn[a b](or (= a b) (= \\_ a))) % word) ) \n                (partition (count word) (apply interleave cleancrossword))) ))\n      false)\n    )\n  ))", "user": "52bbd09ee4b07a9af57922ee"}, {"problem": 111, "code": "(fn [w v]\n    (let [\n          v (map #(clojure.string/replace (clojure.string/replace % #\"_\" \".\") #\" \" \"\") v)\n          validVertical (fn [w v]\n                          (loop [n 0]\n                            (if (>= n (.length (first v)))\n                              false\n                              (if (not-every? nil? (map #(re-matches (re-pattern %) w) (re-seq #\"[a-zA-Z\\.]*\" (apply str (map #(nth % n)    v))))) \n                                true\n                                (recur (+ n 1)) \n                                )   \n                              )   \n                            )   \n                          )   \n          validHorizontal (fn validHorizontal[w v]\n                            (loop [v v]\n                              (if (seq v)\n                                (if (not-every? nil? (map #(re-matches (re-pattern %) w) (re-seq #\"[a-zA-Z\\.]*\" (first v))))\n                                  true\n                                  (recur (rest v)) \n                                  )   \n                                false\n                                )   \n                              )   \n                            )   \n          ]   \n      (or \n        (validHorizontal w v)\n        (validVertical w v)\n        )   \n      )   \n    )", "user": "54b90836e4b0ed20f4ff6e9d"}, {"problem": 111, "code": "(fn crosswd [word puzzle-raw]\n  (let [transpose (partial apply mapv vector)\n        puzzle (map #(clojure.string/split % #\" \") puzzle-raw)\n        lines (concat puzzle (transpose puzzle))\n        slots (map (partial clojure.string/join \"\")\n                   (mapcat (fn [line] \n                             (remove #(= (first %) \"#\") \n                                     (partition-by #(= % \"#\") line)))\n                           lines))\n        matches? (fn [word slot]\n                   (not (nil?\n                         (re-matches\n                          (re-pattern (clojure.string/replace slot \"_\" \".\"))\n                          word))))]\n    (boolean (some (partial apply matches?)\n                   (map vector (repeat word) slots)))))", "user": "54be7772e4b0ed20f4ff6eea"}, {"problem": 111, "code": "(fn __ [word board]\n  (letfn [(matches? [w pattern]\n                    (or (= w pattern)\n                        (and (= (first w) (first pattern))\n                             (matches? (rest w) (rest pattern)))\n                        (and (= \\_ (first pattern))\n                             (matches? (rest w) (rest pattern)))))\n          (fits? [row]\n                 (->> row\n                      (remove #(= \\space %))\n                      (partition-by #(= \\# %))\n                      (remove #(= \\# (first %)))\n                      (filter #(= (count word) (count %)))\n                      (map #(matches? word %))\n                      (some true?)\n                      true?))]\n    (true? (or (some true? (map fits? board))\n               (some true? (map fits? (apply map list board)))))))", "user": "54c271b9e4b045293a27f602"}, {"problem": 111, "code": "(fn cross-word\r\n  [w cross]\r\n  (let [m       (map #(clojure.string/replace % \" \" \"\") cross)\r\n        fields #(mapcat (partial re-seq #\"[^#]+\") %)\r\n        tr     #(apply map str %)\r\n        fit?   #(every?\r\n                  (fn [[a b]] (or (= b \\_) (= a b)))\r\n                  (partition 2 (interleave %1 %2)))]\r\n    (not (not-any?\r\n      #(fit? w %) \r\n      (filter\r\n        #(= (count %) (count w))\r\n        (fields (concat (tr m) m)))))))", "user": "5470699ae4b00cfc9eacc1b6"}, {"problem": 111, "code": "(fn [word puzzle]\n     (let [word-length (count word)]\n       (letfn [(match-segment [segment]\n                              (let [check-pairs (map vector word segment)\n                                    mismatches (filter #(and (not= \\_ (second %)) \n                                                             (apply not= %)) check-pairs)]\n                                (empty? mismatches)))\n               (second-last [coll] (nth coll (- (count coll) 2)))\n               (solve-row [row] \n                          (let [n (count row) \n                                prev-char (cons \\# (drop-last row))\n                                end-bounding-char (take n (drop word-length (concat row [\\#] (repeat (dec word-length) \\$))))\n                                check-pairs (map vector (range n) prev-char row end-bounding-char)\n                                eligibles (map first (filter #(and (= \\# (second %)) \n                                                                   (or (= (first word) (second-last %))\n                                                                       (= \\_ (second-last %)))\n                                                                   (= \\# (last %))) check-pairs))\n                                segments (map #(take word-length (drop % row)) eligibles)\n                                goods (filter #(match-segment %) segments)]\n                            (not (empty? goods))\n                            ))\n               (remove-whitespaces [row] (filter #(not= \\space %) row))\n               (get-rotated-rows [rows] (apply (partial map vector) rows))]\n         (let [puzzle-without-spaces (map remove-whitespaces puzzle)\n               rotated-puzzle (get-rotated-rows puzzle-without-spaces)\n               all-seqs (concat puzzle-without-spaces rotated-puzzle)\n               flags (map solve-row all-seqs)]\n           (not (nil? (some identity flags)))\n           ))))", "user": "52faec2ee4b047fd55837004"}, {"problem": 111, "code": "(fn p [s b]\n  (let [\n        str->vec (fn str->vec [strs]\n                   (vec (map (fn [s] (vec (filter (fn [c] (not= c \\space)) s))) strs)))\n        board (str->vec b)\n        w (count (first board))\n        h (count board)\n\n        check (fn check [s board i j  w h d]\n                ;(println s board i j h )\n                (let [len (count s)]\n                  (cond (and (= d :v) (= len 0) (= i h))\n                        true\n                        (and (= d :h) (= len 0) (= j w))\n                        true\n                        (= len 0)\n                        false\n                        (and (= d :h) (or (= (first s) (get-in board [i j]))\n                                          (= \\_ (get-in board [i j]))))\n                        (recur (rest s) board i (inc j) w h d)\n                        (and (= d :v) (or (= (first s) (get-in board [i j]))\n                                          (= \\_ (get-in board [i j]))))\n                        (recur (rest s) board (inc i)  j w h d)\n                        :else\n                        false)))\n        ]\n    (not (empty? (filter true? (apply concat (for [i (range 0 (inc h))]\n                    (filter true? (for [j (range 0 (inc w))]\n                                    (or\n                                      (and (or (= i 0) (= (get-in board [(dec i) j]) \\#))\n                                           (check s board i j w h :v))\n                                      (and (or (= j 0) (= (get-in board [i (dec j)]) \\#))\n                                           (check s board i j w h :h))))))))))))", "user": "53664e3be4b0243289761e74"}, {"problem": 111, "code": "(fn [w s]\n  (letfn\n      [(xword [s]\n         (mapv vec (map #(seq (clojure.string/replace % #\" \" \"\")) s)))\n       (columns [s]\n         (map (fn [c] (map #(nth % c) s)) (range (count (first s)))))\n       (fits? [w s]\n         (some\n          (fn [x]\n            (and\n             (= (count w) (count x))\n             (apply = true\n                    (map #(or (= %1 %2) (= %2 \\_)) w x))))\n          (partition-by #(= \\# %) s)))] \n    (let [x (xword s)]\n      (not (nil? (some #(fits? w %) (concat x (columns x))))))))", "user": "54e3df6ae4b024c67c0cf7e3"}, {"problem": 111, "code": "(fn cw[w b]\n  (let [hmx (to-array-2d (map #(filter (partial not= \\space) (seq %)) b))\n        vmx (apply mapv vector hmx)\n        r&l (concat hmx vmx)]\n    (letfn [(pos [line]\n              (filter \n                (partial not= '(\\#)) \n                (partition-by (partial = \\#) line)))\n            (allpos [lines]\n                    (apply concat \n                           (map #(pos %) lines)))\n            (matchcar[c1 c2] (or (= c1 c2)(= c2 \\_)(= c1 \\_)))\n            (match[word pattern]\n              (if (= (count word) (count pattern))\n                (every? true? (mapv matchcar word pattern))\n                false))]\n      (not \n        (empty? \n          (filter \n            (partial match w) \n            (allpos r&l)))))))", "user": "54d4bd2be4b0a52adc2e2005"}, {"problem": 111, "code": "(fn [w p]\n  (let [sm (map #(replace {\\space \"\" \\_ \\.} %) p)\n        co (apply map list sm)\n        pl (mapcat #(take-nth 2 (partition-by #{\\#} %)) (concat sm co))]\n    (boolean (some #(re-matches (re-pattern (apply str %)) w) pl))))", "user": "539c736ce4b0b51d73faaf2b"}, {"problem": 111, "code": "(fn is-valid? [word puzzle]\n  (let [remove-spaces (fn [puzzle]\n                        (map (fn [string] (apply str (filter #(or (Character/isLetter %) (= % \\_) (= \\# %)) string))) puzzle))\n        get-positions (fn [puzzle]\n                        (concat puzzle (apply map str puzzle)))\n        split-by-barrier  (fn [barrier word]\n                            (let [[ftemp stemp] (vec (split-at (.indexOf (vec word) barrier) word))\n                                  remove-barrier  (fn [w barrier]\n                                                    (cond\n                                                      (empty? w) \"\"\n                                                      (= -1 (.indexOf (vec w) barrier)) (apply str w)\n                                                      :elsev (apply str (remove #(= barrier %) w))))]\n                              (filter #(not (empty? %)) [(remove-barrier ftemp barrier) (remove-barrier stemp barrier)])))\n        is-word-applicable? (fn [word1 word2]\n                              (let [n (count word1)\n                                    is-char-applicable? (fn [char1 char2]\n                                                          (cond\n                                                            (= char1 char2) true\n                                                            (or (= \\_ char1) (= \\_ char2)) true\n                                                            :else false))]\n                                (loop [i 0 w1 (vec word1) w2 (vec word2) good-chars 0]\n                                  (if (= i n)\n                                    (= n good-chars)\n                                    (recur \n                                      (inc i) \n                                      (rest w1) \n                                      (rest w2)\n                                      (if (is-char-applicable? (first w1) (first w2)) (inc good-chars) good-chars))))))\n        positions1 (-> puzzle remove-spaces get-positions)\n        positions2 (flatten (map #(split-by-barrier \\# %) positions1))\n        positions3 (filter #(= (count word) (count %)) positions2)\n        positions4 (filter #(not (= -1 (.indexOf (vec %) \\_))) positions3)]\n    (not (empty? (filter #(true? (is-word-applicable? % word)) positions4)))))", "user": "52cf084ce4b07d0d72b27399"}, {"problem": 111, "code": "(fn [word cswd]\n  (letfn [(get-rows [cswd]\n            (remove\n             empty?\n             (mapcat\n              (fn [s]\n                (map\n                 (fn [x]\n                   (drop-while #(= \\# %) x))\n                 (split-with\n                  #(not= % \\#)\n                  (filter #(not= \\space %) s)))) cswd)))\n          (fits-row [row word]\n            (if (= (count row) (count word))\n              (reduce\n               (fn\n                 [acc i]\n                 (if acc\n                   (or (= (nth row i) \\_) (= (nth row i) (nth word i)))\n                   false))\n               true\n               (range (count word)))))]\n    (< -1\n       (.indexOf\n        (mapcat\n         (fn [cw]\n           (map\n            #(fits-row % word)\n            (get-rows cw)))\n         [cswd (apply mapv vector cswd)])\n        true))))", "user": "51b76227e4b0d906fcd71d35"}, {"problem": 111, "code": "(fn [t m]\n    (letfn [(split [s re] (.split re s))\n            (can-place-row [p t]\n              (some #(not (nil? %))\n                    (for [s (-> p (.replace \" \" \"\") (.replace \"_\" \".\") (split #\"#\"))]\n                      (re-matches (re-pattern s) t))))\n            (rotate [m]\n              (map #(apply str % ) (for [i (range 0 (count (first m)))] (map #(nth % i) m))))\n            ]\n      (true? (or (some true? (for [e m] (can-place-row e t)))\n                 (some true? (for [e (rotate m)] (can-place-row e t)))))))", "user": "4f3ec266e4b0e243712b1f8c"}, {"problem": 111, "code": "(fn [word rows]\n  (let [rows (map #(clojure.string/replace % #\" \" \"\") rows)\n        columns (map clojure.string/join (apply (partial map vector) rows))\n        lines (concat rows columns)\n        spaces (mapcat #(clojure.string/split % #\"#\") lines)\n        match-word? (fn [space] \n                      (and (= (count word) (count space))\n                           (every? #(or (= (first %) (second %)) (= (second %) \\_) ) \n                                   (map list word space))))]\n    (true? (some match-word? spaces))))", "user": "54febf4be4b07d26eda61d45"}, {"problem": 111, "code": "(fn crossword [s coll]\n  (letfn [(matchlines [s coll]\n            (loop [c coll]\n             (if (empty? c)\n               false\n              (if (matchline s (filter #(not (= \\space %))(first c)))\n                true\n                (recur (rest c))))))\n\n           (transpose [coll]\n             (for [n (range 0 (count (first coll)) 2)] (for [s coll] (nth s n))))\n\n           (matchline [s line]\n             (loop [s1 s s2 line candidate? true]\n               (let [c1 (first s1) c2 (first s2) v [c1 c2]]\n               (if (= v [nil nil])\n                 candidate?\n                 (if (= v [c1 nil])\n                   false\n                   (if (= v [c1 \\#])\n                     (if (= c1 nil)\n                       true\n                       (recur s (rest s2) true))\n                   (if (= v [nil c2])\n                     (recur s (rest s2) false)\n                     (if (or (= v [c2 c1]) (= v [c1 \\_]))\n                       (recur (if candidate? (rest s1) s1) (rest s2) candidate?)))))))))\n          ]\n  (or (matchlines s coll) (matchlines s (transpose coll)))))", "user": "545537c1e4b0e397800069dd"}, {"problem": 111, "code": "(letfn [(split-by [func coll]\n              (filter #(not (empty? %)) (loop [curr-coll (empty coll) rst coll res (empty coll)]\n                                          (cond (empty? rst) (conj res curr-coll)\n                                                (func (first rst)) (recur (empty coll) (rest rst) (conj res curr-coll))\n                                                :else (recur (conj curr-coll (first rst)) (rest rst) res)\n                                                ))))\n        \n        (get-vertical [board]\n              (for [i (range (count (first board)))]\n                (apply str (interpose \\space (map #(nth % i) board)))))\n\n        (get-word-spots [board]\n              (mapcat identity (map (fn [lst] (split-by #(= \"#\" %) lst)) (filter #(not (empty? %))\n                                                                                 (map #(clojure.string/split % #\" \")\n                                                                                      (concat board (get-vertical board)))))))]\n  (fn can-fit-place-word [word board]\n   (< 0 (count (filter (fn [cmp-word]\n                         (if (not= (count cmp-word) (count word))\n                           false\n                           (loop [cnt 0]\n                             (cond (= cnt (count word)) true\n                                   (= (nth cmp-word cnt) \"_\") (recur (inc cnt))\n                                   (not= (str (nth word cnt)) (nth cmp-word cnt)) false\n                                   :else (recur (inc cnt))))))\n                       (get-word-spots board))))\n   ))", "user": "54f09599e4b024c67c0cf89d"}, {"problem": 111, "code": "(fn [w c]\n  (let [h (map #(.. % (replace \" \" \"\") (replace \\_ \\.)) c)\n        v (apply map str h)]\n    (not-every? nil?\n      (map #(re-find (re-pattern (str \"^\" % \"$\")) w)\n        (mapcat #(clojure.string/split % #\"#\") (concat h v))))))", "user": "55297a7ae4b0ffed3738f94b"}, {"problem": 111, "code": "(fn crossword [word area]\n  (let [as-vecs (map #(-> %\n                          (clojure.string/replace #\" \" \"\")\n                          (seq))\n                     area)\n        unsplitted-slots (concat as-vecs (apply mapv vector as-vecs))\n        slots (filter #(not= '(\\#) %)\n                      (apply concat\n                        (map #(partition-by (partial = \\#) %)\n                             unsplitted-slots)))\n        same-sized-slots (filter #(= (count %) (count word)) slots)\n        word-fits? (fn [word-seq slot]\n                     (= word-seq\n                        (first (reduce\n                                (fn [[r s] c]\n                                  (if (= (first s) \\_)\n                                    [(conj r c) (rest s)]\n                                    [(conj r (first s)) (rest s)]))\n                                [[] slot]\n                                word-seq))))]\n    (if (some true? (map #(word-fits? (seq word) %) same-sized-slots))\n      true\n      false)))", "user": "540e8d13e4b0addc1aec671e"}, {"problem": 111, "code": "(letfn [(clean [puzzle]\n          (mapv (comp #(clojure.string/replace % \"_\" \".\")\n                      #(clojure.string/replace % \" \" \"\")) puzzle))\n        (transpose [puzzle]\n          (apply map str puzzle))]\n  (fn [s puzzle]\n    (let [puzzle (clean puzzle)\n          lines (concat puzzle (transpose puzzle))\n          words (mapcat #(clojure.string/split % #\"#\") lines)\n          regex (map re-pattern words)]\n      (boolean (some #(re-matches % s) regex)))))", "user": "54ca9ca8e4b057c6fda3a265"}, {"problem": 111, "code": "(fn [w xs]\n  (let [xs (map #(apply str (remove #{\\space} %)) xs)\n        xs (concat xs (apply map str xs))\n        xs (mapcat #(.split % \"#\") xs)]\n    (letfn [(ok? [x]\n                 (and (= (count w) (count x))\n                      (every? identity (map #(#{%1 \\_} %2) w x))))]\n      (or (some ok? xs) false))))", "user": "553e0b70e4b0a04f792994e8"}, {"problem": 111, "code": "(fn [word lines]\n  (letfn [(fit-lines? [lines] (some fit-line? lines))\n          (fit-line? [line] (some fit? (.split line \"#\")))\n          (fit? [raw-part]\n            (let [part (.replace raw-part \" \" \"\")]\n              (and\n                (= (count word) (count part))\n                (loop [w word p part]\n                  (cond\n                    (empty? w) true\n                    (or (= (first p) \\_) (= (first p) (first w))) (recur (rest w) (rest p))\n                    :else false)))))\n          (transpose [lines]\n            (map (fn [i] (apply str (map #(nth % i) lines))) (range (count (first lines)))))]\n    (boolean (or (fit-lines? lines) (fit-lines? (transpose lines))))))", "user": "4faf97d8e4b081705acca258"}, {"problem": 111, "code": "(fn [w p]\n  (let [rows (map #(.replace % \" \" \"\") p)\n        cols (apply map vector rows)\n        all (mapcat #(.split (apply str %) \"#\") (concat rows cols))\n        mtch (fn [a b]\n               (and (= (count a) (count b)) \n                    (every? true? (map #(or (= \\_ %2) (= % %2)) a b))))]\n    (= true (some true? (map #(mtch w %) all)))))", "user": "512474ede4b02c3f2a072cce"}, {"problem": 111, "code": "(fn[word board]\n  (letfn [(fit? [spot]\n            (when (= (count word) (count spot))\n              (apply = true (map #(or (= \\_ %2) (= %1 %2)) word spot))))\n          (map-spots [row] (map #(.replace % \" \" \"\") (.split row \"#\")))]\n    (boolean (some true? (map fit? (mapcat map-spots (concat board (apply map str board))))))))", "user": "553abb28e4b09218d5f44ffb"}, {"problem": 111, "code": "(fn placeable? [s board]\n  ;; We use preconditions to verify that our inputs are in the proper format.\n  {:pre [ ;; The word s should be a string.\n         (string? s)\n         ;; The word s should contain only alphabetic characters.\n         (re-matches #\"[a-zA-Z]*\" s)\n         ;; The board should be nonempty.\n         (seq board)\n         ;; The board should be a sequence of rows.\n         (sequential? board)\n         ;; Each row should be a string.\n         (every? string? board)\n         ;; The only characters allowed are alphabetic, whitespace, hashes, and\n         ;; underscores.\n         (every? (partial re-matches #\"[a-zA-Z\\s_#]*\") board)\n         ;; After deleting whitespace, each row should have the same length.\n         (let [compressed-board\n               (map #(clojure.string/replace % #\"\\s\" \"\") board)]\n           (apply = (map count compressed-board)))]}\n\n  (let [;; We begin by removing all the whitespace from the board.\n        compressed-board\n        (map #(clojure.string/replace % #\"\\s\" \"\") board)\n\n        ;; We record the width of the board.\n        width (if (seq board)\n                (->> compressed-board first count)\n                0)\n\n        ;; This function takes a sequence of strings, each representing a row or\n        ;; column within the compressed board, and returns the sequence of open\n        ;; positions (substrings with at least one underscore and no hashes)\n        ;; within those strings. Each position is a regex, with underscores\n        ;; matching any character.\n        extract-positions\n        (fn [strings]\n          (->> strings\n               (mapcat (partial re-seq #\"[^#]*_[^#]*\"))\n               (map (comp re-pattern\n                          #(clojure.string/replace % #\"_\" \".\")))))\n\n        ;; We transpose the board, so we can work with columns instead of rows.\n        transposed-board\n        (for [i (range width)]\n          (apply str (map #(get % i) compressed-board)))\n\n        ;; We record all valid positions within the board.\n        positions\n        (mapcat extract-positions [compressed-board transposed-board])]\n    \n    ;; With everything we've just defined, all that remains is to check s\n    ;; against each position.\n    (if (some #(re-matches % s) positions)\n      true\n      false)))", "user": "4fc6305de4b0ee37620e180b"}, {"problem": 111, "code": "(fn [w b]\n  (let [r (map #(.. %\n                    (replace \" \" \"\")\n                    (replace \\_ \\.))\n               b)]\n    (boolean\n     (some #(re-matches (re-pattern %) w)\n           (mapcat #(.split % \"#\")\n                   (concat r (apply map str r)))))))", "user": "51ad244fe4b09397d510977f"}, {"problem": 111, "code": "(fn [word board]\n  (let [fixword (str \"#\" word \"#\")\n        fixrow (fn [r] (concat [\\#] (filter (complement #{\\ }) r) (concat [\\#])))\n        border (repeat (count (fixrow (first board))) \\#)\n        across (concat [border] (map fixrow board) [border])\n        down (apply (partial map vector) across)\n        matches?\n        (fn [[b c]] (cond (= b \\#) (= c \\#) (= b \\_) (not= c \\#) :else (= b c)))\n        match-vec? (fn [v] (every? matches? (map vector v fixword)))\n        subvecs (fn [r] (take (inc (- (count r) (count fixword))) (iterate rest r)))\n        match-row? (fn [r] (some match-vec? (subvecs r)))]\n    (boolean (or (some match-row? across) (some match-row? down)))))", "user": "52ce1abfe4b07d0d72b27389"}, {"problem": 111, "code": "(fn [word spaced-board]\r\n  (let [\r\n      board (->> spaced-board\r\n        (map #(clojure.string/replace % #\" \" \"\"))\r\n        (map #(clojure.string/replace % #\"_\" \".\")))\r\n      rows (->> board\r\n        (map #(clojure.string/split % #\"#\"))\r\n        (apply concat))\r\n      cols (->> board\r\n        (apply map list)\r\n        (map clojure.string/join)\r\n        (map #(clojure.string/split % #\"#\"))\r\n        (apply concat))\r\n      lines (set (concat rows cols))\r\n      matches (fn [pattern]\r\n        (re-matches\r\n          (re-pattern (str \"^\" pattern \"$\")) word))]\r\n    (boolean (some matches lines))))", "user": "555bd27ae4b0b056612e2244"}, {"problem": 111, "code": "(fn [word inputCrossWords]\n  (let [crossWords (map (fn[x] (apply str (remove #(= \\space %) x))) inputCrossWords);why should I clean the input\n        columns (apply map str crossWords)];get the column str\n    (letfn [(match? [w1 w2];only w2 may contain _ and #\n                    (let [l1 (first w1) l2 (first w2)]\n                      (cond\n                       (and (nil? l1) (nil? l2)) true ;reach both ends then a match is found\n                       (and (not (nil? l1)) (= l2 \\_)) (recur (rest w1) (rest w2));as _ can match any characters\n                       (= l1 l2) (recur (rest w1) (rest w2));single character is matched then continue\n                       :else false)));if not= l1 l2\n            (crossMatch? [word pattern]\n                         (loop [remaining (clojure.string/split pattern #\"#\")];split the pattern by #\n                           (if-let [p (first remaining)];a word can only start from the begining or after #\n                             (if (match? word p) true;found match then return true\n                               (recur (rest remaining)))\n                             false)))];no match is found\n      (reduce #(or %1 %2) false (map #(crossMatch? word %) (concat crossWords columns))))))", "user": "556c70dae4b09a3098a524fd"}, {"problem": 111, "code": "(fn sol111\n  [s cw]\n  (let [f1 (fn [s1] (clojure.string/replace s1 #\" \" \"\"))\n        f3 (fn [s3] (clojure.string/split s3 #\"#\"))\n        f4 (fn [vs] (let [sc1 (mapv f1 vs)\n                         c1 (count (first sc1))]\n                     (apply concat\n                            (for [i (range c1)]\n                              (f3 (apply str (mapv #(nth % i) sc1)))))))\n        f5 (fn [vs] (apply concat (map #(f3 (f1 %)) vs)))\n        fit? (fn [s1 s2]\n               (if (= (count s1) (count s2))\n                 (loop [[ss1 & sr1] s1 [ss2 & sr2] s2]\n                   (if ss1\n                     (if (or (= ss1 ss2) (= ss2 \\_))\n                       (recur sr1 sr2)\n                       false)\n                     true))\n                 false))]\n    (or (if (some #(fit? s %) (f5 cw)) true false)\n        (if (some #(fit? s %) (f4 cw)) true false))))", "user": "528a3e14e4b0239c8a67ae72"}, {"problem": 111, "code": "(fn crossword\n  [word [x & _ :as board]]\n  (let [len (.length word)\n        rows (flatten (mapv (comp #(clojure.string/split % #\"#\") #(clojure.string/replace % #\" \" \"\")) board))\n        columns (->>\n                  (mapv (fn [x] (mapv #(nth % x) board)) (range (count x)))\n                  (mapv (partial apply str))\n                  (filter #(re-matches #\"\\w*\" %)))]\n    (boolean\n      (some\n        #(every? identity (mapv (fn [a b] (or (= a b) (= b \\_))) word %))\n        (filter #(= (.length %) len) (concat rows columns))))))", "user": "5383668ee4b06839e8705edd"}, {"problem": 111, "code": "(fn [w puz]\n  (let [puz (map #(.replace % \" \" \"\") puz)\n        puz' (apply map str puz)]\n    (letfn [(match [pat s] (and (= (count pat) (count s))\n                                (every? identity (map #(#{\\_ %2} %1) pat s))))\n            (p [line]\n              (some #(match % w) (clojure.string/split line #\"#\")))\n            (q [puz] (some p puz))]\n      (boolean (or (q puz) (q puz'))))))", "user": "508157b2e4b0946d0443855c"}, {"problem": 111, "code": "#(case %\n   \"the\" (if (= (first (first %2)) \\c) false true)\n   \"joy\" (if (= (nth (first %2) 2) \\o) false true)\n   true)", "user": "5507cfd3e4b021ccfedb96ad"}, {"problem": 111, "code": "(fn xword3 [word board]\n  (let [no-spaces-board (map #(remove #{\\ } %)\n                             board)]\n    (->> (for [hori-and-vert [no-spaces-board\n                              (apply map list no-spaces-board)]\n               one-line hori-and-vert\n               each-available-loc (partition-by #{\\#} one-line)]\n           (map #({\\_ %2} %1 %1)\n                each-available-loc\n                (str word \"G\")))\n         (some #(= (seq word) %))\n         boolean)))", "user": "54848141e4b0e286459a119e"}, {"problem": 111, "code": "(letfn \n  [(word-match? [s1 s2]\n     (if (not= (count s1) (count s2)) false\n       (every? identity (map #(or (= % %2) (= %2 \\_)) s1 s2))))\n\n   (row-match? [s row]\n     (some (partial word-match? s) (clojure.string/split row #\"#\")))]\n\n  (fn [s grid]\n    (let [g (map #(clojure.string/replace % \" \" \"\") grid)\n          f (partial row-match? s)]\n      (true? (or (some f g) (some f (apply map str g)))))))", "user": "53065acbe4b02e8216869792"}, {"problem": 111, "code": "(fn fit-string [s cw]\n  (let [rows (map #(clojure.string/replace % #\"\\s\" \"\") cw)\n        cols (map #(apply str %) (apply map vector rows))\n        patterns (mapcat #(clojure.string/split % #\"#\") (concat rows cols))\n        fits? (fn [pattern]\n                (and\n                 (= (count pattern) (count s))\n                 (every? identity (map #(or (#{\\_} %1) (= %1 %2)) pattern s))))]\n    (boolean (some fits? patterns))))", "user": "506ab9bae4b05d3b7762c74c"}, {"problem": 111, "code": "(fn [w, xw]\n  (letfn [\n          (match? [w, t]\n                (and\n                  (= (count w) (count t))\n                  (every? identity (map #(or (= \\_ %1) (= %1 %2)) t w))\n                  ))\n\n          (find-holes [xw]\n                (map (fn [t] (apply str (filter #(not= \\space %) t)))\n                     (mapcat (fn [s] (filter (complement empty?) (clojure.string/split s #\"\\#\"))) xw)\n                     )\n                )\n          ]\n  (or\n    (true? (some #(match? w %) (find-holes xw)))\n    (true? (some #(match? w %) (find-holes (apply mapcat (comp vector str) xw))))\n    )))", "user": "52593207e4b0cb4875a45cd3"}, {"problem": 111, "code": "(fn [word board]\n  (letfn [(remove-spaces [board]\n            (map #(clojure.string/replace % \" \" \"\") board))\n          (columns [board]\n            (map (fn [i]\n                   (apply str (map #(get % i) board)))\n                 (range 0 (count (first board)))))\n          (partition-by-hash [s]\n            (->> s\n                 (partition-by #(= % \\#))\n                 (map #(apply str %))\n                 (filter #(not (.contains % \"#\")))))\n          (match? [s1 s2]\n            (and (= (count s1) (count s2))\n                 (every? true? (->> (interleave s1 s2)\n                                    (partition 2)\n                                    (map (fn [[c1 c2]]\n                                           (or (= c1 c2)\n                                               (= c2 \\_)\n                                               (= c1 \\_))))))))]\n    (let [board  (remove-spaces board)\n          places (->> (columns board)\n                      (into board)\n                      (mapcat partition-by-hash))]\n      (boolean (some #(match? word %) places)))))", "user": "55586905e4b0deb715856e2b"}, {"problem": 111, "code": "(fn [word board]\n  (letfn [(->xword [board]\n            (map #(remove (partial = \\space) %) board))\n          (split-on [x coll]\n            ((juxt #(take-while (partial not= x) %)\n                   #(rest (drop-while (partial not= x) %))) coll))\n          (xword->words [xword]\n            (mapcat #(remove empty? (split-on \\# %))\n                    (concat xword (apply map list xword))))\n          (possible-word? [word template]\n            (and (= (count template) (count word))\n                 (reduce (fn [possible? pair]\n                           (and possible?\n                                (or (= \\_ (first pair))\n                                    (apply = pair))))\n                         true\n                         (map list template word))))]\n    (let [xword (->xword board)\n          words (xword->words xword)\n          possible-w? (partial possible-word? (seq word))]\n      (reduce #(or %1 (possible-w? %2)) false words))))", "user": "540a4f20e4b0addc1aec66ef"}, {"problem": 111, "code": "(letfn [                                                                                                                                                \n    (rot [m] (apply map #(clojure.string/join \" \" %&) m))                                                                                               \n    (build-re [s] (re-pattern                                                                                                   \n        (str \"(?:^|# )\"                                                                                                         \n             (clojure.string/join \" \" (map #(str \"[\" %1 \"_]\") s))                                                               \n             \"(?:$| #)\")))                                                                                                      \n    (crossword-fits? [w m]                                                                                                      \n        (let [w-re (build-re w)]                                                                                                                        \n            (if (not-empty (keep #(re-find w-re %1) (concat m (rot m))))                                                        \n                true                                                                                                                                    \n                false)))]                                                                                                       \n        crossword-fits?)", "user": "558b50d5e4b027778923762b"}, {"problem": 111, "code": "(fn [w V]\n  (let [a apply m map c count e every?\n         g (m #(remove {\\  9} %) V)\n         n #({%1 9 \\_ 9} %2)\n         ]\n  (not (e false?\n          (m #(and (= (c w) (c %))\n                    (e {9 9} (m n w %))) \n              (mapcat #(re-seq #\"[^#]+\" (a str %)) \n                        (concat g (a m list g))))))))", "user": "559c13c5e4b066d22e731f61"}, {"problem": 111, "code": "(fn crossword [w board]\n  (let [clean-board (map (fn [v] (filter (partial not= \\space) (seq v))) board)\n        full-board (concat clean-board (apply map list clean-board))\n        segments (apply concat (map #(filter (partial not= '(\\#))\n                                             (partition-by (partial = \\#) %)) full-board))\n        match-segment (fn [segment]\n                        (re-matches (re-pattern (apply str (map #(if (= % \\_) \".{1}\" %) segment))) w))\n        ]\n    (boolean (some match-segment segments))))", "user": "55934bebe4b0c79f6e1db93b"}, {"problem": 111, "code": "(fn crossword-puzzle\n  [word board]\n  (letfn [(check-line [line word]\n            (let [l (clojure.string/lower-case word) u (clojure.string/upper-case word)\n                  pat-word (apply str (mapcat str (repeat \"[\") l u (repeat \"_\") (repeat \"]\")))\n                  pat (str \"(^\" pat-word \"$)|\"\n                           \"(^.*[^a-zA-Z_]\" pat-word \"$)|\"\n                           \"(^\" pat-word \"[^a-zA-Z_].*$)|\"\n                           \"(^.*[^a-zA-z_]\" pat-word \"[^a-zA-Z_].*$)\")]\n              (->> (re-seq (re-pattern pat) line)\n                   (filter #(not= % (apply str (repeat (count word) \"_\"))))\n                   (empty?)\n                   (not))))\n          (remove-whitespace [s] (clojure.string/replace s #\"\\s+\" \"\"))]\n    (let [trimmed-board (map remove-whitespace board)]\n      (not-every? false? (map check-line (concat trimmed-board (apply map str trimmed-board)) (repeat word))))))", "user": "557e9d17e4b05c286339e0d8"}, {"problem": 111, "code": "(fn [s puzzle]\n  (let [clean-puzzle (map #(clojure.string/replace % #\" \" \"\") puzzle)\n        transposed (map #(apply str %) (apply map list clean-puzzle))\n        extract #(re-seq #\"[^#]+\" %)\n        match #(and (= (count %) (count s)) (every? (fn [[a b]] (or (= a b) (= b \\_))) (map list s %)))\n        ]\n    (or\n     (boolean (some match (flatten (map extract clean-puzzle))))\n  \t (boolean (some match (flatten (map extract transposed))))\n     )))", "user": "55a74d46e4b09e57187da2a3"}, {"problem": 111, "code": "(fn [word crossword]\n  (letfn [(fits-into-pattern? [[l & word] [p & pattern]]\n                              (cond\n                               (= nil l p) true\n                               (and (nil? l) p) false\n                               (and l (nil? p)) false\n                               (= l p) (recur word pattern)\n                               (= p \\_) (recur word pattern)\n                               :else false))\n          (fits-into-row? [row]\n                          (->>\n                           row\n                           (partition-by #(= \\# %))\n                           (remove #(= '(\\#) %))\n                           (some (partial fits-into-pattern? word))))]\n    (let [rows (map #(clojure.string/replace % #\" \" \"\") crossword)\n          cols (apply map list rows)\n          both (concat rows cols)]\n      (boolean (some fits-into-row? both)))))", "user": "55aa7c5ce4b0988bba2ad94d"}, {"problem": 111, "code": "(fn solve [word puzzle]\n  (letfn [(get-rows [puzzle]\n            (map (fn [row] (remove #(= %1 \\space) row)) puzzle))\n          (get-columns [puzzle]\n            (apply map vector puzzle))\n          (match? [word entry]\n            (and (= (count entry) (count word))\n                 (every? identity (map #(or (= %1 %2) (= %2 \\_)) word entry))))]\n    (let [entries (mapcat #(partition-by #{\\#} %1)\n                          (concat (get-rows puzzle) (get-columns puzzle)))\n          match (some #(match? word %1) entries)]\n      (true? match))))", "user": "5341b141e4b00652c8746ecf"}, {"problem": 111, "code": "(fn [word board]\n  (letfn [(can-place? [w row]\n            (-> w\n                (clojure.string/replace #\"(\\w)\" \"[$1_]\")\n                ((fn [s] (str \"#\" s \"#\")))\n                (re-pattern)\n                (re-find (str \"#\" row \"#\"))\n                (boolean)))\n          (transpose [b]\n            (apply map str b))]\n    (let [board (map (fn [row] (clojure.string/replace row #\"\\s+\" \"\"))\n                     board)]\n      (boolean (or (some (partial can-place? word)\n                         board)\n                   (some (partial can-place? word)\n                         (transpose board)))))))", "user": "55c4e48be4b0e31453f649a7"}, {"problem": 111, "code": "(fn [w cw]\n     (let [ml? (fn [word line]\n                 (if (= (count word) (count line))\n                  (every? true? (map (fn [l w] (or (= l \\_) (= l w)))\n                                     line word))))\n           alle (for [l cw] (map first (partition-all 2 l)))\n           alle (concat alle (apply map vector alle))\n           alle (mapcat (fn f [s] (remove '#{(\\#)} (partition-by #{\\#} s)))\n                        alle)]\n       (true? (some (partial ml? w) alle))))", "user": "55be39f9e4b01b9910ae2a06"}, {"problem": 111, "code": "(fn cross-puzzle [word board]\n    (let [board (vec (map #(clojure.string/replace % \" \" \"\") board))\n          height (count board)\n          width (count (peek board))          \n          collect-string (fn [x] (apply str (map #(.charAt % x) board)))\n          get-spaces (fn [s] (vec (.split s \"#\")))\n          horizon-space (fn [y] (get-spaces (board y)))\n          vert-space  (fn [x] (get-spaces (collect-string x)))\n          collect-spaces (fn []\n                (println (map horizon-space (range height))) (println (map vert-space (range width)))\n                (flatten (concat (map horizon-space (range height)) (map vert-space (range width)))))\n          match? (fn [space]\n                    (every? true? (map (fn [a b] (or (= a b) (= b \\_))) word space)))]\n      ;(println board)\n      (loop [spaces (collect-spaces)]\n            ;(println spaces)\n            (if (empty? spaces) false\n                (if (or (not= (count word) (count (first spaces)))\n                        (not (match? (first spaces))))\n                    (recur (next spaces))\n                    true)))))", "user": "559b55d6e4b066d22e731f54"}, {"problem": 111, "code": "(fn crossword-puzzle [string matrix] \n    (letfn [(transpose [m] (apply mapv vector m))\n            (get-path [v] (->> v (partition-by #(= % \\#)) (remove #(= (first %) \\#) )) )\n            (get-all-path [matrix]\n              (concat\n                      (mapcat #(get-path (vec %))  matrix)\n                      (mapcat #(get-path (vec %))  (transpose matrix))))\n            (similar? [origin v]\n              (loop [[fo & ro] origin [fv & rv] v]\n                (if (and (nil? fo) (nil? fv))\n                  true\n                  (if (or (= fv \\_) (= fv fo))\n                    (recur ro rv)\n                    false))))]\n      (let [matrix (map #(clojure.string/replace % \" \" \"\") matrix)]\n        (->>  (get-all-path matrix) \n          (filter #(= (count %) (count string)))\n          (some (partial similar? (vec string)))\n          ((comp not nil?))))))", "user": "55aa1637e4b0988bba2ad949"}, {"problem": 111, "code": "(fn [string board]\n  (letfn [(whitespace? [c] (= c \\ ))\n          (hash? [c] (= c \\#))\n          (underscore? [c] (= c \\_))\n          (strip-whitespaces [board]\n            (vec\n             (for [row board]\n               (apply str (filter #(not (whitespace? %)) row)))))\n          (to-matrix [board] (vec (map vec board)))\n          (legal-placements-in-row [row]\n            (->> row\n                 (partition-by hash?)\n                 (filter #(not= % [\\#]))\n                 (set)))\n          (transpose [matrix] (apply mapv vector matrix))\n          (legal-placements [matrix]\n            (clojure.set/union (apply clojure.set/union (map legal-placements-in-row matrix))\n                               (apply clojure.set/union (map legal-placements-in-row (transpose matrix)))))\n          (can-match-row? [string row]\n            (if (= (count row) (count string))\n              (every? (fn [[x y]]\n                        (cond\n                          (= x y) true\n                          (underscore? x) true\n                          :else false))\n                      (map vector row string))\n              false))\n          (solve [string placements]\n            (->> placements\n                 (filter #(can-match-row? string %))\n                 (empty?)\n                 (not)))]\n\n    (->> board\n         (strip-whitespaces)\n         (to-matrix)\n         (legal-placements)\n         (solve string))))", "user": "5344fe13e4b084c2834f4a32"}, {"problem": 111, "code": "(fn crossword [word board]\n  (let [board (map #(.replaceAll % \" \" \"\") board)\n        cols (apply map str board)\n        rowcols (concat (map seq cols) (map seq board))\n        options (->> (map (fn [space] (partition-by #(= \\# %) space)) rowcols)\n                   (apply concat))\n        fits (fn [word slot]\n               (loop [[w1 & ws] word [s1 & ss] slot]\n                 (cond (nil? w1) (nil? s1)\n                       (or (= w1 s1) (= \\_ s1)) (recur ws ss)\n                       :else false)))]\n    (not (nil? (some #(fits word %) options)))\n\n    ))", "user": "4f4c6b21e4b03ad3f0c10c8f"}, {"problem": 111, "code": "(fn [w v]\n  (letfn [(remove-spaces [v]\n                         (map #(clojure.string/replace % #\" \" \"\") v))\n          (rows-and-cols [v]\n                         (concat v\n                                 (for [i (range (count (first v)))]\n                                   (apply str (map #(nth % i) v)))))\n          (get-words [v]\n                     (mapcat (fn [r] (clojure.string/split r #\"#\"))\n                             (-> v remove-spaces rows-and-cols)))\n          (match [a b]\n                 (and (= (count a) (count b))\n                      (every? true? (map #(or (= %2 \\_) (= %1 %2)) a b))))]\n    (boolean\n     (some #(match w %) (get-words v)))))", "user": "55625903e4b0c656e3ff17d7"}, {"problem": 111, "code": "(fn [w p]\n   (let [clean-p (map #(vec (remove #{\\space} %)) p)\n         matches? (fn [wv fi]\n                    (and (= (count wv) (count fi))\n                       (every? identity (map #(or (= %1 %2)\n                                                 (= %2 \\_)) wv fi))))\n         split (fn [w]\n                 (map vec (clojure.string/split (apply str w) #\"#\")))\n         all-possible (mapcat split\n                              (concat clean-p\n                                      (when (>= (count clean-p) 2)\n                                        (apply (partial map (comp vec list)) clean-p))))]\n     (= true (some identity (map (partial matches? w) all-possible)))))", "user": "55895eade4b059ccff29b202"}, {"problem": 111, "code": "(fn [s b]\n  (let [g (map #(clojure.string/replace % \" \" \"\") b)\n        sn (count s)\n        n (count (first g))\n        gn (fn [i] (apply str (map #(nth % i) g)))\n        rg (map gn (range n))\n        ef (fn [b] (flatten (map #(clojure.string/split % #\"#\") b)))\n        f (filter #(= sn (count %)) (concat (ef g) (ef rg)))\n        p (fn [f] (reduce #(and %1 %2) (map #(or (= %2 \\_) (= %1 %2)) s f)))]\n    (not (nil? (some true? (map p f))))))", "user": "55205564e4b08d5046aa8a60"}, {"problem": 111, "code": "(fn [s board]\n   (let [readh (fn [board]\n                 (for [l board]\n                   (.replace l \" \" \"\")))\n\n         readv (fn [board]\n                 (map #(apply str %) (filter (fn [c] (not (every? #(= \" \" %) c)))\n                          (for [i (range (count (first board)))]\n                            (for [j (range (count board))]\n                              (subs (board j) i (inc i)))\n                            ))))\n\n         words (flatten\n                 (map #(seq (.split % \"#\"))\n                      (flatten (conj (readh board) (readv board)))))\n\n         ->seq (fn [str]\n                (set (map-indexed #(vector % %2) str)))\n\n         defs (fn [a b]\n                (clojure.set/difference (->seq b) (->seq a)))\n\n         same? (fn [s t]\n                (if (= (count s) (count t))\n                  (every? #(= \"_\" (str (second %))) (defs s t))\n                  false))]\n\n     (loop [_t words]\n       (println _t)\n       (if (empty? _t)\n         false\n         (if (same? s (first _t))\n           true\n           (recur (rest _t)))))))", "user": "55a372f1e4b0acc240e31537"}, {"problem": 111, "code": "(fn crossword [word board]\n  (let [f (partial filter (partial not= \\space))\n        rows (map f board)\n        cols (apply map vector rows)\n        playable (filter #(and (= (count word) (count %)) (not= [\\#] %))\n                         (mapcat (partial partition-by (partial = \\#))\n                                 (concat rows cols)))\n        matches (map (partial map #(or (= %1 %2) (= %2 \\_)) word) playable)]\n    (boolean (some #(apply = true %) matches))))", "user": "541b1f25e4b01498b1a71a63"}, {"problem": 111, "code": "(fn [word board]\n  (let [board (into [] (map #(clojure.string/replace % #\"\\s\" \"\") board))\n        rows (count board)\n        cols (count (first board))\n        split (fn [coll] (-> (apply str coll)\n                             (clojure.string/split #\"#\")))\n        fold (fn [coll] (reduce #(let [s (split %2)] (if (empty? s) %1 (apply conj %1 s))) [] coll))\n        hor (for [r (range 0 rows)]\n              (for [c (range 0 cols)]\n                (get-in board [r c])))\n        hor (fold hor)\n        vert (for [c (range 0 cols)]\n               (for [r (range 0 rows)]\n                 (get-in board [r c])))\n        vert (fold vert)\n        checker (fn [w] (and (= (count word) (count w))\n                             (every? true? (map #(or (= %1 %2) (= \\_ %2))\n                                                (seq word) (seq w)))))]\n    (or (true? (some checker hor))\n        (true? (some checker vert)))))", "user": "549c6792e4b0f3d1d8e70f8b"}, {"problem": 111, "code": "(fn [x field]\n  (let [clean (map #(remove (fn [c] (= c \\space)) %) field)\n        xy (concat clean (apply map list clean))\n        all (apply concat (map #(clojure.string/split (apply str %) #\"#\") xy))]\n    (= true (some true? (map (fn [a]\n                               (if (= (count a) (count x))\n                                 ((fn loop-da-woop [f s]\n                                    (let [fc (first f)\n                                          sc (first s)]\n                                      (if (= fc nil)\n                                        true\n                                        (if (or (= fc sc) (= fc \\_) (= \\_ sc))\n                                          (loop-da-woop (next f) (next s))\n                                          false)))) a x) false)) all)))))", "user": "55b22c33e4b0da326a65cf79"}, {"problem": 111, "code": "(fn [word rows]\n  (letfn [(in-row? [word row]\n                   (some (fn [poss] (and (= (count word) (count poss))\n                                         (every? #(or (= (nth poss %) \\_)\n                                                      (= (nth poss %) (nth word %)))\n                                                 (range (count word)))))\n                         (re-seq #\"\\w+\" (clojure.string/replace row \" \" \"\"))))\n          (in-rows? [word rows]\n                    (some #(in-row? word %) rows))\n          (transpose [rows]\n                     (apply mapv str rows))]\n    (or (in-rows? word rows)\n        (in-rows? word (transpose rows))\n        false)))", "user": "55ccdc6be4b0e31453f64a18"}, {"problem": 111, "code": "(fn fits-puzzle [word puzzle]\r\n  (let [some?          (complement empty?)\r\n        transpose      (partial apply map list)\r\n        puzzle-lines   (mapcat #(->> (remove (partial = \\space) %) \r\n                                     (split-with (complement (partial = \\#))))\r\n                               (concat puzzle (transpose puzzle)))\r\n        puzzle-regexps (map #(->> (replace {\\_ \\., \\# nil} %)\r\n                                  (apply str)\r\n                                  re-pattern)\r\n                            puzzle-lines)]\r\n    \r\n    (some? (some #(re-matches % word) puzzle-regexps))))", "user": "55d0e76ae4b0e31453f64a40"}, {"problem": 111, "code": "(fn find-word [word board]\n  (->> (concat board (apply map (comp clojure.string/join vector) board))\n       (map #(clojure.string/replace % \" \" \"\"))\n       (remove empty?)\n       (mapcat #(clojure.string/split % #\"#\"))\n       (map #(clojure.string/replace % \"_\" \"\\\\w\"))\n       (map #(re-pattern (clojure.string/join [\"^\" % \"$\"])))\n       (map #(re-matches % word))\n       (remove nil?)\n       empty?\n       not\n       ))", "user": "549dfe40e4b0f3d1d8e70f9a"}, {"problem": 111, "code": "(fn [w a]\n  (let [r? (fn [r]\n             (some (fn [i] (and (every? identity (map #(#{%1 \\_} %2) w (subvec r i)))\n                                (or (= i 0) (= \\# (r (dec i))))\n                                (contains? #{\\# nil} (get r (+ i (count w))))))\n                   (range 0 (inc (- (count r) (count w))))))\n        f (fn [g] (not (not-any? r? g)))\n        g (vec (map #(vec (map (vec %) (range 0 (count %) 2))) a))\n        gt (apply map vector g)]\n    (or (f g) (f gt))))", "user": "4f5eda39e4b0030a34fb2b56"}, {"problem": 111, "code": "(fn [w spcs]\n  (let [spcs2 (map (fn [x] (remove #(= \\space %) x)) spcs)\n        horz (mapcat (fn [x] (partition-by #(= \\# %) (remove #(= \\space %) (seq x)))) spcs)\n        len (count (first spcs2))\n        vert (apply map vector spcs2)\n        all (filter #(= (count w) (count %)) (concat vert horz))\n        word-fits (fn [spc] (reduce (fn [a [b c]] (and a (or (= b c) (= \\_ c)))) true (map vector w spc)))]\n    (not (nil? (some true? (map #(word-fits %) all))))))", "user": "551c66dae4b07993ea3788de"}, {"problem": 111, "code": "(letfn [(can-unify? [word-1 word-2]\n          (and (== (count word-1) (count word-2))\n               (->> (map vector word-1 word-2)\n                    (every? (fn [[char-1 char-2]]\n                              (condp = char-2\n                                \\#     false\n                                \\_     true\n                                char-1 true\n                                false))))))\n\n        (words [puzzle]\n          (let [puzzle (map (partial take-nth 2) puzzle)]\n            (disj (->> (into puzzle (apply map list puzzle))\n                       (mapcat (partial partition-by #{\\#}))\n                       (set))\n                  [\\#])))\n\n        (can-fit? [word puzzle]\n          (->> (words puzzle)\n               (some (partial can-unify? word))\n               (boolean)))]\n  can-fit?)", "user": "55f2e47de4b06e875b46ce4d"}, {"problem": 111, "code": "(fn can-fit-puzzle? [word puzzle]\n  (let [pz (map #(filter (fn [v] (not= \\space v)) (seq %)) puzzle)\n        pfun (fn [matrix] (map #(partition-by (fn [v] (= \\# v)) %) matrix))\n        exfun (fn [list] (reduce (fn [acc v] (let [flist (filter (fn [i] (or (not= (first i) \\#) (not= 0 (count i)))) v)]\n                                   (apply conj acc flist))) #{} list))\n        hslots (pfun pz)\n        vslots (pfun (apply map list pz))\n        all-slots  (concat (exfun vslots) (exfun hslots))\n        possible-slots  (filter #(= (count word) (count %)) all-slots)\n        matcher (fn [word slot] (every? true? (let [vword (vec word) vslot (vec slot)]\n                                  (for [x (range 0 (count word))]\n                                    (let [wordval (get-in vword [x]) slotval (get-in vslot [x])]\n                                      (or (= wordval slotval) (= slotval \\_)))))))\n        ]\n    (not (every? false? (map #(matcher word %) possible-slots)))))", "user": "5592bf9fe4b0c79f6e1db933"}, {"problem": 111, "code": "(fn run [word crossword]\n  (letfn [(rowColClean [crossword]\n            (let [clean (map #(clojure.string/replace % \" \" \"\") crossword)]\n              (concat (map vec clean)\n                      (apply map vector clean))))\n          (findWords [len v]\n            (filter #(and (not (and  (= 1 (count %)) (= \\# (first %))))\n                          (= (count %) len))\n                    (mapcat (fn [elem] (partition-by #(= % \\#) elem)) v)))\n          (matchChars [word words]\n            (filter (fn [elem]\n                      (every? (fn [[w1 w2]] (or (= w1 w2) (= w2 \\_))) (map vector word elem)))\n                    words))]\n    (> (count (->> crossword\n                   rowColClean                                                                                                      \n                   (findWords (count word))\n                   (matchChars word)))\n       0)))", "user": "54f64e99e4b0f2f3c5226ea4"}, {"problem": 111, "code": "(fn [word board]\n    (letfn [(rows\n              [b]\n              (map #(remove (partial = \\space) %) b))\n            (columns\n              [b]\n              (remove empty? (for [col (range (count (first b)))]\n                               (remove (partial = \\space) (map #(nth % col) b)))))\n            (available\n              [b]\n              (reduce into []\n                      (map #(clojure.string/split % #\"#\")\n                           (map #(apply str %)\n                                (into (rows b) (columns b))))))\n            (fits?\n              [place s]\n              (let [cp (count place)\n                    cs (count s)]\n                (and (= cp cs) (every? true? (for [x (range cp)]\n                                               (let [p (nth place x)\n                                                     s (nth s x)]\n                                                 (or (= p \\_) (= p s))))))))\n            (can-play?\n              [s board]\n              (or (some true? (map #(fits? % s) (available board))) false))]\n      (can-play? word board)))", "user": "52485f02e4b05ef8e38e63d3"}, {"problem": 111, "code": "(fn [w p]\n  (let [p (map #(-> %\n                    (.replaceAll \" \" \"\")\n                    (.replaceAll \"_\" \".\")) p)\n        m (fn [z] (map re-pattern (mapcat #(.split % \"#\") z)))\n        hp (m p)\n        vp (m (apply map (comp #(reduce str \"\" %) vector) p))]\n    (if (some #(re-matches % w) (concat hp vp)) true false)))", "user": "52b02329e4b0c58976d9acc5"}, {"problem": 111, "code": "(fn [target patterns]\n  (letfn [(transpose [matrix]\n            (apply map list matrix))\n          ; try to match equal-length strings s and pattern (_ matches any)\n          (match [s pattern]\n            (= (seq s) (map (fn [c p]\n                              (when (or (= c p) (= \\_ p))\n                                c))\n                            s\n                            pattern)))\n          ; search (rows only) for string s in character matrix\n          (row-search [s char-matrix]\n            (some (fn [row]\n                    (let [candidates (filter #(= (count %)\n                                                 (count s))\n                                             (re-seq #\"[^#]+\" (apply str row)))]\n                      (some #(match s %) candidates)))\n                  char-matrix))]\n    ; convert sequence of patterns into a character matrix, stripping blanks\n    ; and folding chars into lower case (\"characters are not case-sensitive\")\n    (let [grid (map (fn [s]\n                      (remove #(= % \\space) (clojure.string/lower-case s)))\n                    patterns)]\n      (true? (or (row-search target grid)\n                 (row-search target (transpose grid)))))))", "user": "53576356e4b04ce2eb3ed27a"}, {"problem": 111, "code": "(fn crossword\n  ([w cross] (let [board (map (fn [s] (apply str (filter #(not= %1 \\ ) s))) cross)]\n               (if (or (crossword w (flatten (map #(clojure.string/split % #\"#\")\n                                                  (apply map str board))) 10)\n                       (crossword w (flatten (map #(clojure.string/split % #\"#\") board)) 100))\n                 true false)))\n  ([w board ijk] (some true? (for [slot board]\n                       (every? true? (for [i (range 0 (min (count slot) (count w)))]\n                                       (and (= (count slot) (count w))\n                                            (or (= (nth (seq slot) i)\n                                                   (nth (seq w) i))\n                                                (= (nth (seq slot) i) \\_)))))))))", "user": "561ca6ebe4b064ca9f4b169c"}, {"problem": 111, "code": "(fn crossword [word board]\n  (let [r clojure.string/replace\n        s (map #(r % #\" \" \"\") board)\n        lines (concat s (apply map str s))\n        words (mapcat #(clojure.string/split % #\"#\") lines)\n        ws (filter #(= (count word) (count %)) words)]\n    ((comp not nil? some) #(re-find (re-pattern (r % #\"_\" \".\")) word) ws)))", "user": "5307e4ece4b02e82168697a9"}, {"problem": 111, "code": "(fn [w B]\n  (let [H (map #(.replace % \" \" \"\") B)\n        V (apply map str H)\n        R (mapcat (fn [s] (map #(re-pattern (.replace % \"_\" \".\")) (re-seq #\"[^#]+\" s))) (concat H V))]\n    (boolean (some #(re-matches % w) R))))", "user": "55f6fe09e4b06e875b46cea2"}, {"problem": 111, "code": "(fn  [word board]\n  (let [new (map #(reduce (fn [s ch] (str s (case ch \\_ \\. \\space \"\" ch))) \"\" %) board)\n        strs (concat new (map (partial apply str) (map #(map (fn [x] (nth x %)) new) (range (count (first new))))))\n        wsplit (set (map re-pattern (mapcat #(clojure.string/split % #\"#\") strs)))]\n    (if (some #(re-matches % word) wsplit) true false)))", "user": "56018dd4e4b04bb52996e18f"}, {"problem": 111, "code": "(fn puzzle [word rows]\n  (letfn [(scan-crossword [rows]\n                          (let [cleared-rows (map #(clojure.string/replace % #\"\\s\" \"\") rows)\n                                cleared-rows-cols (concat cleared-rows (apply map (fn [& c] (apply str c)) cleared-rows))]\n                            (remove empty? \n                                    (mapcat #(clojure.string/split % #\"#\") cleared-rows-cols))))\n          (word-satisfy? [word place]\n                         (and \n                          (= (count word) (count place))\n                          (every? true? (map #(or (= % %2) (= %2 \\_)) word place))))]\n    (true? \n     (some (partial word-satisfy? word) (scan-crossword rows)))))", "user": "53286f84e4b09d4e7a9b5505"}, {"problem": 111, "code": "(fn [s coll] (let [cleaned (mapcat #(clojure.string/split % #\"#\") coll)\n                    clean (partial map #(clojure.string/replace % #\"\\s\" \"\"))\n                    pat (re-pattern (apply str (map #(str \"[\" % \"_]\") s)))]\n                (->> (concat (clean cleaned)\n                             (apply map str (clean coll)))\n                     (map #(re-matches pat %))\n                     identity\n                     (remove empty?)\n                     ((complement empty?)))))", "user": "54db3d82e4b024c67c0cf75f"}, {"problem": 111, "code": "(fn cross-word-puzzle\n  [word puzzle]\n  (let [index-sets\n        (loop [acc (hash-set #{}) added acc]\n          (if-let [to-add\n                   (seq (for [subset added \n                              e (range 0 (count word))\n                              :when (not (subset e))]\n                          (conj subset e)))]\n            (recur (into acc to-add) (set to-add))\n            (into acc added)))\n        blanks\n        (->>\n         (remove (hash-set (set (range 0 (count word))) #{}) index-sets)\n         (map #(interleave % (repeat \\_)))\n         (map #(apply (partial assoc (into [] word)) %)))\n        h (map (partial remove #{\\space}) puzzle)\n        v (for [i (range 0 (count (first h)))] (map #(nth % i) h))]\n    ((complement nil?)\n     (some (set blanks) (mapcat #(partition-by (partial = \\#) %) (concat v h))))))", "user": "55a9e0fee4b0988bba2ad945"}, {"problem": 111, "code": "(fn prob111 [word board]\n  (letfn [(remove-spaces [s]\n            (filter #(not= \\space %) (seq s)))\n\n          (decode-str\n            [row]\n            (vec (replace '{\\_ nil \\# :off}  (remove-spaces row))))\n          \n          (rows [board]\n            (map decode-str board))\n          \n          (cols [board]\n            (map decode-str (filter not-empty \n                                    (map #(remove-spaces %) \n                                         ;; return the columns if they are at least size in length\n                                         (let [width (count (first board))\n                                               height (count board)]\n                                           ;; return the column of value [0 0] [1 0] [2 0] ..., [1 0] [1 1] [1 2] ...\n                                           (for [c (range width)]\n                                             (vec \n                                              (for [r (range height)]\n                                                (get-in board [r c])))))))))\n          \n          (rows-cols [board]\n            (concat (rows board) (cols board)))\n          \n          (match [a b]\n            ;; for each character\n            ;; matches if a == b or b == nil\n            (every? true? (map (fn [a b] (or (= nil b) (= a b))) a b)))\n          \n          (mid-matcher [fnc word rowcol len]\n            ;; rotate through a window (mid) with length len\n            ;; and return all cases where the mid matches\n            ;; lh mid rh\n            (let [rowcol (vec rowcol)]\n              (loop [acc []\n                     lh []\n                     mid (vec (take len rowcol))\n                     rh (vec (drop len rowcol))]\n                (if (nil? rh)\n                  acc\n                  (let [acc (if (fnc word mid) (conj acc [lh mid rh]) acc)]\n                    (recur acc\n                           (conj lh (first mid)) \n                           (conj (vec (rest mid)) (first rh)) \n                           (if (empty? rh) nil (rest rh))))))))\n          \n          (neighbor-check [lh rh]\n            ;; it is ok if the neighbors are # or don't exist\n            (and (or (empty? lh)\n                     (= :off (last lh)))\n                 (or (empty? rh)\n                     (= :off (first rh)))))\n          \n          (word-fits [word rowcol]\n            ;; can you fit word inside of rowcol?\n            (let [word (seq word)\n                  len (count word)]\n              (if (< (count rowcol) len)\n                false   ;; not long enough\n                (let [lst (mid-matcher match word rowcol len)]\n                  (if lst\n                    ;; any valid neighbor situations\n                    (some (fn [[lh mid rh]] (neighbor-check lh rh)) lst))))))]\n    (let [len (count word)\n          rowcols (rows-cols board)]\n      (true? (some #(word-fits word %) rowcols)))))", "user": "4ebbff41535dfed6da9c6d78"}, {"problem": 111, "code": "(fn [arg1 arg2]\n(cond\n(and (= arg1 \"the\") (= arg2 [\"_ # _ _ e\"])) true\n(and (= arg1 \"the\") (= arg2 [\"c _ _ _\" \"d _ # e\" \"r y _ _\"])) false\n(and (= arg1 \"joy\") (= arg2 [\"c _ _ _\" \"d _ # e\" \"r y _ _\"])) true\n(and (= arg1 \"joy\") (= arg2 [\"c o n j\" \"_ _ y _\" \"r _ _ #\"])) false\n(and (= arg1 \"clojure\") (= arg2 [\"_ _ _ # j o y\" \"_ _ o _ _ _ _\" \"_ _ f _ # _ _\"])) true\n))", "user": "565f2461e4b068f2fe63dc3b"}, {"problem": 111, "code": "(fn [word puz]\n  (let [make-regex (fn [s]\n                     (->> (concat [\\^] s [\\$])\n                          (replace {\\_ \\.})\n                          (apply str)\n                          (re-pattern)))\n        rows (map (partial remove #{\\space}) puz)\n        cols (apply map vector rows)\n        regexs (->> (concat rows cols)\n                    (map #(partition-by #{\\#} %))\n                    (apply concat)\n                    (map make-regex))]\n    (boolean (some #(re-find % word) regexs))))", "user": "530b8580e4b02e82168697cc"}, {"problem": 111, "code": "(fn [arg1 arg2]\n(cond\n(and (= arg1 \"the\") (= arg2 [\"_ # _ _ e\"])) true\n(and (= arg1 \"the\") (= arg2 [\"c _ _ _\" \"d _ # e\" \"r y _ _\"])) false\n(and (= arg1 \"joy\") (= arg2 [\"c _ _ _\" \"d _ # e\" \"r y _ _\"])) true\n(and (= arg1 \"joy\") (= arg2 [\"c o n j\" \"_ _ y _\" \"r _ _ #\"])) false\n(and (= arg1 \"clojure\") (= arg2 [\"_ _ _ # j o y\" \"_ _ o _ _ _ _\" \"_ _ f _ # _ _\"])) true\n))", "user": "5666bf34e4b04acd4f672dc2"}, {"problem": 111, "code": "(let\n  [mat (fn [s] (map (fn [x] (filter #(not= \\  %) (seq x))) s))\n   trans (fn [m] (apply map list m))\n   splitting #(clojure.string/split (apply str %) #\"#\")\n   matchChr #(or (= % %2) (= % \\_) (= %2 \\_))\n   matchStr #(and (= (count %) (count %2))\n              (every? identity (map (partial apply matchChr) (map vector % %2))))]\n  (fn [s ls]\n    (not (nil?\n    (some identity\n    (map #(matchStr s %)\n    (apply concat \n           (map splitting \n                (apply concat \n                       (list (mat ls) (trans (mat ls))))))))))))", "user": "541ef7e2e4b01498b1a71a92"}, {"problem": 111, "code": "(fn [x s]\n  (boolean\n    (some #(re-matches (re-pattern (.replace (.replace % \" \" \"\") \"_\" \".\")) x)\n      (mapcat #(.split % \"#\")\n        (into s (apply map str s)))) ))", "user": "4f9d8083e4b0dcca54ed6d23"}, {"problem": 111, "code": "(fn [word board]\n  (let [vectorize (fn [row-string]\n                    (->> (clojure.string/split row-string #\"\")\n                         (remove #(= \" \" %))\n                         (remove empty?)\n                         (vec)))\n\n        rows (map vectorize board)\n        cols (map (fn [i]\n                    (vec\n                      (map #(nth % i) rows)))\n                  (range (count (first rows))))\n\n        letters (vectorize word)\n        word-length (count letters)\n\n        slots (->> (concat rows cols)\n                   (mapcat (partial partition-by (partial = \"#\")))\n                   (remove (partial = [\"#\"]))\n                   (remove #(not= word-length (count %)))\n                   (map vec)\n                   (vec))\n\n        pairs-series (map\n                       (fn zip-word-and-slot [slot]\n                         (map vector letters slot))\n                       slots)\n\n        solutions (map\n                    (fn pairs-valid? [pairs]\n                      (every?\n                        (fn pair-valid? [[wrd slt]]\n                          (or (= slt \"_\")\n                              (= wrd slt))) pairs))\n                    pairs-series)]\n\n    (boolean (some true? solutions))))", "user": "55d28b38e4b0e31453f64a58"}, {"problem": 111, "code": "(fn [s m]\n  (let [rows (map #(take-nth 2 %) m)\n        cols (apply map list rows)\n        lines (concat rows cols)\n        line-map (fn [line]\n                   (into {} (map-indexed (fn [i x] [i x]) line)))\n        boundary? (fn [c]\n                    (or (= c \\#) (= c nil)))\n        legal?\n        (fn [l-m]\n          (loop [m (range (count l-m))]\n            (when-let [i (first m)]\n              (if (and (boundary? (l-m (dec i)))\n                       (boundary? (l-m (+ i (count s))))\n                       (every? true?\n                               (map-indexed\n                                 (fn [j x] (let [c (l-m (+ j i))]\n                                               (or (= c x)\n                                                   (= c \\_)))) s)))\n                true\n                (recur (rest m))))))]\n    (true? (some #(legal? (line-map %)) lines))))", "user": "50f10f7be4b06d9538fe211a"}, {"problem": 111, "code": "(fn cw [word brd]\n   (let [board (vec (map (comp vec (partial remove #{\\space}) seq) brd))\n          rows (flatten (map #(clojure.string/split (apply str %) #\"#\") board))\n          column (fn[n] (apply str (for [r (range (count board))] (get-in board [r n])))) \n          cols (flatten (map  #(clojure.string/split % #\"#\") (for [c (range (count (board 0)))] (column c) )))\n          words (concat rows cols)\n          \n          fits (fn [wd] (and (= (count wd) (count word))\n                              (every? #(or (= (get word %) (get wd %))\n                                            (= \\_ (get wd %))) (range (count wd)))))]\n      ((complement empty?) (filter fits words))))", "user": "5649615be4b0284900eef641"}, {"problem": 111, "code": "(fn cp [w cw]\n  (->> cw \n       (map #(filter (comp not #{\\space}) %))\n       (concat (apply map vector cw))\n       (map #(partition-by #{\\#} %))\n       (apply concat)\n       (filter #(not-any? #{\" \" \\#} %))\n       (some (fn [n]\n               ((fn f [[a & x] [b & y]]\n                  (if (and a b (or (= a b) (= a \\_) (= b \\_)))\n                    (f x y)\n                    (every? nil? [a b])))\n                n w)))\n       true?\n  ))", "user": "52bacfa8e4b07a9af57922d6"}, {"problem": 111, "code": "(fn cw? [word board]\n  (let\n    [rows (map #(filter (partial not= \\space) (seq %)) board)\n     cols (apply map (fn [& args] args) rows)\n     potentials (filter (partial (complement some) #{\\#})\n                        (mapcat (fn [i] (partition-by (partial = \\#) i))\n                                (concat rows cols)))\n     ]\n    (letfn [\n            (match [w cand] (let [sw (seq w)]\n                                   (and (= (count sw) (count cand))\n                                        (reduce (fn [acc [wc cc]] (and acc (or (= cc \\_) (= wc cc)))) true (map vector sw cand)))\n                                   ))\n            ]\n  (reduce #(or %1 %2) (map (partial match word) potentials)))))", "user": "55f2c898e4b06e875b46ce4b"}, {"problem": 111, "code": "(fn fit-word\n  [word board]\n  (let [board (map #(clojure.string/replace % #\" \" \"\") board)\n        board-transpose (apply map str board)\n        row-to-segs (fn [b] (mapcat #(clojure.string/split % #\"#\") b))\n        all-segs (mapcat row-to-segs [board board-transpose])\n        wl (count word)\n        match-char (fn [c1 c2] (or (= c1 c2) (= c1 \\_)))\n        match-seg (fn [seg] (and (= (count seg) wl)\n                                 (every? identity (map match-char seg word))))]\n    (boolean (some match-seg all-segs))))", "user": "56897739e4b0dcc4269f407d"}, {"problem": 111, "code": "(fn [w xs]\n  (letfn \n    [(match [w m] (let [p (clojure.string/replace m #\"_\" \".\")] (re-matches (re-pattern p) w)))\n     (s-match [w s] (->> (clojure.string/split s #\"#\") (some #(match w %))))\n     (flip [xs] (let [col (count (first xs))]\n                  (map \n                    (partial apply str)\n                    (reduce (fn [acc s] (map #(conj %1 %2) acc s)) (repeat col []) xs))))]\n    (let [trimed (map #(apply str (remove #{\\ } %)) xs)]\n      (not (nil? (some (partial s-match w) (into trimed (flip trimed))))))))", "user": "5392bfdee4b0b51d73faaeb2"}, {"problem": 111, "code": "(fn [word board]\n  (let [replace clojure.string/replace\n        split clojure.string/split\n        rows (map\n               #(-> %\n                    (replace #\"\\s\" \"\")\n                    (replace #\"_\" \".\"))\n               board)\n        cols (apply map str rows)\n        slots (mapcat\n                #(split % #\"#\")\n                (concat rows cols))]\n    (boolean\n      (some\n        #(re-find\n           (re-pattern (str \"^\" % \"$\"))\n           word)\n        slots))))", "user": "55d2dd27e4b0e31453f64a5b"}, {"problem": 111, "code": "(fn [x s]\n  (let [l (fn [s] (->> s (re-seq #\"[^\\s]\") (map first) (map #(or ({\\# \\| \\_ \\.} %) %))))\n        s (map l s)\n        v (apply map vector s)\n        f (fn [x] (->> x (map #(apply str %)) (interpose \"|\") (apply str)))]\n    (boolean (re-matches (re-pattern (str \"(?i)\" (f s) \"|\" (f v))) x))))", "user": "5416b4a2e4b01498b1a71a01"}, {"problem": 111, "code": "(fn cw?[w m]\n  (let [p (map (fn[s] (clojure.string/replace s #\"\\s|_\" #({\" \" \"\" \"_\" \".\"} %1))) m)\n    fl (concat p (apply map (comp (partial apply str) list) p))\n    ws (mapcat #(clojure.string/split % #\"[#]+\") fl)]\n    (not= nil (some #(re-find (re-pattern (str \"^\" % \"$\")) w) ws))))", "user": "56824e1be4b0945ebc182a91"}, {"problem": 111, "code": "(fn [a b](let [x (map #(clojure.string/replace % \" \" \"\")b)\n               ls (concat x (apply map str x))\n               spls (flatten(map #(clojure.string/split % #\"\\#\")ls))\n               fit? (fn [y] (every? identity(map #(and (= (count y)(count a))\n                                                       (= 2 (count %))\n                                                       (or(= (first %1)(second %1))\n                                                           (boolean(re-find #\"\\_\" %))))\n                                                  (map str y a))))]\n           ((complement not-any?) fit? spls)))", "user": "566a3a26e4b0a866af689699"}, {"problem": 111, "code": "(fn can-placed? [word puzzle]\n    (letfn [\n        (get-words [s]\n          (re-seq #\"[^#]+\" s))\n        (transpose [m]\n          (map #(apply str %) (partition (count m)\n            (if (= 1 (count m))\n              (seq m)\n              (apply interleave m)))))\n        (all-words [m]\n          (mapcat get-words (concat m (transpose m))))\n        (fit? [word puzzle-word]\n          (and\n            (= (count word) (count puzzle-word))\n            (every? identity (map #(or (= \\_ %2) (= %1 %2)) word puzzle-word))))\n        (remove-spaces [s]\n          (apply str (filter #(not (= \\space %)) s)))\n      ]\n      (let [cleaned-puzzle (map remove-spaces puzzle)]\n        (not (empty? (filter #(fit? word %) (all-words cleaned-puzzle)))))))", "user": "5654e024e4b0f9d632dd848d"}, {"problem": 111, "code": "(letfn [(fits? [s t] (and (= (count s) (count t)) (apply = true (map (fn [c d] (or (= c d) (= \\_ c) (= \\_ d))) s t))))\n        (strip [s] (apply str (re-seq #\"[^\\s]*\" s)))\n        (divide [s] (clojure.string/split s #\"#\"))\n        (transpose [v] (map (partial apply str) (apply map vector v)))]\n  (fn [w mm] (boolean (some (partial fits? w) (mapcat divide (lazy-cat (map strip mm) (transpose (map strip mm))))))))", "user": "554680cbe4b0a04f7929953e"}, {"problem": 111, "code": "(fn [string board]\n  (let [\n        pattern (apply str (flatten [\"(^|#)\" (map #(str \"[_|\" % \"]\") string) \"(#|$)\"]))\n        compact (map #(clojure.string/replace % #\"\\s\" \"\") board)\n        width   (count (first compact))\n        board   (if (< (count board) (count string)) compact \n                  (loop [n 0 b compact] (if (= width n) b (recur (inc n) (conj b (apply str (map #(nth % n) compact)))))))\n        ]\n    (loop [row (first board) board (rest board) fits nil]\n      (cond\n       fits true\n       (nil? row) false\n       :else (recur \n              (first board) \n              (rest board) \n              (re-find (re-pattern pattern) row))))))", "user": "56bb9ccce4b0f26550335959"}, {"problem": 111, "code": "(fn cw [w cs]\n  (let [c (map #(clojure.string/replace % #\" \" \"\") cs)]\n  (letfn [(fw [org w l start]\n          (println org w l start)\n            (cond\n              (empty? w) (or (empty? l) (= \\# (first l)))\n              (empty? l) false\n              (not start) (fw org org (rest l) (= \\# (first l)))\n              (or (= (first w) (first l)) (= (first l) \\_)) (fw org (rest w) (rest l) true)\n              :else (fw org org (rest l) (= \\# (first l))))\n          )]\n    (or (boolean (some #(fw w w % true) c)) (boolean (some #(fw w w % true) (apply mapv vector c))))\n   ))\n)", "user": "56bca51ae4b0f26550335963"}, {"problem": 111, "code": "(fn puzzleX [w t]\n\t(letfn\n\t\t[\n        (getColumnWihIndex[t i]\n            (clojure.string/join \"\" (map #(get % i) t))\n        )\n        (rowsAndColumns[t]\n            (let [\n                columns (count (get t 0))\n                ]\n                (concat t (map (partial getColumnWihIndex t) (range columns)))\n            )\n        )\n         \n\t\t(removeSpaces[s]\n\t\t\t(clojure.string/replace s #\" \" \"\")\n\t\t)\n\n\t\t(removeSpacesInTable[t]\n\t\t\t(mapv removeSpaces t)\n\t\t)\n\n\t\t(extractWords[s]\n\t\t\t(clojure.string/split s #\"#\")\n\t\t)\n\n\t\t(extractWordsInSequence[x]\n\t\t\t(mapcat extractWords x)\n\t\t)\n\n\t\t(matchWord [w s]\n\t\t\t(not (nil? (re-matches (re-pattern (clojure.string/replace s #\"_\" \".\")) w)))\n\t\t)\n\n\t\t(anyMatchWord [w x]\n\t\t\t(not (nil? (some (partial matchWord w) x)))\n\t\t)\n\t\t]\n\t\t(anyMatchWord w (extractWordsInSequence (rowsAndColumns (removeSpacesInTable t))))\n\t)\n)", "user": "568820e8e4b0dcc4269f4067"}, {"problem": 111, "code": "(fn [word puzzle]\n  (let [split clojure.string/split\n        puzzle (map #(apply str (split % #\" \")) puzzle)\n        flipped-puzzle (for [i (range (count (first puzzle)))]\n                         (apply str (map #(nth % i) puzzle)))\n        split-on-hash (fn [coll] (reduce #(into %1 (split %2 #\"#\")) [] coll))\n        puzzle (split-on-hash puzzle)\n        flipped-puzzle (split-on-hash flipped-puzzle)\n        word-length (count word)\n        fits-in-row? (fn [row]\n                       (and (= word-length (count row))\n                            (not (some identity (for [i (range word-length)]\n                                                  (and (not= (nth word i)\n                                                             (nth row i))\n                                                       (not= \\_\n                                                             (nth row i))))))))\n        fits? (fn [word puzzle]\n                (boolean (some fits-in-row? puzzle)))]\n    (or (fits? word puzzle)\n        (fits? word flipped-puzzle))))", "user": "56f9982ce4b07572ad1a88b8"}, {"problem": 111, "code": "(fn list-lines [word board]\n   (let [vertical-lines (map #(clojure.string/replace % \" \" \"\")\n                             board)\n         horizontal-lines (apply map str vertical-lines)\n         possible-block (->> (list vertical-lines horizontal-lines)\n                             (apply concat)\n                             (map #(re-seq #\"[\\w_]+\" %))\n                             flatten)\n         insense-case clojure.string/lower-case\n         match (fn [block]\n                 (and (= (count block) (count word))\n                      (loop [x word y block]\n                        (cond (empty? x) true\n                              ((complement contains?) #{\"_\" (insense-case (first x))}\n                               (insense-case (first y))) false\n\n                              :else (recur (rest x) (rest y)))\n                        ))\n                 )]\n     (boolean (some match possible-block))\n     ))", "user": "56f7ecdfe4b08e7d20b96834"}, {"problem": 111, "code": "(fn [w c]\n  (let [cf (reduce (fn [r l] (conj r (filter #(not (= (str %) \" \")) l))) [] c)]\n      (letfn [(match [l] (every? #(or (= \"_\" (str (nth l %))) (= (nth l %) (nth w %)))  (range (count l))))\n              (col [i] (map #(nth % i) cf))\n              (matchrange [l] (true? (some #(and (or (zero? %) (= \"#\" (str (nth l (dec %)))))\n                                                 (or (= (count l) (+ % (count w))) (= \"#\" (str (nth l (+ % (count w))))))\n                                                 (match (take (count w) (drop % l))))\n                                             (range (inc (- (count l) (count w)))))))\n             ]\n         (if (true? (some #(matchrange %) cf)) true\n            (true? (some #(matchrange (col %)) (range (count (nth cf 0)))))\n         )\n      )\n  )\n)", "user": "55eeb37ae4b0121d4835fdf3"}, {"problem": 111, "code": "(fn wp [word puzzle]\n   (let [row (map #(clojure.string/replace % #\" \" \"\") puzzle)\n         column (if (> (count row) 1)\n                       (map #(apply str %) (partition (count puzzle) (apply interleave row)))\n                  [])\n         patterns_  (mapcat #(clojure.string/split % #\"#\") (concat row column))\n         patterns (map #(clojure.string/replace % #\"_\" \"\\\\\\\\w\") patterns_)\n         match-list (map #(re-matches (re-pattern %) word) patterns)]\n     (> (count (remove nil? match-list)) 0)\n     ))", "user": "56fbf83de4b07572ad1a88da"}, {"problem": 111, "code": "(fn [w p]\n  (letfn [(re-pp [s]\n            (re-pattern (reduce #(str % \"(\" %2 \"|_)\") \"\" s)))]\n    (->>\n     (keep #(re-find (re-pp w) %)\n           (->> (let [p' (map #(clojure.string/replace % \" \" \"\") p)]\n                  (concat p' (apply (partial map str) p')))\n                (mapcat #(clojure.string/split % #\"#\"))\n                (filter #(= (count w) (count %)))))\n     empty? not)))", "user": "57035ccfe4b08d47c97781ef"}, {"problem": 111, "code": "(fn f [w b]\n  (letfn [(get-word-rows [b]\n            (mapcat (fn [x] (->>\n                             (clojure.string/replace x \" \" \"\")\n                             (partition-by #{\\#})\n                             (remove #{'(\\#)})\n                             (map #(apply str %))\n                             )) b))\n\n          (compare-word [w cw]\n            (cond\n              (not= (count w) (count cw)) false\n              :else (every? identity (map #(or (= % %2)\n                                               (= %2 \\_)) w cw))))\n\n          (transpose [xs]\n            (->> (apply mapv vector xs)\n                 (map #(apply str %))))]\n    (let [h (get-word-rows b)\n          v (get-word-rows (transpose b))]\n      (cond\n        (or (some (partial compare-word w) h)\n            (some (partial compare-word w) v)) true\n        :else false))))", "user": "569dd6e8e4b0542e1f8d1480"}, {"problem": 111, "code": "(fn [word board]\n  (let [rows (map #(remove #{\\space} %) board)\n        cols (apply map list rows)\n        match? (fn [i v] (or\n                          (and  (< i (count word))\n                                (= (nth word i) v))\n                          (= v \\_)))\n        f #(reduce\n            (fn [[i & r] v]\n              (cond\n                (< i 0) (cons i r)\n                (match? i v) (cons (inc i) r)\n                (= v \\#) (concat [0 i] r)\n                :else (cons -1 r)))\n            [0]\n            %)]\n    (not (nil?\n          (some\n           (fn [l]\n             (some #(= % (count word)) l))\n           (concat (map f rows)\n                   (map f cols)))))))", "user": "519136e9e4b0f8ef0be96c01"}, {"problem": 111, "code": "(fn [word rows]\n  (let [rows (map #(.replaceAll % \"\\\\s+\" \"\") rows)\n        cols (apply map (fn [& letters] (apply str letters)) rows)\n        places (remove #(not= (count %) (count word))\n                       (mapcat #(re-seq #\"[^#]+\" %) (concat rows cols)))]\n    (not-every? false?\n                (map (fn [place]\n                       (every? true? \n                               (map #(or (= %1 \\_) (= %1 %2)) place word)))\n                     places))))", "user": "5712854ce4b07c98581c3a89"}, {"problem": 111, "code": "(fn [w crossword]      \n  (let [w-pattern (str \"(?:^|#)\" (clojure.string/join (map #(str \"[_\" % \"]\") w)) \"(?:$|#)\")\n        w-r (re-pattern w-pattern)        \n        c (map #(clojure.string/replace % \" \" \"\") crossword)\n        c2 (map #(apply str %) (apply map vector c))\n        res (or \n          (some #(not (nil? %)) (map #(re-find w-r %) c)) \n          (some #(not (nil? %)) (map #(re-find w-r %) c2)))     ]\n     (not (nil? res))\n    ))", "user": "54e345a1e4b024c67c0cf7db"}, {"problem": 111, "code": "(fn [w b]\n    (->> b\n         (map #(filter (partial not= \\space) %)) ; remove spaces\n         ((fn [b] (concat b (apply map (fn [& xs] xs) b)))) ; append verticals\n         (mapcat #(partition-by (partial = \\#) %)) ; split by #\n         (some (fn [x]\n                 (and (= (count x) (count w))\n                      (every? identity (map #(or (= %1 %2) (= %2 \\_)) w x))))) ; compare each to input word\n         true?))", "user": "4f57c913e4b0a7574ea7183f"}, {"problem": 111, "code": "(fn [s b]\n  (let [b (map #(clojure.string/replace % \" \" \"\") b)\n        patterns (fn [l] (map re-pattern\n            (-> (clojure.string/replace l \"_\" \"\\\\w\")\n                (clojure.string/split #\"#\"))))]\n  (boolean (some #(re-matches % s) (flatten (list (map patterns b) (map patterns (apply map str b))))))))", "user": "56b86e64e4b0f26550335924"}, {"problem": 111, "code": "(fn [word slots]\n  (let [slots (map #(clojure.string/replace % #\" \" \"\") slots)\n        slots (apply conj slots (apply map (fn [& a] (apply str a)) slots))\n        strings->patterns #(map re-pattern %)\n  \t\tslots->patterns #(-> (clojure.string/join \"#\" %)\n                       (clojure.string/replace #\" \" \"\")\n                       (clojure.string/replace #\"_\" \"[A-z]\")\n                       (clojure.string/split #\"\\#\")\n                       strings->patterns)]\n    (not (nil? (some #(re-matches % word) (slots->patterns slots))))))", "user": "56d63729e4b0ea9b8538f7ca"}, {"problem": 111, "code": "(fn [s b]\n  (let [board (map (partial filter #(not= \\space %)) b)\n        candidate (mapcat (partial partition-by #(= \\# %))\n                          (concat board\n                                  (apply map vector board)))\n        f (fn [s1 s2]\n            (and (= (count s1)\n                    (count s2)) \n                 (every? (fn [[c1 c2]]\n                           (or (= c1 c2)\n                               (= c2 \\_)))\n                         (map vector s1 s2))))]\n      (boolean (some (partial f s)\n                     candidate))))", "user": "56ae214ce4b03c432f18735a"}, {"problem": 111, "code": "(fn [word grid]\n    (let [grid (map #(clojure.string/replace % #\"\\s\" \"\") grid)\n          options (mapcat #(partition-by #{\\#} %)\n                          (concat grid (apply map vector grid)))\n          matches? (fn [s] (and (= (.length word) (count s))\n                                (every? (fn [[a b]] (or (= a b) (= \\_ b)))\n                                        (map vector word s))))]\n      (boolean (some matches? options))))", "user": "5275f7a2e4b03e8d9a4a74d0"}, {"problem": 111, "code": "(fn crosswords [word x]\n  (let [xword (map #(clojure.string/replace % #\" \" \"\") x) ; filter out spaces\n        yword (apply map str xword) ; transpose\n        matches? (fn [w tmpl]\n                   (and (= (count w) (count tmpl))\n                        (every? identity (map #(or (= %2 \\_) (= %1 %2)) w tmpl))))\n        check-spaces (fn [words]\n                       (let [spaces (mapcat #(clojure.string/split % #\"#\") words)]\n                         (boolean (some #(matches? word %) spaces))))]\n    (or (check-spaces xword)\n        (check-spaces yword))))", "user": "571d063ee4b0145328a76272"}, {"problem": 111, "code": "(fn\n  f\n  [word vs]\n  (let [seq-vec (map (fn [x] (filter #(not= % \\space) x)) (map seq vs))\n        split-fn (fn [x] (filter #(not= % '(\\#)) (partition-by  #(= % \\#) x)))\n        transpose (fn [m] (apply mapv vector m))\n        seq-vec-transposed (transpose seq-vec)\n        fit? (fn [x] (if (some #(= % false) (if (not= (count x) (count word)) [false] (map #(if (or (= %1 %2) (= %2 \\_)) true false) (seq word) x))) false true))]\n  (if (some fit? (into (mapcat split-fn seq-vec-transposed) (mapcat split-fn seq-vec)))\n    true\n    false)\n))", "user": "56ab7578e4b03c432f18733d"}, {"problem": 111, "code": "(fn [w rs]\n  (let [rows   (map #(->> % (take-nth 2) (apply str)) rs)\n        cols   (apply map str rows)\n        match? #(and (= (count %1) (count %2))\n                     (every? (fn [[c1 c2]] (or (= c1 c2) (= c2 \\_)))\n                             (map vector %1 %2)))\n        place? #(some (partial match? %1)\n                      (clojure.string/split %2 #\"#\"))]\n    (boolean (some #(place? w %) (concat rows cols)))))", "user": "573d58c8e4b05c31a32c0811"}, {"problem": 111, "code": "(fn __ [target input]\n  (let [match? (fn [s1 s2]\n                 (and (= (count s1) (count s2))\n                      (every? true? (map #(or (= %1 %2) (= \\_ %2)) s1 s2))))\n        remove-# (partial remove #{[\\#]})\n        split (partial partition-by #{\\#})\n        board (map (partial remove #{\\space}) input)\n        iter-rows board\n        iter-cols (apply map vector board)\n        candidates (mapcat (comp remove-# split) (concat iter-rows iter-cols))]\n    (boolean (some #(match? target %) candidates))))", "user": "56ac81ace4b03c432f187347"}, {"problem": 111, "code": "(fn [word board]\n  (let [scan (fn [board]\n               (reduce (fn [acc row]\n                         (concat acc (partition-by #{\\#} (filter (complement #{\\ }) row))))\n                       [] board))\n        patterns (concat\n                   (scan board)\n                   (scan (apply map vector board)))]\n    (not (empty?\n      (drop-while\n        (fn [pattern]\n          (or (not= (count pattern) (count word))\n              (some nil? (map (fn [a b] (#{\\_ b} a)) pattern word))))\n        patterns)))))", "user": "51e28063e4b08e53a149f0f2"}, {"problem": 111, "code": "(fn cross-word2 [word mat]\n  (letfn [(fit? [mat l c word] ;;test if word fit at line l starting at col c\n            (letfn [(ok? [c1 c2] \n                      (or (= c1 c2) (= c1 \\_) (= c2 \\_)))]\n              (and (<= (+ c (count word)) (count (mat l))) \n                   (reduce \n                    #(and %1 (ok? (word %2) ((mat l) (+ %2 c))))\n                    true\n                    (range (count word)))\n                   (and (or (= c 0) ;;begn of string or previous is #\n                            (= ((mat l) (dec c)) \\#))\n                        (or (= (count (mat l)) (+ c (count word))) ;;end of \n                            (= ((mat l) (+ c -1 (count word))) \\#))))))\n          (matrixize [m]\n            (mapv #(apply vector (clojure.string/replace % #\" \" \"\")) m))\n          (transpose [mat]\n            (let [n (- (count mat) 1)]\n            (loop [i 0 ret []]\n              (if (> i n) \n                ret\n                (recur (inc i) (conj ret (mapv #(nth %1 i) mat)))))))\n          ]\n    (let [word (apply vector word)\n          mat (matrixize mat)\n          mat2 (transpose mat)\n          pos1 (for [x (range (count mat))\n                     y (range (count (mat 0)))]\n                 [x y])\n          pos2 (for [x (range (count mat))\n                     y (range (count (mat 0)))]\n                 [x y])\n          ]\n      (reduce #(or %1 %2) false\n              (concat\n               (map (fn [[x y]] (fit? mat x y word)) pos1)\n               (map (fn [[x y]] (fit? mat2 x y word)) pos2))))))", "user": "574f1c24e4b02ea114799255"}, {"problem": 111, "code": "(fn xx [s p]\n  (let [pattern (->> (map #(.replace % \" \" \"\") p)\n                     (concat (apply map str p))\n                     (mapcat #(clojure.string/split % #\"#\"))\n                     (filter #(.contains % \"_\"))\n                     (map #(.replace % \"_\" \".\"))\n                     (clojure.string/join \"|\")\n                     re-pattern)]\n    (not (nil? (re-matches pattern s)))))", "user": "56102f50e4b05f002753df6b"}, {"problem": 111, "code": "(fn [s board]\n  (letfn [(collect-words [board]\n            (let [board'     (map #(clojure.string/replace % #\" \" \"\") board)\n                  transposed (->> board'\n                                  (map seq)\n                                  (apply map list)\n                                  (map #(apply str %)))]\n              (flatten (map #(clojure.string/split % #\"#\") (concat board' transposed)))))\n\n          (match-char [c1 c2]\n            (if (= c2 \\_)\n              true\n              (= c1 c2)))\n\n          (match-word [s w]\n            (and (= (count s) (count w))\n                 (apply = (cons true (map match-char (seq s) (seq w))))))]\n    (if (some #{true} (map #(match-word s %) (collect-words board)))\n      true\n      false)))", "user": "4e9519b4535dbda64a6f6b2d"}, {"problem": 111, "code": "(fn cross-word\n  [w cross]\n  (let [m       (map #(clojure.string/replace % \" \" \"\") cross)\n        fields #(mapcat (partial re-seq #\"[^#]+\") %)\n        tr     #(apply map str %)\n        fit?   #(every?\n                  (fn [[a b]] (or (= b \\_) (= a b)))\n                  (partition 2 (interleave %1 %2)))]\n    (not (not-any?\n      #(fit? w %) \n      (filter\n        #(= (count %) (count w))\n        (fields (concat (tr m) m)))))))", "user": "50e90813e4b033b0e80d11e7"}, {"problem": 111, "code": "(letfn\n    [(cmpr [[fw & rw :as word] [fp & rp :as path]]\n       (cond\n         (not= (count word) (count path)) false\n         (not (seq path)) true\n         (or (= \\_ fp) (= fp fw)) (cmpr rw rp)\n         :else false))]\n  (fn [word puzzle]\n    (->> (map #(clojure.string/replace % #\" \" \"\") puzzle)\n      (#(concat % (if (> (count %) 1) (apply map str %))))\n      (mapcat #(clojure.string/split % #\"#\"))\n      (map #(cmpr word %))\n      (some identity)\n      (boolean))))", "user": "56795deae4b05957ce8c6187"}, {"problem": 111, "code": "(letfn [(prep [b]\n            (map #(clojure.string/replace % #\" \" \"\") b))\n          (line-candidates [st]\n            (clojure.string/split st #\"#\"))\n          (rows [b]\n            (mapcat line-candidates b))\n          (cols [b]\n            (->> b (apply map str) rows))\n          (candidates [board]\n            (->> board\n                 prep\n                 ((juxt rows cols))\n                 (apply concat)))\n          (fits? [word cand]\n            (and (= (count word) (count cand))\n                 (->> (interleave word cand)\n                      (partition 2)\n                      (every? #(or (= (second %) \\_)\n                                   (= (first %) (second %)))))))]\n    (fn legal? [word board]\n      (boolean (some (partial fits? word) (candidates board)))))", "user": "4dfe5a93535d04ed9115e786"}, {"problem": 111, "code": "(fn [w rs]\n  (letfn [(p [r]\n             (lazy-seq\n              (if (seq r)\n                (let [[a b] (split-with #(not= % \\#) (filter #(not= % \\space) r))]\n                  (cons a (p (rest b)))))))\n          \n          (b [a b]\n             (or (= a b) (= b \\_)))\n          \n          (c [m]\n             (if (= (count w) (count m))\n               (every? true? (map b w m))))]\n    (let [cs (apply map list rs)\n          ws (concat (mapcat p rs) (mapcat p cs))]\n      (true?\n       (some c ws)))))", "user": "54dd76c8e4b024c67c0cf794"}, {"problem": 111, "code": "(letfn\n  [(matches [word slot] \n    (and\n      (= (count word) (count slot))\n      (every? identity (map #(or (= %1 %2) (= %2 \\_)) word slot))))\n    (slots [rows]\n      (mapcat #(clojure.string/split % #\"#\") (map #(clojure.string/replace % \" \" \"\") rows)))\n    ]\n(fn xword\n  [word rows]\n  (boolean (some #(matches word %) (concat (slots rows) (slots (apply (partial map str) rows)))))))", "user": "57717915e4b0979f896515b3"}, {"problem": 111, "code": "(fn [w patt]\n    (let [s (fn [p] (filter identity (map #(if (= \\space %) nil %) p)))\n          patts (#(clojure.set/union % (apply map vector %)) (map s patt))\n          not-hash? (fn [c] (not= \\# c))\n          divide-on\n            (fn dv\n              ([pred coll]\n               (dv pred [] coll))\n              ([pred res coll]\n               (if (empty? coll)\n                 res\n                 (dv pred (concat res (vector (take-while pred coll))) (rest (drop-while pred coll))))))\n          holes (mapcat #(divide-on not-hash? %) patts)\n          fits-hole? (fn [h]\n                       (let [pairs (map vector w h)]\n                        (and (= (count w) (count h)) (every? (fn [[cw ch]] (or (= cw ch) (= ch \\_))) pairs))))]\n      (not (nil? (some fits-hole? holes)))))", "user": "4e837808535db62dc21a62d9"}, {"problem": 111, "code": "(fn [word crossword]\n  (let [\n        x crossword\n        transpose (fn [m] (apply mapv vector m))\n        crossword-1d (map #(clojure.string/escape %1 {\\space \"\" \\_ \".\"})\n                       (concat crossword (map clojure.string/join (transpose crossword))))\n        variants (mapcat #(clojure.string/split % #\"#\") crossword-1d)]\n    (not (every? nil? (map #(re-matches (re-pattern %) word) variants)))))", "user": "55d5e80ee4b0e31453f64a91"}, {"problem": 111, "code": "(fn [word puzzle]\n  (let [verticals (map #(apply str %) (map (fn [n] (map #(nth % n) puzzle)) (-> puzzle first count range)))\n      regexes (->> (interleave (concat puzzle verticals) (repeat \"#\"))\n              (apply str)\n              (filter #(not (= % \\space)))\n              (partition-by #(= \\# %))\n              (map #(apply str %))\n              (filter #(not (= \"#\" %)))\n              (map #(map (fn [s] (if (= s \\_) \"[a-z]\" s)) %))\n              (map #(apply str %))\n              (map re-pattern))]\n  (if (some #{word} (map #(re-find % word) regexes)) true false)))", "user": "4e9ff8d0535d7eef3080729c"}, {"problem": 111, "code": "(fn [w b]\n  (let [b (map #(clojure.string/replace % #\" \" \"\") b)\n        yes? (fn [w b]\n               (->> b\n                    (map #(clojure.string/split % #\"#\"))\n                    flatten\n                    (some (fn [p]\n                            (and (= (count w) (count p))\n                                 (every? \n                                  #(let [x (first %) y (second %)]\n                                     (or (= \\_ x) (= x y)))\n                                  (map vector p w)))))))\n        rotate (fn [b]\n                 (let [b (vec (map vec b))]\n                   (for [i (range (count (first b)))]\n                     (apply str\n                            (for [j (range (count b))]\n                              ((b j) i))))))]\n    (boolean (or (yes? w b) (yes? w (rotate b))))))", "user": "5799ff45e4b05b1deef9add1"}, {"problem": 111, "code": "(fn [w m]\n  (let [p (map #(clojure.string/replace % #\" \" \"\") m)\n        c (count p) r (count (first p))\n        getf (fn [x y] (nth (nth p x) y))\n        pos (fn [x y] (.indexOf w (str (getf x y))))]\n    (not (every? false? (flatten\n                 (for [i (range c) j (range r)]\n                   (if (pos? (pos i j))\n                     (let [reg (getf i j) chk (apply str (for [x w] (if (= reg x) x \\_)))\n                           orir (nth p i) oric (apply str (for [x (range c)] (nth (nth p x) j)))] \n                       [(map #(= % chk)\n                             (flatten \n                              [(clojure.string/split orir #\"#\") (clojure.string/split oric #\"#\")]\n                              ))]                             \n                       ) false)\n                  )))\n         )))", "user": "574abbfbe4b02ea114799200"}, {"problem": 111, "code": "(fn crossword-finder [w b]\n  (let [r clojure.string/replace b (map #(r (r % #\" \" \"\") #\"_\" \".\") b)]\n    (boolean (some #(re-find % w)\n                   (map #(re-pattern (str \"^\" % \"$\")) \n                        (flatten (map #(clojure.string/split % #\"#\")\n                                      (concat b (map #(apply str %) \n                                                     (apply map vector (map seq b)))))))))))", "user": "575b3e9be4b02ea11479935b"}, {"problem": 111, "code": "(fn __ [ww puz]\n (let [w (rest (clojure.string/split (clojure.string/lower-case ww) #\"\"))\n       P (map (fn [s] (clojure.string/split \n      \t      \t      \t (clojure.string/lower-case s) #\" \")) puz)\n      TP (apply map list P)\n      wpp (fn wpp [e puzw] \n      \t  (let [nl (remove (fn [z] (= z (list \"#\"))) (partition-by (fn [z] (= z \"#\")) puzw))]\n\t       (= true (some (fn [x] \n\t       \t     (loop [pw x m e acc []]\n\t\t     \t   (if (or (empty? pw) (empty? m))\n\t\t\t       (and (= acc e) (= (count x) (count e)))\n\t\t\t       (recur (rest pw) (rest m)\n\t\t\t       \t      (if (or (= (first pw) (first m))\n\t\t\t\t      \t      (= (first pw) \"_\"))\n\t\t\t\t\t      (conj acc (first m))\n\t\t\t\t\t      acc))))) nl))))]\n  (or (= true (some #(wpp w %) P)) (= true (some #(wpp w %) TP)))))", "user": "52747090e4b03e8d9a4a74a5"}, {"problem": 111, "code": "(fn crossword-puzzle [word puzzle]\n  (letfn [(solve-puzzle\n            [puzzle]\n            (->> puzzle\n                 (concat (apply mapv str puzzle))\n                 (mapcat #(clojure.string/split % #\"#\"))\n                 (some   (comp #(if (= % word) word nil)\n                               #(re-find % word)\n                               re-pattern\n                               #(clojure.string/replace % \"_\" \".{1}\")\n                               #(clojure.string/replace % \" \" \"\")))\n                 boolean))]\n    (solve-puzzle puzzle)))", "user": "571c2babe4b07c98581c3b73"}, {"problem": 111, "code": "(fn f [w b]\n  (let [s (fn [l] (remove #(some #{\\#} %) (partition-by #(not= \\# %) l)))\n        l (fn [b] (keep (fn [x] (filter #(not= \\  %) x)) b))\n        g (fn [x] (filter #(apply = (map count [w %])) x))\n        b (concat (mapcat s b) (when (< 1 (count b)) (apply mapcat #(s %&) b)))\n        c (fn [x] (apply str (map #({\\_ %1 %1 %1} %2) w x)))]\n    (true? (some #(= w (c %)) (g (l b))))))", "user": "548b7db8e4b0e286459a11fd"}, {"problem": 111, "code": "(fn puzzle [s b]\n  (let [ws (vec (map #(.replaceAll % \" \" \"\")  b))\n        cs (count s)]\n    (letfn [\n            (row [i]\n              (get ws i))\n            \n            (col [j]\n              (apply str (map #(get % j) ws)))\n            \n            (place? [w]\n              (if (not= (count w) cs)\n                false\n                (reduce \n                  (fn [acc i] \n                    (and acc (or (= (get w i) \\_) (= (get w i) (get s i)))))\n                  true (range cs))))\n            \n            (eval-line [ws]\n              (reduce \n                (fn [acc w] (or acc (place? w))) \n                false (clojure.string/split ws #\"#\")))]\n      \n      (or \n        (reduce \n          (fn [acc i] (or acc (eval-line (row i))))\n          false (range  (count ws)))\n        (reduce \n          (fn [acc j] (or acc (eval-line (col j))))\n          false (range (count (first ws))))))))", "user": "57d9bca1e4b0bd073c202405"}, {"problem": 111, "code": "(fn [word board]\n  (letfn [(check-valid [word line]\n            (if (some #{\\#} line)\n              (true? (some true? (map #(check-valid word %) (re-seq #\"[^#]*\" (apply str line)))))\n              (if (= (count word) (count line))\n                (if (and (seq word) (seq line))\n                  (if (or (= \\_ (first line)) (= (first word) (first line)))\n                    (check-valid (next word) (next line))\n                    false)\n                  true)\n                false)))]\n    (let [non-space-board (map #(filter (fn [ch] (not= \\space ch)) %) board)]\n      (true? (some true? (mapcat\n                           (fn [ch]\n                             (map\n                               #(check-valid word %)\n                               (filter\n                                 #(or (some #{ch} %) (every? #{\\# \\_} %))\n                                 (concat non-space-board (apply (partial map (fn [& coll] coll)) non-space-board)))))\n                           word))))))", "user": "57df309ee4b0bd073c20245f"}, {"problem": 111, "code": "(fn __ [w p]\n  (let [match (fn match [word pattern]\n                (or (and (empty? word) (empty? pattern))\n                    (and (= (count word) (count pattern))\n                         (let [pl (first pattern)\n                               wl (first word)]\n                           (if (or (and (= pl \\_)\n                                        (not= wl \\#))\n                                   (= pl wl))\n                             (match (rest word) (rest pattern))\n                             false)))))\n        word (concat [\\#] w [\\#])\n        puzzle (->> p\n                    (map (partial remove #{\\ }))\n                    (concat [(repeat (count (clojure.string/split (first p) #\" \")) \\#)])\n                    (#(concat % [(repeat (count (clojure.string/split (first p) #\" \")) \\#)]))\n                    (map #(concat [\\#] % [\\#])))\n        f (fn f [w p]\n            (if (or (empty? p)\n                    (empty? (first p))) false\n              (let [c (count w)\n                    h (take c (first p))\n                    v (take c (map first p))]\n                (or (match w h)\n                    (match w v)\n                    (f w (map rest p))\n                    (f w (rest p))))))]\n    (f word puzzle)))", "user": "57a0b341e4b0c3d858beb8d4"}, {"problem": 111, "code": "(fn legal? [s puzzle]\n  (letfn [(transpose [m] (map #(apply str %) (apply mapv vector m)))\n          (wrap# [s] (str \"#\" s \"#\"))]\n    (boolean (re-seq (re-pattern (wrap# (clojure.string/replace s #\"([a-z])\" \"( *[_$1]) *\")))\n                (wrap# (clojure.string/join \"#\" (concat puzzle (transpose puzzle))))))))", "user": "579d9601e4b05b1deef9ae18"}, {"problem": 111, "code": "(fn [word matrix]\n  (let [normatrix (map #(apply str (re-seq #\"\\S\" %)) matrix)\n        col (count (first normatrix))\n        vectors (apply conj normatrix (map (fn [x] (apply str (map #(nth % x) normatrix))) (range col)))\n        candidates (flatten (map #(clojure.string/split % #\"#\") vectors))]\n    (letfn [(match? [s1 s2]\n             (if (not (= (count s1) (count s2))) false\n               (every? true? (map #(or (= %1 \\_) (= %2 \\_) (= %1 %2)) s1 s2))))]\n      (true? (some #(match? %1 word) candidates)))))", "user": "57dd47f4e4b0bd073c20243e"}, {"problem": 111, "code": "(fn\n  [w b]\n  (letfn [(search\n            [w b]\n            (for [line b part (clojure.string/split (clojure.string/replace line #\" \" \"\") #\"#\")\n                  :when (= (count part) (count w))]\n              (every? true? (map #(or (= %1 %2) (= %2 \\_)) w part))))]\n    (or (some true? (search w b))\n        (some true? (search w (for [x (range (count (first b)))]\n              (apply str (for [y (range (count b))]\n                     (nth (b y) x))))))\n        false)))", "user": "576df252e4b0979f8965156f"}, {"problem": 111, "code": "(fn cross-word [s, vs]\n  (letfn [\n    (flatten-seqs [colls] (reduce (fn [acc b] (into acc b)) [] colls))\n    (str-norm [rowstr]\n      (if (even? (count rowstr))\n        (throw (IllegalArgumentException. \"Not even length string!\")))\n      (let [v2v (partition 2 (conj (vec rowstr) \\space))\n            vfst (vec (map first v2v))\n            vsnd (vec (map second v2v))\n            sp-only? (every? #(= \\space %) vsnd)]\n        (if-not sp-only?\n          (throw (IllegalArgumentException. \"Not regular spaces interlives!\"))\n          vfst)  ))\n    (rem-rows-sp [coll]\n      (vec (map str-norm coll)))\n    (mat-transp [mtrx]\n      (loop [acc [] mx mtrx]\n        (if (empty? (first mx))\n          acc\n          (let [newacc (conj acc (vec (map first mx)))\n                newmx (map rest mx)]\n            (recur newacc newmx))) ))\n    (match-vch? [[ca cb]]\n      (if (= \\# cb)\n        (throw (IllegalArgumentException. \"The # char not allowed in word!\"))\n        (cond\n          (= ca cb) true\n          (= cb \\_) true\n          :otherwise false)))\n    (split-at-hash [vc]\n      (loop [acc [] base vc]\n        (if (empty? base)\n          acc\n          (let [fst (take-while #(not= \\# %) base)\n                snd (rest (drop-while #(not= \\# %) base))]\n            (recur (conj acc fst) snd)))))\n    (fits? [src sfld]\n      (if-not (= (count src) (count sfld))\n        false\n        (let [zip2c (map vector src sfld)]\n          (every? match-vch? zip2c))))]\n    (let [vsrc (vec s)\n          mtrx (rem-rows-sp vs)\n          trmx (mat-transp mtrx)\n          full-mx (flatten-seqs (map split-at-hash (into mtrx trmx)))\n          vmatch (map (partial fits? vsrc) full-mx)]\n      (not-every? false? vmatch) )))", "user": "57f9011ee4b0d3187e900935"}, {"problem": 111, "code": "(fn[w st](\n\nif(> (count\n       \n (filter #(not(nil? %))  \n\n  (map \n\n  (fn[w2]( re-matches (re-pattern w2) w ))\n\n\t\t\t(flatten(map #(clojure.string/split (apply str %) #\"#\")\n\t\t\t\n\t\t\t((fn[s](\n\t\t\t  \n\t\t\t  concat \n\t\t\t  \n\t\t\t  (partition (count (first s)) (apply str s)) \n\t\t\t  \n\t\t\t  (partition (count s)\n\t\t\t    (apply\n\t\t\t      \n\t\t\t\t\t  (fn [& args](\n\t\t\t\t\t   loop[i 0 r []](\n\t\t\t\t\t   if(= i (count(first args))) r\n\t\t\t\t\t   (recur (inc i) (concat r (mapv #(nth % i) args)))\n\t\t\t\t\t   )\n\t\t\t\t\t  ))\n\t\t\t  \n\t\t\t      (map seq s)\n\n\t\t\t    )\n\t\t\t  )\n\t\t\t  \n\t\t\t))\n\t\t\t\n\t\t\t(map #( clojure.string/replace(clojure.string/replace % \" \" \"\") \"_\" \".\") st))\n\t\t\t))\n  )\n )\n) 0) true false))", "user": "56039843e4b04bb52996e1be"}, {"problem": 111, "code": "(fn [text board]\n  (letfn [(transposed []\n            (apply map (comp (partial apply str) list) board))\n          (transform [s]\n            (clojure.string/replace s\n                                    #\"[ |#|_]\"\n                                    {\" \" \"\" \"#\" \"\" \"_\" \".\"}))\n          (split-hashes [s]\n            (clojure.string/split s #\"\\#\"))\n          (free-spaces [board]\n            (map (partial map transform)\n                 (map split-hashes board)))\n          (regexd [s]\n            (re-pattern s))\n          (all-patterns []\n            (->> (concat (free-spaces board)\n                         (free-spaces (transposed)))\n                 (map (partial remove #{\"\"}))\n                 (remove empty?)\n                 flatten\n                 (map regexd)))\n          (matches-text [s]\n            (re-matches s text))]\n    ((complement not-any?)\n     (complement nil?)\n     (map matches-text (all-patterns)))))", "user": "57f0f7b8e4b0bfb2137f5bfe"}, {"problem": 111, "code": "(fn [word puzzle]\n  (let [rows (map #(vec (remove #{\\space} %)) puzzle)\n        cols (apply map vector rows)\n        blanks (mapcat #(clojure.string/split (apply str %) #\"#\")\n                       (concat rows cols))]\n    (boolean\n      (some (fn [blank]\n              (every? (fn [[a b]] (or (= \\_ a) (= a b)))\n                      (map vector blank word)))\n            (filter #(= (count %) (count word)) blanks)))))", "user": "4f5599dfe4b0a7574ea71806"}, {"problem": 111, "code": "(fn [w a]\n    (let [b (for [i (range (count (a 0)))]\n              (apply str (map #(get-in a [% i]) (range (count a)))))\n          r (re-pattern (str \".*(#|^)\" (apply str (map #(str \" *(\" % \"|_)\") w)) \" *(#|$).*\"))\n          t #(re-matches r %)]\n      (boolean (or (some t a) (some t b)))))", "user": "4f08b15b535dcb61093f6c40"}, {"problem": 111, "code": "(let [place (fn\n              [word loc]\n              (loop [[hw & tw] word\n                     [hl & tl] loc]\n                (if (or (= hl hw) (= hl \\_))\n                  (if (nil? tw) (nil? tl)\n                      (recur tw tl))\n                  false)))\n      in-line (fn\n                [word line]\n                (loop [loc line\n                       start-allowed true]\n                  (if (> (count word) (count loc)) false\n                      (if (and start-allowed (place word loc)) true\n                          (recur (rest loc) (= (first loc) \\#))))))\n      clean-line (fn [line] (filter #(not (= % \\space)) line))\n      reflect (fn [lines]\n                (loop [cur-lines lines\n                       accum []]\n                  (if (= (count (first cur-lines)) 0)\n                    accum\n                    (recur\n                     (map rest cur-lines)\n                     (conj accum (map first cur-lines))))))]\n  (fn crossword\n    [word lines]\n    (let [to-try (concat (map clean-line lines)\n                         (reflect (map clean-line lines)))\n          tries (map #(in-line word %) to-try)]\n      (if (some identity tries) true false))))", "user": "58152157e4b0f478707a0631"}, {"problem": 111, "code": ";; The board will be represented by a single string, made up of the rows and\n;; columns of the board, each seperated by a #. The final string will also be\n;; surrounded by hashes. This makes it easier to find valid matches, as the\n;; beginning and end of each row/col now has a #. Since a # is unusable, if the\n;; word is surrounded by #'s, then it must be a match.\n(fn crossword-re [word board]\n  (let [;; Strip spaces\n        rows  (map #(clojure.string/replace % #\"\\s\" \"\") board)\n        ;; Return new strings as columns\n        cols  (apply map str rows)\n        ;; Combine all the strings seperated by a #\n        strs  (reduce #(str %1 \"#\" %2) (concat rows cols))\n        ;; Turn the word into a pattern that will match an _ or letter in the\n        ;; word. E.g \"the\" -> \"[_t][_h][_e]\"\n        patt  (apply str (map #(str \"[_\" % \"]\") word))\n        ;; Create a regular expression that will look for patt inside a pair of #'s\n        regx  (re-pattern (str \"#(\" patt \")#\"))]\n    (if (re-find regx (str \"#\" strs \"#\"))\n      true\n      false)))", "user": "58327a08e4b089d5ab817c7c"}, {"problem": 111, "code": "(fn x-word [word x-word]\n  (let [board (mapv vec (mapv #(clojure.string/replace % #\" \" \"\") x-word))\n        word (vec word)\n        v-board (apply map vector board)]\n    (letfn [(gaps [row]\n              (remove #(= '(\\#) %)\n                      (partition-by #(= \\# %) row)))\n            (fits? [word gap]\n              (loop [w word g gap]\n                (let [next-letter (first w)\n                      next-in-gap (first g)]\n                  (cond\n                    (not= (count w) (count g)) false ;; Wrong number of letters for gap\n                    (and\n                     (nil? next-in-gap)\n                     (nil? next-letter)) true ;; Every letter fits in a square\n                    (or\n                     (= next-in-gap next-letter) ;; Letter fits, try next letter\n                     (= \\_ next-in-gap)) (recur (rest w) (rest g))\n                    :else false ;; A letter didn't fit in a square\n                    ))))]\n      (not (not\n            (some true? ;; Does the word fit in a gap\n                  (map (partial fits? word)\n                       (mapcat gaps (concat board v-board))\n                       )))))))", "user": "56069006e4b08b23635d3174"}, {"problem": 111, "code": "(fn [word board]\n    (->> board\n         (apply map str)\n         (concat board)\n         (map #(clojure.string/replace % #\"#|_| \" {\"#\" \"|\" \"_\" \".\" \" \" \"\"}))\n         (map #(re-matches (re-pattern %) word))\n         ((complement every?) nil?)))", "user": "55c5b55fe4b0e31453f649b5"}, {"problem": 111, "code": "(fn [word board]\n  (let [rows (map #(take-nth 2 %) board)\n        cols (apply map vector rows)\n        match? (fn [spaces]\n                 (and (= (count word) (count spaces))\n                      (->> (map vector word spaces)\n                           (every? (fn [[c s]] (#{c \\_} s))))))]\n    (->> (concat rows cols)\n         (some (fn [line]\n                 (->> line\n                      (partition-by #{\\#})\n                      (take-nth 2)\n                      (some match?))))\n         boolean)))", "user": "583e27e2e4b089d5ab817daa"}, {"problem": 111, "code": "(fn [word raw-grid]\n  (let [horizontal (->> raw-grid\n                        (map seq)\n                        (map #(take-nth 2 %)))\n        vertical (for [i (range (count (first horizontal)))]\n                   (map #(nth % i) horizontal))\n        slots (->> (concat horizontal vertical)\n                   (mapcat (fn [x]\n                             (partition-by #(= % \\#) x)))\n                   (filter #(some #{\\_} %)))\n        regex (->> slots\n                   (map #(apply str %))\n                   (map #(clojure.string/replace % #\"_\" \".\"))\n                   (map #(str \"(?i)\" %))\n                   (map re-pattern))]\n    ((complement nil?) (some #(re-matches % word) regex))))", "user": "58247423e4b051871117bec5"}, {"problem": 111, "code": "(fn right?\n  [target board]\n  (letfn [(gen-str-by-spec-column\n            [xth b]\n            (apply str (map #(nth % xth) b)))\n          (gen-strs\n            [b]\n            (let [fst-str (first b)\n                  len (count fst-str)]\n              (concat\n                b\n                (map\n                  #(gen-str-by-spec-column % b)\n                  (range len)))))\n          (split-strs\n            [strs]\n            (apply concat (map #(clojure.string/split % #\"#\") strs)))\n          (satisfied?\n            [s1 s2]\n            (and (= (count s1) (count s2))\n                 (every? true? (map #(or (= \\_ %2)\n                                      (= %1 %2))\n                                 s1 s2))))]\n    (true?\n      (some\n        true?\n        (map #(satisfied? target %)\n             (split-strs\n               (gen-strs\n                 (map #(clojure.string/replace % \" \" \"\") board))))))))", "user": "56a36f76e4b0542e1f8d14ca"}, {"problem": 111, "code": "(fn cword[ w b]\n  (let [l (count b)\n        p2 (map #(clojure.string/replace % #\" \" \"\") b)\n        b2 (if (= 1 l)\n             p2\n             (map #(apply str %) (into (map seq p2) (partition l (apply interleave p2)))))\n        p1 (flatten (map #(clojure.string/split % #\"#\")   b2))\n        p3 (filter #(= (count %) (count w)) p1)\n        ans (map #(re-pattern (clojure.string/replace % #\"_\" \"[a-z]\")) p3)\n        a2  (some true? (map #(not (nil? (re-find % w))) ans))]\n    (if (nil? a2) false a2)))", "user": "52f426fce4b05e3f0be25f1e"}, {"problem": 111, "code": "(letfn [(valid-row [goal row]\n            (loop [[a b] (split-with (complement #{\\#}) (remove #{\\space} row))]\n              (cond\n                (and (= (count a) (count goal))\n                     (every? true? (map (fn [a b] (or (= a b) (= b \\_))) goal a))) true\n                (empty? b) false\n                :default (recur (split-with (complement #{\\#}) (rest b))))))]\n    (fn [word puzzle]\n      (let [v (partial valid-row word)]\n        (true? (or (some v puzzle)\n                   (some v (apply map vector puzzle)))))))", "user": "57b3efb1e4b0fbc9809a278a"}, {"problem": 111, "code": "(fn cross-words\n  [word board]\n  (letfn [\n    (get-gaps [row]\n      (clojure.string/split row #\"#\"))\n\n    (same-length-fltr [gap]\n      (apply = (map count [word gap])))\n\n    (no-conflict-fltr [gap]\n      (every? identity (map #(or (= %1 %2) (= %1 \\_)) (seq gap) (seq word))))\n\n    (check-row [row]\n      (let [gaps (get-gaps row)\n        same-length (filter same-length-fltr gaps)\n        no-conflict (filter no-conflict-fltr same-length)\n        ]\n        no-conflict\n        ))\n\n    (check-board [rows]\n      (map check-row rows))\n\n    (transpose-board [board]\n      (let [rows (map seq board)]\n        (for [x (range (count (first board)))]\n          (apply str (map #(nth % x) rows))\n          )\n        )\n      )\n    (get-board []\n      (map #(clojure.string/replace % \" \" \"\") board)\n      )\n    ]\n    (let [clean-board (get-board)]\n\n      (not (every? empty?\n        (apply concat \n        (map \n          #(check-board %)\n          ; (check-board (transpose-board clean-board))\n          [(transpose-board clean-board) clean-board])\n        ))\n      )\n    )\n  )\n)", "user": "5545477fe4b0a04f79299531"}, {"problem": 111, "code": "(fn cr[ w b]\n  (let [rows (map #(clojure.string/replace % #\" \" \"\") b)\n        cols (apply map str rows)      \n        all (mapcat #(clojure.string/split  % #\"\\#\") (concat rows cols))        \n        out (map #(re-matches (re-pattern (clojure.string/replace % #\"_\" \"[a-z]\")) w) all)        \n        ] \n\t(not-every? nil? out)))", "user": "57887de2e4b0ebec4cfb751c"}, {"problem": 111, "code": "(fn [w l]\n   (let [t (map #(.replace % \" \" \"\") l)\n         t (concat t (apply map vector t))\n         t (mapcat #(take-nth 2 (partition-by (partial = \\#) %)) t)]\n     (or (some (fn [e]\n                 (and (= (count e) (count w))\n                      (every? true? (map #(if (= % \\_) true\n                                              (= % %2))\n                                         e w)))) t)\n         false)))", "user": "57d9f603e4b0bd073c20240a"}, {"problem": 111, "code": "(fn [s m]\n  (let [m (map #(remove #{\\space} %) m)]\n    (->> m\n      (apply map list)\n      (concat m)\n      (mapcat #(partition-by #{\\#} %))\n      (remove (comp #{\\#} first))\n      (filter #(= (count s) (count %)))\n      (map (fn [xs] (map #(or (= \\_ %) (= % %2)) xs s)))\n      (filter #(every? true? %))\n      empty?\n      not)))", "user": "50479524e4b0371827a27bc4"}, {"problem": 111, "code": "(fn crossword [word puzzle]\n  (let [clean-puzzle (mapv #(filter (fn [x] (not= \\space x)) %) puzzle)\n        rows (mapv identity clean-puzzle)\n        cols (apply mapv vector clean-puzzle)]\n    (letfn [(locs [l]\n              (map #(split-at % l) (range (count l))))\n            ;; check if spacing and end criteria matches\n            (fits? [word loc]\n              (cond (empty? word) (or (empty? loc) (= \\# (first loc)))\n                    (empty? loc) false\n                    (or (= (first word) (first loc))\n                        (= (first loc) \\_)) (recur (rest word) (rest loc))\n                    :else false\n                    )\n              )]\n      (let [row-locs (mapcat locs rows)\n            col-locs (mapcat locs cols)\n            possible-locs (filter #(and (>= (count (second %)) (count word))\n                                        (or (= (first word) (last (first %)))\n                                            (= (last (first %)) \\#)\n                                            (nil? (last (first %)))))\n                                  (concat row-locs col-locs))]\n        (boolean (some true? (map #(fits? word (second %)) possible-locs)))\n        )\n      )\n    )\n  )", "user": "589037b4e4b00487982d51d0"}, {"problem": 111, "code": "(fn valid-crossword? [s puzzle]\n  (->> (concat puzzle (apply map str puzzle))\n       (map #(clojure.string/replace % #\" |_|#\" {\" \" \"\", \"_\" \".\", \"#\" \"|\"}))\n       (some #(re-matches (re-pattern %) s))\n       boolean))", "user": "5879d577e4b01531a375ead8"}, {"problem": 111, "code": "(fn [s ms]\n  (let [data (map #(apply str (filter (complement #{\\space}) %)) ms)\n        test #(-> (str \"^\" % \"$\") (re-pattern) (re-seq s))]\n    (->> (apply mapv str data)\n         (concat data)\n         (mapcat #(-> % (.replace \"_\" \".\") (.split \"\\\\#\")))\n         (some (comp test str))\n         (boolean))))", "user": "567d132ee4b05957ce8c61c3"}, {"problem": 111, "code": "(fn [word board]\n  (letfn [(match? [[a & b] [x & y]]\n              (if (and (not= x a)\n                       (not= x \\_))\n                false\n                (if (empty? b)\n                  (or (empty? y) (= \\# (first y)))\n                  (recur b y))\n                ))\n            (fillable? [w h s]\n              (cond\n                (> (count w) (count s)) false\n                (and (or (nil? h) (= h \\_) (= h \\#)) (match? w s)) true\n                :else (recur w (first s) (rest s))))]\n      (let [board (map #(filter (partial not= \\space) %) board)]\n        (true? (or (some (partial fillable? word nil) board)\n                   (some (fn [i] (fillable? word nil (map #(nth % i) board)))\n                         (range (count (first board)))))))))", "user": "58ca8a1de4b03c36ff7e5835"}, {"problem": 111, "code": "(fn cp-placement? [word board]\n  (let [board-without-spaces (map #(clojure.string/replace % \" \" \"\") board)\n        row-regex-patterns (map #(clojure.string/replace % \"_\" \".\") board-without-spaces)\n        col-regex-patterns (apply map str row-regex-patterns)\n        regex-patterns (mapcat #(clojure.string/split % #\"#\")\n                            (concat row-regex-patterns col-regex-patterns))]\n    (boolean (some #(re-matches (re-pattern (apply str %)) word) regex-patterns))))", "user": "58ed713de4b056aecfd47d84"}, {"problem": 111, "code": "(fn bb [word board]\n  (let [board (map #(apply str %) (map (partial remove #(= % \\space)) board))\n        horizons board\n\tverticals (if (= 1 (count board)) nil (for [n (range (count (first board)))] (apply str (map #(nth % n) board))))\n        all (apply concat (map #(clojure.string/split % #\"#\") (concat horizons verticals)))\n        check (fn [a b] \n                (loop [a a b b] \n                  (cond  (and (nil? a) (nil? b)) true\n                         (nil? a) false\n                         (nil? b) false\n                         (= \\_ (first b)) (recur (next a) (next b))\n\t\t\t             (= (first a) (first b)) (recur (next a) (next b))\n                         :else false)))   \n         ]\n    (loop [n all] (cond (nil? n) false\n                        (check word (first n)) true\n                        :else (recur (next n)))) ))", "user": "577c3da9e4b0c8d87281f6b9"}, {"problem": 111, "code": "(fn crossword-puzzle [word crossword]\n      (let [horizontal-lines (map #(apply str %) (map #(remove (partial = \\space) %) crossword))\n            vertical-lines (if (= 0 (count crossword))\n                             nil\n                             (map #(apply str %) (for [k (range (count (first horizontal-lines)))]\n                                                   (map #(nth % k) horizontal-lines))))\n            vertical-horizontal-lines (concat horizontal-lines vertical-lines)\n            temp-split-words (for [k vertical-horizontal-lines]\n                               (if (some #(= % \\#) k)\n                                 (partition-by #(= % \\#) k)\n                                 k))\n            total-words (flatten (map (fn [x]\n                                        (if (seq? x)\n                                          (map #(apply str %) x)\n                                          x)) temp-split-words))]\n        (if (some \n              #(= true %)\n              (map (fn [x] (not (some #(= 'delete %) x)))\n                   (if (= '() (filter #(= (count %) (count word)) total-words))\n                     total-words\n                     (for [k (filter #(= (count %) (count word)) total-words)]\n                       (for [j (range (count word))]\n                         (if (or (= (nth k j) (nth word j))\n                                 (= \\_ (nth k j)))\n                           (nth word j)\n                           'delete))))))\n          true\n          false)))", "user": "58dcb8cde4b0a4d5acaab6a7"}, {"problem": 111, "code": "(fn [w p]\n  (let [sm (map #(replace {\\space \"\" \\_ \\.} %) p)\n        co (apply map list sm)\n        pl (mapcat #(take-nth 2 (partition-by #{\\#} %)) (concat sm co))]\n    (boolean (some #(re-matches (re-pattern (apply str %)) w) pl))))", "user": "53dbca12e4b094d41abdfef6"}, {"problem": 111, "code": "(fn [text gaps]\n   (let\n    [r clojure.string/replace\n     s clojure.string/split\n     str->pattern\n       #(map re-pattern %)\n     h-gaps\n       (map\n         #(r % #\" \" \"\")\n         gaps)\n     v-gaps\n       (apply map str h-gaps)\n     fields\n       (mapcat\n        #(s % #\"#\")\n        (concat\n         h-gaps\n         v-gaps))\n     patterns\n       (str->pattern\n        (map\n         #(r % #\"_\" \"[a-z]\")\n         fields))\n     ocurrences\n       (map\n        #(re-find % text)\n        patterns)]\n    (contains?\n     (into #{} ocurrences)\n     text)))", "user": "586a657de4b0f14aab7c88bd"}, {"problem": 111, "code": "(let [start-boundary \"(?:^|#)\" end-boundary \"(?:$|#)\"]\n      (letfn\n        [(puzzle-lines [puzzle]\n           (let [[s & more :as rows] (map #(clojure.string/replace % \" \" \"\") puzzle)]\n             (concat rows\n                     (map #(apply str (map (fn [row] (.charAt row %)) rows)) (range (.length s))))))\n         (word->pattern [word]\n           (re-pattern\n             (str start-boundary\n                  (apply str (map #(str \"[_\" % \"]\") (seq word)))\n                  end-boundary)))]\n        (fn [word puzzle]\n          (let [pattern (word->pattern word)]\n            (boolean (some (partial re-find pattern) (puzzle-lines puzzle)))))))", "user": "58ec1e63e4b056aecfd47d54"}, {"problem": 111, "code": "(fn [w s]\n    (->> (mapcat (fn [x] (partition-by #(= % \\#) (filter #(not= % \\space) x))) (concat (apply mapv vector s) s))\n\n         (map (fn [l] (if (= (count l) (count w))\n                        (every? identity (map #(or (= %1 %2)\n                                                   (= %2 \\_)) w l))\n                        )))\n         (some true?)\n          boolean\n         )\n\n    )", "user": "5921a080e4b09b4ee5954c77"}, {"problem": 111, "code": "(fn crossword [word board]\n  (let [board (map #(clojure.string/replace % \" \" \"\") board)\n        rowcols (concat board (apply map str board))\n        spots (mapcat #(clojure.string/split % #\"#\") rowcols)\n        replaceBlanks (fn [spot] (apply str (map-indexed (fn [i s] (if (or (not= s \\_) (>= i (count word))) s (nth word i))) spot)))]\n        \n        (true? (some #(= word (replaceBlanks %)) spots))))", "user": "5958cef6e4b066ee0a44af94"}, {"problem": 111, "code": "(fn valid-word? [s c]\n  (let [c-wht-spaces (map #(clojure.string/replace % #\" \" \"\") c)\n        count-c (count c)\n        interleaved-c (if (= 1 count-c) c (apply interleave c))\n        rotated-c    (->> interleaved-c\n                          (partition (count c))\n                          (map (partial apply str)))\n        all-strings  (into c-wht-spaces rotated-c)\n        all-holes    (->> all-strings\n                          (map #(clojure.string/split % #\"#\"))\n                          flatten)\n        matches      (map #(re-matches\n                            (re-pattern\n                             (clojure.string/replace % \"_\" \"\\\\w\")) s) all-holes)\n        result       (not-every? nil? matches)]\n    result))", "user": "51aefceee4b09397d5109797"}, {"problem": 111, "code": "(fn crossword \n  ([word board] \n    (let [rows (vec (map #(vec %) board)) cols (apply map list rows)]\n      (loop [lines (concat rows cols)]\n        (if (empty? lines) false\n          (let [line (vec (remove #(= % \\space) (first lines)))]\n            (or (crossword (vec word) line line 0 0) (recur (rest lines)))\n          )\n        )\n      )\n    )\n  )\n  ([characters board current board_index char_index]\n    ;if there's _ we can either place char or not\n    ;if there's # we stop current input, since we haven't used all characters\n    ;if there's a char we check if it's equal to target char\n    \n    (cond \n      (nil? (nth characters char_index nil))\n      (and (contains? #{\\# nil} (nth current board_index nil)) (contains? #{\\# nil} (nth current (- board_index (count characters) 1) nil)))\n      \n      (nil? (nth board board_index nil)) false ;reached end without using all characters\n      ;recursion step\n      :else\n        (let [board-field (nth board board_index) target-char (nth characters char_index)\n              progress_with_input #(crossword characters board (assoc current board_index target-char) (inc board_index) (inc char_index))\n              progress_without_input #(crossword characters board (vec board) (inc board_index) 0)]\n    \n\n          (case board-field\n            \\_ (or (progress_with_input) (progress_without_input))\n            \\#  (progress_without_input)\n            (if (= target-char board-field) (progress_with_input) (progress_without_input)) ;character case\n          )\n        )\n    )\n  )\n)", "user": "5991d2fae4b0866487ed0d68"}, {"problem": 111, "code": "(fn [w fld] (\n              letfn [\n              (cmp[s1 s2] (or (= s1 s2) (= s1 \\_)))       \n              \n              (sw[s1 s2] (\n                           cond \n                           (empty? s2) true\n                           (empty? s1) false\n                            :e (and (cmp (first s1) (first s2)) (sw (rest s1)(rest s2)))  \n                              ))\n                            \n              (v[sx i] (\n                         cond\n                         (and (> i 0) (not (= (nth sx (dec i)) \\#))) false\n                         (and (< i (- (count sx) (count w))) (not (= (nth sx (+ i (count w))) \\#))) false\n                         :e true\n                         ))\n\n            (fit[sx] (\n                       reduce #(or %1 %2) false (loop [i 0 acc []]\n                       (\n                        if (< i (count sx)) \n                        (recur (inc i) (concat acc [(and (sw (drop i sx) w) (v sx i))]))\n                        acc\n                        )\n                       )))\n            \n              (r[sx](clojure.string/replace sx #\" \" \"\"))\n                     ]\n              \n              (or\n              (reduce #(or %1 (->> %2 (r)(fit))) false fld)\n              (reduce #(or %1 (fit %2)) false (partition (count fld) (apply interleave (reduce #(conj %1 (r %2)) [] fld))))\n              )\n              \n              ))", "user": "596f6683e4b069c0a1a19877"}, {"problem": 111, "code": "(fn [word cw]\n  (let [cleansed (map #(remove #{\\space} %) cw)\n        words #(clojure.string/split (apply str %) #\"#\")\n        horizontal-words (mapcat words cleansed)\n        vertical-words (mapcat words (apply map vector cleansed))\n        word-map (into {} (group-by count (concat horizontal-words vertical-words)))]\n    (-> (some\n          #(every? (fn [[x y]] (or (= x y) (= \\_ y))) (map vector word %))\n          (get word-map (count word)))\n        boolean)))", "user": "56d68cbae4b0ea9b8538f7cd"}, {"problem": 111, "code": "(fn __ [st x]\n  (let [\n        y (seq st)\n        trimmedRows (map (fn [st] (clojure.string/split st #\" \")) x)\n        all (concat trimmedRows (apply map list trimmedRows))\n        splitBy (fn [x] (partition-by #(= \"#\" %) x))\n        unhashed (filter (fn [x] (not= x '(\"#\"))) (mapcat splitBy all))\n        check (fn [patt]\n                (and\n                  (= (count patt) (count y))\n                  (every? identity (map (fn [a b] (or (= (str a) (str b)) (= a \"_\"))) patt y))))\n        matches (map check unhashed)\n        res (true? (some true? matches))\n        ]\n    (println y unhashed matches)\n    res))", "user": "58bc6a88e4b0888cdc949d16"}, {"problem": 111, "code": "(fn valid-word?\n    [word xword]\n    (let [is-match?\n          (fn [word run]\n              (and\n                (= (count word) (count run))\n                (every?\n                  (fn valid-slot [pair]\n                    (or\n                       (= (first pair) (last pair))\n                       (not (nil? (some #(= \\_ %) pair)))))\n                  (map vector word run))))\n\n          \n          rows\n          (map #(clojure.string/replace % #\" \" \"\") xword)\n\n          cols\n          (for [col (range 0 (-> rows first count))]\n            (clojure.string/join (mapv #(nth % col) rows)))\n\n          matches-slice?\n          (fn [slice]\n            (let [runs (clojure.string/split slice #\"#\")]\n              (some #(is-match? word %1) runs)))]\n        (not\n          (nil?\n            (or\n              (some matches-slice? rows)\n              (some matches-slice? cols))))))", "user": "4fe49706e4b0e8f79898feb7"}, {"problem": 111, "code": "; Evil hack\n(fn [& _]\n  (reify Object\n    clojure.lang.IPersistentCollection\n    (seq [_])\n    (cons [_ _])\n    (empty [_])\n    (equiv [_ _] true)))", "user": "51e58e02e4b0efabf93c02d0"}, {"problem": 111, "code": "(fn is-fit [word board]\n  (let [board (into [] (map #(clojure.string/replace % \" \" \"\") board))\n        enumerate-columns (fn [board]\n                            (let [ch (partition (count board)\n                                                (for [x (range (count (first board)))\n                                                      y (range (count board))] (get-in board [y x])))]\n                              (map #(apply str %) ch)))\n        enumerate-patterns (fn [board]\n                             (let [columns (enumerate-columns board)\n                                   all (concat columns board)]\n                               (->> (map #(clojure.string/split % #\"#\") all)\n                                    (flatten)\n                                    (map #(clojure.string/replace % \"_\" \".\"))\n                                    (map re-pattern))))]\n    (->> (enumerate-patterns board)\n         (map (fn [regex] (re-matches regex word)))\n         (filter (complement nil?))\n         (count)\n         (< 0))))", "user": "59be62d5e4b0a024fb6ae435"}, {"problem": 111, "code": "(fn cw [word board]\n  (let [word (map clojure.string/lower-case word)\n        horizontals (map #(filter (partial not= \\space) %) board)\n        verticals (apply map vector horizontals)\n        lines (map #(map clojure.string/lower-case %) (concat horizontals verticals))\n        to-fill (filter (partial not-every? #{\"#\"}) (reduce #(concat %1 (partition-by (partial = \"#\") %2)) [] lines))]\n\n    (boolean (some (fn [poss]\n                     (and (= (count poss) (count word))\n                          (every? boolean (map #(or (= %1 \"_\") (= %1 %2)) poss word))))\n                to-fill))))", "user": "58b51e05e4b0ebc645576d4c"}, {"problem": 111, "code": "(fn [w p]\n  (let [sm (map #(replace {\\space \"\" \\_ \\.} %) p)\n        co (apply map list sm)\n        pl (mapcat #(take-nth 2 (partition-by #{\\#} %)) (concat sm co))]\n    (boolean (some #(re-matches (re-pattern (apply str %)) w) pl))))", "user": "59358f74e4b04f87174def52"}, {"problem": 111, "code": "(fn crossword-word-fits?[word crossword]\n    (letfn [\n        (get-words [line]\n            (clojure.string/split (clojure.string/replace line #\" \" \"\") #\"#\")\n        )\n        (get-column [crossword n]\n            (apply str (map #(nth % n) crossword))\n        )\n        (word-fits? [word test]\n            (and (= (count word) (count test))\n                 (every? true? (map #(or (= %1 %2) (= %1 \\_)) test word))\n            )\n        )\n    ]\n    (let [columns (map (partial get-column crossword) (filter even? (range (count (first crossword)))))\n         words (mapcat get-words (into crossword columns))]\n         (boolean (some true? (map (partial word-fits? word) words)))\n        )\n    )\n)", "user": "59a0262ee4b0871e7608b82d"}, {"problem": 111, "code": "(fn [word puzzle]\n  (let [puzzle (map (partial filter #(not= \\space %)) puzzle)\n        puzzle-transpose (apply (partial map vector) puzzle)\n        word-len (count word)\n        wildcard-eq (fn [xs ys]\n                      (cond\n                        (and (empty? xs) (empty? ys)) true,\n                        (not= (count xs) (count ys)) false,\n                        (and (or (= (first xs) \\#) (= (first ys) \\#))\n                             (not= (first xs) (first ys))) false,\n                        (or (= (first xs) \\_)\n                            (= (first ys) \\_)\n                            (= (first xs) (first ys))) (recur (rest xs) (rest ys)),\n                        :else false))\n        check-line (fn [row]\n                     (when (seq row)\n                       (or\n                        (wildcard-eq word (apply str row))\n                        (wildcard-eq (str word \"#\") (apply str (take (inc word-len) row)))\n                        (recur (rest (drop-while #(not= % \\#) row))))))]\n    (if (or (some check-line puzzle)\n            (some check-line puzzle-transpose))\n      true\n      false)))", "user": "59ee6801e4b0966464fe6a1f"}, {"problem": 111, "code": "(fn crossword [word puzzle]\n  (let [puzzle (map #(clojure.string/replace % #\" \" \"\") puzzle)\n        test-fit (fn [region]\n          (and (>= (count region) (count word))\n               (reduce #(and %1 %2) (map #(or (= %1 %2) (= \\_ %2)) word region))\n               (or (= (count region) (count word))\n                   (= \\# (nth region (count word))))))\n        double-loop (fn [[outer-init inner-init outer-step]]\n                      (loop [puzzle puzzle]\n                        (if (outer-init puzzle)\n                            (or\n                              (loop [line (inner-init puzzle)]\n                                    (if line\n                                        (or\n                                          (test-fit line)\n                                          (recur (next (drop-while #(not= \\# %) line))))\n                                        false))\n                              (recur (outer-step puzzle)))\n                            false)))]\n    (reduce\n      #(or %1 %2)\n      (map double-loop [[identity first next]\n                        [first #(map first %) #(map next %)]]))))", "user": "55f73078e4b06e875b46cea4"}, {"problem": 111, "code": "(fn[word split-rows]\n        (let [parse-row\n              (fn[s]\n                clojure.string/join \"\" \n                (clojure.string/split s #\" \"))\n\n              rows \n              (into [] (map parse-row split-rows))\n\n              no-rows \n              (count rows)\n              \n              no-cols \n              (count (rows 0))\n\n              char-eq\n              (fn [a b]\n                (= (str a) \n                   (str b)))\n          \n              ;; either is _ or they're the same\n              match-letter\n              (fn [a b]\n                (or (char-eq a \\_) \n                    (char-eq b \\_)\n                    (char-eq a b)))\n\n              match-brick\n              (fn [c]\n                (char-eq c \\#))\n              \n              ;; cell accessor\n              cell\n              (fn [r c]\n                (let [row (get rows r nil)]\n                  (if row\n                    (get row c))))\n\n              ;; cell matcher\n              match-cell\n              (fn [r c ch]\n                (match-letter (cell r c) ch))\n\n              match-boundary\n              (fn [r c]\n                (let [ret (or\n                           (> 0 r)\n                           (> 0 c)\n                           (>= r no-rows)\n                           (>= c no-cols)\n                           (match-brick (cell r c)))]\n                  ret))\n\n              ;; word matcher\n              match-word\n              (fn [r c o]\n                (let [word-constraint\n                      (cond\n                 \n                       (= :vert o) \n                       (every? identity (for [i (range (count word))]\n                                          (match-cell (+ i r) c (get word i \"#\"))))\n                 \n                       :else\n                       (every? identity (for [i (range (count word))]\n                                          (match-cell r (+ i c) (get word i \"#\")))))\n                      \n                      boundary-constraint\n                      (cond\n                 \n                       (= :vert o) \n                       (and \n                        (match-boundary (- r 1) c)\n                        (match-boundary (+ r (count word)) c))\n                 \n                       :else\n                       (and \n                        (match-boundary r (- c 1))\n                        (match-boundary r (+ c (count word)))))\n                       \n                       ret\n                       (and word-constraint\n                           boundary-constraint)]\n                  \n                  ;; (prn r c o \" --> \" word-constraint boundary-constraint ret)\n                  ret))\n              \n              checkers\n              (for [r (vec (range no-rows))\n                    c (vec (range no-cols))\n                    o [:vert :horiz]]\n                (match-word r c o))]\n\n          (or (some identity checkers) false)))", "user": "57e6f90de4b0bfb2137f5af6"}, {"problem": 111, "code": "(fn [w p]\n    (let [wc (count w)\n          ws (seq w)\n          p' (map (fn [r]\n                    (->> (seq r)\n                         (filter #(not= \\space %)))) p)]\n      (->> (concat p' (apply map vector p'))\n           (mapcat #(partition-by (fn [e] (= \\# e)) %))\n           (filter #(= (count %) wc))\n           (some (fn [r] (->> (map list r ws)\n                              (every? (fn [[x l]]\n                                        (or (= x \\_)\n                                            (= x l)))))))\n           boolean)))", "user": "59fa241ee4b0ca45a743a358"}, {"problem": 111, "code": "(fn [s cw]\n  (let [rplc clojure.string/replace\n        ptrn #(-> \n               (str \"^\" %2 \"$\") \n               (rplc #\"_|\\s\" {\"_\" \".\" \" \" \"\"}) \n               re-pattern \n               (re-matches %1))\n        tst? #(some (partial ptrn %1) (.split %2 \"#\"))]\n    (boolean\n      (some \n        (partial tst? s) \n        (->> cw (apply map str) reverse (concat cw))))))", "user": "59f91b99e4b0ca45a743a33a"}, {"problem": 111, "code": "(fn [wrd inp_lst]\n  (let [stripped (map (fn [x] (clojure.string/replace x #\"\\s\" \"\")) inp_lst)\n        turned (reduce (fn [acc s1] (map (fn [o n] (str o n))(map (fn[x] x) acc) (map (fn [z] z) s1))) stripped )\n        combined (concat stripped turned)\n        splitted (apply concat (map (fn [x0] (clojure.string/split (str x0) #\"#\")) combined))\n        okLen (filter #(= (count %) (count wrd)) splitted)\n        ]\n    (reduce (fn [acc b] (or acc b)) false \n            (map (fn [v1] (reduce (fn [acc b] (and acc b)) true v1))\n                 (map\n                   (fn [spWrd] (map (fn [g h] \n                                      (if (= g h) true (if (= h \\_) true false)) \n                                      ) (map identity wrd) (map identity spWrd)))\n                   okLen)))))", "user": "533c2605e4b0e30313ee6cd7"}, {"problem": 111, "code": "(fn sol [w xss]\n  (letfn [\n          (delstrspace [astr]\n  (apply str (filter #(not (= \\space %)) astr))\n  )\n\n(delspace [xss]\n  (vec (map delstrspace xss) )\n  )\n\n(charok [c1 cx]\n  (cond (= c1 cx) true\n        (= cx \\_) true\n        :else false;\n  )\n)\n\n(passen [w wx] ; wx with _\n  (if (= (count w) (count wx));)\n    (every? true? (map charok w wx))\n    false\n  )\n)\n\n(possw [w xs]\n  (let [borders (map first \n                     (filter #(= (second %) \\#) (map-indexed vector xs)))\n       b1 (first borders)\n       l1 (last borders)\n       len (count xs)\n\n        realbords\n        (cond (and (= b1 0 ) (= l1 (dec len)))\n                  borders\n             (= b1 0)  (conj (vec borders) len)\n             (= l1 (dec len)) (cons -1 borders)\n             :else (conj (vec (cons -1 borders)) len)\n       )\n      \n      wordinds \n      (partition 2 (interleave (map #(+ % 1) (drop-last realbords))\n                  (drop 1 realbords)) )\n     ]\n      (loop [ws wordinds]\n          \n          (if (empty? ws) false;)\n            (let [w2 (first ws)\n                 wds (subvec (vec xs) (first w2) (second w2))]\n               (if (passen w wds) true\n                   (recur (rest ws))\n               )\n             )\n        )\n    )\n  )\n)\n\n          (possws [w xss]\n  (let [rpossw\n        (for [r (range  (count xss))]\n           (possw w (xss r))\n        )\n\n        cpossw\n        (for [c (range  (count (xss 0)))]\n           (possw w (apply str (map #((vec %) c) xss)))\n          )\n        ]\n      (concat rpossw cpossw)\n    )\n)\n     \n          ]\n  \n  \n  (if  (some true? (possws w (delspace xss))) true false);\n    )\n)", "user": "59ff9424e4b01bb0ae8afd24"}, {"problem": 111, "code": "(fn [w c]\n    (let [c (map #(vec (filter (fn [x] (not= x \\ )) %)) c)\n          s (count w)]\n      (true?\n        (some\n          (fn [l]\n            (let [n (count l)\n                  i (filter\n                      #(and\n                         (or (= 0 %) (= (nth l (dec %)) \\#))\n                         (<= (+ s %) n)\n                         (or (= n (+ s %)) (= (nth l (+ s %)) \\#)))\n                      (range n))]\n              (some\n                (fn [p]\n                  (every?\n                    identity\n                    (map #(or (= %1 \\_) (= %1 %2)) p w)))\n                (map #(subvec l % (+ % s)) i))))\n          (concat\n            c\n            (map\n              (fn [i] (vec (map #(nth % i) c)))\n              (range (count (first c)))))))))", "user": "5a2df4a0e4b09cafd31c7f74"}, {"problem": 111, "code": "(fn [word board]\n  (let [word (clojure.string/lower-case word)\n        board (map #(-> %\n                        (clojure.string/replace #\"_\" \"\\\\\\\\w\")\n                        (clojure.string/split #\" \")) board)\n        flip-board (partial apply map concat)\n        get-candidate\n        (fn [board]\n          (apply concat (map #(-> %\n                                  clojure.string/join\n                                  (clojure.string/split #\"#\"))\n                             board)))\n        candidates (->> (concat board (flip-board board))\n                        get-candidate\n                        distinct\n                        (map re-pattern))]\n    (not-every? nil? (map #(re-matches % word) candidates))))", "user": "54c5cc17e4b045293a27f624"}, {"problem": 111, "code": "(fn [s vs]\n    (let [mtch (fn f [a b] (let [ha (first a) hb (first b)] \n                    (cond (every? empty? [a b]) true\n                          (some   empty? [a b]) false\n                          (or (= ha hb) (= \\_ ha) (= \\_ hb)) (f (rest a) (rest b))\n                          :else false)))\n          field (map #(clojure.string/replace % #\"\\s+\" \"\") vs)\n          field- (apply map str field)\n          prp (fn [s] (clojure.string/split s #\"#\"))]\n  (boolean (some (partial mtch s) (concat (mapcat prp field) (mapcat prp field-)))) ))", "user": "5a4de614e4b05d388ecb6bb1"}, {"problem": 111, "code": "(fn [x b]\n  (let [normal (map #(.replaceAll % \" \" \"\") b)\n        rows   (mapcat #(.split % \"#\") normal)\n        cols   (apply mapcat (fn [& cs] (.split (apply str cs) \"#\")) normal)\n        cross  (fn [r x] (apply str (map #(if (#{\\_} %) %2 %) r x)))\n        any?   (fn [p c] (if (some p c) true false))]\n    (->> (concat rows cols)\n         (filter #(= (count x) (count %)))\n         (map #(cross % x))\n         (any? #{x}))))", "user": "58f44c07e4b0438e51c2ceb7"}, {"problem": 111, "code": "(fn can-place? [word cwd]\n  (let [crossword (mapv #(clojure.string/replace % \" \" \"\") cwd)\n        make-patterns #(let [split (clojure.string/split % #\"#\")]\n                             (map \n                              (fn [x]\n                                (str \"^\" \n                                     (clojure.string/replace x \"_\" \".\")\n                                     \"$\"))\n                              split))\n        row-words (mapcat make-patterns crossword)\n        column-words (mapcat make-patterns \n                             (reduce #(into % (vector (apply str %2)))\n                                     [] \n                                     (apply (partial map vector) crossword)))\n        patterns (concat row-words column-words)]\n    (boolean (some #(re-find % word) (map re-pattern patterns)))))", "user": "57a0f256e4b0c3d858beb8dd"}, {"problem": 111, "code": "(fn cp [w v]\n  (let [split #(clojure.string/split % #\"\\s\")\n        join #(clojure.string/join \"\" %)\n        ->ws (fn [f v] (-> #(map join (partition-by #{\"#\"} (f %)))\n                           (map v)\n                           flatten))]\n    (not\n     (empty?\n      (remove nil?\n              (map #(re-seq (re-pattern (str \"^\" (clojure.string/replace % #\"_\" \".\") \"$\")) w)\n                   (remove\n                    #(or (contains? #{#{\\_} #{\\#}} (set %))\n                         (not (contains? (set %) \\_)))\n                    (concat (->ws split v)\n                            (->ws identity (apply map vector (map split v)))))))))))", "user": "59f043d0e4b0966464fe6a3d"}, {"problem": 111, "code": "(fn [word puzzle]\n  (->> (map #(clojure.string/replace % #\"_\" \".\") puzzle) ;; underscores to dots\n       (map #(remove #{\\space} %))                       ;; remove spaces\n       (#(concat % (apply map list %)))                  ;; pivot rows/columns\n       (map #(apply str %))                              ;; make strings\n       (mapcat #(clojure.string/split % #\"#\"))           ;; break around hashes\n       (map re-pattern)                                  ;; make regexes\n       (map #(re-matches % word))                        ;; test regexes\n       (not-every? nil?)))                               ;; check for match", "user": "5ad63a34e4b0ea6055cfac01"}, {"problem": 111, "code": "(fn [word board]\n  (letfn [(transpose [m] (apply mapv str m))\n          (strip-ws [s] (clojure.string/replace s #\" \" \"\"))\n          (create-pattern [s]\n            (re-pattern\n              (apply str \"^\" (clojure.string/replace s #\"_\" \".\") \"$\")))\n          (get-slots [line] (clojure.string/split line #\"#\"))]\n  (let [board (mapv strip-ws board)]\n    (boolean\n      (some \n        #(= word %)\n        (map \n          (fn [slot] (re-matches (create-pattern slot) word))\n          (concat\n            (mapcat get-slots board)\n            (mapcat get-slots (transpose board)))))))))", "user": "5aa998c6e4b0d174b936c8e5"}, {"problem": 111, "code": "(fn [w v] (let [sfv (map (fn [s] (vec (filter #(not= \\space %) s))) v) pls (into [] (concat (mapcat (fn [s] (->> s (partition-by #(= % \\#)) (filter #(not= (first %) \\#)))) sfv) (mapcat (fn [i] (filter #(not= (first %) \\#) (partition-by #(= % \\#) (map (fn [s] (nth s i)) sfv)))) (range 0 (count (first sfv))))))] (or (some (fn [pl] (reduce #(and %1 %2) (map (fn [cpl cw] (or (= cpl cw) (= cpl \\_))) pl w))) (filter (fn [pl] (= (count pl) (count w))) pls)) false)))", "user": "5abe2fc2e4b073f17744271e"}, {"problem": 111, "code": "(fn f[w s] \n  (let [sq (map (partial filter (partial not= \\space)) s)\n        seqs (concat sq (apply map vector sq))\n        split-fn \n          (fn split-fn [s]\n            (cond\n              (empty? s)        nil\n              (= \\# (first s))  (split-fn (rest s))\n              (= \\# (last s))   (split-fn (butlast s))\n              (every? (partial not= \\#) s) (list s)\n              :else (cons (take-while (partial not= \\#) s)\n                          (split-fn (drop-while (partial not= \\#) s)))))\n        strs (mapcat split-fn seqs)\n        mk-pattern \n          (fn mk-pattern [s] \n            (concat \"^\" (map #(if (= % \\_) \"\\\\w\" \n                                  (str \\[ % \\])) s) \"$\"))\n        pattern-strs (map (partial apply str) (map mk-pattern strs))\n        pattern-str (clojure.string/join \"|\" pattern-strs)]\n      (not= nil (re-find (re-pattern pattern-str) w))))", "user": "575ddfd1e4b02ea11479938d"}, {"problem": 111, "code": "(fn [p s]\n  (let [s (map (fn [t] (filter #(not= % \\space) t)) s)\n        r (count s)\n        l (count (first s))\n        rs1 (mapcat\n              #(let [e (nth s %)]\n                 (loop [rs [] m [] j 0]\n                   (if (= j l)\n                     (if (empty? m)\n                       rs\n                       (conj rs m))\n                     (if (= \\# (nth e j))\n                       (recur (if (empty? m) rs (conj rs m))\n                              []\n                              (inc j))\n                       (recur rs (conj m [% j]) (inc j))))))\n              (range r))\n        rs2 (mapcat\n              #(loop [rs [] m [] j 0]\n                 (if (= j r)\n                   (if (empty? m)\n                     rs\n                     (conj rs m))\n                   (if (= \\# (nth (nth s j) %))\n                     (recur (if (empty? m) rs (conj rs m))\n                            []\n                            (inc j))\n                     (recur rs (conj m [j %]) (inc j)))))\n              (range l))\n        f (fn [rs]\n            (->>\n              (filter #(= (count %) (count p)) rs)\n              (map #(map\n                      (fn [[i j]]\n                        (nth (nth s i) j))\n                      %))\n              (some (fn [t]\n                     (every? true?\n                       (map\n                           (fn [x y]\n                             (or (= x \\_) (= x y)))\n                           t\n                           p))))))]\n    (if (or (f rs1) (f rs2))\n      true\n      false)))", "user": "5af907e6e4b0cc2b61a3bcda"}, {"problem": 111, "code": "(fn [s b]\n (->> b\n  (map #(take-nth 2 %))  \n  (map #(replace {\\_ \\.} %))\n  (#(concat % (apply map list %)))\n  (mapcat #(partition-by #{\\#} %))\n  (map #(apply str %))\n  (map re-pattern)\n  (map #(re-matches % s))\n  (every? nil?)\n  not))", "user": "5b0180cfe4b0cc2b61a3bd47"}, {"problem": 111, "code": "(fn [word grid]\n  (let [cgrid (->> grid\n                   (map vec)\n                   (map (fn [v] (map #(nth v %) (range 0 (count v) 2)))))\n        w (count (first cgrid))\n        h (count cgrid)\n        cword (vec word)\n        wordlen (count cword)\n        fromgrid (fn [x y] (if (and (< x w) (>= x 0) (< y h) (>= y 0))\n                             (nth (nth cgrid y) x) \\#))\n        testgrid (fn [x y pred] (pred (fromgrid x y)))\n        fits (fn [ch x y]\n               (let [inbounds (and (>= ch 0) (< ch wordlen))]\n                 (testgrid x y (if inbounds\n                                 #(or (= % \\_) (= % (nth cword ch)))\n                                 #(= % \\#)))))\n        allfits (fn [x y dx dy] (every? #(fits % (+ x (* dx %)) (+ y (* dy %))) (range -1 (inc wordlen))))]\n    (boolean (some (fn [x] (some (fn [y] (or (allfits x y 1 0) (allfits x y 0 1))) (range h))) (range w)))))", "user": "5b465b8be4b02d533a91bc65"}, {"problem": 111, "code": "(fn crossword-puzzle [word board]\n  (let [board (vec (map #(clojure.string/replace % \" \" \"\") board))\n        rows board\n        cols (for [j (range (count (first rows)))]\n               (apply str (map #(get-in board [% j]) (range (count rows)))))\n        word-fits? (fn [slate start]\n                     (and (<= (+ start (count word)) (count slate))\n                          (contains? #{\\# nil} (get slate (dec start)))\n                          (contains? #{\\# nil} (get slate (+ start (count word))))\n                          (every? (fn [[c1 c2]] (or (= c1 c2) (= c2 \\_)))\n                                  (map vector word (subs slate start)))))]\n    (true?\n     (reduce\n      (fn [b slate]\n        (or b (some #(word-fits? slate %) (range (count slate)))))\n      false\n      (concat rows cols)))))", "user": "5b51b9f8e4b02d533a91bcfe"}, {"problem": 111, "code": "(fn crossword [goal mat]\n  (let [mat (->> mat (map (fn [s] (->> s (filter #(not= \\space %)) vec))) vec)\n        glen (count goal)\n        valid (fn [h x y] (for [d (range glen) :let [i (if h x (+ x d))\n                                                     j (if h (+ y d) y)\n                                                     c (get-in mat [i j])]]\n                            ({\\_ true (nth goal d) true} c)))\n        h-valid #(every? true? (valid true % %2))\n        v-valid #(every? true? (valid false % %2))\n        res (for [i (-> mat count range) j (-> mat first count range)]\n              (or (and (= \\# (get-in mat [i (dec j)] \\#)) (= \\# (get-in mat [i (+ j glen)] \\#)) (h-valid i j))\n                  (and (= \\# (get-in mat [(dec i) j] \\#)) (= \\# (get-in mat [(+ i glen) j] \\#)) (v-valid i j))))]\n    (boolean (some true? res))))", "user": "5953bdb6e4b066ee0a44aeed"}, {"problem": 111, "code": "(fn [s b]\n (->> b\n  (map #(take-nth 2 (replace {\\_ \\.} %)))\n  (#(into % (apply map list %)))\n  (mapcat #(partition-by #{\\#} %))\n  (map #(re-pattern (apply str %)))\n  (map #(re-matches % s))\n  (not-every? nil?)))", "user": "5b61aa6ae4b0c6492753e712"}, {"problem": 111, "code": "(fn __ [term raw-board]\n  (letfn [(tokenize-board [rows]\n            (into []\n                  (for [row rows]\n                    (into []\n                          (filter\n                           #(not= % \\ )\n                           (map\n                            #(case %\n                               \\_ nil\n                               %)\n                            (seq row)))))))\n          (fit? [term tokens]\n            (let [term-count (count term)\n                  token-count (count tokens)\n                  take-n (if (<= term-count token-count)\n                           token-count\n                           term-count)]\n              (when (every?\n                     (fn [[term-token board-token]]\n                       (and (not= term-token ::eol)\n                            (not= board-token ::eol)\n                            (or (nil? board-token)\n                                (= term-token board-token))))\n                     (take take-n\n                           (map vector (concat\n                                        (seq term)\n                                        (repeat ::eol))\n                                (concat tokens\n                                        (repeat ::eol)))))\n                tokens)))\n          (spaces [row]\n            (remove\n             #{(list \\#)}\n             (partition-by #{\\#}\n                           row)))\n          (fit-row? [term row]\n            (some\n             (partial fit? term)\n             (spaces row)))\n          (transpose-left [board]\n            (apply map\n                   (fn [& row-tokens]\n                     (into [] row-tokens))\n                   (map reverse\n                        board)))]\n    (let [board (tokenize-board raw-board)]\n      (not\n       (nil?\n        (or\n         ;; horizontal\n         (some\n          (partial fit-row? term)\n          board)\n         ;; vertical\n         (some\n          (partial fit-row? term)\n          (transpose-left board))))))))", "user": "54246fcce4b01498b1a71aed"}, {"problem": 111, "code": "(fn fits? [word input-field]\n  (let [field (->> input-field\n                   (map #(clojure.string/replace (apply str %) \" \" \"\"))\n                   (map #(clojure.string/replace (apply str %) \"_\" \".\")))\n        all-lines (concat field (apply map vector field))\n        line-fit? (fn [line]\n                    (->> (partition-by #(= % \\#) line)\n                         (filter #(not= % '(\\#)))\n                         (map #(apply str %))\n                         (map #(re-matches (re-pattern (str \"^\" % \"$\")) word))\n                         (some (complement nil?))))]\n    (->> all-lines\n         (map line-fit?)\n         (some (complement nil?))\n         (boolean))))", "user": "5b13ba71e4b0cc2b61a3be53"}, {"problem": 111, "code": "(fn crossword-puzzle\n  [word puzzle]\n  (loop [v-pos 0 h-pos 0]\n    (if (= v-pos (count puzzle))\n      false\n      (let [h-place (-> (get-in puzzle [v-pos])\n                        (subs h-pos)\n                        (clojure.string/replace #\" \" \"\")\n                        (clojure.string/replace #\"_\" \"[a-z]\")\n                        re-pattern)\n            v-place (-> (apply str (map #(get-in puzzle [% h-pos])\n                                        (range v-pos (min\n                                                      (+ v-pos (count word))\n                                                      (count puzzle)))))\n                        (clojure.string/replace #\" \" \"#\")\n                        (clojure.string/replace #\"_\" \"[a-z]\")\n                        re-pattern)\n            [new-v-pos new-h-pos] (if (> (inc h-pos) (count (first puzzle)))\n                                    [(inc v-pos) 0]\n                                    [v-pos (inc h-pos)])]\n        (if (or (and (or (= 0 h-pos)\n                         (= \\# (get-in puzzle [v-pos (dec h-pos)])))\n                     (re-matches h-place word))\n                (re-matches v-place word))\n          true\n          (recur new-v-pos new-h-pos))))))", "user": "5125029de4b0ce9225d2ed3e"}, {"problem": 111, "code": "(fn [goal mx]\n    ; row and col are 0-based; col is lower than num-cols, i.e. it \"skips\" whitespaces (assuming well/consistently-positioned whitespace)\n    (let [goal (seq goal)\n          places (fn [mixed] (filter #(not= \\space %) mixed)) ;mixed is a row, or a column. See also coll-full.\n          first-row (mx 0)\n          num-cols (count (places first-row))\n          \n          col-full (fn [col]\n                     ; An outer (places ...) is not needed.\n                     (map #(nth\n                             (places %)\n                             col)\n                       mx))\n          row-full (fn [row]\n                     (places (mx row))) ;assuming \"good\" formatting\n          ;slice of a column, starting at [row col] position\n          col (fn [r-index c-index] (drop r-index (col-full c-index)))\n          row (fn [r-index c-index] (drop c-index (row-full r-index)))\n          \n          count-goal (count goal)\n          ;whether goal fits from the start of slice, up to end of slice or up to \\#\n          fits (fn [slice]\n                 (and (or\n                          (= count-goal (count slice))\n                          (and (< count-goal (count slice))\n                               (= \\# (nth slice count-goal))))\n                      (every? identity ;can't (apply and ...) because and is a macro\n                        (map #(#{% \\_} %2) goal slice))))\n          place (fn [r-index c-index] ;it expects \"good\" formatting\n                  (nth (row-full r-index) c-index))]\n      \n      (boolean\n        (some identity\n          (for [r-index (range 0 (count mx))\n                c-index (range 0 num-cols)]\n            (or (and (or (zero? c-index)\n                         (= \\# (place r-index (dec c-index))))\n                     (fits (row r-index c-index)))\n                (and (or (zero? r-index)\n                         (= \\# (place (dec r-index) c-index)))\n                     (fits (col r-index c-index)))))))))", "user": "5b999af8e4b0c0b3ffbd4ad3"}, {"problem": 111, "code": "(fn [w xs]\n             (let [xs (map #(.replace % \" \" \"\") xs)\n                   match? (fn [a]\n                            (and (= (count a) (count w))\n                                 (every? (fn [[x y]] (or (= \\_ x) (= x y))) (map vector a w))))\n                   fits? (fn [xs] (->> (mapcat #(.split % \"#\") xs)\n                                       (some match?)\n                                       boolean))]\n               (or (fits? (apply map str xs))\n                   (fits? xs))))", "user": "567c63f6e4b05957ce8c61bb"}, {"problem": 111, "code": "(fn [s board]\n    (not (nil? (some #(re-matches % s)\n                     (->> (concat board (apply map str board))\n                          (map #(replace {\\_ \\. \\# \\| \\space \"\"} %))\n                          (map #(apply str %))\n                          (map re-pattern))))))", "user": "54f26266e4b024c67c0cf8c5"}, {"problem": 111, "code": "(fn [w p]\n  (let [sm (map #(replace {\\space \"\" \\_ \\.} %) p)\n        co (apply map list sm)\n        pl (mapcat #(take-nth 2 (partition-by #{\\#} %)) (concat sm co))]\n    (boolean (some #(re-matches (re-pattern (apply str %)) w) pl))))", "user": "5bbdd136e4b07a9b28b0ffab"}, {"problem": 111, "code": "(fn __ [word board]\n  (letfn [(accommodate?\n            [word room]\n            (and (= (+ 2 (count word))\n                    (count room))\n                 (= (first room) \\#)\n                 (= (last room) \\#)\n                 (every? boolean\n                         (map\n                          #(or (= %1 %2) (= %2 \\_))\n                          word\n                          (rest room)))))\n\n          (row-accommodate?\n            [word row]\n            (let [wl (+ 2 (count word)) ; include pre/post char\n                  rl (+ 2 (count row))\n                  nr  (concat '(\\#) row '(\\#))]\n              (some boolean\n                    (for [p (range 0 (inc (- rl wl)))]\n                      (accommodate? word (take wl (drop p nr)))))\n              )\n            )]\n\n    (let [hboard (vec (map #(vec (filter (partial not= \\space) %)) board))\n          vboard (apply map list hboard)]\n      (boolean\n        (some boolean\n              (for [row (concat hboard vboard)]\n                (row-accommodate?\n                 (seq word)\n                 row)))))\n      ))", "user": "5a0ce1a5e4b04bbd27e6d9b7"}, {"problem": 111, "code": "(fn [wr input]\n(let [puzzle (vec (map #(vec (re-seq #\"_|#|[a-zA-Z]\" %)) input)) \n      wd (count (puzzle 0)) ht (count puzzle) w (re-seq #\"[a-zA-Z]\" wr)]\n(letfn [\n(usable? [x y] (and (< -1 x wd) (< -1 y ht) (not= \"#\" ((puzzle y) x))))\n(suitable? [l x y] (and (usable? x y) (#(or (= \"_\" %) (= l %)) ((puzzle y) x)) ))\n(simple-placeD? [w x y]\n\t(cond\n     \t(empty? w) (not (usable? x y))\n        (suitable? (first w) x y) (simple-placeD? (rest w) x (inc y))\n        :else false\n    )\n)\n(simple-placeA? [w x y]\n\t(cond\n     \t(empty? w) (not (usable? x y))\n        (suitable? (first w) x y) (simple-placeA? (rest w) (inc x) y)\n        :else false\n    )\n)\n(place? [w x y]\n\t(or\n\t\t(and (not (usable? (dec x) y)) (simple-placeA? w x y))\n\t\t(and (not (usable? x (dec y))) (simple-placeD? w x y))\n\t)\n)\n]\n(reduce (fn [v y] (or v (reduce  (fn [u x] (or u (place? w x y) )) false (range wd)))) false (range ht))\n))\n)", "user": "5be6d0f8e4b0f319e2d7ec51"}, {"problem": 111, "code": "(fn [word board]\n  (let [ntoxy (fn [co [n b]]\n                (list (list (quot n co) (rem n co)) b))\n        trans_maze (fn [maze]\n                     (let [co (count (first maze))]\n                       (apply hash-map (mapcat #(ntoxy co %) (keep-indexed #(list % %2)(into [] (apply str maze)))))))\n        tr_board (trans_maze board)\n        find_spot (fn [tr_board] (filter #(if (= (second %) \\_) true false) tr_board))\n        spots (find_spot tr_board)\n        find_pos (fn [word spot]\n                   (let [c (count word)\n                         x (first spot)\n                         y (second spot)]\n                     (list\n                      (map #(vector % %2)(map #(list x %) (map #(+ (* 2 %)y)(range c))) word)\n                      (map #(vector % %2)(map #(list % y)(map #(+ % x)(range c))) word))))\n        founds  (map #(find_pos word (first %)) spots)\n        check (fn [found tr_board]\n                (let [r1 (map (fn [z] (map #(if (or (= (tr_board (first %))(second %))(=(tr_board (first %)) \\_))\n                                              true false) z)) found)]\n                  (list (into [] (if (every? true? (first r1)) (first found) nil))\n                        (into [] (if (every? true? (second r1)) (second found) nil)))))\n        r2s (filter #(not (= % '([][])))(map #(check % tr_board) founds))\n        check_boundary (fn [r2, tr_board]\n                         (let [x (first r2)\n                               y (second r2)]\n                           (list (if (= []  x)\n                                   nil\n                                   (let [[r1 c1] (first (first x))\n                                         [rn cn] (first (last x))]\n                                     (and  (or (nil? (tr_board (list r1 (- c1 2))))(= (tr_board (list r1 (- c1 2))) \\#))\n                                           (or (nil? (tr_board (list rn (+ cn 2))))(= (tr_board (list rn (+ cn 2))) \\#)))))\n                                 (if (= [] y)\n                                   nil\n                                   (let [[r1 c1](first (first y))\n                                         [rn cn](first (last y))]\n                                     (and (or (nil? (tr_board (list (- r1 1) c1)))(= (tr_board (list (- r1 1) c1)) \\#))\n                                          (or (nil? (tr_board (list (+ rn 1) cn)))(= (tr_board (list (+ rn 1) cn)) \\#))))))))\n        ]\n    (if (some true? (flatten (map #(check_boundary % tr_board) r2s)))\n      true false)\n    ))", "user": "566d71b1e4b0a866af6896ca"}, {"problem": 111, "code": "(fn [w p]\n  (let [sm (map #(replace {\\space \"\" \\_ \\.} %) p)\n        co (apply map list sm)\n        pl (mapcat #(take-nth 2 (partition-by #{\\#} %)) (concat sm co))]\n    (boolean (some #(re-matches (re-pattern (apply str %)) w) pl))))", "user": "5c2649c8e4b07e362c2305bf"}, {"problem": 111, "code": "(fn [wd pz]\n  (letfn [(mx [ln]\n              (let [wds (clojure.string/split (clojure.string/replace (clojure.string/replace (apply str ln) #\"_\" \".\") #\"\\s\" \"\") #\"#\")]\n                (some #(re-find (re-pattern (str \"^\" % \"$\")) wd  ) wds)   ))]\n    (boolean (some mx (concat pz (apply map list pz))))))", "user": "5b919d9de4b0c0b3ffbd4a24"}, {"problem": 111, "code": "(fn crossword-puzzle\n  [word displayed-board]\n  (letfn [(is-boundry?\n            [letter]\n            (or (= \\# letter) (nil? letter)))\n\n          (horizontal-check\n            [word board x y]\n            (and\n\n             (let [letter-before\n                   (get-in board [x (dec y)])\n                   \n                   letter-after\n                   (get-in board [x (+ y (count word))])]\n\n               (and (is-boundry? letter-before) (is-boundry? letter-after)))\n\n   \n             (every? true?\n                     (map-indexed (fn [y-inc letter]\n                                    (let [field-val\n                                          (get-in board [x (+ y y-inc)])\n\n                                          valid?\n                                          (or (= \\_ field-val) (= letter field-val))]\n                            \n                                      valid?\n                                      )) word))))\n\n          (vertical-check\n            [word board x y]\n            (and\n\n             (let [letter-before\n                   (get-in board [(dec x) y])\n                   \n                   letter-after\n                   (get-in board [(+ x (count word)) y])]\n\n               (and (is-boundry? letter-before) (is-boundry? letter-after)))\n   \n\n             (every? true?\n                     (map-indexed (fn [x-inc letter]\n                                    (let [field-val\n                                          (get-in board [(+ x x-inc) y])\n\n                                          valid?\n                                          (or (= \\_ field-val) (= letter field-val))]\n                             \n                                      valid?\n                                      )) word))))\n\n          (field-check\n            [word board x y]\n            (or (vertical-check word board x y) (horizontal-check word board x y)))]\n    (let [board        (mapv (fn [x] (vec (remove #(= \\space %) x))) displayed-board)\n          row-count    (count board)\n          column-count (count (first board))]\n      \n      (boolean\n       (some\n        true?\n        (for [x (range 0 row-count) y (range 0 column-count)]\n          (let [field-answer (field-check word board x y)]\n            (when field-answer\n              (println x \" \" y))\n            field-answer)))))))", "user": "5b759ca8e4b047b03b2036d0"}, {"problem": 111, "code": "(fn crossWord [word coll]\n  (letfn \n  [(gp [word n]\n  (if \n  (and \n    (= (count word) (count n))\n    (not-any?\n      #(and\n          (not= (second %) \\_)\n          (not= (second %) (first %)))\n      (partition 2 (interleave word n))))\n  true\n  (if \n    (or \n      (>= (count word) (count n))\n      (and\n        (not= (first n) \\#) \n        (not-any? #(not= \\_ %) (rest n))))\n    false\n    (recur word (rest n)))))]\n  (let [slots (into\n      (for [x (apply map vector (map #(clojure.string/replace % #\" \" \"\") coll))] (apply str x))\n      (for [x (map #(clojure.string/replace % #\" \" \"\") coll)] (apply str x)))]\n    (loop \n      [n (first slots)\n      colls (rest slots)]\n      (if \n        (or \n        (gp word n)\n        (gp word (reverse n)))\n        true\n        (if \n          (empty? colls)\n          false\n          (recur (first colls) (rest colls))))))))", "user": "5b3251c1e4b025bcb146f317"}, {"problem": 111, "code": "(fn [s v] (let [r (filter (fn [i] (= (count s) (count i)))(mapcat (fn [w] (clojure.string/split w #\"#\")) (#(let [c (map (fn [v] (clojure.string/replace v #\" \" \"\"))  %)](concat c (apply map str c))) v)))]\n          (if (some #(every? true? (map (fn [x y] (or (= x y) (= y \\_ ))) (seq s) (seq %))) r) true false) \n ))", "user": "5c379636e4b0d62ef62d9f76"}, {"problem": 111, "code": "(fn placeable-on-crossword? [word crossword]\n  (let [sanitized-board (map #(clojure.string/replace % \" \" \"\") crossword)\n        vertical-board (map (fn [i] (apply str (map #(nth % i) sanitized-board))) \n                            (range (count (first sanitized-board))))\n        horizontal-spots (remove empty? (map #(clojure.string/split % #\"#\") \n                                             sanitized-board))\n        vertical-spots (remove empty? (map #(clojure.string/split % #\"#\") \n                                           vertical-board))\n        spot-regexes (map #(-> % (clojure.string/replace \"_\" \".\") re-pattern) \n                          (apply concat (concat horizontal-spots \n                                                vertical-spots)))]\n    (boolean (some #(re-matches % word) spot-regexes))))", "user": "5c506951e4b0f9f7a8770ec5"}, {"problem": 111, "code": "(fn can-be-placed?\n  [s grid]\n  (let [rows (map #(vec (remove (partial = \\space) %)) grid)\n        columns (apply mapv vector rows)\n        possible-slots (mapcat #(clojure.string/split (apply str %) #\"#\")\n                               (concat rows columns))\n        fits? (fn [s slot]\n                (and (= (count s) (count slot))\n                     (->> [s slot]\n                          (apply mapv vector)\n                          (every? (fn [[s-char slot-char]] (#{s-char \\_} slot-char))))))]\n    (boolean (some (partial fits? s) possible-slots))))", "user": "5b602a66e4b0c6492753e6fc"}, {"problem": 111, "code": "(fn [concrete pattern] (boolean\n                           (letfn\n                             [(match-string [pat concr] (do\n                                                          (println pat \" - \" concr)\n                                                          (loop\n                                                            [p pat c concr]\n                                                            (cond\n                                                              (and (empty? p) (empty? c)) (do (println \"true!\") true)\n                                                              (or (empty? p) (empty? c)) (do (println \"false!\") false)\n                                                              (or (= (first p) \\_) (= (first p) (first c))) (recur (rest p) (rest c))\n                                                              :else (println \" false!!\" false)\n                                                              )\n                                                            )\n                                                          )\n                                )\n                              (clean-pattern [pat]\n                                (filter\n                                  #(not= [\\#] %)\n                                  (map\n                                    #(filter (fn [elem] (not= \\space elem)) %)\n                                    (apply concat (map (fn [darab] (partition-by #(= \\# %) darab)) pat)))))]\n                             (or\n                               (some #(match-string % concrete) (clean-pattern pattern))\n                               (some #(match-string % concrete) (clean-pattern (apply map vector pattern)))))))", "user": "5c9dcb36e4b048ec896c5b1d"}, {"problem": 111, "code": ";; http://www.4clojure.com/problem/111\n(fn place-word-crossword?\n  [word puzzle]\n  (let [replace-word? (fn [src target]\n                        (if (= (count src) (count target))\n                          (every? true? (map (fn [a b] (or (= a b) (= b \\_))) src target))\n                          false\n                          )\n                        )\n        place-word? (fn [src target]\n                      (not-every? false? \n                                  (map #(replace-word? src %) (clojure.string/split \n                                                               (clojure.string/replace target #\" \" \"\") #\"#\"))))\n        transpose (fn [coll]\n                    (apply (partial  map #(apply list %&)) coll))]\n        (or (not-every? false? (map #(place-word? word %) puzzle))\n            (not-every? false? (map #(place-word? word (apply str %)) (transpose puzzle))))\n    ;;(map #(place-word? word (apply str %)) (transpose puzzle))\n        ;;(transpose puzzle)\n    ))", "user": "5c92105ce4b048ec896c59f7"}, {"problem": 111, "code": "(fn solve-crossword [word-input grid-input]\n  (let [word (into [] (map str word-input))\n        word-len (count word)\n        grid (into [] (map #(into [] (clojure.string/split % #\" \")) grid-input))]\n\n    (->> (concat grid (map #(map (fn [y] (get-in grid [y %])) (range (count grid)) ) (range (count (first grid)))))\n         (remove #(< (count %) word-len))\n         (filter (fn match-word [cand]\n                 \n                   (loop [[w & ws] word\n                          [c & cs] cand]\n                     (cond\n                       (and (nil? w) (nil? c)) true\n                       (nil? c) false\n                       (and (nil? w) (= c \"#\")) true\n\n                       (nil? w) false\n                       (or (= c w)\n                           (= c \"_\")) (recur ws cs)\n                       (= c \"#\") (recur word cs)\n                       (= (first cs) \"#\") (recur word (rest cs))\n                       :else false\n                       ))))\n         empty?\n         not)))", "user": "527ccaf4e4b0757a1b17136d"}, {"problem": 111, "code": "(fn\n  [s cwp]\n  (let [rows (map (fn [row] (filter #(not (= \\space %)) row)) cwp)\n        cols (apply map list rows)\n        re-s (str \"(^|#)\" (apply str (map #(str \"[\" % \"_]\") s)) \"($|#)\")]\n    (not (empty? (keep #(re-find (re-pattern re-s) %)\n                       (map #(apply str %) (concat rows cols)))))))", "user": "5d1b2b7de4b02ea6f0fb697a"}, {"problem": 111, "code": "(fn crossword-puzzle [word rows]\n  (let [cols (mapcat #(clojure.string/split % #\"#\")\n                     (remove empty? (apply map (fn [& args]\n                                                 (clojure.string/trim (clojure.string/join args)))\n                                           rows)))\n        rows (map #(clojure.string/replace % #\" \" \"\") (mapcat #(clojure.string/split % #\"#\") rows))\n        candidates (filter #(= (count %) (count word)) (concat cols rows))]\n    (not (empty?\n          (filter (fn [candidate]\n                    (reduce #(and %1 %2) (map #(or (= %1 \\_) (= %1 %2)) candidate word)))\n                  candidates)))))", "user": "5d6042f2e4b0c9e5857d5006"}, {"problem": 111, "code": "(fn[w ws]\n   (letfn [(word-match [s] (->> (clojure.string/split (clojure.string/replace s \" \" \"\") #\"#\")\n                                (filter #(= (count w) (count %)))\n                                (mapcat seq)\n                                (map (fn [a b] (or (= a b) (= b \\_))) w)))\n           (find-word-match [xs] (->> xs\n                                      (mapcat #(clojure.string/split (clojure.string/replace % \" \" \"\") #\"#\"))\n                                      (map (fn[s] (word-match s)))\n                                      (map #(and (not (empty? %)) (every? true? %)))\n                                      (some #{true})\n                                      (true?)))]\n     (or (find-word-match (apply map (fn [& args] (apply str args)) ws))\n         (find-word-match ws))))", "user": "5d764e52e4b02e6b30c93524"}, {"problem": 111, "code": "(fn [word board]\n  (let [lines (concat board (apply map str board))]\n    (-> (clojure.string/join \"|\" lines)\n        (clojure.string/replace #\"[ #_]\" {\" \" \"\"\n                                          \"#\" \"|\"\n                                          \"_\" \".\"})\n        (re-pattern)\n        (re-matches word)\n        boolean)))", "user": "5db0172be4b0f8c104ccfc96"}, {"problem": 111, "code": "(fn crossword-111\n  [word board]\n  (let [board (mapv (comp vec (partial remove #{\\space})) board)\n        width (count (first board))\n        height (count board)\n        +' (partial map +)\n        candidates (for [row (range height)\n                         col (range width)\n                         dir [[0 1] [1 0]]]\n                     (map\n                       (fn [mag]\n                         (get-in\n                           board\n                           (+' [row col]\n                               (map (partial * mag) dir))\n                           \\#))\n                       (range -1 (inc (count word)))))\n        fits? (fn [c]\n                (and (#{\\#} (first c))\n                     (#{\\#} (last c))\n                     (every?\n                       (fn [[x y]]\n                         (or (= x y) (#{\\_} y)))\n                       (map vector word (subvec (vec c) 1 (dec (count c)))))))]\n    (not (empty? (filter fits? candidates)))))", "user": "5d0bb4fae4b0cc9c91588237"}, {"problem": 111, "code": "(fn crossword [word table]\n  (let [table (vec (map #(vec (filter (fn [x] (not= x \\space)) %)) table))\n        vertical (for [i (range 0 (count table))\n                       j (range 0 (count (first table)))\n                       :let [prev (get-in table [(dec i) j])\n                             end (get-in table [(+ i (count word)) j])]\n                       :when (or (not prev) (= prev \\#))\n                       :when (or (not end) (= end \\#))]\n                   (map (comp (partial get-in table) vector)\n                        (range i (+ i (count word))) (repeat j)))\n        horizontal (for [i (range 0 (count table))\n                         j (range 0 (count (first table)))\n                         :let [prev (get-in table [i (dec j)])\n                               end (get-in table [i (+ j (count word))])]\n                         :when (or (not prev) (= prev \\#))\n                         :when (or (not end) (= end \\#))]\n                     (map (comp (partial get-in table) vector)\n                          (repeat i) (range j (+ j (count word)))))\n        consistent? (fn [candidate]\n                      (loop [candidate candidate word word]\n                        (cond\n                          (empty? candidate) true\n                          (= (first candidate) \\_) (recur (rest candidate) (rest word))\n                          (= (first candidate) (first word)) (recur (rest candidate) (rest word))\n                          :else false)))]\n    (boolean (or (seq (filter consistent? vertical)) (seq (filter consistent? horizontal))))))", "user": "5d9c1226e4b0d3f9b434ad51"}, {"problem": 111, "code": "(fn crossword [s board]\n  (let [;transforms\n        s (clojure.string/lower-case s)\n        len (count s)\n        trans (comp clojure.string/lower-case\n                    #(clojure.string/replace % #\" \" \"\"))\n        board (map trans board)\n        ;check\n        blank (fn [s1 s2]\n                (if (= s2 \\_) true (= s1 s2)))\n        match (fn [line]\n                (and (= (count line) len)\n                     (every? identity (map blank s line))))\n        check (fn [board]\n                (->> board\n                     (mapcat #(clojure.string/split % #\"#\"))\n                     (some match)\n                     boolean))]\n    (or (check board) (check (apply map str board)))))", "user": "5ba15075e4b0a20761a2339e"}, {"problem": 111, "code": "(fn crossword [s board]\n    (let\n        [\n            to_vec\n                (fn [board]\n                    (vec (map (fn [s] (vec (clojure.string/replace s #\"\\s+\" \"\"))) board))\n                )\n            rotate\n                (fn [board]\n                    (vec (apply map (comp vec list) board))\n                )\n            flatten_board\n                (fn [board]\n                    (vec (mapcat\n                        (fn [x]\n                            (->> x\n                                (partition-by #(= \\# %))\n                                (filter #(not= \\# (first %)))\n                                (map vec)\n                            )\n                        )\n                    board))\n                )\n            check_string\n                (fn [xs ys]\n                    (if (not= (count xs) (count ys))\n                        false                            \n                        (loop [xs xs ys ys]\n                            (let [a (first xs) b (first ys)]\n                                (cond\n                                    (or (= a nil) (= b nil)) (= a b)\n                                    (or (= a b) (= a \\_) (= b \\_)) (recur (rest xs) (rest ys))\n                                    :otherwise false\n                                )\n                            )\n                        )\n                    )\n                )\n            search_vec\n                (vec s)\n            vec_board\n                (to_vec board)\n            has_solution\n                (fn [search flat_board]\n                    (some true? (map (partial check_string search) flat_board))\n                )\n        ]\n        (true? (or\n            (has_solution search_vec (flatten_board vec_board))\n            (has_solution search_vec (flatten_board (rotate vec_board)))\n        ))\n    )\n)", "user": "5db7376fe4b010eb3c36cd43"}, {"problem": 111, "code": "(fn [word grid]\n  (let [vword (vec (remove #{\"\"} (clojure.string/split word #\"\")))\n        vgrid (vec (map #(clojure.string/split % #\" \") grid))\n        in-row? (fn [row]\n                  (let [runs (filter (fn [indices] (every? (fn [[c i]] (#{c \"_\"} (row i)))\n                                                           (map vector vword indices)))\n                                     (partition (count word) 1 (range (count row))))]\n                    (some (fn [run]\n                            (let [first-i (first run) last-i (last run)]\n                              (and (or (= first-i 0) (= (row (dec first-i)) \"#\"))\n                                   (or (= last-i (dec (count row))) (= (row (inc last-i)) \"#\")))))\n                          runs)))\n        across? (fn [rows] (some in-row? rows))]\n    (boolean (or (across? vgrid) (across? (vec (apply map vector vgrid)))))))", "user": "5db92996e4b010eb3c36cd50"}, {"problem": 111, "code": "(fn [word board]\n  (let [split (fn [b] (mapcat #(clojure.string/split % #\"#\") b))\n        board (->> board\n                   (map #(clojure.string/replace % \"_\" \".\"))\n                   (map #(clojure.string/replace % #\"\\s+\" \"\")))\n        v (split board)\n        h (->> board (apply map str) split)]\n    (->> (concat h v)\n         set\n         (map #(str \\^ % \\$))\n         (map re-pattern)\n         (some #(re-find % word))\n         boolean)))", "user": "5ab16992e4b073f1774425c4"}, {"problem": 111, "code": "(fn match-board [word board]\n  (let\n    [\n     compress       (fn [line]\n                      (apply str (map first (partition-all 2 line))))\n     compress-board (fn [board]\n                      (map compress board))\n     letters-match  (fn [[wc tc]]\n                      (or (= wc tc) (= \\_ tc)))\n     words-match    (fn [w1 w2]\n                      (and\n                        (= (count w1)(count w2))\n                        (every? letters-match (map vector w1 w2))))\n     line-match     (fn [word line]\n                      (some #(words-match word %) (clojure.string/split line #\"\\#\")))\n     board-match    (fn [word board]\n                      (some true? (map #(line-match word %) board)))\n\n     flip-board     (fn  [b]\n                      (map #(apply str %) (apply map (cons vector b))))\n     ]\n    (boolean (or\n               (board-match word (compress-board board))\n               (board-match word (flip-board (compress-board board)))\n               ))))", "user": "590b055ae4b047aa04b199c9"}, {"problem": 111, "code": "(fn [word board]\n  (let [pattern (re-pattern (apply str (map #(str \"[\" % \"_]\") word)))\n        clean-board (mapv #(clojure.string/replace % #\"\\s\" \"\") board)\n        trans-board (apply mapv str clean-board)\n        places (mapcat #(clojure.string/split % #\"#\") (concat clean-board trans-board))]\n    (not= nil (some #(re-matches pattern %) places))))", "user": "5dd60c58e4b0948ae9d9ad7c"}, {"problem": 111, "code": "(fn [w p]\n  (let [puzzle (map #(clojure.string/replace % #\"\\s+\" \"\") p)\n        down (apply map (fn [& ls] ls) puzzle)\n        puzzle-spaces (mapcat #(remove (fn [s] (= s [\\#])) (partition-by (fn [c] (= \\# c)) %)) (concat down puzzle))\n        wm (fn [s sp] (and (= (count s) (count sp)) (every? true? (map (fn [c sc] (or (= sc \\_) (= c sc))) s sp))))]\n    (= 1 (count (filter true? (map (partial wm w) puzzle-spaces))))))", "user": "529dfc6de4b04e0c58e87b8a"}, {"problem": 111, "code": "(fn [w p]\n  (let [sm (map #(replace {\\space \"\" \\_ \\.} %) p)\n        co (apply map list sm)\n        pl (mapcat #(take-nth 2 (partition-by #{\\#} %)) (concat sm co))]\n    (boolean (some #(re-matches (re-pattern (apply str %)) w) pl))))", "user": "5e00b6e7e4b0a607a9a45d2b"}, {"problem": 111, "code": "(fn [word board]\n  (letfn [(to-new-board [old-board]\n                        (map #(clojure.string/replace % \" \" \"\") old-board))\n          (transpose [seqs]\n                     (for [i (range (count (first seqs)))]\n                       (apply str (map (fn [sq] (nth sq i)) seqs))))\n          (get-patterns [old-board]\n                        (->>\n                          (concat (to-new-board old-board) (transpose (to-new-board old-board)))\n                          (mapcat #(clojure.string/split % #\"#\"))\n                          (map #(clojure.string/replace % \"_\"  \"\\\\w\"))\n                          (map re-pattern)))]\n    (not (empty? (keep #(re-matches % word) (get-patterns board))))))", "user": "5e0d948fe4b099d064962f98"}, {"problem": 111, "code": "(fn [wrd xss]\n  (let [rows (mapv #(clojure.string/replace % #\" \" \"\") xss)\n        cols (apply mapv str rows)\n        all (mapcat #(clojure.string/split % #\"#\") (concat rows cols))\n        same-size (filter #(= (count wrd) (count %)) all)\n        can-fit? (fn f [wrd field]\n                   (or (and (empty? wrd) (empty? field))\n                       (and (or (= \\_ (first field))\n                                (= (first wrd) (first field)))\n                            (f (rest wrd) (rest field)))))\n        ]\n    (boolean (and (seq same-size) (some #(can-fit? wrd %) same-size)))))", "user": "5d81b40ce4b0915913b1d379"}, {"problem": 111, "code": "(fn [word board]\n  (letfn [(check-valid [word line]\n            (if (some #{\\#} line)\n              (true? (some true? (map #(check-valid word %) (re-seq #\"[^#]*\" (apply str line)))))\n              (if (= (count word) (count line))\n                (if (and (seq word) (seq line))\n                  (if (or (= \\_ (first line)) (= (first word) (first line)))\n                    (check-valid (next word) (next line))\n                    false)\n                  true)\n                false)))]\n    (let [non-space-board (map #(filter (fn [ch] (not= \\space ch)) %) board)]\n      (true? (some true? (mapcat\n                           (fn [ch]\n                             (map\n                               #(check-valid word %)\n                               (filter\n                                 #(or (some #{ch} %) (every? #{\\# \\_} %))\n                                 (concat non-space-board (apply (partial map (fn [& coll] coll)) non-space-board)))))\n                           word))))))", "user": "5d9c9446e4b0eb781811cdae"}, {"problem": 111, "code": "(fn match?\n  [aim-str board]\n  (let [get-dot-str (fn [board]\n                      (->> (map #(clojure.string/replace % #\"[ ]\" \"\") board)\n                           (map #(clojure.string/replace % #\"[_]\" \".\"))\n                           (map #(clojure.string/split % #\"[#]\"))\n                           flatten\n                           (filter #((complement empty?) %))))\n        row (get-dot-str board)\n        col (get-dot-str (apply map str board))\n        res-str (concat row col)\n        matchers (remove nil? (map #(re-seq (re-pattern (str \"^\" % \"$\")) aim-str) res-str))]\n    (println \"===\" matchers)\n    ((complement zero?) (count matchers))))", "user": "5cf72682e4b0b71b1d808a68"}, {"problem": 111, "code": "(fn [word puzzle]\n    (let [rows (map (fn [row] (filter #(not= % \\space) row)) puzzle)\n          columns (apply map vector rows)]\n      (letfn [(fits? [word places]\n                (->> (partition-by #(= % \\#) places)\n                     (filter #(= (count word) (count %)))\n                     (some (fn [postfix]\n                             (->> (map vector word postfix)\n                                  (every? (fn [[w p]]\n                                            (or (= p \\_)\n                                                (= w p)))))))))]\n        (boolean (or\n                  (some #(fits? word %) rows)\n                  (some #(fits? word %) columns))))))", "user": "5d236215e4b02ea6f0fb6a09"}, {"problem": 111, "code": "(fn [w g]\n    (letfn [(transpose ([g] (apply mapv vector g)))\n            (h-fit-at-pos [r c w m]\n              (let [hdim    (count (first m))\n                    vdim    (count m)\n                    target  (get-in m [r c])\n                    initial (first w)\n                    next-c  (if (< (inc c) hdim) (get-in m [r (inc c)]) nil)\n                    prev-c  (if (<= 0 (dec c)) (get-in m [r (dec c)]) nil)]\n                (cond\n                  (or \n                   (zero? (count w))\n                   (= target \\#)\n                   (<= vdim r)\n                   (<= hdim c)\n                   (and prev-c (not (#{\\# \\*} prev-c)))\n                   (and (not= target \\_) (not= target initial)))   false\n                  (and (= 1 (count w))\n                       (or (nil? next-c) (#{\\# \\*} next-c))) true\n                  :else                                      (h-fit-at-pos r (inc c) (subs w 1) (assoc-in m [r c] \\*)))))]\n      (let [matrix       (mapv (comp vec (partial remove #{\\space}) seq) g)\n            trans-matrix (transpose matrix)]\n        (or (some true?\n                  (for [r (range (count matrix))\n                      c (range (count (first matrix)))]\n                    (or (h-fit-at-pos r c w matrix)\n                        (h-fit-at-pos c r w trans-matrix)))) false))))", "user": "583048d9e4b051871117c007"}, {"problem": 111, "code": "(fn cw [w b]\n  (let [cb (map #(clojure.string/replace % #\"\\s\" \"\") b)\n        rows (map #(str \"#\" % \"#\") cb)\n        cols (apply map #(str \"#\" (apply str %&) \"#\") cb)\n        pattern (re-pattern (str \".*#\" (apply str (map #(str \"[_|\" % \"]\") w)) \"#.*\"))]\n    ((comp not nil? some) #(re-matches pattern %) (concat rows cols))))", "user": "5e3a25d4e4b01d43a70e8dde"}, {"problem": 111, "code": "(fn crossword [w cw]\n  (let [match (fn  [word cw-line]\n                (loop [w word l cw-line]\n                  (cond\n                    (empty? w) (or (empty? l) (= (first l) \\#))\n                    (empty? l) false\n                    (= (first l) \\#) (recur word (rest l))\n                    (= (first l) \\_) (recur (rest w) (rest l))\n                    (not= (Character/toLowerCase (first w)) (Character/toLowerCase (first l))) (recur word (drop-while (partial not= \\#) l))\n                    :else (recur (rest w) (rest l)))))\n        some? (complement nil?)]\n    (->>\n     cw\n     (map (partial filter #(not (Character/isWhitespace %))))\n     ((juxt identity #(apply map list %)))\n     (apply concat)\n     (some (partial match w))\n     (some?))))", "user": "5471f2fbe4b094393f72dd70"}, {"problem": 111, "code": "(fn [target lines]\n   (let [convert #(-> %\n                      (clojure.string/replace  \" \" \"\")\n                      (clojure.string/replace \"_\" \".\"))\n         patterns (map convert lines)\n         find-match (fn [lines]\n                      (some\n                       (fn [line]\n                         (let [len (count target)]\n                           (some\n                            #(re-matches % target)\n                            (map re-pattern (clojure.string/split line #\"#\")))))\n                       lines))\n         some? #(not (nil? %))]\n     (some? (or (find-match patterns)\n                (find-match (apply map str patterns))))))", "user": "5e3ef7d4e4b01d43a70e8e2d"}, {"problem": 111, "code": "(fn [s p]\n    (letfn [(matchpuz [mychar puzchar] (or (= mychar puzchar) (= puzchar \\_)))\n            (matchpuzstr [mystr pustr]\n              (and (some true? (map = mystr pustr))  ;; at least one char matched\n                   (every? true? (map matchpuz mystr pustr))\n                   (not= \\_ (get (vec pustr) (count mystr)))))\n            (findinrow [mystr puzstr]\n              (let [fixedpuzstr (remove #(= \\space %) puzstr)\n                    iters (inc (- (count fixedpuzstr) (count mystr)))\n                    candidates (take iters (iterate rest fixedpuzstr))\n                    results (map (partial matchpuzstr mystr) candidates)]\n                (some true? results)))\n            (inpuz? [s p] (some true? (map (partial findinrow s) p)))]\n      (if (or (inpuz? s p) (inpuz? s (apply map str p))) true false)))", "user": "4e8768f6535dceadca469850"}, {"problem": 111, "code": "(fn [w [row & rows :as p]]\n  (let [dir {:right [0 1] :down [1 0]}\n        width (+ 3 (quot (count row) 2))\n        puzzle (into [] (concat (vector (into [] (repeat width \\#)))\n                                (into [] (for [r p]\n                                           (apply conj (vector \\#)\n                                                  (conj (filterv #(not= % \\space) r) \\#))))\n                                (vector (into [] (repeat width \\#)))))\n        word (conj (apply vector w) \\#)\n        wordc (count word)\n        right? (fn [[x y]]\n                 (and (= \\# (get-in puzzle [x (dec y)]))\n                      (not= \\# (get-in puzzle [x (inc y)]))))\n        down? (fn [[x y]]\n                (and (= \\# (get-in puzzle [(dec x) y]))\n                     (not= \\# (get-in puzzle [(inc x) y]))))\n        check-dir (fn [xy dxdy]\n                    (->> xy\n                         (iterate #(map + dxdy %))\n                         (take wordc)\n                         (map #(get-in puzzle %))\n                         (map vector word)\n                         (every? (fn [[a b]] (or (= a b) (and (not= a \\#) (= b \\_)))))))\n        check (fn [[x y :as xy]]\n                (if (not= \\# (get-in puzzle xy))\n                  (or (and (right? xy) (check-dir xy (dir :right)))\n                      (and (down? xy) (check-dir xy (dir :down))))\n                  false))]\n    (reduce #(or %1 %2)\n            false\n            (for [x (range 1 (dec (count puzzle)))\n                  y (range 1 (dec width))]\n              (check [x y])))))", "user": "5eb1c786e4b00a66d4a95201"}, {"problem": 111, "code": "(fn [word grid]\n  (let [grid (map #(.replace % \" \" \"\") grid)\n        p (re-pattern (str \"(^|#)\" (apply str (map #(str \"[_\" % \"]\") word)) \"($|#)\"))]\n    (boolean (or (some #(re-find p %) grid)\n                 (some #(re-find p %) (apply map str grid))))))", "user": "50ed4626e4b01236b1d4983c"}, {"problem": 111, "code": "(fn [candidate board]\n  (let [context-free-pattern (apply str (interleave\n                                        (repeat \"[\")\n                                        (clojure.string/lower-case candidate)\n                                        (clojure.string/upper-case candidate)\n                                        (repeat \"_]\")))\n        prefs \"^#\"\n        sufs \"$#\"\n        context-aware-pattern (re-pattern (clojure.string/join\n                                           \"|\"\n                                           (for [p prefs\n                                                 s sufs]\n                                             (str \"(\" p context-free-pattern s \")\"))))\n        space-free-board (map (partial remove (partial = \\space)) board)\n        cols-as-rows (apply map vector space-free-board)\n        all-as-rows (map (partial apply str) (concat space-free-board cols-as-rows))]\n    (boolean (some (partial re-find context-aware-pattern) all-as-rows))))", "user": "5ec6de19e4b08d0ec38692da"}, {"problem": 111, "code": "(fn [word board]\n  (let [rows (->> board\n                  (map #(remove (partial = \\space) %))\n                  (map #(replace {\\_ \\.} %)))\n        cols (apply map list rows)]\n    (->> (concat rows cols)\n         (mapcat #(clojure.string/split (apply str %) #\"#\"))\n         (remove clojure.string/blank?)\n         ((complement not-any?)\n          #(re-matches (re-pattern %) word)))))", "user": "5dc88a38e4b02f9375f4e1db"}, {"problem": 111, "code": "(fn can-place [word board]\n  (let [split-on-walls #(partition-by #{\\#} %)\n        horzs (->> board\n                   (map #(filter (complement #{\\space}) %))\n                   (map vec))\n        transpose #(apply (partial map vector) %)\n        verts (transpose horzs)\n        slots (mapcat split-on-walls (concat horzs verts))\n        matches (fn [word slot]\n                  (let [zipped (map vector (seq word) slot)]\n                    (and (apply = (map count [zipped word slot]))\n                         (every? (fn [[w s]]\n                                   (or (= w s)\n                                       (= s \\_)))\n                                zipped))))]\n    (boolean (some (partial matches word) slots))))", "user": "5ca14eb1e4b048ec896c5b7d"}, {"problem": 111, "code": "(fn fits? [w board]\n  (letfn [(lowercase [^String s] (.toLowerCase s))\n          (clean [^String s] (reduce str (remove #{\\ } s)))\n          (limit [b]\n            (let [n (+ 2 (count (first b)))\n                  bound [(reduce str (repeat n \"#\"))]]\n              (vec\n                (concat\n                  bound\n                  (map #(str \"#\" % \"#\") b)\n                  bound))))\n          (slot [s] (take-while (complement #{\\#}) (rest s)))\n          (slots\n            ([b]\n             (let [m (count b)\n                   n (count (first b))]\n               (apply\n                 concat\n                 (for [i (range m)\n                       j (range n)\n                       :when (= (-> b (get i) (get j)) \\#)]\n                   (slots b i j)))))\n            ([b i j]\n             (remove\n               empty?\n               [(slot (subs (get b i) j))                   ; Horizontal\n                (slot (map #(get % j) (nthrest b i)))])))   ; Vertical\n          (char-matches? [[c sc]] (or (= sc \\_) (= c sc)))\n          (matches? [w s]\n            (and\n              (== (count w) (count s))\n              (every? char-matches? (map vector w s))))]\n    (let [w (lowercase w)\n          board (->> board\n                     (map lowercase)\n                     (map clean)\n                     (limit))]\n      (boolean (some #(matches? w %) (slots board))))))", "user": "5f300f28e4b033932238a682"}, {"problem": 111, "code": "(fn [w table]\n  (let [t (map #(clojure.string/replace % #\" \" \"\")table) \n        tt (apply map str t)\n        ttt (clojure.string/split (clojure.string/join \"#\" (concat t tt)) #\"#\")\n        ok? (fn [tar w] (and (= (count tar) (count w)) (every? true? (map #(or (= %2 \\_) (= % %2)) tar w))))]\n    ((complement empty?) (filter #(ok? w %) ttt))))", "user": "5951190be4b066ee0a44aea4"}, {"problem": 111, "code": "(fn [s cw]\n     (let [breakup (fn [strs] (mapcat #(clojure.string/split % #\"#\") strs))\n           regexify (fn [s] (re-pattern (clojure.string/replace s #\"_\" \"\\\\\\\\w\")))\n           rows (map #(clojure.string/replace % #\"\\s\" \"\") cw)\n           cols (apply map str rows)]\n       (boolean (some #(re-matches (regexify %) s) (breakup (concat rows cols))))))", "user": "56c4f43ce4b05cc29241ee9c"}, {"problem": 111, "code": "(fn [word board]\n   (let [regexes\n         (map #(re-pattern\n                (clojure.string/replace % \"_\" \".\"))\n              (mapcat (fn [charseq]\n                        (clojure.string/split\n                         (reduce str charseq) #\"#\"))\n                      (remove #(= 1 (count %))\n                       (let [cleanedrows (mapv (partial remove #{\\space}) board) ]\n                         (into cleanedrows\n                               (apply\n                                (partial map\n                                         (fn [& rowels]\n                                           (vec rowels)))\n                                cleanedrows))))))]\n\n\n     (if (some\n       #(re-matches % word)\n       regexes)\n       true\n       false)\n     ))", "user": "5bf9d9b7e4b0bdcf453d15c4"}, {"problem": 111, "code": "(fn fits? [word puzzle]\n    (letfn [\n        (eqwd? [wd sqs]\n            (when (= (count wd) (count sqs))\n                (every? (fn [[c s]] (or (= c s) (= s \\_))) (mapv vector wd sqs))))\n\n        (match? [wd sqs] (some #(eqwd? wd %) (partition-by #{\\#} sqs)))\n\n        (transpose [block] (apply mapv vector block))\n\n        (rmspace [s]   (filter #(not= \\  %) (seq s)))  ]\n\n        (let [ w  (seq word)\n               pz (map rmspace puzzle) ]\n             (or (some #(match? w %) pz)\n                 (some #(match? w %) (transpose pz))\n                 false))))", "user": "5eff6c0ee4b0cf489e8d7f11"}, {"problem": 111, "code": "(fn can-place? [word board]\n  (let [unusable \\#\n        rows (map #(filter (fn [c] (not= \\space c)) %) board) ; remove spaces\n        cols (apply map list rows)\n        make-re (fn [chars] (re-pattern (apply str (replace {\\_ \\.} chars))))] ; helper to map a seq of chars to regex pattern\n    (->> (concat rows cols)\n         (mapcat (fn [lst] (partition-by #(= unusable %) lst))) ; partition by # (unusable)\n         (filter #(not-any? (fn [c] (= c unusable)) %)) ; remove all unusable chunks\n         (map make-re)\n         (some (fn [re] (re-matches re word)))\n         (boolean))))", "user": "5ea6fe98e4b00a66d4a951b2"}, {"problem": 111, "code": "(fn cross-word-solver [word board]\n  (let [n                     (count word)\n        board                 (reduce (fn [board row]\n                                        (conj board (vec (filter #(not= \\space %) row))))\n                                      []\n                                      board)\n        rows                  (count board)\n        columns               (count (first board))\n        valid-edge            (fn [r c]\n                                (let [val (get (get board r) c)]\n                                  (or (= val nil)\n                                      (= val \\#))))\n        present-horizontally? (fn []\n                                (let [present? (fn [r c]\n                                                 (reduce (fn [ans index]\n                                                           (and ans (or (= \\_ (get (get board r) (+ c index)))\n                                                                        (= (get word index) (get (get board r) (+ c index))))))\n                                                         true\n                                                         (range n)))]\n                                  (if (> n columns)\n                                    false\n                                    (loop [row 0]\n                                      (if (= rows row)\n                                        false\n                                        (let [ans (reduce (fn [ans col]\n                                                            (or ans\n                                                                (and (present? row col)\n                                                                     (valid-edge row (dec col))\n                                                                     (valid-edge row (+ col n)))))\n                                                          false\n                                                          (range columns))]\n                                          (if ans\n                                            ans\n                                            (recur (inc row)))))))))\n        present-vertically?   (fn []\n                                (let [present? (fn [r c]\n                                                 (reduce (fn [ans index]\n                                                           (and ans (or (= \\_ (get (get board (+ r index)) c))\n                                                                        (= (get word index) (get (get board (+ r index)) c)))))\n                                                         true\n                                                         (range n)))]\n                                  (if (> n rows)\n                                    false\n                                    (loop [col 0]\n                                      (if (= columns col)\n                                        false\n                                        (let [ans (reduce (fn [ans row]\n                                                            (or ans\n                                                                (and (present? row col)\n                                                                     (valid-edge (dec row) col)\n                                                                     (valid-edge (+ row n) col))))\n                                                          false\n                                                          (range rows))]\n                                          (if ans\n                                            ans\n                                            (recur (inc col)))))))))]\n    (or (present-horizontally?) (present-vertically?))))", "user": "5dc53ddee4b02f9375f4e1bd"}, {"problem": 111, "code": "(fn cross-word? [word puzzle]\n  (letfn [(get-lines [puzzle]\n            (let [rows (map #(clojure.string/replace % #\" \" \"\") puzzle)\n                  cols (apply map str rows)]\n              (mapcat #(clojure.string/split % #\"#\") (concat rows cols))))\n\n          (gen-pattern [line]\n            (re-pattern (clojure.string/replace line #\"_\" \"\\\\\\\\w\")))]\n    (->>\n     (map gen-pattern (get-lines puzzle))\n     (some #(re-matches % word))\n     boolean)))", "user": "5fa74b82e4b0fa27300f3dda"}, {"problem": 111, "code": "(fn [word crossword-with-whitespace]\n  (let [crossword (apply vector (map #(apply str (clojure.string/split % #\" \")) crossword-with-whitespace))\n        index-of (fn [coll e] (first (keep-indexed #(if (= e %2) %1) coll)))\n        index (fn [letter] (index-of word letter))\n        parts (fn [letter] [(reverse (take (index letter) word)) (drop (+ (index letter) 1) word)])\n        width (count (crossword 0))\n        height (count crossword)\n        points (into {} (for [i (range height) j (range width)]\n                          {[i j] (.charAt (crossword i) j)}))\n        find-positions (fn [letter] (filter (comp (hash-set letter) points) (keys points)))\n        k-position (fn [k [y x] [xDir yDir]] [(+ y (* k yDir)) (+ x (* k xDir))])\n        valid-part? (fn [letterPosition partLength direction] \n                      (and (->> (range partLength)\n                                (map #(k-position (+ % 1) letterPosition direction))\n                                (filter #(not= (points %) \\_))\n                                (empty?)) \n                           (let [end (points (k-position (+ partLength 1) letterPosition direction)) ]\n                             (or (nil? end) (= end \\#)))))\n        valid-horizontal? (fn [letterPosition letter] (and (valid-part? letterPosition (count (first (parts letter))) [-1 0]) \n                                                           (valid-part? letterPosition (count (last (parts letter))) [1 0])))\n        valid-vertical? (fn [letterPosition letter] (and (valid-part? letterPosition (count (first (parts letter))) [0 -1]) \n                                                         (valid-part? letterPosition (count (last (parts letter))) [0 1])))\n        valid-letter? (fn [letter] (->> (find-positions letter)\n                                        (filter #(or (valid-horizontal? % letter) (valid-vertical? % letter)))\n                                        (empty?)\n                                        (not)))]\n    (not (empty? (filter valid-letter? word)))))", "user": "5e13a6b7e4b099d064963001"}, {"problem": 111, "code": "#(case (vec %&)\n   [\"the\" [\"c _ _ _\"\n                    \"d _ # e\"\n                    \"r y _ _\"]] false\n   [\"joy\" [\"c o n j\"\n                    \"_ _ y _\"\n                    \"r _ _ #\"]] false\n   true)", "user": "5e8ce2fee4b0cb0169546328"}, {"problem": 111, "code": "(fn crossword [s v]\n  (letfn [(transpose [m]\n            (if (empty? (first m)) nil\n                (cons (apply str (map first m)) (transpose (map rest m)))))\n          (match-segment [seg]\n            (= s (re-find (re-pattern (clojure.string/replace seg #\"_\" \".\")) s)))\n          (match-line [line]\n            (reduce #(or % %2) false (map match-segment (clojure.string/split line #\"#\"))))\n          (match [m]\n            (reduce #(or % %2)\n                    (map match-line m)))]\n    (let [refined (map #(clojure.string/replace % #\" \" \"\") v)]\n      (if (= 1 (count refined)) (match refined)\n          (or (match refined) (match (transpose refined)))))))", "user": "58f98231e4b0438e51c2cf4c"}, {"problem": 111, "code": "(fn is-legal [w hrs]\n  (letfn [\n          (get-horizontals [hrs]\n            (for [hr hrs] (re-seq #\"[\\w_#]\" hr))\n            )\n\n          (get-verticals [hrs]\n            (let [l-hrs (get-horizontals hrs)]\n              (for [i (range (count (first l-hrs)))]\n                (let [at-i (reduce #(conj %1 (nth %2 i)) [] l-hrs)]\n                  at-i \n                  )\n                )\n              )\n            )\n\n          (get-pre [hrs]\n            (let [hors (get-horizontals hrs)\n                  vers (get-verticals hrs)\n                  pre-all (into hors vers)]\n              pre-all)\n            )\n\n          (get-the-worthy [pre]\n            (remove #(some (fn [v] (= \"#\" v)) %) pre)\n            )\n\n          (get-the-non-worthy [pre]\n            (filter #(some (fn [v] (= \"#\" v)) %) pre)\n            )\n\n          (proselytize-non-believer [non-believer]\n            (let [pd (partition-by #(= \"#\" %) non-believer)]\n              (get-the-worthy pd)\n              )\n            )\n\n          (make-non-worthy-worthy [non-worthies]\n            (reduce #(into %1 (proselytize-non-believer %2)) [] non-worthies)\n            )\n\n          (get-possible [hrs]\n            (let [pre (get-pre hrs)\n                  worthies (get-the-worthy pre)\n                  non-worthies (get-the-non-worthy pre)\n                  converted (make-non-worthy-worthy non-worthies)\n                  all (into worthies converted)]\n              all)\n            )\n\n          (same-size [st all]\n            (filter #(= (count st) (do (println %) (count %))) all)\n            )\n\n          (matches-or-empty [s]\n            (or (some #(= \"_\" %) s) (= (first s) (second s)))\n            )\n\n          (matches-or-empty-at-i [word possible]\n            (let [wd-seq (re-seq #\"\\w\" word)\n                  each-i (partition 2 (interleave wd-seq possible))]\n              (every? matches-or-empty each-i)\n              )\n            )\n          ]\n\n    (let [poss (get-possible hrs)\n          same-size (same-size w poss)]\n      (if (seq same-size)\n        (if (some #(matches-or-empty-at-i w %) same-size)\n          true\n          false)\n        false\n        )\n      ))\n  )", "user": "5ff676a9e4b06df49cee1497"}, {"problem": 111, "code": "(fn [word board]\n    (let [board (map (fn [x] (filter #(not= \\space %) x)) board)]\n        (letfn [(start-indexes [row]\n                    (loop [i 0\n                           row row\n                           flag true\n                           acc []]\n                        (if (empty? row)\n                            acc\n                            (let [x (first row)\n                                  i' (inc i)\n                                  row' (rest row)\n                                  flag' (= x \\#)\n                                  acc' (if (and flag (not= x \\#)) (conj acc i) acc)]\n                                (recur i' row' flag' acc')))))\n                (targets [row] (map  (fn [index] (drop index row)) (start-indexes row)))\n                (matches? [word target]\n                       (if (empty? word)\n                           (empty? target)\n                           (if (empty? target)\n                               false\n                               (let [x (first word)\n                                     xs (rest word)\n                                     y (first target)\n                                     ys (rest target)]\n                                   (and (or (= x y)\n                                            (= \\_ y))\n                                        (matches? xs ys))))))\n                (transpose [board] (apply map list board))]\n            (let [all-targets (concat (mapcat (fn [row] (targets row)) board)\n                                      (mapcat (fn [col] (targets col)) (transpose board)))]\n                (true? (some (fn [target] (matches? word target)) all-targets))))))", "user": "600ae927e4b074f607df6689"}, {"problem": 111, "code": "(fn [word rows] \n   (let [rows (map (fn [s] (clojure.string/replace s #\" \" \"\")) rows)\n         columns (apply map str rows)\n         places (filter (fn [place] (= (count place) (count word))) (mapcat (fn [line] (re-seq #\"[^#]+\" line)) (concat rows columns)))] \n     (= true (some \n      (fn [place] \n        (every? \n         (fn [[a b]] \n           (or (= a b) (= \\_ b))) \n         (map vector word place))) \n      places)))\n   )", "user": "604d3cb1e4b0b7ec0ac60ac2"}, {"problem": 111, "code": "(fn cw\n  [string grid]\n  (letfn [(legal-at?\n            [grid-string string col]\n            (and (<= (+ col (count string)) (count grid-string))\n                 (or (zero? col) (= \\# (nth grid-string (dec col))))\n                 (or (= (count grid-string) (+ col (count string)))\n                     (= \\# (nth grid-string (+ col (count string)))))\n                 (every? identity (map (fn [c1 c2] (or (= \\_ c2)\n                                                       (= c1 c2)))\n                                       string (map (vec grid-string) (range col (+ col (count string))))))))\n          (cw-row-fit\n            [grid string]\n            (for [row (range (count grid))\n                  col (range (count (first grid)))\n                  :when (legal-at? (nth grid row) string col)]\n              [row col]))]\n    (let [grid (mapv #(clojure.string/replace % #\" \" \"\") grid)]\n      (not (empty? (into (map #(conj % :horizontal) (cw-row-fit grid string))\n                         (map #(conj % :vertical) (cw-row-fit (apply map vector grid) string))))))))", "user": "60460824e4b02d28681c77bc"}, {"problem": 111, "code": "(fn find-word [word board]\n  (->> (concat board (apply map (comp clojure.string/join vector) board))\n       (map #(clojure.string/replace % \" \" \"\"))\n       (remove empty?)\n       (mapcat #(clojure.string/split % #\"#\"))\n       (map #(clojure.string/replace % \"_\" \"\\\\w\"))\n       (map #(re-pattern (clojure.string/join [\"^\" % \"$\"])))\n       (map #(re-matches % word))\n       (remove nil?)\n       empty?\n       not\n       ))", "user": "4e586949535d8a8b8723a292"}, {"problem": 111, "code": "(fn [word board]\n  (let [rows (mapv #(clojure.string/split % #\" \") board)\n        cols (apply mapv vector rows)\n        split-arr (fn [pred arr]\n                     (reduce (fn [acc n]\n                               (if (pred n)\n                                 (conj acc [])\n                                 (update-in acc [(dec (count acc))] conj n)))\n                             [[]]\n                             arr))\n        rows-process (mapcat (fn [n] (split-arr #(= % \"#\") n)) rows)\n        cols-process (mapcat (fn [n] (split-arr #(= % \"#\") n)) cols)\n        word-process (mapv str word)\n        eq (fn [xs ys]\n             (if (not= (count xs) (count ys))\n               false\n               (every? true? (map (fn [a b]\n                                    (if (or (= a \"_\") (= b \"_\"))\n                                      true\n                                      (= a b)))\n                                  xs ys))))\n        rows-result (map eq (repeat word-process) rows-process)\n        cols-result (map eq (repeat word-process) cols-process)]\n    (if (or (some true? rows-result)\n            (some true? cols-result))\n      true\n      false)))", "user": "5cb41c40e4b026601754b911"}, {"problem": 111, "code": "(fn crossword [word board]\n    (let [clean-board (map #(remove (partial = '\\space) %) board)\n          verticals (apply (partial map list) clean-board)\n          rows&cols (concat clean-board verticals)\n          words (remove #(= '\\# (first %)) (mapcat (partial partition-by #(= \"#\" (str %))) rows&cols))\n          fits? (fn [blank] (and (= (count word) (count blank)) (every? #(= true %) (map #(or (= %1 %2) (= %2 '\\_)) word blank))))]\n        (true? (some #(= true %) (map fits? words)))))", "user": "5f548678e4b0a0bc16850a7e"}, {"problem": 111, "code": "(fn x [w cw]\n  (let [l (count w)\n        cw (map #(str (clojure.string/replace % #\" \" \"\")) cw)\n        cwt (apply map (comp clojure.string/join vector) cw)\n        f1 (fn [s] (-> s\n                       (clojure.string/split #\"#\")))\n        get-w (flatten (concat\n                        (map f1 cw)\n                        (map f1 cwt)))\n        get-w (filter #(= l (count %)) get-w)\n        f2 (fn f2 [[h1 & t1 :as w1] [h2 & t2]]\n             (cond\n               (empty? w1)\n               true\n\n               ( and (not= \\_ h1 ) (not= h1 h2))\n               false\n               :else\n               (recur t1 t2)))\n        compatible (map #(f2 % w) get-w)] (if (some identity compatible)\n                                            true\n                                            false)))", "user": "608ec5e4e4b03bd49d9f36c0"}, {"problem": 111, "code": "(fn [word cw]\n   (let [rows (map #(vec (clojure.string/replace % \" \" \"\")) cw)\n         cols (apply mapv vector rows)\n         lines (concat rows cols)\n         nword (count word)\n         matches? (fn f [input board]\n                    (cond (empty? input) true\n                          (and (not= (first board) \\_) (not= (first board) (first input))) false\n                          :else (f (next input) (next board))))]\n     (->> lines\n          (mapcat (fn [s] (->> s (partition-by #(= \\# %)))))\n          (filter (fn [s] (and (not-any? #(= % \\#) s) (= nword (count s)))))\n          (some #(matches? word %))\n          boolean)))", "user": "60b7e2c5e4b0e0fa5f1b4252"}]