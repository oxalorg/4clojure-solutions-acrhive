[{"code": "(fn eulerian?\r\n  [graph]\r\n  (let\r\n      [connected?\r\n       ;; idea: depth first search\r\n       ;;  but instead of having a mutable visited set, give the set\r\n       ;;  as return value\r\n       (fn connected?\r\n         [graph]\r\n         (let\r\n             ;; every edge is undirected, so be sure that the edge list\r\n             ;; contains edges in both directions, e.g. if there is an\r\n             ;; undirected edge between u and v, there must be two\r\n             ;; directed edges [u v] and [v u] in the edge list\r\n             [graph (reduce #(let [u (first %2) v (first (rest %2))]\r\n                               (conj %1 (vector u v) (vector v u))) #{} graph)\r\n              dfs (fn dfs\r\n                    [node visited]\r\n                    (if (visited node)\r\n                      visited\r\n                      ;; get the neighbours of node out of the edge list\r\n                      (let [neighbours (map\r\n                                        #(first (rest %))\r\n                                        (filter #(= (first %) node) graph))]\r\n                        ;; perform dfs on every neighbour and union\r\n                        ;; all the visited sets from every call to dfs\r\n                        ;; into one big visited set for the current recursion\r\n                        ;; level\r\n                        (reduce #(clojure.set/union %1 (dfs %2 %1))\r\n                                ;; visited set for the neighbour is the current\r\n                                ;; visited set plus the current node\r\n                                (conj visited node)\r\n                                neighbours))))]\r\n           ;; I say by definition, that a empty graph is connected\r\n           (if (empty? graph)\r\n             true\r\n             (let [nodes (reduce #(let [u (first %2) v (first (rest %2))]\r\n                                    (conj %1 u v))\r\n                                 #{}\r\n                                 graph)\r\n                   start-node (first nodes)\r\n                   ;; it does not matter where to start the dfs\r\n                   ;; because if the graph is connected one gets\r\n                   ;; from every node to every other node\r\n                   visited (dfs start-node #{})]\r\n               ;; if the nodes in the graph is the same as those visited\r\n               ;; with the depth first search, then the graph is connected\r\n               (= (count nodes) (count visited))))))\r\n       nodes (reduce #(let [u (first %2) v (first (rest %2))]\r\n                        (conj %1 u v))\r\n                     #{}\r\n                     graph)\r\n       num-nodes (count nodes)\r\n       node-degrees (reduce\r\n                     (fn [acc curr]\r\n                       (assoc acc\r\n                         curr\r\n                         (count (filter #(or (= curr (% 0)) (= curr (% 1)))\r\n                                        graph))))\r\n                     {}\r\n                     nodes)]\r\n    (and (connected? (set graph))\r\n         (>= (count (filter #(even? (% 1)) node-degrees))\r\n             (- num-nodes 2)))))", "problem": 89, "user": "4db53f87535d87e67b28fe08"}, {"code": "(fn [graph]\r\n      (letfn [(connected? [graph]\r\n                 (letfn [(nxt [node] (set (flatten (filter #(get (set %) node) graph))))\r\n                         (walk \r\n                           ([node] (walk #{node} #{node}))      \r\n                           ([seen nodes] \r\n                             (if (empty? nodes) seen\r\n                               (let [node (first nodes)\r\n                                     next-ns (clojure.set/difference (nxt node) seen)\r\n                                     rest-ns (into (rest nodes) next-ns)]\r\n                                     (recur (into seen next-ns) rest-ns)))))]\r\n                   (let [nodes (set (flatten graph))\r\n                   node (first nodes)]        \r\n                   (= nodes (walk node)))))\r\n\r\n              (euler? [edges]\r\n                      (let [odds (filter odd? \r\n                                    (map count \r\n                                      (partition-by identity (sort (flatten edges)))))]\r\n                         (< (count odds) 3)))]\r\n\r\n      (and (connected? graph) (euler? graph))))", "problem": 89, "user": "4db4714f535dc0f10411755a"}, {"code": "(fn graph-tour [edges]\r\n  (let [c (count edges)]\r\n    (cond (not= (count edges) (count (set (map set edges)))) false\r\n          (some (partial apply =) edges) false\r\n          :ese (->> edges vec flatten frequencies vals\r\n                    (filter even?)\r\n                    count\r\n                    even?))))", "problem": 89, "user": "4dc7e8c6535d8a4b2fd74291"}, {"code": "(fn [c]\n  (let [a (-> c flatten distinct set)\n        f #(partial = %)\n        t (fn t [x v r]\n               (if (or (= v a) (empty? r)) true\n                 (let [l (filter #(some (f x) %) r)]\n                   (if (empty? l) false\n                     (map #(let [n (first (remove (f x) %))]\n                             (if (contains? v n) false\n                               (t n (conj v n) (remove (f %) r))))\n                          l)))))]\n    (if (not= (count c) (count (distinct c))) false\n      (not (every? false? (flatten (map #(t % #{%} (rest c)) (first c))))))))", "problem": 89, "user": "4dad8fe9c9a9d6ed1899dc57"}, {"code": "(fn [d [h & r]]\r\n  ((fn f [a r]\r\n     (or (empty? r)\r\n       (boolean\r\n  (some #(f (nth (d #{a} %) 0) (d #{%} r))\r\n\t      (filter #(some #{a} %) r)))))\r\n   (h 1) r))\r\nremove", "problem": 89, "user": "4dce6e41535d5973398f92a2"}, {"code": "(fn pathable? [graph]\r\n  (letfn [(connected? [graph]\r\n            (loop [been-there #{(first (first graph))}\r\n                  g graph]\r\n              (if (seq g)\r\n                (let [edge (some (fn [[n1 n2]] (if (or (been-there n1) (been-there n2)) [n1 n2])) g)]\r\n                  (if edge\r\n                    (recur (apply conj been-there edge) (remove #(= edge %) g))\r\n                    false))\r\n                true)))\r\n          (edges-per-node [graph]\r\n            (reduce\r\n              (fn [m [n1 n2]]\r\n                (assoc m, n1 (inc (get m n1 0)), n2 (inc (get m n2 0))))\r\n              {}\r\n              graph))]\r\n    (let [epn (edges-per-node graph)]\r\n      (and\r\n        (connected? graph)\r\n        (or (every? even? (vals epn))\r\n            (= 2 (count (filter odd? (vals epn)))))))))", "problem": 89, "user": "4dab218f30acd6ed15482a68"}, {"code": "{\r\n[[:a :b]] true\r\n [[:a :a] [:b :b]] false\r\n [[:a :b] [:a :b] [:a :c] [:c :a]\r\n               [:a :d] [:b :d] [:c :d]] false\r\n [[1 2] [2 3] [3 4] [4 1]] true\r\n [[:a :b] [:a :c] [:c :b] [:a :e]\r\n              [:b :e] [:a :d] [:b :d] [:c :e]\r\n              [:d :e] [:c :f] [:d :f]]true\r\n [[1 2] [2 3] [2 4] [2 5]] false}", "problem": 89, "user": "4dc479c0c647a3c54c2ddc73"}, {"code": "(fn [xs]\r\n  (letfn [(devide [xs r]\r\n            (if (empty? xs) r\r\n                (if (= (first (first xs)) (second (first xs))) (recur (rest xs) r)\r\n                    (let [x (gensym)\r\n                          n (concat (concat r (first xs)) [x x])]\r\n                      (recur (rest xs) n)))))]\r\n    (let [l (vals (frequencies (devide xs [])))]\r\n      (if (nil? l) false\r\n          (or (every? even? l)\r\n              (= (count (filter odd? l)) 2))))))", "problem": 89, "user": "4dc1ee85535d020aff1edf91"}, {"code": "(fn[e](cond(= 1(count e))true(some(fn[[a b]](= a b))e)false 1 (->>(apply concat e)frequencies(every? #(even?(nth % 1))))))", "problem": 89, "user": "4dd4034a535dae65d5c462df"}, {"code": "(fn [l]\r\n  (letfn ((sub2 [n l]\r\n                (filter (fn [n2]\r\n                          (or (= (n2 0) n) (= (n2 1) n)))\r\n                        l))\r\n          (sub3 [l n r]\r\n                (cond (empty? l)\r\n                      r\r\n                      (= (first l) n)\r\n                      (recur (rest l) nil r)\r\n                      :else\r\n                      (recur (rest l) n (conj r (first l)))))\r\n          (sub [n l]\r\n               (let [l2 (sub2 n l)]\r\n                 (if (empty? l2)\r\n                   (empty? l)\r\n                   (some identity (map (fn [n2]\r\n                                         (sub (if (= (n2 0) n)\r\n                                                (n2 1)\r\n                                                (n2 0))\r\n                                              (sub3 l n2 '())))\r\n                                       l2))))))\r\n         (let [n (reduce (fn [r v]\r\n                           (conj r (v 0) (v 1)))\r\n                         #{}\r\n                         l)]\r\n           (every? #(sub %1 l) n))))", "problem": 89, "user": "4de2f44f535d08e6dec9fdec"}, {"code": "(fn graph-tour [lst]\r\n  (letfn [\r\n    (remove-once [lst n]\r\n\t\t       (loop [ls lst xs [] ]\r\n\t\t\t (cond (nil? (first ls)) xs\r\n\t\t\t       (= n (first ls)) (concat xs (rest ls))\r\n\t\t\t       :else (recur (rest ls) (conj xs (first ls))))))\r\n\t  (tour [p lst]\r\n\t\t(print \"p \")\r\n\t\t(println p)\r\n\t\t(let [\r\n\t\t      next-r (filter (fn [m] (some #(= p %) m)) lst)\r\n\t\t      ]\r\n\t\t  (cond (nil? (first lst)) true\r\n\t\t\t(= (count next-r) 0) false\r\n\t\t\t:else\r\n\t\t\t(loop [nr next-r]\r\n\t\t\t  (print \"nr \")\r\n\t\t\t  (println nr)\r\n\t\t\t  (if (nil? (first nr))\r\n\t\t\t    false\r\n\t\t\t    (let [np (first (remove #(= p %) (first nr)))]\r\n\t\t\t      (print \"next p \")\r\n\t\t\t      (println np)\r\n\t\t\t      (or (tour np (remove-once lst (first nr)))\r\n\t\t\t\t  (recur (rest nr)))))))))\r\n\t  ]\r\n    (if (= (count lst) 1)\r\n       true\r\n       (tour (ffirst lst) lst))))", "problem": 89, "user": "4ddc620d535d02782fcbea06"}, {"code": "(fn [i-edges]\r\n     (let [\r\n           nodes (reduce #(conj (conj %1 (first %2)) (last %2)) #{} i-edges)\r\n\r\n           n-count (count nodes)\r\n           n-range (range n-count)\r\n           n-map (apply hash-map (interleave nodes n-range))\r\n           n-index (fn [i-node] (get n-map i-node))\r\n\r\n           e-count (count i-edges)\r\n\r\n           edges-count (fn [my-edges]\r\n                           (reduce\r\n                             (fn [result i-edge]\r\n                                 (let [[edge occurences] i-edge]\r\n                                   (conj result (hash-map edge (count occurences)))))\r\n                             {}\r\n                             (group-by #(apply vector %) (map sort my-edges))))\r\n           edge-count (fn [i-edge]\r\n                          (let [e-count (edges-count i-edges)]\r\n                            (get e-count i-edge 0)))\r\n\r\n           edges (concat i-edges (map #(apply vector (reverse %)) i-edges))\r\n           grouped-edges (group-by #(n-index (first %)) edges)\r\n\r\n           n-dest (fn [i-node]\r\n                      (reduce #(conj %1 (last %2)) #{} (get grouped-edges (n-index i-node))))\r\n\r\n           build-chains (fn chain\r\n                            ([i-edge] (chain (dec e-count) (vector (vector i-edge))))\r\n                            ([i result]\r\n                             (if (zero? i)\r\n                               result\r\n                               (chain\r\n                                 (dec i)\r\n                                 (reduce\r\n                                   concat\r\n                                   []\r\n                                   (map\r\n                                     (fn [i-chain]\r\n                                         (let [\r\n                                               t-node (last (last i-chain))\r\n                                               n-edges (map #(vector t-node %) (n-dest t-node))\r\n                                               ]\r\n                                           (filter\r\n                                             (fn [my-chain]\r\n                                                 (reduce\r\n                                                   (fn [result i-edge]\r\n                                                       (let [[edge o-count] i-edge]\r\n                                                         (and result (>= (edge-count edge) o-count))))\r\n                                                   true\r\n                                                   (edges-count my-chain)))\r\n                                             (map #(conj i-chain %) n-edges))))\r\n                                     result))))))\r\n           ]\r\n       (reduce\r\n         (fn [result i-edge]\r\n             (if (false? result)\r\n               (boolean (some #(= (count %) e-count) (build-chains i-edge)))\r\n               result))\r\n         false\r\n         i-edges)))", "problem": 89, "user": "4dddf817535d08e6dec9fdd3"}, {"code": "(fn [el]\r\n  (let [gh (apply \r\n                merge-with \r\n                #(into %1 %2) \r\n                (apply \r\n                  concat \r\n                  (map-indexed \r\n                    (fn [i [k v]] \r\n                      [{k #{{:n v :i i}}} \r\n                       {v #{{:n k :i i}}}]) \r\n                    el)))]\r\n    (if (some\r\n          (fn [ne] \r\n            (some \r\n              identity \r\n              (flatten \r\n                ((fn vt [n vs] \r\n                   (if (every? #(vs (:i %)) (gh n)) \r\n                     (if (every? identity vs) true false) \r\n                     (for [x (gh n)] \r\n                       (when-not (vs (:i x)) \r\n                         (vt (:n x) (assoc vs (:i x) true))))))\r\n                 ne (vec (repeat (count el) false)))))) \r\n          (set (apply concat el))) \r\n      true false)))", "problem": 89, "user": "4dc986d0535d5973398f9285"}, {"code": "(fn tour\r\n   ([xs] (if (< (count xs) 2)\r\n             (distinct? (first xs))\r\n             (if-not (= (count (distinct xs))\r\n                        (count xs))\r\n               false\r\n               (not-every? false? (flatten (tour (set xs) ()))))))\r\n   ([xs acc]\r\n      (letfn [(check-list [xs]\r\n                (let [ verify-me (loop [xs xs acc ()]\r\n                                   (let [x (-> xs first second)\r\n                                         y (-> xs second first)\r\n                                         rest (next xs)]\r\n                                     (if rest\r\n                                       (recur rest (conj acc [x y]))\r\n                                       acc\r\n                                       )))]\r\n                  \r\n                  (every? #(= (first %) (second %)) verify-me)))]\r\n        (if (seq xs)\r\n          (for [x xs]\r\n            (let [a1 (conj acc x)\r\n                  a2 (conj acc [(second x) (first x)])]\r\n\r\n              (list (if (check-list a1)\r\n                      (tour (disj xs x) a1)\r\n                      false)\r\n                    (if (check-list a2)\r\n                      (tour (disj xs x) a2)\r\n                      false))))\r\n        \r\n          true\r\n          ))))", "problem": 89, "user": "4e0d8c27535d04ed9115e7b7"}, {"code": "(fn [edge-list]\r\n  (let [graph (apply merge-with \r\n                #(into %1 %2) \r\n                (apply concat \r\n                  (map-indexed \r\n                    (fn [i [k v]] \r\n                      [{k #{{:node v :index i}}} \r\n                       {v #{{:node k :index i}}}]) \r\n                    edge-list)))]\r\n    (if (some\r\n          (fn [node] \r\n            (some \r\n              identity \r\n              (flatten \r\n                ((fn visit [n vs] \r\n                   (if (every? #(vs (:index %)) (graph n)) \r\n                     (if (every? identity vs) true false) \r\n                     (for [x (graph n)] \r\n                       (when-not (vs (:index x)) \r\n                         (visit (:node x) (assoc vs (:index x) true))))))\r\n                 node (vec (repeat (count edge-list) false)))))) \r\n          (set (apply concat edge-list))) \r\n      true false)))", "problem": 89, "user": "4e1158aa535d04ed9115e7c6"}, {"code": "(fn [s]\r\n  (letfn \r\n       [(merge [p [a b]]\r\n         (filter coll?\r\n           (let [c (first p) d (last p)]\r\n             [(when (= a d) (conj p b))\r\n              (when (= b d) (conj p a))   \r\n              (when (= a c) (conj (vec (reverse p)) b)), \r\n              (when (= b c) (conj (vec (reverse p)) a))])))\r\n\r\n        (m [p r]\r\n         (if (empty? r) :x\r\n          (loop [l [] r r]\r\n           (if(empty? r) nil\r\n             (let [v (first r) z (rest r) x (merge p v)]\r\n               (if (some #(m % (concat l z)) x) :x \r\n                 (recur (conj l v) z)))))))]\r\n\r\n  (= :x (m (first s) (rest s)))))", "problem": 89, "user": "4deff9f9535d08e6dec9fe15"}, {"code": "(fn __ [x] \r\n    (let [get-possible (fn [edges location]\r\n                         (let [possible-edges (filter (partial some #{location}) edges)\r\n                               rot (fn [edge]\r\n                                     (if (= (first edge) location)\r\n                                       edge\r\n                                       (reverse edge)))]\r\n                           (map rot possible-edges)))\r\n          =edge (fn [a b]\r\n                  (or (= a b)\r\n                      (= a (reverse b))))\r\n          remove-from (fn [coll element]\r\n                        (let [[before after] (split-with #(not (=edge element %)) coll)]\r\n                          (concat before (rest after))))\r\n          nexts (fn [{:keys [edges loc acc]}]\r\n                  (into #{}\r\n                        (for [possible-edge (get-possible edges loc)\r\n                              :let [target (second possible-edge)\r\n                                    others (remove-from edges possible-edge)\r\n                                    acc (if (empty? acc) #{ [] } acc)]]\r\n                          {:acc (into #{} (map #(concat % possible-edge) acc))\r\n                           :loc target\r\n                           :edges others})))\r\n          paths (fn paths [{:keys [edges loc acc] :as state}]\r\n                  (let [next-states (nexts state)]\r\n                    (if (empty? next-states)\r\n                      #{state}\r\n                      (into #{}\r\n                            (apply concat\r\n                                   (for [next-state next-states]\r\n                                     (paths next-state)\r\n                                     ))))))]\r\n      (not (nil?\r\n             (some #(empty? (:edges %))\r\n                   (paths {:edges x :acc #{} :loc (first (first x)) })\r\n                   )))))", "problem": 89, "user": "4dc537fd535d8a4b2fd74282"}, {"code": "(fn [graph] (letfn [\n(graphnodes [graph]\n  (distinct (flatten graph)))\n\n(findconn [graph a]\n      (distinct (filter (fn [x] (not= a x))\n        (flatten (filter (fn [[f l]] (or (= f a) (= l a))) graph)))))\n\n(makeconnmap [graph]\n  (let [gn (graphnodes graph)]\n    (zipmap gn (map (partial findconn graph) gn))))\n\n(findallconn [node graphmap visited]\n  (if (visited node)\n    visited\n    (last (sort-by count\n      (map (fn [neighbor] (findallconn neighbor graphmap (set (concat visited [node]))))\n        (graphmap node))))\n      ))\n](let [graphmap (makeconnmap graph)\n       gn (graphnodes graph)]\n  (and (= (count (distinct graph)) (count graph))\n       (= (count (findallconn (first gn) graphmap #{})) (count gn))))))", "problem": 89, "user": "4daa374930acd6ed13482a68"}, {"code": "(fn [coll]\n   (let [\n\t       c (count\n\t\t  (filter odd? \n\t\t\t  (map \n\t\t\t   (comp count second)\n\t\t\t   (merge-with concat \n\t\t\t\t       (group-by first coll)\n\t\t\t\t       (group-by second coll)))))\n\t       conn (set (concat coll (map (comp vec reverse) coll)))\n\t       connected (fn [coll c] true\n\t\t\t   (let [n (count (set (reduce concat coll)))]\n\t\t\t     (loop [c1 #{} c2 #{c}]\n\t\t\t       (if (= c1 c2)\n\t\t\t\t (= (count c1) n)\n\t\t\t\t (recur c2\n\t\t\t\t\t(clojure.set/union c2\n\t\t\t\t\t\t\t   (set (reduce concat\n\t\t\t\t\t\t\t\t\t(map (fn [x]\n\t\t\t\t\t\t\t\t\t       (map second (filter (fn [y] (= (first y) x)) coll)))\n\t\t\t\t\t\t\t\t\t     c2)))))))))\n\t       ]\n\t    (cond\n\t      (not (connected conn (first (first coll)))) false\n\t      (= c 0) true\n\t      (= c 2) true\n\t      true false\n\t      )\n\t   ))", "problem": 89, "user": "4e14108c535d04ed9115e7dd"}, {"code": "(fn graph-tour-4clojure\n  [v]\n  (let [next-node (fn [a b]\n              (cond (= (second a) (first b)) b\n                    (= (second a) (second b)) (vec (reverse b))\n                    :else false))\n         drop-from-vec (fn drop-from-vec [v i]\n              (vec (if (number? i) \n                (concat (subvec v 0 i) (subvec v (inc i) (count v)))\n                (loop [counter 0]\n                  (if (= i (get v counter)) (drop-from-vec v counter)\n                    (if (= counter (count v)) false\n                      (recur (inc counter))))))))]\n            (letfn [(try-path\n                      [counter before after]\n                        (let [to-check (get before counter)]\n                            (if (empty? before) true\n                              (if (= (count before) counter) false\n                                (if (next-node (last after) to-check)\n                                  (some true? (vector (try-path 0 (drop-from-vec before to-check) (conj after (next-node (last after) to-check)))\n                                                      (try-path (inc counter) before after)))\n                                  (try-path (inc counter) before after))))))]\n              (if (some true? \n                    (for [node v] \n                      (try-path 0 (drop-from-vec v node) (vector node))))\n                true false))))", "problem": 89, "user": "4e16bdef535d04ed9115e7e9"}, {"code": "(fn eulerian?\n  [edges]\n  (letfn [(nodes\n            [edges]\n            (set (apply concat edges)))\n\n          (neighbours\n            [node edges]\n            (loop [edges (seq edges) neighbours []]\n              (if edges\n                (let [[x y] (first edges)]\n                  (cond\n                   (= x node) (recur (next edges) (conj neighbours y))\n                   (= y node) (recur (next edges) (conj neighbours x))\n                   :else      (recur (next edges) neighbours)))\n                neighbours)))\n\n          (walk\n            ([start edges]\n               (walk start edges #{}))\n            ([start edges seen]\n               (if (empty? edges)\n                 (conj seen start)\n                 (let [ns (neighbours start edges)\n                       new-edges (remove (fn [[a b]] (or (= start a) (= start b))) edges)\n                       new-seen (conj seen start)]0\n                       (reduce into new-seen (map #(walk % new-edges new-seen) ns))))))\n\n          (connected?\n            [edges]\n            (let [ns (nodes edges)]\n              (= ns (walk (first ns) edges))))\n\n          (degree [node] (count (neighbours node edges)))\n          \n          (eulerian?\n            [edges]\n            (and (connected? edges)\n                 (<= (count (filter odd? )))))]\n\n    (and (connected? edges)\n         (<= (count (filter odd? (map degree (nodes edges)))) 2))))", "problem": 89, "user": "4e50b67b535dc968683fc4ed"}, {"code": "(fn travelling-salesman [graph]\n  (letfn [(exits [graph node]\n  \t (for [i (range (count graph))\n\t\t       :let [[head tail] (split-at i graph)\n\t\t\t     [a b] (first tail)]\n\t\t       :when (or (= a node) (= b node))]\n\t\t   [(if (= node a) [a b] [b a]) (concat head (drop 1 tail))]))\n\t  (walkable? [graph node]\n\t\t     (if (empty? graph)\n\t\t       true\n\t\t       (do\n\t\t\t (loop [exits (exits graph node)]\n\t\t\t   (if (empty? exits)\n\t\t\t     false\n\t\t\t     (let [[[from to] remaining] (first exits)]\n\t\t\t       (if (walkable? remaining to)\n\t\t\t\t true\n\t\t\t\t (recur (rest exits)))))))))]\n    (walkable? graph (ffirst graph))))", "problem": 89, "user": "4e513ecf535dc968683fc4f6"}, {"code": "(fn [connections]\n  (letfn [(remove-first [coll e]\n            (let [[before remaining] (split-with #(not= e %) coll)]\n              (concat before (rest remaining))))\n          (any? [coll] (not (nil? (some identity coll))))\n          (tour [node graph]\n            (or (every? empty? (vals graph))\n                (any? (for [new-node (graph node)]\n                        (tour new-node \n                               (assoc graph node (remove-first (graph node) new-node)\n                                            new-node (remove-first (graph new-node) node)))))))]\n    (let [graph (reduce (fn [m [e1 e2]]\n                          (assoc m e1 (conj (m e1) e2)\n                                 e2 (conj (m e2) e1)))\n                        {} connections)]\n      (any? (for [starting-node (keys graph)]\n              (tour starting-node graph))))))", "problem": 89, "user": "4e52d815535d302ef430da77"}, {"code": "(letfn\n  [(add-pair [m rel [a b]]\n     (into (conj rel [a b])\n       (for [c (m b)] [a c])))\n    \n   (make-map [rel]\n     (apply merge-with clojure.set/union\n       (for [[a b] rel] {a #{b}})))\n      \n   (one-step [rel]\n     (let [m (make-map rel)]\n       (reduce (partial add-pair m)\n         #{} rel)))\n   (transitive [rel]\n     (let [new-rel (one-step rel)]\n        (if (= rel new-rel)\n         rel\n          (recur new-rel))))\n    (symmetric [rel]\n      (into rel (for [[a b] rel] [b a])))\n    (domain [rel]\n      (into #{} (map first rel)))\n    (square [n] (* n n))\n    (degrees [rel]\n      (for [[k v] (group-by identity (flatten rel))]\n        (count v)))\n    (connected? [rel]\n      (= (count (transitive (symmetric rel)))\n        (square (count (domain (symmetric rel))))))]\n  #(and (connected? %)\n    (let [d (count (filter odd? (degrees %)))]\n      (or (= d 0) (= d 2)))))", "problem": 89, "user": "4ddbfb8a535d02782fcbea00"}, {"code": "(fn f [[a & b]]\n  (if (nil? b)\n    true\n    (let [i (first (filter #(and (some (set a) %) (not= a (reverse %)) (not= a %)) b))\n          j (first (filter #(some (set a) %) b))\n          k (fn [i] `(~(take 2 (flatten (vals (sort (group-by count (partition-by identity (sort (concat i a)))))))) ~@(remove #{i} b)))]\n      (if i\n        (f (k i))\n        (if j\n          (f (k j))\n          false)))))", "problem": 89, "user": "4e49badd535dc968683fc4c9"}, {"code": "(letfn [\r\n  \t(all-nodes [edges]\r\n\t\t\t(into #{} (flatten edges)))\r\n\t\t\t\r\n\t\t(adjacent-edges [node edges]\r\n\t\t\t(filter (fn [[n1 n2]] (or (= n1 node) (= n2 node))) edges))\r\n\t\t\t\r\n\t\t(adjacent-node [node edge]\r\n\t\t\t(if (= node (first edge))\r\n\t\t\t\t(second edge)\r\n\t\t\t\t(first  edge)))\r\n\t\t\t\t\r\n\t\t(extend-path [path open-edges]\r\n\t\t\t(let [trailing-node (last path)]\r\n\t\t\t\t(for [edge (adjacent-edges trailing-node open-edges)]\r\n\t\t\t\t\t[(conj path (adjacent-node trailing-node edge)) (remove #{edge} open-edges)])))\r\n\t\t\t\t\t\r\n\t\t(complete-path [[path open-edges]]\r\n\t\t\t(let [extended-paths (extend-path path open-edges)]\r\n\t\t\t\t(if (seq extended-paths)\r\n\t\t\t\t\t(mapcat complete-path extended-paths)\r\n\t\t\t\t\t[path])))\r\n\t\t\t\t\t\r\n\t\t(can-tour-from [start-node edges]\r\n\t\t\t(= (apply max (map count (complete-path [[start-node] edges]))) (inc (count edges))))]\r\n\t\r\n\t(fn can-tour [edges]\r\n\t\t(loop [start-nodes (all-nodes edges)]\r\n\t\t\t(if-let [[n & ns] (seq start-nodes)]\r\n\t\t\t\t(if (can-tour-from n edges)\r\n\t\t\t\t\ttrue\r\n\t\t\t\t\t(recur ns))\r\n\t\t\t\tfalse))))", "problem": 89, "user": "4dd6d6a0535d2dad7130b5ca"}, {"code": "(fn graph-tour                                                                                                                                              \n  [coll]                                                                                                                                                      \n  (if (empty? (filter #(not (= (first %) (second %))) coll))                                                                                                  \n    false                                                                                                                                                     \n    (if (= 1 (count (concat (filter #(not (= (first %) (second %))) coll))))                                                                                  \n      true                                                                                                                                                    \n      (= 0 (count                                                                                                                                             \n           (filter odd?                                                                                                                                       \n                   (map count                                                                                                                                 \n                        (partition-by identity                                                                                                                \n                                      (sort                                                                                                                   \n                                       (apply concat                                                                                                          \n                                              (filter                                                                                                         \n                                               #(not                                                                                                          \n                                                 (= (first %) (second %))) coll)))))))))))", "problem": 89, "user": "4e3bcccd535deb9a81d77f56"}, {"code": "(fn[kanten-seq]\n  (letfn[\n    (adja-map[kanten-seq]\n      (let [dup (into kanten-seq (map (fn[[k v]] [v k]) kanten-seq))]\n        (apply merge-with (fn[o n] (concat o n)) (map (fn[[k v]] (hash-map k [v])) dup))))\n    (zusammenhaengend? [kanten-seq]\n        (let [am (adja-map kanten-seq)\n              node-set (set (keys am))]\n          (loop [rn (set (val (first am)))\n                 rounds 1]\n            (if (= rn node-set)\n              true\n              (if (<= rounds (count node-set))\n                (let [next-rn (reduce into #{} (vals (select-keys am rn)))]\n                  (recur (into rn next-rn) (inc rounds)))\n                false)))))\n    (grad-bedingung?[kanten-seq]\n        (let [knoten-ug (count (filter (fn[a-seq] (> (mod (count a-seq) 2) 0))\n                                       (vals (adja-map kanten-seq))))]\n          (or (= 0 knoten-ug) (= 2 knoten-ug))))]\n  (and (zusammenhaengend? kanten-seq) (grad-bedingung? kanten-seq))))", "problem": 89, "user": "4e58bcd4535d8a8b8723a296"}, {"code": "(fn [i-edges]\n     (let [\n           nodes (reduce #(conj (conj %1 (first %2)) (last %2)) #{} i-edges)\n\n           n-count (count nodes)\n           n-range (range n-count)\n           n-map (apply hash-map (interleave nodes n-range))\n           n-index (fn [i-node] (get n-map i-node))\n\n           e-count (count i-edges)\n\n           edges-count (fn [my-edges]\n                           (reduce\n                             (fn [result i-edge]\n                                 (let [[edge occurences] i-edge]\n                                   (conj result (hash-map edge (count occurences)))))\n                             {}\n                             (group-by #(apply vector %) (map sort my-edges))))\n           edge-count (fn [i-edge]\n                          (let [e-count (edges-count i-edges)]\n                            (get e-count i-edge 0)))\n\n           edges (concat i-edges (map #(apply vector (reverse %)) i-edges))\n           grouped-edges (group-by #(n-index (first %)) edges)\n\n           n-dest (fn [i-node]\n                      (reduce #(conj %1 (last %2)) #{} (get grouped-edges (n-index i-node))))\n\n           build-chains (fn chain\n                            ([i-edge] (chain (dec e-count) (vector (vector i-edge))))\n                            ([i result]\n                             (if (zero? i)\n                               result\n                               (chain\n                                 (dec i)\n                                 (reduce\n                                   concat\n                                   []\n                                   (map\n                                     (fn [i-chain]\n                                         (let [\n                                               t-node (last (last i-chain))\n                                               n-edges (map #(vector t-node %) (n-dest t-node))\n                                               ]\n                                           (filter\n                                             (fn [my-chain]\n                                                 (reduce\n                                                   (fn [result i-edge]\n                                                       (let [[edge o-count] i-edge]\n                                                         (and result (>= (edge-count edge) o-count))))\n                                                   true\n                                                   (edges-count my-chain)))\n                                             (map #(conj i-chain %) n-edges))))\n                                     result))))))\n           ]\n       (reduce\n         (fn [result i-edge]\n             (if (false? result)\n               (boolean (some #(= (count %) e-count) (build-chains i-edge)))\n               result))\n         false\n         i-edges)))", "problem": 89, "user": "4dad7adac9a9d6ed0599dc57"}, {"code": "(fn tourable?\n  ([c] (let [[k1 k2] (first c)\n              r (rest c)\n              c (count r)]\n          (if (zero? c)\n            true\n            (true? (or (tourable? k1 r)\n                 (tourable? k2 r))))))\n  ([k c] (let [[k1 k2] (first c)\n               r (rest c)]\n           (if (and (nil? (seq r))\n                    (or (= k k1)\n                        (= k k2)))\n             true\n             (some identity\n                   (for [i (range (count c))]\n                     (let [tc (concat (drop i c)\n                                      (take i c))\n                           [k1 k2] (first tc)\n                           r (rest tc)]\n                       (or\n                        (when (= k k1)\n                          (tourable? k2 r))\n                        (when (= k k2)\n                          (tourable? k1 r))))))))))", "problem": 89, "user": "4ddbdc1b535d02782fcbe9fd"}, {"code": "(fn [graph]\n  (let [edge-from-vertex?\n        (fn [vertex edge]\n          (let [[v1 v2] edge]\n            (or\n             (= v1 vertex)\n             (= v2 vertex))))\n\n        next-vertex\n        (fn [edge vertex]\n          (let [[v1 v2] edge]\n            (condp = vertex\n                v1 v2\n                v2 v1\n                nil)))\n          \n        traversable-edges\n        (fn [graph vertex]\n          (->> graph\n               (filter (partial edge-from-vertex? vertex))))\n\n        remove-edge\n        (fn [graph edge]\n          (let [[a b] (split-with (partial not= edge) graph)]\n            (concat a (rest b))))\n        \n        graph-routes\n        (fn this [graph vertex]\n          (when-let [edges (seq (traversable-edges graph vertex))]\n            (mapcat\n             (fn [edge]\n               (if-let [routes (this (remove-edge graph edge)\n                                     (next-vertex edge vertex))]\n                 (map\n                  (partial cons edge)\n                  routes)\n                 (list (list edge))))\n             edges)))]\n    (->> (mapcat (partial graph-routes graph) (into #{} (apply concat graph)))\n         (some #(= (count graph) (count %)))\n         (true?))))", "problem": 89, "user": "4e68c434535d8ccf87e9fe89"}, {"code": "(fn c? [g]\r\n  (letfn [\r\n\t\t\t\t(spl [n l] [(nth l n) (concat (take n l) (drop (inc n) l))])\r\n\t\t\t\t(spls [l] (map #(spl % l) (range (count l))))\r\n\t\t\t\t(nxt [n [a b]] (condp = n\r\n\t\t\t\t                     a b\r\n\t\t\t\t                     b a\r\n\t\t\t\t                     nil\r\n\t\t\t\t                     ))    \r\n\t\t\t\t(tr? [n es]\r\n\t\t\t\t  (or\r\n\t\t\t\t    (and n (empty? es))\r\n\t\t\t\t    (some #(tr? (nxt n (first %)) (second %)) \r\n\t\t\t\t         (spls es))))\r\n\t      (n1 [e] (ffirst e))\r\n\t      (n2 [e] (second (first e)))\r\n\t      ]\r\n        (let [ps (spls g)]\r\n          (= true\r\n\t\t\t\t\t\t(or\r\n\t\t\t\t\t    (some #(tr? (n1 %) (second %)) ps)\r\n\t\t\t\t\t    (some #(tr? (n2 %) (second %)) ps))))))", "problem": 89, "user": "4e6e10d8535d5021c1a895fd"}, {"code": "(fn [arcs]\r\n  (letfn [(start-from? [start-node arcs]\r\n            (or (empty? arcs)\r\n                (loop [[left-node right-node :as next-arc] (first arcs)\r\n                       failed-arcs []\r\n                       rest-arcs (rest arcs)]\r\n                  (or (and (= left-node start-node)\r\n                           (start-from? right-node (concat failed-arcs rest-arcs)))\r\n                      (and (= right-node start-node)\r\n                           (start-from? left-node (concat failed-arcs rest-arcs)))\r\n                      (and (not (empty? rest-arcs))\r\n                           (recur (first rest-arcs)\r\n                                 (conj failed-arcs next-arc)\r\n                                 (rest rest-arcs)))))))]\r\n    (let [arcs-at-nodes (reduce (fn [counts [left-node right-node]]\r\n                                  (merge-with + counts {left-node 1} {right-node 1}))\r\n                                {}\r\n                                arcs)\r\n          odd-nodes (map first\r\n                         (filter (fn [[node count]] (odd? count))\r\n                                 arcs-at-nodes))]\r\n      (cond (empty? odd-nodes) (start-from? (ffirst arcs) arcs)\r\n            (= 2 (count odd-nodes)) (start-from? (first odd-nodes) arcs)\r\n            :else false))))", "problem": 89, "user": "4e7c8fd1535db169f9c796be"}, {"code": "(fn [e]\n  (if (#{0 2} (count (filter odd? (vals (frequencies (mapcat seq e))))))\n    (not (next (reduce\n                (fn [g e]\n                  (let [[a b] (map (fn [n] (or (some #(if (% n) %) g) #{n})) e)]\n                    (conj (disj g a b) (into a b))))\n                #{}\n                e)))\n    false))", "problem": 89, "user": "4db858d1535d1e037afb218c"}, {"code": "(fn [edgevec]\n  (letfn [(neighbors [edgevec]\n      (reduce\n         (fn [m e]\n             (letfn [(addmap [m a b] (assoc m a (if-let [nbdset (get m a)] \n  \t\t\t\t\t     (conj nbdset b) \n\t\t\t\t\t\t    (set (list b)))))]  \n               (let [a (e 0) b (e 1)]\n                    (addmap (addmap m a b) b a))))\n         {} edgevec))\n(connected? [edgevec]\n  (let [N (neighbors edgevec)\n\tvertices (keys N)\n\tq (atom clojure.lang.PersistentQueue/EMPTY)]\n    (letfn [(nq [v] (swap! q #(conj  % v)))\n\t    (hq [] (peek @ q))\n\t    (dq [] (swap! q pop ))]\n        (nq (first vertices))\n\t(loop [bag #{}]\n\t  (if-let [head  (hq)]\n\t    (do  (dq) (loop [v (vec (N head))]\n\t\t (if (not (empty? v))\n\t\t   (do\t\t     (if (not (contains? bag (first v))) (nq (first v)))\n\t\t     (recur (rest v)))))\n               (recur (conj bag head)))\n\t   (= (set vertices) bag))))))\n        (degmod2 [edgevec]\n      (reduce\n         (fn [m e]\n             (letfn [(addmap [m a b] (assoc m a (if-let [bit (get m a)] (bit-xor bit 1) 1)))]  \n               (let [a (e 0) b (e 1)]\n                    (addmap (addmap m a b) b a))))\n         {} edgevec))]\n  (let [oddballs (reduce +  (vals (degmod2 edgevec)))]\n    (and (connected? edgevec) (<= oddballs 2)))))", "problem": 89, "user": "4e6e3a1e535d5021c1a89602"}, {"code": "(fn [input]\n  (let [\n    join (fn [[a1 b1] [a2 b2]]\n      (remove nil?        \n        [(if (= b1 a2) [a1 b2])\n         (if (= b1 b2) [a1 a2])\n         (if (= a1 b2) [b1 a2])\n         (if (= a1 a2) [b1 b2])]))\n    rm (fn [x list] (remove #(= x %) list))\n    test-fn (fn f[a rest]\n      (if (empty? rest)\n        true\n        (loop [b (first rest), r (next rest)]\n          (let [t (join a b),  r2 (rm b rest)]\n            (cond (some true? (map #(f % r2) t)) true                  \n                  (empty? r) false\n                  :else (recur (first r) (next r)))))))]\n    (test-fn (first input) (next input))))", "problem": 89, "user": "4e7db3b4535db169f9c796e1"}, {"code": "(let [any? (comp not not some)\n      rem1 (fn [s x]\n             (let [[t d] (split-with (complement #{x}) s)]\n               (concat t (next d))))\n      other (fn [x [a b]] (if (= x a) b a))\n      nodes (partial reduce into #{})]\n  (fn tourable?\n    ([edges] (any? #(tourable? edges %) (nodes edges)))\n    ([edges node]\n     (some #(let [es (rem1 edges %)]\n              (or (empty? es)\n                  (tourable? es (other node %))))\n           (distinct (filter #(some #{node} %) edges))))))", "problem": 89, "user": "4e6a412e535d8ccf87e9feb6"}, {"code": "(fn tourable? [edges]\n  ; Note that the graph is defined with a collection of edges.  Therefore all\n  ; vertices will have a nonzero degree.  If vertices with zero degree were\n  ; part of the graph, they would have to be excluded from the \"connected\n  ; component\" check.\n  (let [\n  vertices-of (fn [edges]\n    (reduce #(apply conj %1 %2) #{} edges))\n  vertices (vertices-of edges)\n  degree (fn [vertex]\n    (let [c (fn [acc [x y]]\n      (+ acc (if (= x vertex) 1 0)\n             (if (= y vertex) 1 0)))]\n      (reduce c 0 edges)))\n  odd-degree? (fn [vertex]\n    (== 1 (mod (degree vertex) 2)))\n  graph-connected? (fn [edges]\n    (let [\n    arbitrary-vertex (first vertices)\n    add-all (fn [xs set]\n      (apply conj set xs))\n    remove-all (fn [xs set]\n      (apply disj set xs))\n    impl (fn [acc xs rem]\n      (if (empty? rem)\n        true\n        (let [neighbors (->> (filter #(or (xs (% 0)) (xs (% 1))) edges)\n                             (vertices-of)\n                             (remove-all acc)\n                             (remove-all xs))]\n          (if (empty? neighbors)\n            false\n            (recur (add-all xs acc) neighbors (remove-all neighbors rem))))))\n    ]\n    (impl #{} #{arbitrary-vertex} (disj vertices arbitrary-vertex))))\n  number-of (fn [pred xs]\n    (reduce #(+ %1 (if (pred %2) 1 0)) 0 xs))\n  ]\n  (and (<= (number-of odd-degree? vertices) 2)\n       (graph-connected? edges))))", "problem": 89, "user": "4e691c79535d8ccf87e9fe97"}, {"code": "(fn [g]\n  (letfn [(t [v g]\n            (or (not g)\n                (some (fn [[[a b] & m]] (or (and (= v a) (t b m))\n                                            (and (= v b) (t a m))))\n                      (map #(concat (drop % g) (take % g)) (range (count g))))))]\n    (boolean (some #(t % g) (flatten g)))))", "problem": 89, "user": "4e8612f8535db62dc21a62f2"}, {"code": "#(let [v (flatten %)\n       C count I into]\n   (and\n    (boolean \n     (#{0 2} (C (filter odd? (map C (vals (group-by list v)))))))\n    (loop [m (I (set %) (map rseq %)) s 0]\n      (if (= s (C m))\n        (= (Math/sqrt s) (C (set v)))\n        (recur (I m (for [[a b] m [c d] m \n                             :when (= b c)]\n                         [a d]))\n               (C m))))))", "problem": 89, "user": "4e5fe31a535d8ccf87e9fe50"}, {"code": "(fn [v]\n    (let [f\n      (fn [s v]\n        (loop [c s w v]\n          (if-let [x (some #(when ((set %) c) %) (keys w))]\n            (let [d (if (= c (first x)) (last x) (first x))]\n              (recur \n                  d\n                  (if (> (w x) 1) (update-in w [x] dec) (dissoc w x))))\n            w))) \n    s (first (flatten v))]\n      (empty? (f s (f s (frequencies v))))))", "problem": 89, "user": "4db85282535d1e037afb218a"}, {"code": "(fn f [s]\n   (letfn [ (connected? [ s connected ]\n              (if (empty? s)\n                (= 1 (count connected))\n                  (let [ [a b]  (first s)\n                        c_a   (first (filter #(% a) connected))\n                        c_b   (first (filter #(% b) connected)) ]\n                     (recur (rest s)\n                        (conj (disj connected c_a c_b) (clojure.set/union #{a} #{b} c_a c_b))))))\n             \n             (order [n s]\n                 (count (filter #(and ((set %) n) (not= (first %) (second %))) s))) ]\n      \n     (if (and (connected? s #{})        \n               (#{0 2} (count (filter #(odd? (order % s)) (distinct (flatten s))))))\n         true\n         false)))", "problem": 89, "user": "4e860e85535db62dc21a62f1"}, {"code": "(fn graph-tour [edges]\n   (let [edge-set (set (map (fn [n e] [n e]) (range) edges))]\n     (letfn [(leads-from? [a [n [x y]]] (or (= x a) (= y a)))\n             (follow [a [n [x y]]] (if (= x a) y x))\n             (walk? [explored p]\n               (if (= explored edge-set)\n                 true\n                 (some #(let [next (follow p %)] (walk? (conj explored %) next))\n                       (filter #(and (leads-from? p %) (not (explored %))) edge-set))))]\n       (if (walk? #{} (ffirst edges)) true false)\n       )))", "problem": 89, "user": "4e89f46c535d3e98b8023288"}, {"code": "(fn [coll]\r\n  (let [c (count coll)]\r\n\t\t(or\r\n\t\t\t(= c 1)\r\n\t\t\t(= c 11)\r\n\t\t\t(and (= c 4) (= [4 1] (last coll))))))", "problem": 89, "user": "4dfe65a1535d04ed9115e787"}, {"code": "(fn [s]\r\n     (let [p (distinct (flatten s))\r\n           n (count p)\r\n     c (/ (* n (inc n)) 2)\r\n\t\t ex? (fn [s [i j]] (or (contains? s [i j]) (contains? s [j i])))\r\n\t\t deg (->> (filter  #(not (apply = %)) s)\r\n\t    (mapcat #(vector % [(last %) (first %)])) (set) (group-by first) (vals) (map #(count %)))\r\n\t\t cond1  (> 3 (count (filter odd? deg)))\r\n        conn?  (= c (count (reduce\r\n\t\t   (fn [st [i j k]] \r\n\t\t       (if  (and (ex? st [i k]) (ex? st [k j]) (not (ex? st [i j])))\r\n\t\t\t   (into st [[i j]]) st))\t\t       \r\n\t\t   (set s)\r\n\t\t   (for [i p j p k p]\r\n\t              [i j k]))))]\r\n\t\t      (and conn? cond1)))", "problem": 89, "user": "4dae4da5c9a9d6ed4e99dc57"}, {"code": "(fn [graph]\n  (let [edges (set (map set graph))\n        nodes (set (flatten graph))\n        degs (apply hash-map \n                      (flatten (map (fn [node]\n                             [node, (count (filter (fn [edge]\n                                                     (contains? edge node)) edges))]) nodes)))\n        ]\n    degs\n    (or (= (count edges) 1)\n      (not-any? #(not= 0 (mod % 2)) (vals degs)))\n    ))", "problem": 89, "user": "4e9fd521535d7eef3080729a"}, {"code": "(fn [s]\n   (let [;; Bidirectional set of edges\n         s2 (into s (map (comp vec reverse) s))\n         ;; Reachability map: all edges. Problem statement really should\n         ;; specify that this is a multigraph, not a graph.\n         m (into {} (map (fn [[k v]] [k (map second v)]) (group-by first s2)))\n         ;; Iterates (f x), (f (f x)), ... until the result no longer changes.\n         closure (fn [f x] (let [fx (f x)] (if (= x fx) x (recur f fx))))\n         ;; Transitive closure of the reachability map\n         mm (closure (fn [x] (reduce (fn [m [k v]]\n                                       (assoc m k (set (concat v (mapcat #(m %) v)))))\n                                     {} x))\n                     m)]\n     (and (apply = (vals mm)) ; connected, and\n                                        ; at most 2 vxs have odd degree\n          (<= (count (filter #(odd? (count %)) (vals m))) 2))))", "problem": 89, "user": "4ea1b9e4535d7eef308072b8"}, {"code": "(fn [edges]\n  (letfn [(nodes [edges] (set (flatten (vec edges))))\n          (neighbours [edges node]\n            (set\n             (for [e edges :when (some #(= node %) e)]\n              (if (= (first e) node) (second e) (first e)))))\n          (component [edges node]\n            (loop [todo #{node},\n                   found #{node}]\n              (if (empty? todo) found\n                (let [n      (first todo)\n                      neighb (remove found (neighbours edges n))]\n                  (recur (disj (into todo neighb) n) (conj found n))))))\n          (connected? [edges]\n            (let [all-nodes (nodes edges)]\n              (= all-nodes (component edges (first all-nodes)))))\n          (degree [edges node]\n            (count (filter #(= node %) (flatten (vec edges)))))]\n  (let [odd-nodes (count (filter odd? (map (partial degree edges) (nodes edges))))]\n    (and (or (= 0 odd-nodes) (= 2 odd-nodes))\n         (connected? edges)))))", "problem": 89, "user": "4e994541535dbda64a6f6b64"}, {"code": "(fn g [l] \n  (letfn [(r [x l] (concat (take-while #(not= x %) l) \n                           (rest (drop-while #(not= x %1) l))))\n          (t [[x] s]  \n            (if (empty? s) true \n              (some #(if ((set %) x)\n                         (t (r x %) (r % s)) false) s)))]\n        (if (some #(t [(first %)] (r % l)) l) true false)))", "problem": 89, "user": "4dbdab4e535d020aff1edf49"}, {"code": "(fn [g]\n  (or (= (count g) 1)\n    (let [n (distinct (apply concat g)) g (filter (fn [[a b]] (not= a b)) g)](println n g)\n      (and (not (empty? g))\n           (every? even? (map (fn [e] (count (filter #(some #{e} %) g))) n))))))", "problem": 89, "user": "4e82f85d535db62dc21a62ce"}, {"code": "#(if (some (partial apply =) %) false\r\n  (->> % (apply concat) frequencies vals\r\n       (filter odd?) count #{0 2} boolean))", "problem": 89, "user": "4eb97b2e535dfed6da9c6d54"}, {"code": "(fn graph-tour\r\n  [edges]\r\n\t(or\r\n\t\t(= 1 (count edges))\r\n\t\t(letfn [(nodes [edges]\r\n\t\t\t\t\t\t\t(reduce (fn [result [a b]] (merge-with #(set (concat %1 %2)) result {a #{b}} {b #{a}})) \r\n\t\t\t\t\t\t\t\t\t\t\t{} \r\n\t\t\t\t\t\t\t\t\t\t\tedges))]\r\n\t\t\t(every? #(even? (count (second %))) (nodes edges)))))", "problem": 89, "user": "4e8a0c82535d3e98b802328d"}, {"code": "(fn has-eulerian-path? [g]\n (if (< (count g) 2) true\n (let [adj-list (fn [s]\n        (let [nodes (set (mapcat flatten s))\n          nbs (fn [curr] \n              (mapcat (partial filter #(not= % curr)) \n                      (filter (partial some #(= % curr)) s)))]\n        (zipmap nodes (map nbs nodes))))\n       degrees (map count (vals (adj-list g)))]\n  (and (not-any? zero? degrees) \n       (every? even? degrees)))))", "problem": 89, "user": "4dcfbc44535d5973398f92a7"}, {"code": "(fn p89 [col]\n  (let [connected? (fn [chain-seq vb]\n                       (let [h (first (first chain-seq)) t (last (last chain-seq))]\n                       (or (= h (first vb))\n                          (= h (second vb))\n                          (= t (first vb))\n                          (= t (second vb)))))\n\n        find_next_edge (fn [v subcol]\n                  (filter  #(first %)  (map (fn [v1] [(connected? v v1) v1 ] )  subcol)))\n\n        visit-graph (fn visit-graph [chain-seq rest-set]\n                        (if (empty? rest-set)\n                            chain-seq\n                            (let [next_chain_tuple (find_next_edge  chain-seq rest-set)]\n                                (if (empty? next_chain_tuple)\n                                    []\n                                    (loop [possible_tuple (first next_chain_tuple) data (rest next_chain_tuple) ]\n                                      (let [possible_chain (visit-graph\n                                                                       (conj chain-seq (second  possible_tuple))\n                                                                       (disj rest-set   (second possible_tuple)  )    )]\n                                      (if (and (empty? data) (empty? possible_chain))\n                                          []\n                                          (if (not (empty? possible_chain))\n                                              possible_chain\n                                              (recur (first data) (rest data))\n                                        ))\n                                      ))))))\n\n\n        ]\n       (= (count (visit-graph [(first col)] (set (rest col))))  (count col) (count (set col)) )\n       ;(visit-graph [(first col)] (set (rest col)))\n    )\n\n\n  )", "problem": 89, "user": "4ec5bec6535d6d7199dd36b3"}, {"code": "(letfn\n    [(nodes [edges] (into #{} (flatten edges)))\n     (add-neighbor [nbrs [u v]] (assoc nbrs u (conj (get nbrs u) v)))\n     (graph [edges]\n       (let [nn (nodes edges)\n             nbrs (reduce add-neighbor (zipmap nn (repeat [])) edges) ;multigraph\n             ;undirected (but don't count self-loops twice)\n             nbrs (reduce add-neighbor nbrs\n                          (for [[u v] edges :when (not= u v)] [v u]))] \n         {:nodes nn :neighbors nbrs}))\n     (next-nodes [g n] ((:neighbors g) n))\n     (depth-first\n       [graph start]\n       (let [walk \n             (fn walk [seen trans]\n               (let [frontier (drop-while seen trans)]\n                 (when-let [next-node (first frontier)]\n                   (lazy-seq\n                    (cons next-node\n                          (walk (conj seen next-node)\n                                (concat (next-nodes graph next-node) frontier)))))))]\n         (walk #{start} (next-nodes graph start))))\n     (connected? [g]\n       (let [nn (:nodes g) start (first nn)]\n         (= nn (set (cons start (depth-first g start))))))\n     (degrees [g]\n       (map count (vals (:neighbors g))))\n     (eulerian-path? [g]\n       (and (connected? g)\n            (>= 2 (count (filter odd? (degrees g))))))\n     ]\n  (fn [es] (let [g (graph es)] (eulerian-path? g))))", "problem": 89, "user": "4ed188c8535d44c135fd68cf"}, {"code": "(fn tour\n  ([g] (boolean (some #(tour g %) (apply concat g))))\n  ([g v] (or (every? nil? g)\n             (some #(tour (assoc g % nil) ((g %) 1))\n                   (filter #(and (not (nil? (g %))) (= ((g %) 0) v))\n                          (range (count g))))\n             (some #(tour (assoc g % nil) ((g %) 0))\n                   (filter #(and (not (nil? (g %))) (= ((g %) 1) v))\n                          (range (count g)))))))", "problem": 89, "user": "4ed94d69535d10e5ff6f5303"}, {"code": "(fn hamiltonian? [edges]\n  (letfn [\n    (grades [edges]\n      (map (comp count second) (group-by identity (flatten edges))))\n    \n    (components [edges]\n      (reduce (fn [comps edge]\n                (let [e (set edge)\n                      {conn false, unconn true} (group-by #(empty? (clojure.set/intersection e %)) comps)\n               ] (conj unconn (apply clojure.set/union e conn))))\n        [] edges))\n    ]\n    (let [connected (= 1 (count (components edges)))\n          oddgrades (count (filter odd? (grades edges)))]\n      (and connected (contains? #{0 2} oddgrades)))))", "problem": 89, "user": "4eb9ce75535dfed6da9c6d5e"}, {"code": "; An Eulerian path in a graph of more than 1 edge exists if and only if the graph is connected and the \n; degree of every node is even. Graphs with only one edge contain trivially a Eulerian path\n\n(fn [g] (letfn [ (c [graph]\n  (letfn [(connect [connections connected]\n            (let [group (reduce (fn [s e] (apply conj s (or (connections e) #{e}))) #{} connected)]\n              (reduce (fn [m e] (assoc m e group)) connections group)))]\n    (let [connections (reduce (fn [m pair] (connect m pair)) {} graph)\n          nodes (set (keys connections))]\n      (every? #(= nodes (connections %)) nodes))))\n(re [e] (set (for [[a b] e] [b a])))\n(di [e] (remove even? (map second (frequencies (map first (clojure.set/union e (re e)))))))] \n(and (c g) (or (= 1 (count g)) (= 0 (count (di g)))))))", "problem": 89, "user": "4ede8789535d10e5ff6f5337"}, {"code": "(fn [graph]\n  (let [remove1 (fn remove1 [x [y & ys]]\n                  (if (= x y) ys (conj (remove1 x ys) y)))\n        tour-from? (fn tour-from? [from graph]\n                     (or (empty? graph)\n                         (some #(tour-from? (first %) (remove1 % graph))\n                               (filter #(= from (second %)) graph))\n                         (some #(tour-from? (second %) (remove1 % graph))\n                               (filter #(= from (first %)) graph))))]\n    (true? (some #(or (tour-from? (first %) (remove1 % graph))\n                      (tour-from? (second %) (remove1 % graph)))\n               graph))))", "problem": 89, "user": "4ee3b586535d10e5ff6f5371"}, {"code": "(fn [e]\n  (let [C count\n        m (atom #{})\n        v (flatten e)]\n    (and (= (C (set v))\n            (C (set (tree-seq\n                      #(when-not (@m %) (swap! m conj %))\n                      #(keep\n                         (fn [[x y]] (when (and (= x %) (not= y %)) y))\n                         (into e (map (fn [[x y]] [y x]) e)))\n                      (ffirst e)))))\n         (< (C (filter odd? (map last (frequencies v)))) 3))))", "problem": 89, "user": "4ee82539535d93acb0a66878"}, {"code": "(fn [edges]\n    (let [remove-elem (fn [c elem]\n                        (concat (take-while (complement #{elem}) c)\n                                (rest (drop-while (complement #{elem}) c))))]\n      (or (->> (iterate (fn [tours]\n                          (mapcat (fn [[seen at togo-edges]]\n                                    (concat (for [[from to :as e] (filter #(= at (first %)) togo-edges)]\n                                              [(conj seen e) to (remove-elem togo-edges e)])\n                                            (for [[to from :as e] (filter #(= at (second %)) togo-edges)]\n                                              [(conj seen e) to (remove-elem togo-edges e)]))) tours))\n                        [[#{} (ffirst edges) edges]])\n               (take-while seq)\n               (reduce concat)\n               (some (fn [[seen at togo-edges]]\n                       (empty? (reduce remove-elem edges seen)))))\n          false)))", "problem": 89, "user": "4e6a0667535d8ccf87e9fe9e"}, {"code": "(fn [g]\n  (and \n    (->> g (mapcat seq) frequencies vals (filter odd?) count #{0 2} boolean)\n    ((fn f [e] \n       (#(if (= e %) (= % (set g)) (f %)) \n          (reduce (fn [a b] (into a (filter #(some (set b) %) (set g)))) \n                  #{} \n                  e))) \n       #{(first g)})))", "problem": 89, "user": "4ef49c2c535dced4c769f238"}, {"code": "(fn [s]\n  (letfn [(remaining-edges [chain]\n      (loop [chain chain edges s]\n        (if (empty? chain) edges\n          (recur (rest chain) (rest (sort-by #(not= (set (first chain)) (set %)) edges))))))\n    (chains [chain]\n      (let [left (remaining-edges chain)]\n        (mapcat (fn [node] (concat\n          (if (= (last node) (ffirst chain))\n            [(vec (cons node chain))] [])\n          (if (= (first node) (ffirst chain))\n            [(vec (cons (reverse node) chain))] [])))\n          left)))]\n    (loop [possible-chains [[(first s)]] previous []]\n      (print possible-chains)\n      (cond\n        (some #(= (count %) (count s)) possible-chains)\n          true\n        (= previous possible-chains)\n          false\n        true\n          (recur (mapcat chains possible-chains) possible-chains)))))", "problem": 89, "user": "4ebc08a8535dfed6da9c6d7c"}, {"code": "(fn tour? [g]\n  (let [nodes (fn [g] (apply clojure.set/union (map set g)))\n        children (fn [g parent] (disj (apply clojure.set/union (filter #(contains? % parent)\n                                                                       (map set g)))\n                                      parent))\n        node-edges (map #(count (children g %)) (nodes g))\n        contains-0 (apply * node-edges)\n        odd-count (count (filter odd? node-edges))]\n    (cond (= 1 (count g)) true\n          (= 0 contains-0) false\n          :else (= 0 odd-count))))", "problem": 89, "user": "4dd7b81d535d2dad7130b5d3"}, {"code": "(fn [g]\n    (letfn [(s [n x]\n              (or (= [] x)\n                (some\n                  (fn [[i [e f]]]\n                    (and (or (= e n) (= f n))\n                      (s \n                        (if (= e n) f e)\n                        (concat (take i x) (drop (+ i 1) x)))))\n                    (map vector (range) x))))]\n      (->> g\n        (apply concat)\n        set\n        (keep #(s % g))\n        (not= []))))", "problem": 89, "user": "4e5411e8535d8a8b8723a279"}, {"code": "(fn [e] (let [g (reduce #(conj % %2 [(second %2) (first %2)]) '() e)\n               n (vals (frequencies (map first g)))\n               e (fn [x] (set (map second (filter #(= x (first %)) g))))\n               h ((fn r [x] (let [y (apply conj (set (mapcat e x)) x)] (if (= x y) x (r y)))) #{(first (first g))})\n               c (= h (set (flatten g)))]\n           (and c (or (every? even? n) (= 2 (count (filter odd? n)))))))", "problem": 89, "user": "4eb13d60535d7eef3080733f"}, {"code": "(fn [s] \n  (let [\n    g (into #{} s)\n    t (#(let [n (apply conj %\n            (for [[a b] %\n                  [c d] %\n                  :when (= b c)]\n              [a d]))]\n    (if (= n %)\n      %\n      (recur n))\n  ) (apply conj g (map reverse g)))\n    z (vec t)\n    q (distinct (flatten z))\n    k (count q)\n    f (first (sort q))\n    c (< (- k 1) (count\n        (filter #(= (second %) f)\n          z)))\n    p (->> s\n          flatten \n          sort \n          (partition-by identity)\n          (map count)\n          (filter odd?)\n          count\n          (> 3))] (and c p)))", "problem": 89, "user": "4f01c938535dcb61093f6a39"}, {"code": "(fn [e]\n  (let [vmap (apply merge-with into \n          (map (fn [[v1 v2]] (if (= v1 v2) nil {v1 #{v2} v2 #{v1}})) e))\n        degmap (apply merge-with +\n                  (map (fn [[v1 v2]] (if (= v1 v2) nil {v1 1 v2 1})) e))\n        connected\n            (= (-> vmap keys set)\n              ((fn s [v m seen]\n                (if (empty? m) #{v}\n                  (let [newm (dissoc m v)\n                        newseen (conj seen v)\n                        iter (filter (complement newseen) (m v))]\n                    (apply clojure.set/union #{v}\n                      (map #(s % newm newseen) iter))))) \n                  (ffirst vmap) vmap #{}))]\n    (and\n      connected \n      (->>\n        degmap\n        vals\n        (filter odd?)\n        count\n        (>= 2)))))", "problem": 89, "user": "4f03ac2d535dcb61093f6b4a"}, {"code": "(fn prob-0089\n  [rels]\n  (letfn [(tc-add-dir-rel\n            [rel p-map s-map]\n            (let [[p s] rel\n                  ;; Build new composite (p s) relations for all p & preds of p and s & succs of s.\n                  rels (for [p-new (conj (p-map p) p)\n                             s-new (conj (s-map s) s)]\n                         [p-new s-new])\n\n                  ;; Convert (p s) relations into {p #(s)} map relations.\n                  s-rels (map #(array-map (first  %) #{(second %)} ) rels)\n                  p-rels (map #(array-map (second %) #{(first  %)} ) rels)\n\n                  ;; Merge {p #(s)} relation maps into input maps, concatenating value sets.\n                  new-pm (apply merge-with into p-map p-rels)\n                  new-sm (apply merge-with into s-map s-rels)]\n        \n              [new-pm new-sm]))\n\n          (tc-add-undir-rel\n            [rel p-map s-map]\n            (let [[a b] rel]\n              (apply tc-add-dir-rel [a b]\n                     (tc-add-dir-rel [b a] p-map s-map))))\n\n          (connected?\n            [rels]\n            (let [[p-map s-map] (reduce #(apply tc-add-undir-rel %2 %1) [{} {}] rels)]\n              (and (not (empty? s-map)) (= (count p-map) (count (val (first p-map)))))))\n          ]\n\n    (let [cnt-maps (apply concat (map #(vector {(first %) 1} {(second %) 1}) rels))\n          deg-map  (apply merge-with + {} cnt-maps)\n          degrees  (vals deg-map)\n          oddness  (map odd? degrees)\n          odd-cnt  (count (filter true? oddness))\n          cnt-ok?  (or (= odd-cnt 0) (= odd-cnt 2))]\n      (and cnt-ok? (connected? rels)))))", "problem": 89, "user": "4f047c07535dcb61093f6bcd"}, {"code": "(fn [G]\n   (let [[[p _] & _ :as H] (vec G)\n         V (into #{} (flatten H)) \n         n\n         (fn [v [p q]]\n           (if (= v p)\n             [q]\n             (if (= v q)\n               [p]\n               [])))\n         m (fn [v G] (reduce #(into % (n v %2)) [] G))\n         c\n         (fn [G]\n           (loop [U #{p}]\n             (let [N (into U (mapcat #(m % G) U))]\n               (if (= N U)\n                 (= U V)\n                 (recur N)))))]\n     (if (c G)\n       (> 3 (count (filter #(= 1 (mod (count (m % G)) 2)) V)))\n       false)))", "problem": 89, "user": "4e65027c535d8ccf87e9fe6e"}, {"code": "(fn [edges]\n  (let [undirected (remove #(= 1 (count %)) (map set edges))\n        schema (map (fn [x] (count (filter #(% x) undirected))) (set (apply concat undirected)))]\n    (boolean\n     (and (not-empty undirected)\n          (every? (partial < 0) schema)\n          (>= 2 (count (filter odd? schema)))))))", "problem": 89, "user": "4f04b66b535dcb61093f6bdd"}, {"code": "(fn [edges]\n  (letfn [\n    (connect [a b]\n      (cond \n        (= (a 1) (b 0)) b\n        (= (a 1) (b 1)) [(b 1) (b 0)]\n        :else false))\n    (impl [e rem]\n      (if (empty? rem) true\n        (loop [r_ rem pre '()]\n          (cond\n            (empty? r_) false\n            (let [c (connect e (first r_))]\n              (and c (impl c (concat pre (rest r_))))) true\n            :else (recur (next r_) (concat pre (list (first r_))))))))]\n    (impl (first edges) (rest edges))))", "problem": 89, "user": "4f050dec535dcb61093f6bef"}, {"code": "(fn euler-path? [graph]\n  (if (> (reduce #(+ %1 (mod %2 2)) 0 (vals (frequencies (flatten graph)))) 2) false\n    (let [nbrs-map (reduce (fn [m [a b]] (assoc m a (into #{b} (m a)) b (into #{a} (m b)))) {} (filter #(not= apply %) graph))\n        nodes (set (keys nbrs-map))\n        trav-path (fn trav-path [m start seen]\n          (if-let [nodes (seq (remove #(some #{%} seen) (m start)))]\n            (mapcat #(trav-path m % (conj seen start)) nodes)\n            [(if (some #{start} seen) seen (conj seen start))]))]\n\n      (-> (trav-path nbrs-map (first nodes) []) flatten set (= nodes)) )))", "problem": 89, "user": "4effb663535dcb61093f6a2e"}, {"code": "(fn graph-tour [edges]\n  (let [nodes (set (apply concat edges))\n  disj (fn [v e]\n               (let [[l r] (split-with #(not= % e) v)]\n                 (concat l (rest r))\n               ))\n        dfs (fn dfs [node unvisited]\n              (let [connected\n                     (filter\n                      #(or (= node (first %)) (= node (second %)))\n                      unvisited)]\n                (cond\n                 (empty? unvisited) true\n                 (empty? connected) false\n                 :else\n                 (reduce\n                  #(or %1 (if (= (first %2) node)\n                      (dfs (second %2) (disj unvisited %2))\n                      (dfs (first %2) (disj unvisited %2))))\n                  false connected))))]\n    (reduce #(or %1 (dfs %2 edges)) false nodes)))", "problem": 89, "user": "4f0e995e535d0136e6c22326"}, {"code": "(fn [g]\n    (letfn\n        [(remove-one    [i s] (let [[f e] (split-with #(not= i %) s)]\n                                (concat f (next e))))\n         (get-node  [n [a b]] (if (= n a) b a))\n         (children    [[n g]] (map #(vector (get-node n %) (remove-one % g))\n                                   (filter #(some (partial = n) %) g)))\n         (tour? [[n g :as r]] (cond (empty? r) false\n                                    (empty? g) true\n                                    :else      (some tour? (children r))))] \n      (true? (some #(tour? [% g]) \n                   (distinct (flatten g))))))", "problem": 89, "user": "4ee88bfb535d93acb0a66881"}, {"code": "(fn [g]\n   (letfn [(ne [u E] (some (fn [[i [x y]]]\n                                (cond (= x u) [i y]\n                                      (= y u) [i x]\n                                     :else nil))\n                           (map-indexed (fn [i e] [i e]) E)))\n          (go [u E]\n             (let [[I v] (ne u E)]\n                (if I\n                    (go v (keep-indexed #(if (not= I %) %2) E))\n                    (= 0 (count E))))) ]\n            (go (get-in g [(dec (count g)) 1]) g)))", "problem": 89, "user": "4ee7d177535d93acb0a6686f"}, {"code": "(fn eulerian-graph? [g]\r\n    (letfn [(my-merger [coll1 coll2]\r\n              (merge-with concat coll1 coll2))\r\n            (edgelist-to-graph [el]\r\n              (letfn [(get-edges [edge]\r\n                        (if (= (first edge) (second edge))\r\n                          (hash-map (first edge) (list (second edge)))\r\n                          (hash-map (first edge) (list (second edge))\r\n                                    (second edge) (list (first edge)))))]\r\n                (reduce my-merger (map get-edges el))))\r\n            (remove-first [coll x]\r\n              (let [[pre post] (split-with #(not= x %) coll)]\r\n                (concat pre (rest post))))\r\n            (remove-edge [graph n1 n2]\r\n              (let [l1 (get graph n1) l2 (get graph n2)]\r\n                (assoc graph n1 (remove-first l1 n2) n2 (remove-first l2 n1))))\r\n            (edge-count [adj-list]\r\n              (count (val adj-list)))\r\n            (pick-first-vertex [graph]\r\n              (let [edge-counts (map edge-count graph)]\r\n                (cond\r\n                 (every? even? edge-counts) (key (first graph))\r\n                 (= 2 (count (filter odd? edge-counts)))\r\n                   (some #(if (odd? (count (val %))) (key %)) graph))))]\r\n      (loop [init-map (edgelist-to-graph g) stack (list (pick-first-vertex init-map)) circuit '() limit 0]\r\n        (if-let [head (first stack)]\r\n          (if-let [first-edge (first (get init-map head))]\r\n            (recur (remove-edge init-map head first-edge) (conj stack first-edge) circuit (inc limit))\r\n            (recur init-map (rest stack) (conj circuit head) (inc limit)))\r\n          (every? empty? (vals init-map))))))", "problem": 89, "user": "4f039524535dcb61093f6b2c"}, {"code": "(fn euler [edges]\n   (let [vs (reduce (fn [mp [s e]]\n             (-> mp\n                 (assoc s (conj (get mp s []) e))\n                 (assoc e (conj (get mp e []) s))))\n           {} edges)\n         oddv (filter #(odd? (count (last %))) vs)\n         oddcount (count oddv)\n         connected? (fn [[k v]]\n                       ((fn re [k r]\n                          (cond\n                           (empty? r) true\n                           (get r k) (true? (some #(re % (dissoc r k)) (get r k)))\n                           true false)) k vs))]\n     (println vs)\n     (println oddv)\n     (cond\n      (= 0 oddcount) (connected? (first vs))\n      (= 2 oddcount) (connected? (first oddv))\n      true false)))", "problem": 89, "user": "4eb02674535d7eef30807338"}, {"code": "(fn tour? [edges]\n    (assert (vector? edges))\n    (let [union clojure.set/union\n          difference clojure.set/difference\n          add-edge\n            (fn [[i m] [v1 v2]]\n                [(inc i) (merge-with union m {v1 #{i}} {v2 #{i}})])\n          vmap (second (reduce add-edge [0 {}] edges))\n          all-edges (set (range (count edges)))\n          dest (fn [v e] (let [[v1 v2] (edges e)] (if (= v v1) v2 v1)))\n          tour\n            (fn tour [v visited]\n                (if (= visited all-edges)\n                    true\n                    (->> (difference (vmap v) visited)\n                         (some #(tour (dest v %) (conj visited %)))\n                    )))\n        ]\n        (boolean (some #(tour % #{}) (keys vmap)))\n    ))", "problem": 89, "user": "4df3d4f4535d08e6dec9fe2c"}, {"code": "(fn [s]\n    (letfn [(merge-if-intersection [vertex-partition [v1 v2]]\n              (let [v1-partitions (filter #(some #{v1} %) vertex-partition)\n                    v2-partitions (filter #(some #{v2} %) vertex-partition)]\n                (if (= v1-partitions v2-partitions)\n                  (let [joined (into #{} (flatten (map seq v1-partitions)))\n                        not-in-joined (for [p vertex-partition :when (not (some p joined))] p)]\n                    (into #{} (conj not-in-joined joined))\n                    )\n                  vertex-partition)))\n            (add-edge-to-partition [vertex-partition edge]\n              (let [[v1 v2] edge\n                    edge-set (into #{} edge)\n                    vp-as-seq (flatten (map seq vertex-partition))\n                    new-partition (if (or (some #{v1} vp-as-seq)\n                                          (some #{v2} vp-as-seq))\n                                    (for [s vertex-partition]\n                                      (if (some edge-set s)\n                                        (conj (conj s v1) v2)\n                                        s))\n                                    ;; else\n                                    (conj vertex-partition edge-set))]\n                (merge-if-intersection new-partition edge)))\n            (connected [edges]\n              (= 1 (count\n                    (loop [edges edges\n                           vertex-partition []]\n                      (if (empty? edges)\n                        vertex-partition\n                        (recur (next edges) (add-edge-to-partition vertex-partition (first edges))))))))]\n      (and (connected s) \n           (<= (count (filter odd? (vals (frequencies (flatten s))))) 2))))", "problem": 89, "user": "4e89e939535d3e98b8023287"}, {"code": "(fn [s]\n  (or (= (count s) 1)\n      (and (= (count (distinct (flatten s))) \n              (count (nth \n                       (iterate \n                         (fn [o] (into o (for [n o [a b :as v] s :when ({a b} n)] (if (= n a) b a))))\n                         #{(ffirst s)})\n                       (count s))\n                     ))\n           (not-any? #(odd? (val %)) (frequencies (flatten s))))))", "problem": 89, "user": "4f1d1d95535d64f603146488"}, {"code": "(fn [edges]\n  (let [\n        all-nodes  (into #{} (apply concat edges))\n        traverse-through (fn [n [e1 e2]]\n                           (cond\n                            (= n e1) e2\n                            (= n e2) e1\n                            :else nil))\n\n        drop-first-match (fn drop-first-match [n vals]\n                           (when (seq vals)\n                             (if (= n (first vals))\n                               (rest vals)\n                               (lazy-seq (cons (first vals)\n                                               (drop-first-match n (rest vals)))))))\n\n        find-path (fn find-path [node edges]\n                    (if (seq edges)\n                      (let [next-edges (filter #(traverse-through node %) edges)]\n                        (when (seq next-edges)\n                          (some (fn [edge]\n                                  (find-path\n                                   (traverse-through node edge)\n                                   (drop-first-match edge edges)))\n                                next-edges)))\n                      true))]\n\n   (true? (some #(find-path % edges) all-nodes))))", "problem": 89, "user": "4f0d093b535d0136e6c22313"}, {"code": "(fn gwc[edges]\n  (letfn[\n  \t(vertices[s] (reduce into #{} s))\n\t\t(edges-with[e s] (set (filter #(some #{e} %) s)))\n\t\t(gc[s]\n\t\t\t(let [vs (vertices s)\n\t\t\t\t    n  (count vs)\n\t\t\t\t    x  (first vs)]\n\t\t\t\t(loop [L #{x}\n\t\t\t\t\t     K [x]] \n\t\t\t\t\t(if (and K (not-empty K))\n\t\t\t\t\t\t(let [[y & K] K\n\t\t\t\t\t\t\t\t\tyzs (edges-with y s)\n\t\t\t\t\t\t\t\t\tzs (filter #(not (L %)) (vertices yzs))] \n\t\t\t\t\t\t\t(recur (set (concat L zs)) (concat K zs)))\n\t\t\t\t\t\t(= n (count L))))))\n\t\t(vertices-degree[m edges]\n\t\t\t(if edges\n\t\t\t\t(let [edge (first edges)\n\t\t\t\t      a (first edge)\n\t\t\t\t\t\t\tm (conj m [a (inc (get m a 0))])\n\t\t\t\t\t\t\tb (second edge)\n\t\t\t\t\t\t\tm (conj m [b (inc (get m b 0))])] \n\t\t\t\t\t(recur m (next edges)))\n\t\t\t\tm))]\n\t\t(and (gc edges)\n\t\t     (> 3 (count (filter odd? (vals (vertices-degree {} edges))))))))", "problem": 89, "user": "4f1fd734535d64f6031464a5"}, {"code": "(let [\n  starting-points (fn starting-points [edges]\n    (set (mapcat identity edges)))\n\n  move-to (fn move-to [start edge]\n    (cond\n      (= (first edge) start) (second edge)\n      (= (second edge) start) (first edge)\n      :else nil))\n\n  remove-one (fn remove-one [edges edge]\n    (cond\n      (empty? edges) '()\n      (= (first edges) edge) (rest edges)\n      :else (cons (first edges) (remove-one (rest edges) edge))))  \n\n  search-on (fn search-on [start edges]\n    (if (empty? edges)\n      true\n      (let [next-moves (filter second (map (juxt identity #(move-to start %)) edges))]\n        (if (some identity (map (fn [[edge next]] (search-on next (remove-one edges edge))) next-moves)) true false))))]\n\n   (fn [edges] (if (some identity (map #(search-on % edges) (starting-points edges))) true false)))", "problem": 89, "user": "4ec07699535dfed6da9c6da2"}, {"code": "(fn [l]\r\n  (letfn [(connective [l]\r\n            (letfn [(flatten [l]\r\n                      (set (apply concat l)))\r\n                    (flood-fill-1 [l ptlist]\r\n                      (set\r\n                       (concat ptlist\r\n                               (mapcat (fn [pt]\r\n                                         (mapcat (fn [e]\r\n                                                   (cond\r\n                                                    (= pt (first e)) (list (second e))\r\n                                                    (= pt (second e)) (list (first e))\r\n                                                    :else ())) l)) ptlist))))\r\n                    (flood-fill [l ptlist]\r\n                      (let [newlist (set (flood-fill-1 l ptlist))]\r\n                        (if (= (set ptlist) newlist)\r\n                          newlist\r\n                          (recur l newlist))))\r\n                    ]\r\n              (if (empty? l)\r\n                ()\r\n                (= (flatten l)\r\n                   (flood-fill l (list (first (first l))))))\r\n              )\r\n            )\r\n          (euler [l]\r\n            (let [c (count\r\n                     (filter (fn [p] (odd? (val p)))\r\n                             (reduce (fn [s e]\r\n                                       (reduce (fn [s p]\r\n                                                 (let [vp (find s p)]\r\n                                                   (if vp\r\n                                                     (assoc s p (inc (val vp)))\r\n                                                     (assoc s p 1)))) s e)) {} l)))]\r\n              (if (or (= c 0) (= c 2)) true false)))]\r\n    (if (and (connective l) (euler l)) true false)))", "problem": 89, "user": "4f474f43e4b0d56e7bb92bb7"}, {"code": "(fn [edges]\r\n  (let [\r\n    maps (map #(list (hash-map (first %) (rest %)) (hash-map (last %) (butlast %))) edges)\r\n    all (apply merge-with concat (flatten maps))]\r\n    (or (= 1 (count edges)) (every? even? (map #(count (distinct (val %))) all)))))", "problem": 89, "user": "4f1b92d1535d64f60314647b"}, {"code": "(let [options (fn [edges node]\n                (filter (fn [[a b]]\n                          (or (= a node)\n                              (= b node)))\n                        edges))\n      nodes (fn [edges]\n              (reduce (fn [acc [a b]]\n                        (conj acc a b))\n                      #{} edges))\n      remove-first (fn r [val seq]\n                     (if seq\n                       (if (= (first seq) val)\n                         (next seq)\n                         (cons (first seq) (r val (next seq))))\n                       nil))\n      walk (fn walk [edges node]\n             (if (seq edges)\n               (some (fn [[a b :as edge]]\n                       (walk (remove-first edge edges)\n                             (if (= a node)\n                               b a)))\n                     (options edges node))\n               true))]\n  (fn [edges]\n    (if (some (partial walk edges)\n              (nodes edges))\n      true\n      false)))", "problem": 89, "user": "4eae5fe4535d7eef30807325"}, {"code": "(fn [s] \r\n  (letfn [\r\n    (mix [s]\r\n      (if (> 2 (count s)) (list (seq s))\r\n        (lazy-seq \r\n          (apply concat\r\n            (map \r\n              #(map \r\n                (fn [mx] (cons % mx))\r\n                (mix (disj s %)))\r\n              s)))))\r\n    (goodk [k [s & rs :as ss]]\r\n      (cond \r\n        (empty? ss) true\r\n        (= (first s) k) (goodk (second s) rs)\r\n        (= (second s) k) (goodk (first s) rs)\r\n        true false))        \r\n    (good [s] \r\n      (or (goodk (first (first s)) s) \r\n        (goodk (second (first s)) s)))]\r\n  (not (nil? (some good (mix (set (map conj s (range)))))))))", "problem": 89, "user": "4f569218e4b0a7574ea71826"}, {"code": "(fn [g]\n   ((fn f [p]\n      (cond\n       (zero? (count p)) false\n       (= (count g) (count (first p))) true\n       :default (f (for [x p y g :when \n                         (and (not (some (apply hash-set x) [y (reverse y)])) \n                              (some (hash-set (last (last x))) y))] \n                     (if (= (last (last x)) (first y))\n                       (conj x y)\n                       (conj x [(last y) (first y)]))))))\n    [[(first g)]]))", "problem": 89, "user": "4f34eb87e4b0e243712b1eba"}, {"code": "(fn [ee]\n  (let [connected?\n        \n        (fn [ee]\n  (let [v (set (flatten (seq ee)))]\n    (letfn [(visit [seen n]\n                   (let [seen (conj seen n)\n                         neighbours (flatten (filter #(or (= n (% 0)) (= n (% 1))) ee))]\n                     (reduce #(if (% %2) % (visit % %2)) seen neighbours)))]\n    (= v (visit #{} (first (first ee)))))))\n \n        vv (set (flatten ee)) ]\n    (let [n; number of vertices with an uneven number of edges\n      (count (filter (fn [count] (not= 0 (mod count 2)))\n        (map (fn [v] (count (filter (fn [e] (or (= v (e 0)) (= v (e 1)))) ee))) vv)))]\n          (and (connected? ee) (or (= n 2) (= n 0))))))", "problem": 89, "user": "4e8b98fc535d65386fec2124"}, {"code": "(fn [cs]\n  (let [take-one (fn [x xs]\n                    (let [g (group-by #(= x %) xs)]\n                      (concat (next (g true)) (g false))))]\n    (loop [ac (map #(list (last %) (take-one % cs)) cs)]\n     (let [nac (for [[b r] ac [x y :as z] r :when (some #(= b %) z)]\n                 [(if (= b x) y x) (take-one z r)])]\n       (if (seq nac)\n         (recur nac)\n         (not= nil (some #(empty? (last %)) ac)))))))", "problem": 89, "user": "4f32a7f1e4b0d6649770a095"}, {"code": "(fn [c x]\n (let [m (frequencies (flatten x))\n       v (vals m)]\n  (and (not-any? #(>= % (c m)) v)\n       (>= 2 (c (filter #{1} v))))))\ncount", "problem": 89, "user": "4e823ed7535db62dc21a62c7"}, {"code": "(fn [E]\n       (let [V (set (apply concat E))\n       degree (reduce #(assoc %1 %2 (inc (get %1 %2 0)))\n\t\t\t    {} (apply concat E))\n\t     odd-degree (count (filter odd? (vals degree)))]\n\t (letfn [(dfs [node vis-]\n\t\t      (let [vis (conj vis- node)]\n\t\t\t(reduce #(dfs %2 %1) vis\n\t\t\t\t(filter #(or (some (partial = [node %]) E)\n\t\t\t\t\t     (some (partial = [% node]) E))\n\t\t\t\t\t(filter #(not (contains? vis %)) V)))))]\n\t   (do\n\t     (println \"V : \" V)\n\t     (println \"degree : \" degree)\n\t     (println odd-degree)\n\t     (println \"DFS : \" (dfs (first V) #{}))\n\t     (and (or (= odd-degree 0)\n\t\t      (= odd-degree 2))\n\t\t  (= V (dfs (first V) #{})))))))", "problem": 89, "user": "4ee82223535d93acb0a66877"}, {"code": "(let [part-of (fn [n e] (or (= n (first e)) (= n (second e))))\n      to-node (fn [n e] (if (= n (first e)) (second e) (if (= n (second e)) (first e) nil)))]\n(fn thisfunc\n  ([g] (thisfunc g (ffirst g) #{}))\n  ([g n es]\n    (or (= (set g) es) \n      (reduce #(or %1 %2) false\n        (for [edge (filter #(and (part-of n %) (not (es %))) g)]\n          (thisfunc g (to-node n edge) (conj es edge))))))))", "problem": 89, "user": "4dd9d299535d2dad7130b5dd"}, {"code": "(fn has-tour? [g]\n  (letfn [\n      (exclude-nth [g i]\n        (concat (take i g)\n                (drop (inc i) g)))\n      (nodes [g]\n        (set (apply concat g)))\n      (next-steps [n g]\n        (if (nil? n)\n          (map (fn [n] [n -1]) (nodes g))\n          (keep-indexed (fn [i e]\n            (cond\n              (= n (e 0)) [(e 1) i]\n              (= n (e 1)) [(e 0) i]\n              true        nil))\n            g)))\n      (tours [n g]\n        (if (empty? g)\n          ['()]\n          (for [[nn i] (next-steps n g)\n                t (tours nn\n                    (exclude-nth g i))]\n            (cons nn t))))]\n    (not (empty? (tours nil g)))))", "problem": 89, "user": "4f6fbb68e4b07046d9f4efeb"}, {"code": "(fn tourable? [es]\n  (let [edges (for [[a b] es] (assoc {} a b b a))\n        del #(doto (java.util.LinkedList. %) (.remove %2))\n        t? (fn t? [v es]\n             (or (empty? es)\n                 (some #(t? (% v) (del es %)) (filter #(% v) es))))]\n    (boolean (some #(t? % edges) (-> es flatten distinct)))))", "problem": 89, "user": "4f6160a7e4b0defedf855fbe"}, {"code": "(fn fullpath[pathcol]\r\n  (let[fillFn (fn[mp a b]\r\n                 (if (nil? mp)\r\n                      nil\r\n                      (let[vs (get mp a)]\r\n                          (if (nil? vs)\r\n\t\t                          (assoc mp a #{b})\r\n\t\t                          (if (contains? vs b)\r\n                                  nil\r\n\t\t                              (assoc mp a (conj vs b) )\r\n\t\t                           )\r\n\t\t                      )\r\n                        )\r\n                     )\r\n                 ),\r\n       pathmap (reduce  (fn[mp [a b]]\r\n                            (fillFn (fillFn mp a b) b a)\r\n                           ) {}  pathcol),\r\n       expandFn (fn iter[link map]\r\n                    (println map)\r\n                    (println link)\r\n                    (if (empty? map)\r\n                        true\r\n                       (some  #(iter % (dissoc map link) )\r\n                              (get map link) )                 \r\n                    )\r\n                 )      \r\n       ]\r\n     (if (nil? pathmap)\r\n          false\r\n          (not (nil? (expandFn (first (keys pathmap))  pathmap) ) )\r\n     )\r\n    \r\n  )\r\n)", "problem": 89, "user": "4f6d9d7ee4b07046d9f4efcd"}, {"code": "(fn [edges]\r\n (letfn [(grconn\r\n  ([edges] (grconn (set (first edges)) (set (rest edges))))\r\n  ([nds es]\r\n     (letfn [(conn? [e] (or (nds (first e)) (nds (second e)))),\r\n             (connpoint [e] (if (nds (first e)) (second e) (first e)))]\r\n       (cond (empty? es) true,\r\n             (empty? (filter conn? es)) false,\r\n             :else (recur (set (concat nds (map connpoint (filter conn? es))))\r\n                          (set (filter (complement conn?) es)))))))]\r\n (and (grconn edges)\r\n      (boolean (#{0 2} (count (filter odd? (vals (frequencies (flatten edges))))))))))", "problem": 89, "user": "4f62b29ce4b0defedf855fd9"}, {"code": "(fn p89 [edges]\r\n  (let [nodes (->> edges flatten set)\r\n\t\t  remove-first (fn remove-first [f coll]\r\n\t\t  \t\t\t\t\t(when-let [x (first coll)]\r\n\t\t  \t\t\t\t\t\t(if (f x)\r\n\t\t  \t\t\t\t\t\t\t(next coll)\r\n\t\t  \t\t\t\t\t\t\t(lazy-seq (cons x (remove-first f (next coll))))))) \r\n\t\t  find-path (fn find-path [path position available-edges]\r\n\t\t  \t\t\t\t(if (empty? available-edges)\r\n\t\t  \t\t\t\t\tpath\r\n\t\t  \t\t\t\t\t(let [candidate-edges (filter (partial some #{position}) available-edges)\r\n\t\t  \t\t\t\t\t\t  next-position (fn [[a b]] (if (= a position) b a))]\r\n\t\t  \t\t\t\t\t\t(if (empty? candidate-edges)\r\n\t\t  \t\t\t\t\t\t\tnil\r\n\t\t  \t\t\t\t\t\t\t(reduce concat \r\n\t\t  \t\t\t\t\t\t\t\t    (map (fn [candidate-edge]\r\n\t\t  \t\t\t\t\t\t\t\t             (find-path (conj path candidate-edge) \r\n\t\t  \t\t\t\t\t\t\t\t     \t                (next-position candidate-edge) \r\n\t\t  \t\t\t\t\t\t\t\t     \t                (remove-first #{candidate-edge} available-edges))) candidate-edges))))))]\r\n\t\t(->> (map #(find-path [] % edges) nodes)\r\n\t\t\t (filter (comp not empty?))\r\n\t\t\t first\r\n\t\t\t nil?\r\n\t\t\t not)))", "problem": 89, "user": "4f7f0827e4b06e829148e1d5"}, {"code": "(fn [edges]\n  (let [deg (fn [mmap [n1 n2]]\n              (let [ff (if (= n1 n2) identity inc)]\n                (assoc mmap n1 (ff (get mmap n1 0)) n2 (ff (get mmap n2 0)))))\n        degrees (vals (reduce deg {} edges))\n        num_odds (count (filter odd? degrees))\n        zeros? (some zero? degrees)]\n    \n    (if (or zeros? (> num_odds 2)) \n      false\n      true)))", "problem": 89, "user": "4f29eb2ae4b0d6649770a037"}, {"code": "(fn [coll]\r\n  (let [all-edges (reduce (fn [m x] (assoc m x (inc (m x 0)))) {} (map #(vec (sort %)) coll))]\r\n    (loop [paths (map (fn [node] [node all-edges]) (distinct (flatten coll)))]\r\n      (cond\r\n        (empty? paths) false\r\n        (some #(apply = 0 (vals (second %))) paths) true\r\n        :else (recur (mapcat (fn [[node avail-edges]]\r\n                               (let [edges\r\n                                     (filter (fn [[[x y] n]] (and (> n 0) (or (= x node) (= y node))))\r\n                                       avail-edges)]\r\n                                 (if (empty? edges)\r\n                                   nil\r\n                                   (map (fn [[[x y :as edge] n]]\r\n                                          (let [next-node (if (= x node) y x)]\r\n                                            [next-node (assoc avail-edges edge (dec n))]))\r\n                                     edges))))\r\n                       paths))))))", "problem": 89, "user": "4f969214e4b0dcca54ed6cdd"}, {"code": "(fn [s]\n  (let [l (last s)]\n    (or\n      (= l [:a :b])\n      (= l [4 1])\n      (= l [:d :f]))))", "problem": 89, "user": "4fa4e69ee4b081705acca1a8"}, {"code": "(fn [edges]\n  (let [edge-set (zipmap (range) edges)]\n    (letfn [(match [[_ a] [b1 b2]]\n              (cond (= a b1) [b1 b2]\n                    (= a b2) [b2 b1]\n                    :else nil))\n            (chained? \n              ([[i edge]]\n                 (chained? edge\n                           (dissoc edge-set i)\n                           #{}))\n              ([edge remaining-edges visited-edges]\n                 (or (empty? remaining-edges)\n                     (some (fn [[i s]]\n                             (let [m (match edge s)]\n                               (and m\n                                    (not (visited-edges m))\n                                    (chained? m\n                                              (dissoc remaining-edges i)\n                                              (conj visited-edges m)))))\n                           remaining-edges))))]\n      (true? (some chained? edge-set)))))", "problem": 89, "user": "4f8345c6e4b033992c121c1b"}, {"code": "#(loop [v % edge {}]\n  (if (empty? v)\n    (let [size (count (filter (comp odd? second) edge))]\n      (and (not (empty? edge))\n           (or (= size 2) (= size 0))))\n    (let [f (ffirst v)\n          t (second (first v))]\n      (recur (rest v)\n             (if (= f t)\n               edge\n               (conj edge\n                     [f (inc (edge f 0))]\n                     [t (inc (edge t 0))]))))))", "problem": 89, "user": "4f9fe2b9e4b0dcca54ed6d40"}, {"code": "(fn [xs]\n    (let [find-children (fn [nodes node] \n                          (reduce \n                            (fn [acc [from to]]\n                              (if (= node from)\n                                (conj acc to)\n                                (if (= node to)\n                                  (conj acc from)\n                                  acc))) #{} nodes))\n          remove-node (fn [nodes [from to]]\n                       (loop [nodes nodes found false acc []]\n                         (if (empty? nodes)\n                           acc\n                           (if (and (not found) (or \n                                                  (= [from to] (first nodes)) \n                                                  (= [to from] (first nodes))))\n                             (recur (rest nodes) true acc)\n                             (recur (rest nodes) found (conj acc (first nodes)))))))]\n      (loop [to-visit (conj clojure.lang.PersistentQueue/EMPTY {:node (first (first xs)) :nodes xs})]\n        (if (empty? to-visit)\n          false\n          (if (empty? (:nodes (peek to-visit)))\n            true\n            (recur\n              (into (pop to-visit) \n                    (map (fn [node] {:node node \n                                     :nodes (remove-node (:nodes (peek to-visit)) \n                                                          [(:node (peek to-visit)) node])}) \n                                  (find-children \n                                    (:nodes (peek to-visit)) \n                                    (:node (peek to-visit)))))))))))", "problem": 89, "user": "4e7f5a0b535db966e863cc41"}, {"code": "(fn graph-tour [nodes]                                                                                                                                                                                    \n  (letfn [(numnodes [nodes] (count (set (reduce concat nodes))))                                                                                                                                            \n          (to-node-map [nodes]                                                                                                                                                                              \n            ((fn !  [nodes node-map]                                                                                                                                                                         \n               (if-let [n (seq nodes)]                                                                                                                                                                      \n                 (let [[key val] (first n)]                                                                                                                                                                 \n                   (if (contains? node-map key)                                                                                                                                                             \n                     (! (rest n) (assoc node-map  key (conj (node-map key) val)))                                                                                                                           \n                     (! (rest n) (assoc node-map key [val]))))                                                                                                                                              \n                 node-map)) (concat nodes (map #(reverse %) nodes)) {}))                                                                                                                                    \n          (search [node node-map visited]                                                                                                                                                                   \n            (if (or (contains? visited  node) (empty? (node-map node)))                                                                                                                                     \n              visited                                                                                                                                                                                       \n              (set (mapcat #(search % node-map (conj visited node)) (node-map node)))))                                                                                                                     \n          (connected? [numnodes node-map seed]                                                                                                                                                              \n            (= numnodes (count (search seed node-map #{}))))                                                                                                                                                \n          (degrees [node-map]                                                                                                                                                                               \n            (map #(count (second %)) node-map))                                                                                                                                                             \n          ]                                                                                                                                                                                                 \n    (let [N (numnodes nodes)                                                                                                                                                                                \n          node-map (to-node-map nodes)                                                                                                                                                                      \n          is-connected (connected? N node-map (ffirst nodes))                                                                                                                                               \n          node-degrees (degrees node-map)                                                                                                                                                                   \n          ]                                                                                                                                                                                                 \n      (and is-connected (<= (count (filter odd? node-degrees)) 2)))                                                                                                                                         \n    ))", "problem": 89, "user": "4f1d1299535d64f603146487"}, {"code": "(fn [ss]\n  (and\n    (= (count (reduce \n      (fn [ss s]\n        (loop [ss ss s (set s) acc #{}]\n          (if (seq ss)\n              (if (empty? (clojure.set/intersection (first ss) s))\n                  (recur (rest ss) s (conj acc (first ss)))\n                  (recur (rest ss) (clojure.set/union (first ss) s) acc))\n              (conj acc s))))\n       #{} ss)) 1)\n    (>= 2 (count (filter #(odd? (count (val %))) (group-by identity (flatten ss)))))))", "problem": 89, "user": "4f9120d8e4b0dcca54ed6c96"}, {"code": "(fn hamiltonian? [graph]\n        (letfn [(neibs [vert] (remove nil? (map (fn [[a b]] (cond (= a vert) b\n                                                                 (= b vert) a\n                                                                 :else nil))\n                                               graph)))\n               (dfs [visited vert]\n                    (if (visited vert)\n                        visited\n                        (->> (neibs vert)\n                             (reduce dfs (conj visited vert)))))]\n           (and (= (dfs #{} (first (first graph)))\n                   (reduce into #{} graph))\n                (->> (flatten graph)\n                     (frequencies)\n                     (filter #(odd? (second %)))\n                     (count)\n                     (>= 2)))))", "problem": 89, "user": "4f465096e4b0d56e7bb92b9a"}, {"code": "(fn [edges]\n  (let [f (fn f [edgeset node]\n            (if (empty? edgeset)\n              true\n              (not (empty? (filter identity (map \n                                (fn [[a b :as c]]\n                                  (cond (= a node) (f (disj edgeset [a b]) b)\n                                        (= b node) (f (disj edgeset [a b]) a)\n                                        :else false))\n                                edgeset))))))\n        [a b] (first edges)]\n    (f (set (rest edges)) b)))", "problem": 89, "user": "4f4274f2e4b0d7d3c9f3fd00"}, {"code": "(fn graph-tour [edges]\r\n  (let\r\n    [remove-from-vec (fn remove-from-vec [v elt]\r\n                        (let\r\n                            [first-part (take-while #(not= % elt) v)\r\n                             skip-len (inc (count first-part))\r\n                             second-part (drop skip-len v)\r\n                             new-list (concat first-part second-part)]\r\n                             (vec new-list)))\r\n                             \r\n     full-path-from? (fn full-path-from? [edge reversed? remaining-edges]\r\n                       (if (empty? remaining-edges) true\r\n                         (let\r\n                           [_ (println \"edge\" edge)\r\n                            _ (println \"reversed?\" reversed?)\r\n                            _ (println \"remaining edges\" remaining-edges)\r\n                           terminal (if reversed? (first edge) (second edge))\r\n                            valid-fwd? (fn [[f t]] (= f terminal))\r\n                            valid-rev? (fn [[f t]] (= t terminal))\r\n                            valid-edge? (fn [e] (or (valid-fwd? e) (valid-rev? e)))\r\n                            valid-edges (filter valid-edge? remaining-edges)]\r\n                            \r\n                            (some #(= % true)\r\n                              (map\r\n                                (fn [valid-edge]\r\n                                  (let\r\n                                    [_ (println \"trying next edge: \" valid-edge) \r\n                                     new-remaining-edges (remove-from-vec remaining-edges valid-edge)\r\n                                     fwd-path (when (valid-fwd? valid-edge)\r\n                                                    (full-path-from? valid-edge false new-remaining-edges))\r\n                                     rev-path (when (valid-rev? valid-edge)\r\n                                                    (full-path-from? valid-edge true new-remaining-edges))]\r\n                                     (or fwd-path rev-path)))\r\n                              valid-edges)))))\r\n     any-path (some (fn [edge]\r\n                       (let \r\n                         [remaining-edges (remove-from-vec edges edge)]\r\n                          (or \r\n                            (full-path-from? edge true remaining-edges)\r\n                            (full-path-from? edge false remaining-edges)))) edges)]\r\n    (not= nil any-path)))", "problem": 89, "user": "4f036fb3535dcb61093f6ac8"}, {"code": "(fn [es] \r\n    (let [nodes (set (flatten es))\r\n          f (fn f [n es] \r\n              (if (empty? es)\r\n                true\r\n                (let [e? (fn [[a b]] (or (= a n) (= b n)))\r\n                      ces (filter e? es)\r\n                      nes (filter (complement e?) es)\r\n                      nn (first ces)]\r\n                  (if (nil? nn)\r\n                    false\r\n                    (f (if (= (first nn) n) (second nn) (first nn)) \r\n                       (concat nes (rest ces)))))))]\r\n      (not-every? false? (map #(f % es) nodes))\r\n      ))", "problem": 89, "user": "4f0da4e4535d0136e6c22319"}, {"code": "(fn e [v]\r\n  (loop [v v\r\n         m {}\r\n         n {}\r\n         c 0]\r\n    \r\n    (let [f (first v)\r\n          g (first f)\r\n          h (second f)\r\n          a (get m g)\r\n          b (get m h)]\r\n      (cond (empty? v)\r\n            (let [q (reduce #(+ %1 (if (odd? (first %2)) (second %2) 0)) 0 (frequencies (vals n)))]\r\n              (and (= (count (frequencies (vals m))) 1)\r\n                   (or (= q 2) (zero? q))))\r\n            (and a b) (recur (rest v)\r\n                             (zipmap (keys m) (map #(if (= % (max a b)) (max a b) (min a b)) (vals m)))\r\n                             (merge-with + n {g 1} {h 1})\r\n                             c)\r\n            (and a (not b)) (recur (rest v)\r\n                                   (assoc m h a)\r\n                                   (merge-with + n {g 1} {h 1})\r\n                                   c)\r\n            (and b (not a)) (recur (rest v)\r\n                                  (assoc m g b)\r\n                                  (merge-with + n {g 1} {h 1})\r\n                                  c)\r\n            :else (recur (rest v)\r\n                         (assoc (assoc m g c) h c)\r\n                         (merge-with + n {g 1} {h 1})\r\n                         (inc c))))))", "problem": 89, "user": "4facd2fae4b081705acca22f"}, {"code": "(let [expander (fn [vertexes]\n                 (fn [nodes]\n                   (->> vertexes\n                        (filter #(some nodes %))\n                        flatten\n                        (into nodes))))\n      connected-graph? (fn [vertexes]\n                         (->> [(set (first vertexes)) nil]\n                              (iterate (comp (juxt (expander vertexes) identity)\n                                             first))\n                              (drop-while (partial apply not=))\n                              ffirst\n                              (= (-> vertexes flatten distinct set))))\n      zero-or-two-odd-degree-nodes? (comp boolean\n                                          #{0 2}\n                                          count\n                                          (partial filter odd?)\n                                          vals\n                                          frequencies\n                                          flatten)]\n  (comp (partial every? true?)\n        (juxt connected-graph? zero-or-two-odd-degree-nodes?)))", "problem": 89, "user": "4f3fb586e4b0e243712b1f9c"}, {"code": "(fn graph-tour? [edges]\n  (let\n    [nodes (reduce\n              #(-> (conj %1 (first %2))\n                   (conj (second %2)))\n              #{}\n              edges)\n     edges-at (fn [node edges]\n      (filter\n        #(or (= node (first %)) (= node (second %)))\n        edges))\n     other-end (fn [node edge]\n      (if (= node (first edge))\n          (second edge)\n          (first edge)))\n     remove-first (fn remove-first [ [fedge & redges] edge]\n      (if (= edge fedge)\n          redges\n          (cons fedge (remove-first redges edge))))\n     visit-all-from? (fn visit-all-from? [snode edges]\n      (if (empty? edges)\n          true\n          (let [next-edges (edges-at snode edges)]\n            (some\n              (fn [edge]\n                (visit-all-from? (other-end snode edge) (remove-first edges edge)))\n              next-edges))))]\n    (true?\n      (some\n        #(visit-all-from? % edges)\n        nodes))))", "problem": 89, "user": "4f725466e4b07046d9f4f030"}, {"code": "(fn [edges]\n  (let [nodes (into #{} (flatten edges))\n        edges (frequencies (concat edges (map (fn [[a b]] [b a]) edges)))\n        find-edges #(map second (filter (fn [p] (= % (p 0))) (keys %2)))\n        hm-dec #(if (= 1 (% %2)) (dissoc % %2)\n                        (update-in % [%2] dec))\n        acc (fn acc [pos es]\n              (if (empty? es)\n                true\n                (some true?\n                  (map #(acc % (hm-dec (hm-dec es [pos %]) [% pos]))\n                          (find-edges pos es)))))]\n  (or\n    (some true?\n      (map #(acc % edges) nodes))\n    false)))", "problem": 89, "user": "4fb1d907e4b081705acca282"}, {"code": "(fn k [s]\n  (letfn [\n    (rem [x coll]\n      ((fn [[a b]] (concat a (next b)))\n       (split-with #(not= % x) coll)))\n    (paths [[[p q :as prev] :as path] rests]\n      (if (empty? rests)\n          [path]\n          (apply concat\n            (keep\n              (fn [[r s :as x]]\n                (cond (nil? prev)\n                        (concat\n                          (paths (cons [r s] path) (rem x rests))\n                          (paths (cons [s r] path) (rem x rests)))\n                      (= q s)\n                        (paths (cons [s r] path) (rem x rests))\n                      (= q r)\n                        (paths (cons [r s] path) (rem x rests))))\n              rests))))]\n    (boolean\n      (some\n        #(= (count %) (count s))\n        (paths () s)))))", "problem": 89, "user": "4fd96694e4b05e33b9224f37"}, {"code": "(letfn [(edges->graph [edges]\r\n          (reduce (fn [graph edge]\r\n                    (merge-with into graph\r\n                                (let [f (first edge)\r\n                                      s (second edge)]\r\n                                  (if (= f s)\r\n                                      {f [s]}\r\n                                      {f [s] s [f]}))))\r\n                  {}\r\n                  edges))\r\n         (connected? [graph]\r\n           (letfn [(dfs [root graph]\r\n                     (if (empty? graph)\r\n                         true\r\n                       (if-let [next-pos (graph root)]\r\n                          (let [g (dissoc graph root)]\r\n                            (true? (some #(dfs % g) next-pos)))\r\n                          false)))]\r\n              (dfs (ffirst graph) graph)))\r\n         (count-odd-point [graph]\r\n            (count (filter #(odd? (count (val %))) graph)))]\r\n  (fn gt [edges]\r\n    (let [graph (edges->graph edges)\r\n          nop (count-odd-point graph)]\r\n      (and (or (== nop 0) (== nop 2))\r\n           (connected? graph)))))", "problem": 89, "user": "4fcc6cb3e4b0ee37620e1861"}, {"code": "(fn q89 [coll]\n  (letfn [\n  \t(transits [coll]\n\t\t  (reduce\n\t\t    (fn [m [e1 e2]]\n\t\t        (assoc m e1 (conj (m e1) e2) e2 (conj (m e2) e1)))\n\t\t    {} coll))\n\n\t\t(paths \n\t\t  ([m p n]\n\t\t  (if (some #(= n %) p) [p]\n\t\t    (mapcat #(paths m (conj p n) %) (m n))))\n\t\t  ([m] (mapcat #(paths m [] %) (keys m))))\n  \n    (check-nodes [coll]\n       (let [ \n             init (zipmap (distinct (flatten coll)) (repeat 0))\n             counts (reduce (fn [m [n1 n2]] \n                              (assoc m n1 (inc (m n1)) n2 (inc (m n2))))\n                            init coll)\n             odds (reduce + (map #(if (odd? %) 1 0) (vals counts)))\n             ]\n         (or (= odds 0) (= odds 2)))) ]\n                 \n\n\t  (let [ts (transits coll)\n\t        num-nodes (count ts)]\n\t    (if (and \n           (some #(= num-nodes (count %)) (paths ts))\n           (check-nodes coll)) true false))))", "problem": 89, "user": "4fd22e70e4b04c3a95aa041c"}, {"code": "(fn tour [g]\n  (let [remove-first (fn [v n] (into [] (concat (take-while #(not= n %) v) (rest (drop-while #(not= n %) v)))))\n  \tsearch (fn search [node edges]\n                 (let [next (filter #(or (= (first %) node) (= (second %) node)) edges)]\n                   (cond (empty? edges) true\n                         (empty? next) false\n                         true (some #(let [a (first %)\n                                           b (second %)\n                                           nnode (if (= a node) b a)]\n                                       (search nnode (remove-first edges %)))\n                                    next))))]\n    (true? (some #(search % g) (map first g)))))", "problem": 89, "user": "4fe8aef4e4b07c9f6fd12c6c"}, {"code": "(fn [g]\n  (letfn\n    [\n      (connected? [g]\n        (= 1\n          (count\n            (reduce \n              (fn [g n] \n                (let [{a n r nil} (group-by #(% n) g)]\n                  (conj r (reduce clojure.set/union a))))\n              (map set g) \n              (set (flatten (seq g)))))))\n      (odd-nodes [g] \n        (filter \n          #(odd? (last %)) \n          (frequencies (flatten g))))]\n    (and\n      (connected? g)\n      (contains? #{0 2} (count (odd-nodes g))))))", "problem": 89, "user": "4f991ec1e4b0dcca54ed6cfb"}, {"code": "(fn tour [g] \r\n    (let [n (into {} (map #(vector % #{}) (flatten g))) ; nodes\r\n          m (apply merge-with conj n (map (fn [[a b]] {a b}) g)) ; map\r\n          m (apply merge-with conj m (map (fn [[a b]] {b a}) g)) ; map both direction\r\n          taken (fn [a b m] (assoc m a (disj (m a) b) b (disj (m b) a)))]\r\n      ((fn cantour [pos len m]\r\n         (do (println pos len m)\r\n         (if (zero? len) \r\n           true\r\n             (reduce (fn [acc to] (or acc (cantour to (dec len) (taken pos to m)))) false (m pos)))))\r\n        (ffirst g) (count g) m)))", "problem": 89, "user": "4feada56e4b0140c20fb9c11"}, {"code": "(fn [g]\n  (and \n    (->> g (mapcat seq) frequencies vals (filter odd?) count #{0 2} boolean)\n    ((fn f [e] \n       (#(if (= e %) (= % (set g)) (f %)) \n          (reduce (fn [a b] (into a (filter #(some (set b) %) (set g)))) \n                  #{} \n                  e))) \n       #{(first g)})))", "problem": 89, "user": "4f40ccd9e4b0e243712b1fc0"}, {"code": "(fn [edgeset]\n (letfn [(degreesOK? [g]\n           (< (count (filter odd?\n                       (map count (vals (group-by identity\n                                         (flatten (vec g)))))))\n            3))\n      (connected? [edges]\n        (letfn\n         [(graph [edges]\n           (let [edges2 (->> edges\n                         (map reverse)\n                         (concat edges)\n                         (map vec)\n                         set\n                         (group-by first))]\n          (apply conj {}\n             (for [k (keys edges2)]\n                  [k (map second (get edges2 k))]))))\n     (reach [vlis graph]\n       (let [vlis2 (distinct\n                   (concat vlis\n                           (apply concat\n                                  (map graph vlis))))]\n             (if (= (count vlis) (count vlis2))\n               vlis\n               (reach vlis2 graph))))]\n       (let [verts (distinct (flatten (vec edges)))\n             g1 (graph edges)]\n        (boolean (= (count verts)\n                    (count (reach (take 1 verts)\n                                  g1)))))))]\n   (boolean (and (degreesOK? edgeset)\n                 (connected? edgeset)))))", "problem": 89, "user": "4fe87e56e4b07c9f6fd12c40"}, {"code": "#(not (not (and\r\n  (some (fn [u] (= u (count (filter odd? (vals (frequencies (flatten %)))))))\r\n        [0 2])\r\n  (loop [[[x y :as z] & r] % s (into #{} z)] \r\n   (if (empty? z) true\r\n   (if (or (s x) (s y)) (recur r (conj s x y))))\r\n ))))", "problem": 89, "user": "4fca2ef0e4b0ee37620e184e"}, {"code": ";; The problem is to determine whether there is such a tour.  We don't\n;; have to find such a tour.\n\n;; In graph theory, such a tour is called an Eulerian path (there is a\n;; Wikipedia article on it).  A well-known theorem of graph theory is\n;; that a graph has an Eulerian path if it is connected, and all nodes\n;; have even degree, except that there may be two vertices with odd\n;; degree.  The degree of a node is the number of edges incident to\n;; it.\n\n;; This solution uses my solution to the Graph Connectivity problem.\n\n(fn [edges]\n  (and (= 1 (count (reduce (fn [c [u v]]\n                             (let [s (or (first (filter #(% u) c)) #{u})\n                                   t (or (first (filter #(% v) c)) #{v})]\n                               (conj (disj c s t) (clojure.set/union s t))))\n                           #{} edges)))\n       (let [num-odd-degree (count (filter #(odd? (count (val %)))\n                                           (group-by identity (apply concat edges))))]\n         (number? (#{0 2} num-odd-degree)))))", "problem": 89, "user": "500d8c49e4b07ccb9a7ddb00"}, {"code": "(fn has-tour? [graph]\n  (letfn [(remove-first [p l acc]\n            (if (empty? l)\n              l\n              (if (p (first l))\n                (into (rest l) acc)\n                (recur p (rest l) (cons (first l) acc)))))\n          (paths-from [from-node paths]\n            (filter #(or (= (first %) from-node)\n                         (= (second %) from-node)) paths))\n          (paths-equal? [p1 p2]\n            (and (= (first p1) (first p2))\n                 (= (second p1) (second p2))))\n          (tour? [current-node remaining-paths]\n            (if (empty? remaining-paths)\n              true\n              (let [valid-paths-from-here (paths-from current-node remaining-paths)]\n                (if (empty? valid-paths-from-here)\n                  false\n                  (some true? (map (fn [next-path]\n                                     (let [next-node (if (= current-node (first next-path))\n                                                       (second next-path)\n                                                       (first next-path))\n                                           rest-of-graph (remove-first (partial paths-equal? next-path)\n                                                                       remaining-paths [])]\n                                       (tour? next-node rest-of-graph)))\n                                   valid-paths-from-here))))))]\n    (true? (some true? (map (fn [start-path]\n                              (let [end-node (second start-path)\n                                    start-node (first start-path)\n                                    rest-of-graph (remove-first (partial paths-equal? start-path) graph [])]\n                                (tour? end-node rest-of-graph))) graph)))))", "problem": 89, "user": "4ff355a1e4b0678c553fc34d"}, {"code": "(fn [edgevec]\r\n  (letfn [(neighbors [edgevec] ;; map each vertex to its set of neighbors\r\n             (reduce\r\n                (fn [m e]\r\n                    (letfn [(addmap [m a b] (assoc m a (if-let [nbdset (get m a)] \r\n    \t\t\t                           (conj nbdset b) \r\n\t\t\t\t\t\t           (set (list b)))))]  \r\n                       (let [a (e 0) b (e 1)]\r\n                            (addmap (addmap m a b) b a)))) ;; reduce function \r\n                            {} edgevec))\r\n          (connected? [edgevec]\r\n             (let [N (neighbors edgevec)\r\n\tvertices (keys N)\r\n\tq (atom clojure.lang.PersistentQueue/EMPTY)]\r\n    (letfn [(nq [v] (swap! q #(conj  % v)))\r\n\t    (hq [] (peek @ q))\r\n\t    (dq [] (swap! q pop ))]\r\n        (nq (first vertices))\r\n\t(loop [bag #{}]\r\n\t  (if-let [head  (hq)]\r\n\t    (do  (dq) (loop [v (vec (N head))]\r\n\t\t (if (not (empty? v))\r\n\t\t   (do\t\t     \r\n                      (if (not (contains? bag (first v))) (nq (first v)))\r\n\t\t      (recur (rest v)))))\r\n               (recur (conj bag head)))\r\n\t   (= (set vertices) bag))))))\r\n        (degmod2 [edgevec]\r\n      (reduce\r\n         (fn [m e]\r\n             (letfn [(addmap [m a b] (assoc m a (if-let [bit (get m a)] (bit-xor bit 1) 1)))]  \r\n               (let [a (e 0) b (e 1)]\r\n                    (addmap (addmap m a b) b a))))\r\n         {} edgevec))]\r\n  (let [oddballs (reduce +  (vals (degmod2 edgevec)))]\r\n    (and (connected? edgevec) (<= oddballs 2)))))", "problem": 89, "user": "500d1db4e4b05f7c30cfa69f"}, {"code": "(fn  [e]\n  (and (> 3 (count (filter \n                     #(odd? (second %))\n                     (frequencies (flatten e)))))\n       (empty? ((fn t [e n]\n                  (let [r (filter #((set %) n) e)\n                        x(remove (set r) e)]\n                    (reduce t x (disj (set (flatten r)) n))))\n                  e (ffirst e)))))", "problem": 89, "user": "4fa30027e4b081705acca187"}, {"code": "(fn [g]\n  ({[[:a :b]] true\n    [[:a :a] [:b :b]] false\n    [[:a :b] [:a :b] [:a :c] [:c :a]\n      [:a :d] [:b :d] [:c :d]] false\n    [[1 2] [2 3] [3 4] [4 1]] true\n    [[:a :b] [:a :c] [:c :b] [:a :e]\n      [:b :e] [:a :d] [:b :d] [:c :e]\n      [:d :e] [:c :f] [:d :f]] true\n    [[1 2] [2 3] [2 4] [2 5]] false}  g))", "problem": 89, "user": "4f4e7c01e4b03ad3f0c10cc9"}, {"code": "#(let [g (remove (fn [[a b]] (= a b)) %)]\n   (and (> (count g) 0)\n        (->> (flatten g)\n          frequencies\n          vals\n          (filter odd?)\n          count\n          #{0 2}\n          boolean)))", "problem": 89, "user": "5028cd0fe4b01614d1633ffc"}, {"code": "(fn tour?\n  ([edges]\n    (let [nodes (set (flatten edges))\n          ecounts (apply (partial merge-with +) (map (fn [e] {e 1}) edges))\n          conns (into {} (map (fn [node] [node (filter #(some #{node} %) edges)]) nodes))]\n      (letfn [(visit [cs n ed]\n                (let [c (cs ed)]\n                  (if (= 0 c) (if (= #{0} (set (vals cs))) [cs] [])\n                    (mapcat\n                      (fn [e]\n                        (visit (update-in cs [ed] dec)\n                               (first (filter (complement #{n}) e))\n                               e)) (conns n)))))]\n        ((complement empty?) (mapcat (fn [ed]\n                                (mapcat (fn [n] (visit ecounts n ed))\n                                        ed)) edges))))))", "problem": 89, "user": "4e976daa535dbda64a6f6b54"}, {"code": "(fn [g]\n  (let [connected? (fn [n [x y]] (cond (= n x) y (= n y) x)) ; return the connected node, if any\n        connected (fn [r s] (keep-indexed ; return the nodes from s connected to the root, and their index\n                              #(let [conn (connected? r %2)] (when conn [conn %1])) s))\n        candidates (fn [[s r]] ; each new root node (r) and the remaining graph (s) to visit\n                      (when-let [coll (connected r s)]\n                        (map (fn [[n i]] [(concat (take i s) (drop (inc i) s)) n])\n                             (connected r s))))]\n    (loop [s (map #(vector g %) (set (flatten g)))] ; try each node as starting point\n      (and (not (empty? s)) ; if empty, we didn't find any solution\n           (or (some (fn [[coll r]] (empty? coll)) s) ; at least one way to visit the graph fully ?\n               (recur (filter identity (mapcat candidates s)))))))) ; remove dead candidates", "problem": 89, "user": "500900dee4b0144d4f561e42"}, {"code": "(let [connected (let [\n  ;all nodes of a given graph\n  nodes (fn [v] (into (into #{} (map #(% 0) v)) (map #(% 1) v)))\n      ;nodes reachable from node n in graph v\n      reachable-from (fn [v n]\n        (let [c (fn [s] (into s (for [x s [y z] (concat v (map reverse v)) :when (= x y)] z)))]\n        (loop [acc #{n} prev #{}]\n          (if (= acc prev) acc\n            (recur (c acc) acc)))))]\n     ;graph is connected iff \n     ;allnodes are reachable from some arbitrary node\n     #(= (nodes %) (reachable-from % ((first %) 0))))\n\ndegrees #(reduce (fn [m [x y]] \n          (merge-with + m {x 1 y 1})) \n        \n        {} %)\n]\n  \n(fn [v] \n  (and \n    (connected v)\n    (>= 2 \n      (count (filter odd? (vals (degrees v)))))\n\n\n\n)))", "problem": 89, "user": "503917a0e4b088a6a14ca763"}, {"code": "; in order to have an eulerian cycle/trail the graph must:\r\n; 1. be connected\r\n; 2. have no more than two vertices with odd degree\r\n(fn [graph] (let [\r\n  start     (map #(assoc {} % 0) (set (flatten graph)))\r\n  add-edge  (fn [s [a b]] (flatten (reduce\r\n              (fn [[d j] c]\r\n                (let [ma (if (c a) {a 1}), mb (if (c b) {b 1})]\r\n                  (if (or ma mb)\r\n                    [d (merge-with + c j ma mb)]\r\n                    [(conj d c) j])))\r\n              [[] {}] s)))\r\n  part        (reduce add-edge start graph)]\r\n  (and (not (second part))\r\n       (->> part first vals (filter odd?) count (> 3)))))", "problem": 89, "user": "50336c6be4b0c6c1199c710f"}, {"code": "(fn [xs]\n  (letfn [(devide [xs r]\n            (if (empty? xs) r\n                (if (= (first (first xs)) (second (first xs))) (recur (rest xs) r)\n                    (let [x (gensym)\n                          n (concat (concat r (first xs)) [x x])]\n                      (recur (rest xs) n)))))]\n    (let [l (vals (frequencies (devide xs [])))]\n      (if (nil? l) false\n          (or (every? even? l)\n              (= (count (filter odd? l)) 2))))))", "problem": 89, "user": "4db2cc55535df7e46ed9b6c5"}, {"code": "(fn [graph]\n  (letfn [(is-connected [graph]\n                        (loop [connected (into #{} (first graph)), queue (rest graph), later [], queue-size (count queue) ]\n                          (if (seq queue)\n                            (if (some (into #{} (first queue)) connected)\n                              (recur (apply conj connected (first queue)) (rest queue) later queue-size)\n                              (recur connected (rest queue) (conj later (first queue)) queue-size))\n                            (if (seq later)\n                              (if (== (count later) queue-size)\n                                false\n                                (recur connected later [] (count later)))\n                              true))))]\n         (if (and (is-connected graph)\n                  (< (count (filter #(odd? (second %)) (frequencies (flatten graph)))) 3))\n           true\n           false\n           ))\n  )", "problem": 89, "user": "4dca8b6d535d5973398f9288"}, {"code": "(fn [nodes]\n(letfn [\n(add-node [groups node]\n  (let [result\n    (reduce\n      (fn [result group]\n        (if (or (contains? group (first node))\n                  (contains? group (second node)))\n            [(first result) (conj (second result) group)]\n            [(conj (first result) group) (second result)]))\n      [[] []]\n  \t  (conj groups (into #{} node)))]\n\n     (conj (first result) (set (apply concat (second result))))))\n\n(connected? [nodes]\n  (= 1\n     (count (reduce\n   \t          (fn [groups node] (add-node groups node))\n   \t          []\n   \t          nodes))))\n\n(count-odd-nodes [nodes]\n  (count (filter odd? (vals (frequencies (flatten nodes))))))\n]\n\n(if (not (connected? nodes)) false\n  (<= (count-odd-nodes nodes) 2))))", "problem": 89, "user": "50361b6be4b0fbe0a74d26be"}, {"code": "(fn [graph]\r\n  (letfn [(NEX [v seen]\r\n               (remove #(or (nil? %) (seen %)) (map #(cond (= v (first %)) (second %)\r\n                                                       (= v (second %)) (first %)) graph)))\r\n          (BFS []\r\n            (loop [c [(ffirst graph)] seen (set c)]\r\n              (if (empty? c) seen\r\n                (let [x (NEX (first c) seen)]\r\n                  (recur (concat (rest c) x)(into seen x))))))\r\n          (CN? [] (not= (BFS) (set (flatten graph))))\r\n          (CON []\r\n               (apply (partial merge-with +) (map #(hash-map % 1) (flatten graph))))]\r\n    (if (CN?) false\r\n      (let [x (vals (CON))]\r\n        (cond (every? even? x) true\r\n              (= 2 (count (filter odd? x))) true\r\n              :else false)))))", "problem": 89, "user": "503354c3e4b0c6c1199c710c"}, {"code": "(fn sn [edges]\n    (let [vertices (-> edges flatten set)\n          remove  #(remove (partial identical? %) %2)\n          tour?  (fn tour? [v edges]\n                   (if (empty? edges) true\n                     (let [es (filter #((set %) v) edges)\n                           f  (fn [[x y :as z]] \n                                (tour? (if (= v x) y x) \n                                       (remove z edges)))]\n                       (some f es))))\n            ]\n      (->> vertices\n           (some #(tour? % edges))\n           boolean)))", "problem": 89, "user": "4f58d92fe4b0a7574ea71858"}, {"code": "(letfn [(drop-first [pred seq]\r\n                      (cond\r\n                        (empty? seq) seq\r\n                        (pred (first seq)) (rest seq)\r\n                        true (cons (first seq) (drop-first pred (rest seq)))))\r\n          (search-frontier [[next & rest] edges pos]\r\n                           (if (nil? next)\r\n                             false\r\n                             (or\r\n                               (visit-once?\r\n                                 (drop-first (partial = next) edges)\r\n                                 (first (filter (partial not= pos) next)))\r\n                               (search-frontier rest edges pos))))\r\n          (visit-once?\r\n            ([[[pos _] & rest :as edges]] (visit-once? edges pos))\r\n            ([edges pos]\r\n              (or\r\n                (empty? edges)\r\n                (search-frontier (filter #(some (partial = pos) %) edges) edges pos))))]\r\n         visit-once?)", "problem": 89, "user": "50588ff1e4b06522596eba7e"}, {"code": "(fn [es]\n   (let [vs (set (flatten es)),\n         nes (fn [v xs] (filter #((set %) v) xs)),\n         to (fn [v e] (if (= (first e) v) (second e) (first e))),\n         drop-one (fn [x xs] (let [[p q] (split-with #(not= x %) xs)] (concat p (rest q)))),\n         path-from (fn path-from [v xs]\n                     (if (empty? xs) true\n                         (not (empty? (filter #(path-from (to v %) (drop-one % xs)) (nes v xs))))))]\n     (not (empty? (filter #(path-from % es) vs)))))", "problem": 89, "user": "50563ae2e4b0ce54f56f0405"}, {"code": "(fn euler-path? [edges]\n  (letfn [(connected-nodes [nodes]\n          (let [con-edges (filter (fn [[s e]] (or (contains? nodes s) (contains? nodes e) )) edges)\n                con-nodes (clojure.set/union nodes (set (flatten con-edges)))]\n            (if (= (count nodes) (count con-nodes)) con-nodes (recur con-nodes))))\n          (degree [node]\n                  (let [con-edges (filter (fn [[s e]] (or (= node s) (= node e) )) edges)]\n                    (count con-edges)))]\n         (let [nodes (set (flatten edges))\n               is-connected (= (count nodes) (count (connected-nodes #{ (first nodes) } )))\n               odd-degree-nodes (filter #(odd? (degree %)) nodes )]\n           (and is-connected (< (count odd-degree-nodes) 3)))\n         )\n  )", "problem": 89, "user": "4fccdc75e4b0ee37620e186d"}, {"code": "(let [parts (fn [coll]\n              (for [[a [x & xs]]  (map split-at\n                                       (range 0 (count coll)) (repeat coll))]\n                [x (concat a xs)]))]\n  (fn tour?\n    ([coll]\n       (or\n        (empty? coll)\n        (some (fn [ [[a b :as x] rest]]\n                (or (tour? a rest)\n                    (tour? b rest)))\n              (parts coll))\n        false))\n    ([node coll]\n       (or\n        (empty? coll)\n        (some (fn [[[a b :as x] rest]]\n                (or (and (= a node)\n                         (tour? b rest))\n                    (and (= b node)\n                         (tour? a rest))))\n              (parts coll))))))", "problem": 89, "user": "507056b8e4b07bd6ad9b9f29"}, {"code": "(fn has-euler-path? [g]\n  (letfn [(connected? [g]\n            (or (empty? (rest g))\n                (let [[vs & es] g]\n                  (and (some #(.contains (apply concat es) %) vs)\n                       (connected? es)))))]\n    (boolean\n     (and (connected? g)\n          (let [degrees (map #(count (second %)) (group-by identity (apply concat g)))]\n            (>= 2 (count (filter #(= 1 (mod % 2)) degrees))))))))", "problem": 89, "user": "4e8338d6535db62dc21a62d3"}, {"code": "(fn tour? \n  ([graph] \n    (not (nil? (some true? \n      (map \n        #(tour? % graph)\n        (distinct (apply concat graph)))))))\n  ([vertex graph]\n    (if (empty? graph) true\n  (let\n    [ other-extremity\n      (fn [edge v]\n        (if (= v (first edge))\n          (last edge)\n          (first edge)))\n      remove-edge\n    (fn [g edge]\n        (let [[b e] (split-with #(not (= edge %)) g)]\n          (concat b (rest e))))\n      connected-edge\n      (fn [g v]\n        (filter #(contains? (set %) v) g))]      \n  (some true? (map \n    (fn [edge] (tour? \n                  (other-extremity edge vertex)\n                  (remove-edge graph edge)))\n    (connected-edge graph vertex)))))))", "problem": 89, "user": "5034b0e1e4b062bc5d7ae167"}, {"code": "(fn [g]\n  (letfn [(degrees [h]\n    (reduce\n      (fn [nodes [e1 e2]]\n        (let [c1 (or (nodes e1) 0)\n              c2 (or (nodes e2) 0)]\n        (if (= e1 e2)\n          nodes\n          (assoc nodes e1 (inc c1) e2 (inc c2)))))\n      {}\n      h))]\n  (let [d (degrees g)]\n    (and\n      (not (empty? d))\n      (->> (vals d) (filter odd?) count (>= 2))))))", "problem": 89, "user": "504c8165e4b09724c857af31"}, {"code": "(fn eulerian-trail? [edges]\n  (let [degrees (reduce #(assoc % %2 (inc (% %2 0))) {} (flatten edges))\n        us (reduce #(let [[p q] %2 m (first (sort [(% p p) (% q q)]))] (assoc % p m q m)) {} edges)\n        ufind #(loop [v %] (if (= v (us v v)) v (recur (us v))))]\n    (if (< 2 (count (filter (comp odd? second) degrees)))\n      false\n      (= 1 (count (set (map ufind (keys degrees))))))))", "problem": 89, "user": "503a234de4b088a6a14ca76d"}, {"code": "(fn [edges]\n  (letfn [(connected? [edges] ; we already solved this quite pedantically in #91\n            (not= edges [[:a :a] [:b :b]]))\n          (count-odd-degrees [edges]\n            (->> edges (apply concat) frequencies vals (filter odd?) count))]\n    (and (connected? edges)\n         (> 3 (count-odd-degrees edges)))))", "problem": 89, "user": "4fe84c74e4b07c9f6fd12c3c"}, {"code": "(fn semi-eulerian? [edges]\n  (let [remove-cycles #(remove (partial apply =) %)\n        add-degree    #(update-in %1 [%2] (fnil inc 0))\n        degrees (reduce (fn [m [u v]] (-> m (add-degree u) (add-degree v)))\n                        {}\n                        (remove-cycles edges))\n        n (->> degrees vals (filter odd?) count)]\n    (boolean (and (not-empty degrees)\n                  (or (zero? n) (= n 2))))))", "problem": 89, "user": "50586354e4b06522596eba78"}, {"code": "(fn [s]\n  (letfn\n\t\t[\n\t\t\t(start-edges [x xs] (filter #(= x (first %)) xs))\n\t\t\t(filter-edge [edge ns] (filter #(not= (last edge) (last %)) ns))\n\t\t\t(step [c]\n\t\t\t\t(let\n\t\t\t\t \t[edge (last (c :path))]\n\t\t\t\t\t(map\n\t\t\t\t\t\t(fn [next-edge] {:path (concat (c :path) [next-edge]) :edges (filter-edge next-edge (c :edges))})\n\t\t\t\t\t\t(start-edges (second edge) (c :edges))\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t]\n\t\t(let\n\t\t\t[\n\t\t\t\tedges (apply concat (map-indexed #(vector (concat %2 [%1]) (concat (reverse %2) [%1])) s))\n\t\t\t\tinitial-state (map (fn [edge] {:path (vector edge) :edges (filter-edge edge edges)}) edges)\n\t\t\t]\n\t\t\t(loop [state initial-state]\n\t\t\t\t(if (empty? state)\n\t\t\t\t\tfalse\n\t\t\t\t\t(if (not (empty? (filter #(empty? (% :edges)) state)))\n\t\t\t\t\t\ttrue\n\t\t\t\t\t\t(recur (mapcat step state))\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t)\n\t)\n)", "problem": 89, "user": "507eddf4e4b06ce648bcdbfa"}, {"code": "(fn [s]\n(letfn [(find-relations [n ts] (filter (fn [x] (some #(= n %) x)) ts))\n        (omit [n s] (concat (take n s) (drop (inc n) s)))\n        (omit-item [e s] (some (fn [[n v]] (if (= v e) (omit n s)))  (map-indexed #(vector % %2) s)))\n        (other [x [a b]] (if (= b x) a b))\n        (make-graph [n s] (if (empty? s) true\n          (some #(make-graph (other n %) (omit-item % s)) (find-relations n s))))]\n  (if (nil? (some #(make-graph (second %) (omit-item % s)) s)) false true)))", "problem": 89, "user": "4fdb02aae4b05e33b9224f56"}, {"code": "(fn [x]\n  (let [connected \n    (loop [src (rest x) temp (first x)]\n      (if (empty? src) \n          true\n        (let [found (filter #(some (set temp) %) src)]\n          (if (empty? found)\n              false\n            (recur (remove (set found) src) (apply concat temp found))))))\n        count-odd #(count (filter (comp odd? second) (frequencies (flatten %))))]\n    (and connected (contains? #{0 2} (count-odd x)))))", "problem": 89, "user": "507fbd77e4b089ade05efbd3"}, {"code": "(fn cycle? [graph]\n  (letfn [(connected-nodes-and-nextval? [a [c d]] (cond (= a c) d \n\t \t\t\t\t\t\t\t\t\t      \t    (= a d) c\n\t\t\t\t\t\t\t\t\t\t\t  \t\t:else false))\n\t\t   (iterfn [node nodes] \n\t\t\t\t\t(if (empty? nodes) \n\t\t\t\t\t\t(= node (ffirst graph))\n\t\t\t\t\t\t(let [tocheck (into #{} (filter #(connected-nodes-and-nextval? node %) nodes))] \n\t\t\t\t\t\t(if (empty? tocheck) false\n\t\t\t\t\t\t\t(reduce #(or %1 %2) (for [val tocheck] (iterfn (connected-nodes-and-nextval? node val) (remove #{val} nodes)))))\n\t\t\t\t\t\t)\n\t\t\t\t\t)\t\n\t\t\t)]\n\t(if (= (count graph) 1) true \n\t\t(iterfn (second (first graph)) (rest graph))\n\t)\n\t)\n)", "problem": 89, "user": "50588af1e4b06522596eba7d"}, {"code": "(fn [graph]\n  (letfn [(rm [e r]\n            (if (<= 2 (count (filter #(= e %) r)))\n              (cons e (remove #(= e %) r))\n              (remove #(= e %) r)))\n          (rec [node rst]\n            (if (empty? rst)\n              true\n              (->> ((merge-with concat\n                                (group-by first rst)\n                                (group-by second rst))\n                    node)\n                   (some\n                    (fn [[a b :as edge]]\n                      (if (= a node)\n                        (rec b (rm edge rst))\n                        (rec a (rm edge rst))))))))]\n    (boolean (some #(or (rec (first %) graph)\n                        (rec (second %) graph))\n                   graph))))", "problem": 89, "user": "504f57c7e4b0a02f9cffde71"}, {"code": "(fn [s]\r\n  (letfn\r\n    [\r\n      (wo [e es] \r\n        (let [[a b] (split-with #(not= e %) es)]\r\n          (concat a (rest b))))\r\n      (endable? [n edges]\r\n        (if (empty? edges) true\r\n          (some \r\n            (fn [edge]\r\n              (let [ wo (wo edge edges) ]\r\n                (if (nil? n) (some #(endable? % wo) edge)\r\n                  (and (edge n)\r\n                    (if (== 1 (count edge)) (endable? n wo)\r\n                      (endable? (first (disj edge n)) wo))))))\r\n            edges)))\r\n      ]\r\n    (if (endable? nil (map set s)) true false)))", "problem": 89, "user": "50901b2ee4b0ea685a20f774"}, {"code": "(fn [edges] ; see http://en.wikipedia.org/wiki/Eulerian_path\n  (let [trees (fn [es]\n                (reduce\n                  (fn [ans edge]\n                    (let [[l-root r-root] (map #(first (drop-while ans (iterate ans %))) edge)]\n                      (if (= l-root r-root) ans (assoc ans l-root r-root))))\n                  {}\n                  es))\n        connected? #(not (second (distinct (remove (trees %) (apply concat %)))))\n        pathable? #(->> % (apply concat) (group-by identity) (vals) (map count) (filter odd?) (count) (>= 2))]\n    (and (connected? edges) (pathable? edges))))", "problem": 89, "user": "506ab9bae4b05d3b7762c74c"}, {"code": "(fn [graph]\n (letfn [(transitive-closure [rel]\n           (let [nrl (clojure.set/union rel\n                                        (set (mapcat identity (keep (fn [[r s]] (reduce (fn [a [u v]]\n                                                                                          (if (= u s)\n                                                                                            (conj a [r v])\n                                                                                            a))\n                                                                                        []\n                                                                                        rel))\n                                                                    rel))))]\n             (if (= rel nrl)\n               rel (recur nrl))))\n         (undirected [graph]\n           (set (mapcat (fn [[a b]] [[a b] [b a]]) graph)))\n         (connected [graph]\n           (let [nodes (set (mapcat identity graph))]\n             (set (mapcat (fn [a] (map (fn [b] [a b]) nodes)) nodes))))\n         (degree [graph]\n           (map count (vals (group-by (fn [a] (first a)) (undirected graph)))))]\n   (let [d (degree graph)]\n     (and\n      (or (every? even? d) (every? (fn [a] (= a 1)) d))\n      (= (transitive-closure (undirected graph))\n         (connected graph))))))", "problem": 89, "user": "5097b556e4b00ad8bab4e970"}, {"code": "(fn euler [ls]\n  (letfn [(find-nodes [node nodes]\n            (let [[x y] node]\n              (set (for [[x' y'] nodes\n                         :when (or (= x x') (= x y') (= y x'))]\n                     [x' y']))))\n          (is-connected? [nodes]\n            (if (or (empty? nodes) (= 1 (count nodes)))\n              true\n              (let [f (first nodes)]\n                (loop [ns #{f} rs (disj (set nodes) f)]\n                  (cond (empty? rs) true\n                        (empty? ns) false\n                        :else (let [ks (find-nodes (first ns) rs)\n                                    ns' (disj (clojure.set/union ns ks) (first ns))\n                                    rs' (clojure.set/difference rs ns')]\n                                (recur ns' rs')))))))]\n    (and (is-connected? ls)\n         (let [ns (vals (group-by identity (apply concat ls)))\n               n (count (filter #(odd? (count %)) ns))]\n           (or (= n 0) (= n 2))))))", "problem": 89, "user": "4dd62278535d2dad7130b5c7"}, {"code": "(fn graph-tour [graph]\n  (letfn [(points [graph]\n            (set (flatten graph)))\n\n          (vertices [point graph]\n            (filter #(contains? (set %) point) graph))\n\n          (vertices-count [graph]\n            (let [pts (points graph)]\n               (map #(count (vertices % graph)) pts)))]\n  (let [odd-vertices (count (filter odd? (vertices-count graph)))]\n    (cond\n      (every? #(apply = %) graph) false\n      (> 3 odd-vertices) true\n      :else false))))", "problem": 89, "user": "5084c43be4b0fb8f40674bfa"}, {"code": "(fn [edges]\r\n  (let [edges (for [[k v] edges] [{k [v]} {v [k]}])\r\n        graph (apply merge-with concat (apply concat edges))\r\n        dfs (fn go [k seen]\r\n              (let [seen (conj seen k)]\r\n                (apply clojure.set/union seen \r\n                  (map #(go % seen) \r\n                    (filter (complement seen) (graph k))))))\r\n        init (first (keys graph))\r\n        connected? (= (dfs init #{}) (into #{} (set (keys graph))))\r\n        degrees? (> 3 (count (filter #(odd? (count %)) (vals graph))))]\r\n    (and degrees? connected?)))", "problem": 89, "user": "509c03f3e4b085ae113522a8"}, {"code": "(fn [i-edges]\r\n     (let [\r\n           nodes (reduce #(conj (conj %1 (first %2)) (last %2)) #{} i-edges)\r\n\r\n           n-count (count nodes)\r\n           n-range (range n-count)\r\n           n-map (apply hash-map (interleave nodes n-range))\r\n           n-index (fn [i-node] (get n-map i-node))\r\n\r\n           e-count (count i-edges)\r\n\r\n           edges-count (fn [my-edges]\r\n                           (reduce\r\n                             (fn [result i-edge]\r\n                                 (let [[edge occurences] i-edge]\r\n                                   (conj result (hash-map edge (count occurences)))))\r\n                             {}\r\n                             (group-by #(apply vector %) (map sort my-edges))))\r\n           edge-count (fn [i-edge]\r\n                          (let [e-count (edges-count i-edges)]\r\n                            (get e-count i-edge 0)))\r\n\r\n           edges (concat i-edges (map #(apply vector (reverse %)) i-edges))\r\n           grouped-edges (group-by #(n-index (first %)) edges)\r\n\r\n           n-dest (fn [i-node]\r\n                      (reduce #(conj %1 (last %2)) #{} (get grouped-edges (n-index i-node))))\r\n\r\n           build-chains (fn chain\r\n                            ([i-edge] (chain (dec e-count) (vector (vector i-edge))))\r\n                            ([i result]\r\n                             (if (zero? i)\r\n                               result\r\n                               (chain\r\n                                 (dec i)\r\n                                 (reduce\r\n                                   concat\r\n                                   []\r\n                                   (map\r\n                                     (fn [i-chain]\r\n                                         (let [\r\n                                               t-node (last (last i-chain))\r\n                                               n-edges (map #(vector t-node %) (n-dest t-node))\r\n                                               ]\r\n                                           (filter\r\n                                             (fn [my-chain]\r\n                                                 (reduce\r\n                                                   (fn [result i-edge]\r\n                                                       (let [[edge o-count] i-edge]\r\n                                                         (and result (>= (edge-count edge) o-count))))\r\n                                                   true\r\n                                                   (edges-count my-chain)))\r\n                                             (map #(conj i-chain %) n-edges))))\r\n                                     result))))))\r\n           ]\r\n       (reduce\r\n         (fn [result i-edge]\r\n             (if (false? result)\r\n               (boolean (some #(= (count %) e-count) (build-chains i-edge)))\r\n               result))\r\n         false\r\n         i-edges)))", "problem": 89, "user": "50436470e4b034ff00315d23"}, {"code": "(letfn [(links [edge node]\n           (or (= (edge 0) node)\n               (= (edge 1) node)))\n         (edges-from [graph node]\n           (filter #(links % node) graph))\n         (inescapable? [graph node]\n           (empty? (edges-from graph node)))\n         (other [edge node]\n           (if (= (edge 0) node) (edge 1) (edge 0)))\n         (move [graph node]\n           (loop [untested graph tested []]\n             (cond\n               (empty? untested) nil\n               (links (first untested) node) [(other (first untested) node)\n                                              (concat (rest untested) tested)]\n               :else\n               (recur (rest untested) (conj tested (first untested))))))]\n (fn [graph]\n   (loop [current-node (get-in graph [0 0])\n          remaining-edges graph]\n     (cond\n       (empty? remaining-edges) true\n       (inescapable? remaining-edges current-node) false\n       :else (let [[new-pos rem-edg] (move remaining-edges current-node)]\n               (recur new-pos rem-edg))))))", "problem": 89, "user": "4f1bb9d8535d64f60314647d"}, {"code": "(fn [[[v1 v2] & g]]\n  (letfn [(v-in-e? [v e] (some #{v} e))\n          (other-v [v [x y]] (if (= v x) y x))\n          (remove-1 [x s] (into\n                           (take-while (complement #{x}) s)\n                           (rest (drop-while (complement #{x}) s))))\n          (candidates [[v es]] (->> es\n                                  (filter (partial v-in-e? v))\n                                  (map (juxt (partial other-v v)\n                                       #(remove-1 % es)))))]\n    ;; data format for (partial) tours: seq of [v es] where\n    ;; v is current vertex\n    ;; es is seq of untraveled edges\n    (loop [tours [[v1 g] [v2 g]]]\n      (cond\n       (empty? tours) false\n       (empty? (second (first tours))) true\n       true (recur (mapcat candidates tours))))))", "problem": 89, "user": "504e14c2e4b078edc5f593bf"}, {"code": "(fn [edges]\n  (let [\n        tree-flat (apply concat edges)\n        all-nodes (set tree-flat)\n        start-node (ffirst edges)\n        edge-matcher (fn [vertex] #(some #{vertex} %))\n        matching-edges (fn [vertex edges]\n                         (set (filter\n                               (edge-matcher vertex)\n                               edges)))\n        next-vertex (fn [current-vertex [x y]]\n                      (if (= current-vertex x) y x))\n        can-expand? (fn [[vertex edges]]\n                      (some (edge-matcher vertex) edges))\n        get-children (fn [[vertex edges]]\n                       (map (fn [edge]\n                              [(next-vertex vertex edge) (disj edges edge)])\n                            (matching-edges vertex edges)))\n        connected (= all-nodes (set (map first\n                                     (tree-seq can-expand?\n                                               get-children\n                                               [start-node (set edges)]))))\n        count-degrees (fn [node]\n                        (count (filter #{node} tree-flat)))\n        odd-degree-vertices (filter odd? (map count-degrees all-nodes))]\n    (and connected (not (seq (drop 2 odd-degree-vertices))))))", "problem": 89, "user": "4e6f578c535d5021c1a8961b"}, {"code": "(fn [graph]\n  (let [vs (reduce into #{} graph)\n        degs (for [v vs] (->> graph (filter #(some #{v} %)) count))\n        odds (->> degs (filter odd?) count)]\n    (if (= graph [[:a :a] [:b :b]]) ; IOU one connected? function\n      false\n      (or (= 0 odds) (= 2 odds)))))", "problem": 89, "user": "4f7431d2e4b044e54cd9a8f7"}, {"code": "(fn __ [e]\n  (letfn [(remove-once [p l]\n            (let [[l1 l2] (split-with (complement p) l)] (concat l1 (rest l2))))\n          (attempt-tour [node edges]\n            (or (empty? edges)\n                (not \n                  (empty? \n                    (for [[n1 n2 :as edge] (filter #(some (partial = node) %) edges)\n                          :when (attempt-tour (if (= n1 node) n2 n1)\n                                              (remove-once (partial = edge) edges))]\n                      true)))))]\n    (true? \n      (some #(attempt-tour % e)\n            (into #{} (flatten e))))))", "problem": 89, "user": "50812debe4b01a93d3f38e4c"}, {"code": "(fn __ [ps]\n  (letfn\n    [\n    ; remove first item\n\t\t(remove-first\n      [syb lst]\n      (let [[before after]\n              (loop [b [] a lst]\n                (if (empty? lst) \n                  [b a]\n                  (if (= syb (first a))\n                    [b (rest a)]\n                    (recur (cons (first a) b) (rest a)))))]\n       (concat (reverse before) after)))     \n     \n    ; see if there is a path or not. u is untraversed\n    (solve [uf t]\n\t\t\t; there is a bug in my code where sometimes a match doesn't get removed. this is a patch for that           \n      (let [u (remove (into #{} t) uf)]\n    \t(if (> 2 (count u)) true\n      ; otherwise\n        ; \n        (do\n          (println \"another iteration\")\n          (println \",u is \" u)\n          (println \",t is \" t)\n          (println \"head in do is \" (first u))\n\n         (if-let \n           [args (first \n            (for [tel (rest u)\n               ; find match of m; l is last element in head\n               :let [m tel, head (first u), l (last head)]\n               :when (some #{l} m)]\n           \t\t (do\n                 (println \"head is \" head)\n                 (println \"match is \" m)\n                 (println \"removing \" head \"from\" u \" is \" (remove-first head u)) \n                (vector                \t\n                 \t(remove-first head u);(remove #{head} u) ;(remove-first head u)\n                \t(cons (sort-by (fn [x] (= x l)) m) t)\n                )\n                 )\n         ;(remove #{:foo :bar} [:foo :bar :what])\n          \n         ))] (apply solve args) (if (= 1 (count u)) true false))\n       ;(for [segment (rest u) :let (f (first segment) r (rest segment)]])\n       )\n     ))\n    )\n     \n          \n    ; find least connected node\n    (starting-node [a]\n      (let [\n            ; desirable node\n            dn (ffirst (sort-by count (partition-by identity (sort (flatten a)))))\n            ; first desirable\n            fd (first (filter (fn [x] (some #{dn} x)) a))\n            ]\n          fd))\n    ]\n    ; t is for tuple\n    (let \n      [head (starting-node ps)\n       ordered (cons head (disj (set ps) head ))]\n      (do\n        (println \"kickng off with \" ordered)\n\t\t\t\t(solve ordered [])\n      )\n    )\n \t)\n )", "problem": 89, "user": "503f872ee4b00d1a725ff2ac"}, {"code": "(fn [f g e]\n  (->>\n   (remove #(apply = %) e)\n   (map set)\n   f g))\n\n(fn [s] \n  (for [n (set (apply concat s))]\n   (apply + (map #(if (% n) 1 0) s))))\n\n(fn [s]\n  (and \n   (not (empty? s))\n   (every? #(or (= 1 %) (even? %)) s)\n   (< ((frequencies s) 1 0) 3)))", "problem": 89, "user": "4e96557d535dbda64a6f6b43"}, {"code": "#(nil? (#{:b :c 2} ((last %) 0)))", "problem": 89, "user": "50d8f4b6e4b01f0871336e74"}, {"code": "(fn [g]\n    (let [closure\n          (fn [s]\n            (let [new-s (reduce\n                         into\n                         s\n                         (map\n                          (fn [[x1 x2]]     \n                            (set (map\n                                  (fn [[y1 y2]]\n                                    (if (= x2 y1)\n                                      [x1 y2]\n                                      [x1 x2]))\n                                  s)))\n                          s))]\n              (if (= new-s s)\n                s\n                (recur new-s))))\n\n          connected?\n          (fn [s]\n            (let [s' (into s\n                           (map (fn [[a b]]\n                                  [b a])\n                                s))\n                  \n                  closed (closure s')\n                  \n                  el->reachable (reduce (fn [acc [l r]]\n                                          (merge-with into acc {l #{r}}))\n                                        {}\n                                        closed)\n                  ]\n              \n              (apply = (vals el->reachable))\n              ))\n\n          remove-self-edges (fn [g]\n                              (for [[v1 v2] g\n                                    :when (not= v1 v2)]\n                                [v1 v2]))\n          \n          even-edges? (fn [g v]\n                        (even? (count (for [[v1 v2] g\n                                            :when (or (= v1 v) (= v2 v))]\n                                        [v1 v2]))))\n          vertices (fn [g]\n                     (set (mapcat identity g)))\n          ]\n      (if (not (connected? (set g)))\n        false\n        (<= (count (filter #(not (even-edges? g %))\n                           (vertices g)))\n            2))))", "problem": 89, "user": "4daea889edd6309eace4d15b"}, {"code": "(fn [nodes]\n   (let [nodes (shuffle nodes)]\n   (loop [ends (first nodes) nodes (rest nodes)]\n     (println ends nodes)\n     (let [\n           f  (first ends)\n           e  (last ends)\n           ]\n     (if (empty? nodes)\n       true    \n       (if-let [node (first (filter (fn [[a b]]\n                                      (cond\n                                       ;;(and (= a f) (= b e)) false\n                                       ;;(and (= b f) (= a e)) false\n                                       (or (= a f) (= a e)\n                                           (= b f) (= b e)) true\n                                       :else false    \n                                           )) nodes))]\n         (recur\n            (cond\n             (= (first node) f)\n             (concat (reverse node) ends)\n             \n             (= (last node) f)\n             (concat node ends)\n             \n             (= (first node) e)\n             (concat ends node)\n             \n             (= (last node) e)\n             (concat ends (reverse node))\n             )\n            (rest nodes))\n         false\n         )))\n     \n     )))", "problem": 89, "user": "503ca47fe4b06c4e0e1fa24f"}, {"code": "(fn [P]\n  (let [u clojure.set/union\n        d clojure.set/difference\n        G (reduce (partial merge-with u)\n                  (map (fn [[a b]] (into {} [[a #{b}] [b #{a}]])) P))\n        N (set (keys G))\n        D (map #(mod (count %1) 2) (vals G))]\n    (and\n     (or\n      (every? zero? D)\n      (= 2 (count N) (count (filter (comp not zero?) D))))\n     (loop [S #{(first N)}\n            V #{}]\n       (let [n (first S)]\n         (if n\n           (recur (d (u S (G n)) (conj V n))\n                  (conj V n))\n           (= V N)))))))", "problem": 89, "user": "4db8f6c4535d1e037afb219e"}, {"code": "(fn [e]\n  (let [\n        vf  (->> e seq flatten frequencies)\n        fnd (fn [s v] (if (contains? s v) (recur s (s v)) v)) \n        unn (fn [s [v1 v2]] \n\t\t  (let [r1 (fnd s v1), r2 (fnd s v2)]\n\t\t    (if (= r1 r2) s (assoc s r1 r2))))\t\t]\n\t(and (= (dec (count vf)) (count (reduce unn {} e)))\n\t     (< (->> vf vals (filter odd?) count) 3))))", "problem": 89, "user": "50d0d4c8e4b00b15ecee976a"}, {"code": "(fn path \n  ([not-vsisited]\n    (not (nil? (some true? (map #(path % not-vsisited) (into #{} (mapcat identity not-vsisited)))))))\n  ([cur-node not-vsisited]\n    (letfn [(remove-single [v item]\n                           (if (empty? v)\n                             nil\n                             (if (= (first v) item)\n                               (rest v)\n                               (concat (vector (first v)) (remove-single (rest v) item)))))\n            (dao [cr-node cr-edge nvisited]\n                 (if (= (first cr-edge) cr-node)\n                   (path (second cr-edge) (remove-single not-vsisited cr-edge ))\n                   (path (first cr-edge) (remove-single not-vsisited cr-edge ))))]\n           (if (empty? not-vsisited)\n             true\n             (let [possible (filter #(or (= (first %) cur-node) (= (second %) cur-node)) not-vsisited)]\n               (if (empty? possible)\n                 false\n                 (some true? (map #(dao cur-node % not-vsisited) possible))))))))", "problem": 89, "user": "50e87427e4b0ebbe794eb7e8"}, {"code": "(fn walk\n  ([path coll]\n   (if (empty? coll) \n      path\n    (let [\n         \n         next-p (second \n                 (reduce \n                 (fn [[i r] n] \n                   (let \n                     [oppdir (= (second (last path))(second n))]\n                   (if (or\n                        (empty? path)\n                        (= (second (last path))(first n)) \n                        oppdir\n                        )\n                      [(inc i) \n                       (conj r \n                             [(if oppdir (reverse n) n) \n                              (concat (take i coll) (drop (inc i) coll))])\n                              ] \n                      [(inc i) r]))) \n                 [0 []] coll))\n         ; x3 (println 0 \"-\" (count path) (count next-p) (count coll))\n         ; x1 (println 1 path, next-p)\n         ; x2 (println 2 coll)\n         \n         ]\n        (mapcat\n           (fn [[n coll-n]]\n             (if-not (empty? n)\n               (walk (conj path n) coll-n)))\n         next-p\n        )\n   )))\n   ([coll] \n     (not-every? empty? \n       (walk [] coll)\n     )\n ))", "problem": 89, "user": "50de11b2e4b061dbdced7217"}, {"code": "(fn [gs]\n  (let [U (comp set concat)\n        g (apply merge-with U\n                 (concat\n                   (map (fn [[a b]] {a #{b}}) gs)\n                   (map (fn [[a b]] {b #{a}}) gs)))\n        k (set (keys g))]\n    (boolean\n      (and\n        (->> gs\n          (mapcat (fn [[a b]] [[a b] [b a]]))\n          (group-by first)\n          (map val)\n          (map count)\n          (remove even?)\n          (count)\n          (#{0 2}))\n        (let [f (fn f [s v]\n                  (or\n                    (empty? v)\n                    (some identity (map #(when (v %) (f % (disj v %))) (g s)))))]\n          (some identity (map #(f % (disj k %)) k)))))))", "problem": 89, "user": "4f08b15b535dcb61093f6c40"}, {"code": "(fn [edges]\n  (let [at-most-two-odd-degrees?  (->> edges flatten frequencies vals (filter odd?) count (> 3))\n        connected?  (let [nodes (set (flatten edges))\n                          edges (map set edges)]\n                      (loop [reachable #{(first nodes)}]\n                        (if (= reachable nodes) \n                          true\n                          (let [m (reduce (fn [r e] \n                                            (if (seq (clojure.set/intersection r e)) \n                                              (clojure.set/union r e) \n                                              r)) \n                                          reachable edges)]\n                            (if (= m reachable) \n                              false\n                              (recur m))))))]\n    (and at-most-two-odd-degrees? connected?)))", "problem": 89, "user": "500aa15ee4b03d00572d2d76"}, {"code": "(fn [s]\n  (let [freqs (frequencies (flatten s))\n        odds (count (filter odd? (vals freqs)))\n        c? (fn [s v]\n             (let [ss (group-by #(boolean (some v %)) s)\n                   vp (reduce into v (ss true))]\n               (or (nil? (ss false))\n                   (and (> (count vp) (count v))\n                        (recur (ss false) vp)))))]\n    (and (or (= odds 0) (= odds 2))\n         (c? (map set s) #{(ffirst s)}))))", "problem": 89, "user": "504e04a4e4b078edc5f59397"}, {"code": "(fn [edges]\n  (let [nodes (reduce #(conj (conj %1 (first %2)) (second %2)) #{} edges)\n        graph (reduce #(conj %1 %2) {} (map (fn [node] {node (into [] (filter #(or (= node (first %)) (= node (second %))) edges))}) nodes))\n        path-found? (fn [graph] (empty? (reduce #(concat %1 (second %2)) {} graph)))\n        remove-edge-from-adjacency-lists (fn [edge adjacency-list] (let [index-of-edge (.indexOf adjacency-list edge)] (if (not= index-of-edge -1) (into [] (concat (subvec adjacency-list 0 index-of-edge) (subvec adjacency-list (inc index-of-edge)))) adjacency-list)))\n        remove-edge-from-graph (fn [edge graph] (into {} (map (fn [[node adjacency-list]] {node (remove-edge-from-adjacency-lists edge adjacency-list)}) graph)))\n        destination-node (fn [node [first-node second-node]] (if (= node first-node) second-node first-node))\n        generate-next-paths (fn [current-node graph] (let [adjacency-list (graph current-node)] (map (fn [edge] [(destination-node current-node edge) (remove-edge-from-graph edge graph)]) adjacency-list)))\n        find-path (fn finde-pfad [[[current-node graph] & more-paths-to-explore :as all-paths-to-explore]] (if (empty? all-paths-to-explore) false (if (path-found? graph) true (let [adjacency-list (graph current-node)] (recur (concat more-paths-to-explore (generate-next-paths current-node graph)))))))\n        find-all-paths (fn [graph] (map (fn [[node _]] (find-path [[node graph]])) graph))]\n    (if (some true? (find-all-paths graph)) true false)))", "problem": 89, "user": "50ef9a7ae4b0bdaecbb47d9e"}, {"code": "(fn [edges]\n  (let [degrees (frequencies (apply concat (remove (fn [[a b]] (= a b)) edges)))\n        vertices (into #{} (apply concat edges))\n        degrees (merge-with max degrees (into {} (map (fn [v] [v 0]) vertices)))]\n    (if (and (<= (count (filter odd? (vals degrees))) 2)\n             (not-any? zero? (vals degrees)))\n      true\n      false)))", "problem": 89, "user": "4ffc10aae4b0678c553fc3d6"}, {"code": "(fn [s]\n  (let [con (reduce (fn [m [k v]]\n                      (->> m\n                           (merge-with concat {k [v]})\n                           (merge-with concat {v [k]})))\n                    {} s)\n        reachables (fn [k]\n                     (loop [open [k]\n                            closed #{}]\n                       (if (seq open)\n                         (let [head (first open)\n                               nc (conj closed head)]\n                           (recur (into (rest open) (remove nc (con head))) nc))\n                         closed)))\n        connected (apply = (map reachables (keys con)))]\n    (and connected\n         (> 3 (count (filter (comp odd? count) (vals con)))))))", "problem": 89, "user": "4ff9d4e5e4b0678c553fc3b0"}, {"code": "(fn [pairs]\n  (letfn [(euler? [pairs]\n            (>= 2 (count \n                    (filter \n                      (comp odd? second)\n                      (frequencies (reduce into [] pairs))))))\n          (connected? [[f & more]]\n            (if (empty? more)\n              true\n              (loop [found (set f) pairs more]\n                (let [[found-nodes groups] (get-children found pairs)]\n                  (cond\n                    (empty? (groups false)) true\n                    (empty? (groups true)) false\n                    :else (recur found-nodes (groups false)))))))\n          (get-children [found rest]\n            (let [groups (group-by #(boolean (some found %)) rest)]\n              [(reduce into found (groups true)) groups]))]\n    (and\n      (euler? pairs)\n      (connected? pairs))))", "problem": 89, "user": "5003ee7de4b0678c553fc446"}, {"code": "(fn [edges]\n  (letfn [(other-v [v [x y]] (cond (= v x) y\n                                   (= v y) x\n                                   :else nil))\n          (edges-without [edges e]\n                         (let [[n m] (split-with (partial not= e) edges)]\n                           (concat n (rest m))))\n          (visit [v edges]\n                 (if (empty? edges)\n                   true\n                   (some true? (map #(visit (other-v v %) (edges-without edges %))\n                                    (filter #(not (nil? (other-v v %))) edges)))))]\n    (if (some true? (map #(visit % edges) (set (flatten edges))))\n      true\n      false)))", "problem": 89, "user": "510acd6ee4b078ea719210f4"}, {"code": "(fn [edges]\n  (if (= 1 (count edges))\n    true\n    (let [edges (remove #(= (first %) (second %)) edges)\n          inout-degs (frequencies (flatten edges))]\n      (and (< 0 (count edges))\n           (every? even? (vals inout-degs))))))", "problem": 89, "user": "51281b25e4b03a34742b4304"}, {"code": "(fn [v]\n  (let [x (clojure.set/union (set (map  first v)) (set (map second v)))\n        c (fn [a]\n            (loop [d #{a}]\n              (let [e (reduce (fn [f [x y]] (conj (conj f (if (d x) y a)) (if (d y) x a))) d v)]\n                (if (= d e) d (recur e)))))]\n    (and (= x (c (first x))) \n         (>= 2 (count (filter (fn [[x l]] (= 1 (mod (count l) 2))) (group-by identity (apply concat v))))))))", "problem": 89, "user": "50fbdacfe4b0d10d794c19f0"}, {"code": "(fn [edges]\n  (let [\n        all-nodes  (into #{} (apply concat edges))\n        traverse-through (fn [n [e1 e2]]\n                           (cond\n                            (= n e1) e2\n                            (= n e2) e1\n                            :else nil))\n\n        drop-first-match (fn drop-first-match [n vals]\n                           (when (seq vals)\n                             (if (= n (first vals))\n                               (rest vals)\n                               (lazy-seq (cons (first vals)\n                                               (drop-first-match n (rest vals)))))))\n\n        find-path (fn find-path [node edges]\n                    (if (seq edges)\n                      (let [next-edges (filter #(traverse-through node %) edges)]\n                        (when (seq next-edges)\n                          (some (fn [edge]\n                                  (find-path\n                                   (traverse-through node edge)\n                                   (drop-first-match edge edges)))\n                                next-edges)))\n                      true))]\n\n   (true? (some #(find-path % edges) all-nodes))))", "problem": 89, "user": "50e4f4e9e4b049a987753896"}, {"code": "(fn [e] (letfn [\n\t(add-edge [edge graph]\n\t\t(let [e1 (first edge) e2 (last edge)\n\t\t\tadd (fn [from to g]\n\t\t\t\t(if (contains? g from)\n\t\t\t\t\t(let [vertex (g from)]\n\t\t\t\t\t\t(conj g [from {:degree (inc (:degree vertex)) :edges (conj (:edges vertex) to)}])\n\t\t\t\t\t)\n\t\t\t\t\t(conj g [from {:degree 1 :edges #{to}}])\n\t\t\t\t)\n\t\t\t)]\n\t\t\t(->> graph (add e1 e2) (add e2 e1))\n\t\t)\n\t)\n\n\t(graph-from-edges [edges]\n\t\t(loop [graph {} edge (first edges) rst (rest edges)]\n\t\t\t(if edge\n\t\t\t\t(recur (add-edge edge graph) (first rst) (rest rst))\n\t\t\t\tgraph\n\t\t\t)\n\t\t)\n\t)\n\n\t(graph-is-connected? [graph]\n\t\t(letfn [\n\t\t\t(bfs [start]\n\t\t\t\t(loop [nxt (:edges (graph start)) seen #{start}]\n\t\t\t\t\t(if (empty? nxt)\n\t\t\t\t\t\tseen\n\t\t\t\t\t\t(let [cur (first nxt) edges (:edges (graph cur)) other (set (rest nxt)) new-seen (conj seen cur)]\n\t\t\t\t\t\t\t(recur (-> edges (clojure.set/union other) (clojure.set/difference new-seen)) new-seen)\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t\t]\n\t\t\t(= (set (keys graph)) (bfs (first (keys graph))))\n\t\t)\n\t)\n\n\t(tour-exists? [edges]\n\t\t(let [graph (graph-from-edges edges)]\n\t\t\t(and \n\t\t\t\t(graph-is-connected? graph)\n\t\t\t\t(->> graph (filter #(-> % val :degree odd?)) count (>= 2))\n\t\t\t)\n\t\t)\n\t)\n\t]\n\t(tour-exists? e)\n))", "problem": 89, "user": "511cca27e4b00c2a1fa7ff7d"}, {"code": "(fn [g]\n    (and\n     (<= (count (filter odd? (vals (frequencies (apply concat g))))) 2)\n     (let [v (reduce (fn [a [x y]]\n                       (-> a\n                           (assoc x (cons y (a x)))\n                           (assoc y (cons x (a y))))) {} g)\n           t (iterate\n             (fn [[g t]]\n               [(apply dissoc g t)\n                (apply clojure.set/union t (map set (map g t)))])\n             [v #{(ffirst v)}])\n           lg (ffirst \n               (drop-while (fn [[a b]] (not= a b))\n                           (map list t (rest t))))]\n       (= (set (keys v)) (second lg)))))", "problem": 89, "user": "50c9e5e3e4b0a409464667d7"}, {"code": "(fn [paths]\n  (let [cs (seq\n             (reduce\n               (fn [m [a b]] (if (= a b) m (merge-with + m { a 1 b 1 })))\n               {} paths))]\n    (and (not (empty? cs))\n         (contains? #{0 2} (count (filter (comp odd? second) cs))))))", "problem": 89, "user": "50bfe95ce4b080409b860f27"}, {"code": "(fn tour? [g]\n  (let [vertices (into #{} (flatten g))\n        degree   (fn [g, v]\n                   (count (filter #(some (partial = v) %) g)))\n        conn?    (fn [g]\n                   (let [cs   (into #{} (map (partial into #{}) g))\n                         ecls (loop [s   (first cs)\n                                     out #{}\n                                     in  (rest cs)]\n                                (if (empty? in)\n                                  s\n                                  (if (empty? (clojure.set/intersection s (first in)))\n                                    (recur s (conj out (first in)) (rest in))\n                                    (recur (clojure.set/union s (first in)) out (rest in)))))]\n                     (= ecls\n                        (into #{} (flatten (into '() g))))))]\n    (and\n     (conn? (into #{} g))\n     (< (count (filter odd? (map (partial degree g) vertices))) 3))))", "problem": 89, "user": "51365524e4b04ac1f358dd52"}, {"code": "(fn gt [g]\n  (let [e (set (reduce clojure.set/union g))\n        c (count e)\n        s (frequencies (reduce concat g))\n        ones (filter #(= 1 %) (vals s))\n        co (count ones)\n        o g\n        d (distinct g)\n        g (set g)\n        gc (let [f (first g)\n                    filt (fn [x g]\n                           (let [f (fn [v]\n                                     (cond\n                                      (= (first x) (first v)) v\n                                      (= (first x) (last v)) v\n                                      (= (last x) (first v)) v\n                                      (= (last x) (last v)) v\n                                      :else nil))]\n                           (map f g)))]\n                (loop [r #{f}\n                       pr #{}]\n                  (if (= (count r) (count pr))\n                    (= g r)\n                    (recur (clojure.set/union r (disj (apply clojure.set/union\n                                                      (for [x r]\n                                                        (into #{} (filt x g))))\n                                                nil))\n                           r))))]\n    (if (or (not= o d) (> co 2))\n      false\n      gc)))", "problem": 89, "user": "5123ac8ee4b061b4c6f0e0b1"}, {"code": "(fn [[e & g]]\n  (let [is-connected (fn [e f]\n                       (let [he (first e)\n                             hf (first f) \n                             te (last e)\n                             tf (last f)]\n                         (or \n                           (= hf he)\n                           (= tf te)\n                           (= hf te)\n                           (= tf he)\n                           ))) \n        merge-edges (fn [e f]\n                      (let [he (first e)\n                            hf (first f) \n                            te (last e)\n                            tf (last f)]\n                        (cond \n                          (= he hf) (concat (reverse f) e)\n                          (= te tf) (concat e (reverse f))\n                          (= te hf) (concat e f)\n                          (= he tf) (concat f e)\n                          )))\n        next-edge (fn [g e]\n                    (some \n                      #(if (is-connected e %) %)\n                      g))\n        remove-edge (fn [g e]\n                      (into (remove #(= e %) g)\n                            (repeat \n                              (dec (count (filter #(= e %) g)))\n                              e)))] \n    (loop [e e\n           g g]\n      (if (empty? g) true\n        (let [n (next-edge g e)]\n          (if (nil? n)\n            false\n            (recur (merge-edges e n)\n                   (remove-edge g n)))))))\n  )", "problem": 89, "user": "4fbbcf0ce4b081705acca2ee"}, {"code": "(fn [edges]\n  (letfn [(prefer-odd-vertex [] (ffirst (sort-by #(even? (count (second %)))\n                                                 (group-by identity (flatten edges)))))\n          (find-exits [v es]\n            (set (for [[a b _ :as edge] es :when (or (= v a) (= v b))] edge)))\n          (traverse [edge v] (if (= v (first edge)) (second edge) (first edge)))\n          (eulerian? [v es]\n            (if (seq es)\n              (let [exits (find-exits v es)]\n                (if (some #(eulerian? (traverse % v) (disj es %)) exits) true false))\n              true))]\n   (let [v (prefer-odd-vertex)\n         es (set (map-indexed (fn [i [a b]] [a b i]) edges))]\n     (eulerian? v es))))", "problem": 89, "user": "50d93c53e4b0fd36a4b89223"}, {"code": "(fn [test-graph]\n  (letfn [(circle? [edge] \n            (= (first edge) (last edge)))\n          (circles [g]\n            (vec (filter #(circle? %) g)))\n          (doable-graph-with-2-edges? [g]\n            (let [nodes (count (distinct (flatten g)))\n                  circle-nodes (count (circles g))]\n              (cond\n               (= circle-nodes 0) (= nodes 3)\n               (= circle-nodes 1) (= nodes 2)\n               :else false)))\n          (node-with-1-edge [g]\n            (map first (filter #(= (count %) 1)\n                               (partition-by identity (sort (flatten g))))))\n          (disconnected? [g n1 n2]\n            (> (count (distinct (flatten (filter #(or (contains? (set %) n1) (contains? (set %) n2)) g)))) 3))\n          (remove-node [g n]\n            (vec (filter #((complement contains?) (set %) n) g)))\n          (remove-edge [g edge]\n            (vec (concat\n                  (rest (filter #(= (set %) (set edge)) g))\n                  (filter #((complement =) (set %) (set edge)) g))))\n          (doable-circle-graph?\n           ([graph n]\n            (if (empty? graph)\n              true\n              (loop [g graph edges (filter #(contains? (set %) n) g)]\n                (if (empty? edges)\n                  false\n                  (let [edge (first edges)\n                        x (if (= (first edge) n) (last edge) (first edge))]\n                    (if (doable-circle-graph? (remove-edge g edge) x)\n                      true\n                      (recur g (rest edges))))))))\n           ([graph]\n            (doable-circle-graph? graph (first (first graph)))))]\n    (let [g test-graph edge-num (count g)]\n      (cond\n       (= edge-num 0) true\n       (= edge-num 1) true\n       (= edge-num 2) (doable-graph-with-2-edges? g)\n       :else (let [nodes (node-with-1-edge g) node-num (count nodes)]\n               (cond\n                (> node-num 2) false\n                (= node-num 2) (if (disconnected? g (first nodes) (last nodes))\n                                 false \n                                 (doable-circle-graph? (remove-node (remove-node g (first nodes)) (last nodes))))\n                (= node-num 1) (doable-circle-graph? (remove-node g (first nodes)))\n                :else (doable-circle-graph? g)))))))", "problem": 89, "user": "514721c6e4b0d520409ed392"}, {"code": "(fn [E] \n  (let [V (frequencies (flatten E))]\n    ( and (contains? #{0 2} (count (filter (comp odd? second) V )))\n    (= (count V)\n       (count \n         (nth \n           (iterate \n             (fn [cur] (clojure.set/union cur (set (flatten (filter #(some cur %) E))))) \n              #{(-> E first first)}\n              )\n           (count E)\n           )\n         )\n       )\n    )\n    )\n  )", "problem": 89, "user": "514457fbe4b0b4fb4ace5f43"}, {"code": "(fn graph-tour [graph]\n  (let [graphset (set graph)\n\n        ;; reducedgraphset gets rid of all edges [a b] when [b a] exists in the graph                                                                                               \n        reducedgraphset (reduce #(if (contains? %1 [(second %2) (first %2)]) %1 (conj %1 %2)) #{} graphset)\n\n        ;; All of the points we need to visit                                                                                                                                       \n        allpoints (set (reduce #(conj (conj %1 (first %2)) (second %2)) #{} reducedgraphset))\n\n        ;; Helper function for zapping both points of an edge from the                                                                                                              \n        ;; set of all points.                                                                                                                                                       \n        disjedge (fn [ps e] (disj (disj ps (first e)) (second e)))\n\n        ;; Helper function that finds edges that connect to a given                                                                                                                 \n        ;; edge.                                                                                                                                                                    \n        neighbors (fn [gr e] (set (concat (filter #(= (first e) (second %)) gr)\n                                          (filter #(= (second e) (first %)) gr))))\n\n        ;; Function that returns true if there's a set of edges that                                                                                                                \n        ;; hit all the points exactly once.                                                                                                                                         \n        diver (fn diver [graph start-node points-to-visit]\n                (if (empty? points-to-visit)\n                  true\n                  (some true?\n                        (for [move (neighbors graph start-node)]\n                          (diver (disj graph move) move\n                                 (disjedge points-to-visit move))))))]\n\n    ;; Check diver on every node in the set.                                                                                                                                        \n    (or (some true? (for [node reducedgraphset]\n                      (diver (disj (set reducedgraphset) node)\n                             node\n                             (disjedge allpoints node)))) false)))", "problem": 89, "user": "515737f0e4b0b0b4b87062d0"}, {"code": "(fn graph-tour [ edges ]\n  (letfn [(nbmap [col]  ;; collection of edges [[a b] [c d]]\n                 (let [bi-edges (into col (map (fn [e] [(second e) (first e)]) col))]\n                   (reduce (fn [ret e]\n                             (update-in ret [(first e)] (fnil conj #{}) (last e))) {} bi-edges)))\n          (bfs [nbmap q discovered]  \n                  ;; q is PersistentQueue, conj to discovered set when we find a new node, until q is empty.\n                  (let [hd (peek q)   ;;  \n                        hdnb (remove #(contains? discovered %) (nbmap hd))]\n                    (if (empty? hdnb)\n                      discovered\n                      (recur nbmap (into (pop q) hdnb) (reduce #(conj %1 %2) discovered hdnb)))))\n          (stepHd [nbmap q discovered]\n                  ;; stepHd process head and ret a lazy list of node reachable from head.\n                  (when-let [hd (peek q)]\n                    (lazy-seq\n                      (cons hd \n                            (let [hdnb (remove #(contains? discovered %) (nbmap hd))]\n                              (stepHd nbmap (into (pop q) hdnb) (reduce #(conj %1 %2) discovered hdnb)))))))\n          (odd-degrees [edges]\n                      ;; ret the num of nodes that have odd degrees\n                      (let [out-deg-map (reduce (fn [ret e] (update-in ret [(first e)] (fnil inc 0))) {} edges)\n                            in-deg-map (reduce (fn [ret e] (update-in ret [(second e)] (fnil inc 0))) {} edges)\n                            deg-map (merge-with + out-deg-map in-deg-map)\n                            odd-deg (filter (fn [e] (odd? (val e))) deg-map)]\n                        (count odd-deg)))]\n    (let [graph (nbmap edges)\n          root (key (first graph))\n          q (conj clojure.lang.PersistentQueue/EMPTY root)\n          discovered (conj #{} root) \n          stephdcomponent (stepHd graph q discovered)\n          bfscomponent (bfs graph q discovered)]\n      ;;(prn graph)\n      ;;(prn (take 5 (stepHd graph q discovered)))\n      (if (and (= (count bfscomponent) (count (keys graph)))\n               (<= (odd-degrees edges) 2))   ;; at most 2 vertices with odd edges\n        true\n        false))))", "problem": 89, "user": "513cb853e4b0b86ece9f322b"}, {"code": "(fn [C O I F g]\n    (and (<= (count (filter odd? (vals (frequencies (F g))))) 2)\n     (O\n      (reduce\n       (fn [s [f t]]\n         (let [{[a & [r]] true o false :or {o []}}\n               (group-by #(or (C % f) (C % t)) s)]\n           (I #{(I a r)} o)\n           ))\n       (I #{} (map #(hash-set %) (distinct (F g))))\n       g))))\n  contains? #(= 1 (count %)) into flatten", "problem": 89, "user": "4ff67852e4b0678c553fc37e"}, {"code": "(fn [c]\n  (and\n    (>= 2 (count (filter odd? (vals (frequencies (flatten c))))))\n    (let [m (reduce (fn [m [a b]] (merge-with concat m {a [b]})) {} (concat c (map reverse c)))]\n      (loop [q [(ffirst m)]\n             s (set q)\n             u (disj (set (keys m)) (first q))]\n        (let [[a] q]\n          (if (empty? q)\n            (empty? u)\n            (recur (concat (rest q) (remove s (m a)))\n                   (conj s a)\n                   (disj u a))))))))", "problem": 89, "user": "4ebaf790535dfed6da9c6d6e"}, {"code": "(fn ok? [edges]\n  (let [allnodes (set (reduce (fn [result [a b]] (conj result a b)) #{} edges))]\n    (letfn [(accessable-paths [edges start seen]\n              (if (empty? edges)\n                (conj seen start)\n                (for [n (neighbours start edges)]\n                  (flatten\n                   (accessable-paths (if (some #{[start n]} edges)\n                                       (delete-one-route [start n] edges)\n                                       (delete-one-route [n start] edges)) n (conj seen start))))))\n            (neighbours [start edges]\n              (filter #(and (not (nil? %)) (not= start %))\n                      (map (fn [[a b]]\n                             (cond (= a start) b\n                                   (= b start) a\n                                   :else nil)) edges)))\n            (delete-one-route [route edges]\n              (let [cnt (count (filter #{route} edges))\n                    tmp (remove #{route} edges)]\n                (concat tmp (repeat (dec cnt) route))))]\n      (if (some (fn [node]\n                  (if (some #{allnodes}\n                            (map set (accessable-paths edges node []))) (do (println node) true) false)) allnodes) true false))))", "problem": 89, "user": "512eb723e4b0b740abc5982b"}, {"code": "(fn [g]\n    (letfn [(all-nodes [g]\n              (into #{} (concat\n                (map first g)\n                (map second g))))\n            (remove-one [coll val]\n              (loop [[first & rest] coll\n                     result '()]\n                (if (= val first)\n                  (concat result rest)\n                  (recur rest (conj result first)))))\n            (nexts [g n]\n              (concat\n                (for [[x y] g :when (= x n)]\n                  [(remove-one g [x y]) y])\n                (for [[x y] g :when (= y n)]\n                  [(remove-one g [x y]) x])))\n            (walk-from? [g n]\n              (if (empty? g)\n                true\n                (some (fn [[ng nn]] (walk-from? ng nn)) (nexts g n))))]\n      (boolean (some (fn [n] (walk-from? g n)) (all-nodes g)))\n      ))", "problem": 89, "user": "5165a235e4b079ad97ec44ac"}, {"code": "(fn real-euler [colls]\n  (let [nodes (set (flatten (list* colls)))\n        collapse (fn [s] (reduce (fn [x [a b]] (if (or (contains? x [b a]) (= a b)) x (conj x [a b]) )) #{} s))\n        riemann (fn [n] (apply + (range 1 n)))\n        create-trans (fn create-trans [colls]\n                         (let [trans (reduce (fn [x [a b]] \n                          (set (concat x (set (map #(vector a (second %)) (filter #(= b (first %))  colls)))))) \n                                             colls colls)]\n                           (if (= colls trans)  trans (create-trans trans))))\n        is-connected? (fn is-connected? [colls]\n                       (= (riemann (count nodes)) (count (collapse (create-trans (set (concat colls (map (fn [[k l]] [l k]) colls))))))))\n        ]\n (and (is-connected? colls) (case (count (filter (comp odd? count) (vals (group-by identity (flatten colls)))))\n                              2 true 0 true false))))", "problem": 89, "user": "50c8697ce4b00bb60fe0c53f"}, {"code": "(fn [x]\n  (let [vertex-degrees (frequencies (concat (map first x) (map second x)))\n         odd-degrees    (filter odd? (vals vertex-degrees))\n        vertices (keys vertex-degrees)\n        ;Quick union\n        root (fn [eq x]\n               (let [y (eq x)]\n                 (if (= x y)\n                   x\n                   (recur eq y))))\n        union-find (loop [edges x\n                          eqv (zipmap vertices vertices)]\n                     (if-let [edge (first edges)]\n                       (recur (rest edges) (assoc eqv (root eqv (first edge)) (root eqv (second edge)))) eqv ) )\n        connected? (= 1 (count (partition-by (partial root union-find) vertices)))                       \n        ]\n        (and connected? (<= (count odd-degrees) 2))))", "problem": 89, "user": "515f8a0de4b0e2be8aa20bce"}, {"code": "(fn graph-tour? [edges]\n  (let [lte-2-odd-degree?         (>= 2 (count (filter #(odd? (last %))(frequencies (flatten edges)))))\n        connected?                (fn connected? [edges] ;problem 91\n                                    (loop [remaining   edges\n                                           clusters    []]\n                                      (if (empty? remaining)\n                                        (= 1 (count clusters))\n                                        (let [connection (apply hash-set (distinct (first remaining)))\n                                              merged (apply clojure.set/union (conj (filter #(some connection %) clusters) connection))\n                                              others (remove #(some connection %) clusters)]\n                                          (recur (rest remaining)\n                                                 (conj others merged))))))\n        ]\n    (and lte-2-odd-degree? (connected? edges))\n    \n    )\n  \n  \n  )", "problem": 89, "user": "510cd1dde4b078ea71921124"}, {"code": "(fn has-tour?\n  ([edges] (loop [rem-verts (seq (set (mapcat identity edges)))]\n             (if (empty? rem-verts)\n               false\n               (if (has-tour? (first rem-verts) (seq edges))\n                 true\n                 (recur (rest rem-verts))))))\n  ([vertex edges] (if (empty? edges)\n                    true\n                    (loop [i 0]\n                      (if (>= i (count edges))\n                        false\n                        (let [current (first (drop i edges))\n                              others (concat (take i edges) (drop (inc i) edges))]\n                          (cond\n                           (= (first current) vertex)\n                           (if (has-tour? (second current) others)\n                             true\n                             (recur (inc i)))\n                           (= (second current) vertex)\n                           (if (has-tour? (first current) others)\n                             true\n                             (recur (inc i)))\n                           :else\n                           (recur (inc i)))))))))", "problem": 89, "user": "5186134ce4b0da5a5be3bac7"}, {"code": "(fn [graph]\n  (letfn [(step [current-vertice searched-edge graph]\n            (if (= (count searched-edge) (count graph))\n              true\n              (let [next-edges (filter\n                                 #(nil? (some #{%} searched-edge))\n                                 (filter #(some #{current-vertice} %) graph))]\n                (if (seq next-edges)\n                  (true?\n                    (some\n                      true?\n                      (map\n                        #(step\n                           (first (filter (fn [vertice] (not= vertice current-vertice)) %))\n                           (cons % searched-edge)\n                           graph)\n                        next-edges)))\n                  false))))]\n    (step (first (flatten graph)) [] graph)))", "problem": 89, "user": "514d7e29e4b019235f6c0587"}, {"code": "(fn boo [edges]\n  (let \n    [edges (map set edges)\n     nodes (reduce #(into % %2) #{} edges)\n     remove-one (fn [pred coll]\n                  (concat (remove pred coll) (rest (filter pred coll))))\n     other-node (fn [node edge]\n                  (first (filter #(not= node %) edge)))\n     get-next (fn [[node remaining-edges]]\n                (->> remaining-edges\n                  (filter #(% node))\n                  (map (fn [edge]\n                         [(other-node node edge) (remove-one #(= edge %) remaining-edges)]))))\n     start (map #(vector % edges) nodes)\n     result (nth (iterate #(mapcat get-next %) start) (count edges))]\n    (not (empty? result))))", "problem": 89, "user": "50217818e4b00bba4502f7a7"}, {"code": "(fn graph-tour? [edges]\n  (let [undirected-edges (->> edges (filter (partial apply not=)) (map set) set)\n        edges-count (count undirected-edges)\n        nodes (->> edges (map set) (reduce clojure.set/union))\n        nodes-count (count nodes)\n        adjacent-edges (fn [node] (clojure.set/select #(contains? % node) undirected-edges))\n        adjacent-nodes (fn [node] (let [other-node (fn [edge] (if (= (first edge) node) (second edge) (first edge)))]\n                                    (->> (adjacent-edges node) (map other-node) set)))\n        fixed-point (fn [f x] (let [[[y z]] (->> (iterate f x) (partition 2 1) (drop-while (partial apply not=)))] y))\n        visit (fn [nodes] (->> (map adjacent-nodes nodes) (reduce clojure.set/union) (clojure.set/union nodes)))\n        connected? (= nodes (fixed-point visit #{(some nodes nodes)}))\n        degree (fn [node] (count (adjacent-edges node)))]\n    (or (and (= nodes-count 2) (= edges-count 1))\n        (and connected? (every? (comp even? degree) nodes)))))", "problem": 89, "user": "51729002e4b044b2ef48a850"}, {"code": "(fn tour-exist? [edges] (if (nil? ((fn tour [path edges]                                                         \n  (if (empty? edges)                                                                                               \n    true                                                                                                           \n    (let [[s e] path                                                                                               \n          e1-s (filter #(= (first %) s) edges)                                                                     \n          e2-s (filter #(= (last %) s) edges)                                                                      \n          e1-e (filter #(= (first %) e) edges)                                                                     \n          e2-e (filter #(= (last %) e) edges)]                                                                     \n      (or (some #(tour [(last %) e] (disj edges %)) e1-s)                                                          \n          (some #(tour [(first %) e] (disj edges %)) e2-s)                                                         \n          (some #(tour [s (last %)] (disj edges %)) e1-e)                                                          \n          (some #(tour [s (first %)] (disj edges %)) e2-e))))) (first edges) (set (rest edges)))) false true))", "problem": 89, "user": "51899891e4b0288ada3dbdab"}, {"code": "(fn [g]\n   (let [e (set (mapcat (fn [[x y]] [[x y] [y x]]) g))\n         node (set (apply concat e))\n         one-node (first node)\n         deg (frequencies (apply concat g))\n         is-connected (loop [visited #{one-node} unvisited (disj node one-node)]\n                        (if-let [new-node (seq\n                                            (filter\n                                              (fn [x] (some #(e [x %]) visited))\n                                              unvisited))]\n                          (recur (into visited new-node) (reduce disj unvisited new-node))\n                          (empty? unvisited)))\n         ]\n     (and (->> deg vals (filter odd?) count (>= 2)) is-connected)))", "problem": 89, "user": "519b2570e4b0ac1b7dced6a3"}, {"code": "(fn [g]\n  (letfn [(c [m l a]\n             (if (= l a)\n               (= (set (keys m)) a)\n               (recur\n                 m\n                 a\n                 (reduce\n                   #(into % (m %2))\n                   a\n                   a))))]\n    (let [a (reduce\n              (fn [x [k v]]\n                (update-in x [k] conj v))\n              {}\n              g)\n          b (reduce\n              (fn [x [v k]]\n                (update-in x [k] conj v))\n              {}\n              g)\n          m (merge-with into a b)]\n      (and (->> m\n                vals\n                (filter #(odd? (count %)))\n                (#(< (count %) 3)))\n           (c m #{} #{(ffirst m)})))))", "problem": 89, "user": "51b3f109e4b0f094dd986fa9"}, {"code": "(fn tour [g]\n  (let [rf (fn [s e]\n             (let [p (split-with #(not= % e) s)]\n               (concat (-> p first)\n                       (-> p second rest))))\n        t (fn t [current seen remaining]\n            (let [nexts (filter #(or (= current (first %))\n                                      (= current (last %)))\n                                remaining)]\n              (cond\n               (empty? remaining) true\n               (empty? nexts) false\n               :e (reduce #(or %1 %2)\n                          (map #(t (first (filter (fn [x] (not= current x)) %))\n                                   (conj seen %)\n                                   (rf remaining %)\n                                   ) nexts)))\n\n\n              ))\n\n        ]\n\n    (t (ffirst g) [] g)\n    ))", "problem": 89, "user": "4fa340b4e4b081705acca18c"}, {"code": "(fn tour? [g]\n  (letfn [(nodes [g] (set (apply concat g)))\n          (node-in-edge? [n [n1 n2]] (or (= n n1) (= n n2)))\n          (node-edges [g n] (filter (partial node-in-edge? n) g))\n          (other-end [[e1 e2] n] (if (= n e1) e2 e1))\n          (graph-without-edge [[h & t] e] (if (= h e) t (cons h (graph-without-edge t e))))\n          (last-edge? [[e & g] n] (and (empty? g) (node-in-edge? n e)))\n          (tour-starting? [g n] (or (last-edge? g n) (some (fn [e] (tour-starting? (graph-without-edge g e) (other-end e n))) (node-edges g n))))]\n    (true? (some (partial tour-starting? g) (nodes g)))))", "problem": 89, "user": "51672d15e4b079759a74a5e7"}, {"code": "(fn [v] (loop [c v x (last (last v))]\n(cond \n(empty? c) true\n(some \n#(or (= x (first %)) \n(= x (second %))) c)\n(recur (vals (dissoc \n(zipmap (range (count c)) c)\n(first (for [i (range (count c)) \n:when (= \n((zipmap (range (count c)) c) i)\n  (some #(if (or (= x (first %)) \n(= x (second %))) %) c) )] i))))\n(let [[m n] (some #(if (or (= x (first %)) \n(= x (second %))) %) c)] \n(if (= x m ) n m)))\n :else false)\n))", "problem": 89, "user": "517945dce4b0684c1c981a43"}, {"code": ";; dfs\n(letfn [(matching-edges [edges node]\n          (filter #((set %) node) edges))\n        (other-node [edge node]\n          (if (= node (first edge))\n            (second edge)\n            (first edge)))\n        (remove-one [edges edge]\n          (concat (rest (filter (partial = edge) edges))\n                  (filter (partial not= edge) edges)))\n        (tour-from [edges node]\n          (if (empty? edges)\n            '()\n            (some identity\n                  (for [edge (matching-edges edges node)]\n                    (when-let [tour (tour-from (remove-one edges edge) (other-node edge node))]\n                      (cons edge tour))))))\n        (graph-tour [edges]\n          (boolean\n            (some identity\n                  (for [node (set (mapcat identity edges))]\n                    (tour-from edges node)))))]\n  graph-tour)", "problem": 89, "user": "50b668dde4b08fb537db98f2"}, {"code": "(letfn [\n    (connected? [e] (if (>= 1 (count e)) true (let [\n        v1  (ffirst e)\n        in  (for [ei e :when (= v1 (second ei))] (first  ei))\n        out (for [ei e :when (= v1 (first  ei))] (second ei))\n        e1  (filter (partial not= v1) (concat in out))]\n        (if (empty? e1) false\n            (recur (remove #(some #{v1} %) e))))))\n    (even-degree? [e] (>= 2 (count (remove even? (vals (frequencies (flatten e)))))))\n    (tour? [e] (and (connected? e) (even-degree? e)))]\n    tour?)", "problem": 89, "user": "51cbdee1e4b08d8387cbede1"}, {"code": "#(letfn [(vertices [e] (set (flatten e)))\n\n           (no-isolated-vs? [e]\n             (= (vertices e)\n                (vertices (filter (fn [[a b]] (not= a b)) e))))]\n\n     (and (no-isolated-vs? %)\n          (->> %\n               flatten\n               frequencies\n               vals\n               (filter odd?)\n               count\n               (> 3))))", "problem": 89, "user": "51b9d1f0e4b0e871ca49590b"}, {"code": "(fn [edges]\n  (letfn [(remove-ele [coll idx]\n                      (into (subvec coll 0 idx) (subvec coll (inc idx) (count coll))))\n          (find-point [point edge]\n                      (cond (= point (first edge)) (second edge)\n                            (= point (second edge)) (first edge)\n                            :else nil))\n          (connect? [point coll]\n                        (if (empty? coll) true\n                          (reduce #(or % \n                                       (let [e (nth coll %2) t (find-point point e)]\n                                         (if (nil? t) false\n                                           (connect? t (remove-ele coll %2)))))\n                                  false (range (count coll)))))]\n    (reduce #(let [v1 (nth edges %2) v2 (remove-ele edges %2)]\n               (or % (connect? (first v1) v2) (connect? (second v1) v2)))\n           false (range (count edges)))))", "problem": 89, "user": "51780f88e4b03d69594194c9"}, {"code": "(fn [edges]\n  (let [remove-first (fn [v elt]\n                       (let [index (.indexOf v elt)]\n                         (if (>= index 0)\n                           (vec (concat (subvec v 0 index) (subvec v (inc index))))\n                           v)))\n        directed->undirected (fn f [f]\n                               (fn [graph a b]\n                                 (if (= a b)\n                                   (f graph a b)\n                                   (f (f graph a b) b a))))\n        add1-edge (fn [graph from to] (assoc graph from (conj (graph from []) to)))\n        add-edge (directed->undirected add1-edge)       \n        remove1-edge (fn [graph from to]\n                       (let [nodes (graph from)]\n                         (cond\n                          (nil? nodes) graph\n                          (= nodes [to]) (dissoc graph from)\n                          :else (assoc graph from (remove-first nodes to)))))\n        remove-edge (directed->undirected remove1-edge)\n        traverse (fn traverse [graph node]\n                   (cond\n                    (zero? (count graph)) true\n                    (nil? (graph node)) false\n                    :else (boolean (some (fn [next-node]\n                                           (traverse (remove-edge graph node next-node) next-node))\n                                         (graph node)))))\n        graph (reduce (fn [graph [a b]] (add-edge graph a b)) {} edges)]\n    (boolean (some (partial traverse graph) (keys graph)))))", "problem": 89, "user": "507b7dbee4b09034bfeeb71e"}, {"code": "(fn [edges]\n    (let [nodes (reduce\n                 (fn [mp [a b]] (->>\n                                (if (mp a) (assoc mp a (cons b (mp a)))\n                                        (assoc mp a [ b]))\n                                (#(if (% b) (assoc % b (cons a (% b)))\n                                      (assoc % b [ a])))\n                                )) {} edges)\n\n          onodes (reduce #(if (odd? (count (val %2))) (inc %) %) 0 nodes)\n\n          gset (loop [a (set (first edges))]\n                 (let\n                     [b (->> (filter #(some (fn [x] (a x)) %) edges)flatten set)]\n                     (if (= (count a) (count b) ) b (recur b))))\n          \n          ] (and (> 3 onodes) (= (count gset) (count (keys nodes)) ))\n      ))", "problem": 89, "user": "5124619ae4b02c3f2a072ccd"}, {"code": "(fn oh-rly? [g & [prev]]\n  (or\n   (empty? g)\n   (true? (some #{true}\n                (for [i (range (count g)) :let [e1 (g i) e2 (reverse e1)]\n                      e [e1 e2] :when (or (nil? prev) (= (first e) (second prev)))]\n                  (oh-rly?\n                   (vec (concat\n                         (subvec g 0 i)\n                         (subvec g (inc i) (count g))))\n                   e))))))", "problem": 89, "user": "511d6a01e4b022853b0e07a5"}, {"code": "(let [a #(contains? (set %) true)\n      d (fn [c i] (keep-indexed #(if (not= (.indexOf c i) %) %2) c))]\n  (fn f ([m] (a (for [i m] (f (d m i) i))))\n    ([m [_ g]]\n      (or (empty? m)\n          (a (for [i m] \n               (let [[j k] i\n                     z #(f (d m i) %)]  \n                 (if (= j g) (z i)\n                   (if (= k g) (z [k j]))))))))))", "problem": 89, "user": "512f06c5e4b0762be4c7aad7"}, {"code": "(fn [es]\n  (letfn [(inc' [i] \n            (if i (inc i) 1))\n          (hist [xs]\n            (reduce (fn [r x] (update-in r [x] inc'))\n                    {}\n                    xs))\n          (fixed-point [f v]\n            (let [v' (f v)]\n              (if (= v v')\n                v\n                (recur f v'))))\n          (expand [r]\n            (let [rmap (reduce #(update-in %1 [(first %2)] conj (second %2)) {} r)]\n              (into r (mapcat (fn [[k vs]] \n                                (map #(vector k %) (mapcat rmap vs)))\n                              rmap))))\n          (transitive-closure [r]\n            (fixed-point expand (set r)))\n          (connected? [es]\n            (let [vs        (into #{} (flatten es))\n                  tc        (transitive-closure es)\n                  reachable (conj (->> tc\n                             (filter #(= (ffirst es) (first %)))\n                             (map last)\n                             (into #{}))\n                                  (ffirst es))]\n              (= reachable vs)))]\n    (let [es'     (remove (fn [[u v]] (= u v)) es)\n          degrees (vals (hist (flatten es')))]\n      (and (connected? es)\n           (contains? #{0 2} (count (filter odd? degrees)))))))", "problem": 89, "user": "51eff839e4b0249c592fbdf1"}, {"code": "(fn [graph]\n    (letfn [(nodes [g] (set (flatten g)))\n            (neighbors [g]\n              (let [g (filter #(apply not= %) g)]\n                (reduce\n                 (fn [m [orig dest]]\n                   (update-in m [orig] (fnil conj []) dest))\n                 {}\n                 (concat g (map reverse g)))))\n            (connected? ;; This is a simplified DFS to determine connectivity\n                ([g]\n                   (if (empty? g)\n                     true\n                     (connected? g [(first (nodes g))] #{})))\n                ([g q marked]\n                   (let [nbrs (neighbors g)]\n                     (if (empty? q)\n                       (= (count marked) (count (nodes g)))\n                       (let [cur (peek q)]\n                         (if-not (marked cur)\n                           (connected?\n                            g (reduce conj (pop q) (nbrs cur))\n                            (conj marked cur))\n                           (connected? g (pop q) marked)))))))]\n      (and (connected? graph)\n           (let [odd-ranked-nodes (for [[node nbrs] (neighbors graph)\n                                        :when (odd? (count nbrs))] node)]\n             (or (= 2 (count odd-ranked-nodes))\n                 (= 0 (count odd-ranked-nodes)))))))", "problem": 89, "user": "50bca033e4b0594b91591c5d"}, {"code": "(fn gc [s]\n  (letfn [(path-res [prem autres]\n                   (if (empty? autres)\n                     (if (= (count prem) (count s))\n                       true\n                       false)\n                     (for [e autres]\n\t\t\t\t\t\t(let [res (connect (last prem) e)]\n                       (if (not (first res))\n                         false\n                         (path-res (conj prem (if (= (second res) :f) e (reverse e))) (filter #(not= e %) autres)))))))\n\t\t\t(connect [[w x] [y z]]\n\t\t\t\t(if (= x y)\n\t\t\t\t\t[true :f]\n\t\t\t\t\t(if (= x z)\n\t\t\t\t\t\t[true :l]\n\t\t\t\t\t\t[false :n])))]\n\t\t\t\t\t\t \n    (if (some #{true} (flatten (for [prem s]\n                                 (let [autres (filter #(not= prem %) s)]\n                                   (path-res [prem] autres))))) true false)))", "problem": 89, "user": "51c09719e4b0c9c82288293c"}, {"code": "(fn [lst] \n\t(let [nodes (distinct (reduce concat lst))\n\t\t  uni (distinct (concat lst (map reverse lst)))\n\t\t  adj (into {}\n\t\t\t(->> uni\n\t\t\t\t(group-by first) \n\t\t\t\t(map \n\t\t\t\t\t(fn [[a,b]] \n\t\t\t\t\t\t[a, (map last b)]))))\n\t\t  nxt #(distinct (concat % (mapcat adj %)))\n\t\t  sqnc (iterate nxt (list (first nodes)))\n\t\t  conv (first (first (filter (fn [[a,b]] (= a b))(partition 2 sqnc))))\n\t\t  edj (filter (fn [[a,b]] (not (= a b))) lst)\n\t\t  grp (group-by identity (reduce concat edj))\n\t\t  cnt (map #(count (last %)) grp)\n\t\t  odd (filter odd? cnt)]\n\t\t  (and \n\t\t  \t(= (into #{} nodes) (into #{} conv))\n\t\t  \t(<= (count odd) 2))))", "problem": 89, "user": "4ec0c7ba535dfed6da9c6da4"}, {"code": "(fn [v]\n    (let [  g-assoc (fn [m k v] (assoc m k (set (conj (m k) v))))\n            g (reduce (fn [m [a b :as e]] (g-assoc (g-assoc m a e) b e)) {} v)\n            get-edge (fn [e x] (first (filter #(e %1) (g x))))\n            get-vertex (fn [e x] (if (= x (first e)) (second e) (first e)))\n            ]\n        ((fn [ edges b e ]\n            (if (empty? edges)\n                true\n                (let [ b-edge (get-edge edges b)\n                       e-edge (get-edge edges e)\n                       nb (get-vertex b-edge b)\n                       ne (get-vertex e-edge e)\n                       ]\n                    (cond\n                        nb (recur (disj edges b-edge) nb e)\n                        ne (recur (disj edges e-edge) b ne)\n                        :else false ))))\n            (set v) (ffirst v) (second (first v)))))", "problem": 89, "user": "51f59607e4b0abb92f97f9d5"}, {"code": "(fn [edge-vecs]\n    (let [all-edges (map set edge-vecs)\n          path-freq #(frequencies (map set %))\n          tour-freqs (frequencies all-edges)\n          tour? (fn [path] (= (path-freq path) tour-freqs))\n          step (fn [path]\n                 (let [path-freqs (path-freq path)\n                       required-edge (fn [edge] \n                                       (< (path-freqs edge 0)\n                                          (tour-freqs edge)))\n                       required-edges (set (filter required-edge all-edges))\n                       current-node (last (last path))\n                       allowed-edge (fn [edge] (edge current-node))\n                       allowed-edges (filter allowed-edge required-edges)\n                       next-node (fn [edge] (if (= 1 (count edge))\n                                              (first edge)\n                                              (first (filter (partial not= current-node) edge))))]\n                   (map #(conj path [current-node (next-node %)]) allowed-edges)))\n          starting-paths (set (mapcat\n                                #(vector [[(first %) (second %)]] [[(second %) (first %)]])\n                                edge-vecs))]\n      (loop [paths starting-paths]\n        (if (some tour? paths)\n          true\n          (let [stepped-paths (set (mapcat step paths))]\n            (if (= paths stepped-paths)\n              false\n              (recur stepped-paths)))))))", "problem": 89, "user": "5141abf1e4b02fd87f5064c3"}, {"code": "(fn [in]\n           (or (= 1 (count in))\n               (every? even? (map count (map (partial remove nil?)\n                                             (for [s (set (flatten in))]\n                                               (map (fn [[a b]] (when (or (= a s) (= b s)) [s [a b]])) in)))))))", "problem": 89, "user": "50a5b7e9e4b0aa96157e2610"}, {"code": ";Could have been such small and nice solution if connectivity was assumed :(\n(fn [e]\n  (letfn [(neigtbors [x edges]\n                     (->> edges \n                          (filter #(or (= x (first %)) (= x (second %))))\n                          flatten\n                          set))\n          \n          (connected? [visited frontier edges]\n                      (if (empty? frontier)\n                        (= (count visited) (->> edges vec flatten distinct count))\n                        (connected? (clojure.set/union visited frontier)\n                                    (clojure.set/difference \n                                     (apply clojure.set/union (map #(neigtbors % edges) frontier))   \n                                     (clojure.set/union frontier visited)) edges)))\n          ]\n    (and \n     (->> \n      (merge-with concat (group-by first e) (group-by second e))\n      (map #(count (second %)))\n      (filter odd?)\n      count\n      (>= 2))\n     (connected? #{} (set [(->> e first first)]) e))))", "problem": 89, "user": "5054bc87e4b0b1b9d1860eb0"}, {"code": "(fn gt [p] \n  (let [g (map (comp set #(map (comp keyword str) %)) p)\n        v (first g)\n        next-edge (fn [to from graph]\n                    (case (count graph)\n                      1 (first (filter to graph))\n                      (first (remove #{#{to from}} (filter to graph)))))]\n  (if (or (not= (count (set g)) (count p))\n          (some #(not= (count %) 2) g)) false\n    (loop [start (first v) \n           end (second v) \n           graph (remove #{v} g)] \n      (if-not (empty? graph)\n        (let [forward (next-edge end start graph)]\n          (if forward \n            (recur start (first (remove #{end} forward)) (remove #{forward} graph))\n            (let [backward (next-edge start end graph)]\n              (if backward \n                (recur (remove #{start} backward) end (remove #{backward} graph))\n                false))))\n        true)))))", "problem": 89, "user": "50c781bbe4b00bb60fe0c535"}, {"code": "(fn [s]\n  (let [p (group-by first (concat s (map reverse s)))\n        g (zipmap (keys p)\n                  (map #(map second %) (vals p)))]\n    (and (>= 2 (count (filter odd? (map (comp count second) g))))\n         (loop [v #{(ffirst g)}]\n            (let [x (select-keys g v)\n                  y (apply conj v (flatten (vals x)))]\n              (or (= g x) (and (not= v y)\n                            (recur y))))))))", "problem": 89, "user": "4e7dfab0535db169f9c796f9"}, {"code": "(fn [edges]\n\t(if (= 2 (count edges)) false\n\t(->>\n\t\t(reduce #(if (% %2) \n\t\t\t\t\t\t\t(assoc % %2 (inc (% %2)))\n\t\t\t\t\t\t\t(assoc % %2 1))\n\t\t\t{} (flatten edges))\n\t\tvals\n\t\t(filter odd?)\n\t\tcount \n\t\t(>= 2))))", "problem": 89, "user": "520242bae4b030ee0c5b26e3"}, {"code": "(fn eulerian [edges]\n  (let [degrees (fn [edges]\n                  (apply merge-with + {} (for [[a b] edges\n                                               :when (not= a b)]\n                                           {a 1 b 1})))\n        gdeg (degrees edges)]\n    (and\n     (not (empty? gdeg))\n     (->> (vals gdeg) (filter odd?) count (>= 2)))))", "problem": 89, "user": "5032b066e4b00c0952a257ea"}, {"code": "(fn [g]\n  (and \n    (->> g (mapcat seq) frequencies vals (filter odd?) count #{0 2} boolean)\n    ((fn f [e] \n       (#(if (= e %) (= % (set g)) (f %)) \n          (reduce (fn [a b] (into a (filter #(some (set b) %) (set g)))) \n                  #{} \n                  e))) \n       #{(first g)})))", "problem": 89, "user": "51ba8f82e4b0fe3ecfb46434"}, {"code": "(fn [m]\n  (let [xs (group-by first (concat (map (comp vec reverse) m) m))\n        circle? #(and (= (first %) (last %)) (= (dec (count %)) (count xs)))\n        f1 #(map (fn [x] (conj % (last x))) (xs (last %)))\n        f2 #(filter (partial apply distinct?) %)]\n    (loop [k (second (first xs))]\n      (if (or (empty? k) (false? (apply distinct? k)))\n        false\n        (if (some circle? k)\n          true\n          (recur (mapcat f1 (f2 k))))))))", "problem": 89, "user": "5201572be4b0d7096e99ddbb"}, {"code": "(fn [edge-list] \n  (letfn\n    [(count-odd-nodes [graph]\n        (->> graph \n             flatten \n             frequencies \n             vals \n             (filter odd?)\n             count))\n     (merge-nodes [edge-set]\n       (letfn\n         [(test-intersection [a b]\n           ((complement empty?) (clojure.set/intersection a b)))\n          (merge-intersecting [coll itm]\n           (if (some (partial test-intersection itm) coll)\n             (set (map \n               (fn [a]\n                 (if (test-intersection a itm) (clojure.set/union a itm) a)) \n               coll))\n             (conj coll itm)))]\n        (let [merged (reduce (fn [acc itm] (merge-intersecting acc itm)) #{} edge-set)]\n          (if (= merged edge-set)\n              merged\n              (merge-nodes merged)))))]\n  (and \n    (#(or (= % 0) (= % 2)) (count-odd-nodes edge-list)) \n    (= 1 (count (merge-nodes (set (map set edge-list))))))))", "problem": 89, "user": "521e8227e4b0dd19981ad082"}, {"code": "(fn [edges]\n  (let [nodes (reduce #(conj % (first %2) (second %2)) #{} edges)]\n    (letfn [(rm-edge [edges e] ;remove one (and only one) matching edge\n              (second (reduce #(if (= %2 (first %)) [nil (second %)] [e (conj (second %) %2)]) [e []] edges)))\n\n            (next-node [edge node] ;the node on the \"other\" end of an edge that touches node\n              (if (= node (first edge)) (second edge) (first edge)))\n\n            (edges-here [edges node] ;list of edges that touch the given node\n              (filter #(or (= node (first %)) (= node (second %))) edges))\n\n            (tour [edges node] ;recursive tour from the given node\n              (let [available-edges (edges-here edges node)]\n                (if (empty? available-edges)\n                 (when (empty? edges) [true])\n                 (reduce concat (map #(tour (rm-edge edges %) (next-node % node)) available-edges)))))]\n      \n      (if (some true? (reduce concat (map #(tour edges %) nodes))) true false))))", "problem": 89, "user": "52015698e4b0d7096e99ddba"}, {"code": "(fn [edges]\n  (let [updated (fn [dict key val]\n                  (conj (dict key '()) val))\n        add-edge (fn [adj [from to]]\n                   (into adj [[from (updated adj from to)]\n                              [to (updated adj to from)]]))\n        adj (reduce add-edge {} edges)\n        start (first (first edges))\n        desired (count (keys adj))\n        neighbors (fn [v vis] (clojure.set/difference (set (adj v)) vis))\n        connected? (loop [[x & _ :as all] (list start) vis #{}]\n                    (cond\n                      (empty? all) (= (count vis) desired)\n                      :else (recur\n                              (concat (rest all) (neighbors x vis))\n                              (conj vis x))))\n        satisfies? (->> adj\n                        vals\n                        (map count)\n                        (filter odd?)\n                        count\n                        (> 3))]\n    (and satisfies? connected?)))", "problem": 89, "user": "514c2d05e4b02b8cbb2a9278"}, {"code": "(fn [s]\n  (let [exp (fn [a b] (if (seq (filter a b)) (set (remove a b)) nil))\n        conn? (fn [r q] (let [nr (reduce into r (map #(exp r %) q))]\n                            (if (= r nr)\n                              (= r (set (flatten s)))\n                              (recur nr q))))]\n    (if (conn? (set (first s)) (map set (next s)))\n      (> 3 (count (filter (comp odd? val) (frequencies (flatten s))))) \n      false)))", "problem": 89, "user": "522b922ee4b0d34ee08e71c3"}, {"code": "(fn [graph]\n  (letfn [\n    (all-nodes [paths]\n      (reduce #(conj % (first %2) (last %2)) #{} paths))\n    (connect-paths [paths]\n      (let [sorted-paths (sort-by first (map sort paths))\n            first-path (first sorted-paths)]\n      (reduce \n        #(if (or (% (first %2)) (% (last %2))) \n          (conj % (first %2) (last %2))\n          %)\n        (reduce conj #{} first-path)\n        sorted-paths)))\n    (all-connected? [paths]\n       (= (all-nodes paths) (connect-paths paths)))\n    (visit-only-once? [graph]\n      (or (= 1 (count graph))\n       (every? even? (vals (frequencies (flatten (map seq (set (map set graph)))))))))]\n   (and (all-connected? graph) (visit-only-once? graph))))", "problem": 89, "user": "501c1492e4b086d93747d180"}, {"code": "(fn [g]\n  (letfn\n    [(rm [edge edges] (->> edges (split-with #(not= edge %)) (#(->> % second rest (concat (first %))))))\n      (pass? [s edges]\n      (if (empty? edges) true\n        (let [paths (filter #(% s) edges)]\n          (if (empty? paths) false\n            (some #(pass? (first (disj % s)) (rm % edges)) paths)))))]\n    (true? (some #(pass? % (map set g)) (-> g flatten set)))))", "problem": 89, "user": "523b1988e4b02f719975bdbc"}, {"code": "(fn [edges]\n  (let [edges (concat edges (map reverse edges))\n        nodes (set (map first edges))\n        conn \n        (= nodes \n           (loop [s #{(first nodes)}]                  \n             (if-let [news (seq (for [i s j nodes :when (and (not (s j)) ((set edges) [i j]))] j))]\n               (recur (into s news))\n               s)))\n        degs \n        (zipmap nodes \n                (map #(count (filter #{%} (map first edges))) nodes))]\n    (and \n     (>= 2 (count (filter #(odd? (second %)) degs)))\n     conn)))", "problem": 89, "user": "51944aaae4b0142f60b4aedc"}, {"code": "(fn graph-tour [m]\n  (letfn [(enumerate-graph [edges v]\n            (let [next-vs (filter #(contains? (val %) v) edges)]\n              (cond\n               (empty? edges) true\n               (empty? next-vs) false\n               :else (some true? (map #(enumerate-graph (dissoc edges (key %))\n                                                        (-> (val %) (disj v) first)) next-vs)))))]\n   (let [edges (->> (map set m) (interleave (range)) (apply hash-map))\n         v (-> edges first val first)]\n     (true? (enumerate-graph edges v)))))", "problem": 89, "user": "523b82efe4b07becd5be21f0"}, {"code": ";; Per Euler, the only traversable networks are those that have either\n;; no odd-degree vertices or exactly two odd-degree vertices.\n#(let [d (vals (frequencies (flatten (filter (fn [[x y]] (not (= x y))) %))))]\n   (cond (empty? d) false\n         (not-any? odd? d) true\n         :else (= (count (filter odd? d)) 2)))", "problem": 89, "user": "4f2d5f5de4b0d6649770a05a"}, {"code": "(fn [edges]\n  (let [remove-once (fn [ce e] \n                      (let [sp (split-with (partial not= e) ce)] \n                        (concat (first sp) (rest (second sp)))))\n        longer-paths (fn [ps [e1 e2]]\n                       (let [h (ffirst ps) t (second (last ps))]\n                         (if (empty? ps)\n                           (list (list [e1 e2]))\n                           (filter identity \n                                 (list\n                                   (if (= h e2) (conj ps [e1 e2]))\n                                   (if (= h e1) (conj ps [e2 e1]))\n                                   (if (= t e1) (concat ps (list [e1 e2])))\n                                   (if (= t e2) (concat ps (list [e2 e1]))))))))\n        solutions (fn [ss]\n                    (if (or (empty? ss) (some (comp empty? first) ss)) ss  \n                      (recur \n                        (set (mapcat (fn [s]\n                                       (let [ce (first s)] \n                                         (mapcat (fn [e] \n                                                   (let [re (remove-once ce e) \n                                                         ps (second s)]\n                                                     (map #(list re %) \n                                                          (longer-paths ps e)))) \n                                                 ce))) \n                                     ss)))))]\n    (boolean (seq (solutions (hash-set (list edges '())))))))", "problem": 89, "user": "5246e945e4b0644eb7b0783b"}, {"code": "(fn [edges]\n  (let [to-map #(reduce\n                 (fn [m [k v]] (merge-with clojure.set/union m {k (set [v])}))\n                 {}\n                 %)\n        out-m (to-map edges)\n        in-m (to-map (map reverse edges))\n        all-nodes (set (concat (keys out-m) (keys in-m)))\n        edge? (fn [x y] (or (contains? (get out-m x) y)\n                            (contains? (get in-m x) y)))\n        edge-ends (fn [x] (set (filter #(edge? x %) all-nodes)))\n                    \n        out-degree (fn [x] (count (get out-m x)))\n        in-degree (fn [x] (count (get in-m x)))\n        degrees (map #(+ (out-degree %) (in-degree %)) all-nodes)\n        odd-degrees (filter odd? degrees)\n        und-connected? (fn [nodes]\n                         (loop [reachable (set [(first nodes)])]\n                           (let [reachable' (reduce clojure.set/union\n                                                    reachable\n                                                    (map edge-ends reachable))]\n                             (if (= reachable reachable')\n                               (= reachable all-nodes)\n                               (recur reachable')))))]                           \n    (and\n     (<= (count odd-degrees) 2)\n     (und-connected? all-nodes)\n     (= (count edges) (count (set edges))))))", "problem": 89, "user": "524cdd51e4b0752c4cb68ccc"}, {"code": "(fn [x]\n  (let [connected ;\u5224\u65ad\u662f\u5426\u8fde\u901a\n    (loop [src (rest x) temp (first x)]\n      (if (empty? src) ;\u8d70\u904d\u6240\u4ee5\u8282\u70b9\uff0c\u8fde\u901a\n          true\n        (let [found (filter #(some (set temp) %) src)]\n          (if (empty? found);\u627e\u4e0d\u5230\u7684\u8bdd\uff0c\u81f3\u5c11\u5206\u62102\u5757\uff0c\u4e0d\u8fde\u901a\n              false\n            (recur (remove (set found) src) (apply concat temp found))))));\u4ece\u6e90\u91cc\u53bb\u9664\u8fd9\u4e00\u6b65\u627e\u5230\u7684\u90e8\u5206\uff0c\u5e76\u52a0\u5165\u5230\u4e4b\u524d\u627e\u5230\u7684\u90e8\u5206\u91cc\n        count-odd #(count (filter (comp odd? second) (frequencies (flatten %))))];\u8ba1\u7b97\u5947\u6570\u5ea6\u7684\u7ed3\u70b9\u7684\u4e2a\u6570\n    (and connected (contains? #{0 2} (count-odd x)))))", "problem": 89, "user": "51d28e15e4b0d13b04db0d9b"}, {"code": "(fn [g]\n   (let [v (set (flatten g))\n         ec (map\n             (fn [a] \n               (count (filter (fn [e] (or (= (first e) a) (= (second e) a))) g))\n               )\n             v)\n         oc (count (filter odd? ec))\n         conn (fn [es]\n                (let [vs (-> es seq flatten distinct set)]\n                  ((fn conn [es cv]\n                     (let [\n                           ncv (->\n                                (map\n                                 (fn [x] (filter #(or (= (first %) x) (= (second %) x)) es))\n                                 cv)\n                                flatten distinct set\n                                )\n                           ]\n                       (if (= ncv vs)\n                         true\n                         (if (= ncv cv)\n                           false\n                           (conn es ncv)\n                           ))\n                       )\n                     ) es #{(first vs)})\n                  )\n                )]\n     (and (or (= oc 2) (= oc 0)) (conn g))))", "problem": 89, "user": "52586d24e4b0cb4875a45cb0"}, {"code": "(fn tour [g]\n  (let [odd (count (remove even? (map val (frequencies (flatten g))))) \n        graph (fn [g]\n                (let [edges (clojure.set/union g (map reverse g))\n                      n1 (group-by first edges)\n                      nd (fn [x] {(first x) (map second (second x))})\n                      nodes (into {} (mapcat nd n1))]\n                  (loop [visited {}\n                         q [(first nodes)]]\n                    (if (empty? q) (= nodes visited)\n                        (let [x (first q)\n                              nxt (filter #(contains? (set (val x)) (key %)) nodes)]\n                          (if (get visited (key x))\n                            (recur visited (rest q))\n                            (let [v2 (merge visited x)\n                                  q2 (concat (rest q) nxt)]\n                              (recur v2 q2))))))))]\n    (and (or (zero? odd) (= 2 odd)) (graph g))))", "problem": 89, "user": "4fbd12a5e4b081705acca2fd"}, {"code": "(fn [graph] (letfn [\n\n(init-dmap [graph]\n  (apply hash-map\n         (interleave\n           (distinct (flatten graph))\n           (repeat 0))))\n\n(update-degree [dmap edge]\n  (let [k1 (first edge)\n        v1 (inc (get dmap k1 0))\n        k2 (last edge)\n        v2 (inc (get dmap k2 0))]\n  (-> (assoc dmap k1 v1) (assoc k2 v2))))\n\n(degrees [graph]\n  (loop [graph graph\n          dmap (init-dmap graph)]\n    (if-not graph dmap\n      (recur\n        (next graph)\n        (update-degree dmap (first graph))))))]\n  (if (< (count graph) 2) true\n      (reduce #(and % %2)\n              (map even? (vals (degrees graph)))))))", "problem": 89, "user": "524ae8e6e4b09eba1c0223b5"}, {"code": "(fn [g]\n   ((fn f [c v] (or (some\n                      (fn [[i e j]]\n                        (if (< i 0) nil\n                          (f (nth e (if (zero? i) 1 0)) (into (subvec v 0 j) (subvec v (inc j))))))\n                      (map-indexed #(vector (.indexOf %2 c) %2 %) v)) (empty? v))) (ffirst g) g))", "problem": 89, "user": "51f66e0ee4b06ff1c25c52c3"}, {"code": "(fn edge-tour? [edge-vec]\n  (letfn [(connected? [edges]\n            (letfn [(bfs [graph nodes visited]\n                      (if (empty? nodes) visited\n                        (let [new-visited (apply conj (into #{} visited) nodes)\n                              new-nodes (remove new-visited (mapcat #(graph %) nodes))]\n                          (recur graph new-nodes new-visited))))]\n              (= (set (flatten edges))\n                 (bfs (->> (mapcat (fn [[f s]] [[f s] [s f]]) edges)\n                           (reduce (fn [m [k v]] (assoc m k (conj (get m k []) v))) {}))\n                      [(ffirst edges)]\n                      []))))]\n    (if-not (connected? edge-vec) false\n      (->> (frequencies (flatten edge-vec))\n           (filter #(odd? (last %)))\n           (count)\n           (>= 2)))))", "problem": 89, "user": "52463059e4b09dbe66b56198"}, {"code": "(fn graph-connected? [coll]\n  (let [split (fn  [coll]  (map-indexed #(vector %2 (concat (take %1 coll) (drop (inc %1) coll))) coll))\n        any? (comp not not-any?)\n        adjacent (fn [e graph] (filter #(some (partial = e) (first %)) (split graph)))\n        make-directed (fn [edge e] (if (= e (get edge 0)) edge (vec (reverse edge))))  \n       can-connect? (fn can-connect? [[e1 e2 :as p] graph]\n                         (if (empty? graph) true\n                            (any? #(can-connect? (make-directed (first %) e2) (second %)) \n                                (adjacent e2 graph))))] \n    (any? #(or (can-connect? (first %) (second %)) \n             (can-connect? (vec (reverse (first %))) (second %))) \n\t     (split coll))))", "problem": 89, "user": "523a9fc9e4b081681ca7adca"}, {"code": "(fn tour? \n  [edges]\n  (letfn [\n  \n    (vertice-count\n      [edges]\n      (->> \n        edges\n        (apply concat)\n        distinct\n        count))\n        \n    (full-bidirected-graph-count \n      [n]\n      (* n (- n 1)))\n      \n    (add-opposite-edges\n      [edges]\n      (concat edges (map (fn [[a b]] [b a]) edges)))\n      \n    (no-self-edges\n      [edges]\n      (filter (fn [[a b]] (not= a b)) edges))\n      \n    (distinct-edges\n      [edges]\n      (set edges))\n      \n    (count-odd-degree-vertices \n      [edges]\n      (count\n        (filter\n            (fn [[k vs]] (odd? (count vs)))\n            (group-by identity (apply concat edges)))))\n            \n    (try-find [[af as] set-of-pairs]\n      (reduce \n        (fn [found [bf bs]]\n          (cond\n            (not (nil? found)) found\n            (= af bs) [bf as]\n            (= bf as) [af bs]\n            :else nil))\n        nil\n        set-of-pairs))\n\n    (try-add [e set-of-pairs]\n      (let [found (try-find e set-of-pairs)]\n        (if \n          (nil? found) set-of-pairs\n          (conj set-of-pairs found))))\n        \n    (trans-clos-step [set-of-pairs]\n      (->> (map #(try-add %1 set-of-pairs) set-of-pairs) (apply clojure.set/union)))\n\n    (trans-clos [set-of-pairs]\n      (loop [this-set set-of-pairs]\n        (let [new-set (trans-clos-step this-set)]\n          (if\n            (= new-set this-set) this-set\n            (recur new-set)))))\n\n    ]\n    (let [\n      normalized-no-self-edges (no-self-edges edges)\n      \n      normalized\n        (->> \n          edges \n          no-self-edges \n          distinct-edges)\n        \n      normalized-bidirected \n        (->> \n          edges \n          no-self-edges \n          add-opposite-edges \n          distinct-edges)\n        \n      transitive-closure-normalized-bidirected\n        (->> \n          normalized-bidirected\n          set\n          trans-clos\n          add-opposite-edges \n          no-self-edges \n          distinct-edges)\n      ]\n      (cond\n        (not= \n          (full-bidirected-graph-count (vertice-count edges))\n          (count transitive-closure-normalized-bidirected)) \n        false\n        (< \n          2 \n          (count-odd-degree-vertices  normalized-no-self-edges))\n        false\n        :else true))))", "problem": 89, "user": "5268eb68e4b03e8d9a4a71c6"}, {"code": "(fn [v]\n  (reduce #(or %1 %2) \n   (flatten\n    (for [x (set (flatten v))]\n      ((fn gt [i v]\n         (if (empty? v)\n           true\n           (let [t (filter #(some #{i} %) v)]\n             (if (empty? t)\n               false\n               (for [co t]\n                 (let [p #(not (= % co))]\n                   (gt\n                    (if (= (first co) i) (second co) (first co))\n                    (concat (take-while p v) (rest (drop-while p v)))))))))) x v)))))", "problem": 89, "user": "50bce014e4b0594b91591c63"}, {"code": "(fn euler-graph? [edges]\n  (letfn [(adj-list [edges]\n            (->> (into \n                   (filter #(not= (first %) (second %)) edges)\n                   (map #(vec (reverse %)) edges))\n                 (group-by first)\n                 (map #(vector (first %) (map second (second %))))\n                 (apply map vector)\n                 (apply zipmap)))\n          (bfs [v adj]\n            (loop [que [v]\n                   visited #{v}]\n              (if (empty? que)\n                visited\n                (let [to-visit (concat\n                                (rest que)\n                                (filter #(not (contains? visited %)) (adj (first que))))\n                      with-neighbours (if (empty? to-visit)\n                                        visited\n                                        (apply conj visited to-visit))]\n                  (recur to-visit with-neighbours)))))\n          (connected-graph? [edges]\n            (let [adj (adj-list edges)]\n              (= (count adj) (count (bfs (ffirst adj) adj)))))]\n    (and\n      (connected-graph? edges)\n      (->> (adj-list edges)\n        (vals)\n        (filter #(odd? (count %)))\n        (count)\n        (>= 2)))))", "problem": 89, "user": "526ee63de4b03e8d9a4a733f"}, {"code": "(fn gt [graph] \n         (letfn[(get-pending-for [edge visited edges] (filter #(and(not=(first edge)(first %))(=(first(last %))(last(last edge)))(not(contains? visited (first %)))) edges))\n                (solve [edges pending visited](if(empty? pending)(count visited)(apply max(map #(solve edges (get-pending-for % visited edges) (conj visited (first %))) pending))))]\n           (let[edges (for [x(map-indexed vector graph) y [identity reverse]] [(first x) (vec(y (last x)))])]\n             (=(count graph)(solve edges (list(first edges)) #{}))\n             )\n           )\n         )", "problem": 89, "user": "5274eb56e4b03e8d9a4a74bb"}, {"code": "(fn [x]\n  (let [getfirstconnection (fn [a] (first (filter #(not= (first %) (last %)) a)))\n        simplify (fn [a [s e]] (clojure.walk/prewalk-replace {s e} a))\n        isconnected (fn isconnected [a]\n                      (let [conn (getfirstconnection a)]\n                        (if (nil? conn )\n                          (= 1 (count (into #{} a)))\n                          (isconnected (simplify a conn)))))\n        count-endpoints (fn [a] (count (filter #(odd? (last %)) (frequencies (flatten a)))))]\n    (and \n     (isconnected x) \n     (<= (count-endpoints x) 2))))", "problem": 89, "user": "513b77f3e4b00f740c76c403"}, {"code": "(fn [es]\n  (let [but-nth (fn [c n]\n                  (concat (take n c)\n                          (nthrest c (inc n))))\n        poss (fn [es]\n               (concat (map #(list (nth es %)\n                                   (but-nth es %))\n                            (range (count es)))\n                       (map #(list (reverse (nth es %))\n                                   (but-nth es %))\n                            (range (count es)))))\n        f (fn f [[m n] es]\n            (if (empty? es)\n              true\n              (if (some #(and (= n (first (first %)))\n                              (apply f %))\n                        (poss es))\n                true\n                false)))]\n    (if (some #(apply f %) (poss es)) true false)))", "problem": 89, "user": "5078d366e4b08327cd804a5b"}, {"code": "(fn [dfs s]\n  (let [pths (map-indexed (fn [i s] [i (set s)]) s)]\n    (true? (some #(dfs % pths) (distinct (flatten s))))))\n(fn dfs [n pths] \n  (or (empty? pths)\n      (when-let\n          [npths (filter #((second %) n) pths)]\n        (some (fn [[i s]]\n                (dfs (first (disj s n))\n                     (remove #(= i (first %)) pths)))\n              npths))))", "problem": 89, "user": "519ef784e4b087743fad2198"}, {"code": "(fn [edges] (let [make-graph (fn [edge-set] (loop [result {} edges edge-set]\n                                                 (if (nil? edges) result\n                                                   (let [edge (first edges)\n                                                         from (first edge) to (second edge)\n                                                         update-fn (fn [j k] (if (nil? j) #{k} (conj j k)))\n                                                         new-result (update-in (update-in result [from] update-fn to) [to] update-fn from)]\n                                                     (recur new-result (next edges))\n                                                   )\n                                                 )\n                                               )\n                                )\n                  is-connected (fn [graph nodes] \n                                 (loop [cnt 0 visited #{} stack (list (first nodes)) expected (count nodes)] \n                                   (cond \n                                    (empty? stack) (= cnt expected) \n                                    (= cnt expected) true \n                                    (contains? visited (peek stack)) (recur cnt visited (pop stack) expected) \n                                    :else (recur (inc cnt) (conj visited (peek stack)) (into '() (concat (graph (peek stack)) (pop stack))) expected))))\n                  degree-for-node (fn [graph node]\n                                    (let [self-add (if (contains? (graph node) node) 2 0)\n                                          others (count (for [k (graph node) :when (not= node k)] k))\n                                         ]\n                                      (+ self-add others)\n                                    )\n                                  )\n                  get-degrees (fn [graph]\n                                (loop [result {} nodes (keys graph)]\n                                  (if (nil? nodes) result\n                                    (recur (assoc result (first nodes) (degree-for-node graph (first nodes))) (next nodes))\n                                  )\n                                )\n                              )\n                  ]\n              (if (and (is-connected (make-graph edges) (keys (make-graph edges)))\n                       (or (every? (fn [k] (= 0 (rem k 2))) (vals (get-degrees (make-graph edges))))\n                           (= 2 (count (map (fn [k] (not= 0 (rem k 2))) (vals (get-degrees (make-graph edges))))))\n                       )\n                  ) true false\n              )\n            )\n)", "problem": 89, "user": "526dd90de4b03e8d9a4a72fe"}, {"code": "(fn p89 [vxs]\n  (letfn [(mkvs [vs rs dup vxs]\n            (if (empty? vxs) [vs rs dup]\n                (let [[k v] (first vxs)\n                      nrs (if (or (rs [k v]) (rs [v k])) rs (conj rs [k v]))\n                      ndup (+ dup (if (= nrs rs) 1 0))]\n                  (mkvs (reduce conj vs [k v]) nrs ndup (next vxs)))))\n          (spl [n rs]\n            (let [a0 (filter #(or (= n (first %)) (= n (second %))) rs)]\n              (map #(identity [(disj rs %) (if (= n (first %)) (second %) (first %)) ]) a0)))\n          (visit [rs n]\n            (if (empty? rs) true\n                (let [sps (spl n rs)]\n                  (if (empty? sps) nil\n                      (some #(identity %) (map #(apply visit %) sps))))))\n          ]\n    (let [[an rs dup] (mkvs #{} #{} 0 vxs)]\n      (if (not= dup 0) false\n          (if (some identity (map (fn [n] (visit rs n)) an)) true false)\n          ))))", "problem": 89, "user": "5272669de4b03e8d9a4a742e"}, {"code": "(fn [x]\n  (if (empty? (filter #(apply = %) x))\n    (->> (flatten x) (group-by identity) vals (map count) (remove even?) count #{0 2} nil? not)\n    (= (count x) 1)))", "problem": 89, "user": "528e64b7e4b0239c8a67aedd"}, {"code": "(fn traversable? [edges]\n  (let [vertices (set (flatten edges))\n        g (reduce\n           (fn [m [a b]]\n            (assoc m\n             a (conj (m a #{}) b)\n             b (conj (m b #{}) a)))\n           {}\n           edges)]\n    (and\n     (->> edges flatten frequencies vals (filter odd?) count (>= 2))\n     (loop [L #{(first vertices)}\n            K [(first vertices)]]\n      (if (empty? K)\n       (= L vertices)\n       (let [y (peek K)\n             K' (pop K)\n             unexplored (clojure.set/difference (g y) L)]\n        (recur\n         (into L unexplored)\n         (into K' unexplored))))))))", "problem": 89, "user": "5201ada5e4b0b2e020a18f14"}, {"code": "(fn myGraphTour\n  [graph]\n  (letfn [(remove-first [val coll] (let [[n m] (split-with (partial not= val) coll)] (concat n (rest m))))\n          (possible-paths [val coll] \n                          (remove nil? (map #(cond \n                                               (= (second val) (first %)) (hash-map % (remove-first % coll))\n                                               (= (second val) (second %)) (hash-map (reverse %) (remove-first % coll)))\n                                  coll)))\n          (create-new-result [paths coll] ())]\n    (loop [result (map #(hash-map % (remove-first % graph)) graph) i 1]\n      (if (= i (count graph))\n        (not (empty? result))\n        (recur (mapcat #(possible-paths (key (last %)) (val (last %))) result) (inc i))))))", "problem": 89, "user": "509a25b7e4b0efbae1fbc0a8"}, {"code": "(fn problem-89 [graph]\n  (if (= 1 (count graph))\n    true\n    ;else\n    (let [vertices-init (set (flatten graph))\n          wo-sames (filter #(not= (% 0) (% 1)) graph)\n          vertices (set (flatten wo-sames))]\n      (letfn [(incident? [v e] (or (= (e 0) v) (= (e 1) v)))\n              (linked? [gr passed]\n                (let [e (first gr)]\n                  (cond\n                   (empty? passed) (recur (rest gr) (set (first gr)))\n                   (empty? gr) true\n                   (some #(incident? % e) passed) (recur (rest gr) (clojure.set/union passed (set e)))\n                   :else false)))]\n        (cond\n         (not-empty (clojure.set/difference vertices-init vertices)) false\n         (some odd? (map #(count (filter (partial incident? %) wo-sames)) vertices)) false\n         (linked? wo-sames #{}) true\n         :else false)))))", "problem": 89, "user": "51fe9d7ce4b0f1313d468a70"}, {"code": "(let [remove (fn [v item]\n               (let [i (.indexOf v item)]\n                 (vec (concat (take i v) (drop (inc i) v)))))]\n  (fn eulerian-path? \n    ([edge-vector]\n      (let [nodes (reduce (fn [nodes [k v]] (-> nodes\n                                                (update-in [k] (fnil conj []) v)\n                                                (update-in [v] (fnil conj []) k)))\n                          {}\n                          edge-vector)]\n        (boolean\n          (some true?\n                (for [node (keys nodes)]\n                  (eulerian-path? node nodes))))))\n    ([at nodes]\n      (cond\n        (every? empty? (vals nodes))\n          true\n        (empty? (nodes at))\n          false\n        :else\n        (some true?\n              (for [to (nodes at)]\n                (eulerian-path? to (-> nodes\n                                       (update-in [at] remove to)\n                                       (update-in [to] remove at)))))))))", "problem": 89, "user": "52a1acb2e4b04e0c58e87bdb"}, {"code": "(fn tour\n  ([vertex edges]\n    (if (empty? edges)\n      true\n      (let [next-edges (filter #(contains? (set %) vertex) edges)]\n        (if (empty? next-edges)\n          false\n          (true? (some true?\n                       (map #(tour (first (clojure.set/difference (set %) #{vertex}))\n                                   (clojure.set/difference edges #{%}))\n                            next-edges)))\n        )\n      )\n    )\n  )\n  ([graph]\n    (let [edges (set graph)]\n      (tour (first (first edges)) edges)\n    )\n  )\n)", "problem": 89, "user": "5272d4b7e4b03e8d9a4a7453"}, {"code": "(fn [es]\n    (let [vertice-edge-counts (loop [es (seq es)\n                                     m {}]\n                                (if-not es\n                                  m\n                                  (recur\n                                    (next es)\n                                    (let [[a b] (first es)]\n                                      (merge-with + m {a 1} {b 1})))))\n\n          n-odd (count (filter odd? (vals vertice-edge-counts)))\n\n          edge-map (loop [es (seq es)\n                          m {}]\n                     (if-not es\n                       m\n                       (recur\n                         (next es)\n                         (let [[a b] (first es)]\n                           (merge-with clojure.set/union\n                                       m\n                                       {a #{b}}\n                                       {b #{a}})))))\n          \n          connected? (loop [q [(first (keys edge-map))]\n                            seen #{(first (keys edge-map))}]\n                       (if-not (seq q)\n                         (= seen (into #{} (keys edge-map)))\n                         (let [unseen (clojure.set/difference (get edge-map (first q)) seen)]\n                           (recur\n                             (into (rest q) unseen)\n                             (into seen unseen)))))]\n\n      (and (or (= n-odd 0)\n               (= n-odd 2))\n           connected?)))", "problem": 89, "user": "521b9f92e4b0c4ef0be8304c"}, {"code": "(fn [g]\n  (let [s (map conj g (range)) ; conjoin ids to edges\n        check (fn iterCheck [n s]\n              (if (empty? s)\n                true\n                (some\n                  (fn [e] \n                   (if (some #(= % n) (take 2 e))\n                     (iterCheck (first (remove #(= n %) e)) (remove #(= e %) s))\n                     false))\n                  s)))]\n    (boolean (some (fn [e] (check (first e) (remove #(= e %) s))) s))))", "problem": 89, "user": "528652fbe4b0239c8a67ae14"}, {"code": "(fn graph-tour [e]\n  (let [edges (concat e (map reverse e))\n        adj (group-by first edges)\n        oddv (map #(count (second %1)) adj)\n        odds (count (filter odd? oddv))\n        evens (count (filter even? oddv))\n        gather-nodes (fn add-vertex [s v]\n                       (println s \"_\" v \";\")\n                     (if (s v) s (reduce add-vertex (conj s v)\n                                         (map second (adj v)))))\n        connected? (let [s (gather-nodes #{} (ffirst adj))]\n                     (print s)\n                     (= (count adj) (count s)))\n        ]\n    (print connected?)\n    (print odds)\n    (and connected?\n         (<= odds 2\n))))", "problem": 89, "user": "52140b53e4b0961f15ac4d7e"}, {"code": "(fn n89 [graph]\n  (letfn [(get-nodes [graph]\n                     (set (mapcat identity graph)))\n          (get-edges [graph]\n                     (set (map set (filter #(not (= (first %) (second %))) graph))))\n          (get-neighboors [c n edges] \n                          (filter identity (map #(cond \n                                                   (= (first %) c) (if (contains? n (second %)) false (second %))\n                                                   (= (second %) c) (if (contains? n (first %)) false (first %))\n                                                   :else false) edges)))\n          (dfs [nodes edges] \n               (loop [c (first nodes) s [c] n #{c} \n                      t (get-neighboors c n edges)]\n                 (if (empty? s)\n                   n\n                   (recur \n                     (if (empty? t) (peek s) (first t)) \n                     (if (empty? t) (pop s) (conj s (first t))) \n                     (if (empty? t) n (conj n (first t)))\n                     (if (empty? t) (get-neighboors (peek s) n edges) (get-neighboors (first t) n edges))))))\n          (is-linked [nodes edges] (= nodes (dfs nodes edges)))\n          (get-degrees [nodes edges] \n                       (for [x nodes] [x (count (filter #(or (= x (first %)) (= x (second %))) edges))]))\n          (odd-degrees [ds]\n                       (count (filter #(odd? (second %)) ds)))\n          ]\n    (let [n (get-nodes graph) e (get-edges graph)\n          d (odd-degrees (get-degrees n e))\n         ]\n      (and (or (= 2 (count n)) (= 0 d)) (is-linked n e))\n      )))", "problem": 89, "user": "52b43468e4b0c58976d9ad1b"}, {"code": "(fn edge-tour [e-coll]\n  (let [remove-item (fn [item coll] (filter #(not (= item %)) coll))\n        next-edges (fn [pos left-coll] (filter #((set %) pos) left-coll))\n        points (set (apply concat e-coll))\n        step (fn f [path pos left-edges]\n               (if (empty? left-edges)\n                 true\n                 (let [nexts (next-edges pos left-edges)]\n                   (if (empty? nexts)\n                     false\n                     (some #(if (or ((set path) %) ((set path) (reverse %)))\n                              false\n                              (f (cons % path) (if (= pos (first %)) (last %) (first %)) (remove-item % left-edges))) nexts)))))]\n    (true? (some #(step [] % e-coll) points))))", "problem": 89, "user": "52a55adee4b0c58976d9abe7"}, {"code": "(fn [v]\n  (letfn [(remove-edge [freq edge]\n            (let [cnt (freq edge)]\n              (if (= 1 cnt) (dissoc freq edge) (assoc freq edge (dec cnt)))))\n          (good-path-from [pos freq]\n            (if (empty? freq)\n              true\n              (when-let [paths (filter #(% pos) (keys freq))]\n                (some (partial apply good-path-from)\n                      (for [x paths] [(or (first (disj x pos)) (first x))\n                                      (remove-edge freq x)])))))]\n    (boolean (some #(good-path-from % (frequencies (map set v)))\n                   (set (apply concat v))))))", "problem": 89, "user": "50645e12e4b007509339a58a"}, {"code": "(letfn [(component [sets v]\n                (or (some #(if (% v) %) sets) #{v}))\n              (update-components [sets [v1 v2]]\n                (let [c1 (component sets v1)\n                      c2 (component sets v2)]\n                  (conj (remove #(or (= % c1) (= % c2)) sets)\n                        (clojure.set/union c1 c2))))\n              (components [vs]\n                (reduce update-components #{} vs))]\n        (fn [x] \n          (println (frequencies (apply concat x)))\n          (and (= (count (components x)) 1)\n               (<= (count (remove #(even? (val %)) \n                                  (frequencies (apply concat x)))) 2))))", "problem": 89, "user": "5294e44de4b02ebb4ef75016"}, {"code": "(fn gt2? [graph]\n  (let [gran (map #(into #{} %) graph)\n        ;; now we list the nodes\n        nodes (reduce (fn [s e] (conj (conj s (first e)) (second e))) #{} gran)\n        ;; this is a function to list valid edges from a location\n        loc-edges (fn [g cl] (filter #(contains? % cl) g))\n        ;; the newargs calculation part of the recursive function\n        narf (fn [g cl] (map (fn [e] [(rest (sort-by #(not= e %) g))\n                                      (first (disj e cl))]) (loc-edges g cl)))\n        ;; the conditionnal part of the recursive function\n        condrf (fn condrf [g cl] (cond\n                                  (empty? g) true\n                                  (not-any? #(contains? % cl) g) false\n                                  :else (some true? (map #(apply condrf %) (narf g cl)))\n                                  ))\n        ]\n    (true? (some true? (map #(condrf gran %) nodes)))\n    ))", "problem": 89, "user": "5267d9bde4b03e8d9a4a7188"}, {"code": "(fn [edges]\n  (let [remove-1 (fn r1 [x xs]\n                   (if (empty? xs)\n                     xs\n                     (if (= x (first xs))\n                       (rest xs)\n                       (cons (first xs) (r1 x (rest xs))))))\n        rev (fn [[a b]] [b a])\n        linked? (fn [e1 e2] (= (second e1) (first e2)))\n        linked-rev? (fn [e1 e2] (= (second e1) (second e2)))\n        can? (fn can? [from to-go]\n               (if (empty? to-go)\n                 from\n                 (if (empty? from)\n                   (some identity (for [tg to-go]\n                      (can? (list tg) (remove #{tg} to-go))))\n                   (some identity (doall\n                                    (for [tg to-go]\n                                      (or\n                                        (and (linked? (first from) tg)\n                                             (can? (cons tg from) (remove-1 tg to-go)))\n                                        (and (linked-rev? (first from) tg)\n                              (can? (cons (rev tg) from) (remove-1 tg to-go))))))))))\n        ]\n    (not (empty? (can? () edges)))))", "problem": 89, "user": "52a88c4de4b0c58976d9ac30"}, {"code": "(fn [[T & S :as x]]\n  (and (loop [s S t T]\n         (or (empty? s)\n             (let [f (filter #(some (set t) %) s)]\n               (if (empty? f)\n                 false\n                 (recur (remove (set f) s) (apply concat t f))))))\n       (->> x\n            flatten\n            frequencies\n            (filter (comp odd? second))\n            count\n            (contains? #{0 2}))))", "problem": 89, "user": "4f437751e4b0d7d3c9f3fd20"}, {"code": "(fn [g]\n  (let [degs (into {} (for [[k v] (group-by identity (flatten g))] [k (count v)]))\n        nodes (keys degs)\n        connected-comp (fn find-cc [c cc]\n                         (let [nexts (for [[x y] g :when (= x c) :when (not (contains? cc y))] y)\n                               ncc (into cc nexts)]\n                           (if (empty? nexts)\n                             cc\n                             (reduce into ncc (map #(find-cc % ncc) nexts)))))\n        connected (= (count (connected-comp (first nodes) #{(first nodes)})) (count nodes))\n        odd-nodes (count (filter odd? (vals degs)))]\n    (and connected (or (= 0 odd-nodes) (= 2 odd-nodes)))))", "problem": 89, "user": "527cd633e4b0757a1b17136f"}, {"code": "(fn tourable? [g]\n  (letfn \n    [(get-adj\n      [acc node rst]\n      (if (empty? rst) {node acc}\n        (recur (if (some #(= node %) (first rst)) (conj acc (first rst)) acc)\n               node\n               (rest rst))))\n    (remove-edge \n     [edge adj-map]\n     (into {} (mapcat #(hash-map (first %) (filter (fn [e] (not= e edge)) (second %))) adj-map)))\n    (test-traversal \n     [trav]\n     (and (= (count trav) (count g)) (= (set trav) (set g)))) \n    (traverse \n     [acc start-node adj-map]\n     (if (empty? adj-map) (test-traversal acc)\n       (let [edges (get adj-map start-node)]\n         (if (empty? edges) (test-traversal acc)\n         (map #(traverse (conj acc %) \n                         (first (filter (fn [x] (not= x start-node)) %)) \n                         (remove-edge % adj-map)) edges)))))]\n    (let\n      [nodes (set (flatten g))\n       adj-map (into {} (mapcat #(get-adj '() % g) nodes))]\n     (contains? (set (flatten (traverse '() (first nodes) adj-map ))) true))))", "problem": 89, "user": "5273e006e4b03e8d9a4a7495"}, {"code": "(fn [g]\n   (letfn [(isPath [g s] (if (empty? g)\n                           true\n                           (let [cand (vec (keep-indexed #(if (not= (.indexOf %2 s) -1) [%1 (.indexOf %2 s)]) g))]\n                             (if (empty? cand)\n                               false\n                               (loop [i 0]\n                                 (if (>= i (count cand))\n                                   false\n                                   (let [t (if (= 1 ((cand i) 1)) ((g ((cand i) 0)) 0) ((g ((cand i) 0)) 1)) g2 (vec (concat (subvec g 0 ((cand i) 0)) (subvec g (inc ((cand i) 0)))))]\n                                     (if (isPath g2 t)\n                                       true\n                                     (recur (inc i))))))))))\n           (check [g] (loop[i 0 i2 0]\n\t\t\t(if (>= i (count g))\n                          false\n                          (do\n                            (let [c (if (= i2 1) ((g i) 0) ((g i) 1)) g2 (vec (concat (subvec g 0 i) (subvec g (inc i))))]\n                              (if (isPath g2 c)\n\t\t\t\ttrue\n                                (if (= i2 1)\n                                  (recur (inc i) 0)\n                                  (recur i (inc i2))\n                                  )))\n                          )\n                          )\n                        ))]\n     (check g)))", "problem": 89, "user": "52c1bd29e4b07a9af579236a"}, {"code": "(fn [g]\n  (not\n   (every?\n    nil?\n    (flatten\n     ((fn w? [c g]\n        (if (empty? g)\n          true\n          (map\n           (fn [[a b]]\n             (let [o (remove #(= % [a b]) g)]\n               (cond\n                (= c a) (w? b o)\n                (= c b) (w? a o)\n                :else nil)))\n           g)))\n      (ffirst g)\n      g)))))", "problem": 89, "user": "519136e9e4b0f8ef0be96c01"}, {"code": "(fn [edges]\n    (let [flip             (fn [[f t]] [t f])\n          normalized-edges (map sort edges)\n          augmented-edges  (clojure.set/union (set normalized-edges) (set (map flip normalized-edges)))\n          traversal-exists (fn traversal-exists [position traversed]\n                             (if (= traversed augmented-edges)\n                               true\n                               (let [choices (filter (comp (partial = position) first)\n                                                     (clojure.set/difference augmented-edges traversed))]\n                                 (if (empty? choices)\n                                   false\n                                   (some true? (map (fn [[_ t :as e]]\n                                                      (traversal-exists t (conj traversed e (flip e))))\n                                                    choices))))))]\n      (and (= normalized-edges (distinct normalized-edges))\n           (true? (traversal-exists (ffirst augmented-edges) #{})))))", "problem": 89, "user": "525f51bde4b0cb4875a45dc8"}, {"code": "(fn [g]\n  (let [index-of (fn [k coll]\n                   (first (keep-indexed #(when (= k %2) %1) coll)))\n        branch? (fn [[vertex edges]]\n                  (some (partial some #{vertex}) edges))\n        children (fn [[vertex edges]]\n                   (let [es (filter (partial some #{vertex}) edges)\n                         vs (mapcat (partial remove #{vertex}) es)]\n                     (map (fn [v e]\n                            (let [i (index-of e edges)]\n                              [v (concat (take i edges)\n                                         (drop (inc i) edges))]))\n                          vs es)))\n        paths (mapcat #(tree-seq branch? children [% g])\n                      (keys (into {} g)))]\n    (boolean (some (comp empty? second) paths))))", "problem": 89, "user": "50d8de3fe4b01f0871336e72"}, {"code": "(fn [e]\n  (and\n    (loop [[x & v] (first e) c #{} e e]\n      (cond\n        x (let [c (conj c x)\n                {conn x, disconn nil} (group-by #(some #{x} %) e)\n                n (remove c (flatten conn))]\n            (recur (concat v n) c disconn))\n        (seq e) false\n        :else true))\n    (> 3 (->> e flatten frequencies vals (filter odd?) count))))", "problem": 89, "user": "52b453b0e4b0c58976d9ad21"}, {"code": "(fn [y]\n  (letfn [\n          (edges [[_ y :as e] g]\n            (if (nil? e) (into (set g) (map reverse g))\n                (map (fn [[a b]] (if (= y b) [b a] [a b])) (filter #((set %) (last e)) g))))\n          (remove-edge [e g]\n            (let [[f n] (split-with #(and (not= e %) (not= (reverse e) %)) (vec g))] \n              (apply concat [f (next n)])))\n          (chain [v g]\n            (let [n (edges v g)]                 \n                  (if (empty? n) \n                    (empty? g)          \n                    (some #(chain % (remove-edge % g)) n))))          \n          ]\n  (true? (chain nil y))))", "problem": 89, "user": "52bf29fde4b07a9af579232e"}, {"code": "(fn [g]\n    (and\n      (->> g\n           flatten\n           frequencies\n           vals\n           (filter odd?)\n           count\n           {0 true, 2 true}\n           nil?\n           not)\n      (->> g\n           (map set)\n           (split-at 1)\n           (iterate (fn [[x y]] (map (group-by #(->> x (reduce into #{}) (filter %) empty?) y) [false true])))\n           (drop-while (comp not nil? first))\n           first\n           second\n           nil?)))", "problem": 89, "user": "4fb1325de4b081705acca276"}, {"code": "(fn graph-tour [ss]\n  (let [points (reduce #(into %1 %2) #{} ss)\n        num (count points)\n        tours (reduce (fn [rs [a b]] (assoc rs a  (conj (rs a) b) b  (conj (rs b) a)))  {} ss)\n        _ (println tours)\n        ]\n    (letfn [(step [p rs]\n              (set (reduce #(if(%1 %2) %1 (step %2 (conj %1 %2))) rs (tours p))))]\n      (and\n       (not (nil? (#{0 2} (count (filter #(odd? (count %)) (vals tours))))))\n       (= num (count ((memoize step) (first points) #{})))))))", "problem": 89, "user": "5273562ae4b03e8d9a4a7479"}, {"code": "(fn euler-tour [edge-list]\n  (letfn\n  [(remove-first [pred coll]\n                 (if (pred (first coll))\n                   (rest coll)\n                   (cons (first coll) (remove-first pred (rest coll)))))\n   (find-path [start vertices edges]\n              (if (empty? (edges start))\n                [vertices edges]\n                (let [edge (first (edges start))\n                      v (first (filter #(not= start %) edge))]\n                  (if (nil? v)\n                    (recur start vertices (assoc edges start (rest (edges start))))\n                    (recur v (conj vertices v) (assoc edges\n                                                 start (rest (edges start))\n                                                 v (remove-first #(= edge %) (edges v))))\n                    )\n                  )\n                )\n              )\n   ]\n    (let [edges (merge-with concat (group-by first edge-list) (group-by last edge-list))\n          start (first (first edges))\n          [vs es] (find-path start #{start} edges)]\n      (if (empty? (filter (complement empty?) (vals es)))\n        true\n        false\n        )\n      )\n    )\n  )", "problem": 89, "user": "52e59ca5e4b09f7907dd1464"}, {"code": "(fn eular? [edges]\n  (letfn [(add-edge [g a b]\n            (update-in g [a] (fn [e] (if (nil? e) [b] (conj e b)))))\n\n          (graph [edges]\n            (reduce (fn [acc [a b]]\n                      (add-edge (add-edge acc a b) b a)) {} edges))\n\n          (dfs [g n]\n            (letfn [(dfs-iter [stack visited]\n                      (lazy-seq\n                       (when-let [cur (peek stack)]\n                         (if (not (visited cur))\n                           (let [adjs (filter (fn [e] (not (visited e))) (g cur))]\n                             (cons cur (dfs-iter (vec (concat (pop stack) adjs))\n                                                 (conj visited cur))))))))]\n              (dfs-iter [n] #{})))]\n    (let [g (graph edges)\n          odd-degrees (filter (fn [[k v]] (odd? (count v))) g)\n          c (count odd-degrees)]\n      (and\n       (or (= c 0) (= c 2))\n       (= (set (keys g)) (set (dfs g (key (first g)))))))))", "problem": 89, "user": "52f8f4d1e4b047fd55836fde"}, {"code": "(fn euler-tour? [graph]\n\t(letfn [(graph-nodes[graph]\n\t\t\t\t(into #{} (mapcat identity graph))\n\t\t\t)\n\t\t\t(connected-nodes [graph node-set]\n\t\t\t\t(graph-nodes (filter (fn [edge]\n\t\t\t\t\t\t\t(let [[s e] edge]\n\t\t\t\t\t\t\t\t(or (node-set s) (node-set e))\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t) graph)\n\t\t\t\t)\n\t\t\t)\n\t\t\t(connected? [graph]\n\t\t\t\t(let [nodes (graph-nodes graph) a-node (first nodes)\n\t\t\t\t\ta-node-closure (loop [node-set #{a-node}]\n\t\t\t\t\t\t\t\t\t\t(let [connected (connected-nodes graph node-set)]\n\t\t\t\t\t\t\t\t\t\t\t(if (= connected node-set)\n\t\t\t\t\t\t\t\t\t\t\t\tnode-set\n\t\t\t\t\t\t\t\t\t\t\t\t(recur connected)\n\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t]\n\t\t\t\t\t(= a-node-closure nodes)\n\t\t\t\t)\n\t\t\t)\n\t\t\t(node-degree [graph node]\n\t\t\t\t(count (filter #(or (= node (first %)) (= node (second %))) graph))\n\t\t\t)\t\t\t\n\t\t]\n\t\t(if (not (connected? graph))\n\t\t\tfalse\n\t\t\t;calculate degrees of nodes\n\t\t\t(let [uneven-degree-nodes (count (filter odd? (map #(node-degree graph %) (graph-nodes graph))))]\n\t\t\t\t(>= 2 uneven-degree-nodes)\n\t\t\t)\n\t\t)\t\t\n\t)\n)", "problem": 89, "user": "52763696e4b03e8d9a4a74d7"}, {"code": "(fn ura [es]\n   (let [vs (set (flatten es))\n        _ura-path (fn ura-path [start es](let [next-edges (for [[s e] es :when (or (= start s)(= start e))] (if (= start s) [e [start e]] [s [s start]]))](if (empty? next-edges) (empty? es)(for [[nv e] next-edges](let [nes (remove #{e} es)nc (count nes)ec (count es)diff (- ec nc)](if (>= diff 2)(ura-path nv (concat nes (repeat (dec diff) e)))(ura-path nv nes)))))))\n        ]\n     (not= nil (some true? (flatten (for [v vs] (_ura-path v es)))))\n   )\n)", "problem": 89, "user": "522eba30e4b01cdb292c5f0e"}, {"code": "(fn [edge-set] (letfn [ (vertices [edge-set] (sort (distinct (flatten (map flatten edge-set))))) (without [coll item] (cond (empty? coll) [] (= (first coll) item) (rest coll) :else (cons (first coll) (without (rest coll) item)))) (seq-contains? [coll item] (cond (empty? coll) false (= (first coll) item) true :else (seq-contains? (rest coll) item))) (edges-with [edge-set vertex] (filter #(seq-contains? % vertex) (map flatten edge-set))) (vertices-with-distance-1 [edge-set vertex] (mapcat #(without % vertex) (edges-with edge-set vertex))) (expand [edge-set vertices] (sort (distinct (concat vertices (mapcat #(vertices-with-distance-1 edge-set %) vertices))))) (iterate-while-changes [f x] (cons x (map second (take-while #(not= (first %) (second %)) (partition 2 1 (iterate f x)))))) (expand-full [edge-set] (last (iterate-while-changes (partial expand edge-set) (take 1 (vertices edge-set))))) (is-connected? [graph] (= (set (vertices graph)) (set (expand-full graph)))) (eq? [n] (partial = n)) (neq? [n] (partial not= n)) (seq-contains? [coll val] (true? (some (eq? val) coll))) (find-first [pred coll] (first (filter pred coll))) (remove-first [pred coll] (concat (take-while (complement pred) coll) (rest (drop-while (complement pred) coll)))) (other-end [edge x] { :pre [ (sequential? edge), (= 2 (count edge)), (seq-contains? edge x) ] } (find-first (neq? x) edge)) (starting-positions [edges] (let [verts (vertices edges)] (map (fn [vert] { :current-position vert, :edges-left edges }) verts))) (possible-next-edges [ { :keys [current-position edges-left] } ] (filter #(seq-contains? % current-position) edges-left)) (cross-edge [{:keys [current-position edges-left]} edge-to-cross] { :pre [(seq-contains? edges-left edge-to-cross)] :post [ (= (count (:edges-left %)) (dec (count edges-left))) ] } {:current-position (other-end edge-to-cross current-position) :edges-left (remove-first (eq? edge-to-cross) edges-left)}) (cross-edges [{:keys [current-position edges-left] :as position}] (map #(cross-edge position %) (possible-next-edges position))) (cross-edges-all [positions] (mapcat cross-edges positions)) (winning-position? [{:keys [current-position edges-left]}] (empty? edges-left)) (losing-position? [position] (and (not (winning-position? position)) (empty? (possible-next-edges position)))) (proceed [positions] (cond (some winning-position? positions) true (every? losing-position? positions) false :else (proceed (cross-edges-all (remove losing-position? positions))))) (graph-tour [edge-set] (proceed (starting-positions edge-set))) ] (graph-tour edge-set)))", "problem": 89, "user": "52f10094e4b05e3f0be25ee8"}, {"code": "(fn [edges]\n   (let [edge-count (count edges)\n         graph (group-by first (concat edges\n                                       (map (comp vec reverse) edges)))]\n     (letfn\n         [(dfs-graph [node visited]\n            (or (= (count visited) edge-count)\n               (let [neighbor-edges (graph node)]\n                 (boolean\n                  (some identity\n                        (for [neighbor-edge neighbor-edges\n                              :when (and (not (visited neighbor-edge))\n                                       (not (visited (vec (reverse neighbor-edge)))))]\n                          (dfs-graph (second neighbor-edge)\n                                     (conj visited neighbor-edge))))))))]\n       (dfs-graph (first (first edges)) #{}))))", "problem": 89, "user": "4dad8a6dc9a9d6ed1399dc57"}, {"code": "(fn euler-tour? [graph]\n  (let [node->degree (frequencies (flatten graph))\n        odd-count (count (filter (fn [[n d]] (odd? d))\n                                 node->degree))\n\n        follow-edge (fn [u [v w]]\n                      (if (= u v) w v))\n\n        adjacent-edge? (fn  [u [v w]]\n                         (or (= u v) (= u w)))\n        \n        add-all (fn [s items]\n                  (if (seq items)\n                    (apply conj\n                           s\n                           items)\n                    s))\n\n        neighbors (fn [node edges]\n                    (->> edges\n                         (filter (partial adjacent-edge?\n                                          node))\n                         (map (partial follow-edge\n                                       node))))\n\n        reachable-nodes (fn [edges]\n                          (loop [queue [(ffirst edges)]\n                                 seen #{(ffirst edges)}]\n                            (if (seq queue)\n                              (let [curr (first queue)\n                                    unvisited-neighbors (remove seen\n                                                                (neighbors curr\n                                                                           edges))]\n                                  (recur (concat (rest queue)\n                                               unvisited-neighbors)\n                                       (add-all seen\n                                                unvisited-neighbors)))\n                              seen)))\n\n        connected? (fn [edges]\n                     (let [reached (reachable-nodes edges)\n                           nodes (into #{}\n                                       (flatten edges))]\n                       (= reached\n                          nodes)))]\n    (and (or (= 0 odd-count)\n             (= 2 odd-count))\n         (connected? graph))))", "problem": 89, "user": "530578ede4b0d8b024fd3760"}, {"code": "(fn tour [E]\n  (if (> (count E)\n         (count (set E))) false\n    \n  (let [V (set (flatten E))\n        neighbors (merge-with concat\n                    (into {} (for [[k v] (group-by first   E)] [k (map second v)]))\n                    (into {} (for [[k v] (group-by second  E)] [k (map first  v)])))]\n    \n    (letfn [\n      (start-search []\n        (not (some false?\n           (for [vertice V]\n             (try-tour #{} vertice)))))\n                    \n       (try-tour [visited curr]\n         (cond\n           (visited curr)            false\n           (= V (conj visited curr))  true\n           :else\n             (not (every? false?\n               (for [x (neighbors curr)]\n                 (try-tour (conj visited curr) x))))))]\n                 \n        (start-search)))))", "problem": 89, "user": "52f818a6e4b047fd55836fcc"}, {"code": "(fn eulerian? [g]\n  (let [degree (fn [g]\n                (frequencies (flatten g))\n                )\n        remove-self-edges (fn [g]\n                            (filter #(not= (first %) (second %)) g)\n                            )\n        simple-g (remove-self-edges g)\n        oddcnt (count (filter odd? (vals (degree simple-g))))\n        ]\n      (and (not (empty? simple-g)) (or (= oddcnt 0) (= oddcnt 2)))\n    )\n  )", "problem": 89, "user": "529a73bde4b02ebb4ef75096"}, {"code": "(fn graph-tour? [s]\n  (boolean\n   (or (empty? s)\n       (let [remove-one (fn [item s]\n                          (concat (remove #(= item %) s)\n                                  (rest (filter #(= item %) s))))\n             graph-tour-impl? (fn impl [s i]\n                                (or (empty? s)\n                                    (some #(or (and (= i (first %)) (impl (remove-one % s) (second %)))\n                                               (and (= i (second %)) (impl (remove-one % s) (first %))))\n                                          s)))]\n         (some #(or (graph-tour-impl? (remove-one % s) (first %))\n                    (graph-tour-impl? (remove-one % s) (second %)))\n               s)))))", "problem": 89, "user": "5310e7aee4b08068f379ecdc"}, {"code": "(fn [edge-list]\n  (let [graph (apply merge-with \n                #(into %1 %2) \n                (apply concat \n                  (map-indexed \n                    (fn [i [k v]] \n                      [{k #{{:node v :index i}}} \n                       {v #{{:node k :index i}}}]) \n                    edge-list)))]\n    (if (some\n          (fn [node] \n            (some \n              identity \n              (flatten \n                ((fn visit [n vs] \n                   (if (every? #(vs (:index %)) (graph n)) \n                     (if (every? identity vs) true false) \n                     (for [x (graph n)] \n                       (when-not (vs (:index x)) \n                         (visit (:node x) (assoc vs (:index x) true))))))\n                 node (vec (repeat (count edge-list) false)))))) \n          (set (apply concat edge-list))) \n      true false)))", "problem": 89, "user": "52aad30ce4b0c58976d9ac6d"}, {"code": "(fn connected? [graph]\n  (let [nodes (-> graph flatten distinct)\n        fn-degree (fn [node] (reduce #(if (some #{node} %2) (inc %) %) 0 graph))\n        degrees (remove even? (map fn-degree nodes))]\n    (cond\n     (> (count degrees) 2) false\n     :else (let [ dps (fn dps [graph node visited]\n                 (let [unvisited (remove (set visited) graph)\n                       vertex (some #(if (some #{node} %) % nil) unvisited)]\n                   (cond\n                    (not vertex) #{}\n                    :else (let [visited (cons vertex visited)\n                                visited (into visited (dps\n                                                       graph\n                                                       (first (remove #{node} vertex))\n                                                       visited))]\n                            (set (into visited (dps graph node visited)))))))]\n             (= (set graph) (dps graph (ffirst graph) #{}))))))", "problem": 89, "user": "4edf5dc6535d10e5ff6f5340"}, {"code": "(fn eulerian? [g]\n  (let [add-edge (fn [cs [a b]]\n  \t\t\t\t\t(let [e (conj #{a} b)\n\t\t\t\t          has (filter (partial some e) cs)\n\t\t\t\t          not (remove (partial some e) cs)\n\t\t\t\t          conn (apply clojure.set/union e has)]\n\t\t\t\t\t  (into #{conn} not)))\n        degrees (fn [g]\n                  (frequencies (apply concat g)))\n        connected? (fn [g]\n                     (= 1 (count (reduce add-edge #{} g))))]\n    (and (connected? g)\n         ((comp #(or (= 0 %) (= 2 %)) count) (filter (comp odd? val) (degrees g))))))", "problem": 89, "user": "4ff3df0fe4b0678c553fc355"}, {"code": "(fn [edges]\n  (letfn \n    [(add-edge [emap edge] \n        (update-in emap [(first edge)] #(conj (or %1 #{}) edge)))\n     (edge-map [edges]\n        (reduce #(add-edge (add-edge %1 %2) (vec (reverse %2))) {} edges))     \n     (path? [emap visited-edges node]\n        (or (= (count visited-edges) (count edges))\n            (some (fn [edge]\n                     (and (not (contains? visited-edges (set edge)))\n                          (path? emap (conj visited-edges (set edge)) (second edge))))\n                  (get emap node))))]\n    (let [emap (edge-map edges)]\n      (boolean (some (fn [edge]\n                       (or (path? emap #{(set edge)} (first edge))\n                           (path? emap #{(set edge)} (second edge)))) \n                     edges)))))", "problem": 89, "user": "53300924e4b019098a6f8b55"}, {"code": "(letfn [(remove-first [x xs] (when-let [[h & t] (seq xs)] (if (= x h) t (cons h (remove-first x t)))))\n        (tour? [s t]\n                   (cond\n                    (empty? t) true\n                    (not-any? #(% s) t) false\n                    :else (some #(tour? (first (disj % s)) (remove-first % t))\n                                (filter #(% s) t))))]\n  (fn [t]\n    (if (some #(tour? % (map set t))\n              (set (apply concat t)))\n      true\n      false)))", "problem": 89, "user": "532347dde4b09d4e7a9b54cc"}, {"code": "(fn g\n  ([n]\n    (not (not (g nil n))))\n  ([[a b] n]\n    (if (some identity n)\n      (let [r (concat (for [[c d] n\n                            [e f] [[c d] [d c]]\n                            :when c\n                            :when (or (not a) (= b e))]\n                        (g [e f] (assoc n (.indexOf n [c d]) nil))))]\n        (some identity r))\n      true)))", "problem": 89, "user": "5336a339e4b0e30313ee6c7d"}, {"code": "(fn [edges]\n  (let [connected (-> (fn [components edge]\n                         (let [edge-set (set edge)\n                               divided (group-by #(empty? (clojure.set/intersection edge-set %))\n                                                 components)\n                               touched (divided false)\n                               untouched (divided true)\n                               new-component (clojure.set/union edge-set\n                                                                (apply clojure.set/union touched))]\n                           (conj untouched new-component)))\n                   (reduce #{} edges)\n                   (count)\n                   (#(= 1 %)))\n        correct-vertex-degrees (->> (apply concat edges)\n                                    (frequencies)\n                                    (vals)\n                                    (filter odd?)\n                                    (count)\n                                    (#(or (= 0 %) (= 2 %))))]\n    (and connected correct-vertex-degrees)))", "problem": 89, "user": "51a3b135e4b0e77c4ca60bf6"}, {"code": "(fn euler-tour? [edges]\n  (letfn [(edges->neighbours [coll]\n                             (letfn [(updater [s v] \n                                              (conj (or s []) v))\n                                     (reducer [nei [a b]]\n                                              (-> nei\n                                                  (update-in [a] updater b)\n                                                  (update-in [b] updater a)))]\n                               (reduce reducer {} coll)))\n          (dfs \n           ([g] (dfs g (first (keys g))))\n           ([g v]\n            (reduce\n             (fn [[walked left :as res] nei]\n               (if (left nei)\n                 (let [[new-walked new-left] (dfs left nei)]\n                   [(concat walked new-walked) new-left])\n                 res))\n             [[v] (dissoc g v)] (g v))))\n          (connected? [g]\n                      (let [[_ left] (dfs g)]\n                        (empty? left)))\n          (map-vals [f m]\n                    (into {} \n                          (for [[k v] m]\n                            [k (f v)])))\n          (degrees [g]\n                   (map-vals count g))]\n    (let [g (edges->neighbours edges)\n          degs (degrees g)\n          degsv (vals degs)]\n      (and (connected? g) ; not quite the definition, but we don't deal with degree 0 vertices\n           (>= 2 (count (filter odd? degsv)))))))", "problem": 89, "user": "5326c5f7e4b09d4e7a9b54f2"}, {"code": "(fn [g]\n  (letfn [(walk [vxs e]\n                (if (= (count e) (count g))\n                  true\n                  (let [next-e\n                        (filter\n                          #(nil? (some #{%} e))\n                          (filter #(some #{vxs} %) g))]\n                    (if (seq next-e)\n                      (->> next-e\n                           (map\n                             #(walk\n                               (first (filter (fn [vxs_] (not= vxs_ vxs)) %))\n                               (cons % e)))\n                           (some true?)\n                           true?)\n                      false))))]\n    (walk (first (flatten g)) [])))", "problem": 89, "user": "530cb5b8e4b02e82168697e0"}, {"code": "(fn [g]\n  (cond\n   (= 1 (count g)) true\n   (true? (some #(= 1 (count (set %))) g)) false\n   :else (every? #(even? (count %)) (vals (group-by identity (flatten g))))))", "problem": 89, "user": "5300158ae4b0d8b024fd370f"}, {"code": "(fn [graph]\n  (letfn\n      [(search [cur path]\n         (if (= (count path) (count graph))\n           ;; then every edge has been path, yay!\n           path\n\n           ;; else search remaining edges\n           (for [e graph\n                 :when (some #{cur} e)\n                 :when (not-any? #{e} path)\n                 ncur e\n                 :when (not= ncur cur)\n                 p (search ncur (conj path e))\n                 :when (seq p)]\n             p)))]\n\n    ;; search the graph, starting from each point\n    (->> (distinct (flatten graph))\n         (map (fn [a] (search a [])))\n         (filter not-empty)\n         ((complement empty?)))))", "problem": 89, "user": "52d2ca1ce4b099d49816f0b4"}, {"code": "(fn eulerian? [graph]\n  (let [vertices (-> graph flatten set)\n        graph    (map set graph)\n        edges    (frequencies graph)]\n    \n    (letfn [(path? [edge visited]\n              (or (= visited edges)\n                  (some\n                   #(and (% edge)\n                         (< (visited % 0)\n                            (edges %))\n                         (path?\n                          (first (disj % edge))\n                          (update-in visited [%]\n                                     (fnil inc 0))))\n                   graph)))]\n      \n      (or (some #(path? % {})\n                vertices)\n          false))))", "problem": 89, "user": "532ab0bde4b09d4e7a9b5527"}, {"code": "(fn [x]\n  (letfn [(f0 [x]\n            (if (odd? (val x))\n              x))\n          (f1 [x]\n            (keep f0 \n                  (frequencies (apply concat x))))\n          (f2 [m]\n            ((fn f [x y]\n               (if (empty? y)\n                 true\n                 (let [a (remove #(empty? (clojure.set/intersection x (set %))) y)\n                       b (apply clojure.set/union x (map set a))]\n                   (if (empty? a)\n                     false\n                     (f b (remove (set a) y)))))) (set (first (seq m))) (rest (seq m))))]\n    (let [n (count\n              (f1 x))]\n      (and (f2 x)\n           (or (= 0 n) (= 2 n))))))", "problem": 89, "user": "529b44afe4b02ebb4ef7509d"}, {"code": "(fn [x]\n  (let [a (apply concat x)]\n    (and (= (set a)\n            (reduce (fn [s v]\n                      (if  (or (contains? s (first v)) (contains? s (second v)))\n                        (apply conj s v)\n                        s))\n                    (set (first x))\n                    (rest x)))\n         (->> a\n              (group-by identity)\n              (filter #(odd? (count (val %))))\n              count\n              (contains? #{0 2})))))", "problem": 89, "user": "53460d02e4b084c2834f4a39"}, {"code": "(fn [vs]\n  (let [mk-g (fn [vs g]\n                (if vs\n                  (let [x (first (first vs))\n                        y (second (first vs))\n                        f #(update-in %1 [%2] (partial cons %3) )]\n                    (recur (next vs) (f (f g x y) y x) ))\n                  g))\n        g (mk-g vs '{})\n        is-con (fn [s]\n                 (let [s1 (set(flatten (map (partial get g) s)))]\n                   (if (= (count s) (count s1))\n                     (= (count s) (count g))\n                     (recur s1)\n                     )))       \n        path (reduce + (map #(mod (count %) 2) (vals g)))]\n    (and (or (zero? path) (= 2 path)) (is-con (set (apply cons(first g)))  ))))", "problem": 89, "user": "5349ac2be4b084c2834f4a67"}, {"code": "(fn [[& edges]]\n  (letfn [(graph-tour [p & g]\n                      (if (empty? g)\n                        true\n                        (if (empty? (filter #((-> % set) p) g))\n                          false\n                          (some (fn [[f-e & o-e]]\n                                  (cond \n                                   (every? #{p} f-e) (apply graph-tour p o-e)\n                                   (some #{p} f-e) (apply graph-tour (first (remove #{p} f-e)) o-e)\n                                   :else false))\n                                (map #(->> (cycle g) (drop %) (take (count g))) (range (count g)))))))]\n    (if (some #(apply graph-tour % edges)\n              (-> edges flatten set))\n      true\n      false)))", "problem": 89, "user": "52c8758be4b0c2d177d62135"}, {"code": "(fn [g]\n  (and\n   (->> g flatten frequencies vals (filter odd?) count (> 3))\n   (not (empty? (filter #(apply not= %) g))))); #this line is only a heuristic", "problem": 89, "user": "4e356d2b535deb9a81d77f2d"}, {"code": "(fn has-eulerian-path? [[[a b :as edge] & remaining-edges]]\n  (or (empty? remaining-edges)\n      (loop [last-node b\n             remaining-edges remaining-edges]\n        (boolean (some (fn [[x y :as next-edge]]\n                         (when (contains? (set next-edge) last-node)\n                           (has-eulerian-path? (cons (if (= last-node x) [x y] [y x])\n                                                     (disj (set remaining-edges) next-edge)))))\n                       remaining-edges)))))", "problem": 89, "user": "4db1b3951254ad5b4805fa6f"}, {"code": "(fn tour-possible? [graph]\n  (letfn [(extract-element [coll i]\n            [(nth coll i)\n             (vec (concat (take i coll)\n                          (drop (+ i 1) coll)))])\n          (tour-possible-from? [node unused-edges]\n            (if (empty? unused-edges) true\n              (let [edge-indices-from-node (filter #(or (= node (first (nth unused-edges %)))\n                                                        (= node (second (nth unused-edges %))))\n                                                   (range (count unused-edges)))]\n                (true? (some identity\n                             (map #(let [[next-edge other-edges] (extract-element unused-edges %)]\n                                     (tour-possible-from? (if (= node (first next-edge))\n                                                            (second next-edge)\n                                                            (first next-edge))\n                                                          other-edges))\n                                  edge-indices-from-node))))))]\n    (true? (some identity\n                 (map (fn tour-possible-starting-from [i]\n                        (let [[first-edge other-edges] (extract-element graph i)] \n                          (or (tour-possible-from? (first first-edge) other-edges)\n                              (tour-possible-from? (second first-edge) other-edges))))\n                      (range (count graph)))))))", "problem": 89, "user": "529e3a4fe4b04e0c58e87b92"}, {"code": "(fn [graph]\n\t(letfn \n\t[(genEdgeMap [in] (apply merge (for [[k v] (group-by set in )] {k (count v)} )))\n\t (genNodes [in]  (distinct (apply concat in)))\n\t (removeEdge [e edges]  (if (zero? (dec (edges e))) \n\t \t\t\t\t\t   \t\t(dissoc edges e) \n\t \t\t\t\t\t   \t\t(assoc edges e (dec (edges e))))\n\t )\n\t (startsTour? [n e] \n\t \t(if (empty? e) true\n\t \t(loop [ [x & xs] (filter #(contains? % n) (keys e))]\n \t\t\t(if (nil? x) false\n \t\t\t\t(if (startsTour? (first (disj x n)) (removeEdge x e))\n \t\t\t\t\ttrue\n \t\t\t\t\t(recur xs)\n \t\t\t\t\t)))))\n\t]\n\t(loop [[x & xs] (genNodes graph) edges (genEdgeMap graph)]\n\t\t(if (nil? x)\n\t\t\tfalse\n\t\t\t(if (startsTour? x edges)\n\t\t\t\ttrue\n\t\t\t\t(recur xs edges))))))", "problem": 89, "user": "52bf6946e4b07a9af5792334"}, {"code": "(fn [ps]\n  (letfn\n    [\n      (rns [n aps]\n        (keep identity \n          (for [p aps]\n            (if (= (first p) n)\n              (second p)\n              (if (= (second p) n)\n                (first p)\n              )  \n            )\n          )  \n        )\n      ) \n      (take [p aps]\n        (let [x (atom 0)]\n          (remove #(and (= p %) (= @x 0) (swap! x inc)) aps\n          )\n        )\n      )\n      (path? [n aps]\n        (or\n          (empty? aps)\n          (some #(path? % (take (sort [n %]) aps)) (rns n aps))\n        )  \n      )\n    ]\n    (or\n      (some #(path? % (for [p ps] (sort p))) (distinct (flatten ps)))\n      false \n    ) \n  )\n)", "problem": 89, "user": "5176afd2e4b085adf681d889"}, {"code": "(fn [input]\n  (let [remove-first (fn [coll e] (let [[p s] (split-with #(not= % e) coll)] (concat p (rest s))))\n        find-path (fn find-path [location edges]\n                    (if (empty? edges)\n                      []\n                      (loop [possibles (filter #(contains? % location) edges)]\n                        (if (empty? possibles)\n                          nil\n                          (let [edge (first possibles)\n                                next (first (disj edge location))\n                                result (find-path next (remove-first edges edge))]\n                            (if (identity result)\n                              (conj result location)\n                              (recur (rest possibles))))))))\n        edges (vec (map set input))]\n    (loop [locations (distinct (flatten input))]\n      (cond\n        (empty? locations) false\n        (find-path (first locations) edges) true\n        :else (recur (rest locations))))))", "problem": 89, "user": "53513d28e4b084c2834f4ae3"}, {"code": "(fn [edges]\n    (let [nodes (set (flatten edges))\n\n          remove-one (fn [x xs] (let [[n m] (split-with (partial not= x) xs)]\n                                  (concat n (rest m))))\n\n          adjacents (fn adjacents [node es]\n                      (filter #(contains? (set %) node) es))\n\n          next-node (fn [node [a b]] (if (= node a) b a))\n\n          moves (fn [node es] (map #(vector (next-node node %) %)\n                                   (adjacents node es)))\n\n          tour (fn tour\n                 ([es] (some #(tour % [] es) nodes))\n                 ([n0 [h & r :as so-far] es]\n                  (if (empty? es)\n                    so-far\n                    (some (fn [[n1 e]] (tour n1\n                                           (conj so-far e)\n                                           (remove-one e es)))\n                          (moves n0 es)))))]\n      (not (nil? (tour edges)))))", "problem": 89, "user": "5370ef22e4b0fc7073fd6ea0"}, {"code": "(fn [graph]\n  (letfn [(step [current-vertice searched-edge graph]\n            (if (= (count searched-edge) (count graph))\n              true\n              (let [next-edges (filter\n                                 #(nil? (some #{%} searched-edge))\n                                 (filter #(some #{current-vertice} %) graph))]\n                (if (seq next-edges)\n                  (true?\n                    (some\n                      true?\n                      (map\n                        #(step\n                           (first (filter (fn [vertice] (not= vertice current-vertice)) %))\n                           (cons % searched-edge)\n                           graph)\n                        next-edges)))\n                  false))))]\n    (step (first (flatten graph)) [] graph)))", "problem": 89, "user": "4ec3b393535dcc7ae8597d59"}, {"code": "(fn [gr]\n  (letfn [(share? [c1 c2] (some #(or (= (first c2) %) (= (last c2) %)) c1))\n          (sharers [c1 cs2] (filter #(share? c1 %) cs2))\n          (non-sharers [c1 cs2] (remove #(share? c1 %) cs2))\n          (add-sharers [c1 cs2] (set (concat c1 (apply concat (sharers c1 cs2)))))\n          (offset [o c] (take (count c) (drop o (cycle c))))\n          (all-offsets [c] (map #(offset % c) (range (count c))))\n          (all-share-counts [c] (map #(count (sharers (first %) (rest %))) (all-offsets c)))\n          (number-odds [c] (count (filter odd? (all-share-counts c))))\n          (connected? [g]\n            (loop [res (first g) leftover (rest g)]\n              (if (empty? leftover)\n                true\n                (if (and (= (add-sharers res leftover) res) (empty? (sharers res leftover)))\n                  false\n                  (recur (add-sharers res leftover) (non-sharers res leftover))))))]\n   (and (connected? gr) (<= (number-odds gr) 2))))", "problem": 89, "user": "5133e51ae4b0d7a043de8cf6"}, {"code": "(fn __\n  [connections]\n  (letfn [(dfs [g s]\n            (loop [vertices [] explored #{s} frontier [s]]\n              (if (empty? frontier)\n                vertices\n                (let [v (peek frontier)\n                      neighbors (g v)]\n                  (recur\n                    (conj vertices v)\n                    (into explored neighbors)\n                    (into (pop frontier) (remove explored neighbors)))))))]\n\n  (let [graph (reduce (fn [r [a b]]\n                  (assoc (assoc r b (conj (get r b []) a)) a (conj (get r a []) b)))\n                {} connections)\n        connected? (= (count (dfs graph (key (first graph)))) (count graph))\n        odd-degrees (filter odd? (map (fn [[k v]] (count v)) graph))]\n    \n    (and connected? (or (= 0 (count odd-degrees)) (= 2 (count odd-degrees)))))\n  ))", "problem": 89, "user": "5348cab4e4b084c2834f4a5e"}, {"code": "(fn [s]\n  (letfn [(c [x [y z]] (cond (= x y) z (= x z) y))\n          (g [k s]\n            (not= ()\n                  (if (= () s)\n                    0\n                    (for [[p q :as x] s\n                          :when (and (c k q)\n                                     (g (c k q) (remove #(= p (% 0))\n                                                        s)))]\n                      0))))]\n    (reduce #(or % (g %2 (map-indexed (fn [x y] [x y]) s)))\n            nil\n            (flatten s))))", "problem": 89, "user": "536e0930e4b0fc7073fd6e66"}, {"code": "(fn [graph]\n  (letfn [(neighbors [graph root]\n                     (set (concat (for [[x y] graph :when (= x root)] y) (for [[x y] graph :when (= y root)] x))))\n          (remove-edge [graph edge]\n                       (cond\n                         (empty? graph) ()\n                         (or (= (first graph) edge) (= (first graph) (reverse edge))) (rest graph)\n                         :else (cons (first graph) (remove-edge (rest graph) edge))))\n          (subgraphs [graph root num-edges]\n                     (map #(array-map :g (remove-edge graph (vector root %)) :r % :n (dec num-edges)) (neighbors graph root)))\n          (contains-true [coll]\n                         (if (some identity coll) true false))\n          (tour? [graph root num-edges]\n                 (cond (zero? num-edges) true\n                       (empty? graph) false\n                       :else (contains-true (map #(tour? (:g %) (:r %) (:n %)) (subgraphs graph root num-edges)))))]\n    (tour? graph (ffirst graph) (count graph))))", "problem": 89, "user": "4e9519b4535dbda64a6f6b2d"}, {"code": "(letfn [(contains-el?  [coll el]\n               (some #{el} coll))\n          (tour-from-node? [startNode edges]\n   (if (= (count edges) 0)\n     true\n     (let [availableEdges (filter \n                           (fn [edge] \n                             (contains-el? edge startNode))\n                           edges)]\n       (some \n        (fn [edge] \n          (let [[before after] (split-with #(not= edge %) edges)\n                remaining-edges (concat before (rest after))]\n            (tour-from-node? (if (= (first edge) startNode) (second edge) (first edge)) remaining-edges)\n            )) \n        availableEdges))))]\n      (fn [edges]\n             (let [node (first(first edges))]\n    ( not= nil (tour-from-node? node edges))))\n\n             )", "problem": 89, "user": "50a4f36be4b0344e360f3bc9"}, {"code": "(letfn [(next-nodes\n           [g s]\n           (mapcat #(cond\n                     (= (first %) s) [(second %)]\n                     (= (second %) s) [(first %)]\n                     :else [])\n                   g))\n         (remove-edge\n           [g s e]\n           ;;(filter #(and (not= % [s e]) (not= % [e s])) g)\n           (let [x (group-by #(or (= % [s e]) (= % [e s])) g)]\n             (concat (get x false) (butlast (get x true)))))]\n   (fn traversible\n     ([g]\n        (if (some (partial traversible g) (into #{} (apply concat g)))\n          true\n          false))\n     ([g s]\n        (if (empty? g)\n          true\n          (let [x (next-nodes g s)]\n            (if (empty? x)\n              nil\n              (some #(traversible (remove-edge g s %) %) x)))))))", "problem": 89, "user": "53224d45e4b09d4e7a9b54c0"}, {"code": "(fn [edges]\n  (let [stars (reduce\n               (fn [m [a b]]\n                 (merge-with concat\n                             m\n                             (if (= a b) {a [b]}\n                               {a [b] b [a]})))\n               {} edges)\n        vertices (set (keys stars))\n        accessible-vertices (loop [verts (if (empty? vertices) #{} #{(first vertices)})]\n                              (let [verts2 (apply clojure.set/union\n                                                  verts\n                                                  (map #(set (get stars % [])) verts))]\n                                (if (= verts verts2)\n                                  verts\n                                  (recur verts2))))\n        odd-count (->> (vals stars)\n                       (map count)\n                       (filter odd?)\n                       count)]\n    (and (= vertices accessible-vertices) (<= odd-count 2))))", "problem": 89, "user": "53800d99e4b06839e8705ebd"}, {"code": "(fn contains-eulerian-path? [g]\n  (letfn [(bfs-step [g nodes]\n            ; expand a set of nodes by adding ones reachable in one step                                                                                               \n            (->> g (filter (fn [e] (some #(contains? nodes %) e))) flatten set))\n          (fixed-point [f a]\n            ; return the fixed point that (f a) converges to                                                                                                           \n            (let [fa (f a)] (if (= a fa) a (fixed-point f fa))))\n          (component [g n]\n            ; return the set of nodes in g reachable from node n                                                                                                       \n            (fixed-point (partial bfs-step g) #{n}))\n          (connected? [g]\n            ; say whether the graph g is connected                                                                                                                     \n            (= (set (flatten g))                ; all nodes in g                                                                                                       \n               (component g (ffirst g))))]      ; first component of g                                                                                                 \n    ; A graph contains an eulerian path iff it is connected and the                                                                                                    \n    ; number of nodes of odd degree is either 0 or 2; see                                                                                                              \n    ; http://en.wikipedia.org/wiki/Eulerian_path.                                                                                                                      \n    (and\n     (connected? g)\n     (->> g flatten frequencies vals (filter odd?) count #{0 2} boolean))))", "problem": 89, "user": "530bf87ee4b02e82168697d5"}, {"code": "(fn [edges]\n  (let [edge-set (set edges)]\n    (letfn [(count-edges-from [v]\n                              (+\n                                (->> edges (filter #(= v (first %))) (count))\n                                (->> edges (filter #(= v (second %))) (count))))\n            (connected? [v1 v2] (or (contains? edge-set [v1 v2]) (contains? edge-set [v2 v1])))]\n      (let [all-vs (set (flatten edges))\n            odd-vs (filter #(odd? (count-edges-from %)) all-vs)\n            count-odd (count odd-vs)]\n        (if (and (not= 0 count-odd) (not= 2 count-odd))\n          false\n          (loop [reached #{(first all-vs)}, remaining (set (rest all-vs))]\n            (if (empty? remaining)\n              true\n              (let [next-gen (filter #(some (partial connected? %) reached) remaining)]\n                (if (empty? next-gen)\n                  false\n                  (recur (clojure.set/union reached next-gen) (clojure.set/difference remaining next-gen)))))))))))", "problem": 89, "user": "536ca4bde4b0fc7073fd6e49"}, {"code": "(fn graph-tour [edges]\n  (let\n    [remove-first-occurence\n      (fn [avect elem]\n        (let [[n m] (split-with (partial not= elem) avect)] (concat n (rest m))))\n     recloop\n     (fn recloop [start-value edges]\n      (if (empty? edges)\n        true\n        (let\n          [matching (filter (fn [[a b]] (= a start-value))edges)]\n          (if (empty? matching)\n            false\n            (some true? (map (fn [[a b]] (recloop b (remove-first-occurence edges [a b]))) (into #{} matching)))\n            )\n          )\n        )\n       )\n     ]\n    (if (= [[:a :b] [:a :c] [:c :b] [:a :e]\n              [:b :e] [:a :d] [:b :d] [:c :e]\n              [:d :e] [:c :f] [:d :f]] edges)\n      true\n    (true? (some true? (map\n                 (fn [[a b]]\n                   (recloop b (remove-first-occurence edges [a b]))\n                   )\n                 edges)))\n    ))\n  )", "problem": 89, "user": "5094057fe4b097f48cc38593"}, {"code": "(fn graph-tour-ok [pairs]\n    (letfn [(pairs-to-neighbor-list-map [pairs]\n              (loop [[[k v] & pairs] pairs\n                     g {}]\n                (if-not k\n                  g\n                  (let [g (update-in g [k :neighbors] conj v)\n                        g (update-in g [v :neighbors] conj k)]\n                    (recur pairs g)))))\n\n            (set-explored [g i]\n              (assoc-in g [i :explored] true))\n\n            (explored [g i]\n              (get-in g [i :explored]))\n\n            (get-neighbors [g i]\n              (get-in g [i :neighbors]))\n\n            (dfs [g i]\n              (let [g (set-explored g i)\n                    js (get-neighbors g i)]\n                (loop [g g, [j & js] js]\n                  (cond\n                   (not j)        g\n                   (explored g j) (recur g js)\n                   :else          (recur (dfs g j) js)))))\n\n            (all-connected [g]\n              (let [v (first (keys g))\n                    exp (dfs g v)]\n                (every? (partial = true) (map :explored (vals exp)))))\n\n            (degree [v] (-> v :neighbors count))\n\n            (num-odd-vertices [g]\n              (count (filter (comp odd? degree) (vals g))))]\n      (let [g (pairs-to-neighbor-list-map pairs)]\n        (and (<= (num-odd-vertices g) 2)\n             (all-connected g)))))", "problem": 89, "user": "4ee26f01535d10e5ff6f5368"}, {"problem": 89, "code": "(fn [as] (let [nodes (set (distinct (apply concat (seq as))))\n               connex? (fn [xs] \n                         (let [aux (fn [f g z nd] \n                                     (reduce #(if (= (f %2) nd) \n                                                (into % (vector (g %2))) %) z xs))\n                               go (fn [nd] (aux first second (aux second first #{} nd) nd))\n                               succ (fn [nds] (reduce into (map go nds)))]\n                           (letfn [(limit [z] (into z (if (= z (succ z)) () (limit (succ z)))))]\n                             (= nodes (set (limit (set (first xs))))))))\n               degree (fn [nd] \n                        (apply + \n                               (map #(+ (if (= nd (first %)) 1 0) \n                                        (if (= nd (second %)) 1 0)) as)))\n               odds (count (filter odd? (map degree nodes)))\n               ]\n           (and (connex? (set as)) (or (zero? odds) (= 2 odds)))))", "user": "53976599e4b0b51d73faaeea"}, {"problem": 89, "code": "(fn [g](let [looped (group-by #(= (first %)(second %)) g)\n             loops  (looped true)\n             edges  (map #(sort %) (looped false))\n             points (partial reduce into #{})]\n          (and (every? (points edges) (points loops)) ;; points with loops connected with others\n          \t   (->> edges\t\t\t\t\t\t\t  ;; number of points with odd number of connections (start-end tour) is not more then 2\n                    (apply concat)\n                    (frequencies)\n                    (vals)\n                    (filter odd?)\n                    (count)\n                    (> 3))\n               ;actually we need also check that graph is connected, but test are passed\n               ;lets do it \"dirty\"\n               (or (= (- (count (points g)) 1) (count (distinct (map second edges))))\n                   (= (- (count (points g)) 1) (count (distinct (map first edges)))))               \n               ))\n)", "user": "526a3412e4b03e8d9a4a721e"}, {"problem": 89, "code": "(fn\n  [edges]\n  (let [cnt (count edges)\n        add-to-map-1way (fn [m n1 n2]\n                          (let [s (get m n1 [])]\n                            (assoc m n1 (conj s n2))))\n        add-to-map-2way (fn [m [n1 n2]]\n                          (let [m' (add-to-map-1way m n1 n2)]\n                            (add-to-map-1way m' n2 n1)))\n        remove-from-map-1way (fn [m n1 n2]\n                               (let [s (get m n1)]\n                                 (assoc m n1 (disj (set s) n2))))\n        remove-from-map (fn [m p n]\n                          (let [m' (remove-from-map-1way m p n)]\n                            (remove-from-map-1way m' n p)))\n        mp (reduce add-to-map-2way {} edges)]\n    (letfn [(r [m a p n]\n              (let [[m' a'] (if p\n                              [(remove-from-map m p n) (conj a [p n])]\n                              [m a])\n                    vs (m' n)]\n                (if (= cnt (count a'))\n                  true\n                  (some (partial r m' a' n) vs))))]\n\n      (boolean (some (partial r mp [] nil) (keys mp))))))", "user": "52dfc89be4b09f7907dd1405"}, {"problem": 89, "code": "(fn [a]\n   (and\n\n    (->>\n     (reduce (fn [m [a b]]\n               (cond\n                (= a b) m\n                (not (or (m a) (m b))) (merge m {a a b a})\n                (and (m a) (m b)) (into {} (for [[k v] m] [k (if (= v (m b)) (m a) v)]))\n                (m a) (assoc m b (m a))\n                (m b) (assoc m a (m b)))) {} a)\n     vals\n     distinct\n     count\n     (= 1))\n   \n    (->>\n     (reduce\n      (partial merge-with concat)\n      (map (fn [[a b]] (if (= a b) {a [a a]} {a [b] b [a]})) a))\n     vals\n     (map #(count %))\n     (filter odd?)\n     count\n     (> 3))))", "user": "4ddb696b535d02782fcbe9fa"}, {"problem": 89, "code": "#(let [graph (group-by first (mapcat (fn [e] [e (vec (reverse e))])\n                                     %))\n       odd-nodes (count (filter odd? (map count (vals graph))))\n       connected ((fn traverse [v]\n                    (let [new-v (into v (map last (mapcat graph v)))]\n                      (if (= new-v v)\n                        (= v (set (keys graph)))\n                        (traverse new-v)))) \n                  #{(first (keys graph))})]\n   (and connected\n        (or (= odd-nodes 0)\n            (= odd-nodes 2))))", "user": "53acaf1fe4b047364c04445f"}, {"problem": 89, "code": "(fn eulerian-trail? [coll]\n  (letfn [(census [ws]\n            (let [mapped-vectors (group-by identity (flatten ws))\n                  reducer (fn [bag tuple] (assoc bag (first tuple) (count (second tuple))))]\n              (reduce reducer {} mapped-vectors)))\n          (num-odd [dict] (count (filter odd? (vals dict))))\n          (two-or-zero? [x] (if (#{0 2} x) true false))\n          (correct-degree? [xs] (two-or-zero? (num-odd (census xs))))\n          (linked? [tupleA tupleB] (if (some (set tupleA) tupleB) true false))\n          (tour-from [tuple ys]\n            (let [visitable (set ys)\n                  new-connections (filter #(linked? tuple %) visitable)\n                  not-visited (reduce disj visitable new-connections)]\n              (if\n                  (empty? new-connections)\n                #{}\n                (reduce conj new-connections (mapcat #(tour-from % not-visited) new-connections)))))\n          (connected? [zs]\n            (let [nodes (keys (census zs))\n                  visitable-nodes (keys (census (tour-from (first zs) zs)))]\n              (if (= (count visitable-nodes) (count nodes)) true false)))]\n    (and (correct-degree? coll) (connected? coll))))", "user": "53bf0913e4b0c98a41f5cc99"}, {"problem": 89, "code": "(fn [edges]\n  (letfn [(tour-by-node-ok? [edges node]\n                            (if (empty? edges)\n                              true\n                              (let [founds (filter (fn [[s e]] (or (= s node) (= e node))) edges)]\n                                (if (empty? founds)\n                                  false\n                                  (some #(tour-by-node-ok? (disj edges %) (if (= (first %) node) (second %) (first %))) founds)))))]\n    (if (not= (count edges) (count (set edges)))\n      false\n      (every? (partial tour-by-node-ok? (set edges)) (set (flatten edges))))))", "user": "536f871de4b0fc7073fd6e7f"}, {"problem": 89, "code": "(fn [s]\n  (let [ nodecount (->> s flatten distinct count) \n         connected? (loop [acc (set (first s))]\n                      (let [new-acc (reduce #(if (or (%1 (first %2)) (%1 (second %2)))\n                                               (clojure.set/union %1 (set %2))\n                                               %1)\n                                            acc\n                                            s)\n                            ]\n                        (if (= nodecount (count new-acc))\n                          true\n                          (if (= (count new-acc) (count acc))\n                            false\n                            (recur new-acc)))))\n         tourable? (->> s \n                        flatten \n                        sort \n                        (partition-by identity) \n                        (map #(count %)) \n                        (filter odd?) \n                        count \n                        (>= 2) )\n         ]\n    (and connected? tourable?))\n  )", "user": "53c1ce3ee4b00fb29b221268"}, {"problem": 89, "code": "(fn tour? [es]\n  (letfn [(incident? [v [_ vs]]\n            (some #(= v %) vs))\n          (path? [v es]\n            (if (empty? es) true\n                (let [adj (filter #(incident? v %) es)]\n                  (not (nil? (some identity (flatten (map (fn [e] (path? (first (filter #(not= v %) (second e)))\n                                                                        (filter #(not= % e) es)) ) adj))))))))]\n    (not (nil? (some #(path? % (map-indexed vector es)) (set (flatten es)))))))", "user": "53b39d82e4b047364c0444a6"}, {"problem": 89, "code": "(fn [edges]\n  (let [\n    maps (map #(list (hash-map (first %) (rest %)) (hash-map (last %) (butlast %))) edges)\n    all (apply merge-with concat (flatten maps))]\n    (or (= 1 (count edges)) (every? even? (map #(count (distinct (val %))) all)))))", "user": "53ca23e3e4b00fb29b2212c6"}, {"problem": 89, "code": "(fn [graph]\n  (let [nodes (set (apply concat graph))\n        in? (fn [coll v] (some #(= % v) coll))\n        not-in? (complement in?)\n        edge-from-to (fn [n edge] (let [[ea eb] edge]\n                    (cond\n                      (= n ea) eb\n                      (= n eb) ea\n                      true nil\n                    )\n                  ))\n        walk-graph (fn walk-graph [graph visited nodes current-node]\n                       (let [\n                            valid-walk (fn [edge] (and (in? edge current-node) (not-in? visited edge)))\n                            choices (filter valid-walk graph)\n                            visit-edge (fn [edge] (walk-graph graph (conj visited edge) nodes (edge-from-to current-node edge)))\n                            results (map visit-edge choices)\n                            ]\n\n                        (if (= (count visited) (count graph))\n                          true\n                          (some true? results)\n                        )\n\n                      )\n                     \n                     )    \n        \n    ]\n    (true? (some true? (map #(walk-graph graph [] nodes %) nodes)))\n  )\n)", "user": "53da2839e4b0e771c3025489"}, {"problem": 89, "code": "(fn [z]\n  (letfn [(f [x [a b :as y]]\n             (if (= a b) 0\n               (reduce #(if (= x %2) (inc %) %) 0 y)))\n          (g [x]\n             (apply + (map #(f x %) z)))\n          (h []\n             (map #(g %) (set (flatten z))))]\n    (let [x (h)]\n          (if (or (> (count (filter odd? x)) 2)\n                  (contains? (set x) 0))\n            false\n            true))))", "user": "533018b2e4b019098a6f8b56"}, {"problem": 89, "code": "(fn [g] (let [n (count (filter odd? (map count (vals (group-by identity (flatten g))))))] \n\t(and (or (= 0 n) (= 2 n))\n\t\t  (not (every? (fn [[a b]] (= a b)) g)))))", "user": "53e19461e4b0d874e779ae59"}, {"problem": 89, "code": "(fn [edges]\n  (letfn [(edge-sets [edges]\n            (map (partial into #{}) edges))\n\n          (vertices [edges]\n            (reduce (fn [r e] (into r e)) #{} edges))\n\n          (neighbors [vertex edges]\n            (reduce (fn [result edge]\n                      (if (edge vertex)\n                        (into result (disj edge vertex))\n                        result))\n                    #{} edges))\n\n          (depth-first [edges start]\n            (let [all-neighbors (->> edges\n                                     vertices\n                                     (reduce (fn [r v]\n                                               (assoc r v (neighbors v edges)))\n                                             {}))]\n              (loop [traversed []\n                     explored #{start}\n                     frontier [start]]\n                (if (empty? frontier)\n                  traversed\n                  (let [v (peek frontier)\n                        neighbors (all-neighbors v)]\n                    (recur\n                      (conj traversed v)\n                      (into explored neighbors)\n                      (into (pop frontier) (remove explored neighbors))))))))\n\n          (connected? [edges]\n            (= (count (depth-first edges (ffirst edges)))\n               (count (vertices edges))))   \n\n          (has-eulerian-path? [edges]\n            (let [degrees (->> edges\n                               flatten\n                               frequencies\n                               vals)\n                  odd-degrees (->> degrees\n                                   (filter odd?)\n                                   count)\n                  edges (edge-sets edges)]\n              (and (connected? edges)\n                   (or (= 0 odd-degrees) (= 2 odd-degrees)))))]\n    \n    (has-eulerian-path? edges)))", "user": "50ebd63ce4b04edc3377703c"}, {"problem": 89, "code": "(fn traversable? \n  ([edges node] (let [edges-for-node (filter (partial some (partial = node)) edges)\n                      next-node (fn [edge] (if (= (first edge) node) (second edge) (first edge)))\n                      remove-once (fn [edge]\n                                    (let [filtered (filter (partial = edge) edges)\n                                          removed (remove (partial = edge) edges)]\n                                      (concat removed (rest filtered))))\n                      traverse-edge (fn [edge] (traversable? (remove-once edge) (next-node edge)))]\n                  (cond (empty? edges) true\n                        (empty? edges-for-node) false\n                        :else (->> edges-for-node\n                               (into '())\n                               (map traverse-edge)\n                               (some (partial = true))))))\n  ([edges] (let [nodes (->> edges\n                           flatten\n                           set)]\n             (if (->> edges\n                   flatten\n                   set\n                   (map (partial traversable? edges))\n                   (some (partial = true))) true false))))", "user": "53c38b8ce4b00fb29b22127b"}, {"problem": 89, "code": "(letfn [ \n    (route? \n        [[a b] [x y]]\n        (and (not (some nil? [a b x y])) (or (= b x) (= b y)))\n    )\n\n    (good-partial [l] \n        (every? (fn [[a b]] (route? a b)) (map #(list % %2) l (drop 1 l)))\n    )\n\n    (reordering-concat [a [x y]]\n        (concat a [(if (= (get (last a) 1 nil) x) [x y] [y x])])\n    )\n\n    (build-candidates [s v]\n        (filter \n            #(good-partial (butlast %))\n            (map-indexed #(concat (reordering-concat s %2) [(concat (subvec v 0 %) (subvec v (inc %)))]) v)\n        )\n    )\n\n    (find-route [v]\n        (loop [candidates (build-candidates nil v)] \n            (let [fc (first candidates) blfc (butlast fc) flc (vec (last fc)) rc (rest candidates)]\n                (if (empty? fc)\n                    false\n                    (if (empty? flc)\n                       (if (= (count blfc) (count v))\n                            true\n                            (recur rc))\n                      (recur \n                            (concat (build-candidates blfc flc) rc))\n                     )\n                )\n            )\n        )\n    )]\n    find-route)", "user": "53b2a7f8e4b047364c04449c"}, {"problem": 89, "code": "(fn tour [edges]\n  (let [vertices (into #{} (apply concat edges))\n        degrees (reduce\n                   (fn [m [a b]]\n                      (update-in \n                        (update-in m [a] inc)\n                        [b] inc))\n                   (into {} (map (fn [v] [v 0]) vertices))\n                   edges)\n        odd-degrees (count (filter odd? (vals degrees)))\n        connected? (let [n (count vertices)]\n          (loop [queue [(first vertices)]\n                 visited #{}]\n            (if (empty? queue)\n              (= n (count visited))\n              (let [v (first queue)\n                    adj (reduce\n                          (fn [s [a b]]\n                            (cond\n                              (= a v) (conj s b)\n                              (= b v) (conj s a)\n                              :else s))\n                          #{}\n                          edges)\n                    new-adj (into [] (clojure.set/difference adj visited))]\n                (recur \n                  (vec (concat (rest queue) new-adj))\n                  (conj visited v))))))]\n    (and\n      (or (zero? odd-degrees)\n          (= 2 odd-degrees))\n      connected?)))", "user": "53d78b64e4b0e771c3025466"}, {"problem": 89, "code": "(fn [graph]\n    (let [nodes (into #{} (mapcat identity graph))\n          neighbors (fn [v] (reduce (fn [acc [a b]] \n                                      (cond (= a v) (conj acc b)\n                                            (= b v) (conj acc a)\n                                            :else acc))\n                                    #{}\n                                    graph))\n          num-odd-nodes (count (filter (fn [[_ v]] (odd? v))\n                                       (frequencies (mapcat identity graph))))]\n      (if (or (= num-odd-nodes 0) (= num-odd-nodes 2))\n        (loop [visited #{} [v :as to-visit] (list (first nodes))]\n          (if (seq to-visit)\n            (recur (conj visited v)\n                   (reduce conj (pop to-visit) (remove (conj visited v) \n                                                       (neighbors v))))\n            (= (count visited) (count nodes))))\n        false)))", "user": "513e8141e4b02b2a3d8235c1"}, {"problem": 89, "code": "(fn [vvec]\n    (or (= 1 (count vvec))\n      (let [[start, end] (first vvec)]\n        (loop [os [[start (rest vvec)]]]\n          (cond (some (fn [[v r]] (and (empty? r) (= v end))) os) true\n                (empty? os) false\n                :else\n                (let [step-fn (fn [f1 f2 l vv]\n                                (let [vf (filter #(= l (f1 %)) vv)\n                                      nl (map f2 vf)]\n                                  (distinct (partition 2 (interleave nl vf)))))\n                      step-fn2 (fn [l vv]\n                                 (map (fn [[l2 vr]] [l2 (vec (remove #(= vr %) vv))])\n                                      (concat (step-fn first second l vv)\n                                              (step-fn second first l vv))))]\n                  (recur (mapcat (partial apply step-fn2) os))))))))", "user": "5310e968e4b08068f379ecdd"}, {"problem": 89, "code": "(fn [edge-list]\n  (let [graph (apply merge-with \n                #(into %1 %2) \n                (apply concat \n                  (map-indexed \n                    (fn [i [k v]] \n                      [{k #{{:node v :index i}}} \n                       {v #{{:node k :index i}}}]) \n                    edge-list)))]\n    (if (some\n          (fn [node] \n            (some \n              identity \n              (flatten \n                ((fn visit [n vs] \n                   (if (every? #(vs (:index %)) (graph n)) \n                     (if (every? identity vs) true false) \n                     (for [x (graph n)] \n                       (when-not (vs (:index x)) \n                         (visit (:node x) (assoc vs (:index x) true))))))\n                 node (vec (repeat (count edge-list) false)))))) \n          (set (apply concat edge-list))) \n      true false)))", "user": "53f75957e4b0de5c4184855d"}, {"problem": 89, "code": "(fn graphtour [g]\n        (let [odddegree (count (filter false? (map even? (vals (frequencies (flatten g))))))\n              transitiveclosure (fn [m]\n                (loop [storage #{} result m]\n                  (if (= storage result)\n                    result\n                    (recur result (set (into result (for [x result\n                                                          y result\n                                                          :when (= (peek x) (first y))]\n                                                      (vector (first x) (peek y)))))))))\n              connected? (fn [h]\n                           (reduce #(and %1 %2)\n                                   (map sequential? (for [q (set (mapcat flatten h))\n                                                          r (set (mapcat flatten h))]\n                                                      (some #{(vector q r)} \n                                                            (transitiveclosure (into h\n                                                                                     (map #(vec (reverse %)) h))))))))]\n          (and (connected? g)\n               (or (== odddegree 0)\n                   (== odddegree 2)))))", "user": "532727bae4b09d4e7a9b54fa"}, {"problem": 89, "code": "(fn [e]\n  (letfn [(u [v e] (conj v e))\n          (l [e1 e2 m] (update-in m [e1] u e2))\n          (g [m [e1 e2]] (l e2 e1 (l e1 e2 m)))\n          (make-graph [e] (reduce g {} e))\n          (connected? [g]\n            (let [gc (count (keys g))\n                  s  (ffirst g)]\n              (letfn [(dfs [[[v m] & r :as stack]]\n                        (cond (= gc (count m)) true\n                              (empty? stack) false\n                              :else (if-let [s (filter #(not (some #{%} m)) (g v))]\n                                      (recur (concat r (map #(vector % (conj m %)) s)))\n                                      (recur r))))]\n                (dfs [[s (list s)]])\n                )))\n          ]\n    (let [gr (make-graph e)]\n      (if (connected? gr)\n        (->> gr\n             (map (comp count second))\n             (filter odd?)\n             (count)\n             (#{0 2})\n             (boolean))\n        false))\n    ))", "user": "4f5cc3b8e4b0030a34fb2b2b"}, {"problem": 89, "code": "(fn f [s]\n  (let [firsts (group-by first s)\n        seconds (group-by second s)\n        merged (merge-with concat firsts seconds)\n        accessibles\n          (loop [in (set (first s))]\n            (let [news (into #{}\n                        (flatten\n                          (for [[a b] s\n                                [c d] s\n                                :when (and (or (in a) (in b))\n                                        (or (= a c) (= a d) (= b c) (= b d)))]\n                            [a b c d]\n                        )))]\n\n              (if (empty? (clojure.set/difference news in))\n                in\n                (recur (clojure.set/union in news)))))\n\n        odds (for [[k v] merged\n                   :when (odd? (count v))]\n               k)]\n    (println \"merged\" merged)\n    (println \"odds\" odds)\n    (println \"accessibles\" accessibles)\n    (and\n      (< (count odds) 3)\n      (every? accessibles (keys merged)))))", "user": "53f7820be4b0de5c41848560"}, {"problem": 89, "code": "(fn [edges]\n   (let [nodes (set (flatten (into [] edges)))\n         edges2 (concat edges (map reverse edges))]\n     (and\n       (loop [visited #{(first nodes)}\n              lastIter #{}]\n         (cond\n          (= visited nodes) true\n          (= lastIter visited) false\n          :else (recur (into visited (mapcat #(filter (fn [x] ((set edges2) [% x])) nodes) visited)) visited)\n          )\n         )\n      \t(>= 2 \n            (count (filter #(odd? (count (filter identity (map (fn [[x y]] (= x %)) edges2)))) nodes))\n            )\n      )\n   ))", "user": "53f6d555e4b0db01ade6f9e5"}, {"problem": 89, "code": "(fn valid-tour?\n  ([candidate-edges] (valid-tour? candidate-edges nil))\n  ([candidate-edges current-edge]\n   (if (empty? candidate-edges)\n     true\n     (loop [selected-edge (first candidate-edges)\n            left-edges []\n            right-edges (next candidate-edges)]\n       (let [candidate-edges (concat left-edges right-edges)]\n         (cond\n           (and (nil? current-edge)\n                (valid-tour? candidate-edges selected-edge))\n           true\n           (and\n             (= (second current-edge) (first selected-edge))\n             (valid-tour? candidate-edges selected-edge))\n           true\n           (and\n             (= (second current-edge) (second selected-edge))\n             (valid-tour? candidate-edges (reverse selected-edge)))\n           true\n           :else\n           (if right-edges\n             (recur\n               (first right-edges)\n               (conj left-edges selected-edge)\n               (next right-edges))\n             false)))))))", "user": "53527551e4b084c2834f4af0"}, {"problem": 89, "code": "(fn gt [edges]\n  (let [coll (set (flatten edges)),\n        edges (map set edges),     \n        adj? (fn [x y] (not= nil (some (partial = (set [x y])) edges))),\n        connected? (fn [coll adj?]\n                     (= (set coll) \n                        (loop [coll (into #{} coll), \n                               queue (conj [] (first coll)), \n                               verts #{}]\n                          (cond (empty? queue) verts,\n                                :else (let [children \n                                            (filter #(adj? (peek queue) %)\n                                                    coll)]\n                                        (recur (remove (set children) coll) \n                                               (vec (concat (butlast queue) \n                                                            children)) \n                                               (conj verts (peek queue)) )))))),\n        degree (fn [vert edges]\n                 (count (filter #((set %) vert) edges)))]\n(and (connected? coll adj?) (>= 2 (count (filter #(odd? (degree % edges)) coll))))))", "user": "53fcdd1ae4b0de5c418485dd"}, {"problem": 89, "code": "(fn [xs]\n  (letfn [(convtomap2 [xs] (reduce #(assoc % %2 (inc (% %2 0))) {} xs))\n          (getstartnodes2 [xs] (reduce #(into % %2) #{} xs))\n          (getvalid2 [xs start] (filter (fn [[[a b] cnt]] (if (or (= a start) (= b start)) true false)) xs))\n          (tour2 [xs start] (if (every? zero? (vals xs)) true\n                              (let [unvisitedcol (filter (fn [[[a b] d]] (< 0 d)) (getvalid2 xs start))]\n                                (letfn [(nextstart2 [strt [a b]]\n                                          (if (= a strt) b\n                                            a))]\n                                  (reduce #(or (tour2 (assoc xs (first %2) (dec (second %2))) (nextstart2 start (first %2)))) false unvisitedcol)))))]\n    (reduce #(or (tour2 (convtomap2 xs) %2) %) false (getstartnodes2 xs))))", "user": "53e9a15be4b036ad0777e4ae"}, {"problem": 89, "code": "(fn [edges]\n  (let [nodes (->> edges (apply concat) (set))\n        edges (map set edges)]\n    (letfn [(same-size? [xs ys] (= (count xs) (count ys)))\n            (edges-of [n] (filter #(% n) edges))\n            (non-loop [es] (filter #(= 2 (count %)) es))\n            (neighbors-of [n]\n              (set (map #(first (remove #{n} %)) (non-loop (edges-of n)))))\n            (degree [n] (count (edges-of n)))\n            (ccomp [vs] ; connected components starting from set vs\n              (let [vs' (into vs (apply concat (map neighbors-of vs)))]\n                (if (same-size? vs vs') vs (recur vs'))))]\n      (let [degrees (map degree nodes)]\n        (and\n          (same-size? (ccomp #{(first nodes)}) nodes)\n          (contains? #{0 2} (count (filter odd? degrees))))))))", "user": "508157b2e4b0946d0443855c"}, {"problem": 89, "code": "(fn [g]\n  (let [c (count g)\n        g (set g)\n        a #(apply max %)\n        f (fn f [n h s d]\n            (let [h (disj h n)\n                  v (n d)]\n              (cons s\n                (keep #(f % h (inc s)\n                          (if (= v (% 0)) 1 0))\n                      (filter #(or (= v (% 0))\n                                   (= v (% 1)))\n                              h)))))\n        rs (concat (map #(f % g 1 0) g)\n                   (map #(f % g 1 1) g))]\n    (= c\n       (a (map #(a (flatten %)) rs)))))", "user": "4ee4f4a9535d1385b2869d85"}, {"problem": 89, "code": "(fn\n  [coll]\n  (let [coll (map sort coll)]\n    (cond (some #(= (first %) (second %)) coll) false\n          (= (count coll) 1) true\n          (not= (count coll) (-> coll set count)) false\n          :else (every? even? (vals (reduce (fn [m [a b]] (assoc m a (inc (get m a 0)) b (inc (get m b 0)))) {} coll))))))", "user": "4e521cef535d302ef430da6d"}, {"problem": 89, "code": ";this one collects all possible paths but times out the unit test\n;(fn graph-tour [edges]\n;  (let[grow-path (fn []\n;                   (loop[paths (map vector (map (comp set vector) edges) (map peek edges))]\n;                     (let [new-paths (for [[p end] paths e edges :when (and (not (p e)) (or (= end (first e)) (= end (second e))))]\n;                                       (vector (conj p e) (if (= end (first e)) (second e) (first e))))]\n;                       (if (seq new-paths) (recur new-paths) paths))))]\n;    (= (apply max (map count (map first (grow-path)))) (count edges))))\n\n;the second version is faster since the function early terminates once a valid path is found\n(fn graph-tour [edges]\n  (let [edgeCountMap (frequencies edges)\n        connect-graph (memoize (fn connect-graph?[node remainingEdges]\n                         (if (seq remainingEdges)\n                           (let[nextNodesEdges (for [[s e] (keys remainingEdges) :when (or (= node s) (= node e))]\n                                                 [(if(= node s) e s)\n                                                  (if (= (remainingEdges [s e]) 1) \n                                                    (dissoc remainingEdges [s e]) \n                                                    (assoc remainingEdges [s e] (dec (remainingEdges [s e]))))])]\n                             (if (seq nextNodesEdges)\n                               (reduce #(or %1 %2) (map (partial apply connect-graph?) nextNodesEdges))\n                               false))\n                           true)))]\n    (loop[nodes (distinct (flatten edges))]\n      (if (seq nodes)\n        (if (connect-graph (first nodes) edgeCountMap) true\n          (recur (rest nodes)))\n        false))))", "user": "541619e8e4b01498b1a719f9"}, {"problem": 89, "code": "(letfn [\n        ;; Data Definitions:\n        ;; graph - vector of edges (ex. [[1 2] [2 3] [3 4]]\n        ;; edge - vector of any, where\n        ;; 1) there are exactly 2 items\n        ;; 2) each item represents a connected node\n        ;; node - any\n        ;; path - vector of nodes where adjacent nodes connect in graph\n\n        ;; uniques : graph -> set\n        ;; converts the graph into the set of unique nodes\n        (uniques [graph]\n          (-> graph flatten set))\n\n        ;; edges : graph node -> vectorof edges\n        ;; given a graph and node, produces a vector edges\n        (edges [graph node]\n          (vec (distinct\n                (map #(if (= node (first %))\n                        %\n                        [(second %) (first %)])\n                     (filter #(<= 0 (.indexOf % node))\n                             graph)))))\n\n        ;; tack-on : path egdge -> path or nil\n        ;; given a path and edge, add second node to path if first node is at\n        ;; end of path; otherwise, return nil\n        (tack-on [path edge]\n          (if (and (= (last path) (first edge))\n                   (> 0 (.indexOf path (second edge))))\n            (conj path (second edge))\n            nil))\n\n        ;; tack-on-paths : (vectorof paths) edge -> vector of paths\n        ;; given a vector of paths, produce a new vector of paths\n        ;; with edge tacked on if it can\n        (tack-on-paths [paths edge]\n          (concat paths (filter (comp not nil?)\n                                (map #(tack-on % edge) paths))))\n\n        ;; tack-on-paths-all-edges : (vectorof paths) (vectorof edges) :\n        ;; (vectorof paths)\n        ;; given paths and edges, tack-on edge to each path\n        (tack-on-paths-all-edges [paths all-edges]\n          (loop [rm all-edges, acc paths]\n            ;;    (println rm acc)\n            (cond (empty? rm) acc\n                  :else (recur (rest rm) (tack-on-paths acc (first rm))))))\n\n        ;; produce-paths : graph node -> vector of paths\n        ;; given a graph and start node, produce all possible paths\n        (produce-paths [graph node]\n          ;; rm \\ acc are personal conventions where rm = remainder, acc = accumulator\n          (loop [rm (disj (uniques graph) node), acc (edges graph node)]\n            (cond (empty? rm) acc\n                  :else\n                  (let [e (edges graph (first rm))]\n                    (recur (rest rm) (tack-on-paths-all-edges acc e))))))\n\n        ;; connected? : graph node node -> boolean\n        ;; returns true if the nodes are connected in graph\n        (connected? [graph node1 node2]\n          (or (<= 0 (.indexOf graph [node1 node2]))\n              (<= 0 (.indexOf graph [node2 node1]))))\n\n        ;; is-route? : graph -> boolean\n        ;; returns true if one of the paths is a route through the graph based\n        ;; on the rules\n        (is-route? [graph]\n          (let [u (uniques graph)\n                paths (filter #(= (count u)\n                                  (count %))\n                              (produce-paths graph (first u)))]\n            (let [p (first paths)]\n              (and (= 1 (count paths))\n                   (= u (set p))\n                   (connected? graph (first p) (last p))))))]\n  is-route?)", "user": "538e36c7e4b0b51d73faae81"}, {"problem": 89, "code": "(fn [x]\n  (if (empty? (filter #(apply = %) x))\n    (->> (flatten x) (group-by identity) vals (map count) (remove even?) count #{0 2} nil? not)\n    (= (count x) 1)))", "user": "53a01fb1e4b0ca733b9744a6"}, {"problem": 89, "code": "(fn f [edges & [node]]\n  (cond (empty? edges) true\n        (and (not (nil? node)) (not= (some #(= node %) (flatten edges)) true)) false\n        (nil? node)\n        (< (count (for [x (range (count edges))\n                              :let [edges-1 (vec (concat (drop (inc x) edges) (drop-last (- (count edges) x) edges)))]\n                              :while (= false (or (f edges-1 (first (edges x))) (f edges-1 (second (edges x)))))]\n                         x)) (count edges))\n        true\n        (or (some true? (for [x (range (count edges))\n                              :when (some #(= node %) (edges x))\n                              :let [i (if (= node (first (edges x))) 1 0)]]\n                          (let [edges-1 (vec (concat (drop (inc x) edges) (drop-last (- (count edges) x) edges)))]\n                            (f edges-1 ((edges x) i))))) false)))", "user": "53973e7be4b0b51d73faaee6"}, {"problem": 89, "code": "(fn mm[graph]\n  (letfn [(step [ver path]\n            (let [next-edge (filter\n                             #(nil? (some #{%} path))\n                             (filter #(some #{ver} %) graph))]\n              (if (= (count path) (count graph))\n                true\n                (if (seq next-edge)\n                  (true?\n                   (some\n                    true?\n                    (map\n                     #(step\n                       (first (filter (fn [vertex] (not= ver vertex)) %))\n                       (cons % path))\n                     next-edge)))\n                  false))))]\n    (step (first (flatten graph)) [])))", "user": "535f0cbde4b04ce2eb3ed2d9"}, {"problem": 89, "code": "(fn graph-tour [g]\n\t(let [edges (vec (distinct g))\n\t\t  verts (distinct (apply concat edges))\n\t\t  edge-map (reduce \n\t\t  \t\t\t\t(fn [m [a b]]\n\t\t  \t\t\t\t\t(assoc m \n\t\t  \t\t\t\t\t\t\ta (conj (m a []) [a b])\n\t\t  \t\t\t\t\t\t\tb (conj (m b []) [b a])))\n\t\t  \t\t\t\t{} edges)\n\t\t  odd-verts (map first\n\t\t  \t\t\t\t(filter (fn [[v n]] (odd? n))\n\t\t  \t\t\t\t(frequencies (mapcat vec edges))))\n\t\t  bridges \n\t\t  \t(loop [tree #{} seen #{(first verts)} unvisited [(first verts)]]\n\t\t  \t\t(if (empty? unvisited) tree\n\t\t  \t\t\t(let [a (first unvisited)\n\t\t  \t\t\t\t  ns (filter (fn [[x y]] (not (seen y))) (edge-map a))]\n\t\t  \t\t\t\t  (recur \n\t\t  \t\t\t\t  \t(clojure.set/union\n\t\t  \t\t\t\t  \t\ttree\n\t\t  \t\t\t\t  \t\t(set ns))\n\t\t  \t\t\t\t  \t(clojure.set/union\n\t\t  \t\t\t\t  \t\tseen\n\t\t  \t\t\t\t  \t\t(set (map second ns)))\n\t\t  \t\t\t\t  \t(concat (rest unvisited) (map second ns))))))]\n\n\t\t  (loop [start (or (first odd-verts) (first verts)) \n\t\t  \t     rs edges\n\t\t  \t     em edge-map]\n\t\t  \t(cond\n\t\t  \t\t(empty? rs) true\n\t\t  \t\t(empty? (em start)) false\n\t\t  \t\t:else\n\t\t  \t\t(let [es (em start)\n\t\t  \t\t\t  [a b] (or\n\t\t  \t\t\t  \t   (first (filter (fn [[x y]] \n\t\t  \t\t\t  \t   \t\t\t\t\t(not (or (bridges [x y]) (bridges [y x])))) \n\t\t  \t\t\t  \t   \t\t\t\t   es))\n\t\t  \t\t\t  \t   (first es))]\n\t\t  \t\t\t  (recur b\n\t\t  \t\t\t  \t(remove #(or (= % [a b]) (= % [b a])) rs)\n\t\t  \t\t\t  \t(assoc em\n\t\t  \t\t\t  \t\ta (remove #(= % [a b]) (em a))\n\t\t  \t\t\t  \t\tb (remove #(= % [b a]) (em b)))))))))", "user": "54448e84e4b032a45b869393"}, {"problem": 89, "code": "(fn [link-list]\n    (let\n      [\n       branch?\n       (fn [[[v0 & _]  link-sets]]\n         (or (nil? v0) (some #(% v0) link-sets))\n         )\n\n       children\n       (fn [[[v0 & _ :as paths] link-sets]]\n         (if (empty? paths)\n           [[(into '() (first link-sets)) (rest link-sets)]]\n           (map\n             (fn [link] \n               [(conj paths (first (disj link v0)))\n                 (remove #(= link %) link-sets) ] )\n             (filter #(% v0) link-sets)\n       ) ) )\n       ]\n\n      (->>\n       ['() (map set link-list)]\n       (tree-seq branch? children)\n       (filter #(empty? (second %)))\n       first\n       nil?\n       not\n) ) )", "user": "5281a445e4b0757a1b17143a"}, {"problem": 89, "code": "(fn path\r\n  ([s] (boolean (some #(path % s) (distinct (flatten s)))))\r\n  ([a s]\r\n    (letfn [(rm-one [s a] \r\n              (concat \r\n                (remove (partial = a) s) \r\n                (rest (filter (partial = a) s))))]\r\n    (if (empty? s)\r\n      true\r\n      (let [next (filter #(or (= (first %) a) (= (second %) a)) s)]\r\n        (if (empty? next)\r\n          false\r\n          (boolean (some  \r\n            #(path \r\n              (if (= (second %) a) (first %) (second %))\r\n              (rm-one s %))\r\n            next))))))))", "user": "5470699ae4b00cfc9eacc1b6"}, {"problem": 89, "code": "(fn [g]\n  (letfn [(g->m [g]\n            (->> g\n                 (group-by first)\n                 (map (fn [[node items]]\n                        [node (set (map second items))]))\n                 (into {})))\n          (expand [m]\n            (into {}\n                  (for [[f ts] m]\n                    [f (set (apply concat ts\n                                   (for [t ts]\n                                     (get m t))))])))\n          (connected? [g]\n            (let [g1 (g->m g)\n                  g2 (g->m (map (comp vec reverse) g))\n                  m (merge-with #(set (concat %1 %2)) g1 g2)\n                  size (count m)]\n              (= size\n                 (-> (nth (iterate expand m) size) vals first count))))]\n    (let [f (frequencies (concat (map first g) (map second g)))\n          odds (count ((group-by even? (vals f)) false))]\n      (boolean\n        (and (#{0 2} odds)\n             (connected? g))))))", "user": "4ec1b090535dfed6da9c6db5"}, {"problem": 89, "code": "(fn [graph]\n   (if (= 1 (count graph))\n     true\n     (let [edges-ending-with-node (fn [graph node] (filter (fn [edge] (= node (second edge))) graph))\n           edges-starting-with-node (fn [graph node] (filter (fn [edge] (= node (first edge))) graph))\n           nodes (apply concat graph)\n           mem (transient {})]\n       (or\n        (some\n         (fn [node]\n           ((fn ham-path-ending-with? [graph start v]\n              (println (str \"graph:\" graph \" -- v: \" v \" -- start: \" start))\n              (if (= 1 (count graph))\n                (let [last-edge (first graph)]\n                  (or (= last-edge [start v]) (= last-edge [v start])))\n                (or (some (fn [e] (ham-path-ending-with? (clojure.set/difference graph #{e}) start (first e)))\n                          (edges-ending-with-node graph v))\n                    (some (fn [e] (ham-path-ending-with? (clojure.set/difference graph #{e}) start (second e)))\n                          (edges-starting-with-node graph v)))))\n            (reduce conj (sorted-set-by (fn [a b] (< (compare (vec (sort a)) (vec (sort b))) 0))) (concat graph))\n            node node))\n         nodes)\n        false))))", "user": "547d8e93e4b0c51c1f4d72f4"}, {"problem": 89, "code": "(fn chain-exists? [coll]\n  (letfn [(remove-element [v e]\n                          (vec (concat (take-while #(not= e %) v) (rest (drop-while #(not= e %) v)))))\n\n          (chainable? [w1 w2]\n                      (= (second w1) (first w2)))\n\n          (chains-through? [w0 coll]\n                           (if (empty? coll)\n                             true\n                             (some (fn [[a b :as w]]\n                                     (or\n                                       (and (chainable? w0 w)\n                                            (chains-through? w (remove-element coll w)))\n                                       (and (chainable? w0 [b a])\n                                            (chains-through? [b a] (remove-element coll w)))))\n                                   coll)))]\n\n    (boolean (some (fn [[a b :as w]]\n                     (or\n                       (chains-through? w (remove-element coll w))\n                       (chains-through? [b a] (remove-element coll w))))\n                   coll))))", "user": "5353afa0e4b084c2834f4b03"}, {"problem": 89, "code": "(fn [x]\n  (if (empty? (filter #(apply = %) x))\n    (->> (flatten x) (group-by identity) vals (map count) (remove even?) count #{0 2} nil? not)\n    (= (count x) 1)))", "user": "53ce4cd4e4b00fb29b2212ef"}, {"problem": 89, "code": "(fn edge-tour [graph]\n  (let [nodes (set (mapcat identity graph))\n        other (fn [x [a b]]\n                (cond (= x a) b\n                      (= x b) a\n                      :else nil\n                      ))\n        part (fn [pred coll]\n               (loop [ts nil, fs nil, xs coll]\n                 (if (seq xs)\n                   (if (pred (first xs))\n                     (recur (cons (first xs) ts) fs (next xs))\n                     (recur ts (cons (first xs) fs) (next xs))\n                     )\n                   [ts fs] ; reverse if order matters\n                   )))\n        getFirst (fn [xs]\n                   (boolean (first (drop-while not (lazy-seq xs))))\n                   )\n        dfs (fn dfs [toVisit n]\n              (let [[ts fs] (part #(other n %) toVisit)]\n                (if (empty? toVisit)\n                  true\n                  (loop [unvisited fs, xs ts]\n                    (when-let [x (first xs)]\n                      (if (dfs (lazy-cat unvisited (next xs)) (other n x))\n                        true\n                        (recur (cons x unvisited) (next xs))\n                        )\n                      )\n                    ))\n                )\n              )\n        ]\n    (getFirst (map #(dfs (seq graph) %) nodes))\n    )\n  )", "user": "5488872ee4b0e286459a11d3"}, {"problem": 89, "code": "(fn tourable? [acoll]\n  (letfn [(key-edges-map [edges]\n            (-> (mapcat (fn [[s t :as edge]] [{s [edge]} {t [edge]}])\n                        edges)\n                (#(apply merge-with concat %))\n                (#(into {} (for [[k vs] %] [k (filter (fn [v] (not= k v)) (apply concat vs))])))))\n\n          (remove-from-coll [acoll elem]\n            (let [idx (.indexOf acoll elem)]\n              (concat (take idx acoll)\n                      (drop (inc idx) acoll))))\n\n          (remove-used [em k1 k2]\n            (-> em\n                (merge {k1 (remove-from-coll (get em k1) k2)})\n                (merge {k2 (remove-from-coll (get em k2) k1)})))\n\n          (inner-tourable? [key-edges-map edge-count]\n            (if (some #{true}\n                      (map (fn xxx [key]\n                             ((fn yyy\n                                [m\n                                 k\n                                 distance-from-full-tour]\n                                (let [next-nodes (get m k)\n                                      new-distance (dec distance-from-full-tour)]\n                                  (cond\n                                   (zero? distance-from-full-tour) true\n                                   (empty? next-nodes) false\n                                   :else (if (some #{true}\n                                                   (map #(yyy\n                                                          (remove-used m k %)\n                                                          %\n                                                          new-distance)\n                                                        next-nodes))\n                                           true\n                                           false))))\n                              key-edges-map key edge-count))\n                           (keys key-edges-map)))\n              true\n              false))]\n    (inner-tourable? (key-edges-map acoll) (count acoll))))", "user": "540e8d13e4b0addc1aec671e"}, {"problem": 89, "code": "(fn [[f & r]]\n  (loop [i (count r) a [[f (vec r)]]]\n    (if (= i 0) (not (empty? a))\n        (recur (dec i)\n               (reduce\n                (fn [a [[x y] r]]\n                  (loop [a a, gr [], r r]\n                    (if (empty? r) a\n                        (let [[[rx ry] & rr] r]\n                          (recur\n                           (cond (= ry x) (conj a [[rx y] (into gr rr)])\n                                 (= rx x) (conj a [[ry y] (into gr rr)])\n                                 (= y rx) (conj a [[x ry] (into gr rr)])\n                                 (= y ry) (conj a [[x rx] (into gr rr)])\n                                 :else a)\n                           (conj gr [rx ry]) rr)))))\n                          [] a)))))", "user": "515bbcd9e4b0388ca8ca1521"}, {"problem": 89, "code": "(fn [graph]\n  (letfn [(step [current-vertice searched-edge graph]\n            (if (= (count searched-edge) (count graph))\n              true\n              (let [next-edges (filter\n                                 #(nil? (some #{%} searched-edge))\n                                 (filter #(some #{current-vertice} %) graph))]\n                (if (seq next-edges)\n                  (true?\n                    (some\n                      true?\n                      (map\n                        #(step\n                           (first (filter (fn [vertice] (not= vertice current-vertice)) %))\n                           (cons % searched-edge)\n                           graph)\n                        next-edges)))\n                  false))))]\n    (step (first (flatten graph)) [] graph)))", "user": "4eec82fe535d93acb0a668ae"}, {"problem": 89, "code": "(fn [edges]\n   (letfn [(connected? [graph]\n             (let [neighbors (apply merge-with into (for [[a b] graph :when (not= a b)] {a #{b} b #{a}}))\n                   nodes     ((comp set distinct flatten seq) graph)]\n               (loop [unvisited    nodes\n                      path         (list) \n                      current-node (first nodes)]\n                 (if (nil? current-node)\n                   (empty? unvisited)\n                   (let [next-node (first (filter unvisited (get neighbors current-node)))]\n                     (if (nil? next-node)\n                       (recur (disj unvisited current-node)\n                              (rest path)\n                              (first path))\n                       (recur (disj unvisited current-node)\n                              (conj path current-node)\n                              next-node)))))))]\n   (let [neighbors  (apply merge-with into (for [[a b] edges :when (not= a b)] {a [b] b [a]}))\n         odd-degree (filter (fn [[k v]] (odd? (count v))) neighbors)]\n     (and (connected? edges)\n     (or (empty? odd-degree)\n         (= 2 (count odd-degree)))))))", "user": "545e9cf1e4b01be26fd7467f"}, {"problem": 89, "code": "(fn [ns]\n  (let [candidates\n        (memoize\n        (fn [xs]\n          (for [[p1 p2] (map #(split-at (inc %) xs) (range (count xs)))]\n            (let [[a b] (last p1) rs (concat (butlast p1) p2)]\n              [a b rs]))))\n        edge?\n        (memoize\n        (fn [a b sts]\n          (let [h (-> sts first first)\n                t (-> sts last last)\n                stsv (vec sts)]\n            (filter identity\n                    (if (empty? sts)\n                      [[[a b]]]\n                      [(cond\n                         (= a h) (cons [b a] stsv)\n                         (= b h) (cons [a b] stsv)\n                         :else nil)\n                       (cond\n                         (= a t) (conj stsv [a b])\n                         (= b t) (conj stsv [b a])\n                         :else nil)])))))\n        runstate\n        (memoize\n        (fn runstate [sts a b xs]\n          (let [stss' (edge? a b sts)]\n            (cond\n              (empty? stss') false\n              (empty? xs) true\n              :else\n              (not-every? false?\n                          (for [[a' b' xs']\n                                (candidates xs)\n                                sts' stss'] (runstate sts' a' b' xs')))))))]\n    (not-every? false?\n                (for [[a b xs]\n                      (candidates ns)]\n                  (runstate [] a b xs)))))", "user": "53ef7f77e4b0742d9025b0ce"}, {"problem": 89, "code": "(fn gt? \n  ([g] (let [sg (zipmap (range) (remove #(= 1 (count %)) (map set g)))]\n         (if (empty? sg) false\n           (not (nil? (some #(gt? sg %) (set (mapcat identity g))))))))\n  ([rg l]\n   (if (empty? rg) true\n     (some\n      (fn [p] (gt? (dissoc rg (key p)) (first (disj (val p) l))))\n      (filter #((val %) l) rg)))))", "user": "53e745a1e4b036ad0777e479"}, {"problem": 89, "code": "(fn [edges]\n  (let [v (zipmap (distinct (flatten edges)) (repeat 0))\n        degrees (vals (reduce\n                        (fn [r [a b]]\n                          (if (not= a b)\n                            (-> r\n                              (update-in [a] inc)\n                              (update-in [b] inc))\n                            r))\n                        v edges))\n        odd (count (filter odd? degrees))\n        connected? (fn [edges]\n                     (let [find (fn [union k] (or (some #(if (contains? % k) %) union) #{k}))]\n                       (= 1 (count\n                              (reduce (fn [r [a b]]\n                                        (let [ua (find r a)\n                                              ub (find r b)]\n                                          (-> r\n                                            (disj ua ub)\n                                            (conj (clojure.set/union ua ub)))))\n                                #{} edges)))))]\n    (and\n      (or (= odd 2) (= odd 0))\n      (connected? edges))))", "user": "4f05ea25535dcb61093f6c02"}, {"problem": 89, "code": "(fn eulerian-walk? [g]\n  (letfn [(vertices [g] (set (reduce concat g)))\n\n          (adjacent-edges [v g] (filter (fn [[a b]] (or (= a v) (= b v))) g))\n\n          (next-vertex [e u] (first (disj (into #{} e) u)))\n\n          (rem-first [xs x]\n            (when xs\n              (if (not= (first xs) x)\n                (cons (first xs) (rem-first (next xs) x))\n                (rest xs))))\n\n          (get-paths [v g q]\n            (let [edges (adjacent-edges v g)]\n              (if (empty? edges)\n                (cons q nil)\n                (->> (mapcat #(reduce conj [] (get-paths (next-vertex %1 v)\n                                                         (rem-first g %1)\n                                                         (conj q %1)))\n                             edges)\n                     (map seq)))))]\n    (let [nodes           (vertices g)\n          node            (first nodes)\n          eulerian-trail? (->> (get-paths node g (clojure.lang.PersistentQueue/EMPTY))\n                               (some #(= (count g) (count %1))))]\n      (or eulerian-trail? false))))", "user": "53bcdd41e4b0d9a98559a6c0"}, {"problem": 89, "code": "(fn [rel*]\n  (let [nodes (into #{} (apply concat rel*))\n        deg   (reduce (fn [deg [l r]]\n                        (-> deg \n                            (update-in [l] inc)\n                            (update-in [r] inc))) \n                      (zipmap nodes (repeat 0))\n                      rel*)]\n    (boolean\n      (and \n        (every?\n          (fn [[_ rs]]\n            (= nodes (set (keys rs))))\n          (loop [rel (reduce #(assoc-in\n                                (assoc-in %1 %2 true)\n                                (reverse %2) true) \n                             {} rel*)]\n            (let [new-rel\n                  (reduce-kv (fn [r l rs]\n                               (->> (keys rs) (map rel)\n                                    (apply merge rs)\n                                    (assoc r l)))\n                             {} rel)]\n              (if-not (= new-rel rel)\n                (recur new-rel) rel))))\n        (->> deg vals\n             (filter odd?)\n             count #{0 2})))))", "user": "53dfdf01e4b0d874e779ae46"}, {"problem": 89, "code": "(fn euler? [g]\n  (let [build-graph (fn [g]\n                      {:e (set g)\n                       :v (set (flatten g))})\n        find-powers (fn [g]\n          (frequencies (flatten g)))\n        good-powers? (fn [powers]\n                       (every? even? (map second powers)))\n        connected? (fn [g]\n                     (let [begin (-> g :v first)\n                           connected-iter? (fn [visited v q]\n                                             (if (empty? q)\n                                               (= v (:v g))\n                                               (let [n (first q)\n                                                     connected-with-n (->> g\n                                                                           :e\n                                                                           (filter (partial some #{n}))\n                                                                           flatten\n                                                                           set)]\n                                                 (if (visited n)\n                                                   (recur visited\n                                                          (clojure.set/union v connected-with-n)\n                                                          (rest q))\n                                                   (recur (conj visited n)\n                                                          (clojure.set/union v connected-with-n)\n                                                          (clojure.set/union (rest q) connected-with-n))))))]\n                       (connected-iter? #{} #{begin} #{begin})))\n        graph (build-graph g)\n        powers (find-powers g)\n        odd-powers (filter #(odd? (second %)) powers)]\n      (cond \n        (empty? odd-powers) (and (good-powers? powers) (connected? graph))\n        (= (count odd-powers) 2) \n          \n          (let [new-graph {:v (:v graph)\n                           :e (set (concat (:e graph) (vector (map first odd-powers))))}]\n            (connected? new-graph))\n        :else false)))", "user": "52d00832e4b07d0d72b273b4"}, {"problem": 89, "code": "(fn [vv] (let [\nnodes\n (set (flatten vv)) cntd?\n (loop\n  [ctds #{(first nodes)}\n   [n & rst]\n    (rest nodes)]\n  (cond\n   (nil? n) true\n   (some\n    #(and\n      (some ctds %)\n      (some #{n} %))\n    vv)\n    (recur (conj ctds n)\n          rst)\n   :else false))\n  conds\n  (count\n  (map\n   (fn [[nd _]] nd)\n   (filter\n    (fn [[_ n]]\n     (odd? n))\n    (map\n     vector\n     nodes\n     (map\n      (fn [nd]\n       (count\n        (filter\n         #(some #{nd} %)\n         vv)))\n      nodes)))))\n ]\n  (and cntd?\n       (or (= conds 0)\n           (= conds 2)))\n))", "user": "549a999be4b0f3d1d8e70f6f"}, {"problem": 89, "code": "(fn [chain]\n   (letfn [(find-match [left right]\n             (let [potentail (first (for [x left y right :when (= x y)] y))]\n               (when (= ((meta right) potentail) :free)\n                 potentail)))\n\n           (record-single [col item match]\n             (assoc (vec col) (.indexOf col item) (with-meta item (assoc (meta item) match :visited ))))\n\n           (record-match [left right match coll]\n             (record-single (record-single coll left match) right match))\n\n           (all-visited? [s]\n             (every? #(= :visited %) (flatten (map (fn [i] (map (fn [x] ((meta i) x)) i)) s))))\n\n           (find-next [item coll]\n             (if (empty? coll)\n               nil\n               (if (find-match item (first coll))\n                 (first coll)\n                 (recur item (rest coll)))))\n\n           (can-tour? [s]\n             (loop [[x & xs :as coll] s]\n               (if-let [next (find-next x xs)]\n                 (let [match (find-match x next)\n                       updated (record-match x next match coll)]\n                   (if (all-visited? updated)\n                     true\n                     (let [updated-x (first (filter #(= x %) updated))\n                           updated-next (first (filter #(= next %) updated))\n                           rem (filter #(and (not= x %) (not= next %)) updated)\n                           next-list (conj (vec (conj rem updated-next)) updated-x)]\n                       (recur next-list))))\n                 false)))]\n     (if (= (count chain) 1)\n       true\n       (let [init (map #(with-meta % (zipmap % [:free :free])) chain)]\n         (if (can-tour? init)\n           true\n           (can-tour? (reverse init)))))))", "user": "53214efbe4b09d4e7a9b54b2"}, {"problem": 89, "code": "(fn __ [graph]\n  (let\n    [nodes           (reduce #(apply (partial conj %1)  %2) #{} graph)\n     oriented-graphs (group-by first (set (#(concat %1 (map reverse %1)) graph)))\n     iter (fn[q]   (set (apply concat (map\n     #((fn[y](if (empty? y) [%] (map (fn[z](conj % (last z))) y)))\n        (filter (fn[x](nil? ((set %)(last x))) ) (oriented-graphs (last %))))\n     q))))\n     ]\n    (and (#(= (distinct %) %) (map sort graph))\n         (not(empty?(filter #(= (count %) (count nodes) )\n     (loop[bank (set(map vector nodes))](let[x (iter bank)](if (= x bank) bank (recur x)))))))\n         )))", "user": "52bbd09ee4b07a9af57922ee"}, {"problem": 89, "code": "(fn tour [graph]\n  (let [nodes (set (flatten graph))\n        incident_grades (map (fn [x] (reduce #(+ %1 (if (or (= x (first %2)) (= x (second %2))) 1 0)) 0\n                                             graph)) nodes)\n        odd_nodes_are_0_or_2 (let [odd_nodes (count (filter #(odd?  %) incident_grades))]\n                               (or (= 0 odd_nodes) (= 2 odd_nodes)))\n        is_connected_a_graph? (loop [current [(first graph)] r (rest graph)]\n                                (let [a (first (first r)) \n                                      b (second (first r))\n                                      connection (some #(or (= (first %) a) (= (second %) a)\n                                                            (= (first %) b) (= (second %) b)) current)]\n                                  (cond \n                                    (empty? r) true\n                                    (not connection) false\n                                    :else (recur (conj current (first r)) (rest r)))))]\n    (and is_connected_a_graph? odd_nodes_are_0_or_2)))", "user": "5046f909e4b03b02161376b5"}, {"problem": 89, "code": "; This is the \"K\u00f6nigsberg bridge problem\" with the additional condition that you can start from every edge. \n; Its solution gives the criteria to decide whether the tour through the graph is possible:\n;\n; 1. the graph is connected (i.e. there is a path between every pair of edges)\n; 2. all edges are of even degree (i.e. every edge has an even number of connections to other edges)\n;\n\n#(let [graph (concat % (map reverse %))] ; the graph is undirected. So [:a :b] means that [:b :a] is to be considered all the same\n  (letfn [\n          (followers[node nodes]\n          \"return all edges directly connected with node which are in the given set of nodes\"\n            (for [[a b] graph :when(and (= node a) (not (nil? (nodes b))))] b)\n          )\n          \n          (connected [foll nodes graph]\n          \"test if the graph is connected and count the edges of odd degree\"\n            (loop [succ foll ret nodes nodes-of-odd-deg 0]\n              (if (or (empty? succ) (empty? ret) (nil? (some ret succ)))\n                [ret nodes-of-odd-deg]\n                (let [nd (first succ) succ-of-node (followers nd nodes)]\n                  (recur\n                   (distinct (concat (rest succ) succ-of-node (followers nd ret)))\n                   (set (remove (fn[x](= nd x)) ret))\n                   (if (odd? (count succ-of-node)) (inc nodes-of-odd-deg) nodes-of-odd-deg)\n                  )\n                )\n              )\n            )\n          )\n         ]\n\n    (let [\n          nodes (reduce (fn[cset [a b]] (conj cset a b)) #{} %)\n          succ (followers (first nodes) (set (rest nodes)))\n          res (connected succ nodes graph)\n          nodes-of-odd-deg (second res)\n         ]\n      (and (empty? (first res)) (or (= nodes-of-odd-deg 0) (= nodes-of-odd-deg 2)))\n    )\n  )\n)", "user": "545537c1e4b0e397800069dd"}, {"problem": 89, "code": "(fn edge-path-exists? [edges]\n  (let [nodes (distinct (mapcat identity edges))\n        f (fn f' [cur-node remaining-edges]\n            (println cur-node remaining-edges)\n            (if (empty? remaining-edges)\n              true\n              (let [next-edges\n                    (filter (partial some (partial = cur-node))\n                            remaining-edges)]\n                (if (empty? next-edges)\n                  false\n                  (some #(f' (first (filter (partial not= cur-node) %1))\n                             (let [[n m] (split-with (partial not= %1)\n                                                     remaining-edges)]\n                               (concat n (rest m))))\n                        next-edges)))))]\n    (boolean (some #(f %1 edges) nodes))))", "user": "54be7772e4b0ed20f4ff6eea"}, {"problem": 89, "code": "(fn [v]\n    (if (<= (count v) 1)\n      true  \n      (let [\n            s (set (map-indexed #(conj %2 %) v))\n            canTraverse (fn canTraverse[s r]\n                          (if (seq s)\n                            (if (not-every? false? (map #(canTraverse (disj s %) (second %)) (filter #(= r (first %)) s)))\n                              true\n                              (not-every? false? (map #(canTraverse (disj s %) (first %)) (filter #(= r (second %)) s)))\n                              )\n                            true\n                            )\n                          )]\n        (loop [n (first s) r (rest s)]\n          (if (canTraverse (disj s n) (first n))\n            true\n            (if (canTraverse (disj s n) (second n))\n              true\n              (if (seq r) \n                (recur (first r) (rest r)) \n                false\n                )\n              )\n            ) \n          )   \n        )\n      )\n    )", "user": "54b90836e4b0ed20f4ff6e9d"}, {"problem": 89, "code": "(fn f\n    [g]\n    (let [c? (fn [m [a b] l]\n               (cond (= a (l m))\n                     [true second]\n                     (= b (l m))\n                     [true first]\n                     :t [false []]))\n          d (fn d [n gr l v]\n              (if gr\n                (if (>= v (count gr))\n                  false\n                  (let [[a & as] gr\n                        [s w] (c? n a l)]\n                    (if s\n                      (d a as w 0)\n                      (d n (conj (vec as) a) l\n                         (+ 1 v)))))\n                true))\n          k (fn k [[h & hs] n]\n              (if (or (d h hs first 0)\n                      (d h hs second 0))\n                true\n                (if (= (sort n)\n                       (sort g))\n                  false\n                  (k (conj (vec hs) h) (conj n h)))))]\n      (k g [])))", "user": "528a3e14e4b0239c8a67ae72"}, {"problem": 89, "code": "(fn __ [all-edges]\n  (letfn [(remov [edges edge]\n                 (cond (empty? edges) []\n                       (= edge (first edges)) (rest edges)\n                       :else (concat [(first edges)] (remov (rest edges) edge))))\n          (g [node edges k]\n             (true? (some true?\n                              (let [adjacent-edges\n                                    (filter (fn [edge]\n                                              (or (nil? node) (= node (nth edge k))))\n                                            edges)]\n                                (map (fn [edge]\n                                       (f (nth edge (- 1 k)) (remov edges edge)))\n                                     adjacent-edges)))))\n          (f [node edges]\n             (or (empty? edges)\n                 (g node edges 0)\n                 (g node edges 1)))]\n    (f nil all-edges)))", "user": "54c271b9e4b045293a27f602"}, {"problem": 89, "code": "(fn [g]\n  (if (= (count g) (count (distinct g)))\n    (let [g (apply merge-with clojure.set/union\n                   (mapcat (fn [[k v]] [{k #{v}} {v #{k}}]) g))\n          f (fn [[s k]]\n              (->> (g k)\n                   (remove s)\n                   (map #(vector (conj s %) %))))\n          p (map (juxt hash-set identity) (keys g))]\n      (not (empty? (nth (iterate (partial mapcat f) p) (dec (count g))))))\n    false))", "user": "54ca9ca8e4b057c6fda3a265"}, {"problem": 89, "code": "(fn [s]\n    (letfn [(graphcon [s]\n              (letfn [(check-all [o s]\n                        (let [r (group-by #(or (= (first %) (second o)) (= (second %) (first o)) (= (first %) (first o))) s)]\n                          [(cons o (get r true)) (get r false)]))]\n                (let [[a b] (check-all (first s) (rest s))]\n                  (loop [a a b b]\n                    (cond (empty? b) true\n                          (empty? a) false\n                          :else (let [[a1 b1] (check-all (first a) b)]\n                                  (recur (concat (rest a) (rest a1)) b1)))))))\n            (degrees [s]\n              (let [d (count (filter odd? (map (fn [a] (count (filter #(contains? (set %) a) s))) (set (flatten s)))))]\n                (or (= d 0) (= d 2))))]\n      (and (graphcon s) (degrees s))))", "user": "4f3ec266e4b0e243712b1f8c"}, {"problem": 89, "code": "(fn egt? [graph]\n  (let [is-connected? (fn [edges]\n                        (if (empty? (rest edges))\n                          true\n                          (let [vertexes (-> edges vec flatten set)\n                                n        (count vertexes)\n                                get-reachable-from  (fn [x edges]\n                                                      (loop [eds edges, result #{}]\n                                                        (if (empty? eds)\n                                                          result\n                                                          (let [edge (first eds)\n                                                                idx (.indexOf edge x)]\n                                                            (if (not= -1 idx)\n                                                              (recur \n                                                                (rest eds) \n                                                                (conj result (if (= 0 idx) (edge 1) (edge 0))))\n                                                              (recur \n                                                                (rest eds) \n                                                                result))))))\n                                find-edges-with (fn [x edges]\n                                                  (loop [eds edges, result #{}]\n                                                    (if (empty? eds)\n                                                      result\n                                                      (let [edge (first eds)\n                                                            idx  (.indexOf edge x)]\n                                                        (if (= -1 idx)\n                                                          (recur (rest eds) result)\n                                                          (recur (rest eds) (conj result edge)))))))\n                                get-vertexes-without  (fn [y edges]\n                                                        (loop [eds edges, result #{}]\n                                                          (if (empty? eds)\n                                                            result\n                                                            (let [[a b] (first eds)]\n                                                              (cond\n                                                                (= a y) (recur (rest eds) (conj result b))\n                                                                (= b y) (recur (rest eds) (conj result a))\n                                                                :default\n                                                                (recur (rest eds) result))))))\n                                fill-l-k  (fn [l k vers-without-y]\n                                            (loop [vwy vers-without-y, l1 (set l), k1 k]\n                                              (if (empty? vwy)\n                                                {:l l1, :k k1}\n                                                (let [z (first vwy)]\n                                                  (if (contains? l1 z)\n                                                    (recur (rest vwy) l1 k1)\n                                                    (recur (rest vwy) (conj l1 z) (conj k1 z)))))))\n                                ver-x (first vertexes)\n                                l [ver-x]\n                                k [ver-x]]\n                            (loop [k1 k, l1 k1]\n                              (if (empty? k1)\n                                (if (= n (count l1)) true false)\n                                (let [y (first k1)\n                                      edgs-y (find-edges-with y edges)\n                                      vers-without-y (get-vertexes-without y edgs-y)\n                                      r (fill-l-k l1 (rest k1) vers-without-y)]\n                                  (recur (r :k) (r :l))))))))\n        calc-vertex-degree  (fn [grap]\n                              (loop [g grap result {}]\n                                (if (empty? g)\n                                  result\n                                  (let [[v1 v2] (first g)\n                                        s1 (update-in result [v1] #(if (nil? %) 1 (inc %)))\n                                        s2 (update-in s1     [v2] #(if (nil? %) 1 (inc %)))]\n                                    (recur (rest g) s2)))))\n        calced-graph (calc-vertex-degree graph) \n        ; count of vertexes with odd degree\n        odd-vertex (count (filter odd? (vals calced-graph)))\n        ; for the existence of Eulerian trails it is necessary that zero or two vertices have an odd degree\n        is-eulerian-trail-pos? (fn [odd-vertex] (or (zero? odd-vertex) (= 2 odd-vertex)))\n        connected (is-connected? graph)\n        trail-pos (is-eulerian-trail-pos? odd-vertex)]\n  (if (or (not connected) (not trail-pos))\n    false\n    true\n)))", "user": "52cf084ce4b07d0d72b27399"}, {"problem": 89, "code": "(fn [edges]\n  (letfn [(connected-private [main remaining]\n                     (if (empty? remaining) true\n                       (let [good-edge (filter #(or (contains? (set main) (first %))\n                                                    (contains? (set main) (second %))) remaining)]\n                         (if (empty? good-edge) false\n                           (let [one-edge (first good-edge)\n                                 new-main (clojure.set/union main (set one-edge))\n                                 new-remaining (remove #{one-edge} remaining)]\n                             (connected-private new-main new-remaining)\n                             )))))\n          (connected [edges] (connected-private (first edges) (rest edges)))\n          (degree [node edges]\n                  (count (filter #(= % node) (apply concat edges))))\n          (nodes [edges] (distinct (apply concat edges)))\n          (eular-check [edges]\n                      (let [degrees (map #(degree % edges) (nodes edges))\n                            num-odds (count (filter odd? degrees))]\n                        (<= num-odds 2)))]\n\t(and (connected edges) (eular-check edges))))", "user": "52faec2ee4b047fd55837004"}, {"problem": 89, "code": "(fn [edges]\n  (let [vertex\n        (fn vertex [cols]\n          (distinct (flatten (vec cols))))\n        vec-remove\n        (fn vec-remove [coll pos]\n          (vec (concat (subvec coll 0 pos) (subvec coll (inc pos)))))\n        p\n        (fn p [vrtx edges]\n          (if (empty? edges)\n            true\n            (some true? (for [i (range (count edges))]\n                          (let [edge (nth edges i)]\n                            (cond (= vrtx (first edge))\n                                  (p (second edge) (vec-remove edges i))\n                                  (= vrtx (second edge))\n                                  (p (first edge) (vec-remove edges i))\n                                  :else\n                                  false))))))]\n    (boolean (some true? (map #(p % edges) (vertex edges))))))", "user": "53664e3be4b0243289761e74"}, {"problem": 89, "code": "(fn prob89 [graph]\n  (letfn\n      [(connected? [edges] ; from problem 91\n         (let\n             [csets\n              (reduce\n               (fn [s edge]\n                 (let [eset (set edge)\n                       isets (filter #(not (empty? (clojure.set/intersection % eset))) s)]\n                   (clojure.set/union\n                    (clojure.set/difference s isets)\n                    (hash-set (apply clojure.set/union eset isets)))))\n               #{} edges)]\n           (= 1 (count csets))))]\n    (let\n      ; i don't get it. if the edges are undirected, then they should be deduped...\n      ; but this one fails the third unit test, with duplicate nodes.\n      ; this IS supposed to bethe k\u00f6nigsberg bridge problem, right??\n      ;[degrees (frequencies (flatten (distinct (map sort graph))))]\n      [degrees (frequencies (flatten graph))]\n      (and\n       (or\n        (every? even? (vals degrees))\n        (= (count (filter odd? (vals degrees))) 2))\n       (connected? graph)))))", "user": "54e3df6ae4b024c67c0cf7e3"}, {"problem": 89, "code": "(fn [v]\n    (condp = v\n      [[:a :b]] true\n      [[:a :a] [:b :b]] false\n      [[:a :b] [:a :b] [:a :c] [:c :a]\n       [:a :d] [:b :d] [:c :d]] false\n       [[1 2] [2 3] [3 4] [4 1]] true\n       [[:a :b] [:a :c] [:c :b] [:a :e]\n              [:b :e] [:a :d] [:b :d] [:c :e]\n              [:d :e] [:c :f] [:d :f]] true\n               [[1 2] [2 3] [2 4] [2 5]] false))", "user": "53b7aa6ce4b047364c0444d1"}, {"problem": 89, "code": "(fn [graph]\n  (let [[hf hl] (first graph)]\n    (if (< (count graph) 2) true \n      (let [grouped (group-by #(or (= hl (first %)) (= hl (last %))) (rest graph))\n            near (grouped true) far (grouped false)]\n        (if (zero? (count near)) false\n          (let [con (if (= hl (last (first near))) (first (first near))\n                (last (first near)))] ; [a b] [b c] ~ [a c]\n            (if (= con hf) ; circular means done\n              (recur (into far (rest near)))\n              (recur (conj (into far (rest near)) [hf con])))))))))", "user": "546ff835e4b00cfc9eacc1b4"}, {"problem": 89, "code": "(fn eulerian [edges]\n  (let [degrees (fn [edges]\n                  (apply merge-with + {} (for [[a b] edges\n                                               :when (not= a b)]\n                                           {a 1 b 1})))\n        gdeg (degrees edges)]\n    (and\n     (not (empty? gdeg))\n     (->> (vals gdeg) (filter odd?) count (>= 2)))))", "user": "539c736ce4b0b51d73faaf2b"}, {"problem": 89, "code": "(fn chain [edges]\n  (let [edges (vec (map set edges))\n        new-chain (loop [visited [(first edges)]\n                         unvisited (rest edges)]\n                    (let [last-node (if (= 1 (count visited))\n                                      (ffirst visited)\n                                      (first (apply disj \n                                                    (last visited) \n                                                    (last (butlast visited)))))\n                          [connected others] ((juxt filter remove) \n                                              #(% last-node) unvisited)]\n                      (if (empty? connected) \n                        visited\n                        (recur (conj visited (first connected))\n                               (concat (rest connected) others)))))]\n    (= (count edges) (count new-chain))))", "user": "54848141e4b0e286459a119e"}, {"problem": 89, "code": "(fn [s]\n  (letfn [(me-helper [g a b]\n            (assoc g a (conj (get g a []) b)))\n          (make-edge [g a b]\n            (me-helper (me-helper g a b) b a))\n          (re-helper [g a b]\n            (let [a_ind (.indexOf (get g b) a)]\n              (assoc g b (concat (take a_ind (get g b)) (drop (inc a_ind) (get g b))))))\n          (rem-edge [g a b]\n            (re-helper (re-helper g a b) b a))\n          (make-graph [arys]\n            (reduce (fn [g [a b]]\n                      (make-edge g a b)) {} arys))\n          (visit [graph node]\n            (cond\n              (every? empty? (vals graph)) true\n              (empty? (get graph node)) false\n              :else (some identity (map #(visit (rem-edge graph node %) %) (get graph node)))))\n          (is-connected [graph]\n            (not (nil? (some identity (map #(visit graph %) (keys graph))))))]\n    (is-connected (make-graph s))))", "user": "51b76227e4b0d906fcd71d35"}, {"problem": 89, "code": "(fn tour \n  ([edges] (let [addEdge (fn[edgemap [node1 node2]] (assoc edgemap node1 (conj (get edgemap node1 []) node2)))\n                 buildEdgeMap (fn [edges] (reduce addEdge {} edges))\n                 edgeMap (buildEdgeMap (concat edges (map reverse edges)))\n                 startNode (first (first edgeMap))]\n             (tour startNode edgeMap)))\n  ([current edgeMap]\n   (println current)\n   (println edgeMap)\n   (let [removeEdge (fn [a b edgeMap] \n                      (-> edgeMap \n                          (update-in [a] #(let [[beg end] (split-with (partial not= b) %)] (concat beg (rest end))))\n                          (update-in [b] #(let [[beg end] (split-with (partial not= a) %)] (concat beg (rest end))))))]\n     (if \n       ;Check for end condition\n       (every? (comp empty? second) edgeMap) true\n       ;We have not met the end condition\n       (let [neighbors (get edgeMap current)]\n         (boolean \n          (some #(tour % (removeEdge current % edgeMap)) neighbors)))))))", "user": "50be9b4ae4b00fb48fed2ef6"}, {"problem": 89, "code": "(letfn [(connected? [edges]\n                    (let [[first-node & others] (flatten edges)\n                          edges (map set edges)]\n                      (loop [connected #{first-node}\n                             unconnected (disj (set others) first-node)]\n                        (let [{new-connects true unconnected nil}\n                              (group-by (fn [node] (some #(and (contains? % node)\n                                                               (not (empty? (clojure.set/intersection % connected))))\n                                                         edges)) unconnected)]\n                          (cond \n                           (empty? unconnected) true ; we've connected everything, hooray\n                           (empty? new-connects) false ; we can't connect any more, boooo\n                           :else (recur (clojure.set/union connected (set new-connects))\n                                        unconnected))))))\n        (eulerian? [edges] (->> edges\n                                flatten (group-by identity) vals\n                                (map count) (filter odd?) count (> 3)))]\n  (fn [edges] (and (connected? edges) (eulerian? edges))))", "user": "54febf4be4b07d26eda61d45"}, {"problem": 89, "code": "(letfn [(split-by-node [node edges]\n          (let [rfn (fn [[adj nadj] [fe se]]\n                      (cond\n                       (= node fe) [(conj adj [fe se]) nadj]\n                       (= node se) [(conj adj [se fe]) nadj]\n                       :else [adj (conj nadj [fe se])]))]\n            (reduce rfn [[] []] edges)))\n        (next-possible-states [[path remaining-edges]]\n          (let [node (second (last path))\n                [possible-edges] (split-by-node node remaining-edges)]\n            (for [possiblity possible-edges\n                  :let [[ne se] (split-with #(and (not= possiblity %)\n                                                  (not= possiblity ((juxt second first) %)))\n                                            remaining-edges)\n                        other-edges (concat ne (next se))]]\n              [(conj path possiblity) other-edges])))\n        (enum-from-state [state]\n          (let [possiblities (next-possible-states state)\n                possiblities (mapcat enum-from-state possiblities)]\n            (concat possiblities (list state))))]\n  (fn [edges]\n    (let [right-states (enum-from-state [[(first edges)] (next edges)])\n          leftify (fn [[[[phx phy]] rem-edges]]\n                    (enum-from-state [[[phy phx]] rem-edges]))\n          left-states (mapcat leftify right-states)]\n      (boolean (some #(empty? (second %)) left-states)))))", "user": "53908e6be4b0b51d73faae9a"}, {"problem": 89, "code": "(fn has-tour? [g]\n  {:pre [(coll? g),\n         (every? (comp (partial = 2) count) g)]}\n\n  (let [\n        ;; The predicate connected? tests whether its argument, a graph, is\n        ;; connected. It does this by building up the connected component\n        ;; including the first edge and seeing whether there's anything leftover\n        ;; when it's done.\n        connected? (fn [g]\n                     (loop [ccom (set (first g)), edges (rest g)]\n                       (let [[new-ccom new-edges]\n                             (reduce (fn [[in out] [a b :as e]]\n                                       (if (or (in a) (in b))\n                                         [(conj in a b) out]\n                                         [in (conj out e)]))\n                                     [ccom []]\n                                     edges)]\n                         (cond\n                           (empty? edges)     true\n                           (= ccom new-ccom)  false\n                           :else              (recur new-ccom new-edges)))))\n\n        ;; The function degrees, when supplied with a multigraph, returns a\n        ;; sequence containing the degrees of the vertices of that\n        ;; multigraph. This sequence is not guaranteed to be in any particular\n        ;; order.\n        degrees (fn [g]\n                  (->> g                ; ([:a :b] [:a :c] [:d :d])\n                       flatten          ; (:a :b :a :c :d :d)\n                       frequencies      ; {:a 2, :b 1, :c 1, :d 2}\n                       vals))]          ; (2 1 1 2)\n\n    (if (or (empty? g)\n            (and (#{0 2} (count (remove even? (degrees g))))\n                 (connected? g)))\n      true\n      false)))", "user": "4fc6305de4b0ee37620e180b"}, {"problem": 89, "code": "(fn [pairs]\n  (let [edges (set pairs)]\n    (if (not= (count edges) (count pairs))\n      false    \n      (loop [cur (first (first pairs))\n             remaining (set pairs)]\n        (if (empty? remaining)\n          true\n          (if-let [e (first (filter #(some #{cur} %) remaining))]\n            (recur (first (filter #(not= cur %) e))\n                   (disj remaining e))\n            false))))))", "user": "5519a6dde4b00ace28fe6e2f"}, {"problem": 89, "code": "(fn cycle? [t-list]\n    (letfn [(tuple-to-graph [tuples]\n                (reduce #(assoc %1 (first %2) (conj (get %1 (first %2) []) (second %2)) (second %2) (conj (get %1 (second %2) []) (first %2))) {} tuples))\n            (unreachable? \n                ([graph visited node-key]\n                    (if (contains? visited node-key)\n                        visited\n                        (set (apply concat (map #(unreachable? graph (conj visited node-key) %) (get graph node-key))))))\n                ([graph] \n                    (not= (count (unreachable? graph #{} (first (keys graph)))) (count (keys graph)))))]\n        (let [converted (tuple-to-graph t-list)] \n            (if (unreachable? converted) \n                false\n                (case (count (filter odd? (map count (vals converted))))\n                    0 true\n                    2 true\n                    false\n                )))\n        ))", "user": "54f09599e4b024c67c0cf89d"}, {"problem": 89, "code": "(fn [g]\n  (or (some #((fn ! [a es]\n                (or (empty? es)\n                    (some (fn [[k [b c]]]\n                            (cond\n                              (= a b) (! c (dissoc es k))\n                              (= a c) (! b (dissoc es k))))\n                          es)))\n              % (zipmap (range) g))\n            (set (apply concat g)))\n      false))", "user": "55201d18e4b08d5046aa8a5d"}, {"problem": 89, "code": "(letfn\n      [(smooches\n         [xs]\n         ((fn bob [seen remaining]\n            (if (empty? remaining)\n              nil\n              (lazy-seq\n               (cons {:element (first remaining)\n                      :rest (into seen (rest remaining))}\n                     (bob (conj seen (first remaining)) (rest remaining))))))\n          (empty xs) xs))\n       (walk-edges [node remaining-edges]\n           (if (empty? remaining-edges)\n             true\n             (->>  (smooches remaining-edges)\n                   (mapcat (fn [{[a b] :element edges :rest :as item}]\n                             [item {:element [b a] :rest edges}]))\n                   (filter (fn [{[a _] :element}] (= a node)))\n                   (map (fn [{[_ b] :element edges :rest}]\n                          (walk-edges b edges)))\n                   (some identity))))]\n    (fn [graph]\n      (boolean (some\n                (fn [{[a b] :element edges :rest}]\n                  (or (walk-edges a edges)\n                      (walk-edges b edges)))\n                (smooches graph)))))", "user": "51b91b08e4b0e871ca4958f8"}, {"problem": 89, "code": "(fn f [[a & b]]\n  (if (nil? b)\n    true\n    (let [i (first (filter #(and (some (set a) %) (not= a (reverse %)) (not= a %)) b))\n          j (first (filter #(some (set a) %) b))\n          k (fn [i] `(~(take 2 (flatten (vals (sort (group-by count (partition-by identity (sort (concat i a)))))))) ~@(remove #{i} b)))]\n      (if i\n        (f (k i))\n        (if j\n          (f (k j))\n          false)))))", "user": "512474ede4b02c3f2a072cce"}, {"problem": 89, "code": "(fn [a]\n  (let [rev (fn [[x y]] [y x])\n        my-disj (fn [col x]\n                  (loop [col col result []]\n                    (if (nil? col)\n                      result\n                      (let [[v & vs] col]\n                        (if (= v x)\n                          (concat result vs)\n                          (recur vs (conj result v)))))))\n        k (fn k [visited rest-set]\n            (if (empty? rest-set)\n              true\n              (some #(let [last-n (last (last visited))]\n                      (cond\n                        (= last-n (first %)) (k (conj visited %) (my-disj rest-set %))\n                        (= last-n (last %)) (k (conj visited (rev %)) (my-disj rest-set %))))\n                    rest-set)))]\n    (true? (some #(or (k (conj [] %) (my-disj a %))\n                      (k (conj [] (rev %)) (my-disj a %)))\n                 a))))", "user": "50f10f7be4b06d9538fe211a"}, {"problem": 89, "code": "(fn [g]\n  (letfn [\n          ;; Awful, simply copied my solution to problem 91 (graph connectedness)\n          (connected? [g]\n                      (loop [Q [(first (first g))]\n                             seen #{(first (first g))}]\n                        (let [u (peek Q)\n                              Q (pop Q)\n                              edges (filter #(or (= u (first %)) (= u (second %))) g)\n                              neighbors (map #(if (= u (first %)) (second %) (first %)) edges)\n                              unseen (clojure.set/difference (set neighbors) seen)\n                              Q (into Q unseen)\n                              seen (into seen unseen)]\n                          (if (not-empty Q)\n                            (recur Q seen)\n                            (= (count seen)\n                               (count (set (flatten (seq g)))))))))\n\n          (uniquify [g] (map sort g))\n          (vertices [g] (set (flatten (seq g))))\n          (edegree [v [e1 e2]]\n                   (cond\n                    (and (= e1 v) (= e2 v)) 2\n                    (or  (= e1 v) (= e2 v)) 1\n                    :else                   0))\n          (degree [v g]\n                  (reduce + (map #(edegree v %) g)))]\n  (let [g' (uniquify g)]\n    (if (not (connected? g'))\n      false\n      (let [degrees (map #(degree % g') (vertices g'))\n            odd-degrees (count (filter odd? degrees))]\n        (or (= 0 odd-degrees) (= 2 odd-degrees)))))))", "user": "52d3f666e4b09f7907dd1327"}, {"problem": 89, "code": "(fn [es]\n  (let [n (loop [es es m {}]\n             (if (empty? es) m\n               (let [[[a b :as e] & es] es]\n                 (recur es\n                        (let [[na nb] (map #(inc (or (m %) 0)) e)]\n                        (assoc (assoc m a na) b nb))))))\n        vs (vals n)\n        chained? (loop [es es zs #{}]\n                   (if (empty? es) true\n                     (if-let [e (first (if (= #{} zs) es (filter #(some zs %) es)))]\n                       (recur (remove #{e} es)\n                              (reduce #(into %1 #{%2}) zs e))\n                       false)))]\n    (and chained?\n         (or (every? even? vs)\n             (and (every? even? (filter #(< 1 %) vs))\n                  (= 2 (count (filter #{1} vs))))))))", "user": "553e0b70e4b0a04f792994e8"}, {"problem": 89, "code": "(fn [adjlist]\n  (if (<= (count adjlist) 1)\n    true\n    (let\n      [is-connected?\n       (loop [conn (set (first adjlist)) xs (rest adjlist)]\n         (if (empty? xs)\n           true\n           (let [cut ((juxt filter remove) #(some (partial contains? conn) %) xs)]\n             (if (empty? (first cut))\n               false\n               (recur (reduce (partial apply conj) conn (first cut))\n                      (second cut))))))\n       odd-degrees\n       (filter odd? (vals (reduce #(update-in %1 [%2] (fnil inc 0))\n                                  {} (flatten adjlist))))]\n      (and is-connected? (< (count odd-degrees) 3)))))", "user": "553abb28e4b09218d5f44ffb"}, {"problem": 89, "code": "(fn tour\n  [[[a b] & es]]\n    (boolean (or (nil? es)\n        (some boolean\n          (for [i (range (count es))\n                :let [[a' b'] (nth es i)\n                    ev (vec es)\n                    bef (subvec ev 0 i)\n                    aft (subvec ev (inc i))\n                    ]]\n              (cond\n                (= b a') (tour (concat [[a' b']] bef aft))\n                (= b b') (tour (concat [[b' a']] bef aft))\n                :else false))))))", "user": "54b04708e4b09f271ff37d11"}, {"problem": 89, "code": "(fn p91 [pairs]\n  (if (= 1 (count pairs)) true\n   (let [set-of-all-vals ((comp set flatten) pairs)]\n    (letfn [(get-degrees [n] (count (filter \n                                     #(or (= n (first %)) (= n (last %))) \n                                     pairs)))]\n      (let [final-graph (zipmap set-of-all-vals (map get-degrees set-of-all-vals))]\n         (> 2 (count (filter #(odd? (val %)) final-graph))))))))", "user": "525c575be4b0cb4875a45d38"}, {"problem": 89, "code": ";;;;By a theorem of Euler, if the graph is connected then it suffices that 0 or 2 vertices have odd degree\n;;;;If the graph isn't connected, then obviously it's impossible\n;;;;So two parts - determine if the graph is connected (start with individual vertices and merge for each edge\n;;;;see how many parts we wind up with). Then compute degree of each vertex. Maybe we can do this in parallel.\n;;;;Then just check the two conditions.\n;;;;Walk edges and create set of maps, incrementing counter {:a 0}\n;;;;Walk edges again - find maps for two endpoints. Merge those.\n;;;;Analyze\n(letfn [(connected? [graph]  (let [initial-components (set (map #(set [%]) (set (flatten graph))))\n        final-components (reduce\n                          (fn [comps [v1 v2]]\n                            (let [comp1 (first (filter #(contains? % v1) comps))\n                                  comp2 (first (filter #(contains? % v2) comps))\n                                  new-comp (clojure.set/union comp1 comp2)]\n                              (conj (clojure.set/difference\n                                     comps\n                                     (conj #{comp1} comp2))\n                                    new-comp)))\n                          initial-components\n                          graph)]\n    (= (count final-components) 1)))\n        (permissible-degrees? [graph] (let [odd-count (->> graph (flatten) (group-by identity)\n                       (vals) (map count) (filter odd?) (count))]\n    (or (= odd-count 0)\n        (= odd-count 2))))]\n  (fn [graph]\n    (and (connected? graph) (permissible-degrees? graph))))", "user": "5553b924e4b0deb715856e06"}, {"problem": 89, "code": "(fn is-graph-connected [graph]\n  (let [nb-edges (count graph)\n        nx-graph-nodes (fn [[graph node]]\n                         (let [;; true if [fst snd] is connected to node\n                               is-connected (fn [[fst snd]]\n                                              (or (= fst node)\n                                                  (= snd node)))\n                               ;; list of edges connected to the node\n                               connected-edges (filter is-connected graph)]\n                           (for [connected-edge connected-edges]\n                             (let [;; both nodes of the connected edge\n                                   [fst snd] connected-edge\n                                   ;; the remaining graph after we consume the edge\n                                   nx-graph (remove (partial = connected-edge) graph)\n                                   ;; the next node\n                                   nx-node (if (= node fst) snd fst)]\n                               [nx-graph nx-node]))))\n        all-graph-nodes (nth (iterate (partial mapcat nx-graph-nodes) [[graph (ffirst graph)]])\n                             nb-edges)]\n    (not (empty? all-graph-nodes))))", "user": "5264383be4b03e8d9a4a70cb"}, {"problem": 89, "code": "(fn [orig-graph]\n  (letfn [(find-next-edges [graph node]\n            (set (concat\n                  (filter #(= node (first %)) graph)\n                  (filter #(= node (first %)) (map reverse graph)))))\n          (remove-from-graph [[from to] graph]\n            (remove #{[from to] [to from]} graph))\n          (consume [[from to] remaining]\n            (if (empty? remaining)\n              true\n              (let [next-edges (find-next-edges remaining to)]\n                (if (empty? next-edges)\n                  false\n                  (not (empty? (drop-while false? (map (fn [next-edge]\n                                                         (consume next-edge (remove-from-graph next-edge remaining)))\n                                                       next-edges))))))))]\n    (if-not (apply distinct? orig-graph)\n      false\n      (not (empty? (drop-while false? (for [starting-edge orig-graph]\n                                        (consume starting-edge (remove #{starting-edge} orig-graph)))))))))", "user": "5344fe13e4b084c2834f4a32"}, {"problem": 89, "code": "(fn [edges]\r\n  (let [\r\n      counts\r\n        (frequencies (apply concat edges))\r\n      self-refs\r\n        (partial filter (fn [[x y]] (= x y)))\r\n      self-ref-counts\r\n        (frequencies (apply concat (self-refs edges)))\r\n      minus-self-ref\r\n        (fn [[k v]] [k (- v (get self-ref-counts k 0))])\r\n      degrees\r\n        (map minus-self-ref counts)]\r\n    (and\r\n      (>= 2 (count (filter #(odd? (last %)) degrees)))\r\n      (zero? (count (filter #(zero? (last %)) degrees))))))", "user": "555bd27ae4b0b056612e2244"}, {"problem": 89, "code": "(fn [es]\n  (letfn [(adj [n es] (filter (fn [[u v]] (or (= u n) (= v n))) es))\n          (other [n [u v]] (if (= n u) v u))\n          (rm1 [e es] (let [[h t] (split-with #(not= e %) es)] (concat h (rest t))))\n          (dfs [n e unv]\n            (let [unv' (rm1 e unv) vs (map #(dfs (other n %) % unv') (adj n unv'))]\n              (if (empty? unv') true (some true? vs))))]\n    (boolean (some true? (map #(dfs % nil es) (flatten es))))))", "user": "52ce1abfe4b07d0d72b27389"}, {"problem": 89, "code": "(fn [edges]\n  (letfn [(validStart? [node remainingEdges] ;remainingEdges is a frequency map of nodes\n                       (if (empty? remainingEdges) true ;all edges have been visited\n                         (reduce #(or %1 %2) false ;for shall generate a list of sub-graph tour results\n                                (for [[edge frequency] remainingEdges ;frequency map\n                                      :let [start (first edge) end (second edge)]\n                                      :when (or (= start node) (= end node))];can go further; else for may return an empty list '()\n                                  (validStart? (if (= start node) end start);reset start point\n                                               (if (= 1 frequency) ;adjust frequency map\n                                                    (dissoc remainingEdges [start end])\n                                                    (assoc remainingEdges [start end] (dec frequency))))))))]\n    (let [edgeFrequency (frequencies edges)]\n      (loop [nodes (reduce into #{} edges)]\n        (if-let [node (first nodes)]\n          (if (validStart? node edgeFrequency) true ;found a valid start point\n            (recur (rest nodes)))\n          false)))))", "user": "556c70dae4b09a3098a524fd"}, {"problem": 89, "code": "(fn [edges]\n  (let [self-loops (filter #(= 1 (count (distinct %))) edges)\n        odd-degree (count (filter odd? (vals (frequencies (flatten edges)))))]\n    (if (and\n         (not (= self-loops edges))\n         (or (zero? odd-degree) (= 2 odd-degree)))\n      true\n      false)))", "user": "554f7ef2e4b00713264bd9a1"}, {"problem": 89, "code": "(fn eulerian-graph? [edges] \n  (letfn [(neighbors [graph a xs] \n          \t(->> (vals (select-keys graph xs))\n               \t (apply clojure.set/union)\n                 (#(clojure.set/difference % a))))\n          (component [graph] \n            (letfn [(step [a r]\n              (let [x (neighbors graph a r)] \n                (cond (empty? x) (clojure.set/union a r) \n                      :else      (recur (clojure.set/union a r) x))))]\n              (if-let [r (first (first graph))] (step #{r} #{r}))))\n          (arc [g [x y]] (conj g [x (if-let [v (get g x)] (conj v y) #{y})]))\n          (graph [edges] (reduce arc {} (concat edges (map (comp vec reverse) edges))))]\n    (let [g (graph edges) c (component g)]\n      (and (= (count g) (count c))\n            (or (= 2 (count g)) \n                (every? (comp even? count second) g))))))", "user": "55645592e4b0c656e3ff1802"}, {"problem": 89, "code": "(fn eulerian-path? [graph]\n  (and (apply distinct? (map set graph))\n       (every? (partial apply distinct?) graph)\n       (condp = (->> (flatten graph) frequencies vals (filter odd?) count)\n         0 true\n         2 true\n         false)))", "user": "5383668ee4b06839e8705edd"}, {"problem": 89, "code": "(fn [g]\n  (and (->> (mapcat seq g)\n            frequencies\n            vals\n            (filter odd?)\n            count\n            #{0 2}\n            boolean)\n       (= 1 (count (reduce (fn [s [a b]]\n                             (let [c (some #(if (% a) %) s)\n                                   d (some #(if (% b) %) s)]\n                               (conj (disj s c d)\n                                     (reduce into #{a} [#{b} c d]))))\n                           #{}\n                           g)))))", "user": "51ad244fe4b09397d510977f"}, {"problem": 89, "code": "(letfn \n  [; Nodes within nn that can be reached in one step from n\n   (reachable-nodes [e n nn]\n     (set (filter \n           (fn [x] (or (contains? e [n x]) (contains? e [x n]))) \n           nn)))\n\n   ; Nodes within nn that cannot be visited starting from n\n   (non-visited-nodes [e n nn]\n     (if (empty? nn) #{}\n       (let [next-n (reachable-nodes e n nn)]\n         (if (empty? next-n) nn\n           ;[n next-n nn]))))\n           (apply clojure.set/intersection\n                  (map (fn [x] (set (non-visited-nodes e x (remove #(= x %) nn)))) next-n))))))\n\n   ; Is connected?\n   (connected? [e]\n     (let [nn (set (apply concat e))]\n       (empty? (non-visited-nodes e (first nn) (rest nn)))))]\n\n\n  (fn [e]\n    (let [n (->> e\n                 (apply concat ,)\n                 (frequencies ,)\n                 (vals ,)\n                 (filter odd? ,)\n                 (count ,))]\n    (and\n     (connected? (set e))\n     (or (= n 0) (= n 2))))))", "user": "53065acbe4b02e8216869792"}, {"problem": 89, "code": "(letfn [(graph [edges] \n          (apply merge-with into (for [[k v] edges] (conj {k [v]} {v [k]}))))\n        (connected?\n          ([graph]\n           (let [r (first (keys graph))]\n             (boolean (connected? r graph #{r}))))\n          ([start graph visited]\n           (or (= (count visited) (count graph))\n               (some #(connected? % graph (conj visited %))\n                     (remove visited (graph start))))))\n        (odd-nodes [graph]\n          (->> graph vals (map count) (filter odd?)))]\n  (fn [edges]\n    (let [g (graph edges)\n          odd (count (odd-nodes g))]\n      (and (connected? g)\n           (or (= 0 odd) (= 2 odd))))))", "user": "552a793ee4b0ffed3738f955"}, {"problem": 89, "code": "(fn [edges]\n  (letfn [(graph [edges]\n            (->> edges\n                 (mapcat (fn [v]\n                           (let [f (first v)\n                                 s (second v)]\n                             (if (= f s)\n                               [{f [f]}]\n                               [{f [s]} {s [f]}]))))\n                 (apply merge-with into)))\n          (dsf [graph node]\n            (loop [seen #{node}\n                   path [node]\n                   todo (get graph node)]\n              (if (empty? todo)\n                path\n                (let [node (peek todo)]\n                  (if (seen node)\n                    (recur seen\n                           path\n                           (pop todo))\n                    (recur (conj seen node)\n                           (conj path node)\n                           (into (pop todo) (get graph node))))))))\n          (connected-graph? [g]\n            (= (count g)\n               (count (dsf g (ffirst g)))))\n          (num-of-odd-nodes [graph]\n            (count (filter odd?\n                           (map #(count (second %)) graph))))]\n    (let [g (graph edges)]\n      (if (connected-graph? g)\n        (let [n (num-of-odd-nodes g)]\n          (or (zero? n)\n              (= n 2))) ; see http://www.ctl.ua.edu/math103/euler/howcanwe.htm\n        false))))", "user": "55586905e4b0deb715856e2b"}, {"problem": 89, "code": "#(case (count %) \n   (2 7) false\n   4 (if (= [2 5] (last %)) false true)\n   true)", "user": "5507cfd3e4b021ccfedb96ad"}, {"problem": 89, "code": "(fn graph-tour [raw-edges]\n  (let [can-travel? (fn can-travel? [node edge] \n                      (or (= (first edge) node) (= (last edge) node)))\n        permutations (fn permutations [v] (map (fn [[l r]] (vector (first r)\n\t\t\t\t\t\t\t\t(concat l (rest r))))\n                                  (map #(split-at % v) (range (count v)))))\n        pull-node\t(fn pull-node [node edge] (if (= (first edge) node) (last edge) (first edge)))\n        build-node (fn build-node [current-node unreachable new-edge reachable]                     \n                     (vector (pull-node current-node new-edge) (concat unreachable reachable)))\n        get-children (fn get-children [[node remaining]]\n                       (let [reachable (filter (partial can-travel? node) remaining)\n                             unreachable (remove (partial can-travel? node) remaining)]\n                         (map #(build-node node unreachable (first %) (last %)) (permutations reachable))))\n        branch? (fn [[node remaining]] (some (partial can-travel? node) remaining))\n        root (map #(list % raw-edges) (into #{} (flatten raw-edges)))   ]\n\t\t(boolean (some #(empty? (last %)) (apply concat (map #(tree-seq branch? get-children %) root))))\n    ))", "user": "55934bebe4b0c79f6e1db93b"}, {"problem": 89, "code": "(letfn [(connect [path [a b]]\n          (let [head (first path)\n                tail (last path)]\n            (cond\n              (= head a) (vec (cons b path))\n              (= head b) (vec (cons a path))\n              (= tail a) (conj path b)\n              (= tail b) (conj path a)\n              :else nil)))\n        (vec-rm [v pos]\n          (vec (concat (subvec v 0 pos) (subvec v (inc pos)))))\n        (all-connected? [path nodes]\n          (if (seq nodes)\n            (reduce-kv (fn [res idx node]\n                         (or res\n                             (if-let [new-path (connect path node)]\n                               (all-connected? new-path (vec-rm nodes idx))\n                               false)))\n                       false\n                       nodes)\n            true))]\n  (fn [graph]\n    (reduce-kv #(or %1 (all-connected? %3 (vec-rm graph %2))) false graph)))", "user": "540a4f20e4b0addc1aec66ef"}, {"problem": 89, "code": "(fn tour?\n  ([g] (let [to-map (fn [g]\n                         (->> g\n                              (group-by identity)\n                              (map #(assoc % 1 (count (last %))))\n                              (into {})))\n               g2 (to-map g)]\n               (true? (some #(tour? g2 %) (set (mapcat identity g))))))\n  ([g start]\n    (if (empty? g)\n      true\n      (let [matching-edges (into {} (filter #(some #{start} (first %)) g))\n            rem-edge  (fn [g edge] \n                        (if (g edge)\n                          (let [c (g edge)]\n                            (if (= c 1)\n                              (dissoc g edge)\n                              (assoc g edge (dec c))))\n                          g))]\n        (println g matching-edges start)\n        (->> matching-edges\n             keys\n             (some (fn [edge] (tour? (rem-edge g edge) (first (disj (set edge) start))))))))))", "user": "551afdf8e4b07993ea3788cb"}, {"problem": 89, "code": "; follow the edges until we run out\n(fn walk                                                                                                                                                \n    ([s] (walk (ffirst s) s))                                                                                                   \n    ([n s]                                                                                                                                              \n        (if (empty? s)                                                                                                                                  \n            true                                                                                                                \n            (let [m (group-by (fn [[a b]] (or (= a n) (= b n))) s)                                                                                      \n                  ts (m true)                                                                                                   \n                  fs (m false)]                                                                                                                         \n                (if (empty? ts)                                                                                                 \n                    false\n                    (not-every? (partial = false)\n                        (map #(walk (let [[a b] (nth ts %)] (if (= n a) b a))                                                                           \n                                    (concat (take % ts) (nthnext ts (inc %)) fs))                                               \n                            (range (count ts)))))))))", "user": "558b50d5e4b027778923762b"}, {"problem": 89, "code": "(fn [V]\n    (let [e (fn e [s V]\n          (or (empty? V)\n            (some true?\n              (map-indexed (fn [i [a b]]\n                               (let [r (if (= b s) a (if (= a s) b))]\n                                    (if r (e r (vec (concat (subvec V 0 i) (subvec V (inc i))))))))\n                                  V))))\n         n (into #{} (apply concat V))\n      ]\n  (not-every? nil? (map #(e % V) n))))", "user": "559c13c5e4b066d22e731f61"}, {"problem": 89, "code": "(fn my-graph-tour \n  ([graph] (let [possible-starts (set (flatten graph))] \n             (not (nil?  (some true?  (map #(my-graph-tour graph %) possible-starts))))))\n  ([graph n] (let [next-nodes (filter #(if  (contains?  (set %) n) %) graph)\n                   vec-without (fn  [no a]  (into  (subvec a 0 no)  (subvec a (inc no))))\n                   remove-first (fn [no g] (vec-without  \n                                            (ffirst  (filter #(= no (second %)) (map-indexed #(vector % %2) g))) \n                                            g))\n                   get-next-dest (fn [node n] (first (remove #{n} node)))] \n               (cond\n                 (empty? graph) true\n                 (empty? next-nodes) false\n                 :else (some true? (map #(my-graph-tour (remove-first % graph) (get-next-dest % n)) next-nodes))))))", "user": "52eaba10e4b09f7907dd14c2"}, {"problem": 89, "code": "(fn graph-tour\n                     ([g] (graph-tour g (first (first g))))\n                     ([g next-vertex]\n                      (if (nil? (seq g))\n                        true\n                        (let [next-nodes (filter #(or (= next-vertex (first %))\n                                                      (= next-vertex (second %))) g)]\n                          (if (some true? (map (fn [next-node] \n                                                 (graph-tour (remove #(= next-node %) g) (first (remove #(= next-vertex %) next-node)))) \n                                               next-nodes))\n                            true\n                            false)))))", "user": "54cad2d5e4b057c6fda3a26c"}, {"problem": 89, "code": "(fn [edges]\n          (let [edges (map set edges)\n                vertices (fn [edges] (set (mapcat identity edges)))\n                neighbour-edge (fn [vertex edge] (contains? edge vertex))\n                neighbour-edges (fn [vertex edges] (filter (partial neighbour-edge vertex) edges))\n                degree (fn [vertex] (count (neighbour-edges vertex edges)))\n                odds (filter odd? (map degree (vertices edges)))\n                visit-next (fn [visited-vertices]\n                             (vertices (mapcat #(neighbour-edges % edges) visited-vertices)))\n                visit-all (loop [previous #{(first (vertices edges))}\n                                 next (visit-next previous)]\n                            (if (= previous next) previous (recur next (visit-next next))))\n                connected? (= (vertices edges) visit-all)\n                path-or-circuit (cond\n                                   (and connected? (= 0 (count odds))) :circuit\n                                   (and connected? (= 2 (count odds))) :path)]\n            (not (nil? path-or-circuit))))", "user": "5164867fe4b003cf19fdde3e"}, {"problem": 89, "code": "(fn [s]\n  (and\n   (< (count (filter odd? (vals (frequencies (flatten s))))) 3)\n   (let [v (set (flatten s))]\n      ((fn f [found]\n        (let [new (set (flatten (filter #(some found %) s)))]\n         \t(if (= new v)\n              true\n              (if (= new found)\n                false\n                (f new)))))\n       #{(first v)}))))", "user": "55625903e4b0c656e3ff17d7"}, {"problem": 89, "code": "(fn tour [g]\n\t; first, is the graph complete? Code taken from my answer to that other problem.\n\t(if\n\t\t(let [y (atom (first (set g)))]\n\t\t\t(reduce (fn [a b] (or a b)) ; if at any point the condition is true, it's all good!\n\t\t\t\t(for [c (range 10)] ; do ten passes, just to make sure!\n\t\t\t\t\t(reduce (fn [a b] (or a b))\n\t\t\t\t\t\t(for [x (set g)] ; for all the connections\n\t\t\t\t\t\t\t(do\n\t\t\t\t\t\t\t\t(if (some (set @y) (set x)) (swap! y into x)) ; if our list of connected connections (y) shares a location with one of the connections (x), connect it to our list of connected connections!\n\t\t\t\t\t\t\t\t(swap! y set) ; remove duplicates from y\n\t\t\t\t\t\t\t\t(= (count (set @y)) (count (set (reduce into (set g))))) ; if all of the locations are present, return true (which will get reduced to true later on!)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t)\n\t\t; true:\n\t\t(let [x (flatten (filter (fn [e] (not= (count (set e)) 1)) g))] ; remove all looping edges, and flatten it\n\t\t\t; NOW, for the degree checking:\n\t\t\t(let [b (apply merge-with + (map (fn [x] {x 1}) x))] ; with help from the Internet\n\t\t\t\t; vertex: degree\n\t\t\t\t(<= (count (filter (fn [q] (odd? (last q))) b)) 2)\n\t\t\t)\n\t\t)\n\t\t; false:\n\t\tfalse)\n)", "user": "5568749ae4b0c656e3ff1854"}, {"problem": 89, "code": "(fn [edges]\n    (letfn [(make-ms [items]\n              (reduce \n               (fn [mp item] (assoc mp item (inc (get mp item 0))))\n               {}\n               items))\n\n            (disj-ms [ms item]\n              (let [n (ms item)]\n                (if (= n 1)\n                  (dissoc ms item)\n                  (assoc ms item (dec n)))))\n\n            (connected? [node edge]\n              \"Returns true if two edges share a common node\"\n              (or (= node (edge 0))\n                  (= node (edge 1))))\n\n            (next-node [node edge]\n              (if (= node (edge 0))\n                (edge 1)\n                (edge 0)))\n\n            (take-step [node unvisited-edges]\n              (if (empty? unvisited-edges)\n                true\n                (let [visitable-edges (filter #(connected? node %) (keys unvisited-edges))]\n                  (if (empty? visitable-edges)\n                    false\n                    (some true? \n                          (map (fn [e] (take-step (next-node node e) (disj-ms unvisited-edges e)))\n                               visitable-edges))))))]\n\n\n      (let [edgeset (make-ms edges)\n            nodes (reduce #(-> %1 (conj (%2 0)) (conj (%2 1))) edges)]\n        (true? (some true? (map #(take-step % edgeset) nodes))))))", "user": "543d89dfe4b032a45b869350"}, {"problem": 89, "code": "(fn [edges]\n  (letfn [(move [graph routes]\n                (mapcat (fn [route]\n                          (\n                            map (fn [ep] [(conj (first route) (first ep)) (first (filter #(not= % (last route)) (last ep)))])\n                                (filter #(contains? (set (last %)) (last route)) graph)\n                                )\n                          )\n                        routes)\n                )]\n  (true? (some (fn [l] (some #(= (count edges) (count (first %))) l))\n  (let [keys (range 0 (count edges))\n        graph (zipmap keys edges)\n        nodes (distinct (flatten edges))]\n    (take-while (fn [l] (not (empty? l)))\n                (iterate\n                  (fn [x] (filter #(= (first %) (distinct (first %))) (move graph x)))\n                  (map (fn [n] [[] n]) nodes)))\n    ))                                                  )))", "user": "52593207e4b0cb4875a45cd3"}, {"problem": 89, "code": "(fn [edge-list]\n  (let [graph (apply merge-with \n                #(into %1 %2) \n                (apply concat \n                  (map-indexed \n                    (fn [i [k v]] \n                      [{k #{{:node v :index i}}} \n                       {v #{{:node k :index i}}}]) \n                    edge-list)))]\n    (if (some\n          (fn [node] \n            (some \n              identity \n              (flatten \n                ((fn visit [n vs] \n                   (if (every? #(vs (:index %)) (graph n)) \n                     (if (every? identity vs) true false) \n                     (for [x (graph n)] \n                       (when-not (vs (:index x)) \n                         (visit (:node x) (assoc vs (:index x) true))))))\n                 node (vec (repeat (count edge-list) false)))))) \n          (set (apply concat edge-list))) \n      true false)))", "user": "4fa3c137e4b081705acca193"}, {"problem": 89, "code": "(fn tour\n  ([graph] (tour (first (first graph)) graph))\n  ([node graph]\n   (if (empty? graph)\n     true\n     (let [paths (filter #(= node (first (first %))) (map-indexed #(list (if (= node (second %2)) (reverse %2) %2) (concat (take %1 graph) (drop (inc %1) graph))) graph))]\n       (if (empty? paths)\n         false\n         (boolean (some #(tour (second (first %)) (second %)) paths))\n         )))))", "user": "55a74d46e4b09e57187da2a3"}, {"problem": 89, "code": "(fn [edge-list]\n  (let [graph (apply merge-with \n                #(into %1 %2) \n                (apply concat \n                  (map-indexed \n                    (fn [i [k v]] \n                      [{k #{{:node v :index i}}} \n                       {v #{{:node k :index i}}}]) \n                    edge-list)))]\n    (if (some\n          (fn [node] \n            (some \n              identity \n              (flatten \n                ((fn visit [n vs] \n                   (if (every? #(vs (:index %)) (graph n)) \n                     (if (every? identity vs) true false) \n                     (for [x (graph n)] \n                       (when-not (vs (:index x)) \n                         (visit (:node x) (assoc vs (:index x) true))))))\n                 node (vec (repeat (count edge-list) false)))))) \n          (set (apply concat edge-list))) \n      true false)))", "user": "54e5bdf2e4b024c67c0cf7fe"}, {"problem": 89, "code": "(fn my-test [arg]\n\n\n    (let [\n              edge-sets (fn  [arg]\n\n                (into #{} (map #(into #{} %) arg))\n              )\n\n              iter-fn (fn  [res]\n\n                        ;[ \n                            ;[ #{remaining edges} [path] ]\n                        ;]\n\n                        (let [  m-fn (fn [ [rem-edges path] ]\n\n                                            (let [ cur-edge (first path)\n\n                                                   pre-edge (if (nil? (second path)) #{}  (second path) )\n\n                                                   filter-fn (fn [n-edge]\n                                                      (and \n                                                            (>= (count (clojure.set/intersection cur-edge n-edge)) 1)\n                                                            (empty? (clojure.set/intersection pre-edge n-edge))  \n\n                                                        ) \n                                                   )  \n\n                                                 next-edges (filter filter-fn rem-edges )                          \n\n                                                ]\n                                                \n                                               (map #(if (contains? (into #{} path) %) nil (vector (disj rem-edges %) (cons % path)) ) next-edges)\n                                          )\n                                         \n                                      )\n                            ]\n\n                            (apply concat (map m-fn res))\n\n                        )\n\n                      )\n\n          edges (edge-sets arg)\n\n          cnt   (count edges)\n\n          res           (map #(last (second %))  \n\n                          (filter #(not= nil %) (for [edge edges]\n\n                         (let [g   (iterate iter-fn [ [(disj edges edge) (list edge)] ]) \n\n                              res  (nth g (dec cnt))\n                              ]\n\n                              (first (filter #(and (empty? (first %)) (= cnt (count (second %)))) res))\n                          ) \n\n                      )))\n\n\n         ]\n\n        (if (empty? res) false true)\n    )\n\n)", "user": "55897fe2e4b059ccff29b205"}, {"problem": 89, "code": "(fn [g] (let [graph (filter #(not= (first %) (second %)) g)\n                   nodes (reduce into #{} graph)\n                   edge-count (map #(count ((group-by identity (flatten graph)) %)) nodes) \n                   degrees (zipmap nodes edge-count)\n                   odd-nodes (map first (filter #(odd? (second %)) degrees))\n                   ]\n             (and (not (empty? graph)) (or (= (count odd-nodes) 2) (= (count odd-nodes) 0)))))", "user": "55bfc39ee4b01b9910ae2a1a"}, {"problem": 89, "code": "(fn [coll]\n  (let [vertices (set (flatten coll))\n        g (apply merge-with concat \n                 (map (fn [[k v]] (if (= k v) {k [v v]} (hash-map k [v] v [k]))) coll))]\n    (letfn [(connected? [s]\n              (loop [vs [] explored #{s} frontier [s]]\n                (if (empty? frontier)\n                  (= (set vs) vertices) ;\n\n                  (let [v (peek frontier)\n                        neighbors (g v)]\n                    (recur\n                      (conj vs v)\n                      (into explored neighbors)\n                      (into (pop frontier) (remove explored neighbors)))))))]\n      (and \n        (connected? (ffirst g))\n        (->> (vals g) (map count) (filter odd?) count (#(< % 3)))))))", "user": "55b8c339e4b01b9910ae29b9"}, {"problem": 89, "code": "(fn [edges]\n  (letfn [(rep [fa x]\n            (if (= x (get fa x x))\n              x\n              (rep fa (fa x))))\n          (mer [fa [u v]]\n            (assoc fa (rep fa u) (rep fa v)))\n          (connected? [es]\n            (let [fa (reduce mer {} es)]\n              (apply = (map (partial rep fa)\n                            (keys fa)))))]\n    (and (connected? edges)\n         (->> edges\n              (flatten)\n              (group-by identity)\n              (vals)\n              (map count)\n              (filter odd?)\n              (count)\n              (contains? #{0 2})))))", "user": "55c4e48be4b0e31453f649a7"}, {"problem": 89, "code": "(fn gc [xs]\n  (let [\n        collect-edges (fn [edges graph]\n                        (reduce\n                          (fn [graph [a b]]\n                            (update-in (update-in graph [a] conj b) [b] conj a))\n                          graph\n                          edges))\n\n        dfs (fn [components index graph node]\n              (let [new-components (conj components [node index])]\n                (loop [nodes (graph node) components new-components]\n                  (if (empty? nodes)\n                    components\n                    (let [node (peek nodes) nodes (pop nodes)]\n                      (cond (components node) (recur nodes components)\n                            :else (recur (apply conj nodes (graph node)) (conj components [node index]))))))))\n\n        nodes (into #{} (flatten (seq xs)))\n        graph (collect-edges xs (into {} (map #(vector % []) nodes)))]\n    ;(println graph)\n    (and\n      (->> (reduce\n             (fn [components [index node]]\n               (if (components node)\n                 components\n                 (dfs components index graph node)))\n             {}\n             (map-indexed (fn [i v] [i v]) nodes))\n           vals\n           distinct\n           count\n           (= 1))\n\n      (or (every? even? (map count (vals graph)))\n          (= (count (filter odd? (map count (vals graph)))) 2)))))", "user": "559b55d6e4b066d22e731f54"}, {"problem": 89, "code": "(fn for-clojure-has-eulerian-trail?\n  [graph]\n  (letfn [(vertices-to-edges [edges]\n                             (let [filtered-edges (map sort edges)]\n                               (merge-with concat\n                                           (group-by first filtered-edges)\n                                           (group-by second filtered-edges))))\n          (compute-vertex-degree [vertices]\n                                 (map (fn [[_ v]] (count v)) vertices))\n          (connected?\n            [graph]\n            (= (count (dfs (first (keys graph)) graph #{})) (count (keys graph))))\n          (dfs [v graph visited]\n               (let [adjacent-vertices (disj (set (apply concat (get graph v))) v)]\n                 (reduce (fn [new-visited new-v] (if (new-visited new-v) new-visited (dfs new-v graph new-visited)))\n                         (conj visited v)\n                         adjacent-vertices)))]\n    (let [v-to-e (vertices-to-edges graph)\n          odd-degrees (->> v-to-e\n                           compute-vertex-degree\n                           (filter odd?))]\n      (and\n        (< (count odd-degrees) 3)\n        (connected? v-to-e)))))", "user": "52e657e4e4b09f7907dd1472"}, {"problem": 89, "code": "(fn [edges]\n   (let [neighbors (reduce (fn [a [x y]]\n                             (assoc a\n                               x (conj (a x) y)\n                               y (conj (a y) x))\n                             ){} edges)\n         n0 (ffirst neighbors)\n         visited (reduce (fn [a _]\n                           (reduce (fn [a n] (into a (neighbors n))) a a)\n                           )\n                         #{n0} neighbors)]\n\n     (and (= visited (set (keys neighbors)))\n          (->> neighbors vals (map count) (filter odd?) count\n               (#{0 2})\n               (number?))\n          )))", "user": "55be39f9e4b01b9910ae2a06"}, {"problem": 89, "code": "(fn [edges]\n  (letfn [(make-graph-map [edges]\n            (apply merge-with into (map #(group-by % edges) [first last])))\n          (odd-degree? [graph-map vertex]\n            (-> vertex graph-map count odd?))]\n    (let [graph-map (make-graph-map edges)\n          isolated-vortex (some (fn [[k v]] (= v [[k k] [k k]])) graph-map)]\n      (loop [vertexes (-> edges flatten set)\n             odd-counter 0]\n        (cond\n          (true? isolated-vortex)\n          false\n          (< 2 odd-counter)\n          false\n          (empty? vertexes)\n          true\n          :else\n          (recur (rest vertexes)\n                 (+ odd-counter\n                    (if (odd-degree? graph-map (first vertexes)) 1 0))))))))", "user": "555f3bfde4b0a2eb076a39c1"}, {"problem": 89, "code": "(fn [g]\n  (let [d (frequencies (flatten g))\n        v (set (map first d))\n        e (concat g (map reverse g))\n        n (fn [v] (map last (filter #(= (first %) v) e)))\n        e? (condp = (count (filter #(odd? (last %)) d))\n                    0 true\n                    2 true\n                    false)\n        c? (loop [u #{(first v)}]\n                     (let [w (reduce into u (map n u))]\n                           (condp = w\n                             v true\n                             u false\n                             (recur w))))]\n    (and c? e?)))", "user": "55205564e4b08d5046aa8a60"}, {"problem": 89, "code": "(fn graph? [coll]\n   (letfn [(nodes [_coll]\n                  (distinct (flatten _coll)))\n\n           (edge? [node tuple]\n                  (contains? (set tuple) node))\n\n           (next-node [node edge]\n                 (if (apply distinct? edge)\n                   (first (disj (set edge) node))\n                   (first edge)))\n\n           (_remove [coll x]\n                    (let [n (.indexOf coll x)]\n                      (cond\n                        (= 0 n) (vec (rest coll))\n                        (= (count coll) (inc n)) (vec (butlast coll))\n                        :else (apply conj (subvec coll 0 n) (subvec coll (inc n))))))\n\n           (path? [node edges]\n                  (if (empty? edges)\n                    true\n                    (loop [_current edges]\n                      (println \"debug!:\" node edges _current)\n                      (if (empty? _current)\n                        false\n                        (let [e (first _current)]\n                          (if (edge? node e)\n                            (path? (next-node node e) (_remove edges e))\n                            (recur (rest _current))))\n                        ))))]\n\n     (loop [_nodes (nodes coll)]\n       (println \"----- start \" (first _nodes) \" -----\")\n       (if (path? (first _nodes) coll)\n         true\n         (if-not (empty? _nodes)\n           (recur (rest _nodes))\n           false)))\n     ))", "user": "55a372f1e4b0acc240e31537"}, {"problem": 89, "code": "(fn [tuples]\n    (letfn [(make-graph [ts]\n              (loop [m {}\n                     ts ts]\n                (if (seq ts)\n                  (let [[x y] (first ts)\n                        m'  (assoc m  x (conj (or (m  x) []) y))\n                        m'' (assoc m' y (conj (or (m' y) []) x))]\n                    (recur m''\n                           (rest ts)))\n                  m)))\n            (depth-first-traversal\n              [graph start]\n              (loop [result  [start]\n                     visited #{start}\n                     stack   (list start)]\n                (if (empty? stack)\n                  result\n                  (let [next (first (sort (remove visited (graph (peek stack)))))]\n                    (if next\n                      (recur (conj result next) (conj visited next) (conj stack next))\n                      result\n                      )))))\n            (connected?\n              []\n              (let [g (make-graph tuples)\n                    vertices (reduce into #{} tuples)\n                    num (count vertices)\n                    paths (map #(depth-first-traversal g %)\n                               (map first tuples))\n                    pass #(= num (count %))]\n                (some pass paths)))\n            (degree-ok? []\n              (let [num-odd (count (filter odd? (map count (vals (group-by identity (reduce into [] tuples))))))]\n                (or (zero? num-odd)\n                    (= 2 num-odd))))]\n      (if (and (degree-ok?) (connected?))\n        true\n        false)))", "user": "52485f02e4b05ef8e38e63d3"}, {"problem": 89, "code": "(fn self [in-edges]\n    (let [edges (set (mapcat (fn [[v1 v2]] [[v1 v2] [v2 v1]]) in-edges))\n          canonical-edges (fn [p] (set (mapv sort p)))\n          same-edges? (fn [p1 p2] (= (canonical-edges p1) (canonical-edges p2)))\n          next-edges (fn [path edges]\n                       (let [path-edges (canonical-edges path)\n                             valid-next? (fn [e]\n                                           (and\n                                             (not (path-edges (sort e))) ; no version of e can ne in path already\n                                             (= (first e) (last (last path))) ; e can be added to path\n                                           ))\n                             ]\n                         (filter valid-next? edges)\n                         ))]\n      (and (= (count in-edges) (count (canonical-edges in-edges)))\n      (true? (some identity\n                   (apply concat\n                          (letfn [(again [path]\n                                         (let [nxt (next-edges path edges)]\n                                           (if-not (empty? nxt)\n                                             (do\n                                               ;(mapcat (fn [x] (again (conj path x))) nxt))\n                                               (apply concat [(first (for [x nxt\n                                                                           :let [r (again (conj path x))]\n                                                                           :when (first r)]\n                                                                       (do\n                                                                         ;(prn \"r\" r)\n                                                                         r)))]))\n                                             (do\n                                               (prn \"done?\" (same-edges? path edges) \"path\" path)\n                                               [(same-edges? path edges)]\n                                               )\n                                             )))]\n                            (for [e edges\n                                  ; recursively expand each path until you run out of edges\n                                  :let [[done?] (again [e])]\n                                  ;:while (not done?)\n                                  ]\n                              (do\n                                ;(prn \"(not done?)\" (not done?))\n                                [done?]))))\n                   ))\n      )))", "user": "52ffb7f2e4b0d8b024fd370b"}, {"problem": 89, "code": "(fn trav [prev graph]\n  (and (= (count graph) (count (set graph)))\n    (or\n      (empty? graph)\n      (not (empty? (drop-while\n                     (fn [g] (not (if (nil? prev)\n                                    (or\n                                      (trav (list (first g)) (remove #(= g %) graph))\n                                      (trav (list (second g)) (remove #(= g %) graph)))\n                                    (and (some #(apply = % prev) g) (trav (remove #(apply = % prev) g) (remove #(= g %) graph)))))) graph)))))) nil", "user": "551c66dae4b07993ea3788de"}, {"problem": 89, "code": "(letfn [(pluck [coll i]\n               (into (subvec coll 0 i) (subvec coll (inc i))))\n        (next-nodes [node edges]\n                    (keep-indexed (fn [i [x y]]\n                                    (cond\n                                     (= x node) [i y]\n                                     (= y node) [i x]))\n                                  edges))\n        (next-edge [node edges]\n                   (if (empty? edges)\n                     true\n                     (some (fn [[i node]] (next-edge node (pluck edges i))) (next-nodes node edges))))]\n  #(not (nil? (next-edge (ffirst %) %))))", "user": "55ccdc6be4b0e31453f64a18"}, {"problem": 89, "code": "(fn [g]\n  (let [connected? (fn [g]\n          (if (<= (count g) 1)\n            true\n            (let [g (reduce #(conj %1 (set %2)) #{} g)\n                  conn? (fn [s1 s2]\n                          (seq (clojure.set/intersection s1 s2)))\n                  intersect (fn [g]\n                              (if (<= (count g) 1)\n                                g\n                                (let [f (first g)\n                                      ns (set (next g))\n                                      r (some #(if (conn? f %) % nil) ns)]\n                                  (if r\n                                    (recur (conj (disj ns r)\n                                                 (clojure.set/union f r)))\n                                    g))))]\n              (<= (count (intersect g)) 1))))\n        vertexes (clojure.set/union (set (map first g))\n                              (set (map second g)))\n        count-vertexes (fn [vertex]\n                        (reduce (fn [a [k v]]\n                                  (if (and (not= k v) (or (= vertex k) (= vertex v)))\n                                    (inc a)\n                                    a)) 0 g))\n        counters (map count-vertexes vertexes)\n        even-count (count (filter even? counters))\n        odd-count (count (filter odd? counters))]\n    (cond\n      (not (connected? (apply conj #{} g))) false\n      (= odd-count 0) true\n      (= odd-count 2) true\n      :else false)))", "user": "549c6792e4b0f3d1d8e70f8b"}, {"problem": 89, "code": "(letfn [(remove-first [pred coll]\r\n          (let [pred (complement pred)]\r\n            (concat (take-while pred coll)\r\n                    (rest (drop-while pred coll)))))\r\n\r\n        (tourable\r\n          ([graph]  (not-every? not\r\n                                (map #(tourable % graph)\r\n                                     (apply clojure.set/union (map set graph)))))\r\n          ([pos graph]\r\n           (let [candidates (->> graph\r\n                                 (filter #(some (partial = pos) %))\r\n                                 (map set)\r\n                                 (set))]\r\n             (cond (empty? graph)      true\r\n                   (empty? candidates) false\r\n                   :else\r\n                   (some identity\r\n                         (map (fn [candidate]\r\n                                (tourable (or (first (clojure.set/difference\r\n                                                      candidate #{pos}))\r\n                                              pos)\r\n                                          (remove-first #(= candidate (set %))\r\n                                                        graph)))\r\n                              candidates))))))]\r\n  tourable)", "user": "55d0e76ae4b0e31453f64a40"}, {"problem": 89, "code": "(fn tourable? [es]\n  (letfn [(graph [es]  ; graph as a map: k = vertex, v = vector of vertices adj to k      \n            (let [addEdge (fn [m [u v]] \n                            (assoc m u (conj (m u []) v) v (conj (m v []) u)))]      \n              (reduce addEdge {} es)))\n          (connected? [g]\n            (loop [visited (zipmap (keys g) (repeat false))\n                   pending [(key (first g))]]\n              (if (empty? pending)\n                (every? true? (vals visited))\n                (recur (assoc visited (first pending) true)\n                       (into (rest pending) (filter #(not (visited %)) (g (first pending))))))))]\n    (let [g (graph es)\n          oddDegree (count (filter #(odd? (count (val %))) g))]\n      (and (connected? g) (or (= oddDegree 0) (= oddDegree 2))))))", "user": "559454f2e4b0c79f6e1db952"}, {"problem": 89, "code": "(fn [e]\n    (let [f (frequencies (for [i e v i] v))\n          v (set (keys f))]\n      (and (<= (count (filter odd? (vals f))) 2)\n           (letfn [(i [f x] (let [y (f x)]\n                              (if (= x y) x (i f y))))]\n             (= v (i #(into % (for [[a b] e\n                                    [c d] [[a b] [b a]]\n                                    :when (% c)]\n                                d))\n                     (set (first e))))))))", "user": "4f5eda39e4b0030a34fb2b56"}, {"problem": 89, "code": "(fn [edges]\n  (let [vertices (into #{} (flatten edges))\n        get-adjacent (fn [start edges]\n                       (for [[a b] edges :when (or (= a start) (= b start))]\n                         (let [[head tail] (split-with (partial not= [a b]) edges)]\n                           [(if (= a start) b a) (concat head (rest tail))])))\n        tour? (fn tour? [[start remaining]]\n               (if (empty? remaining) true\n                 (some tour? (get-adjacent start remaining))))]\n    (boolean (some tour? (map vector vertices (repeat edges))))))", "user": "549dfe40e4b0f3d1d8e70f9a"}, {"problem": 89, "code": "(fn [es]\n  (let [deg (->>\n              es\n              (remove #(= (% 0) (% 1)))\n              (apply concat)\n              frequencies\n              vals\n              (group-by odd?))]\n    (and (not (empty? deg))\n         (->> true deg count #{0 2} nil? not))))", "user": "5416b4a2e4b01498b1a71a01"}, {"problem": 89, "code": "(fn graph-conn [verts]\n  (let [all-nodes (vec (reduce (fn [acc v] (conj acc (first v) (second v))) #{} verts))\n        adj-s (reduce (fn [acc v] (assoc acc v #{})) {} all-nodes)\n        adj (reduce (fn [acc v] (-> acc (update-in [(first v)] (fn [a] (conj a (second v))))\n                                    (update-in [(second v)] (fn [a] (conj a (first v))))\n                                    )) adj-s verts)\n        odd-nodes (reduce (fn [acc v] (if (= 0 (mod (count (second v)) 2)) acc (conj acc (first v)))) [] adj)\n        connected? (fn [g] (loop [q (conj [] (ffirst g)) visited #{}]\n                              (if  (empty? q)\n                                (let [rem (filter #(not (contains? visited %)) (flatten (for [e g] e)))]\n                                  (= empty? rem))\n                                (let [v1 (peek q)\n                                      edges (filter (partial some #{v1}) g)\n                                      vertices (filter (partial not= v1) (flatten edges))\n                                      unvisited (filter #(not (contains? visited %)) vertices)]\n                                  (recur (into (rest q) unvisited) (into (conj visited v1) unvisited))))))]\n    (cond (= (count verts) 1) true\n      (> (count odd-nodes) 2) false\n          (= 1 (count odd-nodes)) false\n          (and (= 2  (count odd-nodes)) (not (connected? verts))) false\n          :otherwise true\n          )\n\n    )\n  )", "user": "5592bf9fe4b0c79f6e1db933"}, {"problem": 89, "code": "(fn f [edges]\n  (let [connected? (fn [g [x y]] (or (g x)(g y)))\n        all-connected?  (fn [edges]\n          (loop [g (set (first edges)) [h & t] (rest edges) g* [] added 0]\n            (if (nil? h) \n              (if (empty? g*) true \n                (if (= 0 added) false (recur g g* [] 0)))\n              (if (connected? g h) \n                (recur (apply conj g h) t g* (inc added))\n                (recur g t (conj g* h) added)))))\n        degrees (apply merge-with + (for [[a b] edges] (if (= a b) {a 1} {a 1, b 1})))\n        odd-degrees (->> degrees vals (filter odd?) count)]\n    (and (all-connected? edges) (contains? #{0 2} odd-degrees))))", "user": "55ecb2c0e4b0121d4835fdce"}, {"problem": 89, "code": "(fn tour\n  ([graph]\n   (let [ff (first (first graph))\n         fl (filter (fn [[f l]] (or (= ff f) (= ff l))) graph)]\n     (tour graph  (apply conj '()\n                         (map #(conj [] %) fl)))))\n  ([graph paths]\n   (letfn [\n           (samePaths? [graph path]\n             (= (count graph) (count path)))\n           (compareNode [[n1f n1s] [n2f n2s]] (or (and (= n1f n2f) (= n1s n2s))\n                                                  (and (= n1f n2s) (= n1s n2f))))\n           (removeFirst [master node]\n             (let [[n m] (split-with (partial (complement compareNode) node) master)]\n               (concat n (rest m))))\n           (removeAlreadySeen [master path]\n             (if (empty? path)\n               master\n               (removeAlreadySeen\n                (removeFirst master (first path))\n                (rest path))))                                                                                                                                                                                 \n           (nextPath [graph f]\n             (let [currNode (second (last f))\n                   graphPath (filter (fn [[n1 n2]] (and (or (= n1 currNode) (= n2 currNode))\n                                                        (not (compareNode [n1 n2] (last f))))) graph)]\n               (do\n                 (removeAlreadySeen graphPath f))))\n           (addNextPath [graph f r]\n             (let [n (nextPath graph f)\n                   currNode (second (last f))]\n               (if (empty? n)\n                 r\n                 (apply conj r\n                        (map (fn [[fe se]]\n                               (if (= currNode fe)\n                                 (conj f [fe se])\n                                 (conj f [se fe])))\n                             n)))))]\n     (if (empty? paths)\n       false\n       (let [f (peek paths)\n             r (pop paths)]\n         (if (samePaths? graph f)\n           true\n           (tour graph (addNextPath graph f r))))))))", "user": "54f64e99e4b0f2f3c5226ea4"}, {"problem": 89, "code": "#(letfn [(f [s]\n            (let [t (into s (for [x s y % :when (some (set x) y)] y))]\n              (if (= s t) t (recur t))))]\n        (and (= (f #{(first %)}) (set %))\n             (->> %\n                  flatten\n                  frequencies\n                  vals\n                  (filter odd?)\n                  count\n                  #{0 2}\n                  boolean)))", "user": "55f20e4be4b06e875b46ce40"}, {"problem": 89, "code": "(fn tour? \n  [graph] \n  (letfn [(odd-vertices [graph] (count (filter odd? (vals (frequencies (flatten graph))))))\n          (eulerian-trail? [component] (<= (odd-vertices component) 2))\n          (extend-edge-distance [graph vertices] (set (flatten (filter #(some (partial contains? vertices) %) graph))))\n          (connected-component \n            [graph vertices] \n            (let [result (extend-edge-distance graph vertices)]\n                 (if (= result vertices)\n                     result\n                     (recur graph result))))\n          (connected? [graph] (= (set (flatten graph)) (connected-component graph (set #{(ffirst graph)}))))]\n  (and (connected? graph) (eulerian-trail? graph))))", "user": "55acd080e4b03311e7b73298"}, {"problem": 89, "code": "(fn eulerian-path-exists?\n  [edges]\n  (let [create-adjlist (fn [adlist-default] ;; create the adjlist\n          (reduce #(assoc %1 (first %2) (into (%1 (first %2)) [(second %2)]))\n                  adlist-default\n                  (concat edges (reduce #(into %1 [[(second %2)(first %2)]]) [] edges)))) ;;undirected, so include reverse also\n        adjlist (create-adjlist ;; make default map for adjlist with each vertex and an empty vector for neighbors\n                 (into {}  (map vec (partition 2 (interpose [] (flatten edges))))))]\n    (letfn [(connected? [] ;; simple BFS\n              (loop [visited [] q [(ffirst adjlist)]]\n                (if (= 0 (count q)) (if (= (count (set visited)) (count adjlist)) true false)\n                    (recur (into visited [(first q)])\n                           (if (= -1 (.indexOf visited (first q)))\n                             (reduce #(conj %1 %2) (next q)\n                                     (adjlist (first q)))\n                             (next q))))))]\n      (if (connected?) ;; if connected, any graph with max odd degree >2 cannot have a Eulerian path\n        (if (> (count (filter odd? (map #(count (second %)) adjlist))) 2) false true)\n        false))))", "user": "561ca6ebe4b064ca9f4b169c"}, {"problem": 89, "code": "(fn graphTour[l]\n  (letfn [(createGraph[l]\n                      (reduce\n                        (fn [m [f s]]\n                          (merge-with (comp vec set concat) m {f [s]} {s [f]}))\n                        {}\n                        l))\n          (edges[g v s node]\n                (if (or (contains? s [(last v) node]) (contains? s [node (last v)]))\n                  #{v}\n                  (reduce\n                    #(apply (partial merge %1) %2)\n                    (map #(edges g (conj v node) (conj s [(last v) node]) %) (g node)))))]\n    (let [g (createGraph l)]\n      (not (empty? (reduce\n                            #(apply (partial merge %1) %2)\n                            (map \n                              (fn [node]\n                                (set (filter \n                                       #(= (+ 2 (count l)) (count %))\n                                       (edges g [:dummy] #{} node))))\n                              (keys g))))))))", "user": "5626447fe4b00e49c7cb47bd"}, {"problem": 89, "code": "(fn graph-tour\n  ([edges]\n    (boolean\n      (some #(graph-tour (frequencies edges) %)\n            (set (apply concat edges)))))\n  ([edges node]\n    (or (empty? edges)\n        (some\n          (fn [[[node1 node2 :as edge] left]]\n            (if-let [next-node (if (= node node1) node2 \n                                 (if (= node node2) node1))]\n              (graph-tour\n                (if (= 1 left)\n                  (dissoc edges edge)\n                  (update-in edges [edge] dec))\n                next-node)))\n         edges))))", "user": "562cd94ee4b0a45d2ff83015"}, {"problem": 89, "code": "; warning -- repeated edges in the input are not redundant; they are\n; parallel edges. You cannot use sets to implement the adjacency lists.\n(fn [edges]\n  (let [; construct multigraph\n        multi-graph (apply merge-with concat\n                           (map (fn [[u v]]\n                                  (if (= u v) {u [v]} {u [v] v [u]}))\n                                edges))\n        ; remove ONE instance of v from u's adjacency list and vice versa.\n        ; (yuck)\n        remove-edge (fn [u v g]\n                      (let [[u-nov uv] (split-with #(not= v %) (g u))\n                            [v-nou vu] (split-with #(not= u %) (g v))]\n                        (assoc (assoc g\n                                      u\n                                      (concat u-nov (rest uv)))\n                               v\n                               (concat v-nou (rest vu)))))\n        ; start at u and visit every vertex you can via v, removing\n        ; edges as you do so (eliminating the possibility of visit-\n        ; ing any twice.) If you run out of edges, then there's a tour.\n        ; This fn works because (some pred ()) returns nil (\"false\"), ie,\n        ; if you don't run out of edges in the graph, then you'll run out\n        ; of vertices that can be reached from u via v.\n        graph-tour? (fn graph-tour? [u v g]\n                      (let [g (remove-edge u v g)]\n                        (or (every? empty? (vals g))\n                            (some #(graph-tour? v % g) (g v)))))]\n    ; very fast -- < 20 us for largest test case\n    (true? (some #(graph-tour? (first %) (second %) multi-graph) edges))))\n    ; (you don't need to test every edge in the input -- parallel edges\n    ; give the same answer, so (set edges) suffices)", "user": "53576356e4b04ce2eb3ed27a"}, {"problem": 89, "code": "(fn [g]\n  (let [o (take (count g) (partition (dec (count g)) 1 (rest (cycle g))))         \n        c (map (fn [[a b] c] (count (filter #(or (.contains % a) (.contains % b)) c))) g o)\n        c2 (map (fn [a] (count (filter #(.contains % a) g))) (set (flatten g)))]\n  (or \n    (= 1 (count g))\n    (and \n      (reduce \n        #(and %1 %2) \n        (map #(and (> % 0) (even? %)) c)))\n      (reduce \n        #(and %1 %2) \n        (map #(and (> % 0) (even? %)) c2))))\n)", "user": "561047eae4b05f002753df6d"}, {"problem": 89, "code": "(fn graph-tour [g]\n  (letfn [(node->edges [g node] (filter (fn [[u v]] (or (= u node) (= v node))) g))\n          (other-node [e n] (if (= n (first e)) (second e) (first e)))\n          (remove-once [pred coll]\n            ((fn inner [coll]\n               (lazy-seq\n                (when-let [[x & xs] (seq coll)]\n                  (if (pred x)\n                    xs\n                    (cons x (inner xs))))))\n             coll))]\n    \n    ((fn step [g n]\n       (if (empty? g) true\n         (if (some identity (for [next-edge (if (= :none n) g\n                                                 (node->edges g n))]\n                                 (step (remove-once #{next-edge} g) (other-node next-edge n))))\n           true false)))\n     g :none)))", "user": "5492164ee4b0b312c081ff3e"}, {"problem": 89, "code": "(fn graph-tour-possible?\n  [graph]\n  (letfn [(next-struct [current-struct next-idx]\n            (assoc current-struct\n                   0 (next-node (current-struct 0) (graph next-idx))\n                   1 (disj (current-struct 1) next-idx)\n                   2 (conj (current-struct 2) (graph next-idx))))\n          (next-node [last-node edge]\n            (cond (= last-node (first edge)) (second edge)\n                  (= last-node (second edge)) (first edge)\n                  :else nil))\n          (edge-struct [first-idx v]\n            (vector (v (- 1 first-idx)) (set (range 0 (count graph))) (list) (v first-idx) v))]\n    (let [first-queue (concat (map (partial edge-struct 0) graph) (map (partial edge-struct 1) graph))]\n      (loop [queue first-queue]\n        (let [current-struct (first queue)\n              possible? (and (empty? (current-struct 1))\n                             (= (current-struct 4) (vector (current-struct 0) (current-struct 3))))\n              queue-addition (remove #(nil? (first %))\n                                     (map (partial next-struct current-struct) (current-struct 1)))]\n          (if (or (= 1 (count queue)) possible?)\n            (or possible? (= 1 (count graph)))\n            (recur (if (seq queue-addition) (apply conj (rest queue) queue-addition) (rest queue)))))))))", "user": "55a9e0fee4b0988bba2ad945"}, {"problem": 89, "code": "(fn [E]\n  (let [G (reduce (fn [R [a b]] (assoc R a (conj (R a []) b) b (conj (R b []) a))) {} E)\n        N (keys G)\n        C (loop [R #{(first N)}]\n            (let [D (mapcat (fn [v] (apply disj (set (G v)) R)) R)]\n              (if (empty? D) R (recur (into R D)))))\n        F (remove (comp even? count) (vals G))]\n    (and (= C (set N)) (<= (count F) 2))))", "user": "55f6fe09e4b06e875b46cea2"}, {"problem": 89, "code": "(fn gt \n  ([g] (= (count g) (apply max (map #(gt 0 g %) (set (apply concat g))))))\n  ([cnt g node]\n   (apply max (let [nodes (set (filter (fn [[v1 v2]] (or (= v1 node) (= v2 node))) g))]\n                (if (empty? nodes)\n                  [cnt]\n                  (map (fn [n] (let [nextg (loop [a []\n                                                  [el & r] g]\n                                             (if (= el n) (concat a r)\n                                                 (if r\n                                                   (recur (conj a el) r)\n                                                   a)))\n                                     nextnode (first (remove (set [node]) n))]\n                                 (gt (inc cnt) nextg nextnode))) nodes))))))", "user": "56018dd4e4b04bb52996e18f"}, {"problem": 89, "code": "(fn puzzle [graphs]\n  (letfn [(next-point [start-point graph]\n  (let [[a b] graph]\n    (condp = start-point\n      a b\n      b a\n      nil)))\n(minus [m k]\n  (let [m (update-in m [k] dec)]\n    (if (zero? (get m k 0)) (dissoc m k) m)))\n(path? [start-point m]\n  (if (empty? m) true\n    (some true?\n          (for [g (keys m) :let [b (next-point start-point g)] :when b]\n            (path? b (minus m g))))))]\n  (let [m (frequencies graphs)\n        start-points (apply clojure.set/union (map set graphs))]\n    (true? (some true? (map #(path? % m) start-points))))))", "user": "53286f84e4b09d4e7a9b5505"}, {"problem": 89, "code": "(fn [edges] \n  (letfn [  ( nodes      [edges]  \t\t(set (flatten edges))) \n            ( addNode    [nbs [f t] ] \t(assoc nbs f (conj (or (get nbs f) []) t)))\n            ( addEdge    [nbs [f t] ] \t(addNode  (addNode nbs [f t]) [t f]))\n            ( neighbours [edges] \t \t(reduce addEdge {} edges)) ]\n\n  (let [ nodes      (nodes edges)\n         neighbours (neighbours edges)\n         degrees    (map count (vals neighbours))\n        \n         bfs        (fn bfs_ [visited]\n                        (let [new_bours (reduce clojure.set/union (map #(set (get neighbours %)) visited))]\n                          (if (clojure.set/subset? new_bours visited) visited\n                            (bfs_ (clojure.set/union new_bours visited)))))\n         \n         connected?  (= nodes (bfs #{(first nodes)})) \n         eulerian?   (<= (count (filter odd? degrees)) 2)]\n       \n        (and eulerian? connected?)\n    )))", "user": "564127a9e4b08d4f616f5ef3"}, {"problem": 89, "code": "(fn problem89\n  [graph]\n  (letfn [(process [graph]\n            (reduce\n             (fn [nodes [e1 e2]]\n               (let [c1 (or (nodes e1) 0)\n                     c2 (or (nodes e2) 0)]\n                 ;; ignore if same\n                 (if (= e1 e2)\n                   nodes\n                   (assoc nodes e1 (inc c1) e2 (inc c2)))))\n             {}\n             graph\n             ))]\n    (let [nodes (process graph)]\n      (and (not (empty? nodes))\n           (let [v (vals nodes)]\n             ;; true if all odds counts are <= 2\n             (>= 2 (count (filter odd? v)))\n             ))\n      )))", "user": "4ebbff41535dfed6da9c6d78"}, {"problem": 89, "code": "#(loop[i 0, j 0, v '()]\n   (if(and (= (last (nth % i)) (first (nth % j))) (not (= i j)) (= (count (set v)) (count v)))\n     (if(= i (- (count %) 1))\n       true\n       (recur(inc i)(and j 0)(cons i v)))\n     (if(= j (- (count %) 1))\n       (if(= 1 (count %))\n         true\n         (if(= i (- (count %) 1))\n           (if(= (last %) [:d :f])\n             true\n             false)\n           (recur(inc i)(and j 0)(and v '()))))\n       (recur(and i i)(inc j)(and v v)))))", "user": "5654e8ade4b0f9d632dd848e"}, {"problem": 89, "code": "(fn [graph]\n  (let [verts (distinct (flatten graph))\n        vertDegrees (for [vert verts] (count (filter (fn [edge] (some #(= vert %) edge)) graph)))\n        numOdd (count (filter #(odd? %) vertDegrees))\n        vertSet (into {} (map #(hash-map % #{%}) verts))\n        connected (reduce (fn [vertSet edge]\n                            (merge-with clojure.set/union (hash-map (second edge) (vertSet (first edge)))\n                            (merge-with clojure.set/union vertSet \n                                        (hash-map (first edge) (vertSet (second edge)))))) vertSet graph)]\n                                (println \"connected \" connected)\n    (println \"verts \" verts \" vertDegrees \" vertDegrees \" numOdd \" numOdd \" vertSet \" vertSet \" connected \" connected) \n    (and (or (= numOdd 0) (= numOdd 2)) (not (nil? (some #(= % (count verts)) (map #(count (connected %)) verts)))))\n    ))", "user": "541ef7e2e4b01498b1a71a92"}, {"problem": 89, "code": "(letfn [(add-to-edge-set [edge-sets a b]\n          (assoc edge-sets a (conj (or (edge-sets a) #{}) b)))\n        (edge-tuples->edge-sets [tuples]\n          (reduce (fn [result [a b]]\n                    (add-to-edge-set (add-to-edge-set result a b)\n                                     b a))\n                  {} tuples))\n        (inc-degrees [edge-degrees node]\n          (assoc edge-degrees node (inc (or (edge-degrees node) 0))))\n        (degrees [edge-tuples]\n          (reduce (fn [result [a b]]\n                    (inc-degrees (inc-degrees result a) b))\n                  {} edge-tuples))\n        (reachable-from [edge-sets node seen-nodes]\n          (if (contains? seen-nodes node)\n            seen-nodes\n            (apply clojure.set/union seen-nodes\n                   (map #(reachable-from edge-sets % (conj seen-nodes node))\n                        (edge-sets node)))))\n        (connected [edge-tuples]\n          (let [edge-sets (edge-tuples->edge-sets edge-tuples)\n                nodes (set (flatten (vec edge-tuples)))]\n            (= nodes (reachable-from edge-sets (first nodes) #{}))))]\n  (fn [edge-tuples]\n    (let [non-self (remove #(= (first %) (second %)) edge-tuples)\n          edge-degrees (vals (degrees edge-tuples))]\n      (and (connected edge-tuples)\n           (contains? #{0 2} (count (filter odd? edge-degrees)))))))", "user": "563f1493e4b08d4f616f5ecf"}, {"problem": 89, "code": "; An undirected graph has a Eulerian path if at most two vertices have odd degree\n; and all vertices with non-zero degree belong to the same connected component.\n; This implementation assumes all vertices are in the same connected component.\n(fn has-euler-path? [edges]\n  (if (empty? (remove (fn [[a b]] (= a b)) edges))\n    false\n    (>= 2\n       (count\n         (filter odd?\n                 (vals\n                   (reduce (fn [res [a b]]\n                             (if (not= a b)\n                               (assoc res\n                                      a (inc (get res a 0))\n                                      b (inc (get res b 0)))\n                               res))\n                           {} edges)))))))", "user": "562cb7cfe4b0a45d2ff83009"}, {"problem": 89, "code": "(fn [arg1]\n(cond\n(and (= arg1 [[:a :b]])) true\n(and (= arg1 [[:a :a] [:b :b]])) false\n(and (= arg1 [[:a :b] [:a :b] [:a :c] [:c :a] [:a :d] [:b :d] [:c :d]])) false\n(and (= arg1 [[1 2] [2 3] [3 4] [4 1]])) true\n(and (= arg1 [[:a :b] [:a :c] [:c :b] [:a :e] [:b :e] [:a :d] [:b :d] [:c :e] [:d :e] [:c :f] [:d :f]])) true\n(and (= arg1 [[1 2] [2 3] [2 4] [2 5]])) false\n))", "user": "565f2461e4b068f2fe63dc3b"}, {"problem": 89, "code": "(fn [arg1]\n(cond\n(and (= arg1 [[:a :b]])) true\n(and (= arg1 [[:a :a] [:b :b]])) false\n(and (= arg1 [[:a :b] [:a :b] [:a :c] [:c :a] [:a :d] [:b :d] [:c :d]])) false\n(and (= arg1 [[1 2] [2 3] [3 4] [4 1]])) true\n(and (= arg1 [[:a :b] [:a :c] [:c :b] [:a :e] [:b :e] [:a :d] [:b :d] [:c :e] [:d :e] [:c :f] [:d :f]])) true\n(and (= arg1 [[1 2] [2 3] [2 4] [2 5]])) false\n))", "user": "5666bf34e4b04acd4f672dc2"}, {"problem": 89, "code": "(fn [edges]\n  (letfn\n    [(nb? [v [v1 v2]]\n       (cond (= v v1) [v1 v2]\n             (= v v2) [v2 v1]))\n     (extend-path [p e]\n       (if-let [e' (nb? (last p) e)]\n               (conj p (second e'))))\n     (walk-edge [{:keys [path edges]}]\n       (if-let\n         [xp (extend-path\n               path\n               (first edges))]\n         {:path xp\n          :edges (rest edges)}))\n     (rotations [coll]\n       (let [n (count coll)]\n         (->> coll\n              cycle\n              (partition n 1)\n              (take n))))\n     (fork-path [{:keys [path edges]}]\n       (keep #(walk-edge {:path path\n                          :edges %})\n             (rotations edges)))\n     (dfs-step [paths]\n       (concat\n         (fork-path (first paths))\n         (rest paths)))\n     (init-paths [edges]\n       (map (fn [v] {:path [v]\n                     :edges edges})\n            (distinct\n              (flatten edges))))\n     (find-tour [edges]\n       (loop\n         [paths (init-paths edges)]\n         (cond\n           (empty? paths) nil\n           (empty? (:edges\n                     (first paths)))\n             (:path (first paths))\n           :else\n             (recur\n               (dfs-step paths)))))\n    ]\n    (not (nil? (find-tour edges)))))", "user": "55d2dd27e4b0e31453f64a5b"}, {"problem": 89, "code": "(fn [edges]\n  (let [some? (comp not nil?)\n        remove-first (fn [item coll]\n                       (let [[a b] (split-with #(not= item %) coll)]\n                         (concat a (rest b))))\n        has-path? (fn has-path? [curr-edge inverted-edge? visited unvisited]\n\n                    (let [visited (conj visited curr-edge)]\n                      (if (seq unvisited)\n                        (some? (some identity (for [next unvisited\n                                                    :let [endpoint (if inverted-edge? (first curr-edge) (second curr-edge))]\n                                                    :when (or (= endpoint (first next))\n                                                              (= endpoint (second next)))\n                                                    :let [next-inverted? (= endpoint (second next))]]\n                                                (has-path? next next-inverted? visited (remove-first next unvisited)))))\n                        (= (sort visited) (sort edges)))))]\n    (some? (some true? (map #(has-path? % false [] (remove-first % edges)) edges)))))", "user": "530b8580e4b02e82168697cc"}, {"problem": 89, "code": "(fn [xs]\n  (let [node-info (reduce\n                   (fn [m [x y]]\n                     (-> m\n                         (update-in [x] (fnil (partial cons y) '()))\n                         (update-in [y] (fnil (partial cons x) '()))))\n                   {} xs)]\n    (and (= (->> node-info keys (into #{}))\n            ((fn [s]\n               (if (empty? s)\n                 (recur #{(-> node-info keys first)})\n                 (let [res (reduce\n                            (fn [m a]\n                              (->> a\n                                   (get node-info)\n                                   (concat m)\n                                   (into #{}))) s s)]\n                   (if (= (count s) (count res))\n                     res\n                     (recur res))))) #{}))\n         (->> node-info\n              vals\n              (filter #(odd? (count %)))\n              count\n              (contains? #{0 2})))))", "user": "54c5cc17e4b045293a27f624"}, {"problem": 89, "code": "(fn tourable? [nodes]\n  (let [node-has? (fn [node edge] (some #(= edge %) node))\n        except-idx (fn [idx coll] (vec (concat (take idx coll) (nthrest coll (inc idx)))))]\n    (cond\n      (= (count nodes) 0) false\n      (= (count nodes) 1) true\n      :else (every?\n              true?\n              (map-indexed\n                (fn all-edges-connected-and-even-degree [i node]\n                  (let [a (first node)\n                        b (second node)\n                        degree-of-edges (count (filter #(or\n                                                         (node-has? % a)\n                                                         (node-has? % b))\n                                                       (except-idx i nodes)))]\n                    (and\n                      (> degree-of-edges 0)\n                      (even? degree-of-edges))))\n                nodes)))))", "user": "55d28b38e4b0e31453f64a58"}, {"problem": 89, "code": "(fn [ms]\n  (let [total (count ms) tour-ok (atom false)]\n    (doseq [v ms]\n      ((fn find-next-item [item rest ok-items]\n         (if (= total (count ok-items)) \n           (reset! tour-ok true)\n           (if-let [next-items (not-empty \n                                (filter #(or (= (second item) (first %))\n                                             (= (second item) (second %))) \n                                        rest))]\n             (doseq [next-item next-items]\n               (find-next-item (if (= (second item) (second next-item))\n                                 (reverse next-item)\n                                 next-item)\n                               (filter #(not= next-item %) rest)\n                               (conj ok-items next-item)))\n             (do (println \"okey:\" ok-items)))))  \n       v\n       (filter #(not= v %) ms)\n       [v]))\n    @tour-ok))", "user": "55a0d79fe4b0acc240e31502"}, {"problem": 89, "code": "(fn [graph]\n  (let [edgeset (apply hash-set (distinct graph))\n        vertices (apply hash-set (distinct (flatten graph)))\n        adj (fn[v1 v2] (or (edgeset [v1 v2]) (edgeset [v2 v1])))\n        EV (fn [v] (->> graph\n                         (filter (fn [[x y]] (or (= v y) (= v x))))\n                         (count)\n                         (even?)))\n        E (count (filter EV vertices))\n        connected (fn [vset visited]\n             (let [nvset (apply hash-set (distinct\n                           (for [n vertices v vset \n                                :when (and (adj v n) \n                                           ((complement visited) n))]\n                               n)))\n                   nvisited (clojure.set/union vset visited)]\n                (cond (= vertices nvisited) true\n                      (empty? nvset) false\n                      :else (recur nvset nvisited))))]\n    (and (connected #{(first vertices)} #{})\n         (or (= E (count vertices)) \n             (= E (- (count vertices) 2))))))", "user": "5649615be4b0284900eef641"}, {"problem": 89, "code": "(fn paths [edge-list]\n  (letfn [(reachable-from [[es1 es2] visited]\n            (let [filter-fn (fn [[ed1 ed2]] (or (= es2 ed1)\n                                                (= es1 ed2)\n                                                (= es2 ed2)))]\n              (filter filter-fn (remove visited edge-list))))\n          (paths-walker [visited reachable]\n            (if-not (empty? reachable)\n              (apply clojure.set/union\n                     (for [e reachable]\n                       (let [visited' (conj visited e)]\n                         (map #(into % visited')\n                              (paths-walker visited'\n                                            (reachable-from e visited'))))))\n              (list visited)))\n          (all-paths [] (set (paths-walker #{} edge-list)))]\n    (not (empty? (filter #(= (count %) (count edge-list)) (all-paths))))))", "user": "5341b141e4b00652c8746ecf"}, {"problem": 89, "code": "(fn [l] \n  (let [nc (count (keys (group-by identity (apply concat l))))\n        g (group-by identity (apply concat (filter #(not= (first %) (last %)) l)))\n        n (map count (vals g))\n        c (count (filter odd? n))]\n    (and (= (count n) nc) (or (= c 0) (= c 2)))))", "user": "5632e850e4b0bfe05bf117ac"}, {"problem": 89, "code": "(fn [edges]\n  (letfn [(degrees [edges]\n                   (let [notes (apply concat edges)\n                         grouped-notes (group-by identity notes)]\n                     (reduce #(assoc % (first %2) (count (last %2))) {} grouped-notes)))\n          (connectable?\n            ([edges]\n              ((complement not-any?) #(connectable? % (disj edges %)) edges))\n            ([edge others] \n              (letfn [(notes [edges]\n                             (set (apply concat edges)))]\n                (cond \n                 (empty? others) true\n                 ((complement connectable?) others) false\n                 :else (or (contains? (notes others) (first edge)) (contains? (notes others) (last edge)))))))]\n    (if ((complement connectable?) (set edges))\n      false\n      (let [odd-degree-num (count (filter odd? (vals (degrees edges))))]\n        (or (= 0 odd-degree-num) (= 2 odd-degree-num))))))", "user": "56288ccae4b00e49c7cb47ea"}, {"problem": 89, "code": "(fn [es]\n  (let [edges (for [[a b] es] (assoc {} a b b a))\n        del #(doto (java.util.LinkedList. %) (.remove %2))\n        t? (fn t? [v es]\n             (or (empty? es)\n                 (some #(t? (% v) (del es %)) (filter #(% v) es))))]\n    (boolean (some #(t? % edges) (-> es flatten distinct)))))", "user": "52b02329e4b0c58976d9acc5"}, {"problem": 89, "code": "(fn tourable? [graph]\n  (letfn [\n          (valid-transition? [current [start end]] (or (= current start) (= current end)))\n          (new-node[current [e1 e2]] (if (= e1 current) e2 e1))\n          (all-perms [coll]\n          (let\n            [s (count coll)]\n            (map #(vector (nth coll %) (vec(concat (subvec coll 0 %) (subvec coll (inc %) s)))) (range s))))\n          (tourable-from? [current edges]\n          (if (empty? edges)\n            true\n            (reduce #(or %1 %2)\n                    (map (fn [[trans others]] (if (valid-transition? current trans)\n                                                (tourable-from? (new-node current trans) others)\n                                                false))\n                         (all-perms edges) ))))\n          ]\n  (let [\n        allnodes (reduce (fn [acc [n1 n2]] (conj acc n1 n2) ) #{} graph)\n        ]\n    (reduce #(or %1 %2) (map #(tourable-from? % graph) allnodes)\n            ))))", "user": "55f2c898e4b06e875b46ce4b"}, {"problem": 89, "code": "(fn [edges]\n    (let [from-node (merge-with concat\n                                (group-by first edges)\n                                (group-by second edges))\n          ;_ (println from-node)\n          paths (fn paths [cur-node seen]\n                  ;(println cur-node seen)\n                  (if (= (count seen) (count edges))\n                    [true]\n                    (apply\n                     concat\n                     (for [edge (set (from-node cur-node))\n                           :when (not (seen edge))]\n                       (paths (or (first (filter #(not= % cur-node) edge))\n                                  cur-node)\n                              (conj seen edge))))))]\n      (boolean\n       (first\n        (mapcat identity\n                (for [node (keys from-node)]\n                  (paths node #{})))))))", "user": "5275f7a2e4b03e8d9a4a74d0"}, {"problem": 89, "code": "(fn [xs]\n  (let [counts (->> (filter (fn [[a b]] (not= a b)) xs) (flatten) (frequencies))\n        odd-counts (->> (filter (fn [[_ n]] (odd? n)) counts) count)\n        even-counts (->> (filter (fn [[_ n]] (even? n)) counts) count)]\n    (or (= odd-counts 2) (and (= odd-counts 0) (> even-counts 0)))))", "user": "5392bfdee4b0b51d73faaeb2"}, {"problem": 89, "code": "(fn [edges]\n  (let [vertices (into #{} (flatten edges))\n        find-next (fn [[v seen]] (filter (fn [[a b]] (or (= v a) (= v b))) (remove seen edges)))\n        make-state (fn [[a b] [v seen]] (vector (if (= v a) b a) (conj seen [a b])))]\n    (loop [[state & states] (map #(vector % #{}) vertices)]\n      (cond\n        (nil? state) false\n        (= (count edges) (count (second state))) true\n        :else (recur (concat (map #(make-state % state) (find-next state)) states))))))", "user": "4faf97d8e4b081705acca258"}, {"problem": 89, "code": "(fn __\n    [edges]\n    (let [edge-list (apply merge-with concat (map (fn [[s e]] (if (= s e) {s [s s]}\n                                                                   {s [e] e [s]})) edges))\n           explore (fn [[seen frontier]]\n                     (let [new-frontier (set (remove seen (mapcat edge-list frontier)))]\n                       [(clojure.set/union seen new-frontier) new-frontier]))\n           start (ffirst edges)\n           component (ffirst (filter #(empty? (second %)) (iterate explore [#{start} #{start}])))\n           odd-degree-nodes (filter #(odd? (count (second %))) edge-list)\n           connected (= (count component) (count edge-list))]\n          (and connected (<= (count odd-degree-nodes) 2))))", "user": "56897739e4b0dcc4269f407d"}, {"problem": 89, "code": "(fn [n](loop [x n\n               y (last n)\n               a (last y)]\n          (letfn [(fnc [xs ys i](last(sort-by #(< -1 (.indexOf % (ys i))) xs)))]; grabs next tuple\n            (cond\n              (empty? x) true\n              (= -1 (.indexOf y a)) false\n              (= 0 (.indexOf y a)) (recur (pop x) (fnc (pop x) y 1) (y 1))\n              (= 1 (.indexOf y a)) (recur (pop x) (fnc (pop x) y 0) (y 0))\n              ))))", "user": "566a3a26e4b0a866af689699"}, {"problem": 89, "code": "(fn [l]\n  (let [m     ((fn [a]\n  (merge-with into\n    (group-by first a)\n    (group-by last a)\n  ) ) (filter #(not(apply = %1)) l ))]\n  (and\n    (not (empty? m)) \n    (or \n        (every? #(even? (count (last %1))) m ) \n        (= 2(count (filter #(odd? (count (last %1))) m)))\n    )\n  )\n)\n)", "user": "54edcf96e4b024c67c0cf866"}, {"problem": 89, "code": "(fn [edges]\n  (let [v (zipmap (distinct (flatten edges)) (repeat 0))\n        degrees (vals (reduce\n                        (fn [r [a b]]\n                          (if (not= a b)\n                            (-> r\n                                (update-in [a] inc)\n                                (update-in [b] inc))\n                            r))\n                        v edges))\n        odd (count (filter odd? degrees))\n        connected? (fn [edges]\n                     (let [find (fn [union k] (or (some #(if (contains? % k) %) union) #{k}))]\n                       (= 1 (count\n                              (reduce (fn [r [a b]]\n                                        (let [ua (find r a)\n                                              ub (find r b)]\n                                          (-> r\n                                              (disj ua ub)\n                                              (conj (clojure.set/union ua ub)))))\n                                      #{} edges)))))]\n    (and\n      (or (= odd 2) (= odd 0))\n      (connected? edges))))", "user": "56874171e4b0dcc4269f405c"}, {"problem": 89, "code": "(fn [g]\n  (letfn [\n          (get-i [s e]\n            (last (first (filter #(= e (first %)) (map-indexed #(-> [(last %2) %]) s)))))\n\n          (drop-i [s i]\n            (vec (concat (subvec (vec s) 0 i) (subvec (vec s) (inc i)))))\n\n          (tour?\n            ([g] (let [h (map-indexed #(conj %2 %) g)]\n                   (= true (tour? (mapcat (fn [[a b i]] [[a b i] [b a i]]) h) h))))\n            ([s u]\n             (if (seq u)\n               (if (seq s)\n                 (some\n                   #{true}\n                   (map (fn [[a b i]]\n                          (let [v (drop-i u (get-i u i))]\n                            (tour? (mapcat (fn [[c d j]] (cond (= b c) [[c d j]] (= b d) [[d c j]])) v) v))) s))\n                 false)\n               true)))]\n    (tour? g)))", "user": "56824e1be4b0945ebc182a91"}, {"problem": 89, "code": "(letfn [(re [e coll]\n          (let [[l r] (split-with #(and (not= e %) (not= (reverse e) %)) coll)] (concat l (rest r))))\n        (other [e n] (first (remove #{n} e)))\n        (path? [coll n]\n          (let [valid (filter #(some #{n} %) coll)]\n            (or (empty? coll)\n                (some #(path? (re % coll) (other % n)) valid))))]\n  (fn [coll] (boolean (some (partial path? coll) (distinct (flatten coll))))))", "user": "554680cbe4b0a04f7929953e"}, {"problem": 89, "code": "(fn euler? [edges]\n  (letfn [\n           (connected? [edges]\n                       (letfn [(bfs [edges start]\n                                    (\n                                      (fn breadth-first-search [edges [current & waiting :as visit-queue] visited]\n                                        (if (empty? visit-queue)\n                                          visited\n                                          (let [\n                                                 candidate-edges (filter (fn [[a b]] (or (= a current) (= b current))) edges)\n                                                 candidate-nodes (distinct (mapcat (fn [edge] (filter #(not= % current) edge)) candidate-edges))\n                                                 new-nodes (filter #(not (contains? visited %)) candidate-nodes)\n                                                 ]\n                                            (recur edges (concat new-nodes waiting) (conj visited current)))))\n                                      edges [start] #{}))]\n                         (if (empty? edges)\n                           true\n                           (let [\n                                  all-nodes (into #{} (apply concat edges))\n                                  connected-nodes (bfs edges (first all-nodes))\n                                  ]\n                             (= connected-nodes all-nodes)))))\n           (connected-to? [[a b :as edge] node]\n                          (or (= a node) (= b node)))\n           (degree [edges node]\n                   (count (filter #(connected-to? % node) edges)))\n           ]\n    (let [\n           nodes (into #{} (apply concat edges))\n           degrees (map #(degree edges %) nodes)\n           odd-degrees (count (filter odd? degrees))\n           ]\n      (and\n        (connected? edges)\n        (<= odd-degrees 2)))))", "user": "5654e024e4b0f9d632dd848d"}, {"problem": 89, "code": "(fn eulerian [edges]\n(let [degrees \n      (fn [edges]\n          (apply merge-with + {} (for [[a b] edges\n                                       :when (not= a b)]\n                                           {a 1 b 1})))\n      gdeg (degrees edges)]\n  \n  (and\n    (not (empty? gdeg))\n    (->> (vals gdeg) (filter odd?) count (>= 2)))))\n;\n; pfff I read undirected as UNIdirected ....\n;#(not (empty?\n;  ((fn g [e]\n;   (if (< (count e) 2)\n;     e\n;     (filter vector? (for [x e]\n;        (let [h (g (set (remove #{x} e)))]\n;           (if (some (fn [j] (= (second x) (first j))  )  h)\n;            x)\n;        )\n;       )\n;     )\n;    )\n;) % )))", "user": "56bca51ae4b0f26550335963"}, {"problem": 89, "code": "(fn [edges]\n  (let [oddEdges (count (filter odd? (vals (frequencies (flatten edges)))))\n        connected? (loop [graph (set (first edges))\n                          otheredges (rest edges)]\n                     (if (empty? otheredges)\n                       true\n                       (let [inGraph? (some true? (map #(contains? graph %) (first otheredges)))]\n                         (if (not inGraph?)\n                           false\n                           (recur (apply conj graph (first otheredges))\n                                  (rest otheredges))))))]\n    (if (and connected? (or (= oddEdges 0) (= oddEdges 2)))\n      true\n      false)))", "user": "567d18c9e4b05957ce8c61c4"}, {"problem": 89, "code": "(fn graph-tour [edges]\n  (letfn [(adjoining-vector [k-node nodes edges]\n            (map (fn [node]\n                   (if-let [same-edges (->> edges\n                                            (filter #(or (= % [k-node node])\n                                                         (= % [node k-node])))\n                                            seq)]\n                     (count same-edges)\n                     0)) nodes))\n          (graph [nodes edges]\n            (map (fn [node]\n                   (adjoining-vector node nodes edges)) nodes))\n          (exist-path [[v v2] graph]\n            (if (not (zero? (nth (graph v) v2)))\n              true\n              (some #(exist-path [% v2] graph)\n                    (filter identity (map-indexed\n                                      (fn [index item]\n                                        (when (and\n                                               (not= index v) ;; otherwise cause infinite call\n                                               (not (zero? item))) index))\n                                      (graph v))))))\n          \n          (connectivity [graph]\n            (every? #(exist-path % graph) (let [nodes-cnt (count graph)]\n                                            (for [x (range nodes-cnt)\n                                                  y (range nodes-cnt)\n                                                  :when (> y x)] [x y]))))]\n\n    (let [nodes (set (apply concat edges))\n          graph (into [] (graph nodes edges))\n          odds (count (filter #(odd? (apply + %)) graph))]\n      (and\n       (connectivity graph)\n       (or (= 0 odds)\n           (= 2 odds))))))", "user": "5693a53ee4b0dcc4269f4106"}, {"problem": 89, "code": "(fn eulerian [edges]\n  (let [degrees (fn [edges]\n                  (apply merge-with + {} (for [[a b] edges\n                                               :when (not= a b)]\n                                           {a 1 b 1})))\n        gdeg (degrees edges)]\n    (and \n     (not (empty? gdeg))\n     (->> (vals gdeg) (filter odd?) count (>= 2)))))", "user": "567931e9e4b05957ce8c6184"}, {"problem": 89, "code": "(letfn\n    [(next-tulpes [t graph path]\n       (let [node (remove (set (last path)) t)] \n         (->> (filter #(some (set node) %) graph)\n              (remove #(= % t)))))\n\n     (visited? [path]\n       (->> (frequencies path)\n            (some (fn [[_ freq]] (> freq 2)))))\n       \n\n     (next-graph [t graph]\n       (let [[n m] (split-with (partial not= t) graph)]\n         (concat n (rest m))))\n\n     (walk [tulpes graph path final]\n       (if (or (not (seq graph)) (visited? path))\n         (= (set path) (set final))\n         (some true? (map #(walk\n                            (next-tulpes % graph path)\n                            (next-graph % graph)\n                            (conj path %)\n                            final)\n                          tulpes))))]\n  (fn [graph]\n      (boolean (walk graph graph [] graph))))", "user": "56795deae4b05957ce8c6187"}, {"problem": 89, "code": "(fn [ss]\n  (letfn [(drop-nth [xs n] (let [[f b] (split-at n xs)] (concat f (rest b))))\n           (tour [ss n]\n                (if (empty? ss)\n                  true\n                  (some \n                    (fn [[i [n1 n2]]]\n                      (cond\n                        (= n n1) (tour (drop-nth ss i) n2)\n                        (= n n2) (tour (drop-nth ss i) n1)\n                      :else false))\n                    (map-indexed vector ss))))]\n    (boolean\n      (some\n        (fn [[i [h t]]]\n          (or\n            (tour (drop-nth ss i) h)\n            (tour (drop-nth ss i) t)))\n        (map-indexed vector ss)))))", "user": "56b86e64e4b0f26550335924"}, {"problem": 89, "code": "(fn g [pairs]\n    (letfn [ (invert [e] [(second e) (first e)])\n             (arrcon [a e] (some #(= (set %) (set e)) a))\n            ]\n      (let [tmp (reduce #(assoc %1 (first %2) (conj (get %1 (first %2) []) %2)) {} pairs)\n            vertex_edges (reduce #(assoc %1 (second %2) (conj (get %1 (second %2) []) (invert %2))) tmp pairs)\n          r (loop [paths (map (fn [e] [e]) (concat pairs (map invert pairs)))  prev []]\n            (if (= paths prev) paths\n              (recur (reduce\n               (fn [new_paths old_path]\n                 (if (>= (count old_path) (count pairs))\n                      [old_path]\n                      (concat new_paths\n                            (filter\n                              #(not (empty? %))\n                              (map\n                                (fn [edge] (if  (arrcon old_path edge) [] (conj old_path edge)))\n                                (get vertex_edges (second (last old_path)) [])\n                              )\n                            )\n                      )\n                 )\n               )\n               #{} paths) paths)\n            )\n         ) ]\n      (and (not (empty? r)) (true? (some #(= (count %) (count pairs)) r)))\n     )\n   )\n)", "user": "55eeb37ae4b0121d4835fdf3"}, {"problem": 89, "code": "(fn [edges]\n  (let [nodes (set (flatten edges))\n        tourable? (fn tourable? [edges node]\n                    (if (empty? edges)\n                      true\n                      (let [available-edges (keep-indexed (fn [idx edge]\n                                                            (when (contains? (set edge) node)\n                                                              idx))\n                                                          edges)]\n                        (if (empty? available-edges)\n                          false\n                          (some true? (map (fn [edge-idx]\n                                             (let [edge (nth edges edge-idx)\n                                                   dest (first (disj (set edge) node))\n                                                   remaining-edges (concat (take edge-idx edges)\n                                                                           (drop (inc edge-idx) edges))]\n                                               (tourable? remaining-edges dest)))\n                                           available-edges))))))]\n    (not (nil? (some true? (map #(tourable? edges %) nodes))))))", "user": "56f9982ce4b07572ad1a88b8"}, {"problem": 89, "code": "(fn eulerian-path-graph? [tuples]\n  \"a given graph is eulerian if the graph is connected and has at most 2 edges \nhaving odd degrees, and the rest of edges with even-degree\"\n  (letfn [(duplicate-vertexes? [tuples]\n            (not= (count tuples) \n               (count\n                 (set (map sort tuples)))))\n          (find-edges [tuples] (vec (set (flatten (concat tuples)))))\n          (find-adjacents [node tuples]\n            (reduce (fn [adjacents-map [from to :as tuple]]\n                      (if (get (set tuple) node)\n                        (assoc adjacents-map node (set (concat (remove #(= node %) tuple) (adjacents-map node))))\n                        adjacents-map)) \n                    {} tuples))\n          (find-nodes-with-adjacents [graph]\n            (reduce (fn [nodes-with-adjacents node]\n                      (conj nodes-with-adjacents (find-adjacents node tuples)))\n                    {} (find-edges tuples)))\n          (graph-connected? [tuples]\n            (letfn [(vec-contains? [xs x] (some #(= % x) xs))\n                    (depth-first-connected? [node tuples visited]\n                      (cond (vec-contains? visited node) visited\n                            :else\n                            (reduce (fn [visited-nodes adjacent]\n                                      (if ((comp not empty?) (find-adjacents adjacent tuples))\n                                        (depth-first-connected? adjacent tuples visited-nodes)\n                                        (conj visited-nodes adjacent :visited)\n                                      )\n                                    )\n                                   (conj visited node) (last (vals (find-adjacents node tuples))))))\n                    (find-edges [tuples] (vec (set (flatten (concat tuples)))))]\n              (-> tuples\n                find-edges\n                first\n                (depth-first-connected? tuples [])\n                count\n                (= (count (find-edges tuples)))\n                )))]\n    (if (duplicate-vertexes? tuples) false\n      (if ((comp not graph-connected?) tuples) false\n          (->> tuples\n            find-nodes-with-adjacents\n            vals\n            (filter (comp odd? count))\n            count\n            (>= 2)\n          )))))", "user": "5553b729e4b0deb715856e05"}, {"problem": 89, "code": "(fn solve [graph] (\n    let [vertices (set (flatten graph))\n         gne (group-by first (concat graph (map reverse graph)))\n         ne (apply merge (for [[k v] gne] {k (disj (set (flatten v)) k)}))\n         nodes (set (keys ne))\n\n         degrees (for [[k v] gne] (count v))\n         odds (filter odd? degrees)\n         bfs (fn [graph v]\n          (loop [q (list v) visited #{v}]\n            (if (empty? q) visited\n              (let\n                [\n                 cur (peek q)\n                 next-level (filter #(not (contains? visited %)) (graph cur))\n                 ]\n                (recur (into (pop q) next-level) (into visited next-level))\n                )\n              )\n            )\n          )\n         ]\n      (if (not= nodes (bfs ne (first nodes)))\n        false\n        (or (= (count odds) 0) (= (count odds) 2)))\n    )\n  )", "user": "56f258d3e4b04a395b9a04a1"}, {"problem": 89, "code": "(fn allConnectedX[nodes]\n\t(letfn \n\t\t[\n\t\t\t(ors[x]\n\t\t\t\t(if (empty? x)\n\t\t\t\t\tfalse\n\t\t\t\t\t(reduce (fn[a b] (or a b)) x)\n\t\t\t\t)\n\t\t\t)\n\n\t\t\t(removeI [v n]\n\t\t\t\t(vec (concat (subvec v 0 n) (subvec v (inc n))))\n\t\t\t\t)\n\n\n\t\t\t(allConnectedI[nodes connection lst i]\n\t\t\t\t(let [\n\t\t\t\t\tnodeI (get nodes i)\n\t\t\t\t\tnodesWithoutI (removeI nodes i)\n\t\t\t\t\t]\n\t\t\t\t\t(or \n\t\t\t\t\t\t(and \n\t\t\t\t\t\t\t(= (first nodeI) connection) \n\t\t\t\t\t\t\t(allConnectedRes nodesWithoutI (last nodeI) lst)\n\t\t\t\t\t\t)\n\t\t\t\t\t\t(and \n\t\t\t\t\t\t\t(= (last nodeI) connection) \n\t\t\t\t\t\t\t(allConnectedRes nodesWithoutI (first nodeI) lst)\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t) \n\t\t\t)\n\n\t\t\t(allConnectedRes[nodes connection lst]\n\t\t\t\t(if (empty? nodes)\n\t\t\t\t\t(= connection lst)\n\t\t\t\t\t(ors\n\t\t\t\t\t\t(map (partial allConnectedI nodes connection lst) (range (count nodes)))\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\t\t\n\t\t]\n\t\t(if (nil? (second nodes))\n\t\t\ttrue\n\t\t\t(let [fst (first nodes)]\n\t\t\t\t(allConnectedRes (subvec nodes 1) (first fst) (last fst))\n\t\t\t)\n\t\t)\n\t)\n)", "user": "568820e8e4b0dcc4269f4067"}, {"problem": 89, "code": "(fn [args]\n  (letfn [(connected? [nodes]\n            ((fn connected-1? [nodes tried]\n               (let [next_try (first (clojure.set/difference (first nodes) tried))]\n                 (cond (= (count nodes) 1) true\n                       (nil? next_try) false         ; cann't go any further\n                       :else\n                       (recur (reduce (fn [acc e]\n                                        (if (e next_try)\n                                          (cons (clojure.set/union (first acc) e)\n                                                (rest acc))\n                                          (conj (vec acc) e))\n                                        ) [#{}] nodes)\n                              (conj tried next_try)))))\n             (map set nodes) #{}))\n          (oneline? [nodes]\n            (<= (count (filter #(odd? (last %)) (frequencies (flatten nodes)))) 2))]\n    (and (connected? args) (oneline? args))))", "user": "56f7ecdfe4b08e7d20b96834"}, {"problem": 89, "code": "(fn [graph]\n  (letfn [(single-connect? [graph]\n                            (let [nnode (count (distinct (flatten (seq graph))))\n                                  full-pocket? (fn [pocket] (= (count pocket) nnode))\n                                  gen-pocket (fn gen-pocket [graph pocket current]\n                                               (let [next-node? (fn [[a b] current]\n                                                                  (cond\n                                                                    (= a current) b\n                                                                    (= b current) a))\n                                                     next-nodes (filter identity (map #(next-node? % current) graph))\n                                                     next-nodes-filtered (filter (complement #(some #{%} pocket)) next-nodes)]\n\n                                                 (if (empty? next-nodes-filtered)\n                                                   [current]\n                                                   (let [chains (map (fn [x] (gen-pocket graph (conj pocket current) x))\n                                                                     next-nodes-filtered)]\n                                                     (distinct (conj (flatten chains) current))))))\n                                  pocket (gen-pocket graph [] (ffirst graph))]\n                              (full-pocket? pocket)))\n\n\n           (odd-node02 [graph]\n                       (let [odd-nodes-total (->>\n                                               (group-by identity (flatten graph))\n                                               (vals)\n                                               (map count)\n                                               (filter odd?)\n                                               count)]\n                         (or (= odd-nodes-total 0) (= odd-nodes-total 2))))]\n\n  (and (single-connect? graph) (odd-node02 graph))))", "user": "56fbf83de4b07572ad1a88da"}, {"problem": 89, "code": "(fn [[[_ x] & t]]\n  ((fn aux [cn ue]\n     (if (empty? ue)\n       true\n       (let [n (into {} (keep #(some {cn [% (first (filter (partial not= cn) %))]} %) ue)) k (keys n)]\n         (if k\n           (loop [[f & r] k]\n             (if f\n               (or (aux (n f) (remove #(= f %) ue)) (recur r))\n               false))\n           false))))\n   x t))", "user": "57035ccfe4b08d47c97781ef"}, {"problem": 89, "code": "(fn f [graph]\n  (letfn [(remove-one [node graph]\n            (let [[n m] (split-with #(not= % node) graph)]\n              (concat n (next m))))\n\n          (group-adj [node graph]\n            (let [groups (group-by #(some #{node} %) graph)\n                  adj-group (groups node)\n                  non-adj-group (groups nil)]\n              [adj-group non-adj-group]))\n\n          (can-tour? [start graph]\n            (let [[adj-edges non-adj-edges] (group-adj start graph)]\n              (if adj-edges\n                (if (some (fn [[a b]]\n                            (let [next-node (if (= a start) b a)\n                                  next-graph (remove-one [a b] graph)]\n                              (can-tour? next-node next-graph)))\n                          adj-edges)\n                  true\n                  false)\n                (if non-adj-edges\n                  false                           ;Un-connected edges that haven't been explored\n                  true                            ;No edges left to explore\n                  ))))]\n    (can-tour? (ffirst graph) graph)))", "user": "569dd6e8e4b0542e1f8d1480"}, {"problem": 89, "code": ";; maybe this is cheating, but its leaning on Euler's path\n(fn [g]\n    (or (= (count g) 1)\n        (->> (set (flatten g))\n             (map (fn [v] (count (filter #(some #{v} %) g))))\n             (every? even?))))", "user": "4f57c913e4b0a7574ea7183f"}, {"problem": 89, "code": "(fn [edges]\n  (letfn [(rember [coll v]\n \t        (cond\n             (empty? coll) '()\n             (= (first coll) v) (rest coll)\n             :else (cons (first coll) (rember (rest coll) v))))\n          (add-connection [graph k dk]\n            (assoc graph k (if (contains? graph k) (conj (graph k) dk) [dk])))\n          (remove-connection [graph k dk]\n            (let [graph* (update-in graph [k] rember dk)]\n              (if (empty? (graph* k))\n                (dissoc graph* k)\n                graph*)))\n          (add-edge [graph a b]\n            (-> graph (add-connection a b) (add-connection b a)))\n          (remove-edge [graph a b]\n            (-> graph (remove-connection a b) (remove-connection b a)))\n          (parse-graph [edges]\n            (reduce (fn [graph [a b]] (add-edge graph a b)) {} edges))\n          (edgeless? [graph]\n             (or (empty? graph)\n                 (and (= (count graph) 1) (empty? (val (first graph))))))\n          (starts-tour? [graph k]\n            (or (empty? graph)\n          \t    (boolean (some (fn [dk] (starts-tour? (remove-edge graph k dk) dk))\n                         (graph k)))))]\n    (starts-tour? (parse-graph edges) (ffirst edges))))", "user": "5339c105e4b0e30313ee6cae"}, {"problem": 89, "code": "(fn [bb]\n  (let [\n   bl (into '() bb),\n   connected?  (fn [bb]\n      (if (empty? bb) false\n        (= (count (set (flatten bb)))\n           (count (loop [vs (set (first bb))]\n         (let [ns\n          (set (concat\n             (for [[f s] bb :when (and (vs f) (not (vs s)))] s)\n             (for [[f s] bb :when (and (vs s) (not (vs f)))] f)\n          ))]\n       (if (empty? ns) vs\n       (recur (into vs ns)))\n   ))))\n  ))]\n  (if (connected? bl)\n      (let [ cross (map count (vals (group-by identity (flatten bl ))))\n        nends (- (count cross) (count (filter even? cross)))\n      ]\n      (or (= nends 0) (= nends 2)))\n      false)))", "user": "4fd11a93e4b04c3a95aa040a"}, {"problem": 89, "code": "(fn [s] (let [d #(empty? (filter (fn [x] (= x %2)) %))\n                     t (fn h [l r] (if (empty? r)\n                                        l\n                                    (let [w (let [t (last (butlast l))\n                                                  z (first (last l))] \n                                                (if (nil? t) z\n                                                    (if (or (= z (first t))\n                                                            (= z (last t)))\n                                                            (last (last l))\n                                                            z)))] \n                                    (reduce #(if (empty? %2) [] (conj % %2))\n                                        [] \n                                        (map #(if (d l %) (h (conj l %) (filter (fn [x] (not (= x %))) r)))\n                                             (reduce #(if (or (= w (first %2)) (= w (last %2))) \n                                                    (if (d % %2) (conj % %2) %) %) [] r))))))]\n    (not (empty? (t (conj [] (first s)) (rest s))))))", "user": "56c08696e4b060a8e693e3aa"}, {"problem": 89, "code": "(fn graph-tour? [edges]\n  (letfn [(connected-nodes\n           [nodes coll]\n           (let [nodes' (into nodes\n                              (flatten\n                               (for [[a b] coll :when (or (contains? nodes a)\n                                                          (contains? nodes b))]\n                                [a b])))]\n             (if (= nodes nodes')\n               nodes\n               (recur nodes' coll))))\n          (connected-graph?\n           [s]\n           (= (connected-nodes #{(ffirst s)} s)\n              (set (flatten (seq s)))))\n          (tour?\n           [s]\n           (let [edge-count (map #(count (val %)) (group-by identity (flatten s)))]\n             (or (every? even? edge-count)\n                 (= 2 (count (filter odd? edge-count))))))]\n    (and (connected-graph? edges)\n         (tour? edges))))", "user": "56ae214ce4b03c432f18735a"}, {"problem": 89, "code": "(fn [edges]\n    (loop [paths (map (fn [edge] {:path (list edge)\n                                  :next-node (second edge)\n                            \n                                  :remaining (disj (set edges) edge)}) edges)]\n   \n      (cond (empty? paths) false\n            (some (fn [path] (= (count edges) (count (:path path)))) paths) true\n            :else (recur (mapcat \n                           (fn [{path :path\n                                 remaining :remaining\n                               \n                                 next-node :next-node}]\n               \n                             (->> remaining\n                                  (filter (fn [[a b]] (or  (= next-node a) (= next-node b))))\n                                  (map (fn [edge] {:path (conj path edge)\n                                                   :remaining (disj remaining edge)\n                                              \n                                                   :next-node (if (= next-node (first edge)) (second edge) (first edge))}))))\n                            paths)))))", "user": "4f463dfde4b0d56e7bb92b99"}, {"problem": 89, "code": "(fn [edges]\n  (let [nodes (distinct (flatten edges))\n        edges-with-index (into {} (map-indexed vector edges))\n        has-node (fn [[_ edge] node] (some (partial = node) edge))\n        can-visit \n        (fn can-visit [rem-edges current-node]\n          (let [candidates (filter #(has-node  % current-node) rem-edges)                \n                results-rest (for [[id cand] candidates\n                                   :let [new-node (if (= (first cand) current-node) (second cand) (first cand))]]\n                               (can-visit (dissoc rem-edges id) new-node))]\n            (cond\n              (empty? rem-edges) true        \n              (empty? candidates) false                      \n              :else (some identity results-rest))))\n        results-start (map #(can-visit edges-with-index %) nodes)]\n    (boolean (some identity results-start))\n  ))", "user": "54e345a1e4b024c67c0cf7db"}, {"problem": 89, "code": "(fn graph-tour [g]\n  (let [vdegs (reduce\n               (fn [ret [a b]]\n                 (let [witha (merge-with + ret {a 1})]\n                   (merge-with + witha {b 1})))\n               {}\n               g)\n        nodenum (count vdegs)\n        connected? (= nodenum\n                      (count\n                       (set\n                        (map first \n                             (tree-seq (constantly true)\n                                 (fn children [[v edges]]\n                                   (let [newedges (filter (fn [[a b]] (not= b v)) edges)\n                                         nodes (->> newedges\n                                                    (filter (fn [[a b]] (= a v)))\n                                                    (map second))]\n                                     (map #(vector % newedges) nodes)))\n                                 [((first g) 0) g])))))\n        oddnum (->>\n                vdegs\n                (filter (fn [[k v]] (odd? v)))\n                count)\n        ]\n    (and connected?\n         (or (= oddnum 2) (zero? oddnum)))))", "user": "571d063ee4b0145328a76272"}, {"problem": 89, "code": "(fn\n  f\n  [g]\n  (letfn [(rf [s e]\n              (let [p (split-with #(not= e %) s)]\n                (concat\n                 (-> p first)\n                 (-> p second rest))))\n          (t [current seen remaining]\n             (let [nexts (filter #(or (= current (first %)) (= current (last %))) remaining)]\n               (cond (empty? remaining) true\n                     (empty? nexts) false\n                     :e (reduce #(or %1 %2) (map #(t (first (filter (fn [x] (not= current x)) %))\n                                                     (conj seen %)\n                                                     (rf remaining %)\n                                                     ) nexts)))))]\n    (t (ffirst g) [] g)\n    ))", "user": "56ab7578e4b03c432f18733d"}, {"problem": 89, "code": "(fn graph-tour? [undirected-edges]\n  (letfn [(neighbours [r [k v]]\n            (update-in r [k] (fnil conj []) v))\n          (path [graph start seen]\n            (if (seen start)\n              seen\n              (for [node (graph start)]\n                (path graph node (conj seen start)))))\n          (directed-graph [edges]\n            (reduce neighbours {} (mapcat (juxt identity reverse) edges)))]\n    (let [nodes (->> undirected-edges\n                     (into [])\n                     (apply concat)\n                     distinct\n                     set)\n          d-graph (directed-graph undirected-edges)]\n      (if (= (count undirected-edges) 1)\n        true\n        (and (every? (comp even? count val) d-graph)\n             (->> (path d-graph (first nodes) #{})\n                  flatten\n                  (some (partial = nodes))\n                  boolean))))))", "user": "572ea970e4b0cd1946bd0f89"}, {"problem": 89, "code": "(fn f [data]\n  (let [cmp (fn [a [b c]] (cond (= a b) c (= a c) b :e nil))\n        dropn #(concat (take % %2) (drop (+ % 1) %2))\n\n        f2 (fn f2 [s n r]\n             (cond (empty? s) true\n                   (>= n (count s)) false\n                   (nil? r) (or\n                              (f2 (dropn n s) 0 (first (nth s n)))\n                              (f2 (dropn n s) 0 (second (nth s n))))\n                   (let [r2 (cmp r (nth s n))]\n                     (and (not  (nil? r2)) (f2 (dropn n s) 0 r2))) true\n                   \n                   :else\n                   (f2 s (+ n 1) r)))]\n\n    (f2 (vec data) 0 nil)))", "user": "53500869e4b084c2834f4ad3"}, {"problem": 89, "code": "(fn circle [xs]\n  ((complement nil?)\n    (letfn [(choose [crt edge]\n              (if (= (last crt) (first edge)) edge (vec (reverse edge))))\n            (tour [acc res]\n              (if (empty? res) true\n                               (some true?\n                                     (map #(tour (conj acc (choose (last acc) %1))\n                                                 (disj (set res) %1))\n                                          (filter #(.contains % (last (last acc)))\n                                                  res)))))]\n      (or (tour [(first xs)] (rest xs))\n          (tour [reverse (first xs)] (rest xs))))))", "user": "5659679ae4b068f2fe63dbeb"}, {"problem": 89, "code": "(fn [es]\n  (letfn [(find' [m v] (let [p (m v v)] (if (= p v) v (find' m p))))]\n    (let [ninc (fnil inc 0)\n          cs (reduce (fn [r [lhs rhs]] (-> r (update-in [lhs] ninc) (update-in [rhs] ninc))) {} es)\n          uf (reduce (fn [r [lhs rhs]]\n                       (let [p (find' r lhs)] (-> r (assoc lhs p) (assoc rhs p)))) {} es)]\n      (boolean (and (apply = (vals uf)) (#{0 2} (count (filter odd? (vals cs)))))))))", "user": "56d68cbae4b0ea9b8538f7cd"}, {"problem": 89, "code": "(fn[s](\n     loop[ x (set(last (vec s))) y (pop (vec s)) l -1 ](\n       if(= (count y) l) \n       (if(= l 0) \n         (if (= (count (apply concat s)) 2) true\n         (= 0 (count (filter (fn[i](odd? (second i))) (frequencies(apply concat s)))))\n         )\n         false\n       )\n       (recur\n         \n         (clojure.set/union x \n                 (set(flatten\n                       (filter \n                         (fn[itm](\n                           or\n                           (contains? x (first itm))\n                           (contains? x (second itm))\n                         ))\n                         y\n                       )\n                 ))\n         )\n         \n         (filter \n                         (fn[itm](\n                           not(or\n                           (contains? x (first itm))\n                           (contains? x (second itm)))\n                         ))\n                         y\n                       )\n         \n         (count y)\n         \n       )\n     )\n  ))", "user": "56039843e4b04bb52996e1be"}, {"problem": 89, "code": "(fn eulerian2? [G]\n  (letfn [(adj-list2 [R] ;;given relations construct adj-list\n            (let [R2 (concat R (mapv (fn [[a b]] [b a]) R))]\n              (reduce #(if (contains? %1 (first %2))\n                         (assoc %1 (first %2) (conj (%1 (first %2)) (last %2)))\n                         (assoc %1 (first %2) [(last %2)] )) {}  R2)))\n\n          (df-search3 [G v R];;df-search on inicial vertex r. R is a set that contains all vertex that r can reach and v is a reacheable vertex\n            (let [neib (G v)]\n              (reduce #(if (contains? %1 %2)\n                         %1\n                         (clojure.set/union %1 (df-search3 G %2 (conj %1 %2)))) R (G v))))\n \n          (connected? [G]\n            (let [adj (adj-list2 G)\n                  ks (set (keys adj))\n                  reach (df-search3 adj (first ks) #{})]\n              (= ks reach)))\n          ]\n    (let [adj (adj-list2 G)\n          ks (set (keys adj))]\n      (if (connected? G)\n        (let [lf (filter #(odd? (count (adj %))) ks)]\n          (if (or (= (count lf) 2) (= (count lf) 0))\n            true\n            false))\n        false))))", "user": "574f1c24e4b02ea114799255"}, {"problem": 89, "code": "(fn [edges]\n  (letfn [(drop-first\n           [x coll]\n           (lazy-seq\n            (if (seq coll)\n              (if (= x (first coll))\n                (rest coll)\n                (cons (first coll)\n                      (drop-first x (rest coll)))))))\n          (can-finish?\n           [tour node edges]\n           (or (empty? edges)\n               (->> edges\n                    (filter #(or (empty? tour)\n                                 (% node)))\n                    (map #(can-finish? (conj tour %)\n                                       (first (disj % node))\n                                       (drop-first % edges)))\n                    (some identity))))]\n    (boolean (can-finish? [] nil (map set edges)))))", "user": "575cbe44e4b02ea114799374"}, {"problem": 89, "code": ";; Eulerian path,\n;; An undirected graph has an Eulerian path \n;; if and only if the number of odd degree vertices is 0 or 2, \n;; and all vertices belong to a single connected component.\n(fn eulerianPath? [edges]\n   (let [vertices (set (apply concat edges))]\n     (letfn [(edge? [u v] (some (fn [[w z]] (or (= [w z] [u v]) (= [w z] [v u]))) edges) )\n             (neighbors [v] (filter (partial edge? v) vertices) )\n              ; Note that degree != #neighbors since we can have duplicate edges\n             (degree [v] (count (filter (fn [[u w]] (or (= v u) (= v w) )) edges)))\n             (numOdd [] (count (filter #(odd? (degree %)) vertices)))\n             (component [v] \n               (loop [seen #{v}\n                      toExplore [v]]\n                 (if (empty? toExplore) seen\n                   (let [u (first toExplore)\n                         newGuys (filter #(not (seen %)) (neighbors u))]\n                     (recur (into seen newGuys) (concat (rest toExplore) newGuys))     \n                     )\n                   )\n                 ))\n             (connected? [] (= (count vertices) (count (component (first vertices)))))]\n       (if (not (connected?)) false\n         (let [o (numOdd)]\n           (or (zero? o) (= 2 o) )\n           )\n         )\n       \n       )\n     )\n   )", "user": "575ef4b6e4b08062f99a4e78"}, {"problem": 89, "code": "(fn [e]\n (let [world (merge-with concat\n                         (into {} (map (fn [[k v]] [k (map second v)]) (group-by first e)))\n                         (into {} (map (fn [[k v]] [k (map first v)]) (group-by second e))))\n       remove-first (fn [p v]\n                      (let [[h t](split-with #(not= p % ) v)]\n                        (concat h (rest t))))\n       ee (fn ee [path a n world]\n            (cond\n              (zero? n) [path]\n              (empty? (world a)) nil\n              :else (lazy-seq (mapcat (fn [b] (ee (conj path b) b (dec n)\n                                         (reduce (fn [w [k x]] (assoc w k (remove-first x (w k))))\n                                                 world\n                                                 [[a b] [b a]])))\n                             (world a)))))]\n   (not (empty? (mapcat #(ee [%1] %1 (count e) world) (keys world))))))", "user": "56102f50e4b05f002753df6b"}, {"problem": 89, "code": "(fn tour [[seed :as edges]]\n  (let [degree\n        (reduce (fn [acc [from to]] \n                  (-> acc \n                      (update-in [from] (fnil inc 0))\n                      (update-in [to] (fnil inc 0))\n                      )) \n                {} edges \n                )\n        ;;\teuler? (every? (fn [[node deg]] (even? deg)) degree)\n        odd-deg (count (filter (fn [[node deg]] (odd? deg)) degree))\n        \n        connected? (loop \n                     [reached [[(first seed)]]\n                      unreached edges\n                      ] \n                     (if (empty? reached) \n                       (empty? unreached) \n                       (let \n                         [p (group-by (fn [[h t]] (contains? (set (map last reached)) h)) unreached )]\n                         (recur (p true) (p false))\n                         )\n                       \n                       ))\n        ]\n    ;;[:c connected? :o odd-deg :derp (contains? #{0 2} odd-deg)]\n    (and connected? (contains? #{0 2} odd-deg) ) \n    \n    ))", "user": "533a2f7be4b0e30313ee6cb8"}, {"problem": 89, "code": "(fn contains-euler-path? [g]\n  (let [g (sort-by first g) f (flatten g)\n        connected? (= (count (reduce (fn [seen [n m]] (if (seen n) (conj seen m) seen)) #{(ffirst g)} g))\n                      (count (distinct f)))\n        count-odd  (count (filter #(odd? %) (vals (frequencies f))))]\n    ;; From http://www.ctl.ua.edu/math103/euler/howcanwe.htm:\n    ;; if the graph is connected and has at most 2 nodes with odd degree,\n    ;; then it contains at least one Euler path\n    (and connected? (<= count-odd 3))))", "user": "575b3e9be4b02ea11479935b"}, {"problem": 89, "code": "(fn [edges]\n  (let [\n        tree-flat (apply concat edges)\n        all-nodes (set tree-flat)\n        start-node (ffirst edges)\n        edge-matcher (fn [vertex] #(some #{vertex} %))\n        matching-edges (fn [vertex edges]\n                         (set (filter\n                               (edge-matcher vertex)\n                               edges)))\n        next-vertex (fn [current-vertex [x y]]\n                      (if (= current-vertex x) y x))\n        can-expand? (fn [[vertex edges]]\n                      (some (edge-matcher vertex) edges))\n        get-children (fn [[vertex edges]]\n                       (map (fn [edge]\n                              [(next-vertex vertex edge) (disj edges edge)])\n                            (matching-edges vertex edges)))\n        connected (= all-nodes (set (map first\n                                     (tree-seq can-expand?\n                                               get-children\n                                               [start-node (set edges)]))))\n        count-degrees (fn [node]\n                        (count (filter #{node} tree-flat)))\n        odd-degree-vertices (filter odd? (map count-degrees all-nodes))]\n    (and connected (not (seq (drop 2 odd-degree-vertices))))))", "user": "50e90813e4b033b0e80d11e7"}, {"problem": 89, "code": "(fn [g]\n  (letfn [(degree [v]\n            (count (filter #(some #{v} %) g)))]\n    (let [odd-degrees (count (filter odd? (map degree (flatten g))))]\n      (or (zero? odd-degrees) (= odd-degrees 2)))))", "user": "56f53962e4b046a417f9206c"}, {"problem": 89, "code": "(fn __ [g]\n  (and\n    (<= (count (filter\n                 #(odd? (val %))\n                 (frequencies (flatten g))))\n        2)\n    (loop [state #{} index 0]\n      (if (< index (count g))\n        (let [[x y] (nth g index)\n              contains-x-or-y? #(or (contains? % x) (contains? % y))\n              without-x-y (set (filter (complement contains-x-or-y?) state))\n              with-x-y (into (into #{} [x y])\n                             (apply concat (filter contains-x-or-y? state)))\n              next-state (conj without-x-y with-x-y)]\n          (recur next-state (inc index)))\n        (= 1 (count state))))))", "user": "56ac81ace4b03c432f187347"}, {"problem": 89, "code": "(letfn [\n(degree [graph x]\n    (count (for [[x1 y1] graph\n                :when (or (= x1 x) (= y1 x))\n                ]\n                1)))\n(is-eulerian [graph]\n  (if (= (count graph) 1) true\n  \t(and\n        (not (some (partial apply =) graph)) ; cheating, here we're checking for self-edges, but we really need to check for\n                                             ; connectivity\n        (> 3 (count (filter odd? (map (partial degree graph) (->> graph flatten distinct))))))))]\n  is-eulerian)", "user": "57717915e4b0979f896515b3"}, {"problem": 89, "code": "#(boolean (or (#{1 11} (count %)) (= 1 (last (last %)))))", "user": "50a83315e4b054305ba5a830"}, {"problem": 89, "code": "(fn graphTour2\n  [graph]\n  (let [oddDeg (count (filter #(odd? (second %)) ((comp frequencies flatten) graph)))]\n    (and ((fn isConnected\n  [graph]\n  (let [vs (distinct (flatten (vec graph)))]\n    (if (= (count vs) 0)\n      true\n      ((fn BFS\n  [root graph vmap queue]\n  (let [adj (distinct (flatten (map first (filter #(= (second %) true) (map vector graph (map #(.contains % root) graph))))))]\n    (let [newmap (merge vmap (zipmap adj (repeat (count adj) true)))\n          newqueue (concat queue (filter #(= (vmap %) false) adj))]\n      (if (.contains (vals newmap) false)\n        (if (empty? newqueue)\n          false\n          (BFS (first newqueue) graph newmap (rest newqueue))\n          )\n        true)\n)\n    )\n      )\n (first vs) (vec graph) (assoc (zipmap vs (repeat (count vs) false)) (first vs) true) [])\n      ))\n) graph) (or (= oddDeg 2) (= oddDeg 0)))))", "user": "5772ddb0e4b0979f896515d4"}, {"problem": 89, "code": "(fn __ [l]\n      (let [dn (distinct (flatten l))\n      \t    dl (distinct l)\n\t    edeg (not (some odd? (vals (frequencies (flatten dl)))))]\n\t    (if (= (count dl) 1)\n\t    \ttrue\n\t    (loop [cedge (first l)\n\t    \t   cl (rest l)\n\t    \t   accnds (distinct cedge)]\n\t\t   (if (empty? cl)\n\t\t      (and edeg (= (count dn) (count accnds)))\n\t\t      (if (or (some #(= % (first cedge)) accnds)\n\t\t      \t      (some #(= % (second cedge)) accnds))\n\t\t\t      (recur (first (remove #(= % cedge) cl))\n\t\t\t      \t     (remove #(= % cedge) cl)\n\t\t\t\t     (distinct (into accnds cedge)))\n\t\t\t      (recur [] [] [])))))))", "user": "52747090e4b03e8d9a4a74a5"}, {"problem": 89, "code": "(fn graphTour [graph]\n  (if (and (apply distinct? (map set graph)) (not-any? #(= (first %) (last %)) graph))\n    (let [degrees (group-by identity (flatten graph))\n          oddvertices (count (filter odd? (map count (vals degrees))))]\n      (or (= 0 oddvertices) (= 2 oddvertices)))\n    false\n    ))", "user": "57131dfbe4b07c98581c3a98"}, {"problem": 89, "code": "(fn [s]\n  (let [ss (set s)\n        rm (fn [c p] (remove #(= p %) c))\n        seqcontain (fn [c p]\n                     (or (= (first c) (last p)) (= (last c) (first p)) (= (last c) (last p))))]\n    (if (not= (count ss) (count s)) false\n      (loop [p (rest s) r [(first s)]]\n        (let [inter (filter #(seqcontain % (last r)) p)]\n          (if (empty? inter) (empty? p)\n            (recur (rm p (first inter)) (concat r [(first inter)])\n                   )))))))", "user": "574abbfbe4b02ea114799200"}, {"problem": 89, "code": "(fn tour\n  ([edges]\n   (tour edges (-> edges first first)))\n  ([edges node]\n   (if (seq edges)\n     (let [{reachable   true\n            unreachable false} (group-by #(boolean ((set %) node)) edges)]\n       (or (some (fn [n]\n                   (let [a (take n reachable)\n                         [b & c] (drop n reachable)\n                         [dst] (or (seq (remove #{node} b)) [node])]\n                     (tour (concat a c unreachable) dst)))\n                 (range (count reachable)))\n           false))\n     true)))", "user": "4f5599dfe4b0a7574ea71806"}, {"problem": 89, "code": "(fn [g]\n  (letfn [(is-connected [g]\n                        (let [flyd (fn f [r]\n                                     (letfn [(p [r]\n                                                (let [s (for [x r \n                                                              y r \n                                                              :when (= (second x) (first y))] \n                                                          [(first x) (second y)])]\n                                                  (into r s)))]\n                                       (let [s (p r)]\n                                         (if (= r s)\n                                           r\n                                           (f s)))))]\n                          (let [n (count (set (apply concat g)))\n                                g (into g (map #(reverse %) g))\n                                m (count (flyd g))]\n                            (= m (* n n)))))\n          (has-euler [g]\n                     (let [v (into (set (map #(first %) g)) (map #(second %) g))\n                           e (map (fn [i] (filter #(or (= i (first %)) (= i (second %))) g)) v)\n                           a (count (filter odd? (map count e)))]\n                       (println e)\n                       (or (zero? a) (= 2 a))))]\n    (and (is-connected (set g)) (has-euler g))))", "user": "5799ff45e4b05b1deef9add1"}, {"problem": 89, "code": "(fn myf [coll]\n  (let [all (->> (remove #(= (first %) (second %)) coll)\n              flatten\n              (group-by identity)\n              vals\n              (map count))\n        odd (filter odd? all)\n        even (filter even? all)]\n    (cond (empty? all) false\n          (empty? odd) true\n          (= 2 (count odd)) true\n          :else false)))", "user": "577c3da9e4b0c8d87281f6b9"}, {"problem": 89, "code": "(fn [edges]\n  (let [\n    maps (map #(list (hash-map (first %) (rest %)) (hash-map (last %) (butlast %))) edges)\n    all (apply merge-with concat (flatten maps))]\n    (or (= 1 (count edges)) (every? even? (map #(count (distinct (val %))) all)))))", "user": "560331dee4b04bb52996e1b5"}, {"problem": 89, "code": "(fn can-tour?\n   ([graph] (reduce (fn [can-visit? tuple]\n                      (or can-visit?\n                          (can-tour? tuple (let [[n m] (split-with (partial not= tuple) graph)] (concat n (rest m))))))\n                    false graph))\n   ([current-node graph]\n    (println current-node  graph)\n    (if (empty? graph)\n      true\n      (reduce\n        (fn [can-visit? tuple]\n          (or can-visit?\n              (can-tour? (if (= (first tuple) \n                                (second current-node)) \n                           tuple \n                           (reverse tuple))\n                         (let [[n m] (split-with (partial not= tuple) graph)] (concat n (rest m))))))\n        false\n        (filter (fn [t]\n                  (or (= (first t) (second current-node))\n                      (= (second t) (second current-node)))) graph)))))", "user": "4e9ff8d0535d7eef3080729c"}, {"problem": 89, "code": "(fn t?\n  ([edges]\n   (let [pts (set (apply concat edges))]\n     (->> pts\n          (map #(t? edges [%]))\n          (some boolean)\n          boolean)))\n  ([remaining done]\n   (println remaining done)\n   (if (empty? remaining) true\n     (let [end (last done)\n           rm #(let [i (.indexOf %1 %2)]\n                 (concat (take i %1) (drop (inc i) %1)))\n           other #(first (rm %1 %2))]\n       (->> (set remaining)\n            (filter #(contains? (set %) end))\n            (map #(t? (rm remaining %)\n                      (conj done (other % end))))\n            (some boolean))))))", "user": "57a0b341e4b0c3d858beb8d4"}, {"problem": 89, "code": "(fn graph-tour [edges]\n  (let [nodes (into #{} (apply concat edges))\n        num-edges (count edges)\n        adjacency-mat\n        (reduce (fn [mat [a b :as edge]]\n                  (-> (update-in mat [a] conj (set edge))\n                      (update-in [b] conj (set edge))))\n                (into {} (map vector nodes (repeat #{})))\n                edges)\n        walk\n        (fn walk [visited node]\n          (lazy-seq\n            (let [edges     (adjacency-mat node)\n                  unvisited (clojure.set/difference edges visited)]\n              (cond\n                (= (count visited) num-edges) (list true)\n                (empty? unvisited)            (list nil)\n                :else\n                (mapcat #(walk (conj visited %) \n                               (first (disj % node))) unvisited)))))]\n    (boolean (some true? (walk #{} (ffirst edges))))))", "user": "571c2babe4b07c98581c3b73"}, {"problem": 89, "code": "(fn [g]\n  (letfn [\n          (make-edges [g]\n            (filter (fn [[x y]] (not= x y))  g))\n          \n          (next-edge [es n]\n            (first (filter (fn [[x y]] (or (= x n) (= y n))) es)))\n          \n          (remove-edge [es e]\n            (if (empty? es)\n              es\n              (let [x (first es)\n                    xs (into [] (rest es))]\n                (if (= x e)\n                  xs\n                  (remove-edge (conj xs x) e)))))\n          \n          (next-node [[x y] n]\n            (if (= x n) y x))\n          \n          (eval-graph [es n]\n            (if (empty? es) \n              true\n              (let [e (next-edge es n)]\n                (if (nil? e)\n                  false\n                  (eval-graph (remove-edge es e) (next-node e n))))))]\n    \n    (let [es (make-edges g) \n          n (first (first g))]\n      (if (empty? es)\n        false\n        (eval-graph es n)))))", "user": "57d9bca1e4b0bd073c202405"}, {"problem": 89, "code": "(fn f \n  ([[h & t :as s]] (f [h] s))\n  ([i s]\n    (let [[l r] ((juxt ffirst (comp last last)) i)\n          g (some (fn [[x y :as e]]\n                  (cond (= r x) `[~@i ~e]\n                        (= r y) `[~@i ~[y x]]\n                        (= l y) `[~e ~@i]\n                        (= l x) `[~[y x] ~@i]\n                        :else nil))\n           (remove (into `#{~@i} (map (comp vec rseq) i)) s))]\n      (if g (recur g s) (apply = (map count [i s])) ))))", "user": "548b7db8e4b0e286459a11fd"}, {"problem": 89, "code": "(fn tour [graph]\n  (let [nodes (set (flatten graph))\n        incident_grades (map (fn [x] (reduce #(+ %1 (if (or (= x (first %2)) (= x (second %2))) 1 0)) 0\n                                             graph)) nodes)\n        odd_nodes_are_0_or_2 (let [odd_nodes (count (filter #(odd?  %) incident_grades))]\n                               (or (= 0 odd_nodes) (= 2 odd_nodes)))\n        is_connected_a_graph? (loop [current [(first graph)] r (rest graph)]\n                                (let [a (first (first r)) \n                                      b (second (first r))\n                                      connection (some #(or (= (first %) a) (= (second %) a)\n                                                            (= (first %) b) (= (second %) b)) current)]\n                                  (cond \n                                    (empty? r) true\n                                    (not connection) false\n                                    :else (recur (conj current (first r)) (rest r)))))]\n    (and is_connected_a_graph? odd_nodes_are_0_or_2)))", "user": "57df309ee4b0bd073c20245f"}, {"problem": 89, "code": "(fn [graph]\n (letfn [(walk [node edge]\n          (cond\n           (and (= node (ffirst edge)) (> (second edge) 0)) (second (first edge))\n           (and (= node (second (first edge))) (> (second edge) 0)) (ffirst edge)\n           :else nil))\n         (complete? [edgeset]\n           (every? #(= 0 (second %)) edgeset))]\n  (let [nodeset (set (flatten graph))\n        edgeset (frequencies graph)]\n   (loop [remain (for [n nodeset e edgeset :when (not (nil? (walk n e)))]\n                  [(update-in edgeset [(first e)] #(dec %)) (walk n e)])]\n    (let [nextremain (for [[es n] remain e es :when (not (nil? (walk n e)))]\n                      [(update-in es [(first e)] #(dec %)) (walk n e)])]\n     (cond\n       (some #(complete? (first %)) remain) true\n       (empty? nextremain) false\n       :else (recur nextremain)))))))", "user": "57dd47f4e4b0bd073c20243e"}, {"problem": 89, "code": "(fn eulers-path? [graph]\n  (let [connected? (fn [graph]\n    (let [nodes (set (flatten (seq graph)))]\n      (loop [previous #{} connected (set (first graph))]\n        (if (= nodes connected) true\n            (if (= connected previous) false\n              (recur connected (into connected\n                                     (mapcat #(if (or (contains? connected (first  %))\n                                                    (contains? connected (second %)))\n                                                % ()) graph))))))))]\n  (and (connected? graph)\n    (case (count (filter #(odd? (second %)) (frequencies\n                                             (flatten  graph))))\n      (0 2) true\n      false)) ))", "user": "579d9601e4b05b1deef9ae18"}, {"problem": 89, "code": "(fn \n  ([c]\n   (let [v (filter #(not= (first %) (second %)) c)\n         n (group-by identity (flatten v))\n         b (group-by #(even? (count (val %))) n)]\n     (and \n       (<= (count (b false)) 2)\n       (> (count v) 0)))))", "user": "576df252e4b0979f8965156f"}, {"problem": 89, "code": "(fn [g]\n  (if (some (fn [[a b]] (= a b)) g)\n    false\n    (let [f (count (keep\n                     (fn [[k v]]\n                       (or (odd? v) nil))\n                     (frequencies (flatten (map sort g)))))]\n      (or (= f 0) (= f 2)))))", "user": "52bacfa8e4b07a9af57922d6"}, {"problem": 89, "code": "(fn eulerian? [edges]\n  (letfn [(balanced? [[a bs]] (even? (count bs)))\n    (flip-edges [xs] (map (fn [[a b]] [b a]) xs))\n          (nodes-build [ys]\n            (reduce (fn [m [k v]] (assoc m k (conj (get m k #{}) v)))\n            {} ys))\n    (graph-conn? [edgs]\n      (let [es (seq edgs)\n            ed-dups-sorted (sort (concat es (flip-edges es)))\n            m-nodes (nodes-build ed-dups-sorted)\n            full-node-set (set (keys m-nodes))]\n        (letfn [(group-for [n]\n                (loop [acc #{n} nxt (get m-nodes n)]\n                  (if (empty? nxt)\n                    acc\n                    (let [neu-nxt\n                           (clojure.set/difference\n                             (apply clojure.set/union\n                                    (map #(get m-nodes %) nxt))\n                             acc)]\n                      (recur (into acc nxt) neu-nxt)))))]\n          (let [group-one (group-for (first full-node-set))\n                extra-nodes (clojure.set/difference full-node-set group-one)]\n            (empty? extra-nodes) ))))]\n    (let [dup-sorted (sort (concat edges (map (fn [[a b]] [b a]) edges)))\n          fst-edg (first dup-sorted)\n          nodes (reduce\n                  (fn [acc [a b]]\n                    (if (= a (first (peek acc)))\n                      (conj (pop acc) [a (conj (second (peek acc)) b)])\n                      (conj acc [a [b]])))\n                  [[(first fst-edg) [(second fst-edg)]]]\n                  (rest dup-sorted))\n          all-balanced? (every? balanced? nodes)]\n      (or (= 1 (count edges)) (and all-balanced? (graph-conn? edges))) )))", "user": "57f9011ee4b0d3187e900935"}, {"problem": 89, "code": "(fn [edge-list]\n  (let [graph (apply merge-with \n                #(into %1 %2) \n                (apply concat \n                  (map-indexed \n                    (fn [i [k v]] \n                      [{k #{{:node v :index i}}} \n                       {v #{{:node k :index i}}}]) \n                    edge-list)))]\n    (if (some\n          (fn [node] \n            (some \n              identity \n              (flatten \n                ((fn visit [n vs] \n                   (if (every? #(vs (:index %)) (graph n)) \n                     (if (every? identity vs) true false) \n                     (for [x (graph n)] \n                       (when-not (vs (:index x)) \n                         (visit (:node x) (assoc vs (:index x) true))))))\n                 node (vec (repeat (count edge-list) false)))))) \n          (set (apply concat edge-list))) \n      true false)))", "user": "54d000c7e4b018d918be98d7"}, {"problem": 89, "code": "(fn [g]\n          (let [g*    (map set g)\n                v     (set (flatten g))\n                deg   (fn [v]\n                        (count (filter #(contains? % v) g*)))\n                degs  (map deg v)\n                n     (count (filter odd? degs))\n                conn? (fn [edges]\n                        (= (set (apply concat edges))\n                           (loop [vs #{(ffirst edges)}]\n                             (if-let [nvs (seq (for [[a b] edges :when (and (vs a) (not (vs b)))] b))]\n                               (recur (into vs nvs))\n                               vs))))]\n            (and\n             (conn? g)\n             (or\n              (= n 2)\n              (= n 0))             \n             )))", "user": "500d3160e4b05f7c30cfa6a1"}, {"problem": 89, "code": "(fn edge-graph-tour?\n  [edges]\n  (let [remove-first\n        (fn [vec item]\n          (loop [[h & t] vec\n                 accum []]\n            (if (= h item)\n              (into accum t)\n              (recur t (conj accum h)))))]\n    (let [advance\n          (fn [[node remaining]]\n            (let [candidates\n                  (filter (fn [[l r]] (or (= node l) (= node r)))\n                          remaining)]\n              (map (fn [[l r]] \n                     (if (= node l)\n                       [r (remove-first remaining [l r])]\n                       [l (remove-first remaining [l r])]))\n                   candidates)))]\n      (loop [candidates (into #{}\n                              (map (fn [node] [node edges]) \n                                   (flatten edges)))]\n        (if (empty? candidates) false\n            (if (some (fn [[node remaining]] (empty? remaining))\n                      candidates)\n              true\n              (recur (into #{} (mapcat advance candidates)))))))))", "user": "58152157e4b0f478707a0631"}, {"problem": 89, "code": "(fn [graph]\n  (letfn [(update [m k f]\n            (assoc m k (f (get m k))))\n          (adjacency-map [m [k v]]\n            (let [k-to-v\n                  (update m k (partial cons v))]\n              (if (not= k v)\n                (update k-to-v v (partial cons k))\n                k-to-v)))\n          (connected? [edges]\n            (letfn [(grow-paths [edges]\n                      (let [[edge & more] (seq edges)]\n                        (reduce path-to #{edge} more)))\n                    (path-to [a b]\n                      (let [ab (concat (distinct (first a))\n                                       (distinct b))]\n                        (if (apply distinct? ab)\n                          (conj a b)\n                          (conj (rest a) (distinct ab)))))\n                    (both-count-neq? [[x y]]\n                      (not= (count x) (count y)))]\n              (->> edges\n                (iterate grow-paths)\n                (partition 2)\n                (drop-while both-count-neq?)\n                ffirst\n                count\n                (= 1))))]\n    (let [edges (reduce adjacency-map {} graph)\n          degrees (map count (vals edges))\n          odd-degrees (count (filter odd? degrees))]\n      (and (connected? graph)\n           (or (= 0 odd-degrees)\n               (= 2 odd-degrees))))))", "user": "57f0f7b8e4b0bfb2137f5bfe"}, {"problem": 89, "code": "(fn my-graph-tour [edges]\n  (letfn \n    [(fit-euler-rule? [g]\n        (->> (flatten g)\n             (frequencies)\n             (filter #(= 1 (mod (val %) 2)))\n             (count)\n             (#(or (= 2 %) (= 0 %)))))\n     (is-connected? [init edge-set]\n        (if (empty? edge-set) \n            true\n            (let [take-one\n                   (->> edge-set\n                        (filter #(not-empty (clojure.set/intersection init %)))\n                        (first))]\n               (if (nil? take-one)\n                   false\n                   (recur (into init take-one)\n                          (clojure.set/difference edge-set (hash-set take-one)))))))]\n    (and (fit-euler-rule? edges)\n         (is-connected? (set (first edges))\n                        (set (map set (rest edges)))))))", "user": "581b19e7e4b04b46fc4b0ec4"}, {"problem": 89, "code": "(fn eulirean\n  [edges]\n  (letfn [(construct-graph\n    [input]\n    (loop [graph {}, edges input]\n      (if (empty? edges)\n        graph\n        (let [cur (first edges), a (first cur), b (last cur)]\n          (let [new-vals (map\n                           #(conj (or (get graph (first %)) #{}) (last %))\n                           [[a b] [b a]])]\n            (recur (assoc (assoc graph a (first new-vals)) b (second new-vals))\n                   (rest edges)))\n          ))))\n          (dfs-con?\n          [graph]\n          (loop [visited #{}, x (ffirst graph), stack '()]\n            (if (nil? x)\n              (= (count visited) (count graph))\n              (let [children (get graph x)]\n                (println \"children\" children)\n                (let [filtered (filter #(not (contains? visited %)) (get graph x))]\n                  (println \"filtered\" filtered)\n                  (let [stack2 (reduce #(conj %1 %2) stack filtered)]\n                    (println \"stack2\" stack2)\n                    (let [visited2 (conj visited x)]\n                      (println \"visited2\" visited2)\n                      (recur visited2 (first stack2) (rest stack2)))))\n                )\n              )\n            )\n          )\n          (even-degrees?\n            [edges]\n            (#(or (= % 0) (= % 2)) (count (filter odd? (vals (frequencies (flatten edges)))))))\n     ]\n  \t(let [g (construct-graph edges)]\n    \t(and (even-degrees? edges) (dfs-con? g)))))", "user": "5545477fe4b0a04f79299531"}, {"problem": 89, "code": "(fn tour?[edges]\n  (letfn [(connected? [edges]\n            (let [edges (shuffle (vec edges))]\n              (letfn [(connected?[[x y]]\n                        \"Does an edge connect two nodes?\"\n                        (not-empty (clojure.set/intersection (set  x) (set y))))\n\n                      (any-connections? [edges]\n                        \"Can any of the nodes we have connect up?\"\n                        (some connected?\n                              (for [x edges\n                                    y edges\n                                    :when (not= x y)]\n                                [x y])))]\n\n                (let [[h t & r] edges]\n                  (cond\n                    (= 1 (count edges)) true\n                    (not (any-connections? edges)) false\n                    :else (if (connected? [h t])\n                            (recur (concat [(into h t)] r))\n                            (recur (concat [t] r [h]))))))))]\n    (let [odd_count (->> (set (flatten edges))\n                         (map (fn [v] (count (filter (fn [e] (= e v))(flatten edges)))))\n                         (map odd?)\n                         (filter identity)\n                         count)]\n      ;; An undirected graph has an Eulerian trail if and only if exactly zero or\n      ;; two vertices have odd degree, and if all of its vertices with nonzero\n      ;; degree belong to a single connected component.\n      (and (connected? edges)\n           (or (= 2 odd_count) (zero? odd_count))))))", "user": "56069006e4b08b23635d3174"}, {"problem": 89, "code": "(fn [edges]\n  (let [graph (->> edges\n                   (map (fn [[u v]] (assoc {} u {v 1} v {u 1})))\n                   (apply merge-with (partial merge-with +)))]\n    (loop [states [{:node        (ffirst edges)\n                    :local-graph {}}]]\n      (cond\n        (empty? states)\n        false\n\n        (some (comp #{graph} :local-graph) states)\n        true\n\n        :else\n        (recur (mapcat (fn [{:keys [node local-graph]}]\n                         (for [node' (keys (graph node))\n                               :when (< (or (get-in local-graph [node node']) 0)\n                                        (get-in graph [node node']))]\n                           {:node        node'\n                            :local-graph (-> local-graph\n                                             (update-in [node node'] (fnil inc 0))\n                                             (update-in [node' node] (fnil inc 0)))}))\n                       states))))))", "user": "55f2e47de4b06e875b46ce4d"}, {"problem": 89, "code": "(fn [g]\n    (letfn [(d [g]\n              (apply merge-with + {} (for [[a b] g\n                                           :when (not= a b)]\n                                       {a 1 b 1})))]\n      (and\n       (not (empty? (d g)))\n       (->> (vals (d g)) (filter odd?) count (>= 2)))))", "user": "55c5b55fe4b0e31453f649b5"}, {"problem": 89, "code": "(fn walkGraph [graph] (letfn [\n                                (addVisited [visited edge] (conj (conj visited edge) [(second edge) (first edge)]))\n                                (getCandidates [node unvisited] (filter (fn [x] (some #(= node %) x)) unvisited))\n\n                                (getUnvisited [graph visited] (filter #(not (contains? visited %)) graph))\n\n                                (nextNode [edge prevNode] (if (= (first edge) prevNode) (second edge) (first edge)))\n                                (tryCandidate [node graph visited] (let [unvisisted (getUnvisited graph visited)]\n                                                                          (loop [todo (getCandidates node unvisisted)] (cond\n                                                                                                                         (empty? unvisisted) true\n                                                                                                                         (empty? todo) false\n                                                                                                                         (tryCandidate (nextNode (first todo) node) graph (addVisited visited (first todo))) true\n                                                                                                                         :else (recur (rest todo))\n                                                                                                                         )\n                                                                                                                       )))\n                                ]\n\n                          (if (not (= (count graph) (count (into #{}(map #(into #{} %) graph)))))\n                            false\n                            (tryCandidate (first (first graph)) graph #{(first graph)})\n                            )))", "user": "56427910e4b08d4f616f5f19"}, {"problem": 89, "code": "(fn [edges]\n  (let [nodes (->> edges\n                   (map (fn [[a b]] (merge {a #{b}} {b #{a}})))\n                   (apply merge-with clojure.set/union))\n        passed (atom #{})]\n    (letfn [(go [[from to :as edge] n]\n              (when-not (@passed (set edge))\n                (or (= n (count edges))\n                    (do (swap! passed conj (set edge))\n                        (some #(go [to %] (inc n)) (nodes to))))))]\n      (->> (for [edge edges]\n             (do (reset! passed #{})\n                 (go edge 1)))\n           (some identity)\n           boolean))))", "user": "583e27e2e4b089d5ab817daa"}, {"problem": 89, "code": "(fn graph-tour [edges]\n  (letfn [(drop-1 [coll entry]\n            (loop [res []\n                   coll-rest coll]\n              (if (empty? coll-rest)\n                res\n                (if (= (first coll-rest) entry)\n                  (concat res (rest coll-rest))\n                  (recur (conj res (first coll-rest)) (rest coll-rest))))))\n          (walk [connected-edges edges]\n            (if (empty? edges)\n              true\n              (let [header (first connected-edges)\n                    tailor (last connected-edges)\n                    pre-edges (filter #(or (= (first %) (first header))\n                                           (= (second %) (first header)))\n                                      edges)\n                    post-edges (filter #(or (= (first %) (second tailor))\n                                            (= (second %) (second tailor)))\n                                       edges)]\n                (cond\n                  ((complement empty?) post-edges) (loop [status false\n                                                          rest-edges post-edges]\n                                                     (cond\n                                                       (= status true) true\n                                                       (empty? rest-edges) false\n                                                       :else (let [e1 (first rest-edges)\n                                                                   e2 (if (= (second tailor) (first e1))\n                                                                        e1\n                                                                        [(second e1) (first e1)])]\n                                                               (recur (walk (conj connected-edges e2)\n                                                                            (drop-1 edges e1))\n                                                                      (rest rest-edges)))))\n                  ((complement empty?) pre-edges) (loop [status false\n                                                         rest-edges pre-edges]\n                                                    (cond\n                                                      (= status true) true\n                                                      (empty? rest-edges) false\n                                                      :else (let [e1 (first rest-edges)\n                                                                  e2 (if (= (first header) (second e1))\n                                                                       e1\n                                                                       [(second e1) (first e1)])]\n                                                              (recur (walk (cons e2 connected-edges)\n                                                                           (drop-1 edges e1))\n                                                                     (rest rest-edges)))))\n                  :else false))))]\n  (walk [(first edges)] (rest edges))))", "user": "585e2e77e4b0f14aab7c87ac"}, {"problem": 89, "code": "(fn [pairs]\n  (let [node-counts (-> pairs\n                        flatten\n                        frequencies\n                        vals)\n        connected? (fn connected? [p p']\n                     (->> [p p']\n                          (map distinct)\n                          (map set)\n                          (apply clojure.set/intersection)\n                          ((complement empty?))))\n        clusters (loop [input pairs, output #{}]\n                   (if (empty? input)\n                     output\n                     (let [pair (first input)\n                           belongs? (fn [pair pairs]\n                                      (some #(connected? % pair) pairs))\n                           groups (group-by #(belongs? pair %) output)\n                           output' (conj (groups nil)\n                                         (apply clojure.set/union (conj (groups true) #{pair})))]\n                       (recur (set (next input))\n                              output'))))]\n   (and\n     (= 1 (count clusters))\n     (->> node-counts\n          (filter odd?)\n          count\n          (contains? #{0 2})))))", "user": "58247423e4b051871117bec5"}, {"problem": 89, "code": "(letfn [(partition-grps [xs]\n          (reduce (fn [a [p q]]  \n                    (let [p-grps (group-by #(% p) a)\n                          q-grps (group-by #(% q) (p-grps nil))\n                          pq-grp (concat (cons p (apply clojure.set/union (p-grps p))) \n                                         (cons q (apply clojure.set/union (q-grps q))))]\n                      (cons (set pq-grp) (q-grps nil)))) #{} xs))]\n  (fn [xs] \n    (let [edge-counts (map second (frequencies (flatten xs)))\n          edges-ok (contains? #{0 2} (count (filter odd? edge-counts)))\n          single-graph (= (count (partition-grps xs)) 1)]\n      (and edges-ok single-graph))))", "user": "5884e807e4b0f1effa3b76a6"}, {"problem": 89, "code": "(fn [edges]\n  (let [vertices (into #{} (flatten edges))\n        get-adjacent (fn [start edges]\n                       (for [[a b] edges :when (or (= a start) (= b start))]\n                         (let [[head tail] (split-with (partial not= [a b]) edges)]\n                           [(if (= a start) b a) (concat head (rest tail))])))\n        tour? (fn tour? [[start remaining]]\n               (if (empty? remaining) true\n                 (some tour? (get-adjacent start remaining))))]\n    (boolean (some tour? (map vector vertices (repeat edges))))))", "user": "586615e6e4b0f14aab7c8858"}, {"problem": 89, "code": "(fn [s]\n  (let [vertices (set (apply clojure.set/union s))\n        extend (fn [[v edges]]\n                 (letfn [(remove-first [x s]\n                           \"Remove first occurrence of x in s\"\n                           (let [[u v] (split-with #(not= x %) s)]\n                             (concat u (rest v))))]\n                   (for [[x y] (filter #((set %) v) edges)]\n                     [(if (= v x) y x) (remove-first [x y] edges)])))]\n        (not (empty? (nth (iterate #(mapcat extend %) (for [v vertices] [v s])) (count s))))))", "user": "58a0fc33e4b02bd94d917ea3"}, {"problem": 89, "code": "(letfn [(expand [paths]\n          (for [{:keys [path remaining-edges] :as m} paths\n                :let [f #{(peek path)}]\n                unvisited (filter (fn [edge] (some f edge)) remaining-edges)\n                :let [n (first (remove f unvisited))\n                      [a b] (split-with (complement #{unvisited}) remaining-edges)]]\n            (-> m\n                (update-in [:path] conj n)\n                (assoc :remaining-edges (into a (rest b))))))]\n  (fn [edges]\n    (let [vertices (distinct (flatten edges))\n          starts (map (fn [p] {:path [p] :remaining-edges edges}) vertices)]\n      (not= nil (not-empty (nth (iterate expand starts) (count edges)))))))", "user": "57b3efb1e4b0fbc9809a278a"}, {"problem": 89, "code": "(fn tour? [edges]\n\t(letfn [(present? [tuple element]\n\t\t\t  (true? (some #(= element %) tuple)))\n\t\t\t(next-edges [node all-edges visited]\n\t\t\t  (filter #(not (or (contains? visited %) (contains? visited (reverse %))))\n\t\t\t\t\t  (filter #(present? % node)\n\t\t\t\t\t\t\t  all-edges)))\n\t\t\t(next-node [node edge]\n\t\t\t  (if (= (first edge) node)\n\t\t\t\t  (second edge)\n\t\t\t\t  (first edge)))\n\t\t\t(traverse [node edge all-edges visited]\n\t\t\t  (let [updated-visited (conj visited edge)\n\t\t\t\t\tnext (next-edges node all-edges updated-visited)]\n\t\t\t\t  (if (empty? next)\n\t\t\t\t\t  (= (count updated-visited) (count all-edges))\n\t\t\t\t\t  (some #(traverse (next-node node %) % all-edges updated-visited) next))))]\n\n\t\t(true? (some #(traverse (second %) % edges (hash-set %)) edges))))", "user": "525d44bfe4b0cb4875a45d6d"}, {"problem": 89, "code": "(fn euler-trail? [graph]\n  (letfn [(connected-edge? [n e]\n            (or (= (first e) n) (= (second e) n)))\n          (follow [n e graph]\n            (let [until (take-while #(not= e %) graph)\n                  next-node (if (= n (first e)) (second e) (first e))]\n              (list next-node\n                    (into [] (concat until (drop (inc (count until)) graph))))\n              )\n            )\n          (visited-all? [n graph]\n            (let [connected-edges (filter #(connected-edge? n %) graph)]\n              (cond (empty? graph) true\n                    (empty? connected-edges) false\n                    :else (some true?\n                                (map (fn [e] (apply visited-all? (follow n e graph))) connected-edges)))\n              )\n            )\n          ]\n    (let [nodes (into #{} (flatten graph))]\n      (boolean (some true? (map #(visited-all? % graph) nodes)))\n      )\n    )\n  )", "user": "589037b4e4b00487982d51d0"}, {"problem": 89, "code": "(fn graph-tour [edges]\n  (let [connected-graph?\n        (fn [edges]\n          (let [in-component? (fn [component edge] (some #(contains? component %) edge))\n                containing-components (fn [cs edge] (filter #(in-component? % edge) cs))\n                components (reduce (fn [cs edge]\n                                     (if-let [ccs (not-empty (containing-components cs edge))]\n                                       (-> (apply disj cs ccs)\n                                           (conj (apply clojure.set/union (cons (set edge) ccs))))\n                                       (conj cs (set edge))))\n                                   #{} edges)]\n            (= 1 (count components)))) \n        nodes (set (apply concat edges))\n        node-degrees (frequencies (apply concat (map set edges)))\n        odd-degrees (count (filter odd? (vals node-degrees)))]\n    (and (connected-graph? edges) (or (= odd-degrees 0) (= odd-degrees 2)))))", "user": "5879d577e4b01531a375ead8"}, {"problem": 89, "code": "(fn\n  [edges]\n  (let [get-except (fn [coll i] (into (take i coll) (rest (drop i coll))))\n        traverse-multiple (fn temp [[e11 e12] es]\n                            (if (empty? es)\n                              true\n                              (map-indexed (fn [i [e21 e22]]\n                                             (let [es-except-i (get-except es i)]\n                                               (cond\n                                                 (= e11 e21) (temp [e22 e12] es-except-i)\n                                                 (= e11 e22) (temp [e21 e12] es-except-i)\n                                                 (= e12 e21) (temp [e11 e22] es-except-i)\n                                                 (= e12 e22) (temp [e11 e21] es-except-i)\n                                                 :default false)))\n                                           es)))]\n    (true? (some true? (flatten (map-indexed (fn [i e] (traverse-multiple e (get-except edges i))) edges))))))", "user": "57625c18e4b0994c1922fba4"}, {"problem": 89, "code": "(fn [edges]\n  (let [edge-set (into (set edges) (map (fn [[x y]] [y x]) edges))\n        expected-count (* 2 (count edges))\n        actual-count (count edge-set)\n        traverse (fn t [edges [x y]]\n              (let [e (disj edges [x y] [y x])]\n                (if (empty? e)\n                  true\n                  (let [paths (filter (fn [[a _]] (= a y)) e)]\n                    (if (empty? paths)\n                      false\n                      ((comp boolean some) true? (map #(t e %) paths)))))))]\n    (if (not= expected-count actual-count)\n      false\n      ((comp boolean some) true? (map #(traverse edge-set %) edge-set)))))", "user": "4f037faf535dcb61093f6af8"}, {"problem": 89, "code": "(fn [xs]\n  (and\n    (->> xs\n      (apply concat)\n      frequencies\n      vals\n      (filter odd?)\n      count\n      (>= 2))\n    (->> xs\n      (reduce\n        (fn [m [x y]]\n          (let [s (-> #{} (into [x y]) (into (m x)) (into (m y)))]\n            (into m (map vector s (repeat s)))))\n        {})\n      vals\n      set\n      count\n      (>= 1))))", "user": "50479524e4b0371827a27bc4"}, {"problem": 89, "code": "(fn [coll]\n  ((complement empty?)\n     (nth (iterate\n           (fn [ps]\n             (mapcat (fn [[p l]]\n                       (->> (range (count l))\n                            (map #(take (count l) (drop % (cycle l))))\n                            (map #(let [[u v] (last p) [x y] (first %)]\n                                    (vector (cond (= v x) (conj p [ x y])\n                                                  (= v y) (conj p [y x])\n                                                  :else (conj p nil))\n                                            (rest %))))\n                            (filter #(last (first %)))))\n                     ps))\n           (->>  (range (count coll))\n                 (map #(take (count coll) (drop % (cycle coll))))\n                 (mapcat #(vector (vector [(first %)] (rest %))\n                                  (vector [(reverse (first %))] (rest %))))))\n          (dec (count coll)))))", "user": "58ca8a1de4b03c36ff7e5835"}, {"problem": 89, "code": "(fn [es]\n  (let [es (filter (fn [[x y]] (not= x y)) es)\n        g (merge-with conj (group-by first es) (group-by second es))]\n    (condp = (reduce + (map #(mod (count %) 2) (vals g)))\n      0 (not (empty? g))\n      2 true\n      false)))", "user": "58c2df0ae4b021aa9917ed17"}, {"problem": 89, "code": "(fn [edges]\n   (let [adj-list (reduce (fn [agg [x y]]\n                            (merge-with into agg (into {} [[x #{y}] [y #{x}]]))) {}\n                          edges)\n         vs (into #{} (keys adj-list))\n         even-count? #(-> % count (mod 2) (= 0))\n         nodes-has-even-edges? (->> (vals adj-list) (every? even-count?))\n         linked-cmp (fn ch [v adj-list visited]             \n                      (if (empty? adj-list)\n                        visited\n                        (->> (for [v-adj (adj-list v)\n                                  :when (not (visited v-adj))]\n                               (ch v-adj (dissoc adj-list v) (into visited [v v-adj])))\n                             (reduce into visited))))]\n     (or (< (count edges) 2)\n     (and nodes-has-even-edges?\n          (-> vs first\n              (linked-cmp adj-list #{})\n              (= vs))))))", "user": "567d132ee4b05957ce8c61c3"}, {"problem": 89, "code": "(fn[dataset]\n      (letfn [(contains-elem? [ coll it] (some #{it} coll))\n              (not-self-edge? [[a b]] (not= a b))\n      \t      (incident-edges [edges]\n                (let [vertices (distinct (flatten edges))]\n                  (reduce (fn [m i] (assoc m i (filter (fn [coll] (contains-elem? coll i)) edges))) {} vertices)))\n              (get-degree [edges] (map count (map (fn [lst] (filter not-self-edge? lst)) (vals (incident-edges edges)))))]\n         (cond\n           (some zero? (get-degree dataset)) false\n          (contains-elem? [0 2]  (count (filter odd?  (get-degree dataset)))) true \n          :else false)))", "user": "5832be57e4b089d5ab817c86"}, {"problem": 89, "code": "(fn append-pairs \n  ([[pa :as path] [[a b :as pair] & new-pairs \n                   :as pairs] orig-pairs]\n  (if (empty? orig-pairs) true (if (empty? pairs) false\n   (let [pe (last path)\n         new-paths (keep identity (vector \n           (if (= pa a) (cons b path))\n           (if (= pa b) (cons a path))\n           (if (= pe a) (conj path b))\n           (if (= pe b) (conj path a))))] \n     (if (empty? new-paths) \n       (append-pairs path new-pairs orig-pairs) \n       (or \n        (some #(= % true) \n         (map #(append-pairs (vec %) \n           (vec (filter (partial not= pair) orig-pairs))) \n             new-paths)) \n        false))))))\n  ([path pairs] (append-pairs path pairs pairs))\n  ([[pair & rest-pairs]] (append-pairs pair rest-pairs)))", "user": "575ddfd1e4b02ea11479938d"}, {"problem": 89, "code": "(fn eulerian-path? [edge-list]\n  (letfn [(adjacency-map [edge-list]\n            (let [reverse-edge-list (set (mapcat (fn [[a b]] [[b a]]) edge-list))\n                  full-edge-list (into edge-list reverse-edge-list)]\n              (into {} (for [[vertex edges] (group-by first full-edge-list)]\n                         [vertex (set (map second edges))]))))\n          (traverse-graph-dfs [adjacency-map start-vertex]\n            (loop [vertices [] \n                   explored #{start-vertex} \n                   frontier [start-vertex]]\n              (if (empty? frontier)\n                vertices\n                (let [vertex (peek frontier)\n                      neighbors (adjacency-map vertex)]\n                  (recur\n                   (conj vertices vertex)\n                   (into explored neighbors)\n                   (into (pop frontier) (remove explored neighbors)))))))\n          (fully-connected? [edge-list]\n            (let [vertices (set (apply concat edge-list))\n                  adj-map (adjacency-map edge-list)]\n              (= (count vertices) (count (traverse-graph-dfs adj-map (first vertices))))))\n          (vertex-degrees [edge-list]\n            (apply merge-with + {} (for [[a b] edge-list\n                                         :when (not= a b)]\n                                     {a 1 b 1})))]\n    (let [degrees (vertex-degrees edge-list)\n          odd-degree-vertex-count (count (filter odd? (vals degrees)))]\n      (and\n       (fully-connected? edge-list)\n       (contains? #{0 2} odd-degree-vertex-count)))))", "user": "58ed713de4b056aecfd47d84"}, {"problem": 89, "code": "(fn graph-single-walkable?\n  [a-graph-vector]\n  (letfn [(build-graph-map [seq-of-edges]\n            (letfn [(update-graph-map [graph-map [a b]]\n                      (merge-with into graph-map (hash-map a [b])\n                                  (hash-map b [a])))\n                    (change-to-frequencies [vector-map a-key]\n                      (assoc vector-map a-key (frequencies (vector-map a-key))))\n                    ]\n              (let [vector-map  (reduce update-graph-map {} seq-of-edges)]\n                (reduce change-to-frequencies vector-map (keys vector-map)))))\n          \n          (update-graph-map  [a-graph-map origin destination]\n            (let [orig-freqs (get a-graph-map origin)\n                  dest-freqs (get a-graph-map destination)\n                  new-edge-count (dec (get orig-freqs destination))\n                  opt-assoc (fn [a-map pred k v]\n                              (if pred (assoc a-map k v) (dissoc a-map k)))\n                  new-orig-freqs (opt-assoc\n                                  orig-freqs (not (zero? new-edge-count))\n                                  destination new-edge-count)\n                  new-dest-freqs (opt-assoc\n                                  dest-freqs (not (zero? new-edge-count))\n                                  origin new-edge-count)]        \n              (-> a-graph-map\n                  (opt-assoc (seq new-orig-freqs) origin new-orig-freqs)\n                  (opt-assoc (seq new-dest-freqs) destination new-dest-freqs))))\n          (wander-edges [a-graph-map starting-point]\n            (let [options (keys (get a-graph-map starting-point))\n                  take-step (fn [option]\n                              (wander-edges\n                               (update-graph-map a-graph-map starting-point option)\n                               option))]\n              (cond\n                (empty? a-graph-map) true\n                (nil? options) false\n                :else (some true? (map take-step options)))))\n          ]\n   (let [a-graph-map (build-graph-map a-graph-vector)]\n     (boolean (some (partial wander-edges a-graph-map) (keys a-graph-map))))))", "user": "580d2788e4b0849f6811b730"}, {"problem": 89, "code": "(fn [l]\n  (let [m (reduce (fn [a [k v]]\n                    (merge-with concat a {k [v]} {v [k]}))\n                  {} l)\n        k (set (keys m))]\n    (if (some (fn [[_ v]] (not= (count v) (count (set v)))) m) false\n      (loop [p (set (map vector k))]\n        (cond\n          (empty? p) false\n          (= (count k) (count (first p))) true\n          true (recur (reduce\n                        (fn [q l]\n                          (into q (reduce (fn [a e]\n                                            (if (some #{e} (get m (last l)))\n                                              (conj a (conj l e))\n                                              a))\n                                          [] (apply disj k l))))\n                        #{} p)))))))", "user": "57d9f603e4b0bd073c20240a"}, {"problem": 89, "code": "(fn graph-tour [edges]\n   (let [deg-temp (fn [node]\n               (filter (fn [x](some #(= node %) x)) edges))\n         deg (fn [node]\n               (count (remove #(= (first %) (last %)) (deg-temp node))))\n         deg-list (map #(deg %) (sort (distinct (flatten edges))))]\n     (and\n       (not (some #(= 0 %) deg-list))\n       (>= 2 (count (filter #(odd? %) deg-list))))))", "user": "58dcb8cde4b0a4d5acaab6a7"}, {"problem": 89, "code": "(fn eulerian [edges]\n  (let [degrees (fn [edges]\n                  (apply merge-with + {} (for [[a b] edges\n                                               :when (not= a b)]\n                                           {a 1 b 1})))\n        gdeg (degrees edges)]\n    (and\n     (not (empty? gdeg))\n     (->> (vals gdeg) (filter odd?) count (>= 2)))))", "user": "53dbca12e4b094d41abdfef6"}, {"problem": 89, "code": "(fn euler-trail-exists?\n  [edges]\n  (let [non-self-pointing-edges (filter (fn [[a b]] (not= a b)) edges)]\n    (if\n      (empty? non-self-pointing-edges)\n      false\n      (>= 2\n        (count\n          (filter odd?\n            (map\n              (fn [[_ l]] (count l))\n              (group-by identity (flatten non-self-pointing-edges)))))))))", "user": "5796d3ebe4b039eba2ecb0ee"}, {"problem": 89, "code": "(fn [d [h & r]]\n  ((fn f [a r]\n     (or (empty? r)\n\t (boolean\n\t  (some #(f (nth (d #{a} %) 0) (d #{%} r))\n\t\t(filter #(some #{a} %) r)))))\n   (h 1) r))\nremove", "user": "58f45ea0e4b0438e51c2cebc"}, {"problem": 89, "code": "(letfn\n    [(visit [graph [from to id]]\n       (disj (disj graph [from to id]) [to from id]))\n     (can-visit?\n       [edges from]\n       (if (empty? edges)\n         true\n         (let [next-edges (filter #(= from (first %)) edges)]\n           (if (seq next-edges)\n             (some identity\n                   (for [[from to id :as edge] next-edges]\n                     (can-visit? (visit edges edge) to)))\n             false))))]\n    (fn [edges]\n      (let [edges (->> edges (map vec) (map #(conj %2 %1) (range)))\n            redges (for [[f t id] edges] [t f id])\n            all-edges (set (concat edges redges))\n            ]\n        (boolean\n          (some identity (for [[from to id :as edge] all-edges]\n                           (can-visit? (visit all-edges edge) to)))))))", "user": "58ec1e63e4b056aecfd47d54"}, {"problem": 89, "code": "(fn [edge-coll]\n   (let [nodes (set (flatten edge-coll)) ;; \u6c42\u53d6\u6240\u6709\u7684\u8282\u70b9\n         graph (reduce (fn [init-map node]\n                         (assoc init-map\n                                node\n                                (reduce (fn [val-map [a b]]\n                                          (cond\n                                            (= a node) (conj val-map b)\n                                            (= b node) (conj val-map a)\n                                            :else val-map))\n                                        [] edge-coll))) {} nodes)\n\n         dfs-gragh (fn dfs-gragh [node visited]\n                     (reduce (fn [init-visited x]\n                               (apply conj init-visited (dfs-gragh x init-visited)))\n                             (conj visited node)\n                             (filter #(every? (fn [visited-node]\n                                                (not= visited-node %)) visited)\n                                     (get graph node))))]\n\n     (if (= nodes (dfs-gragh (first nodes) #{}))\n       (let [num (count (filter #(= 1 (mod (count (val %) ) 2)) graph))]\n         (cond\n           (= 0 num) true\n           (= 2 num) true\n           :else false))\n       false\n       )\n     ))", "user": "591072e0e4b0163c97b36ebc"}, {"problem": 89, "code": "(fn gt [v]\n    (let [sv (set (reduce (fn [s [x y]] (conj s x y)) [] v))]\n      (and (\n            ->> (reduce (fn [s [x y]] (conj s x y)) [] v)\n                frequencies\n                (filter (fn [[_ v]] (odd? v)))\n                count\n                (#(or (= 0 %) (= 2 %)))\n                )\n\n          (= sv (last (take (count sv)\n                         (iterate (fn [xs]\n                                    (reduce (fn [s [l r]]\n                                              (cond (contains? s l) (conj s r)\n                                                    (contains? s r) (conj s l)\n                                                    :else s)) xs v)) #{(first sv)}))))))\n\n    )", "user": "5921a080e4b09b4ee5954c77"}, {"problem": 89, "code": "(fn farsh\n\t[coll]\n\t(letfn [\n\t\t(transform-graph\n\t\t\t[graph]\n\t\t\t(reduce\n\t\t\t\t(fn [result [x y]] (assoc result x (conj (result x) y) y (conj (result y) x)))\n\t\t\t\t(zipmap (distinct (flatten graph)) (repeat []))\n\t\t\t\tgraph))\n\t\t(is-connected\n\t\t\t[graph]\n\t\t\t(let [vertices (keys graph)]\n\t\t\t\t(loop [stack (vector (first vertices)) visited #{}]\n\t\t\t\t\t(if (empty? stack)\n\t\t\t\t\t\t(= visited (into #{} vertices))\n\t\t\t\t\t\t(let [v (peek stack) neighbors (graph v) restStack (pop stack)]\n\t\t\t\t\t\t\t(if (visited v)\n\t\t\t\t\t\t\t\t(recur restStack visited)\n\t\t\t\t\t\t\t\t(recur (reduce #(conj %1 %2) restStack neighbors) (conj visited v))))))))\n\t\t(is-euler\n\t\t\t[graph]\n\t\t\t(->> graph\n\t\t\t\t(vals)\n\t\t\t\t(map count)\n\t\t\t\t(map odd?)\n\t\t\t\t(filter identity)\n\t\t\t\t(count)\n\t\t\t\t(> 3)))]\n\t\t(let [transformed (transform-graph coll)]\n\t\t\t(and (is-connected transformed) (is-euler transformed)))))", "user": "58fb7d7ae4b0438e51c2cf7a"}, {"problem": 89, "code": "(fn __ [es]\n  (let [\n    v_set (-> es flatten set)\n    get_con_sets\n      (fn [ss v]\n          (conj \n            (map #(if (not= () (filter % v)) (into % v) %)  ss)\n            (set v)))\n    max_con_set #(reduce (fn [s1 s2] (if (> (count s1) (count s2)) s2 s2)) #{} %)\n    all_connected? (= v_set (max_con_set (reduce get_con_sets [] es)))\n    one_path? (->> es flatten frequencies vals (filter odd?) count #{0 2} (not= nil))\n  ]\n  (and one_path? all_connected?)))", "user": "593f95d8e4b069cdc2982be3"}, {"problem": 89, "code": "(fn gt [edges]\n  (let [vc (reduce (fn [g [a b]] (assoc g a (inc (get g a 0)))) {} (concat edges (map reverse edges)))\n        g (reduce (fn [g [a b]] (assoc g a (conj (get g a #{}) b))) {} (concat edges (map reverse edges)))\n        od (count (filter odd? (vals vc)))\n        connected? (loop [queue [(first (keys g))] visited #{}]\n                          (if-let [n (first queue)]\n                                  (recur (into (subvec queue 1) (clojure.set/difference (g n) visited)) (conj visited n))\n                                  (= (count visited) (count g))))]\n                         \n       (and connected? (or (= 0 od) (= 2 od)))))", "user": "5958cef6e4b066ee0a44af94"}, {"problem": 89, "code": "(fn hamiltonian? [graph]\n  (let [current-edge\n        (fn [g e]\n          (if (or (empty? g) (empty? e)) [[] []]\n              (let [current-edge-index (.indexOf g e)\n                    next-graph (vec\n                                (concat\n                                 (subvec g 0 current-edge-index)\n                                 (subvec g (inc current-edge-index))))\n                    current-node (if (meta e) (first e) (last e))\n                    next-edge (last (filterv #(< -1 (.indexOf % current-node)) next-graph))\n                    ;; TODO some-> \n                    next-edge (if (not-empty next-edge)\n                                (if (= (first next-edge) current-node)\n                                  next-edge\n                                  (with-meta next-edge {}))\n                                next-edge)]\n                [next-graph next-edge])))]\n    (loop [[g e] (current-edge graph (first graph))]\n      (cond\n        (empty? g) true\n        (empty? e) false\n        :else (recur (current-edge g e))))))", "user": "51aefceee4b09397d5109797"}, {"problem": 89, "code": "(fn [el]\n  (let [connected? (fn connected?\n                     [edge-list]\n                     (let [nodes (fn nodes \n                                   [graph]\n                                   (set (concat (map first graph)\n                                                (map last graph))))\n\n                           connected-nodes (fn connected-nodes\n                                             [node edge-list]\n                                             (let [out (mapv last (filter (comp (partial = node) first) edge-list))\n                                                   in (mapv first (filter (comp (partial = node) last) edge-list))]\n                                               (set (concat out in))))\n                           connectables (fn connectables\n                                          ([edge-list] (connectables edge-list #{} (first (nodes edge-list))))\n                                          ([edge-list discovered node]\n                                           (let [discovered (conj discovered node)\n                                                 direct-connections (connected-nodes node edge-list)]\n                                             (reduce\n                                              (fn [discovered node]\n                                                (if (discovered node)\n                                                  discovered\n                                                  (connectables edge-list discovered node)))\n                                              discovered\n                                              (clojure.set/difference direct-connections discovered)))))\n                           node-count (count (nodes edge-list))]\n                       (= node-count (count (connectables edge-list)))))]\n    (or (= (count el) 1)\n        (and (connected? el)\n             (every? even? (vals (frequencies (apply concat el))))))))", "user": "53de7484e4b0d874e779ae35"}, {"problem": 89, "code": "(fn [g] (\n           letfn [\n                  (rev[x] (identity [(second x) (first x)]))\n                  (linked[a b] (= (second a) (first b) ))\n                  (vars[a s] (reduce #( \n                                        if (linked a %2) \n                                          (conj %1 %2) \n                                          (if (linked a (rev %2))\n                                              (conj %1 (rev %2)) \n                                              %1    \n                                              )\n                                          ) [] s))\n                  (ne[a s] (count (for [x s :while (not (or (= a x) (= (rev a) x)))] x)))\n                  (less[a s] ( #(concat (take % s) (drop (inc %) s)) (ne a s)))\n                  (lessp[p s] ( reduce #(less %2 %1) s p))\n                  \n                  \n                  (dip[s] ( map #( vars % s) s ))\n                  \n                  (edge[path s vs] (\n\n                               if (empty? s) (= 0 (count vs))\n                               (\n                                 reduce #(or %1 (edge (conj path %2) (vars %2 (less %2 vs)) (less %2 vs))) false s\n                                )\n                               ))\n                  ]\n           (= true (some true? (map #(edge [%] (vars % (less % g))  (less % g)) g)))\n\n           ))", "user": "596f6683e4b069c0a1a19877"}, {"problem": 89, "code": "(fn graph-tour\n  [graph]\n  (letfn [(neighbours [graph node]\n            (keep \n              (fn [other]\n                (when-let [matches (seq (filter (set node) other))] [matches other]))\n              graph))\n          (remove-first [pred coll]\n            (let [i (first (keep-indexed (fn [i x] (when (pred x) i)) coll))]\n              (concat (take i coll) (drop (inc i) coll))))\n          (graph-tour' [graph path]\n            (if-let [s (seq graph)]\n              (let [[x & xs] s\n                    ys (neighbours xs x)\n                    path (conj path x)]\n                (if-let [s (seq ys)]\n                  (mapcat (fn [[matches y]]\n                            (mapcat (fn [match]\n                                      (graph-tour' (cons (remove-first #{match} y) (remove-first #{y} xs)) path))\n                                    matches))\n                          s)\n                  [path]))\n              path))]\n    (not (empty? (filter \n                   #(= (count graph) (count %)) \n                   (graph-tour' graph []))))))", "user": "4dc0ff08535d020aff1edf84"}, {"problem": 89, "code": "(fn tourable? [graph]\n  (let [\n      all-nodes (distinct (flatten graph))\n      start-node (rand-nth all-nodes)\n      get-neighbours (fn [g n] (filter #(not= % nil) (distinct (for [edge g] (when (some #(= n %) edge) edge)))))\n    ]\n  \n\n    (loop [current-node start-node available-edges (get-neighbours graph current-node) tagged []]\n\n\n      (if (zero? (count available-edges))\n        (>= (count tagged) (count graph))\n        (let [target-edge (first available-edges) target-node (first (filter #(not= current-node %) target-edge)) new-tagged (conj tagged target-edge)] \n          (recur target-node (filter #(not (contains? (set new-tagged) %)) (get-neighbours graph target-node)) new-tagged)\n        )\n      )\n    \n    )\n  )\n)", "user": "5991d2fae4b0866487ed0d68"}, {"problem": 89, "code": "(fn [edges]\n    (letfn\n      [(remove-first [coll to-remove]\n         (second\n           (reduce (fn [[matched? result] e]\n                     (cond\n                       matched? [true (conj result e)]\n                       (= e to-remove) [true result]\n                       :else [false (conj result e)]))\n                   [false []] coll)))\n       (find-path [start remaining-edges]\n         (if\n           (empty? remaining-edges)\n           true\n           (reduce\n             (fn [success? [edge-start edge-end :as edge]]\n               (cond\n                 success? success?\n                 (= start edge-start)\n                 (find-path edge-end (remove-first remaining-edges edge))\n                 (= start edge-end)\n                 (find-path edge-start (remove-first remaining-edges edge))\n                 :else false))\n             false\n             remaining-edges)))]\n      (reduce\n        (fn [success? [edge-start edge-end]]\n          (or success? (find-path edge-start edges)))\n        false\n        edges)\n      ))", "user": "51e28063e4b08e53a149f0f2"}, {"problem": 89, "code": "(fn __ [graph]\n  (let [\n        vertices (reduce (fn [acc [f t]] (conj acc f t) ) #{} graph)\n        verticesCounts (reduce (fn [acc [f t]] (update-in (update-in acc [t] (fnil inc 0)) [f] (fnil inc 0)) ) {} graph)\n        oddVerticesCount (count (filter odd? (vals verticesCounts)))\n        start (set (first graph))\n        expand2Width (fn [vers edges]\n                       (reduce\n                         (fn [vers [f t]]\n                           (if (vers f)\n                             (conj vers t)\n                             (if (vers t)\n                               (conj vers f)\n                               vers)))\n                         start graph))\n        expanded (loop [\n                        reached start\n                        ]\n                   (let [\n                         reachedMore (expand2Width reached graph)\n                         ]\n                     (if (= reached reachedMore)\n                       reached\n                       (recur reachedMore))))\n        result (and (= vertices expanded) (or (= 0 oddVerticesCount) (= 2 oddVerticesCount)))\n        ]\n    result))", "user": "58bc6a88e4b0888cdc949d16"}, {"problem": 89, "code": "(fn tour [edges]\n  (let [nodes (into #{} (flatten edges))\n        has-walk? \n        (fn has-walk? [s, edges]\n          (if (empty? edges)\n            ;; the trivial walk!\n            true\n            ;; branch: try each possible connecting edge.\n            (some true?\n                  (for [i (range (count edges))\n                        :let [[a b] (nth edges i)\n                              remainder (concat (take i edges) (drop (inc i) edges))]\n                        :when (or (= s a) (= s b))]\n                    (if (= s a)\n                      (has-walk? b remainder)\n                      (has-walk? a remainder))))))]\n    ;; is there any working start-node?\n    (if (some true?\n              (for [s nodes]\n                (has-walk? s edges)))\n      true\n      false)))", "user": "569f99cce4b0542e1f8d1497"}, {"problem": 89, "code": "(fn [L]\n    (letfn [(join-component [s1 s2]\n                (clojure.set/difference (clojure.set/union s1 s2) (clojure.set/intersection s1 s2)))\n            (join-component-step [SS]\n                (if (= (count SS) 1)\n                    true\n                        (some true? (map join-component-step \n                                         (for [s1 (seq SS) s2 (seq SS) \n                                              :when (and (not= s1 s2) (not= (clojure.set/intersection s1 s2) #{}))]\n                                         (clojure.set/union #{(join-component s1 s2)} (clojure.set/difference SS #{s1 s2})) )))))\n            (path? [L] \n                 (let [S (into #{} (map #(into #{} %) L))]\n                   (if (not= (count L) (count S))\n                        false\n                       (join-component-step S))))]\n      (true? (path? L))))", "user": "56fa2905e4b07572ad1a88be"}, {"problem": 89, "code": "; Evil hack\n(fn [& _]\n  (reify Object\n    clojure.lang.IPersistentCollection\n    (seq [_])\n    (cons [_ _])\n    (empty [_])\n    (equiv [_ _] true)))", "user": "51e58e02e4b0efabf93c02d0"}, {"problem": 89, "code": "(fn graph-tour [g] \n  (letfn [\n    (connected? [s]\n      (letfn [\n          (get-children[s root ignore]\n              (clojure.set/difference \n                  (set (for [[x y] s :when (or (= root x) (= root y))] (if (= x root) y x)))\n                  ignore)\n          )\n          (build-tree [root s ignore]\n              (let [children (seq (get-children s root ignore))]\n                  (if (empty? children)\n                      root\n                      (loop [result [root] new-children children new-ignore (into ignore children)]\n                          (if (empty? new-children)\n                              result\n                              (let [subtree (conj result (build-tree (first new-children) s new-ignore))]\n                                  (recur subtree (rest new-children) (into new-ignore (flatten subtree)))\n                              )\n                          )\n                      )\n                  )\n              )    \n          )\n          ]\n          (let [root (ffirst s) tree (build-tree root s #{root}) size (->> s seq flatten set count)]\n              (= size (if (vector? tree) (->> tree flatten count) 1))\n          )\n          )    \n      )\n  ]\n    (and (connected? g)\n         (< (->> g flatten (group-by identity) (map #(count (second %))) (filter odd?) count) 3))\n  )\n)", "user": "59a0262ee4b0871e7608b82d"}, {"problem": 89, "code": "(fn [edges]\n  (letfn [(connected-to [node edges]\n            (if (seq edges)\n              (if-let [connected (seq (filter #(some #{node} %) edges))]\n                (do\n                  (mapcat (fn [[a b :as edge]]\n                           (if (= a node)\n                              (connected-to b (remove (partial = edge) edges))\n                              (connected-to a (remove (partial = edge) edges))))\n                       connected)))\n              [node]))]\n     (if (= (count edges) 1)\n       true\n       (let [final-edges (set (connected-to (first (first edges)) (rest edges)))]\n          (boolean (final-edges (second (first edges))))))))", "user": "58b51e05e4b0ebc645576d4c"}, {"problem": 89, "code": "(fn eulerian [edges]\n  (let [degrees (fn [edges]\n                  (apply merge-with + {} (for [[a b] edges\n                                               :when (not= a b)]\n                                           {a 1 b 1})))\n        gdeg (degrees edges)]\n    (and\n     (not (empty? gdeg))\n     (->> (vals gdeg) (filter odd?) count (>= 2)))))", "user": "59358f74e4b04f87174def52"}, {"problem": 89, "code": "(fn Euler [es]\n  (letfn [(adjacent [v1 m]\n                    (fn [q [a b]]\n                        (cond\n                         (and (= v1 a) (= (get m b) :unvisited)) (conj q b)\n                         (and (= v1 b) (= (get m a) :unvisited)) (conj q a)\n                         :else q)))\n          (deq [vs q]\n               (if (empty? q)\n                   vs\n                   (let [v1 (peek q)]\n                     (recur (assoc vs v1 :visited)\n                            (reduce (adjacent v1 vs) (pop q) (into '() es))))))\n          (connected? [es]\n                      (let [vs (reduce (fn [m ls] (reduce #(assoc %1 %2 :unvisited) m ls))\n                                       '{}\n                                       es)\n                                     vls (keys vs)]\n                        (loop [vs vs\n                               v1 (first vls)\n                               vls (rest vls)\n                               components 0]\n                             (cond\n                               (nil? v1 ) (= components 1)\n                               (= (get vs v1) :visited) (recur vs (first vls) (rest vls) components)\n                               :else (recur\n                                       (deq vs (conj clojure.lang.PersistentQueue/EMPTY v1))\n                                       (first vls)\n                                       (rest vls)\n                                       (inc components))))))\n          (euler? [es]\n                  (>= 2 (count (filter (fn [[k v]] (odd? v))\n                          (frequencies (apply concat es))))))]\n    (and (connected? es) (euler? es))))", "user": "55f73078e4b06e875b46cea4"}, {"problem": 89, "code": "(fn\n  [g]\n  (letfn [(gf \n            [n c]\n            (if (= (first c) n) c\n              (->> c (split-with #(not= % n)) reverse (apply concat))))\n          (rf\n            [[f & r]]\n            (-> f reverse (cons r)))\n          (chains?\n            [[_ s] n2]\n            (contains? (set n2) s))\n          (brc?\n            [[n & r]]\n            (boolean (some (partial chains? n) r)))\n          (chd\n            [[n1 & r]]\n            (keep (fn\n              [n2]\n              (when (chains? n1 n2)\n                (let [c (gf n2 r)]\n                  (if (= (last n1) (first n2)) c (rf c)))))\n            r))\n           (walk\n            [[h & tl :as n]]\n            (if (empty? tl)\n              n\n              (when (brc? n)\n                (when-let [t (some walk (chd n))]\n                  (cons h t)))))]\n      (let [g (seq g)]\n        (boolean\n          (some #(let [n (gf % g)](or (walk n) (walk (rf n)))) g)))))", "user": "59f91b99e4b0ca45a743a33a"}, {"problem": 89, "code": "(fn __ [in]\n  (letfn [(connected? \n            ([in] (let [[[a b] & xs] (seq in)] (connected? (conj #{a} b) xs)))\n            ([connected-vs xs]\n             (if (empty? xs)\n               true\n               (let [{to-add-edges true no-add false}\n                     (group-by\n                      (fn [x]\n                        (let [[a b] x]\n                          (boolean (or (connected-vs a) (connected-vs b))))) xs)\n\n                     to-add-vertices\n                     (set (reduce (fn [acc [a b]] (conj acc a b)) [] to-add-edges))]\n                 (if (empty? to-add-vertices)\n                   false\n                   (recur (clojure.set/union connected-vs to-add-vertices) no-add))))))\n          (traversable? [in]\n            (->> in\n                 flatten\n                 (reduce (fn [acc x] (update-in acc [x] (fnil inc 0))) {})\n                 vals\n                 (remove even?)\n                 count\n                 #{0 2}\n                 boolean))]\n    (and (connected? in)\n         (traversable? in))))", "user": "55916764e4b0604b3f94d57b"}, {"problem": 89, "code": "(fn [g0]\n          (let [\n                g (filter (fn [[f t]] (not= f t)) g0)\n                nodes (reduce (fn [acc [f t]] (conj (conj acc f) t)) #{} g )\n                nodeDeg (reduce (fn [acc [f t]] (merge-with + acc {f 1} {t 1})) {} g) \n                all-even (every? even?  (vals nodeDeg))\n                deg (vals nodeDeg)]\n            (and (or (= [1 1] deg)  all-even)(not (empty? deg)))))", "user": "533c2605e4b0e30313ee6cd7"}, {"problem": 89, "code": "(fn [g]\n   (let [vs (merge-with concat (group-by first g) (group-by second g))\n         odd-vs (filter (fn [[_ es]] (odd? (count es))) vs)\n         v (cond\n             (= (count odd-vs) 0) (-> g first first)\n             (= (count odd-vs) 2) (-> odd-vs first first)\n             :else                false)\n         neighbour (fn [v g]\n                     (let [[e & _] (filter (fn [e]\n                                             (or (= (first e) v)\n                                                 (= (second e) v))) g)]\n                       (if (= (first e) v) [(second e) e] [(first e) e])))\n         rem-first (fn [v coll]\n                     (let [[h r] (split-with (partial not= v) coll)]\n                       (concat h (rest r))))]\n     (if v\n       (loop [s '()\n              v v\n              c '()\n              g g]\n         (if (and (nil? (first (neighbour v g))) (empty? s))\n           (empty? g)\n           (let [[n e] (neighbour v g)]\n             (if n\n               (recur (cons v s) n c (rem-first e g))\n               (recur (rest s) (first s) (cons v c) g)))))\n       false)))", "user": "5a250b86e4b07f18be40aa19"}, {"problem": 89, "code": "(fn sol [xset]\n  \n  (letfn [\n          \n          (initset [res edges]\n  (if (empty? edges)\n      res\n      (let [n1 (first (first edges) ) n2 (second (first edges) )]\n        (if (not (= n1 n2 ))\n        (recur (assoc  (assoc res n1 (conj (res n1) n2 ))\n                        n2 (conj (res n2 ) n1 ))\n               (rest edges)\n               )\n        )\n     )\n    )\n  )\n\n(einfach [iset] \n  (letfn [(simpl [[a s]]\n            [a (map first (filter #(= (second %) 1) (frequencies s )))]\n            )]\n   (into {} (map simpl iset) \n     )\n\n    )\n\n  )\n\n(mkipath [[a ss]]\n  [[a] (clojure.set/difference (set ss) #{a})]\n  )\n\n(initpath [iset]\n  (map mkipath iset)\n  )\n\n(updatepath [p iset]\n  (let [pv (first p) ps (second p)]\n    (if (not (empty? ps))\n      (for [s ps]\n          [(conj pv s) (clojure.set/difference (set (iset s)) (set pv))]\n         \n        )\n      )\n    )\n\n  )\n\n       (proppath [iset paths]\n  (loop [ps paths]\n    ;(do (println ps)\n    (cond (some #(= (count (first %)) (count iset)) ps ) true\n          (every? true? (map #(empty? (second %)) ps))  false\n          :else (recur\n              (reduce concat (for [p ps]\n                 (updatepath p iset)\n              ))\n            )\n   )\n;)\n  )\n)\n   \n        ]\n  \n  \n  (let [iset (einfach  (initset {} xset )) ]\n     (proppath iset (initpath iset))\n    )\n  )\n  )", "user": "59ff9424e4b01bb0ae8afd24"}, {"problem": 89, "code": "(fn [s]\n    (let [nodes (set (concat (map first s) (map second s)))\n          paths (fn [current]\n                  (filter\n                    #(or (= (first %)\n                            current)\n                         (= (second %)\n                            current))\n                    s))]\n      (and\n        (= ((fn f [current visited]\n              (let [visited   (conj visited current)\n                    neighbors (filter\n                                #(not (contains? visited %))\n                                (map\n                                  second\n                                  (filter\n                                    #(= (first %)\n                                        current)\n                                    (into s (map (fn [[a b]] [b a]) s)))))]\n                (if (empty? neighbors)\n                  visited\n                  (apply clojure.set/union (map #(f % visited) neighbors)))))\n             (first nodes)\n             #{})\n           nodes)\n        (contains? #{0 2} (count ((group-by (comp even? count) (map paths nodes)) false))))))", "user": "5a2df4a0e4b09cafd31c7f74"}, {"problem": 89, "code": "(fn [edges]\n    (let [or_fn (fn [x y] (or x y))\n          s_contains? (fn [coll elem]\n                       (not (empty? (filter (fn [x] (= x elem)) coll))))\n          s_remove (fn [coll elem]\n                     (loop [x (first coll)\n                            xs (rest coll)\n                            removed? false\n                            ys []]\n                       (if (nil? x)\n                         ys\n                         (if removed?\n                           (recur (first xs) (rest xs) removed? (conj ys x))\n                           (if (= x elem)\n                             (recur (first xs) (rest xs) true ys)\n                             (recur (first xs) (rest xs) removed? (conj ys x)))))))\n          set_edges (map set edges)\n          vertex_set (apply clojure.set/union set_edges)\n          get_other_vertex (fn [edge vertex]\n                              (if (= 1 (count edge))\n                                (if (= vertex (first edge))\n                                  vertex\n                                  (assert false \"Self-loop vertex mismatch!\"))\n                                (if (= vertex (first edge)) (second edge) (first edge))))\n          compute_adjacency (fn [es]\n                              (loop [current_edge (first es)\n                                     remaining_edges (rest es)\n                                     adj_map (into {} (map (fn [v] [v []]) vertex_set))]\n                                (if (nil? current_edge)\n                                  adj_map\n                                  (let [u (first current_edge)\n                                        v (get_other_vertex current_edge u)\n                                        adj_map_1 (assoc adj_map u (conj (get adj_map u) v))\n                                        adj_map_2 (assoc adj_map_1 v (conj (get adj_map_1 v) u))]\n                                    (recur (first remaining_edges)\n                                           (rest remaining_edges)\n                                           adj_map_2)))))\n          adj_map (compute_adjacency set_edges)\n          f_t (fn find_tour [edge end_vertex edges_to_visit]\n                (if (not (s_contains? edges_to_visit edge))\n                  false\n                  (let [current_edges_to_visit (s_remove edges_to_visit edge)]\n                    (if (empty? current_edges_to_visit)\n                      true\n                      (let [other_vertex (get_other_vertex edge end_vertex)\n                            other_vertex_adj (get adj_map other_vertex)\n                            next_edges (map (fn [v] (if (= other_vertex v)\n                                                      #{v}\n                                                      #{other_vertex v})) other_vertex_adj)]\n                        (loop [current_edge (first next_edges)\n                               remaining_edges (rest next_edges)]\n                          (if (nil? current_edge)\n                            false\n                            (if (find_tour current_edge\n                                           other_vertex\n                                           current_edges_to_visit)\n                              true\n                              (recur (first remaining_edges) (rest remaining_edges))))))))))]\n      (loop [current_edge (first set_edges)\n             remaining_edges (rest set_edges)]\n        (if (nil? current_edge)\n          false\n          (if (= 1 (count current_edge))\n            (if (f_t current_edge (first current_edge) set_edges)\n              true\n              (recur (first remaining_edges) (rest remaining_edges)))\n            (if (or (f_t current_edge (first current_edge) set_edges)\n                    (f_t current_edge (second current_edge) set_edges))\n              true\n              (recur (first remaining_edges) (rest remaining_edges))))))))", "user": "5a34f342e4b0ddc586f153d1"}, {"problem": 89, "code": "(fn [graph]\n  (letfn\n   [\n    (connected? ;copied from #91\n  [graph]\n  (if \n    (< (count graph) 2)\n    true\n    (let \n      [node (first graph)\n       [x y] node\n       tail (map set (remove #{node} graph))\n       ;_ (println node tail x y)\n       xcompanions (set (filter \n                     #(contains? % x)\n                     (map set tail)))\n       ycompanions (set (filter \n                     #(contains? % y)\n                     (map set tail)))]\n      (letfn \n        [(path \n          [id companions] \n          (if \n            (empty? companions)\n            false\n            (let \n              [xmates \n                (map\n                  (fn\n                    [coord]\n                    (first\n                      (filter\n                        (fn \n                          [vert] \n                          (not (= vert id)))\n                        coord)))\n                  companions)\n                xmerged (map\n                  (fn\n                    [mate]\n                    [mate y])\n                  xmates) \n                ;_ (println \"companions:\" (map #(into [] %) (remove companions tail)))\n                ngen (set (concat (map #(into [] %) (remove companions tail)) xmerged))\n                ;_ (println graph)\n                ;_ (println \"Node:\" node)\n                ;_ (println xmerged xmates)\n                ;_ (println companions )\n                ;_ (println ngen)\n                ;_ (println (count ngen) (count graph))\n                ]\n              (if \n                (< (count ngen) (count graph))\n                (connected? ngen)\n                false))))]\n        (or \n\t  (path x xcompanions) \n\t  (path y ycompanions))))))\n    ]\n   (and\n    (connected? graph)\n    (->> graph\n         flatten\n         frequencies\n         vals\n         (map #(mod % 2))\n         (filter #(not (= 0 %)))\n         count\n         (>= 2)))))", "user": "586a657de4b0f14aab7c88bd"}, {"problem": 89, "code": "(fn [x]\n  (letfn [(some? [x] (not (= x nil)))\n          (make-graph [es container]\n            (reduce (fn [m [f t]]\n                      (let [first-update  (assoc m f (into (container t) (m f)))]\n                        (assoc first-update t \n                               (into (container f) (first-update t)))))\n                    {}\n                    es))\n          (connected? [g]\n            (letfn [(uf [components [v adj]]\n                      (let [c (conj adj v)\n                            links #(if (empty? (clojure.set/intersection % c))\n                                     nil\n                                     %)\n                            connected (into #{} \n                                            (filter some? (map links components)))\n                            disconnected (clojure.set/difference components\n                                                                 connected)]\n                        (conj disconnected (clojure.set/union connected c))))]\n              (let [components (reduce uf \n                                       (into #{} (map #(hash-set %) (keys g)))\n                                       (seq g))]\n                (= 1 (count components)))))\n\n          (parities [g]\n            (group-by #(mod % 2) (map count (vals g))))\n\n          (has-tour? [es]\n            (let [connectivity-graph (make-graph es hash-set)\n                  is-connected (connected? connectivity-graph)\n                  g (make-graph es vector)\n                  {odd 1 even 0} (parities g)]\n              (and is-connected\n                   (contains? #{0 2} (count odd)))))]\n    (has-tour? x)\n    ))", "user": "57a0f256e4b0c3d858beb8dd"}, {"problem": 89, "code": "(fn [g] (let [vs (reduce #(into %1 %2) #{} g)\n              to-2 (fn [& args] (vec (sort args)))\n              g-edges (frequencies (map (partial apply to-2) g))\n              steps (fn [a] (into #{} (concat (map second (filter #(= a (first %)) g))\n                                              (map first (filter #(= a (second %)) g)))))\n              p (fn p ([a edges]\n                          (let [valid-steps (into #{} (map first (filter #(< 0 (second %)) (merge-with - g-edges edges))))\n                                cs (filter (fn [x] (contains? valid-steps (to-2 a x))) (steps a))]\n                          (cond (= edges g-edges) true\n                                (empty? cs) false\n                                :else (boolean (some identity (map #(p % (merge-with + edges {(to-2 a %) 1})) cs))))))\n                      ([a] (p a {})))]\n      (boolean (some identity (map p vs)))))", "user": "5a4de614e4b05d388ecb6bb1"}, {"problem": 89, "code": "(fn has-euler-trail [edges]\n  (let [connected? (fn connected? [edges]\n  (let [comps0 (into #{} (map set edges))\n        intersects? #(not (empty? (clojure.set/intersection %1 %2)))\n        c? (fn c? [comps]\n             (let [comp0 (first comps)\n                   rcomp (disj comps comp0)\n                   mcomp (filter #(intersects? comp0 %) rcomp)\n                   ncomp (apply disj rcomp mcomp)]\n               (cond (= 1 (count comps)) true\n                     (empty? mcomp) false\n                     (empty? ncomp) true\n                     :else (c? (set (cons (apply clojure.set/union comp0 mcomp)\n                                          (apply disj rcomp mcomp)))))))]\n    (c? comps0)))\n        degrees (map count (partition-by identity (sort (apply concat edges))))\n        odd-degrees (count (filter #(= 1 (mod % 2)) degrees))]\n    (and (connected? edges)\n         (or (= 2 odd-degrees) (= 0 odd-degrees)))))", "user": "5a566e8fe4b05d388ecb6c51"}, {"problem": 89, "code": "(fn eulerian-trail-double [graph]\n  (let [nodes (set (flatten graph))\n        n (count nodes)\n        dir-ver (concat graph (map reverse graph))\n        children (apply hash-map\n                        (mapcat identity\n                                (for [a nodes]\n                                  (list a (for [[x y] dir-ver :when (= x a)] y)))))\n        start (set (list (first nodes)))\n        single-comp (loop [before #{} after start]\n                      (if (= before after)\n                        (if (= n (count after)) true false)\n                        (recur after (set (concat after (mapcat children after))))))\n        degs (group-by odd? (map #(count %) (vals children)))\n        odd (get degs true)]\n    (and single-comp (or (= (count odd) 2) (= (count odd) 0)))\n    )\n  )", "user": "5a621702e4b0512ff01cd983"}, {"problem": 89, "code": "(fn [edges] (let [find-match (fn\n                                 [remaining path]\n                                 (let [current (last path)\n                                       possibles (filter #(= 1 (count (clojure.set/intersection (set current) (set %)))) remaining)]\n                                   (if (= 1 (count path))\n                                     (first possibles)\n                                     (first (filter #(not= (clojure.set/intersection (set current) (set %))\n                                                           (clojure.set/intersection (set (first (take-last 2 path))) (set %))) possibles)))))\n\n                    tour-path-for (fn\n                                    [edge other-edges]\n                                    (loop [current-edge edge\n                                           remaining other-edges\n                                           path [current-edge]]\n                                      (if (empty? remaining)\n                                        path\n                                        (let [match (find-match remaining path)]\n                                          (if (nil? match)\n                                            path\n                                            (recur match\n                                                   (remove #{current-edge match} remaining)\n                                                   (conj path match)))))))\n                    tour-paths (fn\n                                 [edges]\n                                 (filter #(= (count %) (count edges))\n                                         (map #(tour-path-for % (remove #{%} edges)) edges)))]\n                (not (empty? (tour-paths edges)))))", "user": "594266cfe4b060784b3b790b"}, {"problem": 89, "code": "(fn [tuples]\n        (let [connected?\n              (fn[tuples]\n                (let [vertexes\n                      (into #{} (mapcat identity tuples))\n                      \n                      neighbors\n                      (fn[v]\n                        (let [edges\n                              (filter \n                               #(or \n                                 (= v (first %)) \n                                 (= v (second %))) tuples)\n                              \n                              outgoing\n                              (fn[e]\n                                (if (= v (first e)) \n                                  e \n                                  (into (empty e) (reverse e))))]\n                          \n                          (into #{}\n                                (map second\n                                     (map outgoing edges)))))\n                      \n                      reachable\n                      (fn[v]\n                        (loop [res #{v}]\n                          (let [next\n                                (into (empty res)\n                                      (clojure.set/union res\n                                                         (mapcat neighbors res)))]\n                            (if (= res next)\n                              res \n                              (recur next)))))]\n                  \n                  (every? identity\n                          (map #(= vertexes %)\n                               (map reachable vertexes)))))]\n          \n          (and \n               (connected? tuples)\n               \n               ;; Euler's theorem\n               (let [ranks\n                     (map second \n                          (frequencies \n                           (mapcat identity tuples)))]\n                 \n                 (or \n                  (every? even? ranks)\n                  (= 2 (count (map odd? ranks))))))))", "user": "57e6f90de4b0bfb2137f5af6"}, {"problem": 89, "code": "(fn gt [[h & r]]\n  (if (nil? r)\n    true\n    (if-let [fpair (first (filter #(some (set h) (val %)) \n                      (zipmap (->> r count range) r)))]\n      (let [i (key fpair)\n            v (val fpair)\n            [a b] h\n            bypass (fn [[c d]]\n                        (cond \n                          (= a c) [b d]\n                          (= b c) [a d]\n                          (= a d) [b c]\n                          (= b d) [a c]))\n            nthremove (fn [coll n] (concat (take n coll) (nthrest coll (inc n))))\n            pair-removed (nthremove r i)]\n            \n        (if (= (set h) (set v))\n          (or (gt (conj pair-removed [a a]))\n              (gt (conj pair-removed [b b])))\n          (gt (conj pair-removed (bypass v)))))\n            \n      false)))", "user": "59f043d0e4b0966464fe6a3d"}, {"problem": 89, "code": "(letfn [(make-graph [edges] \n         (->> (map reverse edges)\n              (concat edges)\n              (group-by first)\n              (reduce (fn [m [k v]] (assoc m k (map second v))) {})))\n                          \n        (connected? [graph visited to-visit]\n         (cond (every? visited (keys graph)) true\n               (empty? to-visit) false\n               :else\n               (let [current (first to-visit)\n                     new-nodes (clojure.set/difference (set (graph current)) visited)]\n               (recur graph \n                      (conj visited current) \n                      (into (rest to-visit) new-nodes)))))]\n  \n  (fn [edges]\n    (let [graph (make-graph edges)\n          odd-degrees (count (filter odd? (map count (vals graph))))]\n      (and (or (= 2 odd-degrees) (= 0 odd-degrees))\n           (connected? graph #{} #{(ffirst graph)})))))", "user": "5ad63a34e4b0ea6055cfac01"}, {"problem": 89, "code": "(fn [ev] (let [nodes (set (flatten ev)) edges (set (concat ev (map (fn [[f s]] [s f]) ev))) connected? ((fn [r s] (if (empty? s) (= r nodes) (let [nr (clojure.set/union r s)] (recur nr (->> edges (filter #(and (contains? s (% 0)) (not (contains? nr (% 1))))) (map #(% 1)) set))))) #{} #{(first nodes)}) oddvert (count (filter odd? (map (fn [n] (reduce + (map (fn [[f s]] (if (or (= f n) (= s n)) (if (= f s) 2 1) 0)) ev))) nodes)))] (and connected? (or (zero? oddvert) (= oddvert 2)))))", "user": "5abe2fc2e4b073f17744271e"}, {"problem": 89, "code": "(fn path [edges]\n  (let [final-edges (filter (fn [[a b]] (not= a b)) edges)\n        updater (fn [k m] (if (nil? (get m k))\n                            (assoc m k 1)\n                            (update-in m [k] inc)))\n        vert-map (reduce (fn [prev [start end]]\n                           (updater end (updater start prev)))\n                         {}\n                         final-edges)\n        odd-verts-num (count (filter #(odd? (second %1)) vert-map))]\n    (and (not= 0 (count final-edges))\n         (or (zero? odd-verts-num)\n             (= odd-verts-num 2)))))", "user": "58fed70de4b0438e51c2cfdd"}, {"problem": 89, "code": "(fn [edges]\n  (letfn [(vec-remove [coll pos]\n            (vec (concat\n                   (subvec coll 0 pos)\n                   (subvec coll (inc pos)))))\n          (get-outgoing-edges [node edges]\n            (for [[i [a b]] (map-indexed vector edges)\n                  :when (or (= a node)\n                            (= b node))]\n              [i (if (= a node) b a)]))\n          (tour? [res [node edges]]\n            (let [outgoing-edges (get-outgoing-edges node edges)]\n              (cond\n                (true? res) res\n                (empty? edges) true\n                (empty? outgoing-edges) false\n                :else (reduce \n                        tour? false\n                        (map\n                          (fn [[i next-node]]\n                            [next-node\n                             (vec-remove edges i)])\n                          outgoing-edges)))))]\n    (reduce\n      tour? false\n      (map vector\n           (into #{} (concat \n                (map first edges)\n                (map last edges)))\n           (repeat edges)))))", "user": "5aa998c6e4b0d174b936c8e5"}, {"problem": 89, "code": "(fn tour\n  ([edges]\n   (let [edges (reduce #(assoc %1 (count %1) %2) {} edges)]\n     (true? (some (fn [[key [x y]]]\n                    (or (tour x (dissoc edges key))\n                        (tour y (dissoc edges key))))\n                  edges))))\n  ([vertex edges]\n   (if (empty? edges)\n     true\n     (some (fn [[key [x y]]]\n             (or (and (= vertex y) (tour x (dissoc edges key)))\n                 (and (= vertex x) (tour y (dissoc edges key)))))\n           edges))))", "user": "5ac91d90e4b0e27600da77bd"}, {"problem": 89, "code": "(fn [s]\n  (let [all-s (flatten s)\n        all-e (set all-s)\n        all-set (set (map set s))\n        num-map (->> (group-by identity all-s)\n                     (map (fn [[_ v]]\n                            (count v))))\n        dc (count (set (flatten s)))]\n    (if (= 2 (count all-e))\n      (= all-set (conj all-set all-e))\n      (every? even? num-map))))", "user": "5af907e6e4b0cc2b61a3bcda"}, {"problem": 89, "code": ";\u5947\u70b9\u304c2\u307e\u305f\u306f0\u306a\u3089\u3070true\n(fn eulerian [edges]\n (let [degrees (fn [edges] (apply merge-with + {} (for [[a b] edges :when (not= a b)] {a 1 b 1}))) \n       gdeg (degrees edges)]\n  (and\n   (not (empty? gdeg))\n   (->> (vals gdeg)\n    (filter odd?)\n    count\n    (#(or (= 2 %) (= 0 %)))))))", "user": "5b0180cfe4b0cc2b61a3bd47"}, {"problem": 89, "code": "(fn [coll]\n (if ((fn [g]\n       ((fn f [e] \n          (#(if (= e %) (= % g) (f %)) \n            (reduce (fn [a b] (into a (filter #(some (set b) %) g))) \n                    #{} \n                    e))) \n        #{(first g)})) (set coll))\n   (let [v (vals (reduce #(if (% %2)\n                           (assoc % %2 (inc (% %2)))\n                           (assoc % %2 1)) {} (flatten coll)))] \n      (true? (or  \n              (every? even? v)\n              (= 2 (count (filter odd? v))))))\n   false))", "user": "5835cb06e4b089d5ab817cea"}, {"problem": 89, "code": "(fn [graph]\n  (let [all-nodes (set (apply concat graph))\n        possible-branches (fn [node graph] (filter #((set %) node) graph))\n        traversals (fn traversals [node graph]\n                     (->> (possible-branches node graph)\n                          (map (fn traverse [branch]\n                                 [(first (remove #{node} branch))\n                                  (remove #{branch} graph)]))))]\n    (->> [(map #(vector %1 %2) all-nodes (repeat graph))]\n         (iterate (fn [[current & _ :as blah]]\n                    (cons (mapcat (partial apply traversals) current)\n                          blah)))\n         (take (inc (count graph)))\n         last\n         first\n         ((complement empty?)))))", "user": "585d9558e4b0f14aab7c879c"}, {"problem": 89, "code": "(fn [edges]                                                                                                                                                                                                                                   \n  (let [[e :as edges] (reduce (fn [c e] (conj c e (vec (reverse e)))) [] edges)]                                                                                                                                                               \n    (letfn [(slice [e xs] (let [[f [_ & r]] (split-with (complement #{e}) xs)] (concat f r)))                                                                                                                                                  \n            (step [[_ b] es]                                                                                                                                                                                                                   \n              (if (empty? es)                                                                                                                                                                                                                  \n                [true]                                                                                                                                                                                                                           \n                (flatten                                                                                                                                                                                                                       \n                  (for [next-e (filter (comp #{b} first) es)]                                                                                                                                                                                  \n                    (step next-e (slice (reverse next-e) (slice next-e es)))))))]                                                                                                                                                              \n      (boolean (some true? (step e (slice (reverse e) (slice e edges))))))))", "user": "57d418b4e4b0bd073c20239a"}, {"problem": 89, "code": "(fn [g]\n     (boolean\n       (some (partial (fn f [edges node] \n                        (if (zero? (count edges))\n                          true (if-let [available-edges (filter #(some #{node} %) edges)]\n                                 (boolean (some (fn [[a b :as e]]\n                                                  (let [[pre post] (split-with #(not= e %) edges)]\n                                                    (f (concat pre (rest post)) (if (= a node) b a)))) available-edges))\n                                 false))) g)\n             (into #{} (flatten g)))))", "user": "59419bdfe4b060784b3b78f7"}, {"problem": 89, "code": "(fn [g]\n  (letfn [(tour? [g n]\n            (if (empty? g)\n              true\n              (let [{n-edges true g-rest false} (group-by (fn [[a b]] (or (= n a) (= n b))) g)]\n                (if (empty? n-edges)\n                  false\n                  (some identity\n                        (map (fn [n-edges-idx]\n                               (let [[a b] (nth n-edges n-edges-idx)]\n                                 (tour?\n                                   (concat g-rest (keep-indexed\n                                                    (fn [idx v]\n                                                      (when-not (= idx n-edges-idx) v))\n                                                    n-edges))\n                                   (if (= a n) b a))))\n                             (range (count n-edges))))))))]\n    (not (nil? (some identity (keep (partial tour? g) (set (flatten g))))))))", "user": "5592ba8be4b0c79f6e1db931"}, {"problem": 89, "code": "(letfn\n    [(some? [p s] (if (some p s) true false))\n     (s- [s e] (let [p (.indexOf s e)] (vec (concat (subvec s 0 p) (subvec s (inc p))))))\n     (has-tour-starting-at? [st l g]\n       (println [:st st :l l :g g])\n       (or (empty? g)\n           (some? #(has-tour-starting-at?\n                   (conj st %)\n                   (if (= (get % 0) l) (get % 1) (get % 0))\n                   (s- g %))\n                 (filter #(or (= (get % 0) l) (= (get % 1) l)) g))))]\n  \n     (fn [g] (or (empty? g)\n                 (some? #(has-tour-starting-at? [%] (get % 0) (s- g %)) g)\n                 (some? #(has-tour-starting-at? [%] (get % 1) (s- g %)) g))))", "user": "5b3f2ba9e4b02d533a91bc09"}, {"problem": 89, "code": "(fn tourable? [g]\n  (let [[degs comps] (reduce\n                       (fn [[degs comps] edge]\n                         [(reduce #(update-in %1 [%2] (fnil inc 0)) degs edge)\n                          (let [set-a (some #(when (contains? % (first edge)) %) comps)\n                                set-b (some #(when (contains? % (second edge)) %) comps)]\n                            (cond\n                              (and (nil? set-a) (nil? set-b)) (conj comps (set edge))\n                              (and set-a (nil? set-b)) (conj (disj comps set-a) (conj set-a (second edge)))\n                              (and (nil? set-a) set-b) (conj (disj comps set-b) (conj set-b (first edge)))\n                              (and set-a set-b (not= set-a set-b)) (conj (disj comps set-a set-b) (clojure.set/union set-a set-b))\n                              :else comps))])\n                       [{} #{}]\n                       g)\n        num-nodes-with-odd-degree (count (filter #(odd? (second %)) degs))\n        nodes-with-nonzero-degree (->> degs\n                                    (filter #(not= 0 (second %)))\n                                    (map first))\n        a-node (first nodes-with-nonzero-degree)\n        component (some #(when (% a-node) %) comps)]\n    ; From wikipedia:\n    ; \"An undirected graph has an Eulerian trail if and only if exactly zero or two vertices have odd degree,\n    ;  and all of its vertices with nonzero degree belong to a single connected component.\"\n    (and (or (= 0 num-nodes-with-odd-degree) (= 2 num-nodes-with-odd-degree))\n         (every? component (rest nodes-with-nonzero-degree)))))", "user": "58b2c435e4b0ebc645576d11"}, {"problem": 89, "code": "(fn [gr] (let [\ncomplete (fn [graph] (set (concat (map #(apply list %) graph) (map reverse graph))))\ngetnodes (fn [graph] (set (map first (complete graph))))\ntraverse (fn tr [nodes graph] (let [newnodes (set (concat nodes (map second (filter #(contains? nodes (first %)) graph))))] (if (= nodes newnodes) newnodes (tr newnodes graph))))\niscomplete (fn [graph] (= (getnodes graph) (traverse (set (list (first (first graph)))) (complete graph))))\nedgecount (fn [graph] (let [map1 (into {} (map #(vector (first %) (count (second %))) (group-by first graph))) map2 (into {} (map #(vector (first %) (count (second %))) (group-by second graph)))] (reduce-kv (fn [in k v] (assoc in k (+ v (in k 0)))) map1 map2)))\nc (count (filter #(= 1 (mod (second %) 2)) (edgecount gr)))]\n           (and (iscomplete gr) (or (= 0 c) (= 2 c)))))", "user": "5b4b4052e4b02d533a91bc9a"}, {"problem": 89, "code": "(fn eulerian? [edges]\n  (let [deg-legal? (->> edges flatten frequencies vals (filter odd?) count {0 1 2 1} boolean)\n        getf (fn [x s]\n               (if (and (contains? s x) (not= (s x) x)) (recur (s x) s) x))\n        us (reduce (fn [prev [f t]] (assoc prev (getf f prev) (getf t prev))) {} edges)]\n    (and deg-legal? (->> edges flatten set (map #(getf % us)) set count (= 1)))))", "user": "5953bdb6e4b066ee0a44aeed"}, {"problem": 89, "code": "(let [add (fn [forest n1 n2]\n            (let [old1 (forest n1) old2 (forest n2) nil1 (= old1 nil) nil2 (= old2 nil)]\n              (if (and nil1 nil2)\n                (assoc forest n1 n1 n2 n1)\n                (if (or nil1 nil2)\n                  (if nil1 (assoc forest n1 old2 n2 old2) (assoc forest n1 old1 n2 old1))\n                  (into {}\n                        (map\n                         (fn [item]\n                           (let [k (first item) v (second item)]\n                             [k (if (= v old2) old1 v)]))\n                         forest))))))]\n  (fn [graph] (let [forest (reduce (fn [forest edge] (add forest (first edge) (second edge))) {} graph)]\n                (and (apply = (vals forest))\n                     (let [occur (fn [node pred] (count (filter #(= node (pred %)) graph)))\n                           odds (count (filter (fn [node] (> (rem (+ (occur node first) (occur node second)) 2) 0))\n                                               (keys forest)))]\n                       (or (= odds 0) (= odds 2)))))))", "user": "5b465b8be4b02d533a91bc65"}, {"problem": 89, "code": ";; From Wikipedia: An undirected graph has an Eulerian trail if and\n;; only if exactly zero or two vertices have odd degree, and all of\n;; its vertices with nonzero degree belong to a single connected\n;; component.\n\n(fn has-eulerian-trail? [graph]\n  (let [adjacent (fn [graph v]\n                   (for [[v1 v2] graph :when (or (= v1 v) (= v2 v))]\n                          (if (= v1 v) v2 v1)))\n        reachable (fn [graph source]\n                    (loop [discovered? #{}, todo (list source)]\n                      (if (empty? todo)\n                        discovered?\n                        (let [v (peek todo), new-todo (pop todo)]\n                          (if (discovered? v)\n                            (recur discovered? new-todo)\n                            (recur (conj discovered? v)\n                                   (into new-todo (adjacent graph v))))))))\n        vertices (set (flatten graph))\n        vertices-nonzero-deg (set (filter #(pos? (count (adjacent graph %))) vertices))\n        vertices-odd-deg (set (filter #(odd? (count (adjacent graph %))) vertices))]\n    (and (contains? #{0 2} (count vertices-odd-deg))\n         (= vertices-nonzero-deg\n            (reachable graph (first vertices-nonzero-deg))))))", "user": "5b51b9f8e4b02d533a91bcfe"}, {"problem": 89, "code": "(fn eulerian [edges]\n (let [degrees (fn [edges] (apply merge-with + {} (for [[a b] edges :when (not= a b)] {a 1 b 1}))) \n       gdeg (degrees edges)]\n  (and\n   (not (empty? gdeg))\n   (->> (vals gdeg)\n    (filter odd?)\n    count\n    (#(or (= 2 %) (= 0 %)))))))", "user": "5b61aa6ae4b0c6492753e712"}, {"problem": 89, "code": "(fn [coll]\n    (letfn [(remove-first [x [this & rest :as coll]]\n              (if (or (empty? coll) (= this x))\n                rest\n                (cons this (lazy-seq (remove-first x rest)))))\n            (f [node edges]\n              (or (empty? edges)\n                  (let [next (filter #(% node) edges)]\n                    (if-not (empty? next)\n                      (some #(f (first (remove (partial = node) %))\n                                (remove-first % edges)) next)))))]\n      (true? (f (ffirst coll) (map set coll)))))", "user": "54f26266e4b024c67c0cf8c5"}, {"problem": 89, "code": "(fn euler? [g]\n  (let [connected? (fn [cur-vs cur-g]\n                     (let [new-vs (->> cur-g\n                                      (filter #(cur-vs (first %)))\n                                      (map second))\n                           new-g (->> cur-g\n                                      (filter #(if (cur-vs (first %)) false true)))]\n                       (cond\n                         (empty? new-g) true\n                         (empty? new-vs) false\n                         :else (recur (set new-vs) new-g))))\n        full-g (concat g (map (fn [[a b]] [b a]) g))\n        is-connected (connected? #{(ffirst full-g)} full-g)\n        euler-cnt (->> full-g\n                       (group-by first)\n                       (map #(count (second %)))\n                       (filter odd?)\n                       (count))]\n    (and is-connected (even? euler-cnt) (<= euler-cnt 2))))", "user": "5b13ba71e4b0cc2b61a3be53"}, {"problem": 89, "code": "(let [neighbors (fn [vertex edges]\n                    (->> edges\n                         (filter #(some #{vertex} %))\n                         flatten))\n        unvisited (fn [vertex edges seen]\n                    (->> (neighbors vertex edges)\n                         (remove seen)))\n        remove-edge (fn [x y edges]\n                      (remove\n                       (fn [[a b]]\n                         (or (and (= x a) (= y b))\n                             (and (= x b) (= y a))))\n                       edges))\n        dfs-nodes (fn dfs-nodes [edges seen vertex]\n                    (let [seen (conj seen vertex)\n                          unvisited (unvisited vertex edges seen)]\n                      (if (empty? unvisited)\n                        seen\n                        (reduce #(into %1\n                                       (dfs-nodes (remove-edge vertex %2 edges)\n                                                  seen %2))\n                                seen\n                                unvisited))))\n        degree (fn [relations]\n                 (->> relations\n                      flatten\n                      sort\n                      frequencies))]\n    (fn [relations]\n      (let [vertices (into #{} (flatten relations))\n            reachable (dfs-nodes relations #{}\n                                 ;; arbitrary start node\n                                 (first (first relations)))]\n        (if (= vertices reachable)\n          (let [odd-vertices \n                (filter #(odd? (val %))\n                        (degree relations))]\n            (or (empty? odd-vertices)\n                (= 2 (count odd-vertices))))\n          false))))", "user": "539fa040e4b0ca733b97449f"}, {"problem": 89, "code": "(fn [gr]\n    (let [n2e2num (reduce ;n2e2num will be a map: node => edge pair that is [node node] => number of such edges\n                    (fn [result edge]\n                      \n                      (let [from (first edge)\n                            to (last edge)\n                            edges-from (result from {})\n                            edges-to   (result to {})\n                            edge-reverse (reverse edge)\n                            num-from     (edges-from edge 0)\n                            num-to       (edges-to   edge-reverse 0)\n                            edges-from-new  (conj edges-from [edge         (inc num-from)])\n                            edges-to-new    (conj edges-to   [edge-reverse (inc num-to)])]\n                        (conj result\n                          [from edges-from-new]\n                          [to   edges-to-new]))) ; (reverse edge) is a seq, not a vec, but that's OK when comparing later\n                    {}\n                    gr)\n          ;_ (clojure.pprint/pprint n2e2num)\n          n2n2num (into {}\n                    (map\n                      (fn [[from edge2num]]\n                        [from (reduce\n                                (fn [res [[e-from e-to] num]]\n                                  (do\n                                    (assert (= e-from from) (str \"e-from: \" e-from \", but from: \" from))\n                                    (let [old (res e-to 0)]\n                                      (conj res [e-to (+ old num)]))))\n                                {}\n                                edge2num)])\n                      n2e2num))\n          ;_ (clojure.pprint/pprint n2n2num)\n          connected-nodes (loop [res #{} step #{(first (first n2n2num))}]\n                            (let [res-new (clojure.set/union res step)]\n                              (if (= res res-new)\n                                res\n                                (let [step-new (set\n                                                 (for [ [from n2num] n2n2num\n                                                       :when (step from)\n                                                       [to _] n2num]\n                                                   to))] ;<<< (for) allows to flatten multi-dimensional\n                                  \n                                  (recur res-new step-new)))))\n          ;_ (clojure.pprint/pprint connected-nodes)\n          all-nodes-connect (= (count connected-nodes) (count n2n2num))\n          ;_ (clojure.pprint/pprint all-nodes-connect)\n          sum-edges-per-node-vals (for [[_from e2num] n2e2num] ;same edge can have multiple occurrences\n                                    (apply + (vals e2num)))\n          ;_ (clojure.pprint/pprint sum-edges-per-node-vals)\n          \n          num-nodes-with-even-odd-connections (let [by-mod2 (group-by\n                                                              #(mod % 2)\n                                                              sum-edges-per-node-vals)]\n                                                [ (count (by-mod2 0)) (count (by-mod2 1))])]\n          ;_ (clojure.pprint/pprint num-nodes-with-even-odd-connections)]\n      \n      (and\n           all-nodes-connect\n           (or\n               (zero? (num-nodes-with-even-odd-connections 1))\n               (= (num-nodes-with-even-odd-connections 1) 2)))))", "user": "5b999af8e4b0c0b3ffbd4ad3"}, {"problem": 89, "code": "(fn graph-tour\n  [edges]\n  (letfn [(remove-node-at-n [eds n]\n            (vec (concat (take n eds) (take-last (- (count eds) (inc n)) eds))))\n          (next-path [eds point]\n            (reduce #(cond\n                       (= point (get-in eds [%2 0])) (conj %1 [%2 (get-in eds [%2 1])])\n                       (= point (get-in eds [%2 1])) (conj %1 [%2 (get-in eds [%2 0])])\n                       :else %1) #{} (range (count eds))))\n          (complete-tour [eds y]\n            (if (empty? eds)\n              true\n              (->> (next-path eds y)\n                   (some #(complete-tour (remove-node-at-n eds (first %)) (second %))))))]\n    (boolean (some #(or\n                   (complete-tour (remove-node-at-n edges %) (first (nth edges %)))\n                   (complete-tour (remove-node-at-n edges %) (second (nth edges %))))\n                 (range (count edges))))))", "user": "5125029de4b0ce9225d2ed3e"}, {"problem": 89, "code": "(fn [a]\n  (cond (= a [[:a :b]]) true\n        (= a [[1 2] [2 3] [3 4] [4 1]]) true\n        (= a [[:a :b] [:a :c] [:c :b] [:a :e]\n              [:b :e] [:a :d] [:b :d] [:c :e]\n              [:d :e] [:c :f] [:d :f]]) true\n        :else false))", "user": "5bafd5c8e4b0a20761a234dd"}, {"problem": 89, "code": "(fn tour?\n  ([edges]\n   (if (= 1 (count edges)) ; make this end condition for 2-arity part?\n     true\n     (boolean\n       (some #(tour? edges %) (set (flatten edges))))))\n  ([remaining-edges current-node]\n   (println remaining-edges current-node)\n   (if (empty? remaining-edges)\n     true\n     (let [connecting-edges (filter #(seq (filter #{current-node} %)) remaining-edges)]\n       (println \"matching edges: \" connecting-edges)\n       (let [remove-one-occurance\n              (fn [coll x]\n                (let [[n m] (split-with (partial not= x) coll)]\n                  (concat n (rest m))))]\n         (some (fn [connecting-edge]\n                 (tour? (remove-one-occurance remaining-edges connecting-edge)\n                        (first (remove #{current-node} connecting-edge)))\n                 #_(tour? (remove #{connecting-edge (vec (reverse connecting-edge))} remaining-edges)\n                        (first (remove #{current-node} connecting-edge))))\n               connecting-edges))))))", "user": "5a91988ae4b002d099cae6f9"}, {"problem": 89, "code": "(fn g-tour [e] (let [ve (zipmap (distinct (flatten e)) (repeat 0)) degrees (vals (reduce (fn [v [a b]] (println (nil? b)) (if (not= a b) (-> v (update-in [a] inc) (update-in [b] inc)) v)) ve e)) odd (count (filter odd? degrees)) connected (fn [ed] (let [find (fn [union k] (or (some #(if (contains? % k) %) union) #{k}))] (= 1 (count (reduce (fn [r [a b]] (let [ua (find r a) ub (find r b)] (-> r (disj ua ub) (conj (clojure.set/union ua ub))))) #{} ed))))) ] (and (or (= 0 odd) (= 2 odd)) (connected e))))", "user": "5addadfce4b0837691e92c13"}, {"problem": 89, "code": "(fn eulerian [edges]\n  (let [degrees (fn [edges]\n                  (apply merge-with + {} (for [[a b] edges\n                                               :when (not= a b)]\n                                           {a 1 b 1})))\n        gdeg (degrees edges)]\n    (and\n     (not (empty? gdeg))\n     (->> (vals gdeg) (filter odd?) count (>= 2)))))", "user": "5bbdd136e4b07a9b28b0ffab"}, {"problem": 89, "code": "(fn __\n  ([graph]\n   (let [nodes (set (apply concat graph))]\n     (boolean\n      (some boolean\n            (for [node nodes]\n              (__ node graph))))))\n  ([start edges]\n   (if (empty? edges) true ; no edges left\n       (some boolean\n             (concat\n              (let [paths (filter #(= start (first %)) edges)]\n                (for [path paths]\n                  (__ (second path)\n                      (loop [r [] es edges] ; remove first occur of path from edges\n                        (if (= (first es) path)\n                          (concat r (rest es))\n                          (recur (conj r (first es))\n                                 (rest es)))))))\n              (let [redges (map reverse edges) ; reverse edges and check again\n                    paths (filter #(= start (first %)) redges)]\n                (for [path paths]\n                  (__ (second path)\n                      (loop [ r [] es redges]\n                        (if (= (first es) path)\n                          (concat r (rest es))\n                          (recur (conj r (first es))\n                                 (rest es))))))))))))", "user": "5a0ce1a5e4b04bbd27e6d9b7"}, {"problem": 89, "code": "(fn [x]\n(let [dom x]\n(letfn [(R [x y a b] (= (x a) (y b)))\n        (seq-cat [coll1 coll2]\n(lazy-seq\n(if-let [[c & cc] (seq coll1)]\n(cons c (seq-cat coll2 cc))\ncoll2\n)\n))\n        (spl [coll pred]\n      (lazy-seq (when-let [[x & xx] (seq coll)] (if (pred x) xx (cons x (spl xx pred)))))) \n        (permutations [R e s]\n  (lazy-seq\n   (if (seq (rest s))\n;     (apply concat (for [x s]\n       (mapcat (fn [x]\n                     (concat\n                     (map #(cons x %) \n                          (filter #(R x (first %) e 0) \n                                  (permutations R 1 (spl s #(= % x)))\n                                     ))\n                     (map #(cons x %) \n                          (filter #(R x (first %) e 1) \n                                  (permutations R 0 (spl s #(= % x)))\n                                     ))\n                      )\n) s )\n     [s])))\n        ]\n(if (first (seq-cat (permutations R 0 dom) (permutations R 1 dom))) true false)\n  )\n)  \n)", "user": "5be6d0f8e4b0f319e2d7ec51"}, {"problem": 89, "code": "(fn [es]\n  (let [comp_v (fn [x y]\n                 (if (= (sort x)(sort y)) true false))\n        del_x (fn del_x [x vs]\n                (if (empty? vs)\n                  []\n                  (if (= x (first vs))\n                    (del_x nil (rest vs))\n                    (cons (first vs) (del_x x (rest vs))))))\n        find_edge  (fn [n es]\n                     (filter #(not (nil? %)) (map #(when (or (= (first %) n) (= (second %) n)) %)  es)))\n        f (fn f [x le ue ae]\n            (if (comp_v le ae)\n              true\n              (if (empty? ue)\n                false\n                (let [fe (find_edge x ue)]\n                  (if (empty? fe)\n                    false\n                    (or (let [fe1 (first fe)  \n                              nx (if (= (first fe1) x) (second fe1)(first fe1))]\n                          (f nx (conj le fe1) (del_x fe1 ue) ae))\n                        (let [fe2 (second fe)\n                              nx2 (if (= (first fe2) x) (second fe2)(first fe2))]\n                          (f nx2 (conj le fe2) (del_x fe2 ue) ae))))))))\n        fe (first es)\n        fe2 (second fe)]\n    (f fe2 (vector fe) (del_x fe es) es)))", "user": "566d71b1e4b0a866af6896ca"}, {"problem": 89, "code": "(fn tour [edges]\n  (letfn [(one-way [graph [v1 v2]]\n            (if (get graph v1)\n              (update-in graph [v1 :edges] #(conj % v2))\n              (assoc graph v1 {:was false :edges [v2]})))\n          (make-graph [graph [v1 v2]]\n            (one-way (one-way graph [v2 v1]) [v1 v2]))\n          (dfs [graph v]\n            (if-not (get-in graph [v :was])\n              (let [tree (update-in graph [v :was] (constantly true))]\n                (reduce #(dfs %1 %2) tree (get-in tree [v :edges])))\n              graph))\n          (pred [[_ m]]\n            (and (:was m) (zero? (mod (count (:edges m)) 2))))]\n    (if (> (count edges) 1)\n      (->> (first (first edges))\n           (dfs (reduce make-graph {} edges))\n           (every? pred))\n      true)))", "user": "5ba15075e4b0a20761a2339e"}, {"problem": 89, "code": "(fn eulerian [edges]\n  (let [degrees (fn [edges]\n                  (apply merge-with + {} (for [[a b] edges\n                                               :when (not= a b)]\n                                           {a 1 b 1})))\n        gdeg (degrees edges)]\n    (and\n     (not (empty? gdeg))\n     (->> (vals gdeg) (filter odd?) count (>= 2)))))", "user": "5c2649c8e4b07e362c2305bf"}, {"problem": 89, "code": "(fn graph-tour\n  [graph-vec]\n  (letfn [(upsert-relation\n            [relation a b]\n            (if (relation a)\n              (update-in relation [a] conj b)\n              (assoc relation a [b])))\n\n          (path->relation\n            [relation [a b :as path]]\n            (-> relation\n                (upsert-relation a b)\n                (upsert-relation b a)))\n\n          (path-map->relations\n            [path-map]\n            (reduce path->relation {} path-map))\n\n          (count-connected-nodes\n            ([relations] (let [my-first\n                               (ffirst relations)] (count-connected-nodes relations my-first #{my-first} 1)))\n            ([relations next visited counter]\n             (let [all-neighbours          (relations next)\n                   [unknown-n new-v new-c] (reduce\n                                            (fn [[n v c] x]\n                                              (if (v x)\n                                                [n v c]\n                                                [(conj n x) (conj v x) (inc c)])) [[] visited counter] all-neighbours)]\n               (if (empty? unknown-n)\n                 new-c\n                 (apply max (flatten (map (fn [y] (count-connected-nodes relations y new-v new-c)) unknown-n)))))))\n\n\n          (graph-connected?\n            [path-map]\n            (let [node-count (count (distinct (mapcat identity path-map)))\n                  relations  (path-map->relations path-map)]\n              (= node-count (count-connected-nodes relations))))]\n    \n    (let [[even-c odd-c]\n          (->> (path-map->relations graph-vec)\n               (group-by #(count (second %)))\n               (map (fn [x] [(first x) (count (second x))]))\n               (reduce (fn [[even-count odd-count] [times count]]\n                         (if (even? times)\n                           [(+ even-count count) odd-count]\n                           [even-count (+ odd-count count)])) [0 0]))]\n      (println odd-c \" \" even-c \" \" (graph-connected? graph-vec)  (path-map->relations graph-vec))\n      (and (graph-connected? graph-vec) (even? even-c) (or (= 0 odd-c) (= 2 odd-c)) ))))", "user": "5b759ca8e4b047b03b2036d0"}, {"problem": 89, "code": "(fn gt [s [x y] c]\n  (let [p (.indexOf c [x y]) \n        d (if (neg? p) c (vec (concat (take p c) (drop (inc p) c))))]\n   (if (seq d)\n    (boolean (some \n      (fn [[a b]] (or\n            (if (or (nil? s) (= a s)) (gt b [a b] d) false)\n            (if (or (nil? s) (= b s)) (gt a [a b] d) false)\n            ) )\n         d))\n    true))) nil nil", "user": "5b919d9de4b0c0b3ffbd4a24"}, {"problem": 89, "code": "#(and (= (count (remove (fn [x] (= 1 (count x))) (set (map set %))))\n         (count %))\n      (if (= (count %) 1) true (every? even? (vals (frequencies (flatten %))))))", "user": "567c63f6e4b05957ce8c61bb"}, {"problem": 89, "code": "(fn [g] (let [w (vals (reduce (fn [m v] (reduce (fn [m1 v1] (update-in m1 [v1] (fnil inc 0))) m v)) {} (filter (fn [[x y]] (not= x y)) g))) v (count (filter odd? w))] (and (not (empty? w))(or (= v 2) (= v 0)))))", "user": "5c379636e4b0d62ef62d9f76"}, {"problem": 89, "code": "(fn euler-graph? [graph]\n  (let [graph-without-loops (filter (partial apply not=) graph)]\n    (if (empty? graph-without-loops)\n      false\n      (let [graph-with-both-edges (->> graph-without-loops\n                                       (map (comp vec reverse))\n                                       (concat graph-without-loops))\n            zero-degrees (->> graph-with-both-edges\n                              (map (fn [[k v]] [k 0]))\n                              (into {}))\n            degrees (->> graph-with-both-edges\n                         (map (partial apply hash-map))\n                         (apply merge-with (fn [old new] (inc old)) zero-degrees))\n            odd-parity-groups (group-by (comp odd? degrees) (keys degrees))]\n        (case (count (odd-parity-groups true))\n          (0 2) true\n          false)))))", "user": "5c506951e4b0f9f7a8770ec5"}, {"problem": 89, "code": "(letfn [(step [[node efs]]\n          (for [e (keep\n                   (fn [[e f]]\n                     (when (contains? e node)\n                       e))\n                   efs)]\n            [(or (-> e\n                     (disj node)\n                     first)\n                 ;; loopback\n                 node)\n             (if (= 1 (get efs e))\n               (dissoc efs e)\n               (update-in efs [e] dec))]))\n        (gen-seq\n          [last-gen]\n          (lazy-seq\n           (let [this-gen (mapcat step last-gen)]\n             (when (not (empty? this-gen))\n               (concat\n                this-gen\n                (gen-seq\n                 this-gen))))))]\n  (fn [edges]\n    (true? (some (fn [[node efs]]\n                   (when (empty? efs)\n                     true))\n                 (gen-seq (list [(ffirst edges)\n                                 (frequencies\n                                  (map set\n                                       edges))]))))))", "user": "54246fcce4b01498b1a71aed"}, {"problem": 89, "code": "(fn graph-tour [graph]\n  (let [reached? (fn [curr-edges] (let [num-remaining (count (remove (set curr-edges) graph))]\n                                    (or (zero? num-remaining)\n                                        (= (inc num-remaining) (count curr-edges)))))\n        gen-moves (fn [curr-edges]\n                    (let [\n                          ;; Gives us two nodes to see if we can abut against any of the remaining edges\n                          search-edge (last curr-edges)\n                          remaining-edges (remove (set curr-edges) graph)]\n                      (if (seq remaining-edges)\n                        (for [edge remaining-edges\n                              :when (or (= (first search-edge) (second edge))\n                                        (= (second search-edge) (first edge)))]\n                          (conj curr-edges edge))\n                        [curr-edges])))\n        bfs (fn [starting-lab generate-moves dest-state?]\n              (loop [already-tested #{starting-lab}\n                     last-round #{starting-lab}]\n                (let [newly-generated (mapcat generate-moves last-round)\n                      got-there (first (filter dest-state? newly-generated))]\n                  (if got-there\n                    true\n                    (if (seq newly-generated)\n                      (let [now-tested (into already-tested newly-generated)]\n                        (recur now-tested (into #{} (remove already-tested newly-generated))))\n                      false)))))]\n    (bfs [(rand-nth graph)] gen-moves reached?)))", "user": "561d8936e4b064ca9f4b16b2"}, {"problem": 89, "code": ";; http://www.4clojure.com/problem/89\n;; Graph Tour\n(fn graph-traversable?\n  ([edge-vector]\n   (let [edge-set (set edge-vector)]\n     (if (= (count edge-vector) (count edge-set))\n       (not (nil? (some true?\n                        (apply concat\n                               (for [one-edge edge-set]\n                                 (list\n                                  (graph-traversable? (first one-edge) (disj edge-set one-edge))\n                                  (graph-traversable? (second one-edge) (disj edge-set one-edge))))))))\n       false)))\n  ([node edge-set]\n   (letfn [(traverse-to?\n             [node edge]\n             (cond\n               (= node (first edge))\n               (second edge)\n               \n               (= node (second edge))\n               (first edge)\n               \n               :else \n               nil))]     \n     (if (empty? edge-set)\n       true\n       (let [r (for [one-edge edge-set]\n                                (let [other-node (traverse-to? node one-edge)\n                                      rest-edges (disj edge-set one-edge)]\n                                  (if (nil? other-node)\n                                    false\n                                    (graph-traversable? other-node rest-edges))))]\n         (not (nil? (some true? r))))))))", "user": "5c92105ce4b048ec896c59f7"}, {"problem": 89, "code": "(fn graph-tour\n  ([edge-vector]\n   (let [nodes (set (flatten edge-vector))\n         edge-map (map #(merge % (clojure.set/map-invert %))\n                       (map #(apply hash-map %) edge-vector))]\n     (not (not (some true? (map #(graph-tour edge-map '() %) nodes))))))\n  ([cands rejects current-node]\n   (let [destinations 1]\n     (if (empty? cands)\n       (if (empty? rejects)\n         true\n         false)\n       (if (nil? ((first cands) current-node))\n         (graph-tour (rest cands) (conj rejects (first cands)) current-node)\n         (graph-tour (concat (rest cands) rejects) '() ((first cands) current-node)))))))", "user": "5d1b2b7de4b02ea6f0fb697a"}, {"problem": 89, "code": "(fn [g]\n  (let [all-node (distinct (flatten g))\n        node-degree (vals (merge-with concat (group-by first g) (group-by second g)))]\n    (cond\n      (= (count all-node) 2) (and (apply distinct? (flatten g))\n                                  (= 1 (count g)))\n      (some (comp odd? count) node-degree) false\n      :else true)))", "user": "5c2836ebe4b07e362c2305d4"}, {"problem": 89, "code": "(fn [graph] (let [vertices (set (flatten (seq graph)))\n                   connected-edges (fn [v] (filter (fn [[x y]] (or (= v x) (= v y))) graph))\n                   visible-from-vertex (fn [v] (set (flatten (connected-edges v))))\n                   connected? (loop [explored #{(first vertices)}\n                                     visible (visible-from-vertex (first vertices))]\n                                (if (= vertices visible)\n                                  true\n                                  (if (= explored visible)\n                                    false\n                                    (let [new-node (first (clojure.set/difference visible explored))]\n                                      (recur\n                                        (conj explored new-node)\n                                        (clojure.set/union visible (visible-from-vertex new-node))\n                                        )))))\n                   count-odd-degree (->>\n                                      (map connected-edges vertices)\n                                      (map count)\n                                      (filter odd?)\n                                      (count))]\n               (and\n                 (or (= 0 count-odd-degree) (= 2 count-odd-degree))\n                 connected?)\n               ))", "user": "5d1a1082e4b0902706380e0e"}, {"problem": 89, "code": "(fn graph-tour [edges]\n  (letfn ((remove-first [pred [head & tail]]\n            (cond\n              (nil? head) nil\n              (pred head) tail\n              :else (cons head (remove-first pred tail))))\n          (traverse [current-node remaining-edges]\n            (if (empty? remaining-edges)\n              1\n              (let [possible-paths (filter (fn [[a b]] (or (= a current-node) (= b current-node))) remaining-edges)]\n                (if (empty? possible-paths)\n                  0\n                  (reduce (fn [result [a b :as edge]]\n                            (let [next (if (= a current-node) b a)]\n                              (+ result (traverse next (remove-first #(= % edge) remaining-edges)))))\n                          0 possible-paths))))))\n    (let [start-nodes (reduce (fn [n [from to]]\n                                (conj n from))\n                              #{} edges)\n          edges edges]\n      (map #(traverse % edges) start-nodes)\n      (< 0 (reduce + (map #(traverse % edges) start-nodes))))))", "user": "5d6042f2e4b0c9e5857d5006"}, {"problem": 89, "code": "(fn eulerian [edges]\n  (let [degrees (fn [edges]\n                  (apply merge-with + {} (for [[a b] edges\n                                               :when (not= a b)]\n                                           {a 1 b 1})))\n        gdeg (degrees edges)]\n    (and\n     (not (empty? gdeg))\n     (->> (vals gdeg) (filter odd?) count (>= 2)))))", "user": "5d67c955e4b0db5d338d15f7"}, {"problem": 89, "code": "(fn [edge]\n              (letfn [(none-top? [edge] (zero? (count (filter #(= 1 (count %)) (mapv set edge)))))\n                      (less-3-top? [edge] (> 3 (count (filter #(= 1 (count %)) (vals (group-by identity (apply concat edge)))))))\n                      (none-twice-edge? [edge] ((complement not=) (count edge) (count (set (mapv set edge)))))]\n                (and (none-top? edge) (less-3-top? edge) (none-twice-edge? edge))))", "user": "5cf72682e4b0b71b1d808a68"}, {"problem": 89, "code": "(fn euler-cycle? [edges]\n  (let [m (reduce\n            (fn [m [from to :as edge]]\n              (if (= from to) ; loop\n                (update-in m [from] #(or % 0))\n                (reduce (fn [m v] (update-in m [v] #(inc (or % 0)))) m edge)))\n            {}\n            edges)]\n    (and (every? #(> (% 1) 0) m) (< (count (filter #(odd? (% 1)) m)) 3))))", "user": "5d5e0259e4b0c9e5857d4fef"}, {"problem": 89, "code": "(fn eulerian?\n  [edges]\n  (let [connected? (let [adjacency (->> edges\n                                        (mapcat #(vector % (reverse %)))\n                                        (group-by first)\n                                        (mapcat (fn [[k v]] [k (set (map second v))]))\n                                        (apply hash-map))\n                         start-node (first (keys adjacency))\n                         component (loop [visited #{start-node}\n                                          stack [start-node]]\n                                     (if (empty? stack)\n                                       visited\n                                       (let [[next-node stack-rest] ((juxt peek pop) stack)\n                                             new-neighbors (->>\n                                                             (get adjacency next-node)\n                                                             (filter (complement visited)))]\n                                         (recur (into visited new-neighbors) (into stack-rest new-neighbors)))))]\n                     (= component (set (keys adjacency))))\n        num-odd-degree (->> edges\n                            (flatten)\n                            (group-by identity)\n                            (vals)\n                            (map count)\n                            (filter odd?)\n                            (count))]\n    (and connected? (contains? #{0 2} num-odd-degree))))", "user": "5d0bb4fae4b0cc9c91588237"}, {"problem": 89, "code": "(fn [edges]\n  (let [nodes (set (flatten (seq edges)))\n        connected (= 1 (count\n                         (reduce\n                          (fn [classes edge]\n                            (let [joined (apply clojure.set/union (filter (partial some (set edge)) classes))\n                                  independent (filter (complement (partial some (set edge))) classes)]\n                              (cons joined independent)))\n                          (map (comp set vector) nodes)\n                          edges)))\n        matching-edges (fn [node] (filter (partial some #{node}) edges))\n        odd-matching-edges (count (filter (comp odd? count) (map matching-edges nodes)))]\n    (and connected (or (zero? odd-matching-edges) (= 2 odd-matching-edges)))))", "user": "5d9c1226e4b0d3f9b434ad51"}, {"problem": 89, "code": "(fn multigraph_tour? [edge_set]\n    (let\n    [\n        symmetric_closure\n            (fn [edges]\n                (into edges (for [[a b] edges] [b a]))\n            )\n        generate_adjancy_map\n            (fn [edges]\n                (reduce (fn [ret [a b]] (assoc ret a (conj (ret a []) b)) ) {} edges)\n            )\n        is_connected_helper?\n            (fn f [[g visited total] curr]\n                (if (contains? visited curr)\n                    [g visited total]\n                    (reduce f [g (conj visited curr) (inc total)] (g curr))\n                )\n            )\n        is_connected?\n            (fn [g] (= (count g) (last (is_connected_helper? [g #{} 0] (first (first g)))) ) )\n        eulerian_tour_exists? ; check that there are exactly zero or two vertices with odd degree\n            (fn [g] (let [num_odd (count (filter #(odd? (count %)) (vals g)))] (contains? #{0 2} num_odd)))\n            \n    ]\n        (let [g (->> edge_set (symmetric_closure) (generate_adjancy_map))]\n            (and (is_connected? g) (eulerian_tour_exists? g))\n        )\n    )\n)", "user": "5db7376fe4b010eb3c36cd43"}, {"problem": 89, "code": "(letfn [(toset [s] (loop [ [f & xs] (range 0 (count s)) s1 #{}] (if (not f) s1 (recur xs (conj s1 (conj (s f) f))))))\n            (addline [s b] (if (= [] b) s (conj s b)))\n            (myremove [s a] (remove #(= a %) s))\n            (myreverse[a] [(second a) (first a) (second (rest a))])\n            \n            (connect [a b level] (if (=[] a) true (= (second a) (first b))))\n            (p123 [s node past level]\n               (cond\n                  (empty? s) true\n                  (some identity (map (fn [b] (if (connect node b (inc level)) (p123  (myremove s b) b (addline past b) (inc level)) false)) s)) true\n                  (some identity (map (fn [b] (if (connect node (myreverse b) (inc level)) (p123  (myremove s b) (myreverse b) (addline past (myreverse b)) (inc level)) false)) s)) true\n                  :else false)) \n           ]\n          (fn [cll]\n            (let [ s (toset cll)]\n             (if (> 2 (count s)) true (p123 s [] [] 1) ))))", "user": "5dc12b0ae4b0e59a23173d84"}, {"problem": 89, "code": "(fn [es]\n  (let [by-node (group-by first (concat es (map reverse es)))\n        span (fn span [ns]\n               (let [new (set (mapcat #(map last (by-node %)) ns))\n                     next (set (concat ns new))]\n                 (if (= ns next) ns (span next))))\n        connected? (fn [es] (= (span (set (first es))) (set (flatten es))))]\n    (and (connected? es) (contains? #{0 2} (count (filter (comp odd? count) (vals by-node)))))))", "user": "5db92996e4b010eb3c36cd50"}, {"problem": 89, "code": "(fn [x]\n  (let [a\n        #{[[:a :b]]\n          [[1 2] [2 3] [3 4] [4 1]]\n          [[:a :b] [:a :c] [:c :b] [:a :e]\n              [:b :e] [:a :d] [:b :d] [:c :e]\n           [:d :e] [:c :f] [:d :f]]}]\n    (contains? a x)))", "user": "5dd90651e4b0948ae9d9ad97"}, {"problem": 89, "code": "(fn t? [g]\n  (letfn [(connected? [e1 e2] (some #(= (last e1) %) e2))\n          (add-edge [t e] (if (= (last (last t)) (first e)) (conj t e) (conj t (reverse e))))\n          (tour? [t g]\n            (let [e (last t)]\n              (if (empty? g)\n                (connected? (reverse (first t)) e)\n                (some identity (map #(tour? (add-edge t %) (remove #{%} g)) (filter #(connected? e %) g))))))]\n    (= true (tour? [(first g)] (rest g)))))", "user": "5dd60c58e4b0948ae9d9ad7c"}, {"problem": 89, "code": "(fn gt [s]\n  (letfn [(vec-remove\n            [coll pos]\n            (vec (concat (subvec coll 0 pos) (subvec coll (inc pos)))))\n          (remove-first [e g]\n            (loop [c g\n                   r []]\n              (if (seq c)\n                (if (or (= (first c) e) (= (first c) (reverse e)))\n                  (concat r (rest c))\n                  (recur (rest c) (conj r (first c))))\n                r)))\n          (boo [a g]\n            (if (seq g)\n              (let [dd (filter (fn [[t1 t2]] (or (= a t1) (= a t2))) g)]\n                (if (seq dd) (map (fn [[m1 m2 :as m]] (boo (if (= a m1) m2 m1) (remove-first m g))) dd)\n                             false))\n              true))\n          ]\n    (= true (first (filter true? (flatten (for [i (range (count s))]\n                                            (list (boo (first (s i)) (vec-remove s i))\n                                                  (boo (second (s i)) (vec-remove s i))))))))))", "user": "529dfc6de4b04e0c58e87b8a"}, {"problem": 89, "code": "(fn has-eulerian-path [y]\n  (letfn [\n          (near-edges [[_ y :as e] g]\n            (if (nil? e) (into (set g) (map reverse g))\n                (map (fn [[a b]] (if (= y b) [b a] [a b])) (filter #((set %) (last e)) g))))\n          (remove-edge [e g]\n            (let [[f n] (split-with #(and (not= e %) (not= (reverse e) %)) (vec g))] \n              (apply concat [f (next n)])))\n          \n          (next-edge [v g]\n            (let [n (near-edges v g)]    \n              (do (prn v g n)\n                  (if (empty? n) \n                    (empty? g)          \n                    (some #(next-edge % (remove-edge % g)) n)))))          \n          ]\n    (true? (next-edge nil y))))", "user": "5d9c9446e4b0eb781811cdae"}, {"problem": 89, "code": "(fn p-89 [g] (let [\n                    p-89-eulerian-path-possible? (fn p-89-eulerian-path-possible? [g]\n                                                   (let [odd-counts \n                                                         (->> g\n                                                              (reduce concat)\n                                                              (group-by identity)\n                                                              (vals)\n                                                              (map count)\n                                                              (filter odd?)\n                                                              (count))]\n                                                     (or (= odd-counts 0) (= odd-counts 2))))\n\n                    p-89-connected? (fn p-89-connected?\n                                      ([g] (p-89-connected? (vec (rest g)) (set  (first g))))\n                                      ([g seen-vertices-set]\n;                                       (println \"== Got G: \" g)\n ;                                      (println \"== Got seen vertices: \" seen-vertices-set)\n                                       (let [rotate-vec (fn [v] (conj (vec (rest v)) (first v)))\n                                             connected-edge? (fn [[v1 v2]] (or (seen-vertices-set v1) (seen-vertices-set v2)))\n                                             next-edge (first g)]\n                                         (cond (empty? g) true ; no more to include\n                                               (not (some connected-edge? g)) false ; other edges don't connect\n                                               (connected-edge? next-edge)\n                                               (p-89-connected? (rest g)\n                                                                (conj seen-vertices-set\n                                                                      (first next-edge)\n                                                                      (second next-edge)))\n                                               :else (p-89-connected? (rotate-vec g) seen-vertices-set)))))\n                    \n                    ]\n                 (and (p-89-eulerian-path-possible? g)\n                      (p-89-connected? g))))", "user": "5bfc9037e4b0bdcf453d15f2"}, {"problem": 89, "code": "(fn eulerian [edges]\n  (let [degrees (fn [edges]\n                  (apply merge-with + {} (for [[a b] edges\n                                               :when (not= a b)]\n                                           {a 1 b 1})))\n        gdeg (degrees edges)]\n    (and\n     (not (empty? gdeg))\n     (->> (vals gdeg) (filter odd?) count (>= 2)))))", "user": "5e00b6e7e4b0a607a9a45d2b"}, {"problem": 89, "code": "(fn graph-tour? [coll]\n  (letfn [(get-nodes [edges] (set (flatten (vec edges))))\n          (get-edge-map [edges] (merge (into {} edges) (into {} (map (comp vec reverse) edges))))\n          (get-edges-from-node [node edges] (set (concat (filter #(= (first %) node) edges) (filter #(= (second %) node) edges))))\n          (get-edges-from-nodes [nodes edges] (set (mapcat #(get-edges-from-node % edges) nodes)))\n          (connected-nodes [edges]\n                           (loop [toured-nodes #{(first (get-nodes edges))}\n                                  rest-edges (set edges)]\n                             (let [expand-edges (get-edges-from-nodes toured-nodes rest-edges)\n                                   expand-nodes (get-nodes expand-edges)]\n                               (cond\n                                 (empty? expand-edges) toured-nodes\n                                 :else (recur (clojure.set/union toured-nodes expand-nodes) (clojure.set/difference rest-edges expand-edges))))))\n          (all-connected? [edges] (= (connected-nodes edges) (get-nodes edges)))\n          (one-tour? [edges]\n                     (->>\n                       (get-nodes edges)\n                       (map (fn [e] (concat (filter #(= (first %) e) coll) (filter #(= (second %) e) coll))))\n                       (map count)\n                       (#(boolean (#{2 0} (count (filter odd? %)))))))]\n\n    (and (all-connected? coll) (one-tour? coll))\n    ))", "user": "5e0d948fe4b099d064962f98"}, {"problem": 89, "code": "(fn [edges]\n  (let [state {:edges edges\n               :vertex nil}\n        solved? (fn [state]\n                  (empty? (:edges state)))\n        make-move (fn [state [e1 e2]]\n                    (when state\n                      (let [[s1 s2] (split-with #(not= [e1 e2] %) (state :edges))\n                            edges   (concat s1 (rest s2))]\n                        (assoc state\n                          :edges edges\n                          :vertex (if (= e1 (state :vertex))\n                                    e2\n                                    e1)))))\n        generator (fn [state]\n                    (if (state :vertex)\n                      (let [traversals (filter #(some #{(state :vertex)} %) (state :edges))]\n                        (map #(make-move state %) traversals))\n                      (map #(assoc state :vertex %) (distinct (flatten (state :edges))))))\n        solver (fn [state generator solved?]\n                 (let [solve-state (fn find-fut-states [state]\n                                     (let [fut-states (for [gen-state (generator state)\n                                                            fut-state (find-fut-states gen-state)] fut-state)]\n                                       (if (solved? state)\n                                         (cons state fut-states)\n                                         fut-states)))]\n                   (solve-state state)))\n        ]\n    (boolean (first (solver state generator solved?)))))", "user": "590b055ae4b047aa04b199c9"}, {"problem": 89, "code": "(fn [g]\n    (let [graph (into #{} (map (fn [i edge] [i (sort edge)]) (map vector (range (count g))) g))]\n      (boolean\n       (some\n        (fn [starting-vertex]\n          ((fn step [visited\n                     not-visited\n                     current-vertex]\n             (if (= graph (set visited))\n               true\n               (let [moves (filter (fn [[i [a b]]]\n                                     (or (= a current-vertex) (= b current-vertex))) not-visited)]\n                 (boolean\n                  (some #(step (conj visited %) (disj not-visited %) (let [edge (second %)\n                                                                           start (first edge)\n                                                                           end (second edge)]\n                                                                       (if (= start current-vertex)\n                                                                         end\n                                                                         start))) moves)))))\n           [] graph starting-vertex)) (apply concat (map second graph))))))", "user": "5d236215e4b02ea6f0fb6a09"}, {"problem": 89, "code": "(let [neighbors (fn [edge-list] (loop [remaining-edges edge-list current-neighbors {}] (if (empty? remaining-edges) current-neighbors (let [[source destination] (first remaining-edges)] (recur (rest remaining-edges) (merge-with into current-neighbors (if (= source destination) {source [destination]} {source [destination] destination [source]})))))))\n      component-set (fn [vertex neighbor-list] (loop [dfs-stack (list vertex) visited #{}] (if (empty? dfs-stack) visited (if (contains? visited (peek dfs-stack)) (recur (pop dfs-stack) visited) (recur (into (pop dfs-stack) (get neighbor-list (peek dfs-stack) [])) (conj visited (peek dfs-stack)))))))\n      tourable? (fn [edge-list] (let [neighbor-list (neighbors edge-list)] (and (-> neighbor-list (vals) (#(filter (comp odd? count) %)) (count) (<= 2)) (->> neighbor-list (component-set (ffirst edge-list)) (count) (= (count neighbor-list))))))\n      ] tourable?)", "user": "5e1cc888e4b0dc959400853d"}, {"problem": 89, "code": "(fn [g]\n    (letfn [(conn? [g]\n              (let [all (-> g seq flatten set)]\n                (loop [r #{(first all)}]\n                  (let [r' (reduce (fn [r [a b]]\n                                     (if (or (r a) (r b))\n                                       (-> r (conj b) (conj a))\n                                       r))\n                                   r g)]\n                    (if (= r r')\n                      (= all r)\n                      (recur r'))))))\n            (degree [g k]\n              (->> g\n                 (filter #((set %) k))\n                 count)\n              )\n            ]\n      (if (conn? g)\n        (let [nodes (set (flatten g))\n              degrees (map (partial degree g) nodes)\n              odd-degrees (filter #(= 1 (rem % 2)) degrees)\n              ]\n          (get {0 true 2 true} (count odd-degrees) false)\n          )\n        false)\n      )\n    )", "user": "583048d9e4b051871117c007"}, {"problem": 89, "code": "(fn walk \n  ([g] (true? (or (some #(walk g %) g) (some #(walk g %) (map (comp vec reverse) g)))))\n  ([g e]\n   \t(let [gg (group-by identity g)\n          g' (apply concat (vals (assoc gg e (drop 1 (get gg e)))))\n          rg' (map (comp vec reverse) g')]\n      (println e (sort g'))\n      (if (empty? g')\n        true\n   \t\t(or (some #(walk g' %) (filter #(= (second e) (first %)) g'))\n            (some #(walk rg' %) (filter #(= (second e) (first %)) rg')))))))", "user": "5e3a25d4e4b01d43a70e8dde"}, {"problem": 89, "code": "(fn euler? [edges]\n  (letfn [(connective? \n    ([es]\n     (if (nil? (rest es)) \n       true \n       (connective? (rest es) (apply conj #{} (first es)))))\n    ([es cs] \n     (letfn [(t [[a b]] (or (cs a) (cs b)))]\n       (cond \n         (empty? es) true\n         (= (remove t es) es) false\n         :else (connective? (remove t es) \n                            (apply conj cs (flatten (filter t es))))))))]\n    (if (connective? edges)\n      (let [pstats (-> edges (flatten) (frequencies))\n            nodd (count (filter odd? (vals pstats)))]\n        (<= nodd 2))\n      false)))", "user": "5e2549c8e4b05b4b0151615f"}, {"problem": 89, "code": "(fn [v]\n  (let [vv (map #(conj (nth v %) %) (range (count v)))\n        s (set vv)\n        find-rests \n        (fn [n r]\n         (let [first-ch (filter #(= n (first %)) r)\n               first-res (map #(do {:n (second %) :r (disj r %)}) first-ch)\n               second-ch (filter #(= n (second %)) r)\n               second-res (map #(do {:n (first %) :r (disj r %)}) second-ch)\n               res (concat first-res second-res)] \n          res))\n        tour?\n        (fn tour? [n s]\n         (if (empty? s)\n          true  \n          (let [children (find-rests n s)]   \n           (if (empty? children)\n            false\n            (some true? (map #(tour? (:n %) (:r %)) children))))))]\n   (true? (some true? (concat\n                       (map #(tour? (first %) (disj s %)) s)\n                       (map #(tour? (second %) (disj s %)) s))))))", "user": "592334c7e4b0a390037439ee"}, {"problem": 89, "code": "(fn [edges]\n   (letfn [(remove-one [coll target]\n             (loop [acc ()\n                    coll coll]\n               (if (empty? coll) acc\n                   (let [[h & t] coll]\n                     (if (= h target)\n                       (concat acc t)\n                       (recur (cons h acc) t))))))\n           (proceed [from rest-edges]\n             (or (empty? rest-edges)\n                 (some (fn [[l r :as edge]]\n                         (let [next (if (= from l) r l)]\n                           (proceed next (remove-one rest-edges edge))))\n                       (filter (fn [[l r]] ((conj #{l} r) from)) rest-edges))))]\n     (let [verts (reduce (fn [acc [l r]] (conj acc l r)) #{} edges)]\n       (true? (some #(proceed % edges) verts)))))", "user": "5e3ef7d4e4b01d43a70e8e2d"}, {"problem": 89, "code": "(fn [edges]\n  (let [v (zipmap (distinct (flatten edges)) (repeat 0))\n        degrees (vals (reduce\n                        (fn [r [a b]]\n                          (if (not= a b)\n                            (-> r\n                                (update-in [a] inc)\n                                (update-in [b] inc))\n                            r))\n                        v edges))\n        odd (count (filter odd? degrees))\n        connected? (fn [edges]\n                     (let [find (fn [union k] (or (some #(if (contains? % k) %) union) #{k}))]\n                       (= 1 (count\n                              (reduce (fn [r [a b]]\n                                        (let [ua (find r a)\n                                              ub (find r b)]\n                                          (-> r\n                                              (disj ua ub)\n                                              (conj (clojure.set/union ua ub)))))\n                                      #{} edges)))))]\n    (and\n      (or (= odd 2) (= odd 0))\n      (connected? edges))))", "user": "5ca2ca9fe4b048ec896c5b9c"}, {"problem": 89, "code": ";; problem 89\n;;\n;; this solution finds the path. It is an order of magnitude slower than jafingerhut's solution\n;; using Eulerian path theorem. Let this be a lesson.\n;;\n;; stop when:\n;; 1. edge visited more than once - false\n;; 2. all nodes visited. - true\n;;\n;; first node is target, is target in visited, if yes fail\n;; if no nodes are in rest - success.\n;; for all nodes in rest that target can match, recurse using that node as new target\n\n\n  (fn [ls]\n    (letfn [(gt-helper [target ls prevs all-nodes]\n              (cond\n                (not= (count ls) (count (set (map set ls)))) false\n                (= prevs all-nodes) true\n                (empty? ls) (if (= (conj prevs target) all-nodes) true false)\n                (contains? prevs target) false\n                :else\n                (let [res \n                      (for [n ls]\n                        (let [fst (first n)\n                              snd (second n)]\n                          (cond (= target fst) (gt-helper snd (remove #{n} ls) (conj prevs fst) all-nodes)\n                                (= target snd) (gt-helper fst (remove #{n} ls) (conj prevs snd) all-nodes)\n                                :else false)))]\n                  (if (some true? res) true false))))]\n      (let [fst (first ls)]\n        (gt-helper (first fst) (rest ls) #{(second fst)} (set (flatten ls))))))", "user": "5da71eaee4b000c986472c15"}, {"problem": 89, "code": "(fn [s]\n  (let [nodes (fn [s] (set (reduce concat s)))\n        connected? (fn [s] (let [relations (fn [s] (clojure.set/union s (set (mapv reverse s))))\n               partition-nodes (fn [nodes] (map (comp set list) nodes))\n               partition-merge (fn [part a b]\n                                 (conj (filter #(not (or (contains? % a) (contains? % b))) part)\n                                       (apply clojure.set/union\n                                              (concat (filter #(contains? % a) part)\n                                                      (filter #(contains? % b) part)))))\n               add-link (fn [[part tree] link]\n                          (let [new (partition-merge part (first link) (second link))]\n                            (if (< (count new) (count part))\n                              [new (cons link tree)]\n                              [new tree])))\n               make-tree (fn [s] (second (reduce add-link [(partition-nodes (nodes s)) '()] (relations s))))]\n           (= (+ (count (make-tree s)) 1) (count (nodes s)))))\n        vertices (fn [s] (->> s\n                              (flatten)\n                              (group-by identity)\n                              (map (fn [[k v]] (assoc {} k (count v))))\n                              (apply merge)))\n        countVertices (fn [s pred] (count (filter #(pred (val %)) (vertices s))))]\n  (if (not (connected? s)) false\n      (if (= (count (nodes s)) (countVertices s even?)) true\n            (if (= (countVertices s odd?) 2) true false)))))\n;;cf. problem 91 Graph Connectivity", "user": "5e13a6b7e4b099d064963001"}, {"problem": 89, "code": "(fn [graph]\n  (let [m (reduce (fn [m [n1 n2]]\n                    (-> m\n                        (update-in [n1 n2] #(if % (inc %) 1))\n                        (update-in [n2 n1] #(if % (inc %) 1))))\n                  {}\n                  graph)]\n    (letfn [(unhook [m n o]\n              (let [m' (-> m\n                           (update-in [n o] #(if % (dec %) 0))\n                           (update-in [o n] #(if % (dec %) 0)))]\n                (->> m'\n                     (map (fn [[k v]] [k (into {} (filter (fn [[_ nv]] (not= nv 0)) v))]))\n                     (filter (fn [[k v]] (not (empty? v))))\n                     (into {}))))\n            (follow [m n]\n              (if (empty? m)\n                true\n                (if-let [nns (keys (m n))]\n                  (reduce #(or %1 %2) false (map #(follow (unhook m n %) %) nns))\n                  false)))]\n      (follow m (key (first m))))))", "user": "5eb1c786e4b00a66d4a95201"}, {"problem": 89, "code": "(fn [coll]\n  (let [incident (reduce (partial merge-with clojure.set/union)\n                         (flatten (map (fn [[x y]] [{x #{y}} {y #{x}}]) coll)))\n        vertices (into #{} (keys incident))\n        a-vertex (first vertices)\n        find-vertices (fn [to-explore found]\n                        (if (empty? to-explore)\n                          found\n                          (let [new (clojure.set/difference (incident (first to-explore)) found)]\n                            (recur (concat (rest to-explore) new) (clojure.set/union found new)))))\n        connected? (= vertices (find-vertices (list a-vertex) #{a-vertex}))]\n    (and connected?\n         (->> (flatten coll)\n              frequencies\n              vals\n              (filter odd?)\n              count\n              (#(or (= % 2) (= % 0)))))))", "user": "5ec6de19e4b08d0ec38692da"}, {"problem": 89, "code": "(fn __ [g]\n  (let [connectsto (fn [n] (distinct (for [[f t] g :when (= f n)] t)))\n        apass (fn [seen] (distinct (into seen (apply concat (map connectsto seen)))))\n        allnodes (set (distinct (flatten g)))\n        reachable \n        (loop [seen [(ffirst g)]]\n          (if (= (set seen) (set (apass seen)))\n            (set seen)\n            (recur (apass seen))))]\n    (and (= allnodes reachable)\n         (contains? #{0 2}\n                    (count (filter odd? (vals (frequencies (flatten g)))))))))", "user": "4e8768f6535dceadca469850"}, {"problem": 89, "code": "(fn [edges]\n  (let [graph (apply merge-with \n                     into  \n                     (mapcat\n                      (fn [i [k v]]\n                        [{k #{{:node v :idx i}}} \n                         {v #{{:node k :idx i}}}])\n                      (range (count edges))\n                      edges))\n        visit (fn f [n visitor]\n                (loop [[x & xs] (vec (graph n))]\n                  (if (every? #(visitor (:idx %)) (graph n))\n                    (every? identity visitor)\n                    (if (visitor (:idx x))\n                      (recur xs)\n                      (f (:node x) (assoc visitor (:idx x) true))))))]\n    ((complement not-any?)\n     #(visit % (vec (repeat (count edges) false)))\n     (set (apply concat edges)))))", "user": "5dc88a38e4b02f9375f4e1db"}, {"problem": 89, "code": "(fn eulerian [edges]\n  (let [degrees (fn [edges]\n                  (apply merge-with + {} (for [[a b] edges\n                                               :when (not= a b)]\n                                           {a 1 b 1})))\n        gdeg (degrees edges)]\n    (and\n     (not (empty? gdeg))\n     (->> (vals gdeg) (filter odd?) count (>= 2)))))", "user": "51316a63e4b0431ba07e7feb"}, {"problem": 89, "code": "(fn [graph] (letfn [(relate [inp] (reduce (fn [r [a b]] (let [ar (assoc r a (conj (r a []) b))] (assoc ar b (conj (r b []) a)))) {} inp))\n                    (remove-first [s elem] (concat [] (take-while #(not= elem %) s) (rest (drop-while #(not= elem %) s))))\n                    (erase-edge [connected a b] (assoc (assoc connected a (remove-first (connected a) b)) b (remove-first (connected b) a)))\n                    (connect [links]\n                      (let [maxa (apply max (map count (keys links)))\n                            newlinks (reduce (fn [r [ak av]] \n                                               (let [l (last ak)]\n                                                 (reduce (fn [nr rel]\n                                                           (assoc nr (conj ak rel)\n                                                                  (erase-edge av l rel)))\n                                                         r (av l))))\n                                             {}links)\n                            growths (map count (keys newlinks))\n                            newmax (if (> (count growths) 0) (apply max growths) 0)]\n                        (if (> newmax maxa) (recur newlinks) links)))\n                    (graph-tour? [inputs]\n                      (let [related (relate inputs)\n                            connections (map #(assoc {} (vector %) related) (keys related))]\n                        (loop [f (first connections)\n                               rst (rest connections)]\n                          (if (nil? f)\n                            false\n                            (let [c (connect f)\n                                  s (some (fn [[k remainders]]\n                                            (zero? (reduce (fn [ct [p remains]] (+ ct (count remains)))\n                                                           0 remainders)))\n                                          c)]\n                              (if s true (recur (first rst) (rest rst))))))))]\n    (graph-tour? graph)))", "user": "5ef5ee81e4b07c55ae4a054a"}, {"problem": 89, "code": "(fn tourable? [graph]\n  (letfn [(odd-degrees [x] (->> x\n                            (flatten)\n                            (frequencies)\n                            (map second)\n                            (filter odd?)\n                            (count)))\n          (build-paths [root edge-m to-visit]\n            ;head = value, tail = children\n            (if-let [children (seq (clojure.set/intersection (get edge-m root) to-visit))]\n              (list root (mapcat #(build-paths % edge-m (disj to-visit %)) children))\n              (list root)))\n          (connected? [x]\n            (let [nodes (set (distinct (flatten graph)))\n                  edge-m (reduce\n                          (fn [m [a b]]\n                            (merge-with into m {a #{b}} {b #{a}}))\n                          {}\n                          graph)\n                  root (first nodes)]\n              (-> (build-paths root edge-m (disj nodes root))\n                  (flatten)\n                  (distinct)\n                  (count)\n                  (= (count nodes)))))]\n    (and (connected? graph)\n         (boolean (some (partial = (odd-degrees graph)) [0 2])))))", "user": "5b7f2d75e4b047b03b203768"}, {"problem": 89, "code": "(fn has-euler-cycle? [adjacencies]\n  (let [add-adj (fn [m [a b]]\n                  (update-in m [a] (fnil conj '()) b))\n        adjacencies (reduce #(-> %1 (add-adj %2) (add-adj (reverse %2)))\n                            {}\n                            adjacencies)\n        is-connected? (fn [adjacencies]\n                        (loop [visited #{}\n                               [h & more] (list (first (keys adjacencies)))]\n                          (if (nil? h)\n                            false\n                            (let [neighbors (filter (complement visited)\n                                                    (adjacencies h))\n                                  new-visited (conj visited h)]\n                              (or (= new-visited (set (keys adjacencies)))\n                                  (recur new-visited (into more neighbors)))))))\n        degree (fn [a adjs] (count (filter #(not= % a) adjs)))\n        odd-degreed (count (filter odd? (map #(apply degree %) adjacencies)))]\n    (and (is-connected? adjacencies)\n         (or (= 0 odd-degreed)\n             (= 2 odd-degreed)))))", "user": "5ca14eb1e4b048ec896c5b7d"}, {"problem": 89, "code": "(fn graph-tour [g]\n  (letfn [(target [[_ t]] t)\n          (source [[s _]] s)]\n    (let [g (map-indexed #(with-meta %2 {:id %1}) g)\n          num-edges (count g)\n          g (into g (map #(with-meta [(target %) (source %)] (meta %)) g))\n          g (group-by first g)]\n      (letfn [(id [e] (:id (meta e)))\n              (walk [n visited]\n                (letfn [(visit [e] (conj visited (id e)))\n                        (visited? [e] (when (visited (id e)) e))\n                        (not-visited? [e] (when (not (visited? e)) e))]\n                  (or\n                    (== (count visited) num-edges)\n                    (when-let [non-visited (keep not-visited? (g n))]\n                      (some #(walk (target %) (visit %)) non-visited)))))]\n        (boolean (some #(walk % #{}) (keys g)))))))", "user": "5f300f28e4b033932238a682"}, {"problem": 89, "code": "(fn [table] \n  (if (empty? (filter #(= 1 (count (set %))) table))\n      (< (count (filter odd? (vals (frequencies (flatten table))))) 3)\n\t  false))", "user": "5951190be4b066ee0a44aea4"}, {"problem": 89, "code": "(fn [bridges]\n  (let [degrees  (fn [bridges]\n                   (reduce\n                    (fn [islands bridge] ; destructure the next bridge\n                      (let [degree1 (or (get islands (first bridge)) 0) ; island lready collected, use value\n                            degree2 (or (get islands (second bridge)) 0)] ; if not, init with zero\n                        (if (= (first bridge) (second bridge)) ; self-connected nodes are excluded \n                          islands\n                          (assoc islands (first bridge) (inc degree1) (second bridge) (inc degree2)))))\n                    {} ; start with empty islands\n                    bridges))]\n    (and (not (= {} (degrees bridges)))\n     (>= 2 (count (filter odd? (vals (degrees bridges))))))))", "user": "5bf9d9b7e4b0bdcf453d15c4"}, {"problem": 89, "code": "(fn tourable?\n  [graph]\n  (let [valid-edges? (fn [graph]\n                       (let [odd-degree-nodes-num\n                             (count (filter (fn [[_ freq]] (odd? freq))\n                                            (seq (frequencies (reduce concat graph)))))]\n                         (println odd-degree-nodes-num)\n                         (or (= odd-degree-nodes-num 0)\n                             (= odd-degree-nodes-num 2))))\n        adj-list (reduce (fn [acc [a b]]\n                           (update-in\n                             (update-in acc [a] (fnil conj #{}) b)\n                             [b] (fnil conj #{}) a)) {} graph)\n        fixed-point (fn fixed-point [f x]\n                      (if (= (f x) x)\n                        x\n                        (fixed-point f (f x))))\n        connected (= (fixed-point (fn [s]\n                                        (reduce (fn [acc node]\n                                                  (into acc (get adj-list node))) s s))\n                                      #{(first (first graph))})\n                         (set (reduce concat graph)))]\n    (and (valid-edges? graph)\n         connected))\n  )", "user": "5f29837ee4b033932238a64f"}, {"problem": 89, "code": "(fn [edges]\n    (letfn [\n        (del-nth [n coll]\n            (keep-indexed #(if (not= %1 n) %2) coll))\n        \n        (reachable [k coll] \n            (keep-indexed (fn [i [a b]] (if (or (= a k) (= b k)) i)) coll))\n        \n        (next-step [k es]\n            (loop [ns (reachable k es)]\n                (if (empty? ns) false\n                    (let [ik  (first ns)\n                          [a b] (nth es ik) \n                          nk  (if (= b k) a b) ]\n                        (if (find-tour nk (del-nth ik es))\n                                true\n                                (recur (rest ns)))))))\n        \n        (find-tour [k coll]\n            (if (empty? coll)\n                true\n                (next-step k coll)))\n        \n        ]\n        (find-tour (first (first edges)) edges)))", "user": "5eff6c0ee4b0cf489e8d7f11"}, {"problem": 89, "code": "(fn can-tour? [edges]\n  (let [vectors (set (apply concat edges))\n        tour (fn tour [node untraveled-edges]\n               (or (empty? untraveled-edges)\n                   (some true? (map-indexed (fn [i, edge]\n                                              (cond (some #(= node %) edge)\n                                                    (let [[a b] edge\n                                                          target (if (= a node) b a)\n                                                          remaining-edges (concat (subvec untraveled-edges 0 i) (subvec untraveled-edges (inc i)))]\n                                                      (tour target (vec remaining-edges)))\n                                                    :else false)) untraveled-edges))))]\n    (boolean (some #(true? %) (map #(tour % edges) vectors)))))", "user": "5ea6fe98e4b00a66d4a951b2"}, {"problem": 89, "code": "(fn graph-tour? [edges]\n  (let [connections          (reduce (fn [connections edge]\n                                       (let [a           (first edge)\n                                             b           (second edge)\n                                             connections (assoc connections a (concat (get connections a) [b]))]\n                                         (assoc connections b (concat (get connections b) [a]))))\n                                     {}\n                                     edges)\n        vertices-with-edges  (filter (fn [[_ v]] (> (count v) 0)) connections)\n        get-visited-vertices (fn get-visited-vertices [visited-vertices [k v]]\n                               (let [visited-vertices (conj visited-vertices k)]\n                                 (reduce (fn [visited-vertices vertex]\n                                           (get-visited-vertices visited-vertices [vertex (get connections vertex)]))\n                                         visited-vertices\n                                         (filter #(not (contains? visited-vertices %)) v))))\n        visited-vertices     (get-visited-vertices #{} (first vertices-with-edges))\n        odd-degree-vertices  (count (filter (fn [[_ v]] (odd? (count v))) connections))]\n    (and (= (count visited-vertices) (count vertices-with-edges))\n         (or (= 0 odd-degree-vertices)\n             (= 2 odd-degree-vertices)))))", "user": "5dc53ddee4b02f9375f4e1bd"}, {"problem": 89, "code": "(fn [edges]\n    (letfn [(one-tour? [coll]\n                       (->>\n                        (distinct (flatten coll))\n                        (map (fn [e] (concat (filter #(= (first %) e) coll) (filter #(= (second %) e) coll))))\n                        (map count)\n                        (#(boolean (#{2 0} (count (filter odd? %)))))))\n\n            (one-connected [edges]\n                           (loop [es edges\n                                  nds #{}]\n                             (cond\n                               (empty? es) true\n                               (empty? nds) (recur (set (rest es)) (apply conj nds (first es)))\n                               :else (let [e (some (fn [[a b]] (when (or (nds a) (nds b)) [a b])) es)]\n                                       (if e\n                                         (recur (set (disj es e)) (apply conj nds e))\n                                         false)))))]\n      (and\n       (one-connected edges)\n       (one-tour? edges)))\n    )", "user": "5fa74b82e4b0fa27300f3dda"}, {"problem": 89, "code": "(fn [xs]\n  (loop [res []\n         stack (map #(vector res %) (apply conj '() xs))\n         remain xs]\n    (cond\n      (= (count xs) (count res)) true\n      (empty? stack) false\n      (= res (first (first stack))) (let [e (second (first stack))\n                                          e-directed (if (= (first e) (second (last res)))\n                                                       e\n                                                       (reverse e))\n                                          remove-once (fn [pred coll]\n                                                        ((fn inner [coll]\n                                                           (lazy-seq\n                                                            (when-let [[x & xs] (seq coll)]\n                                                              (if (pred x)\n                                                                xs\n                                                                (cons x (inner xs))))))\n                                                         coll))\n                                          new-res (conj res e-directed)\n                                          new-remain (remove-once (set [e (reverse e)]) remain)\n                                          next-edges (fn [e es res]\n                                                       (->> (filter #(or (= (last e) (first %))\n                                                                         (= (last e) (second %))) es)\n                                                            (map #(vector res %))))\n                                          new-stack (let [next-es (next-edges e-directed new-remain new-res)]\n                                                      (if (empty? next-es)\n                                                        (rest stack)\n                                                        (apply conj (rest stack) (next-edges e-directed new-remain new-res))))]\n                                      (recur new-res new-stack new-remain))\n      :else (recur (vec (drop-last res)) stack (conj remain (last res))))))", "user": "5f5358b7e4b0a0bc16850a77"}, {"problem": 89, "code": "#(case %\n   [[:a :b]] true\n   [[1 2] [2 3] [3 4] [4 1]] true\n   [[:a :b] [:a :c] [:c :b] [:a :e]\n              [:b :e] [:a :d] [:b :d] [:c :e]\n              [:d :e] [:c :f] [:d :f]] true\n   false)", "user": "5e8ce2fee4b0cb0169546328"}, {"problem": 89, "code": "(fn [graph] \n    (let [nodes (reduce clojure.set/union (map set graph))\n          n (count nodes)\n          edges (filter (fn [[s t]] (not= s t)) graph)\n          degree (into {} (map (fn [v]\n                                    (let [od (count (filter (fn [[s t]] (= s v)) edges))\n                                          id (count (filter (fn [[s t]] (= t v)) edges))\n                                          d (+ od id)] [v d]))\n                               nodes))\n          v0 (first nodes)]\n        (letfn [(succ [v] (->> edges\n                               (filter (fn [[s t]] (#{s t} v)))\n                               (map (fn [[s t]] (if (= v s) t s)))\n                               (set)))\n                (reachable [v]\n                    (loop [pending [v]\n                           acc #{v}]\n                        (if (empty? pending)\n                            acc\n                            (let [v (first pending)\n                                  vs (set (filter #(not (acc %)) (succ v)))\n                                  pending' (concat vs (rest pending))\n                                  acc' (clojure.set/union acc vs)]\n                                (recur pending' acc')))))]\n            (and (= (reachable v0) nodes)\n                 (let [grouped-degree (group-by (fn [[k v]] (odd? v)) degree)\n                       n-odd-degrees (count (grouped-degree true))]\n                     (or (= n-odd-degrees 0) (= n-odd-degrees 2)))))))", "user": "600ae927e4b074f607df6689"}, {"problem": 89, "code": "(fn hmmm [s]\n  (if (= (count s) 1) \n    true \n    (letfn [\n            (get-nodes [s]\n              (set (flatten s))\n              )\n            (node-occ-gte-2-in-the-seq [n s]\n              (loop [tail s ct 0]\n                (if (= ct 2)\n                  true \n                  (if (seq tail)\n                    (if (some #(= n %) (first tail))\n                      (recur (rest tail) (inc ct))\n                      (recur (rest tail) ct)\n                      )\n                    false))\n                )\n              )\n            (each-node-in-gte-2 [nodes s]\n              (loop [tail nodes]\n                (if (seq tail)\n                  (if (node-occ-gte-2-in-the-seq (first tail) s)\n                    (recur (rest tail))\n                    false\n                    )\n                  true\n                  )\n                )\n              )\n            (remove-rev-dupes [s]\n              (loop [tail s res []]\n                (if (seq tail)\n                  (if (some #(= (reverse (first tail)) %) s)\n                    (recur (rest tail) res)\n                    (recur (rest tail) (conj res (first tail)))\n                    )\n                  res\n                  )\n                )\n              )\n             \n            ]\n      (let [nodes (get-nodes s)]\n        (each-node-in-gte-2 nodes (remove-rev-dupes (set s)))\n        )))\n)", "user": "5ff676a9e4b06df49cee1497"}, {"problem": 89, "code": "(fn [edges]\n  (let [vs (into #{} (apply concat edges))]\n    (letfn [(eliminate [x xs]\n              (cond (empty? xs) nil\n                    (= x (first xs)) (rest xs)\n                    :else (cons (first xs) (eliminate x (rest xs)))))\n            (neighbors [v remains]\n              (mapcat (fn [[x y]]\n                        (cond (= x v) (list [y (eliminate [x y] remains)])\n                              (= y v) (list [x (eliminate [x y] remains)])\n                              :else nil)) remains))\n            (iter [start remains]\n              (let [nexts (neighbors start remains)]\n                (cond (and (empty? nexts) (empty? remains)) true\n                      (empty? nexts) false\n                      :else (reduce #(or % %2) (map #(apply iter %) nexts)))))]\n      (reduce #(or % %2) (map #(iter % edges) vs)))))", "user": "58f98231e4b0438e51c2cf4c"}, {"problem": 89, "code": "(fn lol [gph] \n  (let [f (fn [m [a b]] (->> (into (m a #{a}) (m b #{b}))\n                             (#(reduce (fn [akk x] (assoc akk x %)) m %)) ))\n        dic (reduce f {} gph)\n        con? (apply = (vals dic))\n        nodes (distinct (flatten gph))        \n        dic2 (frequencies (flatten gph))\n        numOdd (count (filter odd? (vals dic2)))        \n        idk (or (= 2 numOdd) (= 0 numOdd))] \n    (and con? idk)))", "user": "6011b89ee4b074f607df66bc"}, {"problem": 89, "code": "(fn [edges]\n  (let [start-points (distinct (apply concat edges))\n        \n        not-nil? (comp not nil?)\n        \n        remove-once (fn [coll n]\n                      (loop [[x & xs] coll\n                             result []]\n                        (cond\n                          (nil? x) result\n                          (or (= x n) \n                              (= x (reverse n))) (into result xs)\n                          :else (recur xs (conj result x)))))\n                            \n        valid? (fn valid? [point edges]\n                 (if (empty? edges)\n                   true\n                   (let [redirect-edges (map #(if (= point (second %)) (reverse %) %) edges)\n                         viable-edges (filter #(= point (first %)) redirect-edges)]\n                     (if (empty? viable-edges)\n                       false\n                       (not-nil? (some #(valid? (second %) (remove-once redirect-edges %)) viable-edges))))))]\n    (not-nil? (some #(valid? % edges) start-points))))", "user": "5cb41c40e4b026601754b911"}, {"problem": 89, "code": "(fn graph-tour? [edges] \n  (let [vertices (set (apply concat edges))\n        degrees (map count (vals (group-by identity (apply concat edges))))\n        connected (loop [queue [(first vertices)]\n                         seen #{(first vertices)}]\n                    (let [node (peek queue)\n                          neighbours (apply disj (set (apply concat (filter #(some #{node} %) edges))) seen)\n                          new-queue (if (empty? neighbours) (pop queue) (apply conj (pop queue) neighbours))\n                          new-seen (if (empty? neighbours) seen (apply conj seen neighbours))]\n                      (if (and (empty? new-queue) (= 1 (count queue))) (= vertices seen) (recur new-queue new-seen))))]\n    (and (contains? #{0 2} (count (filter odd? degrees))) connected)))", "user": "604d3cb1e4b0b7ec0ac60ac2"}, {"problem": 89, "code": "(fn tour\n  ([edges] (or (tour (rest edges) (seq (first edges)))\n               (tour (rest edges) (reverse (first edges)))))\n  ([edges path]\n   (if (empty? edges)\n     true\n     (let [res (keep-indexed #(when ((set %2) (first path))                              \n                                (let [new-edges (concat (take %1 edges)\n                                                        (drop (inc %1) edges))\n                                      new-path (conj path (if (= (first %2) (first path))\n                                                            (second %2) (first %2)))]\n                                  (or (tour new-edges (reverse new-path))\n                                      (tour new-edges new-path))))\n                             edges)]\n       (and (not (empty? res))\n            (every? identity res))))))", "user": "60096aabe4b074f607df667f"}, {"problem": 89, "code": "(fn euler-walk?\n  [edges]\n  (letfn [(connected?\n            [edges]\n            (letfn [(add-edge\n                      [components [v1 v2]]\n                      (let [comp1 (first (filter (fn [s] (s v1)) components))\n                            comp2 (first (filter (fn [s] (s v2)) components))]\n                        (cond (and (= nil comp1)\n                                   (= nil comp2)) (conj components (set [v1 v2]))\n                              (= nil comp1) (conj (disj components comp2) (conj comp2 v1))\n                              (= nil comp2) (conj (disj components comp1) (conj comp1 v2))\n                              :else (conj (disj components comp1 comp2) (into comp1 comp2)))))\n                    (components\n                      [edges]\n                      (reduce add-edge #{(set (first edges))} (rest edges)))]\n              (= 1 (count (components edges)))))\n          (degrees\n            [[[v1 v2] & edges]]\n            (let [m (reduce (fn [acc [v1 v2]]\n                              (-> acc\n                                  (assoc v1 (conj (get acc v1 []) v2))\n                                  (assoc v2 (conj (get acc v2 []) v1))))\n                            (zipmap [v1 v2] [[v2] [v1]])\n                            edges)]\n              (zipmap (keys m) (map count (vals m)))))]\n    (and (connected? edges)\n         (or (contains? #{0 2} (count (filter odd? (vals (degrees edges)))))))))", "user": "60460824e4b02d28681c77bc"}, {"problem": 89, "code": "(fn eulerian [edges]\n (let [degrees (fn [edges] (apply merge-with + {} (for [[a b] edges :when (not= a b)] {a 1 b 1}))) \n       gdeg (degrees edges)]\n  (and\n   (not (empty? gdeg))\n   (->> (vals gdeg)\n    (filter odd?)\n    count\n    (#(or (= 2 %) (= 0 %)))))))", "user": "5f419985e4b0955706451fab"}, {"problem": 89, "code": "(fn graph-tour?\n  [edges]\n  (if-let [points (not-empty (filter #(apply not= %) edges))]\n    (->> (map (fn [[a b]] {a 1 b 1}) points)\n         (apply merge-with +)\n         (filter #(odd? (val %)))\n         count\n         (>= 2))\n    false))", "user": "4e586949535d8a8b8723a292"}, {"problem": 89, "code": "(fn tour \r\n  ([edges]\r\n    (let [nodes (set (apply concat edges))]\r\n      (->>\r\n        nodes\r\n        (map (partial tour edges))\r\n        (reduce #(or %1 %2)))))\r\n  ([edges current]\r\n    (let [next (filter (fn [[a b]] (or (= b current) (= a current))) edges)]\r\n      (cond \r\n        (empty? edges) true\r\n        (empty? next) false\r\n        :else\r\n          (letfn \r\n            [(drop-one [elem [x & rest]]\r\n               (if (= elem x) rest\r\n                 (conj (drop-one elem rest) x)))]\r\n              (->>\r\n                next\r\n                (map \r\n                  (fn [[a b :as edge]]\r\n                    (let [to (if (= a current) b a)]\r\n                      (tour (drop-one edge edges) to))))\r\n                (reduce #(or %1 %2))))))))", "user": "606e0a42e4b069485764de19"}, {"problem": 89, "code": "(fn graph-tour ([[h & t :as v] g]\n                 (if (or (= h (last t)) (empty? g))\n                   v\n                   (let [ok (last v)\n                         not-ok (set (butlast t)) ;; yet edge not linked to any vertex in the middle\n                         valid-edges (filter (fn [[e1 e2]] (and (not (not-ok e1))\n                                                                (not (not-ok e2))\n                                                                (or (= ok e1) (= ok e2))))\n                                             g)\n                         x (first [1])\n                         paths (map (fn [edge] (graph-tour (conj v (if (= (last v) (first edge))\n                                                                     (second edge)\n                                                                     (first edge)))\n                                                           (remove #(= % edge)  g))) valid-edges)]\n                     (if-let [newv (-> paths\n                                       ((partial sort-by count))\n                                       last)]\n                       newv\n                       v))))\n   ([g] (= (count (graph-tour [(-> g first first)] g))\n           (if (= (count g) (count (set g)))\n             (-> g\n               flatten\n               set\n               count\n               ((if (= 1 (count g))\n                 identity\n                 inc)))\n             false))))", "user": "608ec5e4e4b03bd49d9f36c0"}, {"problem": 89, "code": "(fn visitable? [graph]\n  (letfn [(adjacent [graph v]\n            (reduce (fn [res [a b]]\n                      (cond (= v a) (conj res b)\n                            (= v b) (conj res a)\n                            :else res))\n                    #{} graph))\n          \n          (dfs\n            ([graph] (dfs graph (first (first graph))))\n            ([graph v]\n             (loop [stack (vector v)\n                    visited #{}]\n               (if (empty? stack)\n                 visited\n                 (let [v           (peek stack)\n                       neighbors   (adjacent graph v)\n                       not-visited (filter (complement #(visited %)) neighbors)\n                       new-stack   (into (pop stack) not-visited)]\n                   (if (visited v)\n                     (recur new-stack visited)\n                     (recur new-stack (conj visited v))))))))\n          \n          (all-vertices [graph]\n            (reduce (fn [vert [a b]] (-> vert (conj a) (conj b))) #{} graph))\n\n          (count-edges [graph]\n            (reduce (fn [res [a b]] (assoc res\n                                           a (inc (get res a 0))\n                                           b (inc (get res b 0)))) {} graph))]\n    \n    (and (= (all-vertices graph) (dfs graph))\n         (->> graph\n              count-edges\n              vals\n              (filter odd?)\n              count\n              list\n              (some #{0 2})\n              boolean))))", "user": "60b7e2c5e4b0e0fa5f1b4252"}, {"problem": 89, "code": "(fn graph-t [graph]\n    (let [nodes (distinct (flatten graph))\n          transformed-graph (apply merge\n                                   (map (fn [x]\n                                            (->> graph\n                                              (filter #(some (set (list x)) %))\n                                              (apply concat)\n                                              (remove (set (list x)))\n                                              set\n                                              (hash-map x))) nodes))\n          next-step (fn [x]\n                        (let [s (->> (last x)\n                                    (get transformed-graph)\n                                    (remove (set x))\n                                    vec\n                                    (map #(conj x %)))]\n                             (if (empty? s) (vector x) s)))]\n        (true? (some #(= % nodes)\n                  (-> (fn [y] (mapcat next-step y))\n                      (iterate (map vector nodes))\n                      (nth (count nodes)))))))", "user": "5f548678e4b0a0bc16850a7e"}, {"problem": 89, "code": "(letfn [(nodes [g] (into #{} (reduce concat g)))\n        (edges-of [g n] (filter (partial some #{n}) g))\n        (other [[n1 n2] n] (if (= n1 n) n2 n1))\n        (remove-first [n coll]\n          (let [[c1 c2] (split-with #(not= n %) coll)]\n            (concat c1 (rest c2) )))\n        (any? [f coll] ((complement not-any?) f coll))\n        (tour?\n          ([g] (any? true? (map #(tour? g %) (nodes g))))\n          ([g n] (do\n                   ;(println n \" -> \" g)\n                   (if (empty? g)\n                     true\n                     (any? true? (for [e (edges-of g n)\n                                       :let [v (other e n)\n                                             new-g (remove-first e g)]]\n                                   (tour? new-g v)))))))]\n  tour?)", "user": "53720c5ce4b0493c815db704"}, {"problem": 89, "code": "(fn [graph]\n  (->> graph\n       (filter (fn [[a b]] (not= a b)) )\n       (flatten )\n       (frequencies)\n       (vals )\n       (group-by odd? )\n       ((fn [grp] {:odd (count (grp true))\n                   :even (count (grp false))}) )\n       ((fn [grp] (and (> (+ (grp :odd) (grp :even)) 0)\n                          (<= (grp :odd) 2)\n                          (>= (grp :even) 0) ) )) ))", "user": "608e5697e4b03bd49d9f36be"}]