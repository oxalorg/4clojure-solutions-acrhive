[{"problem":69,"code":"(fn my-merge-with\n  [f m & ms]\n  (loop [acc m\n         rms ms]\n    (if (seq rms)\n      (let [cm (first rms)]\n        (recur\n         (merge\n          acc\n          (loop [ks (keys cm)\n                 nm {}]\n            (if (seq ks)\n              (let [k (first ks)]\n                (if (contains? acc k)\n                  (recur (rest ks) (assoc nm k (f (get acc k) (get cm k))))\n                  (recur (rest ks) (assoc nm k (get cm k)))))\n              nm)))\n         (rest rms)))\n      acc)))","user":"5ce6f93be4b0a17bb84e2b99"},{"code":"(fn t2 [f & maps]\n  (let [g #(into {} (for [[x y] %2]\n                       (if (%1 x)\n                         [x (f (%1 x) y)]\n                         [x y])))]\n    (reduce #(conj %1 (g %1 %2)) maps)))","problem":69,"user":"5046f909e4b03b02161376b5"},{"problem":69,"code":"(fn [f a & args]\n\t(reduce #(reduce (fn [ret [k v]]\n\t\t\t\t\t\t (if-let [rv (get ret k)]\n\t\t\t\t\t\t\t(assoc ret k (f rv v))\n\t\t\t\t\t\t\t(assoc ret k v)))\n\t\t\t\t\t  %1 %2)\n\t\t\ta args))","user":"55b8c339e4b01b9910ae29b9"},{"problem":69,"code":"(fn [ f & mps]\n  (letfn [\n           (mrg1 [mp [k v]] \n             (let [new-val (if (contains? mp k) (f (mp k) v) v)] \n                (assoc mp k new-val)))\n           (mrg [a b] (reduce mrg1 a b))\n         ]\n    (reduce mrg mps)))","user":"54d6f22de4b0a52adc2e2023"},{"code":"(fn [f & maps]\n  (reduce\n    conj \n    {} \n    (map \n      (fn [[k vals]] [k (reduce f (map second vals))])\n      (group-by first (apply concat maps)))))","problem":69,"user":"4eb9ce75535dfed6da9c6d5e"},{"problem":69,"code":"(fn merge-with-2\n  ([] {})\n  ([f coll1 coll2]\n     (reduce\n      (fn[m [k v]]\n        (if (coll? v)\n        (update-in m [k]\n                   (fnil (partial f v) nil))\n        (update-in m [k]\n                   (fnil (partial f v) 1))))\n      coll2 coll1))\n  ([f coll1 coll2 & colls]\n   (apply merge-with-2 f (merge-with-2 f coll1 coll2) colls)))","user":"505d1b01e4b0e6aca564be04"},{"problem":69,"code":"(fn [f m1 & maps]\n  (letfn [\n    (merge2 [m1 m2]\n      (reduce\n        (fn [m [k v]]\n          (if-let [m-v (get m k)] \n            (assoc m k (f m-v v))\n            (assoc m k v)))\n        m1\n        m2))]\n\n    (reduce merge2 m1 maps)))","user":"574dfcb8e4b02ea11479923a"},{"problem":69,"code":"(fn my-mergeWith \n  [f a & b]\n  (if (seq b)\n\n   \n    (let [to-merge (first b) merged \n          (reduce #(assoc %1 %2 \n                          (if (and (get a %2) get to-merge %2)\n                            (f (get a %2) (get to-merge %2))\n                            (get to-merge %2)))\n                  a \n                  (keys to-merge))]\n      (apply my-mergeWith f merged (rest b)))\n    a  \n    ))","user":"536f96e3e4b0fc7073fd6e83"},{"problem":69,"code":"(fn [op & maps]\n\t  (reduce (fn [l r] \n\t    (reduce (fn [l k]\n\t      (let [lv (get l k)]\n\t        (if (nil? lv)\n\t          (assoc l k (r k))\n\t          (assoc l k (op lv (r k)))\n\t    ))) l (keys r))) maps\n\t))","user":"569d4640e4b0542e1f8d147b"},{"code":"(fn [op & maps]\n  (let [mrg (fn [m n]\n              (reduce (fn [mm [k v]]\n                        (assoc mm k (if (contains? m k)\n                                      (op (m k) v)\n                                      v)))\n                      m n))]\n    (reduce mrg maps)))","problem":69,"user":"510cd1dde4b078ea71921124"},{"code":"(fn [g & n]\n\t(into {}\n          (map #(do [(key %) (reduce g (map val (val %)))])\n               (group-by key (apply concat n)))))","problem":69,"user":"528a3e14e4b0239c8a67ae72"},{"code":"(fn [f & maps] (letfn [(combine [acc m] (merge m acc (apply hash-map (mapcat (fn [k] [k (f (acc k) (m k))]) (clojure.set/intersection (set (keys m)) (set (keys acc)))))))] (reduce combine maps)))","problem":69,"user":"50a635bbe4b0aa96157e2621"},{"problem":69,"code":"(fn [f m & s]\n  (reduce (fn [a [k v]]\n            (assoc a k (if (m k)\n                         (f (m k) v)\n                         v))) m (for [m s e m] e)))","user":"53523ae0e4b084c2834f4aee"},{"code":"(fn[f & maps]\n   (reduce\n    (fn [m1 m2]\n      (apply\n       (partial merge m1)\n       (for [kv m2]\n         (if (contains? m1 (first kv))\n           {(first kv) (f (get m1 (first kv)) (fnext kv))}\n           {(first kv) (fnext kv)})))) maps))","problem":69,"user":"4fb86dc9e4b081705acca2d8"},{"problem":69,"code":"(fn my-merge [f & maps]\n  ((fn [m maps]\n      (if (empty? maps)\n        m\n        (recur\n          (let [m2 (first maps)]\n            (apply merge m2\n              (for [i m]\n                (if-let [new-val (get m2 (first i))]\n                  {(first i) (f (second i) new-val)}\n                  {(first i) (second i)}))))\n          (rest maps)))\n     ) (first maps) (rest maps)))","user":"58fc52cee4b0438e51c2cf95"},{"problem":69,"code":"(fn [f & maps]\n  (reduce (fn [acc m]\n            (reduce-kv (fn [out k v]\n                         (if (contains? out k)\n                           (assoc out k (f (get out k) v))\n                           (assoc out k v)))\n            acc\n            m))\n          {}\n          maps))","user":"5f37263de4b0574c87022c4e"},{"problem":69,"code":"(fn my-fn [f init & ms]\n  (let [combine-maps (fn [initial-map\n                          new-map]\n                       (reduce (fn [m [k v]]\n                                 (if (contains? m k)\n                                   (assoc m k (f (m k) v))\n                                   (assoc m k v)))\n                               initial-map\n                               new-map))]\n    (reduce (fn [acc m] (combine-maps acc m)) init ms)))","user":"5c896f46e4b048ec896c5940"},{"problem":69,"code":"(fn merge-with-func [f & args]\n  (reduce\n    (fn\n      [first-map second-map]\n      (reduce-kv\n        (fn\n          [m k v]\n          (if\n            (contains? m k)\n            (assoc m k (f (get m k) v))\n            (assoc m k v)\n            )\n          )\n        first-map\n        second-map)\n      )\n    args)\n  )","user":"563b9acbe4b0bfe05bf11827"},{"problem":69,"code":"(fn [f & maps]\n  (let [merge-entry (fn [m [k v]]\n                      (if (contains? m k)\n                        (assoc m k (f (get m k) v))\n                        (assoc m k v)))\n        merge-maps (fn [m1 m2]\n                     (reduce merge-entry m1 (seq m2)))]  \n                 ;    (loop [res m1\n                 ;           [e & more] (seq m2)]\n                 ;      (if (nil? more)\n                 ;        (merge-entry res e)\n                 ;        (recur (merge-entry res e) more))))]\n    (reduce merge-maps maps)))","user":"5680104ae4b0966858e4d8ea"},{"problem":69,"code":"(fn [f & maps]\n  (reduce (fn [out in]\n            (reduce-kv (fn [m k v]\n                         (assoc m k (if-let [v' (get m k)]\n                                      (f v' v)\n                                      v)))\n                       out in))\n          maps))","user":"4f5599dfe4b0a7574ea71806"},{"code":"(fn [f & maps]\n  (reduce #(assoc %1 (key %2)\n                  (if (> (count (val %2)) 1)\n                    (apply f (reverse (val %2)))\n                    (first (val %2))))\n          {}\n          (reduce\n           (fn [in-map new-map]\n             (reduce #(let [[k v] %2]\n                        (assoc %1 k (conj (get %1 k) v)))\n                     in-map\n                     new-map))\n           {} maps)))","problem":69,"user":"504ec4d3e4b069badc5a33c9"},{"problem":69,"code":"(fn [f & maps]\n  (reduce\n   (fn [out in]\n     (reduce\n      (fn [mp [k v]]\n        (if (contains? mp k)\n          (assoc mp k (f (mp k) v))\n          (assoc mp k v))) out in)) {} maps))","user":"54864662e4b0e286459a11b8"},{"problem":69,"code":"(fn mw\n  [f & maps]\n  (when (some identity maps)\n    (let [merge-entry (fn [m e]\n\t\t\t(let [k (key e) v (val e)]\n\t\t\t  (if (contains? m k)\n\t\t\t    (assoc m k (f (get m k) v))\n\t\t\t    (assoc m k v))))\n          merge2 (fn [m1 m2]\n\t\t   (reduce merge-entry (or m1 {}) (seq m2)))]\n      (reduce merge2 maps))))","user":"5412646de4b01498b1a719d4"},{"problem":69,"code":"(fn [f & maps]\n\t(reduce (fn [res mp]\n\t\t(reduce (fn [acc item]\n\t\t\t(let [k (key item) v (val item)]\n\t\t\t\t(if (contains? acc k)\n                \t(assoc acc k (f (get acc k) v))\n                    (assoc acc k v))))\n                        res mp)) {} maps))","user":"53214efbe4b09d4e7a9b54b2"},{"code":"(fn [f m & ms]\n  (reduce\n    (fn [m [k v]]\n      (if-let [u (m k)]\n        (assoc m k (f u v))\n        (assoc m k v)))\n    m\n    (apply concat ms)))","problem":69,"user":"4f4e7c01e4b03ad3f0c10cc9"},{"problem":69,"code":"(fn [f m1 m2 & rests]\n  (if (nil? m2)\n    m1\n    (recur f\n           (reduce (fn [m [k v]]\n                     (assoc m k (if (m k)\n                                  (f (m k) v)\n                                  v)))\n                   m1\n                   m2)\n           (first rests)\n           (rest rests))))","user":"50742549e4b054001656accf"},{"problem":69,"code":"(fn [f & ms]\n   (into {} (for [[k l] (group-by first (apply concat ms))]\n              [k (reduce f (map second l))])))","user":"553698fae4b09218d5f44fc0"},{"code":"#(into {} \n   (for [[k s] (group-by key (apply concat %&))]\n         [k (reduce % (vals s))]))","problem":69,"user":"521679e9e4b0bf4bffd29cca"},{"problem":69,"code":"(fn [f & maps]\n   (reduce (fn [acc m]\n             (reduce (fn [acc2 [k v]]\n                       (if (contains? acc2 k) (assoc acc2 k (f (acc2 k) v))\n                           (assoc acc2 k v))\n                       ) acc m)\n             ) maps))","user":"5935b010e4b04f87174def55"},{"code":"(fn [f & xs]\n  (let [merge-entry (fn [m1 c]\n                       (let [k (key c) v (val c)]\n                         (if (contains? m1 k)\n                           (assoc m1 k (f (get m1 k) v))\n                           (assoc m1 k v))))\n        merge2 (fn [m1 m2] \n                      (reduce merge-entry (or m1 {}) (seq m2))) ]\n    (reduce merge2 xs)))","problem":69,"user":"52fa4f48e4b047fd55836ff7"},{"code":"(fn [f & maps] \n  (reduce #(conj %\n    (reduce (fn [r [k v]] \n              (let [rv (get r k)] (assoc r k (if rv (f rv v) v)))) % %2))\n     maps))","problem":69,"user":"4f05ea25535dcb61093f6c02"},{"problem":69,"code":"(fn [F & Maps]\n    (let\n      [\n          MergeWith (fn\n            ([] {})\n            ([A] A)\n            ([A B]\n              (let\n                ;; ключи обоих карт в одном списке                \n                [AllKeys (clojure.set/union (set (keys A)) (set (keys B))) ]\n                (loop [Ret {} Key (first AllKeys) Keys(rest AllKeys)]\n                  ;; если ключа нет, то хватит\n                  (if (nil? Key)\n                    Ret\n                    ;; иначе к следующему ключу, дополняя результат текущим\n                    (recur\n                      (cond\n                        ;; нет в первой карте, то добавляем из второй\n                        (nil? (get A Key)) (assoc Ret Key (get B Key))\n                        ;; нет во второй карте, то добавляем из первой\n                        (nil? (get B Key)) (assoc Ret Key (get A Key))\n                        ;; есть в обоих - используем функцию\n                        :else (assoc Ret Key (F (get A Key) (get B Key)))\n                      )\n                      (first Keys)\n                      (rest Keys)\n                    )\n                  )\n                )\n              )\n            )\n          )\n      ]\n      (reduce MergeWith Maps)\n    )\n  )","user":"5d4a6c6ce4b0776584bd6f22"},{"problem":69,"code":"(fn my-merge-with\n  [f & maps]\n  (let [merge-maps (fn [m e]\n                     (reduce (fn [a1 a2]\n                               (let [k (first a2)\n                                     original-value (get a1 k)\n                                     new-val (last a2)\n                                     final-val (cond (and (not (nil? (get a1 k)))\n                                                        (not (nil? (last a2))))\n                                                     (f original-value new-val)\n\n                                                     (nil? original-value)\n                                                     new-val\n\n                                                     :else\n                                                     original-value)]\n                                 (assoc a1 k final-val)\n                                 )) m e))]\n    (reduce merge-maps maps)))","user":"5b478997e4b02d533a91bc71"},{"problem":69,"code":"(fn merge-with-fun\n  ([f m1 m2]\n   (let [ks (clojure.set/union (set (keys m1)) (set (keys m2)))]\n     (reduce #(let [v1 (get m1 %2), v2 (get m2 %2)]\n         (if (and v1 v2)\n           (assoc % %2 (f v1 v2))\n           (if v1 % (assoc % %2 v2))))\n             m1 ks)))\n  ([f m1 m2 & ms]\n   (let [m1 (merge-with-fun f m1 m2), [m2 & ms] ms]\n     (apply merge-with-fun f m1 m2 ms))))","user":"572ec4dde4b0cd1946bd0f8d"},{"code":"(fn [f & maps]\n\t(reduce \n\t\t(fn [acc m] \n\t\t\t(reduce \n\t\t\t\t(fn [inner-acc [key value]]\n\t\t\t\t\t(if (contains? inner-acc key)\n\t\t\t\t\t\t(update-in inner-acc [key] (fn [val-before] (f val-before value)))\n\t\t\t\t\t\t(assoc inner-acc key value))\n\t\t\t\t)\n\t\t\t\tacc m))\n\t\t{} maps))","problem":69,"user":"51ba4482e4b0fe3ecfb4642b"},{"code":"(fn [f & args]\n  (let [ms (mapcat vec args)]\n    (reduce #(if-let [existing (%1 (first %2))] (assoc %1 (first %2) (f existing (second %2) )) (into %1 [%2]) ) {} ms)\n ))","problem":69,"user":"53691dc7e4b0243289761e97"},{"problem":69,"code":"(fn [f m & maps]\n   (reduce\n    #(reduce-kv\n      (fn [m k v]\n        (if-let [n (m k)]\n          (assoc m k (f n v))\n          (assoc m k v)))\n      %1\n      %2)\n    m\n    maps))","user":"5f3abcc4e4b004f08c61c52b"},{"problem":69,"code":"(fn outer [f & maps]\n  (letfn \n    [(m-with [f m1 m2]\n       (if (empty? m2) \n         m1\n         (let [k (first (keys m2))]\n           (if (contains? m1 k)\n             (m-with f (assoc m1 k (f (m1 k) (m2 k))) (dissoc m2 k))\n             (m-with f (assoc m1 k (m2 k)) (dissoc m2 k))))))]\n    (reduce (partial m-with f) maps)))","user":"4ff769bce4b0678c553fc38f"},{"code":"(fn [func & maps]\n   (loop [result {} allkeys\n\t\t\t\t\t   (loop [mkeys #{} elements maps]     \n\t\t\t\t\t     (if elements\n\t\t\t\t\t       (recur (clojure.set/union mkeys (set (keys (first elements)))) \n\t\t\t\t\t       (next elements)\n\t\t\t\t\t       )\n\t\t\t\t\t       mkeys\n\t\t\t\t\t       )     \n\t\t\t\t\t     )\n\t\t\t\t    ]\n     (if allkeys\n       (recur \n         (into result {(first allkeys) \n                       (let [temp-map\n\t\t\t                       (loop [map-index [] all-maps maps i 0]\n\t\t\t                         (if all-maps\n\t\t\t                           (recur (if (contains? (first all-maps) (first allkeys))\n\t\t\t                                    (conj map-index i)\n\t\t\t                                    map-index)\n\t\t\t                                  (next all-maps)\n\t\t\t                                  (inc i))\n\t\t\t                           map-index                           \n\t\t\t                           )                         \n\t\t\t                         )]\n                         \n                         (if (= (count temp-map) 1)\n                           ((nth maps (first temp-map)) (first allkeys))\n                           (func ((nth maps (first temp-map)) (first allkeys)) ((nth maps (second temp-map)) (first allkeys)))\n                           )                         \n                         )                       \n                       })         \n         (next allkeys)\n         )\n       result \n       )          \n     )   \n   )","problem":69,"user":"5106dc1be4b01150e115ebf0"},{"problem":69,"code":"(fn [f & ms]\n  (letfn[(m [acc m]\n           (let [to-merge (select-keys m (keys acc))\n                 to-assoc (apply disj (set (keys m)) to-merge)\n                 merged   (map (fn [[k v]] [k (f (get acc k) v)]) to-merge)\n                 assoced  (reduce #(assoc %1 %2 (get m %2)) acc to-assoc)]\n             (into assoced merged)))]\n    (reduce m ms)))","user":"54ca9ca8e4b057c6fda3a265"},{"code":"(fn [fun & maps]\n    (let [merge-maps\n          (fn [m1 m2]\n            (let [left (clojure.set/difference (set (keys m1)) (set (keys m2)))\n                  right (clojure.set/difference (set (keys m2)) (set (keys m1)))\n                  common (vec (clojure.set/intersection (set (keys m2)) (set (keys m1))))\n                  left-map (select-keys m1 left)\n                  right-map (select-keys m2 right)\n                  common-map (zipmap common (map #(fun (m1 %) (m2 %)) common))]\n              (println left-map right-map common-map)\n              (merge left-map right-map common-map)))]\n      (reduce merge-maps maps)))","problem":69,"user":"53527ce8e4b084c2834f4af1"},{"problem":69,"code":"(fn [f & maps]\n    (reduce\n     (fn [acc key]\n       (assoc acc key\n              (let [mm (drop-while (complement #(contains? % key)) maps)\n                    res ((first mm) key)\n                    mm (rest mm)]\n                (reduce (fn [v m]\n                          (if (contains? m key) (f v (m key)) v))\n                        res mm))\n              )\n       )\n     {}\n     (reduce #(into %1 (keys %2)) #{} maps))\n    )","user":"56f9392ae4b07572ad1a88ac"},{"code":"(fn [f & m] (reduce (fn[x y] \r\n  (reduce \r\n    (fn [a i] (conj a \r\n      [(first i) (if (contains? a (first i))\r\n          (f (a (first i)) (last i)) (last i))])) x y)) m))","problem":69,"user":"4ddbd934535d02782fcbe9fc"},{"problem":69,"code":"(fn [f & maps] (reduce (fn [a m] (reduce (fn [b [k v]] (update-in b [k] #(if (nil? %1) %2 (f %1 %2)) v)) a m)) maps))","user":"5a5894d9e4b05d388ecb6c81"},{"code":"(fn [f & xs] (reduce (fn [m n] (reduce (fn [m [k v]] (assoc m k (if-let [w (m k)] (f w v) v))) m n)) xs))","problem":69,"user":"4f296a80e4b0d6649770a02a"},{"code":"(fn [f & maps] (letfn\n                 [(apply-item  [h] (fn [[k v]] (let [y (h k)] [k (if y (f v y) v)])))\n                  (reduce-maps [a b] (let\n                                       [applied (apply hash-map (mapcat (apply-item b) a))]\n                                       (merge b applied)))]\n                 (reduce reduce-maps maps)))","problem":69,"user":"51307b84e4b08c712d3fae39"},{"code":"(fn mer [f s & more]\n  (let [do-mer (fn [s p]\n  (if-let [[k v] (first p)]\n    (recur (assoc s k\n             (if-let [old (s k)]\n               (f old v)\n               v))\n           (rest p))\n    s))]\n    (if-let [p (first more)]\n      (apply (partial mer f (do-mer s p)) (rest more))\n      s\n    )\n    )\n  )","problem":69,"user":"515f8a0de4b0e2be8aa20bce"},{"code":"#(loop [r {} o (apply concat %&)]\n  (if (= [] o)\n    r\n    (let [[k v] (nth o 0)]\n      (recur (assoc-in r [k] (if (r k) (% (r k) v) v)) (rest o)))))","problem":69,"user":"4e43b0d9535dc968683fc4a3"},{"code":"#(reduce (fn [r [k v]] (if (contains? r k) (assoc r k (%1 (r k) v)) (assoc r k v))) {} (mapcat vec %&))","problem":69,"user":"4f21838fe4b0d66497709fd2"},{"problem":69,"code":"(fn [x & y] \n  (reduce (fn [a b] (reduce (fn [e f]  (let [f1 (first f)] \n                                       (if (nil? (e f1)) \n                                           (apply assoc e f) \n                                           (assoc e f1 (x (e f1) (last f)) )))) a b) ) y))","user":"5576e78de4b05c286339e075"},{"code":"(fn mw\n   ([f s1 s2]\n    (if (empty? s2)\n      s1\n      (let [k (first (keys s2))]\n        (if (contains? s1 k)\n          (mw f (assoc s1 k (f (s1 k) (s2 k))) (dissoc s2 k))\n          (mw f (assoc s1 k (s2 k)) (dissoc s2 k))\n          )\n        )\n      )\n    )\n   ([f s1 s2 & s]\n    (let [ss (cons s1 (cons s2 s))]\n      (reduce (partial mw f) ss)\n      )\n    )\n   )","problem":69,"user":"52586d24e4b0cb4875a45cb0"},{"problem":69,"code":"(fn [x & y]\n   (loop [init (first y) lis (rest y)]\n    (if (empty? lis)\n      init\n      (recur\n        (reduce\n          #(if (contains? %1 (first %2))\n             (conj %1 {(first %2) (x (%1 (first %2)) (second %2))})\n             (conj %1 %2))\n          init\n          (first lis))\n        (rest lis)))))","user":"563c48e7e4b0bfe05bf11832"},{"code":"(fn m-w [f & maps]\n  (let [all-keys (keys (apply merge maps))]\n    (apply hash-map\n      (interleave\n       all-keys\n       (for [k all-keys]\n        (let [with-k (filter #(contains? % k) maps)]\n          (reduce\n           #(f %1 (%2 k))\n           ((first with-k) k)\n           (rest with-k))))))))","problem":69,"user":"4fe13ad7e4b0dd6cd5ce3632"},{"code":"(fn [f first-map & other-maps]\n\t(loop [[m & ms] other-maps result1 first-map]\n        (if (nil? m) result1\n\t\t    (recur ms \n                  (loop [[[k v :as entry] & entries] (seq m), result2 result1]\n                      (cond\n                          (empty? entry) result2\n                          (get result2 k) (recur entries (assoc result2 k (f (get result2 k) v)))\n                          :else (recur entries (assoc result2 k v))))))))","problem":69,"user":"53300924e4b019098a6f8b55"},{"code":"#(into {} \n        (for [[k vs] (group-by first (apply concat %&))]\n          [k (reduce % (map second vs))]))","problem":69,"user":"4ffa8affe4b0678c553fc3bd"},{"code":"(fn [o f & rest]\n  (reduce (fn [g m]\n            (reduce (fn [a [k v]]\n                      (if (contains? a k)\n                        (assoc a k (o (get a k) v))\n                        (assoc a k v)))\n                    g\n                    m))\n          f\n          rest))","problem":69,"user":"4e778d36535d324fb2983d71"},{"code":"(fn [f coll & colls]\n  (if (empty? colls)\n    coll\n    (recur f\n           (reduce (fn [c [k v]]\n                     (assoc c k (if (c k) (f (c k) v) v)))\n                   coll (first colls))\n           (rest colls))))","problem":69,"user":"506ef8c3e4b09350ab4199f4"},{"problem":69,"code":"(fn merge-with- [f & ms]\n  (reduce (fn [m1 m2]\n            (reduce (fn [m [k v]]\n                      (if (contains? m k)\n                        (update-in m [k] f v)\n                        (assoc m k v)))\n                    m1 m2))\n          ms))","user":"5972fcf6e4b01722bebd4c92"},{"code":"(fn [f & maps]\n  (->> maps\n    (apply concat)\n    (group-by key)\n    (map (fn [[k vs]] [k (reduce f (map val vs))]))\n    (into {})\n)\n)","problem":69,"user":"4fbbcf0ce4b081705acca2ee"},{"code":"(fn [f & maps]\n  (reduce \n    (fn [old-map new-map]\n      (loop [xs (seq new-map)\n             acc old-map]\n          (if xs\n            (let [[k v] (first xs)]\n              (recur \n                (next xs) \n                (assoc acc k\n                  (if-let [old (acc k)]\n                    (f old v)\n                    v))))\n              \n            acc)))\n    maps))","problem":69,"user":"4e4c238f535dc968683fc4dc"},{"code":"(fn my-merge-with [f & maps]\n  (letfn ((map-merge [f m1 m2]\n             (reduce (fn [m v]\n                        (if (contains? m (first v)) \n                          (assoc m (first v) (f (get m (first v)) (second v)))\n                          (conj m v)))\n                     m1 m2)))\n    (reduce #(map-merge f %1 %2) maps)))","problem":69,"user":"4e7263a1535d5021c1a8965f"},{"problem":69,"code":"(fn [f m & maps]\n  (letfn [(combine [f m submap]\n                   (reduce (fn [acc b]\n                             (if (get acc b)\n                               (assoc acc b (f (get acc b) (get submap b)))\n                               (assoc acc b (get submap b)))) m (keys submap)))]\n    (reduce (partial combine f) m maps)))","user":"58ffac9de4b0438e51c2cffd"},{"problem":69,"code":"(fn [f coll & args]\n  (reduce #(let [[k v] %2]\n             (if (contains? %1 k) (conj (dissoc %1 k) {k (f (%1 k) v)})\n                 (conj %1 {k v}))) coll (apply concat (map seq args))))","user":"58f5b58ae4b0438e51c2cedc"},{"problem":69,"code":"(fn [f & ms]\n  (reduce (fn [acc m]\n            (reduce (fn [acc [k v]]\n                   (let [new-val (if (contains? acc k)\n                                   (f (get acc k) v)\n                                   v)]\n                     (assoc acc k new-val)))\n                    acc\n                    m))\n          {}\n          ms))","user":"5344fe13e4b084c2834f4a32"},{"code":"(fn [f & xs]\n  (let [m (partial reduce (fn [a [k v]]\n                                (if (a k)\n                                    (assoc a k (f (a k) v))\n                                    (assoc a k v))))]\n    (reduce #(m %1 %2) xs)))","problem":69,"user":"4f569a3ce4b0a7574ea71828"},{"code":"(fn [f & ms] \n  (letfn [(update-acc [f acc m]\n                      (if (empty? m)\n                        acc\n                        (let [[k v] (first m)]\n                          (if (acc k)\n                            (recur f (assoc acc k (f (acc k) v)) (rest m))\n                            (recur f (assoc acc k v) (rest m))))))]\n  (loop [[m & ms'] ms, acc {}]\n    (if (nil? m) \n      acc\n      (recur ms' (update-acc f acc m))))))","problem":69,"user":"536ca4bde4b0fc7073fd6e49"},{"problem":69,"code":"(fn __ [f & maps]\n  (reduce\n   (fn [acc map]\n     (reduce\n      (fn [acc [k v]] (update-in acc [k] #(if (nil? %1) %2 (f %1 %2)) v))\n      acc\n      (seq map)))\n   maps))","user":"54c9f165e4b045293a27f687"},{"problem":69,"code":"(fn [op & hs]\n   (let [ls (->> hs\n              (mapcat seq)\n              (group-by first))\n         ks (keys ls)\n         vs (map (fn [coll]\n                   (map second coll)) (vals ls))\n         vs2 (map (fn [coll] (reduce op coll)) vs)\n         ret (zipmap ks vs2)]\n     ret))","user":"56fbf83de4b07572ad1a88da"},{"code":"(fn [f & args] \n  (let [combine-key (fn [m [k v]] (assoc m k (if (m k) (f (m k) v) v)))\n        combine-map (fn [m1 m2] (reduce combine-key m1 m2))]\n  (reduce combine-map args)) )","problem":69,"user":"53976599e4b0b51d73faaeea"},{"code":"(fn [f first-map & rest-maps]\n  (let [res (atom first-map)]\n    (doseq [m rest-maps]\n      (doseq [k (keys m)]\n        (if (@res k)\n          (swap! res #(assoc % k (f (@res k) (m k))))\n          (swap! res #(assoc % k (m k))))))\n  @res))","problem":69,"user":"4e28120f535deb9a81d77efa"},{"problem":69,"code":"(fn [op & dicts]\n  (reduce\n    (fn [p i] (assoc p i (let [items (map #(% i) (filter #(contains? % i) dicts))] (if (= 1 (count items)) (first items) (apply op items)))))\n    {}\n    (apply clojure.set/union (map #(into #{} (keys %)) dicts))))","user":"591f05b4e4b09b4ee5954c42"},{"problem":69,"code":"(fn [f m & ms]\n  (let [kvs (apply concat (map seq ms))]\n    (reduce (fn [x [k v]]\n                      (if (contains? x k)\n                        (update-in x [k] f v)\n                        (assoc x k v))) m kvs)))","user":"58949f8de4b00487982d525e"},{"problem":69,"code":"(fn merge-with-a-function\n  ([f & coll]\n   (reduce (fn [result latter]\n             (reduce (fn [left right]\n                       (let [key (first right)\n                             val (last right)]\n                         (if (contains? left key)\n                           (assoc left key (f (get left key) val))\n                           (conj left right))))\n                     result latter))\n             (first coll)\n             (rest coll))))","user":"5bf5ddfde4b0bdcf453d159e"},{"code":"(fn [f h & hs]\n    (reduce\n      #(reduce (fn [h [k v]]\n                 (assoc h k (if (contains? h k)\n                              (f (get h k) v)\n                              v)))\n               % %2)\n      h hs))","problem":69,"user":"4fdec88fe4b05e33b9224f8e"},{"problem":69,"code":"(fn mw [f m & rm] \n  (reduce \n   (fn [fm sm] \n     (reduce \n      (fn [im [k v]] \n        (if (im k) \n          (assoc im k (f (im k) v)) \n          (assoc im k v))) \n      fm sm)) \n   m rm))","user":"56aed78fe4b03c432f187363"},{"problem":69,"code":"(fn [f & maps]\n           (reduce (fn [acc curr]\n                     (let [base (conj acc curr)\n                           conflicts (into {} (for [[k v] curr]\n                                                (when-let [acc-v (get acc k)]\n                                                  [k (f acc-v v)])))]\n                       (conj base conflicts))) \n                   {} maps))","user":"530b8580e4b02e82168697cc"},{"problem":69,"code":"(fn [f & m]\n  (into {} (map #(let [[k v] %]\n  (vector k (reduce f (map second v))))\n(group-by first (mapcat seq m)))))","user":"55c6fd60e4b0e31453f649c9"},{"problem":69,"code":"(fn [f & sets]\n            (into {}\n                  (for [newkey (apply clojure.set/union (map #(into #{} (keys %)) sets))]\n                    (hash-map newkey (if (= 1 (count (filter #(not (nil? %)) (map #(get % newkey) sets)))) (first (filter #(not (nil? %)) (map #(get % newkey) sets) )) (apply f (filter #(not (nil? %)) (map #(get % newkey) sets))) ))\n                    )))","user":"5c0e3f86e4b01240ff56713d"},{"code":"(letfn [(mymerge-with\r\n    ([f m1 m2]\r\n        (reduce (fn [res [k v]] (if-let [rv (res k)] (assoc res k (f rv v)) (assoc res k v)))\r\n                m1 m2))\r\n    ([f m1 m2 & maps]\r\n        (reduce #(mymerge-with f %1 %2) m1 (cons m2 maps)))\r\n  )]\r\n mymerge-with)","problem":69,"user":"4df3d4f4535d08e6dec9fe2c"},{"problem":69,"code":"; (defn g [m k v f] (assoc m k (if (contains? m k) (f (m k) v) v)))\n; (defn kvs [m] (partition 2 (interleave (keys m) (vals m))))\n; (defn h [f m & ms] (reduce #(g %1 (first %2) (second %2) f) m (apply concat (map kvs ms))))\n\n(fn [f m & ms] (reduce #((fn [m k v f] (assoc m k (if (contains? m k) (f (m k) v) v))) %1 (first %2) (second %2) f) m (apply concat (map (fn [m] (partition 2 (interleave (keys m) (vals m)))) ms))))","user":"54bd04e7e4b0ed20f4ff6ed8"},{"problem":69,"code":"#(reduce\n   (fn [m [k v]]\n     (update-in m [k] (fn [c] (if c (% c v) v))))\n   {}\n   (apply concat %&))","user":"590b055ae4b047aa04b199c9"},{"problem":69,"code":"(fn mrgw [f & xs] \n  (letfn [(ks [xs] (apply clojure.set/union (map set (map keys xs))))]\n        (apply merge \n               (for [k (ks xs)\n                     :let [vals (remove nil? (map get xs (repeat k)))]]\n                 {k (if (> (count vals) 1) (apply f vals) (first vals))} ))))","user":"550e52dbe4b06e50f9beb165"},{"problem":69,"code":"(fn foo [f & a]\n  (reduce \n   (fn [r i] \n     (merge r \n      (into {} \n       (map (fn [[k v]] \n             (if \n               (contains? r k) \n               [k (f (r k) v)] \n               [k v])) \n           i))))\n   a))","user":"561f9110e4b064ca9f4b16ce"},{"code":"(fn my-merge-with [f & maps]\n   (letfn [(my-merge-maps [m n]\n             (letfn\n                 [(my-merge-key [m k]\n                    (if (m k)\n                      (assoc m k (f (m k) (n k)))\n                      (assoc m k (n k))))]\n               (reduce my-merge-key m (keys n))))]\n     (reduce my-merge-maps maps)))","problem":69,"user":"4e89f46c535d3e98b8023288"},{"code":"(fn [f & ms]\n  (reduce (fn [m1 m2]\n            (reduce (fn [m [k v]]\n                      (if (contains? m k)\n                        (assoc m k (f (m k) v))\n                        (assoc m k v)))\n                    m1 m2))\n          {} ms))","problem":69,"user":"533018b2e4b019098a6f8b56"},{"problem":69,"code":"(fn my-merge-with [f & maps]\n    (reduce\n      (fn my-merge [m1 m2]\n        (reduce (fn [acc [k v]](assoc acc k (if (contains? acc k) (f (get acc k) v) v))) m1 m2))\n      (first maps) (rest maps)\n      ))","user":"56791447e4b05957ce8c6183"},{"code":"(fn [f, m & ms] \n  (loop [r m, [hs & ts] (seq ms), ms (seq ms), [[k v] & t] (seq hs)]\n    (if hs \n      (if k \n        (if (contains? r k) \n          (recur (assoc r k (f (r k) v)) ms ms t)\n          (recur (assoc r k v) ms ms t))\n        (recur r ts ts (seq (first ts))))\n      r)))","problem":69,"user":"4eabb245535d7eef30807319"},{"problem":69,"code":"(fn merge-with-a-function [f & ms]\n  (let [ks (reduce #(into %1 (keys %2)) #{} ms)\n        kvs (reduce (fn [em k] (assoc em k (let [vs (keep #(% k) ms)]\n                                             (if (> (count vs) 1)\n                                               (apply f vs)\n                                               (first vs))))) {} ks)] \n    kvs))","user":"5c665311e4b0fca0c16226a7"},{"problem":69,"code":"(fn [f m & ms]\n  (if (empty? ms)\n  \tm\n  \t(recur f\n           (reduce-kv (fn [m k v]\n                     \t(if (contains? m k)\n                     \t  (conj m {k (f (get m k) v)})\n                      \t  (conj {k v} m))) \n                      m (first ms))\n           (rest ms))))","user":"550e83d6e4b06e50f9beb166"},{"code":"(fn merge-maps [f original & args]\n  (let [merge-two-maps (fn [original additions]\n                         (reduce \n                           (fn [m [k v]]\n                             (if-let [e (m k)]\n                               (assoc m k (f e v))\n                               (assoc m k v)))\n                            original\n                            additions))]\n    (reduce merge-two-maps original args)))","problem":69,"user":"53513d28e4b084c2834f4ae3"},{"code":"(fn [f & maps]\n  (reduce (fn [map1 map2]\n            (reduce #(conj %1 [%2 (if (map1 %2) (f (map1 %2) (map2 %2)) (map2 %2))]) \n                    map1 \n                    (keys map2)))\n          maps))","problem":69,"user":"52c8758be4b0c2d177d62135"},{"code":"(fn [f & maps]\n  (reduce (fn [m1 m2]\n    (reduce #(let [[k v] %2\n                   init (% k)]\n      (assoc % k (if init (f init v) v)))\n      m1 m2))\n   maps))","problem":69,"user":"500900dee4b0144d4f561e42"},{"code":"(fn [f & maps]\n  (letfn [(inner-merge [m entry]\n            (if-let [v (m (first entry))]\n              (assoc m (first entry) (f v (last entry)))\n              (assoc m (first entry) (last entry))))]\n  (reduce inner-merge {}\n   (reduce #(into % %2) [] maps))))","problem":69,"user":"4eddcbbf535d10e5ff6f532d"},{"problem":69,"code":"(fn mergeXB [op & x] \n\n\n\t((fn mergeV [op x]\n\n\n\n(if (= 1 (count x)) (first x)\n\t((fn [op x y]\n\n\n(let [ks (distinct (concat (keys x) (keys y)))]\n(apply merge (map (fn [k] (if (and (contains? x k)(contains? y k))\n\t { k (op (get x k) (get y k) )}\n\t (if (contains? x k)\n\t \t{k (get x k)  }\n\t \t{k (get y k)  }\n\t )\n\t )\n)  ks))\n)) op (first x)(mergeV op (rest x)))\n)) op x)\n\n\n)","user":"568820e8e4b0dcc4269f4067"},{"code":"(fn [op & ms]\n    (reduce\n     (fn [a b]\n       (merge a\n              (into {}\n                    (map (fn [k] {k (if (contains? a k) (op (a k) (b k)) (b k))}) (keys b)))))\n     ms))","problem":69,"user":"4ed292ac535d44c135fd68d9"},{"problem":69,"code":"(fn [f & maps] \n  (reduce\n    (fn [m1 m2]\n      (let [ks (filter m1 (keys m2))]      ; get the keys common to both maps\n        (reduce\n          #(assoc % %2 (f (% %2) (m2 %2))) ; update m1 by applying f\n          (conj m2 m1)                     ; init the result map with m1+m2\n          ks)))                            ; only do this for conflicting keys\n    maps))","user":"5b772ad7e4b047b03b2036e8"},{"problem":69,"code":"(fn [f & maps]\n    (into {} (map\n              (fn [x]\n                [x (reduce f (keep #(get % x) maps))])\n              (into #{} (mapcat keys maps))))\n    )","user":"4f5e5975e4b0030a34fb2b4d"},{"problem":69,"code":"(fn merge-function2 [f & mapss]\n  (loop [resp {}\n         maps mapss]\n    (if (= maps [])\n      resp\n      (let [m (first maps)\n            ks (keys m)]\n        (let [resp (reduce (fn [r k]\n                             (let [v (m k)]\n                               (if (contains? r k)\n                                 (assoc r k (f (r k) v))\n                                 (assoc r k v)))) resp ks)]\n          (recur resp (rest maps)))))))","user":"574f1c24e4b02ea114799255"},{"problem":69,"code":"(fn s [func coll & args]\n  (let [all (conj args coll)]\n    (into {} (map (fn [key] [key (let [result (filter (complement nil?) (map #(get % key) all))]\n                              (if (> (count result) 1)\n                                (apply func result)\n                                (first result)))])\n                  (keys (apply merge all))))))","user":"568f2059e4b0dcc4269f40df"},{"problem":69,"code":"(fn [op & maps]\n  (reduce (fn [acc-m m] \n            (reduce (fn [old-map new-map-key]\n                      (if (get old-map new-map-key)\n                        (assoc old-map new-map-key (op (old-map new-map-key) (m new-map-key)))\n                        (assoc old-map new-map-key (m new-map-key))))\n                    acc-m\n                    (keys m)))\n          maps))","user":"59225498e4b09b4ee5954c8c"},{"problem":69,"code":"(fn merge-with'\n  [f & maps]\n  (reduce (fn [map1 map2]\n            (reduce #(let [[k v] %2]\n                            (if (contains? % k)\n                              (update-in % [k] f v)\n                              (assoc % k v))) map1 map2)) maps))","user":"56785234e4b05957ce8c6177"},{"problem":69,"code":"(fn [func result & map-seq]\r\n  (loop [map-seq map-seq\r\n         result result]\r\n    (if (empty? map-seq)\r\n      result\r\n      (recur (rest map-seq)\r\n        (loop [head-map (first map-seq)\r\n               result result]\r\n          (if (empty? head-map)\r\n            result\r\n            (let [head-item (first head-map)\r\n                  tail-items (rest head-map)\r\n                  [head-key head-value] head-item]\r\n                (recur tail-items (merge result {head-key\r\n                  (if (contains? result head-key)\r\n                    (func (result head-key) head-value)\r\n                    head-value)})))))))))","user":"555bd27ae4b0b056612e2244"},{"problem":69,"code":"(fn merge-maps\n  [f & maps]\n  (let [merge-one (fn [left right]\n                    (loop [[[k v] & t] (into [] right)\n                            accum left]\n                       (let [new-accum (if (contains? accum k)\n                                           (assoc accum k (f (accum k) v))\n                                           (assoc accum k v))]\n                         (if (nil? t)\n                             new-accum\n                             (recur t new-accum)))))]\n    (loop [[h & t] maps\n           accum {}]\n      (let [new-accum (merge-one accum h)]\n        (if (nil? t)\n          new-accum\n          (recur t new-accum))))))","user":"58152157e4b0f478707a0631"},{"problem":69,"code":"(fn [f & ms] (reduce (partial reduce (fn [m [k v]] (assoc m k (if (m k) (f (m k) v) v)))) ms))","user":"560a7752e4b05f002753def9"},{"code":"(fn [f & ms]    \n  (reduce (fn [m1 m2] \n              (into {} (map #(let [a1 (m1 %) a2 (m2 %)]\n                                [% (cond (and a1 a2) (f a1 a2)\n                                      a1 a1, a2 a2)])\n                   (into (keys m1) (keys m2)))))\n          {} ms))","problem":69,"user":"4e9660ec535dbda64a6f6b44"},{"problem":69,"code":"(fn [f & maps]\n  (let [inside (fn [m [k v]]\n                  (if (contains? m k)\n                    (assoc m k (f (get m k) v))\n                    (assoc m k v)))\n        merger (fn [acc x]\n                  (reduce inside (or acc {}) x))]\n    (reduce merger maps)))","user":"5ba15075e4b0a20761a2339e"},{"code":"(fn [f & maps]\n  (let\n    [kvs (for [m maps, kv m] kv)\n     add (fn [m [k v]]\n           (if (m k)\n             (conj m [k (f (m k) v)])\n             (conj m [k v])))]\n    (reduce add {} kvs)))","problem":69,"user":"4f7f9665e4b033992c121bea"},{"problem":69,"code":"(fn my-merge [f & maps]\n  (reduce (fn [accum next-map]\n            (loop [accum accum\n                   keys (keys next-map)]\n              (if (empty? keys) accum\n                (let [key (first keys)\n                      val (if (contains? accum key) \n                            (f (accum key) (next-map key)) \n                            (next-map key))]\n                  (recur (assoc accum key val) (rest keys)))))) \n          (first maps) (rest maps)))","user":"556405e5e4b0c656e3ff17fb"},{"code":"(fn [m & c]\n  (reduce \n   (fn [a b] \n     (reduce\n      (fn [ai [k v]]\n        (assoc ai k (if-let [vi (ai k)] \n                      (m vi v) \n                      v)))\n      a b))\n   c))","problem":69,"user":"528652fbe4b0239c8a67ae14"},{"problem":69,"code":"(fn m-w\n  [f m1 & maps]\n  (let [m-w-h (fn m-w-h\n                [m1 m2]\n                (println m1)\n                (let [m2-keys (keys m2)]\n                  (loop [ks m2-keys\n                         r m1]\n                    (let [k (first ks)\n                          v (if (get r k)\n                              (f (get r k) (get m2 k))\n                              (get m2 k))]\n                      (if (seq ks)\n                        (recur (rest ks) (merge r {k v}))\n                        r))\n                    )))]\n    (reduce m-w-h m1 maps)))","user":"58de563fe4b0a4d5acaab6e3"},{"code":"(fn merge-maps [& args]\n  (loop [op (first args)\n         to-merge (rest (rest args))\n         res (second args)]\n    (if (empty? to-merge)\n      res\n      (recur \n       op \n       (rest to-merge) \n       (merge res (into {} \n                        (for [[k v] (first to-merge)]\n                          (if (contains? res k) [k (op (get res k) v)] [k v]))))))))","problem":69,"user":"51d360d1e4b099f3b6acddff"},{"problem":69,"code":"(fn my-merge-with [f & maps]\n  (into {} (map (fn [[keyw vec-vec]]\n                  (if (= 1 (count  vec-vec))\n                    [keyw (second (first vec-vec))]\n                    [keyw (reduce #(f (second %1) (second %2)) vec-vec)]))\n                (group-by #(first %) (apply concat maps)))))","user":"58f2e8fbe4b0438e51c2ce94"},{"problem":69,"code":"(fn my-merge-with\n  ([f a & r]\n   (if (= 1 (count r))\n     (let [b (first r)]\n       (loop [remaining (seq b),\n              result a]\n         (if (empty? remaining)\n           result\n           (recur\n             (rest remaining)\n             (if (contains? result (key (first remaining)))\n               (assoc result (key (first remaining)) (f (get result (key (first remaining))) (val (first remaining))))\n               (assoc result (key (first remaining)) (val (first remaining))))))))\n     (my-merge-with f a (apply my-merge-with f (first r) (rest r))))))","user":"57b99d48e4b0fbc9809a27f2"},{"problem":69,"code":"(fn [f & maps]\n  (let [ks (->> maps (map keys) (apply concat) (into #{}))]\n    (into {} (map (fn [k] [k (reduce f (filter (comp not nil?) (map #(get % k) maps)))]) ks))))","user":"542c22bde4b0dad94371f29e"},{"problem":69,"code":"(fn [f & m]\n  (into {}\n    (map (fn [e]\n           (if (> (count (val e)) 1)\n               [(key e) (reduce f (map second (val e)))]\n               [(key e) (second (first (val e)))]))\n      (group-by first (apply concat m)))))","user":"56d4b22de4b0ea9b8538f7bb"},{"problem":69,"code":"(fn [o & s]\n    (reduce \n      (fn [m [f r]] (assoc m f (reduce o  (map second r))))\n      {}\n      (group-by first (mapcat vec s ))\n      )\n    )","user":"51a058dae4b0b292b01ee3f3"},{"code":"(fn [f & ms]\n  (let [keys (reduce\n    (fn [keyset m]\n      (into keyset (map key (seq m))))\n    #{}\n    ms)]\n    (into {} (map (fn [k] [k (reduce f \n      (filter #(not (nil? %)) (map #(get % k) ms)))] ) keys )) ))","problem":69,"user":"5063fe48e4b075d771da6f9e"},{"code":"(fn [f & s] \n  (reduce (fn [s n] \n            (apply conj s\n              (for [m n [k v] n]\n                (if (s k)\n                  {k (f (s k) v)}\n                  {k v}))))\n                      s))","problem":69,"user":"4eb2eae5535d7eef30807351"},{"problem":69,"code":"(fn [op & ms]\n  (reduce (fn [a x]\n            (reduce (fn [aa [k v]]\n                      (let [new-v (if (contains? a k) (op (a k) v) v)]\n                        (assoc aa k new-v))) a x)) {} ms))","user":"5afb4b15e4b0cc2b61a3bcf6"},{"problem":69,"code":"(fn [f & ms]\n  (letfn [(merge [m1 m2]\n            (reduce merge-entry m1 (seq m2))\n            )\n          (merge-entry [m e]\n            (let [[k v] e]\n              (if (contains? m k)\n                (assoc m k (f (get m k) v))\n                (assoc m k v)\n                ))\n            )]\n    (reduce merge ms))\n  )","user":"5628cb07e4b00e49c7cb47ef"},{"problem":69,"code":"(fn [f mp & mps]\n    (reduce (fn [mporig mpnew]\n              (reduce (fn [mporig2 k] \n                        (if (contains? mporig2 k) \n                          (assoc mporig2 k (f (mporig2 k) (mpnew k)))\n                          (assoc mporig2 k (mpnew k))))\n                      mporig (keys mpnew)))\n            {}\n            (conj mps mp)))","user":"543d89dfe4b032a45b869350"},{"code":"(fn [f & maps]\n  (let [\n        ; Produce a set that is the union of the set of keys from two different maps\n        key-union #(into (set (keys %1)) (set (keys %2)))\n        ; Take two arguments, either of which can be nil, and either combine them with f, or\n        ; return the non-nil one\n        apply-f   #(if (first (sort %&)) (apply f %&) (second (sort %&)))]\n    (reduce #(into {} (map (fn [k] [k (apply-f (%1 k) (%2 k))]) (key-union %1 %2))) maps)))","problem":69,"user":"4fa3f91fe4b081705acca196"},{"problem":69,"code":"(fn merge-w [f & maps]\n  (reduce\n   #(reduce-kv (fn [m k v]\n               (if (get m k)\n                 (assoc m k (f (get m k) v))\n                 (assoc m k v)))\n             %1\n             %2)\n   maps))","user":"5561d2c2e4b0c656e3ff17cd"},{"problem":69,"code":"(fn\n  [f & c]\n  (reduce (fn [a m]\n            (reduce-kv \n               #(assoc % %2 (if (m %2) (f %3 (m %2)) %3)) m a)) \n          c))","user":"5339cb07e4b0e30313ee6caf"},{"code":"(fn [f & maps]\n  (let [ks (set (apply concat (map keys maps)))]\n    (into {} (map (fn [k]\n           [k\n            (reduce f\n                   (filter #(not (nil? %)) \n                           (map #(% k) maps)))])\n         ks))))","problem":69,"user":"51696ee7e4b03f62cda68ce8"},{"code":"(fn mw\n([f m] m)\n([f m & ms] \n  (let [\n     m2 (first ms)\n     k (keys m2)\n     rm (reduce #(\n       if (% %2)\n          (assoc % %2 (f (% %2) (m2 %2)))\n          (assoc % %2 (m2 %2))\n       ) m k)\n     ]\n    (apply mw (concat [f rm] (next ms)))\n)))","problem":69,"user":"4dad86e0c9a9d6ed0f99dc57"},{"problem":69,"code":"(fn [f m & ms]\n  (loop [r m\n         others ms]\n    (if (empty? others)\n      r\n      (let [o (first others)]\n        (recur (into r (for [k (keys o)]\n                         {k (if (get r k nil)\n                              (f (get r k) (get o k))\n                              (get o k))}))\n               (rest others))))))","user":"5866b999e4b0f14aab7c886b"},{"problem":69,"code":"(fn merge-on [f & ms]\n  (letfn [(merge-kv [m p]\n                    (let [k (key p) v (val p)]\n                      (if (contains? m k)\n                        (assoc m k (f (get m k) v))\n                        (assoc m k v))))\n          (merge-mcoll [m1 m2]\n                       (reduce merge-kv (or m1 {}) m2))]\n    (reduce merge-mcoll ms)))","user":"56481722e4b0284900eef628"},{"code":"(fn [f & maps]\n\t\t       (reduce (fn [m [k v]]\n\t\t\t\t (if (contains? m k)\n\t\t\t\t     (assoc m k (f (get m k) v))\n\t\t\t\t     (assoc m k v)))\n\t\t\t       {}\n\t\t\t       (apply concat maps)))","problem":69,"user":"4e68fad4535d8ccf87e9fe93"},{"code":"(fn [f & ms]\n  (reduce\n    (fn [lm rm]\n      (reduce (fn [m [k v]]\n        (if (contains? lm k)\n          (assoc m k (f (m k) v))\n          m))\n        (merge rm lm)\n        rm))\n    {} ms))","problem":69,"user":"4f1b0ab3535d64f603146474"},{"problem":69,"code":"(fn [f & maps]\n    (reduce (fn [acc mp]\n              (reduce-kv #(if (contains? % %2) (assoc % %2 (f (% %2) %3)) (assoc % %2 %3)) acc mp))\n            {} maps))","user":"54ad9d76e4b09f271ff37ce6"},{"problem":69,"code":"(fn merge* [f m & args]\n  (let [merge2 (fn [f m m2] ; fun, set, new set\n                 (reduce-kv (fn [m k v] \n                              (if (contains? m k) \n                                (update-in m [k] f v) \n                                (conj m {k v})))\n                            m m2))]\n    (loop [mm m\n           m2 args]\n      (if (empty? m2) mm\n        (recur (merge2 f mm (first m2)) (rest m2))))))","user":"560843dee4b046a4fc0ac00e"},{"problem":69,"code":"(fn [f & maps]\n   (reduce\n      (fn [a m]\n         (reduce-kv\n            (fn [a k v]\n               (if (contains? a k)\n                  (assoc a k (f (a k) v))\n                  (assoc a k v)))\n            a\n            m))\n      {}\n      maps))","user":"55c4cda5e4b0e31453f649a5"},{"code":"(fn [f m & ms]\n  (if (seq ms)\n    (let [m2 (first ms)]\n      (recur f\n             (into m (map (fn [[k v]] (if (contains? m k) {k (f (m k) v)} {k v})) m2))\n             (rest ms) ))\n    m))","problem":69,"user":"4ea365e2535d7eef308072c5"},{"problem":69,"code":"(fn merge-f [fun & maps]\n  (let [\n    reducer (fn [prev-map nxt-map]\n      (reduce\n        #(if (nil? (prev-map %2)) \n          (assoc %1 %2 (nxt-map %2))\n          (assoc %1 %2 (fun (prev-map %2) (nxt-map %2))))\n        prev-map\n        (keys nxt-map)))]\n    (reduce reducer maps)))","user":"5b02ab12e4b0cc2b61a3bd53"},{"problem":69,"code":"(fn [o & a]\n  (reduce (fn [a m]\n          (reduce (fn [b [k v]]\n                    (update-in b [k] #(if-not % v (o % v)))) a m)) (first a) (rest a)))","user":"57642916e4b0994c1922fbee"},{"problem":69,"code":"(fn [f & args]\n  (loop [items args\n         ret {}]\n    (if (empty? items)\n      ret\n      (recur (rest items)\n             (let [current-keys (keys ret)\n                   current (first items)\n                   item-keys (keys current)]\n               (reduce (fn [prev current-key]\n                         (let [prev-val (get prev current-key nil)\n                               current-val (get current current-key)]\n                           (if (nil? prev-val)\n                             (assoc prev current-key current-val)\n                             (assoc prev current-key(f prev-val current-val)))))\n                       ret item-keys))))))","user":"58fed70de4b0438e51c2cfdd"},{"code":"(fn my-merge-with [f & maps]\n   (reduce\n    (fn [merged amap]\n      (reduce \n       (fn [merged [k v]]\n         (if (contains? merged k)\n           (assoc merged k (f (merged k) v))\n           (assoc merged k v)))\n       merged amap))\n    (first maps)\n    (rest maps)))","problem":69,"user":"51a768e0e4b0da5f497bde84"},{"problem":69,"code":"(fn custom-merge-with [f & s]\n  (let [ks (distinct (mapcat keys s))] \n    (into {} (for [k ks] (vector k (reduce f (filter #(not (nil? %)) (map #(get % k) s))))))))","user":"59f78b49e4b0ca45a743a30e"},{"code":"(fn [f & maps]   \r\n  (reduce \r\n    #(reduce       \r\n       (fn [m [k v]] (assoc m k (if-let [v1 (get m k)] (f v1 v) v)))\r\n       %1 %2)\r\n    {} maps))","problem":69,"user":"4e513758535dc968683fc4f3"},{"problem":69,"code":"(fn\n    [f m & ms]\n    (reduce\n      (fn [m1 m2]\n        (merge\n          m1\n          (apply hash-map\n            (mapcat\n              (fn [k]\n                [\n                  k\n                  (if\n                    (contains? m1 k)\n                    (f\n                      (get m1 k)\n                      (get m2 k)\n                    )\n                    (get m2 k)\n                  )\n                ]\n              )\n              (keys m2)\n            )\n          )\n        )\n      )\n      m\n      ms\n    )\n  )","user":"5784e177e4b0ebec4cfb74cf"},{"problem":69,"code":"(fn mrg-wth [f & maps]\n  (let [ks (distinct (flatten (map keys maps)))]\n    (loop [ks ks\n           res {}]\n      (if (empty? ks)\n        res\n        (let [k (first ks)\n              maps (filter #(get % k) maps)\n              vs (map #(get % k) maps)]\n          (recur (rest ks) (assoc res k (reduce f vs))))))))","user":"5703eda3e4b08d47c9778200"},{"problem":69,"code":"(fn [f & ms] (reduce ((fn [f] (fn [m1 m2]\n                            (reduce (fn [m k] (assoc m k (if (get m k) (f (get m k) (get m2 k)) (get m2 k))))\n                                    m1\n                                    (keys m2)))) f) {} ms))","user":"5b3f2ba9e4b02d533a91bc09"},{"problem":69,"code":"(fn [f & maps]\n  (reduce\n   #(reduce\n     (fn [m [k v]]\n       (assoc m k (if (contains? m k) (f (m k) v) v))\n      )\n     %1 %2)\n   {}\n   maps\n  )\n)","user":"5cebafbbe4b0a17bb84e2be6"},{"code":"(fn [o i j & x] \n  (if (seq j)\n    (recur o\n           (reduce #(let [[k v] %2] (assoc %1 k (if-let [w (%1 k)] (o w v) v))) i j)\n           (first x)\n           (rest x))\n    i))","problem":69,"user":"4efb2fd7535dced4c769f274"},{"code":"#(reduce (fn [m [k v]]\n           (assoc m k (if (m k)\n             (% (m k) v)\n             v)))\n         {}\n         (apply concat %&))","problem":69,"user":"4ebaf790535dfed6da9c6d6e"},{"problem":69,"code":"(letfn [(mergeinto [m1 m2 f]\n          (loop [r m1 k (keys m2)]\n            (if (empty? k)\n              r\n              (recur\n                (assoc r (first k) (if-let [v (get r (first k))]\n                                     (f v (get m2 (first k)))\n                                     (get m2 (first k))))\n                (rest k)))))]\n\n  (fn mergewith [f & maps]\n    (loop [r {} ms (seq maps)]\n      (if (empty? ms)\n        r\n        (recur (mergeinto r (first ms) f) (rest ms)))))\n  )","user":"5f9c4113e4b0715f5002d821"},{"code":"#(into {} (for [[k v] (group-by key (apply concat %&))]\n     {k (reduce % (vals v))}))","problem":69,"user":"4f036d9b535dcb61093f6ac1"},{"code":"(fn a [f m & ms] (loop [m m ms ms] (if-not(empty? ms)(recur (loop [m m nm (first ms)] (if(empty? nm)(identity m)(let [k (key(first nm)) v (val(first nm))] (recur (if-not(nil? (m k))(assoc m k (f (m k) v))(assoc m k v))(next nm)))))(next ms))(identity m))))","problem":69,"user":"527a8eb7e4b03e8d9a4a755f"},{"problem":69,"code":"(fn [f & maps]\n  (loop [[head & tail] maps\n         acc {}]\n    (if head\n      (recur\n        tail \n        (reduce\n          (fn [m [k v]]\n            (let [old-v (get m k)]\n              (if old-v\n                (assoc m k (f old-v v))\n                (assoc m k v))))\n          acc head))\n      acc)))","user":"53f7820be4b0de5c41848560"},{"problem":69,"code":"(fn\n  [f init-m & args-m]\n  (reduce\n      #(reduce-kv\n        (fn [m k v]\n          (if-let [old-v (m k)]\n            (assoc m k (f old-v v))\n            (assoc m k v))) %1 %2)\n    init-m args-m))","user":"57625c18e4b0994c1922fba4"},{"problem":69,"code":"(fn [f & args]\n  (letfn [(merge-item [m k v]\n            (if (contains? m k)\n              (assoc m k (f (get m k) v))\n              (assoc m k v)))]\n    (reduce (fn [m1 m2] (reduce-kv merge-item m1 m2)) args)))","user":"59c94a69e4b0a024fb6ae576"},{"code":"(fn [f & ms]\n  (reduce\n   (fn [m1 m2]\n     (reduce\n      (fn [m [k v]]\n        (if (m k)\n          (conj m {k (f (m k) v)})\n          (conj m {k v})))\n      m1\n      m2))\n   ms))","problem":69,"user":"521b9f92e4b0c4ef0be8304c"},{"code":"(fn [o & h]\n  (reduce into\n    (for [k (keys (reduce into h))]\n      {k (#(if (next %) \n             (apply o %)\n             (first %))\n          (filter (complement nil?)\n                  (map #(get % k) h)))})))","problem":69,"user":"4e49badd535dc968683fc4c9"},{"code":"(fn [f & ms]\n  (let [combine #(loop [m1 %1, m2 %2]\n                    (if (empty? m2)\n                      m1\n                      (let [k (first (keys m2))]\n                        (recur (assoc m1 k (if (m1 k) (f (m1 k) (m2 k)) (m2 k))) (dissoc m2 k)))))]\n    (reduce combine (first ms) (rest ms))))","problem":69,"user":"4edab806535d10e5ff6f5311"},{"problem":69,"code":"(fn [func & themaps]\n  (let [allkeys (distinct (flatten (map keys themaps)))\n        allvals (for [x allkeys] (remove nil? (map #(% x) themaps)))\n        funcvals (for [x allvals] (if (= 1 (count x)) (first x) (apply func x)))]\n    (apply hash-map (interleave allkeys funcvals))))","user":"5705e404e4b0b0fb43fd0676"},{"problem":69,"code":"(fn merge-with-custom [f m1 & maps]\n  (reduce (fn [res mi]\n            (reduce (fn [acc [k v]]\n                      (if (contains? acc k)\n                        (assoc acc k (f (get acc k) v))\n                        (assoc acc k v))) res mi))\n          m1 maps))","user":"5dc53ddee4b02f9375f4e1bd"},{"code":"(fn [f & m]\n  (reduce\n    #(reduce\n      (fn [a [k v]]\n        (if (a k)\n          (update-in a [k] f v)\n          (assoc a k v)))\n      %\n      %2)\n    m))","problem":69,"user":"51b3f109e4b0f094dd986fa9"},{"code":"(fn merge-w*\n          ([f m1 m2]\n              (reduce (fn [acc [k v]]\n                          (assoc acc k (if-let [v* (m1 k)]\n                                               (f v* v)\n                                               v))) m1 m2))\n        ([f m1 m2 m3 & ms]\n            (apply merge-w* f (merge-w* f m1 m2) m3 ms)))","problem":69,"user":"4e599577535d8a8b8723a29f"},{"problem":69,"code":"(fn merge-with-fn [f m1 & maps]\n  (if-let [m2 (first maps)]\n    (apply\n      merge-with-fn f\n      (loop [result m1, ks (keys m2)]\n        (if-let [k (first ks)]\n          (if (get result k)\n            (recur (assoc result k (f (get result k) (get m2 k))) (rest ks))\n            (recur (assoc result k (get m2 k)) (rest ks)))\n          result))\n      (rest maps))\n    m1))","user":"54f2fe9fe4b050824f58f5b8"},{"problem":69,"code":"(fn [f & ms]\n    (let [ks (into #{} (mapcat keys ms))\n          vs (map (fn [k] (keep #(% k) ms)) ks)]\n      (into {} (map (fn [k v] [k (reduce f v)]) ks vs))))","user":"5470b3d0e4b00cfc9eacc1bb"},{"problem":69,"code":"(fn [f & ms]\n   (reduce\n     (fn [a b]\n       (reduce\n         #(if (% (first %2))\n            (update-in % [(first %2)] f (last %2))\n            (assoc-in % [(first %2)] (last %2))\n            )\n         a b)\n       )\n     ms)\n   )","user":"5857d27de4b0f14aab7c8710"},{"code":"(fn [f & args]\n           (reduce (fn [xs ys]\n                     (let [xkeys     (set (keys xs))\n                           ykeys     (set (keys ys))\n                           allkeys   (clojure.set/union xkeys ykeys)\n                           common    (clojure.set/intersection xkeys ykeys)\n                           sepkeys   (remove #(contains? common %) allkeys)\n                           result    (into (select-keys xs sepkeys)\n                                           (select-keys ys sepkeys))\n                           sepmap    (map #(vector % (f (get xs %) (get ys %)))\n                                          common)]\n                       (into result sepmap)))\n                   args))","problem":69,"user":"50aa60bee4b056ee01935865"},{"problem":69,"code":"(fn my-merge-with [f & coll]\n        (let [key-set (set (mapcat keys coll))]\n          (zipmap key-set\n                  (map (fn [k]\n                         (let [v (remove nil? (map #(get % k) coll))]\n                           (if (> (count v) 1)\n                             (reduce f v)\n                             (first v))))\n                       key-set))))","user":"540c54a7e4b0addc1aec6700"},{"code":"(fn [f & ms]\n    (reduce (fn [m m2] (reduce (fn [m e]\n                                 (if-let [v (m (first e))]\n                                   (assoc m (first e) (f v (second e)))\n                                   (conj m e))) m m2)) ms))","problem":69,"user":"52753740e4b03e8d9a4a74c1"},{"problem":69,"code":"(fn [f coll & args]\n          (if (empty? args)\n            coll\n            (recur f\n                   (reduce (fn [coll [k v]]\n                             (assoc coll k\n                                         (if (contains? coll k)\n                                           (f (coll k) v)\n                                           v)))\n                           coll (first args))\n                   (rest args))))","user":"531c6e72e4b08068f379eda0"},{"code":"(fn mer-with-fu\n  [f & maps]\n  (let [fmap (first maps)\n        key-set (into #{} (mapcat keys maps))]\n    (into {}\n     (map\n      (fn [key-set]\n        (assoc {} key-set (reduce f (remove nil? (map #(% key-set) maps)))))\n      key-set))))","problem":69,"user":"4e3bcccd535deb9a81d77f56"},{"code":"(fn [f x & more]\n        (letfn [ (mw [m y]\n           (if (empty? y) m \n             (if (contains? m (ffirst y)) \n               (recur (assoc m (ffirst y) (f (m (ffirst y)) (last (first y)) ))  (rest y))\n               (recur (assoc m (ffirst y) (last (first y)))  (rest y)) \n               )))]\n               (mw x (apply concat more)))\n      )","problem":69,"user":"4fccdc75e4b0ee37620e186d"},{"problem":69,"code":"(fn [f m & ms]\n  (reduce\n    (fn [acc m]\n      (reduce\n        (fn [acc [k v]]\n          (if (find acc k)\n            (update-in acc [k] f v)\n            (assoc acc k v)))\n        acc\n        m))\n    m\n    ms))","user":"5d1c047fe4b02ea6f0fb6988"},{"code":"(fn t [f x & xs]\n  (if (empty? xs)\n    x\n    (apply t f \n           (reduce \n             #(assoc \n                % \n                (first %2) \n                (if (get % (first %2))\n                  (f (get % (first %2)) (second %2))\n                  (second %2)))\n             x \n             (first xs)) \n           (next xs))))","problem":69,"user":"4ef6e689535dced4c769f24f"},{"problem":69,"code":"(fn [f & ms]\n  (reduce (fn [m1 m2]\n            (loop [m m1 ks (keys m2)]\n              (let [k2 (first ks)\n                    v2 (get m2 k2)\n                    v (get m k2)]\n                (if-not k2\n                  m\n                  (if v\n                    (recur (assoc m k2 (f v v2)) (rest ks))\n                    (recur (assoc m k2 v2) (rest ks)))))))\n          ms))","user":"51aab611e4b04e3dc0c27b2d"},{"problem":69,"code":"(fn p69 [f & maps]\n  (reduce \n   (fn [bosmap mp]\n     (reduce #(if (nil? (get %1 %2))\n                (assoc %1 %2 (get mp %2))\n                (assoc %1 %2 (apply f (get %1 %2) (vector  (get mp %2)) ))\n                )\n             bosmap\n             (keys mp)))\n   {} maps))","user":"4ec4d723535dcc7ae8597d65"},{"problem":69,"code":"(fn\n  [f & maps]\n  (letfn [(step\n            [m [k v]] \n            (if (contains? m k)\n              (assoc m k (f (get m k) v))\n              (assoc m k v)))]\n    (reduce #(reduce step %1 %2) maps)))","user":"52dfc89be4b09f7907dd1405"},{"code":"(fn mw [merge-function & maps]\n  (let [ymerge (fn [f m1 m2]\n                 (into m1\n  \t       (loop [ks (keys m2) acc {}]\n                         (if (seq ks)\n                           (let [fk (first ks)\n                                 rk (rest ks)]\n                             (if (m1 fk)\n                               (recur rk (into acc {fk (f (m1 fk) (m2 fk))}))\n                               (recur rk (into acc {fk (m2 fk)}))))\n                           acc))))]\n    (reduce #(ymerge merge-function %1 %2) {} maps)))","problem":69,"user":"4f0d093b535d0136e6c22313"},{"problem":69,"code":"(fn [func & colls]\n   (reduce\n     (fn [acc-map x]\n       (merge acc-map\n              (reduce\n                (fn [acc [k v]]\n                  (if (acc-map k)\n                    (assoc acc k (func (acc-map k) v))\n                    (assoc acc k v)))\n                {}\n                x)))\n     {}\n     colls))","user":"554bd33ce4b0a04f7929959a"},{"code":"(fn [ f & ms ]\n    (reduce\n            #(->> (concat % %2)\n                  (group-by first)\n                  vals\n                  (map (fn [p] [(first (first p)) (reduce f (map last p))]))\n                  (apply conj {}))\n        ms))","problem":69,"user":"5398305fe4b0b51d73faaef6"},{"problem":69,"code":"(fn [f & maps]\n  (loop [merged-map {} current-map (first maps) maps-left (rest maps)]\n    (if (nil? current-map)\n      merged-map\n      (recur \n        (->> \n          (for [[k v] current-map]\n            (if (contains? merged-map k)\n              [k (apply f [(get merged-map k) v])]\n              [k v]\n            )\n          )\n          (into {})\n          (merge merged-map)\n        )\n        (first maps-left)\n        (rest maps-left)\n      )\n    )\n  )\n)","user":"5e8ce2fee4b0cb0169546328"},{"code":"(fn mw\n  [f & maps]\n  (when (some identity maps)\n    (let [merge-entry (fn [m e]\n\t\t\t(let [k (key e) v (val e)]\n\t\t\t  (if (contains? m k)\n\t\t\t    (assoc m k (f (get m k) v))\n\t\t\t    (assoc m k v))))\n          merge (fn [m1 m2]\n\t\t   (reduce merge-entry (or m1 {}) (seq m2)))]\n      (reduce merge maps))))","problem":69,"user":"512474ede4b02c3f2a072cce"},{"code":"(fn [op & s] (reduce\r\n   #(into (conj % %2) (for [[k1 v1] % [k2 v2] %2]\r\n          (if (= k1 k2) [k1 (op v1 v2)]))) s))","problem":69,"user":"50336c6be4b0c6c1199c710f"},{"problem":69,"code":"(fn [f & [m & ms]]\n   (reduce (fn [m1 m2]\n             (merge m1 (->> (for [[k2 v2] m2]\n                              (if-let [v1 (get m1 k2)]\n                                [k2 (f v1 v2)]\n                                [k2 v2]))\n                            (remove nil?)\n                            (into {}))))\n           m\n           ms))","user":"55f2e47de4b06e875b46ce4d"},{"code":"(fn [in-fn & inputs]\n    (let [grouped (-> (group-by key (apply concat inputs)) sort)\n          my-keys (keys grouped)\n          my-vals (vals grouped)]\n      (zipmap my-keys (map (partial reduce in-fn) (for [x my-vals] (map last x))))))","problem":69,"user":"52016fd3e4b0b2e020a18f10"},{"code":"(fn m-with [f a b & r]\n  (let [merged (apply merge a b\n                (for [[k v] b :when (a k)]\n                  {k (f (a k) v)}))]\n    (if (empty? r)\n      merged\n      (apply m-with f merged r))))","problem":69,"user":"4fb1d907e4b081705acca282"},{"code":"(fn [fun & maps]\n  (reduce\n   #(loop [acc %1\n           [fk & rk] (keys %2)]\n      (if (nil? fk)\n        acc\n        (recur\n         (if-let [acc-val (acc fk)]\n           (assoc acc fk (fun acc-val (%2 fk)))\n           (assoc acc fk (%2 fk)))\n         rk)))\n   maps))","problem":69,"user":"52dd4fb4e4b09f7907dd13df"},{"problem":69,"code":"(fn [f & m]\n  (reduce (fn [a [k v]]\n            (assoc a k (if (a k) (f (a k) v) v)))\n          {}\n          (for [x m z x] z)))","user":"505106fee4b05ab4c7e07d38"},{"code":"(fn[f & m](reduce #(reduce-kv(fn[x k v](assoc x k(if(x k)(f(x k)v)v)))% %2)m))","problem":69,"user":"5088082ae4b0198722bd9854"},{"code":"(fn [f & args]\n  (into\n    {}\n    (map (fn [[k v]] [k (if (> (count v) 1) (apply f v) (first v))])\n         (map (fn [[k v]] [k (filter (comp not nil?) v)])\n              (for [k (keys (apply merge args))] [k (map #(get % k) args)])))))","problem":69,"user":"50d8de3fe4b01f0871336e72"},{"problem":69,"code":"(fn mergewith [func & maps]\n  (letfn [ (getVal [vala valb]\n                  (cond\n                    (nil? vala) valb\n                    (nil? valb) vala\n                    :else (func vala valb)))\n           (mergeMaps [mapa mapb]\n                      (let [ mapkeys (keys (merge mapa mapb))\n                             mapvals (map #(getVal (mapa %) (mapb %)) mapkeys)]\n                     (zipmap mapkeys mapvals)))]\n    (reduce mergeMaps maps)))","user":"57131dfbe4b07c98581c3a98"},{"code":"(fn [f & ds]\n  (loop [acc (first ds) ds (rest ds)]\n    (if (seq ds)\n      (recur\n       (into acc (for [[k v] (first ds)] (if (contains? acc k) [k (f (acc k) v)] [k v])))\n       (rest ds))\n      acc)))","problem":69,"user":"504f865ee4b0a02f9cffde90"},{"problem":69,"code":"(fn [f & maps]\n  (reduce (fn [m [k v]] (assoc m k (if (m k) (f (m k) v) v))) {} (mapcat seq maps)))","user":"536046a9e4b063bf7a5f8fe1"},{"problem":69,"code":"(fn [f & ms]\n  (reduce (fn [m kv]\n            (update-in m [(first kv)]\n                       #(if (nil? %) (second kv)\n                             (f % (second kv)))))\n          {} (apply concat ms))\n  )","user":"589037b4e4b00487982d51d0"},{"code":"(fn [o m & s]\n  (reduce #(reduce\n             (fn [m [k v]]\n               (assoc m k\n                 \t  (if (m k) \n                        (o (m k) v)\n                        v))) % %2)\n          m s))","problem":69,"user":"51a10b2ce4b0b292b01ee3fe"},{"code":"(fn func [f & maps]\r\n  (reduce #(reduce (fn [m [k v]]\r\n                     (if (contains? m k) \r\n                       (conj m [k (f (m k) v)])\r\n                       (conj m [k v]))) %1 %2) maps))","problem":69,"user":"505dd5c4e4b0e6aca564be0e"},{"problem":69,"code":"(fn [f & ms]\n  (reduce\n   (fn [m1 m2]\n     (reduce \n      (fn [m k]\n        (assoc m k (if (contains? m k)\n                     (f (m1 k) (m2 k))\n                     (m2 k))))\n      m1\n      (keys m2)))\n   ms))","user":"5af8221ce4b0cc2b61a3bccd"},{"problem":69,"code":"(fn [f & m-list]\n  (loop [[head & tail] m-list\n         result {}]\n    (let [head-keys (set (keys head))\n          overlap (clojure.set/intersection head-keys (set (keys result)))\n          new-keys (clojure.set/difference head-keys overlap)\n          new-result (conj (reduce #(assoc %1 %2 (apply f [(get result %2) (get head %2)])) result overlap) (select-keys head new-keys))]\n      (if (empty? tail) new-result (recur tail new-result))\n      )\n    )\n  )","user":"59073e0fe4b047aa04b19950"},{"problem":69,"code":"(fn [f start & maps]\n   (->> maps\n        (reduce (fn [s m] (reduce\n                               (fn [st [k v]] (if\n                                               (st k)\n                                                (assoc st k (f (st k) v))\n                                                (assoc st k v)))\n                               s m))\n                start)))","user":"5fa96ddbe4b0fa27300f3dec"},{"problem":69,"code":"(fn x [f h & t]  \n  (if (empty? t) h\n    (recur f (conj \n              h\n              (into {} (map \n                     (fn [[k v]] \n                       (if (contains? h k) {k (f (get h k) v)} \n                         {k v})) \n                     (first t))))\n           (rest t))))","user":"5b59d176e4b02d533a91bd86"},{"problem":69,"code":"(fn [f & maps]\n  (let\n    [inner-f (fn [m [k v]] (if (contains? m k)\n                  (assoc m k (f (get m k) v))\n                  (assoc m k v)))\n     outer-f (fn [m1 m2] (reduce inner-f m1 m2))]\n    (reduce outer-f maps)))","user":"5368fedee4b0243289761e93"},{"code":"(fn [f & maps]\n     (when (some identity maps)\n       (let [merge-entry (fn [m e]\n               (let [k (key e) v (val e)]\n                 (if (contains? m k)\n                   (assoc m k (f (get m k) v))\n                   (assoc m k v))))\n             merge2 (fn [m1 m2]\n              (reduce merge-entry (or m1 {}) (seq m2)))]\n         (reduce merge2 maps))))","problem":69,"user":"52a88c4de4b0c58976d9ac30"},{"code":"(fn [f & args]\n  (apply hash-map(apply concat\n    (map\n      (fn [k] [k (reduce f (filter #(not (nil? %)) (map #(% k) args)))])\n      (set (apply concat (map keys args)))))))","problem":69,"user":"5307e4ece4b02e82168697a9"},{"problem":69,"code":"(fn merge-map [f xs & xs2]\n  (let [assoc1 (fn [xs [k v]]\n                  (let [val-in-result (get xs k)]\n                    (if val-in-result\n                      (assoc xs k (f val-in-result v))\n                      (assoc xs k v))))]\n    (reduce (fn[xs m]\n              (reduce assoc1 xs m)) xs xs2)))","user":"54f86b8ce4b01ecee9d88828"},{"problem":69,"code":"(fn m-w [f & args]\n  (reduce\n  \t(fn [init-map new-map]\n    \t(into init-map \n        \t  (for [[k v] new-map] \n            \t(if (init-map k) [k (f (init-map k) v)] [k v]))))\n  \targs))","user":"54bd3aefe4b0ed20f4ff6edb"},{"problem":69,"code":"(fn solve [f & r]\n  (let\n    [pairs (apply concat (map #(apply list %) r))\n     almost (group-by first pairs)\n    ]\n    (into {} (for [[k v] almost] [k (reduce f (map second v))]))\n  )\n)","user":"56f258d3e4b04a395b9a04a1"},{"code":"(fn my-merge-with [f & maps]\n  (reduce\n    (fn [a b]\n      (reduce\n        (fn [x [k v]]\n          (assoc x k (if (b k) (f v (b k)) v)))\n        b a))\n    (first maps) (rest maps)))","problem":69,"user":"4f246938e4b0d66497709fec"},{"problem":69,"code":"(fn [f & maps]\n     (let [g (group-by first (apply concat (map #(apply list %) maps)))]\n       (println (keys g) (vals g))\n       (zipmap (keys g) (map #(reduce f (map second %)) (vals g)))))","user":"5567f164e4b0c656e3ff184d"},{"problem":69,"code":"(fn [f & maps]\n  (let [pairs (apply concat (map seq maps))]\n    (reduce (fn [init pair]\n              (if (get init (first pair))\n                (assoc init\n                       (first pair)\n                       (f (get init (first pair)) (second pair)))\n                (assoc init (first pair) (second pair))))\n            {}\n            pairs)))","user":"5297dcc5e4b02ebb4ef75047"},{"problem":69,"code":"(fn [func map & maps]\n   (reduce (fn [m1 m2]  (reduce (fn [m v]\n                                    (update-in m [(first v)]\n                                               (fn [x1 x2] (if (nil? x1) x2 (func x1 x2))) (second v) )\n                                    )\n                                  m1  m2)) map maps))","user":"5471f2fbe4b094393f72dd70"},{"problem":69,"code":"(fn [f r & other]\n  (reduce\n   (fn [r m]\n     (reduce\n      (fn [r [k v]]\n        (if (contains? r k)\n          (assoc r k (f (r k) v))\n          (assoc r k v)))\n      r\n      m))\n   r\n   other))","user":"5801eed1e4b0a837a8b30c63"},{"code":"(fn [f & s]\n  (reduce #(into % (for [[k v] %2]\n                     [k (if (contains? % k)\n                          (f (% k) v)\n                          v)]))\n          s))","problem":69,"user":"4fa6d532e4b081705acca1be"},{"problem":69,"code":"(fn [f & maps]\n  (loop [res {} maps maps]\n    (if (empty? maps)\n      res\n      (recur\n       (loop [mer res m (first maps)]\n               (if (empty? m)\n                 mer\n                 (recur\n                  (let [k (key (first m)) v (val (first m))]\n                    (if (contains? mer k)\n                      (assoc mer k (f (get mer k) v))\n                      (assoc mer k v)))\n                  (rest m))))\n       (rest maps)))))","user":"54055aa9e4b0addc1aec6665"},{"problem":69,"code":"(fn [f mf & ml]   \n(reduce \n    (fn[m1 m2]\n      (reduce #(if \n              (get %1 (key %2))\n              (assoc %1 (key %2) (f (get %1 (key %2)) (val %2)))\n              (assoc %1 (key %2) (val %2))) m1  m2 )) mf ml))","user":"4e8849c5535d8b9bb0147ca4"},{"problem":69,"code":"(fn my-merge-with\n  [f & ms]\n  (reduce (fn [m [k v]]\n            (assoc m k (reduce f (map second v))))\n          {}\n          (group-by key (apply concat ms))))","user":"5ecfd429e4b016b56eae05a9"},{"code":"(fn merge-with4j\n  [f & args]\n  (->> args\n       (apply concat)\n       (group-by first)\n       vals\n       (map (fn [m]  [(ffirst m)\n                      (reduce f (map second m))]))\n       (apply concat)\n       (apply hash-map)))","problem":69,"user":"524f4256e4b0541d1855b808"},{"code":"(fn f-merge-with \n  ([f m1 m2]\n    (letfn [(f-merge [[key val]]\n                     (if (contains? m2 key)\n                       [key (f val (get m2 key))]\n                       [key val]))]\n      (merge m2 (into {} (map f-merge m1)))))\n  ([f m1 m2 & ms]\n    (if (seq ms) (apply f-merge-with f (f-merge-with f m1 m2) (first ms) (rest ms))\n      (f-merge-with f m1 m2))))","problem":69,"user":"50eddbc4e4b06330c1f87c4b"},{"problem":69,"code":"(fn [f & args]\n  (reduce (fn [map1 map2]\n            (reduce (fn [m [k v]]\n                      (if-let [v2 (m k)]\n                        (assoc m k (f v2 v))\n                        (assoc m k v))) map1 map2))\n          args))","user":"57e6997ee4b0bfb2137f5af0"},{"problem":69,"code":"(fn [f & args]\n  (reduce (fn [accum m]\n            (merge accum\n                   (into {} (map\n                    (fn [[k v]]\n                      (if (contains? accum k)\n                        [k (f (accum k) v)]\n                        [k v]))\n                    m))))\n          (first args)\n          (rest args)))","user":"5ec6de19e4b08d0ec38692da"},{"problem":69,"code":"(fn new-merge\n  [f & maps]\n  (reduce (fn [m1 m2]\n            (reduce (fn [m [k v]]\n                      (if (contains? m k)\n                        (update-in m [k] f v)\n                        (assoc m k v)))\n                    m1 m2))\n          maps)\n  )","user":"5cd4e1b2e4b0ccb061962927"},{"problem":69,"code":"(fn [f & maps]\n  (let [f-v1-v2 #(if % (f % (%2 %3)) (%2 %3))\n        update (fn [m acc-m k] (update-in acc-m [k] f-v1-v2 m k))\n        merge-m (fn [acc map] (reduce (partial update map) acc (keys map)))]\n    (reduce merge-m maps)))","user":"6026737ee4b0d5df2af2222f"},{"code":"(fn [f & maps]\n  (when (some identity maps)\n    (let [merge-entry (fn [m e]\n  \t\t(let [k (key e) v (val e)]\n\t\t\t  (if (contains? m k)\n\t\t\t    (assoc m k (f (get m k) v))\n\t\t\t    (assoc m k v))))\n          merge2 (fn [m1 m2]\n\t\t   (reduce merge-entry (or m1 {}) (seq m2)))]\n      (reduce merge2 maps))))","problem":69,"user":"4ec5bec6535d6d7199dd36b3"},{"code":"(fn mergef [f m1 m2 & m3]\r\n  (println m1 m2)\r\n  (let [ks (clojure.set/union (keys m1) (keys m2)),\r\n        merged (into {}\r\n                     (for [k ks]\r\n                       (cond (and (m1 k) (m2 k)) [k (f (m1 k) (m2 k))],\r\n                             (m1 k) [k (m1 k)],\r\n                             (m2 k) [k (m2 k)])))]\r\n    (if (empty? m3)\r\n      merged\r\n      (apply mergef f merged m3))))","problem":69,"user":"4f62b29ce4b0defedf855fd9"},{"problem":69,"code":"(fn [f & maps] \n  (reduce \n    (fn [acc [k v]] \n      (assoc acc k (if (contains? acc k) (f (get acc k) v) v)))\n   {} (apply concat maps)))","user":"5668dcc6e4b04acd4f672df8"},{"problem":69,"code":"(fn [f to & m]\n   (let [g #(if (contains? % (key %2))\n              (assoc % (key %2) (f (% (key %2)) (val %2)))\n              (assoc % (key %2) (val %2)))\n              ]\n     (reduce #(reduce g % %2) to m)\n     ))","user":"557c6ca6e4b05c286339e0c4"},{"problem":69,"code":"(fn my-merge-with [f m & ms]\n  (reduce (fn [map1 map2]\n            (let [common (apply clojure.set/intersection (map set (map keys [map1 map2])))]\n              (merge map1 map2 (reduce #(assoc %1 %2 (f (map1 %2) (map2 %2))) {} common)))) m ms))","user":"5638b88de4b0bfe05bf117e9"},{"problem":69,"code":"(fn my-merge-with\n  [f & s]\n  (let [dkeys (distinct (mapcat keys s))\n        m {}\n        v (apply map list (map #(map %1 dkeys) s)) ]\n    (apply merge (map (partial assoc {})\n          dkeys\n          (map (fn [xs]\n                 (if (#{1} (count xs))\n                   (first xs)\n                   (apply f xs)))\n               (map (partial filter #(not (nil? %))) v))))))","user":"557e9d17e4b05c286339e0d8"},{"code":"(fn [f first-map & other-maps]\n  (if (empty? other-maps)\n      first-map\n      (recur f\n             (reduce (fn [merged [key value]]\n                       (assoc merged\n                              key\n                              (if (contains? merged key)\n                                  (f (merged key) value)\n                                  value)))\n                     first-map\n                     (first other-maps))\n             (rest other-maps))))","problem":69,"user":"4e7c8fd1535db169f9c796be"},{"problem":69,"code":"(fn [f & maps]\n  (reduce (fn [m-base m-add]\n            (let [m-res (concat (seq m-base) (seq m-add))]\n              (->> m-res\n                  (group-by first)\n                  seq\n                  (map (fn [x]\n                         (reduce #(conj [(first %1)]\n                                        (f (second %1) (second  %2)))\n                                 (second x))))\n                  (into {}))))\n          maps))","user":"5ddb6151e4b0948ae9d9adb0"},{"code":"(fn merges [f seq & seqs]\n  (letfn[( subfn [f all sub top ]\n      (loop [all all \n             sub sub]\n        (if(empty? sub)\n          all\n          (let [ car (first sub)]\n            (recur (assoc all car (f (all car ) (top car )))\n                   (rest sub))))))]\n    (if(empty? seqs)\n      seq\n      (let [top (first seqs)\n           ; _ (println (keys top))\n            all (->>\n                  (filter #(not (contains?  seq  %)) (keys top))\n                  (select-keys top )\n                  (merge seq ))\n           ;_ (println all)\n            sub  (filter #(contains?  seq %) (keys top))\n           ; _ (println sub)\n           ]\n        (if(empty? sub)\n          (recur f all (rest seqs))\n          (recur f\n                 (subfn f all sub top )\n                 (rest seqs)))))))","problem":69,"user":"5273562ae4b03e8d9a4a7479"},{"problem":69,"code":"(fn [f & maps]\n    (loop [acc {}\n           maps maps]\n      (if (empty? maps)\n        acc\n        (recur\n         (reduce\n          (fn [acc [key val]]\n            (if (contains? acc key)\n              (assoc acc key (f (acc key) val))\n              (assoc acc key val)))\n          acc (first maps))\n         (rest maps)))))","user":"555f3bfde4b0a2eb076a39c1"},{"problem":69,"code":"(fn [f a-map & maps]\n  (let [red-func #(assoc %1\n                         (first %2)\n                         (if (%1 (first %2))\n                           (f (%1 (first %2)) (second %2))\n                           (second %2)))]\n    (loop [lseq maps acc a-map]\n      (if (empty? lseq)\n        acc\n        (recur (rest lseq) (reduce red-func acc (first lseq)))))))","user":"56cb4d06e4b0ea9b8538f72e"},{"problem":69,"code":"(fn [f & maps]\n  (reduce \n    (fn [m [k v]] \n      (let [new-value (if (contains? m k) (f (get m k) v) v)]\n        (assoc m k new-value)))\n    {}\n    (mapcat seq maps)))","user":"5821b018e4b04b46fc4b0f80"},{"code":"(fn [f & s] (reduce #(reduce (fn [m [k v]] (assoc m k (if (m k) (f (m k) v) v))) % %2) s))","problem":69,"user":"51b90b88e4b050a1176cd6a2"},{"problem":69,"code":"(fn f-merge [f & ms]\n\t(loop [li (rest ms) m (first ms)]\n\t\t(if (empty? li)\n\t\t\tm\n\t\t\t(recur (rest li)\n\t\t\t\t\t\t (conj m\n\t\t\t\t\t\t\t\t\t (loop [sli (first li) r {}]\n\t\t\t\t\t\t\t\t\t\t (if (empty? sli)\n\t\t\t\t\t\t\t\t\t\t\t r\n\t\t\t\t\t\t\t\t\t\t\t (recur (rest sli)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(conj r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t[(ffirst sli)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t (if (not (nil? (get m (ffirst sli))))\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(f (get m (ffirst sli)) (last (first sli)))\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(last (first sli)))])))))))))","user":"52979551e4b02ebb4ef75043"},{"problem":69,"code":"(fn [f m & ms]\n  (reduce (fn [a x] (reduce #(if (contains? %1 (first %2))\n                               (update-in %1 [(first %2)] f (second %2))\n                               (conj %1 %2)) a x))\n          m ms))","user":"549c6792e4b0f3d1d8e70f8b"},{"problem":69,"code":"(fn [f & maps]\n   (let [merge-entry\n         (fn [m e]\n           (let [k (key e) v (val e)]\n             (if (contains? m k)\n               (assoc m k (f (get m k) v))\n               (assoc m k v))))\n         merge2 (fn [m1 m2]\n                  (reduce merge-entry (or m1 {}) (seq m2)))]\n     (reduce merge2 maps)))","user":"5be0306be4b0ed4b8aab4c7d"},{"problem":69,"code":"(fn __ [f & maps]\n  (letfn [(merge-with-fn [f map1 map2]\n                        (let [keys1 (set (keys map1))\n                              keys2 (set (keys map2))]\n                          (merge map1 map2 (into {} (for [k (clojure.set/intersection keys1 keys2)] [k (f (map1 k) (map2 k))])))))]\n    (reduce #(merge-with-fn f % %2) maps)))","user":"58f44c07e4b0438e51c2ceb7"},{"code":"(fn [f & ms]\n  (let [ks (apply sorted-set (apply concat (map keys ms)))\n        vs (map (fn [k]\n                  (#(if (== 1 (count %)) (first %) (apply f %))\n                      (filter #(not (nil? %)) (map (fn [m] (m k)) ms))))\n                ks)]\n    (zipmap ks vs)))","problem":69,"user":"4ffe1df9e4b0678c553fc3ed"},{"code":"(fn [f & m]\n  (reduce\n    #(into % (for [[k v] %2]\n                [k (if-let [w (% k)] (f w v) v)]))\n   m))","problem":69,"user":"526a7025e4b03e8d9a4a722a"},{"problem":69,"code":"(fn [f & ms] (into {} (map (fn [[k vs]] [k (reduce f (map second vs))]) (group-by first (apply concat ms)))))","user":"54c641f8e4b045293a27f628"},{"problem":69,"code":"(fn mw\n  ([f m1 m2]\n   (merge m1 (apply hash-map (mapcat #(if (contains? m1 (key %)) [(key %) (f (get m1 (key %)) (val %))] %) m2))))\n  ([f m1 m2 & ms] (reduce #(mw f %1 %2) (mw f m1 m2) ms)))","user":"5b008bcae4b0cc2b61a3bd3d"},{"code":"(fn mm [f m1 & more]\n  (if (empty? more)\n    m1\n    (apply mm\n      f\n      (reduce\n        (fn [m [p1 p2]]\n          (merge\n            m\n            (vector\n              p1\n              (if (contains? m p1)\n                (f (m p1) p2)\n                p2))))\n        m1\n        (first more))\n      (rest more))))","problem":69,"user":"511f88eee4b085952a83535f"},{"problem":69,"code":"(fn my-merged-with\n  [f & ms]\n  (reduce\n   (fn merge-in-map\n     [aggregate current]\n     (reduce\n      (fn [aggregate2 k]\n        (if (nil? (get aggregate2 k))\n          (assoc aggregate2 k (get current k))\n          (assoc aggregate2 k (f (get aggregate2 k) (get current k)))))\n      aggregate\n      (keys current)))\n   (first ms)\n   (rest ms)))","user":"53b952eee4b047364c0444e6"},{"problem":69,"code":"(fn [f & maps]\n  (letfn [(g [acc m]\n            (reduce (fn [r [k v]] (update-in r [k] #(if % (f % v) v)))\n                    acc\n                    m))]\n    (reduce g {} maps)))","user":"546ed28be4b00cfc9eacc1a5"},{"problem":69,"code":"(fn [f & m ]\n    (reduce (fn[col el] \n               (assoc col el\n                 (reduce f (filter #(not (nil? %)) (map #(get % el) m)))\n               )\n             ) \n             {} (keys (apply merge m))\n    )\n  \n)","user":"55eeb37ae4b0121d4835fdf3"},{"problem":69,"code":"(fn merge-with- [f coll1 & coll2]\n    (reduce (fn [acc submap2]            \n        (reduce #(if (get %1 %2) \n                (update-in %1 [%2] f  (get submap2 %2))\n                       (assoc %1 %2 (get submap2 %2)))\n                           acc (keys submap2) )  ) \n                               coll1 coll2))","user":"5fec4f5ee4b05ac5b16ea1bf"},{"problem":69,"code":"(fn __\n  [func first-map & other-maps]\n  (letfn [(join [m [k v]]\n\t          (if (contains? m k)\n\t            (assoc m k (func (m k) v))\n\t            (assoc m k v)))\n          (reduce-maps [m other-m]\n            (reduce join m other-m))]\n          \n  (reduce \n    reduce-maps\n    first-map\n    other-maps)))","user":"55a62092e4b0acc240e31554"},{"problem":69,"code":"(fn [f origin & more]\n  (loop [origin origin\n         coll more]\n    (if (empty? coll)\n      origin\n      (recur (loop [the-map origin\n                    additions (first coll)]\n               (if (empty? additions)\n                 the-map\n                 (let [the-key (first (keys additions))\n                       old-value (the-map the-key)\n                       new-value (additions the-key)]\n                   (recur (->> (if old-value\n                                 (f old-value new-value)\n                                 new-value)\n                               (assoc the-map the-key))\n                          (dissoc additions the-key)))))\n             (rest coll)))))","user":"54db3d82e4b024c67c0cf75f"},{"code":"(fn [f & ms]\n  (let [grouped (group-by first \n  \t\t\t\t\t(apply concat \n               \t\t\t(map (fn [m] (for [k (keys m)] (vector k (m k)))) ms)))]\n    \t(into {} (map (fn [m] (vector m (reduce f (map last (grouped m))))) (keys grouped)))))","problem":69,"user":"534f13b2e4b084c2834f4ac4"},{"code":"(fn [f m & maps]\r\n  (loop [m m mlist maps]\r\n    (if (empty? mlist) m\r\n      (recur (reduce \r\n               (fn [v e] \r\n                 (let [k (key e)] (if (v k) (assoc v k (f (v k) (val e))) (assoc v k (val e)))))\r\n               m \r\n               (first mlist)) \r\n             (rest mlist)))))","problem":69,"user":"4f29cdc8e4b0d6649770a033"},{"problem":69,"code":"(fn [f & x] (reduce \n  (fn [m v]\n  (let [k (first v) w (last v)]\n    (if (m k)\n      (assoc m k (f (m k) w))\n      (assoc m k w))\n    )) {} (apply concat x)))","user":"580d7de3e4b0849f6811b73d"},{"problem":69,"code":"(fn merge-with-func\n  [func firstmap & restmaps]\n  (if (empty? restmaps)\n    firstmap\n    (apply (partial  merge-with-func func ((fn combine\n  [f map1 map2]\n  (into {} (for [k (into #{} (concat (keys map1) (keys map2)))]\n             [k (if-let [v1 (get map1 k)]\n                  (if-let [v2 (get map2 k)]\n                    (f v1 v2)\n                    v1)\n                  (get map2 k))]))) func firstmap (first restmaps))) (rest restmaps))))","user":"56449e4de4b0284900eef5f9"},{"problem":69,"code":"(fn my-merge-with[f & colls]\n  (reduce (fn [acc [k v]]\n            (update-in acc [k] #(if % (f % v) v)))\n          {}\n          (apply concat colls)))","user":"59cc4d5ee4b0a024fb6ae5d0"},{"problem":69,"code":"(fn [f m1 & mps] (letfn [(merg2 [g t1 t2] \n       (if (first t2)\n         (let [x1 (first t2) k (key x1) v (val x1)]\n            (if (t1 k) \n                (recur g (assoc t1 k (g (t1 k) v))  (rest t2) )\n                (recur g (assoc t1 k v ) (rest t2) )\n            )\n         )\n         t1\n       )\n       )]\n       \n      (if (first mps)\n            (recur f (merg2 f m1 (first mps)) (rest mps)  )\n             m1 \n      ) \n               )\n      )","user":"59ff9424e4b01bb0ae8afd24"},{"code":"(fn [f m & r]\n  (reduce (fn [x [k v]]\n      (if (x k) (conj x [k (f (x k) v)])\n            (conj x [k v])))\n    m\n    (for [x r [k v] x] [k v])))","problem":69,"user":"50acbd15e4b071b89ef26234"},{"problem":69,"code":"(fn merge* [f init & maps]\n  (reduce (fn [acc m]\n            (reduce (fn [acc2 [k v]]\n                      (if-let [init-v (acc2 k)]\n                        (assoc acc2 k (f init-v v))\n                        (assoc acc2 k v)))\n                    acc\n                    m))\n          init\n          maps))","user":"5617a540e4b06b1bb2182a12"},{"problem":69,"code":"(fn my-merge [fun coll & etc]\n  (let [colls (reduce into [] etc)]\n    (reduce #(let [fst (first %2)]\n               (assoc % fst\n                      (if (contains? % fst)\n                          (fun (get % fst) (second %2))\n                        (second %2)))) coll colls)))","user":"56bf4ac0e4b0f26550335985"},{"problem":69,"code":"(fn merge-with-a-function [f & xs] \n  (let [ys (group-by first (mapcat seq xs))]\n    (->> (vals ys)\n         (map #(map second %))\n         (map #(reduce f %))\n         (zipmap (keys ys)))))","user":"52616198e4b03e8d9a4a705e"},{"problem":69,"code":"(fn [f & maps]\n    (reduce (fn [map1 m]\n                (reduce (fn [m [k v]]\n                           (if-let [left-val (m k)]\n                \t\t\t(assoc m k (f left-val v))\n                \t\t\t(assoc m k v)))\n                         map1\n                         m))\n            {}\n            maps))","user":"5d1be50ce4b02ea6f0fb6986"},{"problem":69,"code":"(fn [f & m]\r\n  (reduce\r\n    (fn [m [k v]] (conj m [k (if (m k) (f (m k) v) v)]))\r\n    {}\r\n    (apply concat (map seq m))))","user":"58f45ea0e4b0438e51c2cebc"},{"problem":69,"code":"(fn [f & maps]\n  (reduce (fn [acc [k v]]\n            (if (contains? acc k)\n              (update-in acc [k] f v)\n              (assoc acc k v)))\n          {}\n          (apply concat maps)))\n;;Inspired by Joew","user":"52ca7711e4b071a8d36bd3e3"},{"code":"(fn mymerge                                              \n  ([f m1 m2]                                               \n     (let [ks (into #{} (concat (keys m1) (keys m2)))]     \n       (reduce #(assoc %1 %2                               \n                       (if (and (m1 %2) (m2 %2))           \n                         (f (m1 %2) (m2 %2))               \n                         (or (m1 %2) (m2 %2))              \n                         ))                                \n               {}                                          \n               ks)                                         \n       ))                                                  \n  ([f m1 m2 & more]                                        \n     (apply mymerge f (mymerge f m1 m2) more)              \n     )                                                     \n  )","problem":69,"user":"50573ed8e4b0012181721987"},{"code":"(fn [f & maps]\n  (let [merge-entry (fn [m e]\n                      (let [k (key e) v (val e)]\n                        (if (contains? m k)\n                          (assoc m k (f (get m k) v))\n                          (assoc m k v))))\n        my-merge (fn [m1 m2]\n                   (reduce merge-entry m1 (seq m2)))]\n    (reduce my-merge maps)))","problem":69,"user":"50ec4ed7e4b04edc33777046"},{"problem":69,"code":"(fn [f & maps]\n\t(let [x (fn [m e]\n\t\t(let [[k v] e]\n\t\t\t(if (contains? m k)\n\t\t\t\t(assoc m k (f (m k) v))\n\t\t\t\t(assoc m k v))))]\n\t(reduce #(reduce x (or % {}) %2) maps)))","user":"4fea09b2e4b0547ebccb2485"},{"problem":69,"code":"#(reduce (fn [m1 m2]\n           (reduce-kv (fn [m k v] \n                        (if (m k)\n                          (assoc m k (% (get m k) v)) \n                          (assoc m k v))) m1 m2)) %&)","user":"5cee521ce4b0aaa82f1129dd"},{"code":"(fn go [f & maps]\n  (reduce\n    (fn [m [k v]]\n      (assoc m k\n        (if (contains? m k)\n          (f (get m k) v) v)))\n    {}\n    (apply concat (into [] maps))))","problem":69,"user":"4dafa380edd6309eace4d17c"},{"code":"(fn my-merge-with \n  [f & maps]\n  (reduce\n    (fn [a b]\n      (reduce\n        (fn [x [k v]]\n          (assoc x k (if (b k) (f v (b k)) v)))\n        b a))\n    (first maps) (rest maps)))","problem":69,"user":"4f890488e4b033992c121c76"},{"problem":69,"code":"(fn my-merge-with [f & maps]\n  (reduce (fn [acc e]\n            (let [inter-keys (keys (select-keys acc (keys e)))\n                  updated-inter-values (map #(f (acc %) (e %)) inter-keys)\n                  updated-map (apply assoc e (interleave inter-keys updated-inter-values))]\n              (merge acc updated-map)))\n          maps))","user":"58a953dae4b01a0c0b232968"},{"code":"(fn [f ma & ms] (\n  let [mb (apply merge ms)] (\n    merge mb (into {} (for [[k a] ma] [k (f a (get mb k)) ]))\n  )\n))","problem":69,"user":"4e7f4147535db966e863cc3d"},{"problem":69,"code":"(fn [f & args]\n  (loop [result {}\n         input args]\n   (if-not (empty? input)\n     (recur \n      (apply (partial assoc result)\n             (apply concat\n              (for [[k v] (first input)] \n                [k (if-let [x (get result k)] (f x v) v)])))\n      (rest input))\n     result)))","user":"56f881e0e4b08e7d20b96839"},{"code":"(fn [f & ms]\n   (let [merge-entry (fn [m e]\n                       (let [k (key e)\n                             v (val e)]\n                         (if (contains? m k)\n                           (assoc m k (f (get m k) v))\n                           (assoc m k v))))\n         merge2 (fn [m1 m2]\n                  (reduce merge-entry (or m1 {}) (seq m2)))]\n     (reduce merge2 ms)))","problem":69,"user":"4db1fe241254ad5b4805fa77"},{"problem":69,"code":"(fn [f map1 & maprest]\n  (letfn [(helper [agg [k v]]\n            (assoc agg k (if (contains? agg k) (f (agg k) v) v)))]\n    (reduce (fn [agg m] (reduce helper agg m)) map1 maprest)))","user":"5e9c11f8e4b0157ca96647f6"},{"code":"(fn [f m & ms]\n  (reduce (fn [res m]\n            (reduce (fn [res e]\n                      (if (res (key e))\n                        (update-in res [(key e)] f (val e))\n                        (conj res e)))\n                    res\n                    m))\n          m\n          ms))","problem":69,"user":"5028cd0fe4b01614d1633ffc"},{"code":"(fn __ [f & maps]\n  (let [red (fn [m [k v]] \n              (assoc m k (if-let [ev (m k)] (f ev v) v)))]\n        (reduce red {} (mapcat seq maps))))","problem":69,"user":"4ec9549d535d6d7199dd36fe"},{"problem":69,"code":";-------------------------------\n(fn [f & ms]\n  (reduce (fn [m1 m2]\n            (reduce (fn [m [k v]]\n                      (if (contains? m k)\n                        (update-in m [k] f v)\n                        (assoc m k v)))\n                    m1 m2))\n          ms))\n\n;------------------------------\n;(fn [f m & ms]\n;   (reduce \n;     (fn [ret x]\n;       (reduce \n;         (fn [r k] \n;           (conj r (if (r k) [k (f (r k) (x k))] (find x k)))) \n;         ret (keys x))) \n;     (cons m ms)))","user":"5633bb9de4b0bfe05bf117b4"},{"code":"(fn [f & ms]\n  (let [merge (fn [m1 m2]\n                (reduce #(if (contains? %1 (first %2))\n                          (assoc %1 (first %2) (f (m1 (first %2)) (second %2)))\n                          (assoc %1 (first %2) (second %2)))\n                        m1 m2))]\n    (reduce merge ms)))","problem":69,"user":"504e13fce4b078edc5f593bc"},{"problem":69,"code":"(fn merge-with-\n  [f & maps]\n  (letfn [(merge- [m1 m2]\n            (reduce (fn [acc [k v]]\n                      (if (contains? acc k)\n                        (update-in acc [k] f v)\n                        (assoc acc k v)))\n                    m1 m2))]\n    (reduce #(merge- %1 %2) maps)))","user":"5cf1d9e3e4b0aaa82f112a18"},{"problem":69,"code":"(fn [f m & maps]\n  (reduce (fn [res cmap]\n      (reduce (fn [res [k v]]\n                (conj res\n                  (if (contains? res k)\n                    [k (f (get res k) v)]\n                    [k v]\n                  )))\n\n\n              res\n              cmap\n              )\n   )\n   m\n   maps\n   ))","user":"5795bddbe4b0e215f87e8488"},{"code":"(fn my-merge-with\n  ([f m & maps]\n     (reduce \n      (fn [m mergeme]\n        (loop [m m mergeme mergeme]\n          (if (empty? mergeme)\n            m\n            (let [[key val] (first mergeme)]\n              (if (m key)\n                ;; if we have this key, apply f\n                (recur (assoc m key (f (m key) val)) (rest mergeme))\n                ;; if we don't simply assoc\n                (recur (assoc m key val) (rest mergeme)))))))\n      m maps)))","problem":69,"user":"4fd16778e4b04c3a95aa040f"},{"problem":69,"code":"(fn [f & maps]\n  (loop [[firstmap & restmaps :as in] maps out {}]\n    (cond (empty? in) out\n          :else (let [out (loop [[[k v] & restkeys :as in] (seq firstmap) out out]\n                            (cond (empty? in) out\n                                  :else (cond (contains? out k) (recur restkeys (conj out {k (f (get out k) v)}))\n                                      \t\t  :else (recur restkeys (conj out {k v})))))]\n                  (recur restmaps out)))))","user":"5472cba1e4b094393f72dd7a"},{"code":"(fn [f m & ms]\n    (reduce\n     (fn [ml mr]\n       (loop [allkeys (set (concat (keys ml) (keys mr)))\n              builder {}]\n         (if (empty? allkeys)\n           builder\n           (let [firstkey (first allkeys)]\n             (if (and (contains? ml firstkey)\n                      (contains? mr firstkey))\n               (recur (rest allkeys) (assoc builder firstkey (f (get ml firstkey)\n                                                                (get mr firstkey))))\n               (recur (rest allkeys) (assoc builder firstkey (val (or (find ml firstkey)\n                                                                      (find mr firstkey))))))))))\n\n     m ms))","problem":69,"user":"50057f23e4b0678c553fc466"},{"problem":69,"code":"(fn [fun & sets] \n  (reduce (fn [acc c]\n           (apply conj (cons acc \n                             (map (fn [[k v]]\n                                    (if (contains? acc k)\n                                      [k (fun (acc k) v)]\n                                      [k v]))\n                                  c))))\n          sets))","user":"53acaf1fe4b047364c04445f"},{"code":"(fn[f & ms]\n  (let [merge-entry (fn [m e]\n                      (let [k (key e) v (val e)]\n                        (if (contains? m k)\n                          (assoc m k (f (get m k) v))\n                          (assoc m k v))))\n        merge-map (fn [m1 m2] \n                    (reduce merge-entry m1 m2))]\n  (reduce merge-map ms)))","problem":69,"user":"4fe8fda4e4b0547ebccb2438"},{"problem":69,"code":"(fn [f & s]\n  (into {} (for [[k v] (group-by first (apply concat (map vec s)))]\n          \t  [k (reduce f (map second v))])))","user":"53ce4cd4e4b00fb29b2212ef"},{"problem":69,"code":"(fn [f & coll](\n   reduce (fn [r m] \n            (reduce #(assoc %1 (key %2) (if (%1 (key %2)) (f (%1 (key %2)) (val %2)) (val %2)) )\n                    r m))\n            (first coll) \n            (rest coll)\n                 ))","user":"546280d8e4b01be26fd746b0"},{"problem":69,"code":"(fn [func & maps]\n  (reduce\n   (fn [map1 map2]\n     (reduce \n      (fn [m [k v]]\n        (if (contains? m k)\n          (update-in m [k] func v)\n          (assoc m k v)))\n      map1 map2)\n     )\n   maps)\n  )","user":"5776558ee4b0979f89651633"},{"problem":69,"code":"(fn [fun & args]\n  (loop [result []\n         [[head tail] :as all] (reduce #(apply (partial conj %) %2) [] args)\n         ]\n    (if (empty? all)\n      (let [initial-list result _ (println initial-list)]\n        (loop [final-result {} [[k v] & rest] initial-list _ (println \"v:\" v)]\n          (if (nil? k)\n            final-result\n            (recur (merge final-result {k (if (> (count v) 1)\n                                            (apply fun v)\n                                            (first v))}) rest \"nothing\"))))\n      (do (println all)\n          (recur (conj result [head (reduce \n                                     #(conj % (last %2))\n                                     []\n                                     (filter #(= head (first %)) all))]) \n                 (filter #(not= head (first %)) all)))\n)))","user":"55a0d79fe4b0acc240e31502"},{"code":"; 不恰好だなあ\n(fn my-merge-with [f & maps]\n  (->> maps\n       (mapcat #(apply vector %))\n       (group-by #(identity (% 0)))\n       (reduce-kv\n        (fn [ret k v]\n          (let [g (if (= (count v) 1) identity f)]\n            (assoc ret k\n                   (apply g (map #(% 1) v))))) {})))","problem":69,"user":"511b9017e4b00c2a1fa7ff6b"},{"code":"(fn [f & xs]\n  (reduce\n   (fn [m [k v]] (assoc m k (if (contains? m k) (f (m k) v) v)))\n   (sorted-map)\n   (apply concat (map #(seq %) xs))))","problem":69,"user":"4f2e0369e4b0d6649770a064"},{"problem":69,"code":"(fn mw [f & cs]\n  (reduce (fn [a [k v]]\n            (if-let [v2 (get a k)]\n              (assoc a k (f v2 v))\n              (assoc a k v)))\n          {}\n          (mapcat identity cs)))","user":"56a76f36e4b07966d5a8a05b"},{"problem":69,"code":"(fn mrg\n  ([func m] m)\n  ([func m n]\n    (into m (map #(if (m %) {% (func (m %) (n %))} {% (n %)} ) (keys n)))\n  )\n  ([func m n & more]\n    (apply mrg func (mrg func m n) more)\n  )\n)","user":"56979bb7e4b0e0b3d3318cac"},{"problem":69,"code":"(fn __ [f & args]\n  (let [keys (keys (apply merge args))]\n    (zipmap keys (map (fn [coll] (if (> (count coll) 1) (apply f coll) (apply identity coll))) \n         (map (fn [coll] (filter (complement nil?) coll))\n              (for [k keys]\n                (map #(% k) args))))\n    )))","user":"526759b3e4b03e8d9a4a715b"},{"problem":69,"code":"(fn [f & maps]\n\t(let [process-map \n\t\t(fn [rslt m]\n\t\t\t(reduce-kv (fn [r k v]\n\t\t\t\t(if (contains? r k)\n\t\t\t\t\t(assoc r k (f (get r k) v))\n\t\t\t\t\t(assoc r k v))) rslt m)\n\t\t\t)]\n\t\t(reduce process-map {} maps)\n\t))","user":"52570aeae4b0541d1855ba42"},{"problem":69,"code":"(fn merge-wit [f & args]\n  (reduce\n    (fn [final [k v]]\n      (if (final k)\n        (assoc final k (f (final k) v)) ;; ugh, why no update function\n        (assoc final k v)))\n    {}\n    (mapcat (partial into []) args)))","user":"5d24e49be4b02ea6f0fb6a2a"},{"problem":69,"code":"(fn [op main & others]\n  (let [merge2\n        (fn [a b]\n          (reduce\n           (fn [merged [k v]]\n             (assoc merged k (if (contains? merged k)\n                                (op (get merged k) v)\n                                v)))\n           a b))]\n  (reduce merge2 main others)))","user":"547d8e93e4b0c51c1f4d72f4"},{"problem":69,"code":"(fn foo [f m & ms]\r\n  (if (empty? ms) m\r\n    (let \r\n      [[m' & ms'] ms\r\n       m'' (into {} \r\n             (for [k (filter m (keys m'))] \r\n                [k (f (m k) (m' k))])) ]\r\n      (apply (partial foo f (merge m m' m'')) ms'))))","user":"606e0a42e4b069485764de19"},{"problem":69,"code":"(fn [f & maps]\n  (reduce #(merge %2\n                   (apply conj {}\n                          (for [[k v] %1]\n                            (if-let [u (%2 k)]\n                              [k (f v u)]\n                              [k v]))))\n          maps))","user":"5712854ce4b07c98581c3a89"},{"problem":69,"code":"(fn [f m & r]\n  (reduce #(reduce (fn [a [k v]]\n                     (let [new-val (if (get a k)\n                                     (f (get a k) v)\n                                     v)]\n                       (assoc a k new-val)))\n                   %\n                   %2)\n          m\n          r))","user":"4dd6d7ee535d2dad7130b5cb"},{"code":"(fn map-with* [f & maps]\n  (let [to-list (fn [k] (if (coll? k) k (list k)))\n        f* (fn [init els]\n             (loop [init init el (first els) rels (rest els)]\n               (let [k (first el) v (second el)]\n                 (let [init* (assoc init k (conj (to-list (get init k [])) v))]\n                   (do\n                     ;(println init* el rels)\n                     (if (empty? rels)\n                       init*\n                       (recur init* (first rels) (rest rels))))))))\n        map-map* (fn [el]\n                   (let [k (first el) v (second el)]\n                     (do\n                       (assoc {} k (if (= 1 (count v)) (first v) (apply f v))))))]\n    (apply merge (map map-map* (reduce f* {} maps)))))","problem":69,"user":"51d662fce4b0154f82ab92ef"},{"problem":69,"code":"(fn [f & ms]\n  (letfn [(mme [m e]\n               (let [k (key e)\n                     v (val e)]\n                 (if-let [mv (m k)]\n                   (assoc m k (f mv v))\n                   (assoc m k v))))\n          (mm [m1 m2]\n              (reduce mme m1 (seq m2)))]\n    (reduce mm ms)))","user":"54dd76c8e4b024c67c0cf794"},{"code":"(fn [f & maps]\n   (reduce (fn [a b] (into a (map (fn [[k v]] (if (a k)\n                                            {k (f (a k) (b k))}\n                                            {k v}))\n                                 b))) maps))","problem":69,"user":"4ea1b9e4535d7eef308072b8"},{"problem":69,"code":"(fn [f & ms]\n  (reduce\n    (fn [ret m]\n      (reduce-kv\n        (fn [m k v]\n          (assoc m k (if (contains? m k)\n                       (f (m k) v)\n                       v)))\n        ret\n        m))\n    {}\n    ms))","user":"5aea2d21e4b0cc2b61a3bbe2"},{"problem":69,"code":"(fn [f & maps]\n  (reduce (fn [acc m]\n            (reduce-kv\n             (fn [m k v]\n               (assoc m\n                 k (if-let [e (get acc k)]\n                     (f e v)\n                     v)))\n             acc m))\n          (first maps)\n          (rest maps)))","user":"505aa653e4b021387fb89857"},{"code":"(fn merge-with-fn [f m & ms]\n  (letfn [(merge-element [m e]\n            (let [k (key e)\n                  v (val e)]\n              (if (contains? m k)\n                (assoc (dissoc m k) k (f (get m k) v))\n                (assoc m k v))))]\n    (loop [m m\n           ms ms]\n      (if (empty? ms)\n        m\n        (recur (reduce merge-element m (first ms)) (rest ms))))))","problem":69,"user":"4e82c062535db62dc21a62cc"},{"code":"(fn [f m & n]\n  (letfn [(g  [m [k v]] (assoc m k (if (contains? m k) (f (m k) v) v) ))]\n    (reduce #(reduce g % %2) m n)\n  \n  ))","problem":69,"user":"503917a0e4b088a6a14ca763"},{"problem":69,"code":"(fn [m & args]\n  (loop [a (first args)\n         b (reduce conj (rest args))]\n    (if (empty? b)\n      a\n      (let [fk (first (keys b))\n            v (get b fk)\n            r (assoc a fk (if (contains? a fk)\n                            (m (get a fk) v)\n                            v))]\n        (recur r (dissoc b fk))))))","user":"53d5a63be4b0e771c3025449"},{"code":"(fn m-with [f m & more]\n  (letfn [(add-keys [f acc [k v]]\n  (if (contains? acc k)\n    (assoc acc k (f (acc k) v))\n    (assoc acc k v)))]\n  (if-not (seq more)\n    m\n    (recur f (reduce (partial add-keys f) m (first more))\n           (rest more)))))","problem":69,"user":"4feff3b6e4b0678c553fc31e"},{"problem":69,"code":"(fn Merge [f m & rst]\n  (reduce (fn [mm s]\n            (reduce-kv (fn [mm k v]\n                         (if (contains? mm k)\n                          (assoc mm k (f (get mm k) v))\n                          (assoc mm k v))\n                         )\n                       mm s)\n            )\n          m\n          rst))","user":"579c8ad1e4b05b1deef9ae0c"},{"problem":69,"code":"(fn [f & ms]\n  (reduce (fn [acc m]\n            (reduce-kv (fn [new-m k v]\n                         (update-in new-m [k] #(if (nil? %) v (f % v))))\n                       acc\n                       m))\n          ms))","user":"57e0f30ae4b0bfb2137f5a66"},{"code":"(fn [f & more]\n  (let [f2 (fn [m [k v]]\n             (assoc m k (if (m k) (f (m k) v) v)))]\n    (reduce f2 {}\n  (mapcat seq more))))","problem":69,"user":"51d5ce6fe4b01da06753aa94"},{"problem":69,"code":"(fn myMergeWith [f m & ms] (reduce (fn [x y] (reduce #(if (nil? (%1 (key %2))) \n                                                          (merge %1 %2) \n                                                          (update-in %1 [(key %2)] f (val %2))) \n                                                     x \n                                                     y)) \n                                   m \n                                   ms))","user":"542c1f73e4b0dad94371f29d"},{"problem":69,"code":"(fn my-merge-with [f & ms]\n  (reduce\n   (fn [result m]\n     (reduce-kv\n      (fn [result-m m-k m-v]\n        (if-let [[_result-k result-v] (find result-m m-k)]\n          (assoc result-m m-k (f result-v m-v))\n          (assoc result-m m-k m-v)))\n      result\n      m))\n   {}\n   ms))","user":"551bdefde4b07993ea3788d7"},{"problem":69,"code":"(fn [f & ms]\n  (reduce\n    (fn [r m]\n      (apply assoc r\n             (interleave\n               (keys m)\n               (map (fn [k x] (if (contains? r k) (f (r k) x) x)) (keys m) (vals m)))))\n    {} ms))","user":"53e4fa2ce4b036ad0777e454"},{"problem":69,"code":"(fn [f firstMap & args]\n      (reduce\n              (fn [init argMap]\n                (reduce\n                        (fn [m [k v]]\n                          (if-let [old (m k)]\n                            (assoc m k (f old v))\n                            (assoc m k v)))\n                  init argMap))\n        firstMap args))","user":"57f8ba80e4b0d3187e90092f"},{"code":"(fn [op map & more-maps]\n  (if (empty? more-maps)\n    map\n    (recur op ((fn [result-map next-map]\n                 (if (empty? next-map)\n                   result-map\n                   (let [[k v] (first next-map)\n                         found (get result-map k)]\n                     (if found\n                       (recur (assoc result-map k (op found v)) (rest next-map))\n                       (recur (assoc result-map k v) (rest next-map))))))\n               map (first more-maps))\n           (rest more-maps))))","problem":69,"user":"51105c7fe4b04c71fce993ef"},{"code":"(fn [f & ms]\n      (reduce (fn [m n]\n                (reduce (fn [m [k v]]\n                          (if (m k)\n                            (update-in m [k] f v)\n                            (assoc m k v)))\n                        m n))\n                {} ms))","problem":69,"user":"50f48298e4b004d364930527"},{"code":"(fn [f & x] (reduce (fn [jm m]\n                    (reduce (fn [jm [k v]]\n                      (if (jm k) (update-in jm [k] f v)\n                       (assoc jm k v))) jm m)) {} x)\n)","problem":69,"user":"4e50e2a0535dc968683fc4ef"},{"problem":69,"code":"(fn [f & maps]\n  (reduce (fn [m1 m2]\n            (reduce #(let [_acc %1\n                           _key (first %2)\n                           _val (last %2)]\n                       (conj _acc [_key (if (contains? _acc _key)\n                                        (f (_acc _key) _val)\n                                        _val)])) m1 m2)) maps))","user":"5360f043e4b0243289761e3c"},{"problem":69,"code":"(fn merge-with'\n  [f m & maps]\n  (if (empty? maps)\n    m\n    (apply merge-with' f (merge m (into {} (map \n      (fn [[k v]]\n        (if (get m k)\n          [k (f (get m k) v)]\n          [k v]))\n      (first maps)))) (rest maps))))","user":"540b2dcbe4b0addc1aec66f4"},{"problem":69,"code":"(fn [f & ms]\n  (let [com (fn [acc [k v]]\n              (if-let [av (get acc k)]\n                (assoc acc k (f av v))\n                (assoc acc k v)))]\n    (reduce (fn [acc m] (reduce com acc m)) ms)))","user":"594bc16be4b07ddc2dafae39"},{"problem":69,"code":"(fn multi-merger [f & all]\n  (reduce (fn [s1 s2] \n  ((fn merger [f s1 s2]\n  (loop [s s1 r s2]\n    (if (empty? r)\n      s\n      (let [fir (first r)\n            k (key fir)\n            v2 (val fir)\n            v1 (get s k)\n            ]\n        ;(println \"fir=\" fir \"key=\" k \"v1=\" v1 \"v2=\" v2 \"s=\" s \"r=\" r)\n        (recur \n          (if (nil? v1)\n            (assoc s k v2)\n            (assoc s k (f v1 v2))\n            )\n          (rest r))\n        )\n      ))) f s1 s2)) {} all)\n  )","user":"5c9b848fe4b048ec896c5acf"},{"problem":69,"code":"(fn  [f & args]\n  (let [argkeys (keys (apply merge args))]\n    (into {} (for [k argkeys] \n               [k (reduce f (filter identity (map #(get % k) args)))]))))","user":"56102f50e4b05f002753df6b"},{"problem":69,"code":"#(let [f %]\n   (loop[m %& res %2]\n     (if (empty? m)\n       res\n       (recur (rest m) (apply merge res (for [y (first m)] (if (some (fn[a](= (first a) (first y))) res)\n                                                          {(first y) (f (get res (first y)) (second y))}\n                                                          (apply hash-map y))))))))","user":"5964c614e4b069c0a1a19770"},{"code":"(fn fm [f & maps]\n  (letfn [(c [f m1 m2]\n            (reduce #(if (contains? %1 (%2 0))\n                       (conj %1 [(%2 0) (f (get %1 (%2 0)) (%2 1))])\n                       (conj %1 [(%2 0) (%2 1)])) m1 m2))]\n    (reduce (partial c f) (first maps) (rest maps))))","problem":69,"user":"4ea1ecfa535d7eef308072bb"},{"problem":69,"code":"(fn my-merge-with [f & maps]\n  (let [all-keys (->> maps (map keys) flatten set)\n        vals-for-keys (for [a-key all-keys\n                            :let [the-vals (filter #(not= nil %) (map #(get % a-key) maps))\n                                  the-val (if (< 1 (count the-vals))\n                                            (apply f the-vals)\n                                            (first the-vals))]]\n                        [a-key the-val])]\n    (apply conj {} vals-for-keys)))","user":"52ee46e5e4b05e3f0be25ec5"},{"problem":69,"code":"(fn mg\n  ([f a b]\n   (reduce (fn [c [k v]]\n             (if (c k) \n               (assoc c k (f (c k) v)) \n               (assoc c k v))) a b))\n  ([f a b & more]\n   (apply (partial mg f (mg f a b)) more)))","user":"5799ff45e4b05b1deef9add1"},{"problem":69,"code":"(fn fn-merge [op & maps]\n    (reduce (fn make-map [res nxt]\n        (merge res \n            (reduce (fn with-keys [res-map k]\n                (assoc res-map k (if (contains? res k) \n                    (op (get res k) (get nxt k))\n                    (get nxt k)))) {} (keys nxt)))) {} maps))","user":"54f09599e4b024c67c0cf89d"},{"code":"(fn mw\n  ([f m m1]\n   (if (empty? m1)\n     m\n     (let [k (first (keys m1))\n           ov (get m k)\n           nv (get m1 k)]\n       (if (nil? ov)\n         (mw f (assoc m k nv) (dissoc m1 k))\n         (mw f (assoc m k (f ov nv)) (dissoc m1 k))))))\n  ([f m m1 & ms]\n     (reduce (partial mw f) (mw f m m1) ms)))","problem":69,"user":"5123ac8ee4b061b4c6f0e0b1"},{"code":"(fn this [f & params]\n  (cond (= (count params) 1) (first params)\n        :else\n        (let [\n              m1 (first params)\n              m2 (nth params 1)\n              rest-params (nnext params)\n              keys1 (keys m1)\n              keys2 (keys m2)\n              m3 (reduce (fn [a b]\n                           (if (.contains keys1 (first b))\n                             (merge a {(first b) (f (get m1 (first b))\n                                                    (second b))\n                                    }) ; merge\n                             (merge a {(first b) (second b)})) ; if\n                           ) ; fn\n                         {} m2) ; reduce\n              m4 (merge m1 m3)\n              new-params (conj rest-params m4)\n              ]\n          (println :m3 m3)\n          (println :new-params new-params)\n          (apply this (concat (list f) new-params))\n          ) ; let\n        ) ; cond\n  ) ; fn","problem":69,"user":"5021f0b3e4b00bba4502f7ac"},{"problem":69,"code":"(fn [f & ms]\n  (reduce (fn [a b]\n            (if (empty? a)\n              b\n              (loop [a a\n                     b b]\n                (if (empty? b)\n                  a\n                  (let [[k v] (first b)\n                        r (a k)]\n                    (recur (assoc a k (if (nil? r) v (f r v))) (dissoc b k)))))))\n          {}\n          ms))","user":"58bb218be4b0888cdc949cf4"},{"code":"(fn [f & more]\n  (reduce #(reduce (fn [m e]\n                     (let [k (key e) v (val e)]\n                       (if (contains? m k)\n                         (update-in m [k] f v)\n                         (assoc m k v)))) %1 %2) more))","problem":69,"user":"4fbef9a6e4b081705acca316"},{"code":"(fn [f & args]\n   (into {}\n      (map (fn [e] [(e 0)\n         (let [s (map (fn [v] (v 1)) (e 1))]\n             (if (<= (count s) 1)\n                 (first s)\n                 (apply f s)))])\n             (group-by key (apply concat (map (fn [m] (into [] m)) args))))))","problem":69,"user":"50bce014e4b0594b91591c63"},{"problem":69,"code":"(fn merge-with-func\n  [func map1 & more-maps]\n  (reduce (fn [result a-map]\n            (loop [mykeys (keys a-map)\n                   result result]\n              (if (empty? mykeys)\n                result\n                (let [key (first mykeys)\n                      val (a-map key)]\n                  (recur (rest mykeys) \n                         (if (contains? result key)\n                           (assoc result key (func (result key) val))\n                           (assoc result key val)\n                         ))\n                  )\n                )\n              )\n            )\n          map1 more-maps)\n  )","user":"5e495e3fe4b043cd24807a4f"},{"problem":69,"code":"(fn my-merge-with [f & maps ]\n  (when (some identity maps )\n    (let [merge-entry (fn [m e]\n                        (let [k (key e) v (val e)]\n                          (if (contains? m k)\n                            (assoc m k (f (get m k) v))\n                            (assoc m k v))))\n          merge2 (fn [m1 m2]\n                   (reduce merge-entry (or m1 {}) (seq m2)))]\n      (reduce merge2 maps))))","user":"5832be57e4b089d5ab817c86"},{"code":"(fn my-merge-with [f & maps]\r\n  (letfn [(map-to-hash [fcn coll] (reduce #(assoc %1 %2 (fcn %2)) {} coll))]\r\n    (map-to-hash (fn [k] (reduce f (keep #(% k) maps)))\r\n                 (reduce #(into % (keys %2)) #{} maps))))","problem":69,"user":"4e994541535dbda64a6f6b64"},{"code":"(fn [f & args] (->> \n                args \n                (apply concat) \n                (group-by key) \n                (map (fn [e] \n                       (vector (key e) \n                               (->> e val (map second) \n                                    (#(reduce f (first %) (rest %))))))) \n                (into {})))","problem":69,"user":"5246e945e4b0644eb7b0783b"},{"code":"(fn my-merge-with [f m1 & maps]\n  (if (empty? maps)\n    m1\n    (let [m2 (first maps)\n          mg1 (merge m1 m2)\n          mg (reduce #(if-let [val2 (get m2 %2)]\n                        (assoc %1 %2 (f (get m1 %2) val2))\n                        %1)\n                     mg1 (keys m1))]\n      (recur f mg (next maps)))))","problem":69,"user":"4dd0e8f7535da60f04a96e57"},{"code":"(fn [f & maps]\n    (let [merge (fn [m f k v]\n                  (if (contains? m k)\n                    (assoc m k (f (get m k) v))\n                    (assoc m k v)))\n          merge-maps (fn [f m1 m2]\n                       (reduce (fn [m [k v]] (merge m f k v)) m1 m2))]\n      (reduce #(merge-maps f % %2) {} maps)))","problem":69,"user":"4f4274f2e4b0d7d3c9f3fd00"},{"problem":69,"code":"(fn [f m & r]\n  (loop [m m\n         r r]\n    (if (seq r)\n      (let [[m' & r'] r]\n        (recur\n         (reduce\n         (fn [m [k v]]\n           (if (contains? m k)\n             (update-in m [k] f v)\n             (assoc m k v)))\n         m m')\n         r'))\n      m)))","user":"54157dace4b01498b1a719f4"},{"problem":69,"code":"(fn [f & maps]\n  (reduce\n   (fn [a b]\n     (reduce\n      (fn [m [k v]]\n        (assoc m k (if-let [[_ v'] (find b k)] (f v v') v)))\n      b a))\n   (first maps) (rest maps)))","user":"5405ae2be4b0addc1aec6671"},{"problem":69,"code":"(fn merge-w [f & maps]\n  (reduce (fn [m1 m2]\n            (reduce #(let [k (first %2)\n                           v (second %2)] \n                       (if (contains? %1 k)\n                         (update-in %1 [k] f v)\n                         (assoc-in %1 [k] v))) \n                    m1 m2)) \n          maps))","user":"558bb38fe4b0277789237631"},{"problem":69,"code":"(fn [f & maps]\n  (letfn [(merge-maps [left-map right-map]\n            (reduce (fn [result [k v]]\n                      (assoc result k (if (contains? result k)\n                                        (f (get result k) v)\n                                        v)))\n                    left-map\n                    right-map))]\n    (reduce merge-maps maps)))","user":"54cc26c1e4b057c6fda3a28a"},{"code":"(fn merge-maps [f & maps]\n  (let [allkeys (set (apply clojure.set/union (map keys maps)))]\n    (apply conj {}\n      (for [k allkeys]\n         [k (reduce f\n               (remove nil?\n                  (for [m maps]\n                    (get m k))))]))))","problem":69,"user":"4fe87e56e4b07c9f6fd12c40"},{"code":"(fn mergew\n  [f & maps]\n  (when (some identity maps)\n    (let [mergee (fn [m e]\n  \t\t(let [k (key e) v (val e)]\n\t\t\t  (if (contains? m k)\n\t\t\t    (assoc m k (f (get m k) v))\n\t\t\t    (assoc m k v))))\n          merge (fn [m1 m2]\n\t\t   (reduce mergee (or m1 {}) (seq m2)))]\n      (reduce merge maps))))","problem":69,"user":"4eb0afed535d7eef3080733e"},{"problem":69,"code":"(fn [f & maps]\n (let [merge-entry (fn [m e]\n                     (let [k (key e) v (val e)]\n                       (if (contains? m k)\n                         (assoc m k (f (get m k) v))\n                         (assoc m k v))))\n       merge-map (fn [m1 m2]\n                   (reduce merge-entry m1 (seq m2)))]\n   (reduce merge-map {} maps)))","user":"5ebdb3d2e4b00a66d4a95275"},{"code":"(fn merg [f m & ms]\n  (if (empty? ms) m\n    (let [[m2 & mrst] ms\n      mg (fn [m [k v]] \n            (assoc m k (if (m k) (f (m k) v) v)))\n      ]\n      (apply merg f (reduce mg m m2) mrst))))","problem":69,"user":"50901b2ee4b0ea685a20f774"},{"problem":69,"code":"(fn mrg [f & maps]\n  (into {}\n    (map (fn [k] \n             [k (reduce (fn [& args] (reduce f (remove nil? args)))\n                     (map (fn [m] (m k)) maps))]) \n         ; Get all keys\n         (apply clojure.set/union (map #(set (keys %)) maps)))))","user":"551afdf8e4b07993ea3788cb"},{"code":"(fn m [f x & y] (reduce #(reduce (fn [h [k v]] (assoc h k (if (h k) (f (h k) v) v))) % %2) x y))","problem":69,"user":"4e80e0f2535db62dc21a62b8"},{"problem":69,"code":"(fn __ [f & ms]\n  (->> (for [m ms\n             k (keys m)]\n         [k (get m k)])\n       (group-by first)\n       (map (fn [entry]\n              [(first entry)\n               (reduce f\n                       (map second (second entry)))]))\n       (into {})))","user":"54c271b9e4b045293a27f602"},{"code":"(fn [f m & l]\n  (reduce\n    (fn [n s]\n      (reduce\n        #(if (contains? % (key %2))\n           (update-in % [(key %2)] f (val %2))\n           (apply assoc % %2))\n        n\n        s))\n    m\n    l))","problem":69,"user":"4e82f85d535db62dc21a62ce"},{"code":"(fn [func & maps]\n\t(reduce \n\t\t(fn [map1 map2]\n\t\t\t(into map1 \n\t\t\t \t(map (fn [[k v]] \n\t\t\t \t\t(if (contains? map1 k)\n\t\t\t \t\t\t[k (func (map1 k) (map2 k))]\n\t\t\t\t\t\t[k v]))\n\t\t \t\tmap2)\n\t\t))\n\t\tmaps))","problem":69,"user":"52bf6946e4b07a9af5792334"},{"code":"(fn [f & maps]\n  (reduce\n   (fn [m1 m2]\n     (reduce (fn [accum k]\n               (if (find accum k)\n                 (assoc accum k (f (get accum k) (get m2 k)))\n                 (assoc accum k (get m2 k))))\n             m1\n             (keys m2)))\n   {}\n   maps))","problem":69,"user":"53527551e4b084c2834f4af0"},{"problem":69,"code":"(fn [f m & ms]\n  (reduce\n   (fn [m n]\n     (reduce \n      (fn [res [k v]]\n        (assoc res k\n               (if-let [v' (res k)]\n                 (f v' v)\n                 v)))\n      m n))\n   m ms))","user":"4e6a4950535d8ccf87e9febf"},{"code":"(fn [f & s] \n  (reduce \n    #(reduce \n      (fn [m [k v]]\n        (assoc m k\n          (if (contains? m k)\n            (f (m k) v)\n            v)))\n      % %2)\n    s))","problem":69,"user":"4e707db6535d5021c1a8963a"},{"problem":69,"code":"(fn [f & ms]\n  (reduce #(reduce (fn [m [k v]]\n                     (if (contains? m k)\n                       (assoc m k (f (get m k) v))\n                       (assoc m k v))) % %2) ms))","user":"54ddb556e4b024c67c0cf798"},{"problem":69,"code":"(fn [f & ms]\n    (letfn [(myfunc [x m1 m2]\n              (cond\n                (nil? (m1 x)) (m2 x)\n                (nil? (m2 x)) (m1 x)\n                :else (f (m1 x) (m2 x))))\n            (merge-2-maps [m1 m2]\n              (into {} (map #(vector % (myfunc % m1 m2 ))  (clojure.set/union (set (keys m1)) (set (keys m2))))))]\n      (reduce #(merge-2-maps  %1 %2) {} ms)))","user":"5c9dcb36e4b048ec896c5b1d"},{"code":"(fn [f & maps] (let [merge-entry (fn [m e] (let [[k v] e] (if (contains? m k)\n                                                           (assoc m k (f (get m k) v))\n                                                           (assoc m k v))))\n                     merge2 (fn [m1 m2] (reduce merge-entry (or m1 {}) (seq m2)))\n                     merge-mult (fn [] (reduce merge2 maps))] (merge-mult )))","problem":69,"user":"50cae881e4b0f75dcc9a6e51"},{"code":"(fn [f & [fst & maps]]\n  (reduce \n   #(loop [m %, [[k v] & r] (seq %2)]\n      (cond\n       (nil? k) m\n       (contains? m k) (recur (assoc m k (f (m k) v)) r)\n       :else (recur (assoc m k v) r)))\n   fst maps))","problem":69,"user":"52039e12e4b0fb7e47ea51ff"},{"code":"(fn [f & maps]\n  (reduce (fn [merged map]\n    (reduce (fn [merged [key value]]\n      (if (contains? merged key)\n        (assoc merged key (f (get merged key) value))\n        (assoc merged key value))) merged map)) maps))","problem":69,"user":"4f542fd9e4b0a7574ea717db"},{"code":"(fn mmerg-with [f coll & colls]\n  (reduce conj\n    coll\n    (for [coll2 colls\n          [k v] coll2]\n      (if (contains? coll k)\n        {k (f (get coll k) v)}\n        {k v}\n        )\n      )\n    )\n  )","problem":69,"user":"4ecfa05c535d44c135fd68b9"},{"code":"(fn [f m1 & ms]\n  (loop [r m1 m (first ms) ms (rest ms)]\n    (if m\n      (recur\n        (reduce \n          (fn [r [k v]]\n            (assoc r k\n              (if (r k) (f (r k) v) v)\n              ) \n          ) r m)\n        (first ms)\n        (rest ms)\n        )\n      r\n    )\n  )\n)","problem":69,"user":"4e7e93f5535db169f9c7971a"},{"code":"(fn [f & maps]\n  (reduce \n   (fn [x y] (reduce \n              #(if (contains? x (key %2)) \n                 (conj %1 [(key %2) (f (x (key %2)) (val %2))]) \n                 (conj %1 %2))\n              x\n              y)\n     )\n   maps))","problem":69,"user":"52379c46e4b0fae3832e99db"},{"code":"(fn [f init & more]\n  (reduce (fn [result latter]\n    (reduce #(assoc %1 (key %2) (if (contains? %1 (key %2)) (f (%1 (key %2)) (val %2)) (val %2)))\n      result latter))\n    init more))","problem":69,"user":"4ec4ac86535dcc7ae8597d64"},{"code":"(fn mw [f & ds]\n  (reduce (fn [m d]\n            (into m \n              (for [[k v :as p] d]\n                (if-let[o (m k)]\n                  [k (f o v)]\n                  p))))\n          ds))","problem":69,"user":"4f58fe71e4b0a7574ea7185f"},{"problem":69,"code":"(fn [op & maps]\n  (reduce (fn [first-map next-map]\n            (reduce (fn [d0 k]\n                      (if (get d0 k)\n                        (assoc d0 k (op (get d0 k) (get next-map k)))\n                        (assoc d0 k (get next-map k))))\n                    first-map\n                    (keys next-map)))\n          (first maps)\n          (drop 1 maps)\n          ))","user":"56cc34aee4b0ea9b8538f73c"},{"code":"(fn [f & colls]\n  (reduce (fn [acc k] (assoc acc k \n                             (let [v (remove nil? (map #(get % k) colls))]\n                               (if (= 1 (count v)) (first v) (apply f v)))))\n          {} (keys (apply conj colls))))","problem":69,"user":"531f7a2de4b08068f379edc6"},{"problem":69,"code":"(fn ! [op & ss]\n  (do (println op)\n      (println ss)\n  (if (= 1 (count ss)) (first ss) \n    (let [fs (first ss)\n          s2 (do (println fs (second ss)) (second ss))\n          r (into {}\n              (map \n               #(if (contains? fs %) \n                  (if (contains? s2 %) [% (op (fs %) (s2 %))] \n                                       [% (fs %)])\n                  [% (s2 %)])\n             (clojure.set/union (set (keys fs)) (set (keys s2)))\n             ))\n          ]\n      (apply ! (concat [op] [r] (drop 2 ss))))))\n)","user":"52faec2ee4b047fd55837004"},{"code":"(fn [f & ms] ( reduce\n  (fn [m1 m2] ( let [\n    k (->> m2 first first)\n    v (->> m2 first second)\n    old (get m1 k)]\n    (assoc m1 k (if old (f old v) v))\n  )) {} (for [m ms, [k v] m] {k v})\n))","problem":69,"user":"4ef48422535dced4c769f236"},{"problem":69,"code":"(fn [f & coll]\n  (reduce\n    (fn [acc e]\n      (reduce\n        (fn [acc [k v]]\n          (if (get acc k)\n            (assoc acc k (f (get acc k) v))\n            (assoc acc k v)))\n        acc\n        e))\n    {}\n    coll))","user":"5c73b8bae4b0fca0c16227ba"},{"code":"(fn [f mastermap & maps]\n\t(letfn \n\t\t[\n\t\t\t(softmergeentry [f mastermap [k v]]\n\t\t\t\t(if (contains? mastermap k)\n\t\t\t\t\t(merge mastermap {k (f (get mastermap k) v)})\n\t\t\t\t\t(merge mastermap {k v})\n\t\t\t\t)\n\t\t\t)\n\t\t]\n\t\t(reduce \n\t\t\t(fn [mastermap othermap]\n\t\t\t\t(loop [master mastermap, other othermap]\n\t\t\t\t\t(if (empty? other)\n\t\t\t\t\t\tmaster\n\t\t\t\t\t\t(recur (softmergeentry f master (first other)) (rest other))\n\t\t\t\t\t) \n\t\t\t\t)\n\t\t\t)\n\t\t\tmastermap maps\n\t\t)\n\t)\n)","problem":69,"user":"522d3a16e4b0e26240291d50"},{"problem":69,"code":"(fn merging [func resultMap & otherMaps]\n  (let [reductor2 (fn [resultMap [key val] ]\n                     (if (contains? resultMap key)\n                       (assoc resultMap key (func (resultMap key) val))\n                       (assoc resultMap key val)))\n        reductor1 (fn [resultMap map]\n                   (reduce reductor2 resultMap map))]\n    (reduce reductor1 resultMap otherMaps)))","user":"525b4e8de4b0cb4875a45d0f"},{"problem":69,"code":"(fn [f m & maps]\n  (reduce (fn [acc m]\n            (reduce (fn [acc* [key* val*]]\n                      (if (contains? acc key*)\n                        (assoc acc* key* (f (get acc* key*) val*))\n                        (assoc acc* key* val*)))\n                    acc\n                    m))\n          m\n          maps))","user":"60654263e4b069485764ddc9"},{"code":"(fn [merge-fn c & cs]\n    (letfn\n        [(superconj [map entry] (if (contains? map (first entry))\n                                  (assoc map (first entry) (merge-fn (map (first entry)) (second entry)))\n                                  (conj map entry)))]\n        (reduce superconj c (apply concat cs))))","problem":69,"user":"4dbb0f2d535d1e037afb21b1"},{"problem":69,"code":"(fn m-w [f m & ms]\n   (if (coll? ms)\n     (reduce (fn [acc [k v]]\n               (if-let [mv (acc k)]\n                 (assoc acc k (f mv v))\n                 (assoc acc k v))) m (apply m-w f ms))\n     m))","user":"5eb1c786e4b00a66d4a95201"},{"code":"(fn my-merge-with [f & maps]\n\t(letfn [(intersecting-keys [m1 m2]\n\t (filter \n\t   #(and \n\t      (contains? m1 %) \n\t      (contains? m2 %)) \n\t   (distinct \n\t     (concat \n\t       (keys m1) \n\t       (keys m2)))))]\n   (reduce \n     (fn [m1 m2]\n       (if-let [crossed-keys (intersecting-keys m1 m2)]\n         (conj m1 m2 (reduce #(assoc %1 %2 (f (get m1 %2) (get m2 %2))) {} crossed-keys))\n         (conj m1 m2)\n                ))\n     {}\n     maps)))","problem":69,"user":"52319066e4b0e2e8de81d1e9"},{"problem":69,"code":"(fn  [f & mps]\n  (reduce (fn [mp1 mp2]\n            (reduce (fn [mp [k v2]]\n                      (assoc mp k (if (contains? mp k) (f (mp k) v2) v2)))\n                    mp1\n                    mp2))\n            mps))","user":"5339c105e4b0e30313ee6cae"},{"problem":69,"code":"(fn [f & maps]\n  (reduce \n   (fn [mainAcc curMap]\n     (reduce\n      (fn [acc cur]\n  \t   (if (contains? acc (first cur))\n   \t    (conj acc [(first cur) (f (get acc (first cur)) (second cur))])\n  \t    (conj acc cur))\n        )\n      \tmainAcc\n      \tcurMap\n      )\n     )\n   \t{}\n   \tmaps\n   )\n  )","user":"52f9c68ce4b047fd55836fef"},{"code":"(fn [f & mp]\n  (let [me (fn [m e]\n  \t\t(let [k (key e) v (val e)]\n\t\t\t  (if (contains? m k)\n\t\t\t    (assoc m k (f (get m k) v))\n\t\t\t    (assoc m k v))))\n          mr (fn [m1 m2]\n\t\t   (reduce me (or m1 {}) (seq m2)))]\n      (reduce mr mp)))","problem":69,"user":"4e44358f535dc968683fc4a8"},{"problem":69,"code":"(fn [f o & maps]\n  (reduce\n    (fn mrg [o m]\n      (merge o\n        (into {}\n          (map (fn [[k v]] (vector k (if (o k) (f (o k) v) v))) m)\n         )\n       )\n    )\n    o maps))","user":"53ecac57e4b0d648e757f4b3"},{"code":"(fn [f & maps ]\n  (reduce \n   #(assoc % (first %2) \n      (reduce f (filter (complement nil?) (map (fn [m] (get m (first %2))) maps)) )\n   ) \n   {} (apply merge maps))\n)","problem":69,"user":"51ba8f82e4b0fe3ecfb46434"},{"problem":69,"code":"(fn [f m & ms]\n  (letfn [(merge-f\n           [f m1 m2]\n           (merge m1  (into {} (for [[key val] m2]\n                                 (if (m1 key)\n                                   [key (f (m1 key) val)]\n                                   [key val])))))]\n    (loop [result m\n           maps ms]\n      (let [next (first maps)\n            rest (rest maps)]\n        (if (nil? next)\n          result\n          (recur  (merge-f f result next)  rest))))))","user":"5e9154c1e4b0cb0169546354"},{"code":"(fn [f & maps]\n  (reduce (fn [merged i]\n            (let [ks (keys (reduce into [merged i]))]\n              (reduce (fn [m k]\n                        (let [a (m k) b (i k)\n                              v (if (and a b) (f a b) (if a a b))]\n                          (assoc m k v)))\n                      merged\n                      ks)))\n          maps))","problem":69,"user":"4e2b1d48535deb9a81d77f03"},{"problem":69,"code":"(fn [f & ms]\n  (apply hash-map (mapcat (fn [[k v]] [k (reduce f (vals v))]) (group-by key (apply concat ms)))))","user":"541096bde4b01498b1a719b2"},{"problem":69,"code":"(fn [f & colls]\n  (reduce\n    #(reduce\n      (fn [m [k v]]\n        (assoc m k (if-let [p (m k)]\n                     (f p v)\n                     v)))\n      %1 %2)\n    colls))","user":"54074fc5e4b0addc1aec66b6"},{"code":"(fn mergewith\n  [f m & ms]\n  (reduce (fn [accum m]\n            (->> m\n                 (map (fn [[k v]]\n                        (vector k (if-let [accuv (accum k)]\n                                    (f accuv v)\n                                    v))))\n                 (into accum)))\n          m ms))","problem":69,"user":"52d95491e4b09f7907dd13a4"},{"code":"(let [merging \n      (fn [f m n] \n        (loop [x m y n] \n          (if (empty? y) \n            x \n            (recur (if (contains? x (key (first y))) \n                     (conj x [(key (first y)) (f (get x (key (first y))) (val (first y)))]) \n                     (conj x [(key (first y)) (val (first y))]))\n                   (rest y)))))]\n(fn merge-fun [f m & args]\n  (if (empty? (rest args))\n    (merging f m (first args))\n    (apply merge-fun \n           f \n           (merging f m (first args))\n           (rest args)))))","problem":69,"user":"52e17e66e4b09f7907dd1423"},{"code":"(fn[f & m]\n  (let [kkeys (set (mapcat keys m))]\n    (apply merge \n        (map (fn[k]\n            (assoc {} k, (reduce f (remove nil? (map #(get % k) m))))) \n                 kkeys))))","problem":69,"user":"52d66ca0e4b09f7907dd135c"},{"problem":69,"code":"(fn func [f & maps]\n  (letfn [(merge-two-maps\n            [m1 m2]\n            (reduce\n             (fn [res [k v]]\n               (if (contains? res k)\n                 (assoc res k (f (res k) v))\n                 (assoc res k v)))\n             m1 m2))]\n    (reduce merge-two-maps {} maps)))","user":"5e805895e4b085ba37836e44"},{"code":"(fn [f & m]\n  (reduce (fn [r n]\n              (reduce (fn [c [k v]]\n                        (assoc c k (if (nil? (c k))\n                                       v\n                                       (f (c k) v))))\n                      r\n                      n))\n          {}\n          m))","problem":69,"user":"4ee4f4a9535d1385b2869d85"},{"problem":69,"code":"(fn mergewith  [f & args]\n  (reduce (fn [map1 map2]\n            (reduce (fn [m [k v]]\n                      (if-let [mv (m k)]\n                        (assoc m k (f mv v))\n                        (assoc m k v)))\n                    map1 map2))\n          args))","user":"5614fa1de4b05f002753dfbe"},{"problem":69,"code":"(fn [f & maps] \n  (letfn [(merge-vals [acc m]\n            (let [kvs\n              (for[[k v] m] \n                (let [new-val (if (contains? acc k) (f (acc k) v) v)]\n                  [k new-val]))]\n              (apply merge acc kvs)))]\n\n    (reduce merge-vals maps)))","user":"55ecb2c0e4b0121d4835fdce"},{"problem":69,"code":"(fn my-merge-with\n  [op & ms]\n  (letfn [(merge-vals [old-val val]\n            (if (nil? old-val) val (op old-val val)))\n          (merge-entry [res key val]\n            (update-in res [key] #(merge-vals % val)))\n          (join [a b]\n            (reduce-kv merge-entry a b))]\n    (reduce join {} ms)))","user":"5b13ba71e4b0cc2b61a3be53"},{"problem":69,"code":"(fn [f & ms]\n(reduce\n(fn [m1 m2]\n(reduce\n(fn [m [k v]]\n(if (m k)\n(update-in m [k] f v)\n(assoc m k v)))\nm1 m2)) ms))","user":"5fd10010e4b07e53c2f3f02a"},{"problem":69,"code":"(fn [f & ms]\n  (reduce (fn [acc cur]\n            (reduce (fn [m [k v]]\n                      (if (contains? m k)\n                        (assoc m k (f (m k) v))\n                        (assoc m k v)))\n                    acc\n                    cur))\n          ms))","user":"55c4e48be4b0e31453f649a7"},{"code":"(fn [f m & to-be-merged]\n    (letfn [(merge-one-with [m1 m2]\n              (loop [result m1\n                     ks (keys m2)]\n                (println :result result :ks ks)\n                (if (empty? ks)\n                  result\n                  (recur \n                   (let [key (first ks)\n                         item1 (get m1 key)\n                         item2 (get m2 key)]\n                     (if (contains? m1 key)\n                       (assoc result key (f item1 item2))\n                       (assoc result key item2)))\n                   (rest ks)))))]\n      (reduce merge-one-with m to-be-merged)))","problem":69,"user":"53487737e4b084c2834f4a59"},{"problem":69,"code":"(fn [ f & ms ] \n  (reduce \n   (fn [b i] (reduce-kv  \n              (fn [m k v]  \n                (assoc m k (if (get m k)\n                             (f (get m k) v)\n                             v)))  \n                b i)) ms  \n               ))","user":"5018ed15e4b011a2e0bf6412"},{"problem":69,"code":"(fn [f & maps]\n  (reduce (fn [base-map m-to-add] \n            (reduce (fn [m k] (if (contains? m k)\n                                  (assoc m k (f (get m k) (get m-to-add k)))\n                                  (assoc m k (get m-to-add k)))) \n                    base-map\n                   (keys m-to-add)))\n          {}\n          maps))","user":"545e9cf1e4b01be26fd7467f"},{"problem":69,"code":"(fn \n  [f & maps]\n  (reduce (fn [merged next-map]\n            (reduce (fn [merged [k v]]\n                      (if-let [merged-val (get merged k)]\n                        (conj merged [k (f merged-val v)])\n                        (conj merged [k v])))\n                    merged\n                    next-map))\n          {}\n          maps))","user":"55eaca20e4b0121d4835fdb4"},{"problem":69,"code":"(fn [f & ms]\n  (let [av (fn [k ms]\n             (map #(% k) (filter #(contains? % k) ms)))\n        ks (set (apply concat (map keys ms)))]\n    (into {} (for [k ks]\n               (let [vs (av k ms)]\n                 [k (if (> (count vs) 1)\n                      (apply f vs)\n                      (first vs))])))))","user":"51780bfce4b0f89a8f53839c"},{"problem":69,"code":"(fn [f m & ms] (into m (for [x ms [k v] x] (if (contains? m k)\n                                             [k (f (m k) v)]\n                                             [k v]))))","user":"55f20e4be4b06e875b46ce40"},{"problem":69,"code":"(fn merge-with' [f & maps]\n  (reduce-kv (fn [agg k v]\n               (assoc agg k (reduce f (map val v))))\n             {}\n             (group-by key (mapcat seq maps))))","user":"5b602a66e4b0c6492753e6fc"},{"code":"(fn m [f & maps]\n  (reduce \n    (fn [m1 m2] (reduce \n                  #(merge % {%2 (if (contains? % %2) (f (% %2) (m2 %2)) (m2 %2))})\n                  (cons m1 (keys m2))))\n    maps))","problem":69,"user":"4fa5406fe4b081705acca1ac"},{"code":"(fn [f & maps]\n  (let [kvs (mapcat seq maps)\n        merge-fn (fn [m [k v]] \n              (if (contains? m k)\n                (assoc m k (f (m k) v))\n                (assoc m k v)))]\n  (into {} (reduce merge-fn {} kvs))))","problem":69,"user":"4f1c2a3a535d64f603146480"},{"problem":69,"code":"#(reduce\n   (fn [acc m]\n     (reduce-kv\n      (fn [acc k v]\n        (if-let [old-v (acc k)]\n          (update-in acc [k] % v)\n          (assoc acc k v)))\n      acc\n      m))\n   {}\n   %&)","user":"510528a0e4b0730a5f55ad85"},{"code":"(fn [f m1 & ms]  \n           (let [m2 (reduce merge ms)]\n             (loop [km (keys m2)\n                    m1 m1]\n               (if (empty? km)\n                 m1\n                 (recur (rest km)\n                        (let [k (first km)]\n                          (if (get m1 k)\n                            (assoc m1 k (f (get m1 k) (get m2 k)))\n                            (assoc m1 k (get m2 k)))))))))","problem":69,"user":"50a5b7e9e4b0aa96157e2610"},{"code":"(fn [f start & rest]\r\n  (reduce (fn [cur newm]\r\n            (let [n (set (keys newm))\r\n                  common (clojure.set/intersection (set (keys cur)) n)\r\n                  c (merge cur (select-keys newm (clojure.set/difference n common)))]\r\n              (reduce #(assoc %1 %2 (f (%1 %2) (newm %2))) c common)))\r\n    start rest))","problem":69,"user":"4fe900a6e4b0547ebccb243a"},{"code":"(fn m-with [f & args]\n  (let [ks (reduce #(into %1 (keys %2)) #{} args)\n        apply-f-vals \n          (fn [f k xs] \n            (let [vs (filter #(not (nil? %)) (map #(% k) xs))]\n              (if (= 1 (count vs)) (first vs) (apply f vs))))]\n    (reduce merge \n      (for [k ks]\n        {k  (apply-f-vals f k args)}\n     ))))","problem":69,"user":"501c1492e4b086d93747d180"},{"problem":69,"code":"(fn [f & ms]\n    (into {}\n          (map (fn [[k kvs]] [k (reduce f (vals kvs))])\n               (group-by key\n                         (mapcat #(map identity %) ms)))))","user":"51b91b08e4b0e871ca4958f8"},{"code":"(fn [f & xs]\n  (reduce \n   (fn [a b]  \n     (reduce-kv \n       #(update-in % [%2] (fn [x] (if x (f x %3) %3)))\n      a b)) {} xs ))","problem":69,"user":"4e3a9dae535deb9a81d77f4a"},{"code":"(fn [f x & y]\n  (let [y (into {} y)]\n    (loop [x x y y]\n      (if (empty? y)\n        x\n        (recur (if (contains? x (key (first y)))\n                  (assoc x (key (first y)) (f (get x (key (first y))) (val (first y)) ))\n                  (assoc x (key (first y)) (val (first y))) )\n                (into {} (next y)))))))","problem":69,"user":"4faec810e4b081705acca24e"},{"problem":69,"code":"(fn [f & maps]\n  (let [merge-entry (fn [m e] \n                      (let [k (key e) v (val e)] \n                        (if (contains? m k)\n                          (assoc m k (f (get m k) v))\n                          (assoc m k v))))\n        merge2 (fn [m1 m2] (reduce merge-entry m1 (seq m2)))] \n    (reduce merge2 maps)))","user":"4e94a8b5535dbda64a6f6b16"},{"problem":69,"code":"(fn merge-w-fun [f m0 & ms]\n  (let [merge-f-m (fn [acc [k v]] (if (get acc k) (assoc acc k (f (acc k) v))\n                                  (assoc acc k v)))]\n    (loop [acc m0, [m1 & ms] ms]\n      (if (nil? (seq m1)) acc\n            (recur (reduce merge-f-m acc m1) ms)))))","user":"54bbaa8ee4b0ed20f4ff6ec0"},{"problem":69,"code":"(fn [predicate & maps]\n    (reduce\n      (fn [reduced-map latter-map]\n        (reduce-kv\n          #(assoc %1 %2 (if (%1 %2) (predicate (%1 %2) %3) %3)) reduced-map latter-map))\n      maps))","user":"5ca622f3e4b048ec896c5be0"},{"problem":69,"code":"(fn [f x & xs] \n  (letfn [(merge-with-sub [init y] \n      (update-in init (vector (first y)) (fn [k] (let [v (second y)] (if (nil? k) v (f k v))))))] \n        (reduce #(if (seq? %2) (merge-with-sub %1 %2) (reduce merge-with-sub %1 %2)) x xs)))","user":"58e7229fe4b056aecfd47cc4"},{"code":"(fn [f & [h & t :as maps]]\n  (let [ks (into #{} (mapcat keys maps))]\n    (apply hash-map (interleave ks (map #(reduce f %) (map (fn [k] (filter #(when % %) (map #(% k) maps))) ks))))))","problem":69,"user":"4ff304f4e4b0678c553fc343"},{"problem":69,"code":"(fn my-merge-with\n  [f & maps]\n  (reduce (fn [sol curr-map]\n            (reduce (fn [acc curr-pair]\n                      (let [curr-key (first curr-pair)\n                            curr-val (last curr-pair)]\n                        (if-let [acc-val (get acc curr-key)]\n                          (assoc acc curr-key (f acc-val curr-val))\n                          (assoc acc curr-key curr-val))))\n                    sol\n                    curr-map))\n          maps))","user":"5acd235ae4b0e27600da7824"},{"problem":69,"code":"(fn mymerge-with [f m1 & ms]\n  (into m1 (for [m ms [k v] m] (if-let [v1 (m1 k)] [k (f v1 v)] [k v]))))","user":"5cab33e7e4b048ec896c5c48"},{"problem":69,"code":"(letfn [(mw [f h1 h2]\n            (reduce (fn [acc key] \n                      (if (contains? acc key)\n                        (assoc acc key (f (get acc key) (get h2 key)))\n                        (assoc acc key (get h2 key)))) \n                    h1 (keys h2)))]\n  (fn [f & hashes]\n    (reduce (partial mw f) hashes)))","user":"5553b924e4b0deb715856e06"},{"code":"(fn merge-all [fx & args]\n  (reduce #(into %1 (for [[a b] %2] (if (%1 a) [a (fx (%1 a) b)] [a b]))) {} args))","problem":69,"user":"514cfa27e4b019235f6c057d"},{"code":"(fn [f & s]\n(->> s (mapcat vec) (group-by key)\n(map (fn [[k v]] [k (reduce f (map val v))]))\n(into {})))","problem":69,"user":"514457fbe4b0b4fb4ace5f43"},{"problem":69,"code":"(fn merge-maps-using-f\n  [f & sq-list]\n  (reduce (fn\n            [acc coll]\n            (reduce-kv (fn [acc k v]\n                         (if (contains? acc k)\n                           (update-in acc [k] f v)\n                           (assoc acc k v)))\n                       acc coll))\n          {} sq-list))","user":"5da94ccfe4b000c986472c2f"},{"problem":69,"code":"(fn me [f & map-seq]\n\n  (let [keys-set (reduce #(clojure.set/union %1 %2) (map #(into #{} (keys %)) map-seq))\n\n        new-map-seq (for [y keys-set] \n\n                      {y  (filter (complement nil?) (map #(% y) map-seq))}\n                    )  \n        \n        new-map   (apply merge new-map-seq)\n       \n\n        fn-values (fn [f my-map]\n\n                    (for [m my-map]\n\n                      {(key m) (reduce f (val m))}\n\n                    ))\n\n\n       ]\n\n       (apply merge (fn-values f new-map))\n    )\n\n)","user":"55897fe2e4b059ccff29b205"},{"problem":69,"code":"(fn [comb firstmap & maps] \n (reduce \n  (fn [result somemap] \n   (reduce \n    (fn [res [k v]] \n      (assoc res k \n        (if (contains? res k) (comb (res k) v) v))) \n    result somemap)) \n  firstmap maps))","user":"58b1f51de4b0ebc645576d05"},{"problem":69,"code":"(fn [f m & r] \n  (reduce \n   (partial \n     reduce \n      (fn [o [k v]] \n        (conj o\n              [k (if (contains? o k)\n                   (f (o k) v)\n                   v)])\n          )\n      )\n   m r))","user":"576e3258e4b0979f89651574"},{"problem":69,"code":"(fn -merge-with [f & ms]\n  (reduce (fn [acc m]\n            (into acc (map (fn [[k v]]\n                             (if-let [val-in-result (get acc k)]\n                               {k (f val-in-result v)}\n                               {k v})\n                             ) m))\n            ) ms))","user":"590d3702e4b047aa04b199ff"},{"code":"(fn my-merge-with\n  [f m & xs]\n  (if (empty? xs) m\n    (apply my-merge-with f\n      (reduce\n        #(update-in\n           %1 [(%2 0)]\n           (fn [x y] (if (nil? x) y (f x y)))\n           (%2 1))\n        m\n        (first xs))\n      (rest xs))))","problem":69,"user":"51e00020e4b01188f0627534"},{"code":"(fn [f c & [d & r]] (if d (recur f (reduce (fn [m [k v]] (assoc m k (if (m k) (f (m k) v) v))) c d) r) c))","problem":69,"user":"52b453b0e4b0c58976d9ad21"},{"code":"(fn my-merge-with [f & maps]\n(reduce\n(fn [a b]\n(reduce\n(fn [x [k v]]\n(assoc x k (if (b k) (f v (b k)) v)))\nb a))\n(first maps) (rest maps)))","problem":69,"user":"5132c6f0e4b021281ec7b6d3"},{"code":"(fn [f & maps]\n  (reduce (fn [init m]\n            (reduce-kv (fn [m k v]\n                         (assoc m k (if (m k)\n                                      (f (m k) v)\n                                      v))) init m)) {} maps))","problem":69,"user":"5236b6bce4b05f3be1c7c8fe"},{"code":"(fn [f m & ms]\n  (reduce (fn [acc m2]\n    (reduce (fn [acc2 [k v]]\n      (assoc acc2 k (if (acc2 k) (f (acc2 k) v) v)))\n        acc m2))\n    m ms))","problem":69,"user":"4e521cef535d302ef430da6d"},{"problem":69,"code":"(fn [op & ms] \n  (letfn [(merge-one [i m] \n                     (reduce (fn [m [k v]] (assoc m k (if (contains? m k) (op (m k) v) v))) i m))]\n    (reduce merge-one ms)))","user":"52e851bfe4b09f7907dd149a"},{"problem":69,"code":"(fn p-69 [f & maps]\n (reduce\n  (fn mergey [a b]\n    (loop [ks (keys b)\n           newa a]\n      (let [k (first ks)]\n        (if (empty? ks)\n          newa\n          (if (get a k)\n            (recur (rest ks) (assoc newa k (f (get a k) (get b k))))\n            (recur (rest ks) (assoc newa k (get b k))))))))\n   maps))","user":"5bfc9037e4b0bdcf453d15f2"},{"code":"(fn [f & ms]\n  (reduce\n    (fn [m0 m1]\n      (reduce\n        (fn [m [k v]]\n          (let [o (get m k)]\n            (if o\n              (assoc m k (f o v))\n              (assoc m k v)\n            )\n          )\n        )\n        m0\n        m1\n      )\n    )\n    ms\n  )\n)","problem":69,"user":"507eddf4e4b06ce648bcdbfa"},{"problem":69,"code":"(fn merge-with*\n  ([f m1 m2]\n   (reduce (fn [m [k v]]\n             (assoc m k (if (contains? m k)\n                          (f (get m k) v)\n                          v)))\n           m1\n           m2))\n  ([f m1 m2 & ms]\n   (reduce (partial merge-with* f)\n           (merge-with* f m1 m2)\n           ms)))","user":"575cbe44e4b02ea114799374"},{"problem":69,"code":"(fn merge4clojure [f & maps]\n  (reduce (fn [val m]\n            (reduce (fn [result [k v]] (assoc result k (if-let [vv (get result k)] (f vv v) v))) val m))\n          {}\n          maps))","user":"52c5c1c8e4b0c2d177d620fc"},{"code":"(fn [f & m]\n  (reduce\n    (fn [j a]\n      (reduce\n        #(assoc % %2 (if (j %2) (f (j %2) (a %2)) (a %2)))\n        j\n        (keys a)))\n    m))","problem":69,"user":"4ef77c82535dced4c769f253"},{"problem":69,"code":"(fn my-merge-with\n  ([f a b]\n   (reduce-kv (fn [m k v]\n             (if (contains? m k)\n               (assoc m k (f (get m k) v))\n               (assoc m k v)))\n           a\n           b))\n  ([f a b & xs]\n   (reduce (fn [acc map] (my-merge-with f acc map)) a (cons b xs)))\n  )","user":"5f29837ee4b033932238a64f"},{"problem":69,"code":"(fn [f & maps] (reduce \n  (fn [acc m] (into acc (for [[k v] m] [k (if (acc k) (f (acc k) v) v)])))\n  maps))","user":"529dfc6de4b04e0c58e87b8a"},{"problem":69,"code":"(fn [f & x]\n  (let [K (reduce into #{} (map keys x))\n        not-nil (fn [v] (not (nil? v)))]\n    (apply conj {}\n      (map\n        #(vector % (let [args (filter not-nil (map (fn [m] (m %)) x))]\n                     (if (= (count args) 1) (first args) (apply f args))))\n        K))))","user":"55c77070e4b0e31453f649d0"},{"code":"(fn merge-with-fun\n  [f & m]\n  (reduce  (fn [a b]  (reduce (fn [c [k v]] (assoc c k (if ( c k)(f ( get c k) v) v) ) ) a b) )  (first m) (rest m)))","problem":69,"user":"4e6dd0f5535d5021c1a895f3"},{"problem":69,"code":"(fn my-merge-width [f c & cols]\n  (reduce\n    #(reduce\n       (fn [m [k v]] (assoc m k (if-let [w (m k)] (f w v) v))) %1 %2) c cols))","user":"54769c7ae4b0c51c1f4d72a8"},{"problem":69,"code":"(fn [f & args]\n   (reduce (fn [acc item] \n             (reduce (fn [m [k v]]\n                       (if (contains? m k)\n                         (update-in m [k] f v)\n                         (assoc m k v))) acc item)) args))","user":"5b337ff4e4b025bcb146f339"},{"code":"(fn [f & m]\r\n  (reduce\r\n    #(reduce\r\n      (fn [m [k v]]\r\n        (assoc m k (if (m k) (f (m k) v) v)))\r\n      % %2)\r\n    m))","problem":69,"user":"4f9597e0e4b0dcca54ed6cd4"},{"problem":69,"code":"(fn fmerge2 [f map1 & rem-maps]\n  (println rem-maps)\n  (if-let [map2 (first rem-maps)]\n    (recur f\n           (merge map2\n                  map1\n                  (reduce conj {} (map #(vector %1\n                                                (f (get map1 %1)\n                                                   (get map2 %1)))\n                                       ;get the common keys\n                                       (keys (select-keys map1 (keys map2)))\n                                       )))\n           (next rem-maps))\n    map1))","user":"53f6bfd9e4b0db01ade6f9e4"},{"code":"(fn [f & ms]\n (into {}\n       (map #(reduce (fn\n                       ([kv] kv)\n                       ([[k v1] [_ v2]] [k (f v1 v2)])) %)\n            (map val (group-by key (apply concat ms))))))","problem":69,"user":"4fa0a4b1e4b0dcca54ed6d4f"},{"code":"(fn mergeFunc [f & maps]\n  (reduce\n    (fn [a b]\n      (reduce\n        (fn [x [k v]]\n          (assoc x k (if (b k) (f v (b k)) v)))\n        b a))\n    (first maps) (rest maps)))","problem":69,"user":"5225b16de4b0d2f5d1e2c0ed"},{"problem":69,"code":"(fn [f & maps]\n   (when (some identity maps)\n     (let [merge-entry\n           (fn [map entry]\n             (let [k (key entry) v (val entry)]\n               (if (contains? map k)\n                 (assoc map k (f (get map k) v))\n                 (assoc map k v))))\n           do-merge\n           (fn [first-map second-map]\n             (reduce merge-entry first-map second-map))]\n       (reduce do-merge maps))))","user":"5c3f37fce4b08cd430848e91"},{"problem":69,"code":"(fn [f, & mapList] (reduce (fn [xMap yMap] \n\t(reduce-kv \n\t\t(fn [m k v] \n\t\t\t(if (get m k)\n\t\t\t\t(assoc (dissoc m k) k (f (get m k) v))\n\t\t\t\t(assoc m k v))) xMap yMap))  mapList))","user":"57986b76e4b039eba2ecb116"},{"problem":69,"code":"(fn merge-with-a-function [f starting-coll & colls]\n  (reduce (fn [result coll]\n            (reduce (fn [r [k v]]\n                      (if (contains? r k)\n                        (assoc r k (f (r k) v))\n                        (assoc r k v)))\n                    result\n                    coll))\n          starting-coll\n          colls))","user":"5a0ef454e4b04bbd27e6d9fa"},{"problem":69,"code":"(fn [op xmap & ymap-coll]\n  (reduce (fn [init-map y-map]\n            (reduce (fn [ret-map y-key]\n                      (if (contains? init-map y-key)\n                        (assoc ret-map y-key (op (get ret-map y-key) (get y-map y-key)))\n                        (assoc ret-map y-key (get y-map y-key))))\n                    init-map (keys y-map)))\n          xmap ymap-coll))","user":"591072e0e4b0163c97b36ebc"},{"problem":69,"code":"(fn mm [f m1 & args]\n  (reduce (fn [ret arg]\n            (reduce (fn [ret2 ar]\n                      (let [k (key ar)\n                            v (val ar)]\n                        (if (ret2 k)\n                          (assoc ret2 k (f (ret2 k) v))\n                          (merge ret2 ar))))\n                    ret\n                    arg))\n          m1 \n          args))","user":"535f0cbde4b04ce2eb3ed2d9"},{"problem":69,"code":"(fn [f & l] (apply merge (map #(hash-map (first %1) (if (>= 1 (count (last %1))) (last (last (last %1))) (apply f (map last (last %1))))) (group-by first (apply concat l)))))","user":"54edcf96e4b024c67c0cf866"},{"problem":69,"code":"(fn mergewith \n  [f m & ms]\n    (if (empty? ms)\n      m\n      (let [m2 (first ms)\n            merged (merge m m2)\n            common (filter #(m %) (keys m2))\n            prods (map #(f (m %) (m2 %)) common)\n            newm (merge merged (zipmap common prods))\n            ]\n        (apply mergewith (concat [f newm] (rest ms)))\n       )\n     )\n  )","user":"57cf03c0e4b00451144b04f9"},{"problem":69,"code":"(fn [f m & ms]\n  (reduce (fn [mo mi]\n            (reduce-kv\n              (fn [m k v1]\n                (assoc m k (if-let [v0 (get m k)] (f v0 v1) v1)))\n              mo mi))\n          m ms))","user":"5310e968e4b08068f379ecdd"},{"problem":69,"code":"(fn [f & maps]\n  (reduce (fn [map1 map2]\n    (reduce (fn [m [k v]]\n      (if (contains? m k)\n        (assoc m k (f (get m k) v))\n        (assoc m k v)))\n     map1 map2))\n   maps))","user":"5b0180cfe4b0cc2b61a3bd47"},{"problem":69,"code":"(fn [f & maps]\n  (reduce (fn [acc map]\n                  (merge map (reduce (fn [acc k]\n                             (update-in acc [k] f (get map k))) acc (clojure.set/intersection (set (keys acc)) (set (keys map)))))) (first maps) (rest maps)))","user":"52efd3d9e4b05e3f0be25ed4"},{"code":"(fn [o r & m] \n  (reduce #(let [a (first %2) b (last %2) c assoc]\n            (if \n             (nil? (% a)) \n             (c % a b) \n             (c % a (o (% a) b))))\n          r\n          (reduce concat (map (partial into []) m)) \n  )\n)\n\n;(fn [op result & maps] \n;  (reduce #(if \n;             (nil? (% (first %2))) \n;             (assoc % (first %2) (last %2)) \n;             (assoc % (first %2) (op (% (first %2)) (last %2)))) \n;          result\n;          (reduce concat (map (partial into []) maps)) \n;  )\n;)","problem":69,"user":"513b77f3e4b00f740c76c403"},{"problem":69,"code":"(fn [f & maps] (when (some identity maps)\n   (let [merge-entry (fn [m e]\n                       (let [k (key e) v (val e)]\n                         (if (contains? m k)\n                           (assoc m k (f (get m k) v))\n                           (assoc m k v))))\n         merge2 (fn [m1 m2]\n                  (reduce merge-entry (or m1 {}) (seq m2)))]\n     (reduce merge2 maps))))","user":"536be48ee4b0fc7073fd6e31"},{"problem":69,"code":"(fn mymerge [f & maps]\n  (let [merge (fn [m1 m2]\n                (loop [m2-keys (keys m2)\n                       result m1]\n                  (if (empty? m2-keys) result\n                      (let [k (first m2-keys)]\n                        (if (contains? result k)\n                          (recur (rest m2-keys) (assoc result k (f (result k) (m2 k))))\n                          (recur (rest m2-keys) (assoc result k (m2 k))))))))]\n    (reduce merge maps)))","user":"58ef0b8ce4b056aecfd47dbf"},{"code":"(fn [op & m] (reduce #(reduce (fn [m k] (let [v1 (m k) v2 (%2 k)] (if v1 (assoc m k (op v1 v2)) (assoc m k v2)))) %1 (keys %2)) {} m))","problem":69,"user":"505dcfc8e4b0e6aca564be0d"},{"problem":69,"code":"(fn [f & args]\n  (reduce\n     (fn [acc m]\n       (reduce (fn [a [k v]]\n                    (assoc a k (if (get acc k)\n                                   (f (get acc k) v)\n                                 v)))\n               acc\n               m))\n   args))","user":"598858d0e4b021a7a535feb5"},{"code":"(fn [f & mps]\n  (reduce (fn [acc mp]\n            (reduce (fn [acc [k v]]\n                      (update-in\n                       acc\n                       [k]\n                       (if (contains? acc k) f (constantly v))\n                       v))\n                    acc\n                    mp)\n            )\n          {}\n          mps))","problem":69,"user":"525431dfe4b0541d1855b970"},{"problem":69,"code":"(fn my-merge-with [f & ms]\n  (reduce (fn [m m2]\n            (reduce (fn [m key]\n                      (assoc m key (if (contains? m key)\n                                     (f (m key) (m2 key))\n                                     (m2 key))))\n                    m (keys m2))) ms))","user":"546c1f73e4b00cfc9eacc175"},{"problem":69,"code":"(fn [f & maps]\n   (let [whole-map (apply merge maps)\n         ks (keys whole-map)]\n     (loop [[k & ks] ks, ret {}]\n       (if (not k)\n         ret\n         (recur ks (conj ret\n                            [k (reduce f (filter identity (map #(% k) maps)))]))))))","user":"554b7056e4b0a04f79299583"},{"code":"(fn \n    [fo collo & colls]\n    (reduce (fn [coll1 coll2]\n                (reduce (fn [c [k v]]\n                            (if (c k) (assoc c k (fo (c k) v))\n                                (assoc c k v))) coll1 coll2)) collo colls))","problem":69,"user":"50b35486e4b03ea88043356a"},{"problem":69,"code":"(fn my-merge-with\n [f a & maps]\n (reduce #(reduce (fn [t [k v]]\n                    (if (contains? t k)\n                      (assoc t k (f (t k) v))\n                      (assoc t k v)))\n                  % %2)\n         a maps)\n )","user":"526143b7e4b03e8d9a4a705a"},{"code":"(fn [fun & maps]\n    (reduce \n      (fn [outer e] \n        (reduce \n          (fn [inner [k v]]\n            (update-in inner [k] #(if (nil? %) v (fun % v))))\n          outer e))\n      {} maps)\n    )","problem":69,"user":"50588ff1e4b06522596eba7e"},{"problem":69,"code":"(fn [func seed & params] (reduce #(reduce (fn [r [k v]] (assoc r k (let [old (get r k nil)] (if (nil? old) v (func old v))))) % %2) seed params))","user":"5ef5ee81e4b07c55ae4a054a"},{"problem":69,"code":"(fn merge-with' [f & ms]\n   (reduce\n    (fn [acc m]\n      (reduce\n       (fn [acc [k v]]\n         (let [c (get acc k)]\n           (assoc acc k (if (nil? c) v (f c v)))))\n       acc\n       m))\n    {}\n    ms))","user":"55fbc657e4b0f488688e0666"},{"problem":69,"code":"(fn prob69\n  [f m & more]\n  (letfn [(update [m k f x] ;; can use Clojure ver. 1.8's update instead\n            (assoc m k (f (m k) x)))\n          (update-with [m k f x] ;; core/update is to update-with\n            (if (contains? m k)  ;; as core/merge is to core/merge-with\n              (update m k f x)\n              (assoc m k x)))]\n    (reduce (fn [m0 m1] ;; for each map in more, iterate over kv pairs\n              (reduce-kv #(update-with %1 %2 f %3) m0 m1))\n            m more)))","user":"5d2e5065e4b01671435dbcae"},{"code":"(fn [f & maps]\r\n  (when (some identity maps)\r\n    (let [merge-entry (fn [m e]\r\n  \t\t(let [k (key e) v (val e)]\r\n\t\t\t  (if (contains? m k)\r\n\t\t\t    (assoc m k (f (get m k) v))\r\n\t\t\t    (assoc m k v))))\r\n          merge2 (fn [m1 m2]\r\n\t\t   (reduce merge-entry (or m1 {}) (seq m2)))]\r\n      (reduce merge2 maps))))","problem":69,"user":"4e0e0529535d04ed9115e7b9"},{"problem":69,"code":"#(reduce (fn [m1 m2]\n             (reduce\n               (fn [m [k v]]\n                 (if (m k)\n                   (assoc m k (%1 (m k) v))\n                   (assoc m k v))) m1 m2)) %&)","user":"5c165d3ee4b01240ff5671d1"},{"code":"(fn [f x & xs]\n  (reduce\n    (fn [rm sm]\n      (reduce\n        (fn [m [k v]]\n          (if (contains? m k)\n            (assoc m k (f (m k) v))\n            (assoc m k v)))\n        rm sm))\n    x xs))","problem":69,"user":"4f1b92d1535d64f60314647b"},{"problem":69,"code":"(fn func [f & maps]\n  (reduce (\n  (fn [f]\n    (fn merge-maps [m1 m2]\n    (let [mapping (first m2)]\n      (cond\n        (nil? mapping) m1\n\n        (contains? m1 (key mapping))\n        (recur\n          ((fn [m f mapping]\n  (assoc m (key mapping) (f (m (key mapping)) (val mapping)))) m1 f mapping)\n          (rest m2))\n\n        :else\n        (recur\n          (assoc m1 (key mapping) (val mapping))\n          (rest m2))))))\n   f) maps))","user":"54b912b3e4b0ed20f4ff6ea1"},{"problem":69,"code":"(fn mw [f res & x]\n  (reduce\n   (fn [x y]\n     (if (x (first y))\n       (assoc x (first y) (f (x (first y)) (second y)))\n       (conj x y)))\n   res\n   (apply concat x)))","user":"549c8bbde4b0f3d1d8e70f8c"},{"problem":69,"code":"(fn mergef [f & s] (\n\treduce (fn [result m]\n\t\t(reduce (fn [a b] (let [k (first b) v (last b)] (if (contains? a k) (assoc a k (f (get a k) v)) (into a [b])))) result m)\n\t) (first s) (rest s)\n))","user":"59a0262ee4b0871e7608b82d"},{"code":"(fn [f & ls]\n  (reduce merge {}\n    (for [k (set (map first (apply concat ls)))]\n      (hash-map k\n        (reduce f (filter #(not (nil? %)) (map #(get % k) ls)))\n      )\n    )\n  )\n)","problem":69,"user":"4f84400de4b033992c121c2e"},{"problem":69,"code":"(fn merge-with-clone [f m1 & rest-ms]\n  (reduce (partial (fn [f m1 m2]  \n                     (conj m1 (into {} \n                                    (for [[k2 v2] m2] \n                                      (if-let [[k1 v1] \n                                               (find m1 k2)]\n                                       [k1 (f v1 v2)]\n                                       [k2 v2]))))) f) m1 rest-ms))","user":"5f21d172e4b0f565ad998286"},{"problem":69,"code":"(fn mymerge [f m & args]\n  (merge m (into {}\n                 (for [x args]\n                   (into {} (map #(let [k (first %)\n                               v (second %)]\n                          (vector k (if (contains? m k) (f (get m k) v) v)))\n                        x)))\n         )\n  ))","user":"5592bf9fe4b0c79f6e1db933"},{"problem":69,"code":"(fn [f & maps]\n   (reduce\n    (fn [m1 m2]\n      (reduce \n       (fn [acc [k v]] \n         (if (contains? acc k) \n           (assoc acc k (f (acc k) v))\n           (assoc acc k v)))\n       m1\n       m2))\n    maps))","user":"567476bde4b05957ce8c6139"},{"problem":69,"code":"(fn [f m & r]\n       (reduce\n         (partial reduce-kv\n                  #(assoc % %2 (if-let [x (% %2)]\n                                 (f x %3)\n                                 %3))) m r))","user":"5382704be4b06839e8705ed4"},{"problem":69,"code":"(fn my-merge-with [f init & maps]\n  (reduce \n    (fn [acc map] \n       (reduce-kv \n         (fn [acc' key val]\n            (if (contains? acc' key) \n              (conj acc' [key (f (acc' key) val)])\n              (conj acc' [key val])))\n         acc\n         map))\n    init\n    maps))","user":"5d97b602e4b0d3f9b434ad3a"},{"problem":69,"code":"(fn [f & [fst & xs]]\n  (let [g (fn [m k v] \n            (assoc m k (if-let [old (m k)]    \n                         (f old v)                            \n                         v)))]\n  (reduce #(reduce-kv g % %2) fst xs)))","user":"6011b89ee4b074f607df66bc"},{"code":"(fn [f & m]\n           (reduce\n            (fn [a b]\n                (reduce \n                 merge\n                 (map\n                  #(let [{i %} a {j %} b]\n                    {% (if (and i j) (f i j) (or i j))})\n                  (mapcat keys [a b]))))\n            m))","problem":69,"user":"4db8f6c4535d1e037afb219e"},{"code":"(fn [f m1 & ms]\n  (reduce\n    (fn [m [k v]]\n      (if (contains? m k)\n        (update-in m [k] f v)\n        (assoc m k v)\n      ))\n    m1\n    (mapcat seq ms)))","problem":69,"user":"5089ebfee4b03217b26a539f"},{"code":"(fn [f & maps]\n  (reduce \n    (fn [to-col from-col]\n      (into to-col (for [[k v] from-col] [k (if (contains? to-col k) (f (get to-col k) v) v)])))\n    {} \n    maps))","problem":69,"user":"513a4babe4b067e25a345eca"},{"code":"(fn my-merge-with\n  [f init & maps]\n  (reduce\n   (fn [dest [k v]]\n     (if (contains? dest k)\n       (assoc dest k (f (dest k) v))\n       (assoc dest k v)))\n   init\n   (apply concat maps)))","problem":69,"user":"511720eae4b0063b4e3e16da"},{"code":"(fn my-merge-with [op result & maps]\n  (reduce (fn [r m]\n      (reduce (fn [result [k v]]\n\t\t      (if (contains? result k)\n\t\t\t(assoc result k (op (get result k) v))\n\t\t\t(assoc result k v))) r m))\n\t  result\n\t  maps))","problem":69,"user":"4e513ecf535dc968683fc4f6"},{"problem":69,"code":"(fn [f & args]\n (reduce \n  (fn [m1 m2] \n   (let [s (seq (group-by first (mapcat seq [m1 m2])))\n         b (map (fn [c] [(first c) (map second (last c))]) s)]\n   (into {}\n    (for [[k v] b]\n      [k (reduce f v)]))))\n args))","user":"532a033be4b09d4e7a9b551f"},{"code":"(fn [f & maps]\n  (let [r #(reduce f %)\n        mmap #(zipmap (keys %2) (map %1 (vals %2)))]\n    (->> (mapcat #(interleave (keys %) (vals %)) maps)\n      (partition 2) (group-by first) (mmap #(map second %)) (mmap r))))","problem":69,"user":"5033a1fbe4b062bc5d7ae155"},{"problem":69,"code":"(fn [f & maps]\n  (let [all-keys (set (mapcat keys maps))]\n    (into {}\n          (for [k all-keys]\n            (let [values (remove nil? (map #(get % k) maps))]\n              (if (< 1 (count values))\n                [k (apply f values)]\n                [k (first values)]))))))","user":"55702081e4b09a3098a52529"},{"problem":69,"code":"(fn [f & rest](reduce \n  (fn [m1 m2] (let [r (or m1 {}) s (seq m2)] \n    (reduce (fn [m [k v]] (if (contains? m k) \n                       (assoc m k (f (m k) v)) (assoc m k v))) r s))) {} rest))","user":"53fe1c3be4b0de5c418485f2"},{"problem":69,"code":"(fn mrg([f m1 m2] ( \n                    reduce \n                    (fn[acc val] \n                          (if (get acc val)\n                            (assoc acc val (f (get acc val) (get m2 val)))\n                            (assoc acc val (get m2 val))\n                            ))\n                    m1\n                    (keys m2))\n                  )\n      ([f m1 m2 & more] (reduce #(mrg f %1 %2) (mrg f m1 m2) more)  )                \n                \n                )","user":"596f6683e4b069c0a1a19877"},{"problem":69,"code":"(fn merge-with* [f m & maps]\n  (let [tuples\n        (reduce (fn [acc nxt]\n                  (apply conj acc (into [] nxt)))\n                []\n                maps)]\n    (reduce\n     (fn [acc [k v]]\n       (assoc\n        acc\n        k\n        (if (get acc k)\n          (f (get acc k) v)\n          v)))\n     m\n     tuples)))","user":"59f4c42ce4b0966464fe6ab6"},{"problem":69,"code":"(fn [my-func & maps]\n  (reduce (fn [a b]\n            (let [new-hash (merge a b)\n                  common-keys (filter (partial contains? a) (keys b))]\n                 (reduce (fn [mhash mkey]\n                          (assoc mhash mkey (my-func (get a mkey) (get b mkey))))\n                        new-hash\n                        common-keys)))\n          {} maps))","user":"5655e056e4b0f9d632dd849b"},{"code":"(fn __ [f & maps]\n  (apply hash-map\n  (mapcat #(conj [(key %)]\n                  (reduce f (map second (val %))))\n          (group-by first (mapcat vec maps)))))","problem":69,"user":"4fa719c0e4b081705acca1bf"},{"code":"(fn [f & maps]\n  (let [merge-into (fn [m e]\n                     (let [k (key e) v (val e)]\n                       (if (contains? m k)\n                         (assoc m k (f (get m k) v))\n                         (assoc m k v))))\n        merge-map (fn [m1 m2]\n                    (reduce merge-into m1 m2))]\n    (reduce merge-map maps)))","problem":69,"user":"527cd633e4b0757a1b17136f"},{"problem":69,"code":"(fn merge-wit\n  [f & m]\n   (if (= 1 (count m))\n     (first m)\n     (let [merg (fn[a [fb sb]](assoc a fb (if-let [x (a fb)] (f x sb) sb)))\n           mergall #(reduce merg %1 %2)]\n       (reduce mergall {} m))))","user":"57bd960fe4b05aa3c4741c52"},{"code":"(fn [f & maps]\n  (letfn [(merge-two [a b]\n          \t(into a (for [[k v] (seq b)]\n                      [k (if (contains? a k) (f (a k) v) v)])))]\n    (reduce merge-two maps)))","problem":69,"user":"5338e33fe4b0e30313ee6ca1"},{"problem":69,"code":"#(reduce-kv (fn [m k v] (assoc m k (reduce % (map second v))))\n            {} \n            (group-by first (mapcat seq %&)))","user":"595eba88e4b066ee0a44b04e"},{"problem":69,"code":"(fn\n  [f init & maps]\n  (reduce\n    (fn [acc curr]\n      (merge acc\n             (into {} \n                   (map \n                     #(if (contains? acc (first %))\n                        (vector (first %) (f (get acc (first %)) (second %)))\n                        %) \n                     curr)))) init maps))","user":"5d1c14cde4b02ea6f0fb698a"},{"problem":69,"code":"(fn [f & ms]\n    (->> (map seq ms)\n         (apply concat)\n         (group-by first)\n         (map (fn [a] (let [k (first a) vs (map second (second a))] [k (if (> (count vs) 1) (reduce f vs) (first vs))])))\n         (into {})))","user":"5f5b624de4b05ea7b9adc42f"},{"problem":69,"code":"(fn [f m & more]\n        (reduce\n          (fn [init m]\n            (reduce-kv (fn [m k v]\n                         (assoc m k (if-let [mv (get m k)]\n                                      (f mv v)  v\n                                      ))) init m ))\n          m more))","user":"60836285e4b0736b099e42e4"},{"problem":69,"code":";; from the docs ^_^;;;\n(fn my-merge-with\n  [f & maps]\n  (when (some identity maps)\n    (let [merge-entry (fn [m e]\n\t\t\t(let [k (key e) v (val e)]\n\t\t\t  (if (contains? m k)\n\t\t\t    (assoc m k (f (get m k) v))\n\t\t\t    (assoc m k v))))\n          merge (fn [m1 m2]\n\t\t   (reduce merge-entry (or m1 {}) (seq m2)))]\n      (reduce merge maps))))\n\n;; daowen's solution looks pretty elegant\n;;(fn [f & ms]\n;;  (->> ms (apply concat) (group-by key)\n;;       (map (fn [[k vs]] [k (reduce f (map val vs))]))\n;;       (into {})))","user":"5fb68f09e4b08cb800c85b58"},{"problem":69,"code":"(fn merge-with-func ([fun & maps]\n  (if (nil? maps)\n    nil\n    (if(= 1 (count maps))\n      (first maps)\n      (let [reduce-func (fn [xs x] (let [val (if (nil? (get xs (first x)))\n                                             {(first x) (second x)}\n                                             {(first x) (fun (get xs (first x)) (second x))})]\n                                     (into xs val)))\n            merge-2-maps (fn [fun map1 map2] (reduce reduce-func map1 map2))\n            [map1 map2 & others] maps\n            map (merge-2-maps fun map1 map2)]\n          (recur fun (cons map others)))))))","user":"5df0c6ffe4b093ff717275c2"},{"problem":69,"code":"(fn [f & maps]\n    (->>\n      maps\n      (map seq)\n      (apply concat)\n      (group-by first)\n      (map (fn [[key values]] [key (->> (map second values) (reduce f))]))\n      (into {})))","user":"5901158de4b0438e51c2d039"},{"code":"(fn [f & ms] (letfn [\n(common-keys [m1 m2] (clojure.set/intersection (set (keys m1)) (set (keys m2))))\n(unique-keys [m1 m2] (clojure.set/difference (clojure.set/union (set (keys m1)) (set (keys m2))) (clojure.set/intersection (set (keys m1)) (set (keys m2)))))\n(merge-2-with-a-function [f m1 m2]\n\t(reduce #(assoc %1 %2 (f (get m1 %2) (get m2 %2))) (merge m1 m2) (common-keys m1 m2))\n)\n(merge-with-a-function [f & ms]\n\t(cond\n\t\t(empty? ms)\n\t\t{}\n\t\t:else\n\t\t(merge-2-with-a-function\n\t\t\tf\n\t\t\t(first ms)\n\t\t\t(apply merge-with-a-function f (rest ms))\n\t\t)\n\t)\n)\n] (apply merge-with-a-function f ms)))","problem":69,"user":"52f10094e4b05e3f0be25ee8"},{"problem":69,"code":"(fn mymerg([f a] a)\n([f a b](reduce (fn [m [k v]](assoc m k (if (m k) (f (m k) v) v))) a b))\n([f a b & c](reduce #(mymerg f %1 %2) (mymerg f a b) c)))","user":"5849ac5fe4b089d5ab817ed7"},{"problem":69,"code":"#(reduce\n  (partial reduce (fn [m [k v]]\n                    (assoc m k (if-let [v0 (m k)] (%1 v0 v) v))))           \n  %&)","user":"5e3e23d9e4b01d43a70e8e20"},{"problem":69,"code":"(fn [myfn & maps]\n  (->> (for [x maps y x] y)\n       (reduce (fn [acc pair] (assoc acc (first pair) (conj (acc (first pair) []) (second pair)))) {})\n       (map (fn [pair] {(first pair) (reduce myfn (second pair))}))\n       (apply merge)))","user":"60b2aaebe4b0e0fa5f1b4228"},{"code":"(fn [f & maps]\n  (reduce\n   (fn [sofar m]\n     (reduce\n      (fn [m' [k v]]\n        (assoc m' k\n          (if (contains? m' k)\n            (f (m' k) v)\n            v)))\n      sofar\n      m))\n   {}\n   maps))","problem":69,"user":"4ffc10aae4b0678c553fc3d6"},{"problem":69,"code":"(fn mw [f & maps]\n    (let [smooshf (fn [f m1 m2]\n                    (into m1 (for [[k v] m2] (if (contains? m1 k)\n                                               [k (f (get m1 k) v)]\n                                               [k v]))))]\n      (if (< (count maps) 2)\n        (first maps)\n        (let [merged (smooshf f (first maps) (second maps))]\n          (apply mw f (conj (rest (rest maps)) merged))))))","user":"54965534e4b0b312c081ff65"},{"code":"(fn [f & [init-m & ms]]\n  (reduce\n   (fn [acc [k v]]\n    (if (acc k)\n      (update-in acc [k] f v)\n      (assoc acc k v)))\n   init-m\n   (for [m ms kv m] kv)))","problem":69,"user":"51aa2b4fe4b04e3dc0c27b21"},{"code":"(fn [f & maps]\n  (reduce #(conj %\n                 (reduce (fn [r [k v]]\n                          (let [rv (get r k)] (assoc r k (if rv (f rv v) v)))) %1 %2))\n          maps))","problem":69,"user":"50705072e4b07bd6ad9b9f27"},{"problem":69,"code":"(fn [f & maps]\n   (into {} (map (fn [[k v]] [k (if (> (count v) 1)\n                                  (apply f (map second v))\n                                  (second (first v)))]) (group-by first (mapcat identity maps)))))","user":"5a250b86e4b07f18be40aa19"},{"problem":69,"code":"(fn map-murge\n  [fun & maps]\n  (reduce #(reduce (fn [result [key val]]\n                     (if (get result key)\n                       (assoc result key (fun (get result key) val))\n                       (assoc result key val))) %1 %2) {} maps))","user":"57d0cd58e4b0bd073c20235e"},{"problem":69,"code":"(fn g [f map1 & [map2 & rst]]\n    (if (nil? map2)\n      map1\n      (let [merged (->> (concat (keys map1) (keys map2))\n                        (map\n                          #(hash-map %\n                            (if (contains? map1 %)\n                              (if (contains? map2 %)\n                                (f (get map1 %) (get map2 %))\n                                (get map1 %))\n                              (get map2 %))))\n                        (apply merge))]\n        (apply g (concat [f merged] rst)))))","user":"5ab1665de4b073f1774425c0"},{"problem":69,"code":"(fn [op & args]\n  (reduce \n    (fn [a b]\n      (into (into a b) (for [[k v] a :let [u (b k)] :when u] [k (op v u)]))) \n          {} args))","user":"57b3efb1e4b0fbc9809a278a"},{"problem":69,"code":"(fn my-merge-with [merge-fn & maps]\n  (reduce (fn [result next]\n            (if (contains? result (first next))\n              (update-in result [(first next)] merge-fn (second next))\n              (assoc result (first next) (second next))\n              )\n            )\n          {} (mapcat seq maps)\n          )\n  )","user":"569f4dabe4b0542e1f8d1491"},{"code":"(fn f [o & m]\n  (if (= 1 (count m))\n    (first m)\n    (let [[a b & r] m]\n      (apply f o (merge a (into {} (map (fn [[k v]]\n                      (if (a k)\n                        [k (o (a k) v)]\n                        [k v]))\n                    b))) r))))","problem":69,"user":"52951156e4b02ebb4ef7501b"},{"code":"(fn [f m & ms]\n  (reduce (fn [res [k v]] (if (contains? res k)\n                              (assoc res k (f (res k) v))\n                              (assoc res k v)))\n          m (apply concat ms)))","problem":69,"user":"4ed94d69535d10e5ff6f5303"},{"problem":69,"code":"(fn mw [f & m]\n  (cond\n   (= 1 (count m)) (first m)\n   (= 2 (count m)) ((fn mw2 [g m1 m2 & [r]]\n                      (cond \n                       (empty? m1) (merge r m2)\n                       (empty? m2) (merge r m1)\n                       :else (let [k (first (keys m1))\n                                   v1 (get m1 k)\n                                   v2 (get m2 k)]\n                               (cond \n                                (nil? v2)(mw2 g (dissoc m1 k) m2 (assoc r k v1))\n                                :else (mw2 g (dissoc m1 k) (dissoc m2 k) (assoc r k (apply g (vector v1 v2))))))))\n                       f (first m) (last m))\n   :else (apply mw f (cons (mw f (first m)(first (rest m))) (rest (rest m))))))","user":"54d4bd2be4b0a52adc2e2005"},{"problem":69,"code":"(fn my-merge-with [f & colls]\n  (let [flat (mapcat seq colls)\n        grouped (group-by first flat)\n        result (into {} (for [[k v] grouped] [k (if (> (count v) 1)\n                                                  (apply f (map second v))\n                                                  (second (first v)))]))]\n    result))","user":"540e8d13e4b0addc1aec671e"},{"code":"(fn [f & maps]\n    (reduce (fn [acc m]\n        (merge acc (reduce (fn [sub [k v :as item]]\n            (if (acc k) (assoc sub k (f (acc k) v)) (conj sub item))) {} m))) {} maps))","problem":69,"user":"4f4ac35ae4b0d56e7bb92c18"},{"problem":69,"code":"(fn [func & maps]\n  (reduce (fn [ret m]\n            (reduce (fn [r [k v]]\n                      (if (contains? r k)\n                        (assoc r k (func (get r k) v))\n                        (assoc r k v)))\n                    ret\n                    m))\n          {} \n          maps))","user":"4f041de1535dcb61093f6ba5"},{"code":"(fn [f & maps]\n  (let [s (apply concat (map #(map identity %) maps))]\n    (reduce #(if (contains? %1 (first %2)) (assoc %1 (first %2) (f (get %1 (first %2)) (second %2))) (conj %1 %2)) {} s)))","problem":69,"user":"524b90fae4b09eba1c0223df"},{"code":"(fn my-merge-with [f a & maps]\n  (letfn [(merge-2-maps [m1 m2]\n            (reduce (fn [m [k v]]\n                      (if (contains? m k)\n                        (assoc m k (f (m k) v))\n                        (assoc m k v)))\n                    m1\n                    m2))]\n    (reduce (fn [a m]\n              (merge-2-maps a m))\n      a\n      maps)))","problem":69,"user":"50a7ef7fe4b090657f4a5ce0"},{"code":"(fn\n  [f & maps]\n  (reduce (fn [r m]\n            (reduce (fn [r2 [k v]]\n                      (assoc r2 k (if (contains? r2 k)\n                                    (f (get r2 k) v)\n                                    v)))\n                    r m)) {} maps))","problem":69,"user":"4e59b02c535d8a8b8723a2a2"},{"problem":69,"code":"(fn my-merge-with [f coll & maps]\n  (let [new-map (apply conj {} maps)]\n    (reduce\n     (fn reducer [acc value]\n       (let [curr-key (key value)\n             curr-val (val value)]\n         (if (contains? acc curr-key)\n           (assoc acc\n                  curr-key\n                  (f (get acc curr-key) curr-val))\n           (assoc acc\n                  curr-key\n                  curr-val))))\n     coll\n     new-map)))","user":"53350264e4b0656e627bfd73"},{"problem":69,"code":"(fn [f & ms]\n  (let [ks (distinct (mapcat keys ms))]\n    (into {} (map\n              (fn [k]\n                (->> ms\n                     (map #(% k))\n                     (remove nil?)\n                     (#(if (> (count %) 1) (apply f %) (first %)))\n                     (vector k)))\n              ks))))","user":"583e27e2e4b089d5ab817daa"},{"problem":69,"code":"(fn new-merge-with\n  [fun source & args]\n  (reduce (fn [amap bmap]\n            (reduce (fn [cmap [akey aval]]\n                      (let [existing (get cmap akey)]\n                        (if existing (assoc cmap akey (fun existing aval))\n                                     (assoc cmap akey aval))))\n                    amap bmap))\n          source args))","user":"550d9452e4b06e50f9beb15d"},{"code":"(fn ! [f & maps]\n  (loop [[h & t] maps]\n    (if (empty? t) h\n        (recur (cons (into {}\n                (for [e1 (distinct (concat (keys h) (keys (first t))))\n                      :let [m2 (first t)]]\n                  (cond\n                   (and (contains? m2 e1) (contains? h e1)) [e1 (f (get h e1) (get m2 e1))]\n                   (contains? m2 e1) [e1 (get m2 e1)]\n                   :else [e1 (get h e1)]))) (rest t))))))","problem":69,"user":"4e7d1c22535db169f9c796c5"},{"code":"(fn [f m1 & ms]\n  (letfn [\n    (mrg1 [f m1 m k]\n      (assoc m1 k (if (contains? m1 k) (f (m1 k) (m k)) (m k))))\n    (mrg-keys [f m1 m ks]\n      (if (empty? ks)\n        m1\n        (recur f (mrg1 f m1 m (first ks)) m (rest ks))))]\n    (if (empty? ms)\n      m1\n      (let [p (first ms)]\n      (recur f (mrg-keys f m1 p (keys p)) (rest ms))))))","problem":69,"user":"4e8f4f64535d65386fec2149"},{"problem":69,"code":"(fn my-merge-with [f & maps]\n(reduce\n (fn my-merge [m1 m2]\n (reduce (fn [acc [k v]] (assoc acc k (if (contains? acc k) (f (get acc k) v) v))) m1 m2))\n(first maps) (rest maps)\n)\n)","user":"592518cde4b072a2710fce66"},{"problem":69,"code":"(fn merge-with- [f & maps]\n  (reduce (fn [map m] (reduce-kv (fn [map k v]\n                                  (assoc map k\n                                         (if-let [ov (get map k)]\n                                           (f ov v)\n                                           v))) map m))\n          (first maps) (rest maps)))","user":"585dbe41e4b0f14aab7c879f"},{"problem":69,"code":"(fn [f & maps]\n    (let [claves-mapas (distinct (mapcat #(keys %) maps))\n          valores-clave (fn [clave] {clave (filter #(not (nil? %)) (map #(get % clave) maps))})\n          mapa-valores (reduce conj {} (map #(valores-clave %) claves-mapas))\n          aplica-funcion-valores (fn [f valores] (if (= (count valores) 1) (first valores) (reduce f valores)))]\n          (apply conj {} (for [[clave valores] mapa-valores] [clave (aplica-funcion-valores f valores)]))))","user":"5d0153f9e4b0cc9c915881aa"},{"code":"(fn mine\n  ([f x] x)\n  ([f x y]\n    (into x (for [[k v2] y]\n      [k (if-let [v (x k)] (f v v2) v2)])))\n  ([f x y & more]\n    (reduce (partial mine f) (mine f x y) more)))","problem":69,"user":"4dbad895535d1e037afb21ae"},{"code":"(fn [f & maps]\n  (let [ks (set (mapcat keys maps))]\n    (reduce (fn [m k]\n              (let [args (remove nil? (map #(% k) maps))]\n                (assoc m k (reduce f args))))\n            {} ks)))","problem":69,"user":"52479487e4b05ef8e38e6373"},{"problem":69,"code":"(letfn [(intersection-keys [map1 map2] (filter #(contains? map1 %) (keys map2)))\n        (modified-intersection [f map1 map2] (reduce #(assoc %1 %2 (f (get map1 %2) (get map2 %2))) {} (intersection-keys map1 map2)))\n        (merge-two [f map1 map2] (conj map1 map2 (modified-intersection f map1 map2)))]\n    (fn my-merge-with ([f & maps] (reduce #(merge-two f %1 %2) {} maps))))","user":"56491050e4b0284900eef639"},{"problem":69,"code":"(fn [f & args]\n  (let [a (->> (mapcat #(vec %) args)\n               (sort-by first)\n               (partition-by first))\n        b (map (fn [x] [(ffirst x) (map #(second %) x)]) a)]\n    (->> (map (fn [x] [(first x) (reduce f (second x))]) b)\n         (into (sorted-map)))))","user":"564d3169e4b0284900eef67c"},{"problem":69,"code":"(fn[f a & m]\n   (reduce-kv (fn [m k v]\n                (assoc m k (if (nil?(get m k)) \n                             v \n                             (f (get m k) v)))) \n              a (apply merge m)))","user":"5a6dbaf5e4b0512ff01cda63"},{"problem":69,"code":"(fn [f & ms]\n   (into {} (for [[k v]\n                  (group-by first\n                            (for [m ms [k v] m]\n                              [k v]))]\n              {k (reduce f (map second v))})))","user":"53c06438e4b0c98a41f5ccb0"},{"code":"(fn [f & args] \n  (reduce \n    (fn [acc, e] \n      (if (contains? acc (key e))\n        (merge acc {(key e) (f (acc (key e)) (val e)) })\n        (merge acc e)))\n    {} \n    (mapcat vec args)))","problem":69,"user":"504e1abee4b0f6ff3350c45d"},{"problem":69,"code":"(fn [f m & ms]\n  (reduce\n    (fn [a [k v]] (if (contains? a k) (update-in a [k] f v) (assoc a k v)))\n    m\n    (apply concat ms)))","user":"4fb1d7ace4b081705acca281"},{"problem":69,"code":"(fn [& args]\n  (let [f  (first args)\n        ks (keys (apply merge (rest args)))]\n    (reduce\n     (fn [m k]\n       (assoc m k\n              (if-let [xs (remove nil? (map #(get % k) (rest args)))]\n                (if (> (count xs) 1) (apply f xs) (first xs))))) {} ks)))","user":"5b72b36ce4b047b03b2036a9"},{"code":"(fn app-maps\n  [f m1 & maps]\n  (if (empty? maps) m1 \n    (let [m2 (first maps)\n          m1-keys (set (keys m1))\n          m2-keys (set (keys m2))\n          both (clojure.set/intersection m1-keys m2-keys)\n          m1-only (into {} (filter #(not (contains? both %)) m1))\n          solos (into m1-only (filter #(not (contains? both %)) m2))\n          m (into solos\n            (for [k both]\n              {k (f (get m1 k) (get m2 k))}))]\n    (recur f m (rest maps)))))","problem":69,"user":"5273e006e4b03e8d9a4a7495"},{"code":"(fn [f & xs]\n  (into {} (let [ks (reduce (fn [acc x] (into acc (keys x))) #{} xs)\n      go (fn [k]\n                                              (let [ans (reduce (fn [acc x] (if-let [v (x k)]\n                                                                                                               (conj acc v)\n                                                                                                               acc)) [] xs)]\n                                                                       (if (= 1 (count ans))\n                                                                                           (first ans)\n                                                                                           (apply f ans))))]\n                          (map (fn [x] [x (go x)]) ks))))","problem":69,"user":"4e7f5a0b535db966e863cc41"},{"problem":69,"code":"(fn mym\n  ([f lm rm]\n   (let [left (for [k (keys lm)] (if (contains? rm k) {k (f (lm k) (rm k))} {k (lm k)}))\n         right (for [k (keys rm)] (if (not (contains? lm k)) {k (rm k)} {}))]\n     (apply conj (concat left right))))\n  ([f lm rm & ms]\n   (reduce #(mym f % %2) (mym f lm rm) ms)))","user":"536673a8e4b0243289761e76"},{"problem":69,"code":"(fn my-merge\n  [func fst & maps]\n  (letfn [(reduce-fn [res nxt]\n            (reduce (fn [r [k v]] (if (contains? r k)\n                       (assoc r k (func (r k) v))\n                       (assoc r k v))) res nxt))]\n    (reduce reduce-fn fst maps)))","user":"5271605ae4b03e8d9a4a73ed"},{"problem":69,"code":"(fn [f & maps]\n  (let [m (fn [m1 m2]\n            (loop [a m1\n                   s (seq m2)]\n              (if s\n                (let [[k v] (first s)\n                      m3 (assoc a k (if (a k) (f (a k) v) v))]\n                  (recur m3 (next s)))\n                a)))]\n    (reduce m maps)))","user":"52d9ba39e4b09f7907dd13af"},{"problem":69,"code":"(fn [f & m]\n  (let [g (fn [m r]\n            (let [k (key r) v (val r)]\n              (if (contains? m k)\n                (assoc m k (f (get m k) v))\n                (assoc m k v))))\n        h (fn [m n]\n            (reduce g m n))]\n    (reduce h m)))","user":"52e1c276e4b09f7907dd142b"},{"code":"(fn [f & maps]\n   (let [ks (keys (apply merge maps))]\n     (reduce (fn [res k] (conj res {k  (let [v (filter (comp not nil?) (map #(get % k)  maps))]\n                                         (cond (= (count v) 1) (let [[thev] v] thev)\n                                               :else (apply f v)\n                                               )\n                                             \n                                             )})) {} ks)))","problem":69,"user":"52be0263e4b07a9af579230e"},{"code":"(fn mergeFun [f & params]\r\n  (loop [cols params ,result {}]\r\n    (if (empty? cols)\r\n         result\r\n        (recur (rest cols)\r\n               (let[vals (first cols),\r\n                    ks (keys vals)]\r\n               (reduce \r\n                (fn comput[r k] \r\n                   (let [val (get vals k),orgVal (get r k)]\r\n                      (if (nil? orgVal)\r\n                          (assoc r k val)\r\n                          (assoc r k (f orgVal val) )                          \r\n                      )\r\n                    ) \r\n                  )\r\n                  result \r\n                  ks\r\n                )\r\n              )\r\n         )\r\n      )\r\n    )\r\n  )","problem":69,"user":"4f6d9d7ee4b07046d9f4efcd"},{"problem":69,"code":"(fn my-merge-with [f & [m & ms]]\n    (letfn [(merge-one [acc [k v]]\n              (assoc acc k\n                     (if (contains? acc k)\n                       (f (get acc k) v)\n                       v)))]\n      (reduce #(reduce merge-one %1 %2) m ms)))","user":"4dfe5a93535d04ed9115e786"},{"code":"(fn [f & maps]\n  (reduce\n   (fn [result map-item]\n     (into result\n           (reduce\n            (fn [new-map new-key]\n              (conj new-map\n                    (vec (list new-key\n                          (if (not (nil? (result new-key)))\n                            (f (result new-key) (map-item new-key))\n                            (map-item new-key))))))\n            {}\n            (keys map-item))))\n   {}\n   maps))","problem":69,"user":"4f31519ae4b0d6649770a086"},{"code":"(fn [f & maps]\n  (reduce (fn [m1 m2]\n            (reduce #(if-let [v1 (% %2)]\n                       (assoc % %2 (f v1 (m2 %2)))\n                       (assoc % %2 (m2 %2))) m1 (keys m2))) maps))","problem":69,"user":"524b0645e4b09eba1c0223bf"},{"problem":69,"code":"(fn [f & args]\n    (loop [hmaps args\n           out-map {}]\n      (if-let [hmap (first hmaps)]\n        (recur\n          (rest hmaps)\n          (merge\n            out-map\n            (into {} (for [[k v] hmap]\n                       (if-let [prev-v (get out-map k)]\n                         [k (f prev-v v)]\n                         [k v])))))\n        out-map)))","user":"53716539e4b0fc7073fd6eb1"},{"code":"(fn [f m1 & ms]\n  (let [m2 (apply merge ms)]\n    (merge m2 (into {} (map #(vector (key %) (f (val %) (m2 (key %)))) m1)))))","problem":69,"user":"5267d9bde4b03e8d9a4a7188"},{"problem":69,"code":"(fn [f & ms]\n  (->> (mapcat #(vec %) ms)\n    (reduce (fn [acc [k v]]\n              (if (contains? acc k)\n                (assoc acc k (f (get acc k) v))\n                (assoc acc k v)))\n            {})))","user":"5573ffb5e4b0aa18f790f3fd"},{"code":"(fn [f v1 & vs]\n  (let [v2 (apply conj {} vs)]\n  (let [k1 (apply hash-set (keys v1)) k2 (apply hash-set (keys v2))]\n    (conj \n     (reduce #(assoc %1 %2 (f (v1 %2) (v2 %2))) {} (clojure.set/intersection k1 k2))\n     (reduce #(assoc %1 %2 (v1 %2)) {} (clojure.set/difference k1 k2))\n     (reduce #(assoc %1 %2 (v2 %2)) {} (clojure.set/difference k2 k1))))))","problem":69,"user":"51780f88e4b03d69594194c9"},{"code":"(fn my-merge-with [f init & xs]\r\n  (reduce #(assoc %1 (first %2) (if (%1 (first %2)) (f (%1 (first %2)) (second %2)) (second %2))) init (mapcat seq xs)))","problem":69,"user":"4f251302e4b0d66497709ff0"},{"code":"(fn mergewith [f & xs]\n  (reduce #(reduce\n            (fn [m [k v]]\n              (if (contains? m k)\n                 (assoc m k (f (get m k) v))\n                 (assoc m k v)))\n            % \n            (seq %2))\n          xs))","problem":69,"user":"51805d22e4b0e3fc13e244df"},{"code":"(fn my-merge [f & ms]\n   (letfn [(merger [[f m1] m2]\n             (let [intr (clojure.set/intersection (set (keys m2)) (set (keys m1)))\n                   merged (merge m2 m1)\n                   fixed\n                   (apply merge {}\n                          (for [k intr]\n                            {k (f (m1 k) (m2 k))}))]\n               [f (merge merged fixed)]))]\n           (if (empty? ms) {}\n               (second\n                (reduce merger [f (first ms)] (rest ms))))))","problem":69,"user":"529ce629e4b04e0c58e87b6e"},{"code":"(fn [o m & s]\n  (into m \n    (for [x s [k v] x] [k (if (m k) (o (m k) v) v)])))","problem":69,"user":"4f956072e4b0dcca54ed6ccf"},{"problem":69,"code":"(fn [f m & ms] \n  (reduce \n    #(loop [fm % om %2] \n      (if (empty? om) \n        fm \n        (recur \n          (update-in fm [(key (first om))] (fn [v] (if (nil? v) (val (first om)) (f v (val (first om))))))\n          (rest om)\n        )\n      )\n    ) \n    m ms\n  )\n)","user":"59c734e3e4b0a024fb6ae53f"},{"problem":69,"code":"(fn [a & b]\n   (let [c (->> b\n              (apply concat)\n              (group-by key))\n         f #(if (and (not (coll? %)) (> 0 %)) (* -1 %) %)\n         d (->> (map val c)\n                (map #(map last %))\n                (map #(apply a %)))]\n     (zipmap (keys c) (map f d))))","user":"55630cc1e4b0c656e3ff17e0"},{"problem":69,"code":"(fn [f & cols] \n  (reduce (fn [result [k v]] (assoc result k (if (> (count v) 1) (apply f v) (first v)) ))\n    {}\n    (reduce \n     (fn [a b] \n       (#(reduce \n           (fn [result [k v]] \n             (assoc result k \n               (conj (or (result k) []) v))) %1 %2) \n         a b))\n     {} cols)))","user":"567798afe4b05957ce8c6169"},{"code":"(fn merge [f & xs]\n  (reduce\n   (fn [x y]\n       (reduce (fn [x' [k v]]\n          (assoc x' k (if (x' k) (f v (x' k)) v)))\n           y x))\n   (first xs) (rest xs)))","problem":69,"user":"531c0619e4b08068f379ed98"},{"code":"(fn merge-by [f & maps]\n  (reduce\n   (fn [acc maps]\n     (reduce-kv\n      (fn [m k v]\n        (assoc m k\n          (if (contains? m k)\n            (f (m k) v) v)))\n      acc maps))\n   {} maps))","problem":69,"user":"532ab0bde4b09d4e7a9b5527"},{"code":"(fn [f & maps] (reduce #(reduce (fn [r [k v]]\n                                   (if-let [v2 (r k)]\n                                     (assoc r k (f v v2))\n                                     (assoc r k v)))\n                                 %2\n                                 %)\n                        maps))","problem":69,"user":"4ee88bfb535d93acb0a66881"},{"code":"(fn [f m & ms]\n  (loop [m m ms ms]\n    (if (= () ms)\n      m\n      (let [r (first ms)]\n        (recur\n          (reduce \n            (fn [m rk]\n              (if (nil? (m rk))\n                (assoc m rk (r rk))\n                (assoc m rk (f (m rk) (r rk)))))\n            m\n            (keys r))\n          (rest ms))))))","problem":69,"user":"50435852e4b034ff00315d22"},{"problem":69,"code":"(fn my-merg [f & maps]\n  (reduce \n    (fn my-me [m1 m2]\n            ( reduce (fn [acc [k v]] (assoc acc k (if  (contains? acc k) (f (get acc k) v) v ))) m1 m2))\n    (first maps) (rest maps)))","user":"5f27f180e4b033932238a648"},{"problem":69,"code":"#(reduce (fn [m [f l]] (assoc m f (if (m f) (% (m f) l) l))) {} (mapcat seq  %&))","user":"5c379636e4b0d62ef62d9f76"},{"problem":69,"code":"(fn\n  [f & maps] \n  (let [grouped-map (reduce (fn [res cur] \n            (reduce #(assoc %1 (key %2) (conj (%1 (key %2)) (val %2))) \n                    res cur)) \n          {} (reverse maps))] \n    (zipmap (keys grouped-map) (map #(reduce f (val %)) grouped-map))))","user":"563b5dc9e4b0bfe05bf1180f"},{"problem":69,"code":"(fn [f m & ms]\n   (loop [ms ms result m]\n     (if (empty? ms)\n       result\n       (recur (next ms)\n              (reduce (fn [r [a b]]\n                         (if (contains? r a)\n                           (update-in r [a] f b)\n                           (assoc r a b))) \n                       result (first ms))))))","user":"55db7e15e4b0e31453f64ae8"},{"problem":69,"code":"(fn [f m & ms]\n    (loop [m m\n           ms ms]\n      (let [fst (first ms)]\n        (if-not\n            (seq fst) m\n            (recur\n             (into m (map (fn [[k v]]\n                            [k\n                             (if (contains? m k)\n                               (f (get m k) v)\n                               v)]) fst))\n             (rest ms))))))","user":"5d236215e4b02ea6f0fb6a09"},{"code":"(fn\n [f & maps]\n (into\n  {}\n  (for \n    [[k vs]\n    (reduce\n     (fn [m s]\n      (reduce\n       (fn [ma itm]\n        (assoc\n         ma\n         (first itm)\n         (concat (ma (first itm)) [(second itm)])))\n       m s))\n     {} (map (partial into []) maps))]\n   [k (reduce f vs)])))","problem":69,"user":"521e8227e4b0dd19981ad082"},{"problem":69,"code":";merge-f [m1 m2 f] takes two maps and a function f, \n;merge m1 with m2, if key duplicates, merge with f.\n;then use another outer reduce to loop \n\n(fn my-merge-with [f & maps]\n  (reduce (fn [m1 m2] ((fn merge-f [m m2 f]\n  (reduce #(if (%1 (first %2))\n             (update-in %1 [(first %2)] f (second %2) )\n             (conj %1 %2)) m m2)) m1 m2 f)) maps))","user":"558bdcefe4b0277789237633"},{"problem":69,"code":"(fn [f & mps]\n  (reduce (fn [acc m] (merge acc (into {} (map (fn [[k v]] (if-let  [ak (get acc k)] {k (f ak v)} {k v})) m)))) mps))","user":"5ecc0831e4b016b56eae058c"},{"code":"(fn [f & m]\n  (into {}\n        (for [[k V] (group-by first (mapcat seq m))]\n          [k (reduce f (map second V))])))","problem":69,"user":"4e7dfab0535db169f9c796f9"},{"problem":69,"code":"(fn [f & maps]\n  (loop [mps maps\n         r {}]\n    (let [curr (first mps)\n          comm (clojure.set/intersection (set (keys r)) (set (keys curr)))\n          df (clojure.set/difference (set (keys curr)) (set (keys r)))\n          r (merge r (select-keys curr df))\n          r (merge r \n                   (into {} (map (fn [[k v]] (vec [k (f (r k) v)]) )\n                         \t\t\t(select-keys curr comm))))]\n                   \n        (if-not (empty? (rest mps))\n            (recur (rest mps) r)\n          r)\n      )\n  )\n)","user":"54c779bee4b045293a27f63b"},{"problem":69,"code":"(fn [f & maps]\n(reduce \n(fn [bmap cmap]\n\t\t\t(reduce (fn [bbmap kv]\n\t\t\t\t\t\t(let [[k v] kv]\n\t\t\t\t\t\t\t\t(if (contains? bbmap k)\n\t\t\t\t\t\t\t\t\t\t(into bbmap [[k (f (get bbmap k) v)]])\n\t\t\t\t\t\t\t\t\t\t(into bbmap [[k v]])))) bmap cmap))\n(first maps) (rest maps)))","user":"565b941ce4b068f2fe63dc07"},{"problem":69,"code":"(fn [f & ms]\n  (->> ms\n       (mapcat keys)\n       (map (fn [k] [k (reduce f (keep #(% k) ms))]))\n       (into {})))","user":"5d27da09e4b092dab7f59c75"},{"code":"(fn [f M & ms]\n  (reduce\n   #(reduce\n     (fn [m [k v]]\n       (assoc m k\n         (if (m k)\n           (f (m k) v)\n           v)))\n     %1 %2)\n   M ms))","problem":69,"user":"5107b86de4b05b2b4eee7495"},{"problem":69,"code":"(fn [f & maps]\n  (loop [ks (distinct (flatten (map keys maps))) acc {}]\n    (if (empty? ks)\n      acc\n      (let [curr-key (first ks) vs (map #(get % curr-key) maps) values (filter #(not (nil? %)) vs)]\n        (if (= (count values) 1)\n          (recur (rest ks) (assoc acc curr-key (first values)))\n          (recur (rest ks) (assoc acc curr-key (reduce f values))))))))","user":"55afc197e4b002ce9d5cbc18"},{"code":"(fn [f & maps]\n  (apply merge (for [x (keys (apply merge maps))]\n    (hash-map x (reduce f (remove nil? (for [m maps]\n      (m x))))))))","problem":69,"user":"4dd9d299535d2dad7130b5dd"},{"code":"(fn [f & maps]\n  (reduce (fn [acc e]\n            (into acc (for [[k v] e]\n                        (if (contains? acc k)\n                          [k (f (get acc k) v)]\n                          [k v]))))\n          maps))","problem":69,"user":"4ef77edb535dced4c769f254"},{"problem":69,"code":";(fn [f & maps]\n;  (reduce (fn [r x]\n;            (reduce (fn [m [k v]]\n;                      (assoc m k (if (m k) (f (m k) v) v)))\n;                    r\n;                    x))\n;          maps))\n\n(fn [f & maps]\n  (->> (apply concat maps)\n       (group-by first)\n       (map (fn [[k xs]] [k (reduce f (map second xs))]))\n       (into {})))","user":"54485749e4b032a45b8693c7"},{"problem":69,"code":"(fn merge-maps-with\n  [func & [head secnd & tail]]\n  (letfn [(merge-two\n             [func first-map next-map]\n               (reduce\n                  (fn [acc entry]\n                    (if-let [found-val (get acc (first entry))]\n                      (assoc acc (first entry) (func found-val (second entry) ))\n                      (conj acc entry)))\n                  first-map next-map))]\n  (if (nil? secnd)\n    head\n    (recur func (cons (merge-two func head secnd) tail)))))\n\n;; my second version dropping recursiveness for a more maybe :) elegant approach: use core reduce to nest 2 levels\n#_(fn merge-maps-with\n  [func & maps]\n  (reduce \n     (fn [outer-acc each-map]\n       (reduce \n          (fn [outer-acc map-entry] \n            (if-let [found-val (get outer-acc (first map-entry))]\n               (assoc outer-acc (first map-entry) (func found-val (second map-entry)))   ;; found -> merge-with\n               (conj outer-acc map-entry)))                                                                         ;; new entry -> just conj'\n          outer-acc  each-map))\n     {} maps))","user":"5553b729e4b0deb715856e05"},{"problem":69,"code":"(fn mrg [f & maps]\n   (reduce (fn g [a b]\n             (reduce (fn [res [k v]]\n                       (if-let\n                         [z (get res k)]\n                         (assoc res k (f z v))\n                         (assoc res k v))) a b))\n           maps))","user":"57fc5e42e4b0d3187e900997"},{"code":"(fn mwf\n  ([f m] m)\n  ([f m m2]      (reduce (fn [a [k v]] (assoc a k (if (contains? m k) (f (m k) (m2 k)) (m2 k))))  m   m2))\n  ([f m m2 & ms] (apply mwf (cons f (cons (mwf f m m2) ms)))))","problem":69,"user":"530bf87ee4b02e82168697d5"},{"code":"(fn mrg [f m & more]\n  (reduce (fn [r [k v]]\n          (merge r (if (contains? r k)\n                       {k (f (r k) v)}\n                       {k v})))\n         m (mapcat list* more)))","problem":69,"user":"4faac363e4b081705acca200"},{"code":"#(reduce (fn [a [k v]]\n           (assoc a k (if-let [w (get a k)] (% w v) v)))\n         %2\n         (mapcat vec %&))","problem":69,"user":"522b922ee4b0d34ee08e71c3"},{"code":"(fn mergef [f base & more]\n  (let [merge-in (fn [b coll]\n                   (reduce (fn [acc [k v]] (if (contains? acc k) (update-in acc [k] f v) (conj acc [k v]))) b coll))]\n    (reduce merge-in base more)))","problem":69,"user":"5003deb9e4b0678c553fc445"},{"problem":69,"code":"(fn nice [f startm & startmaps]\n  (loop [m startm, maps startmaps]\n   (if (empty? maps)\n    m\n    (recur (reduce (fn [nm [k v]] (assoc nm k (if (nm k) (f (nm k) v) v))) m (first maps)) (rest maps)))))","user":"5ab5f60be4b073f177442643"},{"problem":69,"code":"(letfn [(update [m k f]\n            ; update was added in 1.7. 4clojure is 1.4\n            (assoc m k (f (get m k))))\n          (munge [f m1 [[k v] & t :as m2s]]\n            (if m2s\n                (recur f (update m1 k #(if (nil? %) v (f % v)) ) t)\n              m1))]\n    (fn [f m & [h & t :as more]]\n      (if more\n        (recur f (munge f m (seq h)) t)\n        m)))","user":"58ec1e63e4b056aecfd47d54"},{"code":"(fn [f & m] \n           (reduce #(loop [k (keys %2) res %1]\n                        (if (empty? k)\n                            res\n                            (let [k1 (first k)]\n                                 (recur (rest k) (assoc res k1 (if (%1 k1) (f (%1 k1) (%2 k1)) (%2 k1))))))) m))","problem":69,"user":"4f34eb87e4b0e243712b1eba"},{"problem":69,"code":"(fn [f & ms] (reduce (fn [res m] (reduce #(if (contains? %1 (key %2))\n                                                 (update-in %1 [(key %2)] (fn [old] (f old (val %2)) )  )\n                                                 (assoc %1 (key %2) (val %2))) res m)) {} ms))","user":"56a6051fe4b0542e1f8d14e5"},{"code":"(fn\n  [f & [m & r]]\n  (reduce\n    #(reduce\n       (fn [m [k v]]\n         (if (contains? m k)\n           (update-in m [k] f v)\n           (conj m [k v])))\n       % %2)\n    m r))","problem":69,"user":"4f410b63e4b0e243712b1fc5"},{"problem":69,"code":"(fn my-merge-with [f & maps]\n  (letfn [(merge-maps [m1 m2]\n                      (println m1)\n                      (println m2)\n                      (merge m1 (apply hash-map (mapcat \n                                                 (fn [[k v]]\n                                                   (if (nil? (get m1 k))\n                                                     [k v] \n                                                     [k (f (get m1 k) v)])) m2))))]          \n    (loop [curr-map (first maps)\n           rest-maps (rest maps)\n           result {}]\n      (println result)\n      (if (empty? rest-maps)\n        (merge-maps result curr-map)\n        (recur (first rest-maps) (rest rest-maps) (merge-maps result curr-map))))))","user":"53791ab7e4b06839e8705e4d"},{"code":"(fn merge-with-function [f & ms]\n  (letfn [(group [m [k v]]\n            (assoc m k (conj (m k []) v)))]\n    (->> ms\n         (apply concat)\n         (reduce group {})\n         (map #(vector (first %) (reduce f (second %))))\n         (into {}))))","problem":69,"user":"4f3fb586e4b0e243712b1f9c"},{"code":"(fn [f m & ms]\n (reduce #(if (find %1 (key %2))\n            (update-in %1 [(key %2)] f (val %2))\n            (assoc-in %1 [(key %2)] (val %2)))\n         m\n         (apply merge ms)))","problem":69,"user":"4f9f7daae4b0dcca54ed6d37"},{"problem":69,"code":"(fn my-merge-with [f & args]\n  (let [ks (keys (apply merge args))\n        merged-array (keep identity (for [k ks m args] (when (m k) [k (m k)])))]\n    (reduce (fn [acc [k v]]\n              (if (contains? acc k)\n                (assoc acc k (f (acc k) v))\n                (assoc acc k v)))\n            {}\n            merged-array)))","user":"5657fed1e4b0f9d632dd84ae"},{"problem":69,"code":"(fn mw [f ma & [mb & rrm :as rm]]\n  (reduce \n   (fn [r [k v]] \n     (assoc r k (if (contains? r k) (f v (r k)) v))) \n   (if (empty? rrm) mb (apply mw f rm))\n   ma))","user":"55c0afa5e4b01b9910ae2a27"},{"code":"(fn f ([g x] x) ([g a b & m]\r\n (apply f g\r\n(reduce (fn [c [k v]]\r\n(assoc c k (if (c k) (g (c k) v) v))) a b)\r\nm)))","problem":69,"user":"4db858d1535d1e037afb218c"},{"code":"(fn mw [f & maps]\n    (into \n     {} \n     (let [ks (into #{} (mapcat keys maps))]\n      (for [k ks \n            :let [y (reduce\n                     f\n                     (filter #(not= % :non-item) (map #(get % k :non-item) maps)))]] [k y]))))","problem":69,"user":"534941d1e4b084c2834f4a60"},{"code":"(fn g [f & [a & b]]\n  (if b\n    (apply g f\n      (reduce \n         (fn [m [k v]]\n           (assoc m k (if (m k) (f (m k) v) v)))\n         a \n         (first b))\n         (rest b))\n    a))","problem":69,"user":"4ea09fa4535d7eef308072aa"},{"problem":69,"code":"(fn [f & r] (into {} (map (fn [x] [(first x) (reduce  f (map second (second x)))] ) \n     (group-by first (reduce concat (map #(map identity %) r))))))","user":"531bfb69e4b08068f379ed97"},{"code":"(fn m-w [f & maps]\n   (let [distinct-keys (->> maps (map #(keys %)) (flatten) (distinct))]\n     (let [values (->> distinct-keys\n                       (map (fn [k] (map #(% k) maps)))\n                       (map (fn [xs] (filter #(not (nil? %)) xs)))\n                       (map #(if (< (count %) 2)\n                                  (first %)\n                                  (apply f %))))]\n       (apply hash-map (interleave distinct-keys values)))))","problem":69,"user":"529e3a4fe4b04e0c58e87b92"},{"problem":69,"code":"(fn my-merge\n    [f & maps]\n    (when (some identity maps)\n      (let [merge-entry (fn [m e]\n                          (let [k (key e) v (val e)]\n                            (if (contains? m k)\n                              (assoc m k (f (get m k) v))\n                              (assoc m k v))))\n            merge2 (fn [m1 m2]\n                     (reduce merge-entry (or m1 {}) (seq m2)))]\n        (reduce merge2 maps))))","user":"55e6c3f5e4b050e68259b48c"},{"problem":69,"code":"(fn m-m-w [f & maps]\n  (apply hash-map (apply concat (let [new-keys (->>\n                  maps\n                  (map keys)\n                  (flatten)\n                  (distinct))]\n    (map (fn [k]\n           (let [vals (filter (complement nil?) (map #(get % k) maps))]\n             (if (= (count vals) 1)\n               (vector k (first vals))\n               (vector k (apply f vals)))))\n         new-keys)))))","user":"56504dc2e4b0284900eef6bc"},{"problem":69,"code":"(fn merge-with1 [f & hmaps]\n  (let [m-ref (atom {})]\n    (doseq [hmap hmaps\n            [k v] hmap]\n      (if (get @m-ref k)\n        (swap! m-ref update-in [k] #(f % v))\n        (swap! m-ref assoc-in [k] v)))\n    @m-ref))","user":"5fa74b82e4b0fa27300f3dda"},{"problem":69,"code":"(fn mergewith\n\t; base case: single map\n\t([f m] m)\n\n\t; two or more maps\n\t([f m1 m2 & maps]\n\t\t(if (empty? m2)\n\t\t\t; if m2 is empty: proceed with the rest\n\t\t\t(apply mergewith f m1 maps)\n\t\t\t; if m2 is not empty: insert the first and recurse\n\t\t\t(apply mergewith\n\t\t\t\tf\n\t\t\t\t(let [k (key (first m2)) v (val (first m2))]\n\t\t\t\t\t(if (contains? m1 k)\n\t\t\t\t\t\t; already present: merge\n\t\t\t\t\t\t(assoc m1 k (f (get m1 k) v))\n\t\t\t\t\t\t; not present: just insert\n\t\t\t\t\t\t(assoc m1 k v)\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t\t(rest m2)\n\t\t\t\tmaps\n\t\t\t)\n\t\t)\n\t)\n)","user":"5f574662e4b0a0bc16850a90"},{"problem":69,"code":"(fn [f & s] (apply hash-map (interleave (keys (apply conj (seq s))) (map #(reduce f %) (map #(filter (comp not nil?) %) (map #(map (fn [m] (get m %)) (seq s)) (keys (apply conj (seq s)))))))))","user":"56ab7578e4b03c432f18733d"},{"code":"(fn \n [f & maps]\n  (reduce \n    (fn [targetM, thisM]\n      (let [tar targetM this (vec thisM) k (ffirst thisM) v (second (first thisM))]\n        (if (= (count thisM) 0)\n          tar\n          (if (contains? tar k)\n              (recur (assoc tar k (f (tar k) v)) (next this))\n              (recur (assoc tar k v) (next this))\n            \n          )\n        )\n      )\n    )\n    {}\n    maps\n  )\n)","problem":69,"user":"52485723e4b05ef8e38e63d2"},{"problem":69,"code":"(fn [f & ms]\n  (reduce \n   (fn [agg1 itm1]\n     (reduce\n      (fn [agg2 [k v]]\n        (conj\n         agg2\n         (if (contains? agg2 k) \n           [k (f (agg2 k) v)]\n           [k v]))) \n      agg1 itm1)) \n   (first ms) (rest ms)))","user":"604d3cb1e4b0b7ec0ac60ac2"},{"code":"(fn [op m & maps]\n  (letfn [(merge-key \n            ([r in]\n              (reduce (fn [a [k v]] (merge-key a k v)) r (seq in)))\n            ([r k v]\n               (assoc r k (if (r k)\n                            (op (r k) v)\n                            v))))]\n (reduce #(merge-key %1 %2) m maps)))","problem":69,"user":"4e68b46c535d8ccf87e9fe87"},{"problem":69,"code":"(fn my-merge-with [f & maps]\n  (reduce\n   (fn [mm nm]\n       (reduce-kv\n        (fn [m k v]\n          (if (m k)\n            (update-in m [k] f v)\n            (assoc m k v)))\n        mm nm))\n   {} maps))","user":"55c66ffee4b0e31453f649c2"},{"code":"(fn [f & m]\r\n  (let [m-w (fn m-w [f m1 m2]\r\n               (if (empty? m2) m1\r\n                  (m-w f \r\n                       (if (contains? m1 (first (first m2)))\r\n                         (assoc m1 (first (first m2))\r\n                                (f (get m1 (first (first m2))) (second (first m2))))\r\n                         (conj m1 (first m2)))\r\n                       (rest m2))) )]\r\n    (reduce (partial m-w f) m)))","problem":69,"user":"4e14108c535d04ed9115e7dd"},{"code":"(fn [f c & cs]\n  (reduce (fn [xs ys]\n  \t\t\t\t\t(reduce (fn [coll entry]\n            \t(let \n              \t[k (key entry)\n               \tv (val entry)]\n              \t(if (contains? coll k)\n                \t(assoc coll k (f (coll k) v))\n                \t(assoc coll k v)))) xs ys))\n          c cs))","problem":69,"user":"50217818e4b00bba4502f7a7"},{"code":"(fn my-merge-with [f & maps]\n  (reduce (fn [m1 m2]\n            (reduce (fn [m [key val]]\n                      (assoc m key (if (contains? m1 key)\n                                     (f (m1 key) val)\n                                     val)))\n                    m1\n                    m2))\n          (first maps)\n          (rest maps)))","problem":69,"user":"50812debe4b01a93d3f38e4c"},{"problem":69,"code":"(fn [f & maps]\n              (reduce (fn [acc m]\n                        (reduce (fn [a [k v]]\n                                  (assoc a k (if-let [av (get a k)] (f av v) v)))\n                                acc m))\n                      {} maps))","user":"4f9aa2a6e4b0dcca54ed6d0c"},{"code":"(fn [f & hmaps]\n  (into {} (map (fn [[k v]] [k (reduce f v)])\n                (map (fn [[k vecs]] [k (map (fn [v] (get v 1)) vecs)])\n                     (group-by (fn [[k v]] k) (apply concat hmaps))))))","problem":69,"user":"5225271fe4b01819a2de42f9"},{"problem":69,"code":"(fn [f & ms]\n   (letfn [(mergew [f a b] (reduce (fn [acc [k v]] (if (contains? acc k)\n                                                     (assoc acc k (f (get acc k) v))\n                                                     (assoc acc k v))) a b))]\n     (reduce #(mergew f %1 %2) ms)))","user":"5d764e52e4b02e6b30c93524"},{"problem":69,"code":"(fn [f m & ms]\n  (into {} \n        (for [e ms [k v] e]\n          (if (contains? m k) [k (f (m k) v)] [k v]))))","user":"56ae214ce4b03c432f18735a"},{"code":"(fn [f & maps]\n  (letfn [(x [a b]\n             (let [[k v] b]\n               (if (contains? a k)\n                 (assoc a k (f (a k) v))\n                 (assoc a k v))))]\n    (reduce #(reduce x (or %1 {}) %2) maps)))","problem":69,"user":"531d34cfe4b08068f379edac"},{"problem":69,"code":"(fn [f & maps]\n   (reduce (partial (fn [f c1 c2]\n                      (reduce #(cond (not (nil? (%1 (key %2)))) (into %1 {(key %2) (f (%1 (key %2)) (val %2))})\n                                     :else (into %1 {(key %2) (val %2)}))\n                              c1 c2)) f) (into {} (first maps)) (rest maps)))","user":"52fac708e4b047fd55836fff"},{"problem":69,"code":"(fn merge-with-function [f & maps]\n  (reduce (fn [ms m]\n            (apply merge ms\n                   (reduce (fn [es e]\n                             (let [k (key e)\n                                   v (val e)]\n                               (if (contains? ms k)\n                                 (assoc es k (f (get ms k) v))\n                                 (assoc es k v)))) {} m))) {} maps))","user":"5693a53ee4b0dcc4269f4106"},{"problem":69,"code":"(fn my-merge-with [f & ms]\n  (reduce (fn [m1 m2]\n            (let [common-keys (clojure.set/intersection (set (keys m1))\n                                                        (set (keys m2)))]\n              (->> common-keys\n                   (map (fn [k] (f (get m1 k) (get m2 k))))\n                   (interleave common-keys)\n                   (apply hash-map)\n                   (into (into m1 m2))))) \n          ms))","user":"557e56aae4b05c286339e0d5"},{"problem":69,"code":"(fn mf\n  ([f x y]\n   (reduce (fn [r e]\n             (let [k  (first e)\n                   v (r k)]\n               (if v\n                 (conj r [k (f v (second e))])\n                 (conj r [k (second e)]))))\n           x y))\n  ([f x y & args]\n   (reduce (partial mf f) (mf f x y) args)))\n\t\t\t\n;(defn merge-with\n;  \"Returns a map that consists of the rest of the maps conj-ed onto\n;  the first.  If a key occurs in more than one map, the mapping(s)\n;  from the latter (left-to-right) will be combined with the mapping in\n;  the result by calling (f val-in-result val-in-latter).\"\n;  {:added \"1.0\"\n;   :static true}\n;  [f & maps]\n;  (when (some identity maps)\n;    (let [merge-entry (fn [m e]\n;                        (let [k (key e) v (val e)]\n;                          (if (contains? m k)\n;                            (assoc m k (f (get m k) v))\n;                            (assoc m k v))))\n;          merge2 (fn [m1 m2]\n;                   (reduce1 merge-entry (or m1 {}) (seq m2)))]\n;      (reduce1 merge2 maps))))","user":"56051095e4b08b23635d3162"},{"problem":69,"code":"(fn [f & maps] (when (some identity maps) (let [match-entity (fn [m e] (let [k (key e) v (val e)] (if (contains? m k) (assoc m k (f (get m k) v)) (assoc m k v)))) merge2 (fn [m1 m2] (reduce match-entity (or m1 {}) (seq m2)))] (reduce merge2 maps))))","user":"5addadfce4b0837691e92c13"},{"problem":69,"code":"(fn mw [f m & ms]\n  (reduce\n   (fn [acc m]\n     (reduce\n      (fn [acc m]\n        (let [k (first m)\n              v' (second m)\n              v (get acc k)]\n          ;;(println \"acc: \" acc \" k:\" k \" v':\" v' \" v:\" v \" m:\" m)\n          (if (not (nil? v))\n            (conj acc [k (f v v')])\n            (conj acc m))))\n      acc\n      m))\n   m\n   ms))","user":"5d631376e4b0c9e5857d5023"},{"problem":69,"code":"(fn [f & coll] (reduce\n  (fn [m [k v]] (if (contains? m k) \n    (assoc m k (f (get m k) v))\n    (assoc m k v)))\n  {}\n  (apply concat coll)))","user":"5da05bcce4b000c986472bd0"},{"problem":69,"code":"(fn\n  [f & maps]\n  (reduce-kv (fn [agg k v]\n               (assoc agg k (reduce f (map val v)))) \n             {} \n             (group-by first (mapcat seq maps))))","user":"57ea2c91e4b0bfb2137f5b42"},{"code":"(fn\n  ; merge-with implementaion\n  [f & maps]\n  (letfn [(merge-pair\n           ; merge pair of maps\n           [m1 m2]\n           (letfn [(folder\n                    [res k]\n                    (let [v1 (get res k)\n                          v2 (get m2 k)\n                          v (if (nil? v1) v2\n                              (if (nil? v2) v1\n                                (f v1 v2)))]\n                      (assoc res k v)))]\n             (reduce folder m1 (keys m2))))]\n    (reduce merge-pair maps)))","problem":69,"user":"515ead6be4b049add99a053e"},{"code":"(fn [f & maps]\n  (reduce (fn [m k] \n            (assoc m k \n              (let [vs (reduce #(if-let [v (get %2 k)] (conj % v) %) [] maps)]\n                (if (> (count vs) 1) (apply f vs) (first vs)))))\n          {} (reduce #(apply conj % (keys %2)) #{} maps)))","problem":69,"user":"5097cfcbe4b00ad8bab4e977"},{"problem":69,"code":"(fn [f & maps]\n  (loop [res   (first maps)\n         rmaps (rest maps)]\n    (if (empty? rmaps)\n      res\n      (let [current-map (first rmaps)\n            new-res (loop [ires res\n                           rkeys (keys current-map)]\n                      (if (empty? rkeys)\n                        ires\n                        (let [k (first rkeys)]\n                          (if (ires k)\n                            (recur (assoc ires k (f (ires k) (current-map k))) \n                                   (rest rkeys))\n                            (recur (assoc ires k (current-map k)) \n                                   (rest rkeys)) ))))\n            new-rmaps (rest rmaps)]\n        (recur new-res new-rmaps))))\n  )","user":"53c1ce3ee4b00fb29b221268"},{"problem":69,"code":"(fn my-merge-with [f & colls]\n  (let [all-keys\n        (->> (reduce #(into %1 (keys %2)) #{} colls)\n             (into [])\n             (sort))\n        use-f\n        (fn [coll]\n          (if (= (count coll) 1)\n            (first coll)\n            (apply f coll)))]\n    (reduce\n      (fn [res key]\n        (->> (map #(get % key) colls)\n             (filter (complement nil?))\n             (use-f)\n             (assoc res key)))\n      {}\n      all-keys)))","user":"5984e7dee4b021a7a535fe43"},{"problem":69,"code":"(fn merge-maps [f & ms]\n  (reduce (partial (fn [g m1 m2]\n  (loop [acc m1\n         coll (vec m2)]\n    (let [k (first (first coll))\n          v (second (first coll))]\n      (cond \n        (empty? coll) acc\n        (acc k) (recur (assoc acc k (g (acc k) v)) (rest coll))\n        :else (recur (assoc acc k v) (rest coll)))))) f) ms))","user":"53ae0c50e4b047364c044471"},{"problem":69,"code":"(fn [f & ms]\n  (let [ps (mapcat identity ms)]\n    (reduce \n      (fn [acc [k v]]\n        (let [nv (if (contains? acc k)\n                   (f (get acc k) v)\n                   v)]\n          (conj acc [k nv])))      \n      {}\n      ps)))","user":"5596a324e4b04c1e5c31d757"},{"problem":69,"code":"(fn mergewith\n   ([f x1 x2 & xs] (apply mergewith f (mergewith f x1 x2) xs))\n   ([f x1 x2]\n    ((fn loopy [a b]\n       (if (empty? b)\n         a\n         (loopy\n           ((fn merger[new]\n              (if (contains? a (key new))\n                (update-in a [(key new)] f (val new))\n                (merge a new))\n              ) (first b))\n           (rest b))\n         )) x1 x2)\n    ))","user":"5f0824c5e4b0cf489e8d7f5b"},{"code":"(fn [f & ms]\n  (reduce #(into %1\n    (for [[k v] %2]\n      (if (%1 k)\n        [k (f (%1 k) v)]\n        [k v])))\n    {} ms))","problem":69,"user":"4db863d7535d1e037afb2190"},{"code":"(fn [f & ms]\n  (letfn [(merge2 [f l r]\n            (reduce\n             (fn [m [k v]] (if (contains? m k) (assoc m k (f (get m k) v)) (merge m {k v})))\n             l (seq r)))]\n    (reduce #(merge2 f %1 %2) ms)))","problem":69,"user":"51b9d1f0e4b0e871ca49590b"},{"code":"(fn [f & maps]\n    (merge (reduce (fn [a b]\n                     (into {} (map (fn [k]\n                                     (if (and (contains? a k) (contains? b k))\n                                       [k (f (get a k) (get b k))]\n                                       (or (find a k) (find b k)))) (keys (merge a b))))) maps)))","problem":69,"user":"50e3e108e4b01912b3285c48"},{"problem":69,"code":"(fn [f & maps]\n   (loop [map (rest maps) result (first maps)]\n     (if (empty? map)\n       result\n       (recur (rest map) (reduce (fn [y x] (conj y (if (contains? y (key x)) [(key x)  (f (get y (key x)) (val x))] x))) result (first map)))\n       )\n     )\n   )","user":"56f15eade4b04a395b9a048e"},{"problem":69,"code":"(fn [f & ms] (reduce (fn [rm cm] (reduce (fn [m e] (assoc m (e 0) (if (contains? m (e 0)) (f (m (e 0)) (e 1)) (e 1)))) rm cm)) ms))","user":"5abe2fc2e4b073f17744271e"},{"problem":69,"code":"(fn [f & ms]\n\n    (->> (apply concat ms)\n\n         (group-by first)\n\n         (map (fn [[v [& l]]]\n\n                {v (reduce f (map second l))}))\n\n         (into {})))","user":"5fab7ea6e4b08cb800c85ad8"},{"problem":69,"code":"(fn merge-w [f & c]\n  (reduce (fn[g [k v]] (update-in g [k] #(if (nil? %)\n                                           v\n                                           (f % v))))\n          {}\n          (mapcat identity (map vec c))))","user":"5ed6030de4b016b56eae05db"},{"problem":69,"code":"(fn [f & m]\n  (reduce\n    (fn [total n]\n      (reduce\n        (fn [t [k v]]\n          (if (contains? t k)\n            (assoc t k (f (get t k) v))\n            (assoc t k v)))\n        total\n        n))\n    {}\n    m))","user":"55625903e4b0c656e3ff17d7"},{"code":"(fn [f m & ms]\n  (reduce\n   (fn [ml mr]\n     (loop [allkeys (set (concat (keys ml) (keys mr)))\n            builder {}]\n       (if (empty? allkeys)\n         builder\n         (let [firstkey (first allkeys)]\n           (if (and (contains? ml firstkey)\n                    (contains? mr firstkey))\n             (recur (rest allkeys) (assoc builder firstkey (f (get ml firstkey)\n                                                              (get mr firstkey))))\n             (recur (rest allkeys) (assoc builder firstkey (val (or (find ml firstkey)\n                                                                    (find mr firstkey))))))))))\n    m ms))","problem":69,"user":"515737f0e4b0b0b4b87062d0"},{"problem":69,"code":"(fn ms [f & ss]\n  (loop [ret {}\n         ks (reduce clojure.set/union\n                    (map #(into #{} (keys %)) ss))]\n    (if (empty? ks)\n      ret\n      (recur (conj ret {(first ks) (reduce f\n                                           (map (fn [m] (val (find m (first ks))))\n                                                (filter #(not (nil? (find % (first ks)))) ss) ))})\n             (rest ks)))))","user":"54a6399ee4b09f271ff37c85"},{"code":"(fn merge-with* [f m & ms]\n  (reduce #(assoc %1 (first %2)\n             (if (nil? (%1 (first %2)))\n               (second %2)\n               (f (%1 (first %2)) (second %2))))\n          m (apply merge ms)))","problem":69,"user":"5300158ae4b0d8b024fd370f"},{"code":"(fn [f & ms]\r\n  (let [mw2 (fn [m1 m2]\r\n              (reduce (fn [m k]\r\n                        (assoc m k (if (contains? m k)\r\n                                     (f (m k) (m2 k))\r\n                                     (m2 k))))\r\n                      m1 (keys m2)))]\r\n    (reduce mw2 ms)))","problem":69,"user":"4f359c7ee4b0e243712b1ec4"},{"problem":69,"code":"(fn [f first-map & remaining-maps]\n  (reduce (fn [m1 m2]\n            (let [m2-keys (keys m2)]\n              (reduce (fn [conjed-map m2-key]\n                        (if (contains? conjed-map m2-key)\n                          (assoc conjed-map m2-key (f (get conjed-map m2-key) (get m2 m2-key)))\n                          (assoc conjed-map m2-key (get m2 m2-key))))\n                      m1 m2-keys)))\n          first-map\n          remaining-maps))","user":"591e0782e4b09b4ee5954c25"},{"problem":69,"code":"(fn mw [f m & ms]\n  (if (empty? ms)\n    m\n    (recur f\n           (reduce\n            (fn [n [k v]]\n              (assoc n k\n                     (if (contains? n k)\n                       (f (n k) v)\n                       v))) m (first ms))\n           (rest ms))))","user":"508c3d42e4b0f17d83ea26b2"},{"code":"(fn [f & a] (reduce #(reduce (fn [r [k v]] (assoc r k (if (r k) (f (r k) v) v))) % %2) a))","problem":69,"user":"4dad8fe9c9a9d6ed1899dc57"},{"problem":69,"code":"(fn [f & maps]\n  (reduce (fn [r k]\n    (assoc r k (reduce\n      f (filter (complement nil?) (map #(% k) maps)))))\n  {} (set (reduce concat (map keys maps)))))","user":"546ff835e4b00cfc9eacc1b4"},{"problem":69,"code":"(fn [f & maps]\n  (letfn [;; Inner reduce function - merges two maps\n          (rd [m [k v]]\n            (assoc m k\n                   (if (contains? m k)\n                     (f (m k) v)\n                     v)))]\n    (reduce #(reduce rd % %2) (first maps) (rest maps))))","user":"5455c2f3e4b080a794c2c87d"},{"code":"#(reduce (fn foo [a b]\n            (reduce (fn bar [i [k v]]\n                        (assoc i k (if (i k) (% (i k) v) v)))\n                    a b))\n          %&)","problem":69,"user":"523ed522e4b057c4b7cd0a78"},{"problem":69,"code":"(fn [f & maps]\n  (->> maps\n       (apply concat)\n       (reduce (fn [acc [k v]] (assoc acc k (if-let [prev (get acc k)] (f prev v) v))) {})))","user":"50310713e4b05b7df5a0b84c"},{"problem":69,"code":"(fn [func & args] (reduce \n\n#(into {} (for [k (clojure.set/union (into #{} (keys %1)) \n                                     (into #{} (keys %2)))]\n   (cond (and (%1 k) (%2 k)) [k (func (%1 k) (%2 k))]\n         (%1 k) [k (%1 k)]\n         (%2 k) [k (%2 k)]))) args))","user":"57015a1de4b08d47c97781d4"},{"problem":69,"code":"(fn merge-with2 [f m & ms]\n   (let [update-or-add (fn update-or-add [m1 k f arg] \n                         (let [x (get m1 k)]\n                           (if (nil? x)\n                             (conj m1 {k arg})\n                             (update-in m1 [k] f arg))))]\n     (loop [m1 m m2 (first ms) ms ms\n            k (keys m2)]\n       (if-not (map? m2)\n         m1\n         (recur (reduce #(update-or-add %1 %2 f (get m2 %2)) m1 k)\n                (first (next ms))\n                (next ms)\n                (keys (first (next ms))))))))","user":"53da8fede4b0e771c30254a3"},{"code":"(fn [f & ms]\r\n       (reduce #(reduce\r\n                  (fn [o [k v]]\r\n                    (conj o [k\r\n                             (if (o k)\r\n                               (f (o k) v)\r\n                               v)]))\r\n                  %1 %2)\r\n         {} ms))","problem":69,"user":"4deb529a535d08e6dec9fe04"},{"problem":69,"code":"(fn my-merge-with\n  ([f m] m)\n  ([f m1 m2]\n   (reduce-kv\n     (fn [result k v]\n       (->> (if (contains? result k) (f (get result k) v) v)\n            (assoc result k)))\n     m1\n     m2))\n  ([f m1 m2 & ms]\n   (reduce (partial my-merge-with f) m1 (cons m2 ms))))","user":"6098263be4b00e9e6653c3f9"},{"code":"(fn [f m & ms]\n   (reduce\n     #(reduce\n       (fn [rs [k v]] (assoc rs k (if (rs k)\n                                    (f (rs k) v)\n                                    v)))\n        % %2)\n     m ms))","problem":69,"user":"4fc0853ae4b081705acca327"},{"problem":69,"code":"(fn [op & maps]\n  (let [mm (fn [a b]\n             (reduce #(if-let [v (get %1 %2)]\n                        (assoc %1 %2 (op v (get b %2)))\n                        (assoc %1 %2 (get b %2)))\n                     a\n                     (keys b)))]\n    (reduce mm maps)))","user":"57458b82e4b009280f9f2b4e"},{"code":"(fn [f & maps]\n  (reduce\n    (fn [m1 m2]\n      (loop [m m2 res m1]\n        (if (empty? m) res\n          (let [[k v] (first m)]\n            (recur (rest m)\n              (if (contains? res k)\n                (assoc res k (f (res k) v))\n                (assoc res k v)))))))\n    maps))","problem":69,"user":"4f03ac2d535dcb61093f6b4a"},{"problem":69,"code":"(fn custom-merge-with\n  [f & maps]\n  (let [tuples (apply concat (map vec maps))]\n    (reduce (fn [result-set tuple]\n              (let [current-key (first tuple)\n                    current-value (result-set current-key)\n                    next-value (last tuple)]\n                (if current-value\n                  (assoc result-set current-key (f current-value next-value))\n                  (assoc result-set current-key next-value))))\n            {} tuples)))","user":"4fc524aae4b081705acca37e"},{"code":"(fn  [x & y]\r\n (let [ coun (count y)\r\n        coun1 (atom 0)\r\n       y2 (atom {})\r\n       at (atom {})\r\n       at2 (atom (vec y))]\r\n   (loop [d 0]\r\n    (when (< d coun)\r\n        \t(reset! y2 (first @at2))\r\n            (reset! coun1 (count @y2))\r\n        \t(loop [l 0]\r\n\t\t\t  (when (< l @coun1)\r\n                (if \r\n                  (@at (first (first @y2))) \r\n                  (reset! at (assoc @at  (first (first @y2))  (x (@at (first (first @y2))) (@y2 (first (first @y2))))))\r\n                  (reset! at (assoc  @at  (first (first @y2)) (@y2 (first (first @y2))))))\r\n                (reset! y2 (into {} (rest @y2)))\r\n\t\t\t  (recur (+ l 1))))\r\n        (reset! at2 (into [] (rest @at2)))\r\n\t  (recur (+ d 1))))\r\n   @at\r\n   ))","problem":69,"user":"50646c01e4b007509339a58b"},{"code":"(fn my-merge-with [f & maps]\n  (letfn [(my-pair-merge-with [map1 map2]\n  (reduce #(if (contains? %1 %2)\n             (assoc %1 %2 (f (%1 %2) (map2 %2)))\n             (assoc %1 %2 (map2 %2))) map1 (keys map2)))]\n   (reduce my-pair-merge-with {} maps)))","problem":69,"user":"5186134ce4b0da5a5be3bac7"},{"code":"(fn [f & a]\r\n    (let [r #(into % (for [[k v] %2] (if (% k)\r\n                                         [k (f (% k) v)]\r\n                                         [k v])))]\r\n          (reduce r a)))","problem":69,"user":"4db03279838c48654951d9bc"},{"problem":69,"code":"(fn [f & maps]\n     (reduce\n       (fn [result mp]\n         (reduce\n           (fn [res [k v]]\n             (assoc res k\n               (if (contains? res k)\n                 (f (res k) v)\n                 v)))\n           result\n           mp))\n       {}\n       maps))","user":"5b999af8e4b0c0b3ffbd4ad3"},{"code":"(fn [f & m] (let [ks (keys (apply conj m))]\n            (apply conj \n                   (map \n                    (fn [k] \n                      (hash-map k \n                                (reduce f \n                                        (filter \n                                         (comp not nil?) \n                                         (map (fn [kk] (get kk k)) m)\n                                         )))) ks))))","problem":69,"user":"5150a7d7e4b03e678e393abb"},{"problem":69,"code":"(fn [f & maps] (let [gms (group-by first (mapcat (fn [m] (map #(list % (get m %)) (keys m))) maps))]\n                    (reduce #(assoc % %2 (reduce f (map second (get gms %2)))) {} (keys gms))))","user":"4e68c465535d8ccf87e9fe8a"},{"code":"(fn [f & maps]\n  (loop [r (rest maps)\n         result (first maps)]\n    (if (seq r)\n      (let [m (first r)\n            newresult \n              (reduce \n                #(let [k (key %2) v (val %2)] \n                  (if (contains? % k)\n                    (assoc % k (f (% k) v))\n                    (assoc % k v))) \n                result m)]\n        (recur (rest r) newresult))\n      result)))","problem":69,"user":"4edd038c535d10e5ff6f5327"},{"problem":69,"code":"(fn [f & maps]\n  (reduce (fn [m1 m2]\n            (reduce (fn [m [k v]]\n                      (if-let [vv (m k)]\n                        (assoc m k (f vv v))\n                        (assoc m k v)))\n                    m1 m2))\n          maps))","user":"565654dae4b0f9d632dd849f"},{"code":"(fn merge-w [f & maps] \n  (when (some identity maps)\n    (let [merge-entry (fn [m e]\n          (let [k (key e) v (val e)]\n(if (contains? m k) \n(assoc m k (f (get m k) v))\n(assoc m k v))))\nmerge2 (fn [m1 m2]\n  (reduce merge-entry (or m1 {}) (seq m2)))]\n(reduce merge2 maps))))","problem":69,"user":"4ed2dd98535d44c135fd68e2"},{"problem":69,"code":"(fn mer-by [f & maps]\n   (letfn\n    [(map-vals\n      [f pred m]\n      (into {}\n        (for [[k v] m]\n          (if (pred v)\n            [k (f v)]\n            [k (first v)]))))]\n    (map-vals (partial apply f) #(> (count %) 1)\n     (map-vals\n      (partial map second)\n      (constantly true)\n      (group-by first (reduce into [] maps))))))","user":"566ff0a1e4b0a866af6896ec"},{"code":"(fn [f & maps]\n   (reduce\n    (fn [a b]\n      (let [new-vals (map (fn [[k v]] [k (if (a k) (f (a k) v) v)]) b)\n            new-vals-flat (apply concat new-vals)] ;; flatten\n        (apply (partial assoc a) new-vals-flat)))\n    maps))","problem":69,"user":"500ea957e4b00fff93030f9b"},{"problem":69,"code":"(fn\n  [f & s]\n  (reduce\n   (fn \n     [m n]\n     (apply \n      merge\n      (cons n \n            (map\n             (fn\n               [[k v]]\n               {k (if (get n k)\n                       (f v (get n k))\n                       v)})\n                m))))\n   s))","user":"51b76227e4b0d906fcd71d35"},{"code":"(fn [f m1 & m2]\n  (let [maps (list* m1 m2)\nkeys (keys (apply merge maps))]\n(reduce (fn [r x]\n  (assoc r x (let [v (remove nil? (map #(get % x) maps))]\n(if (= 1 (count v))\n(first v)\n(apply f v))))) {} keys)))","problem":69,"user":"4eb27fad535d7eef3080734a"},{"problem":69,"code":"(fn\n  [f X & Y]\n  (loop [x X y (apply merge Y) r {}]\n    (if x\n      (let [[k v] (first x)]\n        (recur (next x) (dissoc y k) (assoc r k (f v (y k)))))\n      (merge r y))))","user":"502940a9e4b061fd216be4b8"},{"problem":69,"code":"(fn [f & maps]\n  (reduce \n   (fn [res m]\n     (loop [[h & t :as ks] (keys m), res res]\n       (let [prev (get res h), v (get m h)]\n         (cond\n           (empty? ks) res\n           (nil? prev) (recur t (assoc res h v))\n           :else (recur t (assoc res h (f prev v))))))) {} maps))","user":"5e9f38cce4b00a66d4a9517e"},{"code":"(fn [ f & maps ]\n  (reduce (fn [a b]\n            (reduce (fn [m k]\n                      (if (contains? m k)\n                        (assoc m k (f (get m k) (get b k)))\n                        (assoc m k (get b k))))\n                    a (keys b)))\n          maps))","problem":69,"user":"504e0517e4b078edc5f5939a"},{"code":"(fn a\n  ([f m n] (loop [m m [h & t] (seq n)]\n             (if-let [[k v] h]\n               (if (contains? m k)\n                 (recur (assoc m k (f (get m k) v)) t)\n                 (recur (assoc m k v) t))\n               m)))\n  ([f m n & ms] (reduce #(a f % %2) (a f m n) ms)))","problem":69,"user":"50142490e4b07d18bdaaf70a"},{"problem":69,"code":"(fn \n  [f m1 & ms]\n  (loop [m m1 o (vec ms)]\n    (let [k (first (keys (first o)))]\n      (if (empty? o )\n        m\n        (if (empty? (first o))\n          (recur m (vec (rest o)))\n          (if (contains? m k) \n            (recur (assoc m k (f (get m k) (get (first o) k ) ) ) (assoc o 0 (conj {} (rest (first o)))))\n            (recur (assoc m k (get (first o) k )  ) (assoc o 0 (conj {} (rest (first o)))))\n            )\n          \n          )))))","user":"5772ddb0e4b0979f896515d4"},{"code":"#(reduce (partial reduce (fn [s [x y]]\r\n  (conj s [x (if (s x) (% (s x) y) y)]))) %&)","problem":69,"user":"4fca2ef0e4b0ee37620e184e"},{"problem":69,"code":"(fn mymerge [f & maps]\n  (reduce (fn [map1 map2]\n            (reduce (fn [x y]\n                      (let [[k v] y]\n                        (if (nil? (x k))\n                          (assoc x k v)\n                          (assoc x k (f (x k) v)))))\n                    map1 map2))\n          maps))","user":"57dd47f4e4b0bd073c20243e"},{"problem":69,"code":"(fn f1 [f m1 & maps]\n  (let [m2 (reduce into {} maps)]\n    (reduce #(if (not (nil? (get % (key %2)))) \n               (assoc % (key %2) (f (get % (key %2)) (val %2)))\n               (conj % %2)) m1 m2)))","user":"53973e7be4b0b51d73faaee6"},{"problem":69,"code":"(fn my-merge-with [f & maps]\n  (reduce\n    (fn [acc m]\n      (let [m' (into {}\n                     (for [[k v] m]\n                       [k (if (contains? acc k) (f (acc k) v) v)]))]\n\n        (merge acc m')))\n    {}\n    maps))","user":"5b51b9f8e4b02d533a91bcfe"},{"code":"(fn my-merge-with [ f m & ms ]\n  (reduce\n   (fn merge-this [to from]\n     (if (empty? from)\n       to\n       (let [[k v] (first from)]\n         (recur (assoc to k (if (contains? to k) (f (to k) v) v)) \n                (rest from)))))\n   m ms))","problem":69,"user":"4ddb696b535d02782fcbe9fa"},{"problem":69,"code":"(fn [op m & ms]\n  (reduce\n   (fn [m [k v]]\n     (assoc m k\n       (let [v0 (get m k)]\n         (if (nil? v0) v (op v0 v)))))\n   m\n   (for [m1 ms e m1] e)))","user":"605b7a90e4b079a07f8593fc"},{"code":"(fn __ [f & dicts]\n  (let [allkeys (set (mapcat keys dicts))]\n    (apply hash-map\n           (mapcat (fn [k]\n                     (let [vals (->> dicts\n                                     (map #(get % k :nil))\n                                     (filter #(not= % :nil)))]\n                       [k (if (= 1 (count vals)) (first vals) (apply f vals))])) \n                   allkeys))))","problem":69,"user":"536d83cee4b0fc7073fd6e5e"},{"code":"(fn [dfn x & maps]\n  (reduce (fn [s n]\n            (reduce (fn [inner-s inner-n]\n                      (merge inner-s\n                             (let [inner-value (get inner-s (first inner-n))\n                                   inner-key (first inner-n)]\n                               (if (nil? inner-value)\n                                 {inner-key (last inner-n)}\n                                 {inner-key (dfn inner-value (last inner-n))}\n                               )\n                            )\n                       )\n                    ) s n)\n           ) x maps)\n)","problem":69,"user":"5303a027e4b0d8b024fd3745"},{"problem":69,"code":"(fn merge [f & maps]\n  (let [merge-item (fn [m e]\n                     (let [k (key e) v (val e)]\n                       (if (contains? m k)\n                         (assoc m k (f (get m k) v))\n                         (assoc m k v))))\n        merge-all (fn [m1 m2]\n                    (reduce merge-item (or m1 {}) (seq m2)))]\n    (reduce merge-all maps)))","user":"5b67d634e4b0c6492753e76b"},{"code":"(fn umerge [f & args]\n  (let [arg1 (first args)\n        arg2 (second args)\n        rst (drop 2 args)\n        mrg (loop [ret arg1 x arg2]\n              (if (empty? x)\n                ret\n                (let [elt (first x)\n                      m-v (ret (key elt) nil)]\n                  (recur (assoc ret (key elt) (if (nil? m-v)\n                                                (val elt)\n                                                (f m-v (val elt))))\n                         (rest x)))))]                  \n    (if (= 2 (count args))\n      mrg\n      (apply umerge f mrg rst))))","problem":69,"user":"4eec82fe535d93acb0a668ae"},{"code":"(fn [f & maps]\n  (reduce\n   (fn [m v]\n     (assoc m v\n       (#(if (> (count %) 1)\n           (apply f %)\n           (first %))\n         (remove nil?\n                 (map #(% v) maps)))))\n   {}\n   (distinct (flatten (map keys maps)))))","problem":69,"user":"519136e9e4b0f8ef0be96c01"},{"code":"(fn [f r & m]\n  (if (= [] m)\n      r\n    (recur f ((fn [rr mm]\n        (if (= [] mm)\n            rr\n          (recur ((fn [rrr mmm] \n            (if (= [] mmm)\n                rrr\n              (if (contains? rrr (first mmm))\n                  (conj rrr [(first mmm) (f (rrr (first mmm)) (first (rest mmm)))])\n                (conj rrr mmm)\n)))rr (first mm)) (rest mm))))r (first m)) (rest m))))","problem":69,"user":"507fbd77e4b089ade05efbd3"},{"problem":69,"code":"(fn [f m & ms]\n  (reduce (fn [res1 m-elem]\n            (reduce-kv (fn [res2 k v]\n                         (if (contains? res2 k)\n                           (assoc res2 k (f (get res2 k) v))\n                           (assoc res2 k v)))\n                       res1\n                       m-elem))\n          m\n          ms))","user":"57822efce4b0d36ec5835e91"},{"code":"(fn [func m & ms]\n   (let [\n     ms (concat [m] ms)\n     ks (set (mapcat keys ms))]\n     (reduce\n       (fn [b k]\n         (assoc b k (reduce \n                          func \n                          (keep (fn [m] (m k)) \n                           ms)))) \n       {} \n       ks)))","problem":69,"user":"4daa374930acd6ed13482a68"},{"problem":69,"code":"(fn [murge & maps]\n  (reduce (fn [result a-map]\n            (reduce-kv (fn [m k v]\n                         (assoc m k (if (m k)\n                                      (murge (m k) v)\n                                      v)))\n                       result\n                       a-map))\n          (first maps)\n          (rest maps)))","user":"59a080e3e4b0871e7608b837"},{"problem":69,"code":"(fn [f & maps]\n  (let [key-grouped (group-by key (apply concat maps))\n        apply-f     (fn [x] \n                      (if (> (count x) 1)\n                        (apply f (map val x))\n                        (val (first x))))\n        mapped      (map #(hash-map (key %) (apply-f (val %))) key-grouped)\n        answer      (apply conj mapped)]\n   answer))","user":"57e139f6e4b0bfb2137f5a6c"},{"problem":69,"code":"(fn [f & ms]\n  (into {}\n        (for [k (distinct (mapcat keys ms))\n              :let [vs (->> ms\n                            (map #(get % k))\n                            (filter identity))]]\n          {k (if (> (count vs) 1)\n               (apply f vs)\n               (first vs))})))","user":"5a257747e4b07f18be40aa1f"},{"code":"(fn [f & maps]\n  (letfn [(maybe-apply [coll]\n          (if (> (count coll) 1)\n          (apply f coll)\n          (first coll)))]\n    (let [smaps (group-by first (apply concat (map #(apply list %) maps)))]\n      (zipmap (keys smaps) (map (fn [x] (maybe-apply (map second (second x)))) smaps)))))","problem":69,"user":"4ea7999e535d7eef308072ee"},{"problem":69,"code":"(fn mw [op x & zs] (let [z (first zs)\n                       \t  w (first (keys z))\n                          new (if (nil? (x w)) (assoc x w (z w)) (assoc x w (op (x w) (z w))))]\n         (if (and (= 1 (count zs)) (= 1 (count z))) \n           new\n           (apply (partial mw op new) ( if (not= (empty z) (dissoc z w)) (conj (rest zs) (dissoc z w)) (rest zs)))\n           )          \n  ))","user":"540479e7e4b0addc1aec665a"},{"problem":69,"code":"(fn [f & maps]\n  (letfn [(zip [map1 map2]\n               (reduce (fn [a [k v]]\n                         (if (contains? a k)\n                           (assoc a k (f (a k) v))\n                           (assoc a k v)))\n                       map1\n                       map2))]\n    (reduce zip {} maps)))","user":"5cc6b4bfe4b0ccb061962827"},{"problem":69,"code":"(fn [f & args]\n                  (reduce (fn[map1 map2]\n                            (reduce (fn [m [k v]]\n                                      (if-let [vv (m k)]\n                                        (assoc m k (f vv v))\n                                        (assoc m k v)))\n                                    map1 map2)) args))","user":"5d9c9446e4b0eb781811cdae"},{"problem":69,"code":"(fn [f & maps]\n  (into {} (map\n  (fn [grp]\n    [(first grp) (apply (fn [& args] (apply (if (= 2 (count args)) f identity) args))\n                         (mapcat #(map last %) (rest grp)))])\n  (group-by first (apply concat  maps)))))","user":"55ede35ce4b0121d4835fde1"},{"problem":69,"code":"(fn solution [f & args]\n  (into {} (for [entry (group-by first (apply concat args))]\n             (if (second (second entry))\n               {(first entry) (f (second (first (second entry))) (second (second (second entry))))}\n               {(first entry) (second (first (second entry)))}))))","user":"5e2ef900e4b05b4b015161fc"},{"problem":69,"code":"(fn [func & maps]\n  (let [joined (into {} \n    (for [[k v] \n      ((comp #(group-by first %) #(partition-all 2 %) #(apply concat %) #(apply concat %) concat #(map seq %)) maps)] \n      [k (apply vector (flatten (map second v)))]))]\n    (if (= concat func) joined\n      (into {} (for [[k v] joined] \n        (if (empty? (rest v)) [k (first v)] [k (apply func v)]))))))","user":"56bb9ccce4b0f26550335959"},{"code":"(fn [f col & more]\r\n(reduce  #(let [[k v] %2] (assoc %1 k (if (contains? %1 k) (f (%1 k) v) v)))\r\n    col (reduce #(concat %1 (seq %2)) more)))","problem":69,"user":"4fd29d7ce4b04c3a95aa0424"},{"problem":69,"code":"(fn mw [f & m]\n  (reduce\n    (fn [a b]\n      (reduce\n        (fn [x [k v]]\n          (assoc x k (if (b k) (f v (b k)) v)))\n        b a))\n    (first m) (rest m)))","user":"54b54d1be4b05787c3b1639c"},{"code":"(fn [f m & more]\n (letfn [(g [s t] (reduce (fn [x [k v]] (if (x k)\n                                          (update-in x [k] (fn [n] (f n v)))\n                                          (assoc x k v))) s t))]\n  (reduce (fn [a b] (g a b)) m more)))","problem":69,"user":"5097b556e4b00ad8bab4e970"},{"problem":69,"code":"(fn [f & maps]\n  (reduce (fn [accum map]\n            (reduce (fn [a k]\n                      (if (get a k)\n                        (update-in a [k] f (get map k))\n                        (assoc a k (get map k))))\n                    accum\n                    (keys map)))\n          maps))","user":"55ed1575e4b0121d4835fdd3"},{"code":"#(letfn [(me [m e]\n\t(let [k (key e) v (val e)]\n\t\t(if (contains? m k)\n\t\t\t(assoc m k (% (get m k) v))\n\t\t\t(assoc m k v))))]\n\t\t(reduce me %2 (seq (apply concat %&))))","problem":69,"user":"514d8084e4b019235f6c0588"},{"problem":69,"code":"(fn my-merge-with [f & maps]\n  (reduce\n   (fn [acc m]\n     (merge acc\n            (into {} (for [k (keys m)]\n                       (if (contains? acc k)\n                         [k (f (acc k) (m k))]\n                         [k (m k)])))))\n   maps))","user":"561d23e3e4b064ca9f4b16a5"},{"code":"(fn\n    ([f] nil)\n    ([f & maps]\n       (letfn [(merge-entry [m e]\n                 (let [k (key e)\n                       v (val e)]\n                   (if (contains? m k)\n                     (assoc m k (f (get m k) v))\n                     (assoc m k v))))\n               (merge2 [m1 m2]\n                 (reduce merge-entry m1 (seq m2)))\n               ]\n         (reduce merge2 maps))))","problem":69,"user":"4e48b61d535dc968683fc4be"},{"problem":69,"code":"(fn [f & as]\n  (let [single-merge (fn [f a b]\n                       (apply\n                         merge \n                         (cons\n                           a\n                           (map \n                             (fn [k] \n                               (if (contains? a k) \n                                 {k (f (a k) (b k))} \n                                 {k (b k)}))\n                             (keys b)))))]\n\n  (reduce (partial single-merge f) as)))","user":"546e4ab8e4b00cfc9eacc19c"},{"problem":69,"code":"(fn [f c1 & colls] \n  (reduce (fn [a b] \n            (reduce #(if (contains? %1 (key %2))\n                       (assoc %1 (key %2) (f (get %1 (key %2)) (val %2)))\n                       (assoc %1 (key %2) (val %2)))\n                    a\n                    b)\n          )\n          c1\n          colls)\n)","user":"59d75e36e4b0ef0a1e9b5c32"},{"code":"(fn [f & maps]\n  (let [my-merge-with (fn [f m1 m2]\n                        (loop [keys2 (keys m2)\n                               acc   m1]\n                          ;;\n                          (let [fst-keys2 (first keys2)]\n                            (cond\n                             ;; if all keys are worked on, return acc\n                             (empty? keys2) acc\n                             ;; If m1 has the same key, merge-with f\n                             (contains? m1 fst-keys2) (recur (rest keys2)\n                                                             (assoc acc fst-keys2(f (get m1 fst-keys2)\n                                                                                    (get m2 fst-keys2))))\n                             ;; If m1 has no such key, just merge\n                             :else (recur (rest keys2) (assoc acc fst-keys2 (get m2 fst-keys2)))))))]\n    \n    (reduce #(my-merge-with f %1 %2) (first maps) (rest maps))))","problem":69,"user":"53415755e4b00652c8746ecd"},{"code":"(fn [f m & mps]\n   (reduce\n    #(reduce\n      (fn [m kv]\n        (let [k (key kv)\n              v (val kv)\n              mv (get m k)]\n          (assoc m k\n                 (if mv\n                   (f mv v)\n                   v)))) % %2) m mps))","problem":69,"user":"5125029de4b0ce9225d2ed3e"},{"problem":69,"code":"(fn [f & m]\n     (reduce\n       #(reduce\n          (fn [m [k v]]\n            (apply assoc m [k (if (contains? m k) (f (m k) v) v)]))\n          %1 %2)\n       m))","user":"59e0f38ae4b08badc2a0c500"},{"code":"(fn [f s & xs]\n  (letfn [(my-merge-with [f s xs]\n            (reduce (fn [samm kay] \n                      (if-let [samm-kay (samm kay)]\n                        (assoc samm kay (f samm-kay (xs kay)))\n                        (assoc samm kay (xs kay))))\n                    s (keys xs)))]\n    (reduce #(my-merge-with f %1 %2)\n            s xs)))","problem":69,"user":"50ef9a7ae4b0bdaecbb47d9e"},{"problem":69,"code":"; Attempt 1: Works but is not as readable as my later attempt\n;(fn my-merge-with [fx & maps] \n;  (reduce (fn [res x]\n;    (loop [k (keys x) res res]\n;      (if (seq k)\n;        (if (res (first k))\n;          (recur (rest k) \n;                 (assoc res (first k) (fx (res (first k)) (x (first k)))))\n;          (recur (rest k) \n;                 (assoc res (first k) (x (first k))))\n;        )\n;        res\n;      )\n;    )) maps))\n\n\n; Simplifying the above a bit more based on fact that looping can be replaced by a reduce/reduce-kv.\n; i.e. its a double reduce, a reduce using an initial map first\n(fn [fx & maps]\n  (reduce (fn [acc first-map]; go over a pair of maps\n            (reduce (fn [init [k v]] ; go over each key in first-map\n              (assoc init k\n                 (if (init k) ; If the key is in both maps evaluate fx \n                   (fx (init k) v)\n                   v\n                 )\n               )\n              )\n            acc first-map)\n          ) {} maps\n  )\n)","user":"5722bf99e4b0c5bde472c0d6"},{"code":"(fn [op m & ms]\n  (reduce (fn [a [k v]] \n            (assoc a k \n              (if (contains? a k) \n                (op (a k) v) \n                 v)))\n          m (mapcat seq ms))\n   )","problem":69,"user":"502bb7c0e4b0194ad32ea1a3"},{"code":"(fn [f m & rest]\n    (let [merge-in (fn [m k v f]\n                     (if (contains? m k)\n                       (assoc m k (f (m k) v))\n                       (assoc m k v)))\n          merge-fn (fn [f m1 m2]\n                     (loop [m m1\n                            kv (seq m2)]\n                       (if-let [[[k v] & r] kv]\n                         (recur (merge-in m k v f) r)\n                         m)))]\n      (reduce (partial merge-fn f) m rest)))","problem":69,"user":"4e50ad74535dc968683fc4ec"},{"problem":69,"code":"(fn [f m & ms] \n  (reduce\n   (fn [a e]\n     (reduce\n      (fn [a1 [k v]] (assoc a1 k (if (contains? a k) (f (get a k) v) v)))\n      a\n      e))\n   m\n   ms))","user":"4f1ef6a0535d64f60314649b"},{"problem":69,"code":"(fn my-merge-with [f & ms]\n  (let [merge-entry (fn [m e]\n    (let [k (key e) \n          v (val e)]\n      (if (contains? m k)\n        (assoc m k (f (get m k) v))\n        (assoc m k v))))]\n    (reduce #(reduce merge-entry \n                     %1 \n                     (map identity %2)) ; generates map-entries\n            ms)))","user":"56255e2de4b00a550fc90297"},{"problem":69,"code":"(fn my-merge-with [f & maps]\n  (reduce (fn [m1 m2]\n            (reduce (fn [m [k v]]\n                      (if (contains? m k)\n                        (update-in m [k] f v)\n                        (conj m [k v])))\n                    m1 m2))\n          maps))","user":"54ae541ae4b09f271ff37cef"},{"code":"(fn [f m & o]\r\n (reduce\r\n  (fn [m [x y]]\r\n   (assoc m x (if-let [t (m x)] (f t y) y)))\r\n  m\r\n  (apply concat o)))","problem":69,"user":"4eb97b2e535dfed6da9c6d54"},{"problem":69,"code":"(fn my-merge-with [f & maps]\n  (reduce (fn [acc m] (reduce (fn [result [k v]]\n                                (assoc result k (if (acc k) (f (acc k) v) v)))\n                              acc m)) {} maps))","user":"5c506951e4b0f9f7a8770ec5"},{"problem":69,"code":"(fn merge-w [f ini & maps]\n  (if (empty? maps)\n    ini\n    (let [m (first maps)]\n      (loop [kvs (seq m) ans ini]\n        (if (empty? kvs)\n          (apply merge-w f ans (rest maps))\n          (let [[kv & remain] kvs]\n            (if (contains? ans (first kv))\n              (recur remain (update-in ans [(first kv)] f (second kv)))\n              (recur remain (conj ans kv)))))))))","user":"5746061ae4b009280f9f2b5b"},{"code":"(fn [f & ms]\n  (reduce (fn [m1 m2]\n            (reduce #(cond\n                      (contains? %1 (first %2)) (let [k (first %2)\n                                                      v1 (get %1 k)\n                                                      v2 (second %2)]\n                                                  (assoc %1 k (f v1 v2)))\n                      :else (conj %1 %2)\n                      ) m1 m2)\n            ) ms))","problem":69,"user":"516d2a46e4b06f078fab252f"},{"problem":69,"code":"(fn [x & y] \n  (reduce \n   \t(fn [u v] \n      (apply hash-map \n             (mapcat \n                #(if (and (contains? u (first %)) (contains? v (first %))) \n                \t[(first %) (x (u (first %)) (v (first %)))]\n                    %)\n                (merge u v)))) \n   y))","user":"53fc8424e4b0de5c418485b3"},{"problem":69,"code":"(fn [f & args]\n  (letfn [(merge' [a b]\n           (reduce (fn [acc [k v]]\n                     (if (contains? a k)\n                       (assoc acc k (f (get a k) v))\n                       (assoc acc k v)))\n                   a b))]\n    (reduce merge' args)))","user":"5576f299e4b05c286339e077"},{"code":"(fn [f & seqs]\n        (reduce (fn [s1 s2]\n                  (merge s2 (apply hash-map \n                                   (mapcat (fn [[key value]] \n                                             (if (contains? s2 key) \n                                               [key (f value (s2 key))] \n                                               [key value]))\n                                           s1))))\n                seqs))","problem":69,"user":"5294e44de4b02ebb4ef75016"},{"problem":69,"code":"(fn merge' [f m1 & mx]\n  (if (empty? mx) m1\n    (let [merge-entry (fn [m e]\n\t\t\t(let [k (key e) v (val e)]\n\t\t\t  (if (contains? m k)\n\t\t\t    (assoc m k (f (get m k) v))\n\t\t\t    (assoc m k v)\n              )\n            ))]\n      (apply merge' f (reduce merge-entry m1 (first mx)) (rest mx))\n    )\n  )\n)","user":"57c7a8b5e4b05aa3c4741d09"},{"problem":69,"code":"(fn [& a]\n           (reduce (fn [r x]\n                     (conj r (reduce (fn [t y]\n                                     (if (contains? r (y 0))\n                                       (into t {(y 0) ((first a) (r (y 0)) (y 1))})\n                                       (conj t y)))\n                                   {} x)))\n                   (second a) (nnext a)))","user":"5e1c3e6ee4b0dc9594008530"},{"problem":69,"code":"(fn [op & maps]\n  (letfn [(mrg [m1 m2]\n            (loop [m m1 [k & ks] (keys m2)]\n              (if k\n                (if-let [oldv (m k)]\n                  (recur (assoc m k (op oldv (m2 k))) ks)\n                  (recur (assoc m k (m2 k)) ks))\n                m)))]\n    (loop [m (first maps)\n           r (rest maps)]\n      (if (seq r)\n        (recur (mrg m (first r)) (rest r))\n        m))))","user":"58b51e05e4b0ebc645576d4c"},{"code":"(fn [func dest & srcs]\n  (letfn [(h [m [k v]]\n             (let [entry (m k)]\n               (if-not entry (conj m {k v})\n                 (assoc m k (func entry v)))))\n          (g [dest src]\n             (reduce h dest (map vec src)))]\n    (reduce g dest srcs)))","problem":69,"user":"51eadb98e4b0f1f103a0d153"},{"problem":69,"code":"(fn m2 [f m & ms]\n  (loop [m m ms ms]\n    (if-let [x (first ms)]\n      (recur (conj m\n                   (mapcat #(hash-map %\n                                      (if (m %)\n                                        (f (m %) (x %))\n                                        (x %)))\n                           (keys (first ms))))\n             (rest ms))\n      m)))","user":"57533bc1e4b02ea1147992a6"},{"problem":69,"code":"(fn [f & maps]\n  (into\n    {}\n    (for [k\n        (apply\n          clojure.set/union\n          (map #(set (keys %)) maps))]\n      [k (reduce\n        f\n        (filter\n          (complement nil?)\n          (map #(get % k) maps)))])))","user":"5a2df4a0e4b09cafd31c7f74"},{"code":"(fn my-merge-with [function result & colls]\n  (reduce (fn [result-map to-add]\n            (reduce (fn [elms elm]\n                      (conj elms\n                            (if-let [value (get elms (key elm))]\n                              {(key elm) (function value (val elm))}\n                              elm)))\n                    result-map\n                    to-add))\n          result\n          colls))","problem":69,"user":"5141bc82e4b02fd87f5064c5"},{"problem":69,"code":"(fn my-merge-with [op & args]\n    (into {}\n          ((fn [groups]\n             (for [key (keys groups)]\n               (let [grp (groups key)\n                     vals (map last grp)]\n                 (if (= 1 (count vals))\n                   {key (first vals)}\n                   {key (apply op (map last grp))}))))\n           (group-by first (mapcat #(into [] %) args)))))","user":"568e1871e4b0dcc4269f40cc"},{"problem":69,"code":"(fn f [g & ms]\n  (reduce\n    (fn [m1 m2]\n      (reduce \n        (fn [m1 [k2 v2]]\n          (if-let [v1 (get m1 k2)]\n            (assoc m1 k2 (g v1 v2))\n            (assoc m1 k2 v2))) \n        m1 m2))\n    ms))","user":"5012da69e4b0c8732600222d"},{"code":"(fn mymerge [f m1 m2 & more]\n  (if (empty? m2)\n    (if (empty? more)\n      m1\n      (recur f m1 (first more) (next more)) \n    )\n    (let [k (first (first m2)) v (second (first m2))]\n      (if (contains? m1 k)\n        (recur f (assoc m1 k (f (m1 k) v)) (next m2) more)\n        (recur f (assoc m1 k v) (next m2) more)\n      )  \n    )\n  )        \n)","problem":69,"user":"5176afd2e4b085adf681d889"},{"code":"(fn [f & more]\n  (reduce (fn [res m]\n            (reduce (fn [res_map [k v]]\n              (if (contains? res_map k)\n               (update-in res_map [k] #(f % v))\n               (assoc res_map k v))\n                      ) res m\n                        )) more) )","problem":69,"user":"5302ac7fe4b0d8b024fd3731"},{"problem":69,"code":"(fn [f my-map & maps]\n  (let [mp (fn [m1 m2]\n             (reduce (fn [m1 key]\n                       (if (get m1 key)\n                         (assoc m1 key (f (get m1 key) (get m2 key)) )\n                         (assoc m1 key (get m2 key))\n                         )\n                       ) m1 (keys m2)\n             ))]\n    (reduce mp my-map maps ))\n  )","user":"564a560ae4b0284900eef654"},{"problem":69,"code":"(fn [f & maps]\n  (reduce (fn [map1 map2] \n            (reduce (fn [map1 item] \n                      (update-in \n                       map1 \n                       [(key item)] \n                       (fn [value]\n                         (if (nil? value)\n                           (val item)\n                           (f value (val item)))))) map1 map2)) maps))","user":"50e90813e4b033b0e80d11e7"},{"problem":69,"code":"#(reduce (fn [r n]\n           (reduce (fn [r i]\n                     (if-let [e (get r (key i))]\n              \t       (assoc r (key i) (% e (val i)))\n              \t\t   (conj r i)))\n                   r\n                   n))\n          %&)","user":"541709b0e4b01498b1a71a06"},{"problem":69,"code":"(fn \n    [f & maps]    \n    (letfn  [(merge-entry [m e]\n               (let [k (key e) v (val e)]\n                 (if (contains? m k)\n                   (assoc m k (f (get m k) v))\n                   (assoc m k v))))\n             (merge2 [m1 m2]\n               (reduce merge-entry (or m1 {}) m2))]\n      (reduce merge2 maps)))","user":"55aa1637e4b0988bba2ad949"},{"problem":69,"code":"(fn my-merge-with [f m & xs]\n    (if (empty? xs)\n      m\n      (recur f (reduce (fn [m [k v :as x]]\n                         (if (contains? m k)\n                           (update-in m [k] f v)\n                           (conj m x))\n                         ) m (first xs)) (rest xs))))","user":"5d5e0259e4b0c9e5857d4fef"},{"problem":69,"code":"(fn [f & ms]\n  (reduce #(reduce (fn [m [k v]]\n                      (assoc m k (if (m k)\n                                   (f (m k) v)\n                                   v)))\n                   %\n                   %2)\n          ms))","user":"53c74cfce4b00fb29b2212a7"},{"code":"(fn [f & maps]\n  (letfn [(merge-reducer [acc m]\n            (reduce (fn [acc2 [k v]] \n              (if (contains? acc2 k) \n                (assoc acc2 k (f (get acc2 k) v)) \n                (assoc acc2 k v))) acc m))] \n  (reduce merge-reducer (first maps) (rest maps))))","problem":69,"user":"5142e808e4b0c172af7558c9"},{"code":"(fn [f & ms] (reduce (fn [m [k v]] (if (contains? m k) (update-in m [k] f v) (assoc m k v))) {} (apply concat ms)))","problem":69,"user":"507056b8e4b07bd6ad9b9f29"},{"problem":69,"code":"(fn [f & maps]\n  (reduce\n    (fn [result m]\n      (let [conflicts (keys (select-keys m (keys result)))]\n        (merge (conj result m)\n               (into {} (map (fn [k] (vector k (f (result k) (m k))))\n                             conflicts)))))\n    maps))","user":"5ab16992e4b073f1774425c4"},{"problem":69,"code":"(fn [f & ms]\n  (reduce (fn [acc n]\n            (reduce \n              (fn [r [k v]] \n                (assoc r k \n                         (if (contains? r k) \n                           (f (get r k) v) \n                           v))) \n              acc n)) \n          ms))","user":"55d28b38e4b0e31453f64a58"},{"code":"(fn [f & coll]\n  (reduce\n   (fn [m [k v]]\n     (if (contains? m k)\n       (assoc m k (f (m k) v))\n       (assoc m k v)))\n   {}\n   (mapcat #(concat %) coll)))","problem":69,"user":"4f8bbb27e4b02e764a0a5182"},{"problem":69,"code":"(fn my-mw [f m & ms]\n  (letfn [(update-if-present [m [key val]]\n            (let [existing-value (m key)] \n              (assoc m key (if existing-value\n                             (f existing-value val)\n                             val))))\n          (merge-map [m1 m2]\n            (reduce update-if-present m1 m2))]\n    (reduce merge-map m ms)))","user":"57a0f256e4b0c3d858beb8dd"},{"problem":69,"code":"(fn [f & maps]\n  (reduce into\n    (for [k (keys (reduce into maps))]\n      (->> maps\n           (map #(get % k))\n           (filter (complement nil?))\n           (reduce f)\n           (assoc {} k)))))","user":"53eb8ceae4b036ad0777e4fb"},{"problem":69,"code":"(fn mf [f & xs]  \n  (into {} (map (fn [[a b]] {a (if (= 1 (count b))  \n                                (second (first b)) \n                                (apply f (map second b)))}) \n                (group-by first (mapcat vec xs)))))","user":"55896a0ce4b059ccff29b204"},{"code":"(fn mwith [f o & m]\n  (loop [origin o more m]\n\t\t  (cond (empty? more) \n\t\t\t\torigin\n\t\t\t\t:else (recur (merge (first more) (zipmap (keys origin) \n\t\t\t\t\t\t\t\t\t (for [k (keys origin)] \n\t\t\t\t\t\t\t\t\t\t  (cond (contains? (first more) k) \n\t\t\t\t\t\t\t\t\t\t  (f (get origin k) (get (first more) k))\n\t\t\t\t\t\t\t\t\t\t  :else \n\t\t\t\t\t\t\t\t\t\t  (get origin k))\n\t\t\t\t\t\t\t\t\t  )\n\t\t\t\t\t\t\t  )) \n\t\t\t\t\t\t\t  (rest more)\n\t\t\t\t\t  )\n\t\t  )\n\t)\n)","problem":69,"user":"50588af1e4b06522596eba7d"},{"problem":69,"code":"(fn [f value & colls]\n  (loop [f f\n         value value\n         coll (first colls)\n         rest-colls (rest colls)]\n  \t(if (nil? coll)\n      value\n      (recur f \n      \t(reduce (fn [res k]\n        \t        (if (nil? (res k))\n                      (conj res {k (coll k)})\n            \t      (conj res {k (f (res k) (coll k))})))\n           \t    value \n           \t    (keys coll))\n        (first rest-colls)\n        (rest rest-colls)))))","user":"598e7998e4b02b9968b84d34"},{"problem":69,"code":"(fn\n  [f & maps]\n  (reduce (fn [result m]\n            (reduce (fn [result [k v]]\n                      (let [ev (get result k)]\n                        (if ev\n                          (assoc result k (f ev v))\n                          (assoc result k v))))\n                    result\n                    m))\n          (first maps)\n          (rest maps)))","user":"570c8ac3e4b0b0fb43fd06ca"},{"problem":69,"code":"(fn my-merge-with\n  [f & xs]\n  (reduce (fn [accum x]\n            (reduce (fn [accum [k v]]\n                      (assoc accum k (if-let [u (get accum k)] (f u v) v))) accum x))\n          (first xs)\n          (rest xs)))","user":"5c222b7de4b07e362c230588"},{"problem":69,"code":"(fn [f & ms]\n  (reduce (fn [acc m]\n            (into acc\n                  (for [[k v :as org] m]\n                    (if (contains? acc k)\n                      [k (f (acc k) v)]\n                      org))))\n          {}\n          ms))","user":"60b57acee4b0e0fa5f1b4238"},{"problem":69,"code":"(fn my-merge-with [f first-map & maps]\n  (let [key-and-bindings\n        (group-by first (apply concat [] first-map maps))] ;; groups each key with its corresponding bindings\n    (into {} (map #(vector\n                (first %)\n                (reduce f (map second (second %)))) key-and-bindings)))) ;; reduces the values in the bidings\n     ;; using the given function. Binds the keys to the single reduced values.","user":"55a9e0fee4b0988bba2ad945"},{"code":"(fn [g d & a] (reduce #(update-in % [(key %2)] (if (% (key %2)) (fn [v] (g v (val %2))) (fn [x] (val %2)))) d (mapcat vec a)))","problem":69,"user":"52c6a0abe4b0c2d177d62111"},{"code":"(fn [f & args]\n  (reduce\n    (fn [m1 m2]\n      (reduce\n        (fn [m [k v]]\n          (if (contains? m k)\n            (assoc m k (f (m k) v))\n            (conj m {k v}))) m1 (seq m2))) args))","problem":69,"user":"515a6151e4b0394f658fe241"},{"problem":69,"code":"(fn myfn [f & cols]\n  (let [ks (set (mapcat keys cols))]\n    (into (hash-map) (for [k ks]\n                       [k ((fn [el] (if (= 1 (count el)) (first el) (apply f el))) (->> cols (map #(get % k)) (remove nil?)))]))))","user":"56df254be4b0ca2494a095ea"},{"problem":69,"code":"(fn [f & ms]\n  (reduce\n   (fn [m1 m2]\n     (reduce\n      (fn [m1 [k v]]\n        (assoc m1 k\n          (if (contains? m1 k)\n            (f (m1 k) v)\n            v))) m1 m2))\n   {} ms))","user":"5a080bdde4b01bb0ae8afde9"},{"problem":69,"code":"(fn [f & ms]\n         (let [ks (apply sorted-set (flatten (map keys ms)))]\n           (into {}\n                 (for [k ks]\n                   [k (let [vs (for [m ms\n                                     :let [v (get m k)]\n                                     :when (not (nil? v))]\n                                 v)]\n                        (if (> (count vs) 1)\n                          (apply f vs)\n                          (first vs)))]))))","user":"5da71eaee4b000c986472c15"},{"code":"(fn [f m & ms]\n  (loop [i ms ret m]\n    (if i\n      (recur (next i)\n        (reduce (fn [a b] \n          (if-let [r (get a (key b))] \n            (assoc a (key b) (f r (val b)))\n            (assoc a (key b) (val b))))\n          ret (first i)))\n      ret)))","problem":69,"user":"4e8e8c24535d65386fec2143"},{"code":"(fn [f m & a]\r\n  (reduce\r\n    (fn [res el]\r\n      (reduce\r\n        (fn [arg1 arg2]\r\n          (let[mkey (first arg2)]\r\n           (if (contains? arg1 mkey )\r\n               (assoc arg1 mkey (f (get arg1 mkey) (second arg2)))\r\n               (assoc arg1 mkey (second arg2))) )) res el)) m a))","problem":69,"user":"5062bc46e4b05ac47bc68d68"},{"problem":69,"code":"(fn my-merge [f & ms]\n  (if (empty? (rest ms))\n    (first ms)\n    ;; loop over the keys of the second map, fitting them into the first one.\n    (loop [m1 (first ms)\n           m2 (second ms)]\n      (if (empty? m2)\n        ;; m1 and m2 are now combined.\n        (apply my-merge f m1 (drop 2 ms))\n        ;; Else, compare the keys of m2 and m1.\n        (let [[k v] (first m2)]\n          (if (contains? m1 k)\n            (recur (update-in m1 [k] f v) (rest m2)) \n            (recur (assoc m1 k v) (rest m2))))))))","user":"569f99cce4b0542e1f8d1497"},{"problem":69,"code":"(fn merge-with1 [f & ms]\n  (reduce (fn [m1 m2]\n            (reduce (fn [m k]\n                      (update-in m [k] (fn [m-val]\n                                    (if (= m-val nil) ;; k is not a key in m\n                                      (m2 k)\n                                      (f m-val (m2 k))))))\n                    m1 (keys m2)))\n          ms))","user":"60460824e4b02d28681c77bc"},{"code":"(fn m69 [f & maps] \n  (if (empty? maps)\n\t\t{}\n\t\t(\n\t\t\t(fn foo [f map-from map-to] \n\t\t\t\t(if (empty? map-from)\n\t\t\t\t\tmap-to\n\t\t\t\t\t(let [the-map (foo f (dissoc map-from (first (keys map-from))) map-to)\n\t\t\t\t\t\t  the-key (first (keys map-from))]\n\t\t\t\t\t\t(if (contains? the-map the-key)\n\t\t\t\t\t\t\t(assoc the-map the-key (f (map-from the-key) (the-map the-key)))\n\t\t\t\t\t\t\t(assoc the-map the-key (map-from the-key))\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t) \n\t\t\tf (first maps) (apply m69 f (rest maps)) \n\t\t)\n\n\t)\n)","problem":69,"user":"4e8d5edd535d65386fec2134"},{"problem":69,"code":"(fn [f og & ds]\n  (loop [ds ds og og]\n    (if (empty? ds)\n      og\n      (recur (next ds)\n        \t (loop [d (first ds) ks (keys d) og og] \n        \t \t(if (empty? ks)\n        \t \t\tog\n        \t \t\t(recur d\n        \t \t\t\t   (next ks)\n        \t \t\t\t   (if (nil? (get og (first ks)))\n        \t \t\t\t   \t\t(conj og [(first ks) (get d (first ks))])\n        \t \t\t\t   \t\t(conj og [(first ks) (f (get og (first ks)) (get d (first ks)))])))))))))","user":"553b87abe4b09218d5f45003"},{"problem":69,"code":"(fn [f m & ms]\n  (reduce (fn [m [k v]]\n            (if-let [me (find m k)]\n              (update-in m [k] f v)\n              (assoc m k v)))\n          m\n          (apply concat ms)))","user":"59074b7ce4b047aa04b19951"},{"code":"(fn [f d & m]\n  (reduce \n    (fn [o i] (assoc o (i 0) (if (nil? (o (i 0))) (i 1) (f (o (i 0)) (i 1))))) \n    d (apply merge m)))","problem":69,"user":"4f1d1d95535d64f603146488"},{"problem":69,"code":"(fn [f m & more]\n  (reduce (fn [acc mnext] \n              (reduce (fn [acc* [k v]] \n                          (assoc acc* k (if-let [acc-v (acc* k)]\n                                          (f acc-v v)\n                                          v)))\n                      acc \n                      (seq mnext)))\n          m\n          more))","user":"523b4e91e4b07becd5be21ef"},{"problem":69,"code":"(fn sol [func & maps]\n  (reduce\n    (fn [acc m]\n      (conj acc\n        (reduce\n          (fn [inacc tuple]\n            (if (contains? acc (tuple 0))\n              (assoc\n                inacc\n                (tuple 0)\n                (func\n                  (acc (tuple 0))\n                  (m (tuple 0))))\n              (conj inacc tuple))\n            )\n          {}\n          m)))\n    {}\n    maps))","user":"578b140be4b0ebec4cfb7545"},{"problem":69,"code":"#((fn mrg [f x u]\n    (if (empty? u)\n      x\n      (if (= (get x (first (first u))) nil)\n        (mrg f (assoc x (first (first u)) (second (first u))) (rest u))\n        (mrg f (assoc x (first (first u)) (f (get x (first (first u))) (second (first u)))) (rest u))))) %1 %2 (into [] (apply conj {} %&)))","user":"586b6a0ae4b01531a375e957"},{"problem":69,"code":"(fn merge-with*\n    ([f m1 m2]\n     (into m1\n           (for [[k v] m2]\n             (if (contains? m1 k)\n               [k\n                (f (get m1 k)\n                   (get m2 k))]\n               [k v]))))\n    ([f m1 m2 & maps]\n     (apply merge-with*\n            f\n            (merge-with* f m1 m2)\n            maps)))","user":"5be5cebde4b0ed4b8aab4d19"},{"problem":69,"code":"(fn [f m1 & more]\n (cond (empty? more) m1\n  (empty? (first more)) (recur f m1 (rest more))\n   :else   (let [m2 (first more) v (first m2) k (v 0) vv (v 1) m2r (rest m2)]\n         (if (contains? m1 k) \n           \t\t(recur f (assoc m1 k (f (m1 k) vv)) (cons m2r (rest more)))\n           \t\t(recur f (assoc m1 k vv) (cons m2r (rest more)))\n         ) \n       )\n   )\n )","user":"5be6d0f8e4b0f319e2d7ec51"},{"problem":69,"code":"(fn mw [op & maps]\n  (reduce  (fn [current next]\n             (merge current\n                    (into {}\n                       (map (fn [[k v]]\n                              [k (if (contains? current k)\n                                     (op (get current k) v)\n                                     v)])\n                            next))))\n           maps ))","user":"55f04526e4b06e875b46ce20"},{"problem":69,"code":"(fn [f m & ms] (reduce (fn [m1 m2]\n                 (reduce #(let [[k v] %2]\n                             (if-let [i (get % k)]\n                                (assoc % k (f i v))\n                                (assoc % k v))) m1 m2)) m ms))","user":"52f53589e4b05e3f0be25f2c"},{"problem":69,"code":"(fn [f & ms]\n  (let [mrg (fn [acc m] (reduce-kv (fn [m' k v] (assoc m' k (if (find m' k) (f (get m' k) v) v))) acc m))]\n    (reduce mrg {} ms)))","user":"597dcb0ce4b0dbe32238d0a2"},{"code":"(fn [f m & ms]\r\n  (reduce (fn [m n]\r\n     (reduce (fn [m [k v]]\r\n               (if-let [mv (m k)] (assoc m k (f mv v))\r\n                  (assoc m k v)))\r\n              m n))\r\n      m ms))","problem":69,"user":"4e8681b7535dae1a5effa438"},{"code":"(fn merma [f & maps]\n  (loop [mapvec maps result {}]\n    (if (empty? mapvec)\n        result\n        (recur (rest mapvec) \n               (loop [smap (first mapvec) res result]         \n                 (if (empty? smap)              \n                   res              \n                   (if (res (key (first smap)))                  \n                     (recur (rest smap) (conj res [(key (first smap)) \n                                                   (f (res (key (first smap))) (val (first smap)))] \n                                              ))                  \n                     (recur (rest smap) (conj res (first smap)))              \n                     )          \n                   )        \n                 )\n               )    \n        )  \n    )\n  )","problem":69,"user":"4fcf5292e4b03432b189f40e"},{"code":"(fn mer-with [op & maps]\n  (letfn [(get-keys [ & maps]\n                    (reduce into #{} (map keys maps)))\n          (single? [key maps]\n                   (= (count (filter #(not (nil? %)) (map #(% key) maps))) 1)) \n          (vl [key maps]\n              (filter #(not (nil? %)) (map #(% key) maps)))]\n         (let [ks (apply get-keys maps)]\n           (into {} (for [k ks]\n                      (if (single? k maps)\n                        [k (first (vl k maps))]\n                        [k (apply op (vl k maps))]))))))","problem":69,"user":"50e87427e4b0ebbe794eb7e8"},{"code":"(fn [f xa & xb]\n  (let [merg (fn [a b]\n               (let [k (key b) v (val b)]\n                 (if (contains? a k)\n                   (assoc a k (f (a k) v))\n                   (assoc a k v)\n                  ))\n               )\n        merge2 (fn [m1 m2] (reduce merg m1 m2))\n        ]\n    (reduce merge2 xa xb)\n    ))","problem":69,"user":"51da7e49e4b02ceefd947768"},{"problem":69,"code":"(fn [f & hs]\n   (reduce (fn [x y]\n             ((fn [ks a]\n                (if (empty? ks)\n                  a\n                  (let [v (first ks)]\n                    (if (x v)\n                      (recur (rest ks) (assoc a v (f (a v) (y v))))\n                      (recur (rest ks) (assoc a v (y v)))))))\n              (keys y) x))\n           (first hs) (rest hs)))","user":"53aaaf7ae4b047364c044444"},{"problem":69,"code":"(fn [f & maps]\n    (reduce (fn [map other]\n              (reduce (fn [m [k v2]]\n                        (let [v1 (get m k)]\n                          (assoc m k (if (nil? v1) v2 (f v1 v2))))\n                        ) map other)\n              ) maps)\n    )","user":"55aa5f73e4b0988bba2ad94b"},{"problem":69,"code":"(fn [f & maps]\n  (reduce\n    #(conj %\n       (reduce (fn [r [k v]]\n                   (let [rv (get r k)] (assoc r k (if rv (f rv v) v)))) % %2))\n    maps))","user":"59cd13d5e4b0ef0a1e9b5b32"},{"code":"(fn [op a & [b & c]]\n    (let [merger \n          (fn [a b]\n            (cond \n             (= (count b) 0) a\n             :else \n             \n             (recur \n              (conj a \n                    (let [fb (first b)\n                    q (first (filter #(= (key %) (key fb)) a))]\n                (if (nil? q) \n                  fb \n                  {(key fb) (op (val q) (val fb))})))\n              (drop 1 b))\n             ))]\n      (if (nil? b) \n        a\n        (recur op (merger a b) c)))\n       )","problem":69,"user":"5356ac72e4b04ce2eb3ed26a"},{"problem":69,"code":"(fn[f & maps]\n  (letfn [(f-merge-1 [f u v]\n            (letfn [(f-into [f m k]\n                      (if (m k)\n                        (into m {k (f (m k) (v k))})\n                        (into m {k (v k)})))]\n              (reduce #(f-into f %1 %2) u (keys v))))]\n    (reduce #(f-merge-1 f %1 %2) maps)))","user":"58a0fc33e4b02bd94d917ea3"},{"problem":69,"code":"(fn merge-with-f [f & cols]\n  (loop [res {}\n         curr-cols (reverse cols)] ;; reverse because the order of the maps is important for subtraction in tests\n    (if (empty? curr-cols)\n      res\n      (recur\n        (reduce (fn [col-acc new-elm]\n                  (assoc col-acc\n                    (key new-elm)\n                    (if (contains? col-acc (key new-elm))\n                      (f (val new-elm)\n                         (col-acc (key new-elm)))\n                      (val new-elm))))\n                res\n                (first curr-cols))\n        (rest curr-cols)))))","user":"5fbf6fe7e4b0ad6fc3476147"},{"problem":69,"code":"(fn p69s [opp coll & args]\n  (->> args\n      (into {})\n     (partition-by key)\n     (map #(if-not (nil? (find coll (first (keys %))))\n             (assoc {}\n              (first (keys %))\n              (opp (get coll (first (keys %))) (first (vals %))))\n             (assoc {}\n              (first (keys %))\n              (first (vals %)))\n             )\n      )\n     (into (sorted-map))\n       )\n\n  )","user":"5400e918e4b0de5c41848619"},{"problem":69,"code":"(fn  [f c & cols]\n  (reduce \n   #(reduce (fn [l r]\n              (let [k (key r)\n                    v (val r)\n                    w (get l k)]\n                (if w (assoc l k (f w v)) (assoc l k v)))) % %2)            \n    c cols))","user":"53b7c21ae4b047364c0444d4"},{"problem":69,"code":"(fn [f & cs]\n  (into {} (for [[k v] (group-by key (mapcat identity cs))]\n             (case (count v)\n               1 [k (get-in v [0 1])]\n               [k (apply f (map second v))] ))))","user":"56441634e4b0018b46ad8c08"},{"problem":69,"code":"(fn [f m & ms]\n  (into {} (for [current-map ms\n                 ks (keys current-map)]\n             (let [a (get m ks)\n                   b (get current-map ks)]\n               (cond\n                 (not-any? nil? [a b]) {ks (f a b)}\n                 (nil? a) {ks b}\n                 (nil? b) {ks a})))))","user":"53528cd3e4b084c2834f4af2"},{"problem":69,"code":"(fn sol [f & maps] (reduce (fn [acc, m] (into m (for [[k v] acc] (if (m k) [k (f v (m k))] [k v])))) (first maps) (rest maps)))","user":"54857657e4b0e286459a11ac"},{"code":"(fn [f & ms]\n  (letfn [(mym [f m1 m2]\n            (reduce (fn [m [k v]]\n                      (if (contains? m k)\n                        (assoc m k (f (m k) v))\n                        (conj m [k v])))\n                    m1\n                    m2))]\n  (reduce (partial mym f) ms)))","problem":69,"user":"5392b849e4b0b51d73faaeb1"},{"problem":69,"code":"(fn [f & maps]\n  (letfn [(merge-maps [map1 map2]\n            (reduce (fn [acc [k v]]\n                      (if-let [current (get acc k)]\n                        (assoc acc k (f current v))\n                        (assoc acc k v)))\n                    map1 map2))]\n    (reduce merge-maps {} maps)))","user":"5515b138e4b055c2f668d4ed"},{"problem":69,"code":"(fn [op & maps]\n  (letfn [(merge-one-with\n            [op result m]\n            (reduce\n             (fn [acc [k v]]\n               (update-in acc [k] #(if % (op % v) v)))\n             result\n             m))]\n    (reduce\n     (partial merge-one-with op)\n     {}\n     maps)))","user":"51ae350fe4b09397d5109790"},{"code":"(fn [f & input]\n  (let [keys (apply clojure.set/union (map #(set (keys %)) input))]\n    (apply merge (for [k keys]\n                   {k (reduce f\n                        (for [i input :when (contains? i k)]\n                          (i k)))}))))","problem":69,"user":"52667ecfe4b03e8d9a4a713e"},{"problem":69,"code":"(fn my-merge-with [f & maps]\n  (reduce\n    (fn [a b]\n      (reduce\n        (fn [x [k v]]\n          (assoc x k (if (b k) (f v (b k)) v)))\n        b a))\n(first maps) (rest maps)))","user":"592fa9f8e4b072a2710fcfcb"},{"code":"(fn mw [f & maps]\n  (reduce (fn [map entry] (update-in map \n                                     [(key entry)] \n                                     (fn [v] (if (nil? v) (val entry) (f v (val entry)))))) \n          {} \n          (apply concat maps)))","problem":69,"user":"51672d15e4b079759a74a5e7"},{"problem":69,"code":"(fn [f & maps] \n\n    (let [merge-entry (fn [m e]\n\t\t\t(let [k (key e) v (val e)]\n\t\t\t  (if (contains? m k)\n\t\t\t    (assoc m k (f (get m k) v))\n\t\t\t    (assoc m k v))))\n          merge2 (fn [m1 m2]\n\t\t   (reduce merge-entry (or m1 {}) (seq m2)))]\n\t(reduce merge2 maps)))","user":"55ed1dc5e4b0121d4835fdd4"},{"code":"(fn merge-with-fn [fun & maps]\n\t(reduce (fn [map1 map2] \n\t\t(loop [[key & rest] (keys map2) acc map1]\n\t\t\t(if (nil? key) acc\n\t\t\t\t(recur rest \n\t\t\t\t\t(if (contains? acc key)\n\t\t\t\t\t\t(assoc acc key (fun (get acc key) (get map2 key)))\n\t\t\t\t\t\t(assoc acc key (get map2 key))))))) maps))","problem":69,"user":"50ed8a5fe4b06330c1f87c3d"},{"problem":69,"code":"(fn mwith [f & args]\n  (let [k (distinct (apply concat (map keys args)))]\n    (letfn [(vals-for-k [ke] (loop [a args vls '()]\n                                (cond (empty? a) vls\n                                      (get (first a) ke) (recur (rest a) (concat vls (list (get (first a) ke))))\n                                      :else (recur (rest a) vls))))\n            (altr [f vls] (if (= (count vls) 1) (first vls) (apply f vls)))\n                                      \n                                      ]\n      (println (vals-for-k (first k)))\n      (zipmap k (map #(altr f %) (map vals-for-k k))))))","user":"60264d89e4b0d5df2af2222d"},{"problem":69,"code":"(fn [f & ms]\n  (reduce (fn [m k]\n            (assoc m k (reduce f (remove nil? (map #(get % k) ms)))))\n          {}\n          (flatten (map keys ms))))","user":"59fa241ee4b0ca45a743a358"},{"problem":69,"code":"(fn [f & maps]\n  (reduce\n   #(reduce (fn [r [k v]]\n              (assoc r k \n                     (if (r k) \n                       (f (r k) v)\n                       v)))\n             %\n             %2)\n   maps))","user":"5835cb06e4b089d5ab817cea"},{"problem":69,"code":"(fn conjur [f & maps]\n  (reduce\n   (partial (fn map2map [f map1 map2]\n  (let [keys1 (keys map1)\n        common-keys (keys (select-keys map2 keys1))\n        common-map (reduce #(assoc %1 %2 (f  (map1 %2) (map2 %2))) {} common-keys)]\n    (into (into map1 map2) common-map))) f)\n   maps)\n  \n  \n  \n  )","user":"55f8fd70e4b03cbcff9738bc"},{"code":"(fn [f & s](reduce (fn [a b] (merge a (->> b \n                                           (map #(vector (key %)\n                                                         (if-let [va (get a (key %))] \n                                                           (f va (val %)) \n                                                           (val %))))\n                                           (apply concat)\n                                           (apply hash-map)\n                                       )  )) s))","problem":69,"user":"526a3412e4b03e8d9a4a721e"},{"code":"(fn [f m & ms]\n  (reduce\n    (fn [result latter]\n      (reduce\n        (fn [acc [k v]]\n          (if-let [oldv (get acc k)]\n            (assoc acc k (f oldv v))\n            (assoc acc k v)))\n        result latter))\n    m ms))","problem":69,"user":"4eb2e6ca535d7eef3080734f"},{"code":"(fn [f & maps]\n  (let [merge-entry (fn [m e]\n          (let [k (first e) v (second e)]\n            (if (contains? m k)\n              (assoc m k (f (get m k) v))\n              (assoc m k v))))\n        merge2 (fn [m1 m2]\n            (reduce merge-entry m1 (seq m2)))]\n  (reduce merge2 maps)))","problem":69,"user":"50361b6be4b0fbe0a74d26be"},{"code":"(fn [f & s]\n  (into {} (map (fn [k] [k (reduce f (remove nil? (map #(% k) s)))]) (distinct (flatten (map keys s))))))","problem":69,"user":"522eb5cce4b01cdb292c5f0c"},{"code":"(fn [f & maps]\n  (reduce #(apply conj % (for [[k v] %2] [k (if (% k) (f (% k) v) v)])) maps))","problem":69,"user":"4ec5aa1f535d6d7199dd36b0"},{"problem":69,"code":"(fn ks [f & m] (apply merge (map (fn [y]  {(first y) (reduce f (second y))}) (for [item (set (reduce #(into (keys %2) %1) '() m))]\n                  [item (filter (complement nil?) (map #(get %1 item) m))]))))","user":"56427910e4b08d4f616f5f19"},{"problem":69,"code":"(fn [f & maps]\n  (let [allks (set (mapcat keys maps))]\n    (reduce\n      (fn [res k]\n        (assoc res k (reduce f (filter #(not(nil? %)) (map #(get % k) maps)))))\n      {} allks)))","user":"5b552117e4b02d533a91bd2c"},{"problem":69,"code":"#(reduce (fn [coll1 coll2] (assoc coll1 (first coll2) (if-let [k (get coll1 (first coll2))] (%1 k (second coll2)) (second coll2)))) %2 (apply merge %&))","user":"56c560ede4b05cc29241eea6"},{"problem":69,"code":";;Merge with a Function - https://www.4clojure.com/problem/69\n\n(fn my-merge-with [f m & more]\n  (letfn [(updater [v1 v2]\n            (if (nil? v1) v2\n                (f v1 v2)))]\n    (->> (reduce into [] more)\n         (reduce #(update-in %1 [(first %2)] updater (last %2)) m))))","user":"5666500ee4b0e91d5f5c566d"},{"problem":69,"code":"(fn [f first-m & rest-m]\n  (reduce (fn [m1 m2] \n            (reduce \n             #(if (contains? %1 %2) \n                (update-in %1 [%2] f (m2 %2)) \n                (conj %1 {%2 (m2 %2)})) \n             m1 (keys m2))) \n          first-m rest-m))","user":"5b77d3c8e4b047b03b2036f1"},{"problem":69,"code":"(fn m [f & ms]\n  (->> (mapcat identity ms)\n       (reduce #(assoc %1 (first %2) (conj (get %1 (first %2) []) (second %2))) {})\n       (mapcat (fn [[k v]] [k (reduce f v)]))\n       (apply hash-map)))","user":"58ca8a1de4b03c36ff7e5835"},{"problem":69,"code":"(fn [f & args]\n  (reduce\n    (fn [m1 m2]\n      (reduce (fn [m [k v]] (if (contains? m k)\n                              (update-in m [k] f v)\n                              (assoc m k v)))\n                              \n        m1\n        m2))\n    args))","user":"5ccf99fbe4b0ccb0619628c8"},{"problem":69,"code":"(fn [f & d]\n    (reduce \n      #( let [\n              k (first (keys %2)) \n              v (last (vals %2)) \n             ]\n        (assoc % k (if (nil? (% k)) v (f (% k) v)))\n        ) {} (#( for [ds d [k v] ds] {k v} ))))","user":"54fc7d89e4b07d26eda61d2b"},{"code":"(fn [op & maps]\n    (letfn [(f [op, m, o]\n              (let [km (set (keys m))\n                    ko (set (keys o))\n                    common-keys (clojure.set/intersection km ko)\n                    unique-m (clojure.set/difference km common-keys)\n                    unique-o (clojure.set/difference ko common-keys)]\n                (merge (into {} (for [k common-keys]\n                                  [k (op (m k) (o k))]))\n                       (into {} (for [k unique-m] [k (m k)]))\n                       (into {} (for [k unique-o] [k (o k)])))))]\n      (reduce (partial f op) maps)))","problem":69,"user":"4ee26f01535d10e5ff6f5368"},{"code":"(fn [func & maps] (reduce \n                         (fn [m1 m2] \n                           (let [ks (keys (conj m1 m2))]\n                             (zipmap ks \n                               (map #(cond \n                                 (nil? (m1 %)) (m2 %)\n                                 (nil? (m2 %)) (m1 %)\n                                 :default (func (m1 %) (m2 %))) \n                                 ks))))\n                         maps))","problem":69,"user":"4ee77f15535d93acb0a66868"},{"code":"(fn cust-merge-with [f m & args]\n  (reduce\n    (fn merge-map [m t]\n      (let [pairs (seq t)]\n        (reduce\n          (fn m-single [m t]\n            (let [v-in-m (get m (first t))]\n              (if (= nil v-in-m)\n                (conj m t)\n              (conj m {(first t) (f v-in-m (second t))}))))\n          m\n          t)))\n    m\n    args))","problem":69,"user":"52463059e4b09dbe66b56198"},{"code":"(fn [f main & maps]\n  (letfn\n    [(red [m e] \n               (if (contains? m (first e))\n                 (assoc m (first e) (f (get m (first e)) (second e)))\n          (conj m e)\n                 ))]\n    (reduce (fn [d s]\n              d\n              s\n              (reduce red d s)) main maps)))","problem":69,"user":"5191e91de4b08962174cf733"},{"problem":69,"code":"(fn [f base & others] (reduce \n                 (fn [res n] (let [k (key (first n))\n                                   v (val (first n))\n                                   curVal (res k)]\n                               (if curVal (assoc res k (f curVal v)) (conj res n)))) \n                 base (for [c others [k v] c] {k v})))","user":"55f2c898e4b06e875b46ce4b"},{"problem":69,"code":"(fn [f & ms]\n  (reduce\n   (fn [acc [key val]]\n     (let [old-val (acc key)\n           new-val (if (nil? old-val) val (f old-val val))]\n       (assoc acc key new-val)))\n   {}\n   (reduce concat (map seq ms))))","user":"5f37839ee4b0574c87022c59"},{"code":"(fn f [g m & [h & t]]\n  (if h\n    (apply f g (reduce (fn [n [a b]] (assoc n a (if (n a) (g (n a) b) b))) m h) t)\n    m))","problem":69,"user":"4ee82539535d93acb0a66878"},{"problem":69,"code":"(fn mw [f & maps]\n  (reduce (fn [s e]\n    (reduce (fn [t [k v]]\n        (if (t k)\n          (assoc t k (f (t k) v))\n          (conj t [k v])\n        )\n      )\n      s e\n    ))\n    maps\n  )\n)","user":"53d78b64e4b0e771c3025466"},{"code":"(fn [f & ms]\n    (let [merge-one (fn [m [k v]]\n                      (if (contains? m k)\n                        (assoc m k (f (m k) v))\n                        (assoc m k v)))\n          merge-all (fn [m1 m2]\n                      (reduce merge-one (or m1 {}) m2))]\n         (reduce merge-all ms)))","problem":69,"user":"4fe8a3bde4b07c9f6fd12c61"},{"problem":69,"code":"(fn mw [f m & maps]\n (letfn [(replacements [f orig new]\n          (into {}\n            (for [[k v] new]\n             (if (contains? orig k)\n              [k (f (orig k) v)]\n              [k v]))))]\n  (if (empty? maps)\n    m\n    (recur \n      f \n      (merge \n        m \n        (replacements f m (first maps)))\n      (rest maps)))))","user":"56b86e64e4b0f26550335924"},{"problem":69,"code":"(fn [f & args]\n  (->> (apply concat args)\n       (group-by key)\n       (map (fn [[k v]]\n              [k (reduce f (vals v))]))\n       (into {})))","user":"5dc88a38e4b02f9375f4e1db"},{"problem":69,"code":"(fn [f p & args]\n  (apply merge \n         (flatten \n          (for [a args]\n            (for [k (keys a)]\n              (if (nil? (find p k)) (assoc {} k (get a k))\n                (assoc {} k (f (get p k) (get a k)))))))))","user":"574abbfbe4b02ea114799200"},{"problem":69,"code":"(fn [cfn & maps]\n  (reduce (fn [x y] (let [p-keys (keys x)\n                          m-found (select-keys y p-keys)\n                          o-keys (keys m-found)\n                          new-vals (if (not-empty o-keys)\n                                     (apply merge (map (fn [k] {k (cfn (get x k) (get y k))}) o-keys))\n                                     {})]\n                      (merge x (merge y new-vals)))) maps))","user":"592883f1e4b072a2710fceea"},{"code":"(fn [f & maps]\r\n       (when (first maps)\r\n         (let [merge-entry (fn [m e] \r\n                             (let [k (key e)\r\n                                   v (val e)]\r\n                               (if (contains? m k)\r\n                                 (assoc m k (f (get m k) v))\r\n                                 (assoc m k v))))\r\n               merge2 (fn [m1 m2]\r\n                        (reduce merge-entry (or m1 {}) (seq m2)))]\r\n           (reduce merge2 maps))))","problem":69,"user":"4dbe19fe535d020aff1edf59"},{"code":"(fn [f & ms]\n   (reduce #(reduce (fn [tmm [k v]]\n                     (if (contains? tmm k)\n                       (assoc tmm k (f (tmm k) v))\n                       (assoc tmm k v)))\n                   % %2)\n           {} ms))","problem":69,"user":"52c25645e4b07a9af579237d"},{"code":"(fn [f & maps]\n  (reduce\n    (fn [m1 m2]\n      (reduce\n        (fn [m [k v]]\n          (assoc m k \n            (if-let [vold (get m k)] (f vold v) v)))\n        m1 m2))\n    maps))","problem":69,"user":"4f9d53f3e4b0dcca54ed6d21"},{"problem":69,"code":"(fn my-merge-with\n  ([func m1]\n   m1)\n  ([func m1 m2 & maps]\n   (apply my-merge-with\n          func\n          (reduce (fn [m [k v]]\n                    (assoc\n                     m k\n                     (if (contains? m k)\n                       (func (m k) v)\n                       v)))\n                  m1 m2)\n          maps)))","user":"57a4fa50e4b0a966079561f1"},{"code":"(fn mymerge [op m & more] ((fn mysubmerge [m s] (if s (mysubmerge (let [e {((first s) 0) ((first s) 1)} k (key (first e)) v1 (val (first e))] (if-let [v (m k)] (merge m {k (op v v1)}) (merge m e))) (next s)) m)) m (apply merge more)))","problem":69,"user":"5138d08be4b0a5db03d727db"},{"code":"(fn [f & m]\n  (reduce #(reduce \n    (fn[h [k v]] \n      (assoc h k (if (h k) (f (h k) v) v)))\n    % %2) m))","problem":69,"user":"4e12cc9d535d04ed9115e7d2"},{"problem":69,"code":"(fn [f & args]\n  (loop [l (rest args), acc (first args)]\n    (if-let [h (first l)]\n      (recur (rest l) (reduce\n                       #(let [[k v] %2]\n                          (conj % [k (if-let [x (% k)] (f x v) v)]))\n                       acc\n                       h))\n      acc)))","user":"57035ccfe4b08d47c97781ef"},{"code":"(fn my-merge-with [op & maps]\n  (loop [f-map (transient (first maps)) r-maps (rest maps)]\n    (if (empty? r-maps)\n      (persistent! f-map)\n      (let [n-map (first r-maps)]\n        (doseq [k (keys n-map)]\n          (if (nil? (get f-map k))\n            (assoc! f-map k (n-map k))\n            (assoc! f-map k (op (f-map k) (n-map k)))))\n        (recur f-map (rest r-maps))))))\n\n;(fn [f x & xs]\n;  (reduce\n;    (fn [rm sm]\n;      (reduce\n;        (fn [m [k v]]\n;          (if (contains? m k)\n;            (assoc m k (f (m k) v))\n;            (assoc m k v)))\n;        rm sm))\n;    x xs))","problem":69,"user":"4f849f76e4b033992c121c36"},{"problem":69,"code":"(fn do-merge-with\n  [f & maps]\n  (let [ks (distinct (mapcat keys maps))]\n    (reduce\n      (fn [acc k]\n        (let [values (filter (complement nil?) (map #(get % k) maps))\n              result (apply f values)]\n          (condp = (count values)\n            1 (assoc acc k (first values))\n            (assoc acc k result))))\n      {}\n      ks)))","user":"59b62f8de4b05c620303ca1f"},{"code":"(fn [f mp & mps]\n  (reduce #(reduce (fn [mp ky] \n                     (assoc mp ky (if-let [vl (mp ky)] (f vl (%2 ky)) (%2 ky)))) \n                   %1 \n                   (keys %2))\n          mp\n          mps))","problem":69,"user":"50645e12e4b007509339a58a"},{"problem":69,"code":"(fn [f & maps]\n  (apply merge \n       (map (fn [[k v]] \n              {k (if (< 1 (count v)) \n                   (apply f (map second v)) \n                   (second (first v)))})  \n            (group-by key (apply concat maps)))))","user":"53fcdd1ae4b0de5c418485dd"},{"problem":69,"code":"(fn [f m & ms]\n    (reduce (fn [m1 m2]\n              (reduce (fn [acc [k v]]\n                        (update-in acc [k] (fn [old]\n                                             (if (nil? old)\n                                               v\n                                               (f old v)))))\n                      m1 m2))\n            m ms))","user":"560e9a2de4b05f002753df52"},{"problem":69,"code":"(fn [f & maps]\n    (let [merge-entry (fn [m e]\n\t\t\t(let [k (key e) v (val e)]\n\t\t\t  (if (contains? m k)\n\t\t\t    (assoc m k (f (get m k) v))\n\t\t\t    (assoc m k v))))\n          merge2 (fn [m1 m2]\n\t\t   (reduce merge-entry (or m1 {}) (seq m2)))]\n      (reduce merge2 maps)))","user":"55b22c33e4b0da326a65cf79"},{"problem":69,"code":"(fn [f & ms]\n  (reduce (fn [am m]\n            (into am (for [[k v] m]\n                       (if (contains? am k)\n                         [k (f (am k) v)]\n                         [k v]))))\n          ms))","user":"5353afa0e4b084c2834f4b03"},{"code":"(fn [f m & rm]\n  (if-let [n (first rm)]\n    (recur\n     f\n     (reduce\n      #(if-let [v (get %1 %2)]\n         (assoc %1 %2 (f v (get n %2)))\n         (assoc %1 %2 (get n %2)))\n      m\n      (keys n))\n     (rest rm))\n    m))","problem":69,"user":"4f713878e4b07046d9f4f00a"},{"code":"(fn [f & maps]\n  (reduce\n   (fn [map1 map2]\n     (reduce\n      (fn [acc [k v]]\n        (if (contains? acc k)\n          (update-in acc [k] f v)\n          (assoc acc k v)))\n      map1\n      map2))\n   maps))","problem":69,"user":"507b7dbee4b09034bfeeb71e"},{"problem":69,"code":"(fn merge-with-fn [f & ms]\n  (reduce #(reduce (fn [acc [k v]]\n                     (if (acc k)\n                       (update-in acc [k] f v)\n                       (assoc acc k v)))\n                    %1\n                    %2)\n          {}\n          ms))","user":"5a67cedbe4b0512ff01cd9ee"},{"problem":69,"code":"(fn [f & ms]\n  (reduce\n    (fn [acc a]\n      (reduce (fn [acc [k v]]\n                (if (contains? acc k)\n                  ;(update acc k f v)\n                  (assoc acc k (f (acc k) v))\n                  (assoc acc k v)))\n              acc a)) ms))","user":"5338387de4b0e30313ee6c91"},{"problem":69,"code":"(fn [f m & maps]\n   (let [merge- (fn [m m1]\n                  (loop [m m m1 m1]\n                    (if (empty? m1)\n                      m\n                      (let [[k v] (first m1)]\n                        (if (contains? m k)\n                          (recur (assoc m k (f (get m k) v)) (rest m1))\n                          (recur (assoc m k v) (rest m1)))))))]\n     (loop [m m maps maps]\n       (if (empty? maps)\n         m\n         (recur (merge- m (first maps)) (rest maps))))))","user":"551a21ece4b091ff45eda993"},{"code":"(fn my-merge-with \n\t([f f-map s-map] \n\t\t(let [result-one (into {} (for [[k v] f-map]\n\t\t\t\t\t(if (s-map k)\n\t\t\t\t\t\t[k (f v (s-map k))]\n\t\t\t\t\t\t[k v]\n\t\t\t\t\t)\n\t\t\t\t )\n\t\t\t   )\n\t\t\t   result (into result-one \n\t\t\t\t\t\t(for [[k v] s-map]\n\t\t\t\t\t\t\t(when (not (contains? f-map k))\n\t\t\t\t\t\t\t\t[k v]\t\t\t\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t)\n\t\t\t\t)\n\t   \n\t\t ]\n\t\t result\n\t\t)\n\t)\n\t([f f-map s-map & more]\n\t\t(apply (partial my-merge-with f (my-merge-with f f-map s-map) ) more)\n\t)\n)","problem":69,"user":"52763696e4b03e8d9a4a74d7"},{"problem":69,"code":"(fn [f & m]\n  (let [[b & r] m\n        r (mapcat vec r)]\n    (reduce (fn [a [k v]]\n              (if (a k)\n                (update-in a [k] #(f % v))\n                (assoc-in a [k] v))) b r)))","user":"51a4d802e4b0def3c5c5869a"},{"problem":69,"code":"(fn my-merge-with [f & maps]\n  (reduce\n    (fn my-merge [m1 m2]\n      (reduce (fn [acc [k v]]\n                (assoc acc k (if (contains? acc k)\n                               (f (get acc k) v)\n                               v))) m1 m2))\n      (first maps) (rest maps)))","user":"567c7fefe4b05957ce8c61bc"},{"code":"(fn [f & ms]\n  (reduce\n    (fn [acc x]\n      (reduce\n        #(if (% (first %2))\n          (assoc %\n            (first %2)\n            (f (% (first %2)) (second %2)))\n          (assoc % (first %2) (second %2)))\n        acc\n        x))\n    ms))","problem":69,"user":"4fb1325de4b081705acca276"},{"problem":69,"code":"(fn [x & m] (into {} (for [k (reduce #(into %1 (keys %2)) #{} m)]\n                   [k (reduce x (filter #(not (nil? %)) (map #(get % k) m)))])))","user":"57dafe97e4b0bd073c20241c"},{"code":"(fn [f & maps]\n  (letfn [(mergewith [m1 m2]\n              (let [ks (into (keys m1) (keys m2))]\n                (loop [ks ks m {}]\n                  (if (empty? ks)\n                    m\n                    (let [k (first ks)\n                          in1 (contains? m1 k)\n                          in2 (contains? m2 k)]\n                      (if (true? in1)\n                        (if (true? in2)\n                          (recur (rest ks) (assoc m k (f (get m1 k) (get m2 k))))\n                          (recur (rest ks) (assoc m k (get m1 k))))\n                        (recur (rest ks) (assoc m k (get m2 k)))))))))]\n      (reduce mergewith maps)))","problem":69,"user":"4e88feef535d8b9bb0147ca8"},{"code":"(fn x ([f m1 m2 & ms] (apply x f (conj m2 (into {} (for [[k x] m1] [k (let [y (m2 k)] (if y (f x y) x))]))) ms))\n    ([f m] m))","problem":69,"user":"4ea41fc2535d7eef308072cb"},{"problem":69,"code":"(fn [afunc & input]\n  (letfn [(replace-val [amap afunc akey avalue]\n                       (assoc amap akey (if (nil? (get amap akey)) avalue (afunc (get amap akey) avalue))))\n          (replace-map [amap another-map afunc]\n                       (reduce #(replace-val %1 afunc (key %2) (get another-map (key %2)))\n                                amap\n                                another-map))]\n    (reduce\n     #(replace-map %1 %2 afunc)\n     {}\n     input)))","user":"57b9fb56e4b0fbc9809a27fa"},{"code":"(fn [f & maps]\n  (reduce\n   (fn [a b]\n     (->> (set (concat (keys a) (keys b)))\n          (mapcat (fn [k]\n                    (let [a-has (contains? a k)\n                          b-has (contains? b k)]\n                      (cond\n                       (and a-has b-has) [k (f (a k) (b k))]\n                       a-has [k (a k)]\n                       b-has [k (b k)]))))\n          (apply hash-map))) maps))","problem":69,"user":"52b65f26e4b0c58976d9ad43"},{"problem":69,"code":"(fn [f & maps]\n  (letfn [(merge-entry [map key val]\n            (assoc map\n              \t   key\n              \t   (if (contains? map key) \n                     (f (get map key) val) \n                     val)))\n          (merge-maps [map1 map2]\n            (reduce #(merge-entry %1 (key %2) (val %2)) map1 map2))]\n    (reduce merge-maps maps)))","user":"56442758e4b0018b46ad8c0a"},{"code":"(fn [f m & ms] \n  (reduce\n   (fn [m1 m2] \n     (reduce \n      (fn [a b] \n        (if (contains? a (first b)) \n          (update-in a [(first b)] #(f % (second b))) \n          (apply assoc a b))) m1 m2))\n   m \n   ms))","problem":69,"user":"52aad30ce4b0c58976d9ac6d"},{"problem":69,"code":"(fn [f & ms]\n  (let [vs\n        (reduce   \n          (fn [acc m]\n            (reduce \n              (fn [ac k] (assoc ac k (concat (get ac k []) (vector (get m k))))) \n              acc (keys m))) {} ms)]\n    (reduce \n      (fn [acc k]\n        (let [v (vs k)]\n          (if (= (count v) 1)\n            (assoc acc k (first v))\n            (assoc acc k (apply f v))))) {} (keys vs))))","user":"57d9bca1e4b0bd073c202405"},{"problem":69,"code":"(fn [f & ms]\n  (reduce\n   (fn [acc m]\n     (reduce (fn [kvs [k v]]\n               (assoc kvs k\n                 (if (contains? kvs k)\n                  (f (kvs k) v)\n                  v)))\n             acc\n             m)\n     )\n   {}\n   ms))","user":"4ff24a1ae4b0678c553fc337"},{"code":"(fn [f & maps]\n  (reduce (fn [r m]\n            (reduce (fn [r2 [k v]]\n                      (if (contains? r2 k)\n                        (assoc r2 k (f (get r2 k) v))\n           \t\t\t\t\t\t\t(assoc r2 k v))) r m))\n          {}\n          maps))","problem":69,"user":"50589113e4b06522596eba7f"},{"problem":69,"code":"(fn [f & args]\r\n  (let [aux (fn [f2 m acc2]\r\n                 (reduce (fn [acc3 nxt2] \r\n                           (if (acc3 (first nxt2)) \r\n                             (assoc acc3 (first nxt2) (f2 (acc3 (first nxt2)) (second nxt2) ))\r\n                             (conj acc3 nxt2)))\r\n                          acc2 \r\n                          (vec m)))]\r\n        (reduce (fn [acc nxt] \r\n                   (aux f nxt acc))\r\n                   {}\r\n                   args)))","user":"59fa5773e4b0ca45a743a35e"},{"problem":69,"code":"(fn [f i & maps]\n  (reduce (fn [j [k v]] (merge j (hash-map k (if (nil? (get i k)) v (f (get i k) v))))) i (apply merge maps)))","user":"551c66dae4b07993ea3788de"},{"problem":69,"code":"(fn my-merge-with [f & maps] \n  (reduce \n   (fn [result [k v item]] \n     (if-let [rv (result k)]\n       (assoc result k (f rv v))\n       (assoc result k v))) \n   {} \n   (apply concat maps))\n  )","user":"53f35c34e4b0742d9025b0f4"},{"problem":69,"code":";(fn my-merge-with [f & maps]\n;  (let [ks (keys (apply merge maps))\n;        vs (map #(filter (complement nil?) %) \n;                (for [k ks] (map #(get % k) maps)))]\n;      (zipmap ks (map #(reduce f %) vs))))\n\n;(fn my-merge-with-better [f & maps]\n;  (into {} \n;        (for [e maps [k v] e]\n;          (if (contains? e k) \n;              [k (f (e k) v)] \n;              [k v]))))\n\n(fn my-merge-with-best [f & maps]\n  (->> (for [m maps [k v] m] [k v])\n       (group-by first)\n       (reduce-kv #(assoc %1 %2 (reduce f (map second %3))) {})))","user":"581b19e7e4b04b46fc4b0ec4"},{"problem":69,"code":"(fn [f & maps] \n   (let [ks (distinct (mapcat keys maps))] \n     (zipmap ks \n             (map (fn [k] \n                    (reduce f (map #(%1 k) (filter #(contains? %1 k) maps))))\n                  ks))))","user":"59ba2ea0e4b0a024fb6ae3e1"},{"code":"(fn m-with [f & maps]\n  (reduce \n    (fn [result [k v]]\n      (assoc result k\n        (if-let [oldv (get result k)]\n          (f oldv v)\n          v)))\n    {}\n    (apply concat (for [m maps]\n      (for [k (keys m)] [k (get m k)])))))","problem":69,"user":"4f215350e4b0d66497709fd0"},{"problem":69,"code":"(fn [f m & maps]\n        (reduce\n            (fn [acc o]\n                (reduce\n                    (fn [a k]\n                        (if (get a k)\n                            (assoc a k (f (get a k) (get o k)))\n                            (assoc a k (get o k))\n                        ))\n                    acc\n                    (keys o)\n                )\n            )\n            m\n            maps\n        )\n    )","user":"5a66fddee4b0512ff01cd9d7"},{"code":"(fn mw [f & maps]\n  (let [merge-entry (fn [m e]\n                      (let [k (key e) v (val e)]\n                        (if (contains? m k)\n                          (assoc m k (f (get m k) v))\n                          (assoc m k v))))\n        merge2 (fn [m1 m2]\n                 (reduce merge-entry m1 (seq m2)))\n        ]\n    (reduce merge2 maps)))","problem":69,"user":"52196842e4b0890f2f822bfa"},{"code":"(fn [f & maps]\r\n    (let [mergeone (fn [m e]\r\n                     (let [k (key e) v (val e)]\r\n                       (assoc m k (if (m k) (f (m k) v) v))))\r\n          mymerge (fn [map1 map2]\r\n                    (reduce mergeone (or map1 {}) (seq map2)))]\r\n      (reduce mymerge maps)))","problem":69,"user":"4e8768f6535dceadca469850"},{"code":"(fn mergewith [f & ms]\n  (let [merge-key (fn [m1 [k v]]\n                    (if (contains? m1 k)\n                      (assoc m1 k (f (m1 k) v))\n                      (assoc m1 k v)))]\n    (reduce (partial reduce merge-key) {} ms)))","problem":69,"user":"4f7f0827e4b06e829148e1d5"},{"problem":69,"code":"(fn [f & maps] (let [mef (fn [m [k v]] (if (contains? m k)\n                                        (assoc m k (f (get m k) v))\n                                        (assoc m k v)))\n                    mmf (fn [m1 m2] (reduce mef m1 (seq m2)))]\n                 (reduce mmf maps)))","user":"549a176ce4b0f3d1d8e70f69"},{"code":"(fn [predicate & args]\r\n    (reduce (fn [m   [k v]]\r\n              (let [p   (get m k)\r\n                    n   (if (nil? p)\r\n                          v \r\n                          (predicate p v))]\r\n                (assoc m k n))) \r\n            {} (mapcat concat args)))","problem":69,"user":"4f3e6244e4b0e243712b1f85"},{"code":"#(reduce (fn [m1 m2]\n          (reduce (fn [m [k v]]                      \n                      (assoc m k (if (m k) (% (m k) v) v)))                        \n            m1 m2))\n  %&)","problem":69,"user":"515e8ce2e4b049add99a053d"},{"problem":69,"code":"(fn mmw [f & ms]\n  (if (< (count ms) 2)\n    (first ms)\n    (let [m1 (first ms)\n          m2 (second ms)\n          mr (drop 2 ms)\n          nm (merge m1 (into {}\n                             (for [[k v2] m2]\n                               (let [v1 (get m1 k)]\n                                 (if (nil? v1)\n                                   [k v2]\n                                   [k (f v1 v2)])))))]\n      (apply mmw f nm mr))))","user":"55dcb06ee4b050e68259b3b9"},{"code":"(fn [func & maps] \n  (let [joined (reduce (fn [join [k v]] (assoc join k (conj (get join k [] ) v))) {} (apply concat maps))]\n    (apply hash-map (mapcat (fn [[k,v]] [k,(if (seq (rest v)) (apply func v) (first v))]) joined))))","problem":69,"user":"4f04b66b535dcb61093f6bdd"},{"problem":69,"code":"(fn [o & a]\n  (into {} (for [k (set (reduce into (map keys a)))]\n             {k (reduce o (for [m a\n                                :when (contains? m k)]\n                            (get m k)))})))","user":"51ab70c3e4b04e3dc0c27b33"},{"code":"(fn [f map1 & maps]\n  (reduce\n    #(let [acc %1 k (key %2) v (acc k) new-v (val %2)]\n      (assoc acc k (if v (f v new-v) new-v)))\n    map1\n    (mapcat (partial into []) maps)))","problem":69,"user":"4f725466e4b07046d9f4f030"},{"code":"(fn [f & maps]\n  (->> maps\n      (mapcat seq)\n      (group-by first)\n      (reduce\n        (fn [rv [k vs]]\n          (assoc rv k (->> (map second vs)\n                           (reduce f))))\n        {})))","problem":69,"user":"4dc0ff08535d020aff1edf84"},{"code":"(fn [f & ms]\n  (let [ks (set (apply concat (map keys ms)))\n        merge (fn [k]\n                (let [vals (filter (comp not nil?)\n                                   (map #(get % k) ms))]\n                  (if (= (count vals) 1)\n                    (nth vals 0)\n                    (apply f vals))))]\n    (apply hash-map\n           (apply concat\n                  (map #(vector % (merge %))\n                       ks)))))","problem":69,"user":"4f84a4a4e4b033992c121c39"},{"problem":69,"code":"(fn [f & maps]\n  (reduce (fn [m1 m2]\n            (reduce (fn [m [k v]]\n                      (if (m k)\n                        (update-in m [k] f v)\n                        (assoc m k v)))\n                    m1 m2))\n          maps))","user":"54ab1b5ae4b09f271ff37cc2"},{"code":"(fn m [f i & a]\n  (reduce\n    (partial reduce (fn [m [k v]]\n      (assoc m k\n        (if (contains? m k)\n          (f (m k) v)\n          v)))) \n   i a))","problem":69,"user":"513b43ede4b067e25a345ed3"},{"code":"(fn [f m & args] (reduce (fn [mp [k v]] (if (not (nil? (get mp k))) (assoc mp k (f (get mp k) v)) (assoc mp k v))) m (apply merge args)))","problem":69,"user":"53a1b5c8e4b0ca733b9744c1"},{"code":"(fn [f & maps]\n  (reduce (fn [result m]\n            (into result (map (fn [[k v]]\n                                [k (if (contains? result k) (f (get result k) v) v)])\n                              m)))\n          maps))","problem":69,"user":"511623cbe4b0d4f670fd2fe1"},{"code":"(fn [f & maps]\n            (into {} (for [[k vs] (group-by key (apply concat maps))]\n                       [k (reduce f (vals vs))])))","problem":69,"user":"4ed0e139535d44c135fd68c7"},{"problem":69,"code":"(fn [f & ms]\n  (reduce (fn [rm m]\n            (into (into rm \n                        (filter (fn [[k v]] (not (rm k))) (seq m)))\n                  (map (fn [[k v]] [k (f (rm k) v)]) (filter (fn [[k v]] (rm k)) (seq m)))))\n                        ms))","user":"55316b8ae4b076ab5578f825"},{"problem":69,"code":"(fn [f & maps]\n    (let [merge-entry\n          (fn [map1 entry]\n            (let [key1 (key entry) val1 (val entry)]\n                 (if (contains? map1 key1)\n                   (assoc map1 key1 (f (get map1 key1) val1))\n                   (assoc map1 key1 val1))))\n          merge-maps\n          (fn [map1 map2]\n            (reduce merge-entry map1 map2))]\n      (reduce merge-maps maps)))","user":"57235dc4e4b0c5bde472c0e2"},{"problem":69,"code":"(fn [f & maps]\n   (let [all-keys (seq ((fn [f maps]\n                          (reduce (fn [ans n] (clojure.set/union ans (set (keys n))))\n                                  #{}\n                                  maps))\n                        f maps))\n         get-attr (fn [attr]\n                    (reduce f (remove nil? (map #(% attr) maps))))]\n     (reduce (fn [a b]  (assoc a b (get-attr b))) {} all-keys))\n   )","user":"5473efc3e4b0c51c1f4d7285"},{"problem":69,"code":"(fn f69 [f & coll]\n   (let [pre (fn [m me]\n               (let [k (key me)\n                     v (val me)]\n                 (if (nil? (m k))\n                   (assoc m k v)\n                   (assoc m k (f (m k) v)))))\n         next (fn [m1 m2]\n                (reduce pre m1 (seq m2)))]\n     (reduce next coll)))","user":"57bbc9bde4b05aa3c4741c31"},{"problem":69,"code":"(fn [f & maps]\n  (reduce #(merge % (zipmap (keys %2) \n                            (map (fn [k] (if (% k)\n                                           (f (% k) (%2 k))\n                                           (%2 k))) (keys %2)))) \n          {} maps))","user":"53e9a15be4b036ad0777e4ae"},{"problem":69,"code":"(fn [f m & ms]\n   (into {} (for [rm ms\n                  k (keys rm)]\n              (if (get m k)\n                {k (f (get m k) (get rm k))}\n                {k (get rm k)})\n\n              ))\n\n   )","user":"542b764ae4b0dad94371f28d"},{"problem":69,"code":"(fn [f m & ms]\n  (loop [out m in ms]\n    (if (empty? in)\n      out\n      (recur\n        (reduce \n          (fn [r [k v]] (assoc r k (if (contains? r k) (f (get r k) v) v)))\n          out\n          (first in))\n        (rest in)))))","user":"564a5a09e4b0284900eef656"},{"problem":69,"code":"(fn [f & maps]\n  (reduce (fn [acc curr]\n            ;(println (type acc) acc)\n            (let [mapping (filter #(not (nil? %))\n                                  (map (fn [[k v]]\n                                         (println (get acc k) v)\n                                         (if (contains? acc k)\n                                           {k (f (get acc k) v)}\n                                           {k v}))\n                                       curr))]\n              (println mapping (into acc mapping))\n              (into acc mapping)))\n          maps))","user":"5c44f0fde4b0e06e1360a384"},{"code":"(fn m [o & xs]\n  (reduce (fn f [m1 m2]\n    (reduce (fn [m1 [k v]]\n      (if (contains? m1 k)\n          (assoc m1 k (o (m1 k) v))\n          (assoc m1 k v)))\n      m1 (seq m2)))\n  {} xs))","problem":69,"user":"504e04a4e4b078edc5f59397"},{"code":"(fn merge-maps [f & maps]\n         (letfn [(merge-entity [m e]\n                     (let [k (key e) v (val e)]\n                       (if (contains? m k)\n                         (assoc m k (f (get m k) v))\n                         (assoc m k v))))\n                 (merge-map [m1 m2] (reduce merge-entity m1 (seq m2)))]\n           (reduce merge-map {} (seq maps))))","problem":69,"user":"4f1bee08535d64f60314647e"},{"problem":69,"code":"(fn [foo & ms]\n   (reduce (fn [acc [k v]]\n             (if (contains? acc k)\n               (update-in acc [k] foo v)\n               (assoc acc k v)))\n           {}\n           (apply concat ms)))","user":"5c30da5ae4b0d62ef62d9f23"},{"code":"(fn [o s & r]\n          (reduce\n           #(reduce\n             (fn [s [k v]]\n               (assoc\n                   s k\n                 (if (s k) (o (s k) v) v)))\n             % %2)\n           s r))","problem":69,"user":"503b6995e4b07a1917cc34dd"},{"code":"(fn g [f & [m1 & [m2 & maps :as mm]]]\n  (if (nil? maps)\n    (reduce (fn [m [k v]]\n              (if (m k)\n                (assoc m k (f (m k) v))\n                (assoc m k v)))\n            m1 m2)\n    (g f m1 (apply g f mm))))","problem":69,"user":"51efd397e4b0249c592fbdeb"},{"code":"#(letfn [\n    (g [m e]\n      (let [k (key e) v (val e)]\n        (if (contains? m k)\n          (assoc m k (% (m k) v))\n          (assoc m k v))))\n    (h [m n]\n      (reduce g (or m {}) (seq n)))]\n  (reduce h %&))","problem":69,"user":"4e03c616535d04ed9115e796"},{"problem":69,"code":"(fn [f & m]\n  (let \n    [ks (set (apply concat (map keys m)))]\n    (reduce (fn [d k] \n              (assoc d k (apply \n                           (fn [& args] \n                             (if (< 1 (count args)) \n                               (apply f args) \n                               (first args))) \n                           (filter (comp not nil?) (map #(get % k) m)))))\n            {} \n            ks)))","user":"5550bcece4b00713264bd9ae"},{"problem":69,"code":"(fn m-with\n  [f & maps]\n    (reduce \n      (fn [r m]\n        (reduce \n          (fn [mp k] \n             (assoc mp k \n               (if (contains? mp k) \n                  (f (mp k) (m k)) \n                  (m k))))\n          r \n          (keys m)))\n      (first maps) \n      (rest maps)))","user":"526c669be4b03e8d9a4a728f"},{"code":"(fn [f & l]\n  (let [g (group-by first (apply concat (map #(apply list %) l)))]\n    (zipmap (keys g) (map #(reduce f (map second %)) (vals g)))))","problem":69,"user":"5349ac2be4b084c2834f4a67"},{"problem":69,"code":"(fn merge-with'\n  [f & maps]\n  (letfn [(go [m1 m2]\n            (let [g (fn [acc [k v']]\n                      (if-let [v (get acc k)]\n                        (assoc acc k (f v v'))\n                        (assoc acc k v')))]\n              (reduce g m1 m2)))]\n    (reduce go maps)))","user":"56488119e4b0284900eef632"},{"code":"(fn merge-with* [f m & ms]\n  (if (empty? ms)\n    m\n    (let [c (fn [acc kv]\n      (let [k (key kv), v (val kv)]\n        (if (contains? acc k)\n          (assoc acc k (f (get acc k) v))\n          (conj acc kv))))]\n      (reduce #(reduce c %1 %2) m ms))))","problem":69,"user":"4e691c79535d8ccf87e9fe97"},{"code":"(fn [f m1 & ms]\n  (letfn [(my-merge [f m n]\n            (reduce \n              #(assoc % %2 \n                (let [a (% %2) b (n %2)] \n                  (if a (f a b) b))) m (keys n)))]\n   (reduce #(my-merge f % %2) m1 ms)))","problem":69,"user":"4fdb02aae4b05e33b9224f56"},{"problem":69,"code":"(fn mymergew [f m1 m2 & ms]\n  (let [dupemap (select-keys m2 (keys m1))]\n    (if m2\n      (apply mymergew f\n             (merge\n              m2\n              m1\n              (into {} (for [[k v] dupemap]\n                         [k (f (get m1 k) v)])))\n             (first ms)\n             (rest ms))\n      m1)))","user":"4ff9a200e4b0678c553fc3ab"},{"problem":69,"code":"(fn custom-merge-with2\n  [f m & maps]\n  (letfn [(merge-maps\n            [f m1 m2]\n            (loop [res m1 l (seq m2)]\n              (if (nil? l)\n                res\n                (let [[k v] (first l)]\n                  (if (contains? res k)\n                    (recur (assoc res k (f (get res k) v)) (next l))\n                    (recur (assoc res k v) (next l))\n                    )\n                  )\n                )\n              )\n            )]\n    (reduce #(merge-maps f %1 %2) m maps)\n    )\n\n  )","user":"5c20b6abe4b07e362c230576"},{"problem":69,"code":"(fn mv [f & start-maps]\n  (loop [result (first start-maps) current-map (second start-maps) maps (drop 2 start-maps)]\n    (if current-map\n\t  (recur (reduce-kv \n\t             (fn [m k v] \n\t\t\t\t   (if (m k) \n\t\t\t\t     (assoc m k (f (m k) v)) \n\t\t\t\t\t (assoc m k v))) \n\t\t\t\t  result \n\t\t\t\t  current-map) \n\t\t\t (first maps) \n\t\t\t (rest maps))\n\t\n\t  result)))","user":"51eec1a6e4b0871fa145d98d"},{"code":"(fn my_merge[f & maps]\r\n  (reduce #(let [prom \r\n\r\n\r\n\r\n   \t(into {} (map \r\n\r\n\r\n      (fn [x](if (find %2 (key x)) \r\n      (into {} (vector [(key x) (f (val x) (second (find %2 (key x))))]) )\r\n        x ))  %1)) \r\n\r\n\r\n      ] \r\n\r\n\r\n      (into {} (concat prom (into {}(map (fn [t] (if (= nil (find  prom (key t))) t )) %2)))\r\n\r\n\r\n          ))\r\n          {} maps\r\n))","problem":69,"user":"5065bd94e4b0148eb3925aed"},{"problem":69,"code":"(fn [f & maps]\n  (letfn [(combine-map [m1 m2]\n                       (if (empty? m2)\n                         m1\n                         (let [[k v] (first m2)]\n                           (recur (assoc m1 k\n                                   \t(if (m1 k)\n                                      (f (m1 k) v)\n                                      v))\n                                  (rest m2)))))]\n    (reduce combine-map maps)))","user":"551ed214e4b08d5046aa8a4d"},{"problem":69,"code":"(fn [f & maps]\n  (when (some identity maps) \n    (let [merge-entry (fn [m e] \n                        (let [k (key e) v (val e)] \n                          (if (contains? m k) \n                            (assoc m k (f (get m k) v)) \n                            (assoc m k v)))) \n          merge2 (fn [m1 m2] \n                   (reduce merge-entry (or m1 {}) (seq m2)))] \n      (reduce merge2 maps))))","user":"57750460e4b0979f8965160c"},{"problem":69,"code":"(fn merge-with* [p & xs]\n  (->> xs\n       (reduce concat)\n       (group-by first)\n       (reduce #(merge %1 (hash-map (first %2) (map second (second %2)))) {})\n       (reduce #(merge %1 (hash-map (first %2) (reduce p (second %2)))) {})))","user":"5ec3a13ae4b08d0ec38692b9"},{"problem":69,"code":"(fn [f & r]\n    (reduce (fn [m om]\n              (merge m (into {}\n                             (for [[k v] om]\n                               (if (m k)\n                                 [k (f (m k) v)]\n                                 [k v])))))\n            r))","user":"4e38f245535deb9a81d77f3e"},{"problem":69,"code":"(fn [f & ms]\n  (reduce \n   (fn [s e] (apply (partial assoc s)\n                    (apply concat\n                       (for [me e\n                             :let [k (first me)\n                                   v (second me)\n                                   vs (s k)]]\n                        [k (if (nil? vs) v (f vs v))])))) \n   ms))","user":"57c94c54e4b05aa3c4741d2c"},{"code":"(fn [r f & c]\n  (r #(r (fn [m [k v]]\n           (assoc m k (if (m k)\n                        (f (m k) v)\n                        v)))\n         % %2)\n     c))\nreduce","problem":69,"user":"51ad244fe4b09397d510977f"},{"problem":69,"code":"(fn\n  [f & args]\n  (reduce (fn [outer-acc in]\n            (reduce (fn [inner-acc [k v]]\n                      (if (contains? inner-acc k)\n                        (assoc inner-acc k (f (get inner-acc k) v))\n                        (assoc inner-acc k v))\n                      )\n                    outer-acc\n                    in)\n            )\n          {}\n          args)\n  )","user":"54e5bdf2e4b024c67c0cf7fe"},{"problem":69,"code":"(fn merge-with* [f & ms]\n  (reduce\n    #(reduce (fn [m [k v]] \n               (assoc m k (if (m k) (f (m k) v) v))) %1 %2)\n    ms))","user":"5bea3177e4b0f319e2d7ec81"},{"problem":69,"code":"(fn __\n  [f & args]\n (->> args\n      (reduce into [])\n      (reduce (fn [x v]\n                (if (get x (first v))\n                  (assoc x (first v) (f (get x (first v)) (second v)))\n                  (assoc x (first v) (second v))))\n              {})))","user":"5b73e500e4b047b03b2036ba"},{"code":"(fn mer [f & ms]\n  (letfn [(merge-two [m1 m2]\n                     (loop [pairs (seq m2)\n                            m m1]\n                       (if-not (seq pairs)\n                         m\n                         (let [[k vlat] (first pairs)]\n                           (recur (rest pairs)\n                                  (assoc m k (if-let [vres (m k)]\n                                               (f vres vlat)\n                                               vlat)))))))]\n  \n    (reduce merge-two ms)))","problem":69,"user":"52d3f666e4b09f7907dd1327"},{"code":"(fn merge-maps [f & maps]\n  (loop [current-map (first maps)\n         rest-maps (rest maps)\n         current-pair (first current-map)\n         rest-pairs (rest current-map)\n         res {}]\n    (cond\n     (nil? current-map) res\n     (nil? current-pair) (recur (first rest-maps) (rest rest-maps) (first (first rest-maps)) (rest (first rest-maps)) res)\n     true (recur current-map rest-maps (first rest-pairs) (rest rest-pairs) (if (nil? (get res (first current-pair)))\n                                                                              (assoc res (first current-pair) (last current-pair))\n                                                                              (assoc res (first current-pair) (f (get res (first current-pair)) (last current-pair))))))))","problem":69,"user":"52d7b0ade4b09f7907dd137c"},{"problem":69,"code":"(fn [f & maps]\n   (reduce (fn [acc item]\n             (let [[head & tail] (reduce\n                                  (fn [a i]\n                                    (let [val (get-in i [item])]\n                                      (if (nil? val)\n                                        a\n                                        (conj a val))))\n                                  []\n                                  maps)]\n               (assoc-in acc [item]\n                         (if (nil? tail)\n                           head\n                           (apply f head tail)))))\n           {}\n           (->> maps\n                (mapcat keys)\n                set)))","user":"5ef8e9e0e4b09b61f08553cb"},{"code":"(fn m-w \n  ([f a b & m]\n   (apply (partial m-w f (m-w f a b)) m))\n  ([f a b]\n   (let [[gm lm] (if (> (count a) (count b)) [a b] [b a])]\n     (merge lm (reduce (fn [s [k v]]\n                         (if-let [v2 (lm k)] \n                           (merge s (if (= gm a) {k (f v v2)} {k (f v2 v)})) \n                           (merge s {k v}))) {} gm)))))","problem":69,"user":"50c8697ce4b00bb60fe0c53f"},{"code":"(fn [f & M] (reduce (fn [a b] (reduce (fn [m e] (let [[k v] e] (assoc m k (if (contains? m k) (f (get m k) v) v)))) a (seq b))) M))","problem":69,"user":"4e7e55ab535db169f9c79711"},{"problem":69,"code":"(fn [f m & ms]\n  (if (empty? ms)\n    m\n    (let [mm (reduce (fn [acc [k v]]\n                          (if (acc k)\n                            (assoc acc k (f (acc k) v))\n                            (assoc acc k v)))\n                        m\n                        (first ms))]\n      (recur f mm (rest ms)))))","user":"60bb21d5e4b0e0fa5f1b4281"},{"problem":69,"code":"(fn [f & maps]\n  (let [kseq (distinct (flatten (for [m maps] (keys m)))) \n        vseq (for [k kseq]\n               (reduce f\n                 (filter (fn[e](not (nil? e)))\n                   (for [m maps]\n                     (get m k)\n                   )\n                 )\n               )\n             )\n       ]\n      (loop [k kseq v vseq r {}]\n        (if (empty? k)\n          r\n          (recur (rest k)(rest v)(assoc r (first k) (first v)))\n      )\n    )\n  )\n)","user":"545537c1e4b0e397800069dd"},{"problem":69,"code":"(fn [f & maps]\n  (let [g (group-by first (apply concat (map #(apply list %) maps)))]\n    (zipmap (keys g)\n            (map #(reduce f (map second %)) (vals g)))))","user":"53da19fde4b0e771c3025484"},{"code":"(fn\n  [f & varargs]\n  (let [all-keys ((comp set flatten (partial map keys)) varargs)]\n    (reduce (fn [m k] \n      (assoc m k (reduce f\n        (remove nil? (map (fn [arg] (get arg k)) varargs))))) {} all-keys)))","problem":69,"user":"4fee04a0e4b0678c553fc308"},{"problem":69,"code":"(fn [f & maps]\n  (reduce (fn [prev cur-map]\n            (reduce (fn [prev [key val]]\n                      (if (contains? prev key)\n                        (update-in prev [key] f val)\n                        (assoc prev key val))\n                      ) prev cur-map)\n            ) maps)\n  )","user":"5ccaed31e4b0ccb061962877"},{"problem":69,"code":"(fn [f & maps]\n  (let [merge-maps (fn [m m2]\n                     (reduce-kv (fn [res k v]\n                                  (if-let [prev (get res k)]\n                                    (assoc res k (f prev v))\n                                    (assoc res k v)))\n                                m\n                                m2))]\n    (reduce (fn [res m]\n              (merge-maps res m))\n            {}\n            maps)))","user":"5f93529ae4b0715f5002d7bc"},{"problem":69,"code":"(fn [f & ms] (reduce\n(fn [x y] (reduce\n  (fn [ m [k v]] (if (get m k) (assoc m k (f (get m k) v)) (assoc m k v) ))\n    x (seq y)))\n  (seq ms)))","user":"4fd11a93e4b04c3a95aa040a"},{"code":"(fn [f & ms] \n  ( let [\n        merge-two-maps \n          (fn [ m n ] ( if (empty? n) \n            m \n            (recur \n              ( assoc m (first (first n)) (concat (m (first (first n))) (vector (second (first n))) ) ) \n              (rest n)) ))\n        m (reduce merge-two-maps (cons {} ms))\n          ] ( apply hash-map (reduce concat (map #( list (first %) \n                ( if (= (count (second %)) 1) (first (second %)) (apply f (second %))) ) m) ) )))","problem":69,"user":"4fc43a8ee4b081705acca346"},{"problem":69,"code":"(fn mwth [f & maps]\n   (letfn [(mw\n             ([f m1 m2]\n              (reduce-kv\n                (fn [tmp k v]\n                  (update-in tmp [k] #(if % (f % v) v)))\n                m1 m2))\n             ([f m1 m2 & maps]\n              (reduce (partial mw f) m1 (cons m2 maps))))]\n     (apply mw f maps))\n   )","user":"60436423e4b02d28681c77a3"},{"problem":69,"code":"(fn [f & ms]\n  (reduce (fn [memo [k v]]\n            (assoc memo k (if (contains? memo k)\n                            (f (memo k) v)\n                            v)))\n          (first ms)\n          (apply concat (rest ms))))","user":"56706f01e4b0a866af6896f2"},{"problem":69,"code":"(fn mengmet\n  [fnktie basis & mappen]\n(reduce (fn [acc curr]\n        \n          (reduce (fn [acc2 k]\n                 (if (not (acc2 k))\n                   (assoc acc2 k (curr k))\n                   (assoc acc2 k (fnktie (basis k ) (curr k )))))\n                  acc\n                  (keys curr)))\n        \n  basis\n  mappen))","user":"595d4996e4b066ee0a44b01d"},{"problem":69,"code":"(fn [f & maps]\n(let [mm2\n  (fn [a b]\n    (let [bm (merge a b)\n          ak (set (keys bm))\n          ck (set (keys (select-keys a (keys b))))\n          uk (clojure.set/difference ak ck)]\n      (merge (select-keys bm uk) (zipmap ck (map #(f (a %) (b %)) ck)))))]\n  (reduce mm2 maps)))","user":"53e745a1e4b036ad0777e479"},{"problem":69,"code":"(fn [foo fst & more]\n  (letfn [(fooconj [fst snd]\n            (loop [acc fst rem snd]\n              (if-let [entry (first rem)]\n                (if (contains? acc (first entry))\n                  (recur (assoc acc (first entry)\n                                (foo (get acc (first entry)) (second entry)))\n                         (rest rem))\n                  (recur (assoc acc (first entry) (second entry)) (rest rem)))\n                acc)))]\n    (loop [acc fst rem more]\n      (if (seq rem)\n        (recur (fooconj acc (first rem)) (rest rem))\n        acc))))","user":"5d126728e4b02c15ef02199a"},{"code":"(fn [f r & m]\n  (reduce #(reduce \n    (fn [r [k v]] \n      (assoc r k (if (r k) (f (r k) v) v))\n) %1 %2) r m))","problem":69,"user":"4e5c801e535d8a8b8723a2c1"},{"code":"(fn [f & m]\n  (reduce\n    #(into %1 (for [[k v] %2]\n                [k (if-let [w (%1 k)] (f w v) v)]))\n   m))","problem":69,"user":"4e5fe31a535d8ccf87e9fe50"},{"problem":69,"code":"(fn merge-with- [f & ms]\n  (reduce #(conj % (reduce (fn [r [k v]]\n                             (let [rv (get r k)]\n                               (assoc r k (if rv\n                                            (f rv v)\n                                            v)))) %1 %2))\n          ms))","user":"5501a1e1e4b07d26eda61d75"},{"code":"(fn [f & maps]\n  (reduce #(into %1 (for [[k vn] %2] (if-let [vo (get %1 k)]\n                                      [k (f vo vn)]\n                                      [k vn])))\n          maps))","problem":69,"user":"4ec28d86535dfed6da9c6dbc"},{"problem":69,"code":"(fn myMergeWith [f & args]\n  (let [mergeOneElem (fn [m e]\n                       (let [k (key e)\n                             v (val e)]\n                         (if (contains? m k)\n                           (assoc m k (f (get m k) v))\n                           (assoc m k v))))\n        mergeTwoMaps (fn [m1 m2]\n                       (reduce mergeOneElem m1 (seq m2)))]\n    (reduce mergeTwoMaps (first args) (rest args))))","user":"54f64e99e4b0f2f3c5226ea4"},{"problem":69,"code":"(fn mwf [f & maps]\n    (let [merge-entry\n          (fn [map e]\n            (let [k (key e) v (val e)]\n              (if (contains? map k)\n                (assoc map k (f (get map k) v))\n                (assoc map k v))))\n          merge-hash (fn [m1 m2]\n                       (reduce merge-entry (or m1 {}) (seq m2)))]\n      (reduce merge-hash maps)))","user":"5317d78ee4b08068f379ed63"},{"problem":69,"code":"(fn\n  [f & maps]\n  (loop [r {}, m maps]\n    (if (empty? m)\n      r\n\t    (let [with #(if (contains? r (first %)) [(first %) (f (r (first %)) (last %))] %)\n              to-merge (into {} (map with (vec (first m))))]\n        (recur (merge r to-merge) (rest m))))))","user":"5dc9ccf8e4b02f9375f4e1f1"},{"code":"(fn [f & maps]\r\n   (reduce (fn [a b]\r\n               (apply merge\r\n                      (for [k (set (concat (keys a) (keys b)))\r\n                            :let [in-a (contains? a k)\r\n                                  in-b (contains? b k)]]\r\n                        (cond\r\n                          (and in-a in-b) {k (f (get a k) (get b k))}\r\n                          in-a {k (get a k)}\r\n                          in-b {k (get b k)}))))\r\n           maps))","problem":69,"user":"51a54fb4e4b0def3c5c586a3"},{"problem":69,"code":"(fn mw [f m1 & ms]\n  (let [merge-elem (fn [acc-map [key val]]\n                      (let [match (get acc-map key)]\n                        (if (nil? match)\n                          (assoc acc-map key val)\n                          (assoc acc-map key (f match val)))))\n        merge (fn [acc-map new-map]\n                (reduce merge-elem acc-map new-map))]\n    (reduce merge m1 ms)))","user":"56a51f26e4b0542e1f8d14e0"},{"code":"#(reduce\n  (fn [m [k v]]\n    (assoc m k (if (m k) (% (m k) v) v )))\n  %2\n  (for [b %& p b] p))","problem":69,"user":"4db85bdd535d1e037afb218d"},{"code":"(fn m-with [f & ms]\n  (reduce (fn [a b] \n            (reduce (fn [m [k v]] \n                      (assoc m k (if (a k) (f (a k) v) v))) \n                    a b)) \n          {} ms))","problem":69,"user":"50c781bbe4b00bb60fe0c535"},{"problem":69,"code":"(fn mymw[f mm & ms]\n  (reduce \n    (fn [m1 m2]\n      (reduce\n        (fn [m [key val]]\n          (if (contains? m key)\n            (update-in m (vector key) #(f % val))\n            (conj m [key val])))\n        m1\n        m2\n        ))\n    mm\n    ms))","user":"5626447fe4b00e49c7cb47bd"},{"problem":69,"code":"(fn [f & z] \n  (let [x (apply concat z)]\n    (let [ks (distinct (map first x))]\n      (zipmap ks \n              (for [x ks] (reduce f (map second (filter #(= (first %) x) (apply concat z)))))\n))))","user":"54524afbe4b0e397800069bc"},{"problem":69,"code":"(fn [f & args] (apply merge(for [k (distinct(mapcat keys args))]\n               (let[values (vals(remove nil? (map #(find % k) args)))]\n               (assoc {} k (reduce f values))))))","user":"566a3a26e4b0a866af689699"},{"code":"(fn [f & maps]\n  (when (some identity maps)\n    (let [merge-entry (fn [m e]\n                        (let [k (key e) v (val e)]\n                          (if (contains? m k)\n                            (assoc m k (f (get m k) v))\n                            (assoc m k v))))\n          merge2 (fn [m1 m2]\n                   (reduce merge-entry (or m1 {}) (seq m2)))]\n      (reduce merge2 maps))))","problem":69,"user":"5216f8dce4b082aa80a88c67"},{"problem":69,"code":"(fn [merge-fn & ms]\n  (reduce\n   (fn [res m]\n     (reduce (fn [res [k v]]\n               (assoc res k (if (contains? res k)\n                              (merge-fn (get res k) v)\n                              v)))\n             res m))\n   {}\n   ms))","user":"4f7ab8c7e4b06e829148e19c"},{"problem":69,"code":"(fn __\n  [function map & maps]\n  (reduce\n    (fn [map other-map]\n      (reduce\n        (fn [map [key value]]\n          (let [old-value (get map key)]\n            (assoc map key (if old-value (function old-value value) value))))\n        map\n        other-map))\n    map\n    maps))","user":"5ac91d90e4b0e27600da77bd"},{"problem":69,"code":"(fn z[f & maps]\n\t( loop [ res (first maps) sc (second maps) other (drop 2 maps) ]\n      (if (empty? sc)\n        ( if (empty? other)\n          res\n          (recur res (first other) (rest other))\n          )\n        ( let [ k (first (first sc)) ]\n        (if (contains? res k)\n          (recur (conj res [k (f (res k) (sc k)) ] ) (into {} (rest sc)) other)\n          (recur (conj res (first sc)) (rest sc) other)\n          )\n          )\n        )\n      )\n  )","user":"5b3aa98be4b02d533a91bbca"},{"problem":69,"code":"(fn [f & maps]\n  (let [result-value (fn [m key next-value] (if (contains? m key) (f (m key) next-value) next-value))\n        assoc-new-value (fn [result next-m] (reduce #(assoc %1 (%2 0) (result-value %1 (%2 0) (%2 1))) result next-m))]\n    (reduce assoc-new-value {} maps)))","user":"55d6a2ebe4b0e31453f64a9a"},{"code":"(fn rr [f & maps]\n  (let [\tcles (into #{} (mapcat keys maps))\n\t\t\tvs-4-k (fn [cle]\n\t\t\t\t\t(->> (map #(get % cle) maps) \n\t\t\t\t\t\t(filter (comp not nil?))\n\t\t\t\t\t\t(reduce f)\n\t\t\t\t\t\t(hash-map cle)))]\n\t\t(into {} (map #(vs-4-k %) cles))))","problem":69,"user":"4fb1fa51e4b081705acca283"},{"problem":69,"code":"(fn\n  [f & ms]\n  (reduce (fn [r m]\n            (reduce-kv\n             #(if-let [ov (get %1 %2)]\n                (assoc %1 %2 (f ov %3))\n                (assoc %1 %2 %3))\n             r\n             m))\n          (first ms)\n          (rest ms)))","user":"57233cc8e4b0c5bde472c0e1"},{"code":"(fn\t[f m & ms]\n\t(let [g (fn [m [k v]] (if (contains? m k) (assoc m k (f (get m k) v)) (assoc m k v)))]\n\t  (reduce (fn [acc el] (reduce g acc el)) m ms)))","problem":69,"user":"5142ea50e4b0c172af7558ca"},{"code":"(fn [f m & ms]\n   (loop [m m ms (seq ms)]\n     (if-let [cm (first ms)] \n       (recur (reduce (fn [m k] (assoc m k (if-not (get m k) (get cm k) (f (get m k) (get cm k))))) m (keys cm)) (next ms))\n       m)))","problem":69,"user":"4ef9c8f9535dced4c769f26b"},{"problem":69,"code":"(fn [f & [m & n]]\n  (let [ff\n        (fn [p q]\n             (reduce #(if (contains? p %2)\n                        (assoc %1 %2 (f (p %2) (q %2)))\n                        (assoc %1 %2 (q %2))) p (keys q)))]\n    (loop [x m y n]\n      (if y\n        (recur (ff x (first y)) (next y))\n        x))))","user":"5a085dfde4b01bb0ae8afdf4"},{"code":"(fn \n            [f map & maps ]\n            (reduce (fn [m [k v]] (update-in m [k] #(if (nil? %1) %2 (f %1 %2)) v)) map\n                    (for [map maps\n                          kv map]\n                      kv)))","problem":69,"user":"4f4d0a52e4b03ad3f0c10c9d"},{"code":"(fn [f h & t]\n  (reduce (fn [acc xs]\n            (reduce (fn [acc [k v]]\n                      (if-let [vv (acc k)]\n                        (assoc acc k (f vv v))\n                        (assoc acc k v))) acc xs)) h t))","problem":69,"user":"513fab65e4b00f13ea1bd891"},{"problem":69,"code":"(fn \n  ([f m1 & ms]\n   (letfn [(merge-entry [m [k v]]\n             (update-in m [k] #(if %1 (f %1 v) v)))]\n     (reduce (partial reduce merge-entry) m1 ms)))\n  ([f m] m))","user":"5bc39d2be4b07a9b28b10045"},{"code":"(fn mw [f & [m & more]]\n  (letfn [(mw-once [f m other]\n            (apply (partial conj m)\n                   (for [k (keys other)]\n                     (if (and (contains? m k)\n                              (contains? other k))\n                       [k (f (m k) (other k))]\n                       [k (other k)]))))]\n    (if (not (seq more))\n      m\n      (let [[hd & tl] more]\n        (apply (partial mw f (mw-once f m hd)) tl)))))","problem":69,"user":"4f0ef874535d0136e6c22328"},{"problem":69,"code":"(fn merge-with-fn\n  ([f m n]\n    (loop [m m n n]\n      (if (empty? n)\n        m\n        (let [x (ffirst n)\n              nv (n x)\n              mv (m x)]\n          (if mv\n            (recur (assoc m x (f mv nv)) (dissoc n x))\n            (recur (assoc m x nv) (dissoc n x)))))))\n  ([f m n & maps]\n    (reduce #(merge-with-fn f %1 %2)\n            (merge-with-fn f m n)\n            maps)))","user":"54d000c7e4b018d918be98d7"},{"problem":69,"code":"(fn [f m & ms ]\n  (reduce (fn [res new-map]\n            (reduce-kv (fn [total k v]\n                         (if (contains? total k)\n                           (assoc total k (f (get total k) v))\n                           (assoc total k v))) \n                       res new-map ))\n          m\n          ms))","user":"57934c67e4b0e215f87e8456"},{"problem":69,"code":"(fn [f & maps]\n  (reduce #(reduce (fn [m [k v]]\n                     (if (contains? m k)\n                       (update-in m [k] f v)\n                       (assoc m k v)))\n                   %1 %2)\n          {} maps))","user":"550f1c99e4b06e50f9beb171"},{"code":"(fn __ [f & coll]\n  (letfn [(in [m1 m2]\n              (reduce \n                (fn [head [k v]]\n                  (if-let [t (head k)]\n                    (merge head {k (f t v)})\n                    (merge head {k v})))\n                m1 m2))]\n    (reduce in coll)))","problem":69,"user":"52828298e4b0757a1b17145b"},{"code":"(fn [pred init & maps]\n  (reduce (fn [acc mp]\n    (reduce (fn [m [k v]]\n      (assoc m k (if (acc k) (pred (acc k) v) v))) acc mp))\n      init maps))","problem":69,"user":"50e8a340e4b0ebbe794eb7ed"},{"code":"(fn [f & coll]\n   (apply merge \n          (for [grp (group-by #(first %) (reduce into [] coll))]\n            {(first grp) (let [[c & ls] (map second (second grp))] (if (> (count ls) 0) (apply f c ls) c))})))","problem":69,"user":"50e4f4e9e4b049a987753896"},{"code":"(fn [f & ms]\n  (reduce (fn [acc m]\n            (reduce (fn [acc2 [k v]] (update-in acc2 [k] #(if % (f % v) v))) acc m))\n          (first ms)\n          (rest ms)))","problem":69,"user":"4ee528fb535d1385b2869d87"},{"problem":69,"code":"(fn [f & ms]\n  (->> ms\n       (apply concat)\n       (group-by first)\n       (map (fn [[k vs]] [k (map second vs)]))\n       (map (fn [[k vs]] [k (if (= 1 (count vs)) (first vs) (apply f vs))]))\n       (into {})\n       ))","user":"5fa17538e4b0f0ebd91b77e3"},{"problem":69,"code":"(fn [f & ms]\n  (reduce (fn [acc m]\n            (merge acc m\n                   (->> (set (keys m))\n                        (clojure.set/intersection (set (keys acc)))\n                        (map #(vector % (f (acc %) (m %))))\n                        (into {}))))\n          ms))","user":"51f01925e4b0249c592fbdfc"},{"problem":69,"code":"(fn [f & maps]\n  (reduce (fn [resmap nextmap]\n            (conj resmap \n                  (reduce (fn [res [k v]]\n                            (if (contains? resmap k)\n                              (assoc res k (f (resmap k) v))\n                              (assoc res k v))) {} nextmap))) \n          maps))","user":"55f85b93e4b03cbcff9738ae"},{"problem":69,"code":"(fn merge-with-clone [f m & maps]\n  (reduce (fn [acc [k v]]\n            (assoc acc k (if (acc k) (f (acc k) v) v)))\n          m (apply concat (map vec maps))))","user":"5879d577e4b01531a375ead8"},{"problem":69,"code":"(fn merge-with-1 [f & maps]\n  (when (some identity maps)\n    ;; combine the maps\n    (reduce\n     ;; taking two maps\n     (fn [m1 m2]\n       ;; put them together, in such a way that\n       (reduce (fn [m e]\n                 ;; for each new element we are bringing in\n                 (let [k (key e)\n                       v (val e)]\n                   ;; if the first map contains that key\n                   (if (contains? m k)\n                     ;; combine the values using our function\n                     (assoc m k (f (get m k) v))\n                     ;; otherwise, just stick it in\n                     (assoc m k v))))\n               (or m1 {})\n               (seq m2)))\n            maps)))","user":"5d64ecb2e4b0c9e5857d5036"},{"code":"(fn [f & maps]\n  (reduce #(reduce\n            (fn [out [k v]]\n              (if (contains? out k)\n                (assoc out k (f (out k) v))\n                (assoc out k v)\n                )\n              ) %1 %2\n            ) {} maps\n          )\n  )","problem":69,"user":"52e59ca5e4b09f7907dd1464"},{"problem":69,"code":"(fn [f & colls]\n  (letfn [(update' [c [k v]] \n            (if (contains? c k)\n              (update-in c [k] f v)\n              (assoc c k v)))\n          (merge' [c1 c2]\n            (reduce update' c1 c2))]\n    (reduce merge' colls)))","user":"58c73111e4b021aa9917ed72"},{"code":"(fn my-merge-with\n  ([op map-1] map-1)\n  ([op map-1 map-2]\n   (reduce (fn [m [k v]] \n             (assoc m k \n               (if-let [val (get m k)] \n                 (op val v) \n                 v)))\n           map-1 map-2))\n  ([op map-1 map-2 & maps]\n   (apply (partial my-merge-with op)\n          (my-merge-with op map-1 map-2)\n          maps)))","problem":69,"user":"5054c853e4b0b1b9d1860eb3"},{"code":"(fn [f & coll]\n  (reduce (fn [m [k v]]\n    (if (contains? m k)\n      (assoc m k (f (m k) v))\n      (assoc m k v))) {} (mapcat #(concat %) coll)))","problem":69,"user":"4f969214e4b0dcca54ed6cdd"},{"problem":69,"code":"(fn [f & maps]\n  (letfn [(merge-maps [m1 m2]\n            (loop [dest m1 r m2]\n              (if-let [[k v] (first r)]\n                (if-let [dv (get dest k)]\n                  (recur (assoc dest k (f dv v)) (next r))\n                  (recur (assoc dest k v) (next r)))\n                dest)))]\n    (reduce merge-maps\n            (first maps)\n            (rest maps))))","user":"55586905e4b0deb715856e2b"},{"problem":69,"code":"(fn [f acc & xs]\n  (reduce #(let [[k v] %2\n                 prev (get %1 k)]\n             (assoc %1 k (if (nil? prev) v (f prev v))))\n          acc (mapcat seq xs)))","user":"55d5ee3fe4b0e31453f64a92"},{"code":"(fn [f & mps]\n   (reduce\n    (fn [finalMap newMap]\n      (reduce\n       (fn [finalMap [newKey newVal]]\n         (assoc finalMap newKey\n                (if (contains? finalMap newKey)\n                  (f (get finalMap newKey) newVal)\n                  newVal)))\n       finalMap newMap))\n    mps))","problem":69,"user":"53224d45e4b09d4e7a9b54c0"},{"code":"(fn [f & maps]\n  (reduce (fn [m1 m2]\n            (reduce (fn [res k] \n                      (assoc res k (if (res k) \n                                       (f (res k) (m2 k)) \n                                       (m2 k))))\n            m1 \n            (keys m2)))\n    maps))","problem":69,"user":"511aa2a4e4b0c87c59c9670a"},{"problem":69,"code":"(fn [f & args] (reduce (fn [tot-out curr-out]\n          (reduce (fn [tot [k v :as curr] ]\n                    (if (contains? tot k)\n                      (assoc tot k (f (tot k) v ))\n                      (assoc tot k v ))) tot-out curr-out)) {} args))","user":"608ec5e4e4b03bd49d9f36c0"},{"problem":69,"code":"(fn [f map-1 & map-s]\n   (reduce \n    (fn [m-1 m-2] (assoc m-1 (first m-2)\n                         (if (contains? m-1 (first m-2))\n                           (f (get m-1 (first m-2)) (last m-2))\n                           (last m-2))))\n    map-1 (reduce #(into %1 %2) [] (map vec map-s))))","user":"5dd90651e4b0948ae9d9ad97"},{"problem":69,"code":"(fn [f & mps]\n  (letfn [(merge-maps [old new]\n            (reduce (fn [merged [k v]]\n                      (assoc merged k (if-let [old-val (old k)]\n                                        (f old-val v)\n                                        v)))\n                    old\n                    new))]\n\n    (reduce merge-maps mps)))","user":"53dad484e4b0e771c30254ac"},{"problem":69,"code":"(fn [f & colls]\n  (loop [ret {}\n         colls colls]\n    (if (empty? colls)\n      ret\n      (recur (reduce\n              (fn [acc m] (if (contains? acc (first m))\n                           (assoc acc (first m) (f (acc (first m)) (second m)))\n                           (conj acc m)))\n              ret\n              (vec (first colls))) (rest colls)))))","user":"5918db70e4b09b4ee5954bbb"},{"problem":69,"code":"(fn [f m & ms]\n  (let [mw (fn [m1 m2]\n             (reduce #(if (%1 (key %2))\n                        (update-in %1 [(key %2)] f (val %2))\n                        (assoc %1 (key %2) (val %2)))\n                     m1 m2))]\n    (reduce #(mw %1 %2) m ms)))","user":"5de12192e4b0948ae9d9aded"},{"problem":69,"code":"(fn fun [f x & xs]\n        (->> (into {} xs)\n             (map #(if (contains? x (key %))\n                  {(key %) (f (x (key %)) (val %))}\n                %))\n             (into {})))","user":"575fbe58e4b08062f99a4e87"},{"code":"(fn [f & maps] (reduce (fn [m x] (reduce #(merge % (let [k (first %2)] (if (contains? m k) {k (f (get m k) (second %2))} %2))) m x)) {} maps))","problem":69,"user":"51f66e0ee4b06ff1c25c52c3"},{"code":"(fn [f & maps]\n  (let [merge-bin \n        (fn [m1 m2]\n          (let [all-keys (clojure.set/union (keys m1) (keys m2))]\n            (reduce (fn [acc k]\n                      (cond\n                       (and (contains? m1 k) (contains? m2 k)) (assoc acc k (f (m1 k) (m2 k)))\n                       (contains? m1 k) (assoc acc k (m1 k))\n                       (contains? m2 k) (assoc acc k (m2 k)))) {} all-keys)))]\n    (reduce merge-bin maps)))","problem":69,"user":"52e6351ae4b09f7907dd146e"},{"problem":69,"code":"(fn [f m & ms]\n  (reduce (fn [m1 m2]\n            (reduce (fn [h [k v]]\n                      (if-let [V (get h k)]\n                        (assoc h k (f V v))\n                        (assoc h k v)))\n                    m1\n                    m2))\n          m\n          ms))","user":"55995fa7e4b031d6649c9ba9"},{"problem":69,"code":"(fn merge-maps [func & maps]\n  (letfn [(merge-map [m1 m2]\n                     (reduce (fn add-entry \n                               [result [k v]] \n                               (if (contains? result k)\n                                 (into result {k (func (result k) v)})\n                                 (into result {k v}))) \n                             m1 \n                             (seq m2)))]\n    (reduce merge-map maps)))","user":"5654e024e4b0f9d632dd848d"},{"code":"(fn my-merge-with [f & maps]\n  (reduce\n    (fn [accum m]\n      (reduce\n        #(assoc %1 (first %2) (second %2))\n        accum\n        (for [k (keys m)\n              :let [v (m k)]]\n          (if (contains? accum k)\n            [k (f (accum k) v)]\n            [k v]))))\n    maps))","problem":69,"user":"526ee63de4b03e8d9a4a733f"},{"code":"(fn my-merge-with [f m & rest]\n  (let [map-merge\n        (fn [f m m1]\n          (reduce\n            (fn [acc x]\n             (let [k (first x) v (second x)]\n               (if (contains? acc k)\n                 (assoc acc k (f (acc k) v))\n                 (conj acc x))))\n             m m1))]\n    (reduce (partial map-merge f) m rest)))","problem":69,"user":"50783762e4b0fc74642bff67"},{"code":"(fn [f & ms]\r\n  (apply hash-map\r\n    (apply concat\r\n      (for [[k, v] (group-by first (apply concat ms))] \r\n        [k (reduce f (map second v))]))))","problem":69,"user":"509c03f3e4b085ae113522a8"},{"problem":69,"code":"(fn merge-with'\n  ([f m1 m2]\n   (reduce #(let [k (key %2)]\n              (if-let [v1 (%1 k)]\n                (conj %1 [k (f v1 (val %2))])\n                (conj %1 %2)))\n           m1\n           m2))\n  ([f m1 m2 & more] (apply merge-with' f (merge-with' f m1 m2) more)))","user":"55ac07afe4b03311e7b7328f"},{"code":"(fn mw [f m & ms]\n  (letfn [(mrg [m [k v]]\n            (assoc m k (if (contains? m k) (f (get m k) v) v)))]\n    (reduce #(reduce mrg %1 (seq %2)) m ms)))","problem":69,"user":"51d19c24e4b0cfcf579466c3"},{"code":"(fn merw [f & maps]\n  (reduce (fn [m1 m2] \n            (reduce (fn [m [k v]]\n                      (if-not (contains? m k)\n                        (assoc m k v)\n                        (update-in m [k] f v)))\n                    m1 m2))\n          maps))","problem":69,"user":"51281b25e4b03a34742b4304"},{"problem":69,"code":"(fn [f & maps]\n\t(loop [acc (first maps) ms (rest maps)]\n\t\t(if (empty? ms)\n\t\t\tacc\n\t\t\t(recur (reduce (fn [m [k v]]\n\t\t\t\t(if (contains? m k)\n\t\t\t\t\t(assoc m k (f (m k) v))\n\t\t\t\t\t(conj m [k v]))) acc (first ms)) (rest ms)))))","user":"536e5b68e4b0fc7073fd6e6d"},{"code":"(fn [f a & b] (apply merge a (for [m b] (apply merge (for [k (keys m)] {k (let [va (a k) vm (m k)] (if (nil? va) vm (f va vm)))})))))","problem":69,"user":"4f0f01c0535d0136e6c22329"},{"code":"(fn [f & maps] \n  (reduce #(conj %\n    (reduce (fn [r [k v]] \n              (let [rv (get r k)] (assoc r k (if rv (f rv v) v)))) % %2))\n          maps))","problem":69,"user":"52d02380e4b07d0d72b273b7"},{"problem":69,"code":"#(->> (group-by first (apply concat [] %&))\n      (map (fn [[k v]] [k (reduce % (map second v))]))\n      (into {}))","user":"5507cfd3e4b021ccfedb96ad"},{"problem":69,"code":"(fn my-merge-with [f & maps]\n   (let [uniq-keys (vec (set (mapcat keys maps)))]\n     (reduce\n      (fn [result item]\n        (into result\n              [ {\n                 item\n                 (let [collected (remove nil? (map #(get % item) maps))]\n                   (if (>= (count collected) 2)\n                     (apply f collected)\n                     (first collected)))\n                 }]\n              ))\n      {}\n      uniq-keys)))","user":"5ee75f8be4b029a2061bbea5"},{"problem":69,"code":"(fn [f & m]\n  (reduce #(let [fi (first %2)\n                 se (second %2)\n                 v (%1 fi)]\n             (if v\n               (assoc %1 fi (f v se))\n               (assoc %1 fi se))\n               ) {} (mapcat #(map identity %) m)))","user":"56b6e354e4b0982f16b37e41"},{"code":"(fn [f & m] (reduce (fn [result _m] (into result (map (fn [[k v]] {k (if-let [_v (get result k)] (f _v v) v)}) _m))) {} m))","problem":69,"user":"4e79a143535db169f9c796a2"},{"problem":69,"code":"(fn [f m & ms]\n  (letfn [(merge-with-f\n            [m1 m2]\n            (reduce (fn [m1 [k v]]\n                      (if (contains? m1 k)\n                        (update-in m1 [k] f v)\n                        (assoc m1 k v)))\n                    m1\n                    m2))]\n    (reduce merge-with-f m ms)))","user":"5540cc0ce4b0a04f79299505"},{"code":"(fn [f m & args]\n  (reduce #(reduce (fn [xmap pair]\n                     (assoc xmap (key pair) (if (contains? xmap (key pair))\n                                              (f (xmap (key pair)) (val pair))\n                                              (val pair))))\n                   % %2) m args))","problem":69,"user":"52736ca1e4b03e8d9a4a747e"},{"problem":69,"code":"(fn my-merge-with [f & ms]\n  (reduce (fn [merged m]\n            (reduce (fn [new-map k]\n                      (let [result (get new-map k)\n                            new    (get m k)]\n                        (if result\n                          (assoc new-map k (f result new))\n                          (assoc new-map k new))))\n                    merged\n                    (keys m)))\n          {} ms))","user":"56444fb1e4b0018b46ad8c0c"},{"problem":69,"code":"(fn [f & maps]\n  (let [map-entries (for [m maps me m] me)]\n    (reduce (fn [ret-map me]\n             (let [[k v] me]\n              (if (contains? ret-map k)\n                (conj ret-map [k (f (get ret-map k) v)])\n                (conj ret-map [k v]))))\n            {} map-entries)))","user":"57262710e4b0c5bde472c120"},{"code":"(fn [f m & ms]\n  (reduce\n   (fn [m [k v]]\n     (assoc m k (if (contains? m k) (f (m k) v) v)))\n   m\n   (apply concat ms)))","problem":69,"user":"52015698e4b0d7096e99ddba"},{"code":"(fn mergewith\n  [f & maps]\n  (let [ks (set (mapcat keys maps))]\n    (println ks)\n    (loop [r {}\n           ks ks]\n      (if ks\n        (recur (assoc r (first ks)\n                      (let [result (filter identity\n                                           (map #(get % (first ks)) maps))]\n                        (if (> (count result) 1)\n                          (apply f result)\n                          (first result))))\n               (next ks))\n        r))))","problem":69,"user":"4e5a460f535d8a8b8723a2ab"},{"code":"(fn [f & ms]\n    (into {} (for [ky (set (mapcat keys ms))]\n               (let [vls (for [m ms :when (contains? m ky)] (m ky))]\n                 [ky (if (> (count vls) 1)\n                       (apply f vls)\n                       (first vls))]))))","problem":69,"user":"5233ad08e4b07e3ee2be83ac"},{"code":"(fn [predicate & args]\n    (reduce (fn [m   [k v]]\n              (let [p   (get m k)\n                    n   (if (nil? p)\n                          v\n                          (predicate p v))]\n                (assoc m k n)))\n            {} (mapcat concat args)))","problem":69,"user":"4df39b50535d08e6dec9fe29"},{"problem":69,"code":"(fn mymerge-with\n  [ f & args ]\n  (reduce \n    (fn [ x y ] (assoc x y (reduce f (filter identity (map #(% y) args))))) \n    {} \n    (reduce into #{} (map keys args))))","user":"55536a8ae4b0deb715856e03"},{"code":"(fn [f m & ms]\n  (reduce (fn [m n]\n            (into m (for [[k v] n]\n                      [k (if (contains? m k)\n                           (f (m k) v)\n                           v)])))\n          m ms))","problem":69,"user":"500d8c49e4b07ccb9a7ddb00"},{"problem":69,"code":"(fn __ [funk & maps]\n      (let [apply-funk-over-a-symbol\n            (fn [funk sym list-of-maps]\n                (let [symbol-getter #(get % sym nil)\n                      filtered-values (filter symbol-getter list-of-maps)\n                      filtered-count (count filtered-values)]\n                            (if (= filtered-count 1)\n                              (symbol-getter (first filtered-values))\n                              (apply funk (map symbol-getter filtered-values)))))\n            make-association\n            (fn [input-map funk sym list-of-maps]\n                (assoc input-map sym (apply-funk-over-a-symbol funk sym list-of-maps)))\n            get-all-keywords\n            (fn [maps]\n                  (reduce (fn [accumulator map]\n                            (set (concat accumulator (keys map)))) [] maps))]\n            (reduce (fn [accumulator keyword]\n                (make-association accumulator funk keyword maps)) {} (get-all-keywords maps))))","user":"596b67a7e4b069c0a1a19815"},{"problem":69,"code":"(fn my-merge-with [f & args]\n  (reduce (fn [map1 map2]\n            (reduce (fn [m1 [k v]]\n                      (if-let [v1 (m1 k)]\n                        (assoc m1 k (f v1 v))\n                        (assoc m1 k v)))\n                    map1 map2))\n          args))","user":"53b7aa6ce4b047364c0444d1"},{"code":"(fn [f & ms]\n    (reduce (fn [r m]\n              (reduce #(assoc %1 (%2 0) (if (nil? (%1 (%2 0)))\n                                          (%2 1)\n                                          (f (%1 (%2 0)) (%2 1))))\n                      r m))\n            {} ms))","problem":69,"user":"5370f8ede4b0fc7073fd6ea2"},{"problem":69,"code":"(fn pms\n  ([f x & y]\n   (letfn [\n           (up\n             [f c p]\n             (let [key (first p)\n                   value (second p)\n                   value-c (c key)\n                   ]\n               (if value-c\n                 (assoc c key (f value-c value))\n                 (conj c p)\n                 )))\n\n           (pm\n             ([f x] x)\n             ([f x y]\n              (if (empty? y)\n                x\n                (pm f\n                    (reduce #(up f % %2) x (first y))\n                    (rest y))\n                )))\n\n\n           ]\n     (pm f x y))))","user":"51f81925e4b09be9c177e526"},{"problem":69,"code":"(fn merge-w [f & ms]\n  (reduce (fn [m1 m2]\n            (let [ks (set (concat (keys m1) (keys m2)))]\n              (into {} (map (fn [k]\n                              (if (and (get m1 k) (get m2 k))\n                                [k (f (get m1 k) (get m2 k))]\n                                [k (or (get m1 k) (get m2 k))])) ks))\n              )) ms))","user":"51a3be77e4b0e77c4ca60bf8"},{"code":"(fn [f & s]\n   (reduce (fn [a b]\n             (reduce (fn [m [k v]]\n                       (if (contains? m k)\n                         (update-in m [k] #(f % v))\n                         (assoc m k v)))\n                     a b))\n           s))","problem":69,"user":"5175533fe4b0dea9bbfba575"},{"code":"#(reduce (fn [m [k v]] (assoc m k (if (contains? m k) (% (m k) v) v))) {} (apply concat %&))","problem":69,"user":"534bde26e4b084c2834f4a81"},{"problem":69,"code":"(fn\n  [f & maps]\n  (reduce (fn [acc v]\n            (reduce (fn [iacc [key newval]]\n                      (assoc iacc key (if-let [oldval (get iacc key)]\n                                        (f oldval newval)\n                                        newval)))\n                    acc (seq v)))\n          {} maps))","user":"5edd05bfe4b0c7845d86b0f3"},{"code":"(fn [f & maps] (reduce (fn [a b] (reduce (fn [c d] (if (nil? (get c (key d))) (assoc c (key d) (val d)) (assoc c (key d) (f (get c (key d)) (val d))))) a b)) (first maps) (rest maps)))","problem":69,"user":"52c1bd29e4b07a9af579236a"},{"code":"(fn merge-fn [f & maps]\n  (let [all-keys (reduce into #{} (map keys maps))\n        merged (map #(remove nil? (concat [%] (map (fn [a] (a %)) maps))) all-keys)]\n    (apply hash-map (mapcat #(vector (first %)\n                               (if (> (count (rest %)) 1)\n                                 (apply f (rest %))\n                                 (last %))) merged))))","problem":69,"user":"50d3b03fe4b030b634c368b9"},{"problem":69,"code":"(fn mwaf [f m & ms]\n  (reduce #(reduce (fn [r [k v]]\n                     (if (contains? r k)\n                       (conj r [k (f (r k) v)])\n                       (conj r [k v])))\n                   %1\n                   (seq %2))\n          m\n          ms))","user":"5f8b06afe4b0715f5002d74a"},{"problem":69,"code":"(fn [f & ms]\n  (let [me (fn [m e]\n                        (let [k (key e) v (val e)]\n                             (if (m k)\n                                 (assoc m k (f (get m k) v))\n                                 (assoc m k v))))]\n  (reduce #(reduce me %1 (seq %2)) ms)))","user":"544e8369e4b0e39780006987"},{"problem":69,"code":"(fn [f m & rms]\n  (loop [m m\n         rms rms]\n    (if (empty? rms)\n      m\n      (let [nextm (first rms)\n            coup (first nextm)\n            k (first coup)\n            v (second coup)\n            mv (get m k)\n            hasmv (not (nil? mv))\n            newmv (if hasmv (f mv v) v)\n            newm (assoc m k newmv)\n            newnextm (rest nextm)\n            restrms (rest rms)\n            newrms (if (> (count newnextm) 0) (cons newnextm restrms) restrms)]\n        (recur newm newrms)))))","user":"592334c7e4b0a390037439ee"},{"problem":69,"code":"(fn [f & maps]\n (loop [current (first maps) remainder (rest maps)]\n   (if (empty? remainder)\n    current\n    (recur \n     (reduce\n      (fn [inner-result [mapkey mapval]]\n        (assoc inner-result mapkey (if (contains? inner-result mapkey) (f (get inner-result mapkey) mapval) mapval))\n      )\n      current\n      (first remainder)\n     )\n     (rest remainder)\n    )\n   )\n )\n)","user":"547dc4c7e4b0c51c1f4d72f8"},{"code":"(fn [op m & ms]\r\n    (reduce \r\n      #(into %1\r\n             (map \r\n               (fn [[k,v]] \r\n                 [k (if (contains? %1 k) (op (get %1 k) v) v)])\r\n               %2))\r\n      m \r\n      ms))","problem":69,"user":"5046b003e4b011c5dfee7727"},{"code":"(fn merge-wif [f & ms]\n  (reduce \n   (fn [m1 m2]\n     (reduce \n       (fn [m [k v]]\n         (if (contains? m k)\n           (assoc m k (f (m k) v))\n           (assoc m k v)))\n       m1 m2))\n   {} ms))","problem":69,"user":"50fc299ee4b0d10d794c19f2"},{"problem":69,"code":"(fn mm[f & ms]\n  (reduce (fn[i m] (reduce-kv #(if (get %1 %2) (assoc %1 %2 (f (get %1 %2) %3)) (assoc %1 %2 %3))\n                              i m)) {} ms))","user":"52f426fce4b05e3f0be25f1e"},{"problem":69,"code":"(fn [fun & r]\n  (letfn [(_merge-two [m1 m2]\n            (reduce (fn [m [k v]]\n                      (if-let [[_ old] (find m1 k)]\n                        (assoc m k (fun old v))\n                        (assoc m k v)))\n                    m1 m2))]\n    (reduce _merge-two r)))","user":"54848141e4b0e286459a119e"},{"code":"(fn [f & v]\r\n  (reduce\r\n    #(reduce (fn [h k]  \r\n               (assoc h k\r\n                  (if (contains? h k)\r\n                    (f (get h k) (get %2 k))\r\n                    (get %2 k))))\r\n           %1 (keys %2))\r\n  (first v) (rest v))\r\n)","problem":69,"user":"4e5bdc2b535d8a8b8723a2bb"},{"problem":69,"code":"(fn [f & cols]\n  (loop [out {} cols cols]\n    (if\n      (empty? cols)\n      out\n      (let [merge-fun\n            (fn [c1 c2]\n             (reduce\n              (fn [acc [k v2]](assoc acc k\n                       (if-let [v (acc k)] (f v v2) v2)))\n                        c1 c2))]\n      (recur (merge-fun out (first cols)) (rest cols))\n    )\n    )\n  ))","user":"5a244240e4b0ff51aa4b32e9"},{"problem":69,"code":"(fn mrec\n  ([f col1 col2]\n  (let [fun\n(fn [col f [k v]]\n  (assoc col k\n(if-let [ov (get col k)]\n  (f ov v)\n  v)))]\n    (if-let [[fir & n] (seq col2)]\n      (fun (mrec f col1 n) f fir)\n      col1)))\n  ([f col1 col2 & rcol]\n   (apply mrec f (mrec f col1 col2) rcol)))","user":"53908e6be4b0b51d73faae9a"},{"problem":69,"code":"(fn [f & ms]\n  (reduce (fn [result-map [k v]]\n            (if (contains? result-map k)\n              (assoc result-map k (f (get result-map k) v))\n              (assoc result-map k v)))\n          {}\n          (apply concat ms)))","user":"54684c3be4b00cfc9eacc139"},{"problem":69,"code":"(fn merge-with' [op & maps]\n  (reduce \n  \t(fn [acc m]\n      (apply assoc acc\n             (mapcat (fn [k]\n                    (list k \n                          (if (acc k)\n                            (op (acc k) (m k))\n                            (m k))))\n                  (keys m))))\n   \tmaps))","user":"54be7772e4b0ed20f4ff6eea"},{"problem":69,"code":"(fn mw [f m & ms]\n  (letfn [(update-or-add [m1 [k v]]\n            (assoc m1 k (if-let [x (m1 k)] \n                          (f x v) \n                          v)))\n          (merge-with-one [m1 m2]\n            (reduce update-or-add m1 m2))]\n    (reduce merge-with-one m ms)))","user":"5919d209e4b09b4ee5954bcc"},{"problem":69,"code":"(fn a [f & sq]\n  (reduce (fn a [x y] \n            (reduce (fn [m [k v]] (\n                                   if (contains? m k)\n                                   (assoc m k (f (m k) v)) (assoc m k v))) x y)) sq)\n  )","user":"5fe09d1fe4b05ac5b16ea15b"},{"problem":69,"code":"(fn[f m & M](if(seq M)(recur f(reduce-kv #(assoc % %2(if(contains? m %2)(f(m %2)%3)%3))m(first M))(rest M))m))","user":"50e5bca5e4b09ae9427b0e75"},{"code":"(fn [f mp & ms]\n   (reduce (fn [m n]\n             (reduce (fn [o v]\n                       (if (get o (key v))\n                         (update-in o [(key v)] #(f %1 (val v)))\n                         (apply assoc o v)))\n                     m\n                     n))\n           mp ms))","problem":69,"user":"4e5914e0535d8a8b8723a29b"},{"code":"(fn [f & ms]\n  (reduce\n    #(loop [pairs (seq %2) m %1]\n       (if pairs\n        (let [[key val] (first pairs)]\n         (recur (next pairs)\n           (assoc m key \n            (if (contains? m key) (f (m key) val) val))))\n        m))\n    ms))","problem":69,"user":"4e593dac535d8a8b8723a29c"},{"problem":69,"code":"(fn  ff [f bs & r]\n  (if (empty? r)\n    bs\n    (apply ff f (loop [ acc bs ks (keys (first r))  vs (vals (first r)) ]\n       (if (empty? ks)\n         acc\n         (recur (assoc acc (first ks) (if (acc (first ks))   (f   (acc (first ks))  (first vs) )     (first vs)   ) )  (rest ks) (rest vs) )\n         \n         \n         )\n  )   \n    (rest r)\n     \n  \n )\n )\n )","user":"5735ac67e4b0cd1946bd102b"},{"code":"(fn [f & a]\n  (reduce (fn [m [k v]]\n               (if (contains? m k)\n  \t\t\t(assoc m k (f (m k) v))\n                (assoc m k v)))\n            {} (mapcat vec a))\n  )","problem":69,"user":"5054bc87e4b0b1b9d1860eb0"},{"problem":69,"code":"(fn [f & coll]\n  (reduce \n    (fn [m1 m2] \n      (conj m1 \n        (reduce-kv (fn [m k v]\n          (assoc m k\n            (if (contains? m1 k)  \n              (f (get m1 k) v)\n              v\n            ))) {} m2)))\n        coll\n))","user":"54bbe505e4b0ed20f4ff6ec5"},{"problem":69,"code":"(fn [f & l]\n   (let [ks (->> (map keys l)\n                 (reduce concat)\n                 (distinct))]\n     (zipmap ks\n             (map\n              (fn [k]\n                (->> (map #(get % k) l)\n                     (filter #(not (nil? %)))\n                     (reduce f)))\n              ks))))","user":"58db3c5ae4b0a4d5acaab677"},{"problem":69,"code":"(fn mein-merge [f & xs]\n  (into {}\n        (map\n         #(vector (first %) (cond (> (count (flatten (vals (second %)))) 1)\n                                  (if (= f concat) (f (flatten (vals (second %))))\n                                      (apply f (flatten (vals (second %)))))\n                                  :else (second (flatten (second %)))))\n         (group-by key (apply concat xs)))))","user":"559067ace4b0277789237670"},{"code":"(fn [f & a]\n(reduce\n    (fn \n      [m x]\n       (if (nil? (get m (first x))) \n         (merge m x) \n         (assoc m (first x) \n           (f (get m (first x)) (last x)))))\n      {} (reduce concat a)))","problem":69,"user":"4f0446f9535dcb61093f6bb8"},{"code":"(fn [f & maps]\n\n  (reduce\n \n   (fn [acc n]\n     (let [k (first n)\n           v (second n)]\n       (if (some #{k} (keys acc))\n         (assoc acc k (f (get acc k) v))\n         (apply assoc acc n))))\n\n \n   '{}\n    (apply concat maps)))","problem":69,"user":"4f47eab2e4b0d56e7bb92bc6"},{"code":"(fn merge-with_ [f m & ms]\n  (if (empty? ms) m\n    (let [merge-single (fn [m s]\n                         (if (m (key s))\n                             (assoc m (key s) (f (m (key s)) (val s)))\n                             (assoc m (key s) (val s))))\n          merge (fn [m1 m2]\n                  (if (empty? m1)\n                      m1\n                      (reduce merge-single m1 m2)))]\n      (reduce merge m ms))))","problem":69,"user":"4f50c414e4b03ad3f0c10d0d"},{"code":"(fn [f & maps]\r\n  (reduce (fn [res map]\r\n    (reduce (fn [r m]\r\n      (let [k (key m)]\r\n        (assoc r k (if (contains? r k) (f (r k) (val m)) (val m))))) res map))\r\n            {} maps))","problem":69,"user":"502873a8e4b01614d1633ff8"},{"code":"(fn [f map1 & maps]\n  (let [r (fn [m [k v]] (if (contains? m k)\n                            (conj m [k (f (m k) v)])\n                            (conj m [k v])))]\n    (reduce #(reduce r %1 %2) map1 maps)))","problem":69,"user":"4daf36c2edd6309eace4d175"},{"problem":69,"code":"(fn [f coll & colls]\n   (reduce (fn [m e]\n             (reduce (fn [m [k v]]\n                       (if (contains? m k)\n                         (assoc m k (f (get m k) v))\n                         (assoc m k v)))\n                     m e))\n           coll colls))","user":"5ab23c99e4b073f1774425e2"},{"problem":69,"code":"(fn [func & maps]\n   (->> (distinct (mapcat keys maps))\n        (map (fn [key]\n               (let [values (->> maps \n                                 (filter #(contains? % key))\n                                 (map #(get % key))\n                                 )] \n                 [key (if (= 1 (count values))\n                        (first values)\n                        (apply func values)\n                        )])))\n        (into {})\n        )\n   \n   )","user":"583f1533e4b089d5ab817dc8"},{"problem":69,"code":"(fn [f & seqs]\n  (let [ks (seq (set (reduce concat (map #(keys %) seqs))))]\n    (loop [s ks r {}]\n      (if (empty? s)\n        r\n        (recur (rest s) (assoc r  (first s) (reduce f (filter #(not (nil? %)) (map #(get % (first s)) seqs)))))))))","user":"57addbcce4b0b8559636fca3"},{"problem":69,"code":"(fn mergew [f & ms]\n  (let [m (fn [f m1 m2]\n            (let [m' (fn [f ks m1 m2]\n                       (if (empty? ks) m1\n                         (let [k (first ks)\n                               rk (rest ks)\n                               v1 (m1 k)\n                               v2 (m2 k)]\n                           (if (nil? v1)\n                             (recur f rk (conj m1 [k v2]) m2)\n                             (recur f rk (conj m1 [k (f v1 v2)]) m2)))))]\n              (m' f (keys m2) m1 m2)))\n        mgw (fn [f ms]\n              (let [[t d & rm] ms]\n                (if (nil? d) t\n                 (recur f (cons (m f t d) rm)))))]\n    (mgw f ms)))","user":"57d1d6c8e4b0bd073c202370"},{"code":"(fn my-merge [func & maps]\n  (reduce\n   (fn [a b]\n     (reduce\n      (fn [base key]\n        (let [value (get b key)]\n          (assoc base key\n                 (if (contains? base key)\n                   (func (get base key) value) value))))\n      a (keys b)))\n   maps))","problem":69,"user":"4f03818e535dcb61093f6b00"},{"code":"(fn mw [f m & [h & r]]\n  (if h\n    (apply mw f\n      (reduce (fn [a [k v]] (assoc a k (if-let [av (a k)] (f av v) v))) m h)\n      r)\n    m))","problem":69,"user":"4fd96694e4b05e33b9224f37"},{"problem":69,"code":"(fn mw [fun & ms]\n  (reduce (fn [ret m] (reduce (fn [r [k v]] (assoc r k (if (get r k) (fun (get r k) v) v))) ret m)) {} ms))","user":"53fe1b42e4b0de5c418485f1"},{"code":"(fn [p & s]\n  (loop [x (next s)\n         acc (first s)]\n    (if x\n      (recur (next x) (into acc (map #(let [[k v] %]\n                                        (if (contains? acc k)\n                                          (vector k (p (get acc k) v))\n                                          (vector k v)))\n                                     (first x))))\n      acc)))","problem":69,"user":"4ff9d4e5e4b0678c553fc3b0"},{"problem":69,"code":"(fn merge-with' [f & ms]\n  (let [\n        merge-kv (fn [m kv]\n                   (let [[k v] kv]\n                     (if (contains? m k)\n                       (assoc m k (f (get m k) v))\n                       (assoc m k v))))\n        merge-both (fn [m1 m2] (reduce merge-kv m1 (seq m2)))]\n    (reduce merge-both ms)))","user":"58dcf11ae4b0a4d5acaab6af"},{"code":"(fn [f m & ms]\n  (let [kvs (mapcat seq ms)\n        mrg (fn [hm [k v]]\n          (assoc hm k (if-let [ev (hm k)] (f ev v) v)))]\n    (reduce mrg m kvs)))","problem":69,"user":"4fa98b72e4b081705acca1e2"},{"code":"(fn [f c1 & cs]\r\n  (letfn [(merge-entry [m [k v]]\r\n            (if (find m k)\r\n                (assoc m k (f (get m k) v))\r\n                (assoc m k v)))\r\n          (merge-map [m1 m2]\r\n            (reduce merge-entry m1 m2))]\r\n    (reduce merge-map c1 cs)))","problem":69,"user":"4fb37882e4b081705acca2a0"},{"code":"(fn my-merge-with [f & maps]\n  (reduce\n    (fn [a b]\n      (loop [res a sec (seq b)]\n        (if (empty? sec)\n          res\n          (let [[[k v] & more] sec]\n            (if (contains? res k)\n              (recur (assoc res k (f (res k) v)) more)\n              (recur (assoc res k v) more)\n              ))\n          )\n        ))\n    {} maps)\n  )","problem":69,"user":"5094057fe4b097f48cc38593"},{"problem":69,"code":"(fn merge+ [f & maps]\n  (reduce\n    #(let [[k v] %2\n           c %1 \n           p (c k)]\n       (assoc c k (if (nil? p)\n                    v\n                    (f p v))))\n    {}\n    (apply concat maps)))","user":"53fa3524e4b0de5c41848578"},{"code":"(fn [f & ms]\n  (->> ms (apply concat) (group-by key)\n       (map (fn [[k vs]] [k (reduce f (map val vs))]))\n       (into {})))","problem":69,"user":"4f6160a7e4b0defedf855fbe"},{"code":"(fn [f & mps]\n  (reduce\n    (fn [r m]\n      (into r\n        (for [[k v] m]\n          (let [x (get r k)]\n          (if x\n            [k (f x v)]\n[k v])))))\n(first mps)\n(rest mps)))","problem":69,"user":"4fca2a13e4b0ee37620e184d"},{"problem":69,"code":"(fn [op & maps]\n  (reduce #(let [k (first %2)\n                 v (second %2)\n                 orig_val (%1 k)]\n             (if (nil? orig_val)\n               (assoc %1 k v)\n               (assoc %1 k (op orig_val v)))) {} (mapcat seq maps)))","user":"5cb0f70ce4b026601754b8c1"},{"code":"(fn [f & maps]\n  (when (some identity maps)\n    (let [merge-entry (fn [m e]\n            (let [k (key e) v (val e)]\n              (if (contains? m k)\n                (assoc m k (f (get m k) v))\n                (assoc m k v))))\n          merge2 (fn [m1 m2]\n           (reduce merge-entry (or m1 {}) (seq m2)))]\n      (reduce merge2 maps))))","problem":69,"user":"518644bce4b0da5a5be3baca"},{"problem":69,"code":"(fn [f m & ms]\n  (letfn [(merge-maps [m1 m2]\n                      (reduce (fn [acc [k v]] (if (contains? acc k) \n                                                (assoc acc k (f (get acc k) v)) \n                                                (assoc acc k v)))\n                              m1 m2))]\n    (reduce merge-maps m ms)))","user":"55c20bd0e4b0e31453f64972"},{"problem":69,"code":"(fn [f & ms]\n  (let [ks (set (flatten \n             (map keys ms)))]\n    (reduce\n     (fn [m k]\n      (assoc-in m [k]\n       (let [vs \n            (map #(% k)\n             (filter\n              #(contains? % k)\n              ms))]\n        (if (= (count vs) 1)\n            (first vs)\n            (apply f vs)))))\n     {} ks)))","user":"51e5a627e4b0efabf93c02db"},{"code":"(fn my-merge-with\n  [f & maps]\n  (reduce (fn [acc curr-map]\n            (reduce (fn [acc [k v]]\n                      (if (contains? acc k)\n                        (update-in acc [k] f v)\n                        (assoc acc k v)))\n                    acc\n                    curr-map))\n          maps))","problem":69,"user":"52dd6cc8e4b09f7907dd13e2"},{"problem":69,"code":"(fn [f & ms]\n  (reduce\n    (fn [a m]\n      (reduce\n        (fn [a [k v]]\n          (assoc a k\n            (if (contains? a k)\n              (f (get a k) v)\n              v)))\n        a m))\n    {} ms))","user":"55fee5e4e4b00f4cabc5765a"},{"code":"(fn [o & x] (let [ l (apply concat x) \n                         f (fn [m [y z]] (let [v (m y)] \n                                           (assoc m y (if (nil? v) z (o v z) ))))] \n                     (reduce f {} l)))","problem":69,"user":"4e71da4d535d5021c1a89653"},{"problem":69,"code":"(fn [f base & new]\n  (reduce\n    (fn [as bs]\n      (reduce (fn [res [bk bv]]\n                (if (contains? res bk)\n                  (update-in res [bk] f bv)\n                  (assoc res bk bv)))\n                as bs))\n    base\n    new))","user":"5363d242e4b0243289761e5c"},{"problem":69,"code":"(fn [f & ms]\n  (let [vfn (fn [m [k v]] (if (contains? m k) (f (get m k) v) v))\n        afn (fn [m [k v :as e]] (assoc m k (vfn m e)))\n        mfn  (fn [m1 m2] (reduce afn m1 (seq m2)))]\n    (reduce mfn ms)))","user":"536d260be4b0fc7073fd6e55"},{"problem":69,"code":"(fn [f & maps]\n  (->> maps\n      (mapcat identity)\n      (group-by first)\n      (map (fn [[k v]] [k (map last v)]))\n      (map (fn [[k v]] [k (reduce f v)]))\n      (into {})))","user":"553b0d95e4b09218d5f44fff"},{"code":"(fn [f & rst]\n  (reduce\n    (fn [m1 m2]\n      (into m1\n        (map (fn [[k v]] [k (if (contains? m1 k) (f (get m1 k) v) v)]) m2)))\n    rst))","problem":69,"user":"4fb12b35e4b081705acca275"},{"problem":69,"code":"(fn  [f & maps]\n(let [arr (apply concat maps)] \n(into {} (for [[k v] (group-by first arr)] [k (reduce f (map second v))])) ))","user":"5a1c8c26e4b0ff51aa4b3247"},{"problem":69,"code":"(fn my-merge-with [f & maps]\n  (reduce (fn [res m]\n    (reduce (fn [res [k v]]\n      (if (contains? res k)\n        (assoc res k (f (get res k) v))\n        (assoc res k v))) res m)) {} maps))","user":"59a24c92e4b066c664927d20"},{"problem":69,"code":"(fn [f & ms]\n  (->> ms\n    (mapcat vec)\n    (group-by first)\n    (map #(vector (key %) \n                  (if (= 1 (count (val %)))\n                    (second (first (val %)))\n                    (apply f (map second (val %))))))\n    (into {})))\n\n;(fn [f & ms]\n;  (reduce (fn [t v]\n;            (reduce (fn [tt vv]\n;                      (if (nil? (tt vv)) \n;                        (assoc tt vv (v vv)) \n;                        (update-in tt [vv] f (v vv)))) \n;                    t \n;                    (keys v))) \n;          ms))\n\n;(fn mymw [f m & ms]\n;  (if (empty? ms)\n;    m\n;    (recur f \n;           (into m (for [el (first ms)]\n;                     (let [[k v] el cur (get m k)]\n;                       (if (nil? cur)\n;                         el\n;                         [k (f cur v)]))))\n;           (rest ms))))","user":"4f7207d3e4b07046d9f4f019"},{"problem":69,"code":"(fn [f m & ms]\n  (let [merge-element\n         (fn [f [key value] map]\n           (if (contains? map key)\n             (assoc map key (f (map key) value))\n             (assoc map key value)))\n        merge-map\n          (fn [f m1 m2]\n            (reduce #(merge-element f %2 %) m1 (seq m2)))]\n    (reduce #(merge-map f % %2) m ms)))","user":"578fc072e4b0ebec4cfb759a"},{"code":"(fn [f result & others]\n ((fn [result others]\n  (cond\n   (empty? others) result\n   (empty? (first others)) (recur result (rest others))\n   true (let [entry (first (first others))]\n          (recur (assoc result (first entry)\n\t        (if (contains? result (first entry))\n              (f (result (first entry)) (second entry))\n              (second entry))) (conj (rest others) (rest (first others))))))) result others))","problem":69,"user":"5196568fe4b04c0af7ff3c1c"},{"code":"(fn merge-with-e [f & x]\n  (let [K (reduce into #{} (map keys x))\n        not-nil (fn [v] (not (nil? v)))]\n    (apply conj {}\n      (map\n        #(vector % (let [args (filter not-nil (map (fn [m] (m %)) x))]\n                     (if (= (count args) 1) (first args) (apply f args))))\n        K))))","problem":69,"user":"52084f75e4b01ce6bbf31dde"},{"code":"(fn\n  [f & maps]\n  (let [ks (set (mapcat keys maps))]\n    (reduce (fn [res k] \n              (let [vals (filter (comp not nil?) (map #(% k) maps))]\n                (assoc res k (if (= 1 (count vals)) (first vals) (apply f vals)))))\n            {}\n            ks)))","problem":69,"user":"531490bde4b08068f379ed17"},{"problem":69,"code":"(fn [f & ms]\n  (letfn [(combine-maps-f [m1 m2]\n            (loop [m1 m1 m2 m2]\n              (if (empty? m2)\n                m1\n                (let [m2el (first m2) m2elkey (first m2el)]\n                  (recur (assoc m1 m2elkey\n                                (if (contains? m1 m2elkey)\n                                  (f (m1 m2elkey) (m2 m2elkey))\n                                  (m2 m2elkey)))\n                         (dissoc m2 m2elkey))))))]\n    (reduce combine-maps-f ms)))","user":"5e078ba7e4b0978307768fb6"},{"problem":69,"code":"(fn my-merge-with\n  ([combine-func left-map right-map & others]\n   (reduce #(my-merge-with combine-func % %2)\n           (cons left-map (cons right-map others))))\n  ([combine-func left-map right-map]\n   (reduce (fn [result-map [key val]]\n             (let [new-val (if (contains? result-map key)\n                             (combine-func (result-map key) val)\n                             val)]\n               (assoc result-map key new-val)))\n           left-map\n           right-map)))","user":"580d2788e4b0849f6811b730"},{"code":"(fn [f & m]\n  (reduce\n    (fn [a b]\n      (reduce \n        #(conj % (if-let [e (% (key %2))] [(key %2) (f e (val %2))] %2))\n      a b))\n  m))","problem":69,"user":"505d4b21e4b0e6aca564be07"},{"problem":69,"code":"(fn mergewith [f & ms]\n  (into {} (map (fn [[k v]]\n                  [k (reduce f (map second v))])\n                (group-by first\n                          (apply concat ms)))))","user":"54857e3be4b0e286459a11ad"},{"problem":69,"code":"(fn [f & maps] \n  (letfn [(upt [m [k v]] \n            (assoc m k (if (m k) (f (m k) v) v)))]\n  (reduce upt {} (mapcat seq maps))))","user":"575ef4b6e4b08062f99a4e78"},{"code":"(fn [f & maps]\r\n  (let [allkeys (distinct (apply concat (map keys maps)))]\r\n    (loop [allkeys allkeys result {}]\r\n      (if (empty? allkeys)\r\n          result\r\n          (recur (rest allkeys)\r\n                 (assoc result\r\n                        (first allkeys)\r\n                        (let [values (filter #(not (nil? %))\r\n                                             (map #(get % (first allkeys)) maps))]\r\n                          (if (== (count values) 1)\r\n                              (first values)\r\n                              (apply f values)))))))))","problem":69,"user":"4e4b4564535dc968683fc4d3"},{"problem":69,"code":"(fn\n [op m & args]\n (letfn\n  [(f\n    [op m1 m2]\n    (into\n     {}\n     (concat\n      (map\n       (fn [[k v]] (if (contains? m2 k) [k (op v (get m2 k))] [k v]))\n       m1)\n      (filter\n       #(not (contains? m1 (first %)))\n       m2))))]\n  (if (not (seq args)) m (recur op (f op m (first args)) (rest args)))))","user":"58a822e4e4b01a0c0b232950"},{"problem":69,"code":"(fn [f coll & args]\n  (if (empty? args)\n    coll\n    (recur f\n           (reduce-kv (fn [m k v]\n                        (assoc m k (if-let [w (get m k)]\n                                     (f w v)\n                                     v)))\n                      coll\n                      (first args))\n           (rest args))))","user":"54c5cc17e4b045293a27f624"},{"problem":69,"code":"(fn [f & maps]\n  (let [input (apply concat maps)] \n    (into {} (map (fn [x] [(first x) (reduce f (map second (second x)))]) (group-by key input)))))","user":"4e9ff8d0535d7eef3080729c"},{"problem":69,"code":"(fn [f & maps]\n  (reduce (fn [cur k]\n            (let [grouped (remove nil? (map #(get % k) maps))]\n              (if (> (count grouped) 1)\n                (assoc cur k (apply f grouped))\n                (assoc cur k (first grouped)))))\n          {}\n          (set (flatten (map #(keys %) maps)))))","user":"5ba28f36e4b0a20761a233c4"},{"problem":69,"code":"(fn [f & args] (let [l (seq (apply clojure.set/union (map (comp set keys) args)))]\n                 (zipmap l (map #(reduce f (for [i args :when (contains? i %)] (i %))) l))))","user":"584dadebe4b0b7285a6f4e44"},{"problem":69,"code":"(fn cmerge-with\n    ([f x] x)\n    ([f first-map & more]\n     (reduce (fn [result y]\n               (reduce (fn [a item]\n                         (let [key (key item)\n                               val (val item)]\n                           (if (get a key)\n                             (assoc a key (f (get a key) val))\n                             (assoc a key val))))\n                       result\n                       y))\n             first-map\n             more)))","user":"5e7b1ef4e4b085ba37836e10"},{"code":"(fn [f & args]\n  (letfn [(entry [a b] (cond (nil? a) b\n                             (nil? b) a\n                             :else (f a b)))\n          (rf [m e] (let [k (key e)]\n                      (assoc m k (entry (m k) (val e)))))\n          (merge-2 [m1 m2]\n                   (reduce rf m1 m2))]\n    (reduce merge-2 args)))","problem":69,"user":"501d34f6e4b066e56b9d0b1e"},{"code":"(fn [f & ms]\n  (reduce\n    (fn [a s] \n      (reduce #(let [k (first %2) v (second %2) x (% k)]\n        (assoc % k (if x (f x v) v))) a s))\n    {} ms))","problem":69,"user":"4fa30027e4b081705acca187"},{"problem":69,"code":"(fn [f & ms]\n   (reduce (fn [m1 m2] (into {}\n                              (concat m1\n                                      m2\n                                      (map (fn [k] [k (f (get m1 k) (get m2 k))])\n                                           (filter (set (keys m1)) (keys m2))))))\n           ms))","user":"4fcf1755e4b03432b189f40c"},{"code":"(fn [f coll & xs]\n  (if (seq xs)\n    (let [uniqs (remove #((set (keys coll)) (key %)) (first xs))\n          exts  (filter #((set (keys coll)) (key %)) (first xs))]\n      (recur f\n        (conj (reduce #(assoc %1 (key %2) (f (%1 (key %2)) (val %2))) coll exts) uniqs)\n        (rest xs)))\n    coll))","problem":69,"user":"4eb51942535d7eef30807365"},{"problem":69,"code":"(fn mrg [f & args]\n  (letfn [(applyf [res [key value]] \n                  (assoc res key \n                        (if (contains? res key) (f (res key) value) value)))]\n  (reduce (fn [resmap nextmap] (reduce applyf resmap nextmap)) args)))","user":"543f854fe4b032a45b86935b"},{"code":"(fn [f x & xs]\n  (loop [o x h (first xs) t (rest xs)]\n    (cond (nil? h) o\n          :else (recur (reduce\n                        (fn [a [k v]] (assoc a k (if (nil? (a k)) v (f (a k) v))))\n                        o\n                        h)\n                       (first t)\n                       (rest t)))))","problem":69,"user":"52d7f9a8e4b09f7907dd1381"},{"code":"(fn r [f & k]\n  (into {} \n        (map #(vector (first %) \n                      (let [[x & xs :as s](map val (second %))] \n                        (if xs (apply f s) x)))\n                      (group-by key (apply concat k)))))","problem":69,"user":"51b793d3e4b0d906fcd71d38"},{"problem":69,"code":"(fn [f & ms]\n  (let [mrg (fn [m [k v]]\n              (if (contains? m k)\n                (assoc m k (f (get m k) v))\n                (assoc m k v)))\n        go (fn [m n]\n             (reduce mrg m (seq n)))]\n    (reduce go ms)))","user":"4f037faf535dcb61093f6af8"},{"problem":69,"code":"(fn\n  [f & maps]\n  (when (some identity maps)\n    (let [merge-entry (fn [m e]\n                        (let [k (key e) v (val e)]\n                          (if (contains? m k)\n                            (assoc m k (f (get m k) v))\n                            (assoc m k v))))\n          merge2 (fn [m1 m2]\n                   (reduce merge-entry (or m1 {}) (seq m2)))]\n      (reduce merge2 maps))))","user":"5a66f358e4b0512ff01cd9d5"},{"code":"(fn [f m & ms]\n  (reduce \n    (fn [ret x]\n      (reduce \n        (fn [r k] \n          (conj r (if (r k) [k (f (r k) (x k))] (find x k)))) \n        ret (keys x))) \n    (cons m ms)))","problem":69,"user":"4fc2e302e4b081705acca33a"},{"problem":69,"code":"(fn [f & ms]\n  (reduce #(let [[a,b] %2]\n             (if (%1 a)\n               (update-in %1 [a] f b)\n               (conj %1 %2)))\n          {}\n          (apply concat ms)))","user":"567b39b6e4b05957ce8c61a3"},{"problem":69,"code":"(fn [f m & ms]\n  (reduce (fn [res m-n]\n            (reduce (fn [r_ m-e]\n                      (let [mk (key m-e)\n                            mv (val m-e)]\n                        (if (contains? r_ mk)\n                          (assoc r_ mk (f (get r_ mk) mv))\n                          (assoc r_ mk mv))))\n                    res\n                    (seq m-n)))\n          m\n          ms))","user":"540a4f20e4b0addc1aec66ef"},{"code":"(fn [f & ms]\n  (let [r (fn [m1 m2]\n            (reduce\n             (fn [m [k v]]\n               (conj m (if (contains? m k)\n                         [k (f (m k) v)]\n                         [k v])))\n             m1 m2))]\n    (reduce r (first ms) (rest ms))))","problem":69,"user":"4fb79872e4b081705acca2d2"},{"problem":69,"code":"(fn [f & ms]\n    (reduce (fn [m_x m_y]\n                (loop [kv_ys (seq m_y)\n                       m_xy m_x]\n                      (if (empty? kv_ys)\n                          m_xy\n                          (recur (rest kv_ys) \n                                 (if (contains? m_x (first (first kv_ys)))\n                                     (assoc m_xy \n                                            (first (first kv_ys))\n                                            (f (get m_x (first (first kv_ys)))\n                                               (second (first kv_ys))))\n                                     (assoc m_xy\n                                            (first (first kv_ys))\n                                            (second (first kv_ys)))))))) ms))","user":"5a34f342e4b0ddc586f153d1"},{"problem":69,"code":"(fn [f & maps]\n  (reduce (fn [r map]\n            (reduce-kv (fn [m k v]\n                         (if (m k)\n                           (assoc m k (f (m k) v))\n                           (assoc m k v)))\n                       r map))\n          (first maps) (rest maps)))","user":"5ccc2a03e4b0ccb06196288f"},{"code":"(fn [f & maps]\n  (apply hash-map\n   (mapcat\n    #(list\n      (first %)\n      (if ( > (count (last %)) 1)\n        (apply f (map last (last %)))\n        (last (first (last %)))))\n  \t(group-by first (apply concat maps)))))","problem":69,"user":"50e7cef1e4b077ad597af36a"},{"code":"(fn\n  [f & ms]\n  (loop  [f f ms ms r {}]\n    (if (empty? ms)\n      r\n      (recur f \n             (rest ms) \n             (reduce #(assoc %1 \n                        (key %2) \n                        (if-let [old-val (get %1 (key %2))]\n                          (f old-val (val %2))\n                          (val %2))) \n                     r \n                     (first ms))))))","problem":69,"user":"4fdf566fe4b05e33b9224f99"},{"code":"(fn my-merge-with [f & maps]\n  (let [stream (mapcat seq maps)\n        grouped (reduce (fn [m, x] (assoc m (first x) (conj (get m (first x) []) (second x)))) {} stream)]\n    (into {} (for [[k v] grouped] [k (reduce f v)]))))","problem":69,"user":"50cb4cf6e4b0f78a8e1645b4"},{"problem":69,"code":"(fn [f & maps]\n  (loop [result {}\n         ms maps]\n    (if (empty? ms)\n      result\n      (recur (conj result\n                   (loop [ires {}\n                          inner (first ms)]\n                     (if (empty? inner)\n                       ires\n                       (if (contains? result (key (first inner)))\n                         (recur (conj\n                                 ires\n                                 {(key (first inner)) (f (result (key (first inner)))\n                                                         (val (first inner)))})\n                                (rest inner))\n                         (recur (conj ires (first inner)) (rest inner)))))) (rest ms)))))","user":"592ac550e4b072a2710fcf27"},{"problem":69,"code":"(fn [f & ms] \n  (reduce \n   (fn [a b] \n     (reduce\n      (fn [x y] (assoc x y (if (x y) (f (x y) (b y)) (b y)))) a (keys b))) \n   ms))","user":"5b919d9de4b0c0b3ffbd4a24"},{"problem":69,"code":";(update-in {1 3 5 7} [5] #(- % 2))\n\n;(\n(fn [f & ms]\n  (let [mrg-1 (fn [old-m [k v]]\n                (if (contains? old-m k)\n                  (update-in old-m [k] #(f % v))\n                  (conj old-m [k v])))                           \n        mrg (fn [old-m nxt-m]\n              (reduce mrg-1 old-m nxt-m))]\n    (reduce mrg ms)))\n;+ {1 3 3 6 2 4} {1 1 5 5 2 6})","user":"57df2722e4b0bd073c20245e"},{"code":"(fn [f & ms]\n              (reduce\n               (fn [m1 m2]\n                   (reduce\n                    (fn [m k]\n                        (let [a (get m1 k) b (get m2 k)]\n                             (do\n                              (println m k)\n                              (cond\n                               (and a b) (assoc m k (f a b))\n                               a         (assoc m k a)\n                               b         (assoc m k b)))))\n                    {}\n                    (concat (keys m1) (keys m2))))\n               ms))","problem":69,"user":"4ee82223535d93acb0a66877"},{"problem":69,"code":"(fn [f & maps]\n  (reduce\n   (fn [acc-map current-map]\n     (merge acc-map\n            (reduce-kv\n             (fn [sub-acc-map k v]\n               (assoc sub-acc-map k (if-let [val (get acc-map k)]\n                                      (f val v)\n                                      v)))\n             {}\n             current-map)))\n   maps))","user":"59b93cd7e4b0a024fb6ae3c7"},{"code":"(fn n69 [f & maps]\n  (letfn [(merge-entry [m e] (let [[k v] e] (if (contains? m k) (assoc m k (f (get m k) v)) (assoc m k v))))]\n    (reduce #(reduce merge-entry %1 (seq %2)) maps)\n    ))","problem":69,"user":"52b43468e4b0c58976d9ad1b"},{"problem":69,"code":"(fn [f m & ms]\n  (loop [ret m\n         ms-it ms]\n    (if (empty? ms-it)\n      ret\n      (recur (let [cur-m (first ms-it)]\n               (loop [conj-it {}\n                      cur-m-it cur-m]\n                 (if (empty? cur-m-it)\n                   (conj ret conj-it)\n                   (recur (let [[keyw value] (first cur-m-it)]\n                            (if (get ret keyw)\n                              (into conj-it {keyw (f (get ret keyw)\n                                              value)})\n                              (into conj-it {keyw value})))\n                          (rest cur-m-it)))))\n             (rest ms-it)))))","user":"559d33b3e4b0ec2b359424d9"},{"problem":69,"code":"(let [merge-value (fn [m k v f]\n    (if (contains? m k) (assoc m k (f (get m k) v)) (assoc m k v)))\n\n  merge-map (fn [m m1 f]\n    (if (empty? m1)\n    m\n    (let [[k v] (first m1)]\n      (recur (merge-value m k v f) (rest m1) f)\n    )\n    )\n    )\n]\n  (fn [f & maps]\n    (loop [m {} ms maps]\n      (prn m ms)\n      (if (empty? ms)\n      m\n      (recur (merge-map m (first ms) f) (rest ms))\n      )\n    )\n  )\n)","user":"5681afaae4b0945ebc182a87"},{"problem":69,"code":"(fn ! [f & args]\n  (let [ff (fn [fm nm] \n             (let [[c d] (split-with #(contains? fm %) (keys nm))]\n               (merge fm (select-keys nm d) (zipmap c (map f \n                                                           (map (partial get fm) c) \n                                                           (map (partial get nm) c))))))]\n    (reduce ff args)))","user":"554680cbe4b0a04f7929953e"},{"code":"(fn [f mr & ms]\n  (let [_merge (fn _merge [f r m](loop [r r ks (keys m)](let [k (first ks)] (if (empty? ks) r(recur (merge r {k (if (contains? r k)(f (r k) (m k)) (m k))}) (rest ks))))))] \n  (loop [r mr ms ms]\n     (if (empty? ms) r\n       (recur (_merge f r (first ms)) (rest ms))\n     )\n  ))\n)","problem":69,"user":"522eba30e4b01cdb292c5f0e"},{"problem":69,"code":"(fn [f & args]\n  (reduce (fn[map1 map2]\n            (reduce (fn [m [k v]]\n                      (if-let [vv (m k)]\n                        (assoc m k (f vv v))\n                        (assoc m k v)))\n                    map1 map2))\nargs))","user":"5790f9d7e4b0ebec4cfb75b4"},{"code":"(fn [f1 & maps]\n   (let [allkeys   (set (flatten (map keys maps)))]\n     (into {} (for [k allkeys]\n                (let [stuffs (reduce f1 (vec (filter identity (map (fn [m] (m k)) maps))))]\n                  (if (seq? stuffs)\n                    [k (vec stuffs)]\n                    [k stuffs]))))))","problem":69,"user":"4ee7fe83535d93acb0a66874"},{"problem":69,"code":"(fn __\n  ([f] {})\n  ([f m1] m1)\n  ([f m1 & args]\n      (loop [a args\n            m m1]\n            (if (empty? a) m\n              (recur (rest a)\n                       (reduce\n                        #(let [k (first %2)\n                              v (second %2)\n                              v0 (get %1 k false)]\n                              (if v0 (conj %1 [k (f v0 v)])\n                                (conj %1 [k v])))\n                        m (first a)))\n            ))\n))","user":"5a0ce1a5e4b04bbd27e6d9b7"},{"problem":69,"code":"(fn [f m & ms] \n  (reduce \n   #(reduce \n     (fn [r [k v]] (if (contains? r k) (update-in r [k] f v) (assoc r k v)))\n     % %2) \n   m ms))","user":"542a8d07e4b01498b1a71b43"},{"problem":69,"code":"(fn fib [ f & args] \n  (let [m (group-by key (apply concat args)) ]\n \t\t(zipmap (keys m) (map #(reduce f (vals %)) (vals m)))\n  ))","user":"57887de2e4b0ebec4cfb751c"},{"problem":69,"code":"(fn [f & x]\n  (reduce \n   #(reduce (fn [m [k v]]\n              (assoc m k (if (m k) (f (m k) v) v)))\n            %1 %2)\n          x))","user":"53a01fb1e4b0ca733b9744a6"},{"problem":69,"code":"(fn [f & ms]\n  (reduce (fn [m1 m2]\n            (reduce (fn [m [k v]]\n                      (if (contains? m k)\n                        (update-in m [k] f v)\n                        (assoc m k v)\n                        ))\n                    m1 m2)\n            )\n          ms))","user":"5baaae06e4b0a20761a23464"},{"problem":69,"code":"(fn [f & xs]\n  (reduce (fn [m n] (into m (for [[x y] n] (if-let [mval (m x)] [x (f mval y)] [x y]))))\n          {} xs))","user":"54924f64e4b0b312c081ff42"},{"problem":69,"code":"(fn mw [f & all]\n  (let [l (first all)\n        s (second all)\n        r (drop 2 all)\n        ai (fn ai [f acc i]\n              (let [k (key i)\n                    v (val i)\n                    o (acc k)]\n                (assoc acc k (if o (f o v) v))))\n        n (reduce #(ai f %1 %2) l s)]\n    (if (empty? r)\n      n\n      (apply mw f (cons n r)))))","user":"52bc6cb2e4b07a9af57922f5"},{"code":"(fn [op orig & maps]\n  (letfn [(op-if-cont [o [k v]]\n            {k\n             (if (contains? o k)\n               (op (o k) v)\n               v)})]\n    (loop [[m & rst] maps\n           res orig]\n      (if m\n        (->> m\n             (map (partial op-if-cont res))\n             (apply merge res)\n             (recur rst))\n        res))))","problem":69,"user":"4f437751e4b0d7d3c9f3fd20"},{"problem":69,"code":"(fn [f & xs]\n  (loop [\n      result (first xs)\n      the-rest (rest xs)\n    ]\n    (if (empty? the-rest)\n      result\n      (let [item (first the-rest)]\n        (recur\n          (merge\n            ; apply f to all keys already in list\n            (apply merge\n                (map (fn [[k v]]\n                (let [val (item k)]\n                  (if (not (nil? val))\n                    (hash-map k (f v val))\n                    (hash-map k v)\n                  )\n                )\n              ) result)\n            )\n            ; adding new keys to list\n            (merge {} (filter (fn [[k v]]\n              (nil? (result k))\n              ) item)\n            )\n          )\n          (rest the-rest)\n        )\n      )\n    )\n  )\n)","user":"55d79b87e4b0e31453f64aa8"},{"code":"(fn [f & ms] (loop [ms ms r {}]\n                         (if (empty? ms)\n                             r\n                           (recur (rest ms)\n                                  (reduce (fn [a [k v]] \n                                              (assoc a k\n                                                     (if-let [ov (a k)]\n                                                             (f ov v)\n                                                             v)))\n                                          r\n                                          (first ms))))))","problem":69,"user":"4f614976e4b0defedf855fbb"},{"problem":69,"code":"(fn [f & args] (reduce #(assoc %1 (key %2) (if (= 1 (count (val %2))) (second (first (val %2))) (apply f (map second (val %2))))) {} (group-by first (reduce into [] args))))","user":"58987ee9e4b00487982d52d2"},{"problem":69,"code":"(do\n  (fn [f x & xs]\n    (let [merge-if-present (fn [a b] (if (nil? a) b (f a b)))\n          merge-maps (fn [m1 m2]\n                       (reduce (fn [acc [k v]]\n                                 (update-in acc [k] merge-if-present v))\n                               m1 m2))]\n      (reduce merge-maps x xs)))\n\n  (fn [f x & xs]\n    (let [merge-fn (fn [a b] (if (nil? a) b (f a b)))]\n      (reduce (fn [acc [k v]] (update-in acc [k] merge-fn v))\n              x\n              (mapcat seq xs)))))","user":"524740e7e4b05ef8e38e635d"},{"problem":69,"code":"(fn [f & cs] (reduce (fn [m [k v]] (let [v2 (if (contains? m k) (f (m k) v) v)] (assoc m k v2))) {} (apply concat cs)))","user":"53b2a7f8e4b047364c04449c"},{"problem":69,"code":"(fn [f & ms]\n (reduce \n  (fn [m1 m2]\n          (reduce (fn [m [k v]] \n                   (if (m k)\n                    (assoc m k (f (m k) v)) \n                    (assoc m k v))) m1 m2)) \n  ms))","user":"5e17c269e4b00200644e3d5c"},{"problem":69,"code":"(fn [ f & p ] \n   (reduce \n   \t(fn [r m]             \n        (loop [s (keys m)\n               a r ]\n          (if (empty? s)\n            a\n            (let [k (first s)] \n              (recur \n               (rest s)\n               (assoc a\n                 k\n                 (if (a k)\n                   (f (a k) (m k))\n                   (m k))))))))           \n   (first p)   \t\t\t\n   (rest p)))","user":"54b45938e4b05787c3b1638f"},{"problem":69,"code":"(fn [f first-map & rest-maps]\n  (reduce\n   (fn [a b]\n     (reduce\n      (fn [x [k v]]\n        (assoc x k (if-let [value (x k)]\n                     (f v value)\n                     v)))\n      b\n      a))\n   first-map\n   rest-maps))","user":"5724a4dae4b0c5bde472c0fe"},{"problem":69,"code":"(fn [f & maps]\n   (reduce (fn [acc cur]\n             (if (empty? acc)\n               (conj acc cur)\n               (->> (set (apply concat (map keys [acc cur])))\n                    (map #(cond\n                            (and (contains? acc %)\n                                 (contains? cur %)) {% (f (acc %) (cur %))}\n                            (contains? acc %) {% (acc %)}\n                            (contains? cur %) {% (cur %)}))\n                    (apply merge))))\n           {} maps))","user":"5fa80c01e4b0fa27300f3de2"},{"code":"(fn\n  [f & maps]\n  (reduce\n    (fn [result m]\n      (let [common-keys (keys (select-keys result (keys m)))\n             new-vals (map f (map result common-keys) (map m common-keys))\n             new-map (zipmap common-keys new-vals)]\n             (merge result m new-map)\n        ))\n    maps)\n  )","problem":69,"user":"5201ada5e4b0b2e020a18f14"},{"code":"(fn [f & maps]\r\n        (loop [acc {}\r\n               maps maps]\r\n         (if (empty? maps)\r\n            acc\r\n            (let [hd-map (first maps)\r\n                  dup-keys (clojure.set/intersection (set (keys acc)) (set (keys hd-map)))\r\n                  dup-key-map (if (not (empty? dup-keys)) (apply assoc {} \r\n                               (mapcat (fn [key] [key (f (get acc key) (get hd-map key))]) dup-keys)))]\r\n              (recur (conj acc hd-map dup-key-map) (rest maps))))))","problem":69,"user":"502a5e59e4b09e8f859a9fbc"},{"problem":69,"code":"(fn [f & maps]\n  (reduce (fn [merged-map new-map]\n            (reduce (fn [merged-map [key val]]\n                      (if (contains? merged-map key)\n                        (assoc merged-map key (f (get merged-map key) val))\n                        (conj merged-map [key val])))\n                    merged-map\n                    new-map))\n          maps))","user":"56603e5fe4b068f2fe63dc4a"},{"code":"(fn [f & args] \n  (loop [[m & l] args r {}]\n    (if (empty? m) r (recur l (reduce #(if (not (% (first %2))) (conj % %2) (conj % {(first %2) (f (% (first %2)) (last %2))})) r m)))))","problem":69,"user":"4f0e4ebd535d0136e6c22322"},{"code":"(fn [f & ms]\r\n          (reduce (fn [res m]\r\n                    (reduce (fn [a k] (if (a k)\r\n                                        (assoc a k (f (a k) (m k)))\r\n                                        (assoc a k (m k))))\r\n                            res (keys m)))\r\n                  ms))","problem":69,"user":"503d129fe4b06c4e0e1fa254"},{"problem":69,"code":"(fn m-w [f & maps]\n  (into {}\n    (for [key (set (flatten (map keys maps)))]\n      [key   (apply\n               (fn ([x] x)\n                   ([x & ys] (apply f x ys)))\n              (keep #(get % key) maps))])))","user":"5a91988ae4b002d099cae6f9"},{"problem":69,"code":"(fn\n  [ip-operator & given-array]\n  (print (first given-array))\n  (reduce\n   (fn [acc curr]\n     (reduce\n      (fn [internal-acc internal-curr]\n        (if (contains? internal-acc (first internal-curr))\n            (assoc internal-acc (first internal-curr)\n                   (ip-operator (get internal-acc (first internal-curr)) (second internal-curr)))\n            (assoc internal-acc (first internal-curr) (second internal-curr))))\n      acc\n      curr))\n   (first given-array)\n   (rest given-array)))","user":"5d8c8175e4b0915913b1d3e1"},{"code":"(fn [f & args]\n  (let [my-keys (distinct (flatten (map keys args)))\n        my-items (map (fn [k] (filter (complement nil?) (reduce #(conj %1 (get %2 k)) [] args))) my-keys)\n        my-vals (map #(if (= 1 (count %)) (first %) (apply f %)) my-items)]\n    (apply hash-map (interleave my-keys my-vals))))","problem":69,"user":"532418f3e4b09d4e7a9b54d8"},{"problem":69,"code":"(fn my-merge-with\n  [f & maps]\n  (letfn [(my-merge\n            [f m nm]\n            (reduce-kv (fn [rem k v]\n                         (if (contains? rem k)\n                           (assoc rem k (f (rem k) v))\n                           (assoc rem k v))) m nm))]\n    (reduce (fn [rem x]\n              (my-merge f rem x)) (first maps) (rest maps))))","user":"55c9bc1ee4b0e31453f649f1"},{"code":"(fn [f & the-maps] \r\n    (let [the-keys (distinct (flatten (map keys the-maps)))\r\n    result-maps\r\n\t  (map \r\n\t   (fn [the-key]\r\n\t       (let [the-vals (remove nil? (map #(get % the-key) the-maps))\r\n\t\t     vector-vals? (last (distinct (map vector? the-vals)))\r\n\t\t     result-val\r\n\t\t     (if (zero? (dec (count the-vals))) \r\n\t\t\t (first the-vals)\r\n\t\t       (apply f the-vals))]\r\n\t\t (hash-map \r\n\t\t  the-key \r\n\t\t  (if vector-vals? (into [] result-val) result-val))))\r\n\t   the-keys)]\r\n      (into {} result-maps)))","problem":69,"user":"4f9c4080e4b0dcca54ed6d1a"},{"problem":69,"code":"(fn [f & s]\n    (let [ts (group-by first\n              (apply concat s))]\n      (apply assoc {} (interleave\n        (keys ts)\n        (map #(let [v (map last %)]\n                (if (second v)\n                  (apply f v)\n                  (first v) ))\n             (vals ts)) ))))","user":"594c1baae4b07ddc2dafae59"},{"code":"(fn [f m & maps]\n  (letfn [(add_entry [m k v] (assoc m k (if (m k) (f (m k) v) v)))\n          (merge_with_single [m1 m2] (if-not (empty? m2) (let [[k v] (first m2)] (recur (add_entry m1 k v) (dissoc m2 k))) m1))\n          (merge_with_all [m maps] (println m maps) (if-not (empty? maps) (recur (merge_with_single m (first maps)) (rest maps)) m))]\n    (merge_with_all m maps)))","problem":69,"user":"4e8b98fc535d65386fec2124"},{"code":"(fn [op & maps]\n  (reduce\n    (fn [m1 m2]\n      (let [keys1 (set (keys m1))\n            keys2 (set (keys m2))\n            shared (clojure.set/intersection keys1 keys2)\n            unchanged-part (conj\n              (select-keys m1 keys1)\n              (select-keys m2 keys2))\n          ]\n          (reduce (fn [m k] \n            (assoc m k (op (m1 k) (m2 k))))\n            unchanged-part\n            shared)))\n    maps))","problem":69,"user":"4fa340b4e4b081705acca18c"},{"problem":69,"code":"(fn xmerge-with\n  [f & maps]\n  (reduce (fn [acc item]\n            (reduce (fn [inacc initem]\n                      (if (contains? inacc (first initem))\n                        (update-in inacc [(first initem)] f (second initem))\n                        (assoc inacc (first initem) (second initem)))) acc item))\n          {} maps))","user":"590b3aeae4b047aa04b199d0"},{"problem":69,"code":"(fn mgmy ([f i l] (reduce-kv \n                   (fn [m k v] \n                     (if (contains? m k) \n                       (assoc m k (f (m k) v)) (assoc m k v))) i l))\n  ([f i l & e] (reduce #(mgmy f % %2) (mgmy f i l) e))\n)","user":"5c308385e4b0d62ef62d9f1c"},{"problem":69,"code":"(fn [joiner target & inputs]\n   (reduce\n     (fn [v1 v2]\n       (reduce\n         (fn [target [new_k new_v :as new_item]]\n           (if (target new_k)\n             (update-in target [new_k] joiner new_v)\n             (conj target new_item)))\n         v1\n         v2))\n     target\n     inputs))","user":"5711b532e4b09c608db70449"},{"problem":69,"code":"(fn __ [f & m]\n  (->> m\n       (map seq)\n       (reduce concat)\n       (group-by first)\n       (map (fn[[k vs]] [k (map last vs)]))\n       (map (fn[[k vs]] [k \n                         (if (> (count vs) 1)\n                             (apply f vs)\n                             (first vs)\n                             )]))\n       (into (hash-map))\n       )\n  )","user":"5c17467fe4b01240ff5671df"},{"problem":69,"code":"(fn [f & l]\n  (let [ks ((comp #(set (apply concat %)) #(map keys %)) l)\n        fa #(let [se (remove nil? %)] (if (<= (count se) 1) (first se) (apply f se) ))\n        func (fn [k] {k, (fa (map #(% k nil) l))})\n        ]\n    (apply conj (map func ks))\n    )\n  )","user":"54a1d643e4b09f271ff37c50"},{"code":"(fn merge-with-function [f & ms]\r\n  (letfn [(help [m1 m2]\r\n            (let [ks (keys m2)]\r\n              (reduce (fn [m k]\r\n                        (if (m k)\r\n                          (conj m [k (f (m k) (m2 k))])\r\n                          (conj m [k (m2 k)]))) m1 ks)))]\r\n    (loop [an {} ms ms]\r\n      (if (empty? ms)\r\n        an\r\n        (recur (help an (first ms)) (rest ms))))))","problem":69,"user":"4dd62278535d2dad7130b5c7"},{"code":"(fn [f & maps]\n  (let [combine-vals (fn [a b]\n                  (cond\n                   (nil? a) b\n                   (nil? b) a\n                   :else (f a b)))\n\n        combine-keys (fn [m1 m2]\n                     (keys (merge m1 m2)))\n\n        combine-maps (fn [m1 m2]\n                       (zipmap (combine-keys m1 m2)\n                               (for [k (combine-keys m1 m2)]\n                                 (combine-vals (m1 k) (m2 k)))))\n        ]\n    (reduce combine-maps maps)))","problem":69,"user":"530578ede4b0d8b024fd3760"},{"problem":69,"code":"(fn [f & m]\n    (reduce (fn [k l]\n               (reduce-kv #(if (contains? % %2)\n                               (update-in % [%2] f %3)\n                               (assoc % %2 %3)) \n                          k \n                          l)) \n            (first m) (rest m)))","user":"5614425ee4b05f002753dfb1"},{"problem":69,"code":"(fn [f & as]\n  (reduce \n    (fn [a1 a2]\n      (reduce \n        (fn [a [k v]]\n          (if (contains? a k)\n            (update-in a [k] f v)\n            (assoc a k v)\n          )\n        )\n        a1 a2)\n      )\n  as)\n)","user":"5958a0c8e4b066ee0a44af8c"},{"code":"(fn [op & m] (reduce (fn [m1 m2]\r\n                        (reduce (fn [m [k v]] (assoc m k (if (contains? m k) (op (get m k) v) v))) m1 m2)) m))","problem":69,"user":"4e9609ad535dbda64a6f6b3e"},{"code":"(let [a apply f first m map p partial \n        r reduce i (p r into) s second]  \n  #(->> (m vec %&) \n     i i\n     (partition 2)\n     (group-by f)\n     (m (juxt f (comp (p r %) (p m s) s)))\n     (a m vector)\n     (a zipmap)))","problem":69,"user":"512f06c5e4b0762be4c7aad7"},{"problem":69,"code":"(fn [f m & ms]\n  (reduce\n   (fn [acc [k v]]\n     (assoc acc k\n            (if-let [prev (get acc k)]\n              (f prev v) v))) m\n   (map (fn [[f s]] (vector f s)) (mapcat identity ms))))","user":"576e607ae4b0979f89651579"},{"code":"(fn [f & ms]\n  (let [ks (distinct (flatten (map keys ms)))]\n    (reduce (fn [h k]\n              (let [vs (keep #(get % k) ms)]\n                (if (< 1 (count vs))\n                  (assoc h k (apply f vs))\n                  (assoc h k (first vs)))))\n            {}\n            ks)))","problem":69,"user":"4fc3a72ae4b081705acca342"},{"problem":69,"code":"(fn [f & maps]\n  (reduce\n   #(reduce (fn [m [k v]]\n              (if (contains? m k)\n                (assoc m k (f (get m k) v))\n                (assoc m k v))) \n            % \n            %2)\n   maps))","user":"563dfc02e4b0da801c4e4662"},{"problem":69,"code":"(fn [f & args]\n  (reduce (fn [res m]\n            (reduce (fn [res [k v]]\n                      (if-let [r (res k)]\n                        (assoc res k (f r v))\n                        (assoc res k v))) res m))\n          {}\n          args))","user":"511688d5e4b0b3e208dba05a"},{"code":"#(reduce (fn [r [k v]]\n           (assoc r k (if (r k)\n                        (% (r k) v)\n                        v)))\n         %2\n         (apply concat %&))","problem":69,"user":"536e0930e4b0fc7073fd6e66"},{"problem":69,"code":"(fn [f & ms]\n  (let [merge-entry (fn [m [k v]]\n                      (assoc m k (if (contains? m k)\n                                   (f (m k) v)\n                                   v)))]\n    (reduce #(reduce merge-entry %1 %2) ms)))","user":"4eb70649535d7eef30807373"},{"problem":69,"code":"(fn merge-with-my [func & maps]\n  (persistent! (\n                reduce\n                (fn [acc map]\n                  (reduce\n                   (fn [acc_in [k v]]\n                     (if (= (get acc_in k) nil)\n                       (assoc! acc_in k v)\n                       (assoc! acc_in k (func (get acc_in k) v))\n                       )\n                     )\n                   acc\n                   map)\n                  )\n                (transient {})\n                maps\n                ))\n  )","user":"574ed2f7e4b02ea11479924a"},{"code":"(fn m [f & maps]\n  (let [all-keys (set (mapcat keys maps))]\n    (reduce (fn [amap k]\n              (assoc amap k (reduce f (filter identity (map #(get % k) maps))))) {}  all-keys)))","problem":69,"user":"532b43c3e4b09d4e7a9b5531"},{"code":"(fn my-merge-with [f map1 & maps]\n  (letfn [(merge-maps [A B]\n            (if-let [[x & xs] (keys B)]\n              (merge-maps (if (A x)\n                            (assoc A x (f (A x) (B x)))\n                            (assoc A x (B x)))\n                          (select-keys B xs))\n              A))]\n    (reduce merge-maps map1 maps)))","problem":69,"user":"4fcaf7a4e4b0ee37620e1857"},{"code":"(fn [f & ms]\n  (reduce\n   (fn [m v]\n     (reduce (fn [mm k] (if-let [mv (get mm k)] (assoc mm k (f mv (v k))) (assoc mm k (v k)))) m (keys v)))\n   {}\n   ms))","problem":69,"user":"5027b41ee4b01614d1633fee"},{"code":"(fn [f & m] \n  (apply hash-map (mapcat (fn [e] (vector (first e) (reduce f (second e))))\n   (reduce \n   (fn [f s] \n     (into f (map #(vector (first %) (conj (f (first %) []) (second %))) s))) \n   {} \n   m))))","problem":69,"user":"506617c3e4b03d366d7cb2ab"},{"problem":69,"code":"(fn [f & maps] \n  (reduce (fn [m1, m2]\n            (let [map-keys (concat (keys m1) (keys m2))]\n              (loop [merged {} k (first map-keys) r (rest map-keys)]\n                (cond\n                 (= nil k) merged\n                 (and (contains? m1 k) (contains? m2 k)) (recur (merge merged {k (f (m1 k) (m2 k))} ) (first r) (rest r))\n                 :else (if (contains? m1 k) \n                         (recur (merge merged {k (m1 k)}) (first r) (rest r))\n                         (recur (merge merged {k (m2 k)}) (first r) (rest r)))\n                 )\n                )\n              )\n            ) maps)\n  )","user":"541bd782e4b01498b1a71a6b"},{"problem":69,"code":"(fn my-merge-with [f & maps]\n  (let [kys (->> (map keys maps) (apply concat) (distinct))]\n    (->>\n     (map \n      (fn [k xsm] (vector k (filter #(not= % :not-found) (map #(% k :not-found) xsm)))) \n      kys \n      (repeat maps))\n     (map \n      #(if (> (count (second %)) 1) \n         (vector (first %) (apply f (second %))) \n         (vector (first %) (first (second %)))))\n     (into {})\n     )))","user":"53c126fce4b00fb29b22125b"},{"problem":69,"code":"(fn my-merge-with [f acc & maps]\n  (loop [f f\n         acc acc\n         maps maps]\n    (if (empty? maps)\n      acc\n      (recur f\n             (reduce #(let [k (first %2)\n                            v (second %2)\n                            orig_v (%1 k)]\n                        (assoc %1\n                               k\n                               (if (nil? orig_v) v (f orig_v v))))\n                     acc\n                     (first maps))\n             (rest maps)))))","user":"587ee260e4b052da650a6353"},{"problem":69,"code":"(fn [f & ms]\n    (reduce\n      (fn [a b]\n        (if (empty? b)\n          a\n          (let [[k v] (first b)\n                r (rest b)]\n            (recur (assoc a k (if (a k)\n                                (f (a k) v)\n                                v\n                                ))\n                   (rest b)))))\n      ms))","user":"5a9d64c8e4b0d174b936c7eb"},{"code":"(fn mrg [f & xs] (let [insertf (fn [m [k v]] (if (contains? m k) (assoc m k (f (get m k) v)) (assoc m k v)))                       \n                       mergef2 #(reduce insertf %1 %2)]\n                   (reduce mergef2 xs)))","problem":69,"user":"515fb48fe4b0e2be8aa20bd5"},{"code":"(fn [op m & ms] \n   (letfn [(combine ([m [k v1]] (let [v2 (m k) v (if v2 (op v2 v1) v1) ] (assoc m k v)))) ]\n     (reduce (partial reduce combine) m ms)))","problem":69,"user":"52dc2bc8e4b09f7907dd13ca"},{"problem":69,"code":"(fn [f x & xs]\n  (reduce\n   (fn [acc m]\n     (reduce\n      (fn [acc [k v]]\n        (if (contains? acc k)\n          (update-in acc [k] f v)\n          (conj acc [k v])))\n      acc m))\n   x xs))","user":"532ecd44e4b019098a6f8b49"},{"problem":69,"code":"(fn [op & maps] \n   (->> maps \n        (mapcat #(for [[k v] %] [k v]))\n        (reduce (fn [m [k v]] (if (contains? m k)\n                                (assoc m k (op (get m k) v))\n                                (assoc m k v)))\n                {})))","user":"506ba58be4b0eda3100c090b"},{"problem":69,"code":"(fn mw [fun & maps]\n    (reduce (fn mw2 [m1 m2]\n              (reduce (fn [m [k v]]\n                        (assoc m k (if (m k) (fun (m k) v) v)))\n                      m1 m2))\n            maps))","user":"5e5b8d92e4b0fd0acd158658"},{"problem":69,"code":"(fn merge [f & xs]\n  (reduce (fn [x,y] \n    (reduce (fn [a,b]\n      (assoc a b (if (contains? a b) (f (a b) (y b)) (y b)))) x (keys y))) {} xs))","user":"5933b736e4b072a2710fd05d"},{"problem":69,"code":"(fn f-merge \n  ([f m n]\n     (if (empty? n)\n       \tm\n       \t(recur f (update-in m [(key (first n))] #(cond (nil? %) (val (first n)) :else (f % (val (first n))))) (next n))))\n  ([f m n & l](reduce (partial f-merge f) m (cons n l))))","user":"55acd080e4b03311e7b73298"},{"code":"(fn [f & m]\n  (letfn [(mw [x y]\n            (reduce (fn [a [k v]]\n                      (let [actual-value (a k)\n                            actual-value (if actual-value\n                                           (f actual-value v)\n                                           v)]\n                       (assoc a k actual-value))) x y))]\n    (reduce mw m)))","problem":69,"user":"4db016af838c48654951d9b9"},{"problem":69,"code":"(fn [f & ms]\n  (reduce (fn [m1 m2]\n            (reduce (fn [m [k v]]\n                      (if (contains? m k)\n                        (update-in m [k] f v)\n                        (assoc m k v)))\n                    m1 m2))\n          ms))\n\n;; redo","user":"5897dda4e4b00487982d52c8"},{"problem":69,"code":"(fn [f map1 & maps]\n  (letfn [(update1 [m [k v]]\n                   (if (nil? (m k))  ; If key k is not in map m...\n                     (assoc m k v)   ;  add new map entry {k v}, else...\n                                     ;  replace existing value for k\n                     (assoc m k (f (m k) v)))) ; w/ value (f old-val new-val)\n          (merge-two [map1 map2]     ; merges two maps, using f\n                    (reduce update1 map1 map2))]\n    (reduce merge-two map1 maps)))   ; mergest first map with remaining maps","user":"4f80db02e4b033992c121bf9"},{"code":"(fn [f & vs]\n  (->>\n   vs\n   (apply concat)\n   (group-by first)\n   (map (fn [[a b]] (vector a (reduce f (map second b)))) )\n   (into {})))","problem":69,"user":"51944aaae4b0142f60b4aedc"},{"code":"(fn merge-with-fn-all [f m & maps]\n  (let [merge-with-fn (fn [f ma mb]\n                        (into ma (for [[k v] mb :let [v1 (ma k)]]\n                                      [k (if v1 (f v1 v) v)])))]\n    (reduce (fn [m1 m2]\n              (merge-with-fn f m1 m2)) m maps)))","problem":69,"user":"4dada426c9a9d6ed2a99dc57"},{"code":"(fn [f & ms]\n  (let [a (set (flatten (map #(map key %) ms)))]\n    (->> a\n      (map\n        (fn [ky]\n          (remove nil? (map #(% ky) ms))\n        )\n      )\n      (map #(reduce f %))\n      (interleave a)\n      (apply sorted-map)\n    )\n  )\n)","problem":69,"user":"4e3456f9535deb9a81d77f2a"},{"code":"(fn [f & maps]\r\n  (letfn [(add1 [mm [k v]]\r\n            (assoc mm k (if (contains? mm k)  (f (mm k) v) v)))\r\n          (add-all [mm m2] (reduce add1 mm m2))]\r\n    (reduce add-all {} maps)))","problem":69,"user":"4ddc1c89535d02782fcbea01"},{"code":"(fn [f & x] ((comp #(zipmap (keys %) (map (comp (partial reduce f) (partial map last)) (vals %))) (partial group-by first) (partial apply concat)) x))","problem":69,"user":"51cbdee1e4b08d8387cbede1"},{"code":"(fn my-merge-with [f & maps]\r\n  (reduce\r\n    (fn [a b]\r\n      (reduce\r\n        (fn [x [k v]]\r\n          (assoc x k (if (b k) (f v (b k)) v)))\r\n        b a))\r\n    (first maps) (rest maps)))","problem":69,"user":"4df669d4535d08e6dec9fe35"},{"problem":69,"code":"(fn [f & colls]\n  (reduce (fn [m1 m2]\n            (reduce (fn [m [k v]]\n                       (if (contains? m k)\n                         (assoc m k (f (m k) v))\n                         (assoc m k v)))\n                    m1 m2)) \n          {} colls))","user":"5640b135e4b08d4f616f5ee8"},{"code":"(fn [f & maps]\n  (reduce (partial reduce\n                   (fn [map [k v]]\n                     (assoc map\n                       k\n                       (if (contains? map k)\n                         (f (map k) v)\n                         v))))\n          maps))","problem":69,"user":"4ebf11bc535dfed6da9c6d9c"},{"code":"(fn [f & ms]\n  (letfn [(mrg [m1 m2]\n               (reduce (fn [m kv]\n                         (let [k (first kv)\n                               v (second kv)]\n                           (if (get m k)\n                             (conj m [k (f (get m k) v)])\n                             (conj m kv)))) m1 m2))]\n    (reduce mrg ms)))","problem":69,"user":"506d5e4ce4b0a302964c5493"},{"problem":69,"code":"(fn [f & a]\n  (let [k (set (mapcat keys a))] \n    (->> k\n      (map (fn [x] (reduce f (filter #(not= nil %) (map #(% x) a)))))\n      (zipmap k)\n    )\n  )\n)","user":"4fc8f671e4b0ee37620e1840"},{"code":"(fn\n  [f & colls]\n  (->>\n   (for [k (distinct (apply concat (map keys colls)))]\n    [k\n     (reduce f\n             (reduce #(if (%2 k)\n                        (conj % (%2 k))\n                        %)\n                     []\n                     colls))])\n   (apply concat)\n   (apply hash-map)))","problem":69,"user":"51852961e4b0da5a5be3babb"},{"code":"(fn [f & maps]\n  (reduce (fn [acc m]\n            (reduce (fn [acc [k v]]\n              (if (contains? acc k)\n                (merge acc {k (f (acc k) v)})\n                (merge acc {k v})))\n            acc m)) maps))","problem":69,"user":"4e22b78b535d04ed9115e81e"},{"code":"(fn my-merge-with [f & ms]\n  (let [merge2 (fn [m1 m2]\n                (conj m1\n                      (into {}\n                        (for [[k v] m2]\n                          (if (contains? m1 k)\n                              [k (f (get m1 k) v)]\n                              [k v])))))]\n       (reduce merge2 ms)))","problem":69,"user":"4fe8aef4e4b07c9f6fd12c6c"},{"problem":69,"code":"(fn [f m & maps] \n   (reduce (fn [a ent]\n             (reduce (fn [b [x y]]\n                       (if (contains? b x)\n                         (assoc b x (f (b x) y))\n                         (assoc b x y)\n                         )) a ent)\n             )\n           m maps))","user":"544e9022e4b0e3978000698b"},{"problem":69,"code":"(fn my-merge-with\n  ([f] nil)\n  ([f m] m)\n  ([f m1 m2]\n    (if (empty? m2)\n      m1\n      (reduce (fn [result [k v]]\n                (assoc result k (if-not (contains? result k)\n                                  v\n                                  (f (result k) v))))\n               m1 m2)))\n  ([f m1 m2 & ms]\n    (reduce (partial my-merge-with f) m1 (cons m2 ms))))","user":"563f1493e4b08d4f616f5ecf"},{"problem":69,"code":"(fn mixall [f m & args]\n  (if (empty? args)\n    m\n    (apply\n     mixall\n     f\n     ((fn mix [f m1 m2]\n        (let [kv (first m2)\n              k (first kv)\n              v1 (m1 k)\n              v2 (m2 k)]\n          (if kv\n            (mix\n             f\n             (assoc\n              m1\n              k\n              (if v1\n                (f v1 v2) v2))\n             (dissoc m2 k))\n            m1)))\n          f m (first args))\n     (rest args))))","user":"598ab445e4b02b9968b84ce0"},{"problem":69,"code":"(fn [f & maps]\n  (letfn [(merge2 [f map1 map2]\n\t  (let [k1 (set (keys map1))\n    \t    k2 (set (keys map2))\n        \tk (clojure.set/intersection k1 k2)\n        \tapplied (for [key k]\n          \t        {key (f (get map1 key) (get map2 key))})]\n    \t(merge map1 map2 (apply merge applied))))]\n    (reduce #(merge2 f % %2) maps)))","user":"4ee75ec2535d93acb0a66867"},{"problem":69,"code":"(fn [f & maps] (let [merge-entry (fn [m e]\n\t\t\t(let [k (key e) v (val e)]\n\t\t\t  (if (contains? m k)\n\t\t\t    (assoc m k (f (get m k) v))\n\t\t\t    (assoc m k v))))\n          merge (fn [m1 m2]\n\t\t   (reduce merge-entry (or m1 {}) (seq m2)))]\n      (reduce merge maps)))","user":"52d954cae4b09f7907dd13a5"},{"problem":69,"code":"(fn mmerge\n   ([f m1 m2]\n     (loop [remain (group-by first (concat m1 m2)) merged {}]\n       (if-let [[k v] (first remain)]\n         (recur (dissoc remain k)\n                (assoc merged k (#(reduce f (map second %)) v )))\n         merged)))\n  ([f m1 m2 & ms]\n    (apply mmerge f (mmerge f m1 m2) ms)))","user":"55f8b32ae4b03cbcff9738ba"},{"problem":69,"code":"(fn mwith [f & ms]\n  (let [apply-keys\n        (fn [res f m]\n          (if (empty? m)\n            res\n            (let [k (-> m (keys) (first))]\n              (if (contains? res k)\n                (recur (assoc res k (f (res k) (m k))) f (dissoc m k))\n                (recur (assoc res k (m k)) f (dissoc m k))))))\n        step\n        (fn [res f & ms]\n          (if (empty? ms)\n            res\n            (recur (apply-keys res f (first ms)) f (rest ms))))]\n    (apply step {} f ms)))","user":"5953bdb6e4b066ee0a44aeed"},{"problem":69,"code":"(fn [f fm & args] (reduce (fn [rm m] (reduce (fn [rm [k v]] (cond (get rm k) (assoc rm k (f (get rm k) v)) :else (assoc rm k v))) rm m)) fm args))","user":"584d8724e4b0b7285a6f4e3e"},{"code":"(fn [f & maps ] \n    (letfn [\n            (merge1 [f m i] (if (contains? m (first i))\n                              (assoc m (first i) (f (m (first i)) (second i)))\n                              (assoc m (first i) (second i))))\n            (mergemap [f m1 m2] (reduce #(merge1 f %1 %2) m1 m2))\n            ]\n      (reduce #(mergemap f %1 %2) {} maps)))","problem":69,"user":"50956c2be4b087f34d351ab2"},{"problem":69,"code":"(fn [f m0 & ms]\n  (reduce (fn [acc m]\n            (merge acc\n                   (reduce (fn [acc1 [k v]]\n                             (if (acc k)\n                               (assoc acc1 k (f (acc k) v))\n                               (assoc acc1 k v)))\n                           {}\n                           m)))\n          m0\n          ms))","user":"5f6d4305e4b02876ed9fd05c"},{"problem":69,"code":"(fn [f m1 & ms]\n      (let [\n            new-f (fn [v1 v2] (if v1 (f v1 v2) v2))\n            reducer-inner (fn [m [k v]] (conj m [k (new-f (get m k) v)]))\n            reducer-outer (fn [m1 m2] (reduce reducer-inner m1 m2))]\n          (reduce reducer-outer m1 ms)))","user":"588e4e05e4b00487982d5188"},{"problem":69,"code":"(fn my-merge-with\n  [f & maps]\n  (into {} (reverse (reduce (fn [my-map item]\n                              (if (contains? my-map (first item))\n                                (assoc my-map (first item) (f (second item) (get my-map (first item))))\n                                (assoc my-map (first item) (second item))))\n                            {} (reverse (mapcat #(keys (group-by identity %)) maps))))))","user":"60396c95e4b0d5df2af222f4"},{"code":"(fn [f m & maps]\n   (loop [r m\n          xs (reduce conj maps)]\n     (if (seq xs)\n       (let [fxs (first xs)\n             k (key fxs)\n             v (val fxs)\n             e (get r k)]\n         (if e\n           (recur (assoc r k (f e v)) (next xs))\n           (recur (assoc r k v) (next xs))))\n       r)))","problem":69,"user":"50aedb8ce4b0a40c9cfb08d4"},{"code":"(fn [h & maps]\n    (let [ks (into #{} (flatten (for [m maps] (keys m)))),                                       ; all keys from all maps in a set\n          vs (for [k ks] (conj {} [k (filter #(not (nil? %1)) (for [map maps] (get map k)))])) ] ; all not-nil values from all keys\n      (loop [f (first vs), r (rest vs), m {}]  ; recursively build up a map to return as our result\n        (let [k (first (keys f)),              ; the current key we're working on\n              n (count (first (vals f)))]      ; the # of values for this key\n          (if (nil? k) m                       ; if it's nil, we're done ... return our result 'm'\n            (cond\n              (= n 1) (recur (first r) (rest r) (conj m [k (first (get f k))])) ; only 1 value, just append to result 'm'\n              :else (recur (first r) (rest r) (conj m [k (apply h (get f k))])))) ; more than 1 value, append to result 'm' the result of h\n          ))))","problem":69,"user":"4f038567535dcb61093f6b0c"},{"code":"(fn mymerge [f & args]\n  (let [hmap (group-by first (mapcat vec args))\n        k (keys hmap)\n        g (fn [hmap a-key]\n            (let [ls (map second (hmap a-key))]\n              (if (> (count ls) 1)\n                [a-key (apply f ls)]\n                (vec (cons a-key ls)))))]\n    (into {} (map #(g hmap %) k))))","problem":69,"user":"51750cd4e4b07031762f2ee5"},{"code":"(fn [f & [m & ms]]\n  (reduce\n    (fn [r [k v]]\n      (if (contains? r k)\n        (assoc r k (f (r k) v))\n        (assoc r k v)))\n    m\n    (apply concat ms)))","problem":69,"user":"4f969a66e4b0dcca54ed6cde"},{"problem":69,"code":"(fn [f & c] (into {} (map #(vector (first %) (reduce (fn [x y] (f x (second y))) (second (first (second %))) (rest (second %)))) (group-by #(identity (first %)) (apply concat (map vec c))))))","user":"5c41db45e4b08cd430848ece"},{"problem":69,"code":"(fn self [func first-map & [second-map & rest-maps :as more-maps]]\n  (if (empty? more-maps)\n    first-map\n    (recur func (reduce (fn [memo [key value]]\n                          (if (contains? memo key)\n                            (assoc memo key\n                                   (func (get memo key) value))\n                            (assoc memo key value)))\n                        first-map second-map) rest-maps)))","user":"545bd22fe4b01be26fd7465a"},{"problem":69,"code":"(fn [func & maps]\n  (reduce\n    (fn [old-map new-map]\n      (loop [acc {} all-keys (set (concat (keys old-map) (keys new-map)))]\n        (if (empty? all-keys)\n          acc\n          (let [current-key (first all-keys) from-old (old-map current-key) from-new (new-map current-key)]\n            (cond\n              (nil? from-old) (recur (assoc acc current-key from-new) (rest all-keys))\n              (nil? from-new) (recur (assoc acc current-key from-old) (rest all-keys))\n              :else (recur (assoc acc current-key (func from-old from-new)) (rest all-keys)))))))\n    maps))","user":"5773f3a9e4b0979f896515f2"},{"problem":69,"code":"(fn my-merge-with [f & maps]\n  (reduce (fn [m-ret m] \n            (reduce (fn [m-ret [k v]]\n                      (assoc m-ret k (if (contains? m-ret k) \n                                       (f (m-ret k) v) \n                                       v))) m-ret m)) \n          (first maps) (rest maps)))","user":"50aa777fe4b056ee01935866"},{"problem":69,"code":"(fn [f & maps]\n  (loop [result (first maps)\n         ms (rest maps)]\n    (if (not (seq ms))\n      result\n      (recur\n       (into result\n             (for [[k v] (first ms)]\n               [k\n                (if (contains? result k)\n                  (f (result k) v)\n                v)]))\n       (rest ms)))))","user":"52be5d55e4b07a9af579231e"},{"problem":69,"code":"(fn [f & ms]\n  (reduce\n    #(reduce-kv (fn [m k v] (assoc m k (if (contains? m k) (f (m k) v) v))) % %2)\n    ms))","user":"4ed45563535d10e5ff6f52c9"},{"problem":69,"code":"(fn mw [op f & l] (reduce #(\n(fn mymerge [op s t]\n(let [sk (keys s)]\n(loop [klist sk tgt t]\n(if (empty? klist) tgt\n(let [k (first klist),\n      vs (s k), vt ( t k),\n      r (rest klist)]\n(if (nil? vt)\n(recur r (assoc tgt k vs))\n(recur r (assoc tgt k \n            (op vs vt)) )\n) ; if\n); if\n)) ;loop let\n)) ; defn let\nop %1 %2) f l)\n)","user":"56c4f971e4b05cc29241ee9d"},{"problem":69,"code":"(fn my-merge-with [f & maps]\n  (reduce\n     #(into (merge %1 %2)\n            (map (fn [k] (vector k (f (get %1 k) (get %2 k))))\n                 (clojure.set/intersection (set (keys %1)) (set (keys %2)))))\n     maps))","user":"54e3df6ae4b024c67c0cf7e3"},{"problem":69,"code":"(fn [f first-map & more-maps]\n    (let [merge-maps \n          (fn [m1 m2]\n            (reduce-kv\n             #(assoc %1 %2\n                     (if (contains? %1 %2)\n                       (f (get %1 %2) %3)\n                       %3))\n             m1\n             m2))]\n      (reduce merge-maps first-map more-maps)))","user":"5531e445e4b09218d5f44f76"},{"problem":69,"code":"(fn [op & maps]\n  (reduce #(into % (for [[k v] %2]\n                     (if (contains? % k)\n                       [k (op (% k) v)]\n                       [k v])))\n          maps))","user":"4fceda40e4b03432b189f407"},{"problem":69,"code":"(fn [f m & o]\n  (reduce (fn [m1 m2]\n            (reduce\n              #(update-in %1 [(first %2)]\n                  (fn [v1 v2] (if v1 (f v1 v2) v2))\n                  (second %2))\n              m1 m2))\n          m o))","user":"5590e55de4b0277789237676"},{"problem":69,"code":"(fn [f & colls]\n  (when (some identity colls)\n    (reduce (fn [new-map coll]\n              (reduce (fn [result [k v]]\n                        (if (contains? result k)\n                          (assoc result k (f (get result k) v))\n                          (assoc result k v)))\n                      new-map coll))\n            {} colls)))","user":"57908d94e4b0ebec4cfb75ac"},{"problem":69,"code":"(fn mw [f & maps]\n    (reduce (fn [m1 m2]\n                (reduce (fn [res [k v]]\n                            (if (contains? res k)\n                                (assoc res k (f (get res k) v))\n                                (assoc res k v)))\n                        m1\n                        (seq m2)))\n            maps))","user":"5ff93da9e4b06df49cee14af"},{"code":"(fn [f & maps]\n  (reduce (fn [h [k v]] (assoc h k\n                              (if (contains? h k)\n                                (f (get h k) v)\n                                v)))\n          {}\n          (apply concat maps)))","problem":69,"user":"4f3e5e87e4b0e243712b1f83"},{"problem":69,"code":"(fn [f & maps]\n\t(let[merge-kvs\n\t\t\t(fn [m [k v]]\n\t\t\t\t(if (contains? m k)\n\t\t\t\t\t(assoc m k (f (get m k) v))\n\t\t\t\t\t(assoc m k v)))\n\t\tmerge-all\n\t\t\t(fn [m1 m2]\n\t\t\t\t(reduce merge-kvs m1 m2))]\n\t(reduce merge-all maps))\n)","user":"5472d919e4b094393f72dd7b"},{"problem":69,"code":"(fn [f m & ms]\n  (reduce (fn [r [k v]]\n            (assoc r k (if (contains? r k) (f (get r k) v) v)))\n          m\n          (apply concat ms)))","user":"55201d18e4b08d5046aa8a5d"},{"problem":69,"code":"(fn [f & ms]\n  (letfn [(merge' [acc [k v]] (if (contains? acc k) (assoc acc k (f (get acc k) v)) (assoc acc k v)))]\n    (reduce #(reduce merge' %1 %2) ms)))","user":"58ee84e5e4b056aecfd47dab"},{"code":"(fn mw\r\n  [f & mp]\r\n  (reduce #(loop [t %\r\n  \t  ms (seq %2)]\r\n\t     (if (empty? ms)\r\n\t       t\r\n\t       (let [k (first (first ms))\r\n\t\t     v (second (first ms))]\r\n\t\t (if (contains? t k)\r\n\t\t   (recur (assoc t k (f (t k) v)) (rest ms))\r\n\t\t   (recur (assoc t k v) (rest ms)))))) {} mp))","problem":69,"user":"4f17ab99535d64f603146457"},{"problem":69,"code":"(fn f [g r & m]\n  (if (empty? m)\n    r\n    (recur\n      g\n      (let [k (first (first (first m)))\n            v (last (first (first m)))]\n        (conj r {k (if (contains? r k)  (g (r k) v) v)}))\n      (if (= 1 (count (first m)))\n        (rest m)\n        (conj \n          (rest m)\n          (rest (first m)))))))","user":"5a3c2a08e4b001c08efc0cdf"},{"code":"(fn [f & ms]\n\t(let [fp (fn [a b]\n\t\t\t\t(if (nil? a) b\n\t\t\t\t\t(f a b)))]\n\t\t(reduce (fn [mf m]\n\t\t\t\t\t(merge mf \n\t\t\t\t\t\t(reduce #(assoc %1 %2 (fp (get mf %2) (get m %2)))\n\t\t\t\t\t\t\t{} (keys m))))\n\t\t\t{} ms)))","problem":69,"user":"4f2baf1ae4b0d6649770a04c"},{"code":"(fn mw [f m & ms]\n  (reduce\n    (fn [resmap curmap]\n      (reduce\n        (fn [mp entry]\n          (if (contains? mp (first entry))\n            (assoc mp (first entry) (f (get mp (first entry)) (second entry)))\n            (assoc mp (first entry) (second entry))\n          ))\n        resmap\n        curmap\n      ))\n    m\n    ms\n))","problem":69,"user":"4e6e10d8535d5021c1a895fd"},{"problem":69,"code":"(fn [f & maps]\n  (let [ks (keys (apply merge maps))]\n    (into {}\n      (for [k ks\n            :let [vs (filter #(not (nil? %)) (map #(get % k) maps))]]\n      \t  [k (reduce f vs)]))))","user":"5da975b9e4b000c986472c32"},{"problem":69,"code":"(fn [f & [h & t]]\n  (reduce\n   (fn [m e]\n     (reduce\n      (fn [acc [k v]]\n        (assoc acc k (if (m k) (f (m k) v) v)))\n     m\n     e))\n   h\n   t))","user":"5881d1c2e4b0f1effa3b7644"},{"code":"(fn [f & a]\r\n   (reduce \r\n    (fn [m [k v]]\r\n      (conj m [k (if (m k) (f (m k) v) v)]))\r\n    {} (apply concat a)))","problem":69,"user":"4fe9de74e4b0547ebccb2475"},{"code":"(fn mymerge [f & s]\n    (reduce\n        (fn [m1 m2]\n            (reduce\n                (fn [m [k v]]\n                    (if (m k)\n                        (assoc m k (f (m k) v))\n                        (assoc m k v)))\n                m1 m2))\n        {} s))","problem":69,"user":"4f128865535d64f603146428"},{"code":"(fn [f & ms]\n  (let [mmap (reduce (fn [acc m]\n                       (reduce (fn [bcc k]\n                                 (assoc bcc k (conj (get bcc k []) (m k)))) acc (keys m))) {} ms)]\n    (apply hash-map (mapcat (fn [[k v]] (vector k (if (> (count v) 1) (apply f v) (first v)))) mmap))))","problem":69,"user":"51bd1a0de4b0df1216cefd93"},{"code":"(fn [f & coll]\n  (reduce (fn [m [the-key the-val]]\n    (if (contains? m the-key)\n      (assoc m the-key (f (m the-key) the-val))\n      (assoc m the-key the-val))) {} (mapcat #(concat %) coll)))","problem":69,"user":"4fcd155de4b065de69964ca3"},{"problem":69,"code":"(fn [f & maps]\n   (let [k (distinct (flatten (map keys maps)))]\n     (zipmap k\n             (for [k k]\n               (reduce f (filter #((complement  nil?) %) (map get maps  (repeat (count maps) k))))))))","user":"56ede653e4b04a395b9a0449"},{"problem":69,"code":"(fn [f m1 & maps]\n   (let [mg (fn my-merge [f m1 m2]\n              (loop [ks (keys m2) m m1]\n                (if (seq ks)\n                  (let [k (first ks)\n                        v2 (m2 k)\n                        v (if (contains? m1 k) (f (m1 k) v2) v2)]\n                    (recur (rest ks) (assoc m k v)))\n                  m)))]\n     (reduce #(mg f %1 %2) m1 maps)))","user":"5370d152e4b0fc7073fd6e9d"},{"problem":69,"code":"(fn [f & ms]\n    (let [mw-one (fn [f m1 m2]\n                   (let [common-keys (set (clojure.set/intersection (set (keys m1)) (set (keys m2))))\n                         m1-kvs (select-keys m1 (clojure.set/difference (set (keys m1)) common-keys))\n                         m2-kvs (select-keys m2 (clojure.set/difference (set (keys m2)) common-keys))]\n                     (-> {}\n                       (into m1-kvs)\n                       (into m2-kvs)\n                       (into (map #(vector % (f (m1 %) (m2 %))) common-keys)))))]\n      (reduce #(mw-one f %1 %2) ms)))","user":"4e837808535db62dc21a62d9"},{"code":"(fn [f & m]\n  (reduce\n    (fn [m [k v]] (conj m [k (if (m k) (f (m k) v) v)]))\n    {}\n    (apply concat (map seq m))))","problem":69,"user":"4f08b15b535dcb61093f6c40"},{"code":"(fn [f & seqs]\r\n     (reduce (fn [acc seq] (reduce (fn [acc [k v]] (if (contains? acc k) \r\n                                                       (assoc acc k (f (acc k) v))\r\n                                                       (assoc acc k v))) acc seq))\r\n             (first seqs)\r\n             (rest seqs)))","problem":69,"user":"4f13047d535d64f60314642c"},{"problem":69,"code":"(fn [f & d]\n  (reduce \n   (fn [a m] \n     (reduce \n      (fn [b [k v]] \n        (if-let [o (b k)] \n          (assoc b k (f o v)) \n          (assoc b k v)))\n      a m)) \n     {} d))","user":"4faf97d8e4b081705acca258"},{"code":"(fn my-merge-with [ f m & ee ]\n (if (empty? ee)\n  m\n  (recur f \n   (reduce \n    (fn[m [k kv]] \n     (assoc m k (if (m k) (f (m k) kv) kv)))\n    m (first ee))\n   (rest ee))))","problem":69,"user":"51f59607e4b0abb92f97f9d5"},{"problem":69,"code":"(fn merger-with\n  ([f m m2]\n   (reduce (fn [acc [k v]] (conj acc [k (if (contains? acc k) (f (acc k) v) v)]))\n           m m2))\n  ([f m m2 & others]\n   (reduce #(merger-with f %1 %2) (merger-with f m m2) others)))","user":"56897739e4b0dcc4269f407d"},{"code":"(fn [f & xs]\n  (reduce\n   (fn [acc m]\n     (apply merge acc\n            (for [k (keys m)]\n              {k (if (contains? acc k)\n                   (f (get acc k) (get m k))\n                   (get m k))}))) {} xs))","problem":69,"user":"52d1e364e4b0d9f9285948e7"},{"problem":69,"code":"(fn m-with\n  [f & maps]\n  (let [merge-maps (fn merge-maps\n                     [f m1 m2]\n                     (reduce (fn [m k]\n                               (if (nil? (m k)) \n                                 (assoc m k (m2 k))\n                                 (assoc m k (f (m k) (m2 k))))) m1 (keys m2)))]\n    (reduce (partial merge-maps f) (first maps) (rest maps))))","user":"5401aefbe4b0df28a13c62c7"},{"problem":69,"code":"(fn [f m & others]\n  (reduce\n   (fn [r [k v]] (if (r k)\n                   (assoc r k (f (r k) v))\n                   (assoc r k v)))\n   m (mapcat seq others)))","user":"55236ad6e4b0882d96d091b1"},{"problem":69,"code":"(fn merge-mm\n  [f & maps]\n  (reduce #(assoc % (first %2)\n                  (if-let [value (% (key %2))] (f value (val %2)) (val %2))) {}\n          (for [m maps\n                kv m]\n            kv)))","user":"5f838122e4b01aacbe7a2715"},{"problem":69,"code":"(fn [p & m]\n  (into {}\n    (for [k (keys (apply merge m))]\n      [k\n       (reduce p\n         (filter\n           #(and %)\n           (map #(get % k) m)))])))","user":"53500869e4b084c2834f4ad3"},{"problem":69,"code":"(fn[f & maps]\n  (reduce (fn [m1 m2]\n            (reduce (fn [m [k v]]\n                      (if (contains? m k)\n                        (assoc m k (f (get m k) v))\n                        (assoc m k v))) m1 m2)) maps))","user":"5eccc5c2e4b016b56eae058f"},{"problem":69,"code":"(fn my-merge-with [f & maps]\n\t(let [all-keys\n\t (distinct (flatten (reduce #(conj %1 (keys %2)) [] maps)))]\n\t (loop [ks (rest all-keys) key (first all-keys) res {}]\n\t \t(if (and (empty? ks) (nil? key))\n\t \t\tres\n\t \t\t(recur (rest ks)\n\t \t\t\t\t\t\t\t\t (first ks)\n\t \t\t\t\t\t\t\t\t (assoc res key \n\t \t\t\t\t\t\t\t\t \t(reduce f (filter (comp not nil?) (reduce #(conj %1 (get %2 key)) [] maps))))\n\t )\n\t ))))","user":"5c87c79be4b048ec896c591b"},{"problem":69,"code":"(fn [f & args]  (reduce  (fn [a b] (merge a  (into {} (map (fn [[k v]] (if (contains? a k) [k (f (a k) v)] [k v]))  b)))) args))","user":"512b07f7e4b078b06821febb"},{"problem":69,"code":"(fn [f  & maps]\n  (reduce (fn [current next]\n            (reduce (fn [curr [k v]]\n                      (if (contains? curr k)\n                        (assoc curr k (f  (curr k) v))\n                        (assoc curr k v)))\n                    current\n                    (for [[k v] next]\n                      [k v])))\n          {}\n          maps))","user":"5508b405e4b06e50f9beb110"},{"code":"(fn mw[f m & maps]\n  (if maps\n    (if (empty? (first maps))\n      m\n      (mw f \n        (reduce\n          (fn [old extra]\n            (let [xtra (if (= clojure.lang.MapEntry (type extra)) extra (first extra))]\n              (if (contains? old (key xtra))\n               (merge old\n                 (hash-map\n                   (key xtra)\n                   (f (get old (key xtra))(val xtra))\n                 )\n               )\n               (merge old extra)\n              ) \n            )\n          )\n          m\n          (first maps)\n        ) \n        (rest maps)\n      )\n    )\n    m\n  )\n)","problem":69,"user":"4f8ea1f7e4b0d4e659cdde69"},{"code":"(fn m-w\n  [f & maps]\n  (when (some identity maps)\n    (let [merge-entry (fn [m e]\n  \t\t(let [k (key e) v (val e)]\n\t\t\t  (if (contains? m k)\n\t\t\t    (assoc m k (f (get m k) v))\n\t\t\t    (assoc m k v))))\n          merge2 (fn [m1 m2]\n\t\t   (reduce merge-entry (or m1 {}) (seq m2)))]\n      (reduce merge2 maps))))","problem":69,"user":"4e6ebd4a535d5021c1a89610"},{"code":"(fn mw\n  ([f m] m)\n  ([f m & ms]\n    (let [[m2 & more] ms]\n      (apply mw f\n        (reduce \n          (fn [m [k v]]\n            (assoc m k\n              (if (m k) (f (m k) v) v)\n            )\n          )\n        m m2)\n      more))))","problem":69,"user":"4f725201e4b07046d9f4f02f"},{"problem":69,"code":"(fn [f & maps]\n  (let [keys-not-in (fn [m ks]\n                      (let [s1 (clojure.set/difference (set (keys m)) (set ks))]\n                        (into {} (remove nil? (map #(if (s1 (key %)) %) m)))))\n        takconj (fn [f m1 m2]\n                  (let [m1only (keys-not-in m1 (keys m2))]\n                    (into {}\n                          (concat m1only\n                                  (for [[k v] m2] (if (m1 k) [k (f (m1 k) v)] [k v]))))))]\n    (reduce #(takconj  f %1 (into {} %2)) {} maps)))","user":"56903cb9e4b0dcc4269f40eb"},{"code":"(fn m [f m1 m2 & ms]\n  (let [r (reduce (fn [m [k v]]\n                    (if (m k)\n                      (assoc m k (f (m k) v))\n                      (assoc m k v)))\n                   m1\n                   m2)]\n    (if (empty? ms)\n      r\n      (apply m f r (first ms) (rest ms)))))","problem":69,"user":"4e7dd982535db169f9c796ee"},{"code":"(fn [comb & hms]\n   (reduce\n    (fn [dest src]\n      (into dest\n            (reduce\n             (fn [hm [k v]]\n               (assoc hm k\n                      (let [curr (dest k)]\n                        (if curr (comb curr v) v))))\n             {}\n             src)))\n    hms))","problem":69,"user":"515cf9b5e4b00901442db1d4"},{"problem":69,"code":"(fn[x & z] (zipmap\n            (keys (apply merge z))\n            (for [i (keys (apply merge z))]\n              (reduce x (filter\n                         #(not(nil? %))\n                         (map #(get % i) z)) ))))","user":"5c683fb5e4b0fca0c16226d5"},{"problem":69,"code":"(letfn [(update-with \n         [f]\n         (fn [m k v]\n           (assoc m k (if (m k) (f (m k) v) v))))]\n  (fn [f & maps]\n    (reduce #(reduce-kv (update-with f) %1 %2) maps)))","user":"5ad63a34e4b0ea6055cfac01"},{"problem":69,"code":"(fn mrg [f & mps]\n\t(reduce \n\t\t#(conj %1\n\t\t\t(apply hash-map (reduce concat \n\t\t\t\t(map \n\t\t\t\t(fn [x] \n\t\t\t\t\t(if (contains? %1 x) [x (f (get %1 x) (get %2 x))] [x (get %2 x)])\n\t\t\t\t\t)\n\t\t\t\t(keys %2)\n\t\t\t\t)\n\t\t\t\t))\n\t\t\t)\n\t\tmps\n\t\t)\n\t)","user":"5545477fe4b0a04f79299531"},{"problem":69,"code":"(fn [f & maps]\n   (->>  maps\n         (apply concat)\n         (group-by first)\n         (#(into {} (for [[k v] %] [k (reduce f (map second v))])))))","user":"550aeddae4b06e50f9beb135"},{"problem":69,"code":"(fn [func a & mps]\n   (reduce (fn [accum m]\n             (let [[k v] (vec m)]\n               (assoc accum k (if (contains? accum k)\n                                (func (get accum k) v)\n                                v))))\n           a (apply concat mps)))","user":"525cc912e4b0cb4875a45d48"},{"problem":69,"code":"(fn g [fx & maps]\n  (reduce #((fn f [fx map entry] (let [entry-key (first entry)\n                            entry-value (second entry)\n                            value-of-map (get map entry-key)]\n                        (if (nil? value-of-map)\n                          (conj map entry)\n                          (conj map [entry-key (fx value-of-map entry-value)])))) fx %1 %2) {} (mapcat vec maps)))","user":"563f2eaae4b08d4f616f5ed1"},{"problem":69,"code":"(fn [f & ms]\n  (->> (mapcat keys ms)\n       (into #{})\n       (map (fn [k] (->> (map #(get % k) ms)\n                         (filter (complement nil?))\n                         (reduce f)\n                         (vector k))))\n       (into {})))","user":"53fc4abae4b0de5c4184859b"},{"problem":69,"code":"(fn my-merge-with [f m & rest-m]\n  (reduce (fn [m1 m2]\n            (let [common-keys (clojure.set/intersection (-> m1 keys set) (-> m2 keys set))\n                  m3 (->> common-keys\n                          (map (fn [k] [k (f (get m1 k) (get m2 k))]))\n                          (into {}))]\n              (merge m3 (apply dissoc m1 common-keys) (apply dissoc m2 common-keys))))\n          m rest-m))","user":"561d8936e4b064ca9f4b16b2"},{"problem":69,"code":"(fn func [f & maps]\n  (reduce\n    (fn [rv k] (assoc rv k (reduce f (filter (complement nil?) (map #(% k) maps)))))\n    {} (mapcat keys maps)))","user":"54dae16de4b024c67c0cf758"},{"problem":69,"code":"(fn [f & maps]\n  (reduce (fn [m1 m2]\n            (reduce-kv (fn [m k v]\n                         (assoc m k (if (get m k)\n                                      (f (get m k) v)\n                                      v)))\n                       m1 m2))\n          maps))","user":"60096aabe4b074f607df667f"},{"code":"(fn [f & maps]\n  (reduce (fn [result m]\n            (into result (map (fn [[k v]]\n                                [k (if (contains? result k)\n                                     (f (get result k) v)\n                                     v)]) \n                              m)))\n          maps))","problem":69,"user":"51aa56c4e4b04e3dc0c27b27"},{"code":"(fn merge-map [f & xs]\n  (let [all-keys (into #{} (mapcat keys xs))]\n    (into {}\n      (map (fn [ak] (vector ak \n                            (let [mvals (filter identity (map #(% ak) xs))]\n                              (if (> (count mvals) 1)\n                                (apply f mvals)\n                                (first mvals)))))\n         all-keys))))","problem":69,"user":"5102ac9de4b00c483ae176fa"},{"problem":69,"code":"(fn [f & ms]\n  (let [ks (set (mapcat keys ms))]\n    (into {} (for [k ks\n                   :let [vs (mapcat #(if (contains? % k) [(get % k)]) ms)\n                         v (if (> (count vs) 1) (apply f vs) (first vs))]]\n               [k v]))))","user":"5896a0e6e4b00487982d52a8"},{"problem":69,"code":";; http://www.4clojure.com/problem/69\n(fn my-merge-with\n  [merge-fn & maps]\n  (loop [out-map {}\n         in-maps maps]\n    (let [next-map (first in-maps)]\n      (if (nil? next-map)\n        out-map\n        (if (empty? next-map)\n          (recur out-map (rest in-maps))\n          (let [next-pair (first next-map)\n                k (key next-pair)\n                existing-val (get out-map k)\n                new-val (val next-pair)\n                new-next-map (dissoc next-map k)]\n            (if (nil? existing-val)\n              (recur (assoc out-map k new-val) (cons new-next-map (rest in-maps)))\n              (let [new-fn-val (merge-fn existing-val new-val)]\n                (recur (assoc out-map k new-fn-val) (cons new-next-map (rest in-maps)))))))))))","user":"5c92105ce4b048ec896c59f7"},{"problem":69,"code":"(fn [function & [head & tail]]\n  (loop [accumulator_map head\n\t\t remaining_maps tail]\n\t(if (empty? remaining_maps)\n\t  accumulator_map\n\t  (let [[first_remaining & remaining_maps] remaining_maps\n\t\t\tto_be_merged (map (fn [[k v]] (if (contains? accumulator_map k)\n\t\t\t\t\t\t\t\t\t\t\t; apply the function to the map\n\t\t\t\t\t\t\t\t\t\t\t[k (function (get accumulator_map k) v)]\n\t\t\t\t\t\t\t\t\t\t\t; the key is not created so just assoc it into the map\n\t\t\t\t\t\t\t\t\t\t\t[k v]))\n\t\t\t\t\t\t\t  first_remaining)\n\t\t\tnew_map (reduce-kv #(assoc %1 %2 %3) accumulator_map (into {} to_be_merged))]\n\t\t(recur new_map remaining_maps))))\n  )","user":"5c05e864e4b0bdcf453d16a5"},{"problem":69,"code":"(fn [f & ms]\n  (reduce\n    (fn [m [k v]]\n      (assoc m k\n             (if (contains? m k)\n               (f (get m k) v)\n               v)))\n    {}\n    (mapcat seq ms)))","user":"4ec1b090535dfed6da9c6db5"},{"code":"(fn [func & maps]\n  (->> maps \n       (apply concat) \n       (group-by key)\n       (map (fn [[k vs]] \n              [k (reduce func (map val vs))]))\n       (into {})))","problem":69,"user":"52b02329e4b0c58976d9acc5"},{"code":"(fn my-merge-with [f & maps]\n  (letfn [(merge-item [fun m item]\n                      (let [k (key item) v1 (m k) v2 (last item)]\n                        (if v1 (merge m {k (apply fun [v1 v2])}) (merge m item))))]\n    (letfn [(merge-map [fun m1 m2]\n                       (reduce (partial merge-item fun) m1 m2))]\n      (reduce (partial merge-map f) {} maps))))","problem":69,"user":"514721c6e4b0d520409ed392"},{"problem":69,"code":"(fn [fun & args]\n   (reduce (fn [acc [k v]]\n             (if (acc k)\n               (assoc acc k (fun (acc k) v))\n               (assoc acc k v))) \n           {} \n           (mapcat seq args)))","user":"54cad2d5e4b057c6fda3a26c"},{"problem":69,"code":"(fn mw [f & maps]\n  (reduce\n   (fn [result m]\n     (let [common-keys (clojure.set/intersection (set (keys m)) (set (keys result)))\n           to-merge (apply (partial dissoc m) (keys result))\n           res (apply merge (map #(hash-map % (f (get result %) (get m %))) common-keys))]\n       (merge result res to-merge)))\n   maps))","user":"56ff45e5e4b08d47c97781bb"},{"code":"(fn [f & args]\n  (reduce\n    (fn [rm l]\n      (reduce \n        (fn [m i]\n          (update-in m [(key i)] #(if (nil? %) (val i) (f % (val i)))))\n        rm \n        l))\n    {}\n    args))","problem":69,"user":"4e7e05a6535db169f9c796fe"},{"problem":69,"code":"(fn merge-with-f [f & maps]\n  (letfn [(conj-with-f [f map val]\n        (let [[k v] val, map-v (get map k)]\n          (if (nil? map-v) (conj map val)\n              (conj map [k (f map-v v)])\n                    )\n              )\n          )]\n        (reduce (fn [m1 m2] (reduce (partial conj-with-f f) m1 (seq m2))) maps))\n        )","user":"57ca95f2e4b05aa3c4741d3b"},{"problem":69,"code":"(fn [f & args]\n  (reduce (fn [map1 map2]\n            (reduce (fn [m [k v]]\n                      (if-let [vv (m k)]\n                        (assoc m k (f vv v))\n                        (assoc m k v)))\n                    map1 map2))\nargs))","user":"5a42dbabe4b0447ef91cc5fc"},{"problem":69,"code":"(fn [f & maps]\n  (reduce\n   #(let [temp (merge % %2)]\n      (apply assoc temp\n(mapcat (fn [kv] (if (contains? %2 (first kv)) [(first kv) (f (last kv) (%2 (first kv)))])) %)     ))\n   maps\n  ))","user":"54349368e4b0b6b47310fcf1"},{"code":"(fn [f & maps]\n  (apply \n   array-map \n   (reduce \n    concat \n    (for [k (set (reduce concat (map keys maps)))]\n      (let [values (for [m maps :when (contains? m k)] (m k))]\n        [k \n         (if (> (count values) 1)\n           (apply f values)\n           (first values))])))))","problem":69,"user":"51899891e4b0288ada3dbdab"},{"code":"(fn [fcn & args]     \n     (let [lst\n           (reduce #(into % %2) [] args)\n           lstb (reduce (fn [s [k v]] (assoc s k (if (s k) (conj  (s k) v ) [v] )  )) {} lst) ]\n\n       (reduce (fn [s [k v]] (assoc s k (if (< 1 (count v)) (apply fcn v) (first v))))  {}  lstb)\n\n     \n     \n     \n\n     ))","problem":69,"user":"5124619ae4b02c3f2a072ccd"},{"problem":69,"code":"(fn [f fm & rm]\n  (reduce (fn [m [k v]] (assoc m k (if (m k) (f (m k) v) v)))\n          fm\n          (apply concat rm)))","user":"559b2ad1e4b066d22e731f4e"},{"problem":69,"code":"(fn [f & maps]\n  (reduce (fn [r m]\n            (merge r\n                   (zipmap (keys m)\n                           (map #(if (contains? r %)\n                                   (f (r %) (m %))\n                                   (m %))\n                                (keys m)))))\n          maps))","user":"59eb63e3e4b0249b7282077c"},{"problem":69,"code":"(fn [f m & r]\n  (reduce (fn [i [k v]]\n            (assoc i k (if (nil? (i k)) v\n                         (f (i k) v))))\n          m (into {} r)))","user":"57d9f603e4b0bd073c20240a"},{"problem":69,"code":"(fn mrg-with [f & ms]\n  (let \n    [ks (set (apply concat (map keys ms)))]\n      (reduce (fn [acc k]\n                (assoc acc k (reduce f (filter (complement nil?) (map #(% k) ms)))\n                  )) {} ks)\n    )\n  )","user":"5245e320e4b09dbe66b56177"},{"problem":69,"code":"(fn[f & maps]\n  (reduce\n   #(reduce\n     (fn[orig [k v]](assoc orig k (if (orig k)\n                                    (f (orig k) v)\n                                    v)))\n     %1\n     %2)\n   maps))","user":"5596af34e4b04c1e5c31d758"},{"problem":69,"code":"(fn [f & maps]\n  (reduce (fn [acc m]\n            (merge acc (->> (map (fn [[k v]]\n                                   [k (if-let [acc-v (acc k)] \n                                        (f acc-v v)\n                                        v)]) m)\n                            (into {})))) \n          {} maps))","user":"5592ba8be4b0c79f6e1db931"},{"problem":69,"code":"(fn [f & maps]\n  (reduce\n   (fn [res m]\n     (reduce\n      (fn [res [key val]]\n        (update-in res [key] #(if % (f % val) val)))\n      res\n      m))\n   maps))","user":"55ccdc6be4b0e31453f64a18"},{"problem":69,"code":"(fn myMergeWith\n  ([f m1 m2]\n   (loop[result m1, remaining m2]\n     (if-let [[k v] (first remaining)]\n       (if (contains? result k)\n         (recur (assoc result k (f (result k) v)) (rest remaining))\n         (recur (assoc result k v) (rest remaining)))\n       result)))\n  ([f m1 m2 & ms]\n   (apply myMergeWith f (myMergeWith f m1 m2) (seq ms))))","user":"556c70dae4b09a3098a524fd"},{"problem":69,"code":"(fn [f m0 & maps] \n (if (empty? maps) m0\n   (reduce (fn [acc-m nxt-m] \n    (reduce-kv \n     (fn [m k v] \n      (assoc m k\n       (if (contains? m k) \n        (f (m k) v) \n        v)) )\n      acc-m nxt-m)) \n  \n    m0 maps)))","user":"57f9011ee4b0d3187e900935"},{"code":"(fn [f & maps]\n  (let [merge-wth (fn [f to from] (reduce #(if (get %1 (key %2)) \n                                           (assoc %1 (key %2) (f (get %1 (key %2)) (val %2))) \n                                           (assoc %1 (key %2) (val %2))) to from))]\n    (reduce #(merge-wth f %1 %2) {} maps)))","problem":69,"user":"513d121fe4b0e544971636a2"},{"problem":69,"code":"(fn [f map & maps]\n   (reduce (fn [acc x]\n             (loop [res acc\n                    [k v] (first x)\n                    r (rest x)]\n               (cond\n                 (nil? k) res\n                 (contains? res k) (recur\n                                    (assoc res k (f (res k) v))\n                                    (first r)\n                                    (rest r))\n                 :else (recur (assoc res k v)\n                              (first r)\n                              (rest r)))))\n           map\n           maps))","user":"55b54ecbe4b01b9910ae2987"},{"problem":69,"code":"(fn merging-with\n  ([f m] \n   m)\n  ([f m & ms]\n  \t(reduce (fn\n            [x y]\n            (reduce #(if (contains? %1 %2)\n                      (assoc %1 %2 (f (%1 %2) (y %2)))\n                      (assoc %1 %2 (y %2))) x (keys y))) m ms)))","user":"527c166de4b03e8d9a4a75b3"},{"problem":69,"code":"(fn mw [f & maps]\n  (loop [rv (first maps) maps (rest maps)]\n    (if (empty? maps)\n      rv\n      (let [right (first maps)\n            ks (apply conj (keys rv) (keys right))\n            both_keys (set (filter #(and (contains? right %) (contains? rv %)) ks))]\n        (recur (merge rv right \n                      (into {} (map #(vector % (f (rv %) (right %))) both_keys)))\n               (rest maps))))))","user":"55934bebe4b0c79f6e1db93b"},{"problem":69,"code":"(fn my-merge-with [f & args]\n  (apply hash-map (apply concat (map \n    #(vector \n      (first %) \n      (reduce f (map (fn [x] (second x)) (second %)))) \n    (group-by #(first %) (mapcat #(seq %) args))))))","user":"561a1af6e4b053970a773b02"},{"problem":69,"code":"(fn mer [f m & rest]\r\n  (reduce\r\n    (fn [acc m]\r\n      (reduce\r\n        #(assoc %1 %2 (if-let [old (%1 %2)] (f old (m %2)) (m %2)))\r\n         acc (keys m)))\r\n    m rest))","user":"5ccb0bbee4b0ccb06196287c"},{"problem":69,"code":"(fn [f & maps]\n  (loop [acc (first maps) remainder (rest maps)]\n    (if (empty? remainder) acc\n      (recur\n        (reduce-kv \n          (fn [m k v]\n            (update-in m [k] (fn [old] (if (nil? old) v (f old v)))))\n        acc\n        (first remainder))\n       (rest remainder)))))","user":"504e71cbe4b0f6ff3350c4b3"},{"problem":69,"code":"(fn my-merge-with\n  [f & maps]\n\n  (if (= 1 (count maps))\n    (first maps)\n    (let [[a b] (take 2 maps)\n          maps' (drop 2 maps)]\n      (apply my-merge-with f (cons (loop [a' a\n                                          b' b]\n                                     (if (empty? b')\n                                       a'\n                                       (let [[k v] (first b')\n                                             b'' (rest b')]\n                                         (if (contains? a' k)\n                                           (recur (assoc a' k (f (get a' k) v)) b'')\n                                           (recur (assoc a' k v) b''))))) maps')))))","user":"5eb4927fe4b00a66d4a95221"},{"problem":69,"code":"(fn my-merge\n  ([f h] h)\n  ([f a b] (into \n            (into \n              (into \n               {} \n               (filter #(not (b (first %))) a))\n              (filter #(not (a (first %))) b))\n            (map #(vector (first %) (f (a (first %)) (b (first %))))  (filter #(b (first %)) a)))\n   )\n  ([f a b & m] (reduce #(my-merge f %1 %2) (my-merge f a b) m))\n  )","user":"50856bd1e4b004985b776e4c"},{"code":"(fn merge-fn [f start & args]\n \n\t(if (= (count args) 0)\n\t\tstart\n\t\t(let [item (first args)]\n\t\t\t(apply merge-fn (concat [f (reduce (fn [memo k]\n\t\t\t\t\t(let [v (start k)]\n\t\t\t\t\t\t(let [ans (if v\n\t\t\t\t\t\t\t(assoc memo k (f v (item k)))\n\t\t\t\t\t\t\t(assoc memo k (item k))\n\t\t\t\t\t\t)]\n\t\t\t\t\t\tans\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t) start (keys item))]\n\t\t\t (rest args)))\n\t\t\t \n\t\t)\n\n\t)\n)","problem":69,"user":"4f7b6b90e4b06e829148e1a4"},{"code":"(fn ms [f & ss]\n  (loop [ret {} \n         ks (reduce clojure.set/union \n                    (map #(into #{} (keys %)) ss))]\n    (if (empty? ks) \n      ret \n      (recur (conj ret {(first ks) (reduce f \n                                           (map (fn [m] (val (find m (first ks))))\n                                                (filter #(not (nil? (find % (first ks)))) ss) ))})\n             (rest ks)))))","problem":69,"user":"4e123905535d04ed9115e7ce"},{"problem":69,"code":"(fn merge-f-maps [f & maps]\n  (reduce #(loop [rem %2\n                  res %1]\n             (if (empty? rem)\n               res\n               (let [[k v2] (first rem)\n                     res (if (contains? %1 k)\n                           (assoc res k (f (%1 k) v2))\n                           (assoc res k v2))]\n                 (recur (rest rem) res))\n               )\n             )\n          (first maps) (rest maps)))","user":"5dd67c22e4b0948ae9d9ad80"},{"code":"(fn [fnc m & maps]\n  (let [all-keys (set (mapcat keys maps))]\n    (loop [ret m\n           maps maps\n           ks (keys (first maps))]\n      (println \"maps: \" maps)\n      (println \"keys: \" ks)\n      (println \"ret : \" ret)\n      (if (empty? maps)\n        ret\n        (if (empty? ks)\n          (recur ret (rest maps) (if (next maps) (keys (fnext maps)) []))\n          (let [new-val ((first maps) (first ks))\n                old-val (ret (first ks))]\n            (println \"old-val: \" old-val)\n            (println \"new-val: \" new-val)\n            (if old-val\n              (recur (update-in ret [(first ks)] fnc new-val) maps (rest ks))\n              (recur (assoc ret (first ks) new-val) maps (rest ks)))))))))","problem":69,"user":"4e58bcd4535d8a8b8723a296"},{"code":"(fn [f & ms]\n  (reduce (fn [out in]\n            (reduce (fn [out [k v]]\n                      (assoc out k (if (contains? out k) (f (out k) v) v)))\n                    out in))\n          {} ms))","problem":69,"user":"4fe84c74e4b07c9f6fd12c3c"},{"problem":69,"code":"(fn [func & args]\n  (loop [maps (rest args), currmap (first (rest args)), ans (first args)]\n    (if (empty? maps)\n      ans\n      (if (empty? currmap)\n        (recur (rest maps) (first (rest maps)) ans)\n        (if (contains? ans (first (first currmap)))\n          (recur maps (rest currmap) (assoc ans (first (first currmap)) (func (get ans (first (first currmap))) (second (first currmap)))))\n          (recur maps (rest currmap) (assoc ans (first (first currmap)) (second (first currmap)))))))))","user":"59369515e4b02506e01a297e"},{"code":"(fn my-merge-with [f & maplist]\n  (reduce  #(reduce (fn [map_ mapEntry]\n                        (let [[k, v] mapEntry] \n                          (if (contains? map_ k)\n                            (conj map_ [k (f (get map_ k) v)])\n                            (conj map_ mapEntry)\n                            ))) %1 %2)\n           {} maplist ))","problem":69,"user":"4f2965ffe4b0d6649770a029"},{"code":"(fn [f & ls]\n  (letfn [(rdc [b r]\n            (if (empty? r) b\n              (recur\n                (reduce \n                  #(let [[k v] %2]\n                    (assoc \n                      %1\n                      k\n                      (if (contains? %1 k)\n                        (f (%1 k) v)\n                        v))) \n                  b \n                  (first r))\n                (rest r))))]\n    (rdc (first ls) (rest ls))))","problem":69,"user":"5003ee7de4b0678c553fc446"},{"problem":69,"code":"(fn [func & lists]\n(letfn [(dm [x a b]\n  (loop [ks (keys b)\n         result a]\n    (if (empty? ks)\n      result\n      (recur (rest ks)\n             (let [k (first ks)]\n               (if (nil? (get result k))\n                 (assoc result k (get b k))\n                 (assoc result k (x  (get result k) (get b k)))))))))]\n  (reduce (partial dm func) lists)\n  ))","user":"57a497e8e4b0a966079561e4"},{"problem":69,"code":"(fn [f & ms]\n  (reduce \n    (fn [acc m]\n      (reduce \n        (fn [m [k v2]]\n          (if-let [v1 (m k)] \n            (assoc m k (f v1 v2)) \n            (assoc m k v2))) \n        acc\n        m))\n    ms))","user":"54397533e4b032a45b86931d"},{"problem":69,"code":"(fn [f & ms] \n  (reduce (fn [m [k v]] \n             (if (m k)\n               (update-in m [k] f v) \n               (assoc m k v))\n          ) \n          {} (apply concat ms)))","user":"5d02fe44e4b0cc9c915881c0"},{"problem":69,"code":"(fn [f & maps]\n   (reduce \n     (fn [reduced new]\n       (reduce-kv \n         (fn [reduced k v]\n           (assoc reduced k (if (reduced k) (f (reduced k) v) v)) \n           ) reduced new)) {} maps))","user":"54094824e4b0addc1aec66da"},{"problem":69,"code":"(fn mw [f result & [l & more-latters]]\n  (if l\n    (apply mw f\n          (reduce\n            (fn [r [k v]] (let [v' (get r k)]\n                            (assoc r k (if v' (f v' v) v))))\n            result\n            l)\n          more-latters)\n    result))","user":"56d68cbae4b0ea9b8538f7cd"},{"problem":69,"code":"(fn [f m & ms]\n  (reduce-kv (fn [acc k v]\n               (if-not (contains? acc k)\n                 (conj acc (vector k v))\n                 (update-in acc [k] f v)))\n             m (apply conj {} ms)))","user":"4fe899a6e4b07c9f6fd12c54"},{"code":"(fn mrg-wth\n  [f m & maps]\n  (reduce\n   (fn [a b]\n     (reduce\n      (fn [mp [k v]]\n        (let [exists? (contains? mp k)\n              existing (get mp k)]\n          (if exists?\n            (assoc mp k (f existing v))\n            (assoc mp k v))))\n      a\n      b))\n   m\n   maps))","problem":69,"user":"51f9527fe4b09be9c177e549"},{"code":"(fn my-merge-with [f & args]\n  ((fn [acc others]\n     (if (seq others)\n       (let [a ((fn [ac more]\n                  (if (seq more)\n                    (let [[k v] (first more)\n                          newac (if (contains? ac k)\n                                  (assoc ac k (f (get ac k) v))\n                                  (assoc ac k v))]\n                      (recur newac (rest more)))\n                    ac))\n                  acc (first others))]\n         (recur a (rest others)))\n       acc))\n     (first args) (rest args)))","problem":69,"user":"4ec75077535d6d7199dd36e0"},{"code":"(fn [f mp & mps] \n  (reduce (fn [m [k v]] (assoc m k (if (contains? m k)\n                                     (f (m k) v)\n                                     v))) \n         mp (apply merge mps)))","problem":69,"user":"4e7f32ee535db966e863cc3a"},{"code":"(fn [f & c] ( let [r1 (fn [f a b] (reduce \n              (fn [m1 [k v]] \n              \t(if-let [vv (get m1 k)]\n                \t(assoc m1 k (f vv v))\n                \t(assoc m1 k v)))\n              a b))]\n            (reduce #(r1 f %1 %2) c)))","problem":69,"user":"519b2570e4b0ac1b7dced6a3"},{"problem":69,"code":"(fn [f & ms]\n    (reduce\n      (fn [m [k v]] (assoc m k (if-let [pv (get m k)] (f pv v) v)))\n      {}\n      (mapcat #(map vec %) ms)))","user":"59419bdfe4b060784b3b78f7"},{"problem":69,"code":"(fn [f x1 & xs]\n  ((fn my-merge [f result rs]\n      (let [ks (clojure.set/union (set (keys result)) (set (keys (first rs))))\n           ks1 (set (keys result)) ks2 (set (keys (first rs)))\n            r1 (reduce\n                #(assoc %1 %2\n                        (cond\n                         (and (contains? ks1 %2) (contains? ks2 %2))\n                         (f (get result %2) (get (first rs) %2))\n                         (and (contains? ks1 %2) (not (contains? ks2 %2)))\n                         (get result %2)\n                         (and (not (contains? ks1 %2)) (contains? ks2 %2))\n                         (get (first rs) %2)\n                         )\n                        )\n                {} (vec ks)) ]\n         (if (empty? (rest rs))\n          r1\n          (my-merge f r1 (rest rs) )\n          ))\n) f x1 xs))","user":"53ca23e3e4b00fb29b2212c6"},{"problem":69,"code":"(fn my-merge-with [f & maps]\n  (reduce\n   (fn [result map]\n     (reduce-kv\n      (fn [result key val]\n        (assoc result\n               key\n               (if (contains? result key)\n                 (f (result key) val)\n                 val)))\n      result\n      map))\n   (first maps)\n   (rest maps)))","user":"60537cd1e4b04c8f2157d152"},{"code":"(fn [f & ms]\n  (reduce (fn [acc m]\n            (reduce (fn [acc [k v]]\n                      (update-in acc [k] (fn [v2]\n                                           (or (and v2 v (f v2 v))\n                                               v2 v))))\n                    acc\n                    (seq m)))\n          (first ms)\n          (rest ms)))","problem":69,"user":"4f32ef71e4b0d6649770a098"},{"code":"(fn [f seed & maps]\n  (reduce (fn [r m]\n            (reduce-kv (fn [ir k v]\n                         (assoc ir k (if (contains? r k) (f (get r k) v) v)))\n                    r m))\n               seed maps))","problem":69,"user":"5348cab4e4b084c2834f4a5e"},{"problem":69,"code":"(fn my-merge [f & maps]\n  (reduce #(conj %\n                 (reduce \n                    (fn [r [k v]]\n                        (let [rv (get r k)] \n                            (assoc r k (if rv (f rv v) v)))) \n                    % \n                    %2))\n          maps))","user":"57644395e4b0994c1922fbf2"},{"code":"(fn [f & ms]\n   (loop [a {}, ms ms, m nil]\n     (cond\n      (and (nil? ms) (nil? m)) a\n      (nil? m) (recur a (next ms) (first ms))\n      :t (let [k (key (first m)) v (val (first m))]\n           (if (a k)\n             (recur (assoc a k (f (a k) v)) ms (next m))\n             (recur (assoc a k v) ms (next m)))))))","problem":69,"user":"4e8510e7535db62dc21a62e7"},{"problem":69,"code":"#(reduce (partial reduce \n                  (fn [m [k v]]\n                    (assoc m k (if (m k) (% (m k) v) v))))\n          %2\n          %&)","user":"53ea5851e4b036ad0777e4e4"},{"code":"(fn[f x & a]( reduce #(if (contains? % (first %2)) (assoc % (first %2) (f (get % (first %2)) (second %2))) (assoc % (first %2) (second %2)))  x (apply concat (map #(seq %) a))))","problem":69,"user":"4fb3dd1ee4b081705acca2a5"},{"code":"(fn [f m & os]\n      (loop [m m, os os]\n        (if (seq os)\n          (recur (apply assoc m (mapcat (fn [[k v]]\n                                          (let [mv (m k ::nf)]\n                                            (if (= mv ::nf)\n                                              [k v]\n                                              [k (f (m k) v)])))\n                                        (seq (first os))))\n                 (rest os))\n          m)))","problem":69,"user":"4f301d02e4b0d6649770a072"},{"problem":69,"code":"(fn [f & [m & ms]]\n    (->> (apply concat ms)\n         (reduce (fn [ret [k v]]\n                   (update-in ret [k] #(if % (f % v) v)))\n                 m)))","user":"54236ce1e4b01498b1a71ad1"},{"problem":69,"code":"(fn [f & [m & ms]]\n  (letfn [(assoc-with-fn [m [k v]] (assoc m k (if (contains? m k) (f (get m k) v) v)))]\n    (reduce #(reduce assoc-with-fn %1 %2) m ms)))","user":"55a12668e4b0acc240e3150b"},{"code":"(fn [f & m]\n  (into {}\n        (for [[k _] (apply merge m)]\n          [k (reduce f (keep #(% k) m))])))","problem":69,"user":"4e823ed7535db62dc21a62c7"},{"code":"(fn [f & args]\n  (reduce\n    #(merge % (into {} (map (fn [[k v]] (if (not (nil? (% k))) {k (f (% k) v)} {k v})) %2))) {} args))","problem":69,"user":"508ee17ae4b0706b2ed3ef8d"},{"problem":69,"code":"(fn [f & ms]\n  (when (some identity ms)\n    (let [m-en (fn [m e]\n                 (let [k (key e) v (val e)]\n                   (if (contains? m k)\n                     (assoc m k (f (get m k) v))\n                     (assoc m k v))))\n          m (fn [m1 m2]\n              (reduce m-en (or m1 {}) (seq m2)))]\n      (reduce m ms))))","user":"58b989dbe4b0888cdc949ccd"},{"code":"(fn [f hmap & hmaps]\n   (reduce  #(reduce-kv (fn [map key val]\n                          (if (contains? map key)\n                            (update-in map [key] \n                                       (fn [val1] (f val1 val)))\n                            (merge map {key val})))\n                        %1 %2) hmap hmaps))","problem":69,"user":"5256c4c1e4b0541d1855ba36"},{"code":"(fn [f & ms]\n  (reduce\n    (fn [m [k v]]\n      (if-let [v1 (get m k)]\n        (assoc m k (f v1 v))\n        (assoc m k v)))\n    {}\n    (apply concat ms)))","problem":69,"user":"4fc4eadee4b081705acca353"},{"code":"(fn mm [f m & more]\n            (let [m2m (fn [f a b]\n                      (reduce (fn [acc [k v]]\n                                (if (nil? (get-in acc [k]))\n                                  (assoc acc k v)\n                                  (assoc acc k (f (get-in acc[k]) v)))) a b))]\n              (if (nil? more)\n                m\n                (apply mm f (m2m f m (first more)) (rest more)))))","problem":69,"user":"4f1b0008535d64f603146473"},{"problem":69,"code":"(fn mw [f & m] (let [c (apply concat m)] (reduce (fn [r [k v]] (if (get r k) (assoc r k (f (get r k) v)) (assoc r k v))) {} c)))","user":"5646dff3e4b0284900eef615"},{"problem":69,"code":"(fn [f & args]\n    (reduce\n      (fn [a b]\n          (reduce\n            (fn [c [k v]]\n                (let [new-v (if (contains? c k)\n                              (f (c k) v)\n                              v)]\n                  (assoc c k new-v)))\n            a\n            b))\n      args))","user":"562e8b2be4b0ab312c17ebbb"},{"code":"(fn [f & ms]\n  (into {}\n    (for [[k vs] (group-by first (apply concat ms))]\n      [k (reduce f (map second vs))])))","problem":69,"user":"4db2cd84535df7e46ed9b6c6"},{"code":"(fn my-merge-with\n  [combiner m & ms]\n  (if (empty? ms)\n    m\n    (let [m2 (reduce\n              (fn [m [k,v]]\n                (assoc m k\n                  (if-let [[k0, v0] (find m k)] (combiner v0 v) v)))\n              m (first ms))]\n      (apply my-merge-with combiner m2 (rest ms)))))","problem":69,"user":"53800d99e4b06839e8705ebd"},{"code":"(fn [f & maps]\n  (letfn [(I [[k v] s]\n            (if (contains? s k)\n              (assoc s k (f v (s k)))\n              (assoc s k v)))\n          (M [s t]\n            (if (empty? s) t\n                (M (rest s) (I (first s) t))))\n          (M* [args]\n            (if (empty? args) {}\n                (M (first args) (M* (rest args)))))]\n    (M* maps)))","problem":69,"user":"51a4416ae4b0def3c5c5868c"},{"code":"(fn[f & mp](reduce \r\n   #(reduce (fn [x [k v]]\r\n              (assoc x k\r\n                     (if-let [xval (x k)] (f xval v) v))) %1 %2) mp))","problem":69,"user":"4fb23582e4b081705acca28a"},{"problem":69,"code":"(fn\n   [f & m]\n   (reduce-kv\n     (fn\n       [m k v]\n       (assoc m k\n         (let [[h & t :as all] (map val v)] (if (nil? t) h (apply f all)))))\n     {}\n     (group-by key (apply concat m))))","user":"576df252e4b0979f8965156f"},{"code":"(fn [op & s] \n  (let [merge-map (fn [m [k v]]\n              (if (contains? m k) \n                (assoc m k (op (m k) v))\n                (assoc m k v)))]\n  (reduce \n    #(reduce merge-map %1 %2) \n      {} s)))","problem":69,"user":"4f3242bae4b0d6649770a08f"},{"code":"(fn [f & maps]\n   (apply merge\n          (for [key (keys (apply merge maps))]\n            (if (and\n                 (contains? (first maps) key)\n                 (contains? (apply merge (rest maps)) key)\n                 )\n              {key (f (get (first maps) key) (get (apply merge (rest maps)) key))}\n              {key (get (apply merge maps) key)}\n              )\n            )\n          )\n   )","problem":69,"user":"4ea31da2535d7eef308072c1"},{"problem":69,"code":"(fn [fc m0 & ms]\n  (reduce\n   (fn [out mn]\n     (reduce\n       (fn [out [k v]]\n         (update-in out\n                    [k]\n                    #(if % (fc % v) v)))\n      out\n      mn))\n   m0\n   ms))","user":"55647a31e4b0c656e3ff1808"},{"problem":69,"code":"(fn mymerge-with [f & maps]\n  (into {} (for [[k v] (group-by first (apply concat (for [m maps] (for [[k v] m] [k v]))))]\n             [k (reduce f (take-nth 2 (drop 1 (apply concat v))))])))","user":"573107d5e4b0cd1946bd0fbc"},{"problem":69,"code":"(fn [f & colls]\n  (reduce (fn [m [k v]]\n            (if (m k)\n              (update-in m [k] f v)\n              (assoc m k v)))\n          {}\n          (mapcat identity colls)))","user":"5591cc56e4b0604b3f94d582"},{"problem":69,"code":"(fn [f s & rest]\n    (let [do-merge (fn [x y]\n                    (reduce\n                     (fn [a b]\n                       (if (a (key b))\n                         (assoc a (key b) (f (a (key b)) (val b)))\n                         (assoc a (key b) (val b))))\n                     x y))]\n      (reduce do-merge s rest)))","user":"5600dccee4b04bb52996e175"},{"problem":69,"code":"(fn my-merge-with\n\t([f xs ys]\n\t\t(reduce (fn [acc pair] \n\t\t\t\t\t(let [k (key pair)\n\t\t\t\t\t\t  vlatter (val pair)\n\t\t\t\t\t\t  vres (acc k)]\n\t\t\t\t\t\t(assoc acc k (if (nil? vres) vlatter (f vres vlatter)))))\n\t\t\txs ys))\n\t([f xs ys & zrest] (reduce #(my-merge-with f %1 %2) (my-merge-with f xs ys) zrest)))","user":"52e657e4e4b09f7907dd1472"},{"code":"(fn [f & m]\n  (reduce (partial reduce \n    #(let [o (%1 (key %2))\n           n (val %2)]\n            (conj %1 [(key %2) (if o (f o n) n)])))\n    m))","problem":69,"user":"4fe83efbe4b07c9f6fd12c3b"},{"problem":69,"code":"(fn [f & ms]\n   (reduce\n    (fn g [acc m]\n      (->> (set (keys m))\n           (map #(if (contains? acc %)\n                   {% (f (acc %) (m %))}\n                   {% (m %)}))\n           (into acc)))\n    (first ms)\n    (rest ms)))","user":"5d4b2155e4b0776584bd6f28"},{"problem":69,"code":"(fn [f m1 m2 & mx]\n  (let [reducer (fn [m [k v]] \n                  (assoc m k (or (and (m k) \n                                      (f (m k) v)) \n                                 v)))]\n    (loop [m (reduce reducer m1 m2)\n           ms mx]\n      (if (empty? ms)\n        m\n        (recur (reduce reducer m (first ms)) (rest ms))))))","user":"56d63729e4b0ea9b8538f7ca"},{"problem":69,"code":"(fn mappity-smackity-merge\n  [f & maps]\n  (when (some identity maps)\n    (let [merge-entry (fn [m e]\n\t\t\t(let [k (key e) v (val e)]\n\t\t\t  (if (contains? m k)\n\t\t\t    (assoc m k (f (get m k) v))\n\t\t\t    (assoc m k v))))\n          mergey-mergey (fn [map1 map2]\n\t\t   (reduce merge-entry (or map1 {}) (seq map2)))]\n      (reduce mergey-mergey maps))))","user":"50e1bdd8e4b019fc399ce17f"},{"problem":69,"code":"(fn [f & maps]\n  (reduce conj {}\n    (for [k (->> maps (map keys) (reduce concat) (set))]\n      (let [vs (->> maps (map #(% k)) (filter identity))]\n        [k (if (next vs) (apply f vs) (first vs))]))))","user":"544e5b22e4b0e39780006983"},{"problem":69,"code":"(fn my-merge-with [f & maps]\n  (letfn [(merge-map [m1 m2]\n            (reduce-kv (fn [ret k v]\n                         (assoc ret k (if (contains? ret k)\n                                        (f (get ret k) v)\n                                        v)))\n                       m1 m2))]\n    (reduce merge-map maps)))","user":"571d063ee4b0145328a76272"},{"problem":69,"code":"(fn merge-with' [function merge-into & merge-from]\n  (loop [target merge-into, queue merge-from]\n    (if (empty? queue)\n      target\n      (recur\n        (reduce \n          (fn [m [k v]] \n            (if (m k)\n              (assoc m k (function (m k) v)) \n              (assoc m k v)))\n          target \n          (first queue))\n        (rest queue)))))","user":"58247423e4b051871117bec5"},{"problem":69,"code":"(fn [f a & x]\n  (reduce\n    #(reduce\n      (fn [a [k v]]\n        (assoc a k (if (a k) (f (a k) v) v)))\n      %\n      %2)\n    a\n    x))","user":"559279b7e4b0604b3f94d58c"},{"problem":69,"code":"(fn [f & mps] \n  (reduce\n   (fn [m m2]\n     (reduce \n      (fn [a [k v]]\n        (if (a k)\n          (assoc a k (f (a k) v))\n          (assoc a k v)))\n      m m2))\n   mps))","user":"53f3a4ace4b0742d9025b0f7"},{"code":"(fn [op & maps]\n  (reduce (fn [l r] \n    (reduce (fn [l k]\n      (let [lv (get l k)]\n        (if (nil? lv)\n          (assoc l k (r k))\n          (assoc l k (op lv (r k)))\n    ))) l (keys r))) maps\n))","problem":69,"user":"504e685fe4b0f6ff3350c4ae"},{"code":"(fn f [combiner initial & others]\n  (if (empty? others)\n    initial\n    (let [[addee & remainder] others\n          keys-in-both (filter #(contains? addee %) (keys initial))]\n      (recur\n        combiner\n        (merge\n          (apply dissoc initial (keys addee))\n          (apply dissoc addee (keys initial))\n          (apply hash-map (mapcat #(list % (combiner (initial %) (addee %))) keys-in-both)))\n        remainder))))","problem":69,"user":"4ec07699535dfed6da9c6da2"},{"code":"(fn ff [f x & args]                                           \n  (reduce (fn [a y-all]                                      \n            (loop [a' a y y-all]                             \n              (print y)                                      \n              (if (empty? y) a'                              \n                  (recur (if (contains? a' (first (first y)))\n                           (update-in a' [(first (first y))] \n                                      f (last (first y)))    \n                           (conj a' y))                      \n                         (rest y))))                         \n            ) x args))","problem":69,"user":"52140b53e4b0961f15ac4d7e"},{"problem":69,"code":"(fn [f & maps]\n  (reduce (fn [t m]\n            (reduce #(let [[k v] %2 v1 (get % k)]\n                       (if-not (nil? v1)\n                         (assoc % k (f v1 v))\n                         (assoc % k v)))\n                    t m))\n          {} maps))","user":"56372c3ce4b0bfe05bf117d1"},{"code":"(fn [f & maps]\n  (reduce (fn mergetwo [m1 m2]\n            (reduce conj m1\n                    (map (fn [e] (if-let [pair (find m1 (key e))]\n                                       [(first e) (f (second pair) (second e))]\n                                       e)) m2)))\n          {} maps))","problem":69,"user":"523c6451e4b07becd5be2222"},{"problem":69,"code":"(fn [f & maps]\n  (letfn [(merger [m [k v]] \n                  (if (contains? m k)\n                    (assoc m k (f (get m k) v))\n                    (assoc m k v)))]\n    (reduce #(reduce merger %1 %2) maps)))","user":"544cf5d7e4b0e39780006977"},{"problem":69,"code":"(fn [f m & ms]\n  (reduce\n   (fn [m1 m2]\n     (reduce #(assoc % %2\n                (if-let [o (get % %2)]\n                  (f o (m2 %2))\n                  (m2 %2))) m1 (keys m2))) m ms))","user":"4eb97234535dfed6da9c6d53"},{"problem":69,"code":"(fn\n  [f & maps]\n  (reduce\n    (fn [m1 m2]\n      (reduce\n        #(let [m %\n               k (first %2)\n               v (second %2)]\n           (if (contains? m k)\n             (assoc m k (f (get m k) v))\n             (assoc m k v)))\n        m1\n        m2))\n    maps))","user":"56bb652ae4b0f26550335953"},{"problem":69,"code":"(fn [f & maps]\n    (letfn [(selective-f [vs] (if (> (count vs) 1) (apply f vs) (first vs))) \n            (vals-of-colls [k]\n                (->> (map (fn [m] (m k)) maps) \n                     (filter (fn [v]  (not (nil? v))))\n                     (selective-f)))]\n    (->> (map keys maps)\n         (reduce into #{})\n         (into [])\n         (map (fn [k] [k (vals-of-colls k)]))\n         (into (sorted-map)))))","user":"53a5bc3ae4b0ef122a8689c3"},{"problem":69,"code":"(fn [f & maps]\n  (let [merger (fn [f map1 map2]\n                 (let [reduce-fn (fn [m [k v]]\n                                   (if (contains? m k)\n                                     (assoc m k (f (m k) v))\n                                     (assoc m k v)))]\n                   (reduce reduce-fn map1 (seq map2))))]\n    (reduce #(merger f %1 %2) {} maps)))","user":"5617db88e4b06b1bb2182a16"},{"code":"(fn [f & [first-map & rest-maps]]\n  (reduce\n    (fn [result-map other-map]\n      (reduce\n        (fn [result-map [k other-v]]\n          (let [result-v (result-map k :not-found)]\n            (assoc result-map k (if (= result-v :not-found)\n                                  other-v\n                                  (f result-v other-v)))))\n        result-map other-map))\n    first-map rest-maps))","problem":69,"user":"53070615e4b02e821686979e"},{"problem":69,"code":"(fn [f m & ms]\n  (reduce\n    (fn [m [k v]]\n      (if (contains? m k)\n        (assoc m k (f (get m k) v))\n        (assoc m k v)))\n    m (mapcat seq ms)))","user":"50ec409ce4b04edc33777045"},{"problem":69,"code":"(fn [f & s]\n  (let [l (group-by first (mapcat #(into [] %) s))\n        k (keys l)\n        v (map (fn [x] (if (= (count x) 1) (second (first x)) (apply f (map #(second %) x)))) (vals l))]\n    (zipmap k v)))","user":"5e6ca949e4b04a83ad7cd289"},{"problem":69,"code":"(fn mw\n  [f map1 & maps]\n  (into {} (map #(if (contains? map1 (first %))\n                   (vector (first %) (f (map1 (first %)) (second %)))\n                   (vector (first %) (second %))\n                   ) (apply merge maps))))","user":"5888b75fe4b0f1effa3b771b"},{"problem":69,"code":"(fn merge-with2 [f & maps] {:pre (fn? f)}\n    (reduce (fn [res m] (reduce (fn [curr [k v]] (assoc curr k (if (curr k) (f (curr k) v) v)) ) res m) ) {} maps)\n)","user":"5db7376fe4b010eb3c36cd43"},{"code":"(fn [f m & ms]\n  (loop [res m ms ms]\n    (if-let [[m & ms] ms]\n      (let [m1 (select-keys res (keys m))]\n        (recur (conj res m (apply hash-map (mapcat (fn [[k v]] [k (f (res k) (m k))]) m1))) ms)\n        )\n      res\n      )\n    )\n  )","problem":69,"user":"5298d3f4e4b02ebb4ef75068"},{"problem":69,"code":"(fn my-merge-with [f & ms]\n  (loop [[[k v] & ps] (mapcat seq ms), macc {}]\n     (if k (recur  \n             ps \n             (assoc macc k (if (macc k) \n                               (f (macc k) v) \n                               v)))\n            macc)))","user":"56fa2905e4b07572ad1a88be"},{"problem":69,"code":"#(reduce\n  (fn [a x]\n    ; for each key in x (=b), y, check if y exists in a\n    ; if exists in a, then return b with {y (f a_val b_val)}\n    ; merge resulting b with a\n    (merge a\n          (reduce\n           (fn [b y]\n             (if (contains? a y)\n               (assoc b y (%1 (get a y) (get b y)))\n               b)) \n           x (keys x))))\n   %2 %&)","user":"5e3a25d4e4b01d43a70e8dde"},{"problem":69,"code":"(fn [f & ms]\n    (reduce\n     (fn [result m]\n       (reduce #(assoc %1 (key %2)\n                       (if-let [v (get %1 (key %2))]\n                         (f v (val %2)) (val %2))) result m))\n     ms))","user":"5c995fa4e4b048ec896c5a96"},{"problem":69,"code":"(fn [f & ms]\n        (reduce (fn [m1 m2]\n                  (reduce-kv\n                    #(assoc % %2\n                            (if (contains? % %2)\n                              (apply f [(get % %2) %3])\n                              %3))\n                    m1 m2)) ms))","user":"544e6b7fe4b0e39780006986"},{"problem":69,"code":"(fn [f m & ms]\n  (if (empty? ms)\n    m\n    (let [new-m (reduce (fn [acc [k v]]\n                          (if (acc k)\n                            (assoc acc k (f (acc k) v))\n                            (assoc acc k v)))\n                        m\n                        (first ms))]\n      (recur f new-m (rest ms)))))","user":"54dce6dbe4b024c67c0cf78d"},{"problem":69,"code":"(fn -merge-with [f & maps]\n    (reduce (fn [acc map]\n              (reduce-kv (fn [acc2 key val-in-latter]\n                           (if-let [val-in-result (acc2 key)]\n                             (assoc acc2 key (f val-in-result val-in-latter))\n                             (assoc acc2 key val-in-latter)\n                             ))\n                      acc\n                      map\n                      )\n              )\n            (first maps)\n            (rest maps)\n            )\n    )","user":"5896ade8e4b00487982d52a9"},{"problem":69,"code":"(fn fun [f & [n1 n2 & args]]\n    (cond\n      (nil? n2) n1\n      :else\n        (apply fun\n          f\n          (reduce\n            (fn [x [k v]]          \n              (if (contains? x k)\n                (assoc x k (f (get x k) v))\n                (assoc x k v)\n              )\n            )\n            n1\n            n2\n          )\n          args\n        )\n    )\n)","user":"5da20e73e4b000c986472be1"},{"code":"(fn [func & maps]\n  (reduce \n    (fn [output [pair-key pair-value]]\n      (if-let [current-value (get output pair-key)]\n        (assoc output pair-key (func current-value pair-value))\n        (assoc output pair-key pair-value)))\n    {}\n    (apply concat maps)))","problem":69,"user":"4ec2fe3f535dcc7ae8597d4f"},{"code":"(fn [f & args]\n   (let [merge-map-entry (fn [a-map a-map-entry]\n                  (let [a-key (key a-map-entry) a-value (val a-map-entry)]\n                    (if (contains? a-map a-key)\n                      (assoc a-map a-key (f (get a-map a-key) a-value))\n                      (assoc a-map a-key a-value))))\n         merge-fn (fn [map-1 map-2]\n                    (reduce merge-map-entry (or map-1 {}) (seq map-2)))]\n     (reduce merge-fn args)))","problem":69,"user":"5011ae8fe4b00ad656b9d982"},{"problem":69,"code":"(fn [f x & y]\n  \n (loop [i (first y) j (rest y) r x]\n   \n   (if (empty? i)\n         r\n     (recur\n                  (first j )\n                  (rest j)\n                 (let [k (keys i)] \n                   (reduce   (fn [c ki] (if (c ki)     (conj c [ki  (f (c ki) (i ki))])     (conj c [ki (i ki)])\n                                          ) \n                               ) \n                             r  k)     \n                   )\n            \n            \n            \n       )\n     \n     )\n   \n   \n   \n   \n   \n   )\n \n \n \n \n \n \n \n \n \n )","user":"5da98129e4b000c986472c33"},{"problem":69,"code":"(fn [f init & x]\n   (reduce\n     (fn [a b]\n       (reduce #(merge %1\n                       (cond\n                         (and (contains? a %2) (contains? b %2)) {%2 (f (get a %2) (get b %2))}\n                         (contains? b %2) {%2 (get b %2)}))\n               a (keys b)))\n  init x))","user":"55a372f1e4b0acc240e31537"},{"code":"(fn my-merge-with [f & maps]\n  (let [ks (apply concat (map keys maps))]\n    (apply conj\n           (map\n             (fn [k]\n               (let [els (reverse (reduce #(if (contains? %2 k) (cons (get %2 k) %1) %1) '() maps))]\n                 (println els)\n                 {k\n                  (if (= (count els) 1)\n                    (first els)\n                    (reduce f (first els) (rest els)))}))\n             ks))))","problem":69,"user":"515828b8e4b0a069fd272c71"},{"code":"(fn [f m & ms]\n  (reduce\n    (fn [m n]\n      (reduce\n        (fn [m [k v]]\n          (assoc m k \n            (if (contains? m k)\n              (f (m k) v)\n              v)))\n        m n))\n    m ms))","problem":69,"user":"50fbf811e4b0d10d794c19f1"},{"problem":69,"code":"(fn merge-with-a-function [f & m]\n  (into {}\n        (map (fn [e]\n               (if (> (count (val e)) 1)\n                 [(key e) (reduce f (map second (val e)))]\n                 [(key e) (second (first (val e)))]))\n             (group-by first (apply concat m)))))","user":"607d6bc1e4b03d835a6eaecc"},{"code":"(fn my-merge-with [f first-map & other-maps]\n        (conj first-map\n        (apply array-map\n               (mapcat (fn [m]\n                         (mapcat #(vector (first %)\n                                       (if (first-map (first %))\n                                         (f (first-map (first %)) (second %))\n                                         (second %))) m)) other-maps))))","problem":69,"user":"4e589bdc535d8a8b8723a295"},{"problem":69,"code":"(fn [f & hash-maps]\n    (let [by-key (group-by first (mapcat #(into [] %) hash-maps))]\n      (into {} (map (fn [[k vals]] [k (reduce f (map second vals))]) by-key))))","user":"5ac6ef9be4b0e27600da7779"},{"problem":69,"code":"#(->> %&\n       (apply concat)\n       (group-by first)\n       (map (fn [[k v]]\n              [k (reduce % (map second v))]))\n       (into {}))","user":"5466aabbe4b01be26fd746e8"},{"problem":69,"code":"(fn [f & s]\n  (reduce #(into {} (for [x (concat (keys %1) (keys %2))] \n                      [x (if (contains? %1 x)\n                           (if(contains? %2 x)\n                             (f (%1 x) (%2 x))\n                             (%1 x))\n                           (%2 x)\n                           )\n                           ])) s))","user":"55c423e1e4b0e31453f64994"},{"problem":69,"code":"(fn [f & maps]\n  (reduce\n   (fn [ma mb]\n     (reduce \n      (fn [m k]\n        (if (contains? m k)\n          (assoc m k (f (get m k)\n                      (get mb k)))\n          (assoc m k (get mb k))))\n      ma\n      (keys mb)))\n     maps))","user":"5461dc79e4b01be26fd746a8"},{"code":"(fn [f & ms]\n  (reduce\n   (fn [m1 m2]\n     (if (empty? m2)\n       m1\n       (let [e (first m2)\n             k (first e)\n             v1 (second e)\n             v (if (m1 k)\n                 (f (m1 k) v1)\n                 v1)]\n         (recur (assoc m1 k v) (rest m2)))))\n   ms))","problem":69,"user":"53460d02e4b084c2834f4a39"},{"code":"(fn merg \n  ([f h1 h2] (reduce  (fn [acc,k] (assoc acc k (if (h1 k) (f (h1 k) (h2 k)) (h2 k)))) h1 (keys h2)))\n  ([f h1 h2 & maps] (merg f h1 (apply merg (cons f (cons h2 maps))))))","problem":69,"user":"533ab9abe4b0e30313ee6cbf"},{"code":"(fn [f & colls]\n  (reduce\n   (fn [m [k v]] (if (m k) (assoc m k (f (m k) v)) (assoc m k v))) \n   (hash-map) (apply concat colls)))","problem":69,"user":"50733b31e4b0e3170b5a869a"},{"code":"(fn [f & ms]\n  (let \n    [base (first ms)\n     others (reduce conj (merge (rest ms))) ]\n    (into {} (map (fn [ [k v] ] (if (get base k) [ k (f (get base k) v) ] [k v] )) others))\n  ))","problem":69,"user":"5204173be4b0fb7e47ea5216"},{"problem":69,"code":"(fn [f & hs]\n  (let [merge-hash (fn [agg [k v]]\n                     (if (contains? agg k)\n                       (assoc agg k (f (agg k) v))\n                       (assoc agg k v)))\n        merge-hash-list (fn [agg h]\n                          (reduce merge-hash agg h))]\n    (reduce merge-hash-list hs)))","user":"5412ef7ee4b01498b1a719da"},{"problem":69,"code":"(fn mergeWith [op & maps]\n  \n  (reduce\n   \n   (fn[lm rm]\n     \n     (->>\n      rm\t\n      (map (fn [[k v]] [k (if (contains? lm k) \n                            (op (get lm k) v) \n                            v) ] ))\n      (into lm)\n      )\n     )\n   \n   maps\n   )\n  )","user":"533a2f7be4b0e30313ee6cb8"},{"problem":69,"code":"(fn -merge-with [f & ms]\n  (letfn [\n          (conj-onto [f m1 m2]\n           (reduce (partial merge-into f) m1 m2))\n          (merge-into [f m [k v]]\n            (if (contains? m k)\n              (assoc m k (f (get m k) v))\n              (assoc m k v)))]\n    (reduce (partial conj-onto f) ms)))","user":"5708e8f6e4b0b0fb43fd06a4"},{"problem":69,"code":"(fn [f & v]\n   (->>\n     (mapcat #(into [] %) v)\n     (group-by first)\n     (map (fn [[k v]] (vector k (map #(second %) v))))\n     (map (fn [[k v]] (vector k (if (< 1 (count v))\n                                  (apply f v)\n                                  (first v)))))\n     (into {})))","user":"54a11042e4b09f271ff37c49"},{"code":"(fn [f & maps]\r\n  (reduce\r\n    (fn [a b]\r\n      (let [common-keys (clojure.set/intersection (set (keys b)) \r\n                                                  (set (keys a)))]\r\n        (apply merge a (for [mk (keys b)] (if (contains? common-keys mk)\r\n                                          (hash-map mk (f (a mk) (b mk)))\r\n                                          (hash-map mk (b mk))))))) {} maps))","problem":69,"user":"502d4ea0e4b02fc10c6c6e46"},{"problem":69,"code":"(fn map-merge\n  [f m1 & maps]\n  (if (= (first maps) nil)\n    m1\n    (let [m2 (first maps)\n          shared-keys (clojure.set/intersection (set (keys m1)) (set (keys m2)))\n          m3 (merge m1 m2)]\n      (apply map-merge f (reduce #(assoc %1 %2 (f (get m1 %2) (get m2 %2))) m3 shared-keys) (rest maps)))))","user":"5609d328e4b05f002753deee"},{"problem":69,"code":"(fn [f & ms]\n  (let [ks (set (mapcat keys ms))]\n    (reduce\n     (fn [acc k]\n       (into\n        acc\n        (let [vs (keep #(get % k) ms)]\n         {k (if (< 1 (count vs))\n              (reduce f vs)\n              (first vs))})))\n     {}\n     ks)))","user":"54d9f7f1e4b024c67c0cf751"},{"problem":69,"code":"(fn merge-with-alt [f & colls]\n     (let [keys- (distinct (flatten (map #(keys %) colls)))]\n      (zipmap \n        keys- \n       (map #(reduce f %)\n          (map #(remove nil? %) \n            (for [n keys-]\n              (map #(get % n) colls)))))))","user":"58dcb8cde4b0a4d5acaab6a7"},{"code":"(fn my-merge-with\n  [f m1 & m]\n  (let [merge-maps (fn [f m1 m2]\n    (if (empty? m2) \n\t    m1\n\t    (let [k (ffirst m2) v (second (first m2))]\n\t    (if (not (nil? (get m1 k))) \n\t      (recur f (assoc m1 k (f (get m1 k) v)) (rest m2))\n\t      (recur f (conj m1 (first m2)) (rest m2))))))]       \n  (reduce #(merge-maps f % %2) m1 m)))","problem":69,"user":"4edf5dc6535d10e5ff6f5340"},{"code":"#(reduce\n  (fn [a b]\n    (reduce\n      (fn [x [k v]]\n        (if-let [e (x k)]\n          (assoc x k (% e v))\n          (assoc x k v)))\n      a b))\n  {} %&)","problem":69,"user":"4ed69ea4535d10e5ff6f52e3"},{"problem":69,"code":"(fn [func & ms]\n  (reduce\n   (fn [result m]\n     (reduce\n      (fn [result_ [k v]]\n        (if (result_ k)\n          (assoc\n            result_\n            k\n            (func (get result_ k) v))\n          (assoc result_ k v)))\n      result\n      m))\n   (first ms)\n   (rest ms)))","user":"549e5e52e4b0f3d1d8e70f9e"},{"code":"(fn [pred & maps] \n    (reduce #(reduce \n        (fn [r [k v]]\n            (assoc r k (if (r k) (pred (r k) v) v))\n        )\n        %1 %2) {} maps)\n)","problem":69,"user":"4f0e995e535d0136e6c22326"},{"code":"(fn [f & maps]\n  (letfn [(step [m1 m2]\n            (if (seq m2)\n              (let [first-ele-in-m2 (first m2)\n                    v-in-m1 (m1 (key first-ele-in-m2))]\n                (if v-in-m1\n                  (step\n                    (assoc m1 (key first-ele-in-m2) (f v-in-m1 (val first-ele-in-m2)))\n                    (rest m2))\n                  (step\n                    (assoc m1 (key first-ele-in-m2) (val first-ele-in-m2))\n                    (rest m2))))\n              m1))]\n    (reduce step maps)))","problem":69,"user":"514d7e29e4b019235f6c0587"},{"code":"(fn \n  [op & colls]\n  (let [dest (first colls)\n        merge-fn (fn [kv]\n                   (let [k (key kv)\n                         v (val kv)]\n                   {(key kv) (if (dest k) (op (dest (key kv)) (val kv)) v)}))\n        change-set (for [coll (rest colls)]\n                     (for [key-val coll]\n                       (merge-fn key-val)))]\n    (reduce #(merge %1 %2) dest (flatten change-set))))","problem":69,"user":"4f4544e1e4b0d56e7bb92b7a"},{"problem":69,"code":"(fn [f m & maps]\n  (if maps\n    (persistent! (reduce (fn [r [k v]]\n                           (assoc! r k (if (contains? m k)\n                                         (f (get m k) v)\n                                         v)))\n                         (transient m)\n                         (apply concat maps)))\n    m))","user":"5122925ae4b068a9582e656d"},{"problem":69,"code":"(fn [f & maps]\n  (reduce \n   (fn [acc m]\n     (reduce \n      (fn [acc [k v]]\n        (if (contains? acc k)\n          (assoc acc k (f (get acc k) v))\n          (assoc acc k v)))\n      acc m))\n   maps))","user":"56cf115de4b0ea9b8538f765"},{"problem":69,"code":"(fn [f & ms]\n  (reduce #(apply conj % (for [[k v] %2] (if (% k) [k (f (% k) v)] [k v]))) {} ms))","user":"56ef077ae4b04a395b9a0459"},{"problem":69,"code":"(fn [f m & r]\n  (let [reducer2 (fn [tm [k v]] (if (get tm k) (assoc! tm k (f (get tm k) v)) (assoc! tm k v)))\n        reducer (partial reduce reducer2)]\n    (persistent! (reduce reducer (transient m) r))))","user":"58923efce4b00487982d521c"},{"problem":69,"code":"(fn merg\n  [f & args]\n  (letfn [(merge2 [f a b]\n            (loop [result a\n                   pairs (seq b)]\n              (if pairs\n                (let [[k v] (first pairs)]\n                  (recur (if (contains? result k) \n                           (assoc result k (f (result k) v))\n                           (assoc result k v))\n                         (next pairs)))\n                result)))]\n    (loop [lst (next args)\n           result (first args)]\n      (if lst\n        (recur (next lst)\n               (merge2 f result (first lst)))\n        result))))","user":"4e8a170c535d3e98b802328f"},{"code":"(fn [f & ms]\n  (reduce (fn [m1 m2]\n            (merge m2\n                   (into {}\n                         (for [[k v] m1]\n                           (if (m2 k)\n                             [k (f v (m2 k))]\n                             [k v])))))\n          ms))","problem":69,"user":"51df825de4b01188f062752b"},{"code":"(fn merge-w [f m & ms]\n   (reduce\n    (fn map-red [acc next-map]\n      (reduce\n       (fn key-red [acc k]\n         (assoc acc k\n                (if (contains? acc k)\n                  (f (get acc k) (get next-map k))\n                  (get next-map k))))\n       acc\n       (keys next-map)))\n    m ms))","problem":69,"user":"524f213be4b0541d1855b7ff"},{"problem":69,"code":"(fn [f & maps]\n  (letfn [(merg [x y]\n                (reduce (fn [a [k v]]\n                          (if (contains? a k)\n                            (assoc a k (f (get a k) v))\n                            (assoc a k v)))\n                        x y))]\n    (reduce (fn [a m] (merg a m)) (first maps) (rest maps))))","user":"55495318e4b0a04f79299566"},{"problem":69,"code":"(fn [f & ms]\n  (letfn [(merge [a b] (reduce (fn [m [k v]] (assoc m k (if (contains? m k) (f (m k) v) v))) a b))]\n    (reduce merge ms)))","user":"5db92996e4b010eb3c36cd50"},{"code":"(fn my-merge-with\n  [f & maps]\n  (letfn [(merge-two-maps [f m1 m2]\n                          (reduce (fn [acc e]\n                                    (let [k (first e) v (second e)]\n                                      (if (acc k)\n                                        (assoc acc k (f (acc k) v))\n                                        (assoc acc k v)))) m1 m2))]\n    (reduce (fn [acc m] (merge-two-maps f acc m)) {} maps)))","problem":69,"user":"50fc48dde4b0d10d794c19f6"},{"problem":69,"code":"(fn [f m & ms]\n  (reduce (fn [m1 m2]\n            (reduce (fn [m1 [k2 v2]]\n                      (if (contains? m1 k2)\n                        (update-in m1 [k2] f v2)\n                        (assoc m1 k2 v2)))\n                    m1\n                    m2))\n          m\n          ms))","user":"4eda7cc3535d10e5ff6f530e"},{"problem":69,"code":"(fn my-merge-with [f & ms]\n  (let [update-with\n        (fn [f m [k v]]\n          (assoc m k (if-let [o (m k)] (f o v) v)))\n        update-withs\n        (fn [f m & kvs]\n          (reduce #(update-with f %1 %2) m (seq kvs)))]\n    (reduce #(apply update-withs f %1 (seq %2)) {} ms)))","user":"5488872ee4b0e286459a11d3"},{"problem":69,"code":"(fn merge-with- [op init & maps]\n  (letfn [(upsert [result k v]\n            (if (contains? result k)\n              (update-in result [k] op v)\n              (assoc-in result [k] v)))]\n    (reduce\n      #(reduce-kv upsert %1 %2)\n      init\n       maps)))","user":"572ea970e4b0cd1946bd0f89"},{"code":"(fn [f x & maps]\n     (let [addee (loop [m maps result {}]\n\t\t\t  (if (empty? m)\n\t\t\t      result\n\t\t\t      (recur (rest m) (into result (first m)))))]\n\t     (loop [a addee result x]\n\t\t(if (empty? a)\n\t\t    result\n\t\t    (let [k (key (first a)) v (val (first a))]\n\t\t\t (if (contains? result k)\n\t\t\t     (recur (rest a) (assoc result k (f (get result k) v)))\n\t\t\t     (recur (rest a) (assoc result k v))))))))","problem":69,"user":"4f066916535dcb61093f6c10"},{"problem":69,"code":"(fn [f & maps]\n  (let [all-keys (keys (apply merge maps))\n    \taddvalues (fn [akey] \n     \t               (let [data (remove nil? (map #(%1 akey) maps))]\n                        (if (> (count data) 1) (apply f data) (first data))))]\n    (apply clojure.set/union (\n      map #(assoc {} %1 (addvalues %1)) \n         (into [] all-keys)))))","user":"567d18c9e4b05957ce8c61c4"},{"problem":69,"code":"(fn [f & maps]\n    (reduce\n      (fn [acc map]\n        (reduce-kv\n          (fn [acc k v]\n            (if-let [current (acc k)]\n              (assoc acc k (f current v))\n              (assoc acc k v))\n            )\n          acc map))\n      maps))","user":"54ca130ce4b057c6fda3a250"},{"problem":69,"code":"(fn foo-merge-with [f & maps]\n   (when (some identity maps)\n     (let [merge-entry (fn [m e]\n                         (let [k (key e) v (val e)]\n                           (if (contains? m k)\n                             (assoc m k (f (get m k) v))\n                             (assoc m k v))))\n           merge2 (fn [m1 m2]\n                    (reduce merge-entry (or m1 {}) (seq m2)))]\n       (reduce merge2 maps))))","user":"57ee804ee4b0bfb2137f5bbb"},{"code":"(fn [f & s] \n  (let [m (partition-by first\n             (sort-by first (apply concat s)))] \n    (into {} (mapcat #(set {% %2})\n      (map ffirst m)\n      (map #(if (= 1 (count %))\n              (last %)\n              (apply f %)) (map #(map second %) m))\n))))","problem":69,"user":"4f01c938535dcb61093f6a39"},{"problem":69,"code":"(fn mw [f & maps]\n  (->> maps\n       (apply concat)\n       (group-by first)\n       (reduce (fn [m [k vs]] (assoc m k (reduce f (map second vs)))) {})))","user":"53b39d82e4b047364c0444a6"},{"problem":69,"code":"(fn [f & maps]\n   (letfn [(my-merge [m k v]\n             (let [v0 (m k)]\n               (assoc m k (if (nil? v0) v (f v0 v)))))\n           (merge-two [m1 m2]\n             (reduce #(let [[k v] %2] (my-merge %1 k v)) m1 m2))]\n     (reduce merge-two maps)))","user":"5e3ef7d4e4b01d43a70e8e2d"},{"problem":69,"code":"(fn m [f h & s]\n\t(if (empty? s)\n\t\th\n\t\t(apply\n\t\t\tm\n\t\t\tf\n\t\t\t(reduce\n\t\t\t\t#(let [k (key %2) v (val %2) p (% k)]\n\t\t\t\t\t(assoc % k (if (nil? p) v (f p v))))\n\t\t\t\th\n\t\t\t\t(first s))\n\t\t\t(rest s))))","user":"57ccedaae4b0c746388ab88e"},{"problem":69,"code":"(fn [f & xs]\n  (reduce\n   (fn [acc item]\n     (reduce\n      (fn [m [k v]]\n        (assoc m k (if (contains? m k) (f (get m k) v) v)))\n      acc\n      item))\n   (first xs)\n   (rest xs)))","user":"5b96800ae4b0c0b3ffbd4a7b"},{"problem":69,"code":"(fn [f & ms]\n  (->> ms\n       (apply concat)\n       (group-by key)\n       (map #(vector (key %) (->> (val %)\n                                  (map val)\n                                  (reduce f))))\n       (into {})))","user":"54e2a779e4b024c67c0cf7d3"},{"problem":69,"code":";no apply-recur :(\n(fn m-with [f & maps]\n  (let [m1 (first maps) m2 (second maps)]\n    (cond\n     (nil? m1) nil\n     (nil? m2) m1\n     (empty? m2) (apply m-with f m1 (drop 2 maps))\n     :else\n     (apply \n      m-with f\n      (let [[k v] (first m2)\n            cur-value (get m1 k nil)]\n        (if (nil? cur-value)\n          (assoc m1 k v)\n          (assoc m1 k (f cur-value v))\n          )\n        )\n      (rest m2)\n      (drop 2 maps)\n      )\n     )\n   )\n)","user":"5991d2fae4b0866487ed0d68"},{"code":"(fn\n  [f & maps]\n  (when (some identity maps)\n    (let [merge-entry (fn [m e]\n  \t\t(let [k (key e) v (val e)]\n\t\t\t  (if (contains? m k)\n\t\t\t    (assoc m k (f (get m k) v))\n\t\t\t    (assoc m k v))))\n          merge2 (fn [m1 m2]\n\t\t   (reduce merge-entry (or m1 {}) (seq m2)))]\n      (reduce merge2 maps))))","problem":69,"user":"4e78dc98535db95036265724"},{"problem":69,"code":"(fn f [f & maps]\n  (into {}\n        (for [k (distinct (mapcat keys maps))]\n          (let [vals (keep identity (map #(% k) maps))]\n            [k (if (seq (rest vals))\n                 (apply f vals)\n                 (first vals))]))))","user":"54d341f7e4b0e8a36923e603"},{"code":"(fn [f & coll]\r\n   (apply merge \r\n          (for [x (group-by #(first %) (reduce into [] coll))]\r\n            {(first x) (let [[c & ls] (map second (second x))] (if (> (count ls) 0) (apply f c ls) c))})))","problem":69,"user":"503354c3e4b0c6c1199c710c"},{"problem":69,"code":"(fn [f & ms]\n  (into {} (for [x (for [k (set (reduce concat (for [m ms] (keys m))))]\n                     (hash-map k (for [m ms :when (contains? m k)]\n                                   (m k))))]\n             (let [k (first (keys x))\n                   v (x k)]\n               (hash-map k (if (> (count v) 1) (reduce f v) (first v)))))))","user":"54d753ebe4b0a52adc2e2029"},{"code":"(fn merge-func\n  [f & colls]\n  (let [collect-vals\n        (fn\t[ks colls]\n  \t\t\t(for [k ks]\n    \t\t\t{k\n     \t\t\t(for [c colls]\n       \t\t\t\t(c k))}))\n        sum-vals\n        (fn [f coll]\n  \t\t\t(map (fn [c]\n         \t\t\t(let [[k v] (first c)\n               \t\t\tvals (filter #((complement nil?) %) v)]\n                  \t{k (if (> (count vals) 1) (apply f (filter #((complement nil?) %) v)) (first vals))}))\n                 coll))]\n  \t(apply merge (sum-vals f (collect-vals (keys (apply merge colls)) colls)))))","problem":69,"user":"5339af7de4b0e30313ee6cab"},{"problem":69,"code":"(fn f\n  ([g m n]\n   (apply conj\n          m\n          (map (fn [[k v]] (if (m k)\n                             [k (g (m k) v)]\n                             [k v]))\n               n)))\n  ([g m n & r]\n   (apply f g (f g m n) r)))","user":"53fb5256e4b0de5c4184857f"},{"code":"(fn [op target & rest]\n  (reduce (fn [target src]\n    (reduce (fn [target [k v]]\n      (assoc target k\n        (if (target k)\n          (op (target k) v)\n          v))) \n    target src)) \n  target rest))","problem":69,"user":"4fe88f78e4b07c9f6fd12c45"},{"problem":69,"code":"(fn [f & maps]\n  (reduce #((fn [f a b] \n              (loop [origin a target b] \n                (if (empty? target) \n                  origin \n                  (let [key (first (first target)) \n                        val (if (get origin key) \n                              (f (get origin key) (get target key)) \n                              (get target key))] \n                    (recur \n                      (conj origin [key val]) (dissoc target key)))))) f %1 %2) maps))","user":"5fc51d88e4b0ad564c76812a"},{"code":"(fn [ f & mps ]\n  (let [ km (keys (apply conj mps)) ]\n    (reduce \n    (fn [a k]\n      (let [ v \n            (reduce (fn [p q] (if (q k) \n                                  (conj p (q k)) p)) \n                        [] mps) ]\n      (conj a { k (reduce f v)} )))\n    {} km)))","problem":69,"user":"4fdd27f3e4b05e33b9224f78"},{"problem":69,"code":"(fn [f & maps]\n  (reduce (fn [m1 m2]\n            (loop [m1 m1 m2 m2]\n              (if (empty? m2)\n                m1\n                (let [[k v] (first m2)]\n                  (if (contains? m1 k)\n                    (recur (assoc m1 k (f (m1 k) v)) (rest m2))\n                    (recur (assoc m1 k v) (rest m2)))))))\n          maps))","user":"54fdbe3fe4b07d26eda61d3b"},{"code":"(fn [f m1 & maps]\n  (let [_f (fn [f m1 m2]\n  \t(if-let [[k v2] (first m2)]\n\t\t  (if-let [v1 (m1 k)]\n\t\t    (recur f (assoc m1 k (f v1 v2)) (dissoc m2 k))\n\t\t    (recur f (assoc m1 k v2) (dissoc m2 k)))\n\t\t  m1))]\n    (if-let [m2 (first maps)]\n      (recur f (_f f m1 m2) (rest maps))\n      m1)))","problem":69,"user":"4e4ad154535dc968683fc4d1"},{"problem":69,"code":"(fn [transform-fn & maps]\n    (reduce\n     (fn [result, current-map]\n       (let [all-keys (distinct (keys (conj result current-map)))]\n         (reduce (fn [memo k]\n                   (let [values-to-combine [(get result k) (get current-map k)]]\n                        (assoc memo k (reduce transform-fn (remove nil? values-to-combine)))))\n                 {}\n                 all-keys)))\n     maps))","user":"5cf2863be4b0aaa82f112a21"},{"problem":69,"code":"(fn [merge-fn & maps]\n    (let [all-keys (into #{} (mapcat keys maps))\n          to-merge-or-not (fn [vals]\n                            (if (empty? (rest vals))\n                              (first vals)\n                              (apply merge-fn vals)))\n          apply-fn-to-key #(->> (map (fn [m] (get m %)) maps)\n                                (remove nil?)\n                                (to-merge-or-not))\n          reduce-fn       #(assoc %1 %2 (apply-fn-to-key %2))]\n      (reduce reduce-fn {} all-keys)))","user":"52761edae4b03e8d9a4a74d4"},{"problem":69,"code":"(fn [q a & b]\n  (reduce \n   #(reduce-kv (fn [r x y]\n                 (if (contains? r x)\n                   (update-in r [x] q y)\n                   (assoc r x y)))\n               % %2)\n   a b))","user":"577ab41fe4b0d3393e5deb05"},{"problem":69,"code":"(fn [f a & b] (reduce #(reduce (fn [s e] (if (nil? (s (key e))) (conj s e) (update-in s [(key e)] f (val e)))) % %2) a b))","user":"56c08696e4b060a8e693e3aa"},{"problem":69,"code":"(fn [f m & ms]\n  (reduce (fn [m m2]\n            (reduce (fn [m [k v]] (update-in m [k] #(if-not % v (f % v))))\n                    m m2))\n          m ms))","user":"4f3ca5a6e4b0e243712b1f53"},{"code":"(fn my-merge [f & maps]\r\n    (letfn [(my-key-merge [f m1 m2 key]\r\n              (if (and (find m1 key) (find m2 key))\r\n                (f (m1 key) (m2 key))\r\n                (if (find m1 key)\r\n                  (m1 key)\r\n                  (m2 key))))\r\n            (my-map-merge [f map1 map2]\r\n              (reduce (fn [a b]\r\n                        (if (contains? a (first b))\r\n                          (assoc a (first b) (my-key-merge f a (hash-map (first b) (second b)) (first b)))\r\n                          (merge a b)))\r\n                      map1 map2))]\r\n      (reduce (fn [a1 b1] (my-map-merge f a1 b1)) maps)))","problem":69,"user":"4f039524535dcb61093f6b2c"},{"problem":69,"code":"(fn [f & args]\n    (reduce-kv #(assoc %1 %2 (if (= 1 (count %3)) (apply last %3) (apply f (map last %3)))) {}  (group-by #(first %) (reduce #(into %1 %2) [] args))))","user":"57c6aa0be4b05aa3c4741cf7"},{"problem":69,"code":"(fn [f & maps]\n  (->> (apply concat maps)\n       (group-by key)\n       (map (fn [[k kvs]]\n              [k (reduce f (map val kvs))]))\n       (into {})))","user":"51db0d99e4b06aa4d4669a9d"},{"code":"(let [merger\n      (fn [f m1-keys m1 m2 result]\n        (if (nil? m1-keys)\n          (merge result m2)\n          (if (contains? m2 (first m1-keys))\n            (recur f (next m1-keys) m1 (dissoc m2 (first m1-keys))\n            \t(assoc result (first m1-keys) (f \n                                               (get m1 (first m1-keys)) \n                                               (get m2 (first m1-keys))\n                                              )\n                )\n            )\n            (recur f (next m1-keys) m1 m2\n                 (assoc result (first m1-keys) (get m1 (first m1-keys)))\n            )\n          )\n        )\n      )\n      doit\n      (fn [f ms result]\n        (if (nil? ms)\n          result\n          (recur f (next ms) (merger f (keys result) result (first ms) {}))\n        )\n      )]\n  (fn [f & ms] (doit f (next ms) (first ms)))\n)","problem":69,"user":"526dd90de4b03e8d9a4a72fe"},{"code":"(fn [f m & more]\n  (reduce\n    (fn [acc [k v]]\n      (conj acc (if (contains? m k) [k (apply f [(get m k) v])] [k v])))\n   {} (apply merge more)))","problem":69,"user":"4f2d5f5de4b0d6649770a05a"},{"problem":69,"code":"(fn\n  [f coll & args]\n  (reduce-kv #(if (contains? %1 %2) (assoc %1 %2 (f (%1 %2) %3)) (assoc %1 %2 %3)) coll (into {} args)))","user":"59ddae03e4b01968742fed65"},{"problem":69,"code":"(fn [f & maps]\n    (reduce\n     (fn [m1 m2]\n       (reduce (fn [m [k v]]\n                 (if-let [v1 (get m k)]\n                   (assoc m k (f v1 v))\n                   (assoc m k v)))\n               m1 m2))\n     maps))","user":"500d3160e4b05f7c30cfa6a1"},{"problem":69,"code":"(fn [f & xs]\n    (let [all-keys (set (flatten (map keys xs)))]\n\n      (reduce\n       (fn [acc current-key]\n\n         (let [val (apply f (filter #(not (nil? %)) (map #(% current-key) xs)))]\n\n         (println (filter #(not (nil? %)) (map #(% current-key) xs)))\n\n         (assoc acc current-key\n\n                (if (= -15 val)\n                  15\n                  val))))\n\n\n       {}\n       all-keys)))","user":"58b81490e4b0ebc645576d8c"},{"code":"(fn [op & maps]\n  (let [ks (apply clojure.set/union\n             (map (comp set keys) maps))\n        vs #(filter \n              (comp not nil?)\n              (map (fn [m] (m %)) maps))]\n    (into {}\n      (map #(hash-map % (reduce op (vs %))) ks))))","problem":69,"user":"4fce5474e4b0d4b2a7a9d451"},{"code":"(fn [f & m]\n  (let [ks (reduce clojure.set/union (map #(set (keys %)) m))]\n    (loop [s ks mm {}]\n      (if (empty? s)\n        mm\n        (recur (rest s)\n               (assoc mm\n                 (first s)\n                 (let [r (remove nil? (map #(% (first s)) m))]\n                   (if (< (count r) 2)\n                     (first r)\n                     (apply f r)))))))))","problem":69,"user":"51740b65e4b0d277d717bc67"},{"code":"(fn [f & ms]\n    (reduce (fn [acc m]\n              (reduce (fn [acc [k v]]\n                        (assoc acc k (if-let [e (acc k)]\n                                       (f e v)\n                                       v))) acc m))\n            ms))","problem":69,"user":"4e6a0667535d8ccf87e9fe9e"},{"problem":69,"code":"(fn my-merge-with\n  [f & args]\n  (loop [acc (first args)\n         rem (rest args)]\n    ; if we have no more maps to merge, return\n    ; our accumulated map\n    (if (empty? rem)\n      acc\n      \n      ; otherwise, merge first from rem\n      ; with our current acc and recur\n      (recur\n        ; this loop should generate our merge\n        (loop [curr-acc acc\n               curr-merge (first rem)\n               ks (keys curr-merge)]\n          (if (empty? ks)\n            ; return if we're out of keys\n            curr-acc\n            (recur\n             (if (contains? curr-acc (first ks))\n               (conj curr-acc {(first ks) (f (get curr-acc (first ks)) (get curr-merge (first ks)))})\n               (conj curr-acc {(first ks) (get curr-merge (first ks))}))\n             curr-merge\n             (rest ks))))\n        (rest rem)))))","user":"53ac4719e4b047364c04445c"},{"problem":69,"code":"(fn  [f m & ms]\n    (reduce (fn [acc cur] \n                (into acc (map (fn [[k v]]  [k (if (acc k) \n                                                (f (acc k) v)\n                                                v)])\n                                              cur)))\n                                            m\n                                            ms))","user":"58ffaddee4b0438e51c2cffe"},{"problem":69,"code":"(fn [f m & ms]\n  (reduce (fn [acc x] \n            (reduce-kv (fn [acc2 k v] (if (contains? acc2 k) \n                                        (assoc acc2 k (f (get acc2 k) v))\n                                        (assoc acc2 k v))) \n                       acc x))\n          m ms))","user":"5d81b40ce4b0915913b1d379"},{"problem":69,"code":"(fn [f & args]\n  (reduce (fn [map1 map2]\n            (reduce (fn [m [k v]]\n                      (if-let [q (m k)]\n                        (assoc m k (f q v))\n                        (assoc m k v)))\n                    map1 map2))\n          args))","user":"5a4443cae4b0447ef91cc60f"},{"problem":69,"code":"(letfn [(reduce-vals [f k ds]\n          (reduce f (filter identity (map #(% k) ds))))]\n  (fn [f & ds]\n    (let [ks (distinct (flatten (map keys ds)))]\n      (into {} (map (fn [k]\n             { k (reduce-vals f k ds)}) ks)))))","user":"5884e807e4b0f1effa3b76a6"},{"problem":69,"code":"(fn g [f & ms]\n  (let [h (fn [m [k v]] (if (m k) (assoc m k (f (m k) v)) (assoc m k v)))]\n    (reduce #(reduce h %1 %2) {} ms)))","user":"57adbe7ee4b0b8559636fca0"},{"code":"(fn [f & m]\n  (into {}\n  (map (fn [[a b]]\n    [a (reduce f (map second b))])\n  (group-by first\n    (mapcat vec m)))))","problem":69,"user":"4f6fbb68e4b07046d9f4efeb"},{"problem":69,"code":"(fn [f & maps]\n         (reduce\n          (fn [c v]\n            (into {} (loop [a c b (apply vector v)]\n                       (if (empty? b)\n                         a\n                         (let [curr (first b) k (first curr)]\n                           (recur (conj a {k (if (contains? a k) (f (get a k) (second curr)) (second curr))}) (rest b)) )))))\n          maps))","user":"564b1ff8e4b0284900eef663"},{"code":"(fn [f m & ms]\n  (reduce (fn [r [k v]] (if (contains? r k) (assoc r k (apply f [(r k) v])) (assoc r k v))) m (apply concat (map seq ms))))","problem":69,"user":"50ebd63ce4b04edc3377703c"},{"code":"(fn my-merge-with\n   ([f original-map] original-map)\n   ([f original-map m & maps]\n      (apply my-merge-with f\n             (loop [current-map original-map\n                    [[k v] & m] (vec m)]\n               (let [old-value (current-map k)\n                     new-map (assoc current-map k (if old-value (f old-value v) v))]\n                 (if m\n                   (recur new-map m)\n                   new-map)))\n             maps)))","problem":69,"user":"4e9fd521535d7eef3080729a"},{"problem":69,"code":"(fn mwf [f & maps]\n  (reduce\n    (fn [nm m1]\n      (apply merge\n             (map\n               (fn [[k v]]\n                 (let [v1 (get nm k)\n                       v2 (get m1 k)]\n                   (if (and v1 v2)\n                     {k (f v1 v2)}\n                     {k v})))\n               (merge nm m1))))\n    {}\n    maps))","user":"5c76577ae4b0fca0c16227ea"},{"problem":69,"code":"(fn mw [f m & ms]\n  (if (first ms)\n    (let [k1 (set (keys m))\n          m2 (first ms)\n          k2 (set (keys m2))\n          common (clojure.set/intersection k1 k2)\n          m2' (reduce #(assoc %1 %2 (f (get m %2) (get m2 %2))) m2 common)]\n      (apply mw f (merge m m2') (rest ms)))\n    m))","user":"5b64370ae4b0c6492753e73c"},{"problem":69,"code":"(fn [op & maps]\n  (reduce \n   \t\t(fn [acc [k v]] (if (contains? acc k) (assoc acc k (op (acc k) v)) (assoc acc k v)))\n      \t{}\n     \t(reduce concat (map vec maps))\n     )\n  )","user":"6004c750e4b074f607df6645"},{"code":"(fn [ f & maps ]\n  (letfn [ (add-val [ m [k v]] (if (contains? m k)\n                                  (assoc m k (f (m k) v))\n                                  (assoc m k v)))\n                \n           (add-all  [ m n ] (reduce add-val m n)) ]\n   (reduce add-all maps)))","problem":69,"user":"4e860e85535db62dc21a62f1"},{"code":"(fn [f & coll] \n   (into {} \n      (map (fn [c] (vector (first c)\n                                 (if (> (count (last c)) 1) \n                                      (apply f (map last (last c)))\n                                      (last (first (last c))) )))  \n                  (group-by key (apply concat coll)) )))","problem":69,"user":"517945dce4b0684c1c981a43"},{"code":"(fn [op m & maps]\n  (reduce (fn [res [k v1]]\n            (if-let [v2 (res k)]\n              (assoc res k (op v2 v1))\n              (conj res [k v1])))\n          m\n          (mapcat seq maps)))","problem":69,"user":"4dc21233535d020aff1edf92"},{"code":"(fn [f & ms]\n  (reduce\n    #(merge %\n      (into {}\n        (for [[k v] %2]\n          [k (if (contains? % k) (f (% k) v) v)])))\n    {} ms))","problem":69,"user":"4f06dcad535dcb61093f6c16"},{"code":"(fn my-merge-with\n  [f m & maps]\n  (if (empty? maps)\n    m\n    (recur f \n           (let [m2 (first maps)]\n             (loop [m1 m                    \n                    ks (keys m2)]\n               (if (empty? ks)\n                 m1\n                 (recur (let [k (first ks)\n                              v (get m2 k)]\n                          (if (contains? m1 (first ks))\n                            (assoc m1 k (f (get m1 k) v))\n                            (assoc m1 k v)))\n                          (rest ks)))))\n           (rest maps))))","problem":69,"user":"4f2942ace4b0d6649770a01e"},{"problem":69,"code":"(fn [f & xs]\n    (reduce \n      (fn [x y]\n        (reduce \n           (fn [m [k v]] \n             (if (contains? m k)\n               (update-in m [k] f v)\n               (assoc-in m [k] v)))\n           x y))\n      xs))","user":"5409a12fe4b0addc1aec66df"},{"problem":69,"code":"(fn [f & maps]\n  (reduce \n   (fn [acc m]\n     (reduce \n      (fn [ac kv]\n        (let [k (key kv)\n              v (val kv)\n              vac (get ac k)]\n          (assoc ac k\n                 (if vac\n                   (f vac v)\n                   v))))\n      acc m))\n   maps))","user":"55d2dd27e4b0e31453f64a5b"},{"code":"(fn[f & args]\n   (reduce (fn [acc e]\n     (into acc (map (fn [[k v]] \n       (if (nil? (get acc k))\n         (vector k v)\n         (vector k (f (get acc k) v)))) e))) args))","problem":69,"user":"4f7431d2e4b044e54cd9a8f7"},{"code":"(fn [f & maps]\n  (reduce (fn [acc m]\n            (reduce (fn [acc [k v]]\n                      (if (contains? acc k)\n                        (update-in acc [k] f v)\n                        (assoc acc k v)))\n                    acc m))\n          {} maps))","problem":69,"user":"4dabb7b1950ed6eda1bd72f3"},{"code":"(fn [o c & e]\n           (reduce #(let [ks (keys %2)]\n                      (loop [r %1 m ks]\n                            (if (not (empty? m))\n                                (let [k (first m)\n                                      v (if (nil? (get r k nil))\n                                            (get %2 k)\n                                          (o (get r k 0) (get %2 k)))]\n                                  (recur (assoc r k v) (rest m)))\n                              r))) c e))","problem":69,"user":"511b810ce4b07ab9ec456182"},{"code":"(fn [f & maps]\n  (reduce \n(fn [map1 map2]\n  (loop [m1 map1 m2 map2 res {}]\n    (if (empty? m1)\n      (merge res m2)\n      (let [key (first (keys m1))]\n        (if (contains? m2 key)\n          (recur\n            (dissoc m1 key)\n            (dissoc m2 key)\n            (assoc res key (apply f [(m1 key) (m2 key)])))\n          (recur\n            (dissoc m1 key)\n            m2\n            (assoc res key (m1 key)))))))) \n    maps))","problem":69,"user":"4f1e4ab5535d64f603146496"},{"problem":69,"code":"(fn my-merge-with [f & args]\n  (reduce\n    ; c 为 {} 对象\n    (fn [p c]\n      (reduce\n        (fn [ip ikey]\n            (assoc\n              ip\n              ikey\n              (if\n                (get ip ikey)\n                (f (get ip ikey) (get c ikey))\n                (get c ikey)\n                )\n              )\n          )\n        p\n        (keys c)\n        )\n      )\n    (hash-map) args)\n\n  )","user":"5edc16e1e4b0c7845d86b0f1"},{"code":"(fn [f & ms]\n  (letfn [(merge-keys [state [k v]] (assoc state k (conj (get state k []) v)))\n          (reduce-values [[k vs]] [k (reduce f vs)])]\n    (->> ms (apply concat) (reduce merge-keys {}) (map reduce-values) (into {}))))","problem":69,"user":"4e8e0a62535d65386fec213f"},{"problem":69,"code":"(fn my-merge-with\n   ([f m1] m1)\n   ([f m1 & maps]\n      (reduce (fn [acc m]\n                (reduce (fn [a [k v]]\n                          (assoc a k (if (get a k)\n                                       (f (get a k) v)\n                                       v))) acc m))\n              m1 maps)))","user":"535eaa73e4b04ce2eb3ed2d4"},{"problem":69,"code":"(fn [f m & ms]\n    (reduce\n     (fn [result curr]\n       (reduce\n        (fn [res [k v]]\n          (assoc res k (if (get res k)\n                         (f (get res k) v)\n                         v)))\n        result curr))\n     m ms))","user":"57b39fbee4b0fbc9809a2783"},{"code":"(fn [func map-1 map-2 & more-maps]\n    (if (nil? map-2)\n      map-1\n      (recur func\n       (loop [key-vals (keys map-2)\n              map-1-new map-1]\n         (if (empty? key-vals)\n           map-1-new\n           (recur (rest key-vals)\n                  (assoc\n                      map-1-new\n                    (first key-vals)\n                    (if (contains? map-1-new (first key-vals))\n                      (func (get map-1-new (first key-vals))\n                            (get map-2 (first key-vals)))\n                      (get map-2 (first key-vals))))\n                  )\n           )\n         )\n       (first more-maps)\n       (rest more-maps)\n       )\n      )\n    )","problem":69,"user":"52213426e4b0e6a83c8925c4"},{"problem":69,"code":"(fn merw [f & maps]\n  (let [[m & more] maps]\n    (reduce (fn [acc hmap]\n              (reduce-kv (fn [acc k v]\n                           (if (contains? acc k)\n                             (assoc acc k (f (get acc k) v))\n                             (assoc acc k v)))\n                         acc\n                         hmap))\n            m\n            more)))","user":"58a2b57fe4b02bd94d917ede"},{"code":"(fn [x y & r]\n  (reduce (fn [s [a b]]\n            (if (contains? s a)\n              (assoc s a (x (get s a) b))\n              (assoc s a b)))\n          y\n          (apply merge r)))","problem":69,"user":"529b44afe4b02ebb4ef7509d"},{"problem":69,"code":"(fn [f & maps]\n  (reduce\n   (fn [a b]\n     (reduce\n      (fn [x [k v]]\n        (assoc x k (if (b k) (f v (b k)) v)))\n      b a))\n   (first maps) (rest maps)))","user":"5522cd9ae4b0882d96d091ab"},{"problem":69,"code":"(fn [func & dicts] \n  (let [key-set (reduce into (sorted-set) (map keys dicts))]\n    (zipmap key-set\n      (map \n        (fn [key]\n          (let [aggregated-vals (keep identity (map #(get %1 key) dicts))]\n            (if (> (count aggregated-vals) 1)\n              (apply func aggregated-vals)\n              (apply identity aggregated-vals))))\n        key-set))))","user":"5227eacee4b0186687e23a5e"},{"code":"(fn [f & ms]\n  (letfn [(map-over-map-vals [m f] (zipmap (keys m) (map f (vals m))))\n          (maps-with-key [maps k] (filter #(contains? % k) maps))\n          (map-vals-for-key [maps k] (vector k (map #(% k) (maps-with-key ms k))))\n          (comb [& maps]\n            (let [ks (distinct (mapcat keys maps))]\n              (into {} (map #(map-vals-for-key maps %) ks))))]\n    (map-over-map-vals (apply comb ms) #(reduce f %))))","problem":69,"user":"5133e51ae4b0d7a043de8cf6"},{"code":"(fn mrg-with [f & maps]\n\t(reduce\n\t\t(fn [m1 m2]\n\t\t\t(reduce\n\t\t\t\t(fn [m k]\n\t\t\t\t\t(conj m\n\t\t\t\t\t\t[k (cond\n\t\t\t\t\t\t\t(and (contains? m1 k) (contains? m2 k)) (f (get m1 k) (get m2 k))\n\t\t\t\t\t\t\t(contains? m1 k) (get m1 k)\n\t\t\t\t\t\t\t:else (get m2 k)\n\t\t\t\t\t\t)]\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t\t{} (concat (keys m1) (keys m2))\n\t\t\t)\n\t\t)\n\t\tmaps\n\t)\n)","problem":69,"user":"511cca27e4b00c2a1fa7ff7d"},{"code":"(fn [f & maps]\n  (loop [result (first maps),\n         remaining (next maps)]\n    (if-not remaining\n      result\n      (let [m (first remaining),\n            acc (reduce (fn [init [k v]]\n                          (if-not (contains? init k)\n                            (assoc init k v)\n                            (assoc init k (f (init k) v))))\n                        result m)] \n        (recur acc (next remaining))))))","problem":69,"user":"5341b141e4b00652c8746ecf"},{"code":"(fn test69 [f & ms]\n  (->> ms\n       (apply concat)\n       (group-by key)\n       (map (fn [[k vs]] [k (reduce f (vals vs))]))\n       (into {})))","problem":69,"user":"50b0cffae4b009df37c708c5"},{"code":"(fn [f & maps]\n(let [merge2\n(fn [a b]\n  (loop [s (seq b) res a]\n     (if (seq s)\n        (let\n          [keyval (first s)\n           k  (key keyval)\n           v  (val keyval)\n           resval ( if (contains? a k)\n                    (f (a k) v)\n                    v\n                   )]\n           (recur (next s) (assoc res k resval))\n          )\n        \n        res\n     )\n  )\n) ]\n(reduce merge2 maps)))","problem":69,"user":"4f03154a535dcb61093f6a58"},{"code":"(fn [f & ms]\n  (reduce\n\t  #(reduce (fn [a [k v]]\n                 (if (contains? a k)\n                   (assoc a k (f (a k) v))\n                   (assoc a k v))) %1 %2)\n  ms))","problem":69,"user":"50a2f901e4b029e8bace362a"},{"code":"(fn [func & maps] (into {}\n        (map (fn [[k a]] [k (reduce func (map second a))])\n             (group-by first (mapcat seq maps)))))","problem":69,"user":"51929214e4b08962174cf74c"},{"problem":69,"code":"(fn [f & xs] \n  (loop [colls xs val {}] \n    (if \n      (empty? colls)\n      val\n      (recur \n        (rest colls)\n        (reduce \n          #(let [k (first %2) v (last %2)]\n            (if \n              (contains? %1 k)\n              (update-in %1 [k] f v)\n              (assoc-in %1 [k] v))) \n          val \n          (first colls))))))","user":"564c8e99e4b0284900eef674"},{"problem":69,"code":"(fn my-merge-with \n  ([f] {})\n  ([f v] \n  v)\n  ([f v n & args]\n      (let [\n            vks (keys v)\n            nks (keys n)\n            intks (into '() \n              (clojure.set/intersection \n                (set vks) \n                (set nks)))\n        ]\n        (apply my-merge-with\n          f\n          (merge \n            (zipmap vks (map #(get v %) vks))\n            (zipmap nks (map #(get n %) nks))\n            (zipmap intks (map #(f (get v %) (get n %)) intks))\n          )\n          args\n        )\n      )\n    \n  )\n)","user":"5710140fe4b09c608db7042e"},{"code":"(fn [f & args] \r\n  (reduce \r\n    (fn [r, a] \r\n      (reduce \r\n        #(let [[k v] %2] (if (contains? r k) (conj %1 [k (f (r k) v)]) (conj %1 %2)))\r\n        r a)) \r\n    {} args))","problem":69,"user":"4feada56e4b0140c20fb9c11"},{"problem":69,"code":"(fn [f m & n]\n    (reduce \n      #(reduce \n        (fn [a [k v]] (assoc a k \n          (if (nil? (a k)) \n              v \n              (f (a k) v))))\n          %1 %2)\n        m\n        n))","user":"561047eae4b05f002753df6d"},{"problem":69,"code":"(fn [f & ms]\n  (loop [xs (mapcat seq ms), res {}]\n    (if (empty? xs) res\n      (let [[k v] (first xs)]\n        (recur (rest xs)\n               (assoc res k (if (contains? res k) (f (res k) v) v)))))))","user":"553e0b70e4b0a04f792994e8"},{"problem":69,"code":"(fn [f coll & args]\n  (reduce-kv (fn [r k v]\n               (if (r k)\n                 (assoc r k (apply f (r k) [v]))\n                 (assoc r k v)))\n             coll (into {} args)))","user":"5a9bfd57e4b0d174b936c7d0"},{"problem":69,"code":"(fn necro [f l & ol]\n  (let [result \n   (for [a ol]\n    (for [b a]\n      (if (contains? l (key b))\n        (hash-map (key b) (f (get l (key b)) (val b)))\n        (hash-map (key b) (val b)))))]\n    (apply conj (flatten result))))","user":"52747090e4b03e8d9a4a74a5"},{"problem":69,"code":"(fn \n  [fnc & maps]\n  (into {} (map #(vector (first %) (reduce fnc (map last (last %)))) (group-by first (apply concat maps)))))","user":"563a30d7e4b0bfe05bf117f9"},{"code":"(fn mwx [f & xs]\n  ((fn mw [f mss]\n              (if (empty? mss) {}\n                  (let [ms (first mss) rs (rest mss) ks (keys ms)\n                        zs (mw f rs)]\n                    (letfn [(upd [m k f v]\n                                 (if (nil? (get m k)) (conj m [k v])\n                                     (conj m [k (f (get m k) v)])))]\n                      (reduce #(upd %1 %2 f (get ms %2)) zs ks)))))\n   f (reverse xs)))","problem":69,"user":"4ee82ce9535d93acb0a6687a"},{"problem":69,"code":"(fn [f & maps]\n  (let [entry #(let [k (key %2) v (val %2)]\n                       (if (%1 k)\n                         (assoc %1 k (f (get %1 k) v))\n                         (assoc %1 k v)))\n        merge2 #(reduce entry (or %1 {}) (seq %2))]\n    (reduce merge2 maps)))","user":"557e8326e4b05c286339e0d7"},{"code":"(fn merge-with2\r\n  [f & maps]\r\n  (when (some identity maps)\r\n    (let [merge-entry (fn [m e]\r\n                        (let [k (key e) v (val e)]\r\n                          (if (contains? m k)\r\n                            (assoc m k (f (get m k) v))\r\n                            (assoc m k v))))\r\n          merge2 (fn [m1 m2]\r\n                   (reduce merge-entry (or m1 {}) (seq m2)))]\r\n      (reduce merge2 maps))))","problem":69,"user":"4e6defcc535d5021c1a895f8"},{"problem":69,"code":"(fn\n  ([f] {})\n  ([f m] m)\n  ([f m1 m2 & ms]\n   (letfn [(my-merge-with [mi mj]\n             (into mi\n                   (map (fn [[k v]]\n                          (if (contains? mi k)\n                            [k (f (get mi k) v)]\n                            [k v]))\n                        mj)))]\n     (reduce my-merge-with (my-merge-with m1 m2) ms))))","user":"57f80350e4b0d3187e90090c"},{"problem":69,"code":"(fn [f & maps]\n  (reduce (fn [res m]\n            (merge\n             res\n             (into {}\n                   (map #(if (contains? res (key %))\n                           [(key %) (f (res (key %)) (val %))]\n                           %)\n                        m))))\n          {} maps))","user":"54926752e4b0b312c081ff44"},{"problem":69,"code":"(fn mape\n  [f & maps]\n  (reduce\n    (fn [m1 m2]\n      (conj \n        m2\n        (into {}\n          (map (fn [[key val]] (if (and (contains? m1 key) \n                                        (contains? m2 key))\n                                    [key (f val (get m2 key))]\n                                    [key val]\n                                )\n                )\n                m1\n          )\n        )\n      )\n    )\n    maps\n  )\n)","user":"5d7d17ece4b02e6b30c93558"},{"problem":69,"code":"(fn [f & ms] (let [ddon\n                   (fn ([a] a)\n                       ([a b] (f a b)))]\n(into {} (map (fn [[k vv]]\n        [k (apply ddon vv)])\n  (reduce\n   (fn [mmap [k v]]\n    (assoc\n     mmap\n     k\n     (conj (mmap k []) v)))\n   (sorted-map)\n   (apply concat\n    (map (partial into []) ms)))\n )\n)\n))","user":"549a999be4b0f3d1d8e70f6f"},{"problem":69,"code":"(fn [f m & r]\n  (reduce (fn [m n]\n            (reduce-kv (fn [m k v]\n                         (if-let [cv (m k)]\n                           \t(assoc m k (f cv v))\n                           \t(assoc m k v))) m n)) m r))","user":"56baa68ce4b0f26550335947"},{"code":"(fn [f & args]\r\n  (loop [final (first args) maps (rest args)]\r\n    (if (empty? maps)\r\n      final\r\n      (recur ((fn mmerge [m new]\r\n                (if (empty? new)\r\n                  m\r\n                  (let [[k v] (first new)]\r\n                    (if (contains? m k)\r\n                      (mmerge (assoc m k (f (get m k) v)) (rest new))\r\n                      (mmerge (assoc m k v) (rest new)))))) final (first maps)) (rest maps)))))","problem":69,"user":"4df3df8a535d08e6dec9fe2d"},{"problem":69,"code":"(fn merge-maps [func m & maps]\n  (reduce (fn [reduction hashmap]\n            (apply assoc reduction \n                   (apply concat \n                          (map (fn [key-val] key-val\n                                 (if (contains? reduction (key key-val))\n                                   (vector (key key-val) (func (reduction (key key-val)) (val key-val)))\n                                   key-val)) hashmap)))) m maps))","user":"5486e317e4b0e286459a11c0"},{"problem":69,"code":"(fn merge-with-fn [oper & vmaps]\n\t(let [fvec (mapcat vec (map #(seq %) vmaps))]\n\t\t(letfn [(mem-test [m v-val]\n\t\t\t(let [[k v] v-val] \n\t\t\t(if (contains? m k) \n\t\t\t\t\t(assoc m k (oper (get m k) v))\n\t\t\t\t\t(assoc m k v))))]\n\t\t(reduce mem-test {} fvec))))","user":"538e29d1e4b0b51d73faae80"},{"code":"(fn [f & s]\n  (loop [a {} b s]\n    (if (empty? b)\n      a\n      (recur\n       (into a\n             (map (fn [[k v]]\n                    (hash-map k (if (get a k)\n                                  (f (get a k) v)\n                                  v)))\n                  (first b)))\n       (next b)))))","problem":69,"user":"4e842ebb535db62dc21a62df"},{"problem":69,"code":"(fn my-merge-with [f oldmap & newmaps]\n  (loop [om oldmap\n         nms (mapcat seq newmaps)]\n    (if (empty? nms) om\n      (let [[k v] (first nms)]\n        (recur (if (contains? om k)\n                 (assoc om k (f (get om k) v)) ; `update` gives an error??\n                 (assoc om k v))\n               (rest nms))))))","user":"5d929ceae4b0915913b1d412"},{"code":"(fn my-merge-with [f orig & merges]\r\n  (let [merges (apply merge merges)]\r\n    (merge merges\r\n     (apply merge (map (fn [e] {(first e) (f (second e) (merges (first e)))}) orig)))))","problem":69,"user":"4dd023dd535d5973398f92ad"},{"problem":69,"code":"(fn [f acc & ms]\n  (reduce \n    (fn [acc m]\n      (reduce\n        (fn [acc [k v]]\n          (if (contains? acc k)\n            (update-in acc [k] f v)\n            (assoc acc k v)))\n        acc m))\n    acc ms))","user":"562cd94ee4b0a45d2ff83015"},{"problem":69,"code":"(fn merge-rec [op merged & maps] (if (empty? maps) merged (let [to-merge (first maps)] (apply merge-rec op (merge merged (into {} (map (fn f [[k v]] [k (if (contains? merged k) (op (get merged k) v) v)]) to-merge))) (rest maps)))))","user":"594d4c57e4b07ddc2dafae87"},{"code":"(fn merge-with1 [f & ms]\n  (reduce \n   (fn [agg elem]\n     (reduce\n      (fn [agg1 [k v]]\n        (if (contains? agg1 k)\n          \t(conj agg1 [k (f (agg1 k) v)])\n            (conj agg1 [k v])))\n      agg\n      elem))\n   (first ms)\n   (rest ms)))","problem":69,"user":"5268eb68e4b03e8d9a4a71c6"},{"code":"(fn [f m & ms]\n  (reduce (fn [m1 m2] \n    (reduce (fn [m [k v]] \n              (conj m [k (if (contains? m k) (f (m k) v) v)]))\n            m1 m2))\n    m ms))","problem":69,"user":"4e8612f8535db62dc21a62f2"},{"problem":69,"code":"(fn my-merge-with [f m & ms]\n  (if (empty? ms)\n    m\n    (let [new-m (reduce (fn [acc [k v]]\n                          (if (acc k)\n                            (assoc acc k (f (acc k) v))\n                            (assoc acc k v)))\n                        m\n                        (first ms))]\n      (recur f new-m (rest ms)))))","user":"57c500f9e4b05aa3c4741cda"},{"problem":69,"code":"(fn [f & ms]                                                                                                                    \n    (reduce                                                                                                                                             \n        #(into                                                                                                                  \n            %1                                                                                                                                          \n            (map (fn [[k v]] (if (contains? %1 k) {k (f (%1 k) v)} {k v})) (seq %2)))                                                                   \n        {}                                                                                                                                              \n        ms))","user":"558b50d5e4b027778923762b"},{"problem":69,"code":"(fn my-merge-with [f & maps]\n    (reduce\n      (fn my-merge [m1 m2]\n        (reduce (fn [acc [k v]] (assoc acc k (if (contains? acc k) (f (get acc k) v) v))) m1 m2))\n      (first maps) (rest maps)\n      ))","user":"550c55d0e4b06e50f9beb14d"},{"code":"(fn [f m & ms]\n  (if (seq ms)\n    (recur f\n      (reduce\n        (fn [r [k v]]\n          (if (contains? r k)\n            (assoc r k (f (get r k) v))\n            (assoc r k v)))\n        m\n        (first ms))\n      (rest ms))\n    m))","problem":69,"user":"4dbdc9da535d020aff1edf4c"},{"code":"(fn [r f & ms]\n  (r\n   #(r (fn [m [k v]] (update-in m [k] (fn [o] (if o (f o v) v))))\n       % %2)\n   ms))\nreduce","problem":69,"user":"4e96557d535dbda64a6f6b43"},{"code":"(fn [f & maps]\n(let [all-keys (into #{} (mapcat keys maps))\n       args (fn [k] (map #(% k) (filter #(% k) maps)))\n       mrg (fn [k] (let [a (args k)] (if (= 1 (count a)) (first a) (apply f a))))]\n     (apply hash-map (mapcat #(vector % (mrg %)) all-keys))))","problem":69,"user":"4dcfbc44535d5973398f92a7"},{"problem":69,"code":"(fn [f & ms]\n  (reduce \n   (fn [acc m] \n     (reduce \n      #(let [k (key %2) v (val %2)]\n          (if (contains? % k) \n            (update-in % [k] f v) \n            (assoc-in % [k] v)))\n      acc m))\n   ms))","user":"5392bfdee4b0b51d73faaeb2"},{"code":"(fn [f & colls]\n  ; reduce all colls\n  (reduce \n    (fn [left right]\n       ; reduce by merging `right` into `left`\n       (reduce \n         (fn [m [k v]]\n           ; if the value already exists in the left\n           (if (contains? m k)\n             ; use the result of `f` applied to both values\n             (assoc m k (f (get m k) v))\n             ; else just use the value from `right`\n             (assoc m k v)))\n         left right))\n  colls))","problem":69,"user":"53834ed3e4b06839e8705edb"},{"problem":69,"code":"(fn eka\n    ([op xr & xs]\n     (if (empty? xs) xr\n     (recur op\n            (into {}\n              (for [k (set (concat (keys xr)(keys (first xs))))\n                    :let [v1 (get xr k)\n                          v2 (get (first xs) k)\n                          v (if (and v1 v2) (op v1 v2)\n                                            (if v1 v1 v2))\n                          ]]\n                [k v]\n                )\n              )\n               (rest xs)))\n      ))","user":"596d630ae4b069c0a1a19846"},{"problem":69,"code":"(fn [fx & maps]\n  (letfn [(foo [m1 m2 ks]\n          (if (empty? ks) m1\n              (let [k (first ks)]\n                (if (contains? m1 k)\n                  #(foo (assoc m1 k (fx (m1 k) (m2 k))) m2 (rest ks))\n                  #(foo (assoc m1 k (m2 k)) m2 (rest ks))))))]\n    (reduce #(trampoline foo % %2 (keys %2))\n            maps)))","user":"538e36c7e4b0b51d73faae81"},{"problem":69,"code":"(fn cmw [func & maps]\n    (into {}\n        (map #(vector (first %)\n                      (reduce (fn [acc [_ val]] (func acc val))\n                              (second (first (second %)))\n                              (rest (second %))))\n             (group-by first (apply concat maps)))))","user":"5f548678e4b0a0bc16850a7e"},{"problem":69,"code":"(fn [f & ms]\n    (reduce (fn merge-entry [result [k v-latter]]\n              (let [v-result (get result k)]\n                (if (nil? v-result)\n                  (assoc result k v-latter)\n                  (assoc result k (f v-result v-latter)))))\n            {}\n            (mapcat seq ms)))","user":"5df70ee8e4b0a607a9a45c8a"},{"code":"(fn [f & ms]\n  (let [merge-entry (fn [m e]\n            (let [k (key e) v (val e)]\n              (if (contains? m k)\n                (assoc m k (f (get m k) v))\n                (assoc m k v))))\n          merge2 (fn [m1 m2]\n           (reduce merge-entry (or m1 {}) (seq m2)))]\n      (reduce merge2 ms)))","problem":69,"user":"4ed60c9c535d10e5ff6f52dd"},{"problem":69,"code":"(fn p69\n           ([f l r]\n            (let [lkeys (keys l)\n                  rkeys (keys r)\n                  common (filter (set lkeys) rkeys) ; behaves like intersection\n                  lcom (map l common)\n                  rcom (map r common)]\n              (merge l r (zipmap common (map #(f %1 %2) lcom rcom)))))\n           ([f l r & maps]\n            (reduce (partial p69 f) (into [l r] maps))))","user":"55d204abe4b0e31453f64a4f"},{"problem":69,"code":"(fn merg-with [f m & maps]\n  (if (empty? maps)\n    m\n    (let [n (first maps)]\n      (apply merg-with\n             (concat [f\n                      (into {}\n                            (for [k (concat (keys m) (keys n))]\n                              (let [vm (get m k)\n                                    vn (get n k)]\n                                (if (nil? vm) [k vn]\n                                    (if (nil? vn) [k vm]\n                                        [k (f vm vn)])))))]\n                     (rest maps))))))","user":"549dfe40e4b0f3d1d8e70f9a"},{"problem":69,"code":"(fn my-merge-with [merge-fn m1 & mrest]\n                  (reduce (fn [acc [current-key current-value]]\n                              (assoc acc\n                                     current-key\n                                     (if (contains? acc current-key)\n                                         (merge-fn (get acc current-key)\n                                                   current-value\n                                         )\n                                         current-value\n                                     )\n                               )\n                           )\n                           m1\n                           (mapcat seq mrest)\n                   )\n)","user":"5990fcb9e4b0866487ed0d5b"},{"problem":69,"code":"(fn [f & args]\n  (let [all-keys (set (flatten (map keys args)))\n        f2 (fn [& ars] (if (nil? (next ars)) (first ars) (apply f ars)))]\n    (reduce (fn [r k] (assoc \n                        r \n                        k \n                        (apply f2 (filter (comp not nil?) (map (fn [i] (get i k)) args))))) \n        {} \n        all-keys)))","user":"5374adc3e4b06d7f452d9e27"},{"problem":69,"code":"(fn [f m & ms]\n      (reduce (fn [ps xs]\n                (reduce (fn [p [k v]]\n                          (update-in p [k] #(if % (f % v) v))) ps xs)) m ms))","user":"5d29c06be4b01671435dbc6b"},{"code":"(fn [o & m] \n    (reduce merge (let[w (reduce #(set (concat %1(keys %2))) #{} m)] \n        (map \n            (fn[a] {a \n                (reduce o (map second (filter #(true? (first %)) (map \n                    (fn[k][(contains? k a) (get k a)])m))))})w))))","problem":69,"user":"5017eface4b02f523d7cc5e7"},{"code":"(fn [f t & s]\n  (reduce (fn [t s] \n            (loop [s s acc t]\n                  (if (empty? s)\n                      acc\n                      (let [e (first s)\n                            k (key e)\n                            vs (val e)\n                            vacc (get acc k)\n                            vn (if (nil? vacc) vs (f vacc vs))]\n                        (recur (rest s) (assoc acc k vn))))))\n          t\n          s))","problem":69,"user":"4f9120d8e4b0dcca54ed6c96"},{"problem":69,"code":"(fn [f first-map & more-maps]\n    (let [merge-maps\n          (fn [m1 m2]\n            (reduce-kv\n             #(assoc %1 %2\n                     (if (contains? %1 %2)\n                       (f (get %1 %2) %3)\n                       %3))\n             m1\n             m2))]\n      (reduce merge-maps first-map more-maps)))","user":"539fa040e4b0ca733b97449f"},{"code":"(fn mw[f & args]\n  (reduce \n    (fn [r i] \n      (reduce \n        (fn[r [k v]] \n          (if (contains? r k)\n            (assoc r k (f (get r k) v))\n            (assoc r k v)))\n        r i))\n    {} args))","problem":69,"user":"500b61b1e4b03d00572d2d81"},{"problem":69,"code":";(vec(\n (fn [f & ms]\n   (reduce (fn [m [k v]] (update-in m (list k) #(if (nil? %1) %2 (f %1 %2)) v)) {} (mapcat vec ms)))\n ;* {:a 2 :b 3 :c 4} {:a 2} {:b 2} {:c 5}))","user":"573632b7e4b0cd1946bd102f"},{"code":"(fn [f & m]\n  (into {}\n    (for [[k _] (apply merge m)]\n      [k (#(if (second %)\n               (apply f %)\n               (first %))\n            (filter identity (map #(% k) m)))])))","problem":69,"user":"50a83315e4b054305ba5a830"},{"problem":69,"code":"(fn merge-with-home-made [f & ms]\n  (reduce (fn [accum curr]\n            (reduce #(conj\n                      %1\n                      (let [[k v] %2]\n                        (if-let [v-accum (get accum k)]\n                          [k (f v-accum v)] \n                          %2)))\n                    accum\n                    curr))\n          {}\n          ms))","user":"5ed52854e4b016b56eae05d2"},{"problem":69,"code":"(fn [f & ms-in]\n          (if (empty? ms-in)\n            {}\n            (loop [ms ms-in\n                   m-acc {}]\n              (if (empty? ms)\n                m-acc\n                (let [m1 (first ms)\n                      m-ret (loop [ks (keys m1)\n                                   m  m-acc]\n                              (if (empty? ks)\n                                m\n                                (let [k (first ks)\n                                      tmp-m (if (contains? m k)\n                                              (update-in m [k] f (get m1 k))\n                                              (assoc m k (get m1 k)))]\n                                  (recur (rest ks) tmp-m))))]\n                  (recur (rest ms) m-ret)\n                  )))))","user":"52c58561e4b0c2d177d620f8"},{"code":"(fn merge [f & maps]\n  (when (some identity maps)\n    (let [merge-entry (fn [m e]\n  \t\t(let [k (key e) v (val e)]\n\t\t\t  (if (contains? m k)\n\t\t\t    (assoc m k (f (get m k) v))\n\t\t\t    (assoc m k v))))\n          merge2 (fn [m1 m2]\n\t\t   (reduce merge-entry (or m1 {}) (seq m2)))]\n      (reduce merge2 maps))))","problem":69,"user":"4f4f543ce4b03ad3f0c10cdf"},{"code":"(fn [f m & more]\n  (reduce (fn [acc [k v]]\n            (if (contains? acc k)\n              (update-in acc [k] f v)\n              (assoc acc k v)))\n          m\n          (apply concat more)))","problem":69,"user":"51b38769e4b026427ecf067f"},{"problem":69,"code":"(fn [f m0 & ms]\n  (reduce (fn [m kv]\n            (let [k (first kv)\n                  v (second kv)]\n              (if (find m k)\n                  (assoc m k (f (get m k) v))\n                  (assoc m k v))))\n          m0\n          (mapcat seq ms)))","user":"548fa2dfe4b0e286459a1240"},{"problem":69,"code":"(fn merge-with-ms\n  [fnc & maps]\n  (reduce (fn [m1 m2]\n            (into m1 [(reduce #(if (contains? %1 (first %2))\n                                 (into %1 [[(first %2)\n                                            (fnc (%1 (first %2)) (second %2))]])\n                                 (into %1 [%2]) ) m1 m2 )])\n            ) {} maps))","user":"561ca6ebe4b064ca9f4b169c"},{"problem":69,"code":"(fn [g & ms]\n  (println \"ms\" ms)\n  (let [m (apply conj ms)\n        fv (fn [k] (->> ms \n                         (filter #(contains? % k))\n                         (map #(get % k))))]\n    \n    (reduce (fn [res k]\n              (let [vs (fv k)]\n                (assoc res k (if (< 1 (count vs)) (apply g vs) (first vs)))))\n                      {} (keys m))))","user":"53b42472e4b047364c0444b2"},{"problem":69,"code":"(fn apna-merge [& args]\n  #_=>   (reduce\n  #_=>    (fn [acc m]\n  #_=>      (reduce\n  #_=>       (fn [res me]\n  #_=>         (if (contains? res (key me))\n  #_=>           (conj res {(key me) ((first args) (res (key me)) (val me))})\n  #_=>           (conj res me))) acc m)) {} (rest args)))","user":"5e0cbc14e4b099d064962f8e"},{"code":"(fn f1 [f & maps] \n\t\t(let [\n\t\t\tk (keys (reduce merge maps))\n\t\t\tm (map (fn [w] (vector w (  reduce (fn [c mp] (if (get mp w) (conj c (get mp w)) c) ) [] maps  ) ) ) k)\n\t\t\tm2 (map (fn [q] (hash-map (first q) (reduce f (second q))) ) m)\n\t\t] (apply merge m2)) \n\t)","problem":69,"user":"5296008fe4b02ebb4ef7502a"},{"problem":69,"code":"(fn [f m & xs ]\n    ((fn mmw [f m xs]\n       (letfn [(mm2 [f m1 m2]\n                 (if (seq m2)\n                   (let [x (first m2)]\n                     (if (contains? m1 (key x))\n                       (recur f (assoc m1 (key x) (f (m1 (key x)) (val x))) (rest m2))\n                       (recur f (assoc m1 (key x) (val x)) (rest m2))))\n                   m1)\n                 )]\n         (if (seq xs)\n           (mmw f (mm2 f m (first xs)) (rest xs))\n           m))) f m xs))","user":"5921a080e4b09b4ee5954c77"},{"code":"(fn [func initial & maps]\n  (reduce (fn [result m]\n    (reduce (fn [result kv]\n      (let [k (first kv) v (second kv)]\n        (if (contains? result k)\n          (conj result [k (func (result k) v)])\n          (conj result [k v])))) result m)) initial maps))","problem":69,"user":"4f294c48e4b0d6649770a023"},{"problem":69,"code":"(fn [f & maps]\n  (let [ks (set (mapcat keys maps))]\n    (apply merge (for [k ks] \n      {k (#(apply (if (> (count %2) 1) %1 identity) %2) f\n                (map #(get % k) (filter #(contains? % k) maps)))}))))","user":"52d07cc5e4b07d0d72b273bb"},{"code":"(fn mf [f r & maps]\n  (if (empty? maps) r\n    (let [wf (fn [x y] (if y (if x (f x y) y) x))\n          fm (first maps)\n          ks (concat (keys r) (keys fm))\n          result (into {}\n                       (for [k ks]\n                         {k (wf (r k) (fm k))}))]\n      (apply (partial mf f result) (rest maps)))))","problem":69,"user":"515ffbfbe4b0e2be8aa20bdd"},{"problem":69,"code":"(fn my-merge-with [f a1 & a2]\n  (loop [result a1 k (keys (first a2)) cur (first a2) coll (rest a2)]\n    (if (and (empty? k) (empty? coll))\n      result\n      (if (empty? k)\n        (recur result  (keys (first coll)) (first coll) (rest coll))\n        (if (nil? (result (first k)))\n          (recur (assoc result (first k) (cur (first k))) (rest k) cur coll)\n          (recur (assoc result (first k) (f (result (first k)) (cur (first k)))) (rest k) cur coll))))))","user":"55eb026de4b0121d4835fdb7"},{"problem":69,"code":"(fn mw [f & res]\n  (reduce (fn [m n]\n            (reduce (fn [mm [k v]]\n                      (if (contains? mm k)\n                        (update-in mm [k] f v)\n                        (assoc-in mm [k] v)))\n                    m n))\n          res))","user":"54b7f217e4b0ed20f4ff6e8f"},{"code":"(fn my-merge [f h & hashes]\n  \n  ;(println h)\n  (println hashes)\n  \n  (if (or (empty? hashes) (empty? (first hashes)) )\n    h\n    (let [h1 (first (flatten hashes))\n          all_keys (distinct (flatten (conj (keys h) (keys h1) )))\n          result {}]\n       \n      (println (rest hashes))\n      (my-merge f \n      (apply merge\n      (for [ke all_keys]\n       (let [v1 (get h ke)\n             v2 (get h1 ke)\n             v3  (cond \n                  (nil? v1) v2\n                  (nil? v2) v1\n                  :else (f v1 v2)          \n                )]\n         (assoc result ke v3)\n         ))) (rest (flatten hashes)))\n      \n      \n      )\n    \n    \n    )\n  \n  \n\n )","problem":69,"user":"5180dc04e4b06b8caf33fa01"},{"problem":69,"code":"(fn [f & maps]\n  (reduce\n   (fn [m1 m2] \n     (reduce \n      (fn [accm [k v]]\n        (if (contains? accm k)\n          (update-in accm [k] f v)\n          (assoc accm k v)))\n      m1\n      m2))\n   maps))","user":"5cf895efe4b0b71b1d808a85"},{"problem":69,"code":"(fn [f & maps]\n       (let [merge-ents (fn [m [me-key me-val]]\n                          (if (contains? m me-key)\n                            (assoc m me-key (f (get m me-key) me-val))\n                            (assoc m me-key me-val)))]\n         (reduce #(reduce merge-ents %1 %2) {} maps)))","user":"5a64d12de4b0512ff01cd9a7"},{"code":"(fn [f m & maps]\n  (letfn [(merge-key [m1 m2]\n            (let [[k v] m2]\n              (if-let [[mk mv] (find m1 k)]\n                (assoc m1 k (f mv v))\n                (assoc m1 k v))))]\n    (reduce #(reduce merge-key %1 %2) m maps)))","problem":69,"user":"52fb64b7e4b047fd55837009"},{"problem":69,"code":"(fn [func & maps]\n  (letfn\n    [(eat-pair [m [k v]]\n               (if (get m k)\n                 (assoc m k (func (get m k) v))\n                 (conj m [k v])))\n     (eat-map [m m2]\n              (reduce eat-pair m m2))]\n    (reduce eat-map {} maps)))","user":"55c68089e4b0e31453f649c4"},{"problem":69,"code":"(fn my-merge-with [f & maps]\n  (let [into-with\n        (fn [f map1 map2]\n          (let\n              [shared-keys (filter map1 (keys map2))\n               update-values (map #(f (map1 %) (map2 %)) shared-keys)\n               merge-updates (zipmap shared-keys update-values)]\n            (into (into map1 map2) merge-updates)))]\n    (reduce (partial into-with f) maps)))","user":"59f7f55de4b0ca45a743a313"},{"code":"(fn [f & ms]\n  (reduce\n    (fn [acc e]\n      (reduce\n        (fn [acc [k v]]\n          (if (contains? acc k)\n            (update-in acc [k] f v)\n            (apply assoc acc [k v])))\n        acc\n        e))\n    ms))","problem":69,"user":"4de165f3535d08e6dec9fde6"},{"code":"(fn [f & args] (reduce\n                (fn [result eachmap]\n                  (reduce \n                   (fn [result eachkey]\n                     (conj result [eachkey (if (contains? result eachkey)\n                                       (f (result eachkey) (eachmap eachkey))\n                                       (eachmap eachkey)\n                                            )]\n                      )\n                    ) result (keys eachmap)\n                   )\n                 ) (first args) (rest args)))","problem":69,"user":"525372ade4b0541d1855b8f3"},{"code":"(fn conj-maps\n  [f m & xs]\n  (reduce (fn [result x]\n            (loop [r result i x]\n              (if (seq i)\n                (let [[key new-val] (first i)\n                      current-val (get result key)\n                      val (if current-val \n                            (f current-val new-val)\n                            new-val)]\n                  (recur (assoc r key val)\n                         (rest i)))\n                r))) m xs))","problem":69,"user":"5048202fe4b0ec70b3ef8d9a"},{"problem":69,"code":"(fn\n    ([f] nil)\n    ([f & ms]\n     (let [all-keys (apply clojure.set/union (map #(keys %) ms))]\n       (reduce (fn [accu k]\n                 (assoc accu k\n                        (let [vs (keep #(get % k) ms)]\n                          (reduce f (first vs) (rest vs)))))\n               {} all-keys))))","user":"5d883119e4b0915913b1d3a6"},{"code":"(fn [f m & r]\n        (if (empty? r)\n          m\n          (recur f\n                 (into m (for [[k v] (first r)]\n                           (if (get m k)\n                             [k (f (get m k) v)]\n                             [k v])))\n                 (rest r))))","problem":69,"user":"4f031eac535dcb61093f6a67"},{"code":"(fn \n  [f & maps]\n  (letfn [(addpair [m e]\n                      (let [k (key e) v (val e)]\n                        (if (contains? m k)\n                          (assoc m k (f (get m k) v))\n                          (assoc m k v))))\n          (mymerge [m1 m2]\n                 (reduce addpair m1 m2))]\n    (reduce mymerge maps)))","problem":69,"user":"512eb723e4b0b740abc5982b"},{"code":"(fn my-merge-with [func & n-maps]\n  (reduce\n   (fn [init input]\n     (->> (keys input)\n          (reduce\n           (fn [initial ky]\n             (assoc initial ky (if (contains? initial ky)\n                                   (func (initial ky) (input ky))\n                                   (input ky))))\n           init)))\n   n-maps))","problem":69,"user":"52381b2ae4b0fae3832e99ef"},{"code":"(fn [f & maps]\n(reduce \n(fn this [map1 map2]\n  (if (= (count map2) 0) map1\n    (let [[k v2] (first map2),\n          v1 (get map1 k :not-here)]\n      (recur \n        (conj map1 \n          [k (if (= v1 :not-here) \n            v2 (f v1 v2))])\n        (rest map2)))))\nmaps))","problem":69,"user":"4ec12577535dfed6da9c6da8"},{"problem":69,"code":"(fn [f & m] (into {} (for [[k e] (group-by key (apply concat m))] [k (reduce f (map val e))])))","user":"4f5eda39e4b0030a34fb2b56"},{"code":"(fn mw [f & ms]\n  (into {}\n        (for [k (into #{} (mapcat keys ms))]\n          (let [[h & t] (keep #(get % k) ms)]\n            (if t\n              [k (apply f (keep #(get % k) ms))]\n              [k h])))))","problem":69,"user":"52d2ca1ce4b099d49816f0b4"},{"code":"(fn [f & maps]\n  (reduce\n    (fn [result m]\n      (reduce\n        (fn [result [k v]]\n          (if (contains? result k)\n            (update-in result [k] f v)\n            (assoc result k v)))\n        result m))\n    maps))","problem":69,"user":"4e68c434535d8ccf87e9fe89"},{"code":"(fn [f & maps]\n  (reduce (fn [m d]\n            (reduce (fn [m k]\n                      (assoc m k (if (m k) (f (m k) (d k)) (d k))))\n                    m \n                    (keys d)))\n    {}\n    maps))","problem":69,"user":"4f9a0064e4b0dcca54ed6d03"},{"code":"(fn [f & args]\n  (reduce (fn [out in]\n    (reduce (fn [out [k v]]\n      (if (contains? out k)\n        (assoc out k (f (get out k) v))\n        (assoc out k v))) out in)) {} args))","problem":69,"user":"4ebc08a8535dfed6da9c6d7c"},{"problem":69,"code":"(fn merge-with-fn-multiple [f & maps]\n  (let [merge-inner (fn merge-with-fn [f a b]\n                      (reduce (fn [m [k v]]\n                                (if (contains? m k)\n                                  (assoc m k (f (get m k) v))\n                                  (assoc m k v)))\n                              a\n                              b))]\n    (reduce (fn [m1 m2] (merge-inner f m1 m2))\n            {}\n            maps)))","user":"5cdc08a2e4b05ee0cb31173a"},{"problem":69,"code":"(fn [f & maps]\n  (loop [remaining maps, merged {}]\n    (if (seq remaining)\n      (recur (next remaining)\n             (into merged (reduce (fn [acc [key val]]\n                                    (assoc acc key (if-let [val-in-merged (merged key)]\n                                                     (f val-in-merged val)\n                                                     val)))\n                                  merged \n                                  (first remaining))))\n      merged)))","user":"5c196e7be4b01240ff5671fb"},{"code":"(fn [f & colls]\n  (let [kys (keys (apply merge colls))]\n    (reduce\n      (fn [ret ky]\n        (let [vls (remove nil? (map #(get % ky) colls)) \n              vl (if (< 1 (count vls)) (apply f vls) (first vls))]\n        (assoc ret ky vl)))\n      {} kys)))","problem":69,"user":"5084c43be4b0fb8f40674bfa"},{"problem":69,"code":"(fn [f & ms]\n  (reduce (fn [res [k vn]]\n            (if-let [vo (res k)]\n              (assoc res k (f vo vn))\n              (assoc res k vn)))\n          {}\n          (mapcat seq ms)))","user":"50385746e4b0803468ea2c6d"},{"code":"(fn do-it [f & maps]\n  (letfn\n    [(merger [result a-map] (reduce (fn [acc k] (conj acc {k (if (result k) (f (result k) (a-map k)) (a-map k))}))\n                                    result\n                                    (keys a-map)))]\n  (reduce merger maps)))","problem":69,"user":"4f03641a535dcb61093f6a9b"},{"code":"(fn [f & ms]\n  (letfn [(assoc-f [acc [k v]] (assoc acc k (if (acc k) (f (acc k) v) v)))\n          (merge2 [m1 m2] (reduce assoc-f m1 m2))]\n    (reduce merge2 ms)))","problem":69,"user":"510db6cde4b078ea71921145"},{"code":"(fn [f & mps]\n\t(let [all-keys (keys (apply merge mps))]\n\t\t(into {}\n\t\t\t(for [k all-keys]\n\t\t\t\t(let [k-vals\n\t\t\t\t\t\t\t(filter #(not (nil? %))\n\t\t\t\t\t\t\t\t(map (fn [m] (get m k)) mps))]\n\t\t\t\t\t(if (> (count k-vals) 1)\n\t\t\t\t\t\t[k (apply f k-vals)]\n\t\t\t\t\t\t[k (first k-vals)]))))))","problem":69,"user":"5201ff99e4b0b2e020a18f26"},{"problem":69,"code":"(fn flippy [f & colls ]\n  (let [mm\n    \t(fn [f m2 m1 k]\n  \t\t\t(if (contains? m1 k)\n\t\t\t    (assoc m1 k (f (m1 k) (m2 k)))\n\t\t\t    (assoc m1 k (m2 k))\n  \t\t\t)\n\t\t)]\n\t(reduce #(reduce (partial mm f %2) %1 (keys %2)) colls )\n)\n)","user":"54b050cee4b09f271ff37d13"},{"problem":69,"code":"(fn my-merge-with [f m & ms]\n  (reduce\n   \t(fn [old-map new-map]\n      (reduce \n       (fn [o [k v]]\n         (assoc o k\n           (if (o k)\n             (f (o k) v)\n             v)))\n       \told-map new-map))  \n    m\n    ms\n   ))","user":"54448e84e4b032a45b869393"},{"problem":69,"code":"(fn my-merge [f & maps]\n  (let [keys-and-values (reduce concat maps)] ;turn \n    (reduce (fn [acc kv-pair]\n              (let [k (first kv-pair) v (second kv-pair)]\n               (if (contains? acc k)\n                  (assoc acc k (f (get acc k) v))\n                  (assoc acc k v)\n                )\n              )\n            )\n            {}\n            keys-and-values\n      )\n  )\n)","user":"56393681e4b0bfe05bf117f2"},{"problem":69,"code":"(fn [f & args]\n  (let [upd (fn [x y] (let [old (get-in x [(key y)])]\n                        (if (nil? old)\n                          y\n                          (hash-map (key y) (f old (val y))))))\n        fmap (fn [x y] (map #(upd x %) y))]\n    (reduce #(into %1 (fmap %1 %2)) args)))","user":"55205564e4b08d5046aa8a60"},{"problem":69,"code":"(fn my-merge-with [f a-map & maps]\n  (letfn [(my-merge [k map1 map2] (let [mv1 (get map1 k nil)\n  \t\t\t\t\t\t\t  mv2 (get map2 k nil)]\n  \t\t\t\t\t      (if (and mv1 mv2) \n  \t\t\t\t\t      \t{k (f mv1 mv2)}\n  \t\t\t\t\t      \t{k (or mv1 mv2)})))\n  \t\t  (merge-into [map1 map2] (apply merge (map #(my-merge % map1 map2) (into (into #{} (keys map1)) (keys map2)))))]\n  (reduce merge-into a-map maps)))","user":"57c0917be4b05aa3c4741c95"},{"problem":69,"code":"(fn my-merge-with\n  [f & maps]\n  (reduce\n    (fn [m m1]\n      (apply merge\n             m m1\n             (map\n               #(hash-map % (f (get m %) (get m1 %)))\n               (->> [m m1] (map (comp set keys)) (apply clojure.set/intersection))\n               )))\n    (first maps)\n    (rest maps)))","user":"586bc870e4b01531a375e964"},{"code":"(fn [f & ms]\n  (loop [ks (seq (set (apply concat (map keys ms))))\n         ms ms\n         vs (for [k ks] (remove nil? (for [m ms] (m k))))\n         m {}]\n    (if (empty? ks) m\n        (let [k (first ks)\n              v (first vs)\n              v (if (= 1 (count v)) (first v) (apply f v))]\n          (recur (rest ks) ms (rest vs) (assoc m k v))))))","problem":69,"user":"524ae8e6e4b09eba1c0223b5"},{"code":"(fn merge-with-2\n  ([f m1] \n   m1)\n  ([f m1 m2] \n   (reduce (fn [m [k v]]\n             (assoc m k\n               (if (contains? m k)\n                 (f (m k) v)\n                 v)))\n           m1 m2))\n   ([f m1 m2 & more] \n    (apply merge-with-2 f (merge-with-2 f m1 m2) more)))","problem":69,"user":"5326c5f7e4b09d4e7a9b54f2"},{"code":"(fn [f & maps]\n  (when (some identity maps)\n    (let [merge-entry (fn [m e]\n                        (let [k (key e) v (val e)]\n                          (if (contains? m k)\n                            (assoc m k (f (get m k) v))\n                            (assoc m k v))))\n          merge2 (fn [m1 m2]\n                    (reduce merge-entry (or m1 {}) (seq m2)))]\n      (reduce merge2 {} maps))))","problem":69,"user":"4f7e29dde4b06e829148e1ca"},{"problem":69,"code":"(fn [f & ms]\n  (when (some identity ms)\n    (let [merge-into (fn [m1 m2]\n                       (let [k (key m2)\n                             v (val m2)]\n                         (if (contains? m1 k)\n                           (assoc m1 k (f (get m1 k) v))\n                           (assoc m1 k v))))\n          reduce-merge (fn [m1 m2]\n                         (reduce merge-into (or m1 {}) (seq m2)))]\n      (reduce reduce-merge ms))))","user":"56d5fd24e4b0ea9b8538f7c5"},{"code":"(fn [f m & ms]\n  (reduce (fn [m1 m2]\n            (into {} (for [k (distinct (concat (keys m1) (keys m2)))]\n                       (cond\n                        (and (m1 k) (m2 k)) [k (f (m1 k) (m2 k))]\n                        (m1 k) [k (m1 k)]\n                        (m2 k) [k (m2 k)]))))\n          m\n          ms))","problem":69,"user":"4ebcb8ff535dfed6da9c6d8a"},{"problem":69,"code":"(fn [f & ms]\n  (loop [ms ms, res {}]\n    (if (seq ms)\n      (let [nres\n            (reduce-kv (fn [acc k v1]\n                         (if-let [v2 (acc k)]\n                           (assoc acc k (f v2 v1))\n                           (assoc acc k v1)))\n                       res (first ms))]\n        (recur (rest ms) nres))\n      res)))","user":"54ca93abe4b057c6fda3a264"},{"code":"(fn [op & ms]\n  (letfn [(frob [acc [k v]]\n            (assoc acc k\n                   (if-let [v' (acc k)]\n                     (op v' v)\n                     v)))]\n    (reduce frob {} (mapcat seq ms))))","problem":69,"user":"4e8338d6535db62dc21a62d3"},{"code":"(fn [f & ms]\n  (let [c (fn [m [k v]]\n              (if (contains? m k)\n                (conj m [k (f (m k) v)])\n                (conj m [k v])))\n    g (fn [a v]\n            (reduce c a v))]\n    (reduce g {} ms)))","problem":69,"user":"503a234de4b088a6a14ca76d"},{"problem":69,"code":"(fn mw-2 [f & maps]\n  (let [r (fn [i a]\n            (reduce-kv\n             (fn [m k v]\n               (let [existing (get m k)]\n                 (assoc m k (if existing (f existing v) v))))\n             i a))]\n    (reduce (fn [v item] (r v item)) (first maps) (rest maps))))","user":"563fc1f2e4b08d4f616f5ed7"},{"code":"(fn [f h & m] (\n  reduce (fn [a n] \n            (reduce (fn [b e] \n              (assoc b e (if (contains? b e)\n                (f (get b e) (get n e))\n                (get n e)))\n            ) a (keys n))\n          ) h m)\n)","problem":69,"user":"4f1595da535d64f603146444"},{"problem":69,"code":"(fn mw\n    [f & maps]\n    (if maps\n      (reduce #(merge\n                %1 (apply hash-map\n                          (mapcat\n                           (fn [kv]\n                             (let [k (first kv)\n                                   v (second kv)]\n                               (if (contains? %1 k)\n                                 [k (f (get %1 k) v)]\n                                 [k v])))\n                           %2)))\n              maps)))","user":"5974d2ede4b01722bebd4cb6"},{"code":"(fn m \n  ([f l1 l2]\n    (reduce \n      (fn [i [k v]]\n        (if (contains? i k)\n          (update-in i [k] #(f % v))\n          (assoc i k v)))\n      l1 l2))\n  ([f l1 l2 & l]\n    (apply m f (m f l1 l2) l)))","problem":69,"user":"4ff5744ae4b0678c553fc36a"},{"problem":69,"code":"(fn [f & m]\n    (loop [n (first m) m (rest m)] \n      (if (seq m)\n        (recur\n          (loop [q n w (first m) k (apply list (keys q) (keys w)) e (first k)] \n            (if (seq k)\n              (if (and (q e) (w e)) \n                (recur (assoc q e (f (q e) (w e))) w (pop k) (first (pop k)))\n                (if (w e)\n                  (recur (assoc q e (w e)) w (pop k) (first (pop k)))\n                  (recur q w (pop k) (first (pop k)))\n                  )   \n                )   \n              q   \n              )   \n            )   \n          (rest m)\n          )   \n        n   \n        )   \n      )   \n    )","user":"54b90836e4b0ed20f4ff6e9d"},{"code":"(fn [f x & xs]\n  (reduce (fn [x x1] \n            (reduce (fn [x [k v]]\n                      (if (contains? x k)\n                        (update-in x [k] f v)\n                        (assoc-in x [k] v)))\n                    x x1)) x xs))","problem":69,"user":"50310b8be4b05b7df5a0b84d"},{"code":"(fn [f & ms]\n  (reduce (fn [m1 m2]\n            (reduce (fn [m [k v]]\n                      (if (contains? m k)\n                        (update-in m [k] f v)\n                        (assoc m k v)))\n                    m1 m2))\n          ms))","problem":69,"user":"5032b066e4b00c0952a257ea"},{"problem":69,"code":"(fn [f c & s]\n    (reduce \n     (fn [a m] \n       (loop [n a\n              i m]\n         (let [[k v] (first i)\n               r (rest i)]\n           (if (nil? k)\n             n\n             (if (nil? (get n k))\n               (recur (assoc n k v) r)\n               (recur (assoc n k (f (get n k) v)) r))))\n         )) \n     c \n     s))","user":"603ae21de4b0d5df2af222fb"},{"code":"(fn [f & ms]\n  (let [merge-entry (fn [m e]\n         (let [k (key e) v (val e)]\n\t\t       (if (contains? m k)\n\t\t\t       (assoc m k (f (get m k) v))\n\t\t\t\t     (assoc m k v))))\n\t      merge2 (fn [m1 m2]\n\t\t      (reduce merge-entry (or m1 {})(seq m2)))]\n\t\t      (reduce merge2 ms)))","problem":69,"user":"4db2cc55535df7e46ed9b6c5"},{"problem":69,"code":"(fn [f & maps]\n  (let [merge-elem (fn [m e]\n                     (let [k (key e) v (val e)]\n                       (if (contains? m k)\n                         (assoc m k (f (get m k) v))\n                         (assoc m k v))))\n        merge2 (fn [m1 m2]\n                 (reduce merge-elem m1 (seq m2)))]\n    (reduce merge2 maps)\n    )\n  )","user":"515ebde3e4b01e5d11ccd0a8"},{"problem":69,"code":"(fn [f & ms]\n  (reduce\n    (fn [m1 m2]\n      (let [keys12 (clojure.set/intersection (set (keys m1)) (set (keys m2)))\n            keys1 (clojure.set/difference (set (keys m1)) keys12)\n            keys2 (clojure.set/difference (set (keys m2)) keys12)\n            vals12 (map #(f (m1 %) (m2 %)) keys12)\n            vals1 (map #(m1 %) keys1)\n            vals2 (map #(m2 %) keys2)]\n        (merge \n          (zipmap keys12 vals12)\n          (zipmap keys1 vals1)\n          (zipmap keys2 vals2))))\n    ms))","user":"5f5358b7e4b0a0bc16850a77"},{"problem":69,"code":"(fn [f & args]\n  (reduce #(merge %1\n                  (into {}\n                        (for [[k v] %2] [k (if (get %1 k) (f (get %1 k) v) v)]))) args))","user":"57147cd9e4b07c98581c3abf"},{"problem":69,"code":";; assoc version\n(fn [f & ms]\n  (reduce (fn [m [k v]]\n            (if (contains? m k)\n              (assoc m k (f (get m k) v))\n              (assoc m k v)))\n          {}\n          (apply concat ms)))\n;; update version\n;(fn [f & ms]\n;  (reduce (fn [m [k v]]\n;            (if (contains? m k)\n;              (update m k (partial f v))\n;              (assoc m k v)))\n;          {}\n;          (apply concat ms)))","user":"60794173e4b0a637ed78035d"},{"code":"(fn [f & maps]\n   (reduce\n    (fn [merged-map next-map]\n      (reduce\n       (fn [the-map [k v]]\n         (if (contains? the-map k)\n           (assoc the-map k (f (get the-map k) v))\n           (assoc the-map k v)))\n       merged-map\n       next-map))\n    (first maps)\n    (rest maps)))","problem":69,"user":"5014754de4b094324338f8e5"},{"code":"(fn [f init & [m & maps]]\n    (if m\n      (recur f\n             (merge m (into {}\n                            (for [[k v] init]\n                              (if (m k) \n                                [k (f v (m k))]\n                                [k v])\n                              )))\n             maps\n              )\n      init))","problem":69,"user":"53440c0ae4b084c2834f4a25"},{"code":"(fn [f & m]\n  (loop [z (first m)\n         m (next m)]\n    (if m\n      (let [[n & r] m\n            w (map (fn [[k v]] \n                      (if (z k) \n                        [k (f (z k) v)]\n                        [k v])) n)]                \n        (recur (merge z\n                 (apply hash-map (reduce concat w))) \n          r))\n      z)))","problem":69,"user":"4e6a4038535d8ccf87e9feb5"},{"problem":69,"code":"(fn [func & a]\n  (let [b (some identity a)] \n    (loop [r (apply conj a)\n           s (rest a)]\n      (let [p (first s)\n            k (first (keys p))\n            v (first (vals p))]\n        \n        (if (> (count s) 0)\n              (recur (assoc r k (func (get b k) (get p k))) (rest s))\n              (zipmap (keys r) (vals r)))))))","user":"53a5c7ffe4b0ef122a8689c4"},{"code":"(fn [f & maps]\n    (loop [maps maps\n           merged {}]\n      (if (empty? maps)\n        merged\n        (recur (rest maps)\n               (loop [m (first maps)\n                      merged2 merged]\n                 (if (empty? m)\n                   merged2\n                   (recur (rest m)\n                          (let [entry (first m)\n                                k (key entry)\n                                v (val entry)]\n                            (assoc\n                                merged2\n                                k\n                                (if (contains? merged2 k)\n                                  (f (merged2 k) v)\n                                  v))))))))))","problem":69,"user":"4f5cc3b8e4b0030a34fb2b2b"},{"code":"(fn [f map1 & map-list]\n      (loop [result map1 current-map (first map-list) maps (rest map-list)]\n        (print result current-map maps \"\\n\")\n        (cond\n         ;; CASE Currently processing a map\n         (seq current-map)\n         ;; If the key is in the result map\n         (if (contains? result (first (first current-map)))\n           (recur (update-in result\n                             (vector (first (first current-map)))\n                             f\n                             (second (first current-map)))\n                  (rest current-map)\n                  maps)\n            ;; else just add it\n           (recur (conj result (first current-map))\n                  (rest current-map)\n                  maps))\n         ;; No more entries in current map\n         ;; CASE Done processing a map\n         (seq maps)\n         (recur result (first maps) (rest maps))\n         :else ;; all done!\n         result)))","problem":69,"user":"53838742e4b06839e8705ee0"},{"code":"(fn [f m & c] \n  (reduce (fn[a b] (into a (map (fn[[k v]] {k (if (nil? (m k)) v (f (m k) v))}) b))) m c))","problem":69,"user":"5093ca51e4b097f48cc38585"},{"problem":69,"code":"(fn [f & m] \n  (reduce \n   #(into % \n          (map (fn [[k v]] [k (if (% k) (f (% k) v) v)]) \n               %2)) \n   m))","user":"53b15e6ee4b047364c04448f"},{"problem":69,"code":"(fn [f & maps]\n  (reduce\n    (fn [m [k v]]\n      (assoc m k (if (> (count v) 1) (apply f v) (get v 0))))\n    {}\n    (reduce\n      #(reduce-kv\n        (fn [m k v]\n          (assoc m k (conj (vec (m k)) v)))\n        %1\n        %2)\n      {}\n      maps)))","user":"5481be5fe4b0e286459a1172"},{"problem":69,"code":"(fn [f & xss]\n  (let [ks (keys (apply merge xss))]\n    (reduce\n      (fn [a k]\n        (let [vs (keep #(get % k) xss)]\n          (assoc a k (if (= 1 (count vs)) (first vs) (apply f vs)))))\n      {}\n      ks)))","user":"507e68abe4b085af06e3afd2"},{"code":"(fn [f m & more]\n  (letfn [(combine [m1 m2]\n            (reduce\n             (fn [acc [k v]]\n               (if (contains? acc k)\n                 (assoc acc k (f (get acc k) v))\n                 (assoc acc k v)))\n             m1\n             m2))]\n    (reduce combine m more)))","problem":69,"user":"500ff421e4b0ae202717946f"},{"problem":69,"code":"(fn merge-with* [f & [h & t]] \n  ( letfn [(r [a [k v]] (conj a (if-let [y (get a k)] [k (f y v)] [k v])))] \n    (reduce #(reduce r %1 %2) h t)))","user":"55645592e4b0c656e3ff1802"},{"code":"(fn [f m & maplist]\n    (loop [m m maplist maplist]\n\t     (if (empty? maplist)\n\t\t m\n\t\t (let [nxtm (first maplist)\n\t\t       ky (keys nxtm)]\n\t\t  (recur (reduce #(assoc %1 %2 (let [newval (nxtm %2)] (if-let [oldval (get %1 %2)] (f oldval newval) newval))) m ky) \n\t\t         (rest maplist))))))","problem":69,"user":"4e6e3a1e535d5021c1a89602"},{"code":"(fn [f & m]\n  (into {}\n    (for [k (set (mapcat keys m)) \n      :let [v (filter identity (map #(% k) m))]]\n        [k (if (> (count v) 1) (apply f v) (last v))])))","problem":69,"user":"4ede361a535d10e5ff6f5332"},{"code":"(fn [f & ms]\n  (reduce (fn [m1 m2] (into m1 (for [[k v] m2]\n                                 (if (contains? m1 k)\n                                   [k (f (m1 k) v)]\n                                   [k v]))))\n          ms))","problem":69,"user":"52a1acb2e4b04e0c58e87bdb"},{"code":"(fn f [op & maps]\n    (reduce \n        (fn [a b]\n            (reduce \n                (fn [m [k v]]\n                    (if-let [v2 (m k)]  ;if m contain a pair with key k    \n                        (assoc m k (op v2 v))\n                        (assoc m k v)\n                    )\n                ) a b\n            ) \n        ) maps\n     )\n)","problem":69,"user":"51d1111ce4b067c36548635f"},{"code":"(fn aa [x yy & args]\n  (loop [zz args y yy]\n \t\t(if (empty? zz) y\n              \n            (recur (rest zz)      \n                       \n           (reduce #(if (%1 (first %2)) (assoc %1 (first %2) (x (%1 (first %2)) (last %2)))\n                      (assoc %1 (first %2) (last %2))\n                      ) y (first zz)\n                   )\n                   )\n          )\n    )\n  )","problem":69,"user":"5105ed16e4b01150e115ebe2"},{"code":"#(into {}\n        (map (fn [[k a]] [k (reduce % (map second a))])\n             (group-by first (mapcat seq %&))))","problem":69,"user":"4ff67852e4b0678c553fc37e"},{"code":"(fn [f & ms] \n      (let [ks (set (flatten (map keys ms)))] \n        (zipmap ks\n                (for [k ks]\n                  (let [v (remove nil? (map #(get % k) ms))]\n                  (if (next v) (apply f v) (first v)))))))","problem":69,"user":"4fe15ffee4b0dd6cd5ce3634"},{"problem":69,"code":"(fn mergew [func startmap & maps] \n  (apply conj startmap (for [m maps\n        item m\n    :let [y (if-not (contains? startmap (first item)) item (vector (first item) (func (get startmap (first item)) (second item))))]\n        ]\n    y)\n  ))","user":"5f309144e4b0574c87022c23"},{"code":"(fn [f & m]\n  (reduce\n    #(apply merge %\n       (for [[k v] %2]\n         [k (if (% k) (f (% k) v) v)]))\n    m))","problem":69,"user":"5336a339e4b0e30313ee6c7d"},{"code":"(fn [f m & es] \n  (reduce \n   (fn m1 [c e] \n     (reduce #(let [[k v] %2 o (%1 k)] (assoc %1 k (if o (f o v) v)))\n             c e))\n    m es))","problem":69,"user":"528e64b7e4b0239c8a67aedd"},{"problem":69,"code":"(fn [f & x] (reduce \n  (fn [m v]\n  (let [k (first v) w (last v)]\n    (if (m k)\n      (assoc m k (f (m k) w))\n      (assoc m k w)))) {} (apply concat x)))","user":"54d75e4ce4b0a52adc2e202a"},{"code":"(fn fun [f & args]\n  (reduce (fn [x1 y1]\n            (let [kx (set (keys x1))]\n\n              (merge x1 \n                     (zipmap (keys y1)\n                             (map (fn [[k v]]\n                                    (if (get kx  k) \n                                      (f (x1 k) v ) \n                                      v)) y1 ))))) {} args ))","problem":69,"user":"5349da55e4b084c2834f4a68"},{"problem":69,"code":"(fn mw\n      ([f h1 h2]\n       (reduce\n        (fn [h [k v]]\n          (let [ev (get h k)\n                v (if (nil? ev)\n                    v\n                    (f ev v))]\n            (assoc h k v))) h1 h2))\n      ([f h1 h2 & r]\n       (let [h (mw f h1 h2)]\n         (if (empty? r)\n           h\n           (apply mw\n                  (concat [f h] r))))\n       ))","user":"50a3ad0ee4b0ceace084d493"},{"problem":69,"code":"(fn [f & ms]\n  (reduce (fn [o m] \n            (reduce #(if (contains? % (key %2))\n                       (assoc % (key %2) (f (% (key %2)) (val %2)))\n                       (conj % %2)) o m))\n          {} ms))","user":"5504dd64e4b086ebe8a79c83"},{"code":"(fn [f & m]\n  (apply merge\n         (map\n          (fn [h]\n            {(ffirst (filter (complement nil?) (map keys h)))\n            (reduce f\n                   (filter\n                    (complement nil?)\n                    (map (comp first vals) h)))})\n          (map\n           (fn [k]\n             (map\n              #(select-keys % [k]) m))\n           (set (mapcat keys m))))))","problem":69,"user":"51170b49e4b0063b4e3e16d9"},{"problem":69,"code":"(fn [f & m]\n  (loop [f1 f m1 m rm {}]\n    (if (empty? m1)\n      rm\n      (recur f (rest m1)\n         (reduce #(if (% (key %2))\n           (assoc % (key %2) (f (% (key %2))(val %2)))\n           (assoc % (key %2) (val %2)))\n                 rm (first m1))))))","user":"566d71b1e4b0a866af6896ca"},{"problem":69,"code":"(fn [op & args]\n\n       (let [coll (apply concat args)\n             k (into [] (distinct (keys coll)))\n            \n             t (map (fn [k] (map #(% 1) (filterv #(= k (% 0)) coll))) k)\n             t2 (map (fn [t] (if-not (= (count t) 1) (apply op t) (first t))) t)\n             v (map (fn [t2] (if-not (coll? t2) t2 (vec t2))) t2)]\n            \n             (into {} (map #(assoc {} %1 %2) k v))))","user":"51316a63e4b0431ba07e7feb"},{"code":"(fn merge-f [f smap & maps]\n  (reduce (fn [m1 m2] \n            (reduce (fn [acc entry]\n                       (let [[k v] entry]\n                        (if (contains? acc k)\n     \t                    (assoc acc k (f (get acc k) v))\n       \t                    (assoc acc k v))))\n\n               m1 m2))\n    smap maps))","problem":69,"user":"502a5fa4e4b09e8f859a9fbd"},{"problem":69,"code":"(fn my-merge-with\n  [op a & b]\n  (let [kv (mapcat seq b)]\n    (reduce (fn [a x]\n              (if (contains? a (first x))\n                (update-in a [(first x)] op (second x))\n                (assoc a (first x) (second x))))\n            a kv)))","user":"569dd6e8e4b0542e1f8d1480"},{"problem":69,"code":"(fn merge-w [f m & maps]\n(let [merged-maps (apply merge maps)\nf-k (fn [k] (if (contains? m k) (f (m k) (merged-maps k)) (merged-maps k)))\nfun (fn [k] (assoc {} k (f-k k)))]\n(->> (keys merged-maps)\n(map fun)\n(apply merge))\n))","user":"5e13a6b7e4b099d064963001"},{"problem":69,"code":"(fn [plus & maps] (into {} (map (fn [[k [v1 & vs]]] [k (reduce plus (second v1) (map #(second %) vs))]) (group-by #(first %) (apply concat (map seq maps))))))","user":"57915ba4e4b0ebec4cfb75ba"},{"problem":69,"code":"(fn [f & maps]\n  (letfn [(mergef [r m] \n                  (reduce (fn [r [k v]] \n                            (if (contains? r k) \n                              (assoc r k (f (r k) v)) \n                              (assoc r k v))) \n                          r m))]\n    (reduce mergef {} maps)))","user":"5e2549c8e4b05b4b0151615f"},{"code":"(fn mwith [f & ms]\r\n  (let [ks (set (apply concat (map keys ms)))]\r\n    (into {} (for [k ks]\r\n               [k (reduce f (for [m ms [k1 v] m :when (= k k1)]\r\n                              v))]))))","problem":69,"user":"4dfd4ba8535d04ed9115e781"},{"problem":69,"code":"(fn mw \n  ([f m1 m2]\n    (loop [m1res m1 m2res m2]\n      (if-not (seq m2res)\n        m1res\n        (let [k2 (first (keys m2res))\n              v2 (get m2 k2)\n              v1 (get m1 k2)\n              v1-res (if (nil? v1) v2 (f v1 v2))]\n          (recur (assoc m1res k2 v1-res)\n                 (dissoc m2res k2))))))\n  ([f m1 m2 & ms]\n    (apply mw f (mw f m1 m2) ms)))","user":"53286f84e4b09d4e7a9b5505"},{"code":"(fn merge-with-\n  ^{:doc \"69. Write a function which takes a function f and a variable number of maps.\"}\n  ([f] {})\n  ([f m1] m1)\n  ([f m1 m2] (conj m2 m1 (apply hash-map (mapcat (fn [k1] (if-let [v2 (get m2 k1)] [k1 (f (get m1 k1) v2)])) (keys m1)))))\n  ([f m1 m2 & ms] (apply merge-with- f (merge-with- f m1 m2) ms)))","problem":69,"user":"4e5eb843535d8a8b8723a2d4"},{"problem":69,"code":"(fn [f & maps]\n    (reduce (fn [result m]\n              (reduce (fn [m1 [k v]]\n                        (assoc m1 k (if (m1 k) (f (m1 k) v) v)))\n                      result m))\n            maps))","user":"538ca203e4b0b51d73faae5f"},{"code":"(fn [f & maps]\r\n  (reduce \r\n    (fn [tm m] \r\n      (reduce (fn [tm k] \r\n                (if (nil? (get tm k)) \r\n                  (assoc tm k (get m k))\r\n                  (assoc tm k (f (get tm k) (get m k)))\r\n                  )) tm (keys m))\r\n              )\r\n    {} maps\r\n    ))","problem":69,"user":"4f0da4e4535d0136e6c22319"},{"problem":69,"code":"(fn [a & b]\n  (reduce\n    (fn [m [k v]] (update-in m [k] #(if (nil? %) v (a % v))))\n    {}\n    (mapcat seq b)))","user":"5b0bd9cfe4b0cc2b61a3bdd9"},{"problem":69,"code":"(fn [f & lm] \n  (reduce (fn [result s]\n            (if (get result (s 0))\n              (update-in result [(s 0)] f (s 1))\n              (conj result s))) {} (reduce #(concat %1 %2) {} lm)))","user":"5471f0f3e4b094393f72dd6f"},{"code":"(fn [f m & ms] \n  (reduce\n    (fn [result m]\n      (reduce \n        (fn [result [key value]]\n          (let [ prev (result key)]\n            (assoc result key \n                  (if prev (f prev value) value))))\n         result m))\n        m ms))","problem":69,"user":"4e6dc95a535d5021c1a895f1"},{"problem":69,"code":"(fn [f & maps]\n  (reduce\n   (fn [result newmap]\n     (reduce\n      (fn [result [key val]]\n        (if-let [initial-value (result key)]\n          (assoc result key (f initial-value val))\n          (assoc result key val)))\n      result\n      newmap))\n   {}\n   maps))","user":"504e108ce4b078edc5f593b3"},{"code":"(fn [f & more]\r\n    (reduce \r\n     (fn mw[a b]\r\n       (loop [[k & ks] (keys b)\r\n              res a]\r\n         (if (not k)\r\n           res\r\n           (recur ks\r\n                  (if (contains? res k)\r\n                    (assoc res k (f (res k) (b k)))\r\n                    (assoc res k (b k))))\r\n           )\r\n         )\r\n       ) more))","problem":69,"user":"4febb4dae4b0681fd128dc98"},{"problem":69,"code":"(fn [op & maps]  \n  (reduce \n   (partial \n    (fn my-merge-with [merged map1 map2]\n      (println (map1 map2))\n      (let [map1Keys (keys map1)] \n        (if (empty? map1Keys) \n          (conj merged map2) \n          (let [fkey (first map1Keys) ]            \n            (if (contains? map2 fkey)        \n              (recur (conj merged {fkey (op (get map1 fkey) (get map2 fkey))}) (dissoc map1 fkey) (dissoc map2 fkey))\n              (recur (conj merged {fkey (get map1 fkey)}) (dissoc map1 fkey) map2)\n            )\n          ) \n        )\n      )\n\t) {}\n   )\n   maps\n  ) \n)","user":"57011eb3e4b08d47c97781d1"},{"problem":69,"code":"(fn mg\n[f & dicts]\n(reduce (fn onestep [dict1 dict2]\n    (reduce (fn mg2 [x ky] \n        (if (contains? x ky) \n       (update-in x [ky] #(f % (dict2 ky)))\n       (merge x {ky (dict2 ky)})\n      ))\n        dict1 \n        (keys dict2)\n      )) dicts))","user":"53d6b266e4b0e771c3025459"},{"problem":69,"code":"(fn [f & args]\n      (->> args\n           (mapcat seq)\n           (group-by first)\n           (reduce-kv (fn [acc k v]\n                        (if (> (count v) 1)\n                          (assoc acc k (apply f (map second v)))\n                          (assoc acc k (second (first v))))) {})))","user":"56c60b36e4b05cc29241eead"},{"problem":69,"code":"(fn [f & colls]\n  (let [update-kv (fn [m k v] \n                    (if (contains? m k) \n                      (assoc m k (f (m k) v))\n                      (assoc m k v)))]\n        \n  (reduce #(reduce-kv update-kv % %2) {} colls)))","user":"5cb41c40e4b026601754b911"},{"code":"(letfn [(merge-two [f m1 m2]                                                                                                                \r\n            (reduce (fn [t [k v]]                                                                                                              \r\n                      (assoc t k (if (contains? t k)                                                                                          \r\n                                   (f (get t k) v)                                                                                            \r\n                                   v)))                                                                                                       \r\n                    m1 m2))]                                                                                                                  \r\n    (fn my-merge-with [f & maps]                                                                                                               \r\n      (reduce (partial merge-two f) maps)))","problem":69,"user":"4f149e0f535d64f60314643d"},{"problem":69,"code":"(fn [f & s]\n  (reduce (fn [m e]\n            (merge m (reduce (fn [updated [key val]]\n                               (assoc updated key\n                                      (if (contains? m key)\n                                        (f (get m key) val)\n                                        val))) {} e))) {} s))","user":"5ea6fe98e4b00a66d4a951b2"},{"code":"(fn [mf & maps] \n\t(reduce (fn [m1 m2] \n              (reduce (fn [m [k v]] \n                        (assoc m k (if (contains? m k) \n                                        (mf (m k) v) \n                                        v))) \n                      m1 m2)) \n            maps))","problem":69,"user":"53720c5ce4b0493c815db704"},{"problem":69,"code":"(fn merge-with-f [f & maps]\n  (letfn [(merge-maps [m1 m2]\n    (if (empty? m2)\n      m1\n      (let [k (key (first m2)),\n            v (val (first m2)),\n            new-v (if (contains? m1 k) (f (m1 k) v) v)]\n        (recur (assoc m1 k new-v) (dissoc m2 k))\n      )))]\n    (reduce merge-maps maps)\n))","user":"587a3babe4b01531a375eae2"},{"problem":69,"code":"(fn merge-maps [f & maps]\n  (let [merge-map (fn [a b]\n                    (reduce\n                      (fn [a [k v]]\n                        (if (contains? a k)\n                          (assoc a k (f (get a k) v))\n                          (assoc a k v)))\n                      a\n                      b))]\n    (reduce merge-map maps)))","user":"4fe49706e4b0e8f79898feb7"},{"problem":69,"code":"(fn [f m & ms]\n  (reduce (fn [a e]\n            (loop [kvs (seq e)\n                   m' a]\n              (if (empty? kvs)\n                m'\n                (recur (rest kvs)\n                       (if (contains? m' (ffirst kvs))\n                         (assoc m'\n                           (ffirst kvs)\n                           (f (m' (ffirst kvs))\n                              (-> kvs first second)))\n                         (conj m' (first kvs)))))))\n            m\n            ms))","user":"57aa4775e4b0b8559636fc6b"},{"problem":69,"code":"(fn merge-with-function [f & maps]\n  (reduce (fn [result-map current-map]\n            (reduce\n              (fn [map [key value]] (update-in map [key] #(if (contains? map key) (f %1 %2) value) value))\n              result-map current-map\n              )\n            ) {} maps)\n  )","user":"5aada061e4b073f17744257a"},{"code":"(fn merge-maps [f & maps]\n  (reduce (fn [one two]\n    (if (= {} two) one\n      (let [k (key (first two))\n            v1 (get one k)\n            v2 (get two k)]\n        (if (and v1 v2) (recur (assoc one k (f v1 v2))\n                               (dissoc two k))\n          (recur (assoc one k v2) (dissoc two k)))))) maps))","problem":69,"user":"502f4c89e4b0842eb223d8b9"},{"code":"(fn [f & ms]\n  (reduce \n    (fn [result m] \n      (merge result\n             (into {}\n               (for [[k v] m]\n                 (if-let [ov (get result k)]\n                   [k (f ov v)]\n                   [k v]))))) ms))","problem":69,"user":"4f45c72be4b0d56e7bb92b8a"},{"problem":69,"code":"(fn mymerge-with [f & maps]\n  (into {} (map (fn [k]\n                  (let [allvals (keep #(% k) maps) multipleVals? (> (count allvals) 1)]\n                    [k (if multipleVals? (apply f allvals) (first allvals))])) \n                (mapcat keys maps))))","user":"60606490e4b03746e80ebf67"},{"problem":69,"code":"(fn [f & maps]\n  (let [ks (into #{} (mapcat keys maps))\n        vs (group-by (fn [k] (remove nil? (map #(% k) maps))) ks)]      \n    (reduce #(conj %1 (if (= 1 (-> %2 first count))\n                        [(-> %2 second first) (ffirst %2)]\n                        [(-> %2 second first) (apply f (first %2))])) {} vs)))","user":"53c649d3e4b00fb29b221297"},{"problem":69,"code":"(fn [func & args]\n  (loop [ans (first args) maps (rest args) currmap (first (rest args))]\n    (if (empty? maps)\n      ans\n      (if (empty? currmap)\n        (recur ans (rest maps) (first (rest maps)))\n        (if (contains? ans (first (first currmap)))\n          (recur (assoc ans (first (first currmap)) (func (get ans (first (first currmap))) (second (first currmap)))) maps (rest currmap))\n          (recur (assoc ans (first (first currmap)) (second (first currmap))) maps (rest currmap)))))))","user":"59368ccae4b02506e01a2979"},{"problem":69,"code":"(fn [func & map-list]\n  (let [to-entries (fn [maps] (apply concat (map seq maps)))\n        merge-entry-with-some-f (fn [f m e]\n                             (let [ek (key e)\n                                   ev (val e)\n                                   mkv (get m ek)]\n                               (assoc m ek (if mkv\n                                             (f mkv ev)\n                                             ev))))\n        merge-entry-with-this-f (partial merge-entry-with-some-f func)\n        ]\n    (reduce merge-entry-with-this-f {} (to-entries map-list))\n    )\n  )","user":"5535e822e4b09218d5f44fb2"},{"problem":69,"code":"(fn [f & args] \n  (->> (map seq args)\n      (apply concat)\n      (group-by #(identity (first %)))\n      (seq)\n      (map (fn [[a b]] \n             [a (reduce f (map second b))]))\n      (into {})))","user":"50be9b4ae4b00fb48fed2ef6"},{"problem":69,"code":"(fn [f & args]\n  (into {} (map (fn [[v k]] [v (reduce f (map second k))] ) (group-by first (mapcat seq args)))))","user":"581a5fdbe4b0e114eb51a002"},{"problem":69,"code":"; (fn [f & maps]\n;   (let [inner-reduce (fn [result k v]\n;                        (if (contains? result k)\n;                          (update result k f v)\n;                          (assoc result k v)))\n;         outer-reduce (fn [result map] (reduce-kv inner-reduce result map))]\n;     (reduce outer-reduce {} maps)))\n\n(fn [f & maps]\n  (let [inner-reduce (fn [result k v]\n                       (let [new-val (if (contains? result k)\n                                       (f (get result k) v)\n                                       v)]\n                         (assoc result k new-val)))\n        outer-reduce (fn [result m] (reduce-kv inner-reduce result m))]\n    (reduce outer-reduce {} maps)))","user":"5b4fef74e4b02d533a91bcde"},{"problem":69,"code":"(fn my-merge [f & ms]\n  (reduce (fn [m1 m2] \n            (reduce (fn [m [k v]]\n                      (assoc m k (if (m k) \n                                   (f (m k) v) \n                                   v)))\n                    m1 m2))\n          (first ms) \n          (rest ms)))","user":"5c58736be4b01df32ab73247"},{"problem":69,"code":"(fn [f & maps](reduce (fn[upper-result _map]\n\t\t\t(reduce (fn[result [key val]]\n\t\t\t\t(conj result {key (if (nil? (get result key))\n                      val\n                      (f (result key) val))})) upper-result _map)) {} maps))","user":"5954eef0e4b066ee0a44af17"},{"code":"(fn m-with [f & ms]\n  (letfn [(m-entry [m [k v]]\n                  (if (contains? m k)\n                    (assoc m k (f (m k) v))\n                    (assoc m k v)))\n          (m-hash [m1 m2]\n                  (reduce m-entry m1 (seq m2)))]\n      (reduce m-hash ms)))","problem":69,"user":"52d00832e4b07d0d72b273b4"},{"code":"(fn [f & ms]\r\n    (letfn [(app [f a] (if (= 1 (count a)) (first a) (apply f a)))]\r\n      (reduce\r\n       (fn [acc k]\r\n         (assoc\r\n             acc\r\n           k\r\n           (app f\r\n                  (filter (comp not nil?) (map #(get % k) ms)))))\r\n       {}\r\n       (set (mapcat keys ms)))))","problem":69,"user":"50427899e4b0add3005c0fc2"},{"code":"#(letfn [(merge-item\n            [mp [a b]]          \n              (if (contains? mp a)\n                (merge mp {a (->(get mp a)(% b))})\n                (conj mp [a b])))\n          (merge-maps [m1 m2]\n                      (loop [c1 m1 c2 m2]\n                        (if (empty? c2) c1\n                              (recur (merge-item c1 (first c2)) (rest c2)))) )]\n    (reduce merge-maps %&))","problem":69,"user":"530cb5b8e4b02e82168697e0"},{"code":"(fn [f & ms]\n  (reduce\n   \t#(let [k2 (key %2) v2 (val %2)]\n      (conj\n        %\n        (vector\n          k2\n          (if-let [v (get % k2)]\n            (f v v2)\n            v2))))\n   \t{}\n   \t(mapcat #(into [] %) ms)))","problem":69,"user":"4f253a49e4b0d66497709ff3"},{"problem":69,"code":"(fn [f m & args] (reduce\n           (fn [a b] (let [keys (keys b)] (reduce #(if (nil? (% %2)) (assoc % %2 (b %2)) (assoc % %2 (f (% %2)(b %2)))) a keys)))\n           m args))","user":"565b2fa5e4b068f2fe63dbfe"},{"code":"(fn [f & maps]\n  (let [merge-entry (fn [m e]\n    (let [k (key e) v (val e)]\n      (if (contains? m k)\n        (assoc m k (f (m k) v))\n        (assoc m k v))))\n        merge2 (fn [m1 m2]\n          (reduce merge-entry m1 (seq m2)))]\n   (reduce merge2 maps)))","problem":69,"user":"5007f751e4b0b17c647f522b"},{"code":"(fn merge-with-f [f m1 & mc2]\n  (reduce (fn compare-and-conj [m1 m2]\n  \t\t\t(conj m1 ((fn on-all-m2 [f m1 m2]\n  \t\t\t\t\t\t(->> (map #(vector (first %) ((fn check-f [f m1 [k v]]\n  (let [v1 (m1 k)]\n    (if v1\n      (f v1 v)\n      v))) f m1 %)) m2)\n       \t\t\t\t\t(into {})))\n                      f m1 m2))) m1 mc2))","problem":69,"user":"52b35a6ee4b0c58976d9ad07"},{"problem":69,"code":"(fn meh [f m & rm]\n  (reduce\n    (fn [m m2]\n      (let [kdiff (clojure.set/difference (set (keys m2)) (set (keys m)))\n            cks   (clojure.set/intersection (set (keys m2)) (set (keys m)))]\n        (merge\n          (reduce\n            #(update-in % [%2] f (m2 %2)) m cks)\n          (select-keys m2 kdiff)))) m rm))","user":"54f4adc8e4b0f2f3c5226e86"},{"code":"(fn mw\n  ([f m n]\n    (loop [ks (keys n) acc m]\n      (if (empty? ks)\n        acc\n        (let [fk (first ks) rk (rest ks)]\n          (if (nil? (acc fk))\n            (recur rk (conj acc {fk (n fk)}))\n            (recur rk (conj acc {fk (f (acc fk) (n fk))})))))))\n  ([f m n & ns]\n    (apply mw f (mw f m n) ns)))","problem":69,"user":"4e6a2f51535d8ccf87e9fea9"},{"code":"(fn [f m1 & ms]\r\n  (let [f-u (fn [m [k v]] \r\n                (let [s (get m k)\r\n                      r (if s (f s v) v)]\r\n                  (assoc m k r)))]\r\n      (reduce #(reduce f-u %1 %2) m1 ms)))","problem":69,"user":"4def301c535d08e6dec9fe12"},{"problem":69,"code":"(fn [f & maps]\n    (reduce\n      (fn [map1 map2]\n        (into map1\n          (for [[k2 v2] map2]\n            (let [v1      (map1 k2)\n                  new-val (if (nil? v1)\n                            v2\n                            (f v1 v2))]\n              {k2 new-val}))))\n      {} maps))","user":"532f7e12e4b019098a6f8b4e"},{"problem":69,"code":"(fn [f & ms]\n    (reduce (fn [r m]\n              (reduce (fn [r k] \n                        (assoc r k (let [e (r k)\n                                         n (m k)]\n                                     (if (nil? e)\n                                       n\n                                       (f e n)\n                                       ))))\n                      r\n                      (keys m)))\n            {}\n            ms))","user":"554a75c9e4b0a04f79299575"},{"code":"(fn [f x & ys]\n   (reduce (fn [a [k v]] (assoc a k (if (contains? a k) (f (a k) v) v))) x (into {} ys)))","problem":69,"user":"50996a38e4b0cae2931060b3"},{"code":"(fn [f & m] \n  (reduce\n    (partial reduce \n        #(conj %1\n          (let [k (first %2)]\n          (if (contains? %1 k)\n              [k (f (get %1 k) (last %2))]\n              %2))))\n    m))","problem":69,"user":"5034b0e1e4b062bc5d7ae167"},{"problem":69,"code":"(fn m [f & [h & t]] \n  (reduce \n   (fn [acc [k v]] \n     (assoc acc k (if-let [p (acc k)](f p v) v))) \n   h (mapcat seq t)))","user":"57e33f6fe4b0bfb2137f5a96"},{"problem":69,"code":"(fn [f m1 & ms]\n  (reduce\n   (fn [m o]\n     (reduce\n      (fn [r [k v]]\n        (if (contains? r k)\n          (update-in r [k] f v)\n          (assoc r k v)))\n      m\n      (seq o)))\n   m1\n   ms))","user":"53c1b787e4b00fb29b221266"},{"code":"(fn [f & maps]\r\n  (loop [maps-left maps, result {}]\r\n\t\t(if-let [[m & ms] (seq maps-left)]\r\n\t\t\t(recur\r\n\t\t\t\tms\r\n\t\t\t\t(reduce\r\n\t\t\t\t\t(fn [m [k v2]]\r\n\t\t\t\t\t\t(if-let [v1 (get m k)]\r\n\t\t\t\t\t\t\t(assoc m k (f v1 v2))\r\n\t\t\t\t\t\t\t(assoc m k v2)))\r\n\t\t\t\t\tresult\r\n\t\t\t\t\t(seq m)))\r\n\t\t\tresult)))","problem":69,"user":"4dd6d6a0535d2dad7130b5ca"},{"problem":69,"code":"(fn [f & maps]\n  (reduce (fn [acc m]\n            (reduce-kv (fn [acc k v]\n                         (assoc acc k (if-let [acc-v (get acc k)]\n                                        (f acc-v v)\n                                        v)))\n                       acc\n                       m))\n          maps))","user":"5424c523e4b01498b1a71b03"},{"code":"(fn [f & ms]\n  (let [all-together (mapcat seq ms)\n        remapped (group-by first all-together)]\n    (reduce (fn [m [k vals]]\n              (let [vals (map second vals)]\n                (assoc m k (if (< 1 (count vals))\n                             (apply f vals)\n                             (apply identity vals)))))\n            {} remapped)))","problem":69,"user":"4e80aa10535db62dc21a62b1"},{"problem":69,"code":"(fn g [f & xs]\n    (->> (apply concat xs)\n         (group-by first)\n         (map (fn [[k v]] [k (reduce f (map second v))]))\n         (into {})))","user":"56795deae4b05957ce8c6187"},{"problem":69,"code":"(fn my-merge-with\n  [fun & maps]\n  (reduce\n   (fn [map1 map2]\n     (merge map1\n      (into {}\n            (map (fn [[key val]]\n                   (if-let [preval (get map1 key)]\n                     [key (fun preval val)]\n                     [key val]))  map2))))\n   maps))","user":"5bf9d9b7e4b0bdcf453d15c4"},{"code":"(fn my-merge-with [f & maps]\n  (loop [maps maps\n         result {}]\n    (cond\n     (empty? result) (recur (rest maps) (conj result (first maps)))\n     :else\n     (loop [_keys (keys (first maps))\n     \t\tmaps maps\n     \t\tresult result]\n     \t(cond\n     \t\t(empty? maps) result\n     \t\t(empty? _keys) (recur (keys (second maps)) (rest maps) result)\n     \t\t(contains? result (first _keys)) \n     \t\t(recur (rest _keys) \n     \t\t\tmaps\n     \t\t\t(assoc result \n     \t\t\t\t(first _keys) \n     \t\t\t\t(f (result (first _keys)) ((first maps) (first _keys)))))\n     \t\t:else\n     \t\t(recur (rest _keys) \n     \t\t\tmaps\n     \t\t\t(assoc result \n     \t\t\t\t(first _keys) ((first maps) (first _keys)))))\n     \t)\n     )\n    )\n  )","problem":69,"user":"521cd8e4e4b0c4ef0be8309f"},{"code":"(fn __ [op m1 & ms]\n    (into {} \n      \t(map (fn [[k v]] [k (reduce op (map (fn [[kk vv]] vv) v))])\n        \t(group-by key (apply (partial concat m1) ms))\n    \t)\n    )\n)","problem":69,"user":"503f872ee4b00d1a725ff2ac"},{"problem":69,"code":"(fn merge-with2 [f & args]\n\t(reduce (fn [map1 map2]\n\t\t\t\t\t\t(reduce (fn [m [k v]]\n\t\t\t\t\t\t\t\t\t\t\t(if-let [vv (m k)]\n\t\t\t\t\t\t\t\t\t\t\t\t(assoc m k (f vv v))\n\t\t\t\t\t\t\t\t\t\t\t\t(assoc m k v)))\n\t\t\t\t\t\t\t\t\t\tmap1 map2))\n\t\t\t\t\targs))","user":"5ca2ca9fe4b048ec896c5b9c"},{"code":"(fn fun [f m & ms]\n  (if (not (seq ms))\n    m\n    (apply fun f\n         (into m (for [[k v] (first ms)] [k (if (contains? m k)\n                              (f (get m k) v)\n                              v)]))\n         (rest ms))))","problem":69,"user":"50232eeae4b0b5d8b1bd2397"},{"problem":69,"code":"(fn [f m & ms]\n   (reduce-kv (fn [acc k v]\n                (if (acc k)\n                  (assoc acc k (f (acc k) v))\n                  (assoc acc k v)))\n              m\n              (apply merge ms)))","user":"5d669613e4b0db5d338d15ea"},{"problem":69,"code":"(fn [func & maps]\n    (reduce (fn [result map]\n              (reduce #(let [key (first %2)]\n                         (assoc %1 key (if (contains? %1 key)\n                                         (func (get %1 key) (last %2))\n                                         (last %2)))) result map))\n            {} maps))","user":"586b6753e4b01531a375e956"},{"problem":69,"code":"(fn [f & ms]\n  (reduce \n   (fn [a b]\n     (reduce (fn [m [k v]]\n               (if (contains? m k)\n                 (assoc m k (f (m k) v))\n                 (assoc m k v)))\n             a b)) ms))","user":"55b1e9e7e4b0da326a65cf74"},{"code":"(fn [f & s]\n  (reduce\n   (fn[r m] (reduce\n             #(let[k (key %2) v (val %2) z (% k)]\n                (assoc % k (if z (f z v) v)))\n             r m))\n     (first s) (next s)))","problem":69,"user":"507c7c8be4b0b083f3ff82ef"},{"code":"(fn [f coll & colls]\n  (let [merge-2-colls\n        (fn [coll1 coll2]\n          (reduce (fn [acc [k v]] (let [r (if (contains? acc k) (f (get acc k) v) v)] (assoc acc k r))) coll1 coll2))]\n    (reduce merge-2-colls coll colls)))","problem":69,"user":"51cdd3f0e4b0e42293a2254b"},{"code":"(fn [f & colls]\n  (let [k  (sort (distinct (apply concat (map keys colls))))]\n    (zipmap k\n      (for [v k]\n        (let [final (filter #(not (nil? %)) (map #(get % v) colls))]\n          (if (> (count final) 1)\n            (apply f final)\n            (first final)\n          )\n        )\n      )\n    )\n  ) \n)","problem":69,"user":"52016690e4b0b2e020a18f0f"},{"code":"(fn merge-with' [f & ms]\n  (let [merge-entry (fn [m [k v]]\n                      (if (contains? m k)\n                        (assoc m k (f (m k) v))\n                        (assoc m k v)))\n        merge-map #(reduce merge-entry %1 %2)]\n    (reduce merge-map {} ms)))","problem":69,"user":"50586354e4b06522596eba78"},{"code":"(fn mergess\n    [f & maps]\n\t    (let [merge-entry (fn [m e]\n\t            (let [k (key e) v (val e)]\n\t              (if (contains? m k)\n\t                (assoc m k (f (get m k) v))\n\t                (assoc m k v))))\n\t          merge2 (fn [m1 m2]\n\t           (reduce merge-entry (or m1 {}) (seq m2)))]\n\t      (reduce merge2 maps)))","problem":69,"user":"4f891abde4b033992c121c77"},{"code":"(fn mmerge-with\r\n  ([f lmap mmap]\r\n     (loop [lm lmap mm (seq mmap)]\r\n       (if (nil? (first mm))\r\n   lm\r\n\t (let [k (first (first mm)) v (second (first mm))]\r\n\t   (if (contains? lm k)\r\n\t     (recur (assoc lm k (f (get lm k) v) ) (rest mm))\r\n\t     (recur (assoc lm k v) (rest mm)))))))\r\n  ([f lmap mmap & args]\r\n     (reduce #(mmerge-with f  %1 %2) lmap (conj args mmap))))","problem":69,"user":"4ddc620d535d02782fcbea06"},{"problem":69,"code":"(fn [f & args] \n  (reduce (fn [a b] \n            (into {} \n                  (for [k (into (set (keys a)) (set (keys b)))] \n                    (cond \n                     (not (contains? a k)) [k (b k)]\n                     (not (contains? b k)) [k (a k)]\n                     :else [k (f (a k) (b k))])))) args))","user":"5d3ae729e4b01671435dbd5d"},{"code":"(fn [f & ms] (let [g (fn [m1 m2] \n                       (let [[k v2] (first m2),\n                             v1 (m1 k),\n                             v (if (nil? v1) v2 (f v1 v2))]\n                         (if (empty? m2) m1\n                           (recur (assoc m1 k v) (rest m2)))) )]\n  \t\t   (reduce g ms)))","problem":69,"user":"50563ae2e4b0ce54f56f0405"},{"problem":69,"code":"(fn my-merge-with [f & ms]\n  (reduce (fn [acc item]\n            (reduce (fn [acc2 [k v]]\n                      (if (contains? acc2 k)\n                        (update-in acc2 [k] f v)\n                        (assoc acc2 k v)))\n                    acc\n                    item))\n          ms))","user":"5215661be4b02f6d8ea676c7"},{"problem":69,"code":"(fn [f & ms]\n      (reduce (fn [m [k v]]\n                (assoc m k (if (contains? m k) (f (get m k) v) v)))\n              {}\n              (mapcat (partial into []) ms)))","user":"51e28063e4b08e53a149f0f2"},{"code":"(fn [f & maps]\n  (letfn [(add-apply [m [k v]]\n                     (assoc m k (if-let [p (get m k)] (f p v) v)))\n          (collect-apply [t m]\n                         (reduce add-apply t m))]\n    (reduce collect-apply {} maps)))","problem":69,"user":"537e745ae4b06839e8705ea6"},{"code":"(fn [f m & ms]\n  (reduce\n    (fn [r v] \n      (reduce \n        #(assoc\n           %\n           (first %2)\n           (if (contains? r (first %2)) (f (r (first %2)) (second %2)) (second %2)))\n        r\n        v))\n    m ms))","problem":69,"user":"4f954dbce4b0dcca54ed6ccd"},{"problem":69,"code":"(fn mf2 [func & cols]\n  (let [f (fn [a [k v]]\n            (if (contains? a k)\n              (assoc a k (func (a k) v))\n              (assoc a k v)))]\n    (reduce #(reduce f % %2) cols)))","user":"5475d755e4b0c51c1f4d72a0"},{"problem":69,"code":"(fn merge-with-a-function\n  [f & ms]\n  (reduce (fn [m1 m2]\n            (reduce\n             (fn [acc [k v]]\n               (if-let [acc-v (acc k)]\n                 (assoc acc k (f acc-v v))\n                 (assoc acc k v)))\n             m1\n             m2))\n          ms))","user":"5d5824fae4b02ba5928a681f"},{"problem":69,"code":"(fn g [f i h & t]\n  (let [[k & v] (vec h)]\n    (if (coll? k)\n        (g f (g f i k) (if v `[~@v ~@t] t))\n        (let [y #(apply identity %)]\n          (if k (assoc i k (if (i k) (f (i k) (y v)) (y v))) i)))))","user":"548b7db8e4b0e286459a11fd"},{"problem":69,"code":"(fn\n  ([f] nil)\n  ([f m1] m1)\n  ([f m1 & more]\n   (if (first more)\n     (let [mrg\n          (fn [f m1 m2]\n            (reduce\n              (fn [m kv]\n                (let [[k v2] (if (map? kv) (first kv) kv)\n                      v1 (get m1 k)]\n                  (if v1\n                    (assoc m k (f v1 v2))\n                    (assoc m k v2))))\n              m1 m2))]\n       (recur f (mrg f m1 (first more)) (next more)))\n     m1)))","user":"5cece5a2e4b0a17bb84e2bfb"},{"problem":69,"code":"(fn my-merge-with [f & maps] (reduce (fn merge-maps [map1 map2] (loop [result map1 kvs (seq map2)] (if (empty? kvs) result (let [[k v] (first kvs)] (recur (assoc result k (if-let [v1 (result k)] (f v1 v) v)) (rest kvs)))))) {} maps))","user":"55d95be7e4b0e31453f64ac9"},{"problem":69,"code":"(fn [f & map-seq]\n  (letfn [(merge-withx [a b f]\n            (if-let [[b-k b-v] (first b)]\n              (merge-withx (assoc a b-k (if-let [v (get a b-k)] (f v b-v) b-v)) (dissoc b b-k) f)\n              a))\n          (merge-withxs [mapx map-seq f] \n            (if (seq map-seq)\n              (merge-withxs (merge-withx mapx (first map-seq) f) (rest map-seq) f)\n              mapx))]\n    (merge-withxs (first map-seq) (rest map-seq) f)))","user":"5a9dbb32e4b0d174b936c7f3"},{"problem":69,"code":"(fn [f initial & maps]\n     (reduce (fn [acc [k v]]\n                 (let [ov (get acc k)\n                       nv (if (nil? ov) v (f ov v))]\n                   (assoc acc k nv)))\n             initial\n             (reduce conj maps)))","user":"4f867b25e4b033992c121c51"},{"code":"(fn [f & maps] \n  (into {} \n    (map \n      (fn [[k vals]] \n        [k (reduce f (map second vals))]) \n      (group-by first (apply concat maps)))))","problem":69,"user":"500aa15ee4b03d00572d2d76"},{"problem":69,"code":"(fn [f & ms] \n  (apply hash-map \n         (mapcat (fn [[k v]] [k (reduce #(f %1 %2) (map second v))]) \n                 (group-by first (mapcat vec ms)))))","user":"58c2df0ae4b021aa9917ed17"},{"code":"(fn [op m & ms]\r\n  (if\r\n    (= (count ms) 0) m\r\n    (recur op\r\n      (into m\r\n        (map (fn [[k v]]\r\n                (if (m k)\r\n                  [k (op (m k) v)]\r\n                  [k v]))\r\n          (first ms)))\r\n      (rest ms))))","problem":69,"user":"4ddbfb8a535d02782fcbea00"},{"code":"(fn [f & maps]\n     (let [ks (distinct (flatten (map keys maps)))\n           v (into {} (map (fn [k] \n                             (reduce #(if (%2 k) (assoc %1 k (conj (%1 k) (%2 k))) %1) {} maps)) ks))]\n       (zipmap (keys v) (map #(if (seq (rest %))\n                                (apply f (reverse %))\n                                (first %)) (vals v)))))","problem":69,"user":"4e6a11ee535d8ccf87e9fe9f"},{"problem":69,"code":"(fn [f & args]\n   (loop [acc {} args args]\n     (cond\n       (empty? args) acc\n       :else\n       (recur (apply assoc \n                     (cons acc (mapcat \n                                 (fn [pair] \n                                   (let [k (first pair)\n                                         v (last pair)]\n                                     (if (contains? acc k) (list k (f (acc k) v)) pair))) \n                                 (first args))))\n              (rest args)))))","user":"57780e4fe4b0979f89651657"},{"problem":69,"code":"(fn [f & maps] (reduce (fn [m [k v]] (assoc m k (reduce f (map second v)))) {} (group-by first (apply concat maps))))","user":"53e19461e4b0d874e779ae59"},{"problem":69,"code":"(fn [f & maps]\n  (loop [ans {} ms maps]\n    (if (empty? ms) ans\n      (let [m (first ms)]\n        (recur\n          (loop [ans' ans ks (keys m)]\n\t            (if (empty? ks) ans'\n               (let [key (first ks)]\n\t              (if (contains? ans' key)\n\t                (recur (assoc ans' key (f (ans' key) (m key))) (rest ks)) \n\t                (recur (assoc ans' key (m key)) (rest ks))\n                 )))) \n        (rest ms))))))","user":"555f0789e4b0a2eb076a39bf"},{"problem":69,"code":"(fn [op & maps]\n   (->> (map vec maps)\n        (apply concat)\n        (reduce (fn [m [k v]]\n                  (if (contains? m k)\n                   (update-in m [k] op v)\n                   (into m {k v}))) {})))","user":"5d9e8e40e4b000c986472bc2"},{"code":"(fn merge-with' [f map0 & maps]\n    (if (empty? maps) map0\n      (recur\n        f\n        (loop [map0' map0, map1' (first maps)]\n              (if (empty? map1')\n                map0'\n                (let [[k v] (first map1')]\n                  (recur\n                    (assoc map0' k\n                           (if (find map0 k) (f (map0 k) v) v))\n                    (rest map1')))))\n        (rest maps))))","problem":69,"user":"508157b2e4b0946d0443855c"},{"code":"(fn [f & maps]\n  (reduce (fn [s [k v]]\n    (if-let [oldv (s k)]\n      (assoc s k (f oldv v))\n      (assoc s k v)))\n    {} (apply concat maps)))","problem":69,"user":"4ec2f192535dcc7ae8597d4c"},{"problem":69,"code":"(fn my-merge [f & maps]\n  (let [ks (keys (reduce merge maps))\n        vs (map #(filter identity %) (map (fn [k] (map #(get % k)  maps))  ks))\n      ]\n    (into {}  (map #(if (= 1 (count %2))\n                      [% (first %2)]\n                      [% (reduce f %2)]) ks vs))))","user":"53bf0913e4b0c98a41f5cc99"},{"problem":69,"code":"(fn [f & maps]\n  (letfn [(merge-val [m k v] (if (contains? m k) (f (get m k) v) v))\n          (merge-maps [m1 m2] (reduce (fn [m [k v]] (assoc m k (merge-val m k v))) m1 m2))]\n    (reduce #(merge-maps % %2) (first maps) (rest maps))))","user":"57002b81e4b08d47c97781c7"},{"code":"(fn mw\n  ([f m1 m2] \n    (loop [ks (keys m2) m1 m1] \n      (if (empty? ks) \n        m1 \n        (let [k (first ks) \n              o1 (get m1 k) \n              o2 (get m2 k) \n              n (if o1 (f o1 o2) o2)] \n          (recur (rest ks) (assoc m1 k n))))))\n  ([f m1 m2 & more]\n    (mw f m1 (apply mw f m2 more))))","problem":69,"user":"4f1fd734535d64f6031464a5"},{"problem":69,"code":"(fn my-merge-with [rf & dics]\n  (letfn [(f [dic1 dic2]\n            (loop [ac dic1, rst dic2]\n              (if (empty? rst)\n                ac\n                (let [new-pair (first rst)\n                      other-pairs (rest rst)\n                      collision-val (ac (first new-pair))]\n                  (if (nil? collision-val)\n                    (recur (conj ac new-pair) other-pairs)\n                    (recur \n                     (conj ac [(first new-pair) \n                               (rf collision-val (second new-pair))])\n                     other-pairs))))))]\n        (reduce f {} dics)))","user":"5492164ee4b0b312c081ff3e"},{"problem":69,"code":"; nasty\n(fn [f & maps]\n(loop [map-keys (apply conj #{} (flatten (map keys maps)))\nres {}]\n(if (empty? map-keys)\nres (recur\n(rest map-keys)\n(let [key (first map-keys)\nraw-args (reduce #(conj %1 (get %2 key)) [] maps)\nargs (filter #(not (nil? %)) raw-args)]\n(if (= 1 (count args))\n(assoc res key (first args))\n(assoc res key (apply f args))\n))))))","user":"589b98fae4b00487982d533c"},{"code":"(fn mapmerge [f m & ml]\n\t(reduce (fn [m [k v]]\n\t\t(let [[_ cv :as entry] (find m k)]\n\t\t\t(conj m [k (if entry (f cv v) v)])\n\t\t)\n\t) m (mapcat seq ml))\n)","problem":69,"user":"527ba695e4b03e8d9a4a7596"},{"problem":69,"code":"(fn [f & maps]\r\n  (reduce (fn [state elem]\r\n            (into state (reduce\r\n                         (fn [inner-state [k v]]\r\n                           (let [existing-val (get state k)]\r\n                             (if (not (nil? existing-val))\r\n                               (assoc inner-state k (f existing-val v))\r\n                               (assoc inner-state k v))))\r\n                         {}\r\n                         elem)))\r\n          {}\r\n          maps))","user":"580e7761e4b0849f6811b753"},{"code":"(fn [f & ms] (into {} (map (fn [col] [(first (first col)) (reduce f (map second col))] ) (partition-by first (sort-by first (mapcat #(into [] %) ms )) ))))","problem":69,"user":"4ee7d177535d93acb0a6686f"},{"problem":69,"code":"(fn [f & args]\n  (reduce (fn [out in]\n            (reduce (fn [out [k v]]\n                      (if (contains? out k)\n                        (assoc out k (f (get out k) v))\n                        (assoc out k v)))\n                    out\n                    in))\n          {}\n          args))","user":"55164856e4b06a49daca83b3"},{"problem":69,"code":"(fn my-merge [f mainmap & vmaps]\n  (reduce (fn [s e]\n            (reduce #(assoc %1 %2 (if (contains? s %2)\n                                    (f (s %2) (e %2))\n                                    (e %2)))\n                    s\n                    (keys e)))\n          mainmap\n          vmaps))","user":"54084784e4b0addc1aec66c9"},{"problem":69,"code":"(fn my-merge-with [func & maps]\n  (let [keys (set (mapcat keys maps))]\n    (loop [keyList keys\n           result {}]\n      (if (empty? keyList)\n        result\n        (let [key (first keyList)\n              vals (map #(get % key) maps)\n              filtered-vals (filter #(not (nil? %)) vals)]\n          (recur (rest keyList) (assoc result key (reduce func filtered-vals))))))))","user":"5a621702e4b0512ff01cd983"},{"problem":69,"code":"(fn [f & ms]\n    (loop [ms     ms\n           result {}]\n      (if (seq ms)\n        (recur (rest ms)\n               (reduce-kv (fn [m k v]\n                               (if-let [x (get m k)]\n                                 (assoc m k (f x v))\n                                 (assoc m k v)))\n                             result\n                             (first ms)))\n        result)))","user":"58bcecc9e4b0888cdc949d24"},{"code":"(fn [f m & r] (reduce (fn [h n] (reduce (fn [a [k v]] (assoc a k (if (contains? a k) (f (a k) v) v))) h n)) m r))","problem":69,"user":"4f83665ee4b033992c121c1c"},{"problem":69,"code":"(fn my-merge [func & args]\n  (let [kys (distinct (flatten (map keys args)))\n        data-map (for [k kys]\n                   (assoc {} k (filter #(not (nil? %)) (reduce #(conj % (get %2 k)) [] args))))]\n    (reduce #(conj % %2) {} (for [mps data-map]\n                    (reduce-kv (fn [m k v]\n                                 (assoc m k (if (= 1 (count v))\n                                              (first v)\n                                              (apply func v)))) {} mps)))))","user":"5785c1d4e4b0ebec4cfb74e1"},{"code":"(fn mytest [f m & args]\n  (reduce (fn [acc i]\n            (reduce (fn [m [k v]]\n                      (if (contains? m k)\n                        (update-in m [k] #(f % v))\n                        (assoc m k v))) acc (seq i))) m args))","problem":69,"user":"52aa16d1e4b0c58976d9ac5a"},{"problem":69,"code":"(fn merge-with-fn [f & maps]\n  (let [all-keys (distinct (mapcat keys maps))]\n    (into {}\n      (map (fn [k]\n            [k (reduce f (map #(% k) (filter #(contains? % k)maps)))])\n          all-keys))))","user":"5880e38fe4b0f1effa3b7625"},{"problem":69,"code":"(fn [f & ms]\n         (reduce #(reduce (fn [m [k v]]\n                            (if (contains? m k)\n                              (assoc m k (f (m k) v))\n                              (assoc m k v)))\n                          %1 %2)\n                 {} ms))","user":"53f592b7e4b0db01ade6f9d0"},{"problem":69,"code":"(fn merge-fn [f & maps]\n  (reduce (fn [map1 map2]\n            (reduce (fn [m [k v]]\n                      (if (contains? m k)\n                        (update-in m [k] f v)\n                        (assoc m k v)))\n                    map1 map2))\n          maps))","user":"542c026ae4b0dad94371f29a"},{"problem":69,"code":"(fn my-merge-with\n  [f & maps]\n  (reduce (fn [m1 m2] (reduce (fn [m1 [k v]]\n                                (if (contains? m1 k)\n                                  (update-in m1 [k] f v)\n                                  (assoc m1 k v))) m1 m2))\n          (first maps) (rest maps)))","user":"506f0968e4b09350ab4199f5"},{"code":"#(reduce (fn [a [k v]] (assoc a k (if (a k) (% (a k) v) v))) %2 (apply merge %&))","problem":69,"user":"4ee9ddb8535d93acb0a66896"},{"problem":69,"code":"(fn [f & maps]\n  (reduce\n   (fn [res m]\n     (let [ks (set (mapcat keys [res, m]))\n           hashes \n           (map #(if (and (res %) (m %))\n                   [%  (f (res %) (m %))]\n                   [%  (or (res %) (m %))]) ks)]       \n       (into {} hashes)\n       ))\n   {}\n   maps))","user":"552a793ee4b0ffed3738f955"},{"problem":69,"code":"(fn [combine-function & maps]\n    (let [ks (;; Put in set, to remove duplicates\n              into #{} (mapcat keys maps))]\n      (reduce\n       (fn [accum k]\n         (let [vs (filter (complement nil?)\n                          ((apply juxt maps) k))\n               v  (if (= (count vs) 1) (first vs)\n                      (apply combine-function vs))]\n           (conj accum [k v])))\n       {}\n       ks)))","user":"5e38a9cbe4b01d43a70e8dc2"},{"code":"(fn [g & c]\r\n  (reduce \r\n    #(reduce \r\n        (fn [r [k v]] \r\n          (assoc r k (if (contains? r k) (g (r k) v) v)))\r\n        % %2)\r\n    c))","problem":69,"user":"4ec0c7ba535dfed6da9c6da4"},{"problem":69,"code":"(fn [f & maps]\n  (let [merge-entry (fn [m e]\n                      \"把右边的entry合并到左边的map\"\n                      (let [k (key e) v (val e)]\n                        (if (contains? m k)\n                          (assoc m k (f (get m k) v))\n                          (assoc m k v))))\n        merge2 (fn [m1 m2]\n                 (reduce merge-entry (or m1 {}) (seq m2)))]\n    (reduce merge2 maps)))","user":"5823d3e6e4b051871117beb8"},{"code":"(fn [f & ms]\n  (reduce (fn [res n]\n            (reduce (fn [r [k v]]\n                      (if (contains? r k)\n                        (update-in r [k] f v)\n                        (assoc r k v)))\n                    res n))\n          {} ms))","problem":69,"user":"4eae5fe4535d7eef30807325"},{"code":"(fn [i-function i-map & i-merge]\r\n    (let [merged (apply concat i-merge)]\r\n        ((fn my-merge\r\n            ([] (my-merge i-map merged))\r\n            ([result i-input]\r\n                (if (zero? (count i-input))\r\n                    result\r\n                    (let [current (first i-input) next (rest i-input)\r\n                        [i-key i-value] current]\r\n                        (if (contains? result i-key)\r\n                            (my-merge (assoc result i-key (i-function (get i-map i-key) i-value)) next)\r\n                            (my-merge (conj result (first i-input)) next)))))))))","problem":69,"user":"4dddf817535d08e6dec9fdd3"},{"code":"(fn [f & coll]\r\n  (reduce\r\n  (fn  [aa bb]\r\n    (loop [result {} col (set (concat (keys aa) (keys bb)))]\r\n      (if (empty? col)\r\n        result\r\n        (let [x (aa (first col)) y ( bb (first col))]\r\n          (recur\r\n           (assoc result (first col)\r\n                  (cond\r\n                   (nil? x) y\r\n                   (nil? y) x\r\n                   :else ( f x y)))\r\n           (rest col))))))\r\n  coll))","problem":69,"user":"4f4ec77ae4b03ad3f0c10cd0"},{"problem":69,"code":"(fn [f & maps]                                                                    \n  (let [ks (distinct (mapcat keys maps))]                                                   \n    (apply merge                                                                            \n           (for [k ks] {k (->> maps                                                         \n                               (map #(get % k))                                             \n                               (remove nil?)                                                \n                               (#(if (< 1 (count %))                                        \n                                   (apply f %)                                              \n                                   (first %))))}))))","user":"54d127b7e4b0e8a36923e5de"},{"code":"(fn [f & s]\n   (reduce\n    (fn [m k]\n      (let [[a & b :as v] (mapcat #(if (% k) [(% k)] []) s)]\n        (assoc m k (if b (apply f v) a))))\n    {}\n    (into #{} (mapcat keys s))))","problem":69,"user":"4e65027c535d8ccf87e9fe6e"},{"code":"(fn [f & maps]\n  (reduce\n    #(if-let [v (%1 (%2 0))]\n       (conj %1 [(%2 0) (f v (%2 1))])\n       (conj %1 %2))\n    (first maps)\n    (mapcat seq (rest maps))))","problem":69,"user":"4e9519b4535dbda64a6f6b2d"},{"problem":69,"code":"(fn\n  [f & maps]\n  (let [K (set (mapcat keys maps))\n        V (map (fn [k]\n                 (vector k (filter #(not (nil? %))\n                                   (map #(get % k) maps)))) K)]\n    (apply hash-map\n           (mapcat #(vector (first %) (reduce f (second %))) V))))","user":"5893c64ce4b00487982d524b"},{"problem":69,"code":"(fn combine [f m & ms]\n  (letfn [(rsv [mp [k v]]\n            (if (contains? mp k)\n              (f (get mp k) v)\n              v))]\n    (loop [mp m\n           others ms]\n      (if (empty? others)\n        mp\n        (recur (reduce (fn [acc kv] (assoc acc (first kv) (rsv acc kv))) mp (first others))\n               (rest others))))))","user":"51b920bfe4b0e871ca4958f9"},{"code":"(fn [f m & ms]\n  (reduce (fn [a [k v]]\n            (assoc a k\n              (if (contains? a k)\n                (f (get a k) v)\n                v))) m (mapcat seq ms)))","problem":69,"user":"5164867fe4b003cf19fdde3e"},{"problem":69,"code":"(fn [f mmap & maps]\n  (let [m-merge \n        (fn [f m1 m2] \n          (reduce (fn [m [k v]]\n            (if (m k)\n              (assoc m k (f (m k) v))\n              (assoc m k v)))\n          m1 m2))]\n   (reduce #(m-merge f %1 %2)  mmap maps)))","user":"549c1713e4b0f3d1d8e70f82"},{"problem":69,"code":"(fn [f & mcoll] \n  \n  (reduce #(into %1 (map (fn [[k v]] {k (if (%1 k) (f (%1 k) v) v)}) (seq %2))) {} mcoll))","user":"54908cc1e4b0b312c081ff32"},{"problem":69,"code":"(fn my-merge-with [f & colls]\n    (reduce\n      (fn [acc coll]\n        (reduce-kv\n          (fn [acc keg value]\n            (if (contains? acc keg)\n              (conj acc [keg (f (acc keg) value)])\n              (conj acc [keg value])))\n          acc\n          coll))\n      {}\n      colls))","user":"5429986ce4b01498b1a71b3b"},{"problem":69,"code":"(fn [f & l]\n   (letfn [(merge* [m1 m2]\n             (reduce-kv #(assoc %1 %2 (if (%1 %2) (f (%1 %2) %3) %3)) m1 m2))]\n     (reduce merge* (first l) (rest l))))","user":"5f3f2281e4b004f08c61c561"},{"problem":69,"code":"(fn m[f a b & r](let\n  [x (apply merge a b (map #(hash-map % (f (a %)(b %))) (keys(select-keys a(keys b)))))]\n  (if(seq r)\n  (apply m f x r)x)))","user":"53ed2fafe4b0d648e757f4c1"},{"code":"(fn[f & v]\n  (reduce (fn[m n]\n           (into m\n            (for [[x y] n]\n             (if (m x) [x (f (m x) y)]\n                       [x y])))) v))","problem":69,"user":"52f818a6e4b047fd55836fcc"},{"code":"(fn [f & ms]\n    (reduce #(assoc %1 (first %2) (reduce f (map second (second %2)))) {}\n            (group-by first (apply concat (map seq ms)))))","problem":69,"user":"53468f6ce4b084c2834f4a3f"},{"problem":69,"code":"(fn[f & xs]\n  (reduce #(reduce (fn [m [k v]] (assoc m k (if (contains? m k) (f (m k) v) v))) %1 %2) xs))","user":"55be39f9e4b01b9910ae2a06"},{"code":"(fn my-merge-with [func m1 & ms]\n  (if-let [m2 (first ms)]\n    (recur\n      func\n      (reduce (fn [coll [k v]]\n                (if-let [existing (coll k)]\n                  (assoc coll k (func existing v))\n                  (assoc coll k v)))\n              m1\n              m2)\n      (rest ms))\n    m1))","problem":69,"user":"51460e4ce4b04ef915e37314"},{"code":"(fn [f & maps]\n    (->> maps\n         (mapcat vec)\n         (group-by first)\n         (map (fn [[k v]] [k (reduce f (map second v))]))\n         (into {})))","problem":69,"user":"4f463dfde4b0d56e7bb92b99"},{"code":"(fn [func & maps]\n  (letfn [(f [f map1 map2]\n            (loop [k (keys map2) result (conj {} map1)]\n              (let [the-key (first k)]\n                (if (not (seq k))\n                  result\n                  (recur (rest k) (assoc result the-key\n                    (if (contains? result the-key)\n                        (f (get map1 the-key) (get map2 the-key))\n                        (get map2 the-key))))))))]\n    (loop [m (rest maps) result (conj {} (first maps))]\n    (if (not (seq m))\n      result\n      (recur (rest m) (conj result (f func result (first m))))))))","problem":69,"user":"51857e64e4b0da5a5be3babe"},{"problem":69,"code":"#(loop [result %2\n        xs %&]\n   (print xs result)\n   (if (empty? xs)\n     result\n     (recur (reduce-kv (fn [acc k v] (assoc acc k (if (acc k) (%1 (acc k) v) v))) result (first xs)) (rest xs))))\n;for clojure version of 1.7\n;#(loop [result %2\n;        xs %&]\n;   (if (empty? xs)\n;     result\n;     (recur (reduce-kv (fn [acc k v] (update acc k %1 v)) result (first xs)) (rest xs))))","user":"56f7ecdfe4b08e7d20b96834"},{"code":"(fn p69\n  ([f & mss] (let [mks (reduce (partial apply conj) #{} (map keys mss))]\n               (reduce conj {} (map (fn [k] (let [ags (filter (comp not nil?) (map (fn [m] (m k)) mss))]\n                                              [k (if (= 1 (count ags)) (first ags) (apply f ags))])) mks)))))","problem":69,"user":"5272669de4b03e8d9a4a742e"},{"problem":69,"code":"(fn merge-w [f a & bs]\n  (reduce\n    (fn [a b]\n      (reduce\n        (fn [sofar k]\n          (assoc sofar k (if (a k) (if (b k) (f (a k) (b k)) (a k)) (b k))))\n        {}\n        (into #{} (concat (keys a) (keys b))))) a bs))","user":"534d1173e4b084c2834f4a98"},{"code":"(fn [f & ms]\n\t(->> ms\n\t\t(map vec)\n\t\t(apply concat)\n\t\t(group-by (fn [[k v]] k))\n\t\t(reduce (fn [acc [k v]] (assoc acc k (map second v))) {})\n\t\t(reduce (fn [acc [k v]] (assoc acc k \n\t\t\t\t\t\t\t\t\t\t\t(if (= 1 (count v))\n\t\t\t\t\t\t\t\t\t\t\t(first v)\n\t\t\t\t\t\t\t\t\t\t\t(apply f v))))\n\t\t\t\t{})\n\t))","problem":69,"user":"4f1abbfb535d64f60314646e"},{"problem":69,"code":"(fn [op & maps]\n  (let [ks (into #{} (mapcat keys maps))]\n    (apply hash-map\n           (mapcat (fn [k]\n                     [k (reduce op\n                                (filter (comp not nil?)\n                                        (map #(% k) maps)))])\n                   ks))))","user":"605f5c69e4b03746e80ebf5e"},{"problem":69,"code":"(fn [f & ms]\n   (reduce (fn [m1 m2]\n             (into m1 (map \n                       (fn [[k v]] (if (contains? m1 k)\n                          {k (f (m1 k) v)}\n                          {k v})) m2) ))\n           ms))","user":"53f6d555e4b0db01ade6f9e5"},{"problem":69,"code":"(fn mw [f & maps]\n  (let [merge-entry (fn [m e]\n                      (let [k (key e) v (val e)]\n                        (if (contains? m k)\n                          (assoc m k (f (get m k) v))\n                          (assoc m k v))))\n        merge2 (fn [m1 m2]\n                 (reduce merge-entry m1 m2))]\n    (reduce merge2 maps)))","user":"5532a04ee4b09218d5f44f82"},{"problem":69,"code":"(fn [f & maps]\n  (reduce (fn [acc [k v]]\n            (if (contains? acc k)\n              (assoc acc k (f (acc k) v))\n              (assoc acc k v)))\n          {}\n          (apply concat maps)))","user":"53dd37aee4b0d874e779ae28"},{"problem":69,"code":"(fn [f & maps]\n  (reduce (fn [acc m]\n            (reduce (fn [cur [k v]]\n                      (let [old (cur k)]\n                        (if old\n                          (assoc cur k (f old v))\n                          (assoc cur k v))))\n                    acc\n                    (map identity m)))\n          maps))","user":"5516a874e4b06a49daca83b5"},{"code":"(fn [f & as]\n  (let [ks (set (apply concat (map keys as)))]\n    (apply merge (for [k ks] \n                   (let [vs (filter identity (map #(get % k) as))]\n                     (hash-map k (if (> (count vs) 1) (apply f vs) (first vs))))))))","problem":69,"user":"52ba43d0e4b07a9af57922cd"},{"code":"(fn[f & xs]\n  (reduce  \n   (fn [r x]\n     (merge x (reduce \n               (fn[res [k v]] \n                 (if (contains? x k)\n                   (assoc res k (f v (x k)))\n                   (assoc res k v))) {} r))) \n   (first xs) (next xs)))","problem":69,"user":"506406c8e4b075d771da6f9f"},{"problem":69,"code":"(fn [f & maps]\n  (letfn [(mymerge [a b]\n                   (into a (cons b (map (fn [x] [x (f (a x) (b x))]) (clojure.set/intersection (set (keys a)) (set (keys b)))))))]\n         (reduce mymerge {} maps)))","user":"5958cef6e4b066ee0a44af94"},{"problem":69,"code":"(fn mm[f & ms]\n  (reduce\n    (fn[acc, map] (reduce (fn[m [k v]] (update-in m [k] (fn[v2] (if v2 (f v2 v) v)))) acc map))\n    ms))","user":"56824e1be4b0945ebc182a91"},{"problem":69,"code":"(fn [f & maps]\n  (into {} (map \n            #(vector (first (first %)) \n                     (if (= 1 (count %)) (second (first %)) (apply f (map second %))))\n            (vals (group-by first (apply concat maps))))))","user":"55a74d46e4b09e57187da2a3"},{"problem":69,"code":"; (fn mrg-with [f m & maps]\n;  (if (empty? maps)\n;    m\n;    (recur f\n;           (reduce (fn [acc [k v]]\n;                     (if (contains? m k)\n;                       (assoc acc k (f (get acc k) v))\n;                       (assoc acc k v)))\n;                   m (seq (first maps)))\n;           (next maps))))\n\n(fn mrg-with [f & maps]\n  (reduce #(into % (for [[k v] %2]\n                     (if (contains? % k)\n                       [k (f (get % k) v)]\n                       [k v])))\n          maps))","user":"5aa4f7dae4b0d174b936c88c"},{"problem":69,"code":"(fn [f & vs]\n (into {}\n (map\n   (fn [ky] (vector ky \n                    (let [va (filter (comp not nil?) (map #(% ky) vs))]\n                      (if (= 1 (count va))\n                        (first va)\n                      (apply f va\n                    )))))\n   (into '() (set (mapcat keys vs)))\n  )))","user":"541ef7e2e4b01498b1a71a92"},{"problem":69,"code":"(fn [f m & maps]\n  (reduce \n   (fn [m1 m2]\n     (reduce \n      (fn [out [k v]] (assoc out k (if (out k) (f (out k) v) v)))\n      m1 m2))\n   m maps))","user":"5478e57de4b0c51c1f4d72c1"},{"code":"(fn my-merge [f m & ms]\n  (let [m2 (apply merge ms)]\n    (reduce \n      #(assoc % %2 \n        (if (contains? % %2)\n          (f (% %2) (m2 %2))\n          (m2 %2))) \n      m \n      (keys m2))))","problem":69,"user":"4e9c81e8535dbda64a6f6b80"},{"code":"(fn w [f m & c] \r\n    (if (empty? c) \r\n      m\r\n      (apply w f (apply merge m (map #(identity {(key %) (if (m (key %)) (f (m (key %)) (val %)) (val %))}) (first c))) (rest c)))\r\n  )","problem":69,"user":"4ecbb249535df97575fdabdf"},{"problem":69,"code":"(fn [f & maps]\n  (reduce (fn [acc el]\n            (reduce (fn [a [k v]]\n                      (assoc a k (if (el k) (f v (el k)) v)))\n                    el acc)) (first maps) (rest maps)))","user":"4f88ae35e4b033992c121c6d"},{"problem":69,"code":"(fn -merge-with\n  ([f m-l m-r]\n   (loop [s-r (seq m-r)\n          acc m-l]\n     (if (empty? s-r)\n       acc\n       (let [[k-r v-r] (first s-r)]\n         (if-let [v-l (get m-l k-r)]\n           (recur (rest s-r) (assoc acc k-r (f v-l v-r)))\n           (recur (rest s-r) (assoc acc k-r v-r)))))))\n  ([f m-l] m-l)\n  ([f m0 m1 m2]\n   (-merge-with f m0 (-merge-with f m1 m2)))\n  ([f m0 m1 m2 m3]\n   (-merge-with f m0 (-merge-with f m1 m2 m3))))","user":"5f86a98be4b0649ffcda4caa"},{"problem":69,"code":"(fn [f & coll]\n  (reduce\n    (fn [a b]\n      (reduce-kv\n        (fn [m k v]\n          (assoc m k\n                   (if-let [v2 (m k)] (f v2 v) v)))\n        a b)) coll))","user":"5e08c3dde4b0978307768fc8"},{"code":"(fn [f & maps]\r\n  (let [merge-kv (fn [m kv]\r\n                   (let [[k v] kv\r\n                         v-final (if (contains? m k) (f (get m k) v) v)]\r\n                     (assoc m k v-final)))\r\n        merge-mm (fn [m1 m2]\r\n                   (reduce merge-kv m1 (seq m2)))]\r\n    (reduce merge-mm maps)))","problem":69,"user":"4fabbb97e4b081705acca21d"},{"problem":69,"code":"(fn [op & maps] (reduce (fn [m1 m2] (reduce (fn [m pair] (if (contains? m (first pair)) (assoc m (first pair) (op (m (first pair)) (second pair))) (assoc m (first pair) (second pair)))) m1 m2)) maps))","user":"5b4b4052e4b02d533a91bc9a"},{"problem":69,"code":"(fn [f & [m & ms]] (reduce (fn [r [k v]]\n                              (let [new (if-let [old (get r k)] (f old v) v)]\n                                (assoc r k new)))\n                            m (apply concat ms)))","user":"56dc3bdfe4b0ea9b8538f819"},{"problem":69,"code":"(fn [f & maps]\n  (letfn [(merge-key [f a b k] \n            (let [valA (get a k)\n                  valB (get b k)\n                  res (if valA (f valA valB) valB)]\n              {k res}))\n          (merge-all [f a b]\n            (let [eu (map (partial merge-key f a b) (keys b))]\n              (apply merge (conj eu a))))]\n    (reduce (partial merge-all f) maps)))","user":"541ddadbe4b01498b1a71a84"},{"code":"(fn my-merge-with [f & maps]\n  (if (some identity maps)\n    (letfn [(merge-entry [m e]\n                         (let [k (key e) v (val e)]\n                           (if (contains? m k)\n                             (assoc m k (f (get m k) v))\n                             (assoc m k v))))\n            (merge2 [m1 m2]\n                    (reduce merge-entry (or m1 {}) m2))]\n      (reduce merge2 maps))))","problem":69,"user":"52a55adee4b0c58976d9abe7"},{"problem":69,"code":"(fn mw [op map1 & maps]\n  (cond\n    (nil? maps) map1\n    (empty? (first maps)) (apply mw op map1 (rest maps))\n    :else (let [map2 (first maps)\n                kall (keys map2)\n                k (first kall)\n                ks (rest kall)\n                m' (apply mw op map1 (dissoc map2 k) (rest maps))]\n            (if (map1 k)\n              (assoc m' k (op (map1 k) (map2 k)))\n              (assoc m' k (map2 k))))))","user":"597a4277e4b02382a38ad1e2"},{"code":"(fn [f & ms]\n  (into\n    {}\n    (map\n      (fn [[k vs]] [k (reduce f (map val vs))])\n      (group-by\n        key\n        (apply concat ms)))))","problem":69,"user":"506ab9bae4b05d3b7762c74c"},{"problem":69,"code":"(fn ff [f & s]\n    (reduce \n     (fn [prev next]\n       (apply merge prev \n             (map #(if (contains? prev (key %))\n                        {(key %) (f (prev (key %)) (val %))}\n                        %) next)))\n     s))","user":"51aefceee4b09397d5109797"},{"code":"(fn [f & s]\n  (reduce #(reduce (fn [m [k v]] (assoc m k (if (m k) (f (m k) v) v))) % %2) s))","problem":69,"user":"4e52d815535d302ef430da77"},{"problem":69,"code":"(fn [f & maps] (reduce\n                (fn [acc m] (reduce\n                             (fn [subacc entry]\n                               (let [k (first entry) v (second entry)]\n                                 (assoc subacc k (if (contains? subacc k) (f (subacc k) v) v))))\n                             acc\n                             m))\n                {}\n                maps))","user":"5b465b8be4b02d533a91bc65"},{"problem":69,"code":"(fn mergeWith [foo & maps]\n  (let [mapKeys (into #{} (mapcat keys maps))]\n  (into {}\n  (for [mapKey mapKeys]\n    [mapKey (reduce foo (filter identity (map #(get % mapKey) maps)))]))))","user":"5b3251c1e4b025bcb146f317"},{"code":"(fn [f & ms]\n  (let [ks (distinct (mapcat keys ms))\n        g  (fn [k] (reduce f (remove nil? (map #(get % k) ms))))]\n    (zipmap ks (map g ks))))","problem":69,"user":"4dda44f2535d02782fcbe9f1"},{"code":"(fn merge-with'\n  ([f m]\n   m)\n  ([f m m1 & ms]\n   (let [merged (reduce #(assoc %1 (first %2)\n                           (if-let [val (get %1 (first %2))]\n                             (f val (second %2))\n                             (second %2)))\n                        m\n                        m1)]\n     (apply merge-with' (concat [f merged] ms)))))","problem":69,"user":"524cdd51e4b0752c4cb68ccc"},{"code":"(fn [op & ms]\n  (reduce\n   (fn [r m]\n     (reduce (fn [result [k v]]\n               (if (contains? result k)\n                 (assoc result k (op (result k) v))\n                 (assoc result k v)))\n             r\n             m))\n   {}\n   ms))","problem":69,"user":"536f871de4b0fc7073fd6e7f"},{"problem":69,"code":"(fn [f & maps]\n  (letfn [(merge-pair-into-map [base pair]\n                               (conj base (if (contains? base (first pair))\n                                            [(first pair) (f (base (first pair)) (second pair) )]\n                                            pair)))\n          (merge-two-maps [base [& pairs]]\n                          (reduce merge-pair-into-map base pairs))]\n    (reduce merge-two-maps maps)))","user":"54febf4be4b07d26eda61d45"},{"code":"(fn [f & maps]\n    (reduce (fn [merged m]\n      (reduce\n        (fn [merged [k v]]\n          (if (merged k)\n            (assoc merged k (f (merged k) v))\n            (assoc merged k v)))\n        merged\n        m))\n      {}\n      maps))","problem":69,"user":"504c8165e4b09724c857af31"},{"code":"(fn [f & l]\n  (let [x (reduce concat l)]\n    (reduce (fn [h [k v]] (if (h k) (assoc h k (f (h k) v)) (assoc h k v))) {} x)))","problem":69,"user":"4f8c5f4fe4b02e764a0a5198"},{"code":"(fn [f & maps]\n                 (loop [result {}\n                        maps maps]\n                   (if (seq maps)\n                     (recur (reduce conj result (map (fn [[k v]] (if (nil? (result k))\n                                                                   {k v}\n                                                                   {k (f (result k) v)})) (first maps)))\n                            (rest maps))\n                     result)))","problem":69,"user":"4e08fb7a535d04ed9115e7ac"},{"code":"(fn prob-0069\n  [f & mps]\n  (cond\n   (zero? (count mps))  nil\n   (= 1   (count mps)) (first mps)\n   :else  (let [red-fn (fn [dst-map el]\n                         (let [k (key el), v (val el)]\n                           (if (contains? dst-map k)\n                             (into dst-map {k (f (dst-map k) v)})\n                             (into dst-map {k v}))))]\n            \n            (reduce red-fn (first mps) (apply concat (rest mps))))))","problem":69,"user":"4f047c07535dcb61093f6bcd"},{"code":"(fn [f & xs]\n  (reduce\n   (fn [a b]\n     (conj a b\n      (reduce #(\n               let [v (get b %2)]\n                 (if v\n                    (assoc %1 %2 (f (get a %2) v))\n                    %1\n                    )\n               )\n             {}\n             (keys a)\n      )\n    )\n  )\n  xs)\n)","problem":69,"user":"504f191ae4b0e7ad84dbc4ba"},{"problem":69,"code":"(fn m-with [f m & ms]\n  (if (empty? ms)\n    m\n    (apply\n     m-with f\n            (reduce-kv\n             (fn [m k v]\n               (update-in m [k] (fn [elt rep]\n                                  (if elt\n                                    (f elt rep)\n                                    rep))\n                                    v))\n             m\n             (first ms))\n            (rest ms))))","user":"5829d9f8e4b051871117bf4d"},{"code":"(fn [fcn x & xs ]\n  (reduce \n   (fn [result [k v]]\n     (assoc result k\n       (if-let \n           [v1 (result k)]\n         (fcn v1 v)\n         v\n         )))\n   x\n   (apply concat xs)\n   )\n)","problem":69,"user":"5281a445e4b0757a1b17143a"},{"problem":69,"code":"(fn [f & colls]\n\t(into {}\n\t\t(for [[x y] (group-by key (apply concat colls))] {x (reduce f (vals y))})))","user":"56540485e4b0f9d632dd847a"},{"code":"(fn mm2 [f x & ys]\n  (if ys\n    (apply mm2 \n           f \n           ((fn mm [f a b]\n              (if (empty? b)\n                a\n                (let [firstKey (first (first b))]\n                  (if (contains? a firstKey)\n                    (mm f (assoc a firstKey (f (get a firstKey) (get b firstKey))) (dissoc b firstKey))\n                    (mm f (assoc a firstKey (get b firstKey)) (dissoc b firstKey))))))\n             f x (first ys))\n           (rest ys))\n    x))","problem":69,"user":"5110b8bae4b04c71fce993f4"},{"code":"(fn m [op n & z] \n             (if (empty? z) \n               n\n               (apply m op \n                  (apply hash-map  \n                         (apply concat \n                  ( for [x (set (concat (keys n) (keys (first z))))] \n                    ( if (and (contains? n x) (contains? (first z) x))\n                         (vector x (op (get n x) (get (first z) x)) )\n                         (vector x (get n x (get (first z) x)))\n                      )\n                    ) \n                  ) \n                 ) (rest z) \n                  )\n               )\n              )","problem":69,"user":"50ef3e5de4b0a78662fa2652"},{"problem":69,"code":"(fn [f & maps]\n  (let [merge-two (fn [f m1 m2]\n                    (let [upd (for [[k v] m2]\n                                (if (contains? m1 k)\n                                  [k (f (m1 k) v)]\n                                  [k v]))]\n                      (merge m1 (into {} upd))))\n        merge-fn (partial merge-two f)]\n    (reduce merge-fn maps)))","user":"518279abe4b0353c468deb65"},{"code":"#(reduce \n  (fn [to from] \n    (reduce \n     (fn [to [k v]]\n       (if (to k)\n         (assoc to k (% (to k) v))\n         (assoc to k v))) \n     to from))\n  %&)","problem":69,"user":"50052d38e4b0678c553fc45c"},{"code":"(fn tf [f & args]\r\n  (into {}\r\n    (map\r\n      (fn [k] [k (reduce f (filter #(not (nil? %)) (map #(% k) args)))])\r\n      (set (apply concat (map keys args))))))","problem":69,"user":"4ef2da4f535dced4c769f224"},{"code":"(fn [f & maps]\n  (let [merge (fn [m e]\n                (let [k (key e) v (val e)]\n                  (if (contains? m k)\n                    (assoc m k (f (m k) v))\n                    (assoc m k v))))]\n    (reduce (fn [m1 m2] (reduce merge m1 (seq m2))) maps)))","problem":69,"user":"4e39fb68535deb9a81d77f47"},{"code":"(fn [f & maps]\n  (let [merge-two (fn [x y] (reduce (fn [a [k v]] (if (contains? a k)\n                                                    (conj a [k (f (a k) v)])\n                                                    (conj a [k v])))\n                                    x y))]\n    (reduce merge-two maps)))","problem":69,"user":"50d86fe2e4b01f0871336e67"},{"problem":69,"code":"(fn [f & ms]\n  (->> ms\n   (mapcat identity)\n   (group-by first)\n   (map (fn [[k vs]] [k (map second vs)]))\n   (map (fn [[k vs]] [k (reduce f vs)]))\n   (into {})))","user":"4fd4bddce4b0d4de60cee36e"},{"code":"(fn test [f & args]\n    (reduce (fn [res new-map]\n                (reduce #(let [key2 (key %2)] \n                           (if (contains? %1 key2)\n                             (merge %1 [key2 (f (get %1 key2) (val %2))])\n                             (merge %1 %2)))\n                        res\n                        new-map))\n            args))","problem":69,"user":"4f678ac8e4b07046d9f4ef67"},{"problem":69,"code":"(fn [f & ms]\n  (letfn [(mw [f m n]\n\t\t    (reduce (fn [m [k v]]\n\t \t\t          (assoc m k\n                        (if (contains? m k)\n             \t\t      (f (m k) v)\n                          v)))\n          \t\t\tm n))]\n    (reduce (partial mw f) (first ms) (rest ms))))","user":"594880ade4b07ddc2dafadc2"},{"problem":69,"code":"(fn [f s & maps]\n  (let [opt-call (fn [v1 v2] (if v1 (f v1 v2) v2))\n        field-update (fn [a] (fn [[k v]] [k (opt-call (a k) v)]))\n        single-merge (fn [a b] (into a (map (field-update a) b)))]\n    (reduce single-merge s maps)))","user":"585d9558e4b0f14aab7c879c"},{"problem":69,"code":"(fn my-merge [f & maps]\n  (reduce (fn [ml mr]\n            (reduce (fn [m k]\n                      (if (contains? m k)\n                        (assoc m k (f (get m k) (get mr k)))\n                        (assoc m k (get mr k))\n                        )) ml (keys mr))\n            ) maps))","user":"5bfa25fbe4b0bdcf453d15c8"},{"problem":69,"code":"(fn mymerge\n  ([f col1 col2]\n  (reduce (fn [col ele]\n            (let [k (first ele)\n                  v (second ele)]\n              (if (get col k)\n                (assoc-in col [k] (f (get col k) v))\n                (assoc-in col [k] v))\n              )\n            ) col1 col2))\n  ([f col1 col2 & more]\n   (apply mymerge f (mymerge f col1 col2) more)))","user":"53664e3be4b0243289761e74"},{"problem":69,"code":"(fn [f & maps]\n  (reduce \n\t(fn [acc e]\n\t\t(reduce (fn [accin ein]\n         (if (acc (first ein))\n           (assoc accin (first ein) (f (acc (first ein)) (second ein)))\n         \t(assoc accin (first ein) (second ein))  ))\n          acc\n        e))\n      (first maps)\n    (rest maps)))","user":"5b15ab32e4b0cc2b61a3be72"},{"problem":69,"code":"(fn m-with [f m & coll]\n    (loop [res m\n           c coll]\n          (if (empty? c)\n            res\n            (recur\n              (reduce\n                #(assoc %1 %2 (if (nil? (get res %2)) (get (first c) %2) (f (get res %2) (get (first c) %2))))\n                res\n                (keys (first c)))\n              (rest c)))))","user":"5acd1a43e4b0e27600da7823"},{"code":"(fn [f & maps]\n  (reduce\n   (fn [merged new-dict]\n     (reduce\n      (fn [dict [ks v]] (assoc dict ks (let [old-v (merged ks)]\n                                        (if (nil? old-v)\n                                          v\n                                          (f old-v v)))))\n      merged\n      new-dict))\n        (first maps)\n        (rest maps)))","problem":69,"user":"527ccaf4e4b0757a1b17136d"},{"problem":69,"code":"(fn [f m & ms]\n  (reduce (fn [m [k v]] (assoc m k (if-let [x (m k)] (f x v) v))) \n          m \n          (mapcat vec ms)))","user":"596a66cde4b069c0a1a19803"},{"code":"(fn [f & ms]\n  (->> ms\n       (mapcat #(into [] %))\n       (group-by first)\n       (map (fn [[k v]] [k (if (< (count v) 2)\n                             (second (first v))\n                             (apply f (map second v)))]))\n       (into {})))","problem":69,"user":"504f57c7e4b0a02f9cffde71"},{"problem":69,"code":"(fn [f & maps] (reduce (fn [r m] (reduce-kv #(if (contains? %1 %2) (assoc %1 %2 (f (get %1 %2) %3)) (assoc %1 %2 %3)) r m)) maps))","user":"56e6ef89e4b02e7e935eb6d0"},{"problem":69,"code":"(fn [f al & ar]\n   (loop [ml al\n          [nm & rnm] ar]\n     (if (empty? nm)\n       ml\n       (recur\n        (reduce-kv\n         (fn [m k v]\n           (if (get m k)\n             (assoc (dissoc m k) k (f (get m k) v))\n             (assoc m k v)))\n         ml\n         nm)\n       rnm))))","user":"5d5ef0bce4b0c9e5857d4ffb"},{"problem":69,"code":"(fn [f & li] \n   (reduce \n    (fn [x y] (if (=(count y)1) \n                (assoc x (first(keys y)) (f (x (first(keys y)))(first(vals y))))\n                (reduce \n                 #(assoc %1 \n                        (first %2) \n                        (if (get %1 (first %2))\n                          (f (%1 (first %2))(second %2)) (second %2))\n                        )\n                 x y)))\n    li))","user":"5951190be4b066ee0a44aea4"},{"problem":69,"code":"(fn [func & sets]\n   (letfn [(update [m k func v] (if (contains? m k)\n                                  (assoc m k (func (get m k) v))\n                                  (assoc m k v)))\n           (merge-with-func [set1 [k v] func] (update set1 k func v))\n           (merge-two [set1 set2] (reduce #(merge-with-func %1 %2 func) set1 set2))]\n     (reduce merge-two sets)))","user":"5d9c1226e4b0d3f9b434ad51"},{"code":"(fn [f & ms] (reduce (fn [res m]\n                         (reduce #(assoc %1 (first %2) (if (contains? %1 (first %2))\n                                                                       (f (%1 (first %2)) (second %2))\n                                                                       (second %2))) res m)\n                         ) {} ms))","problem":69,"user":"50dfb660e4b061dbdced7228"},{"problem":69,"code":"(fn [f m & r]\n  (reduce \n   (fn [a [k v]] \n     (assoc a k (if (a k) (f (a k) v) v))) \n   m \n   (apply concat r)))","user":"57609d91e4b08062f99a4e9b"},{"problem":69,"code":"(fn [f & s]\n  (let [m (fn [r e]\n            (let [k (key e)\n                  v (val e)]\n              (if (contains? r k)\n                (assoc r k (f (get r k) v))\n                (assoc r k v))))\n        mm (fn [m1 m2]\n             (reduce m (or m1 {}) (seq m2)))]\n    (reduce mm s)))","user":"5af907e6e4b0cc2b61a3bcda"},{"code":"(fn [f & maps]\n   (reduce (fn [acc val]\n             (let [cmb (conj acc val)]\n               (conj cmb (zipmap (keys cmb)\n                 (map #(if (and (contains? val %) (contains? acc %)) (f (acc %) (val %)) (cmb %)) (keys cmb))))))\n    maps)\n   )","problem":69,"user":"52c1f404e4b07a9af5792370"},{"problem":69,"code":"(fn my-merge-with [f & colls]\n  (let [all-keys (distinct (mapcat keys colls))\n        wrapped-f (fn ([single] single)\n                    ([one & more] (apply f (conj more one))))]\n    (reduce (fn [ret key] (assoc ret key (apply wrapped-f (filter (complement nil?) (map (fn [coll] (get coll key)) colls))))) {} all-keys)))","user":"56ac81ace4b03c432f187347"},{"problem":69,"code":"(fn m-w\n  ([f m n]\n   (reduce (fn [m' [k v]]\n             (if-let [u (m' k)]\n               (assoc m' k (f u v))\n               (assoc m' k v)))\n           m n))\n  ([f m n & etc]\n   (reduce #(m-w f % %2) (list* m n etc))))","user":"53dfdf01e4b0d874e779ae46"},{"problem":69,"code":"(fn mw [f m & ms] \n  (if (empty? ms) \n      m\n      (apply mw f (reduce-kv (fn [m k v]\n                 (if (contains? m k)\n                     (assoc m k (f (m k) v))\n                     (assoc m k v))\n                 ) m (first ms)) (rest ms))))","user":"5a14228fe4b0ff51aa4b3193"},{"code":"(fn [f & r]\n  (let [ks (set (flatten (map keys r)))]\n    (apply merge\n      (for [k ks]\n           {k (reduce f (remove nil? (map #(get % k) r)))}))))","problem":69,"user":"4f8345c6e4b033992c121c1b"},{"problem":69,"code":"(fn\n  [f & ms]\n  (let [m (first ms)\n        rm (rest ms)]\n    (if (empty? rm)\n      m\n      (recur f \n             (cons (reduce-kv \n                    #(if (get %1 %2) (assoc %1 %2 (f (get %1 %2) %3) ) (assoc %1 %2 %3))\n                    m \n                    (first rm)) \n                   (rest rm))))))","user":"5e12327ee4b099d064962fe5"},{"code":"(fn my-merge-with-- [func & args]\n  (letfn [(f-merge [m i]\n            (let [k (key i) v (val i)]\n              (if (contains? m k)\n                (conj m {k (func (get m k) v)})\n                (conj m {k v}))))]\n    (reduce #(reduce f-merge %1 %2) args)))","problem":69,"user":"511e763ce4b03e81d390ac29"},{"problem":69,"code":"(fn my-merge-with [f & maps]\n  (let [merge-entry (fn [m e]\n                      (let [k (key e)\n                            v (val e)]\n                           (if (contains? m k)\n                             (assoc m k (f (get m k) v))\n                             (assoc m k v))))\n        merge2 (fn [m1 m2]\n                 (reduce merge-entry (or m1 {}) (seq m2)))]\n       (reduce merge2 maps)))","user":"5be33a16e4b0ed4b8aab4cd6"},{"code":"(fn [f & args]\r\n    (reduce (fn [m v]\r\n              (conj m [(first v) \r\n                       (if (= 1 (count (second v)))\r\n                         (first (second v))\r\n                         (apply f (reverse (second v))))])) {}\r\n            (reduce \r\n              (fn [a b]\r\n                (reduce #(update-in %1 [(first %2)] into (rest %2)) a b)) \r\n              {} args)))","problem":69,"user":"4dd61f98535d2dad7130b5c6"},{"code":"(fn [f & ms]\n    (reduce\n     (fn [m1 m2]\n       (merge m1 (reduce \n                  (fn [m [k v]]\n                    (assoc m k (if (m1 k)\n                                 (f (m1 k)\n                                    v) v))) {} m2))) ms))","problem":69,"user":"4f3ec266e4b0e243712b1f8c"},{"code":"(fn [f & maps] \n  (reduce \n    (fn [init m] \n      (reduce\n        (fn [init [k v]] (update-in init [k] \n                                    (fn [old] (if (init k) (f old v) v))))\n        init\n        m)) \n    {} \n    maps))","problem":69,"user":"4eab612d535d7eef30807316"},{"code":"(fn my-merge-with [f & maps]\n\t(loop [current (first maps) remains (rest maps)]\n\t\t(if (empty? remains)\n\t\t\tcurrent\n\t\t\t(let [nxt (first remains)]\n\t\t\t\t(recur\n\t\t\t\t\t(loop [input nxt result current]\n\t\t\t\t\t\t(let [x (first input)]\n\t\t\t\t\t\t\t(if (empty? x)\n\t\t\t\t\t\t\t\tresult\n\t\t\t\t\t\t\t\t(recur\n\t\t\t\t\t\t\t\t\t(rest input)\n\t\t\t\t\t\t\t\t\t(if (get result (first x))\n\t\t\t\t\t\t\t\t\t\t(update-in result [(first x)] #(f % (last x)))\n\t\t\t\t\t\t\t\t\t\t(merge result x))))))\n\t\t\t\t\t(rest remains))))))","problem":69,"user":"512d3304e4b040332b905b2d"},{"problem":69,"code":"(fn [f & maps]\n  (let [mapCombiner (fn [m k v] (assoc m k (if (m k) (f (m k) v) v)))]\n    (reduce (fn [base cur] (reduce-kv mapCombiner base cur)) maps)))","user":"5e909685e4b0cb016954634d"},{"code":"(letfn [(kill [k dicts]\n (cons ;;destructuring would probably be more elegant\n  (dissoc (first dicts) k)\n  (rest dicts))) ]\n\n(fn [f d & dicts]\n (if-let [insert (ffirst dicts)]\n  (let [k (key insert) v (val insert)]\n   (if-let [old-val (d k)] (recur f (assoc d k (f old-val v)) (kill k dicts))\n    (recur f (assoc d k v) (kill k dicts))))\n  (if (empty? dicts) d\n   (recur f d (rest dicts))))))","problem":69,"user":"4e356d2b535deb9a81d77f2d"},{"code":"(fn [f & maps]\n  (let [ks (keys (apply merge maps))]\n    (zipmap ks\n            (for [k ks]\n              ((fn [c] (if (= 1 (count c)) (first c)\n                           (apply f c)))\n               (filter identity (map #(% k) maps)))))))","problem":69,"user":"500cb910e4b05f7c30cfa698"},{"problem":69,"code":"(fn [f & maps]\n  (reduce (fn [result [k value]]\n            (let [new-value (if (contains? result k)\n                              (f (get result k) value)\n                              value)]\n              (assoc result k new-value)))\n          {}\n          (apply concat (map vec maps))))","user":"53f891eee4b0de5c4184856d"},{"problem":69,"code":"(fn [op x & xs]\n  (reduce #(assoc %1 (first %2) (if-let[q (get %1 (first %2))](op q (last %2))(last %2 ) ) )  x (into {} xs)))","user":"52bbd09ee4b07a9af57922ee"},{"code":"(fn [f & ms]\n  (letfn [(merge-maps [m0 m1]\n            (reduce (fn [m [k v]]\n                      (if (m k)\n                        (assoc m k (f (m k) v))\n                        (assoc m k v)))\n                    m0\n                    m1))]\n    (reduce merge-maps ms)))","problem":69,"user":"52487654e4b05ef8e38e63dc"},{"code":"(fn [f & maps] (into {}  (map (fn [[k vs]] [k (apply (if (> (count vs) 1) f identity) (map second vs))]) (group-by first (apply concat maps)))))","problem":69,"user":"4e976f79535dbda64a6f6b55"},{"code":"(fn foo [f m1 & maps]\n  \t(reduce (fn [x y] (reduce \n                       #(assoc % (key %2)\n                          (if (contains? % (key %2))\n                            (f (get % (key %2)) (val %2))\n                            (val %2)\n                            )\n                          ) x y)\n              ) m1 maps)\n  )","problem":69,"user":"5274eb56e4b03e8d9a4a74bb"},{"problem":69,"code":"(fn [f & args]\n  (reduce (fn[map1 map2]\n            (reduce (fn [m [k1 v1]]\n                      (if-let [v2 (m k1)]\n                        (assoc m k1 (f v2 v1))\n                        (assoc m k1 v1)))\n                    map1 map2))\n          args))","user":"567ff160e4b0966858e4d8e6"},{"problem":69,"code":"(fn [f & vs]\n  (reduce\n    (fn [m1 m2]\n      (reduce \n        (fn [m [new-k new-v]]\n          (let [v (m new-k)]\n            (assoc m new-k (if v (f v new-v) new-v))))\n        m1 (vec m2)))\n    {} vs))","user":"50f10f7be4b06d9538fe211a"},{"code":"(fn g\n  ([f a x & xs] (apply g f (g f a x) xs))\n  ([f a x]\n   (reduce (fn [a [k v]]\n             (apply assoc a\n                    (if (a k) [k (f (a k) v)] [k v])))\n             a x)))","problem":69,"user":"509160dae4b0742c82730aef"},{"code":"(fn [f m & ms]\n  (reduce (fn [res x]\n            (reduce (fn [m [k v]]\n                      (if (contains? m k)\n                        (assoc m k (f (get m k) v))\n                        (assoc m k v)))\n                    res x))\n          m ms))","problem":69,"user":"52c4af71e4b0c2d177d620e1"},{"problem":69,"code":"(fn [f & s]\n    (let [k (distinct (apply concat (map keys s)))\n          v (for [z k] (reduce f (filter #(not (nil? %)) (map #(get % z) s))))] (zipmap k v))\n)","user":"549c22f7e4b0f3d1d8e70f86"},{"problem":69,"code":"(fn [f & args]\n  (->> (mapcat identity args)\n       (into [])\n       (group-by first)\n       (map (fn [[k v]] \n              [k (reduce f (map second v))]))\n       (into {})))","user":"549eb44fe4b0f3d1d8e70fa6"},{"code":"(fn [f & maps]\n   (reduce (fn [ret cur]\n             (let [ret-keys (set (keys ret))\n                   cur-keys (set (keys cur))\n                   keys-in-both (clojure.set/intersection ret-keys cur-keys)\n                   keys-only-in-ret (clojure.set/difference ret-keys cur-keys)\n                   keys-only-in-cur (clojure.set/difference cur-keys ret-keys)\n                   merged (zipmap keys-in-both (map #(f (get ret %) (get cur %)) keys-in-both))]\n               (merge (select-keys ret keys-only-in-ret)\n                      merged\n                      (select-keys cur keys-only-in-cur)))) maps)\n   )","problem":69,"user":"525ed5f4e4b0cb4875a45db8"},{"code":"(fn [f & ms]\n    (reduce (fn [a m]\n              (reduce (fn [m [k v]]\n                        (if (contains? m k)\n                          (assoc m k (f (get m k) v))\n                          (assoc m k v)))\n                      a m))\n            (first ms)\n            (rest ms)))","problem":69,"user":"52d6a9c2e4b09f7907dd1365"},{"code":"(fn [f acc & ms]\n   (cond\n    (nil? ms) acc\n    :else (recur f\n                 (reduce (fn [m [k v]]\n                           (assoc m k\n                                  (if (contains? m k)\n                                    (f (get m k) v)\n                                    v)))\n                         acc\n                         (first ms))\n                 (next ms))))","problem":69,"user":"4e39d763535deb9a81d77f46"},{"problem":69,"code":"(fn mg [f & m]\n        (let [keys  (keys (apply merge m))]\n          (loop [k keys r {}]\n            (if (empty? k)\n              r\n              (recur (rest k) (conj r {(first k) (let [a (filter identity (map #(get % (first k)) m))]\n                                                   (if (= (count a) 1) (first a) (apply f a)))}))))))","user":"53b4bddae4b047364c0444b9"},{"code":"(fn [f & xs]\n  (->>\n    xs\n    (mapcat seq)\n    (sort-by first)\n    (partition-by first)\n    (map (fn [es]\n        [(ffirst es) (reduce f (map second es))]))\n    (into {})))","problem":69,"user":"4f4e91a9e4b03ad3f0c10cca"},{"code":"(fn [f & ms]\n  (reduce #(into %1 (for [k (keys %2)]\n                      [k (if (contains? %1 k)\n                             (f (%1 k) (%2 k))\n                             (%2 k))]))\n          ms))","problem":69,"user":"506a1985e4b01dc6af13f83e"},{"problem":69,"code":"(fn [f & ms]\n      (reduce (fn [m1 m2]\n                (reduce (fn [m [k v]]\n                          (if (contains? m k)\n                            (update-in m [k] f v)\n                            (assoc m k v)))\n                        m1 m2))\n              ms))","user":"5e317676e4b05b4b01516229"},{"code":"(fn \n    [f & maps]\n  (let [combined (apply concat maps)\n        grouped (group-by first combined)]\n    (zipmap (keys grouped)\n            (map #(if (> (count %) 1) (apply f %) (first %))\n                 (map #(map second %)\n                      (vals grouped))))))","problem":69,"user":"4f03f197535dcb61093f6b84"},{"code":"(fn [f & source]\n  (reduce \n    (fn [memo [k v]]\n      (if (get memo k)\n        (assoc memo k (f (get memo k) v))\n        (assoc memo k v)\n      )\n    )\n  {} (apply concat source))\n)","problem":69,"user":"51db9e1ee4b0e067a9bbadc9"},{"code":"(fn [f & m]\n  (loop [m m\n         r {}]\n    (if (empty? m)\n      r\n      (recur (rest m)\n             (loop [m (first m)\n                    r r]\n               (if (empty? m)\n                 r\n                 (let [k (first (keys m))]\n                   (recur (dissoc m k)\n                          (assoc r k\n                            (if (r k)\n                              (f (r k) (m k))\n                              (m k)))))))))))","problem":69,"user":"535d910ae4b04ce2eb3ed2c5"},{"problem":69,"code":"(fn [f m1 m2 & more]\n    (persistent!\n      (let [merge-two (fn [f map-1 map-2]\n                        (loop [m1 map-1\n                               entries (into [] map-2)]\n                          (if (seq entries)\n                            (let [entry (first entries)\n                                  k (first entry)]\n                              (if-let [m1-val (get m1 k)]\n                                (recur\n                                  (conj! m1 [k (f m1-val (last entry))])\n                                  (rest entries))\n                                (recur (conj! m1 entry) (rest entries))))\n                            m1)))\n            ret (merge-two f (transient m1) m2)]\n        (if (seq more)\n          (reduce (partial merge-two f) ret more)\n          ret))))","user":"536ecd9fe4b0fc7073fd6e76"},{"problem":69,"code":"(fn [f & ms]\n(reduce (fn [r m] \n          (into {} (loop [ks (keys m)\n                          rs r]\n                     (let [k (first ks)]\n                     (if (empty? ks) \n                            rs\n                            (if (contains? rs k)\n                              (recur (next ks) (assoc rs k (f (get rs k) (get m k))))\n                              (recur (next ks) (assoc rs k (get m k)))\n                              )\n                            ))))\n          ) {} ms)\n)","user":"52824143e4b0757a1b171453"},{"problem":69,"code":"(fn [f & ms]\n  (reduce (fn [a [k v]]\n            (assoc a k (if-let [o (get a k)] (f o v) v)))\n          {}\n          (apply concat ms)))","user":"5d45749be4b07c84aa5ae6a2"},{"code":"(fn myMergeWith\n  [fun & colls]\n  (let [result (first colls) toProcess (rest colls)]\n    (reduce \n      (fn [result other]\n        (reduce \n          #(let [element (get %1 (first %2))]\n             (if (nil? element)\n               (assoc %1 (first %2) (second %2))\n               (assoc %1 (first %2) (fun element (second %2))))) \n          result other)) \n      result toProcess)))","problem":69,"user":"509a25b7e4b0efbae1fbc0a8"},{"code":"(fn mw [f m1 m2 & mr]\n  (let [mu (reduce #( if (%1 (key %2)) (update-in %1 [(key %2)] f (val %2)) (conj %1 %2) ) m1 m2)]\n    (if mr (recur f mu (first mr) (next mr)) mu)))","problem":69,"user":"50d0d4c8e4b00b15ecee976a"},{"problem":69,"code":"(fn [op & args]\n   (let [\n         pairs (partition\n                 2\n                 (mapcat identity (reduce\n                                    (fn [p e]\n                                      (into p e)) [] args)))\n         ]\n     (reduce (fn [p e]\n               (let [\n                     key (first e)\n                     val (second e)\n                     in-p (get p key)\n                     v (if (nil? in-p) val (op in-p val) )\n                     ] (conj p {key v}) )\n               ) {} pairs))\n   )","user":"58a9e872e4b01a0c0b232973"},{"code":"(fn [f & maps]\n    (reduce\n     (fn [m [k v]] (if-let [val (m k)] (conj m [k (f val v)]) (conj m [k v])))\n      {} (apply concat maps)))","problem":69,"user":"4fc67081e4b0ee37620e1813"},{"problem":69,"code":"(fn merge-with-function\n  [op & [head & tail]]\n  (loop [result head [next & others] tail]\n    (if (empty? next)\n      result\n      (recur (reduce (fn [acc [key val]]\n                       (if (contains? acc key)\n                         (assoc acc key (op (get acc key) val))\n                         (assoc acc key val)))\n                     result\n                     next)\n             others))\n    ))","user":"60bf7458e4b0e0fa5f1b4296"},{"problem":69,"code":"(fn my-merge-with [f & maps]\n\t(->> \n    maps \n    (mapcat #(into [] %)) \n    (group-by first) \n    (reduce-kv #(assoc % %2 (map (fn [x] (second x)) %3)) {} ) \n    (reduce-kv #(assoc % %2 (reduce f %3)) {}))\n\t)","user":"58988cbbe4b00487982d52d7"},{"code":"(fn [f & maps]\n    (let [merge-entry      (fn [m [k v]]\n                             (if (contains? m k)\n                               (assoc m k (f (get m k) v))\n                               (assoc m k v)))\n          merge2           (fn [m1 m2]\n                             (reduce merge-entry m1 m2))\n          merge-with-redux (fn [f & maps]\n                             (reduce merge2 maps))]\n      (apply merge-with-redux f maps)))","problem":69,"user":"4ee6400c535d93acb0a6685b"},{"problem":69,"code":"(fn [f & maps] \n  (->> maps\n          (mapcat identity)\n          (group-by key)\n          (reduce-kv #(assoc %1 %2 (reduce f (vals %3))) {})))","user":"52fe31d5e4b047fd55837038"},{"code":"(fn [f & ms] (reduce (fn [m a] (reduce (fn [b [k v]] (if (contains? b k) (assoc b k (f (get b k) v)) (assoc b k v))) m a)) ms))","problem":69,"user":"4f0f174c535d0136e6c22330"},{"code":"(fn [f & maps]\n  (let [x (fn [m e]\n            (let [[k v] e]\n              (if (contains? m k)\n                (assoc m k (f (m k) v))\n                (assoc m k v))))]\n    (reduce #(reduce x (or % {}) %2) maps)))","problem":69,"user":"4f39f902e4b0e243712b1efe"},{"problem":69,"code":"(fn [f & xs]\n  (let [k ( (comp set flatten) (map keys xs))]\n  (zipmap k (for [i k]\n          (let [x (remove nil? (for [e xs] (get e i)))]\n              (if (> (count x) 1) (apply f x) (first x) ))))))","user":"54e51c7be4b024c67c0cf7f7"},{"problem":69,"code":"(fn [f m0 & maps]\n  (reduce\n    (fn [m1 m2]\n      (reduce\n        (fn [m [k v]]\n          (if (contains? m k)\n            (assoc m k (f (get m k) v))\n            (assoc m k v)))\n        m1\n        m2))\n    m0\n    maps\n    ))","user":"553abb28e4b09218d5f44ffb"},{"code":"(fn [f & maps]\n  (reduce (fn [m kv]\n            (let [[k v] kv]\n              (assoc m k (if-let [o (get m k)] (f o v) v))))\n          {}\n          (apply concat maps)))","problem":69,"user":"52cc582ae4b07d0d72b27362"},{"code":"(fn [f & maps]\n  (let [ks (set (reduce concat #{} (map keys maps)))]\n    (zipmap ks\n      (map #(let [vs (filter identity (map (fn [m] (m %)) maps))]\n            (if (= 1 (count vs)) \n              (first vs) \n              (apply f vs)))\n         ks))))","problem":69,"user":"51e38568e4b0c611d6113e43"},{"problem":69,"code":"(fn [f & maps] (loop [keys (distinct (flatten (map keys maps))), v-map {}]\n                                        (if (empty? keys)\n                                          v-map\n                                          (recur (rest keys)\n                                                 (merge v-map\n                                                        (hash-map (first keys)\n                                                                  (let [v (apply f\n                                                                                 (filter (complement nil?)\n                                                                                         (map #(get % (first keys)) maps)\n                                                                                         )\n                                                                                 )]\n                                                                    (if (and (number? v) (neg? v))\n                                                                      (- v)\n                                                                      v\n                                                                      )\n                                                                    )\n                                                                  )\n                                                        )\n                                                 )\n                                          )\n                                        )\n                         )","user":"5cf72682e4b0b71b1d808a68"},{"code":"(fn [f m & mps]\n  (reduce (fn [a b]\n            (reduce (fn [ma [k v]]\n                      (if (contains? ma k)\n                        (assoc ma k (f (get ma k) v))\n                        (assoc ma k v))) a (seq b))) m mps))","problem":69,"user":"4e773be8535d324fb2983d6e"},{"problem":69,"code":"(fn [func val-in-result & val-in-latter]\n  (reduce #(into {} (map (fn [x]\n                                 (cond \n                                   (and (contains? %1 x) (contains? %2 x)) [x (func (get %1 x) (get %2 x))]\n                                   (contains? %1 x) [x (get %1 x)]\n                                   :else [x (get %2 x)]))\n                                    (keys (merge %1 %2)))) val-in-result val-in-latter))","user":"56288ccae4b00e49c7cb47ea"},{"code":"(fn [f m1 & maps]\n  (loop [mhead (first maps), mnext (next maps), result m1]\n    (if (nil? mhead)\n      result\n      (recur (first mnext) (next mnext)\n        (loop [kk (keys mhead), lres result]\n          (let [fk (first kk)]\n            (if (nil? fk)\n              lres\n              (if (contains? lres fk)\n                (recur (next kk) (update-in lres [fk] f (get mhead fk)))\n                (recur (next kk) (assoc lres fk (get mhead fk)))))))))))","problem":69,"user":"4ec5cdb0535d6d7199dd36b8"},{"problem":69,"code":"(fn [f & maps]\n  (into {} (map (fn [[k v]] (vec [k (reduce f (map second v))]))\n                (group-by first (apply concat (map vec maps))))))","user":"532bce35e4b09d4e7a9b5536"},{"problem":69,"code":"#(reduce (fn [m1 m2]\n          (reduce (fn [m [k v]] \n                   (if (m k)\n                    (assoc m k (% (get m k) v)) \n                    (assoc m k v))) m1 m2)) %&)","user":"5b61aa6ae4b0c6492753e712"},{"problem":69,"code":"(fn [f & ms]\n  (reduce (fn [a x]\n                     (reduce (fn [h kv]\n                               (if (h (first kv))\n                                 (assoc h (first kv) (f (get h (first kv)) (second kv)))\n                                 (assoc h (first kv) (second kv))))\n                             a x))\n          {} ms))","user":"58844d43e4b0f1effa3b7696"},{"code":"(fn [f & maps]\n    (loop [answer (first maps)\n           curr-map (fnext maps)\n           maps (nnext maps)]\n      (cond\n       (nil? curr-map) answer\n       (empty? curr-map) (recur answer (first maps) (next maps))\n       :else (let [[k v] (first curr-map)]\n               (recur (if-let [answer-val (get answer k)] (assoc answer k (f answer-val v))\n                              (assoc answer k v))\n                      (dissoc curr-map k)\n                      maps)))))","problem":69,"user":"4e89e939535d3e98b8023287"},{"problem":69,"code":"(fn [f & maps] (reduce (fn [a b] (reduce (fn [x y] (if (not (= (get x (first y)) nil))\n                                                       (assoc x (first y) (f (get x (first y)) (get b (first y))) )\n                                                       (assoc x (first y) (get b (first y)) ))) a b))\n                         (first maps) (rest maps)))","user":"567f988be4b0feffd0d18ebe"},{"problem":69,"code":"(fn my-merge-with [f & ms]\n\n  (let [s-of-ms (reduce #(concat %1 (seq %2)) ms)\n        unique-keys (distinct (map first s-of-ms)) \n    ;; unique-keys\n        updated-kvs (for [uk unique-keys]\n          (let [uk-rel-kvs (filter #(= (first %) uk) s-of-ms)] \n            [uk (reduce #(f %1 (second %2)) (second (first uk-rel-kvs)) (rest uk-rel-kvs))])\n          )]\n          \n          (reduce #(assoc %1 (first %2) (second %2)) {} updated-kvs)\n          ;; (apply hash-map (flatten updated-kvs))\n          )\n    \n    )","user":"5ff676a9e4b06df49cee1497"},{"problem":69,"code":"(fn [f & maps] (reduce (fn [target src] (reduce (fn [m pair] (if (contains? m (first pair)) (assoc m (first pair) (f (m (first pair)) (second pair))) (assoc m (first pair) (second pair)))) target src)) (first maps) (rest maps)))","user":"59468de7e4b07ddc2dafad88"},{"code":"(fn mw [op & maps]\n  (let [kvs (group-by first (apply concat (map vec maps)))\n        ks (keys kvs)\n        vs (map #(map second %) (vals kvs))\n        rs (map #(reduce op %) vs)]\n    (zipmap ks rs)))","problem":69,"user":"51d96ad0e4b02ceefd94774f"},{"problem":69,"code":"(fn [f m1 & ms]\n  (reduce (fn [om m] (reduce #((fn [ff mm [k v]]\n  (if (mm k) (assoc mm k (ff (mm k) v))\n    (assoc mm k v))) f %1 %2) om m)) m1 ms)\n)","user":"5b4ff637e4b02d533a91bce0"},{"problem":69,"code":"(fn mwith [f & maps]\n  (let [entry (fn [m e]\n                (let [k (key e) v (val e)]\n                  (if (contains? m k)\n                    (assoc m k (f (get m k) v))\n                    (assoc m k v))))\n        merge2 (fn [m1 m2]\n                 (reduce entry (or m1 {}) (seq m2)))]\n    (reduce merge2 maps)))","user":"4eb3fcba535d7eef30807359"},{"problem":69,"code":"(fn[f & maps] \n    ((fn[finalMap otherMaps]\n        (if (empty? otherMaps) finalMap\n        (recur\n          (reduce #(if (contains? %1 (key %2))\n                      (assoc %1 (key %2) (f (get %1 (key %2)) (val %2)))\n                      (assoc %1 (key %2) (val %2))\n                    )\n            finalMap (first otherMaps)\n          )\n          (rest otherMaps)\n        )\n      ))             \n      (first maps) (rest maps)) )","user":"571172ece4b09c608db70446"},{"problem":69,"code":"(fn fooMerge [f orig & maps]\n  (reduce\n    (fn [prev cur]\n      (merge\n        prev\n        (apply hash-map (mapcat\n          (fn [x]\n            (let [[key val] x]\n              (if-let [origVal (prev key)]\n                [key (f origVal val)]\n                x)))\n          cur))))\n    orig\n    maps))","user":"56fc0601e4b07572ad1a88db"},{"code":"(fn [f & lst]\r\n  (reduce (fn [r m]\r\n            (reduce (fn [r2 [k v]]\r\n                      (if (r2 k)\r\n                        (assoc r2 k (f (r2 k) v))\r\n                        (assoc r2 k v)))\r\n                    r\r\n                    m))\r\n          (first lst)\r\n          (rest lst)))","problem":69,"user":"4de2f44f535d08e6dec9fdec"},{"problem":69,"code":"(fn \n  [f & maps]\n  (when (some identity maps)\n    (let [merge-entry (fn [m e]\n                        (let [k (key e) v (val e)]\n                          (if (contains? m k)\n                            (assoc m k (f (get m k) v))\n                            (assoc m k v))))\n          merge2 (fn [m1 m2]\n                   (reduce merge-entry (or m1 {}) (seq m2)))]\n      (reduce merge2 maps))))","user":"5243e37ae4b076204b44fae3"},{"problem":69,"code":"(fn [f & [m & ms]]\n  (letfn [(mf [f m1 m2] \n              (into m1 (for [[k v] m2] [k (if (contains? m1 k) (f (m1 k) v) v)])))]\n    (reduce #(mf f %1 %2) m ms)))","user":"52ce1abfe4b07d0d72b27389"},{"problem":69,"code":"(fn my-merge-with [f & maps]\n  (when (some identity maps)\n    (let [merge-entry (fn [m e]\n            (let [k (key e) v (val e)]\n              (if (contains? m k)\n                (assoc m k (f (get m k) v))\n                (assoc m k v))))\n          merge2 (fn [m1 m2]\n           (reduce merge-entry (or m1 {}) (seq m2)))]\n      (reduce merge2 maps))))","user":"5eff6c0ee4b0cf489e8d7f11"},{"problem":69,"code":"(fn [f & v] \n  (reduce (fn [c m]\n            (reduce (fn [im kv] (assoc im (key kv) (if (contains? im (key kv)) (f (im (key kv)) (val kv)) (val kv)))) c m)) v))","user":"4ee67364535d93acb0a6685f"},{"problem":69,"code":"(fn [f & maps]\n  (let [merge-entry (fn [m e]\n                      (let [k (key e) v (val e)]\n                        (if (contains? m k)\n                          (assoc m k (f (get m k) v))\n                          (assoc m k v))))\n        merge2 (fn [m1 m2]\n                 (reduce merge-entry m1 m2))]\n    (reduce merge2 {} maps)))","user":"553dd883e4b0a04f792994e6"},{"code":"(fn [f & args]\n    (letfn [(merge-args [acc v]\n              (reduce #(if\n                         (contains? %1 %2)\n                         (assoc %1 %2 (f (get %1 %2) (get v %2)))\n                         (assoc %1 %2 (get v %2)))\n                      acc (keys v)))]\n      (reduce merge-args (first args) (rest args))))","problem":69,"user":"5141abf1e4b02fd87f5064c3"},{"problem":69,"code":"(fn mwaf [f init-m & ms]\n    (if (seq ms)\n      (apply mwaf \n             f \n             (reduce (fn [acc [k v]]\n                       (if (contains? acc k)\n                         (assoc acc k (f (acc k) v))\n                         (assoc acc k v)))\n                     init-m\n                     (first ms))\n             (rest ms))\n      init-m))","user":"513e8141e4b02b2a3d8235c1"},{"code":"(fn [f & maps]\n  (let [all-keys (keys (apply merge maps))]\n    (into {} \n      (mapcat (fn [k] \n                {k (let [r (filter identity \n                              (map #(% k) maps))]\n                     (if (= 1 (count r))\n                         (first r)\n                         (apply f r)))})\n              all-keys))))","problem":69,"user":"4e498df9535dc968683fc4c4"},{"code":"(fn [f & ms]\r\n    (into {} (for [k (set (mapcat keys ms))] \r\n                  [k (reduce f (remove nil? (map #(get % k) ms)))])))","problem":69,"user":"4eecdd66535d93acb0a668b9"},{"code":"(fn [op & args] \n  (reduce \n   (fn [r [k v]] (merge r {k (if (nil? (get r k)) v (op (get r k) v))})) \n   {} \n   ;(mapcat #(map (fn [[k v]] [k v]) %) args)))\n   (apply concat args)))","problem":69,"user":"50de11b2e4b061dbdced7217"},{"problem":69,"code":"(fn [f & ms]\n  (reduce #(let [k (key %2)\n                 v (val %2)]\n            (if (contains? %1 k)\n              (assoc %1 k (f (get %1 k) v))\n              (conj %1 %2)\n              ))\n          {} (apply concat ms)))","user":"4f82ed48e4b033992c121c0e"},{"code":"(fn [f & maps]\n  (reduce (fn [map1 map2]\n      (reduce (fn [m [k v]]\n                (if-let [old (m k)]\n                  (assoc m k (f old v))\n                  (assoc m k v)))\n              map1 map2))\n       maps))","problem":69,"user":"536973e5e4b0243289761e9e"},{"problem":69,"code":"(fn [f & maps]\n  (reduce \n    (fn [maps m]\n      (reduce\n        (fn [maps [k v]]\n          (if (contains? maps k)\n            (assoc maps k (f (maps k) v))\n            (assoc maps k v)))\n        maps\n        m))\n     {}\n     maps))","user":"541e2ff8e4b01498b1a71a8a"},{"problem":69,"code":"(fn my-merge-with [f & maps]\n  (reduce (fn [result latter]\n            (apply conj result (map (fn [[k v]] (if (contains? result k) [k (f (get result k) v)] [k v])) (seq latter))))\n          maps))","user":"5fada7cce4b08cb800c85af5"},{"code":"(fn sixty-nine-huehuehuehuehue\n  [f & maps]\n  (loop [m {}\n         maps maps]\n    (if (seq maps)\n      (let [nextmap (first maps)]\n        (recur (reduce (fn [m [k v]]\n                         (if (contains? m k)\n                           (assoc m k (f (m k) v))\n                           (assoc m k v)))\n                       m\n                       nextmap)\n               (next maps)))\n      m)))","problem":69,"user":"511b233ae4b07ab9ec456180"},{"code":"(fn [f & maps]\n  (when (some identity maps)\n    (let [merge-entry (fn [m e]\n(let [k (key e) v (val e)]\n(if (contains? m k)\n(assoc m k (f (get m k) v))\n(assoc m k v))))\n          merge2 (fn [m1 m2]\n(reduce merge-entry (or m1 {}) (seq m2)))]\n      (reduce merge2 maps))))","problem":69,"user":"51424cc8e4b0b50abeb46b34"},{"problem":69,"code":"(fn mymerge [thefn & args] (let [sofar (atom {})]\n(last (for [smap args anentry smap :let [thekey (first anentry)]]\n(let [nextent (if (contains? @sofar thekey) (apply thefn [(@sofar thekey) (smap thekey)]) (smap thekey))] \n(swap! sofar conj {thekey nextent})\n)))))","user":"55f75c6be4b06e875b46cea9"},{"problem":69,"code":"(fn [f b & r] (reduce (fn [a [k v]] (assoc a k (if (a k) (f (a k) v) v))) b (apply concat r)))","user":"577202d2e4b0979f896515c0"},{"problem":69,"code":"(fn [f & ms]\n  (reduce (fn [r m] \n            (reduce (fn [m' [k v]] \n                      (assoc m' k (if (contains? m' k) (f (m' k) v) v))) \n                    r m)) \n          {} ms))","user":"5566d812e4b0c656e3ff1837"},{"problem":69,"code":"(fn [f & colls]\n  (reduce\n   (fn [m n]\n     (let [m-key-set (set (keys m))\n           n-key-set (set (keys n))\n           shared-k (seq (clojure.set/intersection m-key-set n-key-set))\n           diff-k (seq (clojure.set/difference n-key-set m-key-set))]\n       (merge m\n              (apply hash-map\n                     (mapcat vector\n                             shared-k\n                             (map f\n                                  (map m shared-k)\n                                  (map n shared-k))))\n              (apply hash-map\n                     (mapcat vector\n                             diff-k\n                             (map n diff-k))))))\n   colls))","user":"561ca2eae4b064ca9f4b169b"},{"code":"(fn ololo [f & maps]\n  (let [ks (->> maps (map keys) (apply concat) set)]\n    (reduce (fn [m k]\n              (let [vs (keep #(% k) maps)\n                    v (if (> (count vs) 1) (apply f vs) (first vs))]\n                (assoc m k v)))\n            {} ks)))","problem":69,"user":"523b82efe4b07becd5be21f0"},{"problem":69,"code":"(fn my-merge\n\t[f result_map & other_maps]\n\t(let [maps (list* result_map other_maps) ks (distinct (apply concat (map keys maps)))]\n\t\t(reduce\n\t\t\t(fn [res k]\n\t\t\t\t(let [vs (filter identity (map #(get % k) maps))]\n\t\t\t\t\t(if (next vs)\n\t\t\t\t\t\t(assoc res k (apply f vs))\n\t\t\t\t\t\t(assoc res k (first vs)))))\n\t\t\tresult_map\n\t\t\tks)))","user":"58fb7d7ae4b0438e51c2cf7a"},{"problem":69,"code":"(fn [f m1 & m2]\n  (let [m2 (mapcat concat m2)]\n      (reduce (fn [t val] (let [[k v] val] (if (contains? t k) (update-in t [k] f v) (assoc t k v)))) m1 m2)))","user":"54e24a05e4b024c67c0cf7ce"},{"code":"(fn [func & maps]\n  (let [my-merge (fn [m1 m2] (reduce\n                             (fn [m e] (let [k (key e)]\n                                        (if (m k)\n                                          (conj m [k (func (m k) (val e))])\n                                          (conj m e))\n                                       ))\n                             m1\n                             m2))]\n    (reduce my-merge maps)))","problem":69,"user":"50481b70e4b0ec70b3ef8d98"},{"code":"(fn [f & s]\n  (reduce \n    #(reduce \n      (fn [a [k v]]\n        (assoc a k (if (a k) (f (a k) v) v)))        \n      %\n      %2)\n    s))","problem":69,"user":"4ef49c2c535dced4c769f238"},{"problem":69,"code":"(fn merge-with_ [f acc & rest]\n  (reduce\n    (fn [acc [k v]] (assoc acc k (if (contains? acc k) (f (get acc k) v) v)))\n      acc\n      (mapcat identity rest)))","user":"55e7d06ee4b050e68259b496"},{"code":"(fn [f m & ms]\n  (reduce\n   (fn [m ms]\n     (reduce\n      (fn [m [k v]]\n        (if (contains? m k)\n          (assoc m k (f (m k) v))\n          (assoc m k v)))\n      m ms))\n   m ms))","problem":69,"user":"53244c9de4b09d4e7a9b54db"},{"problem":69,"code":"(fn merge-with* [binop & maps]\n  (reduce\n   (fn [acc m]\n     (let [shared-ks (keys (select-keys acc (keys m)))\n           acc-vals (map acc shared-ks)\n           new-vals (map m shared-ks)\n           uniq-new-ks (remove #(contains? acc %) (keys m))]\n       (into\n        (into acc\n              (zipmap shared-ks\n                      (map binop acc-vals new-vals)))\n        (select-keys m uniq-new-ks))))\n   maps))","user":"59b1c2eae4b0e1f4e384c8ec"},{"problem":69,"code":"(fn [f m & args]\n           (reduce\n             (fn [mm arg]\n               (reduce\n                 (fn [mmm [k v]]\n                   (assoc mmm k (if (nil? (get mmm k))\n                                  v\n                                  (f (get mmm k) v)))) mm arg))\n             m args))","user":"5beda647e4b0a6d31fed2122"},{"code":"(fn [f & maps]  \n  (reduce (fn [m [k v]]\n            (assoc m k \n                   (if (contains? m k) (f (get m k) v) v))) \n            {}\n            (apply concat maps)))","problem":69,"user":"4e5f08c7535d8a8b8723a2da"},{"code":"(fn mw [f m1 & mn]\n  (letfn\n    [(merge2 [a b]\n       (reduce \n         (fn [x [k v]]\n           (assoc x k \n             (if (x k) (f (x k) v) v)))\n          a b))]\n  (reduce merge2 m1 mn)))","problem":69,"user":"4faa9593e4b081705acca1f9"},{"problem":69,"code":"(fn [fnn ze & se]\n  (reduce-kv\n    (fn [m k v]\n        (assoc m k (reduce (fn [acc x] (fnn acc x)) (map second v))))\n    {}\n    (group-by first (reduce concat ze se))))","user":"58bc6a88e4b0888cdc949d16"},{"problem":69,"code":"(fn [f & cols]\n  (letfn [(mrg [res [k v]] \n\t\t\t(let [in-res (get res k)\n                  to-res (if in-res (f in-res v) v)]\n            \t(conj res [k to-res])))]      \n    (loop [res {}, [c & oth] cols]\n      (if (nil? c) res\n        (recur (reduce mrg res c) oth)))))","user":"5c13da47e4b01240ff5671a6"},{"problem":69,"code":"(fn [f m1 & args]\n  (let [m2 (reduce into args)]\n    (apply conj m1\n      (map\n        (fn [kv]\n          (let [[k v] kv]\n            (if (contains? m1 k)\n              [k (f (m1 k) v)]\n              [k v]\n            )\n          )\n        )\n        m2\n      )\n    )\n  )\n)","user":"53ca41dae4b00fb29b2212c8"},{"problem":69,"code":"(fn prob69 [f & maps]\n  (reduce\n   (fn [m1 maps]\n     (reduce\n      (fn [map [key val]]\n        (println map key val)\n        (assoc map key (if (maps key) (f val (maps key)) val))\n        )\n      maps m1\n      ))\n   (first maps) (rest maps)))","user":"4ebbff41535dfed6da9c6d78"},{"code":"(fn [f & ms]\n  (let [\n    singlevecs (apply concat (map seq ms))\n    grouped (group-by first singlevecs)\n    reduc \n      #(reduce \n        (fn [& o] (apply f o))\n        (first %)\n        (rest %))\n      ]\n  (reduce\n    #(assoc % \n      (first %2) \n      (reduc (map second (second %2))))\n    {}\n    grouped)))","problem":69,"user":"4f569218e4b0a7574ea71826"},{"problem":69,"code":"(fn mw [op & maps]\n  (let [distinct-keys (apply (comp distinct concat) (map keys maps))]\n    (zipmap distinct-keys\n      (map \n        #(reduce op %)\n        (map (fn [distinct-key]\n          (remove #(nil? %) (map #(get % distinct-key) maps)))\n          distinct-keys)))))","user":"53940789e4b0b51d73faaec3"},{"code":"(fn [op & ms]\n  (reduce (fn [res m]\n          (reduce (fn [g [k v]]\n              (assoc g k (if (g k) (op (g k) v) v))) res m))\n    {} ms))","problem":69,"user":"4eb0a757535d7eef3080733d"},{"code":"(fn my-merge-with [f m & ms]\n  (letfn [(merge-two [m1 m2]\n            (if (empty? m2)\n              m1\n              (let [[k v] (first m2)]\n                (if (contains? m1 k)\n                  (recur (conj m1 [k (f (get m1 k) v)]) (rest m2))\n                  (recur (conj m1 [k v]) (rest m2))))))]\n    (reduce merge-two m ms)))","problem":69,"user":"4ed188c8535d44c135fd68cf"},{"problem":69,"code":"(fn [f & args]\n  (reduce (fn [x s] (reduce (fn [m [k v]] ((fn [m k f v] (if (nil? m) {k v} (if (contains? m k) (assoc m k (f (m k) v)) (assoc m k v)))) m k f v)) x s)) {} args))","user":"5b5e7953e4b0c6492753e6d9"},{"problem":69,"code":"(fn my-merge-with [fx & maps]\n  (loop [pairs (mapcat #(or %) maps) result (sorted-map)]\n    (let [fp (first pairs) [k v] fp]\n      (cond\n       (nil? fp) result\n       (contains? result k)\n         (recur (rest pairs) (assoc result k (fx (result k) v)))\n       :else\n         (recur (rest pairs) (assoc result k v))))))","user":"5546704be4b0a04f7929953d"},{"problem":69,"code":"(fn [op & maps]\n  (loop [res {} c {} p maps]\n    (if (empty? c)\n      (if (empty? p)\n        res\n        (recur res (first p) (next p))\n      )\n      (let [[k v] (first c)]\n        (if (res k)\n          (recur (update-in res [k] op v) (next c) p)\n          (recur (assoc res k v) (next c) p)\n        )\n      )\n    )  \n  )\n)","user":"57873017e4b0ebec4cfb7503"},{"problem":69,"code":"(fn [f & maps]\n  (->> maps\n       (mapcat seq)\n       (group-by key)\n       vals\n       (map (fn [grp] [(ffirst grp) (map val grp)]))\n       (map (fn [grp] [(first grp) (reduce f (last grp))]))\n       (into {})))","user":"541d3c0fe4b01498b1a71a7e"},{"code":"(fn [f & maps]\n (when (some identity maps)\n    (let [merge-entry (fn [m e]\n  \t\t(let [k (key e) v (val e)]\n\t\t\t  (if (contains? m k)\n\t\t\t    (assoc m k (f (get m k) v))\n\t\t\t    (assoc m k v))))\n          merge2 (fn [m1 m2]\n\t\t   (reduce merge-entry (or m1 {}) (seq m2)))]\n      (reduce merge2 maps))))","problem":69,"user":"4dfe65a1535d04ed9115e787"},{"code":"(fn mw [f map1 & rest-maps]\r\n  (if (empty? rest-maps)\r\n      map1\r\n    (recur f\r\n           (reduce (fn [map1 entry]\r\n                     (if-let [v (map1 (key entry))]\r\n                             (assoc map1 (key entry) (f v (val entry)))\r\n                         (assoc map1 (key entry) (val entry))))\r\n                   map1\r\n                   (first rest-maps))\r\n           (rest rest-maps))))","problem":69,"user":"4fcc6cb3e4b0ee37620e1861"},{"problem":69,"code":"(fn [f & maps]\n  (reduce (fn [l r]\n            (do\n              (println l \" / \" r)\n              (merge (into {} (map (fn [[k v]] (if (contains? r k)\n                                                [k (f v (get r k))]\n                                                [k v]))\n                                   l))\n                     (into {} (map (fn [[k v]] (if (not (contains? l k))\n                                                [k v]\n                                                nil))\n                                   r)))\n                ))\n          {}\n          maps))","user":"567a680ee4b05957ce8c6198"},{"code":"(fn my-merge-with\n  [f & ms]\n  (letfn [(merge-one [accum m]\n            (loop [accum accum ks (keys m)]\n              (if (empty? ks) accum\n                  (let [k (first ks)]\n                    (if-let [v (get accum k)]\n                      (recur (assoc accum k (f v (m k))) (rest ks))\n                      (recur (assoc accum k (m k)) (rest ks)))))))]\n    (reduce merge-one {} ms)))","problem":69,"user":"4e50b67b535dc968683fc4ed"},{"problem":69,"code":"(fn f1 [f & maps] \n  (->> maps\n       (mapcat seq)\n       (reduce \n         (fn [result [k v]]\n           (assoc result k (if (contains? result k) (f (result k) v) v))) {})))","user":"5493d908e4b0b312c081ff52"},{"problem":69,"code":"(fn my-merge-with [f & maps]\n  (reduce (fn [acc m]\n            (reduce (fn [acc [k v]]\n                      (if-let [res-v (acc k)]\n                        (assoc acc k (f res-v v))\n                        (conj acc [k v])))\n                    acc\n                    (into [] m)))\n          {}\n          maps))","user":"53fd66a4e4b0de5c418485e3"},{"code":"(fn mw\n  ([f & ms]\n    (let [m1m2 (fn [m1 m2]\n                 (let [r1f (fn [acc [k v]]\n                             (if (contains? m2 k)\n                               (assoc acc k (f v (m2 k)))\n                               (assoc acc k v)))\n                       r2f (fn [acc [k v]]\n                             (if (contains? m1 k)\n                               acc\n                               (assoc acc k v)))]\n                   (reduce r2f (reduce r1f {} m1) m2)))]\n      (reduce m1m2 {} ms))))","problem":69,"user":"4edecdae535d10e5ff6f533c"},{"code":"(fn merge-w\n  [f & arg-maps]\n  (letfn [(redcat [k arg-maps]\n            (concat (reduce #(if (contains? %2 k)\n                               (conj %1 (%2 k))\n                               %1) [] arg-maps)))\n          (apply-if-more [f coll]\n            (if (> (count coll) 1)\n              (apply f coll)\n              (first coll)))]\n\n   (let [all-keys (mapcat keys arg-maps)]\n     (zipmap all-keys (map (fn [k]\n                             (apply-if-more f (redcat k arg-maps)))\n                           all-keys)))))","problem":69,"user":"4e3bccb1535deb9a81d77f55"},{"code":"(fn mwith [f & hs]\n    (let [add-entry (fn [acc [k v]]\n                      (assoc acc k (if (contains? acc k)\n                                     (f (get acc k) v)\n                                     v)))]\n      (reduce #(reduce add-entry %1 %2) hs)))","problem":69,"user":"5370ef22e4b0fc7073fd6ea0"},{"code":"(fn mwith [f & maps]\n  (letfn [(mr [m1 m2]\n            (let [ks (into #{} (concat (keys m1) (keys m2)))]\n              (letfn [(nm[k] (cond (and (get m1 k) (get m2 k)) {k (f (get m1 k) (get m2 k))}\n                                   (get m1 k) {k (get m1 k)}\n                                   :else {k (get m2 k)}))]\n                (apply merge (map nm ks)))))]\n    (reduce mr maps)))","problem":69,"user":"4fbd12a5e4b081705acca2fd"},{"problem":69,"code":"(fn [& args]\n  (let [f (first args)\n        ms (rest args)\n        go (fn [f m1 m2]\n             (let [same (clojure.set/intersection \n                          (set (keys m1)) \n                          (set (keys m2)))\n                   d1 (clojure.set/difference\n                        (set (keys m1))\n                        (set (keys m2)))\n                   d2 (clojure.set/difference\n                        (set (keys m2))\n                        (set (keys m1)))\n                   delta (concat d1 d2)]\n               (-> (into {} (for [k same]\n                              [k (f (get m1 k) (get m2 k))]))\n                   (merge (select-keys m1 delta))\n                   (merge (select-keys m2 delta)))))]\n    (reduce #(go f %1 %2) ms)))","user":"5574c172e4b05c286339e059"},{"code":"(fn [f & maps]\r\n  (apply merge\r\n    (map #(hash-map (first %) (if (> (count (second %)) 1) \r\n      (apply f (second %)) (first (second %))))\r\n      (for [k (distinct (mapcat keys maps))]\r\n        [k (remove nil? (map #(get % k) maps))]))))","problem":69,"user":"50843a4ae4b0c98812d0788b"},{"problem":69,"code":"(fn  [f & m]\n  (let [mr (fn [a b] \n             (reduce #(if (find %1 (first %2))\n                        (update-in %1 [(first %2)] f (second %2)) \n                        (conj %1 %2)\n                     ) a b)\n             )]\n  (reduce mr m)\n  ))","user":"54e345a1e4b024c67c0cf7db"},{"problem":69,"code":"(fn [f m1 & m]\n   (apply merge (map #(if (find m1 (key %))\n                        (assoc {} (key %) (f (val (find m1 (key %))) (val %) ))\n                        (assoc {} (key %) (val %)))\n                     (apply merge m))))","user":"520cb8c4e4b0b022ef140c9a"},{"code":"(fn merge-with-a-function [f & sqs]\n  (reduce \n\n   (fn [a x]\n     (reduce\n     \n      (fn [a k] \n        (let [v (a k)]\n          (if (nil? v)\n            (assoc a k (x k))\n            (assoc a k (f v (x k))))))\n     \n      a                   \n      (keys x)))\n   \n   {}\n   sqs))","problem":69,"user":"515bbcd9e4b0388ca8ca1521"},{"problem":69,"code":"(fn [f & ms]\n    (letfn [(combine [m1 m2]\n                (into m1 (for [[k v] m2]\n                             [k, (if (contains? m1 k)\n                                     (f (m1 k) v)\n                                     v)])))]\n        (reduce combine ms)))","user":"600ae927e4b074f607df6689"},{"problem":69,"code":"(fn [f & maps]\n  (reduce\n   (fn [merged this-map]\n     (->> (set (concat (keys merged) (keys this-map)))\n          (map\n           (fn [key]\n             {key\n              (if (contains? merged key)\n                (if (contains? this-map key)\n                  (f (get merged key) (get this-map key))\n                  (get merged key))\n                (get this-map key))}))\n          (into {})))\n   maps))","user":"5cf6522be4b0b71b1d808a58"},{"code":"(fn [f & vs]\n  (reduce (fn [r m]\n               (into r (for [[k v] m] \n(if (r k) \n   [k (f (r k) v)] \n   [k v])))) vs))","problem":69,"user":"4db92654535d1e037afb21a0"},{"code":"(fn [f & maps]  \n\t(let [all-ks (keys (apply merge maps))\n\t      all-vs (map (fn [k] (remove nil? (map #(% k) maps))) all-ks)\n\t      app-vs (map #(reduce f %) all-vs)]\n\t  (zipmap all-ks app-vs)))","problem":69,"user":"4db045b5838c48654951d9be"},{"code":"(fn [f m1 & ms]\n   (loop [m m1\n          b (apply concat ms)]\n     (cond\n       (empty? b) m\n       (contains? m (ffirst b)) (recur (assoc m (ffirst b) (f (get m (ffirst b)) (second (first b)))) (rest b))\n       :else (recur (assoc m (ffirst b) (second (first b))) (rest b)))))","problem":69,"user":"51f28a64e4b0210f90e7454e"},{"problem":69,"code":"(fn [f & m]\n  (reduce (fn [m i]\n            (reduce (fn [mm [k v]]\n                      (if (contains? mm k)\n                        (update-in mm [k] f v)\n                        (assoc mm k v))\n                      ) m i) \n            ) {} m))","user":"53ae16e2e4b047364c044472"},{"code":"(fn my-merge-with\r\n  [f result & other-maps]\r\n\t(letfn [(my-merge \r\n\t\t\t\t\t\t[original other-map]\r\n\t\t\t\t\t\t(println \"Now merging: \" original other-map)\r\n\t\t\t\t\t\t(reduce my-conj original other-map))\r\n\t\t\t\t\t(my-conj\r\n\t\t\t\t\t\t[some-map [k v]] ;splicing\r\n\t\t\t\t\t\t(println \"Now conjing: \" some-map [k v])\r\n\t\t\t\t\t\t(if-not (contains? some-map k)\r\n\t\t\t\t\t\t\t(conj some-map [k v])\r\n\t\t\t\t\t\t\t(conj some-map [k (f (some-map k) v)])))]\r\n\t\t(reduce my-merge result other-maps)))","problem":69,"user":"4e8a0c82535d3e98b802328d"},{"code":"(fn my-merge-with [f m & ms]\r\n  (letfn [(mrg [mbas [k v]]\r\n            (assoc mbas k (if-let [vbas (mbas k)] (f vbas v) v)))]\r\n    (reduce mrg m (mapcat seq ms))))","problem":69,"user":"4dd7d040535d2dad7130b5d6"},{"problem":69,"code":"(fn [g & q] (reduce #((fn [f m1 m2] (reduce (fn [m [k v]] (if-let [h (get m k)] (assoc m k (f h v)) (assoc m k v))) m1 m2)) g %1 %2) q))","user":"5659679ae4b068f2fe63dbeb"},{"code":"(fn [f & ms]\n  (letfn\n    [(xf [a b]\n         (cond\n          (nil? a) b\n          (nil? b) a\n          :else (f a b)))\n     (merge2 [a b]\n             (let [ks (keys (merge a b))]\n               (reduce (fn [m k] (assoc m k (xf (a k) (b k)))) {} ks)))]\n    (reduce merge2 {} ms)))","problem":69,"user":"526439a4e4b03e8d9a4a70cc"},{"problem":69,"code":"(fn [f & ms] (reduce (fn [m1 m2]\n  \n    (reduce (fn [m [k v]]\n              (if (contains? m k)\n                (assoc m k (f (m k) v))\n                (assoc m k v)))\n            m1 m2)) ms))","user":"5a566e8fe4b05d388ecb6c51"},{"code":"(fn [f & ms]\n   (apply hash-map (mapcat concat (for [k (into #{} (mapcat keys ms))\n                                        :let [[m & r :as ms] (filter #(find %1 k) ms)]]\n                                    (if (> (count ms) 1)\n                                      [k (apply f (map #(%1 k) ms))]\n                                      [k (m k)])))))","problem":69,"user":"4f32a7f1e4b0d6649770a095"},{"problem":69,"code":"(fn m-w \n  [f & ms] \n    (reduce \n\t  (fn [a b] \n\t    (let [zs [#(hash-map %1 (if (nil? %2) %3 (f %2 %3))) (keys b) (map a (keys b)) (vals b)]]\n\t\t  (merge a (apply merge (apply map zs))))\n\t\t) ms))","user":"5578f292e4b05c286339e08f"},{"code":"(new clojure.core$merge_with)","problem":69,"user":"4e3b6bff535deb9a81d77f52"},{"problem":69,"code":"(fn mw [f & ms]\n  (let [ks (set (flatten (map keys ms)))\n        results (for [k ks]\n                  {k (reduce f (map #(get-in % [k]) (filter #(contains? % k) ms)))})]\n    (reduce merge results)))","user":"523578efe4b0a643f2dcb74c"},{"problem":69,"code":"(fn [f & ms]\n         (reduce\n          (fn [acc m]\n            (reduce-kv (fn [merged k v] \n                         (let [v* (get merged k)]\n                           (assoc merged k (if v* (f v* v) v))))\n                       acc m))\n          ms))","user":"5782018de4b0d36ec5835e8e"},{"problem":69,"code":"(fn my-merge-with [f & ms]\n  (reduce (fn [ml mr]\n            (reduce (fn [m k]\n                      (let [vr (get mr k)]\n                        (if (contains? m k)\n                          (update-in m [k] f vr )\n                          (assoc m k vr))))\n                    ml (keys mr)))\n          ms))","user":"58e37946e4b005f69f193cae"},{"problem":69,"code":"(fn [f fm & rms]\n  (reduce (fn [r m]\n            (merge r\n             (reduce-kv (fn [rr k v]\n                          (if (contains? r k)\n                            (assoc rr k (f (get r k) v))\n                            (assoc rr k v))\n                          )\n                        {}\n                        m)))\n          fm\n          rms))","user":"55895eade4b059ccff29b202"},{"code":"(fn [f & ms]\n  (reduce #(let [m % [k v] %2]\n             (assoc m k (if (m k) (f (m k) v) v)))\n          {} (apply concat ms)))","problem":69,"user":"500854c4e4b028e089d3518c"},{"code":"(fn [f m1 & ms]\n  (let [merge-one (fn [m [k v]]\n                    (update-in m [k]\n                               #(if (nil? %1) %2 (f %1 %2))\n                               v))]\n    (reduce #(reduce merge-one %1 %2) m1 ms)))","problem":69,"user":"5312cdaae4b08068f379ed03"},{"problem":69,"code":"(fn merge-with- \n  [f & maps]\n  (reduce (fn \n            [m1 m2]\n            (reduce (fn \n                      [m [k v]]\n                      (if (contains? m k)\n                        (update-in m [k] f v)\n                        (assoc m k v)))\n                    m1 m2)) \n          maps))","user":"54f2a1b8e4b024c67c0cf8cb"},{"problem":69,"code":"(fn [func base & maps]\n  (->> (for [curr maps]\n         (for [key (keys curr)]\n           (if (base key)\n             {key, (func (base key) (curr key))}\n             curr)))\n       flatten\n       reverse\n       (reduce conj)))","user":"57155980e4b07c98581c3ad7"},{"code":"(fn [f & ms] (letfn [(mw [m1 m2] (reduce #(assoc %1 (key %2) (if (%1 (key %2)) (f (%1 (key %2)) (val %2)) (val %2))) m1 m2))]\n  (reduce mw ms)))","problem":69,"user":"4efd8b67535de96065cf5085"},{"problem":69,"code":"(fn [f & ms]\n  (reduce \n   (fn [m1 m2]\n     (reduce \n      (fn [m [k v]]\n        (if (contains? m k)\n          (update-in m [k] f v)\n          (assoc m k v)\n          )\n        ) m1 m2)\n     ) ms)\n  )","user":"5a0a25fce4b0eab8c044893d"},{"code":"(fn [f, & ms]\n\n  (apply hash-map (apply concat\n  (for [k (set (mapcat keys ms))]\n    (list k (reduce f (map #(get %1 k) (filter #(contains? %1 k) ms))))))))","problem":69,"user":"4f29eb2ae4b0d6649770a037"},{"problem":69,"code":"(fn [f x & xs]\n (reduce (fn [acc1 s]\n           (reduce\n             (fn  [acc2 [k v]]\n                  (assoc  acc2 k \n                    (let [pv (get acc2 k)]\n                         (if (nil? pv)  v  (f pv v)))))\n             acc1 s))\n    x xs))","user":"5794fd7be4b0e215f87e8476"},{"problem":69,"code":"(fn mf [f & maps]\n  (let [ks (distinct (flatten (map keys maps)))]\n    (reduce (fn [memo key]\n              (let [args (filterv identity (map #(% key) maps))]\n                (if (= 1 (count args))\n                  (assoc memo key (first args))\n                  (assoc memo key (apply f args)))\n                )\n              )\n            {}\n            ks)))","user":"56069006e4b08b23635d3174"},{"code":"(fn _ [f init & args]\n  (if-not (seq args)\n    init\n    (letfn [(merge' [m1 m2]\n              (reduce (fn [acc [k v]] (assoc acc k (if-let [v' (acc k)] (f v' v) v))) m1 m2))]\n      (apply _ f (merge' init (first args)) (rest args)))))","problem":69,"user":"5213d7aae4b0961f15ac4d72"},{"problem":69,"code":"(fn [f m & maps]\n  (let [merge (fn [a, b] (loop [k (keys b), r a]\n    (let [ky (first k), vl (get b ky)]\n      (if (empty? k) r\n        (recur (rest k)\n          (if (contains? a ky) (assoc r ky (f (get a ky) vl)) (assoc r ky vl)))))))]\n    (loop [c maps, a m] (if (empty? c) a (recur (rest c) (merge a (first c)))))))","user":"53bcdd41e4b0d9a98559a6c0"},{"problem":69,"code":"(fn [f & args]\n           (let [reducer #(reduce-kv (fn [m k v] (if-let [w (m k)] (assoc m k (f w v)) (assoc m k v)))\n                                     %1 %2)]\n             (reduce reducer args)))","user":"54a677a9e4b09f271ff37c88"},{"problem":69,"code":"(fn [f & args]\n  (reduce (fn [a b]\n            (reduce (fn [maps [k v]]\n                      (if (contains? maps k)\n                        (update-in maps [k] f v)\n                        (assoc maps k v)))\n                    a b))\n          args))","user":"5dfa1c67e4b0a607a9a45cc5"},{"code":"(fn [f m & ms]\n  (if (seq ms)\n    (recur f (reduce\n              (fn [m [k v]]\n                (conj m (if (contains? m k) [k (f (m k) v)] [k v])))\n              m (first ms)) (rest ms))\n    m))","problem":69,"user":"4f0664bd535dcb61093f6c0f"},{"problem":69,"code":"(fn [f & maps]\n    (let [ks (distinct (mapcat keys maps))\n        vt (apply mapv vector (map (apply juxt (map (fn [x] #(get % x)) ks)) maps))\n        vs (map #(reduce f %)\n                (map #(filter (complement nil?) %) vt))]\n    (apply array-map (interleave ks vs))))","user":"539b6c78e4b0b51d73faaf20"},{"code":"(fn [f m & ms]\n  (reduce\n    (fn [r m]\n      (reduce\n        (fn [m [k v]]\n          (if\n            (contains? m k)\n            (assoc m k (f (m k) v))\n            (assoc m k v)))\n        r m))\n    m ms))","problem":69,"user":"4fb2101ce4b081705acca284"},{"problem":69,"code":"(fn [f & ms]\n    (into {}\n          (map (fn [k]\n                 (let [vals (filter identity (map #(get % k) ms))]\n                   [k (if (= (count vals) 1) (first vals) (apply f vals))]))\n               (-> (map keys ms) flatten set))))","user":"4f57c913e4b0a7574ea7183f"},{"problem":69,"code":"(fn [mfn & args]\n    (reduce\n      (fn [acc m]\n        (into acc \n              (for [[k v] m] \n                [k (if-let [old-val (get acc k)]\n                     (mfn old-val v)\n                     v)])))\n      {} args))","user":"537bde5de4b06839e8705e73"},{"problem":69,"code":"(fn mw \n  ([f m1 m2]\n    (reduce (fn [a [k v]] (if (a k)\n                            (assoc a k (f (a k) v))\n                            (assoc a k v)))\n            m1\n            m2))\n  ([f m1 m2 & ms] (apply mw f (mw f m1 m2) ms)))","user":"4f3b5219e4b0e243712b1f2a"},{"code":"(fn [f & ms]\n  (letfn [(m-w [m1 m2]\n            (reduce (fn [m kv]\n                      (let [k (key kv)\n                            v (val kv)\n                            vp (if (contains? m k)\n                                   (f (m k) v)\n                                   v)]\n                        (conj m {k vp})))\n                    m1 (seq m2)))]\n    (reduce m-w (first ms) (rest ms))))","problem":69,"user":"4ede8e1d535d10e5ff6f5339"},{"problem":69,"code":"(fn [mergefn & ms]\n    (letfn [(myassoc-with [m k v]\n              (if (contains? m k)\n                (assoc m k (mergefn (get m k) v))\n                (assoc m k v)))\n            (mymerge [l r]\n               (reduce-kv myassoc-with l r))]\n      (reduce mymerge ms)))","user":"5bd0ea60e4b0e9689409ee45"},{"problem":69,"code":"(fn [o m & l]\n   (reduce (fn [r [k v :as p]]\n             (let [s (get r k)]\n               (if (nil? s)\n                 (conj r p)\n                 (assoc r k (o s v)))))\n           m\n           (reduce into [] l)))","user":"5742ec91e4b05c31a32c0883"},{"problem":69,"code":"(fn merge-with-a-func\n  [f & maps]\n  (reduce (fn [first-map next-map]\n            (reduce (fn [first-map key]\n                      (if (contains? first-map key)\n                        (assoc first-map key (f (first-map key) (next-map key)))\n                        (assoc first-map key (next-map key))))\n                    first-map\n                    (keys next-map)))\n          (first maps)\n          (rest maps)))","user":"5dadd84ee4b0f8c104ccfc85"},{"code":"(fn [f & x]\r\n  (reduce \r\n   #(reduce (fn [m [k v]]\r\n              (assoc m k (if (m k) (f (m k) v) v)))\r\n            %1 %2)\r\n          x))","problem":69,"user":"4f58d92fe4b0a7574ea71858"},{"problem":69,"code":"(fn [f & maps] (reduce (fn [r m] (reduce (fn [r k] (if (contains? r k) (assoc r k (f (r k) (m k))) (assoc r k (m k)))) r (keys m))) {} maps))","user":"5519c157e4b00ace28fe6e32"},{"problem":69,"code":"(fn btest [f acc & args]\n  (letfn [(mytest [a b]\n  (loop [r a\n         s b]\n    (if (empty? s)\n      r\n      (let [c (first s)]\n        (if (get a (first c))\n          (recur (assoc r (first c) (f (get r (first c)) (get b (first c)))) (rest s))\n          (recur (assoc r (first c) (second c)) (rest s)))))))]\n    (loop [accr acc\n           b args]\n      (if (empty? b)\n        accr\n        (recur (mytest accr (first b)) (rest b))))))","user":"5d1bbef0e4b02ea6f0fb6984"},{"code":"(fn my-merge-with [f & maps]  (reduce    (fn [a b]      (reduce        (fn [x [k v]]          (assoc x k (if (b k) (f v (b k)) v)))        b a))    (first maps) (rest maps)))","problem":69,"user":"50bc23e4e4b0594b91591c3c"},{"problem":69,"code":"(fn foo [f init & xs]\n  (reduce (fn [acc [k v]]\n            (assoc acc k\n                   (if-let [ov (get acc k)]\n                     (f ov v)\n                     v)))\n          init (apply concat xs)))","user":"5393185ae4b0b51d73faaeb7"},{"problem":69,"code":"(fn merge [f & arg_maps]\n\t(loop [maps (next arg_maps), res (first arg_maps)]\n\t\t(if (= nil (first maps))\n\t\t\tres\n\t\t\t(let [map2 (first maps),\n\t\t\t\tcommonkeys (keys (select-keys res (keys map2)))\n\t\t\t\tm1 (apply dissoc res commonkeys)\n\t\t\t\tm2 (apply dissoc map2 commonkeys)\n\t\t\t\tm3 (reduce #(assoc %1 %2 (f (res %2) (map2 %2))) {} commonkeys)\n\t\t\t\t]\n\t\t\t\t(prn m1 m2 m3)\n\t\t\t\t(recur \n\t\t\t\t\t(next maps)\n\t\t\t\t\t(conj m1 m2 m3)\n\t\t\t\t)\n\t\t\t)\n\t\t)\n\t\t\n\t)\n)","user":"5d73530ce4b02e6b30c93514"},{"problem":69,"code":"(fn mfunc [f & maps]\n  (let [merger (fn [coll item]\n                (let [k (key item)]\n                  (if (contains? coll k)\n                    (assoc coll k (f (get coll k) (val item)))\n                    (conj coll item)\n                   )))]\n    (reduce (fn [x y] (reduce merger x y)) maps)))","user":"53778b90e4b06839e8705e36"},{"code":"(fn merge-with- [f & maps]\n  (reduce (fn [m1 m2]\n            (reduce (fn [m1 k]\n                      (if (m1 k)\n                        (update-in m1 [k] f (m2 k))\n                        (assoc m1 k (m2 k))))\n                    m1 (keys m2)))\n          maps))","problem":69,"user":"4e5bff2b535d8a8b8723a2bd"},{"problem":69,"code":"(fn my-merge-with [f & maps]\n\t(when (some identity maps) \n\t\t(let [merge-entry (fn [m x]\n\t\t\t\t(let [k (key x) v (val x)]\n\t\t\t\t\t(if (contains? m k)\n\t\t\t\t\t\t(assoc m k (f (get m k) v))\n\t\t\t\t\t\t(assoc m k v))))\n\t\t\t  merge2 (fn [m1 m2]\n\t\t\t\t\t  (reduce merge-entry (or m1 {}) (seq m2)))]\n\t\t\t(reduce merge2 maps))))","user":"5405885ee4b0addc1aec6668"},{"problem":69,"code":"(fn [func & mps]\n  (reduce (fn [m1 m2]\n            (reduce (fn [m1 [k v]]\n                      (if (contains? m1 k)\n                        (update-in m1 [k] func v)\n                        (assoc m1 k v))) \n                    m1 m2))\n          mps))","user":"5b85221ce4b047b03b2037c8"},{"problem":69,"code":"(fn [f & maps]\n    (letfn [(mval [x y] (if (nil? x) y (f x y)))\n\t    (fassoc [mx [k v]] (assoc mx k (mval (mx k) v)))\n\t    (fmerge [mx my] (reduce fassoc mx (seq my)))]\n\t   (reduce fmerge maps)))","user":"55f09e7be4b06e875b46ce28"},{"problem":69,"code":"(fn [f & s] (reduce (fn [x y] (merge\n                               x\n                               (into {}\n                                     (map\n                                      #(let [a (get % 0)\n                                             b (get % 1)]\n                                         (if (contains? x a)\n                                           [a (f (x a) b)]\n                                           [a b]))\n                                      (into [] y)))))\n                    s))","user":"57ec3d29e4b0bfb2137f5b77"},{"code":"(fn [f & maps](reduce (fn[m1,m2] (reduce (fn [m [k v]] (assoc m k (if (contains? m k) (f (get m k) v) v))) m1 m2)) maps))","problem":69,"user":"531f1e63e4b08068f379edc2"},{"problem":69,"code":"(fn my-merge-with [f & maps]\n  (reduce (fn [m1 m2]\n            (let [common-keys (clojure.set/intersection (set (keys m1)) (set (keys m2)))\n                  mm (merge m1 m2)]\n              (reduce (fn [m k] (update-in m [k] (fn [x] (f (m1 k) (m2 k)))))\n                      mm\n                      common-keys)))\n          (first maps)\n          (rest maps)))","user":"5b47874be4b02d533a91bc70"},{"code":"(fn [f & maps] (reduce\n                   (fn [a b]\n                     (merge a (apply hash-map (mapcat\n                                               #(if (contains? a (first %))\n                                                  (vector (first %)\n                                                          (f\n                                                           (get a (first %))\n                                                           (get b (first %))))\n                                                  (vector (first %)\n                                                          (get b (first %)))\n                             ) b))))\n                   maps))","problem":69,"user":"4ebef65e535dfed6da9c6d9b"},{"problem":69,"code":"(fn [f & maps]\n  (let [modified-f (fn [& args]\n                     (if (= (count args) 1)\n                       (first args)\n                       (apply f args)))\n        map-keys (reduce #(concat % (set (keys %2))) #{} maps)\n        map-vals (map (fn [k]\n                      (apply modified-f (filter #(not (nil? %)) (map #(get % k) maps)))) map-keys)]\n    (zipmap map-keys map-vals)))","user":"5512aca6e4b055c2f668d4b4"},{"code":"(fn [f & ms]\n    (into {} (map (fn [v] (vector (first v) (if (= (count (second v)) 1) (first (second v)) (apply f (second v)) ))) \n                  (reduce (fn [mm m] \n              (into mm \n                    (map #(vector (first %) \n                                  ((fnil conj []) \n                                   (get mm (first %)) \n                                   (second %))) m))) \n            {} \n            ms))))","problem":69,"user":"52a32876e4b04e0c58e87bfb"},{"code":"(fn my-mw [f & maps]\n  (letfn [(mw [f, a, b]\n              (merge\n               b\n               (reduce\n                 (fn [acc, x]\n                   (assoc acc (nth x 0)\n                     (if (contains? b (nth x 0))\n                       (f (nth x 1) (get b (nth x 0)))\n                       (nth x 1))))\n                 {}\n                 a)))]\n    (reduce (partial mw f) maps)))","problem":69,"user":"51365524e4b04ac1f358dd52"},{"code":"(fn [f res & ss]\t\n\t(reduce \n\t\t(fn [res [k v]]\n\t\t\t(if (contains? res k)\n\t\t\t\t(assoc res k (f (res k) v))\n\t\t\t\t(assoc res k v)))\n\t\tres\n\t\t(for [s ss, i s] i)))","problem":69,"user":"520242bae4b030ee0c5b26e3"},{"problem":69,"code":"(fn merge-f\n  ([f fm cm]\n   (let [ff (fn [result k]\n        (if (contains? result k) \n          (conj result {k (f (result k) (cm k))})\n          (conj result {k (cm k)})\n          );if\n        )];ff\n     (reduce ff fm (keys cm))\n    );let\n   )\n  \n  ([f fm cm & ms]\n    (reduce #(merge-f f %1 %2) (merge-f f fm cm) ms) \n   )\n  );fn","user":"574ff497e4b02ea114799266"},{"code":"(fn [f & maps]\n  (reduce #(reduce\n            (fn [x [k v]]\n              (assoc x k\n                (if (contains? x k) (f (x k) v) v))) %1 %2)\n            {} maps))","problem":69,"user":"510acd6ee4b078ea719210f4"},{"problem":69,"code":"(fn [funct & args]\n   (reduce (fn [x y] (if (nil? x)\n                       (assoc {} (first y) (second y))\n                       (if (contains? x (first y))\n                         (assoc x (first y) (funct (get x (first y)) (second y)))\n                         (assoc x (first y) (second y))))) nil (reduce concat args)))","user":"5508102ee4b021ccfedb96b0"},{"code":"(fn [f & s] \n  (reduce (fn [m [k v]] \n            (assoc m k (if (m k) (f (m k) v) v))) \n          {} (mapcat seq s)))","problem":69,"user":"519ef784e4b087743fad2198"},{"code":"(fn [f & maps]\n  (when (some identity maps)\n    (let [merge-entry (fn [m e]\n\t\t\t(let [k (key e) v (val e)]\n\t\t\t  (if (contains? m k)\n\t\t\t    (assoc m k (f (get m k) v))\n\t\t\t    (assoc m k v))))\n          merge2 (fn [m1 m2]\n\t\t   (reduce merge-entry (or m1 {}) (seq m2)))]\n      (reduce merge2 maps))))","problem":69,"user":"51fe9d7ce4b0f1313d468a70"},{"problem":69,"code":"(fn\n  [f & maps]\n  (loop [all-keys (into #{} (flatten (map keys maps)))\n         reduced-map {}]\n    (if (empty? all-keys)\n      reduced-map\n      (recur (rest all-keys)\n             (assoc reduced-map (first all-keys) (reduce f (filter (complement nil?) (map #(get % (first all-keys)) maps))))))))","user":"594266cfe4b060784b3b790b"},{"code":"(fn [f & maps]\n  (reduce #(conj %\n                 (reduce (fn [r [k v]]\n                           (let [rv (get r k)]\n                             (assoc r k (if rv (f rv v) v)))) % %2))\n                 maps))","problem":69,"user":"51a49b21e4b0def3c5c58694"},{"problem":69,"code":"(fn [f & ms]\n  (->> (mapcat seq ms)\n       (reduce (fn [m [k v]]\n                 (if-let [v-current (m k)]\n                   (assoc m k (f v-current v))\n                   (assoc m k v)))\n               {})))","user":"59ef6cfae4b0966464fe6a32"},{"problem":69,"code":"(fn [f & maps]\n     (letfn [(mergeWith [m1 m2]\n                (let [filterFunction #(contains? m1 (first %))\n                      newItems (remove filterFunction m2)\n                      toMergedKeys (keys (filter filterFunction m2))\n                      mergeItems (into {} (map (fn [x] [x (f (m1 x) (m2 x))]) toMergedKeys))]\n                  (into m1 [newItems mergeItems])))]\n     (reduce mergeWith maps)))","user":"53c38b8ce4b00fb29b22127b"},{"code":"(fn merge-with-function [f m1 & ms]\n  (cond\n    (seq ms) (let [m2 (first ms)\n                   m-new (into m1\n                               (for [[k v] m2]\n                                 (if (m1 k)\n                                   [k (f (m1 k) v)]\n                                   [k v])))]\n               (apply (partial merge-with-function f m-new) (rest ms)))\n    :else m1))","problem":69,"user":"52606318e4b03e8d9a4a7036"},{"problem":69,"code":"(fn [g & ms]\n            (let [smoosh (fn [m1 m2]\n                           (let [ks (->> [m1 m2]\n                                         (map (comp set keys))\n                                         (apply clojure.set/union))]\n                             (->> (for [k ks]\n                                    (let [vs (->> [m1 m2]\n                                                  (map (fn [m] (get m k)))\n                                                  (filter identity))]\n                                      [k (if (== 1 (count vs))\n                                           (first vs)\n                                           (apply g vs))]))\n                                  (into {}))))]\n              (reduce smoosh ms)))","user":"53684a2fe4b0243289761e8c"},{"code":"(fn [func initial-map & rest]\n  (reduce #(let [map-key (first %2)\n                 new-val (last %2)\n                 init-val (initial-map map-key)]\n             (conj %1 {map-key (if (nil? init-val)\n                                    new-val\n                                    (func init-val new-val))})) initial-map (apply merge rest)))","problem":69,"user":"523288fee4b035af41902a88"},{"problem":69,"code":"(fn [f & ms]\n       (reduce #(into %1 (map (fn [[k v]][k (if (%1 k) (f (%1 k) v) v)]) %2)) ms))","user":"567c63f6e4b05957ce8c61bb"},{"code":"(fn merge-with*\n    ([f m1] m1)\n    ([f m1 m2 & r]\n       (apply merge-with* f\n              (reduce (fn [acc [k v]]\n                        (if (acc k)\n                          (assoc acc k (f (acc k) v))\n                          (assoc acc k v)))\n                      m1\n                      m2)\n              r)))","problem":69,"user":"4daea889edd6309eace4d15b"},{"code":"(fn r ([f x y] (reduce #(if (% %2) \n  (assoc % %2 (f (% %2) (y %2))) \n  (assoc % %2 (y %2))) x (keys y)))\n  ([f x y & more] \n    (if (empty? more) (r f x y)\n      (recur f (r f x y) (first more) (next more)))))","problem":69,"user":"4ec5d62c535d6d7199dd36ba"},{"problem":69,"code":"(fn __ [f & x]\n\t(\n\t\treduce\n\t\t(fn [a b]\n\t\t\t(reduce-kv\n\t\t\t\t#(assoc\n\t\t\t\t\t %1\n\t\t\t\t\t %2\n\t\t\t\t\t (if (contains? %1 %2)\n\t\t\t\t\t\t (f (get %1 %2) %3)\n\t\t\t\t\t\t %3\n\t\t\t\t\t\t )\n\t\t\t\t\t )\n\t\t\t\ta\n\t\t\t\tb\n\t\t\t\t)\n\t\t\t)\n\t\t{}\n\t\tx\n\t\t)\n\t)","user":"575dda55e4b02ea11479938c"},{"problem":69,"code":"(fn [f & maps]\n  (when (some identity maps)\n    (let [merge-entry (fn [m e]\n\t\t\t\t\t\t(let [k (key e) v (val e)]\n\t\t\t  \t\t      (if (contains? m k)\n\t\t\t    \t\t\t(assoc m k (f (get m k) v))\n\t\t\t   \t\t\t\t(assoc m k v))))\n          merge2 (fn [m1 m2]\n\t\t  \t\t   (reduce merge-entry (or m1 {}) (seq m2)))]\n      (reduce merge2 maps))))","user":"4ebbc1f6535dfed6da9c6d72"},{"problem":69,"code":"(fn [f & ms]\n  (into {}\n    (map (fn [[k v]] [k (reduce f (map second v))])\n      (group-by first (mapcat (partial map identity) ms)))))","user":"56228d00e4b03f08ee9a9227"},{"code":"(fn [f & s]\n  (reduce (fn [agg k]\n            (let [vs (remove nil? (map #(get % k) s))]\n              (into agg {k (if (> (count vs) 1)\n                             (apply f vs)\n                             (first vs))})))\n          {}\n          (set (mapcat keys s))))","problem":69,"user":"4daeabf6edd6309eace4d15c"},{"code":"(fn  [op & maps]\r\n (reduce (fn  [m1 m2]\r\n           (reduce (fn [m [k v]]\r\n                     (if (contains? m k) (update-in m [k] op v)\r\n                       (assoc m k v))\r\n                    ) \r\n                     m1\r\n                       m2)\r\n           ) \r\n         maps)\r\n  )","problem":69,"user":"5060c117e4b024449d699b5d"},{"problem":69,"code":"(fn [f & M] (reduce (fn [R m] (reduce-kv (fn [r k v] (assoc r k (if-let [u (r k)] (f u v) v))) R m)) {} M))","user":"55f6fe09e4b06e875b46cea2"},{"problem":69,"code":";; first solution\n;(fn [f & maps]\n;  (reduce\n;   (fn [m1 m2]\n;     (into {} (for [k (keys (merge m1 m2))\n;                    :let [vs (filter identity [(m1 k) (m2 k)])]]\n;                (if (second vs)\n;                  [k (apply f vs)]\n;                  [k (first vs)]))))\n;   {} maps))\n\n(fn [f & maps]\n  (letfn [(merge-two-maps [to from] (reduce merge-kv-pairs to from))\n          (merge-kv-pairs [m [k v]] \n                          (if (contains? m k) \n                            (assoc m k (f (m k) v)) \n                            (assoc m k v)))]\n    (reduce merge-two-maps {} maps)))","user":"573118ebe4b0cd1946bd0fbd"},{"code":"(fn mergewith [f m & ms]\n  (reduce (fn [mi mo]\n            (reduce (fn [mi [k v]]\n                      (assoc mi k (if (contains? mi k)\n                                    (f (mi k) v)\n                                    v)))\n                    mi mo))\n          m\n          ms))","problem":69,"user":"4f35b2ace4b0e243712b1ec5"},{"code":"(fn [f & maps]\n  (prn maps)\n  (reduce (fn [rt m]\n       (reduce #(let [old (get %1 (first %2))]\n              (conj %1\n               (if old\n                 [(first %2) (f old (second %2))]\n                 %2))) rt m))\n     (first maps) (rest maps)))","problem":69,"user":"4ef992c8535dced4c769f268"},{"problem":69,"code":"(fn [f & ms]\n  (reduce\n   (fn [a m]\n     (reduce\n      (fn [na [k v]]\n        (if (contains? na k)\n          (assoc na k (f (get na k) v))\n          (assoc na k v)))\n      a m))\n   ms))","user":"56efb3a3e4b04a395b9a0463"},{"problem":69,"code":"(fn [op x & y]\n  (loop [ x x\n         y y]\n    (if (seq y)\n     (recur\n            (reduce-kv (fn [r k v] (assoc r k\n                                          (if (x k)\n                                            (op (x k) v)\n                                            v)))\n                 x (first y))\n            (rest y))\n     x)))","user":"5b9ae606e4b0c0b3ffbd4af2"},{"problem":69,"code":"(fn [f m & ms]\n  (reduce (fn [m m']\n            (reduce (fn [a [k v]]\n                      (if (contains? a k)\n                        (assoc a k (f (get m k) v))\n                        (assoc a k v)))\n                    m\n                    m'))\n          m\n          ms))","user":"52173464e4b082aa80a88c75"},{"code":"(fn [f & r]\n\t\t(let [z (reduce (fn [c l]\n\t\t\t\t\t(reduce (fn [cc [k v]]\n\t\t\t\t\t\t\t\t(assoc cc k (conj (get cc k '()) v)))\n\t\t\t\t\t\t\tc l)) {} r)]\n\t\t  (reduce (fn [c [k v]] (assoc c k (reduce f (reverse v)))) {} z)))","problem":69,"user":"51f2851fe4b0210f90e7454b"},{"problem":69,"code":"(fn [f m1 & more]\n\t(letfn [(merge-map [m1 m2]\n\t\t(reduce\n\t\t\t#(merge %1 \n\t\t\t\t(if-let [v (get %1 (key %2))]\n\t\t\t\t\t{(key %2) (f v (val %2))}\n\t\t\t\t\t{(key %2) (val %2)}))\n\t\t\tm1\n\t\t\tm2))]\n\t\t(loop [m-coll more, result m1]\n\t\t\t(if (empty? m-coll)\n\t\t\t\tresult\n\t\t\t\t(recur (rest m-coll) (merge-map result (first m-coll)))))))","user":"5370b386e4b0fc7073fd6e9b"},{"code":"(fn mergew [f & ms]\n  (loop [m ms out {}]\n    (if (empty? m) out\n    (recur (rest m) (into out (map \n      #(let [k (first %) v (second %)] \n        (if (contains? out k) [k (f (out k) v)] [k v])) (first m)))))))","problem":69,"user":"4fcf642ee4b03432b189f410"},{"problem":69,"code":"(fn mw \n  [fun init & r]\n  (reduce \n    #(reduce-kv  \n       (fn [m k v]\n         (if-not (get m k)\n           (assoc m k v) ;then\n           (assoc m k (fun (get m k) v)) ;else\n           )\n         )\n       %1 %2)\n    init\n    r\n    ) \n  )","user":"5ac92dc3e4b0e27600da77bf"},{"problem":69,"code":"(fn [f fst & other]\n  ((fn merge-iter [result rst]\n     (if (empty? rst) result\n       (let [cur (first rst)]\n         (merge-iter ((fn merge-single [m merged]\n                        (if (empty? m) merged\n                            (let [[k v] (first m)]\n                              (merge-single (rest m) (assoc merged k (if (merged k) (f (merged k) v) v)))))) cur result) (rest rst))))) fst other))","user":"58f98231e4b0438e51c2cf4c"},{"problem":69,"code":"(fn [f m & ms]\n  (reduce (fn [acc el]\n            (reduce (fn [t [k v]]\n                      (update-in t [k]\n                                 #(if % (f % v) v)))\n                    acc el))\n          m ms))","user":"5169d422e4b051e2a73aba53"},{"problem":69,"code":"(fn [f & maps]\n  (let [merge-entry (fn [m [k v]]                      \n                      (if (contains? m k)\n                        (assoc m k (f (get m k) v))\n                        (assoc m k v)))\n        merge2 (fn [m1 m2]\n                 (reduce merge-entry m1 (seq m2)))]\n    (reduce merge2 maps)))","user":"550615c0e4b021ccfedb9696"},{"problem":69,"code":"(fn [f & maps]\n  (reduce \n    (fn [cur sec]\n      (reduce \n        (fn [trd [k v]]\n          (assoc trd k\n            (let [pv (get trd k ::none)]\n              (if (= pv ::none)\n                 v\n                 (f pv v)))))\n       cur\n       sec))\n   maps))","user":"4dac39a28cc9d6edb8beb0b3"},{"code":"(fn [f m & ms]\n  (reduce \n    (fn [m1 m2]\n      (reduce\n        #(if (% %2) \n             (update-in % [%2] f (m2 %2))\n             (assoc % %2 (m2 %2)))\n         m1\n        (keys m2)))\n    m\n    ms))","problem":69,"user":"5054c7e1e4b0b1b9d1860eb2"},{"code":"(fn [fn & xs]\n   (let [grouped (group-by first (mapcat seq xs))\n         mapred #(list (first %) (reduce fn (map second (second %))))]\n     (apply hash-map (mapcat mapred grouped))))","problem":69,"user":"4f4f0287e4b03ad3f0c10cd7"},{"problem":69,"code":"(fn [f & ms]\n    (into {}\n      (for [k (distinct (mapcat keys ms))]\n        [k (->> ms\n                (map #(% k))\n                (filter identity)\n                (reduce f))])))","user":"55f081bbe4b06e875b46ce25"},{"problem":69,"code":"(fn [f & maps]\n    (->> maps\n         (map #(into [] %))\n         (apply concat)\n         (group-by first)\n         (map (fn [[key vals]]\n                [key (if (> (count vals) 1)\n                       (apply f (map last vals))\n                       (last (last vals)))]))\n         (into {})))","user":"58bbcbc8e4b0888cdc949d00"},{"code":"(fn foo\n   ([f t] t)\n   ([f t m]\n      (reduce\n       (fn [m [k v]]\n         (update-in m [k] (fn [x] (if (nil? x) v (f x v)))))\n       t\n       m))\n   ([f t m & ms]\n      (apply foo f (foo f t m) ms)))","problem":69,"user":"4fc8c8d8e4b0ee37620e183b"},{"problem":69,"code":"(fn [f & args]\n   (let [k (keys (apply merge args))]\n     (into {} (map (fn [x]\n                     {x (reduce f\n                          (filter #(not (nil? %))\n                            (map #(get % x) args)))})\n                   k))))","user":"572de985e4b0cd1946bd0f7c"},{"code":"(fn mrgw [f & maps]  \n  (letfn [(mrgw2 [m1 m2]\n          (letfn [(merge-value [k v] (if (contains? m1 k) (f (m1 k) v) v))]\n                 (into m1 (for [[k v] m2] [k (merge-value k v)]))))]   \n    \t(reduce mrgw2 maps)))","problem":69,"user":"51729002e4b044b2ef48a850"},{"problem":69,"code":"( fn [f & maps]\n   (let [mergein (fn [f m1 m2]  (reduce  #(if (contains? %1 %2) (assoc %1 %2 (f (%1 %2)(m2 %2)))(assoc %1 %2 (m2 %2)))  m1 (keys m2)) )]\n     (reduce #(mergein f %1 %2) {} maps )\n    )\n )","user":"5649615be4b0284900eef641"},{"problem":69,"code":"(fn [f & ms] \n    (let [merge (fn [l r]\n                  (cond (empty? l) r\n                        (empty? r) l\n                        :else (let [ks (set (mapcat keys [l r]))\n                                    in-l (map #(contains? l %) ks)\n                                    in-r (map #(contains? r %) ks)]\n                                (zipmap ks \n                                        (map #(if %1 (if %2 (f (l %3) (r %3)) (l %3)) (r %3)) in-l in-r ks)))))]\n      (reduce merge ms)))","user":"52950ab6e4b02ebb4ef7501a"},{"code":"(fn p [f & m]\n  (if (= 1 (count m))\n    (first m)\n    (letfn [(w [x y z]\n                (if (empty? z)\n                  x\n                  (let [k (first z)]\n                    (if (find x k)\n                      (w (update-in x [k] f (get y k)) y (rest z))\n                      (w (merge x (find y k)) y (rest z))))))]\n      (apply p f (w (first m) (second m) (keys (second m))) (drop 2 m)))))","problem":69,"user":"507ef25ce4b0f753b6f9788e"},{"problem":69,"code":"(fn [f map & maps]\n      (reduce #(reduce-kv (fn [m k v]\n                            (assoc m k (if (contains? m k)\n                                         (f (m k) v)\n                                         v)))\n                          %1 %2)\n              map maps))","user":"58c4b11ae4b021aa9917ed2c"},{"code":"(fn [op & ms]\n  (letfn ([mrg [o n]\n    (apply assoc o\n      (reduce concat\n        (for [e n \n          :let [k (e 0)] \n          :let [oe (find o k)]]\n          (list k (if oe (op (oe 1) (e 1)) (e 1))))))])\n  (reduce mrg ms)))","problem":69,"user":"4f050dec535dcb61093f6bef"},{"problem":69,"code":"(fn my-merge-with [f & m]\n  (letfn [(conj-with [f m1 m2]\n    (reduce (fn [z h]\n      (let [v (get z (first h))]\n        (cond v (conj z {(first h) (f v (last h))})\n              :else (conj z h))))\n      m1\n      m2))]\n      (reduce (partial conj-with f) m)))","user":"5b15811ee4b0cc2b61a3be6f"},{"problem":69,"code":"(fn my-merge-with [f & maps]\n  (reduce (fn [map1 map2]\n            (reduce (fn [map [key value]]\n                      (if (contains? map key)\n                        (update-in map [key] f value)\n                        (assoc map key value)))\n                    map1 map2))\n          maps))","user":"58ed713de4b056aecfd47d84"},{"problem":69,"code":"(fn [op & inputs]\n (let [ks (->> (map keys inputs) (reduce concat) distinct)]\n  (zipmap ks (map #(->> (map (fn [in] (get in %)) inputs) (remove nil?) (reduce op)) ks))\n  ))","user":"56f974c0e4b07572ad1a88b1"},{"problem":69,"code":"(fn [f & ms]\n  (into {}\n       (map (fn [[k v]] [k (if (= 1 (count v))\n                             (first v)\n                             (apply f v))])\n            (reduce (fn [acc [k v]] (assoc acc k (cons v (acc k))))\n                    {}\n                    (reverse (reduce into [] ms))))))","user":"508923d5e4b06d8254e936e8"},{"code":"(fn mw [f ret & maps]\n (if (empty? maps)\n  ret\n  (let\n   [\n    m (first maps)\n    r (rest maps)\n    md (reduce\n     (fn [ret [k v]]\n      (if (ret k)\n       (assoc ret k (f (get ret k) v))\n       (assoc ret k v)))\n     ret m)\n    ]\n   (apply mw f md (rest maps)))))","problem":69,"user":"506fd0afe4b07bd6ad9b9f23"},{"problem":69,"code":"(fn [f m & args]\n  (let [insert (fn [m [k v]]\n                 (if (contains? m k)\n                   (assoc m k (f (m k) v))\n                   (assoc m k v)))\n        merge* (fn [a b]\n                 (reduce insert a b))]\n    (reduce merge* m args)))","user":"545e7ab0e4b01be26fd7467c"},{"code":"(fn [f & [h & rest]] (reduce #(reduce (fn [acc [k v]] (if (contains? acc k) (assoc acc k (f (acc k) v)) (assoc acc k v) )) % %2) h rest))","problem":69,"user":"52265e41e4b04e78ff2e1981"},{"problem":69,"code":"(fn [f & ms] (reduce (fn [r m] (into r (for [[k v] m] (if (contains? r k) [k (f (get r k) v)] [k v])))) {} ms))","user":"5d47f4dbe4b07c84aa5ae6b5"},{"code":"(fn [f & args]\n    (reduce (fn[map1 map2]\n              (reduce (fn [m [k v]]\n                        (if-let [vv (m k)]\n                          (assoc m k (f vv v))\n                          (assoc m k v)))\n                      map1 map2))\n            args))","problem":69,"user":"52e3e6a8e4b09f7907dd1448"},{"code":"#_ (fn mrgwth [f & maps]\n  (reduce\n    #(reduce\n      (fn [m [k v]]\n        (if-let [oldV (get m k)]\n          (assoc m k (f oldV v))\n          (assoc m k v)))\n      %1 %2)\n    maps))\n\n(fn mrgwth [f & maps]\n  (reduce\n    #(reduce\n      (fn [m [k v]]\n        (assoc m k\n          (if-let [oldV (m k)]\n            (f oldV v)\n            v)))\n      %1 %2)\n    maps))","problem":69,"user":"4fe8b6afe4b07c9f6fd12c76"},{"code":"(fn __ [fun & ms]\r\n  (let [g (fn g [m1 m2]\r\n        (reduce (fn [m1 [k v]] (assoc m1 k  (if (nil? (get m1 k)) v\r\n                                (fun (m1 k)  v)))) m1 m2))]\r\n       (reduce g {} ms)))","problem":69,"user":"4f04a06d535dcb61093f6bd9"},{"code":"(fn [f & v]\n   (reduce\n    #(reduce\n      (fn [o [k v]]\n        (persistent!\n         (assoc!\n          (transient o)\n          k\n          (if (o k)\n            (f (o k) v)\n            v))))\n      % %2)\n    v))","problem":69,"user":"4f9fe2b9e4b0dcca54ed6d40"},{"code":"(fn [f & ms] (->> (apply concat ms)\n                  (group-by key)\n                  (reduce #(assoc % (key %2) (vals (val %2))) {})\n                  (reduce #(assoc % (key %2) (reduce f (val %2))) {})))","problem":69,"user":"4fa05b99e4b0dcca54ed6d47"},{"problem":69,"code":"(fn [f coll & colls]\n  (reduce (fn [out x] (reduce #(let [k (first %2)\n                                     v (get % k)]\n                                 (if v\n                                   (assoc % k (f v (second %2)))\n                                   (conj % %2)))\n                              out\n                              x))\n          coll\n          colls))","user":"5f03ab5be4b0cf489e8d7f37"},{"code":"(fn mergef [f m1 & ms]\n  (if (or (nil? ms) (empty? ms)) m1\n    (let [[m2 & m3] ms\n       m (reduce #(let [[k v] %2] (assoc %1 k (if (contains? %1 k) (f (%1 k) v) v))) m1 m2)]\n    (apply mergef f m m3))))","problem":69,"user":"4effb663535dcb61093f6a2e"},{"problem":69,"code":"(fn merg \n   [f a & bs] \n   (if (= 0 (count bs))\n     a\n     (let [[b & rest] bs]\n       (recur\n         f\n         (into (hash-map)\n          (concat\n            (for [[k v] a\n                  :when (not (contains? b k))]\n              [k v])\n            (for [[k v] b]\n              [k\n                (if (contains? a k)\n                  (f (get a k) v)\n                  v)])))\n         rest))))","user":"58fc92c5e4b0438e51c2cf9a"},{"code":"(fn [func & maps]\n  (reduce (fn [a x]\n            (reduce-kv (fn [acc k v]\n                         (if (contains? acc k)\n                           (assoc acc k (func (get acc k) v))\n                           (assoc acc k v)))\n                       a x))\n          maps))","problem":69,"user":"5245aea8e4b08ba239308123"},{"code":"(fn [o & m] (reduce (fn [a b] (apply merge a (for [[k v] b] (assoc {} k (if (a k) (o (a k) v) v))))) m))","problem":69,"user":"50ed4626e4b01236b1d4983c"},{"code":"(fn merge-with* [f & maps]\n  (loop [m1 (first maps)\n         m2 (second maps)\n         ms (nnext maps)]\n    (if (or m2 ms)\n      (recur (reduce #(let [[k v] %2]\n                        (if (contains? %1 k)\n                          (update-in %1 [k] f v)\n                          (conj %1 %2)))\n                     m1\n                     m2)\n             (first ms)\n             (next ms))\n      m1)))","problem":69,"user":"52ab6de1e4b0c58976d9ac78"},{"problem":69,"code":"(fn [f & ms] \n    (reduce (fn [m1 m2]\n                (reduce (fn [m [k v]]\n                            (if (contains? m k)\n                                (assoc m k (f (m k) v))\n                                (assoc m k v)))\n                        m1 m2))\n            ms))","user":"5ef4fca7e4b07c55ae4a0546"},{"code":"(fn [f & c]\n  (reduce (fn [m [k v]]\n            (update-in m [k] #(if (nil? %1) %2 (f %1 %2)) v)) {} (apply concat c)))","problem":69,"user":"4fbf2818e4b081705acca317"},{"code":"(fn [f & maps] \n  (reduce #(conj %1\n    (reduce (fn [m [k v]] \n              (let [mv (get m k)] (assoc m k (if mv (f mv v) v)))) %1 %2))\n          maps))","problem":69,"user":"52976262e4b02ebb4ef75041"},{"problem":69,"code":"(fn [f & maps]\n  (apply merge (for [[k v] (reduce\n                       #(let [[k v] %2] (assoc %1 k (conj (get %1 k []) v)))\n                       {}\n                       (apply concat  (map seq maps)))] {k (reduce f v)})))","user":"5b100648e4b0cc2b61a3be17"},{"problem":69,"code":"(fn [f head & tail]\n  (reduce (fn [acc it]\n            (apply\n              (partial merge acc it)\n              (for [[k1 v1] acc\n                    [k2 v2] it\n                    :when (= k1 k2)\n                    :let [z (f v1 v2)]]\n                {k2 z})))\n          head tail))","user":"561ba3e5e4b073c65b0ce3eb"},{"problem":69,"code":"(fn [f v0 & vs]\n  (reduce\n    (fn [so-far m]\n      (reduce\n        (fn [now [k v]]\n          (assoc now k (if (now k) (f (now k) v) v)))\n        so-far m))\n    v0\n    vs))","user":"5416b4a2e4b01498b1a71a01"},{"problem":69,"code":"(fn [f & args] \n  (reduce (fn [coll x] \n            (reduce-kv #(if (contains? %1 %2)\n                            (assoc %1 %2 (f (%1 %2) %3))\n                            (assoc %1 %2 %3)) coll x)) \n          {} \n          args))","user":"546692aee4b01be26fd746e7"},{"code":"(fn [f & n]\n  (reduce\n   (fn [m s]\n     (reduce\n      #(let [[k v] %2]\n         (assoc % k \n           (if (contains? % k)\n               (f (% k) v)\n               v)))\n      m\n      s))\n   (first n)\n   (rest n)))","problem":69,"user":"4ec53f8c535d6d7199dd368b"},{"code":"(fn [f & maps]\n   (when (some identity maps)\n    (let [merge-entry (fn [m e]\n\t\t\t(let [k (key e) v (val e)]\n\t\t\t  (if (contains? m k)\n\t\t\t    (assoc m k (f (get m k) v))\n\t\t\t    (assoc m k v))))\n          merge2 (fn [m1 m2]\n\t\t   (reduce merge-entry (or m1 {}) (seq m2)))]\n      (reduce merge2 maps))))","problem":69,"user":"5166e80de4b060c690c1f4c5"},{"problem":69,"code":"(fn __ [f & maps]\n  (->> maps \n       (mapcat vec)\n       (reduce\n          (fn [acc [k v]]\n            (update-in acc [k] #(if % (f % v) v))) {})))","user":"55916764e4b0604b3f94d57b"},{"code":"(fn [f & xs]\n    (reduce\n      (fn [r [k v]]\n        (if (r k)\n           (assoc r k (f (r k) v))\n           (assoc r k v) ))\n      {} (apply concat xs ) )\n   )","problem":69,"user":"519b7d76e4b02a926d9a436e"},{"problem":69,"code":"(fn [f & maps]\n  (reduce (fn [acc m]\n            (reduce (fn [m [k v]]\n                      (if (contains? m k)\n                        (assoc m k (f (get m k) v))\n                        (assoc m k v)))\n                    acc\n                    m))\n          maps))","user":"53576356e4b04ce2eb3ed27a"},{"code":"(fn [op & args] \n  (reduce \n    (fn [a [k x]] \n      (if (contains? a k) \n        (assoc a k (op (a k) x)) \n        (assoc a k x))) \n    {} (apply concat args)))","problem":69,"user":"5201572be4b0d7096e99ddbb"},{"problem":69,"code":"(fn [f & ms]\n  (let [all-keys         (keys (apply merge ms))\n        count-containing (fn [k] (count (filter #(contains? % k) ms)))\n        count-per-key    (into {} (map (fn [k] [k (count-containing k)]) all-keys))]\n    (into {} \n        (map\n            (fn [k]\n                (if (= 1 (count-per-key k))\n                    [k (some #(get % k) ms)]\n                    [k (reduce f (filter #(not (nil? %)) (map #(get % k) ms)))]))\n            all-keys))\n  ))","user":"57717915e4b0979f896515b3"},{"problem":69,"code":"(fn _mymergewith\n    ([func m1 m2 & maps]\n     ; Take care of more than two maps\n     (_mymergewith\n       func m1 (apply _mymergewith func m2 (first maps) (rest maps))))\n    ([func m1 m2]\n     (loop [result m1 m2part m2]\n       (if (empty? m2part)\n         result\n         (let [[k v] (first m2part)\n               resultval (get result k)]\n           (if (nil? resultval)\n             (recur (assoc result k v) (rest m2part))\n             (recur (assoc result k (func resultval v)) (rest m2part))))))))","user":"56eaad95e4b04a395b9a040f"},{"code":"(fn mw\n  ([f m] m)\n  ([f m1 m2 & ms] (apply mw (cons f (cons (merge m1 (into {} (for [[k v] m2] (if (contains? m1 k) [k (f (m1 k) v)] [k v])))) ms)))))","problem":69,"user":"4e9a1512535dbda64a6f6b6e"},{"code":"(fn [f & xs]\n  (reduce #(reduce (fn [acc [k v]] (let [kv (find acc k)] (if (empty? kv) (assoc acc k v) (assoc acc k (f (val kv) v))))) %1 %2) {} xs))","problem":69,"user":"52618ea3e4b03e8d9a4a7064"},{"code":"(fn [o & m] \n  (reduce \n    (fn [r [k v]] \n      (assoc r k \n        (if \n          (r k) \n          (o (r k) v) \n          v)))\n    {}\n    (apply concat m)))","problem":69,"user":"4f991ec1e4b0dcca54ed6cfb"},{"code":"(fn [f m & ms]\r\n  (reduce \r\n    (fn [ret x]\r\n      (reduce \r\n        (fn [r k] \r\n          (conj r (if (r k) [k (f (r k) (x k))] (find x k)))) \r\n        ret (keys x))) \r\n    (cons m ms)))","problem":69,"user":"4dc986d0535d5973398f9285"},{"problem":69,"code":"(fn [f & ms]\n  (reduce\n   (fn walk [res [[k v] & xs]]\n     (if k\n      (if (res k)\n        (recur (assoc res k (f (res k) v)) xs)\n        (recur (assoc res k v) xs))\n       res))\n   (first ms)\n   (map vec (rest ms))))","user":"571c2babe4b07c98581c3b73"},{"problem":69,"code":"(fn z [f m & args]\n  (let [x (fn [m1 m2]\n            (reduce\n               #(if (contains? %1 (first %2))\n                  (update-in %1 [(first %2)] f (second %2))\n                  (conj %1 [(first %2) (second %2)]))\n             \tm1\n             \tm2))]\n    (loop [m m args args]\n      (if (empty? args)\n        m\n        (recur (x m (first args)) (rest args))))))","user":"583667c7e4b089d5ab817cfb"},{"problem":69,"code":"(fn [f & maps]\n  (reduce #(loop [[k & ks] (keys %2)\n                  out      %1]\n             (if (not k) out\n                 (recur ks (assoc out k (if-let [v (%1 k)]\n                                          (f v (%2 k))\n                                          (%2 k))))))\n          maps))","user":"55d0e76ae4b0e31453f64a40"},{"code":"(fn [f & m]                                \n  (into {}                                 \n    (map (fn [[a b]]                       \n            [a (reduce f (map second b))]) \n         (group-by first (mapcat vec m)))))","problem":69,"user":"4f9d8083e4b0dcca54ed6d23"},{"problem":69,"code":"(fn [f m & ms]\n  (reduce (fn [acc n]\n            (merge acc (into {}\n                             (for [[k v] n]\n                               {k (if (get acc\n                                           k)\n                                    (f (get acc\n                                            k)\n                                       v)\n                                    v)}))))\n          m\n          ms))","user":"57cf9de8e4b00451144b0503"},{"problem":69,"code":"(fn my-merge-with\n  ([f coll1 coll2]\n   (loop [re {}\n          col coll2\n          cur (first coll2)\n          cur-key (key cur)\n          cur-value (get coll2 cur-key)]\n     (if (empty? col)\n       re\n       (if (contains? coll1 cur-key)\n         (recur (assoc re cur-key (f (get coll1 cur-key) cur-value))\n                (dissoc col cur-key)\n                (first col)\n                (key (first col))\n                (get col (key (first col))))\n         (assoc re cur-key cur-value)))))\n  ([f coll1 coll2 & colls]\n   (my-merge-with f coll1 (apply merge coll2 colls))))","user":"59b9e669e4b0a024fb6ae3db"},{"problem":69,"code":"(fn [f m & ms]\n  (reduce \n   (fn [n o] \n     (into n \n           (map \n                (fn [[k v]]\n                  (if (contains? n k)\n                    [k (f (n k) v)]\n                    [k v]))\n                o)))\n   m ms))","user":"552d9b31e4b076ab5578f7eb"},{"code":"(fn [f & maps]\n  (reduce\n    (fn [acc m]\n      (reduce\n        (fn [acc k] (if (contains? acc k)\n          (assoc acc k (f (acc k) (m k)))\n          (assoc acc k (m k))\n        ))\n        acc\n        (keys m)\n      )\n    )\n    maps\n  )\n)","problem":69,"user":"4ea57300535d7eef308072d5"},{"problem":69,"code":"(fn mapMerge [f & maps]\n  (reduce\n    (fn partialmerge [m1 m2]\n      (reduce-kv\n        (fn [i k v]\n          (if (contains? i k)\n            (assoc i k (f (i k) v))\n            (assoc i k v)\n            )\n          )\n        m1 m2))\n    maps))","user":"562add6de4b00e49c7cb4834"},{"problem":69,"code":"(fn [f acc & coll]\n  (reduce (fn [m xs]\n            (reduce-kv (fn [m2 k v]\n                         (if-let [v2 (get m2 k)]\n                           (assoc m2 k (f v2 v))\n                           (assoc m2 k v)))\n                       m\n                       xs))\n          acc\n          coll))","user":"53e9dce1e4b036ad0777e4bc"},{"problem":69,"code":"(fn [f c & cs]\n  (reduce (fn [result input]\n              (reduce (fn [result input]\n                        (if (contains? result (key input))\n                          (assoc result (key input) (f (get result (key input)) (val input)))\n                          (assoc result (key input) (val input))))\n                      result input)) \n          c cs))","user":"5cbb0436e4b026601754b9cc"},{"problem":69,"code":"(fn [f b & more] (reduce (fn [m1 m2] (into (conj m1 m2)\n(for [x (keys m1) y (keys m2)] (if (= x y) [x (f (m1 x)  (m2 y))] )))) b more))","user":"6076adb2e4b069485764de60"},{"code":"(fn[f & maps] \n    (loop[ms maps r {}] \n      (if(empty? ms) \n        r \n        (let[fm (first ms) \n             ff (fn[m r] \n                  (loop[ks (keys m) rr r] \n                    (if(empty? ks) \n                      rr \n                      (let[k (first ks)] \n                        (if(contains? rr k) \n                          (recur (rest ks) (assoc rr k (f (get rr k) (get m k)))) \n                          (recur (rest ks) (assoc rr k (get m k)))\n                          )\n                        )\n                      )\n                    ) \n                  )\n             ] \n          (recur (rest ms) (ff fm r))))\n      )\n    )","problem":69,"user":"52e68e61e4b09f7907dd1479"},{"problem":69,"code":"(fn [f & ms]\n  (when (seq ms)\n    (let [helper (fn [m1 m2]\n                   (-> (for [k (clojure.set/union (set (keys m2)) (set (keys m1)))]\n                         (let [org (get m1 k)\n                               new (get m2 k)]\n                             (if (and org new)\n                                (hash-map k (f org new))\n                                (hash-map k (or org new)))\n                       \t))\n                      (doto println)\n                     (#(reduce merge %))))  \n                        \n                     ]\n      (reduce helper ms))))","user":"51533ecde4b0252ac4b16619"},{"code":"(fn [f & s]\n  (let [allkeys (set (mapcat keys s))\n        projector (fn [v] (map (fn [m] (get m v)) s))\n        allvals (map projector allkeys)\n        nonnil-vals (map #(filter identity %) allvals)\n        func (fn [v] (if (>= 1 (count v)) (first v) (apply f v)))\n        allmerged (map func nonnil-vals)]\n    (zipmap allkeys allmerged)\n    )\n  )","problem":69,"user":"523f0bbfe4b01c266ffa7f91"},{"problem":69,"code":"(fn [f & xs] (reduce #(reduce-kv (fn [m k v] (if (get m k) (update-in m [k] f v) (assoc m k v))) %1 %2) xs))","user":"57d418b4e4b0bd073c20239a"},{"problem":69,"code":"(fn f [f m & args]\n\t(loop [a (apply concat (map seq args)) m m]\n\t\t(if (empty? a)\n\t\t\tm\n\t\t\t(recur \n\t\t\t\t(rest a) \n\t\t\t\t(if (contains? m (first (first a)))\n\t\t\t\t\t(assoc m (first (first a)) (f (m (first (first a))) (second (first a))))\n\t\t\t\t\t(assoc m (first (first a)) (second (first a))))))))","user":"563d12f9e4b0bfe05bf11845"},{"code":"(fn [f & maps]\n    (let [all-keys (reduce into (map keys maps))]\n  (reduce\n    (fn [c k]\n      (assoc c k\n        (let [ms (reduce (fn [c2 m]\n                            (if-let [v (m k)]\n                              (conj c2 v)\n                              c2))\n                            [] maps)]\n          (reduce (fn [y1 y2] (f y1 y2)) (first ms) (rest ms)))))\n      {} all-keys)))","problem":69,"user":"4dc1e1e4535d020aff1edf90"},{"code":"(fn [f m & args]\n   (apply merge (concat args \n          (map #(hash-map (first (first %)) (f (m (first (first %))) (second (first %)) )) args))))","problem":69,"user":"5300aa1de4b0d8b024fd3710"},{"code":"(fn [f & maps]\n  (let [mmap\n    (reduce\n      (fn [acc m]\n        (reduce\n          (fn [acc e]\n            (let [[k v] e]\n              (conj acc [k (conj (get acc k []) v)])))\n         acc m))\n      {} maps)]\n   (reduce #(conj % [(first %2) (reduce f (second %2))]) {} mmap)))","problem":69,"user":"4fd22e70e4b04c3a95aa041c"},{"code":"(fn [fun & maps]\n  (reduce (fn [result m]\n    (reduce (fn [result [k v]]\n      (if (contains? result k)\n        (assoc result k (fun (result k) v))\n        (assoc result k v)))\n      result\n      m))\n    {}\n    maps))","problem":69,"user":"4e6a4954535d8ccf87e9fec0"},{"problem":69,"code":"(fn merge-with-function [f m & ms]\n  (let [tm (transient m)]\n\t  (doseq [x ms]\n\t      (doseq [[a b] x]\n    \t    (assoc! tm a (if (tm a) (f (tm a) b) b))))\n    (persistent! tm)))","user":"56f4cedce4b046a417f92063"},{"code":"(fn [f & maps]\n  (reduce\n    (fn [a b]\n      (reduce\n        (fn [x [k v]]\n          (assoc x k (if (b k) (f v (b k)) v)))\n        b a))\n    (first maps) (rest maps)))","problem":69,"user":"4e977eb4535dbda64a6f6b56"},{"code":"(fn [f themap & maps]\n  (reduce\n   (fn [r m]\n     (apply assoc r\n            (interleave (keys m)\n                        (map #(if (r %) (f (r %) (m %)) (m %)) (keys m)) )))\n   themap maps))","problem":69,"user":"4e720985535d5021c1a89655"},{"problem":69,"code":"(fn [f & m]\n  (reduce\n   #(merge % (reduce\n     (fn [o [k v]]\n         (assoc o k \n           (if (contains? % k)\n             (f (% k) v)\n              v)))\n     {} %2))\n   {} m))","user":"53572176e4b04ce2eb3ed276"},{"problem":69,"code":"(fn\n  [f & maps]\n  (let [merge-entry (fn [m e]\n                      (let [k (key e) v (val e)]\n                        (if (contains? m k)\n                          (assoc m k (f (m k) v))\n                          (assoc m k v))))\n        mergemap (fn [rmap maps]\n                 (reduce merge-entry rmap (seq maps)))]\n    (reduce mergemap maps)))","user":"524bc937e4b09eba1c0223ee"},{"problem":69,"code":"(fn [f & maps]\n    (letfn [(update-v [m [k v]] (assoc m k (if (m k) (f (m k) v) v)))]\n      (reduce update-v {} (apply concat maps))))","user":"5f82609ae4b0c071e6c840f9"},{"problem":69,"code":"(fn merge-maps\n    ([_ out] out)\n    ([f out in & ins]\n        (apply merge-maps f (reduce (fn [o [k v]] (assoc o k (if (o k) (f (o k) v) v))) out in) ins)))","user":"59da6480e4b0ef0a1e9b5c68"},{"problem":69,"code":"(fn [op & ms]\n  (into {} (for [k (apply clojure.set/union (map (comp set keys) ms))]\n             [k\n              (let [vs (keep #(get % k) ms)]\n                (if (= (count vs) 1)\n                  (first vs)\n                  (apply op (keep #(get % k) ms))))])))","user":"5136f659e4b04059df19f2fd"},{"problem":69,"code":"(fn m [f & colls]\n  (loop [cs colls acc {}]\n    (if (empty? cs)\n      acc\n      (recur (rest cs)\n             (loop [c (first cs) a acc]\n               (if (empty? c)\n                 a\n                 (let [k (first (first c))\n                       val (second (first c))]\n                   (if (contains? a k)\n                     (recur (rest c) (assoc a k (f (get a k) val)))\n                     (recur (rest c) (assoc a k val))))))))))","user":"56588f4ee4b0f9d632dd84b6"},{"problem":69,"code":"(fn [f & maps]\n  (reduce #(conj %\n                 (reduce (fn [r [k v]]\n                           (let [rv (get r k)] (assoc r k (if rv (f rv v) v)))) % %2))\n          maps))","user":"5be79b5be4b0f319e2d7ec5a"},{"problem":69,"code":"(fn [f & maps]\n  (->> maps\n    (mapcat (partial into []))\n    (group-by key)\n    (map (fn [[k kvps]] [k (reduce f (map second kvps))]))\n    (into {})))","user":"5aa998c6e4b0d174b936c8e5"},{"code":"(fn my-merge-with [f & maps]\n  (let [all-keys (set (mapcat keys maps))]\n    (zipmap all-keys\n            (map (fn [i]\n                   (reduce f (filter #(not= nil %) (map #(get % i) maps)))) all-keys))))","problem":69,"user":"50052fd0e4b0678c553fc45d"},{"problem":69,"code":"(fn [f & ms]\n  (->> ms\n       (mapcat seq)\n       (reduce\n        (fn [result [k v]]\n          (let [prev (get result k)]\n            (if (nil? prev)\n              (assoc result k v)\n              (assoc result k (f prev v)))))\n        {})))","user":"4f3d83b5e4b0e243712b1f69"},{"code":"(fn my-merge-with [f start & others]\r\n  (letfn\r\n    [(reducer [a b]\r\n      (if (> (count b) 1)\r\n        (reduce reducer a \r\n          (map #(apply hash-map %) b))\r\n        (let [[key val] (first b)]\r\n          (if (contains? a key)\r\n            (assoc a key (f (a key) val))\r\n            (assoc a key val)))))]\r\n    (reduce reducer start others)))","problem":69,"user":"4e02bee8535d04ed9115e791"},{"code":"(fn mw ([f ma mb]\n     (reduce #(assoc-in %1 [(key %2)]\n                         (if (contains? %1 (key %2)) (f (%1 (key %2)) (val %2)) (val %2)))\n             ma mb))\n  ([f ma mb & ms]\n     (reduce (partial mw f) ma (cons mb ms))))","problem":69,"user":"4ff3df0fe4b0678c553fc355"},{"problem":69,"code":"(fn me [f src & maps]\n    (letfn [\n      (generate-results [acc args]\n        (reduce update-map acc args))\n      (update-map [acc [k v]]\n        (update-in acc [k] update-entry v))\n      (update-entry [prev v]\n        (if (nil? prev) v (f prev v)))\n    ]\n    (reduce generate-results src maps)\n  )\n)","user":"5c219c0fe4b07e362c230581"},{"problem":69,"code":"(fn [f & maps]\n  (->>\n   maps\n   (apply concat)\n   (group-by first)\n   (map (fn [[k kvs]] [k (reduce f (map second kvs))]))\n   (into {})))","user":"54b04708e4b09f271ff37d11"},{"code":"(fn [f & xms]\n  (reduce\n   (fn [xm ym]\n     (reduce\n      (fn [m [k y]]\n        (assoc m k (if-let [x (get m k)] (f x y) y)))\n      xm ym))\n  {} xms))","problem":69,"user":"4e6a412e535d8ccf87e9feb6"},{"problem":69,"code":"(fn my-merge-with [f m & ms]\n  (reduce (fn [m1 m2]\n            (reduce (fn [cm [k v]]\n                      (if (cm k) (assoc cm k (f (cm k) v))\n                        (assoc cm k v))) m1 m2))\n            m ms))","user":"541619e8e4b01498b1a719f9"},{"problem":69,"code":"(fn [f & maps]\n    (reduce (fn [agg m]\n              (apply merge m\n                     (for [[k v] agg]\n                       {k (if-let [mv (get m k)] (f v mv) v)})))\n            maps))","user":"50978ca4e4b00ad8bab4e966"},{"code":"(fn [f & maps]\n  (into {} (for [[k xs] (->> maps (apply concat) (group-by key))]\n             [k (reduce f (map second xs))])))","problem":69,"user":"518696c1e4b0c40be512d708"},{"code":"(fn [op base & others]\n    (letfn [(acc-val [base-map [key val]]\n              (if (contains? base-map key)\n                (assoc base-map key (op (get base-map key) val))\n                (assoc base-map key val)))\n            (acc-map [base-map other-map]\n              (reduce acc-val base-map other-map))]\n      (reduce acc-map base others)))","problem":69,"user":"5165a235e4b079ad97ec44ac"},{"code":"(fn[f m & ms]\r\n  (reduce\r\n    (fn[m n](reduce\r\n     (fn[x [k v]]\r\n       (assoc x k (if(x k)(f(x k)v)v)))\r\n     m n))\r\n   m ms))","problem":69,"user":"4dd66da7535d2dad7130b5c8"},{"code":"(fn [f & xs]\n  (reduce (fn [result map]\n            (reduce (fn [m [k v]]\n                      (if-let [vv (m k)]\n                        (assoc m k (f vv v))\n                        (assoc m k v))) result map))\n          xs))","problem":69,"user":"523bde95e4b07becd5be2202"},{"code":"(fn [f & ms]\n  (into {}\n    (for [[k vs] (group-by first (for [m ms [k v] m] [k [v]]))]\n      [k (let [rs (mapcat second vs)]\n            (if (= 1 (count rs)) (first rs) (apply f rs)))])))","problem":69,"user":"500933a6e4b046cdb195e074"},{"problem":69,"code":"(fn [f & maps]\n  (reduce (fn [m [k v]] \n            (if (contains? m k)\n              (assoc m k (f (m k) v))\n              (assoc m k v)))\n          {}\n          (reduce concat maps)))","user":"541b1f25e4b01498b1a71a63"},{"problem":69,"code":"(fn mw [f m & ms]\n  (if (empty? ms) m\n    (apply mw f\n           (loop [acc m\n                  nm (first ms)]\n             (if (empty? nm) acc\n               (let [[k v] (first nm)]\n                 (recur\n                   (if (contains? (set (keys acc)) k)\n                     (assoc acc k (f (acc k) v))\n                     (assoc acc k v))\n                   (into {} (rest nm))))))\n           (rest ms))))","user":"57a0b341e4b0c3d858beb8d4"},{"code":"(fn [f m & ms]\n  (reduce\n   (fn [acc-map x] \n     (reduce (fn [acc [k v]]\n               (update-in acc [k] \n                          (fn [old-v] \n                            (if old-v (f old-v v) v))))\n      acc-map x))\n   m ms))","problem":69,"user":"51a97f7ae4b08d8ec191b827"},{"code":"(fn [f & maps]\n    (let [k2v (reduce (fn [a, [k v]] (assoc a k (conj (a k []) v)))\n                {} (reduce into (map vec maps)))]\n      (zipmap (keys k2v) (map (partial reduce f) (vals k2v)))))","problem":69,"user":"4e89ddf9535d3e98b8023284"},{"code":"(fn [f & maps ]\n  (let [ kk (set (mapcat keys maps))\n        get*  (fn [k] (for [m maps :when (m k)] (m k)))\n        merge (fn [vv] (if (= 1 (count vv)) (first vv) (apply f vv)))]\n    (apply hash-map (mapcat #(list % (merge (get* %))) kk))))","problem":69,"user":"50fa01bce4b07934dda8b0ba"},{"code":"(fn [f & colls]\n  (loop [result {} \n        keyset (reduce (fn [r i] (clojure.set/union r (set (keys i)))) #{} colls)]\n     (println \"keyset\" (identity keyset))\n     (if (empty? keyset) result\n       (let [key (first keyset)\n        values (remove (partial = nil) (reduce (fn [r i] (conj r (get i key))) '() colls))\n        m (conj result [key (reduce f (reverse values))])]\n         (println \"values\" (identity values))\n         (recur m (rest keyset))))\n    ))","problem":69,"user":"535ca812e4b04ce2eb3ed2b7"},{"problem":69,"code":"(fn [f & l]\n  (->> (for [k (keys (apply merge l))]\n         (let [[x & xs] (keep #(get % k) l)]\n           (if xs\n             [k (apply f x xs)]\n             [k x])))\n       (into {})))","user":"55bf6dbce4b01b9910ae2a12"},{"problem":69,"code":"(fn [op & maps]\n  (reduce (fn [m n]\n            (reduce (fn [x [y z]]\n                      (if-let [a (x y)]\n                        (assoc x y (op a z))\n                        (assoc x y z)))\n                    m n))\n          maps))","user":"56f4623ae4b046a417f9205d"},{"code":"(fn [f m & ms] \r\n     (loop [m m, ms ms]\r\n           (if (seq ms)\r\n               (recur (#(if (seq %3)\r\n                          (let [k (first %3)]\r\n                            (recur (assoc % k (if (contains? % k) (f (% k) (%2 k)) (%2 k)))\r\n                                   %2\r\n                                   (rest %3)))\r\n                          %) m (first ms) (keys (first ms)))\r\n                      (rest ms))\r\n             m)))","problem":69,"user":"4dbb1126535d1e037afb21b3"},{"code":"(fn [f & l]\r\n  (reduce\r\n   (fn [m n] (reduce \r\n        (fn [x y] \r\n\t\t(conj x [y (if (and (m y) (n y)) (f (m y) (n y)) (or (m y) (n y)))]))\r\n\t      {}\r\n\t      (clojure.set/union (keys m) (keys n))))\r\n   l))","problem":69,"user":"507437c2e4b054001656acd0"},{"problem":69,"code":"(fn [f & maps]\n    (reduce\n     (fn [acc m]\n       (->> (for [[k v] m]\n              [k (if (contains? acc k)\n                   (f (acc k) v)\n                   v)])\n            (into {})\n            (merge acc)))\n     maps))","user":"5275f7a2e4b03e8d9a4a74d0"},{"problem":69,"code":"(fn [f & ms]\n    (let [merge-keys (fn [f k m0 m1] (update-in m0 [k] #(f % (get m1 k))))\n          merge-2-with (fn [m0 m1]\n                         (reduce\n                          (fn [prev [k v]]\n                            (if (contains? prev k)\n                              (update-in prev [k] #(f % v))\n                              (assoc prev k v)))\n                          m0\n                          m1))]\n      (reduce\n       (fn [prev m]\n         (merge-2-with prev m))\n       ms)))","user":"5a5d0726e4b0512ff01cd91b"},{"problem":69,"code":"(fn mymerge [f r & s] \n  (reduce-kv (fn [m k v] \n               (assoc m k (if (contains? m k) (f (m k) v) v))) r (apply merge s)))","user":"573ce277e4b05c31a32c080b"},{"code":"(fn my-merge-with [f & maps]\n  (letfn [(add-items [from into key]\n            (let [old-value (get into key [])]\n              (assoc into key (conj old-value (get from key)))))\n          (combine-maps [into from]\n            (reduce (partial add-items from)\n                    into (keys from)))\n          (combine [merged-map]\n            (reduce (fn [acc key]\n                      (let [val (get merged-map key)]\n                        (if (= (count val) 1)\n                          (assoc acc key (first val))\n                          (assoc acc key (apply f val))))) {} (keys merged-map)))]\n    (combine (reduce combine-maps {} maps))))","problem":69,"user":"4ff355a1e4b0678c553fc34d"},{"code":"(fn [f m & ms]\n  (reduce\n    #(reduce (fn [m1 m2] (let [k (key m2) v (val m2) v0 (get m1 k)] \n               (if v0\n                   (assoc m1 k (f v0 v))\n                   (assoc m1 k v)))) \n             %1 %2) m ms))","problem":69,"user":"4ed286d4535d44c135fd68d7"},{"problem":69,"code":"(fn [f x & xs] (reduce-kv (fn [acc k v] (assoc acc k (if (get x k) (f (get x k) v) v))) {} (apply merge xs)))","user":"5b924123e4b0c0b3ffbd4a34"},{"code":"(fn merge-with1\n  [f init & rest]\n  (letfn [(merge-bin [x y]\n            (merge y\n                   (->> (for [[k v] x]\n                          (if-let [match (get y k nil)]\n                            [k (f v match)]\n                            [k v]))\n                          (into {}))))]\n    (reduce (fn [acc coll] (merge-bin acc coll)) init rest)))","problem":69,"user":"4ef7a483535dced4c769f258"},{"problem":69,"code":"(fn mrg2 [f & mps]\n  (into {} \n        (map #(vector \n               (first %) \n               (reduce f (last %)))\n             (for [k (apply clojure.set/union (map (comp set keys) mps))]\n                [k \n                 (filter \n                  (fn [x] (not (nil? x))) \n                  (map #(% k) mps))]))))","user":"5143824ae4b0b4fb4ace5f36"},{"code":"(fn [ f & maps ]\n          (let [keys (reduce clojure.set/union (map keys maps))]\n            (into {}\n                  (map (fn [k]\n                           (let [vs (filter (complement nil?) (map #(% k) maps))]\n                             [k (if (= 1 (count vs))\n                                 (first vs)\n                               (apply f vs))]))\n                             keys))))","problem":69,"user":"51095588e4b0e34872b3efa5"},{"code":"(fn [f & maps] (reduce #(assoc %\n                          \t(first %2)\n                          \t(if (contains? % (first %2))\n                              (f (get % (first %2))\n                                 (second %2))\n                              (second %2)))\n                       (first maps)\n                       (apply concat (rest maps))))","problem":69,"user":"5078d366e4b08327cd804a5b"},{"problem":69,"code":"(fn merge-f\n  [f & maps]\n  (let [the-keys (distinct (apply concat (map keys maps)))\n        the-big-map (for [k the-keys] (reduce f (filter #(not (nil? %)) (map #(get % k) maps))))]\n    (zipmap the-keys the-big-map)\n    ))","user":"5564709ee4b0c656e3ff1807"},{"code":"(fn [f & maps]                                                                                  \n  (when (some identity maps)                                                                         \n    (let [mrg-each (fn [m e]                                                                          \n                     (let [k (key e) v (val e)]                                                      \n                       (if (contains? m k)                                                           \n                         (assoc m k (f (get m k) v))                                                 \n                         (assoc m k v))))                                                            \n          mrg (fn [m1 m2]                                                                             \n                (reduce mrg-each m1 m2))]                                                            \n      (reduce mrg maps))))","problem":69,"user":"4f1d1299535d64f603146487"},{"problem":69,"code":"(fn mrgw [f & maps]\n  (apply hash-map\n    (apply concat\n      (for [k (distinct (mapcat keys maps))]\n        (let [vs (remove nil? (map #(get % k) maps))]\n          [k (if (second vs)\n               (apply f vs)\n               (first vs))])))))","user":"56f9c7c6e4b07572ad1a88ba"},{"code":"(fn fmerge\n  [function megamap & maps]\n  (reduce (fn [megamap m]\n    (reduce (fn [megamap keyval]\n      (if-let [megamap-val (megamap (first keyval))]\n        (assoc megamap\n          (first keyval)\n          (function megamap-val (last keyval)))\n        (apply assoc megamap keyval)))\n      megamap m))\n    megamap maps))","problem":69,"user":"52b4d8fae4b0c58976d9ad33"},{"problem":69,"code":"(fn [f & ms]\n  (reduce\n   (fn [m [k v]] (conj m [k (if (m k) (f (m k) v) v)]))\n   {}\n   (reduce concat ms)))","user":"6020365ae4b0bf4ca6b10960"},{"problem":69,"code":"(fn [f & maps]\n    (reduce \n      (fn [m1 mrest] \n          (reduce \n            (fn [m [k v]]\n                (if (contains? m k)\n                  (assoc m k (f (m k) v))\n                  (assoc m k v))\n            ) \n          m1 mrest)\n      ) \n      maps)    \n  )","user":"5564c113e4b0c656e3ff180d"},{"problem":69,"code":"(fn [func & args]\n            (reduce (fn [map1 map2]\n                      (reduce (fn [m1 [k v]]\n                                (if-let [v1 (m1 k)]\n                                  (assoc m1 k (func v1 v))\n                                  (assoc m1 k v)))\n                              map1 map2))\n                    args))","user":"5e954b9ee4b0fbed045a3809"},{"code":"(fn [f & maps]\n  (reduce (fn [rmap [k v]]\n            (if (contains? rmap k)\n              (update-in rmap [k] f v)\n              (assoc rmap k v)))\n          {}\n          (apply concat maps)))","problem":69,"user":"4eccb190535d23f0362276fe"},{"code":"(fn [func base & values]\r\n  (let [update (fn [b kv] \r\n                 (if (contains? b (key kv))\r\n                   (update-in b [(key kv)] func (val kv))\r\n                   (conj b kv)))]\r\n    (reduce #(reduce update % %2) base values)))","problem":69,"user":"4e6e2ac4535d5021c1a895ff"},{"problem":69,"code":"(fn [f & ms]\n  (reduce (fn [result m]\n            (reduce-kv (fn [mm k v]\n                         (if (contains? result k)\n                           (assoc mm k (f (get result k) v))\n                           (assoc mm k v)))\n                       result\n                       m))\n          {}\n          ms))","user":"5895477fe4b00487982d527c"},{"problem":69,"code":"(fn my-merge-with [f first-map & maps]\n  (letfn [(merge-maps [f m1 m2]\n            (apply merge m1\n                   (map (fn [x]\n                          (apply hash-map\n                                 (if-let [y (get m1 (key x))]\n                                   [(key x) (f y (val x))]\n                                   x)))\n                        m2)))]\n    (reduce #(merge-maps f %1 %2)\n            first-map\n            maps)))","user":"5be1c6c6e4b0ed4b8aab4ca5"},{"problem":69,"code":"(fn merge-with-function [f & maps]\n  (reduce merge (map (fn [entry] {(key entry) (reduce f (map second (val entry)))})\n      (group-by first\n        (reduce concat\n          (map #(seq %) maps))))))","user":"525d44bfe4b0cb4875a45d6d"},{"problem":69,"code":"(fn mergf\n  [f m1 & maps] \n   (let [ domerge \n   (fn [f m1 m2]\n     (loop [ mergemap  m1 \n             resultmap m2 ]\n       (if-not (seq mergemap)\n         resultmap\n         (let [ [k v] (first mergemap)\n               val (get resultmap k)]\n           (if (nil? val)\n             (recur (dissoc mergemap k) (conj resultmap [k v]))\n             (recur (dissoc mergemap k) (conj resultmap [k (f val v)])))))))\n         ]\n     (loop [ mergemaps maps  \n             resultmap m1  ]\n       (if-not (seq mergemaps)\n         resultmap\n         (recur (rest mergemaps) (domerge f (first mergemaps) resultmap)) \n       ))))","user":"5364ab34e4b0243289761e64"},{"problem":69,"code":"(fn [f & maps]\n  (reduce (fn [m1 m2]\n            (reduce (fn [m [x y]]\n                      (conj m [x (if (m x) (f (m x) y) y)])) m1 m2)) maps))","user":"60b7e2c5e4b0e0fa5f1b4252"},{"problem":69,"code":"(fn [func & coll]\n   (let [all-keys (set (flatten (map keys coll)))]\n     (into {}\n       (for [k all-keys]\n         (->>  (map #(% k) coll)\n               (filter identity)\n               (reduce func)\n               (#(vector k %))\n               )))))","user":"53ed6976e4b0d648e757f4c4"},{"code":"(fn \n  [f & mps]\n  (let [k-set (set (apply concat (map keys mps)))\n        f-n (fn [args] \n              (let [x-args (remove nil? args)]\n                (if (second x-args)\n                  (apply f x-args)\n                  (first x-args))))]\n    (->> (map (fn [x] {x (f-n (map #(get % x) mps))}) k-set)\n         (apply merge))))","problem":69,"user":"5036eba7e4b0af0658af77a5"},{"code":"(fn [f & cs]\n  (reduce \n   #(reduce \n     (fn [c [k v]] (assoc c k (if-let [v2 (c k)] (f v2 v) v)))  \n     % %2)\n   cs))","problem":69,"user":"51e58e02e4b0efabf93c02d0"},{"problem":69,"code":"(fn merge-with'\n  ([f m] m)\n  ([f m1 m2]\n   (loop [in m2\n          out m1]\n     (if-let [[[k v-new] & kvs] (seq in)]\n       (if-let [v-orig (get out k)]\n         (recur kvs (conj out [k (f v-orig v-new)]))\n         (recur kvs (conj out [k v-new])))\n       out)))\n  ([f m1 m2 & ms] (reduce (partial merge-with' f) (list* m1 m2 ms))))","user":"601aaa93e4b0bf4ca6b10926"},{"code":"(fn my-merge-with [f & args]\n  (when (some identity args)\n    (let [-merge (fn [r x]\n                   (let [k (x 0) v (x 1)]\n                     (if (contains? r k)\n                       (assoc r k (f (r k) v))\n                       (assoc r k v))))\n          -merge-all (fn [r x]\n                      (reduce \n                        -merge\n                        (or r {})\n                        x))]\n      (reduce \n        -merge-all\n       (first args)\n        (rest args)))\n  ))","problem":69,"user":"5092f940e4b097f48cc3857b"},{"problem":69,"code":"(fn merge-with-a-function [func & maps]\n  (reduce\n    (fn [m1 m2]\n      (loop [acc m1 add m2]\n        (if (empty? add)\n          acc\n          (recur\n            (let [k (key (first add))\n                  v (val (first add))]\n              (if (contains? acc k)\n                (assoc acc k (func (get acc k) v))\n                (assoc acc k v)))\n            (rest add)))))\n    {}\n    maps))","user":"528bba38e4b0239c8a67aea9"},{"code":"(fn w [f m & n]\n  (if (empty? n)\n    m\n    (recur\n     f     \n     (reduce #(let [a (first %2)]\n                (assoc %1 a\n                       (if (get %1 a)\n                         (f (get %1 a) (second %2))\n                         (second %2)))) m (first n))\n     (rest n))))","problem":69,"user":"4facd2fae4b081705acca22f"},{"problem":69,"code":"(fn merge [f m & ms]\n  (reduce\n    (fn [res m]\n      (reduce-kv\n        (fn [res k v]\n          (assoc res k (if (contains? res k) (f (get res k) v) v)))\n        res\n        m))\n    m\n    ms))","user":"5f300f28e4b033932238a682"},{"code":"(fn tst [f m & o]\n  (letfn [(me [r l]\n              (let [rv (r (key l)) lv (val l)]\n                (if rv\n                  (assoc r (key l) (f rv lv))\n                  (conj r l))))]\n    (loop [rm m oi (seq o)]\n      (if (empty? oi)\n        rm\n        (recur (reduce me rm (first oi)) (rest oi))))))","problem":69,"user":"52d809bde4b09f7907dd1384"},{"problem":69,"code":"(fn mergefn [f & maps]\n  (loop [m maps\n         res {}]\n    (if (seq m)\n      (let [[hd & tl] m]\n        (recur tl (reduce #(let [[k v] %2\n                                 not-nil? (get %1 k)]\n                             (if not-nil?\n                               (assoc %1 k (f not-nil? v))\n                               (assoc %1 k v)))\n                          res\n                          hd)))\n      res)))","user":"5a6b9b95e4b0512ff01cda40"},{"code":"(fn [f & maps] \n  (apply hash-map (mapcat (fn [k] (list k (reduce f (filter (comp not nil?) (map #(% k) maps))))) (set (mapcat keys maps)))))","problem":69,"user":"523b1988e4b02f719975bdbc"},{"problem":69,"code":"(fn my-merge-with [func & maps]\n  (reduce (fn [map1 map2] \n            (reduce \n             (fn [map-first [k v]]  \n                    (if-let [value (map-first k)] \n                      (assoc map-first k (func value v))\n                      (assoc map-first k v))) \n             map1 map2)) \n          maps))","user":"539b4268e4b0b51d73faaf1c"},{"problem":69,"code":"(fn [f & ms]\n    (reduce \n      (fn [ret-all vvs]\n        (reduce (fn [ret vv] \n                        (let [k1 (key vv)\n                             v1 (val vv)\n                             v0 (get ret k1)]\n                          (assoc ret k1\n                            (if (= nil v0) v1 (f v0 v1)))))\n                        ret-all vvs))\n      {} ms)\n  )","user":"593f95d8e4b069cdc2982be3"},{"problem":69,"code":"(fn [f & colls]\n  (let [kys (distinct (reduce concat (map keys colls)))\n        new (fn [ky] (reduce f (filter (complement nil?) (map #(get % ky) colls))))]\n    (zipmap kys (map new kys))))","user":"597768d0e4b01722bebd4cee"},{"code":"(fn g [f r & m] (if (empty? m) r (apply g f (reduce #(let [[k v] %2] (conj %1 (if (%1 k) {k (f (%1 k) v)} %2))) r (first m)) (rest m))))","problem":69,"user":"4eb13d60535d7eef3080733f"},{"problem":69,"code":"(fn [f & ms]\n\t(reduce\n     \t(fn [m [k v]]\n           (if (contains? m k)\n               (assoc m k (f (m k) v))\n               (assoc m k v)))\n     {}\n     (apply concat ms)))","user":"54e540c1e4b024c67c0cf7f9"},{"problem":69,"code":"(fn m [f mp & mps]\n\n   (reduce \n\n     (fn [res [k v]] (assoc res k \n\n                       (if (mp k)\n\n                          (f (mp k) v)\n\n                          v))) \n\n     {}\n\n    (apply concat mps)))","user":"57487084e4b009280f9f2b8c"},{"code":"(fn [mf & ms]\n    (reduce\n      (fn [mp mn]\n        (reduce\n          (fn [m [k v]] (assoc m k (if (contains? m k) (mf (m k) v) v)))\n          mp (map vector (keys mn) (vals mn))))\n      (first ms) (rest ms)))","problem":69,"user":"525f51bde4b0cb4875a45dc8"},{"problem":69,"code":"(fn [f & ms]\n  (letfn [(m [m1 m2]\n             (if (empty? m2)\n               m1\n               (let [[k v] (first m2)]\n                 (if (contains? m1 k)\n                   (m (assoc m1 k (f (m1 k) v)) (rest m2))\n                   (m (assoc m1 k v) (rest m2))))))]\n    (reduce m ms)))","user":"559454f2e4b0c79f6e1db952"},{"problem":69,"code":"(fn merg [f m & ms]\n  (let [addVal (fn [m [k v]]\n                 (if (contains? m k)\n                   (update-in m [k] f v)\n                   (assoc m k v)))]\n    (loop [m1 m\n           ms ms]\n      (if (empty? ms)\n        m1\n        (recur (reduce addVal m1 (first ms)) (rest ms))))))","user":"5396c94be4b0b51d73faaee3"},{"problem":69,"code":"(fn [fnc & maps]\n  (reduce \n     (fn [acc mp]\n       (reduce-kv #(assoc %1 %2 (if (get %1 %2) (fnc (get %1 %2) %3) %3)) acc mp)\n     ) {} maps)  \n)","user":"558fec41e4b0277789237666"},{"code":"(fn [f & maps]\r\n  (letfn [\r\n    (step [m e]\r\n      (let [k (key e) v (val e)]\r\n        (if (contains? m k)\r\n          (assoc m k (f (get m k) v))\r\n          (assoc m k v))))\r\n    (_merge [m1 m2]\r\n      (reduce step (or m1 {}) m2))]    \r\n  (reduce _merge maps)))","problem":69,"user":"4dd52e29535dae65d5c462e5"},{"code":"(fn mergewith [f & maps]\n  (reduce (fn [m [k v]]\n            (assoc m k (if (= (count v) 1) (first v) (apply f v))))\n          {}\n          (reduce (fn [m [k v]]\n                    (assoc m k (conj (get m k []) v)))\n                  {} (apply concat maps))))","problem":69,"user":"539a2901e4b0b51d73faaf0f"},{"problem":69,"code":"(fn my-merge-with\n  ([f] {})\n  ([f res-map] res-map)\n  ([f res-map map-1]\n   (reduce (fn [init-map [k v]]\n             (if (contains? init-map k)\n               (assoc\n                 init-map \n                 k \n                 (f (get init-map k) v))\n               (assoc init-map k v)))\n           res-map\n           map-1))\n  ([f res-map map-1 & more-maps]\n   (apply my-merge-with f \n          (my-merge-with f res-map map-1)\n          more-maps)))","user":"585e2e77e4b0f14aab7c87ac"},{"problem":69,"code":"(fn [f & x] (reduce (fn [m v]\n                                (let [k (first v) w (last v)]\n                                  (if (m k)\n                                    (assoc m k (f (m k) w))\n                                    (assoc m k w)\n                                    ))) {} (apply concat x)))","user":"5464a536e4b01be26fd746cf"},{"problem":69,"code":"(fn my-merge-with [f & [ma & ms]]\n  (let [u (fn [ret [k v]] (if (get ret k) (update-in ret [k] f v) (assoc ret k v)))]\n    (reduce #(reduce u %1 %2) ma ms)))","user":"5383668ee4b06839e8705edd"},{"code":"(fn [f map1 & maps]\n  (loop [m1 map1 m2 (first maps) out (rest maps)]\n    (if (empty? m2)\n      (if (empty? out)\n        m1\n        (recur m1 (first out) (rest out)))\n    (let [[k v] (first m2)]\n      (recur (update-in m1 [k] #(if (nil? %) v (f % v))) (rest m2) out)))))","problem":69,"user":"4f4ba29ae4b03ad3f0c10c7a"},{"problem":69,"code":"(fn [func & args]\n   (reduce (fn [v e]\n             (cond\n               (contains? v (first e)) (conj v {(first e) (func (get v (first e)) (second e))})\n               :else (conj v {(first e) (second e)})\n               )) {} (reduce concat args)))","user":"5a4b3abde4b05d388ecb6b81"},{"code":"(fn [f & m]\n  (let [k (set (mapcat keys m))\n        g (map #(remove nil? %) (map (fn [k] (map #(get % k) m)) k))\n        v (map #(if (> (count %) 1) (apply f %) (first %)) g)]\n    (zipmap k v)))","problem":69,"user":"4f6fd91ae4b07046d9f4efed"},{"code":"(fn [f & xs]\n  (->> xs\n       (apply concat)\n       (group-by first)\n       (reduce-kv\n        (fn [acc k v] (assoc acc k (reduce f (map second v))))\n        {})))","problem":69,"user":"50479524e4b0371827a27bc4"},{"problem":69,"code":"(fn [f m & maps]\n  (reduce\n   (fn [m n]\n     (into m\n           (reduce\n            (fn [m k]\n              (let [v (get m k)]\n                (into m\n                      (if (nil? v)\n                        {k (get n k)}\n                        {k (f v (get n k))}\n                        )\n                      )\n                )\n              )\n            m (keys n))\n           ))\n   m maps))","user":"4e3ac1b2535deb9a81d77f4c"},{"code":"(fn [op & ms]\n  (reduce\n    (fn [accumulator m]\n      (reduce\n        (fn [accumulator [k v]]\n          (if (contains? accumulator k)\n            (assoc accumulator k (op (get accumulator k) v))\n            (assoc accumulator k v))) accumulator m)) (first ms) (rest ms)))","problem":69,"user":"51d08d67e4b067c365486351"},{"code":"(fn my-merge-with [f head-map & tail-maps]\n  (if (empty? tail-maps)\n    head-map\n    (let [result-map (reduce (fn [merged-map [key value]]\n                               (assoc merged-map key\n                                      (if (contains? merged-map key)\n                                        (f (merged-map key) value)\n                                        value)))\n                             head-map\n                             (first tail-maps))]\n      (apply (partial my-merge-with f result-map) (rest tail-maps)))))","problem":69,"user":"5310e7aee4b08068f379ecdc"},{"problem":69,"code":"(fn [f & ms]\n  (when ((complement empty?) ms)\n    (let [merge-entry (fn [acc [k v]]\n                        (if (contains? acc k)\n                          (assoc acc k (f (get acc k) v))\n                          (assoc acc k v)))\n          merge-map (fn [acc m]\n                      (reduce merge-entry acc m))]\n      (reduce merge-map {} ms))))","user":"59769d75e4b01722bebd4cdd"},{"problem":69,"code":"(fn [f & args]\n    (reduce\n      (partial reduce\n               (fn [m [k v]]\n                   (assoc m k (if-let [old-v (get m k)] (f old-v v) v))))\n      {}\n      args))","user":"5f331015e4b0574c87022c37"},{"problem":69,"code":"(fn [f & maps]\n  (reduce (fn [result latter]\n            (reduce (fn [result [k v]]\n                      (assoc result\n                             k\n                             (if (result k)\n                               (f (result k) v)\n                               v)))\n                    result\n                    (seq latter)))\n          {}\n          maps))","user":"580bd81ee4b0849f6811b711"},{"problem":69,"code":"(fn\n    [f & maps]\n      (reduce (fn [r m]\n                (apply (partial merge r)\n                       (map (fn [[k v]]\n                              {k (if (contains? r k)\n                                   (f (r k) v)\n                                   v)})\n                            m)))\n              maps))","user":"54f26266e4b024c67c0cf8c5"},{"problem":69,"code":"(fn [f & more] \n  (loop [dic {} \n         fi (first more) \n         re (rest more)]  \n    (if (nil? fi)\n      dic\n      (recur (reduce (fn [d [k v]]\n                       (if (contains? d k)\n                         (assoc d k (f (get d k) v))\n                         (assoc d k v)\n                        )\n                       ) \n              dic \n              fi)\n             (first re)\n             (rest re)))))","user":"52503747e4b0541d1855b828"},{"code":"(fn [f & ms]\n  (reduce\n   (fn [res [k v]] (assoc res k (if-let [ev (get res k)] (f ev v) v)))\n   {}\n   (mapcat seq ms)))","problem":69,"user":"4f2d4d4ce4b0d6649770a058"},{"problem":69,"code":"(fn [f & xs]\n  (reduce (fn [m m']\n            (reduce-kv (fn [m k v] (assoc m k (if-let [v' (m k)] (f v' v) v))) m m'))\n          {} xs))","user":"50ef4e2be4b0a78662fa2653"},{"problem":69,"code":"(fn\n        [f & maps]\n        (when (some identity maps)\n          (let [merge-entry (fn [m e]\n                              (let [k (key e) v (val e)]\n                                (if (contains? m k)\n                                  (assoc m k (f (get m k) v))\n                                  (assoc m k v))))\n                merge2 (fn [m1 m2]\n                         (reduce merge-entry (or m1 {}) (seq m2)))]\n            (reduce merge2 maps))))","user":"57e6f90de4b0bfb2137f5af6"},{"problem":69,"code":"(fn foo [f & maps]\n (reduce \n   (fn my-foo [m1 m2]\n     (reduce (fn [acc [k v]]\n     (assoc acc k\n     (if (contains? acc k)\n     (f (get acc k)v)v)))\n     m1 m2))\n     (first maps)(rest maps)))","user":"52faf67ce4b047fd55837005"},{"code":"(fn [f m & ms]\n    (reduce\n     (fn [orig new]\n       (reduce #(let [[k v] %2] (update-in %1 [k] (fn [e] (if (nil? e) v (f e v))))) orig new)) m ms))","problem":69,"user":"51c3c6a6e4b0851ac09658f8"},{"code":"(fn [f m & maps]\n  (if (empty? maps) m\n    (let [key-merge (fn [m [k v]]\n                      (conj m [k (if-let [x (m k)] (f x v) v)]))]\n      (recur f (reduce key-merge m (first maps)) (rest maps)))))","problem":69,"user":"4ded27db535d08e6dec9fe0a"},{"problem":69,"code":"(fn\n  [f & maps]\n  (reduce\n   (fn [res nm]\n     (reduce #(if (get %1 (first %2))\n                (assoc %1 (first %2) (f (get %1 (first %2)) (second %2)))\n                (assoc %1 (first %2) (second %2)))\n             res\n             (seq nm)))\n   maps))","user":"5ec02e20e4b00a66d4a95288"},{"problem":69,"code":"(fn [f x & args]\n   (letfn [(mergeW [f x n] \n             (reduce (fn [o [k v]] \n                       (if-let [val (get o k)] (assoc o k (f val v)) (assoc o k v) )) x n))]\n     (reduce #(mergeW f % %2) x args)))","user":"58d27bcae4b03c36ff7e58fe"},{"problem":69,"code":"(fn [f m & maps]\n  (loop [finalM m incM (keys (first maps)) activeMap (first maps) remain (rest maps)]\n    (if (empty? incM) (if (empty? remain) finalM\n      (recur finalM (keys (first remain)) (first remain) (rest remain)))\n      (if (contains? finalM (first incM)) (recur (assoc finalM (first incM) (f (get finalM (first incM)) (get activeMap (first incM)))) (rest incM) activeMap remain)\n        (recur (assoc finalM (first incM) (get activeMap (first incM))) (rest incM) activeMap remain)))))","user":"558378dce4b05c286339e115"},{"problem":69,"code":"(fn [f & maps] \n   (reduce\n    (fn [result m] \n      (reduce (fn [r2 item] (let [k (first item)\n                                  v (second item)\n                                  c (get r2 k)]\n                              (if (nil? c) (assoc r2 k v)\n                                  (assoc r2 k (f c v)))))\n              result m))\n    maps))","user":"5eee7311e4b07c55ae4a0510"},{"problem":69,"code":"(fn [& args]\n  (let [f (first args)\n        ms (rest args)]\n    (reduce #(merge %1 (into {} (for [[k v] %2]\n                         (if (%1 k)\n                           (assoc {} k (f (%1 k) v))\n                           (assoc {} k v)))))\n            ms)))","user":"57acee37e4b0b8559636fc94"},{"problem":69,"code":"(fn mw [f m & maps]\n   (letfn [(assoc-with [r o]\n            (for [k (keys o) :let [vr (get r k) vo (get o k)]]\n              (if (nil? vr) \n                [k vo]\n                [k (f vr vo)])))]\n     (reduce into {} (map (partial assoc-with m) maps))))","user":"5fd8bcb3e4b05ac5b16ea11b"},{"code":"#_(fn mrg-wth [f & maps]\n  (reduce\n    #(loop [acc %, items (vec %2)]\n      (if (empty? items)\n        acc\n        (let [[k v] (first items)]\n          (recur (if (contains? acc k)\n            (assoc acc k (f (acc k) v))\n            (assoc acc k v)\n          ) (rest items) ))))\n          {} maps))\n\n(fn mrg-wth [f & maps]\n  (reduce\n    #(reduce\n        (fn [acc [k v]]\n            (assoc acc k (if (acc k) (f (acc k) v) v)))\n        %1 %2)\n    maps))","problem":69,"user":"53307da1e4b019098a6f8b5e"},{"problem":69,"code":"(fn [f m1 & more]\n  (reduce\n    (fn [res m]\n      (reduce\n        (fn [res [k v]]\n          (if-let [v-res (get res k)]\n            (assoc res k (f v-res v))\n            (assoc res k v)))\n        res m))\n    m1 more))","user":"573d58c8e4b05c31a32c0811"},{"problem":69,"code":"(fn mrgwith [f initial-map & maps]\n  (reduce (fn with [current-map next-map]\n            (merge current-map\n               (loop [new-map next-map add-map next-map]\n                 (if (empty? add-map)\n                   (into {}  new-map)\n                   (let [k (key (first add-map))\n                         v (add-map k)\n                         present (current-map k) \n                         new-val (if present (f present v ) v)]\n                        (recur (conj new-map {k new-val}) (into {}  (rest add-map))))))))\n          initial-map\n           maps))","user":"579d9601e4b05b1deef9ae18"},{"problem":69,"code":"(fn\n  [f & ms]\n  (if ms\n    (let [my-reduce\n          (fn [f m1 m2]\n            (if-let [s (seq m2)]\n              (loop [res m1 entries s]\n                (if-let [entry (first entries)]\n                  (recur (if (contains? res (first entry))\n                           (assoc res (first entry) (f (res (first entry)) (second entry)))\n                           (assoc res (first entry) (second entry)))\n                         (next entries))\n                  res))\n              m1))]\n      (loop [res (first ms) oth-ms (next ms)]\n        (if (nil? oth-ms)\n          res\n          (recur (my-reduce f res (first oth-ms)) (next oth-ms)))))\n    nil))","user":"56a36f76e4b0542e1f8d14ca"},{"code":"(fn [f map1 & maps]\n  (reduce #(clojure.core/loop [in %1 out %2] \n    (if (empty? in)\n      out \n      (let [k (first (keys in))] \n        (recur (dissoc in k) \n          (if (out k) \n            (assoc out k (f (in k) (out k))) \n            (assoc out k (in k))))))) \n        map1 maps))","problem":69,"user":"4e6a60cd535d8ccf87e9fed7"},{"problem":69,"code":"(fn jj [m & l]\n  (reduce\n   (fn[& [a b]]\n     (->> (map #(hash-map % (if (and (contains? a %)\n                                     (contains? b %))\n                              (m (get a %) (get b %))\n                              (cond (contains? a %) (get a %)\n                                    (contains? b %) (get b %))))\n               (set (concat (keys a) (keys b))))\n          (apply merge)))\n   l))","user":"5dab11cde4b000c986472c45"},{"problem":69,"code":"(fn [f & maps]\n    (let [merger (fn [m [k v]]\n                   (assoc m k (if (contains? m k)\n                                (f (get m k) v)\n                                v)))\n          reducer (fn [m1 m2]\n                    (reduce merger (or m1 {}) m2))]\n      (reduce reducer maps)))","user":"55342ee0e4b09218d5f44f98"},{"code":"(fn [f & ms]\n   (reduce (fn [a m] (reduce\n                     #(let [[k v] %2 x (%1 k)] (if (nil? x) (assoc %1 k v) (assoc %1 k (f x v))))\n                     a m)) {}  ms)\n  )","problem":69,"user":"52593207e4b0cb4875a45cd3"},{"problem":69,"code":"(fn [f m & ms] (reduce (fn [m1 m2]\n  (reduce (fn [c [k v]] (if (c k) (update-in c [k] f v) (assoc c k v))) m1 m2)\n) m ms))","user":"5df08767e4b093ff717275bf"},{"problem":69,"code":"(fn mw\n  [f & maps]\n  (letfn [(merge-pair [f a b]\n            (println a b)\n            (let [ks (into (set (keys a)) (keys b))]\n              (reduce\n               #(cond\n                  (and (contains? a %2) (contains? b %2)) (assoc %1 %2 (f (a %2) (b %2)))\n                  (contains? a %2) (assoc %1 %2 (a %2))\n                  (contains? b %2) (assoc %1 %2 (b %2)))\n               {}\n               ks)))]\n    (let [m (first maps)\n          ms (rest maps)]\n      (if (empty? ms)\n        m\n        (apply mw\n               f\n               (merge-pair f m (first ms))\n               (rest ms))))))","user":"5283a919e4b0239c8a67adbe"},{"problem":69,"code":"(fn [f & ms]\n  (reduce (fn [m [k v]]\n            (update-in m [k] #(if %1\n                                 (f %1 %2)\n                                 %2) v)) {} (mapcat vec ms)))","user":"54246fcce4b01498b1a71aed"},{"code":"(fn [f & ms]\n  (reduce\n    (fn [m1 m2]\n      (into {} (for [k (set (mapcat keys [m1 m2]))]\n                 [k\n                  (cond\n                    (not (contains? m2 k)) (m1 k)\n                    (not (contains? m1 k)) (m2 k)\n                    :else (f (m1 k) (m2 k)))])))\n    ms))","problem":69,"user":"50b668dde4b08fb537db98f2"},{"code":"(fn [f & ms]\n    (reduce (fn [acc [k v]]\n              (if (contains? acc k)\n                (assoc acc k (f (get acc k) v))\n                (assoc acc k v)))\n            {}\n            (apply concat ms)))","problem":69,"user":"4dad938fc9a9d6ed1b99dc57"},{"problem":69,"code":"(fn [fun & maps]\n         (letfn [ (app [ a b] (if (and a b) (fun a b) (or a b) ))\n                 (merge  [a b]\n                   (let [keys (into (keys a) (keys b))]\n                    (reduce #(assoc %1 %2 (app (get a %2) (get b %2))) {} keys)))]\n           (reduce merge  maps)))","user":"5d0cf1c8e4b0cc9c91588246"},{"problem":69,"code":"(fn mw [f a & l]\n  (cond (empty? l)  a\n        (= (count l) 1)\n        (reduce (fn [r [k v]] (assoc r k (if (get r k)\n                                           (f (get r k) v)\n                                           v))) a (first l))\n        :else (apply mw f (mw f a (first l)) (rest l))))","user":"583048d9e4b051871117c007"},{"problem":69,"code":"(fn [f & maps]\n  (reduce \n   (fn [acc a-map]\n     (reduce \n      (fn [acc [k v]]\n        (if-let [acc-val (get acc k)] \n          (assoc acc k (f acc-val v))\n          (assoc acc k v)))\n      acc\n      a-map))\n   {}\n   maps))","user":"52f3568fe4b05e3f0be25f0e"},{"code":"(fn [f m & ms] \n  (reduce \n    (fn [r m]\n      (reduce \n        (fn [r [k v]]\n          (conj r  \n            (if (r k)\n              [k (f (r k) v)]\n              [k v]))) \n      r m)) \n  m ms ))","problem":69,"user":"502904e0e4b0feaf66e22fad"},{"code":"(fn [f & ms]\n    (->> ms\n         (map seq)\n         (apply concat)\n         (reduce (fn [m [k v]] (assoc m k (if (contains? m k)\n                                            (f (m k) v)\n                                            v)))\n                 {})))","problem":69,"user":"51a3b135e4b0e77c4ca60bf6"},{"code":"(fn [f map & others]\n  (reduce\n     (fn [m1 m2]\n       (reduce\n         (fn [m [k v]] (assoc m k (if (contains? m k) (f (get m k) v) v)))\n         m1 m2))\n     map\n     others))","problem":69,"user":"5002b6e5e4b0678c553fc42c"},{"code":"(fn [f s1 & s2]\n         (letfn [(merge_with [s1 s2]\n                   (reduce (fn [s1 [k v]]\n                             (if (s1 k)\n                               (assoc s1 k (f (s1 k) v))\n                               (assoc s1 k v)))\n                           s1 s2))]\n           (reduce merge_with s1 s2)))","problem":69,"user":"518ccf6be4b05e6c8537e386"},{"problem":69,"code":"(fn my-merge-with[f & maps]\n  (reduce\n   (fn [memo next]\n     (let [[key value] next]\n       (if (contains? memo key)\n         (assoc memo key (f (memo key) value))\n         (assoc memo key value))))\n   {}\n   (apply concat maps)))","user":"5980f91ae4b021a7a535fddd"},{"code":"(fn [f & args]\n  (reduce (fn[map1 map2]\n            (reduce (fn [m [k v]]\n                      (if-let [vv (m k)]\n                        (assoc m k (f vv v))\n                        (assoc m k v)))\n                    map1 map2))\n          args))","problem":69,"user":"4f7d25b4e4b06e829148e1ba"},{"problem":69,"code":"(fn [op & maps]\n  (let [upd-val #(fn [v] (if (nil? v) % (op v %)))\n        upd #(update-in %1 [%2] (upd-val %3))\n        join #(reduce-kv upd %1 %2)]\n    (reduce join {} maps)))","user":"567d132ee4b05957ce8c61c3"},{"problem":69,"code":"(fn [f x & xs]\n  (reduce\n   (fn [m0 m1]\n     (loop [m m0 n m1]\n       (if (empty? n)\n         m\n         (let [k1 (first (keys n))\n               v1 (get n k1)\n               n' (dissoc n k1)\n               v0 (if (contains? m k1) (f (get m k1) v1) v1)\n               m' (assoc m k1 v0)\n               ]\n           (recur m' n'))))\n     ) x xs)\n  )","user":"53ef7f77e4b0742d9025b0ce"},{"problem":69,"code":"(fn [f a & args]\n  (reduce\n    (fn [r b]\n     (reduce\n       (fn [ ret [k v]]\n         (if-let [e (r k)]\n           (assoc ret k (f e v ))\n           (assoc ret k v))\n         ) \n       r b ))\n    a\n    args\n    )\n  )","user":"57408f87e4b05c31a32c0856"},{"problem":69,"code":"(fn mymerge [f d1 & l]\n  (let [d2 (apply merge l)]\n    (merge d2 (zipmap (keys d1) (map f (map d1 (keys d1)) (map d2 (keys d1)))))\n  )\n)","user":"566b8946e4b0a866af6896b0"},{"code":"(fn [f & mps] \r\n   (let [ks\r\n             (->> (map keys mps)\r\n                  (apply concat)\r\n                  (distinct)\r\n             )\r\n         ]\r\n     (->>\r\n     (map (fn [k] [k (keep #(% k) mps)]) ks)\r\n     (identity)\r\n     (map (fn [[k vs]] (if (= 1 (count vs))\r\n                          [k (first vs)]\r\n                          [k (apply f vs)])))\r\n     (into {})  \r\n     )\r\n   \r\n   ))","problem":69,"user":"502a9fdee4b095a7adb898b4"},{"code":"(fn mymerge [F M N & K]\r\n(letfn [(siesta? [mfu ms1 ms2]\r\n    \t    (let [x (get ms1 (first ms2) nil)]\r\n\t\t\t\t (if (nil? x)\r\n\t\t\t\t     (assoc ms1 (first ms2) (second ms2))\r\n\t\t\t\t     (assoc ms1 (first ms2) (mfu x (second ms2))))))\r\n\t\t(acumula [mfu ms1 ms2]\r\n\t\t\t(reduce (partial siesta? mfu) ms1 ms2))\r\n\t\t]\r\n\t(let [RES1 (acumula F M N)]\r\n\t\r\n\t(if (empty? K)\r\n\t\tRES1\r\n\t\t(loop [acc RES1 krest K]\r\n\t\t\t(if (empty? krest)\r\n\t\t\t\tacc\r\n\t\t\t\t(recur (acumula F acc (first krest)) (rest krest))\r\n\t\t\t)\r\n\t\t)\r\n\t)\r\n\t)\r\n)\r\n)","problem":69,"user":"4dadca03c9a9d6ed4199dc57"},{"problem":69,"code":"(fn [f m & ms]\n  (println f) (println m) (println ms)\n  (letfn [(merge-maps-with [ml mr] \n              (let [[lp & mr] (seq mr) k (first lp)]\n                (if (nil? lp) ml\n                    (if (ml k)\n                       (recur (merge ml [k (f (ml k) (second lp))]) mr)\n                       (recur (merge ml lp) mr)))))] \n     (loop [ml m [mr & mt] ms]\n         (if (nil? mr) \n             ml\n             (recur (merge-maps-with ml mr) mt)))))","user":"559b55d6e4b066d22e731f54"},{"problem":69,"code":"(fn [f acc & xs]\n  (if (empty? xs)\n    acc\n    (letfn [(agg [m k v]\n                 (if (contains? m k)\n                   (assoc m k (f (m k) v))\n                   (assoc m k v)))]\n      (recur f\n             (reduce-kv agg acc (first xs))\n             (rest xs)))))","user":"55f73078e4b06e875b46cea4"},{"code":"(fn merge-with1\n  ([f hmap add] (reduce (fn [orig [k v]] (if (orig k) (assoc orig k (f (orig k) v)) (assoc orig k v))) hmap add))\n  ([f hmap add & additions] (apply merge-with1 f (merge-with1 f hmap add) additions)))","problem":69,"user":"532347dde4b09d4e7a9b54cc"},{"code":"(fn [f & args]\n\t(apply merge\n\t\t(map #(sorted-map (first %)\n\t\t\t(if (> (count (second %)) 1)\n\t\t\t\t(apply f (for [x (range (count (second %)))] (second (nth (second %) x))))\n\t\t\t\t(second (first (second %)))))\n\t\t(group-by first (apply concat args)))))","problem":69,"user":"51c09719e4b0c9c82288293c"},{"problem":69,"code":"(fn [func & params]\n       (let [grouped (group-by #(key %) (reduce #(concat %1 %2) params))]\n         (zipmap (keys grouped) (map #(reduce func (map last %)) (vals grouped)))))","user":"5654cb2de4b0f9d632dd848b"},{"problem":69,"code":"(fn [f result & maps]\n  \n  (let [answer (atom result)]\n    (doseq [m maps]\n      (doseq [[k v] m]\n        (if (@answer k)\n          (let [old (@answer k)] (swap! answer assoc k (f old v)))\n          (swap! answer assoc k v))))\n    \n    @answer))","user":"53d977f1e4b0e771c302547a"},{"code":"(fn\n  [f & ms]\n    (reduce (fn [acc el] (reduce #(assoc %1 %2\n               (if-let [i (%1 %2)]\n                  (f i (el %2))\n                  (el %2)))\n            acc (keys el))) (first ms) (rest ms)))","problem":69,"user":"4f1bb9d8535d64f60314647d"},{"problem":69,"code":"(fn [f a & m]\n  (reduce (fn [mr mx]\n            (reduce-kv (fn [r k v]\n                         (if-let [p (r k)]\n                           (assoc r k (f p v))\n                           (assoc r k v)))\n                       mr mx))\n          a m))","user":"54acf5c7e4b09f271ff37cdd"},{"problem":69,"code":"(fn [op & r]\n  (letfn [(mrg [m1 m2]\n            (reduce #(assoc %1 %2 (if (contains? m1 %2) (op (m1 %2) (m2 %2)) (m2 %2))) m1 (keys m2)))]\n    (reduce mrg r)))","user":"565a3e25e4b068f2fe63dbfb"},{"problem":69,"code":"(fn mw [f & maps]\n  (reduce\n   #(apply merge %1 (for [[k v] %2]\n                      {k\n                      (if (contains? %1 k)\n                        (f (get %1 k) v)\n                        v)}))\n   maps))","user":"5da760ebe4b000c986472c1a"},{"problem":69,"code":"(fn [f & ms]\n  (reduce \n   (fn [m0 mi]\n     (reduce \n      (fn [res [k v]]\n        (conj\n         res\n         [k (if-let \n             [v0 (get res k)]\n             (f v0 v)\n             v)]))\n      m0\n      mi))\n     {}\n     ms))","user":"578cf84ce4b0ebec4cfb7562"},{"problem":69,"code":"(fn [f & ms]\n    (into {}\n          (map\n           (fn [[k xs]]\n             (if (== 1 (count xs))\n               [k (second (first xs))]\n               [k (apply f  (map second xs))]))\n           (group-by first (apply concat ms)))))","user":"55597b84e4b0deb715856e36"},{"problem":69,"code":"(fn merge12 [f & cc] (let [km (->> cc (map keys) (apply concat) set)]\n    (->> (for [k km] [k (filter #(not (nil? %)) (map #(get % k) cc))])\n          (map (fn [c] [(first c) (reduce f (second c))])) (into {})) ;(map #([(first %) (apply f (second %))]))\n))","user":"55adf4d7e4b03311e7b732af"},{"code":"(fn [f m & c]\n  (let [r #(zipmap (keys %) (map f (vals %) (vals %2))) \n        s #(sort (select-keys % (keys %2)))]\n    (reduce #(merge % %2 (r (s % %2) (s %2 %))) m c)))","problem":69,"user":"4ec74de3535d6d7199dd36df"},{"code":"(fn merge-with2 [f & maps]\n  (let [reducer (fn [acc [k v]]\n    (if (contains? acc k)\n      (merge acc {k (f (acc k) v)})\n      (merge acc {k v})))]\n    (reduce reducer (first maps) (apply concat (map seq (rest maps))))))","problem":69,"user":"52ffb7f2e4b0d8b024fd370b"},{"problem":69,"code":"(fn my-merge-with\n  ([f m1 m2]\n   (reduce \n    (fn [m1 [k2 v2]]\n      (if (m1 k2)\n        (assoc m1 k2 (f (m1 k2) v2))\n        (assoc m1 k2 v2)))\n    m1\n    m2))\n  ([f m1 m2 & ms]\n   (reduce (partial my-merge-with f) (my-merge-with f m1 m2) ms)))","user":"539e717fe4b0ca733b974488"},{"problem":69,"code":"(fn test\n  [op & maps]\n  (reduce (fn [ans m]\n            (reduce (fn [inner-ans [k v]]\n                      (if (contains? inner-ans k)\n                        (assoc inner-ans k (op (inner-ans k) v))\n                        (assoc inner-ans k v)))\n                    ans m))\n          {} maps))","user":"5ce077e9e4b0a17bb84e2b0c"},{"code":"(fn mw\n  ([f m1 m2]\n   (loop [m1 m1 m2 m2]\n     (if (seq m2)\n       (let [[k v2] (first m2)]\n         (if (contains? m1 k)\n           (recur (update-in m1 [k] (fn [v1] (f v1 v2))) (rest m2))\n           (recur (assoc m1 k v2) (rest m2))))\n       m1)))\n  ([f m1 m2 & more]\n   (apply mw f (mw f m1 m2) (first more) (rest more))))","problem":69,"user":"511442d0e4b0e9c109bb74d5"},{"problem":69,"code":"(fn mer [f, & args]\n  (reduce (fn F [m mm]\n            (loop [m m, mm mm, res {}]\n              (if (empty? m)\n                (if (empty? mm)\n                  res\n                  (merge res mm))\n                (if (empty? mm)\n                  (merge res m)\n                  (recur (dissoc m (first (keys m)))\n                         (if (contains? mm (first (keys m)))\n                           (dissoc mm (first (keys m)))\n                           mm)\n                         (if (contains? mm (first (keys m)))\n                           (assoc res (first (keys m)) (f (m (first (keys m))) (mm (first (keys m)))))\n                           (assoc res (first (keys m)) (m (first (keys m))))))))))  \n          args))","user":"593d6793e4b069cdc2982ba6"},{"problem":69,"code":"(fn [f m & ms]\n    (if (empty? ms) m\n        (let [merged  (loop [acc m\n                             source (first ms)\n                             [k & ks] (keys source)]\n                        (if (nil? k) acc\n                            (if (contains? acc k)\n                              (recur (assoc acc k (f (acc k) (source k))) source ks)\n                              (recur (assoc acc k (source k)) source ks))))]\n          (recur f merged (rest ms)))))","user":"595bbab7e4b066ee0a44afe0"},{"code":"(fn mw [f & ms]\r\n  (let [ks (into #{} (mapcat keys ms))]\r\n    (into {} \r\n      (mapcat \r\n\t      (fn [k] \r\n\t\t      (hash-map k \r\n            (reduce f \r\n              (keep #(get % k) ms))))\r\n\t     ks))))","problem":69,"user":"4ddbdc1b535d02782fcbe9fd"},{"problem":69,"code":"(fn [f init & colls]\n  (loop [init init colls colls]\n    (if (seq colls)\n      (recur (reduce (fn [res cur]\n                       (let [x (get res (first cur))]\n                       (assoc res (first cur)\n                              (if x\n                                (f (get res (first cur)) (last cur)) \n                                (last cur)))))\n                     init (first colls))\n             (rest colls))\n      init)))","user":"562cb7cfe4b0a45d2ff83009"},{"problem":69,"code":"(fn [f & maps]\n    (reduce\n     (fn [m1 m2]\n       (reduce\n        (fn [m [k v]]\n          (assoc m k (if (m1 k) (f (m1 k) v) v)))\n        m1 m2))\n     (first maps) (rest maps)))","user":"55c5b55fe4b0e31453f649b5"},{"problem":69,"code":"(fn my-merge-with [f m & ms]\n  (letfn [(merge-one [f m1 m2]\n            (reduce (fn [m [k v]]\n                      (update-in m [k] #(if (nil? %) v (f % v))))\n                    m1 m2))]\n    (reduce #(merge-one f %1 %2) m ms)))","user":"5d272077e4b092dab7f59c64"},{"code":"(fn [f & maps]\n  (reduce\n   (fn [map1 map2]\n     (reduce (fn [m [k v]]\n               (assoc m k (if (contains? m k)\n                            (f (get m k) v)\n                            v)\n                      ))\n             map1\n             map2))\n   maps))","problem":69,"user":"50dcc5c9e4b02e6ac9592c93"},{"code":"(fn [r f & l]\r\n  (r #(r (fn [m [k v]]\r\n     (assoc m k (if (m k) (f (m k) v) v)))\r\n       % %2)\r\n     l))\r\nreduce","problem":69,"user":"4dce6e41535d5973398f92a2"},{"problem":69,"code":"(fn [ f & ms ]\n        (letfn   [ (mw [m1 m2]   (let [k1   (keys m1)\n                                       k2   (keys m2)\n                                       k12  (clojure.set/intersection (set k1) (set k2))\n                                       m12  (apply merge (map #(hash-map % (f (m1 %) (m2 %)))  k12))]\n                                   \n                                   (merge (merge m1 m2) m12)))]\n          (reduce mw ms)))","user":"564127a9e4b08d4f616f5ef3"},{"problem":69,"code":"(fn [f & args]\n  (let [ks (set (apply concat (map keys args)))]\n    (zipmap\n     ks\n     (map (fn [k]\n            (reduce f \n                   (filter #(not (nil? %)) (map #(% k) args))))\n          ks\n          )\n     )\n    )\n  )","user":"56d91a53e4b0ea9b8538f7ee"},{"code":"(fn [f & hms]\n\t(let [ks (distinct (mapcat #(keys %) hms))]\n    (->> ks\n      (reduce (fn [rs k] (assoc rs k (filter (comp not nil?) (map #(%1 k) hms)))) {})\n      (reduce #(assoc %1 (key %2) (reduce f (val %2))) {})\n      )\n    )\n\t)","problem":69,"user":"52cdb7efe4b07d0d72b2737c"},{"problem":69,"code":"(fn [f & maps]\n  (letfn [(rkv [m k v]\n            (if-let [orig-val (get m k)]\n              (assoc m k (f orig-val v))\n              (assoc m k v)))\n          (reduc [m1 m2]\n            (merge m1 (reduce-kv rkv m1 m2)))]\n\t(reduce reduc maps)))","user":"58d2af83e4b03c36ff7e5907"},{"problem":69,"code":"(fn merge [f m m2 & more]\n    (letfn [(merge1 [m1 mmerge]\n              (println \"m1:\" m1 \"mmerge:\" mmerge)\n              (if (empty? mmerge)\n                m1\n                (let [[k v] (first mmerge)\n                      v1 (get m1 k)\n                      v-new (if v1 (f v1 v) v)]\n                  (println \"extract kv pair:\" k v)\n                  (println \"v1:\" v1  \"v-new:\" v-new)\n                  (merge1 (assoc m1 k v-new) (rest mmerge))))\n              )]\n      (if (empty? more)\n        (merge1 m m2)\n        (apply merge f (merge1 m m2) (first more) (rest more))\n        ))\n    )","user":"57fc0719e4b0d3187e900987"},{"problem":69,"code":"(fn [f & maps] \n    (reduce\n        (fn [acc m]\n            (reduce\n                (fn [b k] \n                    (if \n                        (contains? b k)\n                        (assoc b k (f (get b k) (get m k)))\n                        (assoc b k (get m k))\n                ))\n                acc\n                (keys m)\n        ))\n        {}\n        maps)\n)","user":"5356d00ee4b04ce2eb3ed26f"},{"problem":69,"code":"(fn f [ op & li]\n  (letfn\n    [(actualiza_item [ac [key val]]\n       (update-in \n          ac\n          [key]\n          (fn [x] (if (nil? x) val (op x val)))))\n     (acumula \n       ([acc dic]\n        (reduce \n            actualiza_item \n            acc(seq dic))))]\n    (reduce acumula {} li)))","user":"4e6a5728535d8ccf87e9fecf"},{"problem":69,"code":"(fn [f & l]\n  (->> (mapcat keys l)\n       set\n       (map (fn [k] {k (reduce f (filter #(not (nil? %)) (map #(% k) l)))}))\n       (apply merge)))","user":"543366dde4b0b6b47310fcdf"},{"code":"(fn [f init & rest]\r\n   (let [e (first rest)\r\n         my-merge (fn [result later]\r\n                    (reduce (fn [result k]\r\n                              (let [val-in-result (get result k)\r\n                                    val-in-later (get later k)]\r\n                                (if val-in-result\r\n                                  (assoc result k (f val-in-result val-in-later))\r\n                                  (assoc result k val-in-later))))\r\n                            result (keys later)))]\r\n     (reduce my-merge init rest)))","problem":69,"user":"4e0d8c27535d04ed9115e7b7"},{"code":"(fn [f & xs]\n  (let [ks (distinct (mapcat keys xs))]\n    (zipmap ks\n            (map #(apply (if (= 1 (count %)) identity\n                           f)\n                         %) (for [k ks] (remove nil? (map #(get % k) xs)))))\n    )\n  )","problem":69,"user":"5269c150e4b03e8d9a4a71f8"},{"code":"(fn merge-with2 [f & maps]\n  (reduce (fn [l r] (\n                    reduce (fn [cur [k v]]\n                              (if (contains? cur k)\n                                (conj cur [k (f (get cur k) v)])\n                                (conj cur [k v])\n                           )) l r\n                      )) {} maps))","problem":69,"user":"50e3ec87e4b0463d32072486"},{"code":"(fn [f mp & mps]\n    (loop [m mp\n           ms mps]\n      (if (empty? ms)\n        m\n        (recur\n         (reduce (fn [accum [k v]]\n                   (if-let [val (get accum k)]\n                     (conj accum [k (f val v)])\n                     (conj accum [k v])))\n                 m (first ms))\n         (rest ms)))))","problem":69,"user":"50763574e4b0a894bb95bf3d"},{"problem":69,"code":"(fn my-merge-with\n  ([f m1 m2]\n   (reduce\n    (fn [res [k v]]\n      (if-let [old-v (get res k)]\n        (assoc res k (f old-v v))\n        (assoc res k v)))\n    m1\n    m2))\n  ([f m1 m2 & maps]\n   (apply my-merge-with (concat [f (my-merge-with f m1 m2)] maps)))\n  )","user":"5b7f2d75e4b047b03b203768"},{"code":"(fn [f & m]\r\n  (reduce \r\n  (fn[a [b c]]\r\n    (assoc a b\r\n      (if (a b) (f (a b) c) c)))\r\n  {} (apply concat m)))","problem":69,"user":"4deff9f9535d08e6dec9fe15"},{"problem":69,"code":"(fn [f & coll] \n    (reduce \n        (fn [a b] \n            (reduce \n                (fn [m [k v]] (assoc m k (if-let [ov (m k)] (f ov v) v))\n                ) a b\n            )\n        ) {} coll\n    )\n)","user":"580c8fcee4b0849f6811b721"},{"code":"(fn mw [f & ms]\n  (let [merge (fn [acc m] (apply zipmap (apply map vector\n                (map #(vector % (cond (and (m %) (acc %))\n                                        (f (acc %) (m %))\n                                      (m %) (m %)\n                                      :else (acc %)))\n                     (set (concat (keys acc) (keys m))))) ))]\n  (reduce merge ms)\n))","problem":69,"user":"4fca1cd6e4b0ee37620e184c"},{"problem":69,"code":"(fn [f result & maps]\n  (reduce \n    (fn [m [k new]] \n      (if-let [old (get m k)] \n        (conj m {k (f old new)})\n        (conj m {k new})))\n    result\n    (for [m maps [k v] m] [k v])))","user":"59a72effe4b066c664927d94"},{"problem":69,"code":"(fn [f & ms] (reduce (fn [acc m]\n              (prn acc m)\n                            (reduce-kv (fn [acc2 k v]\n                                         (prn acc2 k v)\n                                        (assoc acc2 k (if-let [v1 (get acc2 k)]\n                                                        (f v1 v)\n                                                        v\n                                                        )) \n                                         )\n                                       acc\n                                       m\n                                       )\n                            )\n            ms) )","user":"5ed8a12fe4b0c7845d86b0d7"},{"code":"(fn [f & maps]\n    (reduce\n      (fn [a b]\n         (reduce #(assoc %1 %2 (if-let [[_ p] (find %1 %2)]\n                                (apply f [p (get b %2)])\n                                (get b %2)))\n                 a (keys b)))\n      maps))","problem":69,"user":"52b63875e4b0c58976d9ad41"},{"problem":69,"code":"(fn [f & ms]\n  (reduce #(reduce (fn [m [k v]] (assoc m k (if (contains? m k) (f (m k) v) v)))\n                   %1 %2)\n          ms))","user":"554b8572e4b0a04f79299589"},{"problem":69,"code":"(fn\n  [f & ms]\n  (letfn [(merge-one\n           [x y]\n           (reduce-kv (fn\n                        [m k v]\n                        (if (contains? m k)\n                          (assoc m k (f (m k) v))\n                          (assoc m k v)))\n                      x\n                      y))]\n    (reduce merge-one ms)))","user":"59c74c28e4b0a024fb6ae540"},{"code":"(fn m \n([f m1 m2 & ms] \n  (if (seq ms) \n      (apply m f  (m f m1 m2) ms)\n      (m f m1 m2)))\n([f m1 m2]\n (merge m2 (into {} (map (fn [[k v]] (let [o (m2 k)] (if o [k (f v o)] [k v]))) m1)))))","problem":69,"user":"4ede8789535d10e5ff6f5337"},{"problem":69,"code":"(fn [f & ms]\n  (reduce\n   (fn [m1 m2]\n     (into m1\n           (map\n            #(if (m1 %)\n               {% (f (m1 %) (m2 %))}\n               {% (m2 %)})\n            (keys m2)))) ms))","user":"5e5096c6e4b027a2e10ac0c6"},{"problem":69,"code":"(fn [f & mps]\n    (letfn [(mrg [m [k v]]\n                 (assoc m k\n                   \t    (if (nil? (m k)) v (f (m k) v))\n                 ))]                 \n\t(reduce mrg {} (mapcat seq mps)) \n))","user":"5654d0e1e4b0f9d632dd848c"},{"problem":69,"code":"(fn [f init & ms]\n  (reduce (fn [a m2]\n            (reduce-kv (fn [m k v]\n                         (if (contains? m k)\n                           (assoc m k (f (get m k) v))\n                           (assoc m k v))) a m2)) init ms))","user":"606a70a5e4b069485764ddf2"},{"problem":69,"code":"(fn\n  [f mi & ms]\n  (reduce\n   (fn [ma mb]\n     (reduce\n      (fn [m [k v]] (assoc m k (if (contains? m k) (f (get m k) v) v)))\n      ma mb))\n   mi ms))","user":"5796d3ebe4b039eba2ecb0ee"},{"problem":69,"code":"(fn mw [f m & [hr & tr]]\n   (if hr\n      (let [nm (reduce-kv #(assoc %1 %2 (if-let [x (hr %2)] (f %3 x) %3)) hr m)] (apply mw f nm tr))\n      m))","user":"59f043d0e4b0966464fe6a3d"},{"code":"(fn [f & xs] \n  (reduce \n    #(reduce \n      (fn [ys [k v]]\n        (assoc ys k (if (ys k) (f (get ys k) v) v)))\n      %1 %2) \n    xs))","problem":69,"user":"4fb65f2fe4b081705acca2c7"},{"problem":69,"code":"(fn mw [f init & coll]\n  (reduce merge init \n          (mapcat\n            (fn [d] \n              (map \n                #(if (contains? init (key %))\n                   {(key %) (f (get init (key %)) (val %) )}\n                   {(key %) (val %)})\n                d)\n              )\n            coll)\n          ))","user":"5587d8b3e4b059ccff29b1e8"},{"problem":69,"code":"(fn [f & ms]\n    (let [keyvals (mapcat seq ms)]\n      (loop [m     {}\n             coll  (next keyvals)\n             [k v] (first keyvals)]\n        (if v\n          (recur (assoc m k (if-let [v2 (get m k)]\n                              (f v2 v)\n                              v))\n                 (next coll)\n                 (first coll))\n          m))))","user":"5777cffae4b0979f89651651"},{"problem":69,"code":"(fn my-merge-with [f & args]\n  (let [ks (distinct (mapcat keys args))]\n    (apply hash-map \n           (interleave ks (map \n                            (comp \n                              #(reduce f %) \n                              #(filter identity %)) \n                            (map (fn [k] ( map #(get %  k) args)) ks))))))","user":"52eaba10e4b09f7907dd14c2"},{"problem":69,"code":"(fn \n  [f & args]\n  (letfn \n    [(merge-entry\n      [m e]\n      (let [k (key e) v (val e)]\n        (if (contains? m k)\n          (assoc m k (f (get m k) v))\n          (assoc m k v))))\n      (merge2\n       [m1 m2]\n       (reduce merge-entry (or m1 {}) (seq m2)))]\n   (reduce merge2 args)))","user":"5f6e23e6e4b02876ed9fd064"},{"problem":69,"code":"(fn [f & ms] (reduce #(reduce-kv (fn [x k v] (assoc x k (if (x k) (f (x k) v) v))) %1 %2) ms))","user":"512700c4e4b083bb8f88cf14"},{"problem":69,"code":"(fn [f m & maps]\n  (letfn [(rf [m1 m2]\n            (let [rm (for [[k v] m2]\n                       (hash-map k (if (m1 k) (f (m1 k) v) v)))]\n              (into m1 rm)))]\n    (reduce rf m maps)))","user":"567695c2e4b05957ce8c6157"},{"problem":69,"code":"(fn [f m1 & ms] \n  (reduce (fn [m [k v]] (update-in m [k] #(if % (f % %2) %2) v)) m1 (apply concat ms)))","user":"5603c31fe4b04bb52996e1c1"},{"code":"(fn [-fn & more]\n   (->> (reduce into [] more )\n        (group-by key)\n        (map #(vector (first %) (map val (last %))))\n        (reduce #(assoc % (first %2) (if (= 1 (count (last %2)))\n                                       (first (last %2))\n                                       (apply -fn (last %2)))) {}))\n   )","problem":69,"user":"50550f43e4b0b1b9d1860eb7"},{"problem":69,"code":"(fn [f & args]\n    (reduce #(reduce (fn [a b]\n                        (if (a (first b))\n                            (update-in a [(first b)] (fn [x] (f x (second b))))\n                            (apply assoc a b)))\n                    % %2)\n            args))","user":"56677192e4b04acd4f672dd5"},{"problem":69,"code":"(fn [f & maps]\n  (let [[old-map & [merge-map & more-maps]] maps\n        new-map\n        (reduce (fn [m [k v]]\n                  (let [collision? (contains? m k)\n                        new-val (if collision?\n                                  (f (m k) v)\n                                  v)]\n                    (conj m [k new-val])))\n            old-map\n            merge-map)]\n    (if more-maps\n      (recur f (cons new-map more-maps))\n      new-map)))","user":"5764457ae4b0994c1922fbf3"},{"code":"(fn merge-with-f [f & ms]\n  (let [up-first-with-second (fn [f m1 m2]\n                               (loop [result m1, ks (keys m2)]\n                                 (if (empty? ks)\n                                   result\n                                   (let [k (first ks)\n                                         r2 (if (contains? m1 k)\n                                              (update-in result [k] f (m2 k))\n                                              (assoc result k (m2 k)))] \n                                     (recur r2 (rest ks))))))] \n    (loop [result (first ms), s (rest ms)]\n      (if (empty? s)\n        result\n        (recur (up-first-with-second f result (first s)) (rest s))))))","problem":69,"user":"52cf084ce4b07d0d72b27399"},{"code":"(fn my-merge-with [f & maps]\n  (reduce\n   (fn [rdc nxt]\n     (reduce\n      (fn [j [k v]]\n        (if (contains? j k)\n          (assoc j k (f (j k) v))\n          (assoc j k v)))\n      rdc\n      nxt))\n   {} maps))","problem":69,"user":"4e7f51eb535db966e863cc3f"},{"code":"(fn [f & args] \n    (reduce \n      (fn [accum coll] \n        (reduce\n          #(let [k (first %2)\n                 v (second %2)\n                 _ (println (str k \" \" v))] \n            (if (contains? % k) \n             (assoc % k (f (% k) v) )\n             (assoc % k v))) accum coll )) {} args ))","problem":69,"user":"53403110e4b085b17e897da6"},{"problem":69,"code":"(fn [f m & ms]\n  (reduce \n   (fn [m1 [k v]] (update-in m1 [k] #(if (nil? %) v (f % v))))\n  m (mapcat seq ms))\n)","user":"56d80542e4b0ea9b8538f7e1"},{"code":"(fn [f & a]\n  (into {}\n    (map \n      (fn [k] [k (reduce f (keep #(% k) a))])\n      (keys (apply merge a)))))","problem":69,"user":"4e5411e8535d8a8b8723a279"},{"problem":69,"code":"(fn [func & maps] (apply hash-map (apply concat (map (fn [[x y]] (if (= (count y) 1) [x (apply identity y)] [x (apply func y)])) (map #(vector (key %) (map second (val %))) \n                                                                                                                     (group-by first (apply concat maps))\n                                                                                                                     )\n                                                     )\n                                         )\n                         )\n  )","user":"55fe7e15e4b00f4cabc57651"},{"problem":69,"code":"(fn [f & ms]\n   (reduce (fn mrg [m1 m2]\n             (conj (conj m1 m2)\n                   (let [ks (filter #(contains? m2 %) (keys m1))\n                         vs (map f\n                                 (map #(get m1 %) ks)\n                                 (map #(get m2 %) ks))]\n                     (zipmap ks vs))))\n           ms))","user":"50981062e4b04e098a4c7268"},{"problem":69,"code":"(fn my-merge-with [fun & maps]\n  (reduce (fn [m1 m2]\n            (reduce (fn [m1 [k v]]\n                      (if (contains? m1 k)\n                        (assoc m1 k (fun (m1 k) v))\n                        (assoc m1 k v)))\n                    m1 m2))\n          maps))","user":"575b3e9be4b02ea11479935b"},{"code":"(fn [f m1 & mrest]\n  (if (empty? mrest)\n    m1\n    (if (empty? (first mrest))\n      (recur f m1 (rest mrest))\n      (let [[k v] (ffirst mrest)]\n        (if (get m1 k)\n          (recur f\n            (assoc m1 k (f (get m1 k) v))\n            (cons (dissoc (first mrest) k) (rest mrest)))\n          (recur f\n            (assoc m1 k v)\n            (cons (dissoc (first mrest) k) (rest mrest))))))))","problem":69,"user":"504e12ade4b078edc5f593b7"},{"problem":69,"code":"(fn[f & m]\n  (when (some identity m)\n    (let [me (fn [m e]\n\t\t\t(let [k (key e) v (val e)]\n\t\t\t  (if (contains? m k)\n\t\t\t    (assoc m k (f (get m k) v))\n\t\t\t    (assoc m k v))))\n          m2 (fn [m1 m2]\n\t\t   (reduce me (or m1 {}) (seq m2)))]\n      (reduce m2 m))))","user":"5f419985e4b0955706451fab"},{"code":"(fn [g m & ms]\n  (reduce \n    #(let [[f s] %2]\n        (assoc % f (if (% f) (g (% f) s) s)))\n      m (apply concat ms)))","problem":69,"user":"4e1350af535d04ed9115e7d8"},{"code":"(fn __ [f & maps]\n  (let [merge-fn (fn merge-fn [f a b]\n                   (cond\n                    (= a nil) b\n                    (= b nil) a\n                    :else (f a b)))\n        merge-two-maps-with (fn [f m1 m2]\n                              (if (empty? m2) m1\n                                (let [k (key (first m2))\n                                      v1 (m1 k)\n                                      v2 (m2 k)]\n                                  (recur f (assoc m1 k (merge-fn f v1 v2)) (dissoc m2 k)))))]\n    (reduce (partial merge-two-maps-with f) maps)))","problem":69,"user":"5119f3d5e4b06c8af0111818"},{"code":"(fn [f & xs] (reduce \n                #(reduce (fn [r [key rhs]]\n                           (let [lhs (r key)]\n                             (if lhs\n                               (conj r [key (f lhs rhs)])\n                               (conj r [key rhs]))))\n                          %1\n                          %2) xs))","problem":69,"user":"4faae01ae4b081705acca206"},{"code":"(fn mmw [f orig-map & other-maps]\n  (let [other-map (apply conj (conj other-maps {}))\n        k (-> other-map first first)\n        fv (orig-map k)\n        sv (other-map k)]\n    (if k\n      (if (and fv sv)\n        (mmw f (assoc orig-map k (f fv sv)) (dissoc other-map k))\n        (mmw f (assoc orig-map k sv) (dissoc other-map k)))\n      orig-map)))","problem":69,"user":"50c2fbebe4b00e537d00253c"},{"problem":69,"code":"(fn [f mp & params]\n          (let [parmap (apply merge params)]\n            (reduce #(if (contains? mp %2)\n                       (assoc %1 %2 (f (get mp %2 ) (get parmap %2)))\n                       (assoc %1 %2 (get parmap %2))\n                       ) \n                    mp \n                    (keys parmap))\n            )\n          )","user":"533c2605e4b0e30313ee6cd7"},{"problem":69,"code":"(fn [f & xs] \n  (reduce (fn [ret x] \n            (reduce (fn [s [k v]] \n                      (assoc s k \n                        (if-let [vold (s k)]\n                          (f vold v)\n                          v)))\n                    ret x))\n          {}\n          xs))","user":"55cdc576e4b0e31453f64a1f"},{"problem":69,"code":"#(into {} (for [[k v] (group-by key (mapcat vec %&))] [k (reduce % (map second v))]))","user":"5d0bb4fae4b0cc9c91588237"},{"code":"(fn [f & m]\n  (reduce #(reduce (fn [x [k v]]\n                     (if (x k)\n                       (assoc x k (f (x k) v))\n                       (assoc x k v)))\n                   %\n                   %2)\n          m))","problem":69,"user":"53034738e4b0d8b024fd373e"},{"problem":69,"code":"(fn [f & maps]\n   (reduce (fn [res m] \n             (into res \n                   (map (fn [[k v]] \n                           (if (contains? res k) \n                             [k (f (get res k) v)]\n                             [k v]))\n                        m))) \n           maps))","user":"58566b42e4b0f14aab7c86f4"},{"code":"(fn mw [f & maps]\n  (let [merge-entry (fn [m e]\n                      (let [k (key e) v (val e)]\n                        (if (contains? m k)\n                          (assoc m k (f (get m k) v))\n                          (assoc m k v))))\n        merge2 (fn [m1 m2]\n                 (reduce merge-entry (or m1 {}) m2))]\n    (reduce merge2 maps)))","problem":69,"user":"4dad7adac9a9d6ed0599dc57"},{"problem":69,"code":"(fn my-merge-with [f & maps]\n  (reduce (fn merge-one [merged m]\n            (reduce-kv (fn [merged* k v]\n                         (if (merged* k) (assoc merged* k (f (merged* k) v))\n                             (assoc merged* k v)))\n                       merged\n                       m))\n          (first maps)\n          (rest maps)))","user":"5db0d470e4b0f8c104ccfc9e"},{"problem":69,"code":"(fn [f & maps]\n  (let [merger (fn [f em m] (reduce (fn [em k] (if (not= (get em k) nil)\n                                                 (assoc em k (f (get em k) (get m k)))\n                                                 (assoc em k (get m k)))) em (keys m)))]\n\n    (loop [em {}\n           im maps]\n        (if-not (seq im)\n          em\n          (recur (merger f em (first im)) (rest im))))))","user":"58983e3fe4b00487982d52ce"},{"problem":69,"code":"(fn [f m & c]\n  (let [d (reduce merge c)]\n  (reduce \n   (fn [y x]\n     (if (contains? m x)\n       (assoc y x (f (get y x) (get d x)))\n       (assoc y x (get d x))))\n   m (keys d))))","user":"593744abe4b02506e01a299b"},{"problem":69,"code":"(fn [f m & args] (reduce (fn [r i] (reduce (fn [r2 [k v]] (if (get r2 k) (update-in r2 [k] #(f % v)) (assoc r2 k v))) r (vec i))) m args ))","user":"57086931e4b0b0fb43fd069e"},{"code":"(fn [f & maps]\n  (reduce\n    (fn [target source]\n      (reduce\n        (fn [target [k v2]]\n          (let\n            [v1 (get target k)]\n            (if\n              (contains? target k)\n              (assoc target k (f v1 v2))\n              (assoc target k v2))))\n        target\n        source))\n    maps))","problem":69,"user":"4f5c0549e4b0030a34fb2b1a"},{"problem":69,"code":"(fn [f & sets]\n  \n  (into {} (for [k (apply clojure.set/union (map #(set (keys %)) sets))] \n             [k \n              (let [v (remove nil? (map #(get % k) sets))]\n                (if (= 1 (count v))\n                  (first v)\n                  (apply f v)\n                ))\n              ]))\n  )","user":"5f58db95e4b0a0bc16850a9a"},{"problem":69,"code":"(fn [f & maps]\n  (let [mrg (fn [m1 m2]\n              (let [careful-assoc\n                    (fn [m k v]\n                      (assoc m k\n                        (if (contains? m1 k)\n                          (f (get m1 k) v)\n                          v)))]\n                (reduce-kv careful-assoc m1 m2)))]\n    (reduce mrg maps)))","user":"52513bf1e4b0541d1855b86e"},{"problem":69,"code":"(fn [f & c]\n  (reduce #(reduce (fn [r [k v]]\n                     (if-let [n (r k)]\n                       (assoc r k (f n v))\n                       (assoc r k v)))\n                   %\n                   %2)\n          c))","user":"5c1aadcde4b01240ff567209"},{"code":"(fn [f & m]\n  (into {}\n        (map (fn [[k [& v]]]\n               (let [[v1 & v2] (map second v)]\n               \t[k (reduce f v1 v2)]))\n             (group-by first (mapcat #(map identity %) m)))))","problem":69,"user":"50ae0d24e4b0a40c9cfb08ce"},{"problem":69,"code":"(fn my-merge-with\n  ([f m] m)\n  ([f m1 m2]\n   (reduce-kv (fn [m k v]\n                (if (contains? m k)\n                  (update-in m [k] f v)\n                  (assoc m k v)))\n              m1\n              m2))\n  ([f m1 m2 & ms]\n   (apply my-merge-with f (my-merge-with f m1 m2) ms)))","user":"52860baae4b0239c8a67ae09"},{"code":"(fn [f & s]\n  (into {} (map (fn [[k v]] (if (= (count v) 1) [k (v 0)] [k (apply f v)]))\n                (reduce \n                  (fn [x y]       \n                    (reduce \n                      #(assoc %1 (%2 0) (conj (get %1 (%2 0) []) (%2 1))) \n                      x \n                      y)\n                    ) \n                  {} s))))","problem":69,"user":"50fbdacfe4b0d10d794c19f0"},{"code":"(fn\n  [f & maps]\n  (reduce\n   (fn\n     [re aMap]\n     (reduce\n      (fn\n        [cur akey]\n        (if\n          (contains? cur akey)\n          (assoc cur akey (f (get cur akey) (get aMap akey)))\n          (assoc cur akey (get aMap akey))\n        )\n      )\n      re\n      (keys aMap)\n     )\n   )\n   (first maps)\n   (rest maps)\n  )\n)","problem":69,"user":"5162757ee4b03cfa3774b3fe"},{"problem":69,"code":"(fn func-merge \n  ([func map1 map2]\n   (let [key1 (first (keys map2))]\n     (if (empty? map2)\n       map1\n       (recur \n         func\n         (if (contains? map1 key1)\n           (assoc map1 key1 (func (map1 key1) (map2 key1)))\n           (assoc map1 key1 (map2 key1)))\n         (dissoc map2 key1)))))\n  \n  ([func map1 map2 & maps]\n    (reduce (partial func-merge func) (func-merge func map1 map2) maps)))","user":"574e84e0e4b02ea114799243"},{"code":"(fn [f & ms]\n  (reduce \n     (fn [r n]\n       (reduce \n          #(let [k (key %2)\n                 v (val %2)\n                 o (%1 k)]            \n            (if (nil? o)\n             (conj %1 %2)\n             (conj %1 {k (f o v)})))             \n          r \n          n)) \n     {} \n     ms))","problem":69,"user":"51dd9370e4b0c33a4e1da40c"},{"code":"(fn [fncpar fstpar & rstpar]\n                (loop [fnc fncpar fst fstpar rst rstpar]\n                  (if (empty? rst)\n                    fst\n                    (let [rstx (first rst)]\n                      (recur fnc\n                             (loop [ks (keys rstx) fstx fst]\n                               (if (empty? ks)\n                                 fstx\n                                 (let [kk (first ks)\n                                       ss (rest ks)\n                                       org (fstx kk)\n                                       new (rstx kk)]\n                                   (if (= nil org)\n                                     (recur ss\n                                            (assoc fstx kk new))\n                                     (recur ss\n                                            (assoc fstx kk\n                                                   (fnc org new )))))))\n                             (rest rst))))))","problem":69,"user":"52c81954e4b0c2d177d6212e"},{"problem":69,"code":"(fn [f & ms]\n        (reduce\n         (fn [res m]\n           (reduce\n            (fn [res [k v]]\n              (if (contains? res k)\n                (assoc res k (f (res k) v))\n                (assoc res k v)))\n            res\n            m))\n         {}\n         ms))","user":"546c4377e4b00cfc9eacc177"},{"problem":69,"code":"(fn m\n   [f a b & r]\n   (let [z (reduce (fn [q [k v]]\n                     (assoc q k (if (contains? q k) (f (q k) v) v))) a b)]\n     (if r (apply m f z r) z)))","user":"588fbb39e4b00487982d51bd"},{"problem":69,"code":"(fn [operator & maps]\n  (reduce\n   (fn [state step]\n     (reduce\n      (fn [inner-state [key value]]\n        (assoc inner-state key\n               (if (contains? inner-state key)\n                 (operator (get inner-state key) value)\n                 value)))\n      state\n      step))\n   maps))","user":"5f79bff2e4b02876ed9fd0ca"},{"problem":69,"code":"(fn [f & maps]\n  (let [key-set (keys (apply merge maps))]\n    (apply merge (map (fn [k]\n        (let [results (filter #(not(nil? %)) (map #(get % k) maps))]\n          (cond\n            (> (count results) 1) {k, (apply f results)}\n            :else {k, (first results)}))) key-set))))","user":"53bd7080e4b0d9a98559a6d1"},{"problem":69,"code":"(fn merge-maps [fn1 & maps]\n  (reduce \n   (fn [map1 map2] \n    (reduce\n      (fn [m [k v]]\n        (if (nil? (get m k))\n          (assoc m k v)\n          (assoc m k (fn1 v (get m k))))) map2 map1)) maps))","user":"554d0511e4b0a04f792995b5"},{"code":"(fn [f & maps]\n   (when (some identity maps)\n    (let [merge-entry (fn [m e]\n        (let [k (key e) v (val e)]\n              (if (contains? m k)\n                (assoc m k (f (get m k) v))\n                (assoc m k v))))\n          merge2 (fn [m1 m2]\n           (reduce merge-entry (or m1 {}) (seq m2)))]\n      (reduce merge2 maps))))","problem":69,"user":"4ee7d6d8535d93acb0a66870"},{"problem":69,"code":"(fn [f m & maps]\n  (reduce #(reduce (fn [m [k v]] (conj m {k (if (contains? m k) (f (m k) v) v)})) %1 %2) m maps))","user":"5dd60c58e4b0948ae9d9ad7c"},{"problem":69,"code":"(fn [f & os]\n  (->> os\n       (mapcat identity)\n       (group-by first)\n       (mapcat (fn [[k xs]] [k (reduce f (map second xs))]))\n       (apply hash-map)))","user":"5d81eba4e4b0915913b1d37b"},{"problem":69,"code":"(fn m-w\n  [fun & maps]\n  (let [keys (distinct (mapcat keys maps))]\n    (apply merge (for [key keys]\n                   (let [vals (keep #(get % key) maps)]\n                     (if (> (count vals) 1)\n                       {key (apply fun vals)}\n                       {key (first vals)}))))))","user":"54be792ee4b0ed20f4ff6eeb"},{"problem":69,"code":"(fn [the-fn & maps]\n  (loop [ms (rest maps)\n         acc (first maps)]\n    (if (empty? ms)\n      acc\n      (recur (rest ms) (loop [pairs (seq (first ms))\n                              acc acc]\n                         (if (empty? pairs)\n                           acc\n                           (recur (rest pairs) (let [fp (first pairs)\n                                                     [k v] fp\n                                                     ext (acc k)]\n                                                 (if (nil? ext)\n                                                   (apply assoc acc fp)\n                                                   (assoc acc k (the-fn ext v)))))))))))","user":"56018dd4e4b04bb52996e18f"},{"code":"(fn [f & ms]\n  (into {} (for [[k v] (group-by #(first %) (apply concat ms))]\n             [k (reduce f (for [[_ v] v] v))])))","problem":69,"user":"50b1d166e4b03ea880433554"},{"problem":69,"code":"(fn mw\n  [f & maps]\n  (reduce\n    (fn [m [k v]]\n      (if (contains? m k)\n        (update-in m [k] f v)\n        (assoc m k v)))\n    {}\n    (apply concat maps)))","user":"5d609ddde4b0c9e5857d5008"},{"problem":69,"code":"(fn merge-with2\n  [f & ms]\n  (reduce\n   (fn [merged map-to-merge]\n     (reduce\n      (fn [m [k v]]\n        (if (m k)\n          (update-in m [k] f v)\n          (assoc m k v)))\n      merged map-to-merge))\n   ms))","user":"51c8f1d8e4b07ef393169e5d"},{"code":"(fn\n  [f & maps]\n    (let [merge-entry (fn [m e]\n                        (let [k (key e) v (val e)]\n                          (if (contains? m k)\n                            (assoc m k (f (get m k) v))\n                            (assoc m k v))))\n          merge2 (fn [m1 m2]\n                   (reduce merge-entry m1  m2))]\n      (reduce merge2 maps)))","problem":69,"user":"518c5236e4b087e178201de0"},{"code":"#({\r\n*  {:a 4 :b 6 :c 20}\r\n- {1 7 2 10 3 15}\r\nconcat {:a [3 4 5] :b [6 7] :c [8 9]}\r\n  }\r\n  (first %&))","problem":69,"user":"4dcd818e535d5973398f929d"},{"problem":69,"code":"(fn [f m & ms]\n    (reduce (fn [acc elem]\n              (if (get acc (key elem))\n                (update-in acc [(key elem)] f (val elem))\n                (conj acc elem))) m (mapcat seq ms))\n    \n    )","user":"5e44c804e4b01d43a70e8e89"},{"problem":69,"code":"(fn [f & maps]\n  (loop [r {} m maps]\n    (if (empty? m) r \n      (recur (reduce \n              (fn [r [k v]] \n                (assoc r k (if (contains? r k) (f (r k) v) v)))\n              r\n              (first m)) \n             (next m)))))","user":"537f4652e4b06839e8705eb1"},{"problem":69,"code":"(fn [f & ms]\n  (let [ks (apply concat (map keys ms))]\n    (apply assoc {} (for [k ks\n                          :let [mks (for [m ms\n                                          :let [mk (m k)]\n                                          :when mk]\n                                      mk)]\n                          x [k (reduce f mks)]]\n                      x))))","user":"4ea03f70535d7eef308072a1"},{"problem":69,"code":"(fn f690\n  [f map1 & maps]\n  (let [map2 (into {} maps)\n        f* (fn ff69 [map [k v]]\n             (if (not= nil (get map k))\n               (assoc map k (f (get map k) v))\n               (assoc map k v)))]\n    (reduce  f* map1 map2 )))","user":"5db658ebe4b010eb3c36cd39"},{"problem":69,"code":"(fn [f m & ms] (if-let [m' (first ms)]\n                 (recur f\n                        (reduce (fn [acc [k v]] (if (contains? acc k)\n                                                  (update-in acc [k] f v)\n                                                  (assoc acc k v)))\n                                m\n                                (seq m'))\n                        (rest ms))\n                 m))","user":"5e6ba862e4b04a83ad7cd27d"},{"problem":69,"code":"(fn mymerge-with [f m1 & ms]\n  (if (seq ms)\n    (let [m2 (first ms)\n          keys1 (into #{} (keys m1))\n          keys2 (into #{} (keys m2))\n          m-merged (merge (select-keys m1 (clojure.set/difference keys1 keys2))\n                          (select-keys m2 (clojure.set/difference keys2 keys1))\n                          (into {} (for [k (clojure.set/intersection keys1 keys2)]\n                                     [k (f (get m1 k) (get m2 k))])))\n          ]\n      (recur f m-merged (rest ms)))\n    m1\n    )\n  )","user":"5fee18f2e4b05ac5b16ea1d2"},{"problem":69,"code":"(fn my-merge-with [f & maps]\n  (when (seq maps)\n    (letfn [(merge-entry [m e]\n              (let [k (key e)\n                    v (val e)]\n                (if (contains? m k)\n                  (assoc m k (f (m k) v))\n                  (assoc m k v))))\n            (merge2 [m1 m2]\n              (reduce merge-entry (or m1 {}) (seq m2)))]\n      (reduce merge2 maps))))","user":"5227f3ffe4b0186687e23a60"},{"code":"(fn new-merge-with\n  ([x & y]\n    (println y)\n    (let [first-map (first y)\n          second-map (second y)\n              new-merge-with-fn (fn [x-map x-entry]\n                                  (println \"new-merge-with-fn\" x-map x-entry)\n                                  (if (contains? x-map (key x-entry))\n                                    (merge x-map {(key x-entry) (x (get x-map (key x-entry)) (val x-entry))})\n                                    (merge x-map x-entry)))\n              apply-f-for-entry (fn iterate-map [f x-map y-map]\n                                  (println \"iterate-map\" x-map y-map)\n                                  (if (= 0 (count y-map))\n                                    x-map\n                                    (iterate-map f (f x-map (find y-map (first (keys y-map)))) (dissoc y-map (first (keys y-map))))))]\n              \n              (if (nil? second-map)\n                first-map\n                (if (= 2 (count y))\n                  (apply-f-for-entry new-merge-with-fn first-map second-map)\n                  (recur x (list* (apply-f-for-entry new-merge-with-fn first-map second-map) (rest (rest y)))))))))","problem":69,"user":"4e16bdef535d04ed9115e7e9"},{"problem":69,"code":"(fn mw [op m & ms]\n   (if (empty? ms)\n     m\n     (recur op \n       (reduce\n        (fn [m [k v]]\n          (assoc m k (if (m k) (op (m k) v) v)))\n        m\n        (first ms))\n       (rest ms))))","user":"5cdfe2aee4b0a17bb84e2b04"},{"code":"(fn [f & maps]\n  (reduce \n  \t(fn [m1 m2]\n\t\t(reduce \n\t\t(fn [m [k v]]\n\t\t    (assoc m k\n\t\t      (if (contains? m k) \n\t\t        (f (m k) v) \n\t\t        v))) \n\t  \tm1 m2)) \n  {} maps))","problem":69,"user":"531619c1e4b08068f379ed3d"},{"code":"(fn not-merge-with [f initial-map & maps]\n  (reduce (fn [result map] \n            (reduce (fn [result [k v]]\n                      (if(contains? result k)\n                        (assoc result k (f (result k) v))\n                        (assoc result k v)))\n                        result map)) \n          initial-map maps))","problem":69,"user":"50a4f36be4b0344e360f3bc9"},{"problem":69,"code":"(fn [func firstMap & maps] \n    (reduce \n     (fn [outmap mymap] \n       (reduce \n        (fn [out mapkey]\n          (let [outval (out mapkey), mapval (mymap mapkey)]\n            (if \n              (and (nil? outval) (nil? mapval))\n              out\n              (conj \n               out\n               (vector mapkey \n               (if \n                 (nil? outval)\n                 mapval\n                 (if\n                   (nil? mapval)\n                   outval\n                   (func outval mapval)\n                   )\n                 )\n                )\n               )\n              )\n            )\n          )\n        outmap (keys mymap)\n        )\n       )\n     firstMap maps\n     )\n  )","user":"58950f29e4b00487982d5270"},{"problem":69,"code":"(fn fjoin [func map1 & [m1 & mrest :as maps]]\n  \t(if (seq maps)\n      (recur func \n        (loop [[[k v :as item] & m1rest :as M] (seq m1), out map1]\n          (if (seq M)\n            (if (contains? out k) \n              (recur m1rest (conj out [k (func (out k) v)]))\n              (recur m1rest (conj out item)))\n             out))\n         mrest)\n      map1))","user":"564d02cde4b0284900eef679"},{"problem":69,"code":"(fn my-merge-with [f & maps]\n  (let [entries (mapcat identity\n                        (map identity maps))]\n    (reduce (fn [acc [k v]]\n              (if (contains? acc k)\n                (assoc acc k (f (acc k) v))\n                (assoc acc k v)))\n            {}\n            entries)))","user":"5ca14eb1e4b048ec896c5b7d"},{"problem":69,"code":"(fn merge-with-fn\n  [f & ms]\n  (reduce (fn [acc m]\n            (reduce (fn [acc k]\n                      (if (contains? acc k)\n                        (assoc acc k (f (get acc k) (get m k)))\n                        (assoc acc k (get m k))))\n                    acc\n                    (keys m)))\n          {}\n          ms))","user":"60c0ceb7e4b0e0fa5f1b42a6"},{"code":"(fn [f & maps]\n  (letfn [(r [acc m]\n            (let [keys (clojure.set/union (keys acc) (keys m))]\n              (into {}\n                    (for [key keys]\n                      [key (if (contains? acc key)\n                             (if (contains? m key)\n                               (f (acc key) (m key))\n                               (acc key))\n                             (m key))]))))]\n    (reduce r maps)))","problem":69,"user":"50d93c53e4b0fd36a4b89223"},{"problem":69,"code":"(fn [f & rest]\n   (reduce (fn [acc item]\n             (reduce (fn [acc2 item2]\n                       (let [key (first item2) \n                             value (second item2)]\n                         (if (get acc2 key)\n                           (update-in acc2 [key] f value)\n                           (assoc acc2 key value)))) \n                     acc item))\n           rest))","user":"5a64dcabe4b0512ff01cd9a9"},{"problem":69,"code":"(fn [func & maps]\n  \n  \n  (loop [loop-map (first maps)\n         next-map (second maps)\n         rest-maps (rest (rest maps))]\n;   (u/dbg rest-maps)\n;    (u/dbg (first rest-maps))\n;    (u/dbg next-map)\n    (if (not next-map) loop-map\n    (recur \n      ((fn [func loop-map next-map]     \n       (loop [ key-list (keys next-map)\n               key (first key-list)\n               val (loop-map key)\n               mp-val (next-map key)\n               result-map loop-map]\n         ;(u/dbg key-list)\n         ;(u/dbg result-map)\n         ;(u/dbg (count (rest key-list)))\n         (if (not key) result-map \n         (recur \n           (rest key-list)\n           (second key-list)\n           (loop-map (second key-list))\n           (next-map (second key-list))\n           (if (and val mp-val)\n             (do\n             ;(u/dbg (func val mp-val))\n             ;(u/dbg key)\n             (assoc result-map key (func val mp-val))\n            \n             )\n             (if mp-val\n               (assoc result-map key mp-val) \n               result-map))))))  func loop-map next-map)\n           (first rest-maps)\n           (rest rest-maps)))))","user":"53c73e8ae4b00fb29b2212a5"},{"code":"(fn [f & maps]\n\t(let [merge-entry (fn [m e]\n\t\t(let [k (key e) v (val e)]\n\t\t\t (if (contains? m k)\n\t\t\t    (assoc m k (f (get m k) v))\n\t\t\t    (assoc m k v))))\n          \t\tmerge2 (fn [m1 m2]\n\t\t   \t\t(reduce merge-entry (or m1 {}) (seq m2)))]\n      \t\t\t\t(reduce merge2 maps)))","problem":69,"user":"51622fb8e4b009fba0926e3f"},{"problem":69,"code":"(fn x [f & ms]\n  (reduce \n     (fn y [result [k v]]\n       (if (get result k)\n         (assoc result k (f (get result k) v))\n         (assoc result k v)\n         \n         )\n       \n       \n       )\n          \n          \n   {} (reduce #(concat %1 (seq %2)) '() ms))\n  \n  \n  )","user":"56db90d4e4b0ea9b8538f80d"},{"problem":69,"code":"(fn [f & colls]\n  (->> colls\n    (apply #(mapcat seq %&))\n    (group-by first)\n    (mapcat (fn [[k v]] [k (reduce f (map last v))]))\n    (apply hash-map)\n  ))","user":"59cf4013e4b0ef0a1e9b5b68"},{"problem":69,"code":"(fn [funk & maps]\n  (let [merger (fn [m k v]\n                 (if (contains? m k)\n                   (assoc m k (funk (m k) v))\n                   (assoc m k v)))\n        reducer (fn [a b]\n                  (reduce-kv merger a b))]\n    (reduce reducer maps)))","user":"50eeeadae4b02c17778c91f3"},{"code":"(fn [f & maps]\n  (reduce (fn [m1 m2]\n            (let [k1 (set (keys m1))\n                  k2 (set (keys m2))\n                  _ (println k1 k2)\n                  kboth (clojure.set/intersection k1 k2)\n                  _ (println kboth)\n                  map1 (merge m1 m2)\n                  _ (println map1)\n                  newkvs (reduce concat \n                          (map\n                           (fn [k] \n                             [k (f (m1 k) (m2 k))])\n                           (seq kboth)))\n                  _ (println newkvs)]\n              (apply assoc map1 newkvs))\n                  \n  ) maps))","problem":69,"user":"4f036fb3535dcb61093f6ac8"},{"code":"(fn [f & ms]\n  (reduce\n    (fn [result m]\n      (reduce\n        #(if (contains? %1 %2)\n           (assoc %1 %2 (f (get %1 %2) (get m %2)))\n           (assoc %1 %2 (get m %2)))\n        result (keys m)))\n    {} ms))","problem":69,"user":"4dad76588e77d6ed63f12a44"},{"problem":69,"code":"(fn [f init-m & ms]\n    (reduce (fn [acc [k v]]\n              (if-let [cur-v (get acc k)]\n                (assoc acc k (f cur-v v))\n                (assoc acc k v)))\n            init-m\n            (mapcat identity ms)))\n\n;; (fn [f m & ms]\n;;     (reduce (fn [acc cur-m]\n;;               (reduce (fn [cur-acc [k v]]\n;;                         (if-let [cur-v (get cur-acc k)]\n;;                           (assoc cur-acc k (apply f [cur-v v]))\n;;                           (assoc cur-acc k v)))\n;;                       acc\n;;                       cur-m))\n;;             m\n;;             ms))","user":"591ad160e4b09b4ee5954bdf"},{"code":"(fn [f & maps] (reduce #( let [conf (map key (select-keys % (keys %2)))] ; Conf - conflicted keys of two current maps\n                                   (reduce (fn [p n] (assoc p (first n) (last n))) ; Resolves all conflicts iteratevely\n                                           (merge % %2) ; Starting map (obtained as merging two current)\n                                           (map vector  ; Supplying conflicting [key, value] for reduce\n                                              conf ; Key\n                                              (map f (map % conf) (map %2 conf)) ; Value - (f value1 value2)\n                                           )\n                                   )\n                                 )\n                        maps)) ; Supplying maps for reduce","problem":69,"user":"5061cc17e4b0a30dc9a35d34"},{"problem":69,"code":"(fn [f a-map & maps]\n    (reduce (fn [map [k v]]\n              (if (contains? map k)\n                (assoc map k (f (map k) v))\n                (assoc map k v)))\n            a-map\n            (apply concat maps)))","user":"4f42c80ae4b0d7d3c9f3fd0f"},{"problem":69,"code":"(fn [f & maps]\n  (let [x (fn [m [k v]]\n            (if (contains? m k)\n              (assoc m k (f (m k) v))\n              (assoc m k v)))]\n    (reduce #(reduce x (or % {}) %2) maps)))","user":"53d86564e4b0e771c302546b"},{"problem":69,"code":"(fn [f & maps]\n  (reduce (fn [acc [k v]]\n            (if (contains? acc k)\n              (update-in acc [k] f v)\n              (assoc acc k v)))\n          {}\n          (apply concat maps)))","user":"5458c74de4b01be26fd74623"},{"code":"(fn [op & hs] \n  (reduce\n  \t(fn [acc h]\n      (reduce \n        (fn [a [k v]] \n          (if (contains? a k)\n            (assoc a k (op (a k) v))\n            (assoc a k v)))\n        acc\n        h))\n    {}\n   \ths))","problem":69,"user":"516abecae4b081287f204e9f"},{"code":"(fn [f m & maps]\n  (letfn [(mrg [r [k v]]\n            (assoc r k (if (m k) (f (m k) v) v)))]\n    (if (seq maps)\n      (recur f (reduce mrg m (first maps)) (rest maps))\n      m)))","problem":69,"user":"511d6a01e4b022853b0e07a5"},{"problem":69,"code":"(fn [f & args]\n  (reduce \n    (fn [m m-new]\n      (reduce \n        (fn [agg [k v]]\n          (if (contains? agg k)\n            (update-in agg [k] f v)\n            (assoc agg k v)))\n        m m-new))\n    (first args) \n    (rest args)))","user":"5f431d32e4b0955706451fb5"},{"problem":69,"code":"(fn [f & maps]\n  (reduce (fn [x [k v]] (assoc x k (if (contains? x k) (f (get x k) v) v)))\n          {}\n          (apply concat (map vec maps))))","user":"543d5c61e4b032a45b86934d"},{"problem":69,"code":"(fn my-merge-with\n  [f first-map & maps]\n  (reduce\n    (fn [m1 m2]\n      (reduce\n        (fn [m [k v]] (assoc m k (if-let [curr (m k)] (f curr v) v)))\n        m1\n        m2))\n    first-map\n    maps))","user":"5c3ac091e4b0d62ef62d9f95"},{"problem":69,"code":"(fn my-merge [func & maps]\n  \t(reduce\n     (fn [a b]\n       ;(println a b)\n       (reduce \n         (fn [x [k v]]\n           ;(println x k v)\n           (assoc x  k  (if (nil? (b k))\n                          v\n                          (func v (b k))))\n         )\n       b a))\n     (first maps) (rest maps)))","user":"53858594e4b06839e8705f05"},{"problem":69,"code":"(fn\n    [f & maps]\n    (reduce\n      (fn [a b]\n        (->> (concat a b)\n             (group-by first)\n             (map (fn [[k v]]\n                    (prn v)\n                    [k (if (= 1 (count v))\n                         (second (first v))\n                         (apply f (map second v)))]))\n             (into {})))\n      maps))","user":"5bab5440e4b0a20761a23475"},{"problem":69,"code":"(fn [f & ms] (let [mm (apply merge ms)\n                        ks (keys mm)\n                        rf (fn [koef fc maps] (reduce fc (filter #(not (= % nil)) \n                                                                 (map #(get % koef) maps))))] \n                    (into {} (map #(vector % (rf % f ms)) ks))))","user":"575ddfd1e4b02ea11479938d"},{"code":"(fn mergef [op m1 & [m2 :as ls]]\n  (if (or (empty? m2) (nil? m2)) m1\n    (apply mergef (flatten (list op (loop [ls (seq m2) acc m1]\n      (cond (empty? ls) acc\n        (contains? acc (ffirst ls))\n        (recur (rest ls) (-> acc (conj {(ffirst ls) (op  (get acc (ffirst ls))  (second (first ls))) } )))\n        :else (recur (rest ls) (-> acc (conj (first ls)))))) (rest ls))))))","problem":69,"user":"5301157ae4b0d8b024fd3717"},{"problem":69,"code":"(fn [op m & more]\n  (let [n (atom m)]\n  (doseq [o more]\n    (doseq [[k v] o]\n      (if (m k)\n        (swap! n assoc k (op (m k) v))\n        (swap! n assoc k (o k)))))\n    @n))","user":"53da059be4b0e771c302547e"},{"code":"(fn [f & args]\n  (->> (apply concat args)\n       (group-by first)\n       (reduce #(conj %\n                      [(first %2) \n                       (let [x (map second (second %2))]\n                        (if (= 1 (count x))\n                            (apply identity x)\n                            (apply f (map second (second %2)))))]) \n               {})))","problem":69,"user":"50435689e4b034ff00315d21"},{"problem":69,"code":"(fn [f & ms] (->> ms\n                 (apply concat)\n                 (group-by first)\n                 (map (fn [[k v]] [k (reduce f (map second v))]))\n                 (into {})))","user":"5960a1a6e4b066ee0a44b08e"},{"problem":69,"code":"(fn goop [f & args]\n  (reduce (fn [x y]\n            (let [z (keys y)]\n              (reduce (fn [a b]\n                        (if (contains? a b)\n                          (update-in a [b] f (get y b))\n                          (conj a {b (get y b)})))\n                      x z)))\n          (first args) (rest args)\n))\n\n;; Originally, you had only the solution to the first test:\n;;   reduce (over each map) using a function that does the function with update-in or just conj's\n;; You fixed it by adding an imbedded reduce to go per key in each map","user":"577bcbd9e4b0d3393e5deb1b"},{"problem":69,"code":"(fn [f & maps]\n  (reduce #(conj %1 (let [[k v] %2] \n                      [k (if-let [n (%1 k)] (f n v) v)])) \n          {} \n          (apply concat maps)))","user":"56c4f43ce4b05cc29241ee9c"},{"code":"(fn f [F & maps]\n  (reduce\n    (fn g [m1 m2]\n      (reduce\n        #(if-let [v (%1 (key %2))]\n          (assoc %1 (key %2) (F v (val %2)))\n          (assoc %1 (key %2) (val %2)))\n        m1 m2))\n    maps))","problem":69,"user":"50464831e4b011c5dfee771f"},{"problem":69,"code":"(fn mymerge [f & maps]\n  (reduce (fn [a b] ;; the function to merge two maps\n            (reduce (fn [coll [k v]];; the function to merge each of b to a  \n                      (if-let [vv (coll k)]\n                        (assoc coll k (f vv v))\n                        (assoc coll k v)))\n                    a b)) maps))","user":"5ab490f4e4b073f17744261d"},{"problem":69,"code":"(fn [f & args]\n  (reduce (fn [map1 map2]\n            (reduce (fn [m [k v]]\n                      (if-let [vv (m k)]\n                        (assoc m k (f vv v))\n                        (assoc m k v)))\n                    map1 map2))\n          args))","user":"51bfc1f0e4b0e49ef9037dd4"},{"problem":69,"code":"(fn [f m1 & ms]\n    (if (empty? ms)\n      m1\n      (recur\n        f\n        (reduce (fn [a [k v]]\n                  (if (nil? (get a k))\n                    (assoc a k v)\n                    (assoc a k (f (get a k) v)))) m1 (first ms))\n        (rest ms))))","user":"559a9a3de4b066d22e731f45"},{"problem":69,"code":"(fn mrg [f map & maps]\n  (reduce\n   (fn [m1 m2]\n     (reduce\n      (fn [m [k v]]\n        (if (contains? m k)\n          (assoc m k (f (m k) v))\n          (assoc m k v)))\n      m1 m2)) map maps))","user":"5a426a3fe4b0447ef91cc5f2"},{"problem":69,"code":"(fn [f m & ms]\n  (reduce (fn [a b] (apply conj a (map (fn [[k bv]] (if-let [av (a k)] [k (f av bv)] [k bv])) b))) m ms))","user":"54f0d3fde4b024c67c0cf8a6"},{"code":"(fn imerge \n  ([fkt m1 m2] \n    (reduce (fn [result kv] (let [old (get m1 (key kv))]\n                              (conj result (if old \n                                             [(key kv) (fkt old (val kv))] \n                                             kv)))) \n            m1 m2))\n  ([fkt m1 m2 & more]\n    (if more\n      (recur fkt (imerge fkt m1 m2) (first more) (next more))\n      (imerge fkt m1 m2))))","problem":69,"user":"4fae5401e4b081705acca249"},{"code":"(fn [op & args]\n   (reduce (fn [m k]\n             (assoc m k\n                    (reduce op (remove #(= :notfound %) (map #(get % k :notfound) args)))))\n           {} (keys (apply merge args))))","problem":69,"user":"4eb02674535d7eef30807338"},{"code":"(fn merge-with' [f & ms]\n  (reduce\n   (fn\n     [m1 m2]\n     (if (= m2 {})\n       m1\n       (let [k (first (keys m2))]\n         (if (contains? m1 k)\n           (recur (assoc (dissoc m1 k) k (f (m1 k) (m2 k)))\n                  (dissoc m2 k))\n           (recur (assoc m1 k (m2 k))\n                  (dissoc m2 k))))))\n   {}\n   ms))","problem":69,"user":"5316cdcae4b08068f379ed4b"},{"code":"#(letfn [(merge-w\n            [f & maps]\n            (reduce\n              (fn [m1 m2]\n                (reduce\n                  (fn [m e]\n                    (let [k (key e) v (val e)]\n                      (assoc\n                        m\n                        k\n                        (if-let [prev (m k)]\n                          (f prev v)\n                          v))))\n                  m1\n                  m2))\n              {}\n              maps))]\n   (apply merge-w %1 %&))","problem":69,"user":"51fb9d30e4b0f1313d468a0f"},{"problem":69,"code":"(fn\r\n  [f & m]\r\n  (into {}\r\n    (map\r\n      (fn [[k v]] \r\n        (vector k (reduce f (map last v)))) \r\n      (group-by first\r\n        (reduce\r\n          #(concat %1 (map identity %2))\r\n          []\r\n          m)))))","user":"5470699ae4b00cfc9eacc1b6"},{"code":"(fn my-merge-with\n  [f & maps]\n  (when (some identity maps)\n    (let [merge-entry (fn [m e]\n\t\t\t(let [k (key e) v (val e)]\n\t\t\t  (if (contains? m k)\n\t\t\t    (assoc m k (f (get m k) v))\n\t\t\t    (assoc m k v))))\n          merge2 (fn [m1 m2]\n\t\t   (reduce merge-entry (or m1 {}) (seq m2)))]\n      (reduce merge2 maps))))","problem":69,"user":"509e62a8e4b08df8156e9e2e"},{"problem":69,"code":"(fn merge-f [f & maps]\n  (let [assoc-with (fn [xmap [k v]]\n                     (assoc xmap k\n                       (if (xmap k) (f (xmap k) v) v)))\n        merge-2 (fn [map1 map2]\n                  (reduce assoc-with map1 (seq map2)))]\n    (reduce merge-2 maps)))","user":"55253217e4b0882d96d091ce"},{"problem":69,"code":"(fn my-merge-with\n  [f f-map & r-maps]\n  (reduce (fn [c n]\n            (reduce (fn [current key]\n                      (if (contains? current key)\n                        (assoc current key (f (current key) (n key)))\n                        (assoc-in current [key] (n key)))\n                     ) c (keys n)) \n            ) f-map r-maps))","user":"5b759ca8e4b047b03b2036d0"},{"code":"(fn mwith [f & maps]\n  (when (some identity maps)\n    (let [merge-entry (fn [m e]\n\t\t\t(let [k (key e) v (val e)]\n\t\t\t  (if (contains? m k)\n\t\t\t    (assoc m k (f (get m k) v))\n\t\t\t    (assoc m k v))))\n          merge (fn [m1 m2]\n\t\t   (reduce merge-entry (or m1 {}) (seq m2)))]\n      (reduce merge maps))))","problem":69,"user":"51181009e4b0e0897831a60f"},{"problem":69,"code":"(fn [f m & ms]\n  (let [mymerge\n        (fn [m1 m2]\n          (reduce #(if (contains? %1 (key %2))\n                     (->> (f (%1 (key %2)) (val %2))\n                          (hash-map (key %2))\n                          (merge %1))\n                     (merge %1 %2)) m1 m2))]\n    (reduce mymerge m ms)))","user":"577c3da9e4b0c8d87281f6b9"},{"problem":69,"code":"(fn [f a & xs]\n   (letfn [(merge-map [acc x]\n             (reduce (fn [acc [k v]]\n                       (if (contains? (set (keys acc)) k)\n                         (assoc acc k (f (get acc k) v))\n                         (assoc acc k v)))\n                     acc\n                     x))]\n     (reduce merge-map a xs)))","user":"51bb08a4e4b0fe3ecfb46446"},{"code":"(fn merge-with2 [f & ms]\n  (loop [vecs (mapcat #(identity %) ms)\n        k (first (first vecs))\n        v (last (first vecs))\n        merged {}]\n        (cond\n          (empty? vecs)\n            merged\n          (merged k)\n            (recur (rest vecs) (first (second vecs)) (last (second vecs)) (assoc merged k (f (merged k) v)))\n          :default \n            (recur (rest vecs) (first (second vecs)) (last (second vecs)) (assoc merged k v)))))","problem":69,"user":"4faafccde4b081705acca209"},{"code":"(fn blah [f & maps]\n    (let [merge-map (fn [f map1 map2]\n                      (loop [[k v] (first map2)\n                                   [kv & more] (rest map2)\n                                   {current-v k :as accum} map1]\n                        (cond (nil? k) accum\n                              (nil? current-v) (recur kv more \n                                                      (assoc accum k v))\n                              true (recur kv more \n                                          (assoc accum k (f current-v v))))))]\n      (loop [accum (first maps)\n                   [map1 & more] (rest maps)]\n        (if (nil? map1)\n          accum\n          (recur (merge-map f accum map1) more)))))","problem":69,"user":"4f17aa97535d64f603146456"},{"problem":69,"code":"(fn [f m & maps]\n  (reduce\n    (fn [m1 m2]\n      (reduce\n        (fn [m [k v]]\n          (if-let [v1 (get m k)]\n            (assoc m k (f v1 v))\n            (assoc m k v)))\n        m1\n        m2))\n    m\n    maps))","user":"5b0e6795e4b0cc2b61a3be03"},{"problem":69,"code":";(\n(fn [f target & maps]\n  (let [mw-1 (fn [f m1 m2]\n               (reduce\n                (fn [o [k v]]\n                  (assoc\n                   o \n                   k \n                   (if-let [e (o k)]\n                     (f e v)\n                     v)))\n                m1\n                m2))]\n    #_(mw-1 f target (first maps))\n    (reduce\n     (fn [o m]\n       (mw-1 f o m))\n     target\n     maps)))\n;+ {:a 5 :b 3} {:a 1 :c 9} {:d 4})","user":"5e64ae6ce4b0fd0acd1586ac"},{"problem":69,"code":"(fn test [f x  & y ]\n (letfn [\n          (mergewith [f map1 map2]\n               (let [entries \n                       (into [] \n                             (clojure.set/union (set (keys map1)) (set (keys map2)))\n                        )]\n\t\t(loop [  i 0 result {}   ]\n                   (cond \n                      (>= i (count entries))   result\n                      (nil? (get map2  (nth entries i))) (recur (inc i)  (conj result {(nth entries i)  (get map1  (nth entries i))})  )    \n                      (nil? (get map1  (nth entries i))) (recur (inc i)  (conj result {(nth entries i)  (get map2  (nth entries i))}) )    \n                      :else (recur  (inc i) (conj result {(nth entries i)  (f (get map1  (nth entries i))  (get map2 (nth entries i)))}) )\n                   )\n                \n               )\n           )\n          )\n\n        ]\n        (cond \n          (empty? y) x\n          (= (count y) 1) (mergewith f x (first y))\n          :else (apply test f (mergewith f x (first y))  (rest y))        \n        )\n   )\n )","user":"56e6e1e6e4b02e7e935eb6cf"},{"problem":69,"code":"(letfn \n  [(mergew [f map1 map2]\n    ; Base case: empty map2\n    (if (empty? map2) map1\n      (let [[k v] (first map2)]\n        ; Key exists in map1, merge with f\n        (if (map1 k) \n          (recur f (assoc map1 k (f (map1 k) v)) (rest map2))\n          ; Key doesn't exist, just add the value\n          (recur f (assoc map1 k v) (rest map2))))))]\n  (fn [f & maps]\n    (reduce (partial mergew f) (first maps) (rest maps))))","user":"53065acbe4b02e8216869792"},{"code":"(fn zerge-with [f m & maps]\n  (let [all-keys (set (reduce #(concat %1 (keys %2)) (keys m) maps))]\n  \t(zipmap\n\t    all-keys\n\t    (for [k all-keys]\n\t\t\t  (reduce #(if (nil? %1)\n                    (%2 k)\n                    (if (contains? %2 k)\n                      (f %1 (%2 k))\n                      %1))\n             (m k)\n\t           maps)))))","problem":69,"user":"4e5fdd68535d8ccf87e9fe4f"},{"problem":69,"code":"(fn [f & rest]\n  (reduce (fn[x y]\n            (apply merge (apply merge (for [key (keys x)]\n              (if (contains? y key)\n                {key (apply f [(get x key) (get y key)])}\n                {key (get x key)})\n              ))\n            (apply merge (for [key1 (clojure.set/difference (set (keys y)) (set (keys x)))]\n              {key1 (get y key1)})))) rest))","user":"5bab31f1e4b0a20761a23471"},{"code":"(fn [f m & s]\r\n  (let [m- (fn [m1 m2]\r\n             (loop [[k & ks] (keys m2) ret m1]\r\n               (cond\r\n                 (ret k) (recur ks (assoc ret k (f (ret k) (m2 k))))\r\n                 k (recur ks (assoc ret k (m2 k)))\r\n                 :else ret)))]\r\n    (if s (recur f (m- m (first s)) (next s)) m)))","problem":69,"user":"4fd2e5d8e4b04c3a95aa0427"},{"problem":69,"code":"(fn [f & maps]\n  (loop [ms (rest maps)\n         result (into {} (first maps))]\n    (if-not (seq ms)\n      result\n      (recur (rest ms)\n             (reduce (fn [acc new]\n                       (if-not (acc (first new))\n                         (conj acc new)\n                         (assoc acc (first new) (f (acc (first new)) (second new)))\n                         ))\n                     result (first ms)))\n      )\n    )\n  )","user":"544a049de4b0e39780006953"},{"code":"(fn [f & m] \n  (reduce \n    #(reduce \n      (fn [l r] \n        (assoc l r \n          (if (l r) \n            (f (l r) (%2 r))\n            (%2 r)))) \n      % (keys %2)) \n    m))","problem":69,"user":"4fb3b865e4b081705acca2a2"},{"problem":69,"code":"(fn [f & all_maps]\n  (reduce (fn [ret current]\n            (reduce (fn [ret2 [k v]]\n                      (let [value (get ret2 k)]\n                        (if (= value nil)\n                          (assoc ret2 k v )\n                          (assoc ret2 k (f value v)))) )ret current )  )all_maps) )","user":"5e4ba8e8e4b0889a8790a55a"},{"code":"(fn mwf [f & m]\r\n  (reduce \r\n\t\t(fn do-stuff [m1 m2] \r\n\t\t\t(into {} \r\n\t\t\t\t(map \r\n\t\t\t\t\t(fn mw [k] (if \t(and (get m1 k) (get m2 k)) \r\n\t\t\t\t\t\t\t\t\t[k (f (get m1 k) (get m2 k))]\r\n\t\t\t\t\t\t\t\t\t(if (get m1 k) \r\n\t\t\t\t\t\t\t\t\t\t[k (get m1 k)]\r\n\t\t\t\t\t\t\t\t\t\t[k (get m2 k)])))\r\n\t\t\t\t\t(apply conj (keys m2) (keys m1)))))\r\n\t\t m))","problem":69,"user":"4ecf1f51535d1f5ad70dba3a"},{"problem":69,"code":"(fn [zp & args]\n      (letfn [  (merge-two-maps [tp m8 m9]\n    (letfn [(merge-one-key [op k m1 m2] \n          [k (if(contains? m2 k) (op (get m2 k) (get m1 k)) (get m1 k)) ]\n       )]\n\n     (into {} (map #(merge-one-key tp % m8 m9)  (keys m8)))\n   )\n  )]\n    (loop [opr zp xs args acc {}]\n       (if (empty? xs)\n            acc\n          (recur opr \n                 (rest xs)\n                (into acc (merge-two-maps opr (first xs) acc))\n          )\n    ))   \n  )   \n)","user":"55d7312ee4b0e31453f64a9f"},{"code":"(fn [f & maps]\n  (reduce (fn [m0 m1]\n            (reduce (fn [m [k v]]\n                      (assoc m k (if (m k)\n                                     (f (m k) v)\n                                     v)))\n                    m0\n                    m1))\n          maps))","problem":69,"user":"4ee3b586535d10e5ff6f5371"},{"problem":69,"code":"(fn [func & mlist] (let [tm (group-by first (apply concat (map #(vec %) mlist)))\n                        ks (keys tm)\n                        vs (map #(map second %) (vals tm))]\n                    (zipmap ks (map #(reduce func %) vs))))","user":"57c647bbe4b05aa3c4741cf3"},{"problem":69,"code":"(fn [f & ms] (let [in-v (reduce (fn [a m] \n    (reduce (fn [acc [k v]] (let [va (get acc k)]\n                                 (assoc acc k (if va (conj va v) [v])))) a m)) {} ms)]\n    (into {} (map (fn [[k v]] [k (reduce f v)]) in-v))))","user":"5a4de614e4b05d388ecb6bb1"},{"problem":69,"code":"(fn [f1 & arr2]\n(letfn [(add2 [ arr] (let [cl2 (apply concat arr)]\n              (loop [ cl (rest cl2) re {} f (first cl2)]\n                (if (not f) re\n                (recur (rest cl) (update-in re [(key f)] (fn [acc item] (conj (or acc []) item)) (val f)) (first cl))\n                ))))]\n    (loop [c2 (add2 arr2) f (first c2) re {} ]\n      (cond\n           (not f) re\n           (= 1 (count (val f))) (recur (rest c2) (first (rest c2)) (assoc re (key f) (first (val f))))\n           :else (recur (rest c2) (first (rest c2)) (assoc re (key f) (apply f1 (val f))))))))","user":"5dc12b0ae4b0e59a23173d84"},{"code":"#(reduce (fn [x y]\n  (merge x\n    (apply hash-map\n      (mapcat (fn [& [[k v]]]\n        [k (if (x k) (% (x k) v) v)]) y)))) %&)","problem":69,"user":"50548ce8e4b0b1b9d1860ead"},{"problem":69,"code":"(fn [f m & ms]  \n  (reduce (fn [mm [k v]]\n            (if (contains? mm k)\n              (update-in mm [k] f v)\n              (assoc mm k v)))\n          m\n          (for [m ms\n                kv m]\n            kv)))","user":"51dafedee4b09f6bc204eee2"},{"problem":69,"code":"(fn [f & maps]\n  (apply\n    merge\n    (map\n      #(hash-map % (reduce\n                     (fn [v m]\n                       (if (contains? m %) (if (nil? v) (m %) (f v (m %))) v))\n                     ((first maps) %)\n                     (rest maps)))\n      (set (mapcat keys maps)))))","user":"5e246f92e4b05b4b01516150"},{"code":"(fn [f & maps]\n  (loop [[m & cdr] maps ret {}]\n    (if (nil? (seq m))\n      ret\n      (recur cdr (reduce (fn [ret cur]\n\t\t\t\t\t       (if (contains? ret (first cur))\n                             (update-in ret [(first cur)] f (second cur))\n                             (assoc ret (first cur) (second cur)))) ret m) ))))","problem":69,"user":"513cb853e4b0b86ece9f322b"},{"problem":69,"code":"(fn maxi-conjer\n  [f & args]\n  (reduce (fn [x y]\n            (reduce-kv (fn [res yk yv]\n                      (if (some #{yk} (keys x))\n                        (assoc res yk (f (get x yk) (get y yk)))\n                        (assoc res yk (get y yk)))) x y)) args))","user":"5c950334e4b048ec896c5a44"},{"code":"(fn [f & maps] (reduce (fn [old-map new-map] (into old-map (map (fn [[k v]] [k (if (contains? old-map k) (f (get old-map k) v) v)]) new-map))) maps))","problem":69,"user":"5137c3b0e4b0509a8b470482"},{"problem":69,"code":"(fn [ func original-mp & merge-maps ]\n  (let [ merge-map\n        (fn [ current-map merging-map  ]\n          (reduce (fn [ current-map [ key val ]  ]\n                    (let [ value-in-current-map (get current-map key)]\n                      (if (nil? value-in-current-map)\n                        (assoc current-map key val )\n                        (assoc current-map key\n                           (func value-in-current-map val)))))\n                  current-map\n                  merging-map))]\n    (loop [ [ first-merge-maps & rest-merge-maps ] merge-maps, current-map original-mp ]\n      (if (nil? first-merge-maps)\n        current-map\n        (recur rest-merge-maps (merge-map current-map first-merge-maps))))))","user":"59f90e6ae4b0ca45a743a337"},{"problem":69,"code":"(fn [f & c]\n  (reduce\n   (fn [a m]\n     (reduce (fn [a [k v]]\n               (let [v (if (contains? a k)\n                         (f (a k) v)\n                         v)]\n                 (assoc a k v)))\n             a\n             m))\n   {}\n   c))","user":"577832f4e4b0979f8965165b"},{"code":"(fn this\r\n  ([f x] x)\r\n  ([f x1 x2 & xs]\r\n     (if (empty? xs)\r\n       (letfn [(worker [l s]\r\n                 (if (empty? l) s\r\n                     (recur (rest l)\r\n                            (let [v (first l) p (find s (key v))]\r\n                              (if p\r\n                                (assoc s (key v) (f (val p) (val v)))\r\n                                (assoc s (key v) (val v))))))\r\n                 )]\r\n         (worker x2 x1))\r\n       (apply this f (this f x1 x2) (first xs) (rest xs))))\r\n  )","problem":69,"user":"4f474f43e4b0d56e7bb92bb7"},{"code":"(fn [f & maps]\n  (reduce (fn [result m]\n            (reduce (fn [interim-result [k v :as map-entry]]\n                      (if (contains? interim-result k)\n                        (conj interim-result [k (f (interim-result k) v)])\n                        (conj interim-result map-entry)))\n                    result\n                    m))\n          maps))","problem":69,"user":"51789dfae4b03d69594194d7"},{"code":"(fn [f & m]\n  (loop [[l & r] m\n         z {}]\n    (let [k (keys l)\n          o (merge z (zipmap k (map #(if (z %) (f (z %) (l %)) (l %)) k)))] \n\t\t(if (seq r) (recur r o ) o)\n    )\n   )\n )","problem":69,"user":"52bf29fde4b07a9af579232e"},{"problem":69,"code":"(fn merge-with-f [f i-map & o-maps]\n  (reduce #(reduce-kv (fn [m k v] (if-let [prev (m k)] \n                                    (assoc m k (f prev v)) \n                                    (assoc m k v))) %1 %2) i-map o-maps))","user":"55c10409e4b01b9910ae2a2c"},{"code":"(fn [f m & n]\n  (into {} \n        (for [[k v] (seq (apply merge n))]\n          (if (nil? (m k))\n            [k v]\n            [k (f (m k) v)]))))","problem":69,"user":"5371167fe4b0fc7073fd6ea7"},{"problem":69,"code":"(fn merge-maps [f & maps]\n  (reduce \n    #(reduce \n       (fn [m [k v]] \n         (assoc m k (if (contains? m k) \n                      (f (get m k) v)\n                      v))) \n       %1 \n       %2)\n    {}\n    maps))","user":"548b8a50e4b0e286459a11ff"},{"problem":69,"code":"(fn my-merge-with [f & maps]\n  (reduce (fn [acc el]\n            (reduce-kv (fn [acc2 k v]\n                         (if (contains? acc2 k)\n                           (assoc acc2 k (f (get acc2 k) v))\n                           (assoc acc2 k v)))\n                       acc\n                       el))\n          {}\n          maps))","user":"5264383be4b03e8d9a4a70cb"},{"code":"(fn [f s & mm]\n   (reduce\n   (fn mf [s mm]\n     (apply assoc\n         s (interleave\n            (keys mm)\n            (map #(if (contains? s %1) (f (s %1) (mm %1)) %2)\n                 (keys mm) (vals mm)))))\n   s mm))","problem":69,"user":"4fbfe9a4e4b081705acca31f"},{"problem":69,"code":"(fn [func head & more] \n  (reduce (fn [acc coll]  \n    (reduce (fn [in-acc [k v]]\n              (if (contains? in-acc k)\n                (assoc in-acc k (func (get in-acc k) v))\n                (assoc in-acc k v)))\n            acc coll))\n          head more))","user":"56cad309e4b0ea9b8538f720"},{"code":"(fn my-merge-with [f & a]\n  (letfn [(b [d [e v]]\n               (update-in d [e] #(if (nil? %) v (f % v))))\n        (c [d e]\n        (reduce #(b %1 %2) d e))]\n  (reduce c {} a)))","problem":69,"user":"4f465096e4b0d56e7bb92b9a"},{"problem":69,"code":"(fn [ op & maps ]\n    (reduce\n     (fn [res addon]\n       (reduce (fn [m [ k v ]]\n                 (let [mv (get m k)] (if (nil? mv) (assoc m k v) (assoc m k (op mv v)))))\n               res addon))\n     maps))","user":"57aa290de4b0b8559636fc65"},{"problem":69,"code":"(fn [f a & b]\n  (reduce\n   \t(fn [m z]\n      (reduce\n       \t\t  (fn [z [k v]]\n                (update-in z [k] #(if % (f % v) v))\n              )\n              m z\n      )\n    )\n  \ta b\n  )\n)","user":"5b99a0a3e4b0c0b3ffbd4ad7"},{"problem":69,"code":"(fn my-merge-with [f & merge-list]\n  (reduce (fn [result merge-in]\n            (reduce (fn [temp-result [key val]]\n                      (if (temp-result key)\n                        (assoc temp-result key (f (temp-result key) val))\n                        (assoc temp-result key val)))\n                    result\n                    merge-in))\n          {}\n          merge-list))","user":"60849bd6e4b0736b099e42f2"},{"problem":69,"code":"(fn [f & m] (reduce (fn [a b] (into a (for [[k v] b]\r\n            [k (if (a k)\r\n                 (f (a k) v)\r\n                 v)])) ) {} m))","user":"5f2c02d1e4b033932238a65f"},{"problem":69,"code":"(fn merge_ [f m & maps] \n  (let [s (mapcat seq maps)]\n    (reduce #(if (contains? % (first %2))\n               (update-in % [(first %2)] f (second %2)) \n               (assoc % (first %2) (second %2))) m s)))","user":"534fa9dae4b084c2834f4acf"},{"code":"(fn [f & ms]\n    (reduce \n      (fn [r [k v]] \n          (update-in r [k] #(if % (f % v) v)))\n      {} \n      (apply concat ms)))","problem":69,"user":"4e6f578c535d5021c1a8961b"},{"problem":69,"code":"(fn my-merge [f & mps]\n  (letfn [(m-k [m e]\n             (if (contains? m (key e))\n               (assoc m (key e) (f (get m (key e)) (val e)))\n               (assoc m (key e) (val e))))\n          (mrg [m1 m2]\n            (reduce m-k m1 (seq m2)))]\n    (reduce mrg mps)))","user":"586615e6e4b0f14aab7c8858"},{"code":"(fn [f m1 & ms] \n  (reduce \n    #(loop [r % ks (keys %2) vs (vals %2)] \n         (if (and ks vs) \n          (recur\n            (let [k (first ks) v (first vs)]\n              (assoc-in r [k]\n               (if (contains? r k)\n                   (f (r k) v)\n                    v\n               )\n              )\n            )\n            (next ks)\n            (next vs)\n          )\n          r\n         )\n     )\n   m1 ms)\n)","problem":69,"user":"50921f9ae4b09a7d0b586de1"},{"problem":69,"code":"(fn [f & shit]\n    (letfn [(merge-using [f sh1 sh2]\n              (let [keys (apply clojure.set/union (map set (map keys [sh1 sh2])))]\n                (into {}\n                  (map\n                    #(let [v1 (sh1 %)  v2 (sh2 %)] (if (and v1 v2) [% (f v1 v2)] [% (or v1 v2)]))\n                    keys))))]\n     (reduce #(merge-using f %1 %2) shit)))","user":"561814bae4b06b1bb2182a1a"},{"code":"(fn [f & ms] (letfn [(mw [acc [k v]] (assoc acc k (if (contains? acc k) (f (get acc k) v) v)))\n                     (rm [acc m] (reduce mw acc m))]\n                    (reduce rm {} ms)))","problem":69,"user":"51c19873e4b0d204dbe2ca0d"},{"code":"(fn [f & ms]\n  (reduce\n   (fn [res x]\n     (reduce-kv\n      (fn [merged k v]\n        (let [prev-v (get merged k)]\n          (assoc merged k (if prev-v (f prev-v v) v))))\n      res\n      x))\n   {}\n   ms))","problem":69,"user":"50d8f4b6e4b01f0871336e74"},{"problem":69,"code":"(fn [f & ms]\n  (loop [ms ms r {}]\n    (if (empty? ms)\n      r\n      (recur (rest ms)\n             (let [m1 (first ms)]\n               (if (empty? r)\n                 m1\n                 (loop [ks (keys m1) m2 r]\n                   (if (empty? ks)\n                     m2\n                     (recur (rest ks)\n                            (let [k (first ks)]\n                              (if (contains? r k)\n                                (into m2 {k (f (get r k) (get m1 k))})\n                                (into m2 {k (get m1 k)}))))))))))))","user":"54cad59ee4b057c6fda3a26e"},{"problem":69,"code":"(fn [op & ms]\n  (let [ks (set (mapcat keys ms))]\n    (apply merge\n      (for [k ks]\n        (let [ans (filter (comp not nil?) (map #(get % k) ms))]\n          (if (> (count ans) 1)\n            {k (apply op ans)}\n            {k (nth ans 0)}\n          )\n        )\n      )\n    )\n  )\n)","user":"5943abb6e4b060784b3b792b"},{"problem":69,"code":"(fn a [f & args]\n\t(let [k (keys (apply merge args))\n\t\t  ca (fn [c coll] \n\t\t\t\t(let [v (filter #(not= % nil) (map #(% c) \t\t\t\t\t\t\t\t\tcoll))]\n\t\t\t\t\t(if (> (count v) 1) {c (apply f v)} \n\t\t\t\t\t\t{c (first v)})))] \n\t\t(loop [ke k\n\t\t\t\tresult {}]\n\t\t\t(if (empty? ke) result\n\t\t\t\t(recur (rest ke) (into result (ca (first ke) args)))))))","user":"562d869be4b0a45d2ff8301f"},{"problem":69,"code":"(fn [f & args]\n   (reduce #(reduce (fn [m [k v]]\n                     (if-let [vv (m k)]\n                       (assoc m k (f vv v))\n                       (assoc m k v)))\n                   %1 %2)\n           args))","user":"58a44a14e4b01a0c0b2328f2"},{"code":"(fn [f m & maps]\n  (let [mrg (fn [map1 map2]\n              (reduce (fn [memo [k v]]\n                        (if (memo k)\n                          (assoc memo k (f (memo k) v))\n                          (assoc memo k v))) map1 map2))]\n    (reduce #(mrg %1 %2) m maps)))","problem":69,"user":"51195e77e4b055cfb310d499"},{"code":"(fn [f m & maps]\n  (->\n    (fn [m1 m2]\n      (-> (fn [m k]\n            (assoc m k (if (m k)\n                         (f (m k) (m2 k))\n                         (m2 k))))\n          (reduce m1 (keys m2))))\n   (reduce m maps)))","problem":69,"user":"514c2d05e4b02b8cbb2a9278"},{"problem":69,"code":"(fn\n  [f & maps]\n  (let [me (fn [m e]\n             (let [k (key e) v (val e)]\n               (if (contains? m k)\n                 (assoc m k (f (get m k) v))\n                 (assoc m k v))))\n        merge2 (fn [m1 m2]\n\t\t   (reduce me (or m1 {}) (seq m2)))]\n    (reduce merge2 maps)))","user":"53843906e4b06839e8705eee"},{"code":"(fn [f & mp] (reduce (fn [m [k v]] (conj m [k (if (m k) (f (m k) v) v)])) {} (apply concat mp)))","problem":69,"user":"4e71705e535d5021c1a89649"},{"problem":69,"code":"(fn p69 [f & ms]\n  (let [keys-to-use (set (flatten (for [m ms] (keys m))))\n        vals-to-use (for [k keys-to-use]\n                      (reduce f (remove nil? (map #(% k) ms))))]\n    (zipmap keys-to-use vals-to-use)))","user":"525c575be4b0cb4875a45d38"},{"problem":69,"code":"(fn [f & l]\n  (apply merge\n         (map (fn [[k v]] \n                {k (if (= 1 (count v)) (first v) (apply f v))})\n              (reduce (fn [first-arg second-arg]\n                        (println \"reduce:\" first-arg second-arg)\n                        (reduce merge first-arg\n                                (for [[k v] second-arg]\n                                  {k (conj (get first-arg k []) v)})))\n                      {} l))))","user":"55d74e71e4b0e31453f64aa4"},{"problem":69,"code":"(fn \n  [op & maps]\n  (reduce \n    (fn \n      [map-first map-second]\n      (merge\n        map-first\n        map-second\n        (into {}\n          ((fn\n            [map-a map-b]\n            (let \n              [dup-keys\n                (keys\n                  (select-keys \n    \t        map-b \n    \t\t(keys map-a)))]\n              (map \n                (fn \n                  [dup-key]\n          \t{dup-key (op (get map-a dup-key) (get map-b dup-key))})\n                dup-keys))) map-first map-second))))\n      maps))","user":"586a657de4b0f14aab7c88bd"},{"code":"(fn [f & ms]\n   (into {} (for [k (keys (apply merge ms))]\n              [k (let [vs (remove nil? (for [m ms]\n                                         (get m k)))]\n                   (if (nil? (next vs))\n                     (first vs)\n                     (apply f vs)\n                   ))\n               ]\n     )))","problem":69,"user":"503ca47fe4b06c4e0e1fa24f"},{"problem":69,"code":"(fn mrg-with\n  [f & maps]\n  (let [mrg-entry (fn [m e]\n                    (let [k (key e) v (val e)]\n                      (if (contains? m k)\n                        (assoc m k (f (get m k) v))\n                        (assoc m k v))))]\n    (reduce mrg-entry {} (mapcat seq maps))))","user":"5e41b679e4b01d43a70e8e58"},{"code":"(fn [f & maps]\n  (reduce \n    (fn [m p] (reduce \n        (fn [m [a b]] \n          (if (contains? m a) (assoc m a (f (m a) b))\n              (assoc m a b)))\n        m p))\n    maps))","problem":69,"user":"4f4c6b21e4b03ad3f0c10c8f"},{"problem":69,"code":"(fn [f & maps]\n  (reduce\n   #(into (merge % %2) (for [[k0 v0] %\n                             [k1 v1] %2]\n                         (when (= k0 k1)\n                          [k0 (f v0 v1)])))\n   maps))","user":"516f06dce4b06aac486e5b39"},{"code":"(fn [f & maps]\n  (reduce \n    (fn [m1 m2] \n      (reduce \n        (fn [m [k v2]] \n          (let [v1 (m1 k), v (if v1 (f v1 v2) v2)]\n            (assoc m k v))) m1 m2))\n    maps))","problem":69,"user":"4e7db3b4535db169f9c796e1"},{"code":"(fn foo [f m & maps]\n  (if (seq maps) \n      (let [[n & r] maps\n\t        conj-ed #(reduce (fn [acc el] \n\t\t\t\t\t\t\t   (assoc acc (first el) \n\t\t\t\t\t\t\t             (if (contains? acc (first el)) \n\t\t\t\t\t\t\t\t\t\t     (f (acc (first el)) (second el) )\n\t\t\t\t\t\t\t\t\t\t     (second el )) ))  %1 %2) ] \n\t\t(apply foo (into [f (conj-ed m n)] r))) \n      m))","problem":69,"user":"523a9fc9e4b081681ca7adca"},{"problem":69,"code":"(fn [f & [fm & m]]\n  (reduce\n   (fn [a [k v]]\n     (if (a k)\n       (conj a [k (f (a k) v)])\n       (assoc a k v)))\n   fm (apply concat m)))","user":"5c2836ebe4b07e362c2305d4"},{"problem":69,"code":"(fn [f & args]\n  (reduce (fn [acc m] \n            (let [ks (keys m)]\n              (reduce (fn [acc2 k]\n                          (let [vacc (get acc k)]\n                            (if (nil? vacc)\n                              (assoc acc2 k (m k))\n                              (assoc acc2 k (f vacc (m k))))))\n                      acc\n                      ks)))\n          args))","user":"54b13a40e4b09f271ff37d1b"},{"problem":69,"code":"(fn [f & maps]\n  (reduce \n    (fn [a b]\n      (let [ks (filter identity (map (set (keys a)) (set (keys b))))]\n        (merge (merge a b) (apply hash-map (interleave ks (map f (map a ks) (map b ks)))))))\n    maps)\n  )","user":"5bafd5c8e4b0a20761a234dd"},{"problem":69,"code":"(fn merge-with* [f & maps]\n  (let [[m1 & more] maps]\n    (reduce (fn [acc m-n]\n              (reduce (fn [acc [k v]]\n                        (if (contains? acc k)\n                          (assoc acc k (f (get acc k) v))\n                          (assoc acc k v)))\n                      acc m-n))\n            m1 more)))","user":"5777c3d6e4b0979f8965164f"},{"code":"(fn [f m & ms]\n  (loop [m m ms ms]\n    (if (empty? ms)\n      m\n      (let [next-map (first ms)]\n        (recur (loop [m m k (keys next-map)]\n                 (if (empty? k)\n                    m\n                    (if (contains? m (first k))\n                        (recur (assoc m (first k) (f (m (first k)) (next-map (first k)))) (rest k))\n                        (recur (assoc m (first k) (next-map (first k))) (rest k)))))\n               (rest ms))))))","problem":69,"user":"4e568873535d8a8b8723a283"},{"problem":69,"code":"(fn my-merge-with [f base-map & maps]\n  (reduce (fn [base-m m]\n            (reduce (fn [base-m [k v]]\n                      (if (base-m k)\n                        (assoc base-m k (f (base-m k) v))\n                        (assoc base-m k v)))\n                    base-m\n                    m))\n          base-map\n          maps))","user":"4e6a2f93535d8ccf87e9feaa"},{"problem":69,"code":"(fn merge-with1 [f & ms]\n  (->>\n    (mapcat #(into [] %) ms)\n    (reduce (fn [m [k v]] (update-in m [k] #(conj (or % []) v))) {} )\n    (map (fn [[k l]] (vector k (reduce f l))))\n    (into {})))","user":"5e0d948fe4b099d064962f98"},{"code":"(fn newmergewith [f & x]\n  (let [fchecker (fn [dict entry]\n                   (if (contains? dict (first entry))\n                     (assoc dict (first entry) (f (get dict (first entry)) (peek entry)))\n                     (assoc dict (first entry) (peek entry))))\n        combine (fn [dict otherdict]\n                  (reduce fchecker dict otherdict))]\n    (if (seq x)\n      (if (seq (rest x))\n        (reduce combine (first x) (rest x))\n        (first x))\n      '())))","problem":69,"user":"532727bae4b09d4e7a9b54fa"},{"problem":69,"code":"(fn merge-with* [f & maps]\n  (letfn [(merge-two [m1 m2]\n            (into {}\n                  (for [key (into (keys m1) (keys m2))\n                        :let [[k1 v1] (find m1 key) \n                              [k2 v2] (find m2 key)]]\n                    [key (cond (nil? k1) v2\n                               (nil? k2) v1\n                               :else (f v1 v2))])))]\n    (reduce merge-two maps)))","user":"56a01895e4b0542e1f8d149f"},{"problem":69,"code":"(fn [fun & srcs]\n   (reduce\n    #(reduce\n      (fn [res pair]\n        (println res (key pair))\n        (assoc\n         res\n         (key pair)\n         (if (nil? (res (key pair)))\n           (val pair)\n           (fun (res (key pair)) (val pair)))))\n      %1\n      %2)\n    {}\n    srcs))","user":"5d5c6675e4b09db18d4482ec"},{"problem":69,"code":"(fn _merge-with [f & colls]\n  (if (= (count colls) 1) (first colls)\n    (let [m1 (first colls)\n          m2 (second colls)\n          newentries (apply concat (for [k (distinct (concat (keys m1) (keys m2)))]\n                                     (let [v (if (and (contains? m1 k) (contains? m2 k)) (f (m1 k) (m2 k))\n                                              (if (contains? m1 k) (m1 k) (m2 k)))]\n                                       [k, v])))\n          newmap (apply assoc {} newentries)]\n      (recur f (cons newmap (drop 2 colls))))))","user":"52ee0de4e4b05e3f0be25ec1"},{"code":"(fn merge--listcomp\n  [f & maps] {:pre [(ifn? f), (every? map? maps)]}\n  (let [;; This is the set of keys that appear in any of the maps.\n        keyset (set (mapcat keys maps)),\n\n        ;; This is a function wrapping f so that we don't have to separately\n        ;; handle the case where a key only appears in one map.\n        smoosh (fn [x & etc] (if (seq etc) (apply f (cons x etc)) x)),\n\n        ;; This function takes in a key k and provides the value it should have\n        ;; in the output map.\n        update-key (fn [k]\n                     (->> maps\n                          (filter #(contains? % k))\n                          (map #(% k))\n                          (apply smoosh)))]\n\n    ;; To get the output map, we just apply update-key to each key in the key\n    ;; set, and stick all of the resulting pairs in a map.\n    (into {} (for [k keyset] [k (update-key k)]))))","problem":69,"user":"4fc6305de4b0ee37620e180b"},{"problem":69,"code":"(fn my-merge-with [f & maps]\n  (reduce\n   (fn [m p]\n     (reduce\n      #(let [k (first %2), origin-v (%1 k), new-v (second %2)]\n        (if (nil? origin-v)\n          (assoc %1 k new-v)\n          (assoc %1 k (f origin-v new-v))))\n      m p))\n   maps))","user":"567e418fe4b0feffd0d18eb1"},{"problem":69,"code":"(fn [f & maps]\n  (let [merge-entry (fn [m e]\n                      (let [k (key e)\n                            v (val e)]\n                        (if (contains? m k)\n                          (assoc m k (f (get m k) v))\n                          (assoc m k v))))\n        mymerge (fn [m1 m2]\n                  (reduce (fn [m e]\n                            (merge-entry m e))\n                          m1 (seq m2)))]\n    (reduce mymerge {} maps)))","user":"5c3796b3e4b0d62ef62d9f77"},{"code":"#(into {} (for [[k s] (group-by key (apply concat %&))]\n            [k (reduce % (vals s))]))","problem":69,"user":"4e8f1ac6535d65386fec2146"},{"problem":69,"code":"(fn [f m & maps] \n  (into \n   {} \n   (for [mp maps \n         [k v] mp \n         :let [nv (if (contains? m k) \n                    (f (get m k) v) \n                    v)]] \n     [k nv])))","user":"57f0f7b8e4b0bfb2137f5bfe"},{"problem":69,"code":"(fn [f & c]\n        (reduce (fn [ret m]\n                  (reduce (fn [ret [k v]]\n                            (if (contains? ret k)\n                              (assoc ret k (f (get ret k) v))\n                              (assoc ret k v)))\n                          ret m))\n                {} c))","user":"541ae7dbe4b01498b1a71a61"},{"problem":69,"code":"(fn f\n  [func result & args]\n  (println \"starting f with input\" result args \"rest of args is\" (rest args))\n  (if (nil? args)\n    result\n    (apply f func\n       (loop\n         [temp_result result\n          current_input (seq (first args))]\n         (let [current_entry (first current_input)\n               current_key (first current_entry)\n               current_value (second current_entry)]\n           (println \"loop on\" current_key current_value current_input)\n           (if (empty? current_input)\n             temp_result\n             (recur\n              (if (contains? temp_result current_key)\n                (update-in temp_result [current_key] func current_value)\n                (assoc-in temp_result [current_key] current_value))\n              (rest current_input)))))\n       (rest args))))","user":"54021f13e4b0df28a13c62cc"},{"problem":69,"code":"(fn my-merge-with [f first-map & maps]\n  (letfn [(merge-map [m1 m2] (reduce merge-entry m1 m2))\n          (merge-entry [m [key value]]\n            (if (get m key)\n              (assoc m key (f (get m key) value))\n              (assoc m key value)))]\n    (reduce merge-map first-map maps)))","user":"53504fe6e4b084c2834f4ada"},{"problem":69,"code":"(fn [f & m]\n    (into {}\n    (for [[k v]\n           (group-by key (apply concat m))\n          ] \n      [k (reduce f (map val v))])))","user":"559c13c5e4b066d22e731f61"},{"problem":69,"code":"(fn [f & maps]\n  (->> maps\n       (apply concat)\n       (group-by key)\n       (map (juxt key #(->> (map val (val %))\n                            (reduce f))))\n       (into {})))","user":"52470d42e4b05ef8e38e6350"},{"code":"(fn m-with [func-with origin & dest]\n  (reduce \n\t\t(fn me[old-map new-map]\n\t\t   (let [key-set (concat (keys old-map) (keys new-map))]\n\t\t     (reduce \n\t\t\t#(assoc %1 %2 (if (and (old-map %2)(new-map %2))\n\t\t\t\t\t(func-with (old-map %2) (new-map %2))\n\t\t\t\t\t(if (old-map %2)\n\t\t\t\t\t  (old-map %2)\n\t\t\t\t\t  (new-map %2)\n\t\t\t\t\t  )\n\t\t\t\t\t)) \n\t\t\t{} \n\t\t\tkey-set\n\t\t\t)\t\n\t\t     )\n\t\t   ) \n\t\torigin \n\t\tdest)\n)","problem":69,"user":"4e9de526535dbda64a6f6b8e"},{"problem":69,"code":"(fn my-merge-with [f m & ms]\n  (reduce \n   (fn [m1 m2]\n\t(reduce\n     (fn [resmap [ x y] ]\n       (assoc resmap x\n       (if (contains? resmap x)\n         (f (resmap x) y)\n         y\n         )))       \n     m1 m2) \n     )\n   m\n   ms))","user":"5224a46ce4b01819a2de42e5"},{"code":"(fn [f & args]\n  (reduce \n  (fn [m arg]\n    (reduce (fn [m2 k]\n              (if (contains? m2 k)\n                (assoc m2 k (apply f (list (m2 k) (arg k))))\n                (assoc m2 k (arg k))\n               )\n              ) m (keys arg))\n    ) {} args)\n  )","problem":69,"user":"51bec919e4b013aa0d74b800"},{"code":"(fn [f & m]\n  (reduce #(reduce (fn [x [k v]]\n    (assoc x k (if (x k) (f (x k) v) v))) % %2) {} m))","problem":69,"user":"5014718fe4b094324338f8e3"},{"problem":69,"code":"(fn [f & maps] (reduce (fn [map1 map2] (loop [smap1 (seq map1) merged map2] (if (empty? smap1) merged (let [[key1 val1] (first smap1)] (if (contains? merged key1) (recur (rest smap1) (assoc merged key1 (f (map1 key1) (merged key1)))) (recur (rest smap1) (assoc merged key1 val1))))))) {} maps))","user":"5e1cc888e4b0dc959400853d"},{"problem":69,"code":"(fn [f m & ms]\n  (reduce #(reduce \n            (fn [om [k v]] \n              (assoc om k (if-let [ov (om k)] (f ov v) v)))\n            %1 %2)\n          m ms))","user":"51000111e4b00d7ad4cab15e"},{"code":"(fn [f & mss]\n  (loop [ms mss om {}]\n    (if (empty? ms) om\n        (recur (rest ms) (reduce\n      (fn [o kv]\n        (let [k (first kv) v (second kv)]\n(if-let [ov (o k)] (assoc o k (f ov v)) (assoc o k v)))) om (first ms))))))","problem":69,"user":"4fd81472e4b0dab7d829f38e"},{"code":"(fn [f x & y] ((fn w [a [b & c]] (if b (w (reduce (fn [m [k v]] (assoc m k (if-let [d (m k)] (f d v) v))) a b) c) a)) x y))","problem":69,"user":"4f045946535dcb61093f6bba"},{"problem":69,"code":"(fn [f & maps]\n  (reduce (fn [r coll]\n            (reduce (fn [res item]\n                      (let [k (first item)\n                            v (second item)]\n                        (if (contains? res k)\n                          (assoc res k (f (get res k) v))\n                          (assoc res k v))))\n                    r coll))\n          maps))","user":"5e348945e4b0650de70e2b1d"},{"problem":69,"code":"(fn j2m \n  ([f a b]\n   (let [ka (set (keys a)) \n         b-not-a (into {} (remove (comp ka first) b))]\n     (reduce-kv (fn [m k v] (assoc m k (if (and (a k) (b k)) \n                                         (f v (b k))\n                                         v)))\n                {} \n                (merge a b-not-a))))\n  ([f a b & more]\n   (apply j2m (concat [f] [(j2m f a b)] more))))","user":"5b14475be4b0cc2b61a3be5a"},{"problem":69,"code":"(fn my-merge-with\n   [f & ms]\n   (reduce\n     (fn [acc m] \n       (reduce\n         (fn [acc' [k v]]\n           (if (contains? acc' k)\n             (assoc acc' k (f (acc' k) v))\n             (assoc acc' k v)))\n         acc\n         m))\n     {}\n     ms))","user":"56050f06e4b08b23635d3161"},{"problem":69,"code":"(fn merge-fn [f & targets]\n  (let [all-keys #(keys (apply merge %))\n        all-vals-by-k (fn [maps k]\n                        (remove nil? (map #(get % k) maps)))]\n    (into {} (for [k (all-keys targets)]\n               [k (let [[car & cdr :as all] (all-vals-by-k targets k)]\n                    (if (empty? cdr)\n                      car\n                      (apply f all)))]))))","user":"563f4c47e4b08d4f616f5ed2"},{"problem":69,"code":"(fn m\n  ([f x y]\n   (let [[a b] (first y)\n          c    (get x a)]\n     (if (empty? y)\n       x\n       (m f\n         (assoc x a (if c\n                       (f c b)\n                       b))\n         (rest y)))))\n  ([f x y & args]\n   (reduce #(m f % %2) (m f x y) args)))","user":"52bacfa8e4b07a9af57922d6"},{"problem":69,"code":"(fn [f & xs]\n  (reduce (fn [acc x] \n            (reduce-kv (fn [m k v] \n                         (prn m)\n                         (assoc m k (if (contains? m k) \n                                      (f (m k) v) \n                                      v))) \n                       acc x))\n          xs))","user":"54dce62be4b024c67c0cf78b"},{"code":"(fn foo\r\n    ([f xs] xs)\r\n    ([f xs & args]\r\n    (let [ys (first args)]\r\n         (loop [xs xs [[k vys] & ys] (seq ys)]\r\n           (if-not k\r\n             (apply foo f xs (rest args))\r\n           (if-let [vxs (get xs k)]\r\n               (recur (assoc xs k (f vxs vys)) ys)\r\n               (recur (assoc xs k vys) ys)))))))","problem":69,"user":"4e26e8b4535deb9a81d77ef6"},{"problem":69,"code":"(fn [f & maps]\n  (reduce (fn [result m]\n            (merge result\n                   (reduce (fn [acc [k v]]\n                             (if (contains? result k)\n                               (assoc acc k (f (acc k) v))\n                               (assoc acc k v)))\n                           result\n                           m)))\n          {}\n          maps))","user":"5d431c77e4b07c84aa5ae68f"},{"problem":69,"code":"(fn [f & ms]\n  (reduce \n    (fn [res m] \n      (reduce \n        (fn [acc [k v]]\n          (assoc acc k (if (contains? acc k) (f (get acc k) v) v)))\n        res\n        m))\n    {}\n    ms))","user":"5630ce72e4b0bfe05bf11786"}]