[{"code":"#(loop [a %1 b %2 r {}]\n  (if (or (empty? a) (empty? b))\n    r\n    (recur (rest a) (rest b) (conj r [(first a) (first b)]))))","problem":61,"user":"4f141dee535d64f603146434"},{"problem":61,"code":"(fn[a b] (reduce #(assoc %1 (first %2) (second %2)) {} (map list a b)))","user":"57b9fc74e4b0fbc9809a27fb"},{"problem":61,"code":"#(apply hash-map(flatten(map vector %1 %2)))","user":"580d7e53e4b0849f6811b73e"},{"code":"(fn [a b]\n  ((fn pairUp [keys values result]\n    (if (or (empty? keys) (empty? values))\n      result\n      (pairUp\n        (rest keys)\n        (rest values)\n        (assoc result (first keys) (first values))))\n  ) a b {})\n)","problem":61,"user":"4f16d6ed535d64f60314644f"},{"code":"(fn [a b] (apply hash-map (flatten (mapv #(vector %1 %2) a b))))","problem":61,"user":"5048bcf8e4b06e644c63f1ae"},{"code":"(fn [xs ys]\n  (loop [m {}\n        ks (seq xs)\n        vs (seq ys)]\n    (if (and ks vs)\n      (recur (assoc m (first ks) (first vs))\n        (next ks)\n        (next vs))\n      m))\n)","problem":61,"user":"4ee8092f535d93acb0a66875"},{"code":"(fn [k v] \n  (loop [remk k remv v m {}]\n    (if (not (or (empty? remk) (empty? remv)))\n      (recur (rest remk) (rest remv) \n        (assoc m (first remk) (first remv)) )\n      m )))","problem":61,"user":"4eaf08ce535d7eef3080732d"},{"problem":61,"code":"(fn [elems1 elems2]\n    (into {} (map vector elems1 elems2)))","user":"5ac6ef9be4b0e27600da7779"},{"problem":61,"code":"(fn [ks vs]\n          (into {}\n                (map #(hash-map %1 %2) ks vs)))","user":"5c995fa4e4b048ec896c5a96"},{"problem":61,"code":"(fn [ks vs]\n  (apply (partial assoc {}) (interleave ks vs)))","user":"5791d259e4b0ebec4cfb75c0"},{"problem":61,"code":"(fn a [lst1 lst2]\n  (apply merge (map hash-map lst1 lst2) ))","user":"57fc08d8e4b0d3187e900988"},{"code":"(fn\n  [xs ys]\n  (apply assoc {} (interleave xs ys)))","problem":61,"user":"52c58561e4b0c2d177d620f8"},{"code":"(fn [seq1 seq2] \n   (loop [result {} elementsKeys seq1 elementsValues seq2] \n     (if (or (empty? elementsKeys) (empty? elementsValues))\n       result\n       (recur (into result {(first elementsKeys) (first elementsValues)}) (rest elementsKeys) (rest elementsValues))\n       )\n     )   \n   )","problem":61,"user":"5106dc1be4b01150e115ebf0"},{"code":"(fn[x y] (apply hash-map (interleave x y)))","problem":61,"user":"4f32135ae4b0d6649770a08e"},{"problem":61,"code":"#(into (sorted-map) (map (fn [x y] [x y]) %1 %2))","user":"5a4d656fe4b05d388ecb6ba9"},{"problem":61,"code":"(fn [v1 v2]\n    (loop [v1_ v1 v2_ v2 r {}]\n        (if (and (seq v1_) (seq v2_))\n            (recur (rest v1_) (rest v2_) (conj r [(first v1_) (first v2_)]) )\n        r)))","user":"55975569e4b031d6649c9b8e"},{"code":"(fn [v1 v2]\n  (apply hash-map (apply concat (map vector v1 v2))))","problem":61,"user":"53219cece4b09d4e7a9b54b7"},{"code":"(fn zm [k v] (loop [acu {} ak k av v] (if (and (seq ak) (seq av)) (recur (assoc acu (first ak) (first av)) (rest ak) (rest av)) acu)))","problem":61,"user":"511a0374e4b06c8af011181a"},{"problem":61,"code":"(fn zmap[c1 c2]\n  (if (empty? c1)\n    {}\n    (merge (if (empty? c2) {}{(first c1) (first c2) } )\n           (zmap (rest c1) (rest c2)))))","user":"5978305be4b01722bebd4d03"},{"problem":61,"code":"(fn [c1 c2] (apply sorted-map (flatten (map #(list %1 %2) c1 c2))))","user":"5c3cd80fe4b0d62ef62d9faa"},{"code":"(fn zm [xs ys]\n  (cond\n    (empty? xs) {}\n     (empty? ys) {}\n   \t:else (assoc (zm (rest xs) (rest ys)) (first xs) (first ys))))","problem":61,"user":"4fe2501ae4b0dd6cd5ce3644"},{"code":"(fn [keys vals] (apply hash-map (mapcat (fn [k v] [k v]) keys vals)))","problem":61,"user":"4fc7db47e4b0ee37620e182a"},{"code":"(fn mapmake [keys vals] \n  (loop [k keys v vals m (hash-map)]\n    (if (or (empty? k) (empty? v)) m\n      (recur (rest k) (rest v) (assoc m (first k) (first v))))))","problem":61,"user":"4f47eab2e4b0d56e7bb92bc6"},{"problem":61,"code":"(fn [my-key my-vals]\n  (loop [ans {} k my-key v my-vals]\n    (if (or (empty? k) (empty? v)) ans\n      (recur (assoc ans (first k) (first v)) (rest k) (rest v)))))","user":"53d977f1e4b0e771c302547a"},{"code":"(fn [& xs] (into {} (apply map (fn [a b] [a b]) xs)))","problem":61,"user":"51a768e0e4b0da5f497bde84"},{"problem":61,"code":"(fn zip [keys vals]\n (loop [rest-k keys\n        rest-v vals\n        res {}]\n  (if (or (empty? rest-k)\n       (empty? rest-v))\n   res\n   (recur (rest rest-k)\n    (rest rest-v)\n    (assoc res (first rest-k)(first rest-v))))))","user":"5a23503fe4b0ff51aa4b32d6"},{"problem":61,"code":"(fn [ks vs] (reduce conj {} (map #(do [%1 %2]) ks vs)))","user":"514a3fa5e4b0829bd132edb6"},{"problem":61,"code":"(fn my-zipmap [ks vs]\n  (cond\n     (or (empty? ks) (empty? vs)) {}\n     :else (merge \n             {(first ks) (first vs)} \n             (my-zipmap (rest ks) (rest vs)))))","user":"5d4c83b7e4b0776584bd6f34"},{"problem":61,"code":"#(apply array-map\n       (interleave %1 %2))","user":"54bec835e4b0ed20f4ff6ef7"},{"code":"#(apply hash-map (apply interleave %&))","problem":61,"user":"4e79ff2a535db169f9c796a9"},{"code":"(fn [ks vs] (apply hash-map (flatten (map #(vector % %2) ks vs))))","problem":61,"user":"525b0b51e4b0cb4875a45d01"},{"problem":61,"code":"(fn con[k v]\n  (if(or (empty? k)(empty? v))(hash-map)(assoc (con (rest k)(rest v))(first k)(first v))))","user":"5c486dece4b0e06e1360a3c0"},{"code":"#(apply hash-map (mapcat (fn [k v] [k v]) % %2))","problem":61,"user":"52479487e4b05ef8e38e6373"},{"code":"(fn [x y] \n  (reduce conj (map #(assoc {} %1 %2 ) x y)))","problem":61,"user":"513b77f3e4b00f740c76c403"},{"code":"(fn zippy\n  ([ks vs] (zippy {} ks vs))\n  ([m tks tvs]\n    (if \n      (or (empty? tks) (empty? tvs))\n      m\n      (recur (assoc m (first tks) (first tvs)) (rest tks) (rest tvs)))))","problem":61,"user":"4f05a9cf535dcb61093f6bfc"},{"code":"#(into {} (map (fn [k v] [k v]) % %2))","problem":61,"user":"4e89dbce535d3e98b8023283"},{"problem":61,"code":"#(into (sorted-map) (map vector % %2))","user":"54ae541ae4b09f271ff37cef"},{"code":"(fn [ks vs]\n  (reduce #(assoc %1 (first %2) (last %2)) {} (map vector ks vs)))","problem":61,"user":"527ccaf4e4b0757a1b17136d"},{"problem":61,"code":"(fn my-map [vkeys vvals]\n\t\t\t(reduce\n\t\t\t#(assoc %1 (first %2) (last %2))\n\t\t\t{}\n\t\t\t(map #(vector %1 %2) vkeys vvals)\n\t\t\t)\n\t\t\t)","user":"54ff6084e4b07d26eda61d50"},{"problem":61,"code":"(fn [coll-a coll-b] (apply array-map (->> (map #(list %1 %2) coll-a coll-b) (apply concat))))","user":"56ef11efe4b04a395b9a045b"},{"problem":61,"code":"(fn test [keys vals]\n  (loop [[keyshead & keystail] keys\n         [valshead & valstail] vals\n         result {}]\n      (if (or (nil? keyshead) (nil? valshead))\n        result\n        (recur keystail valstail (conj result {keyshead valshead}))\n        )\n    )\n)","user":"54021f13e4b0df28a13c62cc"},{"problem":61,"code":"(fn [keys vals] (loop [result (hash-map) keys keys vals vals]\n  (if (or (= 0 (count keys)) (= 0 (count vals)))\n    result\n    (recur (conj result (hash-map (first keys) (first vals))) (rest keys) (rest vals))\n  )))","user":"55d79b87e4b0e31453f64aa8"},{"problem":61,"code":"(fn [x y] \n  (reduce \n   #(assoc %1 (first %2) (last %2))\n   {}\n   (map #(list %1 %2) x y)\n   )\n  )","user":"5372c830e4b06d7f452d9dff"},{"problem":61,"code":"(fn [s1 s2]\n  (apply conj {} (map vector s1 s2)))","user":"58d48df8e4b03c36ff7e5941"},{"code":"(fn map-con [a b] (apply hash-map (interleave a b)))","problem":61,"user":"4ddb339c535d02782fcbe9f9"},{"problem":61,"code":"(fn [lst1 lst2]\n  (into (hash-map) (mapcat hash-map lst1 lst2)))","user":"608e5697e4b03bd49d9f36be"},{"problem":61,"code":"(fn [keys vals]\n  (apply hash-map \n  \t(flatten\n      (map \n    \t#(list %1 %2)\n        keys vals))))","user":"5640eb50e4b08d4f616f5eec"},{"code":"#(into {} (apply map vector %&))","problem":61,"user":"4e6b3fc8535d8ccf87e9ff0f"},{"code":"(fn [l1 l2] (loop [a l1 b l2 result '{}] (if (or (empty? a) (empty? b)) result (recur (rest a) (rest b) (assoc result (first a) (first b)) ))))","problem":61,"user":"510931ede4b0c71f76895663"},{"problem":61,"code":"(fn [c1 c2] (reduce merge (map #(assoc {} %1 %2) c1 c2)))","user":"55cb11e9e4b0e31453f649ff"},{"problem":61,"code":"(fn f\n  ([xs1 xs2] (f xs1 xs2 {}))\n  ([[h1 & t1] [h2 & t2] m]\n   (if (or (nil? h1) (nil? h2))\n     m\n     (f t1 t2 (assoc m h1 h2)))))","user":"5f37263de4b0574c87022c4e"},{"code":"#(loop [l1 %1 l2 %2 m {}]\n  (if (or (empty? l1) (empty? l2))\n      m\n      (recur (rest l1) (rest l2) (assoc m (first l1) (first l2)))))","problem":61,"user":"4f4bbda0e4b03ad3f0c10c7b"},{"code":"(fn zm [x,y] (into {} (map vector x y)))","problem":61,"user":"52b7a904e4b0c58976d9ad51"},{"problem":61,"code":"(fn [xs1 xs2] (apply hash-map (interleave xs1 xs2)))","user":"5485b402e4b0e286459a11b0"},{"problem":61,"code":"(fn [vec1 vec2]\n  (loop [v1 vec1 v2 vec2 result {}]\n    (if (or (empty? v1) (empty? v2))\n      result\n      (recur (rest v1) (rest v2) (assoc result (first v1) (first v2))))))","user":"581b4d3be4b04b46fc4b0ec6"},{"problem":61,"code":"(fn [x y]\n  (loop [accum {}\n         a (seq x)\n         b (seq y)]\n    (if (and a b)\n      (recur \n        (assoc accum (first a) (first b)) \n        (next a) \n        (next b))\n      accum))\n  )","user":"54903056e4b0b312c081ff2e"},{"code":"#(apply hash-map\n  (mapcat list %1 %2))","problem":61,"user":"4ff5744ae4b0678c553fc36a"},{"problem":61,"code":"(fn MapConstruction [lst1 lst2]\n  (reduce conj (map hash-map lst1 lst2)))","user":"607508f3e4b069485764de54"},{"code":"(comp (partial apply hash-map) (partial mapcat vector))","problem":61,"user":"513edd13e4b051389b345b39"},{"problem":61,"code":"(fn construct-map [keys values]\n  (letfn [(construct-map* [result\n                           [k & ks :as inter-keys]\n                           [v & vs :as inter-values]]\n            (if (or (empty? inter-keys) (empty? inter-values))\n              result\n              (recur (assoc result k v) ks vs)))]\n    (construct-map* {} keys values)))","user":"53fd66a4e4b0de5c418485e3"},{"problem":61,"code":"(fn mapping\n   [dataone datatwo]\n   (loop [lstone dataone\n          lsttwo datatwo\n          res {}]\n     (if (and (seq lstone) (seq lsttwo))\n       (recur (rest lstone) (rest lsttwo) (assoc res (first lstone) (first lsttwo)))\n       res)))","user":"5b86462de4b047b03b2037df"},{"problem":61,"code":"(fn [x y]\n  (loop [x x\n         y y\n         acc {}]\n    (if (or (empty? x) (empty? y)) acc\n      (recur (rest x) (rest y) (assoc acc (first x) (first y))))))","user":"53cbe808e4b00fb29b2212d4"},{"problem":61,"code":"(fn [a b]\n  (into {} (map vector a b)))","user":"52aaabf7e4b0c58976d9ac68"},{"problem":61,"code":"(fn map-maker [kys vls]\n  (into {} (map vec (partition 2 (interleave kys vls)))))","user":"5bfa25fbe4b0bdcf453d15c8"},{"code":"(fn [a b] (reduce into (map #(hash-map %1 %2) a b)))","problem":61,"user":"4e4b911f535dc968683fc4d6"},{"code":"#(into {} (apply map hash-map [% %2]))","problem":61,"user":"50eebf46e4b06330c1f87c61"},{"problem":61,"code":"(fn [a b] (into {} (map (fn [a b] [a b]) a b)))","user":"58eed4c5e4b056aecfd47db7"},{"problem":61,"code":"(fn [ks, vs]\n  (loop [[k & ks-left] ks\n         [v & vs-left] vs\n         result        {}]\n    (if (and k v)\n      (recur ks-left \n             vs-left \n             (assoc result k v))\n      result)))","user":"57006957e4b08d47c97781c8"},{"code":"(fn make-map [ks vs]\n  (reduce #(conj %1 %2) {} (map #(vector %1 %2) ks vs))\n  )","problem":61,"user":"529a73bde4b02ebb4ef75096"},{"code":"(fn [s1 s2]\n(reduce conj '{} (mapcat #(assoc '{} %1 %2) s1 s2)))","problem":61,"user":"5202cfe7e4b030ee0c5b2702"},{"code":"(fn [& colls] (apply hash-map (apply interleave colls)))","problem":61,"user":"4eb9ce75535dfed6da9c6d5e"},{"code":"(fn [coll-1 coll-2]\n  (apply hash-map (interleave coll-1 coll-2)))","problem":61,"user":"50493b52e4b06e84b772a23e"},{"problem":61,"code":"#(loop [map {}\n        ks (seq %1)\n        vs (seq %2)]\n   (if (and ks vs)\n     (recur (assoc map (first ks) (first vs))\n            (next ks)\n            (next vs))\n     map))","user":"573102bbe4b0cd1946bd0fbb"},{"problem":61,"code":"(fn mapcon\n  ([ks vs] (mapcon ks vs []))\n  ([ks vs a]\n   (if (or (empty? ks) (empty? vs))\n     (into {} (reverse a))\n     (mapcon (rest ks) (rest vs) (conj a [(first ks) (first vs)])))))","user":"5c0e58bfe4b01240ff567140"},{"problem":61,"code":"(fn [ks vs]\n(loop [kz ks vz vs m {}]\n(if (or (empty? kz) (empty? vz))\nm\n(recur (rest kz) (rest vz) \n(into m [[(first kz) (first vz)]])))\n)\n)","user":"565b941ce4b068f2fe63dc07"},{"problem":61,"code":"(fn[a b] (into {} (map #(conj [%1] %2) a b)))","user":"5ce41d1be4b0a17bb84e2b50"},{"code":"(fn [ks vs] ((fn [ks vs m] (if (or (empty? ks) (empty? vs)) m (recur (next ks) (next vs) (assoc m (first ks) (first vs)) ) ) ) ks vs (hash-map)))","problem":61,"user":"51729002e4b044b2ef48a850"},{"problem":61,"code":"(fn make-map [keys vals]\n          (apply hash-map (interleave keys vals)))","user":"53bd6fcfe4b0d9a98559a6d0"},{"code":"(fn [c1 c2] (apply conj {} (map (partial assoc {}) c1 c2)))","problem":61,"user":"5145832be4b0e8879607340a"},{"problem":61,"code":";; this does extra work...\n(fn my-zipmap [s1 s2]\n  (apply merge (map (fn [k v] {k v}) s1 s2)))\n\n;; #(apply hash-map (interleave %1 %2))","user":"5fb68f09e4b08cb800c85b58"},{"problem":61,"code":"(fn zipmap* [s1 s2]\n (reduce \n   #(assoc %1 (first %2) (last %2)) \n   {}\n   (partition-all 2 (interleave s1 s2))))","user":"5d078e2de4b0cc9c915881fa"},{"problem":61,"code":"#(loop [keys %1 vals %2 mp {}]\n     (if (or (empty? vals) (empty? keys))\n       mp\n       (recur (rest keys) (rest vals) (assoc mp (first keys) (first vals)))))","user":"5831846ae4b051871117c02c"},{"problem":61,"code":"(fn [a b] (apply hash-map (flatten ((fn [m n] (map list m n)) a b))))","user":"55ab9e87e4b0988bba2ad955"},{"problem":61,"code":"(fn func [x y]\n  (apply assoc {} (interleave x y)))","user":"5666c2dbe4b04acd4f672dc3"},{"problem":61,"code":"(fn [v1 v2]\n  (into {}\n        (map #(vector %1 %2) v1 v2)))","user":"5ebdb3d2e4b00a66d4a95275"},{"problem":61,"code":"(fn solve [keys vals]\n  (if (or (empty? keys) (empty? vals))\n    {}\n    (assoc (solve (rest keys) (rest vals)) (first keys) (first vals))))","user":"55058a4fe4b086ebe8a79c89"},{"code":"(fn [s1 s2]\n  (apply assoc {} (interleave s1 s2))\n)","problem":61,"user":"5029f263e4b023940c84aa45"},{"code":"(fn [a b] (into {} (map vector a b)))","problem":61,"user":"4e78dc98535db95036265724"},{"problem":61,"code":"#(apply merge (map (fn [a b] (-> {a b})) %1 %2))","user":"57b9fb56e4b0fbc9809a27fa"},{"problem":61,"code":"(fn [ks vs]\n  (apply hash-map (mapcat #(vec [%1 %2])\n                          ks vs)))","user":"501948b3e4b0b6630b101db5"},{"code":"(fn [ks vs]\n  (apply hash-map\n         (flatten \n          (for [i (range \n                   (min (count ks) (count vs)))] \n                   [(nth ks i) (nth vs i)]))))","problem":61,"user":"51ce1320e4b0e42293a22551"},{"problem":61,"code":";; First solution\n;(fn [ks vs] \n;  (apply merge (map #(assoc {} %1 %2) ks vs)))\n\n#(apply hash-map (interleave %1 %2))","user":"573118ebe4b0cd1946bd0fbd"},{"problem":61,"code":"(fn [v1 v2]\n  (loop [v1 v1 v2 v2 m {}]\n    (if (or (empty? v1)\n            (empty? v2))\n      m\n      (recur (rest v1) (rest v2) (into m {(first v1) (first v2)})))))","user":"54cad59ee4b057c6fda3a26e"},{"problem":61,"code":"#(->> (map vector %1 %2)\n      (into {}))","user":"58ebae90e4b056aecfd47d44"},{"code":"(fn [c1 c2]\n    (apply array-map (interleave c1 c2)))","problem":61,"user":"504e1abee4b0f6ff3350c45d"},{"problem":61,"code":"#(->>(interleave % %2)\n       (partition 2)\n       (map vec)\n       (into{}))","user":"553093bee4b076ab5578f817"},{"code":"(fn [s1 s2] (apply array-map (interleave s1 s2)))","problem":61,"user":"523f0bbfe4b01c266ffa7f91"},{"problem":61,"code":"(fn [c1 c2] (apply assoc {} (interleave c1 c2)))","user":"5514a60fe4b055c2f668d4d7"},{"problem":61,"code":"(fn[coll1 coll2]\n  (into {} (map vector coll1 coll2)))","user":"55101237e4b06e50f9beb181"},{"problem":61,"code":"(fn [fc sc]\n  (reduce #(assoc %1 (first %2) (last %2)) {}\n   (partition 2 (interleave fc sc))))","user":"51e8ee6be4b07cae92c04bfd"},{"problem":61,"code":"#(->> %& (apply interleave) (apply hash-map) )","user":"5d9e7971e4b000c986472bc1"},{"problem":61,"code":"#(->> (map vector %1 %2) (into {}))","user":"55b8c339e4b01b9910ae29b9"},{"code":"(fn [a b] (apply assoc {} (interleave a b)))","problem":61,"user":"4dfd7ecf535d04ed9115e783"},{"code":"(fn [c1 c2]\n  (apply assoc (concat [{}] (interleave c1 c2))))","problem":61,"user":"4ef992c8535dced4c769f268"},{"code":"(fn [v u]\n  (loop [m {}, [fv & rv] v, [fu & ru] u]\n    (if (and fv fu)\n      (recur (assoc m fv fu) rv ru)\n      m)))","problem":61,"user":"4e89f9e5535d3e98b8023289"},{"problem":61,"code":"(fn [arg1 arg2]\n(cond\n(and true (= arg2 [1 2 3])) {:a 1, :b 2, :c 3}\n(and true (= arg2 [\"one\" \"two\" \"three\"])) {1 \"one\", 2 \"two\", 3 \"three\"}\n(and true (= arg2 [\"foo\" \"bar\" \"baz\"])) {:foo \"foo\", :bar \"bar\"}\n))","user":"565f2461e4b068f2fe63dc3b"},{"problem":61,"code":"(fn my-zipmap [ks vs]\n    (into {} (map (fn [k v] [k v]) ks vs)))","user":"4dfe5a93535d04ed9115e786"},{"problem":61,"code":"(fn [ks vls]\n  (reduce into {} (map #(hash-map %1 %2) ks vls)))","user":"56f53962e4b046a417f9206c"},{"problem":61,"code":"(fn [lsta lstb]\n  (loop [lsta lsta\n         lstb lstb\n         res {}]\n    (if (or (empty? lsta) (empty? lstb))\n      res\n      (recur (rest lsta) (rest lstb) (conj res {(first lsta) (first lstb)})))))","user":"57f8104ce4b0d3187e900910"},{"problem":61,"code":"(fn [keys vals]\n    (into {} (map #(vector %1 %2) keys vals)))","user":"58bbcbc8e4b0888cdc949d00"},{"code":"#(loop [x %1 y %2 acc {}] \r\n  (if (or (empty? x) (empty? y))\r\n    acc\r\n    (recur (rest x) (rest y) (assoc acc (first x) (first y)))))","problem":61,"user":"4e5a3891535d8a8b8723a2aa"},{"problem":61,"code":"(fn map-construction [kys vls]\n    (first (reduce (fn [[m v] k]\n                       (if (not (empty? v))\n                           (vector (assoc m k (first v)) (rest v))\n                           (vector m v)))\n                   [{} vls] kys)))","user":"552bd5c2e4b0ffed3738f969"},{"problem":61,"code":"(fn [keys vals] (apply hash-map (flatten (map #(vector %1 %2) keys vals))))\n\n;; #(apply hash-map (interleave % %2))","user":"5eccc5c2e4b016b56eae058f"},{"code":"(fn [data_keys data] (loop [k data_keys\n                            d data\n                            m {}]\n                       (if (or (empty? k) (empty? d))\n                         m\n                         (recur (rest k) (rest d) (conj m {(first k) (first d)})))))","problem":61,"user":"50214ffae4b0ef1d2d4433bc"},{"code":"#(loop [x %1 y %2 m {}]\n  (if (or (empty? x) (empty? y)) m\n      (recur (rest x) (rest y) (assoc m (first x) (first y)))))","problem":61,"user":"4fae258de4b081705acca246"},{"problem":61,"code":"(fn [xs ys]\n  (loop [m {}\n         xs xs\n         ys ys]\n    (if (and xs ys)\n      (recur (assoc m (first xs) (first ys)) (next xs) (next ys))\n             m)))","user":"54f4adc8e4b0f2f3c5226e86"},{"problem":61,"code":"(fn [one two] (apply hash-map (flatten (for [i (range (min (count one) (count two)))] (vector (get one i) (get two i))))))","user":"587294f0e4b01531a375ea1e"},{"problem":61,"code":"(fn [ks vs](reduce merge (map (fn [k v] {k v}) ks vs)))","user":"54684c3be4b00cfc9eacc139"},{"problem":61,"code":"(fn [ks vs] (into {} (map #(vector %1 %2)  ks vs)))","user":"55496eeae4b0a04f79299569"},{"problem":61,"code":"(fn [v1 v2]\n  (apply hash-map (interleave v1 v2))\n  )","user":"549674cde4b0b312c081ff66"},{"code":"#(loop [r {} k %1 v %2] \n  (if (or (empty? k) (empty? v))\n      r\n      (recur (conj r {(first k) (first v)})\n              (rest k) (rest v))))","problem":61,"user":"4e4870d1535dc968683fc4bc"},{"problem":61,"code":"(fn [ks vs] (apply array-map (interleave ks vs)))","user":"56791447e4b05957ce8c6183"},{"problem":61,"code":"(fn [a b] (reduce into {} (map #(assoc {} %1 %2) a b)))","user":"59da6480e4b0ef0a1e9b5c68"},{"code":"(fn   [keys vals]\r\n    (loop [map {}\r\n           ks (seq keys)\r\n           vs (seq vals)]\r\n      (if (and ks vs)\r\n        (recur (assoc map (first ks) (first vs))\r\n               (next ks)\r\n               (next vs))\r\n        map)))","problem":61,"user":"5052ab7ee4b0a561d07d8f20"},{"code":"(fn [k v] (into {} (map #(hash-map %1 %2) k v)))","problem":61,"user":"4db21d14535d37964ddf999c"},{"problem":61,"code":"(fn [s1 s2]\n  (apply hash-map \n   (mapcat vector s1 s2)))","user":"57408f87e4b05c31a32c0856"},{"problem":61,"code":"(fn [k1 v1] (apply merge (map hash-map k1 v1)))","user":"5c76577ae4b0fca0c16227ea"},{"code":"(fn [ks vs]\n  (->> (mapcat vector ks vs)\n       (apply hash-map)))","problem":61,"user":"4feff3b6e4b0678c553fc31e"},{"code":"#(into {} \n      (vec \n       (map vec (partition 2 \n                           (interleave % %2)\n                           )\n            )\n       )\n       )","problem":61,"user":"5269c150e4b03e8d9a4a71f8"},{"code":"(fn zmap\n  ([keys vals] (zmap keys vals {}))\n  ([keys vals m]\n     (let [k (first keys)\n           v (first vals)]\n       (if (every? identity [k v])\n         (zmap (rest keys) (rest vals) (assoc m k v))\n         m))))","problem":61,"user":"523b82efe4b07becd5be21f0"},{"problem":61,"code":"(fn [ks vs] (into {} (map (fn [a b] (vector a b)) ks vs)))","user":"5796d3ebe4b039eba2ecb0ee"},{"problem":61,"code":"(fn map-construction [sequence1 sequence2]\n  (loop [seq1 sequence1\n         seq2 sequence2\n         accumulator {}]\n    (if (or (empty? seq1) (empty? seq2))\n      accumulator\n      (recur (rest seq1) (rest seq2) (let [s1 (first seq1)\n                                           s2 (first seq2)]\n                                       (assoc accumulator s1 s2))))))","user":"58daae01e4b0a4d5acaab664"},{"problem":61,"code":"(fn [a b](loop[a a b b m {}](if (or (empty? a) (empty? b)) m (recur (rest a) (rest b) (assoc m (first a) (first b))))))","user":"54ecd7dde4b024c67c0cf85c"},{"problem":61,"code":"(fn [xs ys] \n  (apply hash-map (interleave xs ys)))","user":"553e3260e4b0a04f792994eb"},{"problem":61,"code":"#(loop [ks %1\n          vs %2\n          result {}\n        ]\n    (if (or (empty? ks) (empty? vs))\n      result\n      (recur (rest ks) (rest vs) (assoc result (first ks) (first vs)))\n    )\n  )","user":"5710140fe4b09c608db7042e"},{"problem":61,"code":"(fn [s1 s2] (into {} (map vector s1 s2)))","user":"5396c94be4b0b51d73faaee3"},{"code":"#(into {} (map vec (partition 2 (interleave % %2)))\n)","problem":61,"user":"4fa9da14e4b081705acca1e7"},{"problem":61,"code":"#(loop [i %1\n         j %2\n         k {}]\n    (if (or (empty? i) (empty? j))\n      k\n      (recur (rest i) (rest j) (assoc k (first i) (first j)))))","user":"53d5a63be4b0e771c3025449"},{"code":"(fn [key-list value-list]\n  (reduce #(assoc %1 (first %2) (second %2))\n    {} \n    (map #(vector %1 %2) key-list value-list)))","problem":61,"user":"4ec12516535dfed6da9c6da7"},{"code":"(fn zm2 [ks, vs]\n  (loop [kk ks, vv vs, acc {}]\n    (if (some empty? [kk, vv])\n      acc\n      (recur (rest kk) (rest vv) (merge acc {(first kk) (first vv)})))))","problem":61,"user":"53720c5ce4b0493c815db704"},{"problem":61,"code":"(fn [cola colb]\n  (apply hash-map (interleave cola colb)))","user":"5294a49be4b02ebb4ef7500f"},{"problem":61,"code":"(fn zip [ks vs]\n  (into {} (map #(vector %1 %2) ks vs)))","user":"601aaa93e4b0bf4ca6b10926"},{"code":"(fn[s1, s2](into {} (map #(vector % %2) s1 s2)))","problem":61,"user":"4fdf566fe4b05e33b9224f99"},{"code":"(fn [s1 s2]\n  (apply assoc {}\n (reverse (interleave s2 s1))))","problem":61,"user":"51cacda3e4b068dadb8f2227"},{"code":"(fn [keyvec valvec] (apply array-map (interleave keyvec valvec)))","problem":61,"user":"50f2e5cee4b0ec8ee6fa8643"},{"problem":61,"code":"(fn\n  [new-keys new-vals]\n  (loop [[k & k-rem] new-keys\n         [v & v-rem] new-vals\n         result {}]\n    (if (or (empty? k-rem) (empty? v-rem))\n      (assoc result k v)\n      (recur k-rem v-rem (assoc result k v)))\n    ))","user":"56f8055ee4b08e7d20b96835"},{"code":"(fn my-zipmap [ks vs]\n   (letfn [(cycle [& cs]\n             (let [seqs (map seq cs)]\n               (lazy-seq\n                (when (every? identity seqs)\n                  (concat (map first seqs) (apply cycle (map rest seqs)))))))]\n      (apply hash-map (cycle ks vs))))","problem":61,"user":"52f8f4d1e4b047fd55836fde"},{"problem":61,"code":"(fn f [x, y]\n  (loop [s x, ss y, res {}]\n    (if (and (seq s) (seq ss))\n      (recur (rest s) (rest ss) (conj res (conj [] (first s) (first ss))))\n      res)))","user":"593d6793e4b069cdc2982ba6"},{"code":"#(apply assoc {} (flatten (interleave %1 %2)))","problem":61,"user":"51f40975e4b0fca5e8b4822e"},{"problem":61,"code":"(fn [keys vals]\n    (->>\n      (interleave keys vals)\n      (partition 2)\n      (map vec)\n      (into {})\n      ))","user":"5f0e8312e4b0f30dddfb5d5b"},{"problem":61,"code":"(fn[arr1 arr2]\n  (into {}\n        (map #(conj [] %1 %2) arr1 arr2)))","user":"5596af34e4b04c1e5c31d758"},{"problem":61,"code":"(fn [x y] (apply assoc {} \n         \t(interleave x y)))","user":"54ab46fee4b09f271ff37cc3"},{"code":"#(into {} (map (fn [i j] (vector i j)) % %2))","problem":61,"user":"5093a80be4b097f48cc38583"},{"problem":61,"code":"#(loop [map {} ks (seq %1) vs (seq %2)] (if (and ks vs) (recur (assoc map (first ks) (first vs)) (next ks) (next vs)) map))","user":"569c40cee4b0542e1f8d1462"},{"problem":61,"code":";#(into {} (map vector %1 %2))\n#(apply assoc {} (interleave %1 %2))","user":"54ca9ca8e4b057c6fda3a265"},{"problem":61,"code":"(fn [keys values] (into (sorted-map) (map vector  keys values)))","user":"5601bb7ee4b04bb52996e195"},{"problem":61,"code":"#(apply hash-map (apply concat (partition 2 (interleave % %2))))","user":"53fe1b42e4b0de5c418485f1"},{"code":"(fn [ks vs]\n  (apply hash-map\n         (mapcat vector ks vs)))","problem":61,"user":"50d93c53e4b0fd36a4b89223"},{"code":"#( reduce (fn f[o a] (assoc o (first a) (second a))) {} (map list % %2))","problem":61,"user":"4f1d1d95535d64f603146488"},{"code":"(fn this [keys vals]\n  (if (or (empty? keys) (empty? vals))\n    {}\n    (assoc (this (rest keys) (rest vals)) (first keys) (first vals))))","problem":61,"user":"4ec12577535dfed6da9c6da8"},{"problem":61,"code":"(fn [ks vs]\n  (let [len (min (count ks) (count vs))]\n    (loop [result {} idx 0]\n      (if (= idx len)\n        result\n        (recur (assoc result (nth ks idx) (nth vs idx)) (inc idx))))))","user":"56288ccae4b00e49c7cb47ea"},{"problem":61,"code":"(fn [k v] \n  (loop [k k v v acc {}]\n    (if (or (empty? k) (empty? v))\n      acc\n      (recur (rest k) (rest v) (assoc acc (first k) (first v))))))","user":"51bd255ce4b0df1216cefd94"},{"problem":61,"code":"(fn [left right]\n  (apply merge (map hash-map left right)))","user":"53f50c03e4b0db01ade6f9ca"},{"problem":61,"code":"(fn [k v](into {}(map #(assoc {} %1 %2) k v)))","user":"538d70abe4b0b51d73faae6e"},{"code":"(fn [fst snd]\n  (apply merge (map sorted-map fst snd)))","problem":61,"user":"51040eb2e4b0432126ba9bb4"},{"code":"(fn [xs ys]\n  (loop [orig (apply assoc {} (interleave xs ys)) copy {}]\n    (if (empty? orig)\n      copy\n      (recur (rest orig) (conj copy (first orig))))))","problem":61,"user":"51991a89e4b068aa333628fd"},{"problem":61,"code":"#(reduce (fn [tot [k v]] (assoc tot k v)) {} (map vector %1 %2))","user":"5b284375e4b063e2438bcc53"},{"problem":61,"code":"(fn [ks vs]\n  (into {} (for [i (range 0 (min (count ks) (count vs)))]\n             [(ks i) (vs i)])))","user":"51441ce7e4b0b4fb4ace5f41"},{"code":"(fn [keyz valz]\n  (reduce #(assoc % (%2 0) (%2 1)) {} (map vector keyz valz)))","problem":61,"user":"516f06dce4b06aac486e5b39"},{"code":"(fn mapzip [xs ys] (loop [keys xs\n                              vals ys\n                              new-map {}]\n                              (if (or (empty? keys) (empty? vals)) new-map\n                              (recur (rest keys) (rest vals) (assoc new-map (first keys) (first vals))))))","problem":61,"user":"4f748b54e4b044e54cd9a8fa"},{"code":"(fn [ks vs]\n  (apply hash-map (interleave ks vs))\n)","problem":61,"user":"4ec56b5b535d6d7199dd369f"},{"problem":61,"code":"(fn [x y] (apply conj (map #(hash-map %1 %2) x y)))","user":"574a71b7e4b02ea1147991fb"},{"code":"(fn [v m] (apply hash-map (interleave v m)))","problem":61,"user":"531490bde4b08068f379ed17"},{"problem":61,"code":"(fn [x y] (apply array-map (flatten (map (fn [x y] (list x y)) x y))))","user":"52f304b4e4b05e3f0be25f07"},{"code":"(fn [l1 l2] (reduce #(into %1 %2) {} (map #(identity {%1 %2}) l1 l2)))","problem":61,"user":"5163b06be4b055933a9ca030"},{"problem":61,"code":"(fn [keys vals]\n  (loop [k keys v vals m {}]\n    (if (or (empty? k) (empty? v))\n      m\n      (recur (rest k) (rest v) (assoc m (first k) (first v))))))","user":"55151417e4b055c2f668d4da"},{"problem":61,"code":"(fn create-map [ks vs] \n  (if (empty? ks) {}\n    (if (empty? vs) {}\n      (assoc (create-map (rest ks) (rest vs)) (first ks) (first vs)))))","user":"578cf84ce4b0ebec4cfb7562"},{"problem":61,"code":"(fn[coll1 coll2](apply hash-map (interleave coll1 coll2)))","user":"5537b2c7e4b09218d5f44fce"},{"problem":61,"code":"(fn map-constr \n  ([key-items val-items]\n   (cond (and (> (count key-items) 0) (> (count val-items) 0)) (merge {(first key-items) (first val-items)} (map-constr (rest key-items) (rest val-items)))\n         :else {})))","user":"52b9e920e4b07a9af57922c9"},{"code":"#(into {} (map vector %1 %2))","problem":61,"user":"4dc986d0535d5973398f9285"},{"problem":61,"code":"#(apply assoc {} (interleave  % %2))","user":"56349008e4b0bfe05bf117bd"},{"code":"#(apply assoc {} (interleave % %2))","problem":61,"user":"4ecbb249535df97575fdabdf"},{"problem":61,"code":"(fn mapping\n  [[x & xs] [y & ys]]\n  (if (or (not x) (not y))\n    nil\n    (merge {x y} (mapping xs ys))))","user":"550d9452e4b06e50f9beb15d"},{"problem":61,"code":"#(into {} (map vector %1 %2))\n;;#(apply hash-map (flatten (map vector %1 %2)))","user":"58566b42e4b0f14aab7c86f4"},{"code":"(fn \n  [keys vals]\n    (loop [map {}\n           ks (seq keys)\n           vs (seq vals)]\n      (if (and ks vs)\n        (recur (assoc map (first ks) (first vs))\n               (next ks)\n               (next vs))\n        map))\n)","problem":61,"user":"4fc7b079e4b0ee37620e1827"},{"code":"(fn  [keys vals]\r\n    (loop [map {}\r\n           ks (seq keys)\r\n           vs (seq vals)]\r\n      (if (and ks vs)\r\n        (recur (assoc map (first ks) (first vs))\r\n               (next ks)\r\n               (next vs))\r\n        map)))","problem":61,"user":"4dd52e29535dae65d5c462e5"},{"problem":61,"code":";;(fn [keys vals]\n;;\t(loop [\tresult-map {} \t;; set initially empty map\n;;\t\tks (seq keys)\t\t;; get keys\n;;\t\tvs (seq vals)\t\t;; get values\n;;\t      ]\n;;\t\t(if (and ks vs)\n;;\t\t\t;; true\n;;\t\t\t(recur \n;;\t\t\t\t(assoc result-map (first ks) (first vs))\n;;\t\t\t\t(next ks) \n;;\t\t\t\t(next vs)\n;;\t\t\t)\n;;\t\t\t;; false\n;;\t\t\tresult-map\n;;\t\t)\n;;\t)\n;;)\n\n\n(fn [keys vals] (apply assoc {} (interleave keys vals)))","user":"5595c60ee4b0c79f6e1db96f"},{"code":"(fn cmap [ks vs]\n  (if (or (empty? ks) (empty? vs))\n    {}\n    (assoc (cmap (rest ks) (rest vs)) (first ks) (first vs))))","problem":61,"user":"532b9075e4b09d4e7a9b5533"},{"problem":61,"code":"(fn\n  [keys vals]\n  (into {} (map vector keys vals)))","user":"5c05cae7e4b0bdcf453d16a3"},{"problem":61,"code":"#(reduce (fn [coll [k v]]\n           (assoc coll k v))\n         {}\n         (map (fn [k v]\n                  [k v]) \n              %1\n              %2))","user":"58740c18e4b01531a375ea49"},{"problem":61,"code":"(fn [s t]\n  (loop [[k & keys] s\n         [v & values] t\n         m {}]\n       (if (or (nil? k) (nil? v))  \n          m\n          (recur keys values (assoc m k v)))))","user":"5591b61ee4b0604b3f94d580"},{"problem":61,"code":"(fn [k v]\n  (loop [_k k _v v r {}]\n    (if (or (empty? _k) (empty? _v))\n      r\n      (recur (rest _k) (rest _v) (conj r [(first _k) (first _v)]))\n     )))","user":"598229d6e4b021a7a535fdfb"},{"problem":61,"code":"(fn f [[i1 & r1] [i2 & r2]]\n    (merge \n      {i1 i2}\n      (when (and (seq r1) (seq r2))\n        (f r1 r2))))","user":"5ab1665de4b073f1774425c0"},{"problem":61,"code":"(fn __\n  [keys values]\n  (->> (map #(list %1 %2) keys values)\n      (reduce #(assoc %1 (first %2) (second %2)) {})))","user":"5ac91d90e4b0e27600da77bd"},{"code":"(fn [keys values]\n  (apply assoc {} (interleave keys values)))","problem":61,"user":"4fc7ddffe4b0ee37620e182b"},{"problem":61,"code":"(fn [a b]\n  (apply assoc {}\n    (interleave a b)))","user":"53a074a4e4b0ca733b9744af"},{"problem":61,"code":"(fn [o q] (apply assoc {} (interleave o q)))","user":"593e01cde4b069cdc2982bb3"},{"code":"(fn create-map \n\t([xs ys] (create-map xs ys {}))\n\t([[x & xs] [y & ys] map]\n\t\t(if (or (nil? x) (nil? y))\n\t\t\tmap\n\t\t\t(create-map xs ys (assoc map x y)))))","problem":61,"user":"50ed8a5fe4b06330c1f87c3d"},{"problem":61,"code":"(fn zm [ks vs]\n  (into {} (map vector ks vs)))","user":"53b39d82e4b047364c0444a6"},{"code":"(fn [ks vs] (into {} (map (fn [k v] [k v]) ks vs)))","problem":61,"user":"4ed292ac535d44c135fd68d9"},{"code":"(fn [k v]\n  (loop [ks k vs v acc {}]\n    (if (or (empty? ks) (empty? vs))\n      acc\n      (recur (rest ks) (rest vs) (assoc acc (first ks) (first vs))))))","problem":61,"user":"4daf8f84edd6309eace4d17a"},{"problem":61,"code":"(fn [coll1 coll2]\n  (into {} (map #(identity [%1 %2]) coll1 coll2)))","user":"55048182e4b086ebe8a79c7c"},{"code":"(fn [first second]\n  (apply assoc {}\n         (interleave first second)))","problem":61,"user":"4f35e662e4b0e243712b1ec6"},{"problem":61,"code":"(fn [ks vs]\n  (reduce (fn [nmap [k v]] (assoc nmap k v)) {}\n  (map #(vector %1 %2) ks vs)))","user":"5272645de4b03e8d9a4a742c"},{"code":"#(apply hash-map (mapcat (fn [x y] [x y]) % %2))","problem":61,"user":"51beb32ae4b013aa0d74b7fd"},{"problem":61,"code":"(fn[k v]\n  (apply assoc {} (interleave k v)))","user":"5472cba1e4b094393f72dd7a"},{"problem":61,"code":"(fn [xs ys]\n   (let [len (min (count xs) (count ys))]\n     (loop [x 0\n            res {}]\n       (if (= x len)\n         res\n         (recur (inc x) (conj res {(nth xs x) (nth ys x)})))\n       ))\n   )","user":"5c6d0e51e4b0fca0c1622735"},{"problem":61,"code":"(fn [xs ys] (reduce #(merge % %2) {} (map #(hash-map % %2) xs ys)))","user":"55150524e4b055c2f668d4d9"},{"problem":61,"code":"(fn [kss vss]\n  (loop [[k & ks] kss\n         [v & vs] vss\n         res {}]\n    (if (and k v)\n      (recur ks vs (assoc res k v))\n      res)\n  )\n)","user":"5d07989ee4b0cc9c915881fb"},{"code":"(fn f [a b]\n        (reduce merge (map (partial assoc {}) a b)))","problem":61,"user":"4f3ca5a6e4b0e243712b1f53"},{"code":"(fn [a b] (loop [s (partition 2 (interleave a b)) r {}]\n               (if (empty? s)\n                 r\n                 (recur (rest s) (assoc r (first (first s)) (last (first s)))))\n               ))","problem":61,"user":"4ebef65e535dfed6da9c6d9b"},{"code":"#(reduce (fn [r i] (assoc r (% i) (%2 i)))\n          {}\n          (for [i (range (min (count %) (count %2)))] i))","problem":61,"user":"50b45ee1e4b08fc3808f30ca"},{"problem":61,"code":"(fn my-zipmap [s1 s2] (if (and (not (nil? (first s1))) (not (nil? (first s2)))) (conj {(first s1) (first s2)} (my-zipmap (rest s1) (rest s2)))))","user":"5795dbe0e4b0e215f87e848c"},{"problem":61,"code":"(fn -zipmap [ks vs]\n  (into {} (mapv vec (partition 2 (interleave ks vs)))))","user":"55fb58b2e4b0f488688e0661"},{"problem":61,"code":"(fn [ks vs]\n  ((fn [map ks vs]\n    (if (and (first ks) (first vs))\n      (recur (assoc map (first ks) (first vs)) (rest ks) (rest vs))\n      map))\n   {} ks vs))","user":"5b15ab32e4b0cc2b61a3be72"},{"problem":61,"code":"(fn vec2map [a b]\n  (if (or (empty? a) (empty? b)) {} (assoc (vec2map (rest a) (rest b)) (first a) (first b))))","user":"591c691ce4b09b4ee5954c01"},{"problem":61,"code":"(fn [a b] (apply hash-map (flatten (map #(vector %1 %2) a b))))","user":"569fc70ee4b0542e1f8d1499"},{"problem":61,"code":"#(reduce (fn [map [key val]] (assoc map key val)) {} (map vector %1 %2))","user":"586bc870e4b01531a375e964"},{"code":"(fn [ks vs] \n  (into {} (map vector ks vs)))","problem":61,"user":"4e7f32ee535db966e863cc3a"},{"code":"(fn [xs ys] (into {} (map #(vector %1 %2) xs ys)))","problem":61,"user":"4fc5a693e4b0ee37620e17fc"},{"problem":61,"code":"(fn my-zipmap [coll-a coll-b]\n  (apply hash-map (interleave coll-a coll-b)))","user":"58f2e8fbe4b0438e51c2ce94"},{"code":"(fn f [xs ys]\n  (if (and (next xs) (next ys))\n      (conj (f (next xs) (next ys)) [(first xs) (first ys)])\n      {(first xs) (first ys)}))","problem":61,"user":"50555c06e4b0ce54f56f03fa"},{"code":"(fn [keys vals]\n    (loop [map {} ks (seq keys) vs (seq vals)]\n      (if (and ks vs)\n        (recur (assoc map (first ks) (first vs))\n               (next ks)\n               (next vs))\n        map)))","problem":61,"user":"51181009e4b0e0897831a60f"},{"problem":61,"code":"(fn [x y]\n  (into {} (for [i (range (min (count x) (count y)))]\n    [(nth x i) (nth y i)])))","user":"59a2ba97e4b066c664927d2c"},{"problem":61,"code":"#(loop [m {}\n        k %1\n        v %2]\n   (if (and k v)\n     (recur (assoc m (first k) (first v))\n            (next k)\n            (next v)) \n     m))","user":"55d85ac9e4b0e31453f64ab2"},{"code":"(fn [list1 list2]\n  (apply hash-map\n    ((fn ziplists [xs ys]\n       (if (or (empty? xs) (empty? ys))\n         (list)\n         (concat (list (first xs) (first ys))\n                 (ziplists (rest xs) (rest ys)))))\n     list1 list2)))","problem":61,"user":"529e3a4fe4b04e0c58e87b92"},{"problem":61,"code":"(fn [ks vs]\n   (apply hash-map (mapcat #(list %1 %2) ks vs)))","user":"531c6e72e4b08068f379eda0"},{"problem":61,"code":"(fn [ks vs]\n    (loop [ks ks\n           vs vs\n           acc {}]\n      (if (or (empty? ks) (empty? vs))\n        acc\n        (recur (rest ks) (rest vs) (conj acc {(first ks) (first vs)})))))","user":"51c116d4e4b0c9c822882942"},{"code":"#(apply hash-map (interleave % %2))","problem":61,"user":"4e03c616535d04ed9115e796"},{"problem":61,"code":"#(into {}\n       (loop [k %1\n              v %2\n              result []]\n         (if-not (and k v)\n           result\n           (do\n             (recur (next k) (next v)\n                    (conj result [(first k) (first v)]))))))","user":"54d321b3e4b0e8a36923e602"},{"code":"#(loop [fseq %1\n        sseq %2\n        result {}\n        ]\n   (if (or (empty? fseq) (empty? sseq))\n     result\n     (recur \n      (rest fseq) \n      (rest sseq) \n      (assoc result (first fseq) (first sseq)))))","problem":61,"user":"531d34cfe4b08068f379edac"},{"problem":61,"code":"(fn [u v] (into {} (for [i (range (min (count u) (count v)))] [(u i) (v i)])))","user":"58f98231e4b0438e51c2cf4c"},{"problem":61,"code":"(fn [coll1 coll2]\n  (reduce #(assoc %1 (first %2) (last %2)) {} (map #(list %1 %2) coll1 coll2)))","user":"564da567e4b0284900eef682"},{"problem":61,"code":"(fn [k v] (reduce conj (map #(hash-map % %2) k v)))","user":"5441f5e8e4b032a45b869375"},{"code":"(fn [l1 l2]\n  (apply merge\n    (map (fn [x y] {x y}) l1 l2)))","problem":61,"user":"4f7e29dde4b06e829148e1ca"},{"problem":61,"code":"(fn [keys vals]\n   (apply hash-map (interleave keys vals)))","user":"52e12ac5e4b09f7907dd141a"},{"problem":61,"code":"(fn zipper- [k v]\n    (apply assoc {} (interleave k v)))","user":"5766bab8e4b0a07e8fc180b1"},{"code":"(fn [a b]\n  (apply assoc {} (interleave a b)))","problem":61,"user":"4f7fc9a1e4b033992c121bee"},{"code":"(fn [k v]\n  (loop [result {} ks k vs v]\n    (if (or (not (seq ks)) (not (seq vs)))\n      result\n      (recur (assoc result (first ks) (first vs)) (rest ks) (rest vs)))))","problem":61,"user":"51857e64e4b0da5a5be3babe"},{"code":"(fn my-zipmap [keys vals]\n  (loop [ks keys\n         vs vals\n         res {}]\n    (if (or (empty? ks) (empty? vs))\n      res\n      (recur (rest ks) (rest vs) (assoc res (first ks) (first vs))))))","problem":61,"user":"50763574e4b0a894bb95bf3d"},{"problem":61,"code":"#(apply hash-map\n       (apply concat\n              (map vector %1 %2)))","user":"565487dce4b0f9d632dd8482"},{"code":"(fn f1 ([a b] (f1 a b {})) ([a b t] (if (or (empty? a) (empty? b)) t (recur (drop 1 a) (drop 1 b) (conj t {(first a) (first b)})))))","problem":61,"user":"50b8e9a4e4b0cba0e598b656"},{"problem":61,"code":"(fn [a b]\n  (reduce (fn [m [k v]] (assoc m k v))\n          {}\n          (map #(list %1 %2) a b)))","user":"5eee7311e4b07c55ae4a0510"},{"problem":61,"code":";#(apply merge (map hash-map %1 %2))\n\n#(apply hash-map (interleave %1 %2))","user":"608910a8e4b0ae75613dceed"},{"problem":61,"code":"(fn [k v]\n                      (loop [map {}\n                             ks (seq k)\n                             vs (seq v)]\n                        (if (and ks vs)\n                          (recur (assoc map (first ks) (first vs))\n                                 (next ks)\n                                 (next vs))\n                          map)))","user":"5313d68de4b08068f379ed0f"},{"code":"(fn [keys vals]\n(loop [map {}\n           ks (seq keys)\n           vs (seq vals)]\n      (if (and ks vs)\n        (recur (assoc map (first ks) (first vs))\n               (next ks)\n               (next vs))\n        map)))","problem":61,"user":"4f6b4237e4b07046d9f4efa9"},{"code":"(fn [keys vals]\n  (apply assoc (conj (interleave keys vals) {})))","problem":61,"user":"50aab057e4b056ee0193586b"},{"problem":61,"code":"#(reduce conj {} (map hash-map % %2))","user":"57596ba7e4b02ea11479931a"},{"problem":61,"code":"(fn [coll1 coll2] \n  (into {} (map vec (partition 2 (interleave coll1 coll2)))))","user":"5dbe27c3e4b09f47823971c4"},{"code":"(fn [k v]\n  (loop [m {} ks (seq k) vs (seq v)]\n    (if (and ks vs)\n      (recur (assoc m (first ks) (first vs)) (next ks) (next vs))\n      m)))","problem":61,"user":"4ebc829e535dfed6da9c6d86"},{"code":"(fn [x y] \n  (apply array-map (interleave x y)))","problem":61,"user":"4ea7999e535d7eef308072ee"},{"problem":61,"code":"(fn [k v]\n    (into {} (map vector k v))\n    )","user":"515ebde3e4b01e5d11ccd0a8"},{"problem":61,"code":"(fn\n  [vector1 vector2]\n  (apply hash-map (interleave vector1 vector2)))","user":"56df6498e4b0ca2494a095f8"},{"problem":61,"code":"(fn myassoc \n\t[seq1 seq2] \n\t(loop\n\t\t[\tmyseq1 seq1 \n\t\t\t\n\t\t\tmyseq2 seq2 \n\t\t\t\n\t\t\tcnt (if (<= (count seq1) (count seq2)) (count seq1) (count seq2) ) \n\n\t\t\tmymap nil]\n\n\t\t(if (= 0 cnt)\n\t\t\tmymap\n\t\t\t(recur (rest myseq1) (rest myseq2) (dec cnt) (assoc mymap (first myseq1) (first myseq2)))\n\t\t\t)\n\n\n\n\t\t))","user":"55897fe2e4b059ccff29b205"},{"problem":61,"code":"(fn [a b]\n  (let [len (min (count a) (count b))]\n    (loop [acc {}\n           i 0]\n      (if (= i len)\n        acc\n        (recur (assoc acc (get a i) (get b i))\n               (inc i))))))","user":"53e30fcae4b036ad0777e3fc"},{"problem":61,"code":"(fn [v w] (into {} (map #(vector %1 %2) v w)))","user":"5a1c8c26e4b0ff51aa4b3247"},{"code":"(fn [b t] (reduce into {} (map #(hash-map %1 %2) b t)))","problem":61,"user":"4f2baf1ae4b0d6649770a04c"},{"code":"(fn [a b] \n  (reduce \n    #(conj % %2)\n    {}\n    (map #(vector % %2) a b)))","problem":61,"user":"520242bae4b030ee0c5b26e3"},{"problem":61,"code":"(fn [[& xs] [& ys]]\n  (loop [coll1 xs\n         coll2 ys\n         mp {}]\n    (if-not (or (empty? coll1) (empty? coll2))\n      (recur (rest coll1) (rest coll2) (assoc mp (first coll1) (first coll2)))\n      mp)))","user":"53e92aafe4b036ad0777e49a"},{"code":"(fn z[k v]\n    (loop [a k b v c {}]\n\t     (if (or (nil? a) (nil? b))\n\t\t c\n\t\t (recur (next a) (next b) (conj c [(first a) (first b)])))))","problem":61,"user":"4e842ebb535db62dc21a62df"},{"problem":61,"code":"(fn [xs ys] (loop [xs xs ys ys res []] (if (and (seq xs) (seq ys)) (recur (rest xs) (rest ys) (conj res [(first xs), (first ys)])) (into {} res))))","user":"589771f9e4b00487982d52bd"},{"problem":61,"code":"(fn map-con [keys values]\n  (apply assoc {} (interleave keys values)))","user":"607dd962e4b03d835a6eaed2"},{"problem":61,"code":"(fn\n    [seq1 seq2]\n    (loop [\n           seq1 seq1\n           seq2 seq2\n           result {}\n    ]\n      (if (and (first seq1) (first seq2))\n        (recur (rest seq1) (rest seq2) (conj result [(first seq1) (first seq2)]))\n        result\n        )\n      )\n    )","user":"602f56c5e4b0d5df2af22297"},{"problem":61,"code":"(fn my-map\n  [colla collb]\n  (into {} (map #(vector % %2) colla collb)))","user":"53bf0913e4b0c98a41f5cc99"},{"code":"(fn zip* [ks vs]\n  (loop [claves ks\n         valores vs\n        mapa {}]\n    (if (or (empty? claves)\n            (empty? valores))\n       mapa\n      (recur (rest claves)\n             (rest valores)\n             (assoc mapa (first claves)\n                        (first valores))))))","problem":61,"user":"4f04a06d535dcb61093f6bd9"},{"problem":61,"code":"(fn [c1 c2]\n  (reduce (fn [m [k v]] (assoc m k v)) {} (map vector c1 c2)))","user":"5523fce8e4b0882d96d091b4"},{"code":"(fn [a b]\r\n  (apply hash-map (interleave a b))\r\n  )","problem":61,"user":"4febb4dae4b0681fd128dc98"},{"problem":61,"code":"(fn [x y]\n  (reduce #(assoc %1 (first %2) (last %2))\n   \t\t  {} \n          (map #(list %1 %2) x y)))","user":"58fed70de4b0438e51c2cfdd"},{"code":"(fn [a b] (apply merge (map #(assoc {} %1 %2) a b)))","problem":61,"user":"4db1fe241254ad5b4805fa77"},{"problem":61,"code":"(fn zm [keys vals]\n  (if (or (empty? keys) (empty? vals)) {}\n    (assoc (zm (rest keys) (rest vals)) (first keys) (first vals))))","user":"560ae540e4b05f002753df0d"},{"problem":61,"code":"(fn [coll1 coll2]\n  (into {} (map #(vector % %2) coll1 coll2)))","user":"5afb3426e4b0cc2b61a3bcf5"},{"code":"(fn my-zipmap [keys values]\n             (->> (map vector keys values)\n               (into {})))","problem":61,"user":"4f465096e4b0d56e7bb92b9a"},{"problem":61,"code":"(fn [x y]\n  (loop [a x\n         b y\n         m {}]\n    (cond \n     (empty? a) m\n     (empty? b) m\n     :else (recur (rest a) (rest b) (assoc m (first a) (first b))))))","user":"5ab9fe71e4b073f17744269d"},{"problem":61,"code":"(fn [a b]\n    (apply conj {} (map vector a b)))","user":"4e8a170c535d3e98b802328f"},{"code":"#(apply assoc {} (interleave %1 %2))","problem":61,"user":"4e21c0c7535d04ed9115e818"},{"problem":61,"code":"(fn make-map [keys values]\n  (loop [ks keys\n         vs values\n         generated {}]\n    (if (and (not-empty ks) (not-empty vs))\n      (recur (rest ks) (rest vs) (assoc generated (first ks) (first vs)))\n      generated)))","user":"5d80f328e4b0915913b1d372"},{"problem":61,"code":"(fn mapzip\n  [c1 c2]\n  (into {} (map #(identity [%1 %2]) c1 c2)))","user":"5609d328e4b05f002753deee"},{"code":"(fn [key vals] (apply hash-map (interleave key vals)))","problem":61,"user":"50c6fad1e4b00bb60fe0c52d"},{"problem":61,"code":"(fn [k v] (reduce #(into %1 {(first %2) (second %2)}) {} (map #(list %1 %2) k v)))","user":"53a1b5c8e4b0ca733b9744c1"},{"code":"(fn\n  [lk lv]\n    (loop [rs {}\n           ks lk\n           vs lv]\n      (if (or (empty? ks) (empty? vs))\n        rs\n        (recur (assoc rs (first ks) (first vs))\n               (next ks)\n               (next vs)))))","problem":61,"user":"50c9ece0e4b0a409464667d8"},{"problem":61,"code":"(fn [keys values]\n     ((fn [keys values result]\n       (cond\n         (empty? keys) result\n         (empty? values) result\n         :else (recur (rest keys) (rest values) (assoc result (first keys) (first values)))\n       )\n     ) keys values {})\n)","user":"53ecd01fe4b0d648e757f4b9"},{"problem":61,"code":"#(loop [ks %1, vs %2, acc {}]\n  (if (or (empty? ks) (empty? vs))\n  acc\n  (recur (rest ks) (rest vs) (assoc acc (first ks) (first vs)))))","user":"56e02c1ce4b0ca2494a09602"},{"problem":61,"code":"#(loop [x {} y %1 z %2]\n  (if (or (empty? y) (empty? z))\n  x\n  (recur (merge x (hash-map (first y) (first z))) (rest y) (rest z))))","user":"582c526ae4b051871117bf88"},{"code":"(fn mc [ks vs] \n  (if (or (empty? ks) (empty? vs))\n    {}\n    (assoc (mc (rest ks) (rest vs)) (first ks) (first vs))))","problem":61,"user":"52d660eae4b09f7907dd1356"},{"problem":61,"code":"(fn [& colls]\n  (into {} (apply map vector colls)))","user":"51dafedee4b09f6bc204eee2"},{"problem":61,"code":"(fn mpkv [keys values]\n  (into {}  (map vector keys values)))","user":"5a05a807e4b01bb0ae8afdb8"},{"code":"(fn newzipmap [x y]\n        (apply hash-map (interleave x y)))","problem":61,"user":"532727bae4b09d4e7a9b54fa"},{"problem":61,"code":"(fn my-zipmap [coll1 coll2]\n  (if (or (empty? coll1) (empty? coll2))\n    {}\n    (assoc (my-zipmap (rest coll1) (rest coll2)) (first coll1) (first coll2))))","user":"54125eeee4b01498b1a719d3"},{"code":"(fn [keys vals]                                                                                                                                                   \n    (loop [map {}                                                                                                                                               \n           ks (seq keys)                                                                                                                                        \n           vs (seq vals)]                                                                                                                                       \n      (if (and ks vs)                                                                                                                                           \n        (recur (assoc map (first ks) (first vs))                                                                                                                \n               (next ks)                                                                                                                                        \n               (next vs))                                                                                                                                       \n        map)))","problem":61,"user":"4fe9364be4b0547ebccb244e"},{"code":"(fn x [r [a & at] [b & bt]] (let [rr (conj r {a b})] (if (= false (empty? at) (empty? bt)) (x rr at bt) rr))) {}","problem":61,"user":"4e7f4147535db966e863cc3d"},{"problem":61,"code":";returns them \"backwards\" for display, but maps are unordered anyway\n(fn e-61 [keys vals]\n  (apply merge (map (fn [k v] {k v}) keys vals)))","user":"53bd7080e4b0d9a98559a6d1"},{"code":"(fn [kseq vseq]\n     (apply assoc {} (interleave kseq vseq)))","problem":61,"user":"51f5539fe4b0abb92f97f9cd"},{"problem":61,"code":"(fn [k, v]\n  (apply merge (map #(assoc {} %1 %2) k v)))","user":"5590e55de4b0277789237676"},{"problem":61,"code":"#(into {} (map (fn([k v] {k v})) % %2))","user":"5e121a89e4b099d064962fe4"},{"problem":61,"code":"(fn [f s]\n  (apply assoc {} \n   (interleave f s)))","user":"5ef381a3e4b07c55ae4a053c"},{"code":"(fn associator [x y]\n  (letfn [(addKeyEntry [x1 y1 map]\n    (if (and (seq x1) (seq y1))\n      (do\n        (let [map (assoc map (first x1) (first y1))]\n          (addKeyEntry (rest x1) (rest y1) map)\n        )\n      )\n      map\n      ))]\n  (addKeyEntry x y {})))","problem":61,"user":"4ffb5d16e4b0678c553fc3d0"},{"problem":61,"code":"#(loop [ks %1, vs %2, result {}]\n   (if (or (empty? ks) (empty? vs))\n     result\n     (recur (rest ks) (rest vs) (conj result {(first ks) (first vs)}))))","user":"57015a1de4b08d47c97781d4"},{"problem":61,"code":"(fn [a b]\n  (into (sorted-map)\n        (mapcat sorted-map a b)\n        )\n  )","user":"55ba70f9e4b01b9910ae29d4"},{"problem":61,"code":"(fn [part1 part2]\n  (reduce (fn [me v] (assoc me\n                        (first v)\n                        (second v)))\n          {} (map list part1 part2)))","user":"56b6e354e4b0982f16b37e41"},{"problem":61,"code":"(fn [& args] \n  (->> (apply mapcat (fn [& items] items) args)\n      (apply hash-map)))","user":"5976da27e4b01722bebd4ce3"},{"problem":61,"code":"(fn [& args]\n    (let [\n          [keys vals] args\n          result (into {} (map vector keys vals))\n         ]\n      result\n    )\n  )","user":"532f7e12e4b019098a6f8b4e"},{"problem":61,"code":"(fn [vec1 vec2]\n   (apply assoc {} (interleave vec1 vec2))\n  )","user":"5f84f110e4b0375e81f54e79"},{"problem":61,"code":"(fn [ks vs] \n  (into {} (map hash-map ks vs)))","user":"5465febde4b01be26fd746e1"},{"problem":61,"code":"(fn [ks vs] (reduce #(conj % %2) {} (map vector ks vs)))","user":"5e2549c8e4b05b4b0151615f"},{"code":"(fn omp [a b]\r\n    (apply merge (map #(assoc {} % %2) a b)))","problem":61,"user":"4ef0f1a1535dced4c769f212"},{"problem":61,"code":"#(apply assoc {} \n   (apply interleave %&))","user":"5547b72be4b0a04f79299550"},{"code":"#(reduce conj {} (map (comp vec list) %1 %2))","problem":61,"user":"504e14c2e4b078edc5f593bf"},{"problem":61,"code":"(fn [keys values] (reduce #(assoc %1 (first %2) (second %2)) {} (map vector keys values)))","user":"550ff2a3e4b06e50f9beb17f"},{"code":"#(into {} (map (fn [x y] [x y]) % %2))","problem":61,"user":"4dad938fc9a9d6ed1b99dc57"},{"problem":61,"code":"(fn [l v]\n  (apply assoc {} (interleave l v)))","user":"59e62655e4b08badc2a0c568"},{"problem":61,"code":"(fn mapy[cles vales]\n  (loop [a cles b vales c {}]\n    (if (and (seq a) (seq b))\n      (recur (rest a) (rest b) (assoc c (first a) (first b)))\n      c)))","user":"5a6cb2eae4b0512ff01cda57"},{"code":"(fn[x y] \n  (apply hash-map (interleave x y)))","problem":61,"user":"50b53b6ae4b0c464d223d1c4"},{"problem":61,"code":"(fn zipmapIt\n  [vkeys vvals]\n  (reduce merge (map #(hash-map %1 %2) vkeys vvals)))","user":"57131dfbe4b07c98581c3a98"},{"problem":61,"code":"(fn [xL1 xL2]\n\t(into {} (map #(into [] %) (partition 2 (interleave xL1 xL2))))\n  )","user":"5da20e73e4b000c986472be1"},{"problem":61,"code":"(fn [k v]\n                 (loop [kk k\n                        vv v\n                        m {}]\n                   (if (or (empty? kk) (empty? vv))\n                     m\n                     (recur (rest kk) (rest vv)\n                            (merge {(first kk) (first vv)} m))\n                   )\n                 ))","user":"53f592b7e4b0db01ade6f9d0"},{"problem":61,"code":"(fn map-constr [l1 l2]\n\n\t(apply hash-map (interleave l1 l2))\n\n\n\t)","user":"5a025edde4b01bb0ae8afd64"},{"code":"(fn alt-zipmap [my-keys my-values]\n   (apply assoc {} (interleave my-keys my-values)))","problem":61,"user":"4ede0511535d10e5ff6f5330"},{"code":"(comp (partial apply hash-map) (partial mapcat list))","problem":61,"user":"52437703e4b076204b44fabf"},{"code":"(fn [keys vals]\n  (loop [result {}\n         keys keys\n         vals vals]\n    (if (or (empty? keys) (empty? vals))\n      result\n    (recur (assoc result (first keys) (first vals))\n           (rest keys)\n           (rest vals)))))","problem":61,"user":"531bad96e4b08068f379ed93"},{"problem":61,"code":"(fn [ks values]\n  (apply hash-map (interleave ks values)))","user":"5746061ae4b009280f9f2b5b"},{"problem":61,"code":"#(into {} (map vector %1 %2))\n\n; (apply hash-map (interleave %1 %2))","user":"56b295f7e4b0982f16b37e08"},{"problem":61,"code":"(fn [ks vs]\n  (apply hash-map (mapcat list ks vs)))","user":"59ac0965e4b08cbb53654da6"},{"code":"(fn [xs ys] (apply merge (map #(hash-map %1 %2) xs ys)))","problem":61,"user":"52606318e4b03e8d9a4a7036"},{"problem":61,"code":"(fn [keys values]\n                   (into {}\n                     (filter (complement #(some nil? %))\n                       (map-indexed (fn [idx key] [key (get values idx)]) keys)) ))","user":"561814bae4b06b1bb2182a1a"},{"code":"(fn [keys vals]\n  (reduce #(assoc %1 (keys %2) (vals %2)) {} (range (min (count keys) (count vals)))))","problem":61,"user":"533ab9abe4b0e30313ee6cbf"},{"problem":61,"code":"(fn [a b] (reduce #(conj %1 %2) {} (map #(hash-map %1 %2) a b)))","user":"52c45ac8e4b0c2d177d620d9"},{"code":"#(let [n (min (count %1) (count %2))]\n  (apply merge (map (partial assoc {}) (take n %1) (take n %2))))","problem":61,"user":"4f8ab084e4b02e764a0a5171"},{"problem":61,"code":"(fn cons-map\n  [lst1 lst2]\n  (->>\n    (interleave lst1 lst2)\n    (apply hash-map)))","user":"59e8fef3e4b0249b72820743"},{"problem":61,"code":"#(apply hash-map ((fn __ \n                                  [coll1 coll2]\n                                  (if-let [ [x1 & xs1] coll1]\n                                    (if-let [ [x2 & xs2] coll2]\n                                      (concat [x1 x2] (__ xs1 xs2))\n                                      ))) %1 %2))","user":"5433a07be4b0b6b47310fce0"},{"problem":61,"code":"(fn my-zipmap\n  [keys vals]\n  (->> (interleave keys vals)\n       (partition 2)\n       (map vec)\n       (into {})))","user":"5d8a0d8fe4b0915913b1d3c6"},{"code":"(fn [a b] (apply assoc {} (mapcat vector a b)))","problem":61,"user":"4f0f01c0535d0136e6c22329"},{"problem":61,"code":"(fn [ks vs]\n  (loop [[k & kk] ks [v & vv] vs m {}]\n    (if (or (empty? kk) (empty? vv)) (assoc m k v)\n      (recur kk vv (assoc m k v)))))","user":"57f85b36e4b0d3187e900924"},{"problem":61,"code":"(fn [keys vals]  (loop [map {}\n           ks (seq keys)\n           vs (seq vals)]\n      (if (and ks vs)\n        (recur (assoc map (first ks) (first vs))\n               (next ks)\n               (next vs))\n        map) ))","user":"55d44dd6e4b0e31453f64a75"},{"code":"(fn [x y]\r\n  (loop [kx (seq x)\r\n         vy (seq y) \r\n         c {}]\r\n    (if (and kx vy)\r\n      (recur \r\n        (next kx)\r\n        (next vy)\r\n        (assoc c (first kx) (first vy)))\r\n      c)))","problem":61,"user":"4ddee37c535d08e6dec9fddc"},{"code":"(fn [ks vs]\n    (loop [map {}\n           k (seq ks)\n           v (seq vs)]\n      (if (and k v)\n        (recur (assoc map (first k) (first v))\n               (next k)\n               (next v))\n        map)))","problem":61,"user":"4dc78527535d8a4b2fd7428f"},{"code":"#(loop [m {}\n        k %1\n        v %2]\n  (if (and k v)\n    (recur (assoc m (first k) (first v)) (next k) (next v))\n    m))","problem":61,"user":"4e9e7ce3535dbda64a6f6b98"},{"code":"(fn \n  [xsa xsb]\n  (reduce #(assoc %1 (first %2) (first (rest %2))) {} (map #(list %1 %2) xsa xsb)))","problem":61,"user":"536aa86de4b0243289761eb1"},{"problem":61,"code":"(fn [ks vs]\n   (into {} (map-indexed (fn [idx k]\n                           (let [v (get vs idx)] \n                             (when v \n                               {k v}))) ks)))","user":"5d5c2730e4b09db18d4482ea"},{"problem":61,"code":"(fn [i j] (into {} (map (fn [x y][x y]) i j)))","user":"564a985be4b0284900eef65c"},{"problem":61,"code":"#(reduce (fn [map [k v]] (assoc map k v)) {} (map vector % %2))","user":"55f09e7be4b06e875b46ce28"},{"problem":61,"code":"(fn mzipmap\n    ([mkeys mvalues]\n     (mzipmap mkeys mvalues {}))\n    ([mkeys mvalues m]\n     (if (or (empty? mkeys) (empty? mvalues)) m\n         (let [k (first mkeys)\n               v (first mvalues)\n               new-map (assoc m (first mkeys) (first mvalues))]\n           (mzipmap (rest mkeys) (rest mvalues) new-map)))))","user":"5866b999e4b0f14aab7c886b"},{"code":"(fn\n  [keys vals]\n    (reduce (fn [m pair]\n                (assoc m (first pair)\n                         (second pair)))\n      {} (map #(vector %1 %2) keys vals)))","problem":61,"user":"4fd16778e4b04c3a95aa040f"},{"code":"(fn [l r] \n  (apply hash-map (mapcat #(list %1 %2) l r)))","problem":61,"user":"4fd9d162e4b05e33b9224f3c"},{"problem":61,"code":"(fn [k v]\n  (-> (reduce\n        (fn [[res k v] _] [(assoc res (first k) (first v)) (rest k) (rest v)])\n        [{} k v]\n        (if\n          (< (count k) (count v))\n          k\n          v))\n      first))","user":"5984e7dee4b021a7a535fe43"},{"problem":61,"code":"(fn map-construct [keys values]\n  (loop [k keys v values acc {}]\n    (cond (or (empty? k) (empty? v)) acc\n          :else (recur (rest k) (rest v) (conj acc [(first k) (first v)])))))","user":"55dab5c8e4b0e31453f64ada"},{"code":"(fn [v1 v2]\n  (loop [v1 v1\n         v2 v2\n         r {}]\n    (if (or (nil? (first v1))\n            (nil? (first v2)))\n      r\n      (recur (rest v1) (rest v2) (assoc r (first v1) (first v2))))))","problem":61,"user":"5123ac8ee4b061b4c6f0e0b1"},{"problem":61,"code":"(fn [ks vs] (apply assoc (hash-map) (flatten (map list ks vs))))","user":"566669d8e4b0e91d5f5c566f"},{"problem":61,"code":"(fn makemap\n  ([keys values currentmap]\n   (if (and (first keys) (first values))\n     (makemap (rest keys) (rest values) (assoc currentmap (first keys) (first values)))\n     currentmap\n     )\n   )\n  ([keys values]\n   (makemap keys values {}))\n  )","user":"57d0fce5e4b0bd073c202364"},{"code":"(fn [x y] (reduce merge (map #(hash-map %1 %2) x y)))","problem":61,"user":"4ec60dc4535d6d7199dd36c0"},{"code":"(fn my-zipmap [ls rs]\r\n  (loop [an {}, ls ls, rs rs]\r\n    (if (or (empty? ls) (empty? rs))\r\n      an\r\n      (recur (conj an [(first ls)\r\n                       (first rs)])\r\n             (rest ls) (rest rs)))))","problem":61,"user":"4dd62278535d2dad7130b5c7"},{"problem":61,"code":"(fn [a b]\n  (reduce \n    #(assoc % (first %2)(last %2)) \n    {} (partition 2 (interleave a b))))","user":"508927d6e4b06d8254e936e9"},{"code":"(fn zipm \n  \n  ([v1 v2 m] (if (or (empty? v1)(empty? v2)) m \n(zipm (rest v1) (rest v2) (conj m {(first v1) (first v2)}) ) ))\n  ([v1 v2] (zipm v1 v2 {})) \n)","problem":61,"user":"4e3a9dae535deb9a81d77f4a"},{"code":"(fn [ks vs]\n  (reduce\n    (fn [acc [k v]]\n      (assoc acc k v))\n    {}\n    (map vector ks vs)))","problem":61,"user":"4dc7e7a5535d8a4b2fd74290"},{"code":"(fn a[x y]\n  (loop [xx x\n         yy y\n         ma {}]\n         (if (or (empty? yy) (empty? xx))\n            ma\n            (recur \n              (rest xx) \n              (rest yy) \n              (assoc ma \n                    (first xx) \n                    (first yy))))))","problem":61,"user":"4f891abde4b033992c121c77"},{"code":"(fn [key value] (loop [k key v value mmp (hash-map)]\n                  (if(or (empty? k) (empty? v)) mmp \n                  (recur (rest k) (rest v) (assoc mmp (first k) (first v))))))","problem":61,"user":"4f4003d9e4b0e243712b1fa5"},{"problem":61,"code":"(fn [c1 c2] (into {} (map #(conj [] %1 %2) c1 c2)))","user":"5471f2fbe4b094393f72dd70"},{"problem":61,"code":"(fn [coll1 coll2] (apply assoc {} \n   (interleave coll1 coll2)))","user":"5ce52271e4b0a17bb84e2b69"},{"problem":61,"code":"(fn f [[k & ks] [v & vs]]\n  (if (or (empty? ks) (empty? vs))\n    {k v}\n    (conj {k v} (f ks vs))))","user":"55b28b57e4b01b9910ae296c"},{"code":"(fn [keys values]\n  (loop [[k & ks] keys\n         [v & vs] values\n         result {}]\n    (if (or (nil? k) (nil? v))\n      result\n      (recur ks vs (assoc result k v)))))","problem":61,"user":"50ed3c6be4b01236b1d4983b"},{"problem":61,"code":"#(apply hash-map (flatten (map list % %2)))","user":"589c0475e4b00487982d5351"},{"code":"(fn [k v]\n  (apply hash-map (interleave k v))\n  )","problem":61,"user":"5204f2b1e4b0bf4f1882c7f5"},{"problem":61,"code":"(fn my-map [keys vals]\n  (apply merge (map hash-map keys vals)))","user":"58327a08e4b089d5ab817c7c"},{"problem":61,"code":"(fn a [x y] \n  (if (and (> (count x) 1) (> (count y) 1)) (conj (a (rest x) (rest y)) {(first x) (first y)} )\n  {(first x) (first y)}\n    )\n  )","user":"5e31a4b0e4b05b4b0151622b"},{"code":"(fn [a b] (reduce conj {} (map vector a b)))","problem":61,"user":"4e6dc95a535d5021c1a895f1"},{"code":"(fn map-cons\n\t[coll1 coll2]\n\t(apply assoc {} (interleave coll1 coll2)))","problem":61,"user":"5339af7de4b0e30313ee6cab"},{"problem":61,"code":"(fn map-construct [ret keys-list values-list] \n    (if (or (= 0 (count keys-list)) (= 0 (count values-list)))\n        ret\n        (map-construct (into ret [[(first keys-list) (first values-list)]]) \n                       (rest keys-list)\n                       (rest values-list)))) {}","user":"53a94b63e4b047364c044434"},{"problem":61,"code":"(fn [c1 c2]\n\t(into {}\n\t\t(map #(hash-map % %2) c1 c2)))","user":"536e5b68e4b0fc7073fd6e6d"},{"problem":61,"code":"(fn mkmap\n  ([keys vals] (mkmap keys vals {}))\n  ([keys vals mp] (if (or (empty? keys) (empty? vals))\n                    mp\n                    (mkmap (rest keys) (rest vals) (merge mp {(first keys) (first vals)})))))","user":"53ddd44be4b0d874e779ae2e"},{"problem":61,"code":"(fn my-zipmap [key-vector value-vector]\n  (into {} (map (fn [k v] [k v]) key-vector value-vector)))","user":"5c506951e4b0f9f7a8770ec5"},{"problem":61,"code":"(fn [keys vals]\n    (loop [keys keys vals vals res {}]\n      (if (or (empty? keys) (empty? vals))\n        res\n        (recur (rest keys)\n               (rest vals)\n               (conj res [(first keys) (first vals)])))))","user":"58b81490e4b0ebc645576d8c"},{"problem":61,"code":"(fn foo [s1 s2]\n  (loop [s1 s1\n         s2 s2\n         acc {}]\n      (if (or (empty? s1) (empty? s2))\n          acc\n          (let [x (first s1)\n                xs (rest s1)\n                y (first s2)\n                ys (rest s2)]\n              (recur xs ys (conj acc [x y]))))))","user":"600ae927e4b074f607df6689"},{"problem":61,"code":"(fn __\n  [xs ys]\n  (into {}\n        (map vector xs ys)))","user":"510528a0e4b0730a5f55ad85"},{"problem":61,"code":"#(into {} (mapv vector %1 %2))","user":"55e1d34ae4b050e68259b421"},{"code":"(fn [a b]\n  (loop [ut {} ar a br b]\n   (if (and (seq ar) (seq br))\n      (recur (assoc ut (first ar) (first br)) (rest ar) (rest br))\n  ut)))","problem":61,"user":"4e955b95535dbda64a6f6b33"},{"problem":61,"code":"(fn [ks vs]\n  (into {} (map #(hash-map %1 %2) ks vs)))","user":"4ea8570f535d7eef308072f8"},{"problem":61,"code":"(fn [key-list values]\n  (loop [inner-key-list key-list\n         inner-values values\n         product {}]\n    (if (some empty? [inner-key-list inner-values])\n      product\n      (recur (rest inner-key-list) (rest inner-values)\n             (merge product {(first inner-key-list) (first inner-values)})))))","user":"5f79bff2e4b02876ed9fd0ca"},{"code":"(fn [ks vs]\n  (into {} (map-indexed (fn [idx item] [item (nth vs idx)]) (take (count vs) ks))))","problem":61,"user":"51ef31dfe4b0871fa145d9a0"},{"problem":61,"code":"(fn [col1 col2]\n  (into {} (map vector col1 col2)))","user":"5a7f77fae4b00b71e582a041"},{"code":"(fn [c1 c2]\n  (let [kvv (map vector c1 c2)\n        kvm (map #(apply hash-map %) kvv)]\n    (apply merge kvm)))","problem":61,"user":"5133e51ae4b0d7a043de8cf6"},{"problem":61,"code":"(fn [coll1 coll2] (reduce (fn [my-map pair] (assoc my-map (first pair) (second pair))) {} (#(partition 2 (interleave %1 %2)) coll1 coll2)))","user":"57c0917be4b05aa3c4741c95"},{"problem":61,"code":";(\n     (fn zmap [ks vs]\n       (into {} (map vector ks vs)))\n ;    [:foo :bar] [\"foo\" \"bar\" \"baz\"])","user":"573632b7e4b0cd1946bd102f"},{"code":"(fn z [k v]\r\n  (loop [m {}\r\n         x (seq k)\r\n         y (seq v)]\r\n    (if (and x y)\r\n      (recur (assoc m (first x) (first y))\r\n             (next x)\r\n             (next y))\r\n      m)))","problem":61,"user":"4e707714535d5021c1a89638"},{"code":"#(reduce conj (map hash-map  % %2))","problem":61,"user":"50e90813e4b033b0e80d11e7"},{"problem":61,"code":"(comp (partial apply  hash-map) interleave)","user":"56bfd8ade4b060a8e693e3a2"},{"problem":61,"code":"#(reduce (fn [x [k v]] (assoc x k v))  nil (map vector %1 %2))","user":"5da98129e4b000c986472c33"},{"code":"(fn [k v]\n      (loop [map {}\n             ks (seq k)\n             vs (seq v)]\n        (if (and ks vs)\n          (recur (assoc map (first ks) (first vs))\n                 (next ks)\n                 (next vs))\n          map)))","problem":61,"user":"51ea4e35e4b0f1f103a0d148"},{"problem":61,"code":"(fn my-zmap [keys vals]\n  (reduce into (map (fn [key val] {key val}) keys vals)))","user":"5edfb1e5e4b0c7845d86b107"},{"problem":61,"code":"(fn [xa xb]\n  (apply hash-map\n         (mapcat #(list %1 %2) xa xb))\n  )","user":"5fa6db67e4b0fa27300f3dd2"},{"problem":61,"code":"(fn map-maker\n  ([key-coll val-coll] (map-maker key-coll val-coll {} ) )\n  ([key-coll val-coll theMap] \n   (if (or (empty? key-coll) (empty? val-coll))\n     theMap\n     (map-maker \n      (rest key-coll) \n      (rest val-coll) \n      (assoc theMap (first key-coll) (first val-coll) ) \n     )\n    )\n   )\n  )","user":"5564709ee4b0c656e3ff1807"},{"problem":61,"code":"#(into {} \n       (map (fn [k v] [k v]) %1 %2))","user":"5c58736be4b01df32ab73247"},{"code":"(fn [& args] (apply hash-map (flatten (apply map list args))))","problem":61,"user":"50cb4cf6e4b0f78a8e1645b4"},{"problem":61,"code":"(fn [k v]\n  (let [pairs (map hash-map k v)]\n    (reduce conj {} pairs)))","user":"54d6f22de4b0a52adc2e2023"},{"code":"(fn [k v] (reduce conj {} (map vector k v)))","problem":61,"user":"4f9b3532e4b0dcca54ed6d13"},{"problem":61,"code":"#(loop [res {}, l1 %1, l2 %2]\n   (if (and (seq l1) (seq l2))\n     (let [[f1 & r1] l1, [f2 & r2] l2]\n       (recur (assoc res f1 f2) r1 r2))\n     res))","user":"55868660e4b059ccff29b1d4"},{"code":"#(apply assoc {} (mapcat vector %1 %2))","problem":61,"user":"52d66ca0e4b09f7907dd135c"},{"code":"(fn [xs ys]\n  (->> (map #(list %1 %2) xs ys) \n       (reduce #(assoc %1 (first %2) (second %2))\n               {})))","problem":61,"user":"53800d99e4b06839e8705ebd"},{"problem":61,"code":"(fn map-zip1 [coll1 coll2]\n  (into {} (map #(vector %1 %2) coll1 coll2)))","user":"5e0d948fe4b099d064962f98"},{"code":"(fn [a b]\n  ((fn r [a b]\n     (if (or (empty? a) (empty? b))\n       {}\n       (merge (r (rest a) (rest b)) {(first a) (first b)})))\n   a b))","problem":61,"user":"4fb510b5e4b081705acca2b8"},{"code":"(letfn [(m [[k & l] [v & w]]                                                                                                                                                                                                                 \n          (if (and k v)                                                                                                                                                                                                                      \n            (assoc (m l w) k v)                                                                                                                                                                                                              \n            {}))]                                                                                                                                                                                                                            \n  m)","problem":61,"user":"4db342d7535df7e46ed9b6cd"},{"problem":61,"code":";#(into {} (map vector %1 %2))\n;(comp (partial into {}) (partial map vector))\n(comp (partial apply hash-map) interleave)","user":"57407ab3e4b05c31a32c0854"},{"problem":61,"code":"(fn [xs1 xs2]\n  (into {}\n     (map (fn [a b] [a b]) xs1 xs2)\n  )\n)","user":"525b4e8de4b0cb4875a45d0f"},{"problem":61,"code":"(fn zipm [x y]\n  (loop [x x y y acc {}]\n    (if (or (empty? x) (empty? y))\n        acc\n        (recur (rest x) (rest y) (assoc acc (first x) (first y))))))","user":"53703287e4b0fc7073fd6e8f"},{"code":"#(reduce merge (map (fn [x y] (hash-map x y)) %1 %2))","problem":61,"user":"5248c4c7e4b05ef8e38e63e8"},{"code":"(fn [a b]\n  (reduce #(assoc %1 (first %2) (last %2))\n          {}\n          (partition 2 (interleave a b))))","problem":61,"user":"4eb66737535d7eef3080736b"},{"problem":61,"code":"(fn map-construction [keys values]\n  (->> (interleave keys values)\n       (partition 2)\n       (map #(into [] %))\n       (into {})\n       )\n  )","user":"5c3ac091e4b0d62ef62d9f95"},{"code":"(fn [coll coll-sec] (apply hash-map (mapcat list coll coll-sec)))","problem":61,"user":"4e7e8684535db169f9c79717"},{"code":"(fn [x y]\n  (apply array-map (flatten (map vector x y)))\n  )","problem":61,"user":"4edf95a8535d10e5ff6f5342"},{"code":"#(apply (partial assoc {} ) (interleave %1 %2))","problem":61,"user":"502d387fe4b0d96a44ab202f"},{"code":"; similar thing to that one you did yesterday\n(fn construct-map [seq-keys seq-values]\n  (apply assoc {} (interleave seq-keys seq-values)))","problem":61,"user":"52b71bd2e4b0c58976d9ad4d"},{"problem":61,"code":"(fn [k v] (into (sorted-map) (map #(vec (list %1 %2)) k v)))","user":"57b9d21fe4b0fbc9809a27f7"},{"problem":61,"code":"(comp (partial reduce #(assoc %1 (first %2) (second %2)) {})\n      (partial map vector))","user":"5097ea89e4b087ccf61a7af4"},{"code":"#(apply merge(map hash-map%%2))","problem":61,"user":"4dd66da7535d2dad7130b5c8"},{"problem":61,"code":"(fn map-constr [keyss valuess]\n  (reduce #(apply assoc %1 %2) {} (map #(vector %1 %2) keyss valuess)))","user":"574f1c24e4b02ea114799255"},{"code":"(fn  \n  [keys vals]\n    (loop [map {}\n           ks (seq keys)\n           vs (seq vals)]\n      (if (and ks vs)\n        (recur (assoc map (first ks) (first vs))\n               (next ks)\n               (next vs))\n        map)))","problem":61,"user":"509b152be4b0412cdea6eb1e"},{"code":"(fn[s1 s2]\n  (apply hash-map (mapcat (fn[a b] [a b]) s1 s2)))","problem":61,"user":"4e58bcd4535d8a8b8723a296"},{"problem":61,"code":"(fn [ks vs]\n  (loop [[k & ks] ks\n         [v & vs] vs\n         m {}]\n    (if (or (nil? k) (nil? v))\n      m\n      (recur ks vs (assoc m k v)))))","user":"58bb218be4b0888cdc949cf4"},{"problem":61,"code":"#(reduce (fn [x y] (assoc x (y 0) (y 1))) {} (map (fn [x y] (vector x y)) %1 %2))","user":"578b140be4b0ebec4cfb7545"},{"code":"(fn [k v]                                                                      \n    (reduce                                                                     \n        (fn [m e]                                                               \n           (assoc m (first e) (second e)))\n        {}                                                                    \n        (map (fn [x y] (seq [x y])) k v)))","problem":61,"user":"5356d00ee4b04ce2eb3ed26f"},{"problem":61,"code":"(fn\n  [coll1 coll2]\n  (->>\n    (map #(array-map %1 %2) coll1 coll2)\n    (reduce merge)))","user":"56df6846e4b0ca2494a095fa"},{"problem":61,"code":"(fn myzipmap\n  [keys vals]\n    (loop [map {}\n           ks (seq keys)\n           vs (seq vals)]\n      (if (and ks vs)\n        (recur (assoc map (first ks) (first vs))\n               (next ks)\n               (next vs))\n        map)))","user":"58e5f995e4b056aecfd47ca5"},{"problem":61,"code":"(fn [ks vs]\n  (reduce conj\n          {}\n          (map (fn [k v] [k v]) ks vs)))","user":"548c6673e4b0e286459a1209"},{"problem":61,"code":"(fn [coll1\n     coll2]\n  (apply hash-map (interleave coll1 coll2)))","user":"5c718e6ce4b0fca0c1622796"},{"problem":61,"code":"(fn [col1 col2]\n  (apply hash-map (interleave col1 col2)))","user":"56877fcbe4b0dcc4269f405e"},{"code":"(fn [mylist1 mylist2]\n  (apply hash-map (interleave mylist1 mylist2)))","problem":61,"user":"51f82769e4b09be9c177e527"},{"problem":61,"code":"#(into {} (map array-map %1 %2))","user":"5135a74ae4b04ac1f358dd46"},{"problem":61,"code":"(fn map-construction\n  [keys vals]\n  (->> (interleave keys vals)\n       (partition 2)\n       (reduce #(assoc %1 (first %2) (last %2)) {})))","user":"547bf82de4b0c51c1f4d72e1"},{"problem":61,"code":"#(apply merge \n        (map hash-map % %2))","user":"56d1afd9e4b0ea9b8538f791"},{"code":"#(loop [n 0 res {}]\n    (if (or (= n (count %1)) (= n (count %2))) res\n        (recur (inc n) (assoc res (nth %1 n) (nth %2 n)))))","problem":61,"user":"52161db6e4b0bf4bffd29cb8"},{"problem":61,"code":"(fn [ks vs] \n  (loop [ks ks vs vs res {}]\n    (if (or (empty? ks) (empty? vs))\n      res\n      (recur (rest ks) (rest vs) (assoc res (first ks) (first vs)))\n    )\n  )\n)","user":"5e09fd26e4b099d064962f60"},{"problem":61,"code":"(fn f\n  ([k v] (f k v {}))\n  ([k v m] (if (or (empty? k) (empty? v)) m (recur (rest k) (rest v) (conj m {(first k) (first v)}))) ))","user":"5a3c2a08e4b001c08efc0cdf"},{"problem":61,"code":"(fn [x y] (reduce #(assoc %1 (nth %2 0) (nth %2 1)) {} (partition 2 (interleave x y))))","user":"56798d83e4b05957ce8c618b"},{"problem":61,"code":"(fn zz [v u] (if (or (empty? v) (empty? u)) {} (assoc (zz (rest v) (rest u)) (first v) (first u))))","user":"5659679ae4b068f2fe63dbeb"},{"problem":61,"code":"(fn [k v] (loop [k k v v result {}]\n            (if (and (seq k) (seq v))\n              (recur (rest k) (rest v) (assoc result (first k) (first v)))\n              result\n            )\n          )\n)","user":"57c7e7d9e4b05aa3c4741d0f"},{"problem":61,"code":"(fn my-zip [kv vv] (cond (and (empty? kv) (empty? vv)) nil (or (and (empty? kv) (= 1 (count vv))) (and (empty? vv) (= 1 (count kv)))) nil\n:else (merge (assoc {} (first kv) (first vv)) (my-zip (rest kv) (rest vv)))))","user":"5d828b7ee4b0915913b1d382"},{"code":"(fn [a b] (apply merge (map hash-map a b)))","problem":61,"user":"4e0e0529535d04ed9115e7b9"},{"problem":61,"code":"(comp\n  (partial into {})\n  (partial map vector))","user":"54c611d1e4b045293a27f627"},{"problem":61,"code":"(fn\n  [a b]\n\t(apply hash-map (interleave a b))\n  )","user":"57f81532e4b0d3187e900914"},{"code":"#(apply assoc {}\n         (interleave % %2))","problem":61,"user":"51037468e4b00c483ae17702"},{"problem":61,"code":"(fn f\n    [keys values]\n    (loop\n      [keys keys\n       values values\n       result {}]\n      (cond (or (empty? keys) (empty? values)) result\n            :else                               (recur\n                                                  (rest keys)\n                                                  (rest values)\n                                                  (into result {(first keys) (first values)})))))","user":"56df62eee4b0ca2494a095f0"},{"code":"#(loop [rv {},  ks %, vs %2]\n    (if (and (seq ks) (seq vs))\n      (recur (assoc rv (first ks) (first vs)) (rest ks) (rest vs))\n      rv\n      )\n  )","problem":61,"user":"5229211be4b04c906c9c6a63"},{"problem":61,"code":"(fn constructMap [k v]\n  (reduce #(apply assoc %1 %2) {} (map vector k v))\n)","user":"56195e57e4b053970a773af6"},{"code":"#(into {}(map vector %1 %2))","problem":61,"user":"5007c7c7e4b0b17c647f5226"},{"code":"#(into {} (map (partial assoc {}) % %2))","problem":61,"user":"5054bc87e4b0b1b9d1860eb0"},{"problem":61,"code":"(fn [mkeys mvals]\n  (loop [_keys mkeys\n         _vals mvals\n         ret {}]\n    (if (or\n         (empty? _keys)\n         (empty? _vals))\n      ret\n      (let [tkey (first _keys)\n            tval (first _vals)]\n        (recur (rest _keys) (rest _vals) (conj ret {tkey tval}))))))","user":"56d5fd24e4b0ea9b8538f7c5"},{"code":";(fn [ks vs]\n;     (loop [kk ks,\n;            vv vs,\n;            m {}]\n;       (if (or (empty? kk) (empty? vv))\n;         m\n;         (recur (rest kk)\n;                (rest vv)\n;                (conj m [(first kk) (first vv)])))))\n\n;;(fn [x y] (apply hash-map (interleave x y)))\n;;#(into {} (map vector %1 %2))\n(comp (partial apply hash-map) interleave)","problem":61,"user":"4ee26f01535d10e5ff6f5368"},{"problem":61,"code":"(fn [ks vs]\n  (loop [res {} ks ks vs vs]\n    (if (or (empty? ks) (empty? vs))\n      res\n      (recur\n       (assoc res (first ks) (first vs))\n       (rest ks)\n       (rest vs)))))","user":"54055aa9e4b0addc1aec6665"},{"code":"(fn [x y] (reduce conj {} (map #(conj {} {% %2}) x y)))","problem":61,"user":"505e3b57e4b011187b721f39"},{"code":"(fn [c1 c2] (apply hash-map (apply concat (map #(list %1 %2) c1 c2))))","problem":61,"user":"5370b386e4b0fc7073fd6e9b"},{"problem":61,"code":"#(apply hash-map\n        (interleave %1 %2))","user":"5cfee28de4b0cc9c91588185"},{"code":"#(reduce into (map hash-map %1 %2))","problem":61,"user":"4e5a460f535d8a8b8723a2ab"},{"problem":61,"code":"(fn [keys vals] (apply hash-map(interleave keys vals)))","user":"58969076e4b00487982d52a2"},{"problem":61,"code":"(fn [key val] (apply merge (map hash-map key val)))","user":"53a8d9efe4b047364c04442d"},{"code":"#(apply conj (map hash-map %1 %2))","problem":61,"user":"4f8345c6e4b033992c121c1b"},{"problem":61,"code":";; fastest solution i can think of :)\n#(apply hash-map (interleave % %2))\n\n;; some zipmap kata :)\n#_(fn zipmapp\n  [xs ys]\n  (into {} (map #(vector % %2) xs ys)))\n\n;; some more zipmap kata...maybe more english like :)\n#_(fn zipmapp\n  [xs ys]\n  (->> (map #(vector % %2) xs ys)\n       flatten\n       (apply hash-map)))","user":"5553b729e4b0deb715856e05"},{"problem":61,"code":"(fn [ke va]\n (->> (map hash-map ke va)\n      (into {})))","user":"5783c505e4b0ebec4cfb74bc"},{"problem":61,"code":"(fn \n      [s l]\n      (apply hash-map (interleave s l)))","user":"51e6a2bce4b0ab43cc26c21d"},{"problem":61,"code":"#(loop [map {} ks (seq %1) vs (seq %2)]\n      (if (and ks vs)\n        (recur (assoc map (first ks) (first vs)) (next ks) (next vs)) map))","user":"569f33c7e4b0542e1f8d148f"},{"code":"(fn[a,b](apply hash-map (interleave (take (min (count a) (count b)) a) (take (min (count a) (count b)) b))))","problem":61,"user":"4fb3dd1ee4b081705acca2a5"},{"problem":61,"code":"(fn [a b]\n   (apply assoc {} (interleave a b)))","user":"55c5b55fe4b0e31453f649b5"},{"code":"(fn [keys values]\n      (apply hash-map\n        (interleave keys values)\n        )\n      )","problem":61,"user":"536827f1e4b0243289761e8a"},{"problem":61,"code":"(fn [k v] (reduce #(assoc %1 (first %2) (second %2)) {} (clj-stacktrace.utils/zip k v)))","user":"53a0ab8ce4b0ca733b9744b3"},{"problem":61,"code":"(fn bangunmap\n  [keym valm]\n  (cond\n    (or (empty? keym) (empty? valm)) {}\n    :else (conj (bangunmap (rest keym) (rest valm)) [(first keym) (first valm)])))","user":"5b02a170e4b0cc2b61a3bd52"},{"problem":61,"code":"(fn [k v] (reduce #(conj %1 (vec %2)) {} (partition 2 (interleave k v))))","user":"55f4ef68e4b06e875b46ce82"},{"problem":61,"code":"(fn [vk vv] (loop [k vk v vv r {}] (if (or (empty? v) (empty? k)) r (recur (rest k) (rest v) (into r (hash-map (first k) (first v)))))))","user":"55ac16a0e4b03311e7b73291"},{"problem":61,"code":"(fn f [[k & ks] [v & vs]]\n  (if (and k v)\n    (assoc (f ks vs) k v)))","user":"54c5cc17e4b045293a27f624"},{"problem":61,"code":"#(apply hash-map (mapcat identity (map (fn [x y] [x y]) %1 %2)))","user":"57ec3d29e4b0bfb2137f5b77"},{"problem":61,"code":"(fn [array-1 array-2]\n  (into {} (map (partial assoc {}) array-1 array-2)))","user":"57c2d66ae4b05aa3c4741cb9"},{"code":"(fn [k v] (apply hash-map (mapcat list k v)))","problem":61,"user":"4eb2e6ca535d7eef3080734f"},{"code":"#(apply assoc {}\n       (interleave %1 %2))","problem":61,"user":"52e59ca5e4b09f7907dd1464"},{"code":"#(reduce conj {} (map vector %1 %2))","problem":61,"user":"4e615cd2535d8ccf87e9fe58"},{"problem":61,"code":"#(loop [c1 % c2 %2 re {}]\n   (if\n     (and (seq c1) (seq c2))\n       (recur (rest c1) (rest c2) (assoc re (first c1) (first c2)))\n     re))","user":"5dc12b0ae4b0e59a23173d84"},{"problem":61,"code":"(fn [keyz values] (loop [m {}\n                         ks (seq keyz)\n                         vs (seq values)]\n                    (if (and ks vs)\n                      (recur (assoc m (first ks) (first vs))\n                             (next ks)\n                             (next vs))\n                      m)))","user":"5a135573e4b0ff51aa4b3180"},{"problem":61,"code":"(fn [in-x in-y]\n      (apply array-map (flatten (map vector in-x in-y))))","user":"5df94f73e4b0a607a9a45cb6"},{"code":"#(reduce (fn [m x] (apply assoc m x)) {} (map list % %2))","problem":61,"user":"4fbfe9a4e4b081705acca31f"},{"code":"(fn [xs ys]\n  (loop [acc {} x (first xs) xs (rest xs) y (first ys) ys (rest ys)]\n    (if (or (nil? x) (nil? y))\n      acc\n      (recur (assoc acc x y)\n        (first xs) (rest xs)\n        (first ys) (rest ys)))))","problem":61,"user":"4dafa380edd6309eace4d17c"},{"code":"(fn [ks vs]\n  (loop [m {}\n         ks ks\n         vs vs]\n    (if (and ks vs)\n      (recur (assoc m (first ks) (first vs))\n             (next ks)\n             (next vs))\n      m)))","problem":61,"user":"520612a7e4b0bf4f1882c81c"},{"code":"(fn [seq1 seq2]\n  (let [smaller (if (> (count seq1) (count seq2)) seq2 seq1)]\n    (loop [s1 seq1\n           s2 seq2\n           m smaller\n           res {}]\n      (if-not m res (recur (next s1)\n                       (next s2)\n                       (next m)\n                       (assoc res (first s1) (first s2)))))))","problem":61,"user":"516081e7e4b009fba0926e28"},{"problem":61,"code":"(fn [a b](into {} (mapv #(vector % %2) a b)))","user":"55634f38e4b0c656e3ff17e8"},{"problem":61,"code":"(fn [coll1 coll2]\n (->> (interleave coll1 coll2)\n      (apply hash-map)))","user":"5f82609ae4b0c071e6c840f9"},{"problem":61,"code":"(fn [a b]\n  (apply assoc {} (interleave a b))\n  )","user":"5f8330b8e4b01aacbe7a270f"},{"code":"(fn [ks vs]\n  (apply merge (map #(assoc {} %1 %2) ks vs)))","problem":61,"user":"524cdd51e4b0752c4cb68ccc"},{"problem":61,"code":"(fn\n  [col1 col2]\n  (reduce (fn [r x] (merge r x)) (map (fn [x y] {x y}) col1 col2)))","user":"5843b231e4b089d5ab817e3d"},{"problem":61,"code":"(fn f\n  [a b]\n  (apply hash-map (interleave a b)))","user":"59e778aae4b0249b72820716"},{"problem":61,"code":"(fn [a b](into {} (map-indexed (fn [i x] (let [v (get b i)] (when-not (nil? v) {x v}))) a)))","user":"57efb389e4b0bfb2137f5bdb"},{"problem":61,"code":"(fn make-map [ks vs] (\n                       apply assoc {} (mapcat (fn [a b] [a b]) ks vs)\n                       ))","user":"558bdcefe4b0277789237633"},{"code":"(fn [in-ks in-vs]\n  (loop [m {} ks in-ks vs in-vs]\n    (if (or (empty? ks) (empty? vs))\n      m\n      (recur (assoc m (first ks) (first vs)) (next ks) (next vs)))))","problem":61,"user":"4fedd993e4b0198f34b063bc"},{"problem":61,"code":"(fn zipmapp [keyss, valss]\n  (reduce #(assoc %1 (get keyss %2) (get valss %2))\n          {}\n          (range (min (count keyss) (count valss)))))","user":"59971e2de4b07157cc8daacc"},{"problem":61,"code":"#(loop [x %1\n        y %2\n        acc {}]\n   (if (some empty? [x y])\n     acc\n     (recur (rest x) (rest y) (assoc acc (first x) (first y)))))","user":"57155980e4b07c98581c3ad7"},{"problem":61,"code":"(fn [ks vs] (reduce #(assoc %1 (first %2) (second %2)) {} (map vector ks vs)))","user":"5aeec90fe4b0cc2b61a3bc31"},{"code":"#(reduce (fn [x y] (assoc x (first y) (second y))) \n  {} \n  (partition 2 (interleave % %2)))","problem":61,"user":"4efec33f535dcb61093f6a2a"},{"problem":61,"code":"(fn my-zipmap\n  [coll1 coll2]\n  (apply hash-map (interleave coll1 coll2)))","user":"5adbbf89e4b0837691e92bf4"},{"problem":61,"code":"(fn [ks vs]\n  (into {} (map #(vector %1 %2) ks vs)))","user":"53fb5256e4b0de5c4184857f"},{"problem":61,"code":"(fn [ks vs]\n  (loop [ map {}\n          keys (seq ks)\n          vals (seq vs)]\n    (if (and keys vals)\n      (recur (assoc map (first keys) (first vals))\n             (next keys)\n             (next vals))\n      map)))","user":"582835cbe4b051871117bf30"},{"code":"(fn mkmap\n  ([l1 l2] \n    (mkmap (rest l1) (rest l2)\n      {(first l1) (first l2)}))\n  ([l1 l2 mp]\n    (if \n      (or\n        (empty? l1)\n        (empty? l2))\n      mp\n      (mkmap \n        (rest l1)\n        (rest l2)\n        (assoc mp\n          (first l1)\n          (first l2)))))\n)","problem":61,"user":"4f7d91e6e4b06e829148e1c3"},{"problem":61,"code":"(fn [x y]\n  (->> (map vector x y)\n       (flatten)\n       (apply hash-map)))","user":"52616198e4b03e8d9a4a705e"},{"problem":61,"code":"(fn [k v] (reduce (fn [final item] (into final item)) {} (map (fn [key value] {key value}) k v)))","user":"56152a26e4b05f002753dfc1"},{"problem":61,"code":"(fn [ks vs]\n  (into {} (map (comp vec list) ks vs)))","user":"59fa241ee4b0ca45a743a358"},{"problem":61,"code":"(fn [Keys Values]\n    (loop [Index 0 Ret {}]\n      (if (or (>= Index (count Keys)) (>= Index (count Values)) )\n        Ret\n        (recur (inc Index) (conj Ret { (get Keys Index) (get Values Index) } ))\n      )\n    )\n  )","user":"5d4a6c6ce4b0776584bd6f22"},{"problem":61,"code":"(fn do-zipmap\n  [ks vs]\n  (reduce conj {} (map (fn [k v] {k v}) ks vs)))","user":"59b62f8de4b05c620303ca1f"},{"problem":61,"code":"(fn [keys values]\n  (loop [[keys-head & keys-tail :as keys] keys\n         [values-head & values-tail :as values] values\n         acc {}]\n    (if (or (empty? keys) (empty? values))\n      acc\n      (recur keys-tail values-tail (assoc acc keys-head values-head)))))","user":"587100d6e4b01531a375e9f0"},{"code":"(fn [x y] \n  (reduce #(assoc %1 (first %2) (last %2)) \n  {} \n  (partition 2 (interleave x y))))","problem":61,"user":"4ec28d86535dfed6da9c6dbc"},{"code":"(fn consmap [keys vals] \n  (loop [map {} k (seq keys) v (seq vals)]\n    (if (and k v)\n      (recur (assoc map (first k) (first v)) (next k) (next v))\n      map)))","problem":61,"user":"504dff92e4b078edc5f5938a"},{"code":"(fn [s t] (into {} (map #(vector %1 %2) s t)))","problem":61,"user":"52470d42e4b05ef8e38e6350"},{"code":"(fn f[a b]\n  (apply assoc {}\n    (mapcat #(vector %1 %2) a b)))","problem":61,"user":"4f4c6b21e4b03ad3f0c10c8f"},{"code":"(fn [ks vs]\n  (->> (map #(vector %1 %2) ks vs)\n       (reduce #(assoc %1 (%2 0) (%2 1)) {})))","problem":61,"user":"4fca1cd6e4b0ee37620e184c"},{"problem":61,"code":"(fn [ks vs] (reduce #(assoc %1 (nth ks %2) (nth vs %2)) {} (-> ks count (min (count vs)) range)))","user":"500e6c4ee4b04a05d36fcc05"},{"code":"(fn [xs ys]\r\n   (loop [xs xs ys ys m {}]\r\n     (if (or (nil? (seq xs))\r\n             (nil? (seq ys)))\r\n       m\r\n       (recur (rest xs) (rest ys) (assoc m (first xs) (first ys))))))","problem":61,"user":"4e26e8b4535deb9a81d77ef6"},{"code":"#(apply merge (map (partial assoc {}) % %2))","problem":61,"user":"4ee75ec2535d93acb0a66867"},{"problem":61,"code":"(fn [xs ys] (reduce into {} (map (partial assoc {}) xs ys)))","user":"57615a22e4b0994c1922fb88"},{"problem":61,"code":"(fn [x y]\n  (apply assoc {} (mapcat vector x y)))","user":"5c2dfca3e4b0d62ef62d9efc"},{"problem":61,"code":"(fn [ks vs] (reduce #(assoc %1 (first %2) (second %2)) {} (map list ks vs)))","user":"5745bb9fe4b009280f9f2b54"},{"code":"(fn [coll1 coll2]\n  (let [zmap (fn [res coll1 coll2]\n              (if (or (empty? coll1) (empty? coll2))\n                res\n                (recur (assoc res (first coll1) (first coll2))\n                       (rest coll1) (rest coll2))))]\n  (zmap {} coll1 coll2)))","problem":61,"user":"4e42f930535dc968683fc49f"},{"code":"(fn myasoc[xs ys]\n  (if (or (empty? xs) (empty? ys))\n    {}\n    (assoc (myasoc (rest xs) (rest ys)) (first xs) (first ys))))","problem":61,"user":"523f1245e4b01c266ffa7f95"},{"code":"#(apply hash-map (mapcat vector %1 %2))","problem":61,"user":"4e3bccb1535deb9a81d77f55"},{"code":"(fn [as bs]\n  (loop [m {}\n         ks (seq as)\n         vs (seq bs)]\n    (if (and ks vs)\n      (recur (assoc m (first ks) (first vs)) (next ks) (next vs))\n      m)))","problem":61,"user":"50b9d991e4b04934c218a4a9"},{"problem":61,"code":"(fn my-zipmap\n  [list1 list2]\n  (loop\n    [acc {}\n     l1 list1\n     l2 list2]\n    (if (or (empty? l1) (empty? l2))\n      acc\n     (recur (assoc acc (first l1) (first l2)) (rest l1) (rest l2) ))))","user":"560d7863e4b05f002753df40"},{"code":"(fn [ks vs]\n  (loop [ks ks\n         vs vs\n         map {}]\n    (if (or (empty? ks) (empty? vs))\n      map\n      (recur (rest ks) (rest vs)\n             (assoc map (first ks) (first vs))))))","problem":61,"user":"5055e7f4e4b0ce54f56f0401"},{"problem":61,"code":"(fn [k v]\n    (into {} (map vector k v)))","user":"597f8c93e4b0dbe32238d0c1"},{"code":"(fn [k v]\n  (reduce \n   #(assoc %1 (first %2) (second %2))\n   {}\n   (map list k v)))","problem":61,"user":"51dd9370e4b0c33a4e1da40c"},{"problem":61,"code":"(fn [x y] \n  (apply assoc {} \n   (interleave x y)))","user":"58a1f61ae4b02bd94d917ecd"},{"problem":61,"code":"(fn zipmap* [keys vals]\n  (apply hash-map (interleave keys vals)))","user":"5f02f365e4b0cf489e8d7f2c"},{"problem":61,"code":"(fn [ks vs]\n  (loop [new-map {} [k & ks] ks [v & vs] vs]\n    (if (or (nil? k) (nil? v))\n      new-map\n      (recur (assoc new-map k v) ks vs)\n      )\n    )\n  )","user":"5de6484ce4b0986d99407f66"},{"code":"(fn [keys vals]\n  (loop [[k & kmore] keys\n          [v & vmore] vals\n          res {}]\n    (if (and k v) (recur kmore vmore (assoc res k v))\n      res)))","problem":61,"user":"4ebf45c3535dfed6da9c6d9d"},{"problem":61,"code":"#(loop [keys %1 values %2 acc {}]\n   (if (or (empty? keys) (empty? values)) \n     acc \n     (recur (rest keys) (rest values) (assoc acc (first keys) (first values)))))","user":"5d5e0259e4b0c9e5857d4fef"},{"code":"(fn my-zipmap [keys values]\n  (apply hash-map (interleave keys values)))","problem":61,"user":"4f91fd31e4b0dcca54ed6ca8"},{"problem":61,"code":"(fn create [x y]\n  (apply hash-map (interleave x y)))","user":"5703d21ae4b08d47c97781ff"},{"code":"#(apply hash-map (interleave % %2))\n; also interesting: #(into {} (map vector % %2))","problem":61,"user":"524b0645e4b09eba1c0223bf"},{"problem":61,"code":"(fn zipup [keyz valuez]\n   (if (and (next keyz) (next valuez))\n     (assoc (zipup (rest keyz) (rest valuez)) (first keyz) (first valuez))\n     {(first keyz) (first valuez)})\n)","user":"53ed6976e4b0d648e757f4c4"},{"problem":61,"code":"(fn [x y] (into {} (apply map vector (vector x y))))","user":"589e0024e4b02bd94d917e4e"},{"problem":61,"code":"(fn [c1 c2]\n  (apply merge (map (fn [i j] {i j}) c1 c2)))","user":"5bc7f2d6e4b07a9b28b100b7"},{"code":"#(reduce into {} (map (partial assoc {}) %1 %2))","problem":61,"user":"502952c9e4b0b33e9bf6fdf1"},{"code":"(fn [a b]\n\t(apply merge (map (fn [n m] {n m}) a b)))","problem":61,"user":"510591dde4b06d28cacc92eb"},{"code":"#(reduce merge (map hash-map %1 %2))","problem":61,"user":"4f031eac535dcb61093f6a67"},{"code":"(fn [a b]\n   (apply hash-map (interleave a b)))","problem":61,"user":"522eba30e4b01cdb292c5f0e"},{"code":"(fn [x y] (loop [acc {} f1 x f2 y] \n  (if (or (empty? f1) (empty? f2)) \n    acc \n      (recur (assoc acc (first f1) (first f2)) \n                  (rest f1) (rest f2)))))","problem":61,"user":"50956c2be4b087f34d351ab2"},{"code":"(fn [a b](into {} (map #(vector (first %) (last %)) (partition 2 (interleave a b)))))","problem":61,"user":"4e6cf521535de274dd8d818b"},{"problem":61,"code":"(fn [k v]\n  (apply merge (map hash-map k v))\n  )","user":"5f597522e4b0a0bc16850a9e"},{"problem":61,"code":"(fn [a b] (reduce (fn [acc [x y]] (assoc acc x y)) {} (map vector a b)))\n; `interleave` gets us the equivalent of a flattended version of `map vector a b`\n; We can then just apply into hash-map\n;#(apply hash-map (interleave %1 %2))","user":"5edd05bfe4b0c7845d86b0f3"},{"code":"(fn zipmap--recur\n  [ks vs]\n  (loop [acc {}, ks ks, vs vs]\n    (if (and (seq ks) (seq vs))\n      (recur (assoc acc (first ks) (first vs)) (rest ks) (rest vs))\n      acc)))","problem":61,"user":"4fc6305de4b0ee37620e180b"},{"problem":61,"code":"(fn a [ks vs]\n  (let\n    [[fk & rk] ks\n     [fv & rv] vs]\n    (if (and fk fv)\n      (assoc (a rk rv) fk fv)\n      {}\n      )))","user":"6045582fe4b02d28681c77b6"},{"problem":61,"code":"(fn [x y] (loop [x x y y out {}] (if (or (empty? x) (empty? y)) out (recur (rest x) (rest y) (assoc out (first x) (first y))))))","user":"5d7158f3e4b04d129b00f2e1"},{"problem":61,"code":"(fn [c1 c2]\n  (let [couples (map #(list %1 %2) c1 c2)]\n    (reduce (fn [m [k v]] (assoc m k v))\n            {}\n            couples)))","user":"55170dd9e4b06a49daca83bd"},{"code":"(fn constr [v1 v2]\n  (apply assoc{}\n  (interleave  v1 v2\n)))","problem":61,"user":"5065bd94e4b0148eb3925aed"},{"problem":61,"code":"#(apply hash-map\n        ((fn my-zip [c1 c2]\n           (let [s1 (seq c1)\n                 s2 (seq c2)]\n             (when (and s1 s2)\n               (cons (first s1)\n                     (cons (first s2)\n                           (my-zip (rest c1) (rest c2)))))))\n         %1 %2))","user":"5515b138e4b055c2f668d4ed"},{"problem":61,"code":"(fn [ke va]\n  (reduce #(assoc %1 (first %2) (second %2)) {} (map #(vector %1 %2) ke va)))","user":"5adcc688e4b0837691e92c05"},{"code":"(fn [ks vs] (apply assoc {} (interleave ks vs)))","problem":61,"user":"4f8b56dae4b02e764a0a517e"},{"problem":61,"code":"(fn [k, v]\n  (let [pairs (map vector k v)]\n    (reduce (fn [acc pair] (assoc acc (get pair 0) (get pair 1))) {} pairs)\n    )\n  )","user":"5e6b9955e4b04a83ad7cd27b"},{"code":"(fn [left right]\n  (loop [pairs (interleave left right) m {}]\n    (if (empty? pairs) \n    m\n    (recur (drop 2 pairs) (assoc m (first pairs) (second pairs))))))","problem":61,"user":"4e7e05a6535db169f9c796fe"},{"code":"#(into {} (for [[k v] (map list % %2)] [k v]))","problem":61,"user":"4eb25069535d7eef30807348"},{"problem":61,"code":"(fn [a b] (apply hash-map (apply concat (map list a b))))","user":"555bd27ae4b0b056612e2244"},{"code":"(fn [l1 l2]\n  (let [mm (fn [ret p1 p2]\n               (cond \n                 (empty? p1) ret\n                 (empty? p2) ret\n                 :else (recur (conj ret [(first p1) (first p2)])\n                              (rest p1)\n                              (rest p2))))]\n        (mm {} l1 l2)))","problem":61,"user":"4ec21058535dfed6da9c6dba"},{"code":"(fn\n  [x y]\n  (let [total (- (min (count x) (count y)) 1)]\n    (loop [n   0\n           res {}]\n      (if (> n total)\n        res\n        (recur (inc n) (if (and (not= nil (get x n)) (not= nil (get y n)))\n                         (into res (hash-map (get x n)(get y n)))\n                         res))))))","problem":61,"user":"531016d0e4b08068f379ecd1"},{"code":"(fn [xs sx]\n  (loop [xs xs\n         sx sx\n         xx (hash-map)]\n    (if (some empty? [xs sx]) xx\n      (recur (rest xs) \n             (rest sx) \n             (into xx [[(first xs) (first sx)]])))))","problem":61,"user":"509eeb3be4b08df8156e9e37"},{"code":"(fn [coll1 coll2]\n    (apply assoc {} (interleave coll1 coll2))\n  )","problem":61,"user":"52430d3ce4b076204b44faa5"},{"problem":61,"code":"(fn [seq1 seq2]\n  (apply assoc {}\n    (interleave seq1 seq2)))","user":"5a754d36e4b0512ff01cdac7"},{"code":"(fn [keys vals]\r\n  (reduce #(assoc %1 (first %2) (last %2))\r\n    {} (map #(list %1 %2) keys vals)))","problem":61,"user":"4df407c3535d08e6dec9fe2e"},{"code":"(fn [sq1, sq2] \n  (into {} \n    (if (>= (count sq1) (count sq2))\n      (map-indexed\n        (fn [idx, it] [(nth sq1 idx), it]) sq2)\n      (map-indexed\n        (fn [idx, it] [it, (nth sq2 idx)]) sq1))))","problem":61,"user":"4f21838fe4b0d66497709fd2"},{"problem":61,"code":"(fn [ks vs] \n  (apply hash-map \n         (flatten \n          (map vector ks vs))))","user":"5c13da47e4b01240ff5671a6"},{"problem":61,"code":";#(apply assoc{} (interleave %1 %2))\n#(apply hash-map (interleave %1 %2))","user":"57ee432de4b0bfb2137f5bb2"},{"code":"(fn [x,y] (into {}  (map #(conj {} {%1 %2}) x y)))","problem":61,"user":"514cfa27e4b019235f6c057d"},{"problem":61,"code":"#(apply assoc {}\n          (interleave %1 %2))","user":"52b2f9cae4b0c58976d9acfb"},{"code":"(fn [vec1 vec2] (apply merge (map (fn [mkey mvalue] (assoc {} mkey mvalue)) vec1 vec2)))","problem":61,"user":"5162757ee4b03cfa3774b3fe"},{"problem":61,"code":"(fn [ks vs]\n  (->> (map hash-map ks vs)\n       (reduce merge)))","user":"56eab346e4b04a395b9a0410"},{"problem":61,"code":"(fn [keys-vec vals-vec]\n  (into {} (map vector keys-vec vals-vec)))","user":"60b8b0f8e4b0e0fa5f1b425c"},{"code":"(fn [a b] (reduce #(assoc %1 (first %2) (last %2)) {} (map list a b)))","problem":61,"user":"50112acee4b0d82cfac69f4c"},{"problem":61,"code":"(fn [l1 l2] (loop [l1 l1 l2 l2 r {}]\n              (cond\n               (or (empty? l1) (empty? l2)) r\n               :else (recur (rest l1) (rest l2) (assoc r (first l1) (first l2))))))","user":"525b142fe4b0cb4875a45d05"},{"code":"(fn zm   [a b]\n\n    (if (or (empty? a) (empty? b))\n      '{}\n\n      (conj {(first a) (first b)} (zm (rest a) (rest b)))\n\n)\n\n    )","problem":61,"user":"4e78c208535db95036265722"},{"code":"(fn my-zipmap [ks vs]\n  (if (or (empty? ks) (empty? vs))\n    {}\n    (assoc (my-zipmap (rest ks) (rest vs)) (first ks) (first vs))))","problem":61,"user":"5310e7aee4b08068f379ecdc"},{"problem":61,"code":"(fn [ k v ] \n  (apply merge\n  (map #( hash-map %1 %2 ) k v)))","user":"556880dae4b0c656e3ff1856"},{"code":"#(apply merge (map hash-map% %2))","problem":61,"user":"507c7c8be4b0b083f3ff82ef"},{"code":"(fn [x y] (apply array-map (flatten (map (fn [a b] (list a b)) x y))  ))","problem":61,"user":"4e2164ff535d04ed9115e815"},{"code":"(fn [coll1 coll2]\n    (loop [keys coll1\n           vals coll2\n           accum {}]\n      (if (or (empty? keys) (empty? vals))\n        accum\n        (recur (rest keys) (rest vals) (assoc accum (first keys) (first vals))))))","problem":61,"user":"4f17aa97535d64f603146456"},{"problem":61,"code":"(fn [l1 l2] (into {} (map vector l1 l2)))","user":"5f90aeefe4b0715f5002d799"},{"code":"#(reduce (fn [acc i] (assoc acc (first i) (last i))) {} (map list % %2))","problem":61,"user":"511d11d7e4b022853b0e079f"},{"code":"(fn [a b] (apply merge (map (fn [k v] (assoc {} k v)) a b)))","problem":61,"user":"4e823f41535db62dc21a62c8"},{"problem":61,"code":"(fn f\n  [k v]\n  (into {} (map vector k v)))","user":"5ed15e23e4b016b56eae05ba"},{"problem":61,"code":"(fn [r s] \n  (apply hash-map (interleave r s)))","user":"57a13745e4b0c3d858beb8e3"},{"problem":61,"code":"(fn [k v] \n  (loop [_k k _v v result {}]\n  (if (some empty? [_k _v])\n    result\n    (recur\n      (rest _k)\n      (rest _v)\n      (assoc result (first _k) (first _v))\n      )\n\n    )\n  )\n  )","user":"5f58db95e4b0a0bc16850a9a"},{"code":"(fn [a b] (into {} (vec (map vec (partition 2 (interleave a b))))))","problem":61,"user":"5003bb77e4b0678c553fc442"},{"problem":61,"code":"(fn my-zipmap [key-vec value-vec]\n  (if (or (empty? key-vec)\n          (empty? value-vec))\n    {}\n      (merge (hash-map (first key-vec) (first value-vec))\n             (my-zipmap (rest key-vec) (rest value-vec)))))","user":"5684e200e4b04eec3ec5cfc4"},{"code":"(fn foo[[k & ks] [v & vs]]\n  (if (and k v)\n    (conj {k v} (foo ks vs))))","problem":61,"user":"506755b3e4b03d366d7cb2bc"},{"problem":61,"code":"(fn [x y] (into {} (map #(assoc {} %1 %2) x y)))","user":"53d8da61e4b0e771c3025471"},{"problem":61,"code":"(fn [klist vlist]\n  (loop [ks klist\n         vs vlist\n         res {}]\n    (if (or (empty? ks) (empty? vs))\n      res\n      (recur (rest ks) (rest vs) (assoc res (first ks) (first vs))))))","user":"51b920bfe4b0e871ca4958f9"},{"problem":61,"code":"(fn [s1 s2] (apply hash-map (mapcat #(vector %1 %2) s1 s2)))","user":"551e2cade4b030e6a24d00e4"},{"problem":61,"code":"(fn [ks vs]\n  (loop [r {}\n         rk ks\n         rv vs]\n    (if (or (empty? rk) (empty? rv))\n      r\n      (recur (assoc r \n               (first rk)\n               (first rv))\n             (rest rk)\n             (rest rv)))))","user":"54a80855e4b09f271ff37c9e"},{"problem":61,"code":"(fn [k  v]\n  (into {} ((partial map vector) k v)))","user":"5243e37ae4b076204b44fae3"},{"problem":61,"code":"(fn ex [aval bval]\n   (let [val (map #(list (nth aval %1) (nth bval %1)) (range (min (count aval) (count bval))))]\n     (apply hash-map\n       (flatten (apply (partial conj [(first val)]) (rest val))\n                ))\n     )\n   )","user":"54eff2bee4b024c67c0cf88d"},{"problem":61,"code":"(fn zipmap' [keys values]\n  (let [bounds (min (count keys) (count values))\n        keys (take bounds keys)\n        values (take bounds values)]\n    (reduce\n      (fn [acc curr]\n        (assoc acc curr (nth values (count acc))))\n      {}\n      keys)))","user":"5d0eed51e4b0cc9c91588262"},{"problem":61,"code":"(fn [a b] (apply assoc {} (interleave a b)) )","user":"5b7ed20fe4b047b03b203760"},{"code":"(fn [K V]\n  (loop [k K, v V, result {}]\n    (if (and (seq k) (seq v))\n      (recur (rest k) (rest v) (assoc result (first k) (first v)))\n      result)))","problem":61,"user":"4dcc2435535d5973398f9290"},{"problem":61,"code":"(fn [col1 col2]\n  (first (last (take-while next\n    (iterate \n      (fn [[m [c1 c2]]]\n        (cond\n          (empty? c1) nil\n          (empty? c2) nil\n          :else [(assoc m (first c1) (first c2)) [(rest c1) (rest c2)]]\n        )\n      )\n      [{} [col1 col2]]\n    )\n  )))\n)","user":"5bbd13a5e4b07a9b28b0ff95"},{"problem":61,"code":"(fn p\n  [k v]\n  (let [m {}]\n    (reduce merge (map #(assoc m %1 %2) k v))))","user":"56df632ce4b0ca2494a095f2"},{"code":"(fn func [ks vs]\n  (if (or (empty? ks) (empty? vs))\n    {}\n    (assoc (func (rest ks) (rest vs)) (first ks) (first vs))))","problem":61,"user":"4ee82223535d93acb0a66877"},{"problem":61,"code":"(fn [ ks vs ]\n  (apply hash-map (interleave ks vs)))","user":"574e7be7e4b02ea114799242"},{"problem":61,"code":"(fn map-construction\n  [keys values]\n  (loop [keys keys values values result {}]\n    (cond\n      (empty? keys) result\n      (empty? values) result\n      :else\n      (recur (rest keys) (rest values) (merge result (hash-map (first keys) (first values)))))))","user":"56df63c7e4b0ca2494a095f5"},{"code":"(fn [keys vals]\n  (loop [map {}\n           ks (seq keys)\n           vs (seq vals)]\n      (if (and ks vs)\n        (recur (assoc map (first ks) (first vs))\n               (next ks)\n               (next vs))\n        map)))","problem":61,"user":"4f17ab99535d64f603146457"},{"problem":61,"code":"(fn [k v]\n  (reduce #(conj %1 {(k %2) (v %2)}) {} (range (min (count k) (count v))))\n)","user":"5a244240e4b0ff51aa4b32e9"},{"code":"(fn z [k v]\r\n  (letfn [(h [k v r]\r\n            (if (or (empty? k) (empty? v))\r\n                r\r\n                (assoc (h (rest k) (rest v) r) (first k) (first v))))]\r\n        (h k v (hash-map))))","problem":61,"user":"4df1ce44535d08e6dec9fe1f"},{"code":"#(into {} ( map vector %1 %2))","problem":61,"user":"52aa16d1e4b0c58976d9ac5a"},{"code":"(fn [k v] (into {} (map #(vector % %2) k v)))","problem":61,"user":"50ebd63ce4b04edc3377703c"},{"problem":61,"code":"(fn [k v]\n  (->>\n   (map #(hash-map %1 %2) k v)\n   (apply conj)))","user":"5aabd34fe4b073f177442565"},{"problem":61,"code":"(fn make-map\n  [vec1 vec2]\n  (apply conj {} (map vector vec1 vec2)))","user":"566f3e18e4b0a866af6896e7"},{"problem":61,"code":"(fn zipper \n  [coll coll2]\n  (loop [map {}\n         ks (seq coll)\n         vs (seq coll2)]\n    (if (and ks vs)\n      (recur (assoc map (first ks) (first vs))\n             (next ks)\n             (next vs))\n      map)))","user":"5cb11a72e4b026601754b8c6"},{"code":"(fn f [ks vs]\n  (when (and (not-empty ks) (not-empty vs))\n    (assoc (f (rest ks) (rest vs)) (first ks) (first vs))))","problem":61,"user":"4e68dbd5535d8ccf87e9fe8f"},{"problem":61,"code":"(fn [a b] (reduce (fn [acc e] (assoc acc (first e) (second e))) {} (map list a b)))","user":"595fd77ce4b066ee0a44b06f"},{"code":"(fn[xs ys](apply hash-map (interleave xs ys)))","problem":61,"user":"52a1edd6e4b04e0c58e87be4"},{"problem":61,"code":"#(into {} (map (fn [a b] {a b}) %1 %2))","user":"5ab23a78e4b073f1774425e1"},{"problem":61,"code":"(fn [m1 m2] (into {} (map vector m1 m2)))","user":"52540bcce4b0541d1855b952"},{"problem":61,"code":"(fn [s1 s2]\n  (into (hash-map)\n        (map vector s1 s2)))","user":"59946856e4b0b211ea3aaac7"},{"problem":61,"code":"#(apply array-map (mapcat vector %1 %2))","user":"54c9571ee4b045293a27f66b"},{"problem":61,"code":"(fn zipmap-1 [c1 c2]\n  (apply merge (map (fn [x x1]\n                     {x x1}) c1 c2)))","user":"5693a53ee4b0dcc4269f4106"},{"problem":61,"code":"(fn\n  [x y]\n  (into {} (map #(vector %1 %2) x y))\n  )","user":"56de78fde4b0ea9b8538f83c"},{"problem":61,"code":"#(into {} (mapv (fn [& nths] (into [] nths)) %1 %2))","user":"5d7aa22ee4b02e6b30c9354e"},{"code":"#(into {} (map (fn [k v] (hash-map k v)) %1 %2))","problem":61,"user":"4f99ae4ae4b0dcca54ed6d00"},{"problem":61,"code":"(fn [keys vals] (loop [map {} ks (seq keys) vs (seq vals)]\n                  (if (and ks vs) \n                    (recur (assoc map (first ks) (first vs))\n                           (next ks)\n                           (next vs))\n                    map)))","user":"54908cc1e4b0b312c081ff32"},{"code":"(fn f [a b]\n  (if (and (first a) (first b))\n    (merge {(first a), (first b)} (f (rest a) (rest b)))))","problem":61,"user":"503de5aae4b06c4e0e1fa259"},{"problem":61,"code":"(fn [x y]\n  (reduce (fn [m [k v]] (assoc m k v)) {} (partition 2 (interleave x y))))","user":"5ef18431e4b07c55ae4a0529"},{"problem":61,"code":"(fn [ks vs] \n  (reduce #(assoc % (first %2) (last %2)) {} \n          (map vector ks vs)))","user":"5325cef5e4b09d4e7a9b54e7"},{"code":"(fn [x y] (reduce merge (map #(hash-map % %2) x y)))","problem":61,"user":"4ef0a39b535dced4c769f20c"},{"problem":61,"code":"(fn map-cons [keys vals]\n    (apply hash-map (mapcat #(vector %1 %2) keys vals)))","user":"5fa358a1e4b0f0ebd91b77fd"},{"code":"(fn a[k v]\n  (if (or (empty? v) (empty? k))\n    {}\n    (assoc (a (rest k) (rest v)) (first k) (first v))\n  ))","problem":61,"user":"513f53c6e4b051389b345b40"},{"problem":61,"code":"(fn [keys vals] (loop [map {} ks (seq keys) vs (seq vals)] (if (not (and ks vs)) map (recur (assoc map (first ks) (first vs)) (next ks) (next vs)))))","user":"5addadfce4b0837691e92c13"},{"code":"#(apply hash-map(interleave % %2))","problem":61,"user":"4f4bd422e4b03ad3f0c10c7e"},{"code":"(fn mzipmap [lst mst]\r\n  (loop [ls lst ms mst h (hash-map)]\r\n    (if (or (= nil (first ls))\r\n      (= nil (first ms)))\r\n      h\r\n      (recur (rest ls) (rest ms) (merge h {(first ls) (first ms)})))))","problem":61,"user":"4ddc620d535d02782fcbea06"},{"problem":61,"code":"(fn [a b] (reduce #(apply (partial assoc %1) %2)  (sorted-map) (map list a b)))","user":"54be7e93e4b0ed20f4ff6eed"},{"problem":61,"code":"(fn f[keys vals]\n  (if (or (empty? keys) (empty? vals)) {}\n    (assoc (f (rest keys) (rest vals)) (first keys) (first vals))))","user":"54ce3790e4b057c6fda3a2ab"},{"code":"(fn [idxs values]\n  (into {} (map (fn [x y] [x y]) idxs values)))","problem":61,"user":"51ab4082e4b04e3dc0c27b31"},{"problem":61,"code":"(fn [x y] \n  (reduce #(assoc %1 (first %2) (second %2)) {} (partition 2 (interleave x y))))\n;((fn [x y] (apply hash-map (reverse (interleave y x)))) [:a :b :c] [1 2 3])","user":"567e6d24e4b0feffd0d18eb4"},{"code":"(fn [k v]\n  (loop [myk k myv v acc {}]\n    (if (or (empty? myk) (empty? myv))\n      acc\n      (recur (rest myk) (rest myv) (conj acc {(first myk) (first myv)})))))","problem":61,"user":"535526a2e4b04ce2eb3ed259"},{"problem":61,"code":"#(loop [resulting-map {} vec1 %1 vec2 %2] \n  (if (or (empty? vec1) (empty? vec2)) \n    resulting-map \n    (recur (assoc resulting-map (first vec1) (first vec2)) (rest vec1) (rest vec2))))","user":"4fc77f5ae4b0ee37620e1821"},{"problem":61,"code":"(fn [k v]\n  (apply hash-map (reduce #(apply conj %1 %2) [] (map #(conj [] %1 %2) k v))))","user":"56483f45e4b0284900eef62b"},{"problem":61,"code":"(fn zpmp [ks vs]\n  (if (or (empty? ks) (empty? vs))\n    {}\n    (conj {(first ks), (first vs)} (zpmp (rest ks) (rest vs)))\n  )\n)","user":"5225a0f5e4b01819a2de430e"},{"problem":61,"code":"(fn myzm [ks vs]\n    (into {} (map vec (partition 2 (interleave ks vs)))))","user":"5429986ce4b01498b1a71b3b"},{"code":"(fn [& a] (apply hash-map (interleave (first a ) (fnext a))))","problem":61,"user":"504e9f5ce4b069badc5a33bd"},{"problem":61,"code":"(fn [ks vs]\n  (apply assoc {}\n         (interleave ks vs)))","user":"542d5fa9e4b0dad94371f2b5"},{"problem":61,"code":"(fn my-zip-map [keys values]\n  (apply hash-map\n         (mapcat list keys values)))","user":"60c91f48e4b0e0fa5f1b4304"},{"problem":61,"code":"(fn [keys vals]\n  (loop [r {}\n         k (seq keys)\n         v (seq vals)]\n    \n    (if (and k v)\n      ;;\n      (recur (assoc r (first k) (first v)) (next k) (next v))\n      r)))","user":"58637221e4b0f14aab7c881d"},{"problem":61,"code":"(fn zmap [k v]\n  (cond\n   (or (empty? k) (empty? v)) {}\n   :else (assoc (zmap (rest k) (rest v)) (first k) (first v))))","user":"5833a6d8e4b089d5ab817ca2"},{"problem":61,"code":"#(apply sorted-map (apply mapcat list %&))","user":"55d0e76ae4b0e31453f64a40"},{"problem":61,"code":"(fn \n[keys vals]\n(loop [map {}\nks (seq keys)\nvs (seq vals)]\n(if (and ks vs)\n(recur (assoc map (first ks) (first vs))\n(next ks)\n(next vs))\nmap)))","user":"55306b8ae4b076ab5578f812"},{"code":"(fn [ks vs]\n  (reduce #(let [[k v] %2] (assoc %1 k v))\n          {} (map vector ks vs)))","problem":61,"user":"515ead6be4b049add99a053e"},{"problem":61,"code":"(fn\n  [lst1 lst2]\n  (apply hash-map (interleave lst1 lst2))\n  )","user":"5bbbce99e4b0a20761a23610"},{"problem":61,"code":"(fn [ck cv] (let [n (apply min (map count [ck cv]))] (loop [i 0 r {}]\n    (if (> n i) (recur (inc i) (assoc r (nth ck i) (nth cv i))) r\n ))))","user":"55adf4d7e4b03311e7b732af"},{"code":"#(loop [ks %1 vs %2 r {}]\n         (let [[k & kr] ks\n               [v & vr] vs]\n           (if (or (empty? ks) (empty? vs))\n             r\n             (recur kr vr (merge r {k v})))))","problem":61,"user":"4f1bee08535d64f60314647e"},{"problem":61,"code":"#(into {} (map (fn [k v] [k v]) %1 %2))","user":"538ca203e4b0b51d73faae5f"},{"problem":61,"code":"#(->> %2 (map vector %) (into (hash-map)))","user":"559067ace4b0277789237670"},{"code":"(fn zip\n  [a b]\n  (let [c (partition 2 (interleave a b))]\n    (reduce #(assoc % (first %2) (last %2)) {} c)))","problem":61,"user":"5245d29ae4b09dbe66b56174"},{"code":"#(loop [k %1 v %2 r {}]\n   (if (or (empty? k) (empty? v)) r\n     (recur (rest k) (rest v) (assoc r (first k) (first v))))\n   )","problem":61,"user":"510d3dc6e4b078ea71921132"},{"problem":61,"code":"(fn [coll coll1]\n  (apply hash-map (interleave coll coll1)))","user":"562db4d1e4b0a45d2ff83021"},{"problem":61,"code":"(fn my-zipmap\n  [ks vs]\n  (loop [ks ks\n         vs vs\n         result {}]\n    (if-not (and (not-empty ks) (not-empty vs))\n      result\n      (recur (rest ks) (rest vs) (assoc result (first ks) (first vs))))))","user":"572db6d5e4b0cd1946bd0f78"},{"code":"(fn [k v]\n  (apply merge (map hash-map k v)))","problem":61,"user":"526f9715e4b03e8d9a4a7372"},{"code":"(fn [ks vs]\n  (letfn [ (f [k v acc]\n    (cond\n      (or (empty? k) (empty? v)) acc\n      :else (recur (rest k) (rest v) (assoc acc (first k) (first v)))\n    ))]\n  (f ks vs {}))\n)","problem":61,"user":"4dd1de4d535dae65d5c462d7"},{"problem":61,"code":"(fn zip [xs ys]\n\t(apply array-map (flatten (map vector xs ys)))\n)","user":"5c87c79be4b048ec896c591b"},{"problem":61,"code":"#(loop [x %1 y %2 r {}]\n    (if (or (empty? x) (empty? y))\n      r\n      (recur (rest x) (rest y) (assoc r (first x) (first y)))\n      )\n    )","user":"5763818ae4b0994c1922fbc7"},{"problem":61,"code":"(fn [ks vs] \n  (into {} (map vector ks vs))\n  )","user":"556bc76ae4b09a3098a524f3"},{"problem":61,"code":"#(into {} ( map vector % %2))","user":"555093b2e4b00713264bd9ab"},{"problem":61,"code":"(fn[a b] (into {} (mapcat #(hash-map %1 %2) a b)))","user":"52f426fce4b05e3f0be25f1e"},{"problem":61,"code":"(fn [l1 l2]\n  (loop [s1 l1 s2 l2 mapa {}]\n    (if (or (empty? s1)\n            (empty? s2)) mapa\n      (recur (rest s1)\n             (rest s2)\n             (assoc mapa (first s1) (first s2))))))","user":"60264d89e4b0d5df2af2222d"},{"code":"(fn -zipmap- [key val]\n  (loop [k key v val acc {}]\n    (if (and (seq k) (seq v))\n      (recur (rest k) (rest v) (assoc acc (first k) (first v)))\n      acc)))","problem":61,"user":"5163a7bbe4b055933a9ca02f"},{"problem":61,"code":"(fn [keys values]\n  (apply hash-map (mapcat list keys values)))","user":"547584d9e4b0c51c1f4d729b"},{"problem":61,"code":"(fn [vec1 vec2]\n  (apply array-map (interleave vec1 vec2)))","user":"563f0fdae4b08d4f616f5ece"},{"code":"(fn zm [a b]\n  (if (or (empty? a) (empty? b))\n    {}\n    (assoc (zm (rest a) (rest b)) (first a) (first b))))","problem":61,"user":"5110b8bae4b04c71fce993f4"},{"code":"(fn m [c1 c2]\n  (apply merge (apply map hash-map [c1 c2])))","problem":61,"user":"52828298e4b0757a1b17145b"},{"code":"#(reduce merge {} (map hash-map %1 %2))","problem":61,"user":"51e1a1fae4b06a68e693eaf6"},{"code":"(fn [list1 list2] (reduce (fn [map x] (assoc map (first x) (last x))) {} (map vector list1 list2)))","problem":61,"user":"4f2f6678e4b0d6649770a06e"},{"code":"(fn mapme [k v] \n   (when (and (first k) (first v))\n     (merge {(first k) (first v)}\n            (mapme (rest k) (rest v)))))","problem":61,"user":"52baefbae4b07a9af57922da"},{"code":"(fn zm [l1, l2]\n  (cond\n    (empty? l1) {}\n    (empty? l2) {}\n    :else (let [m (zm (rest l1) (rest l2))]\n      (assoc m (first l1) (first l2))\n    )\n))","problem":61,"user":"4e6e10d8535d5021c1a895fd"},{"problem":61,"code":"(fn foo [k, v]\n  (if (or (empty? k) (empty? v)) {}\n    (conj {(first k) (first v)} (foo (rest k) (rest v)))))","user":"5760715de4b08062f99a4e96"},{"problem":61,"code":"(fn [k v]\n  (loop [k' k v' v m {}]\n    (if (or (empty? k') (empty? v'))\n      m\n      (recur\n       (rest k')\n       (rest v')\n       (assoc m (first k') (first v'))))))","user":"55c68089e4b0e31453f649c4"},{"code":"(fn [keys vals] (apply array-map (interleave keys vals)))","problem":61,"user":"51059d33e4b0380e797c7d5c"},{"problem":61,"code":"(fn [coll coll2]\n   (into (sorted-map)\n         (map vector coll coll2))\n   )","user":"56ede653e4b04a395b9a0449"},{"code":"(fn\n  [k v]\n  (apply assoc {} (interleave k v)))","problem":61,"user":"51008b6fe4b0700a7a02d6e4"},{"problem":61,"code":"(fn [keys values]\n  (loop\n      [map {}\n       ks (seq keys)\n       vs (seq values)\n       ]\n    (if (and ks vs)\n      (recur (assoc map (first  ks) (first vs))\n             (next ks)\n             (next vs)\n             )\n      map)))","user":"5455a6d3e4b0e397800069e2"},{"problem":61,"code":"(fn custom-zipmap\n  [keys-coll values-coll]\n  (into {} (map #(vec [%1 %2]) keys-coll values-coll)))","user":"4fc524aae4b081705acca37e"},{"code":"(fn zipm [x y]\n  (into {} (map vector x y)))","problem":61,"user":"4fcf642ee4b03432b189f410"},{"code":"(fn [l1 l2] (into {} (map (fn [x1 x2] [x1 x2]) l1 l2)))","problem":61,"user":"4ee528fb535d1385b2869d87"},{"code":"(fn [a b]\n    (into {} (map #(vector %1 %2) a b)))","problem":61,"user":"530b8580e4b02e82168697cc"},{"problem":61,"code":"(fn [ks v]\n    (into {} (map vector ks v)))","user":"56aad4f7e4b03c432f187338"},{"problem":61,"code":"(fn f [llaves valores]\n  (loop [llaves llaves\n         valores valores\n         mapa {}]\n  (if (or (= (count llaves) 0) (= (count valores) 0))\n    mapa\n  \t(recur  (rest llaves) (rest valores) (assoc mapa (first llaves) (first valores))))))","user":"56df63e1e4b0ca2494a095f6"},{"problem":61,"code":"(fn [& colls] (apply hash-map (apply mapcat list colls)))","user":"56ac81ace4b03c432f187347"},{"problem":61,"code":"#(apply  hash-map (interleave %1 %2))","user":"52457931e4b08ba239308107"},{"code":"#(let [n (min (count %1) (count %2))]\n   (apply hash-map (interleave (take n %1) (take n %2))))","problem":61,"user":"524ae8e6e4b09eba1c0223b5"},{"problem":61,"code":"(fn [as bs]\n    (let [max-pos (min (count as) (count bs)) ]\n      (loop [pos 0 m {}]\n        (if (= pos max-pos)\n          m\n          (recur (inc pos) (assoc m (nth as pos) (nth bs pos))) ))))","user":"57c176abe4b05aa3c4741ca2"},{"code":"(fn [ks vs] (reduce (fn [m [k v]] (assoc m k v)) {} (map list ks vs)))","problem":61,"user":"4dfe65a1535d04ed9115e787"},{"code":"(fn [c1 c2]\n  (into {} (map (fn [a b] [a b]) c1 c2)))","problem":61,"user":"506fd0afe4b07bd6ad9b9f23"},{"problem":61,"code":"(fn [coll1 coll2]\n  \"模拟zipmap\"\n  (loop [map {}\n         coll1 coll1\n         coll2 coll2]\n    (if (and (first coll1)\n             (first coll2))\n      (recur (assoc map (first coll1) (first coll2))\n             (next coll1)\n             (next coll2))\n      map)))","user":"5823d3e6e4b051871117beb8"},{"problem":61,"code":"(fn [coll1 coll2] (loop [res {}\n                         c1 coll1\n                         c2 coll2]\n                   (if (or (empty? c1) (empty? c2)) res (recur (assoc res (first c1) (first c2)) (rest c1) (rest c2))\n                     )\n                   ))","user":"60471241e4b02d28681c77c9"},{"code":"(fn my-zipmap [keys, values]\n  (loop [accum {}, keys keys, values values]\n\t\t(if (or (empty? keys) (empty? values))\n\t\t\taccum\n\t\t\t(recur\n\t\t\t\t(conj accum [(first keys) (first values)])\n\t\t\t\t(rest keys)\n\t\t\t\t(rest values)))))","problem":61,"user":"4fb57e06e4b081705acca2bf"},{"problem":61,"code":"(fn f [k v]\n   (loop [k_ k v_ v map {}]\n     (if (or (empty? k_) (empty? v_))\n       map\n       (recur (rest k_) (rest v_)\n              (conj map [(first k_) (first v_)])))))","user":"589f37e0e4b02bd94d917e79"},{"problem":61,"code":"#(loop [m {} k %1 v %2] \n   (if (and k v) \n     (recur (assoc m (first k) (first v)) (next k) (next v)) \n     m))","user":"51febd40e4b0f1313d468a76"},{"code":"(fn zpmp [kys vls]\n  (apply hash-map (interleave kys vls)))","problem":61,"user":"510cd1dde4b078ea71921124"},{"problem":61,"code":"(fn\n   [arg1 arg2]\n   (reduce merge (map #(hash-map %1 %2) arg1 arg2)))","user":"53d6b266e4b0e771c3025459"},{"code":"(fn [& xs] (apply hash-map (apply interleave xs)))","problem":61,"user":"523b1a65e4b02f719975bdbd"},{"problem":61,"code":"(fn [ks vs]\n  (let [pairs (map list ks vs)]\n    (reduce (fn [acc elt] (assoc acc (first elt) (second elt))) \n            {} pairs)))","user":"5553b924e4b0deb715856e06"},{"code":"#(apply hash-map (interleave  %1 %2))","problem":61,"user":"4f03bf5e535dcb61093f6b5d"},{"code":"(fn [ks vs] (apply hash-map (mapcat (fn [k v] [k v]) ks vs)))","problem":61,"user":"4dd59d8b535dae65d5c462eb"},{"code":"(fn [arg1 arg2]\n  (loop [in1 arg1 in2 arg2 out {}]\n    (cond (= () in1) out\n          (= () in2) out\n          :else (recur (rest in1) (rest in2)\n                       (assoc out (first in1) (first in2))))))","problem":61,"user":"51baff1be4b0fe3ecfb46443"},{"problem":61,"code":"(fn [ks vs] (loop [m {} cnt (min (count ks) (count vs))]\n                   (if (zero? cnt)\n                     m\n                     (recur (assoc m (nth ks (- cnt 1)) (nth vs (- cnt 1))) (dec cnt)))))","user":"565233f2e4b0f9d632dd8461"},{"code":"(fn [ks vs]\n  (loop [ks ks vs vs r {}]\n    (if (or (= ks ()) (= vs ()))\n      r\n      (recur (rest ks) (rest vs) (assoc r (first ks) (first vs))))))","problem":61,"user":"50435852e4b034ff00315d22"},{"code":"(fn [lst1 lst2]\n  ((fn [l1 l2 res]\n     (if (or (empty? l1) (empty? l2)) res\n       (recur (rest l1) (rest l2) (assoc res (first l1) (first l2)))))\n   lst1 lst2 {}))","problem":61,"user":"51da631be4b02ceefd947766"},{"problem":61,"code":"(fn [a b]\n  (loop [res {}\n         a a\n         b b]\n    (if (or (empty? a) (empty? b))\n      res\n      (recur\n       (assoc res (first a) (first b))\n       (rest a)\n       (rest b)))))","user":"5a3e1243e4b0447ef91cc5ae"},{"problem":61,"code":"(fn my-zipmap \n  ([seq1 seq2] (my-zipmap seq1 seq2 {}))\n  ([seq1 seq2 the-map]\n    (if (or (empty? seq1) (empty? seq2))\n      the-map\n      (my-zipmap (rest seq1) (rest seq2) (assoc the-map (first seq1) (first seq2))))))","user":"5235493ee4b05e80434a5064"},{"problem":61,"code":"#(loop [ks %1 vs %2 nmap {}]\n   (if (and (seq ks) (seq vs))\n     (recur\n      (rest ks)\n      (rest vs)\n      (assoc nmap (first ks) (first vs)))\n     nmap))","user":"574eb3b1e4b02ea114799247"},{"problem":61,"code":"(fn [s1 s2] (into {} (map (fn [a b] [a b]) s1 s2)))","user":"5ea97df7e4b00a66d4a951c8"},{"problem":61,"code":"(fn zipit\n  [keyz valz]\n  (apply hash-map (interleave keyz valz)))","user":"563f4c47e4b08d4f616f5ed2"},{"problem":61,"code":"(fn mine [[a & resta] [b & restb]]\n  (if (and (seq? resta) (seq? restb))\n    (assoc (mine resta restb) a b)\n  \t{a b}))","user":"5462caf5e4b01be26fd746b7"},{"code":"(fn [ks vs]\r\n    (reduce (fn [m [k v]] (assoc m k v))\r\n            {} (map list ks vs)))","problem":61,"user":"4ddc1c89535d02782fcbea01"},{"problem":61,"code":"(fn [ks vs]\n  (loop [ks ks\n         vs vs\n         i 0\n         out {}]\n    (if (or (empty? ks) (empty? vs))\n      out\n      (recur (rest ks) (rest vs) (inc i) (assoc out (first ks) (first vs))))))","user":"5530b827e4b076ab5578f818"},{"code":"(fn [c1 c2]\n  (into {} (map #(conj [] %1 %2) c1 c2)))","problem":61,"user":"4db045b5838c48654951d9be"},{"problem":61,"code":"(fn [l1 l2]\n  (loop [tmpl1 l1 tmpl2 l2 new {}]\n    (if (or (empty? tmpl1) (empty? tmpl2))\n      new\n      (recur (rest tmpl1) (rest tmpl2) (assoc new (first tmpl1) (first tmpl2))))))","user":"59368ccae4b02506e01a2979"},{"problem":61,"code":"(fn [ks vs] (into {} (map #(conj {%1 %2} {}) ks vs)))","user":"4eb171d7535d7eef30807340"},{"problem":61,"code":"(fn [x y] \n  (loop [a x b y new {}]\n    (if (or (empty? a) (empty? b))\n       new\n      (recur (rest a) (rest b) (assoc new (first a) (first b))))))","user":"5a9482b7e4b0d174b936c737"},{"code":"#(into {} (map (fn[x y] {x y}) %1 %2))","problem":61,"user":"50b25f2ce4b03ea88043355f"},{"code":"(fn [A B]\n  (apply assoc {}\n    (interleave A B)))","problem":61,"user":"5054c853e4b0b1b9d1860eb3"},{"problem":61,"code":"(fn [xs ys]\n    (->>\n      (map-indexed (fn [i y] [(get xs i) y]) ys)\n      (filter\n        #(->> (map nil? %) \n              (map not) \n              (reduce (fn [x y] (and x y)))\n              )\n        )\n      (reduce conj {})\n      )\n    )","user":"5b118b7be4b0cc2b61a3be34"},{"problem":61,"code":"(fn [a b] (reduce #(assoc %1 (first %2) (second %2)) {} (map #(list %1 %2) a b)))","user":"568a743ee4b0dcc4269f408e"},{"code":"(fn [c1 c2]\n(reduce (fn [m [k v]] (assoc m k v)) \n        {} (partition 2 (interleave c1 c2))))","problem":61,"user":"4e95c771535dbda64a6f6b39"},{"problem":61,"code":"(fn [coll1 coll2]\n      (apply merge (map  #(assoc {} %1 %2) coll1 coll2))\n      \t)","user":"604ccb9fe4b0b7ec0ac60ac1"},{"problem":61,"code":"(fn [x y] (reduce conj (map hash-map x y)))","user":"58b84c28e4b0ebc645576d94"},{"code":"(fn my-zipmap [ks vs]\n     (if (or (empty? ks) (empty? vs))\n         {}\n         (assoc (my-zipmap (rest ks) (rest vs)) (first ks) (first vs))))","problem":61,"user":"5186134ce4b0da5a5be3bac7"},{"code":"(fn [c1 c2]\n  (apply assoc {} (interleave c1 c2)))","problem":61,"user":"5007f751e4b0b17c647f522b"},{"code":"(fn zm [a b]\r\n    (loop [m {} a a b b]\r\n      (if (or (empty? a) (empty? b)) m\r\n      (recur (assoc m (first a) (first b)) (rest a) (rest b)))))","problem":61,"user":"4fea08a9e4b0547ebccb2484"},{"code":"(fn [x y] \n  (apply hash-map (interleave x y)))","problem":61,"user":"4e47f4f3535dc968683fc4bb"},{"problem":61,"code":"#(\n    into {} (map vector %1 %2)\n)","user":"54c8eb61e4b045293a27f658"},{"problem":61,"code":"(fn [l1 l2]\n  (apply assoc {} (interleave l1 l2)))","user":"541c1e46e4b01498b1a71a70"},{"problem":61,"code":"(fn map-con [a b]\n  (apply hash-map (interleave a b)))","user":"56874171e4b0dcc4269f405c"},{"problem":61,"code":"(fn m [x y]\n  (if (or (empty? y) (empty? x))\n    {}\n    (merge (m (rest x) (rest y) ) (hash-map (first x) (first y) ) )\n    )\n  )","user":"54078851e4b0addc1aec66bd"},{"problem":61,"code":"(fn problem61 [keys vals]\n  (loop [keyss keys\n         valss vals\n         map {}]\n    (if (and (seq keyss) (seq valss))\n      (recur (rest keyss) (rest valss) (assoc map (first keyss) (first valss)))\n      map)))","user":"54d0cedde4b0e8a36923e5d2"},{"code":"(fn\n  map-construction\n  [vec1 vec2]\n  (reduce\n    merge\n   (map (fn [x y] {x y}) vec1 vec2) \n   )\n  )","problem":61,"user":"5094057fe4b097f48cc38593"},{"problem":61,"code":"(fn [k v]\n  (loop [[fk & rk :as allk] k\n         [fv & rv :as allv] v\n         res {}]\n    (if (or (empty? allk) (empty? allv))\n      res\n      (recur rk rv (conj res [fk fv]))\n      )\n    )\n  )","user":"55f33f0ce4b06e875b46ce59"},{"problem":61,"code":"#( loop[ ks %1 vs %2 res {} ] ( if ( some empty? [ks vs] ) res (recur (rest ks) (rest vs) (conj res { (first ks) (first vs) } ) ) ) )","user":"5b3aa98be4b02d533a91bbca"},{"problem":61,"code":"(fn [cles valeurs] (into (sorted-map)(map #(into [] %) (partition 2 (interleave cles valeurs))))\n)","user":"556f2009e4b09a3098a52519"},{"problem":61,"code":"(fn mc [coll1 coll2]\n  (loop [c1 coll1\n         c2 coll2\n         res {}]\n    (if (or (empty? c1) (empty? c2) ) res\n      (recur (rest c1) (rest c2) (conj res {(first c1) (first c2)})))))","user":"5475d755e4b0c51c1f4d72a0"},{"problem":61,"code":"(fn [& args] (into {} (apply map hash-map args)))","user":"5707abfce4b0b0fb43fd068d"},{"code":"#(apply hash-map (apply concat (map list %1 %2)))","problem":61,"user":"50fc48dde4b0d10d794c19f6"},{"problem":61,"code":"(fn [ks vs] (loop [m {} ks ks vs vs] (if (or (empty? ks) (empty? vs)) m (recur (conj m [(first ks) (first vs)]) (rest ks) (rest vs)))))","user":"54c641f8e4b045293a27f628"},{"problem":61,"code":"(fn [vk vv]\n  (apply hash-map (interleave vk vv)))","user":"5756f7d7e4b02ea1147992e9"},{"problem":61,"code":"#(loop [map {}\n        ks (seq %1)\n        vs (seq %2)]\n   (if (and ks vs)\n     (recur (assoc map (first ks) (first vs)) (next ks) (next vs))\n     map\n   )\n)","user":"5e08c3dde4b0978307768fc8"},{"problem":61,"code":"#(apply hash-map (flatten (map (fn [& args] args) %1 %2)))","user":"56946d43e4b0dcc4269f411e"},{"problem":61,"code":"(fn [lst xLst] (loop [mapp {}\n                      n    0]\n                 (if (or (= n (count lst)) (= n (count xLst)))\n                   mapp\n                   (recur (conj mapp {(nth lst n) (nth xLst n)}) (inc n)))))","user":"607e1d9de4b03d835a6eaedb"},{"problem":61,"code":"(fn z\n  [k v]\n   (if (and (not-empty k) (not-empty v))\n     (merge {(first k) (first v)} (z (rest k) (rest v)))))","user":"56bca51ae4b0f26550335963"},{"problem":61,"code":"(fn\n  [keys values]\n  (loop [res {}\n         keys keys\n         values values]\n    (if (or (empty? keys) (empty? values))\n      res\n      (recur (conj res {(first keys) (first values)}) (rest keys) (rest values)))))","user":"5c706232e4b0fca0c162277e"},{"problem":61,"code":"(fn build-map [keys values]\n  (into {} (map #(vector %1 %2) keys values)))","user":"5776e21de4b0979f89651642"},{"problem":61,"code":"#(reduce (fn [acc [k v]]\n           (assoc acc k v))\n         {}\n         (map list %1 %2))","user":"55a5c3bee4b0acc240e3154e"},{"code":"#(apply merge (map hash-map %1 %2))","problem":61,"user":"4f043ed1535dcb61093f6bb4"},{"code":"(fn zm [keys vals]\n    (loop [map {}\n           ks (seq keys)\n           vs (seq vals)]\n      (println \"ks = \" ks \" vs = \" vs)\n      (if (and ks vs)\n        (recur (assoc map (first ks) (first vs))\n               (next ks)\n               (next vs))\n        map)))","problem":61,"user":"50da34e4e4b0f31830755b3c"},{"problem":61,"code":"(fn jipmep [mep-1 mep-2] (apply merge (map #(hash-map %1 %2) mep-1 mep-2)))","user":"57bbc9bde4b05aa3c4741c31"},{"problem":61,"code":"#_(fn [ks vs]\n  (apply assoc {} (mapcat vector ks vs)))\n(fn [ks vs]\n  (into {} (map vector ks vs)))","user":"5821b018e4b04b46fc4b0f80"},{"problem":61,"code":"(fn zipm [ks vs] (into {} (map #(vector %1 %2) ks vs)))","user":"5b552117e4b02d533a91bd2c"},{"problem":61,"code":"(fn [s1 s2]\n  (loop [new-map {} col1 s1 col2 s2]\n    (if (and (seq col1) (seq col2))\n      (recur\n        (assoc new-map (first col1) (first col2))\n        (rest col1)\n        (rest col2))\n      new-map)))","user":"5ad76df9e4b0ea6055cfac18"},{"problem":61,"code":"(fn [k v] (into {} (map #(vector %1 %2) k v)))","user":"542c22bde4b0dad94371f29e"},{"code":"#(reduce (fn [a v] (assoc a (first v) (second v))) {} (map list % %2))","problem":61,"user":"4fa30027e4b081705acca187"},{"problem":61,"code":"#(loop [c1 %1 c2 %2 result {}]\n    (if (or (empty? c1) (empty? c2))\n      result\n      (recur (rest c1) (rest c2) (assoc result (first c1) (first c2)))))","user":"4f24c859e4b0d66497709fef"},{"problem":61,"code":"(fn zipmap' [keys vals]\n  (loop [map {}\n         ks (seq keys)\n         vs (seq vals)]\n    (if (and ks vs)\n      (recur (assoc map (first ks) (first vs))\n             (next ks)\n             (next vs))\n      map)))","user":"58b18ba0e4b0ebc645576cfa"},{"problem":61,"code":"(fn mmm[v1 v2](loop [v1 v1\n                       v2 v2\n                       ret {}]\n                  (cond\n                    (or (empty? v1) (empty? v2)) ret\n                    :else (recur (rest v1)\n                                 (rest v2)\n                                 (assoc ret (first v1)(first v2))\n                                 ))))","user":"5dadf73ee4b0f8c104ccfc86"},{"problem":61,"code":"(fn\n  [ks vs]\n  (into {} (map vector ks vs)))","user":"5576fee3e4b05c286339e078"},{"code":"(fn [coll1 coll2]\n  (loop [c1 (seq coll1)\n         c2 (seq coll2)\n         result {}]\n    (if (or (empty? c1)\n            (empty? c2))\n      result\n      (recur \n        (next c1)\n        (next c2)\n        (assoc result (first c1) (first c2))))))","problem":61,"user":"52c672e2e4b0c2d177d6210e"},{"problem":61,"code":"(fn mapc [coll1 coll2] (into {} (map vector coll1 coll2)))","user":"5b421edce4b02d533a91bc2c"},{"code":"(fn zmap \n  ([v1 v2] (zmap v1 v2 {}))\n  ([v1 v2 m]\n  \t(if (or (empty? v1) (empty? v2))\n      m\n      (zmap (rest v1) (rest v2) (assoc m (first v1) (first v2))))))","problem":61,"user":"51d96ad0e4b02ceefd94774f"},{"code":"(fn [ks vs]\n  (into {} (map vector ks vs)))","problem":61,"user":"4e68c434535d8ccf87e9fe89"},{"problem":61,"code":"(fn my-zipmap [s1 s2]\n  (apply merge (map (fn [k v] {k v}) s1 s2)))","user":"550c55d0e4b06e50f9beb14d"},{"problem":61,"code":"(fn my-zip\n  [coll coll']\n  (let [xs (map vector coll coll')]\n    (reduce #(assoc %1 (first %2) (second %2)) {} xs)))","user":"59a512b7e4b066c664927d5e"},{"problem":61,"code":"(fn my-zipmap\n  [coll1 coll2]\n  (loop [coll1 coll1\n         coll2 coll2\n         res {}]\n\t(cond\n     (or (empty? coll1) (empty? coll2)) res\n     :else (recur (rest coll1) (rest coll2) (assoc res (first coll1) (first coll2))))))","user":"5cf938a5e4b0b71b1d808a90"},{"problem":61,"code":"(fn [vs ks]\n  (reduce \n   #(assoc-in %1 (list (first %2)) (second %2)) \n   {} \n   (partition 2 (interleave vs ks))))","user":"57af41bce4b0fbc9809a2731"},{"problem":61,"code":"(fn [keys vals]\n  (loop [rkeys keys\n         rvals vals\n         result {}]\n    (let [k (first rkeys)\n          v (first rvals)]\n      (if (or (nil? k)\n              (nil? v))\n        result\n        (recur (rest rkeys)\n               (rest rvals)\n               (assoc result k v))))))","user":"5bef3e88e4b0a6d31fed213f"},{"problem":61,"code":"(fn [ks vs]\n  (reduce #(assoc %1 (first %2) (second %2)) {} (partition 2 (interleave ks vs))))","user":"54c8d4a8e4b045293a27f654"},{"problem":61,"code":"(fn [x y] (into {} (mapv (fn [& xs] (into [] xs)) x y)))","user":"5d84545ee4b0915913b1d38b"},{"code":"(fn [keys vals]\n  (loop [ret {} k keys v vals]\n    (if (and (first k) (first v))\n      (recur (assoc ret (first k) (first v)) (rest k) (rest v))\n      ret)))","problem":61,"user":"4f0660ee535dcb61093f6c0d"},{"problem":61,"code":"(comp\n     (partial into (hash-map))\n     (partial map vector))","user":"50a3ad0ee4b0ceace084d493"},{"problem":61,"code":"(fn [fields values] (into {} (map vector fields values)))","user":"54b6c24be4b0ed20f4ff6e7c"},{"problem":61,"code":"(fn [keys vals]\n  (loop [m {}\n         ks keys\n         vs vals]\n    (if (and ks vs)\n      (recur (assoc m (first ks) (first vs))\n             (next ks)\n             (next vs))\n      m)))","user":"55f5b8d6e4b06e875b46ce8d"},{"code":"#(into {} (map (partial apply vector) (partition 2 (interleave %1 %2))))","problem":61,"user":"50b1d166e4b03ea880433554"},{"code":"(fn [x y]\n  (loop [x x y y z {}]\n    (if (or (empty? x) (empty? y))\n      z\n      (recur (rest x)\n             (rest y)\n             (assoc z (first x) (first y))))))","problem":61,"user":"4fed24a5e4b0681fd128dcaf"},{"problem":61,"code":"(fn myzipmap\n  [[k & ks] [v & vs]]\n  (if (or (nil? k) (nil? v))\n          {} \n          (merge {k v} (myzipmap ks vs))))","user":"5e20a159e4b05b4b01516118"},{"code":"(fn [k v] \n  (loop [keys k, vals v, ret {}]\n    (if (or (empty? keys) (empty? vals)) \n      ret\n      (recur (rest keys) (rest vals) (assoc ret (first keys) (first vals)))\n)))","problem":61,"user":"4f2965ffe4b0d6649770a029"},{"code":"#(apply conj {} (map vec (partition 2 (interleave % %2))))","problem":61,"user":"4e399685535deb9a81d77f40"},{"code":"(fn [c1 c2] (into {} (map #(vector %1 %2) c1 c2)))","problem":61,"user":"533ee560e4b085b17e897d98"},{"code":"(fn f [k v]\n  (if (or (empty? v)(empty? k))\n    {}\n    (merge {(first k) (first v)} (f (rest k) (rest v)))\n  )\n)","problem":61,"user":"5349ac2be4b084c2834f4a67"},{"code":"(fn mapConstruction [a b] (loop [x a y b z (hash-map)] (if (or (empty? x) (empty? y)) z \n(recur (rest x) (rest y) (conj z [(first x) (first y)])))))","problem":61,"user":"4f9336ece4b0dcca54ed6cb7"},{"code":"(fn ! [x y]\n  (if (or (empty? x) (empty? y))\n    {}\n    (apply merge \n           {(first x) (first y)}\n           (! (rest x) (rest y))\n           )\n   ))","problem":61,"user":"52faec2ee4b047fd55837004"},{"problem":61,"code":"#(loop [k %1 v %2 out {}] (if (or (empty? k) (empty? v)) out (recur (rest k) (rest v) (into out {(first k) (first v)}))))","user":"57f9e0bce4b0d3187e900956"},{"problem":61,"code":"(fn my-zipmap [keys vals]\n  (letfn [(build-zip [maps keys vals]\n            (if (or (empty? keys) (empty? vals))\n              maps\n              (build-zip\n                (assoc maps (first keys) (first vals))\n                (rest keys)\n                (rest vals))))]\n    (build-zip {} keys vals)))","user":"5b107263e4b0cc2b61a3be22"},{"code":"#(into '{} \n       (for [[a b] (->> (interleave %1 %2) (partition 2))]\n    \t\t[a b]))","problem":61,"user":"530cb5b8e4b02e82168697e0"},{"problem":61,"code":"#(apply array-map (mapcat list %1 %2))","user":"5eeb03dde4b029a2061bbeca"},{"code":"(fn zip \n  ([xs ys] (zip xs ys {}))\n  ([xs ys accum]\n  (if (and (seq xs) (seq ys))\n    (zip (rest xs) (rest ys) (assoc accum (first xs) (first ys)))\n\taccum)))","problem":61,"user":"524740e7e4b05ef8e38e635d"},{"code":"#(loop [m {} v [%1 %2] ] \n   (if (or (-> v first empty?) (-> v second empty?)) m\n      (recur (assoc m (-> v first first) (-> v second first)) (vector (-> v first rest) (-> v second rest) ))))","problem":61,"user":"4fff289ae4b0678c553fc3fd"},{"problem":61,"code":"#(-> (fn [ass x] (assoc ass (first x) (second x)))\n    (reduce {}  (map list %1 %2)))","user":"5be79b5be4b0f319e2d7ec5a"},{"problem":61,"code":"(fn\n  [k, v]\n  (into {} (map #(vector %1 %2) k v)))","user":"5dd25ca8e4b0948ae9d9ad55"},{"problem":61,"code":"(fn f [ks vs]\n  (apply conj {} (map #(vector %1 %2) ks vs)))","user":"549c6792e4b0f3d1d8e70f8b"},{"problem":61,"code":"#(apply merge (map (fn [x y] {x y}) %1 %2 ))","user":"5b0b8d29e4b0cc2b61a3bdd7"},{"problem":61,"code":"(fn [ks vs]\n  (loop [m {}\n         kk (seq ks)\n         vv (seq vs)]\n    (if (and (first kk) (first vv))\n      (recur (assoc m (first kk) (first vv))\n             (next kk)\n             (next vv))\n      m))\n  )","user":"57bfffc7e4b05aa3c4741c8a"},{"code":"(fn [l0 l1]\n  (apply array-map  (interleave l0 l1)))","problem":61,"user":"4df9c598535d04ed9115e77a"},{"problem":61,"code":"(fn [keys vals] \n  (loop [map {}\n         ks (seq keys)\n         vs (seq vals)]\n    (if (and ks vs)\n      (recur (assoc map (first ks) (first vs))\n             (next ks)\n             (next vs))\n      map)))","user":"53791ab7e4b06839e8705e4d"},{"code":"(fn [l1 l2]\n    (loop [l1 l1\n           l2 l2\n           res []]\n      (if (or (empty? l1) (empty? l2))\n        (apply hash-map res)\n        (recur (rest l1) (rest l2) (conj res (first l1) (first l2))))))","problem":61,"user":"515ef58be4b02c55805ea237"},{"code":"(fn construct \n  ([keys values] (construct keys values (hash-map)))\n  ([keys values sofar]\n    (let [key (first keys)\n          value (first values)]\n      (if (or (empty? keys) (empty? values))\n        sofar\n        (construct (rest keys) (rest values) (assoc sofar key value))))))","problem":61,"user":"4e84f77c535db62dc21a62e5"},{"problem":61,"code":"(fn robins-zip [v1 v2]\n  (let [zip (fn [m v1 v2]\n              (if (or (empty? v1) (empty? v2))\n                m\n                (recur (assoc m (first v1) (first v2)) (rest v1) (rest v2))))]\n    (zip {} v1 v2)))","user":"55bb1b26e4b01b9910ae29e0"},{"problem":61,"code":"(fn [keys vals] (loop [res {} rk keys rv vals]\n                  (let [k (first rk) v (first rv)]\n                    (if (or (nil? k) (nil? v))\n                      res\n                      (recur (conj res {k v}) (rest rk) (rest rv))))))","user":"58225587e4b04b46fc4b0f94"},{"problem":61,"code":"#(reduce (fn [acc [key val]] (assoc acc key val)) {} (map vector %1 %2))","user":"53c6c9dfe4b00fb29b2212a1"},{"problem":61,"code":"(fn [ks vs] (into {} (map #(hash-map %1 %2) ks vs)))","user":"58b51e05e4b0ebc645576d4c"},{"problem":61,"code":"#(reduce (fn [m [key value]] (assoc m key value)) {} (partition 2 (interleave %1 %2)))","user":"59473563e4b07ddc2dafad97"},{"problem":61,"code":"(fn [a b]\n  (apply sorted-map (interleave a b)))","user":"555f0789e4b0a2eb076a39bf"},{"problem":61,"code":"#(apply assoc {} (reverse(interleave %2  %1)))","user":"54f4a457e4b0f2f3c5226e83"},{"code":"(fn [ks vs]\n  (reduce #(assoc %1 (%2 0) (%2 1)) {} (map vector ks vs)))","problem":61,"user":"5370f8ede4b0fc7073fd6ea2"},{"code":"(fn [a b]\n  (apply hash-map (interleave a b)))","problem":61,"user":"4f410b63e4b0e243712b1fc5"},{"code":"#(loop [acc {}, keys %1, vals %2]\n  (cond\n    (empty? keys) acc\n    (empty? vals) acc\n    :else (recur (conj acc [(first keys) (first vals)])\n                 (rest keys)\n                 (rest vals))))","problem":61,"user":"4e6a2f93535d8ccf87e9feaa"},{"problem":61,"code":"#( into {} (map vector %1 %2))","user":"57822efce4b0d36ec5835e91"},{"problem":61,"code":"(fn [coll1 coll2]\n  (into (sorted-map) (map vector coll1 coll2)))","user":"5f081f6de4b0cf489e8d7f5a"},{"code":"(fn [ks-in vs-in]\n  (loop [result {} ks ks-in vs vs-in]\n    (if (or (nil? ks) (nil? vs))\n      result\n      (recur (assoc result (first ks) (first vs)) (next ks) (next vs))\n    )\n  )\n)","problem":61,"user":"526dd90de4b03e8d9a4a72fe"},{"code":"#(apply (partial assoc {}) (interleave %1 %2))","problem":61,"user":"4f42ae16e4b0d7d3c9f3fd09"},{"problem":61,"code":"(fn [a b] ((fn [a b r] (if (or (empty? a) (empty? b)) r (let [k (first a) v (first b)] (recur (rest a) (rest b) (assoc r k v))))) a b {}))","user":"55041b5ee4b086ebe8a79c78"},{"problem":61,"code":"(fn [[& ks] [& vs]] (into {} (map vector ks vs)) )","user":"54febf4be4b07d26eda61d45"},{"problem":61,"code":"(fn\n  [keys vals]\n  (loop [[k & ks] keys [v & vs] vals acc {}]\n    (if (and k v)\n      (recur ks vs (assoc acc k v))\n      acc\n      )\n    )\n  )","user":"56edf2dde4b04a395b9a044b"},{"problem":61,"code":"(fn [coll1 coll2]\n    (reduce #(conj %1 %2) {}\n          (map #(vector %1 %2) coll1 coll2)))","user":"5defc177e4b093ff717275af"},{"problem":61,"code":"(fn [k v] (reduce into {} (map #(assoc {} %1 %2) k v)))","user":"5a75da49e4b0512ff01cdacf"},{"problem":61,"code":"(fn zmap[k v]\n  (apply sorted-map (interleave k v)))","user":"54b10d08e4b09f271ff37d18"},{"problem":61,"code":"(fn\n  [keyss values]\n  (apply hash-map (interleave keyss values)))","user":"56df636ae4b0ca2494a095f4"},{"problem":61,"code":"#(apply merge (map sorted-map %1 %2))","user":"569ad037e4b0542e1f8d144f"},{"problem":61,"code":"(fn [ks vs]\n         (let [max (if (> (count ks) (count vs)) (count vs) (count ks))]\n           (into {} (map (fn [i]\n                           {(nth ks i) (nth vs i)})\n                         (range max)))))","user":"5251b11be4b0541d1855b87b"},{"problem":61,"code":"(fn zipper [left right]\n      (reduce\n        #(assoc %1 (first %2) (second %2))\n        {}\n        (map #(clojure.lang.MapEntry. %1 %2) left right))\n      )","user":"5c6e8b57e4b0fca0c1622755"},{"problem":61,"code":"(fn customZipmap\n  [v1 v2]\n  (loop [res {} keys (seq v1) values (seq v2)]\n    (if (and keys values)\n      (recur\n        (assoc res (first keys) (first values))\n        (next keys)\n        (next values)\n        )\n       res\n      )\n    )\n  )","user":"5c20b6abe4b07e362c230576"},{"problem":61,"code":"(fn createMap\n  [k v]\n  (loop [keys k\n         values v\n         result {}]\n    (if (or (nil? (first keys)) (nil? (first values)))\n      result\n      (recur (rest keys) (rest values) (assoc result (first keys) (first values))))))","user":"5e9636fee4b0fbed045a3816"},{"problem":61,"code":"(fn [ks vs] \n  (into {} \n        (map vector ks vs)))","user":"55469eede4b0a04f79299542"},{"problem":61,"code":"(fn test16 [coll1 coll2]\n  (into {} (map #(vector %1 %2) coll1 coll2)))","user":"5804d5afe4b0a837a8b30cad"},{"code":"(fn [ks vs] \n  (loop [ks ks\n         vs vs\n         accum {}]\n    (if (or (empty? ks) (empty? vs))\n      accum\n      (recur (rest ks) (rest vs) (conj accum [(first ks) (first vs)])))))","problem":61,"user":"4ef41f26535dced4c769f230"},{"code":"(fn [k v]\n  (loop [m {} ks k vs v]\n    (if (or (empty? ks) (empty? vs)) m\n      (recur (merge m {(first ks) (first vs)}) (rest ks) (rest vs)))))","problem":61,"user":"52199105e4b0c4ef0be82ff9"},{"problem":61,"code":"(fn [ks vs]\n    (apply hash-map (interleave ks vs)))","user":"5777cffae4b0979f89651651"},{"problem":61,"code":"(fn map-const [k v] (apply hash-map (interleave k v)))","user":"553b90c8e4b09218d5f45005"},{"code":"#(loop [input-keys %1 input-values %2 ans {}]\n  (if (or (empty? input-keys) (empty? input-values))\n    ans\n    (recur (rest input-keys) (rest input-values) (assoc ans (first input-keys) (first input-values)))\n  )\n)","problem":61,"user":"51f09f3de4b0274c496158d7"},{"problem":61,"code":"(fn [keys vals]\n   (into {} (map #(vector %1 %2) keys vals)))","user":"55b54ecbe4b01b9910ae2987"},{"problem":61,"code":"(fn f\n   ([x y] (f x y {}))\n   ([[x & xs] [y & ys] acc]\n    (prn x y)\n    (if (or (empty? xs) (empty? ys))\n      (assoc acc x y)\n      (recur xs ys (assoc acc x y)))))","user":"5be0306be4b0ed4b8aab4c7d"},{"problem":61,"code":"#(apply hash-map (->> (map vector %1 %2) flatten))","user":"54857657e4b0e286459a11ac"},{"code":"(fn [col1 col2]\n(into {} (map #(vector % %2) col1 col2))\n\n   )","problem":61,"user":"50550f43e4b0b1b9d1860eb7"},{"problem":61,"code":"(fn construct-map\n  [x y]\n  (apply merge (map #(assoc {} %1 %2) x y)))","user":"563fc1f2e4b08d4f616f5ed7"},{"code":"(fn p61 [k v]\n  (apply hash-map (interleave k v))\n  )","problem":61,"user":"51750fc5e4b07031762f2ee6"},{"code":"(fn map [v1 v2] \n  (apply array-map (vec (mapcat #(list %1 %2) v1 v2)))\n)","problem":61,"user":"4f84400de4b033992c121c2e"},{"problem":61,"code":"(fn [x y] (apply assoc {}\n                  (interleave x y)))","user":"5f082d9ee4b0cf489e8d7f5c"},{"problem":61,"code":"(fn [k v] (reduce conj (map (fn [i] {(nth k i) (nth v i)}) (range (min (count k) (count v))))))","user":"5b465b8be4b02d533a91bc65"},{"problem":61,"code":"(fn eh [x y]\n  ((fn ehh [x y acc]\n     (cond\n      (or (empty? y) (empty? x)) acc\n      :else (ehh (rest x) (rest y) (assoc acc (first x) (first y))))) x y {}))","user":"549c8bbde4b0f3d1d8e70f8c"},{"code":"(fn [ks vs] (reduce (fn [a [k v]] (assoc a k v)) {} (map vector ks vs)))","problem":61,"user":"530bf87ee4b02e82168697d5"},{"problem":61,"code":"(fn map-construction\n  ; \"function which takes a vector of keys and a vector of valuesand constructs a map of them\"\n  [x1 x2]\n  (apply hash-map (interleave x1 x2)))","user":"5bbbd077e4b0a20761a23615"},{"code":"(fn [x y] (apply assoc {} (interleave x y)))","problem":61,"user":"505c6432e4b032b709c81378"},{"code":"(fn [arg-keys arg-vals]\n  (reduce \n    (fn [hsh [k v]] (assoc hsh k v)) \n    {} \n    (map list arg-keys arg-vals)))","problem":61,"user":"4e2f9e71535deb9a81d77f11"},{"problem":61,"code":"(fn [vec1 vec2]\n  (apply merge (map hash-map vec1 vec2)))","user":"5456e4e7e4b080a794c2c883"},{"problem":61,"code":"#(reduce merge (map sorted-map %1 %2))","user":"55f6c0e2e4b06e875b46ce99"},{"problem":61,"code":"(fn ! [k v]\n  (if (or (empty? k) (empty? v)) {}\n   \t(assoc (! (rest k) (rest v)) (first k) (first v))\n    )\n  )","user":"54c271b9e4b045293a27f602"},{"problem":61,"code":"(fn my-zipmap [keys vals]\n  (let [f (fn f [acc ks vs]\n            (if (or (empty? ks) (empty? vs))\n              acc\n              (f (assoc acc (first ks) (first vs)) (rest ks) (rest vs))))]\n    (f {} keys vals)))","user":"53e27bf1e4b036ad0777e3f2"},{"problem":61,"code":"#(apply assoc {} (flatten (map list %1 %2)))","user":"56c560ede4b05cc29241eea6"},{"code":"#(->> (interleave % %2) (apply hash-map))","problem":61,"user":"50657775e4b0deb876850599"},{"code":"(fn\n  [c1 c2]\n  (into {} (map #(assoc {} %1 %2) c1 c2)))","problem":61,"user":"525fffb8e4b03e8d9a4a702b"},{"problem":61,"code":"(fn [coll1 coll2]\n  (loop [i 0 result {}]\n    (if (or (= i (count coll1)) (= i (count coll2)))\n      result\n      (recur (inc i) (assoc result (get coll1 i) (get coll2 i))))))","user":"5d03944de4b0cc9c915881c5"},{"problem":61,"code":"(fn [a b]\n  (apply merge(map #(apply assoc {} (list %1 %2)) a b)))","user":"5822b578e4b04b46fc4b0fa4"},{"problem":61,"code":"(fn f [[a & as] [b & bs]]\n  (if (or (empty? as) (empty? bs))\n    {a b}\n    (into {a b} (f as bs))))","user":"56483562e4b0284900eef629"},{"problem":61,"code":"(fn [keys vals]\n  [keys vals]\n  (loop [map {}\n         ks (seq keys)\n         vs (seq vals)]\n    (if (and ks vs)\n      (recur (assoc map (first ks) (first vs))\n             (next ks)\n             (next vs))\n      map)))","user":"57e79d8ee4b0bfb2137f5afe"},{"problem":61,"code":"(fn make-a-map [keys vals]\n   (apply hash-map (interleave keys vals)))","user":"562eeba2e4b0ab312c17ebc1"},{"problem":61,"code":"(fn [c1 c2] (reduce #(conj %1 %2) {} (map #(identity [%1 %2]) c1 c2)))","user":"5d247902e4b02ea6f0fb6a24"},{"code":"#(apply (partial conj {}) (map vector %1 %2))","problem":61,"user":"507fbd77e4b089ade05efbd3"},{"code":"(fn [arg1 arg2] (apply assoc {} (interleave arg1 arg2)))","problem":61,"user":"52a5d1f3e4b0c58976d9abf1"},{"code":"(fn [key-seq val-seq]\n  (loop [k key-seq v val-seq result {}]\n    (cond\n      (empty? k) result\n      (empty? v) result\n      :else\n        (recur\n          (rest k)\n          (rest v)\n          (assoc result (first k) (first v))))))","problem":61,"user":"4e117dea535d04ed9115e7c9"},{"problem":61,"code":"(fn [k v]\n    (loop [keys k\n           vals v\n           res {}]\n      (if (or (empty? keys) (empty? vals)) res\n          (recur (rest keys) (rest vals) (assoc res (first keys) (first vals))))))","user":"57aa290de4b0b8559636fc65"},{"problem":61,"code":"(fn my\n  [n x]\n  (apply hash-map (interleave n x)))","user":"5ea3711ae4b00a66d4a9519d"},{"problem":61,"code":"(fn [k v] (reduce (fn [m [k v]] (assoc m k v)) {} (map vector k v)))","user":"5cb0f70ce4b026601754b8c1"},{"code":"(fn mapping[x y]\n   (if (or (empty? x) (empty? y))\n     {}\n     (conj (mapping (rest x) (rest y)) {(first x) (first y)})\n            ))","problem":61,"user":"525cc912e4b0cb4875a45d48"},{"problem":61,"code":"(fn[keys vals]\n        (loop [map {}\n               ks (seq keys)\n               vs (seq vals)]\n          (if (and ks vs)\n            (recur (assoc map (first ks) (first vs))\n                   (next ks)\n                   (next vs))\n            map)))","user":"57e6f90de4b0bfb2137f5af6"},{"code":"(fn [x y]\n  (apply assoc {} (interleave x y))\n)","problem":61,"user":"4eeb8f68535d93acb0a668a9"},{"code":"(fn f [xs ys]\n  (if (and (seq xs) (seq ys))\n    (assoc (f (rest xs) (rest ys)) (first xs) (first ys))\n    {}))","problem":61,"user":"536102efe4b0243289761e3e"},{"problem":61,"code":"(fn zipmap* [coll1 coll2]\n  (into {} (map (fn [a b] [a b]) coll1 coll2)))","user":"5f38eecce4b0574c87022c72"},{"code":"#(into {}  (map vector % %2))","problem":61,"user":"50cae881e4b0f75dcc9a6e51"},{"problem":61,"code":"(fn zipmap- [keys vals]\n  (loop [m {}\n         ks (seq keys)\n         vs (seq vals)]\n    (if (and ks vs)\n      (recur (assoc m (first ks) (first vs))\n             (next ks)\n             (next vs))\n      m)))","user":"565654dae4b0f9d632dd849f"},{"problem":61,"code":"(fn [keys vals] (loop [my-map {} my-keys (seq keys) my-vals (seq vals)] (if (and my-keys my-vals) (recur (assoc my-map (first my-keys) (first my-vals)) (next my-keys) (next my-vals)) my-map)))","user":"56347285e4b0bfe05bf117bc"},{"problem":61,"code":"(fn [v1 v2]\n  (loop [m {}\n         v1 v1\n         v2 v2]\n    (if (or (empty? v1) (empty? v2))\n      m\n      (recur (conj m [(first v1) (first v2)]) (rest v1) (rest v2)))))","user":"545944a2e4b01be26fd74627"},{"problem":61,"code":"(fn [a b] (apply conj (map #(hash-map %1 %2) a b)))","user":"56979bb7e4b0e0b3d3318cac"},{"problem":61,"code":"(fn [ks vs]\n  (loop [res {}\n         keys ks\n         vals vs]\n    (if (or (empty? keys) (empty? vals))\n      res\n      (recur (assoc res (first keys) (first vals))\n             (rest keys)\n             (rest vals))\n    )\n  )\n)","user":"554756b8e4b0a04f79299549"},{"problem":61,"code":"(fn [c1 c2]( into {} (map (fn [x y](vector x y)) c1 c2)) )","user":"5d8aad1ce4b0915913b1d3cd"},{"problem":61,"code":"(fn my_zip\n\t([ks vs]\n\t\t(my_zip ks vs {}))\n\t([ks vs result]\n\t\t(if (or (empty? ks) (empty? vs))\n\t\t\tresult\n\t\t\t(recur (rest ks) (rest vs) (conj result (assoc {} (first ks) (first vs)))))))","user":"5954eef0e4b066ee0a44af17"},{"problem":61,"code":"(fn [lk lv]\n  (apply merge (for [n (range (min (count lk) (count lv)))] (hash-map (nth lk n) (nth lv n)))))","user":"54651faee4b01be26fd746d6"},{"code":"(fn [k v] (apply merge (map #(hash-map %1 %2) k v)))","problem":61,"user":"527c040be4b03e8d9a4a75a7"},{"problem":61,"code":"(fn [a b]\n  (apply merge\n   (map hash-map a b)))","user":"58ef93ece4b056aecfd47dca"},{"code":"#(apply hash-map (flatten (interleave % %2)))","problem":61,"user":"4db016af838c48654951d9b9"},{"code":"#(loop [k %1\n        v %2\n        coll (hash-map)]\n   (if (and (seq k) (seq v))\n       (recur (rest k) (rest v) (assoc coll (first k) (first v)))\n     coll))","problem":61,"user":"51ab1da1e4b04e3dc0c27b30"},{"problem":61,"code":"#(loop [seq1 % seq2 %2 res {}] (if (or (= 0 (count seq1)) (= 0 (count seq2))) res\n                                 (recur (rest seq1) (rest seq2) (conj  res {(first seq1) (first seq2)}))))","user":"594a7ed1e4b07ddc2dafae02"},{"problem":61,"code":"(fn [ks vs]\n  (loop [acc (hash-map) k ks v vs]\n   (if (or \n           (empty? k)\n           (empty? v))\n     acc\n     (recur (conj acc [(first k) (first v)]) (rest k) (rest v)))))","user":"54487527e4b032a45b8693cc"},{"problem":61,"code":"(fn [ks vs]\n  (->> (interleave ks vs)\n       (partition 2)\n       (map vec)\n       (into {})))","user":"5b96800ae4b0c0b3ffbd4a7b"},{"problem":61,"code":"(fn [ks vs]\n  (into {}\n        (map hash-map ks vs)))","user":"4ee897fe535d93acb0a66883"},{"code":"(fn [m-keys m-values]\n  (reduce\n   #(assoc %1 (first %2) (second %2))\n   {}\n   (map list m-keys m-values)))","problem":61,"user":"53527551e4b084c2834f4af0"},{"code":"#(loop [curr-keys %1\n        curr-vals %2\n        pairs []]\n   (if-not (and (seq curr-keys)\n                (seq curr-vals))\n     (apply hash-map pairs)\n     (recur (rest curr-keys)\n            (rest curr-vals)\n            (conj pairs (first curr-keys) \n                        (first curr-vals)))))","problem":61,"user":"531c7f0de4b08068f379eda4"},{"code":"(fn [k v]\n  (loop [i 0 m {}]\n    (if (= i (min (count k) (count v)))\n      m\n      (recur (inc i) (conj m [(nth k i) (nth v i)])))))","problem":61,"user":"5341b141e4b00652c8746ecf"},{"code":"(fn [ks vs] (apply hash-map (flatten (map list ks vs))))","problem":61,"user":"52d3f666e4b09f7907dd1327"},{"code":"(fn zipup [a b]\n  (when (and (seq a) (seq b))\n      (assoc (zipup (rest a) (rest b)) (first a) (first b))))","problem":61,"user":"52af7a5ce4b0c58976d9acbd"},{"code":"#(into {} (map (fn [x y] [x y]) %1 %2))","problem":61,"user":"518644bce4b0da5a5be3baca"},{"problem":61,"code":"(fn [keys vals] \n  (into {} (map #(vector %1 %2) keys vals)))","user":"550615c0e4b021ccfedb9696"},{"problem":61,"code":"(fn map-zipper [kwrds vls]\n  (into {} (map #(vector %1 %2) kwrds vls)) )","user":"59fa0bb6e4b0ca45a743a352"},{"code":"#(reduce merge {} (map hash-map % %2))","problem":61,"user":"4e5af45e535d8a8b8723a2b1"},{"code":"(fn [lst1 lst2]                                                     \n            (let [ lst (map #(list % %2) lst1 lst2) ]                           \n                 (loop [ mp {} res lst ]                                        \n                    (if (empty? res) mp                                         \n                        (recur (into mp { (first (first res))                   \n                                          (second (first res)) })               \n                               (rest res))))))","problem":61,"user":"4eed6b32535d93acb0a668bc"},{"code":"(fn [c d]\n  (loop [ret {} c c d d]\n    (cond\n     (= '() c) ret\n     (= '() d) ret\n     :else \n     (recur (conj ret [(first c) (first d)]) \n            (rest c) (rest d)))))","problem":61,"user":"50bfe725e4b080409b860f26"},{"code":"(fn [ks vs]\n  (apply hash-map\n    (flatten\n      (map #(vector %1 %2) ks vs))))","problem":61,"user":"4ee3afde535d10e5ff6f5370"},{"problem":61,"code":"#(loop [mp {} ks %1 vs %2]\n   (if (or (empty? ks) (empty? vs))\n     mp\n     (recur (assoc mp (first ks) (first vs)) (rest ks) (rest vs))\n  )\n)","user":"5e947a69e4b0fbed045a37f8"},{"problem":61,"code":"(fn [a b]\n  (let [t (min (count a) (count b))] (reduce #(if (< (count %1) t) (assoc %1 %2 (get b (count %1))) %1) {} a)))","user":"52cda980e4b07d0d72b2737b"},{"problem":61,"code":"(fn my-mapp\n  [n x]\n  (apply hash-map (interleave n x)))","user":"5e95013fe4b0fbed045a3800"},{"problem":61,"code":"#(into {} (concat (map vector %1 %2)))","user":"55af7e21e4b03311e7b732cc"},{"problem":61,"code":"(fn [vec-keys vec-vals]\n  (apply hash-map (interleave vec-keys vec-vals)))","user":"5d48e6d3e4b0776584bd6f15"},{"problem":61,"code":"(fn map-construction [ks vs]\n  (->> (map vector ks vs)\n       (into {})))","user":"60c0ceb7e4b0e0fa5f1b42a6"},{"code":"(fn zm [k v]\n  (when (and k v)\n    (assoc (zm (next k) (next v)) (first k) (first v))))","problem":61,"user":"5336a339e4b0e30313ee6c7d"},{"problem":61,"code":"(fn map-construction\n  [v1 v2]\n  (into {} (map #(vector %1 %2) v1 v2)))","user":"52561295e4b0541d1855ba03"},{"problem":61,"code":"(fn [ar1 ar2] (apply assoc {} (interleave ar1 ar2)))","user":"573b664ce4b0cd1946bd10a7"},{"problem":61,"code":"(fn [xs ys]\n(apply hash-map (mapcat vector xs ys)))","user":"55aa8276e4b0988bba2ad94e"},{"code":"(fn [keys vals] \n   (loop [map {}\n           ks (seq keys)\n           vs (seq vals)]\n      (if (and ks vs)\n        (recur (assoc map (first ks) (first vs))\n               (next ks)\n               (next vs))\n        map)))","problem":61,"user":"5348236ee4b084c2834f4a54"},{"problem":61,"code":"(fn f [v1 v2]\n  (cond \n    (or (empty? v1) (empty? v2)) {}\n    (= 1 (count v1)) {(first v1) (first v2)}\n    :else (conj {(first v1) (first v2)} (f (rest v1) (rest v2)))))","user":"5e12327ee4b099d064962fe5"},{"problem":61,"code":"#(apply merge (seq (map hash-map %1 %2)))","user":"573940e3e4b0cd1946bd106b"},{"problem":61,"code":"(fn\n  [k v]\n  (reduce\n   conj\n   (map hash-map k v)))","user":"586a657de4b0f14aab7c88bd"},{"problem":61,"code":"(fn [c1 c2]\n  (loop [ret {} c1 c1 c2 c2]\n    (if (or (nil? (first c1)) (nil? (first c2)))\n      ret\n      (recur (assoc ret (first c1) (first c2)) (rest c1) (rest c2)))))","user":"5971a017e4b01722bebd4c75"},{"problem":61,"code":"(fn [ks vs] (into {} (for [i (range 0 (min (count ks) (count vs)))] [(get ks i) (get vs i)])))","user":"56449e4de4b0284900eef5f9"},{"problem":61,"code":"(fn mp [key-seq val-seq]\n    (apply hash-map (interleave key-seq val-seq)))","user":"54f09599e4b024c67c0cf89d"},{"problem":61,"code":"(fn [keys values]\n  (loop [K keys V values M {}]\n    (if (or (empty? K) (empty? V))\n      M\n      (recur (rest K) (rest V) (assoc M (first K) (first V)))\n      )\n    )\n  )","user":"552d9013e4b076ab5578f7ea"},{"code":"(fn [la lb]\n  (reduce conj (map hash-map la lb)))","problem":61,"user":"50b668dde4b08fb537db98f2"},{"problem":61,"code":"(fn [ks vals]\n  (apply hash-map (interleave ks vals)))","user":"5b99554ae4b0c0b3ffbd4ace"},{"problem":61,"code":"(fn mm [key val]\n  (apply merge (map #(assoc nil %1 %2) key val)))","user":"535f0cbde4b04ce2eb3ed2d9"},{"problem":61,"code":"(fn create-map [keys values]\n  (apply hash-map (interleave keys values))\n  )","user":"595fe942e4b066ee0a44b075"},{"code":"(fn mg\n  ([ks vs] (mg ks vs {}))\n  ([ks vs mp]\n  (if (or (empty? ks) (empty? vs))\n    mp\n    (mg (rest ks) (rest vs) (merge mp {(first ks) (first vs)})))))","problem":61,"user":"50970f51e4b00ad8bab4e950"},{"problem":61,"code":"#(loop [col1 %1 col2 %2 cnt (min (count col1) (count col2)) rt {}]\n   (if(<= cnt 0)\n     rt\n     (recur (rest col1) (rest col2) (dec cnt) (assoc rt (first col1) (first col2)))\n     )\n  \n  )","user":"5d270111e4b092dab7f59c62"},{"problem":61,"code":"(fn [ks vs]\n  (let [lastIndex (- (min (count ks) (count vs)) 1)]\n    (loop [n 0\n           result {}]\n      (if (> n lastIndex)\n        result\n        (recur (+ n 1) (assoc result (get ks n) (get vs n)))))))","user":"55d4dddde4b0e31453f64a7f"},{"code":"(fn [k v]\n  (reduce merge {}\n    (map (fn [k v] {k v}) k v)))","problem":61,"user":"4f03818e535dcb61093f6b00"},{"code":"(fn [a b]\r\n  (apply hash-map (interleave a b)))","problem":61,"user":"4e03b010535d04ed9115e794"},{"code":"#(apply hash-map (mapcat list % %2))\n; didn't think to use into, but this isn't terrible IMO","problem":61,"user":"4dd88803535d2dad7130b5d9"},{"problem":61,"code":"(fn [ks vs]\n  (loop [ks ks, vs vs, acc {}]\n    (if (or (empty? ks) (empty? vs))\n      acc\n      (let [k (first ks), v (first vs)]\n       (recur (rest ks) (rest vs) (assoc acc k v))))))","user":"4f4e78fee4b03ad3f0c10cc8"},{"code":"(fn [c1 c2]\n  (into {} (filter (comp not nil? val)\n                   (reduce merge (map-indexed #(hash-map %2 (get c2 %1)) c1)))))","problem":61,"user":"52d2f457e4b099d49816f0ba"},{"problem":61,"code":"(fn zipmap*\n  [c1 c2]\n  (reduce conj (map #(hash-map %1 %2) c1 c2)))","user":"566f7749e4b0a866af6896e9"},{"code":"#(apply assoc {} (mapcat (fn [x y] [x y]) %1 %2))","problem":61,"user":"4ed94d69535d10e5ff6f5303"},{"problem":61,"code":"#(into {}\n    (map (fn [x y] [x y]) \n         %1 %2))","user":"51e5a627e4b0efabf93c02db"},{"problem":61,"code":"(fn\n\t[a b]\n\t(reduce \n     #(let\n        [x (nth b (.indexOf a %2) nil)]\n        (if x\n          (assoc %1 %2 x) %1)) {} a))","user":"53da3fcde4b0e771c3025497"},{"code":"#(into{} (map vector % %2))","problem":61,"user":"4f03857e535dcb61093f6b0d"},{"problem":61,"code":"(fn [keys vals]\n  (loop [acc {}\n         k keys\n         v vals]\n    (if (or (empty? k) (empty? v))\n      acc\n      (recur (assoc acc (first k) (first v)) (rest k) (rest v)))))","user":"5318594ee4b08068f379ed6d"},{"code":"#((fn mkmp [ks vs m]\n  (if (or (empty? ks) (empty? vs))\n    m\n    (assoc (mkmp (rest ks) (rest vs) m) (first ks) (first vs)))) %1 %2 {})","problem":61,"user":"529ce629e4b04e0c58e87b6e"},{"problem":61,"code":"(fn test [seq-1 seq-2]\n  (reduce (fn [acc [x y]]\n            (assoc acc x y))\n          {}\n          (map (fn [a b]\n                 [a b])\n               seq-1\n               seq-2)))","user":"579332c2e4b0e215f87e8452"},{"problem":61,"code":"(fn my-map [s1 s2]\n  (if (or (empty? s1) (empty? s2)) \n    {}\n    (assoc (my-map (rest s1) (rest s2)) (first s1) (first s2))))","user":"5be33a16e4b0ed4b8aab4cd6"},{"code":"(fn [a b]\n  (loop [acc {}\n         l a\n         r b]\n    (let [[l-first & l-rest] l\n          [r-first & r-rest] r]\n      (if (or (empty? l) (empty? r))\n        acc\n        (recur\n          (conj acc [l-first r-first])\n          l-rest\n          r-rest)))))","problem":61,"user":"4fba7d1ee4b081705acca2e0"},{"code":"(fn [x y] (apply merge (map hash-map x y)))","problem":61,"user":"52a28e1ce4b04e0c58e87bf0"},{"code":"(fn [ks vs]\n  (loop [ret {}\n         ks (seq ks)\n         vs (seq vs)]\n    (if (and ks vs)\n      (recur (assoc ret \n                    (first ks) \n                    (first vs))\n             (next ks)\n             (next vs))\n      ret)))","problem":61,"user":"5336ca32e4b0e30313ee6c80"},{"problem":61,"code":"#(reduce (fn [m [k v]] (assoc m k v))  {} (map vector %1 %2))","user":"5627d09ce4b00e49c7cb47db"},{"problem":61,"code":"(fn m [k v] (apply conj (map #(apply hash-map %) (map vector k v))))","user":"54dbcbbde4b024c67c0cf774"},{"code":"#(loop [[k & ks] %1 [v & vs] %2 r {} a assoc s seq]\r\n     (if (and (s vs) (s ks))\r\n         (recur ks vs (a r k v) a s)\r\n         (a r k v)))","problem":61,"user":"4dae869dedd6309eace4d154"},{"code":"(fn [keys vals]\n  (loop [keys (seq keys), vals (seq vals), result {}]\n    (cond\n      (and keys vals) (recur (next keys) (next vals) (assoc result (first keys) (first vals)))\n      :else result)))","problem":61,"user":"4fa820fde4b081705acca1ce"},{"problem":61,"code":"(fn [v1 v2]\n  (let [v3 (partition 2 (interleave v1 v2))]\n    (loop [m {} i 0]\n      (if (= i (count v3))\n        m\n        (recur (assoc m (first (nth v3 i)) (second (nth v3 i))) \n               (inc i))))))","user":"564d3169e4b0284900eef67c"},{"problem":61,"code":"(fn my-map-builder [keys values]\n  (loop [[k & rks :as ks] keys\n         [v & rvs :as vs] values\n         m {}]\n    (if (or (empty? ks) (empty? vs))\n      m\n      (recur rks rvs (assoc m k v)))))","user":"54a31fdae4b09f271ff37c64"},{"code":"(fn my-zipmap [a b]                                                                                                                          \r\n    (apply hash-map (interleave a b)))","problem":61,"user":"4f149e0f535d64f60314643d"},{"problem":61,"code":"(fn [ks vs]\n  (loop [[k & ks] ks\n         [v & vs] vs\n         acc {}]\n    (if (or (nil? k) (nil? v))\n      acc\n      (recur ks vs (assoc acc k v)))))","user":"5d35f997e4b01671435dbd1a"},{"problem":61,"code":"(fn f [ks vs]\n  (apply merge (map #(hash-map %1 %2) ks vs)))","user":"5ea6fe98e4b00a66d4a951b2"},{"code":"(fn [k v]\n  (apply hash-map (mapcat vector k v)))","problem":61,"user":"4de165f3535d08e6dec9fde6"},{"problem":61,"code":"(fn [ks vs]\n  (loop [map {}\n         ks (seq ks)\n         vs (seq vs)]\n    (if (and ks vs)\n      (recur (assoc map (first ks) (first vs))\n             (next ks)\n             (next vs))\n      map)))","user":"55478ce2e4b0a04f7929954e"},{"code":"(fn [x y] (apply merge (map #(hash-map % %2) x y)))","problem":61,"user":"4e8d5911535d65386fec2133"},{"problem":61,"code":"(fn map-construction [keys values]\n  (apply assoc {}  ;; Assoc creates a map\n         (interleave keys values)))  ;; Sequence of keys and values (one at each time)","user":"5fbf6fe7e4b0ad6fc3476147"},{"problem":61,"code":"#(->> %2 (interleave %1) (apply hash-map))","user":"504e2d18e4b0f6ff3350c47a"},{"code":"(fn [coll_1 coll_2]\n    \n    (reduce\n      (fn [my-map elm]\n        (assoc my-map (first elm) (last elm)))\n      {}\n      (map \n        (fn [elm1 elm2] [elm1 elm2])\n        coll_1\n        coll_2)))","problem":61,"user":"518d1b5be4b070277754617b"},{"code":"(fn [a b]\n    (apply assoc\n        (concat [{}] (vec (interleave a b)))\n    )\n)","problem":61,"user":"504f191ae4b0e7ad84dbc4ba"},{"code":"(fn myZipMap\n  [mapKeys mapVals]\n    (apply merge (map #(assoc {} %1 %2) mapKeys mapVals)))","problem":61,"user":"509a25b7e4b0efbae1fbc0a8"},{"code":"(fn [ks vs]\r\n  (loop [mp {} ks ks vs vs]\r\n    (if (or (empty? ks) (empty? vs)) mp\r\n        (recur (assoc mp (first ks) (first vs)) \r\n               (rest ks)\r\n               (rest vs)))))","problem":61,"user":"4e02bee8535d04ed9115e791"},{"problem":61,"code":"(fn [xs ys]\n  (reduce #(assoc %1 (first %2) (last %2)) {} (map #(list %1 %2) xs ys)))","user":"546ff835e4b00cfc9eacc1b4"},{"problem":61,"code":"(fn blah [k v] (apply hash-map (mapcat list k v)))","user":"535f9a5ce4b04ce2eb3ed2de"},{"problem":61,"code":"(fn myzip [ks vs]\n  (if (or (empty? ks) (empty? vs))\n    {}\n    (assoc (myzip (rest ks) (rest vs)) (first ks) (first vs))))","user":"54651982e4b01be26fd746d4"},{"code":"(fn [ks vs]\n  (reduce merge\n    (map #(assoc {} %1 %2) ks vs)))","problem":61,"user":"51db0d99e4b06aa4d4669a9d"},{"code":"(fn [keys vals] \n  (reduce (fn [result next] (merge result next)) {} (map hash-map keys vals)))","problem":61,"user":"4ff83003e4b0678c553fc396"},{"problem":61,"code":"(fn\n  [keys values]\n  (loop [[k & keys] keys\n         [v & values] values\n         m {}]\n    (if (and k v)\n      (recur keys values (assoc m k v))\n      m)))","user":"570c8ac3e4b0b0fb43fd06ca"},{"problem":61,"code":"(fn [%1 %2] (apply hash-map (interleave %1 %2)))","user":"5a51e029e4b05d388ecb6bf0"},{"problem":61,"code":"(fn m[k v]\n   (reduce merge\n     (map\n       #(assoc {} (first %) (second %))\n       (partition 2 (interleave k v)))))","user":"5398123ee4b0b51d73faaef3"},{"code":"(fn [keys vals]\r\n    (loop [map {}\r\n           ks (seq keys)\r\n           vs (seq vals)]\r\n      (if (and ks vs)\r\n        (recur (assoc map (first ks) (first vs))\r\n               (next ks)\r\n               (next vs))\r\n        map)))","problem":61,"user":"4dd579b5535dae65d5c462ea"},{"problem":61,"code":"(fn [xs ys]\n (->> (interleave xs ys)\n  (apply hash-map)))","user":"57eaf869e4b0bfb2137f5b56"},{"problem":61,"code":"(fn\n  [k v]\n  (->> (map #(hash-map %1 %2) k v)\n       (apply merge)))","user":"4e586949535d8a8b8723a292"},{"problem":61,"code":"#(into (sorted-map) (apply hash-map (mapcat vector %1 %2)))","user":"58173722e4b0c0e9c07b838a"},{"problem":61,"code":"#(reduce (partial apply assoc) {} (map vector % %2))","user":"5c7bc0a5e4b0fca0c1622865"},{"code":"#(apply hash-map(flatten (map list %1 %2)))","problem":61,"user":"516eb196e4b06aac486e5b2e"},{"problem":61,"code":"(fn [keys values]\n  (loop [r {}\n         k keys\n         v values]\n    (if (or (empty? k)\n            (empty? v))\n      r\n      (recur (assoc r (first k) (first v))\n             (rest k)\n             (rest v)))))","user":"5541fa50e4b0a04f79299515"},{"code":"(fn [col1 col2]\n  (loop [l1 col1, l2 col2, result {}]\n    (if (or (empty? l1) (empty? l2))\n         result\n        (recur (rest l1) (rest l2) \n            (assoc result (first l1) (first l2) )\n           )\n     )\n  )\n)","problem":61,"user":"4f6d9d7ee4b07046d9f4efcd"},{"problem":61,"code":"#(into {} (map (fn [key val] [key val]) %1 %2))","user":"561d23e3e4b064ca9f4b16a5"},{"code":"(fn [a b] (apply array-map (flatten (map #(vector % %2) a b))))","problem":61,"user":"4fab31a8e4b081705acca215"},{"code":"#(into{} (map vector %1 %2))","problem":61,"user":"534d639ae4b084c2834f4a9e"},{"code":"(comp #(apply merge %) (partial map #(assoc nil %1 %2)))","problem":61,"user":"50e3e108e4b01912b3285c48"},{"problem":61,"code":"#(reduce merge (map (fn [v1 v2] (hash-map v1 v2)) % %2))","user":"5617db88e4b06b1bb2182a16"},{"code":"(fn [l1 l2] (apply hash-map (interleave l1 l2)))","problem":61,"user":"4ff769bce4b0678c553fc38f"},{"problem":61,"code":"(fn [s1 s2]\n          (into {} (map vector s1 s2)))","user":"4e617114535d8ccf87e9fe5b"},{"code":"(fn [as bs]\n  (loop [r {} a as b bs]\n    (println r a b)\n    (if (or (empty? a) (empty? b))\n      r\n      (recur (assoc r (first a) (first b)) (rest a) (rest b)))))","problem":61,"user":"4f1ae082535d64f603146470"},{"problem":61,"code":"(fn[k v] (apply assoc {} (interleave k v)))","user":"53e9681de4b036ad0777e4a4"},{"problem":61,"code":"(fn [vk vv]\n    (apply hash-map (interleave vk vv))\n )","user":"5649615be4b0284900eef641"},{"code":"#(apply merge (for [i (range (min (count %2) (count %)))] {(nth % i) (nth %2 i)}))","problem":61,"user":"4ec0c7ba535dfed6da9c6da4"},{"problem":61,"code":"(fn [ks vs]\n  ((fn spotzmhelp [aks avs m]\n    (if (or (empty? aks) (empty? avs))\n      m\n      (assoc (spotzmhelp (rest aks) (rest avs) m) (first aks) (first avs)))) ks vs {}))","user":"60882700e4b0ae75613dcedf"},{"problem":61,"code":"(fn [keys values]\n  (loop [map {}\n         keys keys\n         values values]\n     (if (or (empty? keys) (empty? values))\n       map\n       (recur (assoc map (first keys) (first values))\n              (rest keys)\n              (rest values)))))","user":"56002c2de4b04bb52996e161"},{"problem":61,"code":"(fn [coll1 coll2]  (let [min-count (min (count coll1) (count coll2))] (reduce (fn [accum val] \n                                        (assoc accum (nth coll1 val) (nth coll2 val) )) {} (range 0 min-count))))","user":"53c73e8ae4b00fb29b2212a5"},{"problem":61,"code":"(fn[a b](reduce(fn[r x](apply assoc r x)){}(for[idx(range (min(count a)(count b)))][(nth a idx)(nth b idx)])))","user":"5ce62d8ee4b0a17bb84e2b83"},{"problem":61,"code":"(fn [keys values]\n  (loop [keys keys\n         values values\n         result {}]\n    (if (or (empty? keys) (empty? values))\n      result\n      (recur (rest keys) (rest values) (conj {(first keys) (first values)} result)))))","user":"5293a603e4b0239c8a67af42"},{"problem":61,"code":"(fn [& colls]\n  (into {}\n    (apply map vector colls)))","user":"53716539e4b0fc7073fd6eb1"},{"problem":61,"code":"(fn [keys values]\n  (loop [keys keys\n         values values\n         result {}]\n    (cond\n      (or (empty? keys)\n          (empty? values)) result\n      :else (recur (rest keys)\n                   (rest values)\n                   (assoc result (first keys)\n                          (first values))))))","user":"5e860270e4b09a7a73c8bbdb"},{"problem":61,"code":"#(reduce \n  (fn [res [key val]]\n    (assoc res key val))\n  {} (partition 2 (mapcat vector % %2))\n  )","user":"5d5b2678e4b06a698e928ee2"},{"code":"(fn fun [[x & xs][y & ys]]\n  (if (and x y)\n    (assoc (fun xs ys) x y)\n         {} ))","problem":61,"user":"5349da55e4b084c2834f4a68"},{"code":"(fn create-map [x y] \n\t(apply hash-map (interleave x y))\n  )","problem":61,"user":"500a214de4b03d00572d2d74"},{"problem":61,"code":"(fn [k v]\n  (let [smaller-count (if (<= (count k) (count v))\n                        (count k)\n                        (count v))]\n    (loop [i 0\n           m {}]\n      (if (= i smaller-count)\n        m\n        (recur (inc i) (assoc m (get k i) (get v i)))))))","user":"57d57f65e4b0bd073c2023b3"},{"problem":61,"code":"(fn f [ks vs]\n  (if (or (empty? ks) (empty? vs))\n    {}\n    (assoc (f (rest ks) (rest vs)) (first ks) (first vs))))","user":"565131b3e4b0f29ec07d2e88"},{"problem":61,"code":"(fn zip-map [k v]\n  (apply assoc {} (interleave k v)))","user":"5f03550ce4b0cf489e8d7f33"},{"code":"#(apply hash-map (mapcat list %1 %2))","problem":61,"user":"4e7dfab0535db169f9c796f9"},{"code":"(fn [m n] (apply array-map (mapcat (fn [k v] [k v]) m n)))","problem":61,"user":"4faac363e4b081705acca200"},{"problem":61,"code":"(fn [a b]\n  (loop [res {} k a v b]\n    (if (or (empty? k) (empty? v))\n      res\n      (recur (conj res [(first k) (first v)])\n             (next k)\n             (next v)))))","user":"553b87abe4b09218d5f45003"},{"problem":61,"code":"(fn [ks vs]\n  (loop [m {}\n         ks ks\n         vs vs]\n    (if (or (empty? ks)\n            (empty? vs))\n        m\n        (recur (assoc m (first ks) (first vs))\n               (rest ks)\n               (rest vs)))))","user":"574c3a7ce4b02ea114799219"},{"problem":61,"code":"(fn [ks elem]\n  (apply hash-map (interleave ks elem)))","user":"6074dfa4e4b069485764de4c"},{"code":"(fn zm [k v]\n  (cond (or (empty? k)(empty? v)) {}\n        :else (into {(first k)(first v)} (zm (rest k)(rest v)))))","problem":61,"user":"52153bdde4b0961f15ac4daa"},{"code":"(fn to-map [ks vs]\r\n  (if (or (empty? vs) (empty? ks))\r\n    {}\r\n    (merge {(first ks) (first vs)} (to-map (rest ks) (rest vs))) ))","problem":61,"user":"4df3df8a535d08e6dec9fe2d"},{"problem":61,"code":"(fn [x y] (apply hash-map\n                  (interleave\n                   x\n                   y\n                   )\n            ) \n           \n  )","user":"56e6e1e6e4b02e7e935eb6cf"},{"code":"(fn [a b] (into {} (map vector a b )))","problem":61,"user":"5018ed15e4b011a2e0bf6412"},{"problem":61,"code":"(fn my-zipmap\n  [xs ys]\n  (reduce (fn [accum [k v]] (into accum {k v}))\n          {}\n          (map list xs ys)))","user":"5c222b7de4b07e362c230588"},{"problem":61,"code":"(fn zip-map [xs ys]\n  (if (or (= (count xs) 0) (= (count ys) 0))\n    {}\n    (conj (zip-map (rest xs) (rest ys)) [(first xs) (first ys)])))","user":"56bfcba1e4b060a8e693e3a1"},{"problem":61,"code":"(fn [lst-keys lst-values]\n  (apply hash-map (interleave lst-keys lst-values))\n  )","user":"57f81045e4b0d3187e90090f"},{"problem":61,"code":"(fn [a b]\n  (apply assoc {} (flatten (map #(vector %1 %2) a b))))","user":"55f2d4ede4b06e875b46ce4c"},{"code":"(fn zippity[keys values]\n  (apply assoc {} (interleave keys values)))","problem":61,"user":"4f831fd3e4b033992c121c17"},{"code":"(fn [seq1 seq2]\n  (->> (map #(assoc {} %1 %2) seq1 seq2)\n       (apply merge )))","problem":61,"user":"536f871de4b0fc7073fd6e7f"},{"problem":61,"code":"(fn [as bs] (into (hash-map) (map vector as bs)))","user":"58334d18e4b089d5ab817c97"},{"code":"#(loop [m {} k %1 v %2]\n  (if (or (empty? k) (empty? v))\n    m\n    (recur (assoc m (first k) (first v)) (rest k) (rest v))))","problem":61,"user":"4faec810e4b081705acca24e"},{"code":"#(into{}(map vector %1 %2))","problem":61,"user":"4e5411e8535d8a8b8723a279"},{"code":"(fn [k v]\n  (loop [kk k vv v out (hash-map)]\n    (if (or (empty? kk) (empty? vv))\n      out\n      (recur (rest kk) (rest vv) (assoc out (first kk) (first vv))))))","problem":61,"user":"4dd9d299535d2dad7130b5dd"},{"problem":61,"code":"(fn M [ks vs]\n  (if (or (empty? ks) (empty? vs))\n    {}\n  (merge (hash-map (first ks) (first vs)) (M (rest ks) (rest vs)))))","user":"53ca23e3e4b00fb29b2212c6"},{"problem":61,"code":"(fn [keys values]\n  (let [my-zip (fn [res ks vs]\n                 (if (or (empty? ks)\n                         (empty? vs))\n                   res\n                   (recur (assoc res (first ks) (first vs)) (rest ks) (rest vs))))]\n    (my-zip {} keys values)))","user":"545f737ce4b01be26fd74688"},{"problem":61,"code":"(fn [ks vs] (apply hash-map (flatten (map #(vector %1 %2) ks vs))))","user":"5b4b4052e4b02d533a91bc9a"},{"code":"(fn [c1 c2]\r\n  (loop [c1 c1\r\n         c2 c2\r\n         r {}]\r\n    (if (some empty? [c1 c2])\r\n      r\r\n      (recur (rest c1) (rest c2) (conj r [(first c1) (first c2)])))))","problem":61,"user":"4de2f44f535d08e6dec9fdec"},{"code":"(fn zm\n  [keys vals]\n\n    (loop [map {}\n\n           ks (seq keys)\n\n           vs (seq vals)]\n\n      (if (and ks vs)\n\n        (recur (assoc map (first ks) (first vs))\n\n               (next ks)\n\n               (next vs))\n\n        map)))","problem":61,"user":"4fe8e719e4b0547ebccb2430"},{"code":"(fn zm [[a & al][b & bl]] \n (cond \n  (some empty? [al bl]) {a b}\n  true (conj {a b} (zm al bl))\n )\n)","problem":61,"user":"4ef355e3535dced4c769f228"},{"code":"(fn [x y] (loop [res {} ks x vs y]\n                        (if (or (empty? vs) (empty? ks))\n                            res\n                            (recur (assoc res (first ks) (first vs))\n                                   (rest ks)\n                                   (rest vs))\n                            )\n                        ))","problem":61,"user":"4db58ccb535d87e67b28fe10"},{"problem":61,"code":"#(apply hash-map (flatten (map (fn [x y] [x y]) %1 %2)))","user":"52824143e4b0757a1b171453"},{"code":"(fn [ks vs]\n  (loop [[kh & kb] ks [vh & vb] vs ret {}]\n    (if-not (or (nil? kh) (nil? vh))\n      (recur kb vb (assoc ret kh vh))\n      ret)))","problem":61,"user":"513cb853e4b0b86ece9f322b"},{"problem":61,"code":"(fn [k v]\n  (into {} (map (fn [ke va] [ke va]) k v)))","user":"53480973e4b084c2834f4a52"},{"code":"#(reduce (fn [m e] (let [[k v] e] (assoc m k v))) {} (map vector % %2))","problem":61,"user":"506cad7de4b0a302964c548e"},{"problem":61,"code":"(fn [s1 s2]\n  (loop [acc {}\n         r1 s1\n         r2 s2]\n    (if (or (empty? r1) (empty? r2))\n      acc\n      (recur (conj acc {(first r1) (first r2)})\n             (rest r1)\n             (rest r2)))))","user":"5292feb4e4b0239c8a67af39"},{"code":"(fn inmap [k v]\n  (apply assoc {} (interleave k v))\n  )","problem":61,"user":"5228f870e4b0186687e23a98"},{"problem":61,"code":"(fn [x y] (into {} (map (fn [a b] {a b}) x y)))","user":"55d42f78e4b0e31453f64a73"},{"code":"(fn [ks vs] (apply hash-map (interleave ks vs)))","problem":61,"user":"4dad7adac9a9d6ed0599dc57"},{"problem":61,"code":"#(reduce merge (map (fn [a b] {a b}) %1 %2))","user":"57c94c6ee4b05aa3c4741d2d"},{"problem":61,"code":"(fn [kcoll vcoll] (reduce (fn [m p] (assoc m (first p) (second p))) {} (map vector kcoll vcoll)))","user":"5519c157e4b00ace28fe6e32"},{"problem":61,"code":"(fn myzipmap [coll1 coll2]\n  (loop [input1 coll1\n         input2 coll2\n         result {}]\n    (if (or (empty? input1) (empty? input2))\n      result\n      (recur (rest input1) (rest input2) (assoc result (first input1) (first input2))))))","user":"5ab490f4e4b073f17744261d"},{"code":"(fn [keys vals]\n  (apply hash-map (interleave keys vals)))","problem":61,"user":"4f504739e4b03ad3f0c10d00"},{"code":"(fn [ks vs]\n  (reduce (fn [m x]\n              (assoc m (first x) (second x)))\n          {}\n          (map vector ks vs)))","problem":61,"user":"4f2a35ace4b0d6649770a03a"},{"code":"#(loop [k %1\n        v %2\n        m {}]\n    (if (or (empty? k) (empty? v))\n      m\n      (recur (rest k) (rest v) (assoc m (first k) (first v)))))","problem":61,"user":"504e9011e4b069badc5a33b7"},{"problem":61,"code":"(fn [n m] (apply hash-map (interleave n m)))","user":"51c1b644e4b0d204dbe2ca12"},{"problem":61,"code":"(fn [x y]\n  (loop [_keys x\n         _values y\n         return {}]\n    (if (or (nil? (first _keys))\n            (nil? (first _values)))\n      return\n      (recur (rest _keys)\n             (rest _values)\n             (assoc return (first _keys) (first _values))))))","user":"55f73078e4b06e875b46cea4"},{"code":"#(apply hash-map (flatten (map list %1 %2)) )","problem":61,"user":"531bfb69e4b08068f379ed97"},{"problem":61,"code":"#(apply conj {} (map vector %1 %2))\n\n;; #(into {} (map vector %1 %2))","user":"58d2af83e4b03c36ff7e5907"},{"code":"(fn \n  [k v]\n  (apply assoc {} (interleave k v)))","problem":61,"user":"4f29afc7e4b0d6649770a02e"},{"code":"(fn makem [ks vs]\n  (loop [m {}, keys ks, vals vs]\n\t\t(if (and keys vals)\n\t\t\t(recur (assoc m (first keys) (first vals))\n\t\t\t\t(next keys) (next vals))\n\t\tm)))","problem":61,"user":"4ff4c9dae4b0678c553fc360"},{"code":"(fn [k v] (apply conj (map #(assoc {} %1 %2) k v)))","problem":61,"user":"5171f684e4b0d70c8bbbf248"},{"problem":61,"code":"#(loop[l1 %1, l2 %2 r {}   ]\n  (cond\n    (nil? l1) r\n    (nil? l2) r\n    :else (recur (next l1) (next l2 ) (assoc r (first l1) (first l2)))  \n    )\n  )","user":"5c4ab449e4b0f9f7a8770e57"},{"problem":61,"code":"(fn make-map [ks vs]\n  (apply hash-map (interleave ks vs)))","user":"56175cf9e4b06b1bb2182a0f"},{"code":"(fn [l1 l2]\n    (apply hash-map (reduce #(assoc %1 (first %2) (second %2)) (mapcat #(list %1 %2) l1 l2) {})))","problem":61,"user":"523288fee4b035af41902a88"},{"problem":61,"code":"(fn  [v1 v2]\n  (loop [vec1 v1\n         vec2 v2\n         acc {}]\n    (if (or (empty? vec1) (empty? vec2))\n      acc\n    (recur (rest vec1) (rest vec2) (assoc acc (first vec1) (first vec2))))))","user":"582dc562e4b051871117bfcb"},{"code":"(fn [k v] (apply hash-map (flatten (map list k v))))","problem":61,"user":"53070615e4b02e821686979e"},{"problem":61,"code":"(fn [ks vs]\n  (->> (map vector ks vs)\n       (into {})))","user":"559622cee4b0c79f6e1db975"},{"code":"(fn [ks vs]\n  (reduce (fn [mp i] (assoc mp (first i) (second i))) \n          {}\n          (partition 2 (interleave ks vs))))","problem":61,"user":"4eb1dd39535d7eef30807345"},{"code":"(fn [keys values] (into {} (map vector keys values)))","problem":61,"user":"4e57afc5535d8a8b8723a288"},{"problem":61,"code":"(fn my-zipmap [a b]\n  (reduce (fn [init pair] (apply assoc init pair))\n          {}\n          (partition 2 (interleave a b))))","user":"580d2788e4b0849f6811b730"},{"code":"(fn [a b] (apply hash-map (mapcat #(vector %1 %2) a b)))","problem":61,"user":"4def301c535d08e6dec9fe12"},{"problem":61,"code":"(fn\n  [keys vals]\n  (loop [result {}\n         ks (seq keys)\n         vs (seq vals)]\n    (if (and ks vs)\n      (recur (assoc result (first ks) (first vs))\n             (next ks)\n             (next vs))\n      result)))","user":"53e0001be4b0d874e779ae48"},{"problem":61,"code":"(fn [keys values]\n               (let [validrange (if (> (count keys) (count values)) \n                               (count values) \n                               (count keys))]\n               (into {} (for [i (range validrange)]\n                          {(nth keys i) (nth values i)}))))","user":"5d4df658e4b0776584bd6f41"},{"code":"(fn [a b] (apply hash-map (mapcat vector a b)))","problem":61,"user":"504e71cbe4b0f6ff3350c4b3"},{"code":"(fn [k v]\n  (->> (interleave k v) (partition 2) (map vec) (into {})))","problem":61,"user":"5012ec0ae4b0c87326002230"},{"problem":61,"code":"(fn [coll1 coll2]\n  (apply assoc {}\n    (interleave coll1 coll2)))","user":"4fbfbd4fe4b081705acca31c"},{"problem":61,"code":"(fn mapConstruct \n    [vec1 vec2]\n    (apply hash-map (interleave vec1 vec2)))","user":"56fe2a2fe4b08d47c97781ad"},{"code":"(fn my-zip-map [keys vals]\r\n  (loop [keys keys\r\n         vals vals\r\n         result {}]\r\n    (if (or (empty? keys) (empty? vals))\r\n      result\r\n      (recur\r\n       (rest keys)\r\n       (rest vals)\r\n       (conj result [(first keys) (first vals)])))))","problem":61,"user":"4fe54ee8e4b0e8f79898fec3"},{"problem":61,"code":"(fn\n  [seq1 seq2]\n  (into {} (map #(assoc {} %1 %2) seq1 seq2)))","user":"5d1c14cde4b02ea6f0fb698a"},{"code":"(fn [as bs]\n   ((fn helper [accu xs ys]\n     (if (or (empty? xs) (empty? ys))\n       accu\n       (recur (assoc accu (first xs) (first ys)) \n                (rest xs) (rest ys))\n     )\n   ) (hash-map ) as bs)\n   )","problem":61,"user":"50217818e4b00bba4502f7a7"},{"problem":61,"code":"(fn [keys values]\n      (into {} (map (fn [[k v]] [k v]) (partition 2 (interleave keys values)))))","user":"53f891eee4b0de5c4184856d"},{"code":"#(into{}(map vector%1%2))","problem":61,"user":"4e7eff9e535db966e863cc38"},{"problem":61,"code":"(fn f [x y]\n  (loop [x x\n         y y\n         result {}]\n    (if (or (empty? x) (empty? y))\n      result\n      (recur (rest x) (rest y) (assoc result (first x) (first y))))))","user":"575fbe58e4b08062f99a4e87"},{"problem":61,"code":"(fn [x y] (reduce #(let [[k v] %2] (assoc %1 k v)) {} (map #(vector %1 %2) x y)))","user":"5f86a98be4b0649ffcda4caa"},{"problem":61,"code":"#(apply merge (map (fn [k v]\n                           {k v})\n                         %1\n                         %2))","user":"5410499de4b01498b1a719a6"},{"code":"(fn [a b]\n  (loop [map {} ks (seq a) vs (seq b)]\n    (if (and ks vs)\n      (recur (assoc map (first ks) (first vs)) (next ks) (next vs))\n      map)))","problem":61,"user":"4e46ac46535dc968683fc4b5"},{"problem":61,"code":";#(loop [k %,v %2,m {}]\n;   (if (or (empty? k) (empty? v)) m\n;     (recur (rest k) (rest v) (conj m [(first k) (first v)]))))\n\n;#(into {} (map (fn [k v] (assoc {} k v)) % %2))\n\n#(into {} (map vector % %2))","user":"555e9dbfe4b0a2eb076a39bc"},{"problem":61,"code":"(fn [coll1 coll2]\n  (apply merge (map-indexed (fn [idx elem] (if (contains? coll2 idx) {elem (nth coll2 idx)})) coll1)))","user":"5658d775e4b00d3155796114"},{"problem":61,"code":"(fn map-const [keys values]\n  (into {} (map #(vector %1 %2) keys values)))","user":"60849bd6e4b0736b099e42f2"},{"code":"(fn a [x y] (if (or (empty? x) (empty? y)) {} (merge {(first x) (first y)} (a (rest x) (rest y)))))","problem":61,"user":"4e85cda3535db62dc21a62f0"},{"code":"#(loop [l1 % l2 %2 m {}]\n  (if (or (empty? l1) (empty? l2)) \n    m\n    (recur (rest l1) (rest l2)\n      (assoc m (first l1) (first l2)))))","problem":61,"user":"4e9c81e8535dbda64a6f6b80"},{"problem":61,"code":"(fn [s1 s2] (into {} (mapcat #(assoc {} %1 %2) s1 s2)))","user":"542fa0dde4b0dad94371f2d2"},{"problem":61,"code":"#(apply hash-map  (interleave %1 %2))","user":"56e9a56ae4b04a395b9a03fc"},{"code":"(fn jzipmap\n  [keys vals]\n  (if (or (empty? keys) (empty? vals))\n    #{}\n    (merge-with #{} {(first keys) (first vals)} (jzipmap (rest keys) (rest vals)))))","problem":61,"user":"534ff8a6e4b084c2834f4ad1"},{"problem":61,"code":"(fn zmap [keyseq valseq]\n  (loop [keyseq-it keyseq\n         valseq-it valseq\n         ret-map {}]\n    (if (or (empty? keyseq-it)\n            (empty? valseq-it))\n      ret-map\n      (recur (rest keyseq-it)\n             (rest valseq-it)\n             (assoc ret-map\n               (first keyseq-it)\n               (first valseq-it))))))","user":"559d33b3e4b0ec2b359424d9"},{"problem":61,"code":"(fn my-zipmap\n  [s1 s2]\n  (reduce conj {} (map #(hash-map %1 %2) s1 s2)))","user":"58976bfde4b00487982d52bc"},{"problem":61,"code":"(fn [keys vals] (into {} (reverse (apply assoc {} (interleave keys vals)))))","user":"554bc64ae4b0a04f79299598"},{"problem":61,"code":"(fn zippy [keys vals]  (reduce merge (map #(hash-map %1 %2) keys vals)))","user":"525d44bfe4b0cb4875a45d6d"},{"problem":61,"code":"(fn [v1 v2] (into {} (map #(conj [] % %2) v1 v2)))","user":"58d27bcae4b03c36ff7e58fe"},{"problem":61,"code":"(fn [list1 list2] (into (sorted-map) (map vector list1 list2)))","user":"57aa103be4b0b8559636fc64"},{"problem":61,"code":"(fn [keys values]\n  (reduce (fn [map [k v]]\n            (assoc map k v))\n          {}\n          (map (fn [k v] (list k v)) keys values)))","user":"57f7c74ee4b0d3187e900902"},{"code":"(fn [k v] (loop [k k v v m {}] (if (or (empty? k) (empty? v)) m (recur (rest k) (rest v) (assoc m (first k) (first v))))))","problem":61,"user":"4f0cc259535d0136e6c22310"},{"problem":61,"code":";#(loop [keys %1\n;       values %2\n;       result {}]\n;  (if (or (nil? keys) (nil? values))\n;    result\n;    (recur (next keys) (next values) (assoc result (first keys) (first values)))\n;    )\n;  )\n#(apply hash-map (interleave %1 %2))","user":"566639f4e4b0e91d5f5c566b"},{"problem":61,"code":"(fn x [coll1 coll2]\n  (if (and (not (empty? coll1)) (not (empty? coll2)))\n    (let [k (first coll1)\n          v (first coll2)]\n  \t(assoc (x (rest coll1) (rest coll2)) k v))\n    {})\n  )","user":"5e84b48ee4b09a7a73c8bbc8"},{"code":"#(loop [x %1 y %2 result {}] (if (or (empty? x) (empty? y)) result (recur (rest x) (rest y) (conj result (hash-map (first x) (first y))))))","problem":61,"user":"52d4acc8e4b09f7907dd1333"},{"problem":61,"code":"(fn [v1 v2] (into {} (map vector v1 v2)))","user":"55d1f0bae4b0e31453f64a4d"},{"problem":61,"code":"(fn [keys vals]\n  (loop [my-map {}\n         my-keys (seq keys)\n         my-vals (seq vals)]\n    (if (and my-keys my-vals)\n      (recur (assoc my-map (first my-keys) (first my-vals))\n             (next my-keys)\n             (next my-vals))\n      my-map)))","user":"5f63d933e4b02876ed9fd018"},{"code":"(fn map-constr [x y]\n      (if (or (empty? (rest x)) (empty? (rest y)))\n        (hash-map (first x) (first y))\n        (merge (hash-map (first x) (first y))\n               (map-constr (rest x) (rest y)))))","problem":61,"user":"52e17e66e4b09f7907dd1423"},{"problem":61,"code":"#(loop[p_key %1\n       p_val %2\n       res {}]\n  (if (or (empty? p_key) (empty? p_val))\n    res\n    (recur (rest p_key) (rest p_val)\n      (assoc res (first p_key) (first p_val))\n    )\n  )\n)","user":"5bfcdc52e4b0bdcf453d15f4"},{"problem":61,"code":"(fn [coll1 coll2]\n  (apply assoc {} (interleave coll1 coll2)))","user":"53bf9cfbe4b0c98a41f5cca4"},{"problem":61,"code":"#(reduce (partial apply assoc) {} (map list %1 %2))","user":"52503747e4b0541d1855b828"},{"code":"#(reduce (fn [m [k v]] (assoc m k v)) {} (partition 2 (interleave %1 %2)) )","problem":61,"user":"52bf6946e4b07a9af5792334"},{"code":"#(reduce conj {} (map (fn [k v] [k v]) %1 %2))","problem":61,"user":"4e07eac0535d04ed9115e7a9"},{"problem":61,"code":"(fn my-zipmap [ks, vs]\n  (if (= 0 (min (count ks) (count vs)))\n    {}\n    (assoc (my-zipmap (rest ks) (rest vs)) (first ks) (first vs))))","user":"5733e4aee4b0cd1946bd0ffe"},{"problem":61,"code":"(fn f [xs ys]\n  (cond (empty? xs) {}\n        (empty? ys) {}\n\t\ttrue (conj (f (rest xs) (rest ys)) {(first xs) (first ys)})))","user":"5583888ae4b05c286339e117"},{"code":"#(apply hash-map (flatten (map vector %1 %2)))","problem":61,"user":"4deb529a535d08e6dec9fe04"},{"code":"#(reduce (fn [m [k v]] (assoc m k v)) {} \n  (partition 2 (interleave %1 %2)))","problem":61,"user":"4e6f1b7a535d5021c1a89618"},{"problem":61,"code":"(fn zip [ks vs]\n  (if (or (empty? ks) (empty? vs))\n    {}\n    (assoc (zip (rest ks) (rest vs)) (first ks) (first vs))))","user":"58a5a099e4b01a0c0b232918"},{"code":"(fn [l1 l2]\n  (apply assoc {}\n    (interleave\n      l1 l2\n    )\n  )\n)","problem":61,"user":"4fc8f671e4b0ee37620e1840"},{"code":"(fn [keys vals]\n  (reduce (fn [map [k v]] (assoc map k v)) {} (partition 2 (interleave keys vals))))","problem":61,"user":"4dbb0f2d535d1e037afb21b1"},{"code":"(fn [a, b] \r\n(apply hash-map (interleave a b)))","problem":61,"user":"4ddeb916535d08e6dec9fdd9"},{"problem":61,"code":"(fn zmap [ks vs](apply hash-map (interleave ks vs)))","user":"5545477fe4b0a04f79299531"},{"code":"(fn z [k v]\n  (when (and (first k) (first v))\n    (merge {(first k) (first v)} (z (rest k) (rest v)))))","problem":61,"user":"4ea0c284535d7eef308072ad"},{"problem":61,"code":"(fn\n    [k v]\n    (apply hash-map (interleave k v))\n    )","user":"6074f5ede4b069485764de52"},{"problem":61,"code":"(fn f [s1 s2]\n  (reduce merge (map #(assoc {} % %2) s1 s2)))","user":"55a62092e4b0acc240e31554"},{"code":"#(apply assoc {} (reverse (interleave %2 %)))","problem":61,"user":"4f045946535dcb61093f6bba"},{"code":"(fn [ks vs]\n  ((fn build [ks vs m]\n      (if (or (empty? ks) (empty? vs))\n        m\n        (recur\n          (rest ks)\n          (rest vs)\n          (assoc m (first ks) (first vs)))))\n    ks vs {}))","problem":61,"user":"4f047902535dcb61093f6bcc"},{"problem":61,"code":"(fn[a b](apply hash-map(mapcat vector a b)))","user":"5f1eec36e4b0f565ad998274"},{"problem":61,"code":"(fn zipmap-ms\n  [keyss values]\n  (into {} (map vector keyss values)))","user":"561ca6ebe4b064ca9f4b169c"},{"code":"(fn f [x y]\n  (if (or (empty? x) (empty? y))\n    {}\n    (conj (f (rest x) (rest y)) {(first x) (first y)})))","problem":61,"user":"52379c46e4b0fae3832e99db"},{"problem":61,"code":"(comp (partial into {}) (partial map #(->[% %2])))","user":"555c38d9e4b0b056612e2249"},{"code":"(fn mm [ks vs]\n  (if (or (empty? ks) (empty? vs))\n    {}\n    (let [k (first ks)\n          v (first vs)]\n      (conj {k v} (mm (next ks) (next vs))))))","problem":61,"user":"50fe2420e4b03cd852b4e84a"},{"problem":61,"code":";#(apply hash-map (interleave %1 %2))\n#(apply array-map (interleave %1 %2))","user":"5c683fb5e4b0fca0c16226d5"},{"problem":61,"code":"(fn [ks vs]\n  (into {}\n        (map vector ks vs)))","user":"512e31e9e4b0b740abc59823"},{"problem":61,"code":"(fn [a b] (into {} (map (fn [c d] [c d]) a b)))","user":"59fa5773e4b0ca45a743a35e"},{"code":"(fn m [l1 l2]\n  (if (and (> (count l1) 0) (> (count l2) 0))\n    (conj (m (rest l1) (rest l2)) (vector (first l1) (first l2)))\n    {}\n    )\n  )","problem":61,"user":"52d92f13e4b09f7907dd13a2"},{"problem":61,"code":"#(reduce conj (map (fn [x y] {x y}) %1 %2))","user":"58524875e4b0b7285a6f4ead"},{"problem":61,"code":"#(reduce-kv (fn [m _ v] (assoc m (first v) (last v))) {} (vec (partition 2 (interleave % %2))))","user":"51412b0ae4b0694e2952b79d"},{"code":"(fn\n  [keys values]\n  (loop [a {}\n         ks keys\n         vs values]\n        (if (and ks vs)\n            (recur (assoc a (first ks) (first vs)) (next ks) (next vs))\n            a)))","problem":61,"user":"52dfc89be4b09f7907dd1405"},{"problem":61,"code":"(fn zipmap' \n  [keys vals]\n  (->> (for [index (range (min (count keys) (count vals)))\n             :let [key (nth keys index)\n                   val (nth vals index)]]\n         [key val])\n       (into {})))","user":"5fe5a64de4b05ac5b16ea187"},{"problem":61,"code":"(fn zipper [x y] (if (or(= 0(count x)) (= 0(count y)))\n                     {}\n                     (merge (assoc {} (first x) (first y)) (zipper (drop 1 x) (drop 1 y)))))","user":"604f4be1e4b0b7ec0ac60ace"},{"problem":61,"code":"(fn kzip [ks vs] \n  (if (or (empty? ks) (empty? vs))\n    (hash-map) \n    (assoc (kzip (rest ks) (rest vs)) (first ks) (first vs))))","user":"60b2aaebe4b0e0fa5f1b4228"},{"problem":61,"code":"(fn my-zipmap\n  [ks vs]\n  (apply merge (map #(assoc {} %1 %2) ks vs)))","user":"5d9c8a85e4b0eb781811cdad"},{"code":"(fn [ks vs]\n  (into {} (map hash-map ks vs)))","problem":61,"user":"50630247e4b05ac47bc68d6b"},{"code":"(fn [keys values]\n    (loop [keys keys values values result {}]\n      (if (and (seq keys) (seq values))\n        (recur\n         (rest keys)\n         (rest values)\n         (conj result [(first keys) (first values)]))\n        result\n        )))","problem":61,"user":"52a7634ae4b0c58976d9ac16"},{"code":"(fn[k,v](apply hash-map(interleave k v)))","problem":61,"user":"4df1e213535d08e6dec9fe20"},{"problem":61,"code":"(fn\n  [ks vs]\n  (into {} (map vector\n       ks vs)))","user":"5afcd6d1e4b0cc2b61a3bd17"},{"code":"(fn solution [v1 v2]\n  (if (or (empty? v1) (empty? v2))\n    {}\n    (assoc (solution (rest v1) (rest v2)) (first v1) (first v2))\n  )\n)","problem":61,"user":"52b49aebe4b0c58976d9ad2b"},{"problem":61,"code":"(fn f [ks vs]\n  (if (or (empty? ks) (empty? vs))\n    nil\n    (assoc (f (rest ks) (rest vs)) (first ks) (first vs))))","user":"5c62979fe4b0fca0c162264c"},{"code":"(fn [k v] (apply merge (map (fn [k v] { k v }) k v)))","problem":61,"user":"5080a697e4b01a93d3f38e49"},{"problem":61,"code":"(fn __ [k v] (apply hash-map (interleave k v)))","user":"5be2e670e4b0ed4b8aab4ccc"},{"code":"(fn [keys vals] (apply hash-map \n  (interleave keys vals)))","problem":61,"user":"504e108ce4b078edc5f593b3"},{"problem":61,"code":"(fn[x y](into {} (map vector x y)))","user":"6001460ce4b074f607df6611"},{"code":"(fn [k v] (apply hash-map (interleave (seq k) (seq v))))","problem":61,"user":"5175616ae4b0dea9bbfba576"},{"problem":61,"code":"(fn [ks vs]\n     (reduce\n       (fn [m [k v]]\n         (assoc m k v))\n       {}\n       (map\n         (fn [k v]\n           [k v])\n         ks\n         vs)))","user":"5b999af8e4b0c0b3ffbd4ad3"},{"code":"(fn [ks vs]\n    (reduce #(let [[k v] %2] (assoc %1 k v)) {} (partition 2 (interleave ks vs))))","problem":61,"user":"51c3c6a6e4b0851ac09658f8"},{"code":"(fn zipmap2 [ks vs]\n  (apply hash-map (interleave ks vs)))","problem":61,"user":"4faafccde4b081705acca209"},{"problem":61,"code":"(fn [ks vs]\n  (loop [m {}\n         ks ks\n         vs vs]\n    (if (or (empty? ks) (empty? vs))\n      m\n      (recur (assoc m (first ks) (first vs)) (rest ks) (rest vs)))))","user":"5cf6522be4b0b71b1d808a58"},{"problem":61,"code":"(fn [v1 v2]\n  (reduce #(assoc %1 (first %2) (second %2)) {} (partition 2 (interleave v1 v2))))","user":"53bd476ae4b0d9a98559a6ca"},{"problem":61,"code":"(fn [fst sen]\n  (reduce (fn [res [key value]] (assoc res key value)) {} (map vector fst sen)))","user":"570e6974e4b0b0fb43fd06ef"},{"problem":61,"code":"(fn [lis1 lis2]\n  (into {} \n        (map (fn [a b]\n               [a b]) lis1 lis2)))","user":"59636b49e4b066ee0a44b0c5"},{"problem":61,"code":"(fn mb [ks xs]\n  (into {} (map #(identity {%1, %2}) ks xs)))","user":"5a0ce1a5e4b04bbd27e6d9b7"},{"problem":61,"code":"#(loop [ks %1 vs %2 res {}]\n   (if (and ks vs)\n     (recur (next ks) (next vs) (assoc res (first ks) (first vs)))\n     res))","user":"503f923fe4b00d1a725ff2ad"},{"code":"(fn [keys vals] \n  (loop [map {} ks keys vs vals]\n    (if (or (empty? ks) (empty? vs)) map\n        (recur (assoc map (first ks) (first vs)) \n                (rest ks) (rest vs)))))","problem":61,"user":"4eb9353f535dfed6da9c6d4e"},{"code":"#(into {} (map (fn [a b] [a b]) % %2))","problem":61,"user":"51e38568e4b0c611d6113e43"},{"code":"(fn [ks vs] (apply merge (map (fn [k v] (hash-map k v)) ks vs)))","problem":61,"user":"53710c09e4b0fc7073fd6ea5"},{"code":"#(reduce (fn[acc,e](assoc acc (first e) (second e))) {} \n         (map (fn[x,y][x y]) %1 %2))","problem":61,"user":"4ec75829535d6d7199dd36e1"},{"problem":61,"code":"(fn [ks, vs] (apply assoc {} (interleave ks vs)))","user":"5ed875abe4b016b56eae05f2"},{"problem":61,"code":"(fn [a b] (apply assoc {}(interleave a b)))","user":"5256c4c1e4b0541d1855ba36"},{"problem":61,"code":"(fn create [a b]\n  (apply hash-map (mapcat list a b)))","user":"57fc34f0e4b0d3187e90098e"},{"problem":61,"code":"(fn [arr1 arr2] \n  (let [shortest-array-length (count (first (sort-by count [arr1 arr2])))]\n    (reduce merge (map-indexed (fn [i n] {(nth arr1 i) (nth arr2 i)}) (range 0 shortest-array-length)))))","user":"504f9ae1e4b0a02f9cffde9c"},{"problem":61,"code":"(fn my-zip-map [keys vals]\n  (loop [map {} ks keys vs vals]\n    (if (and ks vs)\n      (recur (assoc map (first ks) (first vs)) (next ks) (next vs))\n      map)))","user":"570ab24fe4b0b0fb43fd06b7"},{"code":"#(into {} ((comp (partial map vec) (partial partition 2) interleave) %1 %2))","problem":61,"user":"4f294c48e4b0d6649770a023"},{"code":"(fn create-maps [keys vals]\n  (into {} (map vector keys vals)))","problem":61,"user":"4f35b2ace4b0e243712b1ec5"},{"code":"(fn map-construct [coll1 coll2]\n  (apply hash-map (interleave coll1 coll2)))","problem":61,"user":"4e95a440535dbda64a6f6b37"},{"problem":61,"code":"(fn x [ks vs] \n  (into {} (map hash-map ks vs))\n)","user":"5b8ec146e4b0c0b3ffbd49f0"},{"problem":61,"code":"(fn [keys vals] \n  (loop [map {} \n         ks (seq keys)\n         vs (seq vals)]\n    (if (and ks vs)\n      (recur (assoc map (first ks) (first vs))\n             (next ks)\n             (next vs))\n      map)))","user":"5d046f7ce4b0cc9c915881d5"},{"problem":61,"code":"(fn map-\n  [k v]\n  (apply hash-map (interleave k v)))","user":"5d7b90ede4b02e6b30c93552"},{"problem":61,"code":"(fn [kss vss]\n  (loop [res {} \n         ks (seq kss) \n         vs (seq vss)]\n    (if (and ks vs)\n      (recur (assoc res (first ks) (first vs))\n             (next ks)\n             (next vs))\n      res)))","user":"5a6af090e4b0512ff01cda2d"},{"problem":61,"code":"(fn [ks vs]\n    (into\n      {}\n      (map #(vector %1 %2) ks vs)))","user":"5c9dcb36e4b048ec896c5b1d"},{"code":"#(apply assoc (cons {} (interleave %1 %2)))","problem":61,"user":"4f2e0369e4b0d6649770a064"},{"problem":61,"code":"(fn map-constr [ks vs]\n  \n  ; loop through the keys\n  (loop [res {} index 0]\n    (println (count ks))\n    (if (or (= index (count ks)) (= index (count vs)))\n      res\n      \n      (recur (assoc res (get ks index) (get vs index) ) (inc index))\n      \n      ) ; if end\n    \n    ) ; loop end\n  \n  ) ; fn en","user":"5ff676a9e4b06df49cee1497"},{"problem":61,"code":"(fn [keys values] (into {} (map #(hash-map %1 %2) keys values)))","user":"5582dfb6e4b05c286339e10d"},{"code":"(fn [coll1 coll2] (loop [x (min (count coll1) (count coll2)) a coll1 b coll2 result {}] (if (== x 0) result (recur (dec x) (rest a) (rest b) (conj  result {(first a) (first b)}) ))))","problem":61,"user":"52b60e94e4b0c58976d9ad3e"},{"problem":61,"code":"(fn [keys vals]\n  (loop [res {} k keys v vals]\n    (if (and k v)\n      (recur (assoc res (first k) (first v)) (next k) (next v))\n      res)))","user":"5799b260e4b05b1deef9adc8"},{"code":"(fn [k v]\n  (apply hash-map (interleave k v)))","problem":61,"user":"4e1f9bb5535d04ed9115e80d"},{"code":"(fn mapita [k v] (if (or (empty? k) (empty? v)) {}\n                     (assoc (mapita (rest k) (rest v)) (first k) (first v))))","problem":61,"user":"52474ec2e4b05ef8e38e6361"},{"problem":61,"code":"(fn [k v]\n  ((fn inner [acc ks vs] \n    (if (or (empty? ks) (empty? vs))\n      acc\n      (recur (assoc acc (first ks) (first vs)) (rest ks) (rest vs))\n    )\n  ) {(first k) (first v)} (rest k) (rest v))  \n)","user":"5cfd5a93e4b0cc9c91588168"},{"problem":61,"code":"(fn [k v]  \n      (reduce conj (for [i (range (min (count k) (count v)))]\n                     (hash-map (k i) (v i)))))","user":"53623eaee4b0243289761e4f"},{"problem":61,"code":"(fn [keys vals]\n  (reduce #(into %1 %2)\n           (map hash-map keys vals)))","user":"5d4b2155e4b0776584bd6f28"},{"problem":61,"code":"(fn [keyColl valColl]\n  (into \n   {} \n   (map vector keyColl valColl)))","user":"5b3251c1e4b025bcb146f317"},{"problem":61,"code":"(fn [ks vs]\n    (loop [remaining_keys ks\n           remaining_vals vs\n           map_done {}]\n      (if (or (empty? remaining_keys) (empty? remaining_vals))\n        map_done\n        (recur (rest remaining_keys) (rest remaining_vals) (assoc map_done (first remaining_keys) (first remaining_vals))))))","user":"592ac17ae4b072a2710fcf26"},{"problem":61,"code":"(fn [keys values]\n  (loop [keys keys\n         values values\n         res {}]\n    (if (or (empty? values) (empty? keys))\n      res\n      (recur (rest keys) (rest values) (assoc res (first keys) (first values))))))","user":"54b31445e4b09f271ff37d35"},{"code":"(fn zip-map [ks vs]\n  (into {} (map vector ks vs)))","problem":61,"user":"532ab0bde4b09d4e7a9b5527"},{"problem":61,"code":"(fn zmap [ks vs]\n  (->> (interleave ks vs)\n      (partition 2)\n      (map #(vec %))\n      (into {})))","user":"5532a04ee4b09218d5f44f82"},{"problem":61,"code":"#( apply hash-map ( interleave %1 %2 ) )","user":"57561529e4b02ea1147992d3"},{"code":"(fn map-construction [coll1 coll2]\n  (loop [result {} \n         coll1 coll1\n         coll2 coll2]\n    (if(or(empty? coll1)\n          (empty? coll2))\n      result\n      (let[f1 (first coll1)\n           f2 (first coll2)]\n        (recur\n          (assoc result f1 f2)\n          (rest coll1)\n          (rest coll2))))))","problem":61,"user":"5273562ae4b03e8d9a4a7479"},{"code":"#(apply hash-map (apply concat (partition 2 (interleave %1 %2))))","problem":61,"user":"52cc85abe4b07d0d72b27367"},{"problem":61,"code":"(fn [ks vs]\n  (apply merge (map #(->{%1 %2}) ks vs)))","user":"50eeeadae4b02c17778c91f3"},{"problem":61,"code":"(fn [n m]\n  (apply hash-map (interleave n m)))","user":"5668aad0e4b04acd4f672df5"},{"problem":61,"code":"(fn my-zipmap\n    ([x y] (my-zipmap x y {}))\n    ([x y m]\n     (if (or (empty? x) (empty? y))\n       m\n       (my-zipmap (rest x) (rest y) (assoc m (first x) (first y)))\n       )))","user":"5d52bf29e4b0776584bd6f69"},{"problem":61,"code":"#(reduce into {}\n   (map\n    (fn zm [a b] (assoc {} a b)) %1 %2 ))","user":"5d5c6675e4b09db18d4482ec"},{"code":"(fn g [l1 l2] (if (or (empty? l1) (empty? l2))\n                 \t\t{}\n                 \t\t(conj \n                         {(first l1) (first l2)}\n                         (g (rest l1) (rest l2))\n                         )))","problem":61,"user":"4f2004a1535d64f6031464a7"},{"problem":61,"code":"#(loop\n   [ks %1\n    vs %2\n    res {}]\n   (if (or (empty? ks) (empty? vs))\n       res\n       (recur (rest ks) (rest vs) (into res {(first ks) (first vs)}))))","user":"5f0b8243e4b0f30dddfb5d45"},{"code":"(fn makemap [x y] (if \n                    (or (= 0 (count y)) (= 0 (count x)))\n                    {}\n                    (assoc \n                      (makemap (rest x) (rest y))\n                      (first x) (first y)\n                      )\n                    ))","problem":61,"user":"51fc44c5e4b0f1313d468a1b"},{"code":"(fn [x y] \n  (reduce merge (map #(assoc {} %1 %2) x y)))","problem":61,"user":"4dc0f7ff535d020aff1edf82"},{"problem":61,"code":"(fn z-map [k v]\n (reduce merge (map #(%1 %2) (map #(partial hash-map %) k) v)) )","user":"53d70f3be4b0e771c302545f"},{"code":"(fn [kin vin]\n  (loop [ks kin vs vin acc {}]\n    (if (or (empty? ks) (empty? vs))\n      acc\n      (recur\n        (rest ks)\n        (rest vs)\n        (assoc acc (first ks) (first vs))))))","problem":61,"user":"515828b8e4b0a069fd272c71"},{"code":"(fn [k v]\n  (apply assoc {}\n    (interleave k v)))","problem":61,"user":"4eb59464535d7eef30807369"},{"code":"(fn [ks vs]\n  (loop [ke ks ve vs acc {}]\n    (if (or (empty? ke) (empty? ve)) \n      acc\n      (recur (rest ke) (rest ve) (assoc acc (first ke) (first ve))))))","problem":61,"user":"4f418eaee4b0d7d3c9f3fce9"},{"problem":61,"code":"(fn [a b]\n  (apply hash-map (interleave a b))\n )","user":"5a984657e4b0d174b936c78a"},{"code":"(fn [k v] (->> v (interleave k) (apply hash-map)))","problem":61,"user":"4ff6aea8e4b0678c553fc381"},{"problem":61,"code":"(fn [c1 c2] (into {} (mapv #(into [] %) (partition 2 (interleave c1 c2)))))","user":"54246d6de4b01498b1a71aec"},{"code":"(fn zipm [keys vals]\n  (if (or (empty? keys) (empty? vals))\n    {}\n    (assoc (zipm (rest keys) (rest vals)) \n           (first keys) (first vals))))","problem":61,"user":"503e6047e4b06c4e0e1fa266"},{"problem":61,"code":"(fn my-61\n  [ks vs]\n  (reduce (fn [res [k v]] (into res {k v})) {} (partition 2 (interleave ks vs))))","user":"56c3aca0e4b05cc29241ee90"},{"code":"(comp #(apply hash-map %) interleave)","problem":61,"user":"4ebe766d535dfed6da9c6d94"},{"code":"(fn [ks xs] (apply hash-map (mapcat vector ks xs)))","problem":61,"user":"4f8c6bf6e4b02e764a0a519b"},{"problem":61,"code":"#(->> %& (apply map vector) (reduce (fn [m [k v]] (assoc m k v)) {}) )","user":"57c1b32be4b05aa3c4741ca4"},{"problem":61,"code":"(fn\n    [list1 list2]\n    (apply hash-map (interleave list1 list2)))","user":"5e950310e4b0fbed045a3802"},{"code":"(fn [x y] (apply hash-map (apply concat (map #(list % %2) x y))))","problem":61,"user":"50be9b4ae4b00fb48fed2ef6"},{"problem":61,"code":"#(apply assoc {} (flatten (map vector %1 %2)))","user":"5f6b35c3e4b02876ed9fd04d"},{"problem":61,"code":"(fn [ks vs] (loop [ks ks\n                   vs vs\n                   kvs {}]\n                  (if (or (= 0 (count ks))\n                           (= 0 (count vs)))\n                    kvs\n                    (recur (rest ks) (rest vs) (conj kvs [(first ks) (first vs)])))))","user":"5e7bb000e4b085ba37836e1d"},{"problem":61,"code":"(fn makeMap [k v]\n  (into {}\n    (map #(vector %1 %2) k v)\n  )\n)","user":"571aae1fe4b07c98581c3b5a"},{"problem":61,"code":"(fn map-construction\n  ([keys values]\n   (map-construction keys values []))\n  ([keys values constructed-map]\n   (if (or (empty? keys) (empty? values))\n     (into {} constructed-map)\n     (map-construction (rest keys) (rest values) (conj constructed-map (conj [] (first keys) (first values)))))))","user":"5d896a64e4b0915913b1d3b8"},{"code":"#(apply hash-map (interleave %1 %2))\n\n;(fn intomap [keys vals]\n;  (if (or (empty? keys) (empty? vals))\n;    {}\n;    (conj {(first keys) (first vals)}\n;        (intomap (rest keys) (rest vals)))))","problem":61,"user":"4fc50bcbe4b081705acca375"},{"code":"(fn [la lb] (apply assoc {} (interleave la lb)))","problem":61,"user":"4fb86dc9e4b081705acca2d8"},{"code":"(fn build-map\n  ([ks vs] (build-map ks vs {}))\n  ([ks vs m]\n    (if (or (empty? ks) (empty? vs))\n      m\n      (build-map (rest ks) (rest vs) (conj m [(first ks) (first vs)]))\n    )\n  )\n)","problem":61,"user":"4fff00ede4b0678c553fc3fc"},{"problem":61,"code":"#(apply hash-map\n         (interleave % %2))","user":"5466aabbe4b01be26fd746e8"},{"problem":61,"code":"#(apply \n  hash-map (interleave %1  %2))","user":"5f792d48e4b02876ed9fd0c5"},{"code":"(fn create-map [ks vls]\n  (apply hash-map (interleave ks vls)))","problem":61,"user":"4fae4c11e4b081705acca248"},{"code":"(fn myzipmap[s1 s2]\n \n  (let [myzip \n   (fn myzip2[s1 s2]\n          (let \n            [ss1 (seq s1) \n             ss2 (seq s2)\n            ]\n          (cond (and ss1 ss2) \n           (lazy-seq \n             (cons [(first s1) (first s2)]\n                    (myzip2 (rest s1) (rest s2))\n              )      \n                    \n            ) \n            \n           )\n           \n          )\n  )\n        ]\n   (reduce (fn [acc pair]\n             (assoc acc (first pair) (second pair)) \n            \n            )\n            {}\n            (myzip s1 s2)\n   )\n    )\n )","problem":61,"user":"4fb03cf4e4b081705acca262"},{"code":"(fn [& x](apply hash-map (apply interleave x)))","problem":61,"user":"4f039bbe535dcb61093f6b39"},{"code":"(fn [xs ys] (apply assoc {} (interleave xs ys)))","problem":61,"user":"533696b9e4b0e30313ee6c7c"},{"problem":61,"code":"(fn [coll1 coll2]\n  (into {} (keep-indexed (fn [idx item1]\n                           (when-let [item2 (get coll2 idx)]\n                             [item1 item2]))\n                         coll1)))","user":"56a79eb0e4b07966d5a8a05d"},{"problem":61,"code":"(fn map-construct [k v]\n  (apply hash-map (interleave k v)))","user":"542c026ae4b0dad94371f29a"},{"code":"(fn [ks vs]\n  (loop [[k & krest] ks\n         [v & vrest] vs\n         acc {}]\n    (if (some nil? [k v])\n       acc\n       (recur krest vrest (assoc acc k v)))))","problem":61,"user":"53779a26e4b06839e8705e38"},{"code":"(fn [x y] (apply hash-map (mapcat #(list % %2) x y)))","problem":61,"user":"4f0478b0535dcb61093f6bcb"},{"problem":61,"code":"(fn zip-map [coll1 coll2]\n  (let [num1 (count coll1)\n        num2 (count coll2)]\n  (if (or (<= num1 1) (<= num2 1)) {(first coll1) (first coll2)}\n        (conj {(first coll1) (first coll2)} (zip-map (rest coll1) (rest coll2))))))","user":"568f2059e4b0dcc4269f40df"},{"problem":61,"code":"(fn [%1 %2] (into {} (map (fn [%1 %2] { %1 %2 }) %1 %2)))","user":"5a63f8bae4b0512ff01cd99f"},{"problem":61,"code":"(fn [m v]\n\t(apply hash-map (interleave m v)))","user":"59e55cc8e4b08badc2a0c555"},{"code":"(fn [k v] (apply hash-map (mapcat #(list % %2) k v)))","problem":61,"user":"53940789e4b0b51d73faaec3"},{"problem":61,"code":"(fn build-map [keys vals]\n  (loop [res {}\n         [head-key & tail-keys] keys\n         [head-val & tail-vals] vals]\n    (if (or (empty? tail-keys) (empty? tail-vals))\n      (assoc res head-key head-val)\n      (recur (assoc res head-key head-val) tail-keys tail-vals)\n      )\n    ))","user":"5dd67c22e4b0948ae9d9ad80"},{"problem":61,"code":"(fn mp [ks vs]\n  (if (or (empty? ks) (empty? vs))\n    {}\n  \t(assoc (mp (rest ks) (rest vs)) (first ks) (first vs))))","user":"5e98e8a9e4b0157ca96647dc"},{"problem":61,"code":"(fn  ([k v] (loop [s {} k k v v]\n           (if (or (empty? v) (empty? k)) s\n             (recur (assoc s (first k) (first v)) (rest k) (rest v))))))","user":"54d8cc38e4b0a52adc2e203e"},{"code":"#(apply hash-map (reduce concat (map (fn [a b] (list a b)) % %2)))","problem":61,"user":"4f067029535dcb61093f6c12"},{"problem":61,"code":"(fn [coll1 coll2]\n   (apply merge (map hash-map coll1 coll2)))","user":"5fb544f6e4b08cb800c85b4e"},{"code":"(fn [k v] (apply merge (map #(hash-map % %2) k v)))","problem":61,"user":"4eb13d60535d7eef3080733f"},{"problem":61,"code":"(fn mymap2 [c1 c2]\n  (into {} (map vector c1 c2)))","user":"5785c1d4e4b0ebec4cfb74e1"},{"problem":61,"code":";(fn [xs ys]\n;  (loop [x xs\n;         y ys\n;         out {}]\n;    (if (or (empty? x) (empty? y))\n;      out\n;      (recur (rest x) (rest y)\n;             (assoc out (first x) (first y))))))\n\n#(into {} (map vector %1 %2))","user":"57e4dbcbe4b0bfb2137f5ac3"},{"problem":61,"code":"(fn [a b]\n  (apply merge (map #(assoc {} %1 %2) a b)))","user":"5935151ee4b072a2710fd084"},{"code":"(fn make-map [ks vs]\n  (apply assoc {} (interleave ks vs)))","problem":61,"user":"4ee82ce9535d93acb0a6687a"},{"code":"(fn [coll-1 coll-2]\n  (into {} (mapcat hash-map coll-1 coll-2)))","problem":61,"user":"52fb903ee4b047fd5583700b"},{"problem":61,"code":"(fn make-map [ks vs]\n  (if (< (count ks) (count vs))\n    (reduce (fn [acc val] \n              (conj acc [val (nth vs (count acc))] )) \n            {}\n            ks)\n    (reduce (fn [acc val]\n              (conj acc [(nth ks (count acc)) val])) \n            {}\n            vs)))","user":"53350264e4b0656e627bfd73"},{"code":"(fn [x y] (reduce conj (map #(assoc {} %1 %2) x y)))","problem":61,"user":"52ce5056e4b07d0d72b2738f"},{"code":"(fn foo [k v]\n  (if (or (empty? k) (empty? v))\n    '()\n   (let [k1 (first k)\n         v1 (first v)]\n     (conj {k1 v1} (foo (rest k) (rest v))))))","problem":61,"user":"5220a770e4b0e6a83c8925a3"},{"code":"(fn [a b]\n  (loop [[k & a] a\n         [v & b] b\n         res {} ]\n    (if (or (nil? k) (nil? v) )\n       res\n       (recur a b (merge {k v} res))\n    )\n  )\n)","problem":61,"user":"5149c2f1e4b0829bd132edb0"},{"code":"(fn  [klist vlist]\n  (reduce #(assoc %1 (klist %2) (vlist %2)) {} (range (min (count klist) (count vlist)))))","problem":61,"user":"4e6e3a1e535d5021c1a89602"},{"code":"(fn myzip [x, y] \n    (if (or (empty? x) (empty? y))\n    (hash-map)\n    (assoc (myzip (rest x) (rest y)) (first x) (first y))))","problem":61,"user":"4eb0a757535d7eef3080733d"},{"problem":61,"code":"#(into {}  (map hash-map %1 %2))","user":"5e257a33e4b05b4b01516166"},{"code":"#(into {} (mapcat hash-map % %2))","problem":61,"user":"4f2c2ccbe4b0d6649770a050"},{"code":"#(reduce merge \n         (map (fn [k v] {k v}) %1 %2))","problem":61,"user":"51592b81e4b0394f658fe22c"},{"code":"(fn mapify [a b]\n  (apply hash-map (interleave a b)))","problem":61,"user":"4f4e4ecbe4b03ad3f0c10cbf"},{"problem":61,"code":"(fn map-construction\n  [ks vs]\n  (if (or (empty? ks) (empty? vs))\n    {} \n    (assoc (map-construction (rest ks) (rest vs)) (first ks) (first vs))))","user":"5574c172e4b05c286339e059"},{"code":"(fn [hash-keys hash-values]\n  (apply merge \n    (map #(hash-map %1 %2) hash-keys hash-values)))","problem":61,"user":"4f92884de4b0dcca54ed6caf"},{"problem":61,"code":"(fn [keys values]\n  (loop [i 0 m {}]\n    (if (= i (min (count keys) (count values))) m\n      (recur (inc i) (assoc m (get keys i) (get values i))))))","user":"535943b3e4b04ce2eb3ed295"},{"problem":61,"code":"(fn mc [xs ys]\n  (apply hash-map (flatten (map vector xs ys))))","user":"56069006e4b08b23635d3174"},{"code":"#(\n  (fn [v vv a]\n      (if (or (empty? v) (empty? vv))\n          (apply hash-map (reverse a))\n          (recur (rest v) (rest vv)\n                  (cons (first vv)\n                        (cons (first v) a)))))\n  % %2 ())","problem":61,"user":"4f404dcee4b0e243712b1fb0"},{"code":"(fn [l1 l2]\n  (loop [l1 l1 l2 l2 acc {}]\n    (if (or (empty? l2) (empty? l1))\n      acc\n      (recur (rest l1) (rest l2)\n             (assoc acc (first l1)\n                        (first l2))))))","problem":61,"user":"4e568873535d8a8b8723a283"},{"code":"(fn [keys vals]\n  (reduce conj {} (map vector keys vals)))","problem":61,"user":"5268eb68e4b03e8d9a4a71c6"},{"code":"#(into {} (map (fn [k v] {k v}) % %2))","problem":61,"user":"52b5edd1e4b0c58976d9ad3c"},{"problem":61,"code":"(fn [colla collb]\n   (->> (partition 2 (interleave colla collb))\n       (map #(into [] %))\n      (into (sorted-map))\n       ))","user":"5400e918e4b0de5c41848619"},{"code":"(fn [my-keys my-values]\n    (apply hash-map (interleave my-keys my-values)))","problem":61,"user":"4f4a8707e4b0d56e7bb92c12"},{"code":"#(loop [r {} k %1 v %2]\n   (if (or (empty? k) (empty? v)) r\n     \n     (recur (conj r [(first k) (first v)]) (rest k) (rest v))))","problem":61,"user":"5196568fe4b04c0af7ff3c1c"},{"problem":61,"code":"(fn [ks vs] \n  (apply assoc {}\n   (interleave ks vs)))","user":"598debf0e4b02b9968b84d2e"},{"problem":61,"code":"#(into {} (map (fn [f s] [f s]) %1 %2))","user":"553900d4e4b09218d5f44fe5"},{"code":"(fn [x y]\n  (apply sorted-map (flatten\n    (map\n      (fn [one two] (list one two))\n    x y)\n  ))\n)","problem":61,"user":"4e3456f9535deb9a81d77f2a"},{"problem":61,"code":"(fn map-construct [ks vs]\n  (reduce (fn [result item] (assoc result (first item) (second item))) {} (mapv (fn [x y] [x y]) ks vs)))","user":"5c24c654e4b07e362c2305a7"},{"code":"(fn [a b]\n  (loop [x a y b ret {}]\n    (if (and (next x) (next y))\n(recur (next x) (next y) (assoc ret (first x) (first y)))\n(assoc ret (first x) (first y)))))","problem":61,"user":"4eb27fad535d7eef3080734a"},{"problem":61,"code":"(fn [keys vals] (into (sorted-map) (map #(vector %1 %2) keys vals)))","user":"5cb556f9e4b026601754b934"},{"problem":61,"code":"#(->> (interleave % %2)\n      (partition 2)\n      (map vec)\n      (into {}))","user":"531a0709e4b08068f379ed87"},{"problem":61,"code":"(fn [ks vs] (apply merge (map #(assoc {} %1 %2) ks vs)))","user":"5169b23fe4b03f62cda68cee"},{"code":"(fn [x y] (reduce merge (map #(hash-map (first %) (second %)) (partition 2 (interleave x y)))))","problem":61,"user":"523eb110e4b057c4b7cd0a67"},{"problem":61,"code":"(fn [listA listB]\n  (apply hash-map (interleave listA listB)))","user":"59e4e3cbe4b08badc2a0c54a"},{"problem":61,"code":"(fn[param1 param2]\n               (->>\n                 (interleave param1 param2)\n                 (partition 2)\n                 (map vec)\n                 (into {})\n                 \n\n\n                 ))","user":"5ab575f8e4b073f17744263d"},{"code":"(fn [k v] \n  (let [kv (map vector k v)]\n    (reduce \n     (fn [x y] (assoc x (first y) (second y)))\n     {}\n     kv)))","problem":61,"user":"5226f8e9e4b04e78ff2e199a"},{"problem":61,"code":"(fn my-zip-map [seqOne seqTwo]\n  (->>\n    (map #(vector %1 %2) seqOne seqTwo)\n    (reduce (fn [map [key value]] (assoc map key value)) {})\n    )\n  )","user":"5aada061e4b073f17744257a"},{"problem":61,"code":"(fn [keys values]\n  (into {} (map vector keys values)))","user":"58ebd10de4b056aecfd47d49"},{"code":"#(apply hash-map (interleave  % %2))","problem":61,"user":"5191045ee4b0f8ef0be96bf3"},{"problem":61,"code":"(fn my-zip [left right]\n  (if (some nil? [left right])\n    {}\n    (let [[left-elem & rest-left] left\n          [right-elem & rest-right] right]\n      (conj (my-zip rest-left rest-right) [left-elem right-elem]))))","user":"5dc4719ae4b02f9375f4e1b5"},{"code":"(fn build-vex [keys values]\n  (into {} (map vector keys values)))","problem":61,"user":"4e50c894535dc968683fc4ee"},{"problem":61,"code":"(fn construct-map [ks vs]\n  (into (sorted-map) (map vector ks vs)))","user":"56255e2de4b00a550fc90297"},{"code":"(fn [ks vs]\n  (loop [ks ks vs vs d {}]\n    (if (or (empty? ks) (empty? vs))\n      d\n      (recur (rest ks) (rest vs) (assoc d (first ks) (first vs))))))","problem":61,"user":"52b8af15e4b07a9af57922b5"},{"code":"(fn [a b] (\n  reduce (fn [x i] (assoc x (nth a i) (nth b i))) {} (range 0 (min (count a) (count b)))\n))","problem":61,"user":"4f1595da535d64f603146444"},{"problem":61,"code":"(fn [c1 c2]\n  (into {} (map #(assoc {} %1 %2) c1 c2)))","user":"608ec5e4e4b03bd49d9f36c0"},{"problem":61,"code":"(fn z [ks vs]\n  (into {} (map (fn [k, v] [k, v]) ks vs)))","user":"58ef4db9e4b056aecfd47dc6"},{"problem":61,"code":"(fn [ks vs]\n  (reduce #(assoc %1 (first %2) (second %2))\n          {}\n          (map list ks vs)))","user":"5650b8a0e4b0284900eef6c3"},{"code":"#(apply assoc {}\n         (interleave %1 %2))","problem":61,"user":"5274eb56e4b03e8d9a4a74bb"},{"problem":61,"code":"(fn[x y] (loop[a x b y result {}] (if (or (empty? a) (empty? b)) result (recur (rest a) (rest b) (conj result {(first a) (first b)})))))","user":"53f1c05ee4b0742d9025b0e1"},{"problem":61,"code":";;#(apply sorted-map (flatten (map vector %1 %2)))\n;;#(apply assoc {} (flatten (map vector %1 %2)))\n;;#(apply sorted-map (interleave %1 %2))\n(comp (partial apply hash-map) interleave)","user":"57ee42c4e4b0bfb2137f5bb1"},{"code":"(fn [c1 c2] (apply merge (map #(hash-map %1 %2) c1 c2)))","problem":61,"user":"5125745ae4b05d10e3e395f9"},{"code":"(fn this [kv vv]\n  (cond (or (= (count kv) 0)\n            (= (count vv) 0)) {}\n        :else (conj (this (rest kv) (rest vv))\n                    {(first kv) (first vv)})))","problem":61,"user":"5021f0b3e4b00bba4502f7ac"},{"problem":61,"code":"#(loop [s (interleave %1 %2) r {}] (if (empty? s) r (recur (nthrest s 2) (assoc r (first s) (second s)))))","user":"55d29fb6e4b0e31453f64a59"},{"code":"(fn [c1 c2]\n  (loop [m {}\n        c1 c1\n        c2 c2]\n    (if (not (and (seq c1) (seq c2)))\n      m\n      (recur (assoc m (first c1) (first c2)) (rest c1) (rest c2))\n    )\n))","problem":61,"user":"4dc1e1e4535d020aff1edf90"},{"problem":61,"code":"#(apply hash-map (interleave %1 %2)\n  )","user":"5f3a8493e4b004f08c61c527"},{"problem":61,"code":"(fn [ks vs]\n  (reduce\n   (fn [m [k v]]\n     (assoc m k v))\n   {}\n   (map (fn [k v] [k v]) ks vs)))","user":"5881d1c2e4b0f1effa3b7644"},{"problem":61,"code":"(fn [keys vals]\n  (loop [ks keys, vs vals, r {}]\n    (if (or (empty? ks) (empty? vs))\n      r\n      (recur (rest ks) (rest vs) (merge r {(first ks) (first vs)})))))","user":"5c6e1006e4b0fca0c1622744"},{"problem":61,"code":"(fn [k, v]\n  (apply hash-map (interleave k v)))","user":"548f37c7e4b0e286459a1234"},{"code":"(fn [c d]\n (apply merge (map (fn [a b] (into {} {a b})) \n               c d)))","problem":61,"user":"4f00e9c7535dcb61093f6a33"},{"code":"#(apply array-map (mapcat (fn [a b]  [a b] ) %1 %2))","problem":61,"user":"4e86d3cf535dceadca46984c"},{"code":"(fn [ks vs] (apply hash-map (flatten (for [i (range 0 (min (count ks) (count vs)))] [(ks i) (vs i)]))))","problem":61,"user":"52244a77e4b01819a2de42d1"},{"problem":61,"code":"(fn to-map [[x & xs :as c1] [y & ys :as c2]]\n  (if (some empty? [c1 c2]) {}\n      (assoc (to-map xs ys) x y)))","user":"54b07c1ee4b09f271ff37d16"},{"problem":61,"code":"(fn [x y]\n    (loop [x-coll x\n           y-coll y\n           res {}]\n      (if (or (empty? x-coll) (empty? y-coll))\n        res\n        (recur (rest x-coll) (rest y-coll) (conj res {(first x-coll) (first y-coll)})))\n      )\n    )","user":"5b269cf3e4b063e2438bcc35"},{"problem":61,"code":"#(into (sorted-map) (map (fn [qv pv] [qv pv]) %1 %2))","user":"5e692be9e4b04a83ad7cd269"},{"code":"(fn [k v] (apply hash-map (vec (interleave k v))))","problem":61,"user":"50c4ff23e4b0210b849018b8"},{"code":"(fn [keys vals] (apply assoc {} (interleave keys vals)))","problem":61,"user":"534db51be4b084c2834f4aa6"},{"code":"(fn [keys vals] (loop [k (seq keys) v (seq vals) result {}]\n                  (if (or (empty? k) (empty? v))\n                      result\n                      (recur (rest k) \n                             (rest v)\n                             (assoc result (first k)  (first v))))))","problem":61,"user":"4f2aff4de4b0d6649770a044"},{"problem":61,"code":"(fn [allKeys allValues]\n   (loop [m {}\n          ks (seq allKeys)\n          vs (seq allValues)]\n     (if (and ks vs)\n       (recur (assoc m (first ks) (first vs))\n              (next ks)\n              (next vs))\n       m)))","user":"5073e7fde4b054001656accb"},{"problem":61,"code":"(fn [k m] (reduce into {} (apply map hash-map [k m])))","user":"57d1a0e6e4b0bd073c20236d"},{"code":"#( apply hash-map (interleave %1 %2))","problem":61,"user":"5307e4ece4b02e82168697a9"},{"code":"#(loop [fst %1 snd %2 dic {}]\n   (cond\n    (empty? fst) dic\n    (empty? snd) dic\n    :else (recur (rest fst) (rest snd) (conj dic [(first fst) (first snd)]))))","problem":61,"user":"5315a4f0e4b08068f379ed2e"},{"problem":61,"code":"#(into {} (map vector  %1 %2))","user":"5b759ca8e4b047b03b2036d0"},{"problem":61,"code":"#(into {} (map (partial assoc {}) %1 %2))","user":"548b7db8e4b0e286459a11fd"},{"code":"(fn [a b]\n  (loop [map {}\n         ks (seq a)\n         vs (seq b)]\n    (if (and ks vs)\n      (recur (assoc map (first ks) (first vs))\n             (next ks)\n             (next vs))\n      map)))","problem":61,"user":"4f2a7174e4b0d6649770a03e"},{"code":"(fn [klist vlist] \n  (loop [map {}\n         ks (seq klist)\n         vs (seq vlist)]\n    (if (and ks vs)\n      (recur (assoc map (first ks) (first vs))\n             (next ks)\n             (next vs))\n      map)))","problem":61,"user":"5154b16be4b0179c5115f4e2"},{"problem":61,"code":"(fn [ks vs] \n  (apply hash-map (interleave ks vs)))","user":"58dc81d1e4b0a4d5acaab69e"},{"problem":61,"code":"(fn [map-keys values]\n  (loop [map-keys map-keys\n         values values\n         mapped {}]\n    (if (or (empty? map-keys) (empty? values))\n      mapped\n      (recur \n       (rest map-keys) \n       (rest values) \n       (assoc mapped (first map-keys) (first values))))))","user":"5d68f5e6e4b0db5d338d1605"},{"problem":61,"code":"(fn [col1 col2]\n  (into {} (map (fn [x y] {x y} ) col1 col2 )))","user":"5b97c521e4b0c0b3ffbd4a9a"},{"problem":61,"code":"(fn mc [l1 l2]\n  (if (or (nil? l1) (nil? l2))\n    {}\n    (assoc (mc (next l1) (next l2)) (first l1) (first l2))))","user":"54b95f3de4b0ed20f4ff6eab"},{"problem":61,"code":"(fn -myzipmap[ks vs]\n  ((fn mysoc [acc i-keys i-vals]\n    (cond\n      (> 1 (count i-keys)) acc\n      (> 1 (count i-vals)) acc\n      (=    1 (count i-keys)) (merge acc {(first i-keys) (first i-vals)})\n      (not= 1 (count i-keys)) (merge acc {(first i-keys) (first i-vals)} (mysoc acc (rest i-keys) (rest i-vals)))\n    )\n  ) {} ks vs)\n)","user":"546113ffe4b01be26fd74699"},{"problem":61,"code":"(fn f [col c1 c2] (if-not (or (empty? c1) (empty? c2)) (f (assoc col (first c1) (first c2)) (rest c1) (rest c2)) col)) {}","user":"576df252e4b0979f8965156f"},{"problem":61,"code":"#(apply assoc {}\n          (interleave %1 %2))\n\n;; (fn [ks vs]\n;;     (into {} (map #(vector %1 %2) ks vs)))\n\n;; (comp (partial apply hash-map) interleave)\n\n;; #(apply array-map (interleave %1 %2))\n\n;; #(->> (interleave %1 %2)\n;;         (partition-all 2)\n;;         (map (partial apply vector))\n;;         (into {}))\n\n;; #(->> (interleave %1 %2)\n;;         (partition-all 2)\n;;         (map (partial apply vector))\n;;         (into {}))\n\n;; (fn [ks vs]\n;;     (letfn [(get-rst [kss vss rst]\n;;               (if (or (empty? kss) (empty? vss))\n;;                 rst\n;;                 (recur (rest kss)\n;;                        (rest vss)\n;;                        (merge rst {(first kss) (first vss)}))))]\n;;       (get-rst ks vs {})))","user":"591ad160e4b09b4ee5954bdf"},{"problem":61,"code":"(fn [ks vs]\n  (->> (map #(hash-map %1 %2) ks vs)\n       (reduce merge)\n       )\n  )","user":"6004c750e4b074f607df6645"},{"problem":61,"code":"#(into {} (map vector (apply list %1) %2))","user":"5b6962c1e4b0c6492753e787"},{"code":"(fn [c1 c2] (apply merge (map #(hash-map % %2) c1 c2)))","problem":61,"user":"4fdf2b50e4b05e33b9224f93"},{"code":"(fn zipmapj [k v]\n  (cond \n    (or (empty? k) (empty? v)) {}\n    :else\n      (assoc\n        (zipmapj (rest k) (rest v))\n        (first k) (first v))))","problem":61,"user":"4e6f578c535d5021c1a8961b"},{"code":"(fn [keys vals]\n  (loop [res {}\n         ks keys\n         vs vals]\n    (let [k (first ks)\n          v (first vs)]\n      (cond\n        (nil? k) res\n        (nil? v) res\n        :else (recur (assoc res k v) (rest ks) (rest vs))))))","problem":61,"user":"4f230dfbe4b0d66497709fe0"},{"code":"(partial (fn f [m s t] (if (or (empty? s) (empty? t)) m (assoc (f m (rest s) (rest t)) (first s) (first t)))) {})","problem":61,"user":"50ed4626e4b01236b1d4983c"},{"problem":61,"code":"#(loop [m {} ks (seq %1) vs (seq %2)] (if (and ks vs) (recur (assoc m (first ks) (first vs)) (next ks) (next vs)) m))","user":"58cfbd7ae4b03c36ff7e58ba"},{"code":"(fn [k v]\n    (apply merge (map #( array-map % %2) k v )))","problem":61,"user":"4f030775535dcb61093f6a43"},{"problem":61,"code":"(fn myzipmap [ks vs]\n  (reduce (fn [m [k v]]\n            (assoc m k v)\n            ) {} (map #(vector %1 %2) ks vs))\n  )","user":"5488872ee4b0e286459a11d3"},{"problem":61,"code":"(fn my-zipmap [[k & ks] [v & vs]]\n  (if (and k v) (assoc (my-zipmap ks vs) k v) {}))","user":"546c1f73e4b00cfc9eacc175"},{"problem":61,"code":"(fn [ks vs] (loop [ksuffix ks vsuffix vs result {}] (if (or (empty? ksuffix) (empty? vsuffix)) result (recur (rest ksuffix) (rest vsuffix) (assoc result (first ksuffix) (first vsuffix))))))","user":"5e1cc888e4b0dc959400853d"},{"problem":61,"code":"(fn [ks vs]\n  (loop [ks ks vs vs acc {}]\n    (if (or (empty? ks) (empty? vs))\n      acc\n      (recur (rest ks) (rest vs) (assoc acc (first ks) (first vs))))))","user":"54814dbee4b0e286459a116b"},{"problem":61,"code":"#(reduce into {} (map hash-map %1 %2))","user":"58a47197e4b01a0c0b2328f9"},{"code":"; lesson learned, map takes multiargs\n; vector can be a poor mans zip\n(fn zm [a b]\n  (letfn [\n\t\t(zip [a b]\n\t\t\t(lazy-seq\n\t\t\t\t(if (and (seq a) (seq b))\n\t\t\t\t\t(cons (list (first a) (first b)) (zip (rest a) (rest b)))\n\t\t\t\t\t())))\n\t\t]\n\n\t\t(reduce conj (map #(apply hash-map %) (zip a b)))\n\t))","problem":61,"user":"4ed72e51535d10e5ff6f52ee"},{"problem":61,"code":"#((fn [l1 l2 acc] \n  \t(if (empty? l1) \n    \tacc\n      \t(if (empty? l2)\n          acc\n\t    (recur (rest l1) (rest l2) \n               (into acc {(first l1) (first l2)})\n        ))\n    ))\n    %1 %2 {}\n    )","user":"53342a1ce4b019098a6f8b8b"},{"code":"(fn mkmap [k v]\n  (if\n    (or (empty? k) (empty? v)) {}\n    (conj {(first k) (first v)}\n      (mkmap (rest k) (rest v)))))","problem":61,"user":"504e48ace4b0f6ff3350c498"},{"problem":61,"code":"(comp #(apply hash-map %1) interleave)","user":"567476bde4b05957ce8c6139"},{"code":"(fn [a b] (apply merge (map (fn [x] (apply hash-map x)) ((fn [c1 c2] (map #(vector %1 %2) c1 c2)) a b))))","problem":61,"user":"4ef0a39b535dced4c769f20d"},{"problem":61,"code":"#(loop [m {} k %1 v %2] (if (or (empty? k) (empty? v)) m (recur (assoc m (first k) (first v)) (rest k) (rest v))))","user":"553c05b7e4b09218d5f45011"},{"problem":61,"code":"(fn zm [a b] (if (or (empty? a) (empty? b)) {} (assoc (zm (rest a) (rest b)) (first a) (first b))))","user":"5ed4482be4b016b56eae05ca"},{"code":"(fn [ks vs]\n  (reduce \n   (fn [m [k v]] (assoc m k v))\n   {}\n   (map vector ks vs)))","problem":61,"user":"50d8f4b6e4b01f0871336e74"},{"problem":61,"code":"(fn [keys values]\n  (loop [ks keys\n         vs values\n         result {}]\n    (if (or (empty? ks) (empty? vs))\n      result\n      (recur (rest ks) (rest vs) (conj result {(first ks) (first vs)})))))","user":"5954cea2e4b066ee0a44af0a"},{"problem":61,"code":"(fn my-zipmap [s1 s2]\n  (apply merge (map (fn[k v]\n                      {k v}) s1 s2)))","user":"52faf67ce4b047fd55837005"},{"code":"(fn [keys vals]\n  (loop [map {}\n         ks (seq keys)\n         vs (seq vals)]\n    (if (and ks vs)\n     (recur (assoc map (first ks) (first vs))\n             (next ks)\n             (next vs))\n      map)))","problem":61,"user":"4e6a73d0535d8ccf87e9fee7"},{"problem":61,"code":"(fn [a b]\n  (reduce\n   into\n   {}\n   (map #(into {} {%1 %2}) a b)\n   )\n  )","user":"5d6fae1ee4b04d129b00f2d4"},{"problem":61,"code":"(fn [xs ys]\n  (into {} (map (fn [x y] [x y]) xs ys)))","user":"501b1efee4b0b12d9c5f4d82"},{"code":"#(apply hash-map\n  (mapcat vector % %2))","problem":61,"user":"5089ebfee4b03217b26a539f"},{"problem":61,"code":"(fn [keys vals]\n  (into {} (map (fn [k v] [k v]) keys vals)))","user":"52d38c51e4b099d49816f0c5"},{"problem":61,"code":"(fn [first-vector other-vector]\n  (let [len (min (count first-vector) (count other-vector))\n        first-vector (take len first-vector)\n        other-vector (take len other-vector)]\n    (loop [acc {}\n           first-vector first-vector\n           other-vector other-vector]\n      (if (empty? first-vector)\n        acc\n        (recur (merge acc {(first first-vector) (first other-vector)}) (rest first-vector) (rest other-vector))))))","user":"5512aca6e4b055c2f668d4b4"},{"problem":61,"code":"(fn to-map [keys vals]\n        (into {}\n              (map #(vec %)\n                   (partition 2 (interleave keys vals))\n                   )\n              )\n        )","user":"57ca95f2e4b05aa3c4741d3b"},{"problem":61,"code":"(fn [ks vs]\n  (loop\n    [k ks\n     v vs\n     m {}]\n    (if (or (= k '()) (= v '()))\n      m\n      (recur (rest k) (rest v) (assoc m (first k) (first v))))))","user":"5b1c16e1e4b03cfeda66ecf2"},{"code":"(fn constr [v1 v2]\n  ( let [a (empty? v1)\n         b (empty? v2)]\n  (if (= a true) {}\n    ( if (= b true) {}\n      ( merge { (first v1) (first v2)} (constr (rest v1) (rest v2)))))\n  )\n)","problem":61,"user":"5060c117e4b024449d699b5d"},{"code":"(fn [coll1 coll2]\n  (apply merge (map hash-map coll1 coll2)))","problem":61,"user":"4ed7b617535d10e5ff6f52f3"},{"problem":61,"code":"(fn [ks vs]\n    (loop [ks ks vs vs out {}]\n      (if (or (empty? ks) (empty? vs))\n        out\n        (recur (rest ks) (rest vs) (assoc out (first ks) (first vs))))))","user":"5cc6f982e4b0ccb06196282d"},{"problem":61,"code":"(fn [keys vals]\n  (into {} (map vector keys vals))\n  )","user":"5a42dbabe4b0447ef91cc5fc"},{"code":"( fn foo[acc lst1 lst2] \n  (if \n    (or\n     (empty? lst1)\n     (empty? lst2)\n     )\n    acc\n    (foo (merge acc {(first lst1) (first lst2)}) (rest lst1) (rest lst2))\n    )\n  ) {}","problem":61,"user":"51eec1a6e4b0871fa145d98d"},{"code":"(fn [a b] (into {} (map #(hash-map % %2) a b)))","problem":61,"user":"4ddbdc1b535d02782fcbe9fd"},{"code":"(fn mkmp [x y]\n  (cond\n   (empty? x) {}\n   (empty? y) {}\n   :else (merge {(first x) (first y)} (mkmp (rest x) (rest y)))))","problem":61,"user":"51b89503e4b050a1176cd69a"},{"problem":61,"code":"(fn [ks vs]\n  (apply hash-map\n         (flatten (map vector ks vs))))","user":"5561d2c2e4b0c656e3ff17cd"},{"problem":61,"code":"(fn [ a b ] \n  (apply merge\n  (map-indexed (fn [idx el] (when (get b idx) (hash-map el (get b idx)))) a)))","user":"52737333e4b03e8d9a4a747f"},{"problem":61,"code":"(fn [keys values] (reduce (fn [memo [key value]] (assoc memo key value) ) {} (map list keys values)))","user":"516ee939e4b06aac486e5b34"},{"code":"(fn [k v]\n  (reduce #(merge %1 %2) {} \n(map #(vector %1 %2) k v)))","problem":61,"user":"4facd2fae4b081705acca22f"},{"problem":61,"code":"#(apply merge (map (fn [[k v]] {k v}) (map vector %1 %2)))","user":"5454b84ce4b0e397800069d9"},{"code":"#(into (hash-map) (map vector %1 %2))","problem":61,"user":"4faa8de0e4b081705acca1f8"},{"problem":61,"code":"(fn m [ks vs]\n  (apply hash-map (interleave ks vs)))","user":"5630fd6fe4b0bfe05bf1178b"},{"problem":61,"code":"(fn zip\n  [keys vals]\n  (reduce\n    #(apply (partial assoc %1) %2)\n    {} (map list keys vals)))","user":"57b1b8c8e4b0fbc9809a2756"},{"code":"#(reduce merge {} (map vector %1 %2))","problem":61,"user":"51ab1718e4b04e3dc0c27b2f"},{"problem":61,"code":"(fn [xs ys]\n  (apply assoc {}\n         (interleave xs ys)))","user":"5344fe13e4b084c2834f4a32"},{"code":"(fn [vallist maplist]\n (apply merge (map #(hash-map %1 %2)vallist maplist)))","problem":61,"user":"50621cbde4b0341461c88951"},{"code":"(fn [k v]\n  (loop [accu {}\n   k k\n\t v v]\n    (if (or (empty? k) (empty? v))\n      accu\n      (recur (assoc accu (first k) (first v)) (rest k) (rest v)))))","problem":61,"user":"4e82c062535db62dc21a62cc"},{"code":"(fn [a b] (loop [result {} A a B b]\n            (if (= 0 (count A)) result\n              (if (= 0 (count B)) result\n              (recur (merge result {(first A) (first B)}) (rest A) (rest B))\n             )\n           ))\n  )","problem":61,"user":"518aec06e4b06da86c1973c2"},{"problem":61,"code":"(fn [c1 c2] (apply hash-map (mapcat #(vector %1 %2) c1 c2)))","user":"54485727e4b032a45b8693c6"},{"problem":61,"code":"(fn zip [keys vals]\n  (->> (map (fn [k v] {k v}) keys vals)\n       (reduce merge)))","user":"5ff8ead1e4b06df49cee14ab"},{"problem":61,"code":"(fn \n  [ikeys ivals]\n  (loop [xs ikeys ys ivals acc {}]\n    (if (or (empty? xs) (empty? ys))\n      acc\n      (recur (rest xs) (rest ys) (assoc acc (first xs) (first ys))))))","user":"57995ac1e4b05b1deef9adbf"},{"code":"#(apply assoc {} \n         (interleave %1 %2))","problem":61,"user":"50dcb2f4e4b02e6ac9592c91"},{"problem":61,"code":"(fn my-zipmap [keys vals]\n  (loop [acc {}\n         keys keys\n         vals vals]\n    (if (and keys vals)\n      (recur (assoc acc (first keys) (first vals))\n             (next keys)\n             (next vals))\n      acc)))","user":"5db0d470e4b0f8c104ccfc9e"},{"code":"(fn [k v]\n  (into {} (map vector k v)))","problem":61,"user":"4ed9fe5f535d10e5ff6f5308"},{"code":"#(reduce merge (map hash-map % %2))","problem":61,"user":"4f463dfde4b0d56e7bb92b99"},{"code":"(fn [coll1 coll2]\n  (reduce \n    #(assoc %1 (first %2) (second %2))\n    {}\n    (map (fn [item1 item2] [item1 item2]) coll1 coll2)))","problem":61,"user":"4ec2fe3f535dcc7ae8597d4f"},{"problem":61,"code":"(fn [& xs]\n  (into {} (apply mapv vector xs)))","user":"5b4dfd5de4b02d533a91bcc3"},{"code":"(fn zip [ks vs]\n  (letfn [\n          (stop-condition [ks vs] (or (= 0 (count ks)) (= 0 (count vs))))\n          (zip-first [m ks vs] (assoc m (first ks) (first vs)))\n          (zip-iter [m ks vs] (if (stop-condition ks vs) m (zip-iter (zip-first m ks vs) (rest ks) (rest vs))))\n          ]\n    (zip-iter {} ks vs)))","problem":61,"user":"517531c6e4b07031762f2eea"},{"code":"(fn f [k v]\n  (loop [ck (first k)\n         nk (next k)\n         cv (first v)\n         nv (next v)\n         res {}]\n    (if (or (nil? ck) (nil? cv))\n      res\n      (recur (first nk) (next nk) (first nv) (next nv) (assoc res ck cv)))))","problem":61,"user":"52d7b0ade4b09f7907dd137c"},{"code":"(fn my-zipmap [c1 c2]\n  (loop [a (hash-map (first c1) (first c2)) b (rest c1) c (rest c2)]\n    (if (or (= b  '()) (= c '()))\n      a\n      (recur (conj a (hash-map (first b) (first c))) (rest b) (rest c)))))","problem":61,"user":"4f04d312535dcb61093f6be7"},{"code":"(fn [keys values]\n  (apply array-map (interleave keys values)))","problem":61,"user":"4ebc08a8535dfed6da9c6d7c"},{"problem":61,"code":"(fn [va vb]\n  (loop [result {} ra va rb vb]\n    (cond (empty? ra) result\n          (empty? rb) result\n          :else       (recur (conj result [(first ra) (first rb)]) (rest ra) (rest rb))\n)\n)\n)","user":"57d7c894e4b0bd073c2023de"},{"code":"(fn [a b]\n  (loop [a (seq a)\n         b (seq b)\n         r {}]\n    (if-let [cur1 (first a)]\n      (if-let[cur2 (first b)]\n        (recur (next a) (next b) (conj r {cur1 cur2}))\n        r)\n      r)))","problem":61,"user":"531e5c81e4b08068f379edba"},{"problem":61,"code":"(fn [x y] (into {} (mapcat (fn [i j] {i j}) x y)))","user":"53e91473e4b036ad0777e495"},{"code":"(fn [x y](reduce into (map #(into {} {%1 %2}) x y)))","problem":61,"user":"4edbca52535d10e5ff6f531e"},{"problem":61,"code":"(fn [ks vs] \n  (loop [k ks\n         v vs\n         r {}]\n    (if (or (empty? k)\n            (empty? v))\n      r\n      (recur (rest k) (rest v) (assoc r (first k) (first v))))))","user":"5283a919e4b0239c8a67adbe"},{"code":"(fn [x y] (into {} (map #(vec [%1 %2]) x y)))","problem":61,"user":"4f75469ee4b0fbe0118ec55a"},{"problem":61,"code":"(fn cons-map\n  ([xs-keys xs-values]\n    (cons-map xs-keys xs-values {}))\n  ([xs-keys xs-values coll]\n   (let [[first-key & rest-keys] xs-keys\n         [first-value & rest-values] xs-values]\n     (if (or (nil? first-key) (nil? first-value))\n       coll\n       (cons-map rest-keys rest-values (assoc coll first-key first-value))))))","user":"57e9a77ae4b0bfb2137f5b35"},{"code":"(fn [xs1 xs2] (into {} (map #(hash-map %1 %2) xs1 xs2)))","problem":61,"user":"52baea85e4b07a9af57922d9"},{"problem":61,"code":"(fn zm [[k & ks] [v & vs]]\n  (into {} (cons {k v} (if (or (nil? ks) (nil? vs)) nil (zm ks vs)))))","user":"5884e807e4b0f1effa3b76a6"},{"problem":61,"code":"(fn zip-map [k v]\n   (loop [keys k values v result {}]\n     (if (or (= '() keys) (= '() values))\n       result\n       (recur (rest keys) (rest values) (assoc result (first keys) (first values))))))","user":"6090e617e4b03bd49d9f36ce"},{"code":"(fn [a b] \n  (reduce \n    #(assoc % (first %2) (second %2)) \n    nil \n    (map #(list % %2) a b)))","problem":61,"user":"4f569218e4b0a7574ea71826"},{"code":"(fn [& args] (apply hash-map (apply interleave args)))","problem":61,"user":"50acbd15e4b071b89ef26234"},{"problem":61,"code":"(fn my-zip-map [ks vs]\n  (into {} (map vector ks vs)))","user":"556405e5e4b0c656e3ff17fb"},{"problem":61,"code":"#(apply hash-map (flatten (map (fn [key- value-] (vector key- value-)) %1 %2)))","user":"5602f5fce4b04bb52996e1ad"},{"problem":61,"code":"(fn [k, v] (apply assoc {} (interleave k v)))","user":"5a0a3473e4b0eab8c0448941"},{"problem":61,"code":"(fn [ks vs] \n  (let [s (-> vs ((partial interleave ks)) ((partial partition 2)))]\n  (into {} (map vec s))\n    )\n  )","user":"5a535572e4b05d388ecb6c0b"},{"code":"#(apply hash-map (mapcat  list %1 %2))","problem":61,"user":"50807940e4b01a93d3f38e44"},{"problem":61,"code":"(fn [a b]\n  (reduce conj (map #(assoc {} %1 %2) a b)))","user":"5829d588e4b051871117bf4a"},{"problem":61,"code":"(fn [a b] (into {} (map #(conj [] %1 %2) a b)))","user":"56795deae4b05957ce8c6187"},{"problem":61,"code":"(fn map-const\n  [f s]\n  (reduce #(assoc %1 (first %2) (second %2)) {} (map vector f s)))","user":"57d0cd58e4b0bd073c20235e"},{"code":"#(into {}\r\n  (for [i (range (count %1))]\r\n     (if (< i (count %2))\r\n\t      {(nth %1 i) (nth %2 i)})))","problem":61,"user":"4e273301535deb9a81d77ef7"},{"code":"(fn [a b] (apply hash-map (reduce (fn [x y] (concat x y)) (map list a b))))","problem":61,"user":"53638ed2e4b0243289761e5b"},{"problem":61,"code":"(fn mapcon [ks vs] \n    (loop [a {} k ks v vs]\n      (if (or (empty? k) (empty? v))\n      a\n      (recur (assoc a (first k) (first v)) (rest k) (rest v)))))","user":"569aca1ee4b0542e1f8d144d"},{"code":"(fn\n  [keys vals]\n    (apply merge {}\n      (for [x (range (count keys)) :when (< x (count vals))] {(nth keys x) (nth vals x)})))","problem":61,"user":"507a08e4e4b08327cd804a67"},{"code":"(fn [v1 v2] (into {} (map #(do [%1 %2]) v1 v2)))","problem":61,"user":"5392b849e4b0b51d73faaeb1"},{"problem":61,"code":"(fn my-zip [a b]\n  (if (or (empty? a) (empty? b))\n    {}\n    (assoc (my-zip (rest a) (rest b)) (first a) (first b))))","user":"58a0fc33e4b02bd94d917ea3"},{"problem":61,"code":"#(apply hash-map (vec (interleave %1 %2)))\n;#(apply hash-map (interleave %1 %2))\n;#(apply assoc {} (interleave %1 %2))","user":"57ee46c7e4b0bfb2137f5bb3"},{"code":"(fn my-zipmap [a b] (apply array-map (interleave a b)))","problem":61,"user":"4df669d4535d08e6dec9fe35"},{"problem":61,"code":"#(into {} (map-indexed (fn [idx itm] [itm (nth %2 idx)]) (take (min (count %) (count %2)) %)))","user":"604d3cb1e4b0b7ec0ac60ac2"},{"problem":61,"code":"(fn [k v] (into {} (map (fn [& m] (vec m)) k v)))","user":"54fce8bde4b07d26eda61d30"},{"code":"(fn my-zipmap ([ks vs] (my-zipmap ks vs {}))\n   ([[k & ks] [v & vs] m]\n    (if (or (empty? ks) (empty? vs))\n      (assoc m k v)\n      (recur ks vs (assoc m k v)))))","problem":61,"user":"4fe8d862e4b0547ebccb2428"},{"problem":61,"code":"(fn [& more]\n   (into {} (apply map (fn [& xs] (vec xs)) more)))","user":"585dbe41e4b0f14aab7c879f"},{"problem":61,"code":"(fn [ks vs]\n  (into (hash-map)\n        (map vector ks vs)))","user":"580bd81ee4b0849f6811b711"},{"problem":61,"code":"(fn [a b]\n  (loop [acc {}\n         x a\n         y b]\n    (cond\n     (or (nil? x) (nil? y)) acc\n     :else (recur (conj acc [(first x) (first y)]) (next x) (next y)))))","user":"54e79094e4b024c67c0cf818"},{"code":"(fn\n  [coll1 coll2]\n  (into {} (map hash-map coll1 coll2)))","problem":61,"user":"52ba447ee4b07a9af57922ce"},{"code":"(fn [c1 c2] (apply sorted-map (flatten (map #(vector %1 %2) c1 c2))))","problem":61,"user":"4f0c4518535d0136e6c2230b"},{"problem":61,"code":"(fn [keys vals]\n         (into {} (map #(vector %1 %2) keys vals)))","user":"55dcb06ee4b050e68259b3b9"},{"code":"(fn zm [one two]\r\n   (when (and one\r\n              two)\r\n     (conj {(first one) (first two)}\r\n           (zm (next one) (next two)))))","problem":61,"user":"4e0d8c27535d04ed9115e7b7"},{"code":"(fn my-zipmap [ks vs]\n  (loop [k (first ks)\n         v (first vs)\n         rest-k (rest ks)\n         rest-v (rest vs)\n         res {}]\n    (if (or (nil? k) (nil? v))\n      res\n      (recur (first rest-k) (first rest-v) (rest rest-k) (rest rest-v) (assoc res k v)))))","problem":61,"user":"4fb710f4e4b081705acca2cd"},{"code":"#(reduce  (fn [m [x y]] (assoc m x y)){} (map list % %2))","problem":61,"user":"4f7869c2e4b0fbe0118ec589"},{"problem":61,"code":"(fn [keys values]\n  (let [f (fn put-kv[m k v]\n            (if (and (seq k) (seq v))\n              (put-kv (assoc m (first k) (first v)) (rest k) (rest v))\n              m))]\n    (f {} keys values)))","user":"5463c824e4b01be26fd746c5"},{"code":"(fn [& x] (apply hash-map (apply interleave x)))","problem":61,"user":"521dceeae4b050d5da042802"},{"code":"(fn [keys vals] (apply hash-map (interleave keys vals)))","problem":61,"user":"4e14108c535d04ed9115e7dd"},{"problem":61,"code":"(fn[ks vs] (reduce merge(map hash-map ks vs)))","user":"5c852e3ae4b0c8042a70ce78"},{"problem":61,"code":"(fn myMap [keys values]\n  (loop [k keys v values result {}]\n    (if (or (empty? k) (empty? v)) \n      result\n      (recur (rest k) (rest v) (assoc result (first k) (first v))))))","user":"5e42ba49e4b01d43a70e8e6c"},{"code":"#(apply array-map (flatten (map vector % %2)))","problem":61,"user":"4ec5d62c535d6d7199dd36ba"},{"problem":61,"code":"(fn [k v] (apply merge (map #(hash-map %1 %2)  k v)))","user":"5a533cc0e4b05d388ecb6c09"},{"code":"(fn  [kys vals]\n  (loop [k (seq kys), v (seq vals), h (hash-map)]\n    (cond (or (empty? k) (empty? v)) h\n          :else (recur (rest k) (rest v) (assoc h (first k) (first v))))))","problem":61,"user":"538e36c7e4b0b51d73faae81"},{"code":"(fn [k v] (reduce conj {} (map (fn [& v] (vec v))k v)))","problem":61,"user":"4fb2101ce4b081705acca284"},{"problem":61,"code":";(fn [ks vs]\n;  (loop [m {} ks ks vs vs] ; you should seq\n;    (if (or (empty? ks) (empty? vs))\n;      m\n;      (recur (assoc m (first ks) (first vs))\n;             (rest ks)\n;             (rest vs)))))\n\n; see (source zipmap) :-)\n; empty? is fine but simply testing ks/vs is faster. However, you\n; have to use next instead of rest and (seq ks)/(seq vs) initially,\n; in case either is empty.\n(fn [ks vs]\n  (loop [m {} ks (seq ks) vs (seq vs)]\n    (if (and ks vs)\n      (recur (assoc m (first ks) (first vs))\n             (next ks)   ; careful, not rest\n             (next vs))\n      m)))\n\n; concise, only marginally slower\n;(fn [ks vs]\n;  (apply hash-map (interleave ks vs)))","user":"53576356e4b04ce2eb3ed27a"},{"problem":61,"code":"(fn [coll1 coll2]\n  (loop [[h1 & t1 :as coll1] coll1, [h2 & t2 :as coll2] coll2, res {}]\n    (if (or (empty? coll1) (empty? coll2))\n      res\n      (recur t1 t2 (assoc res h1 h2)))))","user":"5e9f38cce4b00a66d4a9517e"},{"problem":61,"code":"(fn [a b]\r\n          (apply assoc {} (interleave a b)))","user":"56f514cee4b046a417f92068"},{"problem":61,"code":"(fn [x y] (loop[i 0 res {}] \n                (if(and (< i (count x)) (< i (count y))) (recur (inc i) (conj res {(x i) (y i)})) res)))","user":"5971763fe4b01722bebd4c72"},{"problem":61,"code":"(fn [ks vs]\n  (reduce\n   (fn [m v] (assoc m (first v) (second v)))\n   {}\n   (map vector ks vs)))","user":"5d1e19c4e4b02ea6f0fb69af"},{"problem":61,"code":"(fn[k v]\n  ( apply assoc {} (interleave k v)))","user":"54651ef5e4b01be26fd746d5"},{"code":"(fn [keys vals]\n  (reduce #(assoc %1 (first %2) (second %2)) {}\n    (partition 2 (interleave keys vals))))","problem":61,"user":"4f04f847535dcb61093f6beb"},{"problem":61,"code":"(comp (partial apply hash-map) (partial mapcat #(list %1 %2)))","user":"58e7229fe4b056aecfd47cc4"},{"problem":61,"code":"(fn make-map [map-keys map-values] (\n   if (or (empty? map-keys) (empty? map-values)) {}\n   (assoc (make-map (rest map-keys) (rest map-values)) (first map-keys) (first map-values))\n                                    \n\t)\n)","user":"5471f090e4b094393f72dd6e"},{"problem":61,"code":"; first try:\n\n#(apply conj (map hash-map % %2))\n\n; perhaps this is better/more efficient:\n; #(into {} (map vector %1 %2))","user":"550fdc1de4b06e50f9beb17d"},{"problem":61,"code":"#(apply hash-map (mapcat (fn [a b] (list a b)) %1 %2))","user":"5a14228fe4b0ff51aa4b3193"},{"problem":61,"code":"(fn [ks vs] (reduce #(conj %1 %2) {} (map vector ks vs)))","user":"564127a9e4b08d4f616f5ef3"},{"problem":61,"code":"(comp (partial into {}) (partial map vec) (partial partition 2) interleave)","user":"5e909685e4b0cb016954634d"},{"problem":61,"code":"(fn [ks vs] (let [n (min (count ks) (count vs))] (loop [i 0 m {}] (if (= i n) m (recur (inc i) (assoc m (nth ks i) (nth vs i)))))))","user":"59468de7e4b07ddc2dafad88"},{"problem":61,"code":"(fn f\n  ([keys vals]\n   (f keys vals {}))\n  ([keys vals result]\n   (let [[k & ks] keys\n         [v & vs] vals]\n     (if (or (nil? k) (nil? v))\n       result\n       (recur ks vs (assoc result k v))))))","user":"524a9556e4b05ef8e38e64b1"},{"problem":61,"code":"(fn [keys vals]\n   (into {} (map vector keys vals)))","user":"569f7bc2e4b0542e1f8d1494"},{"problem":61,"code":"(fn [ks vs] (reduce (fn [agg [k v]] (assoc agg k v)) {} (map vector ks vs)))","user":"552d9b31e4b076ab5578f7eb"},{"code":"(fn [x y] (apply hash-map (mapcat list x y)))","problem":61,"user":"536a37efe4b0243289761eaa"},{"problem":61,"code":"(fn q61\n  ([ks vs] (q61 ks vs {}))\n  ([[k & ks] [v & vs] acc]\n   (if (and k v)\n     (q61 ks vs (into acc {k v}))\n     acc)))","user":"55916764e4b0604b3f94d57b"},{"code":"(fn [a b]\n  (into {} (for [i (range (min (count a) (count b)))] [(get a i) (get b i)])))","problem":61,"user":"519c0c6ee4b0a1d87b003450"},{"problem":61,"code":"(fn myzipmap [xs ys]\n  (loop [col1 xs\n        col2 ys\n        acc []]\n   (if (or (empty? col1) (empty? col2))\n     (apply hash-map acc)\n     (recur (rest col1) (rest col2) (conj acc (first col1) (first col2))))))","user":"544257b4e4b032a45b869379"},{"code":"(fn [& coll] (apply hash-map (apply interleave coll)))","problem":61,"user":"530caf86e4b02e82168697df"},{"problem":61,"code":"(fn map-construction [ks vs]\n  (loop [m {}\n         k ks\n         v vs]\n    (if (or (empty? k) (empty? v))\n      m\n      (recur (assoc m (first k) (first v)) (rest k) (rest v)))))","user":"5865c8f0e4b0f14aab7c884e"},{"code":"(fn [k v] (loop [headk (first k)\n                 ks k \n                 headv (first v)\n                 vs v\n                 res (hash-map)] (if (and (seq vs) (seq ks) )\n          (recur (first (rest ks)) (rest ks) (first (rest vs)) (rest vs)\n                  (assoc res headk headv)) res)))","problem":61,"user":"4efd98fa535de96065cf5086"},{"code":"( fn [x y] ( reduce conj {} (map #(assoc {} % %2) x y) ) )","problem":61,"user":"5061cc17e4b0a30dc9a35d34"},{"problem":61,"code":"#(reduce merge (mapcat (fn [x y] (conj [] (hash-map x y))) % %2))","user":"5e0e836fe4b099d064962fa8"},{"problem":61,"code":"(fn [k v]\n  (apply merge\n    (map #(assoc {} %1 %2) k v)))","user":"5b02ab12e4b0cc2b61a3bd53"},{"problem":61,"code":"(fn [k v](apply hash-map (interleave k v)))","user":"564348e1e4b08d4f616f5f26"},{"problem":61,"code":"(fn my-zipmap\n  [keyz values]\n  (loop [out []\n         xs keyz\n         ys values]\n    (if (or (empty? xs) (empty? ys))\n      (apply array-map out)\n      (recur (conj out (first xs) (first ys)) (rest xs) (rest ys)))\n    )\n  )","user":"560d4994e4b05f002753df3c"},{"problem":61,"code":"(fn [set1 set2]\n   (into {} (map vector set1 set2)))","user":"5840c068e4b089d5ab817df8"},{"problem":61,"code":"(fn [keys vals]\n   (loop [k (seq keys) v (seq vals) rslt {}]\n     (if (or (empty? k) (empty? v)) rslt\n         (recur (rest k)  (rest v) \n                (assoc  rslt (first k) (first v))))\n     ))","user":"572ac718e4b0f4d77e651242"},{"problem":61,"code":"#(loop [i 0\n        m {}]\n   (if (and (< i (count %1))\n            (< i (count %2)))\n   \t(recur (inc i) (assoc m (get %1 i) (get %2 i)))\n    m))","user":"57a4f5cae4b0a966079561f0"},{"code":"(fn [keys values]\n  (loop [k keys v values answer (hash-map)]\n    (if (or (empty? k) (empty? v)) answer\n       (recur\n         (rest k)\n         (rest v)\n         (assoc answer (first k) (first v))\n       )\n    )\n  )\n)","problem":61,"user":"50bfbf25e4b05ae8c1cbbd9b"},{"problem":61,"code":"(fn\n  [coll1 coll2]\n  (into {} (map vector coll1 coll2)))","user":"5a3c06fce4b001c08efc0cdd"},{"problem":61,"code":"(fn [ks vs]\n  (reduce into {} (map #(assoc {} %1 %2) ks vs)))","user":"574e84e0e4b02ea114799243"},{"code":"(fn zipcat* [& cols]\n  (reduce #(assoc %1 (first %2) (second %2)) {} (apply map list cols)))","problem":61,"user":"51d662fce4b0154f82ab92ef"},{"problem":61,"code":"(fn maps [n s]\n  (apply hash-map(interleave n s)))","user":"6085edade4b0736b099e42fc"},{"problem":61,"code":"(fn [ks vs]\n  (loop [ks ks\n         vs vs\n         acc {}]\n    (if (or (empty? ks) (empty? vs))\n      acc\n      (recur (rest ks) (rest vs) (assoc acc (first ks) (first vs)))\n    )\n  )\n)","user":"540f09b9e4b0addc1aec6725"},{"problem":61,"code":"(fn [ks vs] \n   (loop [iks ks ivs vs acc {}] \n     (if (or (empty? iks) (empty? ivs))\n       acc \n       (recur (rest iks) (rest ivs) (assoc acc (first iks) (first ivs))))))","user":"53c06438e4b0c98a41f5ccb0"},{"code":"(fn zipmap-61 [ks vs]\n  (loop [newmap {}\n         ks ks\n         vs vs]\n    (if (and ks vs)\n      (recur (assoc newmap (first ks) (first vs))\n             (next ks)\n             (next vs))\n      newmap)))","problem":61,"user":"501b1a8ee4b0b12d9c5f4d81"},{"code":"(fn [lista listb]\n    (loop [a lista b listb m {}]\n       (if (or (empty? a) (empty? b)) m\n           (recur (rest a) (rest b)\n                (assoc m (first a) (first b)))\n)))","problem":61,"user":"4db883e1535d1e037afb2198"},{"code":"(fn [ks vs]\n  (apply hash-map\n    (flatten\n      (map list ks vs))))","problem":61,"user":"4ee67d74535d93acb0a66861"},{"problem":61,"code":"(fn [k, v] \n  (loop [remainingKeys k\n         remainingValues v\n         output {}]\n    (if (or (= remainingKeys []) (= remainingValues []))\n      output\n      (recur (rest remainingKeys) (rest remainingValues) (assoc output (first remainingKeys) (first remainingValues))))))","user":"54336443e4b0b6b47310fcde"},{"code":"(fn my-zipmap [keys vals]\n  (loop [map {}\n         ks (seq keys)\n         vs (seq vals)]\n    (if (and ks vs)\n      (recur (assoc map (first ks) (first vs))\n             (next ks)\n             (next vs))\n      map)))","problem":61,"user":"4e39fb68535deb9a81d77f47"},{"code":"(fn\n  [x y]\n  \n  (loop [l1 x l2 y acc {}] \n    (cond \n     \n     (or (empty? l1) (empty? l2))\n     acc\n     \n     :else \n     (recur \n      (rest l1) \n      (rest l2) \n      (assoc acc (first l1) (first l2))))))","problem":61,"user":"4e920f44535dbda64a6f6afd"},{"problem":61,"code":"(fn mapper\n  ([x y]\n   (mapper x y {}))\n  ([x y a]\n   (if (or (empty? x) (empty? y))\n     a\n     (recur (rest x) (rest y) (merge a (hash-map (first x) (first y)))))))","user":"5ac741d6e4b0e27600da777d"},{"code":"(fn [kcoll vcoll]\n  (loop [[k & ks] kcoll [v & vs] vcoll m {}]\n    (if (and ks vs)\n     (recur ks vs (assoc m k v))\n     (assoc m k v))))","problem":61,"user":"516199bbe4b009fba0926e36"},{"problem":61,"code":"(fn [x y]\n  (loop [i 0\n         b {}\n         f x\n         s y]\n    (if (= i (min (count x) (count y)))\n      b\n      (recur (inc i) (assoc b (first f) (first s)) (drop 1 f) (drop 1 s)))))","user":"58b54852e4b0ebc645576d52"},{"code":"(fn [xs ys] (apply hash-map (mapcat list xs ys)))","problem":61,"user":"4ee3b586535d10e5ff6f5371"},{"code":"#(into {} (map vec (partition 2 (interleave %1 %2))))","problem":61,"user":"4fa0a4b1e4b0dcca54ed6d4f"},{"problem":61,"code":"(fn [v1 v2] (apply hash-map (interleave v1 v2)))","user":"5c9adfebe4b048ec896c5ab9"},{"problem":61,"code":"(fn map-construction [coll1 coll2]\n     (apply hash-map (interleave coll1 coll2)))","user":"58dcb8cde4b0a4d5acaab6a7"},{"problem":61,"code":"(fn [k v] (apply hash-map (mapcat #(vector %1 %2) k v )))","user":"57c7cef5e4b05aa3c4741d0d"},{"problem":61,"code":"(fn [x y]\n  ((fn [k v m]\n     (if (or (empty? k) (empty? v))\n       m\n       (recur (rest k) (rest v) (assoc m (first k) (first v)))))\n   x y {}))","user":"55495318e4b0a04f79299566"},{"problem":61,"code":"(fn map-construct [ks vs]   (apply hash-map (interleave ks vs )))","user":"5972fcf6e4b01722bebd4c92"},{"code":"(fn [k v] \n  (apply assoc {} (interleave k v)))","problem":61,"user":"539ad6b7e4b0b51d73faaf18"},{"code":"(fn [xs ys]\n  (let [indexes (range (min (count xs) (count ys)))]\n    (reduce (fn [dicc index]\n              (assoc dicc (xs index) (ys index))) {} indexes)))","problem":61,"user":"4feaa579e4b0140c20fb9c0b"},{"code":"#(apply array-map (interleave %  %2))","problem":61,"user":"51ca82e9e4b08b1cbd0d9488"},{"problem":61,"code":"(fn p \n  [& params]\n  (reduce #(assoc %1 (first %2) (second %2))\n    {} (apply map list params)))","user":"56df7440e4b0ca2494a095fb"},{"problem":61,"code":"(fn [xs ys]\n  (apply sorted-map (interleave xs ys)))","user":"54bebeb9e4b0ed20f4ff6ef4"},{"problem":61,"code":"(fn [a b] \n  ((let [nothing? #(or (nil? %) (and (coll? %) (empty? %)))]\n    (fn [running Keys Values]\n      (if (or (empty? Keys) (empty? Values)) running\n        (let \n          [Key (first Keys) Value (first Values)]\n          (recur (conj running {Key Value}) (rest Keys) (rest Values))))))\n   {} a b))","user":"59cf6fbce4b0ef0a1e9b5b6c"},{"code":"(fn foo [v1 v2]\n  (if (and (> (count v1) 0) (> (count v2) 0))\n      (assoc (foo (rest v1) (rest v2)) (first v1) (first v2))\n      {}\n    )\n  )","problem":61,"user":"50ae5659e4b0a40c9cfb08d2"},{"problem":61,"code":"(fn [a b] (reduce conj {} (map hash-map a b)))","user":"58ad4349e4b0ebc645576c9d"},{"code":"(fn [a b] (reduce #(let [[k v] %2] (assoc %1 k v)) {} (map #(vector %1 %2) a b)))","problem":61,"user":"4e6a5f5c535d8ccf87e9fed6"},{"problem":61,"code":"(fn [k-vector v-vector]\n  (reduce into {}\n          (map #(into {} [[% %2]])\n               k-vector v-vector)))\n\n;;; #(apply hash-map (interleave %1 %2))","user":"5724a4dae4b0c5bde472c0fe"},{"problem":61,"code":"(fn\n  [k v]\n    (loop [r {}\n           k k\n           v v]\n      (if (and k v)\n        (recur (assoc r (first k) (first v))\n               (next k)\n               (next v))\n        r)))","user":"5af907e6e4b0cc2b61a3bcda"},{"problem":61,"code":"(fn fun [x y] (apply hash-map (interleave x y)))","user":"540479e7e4b0addc1aec665a"},{"problem":61,"code":"(fn [ks vs]\n  (reduce (fn [m [k v]] (assoc m k v)) \n          {} \n          (partition 2 (interleave ks vs))))","user":"5799ff45e4b05b1deef9add1"},{"problem":61,"code":"#(reduce conj (map (partial assoc {}) %1 %2))","user":"559454f2e4b0c79f6e1db952"},{"code":"(fn [a b]\n(apply hash-map (interleave a b))\n  )","problem":61,"user":"50f4894be4b004d364930528"},{"problem":61,"code":"(fn my-zip-map [ks vs]\n  (loop [ks ks, vs vs, acc {}]\n    (if (or (empty? ks) (empty? vs))\n        acc\n        (recur (rest ks) (rest vs) (assoc acc (first ks) (first vs))))))","user":"5b51b9f8e4b02d533a91bcfe"},{"problem":61,"code":"(fn map-construct [ks vs] (reduce #(assoc %1 (first %2) (last %2)) {} (map vector ks vs)))","user":"56912f93e4b0dcc4269f40ef"},{"code":"(fn f [k,v] (into {} (map vector k v)))","problem":61,"user":"514b66f4e4b0bd81940b86cb"},{"code":"(fn my-zipmap [keys vals]\n   (let [pairs (map (fn [key val] [key val]) keys vals)]\n     (reduce (fn [a pair] (assoc a (first pair) (second pair))) {} pairs)))","problem":61,"user":"50a7ef7fe4b090657f4a5ce0"},{"problem":61,"code":"(fn [ks vs] (apply assoc {} (for [[k v] (map vector ks vs)\n                               x [k v]]\n                           x)))","user":"4ea03f70535d7eef308072a1"},{"code":"(fn [keys vals]\n  (letfn [(mc [k v m]\n            (cond\n             (or (empty? k)(empty? v)) m\n             :else (mc (rest k)(rest v)(assoc m (first k)(first v)))))]\n    (mc keys vals (hash-map))))","problem":61,"user":"4eb6f065535d7eef30807372"},{"problem":61,"code":"#(apply conj {} (map (fn [x y] {x y}) %1 %2))","user":"549e5e52e4b0f3d1d8e70f9e"},{"problem":61,"code":"(fn zapmup\n  [ks vs]\n  (reduce\n   #(assoc %1 (first %2) (second %2))\n   {}\n   (map\n    vector\n    ks\n    vs)))","user":"51b01309e4b0c53cf2e68a57"},{"problem":61,"code":"(fn [ks vs] (apply merge (map #(hash-map %1 %2) ks vs)))","user":"57db2369e4b0bd073c20241f"},{"code":"(fn [keys vals]\r\n  (apply hash-map (interleave keys vals)))","problem":61,"user":"4dd6d6a0535d2dad7130b5ca"},{"problem":61,"code":"(fn [a b]\n     (apply hash-map (interleave a b)))","user":"4f867b25e4b033992c121c51"},{"problem":61,"code":"(fn [ks vls]\n  (apply hash-map (interleave ks vls)))","user":"551d5cb9e4b07993ea3788e9"},{"code":"#(loop [map {}\n           ks (seq %1)\n           vs (seq %2)]\n      (if (and ks vs)\n        (recur (assoc map (first ks) (first vs))\n               (next ks)\n               (next vs))\n        map))","problem":61,"user":"4e44358f535dc968683fc4a8"},{"problem":61,"code":"(fn [one two]\n  (apply assoc {} (interleave one two)))","user":"57344edbe4b0cd1946bd1008"},{"problem":61,"code":"(fn make-map [keys values]\n  (loop [keys keys\n         values values\n         res {}]\n   \t(if (or (empty? keys) (empty? values))\n      res\n      (let [k (first keys)\n            v (first values)]\n        (recur (rest keys) (rest values) (assoc res k v))))))","user":"573f3ccfe4b05c31a32c083f"},{"problem":61,"code":"(fn [ks, vs]\n  (->> (map vector ks vs)\n       (into {})))","user":"54848141e4b0e286459a119e"},{"code":"(fn [c1 c2]\n  ((fn [ret c1 c2]\n     (if (or (empty? c1) (empty? c2))\n       ret\n       (recur (assoc ret (first c1) (first c2)) (rest c1) (rest c2))))\n   {} c1 c2))","problem":61,"user":"521392bce4b0d32679a5065e"},{"code":"#(into {} (map vector % %2 ))","problem":61,"user":"51f81925e4b09be9c177e526"},{"problem":61,"code":"#((fn [result ks vs]\n    (if (or (empty? ks) (empty? vs))\n      result\n      (recur (assoc result (first ks) (first vs)) (rest ks) (rest vs))))\n  {} %1 %2)","user":"567798afe4b05957ce8c6169"},{"problem":61,"code":"(fn mc\n  [[x & xs :as l-1] [y & ys :as l-2]]\n  (if (or (zero? (count l-1)) (zero? (count l-2)))\n    {}\n    (conj {x y} (mc xs ys))))","user":"59390a35e4b02506e01a29f3"},{"code":"#(apply assoc {} (mapcat list % %2))","problem":61,"user":"4fbacdbae4b081705acca2e5"},{"problem":61,"code":"(fn zip-map [X Y]\n\t(loop [[k1 & krest :as K] X, [v1 & vrest :as V] Y, out {}]\n\t\t(if (and (seq K) (seq V))\n\t\t\t(recur krest vrest (conj out [k1 v1]))\n\t\t\tout)))","user":"564d02cde4b0284900eef679"},{"problem":61,"code":"(fn [a b] \n  (apply hash-map\n         (flatten\n          \t(map vector a b))))","user":"56ca2f25e4b0ea9b8538f716"},{"code":"(fn [c1 c2]\r\n  (let [lst ((fn [[x1 & xs1 :as c1] [x2 & xs2 :as c2]  res]\r\n               (if (or (nil? c1) (nil? c2))\r\n                 res\r\n                 (recur xs1 xs2 (cons x1 (cons x2 res))))) c1 c2 nil)]\r\n    (apply hash-map lst)))","problem":61,"user":"4f359c7ee4b0e243712b1ec4"},{"code":"(fn [keys vals]\n  (loop [map {} keys keys vals vals]\n    (if (or (empty? keys) (empty? vals))\n      map\n      (recur (assoc map (first keys) (first vals))\n        (rest keys) (rest vals)))))","problem":61,"user":"4f038499535dcb61093f6b09"},{"code":"(fn [coll1 coll2]\n  (into {} (map vector coll1 coll2)))","problem":61,"user":"500ff421e4b0ae202717946f"},{"problem":61,"code":"(fn [vec1 vec2](into {} (vec (map (fn[x y] [x y] ) vec1 vec2))))","user":"55757e81e4b05c286339e063"},{"problem":61,"code":"(fn my-mapzip\n   [keys vals]\n   (let [limit (min (count keys) (count vals))]\n   (loop [i 0 ans {}]\n     (if (= i limit)\n       ans\n       (recur (inc i) (assoc ans (keys i) (vals i)))))))","user":"5473efc3e4b0c51c1f4d7285"},{"code":"(fn [a b] (reduce  conj  {} (map vector a b)))","problem":61,"user":"5158bba4e4b059418b97f0ab"},{"problem":61,"code":"(fn my-zipmap\n  ([keys values] (my-zipmap {} keys values))\n  ([ans keys values]\n  (if (or (empty? keys) (empty? values)) ans\n    (recur (into ans {(first keys) (first values)}) (rest keys) (rest values)))))","user":"5a962c09e4b0d174b936c765"},{"problem":61,"code":"(fn [key value]\n  (let [pairs (partition 2 (interleave key value))]\n    (reduce (fn [map [key value]] (assoc map key value)) {} pairs)))","user":"5a1bec89e4b0ff51aa4b322f"},{"code":"(fn [a b]\n  (loop [ax a\n         bx b\n         mp {}]\n    (if (or (empty? ax) (empty? bx))\n      mp\n      (recur (rest ax) (rest bx) (assoc mp (first ax) (first bx))))))","problem":61,"user":"5060d137e4b0dc10a69545a0"},{"code":"(fn [x y]\n         (loop [a x\n               b y\n               result {}]\n               (if (or (empty? a) (empty? b))\n                 result\n                 (recur (rest a) (rest b) (assoc result (first a) (first b))))))","problem":61,"user":"4e7e241a535db169f9c79705"},{"problem":61,"code":"(fn [ks vs]\n  \n  (loop [i 0 res {}]\n    (if-not (> (min (count ks) (count vs )) i)\n      res\n      (recur (inc i) (conj res [(nth ks i) (nth vs i)])))\n  )\n\n)","user":"54a7d707e4b09f271ff37c9b"},{"problem":61,"code":"(fn my-zipmap\n  ([ks vs] (my-zipmap ks vs {}))\n  ([ks vs acc]\n   (if (or (empty? ks) (empty? vs))\n     acc\n     (recur (rest ks) (rest vs) (into acc {(first ks) (first vs)})))))","user":"58f3c18ee4b0438e51c2cead"},{"code":"#(loop [map {} k %1 v %2]\n  (if (and k v)\n    (recur (assoc map (first k) (first v)) (next k) (next v)) map))","problem":61,"user":"4e7d2448535db169f9c796c8"},{"problem":61,"code":"(fn [klist vlist] (reduce\n            (fn [accum k] (if (< (k 0) (count vlist))\n                            (assoc\n                                accum\n                                (k 1)\n                                (vlist (k 0)))\n                            accum))\n            {}\n            (map-indexed vector klist)))","user":"597f8984e4b0dbe32238d0bf"},{"problem":61,"code":"(fn [ks vs]\n  (reduce conj {} (map (comp vec list) ks vs)))","user":"57df2722e4b0bd073c20245e"},{"code":"(fn [coll1 coll2]\n  (loop [c1 coll1 c2 coll2 res {}]\n    (if (or (empty? c1) (empty? c2))\n      res\n      (recur \n        (rest c1) \n        (rest c2) \n        (assoc res (first c1) (first c2))))))","problem":61,"user":"4f378631e4b0e243712b1ed3"},{"problem":61,"code":"(fn [xs ys]\n  (->> (interleave xs ys)\n       (partition 2)\n       (reduce #(assoc % \n                  (first %2) \n                  (second %2))\n               {})))","user":"55d8eed3e4b0e31453f64ac3"},{"problem":61,"code":"(fn kvm [k v] (->> (interleave k v) (apply assoc {} )))","user":"5900d5cde4b0438e51c2d02e"},{"problem":61,"code":"(fn \n  [coll1 coll2]\n  (apply hash-map (interleave coll1  coll2)))","user":"6059d2e0e4b07e92fa001ace"},{"code":"#(loop [map {} keys % values %2] \n   (if (some empty? [keys values])\n     map\n   (recur (into map [[(first keys) (first values)]]) (rest keys) (rest values))))","problem":61,"user":"52efc98de4b05e3f0be25ed2"},{"problem":61,"code":"(fn [x y] \n  (into {} \n        (map #(vector %1 %2) x y)))","user":"57011eb3e4b08d47c97781d1"},{"problem":61,"code":"(fn\n  [vkeys vvalues]\n  (loop [vk vkeys vv vvalues acc {}]\n    (if (or (empty? vk) (empty? vv))\n      acc\n      (recur (rest vk) (rest vv) (assoc acc (first vk) (first vv))))))","user":"56cb4d06e4b0ea9b8538f72e"},{"problem":61,"code":"(fn [ks vs] \n  (reduce-kv \n   (fn [acc k v] (if (nil? (get vs k)) acc (assoc acc v (get vs k)))) \n   {} \n   ks\n   )\n  )","user":"546d41bde4b00cfc9eacc18c"},{"code":"#(into {} (apply map \n  (fn [f s] \n    {f s})\n  %&))","problem":61,"user":"4f1e4ab5535d64f603146496"},{"code":"(fn [keys vals] (apply merge {} (map #(hash-map % %2) keys vals)))","problem":61,"user":"4e80e0f2535db62dc21a62b8"},{"problem":61,"code":"(fn mapConstruction\n  [i j] \n  (into {} (map vector i j)))","user":"59dd3930e4b0a0ac046f2504"},{"code":"(fn [k v]\n  (loop [m {}\n         k k\n         v v]\n    (if (and k v)\n      (recur (assoc m (first k) (first v))\n             (next k)\n             (next v))\n      m)))","problem":61,"user":"4e6ebd4a535d5021c1a89610"},{"problem":61,"code":"(fn mm [ a b]\n\n  (let [tr {}]\n\n    (into {} (map #(assoc tr %1 %2) a b))))","user":"548f3ed8e4b0e286459a1236"},{"code":"(fn [xs ys]\n   (into {} (map vector xs ys)))","problem":61,"user":"516282c3e4b0e6d3c4734711"},{"code":"(fn consMap [keys vals] (if (or (empty? keys) (empty? vals)) {} (conj {(first keys) (first vals)} (consMap (rest keys) (rest vals)))))","problem":61,"user":"50ef311fe4b0a78662fa2651"},{"code":"(fn construction [x y] (if (< 0 (min (count x) (count y)))\n                                   (assoc (construction (rest x) (rest y)) (first x) (first y))\n                                 {}))","problem":61,"user":"5296aa9be4b02ebb4ef75034"},{"problem":61,"code":"(fn\n    [xs ys]\n    (apply hash-map\n      (interleave xs ys)\n    )\n  )","user":"5784e177e4b0ebec4cfb74cf"},{"problem":61,"code":"(fn mzipmap [keys values]\n  (loop [k keys v values m {}]\n    (if (or (zero? (count k)) (zero? (count v)))\n      m\n      (recur\n        (rest k)\n        (rest v)\n        (assoc m (first k) (first v))))))","user":"57ed2574e4b0bfb2137f5b93"},{"problem":61,"code":"#(apply hash-map(mapcat vector %1 %2))","user":"5c7d947be4b0d597f478cab6"},{"problem":61,"code":"(fn [kys vas]\n    (apply hash-map (interleave kys vas)))","user":"5703ce0fe4b08d47c97781fd"},{"code":"(fn [k v] \n   (loop [m {}\n          ks (seq k)\n          vs (seq v)]\n     (if (and ks vs)\n       (recur (assoc m (first ks) (first vs))\n              (next ks)\n              (next vs))\n       m)))","problem":61,"user":"5215661be4b02f6d8ea676c7"},{"code":"#(loop [[k & ks] %1 [v & vs] %2 res {}]\n\t(if (or (nil? k) (nil? v)) res\n\t\t(recur ks vs (assoc res k v))))","problem":61,"user":"53300924e4b019098a6f8b55"},{"problem":61,"code":"#(loop [k %1 v %2 m {}]\n    (if (or (empty? k) (empty? v))\n      m\n      (recur (rest k) (rest v) (assoc m (first k) (first v)))))","user":"5614ebc5e4b05f002753dfbc"},{"code":"(fn [x y] (reduce #(assoc %1 (get %2 0) (get %2 1)) {} (for [i (range (min (count x) (count y))) :let [a (get x i), b (get y i)]] [a b])))","problem":61,"user":"5017f840e4b02f523d7cc5e8"},{"code":"(fn myzipmap [a b]\n  (if (or (= 0 (count a)) (= 0 (count b)))\n    {}\n    (conj {(first a) (first b)} (myzipmap (rest a) (rest b)))))","problem":61,"user":"52c8a8b9e4b0c2d177d62139"},{"code":"(fn [left right]\n  (reduce (fn [a [x,y]] (assoc a x y)) {}\n    (partition 2 (interleave left right))))","problem":61,"user":"5027fc0ce4b01614d1633ff2"},{"code":"(fn [keys vals]\n  (loop [map {}\n           ks (seq keys)\n           vs (seq vals)]\n     (if (and ks vs)\n      \t(recur (assoc map (first ks) (first vs))\n               (next ks)\n               (next vs))\n      \tmap)))","problem":61,"user":"52f89125e4b047fd55836fd4"},{"problem":61,"code":"(fn pia [lst1 lst2]\n  (apply merge (map (fn [k v] {k v}\n                      )\n                 lst1 lst2)\n    )\n  )","user":"569ce6fee4b0542e1f8d146c"},{"code":"#(apply assoc {}\n        (interleave %1 %2))","problem":61,"user":"4fda108ee4b05e33b9224f46"},{"problem":61,"code":"(fn construct [ks vs]\n  (into {} (map vector ks vs)))","user":"54468fd3e4b032a45b8693b2"},{"code":"(fn [ks vs] (into {} (map (fn [k v] {k v}) ks vs)))","problem":61,"user":"4fca2a13e4b0ee37620e184d"},{"code":"(fn [ks vs]\n  (apply hash-map (mapcat #(list %1 %2) ks vs)))","problem":61,"user":"4f62b29ce4b0defedf855fd9"},{"problem":61,"code":"(fn myzipmap [k v]\n  (if (or (empty? k) \n          (empty? v))\n    nil\n    (assoc (myzipmap (rest k)\n                     (rest v))\n           (first k)\n           (first v))))","user":"5b5d255de4b0c6492753e6c8"},{"code":"(fn [ks vs] (apply hash-map (interleave ks vs)))\n\n;#(loop [result {} keys-coll %1 vals-coll %2]\n;   (if (or (empty? keys-coll)\n;           (empty? vals-coll))\n;     result\n;     (recur (assoc result (first keys-coll)(first vals-coll)) (rest keys-coll) (rest vals-coll))))","problem":61,"user":"518ccf6be4b05e6c8537e386"},{"problem":61,"code":"(fn [k v]\n  (loop [acc {} k k v v]\n    (if (some empty? (list k v))\n      acc\n      (recur (assoc acc (first k) (first v)) (rest k) (rest v))\n    )\n  )\n)","user":"583dacc2e4b089d5ab817d9f"},{"problem":61,"code":"(fn [col1 col2]\n  (into {} (map vector col1 col2))\n\n\n  )","user":"5c321b8ae4b0d62ef62d9f32"},{"code":"(fn [s1 s2] (apply hash-map (mapcat list s1 s2)))","problem":61,"user":"4f40f055e4b0e243712b1fc2"},{"code":"(fn zm2 [ks vs]\n  (into {} (map vector ks vs)))","problem":61,"user":"51672d15e4b079759a74a5e7"},{"problem":61,"code":"(fn build-map [vk vv]\n  (let [b (fn anon [m ks vs]\n            (if (or (empty? ks) (empty? vs)) m\n              (let [k (first ks)\n                    v (first vs)]\n                (anon (conj m [k v]) (rest ks) (rest vs)))))]\n    (b {} vk vv)))","user":"57d1d6c8e4b0bd073c202370"},{"problem":61,"code":"(fn [a b] (reduce conj (map #(assoc {} % %2) a b)))","user":"5ff3aca3e4b05ac5b16ea205"},{"problem":61,"code":"(fn [ks vs]\n  (into {}\n        (loop [ks ks\n               vs vs\n               acc []]\n          (if (and (seq ks) (seq vs))\n            (recur (rest ks) (rest vs) (conj acc [(first ks) (first vs)]))\n            acc))))","user":"579c35fee4b05b1deef9ae04"},{"problem":61,"code":"(fn my-mkmap\n  ([ks vs] (my-mkmap ks vs {}))\n  ([[k & ks] [v & vs] out]\n    (let [nout  (into out {k v})\n          stop (or (empty? ks) (empty? vs))]\n      (if stop\n        nout\n        (recur ks vs nout)\n      )\n    )\n  )\n)","user":"53edb628e4b0d648e757f4c8"},{"code":"(fn [k v]\n  (reduce #(assoc %1 (first %2) (second %2)) {}\n          (map #(identity [%1 %2]) k v)))","problem":61,"user":"5175533fe4b0dea9bbfba575"},{"problem":61,"code":"(fn my-zipmap [keys* vals*] (apply assoc {} (interleave keys* vals*)))","user":"5614fa1de4b05f002753dfbe"},{"problem":61,"code":"(fn [kc vc]\n  (let [kc-trimmed (take (count vc) kc)]\n    (into {} (map-indexed #(hash-map %2 (vc %1)) kc-trimmed))))","user":"562e8b2be4b0ab312c17ebbb"},{"code":"(fn [A B]\n  (let\n    [n (min (count A) (count B))]\n    (loop\n      [tr {}\n       a A\n       b B\n       i 0]\n      (if (= i n)\n        tr\n        (recur\n         (assoc tr(first a) (first b))\n         (rest a)\n         (rest b)\n         (+ i 1))))))","problem":61,"user":"530d85dee4b08068f379eca8"},{"problem":61,"code":"(fn [x y]\n   (loop [x x y  y res {}]\n     (if-not (empty? x)\n       (if-not (empty? y)\n         (recur (rest x) (rest y) (assoc res (first x) (first y)))\n         res)\n       res)))","user":"5508102ee4b021ccfedb96b0"},{"problem":61,"code":"; rewrite first solution\n#(reduce (fn [m [k v]] (assoc m k v)) {} (map vector % %2))\n\n; into hash\n#_#(into {} (map vector % %2))\n\n; hash-map: \"hash\"; O(1) lookup\n#_#(apply hash-map (interleave % %2))\n\n; array-map: \"array\"; O(N) lookup; sorted by insertion order\n#_#(apply array-map (interleave % %2))\n\n; first\n#_(fn [ks vs]\n  (reduce \n    (fn [m [k v]] (assoc m k v))\n    {}\n    (partition 2 (interleave ks vs))))","user":"55e7d06ee4b050e68259b496"},{"code":"(fn [x y]\n    (reduce #(assoc %1 (first %2) (second %2)) {} (map vector x y)))","problem":61,"user":"4e89ff3d535d3e98b802328a"},{"problem":61,"code":"(fn [x y] \n  (apply merge \n   (map \n    (fn [a b] (hash-map a b))\n    x\n    y)))","user":"59d75e36e4b0ef0a1e9b5c32"},{"problem":61,"code":"(fn [lst1 lst2]\n  (apply hash-map\n         (interleave lst1 lst2)))","user":"5a99c5a9e4b0d174b936c7b1"},{"code":"(fn [ks vs]\n  (apply hash-map (flatten (map (fn [k v] [k v]) ks vs))))","problem":61,"user":"5201ff99e4b0b2e020a18f26"},{"problem":61,"code":"#(into {} \n       (reverse \n        (apply assoc {} (interleave %1 %2))))","user":"553fa883e4b0a04f792994f9"},{"problem":61,"code":"#(into {}\n       (map vector % %2))","user":"54a627bce4b09f271ff37c83"},{"problem":61,"code":"(fn into-map [x y]\n  (loop [index 0 output {}]\n    (if-not (and (contains? x index) (contains? y index)) output\n            (recur (inc index) (assoc output (nth x index) (nth y index))))))","user":"58f5b58ae4b0438e51c2cedc"},{"code":"#(apply array-map(interleave %1 %2))","problem":61,"user":"5300aa1de4b0d8b024fd3710"},{"problem":61,"code":"(fn build-map [coll1 coll2]\n  (apply assoc {} (interleave coll1 coll2)))","user":"5dba063ee4b010eb3c36cd5c"},{"code":"(fn [& xs]\n     (->> xs \n       (apply map vector)\n       (into {})))","problem":61,"user":"502ade49e4b0614b52996120"},{"problem":61,"code":"(fn [key val] (apply hash-map (interleave key val)))","user":"534fa9dae4b084c2834f4acf"},{"problem":61,"code":"(fn [k v]\n  (into {}\n     (map\n      \t#(hash-map % %2) k v))\n)","user":"57a88e24e4b0a9660795621f"},{"code":"; from ClojureDocs on interleave\n#(apply assoc {} (interleave %1 %2))","problem":61,"user":"506ab9bae4b05d3b7762c74c"},{"problem":61,"code":"(fn [k v]\n  (into (sorted-map) (map (fn [a b] [a b]) k v)))","user":"59a0286be4b0871e7608b82f"},{"problem":61,"code":"(fn [keys, values] (reduce #(assoc % (first %2) (nth %2 1)) {} (map list keys values)))","user":"5509a23ee4b06e50f9beb11a"},{"problem":61,"code":"(fn [%1 %2]\n\n  (loop [coll1 %1\n         coll2 %2\n         result {}]\n    (if-not (or (empty? coll1) (empty? coll2))\n      (recur (rest coll1) (rest coll2)    (conj result {(first coll1) (first coll2)}) )\n      result)\n    )\n  )","user":"5a71c89ee4b0512ff01cda93"},{"problem":61,"code":"(fn constuctor [keys values]\n  (loop [keys keys values values result {}]\n    (if (or (empty? keys) (empty? values))\n      result\n      (recur (rest keys) (rest values) (assoc result (first keys) (first values))))))","user":"5d0859fbe4b0cc9c91588208"},{"problem":61,"code":"(fn makemap [seqa seqb]\n    (loop [a seqa\n           b seqb\n           ans (. clojure.lang.PersistentHashMap create {})]\n      (if (or (empty? a) (empty? b))\n        ans\n        (recur (rest a) (rest b) (conj ans [(first a) (first b)]))\n        )\n      )\n    )","user":"57cc14aae4b05aa3c4741d4a"},{"problem":61,"code":"(fn [a b] (into {} (vec (map vec (partition 2 (interleave a b))))))\n\n; (fn [ks vs] (into {} (map vector ks vs)))","user":"577bcbd9e4b0d3393e5deb1b"},{"code":"(fn[x y]( into {} (map vector x y)  ))","problem":61,"user":"52e807b3e4b09f7907dd1490"},{"problem":61,"code":"(fn [x y] (apply merge (#(map (fn [k v] {k v}) x y))))","user":"5cda72ffe4b05ee0cb311714"},{"code":"(fn [a b]\n           (loop [x a y b z {}]\n              (if (or (= x []) (= y []))\n                  z\n                  (recur (rest x) (rest y) (conj z {(first x) (first y)})))))","problem":61,"user":"4f03f197535dcb61093f6b84"},{"problem":61,"code":"(fn [ks vs]\n  (into {} (map (fn [k v] [k v]) ks vs)))","user":"526e1bd0e4b03e8d9a4a730b"},{"code":"(fn [c1 c2] (apply merge (map #(assoc {} %1 %2) c1 c2)))","problem":61,"user":"4e260220535deb9a81d77ef0"},{"problem":61,"code":"(fn [a b]\n   (into {} (map #(hash-map %1 %2) a b)))","user":"5d927df4e4b0915913b1d40f"},{"code":"(fn [a b] \n  (into {} \n    (for [i (range (min (count a) (count b)))] \n     [(nth  a i) (nth  b i)])))","problem":61,"user":"50335235e4b0c6c1199c710b"},{"problem":61,"code":"(fn constMap\n  ([k v] (constMap (- (min (count k) (count v)) 1) k v))\n  ([n k v] (if \n             (< n 0)\n             (hash-map)\n             (conj (constMap (- n 1) k v) (vector (nth k n) (nth v n))))))","user":"58950f29e4b00487982d5270"},{"code":"(fn [x y]\n  (loop [i {} j x k y]\n    (let [a (first j) b (first k)]\n      (if (or (nil? a) (nil? b))\n        i\n        (recur (assoc i a b) (next j) (next k))))))","problem":61,"user":"531488f3e4b08068f379ed16"},{"problem":61,"code":"(fn [k v] (apply merge (map hash-map k v)))","user":"54534c83e4b0e397800069cd"},{"problem":61,"code":"#(loop[a %1 b %2 result {}]\n   (if (or(empty? a) (empty? b)) result\n     (recur (rest a) (rest b) (assoc result (first a) (first b)))))\n\n;(fn [a b] (apply assoc {} (interleave a b)))","user":"59c77511e4b0a024fb6ae545"},{"problem":61,"code":"(fn [ks vs] (loop [ks ks vs vs res {}]\n              (if-not (and (first ks) (first vs))\n                res\n                (recur (rest ks) (rest vs) (assoc res (first ks) (first vs))))))","user":"5b7ec039e4b047b03b20375d"},{"problem":61,"code":"#(reduce (fn [result item]\n          (if (< (count result) (count %2))\n            (assoc result item (%2 (count result)))\n            result)) {} %)","user":"5ccc2a03e4b0ccb06196288f"},{"problem":61,"code":"(fn [x y]\n  (into {} (map #(assoc {} %1 %2) x y)))","user":"54d05a9de4b0e8a36923e5c7"},{"code":"(fn [c1 c2]\n  (reduce conj {}\n    (map (fn [x y]  [x y]) c1 c2)))","problem":61,"user":"4f38d6bbe4b0e243712b1ee2"},{"problem":61,"code":"(fn zm [x y]\n  (if (and (seq x) (seq y))\n    (assoc (zm (rest x) (rest y)) (first x) (first y))\n    {}))","user":"597a4277e4b02382a38ad1e2"},{"problem":61,"code":"(fn [coll coll2]\n(apply assoc {} (interleave coll coll2)))","user":"5f8e2a08e4b0715f5002d767"},{"problem":61,"code":"(fn mappy [keylist vallist]\n  (if (or (empty? keylist) (empty? vallist))\n    {}\n    (merge (hash-map (first keylist) (first vallist)) (mappy (rest keylist) (rest vallist)))))","user":"5705e404e4b0b0fb43fd0676"},{"problem":61,"code":"(comp\n  (partial apply assoc {})\n  interleave)","user":"5703cd50e4b08d47c97781fc"},{"problem":61,"code":"(fn [the-keys the-vals] (apply \n                         hash-map (interleave the-keys the-vals)))","user":"5ca1f8a1e4b048ec896c5b8c"},{"problem":61,"code":"(fn [ks vs]\n  (loop [ks ks vs vs m {}]\n    (if (or (empty? ks) (empty? vs))\n      m\n      (recur\n        (rest ks)\n        (rest vs)\n        (conj m [(first ks) (first vs)])))))","user":"556159fae4b0c656e3ff17c7"},{"code":"(fn f [k v]\n\t(into {} (map #(assoc {} %1 %2) k v)))","problem":61,"user":"514a13cee4b0829bd132edb4"},{"code":"(fn [ks vs]\r\n  (loop [m {}, ks ks, vs vs]\r\n    (if (and (seq ks) (seq vs))\r\n        (recur (assoc m (first ks) (first vs))\r\n               (rest ks)\r\n               (rest vs))\r\n         m)))","problem":61,"user":"4de760a3535d08e6dec9fdf9"},{"problem":61,"code":"#( apply hash-map  (flatten (partition 2 (interleave %1 %2))) )","user":"54e51c7be4b024c67c0cf7f7"},{"code":"(fn [x y]\n  (reduce #(assoc %1 (first %2) (second %2))\n          {}\n          (map list x y)))","problem":61,"user":"515f8a0de4b0e2be8aa20bce"},{"code":"(fn [coll1 coll2]\n  (loop [coll1 coll1 coll2 coll2 result {}]\n    (if-not (and (seq coll1) (seq coll2)) \n      result\n      (recur (rest coll1) (rest coll2) (into result {(first coll1) (first coll2)}))\n    )))","problem":61,"user":"52fcfeeee4b047fd55837027"},{"code":"(fn [x y] (apply array-map (interleave x y)))\n; Not as succinct as some, but I'm happy with this.","problem":61,"user":"4ebb20c0535dfed6da9c6d6f"},{"problem":61,"code":"(fn jp [klu baz] (if (or (empty? klu) (empty? baz)) () (conj (assoc nil (first klu) (first baz)) (jp (rest klu) (rest baz) ))))","user":"544e1794e4b0e39780006980"},{"problem":61,"code":"(fn [ks vs]\n  (into (hash-map)\n        (map (fn [k v] [k v]) ks vs)))","user":"5a95c639e4b0d174b936c75e"},{"problem":61,"code":"(fn [a b] (reduce #(apply assoc %1 %2) {} (map vector a b)))","user":"5712854ce4b07c98581c3a89"},{"code":"(fn map-cons [l1 l2]\r\n    (if (or (empty? l1) (empty? l2))\r\n      {}\r\n      (assoc (map-cons (rest l1) (rest l2)) (first l1) (first l2))))","problem":61,"user":"4f039524535dcb61093f6b2c"},{"problem":61,"code":"(fn [a b c]\n  (if (or (empty? b) (empty? c))\n    a\n    (recur (assoc a (first b) (first c)) (drop 1 b) (drop 1 c)))) {}","user":"5bf0aefde4b0a6d31fed215a"},{"problem":61,"code":"(fn [a b]\n  (->>\n   (map vector a b)\n   (into {})))","user":"5ec21ef0e4b00a66d4a95299"},{"problem":61,"code":"#(loop [ks % vs %2 m {}]\n   (if (and ks vs)\n     (let [k (first (seq ks))\n           v (first (seq vs))]\n       (recur (next ks) (next vs) (assoc m k v)))\n     m))","user":"55b22c33e4b0da326a65cf79"},{"problem":61,"code":"(fn [k v]\n  (into (sorted-map) \n        (map (fn [x y]\n               (let [m {}]\n                 (assoc m x y))) k v)))","user":"55aaa36fe4b0988bba2ad94f"},{"code":"(fn [ks vs]\n  (reduce merge (map (fn [k v] {k v}) ks vs)))","problem":61,"user":"4fa340b4e4b081705acca18c"},{"problem":61,"code":"(fn [keys vals]\n  (loop [map {}\n         ks (seq keys)\n         vs (seq vals)]\n    (if (and ks vs)\n\t\t(recur (assoc map (first ks) (first vs))\n               (next ks)\n               (next vs))\n      map)))","user":"54cbd6bae4b057c6fda3a282"},{"code":"(fn \r\n  [keys vals]\r\n    (loop [map {}\r\n           ks (seq keys)\r\n           vs (seq vals)]\r\n      (if (and ks vs)\r\n        (recur (assoc map (first ks) (first vs))\r\n               (next ks)\r\n               (next vs))\r\n        map)))","problem":61,"user":"5028bce0e4b01614d1633ffb"},{"problem":61,"code":"(fn [v1 v2] (apply assoc {} (interleave v1 v2)))","user":"4fffa422e4b0678c553fc404"},{"code":"#(apply conj (map hash-map % %2))","problem":61,"user":"51757af0e4b085adf681d873"},{"problem":61,"code":"(fn [x y] (apply conj  (map #(hash-map (first %) (second %)) (partition 2 (interleave x y)))))","user":"5233564ae4b0f0b72fabf403"},{"problem":61,"code":"(fn map-construction [keys values] (into {} (map #(hash-map %1 %2) keys values)))","user":"56fbcc1fe4b07572ad1a88d5"},{"code":"(fn [x y]\n  ((fn [a b rec]\n      (cond\n           (empty? a) rec\n           (empty? b) rec\n           :else (recur (rest a) (rest b) (conj rec {(first a) (first b)})))) x y {}))","problem":61,"user":"50ed5d1be4b06330c1f87c37"},{"problem":61,"code":"(fn [k v]\n  (loop [k k\n         v v\n         res {}]\n    (if (and (seq k) (seq v))\n      (recur (rest k) (rest v) (assoc res (first k) (first v)))\n      res)))","user":"5a6b9b95e4b0512ff01cda40"},{"problem":61,"code":"(fn [l1 l2] \n  (loop [news {} tmp1 l1 tmp2 l2]\n    (if (or (empty? tmp1) (empty? tmp2))\n      news\n      (recur (into news {(first tmp1) (first tmp2)}) (rest tmp1) (rest tmp2)))))","user":"59368ccae4b02506e01a297a"},{"problem":61,"code":"(fn [a b]\n  (apply hash-map\n    (interleave a b)))","user":"540c54a7e4b0addc1aec6700"},{"problem":61,"code":"#(apply merge \n       (map (fn [k v] (assoc {} k v)) %1 %2))","user":"566e87cfe4b0a866af6896dc"},{"code":"(fn build [k v]\n  (when (and (not-empty k) (not-empty v))\n    (conj {(first k) (first v)} (build (rest k) (rest v)))\n  ))","problem":61,"user":"53778b90e4b06839e8705e36"},{"problem":61,"code":"(fn [c1 c2]\n  (into {} (map (fn [f s] [f s]) c1 c2)))","user":"5cf935f4e4b0b71b1d808a8f"},{"code":"(fn [v1 v2] (apply conj {} (map vector v1 v2)))","problem":61,"user":"516db4f6e4b046df6fbb76a0"},{"code":"(fn [kk vv]\n  (apply merge (map hash-map kk vv)))","problem":61,"user":"525d490ae4b0cb4875a45d70"},{"code":"(fn [ks vs]\n  (apply merge\n    (for [i (range (min (count ks) (count vs)))]\n      {(nth ks i) (nth vs i)}\n    )\n  )\n)","problem":61,"user":"4ea57300535d7eef308072d5"},{"problem":61,"code":"(fn [a b] \n  (loop [a a b b c {}]\n    (if\t(or (empty? a) (empty? b))\n      \tc\n     \t(recur (rest a) (rest b) (assoc c (first a) (first b))))))","user":"5562f08ae4b0c656e3ff17df"},{"problem":61,"code":"(fn my-zipmap [keys values]\n  (apply merge (map (fn [key value] {key value}) keys values)))","user":"5d49ec5ee4b0776584bd6f1c"},{"problem":61,"code":"(fn make-map\n  ([k v]   (make-map k v {}))  \n  ([k v r] (if (and (first k) (first v))\n             (assoc (make-map (rest k) (rest v) r) (first k) (first v))\n             r)))","user":"5635adeee4b0bfe05bf117c7"},{"code":"(fn [k v]\n  (loop [m {} a k b v]\n    (if (or (empty? a) (empty? b))\n      m\n      (recur \n        (assoc m (first a) (first b)) \n        (rest a) \n        (rest b)))))","problem":61,"user":"4e5c801e535d8a8b8723a2c1"},{"code":"(fn zm [xs ys] (if (or (empty? xs) (empty? ys)) {} (assoc (zm (rest xs) (rest ys)) (first xs) (first ys))))","problem":61,"user":"515fb48fe4b0e2be8aa20bd5"},{"problem":61,"code":"#(->> \n      (map vector %1 %2)\n      (into {}))","user":"5e64ae6ce4b0fd0acd1586ac"},{"problem":61,"code":"(fn [a b]\n  (reduce #(apply assoc %1 %2)\n          {}\n          (map list a b)))","user":"54084784e4b0addc1aec66c9"},{"problem":61,"code":"(fn [ks vs]\n   (into {} (map vector ks vs)))","user":"52281e1ee4b0186687e23a69"},{"code":"(fn [xs ys]\r\n(loop [[head & more] (map vector xs ys)\r\n        z {}]\r\n(if (nil? head) z\r\n(recur more (conj z {(first head )(second head)})))))","problem":61,"user":"4ea09441535d7eef308072a7"},{"problem":61,"code":"(fn zm[ks vs]\n  (loop [res {}\n         [k & more-k :as all-k] ks\n         [v & more-v :as all-v] vs]\n    (if (and all-k all-v)\n      (recur\n       \t(assoc res k v)\n       \tmore-k\n       \tmore-v)\n      res)\n))","user":"5ba75fdfe4b0a20761a23419"},{"problem":61,"code":"(fn [ks vs]\n    (loop [i 0 acc {}]\n      (if (or (= i (count ks)) (= i (count vs))) acc\n          (recur (inc i) (assoc acc (nth ks i) (nth vs i))))))","user":"595bbab7e4b066ee0a44afe0"},{"problem":61,"code":"(fn [c1 c2]\n  (apply hash-map (flatten (map #(identity [%1 %2]) c1 c2))))","user":"576a972ce4b0a07e8fc1811a"},{"code":"(fn [x y]\n  (loop [[h1 & r1] x, [h2 & r2] y, z (sorted-map) ]\n    (if (or (nil? h1) (nil? h2))\n      z\n      (recur r1 r2 (assoc z h1 h2)))\n    ))","problem":61,"user":"5099283ce4b0cae2931060af"},{"problem":61,"code":"(fn [xs ys] (apply merge (map hash-map xs ys)))","user":"5705f569e4b0b0fb43fd0677"},{"code":"(partial \n #(if (or (empty? %2) (empty? %3)) %1 \n          (recur (assoc %1 (first %2) (first %3)) (rest %2) (rest %3))) {})","problem":61,"user":"5273e006e4b03e8d9a4a7495"},{"problem":61,"code":"(fn [kl vl] \n  (loop [m {} k (seq kl) v (seq vl)] \n    (if (and k v) \n      (recur (assoc m (first k) (first v)) (next k) (next v)) \n      m)))","user":"528d6b10e4b0239c8a67aec3"},{"code":"(fn [& c] (into {} (apply map #(hash-map %1 %2) c)))","problem":61,"user":"52f1bc81e4b05e3f0be25eef"},{"problem":61,"code":"(fn [lst1 lst2] (into {} (map vector lst1 lst2)))","user":"59e18b9be4b08badc2a0c50f"},{"problem":61,"code":"(fn [a b]\n  (reduce\n   (fn [m e]\n     (conj m e)\n     )\n   {}\n   (map (fn [m n] [m n]) a b)))","user":"552d2e4fe4b076ab5578f7e1"},{"problem":61,"code":"(fn createmap [key value]\n  (apply hash-map (interleave key value)))","user":"57bc9375e4b05aa3c4741c43"},{"problem":61,"code":"(fn  [x y] (loop [x x y y z {}] (if (and x y) (recur (next x) (next y) (assoc z (first x) (first y))) z)))","user":"5c308385e4b0d62ef62d9f1c"},{"problem":61,"code":"(fn [coll1 coll2]\n  (loop [coll1 coll1 coll2 coll2 acc {}]\n    (if (or (empty? coll1) (empty? coll2))\n      acc\n      (recur (rest coll1) (rest coll2)\n             (assoc acc (first coll1) (first coll2))))))","user":"54fdbe3fe4b07d26eda61d3b"},{"problem":61,"code":"(fn [a b] (into {} (map vec (partition 2 (interleave a b)))))","user":"542baf7ce4b0dad94371f291"},{"code":"(fn [ks vs] (into {} (map #(vector %1 %2) ks vs)))","problem":61,"user":"51195e77e4b055cfb310d499"},{"problem":61,"code":"(fn [keys vals]\n  (loop [acc {}\n         keys keys\n         vals vals]\n    (if (and keys vals)\n      (recur (assoc acc (first keys) (first vals))\n             (next keys)\n             (next vals))\n      acc)))","user":"5fea32f3e4b05ac5b16ea1aa"},{"problem":61,"code":"(fn [xs ys]\n  (->> (interleave xs ys)\n       (partition 2)\n       (map #(hash-map (first %) (second %)))\n       (apply merge)))","user":"562c15d3e4b058fa18c5a6d5"},{"problem":61,"code":"(fn [x y]\n      (into {} (map #(hash-map %1 %2) x y)))","user":"56df6351e4b0ca2494a095f3"},{"problem":61,"code":"(fn [n, m] (into {} (map vector n m)))","user":"5527be83e4b0ffed3738f936"},{"problem":61,"code":"(fn f [k v] (apply assoc {} (interleave k v)))","user":"53b3ea79e4b047364c0444ab"},{"code":"(fn x [keys vals]\r\n  (loop [my-map {}\r\n         my-keys (seq keys)\r\n         my-vals (seq vals)]\r\n    (if (and my-keys my-vals)\r\n      (recur (assoc my-map (first my-keys) (first my-vals))\r\n             (next my-keys)\r\n             (next my-vals))\r\n      my-map)))","problem":61,"user":"4ec7def0535d6d7199dd36e9"},{"problem":61,"code":"(fn\n  my-zipmap\n  [keys vals]\n  (->>\n    ; using map/reduce\n    (map vector keys vals)\n    (reduce (fn[m [key val]] (assoc m key val)) {} ,,,)\n\n    ; using interleave/apply\n    ; (interleave keys vals)\n    ; (apply hash-map ,,,)\n\n    ; using mapcat/apply\n    ; (mapcat vector keys vals)\n    ; (apply hash-map ,,,)\n  ))","user":"5c6227fee4b0fca0c1622641"},{"problem":61,"code":"#(apply assoc {}  (apply interleave %&))","user":"5ed8a12fe4b0c7845d86b0d7"},{"problem":61,"code":"(fn [keys values] (into {} (map (fn [x y] {x y}) keys values)))","user":"5d6d2172e4b04d129b00f2b9"},{"problem":61,"code":"(fn zip\n  ([k v] (zip k v {}))\n  ([k v ans]\n   (if (or (empty? k) (empty? v))\n     ans\n     (zip (rest k) (rest v) (assoc ans (first k) (first v)))\n     )\n   )\n  )","user":"5a90395ce4b05369db4d254a"},{"code":"(fn zipp [a b]\n  (if (or (empty? a) (empty? b)) '{}\n(merge {(first a) (first b)} (zipp (rest a) (rest b)))))","problem":61,"user":"4f8b20fce4b02e764a0a5178"},{"problem":61,"code":"(fn  [a b] (apply array-map (into [] (#(interleave %1 %2) a b))))","user":"5423dc6ae4b01498b1a71ad5"},{"problem":61,"code":"(fn [v1 v2]\n   (loop [i 0 m {}]\n     (if (= (min (count v1) (count v2)) i)\n       m\n       (recur (inc i) (assoc m (nth v1 i) (nth v2 i))))))","user":"5a653f80e4b0512ff01cd9b2"},{"problem":61,"code":"(fn new-map [keys vals]\n  (reduce #(assoc %1 (first %2) (last %2)) {} (map vector keys vals)))","user":"5c8cfff8e4b048ec896c5996"},{"code":"(fn [k v]\n  (reduce \n    (fn [m [kk vv]] (assoc m kk vv)) \n    {} \n    (reverse (partition 2 (interleave k v)))))","problem":61,"user":"4f017593535dcb61093f6a36"},{"problem":61,"code":"(fn [ks,vs]\n    (apply merge \n        (map (fn [k,v] {k v}) ks vs)))","user":"54213a8fe4b01498b1a71aaf"},{"code":"(fn [& args]\n  (into {} (apply map vector args)))","problem":61,"user":"53834ed3e4b06839e8705edb"},{"code":"(fn [a b] (apply hash-map (flatten (map list a b))))","problem":61,"user":"52bb27fee4b07a9af57922df"},{"problem":61,"code":"(fn [kys vas]\n (apply hash-map(interleave kys vas)))","user":"570243e2e4b08d47c97781dd"},{"problem":61,"code":"(fn [list1 list2]\n\t(loop [list1 list1 list2 list2 mymap {}]\n\t\t(if (or (empty? list1) (empty? list2))\n\t\t\tmymap\n\t\t\t(recur (rest list1) (rest list2) (assoc mymap (first list1) (first list2))))))","user":"5b8aa478e4b0c0b3ffbd49b2"},{"code":"(fn [as bs]\n  (loop [a (first as)\n         as (rest as)\n         b (first bs)\n         bs (rest bs)\n         h {}]\n    (if (and a b)\n      (recur (first as) (rest as) (first bs) (rest bs) (assoc h a b))\n      h)))","problem":61,"user":"4ffc10aae4b0678c553fc3d6"},{"problem":61,"code":"(fn [c1 c2] (into {} (map (fn [x y] [x y]) c1 c2)))","user":"53f67bcfe4b0db01ade6f9e1"},{"problem":61,"code":"(fn [ks vs] (reduce merge (map array-map ks vs)))","user":"5fe0d4d4e4b05ac5b16ea164"},{"code":"(fn [ks vs]\r\n  (loop [m {}\r\n   a ks\r\n\t b vs]\r\n    (let [k (first a)\r\n\t  v (first b)]\r\n      (if (or (nil? k) (nil? v))\r\n\tm\r\n\t(recur (assoc m k v)\r\n\t       (rest a)\r\n\t       (rest b))))))","problem":61,"user":"4fdc067fe4b05e33b9224f69"},{"code":"(fn zippy [keys vals]\n    (loop [map {}\n           ks (seq keys)\n           vs (seq vals)]\n      (if (and ks vs)\n        (recur (assoc map (first ks) (first vs))\n               (next ks)\n               (next vs))\n        map)))","problem":61,"user":"526397f1e4b03e8d9a4a70b6"},{"problem":61,"code":"(fn [k v]\n  (reduce into (map hash-map k v)))","user":"566a6e38e4b0a866af68969b"},{"problem":61,"code":"(fn [s1 s2]\n     (apply assoc {} (interleave s1 s2)))","user":"5458c74de4b01be26fd74623"},{"problem":61,"code":"(fn [coll1 coll2]\n        \n         (apply hash-map(interleave coll1 coll2)))","user":"5f737899e4b02876ed9fd099"},{"code":"(fn [c1 c2]\n      (loop [r {} co1 c1 co2 c2]\n         (if (and (> (count co2) 0) (> (count co1) 0))\n              (recur (assoc r (first co1) (first co2)) (rest co1) (rest co2) )\n               r)))","problem":61,"user":"504457c0e4b01f6c9a8b2360"},{"problem":61,"code":"(fn makemap \n  [k v]\n  (loop [k k v v r {}]\n    (if (or (empty? k) (empty? v))\n      r\n      (recur (rest k) (rest v) (assoc r (first k) (first v))))))","user":"5f088bb3e4b0cf489e8d7f5f"},{"code":"(fn [k v] (reduce #(conj %1 %2) {} (map #(vector %1 %2) k v)))","problem":61,"user":"52c8758be4b0c2d177d62135"},{"problem":61,"code":"(fn f [a b]\n  (cond\n   (empty? a) {}\n   (empty? b) {}\n   :else (assoc (f (rest a) (rest b)) \n           (first a)\n           (first b))\n   ))","user":"541ef7e2e4b01498b1a71a92"},{"code":"#(apply hash-map(interleave %1 %2))","problem":61,"user":"517e6671e4b0329b27fa9f56"},{"code":"(fn construct-map [ks vs]\n  (into {} (map vec (partition 2 (interleave ks vs)))))","problem":61,"user":"521b339fe4b0c4ef0be83031"},{"problem":61,"code":"#((fn [r l]\n    (if (seq l)\n      (recur (merge r {(first l) (nth l 1)}) (drop 2 l))\n      r)) {} (interleave %1 %2))","user":"54b2ec84e4b09f271ff37d33"},{"problem":61,"code":"(fn [ xs ys]  (into {} (for [ [key value] (map vector xs ys) ]  {key value} )))","user":"52d24f60e4b099d49816f0a8"},{"code":"(fn [k v]\n  (apply assoc nil (interleave k v)))","problem":61,"user":"50901b2ee4b0ea685a20f774"},{"problem":61,"code":"(fn [s1 s2] (apply hash-map (interleave s1 s2)))","user":"55b0f5bfe4b002ce9d5cbc28"},{"problem":61,"code":"#(loop\n   [ks %1 vs %2 res {}]\n   (if (or (empty? ks) (empty? vs))\n     res\n     (recur (rest ks) (rest vs)\n            (assoc res (first ks) (first vs)))))","user":"55ed37ebe4b0121d4835fdd6"},{"code":"#(loop [k %1\n        v %2\n        m {}]\n   (if (or (empty? k) (empty? v)) m\n     (recur (rest k) (rest v) (assoc m (first k) (first v)))))","problem":61,"user":"537e745ae4b06839e8705ea6"},{"code":"#((fn [l1 l2 acc]\n     (if (or (empty? l1) (empty? l2))\n       acc\n       (recur (rest l1) (rest l2) (assoc acc (first l1) (first l2))))) %1 %2 (hash-map))","problem":61,"user":"4ff355a1e4b0678c553fc34d"},{"problem":61,"code":"(fn [a b]\n  (into {} (map vector (apply list a) b)))","user":"5b7292b3e4b047b03b2036a4"},{"code":"(fn [l n] (reduce merge \n  (apply map #(hash-map % %2) [l n])))","problem":61,"user":"4f0333f6535dcb61093f6a77"},{"problem":61,"code":"#(into {}(map (fn [a b] (assoc {} a b)) %1 %2))","user":"5505d137e4b086ebe8a79c8c"},{"problem":61,"code":"(fn [ks vs]\n   (into {} \n   \t(map vector  ks vs)))","user":"58c4492be4b021aa9917ed27"},{"problem":61,"code":"(fn f [x y] \n  (apply hash-map \n    (interleave x y)))","user":"4e6a5728535d8ccf87e9fecf"},{"problem":61,"code":"(fn [ks vs] (into {} (map (fn [x y] [x y]) ks vs)))","user":"5280539ce4b0757a1b1713f3"},{"problem":61,"code":"#(apply hash-map (flatten (map list %1 %2)))\n\n;Reference for hash-map https://clojuredocs.org/clojure.core/hash-map","user":"5a99b87ee4b0d174b936c7af"},{"code":"(fn [x y] \n   (apply merge \n          (map (fn [a b] {a b}) x y)) )","problem":61,"user":"52eee533e4b05e3f0be25ecb"},{"problem":61,"code":"#(apply hash-map \n        (interleave %1 %2))","user":"5a9cdec0e4b0d174b936c7e1"},{"problem":61,"code":"(fn [a-col b-col]\n  (loop [a-col  a-col\n         b-col  b-col\n         result {}]\n    (if (some empty? (list a-col b-col))\n      result\n      (recur\n        (rest a-col)\n        (rest b-col)\n        (assoc result (first a-col) (first b-col))\n      ))))","user":"5978b4c9e4b01722bebd4d13"},{"code":"(fn map-zip [k v]\n  (let [n (min (count k) (count v))\n        acc (atom {})]\n    (doseq [i (range n)]\n      (swap! acc (fn [_] (assoc @acc (get k i) (get v i)))))\n    @acc))","problem":61,"user":"52d6664be4b09f7907dd1359"},{"problem":61,"code":"(fn [a b]\n  (loop [a a\n         b b\n         acc {}]\n    (if (or (empty? a) (empty? b))\n      acc\n      (recur (rest a) (rest b) (assoc acc (first a) (first b))))))","user":"5141a8f2e4b02fd87f5064c1"},{"code":"(comp (partial into {}) (partial map hash-map))","problem":61,"user":"5040edf4e4b0ff5d2cc40db5"},{"problem":61,"code":"(fn [& vecs] (apply hash-map (apply interleave vecs)))","user":"6059d824e4b07e92fa001acf"},{"problem":61,"code":"(fn [keys vals]\n  (into {} (map vec (partition 2 (interleave keys vals)))))","user":"57644395e4b0994c1922fbf2"},{"code":"#(into {} (mapcat hash-map %1 %2))","problem":61,"user":"504eff22e4b0e7ad84dbc4a9"},{"problem":61,"code":"(fn [x y](into {} (map hash-map x y)))","user":"5756e218e4b02ea1147992e5"},{"problem":61,"code":"(fn zm [kys vlz]\n  (reduce\n   conj\n   (map\n    (fn [k v] {k v})\n    kys\n    vlz\n    )\n   )\n  )","user":"5b5e5019e4b0c6492753e6d3"},{"problem":61,"code":"(fn [colla collb] (reduce merge (mapv #(assoc {} %1 %2) colla collb)))","user":"560039cce4b04bb52996e162"},{"code":"#(loop [map {}\n           ks (seq %)\n           vs (seq %2)]\n      (if (and ks vs)\n        (recur (assoc map (first ks) (first vs))\n               (next ks)\n               (next vs))\n        map))","problem":61,"user":"5047782ce4b0371827a27bc2"},{"problem":61,"code":"(fn\n  [x1 x2]\n  (loop [y 0 j {}]\n    (if (= y (min (count x1) (count x2)))\n      j\n      (recur (inc y) (assoc j (nth x1 y) (nth x2 y))))))","user":"54bcab07e4b0ed20f4ff6ed5"},{"problem":61,"code":"#(loop [m {}\n         k  %\n         v  %2]\n    (if (and v k)\n      (recur\n       (assoc m (first k) (first v))\n       (next k) (next v))\n      m))","user":"5afdca89e4b0cc2b61a3bd20"},{"code":"(fn [keys vals]\n  (loop [acc {} ks keys vs vals]\n    (if (or (empty? ks) (empty? vs))\n  acc\n (recur (assoc acc (first ks) (first vs)) (rest ks) (rest vs)))))","problem":61,"user":"4f26d6d9e4b0d6649770a007"},{"problem":61,"code":"(fn [v1 v2] (apply merge (map #(assoc {} %1 %2) v1 v2)))","user":"53ea72b6e4b036ad0777e4e5"},{"problem":61,"code":"(fn [x y] (apply hash-map (flatten (map list x y))))","user":"5d2ca236e4b01671435dbc94"},{"code":"(fn conm\n  \t([lst1 lst2] (conm {} lst1 lst2))\n  ([m lst1 lst2] (if (or (empty? lst1) (empty? lst2)) m (conm (conj m [(first lst1) (first lst2)]) (next lst1) (next lst2))))\n  )","problem":61,"user":"5272669de4b03e8d9a4a742e"},{"code":"(fn z[keys vals] \n  (let [[k & keys] keys \n        [v & vals] vals] \n    (if (and k v) \n      (assoc (z keys vals) k v) \n      {})))","problem":61,"user":"4f1fd734535d64f6031464a5"},{"problem":61,"code":"(fn f [[a & ar] [b & br]] (if (and ar br) (merge {a b} (f ar br)) {a b}))","user":"59adec09e4b0e1f4e384c897"},{"problem":61,"code":"(fn [k v] (->> (interleave k v) (partition 2) (reduce #(assoc %1 (first %2) (last %2)) {})))","user":"584d8724e4b0b7285a6f4e3e"},{"problem":61,"code":"(fn [ks vs]\n  (reduce #(apply assoc %1 %2) {} (map list ks vs)))","user":"5d27da09e4b092dab7f59c75"},{"code":"#(into {}\n  (map vector % %2))","problem":61,"user":"4f01c938535dcb61093f6a39"},{"problem":61,"code":";(fn [k v] (into {} (map #(vector %1 %2) k v)))\n\n;#(into {} (map (fn [a b] [a b]) %1 %2))\n\n;more concise:\n#(into {} (map vector % %2))","user":"55e01f4ee4b050e68259b406"},{"problem":61,"code":"(fn foo [key vals]\n        (if(or (empty? key ) (empty? vals))\n          nil\n          (conj (hash-map (first key) (first vals)) \n                (foo (rest key) (rest vals)))))","user":"6038b6b4e4b0d5df2af222ef"},{"problem":61,"code":"(fn make_map [ks vs]\n  (apply assoc {} (interleave ks vs)))","user":"561eb82fe4b064ca9f4b16c7"},{"code":"#(into (sorted-map) (map vector %1 %2))","problem":61,"user":"517945dce4b0684c1c981a43"},{"problem":61,"code":"(fn [k v] \n  (loop [ik k \n         iv v \n         acc {}]\n    (let [fk (first ik)\n          fv (first iv)]\n    (if (and fk fv)\n      (recur (rest ik) (rest iv) (assoc acc fk fv))\n      acc\n      )\n    \n    )\n  ))","user":"54bbba99e4b0ed20f4ff6ec2"},{"code":"(fn [k, v]\n   (reduce #(assoc %1 (%2 0) (%2 1)) {} (map vector k v))\n   )","problem":61,"user":"5048202fe4b0ec70b3ef8d9a"},{"problem":61,"code":"(fn [x y]\n  (apply assoc {} (interleave x y)))","user":"56990b68e4b0542e1f8d143a"},{"code":"(fn[k v] (loop [m {} a k b v] (if (or (empty? a) (empty? b)) m (recur (assoc m (first a) (first b)) (rest a) (rest b)))))","problem":61,"user":"4f148418535d64f60314643a"},{"code":"(fn [keys vals]\n  (loop [mymap {}\n        mykeys (seq keys)\n        myvals (seq vals)]\n    (if (and mykeys myvals)\n      (recur (assoc mymap (first mykeys) (first myvals))\n        (next mykeys)\n        (next myvals))\n    mymap)))","problem":61,"user":"4f98da04e4b0dcca54ed6cf7"},{"code":"(fn problem-61 [one two]\n  (apply hash-map (interleave one two)))","problem":61,"user":"4f31519ae4b0d6649770a086"},{"code":"(fn to-map [seqa seqb] \n  (if \n    (or (empty? seqa) (empty? seqb))\n    {}\n\t(merge\n     {(first seqa) (first seqb)}\n     (to-map (rest seqa) (rest seqb)))))","problem":61,"user":"538c3424e4b0b51d73faae58"},{"code":"(fn my-zipmap [keys vals]\n  (loop [k (seq keys)\n         v (seq vals)\n         map {}]\n    (if (and (first k)\n             (first v))\n      (recur (rest k) (rest v) (assoc map (first k) (first v)))\n      map)))","problem":61,"user":"4f6e7073e4b07046d9f4efd8"},{"problem":61,"code":"#(reduce\n   (fn [m [k v]]\n     (assoc m k v))\n   {}\n   (partition 2 (interleave %1 %2)))","user":"511688d5e4b0b3e208dba05a"},{"problem":61,"code":"(fn [k v]\n  (loop [m {}\n         k k\n         v v]\n    (cond\n     (or (empty? k)\n         (empty? v)) m\n     true (recur (conj m [(first k) (first v)]) (rest k) (rest v)))))","user":"551ed214e4b08d5046aa8a4d"},{"code":"(fn my-zipmap [some-keys some-vals]\n  (apply hash-map (interleave some-keys some-vals)))\n\n;;(fn my-zipmap [some-keys some-vals]\n;;  (into {} (map #(vector %1 %2) some-keys some-vals)))","problem":61,"user":"53713ed9e4b0fc7073fd6eaf"},{"code":"#(reduce conj(map (fn[a b]{a b})%1%2))","problem":61,"user":"4f296a80e4b0d6649770a02a"},{"code":"(\n  fn sol [ coll1 coll2 ] (\n\t\tapply hash-map ( interleave coll1 coll2 ) \n\t)\n)","problem":61,"user":"50bf7b72e4b0ffd967a66cc1"},{"problem":61,"code":"(fn [k v]                                                                                                                                                                              \n  (apply assoc {} (interleave k v)))","user":"57a499dae4b0a966079561e6"},{"problem":61,"code":"(fn my-map-cons[a b]\n  (loop [res {}\n         tail-k a\n         tail-v b]\n    (if (or (empty? tail-k) (empty? tail-v))\n      res\n      (recur (assoc res (first tail-k) (first tail-v))\n             (rest tail-k) (rest tail-v)))))","user":"5bf50e76e4b0b326c961d8a0"},{"code":"(fn [k v] (into {} (map vector k v)))","problem":61,"user":"503917a0e4b088a6a14ca763"},{"problem":61,"code":"(fn [keys vals] (into {} (mapv vector keys vals)))","user":"5acc961ae4b0e27600da7810"},{"problem":61,"code":"(fn  [kcol vcol]\n  (apply hash-map (interleave kcol vcol)))","user":"53664e3be4b0243289761e74"},{"code":"(fn mzip [a b]\n  (loop [x a y b o {}]\n    (if (or (empty? x) (empty? y))\n      o\n      (recur (rest x) (rest y) (assoc o (first x) (first y))))))","problem":61,"user":"5101192ae4b0bef64c30e266"},{"code":"(fn problem61 [a b]\n  (apply array-map\n     (flatten\n       (let [x (first a)\n             y (first b)]\n         (if (and x y)\n           (cons (list x y) (problem61 (rest a) (rest b))))))))","problem":61,"user":"4db6ce85535d1e037afb217f"},{"code":"#(reduce merge(map \n (fn [x] (hash-map (first x) (second x))) \n     (partition 2 (interleave % %2))))","problem":61,"user":"5260341ee4b03e8d9a4a7034"},{"code":"(fn [c1 c2]\n  (loop [i 0\n         r {}]\n    (if (or (>= i (count c1)) (>= i (count c2)))\n      r\n      (recur (inc i) (assoc r (get c1 i) (get c2 i))))))","problem":61,"user":"51b86a0fe4b09e0e347b2e78"},{"problem":61,"code":"#(apply (partial assoc {}) (interleave % %2))","user":"5405ae2be4b0addc1aec6671"},{"code":"(fn [a b]\n  (into {} \n        (map vector a b)))","problem":61,"user":"520332f7e4b030ee0c5b2714"},{"code":"(fn [a b]\n  (loop [h {} k a v b]\n    (if (or (empty? k) (empty? v)) h\n        (recur (assoc h (first k) (first v))\n               (rest k) (rest v)))))","problem":61,"user":"52d1e364e4b0d9f9285948e7"},{"code":"(fn _zipmap [k v] (reduce (fn [acc [k v]](assoc acc k v)) {} (map vector k v)))","problem":61,"user":"511ac026e4b0c87c59c9670e"},{"problem":61,"code":"(fn [v1 v2]\n  (reduce (fn [a b]\n            (conj a {(first b) (second b)})) {} (partition-all 2 (interleave v1 v2))))","user":"60aecd73e4b00e9e6653c49a"},{"code":"(fn f\n  [x y]\n  (apply merge (for [i (range (min (count x) (count y)))]\n                 (let [[k v] [(get x i) (get y i)]]\n                 {k v}))))","problem":61,"user":"52f3af46e4b05e3f0be25f14"},{"problem":61,"code":"(fn [mykeys values]\n  (loop [res {}\n         mykeys mykeys\n         values values]\n    (if-not (or (empty? mykeys) (empty? values))\n      (recur (assoc res (first mykeys) (first values)) (rest mykeys) (rest values))\n      res)))","user":"560151b5e4b04bb52996e185"},{"problem":61,"code":"(fn [coll1 coll2]\n  (apply merge-with into (map hash-map coll1 coll2))\n  )","user":"55240916e4b0882d96d091b6"},{"code":"#(loop [m {} k %1 v %2]\r\n  (if (or (empty? k) (empty? v))\r\n    m\r\n    (recur (assoc m (first k) (first v)) (rest k) (rest v))))","problem":61,"user":"4fb54e50e4b081705acca2bb"},{"code":"(fn [kcoll vcoll] (apply hash-map (interleave kcoll vcoll)))","problem":61,"user":"53806e5be4b06839e8705ec1"},{"code":"(fn [k v]\n  (apply hash-map (flatten (map (fn [a b] [a b]) k v))))","problem":61,"user":"4f343e60e4b0e243712b1eb5"},{"code":"(fn map-construction\n  \t([v1 v2]\n\t\t\t(if (or (empty? v1) (empty? v2)) {}\n\t\t\t\t(assoc (map-construction (rest v1) (rest v2)) (first v1) (first v2)))))","problem":61,"user":"4e6a63fd535d8ccf87e9feda"},{"problem":61,"code":"#(apply assoc {} \n        (interleave %1 %2))","user":"55cc6c35e4b0e31453f64a10"},{"code":"(fn zm [a b & m] (let [m (if (nil? m) {} (first m)) aa (first a) bb (first b)] (if (and aa bb) (zm (rest a) (rest b) (assoc m aa bb)) m)))","problem":61,"user":"50366589e4b0fbe0a74d26c3"},{"problem":61,"code":"(fn map-reduce [ks vs]\n  (into {} (map #(assoc {} % %2) ks vs)))","user":"51316a63e4b0431ba07e7feb"},{"code":"(fn [c1 c2] (apply array-map (flatten (map vector c1 c2))))","problem":61,"user":"536f5900e4b0fc7073fd6e7b"},{"code":"(fn fill [keys values] (\n  loop [ks keys, vs values, kvs {}]\n    (if (or (empty? ks) (empty? vs))\n        kvs\n        (recur (rest ks) (rest vs) \n               (assoc kvs (first ks) (first vs)))\n)))","problem":61,"user":"4ed500bb535d10e5ff6f52d3"},{"problem":61,"code":"(fn [vec1 vec2] (into {} (map #(assoc {} %1 %2) vec1 vec2)))","user":"56df62b3e4b0ca2494a095ef"},{"problem":61,"code":"(fn [a b](apply hash-map (interleave a b)))","user":"607f3336e4b05857a65e7747"},{"problem":61,"code":"(fn zipmap' [keys values]\n  (into {}\n        (map vector keys values)))","user":"5b602a66e4b0c6492753e6fc"},{"problem":61,"code":"(fn [acc [x & xs :as X] [y & ys :as Y]]\n  (if (or (empty? X) (empty? Y))\n    acc\n    (recur (conj acc {x y}) xs ys))) {}","user":"59a72effe4b066c664927d94"},{"code":"(fn myMap \n    ([x y z]\n        (if (or (empty? x) (empty? y))\n            z\n        (myMap (rest x) (rest y) (assoc z (first x) (first y)))))\n    ([x y] (myMap x y {})))","problem":61,"user":"4f03b3fb535dcb61093f6b52"},{"code":"(fn [k v] (reduce #(apply assoc %1 %2) {} (map vector k v)))","problem":61,"user":"513d121fe4b0e544971636a2"},{"problem":61,"code":"(fn [k v]\n  (let [step\n        (fn [k v m]\n          (if (and (seq k) (seq v))\n            (recur (rest k) (rest v) (assoc m (first k) (first v)))\n            m))]\n    (step k v (hash-map))))","user":"5953bdb6e4b066ee0a44aeed"},{"problem":61,"code":"#(->> (interleave %1 %2) (apply hash-map))","user":"57e0f30ae4b0bfb2137f5a66"},{"problem":61,"code":"(fn [kvect, vvect] (apply conj (map (fn [x y] (assoc {} x y)) kvect vvect)))","user":"5a5894d9e4b05d388ecb6c81"},{"problem":61,"code":"(fn [k v] \n  (apply hash-map\n   (interleave k v)\n  )\n)","user":"580c8fcee4b0849f6811b721"},{"problem":61,"code":"(fn zm [a b]\n  (let [ca (count a) cb (count b) c (if (< ca cb) ca cb)]\n    (loop [n 0 r {}]\n      (if (= n c)\n        r\n        (recur (inc n) (assoc r (nth a n) (nth b n)))))))","user":"561a1af6e4b053970a773b02"},{"code":"(fn myzipmap [keys values]\n  (loop [ks keys\n         vs values\n         map {}]\n    (if (and (seq ks) (seq vs))\n      (recur (rest ks) (rest vs)\n             (assoc map (first ks) (first vs)))\n      map)))","problem":61,"user":"50c84ba2e4b00bb60fe0c53e"},{"code":"(fn [ks vs]\n    (apply hash-map (mapcat #(list %1 %2) ks vs)))","problem":61,"user":"4e89e939535d3e98b8023287"},{"problem":61,"code":"(fn\n  [xs ys]\n  (reduce (fn\n            [acc x]\n            (assoc acc (first x)(last x))\n            )\n          {}\n          (map (fn [x y] (vector x y)) xs ys)\n  ))","user":"5e1c24f4e4b0dc959400852d"},{"problem":61,"code":"(fn [k v]\n  (loop [mp {} kk k vv v]\n    (if (or (empty? kk) (empty? vv))\n      mp\n      (recur\n       (assoc mp (first kk) (first vv)) (rest kk) (rest vv)))))","user":"54864662e4b0e286459a11b8"},{"code":"#(reduce into  (map (fn [x y] (assoc {} x y)) % %2))","problem":61,"user":"52eb400ee4b0705949c4443b"},{"problem":61,"code":"(fn combine-maps [x y]\n  (if (or (empty? x) (empty? y))\n    {}\n    (assoc (combine-maps (rest x) (rest y)) (first x) (first y))))","user":"5e18c885e4b0dc95940084fc"},{"code":"(fn ass \n  ([c1 c2]\n    (ass c1 c2 {}))\n  ([c1 c2 acc]\n    (if (or (empty? c1) (empty? c2))\n      acc\n      (recur (rest c1) \n             (rest c2) \n             (assoc acc (first c1) (first c2))))))","problem":61,"user":"4e5a2403535d8a8b8723a2a7"},{"problem":61,"code":"(fn [arr1 arr2]\n   (loop [op_map {}  ip1 arr1 ip2 arr2]\n     (if (and (first ip1) (first ip2))\n       (recur (assoc op_map (first ip1) (first ip2))\n              (drop 1 ip1)\n              (drop 1 ip2))\n       op_map)))","user":"5d8c8175e4b0915913b1d3e1"},{"problem":61,"code":"(fn [k value]\n (into {} (map vector k value))\n  )","user":"5be9d530e4b0f319e2d7ec79"},{"code":"(fn [ks vs]\r\n    (reduce (fn [m [k v]] (assoc m k v)) \r\n            {}\r\n            (partition 2 (interleave ks vs)))\r\n    )","problem":61,"user":"4f0da4e4535d0136e6c22319"},{"problem":61,"code":"(fn [a b] (into {} (map vec (partition 2 (mapcat list a b)))))","user":"4f47d84fe4b0d56e7bb92bc3"},{"problem":61,"code":"(fn [ks vs] (apply hash-map (apply concat (map vector ks vs))))","user":"54d03026e4b018d918be98de"},{"code":"(fn my-zipmap [key-list val-list]\n  (loop [ks key-list vs val-list zm {}]\n    (if (and ks vs)\n      (recur (next ks)\n             (next vs)\n             (assoc zm (first ks) (first vs)))\n      zm)))","problem":61,"user":"4f8bbb27e4b02e764a0a5182"},{"problem":61,"code":"(fn map-cons\n  [x y] \n  \n  (apply assoc {} (interleave x y)))","user":"5a99ae99e4b0d174b936c7a4"},{"code":"(fn zm [ks vs]\r\n  (apply hash-map (interleave ks vs)))","problem":61,"user":"4dfd4ba8535d04ed9115e781"},{"problem":61,"code":"(fn map-construction [seq1 seq2]\n  (loop [s1 seq1\n         s2 seq2\n         xs {}]\n    (if (and (seq s1) (seq s2))\n      (let [f1 (first s1)\n            f2 (first s2)\n            new-xs (into xs {f1 f2})]\n        (recur (rest s1) (rest s2) new-xs))\n      xs)))","user":"5df0c6ffe4b093ff717275c2"},{"code":"#(loop [m {} k %1 v %2]\n  (if (or (empty? k) (empty? v)) m\n    (recur  (assoc m (first k) (first v)) (rest k) (rest v))))","problem":61,"user":"5167e4a2e4b0c5a4140a3099"},{"problem":61,"code":"(fn [c1 c2] (into {} (map #(vector % %2) c1 c2)))","user":"535774c2e4b04ce2eb3ed27c"},{"code":"(fn [a b] (apply hash-map (interleave a b)))","problem":61,"user":"4e89ddf9535d3e98b8023284"},{"problem":61,"code":"(fn [x y]\n  \n    (loop [a (reverse (take (count y) x))\n           b (reverse (take (count x) y))\n           end {}]\n      (if (empty? a)\n        end\n        (recur (rest a) (rest b) (conj end {(first a) (first b)})))))","user":"55244318e4b0882d96d091be"},{"code":"(fn [x y]\n  (reduce (fn [m [k v]] \n            (into m {k v})) {} (map vector x y))\n  )","problem":61,"user":"51bec919e4b013aa0d74b800"},{"problem":61,"code":"(fn [a b]\n (apply hash-map\n  (interleave a b))\n)","user":"549a999be4b0f3d1d8e70f6f"},{"code":"(fn [sq1 sq2] (reduce #(assoc %1 (first %2) (second %2)) {} (map vector sq1 sq2)))","problem":61,"user":"50fbdacfe4b0d10d794c19f0"},{"code":"#(apply merge (map (fn[k v] {k v}) % %2))","problem":61,"user":"4eca40cd535d6d7199dd3703"},{"problem":61,"code":"(fn [k v]\n  (reduce #(assoc %1 (first %2) (last %2)) {} (partition 2 (interleave k v))))","user":"53b182a5e4b047364c044491"},{"code":"#(into {}\n       (map vec (partition 2 (interleave % %2))))","problem":61,"user":"4e3996b0535deb9a81d77f41"},{"problem":61,"code":"(fn t\n  [ceys vals]\n  (loop [r {}\n         ceys ceys\n         vals vals]\n    (if-not (or (empty? ceys) (empty? vals))\n      (recur (merge r {(first ceys) (first vals)})\n             (rest ceys)\n             (rest vals))\n      r)))","user":"58de563fe4b0a4d5acaab6e3"},{"code":"(fn f [A B]\n  (if (or (empty? (rest A)) (empty? (rest B)))\n    (conj {(first A) (first B)} {})\n    (conj {(first A) (first B)} (f (rest A) (rest B)))))","problem":61,"user":"51ad0ab8e4b09397d510977b"},{"code":"(fn [ks vs]\n  (loop [k ks v vs m {}]\n    (if (or (= (count k) 0) (= (count v) 0))\n      m\n      (recur (drop 1 k) (drop 1 v) (assoc m (first k) (first v))))))","problem":61,"user":"52b94f15e4b07a9af57922ba"},{"problem":61,"code":"#(apply hash-map\n        (apply concat\n               (map list %1 %2)))","user":"55627de1e4b0c656e3ff17d9"},{"problem":61,"code":"(fn [ks vs] (loop [m {} k ks v vs] (if (or (empty? k) (empty? v)) m (recur (conj m [(first k) (first v)]) (rest k) (rest v)))))","user":"5ab564f8e4b073f177442639"},{"problem":61,"code":"#(loop\n   [a %1\n    b %2\n    s {}]\n   (if (or (empty? a) (empty? b)) s\n       (recur (rest a) (rest b) (conj s {(first a) (first b)}))))","user":"55e732c5e4b050e68259b492"},{"problem":61,"code":"(fn [keys vals] (into {}  (map (fn [k v] [k v]) keys vals)))","user":"5d89427ae4b0915913b1d3b5"},{"code":"(fn [v1 v2]\n  (apply assoc {} (interleave v1 v2)))","problem":61,"user":"5348cab4e4b084c2834f4a5e"},{"problem":61,"code":"(fn [keylist\n     vallist]\n  (loop [k keylist\n         v vallist\n         out {}]\n    (if (or (empty? k) (empty? v))\n      out\n    (recur (rest k) (rest v) (conj out [(first k) (first v)])))))","user":"5ec819b4e4b08d0ec38692e2"},{"code":"(fn [keys vals]\n  (loop [m {} \n    ks keys\n    vs vals]\n    (if (and ks vs)\n(recur (assoc m (first ks) (first vs))\n  (next ks)\n  (next vs))\nm)))","problem":61,"user":"4ebd4448535dfed6da9c6d8f"},{"problem":61,"code":"(fn [ks vs]\n  (apply merge (map #(hash-map \n                %1 %2) ks vs)))","user":"53da059be4b0e771c302547e"},{"problem":61,"code":"(fn algo \n  [lst1 lst2]\n  (apply hash-map (interleave lst1 lst2))\n  )","user":"59e56c75e4b08badc2a0c556"},{"problem":61,"code":"(fn [k v]\n (apply merge \n  (mapv #(hash-map %1 %2) k v))\n)","user":"59c243bae4b0a024fb6ae4aa"},{"code":"(fn [x y] (reduce #(merge %1 %2) (map hash-map x y)))","problem":61,"user":"51f13b80e4b06a20a2523f38"},{"code":"(fn my-zipmap [keys vals]\n  (loop [my-map {}\n         my-keys keys\n         my-vals vals]\n    (if (and (seq my-keys) (seq my-vals))\n      (recur (assoc my-map (first my-keys) (first my-vals))\n             (rest my-keys)\n             (rest my-vals))\n      my-map)))","problem":61,"user":"52b35a6ee4b0c58976d9ad07"},{"code":"(fn map-construct [xs ys]\r\n  (if (or (empty? xs) (empty? ys))\r\n    {}\r\n    (merge {(first xs) (first ys)}\r\n           (map-construct (next xs) (next ys)))))","problem":61,"user":"4dd023dd535d5973398f92ad"},{"code":"(fn [& ls] (apply hash-map (flatten (apply (partial map list) ls))))","problem":61,"user":"4f03ba9c535dcb61093f6b58"},{"problem":61,"code":"(fn map-from-vectors [kv vv]\n  (loop [k kv, v vv, acc {}]\n    (if (or (empty? k) (empty? v)) acc\n      (recur (rest k) (rest v) (conj acc {(first k) (first v)})\n))))","user":"54bbe505e4b0ed20f4ff6ec5"},{"problem":61,"code":"(fn [k v]\n  (loop [kk k vv v ret {}]\n    (if (or (empty? kk) (empty? vv))\n      ret\n      (recur (rest kk) (rest vv) (assoc ret (first kk) (first vv))))))","user":"5151d574e4b03e678e393ae0"},{"problem":61,"code":";not sure if this index i is what should i do in func programming\n(fn [keys values]\n  (loop [result {} i 0]\n    (if (or (>= i (count values)) (>= i (count keys)))\n      result\n  \t  (recur (assoc result (nth keys i) (nth values i)) (inc i))\n    )\n  )\n)","user":"5991d2fae4b0866487ed0d68"},{"code":"(fn asdf[x y] (apply assoc {} (interleave x y)))","problem":61,"user":"5012036ce4b0a040369c12f4"},{"problem":61,"code":"(fn [left, right] \n  (loop [x left,\n         y right,\n         acc {}]\n    (if (or (empty? x) (empty? y))\n      acc\n      (recur (rest x) (rest y) (assoc acc (first x) (first y))))\n  )\n)","user":"543496e1e4b0b6b47310fcf2"},{"problem":61,"code":"(fn map1 [arr1 arr2]\n (loop [x1 arr1 x2 arr2 res []]\n  (if (or (empty? x1) (empty? x2)) (into {} res)\n   (recur (next x1) (next x2) (conj res [(first x1) (first x2)])))))","user":"5e42b688e4b01d43a70e8e6b"},{"problem":61,"code":"(fn foo [s1 s2]\n(if (and (> (count s1) 0) (> (count s2) 0))\n(conj (hash-map (first s1) (first s2))  (foo (rest s1) (rest s2)))\n)\n)","user":"5f1aade6e4b091ba50b4dbe4"},{"problem":61,"code":"(fn [ls1 ls2](apply hash-map (interleave ls1 ls2)))","user":"5bc50870e4b07a9b28b10069"},{"problem":61,"code":"(fn [ks vs]\n  (loop [ks ks\n         vs vs\n         result {}]\n    (let [k (first ks)\n          v (first vs)]\n      (if (and k v)\n        (recur (rest ks) (rest vs) (assoc result k v))\n        result))))","user":"523578efe4b0a643f2dcb74c"},{"problem":61,"code":"#(into {}\n        (for [n (range (min (count %1) (count %2)))] [(get %1 n) (get %2 n)]))","user":"56a1fce9e4b0542e1f8d14b7"},{"problem":61,"code":"#(->> (interleave %1 %2)\n       (apply hash-map))","user":"4eda8d7c535d10e5ff6f530f"},{"problem":61,"code":"(fn [c1 c2] (apply merge (map (fn [key val] {key val}) c1 c2)))","user":"5880d686e4b0f1effa3b7623"},{"code":"(fn [ks vs]\n  (reduce merge\n          (map (fn [k v] {k v})\n               ks\n               vs)))","problem":61,"user":"51460e4ce4b04ef915e37314"},{"problem":61,"code":"(fn [x y](apply assoc {} (interleave x y)))","user":"566a3a26e4b0a866af689699"},{"problem":61,"code":"(fn [k v] \n  (apply hash-map (interleave k v)))","user":"53a511aae4b0b62ce3005735"},{"code":"#(reduce (fn [acc [a b]] (assoc acc a b)) {} (partition 2 (interleave % %2)))","problem":61,"user":"513fab65e4b00f13ea1bd891"},{"problem":61,"code":"(fn [& xs] \n  (->> xs \n    (apply map vector) \n    (into {})))","user":"5da8fa72e4b000c986472c2d"},{"code":"#(apply hash-map (interleave %1 %2) )","problem":61,"user":"4fc43a8ee4b081705acca346"},{"code":"#(apply hash-map (mapcat vector % %2))","problem":61,"user":"4ea09fa4535d7eef308072aa"},{"code":"(fn [keys values]\r\n    (reduce (fn [m [k v]]\r\n              (assoc m k v))\r\n            {}\r\n            (map vector keys values)))","problem":61,"user":"4f047177535dcb61093f6bc6"},{"code":"(fn [a b]\n  (into {} (for [x (range (min (count b) (count a)))]\n    (vector (nth a x) (nth b x)))))","problem":61,"user":"52c52ef2e4b0c2d177d620ef"},{"problem":61,"code":";(fn zipcat* [& cols]\n;  (reduce #(assoc %1 (first %2) (second %2)) {} (apply map list cols)))\n\n(fn [ks vs] (apply hash-map (interleave ks vs)))\n\n;#(into {} (map vector  %1 %2))","user":"58299e03e4b051871117bf46"},{"problem":61,"code":"(fn [x y] (into {} (map #(vector %1 %2) x y)))","user":"544fbabce4b0e39780006999"},{"problem":61,"code":"(fn my-zipmap [xs ys]\n  (into (sorted-map) (map #(vector %1 %2) xs ys)))","user":"598601f9e4b021a7a535fe79"},{"problem":61,"code":"(fn [a b] (apply sorted-map (reduce concat [] (map #(conj [%] %2) a b))))","user":"552f300fe4b076ab5578f7ff"},{"problem":61,"code":"#(into {} (map (fn [[a b]] (vector a b)) (partition 2 (interleave %1 %2))))","user":"5b2689e3e4b063e2438bcc33"},{"problem":61,"code":"(fn [keyz valz] (into {} (mapv vector keyz valz)))","user":"5ecf4ee4e4b016b56eae05a6"},{"code":"#(reduce into (map hash-map % %2))","problem":61,"user":"4e49badd535dc968683fc4c9"},{"problem":61,"code":"(fn [llaves v] \n  (apply array-map \n         (interleave llaves v)))","user":"59e12c94e4b08badc2a0c509"},{"problem":61,"code":"(fn [-s1 -s2]\n    (loop [s1 -s1 s2 -s2 nw {}]\n          (if (or (empty? s1) (empty? s2))\n              nw\n              (recur (rest s1) (rest s2) (conj {(first s1) (first s2)} nw)))))","user":"57e3f709e4b0bfb2137f5aaf"},{"problem":61,"code":"(fn [a b]\n    (apply merge (map (fn [x y] (assoc {} x y)) a b)))","user":"5600dccee4b04bb52996e175"},{"code":"(fn [s1 s2] (apply  merge (map #(conj {} {%1 %2}) s1 s2)))","problem":61,"user":"5022292ee4b0846bc458ae46"},{"code":"(fn zipmp\r\n  ([sk sv] (zipmp sk sv {}))\r\n  ([sk sv m]\r\n   (if (and sk sv)\r\n     (recur (next sk) (next sv) (assoc m (first sk) (first sv)))\r\n     m)))","problem":61,"user":"500159b3e4b0678c553fc419"},{"code":"(fn zippy [keys vals]\n  (cond (empty? keys) {}\n        (empty? vals) {}\n        :else (assoc (zippy (rest keys) (rest vals)) (first keys) (first vals))))","problem":61,"user":"52aa4a67e4b0c58976d9ac62"},{"code":"(fn [a b] \r\n  (apply assoc {} \r\n    (flatten\r\n      (map vector a b))))","problem":61,"user":"5048f98ee4b06e644c63f1af"},{"code":"#(loop [k %1\n        v %2\n        result {}]\n  (if (or (empty? k) (empty? v))\n      result\n      (recur (rest k) (rest v) (assoc result (first k) (first v)))))","problem":61,"user":"4e4ca885535dc968683fc4df"},{"code":"(fn [xs ys]\n  (into {} (map vec (partition 2 (interleave xs ys)))))","problem":61,"user":"4f60ed88e4b0defedf855fb2"},{"problem":61,"code":"(fn [vec1 vec2] (into {} (map vector vec1 vec2)))","user":"57f3b841e4b0511f1d294e0f"},{"problem":61,"code":"(fn peu [x y] (if (or (empty? x) (empty? y)) {} (conj (peu (rest x) (rest y)) (hash-map (first x) (first y)))))","user":"53fc8424e4b0de5c418485b3"},{"problem":61,"code":"(fn stuff\n  [keys values]\n  (let [min-length (min (count keys) (count values))]\n    (reduce\n      (fn [acc [k v]]\n        (assoc acc k v)) {} \n      (for [i (range 0 min-length)\n            :let [pair [(nth keys i) (nth values i)]]]\n        pair))))","user":"5885bea8e4b0f1effa3b76bf"},{"problem":61,"code":"(fn [k v] (loop [m {} ks (seq k) vs (seq v)] (if (and ks vs) (recur (assoc m (first ks) (first vs)) (next ks) (next vs) ) m)))","user":"563a79e5e4b0bfe05bf117fe"},{"problem":61,"code":"#( into {} ( map vector %1 %2 ) )","user":"516d227fe4b06f078fab252d"},{"problem":61,"code":"(fn [c1 c2] (into {} (reduce #(conj %1 (into [] %2)) [] (partition-all 2 (interleave c1 c2)))))","user":"58987ee9e4b00487982d52d2"},{"problem":61,"code":"(fn map-construction' [coll1 coll2]\n  (loop [[head1 & tail1] coll1\n         [head2 & tail2] coll2]\n    (println coll1 coll2)\n    (when (and coll1 coll2)\n      (conj (hash-map head1 head2) (map-construction' tail1 tail2)))))","user":"605a876be4b000d535e6f53c"},{"problem":61,"code":"(fn cmap [k v] (into {} (map #(assoc {} %1 %2) (seq k) (seq v))))","user":"55c9bc1ee4b0e31453f649f1"},{"code":"(fn [xs ys]\n  (into {} (map #(vector %1 %2) xs ys)))","problem":61,"user":"50ef96a1e4b0bdaecbb47d9d"},{"code":"(fn [k v]\r\n  (reduce conj {} (map (fn [x y] [x y]) k v)))","problem":61,"user":"507437c2e4b054001656acd0"},{"problem":61,"code":"#(reduce merge {} (map (fn [k v] {k v}) %1 %2))","user":"57a5da5ee4b0a966079561fe"},{"problem":61,"code":"#( into {} (map hash-map % %2) )","user":"569637d8e4b0dcc4269f4130"},{"code":"(fn test [x y]\n  (when\n    (and (not (empty? x)) (not (empty? y)))\n    (merge \n      (test (next x) (next y)) \t      \n      (array-map (first x) (first y))\n\t)\n  )\n)","problem":61,"user":"52810225e4b0757a1b171418"},{"problem":61,"code":"(fn [keys vals]\n   (loop [map {}\n          k (seq keys)\n          v (seq vals)]\n      (if (and k v)\n        (recur (merge map {(first k) (first v)}) (next k) (next v))\n        map)))","user":"5aa4a1ffe4b0d174b936c886"},{"code":"#(apply assoc {} (apply interleave %&))","problem":61,"user":"4fe8a1f8e4b07c9f6fd12c5f"},{"problem":61,"code":"(fn zipmap*\n  [& cols]\n  (reduce #(assoc %1 (first %2) (second %2)) {} (apply map list cols)))","user":"567931e9e4b05957ce8c6184"},{"problem":61,"code":"#(reduce (fn [acc e] (apply assoc acc e)) {} (partition-all 2 (interleave % %2)))","user":"55a74d46e4b09e57187da2a3"},{"code":"(fn [x y] (apply hash-map (interleave x y)))","problem":61,"user":"4e3ac1b2535deb9a81d77f4c"},{"code":"(fn [keys vals] \n  (loop [map {} \n         ks (seq keys) \n         vs (seq vals)]\n    (if (and ks vs)\n      (recur \n        (assoc map (first ks) (first vs)) \n        (next ks) \n        (next vs))\n      map)))","problem":61,"user":"4db13ff51254ad5b4805fa68"},{"code":"(fn [a b] (reduce conj {} (map #(assoc {} % %2) a b)))","problem":61,"user":"505d4b21e4b0e6aca564be07"},{"code":"#(apply hash-map (reduce concat (map vector %1 %2)))","problem":61,"user":"5238ca2de4b0d705d026eef6"},{"code":"(fn [k v] \n  ((fn my-zip [m ks vs] \n    (if \n      (= 0 (* (count ks) (count vs))) \n      m \n      (my-zip (assoc m (first ks) (first vs)) (rest ks) (rest vs))))\n  (hash-map) k v))","problem":61,"user":"4e89de60535d3e98b8023285"},{"problem":61,"code":"(fn\n  [ksa vsa]\n  (loop [ks ksa vs vsa res {}]\n    (if (or (empty? ks) (empty? vs))\n      res\n      (let [next-key (first ks) next-val (first vs)]\n        (recur (rest ks) (rest vs) (assoc res next-key next-val))))))","user":"529f9bf2e4b04e0c58e87bb4"},{"code":"(fn [keys vals]\n  (apply assoc {} (interleave keys vals)))","problem":61,"user":"5055899de4b0ce54f56f03fd"},{"code":"(fn [ks vs] (reduce conj (map #(hash-map %1 %2) ks vs)))","problem":61,"user":"50981062e4b04e098a4c7268"},{"code":"#(loop [k %1\n        v %2\n        m {}]\n   (if (or (empty? k) (empty? v))\n     m\n     (recur (rest k) (rest v) (assoc m (first k) (first v)))))","problem":61,"user":"51d360d1e4b099f3b6acddff"},{"problem":61,"code":"(fn f [ks vs]\n  (->> (interleave ks vs)\n       (partition 2)\n       (reduce (fn [m [k v]] (assoc m k v)) {})))","user":"57adbe7ee4b0b8559636fca0"},{"problem":61,"code":"(fn [seq1 seq2]\n  (loop [src1 seq1, src2 seq2, result {}]\n    (if (or (empty? src1)\n            (empty? src2))\n      result\n      (recur (rest src1)\n             (rest src2)\n             (assoc result\n               (first src1)\n               (first src2))))))","user":"56c55fbce4b05cc29241eea5"},{"code":"(fn create-map \r\n  ([x y]\r\n    (create-map (rest x) (rest y) (vector (first x) (first y))))\r\n  ([x y z]\r\n    (if (some #(= 0 (count %)) (list x y))\r\n      (apply hash-map z)\r\n      (recur (rest x) (rest y) (conj z (first x) (first y))))))","problem":61,"user":"4e16bdef535d04ed9115e7e9"},{"problem":61,"code":"(fn [ks vs]\n(apply hash-map\n   (mapcat\n   #(list % %2)\n   \n   ks\n   vs\n   )\n   )\n  )","user":"5735ac67e4b0cd1946bd102b"},{"problem":61,"code":"; Can be simplified and more readable using a thread last function. Use:\n;(->> (map vector ks vs) (into {})) \n(fn [ks vs]\n  (reduce (fn [res a] (into res a)) {} (map (fn [a b] [[a b]]) ks vs)))","user":"5722bf99e4b0c5bde472c0d6"},{"problem":61,"code":"(fn [ks vs]\n   (loop [k ks\n          v vs\n          w {}]\n     (cond (= k '()) w\n           (= v '()) w\n           :else (recur (rest k) (rest v) (assoc w (first k) (first v))))))","user":"566734c4e4b04acd4f672dcc"},{"problem":61,"code":"(fn [coll1 coll2]\n   (loop [c1 coll1\n          c2 coll2\n          result {}]\n     (if (and (seq c1) (seq c2))\n       (recur (rest c1) (rest c2) (assoc result (first c1) (first c2)))\n       result)))","user":"562268dce4b03f08ee9a9224"},{"problem":61,"code":"(fn [v1 v2]\n  (apply hash-map (interleave v1 v2)))","user":"55f85b93e4b03cbcff9738ae"},{"problem":61,"code":"(fn zipmap-fn [x y]\n  (loop [r {}\n         ks x\n         vs y\n         ]\n    (if (or (empty? ks) (empty? vs))\n      r\n      (recur (into r [[(first ks) (first vs)]]) (rest ks) (rest vs))\n      )\n    )\n  )","user":"5708e8f6e4b0b0fb43fd06a4"},{"problem":61,"code":"(fn [v1 v2] (reduce (fn [p i] (conj p {(nth v1 i) (nth v2 i)  })) {} (range (min (count v1) (count v2))) )  )","user":"58a9e872e4b01a0c0b232973"},{"problem":61,"code":"#(reduce (fn [m kv] (apply assoc (cons m kv))) {} (map list % %2))","user":"5c7c1d8ee4b0d597f478ca88"},{"problem":61,"code":"(fn [c1 c2]\n    (into {}\n          (map vector\n               c1\n               c2)))","user":"5be5cebde4b0ed4b8aab4d19"},{"problem":61,"code":"(fn [lst lst2] \n  (apply hash-map (interleave lst lst2)))","user":"5bcb672ee4b07a9b28b10100"},{"problem":61,"code":"(fn [lst1 lst2]\n  (loop [m {} s1 lst1 s2 lst2]\n    (if (empty? s1) m\n      (if (empty? s2) m\n        (recur (assoc m (first s1) (first s2)) (rest s1) (rest s2))))))","user":"558378dce4b05c286339e115"},{"problem":61,"code":"(fn [keys vals]\n  (reduce (fn [acc x] (conj acc x)) {} (map vector keys vals)))","user":"5315ba94e4b08068f379ed34"},{"problem":61,"code":"(fn [x y]\n  (or (apply hash-map (interleave x y))\n  (into {} (map vector x y))))","user":"5731e36be4b0cd1946bd0fc9"},{"code":"#(into  {} (map vector % %2) )","problem":61,"user":"51c1d159e4b0d204dbe2ca18"},{"problem":61,"code":"(fn [a b] (apply conj (map (fn [x y] \n      {x y}) a b)))","user":"5587d8b3e4b059ccff29b1e8"},{"code":"(fn [xs vs](into {} (map vector xs vs)))","problem":61,"user":"4efcac3a535de96065cf507e"},{"code":"(fn [& args]\n    (reduce #(assoc %1 (first %2) (second %2))\n      {}\n      (apply map list args)))","problem":61,"user":"504f57c7e4b0a02f9cffde71"},{"problem":61,"code":"(fn [aKeys values]\n  (reduce (fn [acc [aKey aVal]] (assoc acc aKey aVal)) {} (map vector aKeys values)))","user":"5773f3a9e4b0979f896515f2"},{"problem":61,"code":"(fn [keyz values]\n  (loop [out {}\n         k keyz \n         v values]\n    (if (or (empty? k) (empty? v))\n      out\n      (recur (conj out (hash-map (first k) (first v)))\n             (drop 1 k)\n             (drop 1 v)))))","user":"5633bb9de4b0bfe05bf117b4"},{"problem":61,"code":"(fn [a b]\n  (into {} (map hash-map a b)))","user":"5f4eb036e4b0102c75033969"},{"code":"(fn cp\n  [l1 l2]\n  (loop [hej {}\n         l1 l1\n         l2 l2]\n    (if (or (empty? l1) (empty? l2))\n      hej\n      (recur\n        (assoc hej (first l1) (first l2))\n        (rest l1) (rest l2)))))","problem":61,"user":"504e12ade4b078edc5f593b7"},{"problem":61,"code":"(fn map-zipper [keylist vallist]\n  (if (or (empty? keylist) (empty? vallist))\n    {}\n    (assoc (map-zipper (rest keylist) (rest vallist)) (first keylist) (first vallist))))","user":"571cd9dce4b0145328a76271"},{"code":"(fn [xs ys] (apply hash-map (interleave xs ys)))","problem":61,"user":"4f2ef48be4b0d6649770a06c"},{"code":"(fn [a b]\n  (loop [a a b b c {}]\n    (if (or (empty? a) (empty? b))\n      c\n      (recur (rest a) (rest b) (assoc c (first a) (first b))))))","problem":61,"user":"5191ac45e4b0d428d29dc1b6"},{"problem":61,"code":"#(reduce (fn [accum x] (apply assoc accum x)) {} (map vector %1 %2))","user":"5764cc01e4b0994c1922fc05"},{"code":"(fn [keys values]\n    (loop [m {}\n           k (seq keys)\n           v (seq values)]\n      (if (and k v)\n        (recur (assoc m (first k) (first v))\n               (next k)\n               (next v))\n        m)))","problem":61,"user":"4e5be681535d8a8b8723a2bc"},{"code":"#(reduce conj {} (map vector % %2))","problem":61,"user":"4ed69ea4535d10e5ff6f52e3"},{"problem":61,"code":"(fn map- [coll1 coll2]\r\n    (->> (interleave coll1 coll2) \r\n        (apply hash-map)))","user":"5fec4f5ee4b05ac5b16ea1bf"},{"code":"(fn f [a b] (if(or (empty? a) (empty? b))\n             {}\n             (merge {(first a) (first b)} (f (next a) (next b)))\n             )\n )","problem":61,"user":"51aeb1f4e4b09397d5109794"},{"code":"(comp (partial apply hash-map) interleave)","problem":61,"user":"4db27319535df7e46ed9b6bd"},{"problem":61,"code":"(fn [keys values]\n  (->> (map vector keys values)\n     (apply concat)\n     (apply hash-map)))","user":"5180c69ae4b06b8caf33fa00"},{"code":"#(apply hash-map (mapcat list % %2))","problem":61,"user":"4dce6e41535d5973398f92a2"},{"code":"#(apply hash-map (flatten (map list %1 %2)))","problem":61,"user":"4f12ab23535d64f603146429"},{"code":"#(loop [s (interleave %1 %2) ret {}]\n   (if (empty? s)\n     ret\n     (recur (drop 2 s) (assoc ret (first s) (second s)))))","problem":61,"user":"51000111e4b00d7ad4cab15e"},{"code":"(fn zm [k v] (if (or(empty? k) (empty? v)) {} (assoc (zm (rest k) (rest v) ) (first k)\n( first v)  )  ) )","problem":61,"user":"4e8d5edd535d65386fec2134"},{"problem":61,"code":"(fn [ks vs]\n  (into {}\n        (map (fn [k v]\n               [k v])\n             ks\n             vs)))","user":"554bd33ce4b0a04f7929959a"},{"code":"(fn [col1 col2]\n  (let [z (interleave col1 col2)]\n     (apply hash-map z)))","problem":61,"user":"50435689e4b034ff00315d21"},{"code":"(fn [f s]\n\t(letfn [(zmm [f s res]\n\t\t         (let [x (first f) y (first s)]\n\t\t           (if (or (nil? x) (nil? y))\n\t\t\t           res\n\t\t\t           (recur (next f) (next s) (assoc res x y)))))]\n\t(zmm f s {})))","problem":61,"user":"531dc21be4b08068f379edb1"},{"problem":61,"code":"(fn map-construction\n\t[m v]\n\t(apply hash-map (interleave m v)))","user":"57f81544e4b0d3187e900917"},{"problem":61,"code":"(fn zm-1 [ks vs]\n  (into {} (map (fn [k v]\n                  [k v])\n                ks vs)))","user":"5d64ecb2e4b0c9e5857d5036"},{"problem":61,"code":"#(apply\tassoc {} (interleave %1 %2))","user":"53d9e587e4b0e771c302547c"},{"code":"(fn zipmap2 [v1 v2] (cond (or (empty? v1) (empty? v2)) {} :else (assoc (zipmap2 (rest v1) (rest v2)) (first v1) (first v2))))","problem":61,"user":"50723bbae4b0e3170b5a868b"},{"problem":61,"code":"(fn [k v] \n  (let [interleaved (interleave k v)]\n    (loop [arr interleaved, m {}]\n      (if (empty? arr) m (recur (rest (rest arr)), (assoc m (first arr) (second arr)))\n      )\n    )\n  )\n)","user":"5d73530ce4b02e6b30c93514"},{"problem":61,"code":"(fn func2\n  [x y]\n  (loop [hm {} i 0]\n    (if (= i (min (count x) (count y)))\n      hm\n      (recur (assoc hm (nth x i) (nth y i)) (inc i))\n      )\n    )\n)","user":"5581a6dae4b05c286339e0fe"},{"problem":61,"code":"#(reduce merge (map (fn [k v] {k v}) % %2))","user":"56b1b59be4b0982f16b37df2"},{"problem":61,"code":"(fn [thekeys thevalues] (apply hash-map (interleave thekeys thevalues)))","user":"55536a8ae4b0deb715856e03"},{"code":"#(reduce conj {} (map (fn [a, b] [a,b]) %1 %2))","problem":61,"user":"4e25176e535d04ed9115e829"},{"problem":61,"code":"(fn [keys vals]\n  (into (hash-map) (map vector keys vals)))","user":"521ceb02e4b0c4ef0be830a5"},{"code":"(fn [k v]\n  (apply hash-map\n         (interleave k v)))","problem":61,"user":"511f88eee4b085952a83535f"},{"code":"(fn [keys seq]\n  (loop [k keys\n         s seq\n         curr {}]\n\n    (if (empty? s)\n      curr\n      (if (empty? k)\n        curr\n        (recur (rest k) (rest s) (assoc curr (first k) (first s)))))))","problem":61,"user":"4ef9b021535dced4c769f269"},{"problem":61,"code":"#(apply merge (map (fn [a b] {a b}) % %2))","user":"56372c3ce4b0bfe05bf117d1"},{"code":"(fn [ks vs] (into {}\n                      (map #(hash-map %1 %2) ks vs)))","problem":61,"user":"4e6a11ee535d8ccf87e9fe9f"},{"problem":61,"code":"(fn constructor [& data]\n  (reduce #(assoc %1 (first %2) (second %2)) {} (apply map list data)))","user":"56ca6141e4b0ea9b8538f71a"},{"code":"(fn [xs ys]\n  (loop [l1 xs l2 ys m {}]\n    (if (or (empty? l1) (empty? l2))\n      m\n      (recur (rest l1) (rest l2) (conj {(first l1) (first l2)} m))\n    )\n  )\n)","problem":61,"user":"51897709e4b0288ada3dbdaa"},{"problem":61,"code":"#(loop [a %1\n   \t   \tb %2\n   \t    c {}]\n   (if (or (zero? (count a)) (zero? (count b)))\n     c\n     (recur (rest a) (rest b) (assoc c (first a) (first b)))))","user":"595a3b41e4b066ee0a44afb7"},{"problem":61,"code":"(fn [keys' vals']\n  (loop [cur-keys keys'\n         cur-vals vals'\n         result {}]\n    (let [[head-key & tail-key] cur-keys\n          [head-val & tail-val] cur-vals]\n      (if (or (empty? cur-keys)\n              (empty? cur-vals))\n        result\n        (recur tail-key\n               tail-val\n               (conj result [head-key head-val]))))))","user":"567bf820e4b05957ce8c61ad"},{"problem":61,"code":"(fn zm \n  ([[a & as] [b & bs]] \n   (if (or (nil? a) (nil? b))\n     {}\n    (assoc (zm as bs) a b))  )                     \n  )","user":"58335c22e4b089d5ab817c9a"},{"code":"(fn [ks vs] \n  (reduce #(assoc %1 (first %2)(last %2)) {} (map list ks vs)))","problem":61,"user":"50b47c46e4b0c464d223d1b8"},{"problem":61,"code":"(fn [ks vs]\n  (apply hash-map\n         (interleave ks vs))\n  )","user":"5ce867fce4b0a17bb84e2baf"},{"code":"(fn [ks vs]\n      (apply hash-map (interleave ks vs)))","problem":61,"user":"50f48298e4b004d364930527"},{"problem":61,"code":"(fn zipmap-home-made\n  [c1 c2]\n  (first\n   (let [c-short (#(if (< (count %1) (count %2)) %1 %2) c1 c2)]\n    (reduce\n     #(do\n        (println %2)\n       [(assoc (first %1) (first (second %1)) (first (nth %1 2)))\n        (rest (second %1))\n        (rest (nth %1 2))])\n     [{} c1 c2]\n     c-short))))","user":"5ed52854e4b016b56eae05d2"},{"code":"#(apply assoc {} (interleave \n     % %2))","problem":61,"user":"512a8ef7e4b0ff5c4bc1f99e"},{"code":"#(apply array-map (interleave %1 %2))","problem":61,"user":"4f4ac35ae4b0d56e7bb92c18"},{"problem":61,"code":"(fn [c1 c2]\n  (loop [c1 c1 c2 c2 result {}]\n    (if (empty? c1)\n      result\n      (if (empty? c2)\n        result\n        (recur (rest c1) (rest c2) (assoc result (first c1) (first c2)))))))","user":"5c879edae4b048ec896c5917"},{"code":"(fn   [col1 col2]\n  (loop [col3 {} cnt (min (count col1) (count col2)) ]\n   (if (= cnt 0)\n        col3\n        (let [pos (- cnt 1)]\n        (recur (conj col3 [ (nth col1 pos)  (nth col2 pos)  ] ) (dec cnt)\n   )\n  ))))","problem":61,"user":"4ec5bec6535d6d7199dd36b3"},{"code":"(fn zm [k v]\n  (reduce \n    #(assoc %1 (first %2) (second %2)) {} \n       (partition 2 (interleave k v))))","problem":61,"user":"4f611127e4b0defedf855fb4"},{"code":"#(reduce (fn [m [k v]] (assoc m k v)) {} (map vector %1 %2))","problem":61,"user":"4ded27db535d08e6dec9fe0a"},{"problem":61,"code":"(fn my-zipmap [k,v]\n  (if (or (empty? k) (empty? v)) \n    {}\n    (assoc (my-zipmap (rest k) (rest v)) (first k) (first v))\n  )\n)","user":"54b050cee4b09f271ff37d13"},{"problem":61,"code":"(fn my-zipmap [k v]\n  (if (or (empty? k)\n          (empty? v))\n    {}\n    (into (my-zipmap (rest k) (rest v))\n          {(first k) (first v)})))\n\n;; from awebb: (comp (partial apply hash-map) interleave)\n;; from benhammond: #(into {} (map vector %1 %2))\n;; from austintaylor: (comp (partial apply array-map) interleave)","user":"568e1871e4b0dcc4269f40cc"},{"problem":61,"code":"(fn my-zipmap [keys values]\n  (reduce conj {} (map vector keys values)))","user":"571d063ee4b0145328a76272"},{"problem":61,"code":"(fn [orig-one orig-two]\n  (loop [final {} one orig-one two orig-two]\n    (if (or (empty? one) (empty? two))\n      final\n      (recur \n       (assoc final (first one) (first two)) \n       (rest one)\n       (rest two)))))","user":"58e45a2ce4b056aecfd47c69"},{"code":"#(loop [l1 %1 l2 %2 acc {}]\n   (if (or (empty? l1) (empty? l2))\n     acc\n     (recur (rest l1) (rest l2) (conj acc {(first l1) (first l2)}))))","problem":61,"user":"52b405e1e4b0c58976d9ad15"},{"problem":61,"code":"(fn [thelist1 thelist2] (apply array-map (interleave thelist1 thelist2)))","user":"55f75c6be4b06e875b46cea9"},{"code":"(fn [ks vs]\n  (loop [m {}\n         ks ks\n         vs vs]\n    (if (or (empty? ks)\n            (empty? vs))\n      m\n      (recur (conj m {(first ks) (first vs)}) (rest ks) (rest vs)))))","problem":61,"user":"521b9f92e4b0c4ef0be8304c"},{"problem":61,"code":"(fn [ks vs] (->> \n             (interleave ks vs)\n             (apply hash-map)))","user":"5ec0db8be4b00a66d4a9528d"},{"problem":61,"code":"(fn [xs ys] (apply (partial assoc {})(interleave xs ys)))","user":"57f9011ee4b0d3187e900935"},{"problem":61,"code":"#(apply merge\n        (map (fn [k v]\n               {k v})\n             %1\n             %2))","user":"5fe9169ce4b05ac5b16ea1a0"},{"problem":61,"code":"(fn [arr1 arr2] (apply hash-map (apply concat (mapv vector arr1 arr2))))","user":"5cb41c40e4b026601754b911"},{"problem":61,"code":"(fn [keys vals]\n  (reduce (fn [m [k v]]\n            (assoc m k v))\n          {}\n          (map vector keys vals)))","user":"5629dfaae4b00e49c7cb4813"},{"problem":61,"code":"(fn [keys values]\n  (into {} (map (fn [x y] [x y]) keys values)))","user":"577629abe4b0979f8965162e"},{"problem":61,"code":"(fn [ky vl]\n  (loop [result {}\n         ky ky\n         vl vl]\n    (if (or (empty? ky) (empty? vl))\n      result\n      (recur\n       (assoc result (first ky) (first vl))\n       (rest ky)\n       (rest vl)))))","user":"5e950178e4b0fbed045a3801"},{"problem":61,"code":"(fn [c1 c2] (into {} (map #(hash-map %1 %2) c1 c2)))","user":"51319a53e4b06942423563c8"},{"problem":61,"code":"(fn [keys vals]\n  (apply hash-map (flatten (map #(list %1 %2) keys vals))))","user":"53ca41dae4b00fb29b2212c8"},{"problem":61,"code":"(fn [k v] (apply assoc {} (flatten (map #(vector %1 %2) k v))))","user":"53da8fede4b0e771c30254a3"},{"problem":61,"code":"(fn teste [keys values]\n\n  (apply hash-map (interleave keys values)))","user":"58a7d3e0e4b01a0c0b232949"},{"code":"#(reduce (partial apply assoc) {} (partition 2 (interleave %1 %2)))","problem":61,"user":"531792d9e4b08068f379ed5e"},{"problem":61,"code":"#(loop [l1 %1 l2 %2 acc {}]\n   (if (some empty? [l1 l2])\n    acc\n    (let [[x & xs] l1\n          [y & ys] l2]\n      (recur xs ys (assoc acc x y)))))","user":"565e0934e4b068f2fe63dc30"},{"problem":61,"code":"(fn[k v] (loop [res {}\n                 k k\n                 v v]\n              (if (or (empty? k) (empty? v))\n                  res\n                  (recur (assoc res (first k) (first v)) (rest k) (rest v)))))","user":"5f727d2fe4b02876ed9fd08f"},{"problem":61,"code":"(fn [v1 v2]\n  (apply assoc {}\n         (interleave v1 v2)))","user":"53b0750fe4b047364c044483"},{"code":"#(into {} (map (fn [a b] {a b}) % %2))","problem":61,"user":"4e57d1e2535d8a8b8723a289"},{"code":"(fn [keys vals] (loop [r {} k keys v vals] (if (not (and (first k) (first v))) r (recur (assoc r (first k) (first v)) (rest k) (rest v)))))","problem":61,"user":"4f0e4ebd535d0136e6c22322"},{"problem":61,"code":"(fn [keys values]\n  (into (sorted-map) (map\n  #(vector %1 %2)\n  keys values)))","user":"5e7fb908e4b085ba37836e3f"},{"code":"(fn [keys vals] \n  (apply conj {} (map #(vector %1 %2) keys vals)))","problem":61,"user":"4f36f5f2e4b0e243712b1ece"},{"code":"(fn [ks vs] (into {} (map vector ks vs)))","problem":61,"user":"4dc7f472535d8a4b2fd74293"},{"problem":61,"code":"(fn [the-keys the-vals]\n  (let [mapped-items (for [i (range (min (count the-keys) (count the-vals)))]\n                       (hash-map (get the-keys i) (get the-vals i)))]\n    (reduce into {} mapped-items)))","user":"596aaeefe4b069c0a1a19808"},{"problem":61,"code":"(fn [ks vs] (apply (partial conj {}) (map vector ks vs)))","user":"55253217e4b0882d96d091ce"},{"code":"(fn [k v]\n  (apply assoc {} (interleave k v)))","problem":61,"user":"4ec9549d535d6d7199dd36fe"},{"code":"(fn [ks vs]\n  (let [pairs (map vector ks vs)]\n    (reduce \n      (fn [m kv] (assoc m (first kv) (second kv))) \n      {} pairs)))","problem":61,"user":"4f28c979e4b0d6649770a01a"},{"problem":61,"code":"#(reduce merge (map (fn [x y] (assoc {} x y)) %1 %2))","user":"59dd38a8e4b0a0ac046f2503"},{"code":"(fn [keys values]\n  (reduce (fn [map [key value]] (assoc map key value)) {} (map vector keys values)))","problem":61,"user":"5338e33fe4b0e30313ee6ca1"},{"code":"(fn [s1 s2] (apply assoc {} (interleave s1 s2)))","problem":61,"user":"4f2893d0e4b0d6649770a019"},{"code":"(fn [k v] (into {} (map #(hash-map (first %) (last %)) (partition 2 (interleave k v)))))","problem":61,"user":"4f2d5f5de4b0d6649770a05a"},{"code":"(fn [ks vs]\n  (let [kvs (interleave ks vs)]\n    (if (empty? kvs) {} (apply assoc {} kvs))))","problem":61,"user":"52bc6f5ee4b07a9af57922f6"},{"problem":61,"code":"(fn map-construct\n  [alst blst]\n  (into {} (map vector alst blst)))","user":"59636cc2e4b066ee0a44b0c7"},{"code":"(fn [keys vals]\n  (loop [result {} k keys v vals]\n    (if (or (empty? k) (empty? v))\n      result\n      (recur (into result [[(first k) (first v)]]) (rest k) (rest v)))))","problem":61,"user":"512d3304e4b040332b905b2d"},{"problem":61,"code":"(fn [k v]\n  (loop [k k v v \n         result {}]\n    (if (or (empty? k) (empty? v))\n      result\n      (recur (rest k) (rest v) (conj result [(first k) (first v)]))\n    )))","user":"57e396cde4b0bfb2137f5a9e"},{"problem":61,"code":"(fn m [k v] (apply assoc {} (interleave k v)))","user":"5cb4e764e4b026601754b929"},{"problem":61,"code":"(fn[x y]\n\t(reduce merge \n      (map (fn[a b] {a b}) x y)\n    )\n)","user":"54283a7ae4b01498b1a71b2f"},{"problem":61,"code":"(fn [c1 c2] (into {} (map (fn [k v] [k v]) c1 c2)))","user":"55caabd1e4b0e31453f649fb"},{"code":"#(loop [keys %1 values %2 return {}]\n  (\n    if(or (empty? keys)(empty? values)) return\n    (recur (next keys) (next values) (assoc return (first keys) (first values)))\n  )\n)","problem":61,"user":"4fe588b6e4b0e8f79898fec5"},{"problem":61,"code":"(fn [z w] (into {} (map (fn [x y] [x y]) z w)))","user":"55818b0ee4b05c286339e0fb"},{"problem":61,"code":"#(apply assoc {}  (interleave % %2) )","user":"57bffed6e4b05aa3c4741c89"},{"code":"(fn zm\n  [keys vals]\n    (loop [map {}\n           ks (seq keys)\n           vs (seq vals)]\n      (if (and ks vs)\n        (recur (assoc map (first ks) (first vs))\n               (next ks)\n               (next vs))\n        map)))","problem":61,"user":"4f10175e535d64f603146411"},{"code":"(fn  zm [[k & ks :as kcoll]\n          [v & vs :as vcoll]]\n  (when (and (seq kcoll) (seq vcoll))\n    (assoc (zm ks vs) k v)))","problem":61,"user":"4e71705e535d5021c1a89649"},{"problem":61,"code":"#(into (hash-map) \n       (loop [col1 %1 col2 %2 result []]\n         (if (or (empty? col1) (empty? col2))\n           result\n           (recur (rest col1)\n                  (rest col2) \n                  (conj result [(first col1) (first col2)])))))","user":"5956c6dae4b066ee0a44af61"},{"code":"#(reduce (fn [m pair] \n          (assoc m (first pair) (second pair))) \n        {} \n        (for [[x y] (partition 2 (interleave %1 %2))] [x y]))","problem":61,"user":"529d4f4be4b04e0c58e87b79"},{"problem":61,"code":"(fn [keys vals]\n    (apply hash-map (interleave keys vals)))","user":"586b6753e4b01531a375e956"},{"problem":61,"code":"(fn zipmap' [a b]\n  (->> (map list a b)\n       (reduce #(apply assoc %1 %2) {})))","user":"58dcf11ae4b0a4d5acaab6af"},{"code":"#(apply merge (map (partial assoc {}) %1 %2))","problem":61,"user":"4e8e8c24535d65386fec2143"},{"code":"(fn create-map [k v]\r\n   (loop [k1 k v1 v acc {}]\r\n     (if (or (empty? k1) (empty? v1))\r\n       acc\r\n       (recur (rest k1) (rest v1) (conj acc [(first k1) (first v1)])))))","problem":61,"user":"4f629697e4b0defedf855fd6"},{"problem":61,"code":"(fn[k v] (into {} (map vector k v)))","user":"590b8607e4b047aa04b199db"},{"code":"(fn [a b]\n  (into {}  \n    (map vec (partition 2\n      (interleave a b)\n    ))\n  )\n)","problem":61,"user":"4fe610fde4b0e8f79898fece"},{"code":"(fn[s1,s2](apply  hash-map ((fn[s1, s2] (interleave s1 s2))  s1 s2)))","problem":61,"user":"4ffd92e7e4b0678c553fc3e3"},{"problem":61,"code":"(fn [x y]\n  (into {} (map vector x y))\n )","user":"54975e99e4b0b312c081ff72"},{"code":"(fn [x y]\n  (into {} (map #(vector %1 %2) x y)))","problem":61,"user":"50517ebfe4b0a561d07d8f06"},{"problem":61,"code":"(fn [k v] (apply array-map (interleave k v)))","user":"53cd4920e4b00fb29b2212de"},{"code":"#(reduce (fn [xs [k v]] (conj xs {k v})) {} (partition 2 (interleave % %2)))","problem":61,"user":"525078b6e4b0541d1855b832"},{"problem":61,"code":"#(reduce (fn [m kv] (apply assoc m kv)) {} (apply map vector %&))","user":"54ca130ce4b057c6fda3a250"},{"problem":61,"code":"(fn [a b] (apply merge (map #(hash-map    %1 %2) a b)))","user":"581a5fdbe4b0e114eb51a002"},{"problem":61,"code":"#(into{}(map vector %1%2))","user":"5562442be4b0c656e3ff17d5"},{"problem":61,"code":"(fn map-c [s1 s2]\n  (cond (or (nil? (first s1))\n            (nil? (first s2))) nil\n        :else (conj {}\n                    (map-c (rest s1)\n                           (rest s2))\n                    (vector (first s1)\n                            (first s2)))))","user":"57614a42e4b0994c1922fb85"},{"code":"(fn[& coll](into {} (apply map vector coll)))","problem":61,"user":"4ff2f0a9e4b0678c553fc341"},{"code":"(fn [x y] (into {} (map #(identity {(nth x %) (nth y %)}) (range (min (count x) (count y))))))","problem":61,"user":"52c1bd29e4b07a9af579236a"},{"problem":61,"code":"#(apply hash-map ((fn !\n   ([a b xs]\n    (if (not (or (empty? a) (empty? b)))\n      (recur (rest a) (rest b) (concat xs [(first a) (first b)]))\n      xs))\n   ([a b] (! a b [])))\n %1 %2))","user":"5b73e500e4b047b03b2036ba"},{"problem":61,"code":"(fn f [xs ys]\n  (if \n    (or (empty? xs) (empty? ys))\n    {}\n    (assoc (f (rest xs) (rest ys)) (first xs) (first ys))))","user":"55e3e7a8e4b050e68259b44a"},{"problem":61,"code":"(fn [k v]\n  (loop [k k v v output {}]\n    (if (or (empty? k) (empty? v))\n      output\n      (recur (rest k) (rest v) (assoc output (first k) (first v))))))","user":"5689bd04e4b0dcc4269f4082"},{"problem":61,"code":"(fn\n  [a b]\n  (reduce conj {} (map #(assoc {} %1 %2) a b)))","user":"53528cd3e4b084c2834f4af2"},{"problem":61,"code":";#(into {} (map hash-map %1 %2))\n;#(apply hash-map (interleave %1 %2))\n#(into {} (mapcat hash-map %1 %2))","user":"5cd4e1b2e4b0ccb061962927"},{"code":"(fn [col1 col2] (into {} (map vector col1 col2)))","problem":61,"user":"506b8242e4b0eda3100c090a"},{"code":"(fn [k v]\n  (into {} \n        (for [x (map hash-map k v)] x)))","problem":61,"user":"5154fa3fe4b0179c5115f4e6"},{"code":"(fn [& args] (into {} (apply map vector args)))","problem":61,"user":"4e31a15c535deb9a81d77f1e"},{"code":"(fn d [keys vals] (if (or (empty? keys) (empty? vals)) nil (assoc (d (rest keys) (rest vals)) (first keys) (first vals))))","problem":61,"user":"5226f9b8e4b04e78ff2e199b"},{"code":"(fn [k v]\n  (apply\n    hash-map\n    (interleave k v)))","problem":61,"user":"501284d9e4b030d97e4db710"},{"problem":61,"code":"(fn mc [v1 v2] \n  (loop [[k :as s1] v1, [v :as s2] v2, result {}]\n    (if (and k v) \n      (recur (rest s1) (rest s2) (assoc result k v))\n      result)))","user":"572ec4dde4b0cd1946bd0f8d"},{"code":"(fn [ks vs]\n    (into {} (map vector ks vs)))","problem":61,"user":"51805d22e4b0e3fc13e244df"},{"code":"(fn mapea [s1-ini s2-ini] (loop [s1 s1-ini s2 s2-ini result {}] (if (or (= 0 (count s1))(= 0 (count s2)) ) result (recur (rest s1) (rest s2) (assoc result (first s1) (first s2))))))","problem":61,"user":"4e9de526535dbda64a6f6b8e"},{"problem":61,"code":"(fn [ks vls] (into {} (map vector ks vls)))","user":"59a8a4dce4b0bcf4e9a43af7"},{"code":"(fn [s1 s2]\n\t(loop [s1 s1\n           s2 s2\n           v {}]\n      (if (or (empty? s1) (empty? s2)) v\n      \t(recur (rest s1) (rest s2) (assoc v (first s1) (first s2))))\n      )\n)","problem":61,"user":"5081566ce4b0946d0443855b"},{"code":"#(loop [in1 %1 in2 %2 out {}]\n  (if (or (empty? in1) (empty? in2))\n    out\n    (recur (rest in1) (rest in2) (assoc out (first in1) (first in2)))))","problem":61,"user":"5033a1fbe4b062bc5d7ae155"},{"problem":61,"code":"(fn [a b]\n  (into {} (map #(hash-map % %2) a b)))","user":"53ac4719e4b047364c04445c"},{"code":"(fn [k v] \n  (let [hm (hash-map)] \n    (into {} (map #(assoc hm %1 %2) k v))))","problem":61,"user":"50052fd0e4b0678c553fc45d"},{"code":"(fn [x y]\n  (loop [my-map {}\n         ks x\n         vs y]\n    (cond\n     (or (empty? ks) (empty? vs)) my-map\n     :else (recur (assoc my-map (first ks) (first vs)) (rest ks) (rest vs))\n     )\n    )\n  )","problem":61,"user":"51a2569ee4b00957e520db7d"},{"problem":61,"code":";(fn zipmap' [c1 c2]\n; (loop [c1 c1\n;         c2 c2\n;         res {}]\n;    (if (or (empty? c1) (empty? c2))\n;      res\n;      (recur (rest c1) (rest c2) (assoc res (first c1) (first c2))))))\n\n#(into {} (map (fn [k v] {k v}) %1 %2))","user":"5d1be50ce4b02ea6f0fb6986"},{"problem":61,"code":"(fn [x y]\n  (loop [i 0\n         m {}]\n    (if (< i (min (count x) (count y)))\n      (recur \n       (inc i)\n       (assoc m (nth x i) (nth y i)))\n       m\n      )\n    ))","user":"591ac8ece4b09b4ee5954bdd"},{"problem":61,"code":"(fn make-map [ks vs]\n  (if ((set (map empty? [ks vs])) true) {}\n    (assoc (make-map (rest ks) (rest vs)) (first ks) (first vs))))","user":"56dc3dbbe4b0ea9b8538f81a"},{"problem":61,"code":"(fn [a b](into (sorted-map) (mapv (fn[x y][x y]) a b) ))","user":"56039843e4b04bb52996e1be"},{"problem":61,"code":"(fn [vec1 vec2]\n (apply merge (map (fn [k v]\n                           {k v})\n                         vec1\n                         vec2)))","user":"57f8151ce4b0d3187e900912"},{"code":"(fn [ks vs] (apply merge (map (fn [k v] {k v}) ks vs)))","problem":61,"user":"51e24a04e4b01e5198146430"},{"code":"(fn\n    [ks vs]\n  (into {} (map vector ks vs)))","problem":61,"user":"51804bcbe4b04f45bde7d901"},{"code":"(fn [v1 v2]\n  (reduce\n   merge\n   (map hash-map v1 v2)))","problem":61,"user":"4f031883535dcb61093f6a5e"},{"code":"(fn [c1 c2] \n  (reduce #(assoc %1 (first %2) (second %2)) \n          {} \n          (map vector c1 c2)))","problem":61,"user":"4dada426c9a9d6ed2a99dc57"},{"code":"(fn map-constr-rec [k v]\n  (if (or (empty? k) (empty? v))\n    (hash-map)\n    (assoc (map-constr-rec (rest k) (rest v)) (first k) (first v))))","problem":61,"user":"51e0198ee4b01188f0627539"},{"problem":61,"code":"(fn [col1 col2]\n      (apply hash-map (interleave col1 col2)))","user":"54b67463e4b05787c3b163bc"},{"problem":61,"code":"#(into {} (map vector %1 %2) )","user":"57614948e4b0994c1922fb83"},{"code":"(fn [x y] \n  (reduce (fn [a [k v]] (assoc a k v)) {}\n    (map #(vector % %2) x y)))","problem":61,"user":"4ed2b168535d44c135fd68dd"},{"code":"(fn [v1 v2]     (loop [x v1 y v2 col {}]\n        (if (or (empty? x) (empty? y))\n            col\n            (recur (rest x) (rest y) (assoc col (first x) (first y))))))","problem":61,"user":"5179fd22e4b01aacecbecbe5"},{"problem":61,"code":"(fn [coll1 coll2] \n  (into {} (map vector coll1 coll2)))","user":"546692aee4b01be26fd746e7"},{"problem":61,"code":"(fn\n  [key-vec val-vec]\n  (reduce into {}\n          (map (partial assoc {}) key-vec val-vec)))","user":"5974d2ede4b01722bebd4cb6"},{"problem":61,"code":"(fn [ks vs] \n  (reduce #(apply assoc %1 %2) {} (map #(vector %1 %2) ks vs)))","user":"5933b736e4b072a2710fd05d"},{"problem":61,"code":"(fn [v1 v2] \n  (reduce conj (map hash-map v1 v2)))","user":"5486adf7e4b0e286459a11be"},{"problem":61,"code":"#(into {} (map vector % %2))\n;(fn [a b] (into {} (map #(hash-map % %2) a b)))","user":"57ba55c1e4b0fbc9809a2801"},{"problem":61,"code":"(fn [v1 v2]\n  (loop [map {}\n         ks (seq v1)\n         vs (seq v2)]\n    (if (and ks vs)\n      (recur (assoc map (first ks) (first vs))\n             (next ks)\n             (next vs))\n      map)))","user":"5931e498e4b072a2710fd024"},{"problem":61,"code":"(fn my-zipmap [xs ys]\n   (into {} (map #(hash-map % %2) xs ys)))","user":"4e6a23d0535d8ccf87e9fea0"},{"problem":61,"code":"(fn create-map [v1 v2]\n  (reduce (fn [m [a b]] (assoc m a b)) {} (map #(vector %1 %2) v1 v2)))","user":"53d63e6ce4b0e771c3025454"},{"problem":61,"code":"#(apply merge (map (fn [k v] {k v}) %1 %2))","user":"57f8ba80e4b0d3187e90092f"},{"problem":61,"code":"(fn [keys-list values-list] (into {} (map (fn [k v] [k v]) keys-list values-list)))","user":"5a66fddee4b0512ff01cd9d7"},{"code":"(fn [keys values]\n    (loop [ks keys\n           vs values\n           m {}]\n      (if (or (empty? ks) (empty? vs))\n        m\n        (recur (rest ks)\n               (rest vs)\n               (assoc m (first ks) (first vs))))))","problem":61,"user":"4fcbc18ae4b0ee37620e185c"},{"code":"(fn [keys, values]\n  (loop [k keys, v values, m {}]\n    (if (or (empty? k) (empty? v))\n      m\n      (recur \n        (rest k) \n        (rest v) \n        (assoc m (first k) (first v))))))","problem":61,"user":"4ea4fe1f535d7eef308072cf"},{"code":"(fn [ks vs] (let [n (apply min [(count ks) (count vs)])] (->> (range 0 n) (map #(list (nth ks %) (nth vs %))) (apply concat) (apply hash-map))))","problem":61,"user":"509e62a8e4b08df8156e9e2e"},{"code":"(fn [ks vs] (apply hash-map (mapcat vector ks vs)))","problem":61,"user":"4e6a4954535d8ccf87e9fec0"},{"code":"(fn [coll1 coll2]\n  (loop [c1 coll1 c2 coll2 result []]\n    (if (or (empty? c1) (empty? c2))\n      (apply array-map result)\n      (recur (rest c1) (rest c2) (conj result (first c1) (first c2))))))","problem":61,"user":"5046f909e4b03b02161376b5"},{"code":"(fn lo [x y]\r\n  (loop [xar {} ks x vs y]\r\n    (let [k (first ks) v (first vs)] \r\n    (if (and k v)\r\n      (recur (assoc xar k v)\r\n              (rest ks)(rest vs))\r\n      xar\r\n    )\r\n  )\r\n))","problem":61,"user":"4de18de7535d08e6dec9fde8"},{"problem":61,"code":"(fn map-keys-vals [keys vals]\n  (loop [map {}\n         ks keys\n         vl vals]\n    (if (and ks vl)\n      (recur (assoc map (first ks) (first vl))\n\t  (next ks)\n\t  (next vl))\n\t  map)))","user":"560331dee4b04bb52996e1b5"},{"problem":61,"code":"(fn [k v]\n  ((fn blah [k v a]\n    (if (or (= k '()) (= v '()))\n      a\n      (blah (rest k) (rest v) (assoc a (first k) (first v)))))\n   k v {}))","user":"53aaaf7ae4b047364c044444"},{"problem":61,"code":"#(loop [c1 %\n        c2 %2\n        m1 {}]\n   (if (or (empty? c1) (empty? c2))\n     m1\n     (recur (rest c1)\n            (rest c2)\n            (conj m1 {(first c1) (first c2)}))))","user":"55eeeb81e4b0121d4835fdf7"},{"code":"(fn [& more]\n  (reduce #(assoc %1 (first %2) (second %2)) {} \n  (apply map list more)))","problem":61,"user":"4e89f46c535d3e98b8023288"},{"problem":61,"code":"(fn [& s] (apply hash-map (apply mapcat list s)))","user":"54bd04e7e4b0ed20f4ff6ed8"},{"code":"(fn z [a b] (if (or (empty? a)\n                                                  (empty? b))\n                                            {}\n                                            (merge-with clojure.set/union {(first a) (first b)} (z (rest a) (rest b)))\n                                            ))","problem":61,"user":"4fd8544be4b0dab7d829f390"},{"problem":61,"code":"(fn [ks vs] (loop [keyData ks valData vs final {}] (if (or (empty? keyData) (empty? valData)) final (recur (rest keyData) (rest valData) (assoc final (first keyData) (first valData))))))","user":"54e7425ee4b024c67c0cf810"},{"problem":61,"code":"(fn\n  [a b]\n  (reduce\n    (fn [m itm] (assoc m (first itm) (last itm)))\n    {}\n    (map #(vector %1 %2) a b)))","user":"5bc60a65e4b07a9b28b10082"},{"code":"(fn [x y] \n  (reduce \n   #(assoc %1 (first %2) (second %2)) \n   {} \n   (partition 2 (interleave x y))))","problem":61,"user":"50f53694e4b057d4c52de881"},{"problem":61,"code":"(fn [lst coll] (apply hash-map (interleave lst coll)))","user":"5bbc0ddfe4b0a20761a2361e"},{"problem":61,"code":"(fn [a b]\n  \t(apply assoc {} \n   \t\t(interleave a b)\n   \t)\n)","user":"5710e574e4b09c608db7043b"},{"code":"(fn [k v] (apply hash-map (interleave k v)))","problem":61,"user":"4ef0eaef535dced4c769f211"},{"code":"(fn [ks vs]\r\n  (apply assoc {} (interleave ks vs)))","problem":61,"user":"4fb37882e4b081705acca2a0"},{"problem":61,"code":"(fn construct-map [x y]\n  (if (or (empty? x)\n          (empty? y)) {}\n    (merge (assoc {} (first x) (first y))\n           (construct-map (rest x) (rest y)))))","user":"5c538cb5e4b0fb8c5ffd99fb"},{"problem":61,"code":"(fn [l r] (into {} (map vector l r)))","user":"54b04708e4b09f271ff37d11"},{"problem":61,"code":"(fn [xs ys]\n  (loop [m {}\n         xs xs\n         ys ys]\n    (if (and (seq xs) (seq ys))\n      (recur (assoc m (first xs) (first ys)) (rest xs) (rest ys))\n      m)))","user":"5d236215e4b02ea6f0fb6a09"},{"code":"#(loop [[a b & s] (interleave % %2) c {}]\n  (let [c (conj c [a b])]\n    (if (nil? s)\n      c\n      (recur s c))))","problem":61,"user":"4efb87f7535dced4c769f279"},{"problem":61,"code":"(fn [ks vs]\n  (letfn [(f [ks vs]\n             (when-not (or (empty? ks) (empty? vs))\n               (merge {(first ks) (first vs)} (f (rest ks) (rest vs)))))]\n    (f ks vs)))","user":"5f5e7158e4b02876ed9fcff0"},{"code":"(fn [ks vs]\n  (loop [ks ks, vs vs, res {}]\n    (if (some empty? [ks vs])\n      res\n      (recur (rest ks) \n             (rest vs)\n             (into res {(first ks) (first vs)})))))","problem":61,"user":"4efa3d4b535dced4c769f270"},{"problem":61,"code":"#(into {} (map (fn [a b] (conj [] a b)) %1 %2))","user":"5f468d26e4b0955706451fc1"},{"problem":61,"code":"(fn [k v]\n  (loop [ks k\n         vs v\n         mp {}]\n    (if (or (empty? ks) (empty? vs))\n      mp\n      (recur (rest ks)\n             (rest vs)\n             (assoc mp (first ks) (first vs)))\n      )\n    )\n  )","user":"58562083e4b0f14aab7c86eb"},{"problem":61,"code":"(fn [keys vals]\n    (loop [ks keys vs vals res {}]\n      (if (or (empty? ks) (empty? vs))\n      res\n      (recur (rest ks) (rest vs) (assoc res (first ks) (first vs)))\n      )\n    )\n  )","user":"5681afaae4b0945ebc182a87"},{"problem":61,"code":"(fn my-zipmap [keys vals]\n  (apply hash-map (interleave keys vals)))","user":"5146f343e4b04ef915e3731e"},{"problem":61,"code":"#(into {} (map (fn [x,y] {x y}) %1 %2))","user":"5895385fe4b00487982d5279"},{"problem":61,"code":"(fn [xs ys]\n   (reduce-kv\n    (fn [acc key val]\n      (if (<= key (dec (count ys)))\n\t\t\t\t(assoc acc val (nth ys key))\n        acc)) {} xs))","user":"603f6623e4b0d5df2af2231f"},{"problem":61,"code":"(fn [a b] (reduce #(assoc %1 (first %2) (second %2)) {} (partition 2 (interleave a b))))","user":"55eeb37ae4b0121d4835fdf3"},{"code":"(fn [s1 s2]\n  (loop [result {} r1 s1 r2 s2]\n  (if (or (empty? r1) (empty? r2))\n  result\n  (recur (assoc result (first r1) (first r2)) (next r1) (next r2))\n  )))","problem":61,"user":"51a7b4fee4b0da5f497bde8b"},{"problem":61,"code":"(fn [ks vs] \n  (into \n   (sorted-map)\n   (map #(conj [%1] %2) ks vs)))","user":"578df8fee4b0ebec4cfb7574"},{"code":"(fn [xs zs]\n  (into {} (map (fn [idx] [(nth xs idx) (nth zs idx)]) (range (min (count xs) (count zs))))))","problem":61,"user":"4f7f0827e4b06e829148e1d5"},{"code":"(fn [keys vals]\n  (into {} (map vector keys vals)))","problem":61,"user":"4f3fb586e4b0e243712b1f9c"},{"problem":61,"code":"(fn [ks1 ks2]\n  (loop [[k1 & r1] ks1 [k2 & r2] ks2 result {}]\n    (if-not (and k1 k2)\n      result \n      (recur r1 r2 (assoc result k1 k2)))))","user":"57afd36de4b0fbc9809a273c"},{"code":"(fn [k v] (apply merge (map (partial assoc {}) k v)))","problem":61,"user":"4e949d18535dbda64a6f6b15"},{"problem":61,"code":"(fn zipmap*\n  [v1 v2]\n  (loop [vk v1 vv v2 r {}]\n    (if (or (empty? vk) (empty? vv)) r (recur (rest vk) (rest vv) (conj r (hash-map (first vk) (first vv)))))))","user":"57235dc4e4b0c5bde472c0e2"},{"code":"(fn zipmap-\n  [keys vals]\n  \"61. Write a function which takes a vector of keys and a vector of values and constructs a map from them.\"\n  (apply hash-map (interleave keys vals)))","problem":61,"user":"4e5eb843535d8a8b8723a2d4"},{"code":"(fn [daKeys daVals]\n  (loop [runningMap {}\n         runKeys daKeys\n         runVals daVals]\n         (if (or (empty? runKeys) (empty? runVals))\n             runningMap\n         (recur (assoc runningMap (first runKeys) (first runVals))\n                (rest runKeys)\n                (rest runVals)))))","problem":61,"user":"4f0365fc535dcb61093f6aa4"},{"problem":61,"code":"(fn [listkeys listvals]\n  (loop [k listkeys\n         v listvals\n         ans {}]\n    (if (or (empty? k) (empty? v))\n      ans\n      (recur (next k) (next v) (assoc ans (first k) (first v))))))","user":"56038f34e4b04bb52996e1bc"},{"problem":61,"code":"#(loop [k %1 v %2 result {}]\n   (if (or (empty? k) (empty? v))\n     result\n     (recur (rest k) (rest v) (assoc result (first k) (first v)))))","user":"5989ee61e4b021a7a535fed7"},{"problem":61,"code":"(fn [ks vs]\n  (let [pairs (map vector ks vs)]\n    (into {} pairs)))","user":"5d47fa13e4b07c84aa5ae6b6"},{"problem":61,"code":"(fn f [k v] (if (and (not-empty k) (not-empty v))\n                     (merge {(first k) (first v)} (f (rest k) (rest v)))\n                     {}))","user":"5d7d17ece4b02e6b30c93558"},{"problem":61,"code":"#(reduce merge (map (fn [x y] {x y}) %1 %2))","user":"536ecd9fe4b0fc7073fd6e76"},{"code":"(fn zip [keys values]\n  (if (and (seq keys) (seq values))\n    (assoc (zip (rest keys) (rest values))\n          (first keys)\n          (first values))))","problem":61,"user":"4eda7cc3535d10e5ff6f530e"},{"code":"(fn [keys values] (apply merge (map hash-map keys values)))","problem":61,"user":"4e599577535d8a8b8723a29f"},{"code":"#(reduce conj (map hash-map % %2))","problem":61,"user":"517adc6ce4b0925c997201c4"},{"code":"(fn [s1 s2] (reduce conj (map (fn [x y] {x y}) s1 s2)))","problem":61,"user":"523b4e91e4b07becd5be21ef"},{"problem":61,"code":"#(\n  \n  apply assoc {} \n   (interleave %1 %2)\n            \n  \n  )","user":"598085e6e4b021a7a535fdd3"},{"problem":61,"code":"#(into {} (map vector % %2) )","user":"575bd5f9e4b02ea114799365"},{"problem":61,"code":"#(reduce conj {} (map hash-map %1 %2))","user":"56011393e4b04bb52996e178"},{"problem":61,"code":"(fn construct-map [k v]\n  (into {} (map vector k v))\n  )","user":"59f78b49e4b0ca45a743a30e"},{"problem":61,"code":"(fn v ([a b] (v a b (hash-map)))\n      ([a b c] (if (or (empty? a) (empty? b))\n                 c\n                 (recur (rest a) (rest b) (assoc c (first a) (first b))))))","user":"55cf0d0ee4b0e31453f64a2b"},{"code":"(fn[a b] \n    (:r (reduce \n        (fn[x y] (let [r (x :r)\n                       o (x :2)\n                      ] \n                      {:r (if (nil? o) r (merge r {y (first o)}))\n                       :2 (next o)\n                      }\n        ))\n        {:r {}\n         :2 b }\n        a\n    ))\n)","problem":61,"user":"5017eface4b02f523d7cc5e7"},{"code":"(fn [s1 s2]\n  ( into {} (map vector s1 s2)))","problem":61,"user":"4eb8ec4a535dfed6da9c6d4b"},{"code":"(fn zip [a b]  (if-not (or (empty? a) (empty? b)) \n                 (merge \n                  {(first a) (first b)} \n                  (zip (rest a) (rest b)))))","problem":61,"user":"526a3412e4b03e8d9a4a721e"},{"problem":61,"code":"(fn  [x y]\n  (reduce #(into %1 %2) {}  (map #(identity {%1 %2}) x y)))","user":"55aa1637e4b0988bba2ad949"},{"problem":61,"code":"#(apply merge (map (fn [x y] {x y}) % %2))","user":"50d0d2dde4b00b15ecee9768"},{"code":"(fn [sq1 sq2]\n   (reduce #(merge % %2) {}\n         (map #(hash-map % %2) sq1 sq2)))","problem":61,"user":"523bd9c0e4b07becd5be2201"},{"code":"#(into {} (map (fn [k v] (vector k v)) % %2))","problem":61,"user":"4f4319ebe4b0d7d3c9f3fd13"},{"problem":61,"code":"(fn [coll1 coll2] (into (sorted-map)(mapcat #(hash-map %1 %2) coll1 coll2)))","user":"5804b491e4b0a837a8b30cac"},{"problem":61,"code":"(fn my-zipmap [keys vals]\n  (into {} (map vector keys vals)))","user":"58ed713de4b056aecfd47d84"},{"problem":61,"code":"#(loop [ks %1\n        vs %2\n        m {}]\n   (if (and (seq ks) (seq vs))\n     (recur (rest ks) (rest vs) (assoc m (first ks) (first vs)))\n     m))","user":"56521a26e4b0f9d632dd845f"},{"code":"#(reduce (fn[r x](assoc r x (nth %2 (.indexOf %1 x)))) {} (take (count %2) %1))","problem":61,"user":"51f79238e4b06ff1c25c52d7"},{"code":"#(apply assoc {} (interleave %1 %2 ))","problem":61,"user":"518c5236e4b087e178201de0"},{"problem":61,"code":"(fn foo [ks vs]\n  (let [kf (first ks) vf (first vs)]\n    (if (and kf vf)\n      (assoc (foo (next ks) (next vs)) kf vf)\n      {})))","user":"5cece5a2e4b0a17bb84e2bfb"},{"problem":61,"code":"(fn create-map\n  [keys vals]\n  (into {} (map vector keys vals)))","user":"56e99ec8e4b04a395b9a03fb"},{"code":"(fn [coll1 coll2] \n  (reduce #(assoc %1 (first %2) (second %2)) ; add pairs to the resulting hash map\n          {} \n          (map #(cons %1 [%2]) coll1 coll2))) ; create a map of pairs","problem":61,"user":"50fac9e3e4b07934dda8b0d1"},{"code":"(fn [ks vs]\n  (loop [result {}\n         ks ks\n         vs vs]\n    (if (or (empty? vs) (empty? ks))\n      result\n      (recur (conj result {(first ks) (first vs)}) (rest ks) (rest vs)))))","problem":61,"user":"4ee7fe83535d93acb0a66874"},{"problem":61,"code":"(fn [lst1 lst2]\n  (loop [lst1 lst1\n         lst2 lst2\n         map {}]\n    (if (or (empty? lst1) (empty? lst2))\n      map\n      (recur (rest lst1) (rest lst2) (conj map {(first lst1) (first lst2)})))))","user":"57f81549e4b0d3187e900918"},{"problem":61,"code":"(fn [c d] (into {} (map (fn [a b] [a b]) c d)))","user":"6065755ee4b069485764ddcc"},{"code":"(fn m [x y]\n  (cond (or (empty? x) (empty? y)) '{}\n        :else\n        (assoc (m (rest x) (rest y)) (first x) (first y))))","problem":61,"user":"50588af1e4b06522596eba7d"},{"problem":61,"code":"(fn [ks vs]\n  (into (hash-map) (map #(vector %1 %2) ks vs)))","user":"5fa8424ce4b0fa27300f3de5"},{"code":"(fn foo [x y]\n  (into {}\n    (for [i x j y :when (= (.indexOf x i) (.indexOf y j))]\n    [i j])))","problem":61,"user":"5078300de4b0fc74642bff66"},{"problem":61,"code":"(fn [coll1 coll2]\n  (apply assoc {}\n   (interleave coll1 coll2))\n)","user":"506af7d8e4b0a2a5463de37d"},{"problem":61,"code":"#(apply hash-map\n        (mapcat vector %1 %2))","user":"549dd591e4b0f3d1d8e70f98"},{"code":"(comp #(reduce (fn ab [m [a b]] (assoc m a b)) {} %)  #(map vector % %2))","problem":61,"user":"4dad86e0c9a9d6ed0f99dc57"},{"code":"#( apply assoc {} (interleave %1 %2))","problem":61,"user":"539c9e26e4b0b51d73faaf2e"},{"code":"(fn [A B]\n  (loop [k-s A\n         e-s B\n         res {}]\n         (cond (or (= [] k-s) (= [] e-s)) res\n               :default \n               (recur (rest k-s) (rest e-s) (conj res (hash-map (first k-s) (first e-s)))))))","problem":61,"user":"4e49a7bb535dc968683fc4c6"},{"code":"(fn zipmap-\n  [keys vals]\n  (reduce conj {} (map (fn [k v] [k v]) keys vals)))","problem":61,"user":"4e5bff2b535d8a8b8723a2bd"},{"problem":61,"code":"(fn [ks vs]\n  (loop [k ks v vs m {}]\n    (if (or (empty? k) (empty? v))\n      m\n      (recur (next k) (next v) (assoc m (first k) (first v))))))","user":"574abbfbe4b02ea114799200"},{"problem":61,"code":"(fn [a b]\n  (loop [r {}\n         s a\n         e b]\n    (if (and (seq s) (seq e))\n      (recur (assoc r (first s) (first e)) (rest s) (rest e))\n      r)\n    )\n  )","user":"5d917ef0e4b0915913b1d402"},{"problem":61,"code":"(fn [c1 c2]\n  (into {} (map (fn [x1 x2] [x1 x2]) c1 c2)))","user":"5032748ae4b0e78df07b092f"},{"code":"(fn [ks vs]\n(loop [ks ks vs vs tmp {}]\n      (if (or (empty? ks) (empty? vs))\n        tmp\n        (recur (rest ks) (rest vs) (assoc tmp (first ks) (first vs))))))","problem":61,"user":"4e88feef535d8b9bb0147ca8"},{"problem":61,"code":"(fn [keys values]\n    (loop [map {} ks (seq keys) vs (seq values)]\n      (if (and ks vs)\n        (recur (assoc map (first ks) (first vs)) (next ks) (next vs))\n        map)))","user":"57213df6e4b0c5bde472c0ab"},{"code":"(fn [c1 c2] (apply hash-map (interleave c1 c2) ) )","problem":61,"user":"51e28063e4b08e53a149f0f2"},{"problem":61,"code":"(fn [coll1 coll2]\n  (loop [re {}\n         list1 coll1\n         list2 coll2]\n    (if (or (empty? list1) (empty? list2))\n      re\n      (recur (conj re (hash-map (first list1) (first list2)))\n             (rest list1)\n             (rest list2)))))","user":"59b9e669e4b0a024fb6ae3db"},{"code":"(fn [fv sv]\n  (loop [f fv s sv el (sorted-map)]\n    (if (or (empty? f) (empty? s))\n      el\n      (recur (rest f) (rest s) (conj el [(first f) (first s)])))))","problem":61,"user":"501dfd54e4b051153f3b5b80"},{"problem":61,"code":"(fn [ks vs]\n  (loop [res {}\n         ks (seq ks)\n         vs (seq vs)]\n    (if (and ks vs)\n      (recur (assoc res (first ks) (first vs)) (next ks) (next vs))\n      res)))","user":"59d9dcfbe4b0ef0a1e9b5c5d"},{"code":"#(apply hash-map (interleave %1 %2))","problem":61,"user":"4dd6fa35535d2dad7130b5cd"},{"problem":61,"code":"#(apply assoc {} \n   (interleave %1 %2))","user":"555883c5e4b0deb715856e2d"},{"code":"(fn mc [ks, vs] \n  (into {} \n        (for [k ks\n              :let [ki (.indexOf ks k)] \n              :while (contains? vs ki)] (conj {} {k (nth vs ki)}))\n ))","problem":61,"user":"52cf084ce4b07d0d72b27399"},{"problem":61,"code":"(fn [lst1 lst2]\n  (loop [l1 lst1\n         l2 lst2\n         newmap {}]\n    (if (or (empty? l1)\n            (empty? l2))\n      newmap\n      (recur (rest l1) (rest l2) (conj newmap {(first l1) (first l2)})))))","user":"560a7775e4b05f002753defa"},{"problem":61,"code":"#(into {} (map (partial into [])\n                  (partition 2 (interleave % %2))))","user":"56f9890be4b07572ad1a88b5"},{"problem":61,"code":"(fn my-zipmap [ks vs]\n  (reduce #(assoc % (nth ks %2) (nth vs %2))\n          {} (range (min (count vs) (count ks)))))","user":"56bf4ac0e4b0f26550335985"},{"code":"#(loop [l1 %1 l2 %2 acc {}] (if (or (empty? l1) (empty? l2)) acc (recur (next l1) (next l2) (assoc acc (first l1) (first l2)))))","problem":61,"user":"503539dee4b0ed9c821488f6"},{"problem":61,"code":"(fn\n  [kys vls]\n  (loop [rslt                    {}\n         [fk & k-remain :as kys] (seq kys)\n         [fv & v-remain :as vls] (seq vls)]\n    (if (empty? kys)\n      rslt\n      (recur (if fv (assoc rslt fk fv) rslt)\n             k-remain\n             v-remain))))","user":"5cf1d9e3e4b0aaa82f112a18"},{"problem":61,"code":"(fn [keys vals]\n           (loop [map {}\n                  ks  (seq keys)\n                  vs  (seq vals)]\n             (if (and ks vs)\n               (recur (assoc map (first ks) (first vs))\n                      (next ks)\n                      (next vs))\n               map)))","user":"55808f8ee4b05c286339e0ee"},{"problem":61,"code":"#(into {} (map (fn [x y] (vector x y)) %1 %2))","user":"55249f64e4b0882d96d091c6"},{"problem":61,"code":"(fn map-construct [s1 s2] (apply merge (map hash-map s1 s2)))","user":"5654e024e4b0f9d632dd848d"},{"problem":61,"code":"#(into {}\n       (map (fn [x] {(first x) (second x)})\n            (partition 2 \n                       (interleave %1 %2))))","user":"5470cb10e4b094393f72dd65"},{"problem":61,"code":"(fn [ks vs] (apply hash-map (flatten (map (fn [k v] [k v] ) ks vs))))","user":"53347274e4b0656e627bfd6b"},{"code":"(fn [keys values] (reduce #(assoc %1 (first %2) (second %2)) {} (partition 2 (interleave keys values))))","problem":61,"user":"52f10094e4b05e3f0be25ee8"},{"problem":61,"code":"(fn [ks vs]\n  (loop [res {}\n         ks ks\n         vs vs]\n    (if (or \n         (empty? ks)\n         (empty? vs))\n      res\n      (recur\n       (assoc res (first ks) (first vs))\n       (rest ks)\n       (rest vs)))))","user":"592334c7e4b0a390037439ee"},{"code":"(fn [k v] (into {} (map #(vec [%1 %2]) k v)))","problem":61,"user":"500854c4e4b028e089d3518c"},{"code":"(fn [col1 col2]\n  (reduce \n   (fn [m, e] \n     (assoc m \n       (first e) \n       (second e))) {} (map vector col1 col2)))","problem":61,"user":"52a32876e4b04e0c58e87bfb"},{"problem":61,"code":"(fn zippy\n  [c1 c2]\n  (into {} (map #(vector %1 %2) c1 c2)))","user":"5888b75fe4b0f1effa3b771b"},{"code":"(fn [ks vs]\n  (loop [ks ks\n         vs vs\n         kvs {}]\n    (if (or (= '() ks) (= '() vs))\n      kvs\n      (recur (rest ks)\n             (rest vs)\n             (assoc kvs (first ks) (first vs))))))","problem":61,"user":"50bd6033e4b0594b91591c66"},{"problem":61,"code":"(fn [frs scn]\n  (loop [x frs\n         y scn\n         result {}]\n    (if (or (empty? y) (empty? x))\n      result\n      (recur (rest x) (rest y) (assoc result (first x) (first y))))))","user":"5af74644e4b0cc2b61a3bcc2"},{"problem":61,"code":"(fn combine'\n  ([keys vals] (combine' keys vals {}))\n  ([keys vals res]\n   (if (or (empty? keys) (empty? vals))\n     res\n     (combine' (rest keys) (rest vals) (assoc res (first keys) (first vals))))))","user":"5d06499ae4b0cc9c915881ec"},{"problem":61,"code":"(fn [a b] \n  (apply assoc {} (interleave a b)))","user":"58bc6a88e4b0888cdc949d16"},{"code":"(fn [keys values]\n  (apply hash-map (interleave keys values)))","problem":61,"user":"4e7c8fd1535db169f9c796be"},{"code":"(fn [ks vs]\n  (apply hash-map (flatten (map #(list %1 %2) ks vs))))","problem":61,"user":"4e6a2f51535d8ccf87e9fea9"},{"problem":61,"code":"(fn myZipmap [x y] (apply assoc {} (interleave x y)))","user":"542c1f73e4b0dad94371f29d"},{"problem":61,"code":"(fn [ks vs]\n  (into {} (map #(assoc {} %1 %2) ks vs)))","user":"510a3cd4e4b06956752d35ad"},{"problem":61,"code":"(fn [xs1 xs2] (into {} (map #(vector %1 %2) xs1 xs2)))","user":"57c6aa0be4b05aa3c4741cf7"},{"problem":61,"code":"(fn [x y] (into {} (map vec (partition 2 (interleave x y)))))","user":"54cad2d5e4b057c6fda3a26c"},{"problem":61,"code":"(fn my-zip [& coll]\n (reduce #(assoc %1 (first %2) (second %2)) {} (apply map list coll)))","user":"592fa9f8e4b072a2710fcfcb"},{"code":"(fn mapcons [x y]\n  (loop [m {}\n         a x\n         b y]\n    (if ( or (empty? a) (empty? b))\n    m\n    (recur (assoc m (first a) (first b))\n           (rest a)\n           (rest b))\n    )))","problem":61,"user":"522048b3e4b0e6c71e0c0c16"},{"problem":61,"code":"(fn [ks vs]\n                (loop [ks (seq ks)\n                       vs (seq vs)\n                       out {}]\n                  (cond\n                    (or (empty? ks) (empty? vs)) out\n                    :else (recur (rest ks)\n                                 (rest vs)\n                                 (assoc out (first ks) (first vs))))))","user":"5eb22708e4b00a66d4a95204"},{"problem":61,"code":"(fn [a b] (into {} (map (fn [x y] [x y]) a b)))","user":"52ced458e4b07d0d72b27394"},{"problem":61,"code":"(fn zip-map [a b]\n  (if \n    (or (empty? a) (empty? b))\n    {}\n    (assoc \n      (zip-map (rest a) (rest b)) \n      (first a) \n      (first b))))","user":"59733c91e4b01722bebd4c9b"},{"code":"(fn [l1 l2] (apply array-map (interleave l1 l2)))","problem":61,"user":"511b810ce4b07ab9ec456182"},{"code":"#(loop [m {} xs % ys %2]\n  (if (or (empty? xs) (empty? ys))\n    m\n    (recur\n      (assoc m (first xs) (first ys))\n      (rest xs)\n      (rest ys))))","problem":61,"user":"4fb1325de4b081705acca276"},{"problem":61,"code":"#(loop [[e1 & r1] %1 [e2 & r2] %2 m {}]\n              (if (or (= nil e1) (= nil e2))  \n                m\n                (recur r1 r2 (assoc m e1 e2))\n              )\n            )","user":"53a26cede4b0f1fc7453882a"},{"code":"#(apply hash-map (vec (interleave % %2)))","problem":61,"user":"52485723e4b05ef8e38e63d2"},{"problem":61,"code":"(fn [ks vs] \n  (apply merge (map #(assoc {} %1 %2) ks vs)))","user":"5f6d4305e4b02876ed9fd05c"},{"problem":61,"code":"#(loop [p1 %1 p2 %2 mp {}]\n   (if (or (empty? p1) (empty? p2))\n     mp\n     (recur (rest p1) (rest p2) (assoc mp (first p1) (first p2)))\n   ) \n )","user":"5876c0c5e4b01531a375ea8e"},{"problem":61,"code":"(fn my-zipmap [arr1 arr2]\n \n    (\n     into\n      (array-map)\n      (map vector arr1 arr2)\n      )\n  )","user":"5edc16e1e4b0c7845d86b0f1"},{"code":"#(apply assoc (cons {} (interleave % %2)))","problem":61,"user":"4e55b3dc535d8a8b8723a27f"},{"code":"(fn [x y] (into {} (map (fn [t z] [t z]) x y)))","problem":61,"user":"5125029de4b0ce9225d2ed3e"},{"problem":61,"code":"#(apply assoc {} (interleave %1 %2))\n\n;; (comp (partial apply sorted-map) interleave) ;; damn, that would have been beautiful instead","user":"59c76402e4b0a024fb6ae542"},{"code":"(fn[x y](into {} (#(map hash-map %1 %2) x y)))","problem":61,"user":"4fba77fae4b081705acca2df"},{"problem":61,"code":"(fn [a b] (apply hash-map (mapcat #(list %1 %2) a b)))","user":"5bc833a5e4b07a9b28b100bb"},{"problem":61,"code":"(fn [akeys values]\n  (reduce (fn [map [k v]] (assoc map k v)) {}\n       (partition 2 (interleave akeys values))))","user":"5033ed65e4b062bc5d7ae15a"},{"code":"#(apply hash-map\n  (mapcat list % %2))","problem":61,"user":"4f956072e4b0dcca54ed6ccf"},{"problem":61,"code":"(fn zipi [ks vs] (if (or (empty? ks) (empty? vs)) \n                   {}\n                   (assoc \n                     (zipi (rest ks) (rest vs))\n                     (first ks)\n                     (first vs))))","user":"53de622ce4b0d874e779ae34"},{"problem":61,"code":"#(->> (interleave %1 %2)\n      (apply hash-map))","user":"5b073c34e4b0cc2b61a3bda4"},{"code":"(fn [k v]\n      (loop [k k v v m {}]\n        (if (or (empty? k) (empty? v)) m\n         (recur (rest k) (rest v) (assoc m (first k) (first v)))))\n\n\n    )","problem":61,"user":"5029fccee4b023940c84aa47"},{"code":"(fn [ks vs]\n  (loop [m {}, ks ks, vs vs]\n    (if (and (seq ks) (seq vs))\n      (recur (assoc m (first ks) (first vs)) (rest ks) (rest vs))\n      m)))","problem":61,"user":"50f745f6e4b0035e89151849"},{"problem":61,"code":"(fn [keys values]\n  (reduce merge (map (fn [key value]{key value}) keys values)))","user":"563cdfdfe4b0bfe05bf11840"},{"code":"#(apply hash-map (mapcat (fn [a b] [a b]) %1 %2))","problem":61,"user":"4f29cdc8e4b0d6649770a033"},{"problem":61,"code":"#(into {} (map (fn [% %2] {% %2}) % %2))","user":"56193c6ee4b053970a773af2"},{"problem":61,"code":"(fn my-zipmap [ks vs]                                                        \n  (loop [my-map (sorted-map) ks ks vs vs]                                      \n    (if (or (empty? ks) (empty? vs))                                           \n      my-map                                                                   \n      (recur (into my-map [[(first ks) (first vs)]]) (rest ks) (rest vs)))))","user":"56eb16d8e4b04a395b9a041d"},{"problem":61,"code":"(fn\n  [keyz valz]\n  (loop [counter 0 coll valz result {}]\n    (let [current-key (nth keyz counter nil)\n          current-val (nth valz counter nil)]\n      (if (or (nil? current-key) (nil? current-val))\n        result\n        (recur (inc counter) (rest coll) (assoc result current-key current-val)))))\n  )","user":"603e8e3ae4b0d5df2af22316"},{"code":"(fn [lst1 lst2]\n  (loop [l1 lst1\n         l2 lst2\n         acc {}]\n    (if (or (empty? l1) (empty? l2)) acc\n      (recur (rest l1) (rest l2) (assoc acc (first l1) (first l2))))))","problem":61,"user":"4eaa47bc535d7eef30807309"},{"problem":61,"code":"(fn [list1 list2]\n  (apply merge (map (fn [el1 el2] {el1 el2}) list1 list2)))","user":"545801f6e4b01be26fd74615"},{"problem":61,"code":"(fn [a b] (into {}(for [c (range 0 (min (count a) (count b)))] {(nth a c) (nth b c)})))","user":"4e5e9f6b535d8a8b8723a2d2"},{"problem":61,"code":"(fn [lst1 lst2]\n  (loop [x lst1\n         y lst2\n         out {}]\n    (if (or (empty? x) (empty? y)) out\n      (recur (rest x) (rest y) (assoc out (first x) (first y))))))","user":"594bd637e4b07ddc2dafae41"},{"problem":61,"code":"(fn map-construction\n  [a b]\n  (apply hash-map (interleave a b)))","user":"57f8153de4b0d3187e900916"},{"code":"(fn [x y] (apply array-map (interleave x y)))","problem":61,"user":"4f7b6b90e4b06e829148e1a4"},{"code":"#(reduce (fn [m [k v]] (assoc m k v)) {} (partition 2 (interleave % %2)))","problem":61,"user":"538557aee4b06839e8705f02"},{"problem":61,"code":"(fn problem-61 [v1 v2]\n  (into {} (map vector v1 v2)))","user":"5a786f6be4b013a48d39976e"},{"problem":61,"code":"(fn [a b] (apply assoc {} (mapcat #(vector %1 %2) a b)))","user":"5a66f358e4b0512ff01cd9d5"},{"code":"#(apply assoc {}\n(interleave %1 %2))","problem":61,"user":"505d1b01e4b0e6aca564be04"},{"code":"(fn [coll1 coll2]\n\n   (apply sorted-map\n\n          (interleave coll1 coll2)))","problem":61,"user":"51227a00e4b068a9582e656b"},{"problem":61,"code":"(fn [keys vals]\n  (loop [keys keys\n         vals vals\n         result {}]\n    (let [current-key (first keys)\n          current-val (first vals)]\n      (if (or (empty? keys) (empty? vals))\n        result\n        (recur (rest keys) (rest vals) (assoc result current-key current-val))))))","user":"55842c7ee4b05c286339e11d"},{"problem":61,"code":"(fn [ks vs] \n  (apply hash-map (flatten (map list ks vs)))\n  )","user":"59cc4d5ee4b0a024fb6ae5d0"},{"problem":61,"code":"(fn [arg1 arg2]\n\t(loop [col1 arg1\n           col2 arg2\n           res {}\n           ]  \n      \t(cond\n         \t(or (empty? col1) (empty? col2)) res\n         \t:else (recur (rest col1) (rest col2) (conj res {(first col1) (first col2)}))\n         )\n      \n      )\n)","user":"5fc5c303e4b02c825b0c8c1a"},{"code":"(fn [ks vs]\n  (apply hash-map (interleave ks vs)))","problem":61,"user":"4e513ecf535dc968683fc4f6"},{"code":"(fn [coll coll2]\n  (letfn [(c [x y] {x y})]\n    (reduce merge (map c coll coll2))))","problem":61,"user":"5369a4b1e4b0243289761e9f"},{"problem":61,"code":"(fn [coll-one coll-two] (apply assoc {} (interleave coll-one coll-two)))","user":"5c1d9f05e4b0efcb0b05b24c"},{"problem":61,"code":"(fn\n  [v1 v2]\n  (loop [c1 v1 c2 v2 o {}]\n    (cond (or (empty? c1) (empty? c2)) o\n          :else (recur (rest c1) (rest c2) (assoc o (first c1) (first c2))))))","user":"57acee37e4b0b8559636fc94"},{"code":"(fn zm [k v]\n\t(apply hash-map (interleave k v))\n)","problem":61,"user":"511cca27e4b00c2a1fa7ff7d"},{"problem":61,"code":"(fn [a b] (into {} (map (fn [a b][ a b]) a b)))","user":"51421cd5e4b0b50abeb46b2c"},{"problem":61,"code":"(fn [x y]\n  (apply hash-map (mapcat list x y)))","user":"562d869be4b0a45d2ff8301f"},{"code":"(fn buildmap [x y]\n  (loop [cnt 0 newmap {}]\n    (if (= cnt (min (count x) (count y)))\n      newmap\n      (recur (inc cnt) \n      (conj newmap {(nth x cnt) (nth y cnt)}))\n)))","problem":61,"user":"4ea9b80c535d7eef30807306"},{"problem":61,"code":"(fn ass-key-val \n  [x y] (apply assoc {}\n               (interleave x y)))","user":"59afe4bae4b0e1f4e384c8c0"},{"problem":61,"code":"(fn [k v](into {} (map vector k v)))","user":"55597b84e4b0deb715856e36"},{"problem":61,"code":"(fn [a b] (into {} (mapv vec (partition 2 (interleave a b)))))","user":"4f6ba7bce4b07046d9f4efb0"},{"problem":61,"code":"(fn zip [v1 v2] (if (and (seq v1) (seq v2))\n                  (assoc (zip (rest v1) (rest v2)) (first v1) (first v2))\n                  {}))","user":"5ee93720e4b029a2061bbeb7"},{"code":"(fn [ks vs] (reduce #(assoc % (first %2) (second %2)) {} (partition 2 (interleave ks vs))))","problem":61,"user":"50c75d38e4b00bb60fe0c532"},{"problem":61,"code":";(fn [k v]\n;\t(loop [m {} k k v v]\n;\t\t(if (or (empty? k) (empty? v))\n;\t\t\tm\n;\t\t\t(recur (assoc m (first k) (first v)) (rest k) (rest v)))))\n\n;#(apply hash-map (interleave % %2))\n\n#(into {} (map vector % %2))","user":"5f6a583ae4b02876ed9fd046"},{"problem":61,"code":"#(into {}  (map vector %1 %2))","user":"5dd1fb19e4b0948ae9d9ad51"},{"problem":61,"code":"(fn [one two]\n  (into {} \n        (map #(hash-map %1 %2) one two)))","user":"546be022e4b00cfc9eacc171"},{"code":"(fn [col1 col2] (apply hash-map (mapcat #(vector  %1 %2) col1 col2 )))","problem":61,"user":"50a7b76de4b090657f4a5cdc"},{"problem":61,"code":"(fn mapper\n  ([c1 c2]\n    (do (prn c1 c2)\n    (mapper c1 c2 '{})))\n  ([c1 c2 result]\n   (if (and (seq c1) (seq c2))\n     (mapper (rest c1) (rest c2) (assoc result (first c1) (first c2)))\n     result)))","user":"56f4cedce4b046a417f92063"},{"problem":61,"code":"(fn [col_1 col_2] (reduce into {} (map (fn [item_1 item_2] (assoc {} item_1 item_2))  col_1 col_2)))","user":"588f500ae4b00487982d51a4"},{"problem":61,"code":"#(reduce (fn [c [k v]] (assoc c k v)) {} (map list % %2))","user":"5a8e9a7ae4b05369db4d2528"},{"code":"(fn f\n  ([k v] (f k v {}))\n  ([k v m]\n     (if (or (empty? k) (empty? v))\n         m\n         (recur (rest k) (rest v) (assoc m (first k) (first v))))\n  )\n)","problem":61,"user":"5302ac7fe4b0d8b024fd3731"},{"code":"(fn\n    [keys vals]\n    (loop [map {}\n           ks (seq keys)\n           vs (seq vals)]\n      (if (and ks vs)\n        (recur (assoc map (first ks) (first vs))\n               (next ks)\n               (next vs))\n        map)))","problem":61,"user":"4dadba4dc9a9d6ed3899dc57"},{"code":"(fn myassoc [a b]\n  (loop [h '{} a1 a b1 b]\n    (if (or (= 0 (count a1)) (= 0 (count b1)))\n      h\n      (recur (assoc h (first a1) (first b1)) (rest a1) (rest b1)))))","problem":61,"user":"51622fb8e4b009fba0926e3f"},{"problem":61,"code":"(fn [& xs] (into {} (apply mapv vector xs)))","user":"594bc7d6e4b07ddc2dafae3d"},{"code":"(fn [l1 l2] (reduce merge (map #(hash-map %1 %2) l1 l2)))","problem":61,"user":"50b63c5ee4b0a86f8358ca69"},{"problem":61,"code":"#(into {} (map vec (map list %1 %2)))","user":"55895eade4b059ccff29b202"},{"code":"#(apply assoc {} (mapcat list %1 %2))","problem":61,"user":"4e9b230c535dbda64a6f6b75"},{"problem":61,"code":"(fn [keys vals]\n   (->> (map list keys vals)\n        (reduce (fn [acc [key val]]\n                  (assoc acc key val))\n                nil)))","user":"5808ee16e4b0a837a8b30d16"},{"problem":61,"code":"(fn [ks vs] (apply hash-map (flatten (map (fn [k v] [k v]) ks vs))))","user":"5b9357b7e4b0c0b3ffbd4a46"},{"problem":61,"code":"(fn [a b]\n  (loop [x a\n         y b\n         o {}]\n    (if (or (empty? x)(empty? y))\n      o\n      (recur (rest x) (rest y) (into o {(first x) (first y)})))))","user":"566d71b1e4b0a866af6896ca"},{"problem":61,"code":"(fn [x y]\n    (into {} (map vector x y)))","user":"4e837808535db62dc21a62d9"},{"code":"(fn adder\n   ([a b] (adder a b {}))\n   ([a b c] (if (and (first a) (first b)) (adder (rest a) (rest b) (assoc-in c (vector (first a)) (first b))) c))\n   )","problem":61,"user":"4ff8aa3fe4b0678c553fc39e"},{"problem":61,"code":"(fn[a1 a2]\n(into {} (map vector a1 a2)))","user":"539f9f79e4b0ca733b97449e"},{"problem":61,"code":"(fn my-zipmap\n  [a b]\n  (into {} (map vector a b)))","user":"59636ec9e4b066ee0a44b0c8"},{"problem":61,"code":"(fn [keys values]\n   (apply assoc {} (interleave keys values)))","user":"558843dae4b059ccff29b1f3"},{"problem":61,"code":"(fn construct [ks vs]\n  (into {}\n        (map #(hash-map %1 %2) ks vs)\n  )\n)","user":"56393681e4b0bfe05bf117f2"},{"code":"(fn zmap [v1 v2]\r\n  (loop [m {}, vv1 v1, vv2 v2]\r\n    (if (or (nil? (seq vv1)) (nil? (seq vv2)))\r\n      m\r\n      (recur (assoc m (first vv1) (first vv2)) \r\n             (rest vv1) (rest vv2)))))","problem":61,"user":"4e123905535d04ed9115e7ce"},{"code":"(fn [ks vs]\n  (apply merge (map #(hash-map %1 %2) ks vs)))","problem":61,"user":"52a55adee4b0c58976d9abe7"},{"problem":61,"code":"(fn mp[a b]\n  (loop [a a\n         b b\n         c []]\n    (if (or (empty? a)(empty? b))\n      (into (sorted-map) c)\n      (recur(rest a)(rest b)(conj c [(first a)(first b)])))))","user":"57f814fbe4b0d3187e900911"},{"code":"(fn \n  [keys vals]\n    (loop [map {}\n           ks (seq keys)\n           vs (seq vals)]\n      (if (and ks vs)\n        (recur (assoc map (first ks) (first vs))\n               (next ks)\n               (next vs))\n        map)))","problem":61,"user":"4daedd1eedd6309eace4d164"},{"problem":61,"code":"(fn f [ks vls]\n  (->> (map (fn [k v] [k v]) ks vls)\n       (into {})))","user":"5777c3d6e4b0979f8965164f"},{"code":"(fn [m c1 c2] (if (and (seq c1) (seq c2))  (recur (assoc m (first c1) (first c2)) (rest c1) (rest c2)) m)) {}","problem":61,"user":"4dbbdf86535d3f4042261ece"},{"code":"(fn [& s] (apply hash-map (apply interleave s)))","problem":61,"user":"4daf907aedd6309eace4d17b"},{"code":"#(into {} (apply map (fn [a b] [a b]) %&))","problem":61,"user":"4e7115b3535d5021c1a89647"},{"code":"#(loop [m {}, % %, %2 %2]\n    (if (and (seq %) (seq %2))\n      (recur (assoc m (first %) (first %2)) (rest %) (rest %2))\n      m))","problem":61,"user":"51a91ac2e4b08d8ec191b822"},{"problem":61,"code":"#(apply hash-map\n       (mapcat\n           (fn [k v] [k v])\n           % %2))","user":"5d28b684e4b092dab7f59c83"},{"problem":61,"code":"(fn my-zm [[k & k-args] [v & v-args]]\n   (if (and (seq k-args) (seq v-args))\n     (assoc (my-zm k-args v-args) k v)\n     {k v}))","user":"55f8b32ae4b03cbcff9738ba"},{"problem":61,"code":"(fn [colla collb]\n  (loop [result {}\n         a colla\n         b collb]\n    (if (or (empty? a) (empty? b))\n      result\n      (recur (into result {(first a) (first b)}) (rest a) (rest b)))))","user":"540e8d13e4b0addc1aec671e"},{"problem":61,"code":"(fn\n  [keys vals]\n  (into (hash-map) (map (fn [k v] [k v]) keys vals)))","user":"5ec02e20e4b00a66d4a95288"},{"problem":61,"code":"(fn [kc vc]\n  (loop [kc kc vc vc result {}]\n    (let [fc (first kc) fv (first vc)]\n      (if (or (nil? fc) (nil? fv))\n        result\n        (recur (rest kc) (rest vc) (into result {fc fv}))))))","user":"5546704be4b0a04f7929953d"},{"problem":61,"code":"#(apply merge (map (fn [k v]\n                     {k v})\n                   %1\n                   %2))","user":"59251947e4b072a2710fce69"},{"code":"(fn [keys vals]\n(apply (partial assoc {}) (interleave keys vals)))","problem":61,"user":"501688f7e4b052339a490e7a"},{"problem":61,"code":"(fn [keys values] (apply assoc {} (interleave  keys values)))","user":"5a634ff0e4b0512ff01cd995"},{"problem":61,"code":"(fn [a b] (apply conj (map #(assoc nil %1 %2) a b)))","user":"53e9dce1e4b036ad0777e4bc"},{"problem":61,"code":"(fn [xs ys]\n  (loop [[x & xs] xs\n         [y & ys] ys\n         acc {}]\n    (if (and x y)\n      (recur xs ys (assoc acc x y))\n      acc)))","user":"5687b6abe4b0dcc4269f4061"},{"problem":61,"code":"(fn [listone listtwo]\n  (apply hash-map (flatten (map (fn [x y] [x y]) listone listtwo))))","user":"58e6a2c5e4b056aecfd47cba"},{"problem":61,"code":"(fn f [x y]\n  (if (some empty? [x y])\n    {}\n    (conj (f (rest x) (rest y)) (vector (first x) (first y)))))","user":"574b4f3ee4b02ea114799207"},{"problem":61,"code":"(fn [x y] (apply hash-map (mapcat #(vector %1 %2) x y)))","user":"524f3e6de4b0541d1855b805"},{"code":"(fn abr [x y]\r\n (into {} (map vector x y))\r\n)","problem":61,"user":"4edf92f0535d10e5ff6f5341"},{"problem":61,"code":"(fn map-const\n  [coll1 coll2]\n  (reduce conj (map hash-map coll1 coll2)))","user":"60396c95e4b0d5df2af222f4"},{"problem":61,"code":"(fn[x y] (into {} (map #(assoc {} %1 %2) x y)))","user":"54ce541de4b057c6fda3a2ac"},{"problem":61,"code":"(fn [listA listB] (reduce #(assoc %1 (first %2) (second %2)) {} (map #(conj [] %1 %2) listA listB)))","user":"5ee4545ee4b029a2061bbe8d"},{"problem":61,"code":"(fn my-map\n  [keys values]\n  (apply assoc {} (interleave keys values)))","user":"5bbbcf9ee4b0a20761a23614"},{"problem":61,"code":"(fn [m1 m2] (apply merge (map #(assoc {} % %2) m1 m2)))","user":"5be96111e4b0f319e2d7ec70"},{"problem":61,"code":"(fn prob61\n  [keys values]\n  (into {} (map #(hash-map %1 %2) keys values)))","user":"4ebbff41535dfed6da9c6d78"},{"problem":61,"code":"(fn zip-map [keys vals]\n  (into {} (map vector keys vals)))","user":"551bdefde4b07993ea3788d7"},{"problem":61,"code":"(fn constr\n  ( [result keys values] (if-not (or (empty? keys) (empty? values))\n                           (constr (into result (array-map (first keys) (first values))) (rest keys) (rest values))\n                           result))\n  ([keys values] (constr (array-map (first keys) (first values)) (rest keys) (rest values))))","user":"56aa9464e4b07966d5a8a08d"},{"problem":61,"code":"(fn [keys vals]\n  (loop [res {}\n         k (seq keys)\n         v (seq vals)]\n    (if (or (empty? k) (empty? v))\n      res\n      (recur (assoc res (first k) (first v)) (rest k) (rest v)))))","user":"5fada7cce4b08cb800c85af5"},{"code":"(fn zippo\n  ([k v] (zippo k v {}))\n  ([k v m] (if (or (empty? k) (empty? v))\n             m\n             (zippo (rest k) (rest v) (assoc m (first k) (first v))))))","problem":61,"user":"4e7ada51535db169f9c796ae"},{"problem":61,"code":"(fn [coll1 coll2]\n  (into {} (map #(vector %1 %2) coll1 coll2)))","user":"53f6bfd9e4b0db01ade6f9e4"},{"code":"(fn [keys values]\n\t\t(reduce (fn [result input]\n\t\t\t(assoc result (key (first input)) (val (first input)))) {} (map hash-map keys values)))","problem":61,"user":"51205867e4b0e88f5a20c40f"},{"code":"(fn [l r]\n  (apply hash-map (interleave l r)))","problem":61,"user":"52091d57e4b0e152394d76f0"},{"problem":61,"code":"(fn [l1 l2] (apply merge (map #(assoc {} % %2) l1 l2)))","user":"5c0e3f86e4b01240ff56713d"},{"problem":61,"code":"(fn [ks vs]\n      (loop [[k :as ks] ks\n             [v :as vs] vs\n             ret {}]\n        (cond (empty? ks) ret\n              (empty? vs) ret\n              :else (recur (rest ks) (rest vs) (assoc ret k v)))))","user":"5f82cfcce4b0c071e6c840fb"},{"code":"(fn [coll1 coll2]\n  (reduce #(conj %1 %2) {} \n    (map #(vector %1 %2) coll1 coll2)))","problem":61,"user":"5030f16fe4b05b7df5a0b84b"},{"code":"(fn [l r]\n  (loop [x l y r acc {}]\n    (if (or (empty? x) (empty? y))\n      acc\n      (recur (rest x) (rest y) (conj {(first x) (first y)} acc)))))","problem":61,"user":"4ffb38e8e4b0678c553fc3c6"},{"code":"#(into {} (map (fn [x y] [x y]) %1%2))","problem":61,"user":"502904e0e4b0feaf66e22fad"},{"code":"(fn f [keys vals]\n  (if (or (empty? keys) (empty? vals))\n    {}\n    (conj (f (rest keys) (rest vals))\n          (hash-map (first keys) (first vals)))))","problem":61,"user":"521b73f5e4b0c4ef0be83043"},{"problem":61,"code":"(fn [key-coll val-coll] (apply assoc (into [{ }] (interleave key-coll val-coll))))","user":"57b356c2e4b0fbc9809a277b"},{"problem":61,"code":"(fn [coll-a coll-b]\n  (reduce (fn [acc [a b]] (assoc acc a b)) {} (map (fn [a b] [a b]) coll-a coll-b))\n  )","user":"55fbc657e4b0f488688e0666"},{"problem":61,"code":"(fn [kys values]\n  (let [minLength (min (count kys) (count values))]\n    (reduce\n     #(assoc %1 (.get kys %2) (.get values %2)) \n     {} \n     (range minLength)\n     )\n    )\n  )","user":"56d74c88e4b0ea9b8538f7d9"},{"problem":61,"code":"(fn [keys vals] (apply hash-map (mapcat list keys vals)))","user":"55f06183e4b06e875b46ce23"},{"problem":61,"code":"(fn foo [parm1 parm2] (loop [map {} key (seq parm1) value (seq parm2)]\n                          (if (and key value)\n                            (recur (assoc map (first key) (first value)) (next key) (next value))\n                            map)))","user":"598d0dc3e4b02b9968b84d18"},{"problem":61,"code":"(fn [a b]\n  (apply conj (map hash-map a b)))","user":"562cb7cfe4b0a45d2ff83009"},{"problem":61,"code":"(fn my-zipmap [[k & ks] [v & vs]]\n  (if (or (empty? ks) (empty? vs))\n    {k v}\n    (assoc (my-zipmap ks vs) k v)))","user":"569f99cce4b0542e1f8d1497"},{"problem":61,"code":"(fn man-zipmap [keys vals]\n  (loop [map {}\n         ks (seq keys)\n         vs (seq vals)]\n    (if (and ks vs)\n      (recur (assoc map (first ks) (first vs))\n             (next ks)\n             (next vs))\n      map))\n  )","user":"5c51d700e4b0fb8c5ffd99d1"},{"code":"#(reduce conj (map hash-map %1 %2))","problem":61,"user":"4dadca03c9a9d6ed4199dc57"},{"code":"(fn a [c1 c2] (merge {(first c1) (first c2)} (if-not(or(= 1 (count c1))(= 1 (count c2)))(a (next c1)(next c2)))))","problem":61,"user":"527a8eb7e4b03e8d9a4a755f"},{"problem":61,"code":"(fn [keys values]\n    (reduce (fn [map [key value]] (assoc map key value))\n            {}\n            (map (fn [k v] [k v]) keys values)))","user":"554a75c9e4b0a04f79299575"},{"problem":61,"code":"(fn [ks vs]\n  (reduce conj {} (map #(vector %1 %2) ks vs)))","user":"56761ab1e4b05957ce8c6154"},{"code":"(fn [a b] (into {} (map #(vector % %2) a b)))","problem":61,"user":"52d7f9a8e4b09f7907dd1381"},{"problem":61,"code":"(fn [a b](into (hash-map) (map vector a b)))","user":"4f30896ce4b0d6649770a07b"},{"problem":61,"code":"(fn  s[xs ys] \n  (apply merge (for [c (range (min (count xs) (count ys)))] {(get xs c) (get ys c)})))","user":"55f01316e4b06e875b46ce1a"},{"problem":61,"code":"(fn my-zipmap\n  [ks vs]\n  (into {} (map hash-map ks vs)))","user":"579f89d5e4b05302be0b72ff"},{"problem":61,"code":"(fn zm [keys vals]\n  (loop [r {} k keys v vals]\n    (if (or (empty? k) (empty? v))\n      r\n      (recur (assoc r (first k) (first v)) (rest k) (rest v)))))","user":"5f9c4113e4b0715f5002d821"},{"problem":61,"code":"(fn [kys vls]\n   (->>\n     (interleave kys vls)\n     (apply hash-map)))","user":"5e9878b9e4b0157ca96647d8"},{"problem":61,"code":"(fn [a b]\n  (let [pairs (map #(hash-map %1 %2) a b)]\n    (apply merge pairs)))","user":"50a00725e4b08df8156e9e46"},{"problem":61,"code":"#(into {} (map (fn [x y] {x y}) %1 %2))","user":"53c38b8ce4b00fb29b22127b"},{"problem":61,"code":"(fn [x y]\n  (reduce #(apply assoc %1 %2 ) {} (map vector x y)))","user":"5e85163be4b09a7a73c8bbd0"},{"problem":61,"code":"#(into {} (map (fn [a b] (hash-map a b)) % %2))","user":"4dbd7107535d020aff1edf42"},{"problem":61,"code":"(fn my-map [x y] \n  (if (or (= 0 (count x)) (= 0 (count y)) )\n    {} \n    (conj (my-map (rest x) (rest y)) {(first x) (first y)})))","user":"56ff7ffee4b08d47c97781be"},{"code":"(fn [k v] (reduce #(assoc %1 (first %2) (last %2)) {} (map list k v)))","problem":61,"user":"52caeb25e4b071a8d36bd3e7"},{"problem":61,"code":"(fn\n  [x y]\n  (loop [x x\n         y y\n         r {}]\n       (cond\n         (empty? y)  r\n         (empty? x) r\n         :else (recur (rest x) (rest y) (assoc r (first x) (first y))))))","user":"57fedf07e4b0d3187e9009dc"},{"problem":61,"code":"(fn map-construct\n  [xs ys]\n  (apply hash-map (mapcat list xs ys)))","user":"557e9d17e4b05c286339e0d8"},{"problem":61,"code":"(fn fc61 [ks vs]\n  (letfn [(fc61-helper [ks vs]\n            (cond (empty? ks) []\n                  (empty? vs) []\n                  :else (conj (fc61 (rest ks) (rest vs)) (vector (first ks) (first vs)))))]\n    (into (sorted-map) (fc61-helper ks vs))))","user":"547884d7e4b0c51c1f4d72bd"},{"problem":61,"code":"#(reduce conj {} (map vec (partition 2 (interleave % %2))))","user":"55c10409e4b01b9910ae2a2c"},{"code":"(fn zipper [k v]\n  (apply merge (map #(hash-map %1 %2) k v)))","problem":61,"user":"4e0d5a5a535d04ed9115e7b5"},{"problem":61,"code":"(fn [coll1 coll2]\n  (apply merge (map (fn [k v] {k v}) coll1 coll2)))","user":"57f80350e4b0d3187e90090c"},{"code":"(fn a [k v]\n  (apply assoc {} (interleave k v)))","problem":61,"user":"525aa499e4b0cb4875a45cf7"},{"problem":61,"code":"(fn [colla collb]\n  (->>\n    (map (fn [k v] {k v})\n         colla collb)\n    (reduce (fn [res-map item]\n              (conj res-map item)) {})))","user":"591072e0e4b0163c97b36ebc"},{"code":"(fn [ks vs]\r\n  (apply hash-map (mapcat #(identity [% %2]) ks vs)))","problem":61,"user":"50608ea0e4b07251188e4456"},{"code":"(fn [k v] (loop [final {}\n                 rk k\n                 rv v]\n            (if (or (empty? rk) (empty? rv))\n              final\n              (recur (assoc final (first rk) (first rv)) (next rk) (next rv)))))","problem":61,"user":"507a33dee4b08327cd804a68"},{"problem":61,"code":"(fn fff [l1 l2] (if (or (empty? l1) (empty? l2)) {} (conj (fff (rest l1) (rest l2)) [(first l1) (first l2)])))","user":"5c54e605e4b0fb8c5ffd9a14"},{"problem":61,"code":"(fn zpm [s1 s2]\n  (reduce #(conj %1 (vec %2)) {} (partition 2 (interleave s1 s2))))","user":"5f8b06afe4b0715f5002d74a"},{"code":"(fn[x y](into {} (apply map vector [x y])))","problem":61,"user":"5302d79ce4b0d8b024fd3736"},{"code":"(fn myf [x y] ( if (or (empty? x) (empty? y)) {}  (assoc (myf (rest x) (rest y)) (first x) (first y))  ) )","problem":61,"user":"50646c01e4b007509339a58b"},{"problem":61,"code":"(fn construct-map [ks vs]\n  (reduce\n    (fn [z h]\n        (assoc z (nth ks h) (nth vs h)))\n    {}\n    (range (min (count ks) (count vs)))))","user":"5b15811ee4b0cc2b61a3be6f"},{"code":"(fn [ks vs]\n  (reduce (fn [accum pair]\n            (conj accum pair))\n          {}\n         (map (comp identity vector)\n              ks vs)))","problem":61,"user":"4fa3c137e4b081705acca193"},{"code":"(fn [a b] (into {} (map (fn [x] (assoc {} (first x)(last x))) (partition-all 2 (interleave a b)))))","problem":61,"user":"4e61bb60535d8ccf87e9fe5c"},{"problem":61,"code":"(fn zm [ks vs]\n  (apply hash-map (interleave ks vs)))","user":"54dce62be4b024c67c0cf78b"},{"problem":61,"code":"#(apply assoc {} (reverse (interleave %2 %1)))","user":"56c60b36e4b05cc29241eead"},{"code":"(fn zm [xs ys]\n  (->> (interleave xs ys)\n       (partition 2)\n       (map vec)\n       (reduce conj {})))","problem":61,"user":"4ea348ad535d7eef308072c4"},{"problem":61,"code":"(fn my-zipmap [keys vals] (if (or (empty? keys) (empty? vals)) {} (assoc (my-zipmap (rest keys) (rest vals)) (first keys) (first vals))))","user":"55d95be7e4b0e31453f64ac9"},{"code":"(fn [k v] (loop [m {} ks (seq k) vs (seq v)] (if (and ks vs) (recur (assoc m (first ks) (first vs))(next ks)(next vs))m)))","problem":61,"user":"51eab308e4b0f1f103a0d150"},{"problem":61,"code":"(fn myzipmap \n  ([k v]\n    ( myzipmap k v {})\n  )\n  ([k v m]\n    ( if (or (empty? v) (empty? k))\n      m\n      (myzipmap (rest k) (rest v) (assoc m (first k) (first v)))\n    )\n  )\n)","user":"55d35a01e4b0e31453f64a63"},{"problem":61,"code":"(fn [a b]\n  (into {} (map #(apply hash-map [%1 %2]) a b)))","user":"52a3c66ce4b04e0c58e87c04"},{"problem":61,"code":"(fn map-construction [keys vals]\r\n    (into {} (map \r\n            vector\r\n            keys \r\n            vals)))","user":"60c90322e4b0e0fa5f1b4302"},{"code":"(fn my-zipmap\n  [keys vals]\n  (apply merge\n         (map #(assoc {} (first %) (fnext %))\n              (partition 2 (interleave keys vals)))))","problem":61,"user":"4e7f51eb535db966e863cc3f"},{"code":"#(into {} (map vector % %2))\n\n; #(apply hash-map (interleave %1 %2))\n; #(apply assoc {} (interleave %1 %2))","problem":61,"user":"503f4759e4b00d1a725ff2a9"},{"problem":61,"code":"(fn create-map\n  [ks vs]\n  (apply hash-map (flatten (map #(list %1 %2) ks vs))))","user":"53b952eee4b047364c0444e6"},{"problem":61,"code":"(fn [ks vs]\n  (reduce\n   (partial apply assoc)\n   {}\n   (map vector ks vs)))","user":"521d064fe4b0c4ef0be830a8"},{"problem":61,"code":"(fn [keys vals]\n  (loop [my-map {}\n         my-keys keys\n         my-vals vals]\n    (if (and my-keys my-vals)\n      (recur (assoc my-map (first my-keys) (first my-vals))\n             (next my-keys)\n             (next my-vals))\n      my-map)))","user":"56fee4c0e4b08d47c97781b5"},{"problem":61,"code":"(fn [k v]\n  (loop [[k1 & k2] k [v1 & v2] v result (hash-map)]\n    (if (or (= k1 nil) (= v1 nil))\n      result\n      (recur k2 v2 (conj result (hash-map k1 v1))))))","user":"5e7f62cce4b085ba37836e3b"},{"code":"(fn [ks vs] (loop [ks ks vs vs acc {}]\n  (if (not (or (empty? ks) (empty? vs)))\n    (recur (rest ks) (rest vs) (conj acc [(first ks) (first vs)]))\n    acc)))","problem":61,"user":"504f865ee4b0a02f9cffde90"},{"problem":61,"code":"(fn [keys values] (loop [keylst keys valuelst values result {}]\n                    (if (empty? keylst)\n                      result\n                      (if (empty? valuelst)\n                        result\n                        (recur (rest keylst) (rest valuelst) (assoc result (first keylst) (first valuelst)))))))","user":"606d75f5e4b069485764de13"},{"problem":61,"code":"(fn [k v] (apply assoc {} (mapcat #(list %1 %2) k v)))","user":"56b2573ce4b0982f16b37e02"},{"code":"(fn [s1 s2]\n\t(into {} (map (fn [x y] [x y]) s1 s2)\n    )\n)","problem":61,"user":"525ba7bbe4b0cb4875a45d28"},{"problem":61,"code":"(fn [keys vals]\n   (loop [s nil\n          k keys\n          v vals]\n     (if (empty? k)\n       s\n       (recur \n         (if (empty? v) s (assoc s (first k) (first v))) \n         (rest k) \n         (rest v)))))","user":"5ea444b7e4b00a66d4a951a0"},{"code":"#(into {} (map (fn [k v] (assoc {} k v)) %1 %2))","problem":61,"user":"4e79a143535db169f9c796a2"},{"problem":61,"code":"(fn merge [one two] \n       (if (or (empty? one) (empty? two))\n         {}\n         (assoc (merge (rest one) (rest two)) (first one) (first two))))","user":"5654cb2de4b0f9d632dd848b"},{"code":"(fn [c1 c2] (reduce (fn [m [k v]] (assoc m k v)) {} (map vector c1 c2)))","problem":61,"user":"52b94e26e4b07a9af57922b9"},{"problem":61,"code":"(fn my-zipmap [s t]\n  (if (or (empty? s) (empty? t))\n    {}\n    (assoc (my-zipmap (rest s) (rest t)) (first s) (first t))\n  )\n)","user":"54982522e4b0b312c081ff7c"},{"code":"(fn [keys vals]\n  (last \n    (reduce \n      #(list\n        (rest (first %1))\n        (assoc (last %1) (ffirst %1) %2))\n      [keys (hash-map)]\n      (take (count keys) vals))))","problem":61,"user":"4f1b92d1535d64f60314647b"},{"problem":61,"code":"(fn f\n  ([k v] (f {} k v))\n  ([m [k & ks] [v & vs]]\n   (if (and k v)\n     (f (assoc m k v) ks vs)\n     m)))","user":"57a0b341e4b0c3d858beb8d4"},{"problem":61,"code":"(fn my-zipmap2 [keys vals]\n  (apply hash-map (interleave keys vals)))","user":"5a621702e4b0512ff01cd983"},{"problem":61,"code":"(fn [xs ys & m]\n   (let [m (if (nil? m) {} m)\n         x (first xs)\n         xs (rest xs)\n         y (first ys)\n         ys (rest ys)]\n     (if (or (empty? xs) (empty? ys))\n       (assoc m x y)\n       (recur xs ys (assoc m x y)))))","user":"51bb08a4e4b0fe3ecfb46446"},{"code":"(fn [ks vs] \n  (reduce merge \n    (map (fn [k v] {k v}) ks vs)))","problem":61,"user":"4e6ab9cb535d8ccf87e9fefe"},{"code":"(fn [xs ys]\n  (apply hash-map (flatten\n    (map #(vector %1 %2) xs ys))))","problem":61,"user":"50611456e4b0dc10a69545a5"},{"problem":61,"code":"(fn dict [keys values]\n  (loop [result {}, ks keys, vs values]\n    (if (or (empty? ks) (empty? vs))\n      result\n      (recur (assoc result (first ks) (first vs))\n             (rest ks) (rest vs))\n      )\n    )\n  )","user":"5f6adf5ee4b02876ed9fd049"},{"problem":61,"code":"(fn [x y]\n  (apply merge (map #(assoc {} %1 %2) x y))\n  )","user":"56f188e9e4b04a395b9a0494"},{"code":"(fn [keys vals]\n  (loop [keys keys vals vals m {}]\n    (if (or (empty? keys) (empty? vals))\n        m\n        (recur (rest keys) \n(rest vals) \n(conj m [(first keys) (first vals)])))))","problem":61,"user":"4f03ebf7535dcb61093f6b7f"},{"problem":61,"code":"(fn [keys values]\n  (reduce merge {} (map #(hash-map %1 %2) keys values)))","user":"5b60e88be4b0c6492753e70b"},{"problem":61,"code":"(fn my-zipmap\n  [x y]\n  (loop [[x & xrest] x\n         [y & yrest] y\n         result {}]\n    (if (or (empty? xrest) (empty? yrest))\n      (assoc result x y)\n      (recur xrest yrest (assoc result x y)))))","user":"5f003099e4b0cf489e8d7f17"},{"problem":61,"code":"(fn [x y] (reduce (fn [acc [k v]] (assoc acc k v)) {} (map #(vector %1 %2) x y)))","user":"5ccb0bbee4b0ccb06196287c"},{"problem":61,"code":"(fn make-map \n   ([keys values]\n    (make-map keys values {}))\n  ([keys values m]\n    (if (and (> (count keys) 0) (> (count values) 0)) \n      (make-map \n       (rest keys) \n       (rest values) \n       (assoc m (first keys) (first values))) m )\n   )\n  )","user":"5d5eb086e4b0c9e5857d4ff7"},{"code":"(fn [x y] (loop [x x y y result {}] (if (and (seq x) (seq y)) (recur (rest x) (rest y) (assoc result (first x) (first y))) result)))","problem":61,"user":"4e6a4edd535d8ccf87e9fec4"},{"problem":61,"code":"(fn solution61\n  [kkeys vvalues]\n  (loop [kkeys   kkeys\n         vvalues vvalues\n         ans     {}]\n    (let [fk (first kkeys)\n          fv (first vvalues)]\n      (if (or (nil? fk) (nil? fv))\n        ans\n        (recur (rest kkeys) (rest vvalues) (assoc ans fk fv))))))","user":"595bc925e4b066ee0a44afe2"},{"problem":61,"code":"(fn [f s]\n  (->> (interleave f s)\n       (partition 2)\n       (reduce #(conj % (vec %2)) {})))","user":"5703a557e4b08d47c97781f4"},{"code":"(fn my-map [k v]\n  (loop [kp k\n         vp v\n         result {}]\n    (if (or (empty? kp) (empty? vp))\n      result\n      (recur (next kp) (next vp) (assoc result (first kp) (first vp))))))","problem":61,"user":"4efb92ce535dced4c769f27a"},{"problem":61,"code":"(fn [a b]\n  (loop [x a, y b, r {}]\n    (if (or (empty? x) (empty? y)) r (recur (rest x) (rest y) (assoc r (first x) (first y))))))","user":"53bcdd41e4b0d9a98559a6c0"},{"code":"(fn [x y]\n          (loop [accum {} x x y y]\n            (if (or (empty? x) (empty? y))\n              accum\n              (recur (conj accum {(first x) (first y)}) (rest x) (rest y)))))","problem":61,"user":"504e0136e4b078edc5f5938e"},{"problem":61,"code":"(fn [coll1 coll2]\n  (reduce (fn [m [k v]]\n            (assoc m k v))\n          {}\n          (map list coll1 coll2)))","user":"59225498e4b09b4ee5954c8c"},{"code":"(fn [keys values] (apply hash-map (interleave keys values)))","problem":61,"user":"4ee9d697535d93acb0a66895"},{"code":"(fn [ks vs]\r\n          (reduce #(conj %1 (vec %2))\r\n                  {}\r\n                  (partition 2 (interleave ks vs))))","problem":61,"user":"4f07ad89535dcb61093f6c2a"},{"problem":61,"code":"(fn [k v] (apply merge (map (fn [%1 %2]{%1 %2}) k v)))","user":"58983e3fe4b00487982d52ce"},{"problem":61,"code":"(fn [ks vs]\n  (loop [acc {} k ks v vs]\n    (if (and (seq k) (seq v))\n      (recur (assoc acc (first k) (first v)) (rest k) (rest v))\n      acc)))","user":"55f8fd70e4b03cbcff9738bc"},{"code":"(fn [a b] (apply array-map (interleave a b)))","problem":61,"user":"4f559d2ce4b0a7574ea71808"},{"code":"(fn [klucze wartosci]\n  (loop [ks (seq klucze)\n         vs (seq wartosci)\n         mapa {}]\n    (if (or (empty? ks) (empty? vs)) mapa\n\t(recur (rest ks) (rest vs) (assoc mapa (first ks) (first vs))))))","problem":61,"user":"5213348ae4b0d32679a50652"},{"code":"(fn [v1 v2] (reduce merge {} (map #(identity {%1 %2}) v1 v2)))","problem":61,"user":"50b24a2fe4b03ea88043355c"},{"code":"(fn zip [a b] (if (and (seq b)(seq a)) (assoc (zip (rest a) (rest b)) (first a) (first b) ) {}))","problem":61,"user":"522a01ade4b0590a43906ced"},{"problem":61,"code":"(fn [xs ys] (apply hash-map (apply concat (map vector xs ys))))","user":"579c7db7e4b05b1deef9ae0a"},{"problem":61,"code":"(fn [key_coll, val_coll]\n    (reduce conj\n            (map #(hash-map %1 %2) key_coll val_coll)))","user":"55893b09e4b059ccff29b1fe"},{"code":"(fn [v1 v2] (into {} (map #(vector %1 %2) v1 v2)))","problem":61,"user":"534f13b2e4b084c2834f4ac4"},{"problem":61,"code":"(fn Map-Construction\n  [a b]\n  (apply hash-map (interleave a b)))","user":"59e14ee3e4b08badc2a0c50c"},{"problem":61,"code":"(fn [x y] (apply sorted-map (seq (interleave x y))))","user":"54eca495e4b024c67c0cf855"},{"problem":61,"code":"(fn [k v]\n  (loop [k k, v v, res {}]\n    (if (and (seq k) (seq v))\n      (recur (rest k) (rest v) (assoc res (first k) (first v)))\n      res)))","user":"5a7ae674e4b03baeef9276d5"},{"code":"(fn [ks vs]\n  (->> (map vector ks vs)\n       (reduce (fn [m [k v]]\n                 (assoc m k v))\n               {})))","problem":61,"user":"4dc0ff08535d020aff1edf84"},{"problem":61,"code":"(fn [a b](into {} (map #(hash-map %1 %2) a b)))","user":"552800d7e4b0ffed3738f93a"},{"code":"(fn zipmap-2 [k v]\n  (loop [ks k vs v m {}]\n    (if (or (empty? ks) (empty? vs))\n      m\n      (recur (rest ks) (rest vs) (into m {(first ks) (first vs)})))))","problem":61,"user":"519136e9e4b0f8ef0be96c01"},{"problem":61,"code":"(fn zip [k v]\n  (when \n   (and \n    (> (count k) 0)\n    (> (count v) 0)\n   )\n    (assoc \n     (zip \n      (rest k)\n      (rest v))\n     (first k)\n     (first v)\n    )\n   )\n)","user":"5c0d0537e4b0bdcf453d173d"},{"code":"(fn test1 [inseq1 inseq2] (loop [x inseq1 y inseq2 z {}] (if \n                                    (or (= (count x) 0)(= (count y) 0)) z \n                                    (recur (rest x) (rest y) (assoc z (first x) (first y))))))","problem":61,"user":"52711255e4b03e8d9a4a73d7"},{"problem":61,"code":"(fn [& coll]\n   (apply merge (apply map (fn [x y] {x y}) coll)))","user":"5d9c1226e4b0d3f9b434ad51"},{"code":"#(apply merge (map (fn [x y] (hash-map x y)) %1 %2))","problem":61,"user":"5032b398e4b00c0952a257eb"},{"problem":61,"code":"(fn zm [ks vs]\n  (reduce #(assoc %1 (first %2) (second %2))\n          {} \n          (map vector ks vs)))","user":"5779556de4b0979f8965166e"},{"problem":61,"code":"(fn [l1 l2] (reduce (fn [m [k v]] (assoc m k v)) {} (map (fn [a b] [a b]) l1 l2)))","user":"5a2df4a0e4b09cafd31c7f74"},{"code":"(fn [x y] (into {} (map (fn [a b] [a b]) x y)))","problem":61,"user":"510967aae4b07c05fdf6dc0f"},{"code":"(fn [xs ys]\n  (loop [xs1 (seq xs)\n         ys1 (seq ys)\n         res {}]\n    (if (and (seq? xs1) (seq? ys1))\n      (recur (next xs1) (next ys1) (assoc res (first xs1) (first ys1)))\n      res)))","problem":61,"user":"50bc23e4e4b0594b91591c3c"},{"code":"#(apply merge (map hash-map % %2))","problem":61,"user":"4de77a0a535d08e6dec9fdfa"},{"code":"(fn [coll1 coll2]\n  (apply hash-map (flatten (map vector coll1 coll2))))","problem":61,"user":"4e7d4544535db169f9c796d0"},{"code":"(fn [keys vals]\n  (loop [m {}\n         ks (seq keys)\n         vs (seq vals)]\n    (if (and ks vs)\n      (recur (assoc m (first ks) (first vs)) (next ks) (next vs))\n      m)))","problem":61,"user":"5106bc8ae4b01150e115ebec"},{"code":"(fn [col1 col2]\n  (apply hash-map \n    (interleave col1 col2)))","problem":61,"user":"4e9ff8d0535d7eef3080729c"},{"code":"(fn [k v]\n  (loop [k k v v acc {}]\n    (if (or (empty? k) (empty? v))\n        acc\n        (recur (rest k) (rest v) (assoc acc (first k) (first v))))))","problem":61,"user":"4f9120d8e4b0dcca54ed6c96"},{"problem":61,"code":"(fn [ks vs]\n  (->> (interleave ks vs)\n  \t  (apply assoc {})))","user":"5512cd55e4b055c2f668d4ba"},{"problem":61,"code":"(fn\n    [lst1 lst2]\n    (apply hash-map (interleave lst1 lst2)))","user":"56eaad95e4b04a395b9a040f"},{"problem":61,"code":"(fn zm [k v]\n  (apply merge (map hash-map k v)))","user":"5703eda3e4b08d47c9778200"},{"problem":61,"code":"(fn [x y]\n  (apply assoc {} \n         (interleave x y)))","user":"591f5124e4b09b4ee5954c45"},{"problem":61,"code":"(fn [ks vals] (apply hash-map (interleave ks vals)))","user":"4f213e2ee4b0d66497709fcf"},{"problem":61,"code":"(fn make-kv-map\n  [keys values]\n  (loop [[k & ks] keys\n         [v & vs] values\n         accum {}]\n   (if (or (nil? ks) (nil? vs))\n       (assoc accum k v)\n       (recur ks vs (assoc accum k v)))))","user":"58152157e4b0f478707a0631"},{"code":"(fn [a, b] (reduce into (map (fn [x, y] {x y}) a b)))","problem":61,"user":"51365524e4b04ac1f358dd52"},{"problem":61,"code":"(fn [k v]\n  (apply merge (mapv #(hash-map (first %) (second %)) (partition 2 (interleave k v)))))","user":"5926c254e4b072a2710fceb8"},{"problem":61,"code":"(fn getMap [k v] (apply hash-map (interleave k v)))","user":"592518e8e4b072a2710fce67"},{"problem":61,"code":"(fn [k v]\n  (apply array-map (flatten (map list k v))))","user":"54bd9a60e4b0ed20f4ff6ee3"},{"problem":61,"code":"(fn [keys values]\n  (apply hash-map (apply concat (map list keys values))))","user":"58637f03e4b0f14aab7c881e"},{"code":"(fn [ks vs]\n   (apply hash-map (mapcat (fn [a b] [a b]) ks vs)))","problem":61,"user":"4e59b02c535d8a8b8723a2a2"},{"problem":61,"code":"(fn zipmap-\n  [a b]\n  (apply hash-map (interleave a b)))","user":"56084e91e4b046a4fc0ac00f"},{"code":"(fn [coll1 coll2] (into {} (map #(vector %1 %2) coll1 coll2)))","problem":61,"user":"4f98ead0e4b0dcca54ed6cf8"},{"problem":61,"code":"(fn [ks vs]\n  (loop [[fk & rks]ks \n         [fv & rvs]vs\n         res {}]\n    (if (or (empty? rks) (empty? rvs))\n      (conj res [fk fv]) \n      (recur rks rvs (conj res [fk fv])))))","user":"56646a7fe4b0e91d5f5c5657"},{"code":"#(loop [r {}, c (interleave %1 %2)]\n    (if (< (count c) 2)\n      r\n      (recur (conj r [(first c) (second c)]) (drop 2 c))))","problem":61,"user":"4ec6357a535d6d7199dd36c5"},{"code":"(fn zm [ks vs]\n  (loop [ms (map vector ks vs) m {}]\n    (if (seq ms)\n      (let [[[k v] & r] ms]\n        (recur r (assoc m k v)))\n      m)))","problem":61,"user":"4ee88269535d93acb0a6687f"},{"problem":61,"code":"(fn solution [k v]\n  (when (and (first k) (first v))\n    (conj {(first k) (first v)} (solution (rest k) (rest v)))))","user":"5ff5bc1ae4b06df49cee1490"},{"code":"(fn [c1 c2] (reduce merge {} (map #(assoc {} %1 %2) c1 c2)))","problem":61,"user":"524c7fcfe4b0752c4cb68cbd"},{"problem":61,"code":"(fn [m col1 col2]\n\n  (if (or (empty? col1) (empty? col2))\n\n     m\n\n     (recur (assoc m (first col1)(first col2)) (rest col1) (rest col2))))\n\n {}","user":"5794fd7be4b0e215f87e8476"},{"code":"(fn \n  [s1, s2]                                                                                             \n  (loop [zipped {} seq1 s1 seq2 s2]                                                                    \n    (if (and (not-empty seq1) (not-empty seq2))                                                        \n      (recur (conj zipped (hash-map (first seq1) (first seq2))) (rest seq1) (rest seq2))               \n      zipped)))","problem":61,"user":"4eaf1342535d7eef30807330"},{"code":"#(loop [keylist %1, vallist %2, m {}]\n   (if (or (empty? keylist) (empty? vallist))\n     m\n     (recur (rest keylist) (rest vallist) (conj m [(first keylist) (first vallist)]))))","problem":61,"user":"52d340ebe4b099d49816f0c1"},{"code":"(fn [& args](apply merge (apply map (fn [_1 _2] (hash-map _1 _2)) args)))","problem":61,"user":"5220909fe4b0e6a83c89259f"},{"problem":61,"code":"(fn [keys values] (reduce into {} (map #(hash-map %1 %2) keys values)))","user":"55205564e4b08d5046aa8a60"},{"code":"(fn my-mapzip [coll1 coll2]\n  (into {} (map vector coll1 coll2)))","problem":61,"user":"4dc54eb2535d8a4b2fd74284"},{"code":"#(apply merge (map (fn [ca cb] {ca cb})\n  %1 %2))","problem":61,"user":"4f3cd535e4b0e243712b1f56"},{"problem":61,"code":"#(reduce (fn [m [k v]] (assoc m k v)) {} (partition 2 (interleave %1 %2)))","user":"54f26266e4b024c67c0cf8c5"},{"code":"(fn [keys values]\n    (loop [[x & xs] keys [y & ys] values acc {}]\n      (if (or (empty? xs) (empty? ys))\n        (assoc acc x y)\n        (recur xs ys (assoc acc x y)))))","problem":61,"user":"4e9fd521535d7eef3080729a"},{"problem":61,"code":"(fn [keys values]\n  (into {}\n  (map (fn [k v] (vector k v)) keys values)))","user":"5ad99ddee4b0ea6055cfac3a"},{"problem":61,"code":"(fn [c1 c2] (apply merge (map (fn [a b] {a b}) c1 c2)))","user":"5d4f21f3e4b0776584bd6f4e"},{"problem":61,"code":"(fn [x y] (into {} (map #(vector % %2) x y)))","user":"56a44067e4b0542e1f8d14da"},{"code":"(fn hash [keys vals]\n  (if (or (empty? keys) (empty? vals))\n      {}\n      (conj (hash (rest keys) (rest vals)) [(first keys) (first vals)])))","problem":61,"user":"4f13047d535d64f60314642c"},{"problem":61,"code":"(fn [col1 col2]\n  (apply merge (map hash-map col1 col2)))","user":"5592ba8be4b0c79f6e1db931"},{"problem":61,"code":"(fn [k v]\n  (loop [k k v v out {}]\n  \t(if (or (empty? k) (empty? v))\n      out\n      (recur (rest k) (rest v) (assoc out (first k) (first v))))))","user":"551afdf8e4b07993ea3788cb"},{"code":"#(into {} (map vec (partition-all 2 (interleave %1 %2))))","problem":61,"user":"4e705861535d5021c1a89635"},{"problem":61,"code":"(comp #(into {} %) #(map vector %1 %2))","user":"521ed5b4e4b0e6c71e0c0bc0"},{"problem":61,"code":"(fn [a b]\n   (reduce #(conj %1 %2) {} (map #(hash-map %1 %2) a b)) )","user":"5f3f2281e4b004f08c61c561"},{"code":"(fn l [n nn] (loop [m n mm nn i (min (count n) (count nn)) e {}] (if (< i 1) e (recur (next m) (next mm) (dec i) (into e (assoc {} (first m) (first mm)))))))","problem":61,"user":"4fe97adde4b0547ebccb245e"},{"problem":61,"code":"(fn [ks vs] \n\t(reduce (fn [m i] (assoc m (get ks i) (get vs i))) \n    \t    {} \n        \t(range 0 (min (count ks) (count vs)))))","user":"5989e080e4b021a7a535fed6"},{"problem":61,"code":"(fn p\n  [lst lst2]\n\t(apply assoc{} (interleave lst lst2)))","user":"5723e6d6e4b0c5bde472c0f1"},{"problem":61,"code":"(fn [v1 v2] (into {} (filter val (reduce (fn [newM key] (conj newM (hash-map key (get v2 (.indexOf v1 key))))) {} v1))))","user":"5d662fb5e4b0db5d338d15e1"},{"code":"(fn foo [k v]\n  (if (or (empty? v) (empty? k)) nil\n    (conj {(first k) (first v)} (foo (rest k) (rest v)))\n    )\n  )","problem":61,"user":"4f8b27b3e4b02e764a0a5179"},{"code":"#(apply hash-map (mapcat (fn [p q] [p q]) %1 %2))","problem":61,"user":"4f426a7ae4b0d7d3c9f3fcff"},{"code":"(fn\n  [l1 l2]\n  (loop [map {}\n         x l1\n         y l2]\n    (if (and x y)\n      (recur (assoc map (first x) (first y))\n             (next x)\n             (next y))\n      map\n     )\n    ))","problem":61,"user":"50573ed8e4b0012181721987"},{"problem":61,"code":"(fn zipm\n  [ks vls]\n  (apply hash-map (interleave ks vls)))","user":"54c3747de4b045293a27f60e"},{"code":"(fn map-construction\n  [a b & coll]\n  (into {}  (map #(assoc {} %1 %2) a b)))","problem":61,"user":"4e3bcccd535deb9a81d77f56"},{"code":"(fn mapdef [x y]\n  (apply merge (map (fn [a b] {a b}) x y)))","problem":61,"user":"500cb910e4b05f7c30cfa698"},{"problem":61,"code":"(fn [c1 c2]\n  (apply merge (map\n   (fn [el1 el2]\n     {el1 el2})\n   c1 c2)))","user":"52d6d490e4b09f7907dd1369"},{"code":"(fn map-const [k v]\n  (apply hash-map (mapcat list k v)))","problem":61,"user":"5220bc0fe4b0e6a83c8925a7"},{"code":"(fn [keys values]\r\n  (loop [kr keys vr values e {}]\r\n    (let [k (first kr) v (first vr)]\r\n      (if (or (nil? k) (nil? v)) e\r\n        (recur (rest kr) (rest vr) (assoc e k v))))))","problem":61,"user":"4dee4a9c535d08e6dec9fe11"},{"code":"(fn [xs ys]\n  (into {} (map vector xs ys)))","problem":61,"user":"4e8338d6535db62dc21a62d3"},{"problem":61,"code":"(comp (partial into {})\n      (partial map vector))","user":"54d9f7f1e4b024c67c0cf751"},{"problem":61,"code":"(fn [xs ys]\n  (into {} (map #(vector %1 %2) xs ys))\n  )","user":"546a6c7ce4b00cfc9eacc154"},{"code":"(fn [s1 s2]\n  (loop [c1 s1, c2 s2, r {}]\n    (let [f1 (first c1), f2 (first c2)]\n      (if (and f1 f2)\n        (recur (rest c1) (rest c2)\n               (assoc r f1 f2))\n        r))))","problem":61,"user":"4e7e4d5c535db169f9c7970f"},{"problem":61,"code":"(fn [a b] (apply conj {} (map vector a b)))","user":"59c7c2cde4b0a024fb6ae54b"},{"code":"(fn f [a b]\n  (if-let [[k & ks] (seq a)]\n    (if-let [[v & vs] (seq b)]\n      (conj (f ks vs) [k v])\n      {})\n    {}))","problem":61,"user":"504ffb8fe4b0a02f9cffdeae"},{"code":"(fn my-zipmap \n([s t] (my-zipmap s t {}))\n([s t r] (cond (or (empty? s)  (empty? t)) r\n               :default (my-zipmap (rest s) (rest t) \n\t       \t\t  (assoc r (first s) (first t))))))","problem":61,"user":"4f9c4080e4b0dcca54ed6d1a"},{"problem":61,"code":"(fn f [kcoll vcoll] (when-let [ks (seq kcoll)]\n                      (when-let [vs (seq vcoll)]\n                        (assoc (f (rest ks) (rest vs)) (first ks) (first vs)))))","user":"5d629ed9e4b0c9e5857d501d"},{"problem":61,"code":"(fn [ks vs]\n  (reduce (fn [m [k v]] (assoc m k v))\n          {}\n          (map vector ks vs)))","user":"546ed28be4b00cfc9eacc1a5"},{"problem":61,"code":"(fn [K V]\n  (loop [k K v V r {}]\n    (if (or (empty? k) (empty? v)) r (recur (rest k) (rest v) (assoc r (first k) (first v))))))","user":"5f574662e4b0a0bc16850a90"},{"problem":61,"code":"(fn sk-zip-map [l r]\n  (into {} (map #(vector %1 %2) l r)))","user":"51d42f44e4b013d740b70ddb"},{"problem":61,"code":"(fn [coll1 coll2]\n  (apply hash-map (flatten (map list coll1 coll2))))","user":"5e724492e4b085ba37836dc7"},{"code":"(fn\n[keys vals] (reduce #(merge % %2) {} (map #(hash-map % %2) keys vals)))","problem":61,"user":"4f047542535dcb61093f6bc7"},{"code":"#(apply assoc (cons {}(mapcat list % %2)))","problem":61,"user":"4fb23582e4b081705acca28a"},{"problem":61,"code":"(fn\n  [k v]\n  (reduce into {} (map #( hash-map %1 %2 ) k v)))","user":"56019662e4b04bb52996e190"},{"problem":61,"code":"(fn [a b]\n  (reduce #(assoc-in %1 [(first %2)] (second %2))\n          {}\n          (partition 2 (interleave a b))))","user":"56b18445e4b0982f16b37dee"},{"problem":61,"code":"#(loop [k % v %2 res {}]\n   (if (or (empty? k) (empty? v))\n     res\n     (recur (rest k) (rest v) (conj res {(first k) (first v)}))))","user":"5964c614e4b069c0a1a19770"},{"problem":61,"code":"(fn f ([left right] (f left right {}))\n([left right result] \n\t(if (some empty?  [left right])\n\t\tresult\n\t\t(recur (rest left) (rest right) (conj {(first left) (first right)} result))\n\t)\n\t)\n)","user":"57c99a45e4b05aa3c4741d31"},{"code":"(fn [a b]\n  (apply merge\n    (map \n      #(hash-map %1 %2)\n      a\n      b\n    )\n  )\n)","problem":61,"user":"4f8ea1f7e4b0d4e659cdde69"},{"problem":61,"code":"(fn [col1 col2] (reduce #(assoc %1 (first %2) (last %2)) {} (partition 2 (interleave col1 col2))))","user":"56800ba1e4b0966858e4d8e8"},{"problem":61,"code":"(fn myzipmap [keys values] \n  (->> (map #(vector %1 %2) keys values)\n      (into {}))\n  )","user":"5fee18f2e4b05ac5b16ea1d2"},{"code":"(fn zip-map\n  ([keys values] (zip-map keys values {}))\n  ([keys values map]\n    \n(cond\n  (or (empty? keys) (empty? values)) map\n  :else (let\n    [key (first keys) val (first values)\n     nkeys (rest keys) nvals (rest values) ]\n\n(zip-map nkeys nvals (assoc map key val))))))","problem":61,"user":"4e356d2b535deb9a81d77f2d"},{"problem":61,"code":"(fn [ks vs]\n  (apply hash-map (apply concat (map #(vector % %2) ks vs))))","user":"57008afae4b08d47c97781ca"},{"problem":61,"code":"(fn f61 [k v]\n  (apply array-map (interleave k v))\n\n  )","user":"526698c9e4b03e8d9a4a7144"},{"problem":61,"code":"(fn [keys vals]\n                  (loop [map {}\n                         ks (seq keys)\n                         vs (seq vals)]\n                    (if (and ks vs)\n                      (recur (assoc map (first ks) (first vs))\n                             (next ks)\n                             (next vs))\n                      map)))","user":"5d9c9446e4b0eb781811cdae"},{"code":"(fn [coll1 coll2] (into {} (map vector coll1 coll2)))","problem":61,"user":"52d9aaa1e4b09f7907dd13ae"},{"problem":61,"code":"(fn [k v]\n  (apply merge (map #(hash-map %1 %2) k v)))","user":"5ec3cdf7e4b08d0ec38692bc"},{"problem":61,"code":"( fn [k v]   (apply hash-map (interleave k v )))","user":"5ddbd202e4b0948ae9d9adb4"},{"code":"(fn zippy \n  ([keys vals] (zippy (assoc {} (first keys) (first vals)) (rest keys) (rest vals)))\n  ([res keys vals] (if (or (empty? keys) (empty? vals)) res (recur (assoc res (first keys) (first vals)) (rest keys) (rest vals)))))","problem":61,"user":"4fa39b3ee4b081705acca191"},{"problem":61,"code":"#(loop [ks %1 vs %2 result {}]\n   (if (or (empty? ks) (empty? vs))\n     result\n     (recur (rest ks) (rest vs) (assoc result (first ks) (first vs)))))","user":"55e2f502e4b050e68259b43c"},{"problem":61,"code":"(fn [c1 c2]\n  (loop [keys c1\n         vals c2\n         result {}]\n    (if (or (empty? vals) (empty? keys))\n      result\n      (recur (rest keys)\n             (rest vals)\n             (assoc result (first keys) (first vals))))))","user":"5484143de4b0e286459a1197"},{"problem":61,"code":"(fn [ks vs]\n  (loop [[x & xs] ks [y & ys] vs result {}]\n    (if (or (nil? x) (nil? y)) result\n      (recur xs ys (assoc result x y)))))","user":"546176e7e4b01be26fd746a2"},{"code":"#(->> (map vector % %2) (into {}))","problem":61,"user":"4ed845a8535d10e5ff6f52f8"},{"problem":61,"code":"(fn sk-to-map [keys values]\n  (apply array-map (interleave keys values)))","user":"5884f377e4b0f1effa3b76a8"},{"problem":61,"code":"(fn\n  [keys values]\n  (apply hash-map (interleave keys values)))","user":"5aa2f1dee4b0d174b936c865"},{"problem":61,"code":"#(into (sorted-map) (vec (map vec (partition 2 (interleave %1 %2)))))","user":"5589e88ae4b0277789237610"},{"problem":61,"code":"(fn my-zipmap [keys-p vals-p]\n  (apply hash-map (interleave keys-p vals-p)))","user":"58a953dae4b01a0c0b232968"},{"problem":61,"code":"(fn [keys vals] (loop [map {}\n                        ks (seq keys)\n                        vs (seq vals)]\n                   (if (and ks vs)\n                     (recur (assoc map (first ks) (first vs))\n                            (next ks)\n                            (next vs))\n                     map)))","user":"57a6552ce4b0a96607956208"},{"code":"(fn [a b] (apply assoc {} (mapcat (fn [x y] [x y]) a b)))","problem":61,"user":"4eccb190535d23f0362276fe"},{"code":"(fn [coll1 coll2]\n  (loop [c1 coll1, c2 coll2, acc {}]\n    (if (or (empty? c1) (empty? c2))\n      acc\n      (recur (rest c1) (rest c2) (assoc acc (first c1) (first c2))))))","problem":61,"user":"50a83794e4b054305ba5a831"},{"problem":61,"code":"(fn [a b]\n  (let [n (apply min (map count [a b]))]\n    (reduce\n     #(assoc %1 (a %2) (b %2))\n     {}\n     (range n))))","user":"57395f32e4b0cd1946bd1070"},{"problem":61,"code":"(fn [keys values]\n  (loop [r {} x keys y values]\n    (let [k (first x) v (first y)]\n      (if-not (and k v)\n        r\n        (recur (assoc r k v)\n               (next x)\n               (next y))))))","user":"54b331dbe4b09f271ff37d37"},{"code":"#(into {} (map (fn [a b] [a b]) %1 %2))","problem":61,"user":"4f8c5f4fe4b02e764a0a5198"},{"problem":61,"code":"(fn [xs ys]\n\t(reduce #(into %1 %2) {} (map #(hash-map %1 %2) xs ys)))","user":"5da7176ae4b000c986472c13"},{"problem":61,"code":"(fn [ks vs]\n    (into {} (map #(vector %1 %2) ks vs)))","user":"54508859e4b0e397800069a3"},{"problem":61,"code":"(fn [k v] (into {} (map (fn [x y] [x y]) k v)))","user":"5c3f37fce4b08cd430848e91"},{"code":"#(loop [i 0 result nil]\n    (if (or (= i (count %1)) (= i (count %2)))\n      result\n    (recur (inc i) (assoc result (nth %1 i) (nth %2 i) ))\n   ))","problem":61,"user":"4ea31da2535d7eef308072c1"},{"problem":61,"code":"(fn [x y] (->> (map list x y) (reduce (fn [acc [a b]] (conj acc {a b})) {})))","user":"5901158de4b0438e51c2d039"},{"code":"(fn [k v] (loop [map {} ks (seq k) vs (seq v)] (if (and ks vs) (recur (assoc map (first ks) (first vs)) (next ks) (next vs)) map)))","problem":61,"user":"5243d9a2e4b076204b44fadf"},{"code":"(fn [k v]\r\n  (loop [k k\r\n         v v\r\n         z {}]\r\n    (if (or (empty? k) (empty? v))\r\n      z\r\n      (recur (rest k) (rest v) (conj z {(first k) (first v)})))))","problem":61,"user":"504e2333e4b0f6ff3350c46c"},{"problem":61,"code":"(fn [k v] (reduce #(into %1 %2) {} (map #(assoc {} %1 %2) k v)))","user":"56743413e4b05957ce8c612e"},{"problem":61,"code":"(fn map-construct\n  [lst1 lst2]\n  (apply hash-map (interleave lst1 lst2)))","user":"59e68254e4b0249b728206fc"},{"problem":61,"code":"(fn [xs ys]\n  (reduce (fn [m i] (assoc m (nth xs i) (nth ys i)))\n          {}\n          (range (min (count xs)\n                      (count ys)))))","user":"5136f659e4b04059df19f2fd"},{"code":"(fn zi\n   ([k v]\n       (loop [ke (seq k) va (seq v) map {}]\n          (if (and ke va)\n               (recur (next ke) (next va) (assoc map (first ke) (first va)))\n               map)\n        )))","problem":61,"user":"51d28e15e4b0d13b04db0d9b"},{"code":"(fn mine [xs ys]\n  (if (or (empty? xs) (empty? ys))\n      {}\n      (assoc (mine (rest xs) (rest ys)) \n             (first xs) \n             (first ys))))","problem":61,"user":"4dad8d4bc9a9d6ed1799dc57"},{"problem":61,"code":"(fn myF [xs ys] (into {}(map vector xs ys)))","user":"56eff7c1e4b04a395b9a0468"},{"code":"(fn [c1 c2] (reduce (fn [m [k v]] (assoc m k v)) {} (map (fn [a b] [a b]) c1 c2)))","problem":61,"user":"4f3ec266e4b0e243712b1f8c"},{"problem":61,"code":"(fn [col1 col2] (apply hash-map (interleave col1 col2)))","user":"5790e62ae4b0ebec4cfb75b0"},{"problem":61,"code":"(fn my-zip\n  [xs ys]\n  (apply hash-map (flatten (map #(list %1 %2) xs ys))))","user":"568bd448e4b0dcc4269f40a9"},{"code":"(fn [x y]\n  (apply hash-map (interleave x y)))","problem":61,"user":"4e28120f535deb9a81d77efa"},{"code":"( fn [k v] (loop [ktmp k vtmp v acc {}] (if (or (empty? ktmp) (empty? vtmp)) acc \n                                          (recur (rest ktmp) (rest vtmp) (assoc acc (first ktmp) (first vtmp))))))","problem":61,"user":"5301157ae4b0d8b024fd3717"},{"code":"(fn my-zipmap [ks vs]\n  (apply hash-map (interleave ks vs))\n)","problem":61,"user":"50e496e8e4b0cb9ec68fbca0"},{"problem":61,"code":"(comp (partial apply assoc {}) interleave)","user":"5392bfdee4b0b51d73faaeb2"},{"code":"#(apply merge (apply map hash-map %&))","problem":61,"user":"4f9aa97ae4b0dcca54ed6d0e"},{"problem":61,"code":"#(reduce \n  (fn [d, s] (conj d [ (first s) (second s) ] )) \n  {} \n  (partition 2 (interleave % %2))\n  )","user":"54a1d643e4b09f271ff37c50"},{"code":"(fn f [a b]\n  (into {}\n        (map #(vector % %2) a b)))","problem":61,"user":"51750cd4e4b07031762f2ee5"},{"problem":61,"code":"(fn [ks' vs']\n  (letfn [(go [ks vs]\n            (if (or (empty? ks) (empty? vs))\n              {}\n              (merge {(first ks) (first vs)}\n                     (go (rest ks) (rest vs)))))]\n    (go ks' vs')))","user":"53ef7f77e4b0742d9025b0ce"},{"code":"(fn  [a b]\n  (let [min (min (count  a) (count b))]\n    (loop [x (take min a)\n           y (take min b)\n           res {}]\n      (if (empty? x)\n         res\n        (recur (rest x) (rest y) (assoc res (first  x) (first  y))))     \n      )))","problem":61,"user":"4fea1f9ee4b0547ebccb248b"},{"problem":61,"code":"(fn [as bs]\n(into {} (map vector as bs)))","user":"5ebff55de4b00a66d4a95286"},{"code":"(fn [x y]\n  (apply hash-map (flatten (map vector x y))))","problem":61,"user":"4ec5cdb0535d6d7199dd36b8"},{"code":"(fn [k v] (apply hash-map (flatten (map vector k v))))","problem":61,"user":"4f03d0fe535dcb61093f6b6d"},{"problem":61,"code":"(fn [ks vs]\n  (apply hash-map\n         (interleave ks vs)))","user":"54cc26c1e4b057c6fda3a28a"},{"problem":61,"code":"(fn g [k v] (if (and k v) (conj (g (next k) (next v)) {(first k) (first v)}) {}))","user":"4e41a04e535dc968683fc49e"},{"problem":61,"code":"(fn [keys vals]\n  (loop [k keys v vals m {}]\n    (if (or (empty? k)(empty? v)) m\n      (recur (rest k) (rest v) (assoc m (first k) (first v))))))","user":"554dff83e4b00713264bd98d"},{"problem":61,"code":"(fn[x y]\n  (into {} (map vector x y)))","user":"5f77890ae4b02876ed9fd0b9"},{"problem":61,"code":"(fn [a b]\n(apply merge (map #(hash-map %1 %2) a b))\n   )","user":"554b2151e4b0a04f79299580"},{"problem":61,"code":"(fn [x y]\n  (loop [x x\n         y y\n         m {}]\n    (if (and (not-empty x) (not-empty y))\n      (recur (rest x) (rest y) (assoc m (first x) (first y)))\n      m)))","user":"56491d05e4b0284900eef63a"},{"code":"#(into {} (map vec (partition 2 (interleave % %2))))","problem":61,"user":"4e9c3648535dbda64a6f6b7d"},{"code":"(fn [xs1 xs2]\n    (loop [r {} x1 xs1 x2 xs2]\n      (if (or (empty? x1) (empty? x2))\n        r\n        (recur (conj r {(first x1) (first x2)}) (next x1) (next x2)))))","problem":61,"user":"50aedb8ce4b0a40c9cfb08d4"},{"problem":61,"code":"(  fn[keys vals] (loop [map {}\n           ks (seq keys)\n           vs (seq vals)]\n      (if (and ks vs)\n        (recur (assoc map (first ks) (first vs))\n               (next ks)\n               (next vs))\n        map)))","user":"57c6bca1e4b05aa3c4741cf8"},{"code":"(fn [v1 v2]\n  (reduce into {}\n     (map #(assoc {} %1 %2) v1 v2)))","problem":61,"user":"4f91f5b1e4b0dcca54ed6ca7"},{"problem":61,"code":"(fn [col1 col2]\n   (into {} (map hash-map col1 col2)))","user":"54094824e4b0addc1aec66da"},{"problem":61,"code":"(fn [v1 v2]\n   (loop [res {}, remv1 v1, remv2 v2]\n     (if (or (empty? remv1) (empty? remv2)) \n       res\n       (recur (assoc res (first remv1) (first remv2)) (rest remv1) (rest remv2)))))","user":"590b3aeae4b047aa04b199d0"},{"problem":61,"code":"(fn zi [x y]\n  (apply hash-map (interleave x y)))","user":"5d6febe6e4b04d129b00f2d5"},{"problem":61,"code":"(fn [value1 value2]\n  (apply hash-map (interleave value1 value2)))","user":"60504383e4b056659d6341fa"},{"code":"(fn [k v] (reduce #(conj %1 %2) {}  (reverse (map #(identity  {%1 %2}) k v))))","problem":61,"user":"52593207e4b0cb4875a45cd3"},{"code":"(fn [f s] (into {} (map vector f s)))","problem":61,"user":"51e3a549e4b0c611d6113e47"},{"code":"(fn fx [k v]\n  (loop [m {}, k k, v v]\n    (if (and k v)\n      (recur\n        (assoc m (first k) (first v))\n        (next k)\n        (next v))\n      m)))","problem":61,"user":"4e4ad154535dc968683fc4d1"},{"code":"(fn [kws vls]\n  (apply hash-map (interleave kws vls)))","problem":61,"user":"52381b2ae4b0fae3832e99ef"},{"problem":61,"code":"(fn map-construction2 [x y]\n  (apply hash-map (interleave x y)))","user":"574ed2f7e4b02ea11479924a"},{"code":"(fn zpmp [ks vs]\n  (reduce #(assoc % (first %2) (second %2)) {} (map vector ks vs)))","problem":61,"user":"539a2901e4b0b51d73faaf0f"},{"code":"(fn [xs ys] (reduce (fn [acc [x y]] (assoc acc x y)) {} (map vector xs ys)))","problem":61,"user":"5213d7aae4b0961f15ac4d72"},{"code":"(fn my_zipmap [k v]\n  (if (or (empty? k) (empty? v))\n    {}\n    (conj \n      {(first k) (first v)} \n      (my_zipmap (rest k) (rest v)))))","problem":61,"user":"50013694e4b0678c553fc417"},{"problem":61,"code":"(fn q61 [keys vals]\n  (->> (map-indexed (fn [i k] [k (nth vals i nil)]) keys)\n       (reduce (fn [m [k v]]\n                 (if (nil? v) m (assoc m k v))) {})))","user":"5cab0ad9e4b048ec896c5c46"},{"problem":61,"code":";(fn [ks vs]\n;    (apply hash-map (mapcat #(list %1 %2) ks vs)))\n(fn m [x y]\n  (cond (or (empty? x) (empty? y)) '{}\n        :else\n        (assoc (m (rest x) (rest y)) (first x) (first y))))","user":"56cba075e4b0ea9b8538f737"},{"problem":61,"code":";;; tenemos que poner 1 y 1 basicamente \n;;; había una función que hacía eso   ---> interleave creo \n;;; recibimos dos sets y se pasan a hash-map\n(fn [ki elem]\n  (apply hash-map (interleave ki elem)))\n\n\n;;; apply ¿Que cosa? luego el mezclador ()","user":"6075c214e4b069485764de5b"},{"code":"#(apply hash-map (flatten (map (fn [a b] [a b]) %1 %2)))","problem":61,"user":"51891c96e4b04c2714a2670e"},{"problem":61,"code":"(fn zipm [xs ys]\n  (if (or (empty? xs) (empty? ys))\n    '{}\n    (assoc (zipm (rest xs) (rest ys)) (first xs) (first ys))))","user":"58cf00c8e4b03c36ff7e58ac"},{"problem":61,"code":"(fn [ks vs] (apply (partial assoc {}) (interleave ks vs)))","user":"54ca93abe4b057c6fda3a264"},{"problem":61,"code":"(fn [ks vs]\n  (into '{} (map #(vector %1 %2)  ks vs)))","user":"6086abade4b0736b099e42ff"},{"problem":61,"code":"(fn zipmap* [& colls]\n  (reduce (fn [acc [k v]] (assoc acc k v)) {} (apply map list colls)))","user":"5c987160e4b048ec896c5a82"},{"problem":61,"code":"#(reduce merge (map (fn [n c] {n c}) %1 %2))","user":"57210e8ee4b0c5bde472c0a8"},{"problem":61,"code":"(fn sds\n  ([fl sl]\n   (sds fl sl {}))\n  ([fl sl final]\n  (if (or (empty? fl) (empty? sl))\n    final\n    (sds (rest fl) (rest sl) (assoc final (first fl) (first sl))))))","user":"5d4cf3e9e4b0776584bd6f38"},{"problem":61,"code":"(fn ans-61 [arr1 arr2]\n  (apply hash-map\n         (interleave arr1 arr2)))","user":"608fac60e4b03bd49d9f36c7"},{"code":"(fn [ks vs]\n  (apply hash-map\n    (mapcat\n      vector\n      ks vs)))","problem":61,"user":"50427899e4b0add3005c0fc2"},{"problem":61,"code":"(fn [coll1 coll2]\n  (apply sorted-map (interleave coll1 coll2)))","user":"56826ebce4b0945ebc182a93"},{"code":"(fn tomap [ks vs]\n  (cond\n   (empty? ks) {}\n   (empty? vs) {}\n   :else (conj (tomap (rest ks) (rest vs)) {(first ks) (first vs)})\n   )\n  )","problem":61,"user":"5252cbe7e4b0541d1855b8d2"},{"code":"(fn myzipmap [coll1 coll2]\r\n  (let [coll (partition 2 (interleave coll1 coll2))]\r\n    (loop [result {} coll coll]\r\n      (if (empty? coll)\r\n        result\r\n        (recur (assoc result (first (first coll)) (second (first coll)))\r\n          (rest coll))))))","problem":61,"user":"4fd170fce4b04c3a95aa0411"},{"problem":61,"code":"(fn my-zipmap [keys values]\n  (reduce #(assoc %, (first %2), (second %2))\n          {}\n          (map list keys values)))","user":"569dd6e8e4b0542e1f8d1480"},{"problem":61,"code":"(fn [s1 s2] (reduce (fn [acc it] (if (< (count acc) (count s2)) (assoc acc it (nth s2 (count acc))) acc)) {} s1))","user":"5cbdc591e4b026601754ba00"},{"code":"(fn [col1 col2]\n  (reduce #(assoc %1 (first %2) (second %2) ) {} (map vector col1 col2)))","problem":61,"user":"4fd7962ee4b0dab7d829f385"},{"problem":61,"code":"(fn [ks vs]\n  (reduce merge (map #(hash-map %1 %2) ks vs)))","user":"4fdb881ee4b05e33b9224f5e"},{"problem":61,"code":"#(loop [i 0 arr1 %1 arr2 %2 hash {}]\n         (if (and (< i (count arr1)) (< i (count arr2)) )\n           (recur (+ i 1) arr1 arr2 (conj hash {(arr1 i) (arr2 i)}))\n           hash\n           )\n         )","user":"5eee9352e4b07c55ae4a0512"},{"problem":61,"code":"(fn f [x y]\n  (->> (map #(hash-map %1 %2) x y)\n       (into (sorted-map))\n       ))","user":"6022429be4b0d5df2af22200"},{"problem":61,"code":"(fn [a b] (apply merge (map #(hash-map %1 %2) a b)))","user":"5367bc60e4b0243289761e81"},{"problem":61,"code":"(fn   [lst lst20]\n  (loop [lst1  lst\n         lst2 lst20\n         mapa  {}]\n    (if (<(count lst) (count lst20))\n      (if (zero? (count lst1))\n        mapa\n        (recur (rest lst1)\n               (rest lst2)\n               (assoc mapa (first lst1)(first lst2))))\n      (if (zero? (count lst2))\n        mapa\n        (recur (rest lst1)\n               (rest lst2)\n               (assoc mapa (first lst1)(first lst2)))))))","user":"59deba46e4b01968742fed7f"},{"problem":61,"code":"(fn [%1 %2]\n  (loop [ks (seq %1)\n         vs (seq %2)\n         r {}]\n    (if (and (not (empty? ks)) (not (empty? vs)))\n      (recur (rest ks) (rest vs) (assoc r (first ks) (first vs)))\n      r)))","user":"5fb3a096e4b08cb800c85b35"},{"code":"(fn [k v]\n (apply hash-map (interleave k v)))","problem":61,"user":"4f072644535dcb61093f6c20"},{"problem":61,"code":"(fn [keys_ values] (apply hash-map (mapcat (fn [& rest] rest) keys_ values)))","user":"59d4d126e4b0ef0a1e9b5be9"},{"problem":61,"code":"(fn\n  [a b]\n  (apply merge (map #(identity {%1 %2}) a b)))","user":"5673881fe4b05957ce8c6120"},{"problem":61,"code":"(fn \n  [k v]\n  (loop [x k\n         y v\n         m (hash-map)]\n    (cond\n      (empty? x) m\n      (empty? y) m\n      :else (recur (rest x) (rest y)\n                   (assoc m (first x) (first y))))))","user":"5599abc9e4b031d6649c9bb0"},{"code":"(fn crtMap [keysv valsv]\n  (reduce\n    #(assoc %1 (first %2) (second %2))\n    {}\n    (map\n      #(vector %1 %2)\n      keysv\n      valsv)))","problem":61,"user":"526ee63de4b03e8d9a4a733f"},{"problem":61,"code":"(fn ->map [key-coll val-coll]\n   (into {} (map vector key-coll val-coll)))","user":"5ef8e9e0e4b09b61f08553cb"},{"code":"#(reduce (fn[x y] (merge x y)) (map (fn[x y] {x y}) %1 %2))","problem":61,"user":"536c77f1e4b0fc7073fd6e3f"},{"problem":61,"code":"(fn [x y] (into {} (vec (map vector x y))))","user":"5be6d0f8e4b0f319e2d7ec51"},{"code":"(fn [k v]\n  (reduce \n   #(conj % (vec %2))\n   {}\n   (partition 2 (interleave k v))))","problem":61,"user":"52039e12e4b0fb7e47ea51ff"},{"problem":61,"code":"(fn [x y] (into {} (mapv (fn [a b] [ a b] ) x y )))","user":"528b3f5ae4b0239c8a67ae93"},{"problem":61,"code":"(fn [x c] (apply hash-map (interleave x c)))","user":"58a0fd0be4b02bd94d917ea4"},{"code":"#(reduce (fn [acc [k v]]\r\n      (assoc acc k  v))\r\n\t  {}\r\n\t  (map vector % %2))","problem":61,"user":"4dd6d7ee535d2dad7130b5cb"},{"problem":61,"code":"(fn [ks vs]\n  (loop [result {}\n         ks ks\n         vs vs]\n    (if (or (zero? (count ks)) (zero? (count vs)))\n      result\n      (recur (assoc result (first ks) (first vs)) (rest ks) (rest vs))\n    )\n  )\n)","user":"53a36fd7e4b0f1fc74538834"},{"code":"(fn [ks vs] (reduce #(assoc % (first %2) (second %2)) {} (map #(list % %2) ks vs)))","problem":61,"user":"50dfb660e4b061dbdced7228"},{"problem":61,"code":"(fn a [s1 s2]\n\t(apply assoc {} (interleave s1 s2)))","user":"5fe09d1fe4b05ac5b16ea15b"},{"problem":61,"code":"(fn makemap[keys values]\n  (reduce conj {} (map vector keys values )))","user":"5e078ba7e4b0978307768fb6"},{"problem":61,"code":"#(->> (interleave %1 %2)\n      (cons {})\n      (apply assoc))","user":"5d2e5065e4b01671435dbcae"},{"problem":61,"code":"(fn [lk lv]\n  (loop\n    [lik lk liv lv le {}]\n    (if (or (empty? lik) (empty? liv))\n      le\n      (recur (rest lik) (rest liv) (conj le [(first lik) (first liv)])))))","user":"52979551e4b02ebb4ef75043"},{"problem":61,"code":"(fn func [keys vals]\n  (into {} (map (fn [k v] [k v]) keys vals)))","user":"5e805895e4b085ba37836e44"},{"problem":61,"code":"(fn  [coll1 coll2] \n  (loop [c1 coll1 c2 coll2  acc {}]\n    (if (or (empty? c1)  (empty? c2)) acc\n      (recur (rest c1) (rest c2) (assoc acc (first c1) (first c2))))))","user":"4e526cc4535d302ef430da74"},{"code":"(fn [col1 col2]\n  (into {} (map #(vec [%1 %2]) col1 col2)))","problem":61,"user":"4db2cc55535df7e46ed9b6c5"},{"code":"(fn [keys vals]\n  (into {} (map #(vector %1 %2) keys vals)))","problem":61,"user":"4e5fdd68535d8ccf87e9fe4f"},{"problem":61,"code":"#(reduce conj (map (fn [k v] {k v}) %1 %2))","user":"51647faae4b003cf19fdde3b"},{"code":"(fn [keys vals]\n  (loop [result {}, k keys, v vals]\n    (if\n      (or (empty? k) (empty? v))\n      result\n      (recur\n        (assoc result (first k) (first v))\n        (rest k)\n        (rest v)))))","problem":61,"user":"4f5c0549e4b0030a34fb2b1a"},{"problem":61,"code":"(fn [c1 c2] \n  (loop [c (interleave c1 c2) res {}]\n    (if (empty? c)\n      res\n      (recur (drop 2 c) (assoc res (first c) (second c))))))","user":"557f7c8be4b05c286339e0e0"},{"code":"(fn zipmap'\n    ([keys values] (zipmap' keys values {}))\n    ([keys values acc]\n     (if (or (empty? keys) (empty? values))\n       acc\n       (recur (rest keys) (rest values)\n              (conj acc [(first keys) (first values)])))))","problem":61,"user":"508157b2e4b0946d0443855c"},{"problem":61,"code":"(fn [s1 s2]\n  (apply assoc {} (interleave s1 s2)))","user":"5a291617e4b07f18be40aa76"},{"problem":61,"code":"(fn [k v]\n  (loop [out {} kys k vls v]\n    (if (and (> (count kys) 0) (> (count vls) 0))\n      (recur (assoc out (first kys) (first vls)) (rest kys) (rest vls))\n      out)))","user":"4daeff24edd6309eace4d16e"},{"code":"(fn zm [a b]\n  (apply hash-map (interleave a b)))","problem":61,"user":"4ff201d7e4b0678c553fc330"},{"problem":61,"code":"(fn [k v]\n  (apply assoc {}\n         (interleave k v)))","user":"53065acbe4b02e8216869792"},{"problem":61,"code":"#(let [x %1 y %2]\n   (loop [m {} b 0]\n    (if (>= b (min (count x) (count y)))\n        m\n        (recur (assoc m (nth x b) (nth y b)) (inc b)))))","user":"57ecc16fe4b0bfb2137f5b83"},{"code":"(fn mymapcons [k v]\r\n    (apply assoc {}\r\n     (apply concat (map #(list %1 %2) k v))))","problem":61,"user":"4e1b2cd9535d04ed9115e7fd"},{"problem":61,"code":"(fn [k v] (reduce #(assoc % (first %2) (second %2)) {} (map vector k v)))","user":"569f4dabe4b0542e1f8d1491"},{"problem":61,"code":"(fn zip-map [ks vs] (into {} (map vector ks vs)))","user":"505fdf63e4b08f2a82ad10b9"},{"code":"#(apply sorted-map (interleave % %2))","problem":61,"user":"4e6e2ac4535d5021c1a895ff"},{"problem":61,"code":"(fn a61[ks vs] (into {} (map vector ks vs)))","user":"56163cc1e4b06b1bb21829ff"},{"problem":61,"code":"(fn tomap [keyv valv]\n  (loop [[k & ks] keyv\n         [v & vs] valv\n         res {}]\n    (if (or (nil? k)\n            (nil? v))\n      res\n      (recur ks vs (assoc res k v)))))","user":"587fb546e4b0f1effa3b75f9"},{"code":"(fn zm [ks, vs]\n  (if (= 1 (min (count ks) (count vs)))\n    {(first ks) (first vs)}\n    (assoc (zm (rest ks) (rest vs)) (first ks) (first vs))))","problem":61,"user":"4e8b98fc535d65386fec2124"},{"code":"(fn [k v]\n  (loop [ks k\n         vs v\n         m {}]\n    (let [ak (first ks)\n          av (first vs)]\n      (if (and ak av)\n        (recur (rest ks) (rest vs) (assoc m ak av))\n        m))))","problem":61,"user":"51899891e4b0288ada3dbdab"},{"code":"(fn mapper [keys values]\n  (cond \n    (or (empty? keys) (empty? values)) {}\n    :else (conj (mapper (rest keys) (rest values)) (hash-map (first keys) (first values)) )\n  )\n  )","problem":61,"user":"4ecfa05c535d44c135fd68b9"},{"problem":61,"code":"#(into {}(map hash-map %1 %2))","user":"57752a2de4b0979f89651613"},{"code":"(fn [a b] (into {} (map #(vector %1 %2) a b)))","problem":61,"user":"4f68c485e4b07046d9f4ef7c"},{"problem":61,"code":"(fn do-zipmap [ks vs]\n  (apply hash-map (interleave ks vs)))","user":"60777335e4b0a637ed78034f"},{"problem":61,"code":"(fn [col1 col2]\n    (let [f (fn [c1 c2] {c1 c2})]\n      (into {} (map f col1 col2))))","user":"59932f49e4b0b211ea3aaaae"},{"problem":61,"code":"(fn [k v]\r\n  (apply hash-map (take (* 2 (count k)) (interleave k v))))","user":"5dbd51cfe4b09f47823971bb"},{"problem":61,"code":"(fn to-map [to-key to-value]\n  (let [len-to-key (count to-key)\n        len-to-value (count to-value)\n        min-len (min len-to-key len-to-value)\n        key-value (for [i (range min-len)]\n                    [(nth to-key i) (nth to-value i)])\n        flat-key-value (flatten key-value)]\n    (apply hash-map flat-key-value)))","user":"524b827ce4b09eba1c0223d7"},{"problem":61,"code":"(fn [a b]\n  (into {} (map vector a b))\n  )","user":"52dc7344e4b09f7907dd13cf"},{"problem":61,"code":"(fn [k v] \n      (loop [ke k, values v, acc {}]\n        (if (and (not-empty ke) (not-empty values))\n          (recur (rest ke) (rest values) (assoc acc (first ke) (first values)))\n          acc\n        )\n      )\n   )","user":"52149e21e4b0961f15ac4d94"},{"problem":61,"code":"(fn [keycoll valcoll] (into {} (map vector keycoll valcoll)))","user":"54a6baaee4b09f271ff37c8a"},{"problem":61,"code":"(fn foozip [keys vals]\n  (apply hash-map\n    (mapcat\n      (fn [a b] (list a b))\n      keys vals)))","user":"56fc0601e4b07572ad1a88db"},{"code":"#(into {} (for[i (range 0 (min (count %) (count %2)))](hash-map (nth % i) (nth %2 i))))","problem":61,"user":"5138d08be4b0a5db03d727db"},{"problem":61,"code":"#(reduce (fn [acc e] (into acc {(first e) (second e)})) {} (map vector %1 %2))","user":"5897dda4e4b00487982d52c8"},{"problem":61,"code":"#(into {}\n        (map (fn [f s]\n               (hash-map f s)) %1 %2))","user":"5ab23c99e4b073f1774425e2"},{"problem":61,"code":"(fn zm [kl vl]\n  (->>\n    (map-indexed (fn [i k]\n                   (when-let [v (get vl i)]\n                     {k v}))\n                 kl)\n    (apply merge)))","user":"5a8fd113e4b05369db4d2542"},{"code":"(fn [ks vs]\n  (apply hash-map (mapcat #(do [% %2]) ks vs)))","problem":61,"user":"510b0480e4b078ea719210fa"},{"code":"(fn [coll1 coll2] (apply hash-map (interleave coll1 coll2)))","problem":61,"user":"4e4bd94b535dc968683fc4d7"},{"problem":61,"code":"(fn [as bs] (reduce merge (map (fn [a b] {a b}) as bs)))","user":"5b67f0fbe4b0c6492753e76d"},{"problem":61,"code":"(fn[a b] (reduce #(assoc %1 (first %2) (last %2)) {} (map list a b)))","user":"5602ab92e4b04bb52996e1a3"},{"problem":61,"code":"#(reduce merge {} (apply map hash-map [%1 %2]))","user":"5c30d90de4b0d62ef62d9f22"},{"code":"(fn f [x y] (into {} (into [] (map #(into [] (concat [] [%1 %2])) x y))))","problem":61,"user":"5062bc46e4b05ac47bc68d68"},{"problem":61,"code":"(fn mapc\n  [veca vecb]\n  (if (or (empty? veca) (empty? vecb))\n    {}\n    (assoc (mapc (rest veca) (rest vecb)) (first veca) (first vecb))\n    )\n  )","user":"5bc8c033e4b07a9b28b100ca"},{"problem":61,"code":"(fn my-zipmap [A B]\n   ((fn helper [A B result]\n      (if (and (not-empty A)\n               (not-empty B))\n        (helper (rest A) (rest B) (into result [{(first A) (first B)}]))\n        result\n        )\n      )\n    A\n    B\n    {}))","user":"5ee75f8be4b029a2061bbea5"},{"problem":61,"code":"#(let [k %1 v %2] (into (sorted-map) (mapcat hash-map k v)))","user":"5b044436e4b0cc2b61a3bd71"},{"problem":61,"code":"; The online docs for interleave have this problem as an example!\n#(apply assoc {} (interleave %1 %2))","user":"5535e822e4b09218d5f44fb2"},{"code":"(fn [coll1 coll2]\n   (reduce merge (map hash-map coll1 coll2)))","problem":61,"user":"4f2582bae4b0d66497709ff6"},{"code":"(fn [keys vals]\n   (reduce\n     (fn [mp [k v]]\n       (assoc mp k v))\n     {}\n     (partition 2 (interleave keys vals))))","problem":61,"user":"50f1dedbe4b0897c4366dcd8"},{"problem":61,"code":"(fn [kk vv] \n  (loop [l kk r vv out {}]\n    (if (or (empty? l) (empty? r))\n      out\n      (recur (rest l) (rest r) (conj out [(first l) (first r)])))))","user":"58b997afe4b0888cdc949cd1"},{"code":"(fn [ks vs] (into {} (map (fn [a b] [a b]) ks vs)))","problem":61,"user":"4db86aee535d1e037afb2193"},{"code":"(fn [a b] (reduce #(assoc %1 (first %2) (second %2)) {} (map vector a b)))","problem":61,"user":"4fa05b99e4b0dcca54ed6d47"},{"problem":61,"code":"(fn [a b]\n   (loop [l a r b output []]\n     (if (or (empty? l) (empty? r))\n       (apply hash-map output)\n       (recur (rest l) (rest r) (concat output [(first l) (first r)]))\n     )\n   )\n)","user":"53beacf9e4b0d9a98559a6e3"},{"problem":61,"code":"(fn [ks vs]\n  (reduce (fn [m [k v]]\n            (assoc m k v))\n          {}\n          (map vector ks vs)))","user":"55d2dd27e4b0e31453f64a5b"},{"code":"(fn [a b] (apply hash-map (mapcat #(conj [%1] %2) a b)))","problem":61,"user":"503ca47fe4b06c4e0e1fa24f"},{"code":"#(apply hash-map (apply mapcat list %&))","problem":61,"user":"4e6a48d5535d8ccf87e9febd"},{"problem":61,"code":"(fn czipmap [x y]\n    (loop [keys x\n           values y\n           result {}]\n      (if (or (empty? keys) (empty? values))\n        result\n        (recur (rest keys)\n               (rest values)\n               (assoc result (first keys) (first values))))))","user":"5e7b1ef4e4b085ba37836e10"},{"problem":61,"code":"#(into {} (apply map hash-map %&))","user":"5501a1e1e4b07d26eda61d75"},{"problem":61,"code":"(fn[a b] (into {} (map #(hash-map %1 %2) a b)))","user":"563c6ebae4b0bfe05bf11834"},{"problem":61,"code":"(fn [ sq1 sq2 ]\n  (apply hash-map  (flatten (map (fn [ a1 a2 ] [a1 a2]) sq1 sq2))))","user":"59f90e6ae4b0ca45a743a337"},{"problem":61,"code":"(fn [ks vs]\n  (reduce\n   (fn [coll [k v]] (conj coll {k v}))\n   {}\n   (map vector ks vs)))","user":"5b500215e4b02d533a91bce2"},{"code":"(fn my-zipmap\n  [keys values]\n  (loop [[k & ks] keys\n         [v & vs] values\n         acc {}]\n    (if (and k v) (recur ks vs (assoc acc k v)) acc)))","problem":61,"user":"52dd6cc8e4b09f7907dd13e2"},{"code":"(fn zm [ks vs]\n  (when-let [ks (seq ks)]\n    (when-let [vs (seq vs)]\n      (into {(first ks) (first vs)} (zm (rest ks) (rest vs))))))","problem":61,"user":"527cd633e4b0757a1b17136f"},{"problem":61,"code":"(fn [v1 v2]\n\t(loop [i 0 result {}]\n\t\t(if (or (= (count v1) i) (= (count v2) i))\n\t\t\tresult\n\t\t\t(recur (inc i) (assoc result (get v1 i) (get v2 i)))\n\t\t)\n\t)\n)","user":"5559b443e4b0deb715856e3c"},{"code":"(fn [keys vals]\n  (loop [map {}\n         ks (seq keys)\n         vs (seq vals)]\n    (if (and ks vs)\n      (recur (assoc map (first ks) (first vs))\n             (next ks)\n             (next vs))\n      map)))","problem":61,"user":"505aa653e4b021387fb89857"},{"problem":61,"code":"(fn [coll1 coll2] (reduce (fn [result [a b]]\n            (assoc result a b))\n          {}\n          (map (fn [x y] [x y]) coll1 coll2)))","user":"540997ede4b0addc1aec66dd"},{"code":"(fn\n  [keys vals]\n  (apply hash-map (interleave keys vals)))","problem":61,"user":"5289bba9e4b0239c8a67ae69"},{"problem":61,"code":"(fn foo [k v] \n  (merge  \n   (if \n     (or \n      (= () (rest k)) \n      (= () (rest v)))\n     {} \n     (foo (rest k) (rest v)))\n     (assoc \n     {} \n     (first k) \n     (first v))))","user":"5143824ae4b0b4fb4ace5f36"},{"code":"(fn [k v]\n  (loop [ke k va v result {}]\n    (if (or (empty? ke) (empty? va))\n        result\n        (recur (rest ke) (rest va) (conj result {(first ke) (first va)}))\n    )\n  )\n)","problem":61,"user":"4fcf5292e4b03432b189f40e"},{"code":"(fn [a b] (reduce merge (map #(hash-map %1 %2) a b)))","problem":61,"user":"4f0e995e535d0136e6c22326"},{"problem":61,"code":"(fn [xs ys] \n    (loop [xseq xs\n           yseq ys\n           result {}]\n          (if (and (not (empty? xseq))\n              \t   (not (empty? yseq)))\n              (recur (rest xseq) (rest yseq) (assoc result (first xseq) (first yseq)))\n              result)))","user":"5830377ee4b051871117c004"},{"problem":61,"code":"(fn [xs ys] (apply hash-map (mapcat #(list % %2) xs ys)))","user":"504f5804e4b0a02f9cffde72"},{"problem":61,"code":"(fn [x y]\n    (letfn [(my-fn [xs ys]\n                   (if (or (empty? xs)\n                           (empty? ys))\n                     '()\n                     (concat `(~(first xs) ~(first ys))\n                           (my-fn (rest xs) (rest ys)))))]\n      (apply hash-map (my-fn x y))))","user":"5447e08ce4b032a45b8693c3"},{"code":"(fn [kys items] (apply assoc {} (interleave kys items)))","problem":61,"user":"4ef7a483535dced4c769f258"},{"code":"(fn [k v] (reduce conj (map (partial assoc {}) k v)))","problem":61,"user":"524469dee4b0d8acf9ed6a9d"},{"code":"(fn [cl1 cl2]\n\t(into {} (map\n\t\t#(vector %1 %2)\n\t\tcl1 cl2)\n \t)\n )","problem":61,"user":"51db9e1ee4b0e067a9bbadc9"},{"code":"(fn [keys values]\n  (apply merge\n    (map (fn [key value]\n         {key value}) keys values)))","problem":61,"user":"4ff505c8e4b0678c553fc364"},{"problem":61,"code":"(fn [keys vals] (reduce (fn [acc [k v]] (assoc acc k v)) {} (map (fn [e1 e2] [e1 e2]) keys vals)))","user":"5d63f1c2e4b0c9e5857d502b"},{"problem":61,"code":"#(reduce (fn [xs [k v]] (assoc xs k v)) {} (map (fn [a b] [a b]) % %2))","user":"580e7761e4b0849f6811b753"},{"problem":61,"code":"(fn my-zipmap [xs ys]\n  (apply assoc {}\n         (interleave xs ys)))","user":"5688a01be4b0dcc4269f406d"},{"problem":61,"code":"(fn bla2 [x y] (if (and (not= nil (first x)) (not= nil (first y)))\n                  (merge {(first x) (first y)} (bla2 (rest x) (rest y)))\n                  ))","user":"54458995e4b032a45b86939e"},{"code":"#(loop [a %1 b %2 m {}]\n  (if (or (empty? a) (empty? b))\n    m\n    (recur (rest a) (rest b) (assoc m (first a) (first b)))))","problem":61,"user":"4eb5750a535d7eef30807366"},{"problem":61,"code":"(fn map-maker [k v] (if (or (empty? k) (empty? v)) {}\n                      (merge {(first k) (first v)} (map-maker (rest k) (rest v)))))","user":"53e2ac1ae4b036ad0777e3f3"},{"code":"(fn [x y] (reduce merge {} (map #(hash-map % %2) x y)))","problem":61,"user":"4f048f67535dcb61093f6bd3"},{"code":"(fn [keys values]\n  (loop [k keys\n         v values\n         acc (hash-map)]\n    (if (or (empty? k) (empty? v))\n      acc\n      (recur (rest k) (rest v) (assoc acc (first k) (first v))))))","problem":61,"user":"4f08a8a2535dcb61093f6c3d"},{"problem":61,"code":"(fn [x y] (into {} (map vector x y)))","user":"529c722de4b04e0c58e87b63"},{"problem":61,"code":"(fn [ks vs]\n  (into {} (map (fn [a b] [a b]) ks vs)))","user":"571c2babe4b07c98581c3b73"},{"problem":61,"code":"(fn [la lb] (apply hash-map (mapcat #(list %1 %2) la lb)) )","user":"5bbbd484e4b0a20761a23617"},{"problem":61,"code":"#(into (hash-map) (mapcat (fn[k v](hash-map k v)) %1 %2))","user":"5e48ec09e4b043cd24807a45"},{"problem":61,"code":"(fn [first-seq second-seq] \n  (apply hash-map (interleave first-seq second-seq)))","user":"56020b3fe4b04bb52996e19b"},{"problem":61,"code":"(fn [x y]\n  (reduce\n   #(assoc %1 \n     (first %2) (last %2))\n   {} (partition 2\n       (interleave x y))))","user":"510608ebe4b01150e115ebe3"},{"code":"(fn [xs ys] (into {} (map vector xs ys)))","problem":61,"user":"52618ea3e4b03e8d9a4a7064"},{"problem":61,"code":"(fn [x y]\n      (reduce merge {} (map (fn [x y] {x y}) x y)))","user":"5540fe42e4b0a04f7929950a"},{"code":"(fn [c1 c2] (apply hash-map (interleave c1 c2)))","problem":61,"user":"51c214bce4b0d204dbe2ca1c"},{"code":"(fn [k v]\n  (loop [m {}\n         ks k\n         vs v]\n    (if (or (empty? ks) (empty? vs))\n      m\n    (recur (assoc m (first ks) (first vs)) (next ks) (next vs)))))","problem":61,"user":"51da565ae4b02ceefd947765"},{"problem":61,"code":"(fn [c1 c2] \n  (apply hash-map (mapcat #(list % %2) c1 c2)))","user":"56bb652ae4b0f26550335953"},{"code":"(fn [& c]\n  (apply assoc {} (apply interleave c)))","problem":61,"user":"4fb79872e4b081705acca2d2"},{"code":"(fn [S1 S2]\n  (loop [m {} s1 S1 s2 S2]\n    (if (or (empty? s1) (empty? s2))\n      m\n      (recur (assoc m (first s1) (first s2)) (rest s1) (rest s2)))))","problem":61,"user":"4ef4c1ff535dced4c769f23e"},{"problem":61,"code":"(fn f[a b]\n  (apply hash-map (mapcat list a b)))","user":"56fa8984e4b07572ad1a88c1"},{"code":"(fn [a b]\n  (into {} (map vec (partition 2 2 (interleave a b)))))","problem":61,"user":"4f4ba29ae4b03ad3f0c10c7a"},{"code":"(fn my-zipmap [ks vs]\n  (apply assoc {} (interleave ks vs)))","problem":61,"user":"5119f3d5e4b06c8af0111818"},{"problem":61,"code":"#(loop [s1 %1 s2 %2 r {}]\n   (if (or (empty? s1) (empty? s2)) r\n     (recur (rest s1) (rest s2) (assoc r (first s1) (first s2)))))","user":"592bb806e4b072a2710fcf46"},{"code":"(fn make-map [keys values] (apply hash-map (interleave keys values)))","problem":61,"user":"531dfaf5e4b08068f379edb3"},{"problem":61,"code":"(fn zip-map [key-seq value-seq]\n  (if (or (empty? key-seq) (empty? value-seq))\n    {}\n    (assoc (zip-map (rest key-seq) (rest value-seq)) (first key-seq) (first value-seq))))","user":"57d9bca1e4b0bd073c202405"},{"problem":61,"code":"(fn [a b] (apply merge (map (partial assoc {}) a b)))","user":"56ebe773e4b04a395b9a042a"},{"problem":61,"code":";#(into {} (map-indexed (fn [idx i] (vector (%1 idx) (%2 idx)) ) (if (> (count %1) (count %2)) %2 %1) ))\n#(into {} (map vector %1 %2))","user":"55647a31e4b0c656e3ff1808"},{"problem":61,"code":"(fn [k-vec v-vec]\n  (into {} (map vector k-vec v-vec)))","user":"52bc0dade4b07a9af57922f1"},{"problem":61,"code":"(fn [xs ys] (apply hash-map (mapcat vector xs ys)))","user":"564ecc9ee4b0284900eef6a1"},{"problem":61,"code":"(fn [c1 c2] (reduce into (map #(hash-map %1 %2) c1 c2)))","user":"53d6cf90e4b0e771c302545c"},{"code":"(fn f [keys vals]\n  (if (or (empty? keys) (empty? vals)) \n    {}\n    (let [[k & ks] keys [v & vs] vals]\n      (assoc (f ks vs) k v))))","problem":61,"user":"4fd22e70e4b04c3a95aa041c"},{"problem":61,"code":"(fn [col1 col2]\n  (reduce #(assoc %1 (first %2) (last %2)) {} (map list col1 col2)))","user":"57ea2c91e4b0bfb2137f5b42"},{"problem":61,"code":"(fn zm [[k & ks] [v & vs]]\n  (if (and k v)\n    (merge {k v} (zm ks vs))\n    {}))","user":"51b76227e4b0d906fcd71d35"},{"problem":61,"code":"(fn [x n] \n  (apply assoc {} (interleave x n)))","user":"5a99b861e4b0d174b936c7ad"},{"code":"#(reduce (fn [m n] (conj m n)) {} (map (fn [k v] {k v}) %1 %2))","problem":61,"user":"505dcfc8e4b0e6aca564be0d"},{"problem":61,"code":"(fn mc [vk vv] \n  (cond\n   (or (= 1 (count vk)) (= 1 (count vv))) (assoc {} (first vk) (first vv))\n   :else (assoc (mc (rest vk) (rest vv)) (first vk) (first vv))))","user":"54d4bd2be4b0a52adc2e2005"},{"problem":61,"code":"#(reduce merge (map (fn [k v] {k v}) %1 %2))","user":"54c9636fe4b045293a27f66e"},{"code":"(fn f [x y]\n  (apply hash-map (interleave x y)))","problem":61,"user":"52b0323ee4b0c58976d9acc6"},{"code":"(fn [a b]\n  (apply conj\n    (map #(assoc {} %1 %2) a b)))","problem":61,"user":"5014754de4b094324338f8e5"},{"problem":61,"code":"(fn [& args]\n  (apply hash-map (apply interleave args)))","user":"60460824e4b02d28681c77bc"},{"code":"(fn [k v]\n  (into {} (map #(vector %1 %2) k v)))","problem":61,"user":"5338387de4b0e30313ee6c91"},{"code":"#(apply merge (map (fn [x y] {x y}) %1 %2))","problem":61,"user":"4faf2f4ce4b081705acca251"},{"code":"(fn f [k v]\n  (if (or (empty? k) (empty? v))\n      {}\n      (assoc (f (rest k) (rest v))\n             (first k) (first v))))","problem":61,"user":"5054c7e1e4b0b1b9d1860eb2"},{"problem":61,"code":"(fn\n    [ks vs]\n(into {} (map #(assoc {} %1 %2) ks vs ))\n    \n    )","user":"56a358d0e4b0542e1f8d14c9"},{"code":"(fn [keys values] (apply assoc {} (interleave keys values)))","problem":61,"user":"4edd4b77535d10e5ff6f5328"},{"problem":61,"code":"(fn [m1 m2]\n  (into {} (map vector m1 m2)))","user":"5cc6b4bfe4b0ccb061962827"},{"code":"(fn [ks vs]\n  (loop [h (hash-map)\n         rks ks\n         rvs vs]\n     (if (or (empty? rks) (empty? rvs)) h\n       (recur (assoc h (first rks) (first rvs)) (rest rks) (rest rvs)))))","problem":61,"user":"4f036fb3535dcb61093f6ac8"},{"problem":61,"code":"(fn [k v] (loop [m {} ks k vs v] (if\n                                   (or (empty? ks) (empty? vs))\n                                   m\n                                   (recur \n                                    (assoc m (first ks) (first vs))\n                                    (rest ks)\n                                    (rest vs)))))","user":"55009d17e4b07d26eda61d5d"},{"code":"(fn [x y] (reduce merge (map #(assoc {} %1 %2) x y) ))","problem":61,"user":"4fa7de4ce4b081705acca1c9"},{"problem":61,"code":"(fn [listaA listaB]\n(apply hash-map (mapcat #(cons %1 (list %2)) listaA listaB)))","user":"59e63a2ce4b08badc2a0c569"},{"code":"(fn [v1 v2]\n  (loop [[h1 & t1] v1\n         [h2 & t2] v2\n         acc       {}]\n   (if (or (nil? h1) (nil? h2))\n      acc\n      (recur t1  t2 (assoc acc h1 h2)))))","problem":61,"user":"4e68b46c535d8ccf87e9fe87"},{"code":"(fn [a b] (reduce conj {} (map #(hash-map %1 %2) a b)))","problem":61,"user":"4e5d2dc5535d8a8b8723a2ca"},{"problem":61,"code":"(fn [a b]\n   (loop [a a\n          b b\n          return []]\n     (if (or (empty? a) (empty? b))\n       (into {} return)\n       (recur (rest a) (rest b) (conj return (vector (first a) (first b)))))))","user":"57c44053e4b05aa3c4741ccb"},{"problem":61,"code":"(fn [ks vs] (loop [ks ks vs vs m (hash-map)]\n              (if (or (empty? ks) (empty? vs))\n                m\n                (recur (rest ks) (rest vs) (assoc m (first ks) (first vs))))))","user":"5bdf651ee4b0ed4b8aab4c6d"},{"problem":61,"code":"(fn [ks vs] (reduce #(let [[k v] %2] (assoc %1 k v)) {} (map list ks vs)))","user":"5c0a87e6e4b0bdcf453d1707"},{"problem":61,"code":"(fn zm \n  ([a b] (zm a b {}))\n  ([a b m]\n    (if (or (empty? a) (empty? b))\n      m\n      (zm (rest a) (rest b) (assoc m (first a) (first b))))))","user":"4f4aa932e4b0d56e7bb92c14"},{"code":"(fn [ks vs]\n  (reduce conj {} (map vector ks vs)))","problem":61,"user":"4edeac6b535d10e5ff6f533a"},{"code":"(fn [coll-1 coll-2] (into {} (map #(vector %1 %2) coll-1 coll-2)))","problem":61,"user":"4f9510b5e4b0dcca54ed6cc7"},{"problem":61,"code":"(fn [coll-1 coll-2] \n   (into\n    {}\n    (map \n     (fn [item-1 item-2]\n       {item-1 item-2})\n     coll-1\n     coll-2)))","user":"54ef7568e4b024c67c0cf885"},{"code":"(fn mapper[keys values]\r\n  (loop [result {} x (seq keys) y (seq values) ]\r\n    (if (and x y)\r\n      (recur (assoc result (first x) (first y))\r\n          (next x)\r\n          (next y)\r\n        )\r\n      result)\r\n    )\r\n  )","problem":61,"user":"4e9def6b535dbda64a6f6b8f"},{"code":"(fn [keys vals](apply array-map (mapcat list keys vals)))","problem":61,"user":"4e739e13535dff18050a9c76"},{"problem":61,"code":"(fn [seq1 seq2]\n  (loop [[x & xs] seq1\n         [y & ys] seq2\n         result {}]\n    (if (or (nil? x)\n            (nil? y))\n      result\n      (recur xs ys (assoc result x y)))))","user":"52ea025ae4b09f7907dd14b5"},{"problem":61,"code":"(fn [x y]\n    (apply conj {}\n          (map #(vector %1 %2) x y)))","user":"5921a080e4b09b4ee5954c77"},{"problem":61,"code":"(fn zip-map [ks vs]             ;此处必须要使用ks vs告诉clojure是键对值形式的  interleave是将第一个参数和第二个参数进行键对转换，然后用apply hash-map将他们装进{}\n  (apply hash-map (interleave ks vs)))","user":"57c500f9e4b05aa3c4741cda"},{"problem":61,"code":"(fn my-zipmap\n  [k v]\n  (apply merge (map (fn [x y] {x y}) k v)))","user":"5f3103aee4b0574c87022c24"},{"code":"(fn [ks vs]\n  (apply hash-map (mapcat vector ks vs)))","problem":61,"user":"503a234de4b088a6a14ca76d"},{"problem":61,"code":"#(apply array-map (apply interleave %&))","user":"4f070ce6535dcb61093f6c1e"},{"problem":61,"code":"(fn [c1 c2] (into {} (mapv vector c1 c2)))","user":"57642916e4b0994c1922fbee"},{"problem":61,"code":"(fn [s1 s2] (apply merge (map (partial assoc {}) s1 s2)))","user":"57a0f256e4b0c3d858beb8dd"},{"code":"(fn zipp [x y]\n  (apply  assoc {} (interleave x y))\n)","problem":61,"user":"4fb7b80ae4b081705acca2d4"},{"problem":61,"code":"#(into { } (map hash-map %1 %2))","user":"5bec37e2e4b0f319e2d7ec96"},{"problem":61,"code":"(fn [x y]\n  (loop [acc {} cnt (count x) a x b y]\n    (cond\n     (zero? cnt) acc\n     (nil? b) acc\n     :else( recur (assoc acc (first a) (first b)) (dec cnt) (next a) (next b)))))","user":"5585f088e4b001b0851d7513"},{"problem":61,"code":"#(->> %& (apply map vector) (apply concat) (apply hash-map))","user":"4fec08e8e4b0681fd128dc9d"},{"code":"(fn [v1 v2]\n  (reduce #(assoc %1 (first %2) (last %2)) {} (\n    partition 2 (interleave v1 v2))\n  )\n)","problem":61,"user":"4fcad14ce4b0ee37620e1856"},{"problem":61,"code":"(fn [keys vals]\n    (loop [map (transient {})\n           ks (seq keys)\n           vs (seq vals)]\n      (if (and ks vs)\n        (recur (assoc! map (first ks) (first vs))\n               (next ks)\n               (next vs))\n        (persistent! map))))","user":"57123c96e4b09c608db70454"},{"problem":61,"code":"(fn map-construction\n\t[keyz valz] \n\t(reduce #(assoc %1 (nth keyz %2) (nth valz %2)) {} \n\t\t(range (min (count keyz) (count valz))))\n\t)","user":"5252b59de4b0541d1855b8cf"},{"code":"(fn [x y]\n  (reduce conj {} (map hash-map x y)))","problem":61,"user":"51eadb98e4b0f1f103a0d153"},{"problem":61,"code":"(fn [a b] (apply merge (map #(hash-map % %2) a b)))","user":"5f8e865fe4b0715f5002d76d"},{"code":"(comp (partial apply sorted-map) interleave)","problem":61,"user":"4faa9593e4b081705acca1f9"},{"code":"(fn my-zipmap [k v]\n  (cond\n    (or (empty? k) (empty? v)) {}\n    :else (merge {(first k) (first v)} (my-zipmap (rest k) (rest v)))\n  )\n)","problem":61,"user":"4faacc04e4b081705acca201"},{"problem":61,"code":"(fn const\n  [keys values]\n  (when (and (not-empty keys) (not-empty values))\n    (assoc (const (rest keys) (rest values)) (first keys) (first values))))","user":"5a6a32b6e4b0512ff01cda22"},{"code":"(fn [k v] (apply hash-map (mapcat vector k v)))","problem":61,"user":"51bc2f6ae4b0fe3ecfb46452"},{"problem":61,"code":"(fn [ks vs]\n  (loop [[k & ks] ks\n         [v & vs] vs\n         acc {}]\n    (if-not (and k v)\n      acc\n      (recur ks vs (assoc acc k v)))))","user":"601004d6e4b074f607df66b2"},{"code":"(comp (partial into {}) (partial map vector))","problem":61,"user":"4ddbd934535d02782fcbe9fc"},{"code":"(fn [kk vv]\n   (apply hash-map (mapcat vector kk vv)))","problem":61,"user":"4f616892e4b0defedf855fbf"},{"problem":61,"code":"#(loop [[hkey & tkey] %1\n        [hval & tval] %2\n        acc {}]\n   (if (and hkey hval)\n     (recur tkey tval (assoc acc hkey hval))\n     acc))","user":"53f7820be4b0de5c41848560"},{"code":"(fn [a b] (reduce merge (map (fn [r t] {r t}) a b) ) )","problem":61,"user":"525cc137e4b0cb4875a45d46"},{"problem":61,"code":"(fn [vkeys vvalues] (apply hash-map (interleave vkeys vvalues)))","user":"5c723f4be4b0fca0c16227a0"},{"code":"(fn my-zipmap [keys vals]\n  (reduce (fn [m [key val]]\n            (assoc m key val))\n    {}\n    (map list keys vals)))","problem":61,"user":"50812debe4b01a93d3f38e4c"},{"code":"(fn[x y] (loop [xs x ys y result {}]\n    (if (not (or (empty? xs)  (empty? ys)))\n      (recur (rest xs) (rest ys) (conj result {(first xs) (first ys)}))\n      result)))","problem":61,"user":"51d10b1fe4b067c36548635e"},{"problem":61,"code":";; (fn [keys vals]\n;; (loop [map {}\n;;            ks (seq keys)\n;;            vs (seq vals)]\n;;       (if (and ks vs)\n;;         (recur (assoc map (first ks) (first vs))\n;;                (next ks)\n;;                (next vs))\n;;         map)))\n\n#(into {} (map vector %1 %2))","user":"5412646de4b01498b1a719d4"},{"code":"#(into {} (map (fn [a b] {a b})  %1 %2))","problem":61,"user":"52736ca1e4b03e8d9a4a747e"},{"problem":61,"code":"#(into (sorted-map) (map (fn [x y] (conj [] x y)) %1 %2))","user":"58dcae01e4b0a4d5acaab6a4"},{"problem":61,"code":"#(loop [[x & xs] %1, [y & ys] %2, ret {}]\n   (if (and x y)\n     (recur xs ys (conj ret [x y]))\n     ret))","user":"554b7056e4b0a04f79299583"},{"problem":61,"code":"#(reduce (fn [h v] (apply assoc h v)) {} (partition 2 (interleave %1 %2)))","user":"56018dd4e4b04bb52996e18f"},{"code":"#(into {} (map vector % %2))","problem":61,"user":"4e4ae5aa535dc968683fc4d2"},{"problem":61,"code":"(fn [l1 l2]\n  (loop [l1 l1 l2 l2 r {}]\n    (if (or (empty? l1) (empty? l2)) r\n      (recur (rest l1) (rest l2) (conj r [(first l1) (first l2)])))))","user":"57d9f603e4b0bd073c20240a"},{"code":"(fn [kseq vseq] \n  (loop [[k & ks] kseq [v & vs] vseq acc {}]\n    (if (or (nil? k) (nil? v))\n      acc\n    (recur ks vs (assoc acc k v)))))","problem":61,"user":"4f1c2a3a535d64f603146480"},{"problem":61,"code":";; http://www.4clojure.com/problem/61\n(fn map-construct\n  [key-coll val-coll]\n  (apply hash-map (interleave key-coll val-coll)))","user":"5c92105ce4b048ec896c59f7"},{"code":"#(apply merge {} (map hash-map %1 %2))","problem":61,"user":"4daf36c2edd6309eace4d175"},{"problem":61,"code":"(fn [l1 l2] (into (hash-map) (map vector l1 l2)))","user":"5a778224e4b013a48d399761"},{"problem":61,"code":"(fn [ks vs]\n  (loop [rks ks\n         rvs vs\n         m {}]\n    (let [k (first rks)\n          v (first rvs)]\n      (if (or (empty? rks) (empty? rvs))\n        m\n        (recur (rest rks) (rest rvs) (assoc m k v))))))","user":"567c2322e4b05957ce8c61af"},{"code":"#(into {} (map hash-map %1 %2))","problem":61,"user":"4e5bdc2b535d8a8b8723a2bb"},{"problem":61,"code":"(fn zipmap-\n  [keys vals]\n  (->> [keys vals]\n       (apply map (fn [k v] {k v}))\n       (reduce conj)))","user":"604a30c6e4b02d28681c77f0"},{"problem":61,"code":"(fn my-zipmap [keys, values]\n     (apply hash-map\n      (reduce concat (map list keys values) ))\n    )","user":"5443cb97e4b032a45b86938a"},{"code":"(fn [keys vals]\n    (loop [map {}\n           ks keys\n           vs vals]\n      (if (and ks vs)\n        (recur (assoc map (first ks) (first vs))\n               (next ks)\n               (next vs))\n        map)))","problem":61,"user":"5126dbabe4b083bb8f88cf0e"},{"problem":61,"code":"(fn [ks vs]\n  (apply hash-map\n    (apply concat\n      (map list ks vs))))","user":"562cd94ee4b0a45d2ff83015"},{"code":"#(apply hash-map (flatten (map (fn [k v] [k v]) % %2)))","problem":61,"user":"51424cc8e4b0b50abeb46b34"},{"problem":61,"code":"(fn [keys values]\n  (let [resultMap {}]\n    (loop [[theKeys theValues theMap] [keys values resultMap]]\n      (if (or (empty? theKeys) (empty? theValues)) \n        theMap \n        (recur [(rest theKeys) (rest theValues) (assoc theMap (first theKeys) (first theValues))])\n      )\n    )\n  )\n)","user":"57f904c5e4b0d3187e900936"},{"code":"(fn [keys values] \n  (apply hash-map (interleave keys values)))","problem":61,"user":"520f46f9e4b0101e4be6fcee"},{"code":"(fn myzipmap [a b]\n    (apply hash-map (interleave a b))\n)","problem":61,"user":"51d1111ce4b067c36548635f"},{"problem":61,"code":"(fn [start-ks start-vs]\n  (loop [\n         [k & ks] start-ks\n         [v & vs] start-vs\n         m {}\n         ]\n    (if (and k v)\n      (recur ks vs (assoc m k v))\n      m\n      )\n    )\n  )","user":"5ab5f60be4b073f177442643"},{"problem":61,"code":"(fn [ks vs]\n   (apply hash-map (interleave ks vs)))","user":"51f66891e4b06ff1c25c52c1"},{"code":"(fn [x y] (apply merge (map #(assoc {} % %2) x y)))","problem":61,"user":"50ad7888e4b0a40c9cfb08c7"},{"problem":61,"code":"#(reduce (fn [m [k v]] (assoc m k v)) {} (map (fn [k v] [k v]) %1 %2))","user":"550aeddae4b06e50f9beb135"},{"code":"#(loop [keys %1 values %2 result {}]\n     (if (or (nil? (first keys)) (nil? (first values)))\n\t       result\n\t       (recur (rest keys) (rest values) (assoc result  (first keys) (first values)))))","problem":61,"user":"4f066916535dcb61093f6c10"},{"code":"(fn [c1 c2] (apply hash-map (mapcat list c1 c2)))","problem":61,"user":"53286389e4b09d4e7a9b5504"},{"problem":61,"code":"(fn my-zipmap\n    ([x y]\n     (my-zipmap x y {})\n     )\n    ([x y m]\n     (if (or (empty? x) (empty? y))\n       m\n       (my-zipmap (rest x) (rest y) (assoc m (first x) (first y)))\n       )))","user":"5a9d64c8e4b0d174b936c7eb"},{"code":"(fn [ks vs]\n  (loop [m {} ks ks vs vs]\n    (if (or (empty? ks) (empty? vs))\n      m\n      (recur\n       (assoc m (first ks) (first vs))\n       (rest ks)\n       (rest vs)))))","problem":61,"user":"51684318e4b03f62cda68cd6"},{"problem":61,"code":"(fn zpmp\n  [key-lst val-lst]\n  (apply hash-map (interleave key-lst val-lst)))","user":"57f81534e4b0d3187e900915"},{"problem":61,"code":"#(apply hash-map (mapcat (fn[x y] [x y]) %1 %2))","user":"503c90aae4b06c4e0e1fa24b"},{"problem":61,"code":"(fn [k v]\n  (reduce #(assoc % (first %2) (last %2))\n          {}\n          (partition 2 (interleave k v))))","user":"56ff45e5e4b08d47c97781bb"},{"problem":61,"code":"(fn [f s] \n  (apply conj (for [[x y] (partition 2 (interleave f s))] {x y})))","user":"55d74e71e4b0e31453f64aa4"},{"problem":61,"code":"(fn solution [keys vals]\n  (apply hash-map (mapcat #(vector %1 %2) keys vals)))","user":"5e2ef900e4b05b4b015161fc"},{"code":"(fn my-zipmap [ks vs]\n  ((fn [ks vs m]\n     (if (and (seq ks) (seq vs))\n       (recur (rest ks) (rest vs) (assoc m (first ks) (first vs)))\n       m))\n     ks vs {}))","problem":61,"user":"4ec75077535d6d7199dd36e0"},{"problem":61,"code":"(fn my-zipmap [keys vals]\n    (if (or (empty? keys) (empty? vals))\n      {}\n      (assoc\n        (my-zipmap (rest keys) (rest vals))\n        (first keys)\n        (first vals))\n      )\n    )","user":"563b9acbe4b0bfe05bf11827"},{"code":"(fn [ks vs]\n  (loop [i (dec (min (count ks) (count vs)))\n         r {}]\n    (if (< i 0) r\n      (recur (dec i) (conj r (hash-map (get ks i) (get vs i)))))))","problem":61,"user":"523bc0e6e4b07becd5be21f9"},{"code":"#(apply sorted-map (interleave %1 %2))","problem":61,"user":"4ec1619b535dfed6da9c6dab"},{"problem":61,"code":"(fn\n  [collA collB]\n  (apply hash-map (interleave collA collB)))","user":"5ac35d00e4b0e27600da7712"},{"code":"(fn mapconstruct [keys vals]\n  (if (or (empty? keys) (empty? vals))\n    (hash-map)\n    (assoc (mapconstruct (rest keys) (rest vals))\n           (first keys) (first vals))))","problem":61,"user":"52d6889ae4b09f7907dd1361"},{"problem":61,"code":"(fn [keys values]\n  (loop [ret {} keys (seq keys) values (seq values)]\n    (if (and  keys values)\n      (recur (assoc ret (first keys) (first values)) (next keys) (next values))\n      ret)))","user":"5370d152e4b0fc7073fd6e9d"},{"code":"(fn [a b]\n  (loop [a a\n         b b\n         c {}]\n    (if (empty? a) c\n      (if (empty? b) c\n      (recur (rest a) (rest b) (conj c [(first a) (first b)]))))))","problem":61,"user":"531cbf46e4b08068f379eda6"},{"problem":61,"code":"(fn once [x y] (if (or (empty? x) (empty? y)) {} (merge {(first x) (first y)} (once (rest x) (rest y)))))","user":"57300c19e4b0cd1946bd0fa1"},{"problem":61,"code":"(fn [ks vs]\n  (reduce #(assoc %1 (first %2) (last %2)) {} (partition 2 (interleave ks vs)))\n)","user":"5bc28638e4b07a9b28b10033"},{"problem":61,"code":"(fn [keys vals] \n  (loop [map {} ks (seq keys) vs (seq vals)] \n    (if (and ks vs) \n      (recur (assoc map (first ks) (first vs)) \n             (next ks) \n             (next vs)) \n      map)\n    )\n  )","user":"57750460e4b0979f8965160c"},{"code":"#(loop [a %1 b %2 m {}]\n   (if (or (empty? a) (empty? b))\n     m\n     (recur (rest a) (rest b) (conj m {(first a) (first b)}))\n   )\n )","problem":61,"user":"53244c9de4b09d4e7a9b54db"},{"problem":61,"code":"(fn [ks vs]\n  (loop [ks ks\n         vs vs\n         map {}]\n    (if (and (first ks) (first vs))\n      (recur (rest ks) (rest vs) (assoc map (first ks) (first vs)))\n      map)))","user":"580a0783e4b0a837a8b30d2c"},{"problem":61,"code":"(fn my-map\n  [xs ys]\n  (loop [x xs y ys res {}]\n    (if (or (empty? x) (empty? y))\n      res\n      (recur (rest x) (rest y) (into res (assoc {} (first x) (first y)))))))","user":"5c35acffe4b0d62ef62d9f62"},{"code":"(fn zm [xs ys]\n  (if (or (empty? xs) (empty? ys))\n    {}\n    (conj (zm (rest xs) (rest ys)) {(first xs) (first ys)})))","problem":61,"user":"5334d4f2e4b0656e627bfd71"},{"code":"(fn [kys vls]\n  (reduce #(assoc %1 (first %2) (second %2)) {}\n    (partition 2 (interleave kys vls))))","problem":61,"user":"515737f0e4b0b0b4b87062d0"},{"problem":61,"code":"#(into {} (map  hash-map %1 %2))","user":"52c70127e4b0c2d177d6211a"},{"code":"(fn [k v]\r\n    (loop [keys k vals v map {}]\r\n\t     (if (or (empty? keys) (empty? vals))\r\n\t     map\r\n\t     (recur (rest keys) (rest vals) \r\n\t\t    (conj map {(first keys) (first vals)})))))","problem":61,"user":"4e821ca5535db62dc21a62c2"},{"code":"(fn [ks vs] (reduce (fn [m [k,v]] (assoc m k v)) {} (map list ks vs) ))","problem":61,"user":"50fa01bce4b07934dda8b0ba"},{"problem":61,"code":"#(reduce (fn [s p] (assoc s (first p) (second p))) {} (map (fn [k v] [k v]) %1 %2))","user":"4f041de1535dcb61093f6ba5"},{"problem":61,"code":"(fn [key-coll value-coll] (apply hash-map (interleave key-coll value-coll))\n  )","user":"56885c32e4b0dcc4269f4068"},{"code":"(fn zipmap*\n  [keys vals]\n  (loop [acc {}\n         k keys\n         v vals]\n    (if (or (empty? k) (empty? v))\n      acc\n      (recur (assoc acc (first k) (first v)) (rest k) (rest v))\n      )))","problem":61,"user":"4edfb618535d10e5ff6f5343"},{"problem":61,"code":"(fn [k v]\n         (reduce #(merge % %2) {} (map #(assoc {} % %2) k v)))","user":"570bd29be4b0b0fb43fd06c5"},{"code":"(fn [coll1 coll2] (into {} (map #(do [%1 %2]) coll1 coll2)))","problem":61,"user":"4e22b78b535d04ed9115e81e"},{"code":"#(loop [ret {} k %1 v %2 ] (if (or (empty? k) (empty? v)) ret\r\n                              (recur  (assoc ret (first k) (first v))  (rest k) (rest v) )))","problem":61,"user":"50463347e4b011c5dfee771e"},{"code":"#(apply array-map (interleave % %2))","problem":61,"user":"4e589bdc535d8a8b8723a295"},{"code":"#(let [l (if (< (count %1) (count %2)) (count %1) (count %2))]\n    (loop [r {} n 0]\n      (if (>= n l)\n        r\n        (recur (assoc r (nth %1 n) (nth %2 n)) (inc n)))))","problem":61,"user":"4ef2eb4d535dced4c769f226"},{"code":"(fn this-f [list-1 list-2]\n    (if (not\n         (or (empty? list-1)\n             (empty? list-2)))\n      (assoc (this-f (rest list-1) (rest list-2))\n        (first list-1) (first list-2))\n      {})\n    )","problem":61,"user":"52213426e4b0e6a83c8925c4"},{"problem":61,"code":"(fn [x y]\n      (apply assoc {}\n             (interleave x y)))","user":"54a11042e4b09f271ff37c49"},{"problem":61,"code":"(fn [& l] (apply assoc {} (apply interleave l)))","user":"556086a2e4b0c656e3ff17c1"},{"problem":61,"code":"(fn [xs ys]\n  (into {}\n    (map #(vector %1 %2)\n         xs ys)))","user":"53b42472e4b047364c0444b2"},{"code":"(fn [ks v]\n  (apply assoc {} (interleave ks v)))","problem":61,"user":"514fd753e4b0b449e54b8e00"},{"problem":61,"code":"(fn [keys vals] (loop [output {}\n                         k keys\n                         v vals]\n                    (if (or (empty? k) (empty? v))\n                      output\n                      ;; else\n                      (recur (merge output {(first k) (first v)}) (rest k) (rest v))\n                      )))","user":"5683fcafe4b0945ebc182aa8"},{"code":"(fn [keys values]\r\n     (into {} (map vector keys values)))","problem":61,"user":"4f82e14be4b033992c121c0c"},{"code":"(fn [a b]\n  (reduce #(assoc %1 (first %2) (second %2))\n          {}\n          (map vector a b)))","problem":61,"user":"50270618e4b01614d1633feb"},{"problem":61,"code":"(fn [k v]\n  (loop [m {} ks (seq k) vs (seq v)]\n    (if (and ks vs)\n      (recur (assoc m (first ks) (first vs)) (next ks) (next vs))\n      m)\n    )\n  )","user":"53a19dece4b0ca733b9744c0"},{"problem":61,"code":"(fn [k v] (apply assoc {} (flatten (map #(list %1 %2)   k v))))","user":"5fae3d8ae4b08cb800c85afa"},{"code":"(fn [a b] \n  (reduce (fn [x y] (merge x y))\n          {}\n          (map #(hash-map %1 %2) a b)))","problem":61,"user":"4ffe4d43e4b0678c553fc3f1"},{"problem":61,"code":"(fn [key-vec val-vec]\n  (reduce (fn [acc item]\n            (into acc item))\n          {}\n          (map #(hash-map %1 %2) key-vec val-vec)))","user":"58ee5371e4b056aecfd47da8"},{"code":"(fn [c1 c2]\n  (apply hash-map (interleave c1 c2)))","problem":61,"user":"4f29eb2ae4b0d6649770a037"},{"code":"(fn [keys vals]\n  (loop [k keys v vals r {}]\n    (if (or (empty? k) (empty? v))\n      r\n      (recur (rest k) (rest v) (merge r {(first k) (first v)})))))","problem":61,"user":"51aefceee4b09397d5109797"},{"code":"(fn [l1 l2] ((fn [res l1 l2]\n  (let [h1 (first l1)\n       h2 (first l2)]\n    (if (and (not (nil? h1)) (not (nil? h2)))\n    (recur (assoc res h1 h2) (rest l1) (rest l2))\n    res)\n  )\n  ) {} l1 l2)\n)","problem":61,"user":"4e9d6a65535dbda64a6f6b87"},{"code":"(fn [ks vs] \n    (reduce (fn [m [k v]] (assoc m k v)) {} (map vector ks vs)))","problem":61,"user":"4fa6a491e4b081705acca1bc"},{"problem":61,"code":"(fn [xs ys] (into {} (map #(identity [%1 %2]) xs ys)))","user":"597fa3fbe4b021a7a535fdbf"},{"code":"#(apply conj {} (map vec (map list %1 %2)))","problem":61,"user":"4fe87e56e4b07c9f6fd12c40"},{"code":"#(apply hash-map (interleave % %2))\r\n\r\n;#(reduce into (map hash-map % %2))","problem":61,"user":"4f07c8c3535dcb61093f6c2d"},{"problem":61,"code":"(fn my-map [lst1 lst2]\n\t(apply hash-map \n           (mapcat #(cons %1 (list %2)) lst1 lst2)))","user":"59dd387be4b0a0ac046f2502"},{"code":"(fn f\n  ([k v] (f k v {}))\n  ([[k & keys] [v & vals] a]\n  (if (and k v)\n    (recur keys vals (assoc a k v))\n    a)))","problem":61,"user":"52753740e4b03e8d9a4a74c1"},{"problem":61,"code":"(fn [s t]\n    (apply merge \n           (map \n             (fn [s t] \n               (merge(hash-map s t))) \n             s \n             t)))","user":"59301509e4b072a2710fcfd6"},{"code":"(fn construct [xs ys]\n\t  (cond (or (empty? xs) (empty? ys)) {}\n\t\t:else (assoc (construct (rest xs) (rest ys)) (first xs) (first ys))))","problem":61,"user":"5213ffd3e4b0961f15ac4d7d"},{"problem":61,"code":"(fn [keys vals]\n  (apply hash-map (mapcat #(vector %1 %2) keys vals))\n  )","user":"60436423e4b02d28681c77a3"},{"code":"(fn [xs ys]\n  (apply hash-map (reverse (loop [xsp xs ysp ys acc '()]\n    (if (or (empty? xsp) (empty? ysp))\n        acc\n        (recur (rest xsp) (rest ysp) (cons (first ysp) (cons (first xsp) acc))))))))","problem":61,"user":"4e7f5a0b535db966e863cc41"},{"code":"(fn[a b]\r\n  (apply merge (map #(assoc {} %1 %2) a b)))","problem":61,"user":"4deff9f9535d08e6dec9fe15"},{"problem":61,"code":"(fn [ks vs]\n  (reduce #(assoc %1 (first %2) (second %2))\n          {}\n          (map #(vector %1 %2) ks vs)\n  )\n)","user":"5da975b9e4b000c986472c32"},{"code":"(fn [coll1 coll2] (apply assoc {} (interleave coll1 coll2)))","problem":61,"user":"51f805b0e4b06ff1c25c52e2"},{"code":"(fn [k v] (apply assoc {} (interleave k v)))","problem":61,"user":"4f57a153e4b0a7574ea7183a"},{"problem":61,"code":"(fn [x y] (into {} (map #(hash-map %1 %2) x y)))","user":"53f6566ee4b0db01ade6f9de"},{"problem":61,"code":"(fn [a b]\n  (loop [m {} ks a vs b]\n    (if (or (empty? ks) (empty? vs))\n      m\n      (recur\n       (assoc m (first ks) (first vs))\n       (rest ks)\n       (rest vs)))))","user":"5843b95de4b089d5ab817e3f"},{"problem":61,"code":"(fn f61\n  [[a1 a2 a3 a4] [b1 b2 b3 b4]]\n  (if (nil? a3)\n    (hash-map a1 b1 a2 b2)\n    (hash-map a1 b1 a2 b2 a3 b3)))","user":"53abf519e4b047364c044456"},{"problem":61,"code":"(fn rmap [ks vs]\n  (reduce merge (map #(assoc {} %1 %2) ks vs)))","user":"56fa2905e4b07572ad1a88be"},{"problem":61,"code":"#(into {} (map (fn[x y](assoc {} x y)) %1 %2))","user":"545537c1e4b0e397800069dd"},{"problem":61,"code":"#(loop [i %1 j %2 result '()]\n   (if (or (empty? i) (empty? j))\n     (apply hash-map result)\n     (recur (rest i) (rest j) (concat result [(first i) (first j)])))\n)","user":"560c37b5e4b05f002753df2e"},{"code":"(fn [ks vs] (apply hash-map (mapcat #(vector %1 %2) ks vs)))","problem":61,"user":"4f4fbed7e4b03ad3f0c10ce8"},{"code":"(fn [keys vals] \n  (into {} (map vector keys vals)))","problem":61,"user":"5025b93ce4b0c969f0b056df"},{"code":"(fn my-zipmap\n  [ks vs]\n  (apply hash-map (interleave ks vs)))","problem":61,"user":"4e50b67b535dc968683fc4ed"},{"problem":61,"code":"(fn [ks vs]\n  (reduce\n    (fn [c n] (assoc c (first n) (second n)))\n    {}\n    (map list ks vs)))","user":"561d506ee4b064ca9f4b16aa"},{"code":"(fn [a b]\n  (into {} (map #(vec %) (partition 2 (interleave a b)))))","problem":61,"user":"4e964f4a535dbda64a6f6b42"},{"problem":61,"code":"(fn [ks vs]\n  (loop [ks ks\n         vs vs\n         acc {}]\n  (if-let [[k & ks-more] ks]\n    (if-let [[v & vs-more] vs]\n      (recur ks-more vs-more (assoc acc k v))\n      acc)\n    acc)))","user":"4ff24a1ae4b0678c553fc337"},{"code":"(fn[k v]\n  (loop [map {}\n        ks (seq k)\n        vs (seq v)] \n  (if (and ks vs) \n    (recur (assoc map (first ks) (first vs))\n           (next ks) \n           (next vs))\n    map)))","problem":61,"user":"52196842e4b0890f2f822bfa"},{"code":"(fn map-construction-solution\n  [ks vs]\n  (apply hash-map (interleave ks vs)))","problem":61,"user":"50c113bee4b096f585049c37"},{"problem":61,"code":"(fn[keys vals] (into {} (map (fn [k v] [ k v]) keys vals )))","user":"561d7246e4b064ca9f4b16b1"},{"code":"(fn [ks vs]\n  (loop [k ks, v vs, mp {}]\n    (if (or (empty? k) (empty? v))\n      mp\n      (recur (rest k) (rest v) (assoc mp (first k) (first v))))))","problem":61,"user":"5050b107e4b063148f524126"},{"code":"(fn [ks vs]\n  (apply merge (mapv #(assoc {} %1 %2) ks vs)))","problem":61,"user":"4f3d83b5e4b0e243712b1f69"},{"problem":61,"code":"#(into (hash-map) (map vector % %2))","user":"5d672bd7e4b0db5d338d15f1"},{"problem":61,"code":"(fn [keys vals]\n\t(loop [result {}\n\t\t\tks (seq keys)\n\t\t\tvs (seq vals)]\n\t\t(if (and ks vs)\n\t\t\t(recur (assoc result (first ks) (first vs))\n\t\t\t\t\t(next ks)\n\t\t\t\t\t(next vs))\n\t\t\tresult)))","user":"54eea988e4b024c67c0cf875"},{"code":"(fn oo [a b]\n  (apply hash-map (into [] (flatten (map vector a b)))))","problem":61,"user":"52c42bc2e4b0c2d177d620d0"},{"code":"(fn [coll1 coll2]\r\n    (reduce conj {}\r\n            (map #(vector %1 %2) coll1 coll2)))","problem":61,"user":"4dd61f98535d2dad7130b5c6"},{"problem":61,"code":"(fn m-c \n  ([k v]\n      (m-c k v {}))\n  ([k v m]\n      (if (or (empty? k) (empty? v))\n          m\n          (recur (next k) (next v) (assoc m (first k) (first v))))))","user":"55acd080e4b03311e7b73298"},{"problem":61,"code":"(fn [v1 v2]\n  (loop [vec1 v1 vec2 v2 m {}]\n    (if (or (empty? vec1) (empty? vec2)) m\n      (recur (next vec1) (next vec2) (assoc m (first vec1) (first vec2))))))","user":"57061d20e4b0b0fb43fd0679"},{"code":"(fn [coll1 coll2]\n  (loop [map {}\n         ks (seq coll1)\n         vs (seq coll2)]\n    (if (and ks vs)\n      (recur (assoc map (first ks) (first vs))\n             (next ks)\n             (next vs))\n      map)))","problem":61,"user":"4fc8769be4b0ee37620e1833"},{"problem":61,"code":"#(apply hash-map\n  (let [col (interleave %1 %2)]\n    (if (even? (count col))\n      col\n      (butlast col))))","user":"541ddadbe4b01498b1a71a84"},{"code":"(fn [ks vs] (reduce (fn [m [k v]] (assoc m k v)) {} (partition 2(interleave ks vs))))","problem":61,"user":"521d709ae4b050d5da0427ef"},{"problem":61,"code":"(fn _zipmap [a b]\n  (loop [a (seq a)\n         b (seq b)\n         m (transient {})\n         ]\n    (if (and a b) \n      (recur \n        (next a)\n        (next b)\n        (assoc! m (first a) (first b))\n             )\n      (persistent! m)\n      )\n    )\n  )","user":"5b9ae606e4b0c0b3ffbd4af2"},{"problem":61,"code":"(fn [k v]\n    (apply conj\n      (map hash-map k v)\n      )\n    )","user":"55c3149de4b0e31453f64987"},{"problem":61,"code":"(fn [ks vls]\n  (into {} (map vector ks vls)))","user":"53a83c74e4b047364c044426"},{"code":"(fn [arg1 arg2]\n  (into {} (reverse (apply assoc {} (interleave arg1 arg2)))))","problem":61,"user":"537881a4e4b06839e8705e46"},{"problem":61,"code":"(fn [s1 s2] \n  (loop [s1 s1\n         s2 s2\n         result {}]\n    (if (or (empty? s1) (empty? s2))\n      result\n      (recur (rest s1) \n             (rest s2) \n             (conj {(first s1) (first s2)} result)))))","user":"567d18c9e4b05957ce8c61c4"},{"problem":61,"code":"(fn [map-keys values]\n  (loop [[next-key & remaining-keys :as keys-to-process] map-keys\n         [next-value & remaining-values :as values-to-process] values\n         results {}]\n    (if (or (empty? keys-to-process) (empty? values-to-process))\n      results\n      (recur \n       remaining-keys\n       remaining-values\n       (assoc results next-key next-value)))))","user":"55d06bcbe4b0e31453f64a3a"},{"code":"#(apply array-map (mapcat list % %2))","problem":61,"user":"5102489de4b00c483ae176f6"},{"problem":61,"code":"(fn [x y]\n  (into {} (mapcat #(hash-map % %2) x y)))","user":"539f4e9ee4b0ca733b974498"},{"problem":61,"code":"(fn make-map\n  ([keys values]\n    (make-map nil keys values))\n  ([cur-map [head-keys & tail-keys] [head-values & tail-values]]\n    (if (or (nil? head-keys) (nil? head-values))\n      cur-map\n      (make-map (assoc cur-map head-keys head-values) tail-keys tail-values))))","user":"5c3f6322e4b08cd430848e97"},{"problem":61,"code":"#(loop [ks %1 vs %2 m {}]\n   (if (or (empty? ks) (empty? vs))\n     m\n     (let [fk (first ks) fv (first vs)]\n       (recur (rest ks) (rest vs) (conj m {fk fv})))))","user":"55afc197e4b002ce9d5cbc18"},{"problem":61,"code":"(fn p [a b]\n  (apply hash-map (interleave a b)))","user":"56fc1bc7e4b07572ad1a88dd"},{"problem":61,"code":"(fn [key-vect val-vect]\n  (apply hash-map (interleave key-vect val-vect)))","user":"545e9cf1e4b01be26fd7467f"},{"code":"(fn map-construction [x y]\n  (first (reduce \n   \n   (fn [[a y] xi]\n     (let [fy (first y)]\n           [(if-not (nil? fy)(assoc a xi fy) a) , (rest y)]))\n\n   [{},y]\n   x)))","problem":61,"user":"515bbcd9e4b0388ca8ca1521"},{"code":"(fn [k v]\n  (loop [keycol k vcol v m {}]\n    (if (or (empty? keycol)(empty? vcol))\n      m\n      (recur (rest keycol) (rest vcol)(assoc m (first keycol) (first vcol)))\n      )\n    )\n  )","problem":61,"user":"4db7da66535d1e037afb2187"},{"problem":61,"code":"(fn [ks vs]\n  (apply hash-map\n  (interleave ks vs)))","user":"56967bc0e4b0dcc4269f4131"},{"code":"(fn [k v]\n  (reduce conj {} (map #(clojure.lang.MapEntry. %1 %2) k v)))","problem":61,"user":"5326c5f7e4b09d4e7a9b54f2"},{"problem":61,"code":"(fn i2 [q, w](into {} ((fn i [x,y] (if (and (> (count x) 0) (> (count y) 0)) (concat [[(first x) (first y)]] (i (rest x) (rest y))) '() )) q w)))","user":"54a7efdee4b09f271ff37c9d"},{"problem":61,"code":"#(apply conj {} (map vector % %2))","user":"50aa777fe4b056ee01935866"},{"problem":61,"code":"(fn [keys values]\n  (loop [k keys v values output {}]\n    (if (and true (seq k) (seq v))\n      (recur (rest k) (rest v) (conj output {(first k) (first v)}))\n      output)))","user":"5cf62ecce4b087f62be35aa7"},{"problem":61,"code":"#(apply hash-map (flatten (map (fn [k v] [k v]) %1 %2)))","user":"5885e90de4b0f1effa3b76c5"},{"code":"#(apply merge (map (fn [a b] {a b}) %1 %2))","problem":61,"user":"4fe9f0f6e4b0547ebccb247b"},{"code":"(fn [ks vs] \n  (loop [m {} k ks v vs]\n     (if (and k v)\n        (recur (assoc m (first k) (first v)) \n            (next k) (next v)) m) ))","problem":61,"user":"524f4162e4b0541d1855b806"},{"code":"#(apply conj {} (map vector %1 %2))","problem":61,"user":"4edecdae535d10e5ff6f533c"},{"problem":61,"code":"(fn [ks,vs]\n    (loop [\n           result {}\n           ks_v ks\n           vs_v vs]\n      (if (or (empty? ks_v) (empty? vs_v)) result\n      (recur (assoc result (first ks_v) (first vs_v)) (rest ks_v) (rest vs_v)))))","user":"5c09e555e4b0bdcf453d16fd"},{"problem":61,"code":"(fn  [keys-vec values-vec]\n  (apply hash-map (interleave keys-vec values-vec)))","user":"5acd235ae4b0e27600da7824"},{"code":"(fn [ks vs]\n  (loop [result {}\n         k (seq ks)\n         v (seq vs)]\n    (if (and k v)\n      (recur (assoc result (first k) (first v))\n             (next k)\n             (next v))\n      result)))","problem":61,"user":"525ab6cfe4b0cb4875a45cf9"},{"problem":61,"code":"(fn [keys values] (apply merge (map (fn [a b] {a b}) keys values)))","user":"540ef409e4b0addc1aec6723"},{"problem":61,"code":"(fn [ks vs]\n  (apply assoc \n   {}\n   (reduce\n    (fn [a x] (concat a x))\n    ()\n    (map #(list %1 %2) ks vs))))","user":"56050f06e4b08b23635d3161"},{"problem":61,"code":"(fn [ks vs]\n  (loop [res {}\n         ks ks\n         vs vs]\n    (if (or (empty? ks) (empty? vs))\n      res\n      (recur (assoc res (first ks) (first vs))\n             (rest ks)\n             (rest vs)))))","user":"5f93529ae4b0715f5002d7bc"},{"problem":61,"code":"(fn\n  [keys-seq values-seq]\n  (loop [curr-keys keys-seq curr-values values-seq curr-map {}]\n    (if (or (empty? curr-keys) (empty? curr-values)) \n      curr-map\n      (recur (rest curr-keys) (rest curr-values) (assoc curr-map (first curr-keys) (first curr-values))))\n    )\n  )","user":"60337f1fe4b0d5df2af222c1"},{"problem":61,"code":"(fn [ks vs]\n  (loop [k (first ks)\n         v (first vs)\n         r {k v}\n         kr (rest ks)\n         vr (rest vs)]\n    (if (or (= 0 (count kr)) (= 0 (count vr))) r\n      (recur (first kr) (first vr) (assoc r (first kr) (first vr)) (rest kr) (rest vr)))))","user":"591f05b4e4b09b4ee5954c42"},{"code":"#(into {} (map vec (partition 2 (apply interleave %&))))","problem":61,"user":"5063fe48e4b075d771da6f9e"},{"problem":61,"code":"(fn [keys, values]\n  (loop [my-map {} ix 0]\n\t(if (or (> (inc ix) (count keys)) (> (inc ix) (count values)))      \n      my-map\n      (recur (assoc my-map (nth keys ix) (nth values ix)) (inc ix)))))","user":"5a9ac061e4b0d174b936c7c1"},{"problem":61,"code":";;(fn [s1 s2]\n;;  (apply hash-map  (interleave s1 s2)))\n\n#(apply hash-map  (interleave %1 %2))","user":"5edb07dde4b0c7845d86b0ed"},{"problem":61,"code":"(fn [k v]\n    (reduce (fn [m kv] (assoc m (first kv) (second kv))) {} (map #(vector %1 %2) k v)))","user":"5b4ff637e4b02d533a91bce0"},{"code":"(fn [ks vs]\n  (loop [ks ks vs vs result {}]\n    (if (or (empty? ks) (empty? vs))\n        result\n        (recur (rest ks) (rest vs)\n               (assoc result (first ks) (first vs))))))","problem":61,"user":"4e4b4564535dc968683fc4d3"},{"problem":61,"code":"(fn my-zipmap\n\t[k v]\n\t(persistent! \n\t\t(reduce #(assoc! %1 (first %2) (second %2)) (transient {}) (map list k v))))","user":"58fb7d7ae4b0438e51c2cf7a"},{"code":"#(into {} (map vector %1 %2 ))","problem":61,"user":"533f09e1e4b085b17e897d9a"},{"problem":61,"code":"(fn map-construction [xs ys]\n  (apply hash-map (mapcat vector xs ys)))","user":"518b8561e4b0f028e99addef"},{"problem":61,"code":"(fn [keys values]\n  (loop [keys keys, values values, result {}]\n    (if (or (empty? keys)(empty? values))\n      result\n      (recur (rest keys)(rest values)(assoc result (first keys) (first values))))))","user":"565b371fe4b068f2fe63dbff"},{"problem":61,"code":"(fn map-cons [ks vs]\n  (into {}\n        ((fn vec-map [ks' vs']\n           (if (some empty? [ks' vs'])\n             ()\n             (cons\n              [(first ks') (first vs')]\n              (lazy-seq (vec-map (rest ks') (rest vs'))))))\n         ks vs)))","user":"5641296de4b08d4f616f5ef4"},{"problem":61,"code":"#(apply assoc {} (flatten(map vector % %2)))","user":"53e241a6e4b036ad0777e3f0"},{"problem":61,"code":"(fn [ks vs]\n  (into {} (mapv vector ks vs)))","user":"553dd883e4b0a04f792994e6"},{"code":"(fn [x y]\n  (into {} (mapcat #(hash-map %1 %2) x y)))","problem":61,"user":"5371167fe4b0fc7073fd6ea7"},{"code":"(fn [keys vals] \n  (loop [map {}\n         keys keys\n         vals vals]\n    (if (or (empty? keys) (empty? vals))\n        map\n        (recur (assoc map (first keys) (first vals)) (rest keys) (rest vals)))))","problem":61,"user":"4eed26af535d93acb0a668bb"},{"code":"(fn zm [s1 s2]\r\n   (reduce  #(assoc %1 (first %2) (second %2)) {}\r\n            (map list s1 s2)))","problem":61,"user":"4fcc6cb3e4b0ee37620e1861"},{"problem":61,"code":"(fn [m n]\n  (loop [a m b n r {}]\n    (if (or (empty? a) (empty? b))\n      r\n      (recur (rest a) (rest b) (assoc r (first a) (first b))))))","user":"5683d2a9e4b0945ebc182aa0"},{"code":"(fn [v1 v2]\n  (let [v (interleave v1 v2)]\n    (apply assoc {} v)))","problem":61,"user":"4e9519b4535dbda64a6f6b2d"},{"problem":61,"code":"(fn \n  [xs1 xs2]\n  (apply merge\n         (mapv #(assoc {} %1 %2) xs1 xs2)))","user":"5484c3b2e4b0e286459a11a2"},{"code":"#(apply merge\n     (map hash-map % %2))","problem":61,"user":"52c73194e4b0c2d177d6211e"},{"code":"(fn f [a b]\n  (if (or (empty? a) (empty? b))\n    {}\n    (assoc (f (rest a) (rest b)) (first a) (first b))))","problem":61,"user":"4e8dd6cb535d65386fec213b"},{"code":"(fn [col1 col2] (apply hash-map (mapcat #(list %1 %2) col1 col2)))","problem":61,"user":"52727d52e4b03e8d9a4a7439"},{"problem":61,"code":"(fn myzip [keys values] (apply hash-map (interleave keys values)))","user":"5da05bcce4b000c986472bd0"},{"problem":61,"code":"(letfn \n  [(f [[k & ks :as kss] [v & vs :as vss]] \n      (if (and (seq kss) (seq vss)) \n        (conj (f ks vs) {k v}) {}))] f)","user":"540470dae4b0addc1aec6658"},{"code":"(fn my-zipmap [a b]\n  (if (or (empty? a) (empty? b))\n    {}\n    (assoc (my-zipmap (rest a) (rest b)) (first a) (first b))))","problem":61,"user":"4ec6559a535d6d7199dd36c9"},{"problem":61,"code":"#(into\n  {}\n  (map vector %1 %2))","user":"5c51c930e4b0fb8c5ffd99ce"},{"code":"(fn [ks vs] (apply merge (map hash-map ks vs)))","problem":61,"user":"522404d8e4b01819a2de42c0"},{"problem":61,"code":"(fn[x y](apply assoc {} (interleave x y)))","user":"60195030e4b0bf4ca6b10920"},{"problem":61,"code":"(fn [lk lv]\n  (loop [m {}\n         mk lk\n         mv lv]\n    (if-not (and mk mv)\n      m\n      (recur (into m {(first mk) (first mv)})\n             (next mk) (next mv)))))","user":"56051095e4b08b23635d3162"},{"problem":61,"code":"(fn [a b] (into {} (map #(hash-map %1 %2) a b)))","user":"58c71509e4b021aa9917ed6e"},{"problem":61,"code":"(fn construct [s1 s2]\n  (loop [r1 s1\n        r2 s2\n        mp {}]\n    (if (or (empty? r1) (empty? r2))\n      mp\n      (recur \n        (rest r1) \n        (rest r2)\n        (assoc mp (first r1) (first r2))  \n      )\n    )\n  )\n)","user":"60335b35e4b0d5df2af222bf"},{"problem":61,"code":"(fn [k v] (apply hash-map (mapcat (fn [m n] (vector m n)) k v)))","user":"5b100648e4b0cc2b61a3be17"},{"problem":61,"code":"(fn [l1 l2] (reduce #(apply assoc (cons %1 %2)) {} (map list l1 l2)))","user":"54edcf96e4b024c67c0cf866"},{"problem":61,"code":"(fn zm [k v] (if (and (first k) (first v)) (conj (zm (rest k) (rest v)) [(first k) (first v)]) {}))","user":"5646dff3e4b0284900eef615"},{"problem":61,"code":"(fn [x y]\n    (reduce (fn [a [w z]] (assoc a w z)) \n            {} \n            (map #(vector %1 %2) x y)))","user":"603ae21de4b0d5df2af222fb"},{"problem":61,"code":"(fn [col1 col2]\n   (apply assoc {} (interleave col1 col2)))","user":"5db98f39e4b010eb3c36cd53"},{"problem":61,"code":"#(into (sorted-map) (map hash-map %1 %2))","user":"5cf53196e4b087f62be35a94"},{"code":"(fn doit [x y] (apply hash-map (interleave x y)))","problem":61,"user":"4f601623e4b0defedf855fa3"},{"problem":61,"code":"(fn [ks vs] (reduce merge {} (map (fn [k v] {k v}) ks vs)))","user":"53a5bc3ae4b0ef122a8689c3"},{"code":"(fn [x y] (reduce merge (map hash-map x y)))","problem":61,"user":"4ec4d723535dcc7ae8597d65"},{"problem":61,"code":"(fn [x y]\n  (into {} (map #(hash-map %1 %2) x y)))","user":"57fc5e42e4b0d3187e900997"},{"code":"(fn [c1 c2]\n  (reduce #(assoc % (first %2) (last %2))    {}  (map #( list %1 %2) c1 c2)))","problem":61,"user":"5007cdb9e4b0b17c647f5227"},{"code":"(fn [a b]\n          (apply assoc {} (interleave a b)))","problem":61,"user":"514d7e29e4b019235f6c0587"},{"problem":61,"code":"(fn [xs ys]\n   (apply hash-map (mapcat #(list %1 %2) xs ys))\n   )","user":"5ac85708e4b0e27600da77ac"},{"problem":61,"code":"(fn [coll1 coll2]\n  (reduce merge {} (map hash-map coll1 coll2)))","user":"55a372f1e4b0acc240e31537"},{"code":"(fn Mp [K V]\n  (let [[k & ks] K,[v & vs] V]\n    (cond\n      (or (empty? vs) (empty? ks)) (assoc {} k v)\n      :else (assoc (Mp ks vs) k v))))","problem":61,"user":"4fda016ae4b05e33b9224f42"},{"problem":61,"code":"(fn map-const [v1 v2]\n  (loop [col1   v1\n         col2   v2\n         res    {}]\n    (if (or (empty? col1) (empty? col2)) res (recur (rest col1) (rest col2) (assoc res (first col1) (first col2))))))","user":"56a94562e4b07966d5a8a074"},{"problem":61,"code":"(fn buildMap\n  [lst1 lst2]\n  (apply hash-map (interleave lst1 lst2)))","user":"59e0111ae4b08badc2a0c4e4"},{"code":"#(loop [hs {}\n        ks %1\n        vs %2]\n   (if (and ks vs)\n     (recur (assoc hs (first ks) (first vs))\n            (next ks)\n            (next vs))\n     hs))","problem":61,"user":"5012614ee4b02a085b99dc79"},{"code":"(fn [k v] (apply merge (map #(assoc {} %1 %2) k v)))","problem":61,"user":"502a9fdee4b095a7adb898b4"},{"code":"(fn [a b] (into {} (map (fn [x y] (vector x y)) a b)))","problem":61,"user":"50aa60bee4b056ee01935865"},{"problem":61,"code":"(fn [k v] (into {}(for [i (range (min (count k) (count v)))] [(nth k i) (nth v i)])))","user":"5751fda4e4b02ea114799295"},{"problem":61,"code":"(fn f [ks vs]\n            (->> (map vector ks vs)\n                 (into {})))","user":"53684a2fe4b0243289761e8c"},{"code":"(fn [ks vs]\n  (let [s (min (count ks) (count vs))]\n    (reduce #(assoc % (get ks %2)\n             \t\t  (get vs %2))\n            {} (range s))))","problem":61,"user":"52f818a6e4b047fd55836fcc"},{"problem":61,"code":"(fn zmap\n    [l1 l2]\n    (apply array-map (interleave l1 l2))\n    )","user":"55ddc5cbe4b050e68259b3d0"},{"code":"(fn [x y] (loop [sx x sy y res {}] (if (or (= () sx)(= () sy)) res (recur (rest sx)(rest sy)(conj res {(first sx) (first sy)})))))","problem":61,"user":"51a7f74be4b08d8ec191b802"},{"problem":61,"code":"#(into {} (mapcat (comp list vec list) %1 %2))","user":"541619e8e4b01498b1a719f9"},{"code":"(fn [coll1 coll2] (apply hash-map (mapcat #(list %1 %2) coll1 coll2)))","problem":61,"user":"4fa09916e4b0dcca54ed6d4e"},{"code":"(fn [x y] (loop [keyi 0 result {}] (cond (= keyi (count x)) result (= keyi (count y)) result true (recur (inc keyi) (merge (hash-map (nth x keyi) (nth y keyi)) result)))))","problem":61,"user":"4e975bce535dbda64a6f6b53"},{"code":"(fn [k v]\n  (loop [k k\n         v v \n         res {}]\n    (if (or (empty? k) (empty? v))\n      res\n      (recur (rest k) (rest v) (assoc res (first k) (first v))))))","problem":61,"user":"538d464ee4b0b51d73faae69"},{"code":"(fn [k v]\n  (loop [h {}\n         k (seq k)\n         v (seq v)]\n    (if (and k v)\n      (recur (assoc h (first k) (first v))\n             (next k)\n             (next v))\n      h)))","problem":61,"user":"4ff3e771e4b0678c553fc356"},{"problem":61,"code":"#(->> (interleave % %2)\n     (apply hash-map))","user":"5470b3d0e4b00cfc9eacc1bb"},{"problem":61,"code":"(fn [xs ys] (into {} (map #(vec [%1 %2]) xs ys)))","user":"549c1713e4b0f3d1d8e70f82"},{"problem":61,"code":"(comp (partial apply array-map) interleave)","user":"55cdc576e4b0e31453f64a1f"},{"code":"(fn [keys vals] (into {} (map vector keys vals)))","problem":61,"user":"4ebcb8ff535dfed6da9c6d8a"},{"problem":61,"code":"(fn [ks vs]\n        (into {} (map (fn [k v] {k v}) ks vs)))","user":"546c4377e4b00cfc9eacc177"},{"problem":61,"code":"(fn [the-keys the-values]\n  (reduce merge {} (map #(hash-map %1 %2) the-keys the-values)))","user":"5054d243e4b0b1b9d1860eb5"},{"code":"#(loop [m {} z (interleave %1 %2)]\n      (if (empty? z) m\n        (recur (into m (assoc {} (first z) (second z))) (drop 2 z))))","problem":61,"user":"51b66b31e4b02e5820733406"},{"code":"(fn my-zipmap [col1 col2]\n  (apply hash-map\n       (reduce (fn [a b] (concat a b)) []\n               (map vector col1 col2))))","problem":61,"user":"522d0360e4b0806774ddfef7"},{"code":"(fn [x y] (into {}(for[i (range (min (count x) (count y)))] [(nth x i) (nth y i)])))","problem":61,"user":"52f9ce6de4b047fd55836ff0"},{"code":"(fn [x1 x2]\n       (loop [seq1 x1\n        seq2 x2\n\t      hm {}]\n\t (if (and (not (empty? seq1)) (not (empty? seq2)))\n\t   (recur (rest seq1) (rest seq2) (assoc hm (first seq1) (first seq2)))\n\t   hm)))","problem":61,"user":"4eae2f9e535d7eef30807324"},{"code":"(fn [coll1 coll2]\n  (apply hash-map (interleave coll1 coll2)))","problem":61,"user":"4f4f08c8e4b03ad3f0c10cd8"},{"code":"(fn [ks vs]\n  (into {}\n    (map hash-map ks vs)))","problem":61,"user":"53727c0be4b06d7f452d9dfa"},{"problem":61,"code":"(fn count-occurrences \n    ([x x1] (count-occurrences x x1 0 {}))\n\n    ([x x1 i y]\n        (cond (< i (min (count x) (count x1)))\n            (count-occurrences x x1 (inc i) (conj y {(nth x i) (nth x1 i)}))\n            :else y\n        )\n    )\n)","user":"5f0cb4f3e4b0f30dddfb5d4e"},{"code":"(fn [x y] (apply array-map (flatten (map vector x y))))","problem":61,"user":"535920b2e4b04ce2eb3ed294"},{"problem":61,"code":"(fn [ks vs] (apply hash-map (mapcat list ks vs)))","user":"552356fae4b0882d96d091af"},{"code":"#(into {} (map hash-map % %2))","problem":61,"user":"4e307313535deb9a81d77f14"},{"code":"#(apply assoc {}\r\n  (interleave %1 %2))","problem":61,"user":"4ddc56e1535d02782fcbea04"},{"problem":61,"code":"(fn [a b] (let [c (interleave a b), d (cons {} c)] (apply assoc d)))","user":"56c4f971e4b05cc29241ee9d"},{"problem":61,"code":"(fn [keys vals]\n   (loop [ks keys\n          vs vals\n          result {}]\n     (if (or (empty? ks) (empty? vs))\n       result\n       (recur (rest ks)\n              (rest vs)\n              (assoc result (first ks) (first vs))))))","user":"5e3ef7d4e4b01d43a70e8e2d"},{"code":"(fn [ks vs]\r\n  (into {} (map vector ks vs)))","problem":61,"user":"4fee04a0e4b0678c553fc308"},{"code":"(fn map-construct [v1 v2]\n  (apply hash-map (interleave v1 v2)))","problem":61,"user":"53713ebee4b0fc7073fd6ead"},{"problem":61,"code":"#(into (hash-map) (apply map vector %&))","user":"605b7a90e4b079a07f8593fc"},{"problem":61,"code":"(fn zm [keys values]\n  (loop\n    [rkeys keys\n     rvalues values\n     result {}]\n    (cond\n      (or (empty? rkeys) (empty? rvalues)) result\n      :else (recur (rest rkeys) (rest rvalues) (assoc result (first rkeys) (first rvalues)))\n      )\n    )\n  )","user":"576d24ede4b0979f8965155b"},{"code":"#(into {} (map  vector % %2))","problem":61,"user":"51c09719e4b0c9c82288293c"},{"problem":61,"code":"(fn [sleutels waardes]\n  (loop [sleutels sleutels waardes waardes out {}] \n    (if (or (empty? sleutels) (empty? waardes)) \n      out \n      (recur (rest sleutels) (rest waardes) (assoc out (first sleutels) (first waardes))))\n  )\n)","user":"58186016e4b0c0e9c07b83ad"},{"problem":61,"code":"#(apply assoc {} (interleave % %2) )","user":"51e1c176e4b06a68e693eafb"},{"problem":61,"code":"(fn [ks vs] (into {} (map (fn [k v] (vector k v)) ks vs)))","user":"569d2283e4b0542e1f8d1474"},{"code":"(fn [k v] (apply array-map (apply concat {} (map #(list %1 %2) k v))))","problem":61,"user":"51a8f0c6e4b08d8ec191b821"},{"problem":61,"code":"(fn [x y]\n  (loop [c x d y e {}]\n    (if (or (empty? c) (empty? d))\n      e\n      (recur (rest c)\n             (rest d)\n             (assoc e (first c) (first d))))))","user":"607d6bc1e4b03d835a6eaecc"},{"problem":61,"code":"(fn [x y]\n  (into {} (map vec (partition 2 (interleave x y)))))","user":"5297dcc5e4b02ebb4ef75047"},{"problem":61,"code":"(fn [ks vs]\n  (reduce conj {} (mapv (fn [k v] (assoc {} k v)) ks vs)))","user":"56cf115de4b0ea9b8538f765"},{"problem":61,"code":"(fn [keyx valx]\n  (into (hash-map) (map #(hash-map %1 %2) keyx valx)))","user":"5db9a6c3e4b010eb3c36cd56"},{"problem":61,"code":"(fn [& args] (apply conj (apply map (fn [x,y] {x y}) args)))","user":"56ec0af1e4b04a395b9a0430"},{"code":"(fn zm [ks vs]\n  (reduce conj (map #(assoc {} %1 %2) ks vs)))","problem":61,"user":"511aa2a4e4b0c87c59c9670a"},{"problem":61,"code":"(fn [x y]\n  (loop [rst {} a x b y]\n    (if (or (= 0 (count a)) (= 0 (count b))) rst\n      (recur (assoc rst (first a) (first b)) (rest a) (rest b)))))","user":"54381729e4b032a45b869310"},{"problem":61,"code":"(fn [ks vs] \n   (reduce-kv (fn [memo ind val]\n                (if (< ind (count vs))\n                  (into memo {val (nth vs ind)})\n                  memo))                 \n              {} \n              ks))","user":"51f38193e4b0fca5e8b48226"},{"problem":61,"code":"#(apply merge \n        (map hash-map %1 %2))","user":"576e607ae4b0979f89651579"},{"problem":61,"code":"(fn [keys vals]\n   (loop [k keys\n          v vals\n          acc {}]\n     (cond\n       (or (empty? v) (empty? k)) acc\n       :else (recur (rest k) (rest v) (assoc acc (first k) (first v))))))","user":"5a8bc2a1e4b05369db4d24ef"},{"problem":61,"code":"#(into {} (mapcat  hash-map % %2))","user":"5643ba10e4b0018b46ad8bff"},{"problem":61,"code":"(fn [ks vs] ((fn [[k & ks] [v & vs] m] (if (or (nil? k) (nil? v)) m (recur ks vs (assoc m k v)))) ks vs {}))","user":"53f78944e4b0de5c41848561"},{"code":"#(reduce merge (map (partial assoc {}) %1 %2) )","problem":61,"user":"4e9fde3c535d7eef3080729b"},{"problem":61,"code":"(fn [x y] {x y} \n    (reduce merge (map (fn [a b] {a b}) x y))\n )","user":"5a6afb1de4b0512ff01cda2f"},{"code":"#(reduce conj (map (fn [a b] {a b}) %1 %2))","problem":61,"user":"4e5f034b535d8a8b8723a2d9"},{"code":"(fn [k v]\r\n   (let [s (min (.size k) (.size v))]\r\n     (reduce merge (for [i (range 0 s)]\r\n     {(get k i) (get v i)})))\r\n)","problem":61,"user":"510a6bece4b06956752d35af"},{"problem":61,"code":"(fn [x y] \n  (into {} (map vector x y)))","user":"555df9c8e4b0a2eb076a39b2"},{"code":"(fn [ks vs]                                     \n  (reduce conj {} (map #(hash-map %1 %2) ks vs)))","problem":61,"user":"5141abf1e4b02fd87f5064c3"},{"code":"(fn [s1 s2]\n  (apply merge (map hash-map s1 s2)))","problem":61,"user":"524ab5f2e4b09eba1c02239d"},{"code":"(fn [x y]\n  ((fn [x y result]\n    (if (or (empty? x) (empty? y))\n        result\n        (recur (rest x)\n               (rest y)\n               (assoc result (first x) (first y)))))\n  x y {}))","problem":61,"user":"4e73a9dc535dff18050a9c77"},{"problem":61,"code":"#(apply hash-map (flatten (interleave %1 %2)))","user":"54ef4a1ee4b024c67c0cf883"},{"code":"(fn [s1 s2] (reduce conj (map (fn[a b] {a b})  s1 s2)))","problem":61,"user":"51f59607e4b0abb92f97f9d5"},{"problem":61,"code":"(fn [f f1]\n  (apply hash-map (interleave f f1))\n  \n  )","user":"5f727be9e4b02876ed9fd08d"},{"problem":61,"code":"(fn [keys values]\n  (loop [ks keys\n         vs values\n         result {}]\n    (if (or (empty? ks) (empty? vs))\n      result\n      (recur (rest ks) (rest vs) (assoc result (first ks) (first vs))))))","user":"5524120fe4b0882d96d091b7"},{"problem":61,"code":"(fn [keys values] (reduce merge (map (partial assoc {}) keys values)))","user":"58db362be4b0a4d5acaab675"},{"problem":61,"code":"(fn [x y]\n  (reduce #(assoc %1 (first %2) (second %2)) {} (map #(vector %1 %2) x y)))","user":"564a5a09e4b0284900eef656"},{"problem":61,"code":"#(loop [x %1 y %2 o {}]\n  (if (or (empty? x) (empty? y)) \n    o\n    (recur (rest x) (rest y) (conj o [(first x) (first y)]))))","user":"5f3567d6e4b0574c87022c44"},{"code":"#(loop [[kh & kt] %1, [vh & vt] %2, res {}]\n  (if (and kh vh)\n(recur kt vt (assoc res kh vh))\nres\n))","problem":61,"user":"4eabb245535d7eef30807319"},{"code":"(fn [c1 c2] (reduce (fn [a c] (conj a c)) (map (fn [k v] {k v}) c1 c2)))","problem":61,"user":"53629381e4b0243289761e54"},{"problem":61,"code":"(fn\n  [keys vals]\n  (into {} (map vec (partition 2 (interleave keys vals)))))","user":"59ea07c9e4b0249b72820756"},{"problem":61,"code":"(fn zipmap2 [keys values]\n  (into {} (map #(assoc {} %1 %2) keys values)))","user":"541f5b37e4b01498b1a71a97"},{"problem":61,"code":"(fn [vec1 vec2]\n  (let [min1 (min (count vec1) (count vec2))]\n    (apply hash-map (flatten (map #(vec[%1 %2]) (take min1 vec1) (take min1 vec2))))))","user":"57f52d3be4b0903ccab3dce7"},{"problem":61,"code":"( fn [ks vs]\n  (into {} (map vector ks vs)))","user":"5ce5b43be4b0a17bb84e2b7a"},{"problem":61,"code":"(fn [k v]\n  (loop [kx k vx v res {}]\n    (if (or (empty? kx) (empty? vx))\n      res\n      (recur (rest kx) (rest vx) (assoc res (first kx) (first vx))))))","user":"5675cdf1e4b05957ce8c614d"},{"code":"(fn [ks vs]\n  (apply array-map (interleave ks vs)))","problem":61,"user":"4dadb891c9a9d6ed3699dc57"},{"problem":61,"code":"(fn [ks vs]\n  ((fn buildmap [ks vs m]\n     (if (or (empty? ks) (empty? vs))\n       m\n       (buildmap (rest ks) (rest vs) (assoc m (first ks) (first vs))))) ks vs {}))","user":"5c7ef3f3e4b0d597f478cad7"},{"problem":61,"code":"#(apply hash-map (interleave% %2))","user":"5507cfd3e4b021ccfedb96ad"},{"problem":61,"code":"(fn mmap [kys vls]\n  (apply assoc (cons {} (interleave kys vls))))","user":"540efe2ee4b0addc1aec6724"},{"code":"(fn [k-coll v-coll]\n  (apply hash-map (interleave k-coll v-coll)))","problem":61,"user":"50b79c5fe4b0cf3e51c3046c"},{"code":"(fn [l1 l2]\r\n  (loop [_l1 l1\r\n         _l2 l2\r\n         res {}]\r\n\r\n    (if (or (empty? _l1) \r\n            (empty? _l2))\r\n      res\r\n      (recur (rest _l1) \r\n             (rest _l2)\r\n             (assoc res (first _l1) (first _l2))))))","problem":61,"user":"50576483e4b001218172198b"},{"problem":61,"code":"(fn [map-keys map-args] (reduce #(assoc %1 (first %2) (second %2)) {} (map vector map-keys map-args)))","user":"5a21d34ce4b0ff51aa4b32b9"},{"problem":61,"code":"(fn [key-vec value-vec]\n  (into {} (map vector key-vec value-vec)))","user":"55ce2b6de4b0e31453f64a26"},{"code":"#(apply hash-map(flatten( map vector %1 %2)))","problem":61,"user":"52ca720fe4b071a8d36bd3e2"},{"problem":61,"code":";(fn [col1 col2] (reduce conj {} (map #(vector %1 %2) col1 col2)))\n#(apply hash-map (interleave %1 %2))","user":"5d0beecee4b0cc9c91588239"},{"problem":61,"code":"#(apply (partial assoc {}) (flatten (map vector %1 %2)))","user":"59fa7fb0e4b0ca45a743a366"},{"problem":61,"code":"(fn [ks vs]\n  (apply merge (map (fn [k v] {k v}) ks vs)))","user":"5bb25684e4b0a20761a2350d"},{"code":"(fn make-map[a-seq b-seq]\n \t(apply hash-map (mapcat #(list %1 %2) a-seq b-seq))\n )","problem":61,"user":"52763696e4b03e8d9a4a74d7"},{"code":"(fn [a b]\n  (let [c (min (count a) (count b))]\n       (loop [curr (- c 1)\n              my-map []]\n         (if (< curr 0)\n           (apply assoc {} my-map)\n           (recur (- curr 1)\n                  (conj (conj my-map (get a curr)) (get b curr)))))))","problem":61,"user":"4f0324d2535dcb61093f6a69"},{"code":"(fn mc [ks vs]                                     \n    (cond                                              \n      (or (nil? ks) (nil? vs)) (hash-map)                             \n      :else (assoc (mc (next ks) (next vs)) (first ks) (first vs))))","problem":61,"user":"4e444c11535dc968683fc4a9"},{"problem":61,"code":"(fn [a b] (into (sorted-map) (map vector a b)))","user":"5fab7ea6e4b08cb800c85ad8"},{"code":"(fn m2 [a b]\n  (cond \n   (empty? a) {}\n   (empty? b) {}\n   :else (assoc (m2 (rest a)\n                    (rest b))\n           (first a)\n           (first b))))","problem":61,"user":"5374adc3e4b06d7f452d9e27"},{"problem":61,"code":"#(apply hash-map (vec (mapcat vector %1 %2)))","user":"5414b7c4e4b01498b1a719ed"},{"problem":61,"code":"#(into {} (map (comp vec list) %1 %2))","user":"606e0a42e4b069485764de19"},{"problem":61,"code":"#(apply hash-map (flatten (mapv vector %1 %2)))","user":"56f15eade4b04a395b9a048e"},{"code":"(fn [ka va] (reduce (fn [c [k v]] (assoc c k v)) {} (map vector ka va)))","problem":61,"user":"51f2851fe4b0210f90e7454b"},{"problem":61,"code":"(fn [ks vs] (let [kvs (map list ks vs)]\n              (reduce (fn [a y]\n                        (assoc a (first y) (last y))\n                        ) {} kvs)\n              ))","user":"57b8b008e4b0fbc9809a27e6"},{"code":"(fn [col1 col2] \n  (reduce merge (map  #(assoc {} %1 %2) col1 col2)))","problem":61,"user":"4fb2f9b2e4b081705acca294"},{"problem":61,"code":"#(apply hash-map (interleave (seq %1) (seq %2)))","user":"55b1ab40e4b0da326a65cf6e"},{"problem":61,"code":"(fn zip-map [seq1 seq2]\n  (if (or (empty? seq1) (empty? seq2)) nil\n  (conj (hash-map (first seq1) (first seq2)) (zip-map (rest seq1) (rest seq2)) ))\n\n\n)","user":"575ebba3e4b08062f99a4e70"},{"code":";(fn [ks vs]\n;  (reduce (fn [m [k v]] (assoc m k v)) {} (map vector ks vs)))\n\n(fn [ks vs]\n  (reduce #(apply assoc %1 %2) {} (map vector ks vs)))","problem":61,"user":"5312cdaae4b08068f379ed03"},{"problem":61,"code":"#(->> (map (fn[x y]{x y}) %1 %2) (apply merge))","user":"58d1c1b1e4b03c36ff7e58ef"},{"problem":61,"code":"(fn [left right]\n    (loop [l left\n           r right\n           out {}]\n      (if (or (empty? l) (empty? r))\n        out\n        (recur (rest l) (rest r) (assoc out (first l) (first r))))))","user":"5df75fd8e4b0a607a9a45c92"},{"problem":61,"code":"#(apply assoc {}(interleave %1 %2))","user":"5481be5fe4b0e286459a1172"},{"problem":61,"code":"(fn my-zipmap [keys vals]\n  (loop [my-map {}\n         my-keys (seq keys)\n         my-vals (seq vals)]\n    (if (and my-keys my-vals)\n      (recur (assoc my-map (first my-keys) (first my-vals))\n             (next my-keys)\n             (next my-vals))\n      my-map)))","user":"53f17931e4b0742d9025b0dd"},{"problem":61,"code":"(fn [ks vs]\n  (into {} (for [idx (range (min (count ks) (count vs)))] [(nth ks idx) (nth vs idx)])))","user":"5cbb0436e4b026601754b9cc"},{"problem":61,"code":"(fn mapcon [ks vs] (let [index (min (count ks) (count vs))] (loop [i 0 result {}]\n                                                               (if (>= i index)\n                                                                 result\n                                                                 (recur (inc i) (assoc result (nth ks i) (nth vs i)))))))","user":"58b2f085e4b0ebc645576d15"},{"code":"#(into '{} (map (fn [a b] {a b}) %1 %2))","problem":61,"user":"4f409e29e4b0e243712b1fb6"},{"problem":61,"code":"(fn[m n]\n  (into {} (map vector m n)))","user":"5a99b844e4b0d174b936c7ab"},{"code":"(fn h\n[x y]\n(loop [map {}\nks (seq x)\nvs (seq y)]\n(if (and ks vs)\n          (recur (assoc map (first ks) (first vs))\n\t               (next ks)\n\t               (next vs))\n\t        map)))","problem":61,"user":"502d39f8e4b0d96a44ab2032"},{"code":"(fn [ns ms] (loop [xs ns, ys ms, acc {}]\n\t\t\t  (if (or (empty? xs) (empty? ys))\n\t\t\t      acc\n\t\t\t    (recur (rest xs) (rest ys) (assoc acc (first xs) (first ys))))))","problem":61,"user":"4eeccfc0535d93acb0a668b5"},{"problem":61,"code":"(fn [xs ys] (apply hash-map (mapcat #(list %1 %2) xs ys)))","user":"548cd813e4b0e286459a1211"},{"code":"(fn my-zipmap\n  [k v]\n  (into {} (map hash-map k v)))","problem":61,"user":"5300b750e4b0d8b024fd3711"},{"problem":61,"code":"(fn construct-map [key-coll val-coll]\n  (apply hash-map (mapcat vector key-coll val-coll)))","user":"557e56aae4b05c286339e0d5"},{"problem":61,"code":"#(loop [l1 %1 l2 %2 o {}]\n        (if (or (empty? l1) (empty? l2))\n            o\n            (recur\n                (rest l1)\n                (rest l2)\n                (assoc o (first l1) (first l2)))))","user":"5b083513e4b0cc2b61a3bdb4"},{"problem":61,"code":"#(loop [ks %\n         vs %2\n         result {}]\n    (if (and ks vs)\n      (recur (next ks)\n             (next vs)\n             (assoc result (first ks) (first vs)))\n      result))","user":"502ea967e4b06efe12e8cc76"},{"problem":61,"code":"(fn [a b & args]\n  (if (and (seq a) (seq b))\n    (recur (rest a) (rest b) (assoc args (first a) (first b)))\n    args))","user":"5479c58de4b0c51c1f4d72c7"},{"code":"(fn [& l] (apply hash-map  (apply mapcat list l)))","problem":61,"user":"50ef3e5de4b0a78662fa2652"},{"problem":61,"code":"(fn [as bs] (apply hash-map (interleave as bs)))","user":"54d5fbe9e4b0a52adc2e2014"},{"code":"(fn [x y] (into {} (map #(hash-map % %2) x y)))","problem":61,"user":"52c60945e4b0c2d177d62108"},{"code":"(fn construct-map [ks vs]\n  (apply hash-map (flatten (map vector ks vs))))","problem":61,"user":"516385cee4b055933a9ca02d"},{"problem":61,"code":"(fn map-construct\n  [c1 c2]\n  (reduce conj (map hash-map c1 c2)))","user":"5d6d2e11e4b04d129b00f2ba"},{"code":"(fn[x y] (apply assoc {} (flatten (partition 2 (interleave x y)))))","problem":61,"user":"529952a4e4b02ebb4ef75081"},{"code":"(fn zipmap2 [keys vals]\n    (loop [map {}\n           ks (seq keys)\n           vs (seq vals)]\n      (if (and ks vs)\n        (recur (assoc map (first ks) (first vs))\n               (next ks)\n               (next vs))\n        map)))","problem":61,"user":"4f8ac2bde4b02e764a0a5172"},{"problem":61,"code":"(fn f [k v]\n  (loop [v v k k result '{}]\n    (if (or (empty? v) (empty? k))\n      result\n      (recur (rest v) (rest k) (conj result (hash-map (first k) (first v)))))))","user":"563d12f9e4b0bfe05bf11845"},{"problem":61,"code":"(fn [ks vs]\n    (reduce (fn [accu [k v]] (assoc accu k v))\n            {}\n            (partition 2 (interleave ks vs))))","user":"5d883119e4b0915913b1d3a6"},{"problem":61,"code":"(fn [x y]\n  (loop [x x\n         y y\n         acc {}]\n    (if (or (empty? x) (empty? y))\n      acc\n      (recur (rest x) (rest y) (assoc acc (first x) (first y))))))","user":"51ca5378e4b08b1cbd0d9480"},{"code":"(fn myzip [ks vs]\n  (reduce merge (map #(hash-map %1 %2) ks vs)))","problem":61,"user":"52f07ccee4b05e3f0be25edf"},{"code":"(fn my-zipmap\n  [coll1 coll2]\n  (apply conj {} (map hash-map coll1 coll2)))","problem":61,"user":"4edf5dc6535d10e5ff6f5340"},{"problem":61,"code":"(fn [ks vs]\n  (reduce\n      (fn [s [k v]] (assoc s k v))\n      {}\n      (map list ks vs)))","user":"53d78b64e4b0e771c3025466"},{"code":"(fn [ks vs]\n  (apply assoc {} (interleave ks vs)))","problem":61,"user":"4ef6f5ea535dced4c769f250"},{"problem":61,"code":"(fn [fields values] (apply hash-map (interleave fields values)))","user":"55306f9de4b076ab5578f814"},{"problem":61,"code":"(fn [keys vals]\n   (reduce #(assoc %1 (first %2) (last %2)) {}\n           (map #(conj [] %1 %2) keys vals)))","user":"5dd90651e4b0948ae9d9ad97"},{"problem":61,"code":"(fn f\n  [xs ys]\n  (cond\n    (or (empty? xs) (empty? ys)) ()\n    :else (conj {(first xs) (first ys)} (f (rest xs) (rest ys)))))","user":"60486e8ae4b02d28681c77db"},{"code":"(fn C [ks vs]\n  (cond (empty? ks) {}\n        (empty? vs) {}\n        :else (assoc (C (rest ks) (rest vs))\n                (first ks)\n                (first vs))))","problem":61,"user":"51a4416ae4b0def3c5c5868c"},{"code":"(fn build [k v]\n  (if (and (seq k) (seq v))\n    (assoc (build (rest k) (rest v))\n           (first k)\n           (first v))))","problem":61,"user":"505f55d3e4b08f2a82ad10b0"},{"problem":61,"code":"(fn [s1 s2]\n  (apply hash-map (interleave s1 s2)))","user":"53403f42e4b085b17e897da8"},{"code":"(fn [l1 l2] (reduce #(conj %1 %2) {} (map vector l1 l2)))","problem":61,"user":"51b0fc95e4b0c53cf2e68a72"},{"problem":61,"code":"(fn map-constr\n  ; \"takes a vector of keys and a vector of valuesand constructs a map of them\"\n  [x1 x2]\n  (apply hash-map (interleave x1 x2)))","user":"5bbbcecee4b0a20761a23611"},{"code":"(fn [k v]\n  (loop [map {}\n        ks (seq k)\n        vs (seq v)]\n    (if (and ks vs)\n      (recur (assoc map (first ks) (first vs))\n        (next ks)\n        (next vs))\n    map)))","problem":61,"user":"4f3242bae4b0d6649770a08f"},{"code":"(fn [keys values]\n  (loop [acc {} k keys v values]\n    (if (or (empty? k) (empty? v))\n      acc\n      (recur (assoc acc (first k) (first v)) (rest k) (rest v)))))","problem":61,"user":"52262a6ce4b06a1ecd0c4e7d"},{"code":"(fn my-zipmap [ks vs] (into {} (map vector ks vs)))","problem":61,"user":"4ed188c8535d44c135fd68cf"},{"code":"#(apply (partial assoc {}) (mapcat list %1 %2))","problem":61,"user":"5142ea50e4b0c172af7558ca"},{"code":"(fn [k v]\n    (reduce merge\n       (map #(assoc {} %1 %2) k v)\n       )\n     )","problem":61,"user":"4f9920a3e4b0dcca54ed6cfc"},{"code":"(fn [ks vs]\n  (reduce #(apply assoc %1 %2)\n          {}\n          (partition 2 (interleave ks vs))))","problem":61,"user":"4f1bb9d8535d64f60314647d"},{"code":"#(loop [kv %1 vv %2 r {}]\n   (if (or (empty? kv) (empty? vv))\n     r\n     (recur (rest kv) (rest vv) (assoc r (first kv) (first vv)))))","problem":61,"user":"52c81954e4b0c2d177d6212e"},{"code":"(fn [keys vals] (into {} (map #(vector %1 %2) keys vals)))","problem":61,"user":"4ea092f4535d7eef308072a6"},{"code":"(fn [ks vs]\n  (let [cnt (if (< (count ks) (count vs))\n              (count ks)\n              (count vs))]\n    (into {} (for [x (range cnt)]\n               [(nth ks x) (nth vs x)]))))","problem":61,"user":"4f4544e1e4b0d56e7bb92b7a"},{"code":"#(apply hash-map (apply concat (map vector %1 %2)))","problem":61,"user":"4e521cef535d302ef430da6d"},{"problem":61,"code":"(fn [keycoll valcoll] (apply merge (map #(array-map %1 %2) keycoll valcoll)))","user":"554a270fe4b0a04f79299570"},{"code":"(fn [x y] (loop [acc {} k x v y]\n  (if (or (empty? k) (empty? v))\n    acc\n    (recur (merge acc {(first k) (first v)}) (rest k) (rest v)))))","problem":61,"user":"4f697a66e4b07046d9f4ef8a"},{"code":"(fn [keys vals]\n    (loop [map {}\n           ks (seq keys)\n           vs (seq vals)]\n      (if (and ks vs)\n        (recur (assoc map (first ks) (first vs))\n               (next ks)\n               (next vs))\n        map)))","problem":61,"user":"4fa2fa5ee4b081705acca186"},{"problem":61,"code":"#(let [mapped (map vector %1 %2)\n        flat (flatten mapped)]\n    (apply hash-map flat))","user":"54357066e4b0b6b47310fcfd"},{"problem":61,"code":"(fn re [xs ys]\n  (apply hash-map ((fn te [as bs] (if (or (empty? as) (empty? bs)) [] (conj (te (rest as) (rest bs)) (first as) (first bs)))) xs ys)))","user":"60228147e4b0d5df2af22202"},{"problem":61,"code":"(fn f [x y]\n  (if (and (not-empty x) (not-empty y))\n    (merge (f (rest x) (rest y)) {(first x) (first y)})))","user":"5478e57de4b0c51c1f4d72c1"},{"code":"(fn cust-zipmap [k v]\n  (apply assoc {}(interleave k v)))","problem":61,"user":"52463059e4b09dbe66b56198"},{"code":"#(reduce merge (map array-map %1 %2))","problem":61,"user":"51f4d46ee4b0fca5e8b48243"},{"problem":61,"code":"(fn [k v]\n   (loop [c 0\n          y []]\n     (if (= c (min (count k) (count v)))\n       (apply hash-map y)\n       (recur (inc c) (conj y (k c) (v c))))))","user":"5fa80c01e4b0fa27300f3de2"},{"problem":61,"code":"(fn [k v]\n  (loop [k k\n         v v\n         r {}]\n    (if (or (= 0 (count k)) (= 0 (count v)))\n      r\n      (recur (rest k) (rest v) (assoc r (first k) (first v))))))","user":"504f0c9ce4b0e7ad84dbc4b2"},{"problem":61,"code":"#(loop [m {}\n        a1 %1\n        a2 %2]\n   (if (or (empty? a1) (empty? a2))\n     m\n     (recur (assoc m (first a1) (first a2))\n            (rest a1)\n            (rest a2))))","user":"54194782e4b01498b1a71a29"},{"problem":61,"code":"(fn [seq-1 seq-2]\n  (loop [out {}\n         seq-1 seq-1\n         seq-2 seq-2]\n    (let [head-1 (first seq-1)\n          tail-1 (rest  seq-1)\n          head-2 (first seq-2)\n          tail-2 (rest  seq-2)]\n      (if head-1\n        (if head-2\n          (recur (assoc out head-1 head-2) tail-1 tail-2)\n          out)\n        out))))","user":"60b66033e4b0e0fa5f1b4248"},{"code":"(fn [xa xb]\n  (loop [result {} a xa b xb]\n    (if (or (empty? a) (empty? b))\n      result\n      (recur (assoc result (first a) (first b)) (rest a) (rest b))\n     )\n   ))","problem":61,"user":"51da7e49e4b02ceefd947768"},{"problem":61,"code":"(fn [x y] (into {} (vec (map #(vector %1 %2) x y))))","user":"5c52f3fce4b0fb8c5ffd99e9"},{"problem":61,"code":"(fn [coll1 coll2]\n     (loop [x 0\n            m {}]\n       (if (< x (min (count coll1) (count coll2)))\n         (recur (+ x 1)\n                (conj m (conj [] (nth coll1 x) (nth coll2 x))))\n         m)))","user":"5c52fa3ce4b0fb8c5ffd99eb"},{"code":"(fn [coll1 coll2] ( reduce conj (map (fn[a b] {a b}) coll1 coll2)))","problem":61,"user":"52c58440e4b0c2d177d620f7"},{"code":"(fn zmap [keys values]\n\t((fn [keys values acc]\n\t\t(if (or (empty? keys) (empty? values))\n\t\t\tacc\n\t\t\t(recur (rest keys) (rest values) (conj acc {(first keys) (first values)})))) keys values {}))","problem":61,"user":"539378fbe4b0b51d73faaebd"},{"problem":61,"code":"(fn [xs ys]\n    (apply hash-map (interleave xs ys))\n    )","user":"53c3397be4b00fb29b221279"},{"problem":61,"code":"(fn [v1 v2] (reduce (fn [a b] (assoc a (nth v1 b) (nth v2 b))) {} (range 0 (min (count v1) (count v2)))))","user":"5a9e3698e4b0d174b936c7fc"},{"problem":61,"code":"(fn [keys values] (apply (partial assoc {}) (interleave keys values)))","user":"5c30da5ae4b0d62ef62d9f23"},{"code":"(fn [ks vs]\n  (loop [ks ks\n         vs vs\n         result {}]\n    (if (and (seq ks) (seq vs))\n      (recur (rest ks) (rest vs) (assoc result (first ks) (first vs)))\n      result)))","problem":61,"user":"508a2c2fe4b016a2107004a1"},{"problem":61,"code":"(fn [ks vs] (into {} (vec (map vec (partition 2 (interleave ks vs))))))","user":"56c70cc2e4b0ed865f9758b5"},{"problem":61,"code":"(fn [a b] (reduce #(assoc %1 (:k %2) (:v %2)) {} (map (fn [x y] {:k x :v y}) a b)))","user":"5448616be4b032a45b8693c9"},{"problem":61,"code":"(fn maps\n  [x lst]\n  (into '{} (map (fn [y z] (hash-map y z)) x lst)))","user":"5c7dad57e4b0d597f478caba"},{"code":"#(into {} (map (fn [x y] {x y}) % %2))","problem":61,"user":"52fba50ce4b047fd5583700d"},{"problem":61,"code":"(fn [c1 c2]\n  (apply merge (map #(assoc {} %1 %2) c1 c2)))","user":"585a7cb2e4b0f14aab7c874e"},{"problem":61,"code":"#(apply merge (map (fn [k v] {k v}) %1 %2) )","user":"56bff105e4b060a8e693e3a4"},{"code":"(fn [keys, values]\n  (reduce merge (map (fn [a b] {a b}) keys values))\n  )","problem":61,"user":"4f03641a535dcb61093f6a9b"},{"problem":61,"code":"(fn [coll1 coll2] \n    (reduce (fn [acc item]\n    (assoc acc (first item) (second item)))  \n    {} (map #(list %1 %2)\n    coll1 coll2)))","user":"5a64dcabe4b0512ff01cd9a9"},{"problem":61,"code":"(fn map [keys values]\n  (let [key (first keys)\n        value (first values)]\n    (if (and key value)\n      (assoc\n       (map\n        (rest keys)\n        (rest values))\n       key value)\n      {})))","user":"598ab445e4b02b9968b84ce0"},{"problem":61,"code":"(fn [ fun1 fun2]\n  (apply hash-map (interleave fun1 fun2)))","user":"5634995fe4b0bfe05bf117be"},{"code":"(fn xipmap\n  [ks vs]\n  (loop [lks ks lvs vs m {}]\n    (if (or (empty? lks) (empty? lvs))\n      m\n      (recur (rest lks) (rest lvs) (assoc m (first lks) (first lvs))))))","problem":61,"user":"5070e31ee4b0e3170b5a8678"},{"code":"(fn [v1 v2] (letfn [(construct-map [keys vals c]\n  (if (or (empty? keys) (empty? vals))\n    c\n    (recur (rest keys) (rest vals) (assoc c (first keys) (first vals)))))]\n  (construct-map v1 v2 {})))","problem":61,"user":"4e8f4f64535d65386fec2149"},{"problem":61,"code":"(fn [ks vs](into {} (map #(vector %1 %2) ks vs)))","user":"56903cb9e4b0dcc4269f40eb"},{"problem":61,"code":"(fn [keys values]\n    (into {}\n          (map vector keys values)))","user":"4f42c80ae4b0d7d3c9f3fd0f"},{"problem":61,"code":"(fn [one two]\n  (apply hash-map (interleave one two)))","user":"5391ab43e4b0b51d73faaea6"},{"code":"(fn my-zipmap\n  [keys values]\n  (into\n   {}\n   (map (fn [a b] {a b}) keys values)))","problem":61,"user":"511720eae4b0063b4e3e16da"},{"problem":61,"code":"(fn [ks vs] (reduce (fn [acc kv] (assoc acc (first kv) (second kv))) {} (map vector ks vs)))","user":"54431b6ee4b032a45b869385"},{"code":"(fn \n[coll1 coll2]\n(into {} (map vector coll1 coll2)))","problem":61,"user":"53862316e4b06839e8705f0e"},{"code":"#(loop [xs1 %1 xs2 %2 rmp {}] (if (or (empty? xs1) (empty? xs2)) rmp (recur (rest xs1) (rest xs2) (assoc rmp (first xs1) (first xs2)))))","problem":61,"user":"4f2942ace4b0d6649770a01e"},{"code":"#(apply hash-map (flatten (map vector % %2)))","problem":61,"user":"4ee82539535d93acb0a66878"},{"code":"(fn[k v]\n   (apply merge (map (fn[x y] {x y}) k v)))","problem":61,"user":"506c0a02e4b0eda3100c090d"},{"code":"(fn\n  [keys vals]\n    (loop [map {}\n           ks (seq keys)\n           vs (seq vals)]\n      (if (and ks vs)\n        (recur (assoc map (first ks) (first vs))\n               (next ks)\n               (next vs))\n        map)))","problem":61,"user":"4eb0afed535d7eef3080733e"},{"code":"(fn [ks vs]\n  (reduce merge \n     (map #(hash-map %1 %2) ks vs)))","problem":61,"user":"52a8ca0fe4b0c58976d9ac36"},{"code":"(fn [keys vals] (apply hash-map (flatten (map #(vector %1 %2) keys vals))))","problem":61,"user":"523a9fc9e4b081681ca7adca"},{"problem":61,"code":"(fn iter [keys vals]\n\t(if (or (empty? keys) (empty? vals))\n\t\t{}\n      \t(assoc (iter (rest keys) (rest vals)) (first keys) (first vals)) ))","user":"59f043d0e4b0966464fe6a3d"},{"code":"(fn zipmap* [ks vs]\n  (let [impl (fn impl [acc ks vs]\n    (if (or (empty? ks) (empty? vs))\n      acc\n      (recur (conj acc [(first ks) (first vs)])\n          (rest ks) (rest vs))))]\n    (impl {} ks vs)))","problem":61,"user":"4e691c79535d8ccf87e9fe97"},{"problem":61,"code":"(fn my-zipmap\n  [ks vs]\n  (if (or (empty? ks) (empty? vs))\n    {}\n    (assoc (my-zipmap (rest ks) (rest vs)) (first ks) (first vs))))","user":"563f1493e4b08d4f616f5ecf"},{"problem":61,"code":"(fn [a b]  \n  (into {} (map (fn [x y] [x y]) a b)))","user":"55625903e4b0c656e3ff17d7"},{"problem":61,"code":"(fn [keys vals]\n  (loop [k keys v vals r {}]\n    (if (or (empty? k) (empty? v))\n      r\n      (recur\n        (rest k)\n        (rest v)\n        (assoc r (first k) (first v))\n      )\n    )\n  )\n)","user":"55929e89e4b0604b3f94d58e"},{"code":"(fn [k v]\n  (loop [k_ k v_ v ret ()]\n    (cond\n      (or (not k_) (not v_))\n        (apply hash-map (into '() ret))\n      :else\n        (recur \n          (next k_) \n          (next v_) \n          (conj ret (first k_) (first v_))))))","problem":61,"user":"4f050dec535dcb61093f6bef"},{"problem":61,"code":"(fn [a b] (reduce #(into %1 (apply hash-map %2)) {} (map list a b)))","user":"52eb2ec9e4b0705949c44439"},{"code":"(fn [c1 c2] (reduce merge (map (fn [k v] {k v}) c1 c2)))","problem":61,"user":"514721c6e4b0d520409ed392"},{"code":"(fn [c1 c2] (into {} (map vector c1 c2)))","problem":61,"user":"4e6fa38b535d5021c1a89622"},{"problem":61,"code":"(fn mymap \n  [k v]\n  (reduce merge {} (map hash-map k v)))","user":"54091b82e4b0addc1aec66d5"},{"problem":61,"code":"(let [zipped (partial map vector)] \n\t(fn [l1 l2] \n\t\t(reduce #(assoc %1 (first %2) (last %2)) {} (zipped l1 l2))))","user":"5650082fe4b0284900eef6b7"},{"code":"#(loop [a %1 b %2 res {}] (if (or (= 0 (count a)) (= 0 (count b)))\n                               res (recur (rest a) (rest b) (merge res {(first a) (first b)}))))","problem":61,"user":"4eb44d78535d7eef30807360"},{"problem":61,"code":"(fn [ks vs] (apply assoc {}  (interleave ks vs)))","user":"4f3b5219e4b0e243712b1f2a"},{"problem":61,"code":"(fn me [[a & ra] [b & rb]] (if (and ra rb) (conj {a b} (me ra rb)) {a b}))","user":"5ecc0831e4b016b56eae058c"},{"code":"(fn [keys values] (loop [k keys v values result {}]\n  (if (or (empty? k) (empty? v)) result\n    (recur (rest k) (rest v) (conj result {(first k) (first v)})))))","problem":61,"user":"4ef4ab95535dced4c769f23b"},{"problem":61,"code":"(fn [coll1 coll2]\n    (letfn [(func [m c1 c2]\n                  (if (and c1 c2)\n                    (recur\n\t                    (assoc m (first c1) (first c2))\n\t                    ;(func m (rest c1) (rest c2))\n                     (next c1)\n                     (next c2)\n                    )\n                    m))]\n                  (func {} coll1 coll2)))","user":"533a399de4b0e30313ee6cb9"},{"problem":61,"code":"#(into {} (map (fn [key value]\n                  {key value}) %1 %2))","user":"58a34442e4b02bd94d917ef2"},{"problem":61,"code":"(fn rmp\n     [acc k v]\n     (if (or (empty? k) (empty? v))\n       acc\n       (rmp (assoc acc (first k) (first v)) (next k) (next v))\n       )\n     )\n   {}","user":"5bdc4a76e4b0ed4b8aab4c30"},{"problem":61,"code":"(fn [k v]\n  (reduce \n   (fn [m [k v]] (assoc m k v))\n   {} (map vector k v)))","user":"5d45749be4b07c84aa5ae6a2"},{"problem":61,"code":"(fn my-zipmap \n  ([lst1 lst2] (my-zipmap lst1 lst2 []))\n  ([lst1 lst2 ret]\n    (if (or (empty? lst1) (empty? lst2)) \n      (apply array-map ret)\n      (my-zipmap (rest lst1) (rest lst2) (concat ret (cons (first lst1) (cons (first lst2) nil)))))))","user":"54c8ac49e4b045293a27f64e"},{"problem":61,"code":"#(apply hash-map (mapcat vector %1 %2))\n;#(into {} (map vector %1 %2))\n;#(apply hash-map (interleave % %2))","user":"581b19e7e4b04b46fc4b0ec4"},{"problem":61,"code":"(fn [k v]\n    (loop [ks k\n           vs v\n           res {}]\n      (if (or (empty? ks)\n              (empty? vs))\n        res\n        (recur (rest ks) (rest vs) (merge res (hash-map (first ks) (first vs)))))))","user":"5530baa5e4b076ab5578f81a"},{"code":"(fn f [x y]\n  (let [[h1 & t1] (seq x)\n        [h2 & t2] (seq y)]\n    (if (or (empty? t1) (empty? t2))\n      (hash-map h1 h2)\n      (conj (hash-map h1 h2) (f t1 t2)))))","problem":61,"user":"4ead2841535d7eef3080731e"},{"problem":61,"code":"#(loop [\n                      map {}\n                      ks %1\n                      vs %2]\n                     (if (and ks vs)\n                       (recur (assoc map (first ks)(first vs))(next ks)(next vs))map))","user":"5f27cc7fe4b033932238a646"},{"problem":61,"code":"#(into {} (apply map vector [%1 %2]))","user":"56f974c0e4b07572ad1a88b1"},{"problem":61,"code":"(fn [k v]\n   (into {} (map vector k v)))","user":"59385840e4b02506e01a29c9"},{"code":"#(apply hash-map (interleave %1 %2 ))","problem":61,"user":"4f25c4c4e4b0d66497709ffc"},{"problem":61,"code":"(fn [a b]\n  (loop [x (rest a)\n         y (rest b)\n         res (hash-map (first a) (first b))]\n    (if (or (empty? x) (empty? y))\n      res \n      (recur (rest x)\n             (rest y)\n             (assoc res (first x) (first y))))))","user":"5c748bf5e4b0fca0c16227cb"},{"code":"(fn f [x y]\n  (if (or (empty? x) (empty? y))\n    (hash-map)\n    (assoc (f (rest x) (rest y)) (first x) (first y))))","problem":61,"user":"4f062d4a535dcb61093f6c08"},{"code":"(fn [& colls]\n  (apply hash-map (apply interleave colls)))","problem":61,"user":"505bd09fe4b032b709c81373"},{"code":"(fn zmp [keys vals] (loop [map {} ks (seq keys) vs (seq vals)] (if (and ks vs) (recur (assoc map (first ks) (first vs)) (next ks) (next vs)) map)))","problem":61,"user":"50ed9e8de4b06330c1f87c44"},{"problem":61,"code":"(fn \n  [map-keys map-values]\n  (into {} (map #(assoc {} (nth map-keys %) (nth map-values %)) (range (count (if (< (count map-keys) (count map-values)) map-keys map-values)))))\n)","user":"5a4ec4f0e4b05d388ecb6bc2"},{"problem":61,"code":"#(reduce (fn [hmap kv] (apply assoc hmap kv))\n         {}\n         (partition 2\n                    (interleave %1 %2)))","user":"585e2e77e4b0f14aab7c87ac"},{"code":"(fn [l m]\n  ((fn a [l m cum]\n     (if-not (and (seq l) (seq m))\n       cum\n       (a (rest l) \n          (rest m) \n          (assoc cum \n            (first l) \n            (first m)))))\n   l m {}))","problem":61,"user":"50e135f4e4b084616e11c667"},{"problem":61,"code":"(fn [l1 l2]\n  (loop [l1 l1 l2 l2 r {}]\n    (if (and (seq l1) (seq l2))\n      (recur (rest l1) (rest l2) (assoc r (first l1) (first l2)))\n      r)))","user":"557c6ca6e4b05c286339e0c4"},{"problem":61,"code":"(fn [a b]\n  (loop [i 0\n         mp {}]\n    (if (or (= i (count a)) (= i (count b)))\n      mp\n     (recur (inc i) (assoc mp (a i) (b i)) ) )))","user":"6074df6fe4b069485764de4b"},{"problem":61,"code":"(fn [kys vls]\n  (loop [ mp {}\n          ks kys\n          vs vls]\n    (if (or \n         (empty? ks) \n         (empty? vs)) \n      mp\n      (recur \n       (assoc mp (first ks) (first vs))\n       (rest ks)\n       (rest vs)))))","user":"5832be57e4b089d5ab817c86"},{"problem":61,"code":"(fn [ks vs]\n  (into {} (for [[x y] (partition 2 (interleave ks vs))] [x y])))","user":"5d231255e4b02ea6f0fb69fe"},{"problem":61,"code":"#(into {} (map sorted-map %1 %2))","user":"5826a843e4b051871117befd"},{"problem":61,"code":"(fn f [key-vec val-vec] (->> (range (count key-vec))\n                           (map #(vector (get key-vec %) (get val-vec %)))\n                           (filter #(not (nil? (last %))))\n                           (apply concat)\n                           (apply hash-map)))","user":"5493d908e4b0b312c081ff52"},{"problem":61,"code":"(fn [x y] (reduce conj (hash-map) (map vector x y)))","user":"56eb3f9de4b04a395b9a0420"},{"code":"(fn [coll1 coll2]\n  (into {} (map (fn [x y] {x y}) coll1 coll2)))","problem":61,"user":"4ff9cfd6e4b0678c553fc3af"},{"problem":61,"code":"(fn f [keys vals]\n   (loop [k keys v vals acc {}]\n     (if (or (empty? k) (empty? v))\n       acc\n       (recur (rest k) (rest v) (assoc acc (first k) (first v))))))","user":"52ee0de4e4b05e3f0be25ec1"},{"problem":61,"code":"(comp\n (partial into {})\n (partial map vector))","user":"5af8221ce4b0cc2b61a3bccd"},{"code":"(fn [s1 s2]\n   (reduce\n    (fn [acc x]\n      (conj acc (hash-map (first x) (last x)))\n      )\n    {}\n    (partition 2 (interleave s1 s2)))\n   )","problem":61,"user":"50868795e4b004985b776e5e"},{"problem":61,"code":"(fn foo [keys vals]\n  (loop [ks keys\n         vs vals\n         result {}]\n    (if (or (empty? ks) (empty? vs))\n      result\n      (recur (rest ks)\n             (rest vs)\n             (assoc result (first ks) (first vs))))))","user":"5b333626e4b025bcb146f32f"},{"problem":61,"code":"(fn [k v] (apply hash-map (apply concat (map #(vector %1 %2) k v))))","user":"57c3451fe4b05aa3c4741cbd"},{"problem":61,"code":"(fn [ks vs] (reduce conj (map (fn [k v] {k v}) ks vs)))","user":"53dadf1de4b0e771c30254ad"},{"code":"(fn [keys vals]\r\n (loop [map {}\r\n           ks (seq keys)\r\n           vs (seq vals)]\r\n      (if (and ks vs)\r\n        (recur (assoc map (first ks) (first vs))\r\n               (next ks)\r\n               (next vs))\r\n        map)))","problem":61,"user":"4e570b60535d8a8b8723a286"},{"code":"(fn[vk vv] (into {} (map (fn[k v] [k v]) vk vv)))","problem":61,"user":"4ec64981535d6d7199dd36c7"},{"problem":61,"code":"#(apply hash-map (seq (interleave %1 %2)))","user":"596caee3e4b069c0a1a19837"},{"code":"(fn zip-map [k v] (apply hash-map (reduce concat (map (fn [a b] [a b]) k v))))","problem":61,"user":"4fcaf7a4e4b0ee37620e1857"},{"problem":61,"code":"(fn [c1 c2]\n  (apply array-map (interleave c1 c2)))","user":"5b88f0c0e4b047b03b203816"},{"code":"(fn [ks vs]\n  (into {} (map vector ks vs))\n  )","problem":61,"user":"51aa2b4fe4b04e3dc0c27b21"},{"code":"(fn [s1 s2 &{:keys [o], :or {o (hash-map)}}] (if-not (or (empty? s1) (empty? s2)) (recur (rest s1) (rest s2) {:o (conj o {(first s1) (first s2)})}) o))","problem":61,"user":"52bdf6bde4b07a9af579230d"},{"code":"(fn f [ks vs]                                                                   \n  (if (not (or (empty? ks) (empty? vs)))                                        \n    (conj {(first ks) (first vs)} (f (rest ks) (rest vs))) ) )","problem":61,"user":"4df20dda535d08e6dec9fe23"},{"problem":61,"code":"(fn [k v]\n   (apply hash-map (interleave k v)))","user":"51e7c1f1e4b0a3e081b8cbef"},{"problem":61,"code":"(fn [ks vs] (reduce merge (map (fn [k v] {k v}) ks vs)))","user":"53e8e42ce4b036ad0777e48e"},{"problem":61,"code":"(fn map-cons [keys vals]\n   (if (or (empty? keys)\n           (empty? vals))\n     {}\n     (merge (assoc {}\n                   (first keys)\n                   (first vals))\n            (map-cons\n             (rest keys)\n             (rest vals)))))","user":"54d26316e4b0e8a36923e5f2"},{"problem":61,"code":"#(into {} (map (fn [[& elements]] (into [] elements)) (partition 2 (interleave %1 %2))))","user":"602b90c1e4b0d5df2af22266"},{"problem":61,"code":"#(apply assoc {} \n   (interleave %1 \n               %2))","user":"57a1ef58e4b0c3d858beb8f3"},{"problem":61,"code":"(fn [a b]\n  (loop\n    [out {} x a y b]\n    (cond\n    \t(or (empty? x) (empty? y)) out\n    \t:else (recur (assoc out (first x) (first y)) (rest x) (rest y)))))","user":"5e6e6537e4b04a83ad7cd29a"},{"problem":61,"code":"(fn[ks vls]\n    (loop [newhm {}\n           ks ks\n           vls vls]\n        (if (or (empty? ks)(empty? vls))\n            newhm\n            (recur (assoc newhm (first ks) (first vls)) (rest ks) (rest vls)))))","user":"5f77d470e4b02876ed9fd0be"},{"problem":61,"code":"(fn [k v]\n  (let [n (min (count k) (count v))]\n    (loop [i 0\n           ck (first k)\n           cv (first v)\n           ckk (rest k)\n           ckv (rest v)\n           m {}]\n      (if (= i n)\n        m\n        (recur (inc i) (first ckk) (first ckv) (rest ckk) (rest ckv) (assoc m ck cv))))))","user":"5f3ddc71e4b004f08c61c551"},{"problem":61,"code":"(fn [ x y ]  \n   (apply assoc {} (interleave x y))\n   )","user":"50b25edae4b03ea88043355e"},{"problem":61,"code":"(fn [ks vs]\n    (loop [ks ks vs vs acc {}]\n      (if (or (empty? ks) (empty? vs))\n        acc\n        (recur (rest ks) (rest vs) (assoc acc (first ks) (first vs))))))","user":"551a21ece4b091ff45eda993"},{"code":"(fn [keys vals & res] \n  (if (or (empty? keys) (empty? vals))\n    res\n    (recur (rest keys) (rest vals) (assoc res (first keys) (first vals)))))","problem":61,"user":"51fe9d7ce4b0f1313d468a70"},{"problem":61,"code":"#(->> (map vector %1 %2)\n      (flatten)\n      (apply hash-map))","user":"5461c402e4b01be26fd746a6"},{"problem":61,"code":"(fn f [xs-keys xs-vals]\n    (apply hash-map (interleave xs-keys xs-vals)))","user":"5ff64845e4b06df49cee1495"},{"problem":61,"code":"(fn [listOne listTwo]\n  (loop [remainingFirst listOne remainingSecond listTwo output {}]\n  (println remainingFirst remainingSecond output)\n  (if (or (empty? remainingFirst) (empty? remainingSecond))\n    output\n    (recur (rest remainingFirst) (rest remainingSecond) (conj output (hash-map (first remainingFirst) (first remainingSecond))))))\n)","user":"5b3de9a7e4b02d533a91bbf4"},{"problem":61,"code":"(fn [col1 col2] (reduce #(let [[k v] %2]\n                               (assoc %1 k v)) {} (map #(vector %1 %2) col1 col2)))","user":"52f53589e4b05e3f0be25f2c"},{"problem":61,"code":"(fn [vect1 vect2]\n  (loop [v1 vect1 v2 vect2 combo []]\n    (if (or (empty? v1) (empty? v2)) ;if either input is empety, finish\n      (apply hash-map combo)\n      (recur (rest v1) (rest v2) (conj combo (first v1) (first v2))))))","user":"59369515e4b02506e01a297e"},{"code":"(fn [keys vals]\n  (loop [map {}\n         ks (seq keys)\n         vs (seq vals)]\n     (if (and ks vs)\n       (recur (assoc map (first ks) (first vs))\n              (next ks)\n              (next vs))\n       map)))","problem":61,"user":"4f1d1299535d64f603146487"},{"problem":61,"code":"(fn [ks vs]\n  (into {}\n    (map #(vector %1 %2) ks vs)))","user":"54448e84e4b032a45b869393"},{"problem":61,"code":"(fn [key_seq value_seq]\n  (loop [key_rest key_seq\n         value_rest value_seq\n         res {}]\n    (if (or (empty? key_rest) (empty? value_rest))\n      res\n      (recur (rest key_rest) (rest value_rest) (assoc res (first key_rest) (first value_rest))))))","user":"5d64013ce4b0c9e5857d502d"},{"problem":61,"code":"(fn [s1 s2] (->> (interleave s1 s2)\n                  (apply hash-map)\n                  \n               ))","user":"59419bdfe4b060784b3b78f7"},{"code":"(fn [ks vs]\n  (let [p (map (fn [q w] [q w]) ks vs)]\n    (reduce (fn [m [k v]] (assoc m k v)) {} p)))","problem":61,"user":"4ec18451535dfed6da9c6db0"},{"problem":61,"code":"(fn [col1 col2]\n           (into {} (map (fn [x1 x2]\n                           [x1 x2])\n                         col1 col2)))","user":"5e1c3e6ee4b0dc9594008530"},{"problem":61,"code":"(fn [keyList valList]\n\t(loop [l1 keyList l2 valList acc {}]\n\t\t(if (or (empty? l1) (empty? l2))\n\t\t\tacc\n\t\t\t(let [\n\t\t\t\tk (first l1)\n\t\t\t\tv (first l2)\n\t\t\t\tr1 (rest l1)\n\t\t\t\tr2 (rest l2)\n\t\t\t\tnewAcc (assoc acc k v)]\n\t\t\t\t(recur r1 r2 newAcc)))))","user":"598af379e4b02b9968b84ce6"},{"problem":61,"code":"(fn createmap [coll1 coll2]\n  (reduce (fn [result [val key]] (assoc result val key)) {} (map #(vector %1 %2) coll1 coll2)))","user":"56e53d2fe4b02e7e935eb6bc"},{"problem":61,"code":"(fn\n  [keys values]\n  (loop [keys keys values values m {}]\n    (if (and  (not (empty? keys)) (not (empty? values)))\n      (recur (rest keys) (rest values) (assoc m (first keys) (first values)))\n      m\n      )\n    \n))","user":"5772ddb0e4b0979f896515d4"},{"problem":61,"code":"(fn [c1 c2]\n  (loop [r {}\n         c1 c1\n         c2 c2]\n    (if (or (empty? c1) (empty? c2))\n      r\n      (recur (into r {(first c1) (first c2)}) (rest c1) (rest c2)))))","user":"55ff562fe4b00f4cabc57660"},{"problem":61,"code":"(fn [ks vs]\n    (apply hash-map (interleave ks vs))\n    )","user":"58ec1e63e4b056aecfd47d54"},{"code":"(fn [x y]\n          (let [f (fn ff [x y d]\n                    (if (or (empty? x) (empty? y)) d\n                        (ff (rest x) (rest y) (into d {(first x) (first y)})))\n                    )] (f x y {})))","problem":61,"user":"52c7f036e4b0c2d177d62126"},{"code":"(fn [keys vals] \n  (loop [m {}\n         k keys\n         v vals]\n    (if (or (empty? k) (empty? v))\n      m\n      (recur (assoc m (first k) (first v)) (next k) (next v)))))","problem":61,"user":"51ae350fe4b09397d5109790"},{"code":"(fn [a b] (reduce #(conj %1 {(first %2) (second %2)}) {} (partition 2 (interleave a b))))","problem":61,"user":"5142e808e4b0c172af7558c9"},{"code":"(fn my-zipmap\n  [xs ys]\n  (apply hash-map (interleave xs ys)))","problem":61,"user":"51e780dae4b0730ab87cf353"},{"code":"(fn [keys vector]\n    (apply assoc {} (interleave keys vector)))","problem":61,"user":"511e763ce4b03e81d390ac29"},{"code":"(fn myzip [keys vals] (if (or (empty? keys) (empty? vals))\n                        nil\n                        (assoc (myzip (rest keys) (rest vals))\n                          (first keys)\n                          (first vals))))","problem":61,"user":"518279abe4b0353c468deb65"},{"code":"#(into {} (apply map vector [% %2]))","problem":61,"user":"53307da1e4b019098a6f8b5e"},{"problem":61,"code":"(fn my-zipmap [seq1 seq2]\n  (let [map-fn (fn [v1 v2] [v1 v2])\n        res (map map-fn seq1 seq2)]\n    (into {} res)))","user":"561d8936e4b064ca9f4b16b2"},{"code":"#(reduce merge (apply map hash-map %&))","problem":61,"user":"4fab259ae4b081705acca212"},{"code":"#(apply sorted-map (apply mapcat vector %&))","problem":61,"user":"4f71347ae4b07046d9f4f009"},{"problem":61,"code":"(fn [ks vs]\n    (loop [a_ks ks a_vs vs m {}]\n          (if (or (empty? a_ks) (empty? a_vs))\n              m\n              (recur (rest a_ks) (rest a_vs) (assoc m (first a_ks) (first a_vs))))))","user":"5a34f342e4b0ddc586f153d1"},{"code":"(fn [s1 s2] (reduce #(assoc %1 (first %2) (second %2)) {} (map #(conj [] %1 %2) s1 s2)))","problem":61,"user":"51b0e7b3e4b0c53cf2e68a6e"},{"problem":61,"code":"(fn [keys vals]\n  (apply hash-map (mapcat list keys vals)))","user":"5424c523e4b01498b1a71b03"},{"problem":61,"code":"(fn [coll-1 coll-2]\n  (into {} (map vector coll-1 coll-2)))","user":"53b05a36e4b047364c044481"},{"code":"(fn\n  [keys vals]\n  (loop [keys keys\n         vals vals\n         map {}]\n        (if (or (empty? keys) (empty? vals))\n            map\n            (recur (rest keys)\n                   (rest vals)\n                   (assoc map (first keys) (first vals))))))","problem":61,"user":"52561be5e4b0541d1855ba08"},{"problem":61,"code":"(fn [ks vs]\n  (->> (map vector ks vs)\n       (apply concat)\n       (apply hash-map)))","user":"5d431c77e4b07c84aa5ae68f"},{"problem":61,"code":"(fn  [ks vs]\n  (loop [rk ks\n         rv vs\n         m {}]\n    (if (and (first rk) (first rv))\n\n      (recur\n       (rest rk) (rest rv)\n       (assoc m (first rk) (first rv)))\n\n      m)))","user":"59971dcbe4b07157cc8daacb"},{"problem":61,"code":"(fn map-construction [keys values]\n  (apply assoc {} (interleave keys values)))","user":"54c72b19e4b045293a27f636"},{"problem":61,"code":"(fn [ks vs]\n              (reduce into {}\n                      (map (fn [k v] {k v})\n                           ks\n                           vs)))","user":"53f31dafe4b0742d9025b0f0"},{"problem":61,"code":"(fn construct [a b] (if (or (empty? a) (empty? b)) {} (assoc (construct (rest a) (rest b)) (first a) (first b))))","user":"54c9e00be4b045293a27f683"},{"problem":61,"code":"(fn build_map\n  [k v]\n  (apply hash-map (interleave k v))\n)","user":"5f6b8222e4b02876ed9fd052"},{"problem":61,"code":"(fn map-construction-solution\n  [arr1 arr2] ;; update args as needed\n  (apply array-map (interleave arr1 arr2))\n  ;; Write a function which takes a vector of keys and a vector of values and constructs a map from them.\n   )","user":"536829c8e4b0243289761e8b"},{"problem":61,"code":"(fn [x y]\n  (into {} (map vector x y)))","user":"551ecb76e4b08d5046aa8a4c"},{"code":"(fn make-map [keys values]\r\n  (reduce #(assoc %1 (first %2) (second %2)) {}\r\n    (map #(list % %2) keys values)))","problem":61,"user":"504ec4d3e4b069badc5a33c9"},{"problem":61,"code":"(fn __ [k v] (into {} (map #(hash-map %1 %2) k v)))","user":"575b3e9be4b02ea11479935b"},{"problem":61,"code":"(fn zip [x y]\n   (loop [ret {}\n          ks (seq x)\n          vs (seq y)]\n     (if (and ks vs)\n       (recur (assoc ret (first ks) (first vs))\n              (next ks)\n              (next vs))\n       ret)))","user":"53b12c76e4b047364c04448a"},{"problem":61,"code":"(fn [ks vs]\n  (loop\n    [ks ks\n     vs vs\n     acc {}]\n    (cond\n     (or (empty? ks) (empty? vs)) acc\n     :else (recur (rest ks) (rest vs) (assoc acc (first ks) (first vs))))))","user":"5689fd03e4b0dcc4269f4088"},{"code":"(fn [l r] (reduce #(assoc %1 (first %2) (second %2)) {} (partition 2 (interleave  l r))))","problem":61,"user":"50057f23e4b0678c553fc466"},{"code":"(fn funky [col1 col2]\n   (into {} (map (fn [a b]\n          (vector a b) ) col1 col2)))","problem":61,"user":"51427a8be4b0b50abeb46b37"},{"problem":61,"code":"(fn [xs ys]\n  (reduce merge (map #(assoc {} %1 %2) xs ys)))","user":"54dce62fe4b024c67c0cf78c"},{"problem":61,"code":"(fn [a b]\n  (into {} (map #(vector %1 %2) a b)))","user":"53214efbe4b09d4e7a9b54b2"},{"code":"(fn [klist vlist]\n  (loop [klist,klist vlist,vlist resmap,{}]\n    (if (or (empty? klist) (empty? vlist))\n      resmap\n      (recur (rest klist) (rest vlist) (conj resmap [(first klist) (first vlist)]))\n      )))","problem":61,"user":"50f0d000e4b0c5f4fa5ddb6f"}]