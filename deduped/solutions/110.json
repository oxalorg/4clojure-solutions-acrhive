[{"problem":110,"code":"(fn f [x]\n  (let [y (mapcat #(vector (count %) (first %)) (partition-by identity x))]\n    (cons y (lazy-seq (f y)))))","user":"5654cb2de4b0f9d632dd848b"},{"problem":110,"code":"(fn[s](next (iterate #(vec (flatten (for[k (partition-by identity %)]\n                                      [(count k) (first k)])\n                                    )\n                           )\n                     s)\n            )\n  )","user":"5731e36be4b0cd1946bd0fc9"},{"code":"(fn pronounce [xs]\n  (let [pron (fn [xs] (mapcat (fn [x] [(count x) (first x)]) (partition-by identity xs)))]\n  (iterate pron (pron xs))))","problem":110,"user":"51aab611e4b04e3dc0c27b2d"},{"problem":110,"code":"(comp rest (fn pron\n    [n]\n    (let [pronounce (fn [s] (vec (mapcat #(list (count %) (first %)) (partition-by identity s))))]\n      (lazy-seq (cons n (pron (pronounce n)))))))","user":"4f47eab2e4b0d56e7bb92bc6"},{"code":"(fn pronounce-seq\n  [col]\n  (let [pronounce (fn [col] \n                    (flatten (map #(vector (count %) (first %))\n                                  (partition-by identity col))))\n        p (pronounce col)]\n    (drop 1 (iterate pronounce col))))","problem":110,"user":"4db8d37d535d1e037afb219c"},{"code":"(fn\t[s]\n\t(letfn [(f [x]\n\t\t   (reduce\n\t\t    (fn [acc el]\n\t\t\t(conj acc (count el) (first el))) [] (partition-by identity x)))]\n\t       (iterate f (f s))))","problem":110,"user":"5142ea50e4b0c172af7558ca"},{"problem":110,"code":"(fn pron [coll]\n  (next\n    (iterate\n      (fn [val] (->> (partition-by identity val)\n                     (mapcat #(list (count %) (first %)))))\n      coll)))","user":"5b13ba71e4b0cc2b61a3be53"},{"problem":110,"code":"#(letfn [\n  (aFunc [acc value]\n    (if (empty? acc)\n      (conj acc value 1)\n      (let [[q n & others] acc]\n        (if (= n value)\n          (conj others value (inc q))\n          (conj acc value 1)))))\n  (pronounce [nums]\n    (flatten (reverse (partition 2 (reduce aFunc '() nums)))))]\n  (iterate pronounce (pronounce %)))","user":"5773f3a9e4b0979f896515f2"},{"code":"(fn [s] \n  (rest (iterate\n    #(mapcat (juxt count first)\n      (partition-by identity %)) \n    s)))","problem":110,"user":"4e5411e8535d8a8b8723a279"},{"code":"(fn [start]\n    (letfn [(next-pron [seq] (mapcat #(vector (count %) (first %)) (partition-by identity seq)))]\n        (rest (iterate next-pron start))))","problem":110,"user":"4f4ac35ae4b0d56e7bb92c18"},{"problem":110,"code":"(fn lazy-pronouce [col]\n  (letfn [(pronouce [col]\n            (let [grouped (partition-by identity col)\n                  res (mapcat #(list (count %) (first %)) grouped)]\n              res))]\n    (drop 1 (iterate pronouce col))))","user":"58fc92c5e4b0438e51c2cf9a"},{"problem":110,"code":"(fn [values]  \n            (->> values\n                (iterate (fn [xs] \n                                (->> (partition-by identity xs)\n                                (map (fn [val] [(count val) (first val)]))\n                                (flatten))\n                        ))\n                (drop 1)\n            )\n        )","user":"5a66fddee4b0512ff01cd9d7"},{"code":"(fn [x] (rest (iterate (fn [s]\n       \t  (->> s\n       \t\t  (partition-by identity)\n       \t\t  (map #(list (count %) (first %)))\n      \t\t  flatten)) x)))","problem":110,"user":"5054bc87e4b0b1b9d1860eb0"},{"code":"#(rest (iterate (fn [lst] (loop [n 1 x (first lst) r (rest lst) t []]\n           (cond\n            (empty? r) (conj t n x)\n            (= x (first r)) (recur (+ 1 n) x (rest r) t)\n            :else (recur 1 (first r) (rest r) (conj t n x))))) %))","problem":110,"user":"5088082ae4b0198722bd9854"},{"code":"(fn pronunc-seq [coll]\n  (let [p (reduce\n            #(conj %1 (count %2) (first %2))\n            []\n            (partition-by + coll))]\n    (cons p (lazy-seq (pronunc-seq p)))))","problem":110,"user":"526ee63de4b03e8d9a4a733f"},{"code":"(fn f [ls]\n  (let [next (flatten \n              (map \n                #(vector (count %) (first %)) \n                (partition-by identity ls)))]\n    (lazy-seq (cons next (f next)))))","problem":110,"user":"5003ee7de4b0678c553fc446"},{"code":"(fn pronounce [coll]\n  (let [parts (partition-by identity coll)\n        xs (apply concat (for [part parts] [(count part) (first part)]))]\n    (cons xs\n         (lazy-seq (pronounce xs)))))","problem":110,"user":"4e593dac535d8a8b8723a29c"},{"problem":110,"code":"(fn f110 [coll]\n  (letfn [(pronounce [coll]\n            (->>\n             (partition-by identity coll)\n             (map (juxt count first))\n             (apply concat)))]\n    (let [pronounced (pronounce coll)]\n      (cons pronounced (lazy-seq (f110 pronounced))))))","user":"55586905e4b0deb715856e2b"},{"code":"(fn pron [x]\n  (let [ans (fn [x]\n    (reduce (fn [acc lst]\n              (conj (conj acc (count lst)) (first lst)))\n            [] (partition-by identity x)))]\n    (lazy-seq \n      (cons (ans x) (pron (ans x))))))","problem":110,"user":"4e7f5a0b535db966e863cc41"},{"code":"(fn f [s] (rest (iterate\n  #(let [r (partition-by + %)]\n    (interleave (map count r) (map first r)))\n  s)))","problem":110,"user":"4f01c938535dcb61093f6a39"},{"problem":110,"code":"(fn pronounce [xs]\n  (letfn [\n    (pronounce1 [xs]\n      (mapcat #(vector (count %) (first %)) (partition-by identity xs)))]\n    (lazy-seq (cons (pronounce1 xs) (pronounce (pronounce1 xs))))))","user":"55d5e80ee4b0e31453f64a91"},{"problem":110,"code":"(fn [start] \n                         (drop 1 (iterate \n                                  (fn [elt] \n                                    (mapcat \n                                     (fn [part] \n                                       [(count part) (first part)]) \n                                     (partition-by identity elt)))\n                                  start)))","user":"54cad2d5e4b057c6fda3a26c"},{"code":"(fn me [xs]\n   (let [el (mapcat (fn [xs] [(count xs) (first xs)]) (partition-by identity xs))]\n   (cons \n    el\n    (lazy-seq (me el)))))","problem":110,"user":"531490bde4b08068f379ed17"},{"problem":110,"code":"(fn pronunciation-seq  [s]\n  (let [pronounce (fn [coll] \n                    (reduce #(into % [(count %2) (first %2)]) \n                            []\n                            (partition-by identity coll)))\n        pronunciation (pronounce s)] \n    (lazy-seq (cons pronunciation (pronunciation-seq pronunciation)))))","user":"57a0f256e4b0c3d858beb8dd"},{"problem":110,"code":"(fn [s]\n    (rest\n     (iterate\n      #(flatten\n        (map (fn [v] (vector (count v) (first v)))\n             (partition-by identity %))) s)))","user":"55c5b55fe4b0e31453f649b5"},{"problem":110,"code":"(fn f [ns]\n  (let [ns (partition-by identity ns)\n        cts (map count ns)\n        r (interleave cts (map first ns))]\n    (lazy-seq (cons r (f r)))))","user":"5012da69e4b0c8732600222d"},{"problem":110,"code":"(fn __ [in]\n  (let [el (mapcat (fn [pn] [(count pn) (first pn)])\n                   (partition-by identity in))] \n    (lazy-seq (cons el (__ el)))))","user":"55916764e4b0604b3f94d57b"},{"code":"(fn lazy-pronounce [seq]\n  (letfn [(pronounce [seq]\n            (let [groups (partition-by identity seq)]\n              (flatten (map #(vector (count %) (first %)) groups))))]\n    (let [lazy-pronounciation (pronounce seq)]\n      (lazy-seq (cons lazy-pronounciation\n                      (lazy-pronounce lazy-pronounciation))))))","problem":110,"user":"4ff355a1e4b0678c553fc34d"},{"problem":110,"code":"(fn [ps] (drop 1 (iterate (fn [ms] (into [] (mapcat #(list (count %) (first %)) (partition-by identity ms)))) ps)))","user":"5a566e8fe4b05d388ecb6c51"},{"problem":110,"code":"(fn f [c]\n\t(let [a (mapcat #(vector (count %) (first %))\n\t\t\t(partition-by identity c))]\n\t\t(cons a (lazy-seq (f a)))))","user":"536e5b68e4b0fc7073fd6e6d"},{"problem":110,"code":"(fn [coll]\n  (rest (iterate #(->> (partition-by identity %)\n                       (mapcat (juxt count first)))\n                 coll)))","user":"5de12192e4b0948ae9d9aded"},{"code":"(fn [s]\n  (drop 1 (iterate (fn [s1]\n             (->> s1\n                  (partition-by identity)\n                  (map (fn [e] [(count e)\n                                (first e)]))\n                  flatten))\n           s)))","problem":110,"user":"5092fe10e4b097f48cc3857e"},{"problem":110,"code":"#(rest (iterate\n        (fn [n]\n          (mapcat (juxt count first)\n                  (partition-by identity n)))\n       %))","user":"541709b0e4b01498b1a71a06"},{"problem":110,"code":"(fn [u] \n  (rest (iterate \n         (fn [v] \n           (reduce \n            #(conj (conj %1 (count %2)) (first %2)) \n            [] (partition-by num v))) u)))","user":"573ce277e4b05c31a32c080b"},{"code":"(comp rest (partial iterate \n                    #(mapcat (juxt count first) (partition-by identity %))))","problem":110,"user":"51efd397e4b0249c592fbdeb"},{"problem":110,"code":"(fn f110\n  [col]\n  (let [f (fn [c]\n            (loop [[x & xs] c res []]\n              (if x\n                (recur (drop-while (partial identical? x) xs) (concat res (vector (inc (count (take-while (partial identical? x) xs))) x)))\n                res)))\n        lol (f col)]\n    (iterate f lol)))","user":"59390a35e4b02506e01a29f3"},{"code":"(fn [s]\n  (let [f (fn [s] (mapcat #(vector (count %) (first %)) (partition-by identity s)))]\n    (rest (iterate f s))))","problem":110,"user":"504e04a4e4b078edc5f59397"},{"code":"(fn pron [s]\n  (let [p (mapcat #(list (count %) (first %)) (partition-by identity s))]\n    (lazy-seq (cons p (pron p)))))","problem":110,"user":"4f9120d8e4b0dcca54ed6c96"},{"code":"(fn [s]\n  (rest (iterate #(mapcat (juxt count first)\n                          (partition-by identity %))\n  s)))","problem":110,"user":"4ee26f01535d10e5ff6f5368"},{"code":"(fn recpro\n  [ns]\n  (lazy-seq\n   (let [pt (partition-by identity ns)\n         pros (vec (flatten (map (fn [s] [(count s) (first s)]) pt)))]\n     (cons pros (recpro pros)))))","problem":110,"user":"4e8768f6535dceadca469850"},{"problem":110,"code":"(fn pron [xs]\n     (let [rs (mapcat #(into [] (list (count %) (first %))) (partition-by identity xs))]\n       (cons rs (lazy-seq (pron rs)))))","user":"5d02fe44e4b0cc9c915881c0"},{"code":"(fn [xs]\n  (rest (iterate\n    (fn [x]\n      (mapcat (juxt count first) (partition-by identity x)))\n    xs)))","problem":110,"user":"4db1b3951254ad5b4805fa6f"},{"code":"(fn [l]\n  (letfn [(f [l] (mapcat (juxt count first) (partition-by identity l)))]\n    (iterate f (f l))\n    ))","problem":110,"user":"4fbbcf0ce4b081705acca2ee"},{"problem":110,"code":"(fn solve [s]\n  (letfn [(pronounce [l]\n            (mapcat (fn [xs] [(count xs) (first xs)])\n                    (partition-by identity l)))]\n    (iterate pronounce (pronounce s))))","user":"56444fb1e4b0018b46ad8c0c"},{"problem":110,"code":"(fn pronunciations\n  [n]\n  (let [get-pronunciation (fn [x]\n    (loop [curr (first x)\n           count 1\n           remaining (rest x)\n           acc []]\n      (cond\n       (empty? remaining)\n         (conj acc count curr)\n       (= curr (first remaining))\n         (recur\n           curr\n           (inc count)\n           (rest remaining)\n           acc)\n       :else\n         (recur\n          (first remaining)\n          1\n          (rest remaining)\n          (conj acc count curr)))))]\n    (cons (get-pronunciation n) (lazy-seq (pronunciations (get-pronunciation n))))))","user":"53ac4719e4b047364c04445c"},{"problem":110,"code":"(fn [start]\n  (let [f (fn [coll] (mapcat #(vector (count %) (first %)) (partition-by identity coll)))]\n    (iterate f (f start))))","user":"5e0d948fe4b099d064962f98"},{"code":"(fn [x] (rest (iterate #(mapcat (juxt count first) (partition-by identity %)) x)))","problem":110,"user":"4db858d1535d1e037afb218c"},{"problem":110,"code":"(fn pronunciations [s]\n  (let\n    [pronunciation (apply concat \n                          (map (fn [coll] [(count coll) (first coll)]) \n                               (partition-by identity s)))]\n  (cons pronunciation (lazy-seq (pronunciations pronunciation)))))","user":"5514a60fe4b055c2f668d4d7"},{"problem":110,"code":"(fn sequp [xs] (drop 1 (iterate\n                          (fn [xs] (->> xs\n                                 (partition-by identity)\n                                 (reduce #(conj % (count %2) (first %2)) []))) xs)))","user":"5b924123e4b0c0b3ffbd4a34"},{"problem":110,"code":"(fn p [s] (lazy-seq\n          (let [n (mapcat #(vector (count %) (first %)) \n                          (partition-by identity s))]\n               (cons n (p n)))))","user":"564127a9e4b08d4f616f5ef3"},{"problem":110,"code":"(fn [s]\n  (letfn [(pronounce [s]\n            (mapcat (juxt count first)\n                    (partition-by identity s)))]\n    (rest (iterate pronounce s))))","user":"54684c3be4b00cfc9eacc139"},{"problem":110,"code":"(fn [coll]\n  (let [next (fn [coll] (reduce #(into %1 [(count %2) (first %2)])\n                          [] (partition-by identity coll)))]\n    (drop 1 (iterate next coll))))","user":"55205564e4b08d5046aa8a60"},{"code":"(fn my-sequence-of-pronunciations\r\n  [coll]\r\n  (let [nextVal (into [] (mapcat #(vector (count %) (first %)) (partition-by identity coll)))]\r\n    (cons nextVal (lazy-seq (my-sequence-of-pronunciations nextVal)))))","problem":110,"user":"509a25b7e4b0efbae1fbc0a8"},{"code":"(fn f [s]\n  (let [p (reduce concat (map #(list (count %) (first %)) (partition-by identity s)))]\n    (cons p\n      (lazy-seq (f p)))))","problem":110,"user":"5054c7e1e4b0b1b9d1860eb2"},{"problem":110,"code":"(fn [coll]\n  (let [pronounce (fn [coll]\n                   (let [parted (partition-by identity coll)]\n                     (-> (map count parted)\n                         (interleave (map first parted)))))]\n    (drop 1 (iterate pronounce coll))))","user":"5297dcc5e4b02ebb4ef75047"},{"code":"(fn [x](next (iterate #(mapcat (fn[x] [(count x) (first x)]) (partition-by (fn[x]x) %)) x)))","problem":110,"user":"4f296a80e4b0d6649770a02a"},{"code":"(fn sop [seed]\n  (letfn [(describe [xs]\n            (when-not (empty? xs)\n              (let [h (first xs)]\n                (lazy-cat\n                 [(count (take-while #(= h %) xs)) h]\n                 (describe (drop-while #(= h %) xs))))))]\n    (drop 1 (iterate describe seed))))","problem":110,"user":"52d2ca1ce4b099d49816f0b4"},{"problem":110,"code":"(fn pron [coll]\n           (let [ncoll (->> coll\n                            (partition-by identity)\n                            (map #(vector (count %) (first %)))\n                            flatten)]\n             (lazy-seq\n               (cons ncoll (pron ncoll)))))","user":"56fbf83de4b07572ad1a88da"},{"code":"(fn sop [c]\r\n  (drop 1 (iterate \r\n  \t\t\t\t(fn [v] (reduce \r\n  \t\t\t\t\t\t\t#(conj % (count %2) (first %2)) \r\n  \t\t\t\t\t\t\t[] (partition-by identity v))) \r\n  \t\t\t\tc)))","problem":110,"user":"4ecf1f51535d1f5ad70dba3a"},{"code":"(fn pronunc [coll]\n  (let [f (fn [coll]\n            (reduce #(concat [(count %2) (first %2)] %1)\n                    [] (partition-by identity (reverse coll))))]\n    (iterate f (f coll))))","problem":110,"user":"511e763ce4b03e81d390ac29"},{"code":"(fn pronounce\n  [coll]\n  (rest \n   (iterate #(mapcat (juxt count first) \n                     (partition-by identity %)) \n            coll)))","problem":110,"user":"4f21838fe4b0d66497709fd2"},{"code":"(fn [start]\n  (letfn [\n    (pronunc [s]\n      (reverse (reduce \n        #(let [[digit n & t] %1]\n          (if (= digit %2) \n            (cons digit (cons (inc n) t))\n            (cons %2 (cons 1 %1))))\n        (list) s)))]\n  (next (iterate pronunc start))))","problem":110,"user":"533ab9abe4b0e30313ee6cbf"},{"code":"(fn [l]\n  (rest\n    (iterate\n      #(mapcat \n        (juxt count first)\n        (partition-by identity %))\n      l)))","problem":110,"user":"4fce5474e4b0d4b2a7a9d451"},{"problem":110,"code":"(fn pronunciations [s]\n  (let [s' (->> s\n                (partition-by identity)\n                (map #(list (count %) (first %)))\n                (apply concat))]\n  (lazy-seq (cons s' (pronunciations s')))))","user":"5901158de4b0438e51c2d039"},{"problem":110,"code":"(fn [start] \n  (letfn [(pronounce [a] \n            (flatten \n              (map \n                #(list (count %) (first %)) \n                (partition-by identity a))))]\n  (iterate pronounce (pronounce start))))","user":"541ddadbe4b01498b1a71a84"},{"code":"(fn f [l]\n  (let [x (->> l\n               (partition-by identity)\n               (map (fn [i]\n                      [(count i)(first i)]))\n               (apply concat))]\n    (lazy-seq (cons x (f x)))))","problem":110,"user":"50a83315e4b054305ba5a830"},{"problem":110,"code":"(fn sp [xs]\n  (let [r (flatten (map #(vector (count %) (first %)) (partition-by identity xs)))]\n    (lazy-seq\n     (cons r (sp r)))))","user":"557c6ca6e4b05c286339e0c4"},{"problem":110,"code":"(letfn [(pronounce [s] (->> s \n                            (partition-by identity)\n                            (map #(vector (count %) (first %)))\n                            flatten))]\n  (fn [s] (rest (iterate pronounce s))))","user":"54febf4be4b07d26eda61d45"},{"code":"(fn [f]\n  (drop 1 (iterate (fn [s]\n  (let [g (partition-by identity s)]\n  (interleave (map count g) (map first g)))) f)))","problem":110,"user":"50ad7888e4b0a40c9cfb08c7"},{"code":"(fn [s]\n  (letfn [(pn [s]\n            (flatten\n             (map (fn [a] [(count a) (first a)]) \n                  (partition-by identity s))))]\n    (iterate pn (pn s))))","problem":110,"user":"4fc3a72ae4b081705acca342"},{"code":"(fn gen-prons[s]\n  (letfn [(pron [ss]\n                (let [sss (partition-by identity ss)]\n                  (mapcat #(vector (count %) (first %)) sss)))]\n    (cons (pron s)\n          (lazy-seq (gen-prons (pron s))))))","problem":110,"user":"512eb723e4b0b740abc5982b"},{"problem":110,"code":"(fn pronounce-seq [xs]\n  (let [pronounce #(flatten (map (juxt count first) (partition-by identity %)))]\n    (rest (iterate pronounce xs))))","user":"575b3e9be4b02ea11479935b"},{"problem":110,"code":"(fn say [xs]\n  (loop [to-split xs res []]\n    (let [start (first to-split) [first-string remaining] (split-with (partial = start) to-split)]\n\t\t    ; (println first-string)\n\t\t    ; (println res)\n\t\t    (if (empty? remaining)\n\t\t      (lazy-seq (cons (conj res (count first-string) start) (say (conj res (count first-string) start))))\n\t\t      (recur remaining (conj res (count first-string) start) )))))","user":"5ab276f2e4b073f1774425e6"},{"problem":110,"code":"(fn sq-pron\n    [cvec]\n    (let [next-vec\n          (let [{:keys [cnt num res]}\n                (reduce\n                  (fn\n                    [{:keys [cnt num res] :as full} item]\n                    (if (= item num)\n                      (assoc full :cnt (inc cnt))\n                      {:cnt 1 :num item :res (conj res cnt num)}))\n                  {:cnt 1 :num (first cvec) :res []}\n                  (drop 1 cvec))]\n            (conj res cnt num))]\n      (cons next-vec (lazy-seq (sq-pron next-vec)))))","user":"5f5a2cc6e4b0a0bc16850aa4"},{"problem":110,"code":"(fn pron [x]\n\n  (lazy-seq(concat [(vec(interleave (map count (partition-by identity x)) (flatten (map distinct (partition-by identity x)))))] (pron (interleave (map count (partition-by identity x)) (flatten (map distinct (partition-by identity x))))))))","user":"586b6a0ae4b01531a375e957"},{"problem":110,"code":"#(rest (iterate (fn [nums]\n                 (mapcat (juxt count first) (partition-by identity nums)))\n                %))\n\n; golf\n;(comp rest (partial iterate #(mapcat (juxt count first) (partition-by identity %))))\n;#(rest (iterate (fn [n] (mapcat (juxt count first) (partition-by identity n))) %))","user":"54d341f7e4b0e8a36923e603"},{"code":"#(next (iterate (fn [x]\n                  (flatten \n                    (map (fn [x] [(count x) (first x)])\n                         (partition-by identity x))))\n                %))","problem":110,"user":"4f32a7f1e4b0d6649770a095"},{"code":"(fn se [xs]\n  (let [res\n        (reduce #(conj % (count %2) (first %2)) [] (partition-by identity xs))]\n    res\n    (cons res (lazy-seq (se res)))\n  ))","problem":110,"user":"513fab65e4b00f13ea1bd891"},{"problem":110,"code":"(fn [s]\n  (rest\n   (iterate \n    (fn [t]\n      (->> t\n           (partition-by identity)\n           (map (juxt count first))\n           flatten))\n    s)))","user":"5657fed1e4b0f9d632dd84ae"},{"problem":110,"code":"(fn q[v]\n    (let [f (fn [v]\n              (loop [v v r [] n 0 c 0]\n                (if (seq v)\n                  (if-not (= n (first v))\n                    (if (= n 0)\n                      (recur (rest v) r (first v) 1)\n                      (recur (rest v) (conj r c n) (first v) 1)\n                      )\n                    (recur (rest v) r n (+ c 1))\n                    )\n                  (conj r c n)\n                  )\n                )\n              ) g (f v)]\n      (cons g (lazy-seq (q g)))\n      )\n    )","user":"54b90836e4b0ed20f4ff6e9d"},{"code":"(fn [init]\n  (let [pronounce (fn [vector]\n                    (->> vector\n                         (partition-by identity)\n                         (mapcat (fn [group]\n                                   [(count group) (first group)]))))]\n    (next (iterate pronounce init))))","problem":110,"user":"4eae5fe4535d7eef30807325"},{"code":"(fn pronunciations [seq]\n           (lazy-seq\n             (let [new-seq\n                   (let [groups (partition-by identity seq)]\n                     (mapcat (fn [group]\n                               [(count group)\n                                (first group)])\n                             groups))]\n               (cons new-seq\n                     (pronunciations new-seq)))))","problem":110,"user":"4f35b2ace4b0e243712b1ec5"},{"problem":110,"code":"(fn pron [s]\n  (drop 1 (iterate (fn [s]\n                     (mapcat (juxt count first)\n                             (partition-by identity s))) \n                    s)))","user":"57644395e4b0994c1922fbf2"},{"problem":110,"code":"(fn pronunciation [c]\n           (let [pronunciated (reduce #(into (into %1 (list (count %2))) (list (first %2))) [] (partition-by identity c))]\n             (lazy-seq (cons pronunciated (pronunciation pronunciated)))))","user":"52fac708e4b047fd55836fff"},{"problem":110,"code":"(fn pronunications [xs]\n\t(let [nxs (mapcat #(vector (count %) (first %)) (partition-by identity xs))]\n\t(cons\n\t\tnxs\n\t\t(lazy-seq (pronunications nxs)))))","user":"54448e84e4b032a45b869393"},{"code":"(fn pron [s]\n   (let [ns\n         (flatten\n           (map #(into [] %)\n                (map clojure.set/map-invert\n                     (map frequencies\n                          (partition-by identity s)))))]\n     (cons\n       ns\n       (lazy-seq (pron ns)))))","problem":110,"user":"51c09719e4b0c9c82288293c"},{"code":"(fn f [s]\n    (letfn [(pronounce [s]\n              (loop [s s\n                     p []]\n                (if-not (seq s)\n                  p\n                  (let [x (first s)\n                        n (count (take-while #(= x %) s))]\n                    (recur (drop n s)\n                           (conj (conj p n) x))))))]\n      (lazy-seq\n        (let [p (pronounce s)]\n          (cons p (f p))))))","problem":110,"user":"521b9f92e4b0c4ef0be8304c"},{"problem":110,"code":"(fn tr [sq]\n      (lazy-seq\n        (let [fr (fn [s]\n                     (loop [x s, last (first x), cnt 0, r []]\n                           (if (empty? x )\n                             (conj (conj r cnt) last)\n                             (let [c (first x)]\n                                  (recur\n                                    (rest x)\n                                    c\n                                    (if (= c last) (inc cnt) 1)\n                                    (if (not= c last) (conj (conj r cnt) last) r)\n                                    )\n                                  )\n                             )\n                           )\n                     )]\n             (cons\n               (fr sq)\n               (tr (fr sq))\n               )\n             )\n        )\n      )","user":"53bcdd41e4b0d9a98559a6c0"},{"code":"(fn lazy-pron [sq]\n  (let [next-sq (mapcat (juxt count first) (partition-by identity sq))]\n    (lazy-seq (cons next-sq (lazy-pron next-sq)))))","problem":110,"user":"52dd4fb4e4b09f7907dd13df"},{"problem":110,"code":"(fn [xs] (letfn[\n     (pron [ts] ( letfn [\n         (fr [res n t ys] \n             (if (first ys) \n                 (let [y1 (first ys) ry (rest ys)]\n                   (if (= n 0) \n                       (recur res 1 y1 ry) \n                       (if (= t y1)\n                          (recur res (inc n) t ry)\n                          (recur (conj (conj res n) t) 0 nil ys )\n                        )\n                    )\n                  )\n                  (if (> n 0) \n                      (conj (conj res n ) t )\n                       res\n                  )\n             )\n          )]\n               (fr [] 0 nil ts)\n              ))\n     (hfr [v] (lazy-seq \n                  (cons v (hfr (pron v)))\n               ))\n     ]\n    (drop 1 (hfr xs))\n   )\n  )","user":"59ff9424e4b01bb0ae8afd24"},{"problem":110,"code":"(letfn [(pronounce [ys]\n                   (if (empty? ys)\n                     '()\n                     (let [y (first ys)\n                           eq #(= y %)\n                           txs (take-while eq ys)]\n                       (list* (count txs) y (pronounce (drop-while eq ys))))))]\n           (fn __ [xs]\n             (let [v (pronounce xs)]\n               (cons v (lazy-seq (__ v))))))","user":"56706f01e4b0a866af6896f2"},{"problem":110,"code":"(fn [c]\n  (rest (iterate (fn [c']\n                   (->> (partition-by identity c')\n                        (mapcat #(identity [(count %) (first %)])) ))\n                 c)))","user":"56441634e4b0018b46ad8c08"},{"problem":110,"code":"(fn pronounce\n  [coll]\n  (let [pronounciation (mapcat\n                         (fn [group]\n                           [(count group) (first group)])\n                         (partition-by identity coll))]\n    (lazy-seq (cons pronounciation (pronounce pronounciation)))))","user":"554bd33ce4b0a04f7929959a"},{"code":"(fn pro-seq [coll]\n  (let\n    [pronounced\n      (mapcat\n        (juxt count first)\n        (partition-by identity coll))]\n    (cons\n      pronounced\n      (lazy-seq (pro-seq pronounced)))))","problem":110,"user":"4f7f9665e4b033992c121bea"},{"problem":110,"code":"(fn pronunciations [coll]\n  (letfn [(chunkify [xs]\n            (partition-by identity xs))\n          (add-labels [ys]\n            (map #(vector (count %) (first %)) ys))\n          (pronounce [zs]\n            (vec (apply concat (add-labels (chunkify zs)))))]\n    (rest (iterate pronounce coll))))","user":"53bf0913e4b0c98a41f5cc99"},{"problem":110,"code":"(fn\n  [c]\n  (letfn [(f\n            [c]\n            (reduce #(apply into %1 %2) []  (map #(assoc {} (count %) (first %)) (partition-by identity c))))]\n    (iterate f (f c))))","user":"57d0cd58e4b0bd073c20235e"},{"code":"(fn f[coll]\n  (let [nxt (->> (partition-by identity coll)\n                 (reduce #(into %1 [(count %2) (first %2)]) []))] \n    (cons nxt\n        (lazy-seq (f nxt)))))","problem":110,"user":"51696ee7e4b03f62cda68ce8"},{"problem":110,"code":"(fn\n  [v]\n  (rest (iterate #(flatten (map (fn [c]\n                                  [(count c) (first c)])\n                                (partition-by identity %))) v)))","user":"56a36f76e4b0542e1f8d14ca"},{"code":"(fn [s] (next (iterate (fn [x] (mapcat #(vector (count %) (first %)) (partition-by str x))) s)))","problem":110,"user":"52bf29fde4b07a9af579232e"},{"code":"(fn [n]\n  (rest (iterate\n      (fn [n]\n  (->> n (partition-by identity) (mapcat #(vector (count %) (first %))) (into []))\n  ) n)))","problem":110,"user":"5124619ae4b02c3f2a072ccd"},{"problem":110,"code":"#(rest (iterate (fn [i] (mapcat (juxt count first) (partition-by identity i))) %))","user":"53fa3524e4b0de5c41848578"},{"problem":110,"code":"(fn [x] (let [g (fn [y] (mapcat #(vector (count %) (first %)) (partition-by identity y)))] ((fn peu [z] (cons z (lazy-seq (peu (g z))))) (g x))))","user":"53fc8424e4b0de5c418485b3"},{"problem":110,"code":"(let [pronunciations\n      (fn [xs]\n        (loop [xs xs\n               ps []]\n          (if-let [[x & xs] (seq xs)]\n            (let [x-coll (take-while #(= x %) xs)\n                  rest-coll (drop-while #(= x %) xs)]\n              (recur rest-coll (conj ps [(inc (count x-coll)) x])))\n            (apply concat ps))))]\n  #(drop 1 (iterate pronunciations %)))","user":"4ff24a1ae4b0678c553fc337"},{"code":"(fn [v]\n    (let\n        [describe\n         (fn [v]\n        \n           (mapcat (juxt count first)\n             (partition-by identity v)\n             )\n           )]\n      (drop 1 (iterate describe v)))\n    )","problem":110,"user":"4daea889edd6309eace4d15b"},{"problem":110,"code":"(comp next \n      (partial iterate \n               #(mapcat (juxt count first) (partition-by identity %))))\n\n#_\n(letfn [(pronunciation [xs]\n         (mapcat (juxt count first) (partition-by identity xs)))]\n #(->> (iterate pronunciation %) rest))\n\n#_\n(letfn [(pronunciation [xs]\n         (let [nss (partition-by identity xs)]\n          (->> (for [ns nss] [(count ns) (first ns)])\n               flatten)))]\n #(->> (iterate pronunciation %) rest))","user":"5bea3177e4b0f319e2d7ec81"},{"problem":110,"code":"; chouser's solution:\n(fn [xs] (rest (iterate #(mapcat (juxt count first) (partition-by identity %)) xs)))\n\n; first solution\n#_(fn [seq]\n    (letfn [(pronounce-sequence [numFound findItem xs]\n                                (cond\n                                  (empty? xs) [numFound findItem]\n                                  (= findItem (first xs)) (recur (inc numFound) findItem (rest xs))\n                                  :else (lazy-seq (concat [numFound findItem] (pronounce-sequence 1 (first xs) (rest xs))))))\n            (start-sequence [xs] (pronounce-sequence 1 (first xs) (rest xs)))\n            ]\n      (rest (iterate start-sequence seq))))","user":"55e7d06ee4b050e68259b496"},{"problem":110,"code":"(fn yo [n]\n             (lazy-seq\n               (let [a (flatten (map #(vec [(count %) (first %)]) (partition-by identity n)))]\n                 (cons a (yo a)))\n               )\n             )","user":"58a44a14e4b01a0c0b2328f2"},{"code":"(fn [coll]\n  (letfn [(pro [coll]\n    (mapcat #(vector (count %) (first %)) (partition-by identity coll)))]\n(iterate pro (pro coll))))","problem":110,"user":"503354c3e4b0c6c1199c710c"},{"problem":110,"code":"(fn p110 [s]\n   (let [partitioned-seq (partition-by identity s)\n         seq-of-counts (map count partitioned-seq)\n         seq-of-vals (map first partitioned-seq)\n         final-answer (interleave seq-of-counts seq-of-vals)]\n     (cons final-answer (lazy-seq (p110 final-answer)))))","user":"525c575be4b0cb4875a45d38"},{"problem":110,"code":"#(rest (iterate \n         (fn [xs] \n           (flatten (map (juxt count first) \n                         (partition-by identity xs)))) %))","user":"4e6ebd4a535d5021c1a89610"},{"problem":110,"code":"(fn myf [coll]\n  (letfn [(sub [coll] (let [lst (partition-by identity coll)\n                            cnt (map count lst)\n                            iden (map first lst)]\n                        (interleave cnt iden)))]\n    (iterate sub (sub coll))))","user":"577c3da9e4b0c8d87281f6b9"},{"problem":110,"code":"(fn prons [sq]\n    (rest \n    \t(iterate (fn [xs] (mapcat #(list (count %) (first %)) (partition-by identity xs)))\n    \tsq)))","user":"52e657e4e4b09f7907dd1472"},{"code":"(fn [s]\n  (let [pronounce (fn [s]\n                    (apply conj\n                           (reduce (fn [[r i n] e]\n                                     (if (= n e)\n                                       [r (inc i) n]\n                                       [(conj r i n) 1 e]))\n                                   [[] 0 (first s)]\n                                   s)))]\n    (iterate pronounce (pronounce s))))","problem":110,"user":"5392b849e4b0b51d73faaeb1"},{"problem":110,"code":"(fn [coll]\n  (letfn [(partition-by-v [coll]\n          (if (seq coll)\n            (let [[part rm] (split-with #(= (first coll) %) coll)]\n              (cons part (partition-by-v rm)))))\n          (pronounce [coll]\n            (->> (partition-by-v coll)\n                 (map #(vector (count %) (first %)))\n                 flatten))\n          (pronounciations [coll]\n            (lazy-seq\n              (cons (pronounce coll) (pronounciations (pronounce coll)))))]\n    (pronounciations coll)))","user":"5a9dbb32e4b0d174b936c7f3"},{"code":"#(rest (iterate\n  (fn [x] (mapcat (juxt count first)\n   (partition-by identity x))) %))","problem":110,"user":"4ea41fc2535d7eef308072cb"},{"code":"(fn [s]\n  (drop 1 (iterate (fn [s]\n                     (mapcat (juxt count first)\n                             (partition-by identity s))) s)))","problem":110,"user":"52d7f7efe4b09f7907dd1380"},{"code":"(fn [xs]\r\n  (rest\r\n   (iterate\r\n    #(reverse\r\n      (reduce\r\n       (fn [[x n & xs :as l] y]\r\n         (if (nil? x) [y 1]\r\n             (if (= x y) (cons x (cons (inc n) xs))\r\n                 (cons y (cons 1 l)))))\r\n       [] %)) xs)))","problem":110,"user":"4dc1ee85535d020aff1edf91"},{"problem":110,"code":"(fn [y] \n  (drop 1 (iterate #(vec (flatten (map (juxt count first) (partition-by identity %)))) y)))","user":"551c66dae4b07993ea3788de"},{"problem":110,"code":"(fn [xs] (drop 1 (iterate (fn [xs] (mapcat #(vector (count %) (first %)) (partition-by identity xs))) xs)))","user":"586bc870e4b01531a375e964"},{"code":"(fn count-p\n  [l]\n  (letfn [(count-num [l]\n                     (mapcat #(vector (count %) (first %)) (partition-by identity l)))]\n    (rest (iterate count-num l))))","problem":110,"user":"52dd6cc8e4b09f7907dd13e2"},{"problem":110,"code":"(fn sp [s]\n  (lazy-seq\n    (let [a (mapcat #(vector (count %) (first %)) (partition-by identity s))]\n      (cons a (sp a)))))","user":"53ce4cd4e4b00fb29b2212ef"},{"code":"(fn [x] (rest (iterate (fn [s] (reduce #(if (= %2 (last %))\n                                          (update-in % [(- (count %) 2)] inc)\n                                          (conj % 1 %2))\n                                       [] \n                                       s))\n                        x)))","problem":110,"user":"4ee88bfb535d93acb0a66881"},{"code":"(fn f [s]\n  (let [r (flatten (map #(list (count %) (nth % 0))\n                        (partition-by identity s)))]\n    (cons r \n          (lazy-seq (f r)))))","problem":110,"user":"4e49badd535dc968683fc4c9"},{"code":"(fn [c]\n  (let [step (fn [so-far to-go]\n               (if (empty? to-go)\n                   so-far\n                   (let [current (first to-go)\n                         this-step (count (take-while #{current} to-go))]\n                    (recur (conj so-far this-step current) (drop this-step to-go)))))\n        pronounce (fn [c] (step [] c))]\n  (drop 1 (iterate pronounce c))))","problem":110,"user":"4e42f930535dc968683fc49f"},{"problem":110,"code":"(comp rest (partial iterate\n                      #(->> %\n                            (reduce (fn [[[c v] & vs :as vss] v']\n                                      (if (= v v')\n                                        (cons [(+ c 1) v] vs)\n                                        (cons [1 v'] vss))) nil)\n                            reverse\n                            flatten)))","user":"54c641f8e4b045293a27f628"},{"problem":110,"code":"(fn pro [a] \n  (rest (iterate \n   #(mapcat \n\t (fn [v] (vector (count v) (first v))) \n\t(partition-by identity %)) a)))","user":"538e29d1e4b0b51d73faae80"},{"problem":110,"code":"(fn pronunciations [s]\n  (let [group-same (fn group-same [s]\n                      (if (empty? s)\n                        (list)\n                        (let [[h t](split-with #(= % (first s)) s)]\n                          (cons h (lazy-seq (group-same t))))))\n        codify (fn [grp-s]\n                  (flatten (map (fn [s] (vector (count s) (first s))) (group-same grp-s))))]\n  (rest (iterate codify s))))","user":"590b055ae4b047aa04b199c9"},{"problem":110,"code":"(fn pronounce\n  [coll]\n  (rest (iterate (fn [nums]\n                   (->> nums\n                        (partition-by identity)\n                        (mapcat (juxt count first))))\n                 coll)))","user":"5974d2ede4b01722bebd4cb6"},{"problem":110,"code":"(fn [init-coll]\n  (letfn [\n          (pron [coll]\n                (letfn [(batch-seq [coll]\n                                   (if (empty? coll)\n                                     []\n                                     (let [f (first coll) sp (split-with #(= % f) (rest coll)) b (cons f (first sp)) r (second sp)]\n                                       (lazy-seq (cons b (batch-seq r))))))]\n                  (flatten (map #(vector (count %) (first %)) (batch-seq coll)))))\n          ]\n    (drop 1 (iterate pron init-coll))))","user":"55afd469e4b002ce9d5cbc19"},{"code":"(fn [s]\n  (drop 1 (iterate (fn [s] \n                     (mapcat (juxt count first) \n                              (partition-by identity s))) s)))","problem":110,"user":"4f05ea25535dcb61093f6c02"},{"problem":110,"code":"(fn [coll]\n  (rest\n   (iterate (fn [coll*]\n              (->> coll*\n                   (partition-by identity)\n                   (mapcat #(vector (count %1) (first %1)))))\n            coll)))","user":"5c3796b3e4b0d62ef62d9f77"},{"problem":110,"code":"#(next (iterate (fn [x] \n                  (mapcat (fn [[f :as a]] \n                            [(count a) f]) \n                          (partition-by identity x))) \n                %))","user":"5c1aadcde4b01240ff567209"},{"problem":110,"code":"(fn r [s]\n  (let [res (->> s\n              (partition-by identity)\n              (map #(vector (count %) (first %)))   \n              (flatten))]\n    (cons res\n      (lazy-seq    \n        (r res)))))","user":"51aefceee4b09397d5109797"},{"problem":110,"code":"(fn f [xs]\n\t(let [y (reduce (fn [els el] (if (= (last els) el) (concat (drop-last 2 els) [(inc (first (take-last 2 els))) el]) (concat els [1 el]))) [] xs)] \n      (lazy-seq (cons y (f y)))))","user":"5a14228fe4b0ff51aa4b3193"},{"code":"(fn f [s]\r\n  (let [s (partition-by identity s)\r\n        t (reduce into [] (map #(list (count %) (first %)) s))]\r\n    (cons t (lazy-seq (f t)))))","problem":110,"user":"50464831e4b011c5dfee771f"},{"problem":110,"code":"(fn pronounce [myseq]\n  (let \n    [\n     stepping \n     (fn [myseq]\n      (into [] \n        (flatten\n          (reduce \n           (fn \n             [prev item] \n             (if \n               (empty? prev) \n               (vector (vector 1 item))\n               (into [] (concat (pop prev) ((fn [[numof value] x] (if (= value x) (vector (vector (inc numof) value)) (vector (vector numof value) (vector 1 x)))) (peek prev) item)))\n               )\n             )\n           []\n           myseq)\n         )\n        )\n      ),\n     step (stepping myseq)\n     ]\n    (cons step (lazy-seq (pronounce step)))\n     )\n    )","user":"58950f29e4b00487982d5270"},{"code":"(fn [x] \n  (rest (iterate #(mapcat (fn [x] [(count x) (first x)]) (partition-by identity %)) x)))","problem":110,"user":"4f047542535dcb61093f6bc7"},{"code":"(fn [y]\n  (next\n    (iterate\n      (fn [x]\n        (reduce #(conj %1 (count %2) (first %2)) [] (partition-by identity x))\n      )\n      y\n    ) \n  )\n)","problem":110,"user":"5176afd2e4b085adf681d889"},{"problem":110,"code":"(fn [n]\n  (letfn\n    [(grouping-nums\n       ([nums]\n        (grouping-nums nums []))\n       ([nums accumulating-total]\n        (if (empty? nums)\n          accumulating-total\n          (recur (rest nums)\n                 (if (= (first (last accumulating-total)) (first nums))\n                   (into [] (concat (into [] (take (- (count accumulating-total) 1) accumulating-total))\n                         (vector (into [] (concat\n                                    (into [] (concat (last accumulating-total) (vector (first nums)))))))))\n                   (into [] (concat\n                     accumulating-total\n                     (vector (vector (first nums))))))))))\n\n     (pronunciation [nums]\n       (into []\n             (reduce concat\n                     (map (fn [group-of-the-same]\n                            (vector (count group-of-the-same)\n                                    (first group-of-the-same)))\n                          (grouping-nums nums))))\n       )\n\n     (pronunciations [nums]\n       (lazy-seq (cons (pronunciation nums)\n                       (pronunciations (pronunciation nums))))\n       )]\n    (pronunciations n)))","user":"5b60e88be4b0c6492753e70b"},{"problem":110,"code":"(fn pronunciations [coll]\n  (let [p (mapcat #(vector( count %) (first %)) (partition-by identity coll))] \n   (lazy-seq (cons p (pronunciations p)))))","user":"566ff0a1e4b0a866af6896ec"},{"code":"(let [f (fn [xs] (let [partitions (partition-by identity xs)]\n                   (mapcat (juxt count first) partitions)))]\n  (fn [coll] (rest (iterate f coll))))","problem":110,"user":"4ebcb8ff535dfed6da9c6d8a"},{"code":"(fn recursive-pronounce [s]\n  (let [p (loop [s s\n                 result []]\n            (if (empty? s)\n              result\n              (let [head (first s)\n                    repeats (count (take-while #(= head %) s))\n                    tail (drop repeats s)]\n                (recur tail (concat result [repeats head])))))]\n    (lazy-seq (cons p (recursive-pronounce p)))))","problem":110,"user":"5310e7aee4b08068f379ecdc"},{"code":"(fn exp_ [col]\r\n  (let[gen  (fn[col]\r\n  \t\t\t\t\t\t   (loop[l (rest col),currKey (first col),currVal 1,result [] ]\r\n\t\t\t\t\t\t\t       (let[v (first l)]\r\n\t\t\t\t\t\t\t         (cond (nil? v)\r\n\t\t\t\t\t\t\t                 (conj (conj result currVal) currKey)\r\n\t\t\t\t\t\t\t               (= v currKey)\r\n\t\t\t\t\t\t\t                 (recur (rest l) currKey (inc currVal) result)\r\n\t\t\t\t\t\t\t               :else\r\n\t\t\t\t\t\t\t                 (recur (rest l) v 1 (conj (conj result currVal) currKey) )\r\n\t\t\t\t\t\t\t               )\r\n\t\t\t\t\t\t\t         )\r\n\t\t\t\t\t\t\t     )\r\n\t\t\t\t\t\t\t  )\r\n       ]\r\n       (iterate gen (gen col))\r\n    )\r\n  )","problem":110,"user":"4f6d9d7ee4b07046d9f4efcd"},{"code":"(fn [n] (let [f (fn [x] (mapcat #(vector (count %) (first %)) (partition-by identity x)))] (iterate f (f n))))","problem":110,"user":"4eb13d60535d7eef3080733f"},{"problem":110,"code":"(fn __\n  [coll]\n  (letfn [(next [item]\n            (let [partitioned (partition-by identity item)]\n              (reduce #(conj % (count %2) (first %2)) [] partitioned)))]\n    (iterate next (next coll))))","user":"55a62092e4b0acc240e31554"},{"code":"#(rest (iterate %1 %2))\n\n(fn grouping [coll]\n  (if (empty? coll) []\n    (let [[x & xs] coll\n          [l r] (split-with #(= % x) xs)]\n      (concat [(inc (count l)) x] (grouping r)))))","problem":110,"user":"500933a6e4b046cdb195e074"},{"problem":110,"code":"(fn solution [initial]\n  (let [mapped (partition-by identity initial)\n        pronunciation (reduce #(conj %1 (count %2) (first %2)) [] mapped)]\n    (lazy-seq (cons pronunciation (solution pronunciation)))))","user":"5e2ef900e4b05b4b015161fc"},{"code":"(letfn [(pronounce [s]\n          (flatten (for [x (partition-by identity s)]\n            [(count x) (first x)])))]\n  #(rest (iterate pronounce %))\n)","problem":110,"user":"4e9dafe1535dbda64a6f6b89"},{"problem":110,"code":"(fn [cs]\n  (drop 1\n        (iterate\n          (fn [cs]\n            (->> (partition-by identity cs)\n                 (mapcat #(vector (count %) (first %)))))\n          cs)))","user":"594880ade4b07ddc2dafadc2"},{"code":"(fn [init]\n         (rest (iterate\n          (fn pronounce [n]\n            (mapcat\n             (fn [x] (list (count x) (first x)))\n             (loop [n n acc []]\n               (let [[g r] (split-with (partial = (first n)) n)]\n                 (if (not (empty? r))\n                   (recur r (conj acc g))\n                   (conj acc g)\n                   )))\n             )) init)))","problem":110,"user":"503ca47fe4b06c4e0e1fa24f"},{"code":"(fn pronunciations [coll]\n                   (let [pron (->> (partition-by identity coll)\n                                   (map #(vector (count %) (first %)))\n                                   (apply concat))]\n                     (cons pron (lazy-seq (pronunciations pron)))))","problem":110,"user":"50310b8be4b05b7df5a0b84d"},{"code":"#(rest (iterate (fn [coll] (mapcat (juxt count first) (partition-by identity coll))) %))","problem":110,"user":"5032b066e4b00c0952a257ea"},{"code":"(fn pron-sequence[init-seq]\n\t(letfn [(next-pronunciation [int-seq]\n\t\t\t\t(loop [c-seq int-seq res []]\n\t\t\t\t\t(let [ f (first c-seq) ]\n\t\t\t\t\t\t(if (= f nil)\n\t\t\t\t\t\t\tres\n\t\t\t\t\t\t\t(let [ f-seq (take-while #(= f %) c-seq) \n\t\t\t\t\t\t\t\t  n-seq (drop-while #(= f %) c-seq) ]\n\t\t\t\t\t\t\t\t(recur n-seq (conj res (count f-seq) f))\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)]\n\t\t(let [nxt (next-pronunciation init-seq)]\n\t\t\t(cons nxt (lazy-seq (pron-sequence nxt)))\n\t\t)\n\t)\n)","problem":110,"user":"52763696e4b03e8d9a4a74d7"},{"code":"(fn self [xs] (let [res (#(vec (flatten (map (fn [x] (list (count x) (first x))) \n                                              (partition-by identity %)))) xs)] \n                 (cons res (lazy-seq (self res)))))","problem":110,"user":"513d121fe4b0e544971636a2"},{"code":"(fn q110 [coll]\n  (rest\n    (iterate\n      (fn [coll]\n  \t    (reduce \n\t\t      #(conj % (count %2) (first %2))\n\t\t      []\n\t\t      (partition-by identity coll)))\n      coll)))","problem":110,"user":"4fd22e70e4b04c3a95aa041c"},{"code":"(fn pronunciations [xs] \n  (letfn [(pron [xs]\n                (mapcat #(list (count %) (first %)) (partition-by identity xs)))]\n    (let [p (pron xs)]\n      (cons p (lazy-seq (pronunciations p))))))","problem":110,"user":"536ca4bde4b0fc7073fd6e49"},{"problem":110,"code":"(fn sequence-of-pronounciations\n  [xs]\n  (let [ys (mapcat (fn [[z & zs :as e]] [(count e) z]) (partition-by identity xs))]\n    (lazy-seq (cons ys (sequence-of-pronounciations ys)))))","user":"506f0968e4b09350ab4199f5"},{"code":"(fn [l1]\n  (drop 1 \n        (iterate\n         (fn p [l]\n           (let [[identicals restlist] (split-with #{(first l)} l)]\n             (concat [(count identicals) (first identicals)] (if (empty? restlist) [] (p restlist)))))\n         l1)))","problem":110,"user":"5034b0e1e4b062bc5d7ae167"},{"problem":110,"code":"(fn pronunciations [x]\n  (let [compress (fn rec [[x0 & xs]]\n                   (loop [res [], curr-cnt 1, curr-word x0, [cand & cands] xs]\n                     (cond (nil? cand) (conj res curr-cnt curr-word )\n                           (= cand curr-word) (recur res (+ curr-cnt 1) curr-word cands)\n                           true (recur (conj res curr-cnt curr-word) 1 cand cands))))]\n    (let [curr-proun (compress x)]\n      (cons curr-proun (lazy-seq (pronunciations curr-proun))))))","user":"54bbaa8ee4b0ed20f4ff6ec0"},{"code":"(fn pronunciations [s]\n  (let [group (fn group [s] \n                (when-not (empty? s) \n                  (lazy-seq \n                    (cons \n                      (take-while #(== (first s) %) s)\n                      (group (drop-while #(== (first s) %) s))))))\n        grouped (group s)\n        pron (interleave (map count grouped) (map first grouped))]\n    (lazy-seq (cons pron (pronunciations pron)))))","problem":110,"user":"4f50c414e4b03ad3f0c10d0d"},{"problem":110,"code":"(fn [x]\n         (rest (iterate\n                 #(let [n (partition-by identity %)\n                        a (map count n)\n                        b (map last n)]\n                   (interleave a b))\n                 x)))","user":"55630cc1e4b0c656e3ff17e0"},{"problem":110,"code":"(fn pron-seq [s]\r\n  (rest (iterate\r\n    (fn [a]\r\n      (mapcat\r\n        #(list (count %) (first %)) \r\n        (partition-by identity a)))\r\n    s)))","user":"5470699ae4b00cfc9eacc1b6"},{"problem":110,"code":"#(rest\n  (iterate\n    (fn [s]\n      (loop [s s result [] elem (first s) c 0]\n        (if (empty? s)\n          (conj result c elem)\n          (if (= (first s) elem)\n            (recur\n              (rest s)\n              result\n              (first s)\n              (inc c))\n            (recur\n              s\n              (conj result c elem)\n              (first s)\n              0)))))\n    %))","user":"5a2df4a0e4b09cafd31c7f74"},{"code":"(fn [c]\n  (rest (iterate\n    (fn pro [v]\n      (vec (if (empty? v) []\n        (lazy-seq (cons \n                  (count (take-while #(= (first v) %) v)) \n                  (cons \n                    (first v)\n                    (pro (drop-while #(= (first v) %) v))\n                  )\n                )\n      )))\n    )\n    c))\n)","problem":110,"user":"4f84400de4b033992c121c2e"},{"problem":110,"code":"(comp rest\n      (partial\n       iterate (fn [coll]\n                 (loop [acc   []\n                        items coll]\n                   (if (empty? items)\n                     acc\n                     (let [head           (first items)\n                           [matches tail] (split-with #(= % head) items)]\n                       (recur (conj acc (count matches) head)\n                              tail)))))))","user":"5a95c639e4b0d174b936c75e"},{"problem":110,"code":"(fn x [y]\n  (let [f (fn [s] (reduce #(conj %1 (count %2) (first %2)) [] (partition-by identity s)))\n        result (f y)]\n   (lazy-seq (cons result (x result)))      \n  )\n  \t  \t  \n  \n  )","user":"56db90d4e4b0ea9b8538f80d"},{"code":"(fn pronounciation-seq [ns]\n    (let [groups (partition-by identity ns)\n          pronounciation (flatten (map #(list (count %) (first %)) groups))]\n      (cons pronounciation (lazy-seq (pronounciation-seq pronounciation)))))","problem":110,"user":"50763574e4b0a894bb95bf3d"},{"code":"(fn seq-pronunce [coll]\n    (let [ pronunce     \n          (fn [coll]\n            (loop [cur (first coll) cn 1 acc []  xs (rest coll)]\n              (if (seq xs) \n                (if (= cur (first xs))\n                  (recur cur (inc cn) acc (rest xs))\n                  (recur (first xs) 1 (concat acc [cn cur]) (rest xs)))\n                (concat acc [cn cur]))))\n          pronunciation (pronunce coll) ]\n      (lazy-seq (cons pronunciation (seq-pronunce pronunciation)))\n      )\n    )","problem":110,"user":"50eddbc4e4b06330c1f87c4b"},{"code":"#(iterate % (% %2))\n(fn [s]\n  (mapcat #(list (count %) (last %))\n          (partition-by #(-> %) s)))","problem":110,"user":"536e0930e4b0fc7073fd6e66"},{"code":"(fn [x] (drop 1 (iterate (fn [c] (reduce #(conj %1 (count %2) (first %2)) [] (partition-by identity c))) x)))","problem":110,"user":"5098bcfee4b0cae2931060a1"},{"problem":110,"code":"(fn pronounciations [coll]\n                     (let [out (flatten (reduce (fn [acc val]\n                                          (cond\n                                           (empty? acc)\n                                           [[1 val]]\n                                          \n                                           (= (last (last acc)) val)\n                                           (conj (vec (butlast acc)) [(inc (first (last acc))) val])\n                                          \n                                           :else\n                                           (conj acc [1 val]))) [] coll))]\n                       (cons out (lazy-seq (pronounciations out)))))","user":"52efd3d9e4b05e3f0be25ed4"},{"problem":110,"code":"(fn p-110 [ns]\n  (letfn [(p [coll]\n            (->> coll\n                 (partition-by identity)\n                 (mapcat (juxt count first))))]\n    (drop 1 (iterate p ns))))","user":"501d34f6e4b066e56b9d0b1e"},{"code":"(fn p [s]\n  (let [r (vec (flatten (map (juxt count first) (partition-by identity s))))]\n    (cons r (lazy-seq (p r)))))","problem":110,"user":"4f2d5f5de4b0d6649770a05a"},{"problem":110,"code":"(fn reading [seed]\n  (let [r (apply concat (map #(list (count %) (first %)) (partition-by identity seed)))]\n\t(cons r (lazy-seq (reading r)))))","user":"56979bb7e4b0e0b3d3318cac"},{"problem":110,"code":"(fn pronunciations-fn [coll]\n    (lazy-seq\n      (let [pronunciations\n            (mapcat\n              (fn [coll]\n                [(count coll) (first coll)]) (partition-by identity coll))]\n        (cons pronunciations (pronunciations-fn pronunciations)))))","user":"569f4dabe4b0542e1f8d1491"},{"problem":110,"code":"#(rest\n          (iterate\n            (fn [s]\n              (flatten (map (juxt count first) (partition-by identity s))))\n            %))","user":"5a91988ae4b002d099cae6f9"},{"problem":110,"code":"(fn [coll]\n  (letfn [(pronounce [coll]\n            (flatten\n             (map\n              #(list (count %) (first %))\n              (partition-by identity coll))))]\n    (rest\n     (iterate pronounce coll))))","user":"56504dc2e4b0284900eef6bc"},{"problem":110,"code":"(fn lzpn [coll]\n            (let [pronunciation (fn [_coll]\n                                  (reduce #(conj % (count %2) (first %2)) []\n                                          (partition-by identity _coll)))\n                  p (pronunciation coll)]\n              (lazy-seq (cons p (lzpn p)))))","user":"55a372f1e4b0acc240e31537"},{"code":"(fn [v]\n  (rest (iterate #(flatten (for [x (partition-by identity %)] [(count x) (first x)])) v)))","problem":110,"user":"4e9519b4535dbda64a6f6b2d"},{"code":"(fn [n] \n    (rest \n      (iterate  \n    (fn [v]\n      (vec (apply concat \n        (map #(vector (count %) (first %))\n            (partition-by identity v)))))\n        n)))","problem":110,"user":"4facd2fae4b081705acca22f"},{"problem":110,"code":"(fn [coll]\n  (->> coll\n       (iterate (fn [x]\n                  (mapcat #(vector (count %) (first %))\n                          (partition-by identity x))))\n       rest))","user":"5712854ce4b07c98581c3a89"},{"code":"(fn pronounce [it]\n          (let [r (into [] (flatten (map #(vector (count %) (first %))  (partition-by identity it))))]\n            (cons r (lazy-seq (pronounce r)))))","problem":110,"user":"50550f43e4b0b1b9d1860eb7"},{"code":"(fn problem-110 [s]\n  (let [result\n        (reduce\n         (fn [result next-group]\n           (conj result (count next-group) (first next-group)))\n         []\n         (partition-by identity s))]\n    (lazy-seq\n      (cons result (problem-110 result)))))","problem":110,"user":"4f31519ae4b0d6649770a086"},{"problem":110,"code":"(fn [xs] \n\t(rest (iterate \n      (fn [y] \n        (mapcat \n         (juxt count first) \n         (partition-by identity y))) xs)))","user":"51bfc1f0e4b0e49ef9037dd4"},{"problem":110,"code":"(comp (partial drop 1)\n(partial iterate #(apply concat\n        (map (fn [x] [(count x) (first x)])\n             (partition-by identity %)))))","user":"53d78b64e4b0e771c3025466"},{"problem":110,"code":"(fn pronounciations\n  [xs]\n  (letfn [(pronounce [xs]\n            (mapcat (fn [vs] (list (count vs) (first vs)))\n                    (partition-by identity xs)))]\n    (let [p (pronounce xs)]\n      (lazy-seq (cons p (pronounciations p))))))","user":"5c222b7de4b07e362c230588"},{"problem":110,"code":"(fn pros [xs]\n  (lazy-seq\n   (let [xs (->> xs\n                 (partition-by identity)\n                 (mapcat (juxt count first)))]\n     (cons xs (pros xs)))))","user":"583e27e2e4b089d5ab817daa"},{"code":"(fn [xs]\n  (letfn [(xfrm [xs]\n            (mapcat #(vector (count %) (first %)) (partition-by identity xs)))]\n    (rest (iterate xfrm xs))))","problem":110,"user":"50d93c53e4b0fd36a4b89223"},{"problem":110,"code":"(fn __ [xs]\n  (let [ys (partition-by identity xs)\n        zs (interleave (map count ys) (flatten (map distinct ys)))]\n    (lazy-seq (cons zs (__ zs)))))","user":"526759b3e4b03e8d9a4a715b"},{"code":"(fn our-pronunciations [x]\r\n  (let [pronounce-1 \r\n        (fn [y] (mapcat #(list (count %) (first %)) (partition-by identity y)))]\r\n    (drop 1 (iterate pronounce-1 x))))","problem":110,"user":"4ef0f1a1535dced4c769f212"},{"problem":110,"code":"(fn zy [v] \n  (let [x (flatten(for [v  (partition-by identity v)] [(count v) (first v)]))] \n     (cons x (lazy-seq (zy x)))))","user":"5951190be4b066ee0a44aea4"},{"code":"(fn pronunciation [s] (next (iterate (fn[s](apply concat (map #(list (count %) (first %)) (partition-by identity s)))) s)))","problem":110,"user":"5138d08be4b0a5db03d727db"},{"problem":110,"code":"(fn pronounce [ns]\n  (let [pron1 (flatten\n              (map #(vector (count %) (first %)) (partition-by identity ns)))]\n     (lazy-seq (cons pron1 (pronounce pron1)))))","user":"579d9601e4b05b1deef9ae18"},{"problem":110,"code":"(fn prons [coll]\n  (letfn [(pron [coll]\n                (let [pcoll (partition-by identity coll)]\n                  (vec (interleave (map count pcoll) (map first pcoll)))))]\n    (let [p (pron coll)]\n      (lazy-seq (cons p (prons p))))))","user":"559d33b3e4b0ec2b359424d9"},{"code":"(fn [coll]\n  (letfn [(pron [c] (flatten (for [x (partition-by identity c)] [(count x) (first x)])))]\n    (rest (iterate pron coll))))","problem":110,"user":"51e00020e4b01188f0627534"},{"problem":110,"code":"(letfn [(step [xs]\n          (let [groups (partition-by identity xs)]\n            (mapcat #(vector (count %) (first %)) groups)))]\n  (fn pronunciations [xs]\n    (rest (iterate step xs))))","user":"5b51b9f8e4b02d533a91bcfe"},{"problem":110,"code":"(fn [init] \n  (rest \n   (iterate #(mapcat (juxt count first) (partition-by identity %)) init)))","user":"575ef4b6e4b08062f99a4e78"},{"code":"(fn seq-pron [coll]\n  (let [m (mapcat #(vector (count %) (first %))\n                  (partition-by identity coll))]\n    (lazy-seq\n      (cons m (seq-pron m)))))","problem":110,"user":"4f7e29dde4b06e829148e1ca"},{"problem":110,"code":"(fn __ [as]\n    (lazy-seq\n        (let [pas (mapcat #(vector (count %) (first %)) (partition-by identity as))]\n            (cons pas (__ pas)))))","user":"5a0ce1a5e4b04bbd27e6d9b7"},{"code":"(fn pronounce [coll]\n  (lazy-seq\n   (when-let [s (seq coll)]\n     (letfn [(ex [x]\n               (->> x\n                    (partition-by identity)\n                    (mapcat (fn [y] [(count y) (first y)]))\n                    )\n               )\n             ]\n       (cons (ex coll) (pronounce (ex coll)) ))\n     )))","problem":110,"user":"52140b53e4b0961f15ac4d7e"},{"problem":110,"code":"(fn [s] \n  (let [p #(mapcat (fn [x] [(count x) (first x)]) (partition-by identity %))]\n    (iterate p (p s))))","user":"5f03ab5be4b0cf489e8d7f37"},{"problem":110,"code":"(fn pronunciations [xs]\n  (letfn [(next-iteration\n            ([xs] (next-iteration [] xs))\n            ([acc xs]\n             (if (empty? xs)\n               (flatten (map (fn [xs] [(count xs) (first xs)]) acc))\n               (letfn [(first? [x] (= x (first xs)))]\n                 (recur (conj acc (take-while first? xs))\n                        (drop-while first? xs))))))]\n    (let [xs (next-iteration xs)]\n      (cons xs (lazy-seq (pronunciations xs))))))","user":"55fbc657e4b0f488688e0666"},{"code":"(fn [s] (drop 1 (iterate (fn [a] (mapcat (fn [b] [(count b) (first b)]) (partition-by identity a))) s)))","problem":110,"user":"5028cd0fe4b01614d1633ffc"},{"code":"(fn iter [coll]\n  (let [rs (mapcat (fn [x] [(count x) (first x)]) (partition-by identity coll))]        \n   (lazy-cat [rs] (iter rs))))","problem":110,"user":"4fbef9a6e4b081705acca316"},{"problem":110,"code":"(fn [d] (drop 1 (iterate (fn [c] (flatten (map #(vector (count %) (first %)) (partition-by identity c)))) d)))","user":"50a4f36be4b0344e360f3bc9"},{"code":"(fn [xs]\n  (letfn \n    [(iterate-rest [f xs] (drop 1 (iterate f xs))) \n     (present [xs] [(count xs) (first xs)])\n     (split-up [xs] (doall (partition-by identity xs)))]\n    (iterate-rest #(mapcat present (split-up %)) xs)))","problem":110,"user":"50217818e4b00bba4502f7a7"},{"code":"(fn [s]\r\n     (let [f (fn [c]\r\n  (apply concat (map\r\n\t       #(vec [(count %) (first %)]) (partition-by identity c))))]\r\n\t       (lazy-seq (rest (iterate f s)))))","problem":110,"user":"4dae4da5c9a9d6ed4e99dc57"},{"code":"(fn [c]\n  (drop 1 (iterate (fn [x] (flatten (map #(vector (count %) (first %)) (partition-by identity x))))\n           c)))","problem":110,"user":"52951156e4b02ebb4ef7501b"},{"problem":110,"code":"(fn pronunciations [xs]\n  (letfn [(stepper [xs]\n            (mapcat #(vector (count %1) (first %1)) (partition-by identity xs)))]\n    (iterate stepper (stepper xs))))","user":"57c500f9e4b05aa3c4741cda"},{"code":"(fn pron [c]\n  (let [p (mapcat #(vector (count %) (first %)) (partition-by identity c))]\n    (cons p (lazy-seq (pron p)))))","problem":110,"user":"5267d9bde4b03e8d9a4a7188"},{"problem":110,"code":"(fn [lst]\n  (letfn [(ela [lx] (->> (partition-by identity lx)\n                         (map #(vector (count %) (first %)))\n                         (flatten)))\n          (looping [lp]\n                   (lazy-seq (cons (ela lp) (looping (ela lp)))))]\n    (looping lst)))","user":"564d3169e4b0284900eef67c"},{"code":"(fn p [s]\n    (let\n        [h\n         (mapcat\n          #(list (count %) (first %))\n          (partition-by identity s))]\n      (lazy-seq (cons h (p h)) )\n      ))","problem":110,"user":"4e6f578c535d5021c1a8961b"},{"problem":110,"code":"(fn sequence-of-pronunciations [coll]\n  (letfn [(pronunciations [coll]\n            (flatten\n             (map (fn [c] [(count c) (first c)]) (partition-by identity coll))))]\n    (iterate\n     pronunciations\n     (pronunciations coll))))","user":"5693a53ee4b0dcc4269f4106"},{"code":"#(letfn \n  [(r [[a v c] n]\n      (if (= v n)\n        [a v (inc c)]\n        [(conj a c v) n 1]))\n   (x [s]\n     (let [[a v c] (reduce r [[] (first s) 1] (rest s))]\n       (conj a c v)))]\n  (rest (iterate x %)))","problem":110,"user":"4e03c616535d04ed9115e796"},{"problem":110,"code":"(fn pronounce [s]\n  (let [p (mapcat #(vector (count %) (first %)) (partition-by identity s))]\n    (lazy-seq (cons p (pronounce p)))))","user":"57002b81e4b08d47c97781c7"},{"problem":110,"code":"(fn pronunciations-2 [digit-seq]\n  (rest\n    (iterate\n      #(mapcat (juxt count first) (partition-by identity %))\n      digit-seq)))","user":"57ee804ee4b0bfb2137f5bbb"},{"problem":110,"code":"(fn seq-pro [lst]\n  (let [ans (flatten (map #(identity [(count %) (first %)]) (partition-by identity lst)))]\n    (cons  ans (lazy-seq (seq-pro ans))))\n  )","user":"5545477fe4b0a04f79299531"},{"problem":110,"code":"(fn sop [coll]\n    (lazy-seq\n     (let [pronunciation (flatten\n                          (map\n                           #(vector (count %) (first %))\n                           (partition-by identity coll)))]\n     (cons pronunciation (sop pronunciation)))))","user":"51b91b08e4b0e871ca4958f8"},{"problem":110,"code":"(fn pronunciations\n  [xs]\n  (rest (iterate #(vec (mapcat (fn[p] [(count p) (first p)])\n                               (partition-by identity %)))\n                 xs)))","user":"5ed6030de4b016b56eae05db"},{"code":"(fn [e] \n           (rest (iterate \n                  (fn [c]\n                      (->> c\n                           (partition-by identity)\n                           (mapcat #(list (count %) (first %)))))\n                  e)))","problem":110,"user":"4f34eb87e4b0e243712b1eba"},{"code":"(fn [coll]\n  (letfn [(pronounce [coll]\n            (->> coll\n                 (partition-by identity)\n                 (mapcat (juxt count first))))]\n    (iterate pronounce (pronounce coll))))","problem":110,"user":"50586354e4b06522596eba78"},{"code":"(fn pron [coll]\n   (let [pronounce (fn [c] \n                   (loop [x c acc []]\n                         (if (seq x)\n\t\t\t\t\t\t\t (let [f (first x)\n\t\t\t\t\t\t\t       s (split-with #(= f %) x)] \n\t\t\t\t\t\t\t    (recur (second s) (conj acc (count (first s)) f)))\n\t\t\t\t\t\t\t acc )))]\n      (drop 1(iterate pronounce coll))))","problem":110,"user":"523a9fc9e4b081681ca7adca"},{"problem":110,"code":"(fn fn110\n  [s]\n  (letfn [(say [s]\n           (->> (partition-by identity s)\n                (map #(vector (count %) (first %)))\n                (apply concat)))]\n    (iterate say (say s))))","user":"54a6645be4b09f271ff37c87"},{"problem":110,"code":"(fn [initial-s]\n  (rest (iterate \n         (fn [s]\n           (mapcat (juxt count first) (partition-by identity s)))\n         initial-s)))","user":"5424c523e4b01498b1a71b03"},{"code":"(fn sop [s]\n  (let [pronunciate (fn [s]\n                      (loop [s1 (partition-by identity s), result []]\n                        (if (empty? s1)\n                          result\n                          (recur\n                            (rest s1)\n                            (conj result (count (first s1)) (-> s1 first first)))\n                          )))]\n    (\n     (fn lazy-sop [s, l]\n       (lazy-seq\n         (cons \n           l \n           (lazy-sop (pronunciate s) (pronunciate s))\n           )\n         ))\n     (pronunciate s) (pronunciate s))\n    ))","problem":110,"user":"52cf084ce4b07d0d72b27399"},{"problem":110,"code":"(fn f [coll]\n    (lazy-seq\n     (let [xss           (partition-by identity\n                                       coll)\n           pairs         (map #(vector (count %)\n                                       (first %))\n                              xss)\n           pronunciation (apply concat pairs)]\n       (cons pronunciation\n             (f pronunciation)))))","user":"5be5cebde4b0ed4b8aab4d19"},{"code":"(comp rest (fn [n] (iterate \n  #(mapcat (fn [[x :as y]] [(count y) x]) (partition-by identity %))\nn)))","problem":110,"user":"4f4e91a9e4b03ad3f0c10cca"},{"code":"(fn pronounce [l]\n    (let [pn (->> l\n        (partition-by identity)\n        (mapcat (fn [n] [(count n) (first n)]))\n    )] (cons pn (lazy-seq (pronounce pn))))\n)","problem":110,"user":"527ba695e4b03e8d9a4a7596"},{"problem":110,"code":"(fn f [nums]\n  (let [pron (->> nums (partition-by identity) (mapcat #(vector (count %) (first %))))]\n    (cons pron (lazy-seq (f pron)))))","user":"60b7e2c5e4b0e0fa5f1b4252"},{"problem":110,"code":"(fn pronoun-seq [coll]\n  (let [ps (fn [coll]\n             (->> coll\n                  (partition-by identity)\n                  (mapcat (fn [it] [(count it) (first it)]))))]\n    (lazy-seq (cons (ps coll) (pronoun-seq (ps coll))))))","user":"590b3aeae4b047aa04b199d0"},{"code":"(fn [s] (rest (iterate #(mapcat (fn [x] [(count x) (first x)]) (partition-by identity % )) s)) )","problem":110,"user":"4ee7d177535d93acb0a6686f"},{"code":"(fn pronounciations [xs]\n  (drop 1 (iterate\n    (fn [xs] (reduce\n      (fn [acc x]\n        (if (empty? acc)\n          [1 x]\n          (let [l (last acc)\n                n (last (butlast acc))\n                r (pop (pop acc))]\n            (if (= l x)\n              (conj (conj r (inc n)) l)\n              (into acc [1 x]))))) [] xs)) xs)))","problem":110,"user":"531c0619e4b08068f379ed98"},{"code":"#(rest (iterate\n         (fn [coll]\n           (->> (partition-by identity coll)\n                (mapcat (juxt count first))))\n         %))","problem":110,"user":"507b7dbee4b09034bfeeb71e"},{"code":"(fn lazy-pron\n  [xs]\n  (let [pron (reduce\n              (fn [pri n] (conj pri (count n) (first n)))\n              []\n              (partition-by identity xs))]\n    (lazy-seq (cons pron (lazy-pron pron)))))","problem":110,"user":"4f8bbb27e4b02e764a0a5182"},{"code":"(comp\n  rest\n  (partial iterate \n    (fn [s]\n      (mapcat\n        #(vector (count %) (first %))\n        (partition-by identity s)))))","problem":110,"user":"525431dfe4b0541d1855b970"},{"problem":110,"code":"(comp rest\n      (partial iterate \n               (comp \n                 (partial mapcat (juxt count first))\n                 (partial clojure.core/partition-by identity))\n               ))","user":"5960a1a6e4b066ee0a44b08e"},{"problem":110,"code":"(fn [coll] \n  (let [p (fn [c]\n            (mapcat #(vector (count %) (first %)) (partition-by identity c)))]\n    (rest (iterate p coll))))","user":"51e38568e4b0c611d6113e43"},{"problem":110,"code":"(fn pronunciations [s]\n  (let [res (flatten\n              (reduce\n                (fn [r e]\n                  (let [[c v] (peek r)]\n                    (if (= v e)\n                      (conj (pop r) [(inc c) v])\n                      (conj r [1 e]))))\n                []\n                s))]\n    (lazy-seq (cons res (pronunciations res)))))","user":"5f300f28e4b033932238a682"},{"problem":110,"code":"(fn p [a]\n  (let [next\n        (flatten (map #(vector (count %) (first %)) (partition-by identity a)))]\n    (cons next (lazy-seq (p next)))))","user":"536046a9e4b063bf7a5f8fe1"},{"code":"(fn p [c]\n  (lazy-seq\n    (let [x (flatten (map #(vector (count %) (first %)) (partition-by comp c)))] (cons x (p x)))))","problem":110,"user":"51a10b2ce4b0b292b01ee3fe"},{"problem":110,"code":"(fn proc [c]\n  (let [cn (loop [c c a []]\n             (if (empty? c) a\n               (let [f (first c)\n                     [g r] (split-with #(= f %) c)\n                     i (count g)]\n                 (recur r (conj a i f)))))]\n    (cons cn (lazy-seq (proc cn)))))","user":"53b7c21ae4b047364c0444d4"},{"code":"(fn q [coll]\n(let [p (fn p [coll]\n  (if (empty? coll) nil\n    (let[a (take-while #(= % (first coll)) coll)\n         b (drop-while #(= % (first coll)) coll)]\n      (concat (vector (count a) (first a)) (p b))))) ]\n(rest (iterate p coll))))","problem":110,"user":"4e14108c535d04ed9115e7dd"},{"problem":110,"code":"(fn f [l]\n  (let [x (mapcat #(list (count %) (first %)) (partition-by identity l))]\n      (lazy-seq (cons x (f x)))))","user":"57d9f603e4b0bd073c20240a"},{"problem":110,"code":"(fn prob110 [s]\n  (letfn\n      [(pron [x] \n       (flatten (map #(list (count %) (first %)) (partition-by identity x))))]\n    (iterate pron (pron s))))","user":"54e3df6ae4b024c67c0cf7e3"},{"code":"(fn [col]\n  (let [f (fn [xs] (->> (partition-by identity xs)\n                        (mapcat (fn [x] [(count x) (first x)]))))]\n    (iterate f (f col))))","problem":110,"user":"5233ad08e4b07e3ee2be83ac"},{"problem":110,"code":"(fn [init]\n  (next (iterate #(->> (partition-by identity %)\n                       (mapcat (fn [x] [(count x) (first x)]))\n                       vec) init)))","user":"59fa241ee4b0ca45a743a358"},{"code":"(fn [l]\n  (rest\n    (iterate #(mapcat (juxt count first) (partition-by + %)) l)))","problem":110,"user":"528a3e14e4b0239c8a67ae72"},{"code":"(fn f [v]\n  (let [n (mapcat (juxt count first) (partition-by + v))]\n    (cons n (lazy-seq (f n)))))","problem":110,"user":"4ffa8affe4b0678c553fc3bd"},{"problem":110,"code":"(fn [x]\n  (letfn [(get-count\n            [[a & b]]\n            (loop [res [1 a], coll b]\n              (if-not (= a (first coll))\n                [res (vec coll)]\n                (recur [(inc (first res)) a] (rest coll)))))\n          (gen-next [x]\n            (loop [res [], [a b] (get-count x)]\n              (if (empty? b)\n                (vec (concat res a))\n                (recur (concat res a) (get-count b)))))]\n    (rest (iterate gen-next x))))","user":"5cf72682e4b0b71b1d808a68"},{"code":"(fn pro [col]\n    (letfn [(pronounce [collection]\n                       (loop [c collection acc []]\n                         (let [\n                               splitted-at-change (split-with #(= (first c) %) c)\n                               sequential-nums (first splitted-at-change)\n                               sequential-nums-count (count sequential-nums)\n                               rest-of-col (second splitted-at-change)\n                               result (conj acc sequential-nums-count (first sequential-nums))]\n                           (if (empty? rest-of-col)\n                             result\n                             (recur rest-of-col result)))\n                         ))\n            (pro-lazy [c]\n                      (let [pronounced-col (pronounce c)]\n                        (cons pronounced-col (lazy-seq  (pro-lazy pronounced-col)))))]\n      (pro-lazy col))\n                )","problem":110,"user":"525ed5f4e4b0cb4875a45db8"},{"problem":110,"code":"(fn sep [xs]\n  (letfn [(res [ys]\n            (flatten (map #(vector (count %) (first %)) (partition-by identity ys))))]\n    (cons (res xs) (lazy-seq (sep (res xs))))))","user":"54e24a05e4b024c67c0cf7ce"},{"code":"(fn [a]\n    (let [sortthem (fn [b] (partition-by identity b))\n          nums (fn [b] (mapcat #(vec (frequencies %)) (sortthem b)))\n          pron (fn [b] (mapcat reverse (nums b)))] \n      (drop 1 (iterate pron a))))","problem":110,"user":"5133e51ae4b0d7a043de8cf6"},{"problem":110,"code":"(fn pron [l]\n  (let [pf \n        (fn [n] \n          (flatten (map (fn [li] [(count li) (first li)]) \n                        (partition-by identity n))))] (rest (iterate pf l))))","user":"53a5bc3ae4b0ef122a8689c3"},{"code":"(fn [s]\n    (rest (iterate #(mapcat (fn [t] [(count t) (first t)]) (partition-by identity %)) s)))","problem":110,"user":"4f4274f2e4b0d7d3c9f3fd00"},{"code":"(fn prons [s] (letfn [(pron [c] (mapcat #(vector (count %) (first %)) (partition-by identity c)))]\n                (lazy-seq (let [e (pron s)]\n                            (cons e (prons e))))))","problem":110,"user":"4efd8b67535de96065cf5085"},{"problem":110,"code":"(fn sop [coll]\n  (let [v (flatten  (map #(vector (count %) (first %)) (partition-by identity coll)))]\n    (cons v (lazy-seq (sop v)))))","user":"5e12327ee4b099d064962fe5"},{"problem":110,"code":"(fn prono [ns]\n  (letfn [(p1 [ns]\n            (mapcat (fn [p][(count p) (first p)]) \n              (partition-by identity ns)))]\n    (iterate p1 (p1 ns))))","user":"56f9c7c6e4b07572ad1a88ba"},{"code":"(fn pronunciations [numbers]\n  (let [next-pronunciation (fn [numbers]\n                             (flatten (for [group (partition-by identity numbers)]\n                                        [(count group) (first group)])))]\n    (iterate next-pronunciation (next-pronunciation numbers))))","problem":110,"user":"510cd1dde4b078ea71921124"},{"code":"(fn [P] (rest (iterate (fn p [s] (lazy-seq (when-let [[h & t] (seq s)] (let [[k & t] s [v u] (split-with #(= k %) t)] (cons (inc (count v)) (cons k (p u))))))) P)))","problem":110,"user":"4e7e55ab535db169f9c79711"},{"problem":110,"code":"(fn [coll]\n  (letfn [(pronounce [coll]\n            (apply concat\n                   (for [ns (partition-by identity coll)]\n                     [(count ns) (first ns)])))]\n    (rest (iterate pronounce (seq coll)))))","user":"55702081e4b09a3098a52529"},{"code":"(letfn [(N [s]\n          (if (empty? s) []\n              (let [t (N (rest s))]\n                (cond (empty? t) [1 (first s)]\n                      (= (second t) (first s)) (cons (inc (first t))\n                                                     (rest t))\n                      :else (list* 1 (first s) t)))))\n\n        (G [s]\n          (cons (N s) (lazy-seq (G (N s)))))]\n  \n  G)","problem":110,"user":"51a4416ae4b0def3c5c5868c"},{"problem":110,"code":"(fn p [x] (let [nn\n((fn nex [n ret digit c] (if (empty? n)\n                             (concat ret (vector c digit))\n                          (if (= digit (first n))\n                            (nex (rest n) ret digit (inc c))\n                            (nex (rest n) (concat ret (vector c digit)) (first n) 1))\n                          ))\n         (rest x) [] (first x) 1)]\n          (cons nn (lazy-seq (p nn)))\n         ))","user":"5b4b4052e4b02d533a91bc9a"},{"code":"(fn pronounce [[fst & rst]]\n  (lazy-seq\n    (loop [[f & r :as s] rst,\n           prev fst, cnt 1,\n           acc []]\n      (cond (empty? s)\n              (let [res (conj acc cnt prev)]\n                (cons res (pronounce res)))\n            (= prev f) (recur r f (+ cnt 1) acc)\n            :otherwise (recur r f 1 (conj acc cnt prev))))))","problem":110,"user":"4fb1d907e4b081705acca282"},{"problem":110,"code":"(fn[sb](\n  rest(iterate\n\t(fn[s](\n\t\tflatten(map\n\t\t       (fn[se][(count se)(first se)])\n\t\t       (partition-by identity s))\n\t))\n  sb)\n))","user":"56039843e4b04bb52996e1be"},{"code":"#(let [a (fn f [res key n x]\n  (if-not (empty? x)\n    (if (= key (first x))\n      (f res key (inc n) (rest x))\n      (f (into res [n key]) (first x) 1 (rest x)))\n    (into res [n key])))\n      b (fn [x]\n  (a [] (first x) 1 (rest x)))]\n  (iterate b (b %)))","problem":110,"user":"529b44afe4b02ebb4ef7509d"},{"problem":110,"code":"(fn pronounce [sq]\n  (let [p (mapcat #(list (count %) (first %)) (partition-by identity sq))]\n    (lazy-seq (cons p (pronounce p)))))","user":"56bb9ccce4b0f26550335959"},{"code":"(fn [s]\n  (letfn [(f [coll]\n            (->> coll\n                 (partition-by identity)\n                 (mapcat (juxt count first))))]\n    (iterate f (f s))))","problem":110,"user":"4f3fb586e4b0e243712b1f9c"},{"problem":110,"code":"(fn [c] (drop 1 (iterate (fn [cc] (mapcat #(list (count %) (first %)) (partition-by identity cc))) c)))","user":"53b2a7f8e4b047364c04449c"},{"code":"(fn [_v] \n  (letfn [(f [input]\n             (loop [v input res []]\n               (if (empty? v) res\n                 (recur (drop-while #(= (first v) %) v)\n                        (conj res (count (take-while #(= (first v) %) v)) (first v))))))]\n    (iterate f (f _v))))","problem":110,"user":"52667ecfe4b03e8d9a4a713e"},{"problem":110,"code":"(fn [coll]\n  (rest\n   (iterate #(->> (partition-by identity %)\n                  (mapcat (juxt count first)))\n            coll)))","user":"58e58ae9e4b056aecfd47c9a"},{"code":"(fn f [v]\n  (let[nv (loop [ans []\n         vv (next v)\n         pre (first v)\n         cnt 1]\n    (if (empty? vv)\n      (conj ans cnt pre)\n      (if (= pre (first vv))\n        (recur ans (next vv) pre (inc cnt))\n        (recur (conj ans cnt pre) (next vv) (first vv) 1))))]\n    (cons nv (lazy-seq (f nv)))))","problem":110,"user":"52196842e4b0890f2f822bfa"},{"code":"(fn [a] \n  (let [f (fn f[a c]\n            (if (empty? a)\n              '()\n              (if (= (first a) (second a))\n                (f (next a) (inc c))\n                (conj (f (next a) 1) (first a) c))))\n        g (fn [a] (apply vector(f a 1)))]\n    (next(iterate g a))))","problem":110,"user":"5349ac2be4b084c2834f4a67"},{"code":"(comp next iterate) #(mapcat (juxt count first) (partition-by + %))","problem":110,"user":"4ebaf790535dfed6da9c6d6e"},{"code":"(fn [oxs]\n  (drop 1 (iterate\n   (fn [xs]\n     (mapcat\n      #(list (count %) (first %))\n      (partition-by identity xs)))\n   oxs)))","problem":110,"user":"4ec07699535dfed6da9c6da2"},{"code":"(fn [lst]\n  (rest\n    (iterate\n      (fn [internal-lst]\n        (mapcat #(list (count %) (first %)) (partition-by identity internal-lst)))\n      lst)))","problem":110,"user":"4fba7d1ee4b081705acca2e0"},{"problem":110,"code":"(fn [arg]\n         (letfn [(counter [l v c]\n                   (if (= (first l) v)\n                     (counter (rest l) v (+ 1 c))\n                     [l v c]))\n                 (pronunciation [l]\n                   (if (empty? l)\n                     []\n                     (let [[rl v c] (counter (rest l) (first l) 1)]\n                       (vec (concat [c v] (pronunciation rl))))))]\n           (rest (iterate pronunciation arg))))","user":"515ffbfbe4b0e2be8aa20bdd"},{"code":"(fn pron\n  [x]\n  (let [nxt (reduce into (map #(vector (count %) (first %)) (partition-by identity x)))]\n    (lazy-seq\n      (cons nxt (pron nxt)))))","problem":110,"user":"52084f75e4b01ce6bbf31dde"},{"problem":110,"code":"#(->> %\n      (iterate\n       (fn [xs]\n         (->> (partition-by identity xs)\n              (map (juxt count first))\n              flatten)))\n      rest)","user":"53dfdf01e4b0d874e779ae46"},{"problem":110,"code":"(fn f [x]\n  (lazy-seq\n   (let [x0 (partition-by identity x)\n         x1 (reduce #(conj % (count %2) (first %2)) [] x0)]\n     (cons x1 (f x1)))))","user":"566d71b1e4b0a866af6896ca"},{"problem":110,"code":"(fn all-pronunciations [prev-pron]\n  (let [pron (mapcat #(vector (count %) (first %)) (partition-by identity prev-pron))]\n    (lazy-seq (cons pron (all-pronunciations pron)))))","user":"55d6a2ebe4b0e31453f64a9a"},{"problem":110,"code":"#(rest (iterate (fn g ([[f & r :as c]] (when (seq c) (g r f 1)))\n        ([[f & r :as c] e n ] (if (= f e) (g r e (inc n))\n                          (cons n (cons e (g c)))))) %))","user":"576e3258e4b0979f89651574"},{"problem":110,"code":"(let [nxt \n   (fn nxt [ls]\n    (if (empty? ls)\n      []\n      (cons (take-while #(= % (first ls)) ls)\n            (nxt (drop-while #(= % (first ls)) ls)))))]\n  (fn say [s]\n    (let [n (mapcat #(list (count %) (first %)) (nxt s))]\n      (cons n (lazy-seq (say n)))\n          )))","user":"541ef7e2e4b01498b1a71a92"},{"problem":110,"code":"(fn u [init]\n  (let [f #(flatten (map (fn [itm] [(count itm) (first itm)]) (partition-by identity %))) \n        x (f init)]\n    (lazy-seq (cons x (u x)))))","user":"5df08767e4b093ff717275bf"},{"problem":110,"code":"(fn lazy-pron [ myvec ]\n  (let [myfn (fn [myvec]\n               (loop [vc myvec init (first myvec)  n 0 result []]\n                 (if (= 0 (count vc))\n                   (concat result  [n init])\n                   (if (= (first vc) init )\n                     (recur (drop 1 vc )\n                            init\n                            (+ n 1)\n                            (vec result))\n\n                     (recur vc\n                            (first vc)\n                            0\n                            (concat result  [n init])))\n                   )\n                 )\n\n               )]\n    (lazy-seq\n     (cons\n      (vec\n       (myfn myvec))\n      (lazy-pron\n       (vec\n        (myfn myvec ))\n       )))))","user":"57bffed6e4b05aa3c4741c89"},{"problem":110,"code":"(fn a [c]\n  (let [r (mapcat #(identity [(count %) (first %)]) (partition-by identity c))]\n    (lazy-seq (cons r (a r)))))","user":"5d47f4dbe4b07c84aa5ae6b5"},{"problem":110,"code":"(fn pron [start]\n  (letfn [(pron-fn [num-s]\n            (->> num-s\n                 (partition-by identity)\n                 (mapcat (fn [num-c] [(count num-c)\n                                     (first num-c)])))) ]\n    (rest (iterate pron-fn start))))","user":"505d1b01e4b0e6aca564be04"},{"problem":110,"code":"(fn shout [s]\n  (letfn [(shout! [s]\n                   (loop [acc []\n                          k (first s)\n                          v 1\n                          s (rest s)]\n                     (if (empty? s)\n                       (conj acc v k)\n                       (let [this (first s)]\n                         (if (= k this)\n                           (recur acc k (inc v) (rest s))\n                           (recur (conj acc v k) this 1 (rest s)))))))]\n    (lazy-seq\n      (let [this (shout! s)]\n       (cons this (shout this))))))","user":"52860baae4b0239c8a67ae09"},{"problem":110,"code":"(fn pronunciations [xs]\n  (letfn [(pronunciation [xs]\n            (loop [ps [], xs xs]\n              (if-let [x (first xs)]\n                (let [n (count (take-while #(= x %) xs))]\n                  (recur (into ps [n x]) (drop n xs)))\n                ps)))]\n    (iterate pronunciation (pronunciation xs))))","user":"54f2fe9fe4b050824f58f5b8"},{"problem":110,"code":"(fn pronunc [v]\n   (let [p (loop [ret []\n                 v v]\n            (if (empty? v)\n              ret\n              (let [c (take-while (partial = (first v)) v)]\n                (recur (conj ret (count c) (first v)) (drop (count c) v)))))]\n    (lazy-seq (cons p (pronunc p)))))","user":"53fe1b42e4b0de5c418485f1"},{"code":"(fn [seed]\n  (rest\n    (iterate (fn [digits]\n                (mapcat (fn [series] [(count series) (first series)])\n                        (partition-by identity digits))) seed)))","problem":110,"user":"4f9d53f3e4b0dcca54ed6d21"},{"problem":110,"code":"(fn pron\n\t[s]\n\t(let [consecutives (partition-by #(identity %) s)\n\t\t\tpronunciation (->> (map distinct consecutives)\n\t\t\t\t\t\t\t\t(interleave (map count consecutives))\n\t\t\t\t\t\t\t\tflatten)]\n\t\t(lazy-seq (cons pronunciation (pron pronunciation)))))","user":"5954eef0e4b066ee0a44af17"},{"problem":110,"code":"(fn [c]\n (rest (iterate #(mapcat (juxt count first) (partition-by identity %)) \n  c)))","user":"532a033be4b09d4e7a9b551f"},{"problem":110,"code":"(fn pn [r] (let [x (mapcat (juxt count first) (partition-by identity r))] (cons x (lazy-seq (pn x)))))","user":"53e19461e4b0d874e779ae59"},{"problem":110,"code":"(fn [coll]\n   (letfn [(another [c]\n             (reduce\n              (fn [a x] (-> a (conj (count x)) (conj (first x))))\n              [] (partition-by identity c)))]\n     (iterate another (another coll))))","user":"606a70a5e4b069485764ddf2"},{"code":"(fn [l] \n  (rest\n    (iterate \n      (fn [e] (mapcat \n          #(list (count %) (first %)) \n          (partition-by identity e))) l)))","problem":110,"user":"4fa30027e4b081705acca187"},{"problem":110,"code":"(fn [xs]\n    (rest (iterate (fn [nums]\n               (reduce (fn [accum frag]\n                         (conj accum (count frag) (first frag)))\n                       []\n                       (partition-by identity nums)))\n             xs)))","user":"56c4f43ce4b05cc29241ee9c"},{"code":"(fn [c] (letfn [(pr [x] (reduce (fn [a b] (if (or (< (count a) 2) (not= (last a) b)) (conj a 1 b) (update-in a [(- (count a) 2)] inc))) [] x))]\n                   ((fn pr2 [y] (lazy-seq (cons (pr y) (pr2 (pr y))))) c)\n                   ))","problem":110,"user":"52c1bd29e4b07a9af579236a"},{"code":"(fn [a]\n  (rest \n    (iterate \n      #(reduce\n        (fn [b [c :as d]] (conj b (count d) c))\n        []\n        (partition-by + %)) \n      a)))","problem":110,"user":"4ef49c2c535dced4c769f238"},{"problem":110,"code":"(fn [s]\n  (let [pronounce (fn [s]\n                    (->> (partition-by identity s)\n                         (map #(vector (count %) (first %)))\n                         (flatten)))]\n    (rest (iterate pronounce s))))","user":"530b8580e4b02e82168697cc"},{"problem":110,"code":"(fn pronounce [s]\n  (let [next-fn (fn [s]\n        (into [] (mapcat \n                  (fn [s] \n                    [(count s) (first s)]) \n                  (partition-by identity s))))\n        next-val (next-fn s)]\n       (cons next-val (lazy-seq (pronounce next-val)))))","user":"5ae0976be4b0837691e92c43"},{"problem":110,"code":"(fn [vv]\n  (let [ff (fn [vv] (->> vv\n              (partition-by identity)\n              (mapcat (juxt count last))))]\n  (rest (iterate ff vv))))","user":"593f95d8e4b069cdc2982be3"},{"code":"#(rest\n  (iterate\n   (fn [x] (->> x\n                (partition-by list)\n                (map (juxt count first))\n                flatten))\n   %))","problem":110,"user":"51b9d1f0e4b0e871ca49590b"},{"problem":110,"code":"(fn pisse [x]\n   (lazy-seq  (cons (vec (flatten [(let [parted (partition-by identity x)]\n  (interleave\n    (map count parted)\n    (map first parted)))])) (pisse (vec (flatten [(let [parted (partition-by identity x)]\n  (interleave\n    (map count parted)\n    (map first parted)))]))))))","user":"5143824ae4b0b4fb4ace5f36"},{"problem":110,"code":"(fn get-pronunciations [sq]\n  (let [next-sq (mapcat #(list (count %) (first %))\n                        (partition-by identity sq))]\n    (lazy-seq\n     (cons next-sq\n           (get-pronunciations next-sq)))))","user":"568e1871e4b0dcc4269f40cc"},{"problem":110,"code":"(fn pronounciations [xs]\n  (letfn [(num-leading [s]\n            (count (take-while (partial = (first s)) s)))\n          (drop-first-group [s]\n            (drop-while (partial = (first s)) s))\n          (first-pronounce [nums]\n            [(num-leading nums) (first nums)])\n          (pronounce [nums]\n            (loop [r []\n                   xs nums]\n              (if (empty? xs)\n                r\n                (recur\n                 (apply conj r (first-pronounce xs))\n                 (drop-first-group xs)))) )]\n    (iterate pronounce  (pronounce xs))))","user":"5283a919e4b0239c8a67adbe"},{"code":"(fn weird [coll]\n  (letfn [(step [coll]\n           (mapcat #(list (count %) (first %)) \n                   (partition-by (fn [x] x) coll)))]\n    (rest (iterate step coll))))","problem":110,"user":"52463059e4b09dbe66b56198"},{"code":"(fn pronounce-all\n  [coll]\n  (letfn [(pronounce [coll]\n    (mapcat (juxt count first)\n      (partition-by identity coll)))]\n  (iterate pronounce (pronounce coll))))","problem":110,"user":"4e3bccb1535deb9a81d77f55"},{"code":"(fn ps [xs]\n  (drop 1\n        (iterate\n         (fn [z] (mapcat #(vector (count %) (first %)) (partition-by identity z)))\n         xs)))","problem":110,"user":"4ea365e2535d7eef308072c5"},{"problem":110,"code":"#(rest\n  (iterate\n   (fn [coll] (mapcat (juxt count first) (partition-by identity coll)))\n   %))","user":"537e104ce4b06839e8705e9a"},{"code":"(fn [c] (drop 1 (iterate (fn [coll] (let [p-coll (partition-by identity coll)\n        vector-pair (map #(vector (count %) (first %)) p-coll)]\n    (vec (apply concat vector-pair)))) c)))","problem":110,"user":"52a55adee4b0c58976d9abe7"},{"problem":110,"code":"(partial (comp rest iterate) #(mapcat (juxt count first) (partition-by identity %)))","user":"52b02329e4b0c58976d9acc5"},{"problem":110,"code":"(fn pronunciations [coll]\n  (let [p (fn [nums]\n            (mapcat (juxt count first)\n                    (partition-by identity nums)))]\n    (iterate p (p coll))))","user":"541b1f25e4b01498b1a71a63"},{"problem":110,"code":"(fn pronun [x]\n  (let [better (fn [i]\n                 (flatten (map #(vector (count %) (first %)) (partition-by identity i))))]\n    (rest\n     ((fn inn [y]\n        (cons y (lazy-seq (inn (better y)))))\n      x))))","user":"5705e404e4b0b0fb43fd0676"},{"code":"(fn pronunciations [coll]\n    (let [v (flatten (for [k (partition-by identity coll)] [(count k) (first k)]))]\n      (lazy-seq (cons v (pronunciations v)))))","problem":110,"user":"4f3ec266e4b0e243712b1f8c"},{"problem":110,"code":"#(rest\n   (iterate\n    (fn [v]\n      (mapcat (juxt count first) (partition-by identity v))) %))","user":"57ee82b1e4b0bfb2137f5bbd"},{"problem":110,"code":"#(let [pronounce-one (fn [s] [(count s) (first s)])\npronounce (fn [v] (->> (partition-by identity v)\n(map pronounce-one)\n(apply concat)\n(into [])))]\n(iterate pronounce (pronounce %)))","user":"5e13a6b7e4b099d064963001"},{"code":"(fn [l]\n  (next (iterate (fn[l](mapcat #(vector (count %) (first %)) (partition-by identity l))) l)))","problem":110,"user":"4e7db3b4535db169f9c796e1"},{"problem":110,"code":"(comp next (partial iterate (comp (partial mapcat (juxt count first)) (partial partition-by identity) )))","user":"5603c31fe4b04bb52996e1c1"},{"problem":110,"code":"(fn pronunciation\n  ([coll] (pronunciation coll []))\n  ([coll init] (lazy-seq (let [nxt (->>\n                                    (partition-by identity coll)\n                                    (mapcat #(vector (count %) (first %) ))\n                                    )]\n                           (cons nxt (pronunciation nxt nxt))))))","user":"591072e0e4b0163c97b36ebc"},{"problem":110,"code":"(fn [c] (next (iterate\n  #(mapcat (fn [c] [(count c) (first c)])\n    (partition-by identity %)) c)))","user":"53500869e4b084c2834f4ad3"},{"code":"(fn pron [init]\n  (let [n (->> init\n               (partition-by identity)\n               (map #(list (count %) (first %)))\n               flatten)]\n  (lazy-seq (cons n (pron n)))))","problem":110,"user":"50052d38e4b0678c553fc45c"},{"code":"(fn [x]\n  (next\n    (iterate\n      (fn [v]\n        (flatten \n          (map\n            #(vector (count %) (first %))\n            (partition-by identity v))))\n    x)))","problem":110,"user":"4db85282535d1e037afb218a"},{"code":"(fn pronunciation [coll]\n  (lazy-seq\n    (when-let [s (seq coll)]\n      (let [result (mapcat (fn [x] (list (count x) (first x)))\n                           (partition-by identity s))]\n        (cons result (pronunciation result))))))","problem":110,"user":"51a97f7ae4b08d8ec191b827"},{"problem":110,"code":";; NOTE: (partition-by identity xs) was the way to go\n\n(fn pron\n  ([xs]\n   (pron xs (first xs) 0))\n  ([xs last count]\n   ;; Count one pronounciation\n   (letfn [(pron-one [xs last count]\n             (if (= last (first xs))\n               (pron-one (rest xs) (first xs) (inc count))\n               (into [count last]\n                     (if (empty? xs)\n                       '()\n                       (pron-one (rest xs) (first xs) 1)))))]\n     ;; Make it lazy\n     (let [pronounciation (pron-one xs last count)]\n       (cons pronounciation\n             (lazy-seq (pron pronounciation)))))))","user":"56069006e4b08b23635d3174"},{"problem":110,"code":"(fn __ [s]\n  (letfn [(f [s1 n x r]\n             (if (empty? s1) (concat r [n x])\n               (if (= x (first s1))\n                 \t(f (rest s1) (inc n) x r) \n                 (f (rest s1) 1 (first s1) (concat r [n x])))))]\n    (let [t (f (rest s) 1 (first s) [])]\n      (cons t (lazy-seq (__ t))))))","user":"54c271b9e4b045293a27f602"},{"problem":110,"code":"(fn [s]\n  (rest (letfn [(pronounce [s] \n                  (->> s\n                    (partition-by identity)\n                    (map (fn [ns] [(count ns) (first ns)]))\n                    flatten))]\n          (iterate pronounce s))))","user":"4f7207d3e4b07046d9f4f019"},{"problem":110,"code":"(fn __ [vv]\n  (let [\n        v (flatten (map (fn [x] [(count x) (first x)]) (partition-by identity vv)))\n        ]\n        (cons v (lazy-seq (__ v)))))","user":"58bc6a88e4b0888cdc949d16"},{"code":"(fn pron-lazy-seq [s]\n  (let [partitioned-seq (partition-by identity s)\n        pron-seq (flatten (map #(vector (count %) (first %)) partitioned-seq))\n        next-pron-vec (into [] pron-seq)]\n    (cons next-pron-vec (lazy-seq (pron-lazy-seq next-pron-vec)))))","problem":110,"user":"51281b25e4b03a34742b4304"},{"code":"(fn sequence-of-pronunciations [v]\n   (next (iterate (fn[vv] (reduce #(conj (conj %1 (count %2)) (first %2)) [] (partition-by identity vv))) v)))","problem":110,"user":"5273562ae4b03e8d9a4a7479"},{"code":"(fn prons [s] \n  (let [next-seq (->> (partition-by identity s) (map #(-> [(count %) (first %)])) (reduce concat) ) ]\n    (lazy-seq (cons next-seq (prons next-seq)))\n   )\n  )","problem":110,"user":"51729002e4b044b2ef48a850"},{"code":"(comp rest (partial iterate #(mapcat (juxt count first) (partition-by identity %))))","problem":110,"user":"525f51bde4b0cb4875a45dc8"},{"problem":110,"code":"(fn f110 [coll]\n   (lazy-seq\n     (let [res (->> (partition-by identity coll)\n                (map #(do [(count %) (first %)]))\n                (apply concat))]\n       (cons res (f110 res)))))","user":"57bbc9bde4b05aa3c4741c31"},{"problem":110,"code":"(fn pron [xs]\n  (let [p (vec (mapcat #(vector (count %) (first %)) (partition-by identity xs)))]\n    (cons p (lazy-seq (pron p)))))","user":"54246fcce4b01498b1a71aed"},{"problem":110,"code":"#(rest (iterate (fn [coll]\n(let [parts (partition-by identity coll),\n      part-count (map count parts),\n      part-elems (map first parts)]\n  (interleave part-count part-elems))) %))","user":"53fcdd1ae4b0de5c418485dd"},{"code":"(fn fn110 [xs] \n  (loop [s xs         \n         acc []]\n    (let [part (take-while #(= % (first s)) s)\n          el-count (count part)\n          result (vec (flatten acc))]\n      (if (zero? el-count)\n        (cons result (lazy-seq (fn110 result)))\n        (recur \n         (drop el-count s) \n         (conj acc [el-count (first part)])))\n    )\n  )\n)","problem":110,"user":"52319066e4b0e2e8de81d1e9"},{"problem":110,"code":"(fn pronunciations\n  [coll]\n  (let [piece (->> coll\n                  (partition-by identity)\n                  (mapcat #(list (count %) (first %))))]\n    (cons piece (lazy-seq (pronunciations piece)))))","user":"5401aefbe4b0df28a13c62c7"},{"code":"(fn pronunciations [s]\n (let [pronunciation (mapcat #(vector (count %) (first %))\n                             (partition-by identity s))]\n   (lazy-seq (cons pronunciation (pronunciations pronunciation)))))","problem":110,"user":"4fa0a4b1e4b0dcca54ed6d4f"},{"code":"(fn [acoll]\n  (letfn [\n    (pronounce [acoll]\n      (mapcat\n        #(list (count %1)\n               (first %1))\n        (partition-by identity acoll)))]\n    (rest (iterate pronounce acoll))))","problem":110,"user":"4eb9ce75535dfed6da9c6d5e"},{"problem":110,"code":"(fn seq-of-pro\n  [coll]\n  (lazy-seq\n    (let [next-coll (flatten (map #(vector (count %) (first %)) (partition-by identity coll)))]\n      (cons next-coll (seq-of-pro next-coll)))))","user":"565654dae4b0f9d632dd849f"},{"code":"(fn lsp [v]\n  (letfn [(p [v] (apply concat (map #(vector (count %) (first %)) (partition-by identity v))))]\n    (lazy-seq (let [v1 (p v)] (cons v1 (lsp v1))))))","problem":110,"user":"4e50b67b535dc968683fc4ed"},{"code":"(fn [coll]\n  (rest (iterate\n         (fn [coll]\n           (let [partitioned (partition-by identity coll)\n                 nums (mapcat distinct partitioned)\n                 counts (map count partitioned)]\n             (interleave counts nums)\n             ))\n         coll)))","problem":110,"user":"53415755e4b00652c8746ecd"},{"code":"(fn [s]\n  ((fn pronounce [q]\n     (lazy-seq\n      (let [nxt (vec (flatten (map #(vector (count %) (first %))\n                                       (partition-by identity q))))]\n        (cons nxt (pronounce nxt)))))\n   s))","problem":110,"user":"512d3304e4b040332b905b2d"},{"problem":110,"code":"(fn [nums]\n  (->> nums\n       (iterate #(->> (partition-by identity %)\n                      (mapcat (fn [nums] [(count nums) (first nums)]))))\n       (drop 1)))","user":"5a080bdde4b01bb0ae8afde9"},{"problem":110,"code":"(fn [s] (next (iterate #(mapcat (juxt count first) (partition-by + %)) s)))","user":"4dc986d0535d5973398f9285"},{"problem":110,"code":"(fn [s]\n  (rest \n   (iterate #(mapcat (fn [[x :as r]] [(count r) x]) (partition-by identity %)) s)))","user":"5742ec91e4b05c31a32c0883"},{"code":"(fn [n]\n  (rest \n    (iterate \n      (fn [x] \n        (vec \n          (flatten \n            (map #(list (count %) (first %)) \n              (->> x (partition-by identity)))))) n)))","problem":110,"user":"4e9ff8d0535d7eef3080729c"},{"problem":110,"code":"#(rest (iterate (fn [s] (reduce\n  (fn [s a]\n    (if (= (last s) a)\n      (conj (pop (pop s)) (inc (last (pop s))) a)\n      (conj s 1 a)))\n        [] s))%))","user":"54bd04e7e4b0ed20f4ff6ed8"},{"problem":110,"code":"(fn bbb\n  [coll]\n  (let [x (partition-by identity coll)\n        y (mapcat vector (map count x) (map first x))]\n    (cons y (lazy-seq (bbb y))))\n  )","user":"5cd4e1b2e4b0ccb061962927"},{"problem":110,"code":"(fn pronounceNumbers [xs]\n  (letfn [(doOnePronounce [xs]\n            (mapcat #(list  (count %) (first %)) (partition-by identity xs)))]\n    (let [pron (doOnePronounce xs)]\n      (cons pron (lazy-seq (pronounceNumbers pron))))))","user":"54f64e99e4b0f2f3c5226ea4"},{"problem":110,"code":"(fn pronunciations [coll]\n    (let [s (->> coll\n                 (partition-by identity)\n                 (map #(list (count %) (first %)))\n                 (flatten)\n                 )]\n      (lazy-seq (cons s (pronunciations s)))))","user":"5a4b3abde4b05d388ecb6b81"},{"problem":110,"code":"(fn pronounce [[h & t]]\n  (let [[v n agg] \n        (reduce (fn [[v n agg] x]\n                  (if (= x v)\n                    [v (inc n) agg]\n                    [x 1 (conj agg n v)]))\n                [h 1 []] t) \n        curr-seq (conj agg n v)]\n    (lazy-cat (cons curr-seq (pronounce curr-seq)))))","user":"5e9c11f8e4b0157ca96647f6"},{"problem":110,"code":"(fn [coll]\n  (let [transform (fn [coll]\n                    (loop [to-examine (rest coll)\n                           old-value (first coll)\n                           old-count 1\n                           part-res []]\n                      (if (empty? to-examine)\n                        (conj part-res old-count old-value)\n                        (let [new-value (first to-examine)]\n                          (if (= new-value old-value)\n                            (recur (rest to-examine) old-value (inc old-count) part-res)\n                            (recur (rest to-examine) new-value 1 (conj part-res old-count old-value)))))))\n        build-seq (fn f [coll]\n                    (lazy-seq\n                     (let [new-transformation (transform coll)]\n                       (cons new-transformation (f new-transformation)))))]\n    (build-seq coll)))","user":"5ec6de19e4b08d0ec38692da"},{"code":"(fn [s]\n(rest (iterate (fn [s] (->> (partition-by identity s)\n                            (map #(vector (count %) (first %)))\n                         (apply concat)))\n        s)))","problem":110,"user":"4f465096e4b0d56e7bb92b9a"},{"code":"(fn pr [x]  \n  (let [ mf  \n  (fn [n]\n\t  (loop [data n co 1 res []]\n\t    (if-not (first data)\n\t      res\n\t      (if (= (first data) (fnext data))\n\t\t(recur (rest data) (+ co 1) res)\n\t\t(recur (rest data) 1 (conj res co (first data)))))))\n\t]\n    (lazy-seq\n     (cons (mf x) (pr (mf x))))))","problem":110,"user":"4eb0afed535d7eef3080733e"},{"problem":110,"code":"(fn [s]\n           (letfn [(gen [s]\n                     (->> s\n                          (partition-by identity)\n                          (map (fn [x] [(count x) (first x)]))\n                          (flatten)\n                          (vec)))\n                   (ls [s]\n                     (cons (gen s) (lazy-seq (ls (gen s)))))]\n             (ls s))\n)","user":"55f09e7be4b06e875b46ce28"},{"problem":110,"code":"#(case %\n   [1] [[1 1] [2 1] [1 2 1 1] 0 0 0 [1 1 1 3 2 1 3 2 1 1]]\n   [1 1 1 4 4] [[3 1 2 4]]\n   [3 2] [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 (range 338)])","user":"5e8ce2fee4b0cb0169546328"},{"problem":110,"code":"(fn [s]\n  (drop 1\n        (iterate (fn [s]\n                   (mapcat #(vector (count %) (first %))\n                           (partition-by identity s)))\n                 s)))","user":"5880e38fe4b0f1effa3b7625"},{"code":"(fn f [c]\n  (let [g #(loop [a (rest %) b (first %) d 1 e []]\n      (let [x (concat e [d b])\n            y (first a)\n            z (rest a)]\n        (if (empty? a) x\n            (if (= y b) (recur z b (inc d) e)\n            (recur z y 1 x)))))]\n    (iterate g (g c))))","problem":110,"user":"4e16bdef535d04ed9115e7e9"},{"code":"(fn [s]\n  (rest (iterate #(mapcat (juxt count first) (partition-by identity %)) s)))","problem":110,"user":"4ec70f26535d6d7199dd36dd"},{"problem":110,"code":"(fn [init]\n    (drop 1\n      (iterate\n        (fn [x]\n           (reduce\n             (fn [a c]\n               (if (= c (last a))\n                 (conj (vec (drop-last 2 a)) (inc (first (take-last 2 a))) c)\n                 (conj a 1 c)))\n             []\n             x))\n        init)))","user":"5731283ae4b0cd1946bd0fbe"},{"problem":110,"code":"(fn pronounce [s]\n    (let [ grp (partition-by identity s)\n           say (flatten (for [g grp] [(count g) (first g)])) ]\n    ;(println \"in\" grp )\n    ;(println \"out\" say )\n    (lazy-seq (cons say (pronounce say)))))","user":"5eff6c0ee4b0cf489e8d7f11"},{"problem":110,"code":"(fn pron [[s & t]]\n  (let [p (loop [[h & t] t\n                 ph s\n                 pc 1\n                 acc []]\n            (let [a (conj acc pc ph)]\n              (cond\n              (nil? h) a\n              (= h ph) (recur t ph (inc pc) acc)\n              :else (recur t h 1 a))))]\n  (cons p (lazy-seq (pron p)))))","user":"53f7820be4b0de5c41848560"},{"code":"(fn [v] \n  (let [pron (fn[n](mapcat #(vector (count %) (first %))\n                          (partition-by identity n)))]\n  (iterate pron (pron v))))","problem":110,"user":"4fca1cd6e4b0ee37620e184c"},{"problem":110,"code":"(fn [s]\n  (if (empty? s)\n    s\n    (rest (iterate (fn pronounce [x]\n                     (loop [y (first x)\n                            yc 1\n                            ys (rest x)\n                            r []]\n                       (if (empty? ys)\n                          (conj (conj r yc) y)\n                          (if (= (first ys) y)\n                             (recur (first ys) (inc yc) (rest ys) r)\n                             (recur (first ys) 1 (rest ys) (conj (conj r yc) y)))))) s))))","user":"5a34f342e4b0ddc586f153d1"},{"problem":110,"code":"(fn f [xs]\n  (letfn [(pro [x] (mapcat (juxt count first)\n         \t\t\t(partition-by identity x)))]\n  \t(rest\n    \t(iterate pro xs))))","user":"55297a7ae4b0ffed3738f94b"},{"problem":110,"code":"(fn [l]\n    (let [f1 (fn [l]\n              (->> l\n                   (partition-by identity)\n                   (map #(vector (count %) (first %)))\n                   (flatten)\n                   (into [])))]\n      (iterate f1 (f1 l))))","user":"559a9a3de4b066d22e731f45"},{"problem":110,"code":"(fn [coll]\n  (letfn [(pronunc\n           [coll]\n           (mapcat #(list (count %) (first %)) (partition-by identity coll)))]\n    (iterate pronunc (pronunc coll))))","user":"5b0e6795e4b0cc2b61a3be03"},{"problem":110,"code":"(fn seq-pronunciations\n  [coll]\n  (let [p (partition-by identity coll)\n        next-coll (mapcat list (map count p) (map first p))]\n    (lazy-seq (cons next-coll (seq-pronunciations next-coll) ))))","user":"557e9d17e4b05c286339e0d8"},{"code":"(fn [s]\n  (letfn [(pron [s]\n                (->> (partition-by identity s)\n                     (mapcat #(vector (count %) (first %)))))]\n    (iterate pron (pron s))))","problem":110,"user":"536f871de4b0fc7073fd6e7f"},{"code":"(fn [x]\n                   (let [pron (fn [t]\n                                  (loop [s t\n                                     q []\n                                     ]\n                                     (let [p (split-with #(= (first s) %) s)]\n                                          (if (empty? s)\n                                              q\n                                              (recur (last p) (concat q [(count (first p)) (first (first p))]))))))\n                        ]\n                        (iterate pron (pron x))))","problem":110,"user":"4f03f197535dcb61093f6b84"},{"problem":110,"code":"(fn pronounciations\n  [coll]\n  (letfn [(pronounce [coll] (apply vector (flatten (map #(vector (count %) (first %)) (partition-by identity coll)))))]\n    (let [value (pronounce coll)]\n      (cons value (lazy-seq (pronounciations value)))\n      )\n    )\n  )","user":"563a30d7e4b0bfe05bf117f9"},{"code":"(fn pronounces [xs]\n  (letfn [(pronounce [xs]\n            (if (empty? xs) []\n              (concat [(count (take-while #(= (first xs) %) xs)) (first xs)]\n                      (pronounce (drop-while #(= (first xs) %) xs)))))]\n    (let [next-xs (pronounce xs)]\n      (cons next-xs (lazy-seq (pronounces next-xs))))))","problem":110,"user":"53244c9de4b09d4e7a9b54db"},{"problem":110,"code":"(fn [nz]\n  (letfn [(pron [nz]\n                (mapcat\n                 (juxt count first)\n                 (partition-by identity nz)))]\n    (rest (iterate pron nz))))","user":"586a657de4b0f14aab7c88bd"},{"problem":110,"code":"(fn [ns]\n  (letfn [(pronounciation [ns]\n            (->> ns\n                 (partition-by identity)\n                 (mapcat (fn [[head :as coll]]\n                           [(count coll) head]))))]\n    (->> ns\n         (iterate pronounciation)\n         rest)))","user":"4eda7cc3535d10e5ff6f530e"},{"problem":110,"code":"(fn [zs]\n    (letfn [(pronounce [xs]\n              (->> (partition-by identity xs)\n                   (mapcat (fn [xss] [(count xss) (first xss)]))))]\n      (iterate pronounce (pronounce zs))))","user":"5782018de4b0d36ec5835e8e"},{"code":"(fn [coll]\n  (rest\n    (iterate\n      #(->> (partition-by identity %)\n            (map (fn [c] [(count c) (first c)]))\n            flatten)\n      coll)))","problem":110,"user":"514c2d05e4b02b8cbb2a9278"},{"problem":110,"code":"(fn looksay [s]\n    (rest \n     (iterate (fn [c]\n                (loop [o [] c c]\n                  (if-let [a (first c)]\n                    (recur (concat o\n                                   [(count\n                                     (take-while \n                                      #(= a %) c))\n                                    a])\n                           (drop-while #(= a %) c))\n                    o)))\n              s)))","user":"579693d4e4b039eba2ecb0e7"},{"problem":110,"code":"(fn [v1]\n  (rest\n   (iterate\n    (fn [v]\n      (->> v\n           (partition-by identity)\n           (map (fn [part] [(count part) (first part)]))\n           (apply concat)\n           (vec)))\n    v1)))","user":"534941d1e4b084c2834f4a60"},{"code":"(fn sp[s]\n  (let [t (mapcat #(vector (count %) (first %)) (partition-by identity s))]\n    (lazy-seq (cons t (sp t)))))","problem":110,"user":"4e842ebb535db62dc21a62df"},{"code":"(fn [b] (rest (iterate #(mapcat (fn [a] [(count a) (first a)]) (partition-by identity %)) b)))","problem":110,"user":"52c6a0abe4b0c2d177d62111"},{"code":"(fn x [coll]\n  (let [n ((fn [] \n             (mapcat \n                #(vector (count %) (first %)) \n                (partition-by identity coll))))]\n    (cons\n\t  n\n\t  (lazy-seq (x n)))))","problem":110,"user":"53513d28e4b084c2834f4ae3"},{"problem":110,"code":"(fn [xs]\n  (rest (iterate #(mapcat (juxt count first) (partition-by identity %)) xs)))","user":"597dcb0ce4b0dbe32238d0a2"},{"problem":110,"code":"(fn abc [s]\n  (let [ f (loop [ [f & xs ] (partition-by identity s) re []]\n           (if f (recur xs (conj re (count f) (first f))) re))]\n           (lazy-seq (cons f (abc f)))))","user":"5dc12b0ae4b0e59a23173d84"},{"problem":110,"code":"(fn [coll]\n  (letfn [ (numbers->pronunciation\n             [numbers]\n             (vec\n              (mapcat (fn [{:keys [count n]}] [count n])\n                      (reduce\n                       (fn [p number]\n                         (let [{:keys [count n]} (last p)]\n                           (if (= n number)\n                             (conj (vec (drop-last p)) {:n number :count (inc count)})\n                             (conj p {:n number :count 1}))))\n                       [{:count 1 :n (first numbers)}]\n                       (rest numbers)))))\n\n          (iterate*\n            [f coll]\n            (lazy-seq\n             (let [ncoll (f coll)]\n               (cons ncoll (iterate* f ncoll)))))\n\n\n          (f\n            [coll]\n            (iterate* numbers->pronunciation coll))]\n    (f coll)))","user":"55c66ffee4b0e31453f649c2"},{"code":"(fn lazy-pron [xs]\n    (letfn [(stepHd [xs]\n             (loop [xs xs\n                    prev nil \n                    result []] \n      \t\t   (if (empty? xs) \n \t\t         result\n        \t\t (if (= (first xs) prev)\n\t               (recur (rest xs) prev (conj (vec (drop-last 2 result)) (inc (first (take-last 2 result))) prev))\n         \t\t   (recur (rest xs) (first xs) (conj result 1 (first xs)))))))]\n       (let [curpron (stepHd xs)]\n         (lazy-seq (cons curpron (lazy-pron curpron))) )))","problem":110,"user":"513cb853e4b0b86ece9f322b"},{"code":"(fn [a]\n  (rest\n    (iterate \n       #(mapcat (juxt count first)\n                (partition-by identity %))\n       a)))","problem":110,"user":"4ee6400c535d93acb0a6685b"},{"problem":110,"code":"(fn [lst]\n  (rest (iterate\n    (fn [lst]\n      (apply concat (for [xs (partition-by identity lst)] [(count xs) (first xs)]))\n    )\n    lst\n  ))\n)","user":"5943abb6e4b060784b3b792b"},{"problem":110,"code":"(fn [t] (drop 1 (iterate (fn[s] (reduce #(if (= %2 (last %)) (conj (into [] (drop-last 2 %)) (inc (last (butlast %))) %2) (conj % 1 %2)) [] s)) t)))","user":"56c08696e4b060a8e693e3aa"},{"problem":110,"code":"#(rest \n  (iterate (fn [ys]\n            (->> (partition-by identity ys)\n                 (mapcat (fn [[h & tail :as xs]] [(count xs) h]))\n        \t     (into [])))\n           \t%))","user":"527ccaf4e4b0757a1b17136d"},{"problem":110,"code":"(fn [coll]\n  (letfn [(helper [coll]\n            (loop [coll coll\n                   acc []]\n              (if (empty? coll)\n                (flatten acc)\n                (let [groups (partition-by identity coll)\n                      group (first groups)\n                      others (flatten (rest groups))]\n                  (recur others (conj acc [(count group) (first group)]))))))]\n    (->> coll (iterate #(helper %)) rest)))","user":"53528cd3e4b084c2834f4af2"},{"problem":110,"code":"(fn pronunciation[arr] (let\n\t[pronounce\n\t(fn [s]\n\t\t(loop [splat (partition-by identity s), res []]\n\t\t\t(prn splat, res)\n\t\t\t(if (empty? splat) res\n\t\t\t\t(recur\n\t\t\t\t\t(next splat)\n\t\t\t\t\t(concat res [(count (first splat)), (first (first splat))])\n\t\t\t\t)\n\t\t\t)\n\t\t)\n\t)]\n\t(lazy-seq\n\t\t(cons\n\t\t\t(pronounce arr)\n\t\t\t(pronunciation (pronounce arr))\n\t\t)\n\t)\n))","user":"5d73530ce4b02e6b30c93514"},{"problem":110,"code":"(fn spell[inp] \n         (let [desc (fn[ar] vec (reduce #(if (= %2 (last %1)) \n                              (let [splts (split-at (- (count %1) 2) %1)\n                                    fst (first splts)\n                                    [cnt elm] (second splts)]\n                                (concat fst [(inc cnt)elm]))\n          \n                              (concat %1 [1 %2])) [] ar))] \n               \n           (lazy-seq (cons (desc inp) (spell (desc inp))))))","user":"5d0cf1c8e4b0cc9c91588246"},{"problem":110,"code":"(fn mm [v]\n  (let [new (flatten (map (fn [e] (list (count e) (first e))) (partition-by identity v)))]\n  (lazy-seq (cons new\n                  (mm new)))))","user":"60264d89e4b0d5df2af2222d"},{"problem":110,"code":"(fn pronunciations [c]\n  (let [pron (fn [col] \n               (loop [i 0 j 1 res []]\n                 (if (= (+ i j) (count col))\n                   (conj res j (nth col i))\n                   (if (= (nth col i) (nth col (+ i j))) \n                     (recur i (inc j) res)\n                     (recur (+ i j) 1 (conj res j (nth col i)))))))]\n  (lazy-seq (cons (pron c) (pronunciations (pron c))))))","user":"5243e37ae4b076204b44fae3"},{"problem":110,"code":"(fn [init]\n  (rest (iterate (fn [s] (mapcat #(vector (count %) (first %))\n                                 (partition-by identity s)))\n                 init)))","user":"55f20e4be4b06e875b46ce40"},{"problem":110,"code":"(fn sp [xs]\n   (let [cur (mapcat #(vector (count %) (first %)) (partition-by identity xs))]\n      (lazy-seq (cons cur (sp cur)))))","user":"59f043d0e4b0966464fe6a3d"},{"problem":110,"code":"(fn ThisFunc [L]\n    ;;(println \"Start\" L)\n    (loop \n      [\n        Ret [] \n        ThisGroup (first L)\n        ThisCount 0\n        First ThisGroup\n        Rest (rest L)        \n      ]\n      (if (nil? First)\n        (let \n          [\n            Ret (into [] (concat Ret [ThisCount ThisGroup]))\n          ]\n          (lazy-seq (cons Ret (ThisFunc Ret)))\n        )\n        (recur\n          (if (= ThisGroup First) Ret (concat Ret [ThisCount ThisGroup]))\n          (if (= ThisGroup First) ThisGroup First)\n          (if (= ThisGroup First) (inc ThisCount) 1)\n          (first Rest)\n          (rest Rest)\n        )\n      )\n    )\n  )","user":"5d4a6c6ce4b0776584bd6f22"},{"problem":110,"code":"(fn pron [p]\n  (letfn [(pl [x] (->> x \n                  (partition-by identity)\n                  (mapcat #(vector (count %) (first %)) )\n                  vec\n                  ))]\n  (iterate pl (pl p))))","user":"5576e78de4b05c286339e075"},{"code":"(fn sq-pro [ls]\n  (letfn [(seq-proun [ls]\n            (loop [an [] ls ls]\n              (if (empty? ls)\n                an\n                (let [[xs ys] (split-with #(= % (first ls)) ls)]\n                  (recur (into an [(count xs) (first xs)])\n                         ys)))))\n          ]\n    (iterate seq-proun (seq-proun ls))))","problem":110,"user":"4dd62278535d2dad7130b5c7"},{"code":"(fn f[v]\n  (let\n    [p (->>\n        (partition-by identity v)\n        (map (fn[x][(count x)(first x)]))\n        (flatten))]\n    (cons p\n      (lazy-seq (f p)))))","problem":110,"user":"52f818a6e4b047fd55836fcc"},{"code":"(fn seq-of-pronunciations [coll]\n  (lazy-seq\n    (let [next-coll (apply concat (map #(vec [(count %) (first %)]) (partition-by #(if true %) coll)))]\n      (cons next-coll (seq-of-pronunciations next-coll)))))","problem":110,"user":"514d7e29e4b019235f6c0587"},{"code":"(fn seqprons [initial]\n  (rest\n  \t(iterate\n   \t\t(fn prns [sq]\n     \t\t(let [pbyid (partition-by identity sq)]\n       \t\t\t(mapcat (fn [v] [(count v) (first v)]) pbyid)))\n   \tinitial)))","problem":110,"user":"51a768e0e4b0da5f497bde84"},{"code":"(fn [vs] (rest (iterate (fn [v] (let \n[ls (partition-by identity v)] \n(flatten (map vector (map count ls) (map first ls))))) vs)))","problem":110,"user":"517945dce4b0684c1c981a43"},{"problem":110,"code":"(letfn [(pronunciation [xs]\n          (loop [result [], n 1, x (first xs), [a & other :as xs] (rest xs)]\n            (if (seq xs)\n              (let [same? (= a x)]\n                (recur\n                 (if same? result (conj result n x))\n                 (if same? (inc n) 1)\n                 (if same? x a)\n                 other))\n              (conj result n x))))]\n  (fn [xs]\n    (iterate pronunciation (pronunciation xs))))","user":"5b96800ae4b0c0b3ffbd4a7b"},{"code":"(fn [x]\n  (letfn [(pronounce [s] \n           (mapcat #(vector (count %) (first %)) (partition-by identity s)))]\n    (rest (iterate pronounce x))))","problem":110,"user":"4fdb02aae4b05e33b9224f56"},{"problem":110,"code":"(fn [coll]\n  (rest\n   (iterate\n    #(mapcat (juxt count first) (partition-by identity %))\n    coll)))","user":"605b7a90e4b079a07f8593fc"},{"code":"(fn [coll]\n  (iterate (fn pron [c]\n  (mapcat (juxt count first) (partition-by identity c))) ((fn pron [c]\n  (mapcat (juxt count first) (partition-by identity c))) coll)))","problem":110,"user":"4dada6d4c9a9d6ed2c99dc57"},{"code":"(fn x [s]\n  (let [ans (->> s (partition-by identity) (mapcat #(vector (count %) (first %))))]\n    (cons ans (lazy-seq (x ans)))))","problem":110,"user":"526439a4e4b03e8d9a4a70cc"},{"problem":110,"code":"(fn [coll]\n  (rest\n   (iterate\n   (fn [coll]\n     (mapcat #(list (count %) (first %)) (partition-by identity coll)))\n   coll)))","user":"57a4fa50e4b0a966079561f1"},{"problem":110,"code":"(fn pronunciations [xs]\n  (lazy-seq\n    (let [nxt (mapcat (juxt count first) (partition-by identity xs))]\n      (cons nxt (pronunciations nxt)))))","user":"5884e807e4b0f1effa3b76a6"},{"code":"(fn f [x] (let [looksay\n              (fn [n] \n                (if (= 1 (count n)) \n                  (conj [1] (first n))) \n                (loop [prev (first n) m (next n) prevcount 1 result []] \n                  (if (nil? m) \n                    (conj result prevcount prev) \n                    (if (= (first m) prev) \n                      (recur (first m) (next m) (inc prevcount) result) \n                      (recur (first m) (next m) 1 (conj result prevcount prev))))))\n              ]\n          (cons (looksay x) (lazy-seq (f (looksay x))))\n            )\n)","problem":110,"user":"526dd90de4b03e8d9a4a72fe"},{"code":"(fn [v] \n\t  (letfn [(speak [s] (->> s (partition-by identity) (map (juxt count first)) flatten ))]\n\t    (iterate speak (speak v))))","problem":110,"user":"50d0d4c8e4b00b15ecee976a"},{"problem":110,"code":"(fn pron [s]\n  (lazy-seq (cons (loop [prev (first s) c 1 tmps (rest s) ans '()]\n          (if (empty? tmps)\n            (reverse (conj (conj ans c) prev))\n            (if (= (first tmps) prev)\n              (recur prev (inc c) (rest tmps) ans)\n              (recur (first tmps) 1 (rest tmps) (conj (conj ans c) prev))))) (pron (loop [prev (first s) c 1 tmps (rest s) ans '()]\n          (if (empty? tmps)\n            (reverse (conj (conj ans c) prev))\n            (if (= (first tmps) prev)\n              (recur prev (inc c) (rest tmps) ans)\n              (recur (first tmps) 1 (rest tmps) (conj (conj ans c) prev)))))))))","user":"59368ccae4b02506e01a297a"},{"code":"(fn pronounce [s]\n  (let [pronunciation (flatten (map #(vector (count %) (first %)) (partition-by identity s)))]\n    (cons pronunciation (lazy-seq (pronounce pronunciation)))))","problem":110,"user":"52d3f666e4b09f7907dd1327"},{"problem":110,"code":"(fn [lst]\n  (letfn [(sequence-of-pronunciations [lst]\n            (let [nxt (->> (partition-by identity  lst)\n                        (map #(identity [(count %) (first %)] ))\n                        flatten \n                        vec) ]\n              (cons nxt (lazy-seq (sequence-of-pronunciations nxt)))\n              ))\n          ]\n    (sequence-of-pronunciations lst)))","user":"55aa1637e4b0988bba2ad949"},{"problem":110,"code":"(fn [ns]\n  (letfn [(foo [[n & _ :as ns]]\n            (if (empty? ns)\n              ns\n              (let [takes (take-while #(= n %) ns)\n                    drops (drop-while #(= n %) ns)]\n                (into [(count takes) n] (foo drops)))))]\n    (rest (iterate foo ns))))","user":"545bd22fe4b01be26fd7465a"},{"problem":110,"code":"(fn pro [init]\n  (letfn [(f [v] (flatten (map #(flatten [(count %) (last %)]) (partition-by identity v))))]\n   (drop 1 (reductions\n     (fn [x _] (flatten (f x)))\n     init\n     (range)))))","user":"55ede35ce4b0121d4835fde1"},{"code":"(fn [s]\r\n (rest\r\n  (iterate\r\n   (comp flatten\r\n    (fn pro [[x & xs]]\r\n     (if (nil? xs) [[1 x]]\r\n      (let [[[c p] & ps] (pro xs)]\r\n       (if (= x p) \r\n        (cons [(inc c) x] ps)\r\n         (into ps [[c p] [1 x]]))))))\r\n   s)))","problem":110,"user":"4db4714f535dc0f10411755a"},{"code":"(fn pronounce [v]\n  (lazy-seq\n    (let [prt (partition-by identity v)\n          r (vec (flatten (map (fn [coll] (list (count coll) (first coll))) prt)))]\n      (cons r (pronounce r)))))","problem":110,"user":"4f1bee08535d64f60314647e"},{"problem":110,"code":"(fn __ [coll]\n  (let [pron (mapcat #(vector (count %) (first %)) (partition-by identity coll))]\n    (cons pron (lazy-seq (__ pron)))))","user":"553abb28e4b09218d5f44ffb"},{"problem":110,"code":"(comp rest\n      (partial iterate #(mapcat (juxt count first) \n                                (partition-by identity %))))","user":"53ea5851e4b036ad0777e4e4"},{"problem":110,"code":"(letfn [(get-plural [numstr]\n          (if (empty? numstr) []\n              (let [item (first numstr)\n                    ymatch (take-while #(= % (first numstr)) numstr)\n                    nmatch (drop-while #(= % (first numstr)) numstr)\n                    count  (count ymatch)]\n                (concat [count item]\n                        (get-plural nmatch)))))\n        (pluralize [seed]\n          (lazy-seq (cons (get-plural seed) (pluralize (get-plural seed)))))]\n  (fn [seed] (pluralize seed)))","user":"5d4b2155e4b0776584bd6f28"},{"problem":110,"code":"(fn pronounciations [xs] \n     (let [pronounciation (fn [ys]\n                            (->> ys\n                              (partition-by identity)\n                              (map #(vector (count %) (first %)))\n                              flatten))\n           pronounced (pronounciation xs)]\n     (lazy-cat [pronounced] (pronounciations pronounced))))","user":"53c38b8ce4b00fb29b22127b"},{"code":"(fn pronunciation [x]\n      (let [part (partition-by identity x)\n            next (flatten (map #(list (count %) (first %)) part))]\n        (cons next (lazy-seq (pronunciation next)))\n      )\n    )","problem":110,"user":"5272d4b7e4b03e8d9a4a7453"},{"problem":110,"code":"(fn [coll]\n  (letfn [(pronounce [coll] (mapcat (juxt count first) (partition-by identity coll)))]\n    (rest (iterate pronounce coll))))","user":"50310713e4b05b7df5a0b84c"},{"problem":110,"code":"(fn [seq]\n  (let [f (fn [s]\n            (vec (reverse\n             (mapcat #(vector (first %) (count %)) \n                     (partition-by identity (reverse s))))))]\n    (iterate f (f seq))))","user":"546ff835e4b00cfc9eacc1b4"},{"problem":110,"code":"(fn [c]\n  (let [h (fn [c] (loop [_c c res []]\n                    (if (seq _c)\n                      (let [r (count (take-while #(= (first _c) %) _c))]\n                        (recur (drop r _c) (conj res r (first _c))))\n                      res)))\n        r (fn rr [c]\n            (lazy-seq\n             (let [x (h c)]\n               (cons x (rr x)))))]\n    (r c)))","user":"5a085dfde4b01bb0ae8afdf4"},{"problem":110,"code":"(fn p [xs]\n    (let [ts (reduce #(concat %1 [(count %2) (first %2)]) [] (partition-by identity xs))]\n      (lazy-seq (cons ts (p ts)))))","user":"507e68abe4b085af06e3afd2"},{"problem":110,"code":"(fn [coll]\n  (let [f #(->> (partition-by identity %)\n                (map (juxt count first))\n                (apply concat))]\n    (iterate f (f coll))))","user":"52470d42e4b05ef8e38e6350"},{"code":"(fn [s]\n  (drop 1\n    (iterate\n      (fn [x]\n        (reduce #(conj (conj %1 (count %2)) (first %2))\n        []\n        (partition-by identity x))\n      ) s)))","problem":110,"user":"4ea1ecfa535d7eef308072bb"},{"code":"(fn p [s]\n  (rest (iterate (fn [x] (mapcat #(list (count %) (first %)) (partition-by identity x))) s))\n)","problem":110,"user":"51ba8f82e4b0fe3ecfb46434"},{"problem":110,"code":"(fn f [x]\n  (let [p (partition-by identity x)\n        y  (flatten (for [i p] [(count i) (first i)]))]\n    (lazy-seq (cons y (f y)))))","user":"5d7d17ece4b02e6b30c93558"},{"problem":110,"code":"(fn f-110 [coll]\n  (let [r (flatten (map (comp reverse flatten vec frequencies) (partition-by identity coll)))]\n    (cons r (lazy-seq (f-110 r)))))","user":"53d86564e4b0e771c302546b"},{"problem":110,"code":"(fn [coll]\n  (let [pronoun (fn [coll] (->> coll\n                                (partition-by identity)\n                                (mapcat #(vector (count %) (first %)))))]\n    (->> coll\n         (iterate pronoun)\n         rest)))","user":"5cb41c40e4b026601754b911"},{"code":"(fn prons [sq]\n  (lazy-seq \n    (let [res (loop [[a & xs] sq, zs [], es []] \n                (let [zs (conj zs a)\n                      [b] xs]\n                  (if (= a b) \n                    (recur xs zs es)\n                    (let [zs [(count zs) (first zs)]]\n                      (if-not b\n                        (concat es zs)\n                        (recur xs [] (concat es zs)))))))]\n      (cons res (prons res)))))","problem":110,"user":"4dd61f98535d2dad7130b5c6"},{"code":"(fn\n  [n]\n  (let [nextpron (fn [vs]\n                   (reduce (fn [s n]\n                             (if (= (last s) n)\n                               (update-in s [(- (count s) 2)] inc)\n                               (into s [1 n])))\n                           []\n                           vs))]\n    (rest (iterate nextpron n))))","problem":110,"user":"51852961e4b0da5a5be3babb"},{"problem":110,"code":"(fn [c]\n  (next (iterate\n          #(mapcat (juxt count first)\n                   (partition-by + %))\n          c)))","user":"4f9d8083e4b0dcca54ed6d23"},{"problem":110,"code":"(fn [s]\n  (drop 1 (iterate (fn[x]\n                     (mapcat #(vector (count %) (first %)) (partition-by identity x)))\n                   s)))","user":"57822efce4b0d36ec5835e91"},{"problem":110,"code":"(fn [sx] \n  (letfn [(pron [sy] \n            (mapcat (fn [n] [(count n) (first n)]) (partition-by identity sy)))]\n    (lazy-seq (iterate pron (pron sx)))  \n  )\n)","user":"5fd8bcb3e4b05ac5b16ea11b"},{"problem":110,"code":"(fn f [xs]\n  (let [a (flatten (map (juxt #(count %) #(first %)) (partition-by identity xs)))]\n    (lazy-seq \n      (cons a (f a)))))","user":"5e2549c8e4b05b4b0151615f"},{"problem":110,"code":"#(rest( iterate (fn [l]\n\t(flatten (reduce\n\t\t(fn [[l num curr] el]\n\t\t\t(if (= curr el)\n\t\t\t\t[l (+ 1 num) el]\n\t\t\t\t[(concat l [num curr]) 1 el]))\n\t\n\t[[] 1 (first l)]\n\t(rest l)))\n) %))","user":"5626447fe4b00e49c7cb47bd"},{"problem":110,"code":"(fn pronounciations [ns] \n  (let [p (into [] (apply concat (map (comp vec (juxt count first)) (partition-by identity ns))))]\n    (lazy-seq (cons p (pronounciations p)))))","user":"5609d328e4b05f002753deee"},{"problem":110,"code":"(fn f [x]\n  (let [s (fn [x] \n               (mapcat \n                #(list (count %) (first %))\n                (partition-by identity x)))]\n        (rest (iterate s x))))","user":"543d5c61e4b032a45b86934d"},{"code":"#(drop 1 (iterate (fn [a] (reduce (fn [c x] (conj c (count x) (first x))) [] (partition-by identity a))) %))","problem":110,"user":"51f66e0ee4b06ff1c25c52c3"},{"problem":110,"code":"(fn [init]\n  (rest (iterate (fn [coll]\n                   (mapcat #(vector (count %) (first %))\n                           (partition-by identity coll)))\n                 init)))","user":"56dc3bdfe4b0ea9b8538f819"},{"code":"#(next (iterate (fn [c] (mapcat (fn [x] [(count x) (first x)]) (partition-by identity c))) %))","problem":110,"user":"4e65027c535d8ccf87e9fe6e"},{"problem":110,"code":"(fn [sq]\n    (lazy-seq\n     (rest (iterate\n            #(mapcat\n              (juxt count first)\n              (partition-by identity %))\n            sq))))","user":"539fa040e4b0ca733b97449f"},{"code":"(fn [v]\r\n  (letfn [(sub [v]\r\n            (let [r (loop [v v\r\n                           l nil\r\n                           c nil\r\n                           r '()]\r\n                      (cond (empty? v)\r\n                            (if c\r\n                              (vec (reverse (conj r c l)))\r\n                              (vec (reverse r)))\r\n\r\n                            c\r\n                            (if (= (first v) l)\r\n                              (recur (rest v) l (+ 1 c) r)\r\n                              (recur (rest v) (first v) 1 (conj r c l)))\r\n\r\n                            :else\r\n                            (recur (rest v) (first v) 1 r)))]\r\n              (lazy-seq (cons r (sub r)))))]\r\n    (sub v)))","problem":110,"user":"4de2f44f535d08e6dec9fdec"},{"problem":110,"code":"(fn pronunciations [ l ] \n  (let [m (partition-by identity l)\n        out (vec (interleave  (map count m) (map first m)))]\n    (lazy-seq (cons  out  (pronunciations out)))))","user":"57887de2e4b0ebec4cfb751c"},{"problem":110,"code":"(fn pronounce [coll]\n    (let [these-seqs (partition-by identity coll)\n          new-coll (flatten (map #(vector (count %) (first %)) these-seqs))]\n      (cons new-coll (lazy-seq (pronounce new-coll)))\n    ))","user":"546692aee4b01be26fd746e7"},{"problem":110,"code":"(fn pronounce [s]\n    (let [pronounced (->> s\n                          (partition-by identity)\n                          (mapcat #((juxt count first) %)))]\n      (lazy-seq (cons pronounced (pronounce pronounced)))))","user":"52761edae4b03e8d9a4a74d4"},{"code":"(fn it [s]\r\n  (letfn [(pr [s]\r\n    (mapcat (juxt count first)\r\n         (partition-by identity s)))]\r\n    (lazy-seq (cons (pr s) (it (pr s))))))","problem":110,"user":"4ff304f4e4b0678c553fc343"},{"code":"(fn [x] (rest (iterate #(reduce into (map (fn [s] [(count s) (first s)]) (partition-by identity %))) x)))","problem":110,"user":"536973e5e4b0243289761e9e"},{"problem":110,"code":"(fn sq [coll]\n  (lazy-seq\n   (let [next-coll (apply concat \n                          (map #(vec [(count %) (first %)])\n                               (partition-by #(if true %) coll)))]\n     (cons next-coll (sq next-coll)))))","user":"5632d1b3e4b0bfe05bf117a9"},{"problem":110,"code":"(fn pronounce [gen]\n  (->>\n    (iterate\n      (fn [prev-gen]\n        (->>\n          prev-gen\n          (partition-by identity)\n          (reduce\n            #(conj %1 (count %2) (first %2))\n            [])))\n      gen)\n    (drop 1)))","user":"5b02ab12e4b0cc2b61a3bd53"},{"problem":110,"code":"(fn pronunciations\n  [my-vec]\n  (let [new-vec\n        (->> (partition-by identity my-vec)\n             (map (fn [x] [(count x) (first x)]))\n             (flatten))]\n    (lazy-seq\n     (cons new-vec\n           (pronunciations new-vec)))))","user":"5b759ca8e4b047b03b2036d0"},{"problem":110,"code":"(fn get_s [s]\n  (let [get_l (fn [l]\n                (loop [m (rest l)\n                       v  (first l)\n                       c  1\n                       r []]\n                  (if (empty? m)\n                    (into r [c v])\n                    (let [nv (first m)]\n                      (if (= nv v)\n                        (recur (rest m) v (inc c) r)\n                        (recur (rest m) nv 1 (into r [c v])))))))]\n    (let [q (get_l s)]\n      (lazy-seq (cons q (get_s q))))))","user":"56051095e4b08b23635d3162"},{"problem":110,"code":"(fn pronunciations [nums]\n  (let [soln (mapcat (juxt count first) (partition-by identity nums))]\n    (lazy-seq\n     (cons soln (pronunciations soln)))))","user":"4ee75ec2535d93acb0a66867"},{"code":"(fn p [xs]\n  (lazy-seq\n    (let [r (mapcat #(list (count %) (first %)) (partition-by identity xs))]\n      (cons r (p r)))))","problem":110,"user":"4f1b92d1535d64f60314647b"},{"code":"(fn pronounce [coll]\n  (let [p (mapcat (juxt count first) (partition-by identity coll))]\n    (lazy-seq (cons p (pronounce p)))))","problem":110,"user":"4f849f76e4b033992c121c36"},{"code":"(fn [init]\n  (let [pron (fn [curr]\n    (apply conj (reduce (fn [[acc cnt prev] e]\n      (if (= prev e)\n          [acc (+ cnt 1) prev]\n          [(conj acc cnt prev) 1 e]))\n            [[] 1 (first curr)]\n            (rest curr))))]\n       (rest (iterate pron init))))","problem":110,"user":"4f13047d535d64f60314642c"},{"code":"(fn pronunciations [coll]\n  (letfn [(pronounce [coll]\n            (->> (reduce build [[1 (first coll)]] (rest coll))\n                 (flatten)))\n          (build [coll n]\n            (let [current (peek coll)]\n              (if (= n (second current))\n                (conj (pop coll) [(inc (first current)) n])\n                (conj coll [1 n]))))]\n    (->> (iterate pronounce coll)\n         (rest))))","problem":110,"user":"4e5bff2b535d8a8b8723a2bd"},{"problem":110,"code":"(fn get-pronun [coll]\n  (let [pron (fn [coll]\n               (loop [x (first coll) n 0 counts [] coll coll]\n                 (cond\n                   (empty? coll) (conj counts n x)\n                   (= x (first coll)) (recur x (inc n) counts (rest coll))\n                   :else (recur (first coll) 1 (conj counts n x) (rest coll)))))\n        p (pron coll)]\n      (cons p (lazy-seq (get-pronun p)))))","user":"549c1713e4b0f3d1d8e70f82"},{"code":"(fn pronounce-seq\n  [coll]\n    (lazy-seq\n    (let [coll (->> coll\n      (partition-by identity)\n      (map #(vector (count %1) (first %1)))\n      (apply concat))]\n    (cons coll (pronounce-seq coll)))))","problem":110,"user":"4e521cef535d302ef430da6d"},{"code":"(fn pronon [n]\n    (let [pron\n          (mapcat\n              #(list (count %) (first %))\n              (partition-by identity n))]\n        (lazy-seq (cons pron (pronon pron)))))","problem":110,"user":"4f128865535d64f603146428"},{"code":"(fn pronunciations [list]\n  (letfn [(pronounce [list]\n            (mapcat #(vector (count %) (first %)) (partition-by identity list)))]\n    (rest (iterate pronounce list))))","problem":110,"user":"4e8338d6535db62dc21a62d3"},{"code":"#(rest (iterate (fn [s] (mapcat (fn [x] (cons (count x) [(first x)])) (partition-by identity s))) %))","problem":110,"user":"53973e7be4b0b51d73faaee6"},{"problem":110,"code":"(fn pronounce [s]\n  (let [pronunciation (mapcat #(vector (count %) (first %)) (partition-by identity s))]\n    (lazy-seq (cons pronunciation (pronounce pronunciation)))\n    )\n  )","user":"589037b4e4b00487982d51d0"},{"code":"(partial (comp next iterate)\n                  #(->> %\n                        (partition-by identity)\n                        (mapcat (fn [x] [(count x) (first x)])))\n                  )","problem":110,"user":"4e9fd521535d7eef3080729a"},{"problem":110,"code":"#(letfn ([f [arg]\n          (iterate (fn [y]\n                    (let [a (partition-by identity y)\n                          b (map count a)\n                          c (map first a)]\n                      (flatten (interleave b c))))\n                   arg)])\n  (rest (f %)))","user":"5371167fe4b0fc7073fd6ea7"},{"code":"(fn prob-110 [coll]\n  (let [pronounced \n        (->> coll\n             (partition-by identity)\n             (map #(list (count %) (first %)))\n             flatten)]\n    (cons pronounced\n          (lazy-seq (prob-110 pronounced)))))","problem":110,"user":"504ec4d3e4b069badc5a33c9"},{"problem":110,"code":"(fn pron [x]\n          (let [y (flatten (map #(vector (count %) (first %)) (partition-by identity x)))] \n            (cons y (lazy-seq (pron y)))))","user":"52bbd09ee4b07a9af57922ee"},{"code":"(fn pron [xs]\n   (let [next-xs (mapcat (juxt count first) (partition-by identity xs))]\n     (lazy-seq (cons next-xs (pron next-xs)))))","problem":110,"user":"51e58e02e4b0efabf93c02d0"},{"code":"(fn [s0]\n  (letfn [(step [s]\n            (mapcat #(list (count %) (first %))\n                    (partition-by identity s)))]\n    (iterate step (step s0))))","problem":110,"user":"4ed188c8535d44c135fd68cf"},{"code":"(fn x [s]\r\n  (let [p (partition-by identity s)\r\n        thing (flatten (map #(vector (count %) (first %)) p))]\r\n  (lazy-seq (cons thing (x thing)))))","problem":110,"user":"4fe900a6e4b0547ebccb243a"},{"code":"(fn f [x]\n  (let [y (reduce #(into % [(count %2) (first %2)])\n                  []\n                  (partition-by identity x))]\n    (lazy-seq\n     (cons y (f y)))))","problem":110,"user":"509160dae4b0742c82730aef"},{"code":"(fn [v]\r\n  (#(iterate % (% %2))\r\n  #(mapcat (juxt count last) (partition-by + %)) v))","problem":110,"user":"50843a4ae4b0c98812d0788b"},{"problem":110,"code":"(let [pronunce (fn\n                 [s]\n                 (let [[curr count accum] (reduce (fn [[curr count accum] next]\n                                                    (if (= next curr)\n                                                      [curr (+ count 1) accum]\n                                                      [next 1 (conj accum count curr)]))\n                                                  [gensym 0 []] s)]\n                   (conj (into [] (drop 2 accum)) count curr)))]\n  (fn pronunce-seq\n    [s]\n    (lazy-seq (cons (pronunce s) (pronunce-seq (pronunce s))))))","user":"58152157e4b0f478707a0631"},{"problem":110,"code":"(fn pronunciations\n  [coll]\n  (let [f #(mapcat (juxt count first) (partition-by identity %))]\n    (iterate f (f coll))))","user":"5383668ee4b06839e8705edd"},{"problem":110,"code":"(fn [coll]\n  (letfn [(pronunciation [coll]\n            (mapcat #(list (count %) (first %)) (partition-by identity coll)))]\n    (iterate pronunciation (pronunciation coll))))","user":"5d9c1226e4b0d3f9b434ad51"},{"problem":110,"code":"(fn pro [lst]\n  (let [result (atom [])\n        temp-store (reduce #(cond (not\n                                   (or\n                                    (nil? (last %1))\n                                    (= %2 (last %1))))\n                   (do (swap! result concat [(count %1) (first %1)])\n                       (conj (empty %1) %2))\n                   :else (conj %1 %2)) [] lst)]\n    (swap! result concat [(count temp-store) (first temp-store)])\n    (lazy-seq (cons @result (pro @result)))))","user":"5bab31f1e4b0a20761a23471"},{"problem":110,"code":"(fn pr\n  [nums]\n  (lazy-seq\n   (let\n     [h ((fn\n           [s]\n           (flatten\n            (map\n             #(vector (count %) (first %))\n             (partition-by identity s))))\n         nums)]\n     (cons h (pr h)))))","user":"5796d3ebe4b039eba2ecb0ee"},{"problem":110,"code":"(fn lazy-pronouncer [arr]\n  (let [pronounced ((fn pronounce [arr]\n                      ((fn helper [curr c arr res]\n                         (if (empty? arr)\n                           (conj res c curr)\n                           (if (= curr (first arr))\n                             (helper curr\n                                     (inc c)\n                                     (drop 1 arr)\n                                     res)\n                             (helper (first arr)\n                                     1\n                                     (drop 1 arr)\n                                     (conj res c curr)))))\n                       (first arr)\n                       1\n                       (drop 1 arr)\n                       [])) arr)]\n    (lazy-seq (cons pronounced\n                    (lazy-pronouncer pronounced)))))","user":"5dc53ddee4b02f9375f4e1bd"},{"code":"(fn prons [initial]\n  (let [step (fn step [old]\n      (loop [data initial, new_vec []]\n        (if (empty? data)\n          new_vec\n          (let [number (first data)\n              numlist (take-while #(= number %) data)\n              numcount (count numlist)]\n            (recur (drop-while #(= number %) data) (into new_vec [numcount number]))))))]\n  (cons (step initial) (lazy-seq (prons (step (step initial)))))))","problem":110,"user":"4e6a60cd535d8ccf87e9fed7"},{"code":"(fn [s]\n  (letfn [(apron [r s]\n    (if (empty? s)\n        r\n        (let [fs (first s) vs (take-while #(= % fs) s) cnt (count vs)]\n          (recur (conj (conj r cnt) fs) (drop cnt s)))))]\n    ((fn prons [r] (lazy-seq (cons r (prons (apron [] r))))) (apron [] s))))","problem":110,"user":"5063fe48e4b075d771da6f9e"},{"code":"(fn pseq [col]\n  (let [p (flatten (for [g (partition-by identity col)] [(count g) (first g)]))]\n    (cons p (lazy-seq (pseq p)))))","problem":110,"user":"514721c6e4b0d520409ed392"},{"problem":110,"code":"(fn pron [col]\n  (let [p (flatten (map (fn [c] [(count c) (first c)]) (partition-by identity col)))]\n    (cons p\n      (lazy-seq\n        (pron p)\n      )\n    )\n  )\n)","user":"53ca41dae4b00fb29b2212c8"},{"problem":110,"code":"(fn f [x]                                                                                                                     \n    (lazy-seq (let [x (->> x                                                                                                  \n                           (partition-by identity)                                                                            \n                           (reduce (fn [xs y]                                                                                 \n                                       (-> xs                                                                                 \n                                           (conj (count y))                                                                   \n                                           (conj (first y)))) []))]                                                           \n                (cons x (f x)))))","user":"55316b8ae4b076ab5578f825"},{"code":"(fn [coll]\n  (rest (iterate #(mapcat (juxt count first)\n                          (partition-by identity %))\n                 coll)))\n\n;; (fn solve [coll]\n;;   (loop [coll coll, acc []]\n;;     (if (not-empty coll)\n;;       (let [x (first coll)\n;;             [a b] (split-with (partial = x) coll)]\n;;         (recur b (conj acc (count a) x)))\n;;       (lazy-seq (cons acc (solve acc))))))\n\n;; (fn [^vector vect]\n;;   (letfn [(iter [v]\n;;             (->> (conj v 'trminate)\n;;                  (partition 2 1)\n;;                  (reduce (fn [[acc n] [x y]]\n;;                            (if (= x y) [acc (inc n)] [(conj acc n x) 1]))\n;;                          [[] 1])\n;;                  first))]\n;;     (rest (iterate iter vect))))","problem":110,"user":"4daec9dcedd6309eace4d15f"},{"code":"(fn [s]\n    (drop 1 (iterate (fn [s] \n                       (mapcat (juxt count first) \n                               (partition-by identity s))) s)))","problem":110,"user":"52e3e6a8e4b09f7907dd1448"},{"code":"(fn [xs]\n  (rest\n    (iterate \n      #(reduce\n         (fn [xs x] (into xs [(count x) (first x)]))\n         []\n         (partition-by identity %)) xs)))","problem":110,"user":"4e513758535dc968683fc4f3"},{"problem":110,"code":"#(rest\n  (iterate\n   (fn [x]\n     (mapcat\n      (fn [y]\n        [(count y) (first y)])\n      (partition-by identity x)))\n   %))","user":"53d5a63be4b0e771c3025449"},{"code":"(fn iter [start-seq]\n  (let [p ((fn [number-seq]\n             (let [tokens (into [[1 (first number-seq)]] (rest number-seq))]\n               (reduce\n                (fn [result current]\n                  (let [parts (split-at (- (count result) 2) result),\n                        done (vec (first parts)),\n                        total (first (last parts)),\n                        token (last (last parts))]\n                    (if (= current token)\n                      (conj done (inc total) token)\n                      (conj done total token 1 current))))\n                tokens)))\n           start-seq)]\n    (cons p (lazy-seq (iter p)))))","problem":110,"user":"4ecbb249535df97575fdabdf"},{"code":"(fn [x] (rest (iterate #(->> (partition-by identity %) (map (juxt count first)) flatten) x)))","problem":110,"user":"528e64b7e4b0239c8a67aedd"},{"code":"(fn [n]\r\n  (let [speak #(flatten (map (fn [[a b]] [b a]) (frequencies %)))]\r\n    (drop 1 (iterate #(flatten (map speak (partition-by identity %))) n))))","problem":110,"user":"4e6e2ac4535d5021c1a895ff"},{"code":"#(rest\n    (iterate\n     (fn [x]\n       (mapcat\n        (fn [x] [(count x) (first x)])\n        (partition-by identity x))) %))","problem":110,"user":"4f0664bd535dcb61093f6c0f"},{"problem":110,"code":"(fn [coll]\n  (letfn [(pron [coll]\n            (->>\n             (partition-by identity coll)\n             (reduce (fn [acc v] (conj acc (count v) (first v))) [])))]\n    (iterate pron (pron coll))))","user":"5fa74b82e4b0fa27300f3dda"},{"problem":110,"code":"(fn [xs]\n  (rest\n\t(iterate \n   \t\t(fn [x] (mapcat \n                 #(vector (count %) (first %))\n                 (partition-by identity x))) \n   xs)))","user":"506ba58be4b0eda3100c090b"},{"code":"(letfn [(pronounce [x] (mapcat (fn [s] [(count s) (first s)]) (partition-by identity x)))]\n  #(rest (iterate pronounce %)))","problem":110,"user":"4ed94d69535d10e5ff6f5303"},{"problem":110,"code":"(fn f [s]\n  (let [p (mapcat #(list (count %) (first %)) (partition-by identity s))]\n    (cons p (lazy-seq (f p)))))","user":"54dd76c8e4b024c67c0cf794"},{"problem":110,"code":"(fn ps [xs]\n  (let [v (->> xs\n               (partition-by identity)\n               (mapcat (juxt count first)))]\n    (cons v (lazy-seq (ps v)))))","user":"56ef077ae4b04a395b9a0459"},{"problem":110,"code":"(fn p [xs]\n    (let [f (fn [xs] (mapcat #(vector (count %) (first %)) (partition-by identity xs)))\n          ys (f xs)] (lazy-cat [ys] (p ys))))","user":"59da6480e4b0ef0a1e9b5c68"},{"code":"(letfn [(split-same [seq]\n                (if (empty? seq) []\n                    (cons (take-while #(= % (first seq)) seq)\n                          (split-same (drop-while #(= % (first seq)) seq)))))\n              (pron-same [s]\n                [(count s) (first s)])\n              (pron1 [s]\n                (mapcat pron-same (split-same s)))]\n        (fn [s] (iterate pron1 (pron1 s))))","problem":110,"user":"5294e44de4b02ebb4ef75016"},{"problem":110,"code":"(fn sequenceofPronunciations\n  [vect]\n  (let [resVec (vec (interleave (map count (partition-by identity vect)) (flatten (map distinct (partition-by identity vect)))))]\n      (cons resVec (lazy-seq (sequenceofPronunciations resVec ))))\n  )","user":"5772ddb0e4b0979f896515d4"},{"problem":110,"code":"(fn p [coll]\n    (lazy-seq\n      (let [nxt\n            (mapcat (fn [c] [(count c) (first c)])\n                   (partition-by identity coll))]\n        (cons nxt (p nxt))\n      )))","user":"536ecd9fe4b0fc7073fd6e76"},{"code":"(fn pronunciations [xs] (rest (iterate (fn [x] (mapcat #(vector (count %) (first %)) (partition-by identity x))) xs)))","problem":110,"user":"52f10094e4b05e3f0be25ee8"},{"code":"(fn p110\n  ([ls] (p110 [] ls))\n  ([ac ls] (if (empty? ls) (cons ac (lazy-seq (p110 ac)))\n    (let [f (first ls)\n           hs (take-while #(= f %) ls)\n           ds (drop-while #(= f %) ls)\n            ] (p110 (conj ac (count hs) f) ds))))\n)","problem":110,"user":"5272669de4b03e8d9a4a742e"},{"problem":110,"code":"(fn x [v]\n  (let [z (fn [coll] (reduce #(conj %1 (count %2) (first %2)) [] (partition-by identity coll)))]\n    (iterate z (z v))))","user":"583667c7e4b089d5ab817cfb"},{"problem":110,"code":"(fn p [s]\n\t(let[pronounce (juxt count first)\n\t\t init (mapcat pronounce (partition-by identity s))]\n\t\t(cons init\n\t\t\t(lazy-seq (p init)))))","user":"5472d919e4b094393f72dd7b"},{"code":"(fn [ss] (rest (iterate (fn [s] (mapcat #(vector (count %) (first %)) (partition-by identity s))) ss )))","problem":110,"user":"523b1988e4b02f719975bdbc"},{"problem":110,"code":"(fn f\n  ([c]\n   (f [] 1 (first c) (rest c)))\n  ([v n i c]\n   (if i\n       (let [head (first c)]\n         (if (= head i)\n           (f v (inc n) i (rest c))\n           (f (conj v n i) 1 head (rest c))))\n       (lazy-seq (cons v (f v))))))","user":"4f3e6244e4b0e243712b1f85"},{"problem":110,"code":"(fn process [inputList]\n\t(lazy-seq\n    \t(let [groupedList (partition-by identity inputList)\n              pronounceList (reduce #(conj %1 (count %2) (first %2)) [] groupedList)]\n        \t(cons pronounceList (process pronounceList))))\n)","user":"571172ece4b09c608db70446"},{"problem":110,"code":"(fn pronounce [s]\n  (letfn [(get-pronunciation [s] \n            (loop [tail (rest s) res [] cur-digit (first s) num-times-repeating 1]\n              (let [head (first tail)]\n                (if (nil? head)\n                  (conj res num-times-repeating cur-digit)\n                  (if (= head cur-digit) \n                    (recur (rest tail) res cur-digit (inc num-times-repeating))\n                    (recur (rest tail) (conj res num-times-repeating cur-digit) head 1)\n                    )\n                  )\n        ;; (recur (filter #(not (= head %)) tail) (into res  [(count (filter #(= head %) tail)) head]))\n                )\n              )\n\n            )]\n    (lazy-seq (cons (get-pronunciation s) (pronounce (get-pronunciation s)))))\n)","user":"5ff676a9e4b06df49cee1497"},{"code":"(fn sop [xs]\n  (let [item (->> xs (partition-by identity) (mapcat (juxt count first)) vec)]\n    (lazy-seq (cons item (sop item)))))","problem":110,"user":"50366589e4b0fbe0a74d26c3"},{"code":"(fn f [s]\n  (letfn [\n          (pronounce [s] (pronounce2 (first s) 1 (rest s) []))\n          (pronounce2 [e c s r] (if-not (empty? s) \n                                        (let [f (first s) m (= f e)]\n                                          (if m (recur e (inc c) (rest s) r)\n                                                (recur f 1       (rest s) (concat r [c e]))))\n                                        (concat r [c e])))]\n         (let [p (pronounce s)] (lazy-seq (cons p (f p))))))","problem":110,"user":"4e8b98fc535d65386fec2124"},{"code":"(fn ps [xs]\n  (letfn\n    [\n      (pronounce [[x & s]]\n        (reduce\n          #(if (= (last %1) %2)\n            (concat (drop-last 2 %1) [(inc (first (take-last 2 %1))) %2])\n            (concat %1 [1 %2])\n          )\n          [1 x]\n          s\n        )\n      )\n    ]\n    (let [p (pronounce xs)]\n      (cons p (lazy-seq (ps p)))\n    )\n  )\n)","problem":110,"user":"507eddf4e4b06ce648bcdbfa"},{"problem":110,"code":"(fn [s]\n  (letfn [(g [s]\n             (loop [s s\n                    a []\n                    c nil]\n               (if (empty? s)\n                 (vec (apply concat (map reverse (partition 2 a))))\n                 (let [v (first s)]\n                   (do (print a)\n                     (recur (rest s)\n                          (if (= v c)\n                            (vec (concat (butlast a)\n                                    [(inc (last a))]))\n                            (into a [v 1]))\n                          v))))))\n          (r [s] (cons s (lazy-seq (r (g s)))))]\n    (r (g s))))","user":"551ed214e4b08d5046aa8a4d"},{"problem":110,"code":"(fn seq-pro\n  [n]\n  (let [pronun (fn [coll]\n                 (let [part (partition-by identity coll)]\n                   (loop [[x & xs] part res []]\n                     (if (nil? x)\n                       res\n                       (recur xs\n                              (conj res (count x) (first x)))))))]\n    (iterate pronun (pronun n))))","user":"54b7f217e4b0ed20f4ff6e8f"},{"problem":110,"code":"(fn aaa [init]\n (letfn \n  [(func [v]\n     (mapcat \n      (juxt count first)\n      (partition-by identity v)))]        \n  (iterate func (func init))))","user":"57487084e4b009280f9f2b8c"},{"code":"(fn [ns]\n  (rest (iterate (fn pron [ns] (when-first [n ns]\n                           (let [c (count (take-while #(= % n) ns))]\n                             (list* c n (pron (drop c ns)))))) ns)))","problem":110,"user":"4e8612f8535db62dc21a62f2"},{"code":"(fn pronunciations\n [xs]\n (let [x (->> xs\n             (partition-by identity)\n             (mapcat #(vector (count %) (first %))))]\n   (cons x (lazy-seq (pronunciations x)))))","problem":110,"user":"524f4256e4b0541d1855b808"},{"problem":110,"code":"(fn [x]\n  (let [f (fn [x] (mapcat (fn [[y :as z]] [(count z) y])\n                          (partition-by identity x)))]\n    (iterate f (f x))))","user":"5d1b2b7de4b02ea6f0fb697a"},{"code":"(fn f [s]\n  (let [p (mapcat #(list (count %) (first %)) (partition-by str s))]\n    (cons p (lazy-seq (f p)))))","problem":110,"user":"4e1350af535d04ed9115e7d8"},{"code":"(fn [x]\n  (rest (iterate \n     #(mapcat (juxt count first)\n                  (partition-by identity %))\n     x)))","problem":110,"user":"502bb7c0e4b0194ad32ea1a3"},{"problem":110,"code":"(fn [s]\n    (rest\n     (iterate (fn [s]\n                (flatten\n                 (reduce\n                  (fn [[v i m] n]\n                    (if (= n m)\n                      [v (inc i) m]\n                      [(conj v i m) 1 n]))\n                  [[] 1 (first s)] (rest s))))\n              s)))","user":"4f57c913e4b0a7574ea7183f"},{"problem":110,"code":"(fn pronun [a-seq]\n  (let [trnslt (fn [b-seq]\n                 (loop [lseq b-seq acc []]\n                   (if (empty? lseq)\n                     acc\n                     (let [nnum (first lseq)\n                           cnt (count\n                                 (take-while\n                                   #(= nnum %)\n                                   lseq))]\n                       (recur\n                         (drop cnt lseq)\n                         (conj acc cnt nnum))))))]\n    (lazy-seq\n      (let [ngrp (trnslt a-seq)]\n        (cons ngrp (pronun ngrp))))))","user":"56cb4d06e4b0ea9b8538f72e"},{"problem":110,"code":"(fn [l]\n  (rest\n   (iterate\n    (fn [lst]\n      (flatten\n       (map\n        (fn [x] [(count x) (first x)])\n        (reduce (fn [acc el]\n                  (let [lastlst (last acc)\n                        lastel (last lastlst)]\n                    (if (= el lastel)\n                      (conj (into [] (butlast acc))\n                            (conj (into [] lastlst) el))\n                      (conj (into [] acc) [el])))) [] lst))))\n    l)))","user":"51b76227e4b0d906fcd71d35"},{"problem":110,"code":"(fn pronunciations [xs]\n  (letfn [(pronounce [xs]\n            (->> xs\n                 (partition-by identity)\n                 (mapcat #(vector (count %) (first %)))))]\n    (rest (iterate pronounce xs))))","user":"5ca14eb1e4b048ec896c5b7d"},{"problem":110,"code":"(fn pron [x]\n  (letfn [(topron [x]\n                  (if (empty? x)\n                    []\n                    (let [[nums rst] (split-with #(= (first x) %) x)\n                          cnt (count nums)\n                          v (first nums)]\n                      (concat [cnt v] (topron rst)))))]\n    (let [res (topron x)]\n      (cons res (lazy-seq (pron res))))))","user":"525cc912e4b0cb4875a45d48"},{"problem":110,"code":"(fn p [c]\n  (let [res (mapcat (fn [x] [(count x) (first x)]) (partition-by identity c))]\n    (cons res (lazy-seq (p res)))))","user":"529dfc6de4b04e0c58e87b8a"},{"problem":110,"code":"(fn [x]\n  (letfn [(transform\n            [col]\n            (->> (partition-by identity col)\n                 (map #(conj [] (count %) (first %)))\n                 (apply concat)))\n          (transform-times\n            [n col]\n            (->> (transform col)\n                 (transform-times (dec n))\n                 (if (= 0 n) col)))]\n    (map #(transform-times % x) (next (range)))))","user":"55b22c33e4b0da326a65cf79"},{"code":"(fn pro-seq [coll]\n  (let [pronounce (fn \n            [coll]\n            (reduce #(concat % (list (count %2) (first %2))) []\n              (partition-by identity coll)))\n        res (pronounce coll)]\n    (lazy-seq (cons res (pro-seq res)))))","problem":110,"user":"502a5fa4e4b09e8f859a9fbd"},{"code":"(fn f [s]\n  (let [proc (fn [s] (mapcat #(vector (count %) (first %)) (partition-by identity s)))]\n    (lazy-seq\n     (let [p (proc s)]\n       (cons p (f p))))))","problem":110,"user":"524cdd51e4b0752c4cb68ccc"},{"code":"(fn pronunciations [l]\n  (let [p #(partition-by identity %)\n        r (fn [l] (reduce #(concat % [(count %2) (first %2)]) [] (p l)))]\n    (iterate r (r l))))","problem":110,"user":"4f251302e4b0d66497709ff0"},{"problem":110,"code":"(fn pron [s]\n  (lazy-seq\n   (let [secs (partition-by identity s)\n         next (flatten (map #(vector (count %) (first %)) secs))]\n     (cons next (pron next)))))","user":"5317d78ee4b08068f379ed63"},{"problem":110,"code":"(fn [arg]\n    (letfn [(sop-110 [xs]\n              (loop [acc [] rs xs]\n                (if (seq rs)\n                  (let [front (take-while #(= (first rs) %) rs)]\n                    (recur (conj acc (count front) (first front)) \n                           (drop-while #(= (first rs) %) rs)))\n                  acc)))]\n      (iterate sop-110 (sop-110 arg))))","user":"513e8141e4b02b2a3d8235c1"},{"problem":110,"code":"(fn pronounce [coll]\n  (let [f (fn [c] (mapcat #(list (count %) (first %)) (partition-by identity c)))]\n   (iterate f (f coll))))","user":"58dcf11ae4b0a4d5acaab6af"},{"code":"(fn f [s]\r\n  (let [t (loop [x s\r\n                 a []\r\n                 c (first s)\r\n                 n 0]\r\n            (if x\r\n              (if (= (first x) c)\r\n                (recur (next x) a c (inc n))\r\n                (recur x (-> a (conj n) (conj c)) (first x) 0))\r\n              (-> a (conj n) (conj c))))]\r\n    (lazy-seq (cons t (f t)))))","problem":110,"user":"4ff9d4e5e4b0678c553fc3b0"},{"code":"(fn conway [prev-seq]\n  (loop [cnt 0 prev nil cur (first prev-seq) rst (rest prev-seq) curseq []]\n    (cond\n     (and (nil? prev) (nil? cur)) (cons curseq (lazy-seq (conway curseq)))\n     (or (nil? prev) (= prev cur)) (recur (inc cnt) cur (first rst) (rest rst) curseq)\n     :else (recur 1 cur (first rst) (rest rst) (conj (conj curseq cnt) prev))\n    )\n  )\n)","problem":110,"user":"511cca27e4b00c2a1fa7ff7d"},{"code":"(fn pron[a]\n     (next (iterate \n      (fn [res] (mapcat #(vector (count %)(first %)) \n                  (partition-by identity res)))\n      a\n     )))","problem":110,"user":"50de11b2e4b061dbdced7217"},{"problem":110,"code":"(fn [s] (rest (iterate #(->> (partition-by identity %)\n                       (mapcat (fn [l] [(count l) (first l)]))\n                       (into []))\n                     s)))","user":"5a4de614e4b05d388ecb6bb1"},{"code":"(fn [a]\r\n  (rest (iterate\r\n   (fn [a]\r\n\t   (reduce concat\r\n\t\t   (map (fn [x] [(count x) (first x)])\r\n\t\t\t((fn [a l] \r\n\t\t\t   (if (empty? a)\r\n\t\t\t     l\r\n\t\t\t     (let [[c d] (split-with #(= % (first a)) a)]\r\n\t\t\t       (recur d (conj l c)))))\r\n\t\t\t a\r\n\t\t\t [])))) a)))","problem":110,"user":"507437c2e4b054001656acd0"},{"problem":110,"code":"(fn pronounce [ss]\n  (drop 1 (iterate #(nth\n                     (reduce (fn [val s]\n                               (let [[count curr-char curr-res] val]\n                                 (cond (= s curr-char) [(inc count) curr-char curr-res]\n                                       (and (not= s curr-char) (not (nil? curr-char))) [1 s (concat curr-res [count curr-char])]\n                                       (not= s curr-char) [1 s curr-res])))\n                             [0 nil []] (conj (vec %) nil)) 2)\n                   ss)))","user":"5f419985e4b0955706451fab"},{"problem":110,"code":"#(drop 1 (iterate (fn [coll] (let [go (fn [x coll cant acum] \n   (if (empty? coll) \n      (conj acum cant x)\n     (if (= x (first coll)) \n\t   (recur x (rest coll) (inc cant) acum)\n\t   (recur (first coll) (rest coll) 1 (conj acum cant x)))))]\n  (go (first coll) (rest coll) 1 []))) %))","user":"53fe1c3be4b0de5c418485f2"},{"code":"(fn [v] (letfn [(pron [v] (into [] (mapcat (fn [x] [(count x) (first x)]) (partition-by identity v) ) ) )]\n          (rest (iterate pron v))))","problem":110,"user":"50fbdacfe4b0d10d794c19f0"},{"code":"(fn [y]\n  (rest (iterate (fn [x]\n                   (reduce concat\n                           (map #(list (count %) (first %))\n                                (partition-by identity x)))) y)))","problem":110,"user":"4dc537fd535d8a4b2fd74282"},{"problem":110,"code":"(fn pronounce [s]\n  (let [reduced (remove #(zero? (first %))\n                        (reductions #(if (= (second %1) %2)\n                                       [(inc (first %1)) (second %1)]\n                                       [1 %2])\n                                    [0 nil] s))\n        it (flatten (reverse (reduce #(if (= (-> %1 last second) (-> %2 second)) %1 (conj %1 %2))\n                                  []\n                                  (reverse reduced))))]\n    (lazy-seq (cons it (pronounce it)))))","user":"53c649d3e4b00fb29b221297"},{"code":"(fn [s]\n    (let [f (fn [s] (reduce (fn [s k] (conj s (count k) (first k))) [] (partition-by identity s)))]\n      (iterate f (f s))))","problem":110,"user":"503b6995e4b07a1917cc34dd"},{"code":"(fn f [x]\n  (let [t (partition-by identity (flatten x))\n        pronunciation (map (fn [v] [(count v) (first v)] ) t)]\n    (cons (flatten pronunciation) (lazy-seq (f pronunciation)))\n    )\n  )","problem":110,"user":"523f0bbfe4b01c266ffa7f91"},{"problem":110,"code":"(fn [coll]\n  (drop 1 (iterate #(mapcat (fn [s] (list (count s) (first s)))\n                            (partition-by identity %)) coll)))","user":"549eb44fe4b0f3d1d8e70fa6"},{"code":"(fn pn [xs]\n  (let [p (mapcat #(vector (count %) (first %)) (partition-by identity xs))] \n    (cons p  (lazy-seq (pn p)))))","problem":110,"user":"5370f8ede4b0fc7073fd6ea2"},{"code":"(fn pronunciations [coll]\n  (rest (iterate (fn pronounce [items]\n                   (->> items\n                        (partition-by identity)\n                        (mapcat #(vector (count %)\n                                         (first %)))))\n                 coll)))","problem":110,"user":"530578ede4b0d8b024fd3760"},{"code":"(fn iter [s]\r\n        (lazy-seq \r\n          (let [res (flatten (map (fn [c] [(count c) (first c)]) \r\n                                  (partition-by identity s)))]\r\n            (cons res\r\n                  (iter res)))))","problem":110,"user":"4ef1ee67535dced4c769f219"},{"problem":110,"code":"(fn pronounce-seq [xs]\n   (lazy-seq\n    (let [pron (->> xs\n                    (partition-by identity)\n                    (map #(vector (count %) (first %)))\n                    (reduce concat))]\n      (cons pron (pronounce-seq pron)))))","user":"549dfe40e4b0f3d1d8e70f9a"},{"problem":110,"code":"(fn [inseq]\n   (rest\n   (map vec\n        (iterate\n         (fn [sequence]\n           (mapcat\n            (fn [chunk]\n              [(count chunk) (first chunk)])\n            (partition-by identity sequence)))\n         inseq\n         ))))","user":"5bf9d9b7e4b0bdcf453d15c4"},{"problem":110,"code":"(fn [s] (next (iterate #(mapcat (juxt count first) (partition-by identity \n%)) s)))","user":"59358f74e4b04f87174def52"},{"problem":110,"code":"(fn step [coll]\n    (let [pronunciation (loop [pronunciation []\n                               coll coll]\n                          (if-not (seq coll) pronunciation\n                                  (let [number (first coll)\n                                        identical (take-while #(= number %) coll)]\n                                    (recur  (-> (conj pronunciation (count identical))\n                                                (conj number))\n                                            (drop-while #(= number %) coll)))))]\n      (cons pronunciation (lazy-seq (step pronunciation)))))","user":"5d236215e4b02ea6f0fb6a09"},{"problem":110,"code":"(fn pro [x] (next (iterate (fn [y] (vec (flatten (map #(vector (count %) (first %)) (partition-by identity y)) ))) x)))","user":"550e52dbe4b06e50f9beb165"},{"problem":110,"code":"(fn [nums]\n  (letfn [(prns [nums]\n            (let [nums (reduce\n                         (fn [a b]\n                           (if (empty? a)\n                             [1 b]\n                             (let [i (- (count a) 2)\n                                   [h t] [(subvec a 0 i) (subvec a i)]\n                                   c (first t)\n                                   n (last t)]\n                               (if (= n b)\n                                 (conj h (inc c) n)\n                                 (conj a 1 b)))))\n                         []\n                         nums)]\n              (lazy-seq\n                (cons nums (prns nums)))))]\n    (prns nums)))","user":"58bb218be4b0888cdc949cf4"},{"code":"(fn counting-seq [cs]\n  (letfn [(counting [a]\n            (loop [xs a\n                   result []]\n              (if (seq xs)\n                (let [current (first xs)\n                      [sublist remaining] ((juxt take-while drop-while) #(= % current) xs)]\n                  (recur remaining (into result [(count sublist) current])))\n                result)))]\n    (let [counted (counting cs)]\n      (cons counted (lazy-seq (counting-seq counted))))))","problem":110,"user":"5102ac9de4b00c483ae176fa"},{"code":"(fn [s] (rest (iterate #(flatten (map (juxt count first) (partition-by identity %))) s)))","problem":110,"user":"514457fbe4b0b4fb4ace5f43"},{"problem":110,"code":"(fn [s]\n  (rest (iterate #(mapcat (juxt count first)\n                     (partition-by identity %)) s)))","user":"5405ae2be4b0addc1aec6671"},{"problem":110,"code":"(fn pron [seq]\n         (let [new-seq  (apply concat (map (fn [x] [(count x) (first x)]) (partition-by identity seq)))]\n           (lazy-seq (cons new-seq (pron new-seq)))))","user":"607d6bc1e4b03d835a6eaecc"},{"code":"(fn pronounce [coll]\r\n  (letfn [(f [coll]\r\n             (flatten\r\n               (map (fn [x] [(count x) (first x)])\r\n                     (partition-by identity coll))))]\r\n    (iterate f (f coll))))","problem":110,"user":"4dc97aec535d5973398f9284"},{"code":"(fn f [coll]\n  (rest\n  (iterate\n    #(loop [acc []\n            items %]\n       (if (empty? items)\n         acc\n         (let [fst (first items)\n               equiv (fn [x] (= fst x))]\n           (recur\n             (conj acc (count (take-while equiv items)) fst)\n             (drop-while equiv items)))))\n    coll)))","problem":110,"user":"51195e77e4b055cfb310d499"},{"problem":110,"code":"(fn p [s]\n  (letfn [ (nxt [ss] (mapcat #(list (count %) (first %) ) (partition-by identity ss) ))\n           ]\n    (cons (nxt s) (lazy-seq (p (nxt s))))\n    ))","user":"53c1ce3ee4b00fb29b221268"},{"problem":110,"code":"(fn [col] \n  (rest \n   (iterate (fn [x] \n              (mapcat \n               \t(fn [y] \n                  \t[(count y) (first y)]) \n               \t(partition-by identity x)))\n            col)))","user":"4ebbff41535dfed6da9c6d78"},{"problem":110,"code":"(fn f [x]\n  (lazy-seq\n    (let [head (mapcat #(vector (count %) (first %))\n                       (partition-by identity x))]\n      (cons head (f head)))))","user":"52c4af71e4b0c2d177d620e1"},{"problem":110,"code":"(fn pronunciation-seq [coll]\n  (letfn [(pronunciation [coll]\n            (let [partitioned-coll (partition-by identity coll)\n                  counts           (map count partitioned-coll)\n                  elts             (map first partitioned-coll)]\n              (mapcat vector counts elts)))]\n    (cons (pronunciation coll)\n          (lazy-seq (pronunciation-seq (pronunciation coll))))))","user":"53fd66a4e4b0de5c418485e3"},{"problem":110,"code":"(fn [coll]\n  (letfn [(iterate-fn [coll]\n            (let [parts (partition-by identity coll)]\n              (reduce #(conj %1 (count %2) (first %2)) [] parts)))]\n    (rest (iterate iterate-fn coll))))","user":"5c13da47e4b01240ff5671a6"},{"problem":110,"code":"(fn f [x]\n    (let [e (reduce #(into %1 [(count %2) (first %2)]) [] (partition-by identity x))]\n        (cons e (lazy-seq (f e)))))","user":"548b7db8e4b0e286459a11fd"},{"problem":110,"code":"(fn _ [coll]\n  (let [result (mapcat (fn [coll'] [(count coll') (first coll')]) (partition-by identity coll))]\n    (lazy-seq (cons result (_ result)))))","user":"5213d7aae4b0961f15ac4d72"},{"problem":110,"code":"#(rest (iterate (fn [arg]\n                  (->> arg (partition-by identity) (map (juxt count first)) flatten)\n                  )\n                %))","user":"56f7ecdfe4b08e7d20b96834"},{"problem":110,"code":"(fn pronunciations [s]\n  (lazy-seq\n   (let [pr (mapcat (juxt count first) (partition-by identity s))]\n     (cons pr (pronunciations pr)))))","user":"4f3e5e87e4b0e243712b1f83"},{"problem":110,"code":"(fn sp[zfz]\n  ( loop [ x zfz res [] ]\n    (if (empty? x)\n      (lazy-seq (cons res (sp res)))\n      (let [ f (first x) ]\n        (let [ h (take-while #(= % f) x) t (drop-while #(= % f) x) ]\n          (recur t (concat res [(count h) f]))\n          )\n        )\n      )\n    )\n  )","user":"5b3aa98be4b02d533a91bbca"},{"problem":110,"code":"(fn [s]\n  (rest (iterate\n         (fn pron [s]\n           (when (seq s)\n             (let [fs (first s)\n                   nfs (count (take-while #(= % fs) s))\n                   r (drop nfs s)]\n               (concat [nfs fs] (pron r)))))\n         s)))","user":"5e5b8d92e4b0fd0acd158658"},{"problem":110,"code":"(fn f\n  [col]\n  (rest\n   (iterate\n    (fn [col]\n      (->> col\n          (partition-by identity)\n          (mapcat #(list (count %)\n                          (first %)))))\n   col)))","user":"5da7176ae4b000c986472c13"},{"code":"(fn pro [coll]\n  (letfn [(generate-next [coll] (flatten (map (fn [c] [(count c) (first c)]) (partition-by identity coll))))]\n   (lazy-seq \n    (let [next-coll (generate-next coll)] \n      (cons next-coll (pro next-coll))\n    ))))","problem":110,"user":"52fcfeeee4b047fd55837027"},{"code":"(fn [p]\n  (letfn [(gp [q] (flatten (map (fn [x] [(count x) (first x)])\n                                (partition-by identity q))))]\n    (iterate gp (gp p))))","problem":110,"user":"500cb910e4b05f7c30cfa698"},{"code":"(fn pron [src]\n   \t(let [x (mapcat #(reverse(into[](first(frequencies %)))) (partition-by identity src))]\n     (cons x (lazy-seq(pron x)))\n\t  \n     )\n   )","problem":110,"user":"5274eb56e4b03e8d9a4a74bb"},{"code":"(fn [s]\n  (letfn [(f [s] (reduce #(conj % (count %2) (first %2)) [] (partition-by identity s)))]\n    (next (iterate f s))))","problem":110,"user":"4ec5aa1f535d6d7199dd36b0"},{"code":"(fn [s]\n  (drop 1 (iterate (fn [s] \n                     (mapcat (juxt count first) \n                             (partition-by identity s))) s)))","problem":110,"user":"514fd753e4b0b449e54b8e00"},{"problem":110,"code":"(fn [x] (rest (iterate (fn [v] (mapcat (fn [vv] [(count vv) (first vv)])\n                              (partition-by identity v)))\n                       x)))","user":"52173464e4b082aa80a88c75"},{"problem":110,"code":"(fn [y] \n  (->> y\n       (iterate\n        (fn [x] (->> x \n                     (partition-by identity) \n                     (mapcat (juxt count first)))))\n       rest))","user":"5066003ee4b0313a384e5647"},{"problem":110,"code":"(fn f [xs]\n  (let [p (->> xs\n               (partition-by identity)\n               (map #(vector (count %) (first %)))\n               (flatten))]\n    (cons p (lazy-seq (f p)))))","user":"5ccb0bbee4b0ccb06196287c"},{"code":"(fn pro [ns]\n  (let [p (mapcat (juxt count first) (partition-by num ns))]\n    (cons p (lazy-seq (pro p)))))","problem":110,"user":"4e8e8c24535d65386fec2143"},{"code":"(fn sp [s] \n    (letfn [\n            (nextn [ cur] \n                   (loop [ acc [] remains cur ]\n                     (if (empty? remains)\n                       (reverse acc)\n                       (let \n                         [fst (first remains)\n                          cnt (count (take-while #(= fst %) remains))\n                          newremains (drop-while #(= fst %) remains)]\n                         (recur (cons fst (cons cnt acc)) newremains)\n         ))))] \n      (let [nextproc (nextn s)]\n        (cons nextproc (lazy-seq (sp nextproc)))\n        )))","problem":110,"user":"50956c2be4b087f34d351ab2"},{"code":"(fn prons\r\n  [lista]\r\n\t(lazy-seq\r\n\t\t(let [pron (mapcat (fn [repeats] [(count repeats) (first repeats)]) \r\n\t\t\t\t\t\t\t (partition-by identity lista))]\r\n\t\t\t(cons pron (prons pron)))))","problem":110,"user":"4e8a0c82535d3e98b802328d"},{"problem":110,"code":"(fn [sq]\n  (rest (iterate (fn [x] (mapcat\n\t (fn [p] \n\t\t((juxt count first) p)) (partition-by identity x))) sq)))","user":"5578f292e4b05c286339e08f"},{"problem":110,"code":"(fn pron [ls]\n  (let [get-v (fn f[xs]\n                (if (empty? xs)\n                  []\n                  (let [fv (first xs)\n                        fl (take-while #(= fv %) xs)\n                        len (count fl)]\n                   (concat [len fv] (f (drop len xs))))))\n        v (get-v ls)]\n    (lazy-seq\n     (cons v (pron v)))))","user":"5488537be4b0e286459a11cf"},{"code":"(comp rest (partial iterate (fn [s]\r\n  (mapcat (fn [s] [(count s) (first s)]) (partition-by identity s))\r\n  )))","problem":110,"user":"4f1b0ab3535d64f603146474"},{"code":"(fn pronunciations [c]\n  (let [pronounce (fn [c]\n                    (mapcat #(vector (count %) (first %))\n                            (partition-by identity c)))]\n    (iterate pronounce (pronounce c))))","problem":110,"user":"4f7431d2e4b044e54cd9a8f7"},{"problem":110,"code":"(fn seq-of-pronounciations [se]\n  (drop 1 (iterate (fn [curr-pronounciation]\n                     (flatten\n                       (map (fn [row]\n                              (vector (count row)\n                                      (first row)))\n                            (partition-by identity curr-pronounciation))))\n                   se)))","user":"5fbf6fe7e4b0ad6fc3476147"},{"code":"(letfn [\r\n  \t(pronounce [ns]\r\n\t\t\t(when (seq ns)\r\n\t\t\t\t(let [[these those] (split-with (partial = (first ns)) ns)]\r\n\t\t\t\t\t(concat [(count these) (first these)] (pronounce those)))))]\r\n\t(fn pronounce-all [ns]\r\n\t\t(lazy-seq\r\n\t\t\t(let [p (pronounce ns)]\r\n\t\t\t\t(concat [p] (pronounce-all p))))))","problem":110,"user":"4dd6d6a0535d2dad7130b5ca"},{"problem":110,"code":"(fn [coll] \n  (drop 1 (iterate #(mapcat (juxt count first) \n                            (partition-by identity %))\n                   coll)))","user":"5591cc56e4b0604b3f94d582"},{"problem":110,"code":"(fn pron [c]\n  (let [nc (mapcat \n   \t    \t #(list (count %) (first %)) \n        \t (partition-by identity c))]\n    (lazy-seq (cons nc (pron nc)))))","user":"59f91b99e4b0ca45a743a33a"},{"problem":110,"code":"(fn p [y]\n   (let [pronounce (fn [x]\n                   (loop [x x, new '()]\n                     (if (empty? x) new\n                       (let [n (take-while #(= (first x) %) x)] \n                         (recur (drop (count n) x) (concat new (list (count n) (first x))))))))]\n     (rest (iterate pronounce y))))","user":"54b54d1be4b05787c3b1639c"},{"code":"(fn pr [c] \n  (let\n    [p (mapcat \n        (juxt count first) \n        (partition-by list c))]\n    (lazy-seq (cons p (pr p)))))","problem":110,"user":"4f991ec1e4b0dcca54ed6cfb"},{"code":"(fn pronounce [coll]\n  (let [p (mapcat #(vector (count %) (first %))\n                  (partition-by identity coll))]\n       (lazy-seq (cons p (pronounce p)))))","problem":110,"user":"500900dee4b0144d4f561e42"},{"code":"(fn h [ll]\n  (let [g (fn g [l]\n  (if (empty? l) l\n    (let [ x (first l)\n          [uno dos] (split-with #(= % x) l)]\n      (concat (list (count uno) x)\n              (g dos)))))]\n (iterate g (g ll))))","problem":110,"user":"4f04a06d535dcb61093f6bd9"},{"problem":110,"code":"(fn sop [coll]\n  (lazy-seq\n   (let [result \n         (flatten (for [x (partition-by identity coll)] [(count x) (first x)]))]\n   (cons result (sop result)))))","user":"574abbfbe4b02ea114799200"},{"code":"(fn [x]\n  (rest \n   (iterate #(mapcat \n              (fn [k] [(count k) (first k)]) \n              (partition-by identity %)) \n            x)))","problem":110,"user":"500aa15ee4b03d00572d2d76"},{"code":"(fn proseq [s]\n  (let [step (vec (mapcat #(vector (count %) (first %)) (partition-by identity s)))]\n    (cons step (lazy-seq (proseq step)))))","problem":110,"user":"51d96ad0e4b02ceefd94774f"},{"problem":110,"code":"(fn pronounce-lazy\n  [llist]\n  (next (iterate #(flatten (into [] (for [itms (partition-by identity %)]\n                                 [(count itms) (first itms)]))) llist)))","user":"561ca6ebe4b064ca9f4b169c"},{"problem":110,"code":"(fn p [v] \n   (lazy-seq\n    (let [x (mapcat identity \n                    (map \n                     #(cons (count %) (list (first %))) \n                     (partition-by identity v)))]\n      (cons x (p x)))))","user":"53da8fede4b0e771c30254a3"},{"problem":110,"code":"(fn xx[xs]\n          (let [fn1 (fn [xs] (loop [res [] xs xs]\n                      (if (empty? xs)\n                        res\n                        (let [nn (first xs)\n                              [f l] (split-with #(= nn %) xs)\n                              cc (count f)\n                              ]\n                          (recur (conj (conj res cc) nn) l)\n                          ))\n                      ))]\n            (cons (fn1 xs) (lazy-seq (xx (fn1 xs))))\n            )\n          )","user":"533c2605e4b0e30313ee6cd7"},{"problem":110,"code":"(fn prononunce-sequence [nums]\n     (lazy-cat\n       (let [new-nums (mapcat #(vector (count %) (first %)) (partition-by identity nums))]\n         (cons new-nums (prononunce-sequence new-nums)))\n       )\n     )","user":"55e6c3f5e4b050e68259b48c"},{"problem":110,"code":"(fn aa [coll]\n  (let [p (fn [x]\n            (loop [c x\n                   e (first x)\n                   i 1]\n              (if (not= (second c) e)\n                [e i (rest c)]\n                (recur (rest c)\n                       (first c)\n                       (inc i)))))\n        ps (fn [y]\n             (loop [[e i b] (p y)\n                    r []]\n               (if (empty? b)\n                 (conj r i e)\n                 (recur (p b)\n                        (conj r i e)))))]\n    (lazy-seq (cons (ps coll) (aa (ps coll))))))","user":"5541fa50e4b0a04f79299515"},{"code":"(fn pronounce [sq]\n  (let [x (mapcat #(vector (count %) (first %)) (partition-by identity sq))]\n    (lazy-seq (cons x (pronounce x)))))","problem":110,"user":"5300158ae4b0d8b024fd370f"},{"problem":110,"code":"(fn ! [a-vec]\n  (letfn [(auxi [v]\n                (->> (partition-by identity v)\n                     (map #(vector (count %) (first %)))\n                     (flatten)))]\n    (lazy-seq\n     (let [n (auxi a-vec)]\n       (cons n (! n))))))","user":"59225498e4b09b4ee5954c8c"},{"problem":110,"code":"(fn [seq]\n  (next (iterate (fn [seq]\n                 \t(mapcat #(identity [(count %) (first %)]) (partition-by identity seq)))\n              \t seq)))","user":"562cb7cfe4b0a45d2ff83009"},{"problem":110,"code":"(fn [n] (rest (iterate (fn [s] (apply vector(mapcat #(vector (count %)(first %)) (partition-by identity s)))) n)))","user":"5457e5f1e4b01be26fd74613"},{"problem":110,"code":"(fn pronounce [coll]\n  (let [step (fn [coll]\n               (->> coll\n                    (partition-by identity)\n                    (mapcat #(list (count %) (first %)))))\n        new-coll (step coll)]\n    (lazy-seq (cons new-coll (pronounce new-coll)))))","user":"59f78b49e4b0ca45a743a30e"},{"problem":110,"code":"(fn [col]\n  (->> col\n       (iterate #(->> (partition-by identity %)\n                      (mapcat (fn [a] [(count a) (first a)]))))\n       (drop 1)))","user":"567d132ee4b05957ce8c61c3"},{"problem":110,"code":"(fn pr [x]\n  (let [y (partition-by identity x)\n       z (reduce #(conj %1 (count %2) (first %2)) [] y)]\n  (lazy-seq (cons z (pr z)))\n    ))","user":"5a244240e4b0ff51aa4b32e9"},{"problem":110,"code":"#(letfn [(p [[m & _ :as xs]] \n            (if (empty? xs) () \n              (let [[ms xs'] (split-with #{m} xs)] \n                (lazy-cat [(count ms) m] (p xs')))))]\n  (iterate p (p %)))","user":"5566d812e4b0c656e3ff1837"},{"code":"(fn [coll]\r\n  (letfn [(pro [a x]\r\n            (let [[d n] a]\r\n              (if (= d x)\r\n                (conj (drop 2 a) (inc n) x)\r\n                (conj a 1 x))))\r\n          (pro-seq [coll]\r\n            (let [next (vec (reverse (reduce pro () coll)))]\r\n              (lazy-seq (cons next (pro-seq next)))))]\r\n    (pro-seq coll)))","problem":110,"user":"4f969214e4b0dcca54ed6cdd"},{"problem":110,"code":"(fn pronuc\n  [v]\n  (let [gv (partition-by identity v)\n        nv (interleave (map count gv) (map first gv))]\n    (lazy-seq (cons nv (pronuc nv)))))","user":"5b008bcae4b0cc2b61a3bd3d"},{"code":"(fn [coll]\n  (drop 1\n    (iterate\n      (fn [coll] \n        (->> coll \n          (partition-by identity) \n          (reduce #(conj %1 (count %2) (first %2)) [])))\n      coll)))","problem":110,"user":"5033a1fbe4b062bc5d7ae155"},{"code":"(fn [x]\n  (next\n    (iterate\n      #(flatten\n         (map\n           (fn [l]\n             [(count l) (first l)])\n           (partition-by identity %)))\n      x)))","problem":110,"user":"4ee82539535d93acb0a66878"},{"code":"(fn i [c]\n  (rest\n   (iterate (fn [c] (mapcat #(list (count %) (first %))\n                            (partition-by identity c))) c)))","problem":110,"user":"52c25645e4b07a9af579237d"},{"code":"(fn [s]\n  (let [p (fn [s]\n            (->> s\n                 (partition-by identity)\n                 (mapcat #(list (count %) (first %)))))]\n    (drop 1 (iterate p s))))","problem":110,"user":"4ff3df0fe4b0678c553fc355"},{"problem":110,"code":"(fn f [s]\n  (let [n (mapcat #(vector (count %) (first %)) (partition-by identity s))]\n    (cons n (lazy-seq (f n)))))","user":"4fc8f671e4b0ee37620e1840"},{"problem":110,"code":"(fn pronunciations [xs]\n    (let\n      [\n        xs'\n        (mapcat\n          (fn [ps]\n            [\n              (count ps)\n              (first ps)\n            ]\n          )\n          (partition-by identity xs)\n        )\n      ]\n      (lazy-seq\n        (cons\n          xs'\n          (pronunciations xs')\n        )\n      )\n    )\n  )","user":"5784e177e4b0ebec4cfb74cf"},{"problem":110,"code":"(fn pron [xs]\n    (lazy-seq\n      (let [p (mapcat (juxt count first) (partition-by identity xs))]\n        (cons p (pron p)))))","user":"58b51e05e4b0ebc645576d4c"},{"code":"(fn [sq]\n   (rest (iterate \n     (fn [s](flatten (map #(vector (count %) (first %)) \n            (partition-by identity s)))) sq)))","problem":110,"user":"4dcfbc44535d5973398f92a7"},{"code":"(fn p [l]\n  (lazy-seq\n   (let [s (apply concat (for [subl (partition-by identity l)]\n                              [(count subl) (first subl)]))]\n     (cons s (p s)))))","problem":110,"user":"50b1d166e4b03ea880433554"},{"problem":110,"code":"(fn seq-of-pron\n  [coll]\n  (let [result-seq (fn [coll]\n                     (reduce (fn [my-list item]\n                               (conj my-list (count item) (first item))) [] (partition-by identity coll)))]\n    (lazy-seq (cons (result-seq coll) (seq-of-pron (result-seq coll))))))","user":"60396c95e4b0d5df2af222f4"},{"code":"(fn __ [coll]\n  (let [new-coll (->> coll\n                   (partition-by identity)\n                   (mapcat #(do [(count %) (first %)]))\n                   (into [])\n                   )]\n    (cons new-coll (lazy-seq (__ new-coll)))))","problem":110,"user":"52828298e4b0757a1b17145b"},{"code":"(fn t [l] \n  (let [f (mapcat (juxt count first) (partition-by identity l))]\n   (cons f (lazy-seq (t f)))))","problem":110,"user":"4dbdab4e535d020aff1edf49"},{"problem":110,"code":"(fn pron [i]\n  (next (iterate (fn [x] (->> x\n                             (partition-by identity)\n                             (mapcat frequencies)\n                             (mapcat reverse))) i)))","user":"585dbe41e4b0f14aab7c879f"},{"problem":110,"code":"(fn [sq]\n  (letfn [(f [sq] (mapcat #(vector (count %) (first %)) (partition-by identity sq)))]\n    (drop 1 (iterate f sq))))","user":"56903cb9e4b0dcc4269f40eb"},{"code":"#(rest (iterate (fn [n] \n  (mapcat (fn [x] [(count x) (first x)]) \n    (partition-by (fn [x] x) n))) %))","problem":110,"user":"4dada16fc9a9d6ed2699dc57"},{"problem":110,"code":"(fn [arg]\n  (drop 1 (iterate (fn [xs]\n                     (mapcat #(vector (count %) (first %))\n                             (partition-by identity xs))) arg)))","user":"5adf5f9be4b0837691e92c33"},{"problem":110,"code":"(fn [s] \n  (rest (iterate \n          (fn [s]\n           (let [x (partition-by identity s)\n                 x (for [[i :as s] x] [(count s) i])]\n            (apply concat x)))\n         s)))","user":"533a2f7be4b0e30313ee6cb8"},{"problem":110,"code":"(fn pronounce [n]\n  (let [parts (partition-by identity n)\n        newN (flatten (map (fn [x] [(count x) (first x)]) parts))]\n    (lazy-seq (cons newN (pronounce newN)))))","user":"57986b76e4b039eba2ecb116"},{"code":"(fn pronunciations [s]\n           (let [pronunciation (mapcat #(list (count %) (first %)) (partition-by identity s))]\n             (lazy-seq (cons pronunciation (pronunciations pronunciation)))))","problem":110,"user":"4e89f46c535d3e98b8023288"},{"problem":110,"code":"(fn f [xs]\n  (lazy-seq\n   (let [xss (mapcat #(vector (count %) (first %)) (partition-by identity xs))]\n        (cons xss (f xss)))))","user":"56795deae4b05957ce8c6187"},{"code":"(fn pronounce [nums]\n  (let [result (mapcat (fn [[x :as v]] [(count v) x]) (partition-by identity nums))]\n    (lazy-cat [result] (pronounce result))))","problem":110,"user":"53307da1e4b019098a6f8b5e"},{"code":"(fn [x]\n  (drop 1 (iterate (fn [x]\n    (vec (mapcat #(vector (count %) (first %))\n            (partition-by identity x)))) x)))","problem":110,"user":"50acbd15e4b071b89ef26234"},{"code":"(fn lp[a]\n   (lazy-seq\n    (when-let [s (flatten (for [x (partition-by identity a)] [(count x) (first x)])) ]\n      (cons s (lp s)))))","problem":110,"user":"4fb3dd1ee4b081705acca2a5"},{"code":"(fn pron[s]\n  (rest\n    (iterate\n\t    (fn pronounce[se] \n\t      (mapcat #(vector (count %) (first %)) (partition-by identity se))\n\t    )\n\t    s\n\t  )\n  )\n)","problem":110,"user":"4e9de526535dbda64a6f6b8e"},{"problem":110,"code":"(fn xx [coll]\n  (let [p (mapcat (juxt count first )\n                       (partition-by identity coll))]\n   (lazy-seq (cons p (xx p)))))\n;; iterate is better i think","user":"56102f50e4b05f002753df6b"},{"problem":110,"code":"(fn [coll]\n  (letfn [(pron [coll]\n                (->> coll\n                     (partition-by identity)\n                     (mapcat (fn [x] [(count x) (first x)]))))]\n    (iterate pron (pron coll))))","user":"5cc6b4bfe4b0ccb061962827"},{"problem":110,"code":"(let [pron (fn [vs]\n               (loop [vs vs, acc []]\n                 (if (seq vs)\n                   (let [v (first vs)\n                         cnt (->> vs (take-while #(= v %)) count)]\n                     (recur (drop cnt vs) (conj acc cnt v)))\n                   acc)))\n        f (fn [vs]\n            (->> vs\n                 (iterate pron)\n                 rest))]\n    f)","user":"53684a2fe4b0243289761e8c"},{"code":"#(rest (iterate (fn [sq]\n        (mapcat (fn [a] (list (count a) (first a)))\n        (partition-by identity sq))) %))","problem":110,"user":"4fc0853ae4b081705acca327"},{"problem":110,"code":"(fn [x] (drop 1 (iterate (fn [x] (vec (mapcat #(vector (count %) (first %) ) (partition-by identity x)))) x )))","user":"4fd11a93e4b04c3a95aa040a"},{"problem":110,"code":"(fn seq-of-pronounciations [coll]\n  (rest\n   (iterate (fn [coll]\n              (if (empty? coll)\n                []\n                (loop [[c & cs] (rest coll)\n                       n 1\n                       v (first coll)\n                       res []]\n                  (cond\n                    (not c) (conj res n v)\n                    (= v c) (recur cs (inc n) v res)\n                    :else (recur cs 1 c (conj res n v))))))\n            coll)))","user":"5d6042f2e4b0c9e5857d5006"},{"problem":110,"code":"(fn iter [c]\n    (lazy-seq\n     (let [pronun (->> (partition-by identity c)\n                       (mapcat #(vector (count %) (first %))))]\n       (cons pronun (iter pronun)))))","user":"591ad160e4b09b4ee5954bdf"},{"code":"(fn [s]\n  (drop 1 (iterate (fn [s]\n                     (mapcat (juxt count first)\n                             (partition-by identity s)))\n                   s)))","problem":110,"user":"50705072e4b07bd6ad9b9f27"},{"problem":110,"code":"(fn p110\n  [coll]\n  (let [tiger (fn p110\n                [coll]\n                (let [x (first coll)\n                      a (take-while #(= x %) coll)\n                      b (drop-while #(= x %) coll)]\n                  (if x\n                    (conj (p110 b)\n                          x (count a))\n                    '())))]\n    (iterate tiger (tiger coll))))","user":"520cb8c4e4b0b022ef140c9a"},{"problem":110,"code":"(fn [c]\n  (letfn [(p [c] (flatten (map #((juxt count first) %) (partition-by identity c))))]\n    (iterate p (p c))))","user":"586615e6e4b0f14aab7c8858"},{"problem":110,"code":"(letfn [(f [s] (lazy-seq (let [n (mapcat (juxt count first) (partition-by identity s))] (cons n (f n)))))] f)","user":"54f0d3fde4b024c67c0cf8a6"},{"problem":110,"code":"(fn f [init] \n  (let [sig (fn [v] (flatten (map #(vector (count %1) (first %1)) (partition-by identity v))))]\n    (rest (iterate sig init))\n    )\n  )","user":"54e51c7be4b024c67c0cf7f7"},{"problem":110,"code":"(fn pronounce [s]\n  (let [next-fn (fn [s] (into []\n     (mapcat (fn [s] [(count s) (first s)])\n             (partition-by identity s))))\n        next-val (next-fn s)]\n    (cons next-val (lazy-seq (pronounce next-val)))))\n\n;; I like dan7es's solution:\n;; (comp rest (partial iterate\n;;    #(mapcat (juxt count first)\n;;             (partition-by identity %))))","user":"5fb68f09e4b08cb800c85b58"},{"code":"(fn [xs] (let\n    [pron \n        (fn [cs]\n            (mapcat #(list (count %) (first %)) (partition-by identity cs)))]\n    (iterate pron (pron xs))))","problem":110,"user":"4f0e995e535d0136e6c22326"},{"problem":110,"code":"(fn pronunciations [s]\n  (next (iterate #(mapcat (juxt count first)\n                          (partition-by identity %))\n                 s)))","user":"5ab564f8e4b073f177442639"},{"code":"(fn f \n  ([i] (f i []))\n  ([i p]\n    (if (empty? i)\n      (lazy-cat [p] (f p []))\n      (let [n (first i)\n      [c r] (split-with #(= n %) i)]\n        (recur r (conj p (count c) n))))))","problem":110,"user":"4da3e51330acd6ed10482a68"},{"code":"(fn f [s]\n  (let [t  (reduce #(conj % (count %2) (first %2)) [] (partition-by identity s))]\n    (lazy-seq (cons t (f t)))))","problem":110,"user":"4f1d1d95535d64f603146488"},{"code":"#(rest\n  (iterate\n    (fn [l]\n      (flatten\n        (map\n          (fn [x] (list (count x) (first x)))\n          (partition-by identity l))))\n    %))","problem":110,"user":"4fb1325de4b081705acca276"},{"problem":110,"code":"(fn\n  [v]\n  (rest (iterate (fn [x]\n                   (mapcat (juxt count first)\n                           (partition-by identity x)))\n                 v)))","user":"4daeabf6edd6309eace4d15c"},{"code":"(fn pron [xs]\n  (let [process #(mapcat  (juxt count first) \n                          (partition-by identity %))]\n    (rest (iterate process xs))))","problem":110,"user":"53691dc7e4b0243289761e97"},{"code":"(fn [s]\n  (rest\n    (iterate\n      (fn nxt [s]\n        (if (empty? s) []\n          (let [\n              f (first s) \n              [n r] (split-with #(= % f) s)]\n            (concat [(count n) f] (nxt r))))) s))\n  )","problem":110,"user":"50901b2ee4b0ea685a20f774"},{"problem":110,"code":"(fn f [ns]\n  (lazy-seq\n    (let [x (mapcat #(vector (count %) (first %)) (partition-by identity ns))]\n      (cons x (f x)))))","user":"56d68cbae4b0ea9b8538f7cd"},{"problem":110,"code":"(fn pro [coll]\n  (cons (reduce #(concat %1 (cons (count %2) (list (first %2)))) () (partition-by identity coll))\n        (lazy-seq (pro (reduce #(concat %1 (cons (count %2) (list (first %2)))) () (partition-by identity coll))))))","user":"53a1b5c8e4b0ca733b9744c1"},{"problem":110,"code":"(fn [c]\n  (drop 1\n\t(iterate\n   \t\t(fn [s] (into [] (flatten (map #(if (= 1 (count %)) (into [1] %) [(count %) (first %)]) (partition-by identity s)))))\n      \tc\n    )\n   )\n)","user":"5676af21e4b05957ce8c6158"},{"problem":110,"code":"(fn pro [s]\n  (letfn [(nextpro [s]\n                   (reduce (fn [acc v] (conj acc (count v) (first v))) [] (partition-by identity s))\n                   )]\n    (let [val (nextpro s)]\n      (lazy-cat [val] (pro val)))\n    )\n  )","user":"5592bf9fe4b0c79f6e1db933"},{"code":"(fn cnt [A]\n  (letfn [\n    (step [A]\n      (loop [B (rest A), counting (first A), \n              N 1, result []]\n        (if (empty? B)\n          (conj result N counting)\n          (let [p (= (first B) counting)]\n            (recur (rest B) (first B) \n              (if p (inc N) 1) \n              (if p result (conj result N counting)))))))]\n\n  (let [B (step A)]\n    (lazy-seq (cons B (cnt B))))))","problem":110,"user":"4faa9593e4b081705acca1f9"},{"code":"(fn [coll]\n  (let [step (fn [c]\n               (mapcat\n                (fn [x] [(count x) (first x)])\n                (partition-by identity c)))]\n  (iterate step (step coll))))","problem":110,"user":"504f57c7e4b0a02f9cffde71"},{"problem":110,"code":"(fn makeprons [icol]\n    (let [nextpron       (loop [col   (rest icol)\n                                curr  (first icol)\n                                count 1\n                                res   [] ]\n                           (cond\n                             (empty? col) (-> res (conj count) (conj curr))\n                             (= curr (first col)) (recur (rest col) curr (inc count) res)\n                             :else  (recur (rest col) (first col) 1 (-> res (conj count) (conj curr)))\n                             )\n                           )\n          ]\n      (lazy-seq (cons nextpron (makeprons nextpron))))\n    )","user":"57aa290de4b0b8559636fc65"},{"problem":110,"code":";; http://www.4clojure.com/problem/110\n(fn pronunciations\n  [coll]\n  (loop [in coll\n         current []\n         out []]\n    (if (empty? in)\n      (let [out (if (empty? current)\n                  out\n                  (vec (concat out [(count current) (first current)])))]\n        (lazy-seq (cons out (pronunciations out))))\n      (let [n (first in)\n            r (rest in)]\n        (if (empty? current)\n          (recur r (conj current n) out)\n          (let [l (last current)]\n            (if (= l n)\n              (recur r (conj current n) out)\n              (recur r [n] (vec (concat out [(count current) (first current)]))))))))))","user":"5c92105ce4b048ec896c59f7"},{"problem":110,"code":"(fn [start]\n  (letfn [(step [xs]\n            (loop [xs xs, acc []]\n              (if (seq xs)\n                (let [x (first xs)\n                      [ns rest] (split-with (partial = x) xs)]\n                  (recur rest (conj acc (count ns) x)))\n                acc)))]\n    (rest (iterate step start))))","user":"505aa653e4b021387fb89857"},{"problem":110,"code":"(fn pron [xs]\n  (->> xs\n       (partition-by identity)\n       (mapcat (juxt count first))\n       (#(cons % (lazy-seq (pron %))))))","user":"5ab16992e4b073f1774425c4"},{"problem":110,"code":"(fn [c]\n  (let [fun-fn (fn [coll]\n                 (loop [result []\n                        [f & r :as c] coll]\n                   (if (not-empty c)\n                     (recur (conj result (count (take-while #(= f %) c)) f) (drop-while #(= f %) c))\n                     result)))]\n    (reductions #(%2 %) (fun-fn c) (repeat fun-fn))))","user":"5835cb06e4b089d5ab817cea"},{"problem":110,"code":"(fn [nums]\n  (let [iterator (fn [coll]\n                   (->> coll\n                        (partition-by identity)\n                        (mapcat #(vector (count %) (first %)))))]\n    (rest (iterate iterator nums))))","user":"58d2af83e4b03c36ff7e5907"},{"problem":110,"code":"(fn f [s]\n\t(let [x (flatten (map #(list (count %) (first %)) (partition-by (fn [x] x) s)))]\n\t\t(lazy-seq (cons x (f x)))))","user":"57ccedaae4b0c746388ab88e"},{"problem":110,"code":"(fn ff [xs]\n    (lazy-seq\n     (let [xs (->> xs\n                   (reduce #(let [n %2]\n                              (if (= (last %1) n)\n                                (conj (vec (butlast (butlast %1)))\n                                      (inc (last (butlast %1))) n)\n                                (conj %1 1 n))) []))]\n       (cons xs (ff xs)))))","user":"5c995fa4e4b048ec896c5a96"},{"problem":110,"code":"(fn [s]\n  (rest\n    (iterate\n      #(mapcat\n         (juxt count first)\n         (partition-by identity %))\n      s)))","user":"4eb70649535d7eef30807373"},{"code":"(fn [b]\n  (letfn [(get-next [x] (mapcat #(list (count %) (first %)) (partition-by identity x)))]\n    (iterate get-next (get-next b))))","problem":110,"user":"532418f3e4b09d4e7a9b54d8"},{"problem":110,"code":"(fn pron\n  ([v]\n   (lazy-seq\n    (let [n (reduce #(concat % ((juxt count first) %2))\n              []\n      \t   \t  (partition-by identity v))]\n    (cons\n      n\n      (pron n))))))","user":"4dd6d7ee535d2dad7130b5cb"},{"code":"(fn[num-seq]\n  (letfn [(pron[num-seq]\n    (let [p-seq (partition-by identity num-seq)\n          next-seq (interleave (map count p-seq) (map first p-seq))]\n      (cons (seq next-seq) (lazy-seq (pron next-seq)))))]\n         (pron num-seq)))","problem":110,"user":"4e58bcd4535d8a8b8723a296"},{"problem":110,"code":"; first solution \n;(fn pro[col]\n;  (letfn [(mypro [co]\n;    (let [num (mapv count (partition-by identity co))\n;          val (mapv first (partition-by identity co))]\n;           (interleave num val)))]\n;    (lazy-seq (cons (mypro col) (pro (mypro col))))))\n(fn pro[col]\n  (letfn [(mypro [co] (mapcat (juxt count first) (partition-by identity co)))]          \n  \t(lazy-seq (cons (mypro col) (pro (mypro col))))))","user":"5f0824c5e4b0cf489e8d7f5b"},{"code":"(let [pronounce\n      (fn [n]\n        (loop [result [] actual-digit (first n) actual-count 1 digits (rest n)]\n          (if (empty? digits)\n            (concat result (list actual-count) (list actual-digit))\n            (if (= actual-digit (first digits))\n              (recur result actual-digit (inc actual-count) (rest digits))\n              (recur (concat result (list actual-count) (list actual-digit))\n                     (first digits)\n                     1\n                     (rest digits))))))]\n(fn pro [x]\n  (cons (pronounce x)\n        (lazy-seq (pro (pronounce x))))))","problem":110,"user":"52e17e66e4b09f7907dd1423"},{"code":"(fn [a]\n  (next\n    (iterate\n      (fn [s]\n        (mapcat \n          (fn [x] [(count x) (first x)])\n          (partition-by identity s)))\n      a)))","problem":110,"user":"4f08b15b535dcb61093f6c40"},{"problem":110,"code":"(fn pronounce-seq [coll]\n  (let [p (mapcat (fn[_] [(count _) (first _)]) (partition-by identity coll))]\n    (lazy-seq (cons p\n      (pronounce-seq p)))))","user":"57c0917be4b05aa3c4741c95"},{"problem":110,"code":"(fn pronunciations[xs]\n  ;; A function that returns a lazy sequence of \"pronunciations\" of a\n  ;; sequence of numbers. A pronunciation of each element in the sequence\n  ;; consists of the number of repeating identical numbers and the number\n  ;; itself. For example, [1 1] is pronounced as [2 1] (\"two ones\"), which in\n  ;; turn is pronounced as [1 2 1 1] (\"one two, one one\").\n  (let [next (mapcat #(list (count %) (first %))\n                     (partition-by identity xs))]\n    (lazy-seq\n     (cons next (pronunciations next)))))","user":"5980f91ae4b021a7a535fddd"},{"problem":110,"code":"(fn pronounce [v]\n  (lazy-seq\n   (let [vnext (flatten (map (juxt count first) (partition-by identity v)))]\n     (cons vnext (pronounce vnext)))))","user":"56ff45e5e4b08d47c97781bb"},{"problem":110,"code":"(fn f [s]\n  (let [n (flatten (map #(list (count %) (first %)) (partition-by identity s)))]\n    (lazy-seq (cons n (f n)))))","user":"5590e55de4b0277789237676"},{"code":"#(let [w (fn [x]\n            (mapcat (fn [[i :as y]][(count y) i]) (partition-by identity x)))]\n   (iterate w (w %)))","problem":110,"user":"5098f5d6e4b0cae2931060a4"},{"code":"(let [next-pronunciation (fn [coll]\n                            (loop [result [], coll coll]\n                              (if (empty? coll)\n                                result\n                                (let [elem (first coll), pred (partial = elem)]\n                                  (recur (conj result (count (take-while pred coll)) elem) (drop-while pred coll))))))]\n  (fn gen [coll]\n    (let [coll (next-pronunciation coll)]\n      (lazy-seq\n        (cons coll (gen coll))))))","problem":110,"user":"4edab806535d10e5ff6f5311"},{"code":"(fn [s]\n  (letfn [(pronounce [x]\n            (if (seq x)\n              (let [f (first x)\n                    matching (take-while #(= f %) x)\n                    c (count matching)]\n                (concat [c f] (pronounce (drop c x))))))]\n    (rest (iterate pronounce s))))","problem":110,"user":"4e80aa10535db62dc21a62b1"},{"problem":110,"code":"(fn __ [s]\n  (let [p (fn p [s acc]\n            (if (empty? s) acc\n              (let [n (first s)\n                    f (partial = n)]\n                (p (drop-while f s)\n                   (concat\n                     acc\n                     [(count (take-while f s))\n                      n])))))\n        r (p s [])]\n    (lazy-cat [r] (__ r))))","user":"57a0b341e4b0c3d858beb8d4"},{"problem":110,"code":"(fn sof [xs]\n  (lazy-seq \n   \t(let [new-xs (->> xs\n                      (partition-by identity)\n                      (map #(vector (count %) (first %)))\n                      (apply concat)\n                      vec)]   \n       (cons new-xs (sof new-xs)))))","user":"559b55d6e4b066d22e731f54"},{"problem":110,"code":"(fn x-f [seqqq]\n           (let [get-next (fn [seqqq]\n                            (loop [seqq (rest seqqq) tempseq (conj '() (first seqqq)) res []]\n                              (if (empty? seqq)\n                                (vec (conj res (count tempseq) (first tempseq)))\n                                (if (= (first seqq) (first tempseq))\n                                  (recur (rest seqq) (conj tempseq (first seqq)) res)\n                                  (recur (rest seqq) (conj '() (first seqq))\n                                         (vec (conj res (count tempseq) (first tempseq))))))))]\n             (lazy-seq (cons (get-next seqqq) (x-f (get-next seqqq))))))","user":"5508102ee4b021ccfedb96b0"},{"problem":110,"code":"(fn pner [coll]\n  (letfn [(pn [coll]\n            (->> coll\n                 (partition-by identity)\n                 (mapcat #(list (count %) (first %)))))]\n    (iterate pn (pn coll))))","user":"5eb1c786e4b00a66d4a95201"},{"problem":110,"code":"(fn gggg [s]\n     (let [im (partition-by identity s)\n           c (mapv count im)\n           k (mapv first im)\n           ans (interleave c k)]\n       (lazy-seq (cons ans (gggg ans)))))","user":"52f426fce4b05e3f0be25f1e"},{"code":"(fn q [l] (drop 1 (iterate #(mapcat (fn [e] [(count e) (first e)]) (partition-by identity %)) l)))","problem":110,"user":"4ede8789535d10e5ff6f5337"},{"code":"(fn [xs]\n  (let [\n  pronounce (fn [xs]\n    (->> xs\n         (partition-by identity)\n         (mapcat #(vector (count %) (first %)))))\n  ]\n  (drop 1 (iterate pronounce xs))))","problem":110,"user":"4e691c79535d8ccf87e9fe97"},{"code":"(fn [s]\n  (next\n    (iterate\n      (fn [s]\n        (apply concat \n          (map #(list (count %) (first %))\n            (partition-by identity s))))\n      s)))","problem":110,"user":"4f569218e4b0a7574ea71826"},{"problem":110,"code":"(fn [input]\n  (drop 1\n     (iterate (fn [xs] \n                   (let [[st v]\n                  (reduce (fn [[{:keys [prev run] :or {:prev nil :run 0}} v] x]\n                            (if (nil? prev)\n                              [{:prev x :run 1} v]\n                              (if (= prev x)\n                                [{:prev x :run (inc run)} v]\n                                [{:prev x :run 1} (conj v run prev)]\n                            )))\n                          [{} []]\n                          xs\n                          )]\n                     (conj\n                      v (st :run) (st :prev)) ))\n                    \n                    \n                    \n                input)))","user":"51aa2b4fe4b04e3dc0c27b21"},{"problem":110,"code":"(fn p [c]\n  (let [n (reduce\n            #(conj % (count %2) (first %2))\n            []\n            (partition-by identity c))]\n    (lazy-seq (cons n (p n)))))","user":"52bacfa8e4b07a9af57922d6"},{"problem":110,"code":"(fn pronounce [coll]\n    (let [pronunciation (mapcat #(list (count %) (first %))\n                                (partition-by identity coll))]\n      (cons pronunciation (lazy-seq (pronounce pronunciation))))\n    \n    )","user":"4f5e5975e4b0030a34fb2b4d"},{"problem":110,"code":"(fn [coll]\n  (rest\n    (iterate\n      (fn [s]\n        (mapcat (juxt count first)\n          (partition-by identity s)))\n      coll)))","user":"55d2dd27e4b0e31453f64a5b"},{"problem":110,"code":"(fn f [l]\n   (rest (iterate (fn [s] (mapcat (fn [q] [(count q) (first q)]) (partition-by identity s)) ) l)))","user":"53f6d555e4b0db01ade6f9e5"},{"code":"(fn f [s]\n  (lazy-seq\n   (let [n (mapcat #(vector (count %) (first %)) (partition-by identity s))]\n     (cons n (f n)))))","problem":110,"user":"52753740e4b03e8d9a4a74c1"},{"problem":110,"code":"(fn [xs]\n      (letfn [ (FF [ys]\n                 (let [ cs\n                       (loop [zs ys rs []]\n                         (if (empty? zs) rs\n                             (recur (second (split-with #(= (first zs) %) zs))\n                                    (conj rs (first (split-with #(= (first zs) %) zs)))\n                           ))\n                         )]\n          (reduce #(conj %1 (count %2) (first %2)) [] cs)\n          )\n\n        )]\n        (iterate FF (FF xs))\n\n))","user":"53ca23e3e4b00fb29b2212c6"},{"problem":110,"code":"(fn fourclojure-110 [init]\n  (letfn [(next-entry [v]\n            (reduce\n             #(if (= %2 (last %1)) ;; if the last element of the return vector is equal to the current input element\n                (update-in %1 [(- (count %1) 2)] inc) ;; increase the counter (next-to-last)\n                (conj %1 1 %2))                     ;; else append 1 and the current input\n             [] v ))]\n    (rest (iterate next-entry init))))","user":"5f2c94b4e4b033932238a669"},{"problem":110,"code":"(fn [xs]\n  (letfn [(pronunciation [xs]\n                         (->> xs\n                              (partition-by identity)\n                              (mapcat (juxt count first))))]\n    (rest (iterate pronunciation xs))))","user":"56cf115de4b0ea9b8538f765"},{"problem":110,"code":"(fn [ic]\n  (rest (iterate\n          #(loop [s % res []]\n            (if (first s)\n              (let [[f r] (split-with #{(first s)} s)]\n                (recur r (conj res (count f) (first s))))\n              res))\n          ic)))","user":"57b3efb1e4b0fbc9809a278a"},{"code":"(fn [coll]\n  (rest (iterate (fn [v] \n             (reduce \n              #(conj %1 (count %2) (first %2)) \n              [] (partition-by identity v))) coll)))","problem":110,"user":"51780f88e4b03d69594194c9"},{"code":"(comp\n rest\n (partial\n  iterate\n  #(mapcat\n    (juxt count first)\n    (partition-by\n     identity %))))","problem":110,"user":"532ab0bde4b09d4e7a9b5527"},{"problem":110,"code":"(fn get-pronounciation [v]  \n  (rest (iterate (fn [x]\n             (->> x\n                  (partition-by identity)\n                  (mapcat #(vector (count %) (first %)))))\n           v)))","user":"54e345a1e4b024c67c0cf7db"},{"code":"(fn [s] (let [g #(mapcat (juxt count first) (partition-by identity %))] (iterate g (g s))))","problem":110,"user":"4ee9ddb8535d93acb0a66896"},{"problem":110,"code":"(fn p [s]\n  (let [n (flatten\n            (map #(vector (count %) (first %))\n                 (partition-by identity s)))]\n  (lazy-seq\n    (cons n (p n)))))","user":"56d4b22de4b0ea9b8538f7bb"},{"code":"(fn b [n]\n  (let [nn (partition-by identity n)\n        a (flatten (map #(list (count %) (first %)) nn))]\n    (cons a (lazy-seq (b a)))))","problem":110,"user":"4fe97adde4b0547ebccb245e"},{"problem":110,"code":"(let [xfer (fn xfer [acc coll]\n             (if (first coll)\n               (let [n (first (filter #(not= (first coll) (nth coll % nil)) (range)))]\n                 (xfer (conj (conj acc n) (first coll)) (drop n coll)))\n               acc))\n      pronounce #(xfer [] %)]\n  (fn pseq [x] (let [p (pronounce x)] (lazy-seq (cons p (pseq p))))))","user":"5b465b8be4b02d533a91bc65"},{"code":"(fn [s] \n  (let [pronunciation-it \n        (fn [s] (reduce (fn [coll e] \n                          (conj (conj coll (count e)) (first e))) \n                        [] (partition-by identity s)))]\n    (rest (iterate pronunciation-it s))))","problem":110,"user":"5246e945e4b0644eb7b0783b"},{"code":"(fn [v]\n    (drop 1 (iterate \n      #(->> (partition-by identity %) \n         (mapcat (juxt count first)))\n      v)))","problem":110,"user":"4dbad895535d1e037afb21ae"},{"problem":110,"code":"(fn f [s]\n  (let [x (mapcat #(vector (count %) (first %)) (partition-by #(do %) s))]\n    (cons x (lazy-seq (f x)))\n    )\n  )","user":"55e1d34ae4b050e68259b421"},{"problem":110,"code":"(fn pronounce [coll]\n  (let [r (mapcat #(vector (count %) (first %))\n                  (partition-by identity coll))]\n    (cons r (lazy-seq (pronounce r)))))","user":"561ca2eae4b064ca9f4b169b"},{"problem":110,"code":"(fn [s]\n (letfn [(p [n]\n            (reduce #(conj % (count %2) (first %2)) []\n                    (partition-by identity n)))]\n   (drop 1 (iterate p s))))","user":"4eb97234535dfed6da9c6d53"},{"code":"(fn [coll]\n  (let [pronunciation (fn [s] (flatten (map (fn [t] [(count t) (first t)]) (partition-by identity s))))]\n    ((fn inner [coll]\n       (cons (pronunciation coll)\n             (lazy-seq (inner (pronunciation coll))))) coll)))","problem":110,"user":"50fc299ee4b0d10d794c19f2"},{"problem":110,"code":"(fn sequence-of-pronunciation [coll]\n  (letfn [(pronunce [coll]\n                    (apply concat (map #(vector (count %) (first %))\n                                       (partition-by identity coll))))]\n    (iterate pronunce (pronunce coll))))","user":"53b7aa6ce4b047364c0444d1"},{"code":"(fn [l] (rest (iterate #(mapcat (fn [x] [(count x) (first x)]) (partition-by identity %)) l)))","problem":110,"user":"4f8c5f4fe4b02e764a0a5198"},{"code":"(fn\n  [s]\n  (letfn [(pronuntiate [l]\n            (apply concat (map (juxt count first) (partition-by identity l))))]\n    (iterate pronuntiate (pronuntiate s))))","problem":110,"user":"5048202fe4b0ec70b3ef8d9a"},{"problem":110,"code":"(fn [c] (rest (iterate #(reduce (fn [a e]\n                      (concat a [(count e) (first e)])) [] (partition-by identity %)) c)))","user":"51e28063e4b08e53a149f0f2"},{"code":"(fn [y]\n      (letfn\n        [(o [x]\n          (->>\n            (partition-by identity x)\n            (map #(list (count %) (first %)))\n            flatten\n            ))]\n      (iterate\n        o\n        (o y))))","problem":110,"user":"51b3f109e4b0f094dd986fa9"},{"problem":110,"code":"(fn f [xs] \n  (let [ p (flatten (map (juxt count first)(partition-by identity xs)))]\n    (lazy-seq \n      (cons p (f p)))))","user":"55ecb2c0e4b0121d4835fdce"},{"problem":110,"code":"#(rest (iterate (fn [x] (loop [[h & r] x c 0 w nil o []]\n                                   (if h\n                                     (if (or (nil? w) (= h w))\n                                       (recur r (inc c) h o)\n                                       (recur r 1 h (concat o [c w])))\n                                     (concat o [c w]))\n                                   )) %))","user":"545ddac3e4b01be26fd74676"},{"problem":110,"code":"(fn sp [s]\n    (let [ns (vec (mapcat (juxt count first) (partition-by identity s)))]\n      (lazy-seq (cons ns (sp ns)))))","user":"5310e968e4b08068f379ecdd"},{"problem":110,"code":"(fn lazy-pronounce [x] (let[pronunce (fn[v]\n                                       (loop[reV (rest v) n (first v) c 1 r [] ]\n                                         (if(seq reV)(let[cn (first reV)]\n                                                       (if (= cn n) (recur (rest reV) n (inc c) r) (recur (rest reV) cn 1 (conj r c n))))\n                                           (conj r c n))))\n                            pv (pronunce x)]\n                         (cons pv (lazy-seq (lazy-pronounce pv)))))","user":"541619e8e4b01498b1a719f9"},{"problem":110,"code":"(fn __ [v] \n  (drop 1 \n        (iterate \n         (fn [x] \n           (reduce #(concat %1 [(count %2) (first %2)]) \n                   [] \n                   (partition-by identity x))) v)))","user":"53f3a4ace4b0742d9025b0f7"},{"code":"(fn [c]\n    (next (iterate #(mapcat (juxt count first)\n                            (partition-by identity %)) c)))","problem":110,"user":"4e6a0667535d8ccf87e9fe9e"},{"code":"(fn [xs] (rest (iterate #(reduce (fn [s a] (concat s [(count a) (first a)])) [] (partition-by identity %)) xs)))","problem":110,"user":"504f191ae4b0e7ad84dbc4ba"},{"problem":110,"code":"(fn [s](rest (iterate (fn [t] (mapcat #(list (count %) (first %)) (partition-by identity t))) s) ))","user":"512b07f7e4b078b06821febb"},{"code":"(fn [s] (next (iterate (fn [c] (mapcat (juxt count first) (partition-by #(do %) c))) s)))","problem":110,"user":"514d8084e4b019235f6c0588"},{"problem":110,"code":"(fn [sn]\n  (let [mp (fn [v]\n             (loop [out [] in v]\n               (if (empty? in)\n                 out\n                 (let [x (first in) xs (take-while #(= x %) in) c (count xs)]\n                   (recur (conj out c x) (drop c in))))))]\n    (iterate mp (mp sn))))","user":"564a5a09e4b0284900eef656"},{"problem":110,"code":"(fn [c]\n (->> c\n  (iterate #(->> (partition-by identity %)\n             (mapcat (fn [a] [(count a) (first a)]))))\n  rest))","user":"5c379636e4b0d62ef62d9f76"},{"problem":110,"code":"(fn\n  [coll]\n  (letfn [(r [coll] (mapcat #(vector (.size %) (first %))\n                            (partition-by identity coll)))]\n    (rest (iterate r coll))))","user":"52dfc89be4b09f7907dd1405"},{"problem":110,"code":"(letfn \n  [(pron-seq [s]\n    (flatten \n     (map \n      (fn [x] [(count x) (first x)])\n      (partition-by identity s))))]\n\n  (fn func [s]\n    (let [p (pron-seq s)]\n      (cons p (lazy-seq (func p))))))","user":"53065acbe4b02e8216869792"},{"problem":110,"code":"(fn prons-seq [nums]\n   (let [nxt (mapcat (fn [xs] [(count xs) (first xs)])\n                  (partition-by identity nums))]\n     (cons nxt (lazy-seq (prons-seq nxt)))))","user":"55c20bd0e4b0e31453f64972"},{"code":"(fn [xs]\n  (rest (iterate\n    (fn [xs]\n      (mapcat\n        (fn [part] [(count part) (first part)])\n        (partition-by identity xs)))\n     xs)))","problem":110,"user":"50fbf811e4b0d10d794c19f1"},{"problem":110,"code":"(fn [v]\n  (letfn [(group [prev freq rst]\n            (if (empty? rst) [freq prev]\n                (let [cur (first rst)]\n                  (cond (nil? prev) (group cur 1 (rest rst))\n                        (= prev cur) (group cur (inc freq) (rest rst))\n                        :else (cons freq (cons prev (group cur 1 (rest rst))))))))\n          (pronounce [s]\n            (let [res (vec (group nil 0 s))]\n              (cons res (lazy-seq (pronounce res)))))]\n    (pronounce v)))","user":"58f98231e4b0438e51c2cf4c"},{"problem":110,"code":"(letfn [                                                                                                                        \n    (pronounce [s] (mapcat #(list (count %) (first %)) (partition-by identity s)))                                                                      \n    (pronunciation-seq [s] (let [s' (pronounce s)] (cons s' (lazy-seq (pronunciation-seq s')))))]                                                       \n        pronunciation-seq)","user":"558b50d5e4b027778923762b"},{"code":"(fn P [s]\n     (let [S ((fn p [[h & t]]\n                  (if h\n                      (let [C (count (take-while #(= h %) t))]\n                           (lazy-cat [(inc C) h]\n                                     (p (drop C t)))))) s) ]\n                                    (lazy-seq (cons S (P S)))))","problem":110,"user":"4db8f6c4535d1e037afb219e"},{"code":"(fn [coll]\n  (let [pack (fn [c]\n               (let [diffs (filter #(not (= (get c %)\n                                            (get c (dec %))))\n                                   (range 1 (count c)))]\n                 (map (fn [[start end]] (subvec c start end))\n                      (partition 2 1 (concat [0] diffs [(count c)])))))]\n    (rest (iterate #(mapcat (fn [packed] [(count packed)\n                                         (first packed)])\n                            (pack (vec %)))\n                   coll))))","problem":110,"user":"5225271fe4b01819a2de42f9"},{"code":"(fn pron-seq [xs]\n  (let [p (mapcat (juxt count first) (partition-by identity xs))]\n    (lazy-seq (cons p (pron-seq p)))\n  )\n)","problem":110,"user":"4f725201e4b07046d9f4f02f"},{"problem":110,"code":"(fn [v]\n  (rest (iterate\n          (fn [s]\n            (mapcat (fn [ps] [(count ps) (first ps)])\n                    (partition-by identity s)))\n          v)))","user":"51df825de4b01188f062752b"},{"code":"#(rest\n  (iterate\n    (fn [s]\n      (mapcat (juxt count first)\n        (partition-by identity s)))\n    %))","problem":110,"user":"4ddbfb8a535d02782fcbea00"},{"problem":110,"code":"(fn [coll]\n    (letfn [(look-and-say [coll]\n              (mapcat #((juxt count first) %)\n                      (partition-by identity coll)))]\n      (drop 1 (iterate look-and-say coll))))","user":"5ac6ef9be4b0e27600da7779"},{"problem":110,"code":"(fn [c]\n    (rest (iterate #(mapcat (juxt count first) (partition-by identity %))\n             c)))","user":"57642916e4b0994c1922fbee"},{"code":"(fn self [coll]\n   (let [ret (mapcat (fn [v] [(count v) (first v)])  (partition-by identity coll))]\n     (lazy-seq (cons ret (self ret)))))","problem":110,"user":"52afbc69e4b0c58976d9acc0"},{"code":"(fn pron-seq [x]\n  (letfn [(pron [s] (mapcat #(list (count %) (first %)) (partition-by identity s)))]\n    (rest (iterate pron x))))","problem":110,"user":"4ec6559a535d6d7199dd36c9"},{"problem":110,"code":"(fn pronouncations [x]\n  (drop 1\n   (iterate\n    (fn [coll]\n      (->>\n       (partition-by identity coll)\n       (mapcat #(vector (count %) (first %)))))\n    x)))","user":"4ddb696b535d02782fcbe9fa"},{"problem":110,"code":"(letfn [(say [s] (mapcat (juxt count first)\n                         (partition-by identity s)))]\n  #(iterate say (say %)))","user":"5ad63a34e4b0ea6055cfac01"},{"code":"(fn [coll] (let [pronf (fn [coll]\n                (reduce\n                  (fn [a b]\n                    (let [before (last a)\n                          n (first before)\n                          v (second before)]\n                      (if (= v b)\n                        (conj (vec (butlast a)) [(inc n) v])\n                        (conj (vec a) [1 b]))))\n                  [] coll))]\n    (rest (iterate (comp flatten pronf) coll))))","problem":110,"user":"4ee77f15535d93acb0a66868"},{"code":"(fn [v] \n  (rest \n   (iterate (fn pronounce [xs] \n              (vec (mapcat #(vector (count %) (first %)) (partition-by identity xs)))) \n            v)))","problem":110,"user":"515fb48fe4b0e2be8aa20bd5"},{"code":"(fn [c] (rest (iterate #(mapcat (juxt count first) (partition-by identity %)) c)))","problem":110,"user":"4dae916eedd6309eace4d155"},{"problem":110,"code":"(fn pro [coll]\n  (lazy-seq\n    (if (empty? coll)\n      []\n      (let [pron (loop [item (first coll) my-count 1 rest-coll (rest coll) result []]\n                   (cond\n                     (empty? rest-coll) (concat result [my-count item])\n                     (= item (first rest-coll)) (recur item (inc my-count) (rest rest-coll) result)\n                     :default (recur (first rest-coll) 1 (rest rest-coll) (concat result [my-count item]))))]\n                     (cons pron (pro pron))))))","user":"51eec1a6e4b0871fa145d98d"},{"code":"(fn [l]\n  (rest (iterate (fn [l]\n             (let [seqs (partition-by identity l)]\n               (flatten (map #(list (count %) (first %)) seqs)))) l)))","problem":110,"user":"4ddbd934535d02782fcbe9fc"},{"code":"(fn pron [s]\n       (lazy-seq \n             (let [x (flatten (map #(vector (count %) (first %)) (partition-by\n                                                     identity s)))]\n(cons x (pron x)))))","problem":110,"user":"4eb8ec4a535dfed6da9c6d4b"},{"code":"(fn [coll]\n  (let [pron (fn pron [c]\n               (let [x (take-while #(= (first c) %) c)]\n                 (if (empty? c)\n                   '()\n                   (cons (count x) (cons (first c) (pron (drop-while #(= (first c) %) c)))))))]\n    (iterate pron (pron coll))))","problem":110,"user":"50d86fe2e4b01f0871336e67"},{"problem":110,"code":"(fn [xs]\n  (letfn\n      [(step [xs']\n         (let [[rs ys]\n               (reduce (fn [[rs ys] x]\n                         (cond\n                          (empty? ys) [rs, (cons x ys)]\n                          (= (first ys) x) [rs, (cons x ys)]\n                          :else [(conj rs ys), [x]]))\n                       [[],[]]\n                       xs')\n               rs' (if (empty? ys)\n                     rs\n                     (conj rs ys))]\n           (flatten (for [ys rs'] [(count ys) (first ys)]))))]\n    (rest (iterate step xs))))","user":"53ef7f77e4b0742d9025b0ce"},{"code":"(fn [coll]\n(next\n  (iterate\n    (fn [coll]\n      (mapcat \n        #(vector (count %) (first %)) \n        (partition-by identity coll)))\n    coll)))","problem":110,"user":"4f03154a535dcb61093f6a58"},{"code":"(fn [v]\n  (letfn \n    [(p [v1]\n      (mapcat #(vector (count %) (first %))\n              (partition-by identity v1)))]\n      (rest (iterate p v))))","problem":110,"user":"4e6dc95a535d5021c1a895f1"},{"code":"(fn pronunciations [numbers]\n  (letfn [(pronunciation [numbers]\n            (mapcat (fn [part] [(count part) (first part)])\n                    (partition-by identity numbers)))]\n    (lazy-seq\n      (let [pronunciation (pronunciation numbers)]\n        (cons pronunciation (pronunciations pronunciation))))))","problem":110,"user":"4e7c8fd1535db169f9c796be"},{"code":"(fn [x]\n  (drop 1 (iterate #(mapcat (juxt count first)\n                            (partition-by identity %)) x)))","problem":110,"user":"4e50c894535dc968683fc4ee"},{"problem":110,"code":"(fn [x]\n  (letfn [(partit [y] (partition-by identity y))\n          (pronun [y] (mapcat #(list (count %) (first %)) (partit y)))]\n    (iterate pronun (pronun x))))","user":"57e139f6e4b0bfb2137f5a6c"},{"problem":110,"code":"(fn ps [coll]\n  (let [nc (mapcat #(vector (count %) (first %)) (partition-by identity coll))]\n    (lazy-seq (concat [nc] (ps nc)))))","user":"561a1af6e4b053970a773b02"},{"problem":110,"code":"(fn [v] (rest (iterate #(mapcat (juxt count first) (partition-by identity %)) v)))","user":"5504dd64e4b086ebe8a79c83"},{"problem":110,"code":"(fn [s]\n  (let [step (fn [ps]\n               (loop [ret []\n                      ps ps\n                      lastn (first ps)\n                      countn 0]\n                 (cond\n                   (and (empty? ps) lastn) (conj ret countn lastn)\n                   (empty? ps) ret\n                   (= (first ps) lastn) (recur ret (rest ps) lastn (inc countn))\n                   :else (recur (conj ret countn lastn) (rest ps) (first ps) 1))))]\n    (rest (iterate step s))))","user":"571d063ee4b0145328a76272"},{"problem":110,"code":"(fn p [s]\n  (let [f (reduce #(conj % (count %2) (first %2)) [] (partition-by identity s))]\n    (lazy-seq \n      (cons f (p f)))))","user":"5e3a25d4e4b01d43a70e8dde"},{"problem":110,"code":"(fn pronounce [coll]\n  (let [p (flatten (for [x (partition-by identity coll)]\n                       [(count x) (first x)]))]\n    (cons p (lazy-seq (pronounce p)))))","user":"543c39e0e4b032a45b86933d"},{"problem":110,"code":"(fn pronon [coll]\n  (let [res (->> (partition-by identity coll)\n                 (mapcat (fn [e] [(count e) (first e)])))]\n    (lazy-seq (cons res (pronon res)))))","user":"5a527beee4b05d388ecb6bfe"},{"problem":110,"code":"(fn f [v]\n  (let [p (flatten\n           (map\n            (juxt count first)\n            (partition-by identity v)))]\n    (lazy-seq\n     (cons\n      p\n      (f p)))))","user":"57609d91e4b08062f99a4e9b"},{"problem":110,"code":"(fn [start]\n         (let [step (fn  [coll]\n                      (->> coll\n                           (partition-by identity)\n                           (map #(vector (count %) (first %)))\n                           (flatten)\n                       ))]\n                (iterate step (step start)))\n)","user":"53ed6976e4b0d648e757f4c4"},{"problem":110,"code":"(fn pronunciations [coll]\n  (letfn [(solve [coll]\n            (letfn [(same-as [x] (partial = x))]\n              (loop [coll coll, pronunciation []]\n                (if (empty? coll)\n                  pronunciation\n                  (let [x (first coll)\n                        xs (take-while (same-as x) coll)]\n                    (recur (drop-while (same-as x) coll)\n                           (conj pronunciation (count xs) x)))))))]\n    (lazy-seq\n     (cons (solve coll) (pronunciations (solve coll))))))","user":"55ed1575e4b0121d4835fdd3"},{"problem":110,"code":"(fn [coll]\n      (letfn [(prn [p]\n              (->> p\n                   (partition-by identity)\n                   (mapcat (fn [pi] [(count pi) (first pi)]))))]\n      (iterate prn (prn coll))))","user":"58ca8a1de4b03c36ff7e5835"},{"code":"(fn [s]\n  (rest (iterate (fn [z]\n    (mapcat \n      #(vector (count %) (first %)) \n      (partition-by identity z))) s)))","problem":110,"user":"4e5c801e535d8a8b8723a2c1"},{"problem":110,"code":"(fn [s]\n  (rest (iterate \n         (fn [s] (let [ss (partition-by identity s)] \n                   (mapcat #(vector (count %) (first %)) ss))) s)))","user":"5e6ca949e4b04a83ad7cd289"},{"problem":110,"code":"(fn f\n  ([s] (f (first s) 1 (rest s) []))\n  ([x c s r]\n   (if (empty? s)\n     (lazy-seq (cons (conj r c x) (f (conj r c x))))\n     (if (= x (first s))\n       (f x (inc c) (rest s) r)\n       (f (first s) 1 (rest s) (conj r c x))))))","user":"5a3c2a08e4b001c08efc0cdf"},{"code":"(fn pronuns [xs] \n  (let [p (reduce #(conj %1 (count %2) (first %2)) [] (partition-by identity xs))]\n    (cons p (lazy-seq (pronuns p)))))","problem":110,"user":"511442d0e4b0e9c109bb74d5"},{"code":"(fn pro [xs]\n  (let [f (fn [xs]\n            (->> xs\n                 (partition-by identity)\n                 (map #(vector (count %) (first %)))\n                 flatten))]\n    (iterate f (f xs))))","problem":110,"user":"4fb79872e4b081705acca2d2"},{"code":"(fn [n] (drop 1 (iterate #(flatten (map (fn [s] [(count s) (first s)]) (partition-by identity %))) n)))","problem":110,"user":"4e9609ad535dbda64a6f6b3e"},{"problem":110,"code":"(fn [xs]\n  (letfn [(f [p _] (mapcat #(->> % frequencies (apply reverse)) (partition-by identity p)))]\n    (reductions f (f xs 0) (range))))","user":"5d29c06be4b01671435dbc6b"},{"problem":110,"code":"(comp next iterate) (comp (partial mapcat (juxt count first)) (partial partition-by identity))","user":"548b8a50e4b0e286459a11ff"},{"code":"(fn [s]\n  (rest (iterate (fn [el]\n                   (mapcat #(vector (count %) (first %))\n                           (partition-by identity el))) s)))","problem":110,"user":"4f2baf1ae4b0d6649770a04c"},{"code":"#(letfn [\n  (next-p [p]\n    (flatten\n      (for [s (partition-by identity p)]\n        [(count s) (first s)])))]\n  (iterate next-p (next-p %)))","problem":110,"user":"4e8f4f64535d65386fec2149"},{"problem":110,"code":"(fn pronounce [xs]\n  (letfn [(sumrep [ys]\n            (let [sum (count (take-while #(= (first ys) % ) ys))]\n              (if (= sum 0) nil \n                (concat (list sum (first ys))\n                        (sumrep (drop sum ys))))))]\n    (lazy-seq (cons (sumrep xs) (pronounce (sumrep xs))))))","user":"53e9a15be4b036ad0777e4ae"},{"problem":110,"code":"(fn f [col]\n    (cons\n      (mapcat #(vector (count %) (first %)) (partition-by identity col))\n      (lazy-seq (f (first (f col))))))","user":"54f26266e4b024c67c0cf8c5"},{"problem":110,"code":"(fn p110 [s]\n    (let [pronounce (fn [word] (->> word\n                                    (partition-by identity)\n                                    (mapcat (juxt count first))))]\n        (drop 1 (iterate pronounce s))))","user":"4fc4eb1ee4b081705acca354"},{"code":"(fn pronunciation-seq [init]\n      (letfn [(pronunciation-iter [s]\n                (apply concat (for [part (partition-by identity s)] [(count part) (first part)]))\n              )]\n          (drop 1 (iterate pronunciation-iter init)))\n  )","problem":110,"user":"5165a235e4b079ad97ec44ac"},{"problem":110,"code":"(fn p [s]\n  (let [n (mapcat (juxt count first) (partition-by identity s))]\n    (lazy-seq (cons n (p n)))))","user":"567c63f6e4b05957ce8c61bb"},{"code":"(fn [coll]\n    (let [pronunciation (fn [c]\n                          (loop [c c\n                                 prev-val nil\n                                 count 0\n                                 p []]\n                            (cond (nil? c) (concat p [count prev-val])\n                                  (= (first c) prev-val) (recur (next c) prev-val (inc count) p)\n                                  (nil? prev-val) (recur (next c) (first c) 1 [])\n                                  :else (recur (next c) (first c) 1 (concat p [count prev-val])))))]\n      (drop 1 (iterate pronunciation coll))))","problem":110,"user":"4e89e939535d3e98b8023287"},{"problem":110,"code":"(fn [v] (rest (iterate #(vec (flatten (map (fn [s] [(count s) (first s)]) (partition-by identity %)))) v)))","user":"5280539ce4b0757a1b1713f3"},{"problem":110,"code":"(fn pronounces [s]\n  (letfn [(pronounce [s]\n                     (let [p (partition-by identity s)]\n                       (reduce\n                        (fn [r [f :as g]]\n                          (conj r (count g) f))\n                        []\n                        p)))]\n    (drop 1 (iterate pronounce s))))","user":"5654e024e4b0f9d632dd848d"},{"code":"(fn [col]\n      (letfn [(pronfn [coll] (loop [result [] x (first coll) counter 1 elements (next coll)]    \n\t\t\t     (if elements       \n\t\t\t       (if (= x (first elements))\n\t\t\t          (recur\n\t\t\t             result x (inc counter) (next elements)\n\t\t\t          )\n\t\t\t          (recur (conj (conj result counter) x ) (first elements) 1 (next elements)                    \n\t\t\t          )              \n\t\t\t       )\n\t\t\t       (conj (conj result counter) x )\n\t\t\t       )     \n\t\t\t     )) ]\n        (iterate pronfn (pronfn col))        \n        )\n   )","problem":110,"user":"5106dc1be4b01150e115ebf0"},{"problem":110,"code":"(fn hear [l]\n  (let [beep\n        (loop [x (partition-by identity l)\n               w '[]]\n          (if (empty? x)\n            w\n            (let [y (first x)]\n              (recur (rest x) (conj w (count y) (first y))))))]\n    (lazy-seq (cons beep (hear beep)))))","user":"56d5fd24e4b0ea9b8538f7c5"},{"problem":110,"code":"(letfn [(pronounce [ns]\n            (->> ns\n                 (partition-by identity)\n                 (mapcat (fn [v] [(count v) (first v)]))))]\n    (fn pronunciations [ns]\n      (rest (iterate pronounce ns))))","user":"4dfe5a93535d04ed9115e786"},{"problem":110,"code":"(fn [l] (rest (iterate (fn [l1] (mapcat (juxt count first) (partition-by identity l1))) l)))","user":"5b919d9de4b0c0b3ffbd4a24"},{"problem":110,"code":"(fn pronunciations\n  [xs]\n  (lazy-seq\n    (let [next-xs (->> xs\n                       (partition-by identity)\n                       (mapcat #(vector (count %) (first %))))]\n      (cons next-xs (pronunciations next-xs)))))","user":"5338387de4b0e30313ee6c91"},{"code":"(fn prnn\r\n  [a]\r\n  (let [f (fn [v] (loop [s v r [] n (first v)]\r\n    (if (nil? n)\r\n      r\r\n      (let [c (count (take-while #(= n %) s))]\r\n        (recur (drop c s) (conj (conj r c) n) (nth s c nil)))))) \r\n        i (f a)]\r\n    (cons i (lazy-seq (prnn i)))))","problem":110,"user":"4f17ab99535d64f603146457"},{"code":"#(rest (iterate (fn [c] (mapcat (juxt count first) (partition-by identity c))) %))","problem":110,"user":"52b453b0e4b0c58976d9ad21"},{"code":"(fn p110\n  ([x]\n     (iterate (partial p110 []) (p110 [] x)))\n     ;(let [s (p110 [] x)]\n     ;  (cons s (lazy-seq (p110 s)))))\n  ([re x]\n     (loop [l x, n 0, i (first l), r []]\n       (if (empty? l)\n         (conj r n i)\n         (if (= i (first l))\n           (recur (rest l) (inc n) i r)\n           (recur (rest l) 1 (first l) (conj r n i)))))))","problem":110,"user":"500b61b1e4b03d00572d2d81"},{"problem":110,"code":"(letfn [(pronounce [xs]\n          (mapcat #(vector (count %) (first %))\n            (partition-by identity xs)))]\n  (fn [xs]\n    (rest (iterate pronounce xs))))","user":"59eb63e3e4b0249b7282077c"},{"problem":110,"code":"(fn [sq]\n        (let [pronunciation\n              (fn[sq]\n                (let [aux\n                      (fn[res eye cnt [hd & more]]\n                        (prn res eye cnt (cons hd more))\n                        (cond \n                         (nil? hd)\n                         (conj res cnt eye)\n                         \n                         (nil? eye)\n                         (recur res hd 1 more)\n                         \n                         (= eye hd)\n                         (recur res hd (inc cnt) more)\n                         \n                         :otherwise\n                         (recur (conj res cnt eye) hd 1 more)))]\n                  \n                  (aux [] nil 0 sq)))\n              ]\n          (rest (iterate pronunciation sq))))","user":"57e6f90de4b0bfb2137f5af6"},{"code":"(fn [s] (rest (iterate #(mapcat (juxt count first) (partition-by identity %)) s)))","problem":110,"user":"4e82f85d535db62dc21a62ce"},{"problem":110,"code":"#(rest (iterate % %2))\n#(mapcat (juxt count first) (partition-by identity %))","user":"57e33f6fe4b0bfb2137f5a96"},{"code":"(fn pronounce\n           [seq]\n           (letfn [(pronunciations\n                     ([seq] (pronunciations 1 (first seq) (rest seq) []))\n                     ([c f r pronunciations]\n                        (if f\n                          (if (= (first r) f)\n                            (recur (inc c) (first r) (rest r) pronunciations)\n                            (recur 1 (first r) (rest r) (-> pronunciations\n                                                            (conj c)\n                                                            (conj f))))\n                          pronunciations)))]\n             (let [pronunciations (pronunciations seq)]\n               (lazy-seq (cons pronunciations\n                               (pronounce pronunciations))))))","problem":110,"user":"4dbb0f2d535d1e037afb21b1"},{"problem":110,"code":"(fn pron [coll]\n  (lazy-seq \n   (let [x (flatten (map #(do [(count %) (first %)])\n                         (partition-by identity coll)))]\n     (cons x (pron x)))))","user":"57dd47f4e4b0bd073c20243e"},{"code":"(fn sp [in]\n  (let [n (flatten (into [] (map #(list (count %1) (first %1)) (partition-by identity in))))]\n  (lazy-seq\n    (cons n (sp n)))))","problem":110,"user":"4faec810e4b081705acca24e"},{"code":"(fn p [s]\n  (let [nxt (mapcat (fn [x] [(count x) (first x)]) (partition-by identity s))]\n    (cons nxt (lazy-seq (p nxt))))\n  )","problem":110,"user":"52ffb7f2e4b0d8b024fd370b"},{"problem":110,"code":"(fn [coll]\n  (letfn\n    [(pronounce [x]\n               (when-let [f (first x)]\n                 (let [s (split-with #(= % f) x)]\n                   (cons (count (s 0)) (cons f (pronounce (s 1)))))))]\n    (rest (iterate pronounce coll))))","user":"56a01895e4b0542e1f8d149f"},{"code":"(fn [i] \n  (rest\n    (iterate \n    #(mapcat (juxt count first) \n     (partition-by + %)) i)))","problem":110,"user":"4e513ecf535dc968683fc4f6"},{"problem":110,"code":"(fn pronunciations [start]\n  (let [pronounce (fn [coll]\n                    (apply concat (map #(vector (count %) (first %))\n                                       (partition-by identity coll))))]\n    (rest (iterate pronounce start))))","user":"601aaa93e4b0bf4ca6b10926"},{"problem":110,"code":"(fn x [s]\n        (let [ps (->> (partition-by identity s)\n                      (mapcat #(list (count %) (first %))))]\n          (cons ps (lazy-seq (x ps)))))","user":"502873a8e4b01614d1633ff8"},{"problem":110,"code":"(fn pronunciation-of-coll\n  [coll]\n  (let [res (mapcat (fn [xs]\n                      [(count xs) (first xs)])\n                    (partition-by identity coll))]\n    (cons res (lazy-seq (pronunciation-of-coll res)))))","user":"55079e55e4b021ccfedb96aa"},{"problem":110,"code":"(fn  [coll]\n  (rest (iterate #(vec (mapcat (fn [c] [(count c) (first c)]) (partition-by identity %))) coll)))","user":"53b530c6e4b047364c0444bc"},{"problem":110,"code":"#(letfn [(pronounce [v] (mapcat (fn [[x :as xs]] [(count xs) x]) (partition-by identity v)))]\n    (rest (iterate pronounce %)))","user":"5e3e23d9e4b01d43a70e8e20"},{"code":"(fn [s]\n  (rest (iterate #(mapcat (juxt count first) (partition-by max %)) s)))","problem":110,"user":"5164867fe4b003cf19fdde3e"},{"problem":110,"code":"(fn pronunciations [coll]\n  (rest (iterate\n          (fn [coll]\n            (->> coll\n                 (partition-by identity)\n                 (map #(list (count %) (first %)))\n                 (apply concat)))\n          coll)))","user":"53dc94c8e4b094d41abdfefc"},{"code":"(fn [col]\n  (letfn [(gen [col] (mapcat (fn [c] [(count c) (first c)]) (partition-by identity col)))]\n    (rest (iterate gen col))))","problem":110,"user":"50435689e4b034ff00315d21"},{"code":"(fn [z] \n  (rest \n   (iterate\n    (fn [y] \n      (flatten\n       (map (fn [x] (conj [] (count x) (first x))) \n            (partition-by identity y)))) \n    z)))","problem":110,"user":"4ed286d4535d44c135fd68d7"},{"problem":110,"code":"(fn pronunciation-sequence [ns]\n  (rest (iterate\n          (fn pronunciation [ms]\n            (mapcat (fn [xs] [(count xs) (first xs)])\n                    (partition-by identity ms)))\n          ns)))","user":"56ac81ace4b03c432f187347"},{"code":"(partial (comp next iterate) #(mapcat (juxt count first) (partition-by identity %)))","problem":110,"user":"50645e12e4b007509339a58a"},{"code":"(fn a [x]\n  (letfn [(f [x] (mapcat (fn [y] [(count y) (first y)]) (partition-by identity x)))]\n    (lazy-seq (cons (f x) (a (f x))))))","problem":110,"user":"4fe8fda4e4b0547ebccb2438"},{"code":"(fn [s]\n  (rest\n    (iterate\n      #(mapcat (juxt count first) (partition-by identity %))\n      s)))","problem":110,"user":"528652fbe4b0239c8a67ae14"},{"problem":110,"code":"(fn f  [l] \n  \n  (let [nxtl (mapcat #(vector (count %) (first %)) (partition-by  identity l) ) ] \n      (lazy-seq (cons nxtl  (f nxtl) )   )\n  )\n  \n  \n  )","user":"5735ac67e4b0cd1946bd102b"},{"problem":110,"code":";; base function:\n  ;; first element is a count\n  ;; second element is actual number\n;; lazy sequence, therefore you need to groupby by the value, then you need to mapcat the basefunction into each of the groups?\n\n#(rest (iterate (fn [coll] (mapcat (juxt count first) (partition-by identity coll))) %))","user":"5baaae06e4b0a20761a23464"},{"problem":110,"code":"#(rest (iterate (fn [i] (mapcat (juxt count first)\n                               (partition-by identity i))) %))","user":"554680cbe4b0a04f7929953e"},{"problem":110,"code":"(fn [c] (rest (iterate #(mapcat (fn [x] [(count x) (first x)]) (partition-by identity %)) c)))","user":"594d4c57e4b07ddc2dafae87"},{"problem":110,"code":"(fn prons [v]\n   (lazy-seq\n     (let [pron (mapcat #(vector (count %) (first %)) (partition-by identity v))]\n               (cons pron (prons pron)))))","user":"55f8b32ae4b03cbcff9738ba"},{"code":"(fn [n]\n  (letfn [(step [n] \n             ( mapcat (juxt count first)\n                      (partition-by identity n))) ]\n     (iterate step (step n))))","problem":110,"user":"4e860e85535db62dc21a62f1"},{"code":"(fn f [s]\n  (let [result (loop [remaining (rest s)\n         result []\n         subject (first s)\n         counter 1]\n    (if (empty? remaining)\n      (conj result counter subject)\n      (if (= (first remaining) subject)\n        (recur (rest remaining) result subject (inc counter))\n        (recur (rest remaining) (conj result counter subject) (first remaining) 1))))]\n    (cons result (lazy-seq (f result)))))","problem":110,"user":"51899891e4b0288ada3dbdab"},{"code":"#(let [f (fn [x] (reduce (fn [s e] (conj (conj s (count e)) (first e))) [] (partition-by identity x)))]\n   (iterate f (f %)))","problem":110,"user":"5027b41ee4b01614d1633fee"},{"code":"(fn [s]\n                   (rest (iterate\n            (fn [x] (loop [n (first x) c x r '()]\n                  (if (empty? c)\n                      r\n                    (let [a (count (take-while #(= n %) c))\n                            b (drop a c)]\n                      (recur (first b) b (concat r [a n])))))) s)))","problem":110,"user":"511b810ce4b07ab9ec456182"},{"problem":110,"code":"(fn pronunciations\n  [xs]\n  (let [pronunciation (->> (partition-by identity xs)\n                           (map (fn [xs] [(count xs) (first xs)]))\n                           (mapcat identity))]\n    (lazy-seq (cons pronunciation (pronunciations pronunciation)))))","user":"5c3ac091e4b0d62ef62d9f95"},{"problem":110,"code":"(fn seq-of-pronounciations [xs]\n  (let [x (mapcat #(list (count %) (first %)) (partition-by identity xs))]\n    (lazy-seq (cons x (seq-of-pronounciations x)))))","user":"5d81b40ce4b0915913b1d379"},{"code":"(fn inf-seq-pronounce [s]\r\n    (letfn [(seq-pronounce\r\n              ([l] (seq-pronounce l nil 0))\r\n              ([l curnum curcount]\r\n                 (if (empty? l)\r\n                   (list curcount curnum)\r\n                   (if (= (first l) curnum)\r\n                     (seq-pronounce (rest l) curnum (inc curcount))\r\n                     (if (nil? curnum)\r\n                       (seq-pronounce (rest l) (first l) 1)\r\n                       (concat (list curcount curnum)\r\n                               (seq-pronounce (rest l) (first l) 1)))))))]\r\n    (lazy-seq (cons (seq-pronounce s) (inf-seq-pronounce (seq-pronounce s))))))","problem":110,"user":"4f039524535dcb61093f6b2c"},{"code":"(fn say [xs]\n  (let [n (mapcat #(vector (count %) (first %))\n                  (partition-by identity xs))]\n    (cons n (lazy-seq (say n)))))","problem":110,"user":"511aa2a4e4b0c87c59c9670a"},{"code":"(fn pron [sq]\n  (let [p (reduce #(conj %1 (count %2) (first %2)) \n                  []\n                   (partition-by identity sq))]\n    (cons p (lazy-seq (pron p)))))","problem":110,"user":"53300924e4b019098a6f8b55"},{"problem":110,"code":"(fn [init]\n  (letfn\n    [(pron [coll]\n           (flatten (map #(vec [(count %) (first %)])\n                         (partition-by identity coll))))]\n    (rest (iterate pron init))))","user":"5da760ebe4b000c986472c1a"},{"code":"(fn pron [coll]\n  (let* [p (partition-by identity coll)\n         q (reduce (fn [acc e] (conj acc (count e) (first e))) [] p)]\n    (lazy-seq\n     (cons q (pron q)))))","problem":110,"user":"52f8f4d1e4b047fd55836fde"},{"problem":110,"code":"(fn f [c] (let [d (flatten (map #(vector (count %) (first %)) (partition-by identity c)))] (lazy-seq (cons d (f d)))))","user":"5c41db45e4b08cd430848ece"},{"problem":110,"code":"(fn pronounce* [coll]\n    (let [pronounce (fn [coll]\n                      (loop [[x & xs] coll\n                             val      []]\n                        (if x\n                          (let [[h t] (split-with #(= % x) xs)]\n                            (recur t (conj val (inc (count h)) x)))\n                          val)))]\n      (lazy-seq\n       (let [p (pronounce coll)]\n         (cons p (pronounce* p))))))","user":"500d3160e4b05f7c30cfa6a1"},{"problem":110,"code":"(letfn [(pronounce [[h & t]]\n            (loop [v h, n 1, [h & t :as xs] t, accu []]\n              (cond\n                (empty? xs) (into accu [n v])\n                (= h v) (recur v (inc n) t accu)\n                :else (recur h 1 t (into accu [n v])))))]\n    #(drop 1 (iterate pronounce %)))","user":"58ec1e63e4b056aecfd47d54"},{"problem":110,"code":"(fn f [s]\n  (let [next (mapcat #(vector (count %) (first %)) (partition-by identity s))]\n    (lazy-cat (vector next) (f next))))","user":"50f10f7be4b06d9538fe211a"},{"problem":110,"code":"(fn [coll] (rest (iterate #(mapcat (juxt count first) (partition-by identity %)) coll)))","user":"5339c105e4b0e30313ee6cae"},{"problem":110,"code":"(fn [xs]\n  (letfn [(pron [ys]\n            (mapcat (juxt count first)\n                    (partition-by identity ys)))]\n    (rest (iterate pron xs))))","user":"55c4e48be4b0e31453f649a7"},{"problem":110,"code":"(fn [s] (rest (iterate #(flatten (map (fn [p] [(count p) (first p)]) \n                                      (partition-by identity %))) s)))","user":"53acaf1fe4b047364c04445f"},{"problem":110,"code":"(fn genPronounciationSeq [initColl]\n  (letfn[(pronounce [coll]\n                    (let [partitionedColl (partition-by identity coll)]\n                      (vec (interleave (map count partitionedColl) (map first partitionedColl)))))]\n    (lazy-seq\n     (let [newPronunciation (pronounce initColl)]\n       (cons newPronunciation (genPronounciationSeq newPronunciation))))))","user":"556c70dae4b09a3098a524fd"},{"code":"(fn pronuns [s]\n  (rest (iterate\n    #(flatten\n      (map (fn [s] [(count s) (first s)])\n           (partition-by identity %)))\n    s)))","problem":110,"user":"50ef9a7ae4b0bdaecbb47d9e"},{"code":"(fn blah [v]\n  (let [next (mapcat #(vector (count %) (first %)) \n                     (partition-by identity v))]\n    (cons next (lazy-seq (blah next)))))","problem":110,"user":"52b35a6ee4b0c58976d9ad07"},{"problem":110,"code":"(fn pronunciations [coll]\n  (letfn [\n      (ciations [n]\n        (lazy-seq (cons n (ciations \n        (reduce \n  #(if (= (last %1)\n          %2)\n        (conj (pop (pop %1)) (inc (last (pop %1))) (last %1))\n        (conj %1 1 %2)\n  )\n  []\n  n\n)\n        ))))]\n    (ciations \n    (reduce \n  #(if (= (last %1)\n          %2)\n        (conj (pop (pop %1)) (inc (last (pop %1))) (last %1))\n        (conj %1 1 %2)\n  )\n  []\n coll\n)\n    )\n  )\n)","user":"5b3251c1e4b025bcb146f317"},{"code":"(fn pronunciations\n  [coll]\n  (lazy-seq\n    (when-let [s (seq coll)]\n      (let [n (reduce (fn [r e] (conj r (count e) (first e))) [] (partition-by identity s))]\n        (cons n (pronunciations n))))))","problem":110,"user":"5348cab4e4b084c2834f4a5e"},{"code":"(fn pronunciations [coll]\n  (let [nextp (fn [c] (reduce (fn [acc t] (into acc [(count t) (first t)])) [] (partition-by identity c)))] \n    (iterate nextp (nextp coll))))","problem":110,"user":"5003deb9e4b0678c553fc445"},{"problem":110,"code":"(fn pronunciations\n  ([res]\n   (lazy-seq\n     (let [new\n           (flatten (map #(apply vector (clojure.set/map-invert (frequencies %))) (partition-by identity res)))]\n       (concat [new]\n             (pronunciations new))))))","user":"5e348945e4b0650de70e2b1d"},{"problem":110,"code":"(fn f[col] (let [p (partition-by identity col) res (mapcat #(vector (count %) (first %)) p)] (cons res (lazy-seq (f res)))))","user":"531f1e63e4b08068f379edc2"},{"code":"(fn [s] \n  (drop 1 (iterate \n    (fn [s] \n      (->> s\n       (partition-by identity)\n       (mapcat #(list (count %) (first %))))) s)))","problem":110,"user":"4ee7ef87535d93acb0a66872"},{"problem":110,"code":"(fn pron [coll]\n  (let [p (mapcat #(vector (count %) (first %)) (partition-by identity coll))]\n  \t(cons p (lazy-seq (pron p)))))","user":"55c0afa5e4b01b9910ae2a27"},{"problem":110,"code":"#(let [f (fn [[h & t]] \n           (flatten    \n             (reverse \n               (reduce \n                 (fn [[[n v] & r :as a] e] \n                  (if (= e v) \n                    (cons [(inc n) v] r) \n                    (cons [1 e] a)))\n                (list [1 h]) t))))]\n  \t(drop 1 (iterate f %)))","user":"4faf97d8e4b081705acca258"},{"problem":110,"code":"(fn [s] (drop 1 (iterate (fn [s] (->> s (partition-by identity) (mapcat (fn [e] [(count e) (first e)])))) s)))","user":"5abe2fc2e4b073f17744271e"},{"problem":110,"code":"(fn [s] (rest (iterate #(mapcat (juxt count first) (partition-by identity %)) s)))\n;\n;(fn f [s]\n;  (let [p (mapcat (juxt count first)\n;                  (partition-by identity s))]\n;    (cons p (lazy-seq (f p)))))","user":"54ca9ca8e4b057c6fda3a265"},{"code":"(fn [x]\n  (rest (iterate #(mapcat (juxt count first) (partition-by identity %)) x)))","problem":110,"user":"50479524e4b0371827a27bc4"},{"problem":110,"code":"(fn pronunciations\n  [s]\n  (letfn [(pronounce [s]\n            (lazy-seq\n              (if (empty? s)\n                '()\n                (let [v (first s)\n                      run (take-while #(= v %) s)]\n                  (concat (list (count run) v)\n                          (pronounce (drop-while #(= v %) s)))))))\n          (pronunciations* [s]\n            (lazy-seq\n              (let [p (pronounce s)]\n                (cons p (pronunciations* p)))))]\n    (pronunciations* s)))","user":"563f1493e4b08d4f616f5ecf"},{"problem":110,"code":"(fn pronounce [coll]\n  (let [groups (partition-by identity coll)\n        pronounced (mapcat #(vector (count %) (first %)) groups)]\n    (cons pronounced (lazy-seq (pronounce pronounced)))))","user":"57aa4775e4b0b8559636fc6b"},{"code":"(fn pron [x]\n  (let [res (reduce #(conj % (count %2) (first %2)) []\n                         (partition-by identity x))]\n    (cons res (lazy-seq (pron res)))))","problem":110,"user":"4fc93728e4b0ee37620e1844"},{"problem":110,"code":"(fn f [s]\n  (let [x (mapcat #(vector (count %) (first %)) (partition-by identity s))]\n    (lazy-seq (cons x (f x)))))","user":"552a793ee4b0ffed3738f955"},{"code":"(fn pronounce [x]\n  (let [res (mapcat (fn [y] [(count y) (first y)])\n                    (partition-by identity x))]\n    (cons res (lazy-seq (pronounce res)))))","problem":110,"user":"52736ca1e4b03e8d9a4a747e"},{"problem":110,"code":"(fn prons [coll]\n  (let [res (mapcat #(conj [(count %)] (first %)) (partition-by identity coll))]\n    (cons res (lazy-seq (prons res)))))","user":"53791ab7e4b06839e8705e4d"},{"code":"(fn [x] (rest (iterate #(mapcat (juxt count last) (partition-by identity %)) x)))","problem":110,"user":"523ed522e4b057c4b7cd0a78"},{"code":"(comp rest iterate)\n#(mapcat (fn [[h :as a]] [(count a) h])\n  (partition-by identity %))","problem":110,"user":"4e96557d535dbda64a6f6b43"},{"code":"(fn f [xs]\n  (let [res (mapcat #((juxt count first) %)\n                    (partition-by identity xs))]\n    (cons res (lazy-seq (f res)))))","problem":110,"user":"510acd6ee4b078ea719210f4"},{"problem":110,"code":"(fn f [xs]\n  (let [ys (mapcat (juxt count first) (partition-by identity xs))]\n    (lazy-cat [ys] (f ys))))","user":"5b64370ae4b0c6492753e73c"},{"code":"(fn pron [s]\n  (let [l (mapcat #(list (count %) (first %)) (partition-by identity s))]\n    (lazy-seq (cons l (pron l)))))","problem":110,"user":"52ba43d0e4b07a9af57922cd"},{"problem":110,"code":"(fn pronounce [coll]\n           (lazy-seq\n             (let [result (interleave\n                 (map count (partition-by identity coll))\n                 (map #(first %) (partition-by identity coll)))]\n         (cons result (pronounce result)))))\n\n\n\n\n\n;#(rest (iterate (fn [coll] (mapcat (juxt count first) (partition-by identity coll))) %))","user":"5633bb9de4b0bfe05bf117b4"},{"problem":110,"code":"(fn seq-pronunciations [xs]\n  (letfn [(pronunciation [nums]\n            (mapcat (juxt count first) (partition-by identity nums)))]\n    (rest (iterate pronunciation xs))))","user":"53504fe6e4b084c2834f4ada"},{"code":"(fn seq-of-pronunciation\n  [coll]\n  (letfn [(step [c] (mapcat #(vector (count %) (first %)) (partition-by identity c)))]\n         (drop 1 (iterate step coll))))","problem":110,"user":"4edf5dc6535d10e5ff6f5340"},{"code":"(fn p\n    [coll]\n    (let [a (reduce #(into %1 %2) (for [k (partition-by identity coll)]\n        [(count k) (first k)]))]\n        (cons a (lazy-seq (p a)))))","problem":110,"user":"50b35486e4b03ea88043356a"},{"problem":110,"code":"(fn pronunciations [n]\n  (let [pronounce-acc (fn [acc n cnt d]\n                        (cond\n                          (empty? n) (conj acc cnt d)\n                          (= d (first n)) (recur acc (next n) (inc cnt) d)\n                          :else (recur (conj acc cnt d) (next n) 1 (first n))))\n        pronounce (fn [n]\n                    (pronounce-acc [] (next n) 1 (first n)))\n        pron (pronounce n)]\n    (lazy-seq (cons pron (pronunciations pron)))))","user":"518279abe4b0353c468deb65"},{"problem":110,"code":"#(letfn [(pronounciation [current-num current-num-count pr-nums nums]\n          (if (seq nums)\n            (let [n (first nums)]\n              (if (= n current-num)\n                (recur current-num (inc current-num-count) pr-nums (rest nums))\n                (recur n 1 (if current-num\n                             (conj pr-nums current-num-count current-num)\n                             pr-nums) (rest nums))))\n            (conj pr-nums current-num-count current-num)))]\n  (rest (iterate (partial pronounciation nil nil []) %)))","user":"56bb652ae4b0f26550335953"},{"code":"(fn pronoun [seq]\n  (lazy-seq \n    (let [x\n          (mapcat #(vector (count %) (first %)) \n                  (partition-by identity seq))]\n              (cons x (pronoun x)))))","problem":110,"user":"4f04b66b535dcb61093f6bdd"},{"problem":110,"code":"(fn [x]\n  (letfn [(pronunciations [xs]\n    (loop [result [] the-list (rest xs) current (first xs) count 1]\n      (if (empty? the-list)\n        (conj result count current)\n        (let [next (first the-list)]\n          (if (= next current)\n            (recur result (rest the-list) current (inc count))\n            (recur (conj result count current) (rest the-list) next 1)\n          )\n        )\n      )\n    )\n  )]\n    (drop 1 (iterate pronunciations x))\n  )\n)","user":"55d79b87e4b0e31453f64aa8"},{"code":"(partial (comp next iterate)\n         #(mapcat (juxt count first) (partition-by identity %)))","problem":110,"user":"4f6160a7e4b0defedf855fbe"},{"code":"(fn pronunciations [s] \n   (let [prn (fn [col]\n               (mapcat \n                (fn [c] [(count c) (first c)]) \n                (partition-by identity col)))\n         fprn (prn s)]\n     (cons fprn (lazy-seq (pronunciations fprn)))))","problem":110,"user":"506d5e4ce4b0a302964c5493"},{"code":"(fn f [l]\n  (rest (iterate (fn [l] (mapcat #(list (count %) (first %)) (partition-by identity l))) l)))","problem":110,"user":"50b668dde4b08fb537db98f2"},{"problem":110,"code":"#(rest (iterate\n        (fn [xs]\n          (reduce (fn [m k] (conj m (count k) (first k)))\n                  [] (partition-by identity xs)))\n        %))","user":"54c5cc17e4b045293a27f624"},{"code":"(fn f [s] \r\n  (let [p #(mapcat (juxt count first) (partition-by identity %))]\r\n    (lazy-seq (cons (p s) (f (p s))))))","problem":110,"user":"4db92654535d1e037afb21a0"},{"problem":110,"code":"(fn pron [xs]\n  (let [res (mapcat (juxt count first) (partition-by identity xs))]\n    (lazy-seq (cons res (pron res)))))","user":"5d81eba4e4b0915913b1d37b"},{"problem":110,"code":"(fn seq-pron [coll]\n  (let [pronouncer (fn [c] (reduce\n                            (fn [a c]\n                              (conj a (count c) (first c)))\n                            []\n                            (partition-by identity c)))\n        seed (pronouncer coll)]\n    (iterate pronouncer seed)))","user":"563fc1f2e4b08d4f616f5ed7"},{"problem":110,"code":"(fn [x]\n  (rest (iterate (fn [start] (let [p (partition-by identity start)]\n                              (interleave (map count p) (map first p)))) x)))","user":"5a621702e4b0512ff01cd983"},{"code":"(fn f [s]\n      (let [y (reverse ( reduce \n         (fn [[a b & m] x]\n           (if (= a x)\n              (concat [a (+ 1 b)] m )\n              (concat [x 1] (concat [a b] m))\n           )\n          ) \n        [(first s) 0] \n        s))] (lazy-seq (concat [y] (f y)))) \n  )","problem":110,"user":"4f1595da535d64f603146444"},{"code":"(fn iter [s]\n  (let [s+1 (mapcat (juxt count first)\n                    (partition-by identity s))]\n    (lazy-seq (cons s+1 (iter s+1)))))","problem":110,"user":"4f8345c6e4b033992c121c1b"},{"code":"(fn pronunciations [coll]\n  (letfn [(group-adjacent [coll]\n                          (loop [rem (next coll) curr [(first coll)] res []]\n                            (if-let [s (seq rem)]\n                              (let [[x & xs] s]\n                                (if (= (first curr) x)\n                                  (recur xs (conj curr x) res)\n                                  (recur xs [x] (conj res curr))))\n                              (conj res curr))))\n          (pronounce [coll]\n                     (->> coll\n                          group-adjacent\n                          (map (juxt count first))\n                          flatten\n                          vec))]\n    (next (iterate pronounce coll))))","problem":110,"user":"5326c5f7e4b09d4e7a9b54f2"},{"code":"(fn prs [sqq]\n  (letfn [(pr [sq]\n            (loop [s sq\n                   num (first s)\n                   c 1\n                   acc [] ]\n              (if (empty? s) acc\n                  (let [r (rest s)]\n                    (if (= num (first r))\n                      (recur r num (inc c) acc)\n                      (recur r (first r) 1 (concat acc [c num])))))))]\n    (let [res (pr sqq)]\n      (cons res (lazy-seq (prs res))))))","problem":110,"user":"4fbd12a5e4b081705acca2fd"},{"code":"(fn [n]\n    (rest \n      (iterate\n        (fn [n]\n          (->>\n            (partition-by + n)\n            (mapcat #(do [(count %) (first %)]))))\n        n)))","problem":110,"user":"4f410b63e4b0e243712b1fc5"},{"problem":110,"code":"(fn [coll] (letfn [(f [c] (flatten (map #(vec [(count %) (first %)]) (partition-by identity c))))] (iterate f (f coll))))","user":"57c647bbe4b05aa3c4741cf3"},{"problem":110,"code":"(fn [coll]\n  (rest (iterate #(mapcat (fn [x] [(count x) (first x)]) (partition-by identity %)) coll)))","user":"54ddb556e4b024c67c0cf798"},{"code":"(fn [lst] (drop 1 \n   (iterate #(\n     (fn [s] (interleave (map count s) (map first s)))\n      (partition-by identity %)\n              )         \n      lst )))","problem":110,"user":"5281a445e4b0757a1b17143a"},{"code":"(fn [v]\n  (letfn\n    [(pronounce [v](reduce #(into %1 [(count %2) (first %2)]) [] (partition-by identity v)))]\n  (iterate pronounce (pronounce v))))","problem":110,"user":"52015698e4b0d7096e99ddba"},{"problem":110,"code":"(fn p [s]\n  (let [g (fn [s]\n            (loop [s s\n                   a []]\n              (if (seq s)\n                (let [f (first s)\n                      n (next s)]\n                  (if (seq n)\n                    (let [cnt (->> n (take-while #(= % f)) count)]\n                      (recur (drop cnt n) \n                             (conj a (inc cnt) f)))    \n                    (conj a 1 f)))\n                a)))\n        s (g s)]\n    (lazy-seq (cons s (p s)))))","user":"549c6792e4b0f3d1d8e70f8b"},{"problem":110,"code":"(fn pronunciations [cl] (when-let [c (seq cl)] \n                      (let [v (loop [c c r []]\n                          (if (empty? c) r \n                              (recur (drop-while #(= (first c) %) c)\n                                     (let [tw (take-while #(= (first c) %) c)] (into r [(count tw) (first tw)]) ) )\n                           ))]\n            (cons v (lazy-seq (pronunciations v)))\n  )))","user":"55adf4d7e4b03311e7b732af"},{"problem":110,"code":"(fn f [start]\n    (let [pronounce\n          (fn [digits]\n            (loop [remaining digits\n                   result []]\n              (if\n                  (empty? remaining)\n                result\n                (let [d (first remaining)\n                      pred (fn [x] (= x d))\n                      c (count (take-while pred remaining))\n                      rest (drop-while pred remaining)]\n                  (recur rest (conj result c d))))))]\n\n      (lazy-seq (cons (pronounce start) (f (pronounce start))))\n      )\n    )","user":"5f06caa7e4b0cf489e8d7f52"},{"code":"(fn pron[xs]\n  (letfn [(pron[ys] (reduce #(conj % (count %2) (first %2)) \n                            [] (partition-by identity ys)))]\n    (iterate pron (pron xs))))","problem":110,"user":"506406c8e4b075d771da6f9f"},{"code":"(letfn [(pronounce\n         [coll]\n         (vec (mapcat (juxt count first) (partition-by identity coll))))]\n  #(iterate pronounce (pronounce %)))","problem":110,"user":"4dad7adac9a9d6ed0599dc57"},{"code":"(fn [l]\n  (rest\n    (iterate\n      #(mapcat (fn[x] (list (count x) (first x)))\n  \t  (partition-by identity %)) l\n)))","problem":110,"user":"4e6e10d8535d5021c1a895fd"},{"problem":110,"code":"(fn pronounce [s]\n  (let [p (vec (mapcat #(list (count %) (first %))\n                       (partition-by identity s)))]\n    (cons p (lazy-seq (pronounce p)))))","user":"54be7772e4b0ed20f4ff6eea"},{"problem":110,"code":"(fn [init]\n  \n  (letfn [(pronounce [item]\n                     (reduce concat (map #(vector (count %) (first %)) (partition-by identity item))))\n          \n          (lazy-pro [item]\n                    (let [pitem (pronounce item)]\n                      (lazy-seq (cons pitem (lazy-pro pitem)))))]\n    \n    (lazy-pro init)))","user":"53d977f1e4b0e771c302547a"},{"problem":110,"code":"(fn lazyPronunc [s]\n              (letfn\n                [(pronuncSeq [x]\n                   (flatten (map #(vector (count %) (first %)) (partition-by identity x))))]\n                (cons (pronuncSeq s) (lazy-seq (lazyPronunc (pronuncSeq s))))))","user":"56427910e4b08d4f616f5f19"},{"code":"(fn [v] (next (iterate #(mapcat (juxt count first) (partition-by identity %)) v)))","problem":110,"user":"500854c4e4b028e089d3518c"},{"code":"(fn pronounce-seq [i]\n  (let [pronounce (fn [p] (vec (flatten (map #(list (count %) (Integer/parseInt (first %))) (clojure.core/reverse (loop [cc (re-seq #\"[\\d]\" (str p)) i (first cc) m (list) r (list)] (if (empty? cc) (conj m r) (if (= (first cc) i) (recur (rest cc) i m (conj r i)) (recur (rest cc) (first cc) (conj m r) (list (first cc)))))))))))\n        p (pronounce i)] (lazy-seq (concat [p] (pronounce-seq p)))))","problem":110,"user":"4f0e4ebd535d0136e6c22322"},{"code":"(fn [i]\n  (let [f #(mapcat \n             (fn [[a :as b]] [(count b) a]) \n             (partition-by identity %))]\n    (iterate f (f i))))","problem":110,"user":"5201572be4b0d7096e99ddbb"},{"problem":110,"code":"(fn pronunciations [xs]\n  (let [c (let [ps (partition-by identity xs)]\n            (mapcat (fn [p] [(count p) (first p)]) ps))]\n    (cons c (lazy-seq (pronunciations c)))))","user":"5866b999e4b0f14aab7c886b"},{"problem":110,"code":"(fn f [p s]\n  (lazy-seq (cons (p s) (f p (p s)))))\n#(mapcat\n  (juxt count first)\n  (partition-by int %))","user":"505106fee4b05ab4c7e07d38"},{"code":"(fn abc [lat]\n         (letfn [(fre [lat] (if (empty? lat)\n                        []\n                        (let [f (first lat)\n                              v (into [] (for [l lat :while (= l f)] l))\n                              k (count v)]\n                          (cons k (cons f (fre (nthrest lat  k)))))))]\n           (let [f (fre lat)]\n             (cons f (lazy-seq (abc f)))))\n         )","problem":110,"user":"5125029de4b0ce9225d2ed3e"},{"problem":110,"code":"(fn pronounce [s]\n  (let [next-fn (fn [s] \n                  (into [] (mapcat \n                             (fn [s] \n                               [(count s) (first s)])\n                             (partition-by identity s))))\n        next-val (next-fn s)]\n      (cons next-val (lazy-seq (pronounce next-val)))))","user":"550c55d0e4b06e50f9beb14d"},{"problem":110,"code":"(fn solve [coll]\n  (drop\n   1\n   (iterate\n    (fn [c]\n      (flatten (map #(vector (count %) (first %))\n                    (partition-by identity c))))\n    coll)))","user":"60537cd1e4b04c8f2157d152"},{"problem":110,"code":"(fn pronouciations-seq [sequ]\n  (let [pronouciations (fn [sequ]\n\t\t\t\t\t\t\t\t\t\t\t  (loop [curseq (rest sequ)\n\t\t\t\t\t\t\t\t\t\t\t         curel (first sequ)\n\t\t\t\t\t\t\t\t\t\t\t         curcount 1 \n\t\t\t\t\t\t\t\t\t\t\t         result []]\n\t\t\t\t\t\t\t\t\t\t\t    (let [nextel (first curseq)]\n\t\t\t\t\t\t\t\t\t\t\t      (if (nil? nextel)\n\t\t\t\t\t\t\t\t\t\t\t        (conj (conj result curcount) curel)\n\t\t\t\t\t\t\t\t\t\t\t        (if (= curel nextel)\n\t\t\t\t\t\t\t\t\t\t\t          (recur (rest curseq) curel (inc curcount) result)\n\t\t\t\t\t\t\t\t\t\t\t          (recur (rest curseq) nextel 1 (conj (conj result curcount) curel)))))))\n        newseq (pronouciations sequ)]\n    (cons newseq (lazy-seq (pronouciations-seq newseq)))))","user":"5df0c6ffe4b093ff717275c2"},{"problem":110,"code":"(fn [coll]\n  (drop 1\n    (iterate (fn [x]\n               (mapcat #(list (count %) (first %))\n                       (partition-by identity x)))\n             coll)))","user":"572de985e4b0cd1946bd0f7c"},{"code":"(fn [y]\n(rest (iterate (fn [x] (flatten (map #(identity [(count %1) (first %1)]) (partition-by identity x)))) y))\n)","problem":110,"user":"52593207e4b0cb4875a45cd3"},{"code":"(fn lazy-pron [s]\r\n  (let\r\n    [pron (fn pron [x]\r\n            (if (empty? x) []\r\n              (let \r\n                [first-elt (first x)\r\n                 _ (println \"first elt\" first-elt)\r\n                 nfe (count (take-while #(= first-elt %) x))\r\n                 _ (println \"nfe\" nfe)\r\n                 new-x (drop nfe x)\r\n                 _ (println \"new x\" new-x)]                 \r\n                 (concat [nfe first-elt] (pron new-x)))))\r\n     new-s (vec (pron s))]\r\n     (lazy-seq (cons new-s (lazy-pron new-s)))))","problem":110,"user":"4f036fb3535dcb61093f6ac8"},{"code":"(fn [sq]\n  (let [pronounce\n    (fn pronounce [sq]\n      (if (empty? sq) []\n        (let [fritem (first sq)]\n          (concat [(count (take-while #(= fritem %) sq)) fritem]\n            (pronounce (drop-while #(= fritem %) sq))))))]\n    (rest (iterate pronounce sq))))","problem":110,"user":"515737f0e4b0b0b4b87062d0"},{"problem":110,"code":"(fn [initial-numbers]\n  (next (iterate (fn [numbers]\n                   (mapcat (juxt count first) (partition-by identity numbers)))\n                 initial-numbers)))","user":"54cc26c1e4b057c6fda3a28a"},{"problem":110,"code":"(fn pro [c]\n\t(lazy-seq\n\t\t(let [e (mapcat #(conj [(count %)] (first %)) (partition-by identity c))]\n\t\t(cons e (pro e)))))","user":"565b2fa5e4b068f2fe63dbfe"},{"code":"(fn ! [s]     \n    (letfn [(nextpron [nums]                                                                                \n               (if-let [s (seq nums)]                                                                             \n                  (let [curr (first s)                                                                             \n                        res (split-with  #(= curr %) s)                                                            \n                        idents (first res)                                                                         \n                        rst (last res)]                                                                            \n                    (concat [(count idents) curr] \n                            (nextpron rst)))                                                 \n                     nums))]\n    (let [nxt (nextpron s)]                                                                          \n      (lazy-seq (cons nxt (! nxt))))                                                                 \n    ))","problem":110,"user":"4f1d1299535d64f603146487"},{"code":"(comp rest (partial iterate\n  (comp (partial mapcat #(vector (count %) (first %)))\n    (partial partition-by identity))))","problem":110,"user":"4f03ac2d535dcb61093f6b4a"},{"code":"(fn [nums]\n    (let [pronounce \n            (fn [nums]\n                (->> (partition-by identity nums)\n                     (mapcat #(list (count %) (first %)))\n                ))\n        ]\n        (rest (iterate pronounce nums))\n    ))","problem":110,"user":"4df3d4f4535d08e6dec9fe2c"},{"problem":110,"code":"(fn [s] \n  (letfn [(pronounce [s] (mapcat #(vector (count %) (first %)) (partition-by identity s)))]\n    (iterate pronounce (pronounce s))))","user":"5dc9ccf8e4b02f9375f4e1f1"},{"code":"(fn [v]\n  (letfn [(seq-pron \n  \t\t\t[v]\n  \t\t\t(vec (mapcat #(vector (count %) (first %)) (partition-by identity v))))]\n  (drop 1 (iterate seq-pron v))))","problem":110,"user":"4fdf566fe4b05e33b9224f99"},{"code":"(fn [x]\n  (rest (iterate #(mapcat (juxt count first)\n                          (partition-by identity %))\n                 x)))","problem":110,"user":"4dbb0b6c535d1e037afb21b0"},{"code":"(fn [x] (rest ((partial iterate (fn [l] (reduce #(conj (conj % (count %2)) (first %2)) [] (partition-by identity l)))) x)))","problem":110,"user":"52570aeae4b0541d1855ba42"},{"problem":110,"code":"(fn [init]\n  (letfn [(pronounce [items]\n                     (mapcat (fn [item] [(count item) (first item)]) (partition-by identity items)))]\n    (iterate pronounce (pronounce init))))","user":"56897739e4b0dcc4269f407d"},{"code":"(fn [x]  (rest (iterate (fn p [s]             (if (empty? s) []               (let [c (#(loop [c % r 1] (if (= (first c) (fnext c)) (recur (rest c) (inc r)) r)) s)]                 (vec (concat [c (first s)] (p (drop c s)))))))           x)))","problem":110,"user":"50bc23e4e4b0594b91591c3c"},{"problem":110,"code":"(fn pron [coll]\n  (rest (iterate \n         (fn [coll] \n           (flatten (map #(vector (count %) (first %)) (partition-by identity coll)))) coll)))","user":"52d00832e4b07d0d72b273b4"},{"code":"(fn [init]\n  (let [f (fn [i]\n      (mapcat #(vec [(count %) (first %)])\n\t\t    (partition-by identity i)))]\n    (iterate f (f init))))","problem":110,"user":"4e7d1c22535db169f9c796c5"},{"problem":110,"code":"(fn pron [vals]\n         (let [v (mapcat #(into [] [(count %) (first %)]) (partition-by identity vals))] \n           (lazy-seq (cons v (pron v)))))","user":"58d27bcae4b03c36ff7e58fe"},{"code":"(fn prnc [seed]\n  (letfn [(aux [coll] (mapcat #(vector (count %) (first %))\n                              (partition-by identity coll)))]\n    (let [res (aux seed)]\n      (cons res (lazy-seq (prnc res))))))","problem":110,"user":"500ff421e4b0ae202717946f"},{"problem":110,"code":"(fn [xs]\n  (drop 1 (iterate (fn [xs]\n                     (->> (partition-by identity xs)\n                          (map #(list (count %) (first %)))\n                          (flatten))) xs)))","user":"5eee7311e4b07c55ae4a0510"},{"problem":110,"code":"(fn [col]\n  (drop 1\n    (iterate \n      (fn [c] \n        (mapcat \n          #(-> [(count %) (first %)]) \n          (partition-by identity c))) \n      col)))","user":"58f44c07e4b0438e51c2ceb7"},{"problem":110,"code":"(fn pronounce-all\n  [beginning]\n  (let [pronounce (fn [alist]\n                    (->> (partition-by identity alist)\n                         (mapcat (fn [a] [(count a) (first a)]))))]\n    (rest (iterate pronounce beginning))))","user":"550d9452e4b06e50f9beb15d"},{"problem":110,"code":"(fn pron [n] (rest (reductions #(%2 %1) n (cycle [#(mapcat (juxt count first) (partition-by identity %))]))))","user":"542c1f73e4b0dad94371f29d"},{"code":"(fn [s]\n  (next\n   (reductions\n    (fn f [[a :as s] _]\n      (if a\n        (let [[p q] (split-with #(= a %) s)]\n          (conj (f q _) a (count p)))))\n    s (range))))","problem":110,"user":"4e71705e535d5021c1a89649"},{"code":"(fn proun [v]\n  (let [ret (loop [acc [] cnt v]\n              (if (empty? cnt)\n                acc\n                (let [[h t] (split-with #(= % (first cnt)) cnt)]\n                  (recur (conj acc (count h) (first h)) t))))]\n    (cons ret (lazy-seq (proun ret)))))","problem":110,"user":"4eec82fe535d93acb0a668ae"},{"problem":110,"code":"#(letfn [(pronounce [coll]\n                    (mapcat (fn [c] [(count c) (first c)])\n                            (partition-by identity coll)))]\n   (next (iterate pronounce %)))","user":"51780bfce4b0f89a8f53839c"},{"problem":110,"code":"(fn pronounce-seq [s]\n  (let [pronounce (fn [s]\n                    (->> (partition-by identity s)\n                         (map #(vector (count %) (first %)))\n                         (apply concat)))\n        sp (pronounce s)]\n    (lazy-seq\n      (cons sp (pronounce-seq sp)))))","user":"53834ed3e4b06839e8705edb"},{"problem":110,"code":"(fn pronunciations [c]\n  (letfn [(pronunciate [s]\n            (mapcat (juxt count first) (partition-by identity s)))]\n    (iterate pronunciate (pronunciate c))))","user":"572ea970e4b0cd1946bd0f89"},{"problem":110,"code":"(fn pronunciations [init]\n  (letfn [(pronunciation [& init]\n                         (reduce #(conj % (count %2) (first %2)) [] (partition-by identity (last init))))]\n    (rest (iterate pronunciation init))))","user":"56288ccae4b00e49c7cb47ea"},{"problem":110,"code":"(fn [n]\n  (rest (iterate \n         (fn [n] (mapcat #(vector (count %) (first %))(partition-by identity n))) n)))\n\n;;(fn [x] (rest (iterate #(mapcat (juxt count first) (partition-by identity %)) x)))","user":"544cf5d7e4b0e39780006977"},{"code":"(fn [s]\n  (rest\n   (iterate\n    #(->> (partition-by identity %)\n          (map (juxt count first))\n          (apply concat))\n    s)))","problem":110,"user":"5175533fe4b0dea9bbfba575"},{"code":"(fn __ [v]\n  (let [read-v (flatten (map #(vector (count %) (first %))\n                             (partition-by identity v)))]\n       (lazy-seq (cons read-v (__ read-v)))))","problem":110,"user":"4ec9549d535d6d7199dd36fe"},{"code":"(fn pronounce [s]\n  (let [p (apply concat\n            (map #(vector (count %) (first %))\n              (partition-by identity s)))]\n    (cons p (lazy-seq (pronounce p)))))","problem":110,"user":"515a6151e4b0394f658fe241"},{"code":"(fn seq-of-pronunciations [coll]\n  (letfn [(rle [coll]\n            (first\n              (reduce\n                (fn [[result prev-elt prev-elt-count] curr-elt]\n                  (if (= curr-elt prev-elt)\n                    [result prev-elt (inc prev-elt-count)]\n                    [(conj result prev-elt-count prev-elt) curr-elt 1]))\n                [[] (first coll) 1] (rest (conj coll :sentinel)))))]\n    (let [rle-coll (rle coll)]\n      (cons rle-coll (lazy-seq (seq-of-pronunciations rle-coll))))))","problem":110,"user":"53070615e4b02e821686979e"},{"problem":110,"code":"(fn t [xs]\n  (let [n (into [] (->> xs (partition-by identity) (mapcat (juxt count first))))]\n    (cons n (lazy-seq (t n)))))","user":"55597b84e4b0deb715856e36"},{"code":"(fn [s]\r\n  (drop 1 (iterate\r\n    #(->> %\r\n      (partition-by identity)\r\n      (map (juxt count first))\r\n      (apply concat))\r\n    s)))","problem":110,"user":"504e14c2e4b078edc5f593bf"},{"problem":110,"code":"(fn [x ] (rest (iterate \n(fn [col]\n  (->>\n   (partition-by identity col)\n   (map #(vector (count %) (first %)) )\n   (flatten))) x)))","user":"54af6fb0e4b09f271ff37d08"},{"code":"(fn [c]\n  (rest \n    (iterate (fn [c]\n      (flatten\n        (reduce #(conj %1 [(count %2) (first %2)]) []\n          (partition-by identity c))))\n      c)))","problem":110,"user":"4e6f4cbc535d5021c1a8961a"},{"code":"(fn pron [ns]\n  (lazy-seq\n    (let [n (flatten (map\n                       #(vector (count %) (first %))\n                       (partition-by identity ns)))]\n      (cons n (pron n)))))","problem":110,"user":"50f48298e4b004d364930527"},{"problem":110,"code":"(fn [xs] (letfn [\n  (s-grps [ys] \n   (if (empty? ys) []\n    (reduce (fn [acc b] \n     (if (= b (peek (peek acc)))\n      (conj (pop acc) (conj (peek acc) b))\n      (conj acc [b]))) \n     [[(first ys)]] \n     (rest ys))))\n  (grp-pr [v] \n     [(count v) (peek v)])\n\n  (prons [zs] \n   (let [prns2v (map grp-pr (s-grps zs))] \n\n    (reduce (fn [acc b]\n      (into acc b)) [] prns2v)) )\n\n  (pron-seq [iv] \n   (if (empty? iv) []\n   (let [neuv (prons iv)]\n    (lazy-seq\n    (cons neuv (pron-seq neuv))))))] (pron-seq xs) ))","user":"57f9011ee4b0d3187e900935"},{"problem":110,"code":"(fn pronounce [xs]\n  (let [results (->> (partition-by identity xs)\n                     (mapcat #(vector (count %) (first %))))]\n    (cons results (lazy-seq (pronounce results)))))","user":"5ec3a13ae4b08d0ec38692b9"},{"code":"(fn aa [xx]\n  (let [z\n\n     (mapcat identity (for [x (partition-by identity xx)]\n       [(count x) (first x)]\n      ))]\n   \n  (lazy-seq\n    (cons z (aa z)))\n)\n     \n  )","problem":110,"user":"5105ed16e4b01150e115ebe2"},{"problem":110,"code":"(fn p [s]\n  (->> s\n       (iterate (fn [s] (mapcat #(vector (count %) (first %)) (partition-by identity s))))\n       rest))","user":"53b39d82e4b047364c0444a6"},{"problem":110,"code":"(letfn [(prn [xs] (->> (partition-by identity xs)\n                       (mapcat #(list (count %) (first %)))))]\n  #(rest (iterate prn %)))","user":"54055aa9e4b0addc1aec6665"},{"code":"(fn [xs]\n  (letfn [(pronounce [xs]\n            (->> xs\n              (partition-by identity)\n              (mapcat frequencies)\n              (mapcat reverse)))]\n    (rest (iterate pronounce xs))))","problem":110,"user":"4e994541535dbda64a6f6b64"},{"problem":110,"code":"(fn [coll]\n  (let [f #(mapcat (juxt count first) (partition-by identity %))]\n    (iterate f (f coll))))","user":"559b2ad1e4b066d22e731f4e"},{"code":"(fn f [x] \n  (let [n (flatten (map (juxt count first) (partition-by identity x)))]\n    (lazy-seq (cons n (f n)))))","problem":110,"user":"512f06c5e4b0762be4c7aad7"},{"code":"(fn f110 [coll]\n  (drop 1\n    (iterate\n      (fn [coll1]\n        ((fn [curr c rcoll res]\n           (if (seq rcoll)\n             (let [v (first rcoll)]\n               (if (= v curr)\n                 (recur curr (inc c) (rest rcoll) res)\n                 (recur v 1 (rest rcoll) (conj (conj res c) curr))))\n             (conj (conj res c) curr)))\n         (first coll1) 1 (rest coll1) [])) coll)))","problem":110,"user":"4ec75077535d6d7199dd36e0"},{"code":"(letfn [(rle [coll] (mapcat #(list (count %) (first %)) (partition-by identity coll)))]\n\t(fn [coll] (iterate rle (rle coll))))","problem":110,"user":"532347dde4b09d4e7a9b54cc"},{"code":"(fn [s]\n   (letfn[(pronounce [x]              \n              (reduce concat\n                      (map \n                        #(vector (count %) (first %))\n                        (partition-by identity x))))]\n    (iterate pronounce (pronounce s))))","problem":110,"user":"4f4c6b21e4b03ad3f0c10c8f"},{"problem":110,"code":"(fn pronounce [data]\n  (let [numbers\n        (flatten\n         (map\n          #(vector (count %) (first %))\n          (partition-by identity data)))]\n    (lazy-seq\n     (cons numbers (pronounce numbers)))))","user":"4ee897fe535d93acb0a66883"},{"code":"(fn f [ls]\r\n  (let [\r\n        pron (fn [xs] \r\n               (->> xs\r\n                    (partition-by identity)\r\n                    (map (fn [x] \r\n                           [ (count x) (first x) ]))\r\n                    (apply concat)\r\n               ))   \r\n         pr    (pron ls)\r\n        ]\r\n    (cons pr\r\n          (lazy-seq (f pr)))))","problem":110,"user":"502a9fdee4b095a7adb898b4"},{"problem":110,"code":"(fn [s]\n  (letfn [(next-p [s]\n              (->> (partition-by identity s)\n                   (map (juxt count first))\n                   (mapcat identity)\n                   vec))]\n    (rest (iterate next-p s))))","user":"553b0d95e4b09218d5f44fff"},{"code":"(fn sp [start]\n  (let [pr-digit (fn[n] [(count n) (first n)])\n        pr-digits (fn [s]\n          (mapcat pr-digit (partition-by identity s)))]\n    (lazy-seq\n      (cons (pr-digits start) (sp (pr-digits start))))))","problem":110,"user":"4dbd2aa3535d020aff1edf40"},{"code":"(letfn [(p [s] (->> s\n     (partition-by identity)\n     (mapcat (juxt count first))\n     ))]\n\n    #(iterate p (p %)))","problem":110,"user":"503917a0e4b088a6a14ca763"},{"code":"(fn [s]\n  (rest\n    (iterate\n      (fn pronounce [xs]\n        (when (seq xs)\n          (let [f (first xs), [fs rs] (split-with (partial = f) xs)]\n            (cons (count fs) (cons f (pronounce rs))))))\n      s)))","problem":110,"user":"506ab9bae4b05d3b7762c74c"},{"code":"(fn [x]\n  (rest (iterate (fn [y] (mapcat #(list (count %) (first %)) (partition-by identity y))) x)))","problem":110,"user":"507ef25ce4b0f753b6f9788e"},{"problem":110,"code":"(fn [xs]\n    (letfn [(add-seq [agg s1] (apply conj agg s1))\n            (inc-first [[fst snd]] [(inc fst) snd])\n            (pronounce-seq [ys hist acc]\n              (lazy-seq\n               (let [[y & rst] ys\n                     [cnt prev] hist]\n                 (cond\n                   (nil? (seq ys)) (cons (add-seq acc hist)\n                                         (pronunciation (add-seq acc hist)))\n                   (not= y prev) (pronounce-seq rst\n                                                [1 y]\n                                                (add-seq acc hist))\n                   (= y prev) (pronounce-seq rst\n                                             (inc-first hist)\n                                             acc)))))\n            (pronunciation [[z & zs]] (pronounce-seq zs [1 z] []))]\n      (trampoline pronunciation xs)))","user":"560e9a2de4b05f002753df52"},{"problem":110,"code":"(fn [s]\n  (let [prnc (fn [S]  (vec (flatten (map #(vector (count %) (first %))(partition-by identity S)))))]\n   (drop 1 (iterate prnc s)))\n )","user":"5649615be4b0284900eef641"},{"code":"(fn pronounce [s]\n  (lazy-seq\n   (let [next (mapcat #(vector (count %) (first %))\n                      (partition-by identity s))]\n     (cons next (pronounce next)))))","problem":110,"user":"4dd0e8f7535da60f04a96e57"},{"problem":110,"code":"(fn p [l]\n  (lazy-seq\n   (let [o (loop [r l\n                  a []\n                  p 0 \n                  v (first l)]\n             (if (empty? r)\n               (conj a p v)\n               (if (= v (first r))\n                 (recur (next r) \n                        a\n                        (inc p)\n                        (first r))\n                 (recur (next r)\n                        (conj a p v)\n                        1\n                        (first r)))))]\n    (cons o (p o)))))","user":"55995fa7e4b031d6649c9ba9"},{"problem":110,"code":"(fn ps[v] (rest (iterate (fn[s] (vec (mapcat #(-> [(count %) (first %)]) (partition-by identity s)))) v)))","user":"56824e1be4b0945ebc182a91"},{"code":"(fn [in]\n  (letfn [(f [l]\n            (loop [r []\n                   [x :as y] l]\n              (if (empty? y)\n                r\n                (let [c (count (take-while #(= x %) y))]\n                  (recur (into r [c x])\n                         (drop c y))))))\n          (g [i] (cons (f i) (lazy-seq (g (f i)))))]\n    (g in)))","problem":110,"user":"4e773be8535d324fb2983d6e"},{"code":"(fn [xs]\n  (letfn [(f [xs] (->> xs (partition-by identity)\n                    (mapcat #(vector (count %) (first %)))))]\n    (drop 1 (iterate f xs))))","problem":110,"user":"508157b2e4b0946d0443855c"},{"problem":110,"code":"(fn [xs]\n  (rest\n    (iterate\n      (fn [xs]\n        (apply concat\n          (map (fn [[x :as xs]]\n                 [(count xs) x])\n               (partition-by identity xs))))\n      xs)))","user":"562cd94ee4b0a45d2ff83015"},{"problem":110,"code":"(fn [col]\n (letfn [(p [col]\n          (mapcat #(concat [(count %)] (distinct %)) (partition-by identity col)))\n         (s\n          ([] (s (p col)))\n          ([col] (lazy-seq (cons col (s (p col))))))]\n  (s)))","user":"5b0180cfe4b0cc2b61a3bd47"},{"problem":110,"code":"(fn [l]\n  (letfn [(pronounce [x] (mapcat (juxt count first) (partition-by identity x)))]\n    (iterate pronounce (pronounce l))))","user":"4fc8c8d8e4b0ee37620e183b"},{"problem":110,"code":"(fn solve [x]\n  (let [nxt (fn [a] (vec (mapcat #(vector (count %) (first %)) (partition-by identity a))))]\n    (drop 1 (iterate nxt x))))","user":"56f258d3e4b04a395b9a04a1"},{"problem":110,"code":"(fn sop ([l]\n  (let [fre (fn [coll]\n                (let [gp (partition-by identity coll)] \n                     (map #(vector (count %) (first %)) gp)))\n        pro (fn pro ([x] (flatten (fre x))))]\n       (cons (pro l) (lazy-seq (sop (pro l)))))))","user":"544e8369e4b0e39780006987"},{"code":"(fn pronunciations [coll]\n  (letfn [(pron [coll] \n            (mapcat (juxt count first) \n                    (partition-by identity coll)))]\n    (iterate pron (pron coll))))","problem":110,"user":"4e7263a1535d5021c1a8965f"},{"problem":110,"code":"#(letfn [\n          (pron-next[coll]\n            (loop [v coll prev (first v)  n 0 ret []]\n              (if (empty? v)\n                (vec (concat ret [n prev]))\n                (let [cur (first v)]\n                  (if (= cur prev)\n                    (recur (rest v) prev (inc n) ret) \n                    (recur (rest v) cur 1 (concat ret [n prev])) \n                  )\n                )\n              )\n            )\n          )\n       ]\n  \n  (iterate pron-next (pron-next %))\n)","user":"545537c1e4b0e397800069dd"},{"problem":110,"code":"(fn pronunciations [xs]\n  (lazy-seq\n   (let [ys (reduce #(conj % (count %2) (first %2))\n                    []\n                    (partition-by identity xs))]\n\n     (cons ys (pronunciations ys)))))","user":"58b81490e4b0ebc645576d8c"},{"code":"(fn [c]\r\n  (rest (iterate (fn [x] \r\n                   (let [p (partition-by identity x)]\r\n                     (mapcat #(list (count %) \r\n                                    (first %)) p))) c)))","problem":110,"user":"4fb37882e4b081705acca2a0"},{"problem":110,"code":"(fn [ns] (drop 1(iterate (fn [n] (->> n (partition-by identity)\n                                     (mapcat (juxt count first))\n                                     (into []))) ns)))","user":"54d7e277e4b0a52adc2e2031"},{"code":"(fn pronunc [ns]\n  (letfn [(impl [ns]\n    (reverse\n      (reduce\n        #(cond \n          (empty? %1) (list %2 1)\n          (= %2 (first %1)) \n            (list* %2 (inc (second %1)) (next (next %1)))\n          :else\n            (list* %2 1 %1))\n        '()\n         ns)))]\n    (let [r (impl ns)]\n      (lazy-seq\n        (cons r (pronunc r))))))","problem":110,"user":"4f050dec535dcb61093f6bef"},{"code":"(fn [z] (drop 1 (iterate (fn [x] (mapcat #(vector (count %) (first %)) (partition-by identity x))) z)))","problem":110,"user":"4feada56e4b0140c20fb9c11"},{"problem":110,"code":"(fn pronounce [coll]\n  (letfn [(gen-next\n            [coll]\n            (->> coll\n                 (partition-by identity)\n                 (mapcat (fn [coll]\n                           [(count coll) (first coll)]))))]\n    (iterate gen-next (gen-next coll))))","user":"571c2babe4b07c98581c3b73"},{"code":"(fn [coll]\n  (rest (iterate (fn [coll]\n                   (loop [coll   coll\n                          result []]\n                     (if-not coll\n                       (flatten result)\n                       (recur (next coll)\n                              (vec\n                               (let [[counter current-record] (last result)\n                                     current-number           (first coll)]\n                                 (if (= current-number current-record)\n                                   (concat (butlast result)\n                                           [[(inc counter) current-number]])\n                                   (concat result\n                                           [[1 current-number]]))) )))))\n                 coll)))","problem":110,"user":"509e62a8e4b08df8156e9e2e"},{"code":"(fn pronounce [s]\n  (letfn [(next-val [s]\n            (loop [nums s\n                   result []]\n              (if (seq nums)\n                (let [n (first nums)\n                      c (count (take-while #(= n %) nums))]\n                  (recur (drop c nums)\n                         (conj result c n)))\n                result)))]\n    (let [result (next-val s)]\n      (lazy-seq (cons result (pronounce result))))))","problem":110,"user":"5236b6bce4b05f3be1c7c8fe"},{"code":"(fn pronunciations [coll]\n  (rest\n    (iterate\n      #(mapcat (juxt count first)\n        (partition-by identity %))\n      coll)))","problem":110,"user":"4ec2fe3f535dcc7ae8597d4f"},{"problem":110,"code":"(fn f [xs]\n    (let [vale (->> (partition-by identity xs)\n                    (map #(frequencies %))\n                    (map #(concat (vals %) (keys %)))\n                    (flatten))]\n      (lazy-seq\n        (cons vale (f vale)))\n      )\n    )","user":"596d630ae4b069c0a1a19846"},{"problem":110,"code":"(fn pronounciations [coll]\n  (let [pronounce (->> (partition-by identity coll)\n                       (mapcat (fn [els] [(count els) (first els)])))]\n    (lazy-seq (cons pronounce (pronounciations pronounce)))))","user":"5344fe13e4b084c2834f4a32"},{"code":"(fn [v] (rest (iterate  (fn [s] (apply concat (map (fn [p] [(count p) (first p)]) (partition-by (fn [a] a) s)))) v)))","problem":110,"user":"50bce014e4b0594b91591c63"},{"code":"(fn [xs] (let [f #(->> % (partition-by identity) (mapcat (juxt count first)))] (iterate f (f xs))))","problem":110,"user":"52dc2bc8e4b09f7907dd13ca"},{"code":"(fn [seed]\n  (rest\n   (iterate\n    (fn [x]\n      (mapcat #(list (count %) (first %))\n              (partition-by identity x)))\n    seed)))","problem":110,"user":"50fa01bce4b07934dda8b0ba"},{"problem":110,"code":"(fn seq-pron\n  [coll]\n  (let [res\n        (mapcat #(vector (count %) (first %)) (partition-by identity coll))]\n    (cons res (lazy-seq (seq-pron res)))))","user":"5594e0e3e4b0c79f6e1db95b"},{"problem":110,"code":"(fn pronounce [input]\n  (let [identical #(take-while (partial = (first %)) %)\n        pronunciation (loop [result [], queue input]\n            (if (empty? queue) result\n              (recur\n                (concat result [(count (identical queue)) (first queue)])\n                (drop (count (identical queue)) queue))))]\n    (lazy-seq (cons pronunciation (pronounce pronunciation)))))","user":"58247423e4b051871117bec5"},{"problem":110,"code":"(fn pronounciations\n  [init]\n  (let [next* (->> (partition-by identity init)\n                   (mapcat (fn [group] [(count group) (first group)])))]\n    (lazy-seq (cons next* (pronounciations next*)))))","user":"6098263be4b00e9e6653c3f9"},{"code":"(fn pronunce\n    [coll]\n    (let [fun (fn pronunce-helper\n                [input-coll]\n                (mapcat (juxt count first)\n                        (partition-by identity input-coll)))]\n      (iterate fun (fun coll))))","problem":110,"user":"4e4e5b91535dc968683fc4e5"},{"code":"(fn p* [s]\n  (letfn [(p [ss]\n            (loop [s (next ss) r [] i (first ss) c 1]\n              (if s\n                (if (= (first s) i)\n                  (recur (next s) r i (inc c))\n                  (recur (next s) (conj r c i) (first s) 1))\n                (conj r c i))))]\n    (let [r (p s)]\n      (cons r (lazy-seq (p* r))))))","problem":110,"user":"4dbdc9da535d020aff1edf4c"},{"problem":110,"code":"(fn prononciation [coll]\n  (let [value (reduce (fn [stock el] (concat stock [(count el) (first el)])) [] (partition-by identity coll))]\n  \t(cons  value (lazy-seq (prononciation value)))\n    )\n  )","user":"5776558ee4b0979f89651633"},{"code":"(fn seqpro [coll]\n  (letfn [(seqpvec [coll] (flatten \n\t(map #(vector (count %) (first %))\n\t(loop [coll coll res []]\n\t\t(if (seq coll)\n\t\t\t(let [split (split-with #(= %1 (first coll)) coll)]\n\t\t\t\t(recur (second split) (conj res (first split)))\n\t\t\t)\n\t\t\tres\n\t\t)\n\t)\n\t)\n\t))]\n\t(iterate seqpvec (seqpvec coll))\n\t)\n)","problem":110,"user":"50588af1e4b06522596eba7d"},{"problem":110,"code":"(fn [xs]\n  (rest (iterate (fn [ys] \n            (mapcat #(vector (count %) (first %)) (partition-by identity ys))) xs)))","user":"53976599e4b0b51d73faaeea"},{"problem":110,"code":"(fn pronunciations [coll]\n  (let [\n      result \n      (reduce \n        (fn [reduced item]\n          (cond\n            (empty? reduced) (vec (conj reduced 1 item))\n            (= item (last reduced)) (update-in reduced [(- (count reduced) 2)] inc)\n            :else\n              (vec (conj reduced 1 item))\n          )   \n        )\n      [] coll)]\n    (lazy-seq (cons result (pronunciations result)))\n  )\n)","user":"5991d2fae4b0866487ed0d68"},{"problem":110,"code":"(fn sp [s]\n  (let [ss (mapcat #(vector (count %) (first %)) (partition-by identity s))]\n    (lazy-seq (cons ss (sp ss)))))","user":"52ce1abfe4b07d0d72b27389"},{"problem":110,"code":"(fn pron [sq]\n  (letfn [(pron-one [s]\n            (println \">\" s)\n            (loop [res []\n                   others (rest s)\n                   cur (first s)\n                   nb 1]\n              (println \">>\" res others cur nb)\n              (if (empty? others)\n                (conj res nb cur)\n                (if (= cur (first others))\n                  (recur res (rest others) cur (inc nb))\n                  (recur (conj res nb cur) (rest others) (first others) 1)))))]\n          (drop 1 (iterate pron-one sq))))","user":"51b920bfe4b0e871ca4958f9"},{"problem":110,"code":"(fn [coll]\n  (rest (iterate #(flatten (map (juxt count first) (partition-by identity %))) coll)))","user":"5b88f0c0e4b047b03b203816"},{"code":"#(rest (iterate % %2))\n#(mapcat (juxt count first) (partition-by min %))","problem":110,"user":"4ee4f4a9535d1385b2869d85"},{"problem":110,"code":"(fn [k] \n   (rest \n    (iterate \n     (fn [c] \n       (mapcat (juxt count first) (partition-by identity c))\n       )\n     k)))","user":"5412646de4b01498b1a719d4"},{"code":"(letfn [(pronounce [s] (mapcat (fn [p] [(count p) (first p)]) (partition-by identity s)))]\n  (fn prs [s] \n    (let [p (pronounce s)]\n      (cons p (lazy-seq (prs p))))))","problem":110,"user":"4e9a1512535dbda64a6f6b6e"},{"problem":110,"code":"(fn sp[v]\n  (let [prt (partition-by identity v)\n        spn (flatten (map #(list (count %)(first %)) prt ))]\n    (cons spn (lazy-seq (sp spn)))))","user":"54d4bd2be4b0a52adc2e2005"},{"problem":110,"code":"(fn [c] (rest (iterate #(mapcat (fn [x] [(count x) (first x)]) (partition-by num %)) c)))","user":"5d764e52e4b02e6b30c93524"},{"code":"(fn pronunciations [s]\n  (letfn\n      [(pron [s]\n        (let\n            [[prev, cnt, result]\n              (reduce\n                (fn [[prev, cnt, result], b]\n                  (cond\n                    (nil? prev) [b, 1, result],\n                    (= prev b) [b, (+ 1 cnt), result],\n                    :else\n                      [b, 1, (conj result [cnt prev])])),\n                [nil, 0, []],\n                s)]\n          (apply concat (conj result [cnt prev]))))]\n      (lazy-seq\n            (when-let [s (seq s)]\n              (let [ps (pron s)]\n                (cons ps (pronunciations ps)))))))","problem":110,"user":"4f5c0549e4b0030a34fb2b1a"},{"problem":110,"code":"(fn [coll]\n  (let [pf (fn [xs] (reduce #(into % [(count %2) (first %2)]) [] (partition-by identity xs)))]\n    (iterate pf (pf coll))))","user":"5392bfdee4b0b51d73faaeb2"},{"problem":110,"code":"(fn pron [seq]\n  (drop 1\n        (iterate\n         (fn [xs]\n           (loop [coll xs, acc []]\n             (if (empty? coll) acc\n                 (let [n (count (take-while (partial = (first coll)) coll))\n                       rest-coll (drop n coll)]\n                   (recur rest-coll (conj (conj acc n) (first coll))))))) seq)))","user":"561d23e3e4b064ca9f4b16a5"},{"code":"(fn p [s]\n  (let [y (apply concat\n              (for [x (partition-by identity s)] [(count x) (first x)]))]\n    (cons y (lazy-seq (p y)))))","problem":110,"user":"4db016af838c48654951d9b9"},{"code":"(fn seq-of-pronunciations [s]\n  (letfn [(pronounce-num [num-s]\n            [(count num-s) (first num-s)])\n          (pronounce [s]\n            (if (not (empty? s))\n                (concat\n                  (pronounce-num (take-while #(= % (first s)) s))\n                  (pronounce     (drop-while #(= % (first s)) s)))))]\n    (drop 1 (iterate pronounce s))))","problem":110,"user":"4f725466e4b07046d9f4f030"},{"problem":110,"code":"(fn pronounce [init]\n  (let [p (mapcat #(vector (count %) (first %)) (partition-by identity init))]\n    (cons p (lazy-seq (pronounce p)))))","user":"5958cef6e4b066ee0a44af94"},{"problem":110,"code":"(fn pronunciations [coll]\n  (->> coll\n       (iterate (fn [c]\n                  (->> c\n                       (partition-by identity)\n                       (mapcat (fn [x] [(count x) (first x)])))))\n       (drop 1)))","user":"5c506951e4b0f9f7a8770ec5"},{"code":"(fn f [x]\n  (rest\n    (iterate\n      #(->>\n         %\n         (partition-by identity )\n         (mapcat (fn [a] [(count a) (first a)]))\n         )\n      x)))","problem":110,"user":"518c5236e4b087e178201de0"},{"code":"(fn pron [xs] (lazy-seq\n               (let [s (mapcat #(vector (count %) (first %)) (partition-by identity xs))]\n               (cons \n                s\n                (pron s)))))","problem":110,"user":"4ef9c8f9535dced4c769f26b"},{"problem":110,"code":"(fn [nums]\n  (->> nums\n       (iterate #(mapcat (juxt count first) (partition-by identity %)))\n       (rest)))","user":"5b77d3c8e4b047b03b2036f1"},{"code":"(fn prob-110 [s]\n  (lazy-seq\n    (let [s1 (flatten (map #(vector (count %) (first %)) (partition-by #(identity %) s)))]\n      (cons s1 (prob-110 s1)))))","problem":110,"user":"4ec5cdb0535d6d7199dd36b8"},{"code":"(fn [ns]\n  (letfn [(append-dig-cnt [{:keys [cnt dig pron]}]\n                          (if dig \n                            (-> pron (conj ,,, cnt) (conj ,,, dig))\n                            pron))\n          (prononce [ns]\n                    (append-dig-cnt \n                      (reduce (fn [acc item]\n                                (if (= item (acc :dig))\n                                  (update-in acc [:cnt] inc)\n                                  {:dig item, :cnt 1, :pron (append-dig-cnt acc)}\n                                  ))\n                              {:dig nil, :cnt 0, :pron []}\n                              ns)))\n          (pron-seq [ns] \n                    (lazy-seq\n                      (let [pron (prononce ns)]\n                        (cons pron (pron-seq pron)))))]\n         (pron-seq ns))\n  )","problem":110,"user":"4dca8b6d535d5973398f9288"},{"code":"(fn [coll]\n  (letfn [(pron [coll]\n            (mapcat (juxt count first) \n                    (partition-by identity coll)))]\n    (rest (iterate pron coll))))","problem":110,"user":"4fe84c74e4b07c9f6fd12c3c"},{"problem":110,"code":"(fn number-pronouce [n]\n  (let [np (->> n\n                (partition-by identity)\n                (map (fn [x] [(count x) (first x)]))\n                (flatten))]\n    (lazy-seq (cons np (number-pronouce np)))))","user":"56f4cedce4b046a417f92063"},{"code":"#_(fn g [s]\n  (let [f (fn [s]\n            (loop [s s res ()]\n              (if (seq s)\n                (if (= (first s) (ffirst res))\n                  (recur (rest s) (cons [(ffirst res) (inc (second (first res)))] (rest res)))\n                  (recur (rest s) (cons [(first s) 1] res)))\n                (reverse (flatten res)))))]\n    (cons (f s) (lazy-seq (g (f s))))))\n#_(fn f [s]\n   (let [s (->> s\n             (partition-by identity)\n             (map #(-> [(count %) (first %)]))\n             flatten)]\n     (cons s (lazy-seq (f s)))))\n#_(comp (partial drop 1)\n      (partial iterate (comp flatten\n                             (partial map (juxt count first))\n                             (partial partition-by identity))))\n#(drop 1 (iterate (fn [s]\n                    (flatten (map (juxt count first)\n                                  (partition-by identity s)))) %))","problem":110,"user":"4f1bb9d8535d64f60314647d"},{"code":"(fn f [c]\n  (let [c2 (mapcat (fn [x] [(count x) (first x)]) (partition-by identity c))]\n    (lazy-seq (cons c2 (f c2)))))","problem":110,"user":"4f9f7daae4b0dcca54ed6d37"},{"code":"(fn no-fx [s]\n  (let [fx (fn [coll]\n        (into [] (flatten\n          (reverse\n            (reduce #(let [[x y] (first %1)]\n                       (if (= y %2)\n                         (cons [(inc x) y] \n                               (rest %1))\n                         (cons [1 %2] %1))) [] coll)))))\n        v (fx s)]\n    (cons v (lazy-seq (no-fx v)))))","problem":110,"user":"514cfa27e4b019235f6c057d"},{"code":"(fn [x]\n  (let [f #(mapcat (juxt count first) (partition-by identity %))]\n    (iterate f (f x))))","problem":110,"user":"513b77f3e4b00f740c76c403"},{"problem":110,"code":"(fn pronunciation-seq [v]\n  (let [pronunciation\n        (fn [v]\n          (let [[res n number]\n                (reduce #(let [[res n number] %1]\n                           (if (= number %2)\n                             [res (+ n 1) number]\n                             [(conj (conj res n) number) 1 %2]))\n                        [[] 1 (first v)]\n                        (rest v))]\n            (conj (conj res n) number)))\n        pronunced (pronunciation v)]\n    (lazy-seq (cons pronunced (pronunciation-seq pronunced)))))","user":"5a6b9b95e4b0512ff01cda40"},{"code":"(fn pro-seq [start]\n  (letfn [(pronounce [vn]\n            (let [z (partition-by identity vn)]\n              (interleave (map count z) (map first z))))]\n    (iterate pronounce (pronounce start))))","problem":110,"user":"4ea7999e535d7eef308072ee"},{"code":"#(rest \n  (iterate \n     (fn [c] (mapcat (juxt count first) \n     (partition-by identity c))) %))","problem":110,"user":"4daa374930acd6ed13482a68"},{"code":"(fn pron [coll]\n  (let [pronunc (flatten\n                 (map #(vector (count %) (first %))\n                      (partition-by identity coll)))]\n    (cons pronunc (lazy-seq (pron pronunc)))\n    )\n  )","problem":110,"user":"52e59ca5e4b09f7907dd1464"},{"code":"(fn p [ns]\n  (loop [ns ns d nil c -1 acc []]\n    (if (seq ns)\n      (cond\n         (= (first ns) d) (recur (rest ns) d (inc c) acc)\n         :else (recur (rest ns) (first ns) 1 (if d (concat acc [c d]))))\n      (let [res (if d (vec (concat acc [c d])) (vec acc))] (cons res (lazy-seq (p res)))))))","problem":110,"user":"504f865ee4b0a02f9cffde90"},{"problem":110,"code":"(fn [q] (rest (iterate #(mapcat (fn [s] [(count s) (first s)])\n                                (partition-by identity %)) q)))","user":"4f5eda39e4b0030a34fb2b56"},{"problem":110,"code":"(fn [x]\n  (drop 1 (iterate #(->> %\n                         (partition-by identity)\n                         (mapcat (fn [coll]\n                                   [(count coll) (first coll)])))\n                   x)))","user":"60096aabe4b074f607df667f"},{"problem":110,"code":"(fn p ([s] (p (rest s) [] 1 (first s)))\n      ([s ps v k]\n       (if (empty? s)\n         (let [rs (conj ps v k)]\n         (cons rs (lazy-seq (p rs))))\n         (let  [h (first s)]\n           (if (= h k)\n             (p (rest s) ps (inc v) k)\n             (p (rest s) (conj ps v k) 1 h))))))","user":"56bca51ae4b0f26550335963"},{"code":"(fn [v]\n(letfn [(pronun [v]\n  (loop [v v\n         p []]\n    (if (empty? v) (flatten p)\n        (let [e (first v)\n              f #(= e %)\n              a (take-while f v)\n              n (count a)]\n          (recur (drop-while f v)\n                 (conj p [n e]))))))]\n\n(next (iterate pronun v))))","problem":110,"user":"524ae8e6e4b09eba1c0223b5"},{"problem":110,"code":"(fn f [lst]\n  (loop [[h & _ :as l] lst, acc []]\n    (if h\n      (let [[f s] ((juxt take-while drop-while) #(= h %) l)]\n        (recur s (conj acc (count f) h)))\n      (cons acc (lazy-seq (f acc))))))","user":"57035ccfe4b08d47c97781ef"},{"problem":110,"code":"(fn ex110\n  [s]\n  (let [res (flatten (map (fn [x]\n                            [(count x) (first x)])\n                          (partition-by identity s)))]\n    (cons res\n          (lazy-seq (ex110 res)))))","user":"532bce35e4b09d4e7a9b5536"},{"problem":110,"code":"(fn [coll] (rest (iterate #(reduce (fn [m [k & rest :as v]] (conj m (count v) k)) [] (partition-by identity %)) coll)))","user":"580c8fcee4b0849f6811b721"},{"code":"(letfn [(pronounce [coll]\n          (reduce\n           (fn [acc val]\n             (if (= val (last acc))\n               (let [index (- (count acc) 2)]\n                 (conj (subvec acc 0 index)\n                       (inc (get acc index))\n                       val))\n               (conj acc 1 val)))\n           []\n           coll))\n        (pronunciations [coll]\n          (let [pronunciation (pronounce coll)]\n            (lazy-seq (cons pronunciation (pronunciations pronunciation)))))]\n  pronunciations)","problem":110,"user":"5014754de4b094324338f8e5"},{"code":"(letfn [(f [x] (mapcat #(list (count %) (first %)) (partition-by identity x)))]\n       #(next (iterate f %)))","problem":110,"user":"4efb2fd7535dced4c769f274"},{"code":"(fn [num-vec]\n  (letfn [(next-vec [num-vec] (loop [result []\n                                     current (first num-vec)\n                                     n 1\n                                     num-vec (next num-vec)]\n                                (cond (empty? num-vec)\n                                      (conj result n current)\n                                      (= current (first num-vec))\n                                      (recur result current (inc n) (next num-vec))\n                                      true\n                                      (recur (conj result n current) (first num-vec) 1 (next num-vec)))))]\n    (next (iterate next-vec num-vec))))","problem":110,"user":"502a5e59e4b09e8f859a9fbc"},{"problem":110,"code":"(fn repeat-pronunciation [ini]\n  ((fn helper [coll]\n     (let [next-pronunciation (#(loop [remaining % prev (first %) ans [] cnt 0]\n                                  (if (empty? remaining)\n                                    (conj ans cnt prev)\n                                    (if (= prev (first remaining))\n                                     (recur (rest remaining) (first remaining) ans (inc cnt))\n                                     (recur (rest remaining) (first remaining) (conj ans cnt prev) 1)))) coll)]\n       (cons next-pronunciation (lazy-seq (helper next-pronunciation))))) ini))","user":"5746061ae4b009280f9f2b5b"},{"problem":110,"code":"(fn pronounce [coll]\n  (let [i (-> (for [chunk (partition-by identity coll)]\n                [(count chunk) (first chunk)])\n              (flatten)\n              (vec))]\n    (lazy-seq\n      (cons i\n            (pronounce i)))))","user":"542c026ae4b0dad94371f29a"},{"problem":110,"code":"(fn sequence-of-pronunciations [col]\n  (rest\n   (iterate\n    #(mapcat (fn [x] [(count x) (first x)])\n             (partition-by identity %))\n    col)))","user":"4dd7d040535d2dad7130b5d6"},{"problem":110,"code":"(fn pronounce [ns]\n  (let [pronunciation (mapcat (juxt count first) (partition-by identity ns))]\n    (lazy-seq (cons pronunciation (pronounce pronunciation)))))","user":"4f5599dfe4b0a7574ea71806"},{"code":"(fn prons [x0]\n  (letfn [(pron [xs]\n                (loop [in  (rest xs)\n                       out []\n                       cur (first xs)\n                       cnt 1]\n                  (if (empty? in)\n                    (conj (conj out cnt) cur)\n                    (if (= (first in) cur)\n                      (recur (rest in) out cur (inc cnt))\n                      (recur (rest in)\n                             (conj (conj out cnt) cur)\n                             (first in)\n                             1)))))]\n    (let [x1 (pron x0)]\n      (cons x1 (lazy-seq (prons x1))))))","problem":110,"user":"51365524e4b04ac1f358dd52"},{"code":"(fn [s]\n  (next (iterate\n    #(mapcat (juxt count first)\n      (partition-by identity %))\n    s)))","problem":110,"user":"4f6fbb68e4b07046d9f4efeb"},{"code":"(fn [v]\n  (rest\n   (iterate\n    #(mapcat\n      (fn [v] [(count v) (first v)])\n      (partition-by + %))\n    v)))","problem":110,"user":"4f9fe2b9e4b0dcca54ed6d40"},{"problem":110,"code":"#(letfn [(pron [v] (->> v (partition-by identity) (mapcat (juxt count first))))]\n   (iterate pron (pron %)))","user":"596a66cde4b069c0a1a19803"},{"problem":110,"code":"(fn foo [l]\n    (letfn\n        [(pronounce [l]\n                    (if (empty? l)\n                        []\n                        (loop [n (first l)\n                               cnt 1\n                               xs (rest l)\n                               acc []]\n                            (if (empty? xs)\n                                (conj (conj acc cnt) n)\n                                (let [m (first xs)\n                                      xs' (rest xs)\n                                      cnt' (if (= m n) (inc cnt) 1)\n                                      acc' (if (= m n) acc (conj (conj acc cnt) n))]\n                                    (recur m cnt' xs' acc'))))))]\n        (let [p (pronounce l)]\n            (lazy-seq (cons p (foo p))))))","user":"600ae927e4b074f607df6689"},{"problem":110,"code":"(comp rest\n        (partial iterate\n                 (comp (partial reduce concat)\n                       (partial map (juxt count first))\n                       (partial partition-by identity))))","user":"5bd0ea60e4b0e9689409ee45"},{"code":"(fn [s]\r\n  (next\r\n    (iterate\r\n      #(mapcat (juxt count first)\r\n        (partition-by identity %)) s)))","problem":110,"user":"4f9597e0e4b0dcca54ed6cd4"},{"code":"(fn p [ns]\n  (letfn [(pp [nums] \n              (->> nums\n                   (partition-by identity)\n                   (map #(list (count %) (first %)))\n                   (apply concat)))]\n    (lazy-seq (cons (pp ns) (p (pp ns))))))","problem":110,"user":"506617c3e4b03d366d7cb2ab"},{"problem":110,"code":"(fn [col]\n            (letfn [(p110_S [col]\n                      (reduce (fn [result x]\n                                (conj result (count x) (first x)))\n                              [] (partition-by identity col)))]\n              ((fn my-sp [col]\n                 (lazy-seq (cons (p110_S col) (my-sp (p110_S col)))))\n               col)))","user":"5e1c3e6ee4b0dc9594008530"},{"problem":110,"code":"(fn [xs]\n  (letfn[(f [s]\n           (->> (partition-by identity s)\n             (map (fn [xs] [(count xs) (first xs)]))\n             (apply concat)))]\n    (drop 1 (iterate f xs))))","user":"5573ffb5e4b0aa18f790f3fd"},{"problem":110,"code":"(fn pronounce [se]\n  (let [f (fn f [alist]\n            (loop [l alist res []\n                   ccount 0 pnum nil]\n              (if (= 0 (count l))\n               (conj res ccount pnum)\n               (if (nil? pnum)\n                (recur (rest l) res (inc ccount) (first l))\n                (if-not (= (first l) pnum)\n                 (recur (rest l) (conj res ccount pnum) 1 (first l))\n                 (recur (rest l) res (inc ccount) (first l)))))))]\n  (iterate f (f se))))","user":"52747090e4b03e8d9a4a74a5"},{"code":"#(rest \n  (iterate\n   (fn [v] \n     (->>\n      v\n      (partition-by identity)\n      (mapcat (juxt count first))))\n   %))","problem":110,"user":"51944aaae4b0142f60b4aedc"},{"problem":110,"code":"#(->> (iterate (fn [nums] \n                 (->> (partition-by identity nums)\n                      (mapcat (fn [vs] \n                                [(count vs) (first vs)]))))\n               %)\n      (rest))","user":"5f37263de4b0574c87022c4e"},{"problem":110,"code":"(fn pronunseq [s]\n  (letfn [(idc [s] (let [v (first s)]\n                     (loop [ns (rest s)\n                            r [(first s)]]\n                       (if (empty? ns)\n                         [ns r]\n                         (if (= v (first ns))\n                           (recur (rest ns) (conj r v))\n                           [ns r])))))\n          (pronun [s] (loop [s s\n                             r []]\n                        (if (empty? s)\n                          r\n                          (let [[ns nr] (idc s)]\n                            (recur ns (conj r (count nr) (first nr)))))))]\n    (let [p (pronun s)]\n      (lazy-seq (cons p (pronunseq p))))))","user":"5f8b06afe4b0715f5002d74a"},{"code":"(fn [xs]\n  (drop 1 (iterate (fn [ys]\n                     (mapcat\n                      (fn [zs] [(count zs) (first zs)])\n                      (partition-by identity ys))) xs)))","problem":110,"user":"5097b556e4b00ad8bab4e970"},{"problem":110,"code":"(fn pronunciations [coll]\r\n  (let [coll (mapcat (juxt count first)\r\n                     (partition-by identity coll))]\r\n    (lazy-seq (cons coll\r\n                    (pronunciations coll)))))","user":"55d0e76ae4b0e31453f64a40"},{"code":"#(letfn [(same-item-count [x l n]\r\n            (if (empty? l)\r\n              n\r\n              (if (= x (first l))\r\n                (recur x (rest l) (inc n))\r\n                n)))\r\n          (f [l]\r\n            (if (empty? l) l\r\n                (let [v (same-item-count (first l) (rest l) 1)]\r\n                  (vec (cons v (cons (first l) (f (drop v l))))))))]\r\n    (iterate f (f %)))","problem":110,"user":"4f474f43e4b0d56e7bb92bb7"},{"code":"(fn [l] (let [f (fn [x] \n                 (->> x (partition-by identity)\n                      (mapcat #(list (count %) (first %)))))]\n          (iterate f (f l))))","problem":110,"user":"50563ae2e4b0ce54f56f0405"},{"problem":110,"code":"(fn pronunciations\n  [l]\n  (rest (iterate #(reduce (fn f [a b] (concat a [(count b) (first b)])) [] (partition-by identity %1)) l))\n  )","user":"558bdcefe4b0277789237633"},{"code":"(fn [s]\n(rest (iterate \n  #(mapcat (fn [a] [(count a) (first a)])\n           (partition-by identity %)) \n           s)))","problem":110,"user":"4e68b46c535d8ccf87e9fe87"},{"code":"#(rest\n    (iterate (fn [n]\n               (mapcat (fn [x]  [(count x) (first x)])\n                       (partition-by identity n)))\n                       %))","problem":110,"user":"4e8510e7535db62dc21a62e7"},{"code":"(comp rest\n      (partial iterate #(mapcat (juxt count first)\n                                (partition-by identity %))))","problem":110,"user":"4ee3b586535d10e5ff6f5371"},{"problem":110,"code":"(fn p[sx] (\n           letfn [\n                  (cl [c s] (\n                              if (or (< (count s) 2) (not (= (nth s 0) (nth s 1))))\n                              c\n                              (cl (inc c) (rest s))\n                              ))\n                            \n                  (pr [s] (\n                            if (not (empty? s))\n                            (#(concat [%] [(first s)] (pr (drop % s)) ) (cl 1 s))\n                            []\n                            ))\n                          \n                    (lx [s] (\n                              lazy-seq (concat s (lx [(pr (last s))]))\n                            )\n                    )\n                          \n                  ]\n         \n\t\t\t(lx [(pr sx)])\n\n           ))","user":"596f6683e4b069c0a1a19877"},{"problem":110,"code":"(fn pronounce [xs]\n  (letfn [(pronounce* [[x & more :as xs]]\n            (if (seq xs)\n              (let [[head tail] (split-with #(= x %) xs)]\n                (cons (count head) (cons x (lazy-seq (pronounce* tail)))))\n              '()))]\n    (->> xs (iterate pronounce*) (drop 1))))","user":"534d1173e4b084c2834f4a98"},{"problem":110,"code":"(fn pronounce-lst [input-lst]\n   (let [pronounce\n         (fn pronounce [lst]\n              (loop [last-item (first lst) total 0 ret [] res lst]\n                (cond (empty? res) (conj ret total last-item)\n                      (= (first res) last-item) (recur last-item (inc total) ret (rest res))\n                      :else (recur (first res) 1 (conj ret total last-item) (rest res))\n                      )))\n         pronounced (pronounce input-lst)]\n     (cons pronounced (lazy-seq (pronounce-lst pronounced)))))","user":"54f09599e4b024c67c0cf89d"},{"problem":110,"code":"(fn pron [s]\n  (letfn [(pronounc [s]\n            (let [i (first s)\n                  [head tail] (split-with (partial = i) s)\n                  n (count head)]\n              (if (empty? tail)\n                (list n i)\n                (cons n (cons i (pronounc tail))))))]\n    (drop 1 (iterate pronounc s))))","user":"587ee260e4b052da650a6353"},{"code":"(fn [sq]\n  (letfn [(something [sq0]\n            (vec\n              (apply concat\n                     (for [x (partition-by identity sq0)]\n                       [(count x) (first x)]))))]\n    (drop 1 (iterate something sq))))","problem":110,"user":"504e12ade4b078edc5f593b7"},{"code":"(fn pronunciate [ns]\n  (lazy-seq\n    (let [p (mapcat #(vector (count %) (first %)) (partition-by identity ns))]\n      (cons p (pronunciate p)))))","problem":110,"user":"504e13fce4b078edc5f593bc"},{"code":"(fn pronunciations [x]\n  (lazy-seq \n   (let [y (mapcat (fn [z] [(count z) (first z)]) (partition-by identity x))]\n     (cons y (pronunciations y)))))","problem":110,"user":"51307b84e4b08c712d3fae39"},{"problem":110,"code":"(fn f [nums]\n  (lazy-seq\n    (let [prons (reduce \n                  (fn [a x]\n                    (if (empty? a) [1 x]\n                      (let [[c e] (take-last 2 a)]\n                        (if (= e x)\n                          (conj (vec (drop-last 2 a)) (inc c) e)\n                          (conj a 1 x)))))\n                  [] nums)] \n      (cons prons (f prons)))))","user":"5794fd7be4b0e215f87e8476"},{"problem":110,"code":"(fn p-list [xs]\n  (letfn [(p [xs] (->> xs\n                       (partition-by identity)\n                       (mapcat #(vector (count %) (first %)))))]\n    (lazy-seq (let [p-xs (p xs)]\n                (cons p-xs\n                      (p-list p-xs))))))","user":"5d272077e4b092dab7f59c64"},{"code":"(fn pronounciations [v]\n  (letfn [(next-val [v]\n            (mapcat\n              (fn [x] [(count x) (first x)])\n              (partition-by identity v))\n            )]\n    (iterate next-val (next-val v))\n    )\n  )","problem":110,"user":"5094057fe4b097f48cc38593"},{"code":"(fn f [c]\n  (let [c (mapcat (juxt count first) (partition-by identity c))]\n    (lazy-seq (cons c (f c)))))","problem":110,"user":"4eb51942535d7eef30807365"},{"problem":110,"code":"(fn [xs]\n  (letfn [(count-element [xs]\n                         (->> xs\n                              (partition-by identity)\n                              (mapcat #(vector (count %) (first %)))))]\n    (next (iterate count-element xs))))","user":"5ebdb3d2e4b00a66d4a95275"},{"code":"(fn pron [coll]\n  (let [step (fn step [coll]\n               (vec (mapcat \n                     identity \n                     (reduce \n                      #(conj % [(count %2) (first %2)]) \n                      [] (partition-by identity coll)))))\n        result (step coll)]\n    (lazy-seq (cons result (lazy-seq (pron result))))))","problem":110,"user":"4faafccde4b081705acca209"},{"problem":110,"code":"(fn [coll]\n  (letfn [(process-chunk [[v & _ :as coll]] (let [n (count coll)] (if (= 1 n) [1 v] [n v])))\n          (process [s] (mapcat process-chunk (partition-by identity s)))]\n    (rest (iterate process coll))))","user":"5764457ae4b0994c1922fbf3"},{"code":"(fn xx[xs] (let [r (->> xs ((fn ss[l] (let [[c n] (split-with (partial = (first l)) l)] (if (empty? n) [c] (lazy-seq (cons c (ss n))))))) (map #(list (count %) (first %))) flatten)] (lazy-seq (cons r (xx r)))))","problem":110,"user":"4e7f4147535db966e863cc3d"},{"code":"(fn [l]\n  (letfn [(p [x]\n            (loop [acc [] tmp (rest x) lf [1 (first x)]]\n              (if (empty? tmp)\n                (flatten (conj acc lf))\n                (if (= (second lf) (first tmp))\n                  (recur acc (rest tmp) [(inc (first lf)) (second lf)])\n                  (recur (conj acc lf) (rest tmp) [1 (first tmp)])))))\n          (ps [x] (lazy-seq (concat [(p x)] (ps (p x)))))]\n      (ps l)))","problem":110,"user":"4e6a2f51535d8ccf87e9fea9"},{"problem":110,"code":"(fn [vv] (letfn [(step-fn [v] (into [] (flatten (loop [r [] rv v] (if (empty? rv) r (recur (let [l (last r) c (first rv)] (if (empty? r) [[1 c]] (if (= (second l) c) (conj (pop r) [(inc (first l)) c]) (conj r [1 c])))) (next rv)))))))] (drop 1 (iterate step-fn vv))))","user":"58987ee9e4b00487982d52d2"},{"code":"(fn pronounce [coll]\n  (rest (iterate (fn [c]\n             (let [p (partition-by identity c)]\n               (vec (flatten (map #(vector (count %) (first %)) p))))) coll)))","problem":110,"user":"50c8697ce4b00bb60fe0c53f"},{"code":"(fn [s0] (rest (iterate #(mapcat (fn [s] [(count s) (first s)]) (partition-by + %)) s0)))","problem":110,"user":"4f569a3ce4b0a7574ea71828"},{"code":"(fn [s]\n  (rest (iterate\n          #(mapcat (fn [l] [(count l) (first l)]) (partition-by identity %))\n          s)))","problem":110,"user":"5336a339e4b0e30313ee6c7d"},{"code":"(fn problem-110 [s]\n  (letfn [(sames [v res]\n            (if (empty? v)\n              (reverse res)\n              ;else\n              (let [spd (split-with #(= % (first v)) v)]\n                (recur (second spd) (concat (list (first spd)) res)))))\n          (prononciation [v]\n            (vec (flatten (map (fn [el] [(count el) (first el)])\n                               (sames v [])))))]\n    (next (iterate prononciation s))))","problem":110,"user":"51fe9d7ce4b0f1313d468a70"},{"code":"(fn n110 [coll-1]\n  (letfn [(pron [coll] (loop [c (rest coll) curr (first coll) t 1 a []]\n    (if (empty? c)\n      (conj a t curr)\n      (recur (rest c) (first c) (if (= curr (first c)) (inc t) 1) (if (= curr (first c)) a (conj a t curr))))))]\n    (rest (iterate pron coll-1))))","problem":110,"user":"52b43468e4b0c58976d9ad1b"},{"code":"(fn f [sq]\r\n    (let [sqp (reverse \r\n                 (reduce #(conj %1 (count %2) (first %2))\r\n                         '()\r\n                         (partition-by identity sq)))]\r\n            \r\n      (lazy-seq (cons sqp (f sqp)))\r\n      ))","problem":110,"user":"4f0da4e4535d0136e6c22319"},{"problem":110,"code":"(fn [v]\n  (letfn [(nextp [v]\n            (mapcat #(list (count %) (first %)) (partition-by identity v)))]\n    (iterate nextp (nextp v))))","user":"5576f299e4b05c286339e077"},{"code":"(fn s [c]\n  (lazy-seq\n    (let [step (mapcat #(vector (count %) (first % ))(partition-by identity c))]\n      (cons step (s step)))))","problem":110,"user":"5307e4ece4b02e82168697a9"},{"problem":110,"code":"(fn pron [col]\n  (let [ r (apply concat (map \n                  #(vector (count %) (first %)) \n                  (partition-by identity col)))]\n    (lazy-seq\n      (cons r (pron r)))))","user":"55536a8ae4b0deb715856e03"},{"code":"(fn [coll]\n  (rest (iterate (fn [coll]\n                   (mapcat (juxt count first)\n                           (partition-by identity coll)))\n                 coll)))","problem":110,"user":"4dabb7b1950ed6eda1bd72f3"},{"problem":110,"code":"(fn seq-pronunciations [s]\n  (let [r (->> (partition-by identity s)\n               (reduce #(conj % (count %2) (first %2)) []))]\n    (lazy-seq (cons r (seq-pronunciations r)))))","user":"572ec4dde4b0cd1946bd0f8d"},{"problem":110,"code":"#(rest\n  (iterate\n   (fn bar [xs]\n     (loop [ys xs zs []]\n       (if (empty? ys)\n         zs\n         (let [z (take-while (partial = (first ys)) ys)\n               n (count z)]\n           (recur (drop n ys) (conj zs n (first z))))))) %))","user":"54d753ebe4b0a52adc2e2029"},{"problem":110,"code":"(fn pron[coll]\n   (lazy-seq \n     (let [f (fn [s] (loop [result []\n               s s]\n\t\t\t (if (empty? s)\n\t\t\t\tresult\n\t\t\t   (let [my-first (first s)]\n\t\t\t\t  (recur (conj result (into [] (conj (take-while (partial = my-first) (rest s)) my-first )))\n\t\t\t\t\t\t(drop-while (partial = my-first) (rest s))\n\t\t\t\t  )))))\n\t\t\tx (into [] (flatten (map #(vector (count %) (get % 0)) (f coll) )))]\n     (cons x (pron x)))))","user":"567d18c9e4b05957ce8c61c4"},{"problem":110,"code":"(fn pronunciations [xs]\n  (lazy-seq\n    (let [xs'\n          (loop [acc [] r xs]\n             (if (seq r)\n               (let [a (first r) s (split-with #(= % a) r)]\n                 (recur (conj acc (count (first s)) a) (second s)))\n               acc))]\n      (cons xs' (pronunciations xs')))))","user":"567b39b6e4b05957ce8c61a3"},{"problem":110,"code":"#(let [f (fn [s]\n           (mapcat (fn [a] [(count a) (first a)])\n                   (partition-by identity s)))]\n   (rest (iterate f %)))","user":"57ec3d29e4b0bfb2137f5b77"},{"code":"#(next \n   (iterate \n     (fn [coll] \n       (mapcat \n         (fn [[primeiro & r] & _] \n           (vector (inc (count r)) primeiro)) \n         (partition-by identity coll)))\n     %))","problem":110,"user":"52c8758be4b0c2d177d62135"},{"code":"(fn [nv]\n           (let [next-nv (fn [nv]\n                           (loop [nv nv\n                                  acc []]\n                             (if (empty? nv)\n                               acc\n                               (let [fn (first nv)\n                                     c (count (take-while #{fn} nv))]\n                                 (recur (drop-while #{fn} nv)\n                                        (conj acc c fn))))))]\n             (iterate next-nv (next-nv nv))))","problem":110,"user":"50a5b7e9e4b0aa96157e2610"},{"problem":110,"code":"(fn pronounce [s]\n  (let [ps (->>\n            s\n            (partition-by identity)\n            (map (fn [c] [(count c) (first c)]))\n            (apply concat))]\n    (cons ps (lazy-seq (pronounce ps)))))","user":"4f0f01c0535d0136e6c22329"},{"code":"(fn pronounce-seq \r\n  ([v]\r\n    (let [pronounce\r\n    (fn [vect]\r\n      (reduce\r\n        (fn [result current]\r\n          (if (= (last result) current)\r\n            (assoc result (- (count result) 2) (inc (last (butlast result))))\r\n            (conj result 1 current)))\r\n        [] vect))]\r\n    (pronounce-seq (pronounce v) true)))\r\n  ([v b]\r\n  (let [pronounce\r\n    (fn [vect]\r\n      (reduce\r\n        (fn [result current]\r\n          (if (= (last result) current)\r\n            (assoc result (- (count result) 2) (inc (last (butlast result))))\r\n            (conj result 1 current)))\r\n        [] vect))]\r\n    (cons v\r\n      (lazy-seq (pronounce-seq (pronounce v) true))))))","problem":110,"user":"4dad76588e77d6ed63f12a44"},{"problem":110,"code":"(fn F [s]\n  (letfn [(pronounce [s] (mapcat (fn [p] [(count p) (first p)]) (partition-by identity s)))]\n    (lazy-seq (let [x (pronounce s)] (cons x (F x))))))","user":"5db92996e4b010eb3c36cd50"},{"problem":110,"code":"(fn ant [lst]\n  (let [nlst (->> lst (partition-by identity) (map #(list (count %) (first %))) flatten)]\n    (lazy-seq (cons nlst (ant nlst)))\n    )\n  )","user":"5cebafbbe4b0a17bb84e2be6"},{"code":"( fn[s] (drop 1\n  (iterate \n    (fn[n] (flatten (map #(list (count %) (first %)) \n     (partition-by identity n)))) s )))","problem":110,"user":"507c7c8be4b0b083f3ff82ef"},{"code":"(fn pronouce-sequence [v]\n  (rest (iterate #(flatten (map (juxt count first) \n                                (partition-by identity %)))\n                 v)))","problem":110,"user":"50812debe4b01a93d3f38e4c"},{"problem":110,"code":"(fn pronunciations [a-vec]\n  (rest\n   (iterate\n    (fn [a-vec]\n      (mapcat (fn [x] [(count x) (first x)]) (partition-by identity a-vec)))\n    a-vec)))","user":"58f2e8fbe4b0438e51c2ce94"},{"code":"(fn [v]\n    (drop 1\n          (iterate\n           (fn [v]\n             (mapcat (juxt count first) (partition-by identity v))) v)))","problem":110,"user":"4e59b02c535d8a8b8723a2a2"},{"code":"(fn [s]\n  (next\n    (iterate\n      #(mapcat\n         (juxt count first)\n         (partition-by identity %))\n      s)))","problem":110,"user":"504c8165e4b09724c857af31"},{"code":"(fn f [l] (let [n (mapcat #(do [(count %) (last %)]) (partition-by #(do %) l))] (cons n (lazy-seq (f n)))))","problem":110,"user":"50548ce8e4b0b1b9d1860ead"},{"code":"(fn f [l]\n  (let [r (mapcat #(list (count %) (first %)) (partition-by identity l))]\n    (cons r (lazy-seq (f r)))))","problem":110,"user":"52379c46e4b0fae3832e99db"},{"code":"(fn [v]\n  (next (iterate #(mapcat (juxt count first)\n                          (partition-by inc %)) v)))","problem":110,"user":"51ad244fe4b09397d510977f"},{"problem":110,"code":"(fn pronounciations [v]\n  (lazy-seq\n   (let [current (into [] (mapcat #(list (count %) (first %)) (partition-by identity v)))]\n     (cons current (pronounciations current)))))","user":"55a9e0fee4b0988bba2ad945"},{"problem":110,"code":"(fn pronounce [s]\n  (letfn [(collect [v]\n            (if (empty? v)\n              []\n              (let [const (take-while #(= (first v) %) v)\n                    cnt   (count const)\n                    x     (first const)]\n                (concat [cnt x] (collect (nthrest v (count const)))))))]\n    (let [s0 (collect s)]\n         (lazy-seq (cons s0 (pronounce s0))))))","user":"58a0fc33e4b02bd94d917ea3"},{"code":"(fn pr [s]\n  (let [nextS (reduce into [] \n                  (map #(vector (count %) (first %)) \n                  (partition-by identity s)))]\n    (lazy-seq (cons nextS (pr nextS)))\n  )\n)","problem":110,"user":"4fcf5292e4b03432b189f40e"},{"problem":110,"code":"(fn p-110 [s]\n  (let [pronounce (fn pronounce [s]\n                    (if (empty? s) []\n                        (let [n (first s)\n                              sayit (take-while #(= n %) s)\n                              therest (drop-while #(= n %) s)]\n                          (concat [(count sayit) n] (pronounce therest)))))\n        res (pronounce s)]\n    (lazy-seq (cons res (p-110 res)))))","user":"5bfc9037e4b0bdcf453d15f2"},{"code":"(fn [l]\n  (next (iterate #(mapcat (juxt count first) (partition-by + %)) l)))","problem":110,"user":"522b922ee4b0d34ee08e71c3"},{"problem":110,"code":"(fn seq-pronunciations [x]\n  (let [x (reduce #(conj %1 (count %2) (first %2)) [] (partition-by identity x))]\n    (lazy-seq (cons x (seq-pronunciations x)))))","user":"54769c7ae4b0c51c1f4d72a8"},{"problem":110,"code":"(let [pronounce #(->> %\n                      (partition-by identity)\n                      (mapcat (juxt count first)))]\n  (fn [coll]\n    (iterate pronounce (pronounce coll))))","user":"55f2e47de4b06e875b46ce4d"},{"code":"(fn [s]\n  (let [f (fn [n] (flatten\n                    (map #(vector (count %) (first %))\n                          (partition-by identity n))))]\n    (iterate f (f s))))","problem":110,"user":"51f28a64e4b0210f90e7454e"},{"problem":110,"code":"(fn pronoun [coll]\n  (rest (iterate #(reduce \n                   (fn [xs x] \n                     (let [n (last xs)  i (- (.size xs) 2)]\n                      (if (= n x)\n                        (assoc xs i (inc (get xs i)))\n                        (conj xs 1 x)\n                      ))) [] %) coll)))","user":"55645592e4b0c656e3ff1802"},{"problem":110,"code":"(let [pack (fn [c]\n             (drop 1 ((fn cpack [on-item on-coll c]\n                        (if (empty? c)\n                          (list on-coll)\n                          (let [h (first c)\n                                q (rest c)]\n                            (if (= on-item h)\n                              (lazy-cat (cpack on-item (conj on-coll h) q))\n                              (cons on-coll (lazy-cat (cpack h [h] q)))))))\n                      nil [] c)))\n      reading (fn [c]\n                (flatten (mapv (fn [c] [(count c) (first c)]) c)))]\n  (fn f [c]\n    (let [r (reading (pack c))]\n      (cons r (lazy-cat (f r))))))","user":"547d8e93e4b0c51c1f4d72f4"},{"code":"(fn this [col]\n  (letfn [(f \n           ([l] (f (rest l) (first l) 1 []))\n           ([l now-ele now-count result]\n             (if (empty? l)\n               (into result (vector now-count now-ele))\n               (let [item (first l)\n                     ]\n                 (if (= item now-ele)\n                   (recur (rest l) now-ele (inc now-count) result)\n                   (recur (rest l) item 1 (into result (vector now-count now-ele)))\n                 ) ; if\n                 ) ; let\n               ) ; if\n            )\n           ) ; fn f\n          ]\n    (cons (f col) (lazy-seq (this (f col))))\n    ) ; letfn\n  ) ; fn","problem":110,"user":"5021f0b3e4b00bba4502f7ac"},{"code":"(fn inf-prons [s] \n  (let [\n    pron (fn [s] (for [d (partition-by identity s)] [(count d) (first d)]))\n    f (flatten (pron s))]\n    (iterate (comp flatten pron) f)))","problem":110,"user":"503e7f06e4b06c4e0e1fa268"},{"code":"(letfn [(next-pronunciation [coll]\n          (mapcat\n           (juxt count first)\n           (partition-by identity coll)))]\n  #(rest (iterate next-pronunciation %)))","problem":110,"user":"51789dfae4b03d69594194d7"},{"code":"; Clearly my solution here is more complex than it needed to be. \n(fn pron [s]\n  (let [item (fn item [s]\n                (if (not-empty s)\n                  (let [taken (let [consume-same (take-while #(= % (second s)) s)]\n                                (if (empty? consume-same) (list (first s)) consume-same))\n                        result [(count taken) (first taken)]]\n                    (filter identity (flatten (list result (item (drop (count taken) s))))))))]\n    (if s (cons (item s) (lazy-seq (pron (item s)))))))","problem":110,"user":"5201ff99e4b0b2e020a18f26"},{"problem":110,"code":"(fn pronounce [x] (lazy-seq (cons (flatten (map (fn [a] [(count a) (first a)]) (partition-by identity x))) (pronounce (flatten (map (fn [a] [(count a) (first a)]) (partition-by identity x)))))))","user":"567f988be4b0feffd0d18ebe"},{"code":"(fn pronounce [s]\n  (let [p (fn [s] (flatten (reduce (fn [acc x] (conj acc [(count x) (first x)]) ) [] (partition-by identity s))))]\n   (lazy-seq (cons (p s) (pronounce (p s))) )))","problem":110,"user":"50783762e4b0fc74642bff67"},{"code":"(fn p110 [coll]\n  (let [f (fn [coll]\n    (mapcat #(list (count %) (first %)) (partition-by identity coll)))]\n    (iterate f (f coll))))","problem":110,"user":"5125745ae4b05d10e3e395f9"},{"problem":110,"code":"(fn pronunciations\n  [s]\n  (rest \n   (iterate\n    (fn [seq]\n      (mapcat \n       (fn [s2] (list (count s2) (first s2)))\n       (partition-by identity seq)))\n    s)))","user":"53b952eee4b047364c0444e6"},{"code":"(fn [s]\n  (let  [f (fn [s]\n             (loop [s s\n                    prev nil\n                    cnt 0\n                    accum []]\n               (if (empty? s)\n                 (conj accum (inc cnt) prev)\n                 (let [current-element (first s)]\n                   (if (= current-element prev)\n                     (recur (rest s) prev (inc cnt) accum)\n                     (if prev\n                       (recur (rest s) current-element 0 (conj accum (inc cnt) prev))\n                       (recur (rest s) current-element 0 accum)))))))]\n    (rest (iterate f s))))","problem":110,"user":"53527551e4b084c2834f4af0"},{"problem":110,"code":"(fn pron [s]\n(rest (iterate (fn [x] (vec (mapcat #(list (count %) (first %)) (partition-by identity x)))) s))\n)","user":"5be6d0f8e4b0f319e2d7ec51"},{"problem":110,"code":"(fn [s]\n    (drop 1 (iterate (fn [x]\n                       (reduce\n                        #(conj (conj %1 (count %2)) (first %2))\n                        []\n                        (partition-by identity x))) s)))","user":"53c1b787e4b00fb29b221266"},{"problem":110,"code":"(fn [seed]\n  (rest (iterate\n         #(->> %\n               (partition-by identity)\n               (mapcat (juxt count first)))\n         seed)))","user":"52fc34cee4b047fd55837015"},{"problem":110,"code":"#(letfn [(f [x] (interleave (map count (partition-by identity x)) (map first (partition-by identity x))))]\n   (lazy-seq (rest (iterate f %))) )","user":"5c683fb5e4b0fca0c16226d5"},{"problem":110,"code":"(fn pronounce [s]\n  (let [v (reduce #(conj %1 (count %2) (first %2)) [] (partition-by identity s))]\n    (lazy-seq (cons v (pronounce v)))))","user":"56d63729e4b0ea9b8538f7ca"},{"problem":110,"code":"(fn [ns]\n  (letfn [(speak [ns]\n            (let [gs (partition-by identity ns)]\n              (reduce (fn [acc s]\n                        (conj acc (count s) (first s)))\n                      []\n                      gs)))]\n    (rest (iterate speak ns))))","user":"53576356e4b04ce2eb3ed27a"},{"problem":110,"code":"(fn pronunciations\n  [coll]\n  (let [next-coll (flatten (map #(vector (count %) (first %)) (partition-by identity coll)))]    \n    (cons next-coll\n          (lazy-seq (pronunciations next-coll)))))","user":"4fc524aae4b081705acca37e"},{"code":"(fn [y] (rest (iterate (fn [x] (mapcat #(list (count %) (first %)) (partition-by identity x))) y)))","problem":110,"user":"4ece9ca9535d23f03622770f"},{"problem":110,"code":"(fn [coll]\n  (rest (iterate (fn [xs] (mapcat #(vector (count %) (first %)) \n                                  (partition-by identity xs))) \n                 coll)))","user":"57015a1de4b08d47c97781d4"},{"problem":110,"code":"(fn anon [s]\n      (let [one-run (fn [r] [(count r) (first r)])\n            pron    (fn [s] (mapcat one-run (partition-by identity s)))\n            p       (pron s)]\n        (lazy-seq (cons p (anon p)))))","user":"5f93529ae4b0715f5002d7bc"},{"problem":110,"code":"(fn lazy-pronunciation\n  [xs]\n  (letfn [(subseq-by-first [xs]\n            (take-while (fn [each] \n                          (= (first xs) each)) \n                         xs))\n          (pronounce-once [xs]\n            (loop [remained xs\n                   acc []]\n              (if (empty? remained)\n                acc\n                (let [result (subseq-by-first remained)]\n                  (recur (drop (count result) remained) (conj acc (count result) (first result)))))))]\n    (iterate #(pronounce-once %) (pronounce-once xs))))","user":"5553b729e4b0deb715856e05"},{"problem":110,"code":"(fn ddx [n1] (rest (iterate (fn trans [x]\n      (let [fx (take-while #(= % (first x)) x)\n      \t    sx (drop-while #(= % (first x)) x)\n\t    ]\n\t    (if (empty? x) \n\t    []\n\t    (vec (concat [(count fx) (first fx)] (trans sx)))))\n) n1 )))","user":"54a1d643e4b09f271ff37c50"},{"code":"(fn [s]\n    (letfn [(f1 [s]\n              (when (seq s)\n                (let [ns (take-while #(= % (first s)) s)]\n                  (concat [(count ns) (first s)] (f1 (drop (count ns) s))))))]\n            (iterate f1 (f1 s))))","problem":110,"user":"4ed292ac535d44c135fd68d9"},{"code":"(fn [z] (rest (iterate (fn say [x]\n  (let [v (first x)\n        c (count (take-while #(= %1 v) x))\n        r (drop-while #(= %1 v) x)]\n    (if (empty? r)\n      [c v]\n      (concat [c v] (say r))))) z)))","problem":110,"user":"4eb2eae5535d7eef30807351"},{"problem":110,"code":"(fn pron [ls]\n  (let [p (flatten (map #(list (count %) (first %)) (partition-by identity ls)))]\n    (cons p (lazy-seq (pron p)))))","user":"5d1bbef0e4b02ea6f0fb6984"},{"problem":110,"code":"(fn [c] (rest (iterate #(->>\n   (partition-by identity %)\n   (mapcat (juxt count first))\n    ) c)))","user":"54908cc1e4b0b312c081ff32"},{"problem":110,"code":"(fn look-and-say [[fst & xs]]\n  (lazy-seq\n    (let [pronun (apply conj\n                   (reduce\n                     (fn [[pronun n prev] x]\n                       (if (= x prev)\n                         [pronun (inc n) prev]\n                         [(conj pronun n prev) 1 x]))\n                     [[] 1 fst]\n                     xs))]\n      (cons pronun (look-and-say pronun)))))","user":"573d58c8e4b05c31a32c0811"},{"problem":110,"code":"(fn [lis]\n  (next (iterate (fn [l]\n                   (->> (partition-by identity l)\n                        (map #(list (count %) (first %)))\n                        flatten)) lis)))","user":"581e61b0e4b04b46fc4b0f28"},{"problem":110,"code":"(fn [x]\n  (letfn [(pronuntiation [coll]\n            (->> (partition-by identity coll)\n                 (mapcat #((juxt count first) %))))]\n    (rest (iterate pronuntiation x))))","user":"5f82609ae4b0c071e6c840f9"},{"code":"(fn pronunciations [coll]    (let [next-coll (loop [xs (rest coll) prev (first coll) size 1 result []]                      (if (empty? xs)                        (apply conj result [size prev])                        (let [curr (first xs)]                          (if (= prev curr)                            (recur (rest xs) curr (inc size) result)\n                            (recur (rest xs) curr 1 (apply conj result [size prev]))))))]\n      (lazy-seq (cons next-coll (pronunciations next-coll)))))","problem":110,"user":"4dc29a1d535d020aff1edf96"},{"problem":110,"code":"(fn pronounce [s]\n  (lazy-seq\n    (let [pronounciation (flatten (map (juxt count first)\n                                       (partition-by identity s)))]\n      (cons pronounciation (pronounce pronounciation)))))","user":"5353afa0e4b084c2834f4b03"},{"problem":110,"code":"(fn [input] (rest (iterate (fn [i]\n          (vec (flatten\n           (map\n              #(vector (count %) (first %))\n              (partition-by identity i))))) input)))","user":"5f548678e4b0a0bc16850a7e"},{"code":"(letfn [\n\n(runs [lst]\n (let [fst (first lst)]\n  (count (take-while #(= fst %) lst))))\n\n(iter [lst]\n (let [fst (first lst) len (runs lst)]\n  (if (nil? fst) '()\n   (cons len (cons fst (iter (drop len lst)))))))\n\n] (fn [lst]\n (iterate iter (iter lst))))","problem":110,"user":"4e356d2b535deb9a81d77f2d"},{"code":"(fn proseq [startseq]\n  (letfn [(pronounce [s]\n            (if (empty? s)\n               ()\n               (cons (count (take-while #(= % (first s)) s))\n                     (cons (first s)\n                           (pronounce (drop-while #(= % (first s)) s))))))]\n    (let [nextseq (pronounce startseq)]\n      (cons nextseq\n            (lazy-seq (proseq nextseq))))))","problem":110,"user":"4fe87e56e4b07c9f6fd12c40"},{"problem":110,"code":"(fn __\n  [x]\n  (letfn [(pron [x] (flatten (map #(vector (count %) (first %)) (partition-by identity x))))\n          (f [coll] (lazy-seq (cons coll (f (pron coll)))))]\n    (f (pron x))))","user":"5b73e500e4b047b03b2036ba"},{"problem":110,"code":"(fn foo [coll]\n  (let [v (mapcat (juxt count first) (partition-by identity coll))]\n    (cons v (lazy-seq (foo v)))))","user":"561ba3e5e4b073c65b0ce3eb"},{"code":"(fn [s]\n    (drop 1 (iterate (fn [ v ]\n    (mapcat #(vector (count %) (first %)) (partition-by identity v))) s)))","problem":110,"user":"51f59607e4b0abb92f97f9d5"},{"problem":110,"code":"(fn\n  [x]\n  (letfn [(pronounce [xs]\n            (mapcat #(list (count %) (first %))\n                    (partition-by identity xs)))]\n    (iterate pronounce (pronounce x))))","user":"5ecfd429e4b016b56eae05a9"},{"problem":110,"code":"(fn [xs]\n  (letfn [(f [xs] (mapcat #(vector (count %) (first %)) (partition-by identity xs)))]\n    (rest (iterate f xs))))","user":"559454f2e4b0c79f6e1db952"},{"code":"(fn f [s]\r\n    (lazy-seq     \r\n     (let [p\r\n           (->> s\r\n                (partition-by identity)\r\n                (mapcat #(vector (count %) (first %))))]\r\n       (cons p (f p)))))","problem":110,"user":"4f047177535dcb61093f6bc6"},{"code":"(fn syllable [coll]\n  (let [partitioned (partition-by identity coll)\n        result (mapcat #(list (count %) (first %)) partitioned)]\n    (cons result (lazy-seq (syllable result)))))","problem":110,"user":"528b08efe4b0239c8a67ae8a"},{"problem":110,"code":"(fn pronunciationX [v]\n\t(lazy-seq (let [newV ((fn pronunciation [v] \n(mapcat (fn pronunciationOne [v] [(count v) (first v)])\n ((fn partitionIdentity [v] (partition-by identity v))\n v))\n)\n v)] \n\t\t(cons newV (pronunciationX newV))))\n\t)","user":"568820e8e4b0dcc4269f4067"},{"problem":110,"code":"(fn seq-pronun [coll]\n           (letfn [(partitioned-vec [x]\n                     (partition-by identity x))\n                   (count-vec [x]\n                     (map #(count %) (partitioned-vec x)))\n                   (number-vec [x]\n                     (map #(first %) (partitioned-vec x)))\n                   (pronunciation [x]\n                     (vec (interleave (count-vec x) (number-vec x))))]\n             (rest (iterate pronunciation coll))))","user":"58dcb8cde4b0a4d5acaab6a7"},{"problem":110,"code":"(fn [x]\n  (rest\n   (iterate\n    (fn [x]\n      (apply concat (map #(vector (count %) (first %)) (partition-by identity x))))\n    x)))","user":"60c43b20e4b0e0fa5f1b42c9"},{"code":"(fn [init]\n    (letfn [(pronunciation [s]\n              (loop [s s\n                     nxt '[]]\n                (if (empty? s)\n                  nxt\n                  (let [h (first s)\n                        [t d]\n                        (split-with #(= h %) s)]\n                    (recur d\n                           (conj nxt (count t) h))))))]\n      (drop 1 (iterate pronunciation init))))","problem":110,"user":"4f5cc3b8e4b0030a34fb2b2b"},{"code":"(fn pronounce [coll]\n  (letfn [(group-numbers [coll]\n            (lazy-seq\n              (when (seq coll)\n                (cons\n                  (take-while #(= % (first coll)) coll)\n                  (group-numbers (drop-while #(= % (first coll)) coll))))))]\n    (let [first-coll (apply concat\n                            (map\n                              #(vector (count %) (first %))\n                              (group-numbers coll)))]\n      (lazy-seq (cons first-coll (pronounce first-coll))))))","problem":110,"user":"4dab218f30acd6ed15482a68"},{"problem":110,"code":"(fn lazy-pron [sq]\n  (let [pron (fn [sq]\n               (->> (partition-by identity sq)\n                    (map (fn [e] [(count e) (first e)]))\n                    (reduce concat [])))]\n    (lazy-seq\n     (cons (pron sq) (lazy-pron (pron sq))))))","user":"4f041de1535dcb61093f6ba5"},{"code":"(fn p [n]\n  (let [r ((fn [n] (reduce #(conj % (count %2) (first %2)) [] (partition-by identity n))) n)]\n    (cons r (lazy-seq (p r)))))","problem":110,"user":"50e4f4e9e4b049a987753896"},{"problem":110,"code":"(fn [se]\n  (drop 1\n        (iterate (fn [s]\n                   (mapcat #(vector (count %) (first %))\n                           (partition-by identity s)))\n                 se)))","user":"580bd81ee4b0849f6811b711"},{"problem":110,"code":"(fn f [xs]\n  (rest (iterate (fn [xs]\n                 (loop [pro []\n                        prev-x (first xs)\n                        n-same 1\n                        xs-left (rest xs)]\n                   (if-not (seq xs-left) (into pro [n-same prev-x])\n                     (let [[new-pro new-prev-x new-n-same new-xs-left]\n                           (if (= prev-x (first xs-left))\n                               [pro prev-x (inc n-same) (rest xs-left)]\n                               [(into pro [n-same prev-x]) (first xs-left) 1 (rest xs-left)])]\n                       (recur new-pro new-prev-x new-n-same new-xs-left))))) \n               xs)))","user":"529e3a4fe4b04e0c58e87b92"},{"code":"(fn [coll]\n  (rest\n   (iterate\n    (fn [coll]\n      (mapcat\n       (fn [items]\n         [(count items) (first items)])\n       (partition-by identity coll)))\n    coll)))","problem":110,"user":"4e68c434535d8ccf87e9fe89"},{"code":"(fn [colls]\n\t(rest\n\t(iterate\n\t\t(fn [colls]\n\t\t\t(reduce \n\t\t\t\t#(if (empty? %) \n\t\t\t\t\t(conj % 1 %2)\n\t\t\t\t\t(do (println % %2)\n\t\t\t\t\t\t(if (= %2 (last %))\n\t\t\t\t\t\t\t(conj (vec (drop-last 2 %))\n\t\t\t\t\t\t\t\t(inc (second (reverse %))) \n\t\t\t\t\t\t\t\t(last %))\n\t\t\t\t\t\t\t(conj % 1 %2))))\n\t\t\t\t[]\n\t\t\t\tcolls))\n\t\tcolls)))","problem":110,"user":"520242bae4b030ee0c5b26e3"},{"problem":110,"code":"(fn inf-pron [coll]\n  (let [new-item (mapcat (fn [x] [(count x) (first x)])\n                         (partition-by identity coll))]\n    (lazy-seq\n      (cons new-item (inf-pron new-item)))))","user":"5515b138e4b055c2f668d4ed"},{"code":"#(drop 1 (iterate \n  (fn [x] \n    (mapcat (fn [v] [(count v) (first v)]) (partition-by identity x)))\n  %))","problem":110,"user":"502904e0e4b0feaf66e22fad"},{"code":"(fn [init]\n  (rest\n    (iterate\n      (fn [coll]\n        (flatten\n          (map (fn [c] [(count c) (first c)])\n            (partition-by identity coll))))\n    init)))","problem":110,"user":"4dfe65a1535d04ed9115e787"},{"code":"(comp rest\n  (partial iterate\n    (fn [s]\n      (mapcat (juxt count first) (partition-by identity s)))))","problem":110,"user":"527cd633e4b0757a1b17136f"},{"problem":110,"code":"(fn num-pron [digits]                                                          \n  (drop 1                                                                        \n        (iterate                                                                 \n          (fn [digits]                                                           \n            (flatten                                                             \n              (map                                                               \n                #(vector (count %) (first %))                                    \n                (partition-by identity digits))))                                \n          digits)))","user":"58ebd10de4b056aecfd47d49"},{"problem":110,"code":"(fn [x] (rest (iterate (fn [x] (mapcat #(-> [(count %) (first %)]) (partition-by identity x))) x)))","user":"53b15e6ee4b047364c04448f"},{"code":"(fn [coll]\n  (drop 1 (iterate #(flatten (map (fn [c] (list (count c) (first c)))\n  \t\t\t    (partition-by identity %)))\n\t\t     coll)))","problem":110,"user":"4e949d18535dbda64a6f6b15"},{"code":"(comp rest (partial iterate (fn [s] (mapcat #(vector (count %) (first %)) (partition-by identity s)))))","problem":110,"user":"4fe8a1f8e4b07c9f6fd12c5f"},{"problem":110,"code":"(fn a [x]\n  (let [f (fn [x]\n            (loop [x x\n                   y (rest x)\n                   i 1\n                   r []]\n              (cond (= y '()) (conj r i (first x))\n                    (= (first x) (first y)) (recur (rest x) (rest y) (inc i) r)\n                    :else (recur (rest x) (rest y) 1 (conj r i (first x))))))]\n    (cons (f x) (lazy-seq (a (f x))))))","user":"51ab70c3e4b04e3dc0c27b33"},{"problem":110,"code":"(fn pron [coll]\n  (lazy-seq \n   (let [cts (map count (partition-by identity coll))\n         nums (map first (partition-by identity coll))\n         pro (interleave cts nums)\n         ]\n     (cons pro (pron pro))\n   )))","user":"53e76bb2e4b036ad0777e47d"},{"problem":110,"code":"(fn [xs]\n  (drop 1 (iterate #(mapcat (juxt count first) (partition-by identity %)) xs)))","user":"5d0bb4fae4b0cc9c91588237"},{"code":"(fn [n] \n  (drop 1 (iterate (fn [x] (mapcat #(list (count %) (first %))\n                           (partition-by identity x))) n)))","problem":110,"user":"4ea1b9e4535d7eef308072b8"},{"problem":110,"code":"(fn seq-pronunce [coll]\n  (letfn [(one-pronunce [coll] (let [cs (take-while #(= % (first coll)) coll)\n                                     p [(count cs) (first cs)]\n                                     ne (drop (count cs) coll)]\n                                 (if (empty? ne) p\n                                   (concat p (one-pronunce ne)))))]\n    (let [ps (one-pronunce coll)]\n      (lazy-seq (cons ps (seq-pronunce ps))))))","user":"52ee0de4e4b05e3f0be25ec1"},{"code":"(fn [s]\n  (rest (iterate #(flatten \n                    (map (juxt count first) \n                         (partition-by + %))) s)))","problem":110,"user":"4ec74de3535d6d7199dd36df"},{"code":"(fn pronunc\n  [[a1 & b1 :as ls1]]\n  (loop [a a1 b b1 ls ls1 count 1 acc []]\n    (cond\n     (nil? a) (lazy-seq (cons acc (pronunc acc)))\n     (nil? b) (recur nil nil ls count (-> acc (conj count) (conj a)))\n     (= a (first b)) (recur (first b) (rest b) (rest ls) (inc count) acc)\n     :else (recur (first b) (rest b) (rest ls) 1 (-> acc (conj count) (conj a))))))","problem":110,"user":"5301157ae4b0d8b024fd3717"},{"code":"(fn pronounce [v]\n  \t(let [result (flatten (map #(list (count %) (first %)) (partition-by identity v)))]\n     \t(cons result (lazy-seq (pronounce result)))))","problem":110,"user":"534f13b2e4b084c2834f4ac4"},{"code":"(fn [s]\n  (rest (iterate #(mapcat (fn [e] [(count e) (first e)]) (partition-by identity %)) s)))","problem":110,"user":"4e52d815535d302ef430da77"},{"code":"#(iterate % (% %2))\n#(mapcat (juxt count last) (partition-by + %))","problem":110,"user":"4dce6e41535d5973398f92a2"},{"code":"(fn [x] (rest  (iterate #(mapcat (juxt count first)\n                                  (partition-by identity %)) x)))","problem":110,"user":"4ff67852e4b0678c553fc37e"},{"problem":110,"code":"(fn [x]\n (letfn\n  [\n   (pronounce [x]\n\n    (let [ pronounced \n\n     (interleave \n     (map \n      count \n      (partition-by identity x)\n     )  \n    (map \n      first \n      (partition-by identity x)\n    ) \n   )\n   ]\n  (lazy-seq (cons pronounced (pronounce pronounced)))))\n  ]\n\n (pronounce x))\n )","user":"56e6e1e6e4b02e7e935eb6cf"},{"code":"#(let [g (fn [z]\r\n           (apply concat\r\n                 (reduce (fn [[a w] x]\r\n                          (if (nil? w) [a [1 x]]\r\n                           (let [[c g] w]\r\n                             (if (= x g) [a [(inc c) g]]\r\n                              [(concat a w) [1 x]]))))\r\n                          [[] nil] z)))]\r\n    (iterate g (g %)))","problem":110,"user":"4e8681b7535dae1a5effa438"},{"code":"(fn squash [nums]\n  (let [val (flatten\n             (map #(vector (count %) (first %))\n                  (partition-by identity nums)))] \n    (cons val\n          (lazy-seq (squash val)))))","problem":110,"user":"4e7f51eb535db966e863cc3f"},{"code":"(fn [init]\n   (drop 1 (iterate (fn [s] (mapcat #(list (count %) (first %)) (partition-by identity s))) init)))","problem":110,"user":"4ede8e1d535d10e5ff6f5339"},{"problem":110,"code":"(fn [xs]\n  (rest (iterate\n          (fn [xs]\n            (->> xs\n                 (partition-by identity)\n                 (mapcat #((juxt count first) %))))\n          xs)))","user":"50ec409ce4b04edc33777045"},{"code":"(fn [n] \n  (rest \n    (iterate \n      (fn [x] \n        (mapcat #(list (count %1) (first %1)) \n                (partition-by identity x))) \n      n)))","problem":110,"user":"4f1fd734535d64f6031464a5"},{"problem":110,"code":"(fn pron\n  [x]\n  (drop 1 (iterate #(mapcat (fn [s] [(count s) (first s)]) (partition-by identity %)) x)))","user":"57ea2c91e4b0bfb2137f5b42"},{"code":"(fn o [s]\n  (lazy-seq\n    (#(cons % (o %))\n     ((fn i [[a :as s]]\n       (lazy-seq\n         (if (nil? a) nil\n          (let [[r t] (split-with #(= a %) s)]\n            (cons (count r) (cons a (i t)))))))\n     s))))","problem":110,"user":"4e5fe31a535d8ccf87e9fe50"},{"problem":110,"code":"(fn [s]\n (next (iterate \n   #(let [seq (partition-by identity %)]\n    (interleave (map count seq) (map first seq))) s)))","user":"534fa9dae4b084c2834f4acf"},{"code":"(fn this [x]\n   (lazy-seq\n    (let [res (reduce #(conj %1 (count %2) (first %2)) [] (partition-by identity x))]\n      (cons res (this res)))))","problem":110,"user":"4eb02674535d7eef30807338"},{"problem":110,"code":"(fn [v]\n(rest\n        (iterate (fn [a]\n                   (mapcat #(vector (count %) (first %))\n                           (partition-by identity a))) v)))","user":"54a11042e4b09f271ff37c49"},{"code":"(fn [xs]\n(rest \n  (iterate\n(fn pr [x]\n  (if (seq x)\n      (concat [(count (take-while #(= (first x) %) x))\n              (first x)]\n       (pr (drop-while #(= (first x) %) x)))\n      [])) xs)))","problem":110,"user":"4fdd27f3e4b05e33b9224f78"},{"problem":110,"code":"(fn pronunciations [coll]\n  (let [p (->> (partition-by identity coll)\n               (mapcat #(vector (count %) (first %))))]\n    (lazy-seq (cons p (pronunciations p)))))","user":"5666500ee4b0e91d5f5c566d"},{"problem":110,"code":"(letfn \n[\n( span [xs] (split-with #(= (first xs) %) xs))\n( chunk [xs] \n  (map first \n    (take-while \n      #(< 0 (count (first %))) \n      (iterate \n        (fn [[xs ys]] (vec (span ys)))\n        (vec (span xs))))))\n( pronounce [xs] (mapcat (juxt count first) (chunk xs)))]\n  #(rest (iterate pronounce %)))","user":"57717915e4b0979f896515b3"},{"code":"(fn p [s] \n  (let [t (->> (partition-by identity s)\n               (mapcat #(list (count %) (first %))))]\n    (cons t (lazy-seq (p t)))))","problem":110,"user":"4fa05b99e4b0dcca54ed6d47"},{"problem":110,"code":"(fn pronunciation [l]\n  (let [l2 (reduce #(if (= %2 (first (first %1)))\n                      (conj (rest %1) (conj (first %1) %2))\n                      (conj  %1 (list %2))) '() l)\n        lres  (reduce #(conj %1 (first %2) (count %2)) '() l2)\n        ]\n    (cons lres (lazy-seq (pronunciation lres)))))","user":"574f1c24e4b02ea114799255"},{"code":"(fn [coll]\n           (next (iterate #(mapcat (juxt count first) (partition-by identity %)) coll)))","problem":110,"user":"4f036d9b535dcb61093f6ac1"},{"problem":110,"code":"(fn pron [s]\n  (let [ps (mapcat #(vector (count %) (first %))\n                   (partition-by identity s))]\n    (lazy-seq (cons ps (pron ps)))))","user":"55dcb06ee4b050e68259b3b9"},{"code":"(fn [x] (rest ((partial iterate (fn say-number [nums]\n  (if-let [[x & xs] (seq nums)]\n    (let [[head tail] (split-with #(= x %) nums)]\n      (conj (say-number tail) x (count head)))\n    '()))) x)))","problem":110,"user":"4fcaf7a4e4b0ee37620e1857"},{"problem":110,"code":"(fn seq-of-pronuns [coll]\n  (lazy-seq\n   (let [res (mapcat (juxt count first) (partition-by identity coll))]\n     (cons res (seq-of-pronuns res)))))","user":"58ffac9de4b0438e51c2cffd"},{"code":"(fn pronounce [coll]\n  (let [pronounciation (mapcat #(vector (count %) (first %)) (partition-by identity coll))]\n    (lazy-seq\n       (cons pronounciation (pronounce pronounciation)))))","problem":110,"user":"51d08d67e4b067c365486351"},{"problem":110,"code":"(fn [col]\n (->> col\n  (iterate #(->> (partition-by identity %)\n             (mapcat (fn [x] [(count x) (first x)]))))\n  rest))","user":"5b61aa6ae4b0c6492753e712"},{"code":"(fn [s]\n  (rest\n  (iterate\n   (fn [t]\n     (flatten (map (juxt count first) (partition-by identity t))))\n   s)))","problem":110,"user":"4fa340b4e4b081705acca18c"},{"problem":110,"code":"(fn [c]\n  (drop 1 (iterate (fn [c]\n         (first (reduce (fn [[coll cnt n] x]\n                          (println \"cnt=\" cnt \"n=\" n \"x=\" x)\n                      (if (= x n)\n                        [coll (inc cnt) n]\n                        [(conj coll cnt n) 1 x]))\n                   [[] 1 (first c)]\n                   (rest (conj c nil))))) c)))","user":"58949f8de4b00487982d525e"},{"problem":110,"code":"(fn [init]\n  (letfn [(f [coll] (->> (partition-by identity coll)\n                         (mapcat (juxt count first))))]\n    (iterate f (f init))))","user":"59c94a69e4b0a024fb6ae576"},{"problem":110,"code":"(fn [xs] (rest (iterate #(->> % (partition-by identity) (map (fn [x] (vector (count x) (first x)))) (apply concat)) xs)))","user":"5416b4a2e4b01498b1a71a01"},{"problem":110,"code":"(letfn [(p [v] (->> (partition-by identity v) (mapcat #(-> [(count %) (first %)])) ))]\n  (fn psq [v]\n    (let [n (vec (p v))]\n      (lazy-seq  (cons n (lazy-seq (psq n)))))))","user":"5ecc0831e4b016b56eae058c"},{"code":"(fn lazy-p [init]\n  (let [p (mapcat #(vector (count %) (first %))(partition-by identity init))]\n  (cons p (lazy-seq (lazy-p p)))))","problem":110,"user":"4f0446f9535dcb61093f6bb8"},{"problem":110,"code":"(fn [init] (drop 1 (iterate (fn [xs] (->> xs (partition-by identity) (mapcat #(vector (count %) (first %))) vec)) init)))","user":"5da8fa72e4b000c986472c2d"},{"problem":110,"code":"(fn f[s]\n  (let [r (loop [a s rr [] l (first a) c l cc 0 ] \n            (cond (empty? a) (conj rr cc l) \n              (= l c) (recur (rest a) rr c (second a) (inc cc) )\n              :else (recur (rest a) (conj rr cc l)  c (second a) 1)\n              \n          ))\n        ]\n    (cons r (lazy-seq (f r)))  \n  )\n)","user":"55eeb37ae4b0121d4835fdf3"},{"problem":110,"code":"(letfn [(pro [xs] (->> xs (partition-by identity) (mapcat #(vector (count %) (first %)))))]\n  (comp next (partial iterate pro)))","user":"53908e6be4b0b51d73faae9a"},{"problem":110,"code":"(fn a [xs] (lazy-seq (let [t (flatten (map #(vec [(count %) (first %)]) (partition-by #(int %) xs)))] (cons t (a t)))))","user":"5507cfd3e4b021ccfedb96ad"},{"problem":110,"code":"(fn ps\n  [coll]\n  (letfn [(fnp [c]\n             (let [[es rst] (split-with #(= (first c) %) c)]\n               (concat [(count es) (first es)] (when (seq rst) (fnp rst)))))]\n    (let [np (fnp coll)]\n      (cons np (lazy-seq (ps np))))))","user":"4ee528fb535d1385b2869d87"},{"code":"(fn i [s]\n  (let [n (mapcat (juxt count first)\n            (partition-by #(do %) s))]\n    (cons n (lazy-seq (i n)))))","problem":110,"user":"4fe8aef4e4b07c9f6fd12c6c"},{"problem":110,"code":"(fn f [x] \n  (lazy-seq \n   (let [n (reduce \n            #(conj % (count %2) (first %2)) \n            [] \n            (partition-by identity x))] \n     (cons n (f n)))))","user":"51dd5d6fe4b0c33a4e1da406"},{"problem":110,"code":"(fn sop [s]\n  (let [nxt (->> s\n                 (partition-by identity)\n                 (map #(list (count %) (first %)))\n                 (reduce into []))]\n    (lazy-seq (cons nxt (sop nxt)))))","user":"567e418fe4b0feffd0d18eb1"},{"problem":110,"code":"(fn pron [col]\n  (let \n    [\n      newcol\n      (reverse (first (reduce (fn [[cl cur cnt] v]\n        (if (= cur v) \n          [(conj (rest (rest cl)) (inc cnt) v) cur (inc cnt)]\n          [(conj cl 1 v) v 1]\n        )\n      ) [() nil 0] col)))\n    ]\n    (lazy-seq (cons newcol (pron newcol)))\n  )\n  \n)","user":"5bbd13a5e4b07a9b28b0ff95"},{"problem":110,"code":"#(letfn [(pronunce [num-coll]\n\t(loop [nums (rest num-coll), prev (first num-coll), len 1, result []]\n\t\t(if (empty? nums)\n\t\t\t(conj result len prev)\n\t\t\t(let [n (first nums), nums' (rest nums)]\n\t\t\t\t(if\t(= n prev)\n\t\t\t\t\t(recur nums' prev (inc len) result)\n\t\t\t\t\t(recur nums' n 1 (conj result len prev)))))))]\n\t(iterate pronunce (pronunce %)))","user":"5370b386e4b0fc7073fd6e9b"},{"problem":110,"code":"(fn pronunciations [coll]\n  (let [pronunciation (fn [coll] (->> (partition-by identity coll)\n                                      (mapcat (juxt count first))))]\n    (rest (iterate pronunciation coll))))","user":"5879d577e4b01531a375ead8"},{"problem":110,"code":"(fn pronounce \n  ([s] (pronounce 1 (first s) [] (rest s)))\n  ([nb e vs s]\n   (if (seq s)\n     (if (= (first s) e)\n       (recur (inc nb) e vs (rest s))\n       (recur 1 (first s) (conj vs nb e) (rest s)))\n     (let [nxt (conj vs nb e)]\n       (lazy-seq (cons nxt (pronounce nxt)))))))","user":"54ca93abe4b057c6fda3a264"},{"code":"#(rest (iterate (fn pronun [g]\n                  (reduce (fn f[s el] \n                       (let [n (peek s)\n                             p (peek (pop s))]                    \n                        (if (= el n) \n                          (into (pop (pop s)) [(inc p) n]) \n                          (into s [1 el]) )\n                       )\n                     ) [1 (first g)] (rest g))) %))","problem":110,"user":"526a3412e4b03e8d9a4a721e"},{"problem":110,"code":"(fn f [n]\n  (letfn [(pro [c]\n               (loop [r c\n                      f []]\n                 (if (empty? r)\n                   f\n                   (let [v (first r)\n                         c (count (take-while #{v} r))]\n                     (recur (drop c r) (conj f c v))))))]\n    (let [p (pro n)]\n      (lazy-seq (cons p (f p))))))","user":"53fb5256e4b0de5c4184857f"},{"code":"#(rest (iterate (fn [ys] (mapcat (juxt count first) (partition-by identity ys))) %))","problem":110,"user":"51bd1a0de4b0df1216cefd93"},{"problem":110,"code":"(fn [coll]\n  (->> coll\n       (iterate #(->> (partition-by identity %)\n                      (mapcat (fn [p] [(count p) (first p)]))))\n       rest))","user":"57f80350e4b0d3187e90090c"},{"code":"(fn [s]\n  (letfn [(punc [x]\n                (vec (flatten (map (fn [p] [(count p) (first p)])\n                                  (partition-by identity\n                                            x)))))]\n    (iterate punc (punc s))))","problem":110,"user":"531d34cfe4b08068f379edac"},{"problem":110,"code":"(fn [x] (rest (iterate (fn [l] ((fn [l v] (if (empty? l)\n                                            v (let\n                                                [[l1 l2] (split-with (partial = (first l)) l)]\n                                                (recur l2 (conj v (count l1) (first l)))))) l [])) x)))","user":"584dadebe4b0b7285a6f4e44"},{"code":"(fn s-o-p [x]\n  (let [r (flatten (map #(vector (count %) (first %)) (partition-by identity x)))]\n\t     (lazy-seq (cons r (s-o-p r)))))","problem":110,"user":"4ec5d62c535d6d7199dd36ba"},{"problem":110,"code":"(fn pron [s]\n  (rest (iterate (fn [v] (mapcat #(vector (count %) (first %)) (partition-by identity v))) s)))","user":"53e745a1e4b036ad0777e479"},{"problem":110,"code":"(letfn [(pronounce-seq [v] (lazy-seq (cons (count (take-while (partial = (first v)) v))\n                                           (cons (first v)\n                                            (let [vv (drop-while (partial = (first v)) v)]\n                                              (if (seq vv)\n                                                (pronounce-seq vv)\n                                                nil))))))]\n  (fn iter-pronounce-seq [v]\n    (lazy-seq (cons (pronounce-seq v)\n                    (iter-pronounce-seq (pronounce-seq v))))))","user":"51dafedee4b09f6bc204eee2"},{"problem":110,"code":"(fn pro [se]\n   (let [p (mapcat #(vector (count %) (first %)) (partition-by identity se))]\n       (lazy-seq (cons p (pro p)))))","user":"56018dd4e4b04bb52996e18f"},{"code":"(fn f [v]\n    (let [say (fn _ [v]  \n                (flatten (for [e (partition-by identity v)] [(count e) (first e)])))]\n    (cons (say v) (lazy-seq (f (say v))))))","problem":110,"user":"4f038567535dcb61093f6b0c"},{"problem":110,"code":"#(rest((fn f[x](lazy-cat[x](f(mapcat(juxt count first)(partition-by + x)))))%))","user":"4db2903f535df7e46ed9b6bf"},{"code":"(fn rec [x]\n  (let [n (mapcat #(vector (count %) (first %)) (partition-by identity x))]\n    (lazy-seq (cons n (rec n)))))","problem":110,"user":"52d1e364e4b0d9f9285948e7"},{"code":"(fn f [v]\n (next \n  (iterate\n   #(let [p (partition-by identity %)]\n      (flatten\n        (for [t p]\n          [(count t) (first t)])))\n   v)))","problem":110,"user":"4daddc19c9a9d6ed4599dc57"},{"problem":110,"code":"(fn pronunciations\n  [nums]\n  (let [x (mapcat (juxt count first) (partition-by identity nums))]\n    (lazy-seq (cons x (pronunciations x)))))","user":"56603e5fe4b068f2fe63dc4a"},{"problem":110,"code":"(fn prn [s]\n  (let [next (->> s\n                  (partition-by identity)\n                  (reduce #(into % [(count %2) (first %2)]) []))]\n    (lazy-seq (cons next (prn next)))))","user":"563dfc02e4b0da801c4e4662"},{"problem":110,"code":"(fn [col] (let [say-it  \n  (fn [col] (mapcat #(list (count %) (first %)) \n          (partition-by identity col)))]\n            (next \n             (iterate say-it col))))","user":"50856bd1e4b004985b776e4c"},{"code":"(fn f[x]\n  (let [y (mapcat \n            #(vector (count %) (first %)) \n            (partition-by identity x))]\n  (cons y (lazy-seq (f y)))))","problem":110,"user":"4ec0c7ba535dfed6da9c6da4"},{"problem":110,"code":"(fn pronounce [xs]\n  (let [p (mapcat (fn [a] [(count a) (first a)])\n                (reduce\n                 (fn [coll n]\n                   (let [last-group (if (empty? coll) [] (last coll))\n                         mine (if (empty? last-group ) n (first last-group))]\n                     (if (= mine n)\n                       (conj (vec (drop-last coll)) (conj last-group n) )\n                       (conj coll [n]))\n                     )) [] xs))]\n    (cons p (lazy-seq (pronounce p)))\n    )\n  \n  )","user":"564a560ae4b0284900eef654"},{"code":"(fn [s] \n (letfn [(step [s] \n        (reduce (fn [v col] (conj v (count col) (first col))) [] (partition-by identity s)))]\n  (iterate step (step s))))","problem":110,"user":"4f29eb2ae4b0d6649770a037"},{"problem":110,"code":"(let [pronounce (fn [coll]\n                    (reduce (fn [so-far this-part]\n                              (concat so-far [(count this-part) (first this-part)]))\n                            []\n                            (partition-by identity coll)))]\n    (fn inf-pron\n      [coll]\n      (lazy-seq (cons (pronounce coll)\n                      (inf-pron (pronounce coll))))))","user":"53716539e4b0fc7073fd6eb1"},{"problem":110,"code":"(fn g [xs]\n  (letfn\n    [(f\n      ([xs x c rs]\n       (let [ys (rest xs)\n             y (first xs)]\n         (if (= x y) \n           (recur ys x (inc c) rs)\n           (let [ps (conj rs c x)]\n             (if (seq xs)\n               (recur ys y 1 ps)\n               ps)))))\n      ([xs] (f (rest xs) (first xs) 1 [])))]\n    (lazy-seq (cons (f xs) (g (f xs))))))","user":"5799ff45e4b05b1deef9add1"},{"code":"(fn [n]\n  (rest (iterate (fn [x]  \n         (mapcat  #(vector (count %) (first %) ) \n              (partition-by identity x))) n )))","problem":110,"user":"4fccdc75e4b0ee37620e186d"},{"problem":110,"code":"(fn pronounce [coll]\n   (let [nxt (->> (partition-by identity coll)\n                  (mapcat #(vector (count %) (first %))))]\n     (lazy-seq (cons nxt (pronounce nxt)))))","user":"535eaa73e4b04ce2eb3ed2d4"},{"problem":110,"code":"(fn [numbers]\n                    (let [step-fn (fn [numbers]\n                                    (vec (flatten (mapv (fn [group]\n                                                          [(count group) (first group)])\n                                                        (partition-by identity numbers)))))]\n                      (iterate step-fn (step-fn numbers)))\n\n                    )","user":"53f891eee4b0de5c4184856d"},{"problem":110,"code":"(fn [init]\n  (drop 1\n        (iterate\n         (fn [s]\n           (mapcat (comp reverse flatten vec frequencies) (partition-by identity s)))\n         init)))","user":"56481722e4b0284900eef628"},{"problem":110,"code":"(fn pronunciations [lista]\n    (let [cuenta-pronuncia (fn [parte]\n                             (let [longitud (count parte)\n                                   primero (first parte)]\n                               [longitud primero]))\n          primeras-pronunciaciones (mapcat #(cuenta-pronuncia %) (partition-by identity lista))]\n      (lazy-seq (cons primeras-pronunciaciones (pronunciations primeras-pronunciaciones)))))","user":"5d0153f9e4b0cc9c915881aa"},{"problem":110,"code":"(fn [xs] \n  (rest (iterate \n           #(mapcat (juxt count first) \n                    (partition-by identity %)) \n           xs)))","user":"50c781bbe4b00bb60fe0c535"},{"problem":110,"code":"(fn lazy-sp [col]\n  (let [next-col (->> col\n                     (partition-by identity)\n                      (mapcat #(list (count %) (first %))))]\n    (lazy-seq\n     (cons next-col (lazy-sp next-col)))))","user":"5cf895efe4b0b71b1d808a85"},{"problem":110,"code":"(fn p [c]\n  (lazy-seq\n   (let [n (mapcat #(vector (count %) (first %))\n                   (partition-by identity c))]\n     (cons n (p n)))))","user":"53034738e4b0d8b024fd373e"},{"problem":110,"code":"(fn pronunciation [xs]\n  (let [res (mapcat (fn [ys] [(count ys) (first ys)]) \n                 (partition-by identity xs))]\n    (lazy-seq (cons res (pronunciation res)))))","user":"54b13a40e4b09f271ff37d1b"},{"problem":110,"code":"(fn pronunciations [input]\n  (letfn [(split-by-value [input]\n                          (map vec (partition-by identity input)))\n          (pronunciation [input]\n            (vec (apply\n                   concat\n                   (map #(-> [(count (second %)) (first %)]) (group-by identity input)))))]\n    (lazy-seq\n      (let [current (vec (apply concat (map pronunciation (split-by-value input))))]\n        (cons current (pronunciations current))))))","user":"57b9fb56e4b0fbc9809a27fa"},{"code":"(fn [s]\n  (rest\n    (iterate \n      #(->> (partition-by identity %)\n        (map (fn [x] [(count x) (first x)]))\n        flatten)\n      s)))","problem":110,"user":"4f06dcad535dcb61093f6c16"},{"problem":110,"code":"(fn pronunciate [s]\n  (when (seq s)\n    (letfn [(pronounce [xs]\n              (into [] (mapcat #(vector (count %) (first %))\n                               (partition-by identity xs))))]\n      (rest (iterate pronounce s)))))","user":"58327a08e4b089d5ab817c7c"},{"code":"(fn p [x]\n  (let [f (fn [i]\n            (mapcat (juxt count first) (partition-by identity i)))]\n    (lazy-seq\n      (cons (f x) (p (f x))))))","problem":110,"user":"507fbd77e4b089ade05efbd3"},{"problem":110,"code":"(fn [ns]\n   (let [next (fn [ns]\n                (if (empty? ns)\n                  []\n                  (let [[h & t] ns]\n                    (loop [current h\n                           ns-rest t\n                           count 1\n                           acc []]\n                      (if (empty? ns-rest)\n                        (conj acc count current)\n                        (let [[hh & tt] ns-rest]\n                          (if (= current hh)\n                            (recur hh tt (inc count) acc)\n                            (recur hh tt 1 (conj acc count current)))))))))]\n     (drop 1 (iterate next ns))))","user":"5e3ef7d4e4b01d43a70e8e2d"},{"problem":110,"code":"(fn pron [coll]\n  (let [pro #(->> %\n               (partition-by identity)\n               (mapcat (fn [v] [(count v) (first v)])))]\n  (iterate pro (pro coll))))","user":"5ba15075e4b0a20761a2339e"},{"problem":110,"code":"#(next\n  (iterate (fn [ns]\n             (loop [r []\n                    ns ns]\n               (if (empty? ns)\n                 (vec r)\n                 (let [[eqs rest] (split-with (partial = (first ns)) ns)]\n                   (recur (concat r [(count eqs) (first eqs)])\n                          rest)))))\n           %))","user":"57e0f30ae4b0bfb2137f5a66"},{"code":"(fn pronunciations- [coll]\n  \"110. Write a function that returns a lazy sequence                                                                                                                  \n  of 'pronunciations' of a sequence of numbers.\"\n  (letfn [(pronounce- [s]\n          (loop [[partition & xs] (partition-by identity s)\n                 acc []]\n            (if (empty? partition)\n              acc\n              (recur xs (conj acc (count partition) (first partition))))))]\n    (drop 1 (iterate pronounce- coll))))","problem":110,"user":"4e5eb843535d8a8b8723a2d4"},{"problem":110,"code":"(fn [xs]\n  (letfn [(pronounce [n] (mapcat #(list (count %) (first %)) (partition-by identity n)))]\n    (iterate pronounce (pronounce xs))))","user":"58ee84e5e4b056aecfd47dab"},{"code":"(fn __\n  [s]\n  (let [pronounce\n        (fn [s]\n          (mapcat identity\n                  (reduce\n                   (fn [acc curr]\n                     (if (empty? acc)\n                       (conj acc [1 curr])\n                       (let [prev-num ((last acc) 1)\n                             prev-cnt ((last acc) 0)]\n                         (if (= curr prev-num)\n                           (conj (vec (drop-last acc)) [(inc prev-cnt) prev-num])\n                           (conj acc [1 curr])))))\n                   []\n                   s)))]\n    (lazy-seq\n     (let [p (pronounce s)]\n       (cons p (__ p))))))","problem":110,"user":"4db53f87535d87e67b28fe08"},{"code":"(letfn [\n    (pron [x] (for [i (partition-by identity x) v [(count i) (first i)]] v))\n    (iterpron [x] (iterate pron (pron x)))]\n    iterpron)","problem":110,"user":"51cbdee1e4b08d8387cbede1"},{"problem":110,"code":"(fn pronunciate\n  [xs]\n  (let [pronunciation (->> xs\n                           (partition-by identity)\n                           (map #(vector (count %) (first %)))\n                           (apply concat))]\n    (lazy-seq (cons pronunciation\n                    (pronunciate pronunciation)))))","user":"5ce077e9e4b0a17bb84e2b0c"},{"problem":110,"code":"(let [it (fn [s]\n             (->> (partition-by identity s)\n               (map #(vector (count %) (first %)))\n               flatten\n               vec))\n        lz (fn pr [s] (lazy-seq (cons s (pr (it s)))))]\n    (fn [s] (rest (lz s))))","user":"4e837808535db62dc21a62d9"},{"problem":110,"code":"(fn [s]\r\n(rest (iterate (fn [l] (mapcat #(list (count %) (first %)) (partition-by identity l))) s)))","user":"5f2c02d1e4b033932238a65f"},{"problem":110,"code":"#(rest\n\t(iterate \n\t\t(fn [s]\n\t\t\t(reduce (fn [c v]\n\t\t\t\t\t\t(conj c (count v) (first v)))\n\t\t\t[]\n\t\t\t(partition-by identity s))) %))","user":"56baa68ce4b0f26550335947"},{"code":"#(next (iterate  \n            (fn [c]\n              (->> c \n                (partition-by identity)\n                (mapcat (juxt count first))))\n            %))","problem":110,"user":"4e50e2a0535dc968683fc4ef"},{"problem":110,"code":"(fn [l]\n  (letfn [(pronounciation [l]\n  \t(mapcat (fn [l] [(count l) (first l)])\n    \t(partition-by identity l)))]\n    (drop 1 (iterate pronounciation l))))","user":"60460824e4b02d28681c77bc"},{"code":"(fn thisfunc [s]\n  (let [out\n    (loop [l (first s) s (rest s) c 1 out []]\n      (if (empty? s)\n        (conj out c l)\n        (let [x (first s)]\n          (if (= l x)\n            (recur l (rest s) (inc c) out)\n            (recur x (rest s) 1 (conj out c l))))))]\n    (cons out\n      (lazy-seq (thisfunc out)))))","problem":110,"user":"4dd9d299535d2dad7130b5dd"},{"code":"(fn f [s]\n  (let [t (reduce #(conj % (count %2) (first %2)) [] (partition-by identity s))]\n    (cons t (lazy-seq (f t)))))","problem":110,"user":"4f954dbce4b0dcca54ed6ccd"},{"problem":110,"code":"(fn [s]\n  (rest\n    (iterate (fn [s]\n               (mapcat #(list (count %) (first %))\n                       (partition-by identity s)))\n             s)))","user":"4ec1b090535dfed6da9c6db5"},{"code":"(fn  sequence-of-pronunciations [v]\n  (lazy-seq\n   (let [[a, lc, ld]   (reduce \n\n                        (fn [[a,c,d]  x]\n                          (if (= d x)\n                            [a,(inc c),d]\n                            [(into a [c,d]),1,x]))\n                        \n                        [[],1,(first v)]\n                        (rest v))\n         rez (into a [lc,ld])]\n     \n     (cons rez (sequence-of-pronunciations rez)))))","problem":110,"user":"515bbcd9e4b0388ca8ca1521"},{"problem":110,"code":"(fn problem-110\n  [xs]\n  (->> xs\n       (partition-by identity) \n       (mapcat (juxt count first))\n       (#(lazy-seq (cons % (problem-110 %))))))","user":"58e37946e4b005f69f193cae"},{"code":"(fn hoge [col]\n  (letfn [(fff [col]\n\t    (mapcat (fn [x][(count x)(first x)])(partition-by identity col)))]\n    (iterate fff (fff col))))","problem":110,"user":"4db2cc55535df7e46ed9b6c5"},{"code":"(fn pro [coll]\n  (letfn [(pronounce [coll]\n            (mapcat (juxt count first) (partition-by identity coll)))]\n    (iterate pronounce (pronounce coll))))","problem":110,"user":"511b9017e4b00c2a1fa7ff6b"},{"code":"(fn a1 [s]\n  (let [b (mapcat (fn [a] [(count a) (first a)]) (partition-by identity s))]\n    (lazy-cat [b] (a1 b))))","problem":110,"user":"50ae0d24e4b0a40c9cfb08ce"},{"problem":110,"code":"(fn myf [coll]\n  (let [next-val (loop [c (rest coll) l (first coll) new-c [1 (first coll)]]\n                   (cond\n                     (empty? c) new-c\n                     (= (first c) l) (recur (rest c) l (into (pop (pop new-c)) [(inc (second (reverse new-c))) l]))\n                     :else (recur (rest c) (first c) (into new-c [1 (first c)]))))]\n     (lazy-seq (cons next-val (myf next-val))))\n )","user":"608ec5e4e4b03bd49d9f36c0"},{"code":"(fn seq-of-pron [xs]\n  (let [f\n    (let [& comp\n          p partial]\n      (& flatten\n         (p map #(list (count %) (first %)))\n         (p partition-by identity)))]\n    (iterate f (f xs))))","problem":110,"user":"52606318e4b03e8d9a4a7036"},{"problem":110,"code":"(fn p [col]\n  (let  [r (flatten (map (fn [x] [(count x) (first x)])\n                         (partition-by #(identity %) col)))]\n    (cons r (lazy-seq (p r)))))","user":"53664e3be4b0243289761e74"},{"code":"(fn [y] (rest (iterate (fn [x]\n    (mapcat #(list (count %) (first %)) \n          (partition-by identity x))) y)))","problem":110,"user":"4eaede1f535d7eef30807329"},{"code":"#(let [P (fn [c] (mapcat (fn [e] [(count e) (last e)]) (partition-by int c)))]\n  (iterate P (P %)))","problem":110,"user":"4f0ef874535d0136e6c22328"},{"problem":110,"code":"(fn [s]\n  (rest\n   (iterate\n    #(flatten (map (juxt count first) (partition-by identity %)))\n    s)))","user":"56ae214ce4b03c432f18735a"},{"code":"(fn [s]\n  (rest (iterate #(mapcat (juxt count first) (partition-by identity %))\n                 s)))","problem":110,"user":"500d8c49e4b07ccb9a7ddb00"},{"problem":110,"code":"(fn loopgroup [in]\n  (letfn [\n          (groupnums [in]\n            (loop [in in out []]\n              (if (empty? in)\n                out\n                (let [[run rst] (split-with #(== (first in) %) in)]\n                  (recur rst (conj out (count run) (first in)))))))\n          ]\n    (lazy-seq (cons (groupnums in) (loopgroup (groupnums in))))))","user":"562add6de4b00e49c7cb4834"},{"problem":110,"code":"(letfn\n  [(q4q110-pronounce [s v]\n   (if (empty? s)\n     v\n     (let [[head tail] (split-with #(= (first s) %) s)]\n      (recur tail (conj v (count head) (first head))))))]\n\n(fn q4q110 [s]\n  (lazy-seq\n   (let [pronunciation (q4q110-pronounce s [])]\n     (cons pronunciation\n           (q4q110 pronunciation))))))","user":"52213426e4b0e6a83c8925c4"},{"code":"(fn[x](rest(iterate #(mapcat(juxt count first)(partition-by identity %))x)))","problem":110,"user":"4dd4034a535dae65d5c462df"},{"code":"(fn pronounce-seq [x]\n  (letfn [(pronounce [coll]\n            (let [subseqs (partition-by identity coll)]\n              (vec (mapcat  #(vector (count %) (first %)) subseqs))))]\n    (let [pronounced (pronounce x)]\n      (lazy-seq\n        (cons pronounced (pronounce-seq pronounced))))))","problem":110,"user":"4e6defcc535d5021c1a895f8"},{"code":"(fn _p [seq]\n  (let [_plist (fn [s](loop [r [] k (first s) s s](if (empty? s) (apply concat (map #(list (count %) (first %)) r)) (let [tuple (for [_s s :while (= k _s)]_s) restseq (drop (count tuple) s)] (recur (conj r tuple) (first restseq) restseq)))))]\n  (cons (_plist seq) (lazy-seq (_p (_plist seq))))\n  )\n)","problem":110,"user":"522eba30e4b01cdb292c5f0e"},{"code":"(fn [x] (rest (iterate\n#(mapcat (fn [s] [(count s) (first s)])\n  (partition-by identity %)) x)))","problem":110,"user":"4eb97b2e535dfed6da9c6d54"},{"problem":110,"code":"(fn pronunciations [xs]\n  (let [partitions (partition-by identity xs)\n        counts (map count partitions)\n        pronunciation (interleave counts (map first partitions))]\n    (cons pronunciation (lazy-seq (pronunciations pronunciation)))))","user":"4fe49706e4b0e8f79898feb7"},{"problem":110,"code":"(fn [nums]\r\n  (let [pronounce (fn [nums] (->>\r\n          (partition-by identity nums)\r\n          (map (fn [x] [(count x) (first x)]))\r\n          (apply concat)))]\r\n    (rest (iterate pronounce nums))))","user":"555bd27ae4b0b056612e2244"},{"problem":110,"code":"(fn [coll]\n  {:pre [(seq coll)]}\n  (let [pronounce\n        (fn [coll]\n          (loop [acc []\n                 y (first coll)\n                 c 1\n                 [x & xs] (rest coll)]\n            (if-not x\n              (conj acc c y)\n              (if (= x y)\n                (recur acc y (inc c) xs)\n                (recur (conj acc c y)\n                       x 1 xs)))))]\n    (rest (iterate pronounce coll))))","user":"54d9f7f1e4b024c67c0cf751"},{"code":"(fn pronounciations\n  [coll]\n  (let [xs (mapcat (fn [part]\n                     (let [n (count part)]\n                       [n (first part)]))\n                   (partition-by identity coll))]\n    (cons xs (lazy-seq (pronounciations xs)))))","problem":110,"user":"4dc0ff08535d020aff1edf84"},{"problem":110,"code":"(fn [xs]                                                                                                                                                                           \n  (letfn [(pronun [xs]                                                                                                                                                                       \n            (->> xs                                                                                                                                                                          \n                 (partition-by identity)                                                                                                                                                     \n                 (mapcat #(list (count %) (first %)))))]                                                                                                                                     \n    (iterate pronun (pronun xs))))","user":"54d127b7e4b0e8a36923e5de"},{"problem":110,"code":"(fn p [a]\n  (let [b (flatten (for [c (partition-by identity a)] [(count c) (first c)]))]\n    (cons b (lazy-seq (p b)))))","user":"576df252e4b0979f8965156f"},{"problem":110,"code":"(fn [x](rest(iterate #(loop [xs %\n                        ys []\n                        c 1]\n                   (cond\n                     (= 1 (count %)) [1 (first %)]\n                     (empty? xs) ys\n                     (= (first xs ) (second xs)) (recur (rest xs) ys (inc c))\n                     :else (recur (rest xs) (conj ys c (first xs)) 1)\n                     )) x)))","user":"566a3a26e4b0a866af689699"},{"code":"; point-free style:\n(comp next\n      (partial iterate\n               (comp (partial mapcat (juxt count first))\n                     (partial partition-by identity))))\n\n; ordinary style:\n;  (fn [xs]\n;     (next\n;       (iterate\n;         #(mapcat\n;           (juxt count first)\n;           (partition-by identity %))\n;         xs)))","problem":110,"user":"4fd96694e4b05e33b9224f37"},{"problem":110,"code":"(fn f [xs]\n   (let [parts (partition-by identity xs)\n         res (flatten (map (juxt count first) parts))]\n     (lazy-seq (cons res (f res)))))","user":"54926752e4b0b312c081ff44"},{"problem":110,"code":"(fn recpron [aseq] \n(letfn [(pronounce [theseq] (if (empty? theseq) [] (let [result (take-while #(= (first theseq) %) theseq)] \n(concat [(count result)] [(first result)] (pronounce (drop-while #(= (first theseq) %) theseq))))))]\n(let [result (pronounce aseq)]\n(cons result (lazy-seq (recpron result))))))","user":"55f75c6be4b06e875b46cea9"},{"code":"(fn  [thevalue]\n    ( let [ listname (fn [v]\n    (loop [result [] currentkey (first v) currentcount 1 data (rest v) ]\n      (if (empty? data)\n            (concat result [currentcount currentkey]  )\n            (let [changed  (not= (first data) currentkey)]\n                 (recur (if changed\n                            (concat result [currentcount currentkey]  )\n                            result)\n                         (if changed (first data) currentkey)\n                         (if changed 1 (inc currentcount))\n                         (rest data)\n                   )\n\n                   ))\n      ))]\n    (iterate listname (listname thevalue))\n  ))","problem":110,"user":"4ec5bec6535d6d7199dd36b3"},{"code":"(fn lz-pro[in]\n  (when-let [s (seq in)]\n    (let [nxt (mapcat #(vector (count %) (first %)) (partition-by identity s))]\n      (lazy-seq  (cons nxt (lz-pro nxt))))))","problem":110,"user":"4fb86dc9e4b081705acca2d8"},{"problem":110,"code":"#(rest (iterate (fn [v] (mapcat (juxt count first) (partition-by identity v))) %))","user":"55f6fe09e4b06e875b46cea2"},{"problem":110,"code":"(letfn [(pronunciation [xs]\n                       (reduce #(conj %1 (count %2) (first %2)) [] (partition-by identity xs)))]\n  (fn pronunciations [xs]\n    (let [p (pronunciation xs)]\n      (cons p (lazy-seq (pronunciations p))))))","user":"5553b924e4b0deb715856e06"},{"problem":110,"code":"(fn pronounce [s]\n  (rest (iterate\n         #(loop [[f & _ :as xs] %\n                 acc []]\n            (if (empty? xs)\n              acc\n              (recur (drop-while #{f} xs)\n                     (conj acc (count (take-while #{f} xs)) f))))\n         s)))","user":"5c950334e4b048ec896c5a44"},{"code":"(fn [x]\n     (let [counter (fn [x]\n        (let [counted (map frequencies (partition-by identity x))]\n\t  (loop [s counted result []]\n\t     (if (empty? s) result\n\t         (recur (rest s) (conj (conj result (apply val (first s))) (apply key (first s))))))))]\n\t      (rest (iterate #(counter %) x))))","problem":110,"user":"4f066916535dcb61093f6c10"},{"code":"(fn pros [numbers]\n  (let\n    [pro (->> numbers (partition-by identity) (map #(vector (count %) (first %))) flatten)]\n    (cons pro (lazy-seq (pros pro)))))","problem":110,"user":"4f03641a535dcb61093f6a9b"},{"problem":110,"code":"(fn pronunc [ls]\n  (let [[v [n cnt]] (reduce (fn [[v [n cnt]] x]\n                          (if (= n x)\n                            [v [n (inc cnt)]]\n                            [(conj v cnt n) [x 1]]))\n                        [[] [(first ls) 1]]\n                        (rest ls))\n        new-ls (conj v cnt n)]\n    (lazy-seq (cons new-ls (pronunc new-ls)))))","user":"55f73078e4b06e875b46cea4"},{"problem":110,"code":"(fn pronunciation-seq [number-seq]\n  (letfn [(pronounce [seq]\n            (mapcat (juxt count first) (partition-by identity seq)))]\n    (rest (iterate pronounce number-seq))))","user":"58ed713de4b056aecfd47d84"},{"problem":110,"code":"(fn [x]\n\t(let [pronounce #(mapcat \n\t\t                 (fn [xs] [(count xs) (first xs)]) \n\t\t                 (partition-by identity %))]\n\t    (rest (iterate pronounce x))))","user":"5af8221ce4b0cc2b61a3bccd"},{"problem":110,"code":"(fn fin [seq]\n  (let [f (fn pron [vect]\n  (loop [d [] s vect c 1]\n    (if (empty? s) (into [] d)\n      (if (= (first s) (second s)) (recur d (rest s) (inc c))\n        (if (= (count s) 1) (recur (concat d [c (first s)]) (rest s) 1)\n        (recur (concat d [c (first s)]) (rest s) 1))))))]\n    (cons (f seq) (lazy-seq (fin (f seq))))))","user":"558378dce4b05c286339e115"},{"problem":110,"code":"(fn [s] (rest (iterate #(->> % (partition-by identity)\n(mapcat (juxt count first))) s)))","user":"5849ac5fe4b089d5ab817ed7"},{"problem":110,"code":"(fn pronounce [s]\n  (let [s-next (mapcat (fn [c] [(count c) (first c)]) (partition-by identity s))]\n    (cons s-next \n          (lazy-seq (pronounce s-next)))))","user":"54bd3aefe4b0ed20f4ff6edb"},{"problem":110,"code":"(fn pronunciations\n  [s]\n  (rest (iterate (fn [xs]\n                   (->> xs\n                        ;; LEFTOFF: Something is up here\n                        (reduce (fn [[acc [count n :as acc2]] x]\n                                  (cond (nil? acc2) [acc [1 x]]\n                                        (= n x) [acc [(inc count) n]]\n                                        :else [(conj acc count n) [1 x]]))\n                                [[] nil])\n                        (apply into)))\n                 s)))","user":"50427899e4b0add3005c0fc2"},{"code":"(fn f [s]\n  (lazy-seq\n    (let [p (mapcat #(list (count %) (last %))\n              (partition-by identity s))]\n      (cons p (f p)))))","problem":110,"user":"4f956072e4b0dcca54ed6ccf"},{"problem":110,"code":"(fn pronunciation\n  [v]\n  (let [p-fn (fn [v] (->> (partition-by identity v)\n                          (mapcat #(vector (count %) (first %)))))]\n    (rest (iterate p-fn v))))","user":"4e586949535d8a8b8723a292"},{"code":"(fn prob-0110\n  [xs]\n  (let [pronounce (fn pronounce\n          [xs]\n          (mapcat #(list (count %) (first %)) (partition-by identity xs)))]\n    \n  (rest (iterate pronounce xs))))","problem":110,"user":"4f047c07535dcb61093f6bcd"},{"code":"(fn [v]\n  (rest\n    (iterate\n      (fn [v2]\n        (mapcat\n          #(vector (count %) (first %))\n          (partition-by identity v2)))\n     v)))","problem":110,"user":"4f253a49e4b0d66497709ff3"},{"problem":110,"code":"(fn pronounce [xs]\n  (drop 1\n        (iterate #(->> %\n                       (partition-by identity)\n                       (mapcat (fn [x] [(count x) (first x)]))) xs)))","user":"569dd6e8e4b0542e1f8d1480"},{"problem":110,"code":"(fn seq-pronun [xs]         \n  (letfn [\n          (create-seq \n            ([xs] \n              (create-seq [] (first xs) 0 xs))\n            \n            ([acc y c xs]\n              (if (empty? xs)\n                (conj acc c y)\n                (let [x (first xs)]\n                  (if (= x y)\n                    (create-seq acc y (inc c) (rest xs))\n                    (create-seq (conj acc c y) x 1 (rest xs)))))))]\n    \n    (let [ys (create-seq xs)]                      \n      (lazy-seq (cons ys (seq-pronun ys))))))","user":"57d9bca1e4b0bd073c202405"},{"code":"(letfn\n  [(helper [s] (pron (rest s) (first s) 1 []))\n(pron [s current tally answ]\n  (cond (empty? s) (conj answ tally current)\n(= current (first s)) (recur (rest s) current (inc tally) answ)\n:else (recur (rest s) (first s) 1 (conj answ tally current))))]\n(fn [s] (iterate helper (helper s))))","problem":110,"user":"4fca2a13e4b0ee37620e184d"},{"problem":110,"code":"(fn foo [coll]\n  (let [x (->> coll\n               (partition-by identity)\n               (mapcat #(vector (count %) (first %))))]\n    (lazy-seq (cons x (foo x)))))","user":"5f3abcc4e4b004f08c61c52b"},{"problem":110,"code":"(fn [l]\n           (letfn [(pron [l]\n                     (let [v (reduce #(conj %1 (count %2) (first %2)) [] (partition-by identity l))]\n                       (lazy-seq (cons v (pron v)))))]\n             (pron l)))","user":"5f3f2281e4b004f08c61c561"},{"code":"(fn [s]\n  (letfn [(prons [s]\n    (lazy-seq\n      (let [pr (mapcat #(vector (count %) (first %)) (partition-by identity s))]\n        (cons pr (prons pr)))))]\n    (prons s)))","problem":110,"user":"4ebc08a8535dfed6da9c6d7c"},{"code":"(fn [l]\n  (next\n   (iterate\n    #(flatten\n      (for [n (partition-by identity %)]\n        [(count n) (first n)]))\n    l)))","problem":110,"user":"519136e9e4b0f8ef0be96c01"},{"code":"(fn f [x]\r\n  (rest (iterate (fn [x] (mapcat #(list (count %) (first %)) (partition-by identity x))) x)))","problem":110,"user":"4ef6e689535dced4c769f24f"},{"problem":110,"code":"(fn [coll] \n  (let [next #(flatten (map (fn [x] [(count x) (first x)]) (partition-by identity %)))]\n    (rest (iterate next coll))))","user":"55a74d46e4b09e57187da2a3"},{"problem":110,"code":"(fn [coll]\n  (letfn [(pronunciation [my-coll] \n                         (apply concat (map #(vector (count %) (first %)) \n                                      (partition-by identity my-coll)\n                                      )\n                                 )\n                         )]\n    (drop 1 (iterate pronunciation coll))\n    )\n  )","user":"55fe7e15e4b00f4cabc57651"},{"code":"(fn p [coll]\n    (let [r\n          (mapcat\n            (juxt count first)\n            (partition-by identity coll))]\n      (cons r\n            (lazy-seq (p r)))))","problem":110,"user":"4f463dfde4b0d56e7bb92b99"},{"code":"#(next (iterate % %2))\n#(mapcat (juxt count first) (partition-by + %))","problem":110,"user":"4e823ed7535db62dc21a62c7"},{"code":"(fn pronounceseq [x]\n           (drop 1 (iterate (fn f [y] \n                              (mapcat #(vector (count %) (first %)) (partition-by identity y)))\n                            x)))","problem":110,"user":"532727bae4b09d4e7a9b54fa"},{"problem":110,"code":"(fn [xs]\n    (rest\n     (iterate #(->> %\n                    (partition-by identity)\n                    (mapcat (juxt count first)))\n              xs)))","user":"5a257747e4b07f18be40aa1f"},{"problem":110,"code":"(fn [c0]\n  (next (iterate (fn [c]\n                      (mapcat (fn [x] (list (count x) (first x)))\n                              (partition-by identity c)))\n                 c0)))","user":"5596a324e4b04c1e5c31d757"},{"code":"(fn seq-prons [coll]\n  (letfn [(f [coll]\n    (apply concat\n      (map \n        #(vector (count %) (first %))\n        (partition-by identity coll))))]\n  (rest (iterate f coll))))","problem":110,"user":"501c1492e4b086d93747d180"},{"problem":110,"code":"(fn f [s] \n  (let [f-s  (fn f-s [[a :as s]]\n               (let [c (count (take-while (partial = a) s))\n                     r (drop-while (partial = a) s)]\n                  (cons c (cons a (if (empty? r) r (f-s r))))))\n        f-sq (fn f-sq [s] (lazy-seq (cons (f-s s) (f-sq (f-s s)))))]\n      (f-sq s)))","user":"575ddfd1e4b02ea11479938d"},{"code":"(fn [s]\n  (letfn [(grp [s] (reduce (fn [[v prv cnt] elt]\n  \t\t(if (= prv elt) [v prv (inc cnt)] [ (conj v [cnt prv]) elt 1]))\n\t\t      [[] (first s) 0] (conj s nil)))\n          (pronounce [s] (->> s (grp) (first) (apply concat) (vec)))]\n    (iterate pronounce (pronounce s))))","problem":110,"user":"4e6e3a1e535d5021c1a89602"},{"problem":110,"code":"(fn [s] (rest (iterate\n                  #(mapcat (fn [x] [(count x) (first x)]) (partition-by identity %)) s\n                  )))","user":"5921a080e4b09b4ee5954c77"},{"problem":110,"code":"(fn f [s]\n  (letfn [(say [s] (mapcat #(vector (count %) (first %)) (partition-by identity s)))]\n    (iterate say (say s))))","user":"5dd60c58e4b0948ae9d9ad7c"},{"code":"(fn [x]\r\n  (rest (iterate (fn p [s]\r\n             (if (empty? s) []\r\n               (let [c (#(loop [c % r 1] (if (= (first c) (fnext c)) (recur (rest c) (inc r)) r)) s)]\r\n                 (vec (concat [c (first s)] (p (drop c s)))))))\r\n           x)))","problem":110,"user":"4e821ca5535db62dc21a62c2"},{"code":"(fn pronunciations [s]\n  (letfn [(get-next-repeated [b] (take-while #(= % (first b)) b))\n          (pronounce [a]\n                     (loop [a a\n                            o []]\n                       (if (empty? a)\n                         o\n                         (recur (drop (count (get-next-repeated a)) a)\n                                (concat o (list (count (get-next-repeated a)) (first a)))))))]\n    (cons (pronounce s) (lazy-seq (pronunciations (pronounce s))))))","problem":110,"user":"51d360d1e4b099f3b6acddff"},{"problem":110,"code":"(fn\n  [s]\n  (letfn [(pro [seq]\n            (mapcat\n             (fn\n               [l]\n               [(count l) (first l)])\n             (partition-by identity seq)))]\n    (rest (iterate pro s))))","user":"5893c64ce4b00487982d524b"},{"code":"(fn p [c]\n  (let [d (mapcat\n            #(vector (count %) (first %))\n            (partition-by identity c))]\n    (cons d\n      (lazy-seq (p d)))))","problem":110,"user":"4fb2101ce4b081705acca284"},{"problem":110,"code":"(fn [coll]\n  (let [pron (fn pron [coll]\n    (let [xs (partition-by identity coll)]\n      (mapcat #(vector (count %) (first %) ) xs)))]\n        (rest(iterate pron coll))))","user":"5224a46ce4b01819a2de42e5"},{"code":"(fn [col]\n    (let [consecutive\n          (fn [col & [start counter previous]]\n            (let [;;start (first more)\n                  ;;counter (second more)\n                  ;;previous (nth more 2)\n                  cur (first col)\n                  res (if (nil? previous) [] previous)]\n              (cond\n               (empty? col) (concat res [counter start])\n               (nil? start) (recur (rest col) [cur 1 []])\n               (= cur start) (recur (rest col) [start (inc counter) previous])\n               :default (recur (rest col) [cur 1 (concat previous [counter start])]))))]\n      (rest (iterate consecutive col))))","problem":110,"user":"4e49a7bb535dc968683fc4c6"},{"problem":110,"code":"(letfn [(p [coll]\n          (->> coll\n               (partition-by identity)\n               (mapcat #(list (count %) (first %)))))]\n  #(drop 1 (iterate p %)))","user":"53720c5ce4b0493c815db704"},{"problem":110,"code":"(fn [s]\n  (let [pronounce (fn [s]\n                     (mapcat #(list (count %) (first %))\n                             (partition-by identity s)))]\n  (rest (iterate pronounce s))))","user":"5078d366e4b08327cd804a5b"},{"problem":110,"code":"(fn [coll]\n  (next \n    (iterate \n      #(mapcat \n         (fn [n] [(count n) (first n)])\n         (partition-by identity %))\n      coll)))","user":"5aa998c6e4b0d174b936c8e5"},{"problem":110,"code":"(fn [x]\n  (->> x\n    (iterate #(mapcat (juxt count first) (partition-by identity %)))\n    rest))","user":"5b0bd9cfe4b0cc2b61a3bdd9"},{"problem":110,"code":"(fn pronounce-numbers [xs]\n  (->> (iterate #(->> % (partition-by identity) (mapcat (juxt count first))) \n                xs)\n       (drop 1)))","user":"561d8936e4b064ca9f4b16b2"},{"problem":110,"code":"(fn [c]\n    (->\n      (fn [coll] (mapcat #(vector (count %) (first %))\n                         (partition-by identity coll)))\n      (iterate c)\n      rest))","user":"538ca203e4b0b51d73faae5f"},{"problem":110,"code":"(letfn [(pronounce [v]\n                  (->> v\n                       (partition-by identity)\n                       (mapcat (juxt count first))\n                       vec))]\n          (fn [v] (rest (iterate pronounce v))))","user":"4e0e0529535d04ed9115e7b9"},{"problem":110,"code":"(fn [xs]\n  (->> xs\n       (iterate\n        (fn [xs]\n          (->> (partition-by identity xs)\n               (mapcat (juxt count first)))))\n       rest))","user":"5dc88a38e4b02f9375f4e1db"},{"code":"(fn [s]\n  (next\n   (iterate\n    (fn [v] \n      (mapcat \n       #(vector (count %) (first %)) \n       (partition-by identity v)))\n    s)))","problem":110,"user":"52039e12e4b0fb7e47ea51ff"},{"problem":110,"code":"(fn [xs] (next (iterate #(mapcat (juxt count first) (partition-by identity %)) xs)))","user":"56b86e64e4b0f26550335924"},{"problem":110,"code":"(fn [x0]\n  (rest (iterate #(->> %\n       (partition-by identity)\n       (mapcat (juxt count first))\n       ) x0)))","user":"5fa416ece4b0f0ebd91b7803"},{"problem":110,"code":"(fn seq-pronunciations [x]\n  (lazy-seq\n   (let [next-coll (flatten (map #(vec [(count %) (first %)])\n                                 (partition-by identity x)))]\n     (cons next-coll (seq-pronunciations next-coll)))))","user":"4f2942ace4b0d6649770a01e"},{"code":"(fn pronounciations [initial-seq]\n  (let [next ((fn next-pronounciation [sq]\n                (let [grouped (partition-by identity sq)]\n                  (flatten\n                   (map (fn [group]\n                          [(count group) (first group)])\n                        grouped)))) initial-seq)]\n    (lazy-seq\n     (cons next\n           (pronounciations next)))))","problem":110,"user":"4e7e4a1f535db169f9c7970c"},{"problem":110,"code":"(fn [s]\n  (rest \n   (iterate\n    (fn [t] (mapcat #(vector (count %) (first %)) (partition-by identity t)))\n    s\n   ))\n  )","user":"55625903e4b0c656e3ff17d7"},{"code":"(fn pron [c]\n (let [cpron (mapcat #(vector (count %) (first %)) (partition-by identity c))]\n   (lazy-seq\n     (cons cpron (pron cpron)))))","problem":110,"user":"4e6a5f5c535d8ccf87e9fed6"},{"code":"(fn [v] (next (iterate #(flatten (for [x (partition-by identity %)] [(count x) (first x)])) v)))","problem":110,"user":"4e9c81e8535dbda64a6f6b80"},{"code":"(let [step (fn [xs] \n             (mapcat #(vector (count %) (first %)) \n                     (partition-by identity xs)))]\n  (fn f [xs] \n    (let [stepped (step xs)]\n     (lazy-seq (cons stepped (f stepped))))))","problem":110,"user":"5141abf1e4b02fd87f5064c3"},{"problem":110,"code":"#(rest \n  (iterate \n   (fn [v]\n     (mapcat (juxt count last)\n             (partition-by identity v)))\n   %))","user":"559c13c5e4b066d22e731f61"},{"code":"(letfn [(next-seq [s]\n                    (->> s\n                         (partition-by identity)\n                         (mapcat #((juxt count first) %))))]\n            (fn [s]\n              (rest (iterate next-seq s))))","problem":110,"user":"53224d45e4b09d4e7a9b54c0"},{"code":"(fn f [s]\n  \t\n\t(drop 1 (iterate (fn pronun [s & args]\n\t\t(let [ans (if (nil? args) [] (first args))]\n\t\t\t(cond (empty? s) ans\n\t\t\t\t:else (let [init (first s)]\n\t\t\t\t\t(let [part (take-while (fn [x]\n\t\t\t\t\t\t(= x init)\n\t\t\t\t\t) s) c (count part)] \n\t\t\t\t\t\t(pronun (drop c s) (concat ans [c init]))\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t)\n\t) s ))\n\n)","problem":110,"user":"4f7b6b90e4b06e829148e1a4"},{"code":"(fn pronunciations [n]\n        (let [p (flatten\n                 (map #(list (count %) (first %))\n                      (partition-by identity n)))]\n          (lazy-seq (cons p (pronunciations p)))))","problem":110,"user":"4f031eac535dcb61093f6a67"},{"code":"(fn ! [coll]\n  (cons (into [] ( (fn flatten [coll]\n   (reverse (loop [result [] s coll i 1]\n     (if (empty? s)\n       result\n       (recur\n        (if (= (first s) (second s))\n          result\n          (cons (first s) (cons i result))\n          )\n        (rest s)\n        (if (= (first s) (second s))\n          (inc i)\n          1\n          ))\n       )))\n   ) coll)) (lazy-seq (! ( (fn flatten [coll]\n   (reverse (loop [result [] s coll i 1]\n     (if (empty? s)\n       result\n       (recur\n        (if (= (first s) (second s))\n          result\n          (cons (first s) (cons i result))\n          )\n        (rest s)\n        (if (= (first s) (second s))\n          (inc i)\n          1\n          ))\n       )))\n   ) coll))))\n  )","problem":110,"user":"4ea31da2535d7eef308072c1"},{"code":"(letfn [(pronounce [nums]\r\n          (loop [nums nums\r\n                 ret []]\r\n              (if (empty? nums)\r\n                  ret\r\n                  (let [[said new-nums] (split-with #(= (first nums) %) nums)]\r\n                      (recur new-nums\r\n                             (-> ret (conj (count said)) (conj (first nums))))))))]\r\n  (fn sop [nums]\r\n    (drop 1 (iterate pronounce nums))))","problem":110,"user":"4fcc6cb3e4b0ee37620e1861"},{"code":"(comp next \r\n  (partial iterate\r\n    (comp (partial mapcat (juxt count first))\r\n          (partial partition-by identity))))","problem":110,"user":"50336c6be4b0c6c1199c710f"},{"problem":110,"code":"(fn f [num-coll]\n  (let [pronounce (fn [coll]\n                    (reduce #(conj %1 (count %2) (first %2)) [] (partition-by identity coll))),\n        next-iter (pronounce num-coll)]\n    (lazy-seq (cons next-iter (f next-iter)))))","user":"567695c2e4b05957ce8c6157"},{"problem":110,"code":"(fn pronunciations [coll] \n  (lazy-seq\n   (let [new-coll (mapcat #(vec [(count %) (first %)]) (partition-by identity coll))]\n     (cons new-coll (pronunciations new-coll)))))","user":"4f88ae35e4b033992c121c6d"},{"problem":110,"code":"(fn number110 [xs]\n  (let [parts (partition-by identity xs)\n        pronunciation (mapcat #(vector (count %) (first %)) parts)]\n    (lazy-cat [pronunciation] (number110 pronunciation))))","user":"54074fc5e4b0addc1aec66b6"},{"code":"(fn pronounce [coll]\n  (lazy-seq\n   (let [p (partition-by identity coll)\n         pro (mapcat (juxt count first) p)]\n     (cons pro (pronounce pro)))))","problem":110,"user":"4e89ff3d535d3e98b802328a"},{"code":"(fn pronounce \n  [xxs] \n     (let [v (flatten (map #(vector (count %) (first %)) (partition-by identity xxs)))]\n     (cons v (lazy-seq (pronounce v))))\n     )","problem":110,"user":"536aa86de4b0243289761eb1"},{"problem":110,"code":"#(next (iterate (fn [c] (mapcat (juxt count first) (partition-by + c))) %))","user":"55be39f9e4b01b9910ae2a06"},{"code":"(fn* pron [x]\n  (let [p (mapcat #(vector (count %) (first %)) (partition-by identity x))]\n    (cons p (lazy-seq (pron p)))))","problem":110,"user":"53468f6ce4b084c2834f4a3f"},{"code":"(fn pron [s]\n  (let [nxt (mapcat (juxt count first) (partition-by identity s))]\n    (lazy-seq (cons nxt (pron nxt)))))","problem":110,"user":"4ffc10aae4b0678c553fc3d6"},{"problem":110,"code":"(fn [coll1]\n\n(let [lazy-it (fn [coll]\n(nth (reduce (fn [acc val] \n(if (not= (first val) (second val)) \n[1 (second val) ( concat (nth acc 2) [(first acc) (second acc)])]\n[ (inc (first acc)) (second val) (nth acc 2)])\n\n)\n[1 (first coll) []]\n(map #( -> [%1 %2]) coll (concat (rest coll) [nil]))) 2))\n\n\n\n__ (fn __ [init-coll]\n\n(let [ first (lazy-it init-coll)] \n\n(lazy-seq (cons first (__ first))))\n)]\n  \n  (__ coll1)))","user":"53c73e8ae4b00fb29b2212a5"},{"problem":110,"code":"(fn f\n  [s]\n  (let [x (flatten (map #(vector (count %) (first %)) (partition-by identity s)))]\n  (lazy-seq (cons x (f x)))))","user":"56ab7578e4b03c432f18733d"},{"code":"(fn se [coll]\n  (let [res (reduce into (map #(vector (count %) (first %)) (partition-by identity coll))\n                    )]\n    (cons res (lazy-seq (se res)))\n    ))","problem":110,"user":"51da7e49e4b02ceefd947768"},{"problem":110,"code":"(fn sop [xs] (let [x (->> xs\n                      (partition-by identity)\n                      (mapcat #(vector (count %) (first %))))] \n           (cons x (lazy-seq (sop x)))))","user":"6011b89ee4b074f607df66bc"},{"problem":110,"code":"(fn pi\n  [s]\n  (rest (iterate (fn p [s]\n                   (if (empty? s)\n                     []\n                     (let [h     (first s)\n                           [a r] (split-with #(= % h) s)]\n                       (concat [(count a) h] (p r))))) s)))","user":"583048d9e4b051871117c007"},{"problem":110,"code":"(fn pron [bloc]\n  (let [tsugi (->> bloc\n                   (partition-by identity)\n                   (mapcat (fn [grp] [(count grp) (first grp)])))]\n    (cons tsugi (lazy-seq (pron tsugi)))))","user":"541d3c0fe4b01498b1a71a7e"},{"code":"(fn [xs]\n  (drop 1\n    (iterate\n      (fn [coll]\n        (mapcat #(vector (count %) (first %))\n          (partition-by identity coll)))\n      xs)))","problem":110,"user":"4fb12b35e4b081705acca275"},{"code":"(fn __ [nums]\n  (letfn [(pronounce [n]\n        \t(mapcat \n    \t\t\t#(vector (count %) (first %))\n        \t\t(partition-by identity n)))]\n  (iterate pronounce (pronounce nums))))","problem":110,"user":"4fa719c0e4b081705acca1bf"},{"code":"(let [pronounce (fn [v]\n (->> v\n  (partition-by identity)\n  (mapcat #(vector (count %) (first %)))) )]\n #(rest (iterate pronounce %)))","problem":110,"user":"510db6cde4b078ea71921145"},{"problem":110,"code":"(fn fun [col]\n  (let [x (reduce\n            #(conj % (count %2) (first %2))\n            []\n            (partition-by identity col)\n          )\n        ]\n    (cons\n      x\n      (lazy-seq (fun x))\n    )\n  )\n)","user":"5da20e73e4b000c986472be1"},{"code":"(letfn [(int2base\n           [n base]\n           (if (< n base)\n             (vector n)\n             (conj (int2base (quot n base) base) (rem n base))))\n         (v2int [v]\n           (reduce #(+ (* %1 10N) %2)  0 v))\n         (pronounce [n]\n           (reduce\n            #(conj %1 (count %2) (first %2))\n            [] (partition-by identity (int2base n 10))))]\n   (fn l-pronounce [n]\n     (lazy-seq (concat (conj [] (pronounce (v2int n))) (l-pronounce (pronounce (v2int n)))))))","problem":110,"user":"50733b31e4b0e3170b5a869a"},{"code":"(fn pronounce [s]\n  (rest (iterate\n    (fn [s']\n      (reduce\n        (fn [[c m & tail :as s''] n]\n          (if\n            (= m n)\n            (conj tail m (inc c))\n            (conj s'' n 1)))\n        (list 0 (last s'))\n        (reverse s')))\n    s)))","problem":110,"user":"5201ada5e4b0b2e020a18f14"},{"code":"#(rest (iterate (fn [v] (mapcat (fn [c] [(count c) (first c)])\r\n (partition-by (partial + 0) v))) %))","problem":110,"user":"4fca2ef0e4b0ee37620e184e"},{"problem":110,"code":"(fn pp [s]\n   (let [s (mapcat (juxt count first) (partition-by identity s))]\n     (cons s (lazy-seq (pp s)))))","user":"538db083e4b0b51d73faae74"},{"code":"(fn [s]\n  (next (iterate #(mapcat (juxt count first)\n                          (partition-by + %)) s)))","problem":110,"user":"4e6a412e535d8ccf87e9feb6"},{"problem":110,"code":"(fn pronunciations [seq]\n  (let [pr (fn [sq]\n             (vec (mapcat (fn [e] [(count e) (first e)]) (partition-by identity sq))))]\n    (iterate pr (pr seq))))","user":"5471f2fbe4b094393f72dd70"},{"code":"(fn pro-seq [start]\r\n  (letfn [(pronounce [vn]\r\n            (let [z (partition-by identity vn)]\r\n              (interleave (map count z) (map first z))))]\r\n    (iterate pronounce (pronounce start))))","problem":110,"user":"500d1db4e4b05f7c30cfa69f"},{"problem":110,"code":"(comp rest \n      (partial \n       iterate \n       #(mapcat \n         (juxt count first) \n         (partition-by identity %))))","user":"57f0f7b8e4b0bfb2137f5bfe"},{"problem":110,"code":"(fn pronounce [s]\n  (drop 1\n        (iterate\n         (comp #(into [] %) reverse (fn step [l]\n           (if (empty? l)\n             []\n             (conj (step (drop-while #(= % (first l)) l)) (first l) (count (take-while #(= % (first l)) l)) ))))\n         s)))","user":"56588f4ee4b0f9d632dd84b6"},{"code":"(fn [xs]\n  (let [f (fn [ys]\n            (flatten\n              (map #(vector (count %) (first %))\n                (partition-by identity ys))))]\n    (drop 1 (iterate f xs))))","problem":110,"user":"52a88c4de4b0c58976d9ac30"},{"problem":110,"code":"(fn calc [col] \n  (lazy-seq\n    (let [res (mapcat #(list (count %) (first %)) (partition-by identity col))]  \n      (cons res (calc res)))))","user":"563cce5be4b0bfe05bf1183f"},{"code":"(fn pron-seq2 [xs]\n  (letfn [(cnt-rep [x xs]\n            (cond (empty? xs) 0\n                  (not= x (first xs)) 0\n                  true (+ 1 (cnt-rep x (rest xs)))))\n          (pron [xs]\n            (let [n (cnt-rep (first xs) xs)]\n              (cond (empty? xs) '()\n                    true (conj (pron (drop n xs)) (first xs) n))))]\n    (lazy-seq\n     (cons (pron xs) (pron-seq2 (pron xs))))))","problem":110,"user":"4ef6f5ea535dced4c769f250"},{"code":"(fn pron [x]\n  \"4clojure.com/problem/110\"\n  (let [pron-1  (fn [coll] (mapcat #(vector  (count %) (first %)) (partition-by identity coll)))\n   init-val (pron-1 x)]\n  (iterate pron-1 init-val)))","problem":110,"user":"4db58ccb535d87e67b28fe10"},{"code":"(fn pron [coll]\n  (let [curr (flatten (mapcat #(list (count %) (first %)) (partition-by identity coll)))]\n  \t(cons curr(lazy-seq (pron curr)))))","problem":110,"user":"5273e006e4b03e8d9a4a7495"},{"code":"(fn pro [sequence] \n  (letfn \n    [(group [acc n]\n      (if (= (ffirst acc) n)\n          (cons [n (inc (second (first acc)))] (rest acc))\n          (cons [n 1] acc)))\n     (pronounciation [s] (reverse (flatten (reduce group '() s))))]\n    (cons\n      (pronounciation sequence)\n      (lazy-seq (pro (pronounciation sequence))))))","problem":110,"user":"521e8227e4b0dd19981ad082"},{"code":"(fn pronunc\n  [nums]\n  (let [pron (apply concat (map (juxt count first) (partition-by identity nums)))]\n    (cons pron (lazy-seq (pronunc pron)))))","problem":110,"user":"511b233ae4b07ab9ec456180"},{"problem":110,"code":"(fn [s]\n  (->> s\n    (iterate\n      #(->> %\n        (partition-by identity)\n        (map (fn [c] [(count c) (first c)]))\n        (apply concat)))\n    rest))","user":"50d882d4e4b01f0871336e69"},{"code":"(fn ff [coll]\n  (let [e (flatten (map #(list (count %) (first %))\n                 (reverse\n                  (reduce #(if (= (first (first %1)) %2)\n                             (conj (rest %1) (conj (first %1) %2))\n                             (conj %1 (list %2)))\n                          () coll))))]\n     (cons e (lazy-seq (ff e)))))","problem":110,"user":"5341b141e4b00652c8746ecf"},{"code":"(fn seqp [vals]\n  (letfn [(nextp [vals]\n            (when (seq vals)\n       \t       (let [firstval (first vals)\n             \t     countfirst (count (take-while #(= firstval %) vals))]\n         \t (concat [countfirst firstval] (nextp (drop countfirst vals))))))]\n     (drop 1 (iterate nextp vals))))","problem":110,"user":"4f0d093b535d0136e6c22313"},{"code":"(fn [init]\n  (letfn [(next-seq [xs] (mapcat #(vector (count %) (first %)) (partition-by identity xs)))]\n    (rest (iterate next-seq init))))","problem":110,"user":"51d19c24e4b0cfcf579466c3"},{"code":"(fn [s]\n  (let [p (fn [s] (->> (partition-by identity s)\n                       (mapcat (juxt count first))))]\n    (iterate p (p s))))","problem":110,"user":"524b0645e4b09eba1c0223bf"},{"problem":110,"code":"(fn r [coll] \n    (let [res (flatten (map #(vector (count %) (first %)) (partition-by identity coll)))]\n      (cons res (lazy-seq (r res)))))","user":"55f2c898e4b06e875b46ce4b"},{"problem":110,"code":"(fn [xs] (let [f  #(flatten (map (fn [v] [ (count v) (first v)]) (partition-by identity %)))] (iterate f (f xs))))","user":"545801f6e4b01be26fd74615"},{"code":"(fn pron [x_]\n    (let [p ((fn topr [[a & rest :as x]]\n               (if (empty? x)\n                 '()\n                 (let [n (count (take-while #(= % a) x))]\n                   (concat [n a] (topr (drop n x))))))\n             x_)]\n      (cons p (lazy-seq (pron p)))))","problem":110,"user":"52586d24e4b0cb4875a45cb0"},{"code":"(fn pron [v]\n  (let [v' (mapcat #(list (count %) (first %)) (partition-by identity v))]\n    (cons v' (lazy-seq (pron v')))))","problem":110,"user":"50e87427e4b0ebbe794eb7e8"},{"code":"(fn [coll]\n  (let [count-consec (fn count-consec [[fst :as s]]\n    (when-not (empty? s) (let [[fs xs] (split-with (partial = fst) s)]\n      (concat [(count fs) fst] (count-consec xs)))))]\n\n  (iterate count-consec (count-consec coll))))","problem":110,"user":"4effb663535dcb61093f6a2e"},{"problem":110,"code":"(fn p [c]\n  (let [n (->> c (partition-by identity) (map #(vector (count %) (first %))) (apply concat))]\n    (cons n (lazy-seq (p n)))))","user":"5953bdb6e4b066ee0a44aeed"},{"problem":110,"code":"(fn desc-count [v]\n  (let [rv (flatten (map #(list (count %) (first %)) (partition-by identity v)))]\n    (cons rv (lazy-seq (desc-count rv)))))","user":"55934bebe4b0c79f6e1db93b"},{"code":"(fn [initial]\n  (let [pronounce \n        #(mapcat (fn [[x & _ :as xss]] [(count xss) x]) \n           (partition-by identity %))]\n    (iterate pronounce (pronounce initial))))","problem":110,"user":"51cdd3f0e4b0e42293a2254b"},{"problem":110,"code":"(fn [a] (drop 1 (iterate (fn [s] (->> s (partition-by identity) (map #(list (count %) (first %))) flatten)) a)\n))","user":"59a0262ee4b0871e7608b82d"},{"problem":110,"code":"(fn[coll] (rest (iterate #(->> %\n                   (partition-by identity)\n                   (map (fn[v][(count v)(first v)]))\n                   (flatten)\n                   (vec)) coll)))","user":"50e90813e4b033b0e80d11e7"},{"problem":110,"code":"(fn pronounce [coll]\n  (let [p-coll (reduce #(conj %1 (count %2) (first %2))\n                       []\n                       (partition-by identity coll))]\n    (lazy-seq (cons p-coll (pronounce p-coll)))))","user":"540a4f20e4b0addc1aec66ef"},{"problem":110,"code":"(fn pronunciation-sequence\n  [coll] {:pre [(every? integer? coll), (every? pos? coll)]}\n  (let [pronounce\n        (fn [input]\n          (->> input\n               (partition-by identity)\n               (mapcat (juxt count first))))]\n    (rest (iterate pronounce coll))))","user":"4fc6305de4b0ee37620e180b"},{"problem":110,"code":"(fn pronounce[s]\n  (letfn [(gen-next[s]\n            (->> s\n             (partition-by identity)\n             (mapcat (juxt count first))))]\n    (when (seq s)\n      (lazy-seq (let [n (gen-next s)] (cons n (pronounce n)))))))","user":"4fd4bddce4b0d4de60cee36e"},{"code":"(fn [v]\n  (drop 1 (iterate \n            (fn [vv]\n              (reduce (fn [m i]\n                        (concat m [(count i) (first i)])\n                        ) [] (partition-by (fn [x] x) vv))\n              ) \n            v\n            )\n    ))","problem":110,"user":"51bec919e4b013aa0d74b800"},{"code":"(fn pro [v] (lazy-seq (let [o (mapcat #(vector (count %) (first %)) (partition-by identity v))] (cons o (pro o)))))","problem":110,"user":"4fd81472e4b0dab7d829f38e"},{"problem":110,"code":"(fn [coll]\n  (let [pro-one (fn [coll]\n                  (->> (partition-by identity coll)\n                       (map frequencies)\n                       (map (comp  reverse first))\n                       (flatten)))]\n    (drop 1 (iterate pro-one coll))))","user":"54848141e4b0e286459a119e"},{"code":"(fn [coll]\n  (rest (iterate \n     (fn nm[c2]\n       (if (empty? c2) '()\n         (let [h (first c2) rng (take-while #(= % h) c2)]\n           (lazy-cat [(count rng) h]\n                     (nm (drop-while #(= h %) c2)))\n         ))\n       ) coll)))","problem":110,"user":"4f38d6bbe4b0e243712b1ee2"},{"problem":110,"code":"(fn [nums]\n  (letfn [(next-pronunciation [n]\n            (let [nums (seq n)]\n              (if (= 1 (count nums))\n                [1 (first nums)]\n                (->> (reduce\n                       (fn [[acc count prev] next]\n                         (if (= prev next)\n                           [acc (inc count) prev]\n                           [(conj acc count prev) 1 next]))\n                       [[] 1 (first nums)]\n                       (next nums))\n                     (flatten)\n                     (vec)))))]\n    (drop 1 (iterate next-pronunciation nums))))","user":"55d28b38e4b0e31453f64a58"},{"problem":110,"code":"(fn [ns] (rest \n  (iterate \n    (fn [ns'] (mapcat (fn[x] (list (count x) (first x))) \n      (partition-by identity ns'))) ns)))","user":"58e7229fe4b056aecfd47cc4"},{"problem":110,"code":"(fn p [s]\n  (letfn [(f [s]\n            (loop [[x & xs] s r []]\n              (if (nil? x)\n                r\n                (let [c (count (take-while #(= x %) xs))]\n                  (recur (drop c xs) (into r [(inc c) x]))))))]\n    (lazy-seq\n     (let [s (f s)]\n       (cons s (p s))))))","user":"55ac07afe4b03311e7b7328f"},{"problem":110,"code":"(fn ! [v]\n  (let [b (partition-by identity v)\n        x (interleave (map count b) (map first b))]\n   (cons x (lazy-seq (! x)))\n   ))","user":"52faec2ee4b047fd55837004"},{"problem":110,"code":"#(rest\n  (iterate (fn [c]\n             (mapcat (juxt count first)\n                     (partition-by identity c)))\n           %))","user":"508923d5e4b06d8254e936e8"},{"code":"#(let [f (fn[s]\n           (loop [v (first s) s (rest s)  c 1 r []]\n             (if (empty? s) (conj r c v)\n               (if (= (first s) v)\n                 (recur  v (rest s) (inc c) r)\n                 (recur (first s) (rest s) 1 (conj r c v))))))]\n  (iterate f (f %)))","problem":110,"user":"4deff9f9535d08e6dec9fe15"},{"problem":110,"code":"(fn sequence-of-pronunciations [s]\n  (let [how-many-repetitions ;how many times does the first element of xs repeat?\n        (fn how-many-repetitions\n          ([xs] (how-many-repetitions xs (first xs) 0))\n          ([xs value so-far] ;value is the value we're looking for repetitions of\n           (if (empty? xs) so-far\n             (if (= (first xs) value) (how-many-repetitions (rest xs) value (inc so-far))\n               so-far\n              ))))\n        \n        pronounce (fn pronounce [xs]\n                    (if (empty? xs) (list)\n                      (let [repetitions (how-many-repetitions xs)]\n                        (concat (list repetitions (first xs)) (pronounce (drop repetitions xs))))))\n        ]\n    \n    (let [pronunciation (pronounce s)]\n      (cons pronunciation (lazy-seq (sequence-of-pronunciations pronunciation))))\n  )\n)","user":"56393681e4b0bfe05bf117f2"},{"problem":110,"code":"(fn [input]\n  (letfn [(calc-prons [coll]\n                      (reduce (fn [coll x] (if (= (first coll) x) \n                                              (conj (rest (rest coll))\n                                                    (inc (second coll))\n                                                    x)\n                                              (conj coll 1 x)))\n                              '()\n                              coll))\n          (seq-of-prons [coll] (let [prons (reverse (calc-prons coll))]\n                                 (lazy-seq\n                                  (cons prons (seq-of-prons prons)))))]\n    (seq-of-prons input)))","user":"585e2e77e4b0f14aab7c87ac"},{"problem":110,"code":"(fn sequence-pronunciations\n  [s]\n  (let [id (reduce #(into %1 [(count %2) (first %2)]) [] (partition-by identity s))]\n    (lazy-seq (cons id (sequence-pronunciations id))))\n    )","user":"5c20b6abe4b07e362c230576"},{"problem":110,"code":"(let [pronun (fn pronun [coll]\n               (let [d (first coll)\n                     n (count (take-while #(= d %) coll))]\n                 (if (empty? coll) []\n                   (concat [n d] (pronun (drop n coll))))))]\n  #(drop 1 (iterate pronun %)))","user":"5412ef7ee4b01498b1a719da"},{"problem":110,"code":"(fn [s]\n    (->> s\n         (iterate #(->> (partition-by identity %)\n                        (mapcat (juxt count first))))\n         (drop 1)))","user":"5a5d0726e4b0512ff01cd91b"},{"problem":110,"code":"(fn f [c] (lazy-seq (let [nc (apply concat (map #(vector (count %) (first %)) (partition-by #(if true %) c)))] (cons nc (f nc)))))","user":"5481be5fe4b0e286459a1172"},{"problem":110,"code":"(fn [coll]\n    (->> coll\n         (iterate #(->> (partition-by identity %)\n                        (mapcat (fn [xs] [(count xs) (first xs)]))))\n         (drop 1)))","user":"5c165d3ee4b01240ff5671d1"},{"code":"(fn pro [xs]\n  (let [p (partition-by identity xs)\n        c (map count p)\n        r (flatten (interleave c (map first p)))]\n    (cons r (lazy-seq (pro r)))))","problem":110,"user":"4e3a9dae535deb9a81d77f4a"},{"code":"(fn [coll]\n  (rest (iterate #(mapcat (juxt count first) (partition-by identity %)) coll)))","problem":110,"user":"507056b8e4b07bd6ad9b9f29"},{"code":"#(iterate % (% %2))\n  #(mapcat (juxt count first) (partition-by + %))","problem":110,"user":"4dad8fe9c9a9d6ed1899dc57"},{"problem":110,"code":"(fn [xs]\n  (letfn [(pro [xs]\n            (->> xs\n                 (partition-by identity)\n                 (map (juxt count first))\n                 (apply concat)))]\n    (iterate pro (pro xs))))","user":"5afb4b15e4b0cc2b61a3bcf6"},{"problem":110,"code":"(fn pronounciations [s] (letfn [(pronounce [s1] (mapcat #(vector (count %) (first %)) (partition-by identity s1)))]\n                          (let [current (pronounce s)]\n                            (lazy-seq (cons current (pronounciations current))))))","user":"56baab13e4b0f26550335948"},{"code":"(fn pron[l]\n  (let [next-col \n        (mapcat \n         #(vec [(count %) (first %)]) \n        (partition-by identity l))]\n    (lazy-seq\n     (cons next-col (pron next-col)))))","problem":110,"user":"50d3b03fe4b030b634c368b9"},{"code":"(fn [nums]\n  (drop 1\n    (iterate #(mapcat (juxt count first)\n                      (partition-by identity %))\n             nums)))","problem":110,"user":"4e2b1d48535deb9a81d77f03"},{"code":"(fn seqp [s]\n  (let [n (mapcat #(vector (count %) (first %)) (partition-by identity s))]\n  (lazy-seq\n    (cons n (seqp n)))))","problem":110,"user":"4eb0a757535d7eef3080733d"},{"problem":110,"code":"(fn [x] \n  (rest (iterate #(mapcat (juxt count first) (partition-by identity %)) x)))","user":"4e6a4950535d8ccf87e9febf"},{"problem":110,"code":"(fn pronounciations [numbers]\n    (letfn [(pronounciation [numbers]\n              (->> numbers\n                (partition-by identity)\n                (mapcat (juxt count first))))]\n      (let [pronounced (pronounciation numbers)]\n        (cons pronounced (lazy-seq (pronounciations pronounced))))))","user":"561814bae4b06b1bb2182a1a"},{"code":"(fn [xs]\r\n  (rest\r\n    (iterate\r\n      (fn [xs] (mapcat (juxt count first) (partition-by identity xs)))\r\n         xs)))","problem":110,"user":"509c03f3e4b085ae113522a8"},{"problem":110,"code":"#(drop 1 (iterate \n  (fn [a-seq]\n   (flatten\n   (reduce (fn [a b]\n               (if (= b (second (last a)))\n                (conj (vec (butlast a)) [(inc (first (last a))) b])\n                (conj a [1 b])))\n           [] a-seq))) %))","user":"544e9022e4b0e3978000698b"},{"code":"#(drop 1\n         (iterate\n          (fn [vec]\n            (mapcat (juxt count first)\n                    (partition-by identity vec)))\n          %))","problem":110,"user":"51f9527fe4b09be9c177e549"},{"problem":110,"code":"(fn [s]\n  (drop 1 (iterate #(reduce (fn [res repeats]\n                              (conj res (count repeats) (first repeats)))\n                            []\n                            (partition-by identity %)) s)))","user":"55ccdc6be4b0e31453f64a18"},{"problem":110,"code":"(fn f [s]\n          (let [i (->> (partition-by identity s)\n                       (reduce #(concat %1 [(count %2) (first %2)]) []))]\n            (cons i (lazy-seq (f i)))))","user":"53f592b7e4b0db01ade6f9d0"},{"problem":110,"code":"(fn seq-pron [coll]\n  (letfn [(pron [xs]\n            (mapcat #(vector (count %) (first %))\n                    (partition-by identity xs)))]\n    (cons (pron coll) (lazy-seq (seq-pron (pron coll))))))","user":"540e8d13e4b0addc1aec671e"},{"problem":110,"code":"(fn me [e]\n\n  (let [my (fn [e]\n\n            (let [ res1 (partition-by identity e)\n\n              res2 (map #(vector (count %) (first %)) res1)\n              ]\n            \n                (flatten res2)\n              ) \n            )\n      ]\n\n     (cons (my e) (lazy-seq (me (my e))))\n    )\n)","user":"55897fe2e4b059ccff29b205"},{"problem":110,"code":"(fn rpron [x]\n  (letfn [(pron [v] (flatten (map (fn [i] [(count i) (first i)]) (partition-by identity v))))]\n    (let [x1 (pron x)]\n      (cons x1 (lazy-seq (rpron x1)))\n)))","user":"54524afbe4b0e397800069bc"},{"problem":110,"code":"(fn pro\n  ([x]\n   (lazy-seq\n    (cons \n      (mapcat #(-> [(count %) (first %)]) (partition-by identity x))\n     (pro (mapcat #(-> [(count %) (first %)]) (partition-by identity x)))))))","user":"5a6a7cc5e4b0512ff01cda27"},{"code":"(fn pronun [seq]\n           (letfn [(grouped [seq]\n                     (let [pseq (partition-by identity seq)]\n                       (apply concat\n                              (map (fn [s] [(count s) (first s)]) pseq))))]\n             (rest (iterate grouped seq))))","problem":110,"user":"529ce629e4b04e0c58e87b6e"},{"problem":110,"code":"(fn [x] (drop 1 (iterate (fn [x] (mapcat (juxt count first) (partition-by identity x))) x)))","user":"58a822e4e4b01a0c0b232950"},{"code":"(fn go [ns]\n  (rest (iterate\n    (fn pronounce [ns]\n      (vec (nnext\n        (flatten\n          (reduce\n            (fn [[acc count cur] n]\n              (if (= n cur)\n                [acc (inc count) cur]\n                [(conj acc count cur) 1 n]))\n            [[] 0 nil]\n            ns)))))\n    ns)))","problem":110,"user":"4dafa380edd6309eace4d17c"},{"code":"(fn seq-of-pronun [xs]\n  (loop [items xs, occurrences []]\n    (if (empty? items) \n      (lazy-cat [occurrences] (seq-of-pronun occurrences)) \n      (let [[same different] (split-with #(= % (first items)) items)]\n        (recur different (concat occurrences [(count same) (first same)]))))))","problem":110,"user":"4f2e0369e4b0d6649770a064"},{"problem":110,"code":"(fn s [i]\n  (let [c (mapcat (juxt count first) (partition-by + i))]\n    (lazy-seq (cons c (s c)))))","user":"5c1c08cde4b01240ff567219"},{"problem":110,"code":"(letfn [(next [v]\n\t (loop [r (seq v), a [], n nil, c 1]\n\t  (cond (empty? r) (conj a c n)\n\t\t(nil? n) (recur (rest r) a (first r) 1)\n\t\t(= n (first r)) (recur (rest r) a n (inc c))\n\t\t:else (recur (rest r) (conj a c n) (first r) 1))))]\n (fn [v]\n  (iterate next (next v))))","user":"538e36c7e4b0b51d73faae81"},{"problem":110,"code":"(fn pronounce [s] {:pre (sequential? s)}\n    (let\n        [\n            helper\n                (fn [s] (->> s\n                    (partition-by identity)\n                    (#(interleave (map count %) (map first %)))\n                ))\n        ]\n        (rest (iterate helper s))\n    )\n)","user":"5db7376fe4b010eb3c36cd43"},{"code":"(fn pr[s] \n  (let [r (flatten (for [ss (partition-by identity s)] [(count ss) (first ss)]))]\n    (cons r (lazy-seq (pr r)))))","problem":110,"user":"5093ca51e4b097f48cc38585"},{"code":"(fn one-ten\n  [coll]\n  (rest (iterate\n    (fn [v]\n      (flatten\n       (map\n        (fn [k] [(count k) (first k)])\n        (partition-by identity v)))) coll)))","problem":110,"user":"510591dde4b06d28cacc92eb"},{"problem":110,"code":"(fn pronun [coll]\n  (let [get-next (fn [coll]\n                   (reduce #(if (= (last %1) %2)\n                              (conj (pop (pop %1)) (inc (get %1 (- (count %1) 2))) %2)\n                              (conj %1 1 %2)) [] coll))]\n    (cons (get-next coll) (lazy-seq (pronun (get-next coll))))))","user":"5dd67c22e4b0948ae9d9ad80"},{"code":"#(rest (iterate (fn [s] (mapcat (juxt count first) (partition-by identity s))) %))","problem":110,"user":"4ef77edb535dced4c769f254"},{"problem":110,"code":"(fn [coll] (rest (iterate (fn [coll] (->> coll\n                                           (partition-by identity)\n                                           (mapcat #(list (count %) (first %))))) coll)))","user":"54db3d82e4b024c67c0cf75f"},{"problem":110,"code":"(fn [s]\n  (drop 1\n    (iterate \n      (fn [s]\n        (->> (partition-by identity s)\n             (map #(list (count %) (first %)))\n             (flatten)))\n      s)))","user":"5af907e6e4b0cc2b61a3bcda"},{"code":"(fn pro [s]\n  (next\n   (iterate #(mapcat (juxt count first) (partition-by identity %)) s)))","problem":110,"user":"51805d22e4b0e3fc13e244df"},{"code":"(comp rest \n      (partial iterate \n               (comp (partial mapcat (juxt count first)) \n                     (partial partition-by identity))))","problem":110,"user":"4e9660ec535dbda64a6f6b44"},{"code":"(fn [s] (drop 1 (iterate #(mapcat (fn [s] [(count s) (first s)]) (partition-by + %)) s)))","problem":110,"user":"4fdec88fe4b05e33b9224f8e"},{"problem":110,"code":"(fn prons [x]\n  (let [p (mapcat #(vector (count %) (first %)) (partition-by identity x))]\n    (lazy-seq\n     (cons p (prons p)))))","user":"553e0b70e4b0a04f792994e8"},{"code":"(fn seq-pro\n  [coll]\n  (let [i-step (fn [c]\n                            (vec (mapcat #(cons (count %) (list (first %)))\n                                         (partition-by identity c))))]\n    (iterate i-step (i-step coll))))","problem":110,"user":"4e3bcccd535deb9a81d77f56"},{"code":"(fn [l] \r\n    (letfn [(f [xs]\r\n              (mapcat #(do [(count %) (nth % 0)]) (partition-by #(do %) xs)))]\r\n      (iterate f (f l))))","problem":110,"user":"4f58d92fe4b0a7574ea71858"},{"code":"#(rest \n  (iterate (fn [s]\n             (mapcat (juxt count first)\n                     (partition-by + s))) \n           %))","problem":110,"user":"4e12cc9d535d04ed9115e7d2"},{"problem":110,"code":"(fn [l] \n   (letfn \n     [(pronun [l]   \n              (->> (partition-by identity l)\n                   (map #(vector (count %) (first %)))\n                   (flatten)))]\n     (iterate pronun (pronun l))))","user":"5fab7ea6e4b08cb800c85ad8"},{"code":"(fn pronseq [s]\n  (letfn [(pron [s] \n    (if (empty? s) []\n       (concat [(count (take-while #(= % (first s)) s)) (first s)]\n           (pron (drop-while #(= % (first s)) s))))\n   )]\n    (lazy-seq (cons (pron s) (pronseq (pron s))))))","problem":110,"user":"4f62b29ce4b0defedf855fd9"},{"problem":110,"code":"(fn pronounciations [x]\n  (rest (iterate (fn [y] \n             (mapcat (fn [z] [(count z) (first z)])\n                     (partition-by identity y))) \n           x)))","user":"604d3cb1e4b0b7ec0ac60ac2"},{"problem":110,"code":"(comp rest iterate)#(mapcat(juxt count last)(partition-by + %))","user":"50ed4626e4b01236b1d4983c"},{"code":"(fn pron [input]\n  (lazy-seq\n    (let [ys (partition-by identity input)\n          zs (apply concat (map (fn [xs] [(count xs) (first xs)]) ys))]\n      (cons zs (pron zs)))))","problem":110,"user":"536d83cee4b0fc7073fd6e5e"},{"code":"(fn seq-pron [i]\n  (cons (flatten (map #(vector (count %) (first %)) (partition-by identity i)))\n        (lazy-seq (seq-pron (flatten (map #(vector (count %) (first %)) (partition-by identity i)))))))","problem":110,"user":"5123ac8ee4b061b4c6f0e0b1"},{"code":"(comp next iterate) \n  #(mapcat (juxt count first) (partition-by + %))","problem":110,"user":"4e8f1ac6535d65386fec2146"},{"problem":110,"code":"(fn [s]\n    (letfn [(pron [s]\n              (let [split (partition-by identity s)]\n                (mapcat #(list (count %) (first %)) split)))]\n      (next (iterate pron s))))","user":"5275f7a2e4b03e8d9a4a74d0"},{"problem":110,"code":"(fn pronunciations [xs]\n  (let [pronounce  (fn pronounce [xs]\n           (vec (apply concat (for [ys  (partition-by identity xs)]\n                                [(count ys) (first ys)]))))]\n    (rest (iterate pronounce xs))))","user":"54f86b8ce4b01ecee9d88828"},{"problem":110,"code":"(fn pronunciations [s]\n  (letfn [(pronunciate [s]\n                       (mapcat #(list (count %) (first %)) \n                               (partition-by identity s)))]\n    (drop 1 (iterate pronunciate s))))","user":"53286f84e4b09d4e7a9b5505"},{"code":"(fn t9 [coll]\n  (let [next_val (flatten (map #(list (count %1) (first %1)) (partition-by identity coll)))]\n    (lazy-seq (cons next_val (t9 next_val)))))","problem":110,"user":"5046f909e4b03b02161376b5"},{"problem":110,"code":"(fn prons [coll]\n  (let [p (fn [x] (flatten (map #(vector (count %) (first %)) (partition-by identity x))))]\n    (next (iterate p coll))))","user":"59f44189e4b0966464fe6aab"},{"code":"(fn p[i]\n  (lazy-seq \n    (let [r (mapcat (fn [a] [(count a) (last a)]) (partition-by + i))]\n      (cons r (p r)))))","problem":110,"user":"4e43b0d9535dc968683fc4a3"},{"code":"(fn [s]\n    (letfn [(f [x]\n               (mapcat #(list (count %) (first %))\n                       (partition-by identity x)))]\n           (iterate f (f s))))","problem":110,"user":"4f969a66e4b0dcca54ed6cde"},{"problem":110,"code":"(fn pronunciations [v]\n  (letfn [(next-step\n            ([v] (next-step 1 (first v) (rest v)))\n            ([c v vs]\n              (if (not= v (first vs))\n                [c v vs]\n                (recur (inc c) v (rest vs)))))\n          (next-state [v]\n            (let [ne (next-step v)]\n              (if (empty? (last ne))\n                [(first ne) (second ne)]\n                (cons (first ne) (cons (second ne) (next-state (last ne)))))))]\n            (let [state (next-state v)]\n      (lazy-seq (cons state (pronunciations state))))))","user":"5b15811ee4b0cc2b61a3be6f"}]