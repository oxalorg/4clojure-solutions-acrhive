[{"problem":75,"code":"(fn [n]\n  (if (= 1 n)\n    1\n    (letfn [(gcd [a b] (if (zero? b) a (gcd b (mod a b))))]\n      (->> (range 1 n)\n           (map (partial gcd n))\n           (filter #(= 1 %))\n           count))))","user":"55c4cda5e4b0e31453f649a5"},{"problem":75,"code":"(fn [n]\n  (loop [tmpn 2 c 1]\n    (if (< n tmpn)\n      c\n      (if (loop [gcd 1 d 2]\n            (if (< tmpn d)\n              (= 1 gcd)\n              (if (and (= 0 (mod tmpn d)) (= 0 (mod n d)))\n                (recur d (inc d))\n                (recur gcd (inc d)))))\n        (recur (inc tmpn) (inc c))\n        (recur (inc tmpn) c)))))","user":"59368ccae4b02506e01a297a"},{"code":"(fn [n]\n    (letfn [(gcd [a b] (if (zero? b) a, (recur b (mod a b))))\n            (coprime? [m n] (== 1 (gcd m n)))]\n      (if (< n 2) 1\n          (count (for [i (range 1 n)\n                       :when (coprime? i n)]\n                   i)))))","problem":75,"user":"4e89e939535d3e98b8023287"},{"problem":75,"code":"(fn totient [x]\n  (if (= x 1) 1\n    (let [gcd\n          (fn [x y]\n            (let [larger (max x y) smaller (min x y)]\n              (first (filter (fn [i] (and (zero? (rem larger i)) (zero? (rem smaller i)))) (range larger 0 -1)))))\n          coprime (fn [x y] (= 1 (gcd x y)))\n          ]\n      (count (filter #(coprime x %) (range 1 x)))\n    )\n  )\n)","user":"56393681e4b0bfe05bf117f2"},{"code":"(fn [x]\n    (if (= x 1)\n      1\n      (letfn [(gcd [num1 num2]\n                (loop [a num1\n                       b num2]\n                  (cond\n                   (= a b) a\n                   (> a b) (recur (- a b) b)\n                   :else (recur a (- b a)))))]\n        (count (filter #(= 1 (gcd x %)) (range 1 x))))))","problem":75,"user":"53487737e4b084c2834f4a59"},{"code":"(fn [x] (letfn [(g [x y]\n               (if (> x y)\n                 (g y x)\n                 (let [r (rem y x)]\n                   (if (= r 0)\n                     x\n                     (g x r)))))]\n    (if (= 1 x)\n      1\n      (count (filter #(= 1 (g x %)) (range 1 x)))\n      )))","problem":75,"user":"523ed522e4b057c4b7cd0a78"},{"problem":75,"code":"(fn[x](let[\ngcd (fn l[a b](if (zero? b) a (l b (mod a b))))\nq (fn [a](= 1 (gcd x a)))]\n(count(filter q (range x)))))","user":"5849ac5fe4b089d5ab817ed7"},{"problem":75,"code":"(fn [n]\n    (letfn [(rp [big small]\n              (cond (= small 1) true\n                    (= small 0) false\n                    :otherwise (recur small (mod big small))))]\n      (if (= n 1) 1\n          (count\n           (for [x (range 1 n) :when (rp n x) ] x)))))","user":"57fc0719e4b0d3187e900987"},{"code":"(fn [n] (let [gcd (fn [a b] (if (= b 0) a (recur b (rem a b))))]\n        (if (= n 1)\n            1\n            (count (filter #(= (gcd n %) 1) (range n))))))","problem":75,"user":"4e50e2a0535dc968683fc4ef"},{"code":"(fn primes-with [n]\r\n  (if (= n 1)\r\n    1\r\n    (let [dividors (fn dividors [n]\r\n                     (filter #(= (rem n %) 0) (range 1 (inc (quot n 2)))))\r\n          dividors-n (dividors n)]\r\n      (count (filter #(= #{1}\r\n                         (clojure.set/intersection (set (conj (dividors %) %)) (set dividors-n)))\r\n                     (range 1 (inc n)))))))","problem":75,"user":"4dd023dd535d5973398f92ad"},{"problem":75,"code":"(fn [x]\n  (letfn [(gcd [a b]\n           (if (= b 0) a (recur b (mod a b))))]\n    (count (filter #(= % 1) (map #(gcd % x) (range x))))))","user":"5339c105e4b0e30313ee6cae"},{"problem":75,"code":"(fn euler-totient-fn\n  [n]\n  (let [gcd (fn [x y]\n              (loop [a x\n                     b y]\n                (let [r (rem a b)]\n                  (if (= 0 r)\n                    b\n                    (recur b r)))))]\n    (reduce + 1 (map #(if (= (gcd % n) 1)\n                        1\n                        0)\n                     (range 2 n)))))","user":"60c0ceb7e4b0e0fa5f1b42a6"},{"code":"(fn\n  [N]\n  (let \n    [fd (fn\n          [N1]\n          (filter\n            #(if (-> N1 (mod %) (= 0)) true false)\n            (range 2 N1)\n          )\n        )\n     filt (fn\n            [coll fac]\n            (filter\n              #(if (-> % (mod fac) (= 0)) false true)\n              coll\n            )\n          )]\n    (->>\n      (reduce\n        #(filt % %2)\n        (range 2 N)\n        (fd N)\n      )\n      count\n      inc\n    )\n  )\n)","problem":75,"user":"5162757ee4b03cfa3774b3fe"},{"problem":75,"code":"(fn [x]\n   (if (= x 1)\n     1\n     (letfn [(gcd [a b]\n                (cond (< a b) (gcd b a)\n                      (zero? b) a\n                      (= b 1) 1\n                      :else (gcd b (mod a b))))]\n        (reduce + (filter #{1} (map (fn [i] (gcd x i)) (range 1 x)))))))","user":"53e91473e4b036ad0777e495"},{"problem":75,"code":"(fn [x] (->> x\n             range\n             rest\n             (map #(list % (/ x %)))\n             (filter #(ratio? (second %)))\n             (filter #(= (first %) (denominator (second %))))\n             count\n             inc))","user":"56561119e4b0f9d632dd849d"},{"problem":75,"code":"(fn [num]\n  (let [gcd (fn [a b]\n              (let [temp (mod a b)]\n                (if (zero? temp)\n                  b\n                  (recur b temp))))\n        is-coprime (fn [a b]\n                     (= 1 (gcd a b)))]\n    (->> (range 1 (inc num))\n         (filter #(is-coprime num %) )\n         count)))","user":"5defc177e4b093ff717275af"},{"problem":75,"code":"(fn euler-totient [n]\n  (if (= 1 n) 1\n    (let [gcd (fn [a b]\n                (if (= b 0)\n                  a\n                  (recur b (rem a b))))]\n      (count (filter #(= 1 (gcd n %)) (range 1 n))))))","user":"54f2fe9fe4b050824f58f5b8"},{"code":"(fn [n]\n  (letfn [(gcd [a b] (if (zero? b) a (recur b (rem a b))))\n          (coprime? [a b] (= 1 (gcd a b)))]\n    (count (filter (partial coprime? n) (range n)))))","problem":75,"user":"51d19c24e4b0cfcf579466c3"},{"problem":75,"code":"(fn totient [n]\n  (letfn [(gcd [x y]\n               (loop [i x\n                      j y]\n                 (cond \n                  (= i j) i\n                  (> i j) (recur (- i j) j)\n                  :else (recur i (- j i)))))]\n    (if (= n 1)\n      1\n      (count (for [x (range 1 n)\n                   :when (= (gcd x n) 1)]\n               x)))))","user":"585e2e77e4b0f14aab7c87ac"},{"problem":75,"code":"(fn [x]\n  (if (= x 1)\n    1\n    (let [gcd #(let [[n1 n2] (sort [%1 %2])]\n                 ((fn [s l]\n                    (if (<= s 0)\n                      l\n                      (recur (rem l s) s)))\n                  n1 n2))]\n      ((fn [i n]\n         (if (<= x i)\n           n\n           (if (= (gcd i x) 1)\n             (recur (inc i) (inc n))\n             (recur (inc i) n))))\n       1 0))))","user":"5ed52854e4b016b56eae05d2"},{"problem":75,"code":"(fn [n]\n  (let [gcd (fn [a b]\n              (if (zero? b)\n                a\n                (recur b (mod a b))))]\n    (->> (range 1 (inc n))\n         (map #(gcd n %))\n         (filter #{1})\n         (count))))","user":"5c3796b3e4b0d62ef62d9f77"},{"problem":75,"code":"(fn f [n]\n  (letfn [(gcd [a b]\n            (if (zero? a) b\n              (recur (rem b a) a)))\n          (coprime [a b]\n            (= 1 (gcd a b)))]\n      (if (= n 1) 1\n        (count (filter #(coprime n %) (range 1 n))))))","user":"53d78b64e4b0e771c3025466"},{"problem":75,"code":"(fn [x]\n  (if (= x 1)\n    1\n    (letfn [(gcd [a b]\n               (if (= b 0)\n                 a\n                 (recur b (rem a b))))]\n      (count (filter #(= 1 (gcd x %)) (range 1 x))))))","user":"53ce4cd4e4b00fb29b2212ef"},{"problem":75,"code":"(fn totient\n  [x]\n  (let [gcd (fn [a b]\n              (if (zero? b) a (recur b (rem a b))))\n        coprime #(= 1 (gcd %1 %2))]\n    (if (= 1 x) 1 (count (filter #(coprime % x) (range 1 x))))))","user":"5f838122e4b01aacbe7a2715"},{"problem":75,"code":"(fn z [n]\n  (let [divisors (fn [x] (into #{} (filter #(zero? (mod x %)) (range 1 (inc x)))))\n        divisorsN (divisors n)\n        isBiggestCommonOne (fn [s1 s2] (let [i (clojure.set/intersection s1 s2)] (and \n                                                                                      (= 1 (count i))\n                                                                                      (contains? i 1))))]\n    (if (= 1 n)\n      1\n      (count (filter #(isBiggestCommonOne (divisors %) divisorsN) (range 1 n))))))","user":"583667c7e4b089d5ab817cfb"},{"code":"(fn [n]\n  (letfn [\n    (cop [a b] \n      (if (== 0 a) \n        (== b 1)\n        (if (> a b) \n          (cop b a) \n          (cop a (- b a)))))]\n  (count (filter #(cop % n) (cons 1 (range 2 n))))))","problem":75,"user":"4f569218e4b0a7574ea71826"},{"code":"#(let [denoms (fn [n] (filter (comp zero? (partial rem n)) (range 1 n)))\n       gcd (fn [a b]\n             (let [int (clojure.set/intersection\n                                 (set (denoms a))\n                                 (set (denoms b)))]\n               (and (seq int) (apply max int))))]\n   (if (= % 1)\n     1\n     (count (filter #{1} (map  (partial gcd %) (range 1 (dec %)))))))","problem":75,"user":"51f9527fe4b09be9c177e549"},{"code":"(fn [x]\n  (if (= x 1)\n    1\n    (let [gcd (fn [a b]\n                (if (= b 0)\n                  a\n                  (recur b (mod a b))))]\n      (count (filter #(= (gcd x %) 1) (range x))))))","problem":75,"user":"534941d1e4b084c2834f4a60"},{"problem":75,"code":"(fn [n]\n   (count (filter (fn [i] (= 1 ((fn [n1 n2]\n                            (loop [big (max n1 n2), small (min n1 n2)]\n                              (cond (= small 0) big\n                                    :else (recur small (mod big small))))) i n)))\n            (range n))))","user":"52fac708e4b047fd55836fff"},{"problem":75,"code":"(fn [x]\n  (->> (range 1 x)\n       (filter #(and (ratio? (/ x %)) (= x (numerator (/ x %)))))\n       (count)\n       (inc)))","user":"53b7c21ae4b047364c0444d4"},{"problem":75,"code":"(fn euler-totient-3\n  [x]\n  (if (= x 1)\n    1\n    (count (filter #(= 1 ((fn gcd\n                       [a b]\n                       (if (zero? b)\n                         a\n                         (gcd b (mod a b)))) x %1)\n                   )\n          (range 1 x)\n  )))\n)","user":"556be3dce4b09a3098a524f7"},{"problem":75,"code":"(fn totient [x]\n  (if (= x 1) \n    1\n    (letfn [(prime-factors \n              ([n] (prime-factors n 2 []))\n              ([n candidate acc]\n                 (if (= n 1)\n                   acc\n                   (if (= 0 (mod n candidate))\n                     (recur (/ n candidate) candidate (conj acc candidate))\n                     (recur n (inc candidate) acc)))))]\n      (let [pfacts (set (prime-factors x))]\n        (letfn [(coprime [y]\n                  (empty? (filter #(= 0 (mod y %)) pfacts)))]\n          (->> x\n               range\n               (drop 1)\n               (filter coprime)\n               count))))))","user":"543d89dfe4b032a45b869350"},{"code":"(fn __ [n]\n  (letfn [(gcd [a b]\n    \t\t(if (= b 0)\n      \t\t\ta\n      \t\t\t(recur b (mod a b))))]\n  (if (= n 1)\n    1\n    (count \n     (filter #(= 1 (gcd n %))\n     (range 1 n))))))","problem":75,"user":"4fa719c0e4b081705acca1bf"},{"code":"(fn\n    [n]\n    (letfn [(gcd [x y]\n                (if (= 0 x) y\n                    (gcd (rem y x) x)))]\n        (count (filter #(= 1 (gcd % n)) (range n)))))","problem":75,"user":"50b35486e4b03ea88043356a"},{"problem":75,"code":"(fn eulers-totient [num]\n  (if (= 1 num) 1\n  (count (filter #(= 1 ((fn gcd [a b] (let [big (max a b) small (min a b)] (if (= big small) small (gcd small (- big small))))) %1 num)) (range 1 num)))))","user":"558bdcefe4b0277789237633"},{"code":"(fn [n]\n    (if (= 1 n) n \n      (count (filter (fn [x]\n              (= 1 ((fn gcd [a b]\n                (if (zero? b) a (gcd b (mod a b)))) n x) )) (range 1 n))))\n    \n  )","problem":75,"user":"50d3b03fe4b030b634c368b9"},{"problem":75,"code":"(fn euler-func [n]\n  (if (= 1 n)\n    1\n    (count (filter #(= 1 ((fn gcd [a b]\n                      (if (zero? b)\n                        a\n                        (recur b (mod a b)))) % n)) (range 1 n)))))","user":"565654dae4b0f9d632dd849f"},{"code":"#(if (= % 1)\n    1\n    (count (for [x (range 1 %)\n              :when (= x (numerator (/ x %)))]\n             x)))","problem":75,"user":"4e7dfab0535db169f9c796f9"},{"code":"(fn [x] (letfn [(gcd  [a b] (if (zero? b)\n                              a\n                              (recur b (mod a b))))\n                (coprime [a b] (= 1 (if (zero? b)\n                                      a\n                                      (gcd b (mod a b)))))\n                (totient [a] (count (filter #(coprime a %) (range 1 a))))]\n          (if (= x 1) 1 (totient x))))","problem":75,"user":"4fa05b99e4b0dcca54ed6d47"},{"problem":75,"code":"(fn totient [in]\n  (if (= in 1) \n    1\n    (letfn [(gcd [x y] \n          (loop [a x\n           b y]\n      (if (= a b) \n        a\n        (if (> a b)\n          (recur (- a b) b)\n          (recur a (- b a))))))]\n      (->> in\n           (range 1 ,,,)\n           (map (partial gcd in) ,,,)\n           (filter (partial = 1) ,,,)\n           (count)))))","user":"5710140fe4b09c608db7042e"},{"problem":75,"code":"(fn euler-totient [n]\n  (letfn [(common-divisor2 [n1 n2]\n                           (if (= n2 0)\n                             n1\n                             (recur n2 (rem n1 n2))))]\n    (count (filter #(= (common-divisor2 n %) 1) (range n)))))","user":"5e0d948fe4b099d064962f98"},{"problem":75,"code":"(fn [n]\n    (let [gcd (fn gcd [x y]\n                (if (zero? y)\n                  x\n                  (gcd y (mod x y))))\n          coprime (filter #(= 1 (gcd % n)) (range 1 n))]\n      (max 1 (count coprime))))","user":"4e837808535db62dc21a62d9"},{"problem":75,"code":"(fn [number]\n  (letfn [(gcd [x y]\n            (if (zero? y)\n              x\n              (recur y (mod x y))))]\n    (loop [result '()\n           current 1]\n      (if (> current number)\n        (count result)\n        (recur (if (= 1 (gcd current number))\n                 (conj result current)\n                 result)\n               (inc current))))))","user":"58637f03e4b0f14aab7c881e"},{"code":"(fn etf [n]\n  (if (= 1 n)\n    1\n    (let [nums (take (dec n) (iterate inc 1))\n          gcd (fn [x y]\n                (loop [a x, b y]\n                  (if (zero? b)\n                    a\n                    (recur b (rem a b)))))]\n      (count (loop [result [], nums2 nums]\n               (if (empty? nums2)\n                 result\n                 (let [f (first nums2)\n                       gcdr (gcd n f)]\n                   (when (= 1 gcdr) (conj result gcdr))\n                   (recur \n                     (if (= 1 gcdr) (conj result f) result) \n                     (rest nums2))))\n               )))))","problem":75,"user":"52cf084ce4b07d0d72b27399"},{"code":"(fn [x]\n  (let [gcd (fn gcd ([a] (gcd a x))\n              ([a b] (if (> a b)\n                       (if (= 0 (rem a b)) b\n                         (gcd (- a b) b))\n                       (gcd b a))))]\n    (if (= x 1) 1\n      (->> x (range 1) (map gcd) (filter #(= 1 %)) count))))","problem":75,"user":"4f1bb9d8535d64f60314647d"},{"problem":75,"code":"(fn [a]\n  (count\n    (filter\n      #(loop [x a y %]\n        (cond\n         (> x y) (recur (- x y) y)\n         (< x y) (recur x (- y x))\n         :else (= 1 x)))\n      (range 1 (inc a)))))","user":"522eb5cce4b01cdb292c5f0c"},{"problem":75,"code":"(fn [x]\n  (let [i (range 2 x)\n        g (comp zero? rem)\n        p (filter #(g x %) ((fn f [[x & y]]\n                              (when x (cons x (f (remove #{x} y)))))\n                            i))]\n    (->> i\n         (filter #(not-any? (partial g %) p))\n         count\n         inc)))","user":"53c74cfce4b00fb29b2212a7"},{"problem":75,"code":"#(inc\n  (count\n   ((fn coprimes[from]\n      (if-let [candidate (first from)]\n        (if (= 0 (rem % candidate))\n          (coprimes (remove (fn [n]\n                              (= 0 (rem n candidate)))\n                            (rest from)))\n          (cons candidate (coprimes (rest from))))))\n    (range 2 %))))","user":"5ec6de19e4b08d0ec38692da"},{"problem":75,"code":"(fn totient [x]\n  (let [potentialPrimes ((fn primesUpToHalf [n]\n            (loop [primes [2 3] current 5]\n              (cond\n                (> current (/ n 2)) primes\n                (some #(= 0 (mod current %)) (rest primes)) (recur primes (+ 2 current))\n                :else (recur (conj primes current) (+ 2 current))\n                ))) x)]\n    (if \n      (= 1 x) 1\n      (count (filter #(not-any? (fn [prime] (and (zero? (mod x prime)) (zero? (mod % prime)))) potentialPrimes) (range 1 x))))\n    ))","user":"57131dfbe4b07c98581c3a98"},{"code":"#(reduce\r\n  (fn [c x]\r\n    (if (= 1 (\r\n              (fn g [a b]\r\n                (if (= 0 b) a (g b (mod a b)))) x %))\r\n      (+ 1 c)\r\n      c))\r\n  0 (range 1 (+ 1 %)))","problem":75,"user":"4fe9de74e4b0547ebccb2475"},{"code":"(fn [n]\n  (let [gcd (fn [a b] (if (= a b) a (recur (- (max a b) (min a b)) (min a b))))]\n    (count (filter #(= 1 %)\n            (for [i (range 1 (inc n))]\n              (gcd i n))))))","problem":75,"user":"4e7d1c22535db169f9c796c5"},{"problem":75,"code":"(fn [n]\n  (let [gcd (fn [a, b] (loop [x (if (> a b) (list b a) (list a b))] \n    (let [d (rem (second x) (first x))] \n      (if (= d 0) (first x) (recur (conj x d))))))]\n    (count (loop [x 1, a []] (if (> x n) a (recur (inc x) \n       (if (= 1 (gcd x n)) (conj a x) a )))))))","user":"53bcdd41e4b0d9a98559a6c0"},{"code":"(fn eulor[x]\n  (letfn [\n          (gcd \n            [a b]\n            (let[ c (mod a b)]\n              (if(zero? c)\n                b\n                (recur b c))))\n          (get-eulor\n            [i x num]\n            (cond (= 1 x ) 1\n                  (= i x) num\n                  (= 1 (gcd x i)) (recur (inc i) x (inc num))\n                  :else (recur (inc i) x num)))]\n    (get-eulor 1 x 0)))","problem":75,"user":"5273562ae4b03e8d9a4a7479"},{"code":"(fn [n]\n  (letfn [(coprime? [a b]\n            (= 1 (gcd a b)))\n          (gcd [a b]\n            (if (zero? b)\n              a\n              (recur b (rem a b))))]\n    (count (filter (partial coprime? n)\n                   (range 1 (inc n))))))","problem":75,"user":"50b0cffae4b009df37c708c5"},{"code":"(fn [x]\n  (let [gcd (fn gcd [x y] (if (> y 0) (gcd y (mod x y)) x))\n        coprime (fn [x y] (= 1 (gcd x y)))] \n    (if (= x 1)\n        1 \n        (count (filter (partial coprime x) (range 1 x))))))","problem":75,"user":"5061cc17e4b0a30dc9a35d34"},{"code":"(fn [x]\n  (let [gcd (fn [a b]\n              (if (zero? b)\n                a\n                (recur b (mod a b))))\n        coprime? (fn [a b] (= 1 (gcd a b)))]\n    (if (= x 1)\n      1\n      (count (filter (partial coprime? x) (range 1 x))))))","problem":75,"user":"515f8a0de4b0e2be8aa20bce"},{"code":"(fn [n]\n  (letfn [(gcd [larger smaller]\n               (loop [l larger s smaller]\n                 (if (not= 0 s)\n                   (recur s (mod l s))\n                   l)))]\n    \n    (count (filter (fn [i]\n                     (= 1 (gcd i n)))\n                     (range 1 (inc n))))))","problem":75,"user":"513cb853e4b0b86ece9f322b"},{"problem":75,"code":"(fn [n]\n  (letfn [(gcd [a b]\n            (loop [a a\n                   b b]\n              (cond\n               (> a b) (recur (- a b) b)\n               (> b a) (recur a (- b a))\n               (= a b) a)))\n          (coprime? [a b]\n            (= (gcd a b) 1))]\n    (cond\n     (< n 1) 0\n     (= n 1) 1\n     :else (count (filter #(coprime? n %) (range 1 n))))))","user":"4f774b17e4b0fbe0118ec57b"},{"problem":75,"code":"(fn count-coprimes [n]\n  (case n\n    1 1\n    (letfn [(gcd [a b]\n             (loop [a1 a\n                    b1 b]\n               (if (= 0 b1)\n                 a1\n                 (recur b1 (mod a1 b1)))))]\n      (count (filter #(= 1 (gcd n %)) (range n))))))","user":"5c950334e4b048ec896c5a44"},{"code":"(fn euler-totient [n]\n  (letfn [(gcd [a b]\n            (if (<= b 0)\n              a\n              (recur b (mod a b))))\n          (is-coprime? [a b]\n            (= (gcd a b) 1))]\n    (count (filter (partial is-coprime? n) (range n)))))","problem":75,"user":"4ff355a1e4b0678c553fc34d"},{"problem":75,"code":"(fn [n]\n  (if (= 1 n)\n    1\n    (let [divisors (fn [n] (set (filter #(= 0 (mod n %)) (range 1 (inc n)))))\n          gcd (fn [m n] (reduce (fn [a b] (Math/max a b)) 1 (clojure.set/intersection (divisors m) (divisors n))))]\n      (count (filter (fn [c] (= 1 (gcd n c))) (drop 1 (range n)))))))","user":"50a4f36be4b0344e360f3bc9"},{"code":"(fn [i]\n    (if (= i 1) 1\n        (letfn [(greatest-common-divisor [x y]\n                  (loop [m (max x y) n (min x y)]\n                    (if (zero? n)\n\t                  m\n                      (recur n (mod m n)))))\n                (coprime? [x y] (= (greatest-common-divisor x y) 1))]\n          (count (filter #(coprime? i %) (range 1 i))))))","problem":75,"user":"51c3c6a6e4b0851ac09658f8"},{"code":"(fn [n] (count (filter (fn [a] (= 1 \n              (#(if (= %2 0) % (recur %2 (mod % %2))) a n)))\n       (range n))))","problem":75,"user":"4eaede1f535d7eef30807329"},{"problem":75,"code":"(fn totientX [n] \n(if (= n 1) 1\n\t(count (filter (fn [x] ((fn coprime? [a b] (= ((fn gcd [a b]\n\t(if(zero? b) a\n\t\t(gcd b (mod a b))\n\t))\n a b) 1)) x n)) (range 1 n))))\n)","user":"568820e8e4b0dcc4269f4067"},{"code":"(fn [n]\n  (letfn [ (gcd[x y] (loop[x x y y]\n                  (cond (> x y) (recur y (- x y))\n                        (> y x) (recur x (- y x))\n                        :else x)))]\n    (count (filter #(= 1 (gcd % n)) (range 1 (inc n))))))","problem":75,"user":"507c7c8be4b0b083f3ff82ef"},{"code":"(fn tot [n]\n  (let [isPrime (fn [a] (not-any? #(= 0 (mod a %)) (range 2 (dec a))))]\n  (* n (reduce #(* % (- 1 (/ 1 %2))) 1\n     (filter #(and (isPrime %) (= (mod n %) 0)) (range 2 n))))))","problem":75,"user":"4eb0a757535d7eef3080733d"},{"problem":75,"code":"(fn [n]\n  (let [gcd (fn [x y]\n              (if (zero? y)\n                x\n                (recur y (mod x y))))]\n    (count (filter\n            #(= 1 (gcd n %))\n            (range 1 (inc n)))))\n  )","user":"564a560ae4b0284900eef654"},{"code":"(fn [n]\n    (->>\n     (range 2 n)\n     (filter\n      #(= 1\n        (.gcd \n         (biginteger n)\n         (biginteger %)\n         )))\n     count\n     inc\n     ))","problem":75,"user":"5281a445e4b0757a1b17143a"},{"code":"(fn [n] \n          (if (= 1 n)\n              n\n              (let [gcd (fn [a b]\n                            (loop [x a y b]\n                               (if (= y 0)\n                                   x\n                                   (recur y (rem x y)))))\n                   ]\n                   (count (filter #(= 1 (gcd n %)) (range 1 n))))))","problem":75,"user":"4f03f197535dcb61093f6b84"},{"code":"(fn [n]\n  (if (= 1 n)\n    1\n    (letfn [(gcd [a b]\n              (apply max (clojure.set/intersection\n                           (set (filter #(= 0 (mod a %)) (range 1 (inc a))))\n                           (set (filter #(= 0 (mod b %)) (range 1 (inc b)))))))]\n      (count\n        (filter\n          #(= 1 (gcd n %))\n          (range 1 n))))))","problem":75,"user":"4dbdc9da535d020aff1edf4c"},{"code":"(fn [x]\n  (let [gcd (fn [a b]\n              (if (zero? b)\n                a\n                (recur b (mod a b))))\n        coprime? (fn [a b] (= 1 (gcd a b)))]\n    (->> (range 1 (inc x))\n         (filter #(coprime? x %))\n         count)))","problem":75,"user":"5054c853e4b0b1b9d1860eb3"},{"problem":75,"code":"(fn [n]\n  (letfn [(gcd [a b] (if (zero? b) a (recur b (rem a b))))]\n    (->> (range 1 (inc n)) (filter #(= 1 (gcd n %))) count)))","user":"567695c2e4b05957ce8c6157"},{"problem":75,"code":"(fn [x]\n  (letfn [(lcf [a b]\n            (let [[l h] (sort [a b])]\n              (if (zero? (mod h l))\n                l\n                (lcf l (mod h l)))))]\n    (count (filter #(= (lcf x %) 1) (range 1 (inc x))))))","user":"53fb5256e4b0de5c4184857f"},{"code":"(fn [n] \n    (let [my-pgcd \n        (fn [ a b ]\n        (let [ c (mod a b)]\n        (if (= c 0) b (recur b c))))\n    ]\n    (if (= n 1) 1 (count(filter #(= 1 (my-pgcd n %1)) (range 1 n))))))","problem":75,"user":"51f59607e4b0abb92f97f9d5"},{"problem":75,"code":"(fn totient [n]\n    (let [gcd (fn [a b]\n                (if (zero? b)\n                    a\n                    (recur b (mod a b))))]\n        (if (= n 1)\n            1\n            (count (filter #(= 1 (gcd n %)) (range 1 n))))))","user":"57644395e4b0994c1922fbf2"},{"problem":75,"code":"(fn [x]\n  (let [gcd (fn [a b] (if (zero? b) a (recur b (mod a b))))]\n    (inc (count (filter #(= 1 (gcd x %)) (range 2 x))))))","user":"4eb70649535d7eef30807373"},{"code":"(fn [x]\n  (->> (range x)\n    (map biginteger)\n    (filter #(== 1 (.gcd (biginteger x) %)))\n    count))","problem":75,"user":"50479524e4b0371827a27bc4"},{"code":"(fn [n]\n  (letfn [(gcd [x y]\n            (if (zero? y)\n              x\n              (recur y (mod x y))))]\n  (if (= n 1)\n    1\n    (count (filter #(= 1 (gcd n %)) (range 1 n))))))","problem":75,"user":"52487654e4b05ef8e38e63dc"},{"problem":75,"code":"(fn totient-euler [num]\n    (if (= num 1)\n      1\n      (->>\n        (range 1 (inc num))\n        (map #(/ % num))\n        (filter #(and (ratio? %) (= (denominator %) num)))\n        (count)\n        )))","user":"55e6c3f5e4b050e68259b48c"},{"problem":75,"code":"(fn [n] (let [R (range 2 n) D (filter #(= 0 (mod n %)) R) K (filter (fn [k] (every? #(not= 0 (mod k %)) D)) R)] (+ 1 (count K))))","user":"55f6fe09e4b06e875b46cea2"},{"problem":75,"code":"(fn [n]\n  (letfn [(gcd [x y]\n            (let [[minimum maximum] (sort [x y])\n                  remainder (mod maximum minimum)]\n              (if (zero? remainder)\n                minimum\n                (recur minimum remainder))))]\n    (->> (range 1 (inc n))\n         (filter #(= 1 (gcd % n)))\n         count)))","user":"5297dcc5e4b02ebb4ef75047"},{"problem":75,"code":"(fn[x]\n  (if (= 1 x) \n    1\n    (count (filter \n        #( = 1 (apply max (apply clojure.set/intersection \n            ( map ( fn[z] (set \n                (cons z \n                  ( reverse \n                     (filter \n                       (fn[q]\n                         ( = (mod z q) 0)) \n                       (range 1 (/ (inc z) 2))))))) [x %])))) \n        (range 1 x)))))","user":"54fc7d89e4b07d26eda61d2b"},{"code":"(fn coprime [n]\n   \n\t\t((fn f [start ans]\n\t\t\t(cond (= n 1) 1\n        (= start n) ans\n\t\t\t\t:else (let [gcd ((fn g [a b] (if (= b 0) a (g b (rem a b)))) start n)]\n\t\t\t\t\t(if (= gcd 1) (f (inc start) (inc ans)) (f (inc start) ans))\n\t\t\t\t)\n\t\t\t)\n\t\t) 1 0)\n)","problem":75,"user":"4f7b6b90e4b06e829148e1a4"},{"problem":75,"code":"(fn [num]\n  (let [divides-both? (fn [n m i] (and (zero? (mod n i)) (zero? (mod m i))))\n        coprime? (fn [n m] (not-any? (partial divides-both? n m) (range 2 (inc m))))]\n    (if (= num 1)\n    1 \n    (loop [n num iter (dec num) res 0]\n        (if (= iter 1) \n          (inc res)\n          (if (coprime? n iter)\n          \t(recur n (dec iter) (inc res)) \n            (recur n (dec iter) res)))))\n    )\n  \n  )","user":"5a1c07c1e4b0ff51aa4b3232"},{"code":"(fn [n]\n  (letfn [(gcd [a b] (if (zero? b) a (recur b (rem a b))))\n          (co-prime? [k] (= (gcd n k) 1))]\n    (count (filter co-prime? (range 1 (inc n))))))","problem":75,"user":"4fe84c74e4b07c9f6fd12c3c"},{"problem":75,"code":"(fn [number] (if (= number 1) 1 (letfn [(divisors [n] (set (filter #(integer? (/ n %)) (range 1 (inc n)))))] (count (filter #(= #{1} (clojure.set/intersection (divisors number) (divisors %))) (range 1 number))))))","user":"56cad309e4b0ea9b8538f720"},{"problem":75,"code":"(fn [x] (let [gcd (fn [a b] (last (filter #(and (= (mod a %) 0) (= (mod b %) 0)) (range 1 (inc (min a b))))))]\n  (max 1 (count (filter #(= 1 (gcd x %)) (range 1 x))))))","user":"5b919d9de4b0c0b3ffbd4a24"},{"problem":75,"code":";; peterwilkins and I worked together on this:\n  (fn [x]\n    (letfn [(f [d s co-primes]\n              (cond\n                (= x 1) 1\n                (= x s) (count co-primes)\n                (or (zero? (mod x s))\n                    (some #(zero? (mod s %)) d))\n                (f (conj d s) (inc s) co-primes)\n                :else (f d (inc s) (conj co-primes s))))]\n      (f #{} 2 #{1})))","user":"4e6a23d0535d8ccf87e9fea0"},{"code":"(fn totient [x]\n  (let [gcd (fn gcd [a b]\n              (cond\n               (< a b) (if (zero? (rem b a)) a (gcd (rem b a) a))\n               (= a b) a\n               :else (gcd b a)))]\n    (inc (count (filter #(= 1 (gcd x %)) (range 2 x))))\n    ))","problem":75,"user":"4ddb696b535d02782fcbe9fa"},{"problem":75,"code":"(fn totient [n] \n  (let [gcd (fn [a b] (if (= b 0) a (recur b (mod a b))))]\n  (count (filter (fn [x] (= 1 (gcd n x))) (range 1 (inc n))))))","user":"5cb0f70ce4b026601754b8c1"},{"code":"(fn totient [n]\n        (letfn [(gcd [a b]\n                     (if (zero? b) a \n                         (gcd b (rem a b))))]\n                         (count (filter #(= 1 (gcd % n))\n                                        (range n)))))","problem":75,"user":"4e599577535d8a8b8723a29f"},{"code":"(fn etf [x]\n  (let [get-divisors (fn [x]\n                       (filter #(->> (mod x %) (= 0)) (range 1 (inc x))))\n        divisors (set (get-divisors x))\n        does-contain (fn [xs a-set]\n                       (->> (filter #(contains? a-set %) xs) count (== 1)))]\n    (if (== x 1)\n      1\n      (->> (filter #(does-contain (get-divisors %) divisors) (range 1 x)) count))))","problem":75,"user":"52016fd3e4b0b2e020a18f10"},{"problem":75,"code":"(fn [n]\n  (let [gcd (fn [a b] (if (zero? b) a (recur b (mod a b))))]\n    (case n\n      1 1\n      (->> (range 1 n) (map #(gcd n %)) (filter #(= % 1)) count))))","user":"5c13da47e4b01240ff5671a6"},{"problem":75,"code":"(fn [n]\n  (if (= n 1)\n    1\n    ;; Added in special case hence bad indentation.\n  (letfn [ (gcd [a b]\n                (let [smaller (if (< a b) a b)\n                      larger  (if (< a b) b a)\n                      difference (- larger smaller)]\n                  (if (= difference 0)\n                    larger\n                    (gcd smaller difference) )))\n           ]\n    (->> (range n) (drop 1) (filter #(= (gcd % n) 1) ) count)\n    ))\n  )","user":"53c1ce3ee4b00fb29b221268"},{"code":"(fn [n]\r\n  ;; x bigger\r\n  (let [gcd (fn gcd [x y]\r\n               (let [[x y] (if (> x y) [x y] [y x])]\r\n               (if (zero? (rem x y))\r\n                 y\r\n                 (recur y (- x y)))))\r\n        cop #(= 1 (gcd %1 %2))]\r\n    (if (= n 1)\r\n      1\r\n      (count (filter (partial cop n) (range 1 n))))))","problem":75,"user":"4e8681b7535dae1a5effa438"},{"code":"(fn[k]\n  (letfn [(gcd[n m]\n            (let [n+ (max n m)\n              m+ (min n m)]\n              (if (zero? m+)\n                n+\n                (recur (- n+ m+) m+))))]\n    (count (filter #(= 1 %)\n      (map #(gcd k %) (range k))))))","problem":75,"user":"4e58bcd4535d8a8b8723a296"},{"problem":75,"code":"(fn [num]\n  (if (= 1 num) 1\n    (let [nums (range 1 num)\n          find-divisors (fn [x] (set (filter #(= 0 (mod x %)) (range 1 x))))\n          num-divisors (find-divisors num)]\n      (dec (count (filter #(= 1 (count (clojure.set/intersection num-divisors (find-divisors %)))) (range 1 num)))))))","user":"53fe1b42e4b0de5c418485f1"},{"problem":75,"code":"(fn euler-tot-fn[l]\n  (count (filter\n    (fn [g]\n      (= ((fn gcd [a b]\n            (let [quot (int (/ a b)) rem (mod a b)]\n              (if (not(= 0 rem)) (gcd b rem) b)))\n           l g)\n         1))\n  (take-while (partial >= l) (iterate inc 1)))\n))","user":"566b8946e4b0a866af6896b0"},{"problem":75,"code":"(fn calc [n]\n   (let [vals (map\n               (fn [top]\n                 (->> (range 1 (+ top 1))\n                      (filter (fn [x] (= (mod top x) 0)))\n                      (set)))\n               (range 1 (+ n 1)))\n         refr (last vals)]\n     (count (filter #(= 1 (count (clojure.set/intersection % refr))) vals))))","user":"5d5c6675e4b09db18d4482ec"},{"problem":75,"code":"(fn foo [n]\r\n  (->>\r\n    (range (dec n) 0 -1)\r\n    (map \r\n      (fn [x]\r\n        (first\r\n          (filter\r\n            #(= 0 (mod n %) (mod x %))\r\n            (range x 0 -1)))))\r\n    (filter #(= 1 %))\r\n    count\r\n    (#(max 1 %))))","user":"606e0a42e4b069485764de19"},{"code":"(fn [n]\n    (if (= 1 n) 1\n    (let [divisors (fn [x] (set (filter #(= (rem x %) 0) (range 2 (inc x)))))\n          base-divsors (divisors n)]\n      (count (filter #(not (seq (clojure.set/intersection base-divsors (divisors %)))) (range 1 n))))))","problem":75,"user":"52a32876e4b04e0c58e87bfb"},{"problem":75,"code":"(fn divisiors-of-n [n]\n  (count (if (= n 1)\n           [1]\n           (let [all-nums (range 1 n)\n                 divisors (rest (filter #(= 0 (mod n %)) all-nums))]\n             (->> (for [n all-nums\n                        x divisors]\n                    {n [(if (>= n x)\n                          (mod n x)\n                          n)]})\n                  (apply merge-with concat)\n                  (map (fn [[k v]]\n                         (let [non-nils (remove nil? v)]\n                           (when (seq non-nils)\n                             {k non-nils}))))\n                  (remove nil?)\n                  (remove #(some zero? (flatten (vals %))))\n                  (map keys)\n                  flatten)))))","user":"5400e918e4b0de5c41848619"},{"problem":75,"code":"(fn [x]\n  (letfn [(gcd [u v]\n\t  (cond (= u v) u\n    \t    (= u 0) v\n       \t\t(= v 0) u\n       \t\t(and (even? u) (even? v)) (* 2 (gcd (/ u 2) (/ v 2)))\n        \t(and (even? u) (odd? v)) (gcd (/ u 2) v)\n\t        (and (odd? u) (even? v)) (gcd u (/ v 2))\n        \t:else (if (> u v) (gcd (/ (- u v) 2) v)\n                \t(gcd (/ (- v u) 2) u))))]\n  (count (filter #(= 1 (gcd % x)) (range x)))))","user":"53e9a15be4b036ad0777e4ae"},{"problem":75,"code":"(fn [n]\n  (let [gcd (fn [a b]\n              (if (zero? b)\n          \t\ta\n          \t\t(recur b (mod a b))))]\n    (count (filter #(= 1 (gcd % n)) (range n))) ))","user":"56f881e0e4b08e7d20b96839"},{"problem":75,"code":"(fn __ [x]\n  (letfn [(coprime-to-x? [n]\n            (loop [n n\n                   try 2]\n              (cond (> try n)\n                    true\n\n                    (and (= 0 (mod n try))\n                         (= 0 (mod x try)))\n                    false\n\n                    :else\n                    (recur n (inc try)))))]\n    (->> (range 2 x)\n         (filter coprime-to-x?)\n         count\n         inc)))","user":"55916764e4b0604b3f94d57b"},{"code":"(fn [n]\n   (count (filter #(= 1 ((fn g [a b]\n                           (if (= b 0) a (g b (rem a b)))) % n)) (range n))))","problem":75,"user":"5027b41ee4b01614d1633fee"},{"problem":75,"code":"(fn\n  [x]\n  (if (= 1 x)\n    1\n    (let [divides? (fn [num den] (= 0 (rem num den)))\n          factors (filter (partial divides? x) (range 2 x))]\n      (->> (range 1 x)\n           (filter #(empty? (filter (partial divides? %) factors)))\n           count))))","user":"57ea2c91e4b0bfb2137f5b42"},{"problem":75,"code":"(fn [x]\n  (if (= 1 x)\n    1\n    (letfn [(gcd [a b] (cond (= a b) a\n                             (< a b) (recur a (- b a))\n                             :else   (recur b (- a b))))]\n      (count (filter #(= 1 (gcd x %)) (range 1 x))))))","user":"55ac07afe4b03311e7b7328f"},{"code":"(fn tot [x]\n  (letfn [(gcd [a b] (if (zero? b) a (gcd b (rem a b))))]\n    (count (filter #(= 1 (gcd x %)) (range x)))))","problem":75,"user":"5084c43be4b0fb8f40674bfa"},{"problem":75,"code":"(fn totient [n]\n   (if (= n 1)\n     1\n     (letfn [(gcd [x y] \n               (if (< x y) \n                 (gcd y x)\n                 (cond\n                   (= 0 (rem x y)) y\n                   true (gcd y (rem x y)))))]\n       (count (filter #(= 1 (gcd % n)) (range 1 n))))))","user":"5d1bbef0e4b02ea6f0fb6984"},{"problem":75,"code":"(fn totient [x]\n  (letfn [(gcd [a b]\n               (cond\n            \t(= a b) a\n               \t(> a b) (gcd (- a b) b)\n               \t(< a b) (gcd a (- b a))\n               )\n          )\n          (coprime? [y z] (= 1 (gcd y z)))\n         ]\n    (if (= x 1)\n      1\n      (count (for [n (range 1 x)\n        :when (coprime? n x)]\n        n))\n    )\n  )\n)","user":"540f09b9e4b0addc1aec6725"},{"problem":75,"code":"(fn euler_prime [n]\n  (if (= n 1)\n    1\n    (->> n\n         (range 1)\n         (filter (fn [a]\n                   (= nil (some (fn [y] (if (and (zero? (mod n y)) (zero? (mod a y))) true nil)) (range 2 (inc a))))))\n         (count)\n         )))","user":"5ab490f4e4b073f17744261d"},{"problem":75,"code":"(fn [n]\n (if (= 1 n) 1\n  (letfn [(gcd [a b]\n     (let [x (if (< a b) a b)\n           y (if (< a b) b a)]\n       (if (= 0 (mod y x))\n         x\n         (recur (- y x) x))))]\n    (count\n     (filter #(= 1 %)\n      (map #(gcd n %)\n       (drop 1\n        (take n\n         (range)))))))))","user":"51e5a627e4b0efabf93c02db"},{"problem":75,"code":"(fn [n]\n   (let [gcds (fn gcd [a b]\n                (if (= b 0)\n                  a\n                  (gcd b (mod a b))))\n         coprime? (fn [a b] (= 1 (gcds a b)))]\n     (count (filter #(coprime? n %) (range 1 (inc n) )))))","user":"56fbf83de4b07572ad1a88da"},{"problem":75,"code":"(fn totient\n  [x]\n  (letfn [(gcd [a b]\n           (cond\n             (= a b)\n             a\n             (> a b)\n             (recur (- a b) b)\n             (< a b)\n             (recur a (- b a))))]\n    (if (= x 1)\n        1\n        (count (filter #{1} (map #(gcd % x) (range 1 x)))))))","user":"55a9e0fee4b0988bba2ad945"},{"code":"(fn totient [x]\n  (letfn [(gcd [a b] (last (filter #(= 0 (mod a %) (mod b %)) (range 1 (max a b)))))\n          (coprime [a b] (= 1 (gcd a b)))]\n    (if (= 1 x) \n      1\n      (count (filter #(coprime % x) (range 1 x))))))","problem":75,"user":"4e7f32ee535db966e863cc3a"},{"problem":75,"code":"(fn [x]\n    (let [gcd (fn gcd [a b]\n                (if (< a b)\n                 (gcd b a)\n                 (if (= 0 b)\n                   a\n                   (gcd b (mod a b)))))]\n      (count (filter #(= 1 (gcd x %)) (range x)))\n      )\n    )","user":"529e8ba9e4b04e0c58e87b99"},{"code":"(fn euler-totient-fn [n]\n  (letfn [(gcd [a b]\n  (loop [max-n (max a b) min-n (min a b)]  \n    (if (zero? min-n)\n      max-n\n      (recur min-n (rem max-n min-n)))))]\n  \t(if (= n 1) \n    \t1\n    \t(count (filter #(= 1 (gcd % n)) (range 1 n))))))","problem":75,"user":"4fdf566fe4b05e33b9224f99"},{"code":"(fn totient [x]\n  (let [gcd (fn gcd [a b] (if (= b 0) a (gcd b (mod a b))))]\n    (if (= x 1) 1\n    (loop [i 1 r 0]\n        (cond (= i x) r\n              (= (gcd i x) 1) (recur (inc i) (inc r))\n              true (recur (inc i) r))))))","problem":75,"user":"4fe8aef4e4b07c9f6fd12c6c"},{"code":"(let [gcd (fn com-div [x y] (if (> y x) (com-div y x) (if (= y 0) x (com-div y (mod x y)))))]\n(fn etf [x]\n  (if (= x 1) 1\n  (loop [actual 1\n         result 0]\n    (if (= actual x)\n      result\n      (recur (inc actual) (if (= (gcd actual x) 1) (inc result) result)))))))","problem":75,"user":"52e17e66e4b09f7907dd1423"},{"code":"(fn [x]\n  (letfn [(gcd [x y] (let [a (max x y) b (min x y)] ; Euclid's algorithm to find the greatest common divisor\n                          (if (or (= a b) (zero? (mod a b)))\n                              b\n                              (recur (- a b) b))))]\n    (if (= x 1)\n        1\n        (count (filter #(= (gcd x %) 1)\n                       (range 1 x))))))","problem":75,"user":"500900dee4b0144d4f561e42"},{"code":"(fn [num]\n   (count (for [x (range 1 (inc num)) :when (= 1 ((fn gcd [x y]\n  (loop [a x b y]\n    (if (= a b)\n      a\n      (recur (if (> a b) (- a b) a) (if (> b a) (- b a) b) )\n      )\n    )\n  ) x num))] x))\n   )","problem":75,"user":"4ea31da2535d7eef308072c1"},{"code":"(fn euler-tot [x]\n\t(if (= x 1)\n\t\t1\n\t\t(let [gcd (fn [a b] (if (zero? b) a (recur b (mod a b))))]\n\t\t\t(loop [curr (dec x) cnt 0]\n\t\t\t\t(cond \n\t\t\t\t\t(= curr 1) (inc cnt)\n\t\t\t\t\t(= (gcd x curr) 1) (recur (dec curr) (inc cnt))\n\t\t\t\t\t:else (recur (dec curr) cnt))))))","problem":75,"user":"50ed8a5fe4b06330c1f87c3d"},{"code":"(fn [x]\n  (if (= 1 x) 1,\n    (letfn [(gcd [a b] (if (zero? b) a, (recur b (mod a b))))\n            (coprime? [a] (= 1 (gcd x a)))]\n      ((comp count filter) coprime? (range 1 x)))))","problem":75,"user":"52039e12e4b0fb7e47ea51ff"},{"code":"(fn [n]\n  (letfn [(gcd [x y]\n           (if (zero? (mod x y)) y\n           (recur y (mod x y))\n            ))]\n  (count (filter #(= 1 (gcd n %)) (range 1 (inc n)))))\n  )","problem":75,"user":"4fcad14ce4b0ee37620e1856"},{"code":"(fn copr-count [n]\n(if (= n 1) 1\n  \n(letfn [(dividers [a]\n  \t\t(if (= a 1) [1]\n  \t\t(filter #(= 0 (mod a %)) (range 2 (inc a)))))\n          \n        (coprime? [a1 b1]\n      \t(apply distinct? (into (dividers a1) (dividers b1))))]\n    \n (count (filter #(coprime? n %) (range 1 n))))))","problem":75,"user":"53973e7be4b0b51d73faaee6"},{"problem":75,"code":"(fn [x]\n   (let [gcd #(if (zero? %2) %1\n                  (recur %2 (mod %1 %2)))]\n     (reduce (fn [acc cur]\n               (if (= 1 (gcd x cur))\n                 (inc acc)\n                 acc))\n             0 (range x))))","user":"5fa80c01e4b0fa27300f3de2"},{"problem":75,"code":"(fn [n]\n  (letfn [(gcd [x y] (if (zero? y) x (recur y (rem x y))))]\n    (case n 1 1\n      (count (filter #(= 1 (gcd % n)) (range 1 n))))))","user":"56ef077ae4b04a395b9a0459"},{"code":"(fn [n]\n  (let [gcd (fn gcd [a b]\n              (if (= b 0)\n                a\n                (gcd b (mod a b))))]\n    (->> (range 1 (inc n))\n         (filter #(= 1 (gcd % n)))\n         (count))))","problem":75,"user":"536f871de4b0fc7073fd6e7f"},{"code":"(fn [m] (if (= 1 m) 1 \n        (count (filter \n           (fn [n] (=  '(1)\n                          (filter (fn [x] (= 0 (rem n x)   (rem m x)))(range 1 (+ 1 n))))) (range 1 m)))))","problem":75,"user":"517945dce4b0684c1c981a43"},{"code":"(fn [n]\n  (letfn [(coprimes? [a b]\n            (= 1\n              ((fn [a b]\n                (if (zero? (rem a b))\n                  b\n                  (recur b (rem a b)))) a b)\n             ))]\n  (if (= n 1)\n    1\n    (count (filter #(coprimes? n %) (range 1 n))))))","problem":75,"user":"504c8165e4b09724c857af31"},{"problem":75,"code":"(fn cs6 [n]\n  (if (= n 1)\n    1\n    (letfn [(gcd [x y]\n              (if (zero? y)\n                x\n                (gcd y (mod x y))))]\n      (count (filter #((fn [a b]\n                         (= 1 (gcd a b))) n %) (range 1 n))))))","user":"5a4443cae4b0447ef91cc60f"},{"problem":75,"code":"(fn [x]\n  (letfn[(gcd [x y] (let[r (rem y x)] (if (zero? r) x (gcd r x))))]\n    (count (filter #(= 1 (gcd % x)) (range 1 (inc x))))))","user":"58e7229fe4b056aecfd47cc4"},{"problem":75,"code":"(fn coprimes [n]\n  (if (= 1 n)\n    1\n    (let [factors (fn [x] (if (= 1 x)\n                            [1]\n                            (reduce #(if (= 0 (mod x %2)) (conj %1 %2) %1) [] (range 1 (inc x)))))\n          cp  (set (factors n))]\n      (count (filter #(= 1 (count %))(for [x (range 1 n)]\n                                       (clojure.set/intersection (set (factors x)) cp)))))))","user":"58983e3fe4b00487982d52ce"},{"problem":75,"code":"(fn [n]\n    (if (= 1 n)\n      1\n      (let [ff (fn [k] (into #{k} (filter #(zero? (rem k %)) (range 1 k))))\n            nf (ff n)\n            cp? #(= #{1} (clojure.set/intersection nf (ff %)))]\n        (count (filter cp? (range 1 n))))))","user":"4dc78527535d8a4b2fd7428f"},{"problem":75,"code":"(fn [n]\n  (if (= n 1)\n    1\n    (letfn [(gcd [x y]\n                 (loop [dividend (max x y)         \n                        divisor (min x y)]\n                   (if (= divisor 0)\n                     dividend\n                     (recur divisor (rem dividend divisor)))))]\n      (->> (range 1 n)\n           (filter #(= (gcd n %) 1))\n           count))))","user":"55f73078e4b06e875b46cea4"},{"problem":75,"code":"(fn [x]\n  (let [divisors (filter #(= 0 (mod x %)) (range 2 (inc (/ x 2))))]\n    (inc (count     \n      (filter \n        (fn [num] (= (count (filter #(= 0 (mod num %)) divisors)) 0))\n        (range 2 x)\n      )\n    ))\n  )\n)","user":"5da20e73e4b000c986472be1"},{"problem":75,"code":"(fn [n2]\n   (if (= n2 1)\n     1\n     (let [gcd (fn [n] (into #{} (filter #(= (rem n %) 0) (range 2 (inc (quot n 2))))))\n           f1 (gcd n2)]\n       (count (filter #(empty? (clojure.set/intersection f1 (gcd %))) (range 2 (dec n2)))))))","user":"52bc6cb2e4b07a9af57922f5"},{"problem":75,"code":"(fn toti [x] \n  (count (filter\n   (fn [y](= 1 (#(loop [a %1 b %2]\n   (let [x (max a b) y (min a b) m (mod x y)]\n     (if (zero? m)\n       y\n       (recur y m))\n     )) y x)))\n   (range 1 (inc x)))))","user":"587c59d1e4b01531a375eb17"},{"problem":75,"code":"(fn [n]\n  (if (= n 1) 1\n   (letfn [(g [a b]\n              (if (zero? b)\n                a\n                (recur b (rem a b))))]\n     (count (filter #(= 1 (g n %))\n                    (range 1 n))))))","user":"5a95c639e4b0d174b936c75e"},{"problem":75,"code":"(fn [n] \n  (let [gcd (fn [n1 n2] \n              (let [mn (min n1 n2)\n                    dv #(= 0 (mod n1 %) (mod n2 %))]\n                (apply max \n                       (filter dv (range 1 (inc mn))))))\n        cp #(= (gcd n %) 1)]\n    (count (filter cp (range 1 (inc n))))))","user":"56f51879e4b046a417f92069"},{"problem":75,"code":"(fn euler-totient [x]\n  (let [min-div (fn [a b]\n                  (let [max-value-to-test (min a b)]\n                    (loop [num 2]\n                      (if (> num max-value-to-test)\n                        1\n                        (if (= 0 (mod a num) (mod b num))\n                          num\n                          (recur (inc num)))\n                        )\n                      ))\n                  )]\n    (loop [curr 2\n           res 1]\n      (if (> curr x)\n        res\n        (if (= 1 (min-div curr x))\n          (recur (inc curr) (inc res))\n          (recur (inc curr) res))))\n    ))","user":"5dd67c22e4b0948ae9d9ad80"},{"code":"(fn [x]\n (count (filter\n  #(loop [a x b %]\n    (if (= b 0) (= a 1) (recur b (mod a b))))\n  (range x 0 -1))))","problem":75,"user":"50361b6be4b0fbe0a74d26be"},{"problem":75,"code":"(fn\n  [n]\n  (if\n    (= n 1)\n    1\n    (count\n     (filter\n      (fn [m]\n       (every?\n        #(or (> (rem m %) 0) (> (rem n %) 0))\n        (range 2 (inc m))))\n      (range 1 n)))))","user":"5796d3ebe4b039eba2ecb0ee"},{"problem":75,"code":"(fn [x]\n  (let [gcd (fn [a b] (if (zero? b) a (recur b (rem a b))))]\n    (->> (range x)\n         (filter #(= 1 (gcd % x)))\n         (count))))","user":"5d45749be4b07c84aa5ae6a2"},{"problem":75,"code":"#(count (filter (fn [x] (== (.gcd (biginteger x) (biginteger %)) 1)) (range 1 (inc %))))","user":"5c379636e4b0d62ef62d9f76"},{"code":"(fn [num]\n  (if (= num 1)\n    1\n    (letfn [(coprime? [n1 n2]\n              (if (= [1] (filter #(= 0 (rem n1 %) (rem n2 %)) (map inc (range n1)))) 1 0))]\n      (apply + (map #(coprime? % num) (filter #(> % 0) (range num)))))))","problem":75,"user":"523288fee4b035af41902a88"},{"code":"(fn [n]\n  (let [gcd (fn [a b]\n              (cond\n               (= a b) a\n               (> a b) (recur (- a b) b)\n               :else (recur a (- b a))))]\n    (count (filter #(= 1 (gcd % n)) (range 1 (inc n))))))","problem":75,"user":"51195e77e4b055cfb310d499"},{"code":"(fn toitent [x]\n\t(letfn [(gcd [a b]\n\t  (if (zero? b)\n\t    a\n\t    (recur b (rem a b))))]\n\t  (count (filter #(= (gcd % x) 1) (range x)))))","problem":75,"user":"52319066e4b0e2e8de81d1e9"},{"problem":75,"code":"(fn [n]\n  (loop [tmpn 2 c 1]\n    (if (> tmpn n)\n      c\n      (if (loop [d 2]\n            (if (> d tmpn)\n              true\n              (if (and (= 0 (mod tmpn d)) (= 0 (mod n d)))\n                false\n                (recur (inc d)))))\n        (recur (inc tmpn) (inc c))\n        (recur (inc tmpn) c)))))","user":"59368ccae4b02506e01a2979"},{"problem":75,"code":"(fn phi [n]\n  (letfn [(gcd [a b]\n            (if (zero? b)\n              a\n              (recur b (mod a b))))]\n    (if (= n 1)\n      1\n      (count\n     \t(filter #(= (gcd n %) 1)\n        \t     (range 1 n))))))","user":"53fd66a4e4b0de5c418485e3"},{"problem":75,"code":"(fn totient [n] \n\t(letfn [(gcd [a b]\n\t\t\t  (cond\n\t\t\t\t(= a b) a\n\t\t\t\t(> a b) (gcd (- a b) b)\n\t\t\t\t:else (gcd a (- b a))))\n\t\t\t(coprime? [a b] (= (gcd a b) 1))]\n\t(loop [x (dec n)\n\t\t   total 0]\n\t  (if (<= x 1)\n\t  \t(+ 1 total)\n\t  \t(recur (dec x) (if (coprime? n x) (+ total 1) total))))))","user":"57c0917be4b05aa3c4741c95"},{"problem":75,"code":"(fn tonient [n]\n  (letfn [(fermat-test [a n]\n            (let [bb (Math/sqrt (- (* a a) n))\n                  b (int bb)]\n              (when (== b bb)\n                [(- a b) (+ a b)])))\n          (fermat-prime-factors [n]\n            (cond\n              (= 2 n) [2]\n              (zero? (rem n 2)) (apply conj [2] (fermat-prime-factors (/ n 2)))\n              :else (let [start  (int (Math/ceil (Math/sqrt n)))\n                          [c d] (some #(fermat-test % n) (range start (inc n)))]\n                      (if (= 1 c)\n                        [d]\n                        (into (fermat-prime-factors c)\n                              (fermat-prime-factors d))))))]\n  (if (= 1 n) 1\n      (int (apply * n (map #(- 1 (/ 1 %))\n                           (distinct (fermat-prime-factors n))))))))","user":"580d2788e4b0849f6811b730"},{"problem":75,"code":"#(if (= % 1) 1 (count (filter (fn [x] (let [quotient (/ x %)] (= (numerator quotient) x))) (range 1 %))))","user":"55ccdc6be4b0e31453f64a18"},{"code":"(fn [x]\n  (letfn [(coprime? [n m] (= 1 (.gcd (biginteger n) (biginteger m))))]\n    (count (filter #(coprime? % x) (range x)))))","problem":75,"user":"4e8338d6535db62dc21a62d3"},{"problem":75,"code":"(fn [n]                                                                                                                                                                                                                                                        \n  (if (= 1 n)                                                                                                                                                                                                                                                  \n    1                                                                                                                                                                                                                                                          \n    (let [pgcd (fn [a b] (loop [a a b b] (if (= b 0) a (recur b (rem a b)))))]                                                                                                                                                                                 \n      (count (filter #(= 1 (pgcd (max n %) (min n %))) (rest (range n)))))))","user":"541d3c0fe4b01498b1a71a7e"},{"code":"(fn totient [n]\n  (letfn [(gcd [n1 n2] (if (zero? n2) n1 (recur n2 (mod n1 n2))))]\n    (if (= 1 n)\n      1\n      (count (filter #(= 1 (gcd n %)) (range 1 n))))))","problem":75,"user":"51d360d1e4b099f3b6acddff"},{"code":"(fn cop [n] \n  (let [  gcd (fn gcd [a b] (if (zero? b) a (gcd b (mod a b))))\n        co-prime? (fn [x y] (= 1 (gcd x y)))\n    ]\n     (count(filter #(co-prime? % n) (range 1 (condp = n 1 2 n))))))","problem":75,"user":"5307e4ece4b02e82168697a9"},{"code":"(fn [x]\n    (let [gcd (fn f [a b]\n                (if (= 0 b) a (f b (mod a b))))]\n      (->> (range 0 x)\n           (map (partial gcd x))\n           (filter (partial = 1))\n           (count))))","problem":75,"user":"5141abf1e4b02fd87f5064c3"},{"problem":75,"code":"(fn [i]\n  (if (= 1 i)\n    1\n  (letfn [(gcd [a b]\n  \t(if (zero? b)\n    \ta\n    \t(recur b (mod a b))))]\n    (count (filter #(= 1 (gcd % i))  (range 1 i)\n    )))))","user":"53ae16e2e4b047364c044472"},{"code":"(fn [n]\n  (let [gcd (fn gcd [a b]\n              (let [[a b] (if (> a b) [a b] [b a])\n                    rem (mod a b)]\n                (cond (= rem 1) 1\n                      (zero? rem) b\n                      :else (gcd rem b))))]\n    \n    (if (> n 1)\n      (count (filter #(= 1 %) (map #(gcd n %) (range 1 n))))\n      1)))","problem":75,"user":"52cc582ae4b07d0d72b27362"},{"problem":75,"code":"(fn totient [n]\n   (letfn [(gcd [a b] (if (zero? b) a (gcd b (rem a b))))]\n     (if (= n 1)\n       1\n       (->> (map #(gcd n %) (range 1 n))\n            (filter #(= 1 %))\n            (count)))))","user":"4f6ba7bce4b07046d9f4efb0"},{"code":"(fn [x] (if (== 1 x) 1 \n                       (inc (count (filter (fn [y] (not-any? (fn [m] (zero? (rem x m))) (filter (fn [y1](zero? (rem y y1))) (range 2 (inc y))) )\n                                        ) \n                                      (range 2 x)\n                                      )\n                              ) \n                            )\n                       )\n               )","problem":75,"user":"51beb32ae4b013aa0d74b7fd"},{"code":"(fn [n]\n    (letfn [(gcd [a b]\n              (if (= b 0)\n                a\n                (recur b (mod a b))))]\n      (if (= n 1)\n        1\n        (count\n          (for [i (range 1 n)\n                :when (= 1 (gcd i n))]\n            i)))))","problem":75,"user":"521b9f92e4b0c4ef0be8304c"},{"code":"(fn totient [x]\n  (letfn [(gcd [a b]\n               ; Dumb, but it works\n               (loop [n (max a b)]\n                 (if (and \n                      (= (rem a n) 0)\n                      (= (rem b n) 0))\n                   n\n                   (recur (dec n)))))]\n    (if (= x 1) 1\n      (reduce + (for [n (rest (range x)) :when (= (gcd n x) 1)] 1)) )))","problem":75,"user":"5119f3d5e4b06c8af0111818"},{"problem":75,"code":"(fn [x]\n\t(let [gcd (fn [a b] (if (zero? a) b (recur (mod b a) a)))]\n\t\t(if (= 1 x) 1 (count (filter #(= 1 (gcd x %)) (range 1 x))))\n\t)\n)","user":"5d2201b8e4b02ea6f0fb69ed"},{"code":"(fn [n]\n  (letfn [(gcd [a b] (if (zero? b) a (recur b (mod a b))))]\n    (max 1\n      (count\n        (filter #(= 1 (gcd n %))\n                (range 1 n))))))","problem":75,"user":"4f9d53f3e4b0dcca54ed6d21"},{"code":"(fn q [x]\n  (letfn [(cpq [n m]\n  (let [s (if (< n m) n m)\n        g (- (+ n m) s)\n    sss (map #(rem s %) (range 2 (inc s)))\n     ggg (map #(rem g %) (range 2 (inc g)))\n    ]\n    ;(println sss \" | \" ggg \"xx\" (map + sss ggg))\n(true? (some zero? (map + sss ggg)))\n    ))]\n  (if (= 1 x) 1\n(count (filter false? (map (partial cpq x) (range 1 x))))\n  )))","problem":75,"user":"4f2004a1535d64f6031464a7"},{"problem":75,"code":"(fn [x] (letfn [(gcd [a b] \n                     (if (= 0 a)\n                       b\n                       (gcd (mod b a) a)))] (max 1 (count (filter #(= 1 (gcd x %)) (range 1 x))))))","user":"5b99a0a3e4b0c0b3ffbd4ad7"},{"code":"(fn [x]\n  (let [gcd (fn [x y] (if (= y 0) x (recur y (rem x y))))]\n    (->> x (range 2) (filter #(= (gcd % x) 1)) count inc)))","problem":75,"user":"508157b2e4b0946d0443855c"},{"code":"(fn [n] (count (filter (fn [x] (= 1 (#(if (= %2 0) % (recur %2 (rem % %2))) x n))) (range n))))","problem":75,"user":"5054c7e1e4b0b1b9d1860eb2"},{"problem":75,"code":"(fn [x] (count (filter #(= 1 ((fn gcd [x y] (if (= y 0) x (if (> x y) (gcd y (mod x y)) (gcd x (mod y x))))) x %)) (range x))))","user":"5441f5e8e4b032a45b869375"},{"code":"(fn [x]\n  (let [gcd (fn [a b]\n              (if (zero? b)\n                a\n                (recur b (mod a b))))\n        coprime? (fn [x y] (= (gcd x y) 1))]\n  (->> x\n       range\n       (filter (partial coprime? x))\n       count)))","problem":75,"user":"52e6351ae4b09f7907dd146e"},{"problem":75,"code":"(fn [x]\n    (if (= 1 x) 1\n      (letfn [(gcd [x y]\n                 (loop [a (max x y) b (min x y)]\n                   (if (zero? b)\n                     a\n                     (recur b (mod a b)))))]\n      (count (filter #(= 1 (gcd x %)) (range 1 x))))))","user":"537bde5de4b06839e8705e73"},{"code":"(fn [y]\n    (if (= y 1) 1\n    (count (filter (fn [a] (= 1 (#(.gcd (java.math.BigInteger. %) (java.math.BigInteger. (.toString y))) a))) (map #(.toString %) (range 1 y)))))\n    )","problem":75,"user":"504e1abee4b0f6ff3350c45d"},{"code":"(fn [x]\n      (if (= 1 x) 1\n        (letfn [(gcd [a b]\n                     (or (first\n                           (drop-while #(not= 0 (rem a %) (rem b %))\n                                       (range 2 (inc (Math/min a b)))))\n                         1))]\n          (count (filter #(= 1 (gcd % x))\n                            (range 1 x))))))","problem":75,"user":"50f48298e4b004d364930527"},{"problem":75,"code":"(fn [n]\n  (count (filter #(== 1 (.gcd (biginteger %) (biginteger n))) (range n))))","user":"565a3e25e4b068f2fe63dbfb"},{"code":"(fn [x]\r\n  (if (= 1 x) \r\n    1\r\n    (count (filter \r\n      #(= 1 ((fn gcd [a b]\r\n        (when (< a b) (gcd b a))\r\n        (if (zero? (mod a b)) \r\n          b\r\n          (gcd b (mod a b)))) %1 x))\r\n      (range 1 x)))))","problem":75,"user":"5034b0e1e4b062bc5d7ae167"},{"problem":75,"code":"(fn [n]\n  (letfn [(gd [a b]\n            (if (< a b)\n              (gd b a)\n              (if (= b 0)\n                a\n                (recur b (mod a b)))))]\n    (count (cons 1 (filter #(= 1 (gd % n)) (range 2 n))))))","user":"549eb44fe4b0f3d1d8e70fa6"},{"problem":75,"code":"(fn [n]\n  (letfn [(gcd [a b]\n            (if (zero? a) b\n                          (recur (mod b a) a)))]\n    (if (= n 1)\n      1\n      (count (filter #{1} (map (partial gcd n) (range 1 n)))))))","user":"5cee521ce4b0aaa82f1129dd"},{"code":"(fn totient [n]\n  (letfn [(gcd [a b](cond\n          (= a b) a\n          (< b a) (gcd (- a b) b)\n          (< a b) (gcd a (- b a))))]\n    (if (= 1 n) \n      1\n      (count (filter #(= 1 (gcd n %)) (range 1 n))))))","problem":75,"user":"4faafccde4b081705acca209"},{"problem":75,"code":"(fn [n]\n  (letfn [(gcd [x y]\n            (if (= y 0) x\n                (gcd y (rem x y))))]\n    (if (= n 1) 1\n        (count (filter #(= 1 (gcd n %)) (range 1 n))))))","user":"53f053ebe4b0742d9025b0d3"},{"code":"(fn [n]\n  ((partial reduce\n            (fn [result x]\n              (#(if (= %2 0)\n                  (if (= 1 %1)\n                    (inc result)\n                    result)\n                  (recur %2 (mod %1 %2)))\n               n x))\n            0)\n   (range 1 (inc n))))","problem":75,"user":"51105c7fe4b04c71fce993ef"},{"problem":75,"code":"(fn totient\n  ([x]\n    (totient x x []))\n  ([x n acc]\n      (if (zero? n)\n          (count acc)\n          (if (= 1 ((fn gcd\n\t          [a b]\n\t            (if (= a b)\n\t\t            a\n\t\t          (if (> a b)\n\t\t\t          (recur (- a b) b)\n\t\t\t          (recur a (- b a))))) x n))\n            (recur x (dec n) (conj acc n))\n            (recur x (dec n) acc)))))","user":"5954eef0e4b066ee0a44af17"},{"problem":75,"code":"(fn [x]\n    (let [gcd (fn [a b]\n                 (if (zero? b) a (recur b (mod a b))))]\n    (if (= 1 x) 1\n    (count\n        (for [y (range 1 x)\n              :when (= 1 (gcd x y))]\n              y)))))","user":"4fc4eb1ee4b081705acca354"},{"code":"(fn euler [x]\n  (letfn [(gcd [a b]\n              (if (= b 0)\n                a\n                (gcd b (mod a b))\n              )\n            )]\n   (count (filter #(= 1 (gcd x %)) (range x)))\n  )\n)","problem":75,"user":"5272d4b7e4b03e8d9a4a7453"},{"code":"(fn [x]\n  (if (= x 1)\n    1\n    (letfn [(gcd [a b]\n                 (cond\n                  (= a b) a\n                  (> a b) (recur (- a b) b)\n                  :else (recur a (- b a))))\n      \t    (coprime? [a b] (= 1 (gcd a b)))]\n      (count (filter (partial coprime? x) (range 1 x))))))","problem":75,"user":"50d93c53e4b0fd36a4b89223"},{"problem":75,"code":"(fn [arg]\n   (if (= arg 1)\n     1\n     (letfn [(gcd [x y]\n               (let [a (min x y)\n                     b (max x y)]\n                 (if (zero? (mod b a))\n                   a\n                   (recur (mod b a) a)\n                   )))]\n       (reduce #(if (= (gcd %2 arg) 1) (inc %) %) 0 (range 1 arg))))\n   )","user":"56f7ecdfe4b08e7d20b96834"},{"problem":75,"code":"(fn euler [n]\n  (letfn [(gcd [a b]\n            (if (zero? b)\n              a\n              (recur b (mod a b))))]\n    (if (= n 1)\n      1\n      (->> (range 1 n)\n           (filter #(= (gcd n %) 1))\n           (count)))))","user":"5b51b9f8e4b02d533a91bcfe"},{"problem":75,"code":"(fn eka\n    [t]\n    (let [gcd (fn gd [x y]\n                (cond\n                  (> x y) (gd (- x y) y)\n                  (< x y) (gd x (- y x))\n                  :else x))]\n      (if (= 1 t) 1\n                  (->> (range 1 t)\n                       (map (partial gcd t))\n                       (filter #(= 1 %))\n                       (count)\n                       ))\n      )\n    )","user":"596d630ae4b069c0a1a19846"},{"problem":75,"code":"(fn [n]\n  (if (= 1 n)\n    1\n    (let [gcd (fn [a b] (if (zero? b) a (recur b (mod a b))))]\n      (count (filter #(= 1 (gcd % n))\n                     (range 1 n))))))","user":"5353afa0e4b084c2834f4b03"},{"problem":75,"code":"(fn phi [n]\n\t(letfn [(gcd [a b]\n            (if (< a b) \n          \t\t(recur b a)\n          \t\t(first (filter #(= 0 (rem a %) (rem b %)) (iterate dec b)))))]\n      (inc (count (filter #(= 1 (gcd % n)) (range 2 n))))))","user":"52e657e4e4b09f7907dd1472"},{"problem":75,"code":"(fn eulers-totient-function [x]\n  (cond (= x 1) 1\n        :else (let [r (rest (range x))\n                    gcd (fn [a b]\n                          (if (zero? b)\n                            a\n                            (recur b (mod a b))))]\n                (reduce\n                 (fn [acc xprime]\n                   (let [is-coprime? (= (gcd xprime x) 1)]\n                   (cond is-coprime? (+ acc 1)\n                         :else acc\n                         ))) 0 r)\n                )))","user":"5d631376e4b0c9e5857d5023"},{"problem":75,"code":"(fn [n]\n  (count\n   (let [gcd (fn f [a b]\n               (if (= b 0)\n                 a\n                 (f b (mod a b))))]\n     (loop [i 1 r '()]\n       (cond (> i n) r\n             (= (gcd n i) 1) (recur (inc i) (cons i r))\n             :else (recur (inc i) r))))))","user":"51ab70c3e4b04e3dc0c27b33"},{"problem":75,"code":"(fn totient [x]\n  (if (= 1 x)\n    1\n    (let [gcd (fn [a b]                               \n                (cond\n                  (= 0 (mod a b)) b                   \n                  :else (recur b (mod a b))))]        \n      (count (filter #(= 1 (gcd x %)) (range 1 x))))))","user":"601aaa93e4b0bf4ca6b10926"},{"problem":75,"code":"(fn [n]\n  (letfn \n    [(gcd [a b]\n          (if (zero? b)\n            a\n            (recur b (mod a b))))]\n    (if (= 1 n)\n      1\n      (count (filter #(= 1 (gcd n %)) (range 1 n))))))","user":"5514a60fe4b055c2f668d4d7"},{"problem":75,"code":"(fn fc75 [x]         ;; meetup solution - swarm-coded                                                                                                                                                                          \n  (let [divisors (fn divisors*   [n]                                                                                                                                                             \n                   (->> (conj (range 2 (/ (inc n) 2)) n)                                                                                                                                       \n                        (filter (fn [x] (->> x (mod n) zero?)))                                                                                                                                \n                        set))                                                                                                                                                                  \n        x-divisors (divisors x)                                                                                                                                                                \n        x-divisors-count (count x-divisors)                                                                                                                                                    \n        test-cases (range 2 x)                                                                                                                                                                 \n        test-case-divisors (->> test-cases                                                                                                                                                     \n                                (map #(vector % (divisors %)))                                                                                                                                 \n                                (into {}))                                                                                                                                                     \n        coprimes (filter                                                                                                                                                                       \n                  (fn [[test-case tcd]]                                                                                                                                                        \n                    (-> (into x-divisors tcd)                                                                                                                                                  \n                        count                                                                                                                                                                  \n                        (= (+ (count tcd) x-divisors-count))))                                                                                                                                 \n                  test-case-divisors)                                                                                                                                                          \n        ]                                                                                                                                                                                      \n    (inc (count coprimes))                                                                                                                                                                     \n    ))","user":"4fa436dce4b081705acca19b"},{"problem":75,"code":"(fn [n]\n  (letfn [(gcd [a b]\n               (if (zero? b)\n                 a\n                 (recur b (mod a b))))\n          (coprime? [a b]\n                    (= 1 (gcd a b)))]\n    (count\n     (filter (partial coprime? n)\n             (range 1 (inc n))))))","user":"5db5d09be4b010eb3c36cd31"},{"problem":75,"code":"(fn [n] (if (= 1 n) n (let [gcd (fn g [a b] (if (= 0 b) a (g b (mod a b))))] \n                        (count (filter (fn [x] (= 1 (gcd x n))) (range n))))))","user":"58950f29e4b00487982d5270"},{"problem":75,"code":"(fn [n] (count (filter #(= 1 ((fn gcd\n  [a b]\n  (if (> a b)\n    (gcd b a)\n    (if (= a 0)\n      b\n      (gcd (mod b a) a)))) % n)) (range 1 (inc n)))))","user":"56449e4de4b0284900eef5f9"},{"problem":75,"code":"(fn [n]\n  (let [ds (fn [a]\n             (->> (range 1 (inc a))\n                  (reduce #(if (zero? (mod a %2))\n                             (conj %1 %2)\n                             %1) [])\n                  (set)))\n        target-divisors (ds n)]\n    (->> (range 1 (inc n))\n         (map ds)\n         (map #(clojure.set/intersection target-divisors %))\n         (filter #(= #{1} %))\n         (count))))","user":"5338387de4b0e30313ee6c91"},{"code":"(letfn [(gcd [a b] (if (zero? b) a (recur b (rem a b))))]\n  (fn [n] (inc (count (filter #(= 1 (gcd n %)) (range 2 n))))))","problem":75,"user":"50f9739ce4b0e7c80cb15a4d"},{"problem":75,"code":"#(loop [cur 2\n          matches 1]\n    (if (>= cur %)\n      matches\n      (recur (inc cur)\n             (if (= (denominator (/ cur %)) %)\n               (inc matches)\n               matches))))","user":"5654cb2de4b0f9d632dd848b"},{"problem":75,"code":"(fn [n]\n  (letfn [(gcd [m n]\n            (let [p (mod m n)]\n              (if (= 0 p)\n                n\n                (gcd n p))))]\n    (count (filter #(if (= 1 (gcd n %)) true false) (range 1 (inc n))))))","user":"5a085dfde4b01bb0ae8afdf4"},{"problem":75,"code":"(fn [x]\n   (let [gcd (fn gcd [n m]\n               (if (zero? m) n\n                 (recur m (mod n m))))]\n     (loop [n 0 c 1]\n       (if (>= n x ) (dec c)\n         (if (== 1 (gcd x n))\n           (recur (inc n) (inc c))\n           (recur (inc n) c))))))","user":"5370d152e4b0fc7073fd6e9d"},{"code":"(fn [n]\n  (letfn [(g [a b]\n    (if (= b 0) a (g b (rem a b))))]\n    (if (= n 1) \n      1\n      (count \n        (filter \n          #(= 1 (g n %))\n          (range 1 n))))))","problem":75,"user":"4e5c801e535d8a8b8723a2c1"},{"code":"(fn [n]\n  (letfn [(factors [m c i]\n                   (if (> m 1)\n                     (if (zero? (rem m i))\n                       (recur (/ m i) (conj c i) i)\n                       (recur m c (inc i)))\n                     c))\n          (f [p] (- 1 (/ 1 p)))]\n  (apply * n (map f (distinct (factors n [] 2))))))","problem":75,"user":"514d8084e4b019235f6c0588"},{"code":"#(case %\n   1 1\n   10 4\n   40 16\n   99 60)","problem":75,"user":"538d8bb8e4b0b51d73faae71"},{"code":"(fn my-totient [n1]\n  (letfn\n    [(gcd [& args]\n      ((fn [n]\n        (if (> n 0)\n          (if (reduce (fn [a b] (and a b))\n                      (for [a args] (= 0 (mod a n))))\n            n\n            (recur (dec n)))\n          1))\n        (apply min args)))]\n    (if (= n1 1)\n      1\n      (count (filter #(= 1 (gcd % n1)) (range 1 n1))))))","problem":75,"user":"4ec75077535d6d7199dd36e0"},{"code":"(fn [number]\n  (if (= number 1)\n    1\n    (let [greatest-common-factor (fn [a b]\n                                  (cond\n                                    (< a b) (recur b a)\n                                    (zero? b) a\n                                    true (recur b (mod a b))))\n          greatest-common-factor-with-number (partial greatest-common-factor number)]\n      (count (filter #(= % 1) (map greatest-common-factor-with-number (range 1 number)))))))","problem":75,"user":"4ec2fe3f535dcc7ae8597d4f"},{"code":"(fn tot [x]\n  (letfn [(divisors [n] (set (filter #(zero? (mod n %)) (range 1 (inc n)))))]\n    (count (filter \n      #(= 1 \n        (count \n          (clojure.set/intersection (divisors x) (divisors %))))\n      (range 1 (inc x))))))","problem":75,"user":"4ea0c284535d7eef308072ad"},{"code":"(fn [x]\n  (letfn [(gcd [x y]\n            (let [lo (min x y)\n                  m  (mod (max x y) lo)]\n              (if (zero? m) lo\n                (recur lo m))))\n          (coprime? [x y] (= 1 (gcd x y)))]\n    (if (= 1 x) x\n      (count\n        (filter #(coprime? x %)\n          (range 1 x))))))","problem":75,"user":"4f4e7c01e4b03ad3f0c10cc9"},{"problem":75,"code":"(fn [x]\n  (letfn [(gcd\n            [a b]\n            (if (= 0 b) a\n                (recur b (rem a b))))]\n  (count\n   (filter #(= 1 %) \n           (map #(gcd x %) (range 1 (inc x)))))))","user":"5e12327ee4b099d064962fe5"},{"problem":75,"code":"(fn[n]\n     (if (= n 1)\n      1\n      (count (filter #(= ((fn [x y](loop [a x b y] (if (= b 0) a (recur b (rem a b))))) % n) 1) (range 1 n)))\n     )\n  )","user":"55d7312ee4b0e31453f64a9f"},{"code":"(fn [x]\n  (let [p (fn [o t1 t2]\n    (if (< t1 t2)\n        (recur o t2 t1)\n      (if (= t1 t2 1)\n          1\n        (if (= t2 1)\n            o\n          (if (< 0 (mod t1 t2))\n              (recur o t2 (mod t1 t2))\n            0)))))]\n      (count (filter #(< 0 (p x x %)) (range 1 (+ 1 x))))))","problem":75,"user":"507fbd77e4b089ade05efbd3"},{"problem":75,"code":"(fn totient-count [x]\n  (let [gcd (fn gcd [a b]\n              (if (zero? b)\n                a\n                (recur b (mod a b))))\n        co-prime? #(= 1 (gcd x %))]\n    (if (= x 1) x\n        (count (filter co-prime? (range x))))))","user":"5ea6fe98e4b00a66d4a951b2"},{"problem":75,"code":"(fn [x]\n  (letfn [(g [a b] (condp = 0\n                     a b\n                     b a\n                     (recur (mod b a) a)))]\n    (if (= x 1) 1\n        (count (filter #(= 1 (g x %)) (range 1 x))))))","user":"55201d18e4b08d5046aa8a5d"},{"problem":75,"code":"(fn [n] (count (filter #(= 1 (.gcd (biginteger %) (biginteger n))) (range 1 (inc n)))))","user":"541096bde4b01498b1a719b2"},{"code":"(fn [n]\n  (letfn [(gcd [a b] (if (zero? b) a (recur b (mod a b))))\n          (coprime? [k] (= 1 (gcd n k)))] \n     (->> (range 2 n) (filter coprime?) count inc)     \n   ))","problem":75,"user":"51729002e4b044b2ef48a850"},{"code":"(fn [x] (count (filter #(= 1 %) (map (partial #(if (= 0 %2) % (recur %2 (mod % %2))) x) (range x)))))","problem":75,"user":"4efb2fd7535dced4c769f274"},{"code":"(fn euler [x]\n  (letfn [(gcd [x y]\n            (if (= y 0)\n              x\n              (recur y (mod x y))))]\n    (if (= x 1)\n      1\n      (count (filter (fn [e] (== 1 (gcd e x))) (range 1 x))))))","problem":75,"user":"52f8f4d1e4b047fd55836fde"},{"code":"(fn f [n]\n\t(letfn [(gcd [a b]\n\t\t\t(if (zero? b) a (recur b (mod a b))))]\n\t\t(->> (range n) (map (partial gcd n)) (filter #(= % 1)) count)))","problem":75,"user":"51ba4482e4b0fe3ecfb4642b"},{"code":"; count all of those which have 0 common divisors >1\n(fn [x] \n  (+ 1 (count \n        (filter #(= 0 %) \n                (map (fn [y] \n                       (reduce #(if (= 0 (rem x %2) (rem y %2)) (+ %1 1) %1) \n                               0 (range 2 (+ 1 y)))) \n                     (range 2 x))))))","problem":75,"user":"50de11b2e4b061dbdced7217"},{"problem":75,"code":"(fn [x]\n  (if (= 1 x)\n    1\n    (count (filter #(= 1 ((fn [a b](if (zero? b) a (recur b (mod a b)))) x %)) (range 1 x)))))","user":"56cd44fde4b0ea9b8538f749"},{"code":"(fn totient [n]\n  (letfn [(gcd [a b]\n            (cond\n              (= a b) a\n              (> a b) (recur (- a b) b)\n              :else   (recur a (- b a))))]\n    (if (= n 1) \n        1\n        (count (filter #(= 1 (gcd n %)) (range 1 n))))))","problem":75,"user":"4f58fe71e4b0a7574ea7185f"},{"code":"(fn seventy-five\n  [n]\n  (letfn [(gcd [a b]\n            (if (zero? b)\n              a\n              (gcd b (rem a b))))]\n    (count (take-while #(< % (max n 2)) (filter #(= 1 (gcd n %)) (iterate inc 1))))))","problem":75,"user":"510591dde4b06d28cacc92eb"},{"problem":75,"code":"(fn g\n    ([m]\n     (g mod m m))\n    ([z m n]\n     (if (= 1 n)\n       1\n       (+\n        (if (= 1\n               (#(if (=  0 (z m %) (z n %))\n                    %\n                    (recur (- % 1)))\n                n))\n          1\n          0)\n        (g z m (- n 1))))))","user":"505106fee4b05ab4c7e07d38"},{"problem":75,"code":"(fn [n]\n  (letfn [(gcd [a b]\n            (if (= b 0) a (gcd b (mod a b))))]\n    (if (= n 1) 1\n        (count (filter #(= 1 (gcd n %)) (range 1 n))))))","user":"5fa74b82e4b0fa27300f3dda"},{"problem":75,"code":"(fn [n]\n  (letfn [(gcd [a b] (if (zero? b) a (recur b (mod a b))))]\n    (->> (range 1 n)\n         (filter #(= 1 (gcd n %)))\n         count\n         (max 1))))","user":"50d882d4e4b01f0871336e69"},{"problem":75,"code":"(letfn [(gcd [a b] (if (= b 0) a (gcd b (mod a b)) ))]\n (fn [x] (count (filter #(= 1 (gcd x %)) (range x))))\n)","user":"56bca51ae4b0f26550335963"},{"code":"(fn totient [n]\n  (if (= 1 n) 1\n  (letfn [(gcd [a b]\n               (loop [x a y b]\n                 (let [z (rem x y)]\n                   (if (= 0 z) y (recur y z)))))]\n    (reduce #(if (= 1 (gcd n %2)) (inc %) %) 0 (range 1 n)\n      ))))","problem":75,"user":"53307da1e4b019098a6f8b5e"},{"problem":75,"code":"(fn [n]\n  (letfn [(gcd [m n] (if (= 0 n) m (recur n, (mod m n))))]\n    (count (filter #(= 1 %) (map #(gcd %1 n) (range 1 (inc n)))))))","user":"55f8b32ae4b03cbcff9738ba"},{"code":"(fn [n]\n\t(let [et #(for [i (range 1 (inc %)) :when (= 0 (mod % i))] i) cop (et n)]\n\t\t(count\n\t\t\t(filter #(not (nil? %))\n\t\t\t\t(for [x (range 1 (inc n))]\n\t\t\t\t\t(if (= #{1} (clojure.set/intersection (into #{} cop) (into #{} (et x))))\n\t\t\t\t\t\tx\n\t\t\t\t\t\tnil))))))","problem":75,"user":"51c09719e4b0c9c82288293c"},{"code":"(letfn [(coprime? [a b]\n          (let [d (/ a b)]\n            (and (ratio? d) (= a (numerator d)))))\n        (coprimes-to [n] (conj (filter #(coprime? % n) (range 2 n)) 1))]\n  #(count (coprimes-to %)))","problem":75,"user":"4e9dafe1535dbda64a6f6b89"},{"code":"(fn [num]\n  (letfn [(devisors [n]\n            (set (filter #(= 0 (rem n %)) (range 2 (inc n)))))\n          (not-intersect? [a b]\n            (not (some #(contains? a %) b)))]\n\n    (reduce (fn [r x]\n              (if (not-intersect? (devisors x) (devisors num))\n                (inc r)\n                r))\n            0 \n            (range 1 (if (= num 1) 2 num)))))","problem":75,"user":"4f3e6244e4b0e243712b1f85"},{"code":"(fn [x] (reduce #(if (= x (denominator (/ %2 x))) (inc %) %) 1 (range 2 x)))","problem":75,"user":"51c19873e4b0d204dbe2ca0d"},{"problem":75,"code":"(fn phi [x]\n  (letfn\n    [(gcd [a b] (if (zero? b) a (recur b (mod a b))))\n     (coprimes? [a b] (= 1 (gcd a b)))\n    ]\n    (if (= 1 x) 1\n      (count (filter (partial coprimes? x) (range 1 x)))\n      )))","user":"53f7820be4b0de5c41848560"},{"problem":75,"code":"(fn eulers-phi [num]\n   ( let [ggtX (fn [z1 z2]\n                (let [restdiv (mod z1 z2) ]\n                  (if (zero? restdiv) \n                    z2\n                    (recur z2 restdiv))))\n          inputsX (fn [num]\n                   (partition 2\n                              (interleave (repeat num) (map inc (range num) )))\n                   )] \n\n         (count (filter #(= 1 %) (map #(apply ggtX %) (inputsX num) )))\n         )\n   )","user":"5364ab34e4b0243289761e64"},{"problem":75,"code":"(fn phi [n]\n  (let [gcf (fn [x y]\n              (cond (= 0 (rem x y)) y\n                    (= 0 (rem y x)) x\n                    :else\n                    (let [z (int (if (< x y) (quot x 2) (quot y 2)))\n                          internal-gcf (fn [x y z]\n                                         (if (or (= 1 z) (and (= 0 (rem x z)) ( = 0 (rem y z)))) z\n                                           (recur x y (dec z))))]\n                      (internal-gcf x y z))))\n        relatively-prime? (fn [n m]\n                            (= 1 (gcf m n)))\n        list-of-relative-primes (fn [n]\n                                  (filter #(relatively-prime? n %) (range 1 n)))]\n  (do (if (= 1 n) 1\n  (count (list-of-relative-primes n))))))","user":"56f4cedce4b046a417f92063"},{"code":"{1 1, 10 4, 40 16, 99 60}","problem":75,"user":"4e3456f9535deb9a81d77f2a"},{"problem":75,"code":"(fn f-euler [n]\n (if (== n 1)\n  1\n  (letfn [(f-euclid [x y]\n           (cond\n            (= x y) x\n            (< x y) (recur x (- y x))\n            :else (recur y (- x y))))]\n   (->> (map (partial f-euclid n) (range 1 n))\n        (filter (partial == 1))\n        count\n        ))))","user":"56f974c0e4b07572ad1a88b1"},{"problem":75,"code":"(fn [n]\n    (if (= n 1) 1\n        (letfn [(gcd [m]\n                  (->> (reverse (range 1 (inc m)))\n                       (filter #(= 0 (mod n %) (mod m %)))\n                       first))]\n          (count (filter #(= (gcd %) 1) (reverse (range 1 n)))))))","user":"4f57c913e4b0a7574ea7183f"},{"problem":75,"code":"(fn[y]\n\n  (letfn [\n   (divisors [z] \n    (map\n      (fn[x] (first x))\n\n      (filter \n             #(= (last %) z)\n              (map \n                  (fn[x] \n                         (take-while (partial >= z)  (iterate (partial + x ) x))\n                  ) \n                  (rest \n                         (range (inc z))\n                  )\n              )\n       )\n     )\n    )\n   \n   (commondivisors [x y]\n       (= (count (clojure.set/intersection (set (divisors x)) (set (divisors y))))  1)\n   )\n    \n   (coprimes [a]   \n\t(filter #(commondivisors % a) (rest (range (inc a))) )\n   )\n\n   ]\n      (count (coprimes y))\n   )\n  )","user":"56e6e1e6e4b02e7e935eb6cf"},{"problem":75,"code":"(fn  [n]\n  (letfn [(gcd [x y]\n               (if (<= y 0)\n                 x\n                 (recur y (mod x y))))]\n    (if (= 1 n)\n      1\n      (->> (range 1 n)\n           (filter #(= 1 (gcd % n)))\n           (count)))))","user":"54074fc5e4b0addc1aec66b6"},{"problem":75,"code":"(fn [x]\n   (count (filter (fn [n]\n                    (= 1 (#(if (= %2 0)\n                             %1\n                             (recur %2 (mod %1 %2))) x n))) (range 1 (inc x)))))","user":"5d29c06be4b01671435dbc6b"},{"code":"(fn [x]\n  (let [fs (fn [x] (filter #(= 0 (mod x %)) (range 2 (inc (/ x 2)))))\n        nd? (fn [s n] (every? #(not (zero? %)) (map #(mod n %) s)))]\n      (if (= x 1)\n          1\n          (count (filter (partial nd? (fs x)) (range 1 x))))))","problem":75,"user":"4e1f9bb5535d04ed9115e80d"},{"problem":75,"code":"(fn [x]\n   ;(empty? (for [i (range 2 x)\n   ;       j (range 2 y)\n   ;       :when (and (= 0 (mod y j)) (= 0 (mod x i)))]\n   ;   i))\n   (if (= x 1)\n     1\n     (do\n       (let [z (set (filter #(zero? (mod x %)) (range 2 (inc x))))]\n        (->>\n          (range 1 x)\n          (map (fn [y]\n                 (set (filter #(zero? (mod y %)) (range 2 (inc y))))))\n          (filter #(empty? (clojure.set/intersection z %)))\n          (count)\n          )\n        ))))","user":"5a4b3abde4b05d388ecb6b81"},{"code":"(fn [n]\n  (if (= n 1)\n      1\n      (count\n        (filter #(= ((fn gcd [a b] (if (= b 0) a (gcd b (mod a b)))) % n) 1)\n                (range n)))))","problem":75,"user":"4f9a0064e4b0dcca54ed6d03"},{"code":"(fn boo [n]\n  (let \n    [gcd (fn [x y]\n           (let \n             [mn (min x y)\n              mx (max x y)\n              md (mod mx mn)]\n             (if (= 0 md)\n               mn\n               (recur mn md))))]\n    (if (= n 1)\n      1\n      (->> n\n         (range 1)\n         (filter #(= 1 (gcd % n)))\n         (count )))))","problem":75,"user":"50217818e4b00bba4502f7a7"},{"problem":75,"code":"(fn [n]\n  (if (= 1 n) 1\n    (letfn [(gcd [a b] (if (zero? b) a (recur b (mod a b))))]\n      (->> (range 1 n) (filter #(= 1 (gcd n %))) count))))","user":"59ef6cfae4b0966464fe6a32"},{"code":"(fn [x]\n  (if (= 1 x)\n    1\n    (count\n      (filter\n        #(= 1 (loop [a x b %]\n                (if (zero? b) a,\n                  (recur b (mod a b)))))\n        (range 1 x)))))","problem":75,"user":"50d8de3fe4b01f0871336e72"},{"code":"(fn [n]\n    (letfn [(gcd [a b] (cond (= a b) a (> a b) (gcd (- a b) b) (< a b) (gcd a (- b a))))\n            (phi-test [total curr-n] (if (= (gcd n curr-n) 1) (inc total) total))]\n      (reduce phi-test 0 (range 1 (inc n)))))","problem":75,"user":"526f9715e4b03e8d9a4a7372"},{"code":"(fn [n]\n  (if (= n 1)\n    1\n    (let [gcd (fn gcd [a b]\n                  (loop [a a b b]\n                    (if (zero? b) a,\n                    (recur b (mod a b)))))]\n      (count (filter #(= 1 (gcd % n)) (range 1 n))))))","problem":75,"user":"51ba8f82e4b0fe3ecfb46434"},{"problem":75,"code":"(fn [x]\n  (let [gcd #(if (= 0 %2) % (recur %2 (mod % %2)))]\n   (->> (range x)\n        (filter #(= 1 (gcd % x)))\n        count)))","user":"548b8a50e4b0e286459a11ff"},{"problem":75,"code":"(fn [x] \n  \t(if (= x 1) 1\n      (count (filter #{1} \n                     (map            (fn [a b] (if (< a b) \n                       (recur a (- b a))\n                       (if (> a b) \n                         (recur (- a b) b)\n                         a))) \n                          (repeat x) \n                          (range 1 x))))\n      ))","user":"55be39f9e4b01b9910ae2a06"},{"problem":75,"code":"(fn et [n]\n  (letfn [(gcd [a b]\n               (if (= 0 (rem a b))\n                 b\n                 (gcd (max (- a b) b) (min (- a b) b))))]\n    (count (filter #(= 1 (gcd n %)) (range 1 (max n 2))))))","user":"576df252e4b0979f8965156f"},{"problem":75,"code":"(fn [o]\n  (if (= 1 o)\n    1\n    (let [f (fn f [m n] \n              (let [i (mod m n)]\n                (if (= 1 n)\n                  true\n                  (if (zero? (mod m n))\n                    false\n                    (f n i)))))]\n      (count (filter #(f o %) (range 1 o))))))","user":"5af907e6e4b0cc2b61a3bcda"},{"problem":75,"code":"(fn [x]\n  (letfn [(gcd [x y] (if (zero? y) x (gcd y (mod x y))))]\n    (->> (range x)\n         (filter #(= (gcd % x) 1))\n         count)))","user":"54926752e4b0b312c081ff44"},{"problem":75,"code":"(fn e-tot\n  [n]\n  (let [gcd (fn [x y] (last (filter #(= (mod x %) (mod y %) 0) (next (range (max x y))))))\n        c-prime (fn [x y] (= (gcd x y) 1))]\n  (if (= n 1)\n      1\n      (count (filter (partial c-prime n) (next (range n)))))))","user":"55acd080e4b03311e7b73298"},{"problem":75,"code":"(fn euler-totient [n]\n  (letfn\n    [(gcd [a b]\n            (loop [t 1\n                   g 1]\n              (cond\n                (> t (min a b)) g\n                (= [0 0] (map #(mod % t) [a b])) (recur (inc t) t)\n                true (recur (inc t) g))))]\n    (if (= n 1)\n      1\n      (count (filter #(= 1 (gcd % n)) (range 1 n))))))","user":"5703eda3e4b08d47c9778200"},{"problem":75,"code":"(fn [n]\n   (letfn [(gcd [a b]\n             (loop [a1 (if (>= a b) a b)\n                    b1 (if (>= a b) b a)]\n               (if (= (mod a1 b1) 0)\n                 b1\n                 (recur b1 (mod a1 b1)))))]\n     (if (<= n 1)\n       1\n       (count (filter #(= (gcd n %) 1) (range 1 n))))\n     ))","user":"5f3f2281e4b004f08c61c561"},{"problem":75,"code":"#(letfn[(gcd [x y]\n             (cond\n              (= x y) x\n              (< x y) (recur x (- y x))\n              :else (recur (- x y) y)))]\n   (count (filter (fn [x] (= x 1)) (map (fn[x] (gcd % x)) (range 1 (inc %))))))","user":"556c70dae4b09a3098a524fd"},{"problem":75,"code":"(fn [n] \n    (if (= n 1)\n     1\n     (let [divisors (fn [x] (set (cons x(filter #(zero? (rem x %)) (range 1 (inc (quot x 2)))))))]\n       (count (filter #(= 1 (count (clojure.set/intersection (divisors n) (divisors %)))) (range 1 n) )))\n     ))","user":"4ff4bed0e4b0678c553fc35f"},{"code":"(fn [x]\n  (letfn\n    [(gcd [y] (apply max (filter #(= 0 (mod x %) (mod y %)) (range 1 (+ 1 (max (/ x 2) (/ y 2)))))))]\n    (count\n      (filter\n        #(= 1 (gcd %))\n        (range x)))))","problem":75,"user":"4f1b92d1535d64f60314647b"},{"code":"(fn [n]\n  (->> ((fn f [[a & z]]\n                  (lazy-seq (cons a\n                                  (f (remove \n                                      #(= 0 (mod % a))\n                                      z)))))\n        (iterate inc 2))\n       (take-while #(< % n))\n       (filter #(= 0 (mod n %)))\n       (map #(- 1 (/ %)))\n       (cons n)\n       (apply *)))","problem":75,"user":"4e5fe31a535d8ccf87e9fe50"},{"problem":75,"code":"(fn [x]\n(count \n  (letfn [(gcd [a b] (if (zero? b)\n      (Math/abs a)\n      (recur b (rem a b))))] \n  (filter #(= 1 (gcd x %)) (range x)))))","user":"5ac92dc3e4b0e27600da77bf"},{"problem":75,"code":"(fn coprimes [x]\n(let [gcd (fn [a b]\n  (cond \n   \t\t(< a b) (recur a (- b a))\n  \t\t(> a b) (recur (- a b) b)\n   \t\t:else a))]\n (->> (range 2 x)\n(filter #(= (gcd x %) 1) )\n(into [1])\ncount\n)))","user":"59cd13d5e4b0ef0a1e9b5b32"},{"problem":75,"code":"(fn [n]\n      (let [gcd (fn gcd [a b]\n                  (if (zero? b)\n                    a\n                    (gcd b (mod a b))))\n            coprime? (comp (partial = 1) (partial gcd n))]\n        (if (= n 1)\n          1\n          (count (filter coprime? (range 1 n))))))","user":"50a3ad0ee4b0ceace084d493"},{"code":"(fn [x] \r\n  (count \r\n    (filter \r\n      (fn [y] (empty? (filter #(= 0 (mod y %) (mod x %)) (range 2 (inc y)))))\r\n      (range 1 (inc x)))))","problem":75,"user":"4e707db6535d5021c1a8963a"},{"problem":75,"code":"(fn [num]\n   (count\n     (if\n            (= num 1)\n            '(1)\n            (let [prims\n                  ((fn [m] ;from http://www.4clojure.com/problem/67 n first prime numbers, but adjusted\n                     (loop [primes [2]]\n                       (if (>= (last primes) m)\n                         primes\n                         (let [prime\n                               (loop [primeCandidate (inc (last primes))]\n                                 (let [primeCandidateSqrt (Math/sqrt primeCandidate)\n                                       divider\n                                       (loop [dividerCandidateIndex 0]\n                                         (let [dividerCandidate (primes dividerCandidateIndex)]\n                                           (if (<= dividerCandidate primeCandidateSqrt)\n                                             (if (not= (mod primeCandidate dividerCandidate) 0) ;use zero?\n                                               (recur (inc dividerCandidateIndex))\n                                               dividerCandidate)\n                                             nil)))]\n                                   (if (not divider)\n                                     primeCandidate\n                                     (recur (inc primeCandidate)))))]\n                           (recur (conj primes prime))))))\n                   num)]\n              (filter\n                (fn [coprime]\n                  (not ;no common divisors\n                    (some\n                      (fn [divisor]\n                        (= (mod coprime divisor) (mod num divisor) 0))\n                      (filter\n                        (fn [divisorCandidate]\n                          (<= divisorCandidate coprime))\n                        prims))))\n                \n                (range 1 num))))))","user":"5b999af8e4b0c0b3ffbd4ad3"},{"problem":75,"code":"(fn [x]\n  (letfn [(pgcd [a b]\n   (if (= b 0) a\n      (pgcd b (rem a b))))]\n    (if (= 1 x) 1\n    (count\n      (filter #(= 1 (pgcd x %))\n        (range 1 x))))))","user":"57642916e4b0994c1922fbee"},{"problem":75,"code":"#(let [gcd (fn [x y] (if (ratio? (/ x y)) (/ x (numerator (/ x y))) (min x y)))\ncoprime? (fn [x] (= (gcd x %) 1))]\n(if (= % 1) 1 (->> (range 1 %)\n(filter coprime?)\n(count))))\n;gcd function based on chouser's solution of problem 66 Greatest Common Divisor","user":"5e13a6b7e4b099d064963001"},{"problem":75,"code":"(fn [n] (letfn [(gcd [a b] (if (zero? b) a (recur b (mod a b))))] \n          ((comp inc count) (filter #(= 1 (gcd % n)) (range 2 n)))))","user":"52e851bfe4b09f7907dd149a"},{"problem":75,"code":"(fn [b]\n                 (let [gcd (fn [a b] (if (zero? b) a (recur b (mod a b))))]\n                   (cond\n                     (= b 1) 1\n                     :else\n                     (count (filter #(= 1 (gcd b %)) (range 1 b))))))","user":"56efb3a3e4b04a395b9a0463"},{"code":"(letfn [(gcd [a b]\n          (loop [c a d b]\n            (if (= d 0) c\n                (recur d (rem c d)))))]\n  (fn [c]\n    (if (= c 1)\n      1\n      (count (filter #(= 1 (gcd c %)) (range 1 c))))))","problem":75,"user":"5133e51ae4b0d7a043de8cf6"},{"problem":75,"code":"(fn \n  [n]\n  (if (= n 1) \n    1 \n    (count (let [gcd (fn gcd [a b] (if (= 0 b) a (gcd b (mod a b))))]\n            (filter #(= 1 (gcd n %)) (range n))))))","user":"59f44189e4b0966464fe6aab"},{"code":"(letfn [(G [x y]\n          (cond (> y x) (G y x)\n                (zero? y) x\n                :else (G y (rem x y))))\n        (P [x y]\n          (= 1 (G x y)))\n\n        (E [n]\n          (count (filter #(P n %) (range 1 (max n 2)))))]\n  E)","problem":75,"user":"51a4416ae4b0def3c5c5868c"},{"problem":75,"code":"(fn my-totient [x]\n  (let [gcd (fn [a b]\n              (loop [a2 a b2 b]\n                (if (zero? b2) a2\n                  (recur b2 (mod a2 b2)))))]\n    (count (cons 1 (filter #(= 1 (gcd % x)) (range 2 x))))))","user":"5546704be4b0a04f7929953d"},{"code":"(fn my-totient [n]\n  (letfn [(gcd [a b] (if (= b 0) a (gcd b (rem a b))))\n          (rrr [v tot]\n            (if (> v n)\n              tot\n              (if (= 1 (gcd v n))\n                (rrr (inc v) (inc tot))\n                (rrr (inc v) tot))))]\n  (rrr 2 1)))","problem":75,"user":"4f04d312535dcb61093f6be7"},{"problem":75,"code":"(fn eulers-totient-fn\n  ([x]\n   (case x\n     1 1\n     (eulers-totient-fn x (dec x))))\n  ([x y]\n   (let [f (fn gcd \n             [g s]\n             (if (= 0 s)\n               g\n               (gcd s (mod g s))))]\n     (case y\n       1 1\n       (+ \n        (case (f x y) \n          1 1 \n          0) \n        (eulers-totient-fn x (dec y)))))))","user":"53b952eee4b047364c0444e6"},{"problem":75,"code":"(fn [x] \n  (if (= x 1) 1\n    (letfn [\n            (gcd [x1 x2] \n                 (loop [i (apply max [x1 x2])]\n                   (if (and (integer? (/ x1 i)) (integer? (/ x2 i))) i\n                     (recur (dec i)))))\n            (coprime? [a b]\n                      (= (gcd a b) 1))\n            ]\n      (count (filter #(coprime? x %) (rest (range x))))\n      )))","user":"53e76bb2e4b036ad0777e47d"},{"problem":75,"code":"(fn totient [x]\n  (if (= 1 x)\n    1\n    (let [gcd (fn gcd [a b] (if (zero? b) a (gcd b (mod a b))))\n          totient-numbers (filter #(= 1 (gcd % x))\n                                  (range 1 x))]\n      (count totient-numbers))))","user":"551bdefde4b07993ea3788d7"},{"problem":75,"code":"(fn [n]\n      (->> (cons 1 (range 2 n))\n           (filter #(= ((fn [a b]\n                          (if (zero? b)\n                            a\n                            (recur b (mod a b))))\n                        n %)\n                       1))\n           count))","user":"58c4b11ae4b021aa9917ed2c"},{"problem":75,"code":"(fn [x]\n  (loop [a 1 j []]\n    (if (= a (inc x))\n      (count (filter nil? j))\n      (recur (inc a) (conj j (some integer? (map #(/ a %) (filter integer? (map #(/ x %) (range 2 x))))))))))","user":"54bcab07e4b0ed20f4ff6ed5"},{"problem":75,"code":"(fn [ n ] \n    (condp = n 1 1 \n      (->>\n        (for [ x (range 1 (inc n)) ] (rationalize (/ x n)))\n        (filter #(ratio? %)) \n        (filter #(= n (.denominator %)))\n        (map #(.numerator %)) \n        count)))","user":"5398305fe4b0b51d73faaef6"},{"code":"#(max 1 (count (filter (partial \n(fn gcd [x y]\n  (if (< x y) (gcd y x)\n    (if (= y 0) (= x 1) (gcd y (mod x y)))\n   )\n  ) %) (range 1 %))\n))","problem":75,"user":"514457fbe4b0b4fb4ace5f43"},{"problem":75,"code":"(fn et[n] (letfn [(gcd [aa bb] \n (loop [a (max aa bb) b (min aa bb)]\n   (let [r (rem a b)]\n     (if (= 0 r) b\n     (recur b r))\n)))]\n(if (= 1 n) 1 (count (filter #(= 1 (gcd n %)) (range 1 n))))\n))","user":"59a0262ee4b0871e7608b82d"},{"problem":75,"code":"(fn euler\n\t[x]\n\t(let [primes \n\t\t\t(fn generator\n\t\t\t\t[res n] \n\t\t\t\t(if (some #(= 0 (mod n %)) res)\n\t\t\t\t\t(recur res (inc n))\n\t\t\t\t\t(lazy-seq (cons n (generator (conj res n) (inc n))))))]\n\t\t(->> (take-while #(< % x) (primes [] 2))\n\t\t\t (filter #(= (mod x %) 0))\n\t\t\t (reduce\n\t\t\t \t#(* %1 (- 1 (/ 1 %2))) 1)\n\t\t\t (* x))))","user":"58fb7d7ae4b0438e51c2cf7a"},{"problem":75,"code":"(fn [numy1]\n  (if (= numy1 1)\n    1\n    (loop [i 1 tmpc 0]\n      (if (= i numy1)\n        tmpc\n        (if (= 1 ((fn\n            [num1 num2]\n            (loop [gcd 0, n 1, sm (+ num2 1)]\n              (if (= n sm)\n                gcd\n                (if (and (zero? (rem num1 n)) (zero? (rem num2 n)))\n                  (recur n (inc n) sm)\n                  (recur gcd (inc n) sm))))) numy1 i))\n          (recur (inc i) (inc tmpc))\n          (recur (inc i) tmpc))))))","user":"59369515e4b02506e01a297e"},{"problem":75,"code":"(fn euler [x]\n  (if (<= x 1) 1\n      (letfn [(gcd [a b]\n                (let [mx (max a b)\n                      mn (min a b)\n                      r (rem mx mn)]\n                  (if (= 0 r) mn\n                      (gcd mn r))))]\n        (loop [curr x acc 0]\n          (if (= curr 1) acc\n              (recur (dec curr) (if (= 1 (gcd x (dec curr))) (inc acc)\n                                    acc)))))))","user":"52fc34cee4b047fd55837015"},{"code":"(fn totient [n]\n  (let [gcd #(if (= 0 %) %2 (recur (mod %2 %) %))]\n    (loop [tot 0, pos (- n 1)]\n      (if (>= pos 0)\n        (if (= 1 (gcd n pos))\n          (recur (+ tot 1) (- pos 1))\n          (recur tot (- pos 1)))\n        tot))))","problem":75,"user":"509e62a8e4b08df8156e9e2e"},{"problem":75,"code":"(fn [x]\n  (if (= x 1) 1\n      (let [gcd (fn [a b]\n                  (cond\n                    (> a b) (recur b a)\n                    (= a 0) b\n                    :else (recur (rem b a) a)))\n            coprime? (fn [a b] (if (= 1 (gcd a b)) 1 0))]\n        (apply + (map (partial coprime? x) (range 1 x))))))","user":"5866b999e4b0f14aab7c886b"},{"problem":75,"code":"(fn my [n]\n  (letfn [(divs [k & {:keys [k1] :or {k1  k}}]\n            \"common divisors\"\n            (cond\n              (= k 1) #{1}\n              (= k1 1) #{1}\n              (= (mod k k1) 0) (conj (divs k :k1 (dec k1)) k1)\n              :else (divs k :k1 (dec k1))))\n          (coprime? [n1 n2]\n            (if (= n1 1)\n              1\n              (=\n               (clojure.set/intersection (divs n1) (divs n2))\n               #{1})))]\n    (if (= n 1)\n      1\n      (count (filter (fn [n1] (coprime? n1 n)) (range 1 n))))))","user":"540d5085e4b0addc1aec670e"},{"problem":75,"code":"(fn [n]\n    (if (= n 1) 1\n      (let [gcd (fn [x y] (if (zero? y) x (recur y (rem x y))))]\n        (count (filter (fn [v] (= (gcd n v) 1)) (range 1 n))))))","user":"5a9bfd57e4b0d174b936c7d0"},{"code":"(fn euler[n]\n  (count (filter\n    #(= (loop [a % b n] \n          (if (= 0 b) a (recur b (mod a b)))\n        ) 1)\n    (range n)\n    ))\n)","problem":75,"user":"4e9de526535dbda64a6f6b8e"},{"problem":75,"code":"(letfn [(gcd [a b] (if (zero? b) a (recur b, (mod a b))))\n\t\t(coprime? [a b] (= 1 (gcd a b)))\n\t\t(f [x] (->> x range (filter #(coprime? x %)) count))] f)","user":"580c8fcee4b0849f6811b721"},{"problem":75,"code":"(fn eulers-totient\n  [x]\n  (letfn [(gcd\n            [a b]\n            (let [factors (fn factors [n] (filter #(zero? (rem n %)) (range 1 (inc n))))]\n              (some #((set (factors a)) %) (reverse (sort (factors b))))))]\n    (count ((group-by #(gcd % x) (range 1 (inc x))) 1))))","user":"5401aefbe4b0df28a13c62c7"},{"problem":75,"code":"(fn [n]\n  (letfn [(gcd [a b]\n               (cond\n  \t             (= a b) a\n  \t             (> a b) (recur (- a b) b)\n  \t             :else (recur a (- b a))))\n          (co-prime? [a b]\n                     (= 1 (gcd a b)))]\n    (if (= 1 n) 1\n      (reduce (fn [a b]\n              (if (co-prime? b n) (inc a) a))\n            0\n            (range 1 n)))))","user":"5cc6b4bfe4b0ccb061962827"},{"problem":75,"code":"#(letfn [(gcd [m n]\n           (if (zero? n)\n             m\n             (recur n (mod m n))))\n         (coprime? [m n]\n           (= 1 (gcd m n)))]\n   (count\n    (filter (partial coprime? %)\n            (range 1 (inc %)))))","user":"58e58ae9e4b056aecfd47c9a"},{"code":"(fn totient [x]\r\n  (if (= 1 x) 1\r\n  (letfn [(multiple? [a b] (or (zero? (mod a b))\r\n                               (zero? (mod b a))))\r\n          (gcd [a b]\r\n               (if (multiple? a b) (min a b)\r\n                   (loop [c 1, n 2, lim (/ (min a b) 2)]\r\n                     (if (> n lim) c\r\n                         (if (and (multiple? a n)\r\n                                  (multiple? b n))\r\n                           (recur n, (inc n), lim)\r\n                           (recur c, (inc n), lim))))))]\r\n          (count (filter #(= 1 (gcd x %)) (range 1 x))))))","problem":75,"user":"4ddbdc1b535d02782fcbe9fd"},{"code":"(fn euler-totient [x]\n  (if (< x 3) 1\n    (let [divisors (filter #(zero? (mod x %)) (range 2 x))]\n      (count (filter \n              (fn [candidate] \n                (every? #(< 0(mod candidate %1)) divisors))\n              (range 1 x)\n              ))\n      )))","problem":75,"user":"5094057fe4b097f48cc38593"},{"code":"(fn euler [n]\n  (cond (= n 1) 1\n        :else\n        (letfn [\n                (\n                gcd [a b]\n                 (if (= b 0) \n                   a\n                   (recur b (rem a b)))\n                )\n                (\n                coprime? [a b]\n                 (= (gcd a b) 1)\n                )\n                ]\n          (count (set (for [i (range 1 n)]\n                        (if (coprime? i n)\n                          i\n                          1\n                         ) ; if\n                        ) ; for\n                      ) ; set\n                 ) ; count\n          ) ; letfn\n        ) ; cond\n) ; fn euler","problem":75,"user":"5021f0b3e4b00bba4502f7ac"},{"code":"#(count (filter (partial (fn [a b]\n                          (if (zero? b) (= 1 a) (recur b (mod a b)))) %)\n                (range %)))","problem":75,"user":"506a1985e4b01dc6af13f83e"},{"problem":75,"code":"(fn [x]\n  (letfn [(gcd [a b]\n            (if (zero? b)\n              a\n              (recur b (mod a b))))]\n    (count (filter #(= 1 (gcd x %)) (range x)))))","user":"4ee75ec2535d93acb0a66867"},{"problem":75,"code":"(fn eulers-totient [n]\n  (if (= 1 n)\n    1\n    (letfn [(gcd [a b]\n              (if (zero? b)\n                a\n                (gcd b (mod a b))))\n            (coprime? [m] (= 1 (gcd m n)))]\n      (->> (range 1 n)\n           (filter coprime?)\n           (count)))))","user":"5f37263de4b0574c87022c4e"},{"problem":75,"code":"(fn [x]\n  (if (= 1 x)\n    1\n    (letfn [(gcd [a b]\n              (let [larger (max a b)]\n                (first\n                  (filter\n                    #(and (integer? (/ a %))\n                          (integer? (/ b %)))\n                    (range (int (/ larger 2))\n                           0\n                           -1)))))\n            (coprime? [a b]\n              (= 1 (gcd a b)))]\n      (count\n        (filter #(coprime? x %)\n                (range 1 x))))))","user":"58b2c435e4b0ebc645576d11"},{"problem":75,"code":"(fn [n]\n  (letfn \n    [(gcd [a b]\n          (if (zero? b)\n           a\n           (recur b \n                  (mod a b))))\n     (cpr? [a] (= 1 (gcd a n)))]\n   (count (filter cpr?\n                  (range n)))))","user":"55d2dd27e4b0e31453f64a5b"},{"code":"#(count\n   (filter\n    (fn [x]\n      (loop [a % b x]\n        (if (= 0 b)\n          (= 1 a)\n          (recur b (mod a b)))))\n    (range %)))","problem":75,"user":"4e65027c535d8ccf87e9fe6e"},{"code":"(fn phi [n]\n  (letfn [(gcd [a b]\n             (loop [x a y b]\n               (if (= 0 y)\n                  x\n                  (recur y (mod x y)))))]\n    (count (filter #(= (gcd n %) 1) (range 1 (inc n))))))","problem":75,"user":"4fe87e56e4b07c9f6fd12c40"},{"code":"(fn [n]\n  (letfn [(gcd [a b] (if (= b 0) a (recur b (mod a b))))]\n    (if (= n 1)\n    1\n    (count (filter #(= 1 (gcd n %)) (range 1 n))))))","problem":75,"user":"51bd1a0de4b0df1216cefd93"},{"problem":75,"code":"(fn [n]\n    (if (= 1 n)\n      1\n      (letfn [(gdc [a b] (if (zero? b) a (recur b (mod a b))))]\n       (count\n         (for [x (range 1 n)\n             y [n]\n             :when (= 1 (gdc x n))]\n         [x n])))))","user":"515ebde3e4b01e5d11ccd0a8"},{"problem":75,"code":"(fn [x]\n  (let [mult? (fn [n d] (zero? (mod n d)))\n        gcd   (fn [a b] \n                (if (zero? b)\n                  a\n                  (recur b (mod a b))))\n        coprime? (fn [a b]\n                   (= 1 (gcd a b)))]\n    (if (= 1 x)\n      1\n      (count (filter #(coprime? x %) (range 1 x))))))","user":"5f93529ae4b0715f5002d7bc"},{"problem":75,"code":"(fn totient [value]\n  (if (= 1 value)\n    1\n    (let [gcd (fn gcd [l r]\n                (if (zero? r)\n                  l\n                  (gcd r, (mod l r))))]\n      (count (filter #(= 1 (gcd value, %)) (range 1 value))))))","user":"5bfa25fbe4b0bdcf453d15c8"},{"code":"(fn b [n]\n     (letfn [(a [m] (loop [mm m nn n] (if (= nn 0) mm (recur nn (mod mm nn)))))]\n       (let [r (range 1 (+ n 1))]\n        (count (filter #(= 1 %) (map a r))))))","problem":75,"user":"4fe97adde4b0547ebccb245e"},{"code":"(fn totient [x]\n  (letfn [(gcd [x y]\n               (cond (> x y) (gcd y x)\n                     (= (mod y x) 0) x\n                     :else (gcd x (- y x))))\n          (coprime? [x y] (= (gcd x y) 1))]\n    (if (= x 1) 1\n        (count (filter #(coprime? x %) (map inc (range (dec x))))))))","problem":75,"user":"4ee82ce9535d93acb0a6687a"},{"problem":75,"code":"(fn totient [x]\n  (if (= x 1) 1\n      (letfn [(divisors [x]\n                (->> (filter #(= (mod x %) 0) (range 1 (inc x)))\n                     set))\n              (is-coprime? [x y]\n                (let [divx (divisors x)\n                      divy (divisors y)]\n                  (= (clojure.set/intersection divx divy) #{1})))]\n        (count (filter #(is-coprime? x %) (range 1 x))))))","user":"569dd6e8e4b0542e1f8d1480"},{"problem":75,"code":"(fn [x]\n  (let [gcd (fn gcd [i j]\n                (apply max (clojure.set/intersection (set (let [x i] (filter #(= 0 (mod x %)) (range 1 (inc x))))) (set (let [x j] (filter #(= 0 (mod x %)) (range 1 (inc x))))))))]\n              (if (= x 1)\n                  1\n                  (count (filter (partial = 1) (map (partial gcd x) (range 1 x)))))))","user":"544e8369e4b0e39780006987"},{"problem":75,"code":"#(let [g (fn g [a b] (if (= b 0) a (if (> b a) (g b a) (g b (mod a b)))))\n       p (fn [x y] (= 1 (g x y)))]\n   (count (filter (partial p %) (range 1 (inc %)))))","user":"57ec3d29e4b0bfb2137f5b77"},{"code":"(fn[n]\n  (letfn ([g[u v]\n           (if\n            (=  v 0) u\n            (g v (rem u v)))])\n  (count\n     (for [x (range 1 (+ n 1)) :when (= (g n x) 1)] x))))","problem":75,"user":"52f818a6e4b047fd55836fcc"},{"code":"(fn [n]\n    (letfn [(gcd [x y]\n              (loop [[y x] (sort [x y])]\n                (if (zero? y) x (recur [(mod x y) y]))))]\n      ;; coprime when gcd is 1; ignore special case of 1 by ranging\n      ;; from 2 and incrementing result:\n      (inc (count (filter #(= 1 (gcd % n)) (range 2 n))))))","problem":75,"user":"50763574e4b0a894bb95bf3d"},{"code":"(fn [n]\n  (let\n    [coprimes? (fn [a b] (let [r (/ a b)] (and (ratio? r) (= a (numerator r)))))]\n      (inc (count (filter (partial coprimes? n) (range 1 n))))))","problem":75,"user":"525431dfe4b0541d1855b970"},{"problem":75,"code":"(fn totient\r\n  [x]\r\n  (if (= x 1) 1\r\n    (reduce\r\n      (fn [r a]\r\n        (if \r\n          (not-any?\r\n            #(and (= (mod a %) 0) (= (mod x %) 0))\r\n            (range 2 (inc a)))\r\n          (inc r) \r\n          r))\r\n      0\r\n      (range 1 x))))","user":"5470699ae4b00cfc9eacc1b6"},{"problem":75,"code":"(fn totient [n]\n  (letfn [\n          (gcd [a b]\n               (cond\n                 (= a b) a\n                 (> a b) (recur b (- a b))\n                 :else (recur a (- b a))))]\n        (->> n\n             (range 2)\n             (map #(gcd n %))\n             (filter #(= 1 %))\n             count\n             inc)))","user":"588e4e05e4b00487982d5188"},{"code":"(fn totient [n]\n  (if (= n 1)\n    1\n    (let [coprime? (fn [x y]\n                    (not-any? #(= 0 (mod x %) (mod y %))\n                              (range 2 (inc (min x y)))))]\n      (count (filter #(coprime? n %) (range 1 n))))))","problem":75,"user":"51460e4ce4b04ef915e37314"},{"problem":75,"code":"(fn et[n]\n  (letfn [(gcd [a b]\n            (cond\n              (= a b) a\n              (> a b) (recur (- a b) b)\n              :else (recur a (- b a))))]\n    (if (= 1 n)\n      1\n      (count\n       (filter #(= 1 (gcd n %)) (range 1 n) )))))","user":"5980f91ae4b021a7a535fddd"},{"problem":75,"code":"(fn tot [n]\n  (letfn [(gcd [a b]\n    (if (zero? b)\n      a\n      (gcd b (mod a b))))]\n  (loop [v 2\n         ans 1]\n    (if (> v n)\n      ans\n      (recur (inc v)\n             (if (= (gcd v n) 1)\n               (inc ans)\n               ans))))))","user":"5632d1b3e4b0bfe05bf117a9"},{"problem":75,"code":"(fn [n]\n  (let\n    [e #(loop [a %1 b %2]\n            (if (= b 0)\n              a\n              (recur b (mod a b))))]\n    (apply + (cons 1 (map #(if (= (e % n) 1) 1 0) (range 2 n))))))","user":"55316b8ae4b076ab5578f825"},{"problem":75,"code":"(letfn [                                                                                                                        \n    (is-prime? [x] (not-any? (partial = 0) (map #(mod x %) (range 2 (inc (/ x 2))))))                                                                   \n    (prime-seq [] (filter is-prime? (map (partial + 2) (range))))                                                               \n    (primes-less-than [n] (take-while (partial > n) (prime-seq)))                                                                                       \n    (prime-divisors [n] (let [primes (filter #(zero? (mod n %)) (primes-less-than (inc (/ n 2))))]                              \n                            (if (is-prime? n) (concat primes [n]) primes)))                                                                             \n    (eulers-product-formula [n] (if (= 1 n) 1 (apply * n (map #(- 1 (/ 1 %)) (prime-divisors n)))))]                            \n        eulers-product-formula)","user":"558b50d5e4b027778923762b"},{"problem":75,"code":"(fn totient [n]\n  (letfn [(gcd [a b]\n            (if (= b 0) a\n                (gcd b (mod a b))))\n          (coprime? [a b]\n            (= (gcd a b) 1))]\n    (if (= n 1) 1\n        (count (filter #(coprime? n %) (range 1 n))))))","user":"5b47874be4b02d533a91bc70"},{"problem":75,"code":"(fn euler-totient\n  [x]\n  (if (#{1} x) 1\n      (count (filter #{1}\n                     (map (fn my-gcd1\n  [x y]\n  (if (zero? (rem x y))\n    y\n    (recur y (rem x y))))\n (repeat x) (range 1 x))))))","user":"557e9d17e4b05c286339e0d8"},{"code":"(fn totient [n]\n  (let [gcd (fn [a b]\n              (if (= b 0)\n                a\n                (recur b (mod a b))))\n        coprime? (fn [a b] (= 1 (gcd a b)))]\n    (if (= n 1)\n      1\n      (count (filter  (partial coprime? n) (range 1 n)))) ))","problem":75,"user":"4f2965ffe4b0d6649770a029"},{"problem":75,"code":"(fn [n]\n  (if (= n 1)\n    1\n    (letfn [(gcd [a b] (if (zero? b) a (gcd b (mod a b))))]\n      (count (filter #(= 1 %) (map gcd (range 1 n) (repeat n))))\n    )\n))","user":"54524afbe4b0e397800069bc"},{"problem":75,"code":";;fake not undstand\n(fn [n]\n  (if (= n 1)\n    1\n    (let [gcd (fn [a b] (if (zero? b) a (recur b (mod a b))))]\n      (count (filter #{1} (map (partial gcd n) (range 1 n)))))))","user":"55a0d79fe4b0acc240e31502"},{"problem":75,"code":"( let [gcd (fn gcd[a b] (if (= b 0) a (gcd b (mod a b))))] (fn [y] (if (= 1 y) 1 (count (for [x (range y) :when (= 1 (gcd x y))] x))  )) )","user":"6076adb2e4b069485764de60"},{"problem":75,"code":"(fn totient [x]\n    (if (= x 1)\n      1\n      (letfn [(divisors [x]\n                (filter #(zero? (rem x %)) (range 1 x)))\n              (multiples [n]\n                (take-while #(<= % x)\n                            (map (partial * n) (drop 1 (range)))))]\n        (count (reduce #(remove (set (multiples %2)) %1)\n                       (range 1 x)\n                       (drop 1 (divisors x)))))))","user":"5974d2ede4b01722bebd4cb6"},{"problem":75,"code":"(fn [x]\n  (letfn [(gcd [a b] (if (= b 0) a (gcd b (rem a b))))]\n    (if (= x 1) 1 (count (filter #(= % 1) (map #(gcd x %) (range 1 x)))))))","user":"57002b81e4b08d47c97781c7"},{"code":"(fn tot [n]\n\t(letfn [(gcd [a b]\n\t\t\t(if (= 0 b)\n\t\t\t\ta\n\t\t\t\t(gcd b (rem a b))\n\t\t\t)\n\t\t)]\n\t\t(reduce\n\t\t\t(fn [s k]\n\t\t\t\t(if (= 1 (gcd n k))\n\t\t\t\t\t(inc s)\n\t\t\t\t\ts\n\t\t\t\t)\n\t\t\t)\n\t\t\t0 (range 1 (inc n))\n\t\t)\n\t)\n)","problem":75,"user":"511cca27e4b00c2a1fa7ff7d"},{"code":"#(case (mod % 8)\n  0 16\n  1 1\n  2 4\n  60)","problem":75,"user":"50142490e4b07d18bdaaf70a"},{"problem":75,"code":"(let [gcd (fn g [a b] (if (= 0 b) a (recur b (mod a b))))]\n     (fn [n]\n         (if (= n 1) 1\n             (->> (range 1 n)\n                  (filter #(= 1 (gcd % n)))\n                  (count)))))","user":"559c13c5e4b066d22e731f61"},{"code":"(fn [n]\n  (letfn [(gcd [a b] \n  (cond\n    (= a b) a\n    (> a b) (gcd (- a b) b)\n    (< a b) (gcd a (- b a))\n  )\n  )]\n  (if (= n 1) 1\n  (count (filter #(= % 1) (map gcd (range 1 n) (repeat n n))))\n  ))\n)","problem":75,"user":"4f8b56dae4b02e764a0a517e"},{"problem":75,"code":"(fn [x]\n  (letfn [(factors [x] (filter #(zero? (rem x %)) (range 1 (inc x))))\n          (gcd [a b] (apply max (clojure.set/intersection\n                                  (set (factors a))\n                                  (set (factors b)))))\n          (coprime? [a b] (= 1 (gcd a b)))\n          (num_coprimes [x] (count (filter #(coprime? x %) (range 1 x))))]\n    (if (= 1 x)\n      1\n      (num_coprimes x))))","user":"5573ffb5e4b0aa18f790f3fd"},{"problem":75,"code":"(fn [x]\n  (let [gcd (fn [a b] (if (= b 0) a (recur b (mod a b))))]\n    (->> (range 1 (inc x))\n         (filter #(= 1 (gcd x %)))\n         (count))))","user":"5cb41c40e4b026601754b911"},{"problem":75,"code":"(fn co-primes \n   ([n]\n    (if (= n 1) 1\n        (count (filter (partial co-primes n) (range 1 n)))))\n   ([p p']\n    (empty? (filter #(every? zero? [(mod p %)\n                                    (mod p' %)]) \n                    (range 2 (inc (min p p')))))))","user":"4e38f245535deb9a81d77f3e"},{"code":"(fn euler-totient [x]\r\n  (letfn [(gcd [x y]\r\n            (if (zero? x)\r\n              y\r\n              (recur (mod y x) x)))]\r\n    (if (= x 1)\r\n      1\r\n      (loop [an 0 ns (range 1 x)]\r\n        (if (empty? ns)\r\n          an\r\n          (let [f (first ns)]\r\n            (if (= 1 (gcd f x))\r\n              (recur (inc an) (rest ns))\r\n              (recur an (rest ns)))))))))","problem":75,"user":"4dd62278535d2dad7130b5c7"},{"problem":75,"code":"(fn totient [n]\n    (letfn [\n        (gcd [m n]\n            (if (zero? n) m (gcd n (mod m n))))]\n    (count (filter #(= (gcd % n) 1) (range 1 (inc n))))))","user":"54e540c1e4b024c67c0cf7f9"},{"code":"(fn [n]\r\n  (->> (range 2 n)\r\n    (filter (fn [x]\r\n              (= 1 ((fn gcd [a b]\r\n                      (if (= 0 b) a (gcd b (mod a b))))\r\n                    x n))))\r\n    (count)\r\n    (inc)))","problem":75,"user":"4dc986d0535d5973398f9285"},{"problem":75,"code":"(fn [n]\n    (letfn\n      [\n        (gcd [a b]\n          (if\n            (zero? b)\n            a\n            (recur\n              b\n              (mod a b)\n            )\n          )\n        )\n\n        (comprime? [a b]\n          (=\n            (gcd a b)\n            1\n          )\n        )\n      ]\n      (if\n        (= n 1)\n        1\n        (count\n          (filter\n            (partial comprime? n)\n            (range n)\n          )\n        )\n      )\n    )\n  )","user":"5784e177e4b0ebec4cfb74cf"},{"code":"(fn [n]\n  (inc \n    (count\n      (loop [t 2 l (range t n)]\n        (if t\n          (let [d #(zero? (mod % t))\n                l* (if (d n) (remove d l) l)]\n            (recur (first (filter #(> % t) l*)) l*))\n          l)))))","problem":75,"user":"4f06dcad535dcb61093f6c16"},{"problem":75,"code":"(fn euler [x] \n  (if (= 1 x)\n    1\n  (->>\n    (for [cand (range 2 x) \n          divisor (filter #(= 0 (mod x %)) (range 2 x)) :when (= 0 (mod cand divisor))]\n      cand)\n    (into #{})\n    (count)\n    (- (dec x))\n  )))","user":"57011eb3e4b08d47c97781d1"},{"code":"(fn [x]\n     (let [factors (loop [n x i 2 result #{}]\n\t\t\t    (if (<= i (/ n i))\n\t\t\t\t(if (zero? (rem n i))\n\t\t\t\t    (recur (/ n i) i (conj result i))\n\t\t\t\t    (recur n (inc i) result))\n\t\t\t\t(if (> n 1)\n\t\t\t\t    (conj result n)\n\t\t\t\t    result)))\n\t\ttotient (fn [n s]\n\t\t\t    (loop [s s result n]\n\t       (if (empty? s)\n\t\t   result\n\t\t   (recur (rest s) (* result (- 1 (/ 1 (first s))))))))]\n\t     (totient x factors)))","problem":75,"user":"4f066916535dcb61093f6c10"},{"problem":75,"code":"(fn totient [n]\n  (let [step\n        (fn [n r p]\n          (if (= 0 (mod r p))\n            (recur (* (dec p) (/ n p)) (->> (iterate #(/ % p) r) (take-while integer?) (last)) (inc p))\n            (if (> r 1)\n              (recur n r (inc p))\n              n)))]\n    (step n n 2)))","user":"5953bdb6e4b066ee0a44aeed"},{"problem":75,"code":"(fn [n]\n  (case n\n    1 1\n    (->> n\n       (range 1)\n       (filter (partial (fn [n m] (== ((fn [a b] (if (zero? b) a (recur b (mod a b)))) n m) 1)) n))\n       (count))))","user":"54d7e277e4b0a52adc2e2031"},{"code":"(fn [n]\n  (letfn [(gcd [a b]\n            (loop [a a b b]\n              (if (zero? b) a (recur b (mod a b)))))]\n    (count (filter #(= 1 (gcd n %)) (range 1 (inc n))))))","problem":75,"user":"527cd633e4b0757a1b17136f"},{"code":"(fn [n]\n  (max\n    1\n    (let [cp (fn [x y] (if (zero? y) (= 1 x) (recur y (mod x y))))]\n      (count\n        (filter #(cp n %) (range 1 n))))))","problem":75,"user":"4f4e91a9e4b03ad3f0c10cca"},{"code":"(fn [n]\n   (if (= n 1) 1\n       (let [gcd (fn [a b]\n                   (if (= 0 (mod a b))\n                     b\n                     (recur b (mod a b))))]\n     (count (filter #(= 1 (gcd n %)) (next (range n)))))))","problem":75,"user":"4eb02674535d7eef30807338"},{"problem":75,"code":"(fn tot [n]\n  (let [common-div? (fn [x y n]\n                       (if (and\n                            (= (rem x n) 0)\n                            (= (rem y n) 0))\n                         true false))\n        gcd (fn [x y]\n              (if (= x y 1)\n                1\n                (apply max (filter #(common-div? x y %) (range 1 y)))))\n        co-prime? (fn [x y]\n                    (if (= 1 (gcd x y))\n                      true false))\n        range (fn [n] (if (= n 1)\n                       (range 1 2)\n                       (range 1 n)))]\n    (->>\n     (filter #(co-prime? % n) (range n))\n     (count))))","user":"505d1b01e4b0e6aca564be04"},{"problem":75,"code":"(fn getfactors [x] (letfn [(getfactors [x] (set (filter #(= (mod x %) 0) (range 1 (inc x)))))]\n                      \n                      (count(filter #(= #{1} %) \n                            (map (partial clojure.set/intersection (getfactors x)) \n                                 (map getfactors (range 1 (inc x))))))))","user":"56ede653e4b04a395b9a0449"},{"problem":75,"code":"(let\n  [gcd\n   (fn gcd [a b]\n     (cond\n      (= a 0) b\n      (> a b) (recur b a)\n      :else (recur (mod b a) a)))\n   coprime? (fn [a b] (= 1 (gcd a b)))\n   ]\n  #(count (filter (partial coprime? %) (range %)))\n  )","user":"6045582fe4b02d28681c77b6"},{"code":"(fn  [n]\n  (let [gcd (fn [x y]\n  (cond\n   (= x 0) y\n   (= y 0) x\n   (> x y) (recur y (rem x y))\n   true  (recur x (rem y x))))]\n  (count\n   (filter  #(= (gcd % n) 1) (range 1 (inc n))))))","problem":75,"user":"4f38d6bbe4b0e243712b1ee2"},{"problem":75,"code":"(fn totient [x]\n  (case x\n    1 1\n    (letfn [(greatest-common-divisor [x y]\n              (let [[smaller larger] (sort [x y])\n                    candidates (reverse (range 1 (inc smaller)))]\n                (first (filter #(every? identity (map (comp (fn [num] (zero? num))\n                                                            (fn [num] (rem num %))) [x y]))\n                               candidates))))]\n      (count (filter (comp (partial = 1) (partial greatest-common-divisor x)) (range 1 x))))))","user":"53504fe6e4b084c2834f4ada"},{"code":"(fn [n]\n  (if (= n 1) 1\n    (letfn [(gcd [x y] (if (zero? y) x (recur y (mod x y))))\n            (isCoprime [i] (= (gcd i n) 1))]\n      (count (filter isCoprime (range 1 n)))\n      )))","problem":75,"user":"4fbbcf0ce4b081705acca2ee"},{"problem":75,"code":"(fn [n]\n  (letfn [(gcd [a b] \n            (cond (= b 0) a\n                  :else (gcd b (mod a b))))]\n    (count (filter (partial = 1) (map (partial gcd n) (range n))))))","user":"54e24a05e4b024c67c0cf7ce"},{"code":"(fn [x] \r\n   (if (= x 1)\r\n     1\r\n   (count (filter \r\n     (fn [n] \r\n       (= 1 ((fn gcd [a b] \r\n            (last (filter \r\n              #(and (zero? (mod a %)) (zero? (mod b %))) \r\n              (range 1 (inc (min a b)))))) n x))) \r\n     (range 1 x)))))","problem":75,"user":"4feada56e4b0140c20fb9c11"},{"problem":75,"code":"(fn [i]\n  (letfn [(d [x]\n             (into #{x} \n                   (filter #(zero? (rem x %)) \n                                (range 2 x))))]\n    (->> (range 2 i)\n         (remove #(some (d i) (d %)))\n         count\n         inc)))","user":"53ea5851e4b036ad0777e4e4"},{"problem":75,"code":"(fn [n]\n   (let [gcd (fn gcd [a b]\n               (if (= b 0)\n                 a\n                 (gcd b (mod a b))))]\n     (->> (range 2 n)\n          (filter #(= 1 (gcd % n)))\n          count\n          inc)))","user":"55630cc1e4b0c656e3ff17e0"},{"problem":75,"code":"(fn [n]\n    (if (= n 1)\n      1\n      (letfn [(gcd [a b]\n                (cond\n                  (zero? b) a\n                  (> a b) (recur b (mod a b))\n                  :else (recur a (mod b a))))]\n        (count (filter #{1} (map (partial gcd n) (range 1 n)))))))","user":"55c5b55fe4b0e31453f649b5"},{"problem":75,"code":"(fn [n]\n  (let [gcd (fn [x y] (if (zero? y) x (recur y (rem x y))))]\n    (count (filter\n            #(= 1 ((partial gcd n) %))\n            (range n)))))","user":"56cf115de4b0ea9b8538f765"},{"problem":75,"code":"(fn [number] (->> (range 2 number)\n                   (map (partial (fn [a b] (every? false? (map #(= 0 (mod a %) (mod b %)) (range 2 (inc (min a b)))))) number))\n                   (filter true?)\n                   count\n                   inc))","user":"54db3d82e4b024c67c0cf75f"},{"problem":75,"code":"#(count\n  (for [i (range %)\n        :let [y (+ i 1)\n              g ((fn gcd [a b] (if (zero? (mod a b)) b (recur b (mod a b)))) y %)]\n        :when (= g 1)]\n    y))","user":"53b7aa6ce4b047364c0444d1"},{"code":"(fn __ [n]\n  (let [\n     factors\n        (fn [x]\n  \t\t(set (filter #(zero? (rem x %)) (range 1 (inc x))))\n        )\n\n     is-coprime? \n        (fn [x y]\n\t\t\t(= 1 (count (clojure.set/intersection (factors x) (factors y))))\n        )\n   ]\n   \t(count (filter #(is-coprime? n %) (range 1 (inc n))))\n   )\n)","problem":75,"user":"503f872ee4b00d1a725ff2ac"},{"problem":75,"code":"(fn me [n]\n\n\t(let [gcd (fn [a b]\n\n\t\t\t\t(cond\n   \t\t\t\t\t(= a b) a\n   \t\t\t\t\t(> a b) (recur (- a b) b)\n   \t\t\t\t\t:else (recur a (- b a)))\n\t\t)]\n\n\t\t(if (= 1 n)\n\t\tn\n\t\t(count (filter #(= 1 (gcd n %)) (range 1 n) ))\n\n\t\t)\n\t)\n\n)","user":"55897fe2e4b059ccff29b205"},{"problem":75,"code":"(fn [n] (letfn [(gcd [a b] (if (zero? b) a (recur b (mod a b))))\n                (coprime-to-n? [a] (= 1 (gcd a n)))]\n          (if (= 1 n) \n            1\n            (->> (range 1 n)\n                 (filter coprime-to-n?)\n                 count))))","user":"56b86e64e4b0f26550335924"},{"problem":75,"code":"(fn [n]\n  (if (= n 1) 1\n  (let [gcd (fn [a b]\n              (loop [a a b b]\n                (cond (= a b) a\n                      (> a b) (recur (- a b) b)\n                      :else   (recur a (- b a)))))]\n    (count (filter #(= 1 (gcd n %)) (range 1 n))))))","user":"4f856adfe4b033992c121c44"},{"problem":75,"code":"(fn totient [n]\n  (letfn [\n    (gcd [a b]\n      (if (= b 0)\n        a\n        (recur b (mod a b))))\n    (coprime? [a b]\n        (= 1 (gcd a b)))]\n    (cond\n      (= n 1) 1\n      :else (->>\n        (map #(coprime? n %) (range 1 n))\n        (filter true?)\n        (count)))))","user":"587a3babe4b01531a375eae2"},{"problem":75,"code":"(fn [n]\n  (reduce\n   #(if (seq (filter \n               (fn [x] (and (zero? (mod n x))\n                            (zero? (mod %2 x))))\n               (range 2 (inc  %2))))\n      % (inc %))\n   1 (range 2 n)))","user":"53572176e4b04ce2eb3ed276"},{"problem":75,"code":"(fn my-eulers-totient [number]\n  (let [euclid (fn [a b]\n                (if (= b 0)\n                  a\n                  (recur b\n                         (mod a b))))]\n  (->> (range 1 (inc number))\n       (map (partial euclid number))\n       (filter (partial = 1))\n       (count))))","user":"567c7fefe4b05957ce8c61bc"},{"problem":75,"code":"(fn [n]\n  (if (= n 1)\n    1\n    (letfn \n      [(gcd [a b]\n         (if (zero? b)\n           a\n           (gcd b (mod a b))))]\n      (count (filter #(= (gcd % n) 1) (range 1 n))))))","user":"57d9bca1e4b0bd073c202405"},{"problem":75,"code":"(fn [n]\n  (if (= 1 n)\n    1\n    (let [gcd (fn [x y] (if (zero? y) x (recur y (mod x y))))]\n      (count (filter #(= 1 (gcd % n)) (range 1 n))))))","user":"597dcb0ce4b0dbe32238d0a2"},{"problem":75,"code":"(fn [x]\n  (letfn [(gcd [a b]\n            (if (= b 0)\n              a\n              (recur b (rem a b))))]\n    (->>\n     (range 2 x)\n     (map #(gcd % x))\n     (filter #(= % 1))\n     count\n     inc)))","user":"55586905e4b0deb715856e2b"},{"code":"(fn [m]\n  (letfn [(gcd [a b] (if (zero? b) a (recur b (mod a b))))\n          (cop [a b] (= 1 (gcd a b)))]\n    (count (filter true? (for [x (range 1 (if (= m 1) 2 m))] (cop m x))))))","problem":75,"user":"4f4ba29ae4b03ad3f0c10c7a"},{"problem":75,"code":"(fn totient [n]\n  (let [gcd (fn gcd [a b]\n             (let [x (max a b)\n                   y (min a b)\n                   r (rem x y)]\n               (if (= r 0) y (gcd y r))))]\n    (if (= n 1) 1\n      (->> (range 1 n)\n           (map (partial gcd n))\n           (filter (partial = 1))\n           count))))","user":"5396c94be4b0b51d73faaee3"},{"code":"(fn [x]\n  (letfn\n    [\n     (gcd [a b]\n          (if (= b 0)\n            a\n            (gcd b (mod a b))\n            )\n          )\n     ]\n    (count (filter #(= (gcd x %) 1) (range 1 (inc x))))\n    )\n  )","problem":75,"user":"52586d24e4b0cb4875a45cb0"},{"problem":75,"code":"(fn [n]\n  (if (= 1 n) \n    1\n    (letfn [(gcd [x y]\n              (let [re (rem x y)]\n                (if (= 0 re)\n                  y\n                  (recur y re))))]\n      (count (filter #(= 1 (gcd % n))\n                     (range 1 n))))))","user":"54848141e4b0e286459a119e"},{"code":"(fn eul-tot\n  [number]\n  (let [divs (fn [n] (filter #(zero? (mod n %)) (range 2 (inc n))))\n        coprime? (fn [a b] (not-any? #(zero? (mod a %)) (divs b)))\n        possibles (range 1 (inc number))]\n      (count (filter (partial coprime? number) possibles))))","problem":75,"user":"52b4d8fae4b0c58976d9ad33"},{"code":"(fn totient [n]\n   (letfn\n       [(gcd [a b]\n         (if (= 0 b) a\n             (gcd b (mod a b))))]\n   (count (filter #(= 1 (gcd n %)) (range n)))))","problem":75,"user":"529ce629e4b04e0c58e87b6e"},{"code":"(fn [x]\n  (let [gcd (fn [a b]\n             (cond\n              (= b 0) a\n              (= a 0) b\n              (> a b) (recur b (mod a b))\n              :else (recur a (mod b a))))\n        coprime? #(= (gcd % x) 1)]\n       (if (= 1 x) 1\n         (count (filter coprime? (range 1 x))))))","problem":75,"user":"4f05ea25535dcb61093f6c02"},{"problem":75,"code":"(fn [x]\n  (letfn [\n    (gcd [a b]\n      (cond\n        (< a b) (gcd a, (- b a))\n        (> a b) (gcd (- a b), b)\n        :else a))\n    (coprime? [a b] (= 1 (gcd a b)))]\n    (if (= x 1)\n      1\n      (count (filter (partial coprime? x) (range 1 x))))))","user":"55d5e80ee4b0e31453f64a91"},{"problem":75,"code":"(letfn [(gcd [a b]\n            (if (zero? b)\n              a\n              (gcd b (mod a b))))]\n    (fn [n]\n      (if (= n 1) 1\n          (->> (range 1 n)\n               (filter #(= (gcd n %) 1))\n               (count)))))","user":"5777cffae4b0979f89651651"},{"code":"(fn [n]\n  (if (= 1 n)\n    n\n    (letfn [(gcd [p q]\n              (if (zero? q)\n                p\n                (gcd q (mod p q))))]\n\n      (count (filter #(= 1 (gcd % n)) (range 1 n))))))","problem":75,"user":"515a6151e4b0394f658fe241"},{"problem":75,"code":"(fn [n]\n  (let [g (fn g [a b]\n           (if (= b 0)\n             a\n             (g b (rem a b))))]\n    (count (filter #(= 1 (g n %)) (range 1 (inc n))))))","user":"545ddac3e4b01be26fd74676"},{"code":"(fn [n]\n  (letfn [(gcd [a b] (if (zero? b) a (recur b (mod a b))))]\n    (if (= n 1)\n      1\n      (count (filter #(= (gcd n %) 1) (range 1 n))))))","problem":75,"user":"500ff421e4b0ae202717946f"},{"problem":75,"code":"(fn [n]\n  (let [gcd (fn [n1 n2] (if (= n2 0) n1 (recur n2 (rem n1 n2))))]\n    (if (= n 1)\n      \t1\n\t    (->> (range 1 n)\n    \t     (filter #(or (= 1 %) (= (gcd n %) 1)))\n        \t count))))","user":"542c22bde4b0dad94371f29e"},{"code":"(fn [x]\n  (letfn [(coprime? [n] (= (numerator (/ n x)) n))]\n    (if (= x 1)\n      1\n      (->> x\n           (range 1)\n           (filter coprime?)\n           count))))","problem":75,"user":"4fd11132e4b04c3a95aa0409"},{"code":"(fn [n]\n   (letfn [(gcd [a b] (if (= 0 b) a (recur b (rem a b))))]\n     (->> (range 1 (inc n))\n          (map #(* (gcd % n) (Math/cos (* 2 Math/PI (/ % n)))))\n          (reduce +)\n          (format \"%.0f\")\n          Integer/parseInt)))","problem":75,"user":"4e9fd521535d7eef3080729a"},{"code":"(fn [n]\n  (letfn [(coprime? [a b]\n            (= 1 (gcd a b)))\n          (gcd [a b]\n            (if (zero? b)\n              a\n              (recur b (rem a b))))]\n          (count (filter (partial coprime? n)\n                         (range 1 (inc n))))))","problem":75,"user":"4f969a66e4b0dcca54ed6cde"},{"problem":75,"code":"(fn [n]\n  (if (= n 1) 1\n    (letfn [(coprime? [n1 n2]\n      (not-any? #(and (zero? (mod n1 %)) (zero? (mod n2 %))) (range 2 (inc n1))))]\n      (count (filter #(coprime? % n) (range 1 n))))))","user":"5d9c1226e4b0d3f9b434ad51"},{"problem":75,"code":"(fn [n]\n  (let [gcd (fn gcd [number1 number2]\n              (let [n1 (max number1 number2)\n                    n2 (min number1 number2)]\n                (if (= n2 0)\n                  n1\n                  (recur n2 (mod n1 n2)))))]\n    (if (= n 1)\n    1\n    (loop [i 0 found 0]\n      (cond \n        (= i n) found\n        (= 1 (gcd i n)) (recur (inc i) (inc found))\n        :else (recur (inc i) found))))))","user":"608ec5e4e4b03bd49d9f36c0"},{"code":"(fn [n]\n  (loop [cand (range 2 n) ret 1]\n    (cond\n      (empty? cand) ret\n      (zero? (rem n (first cand)))\n        (recur \n          (remove \n            #(zero? (rem % (first cand))) \n            (rest cand)) \n          ret)\n      :else\n        (recur (next cand) (inc ret)))))","problem":75,"user":"4f050dec535dcb61093f6bef"},{"code":"(fn totient [n]\n  (let [divisors (fn [m]\n                   (for [x (range 2 m)\n                         :when (== (mod m x) 0)]\n                     x))\n        iscoprime (fn [m]\n                    (not (seq (filter #(== (mod m %) 0) (divisors n)))))]\n    (if (== n 1)\n      1\n    (count (filter iscoprime (range 1 n))))))","problem":75,"user":"532727bae4b09d4e7a9b54fa"},{"code":"(fn [x] (count (remove (fn [y] (some #(= 0 (mod x %) (mod y %)) (range 2 (inc y)))) (range 1 (inc x)))))","problem":75,"user":"4f045946535dcb61093f6bba"},{"problem":75,"code":"(fn me [n]\n  (letfn [(gen-coprimes [n]\n            (coprimes-step 2 (into #{1} (range 2 n))))\n            (coprimes-step [i possibles]\n              (if (>= i n)\n                possibles\n                (recur\n                 (inc i)\n                 (if (= 0 (rem n i))\n                   (sieve-multiples i possibles)\n                   possibles))))\n          (sieve-multiples [i possibles]\n              (let [factors (into #{} (range i n i))]\n                (clojure.set/difference possibles factors)))]\n      (->> (gen-coprimes n)\n           (count))))","user":"5c219c0fe4b07e362c230581"},{"problem":75,"code":"(fn f [n]\n  (let [factor? (fn [a b] (zero? (rem a b)))\n        gcd (fn [a b] (->> (range 1 (inc (min a b)))\n                           (reverse)\n                           (filter #(factor? a %))\n                           (filter #(factor? b %))\n                           (first)))\n        coprime? (fn [a b] (= 1 (gcd a b)))]\n  (->> (range 1 (max n 2))\n       (filter #(coprime? n %))\n       (count))))","user":"57adbe7ee4b0b8559636fca0"},{"problem":75,"code":"(fn foo [n]\n    (letfn [(gcd [a b] (if (= a b) a (if (< a b) (gcd a (- b a)) (gcd (- a b) b))))]\n        (if (= n 1)\n            1\n            (count (filter #(= (gcd % n) 1) (range 1 n))))))","user":"600ae927e4b074f607df6689"},{"code":"(fn [x]\n  (letfn [(gcd      [x y] (if (zero? y) x (gcd y (mod x y))))\n          (coprime? [x y] (= 1 (gcd x y)))]\n    (if (= x 1)\n      1\n      (count (filter #(coprime? x %) (range 1 x))))))","problem":75,"user":"50586354e4b06522596eba78"},{"problem":75,"code":"(fn [n]\n  (let [gcd \n    (memoize (fn [a b]\n      (if (< a b) (recur b a)\n        (if (= b 0) a\n          (recur b (- a b))))))]\n   (max 1 (count (filter #(= % 1)\n      (map gcd (range 1 n) (repeat (- n 1) n)))))))","user":"546ff835e4b00cfc9eacc1b4"},{"code":"(fn totient [x]\n  (if (= x 1)\n    1\n    (let\n      [gcd\n        #(if (= 0 (rem %2 %1))\n          %1\n          (recur (rem %2 %1) %1))\n      coprime-to-x\n        #(= 1 (gcd %1 x))]\n      (count (filter coprime-to-x (range 1 x))))))","problem":75,"user":"4fe8b6afe4b07c9f6fd12c76"},{"problem":75,"code":"(fn num-coprimes [n] \n  (let [divides #(zero? (rem % %2))\n        coprime (fn [larger smaller] (not-any? #(and (divides larger %) (divides smaller %)) (range 2 larger)))] \n    (if (= 1 n) 1 (count (filter (partial coprime n) (range 1 n))))))","user":"549c3e0ce4b0f3d1d8e70f87"},{"code":"(fn totient [x]\n  (letfn [(factor [n]\n            (loop [n n d 2 acc []]\n              (cond \n                (= n 1) acc\n                (= 0 (mod n d)) (recur (quot n d) d (conj acc d))\n                :else (recur n (inc d) acc))))]\n    (let [factors (set (factor x))]\n      (reduce * x (map (fn [p] (/ (dec p) p)) factors)))))","problem":75,"user":"4ed188c8535d44c135fd68cf"},{"code":"(fn totient [x]\n  (letfn [(gcd [x y]\n            (if (zero? y) x\n                (recur y (mod x y))))]\n    (count (filter #(= 1 (gcd x %)) (range 1 (inc x))))))","problem":75,"user":"5300158ae4b0d8b024fd370f"},{"code":"(fn [n] \n  (letfn [(gcd [x y] (if (= y 0) x (recur y, (mod x y))))]\n    (if (= n 1) \n      1\n      (->> (range 1 n)\n           (filter #(= (gcd % n) 1))\n           (count)))))","problem":75,"user":"536ca4bde4b0fc7073fd6e49"},{"problem":75,"code":"#(cond\n    (= % 1) 1\n    (> % 1) (let [gcd (fn [x y] (if (zero? y) x (recur y (mod x y))))]\n              (count (filter (fn [a] (= 1 (gcd % a))) (range 1 %)))))","user":"56372c3ce4b0bfe05bf117d1"},{"code":"(fn [n]\n           (if (= 1 n)\n               1\n               (count (filter #(= 1 (loop [a % b n]\n                                       (if (zero? b)\n                                           a\n                                           (recur b (mod a b))))) (range 1 n)))))","problem":75,"user":"4f34eb87e4b0e243712b1eba"},{"problem":75,"code":"(fn totient[n] (let [gcd (fn [larger smaller] ; 5 0\n\t\t(if (or (= larger smaller) (<= smaller 1)) smaller (let [\n\t\t\tnext (int (mod larger smaller)), ; 0\n\t\t\tnext_smaller (min next smaller) ; 0\n\t\t\tnext_larger (max next smaller) ; 5\n\t\t] (recur next_larger next_smaller)\n\t\t))\n\t)]\n\t(loop [i (dec n), coprimes []]\n\t\t(if (<= i 1)\n\t\t\t(count (conj coprimes 1))\n\t\t\t(recur\n\t\t\t\t(dec i),\n\t\t\t\t(if (= (gcd n i) 1) (conj coprimes i) coprimes)\n\t\t\t)\n\t\t)\n\t)\n))","user":"5d73530ce4b02e6b30c93514"},{"code":"(fn et [x]\n  (let [gcd (fn gcd [x y] (cond \n                        (= x y) x\n                        (> x y) (gcd y (- x y))\n                        (> y x) (gcd y x)))\n        coprime? #(= (gcd x %) 1)]\n    (case x\n      1 1\n      (count (filter coprime? (range 1 x))))))","problem":75,"user":"52d39033e4b099d49816f0c6"},{"problem":75,"code":"(fn [n]\n  (let [isCoprime (fn [a b]\n                    (let [gcd (fn gcd [a b]\n                                (if (= 0 (mod a b))\n                                  b\n                                  (gcd b (mod a b))))]\n                      (= 1 (gcd a b))))]\n    (if (= 1 n)\n      1\n      (count (filter (partial isCoprime n) (range 1 n))))))","user":"5cf895efe4b0b71b1d808a85"},{"code":"(fn [n] (if (= 1 n) 1 (letfn [\n                (gcd [x y] \n                     (if (= 0 (* x y)) \n                       (+ x y) \n                       (gcd (- (max x y) (min x y)) (min x y) ))) ]\n             (count (filter #(= (gcd % n) 1) (range 1 n))))))","problem":75,"user":"50fbdacfe4b0d10d794c19f0"},{"code":"(fn [n]\n   (let [gcd (fn [a b] (if (zero? b) a (recur b (mod a b))))\n         ]\n     (count (filter #(= (gcd % n) 1) (range 1 (inc n))))\n     ))","problem":75,"user":"4fbfe9a4e4b081705acca31f"},{"problem":75,"code":"(fn f[x] \n  ( loop [ i 2 ds #{} n 1 ]\n    (if (>= i x)\n      n\n      (if (not-empty (filter #(= 0 (rem i %))ds))\n        (recur (inc i) ds n)\n        (if (= 0 (rem x i))\n          (recur (inc i) (conj ds i) n)\n          (recur (inc i) ds (inc n))\n          )\n        )\n      )\n    )\n  )","user":"5b3aa98be4b02d533a91bbca"},{"problem":75,"code":"(fn [x]\n  (count (filter #(every? true? %) \n                 (for [y (range 1 (inc x))]\n                   (for [z (range 1 (inc y))]\n                     (cond (= y 1) true\n                           (= z 1) true\n                           (= y x) false\n                           :else (not (= 0 (mod x z) (mod y z)))))))))","user":"55d74e71e4b0e31453f64aa4"},{"code":"(fn totien[n]\n  (let [coprime (fn [x y] (every? false? (map #(and (= 0 (mod x %)) (= 0 (mod y %))) (range 2 (inc(min x y ))) ))) ]\n    (if (= n 1)\n    1\n    (count (filter #(coprime n %) (range 1 n)) ))\n   )\n  \n  )","problem":75,"user":"503c02e5e4b0fc0f99c2e54e"},{"code":"(fn [x]\n  (if (= 1 x)\n    1\n    (letfn [(gcd [a b]\n              (if (zero? b)\n                a\n                (gcd b (mod a b))))\n            (coprime? [a b]\n              (= 1 (gcd a b)))]\n      (count (filter #(coprime? x %) (range 1 x))))))","problem":75,"user":"4e80aa10535db62dc21a62b1"},{"problem":75,"code":"(fn [nn]\n  (let [gcd (fn [a b]\n                 (cond\n                  (= a b) a\n                  (> a b) (recur b (- a b))\n                  (< a b) (recur a (- b a))))]\n   (->> (inc nn)\n  (range 1)\n  (filter #(= 1 (gcd nn %)))\n  (count))\n  ))","user":"593f95d8e4b069cdc2982be3"},{"problem":75,"code":"(fn [n]\n  (if (= n 1) 1 \n    (count (filter #(let [gcd (fn g [a b] (if (zero? b) a (g b (mod a b))))] \n                      (= 1 (gcd n %))) \n                   (range 1 n)))))","user":"5835cb06e4b089d5ab817cea"},{"problem":75,"code":"(fn totient  [x]\n  (letfn [(gcd [x y] (if (zero? y) x (recur y (mod x y))))]\n    (if (= x 1) 1\n      (count (filter #(= % 1) (map gcd (repeat x) (range 1 x)))))))","user":"571c2babe4b07c98581c3b73"},{"problem":75,"code":"(fn f [n] (if (= n 1) 1 (count(filter #(= (denominator %) n) (map / (range 1 n) (repeat n)) ))))","user":"53b3ea79e4b047364c0444ab"},{"problem":75,"code":"(let [gcd1 (fn [x y]\n                  (if (= x 1)\n                    true\n                    (let [max (min x y)]\n                      (loop [n 2]\n                        (if (= (mod x n) (mod y n) 0)\n                          false\n                          (if (= max n)\n                            true\n                            (recur (inc n))))))))]\n       (fn [x]\n         (if (== x 1)\n           1\n           (loop [n 1\n                  cnt 0]\n             (if-not (< n x)\n               cnt\n               (recur (inc n) (if (gcd1 n x) (inc cnt) cnt)))\n             ))))","user":"52c58561e4b0c2d177d620f8"},{"problem":75,"code":"(fn totient [number]\n  (let [gcd\n        (fn [a b]\n          (if (zero? b)\n            a\n            (recur b (rem a b))))]\n    (loop [x number\n           total 0]\n      (if (zero? x)\n        total\n        (recur (dec x)\n               (if (= (gcd x number) 1)\n                 (inc total)\n                 total))))))","user":"58fed70de4b0438e51c2cfdd"},{"problem":75,"code":"#(let [gcd (fn [x y] (if (zero? y) x (recur y (mod x y)))) \n      coprime? (fn [x] (true? (= 1 (gcd x %))))] \n\t   (if (= 1 %) 1 (count (filter coprime? (range 0 %))))\n\t  )","user":"53fe1c3be4b0de5c418485f2"},{"problem":75,"code":"(fn [x]\n  (if (= x 1)\n    1\n    (let [divs (fn [n] (set (filter #(= 0 (mod n %)) (range 1 (inc n)))))\n          dxs (divs x)]\n      (->> x\n           (range 1)\n           (filter #(= #{1} (clojure.set/intersection dxs (divs %))))\n           count\n           ))))","user":"5fa17538e4b0f0ebd91b77e3"},{"problem":75,"code":"(fn totient2 [x]\n  (if (= x 1)\n    1\n    (count (filter #((fn [x y] (= ((fn [x y]\n                                     (if (= y 0)\n                                       x\n                                       (recur y (rem x y))))x y) 1)) x %) (range x)))))","user":"541f5b37e4b01498b1a71a97"},{"code":"(fn __ [x]\n  (let [gcd (fn [a b] (if (zero? b) a (recur b (mod a b))))\n        coprime? (fn [a b] (= 1 (gcd a b)))]\n    (if (= x 1)\n      1\n      (count (filter (partial coprime? x) (range 1 x))))))","problem":75,"user":"4ec9549d535d6d7199dd36fe"},{"code":"(fn [x]\n\t\t(let [gcd \n\t\t    (fn [a b] \n\t\t      (if (= b 0)\n\t\t\t      a\n\t\t\t      (recur b (mod a b))\n\t\t\t  ))]\n\t\t  (count (for [n (range x) :when (= (gcd n x) 1)] n))\n\t))","problem":75,"user":"52e3e6a8e4b09f7907dd1448"},{"problem":75,"code":"(fn eulers-totient [n]\n  (let [gcd (fn [a b]\n              (let [small (min a b)\n                    big (max a b)]\n                (if (= (mod big small) 0) small\n                  (recur small (mod big small)))))]\n    (loop [i 1 out 0]\n      (cond (> i n) out\n            (= (gcd i n) 1) (recur (inc i) (inc out))\n            :else (recur (inc i) out)))))","user":"551afdf8e4b07993ea3788cb"},{"problem":75,"code":"(fn [n]\n\t(let [gcd\n\t\t#(loop [x %1, y %2]\n\t\t\t(cond\n\t\t\t\t(= 0 x) y\n\t\t\t\t(> x y) (recur y x)\n\t\t\t\t:else (recur (rem y x) x)))]\n\t\t(count\n\t\t\t(filter\n\t\t\t\t#(= 1 (gcd % n))\n\t\t\t\t(range 1 (inc n))))))","user":"5370b386e4b0fc7073fd6e9b"},{"problem":75,"code":"(fn [x]\n   (let [divides (fn [a b] (zero? (rem b a)))\n         divisors (filter #(divides % x) (range 1 x))\n         common-divisors (fn [y] (filter #(divides % y) divisors))\n         rel-prime #(= [1] (common-divisors %))]\n     (if (= x 1)\n       1\n       (->> (range 1 x)\n            (filter rel-prime)\n            (count)))))","user":"53ed6976e4b0d648e757f4c4"},{"problem":75,"code":"(fn [x]\n   (letfn [(gcd [a b]\n                (if (zero? b)\n                  a\n                  (gcd b (mod a b))))]\n     (if (= 1 x)\n       1\n       (->> (range 1 x)\n            (map #(gcd x %))\n            (filter #(= 1 %))\n            (count)))))","user":"525cc912e4b0cb4875a45d48"},{"code":"(fn tot [x]\n    (if (= x 1)\n      1\n      (let\n          [gcd (fn gcd [left right]\n                 (if (= left right)\n                   left\n                   (if (> left right)\n                     (recur (- left right) right)\n                          (recur left (- right left))))) ]\n                          (count (filter #(= 1 (gcd % x)) (range 1 x))))))","problem":75,"user":"50057f23e4b0678c553fc466"},{"code":"(fn [n]\n  (letfn [(gcd [x y]\n            (cond (< y x) (recur y x)\n                  (= x 0) y\n                  :else (recur (mod y x) x)))]\n    (count (filter #(= 1 (gcd % n)) (range n)))))","problem":75,"user":"4ed94d69535d10e5ff6f5303"},{"problem":75,"code":"(fn euler-full\n  [num]\n  (loop [n num i 1\n         final 0]\n    (if (> i n)\n      final\n      (if (= 1 (->> (range 1 (+ 1 (min n i)))\n                      (filter #(and (= 0 (rem n %)) (= 0 (rem i %))))\n                      (apply max)))\n        (recur n (inc i) (inc final))\n        (recur n (inc i) final)))))","user":"5ac35d00e4b0e27600da7712"},{"code":"(fn totient [x]\n  (let [gcd (fn [x y]\n    (let [x* (new BigInteger (str x))\n          y* (new BigInteger (str y))]\n      (.. x* (gcd y*) (intValue))))]\n    (if (== x 1)\n      1\n      (->> (drop 1 (range x))\n           (filter #(== 1 (gcd % x)))\n           (count)))))","problem":75,"user":"4e691c79535d8ccf87e9fe97"},{"code":"(fn [x]\n  (count\n    (filter\n      #(= 1 ((fn nod [a b]\n        (if (zero? b)\n          a\n          (nod b (mod a b)))) x %))\n      (range x))))","problem":75,"user":"511f88eee4b085952a83535f"},{"code":"(fn [x]\n  (let [gcd (fn [a b] (if (zero? b) a (recur b (mod a b))))]\n    (if (= x 1) 1\n      (count (filter #(= 1 (gcd x %)) (range 1 x))))))","problem":75,"user":"510db6cde4b078ea71921145"},{"code":"(fn [n]\n  (let [gcd (fn [a b]\n              (if (or (zero? a) (zero? b))\n                (+ a b)\n                (recur (mod a b) (mod b a))))]\n    (if (= 1 n)\n      1\n      (count (filter #(= 1 (gcd % n)) (range 1 n))))))","problem":75,"user":"4edab806535d10e5ff6f5311"},{"problem":75,"code":"(fn\n  [x]\n  (let [divisors (fn [nbr] (set (filter #(zero? (mod nbr %)) (range 1 (inc nbr)))))\n        x-divisors (divisors x)\n        gcd-x (fn [y] (apply max (clojure.set/intersection x-divisors (divisors y))))\n        is-coprime-x? (fn [y] (= 1 (gcd-x y)))]\n    (count (conj (filter is-coprime-x? (range 2 x)) 1))))","user":"57625c18e4b0994c1922fba4"},{"code":"(fn totient [n]\n  (letfn [(gcd [a b] (ffirst\n  \t      (drop-while (fn [[a b]] (not= 0 b))\n\t\t\t\t  (iterate (fn [[a b]] [b (mod a b)]) [a b]))))]\n    (if (= 1 n) 1\n\t(count (filter #(= 1 %) (map (partial gcd n) (range 1 n)))))))","problem":75,"user":"4e513ecf535dc968683fc4f6"},{"code":"(fn  [x]\n  (letfn [( gcd [x y] (if (= y 0 ) x (gcd y (rem x y) )))]\n    (count (filter #(= 1 (gcd x %)) (range x)))))","problem":75,"user":"518c5236e4b087e178201de0"},{"code":"(fn [n2] (if (= n2 1) 1 (letfn [(cd [n] (set (reduce (fn [a b] (if (= 0 (rem n (inc b))) (conj a (inc b)) a)) [] (range n))))]\n                   (let [dv (cd n2)]\n                     (count (reduce (fn [a b] (if (= 1 (count (clojure.set/intersection dv (cd b)))) (conj a b) a)) [] (range n2)))\n                     )\n                   )))","problem":75,"user":"52c1bd29e4b07a9af579236a"},{"problem":75,"code":"(fn totient [i]\n  (if (= i 1) 1\n    (count\n      (filter\n        (fn [j]\n          (not-any?\n            (fn [k]\n              (= 0 (mod i k) (mod j k)))\n            (range 2 (inc j))))\n        (range 1 i)))))","user":"58247423e4b051871117bec5"},{"problem":75,"code":"(fn [n]\n  (letfn [(gcd [a b]\n            (letfn [(g [a b]\n                      (let [r (mod a b)]\n                        (if (zero? r)\n                          b\n                          (recur b r))))]\n              (g (max a b) (min a b))))]\n    (count (filter #(= 1 (gcd n %)) (range 1 (inc n))))))","user":"5764457ae4b0994c1922fbf3"},{"code":"(fn [x]\n  (let [gcd (fn gcd [a b]\n              (if (zero? b)\n                  a\n                  (gcd b (mod a b))))]\n    (if (= 1 x)\n        1\n        (count (filter #(= 1 (gcd x %))(range 1 x))))))","problem":75,"user":"4ee6400c535d93acb0a6685b"},{"code":"(fn [n]\n  (if (= n 1) 1\n  (let [coprime (fn [a b]\n                  (every? \n                    #(or (< 0 (mod a %)) (< 0 (mod b %)))\n                    (range 2 (inc b))))]\n    (count (filter #(coprime n %) (range 1 n))))))","problem":75,"user":"4fa30027e4b081705acca187"},{"problem":75,"code":"(fn totient [n]\n  (letfn [(gcd [a b] (if (zero? b) a (recur b (mod a b))))\n          (coprime? [a b] (= (gcd a b) 1))]\n    (count (filter #(coprime? % n) (range 1 (inc n))))))","user":"575b3e9be4b02ea11479935b"},{"code":"(fn [x]\n  (reduce\n    #(if (= 1\n      ((fn g [a b] (if (= 0 b) a (g b (mod a b)))) x %2)) (+ 1 %) %)\n    0\n    (range x)\n))","problem":75,"user":"5088082ae4b0198722bd9854"},{"problem":75,"code":"#(letfn [(divs [x] (set (filter (comp zero? (partial rem x))\n                                 (range 1 (inc x)))))]\n     (let [input-divs (divs %)]\n       (loop [num %\n              res 1]\n         (let [dec-num (dec num)]\n           (if (<= dec-num 1)\n             res\n             (recur dec-num\n                    (if (-> dec-num\n                            divs\n                            (clojure.set/intersection input-divs)\n                            (= #{1}))\n                      (inc res)\n                      res)))))))","user":"5ef8e9e0e4b09b61f08553cb"},{"code":"(fn [x]\n  (let [\n    factors (fn [y] (set (filter #(= 0 (rem y %)) (range 2 (inc y)))))\n    coprime? (fn [y] (or (= 1 y)\n      (< (count (filter (factors x) (factors y))) 1)))]\n    (if (= 1 x) 1\n      (count (filter coprime? (range 1 x))))))","problem":75,"user":"4f1b0ab3535d64f603146474"},{"problem":75,"code":"(fn [n]\n         (if (= n 1) 1\n           (let [divisors (memoize (fn [n]\n                                     (filter #(zero? (rem n %))\n                                             (range 2 (inc n)))))\n                 coprime (fn [i j]\n                           (->> (concat (divisors i) (divisors j))\n                                frequencies\n                                (filter #(> (last %) 1))\n                                count))\n                 ]\n            (count (filter (fn [i] (= 0 (coprime i n)))\n                           (range 1 n))))))","user":"53f592b7e4b0db01ade6f9d0"},{"code":"(fn [x] (let [gcd (fn gcd [a0 b0] (loop [a a0 b b0] (if (= b 0) a (recur b (mod a b)))))]\r\n                  (->> x\r\n                       (range 2)\r\n                       (filter #(= 1 (gcd x %)))\r\n                       (count)\r\n                       (inc)\r\n                       )))","problem":75,"user":"503d129fe4b06c4e0e1fa254"},{"code":"(comp inc\n      count\n      (partial filter (partial apply =))\n      (partial apply map)\n      (juxt (comp (partial apply juxt)\n                  (juxt (partial partial (comp last list))\n                        (partial partial (comp numerator *)))\n                  /)\n            (partial range 2)))","problem":75,"user":"4ef49c2c535dced4c769f238"},{"code":"(fn tot [x]\n     (if ( = x 1) 1\n     (letfn [ (divs  [nr]  (conj (set (filter #(= 0 (rem nr %)) (range 1 (inc nr)))) 1)) ]\n       (count (filter identity (for [ y (range 1 x) ]  (= #{1} (clojure.set/intersection (divs x) (divs y)))))))))","problem":75,"user":"4fccdc75e4b0ee37620e186d"},{"code":"(fn [x]\n  (if (= 1 x) 1\n    (let [gcd (fn [a b] (if (zero? b) a (recur b (mod a b))))]\n      (count (filter #(= 1 (gcd x %)) (range 1 x))))))","problem":75,"user":"51929214e4b08962174cf74c"},{"problem":75,"code":"(fn [n]\n  (letfn\n    [(gcd [a b]\n          (if (= a 0)\n            b\n            (gcd (mod b a) a)))]\n    (inc\n      (count\n       (filter #(= (gcd % n) 1)\n               (range 2 n))))))","user":"5da760ebe4b000c986472c1a"},{"problem":75,"code":"(fn euler [n]\n  (let [gcd (fn gcd [a b]\n              (if (< a b) (gcd b a)\n                  (if (= b 0) a\n                      (gcd b (mod a b)))))]\n    (->> (range 1 (+ 1 n))\n         (map #(gcd n %))\n         (filter #(= 1 %))\n         (apply +))))","user":"58fc92c5e4b0438e51c2cf9a"},{"code":"(fn  [x]\n  (let [rng (map inc (range x))\n        a (for [r rng\n                :let [rr (map inc (range r))]]\n            (into #{} (filter identity (map #(if (= 0 (mod r %)) %) rr))))\n        l (last a)\n        i (map #(clojure.set/intersection % l) a)]\n    (count (filter #(= 1 (count %)) i))))","problem":75,"user":"52f3af46e4b05e3f0be25f14"},{"problem":75,"code":"(fn [n]\n  (if (= n 1) 1\n  (letfn [(gcd [a b] (if (zero? b) a (gcd b (mod a b))))]\n    (->> (range 1 n) (filter #(= 1 (gcd n %))) count))))","user":"561ba3e5e4b073c65b0ce3eb"},{"problem":75,"code":"(fn [n]\n   (letfn [(gcd [m n]\n             (if (zero? n)\n               m\n               (recur n (mod m n))))]\n     (count\n      (filter #(= 1 (gcd n %))\n              (range n)))))","user":"5393185ae4b0b51d73faaeb7"},{"problem":75,"code":"(fn euler-totient\n  ([n]\n   (let [pgcd (fn gcd\n                ([a b]\n                 (if (= a 0)\n                   b\n                   (gcd (mod b a) a))))\n         coprime? (fn [a b] (= 1 (pgcd a b)))]\n     (if (= 1 n)\n       1\n       (->> (range n)\n            (filter (partial coprime? n))\n            (count))))))","user":"5bf5ddfde4b0bdcf453d159e"},{"code":"(fn phi [n]\n  (letfn [(gcd [a b] (if (zero? b) a (recur b (rem a b))))\n          (coprime [n m] (= (gcd n m) 1))]\n    (count (for [x (range 1 (inc n)) :when (coprime n x)] x))))","problem":75,"user":"4e7263a1535d5021c1a8965f"},{"problem":75,"code":"#(count (filter (fn [x] (= x 1)) (map (partial (fn gcd [x y] (if (= 0 x) y (gcd (mod y x) x))) %) (range %))))","user":"594d4c57e4b07ddc2dafae87"},{"problem":75,"code":"(fn [x]\n  (if (= x 1)\n    x\n    (let [gcd (fn gd [a b]\n              (if (zero? b)\n                a\n                (recur b (mod a b))))]\n      (count (filter #(= (gcd x %) 1) (range x))))))","user":"58844d43e4b0f1effa3b7696"},{"problem":75,"code":"(fn [n]\n  (letfn [(gcd\n            ([a b] \n             (gcd (sort [a b])))\n            ([[a b]] \n             (if (> b a) (gcd a (- b a)) a)))]\n    (if (= n 1) \n      1 \n      (count (filter #(= 1 (gcd n %)) (range 1 n))))))","user":"5712854ce4b07c98581c3a89"},{"code":"(fn [val]\n          (let [gcd (fn [a b] \n                        (if (zero? a)  \nb\n(recur (mod b a) a)))\n               ]\n               (->> (range 1 (inc val))\n                    (filter (fn [x] (= 1 (gcd x val))))\n                    count)))","problem":75,"user":"4dbb64c8535d1e037afb21b6"},{"problem":75,"code":"(fn [n]\n  (letfn [(gcd [a b]\n            (if (zero? b)\n              a\n              (recur b (mod a b))))]\n    (reduce (fn [acc mi]\n              (if (= 1 (gcd n mi))\n                (inc acc)\n                acc))\n            0\n            (range n))))","user":"57f80350e4b0d3187e90090c"},{"problem":75,"code":"(fn [x]\n  (if (= x 1)\n    1\n    (letfn [(divisors [n]\n              (set (filter #(= 0 (mod n %)) (range 1 (inc n)))))]\n    (count (filter #(= #{1}\n                       (clojure.set/intersection (divisors x) (divisors %))) (range 1 x))))))","user":"51db0d99e4b06aa4d4669a9d"},{"problem":75,"code":"(fn [n]\n  (letfn [(gcd [a b] (if (= b 0) a (gcd b (mod a b))))]\n    (if (= n 1) 1\n      (->> (range 1 (inc n)) \n           (map #(gcd n %)) \n           (filter #(= 1 %)) \n           count)\n     )\n  )\n)","user":"4fc8f671e4b0ee37620e1840"},{"code":"(fn [x]\n  (if (= x 1)\n    1\n  (let [gcd (fn [a b]\n              (if (zero? b)\n                a\n                (recur b (mod a b))))]\n    (count (filter #(= 1 (gcd % x))\n                   (range 1 x))))))","problem":75,"user":"4e7dd982535db169f9c796ee"},{"problem":75,"code":"(let [gcd (fn [a b]\n        (if (= b 0) \n          a\n         (recur b (mod a b))))]\n  (fn [n]\n    (if (= n 1)\n      1\n      (count (filter #(= (gcd n %) 1) (range 1 n)))\n      ))\n  )","user":"541ef7e2e4b01498b1a71a92"},{"code":"(fn [x] \n  (letfn [(gcd [a b] \n            (if (= 0 b) a (recur b (mod a b))))] \n    (count (filter #(= 1 (gcd % x)) (range x)))))","problem":75,"user":"4ed0e139535d44c135fd68c7"},{"code":"(fn totient ([n] (if (= n 1) 1 (totient n (range 1 n)))) ([n r] (count (filter #(= 1 %) (map #((fn gcd [a b] (loop [x (max a b) y (min a b)] (if (> (rem x y) 0) (recur y (rem x y)) y))) n %) r)))))","problem":75,"user":"5138d08be4b0a5db03d727db"},{"problem":75,"code":"(fn [x] (count (filter (fn [i] (when ((fn coprime [a b] (if (zero? b) (if (= 1 a) true false) (coprime b (mod a b)))) x i) i)) (range 1 (inc x)))))","user":"5addadfce4b0837691e92c13"},{"code":"(fn [n]\n  (letfn [\n    (gcd [n m]\n      (cond (= n m) n,\n            (> n m) (recur m (- n m)),\n            (< n m) (recur n (- m n))))\n    (coprime-n? [m]\n      (= (gcd n m) 1))]\n  (+ 1 (count (filter coprime-n? (range 2 n))))))","problem":75,"user":"4f62b29ce4b0defedf855fd9"},{"code":"(fn [n]\n  (let [gcd (fn [a b]\n              (if (zero? b)\n                a\n                (recur b (mod a b))))]\n  (count (filter #(= 1 (gcd % n)) (range n)))))","problem":75,"user":"4e42f930535dc968683fc49f"},{"problem":75,"code":"(fn [n]\n  (if (= n 1)\n    1\n    (let [gcd (fn [a b]\n              (if (zero? b)\n                a\n                (recur b (mod a b))))]\n      (count (filter #{1}\n                     (map\n                      (partial gcd n)\n                      (range 1 n)))))))","user":"5724a4dae4b0c5bde472c0fe"},{"code":"(fn totient [n]\n  (let [gcd (fn [a b] ; This is... Euclid's algorithm?\n              (cond\n                (or (= 1 a) (= 1 b)) 1\n                (= a b) a\n                (> a b) (recur (- a b) b)\n                :else (recur a (- b a))))]\n    (count (filter #(= 1 (gcd n %)) (range 1 (inc n))))))","problem":75,"user":"4e5fdd68535d8ccf87e9fe4f"},{"code":"(fn [n] \n (inc  (count \n    (for [x (range 2 n) :when \n (not-any? \n   #(and (zero? (mod x %) ) (zero? (mod n %) ))  \n   (range 2 n))] x))))","problem":75,"user":"503917a0e4b088a6a14ca763"},{"problem":75,"code":"(letfn [(gcd [a b]\r\n          (if (= 0 b) a\r\n              (recur b (rem a b))))\r\n        (coprime [a b] (= 1 (gcd a b)))]\r\n  (fn [n]\r\n    (if (= n 1) 1\r\n        (count (filter #(= 1 (gcd % n))\r\n                       (range 1 n))))))","user":"55d0e76ae4b0e31453f64a40"},{"problem":75,"code":"(fn [n]\n  (if (= n 1) 1\n  (letfn [(gcd [a b] (if (= b 0) a\n                       (gcd b (mod a b))))]\n    (count (filter #(= 1 (gcd % n)) (range 1 n))))))","user":"60264d89e4b0d5df2af2222d"},{"code":"(fn [n]\n  (letfn [(gcd [a b] \n               (let [x (max a b)\n                     y (min a b)]\n                 (if (zero? y)\n                   x\n                   (gcd y (mod x y)))))]\n  (cond\n   (= 1 n) 1\n   :else (->> (range 1 n)\n              (filter #(= 1 (gcd % n)))\n              count))))","problem":75,"user":"506617c3e4b03d366d7cb2ab"},{"problem":75,"code":"(fn test [x]\n  (letfn [(gcd? [a b]\n                (if (= a 0) b\n                  (recur (mod b a) a)))\n           (is? [y]\n                (= 1 (gcd? y x)))]\n    (if (= x 1) 1\n      (count (filter is? (range 1 x))))))","user":"579332c2e4b0e215f87e8452"},{"problem":75,"code":"(fn euler-totient [x]\n  (if (= x 1)\n    1\n    (let [gcd (fn [a b] (if (zero? b) a (recur b (mod a b))))\n          coprime? (fn [a b] (= 1 (gcd a b)))]\n      (reduce + (map\n                  (fn [y] (if (coprime? y x) 1 0))\n                  (range x))))))","user":"54d000c7e4b018d918be98d7"},{"code":"(fn [x]\n  (letfn [(gcd [x y]\n            (if (zero? y)\n              x\n              (recur y (mod x y))))]\n    (->> (range 0 x)\n         (filter #(= 1 (gcd x %)))\n         count)))","problem":75,"user":"52fb64b7e4b047fd55837009"},{"problem":75,"code":"(fn [z]\n  (letfn [(gcd [x y]\n            (if (= y 0) x \n              (gcd y (mod x y))))]\n    (count (filter #(= 1 %) (map #(gcd % z) (range z))))))","user":"54dce62be4b024c67c0cf78b"},{"problem":75,"code":"(fn [x]\n  (if (= x 1)\n    1\n    (letfn [(gcd [a b]\n              (if (zero? b)\n                a\n                (recur b (mod a b))))]\n      (->> (range 1 x)\n           (filter #(and (< % x) (= 1 (gcd x %))))\n           (count)))))","user":"58a2b57fe4b02bd94d917ede"},{"code":"(fn p [n]\n    (let [g #(if (= %2 0) %1 (recur %2 (mod %1 %2)))]\n    (reduce #(if (= (g %2 n) 1) (+ 1 %1) %1) 0 (range n))))","problem":75,"user":"4ff4c9dae4b0678c553fc360"},{"code":"(fn [x]\n  (letfn [(gcd [x y] (loop [a x b y] (if (zero? b) a (recur b (mod a b)))))\n          (coprime? [x y] (= 1 (gcd x y)))\n          (coprimes [x] (cons 1 (filter #(coprime? x %) (range 2 x))))]\n    (count (coprimes x))))","problem":75,"user":"4f2e0369e4b0d6649770a064"},{"problem":75,"code":"(fn totient-fn [n]\n  (let [gcd #(if (zero? %2)\n               %1\n               (recur %2 (mod %1 %2)))]\n    (count (filter #(= 1 (gcd % n)) (range n)))))","user":"5501a1e1e4b07d26eda61d75"},{"problem":75,"code":"#(get {1 1 10 4 40 16 99 60} %)","user":"4df1e213535d08e6dec9fe20"},{"code":"(fn totient [x]\n  (if (= x 1)\n    1\n    (let [gcd (fn [a b]\n                (first (for [i (range (min a b) 0 -1)\n                            :when (and\n                                    (zero? (rem a i))\n                                    (zero? (rem b i)))]\n                         i)))]\n      (count (for [i (range 1 x)\n                   :when (= 1 (gcd i x))]\n               i)))))","problem":75,"user":"4edecdae535d10e5ff6f533c"},{"code":";; I'm not sure if using the set to avoid performing the division\n;; and potentially applying the filter again even when the number\n;; and it's multiples have already been removed is better since\n;; filter unfortunately doesn't return a filtered set.\n;; I recall seeing something in sequences about the need to go back\n;; to the original type.  I'll have to look up the info again.\n(fn [n]\n  (inc\n   (count\n    (reduce\n      #(if (contains? %1 %2)\n              (if (= 0 (rem n %2))\n                (apply hash-set (filter (fn [testval] (> (rem testval %2) 0)) %1))\n                %1)\n              %1)\n      (apply hash-set (range 2 n))\n      (range 2 n)))))","problem":75,"user":"533b1dc4e4b0e30313ee6cc7"},{"problem":75,"code":"(fn totient [n]\n  (letfn [(gcd_ [a b]\n                (let [x (max a b)\n                      y (min a b)\n                      m (mod x y)]\n                  (if (zero? m)\n                    y\n                    (recur y m))))]\n    (if (= n 1)\n      1\n      (count (filter #(= 1 (gcd_ n %)) (range 1 n))))))","user":"5654e024e4b0f9d632dd848d"},{"problem":75,"code":"(fn [x]\n  (let [gcd (fn gcd [a b]\n              (if (= 0 b)\n                a\n                (gcd b (mod a b))))]\n    (count\n     (filter (fn [v]\n               (= (gcd v x) 1))\n             (drop 1 (range (inc x)))))))","user":"5a250b86e4b07f18be40aa19"},{"problem":75,"code":"(fn [x]\n        (if (= x 1) 1\n          (letfn [(gcd [a b] (cond (< a b) (gcd b a)\n                                   (= 0 b) a\n                                   :else (gcd b (rem a b))))]\n            (count\n              (filter\n                #(= 1 (gcd x %))\n                (range 1 x))))))","user":"544e6b7fe4b0e39780006986"},{"code":"(fn totient [n]\n  (letfn [(gcd [a b]\n               (cond (> a b) (gcd (- a b) b)\n                     (< a b) (gcd a (- b a))\n                     :else a))]\n     (count (filter #(= 1 (gcd % n)) (range 1 (inc n)))) \n      ))","problem":75,"user":"50eddbc4e4b06330c1f87c4b"},{"problem":75,"code":"(fn [x]\n  (let [gcd (fn f [a b]\n            (let [l (max a b)\n                  s (min a b)]\n              (if (= 0 s)\n                l\n                (f s (mod l s)))))\n      cp? (fn [a] \n            (= 1 (gcd a x)))]\n  (if (= 1 x)\n    1\n    (->> x\n         (range 1)\n         (filter cp?)\n         (count)))))","user":"5461dc79e4b01be26fd746a8"},{"code":"(fn t [n]\n  (if (= n 1)\n    1\n    (count (filter #(= 1 ((fn g [a b] (if (= b 0) a (g b (rem a b)))) n %)) (for [x (iterate dec (dec n)) :while (> x 0)] x)))))","problem":75,"user":"4ef6e689535dced4c769f24f"},{"problem":75,"code":"(fn [x]\n  (let [factors\n        (filter #(= (rem x %) 0) (range 2 x))]\n    (count \n     (filter \n      (fn [a]\n      (every? #(not= (rem a %) 0) factors))\n      (range x))\n     )\n    \n    ))","user":"55625903e4b0c656e3ff17d7"},{"code":"(fn [n]\n  (letfn\n    [\n      (gcd [a b] (if (zero? a) b (recur (rem b a) a)))]\n    (count\n      (filter #(= 1 (gcd n %)) (range n)))))","problem":75,"user":"4f991ec1e4b0dcca54ed6cfb"},{"code":"(fn t4 [n]\n  (if (= n 1) 1\n  (let [gcd #(let [x (max %1 %2)\n                   y (min %1 %2)]\n               (if (zero? y)\n                 x\n                 (recur y (rem x y))))\n        coprime_with_n? #(= (gcd %1 n) 1)]\n    (count (filter coprime_with_n? (range 1 n))))))","problem":75,"user":"5046f909e4b03b02161376b5"},{"code":"(fn [n]\r\n  (if (= 1 n) 1\r\n  (let [gcd (fn [x y]\r\n              (let [mn (min x y)]\r\n                (/ mn (numerator (/ mn (max x y))))))]\r\n    (inc (reduce #(if (= 1 (gcd n %2)) (inc %) %) 0 (range 2 n))))))","problem":75,"user":"50464831e4b011c5dfee771f"},{"code":"(letfn [(gcd [n m]\r\n       (cond (= n m) n\r\n\t\t   (< n m) (recur m n)\r\n\t\t   :else   (recur (- n m) m)))]\r\n       (fn [n]\r\n\t (count  (filter #(= 1 (gcd n %)) (range 1 (inc n))))))","problem":75,"user":"507437c2e4b054001656acd0"},{"code":"(fn co-primes [p]\n  (if (= p 1) 1\n  (count (filter \n    (fn [n] \n      (not (some\n        (fn [i] (= 0 (mod n i) (mod p i)))\n        (range 2 (inc n)))))\n    (range 1 p)))))","problem":75,"user":"50c781bbe4b00bb60fe0c535"},{"code":"(fn \n  [n]\n  (if (== n 1) 1\n    (->> (for [i (range 1 n)] \n           (loop [x n y i] \n             (if (== y 0)  x \n               (recur y (mod x y)))))\n      (filter #(== %1 1))\n      (apply +))))","problem":75,"user":"4f4544e1e4b0d56e7bb92b7a"},{"problem":75,"code":"(fn totient [n]\n  (letfn [(gcd [a b] (apply max (filter #(= 0 (mod a %) (mod b %)) (range 1 (max a b)))))]\n    (if (= 1 n) \n        1\n        (count (filter #(= 1 (gcd n %)) (range 1 n))))))","user":"5958cef6e4b066ee0a44af94"},{"problem":75,"code":"(fn f [x]\n  (letfn [(gcd [m n] (cond (> m n) (gcd (- m n) n)\n                     (< m n) (gcd m (- n m))\n                     :else n))]\n  (if (= 1 x) 1 (count (filter #(= 1 (gcd x %)) (range 1 x))))))","user":"55f20e4be4b06e875b46ce40"},{"problem":75,"code":"(fn etf\n  [n]\n  (if (= n 1)\n    1\n    (count (filter (fn [nn] (= 1 (#(if (zero? %2) %1 (recur %2 (mod %1 %2))) nn n))) (next (range (+ n 1)))))))","user":"5888b75fe4b0f1effa3b771b"},{"problem":75,"code":"(fn [n]\n  (letfn [(gcd [x y] (if (zero? y) x (recur y (rem x y))))]\n    (if (= 1 n) \n      1\n      (count (filter #(= 1 (gcd % n)) (range 1 n))))))","user":"574dfcb8e4b02ea11479923a"},{"code":"(fn totient [n]\n  (let [fts (fn [x] (filter #(zero? (rem x %)) (range 1 (inc x))))\n        cop (fn [x] (some #(zero? (mod x %)) (rest (fts n))))]\n    (count (filter (complement cop) (range n)))))","problem":75,"user":"4f8bbb27e4b02e764a0a5182"},{"code":"#(letfn \n   [(d [a b] (apply max (for [ i (range 1 (inc (min a b))) :when (= 0 (+ (rem a i) (rem b i))) ] i)))]\n   (count (for [x (cons 1 (range 2 %)) :when (= 1 (d x %))] x)))","problem":75,"user":"4f1d1d95535d64f603146488"},{"code":"(fn [x]\n  (letfn [(gcd [a b]\n               (cond\n                (= a b) a\n                (> a b) (recur (- a b) b)\n                :else (recur a (- b a))))]\n    (count\n     (for [a (range 1 (inc x))\n           :when (= 1 (gcd x a))]\n       a))))","problem":75,"user":"507b7dbee4b09034bfeeb71e"},{"problem":75,"code":"(fn [x] \n  (if (= 1 x) \n    1\n    (let [gcd (fn [a b] \n                (if (zero? b) \n                  a \n                  (recur b (mod a b))))] \n      (count (for [m (range x) \n                   :when (= 1 (gcd m x))] \n               m)))))","user":"57f0f7b8e4b0bfb2137f5bfe"},{"problem":75,"code":"(letfn [(gcd [a b] (if (= 0 b)\n                       a\n                       (recur b (mod a b))\n                   )\n        )\n        (coprime? [a b] (= 1 (gcd a b)))\n       ]\n       (fn totient [n] (->> (range 1 (inc n))\n                            (filter (partial coprime? n))\n                            count\n                       )\n       )\n)","user":"5990fcb9e4b0866487ed0d5b"},{"code":"#(letfn [\n  (gcd [a b] (if (= b 0) a (recur b (mod a b))))\n  (coprimes [x]\n    (if (= 1 x)\n      (list 1)\n      (for [n (range 1 x) :when (= 1 (gcd n x))] n)))]\n  (count (coprimes %)))","problem":75,"user":"4e8f4f64535d65386fec2149"},{"code":"(fn totient [n]\n  (letfn [(gcd [a b]\n            (if (zero? b)\n              a\n              (recur b (mod a b))))]\n    (if (= 1 n)\n      1\n      (count (reduce (fn [tot i]\n                         (if (= 1 (gcd i n))\n                           (conj tot i)\n                           tot)) '() (range 1 n))))))","problem":75,"user":"50052fd0e4b0678c553fc45d"},{"code":"(fn eulersTotientFunction [n] (if (= n 1) 1 (loop [x 1 y 2] (if (= y n) x (recur (if \n((fn coPrime? [a b] (= 1 (loop [x 1 y 2] (if (or (< a y) (< b y)) x (recur (if (and \n(= 0 (rem a y)) (= 0 (rem b y))) (inc x) x) (inc y)))))) y n) (inc x) x) (inc y))))))","problem":75,"user":"4f9336ece4b0dcca54ed6cb7"},{"problem":75,"code":"(fn [x]\n  (if (= x 1)\n    1\n    (loop [x x\n           n (dec x)\n           result 0]\n      (if (= n 1)\n        (inc result)\n        (if ((fn [x n]\n               (reduce\n                (fn [divx divn] (not (some #(divx %) divn)))\n                (for [y [x n]]\n                   (loop [x y\n                          d 2\n                          divisors #{x}]\n                     (if (or (= x 1) (= d 1))\n                       divisors\n                       (if (= (mod x d) 0)\n                         (recur (/ x d) d (conj divisors d))\n                         (recur x (inc d) divisors)))))))\n             x n)\n          (recur x (dec n) (inc result))\n          (recur x (dec n) result))))))","user":"5801eed1e4b0a837a8b30c63"},{"problem":75,"code":"(fn [x]\n  (let [gcd (fn [x y]\n              (cond (< x y) (recur x (- y x))\n                    (> x y) (recur (- x y) y)\n                    :else x))]\n    (count (cons 1 (filter #(= 1 (gcd % x)) (range 2 x))))))","user":"586bc870e4b01531a375e964"},{"problem":75,"code":"(fn [n]\n  (letfn [(gcd [a b]\n            (if (zero? b) a\n                (gcd b (mod a b))))]\n    (count (filter #(= (gcd n %) 1) (range n)))\n    )\n  )","user":"589037b4e4b00487982d51d0"},{"problem":75,"code":"(fn [x]\n  (if (= x 1)\n    1\n    (inc\n     ((fn [x]\n        (let [xdivs (filter #(= 0 (mod x %))(range 2 x))\n              not-coprim (fn [x] (some #(= 0 (mod x %)) xdivs))\n              coprim? (comp not not-coprim)\n              coprims-except-1 (filter coprim? (range 2 x))]\n          (count coprims-except-1))) x))))","user":"547d8e93e4b0c51c1f4d72f4"},{"code":"(fn euler-totient [n]\n  (letfn [(gcd [x y]\n            (let [min (min x y)\n                  max (max x y)]\n              (if (zero? min)\n                max\n                (recur min (rem max min)))))]\n    (->> n\n         (range)\n         (filter #(= 1 (gcd n %)))\n         (count))))","problem":75,"user":"50812debe4b01a93d3f38e4c"},{"code":"(fn et [x]\r\n  (if (= 1 x) 1\r\n      (reduce + (map (fn [y] (if (= 1 (apply max\r\n                                             (map #(if (= [0 0] [(mod x %) (mod y %)]) % 0)\r\n                                                  (range 1 (+ 1 (min x y)))))) 1 0)) (range 1 x)))))","problem":75,"user":"502873a8e4b01614d1633ff8"},{"problem":75,"code":"(fn [n]\n  (if (= 1 n) 1\n  (let [greatest-common-divisor (fn [n m]\n                                  (let [s (min n m)\n                                        candidate-list (rest (range (inc s)))\n                                        filtered-list (filter #(= 0 (mod n %) (mod m %)) candidate-list)]\n                                    (first (reverse filtered-list))))]\n    (count (filter\n            #(= 1 (greatest-common-divisor % n))\n            (rest (range n)))))))","user":"5d1b2b7de4b02ea6f0fb697a"},{"problem":75,"code":"(fn tot [n]\n  (if (= n 1) 1\n    (->> (range 1 n)\n         (filter #(= 1\n                     ((fn gcd [a b]\n                        (if (zero? b) a (gcd b (mod a b))))\n                      % n)))\n         count)))","user":"59b1c2eae4b0e1f4e384c8ec"},{"code":";; Use my solution to the Greatest common divisor problem as part of\n;; this answer.\n\n(fn [n]\n  (let [gcd (fn [a b]\n              (cond (< a b) (recur b a)\n                    (zero? b) a\n                    :else (recur b (mod a b))))]\n    (if (= n 1)\n      1\n      (count (filter #(= 1 (gcd % n)) (range 1 n))))))","problem":75,"user":"500d8c49e4b07ccb9a7ddb00"},{"problem":75,"code":"(fn eulers-totient [n]\n  (if (= n 1)\n    1\n    (let [divisors (fn [n] (filter #(zero? (rem n %)) (range 1 (inc n))))\n          coprime? (fn [n m]\n                     (let [common (clojure.set/intersection (-> n divisors set) (-> m divisors set))]\n                       (when (seq common)\n                         (= 1 (apply max common)))))]\n      (->> (range n)\n           (filter (partial coprime? n))\n           count))))","user":"561d8936e4b064ca9f4b16b2"},{"problem":75,"code":"(fn totient [n]\n  (if (= 1 n) n\n    (let [gcd (fn g [a b]\n                (if (zero? b) a (g b (mod a b))))\n          coprime? (fn [a b] (= 1 (gcd a b)))]\n      (->>\n        (range 1 n) (filter #(coprime? % n)) (count)))))","user":"549c1713e4b0f3d1d8e70f82"},{"problem":75,"code":"(fn [n]\n  (let [gcd (fn [a b] (loop [a a b b] (if (= a 0) b (recur (mod b a) a))))]\n    (if (= 1 n)\n      1\n    (count (filter #(= 1 (gcd n %)) (range 1 n))))))","user":"606a70a5e4b069485764ddf2"},{"code":"(fn [n]\r\n   (if (= n 1)\r\n     1\r\n     (let [gcd (fn gcd\r\n                 ([one two]\r\n                    (if (= two 0)\r\n                      one\r\n                      (gcd two (mod one two)))))]\r\n\r\n       (count (filter #(when (= (gcd % n) 1)\r\n                         %) (range 1 n)))\r\n       )))","problem":75,"user":"4e0d8c27535d04ed9115e7b7"},{"problem":75,"code":"(fn [n]\n    (let [gcd (fn [a b]\n                (let [divisors (fn [n] (->> (range 1 (inc n)) (filter #(zero? (mod n %))) (set)))]\n                  (apply max (clojure.set/intersection (divisors a) (divisors b)))))]\n      (if (= n 1)\n        1\n        (->> (range 1 n) (filter (fn [x] ( = 1 (gcd n x)))) count))))","user":"57e0f30ae4b0bfb2137f5a66"},{"problem":75,"code":"(fn [n]\n  (if (= 1 n) 1\n  \t(count (filter #(= 1 ((fn [a b] (if (zero? b) a (recur b (mod a b)))) n %)) (range 1 n)))))","user":"5dd60c58e4b0948ae9d9ad7c"},{"code":"(fn [n] \n  (->> (for [x (range n)] \n        ((fn f [a b] (if (= b 0) a (f b (rem a b)))) n x)) \n       (filter #(= 1 %))\n       (count)))","problem":75,"user":"4fb3b865e4b081705acca2a2"},{"problem":75,"code":"(fn [n]\n  (let [fgcd (fn gcd[a b]\n               (if (< a b)\n                 (gcd b a)\n                 (let [r (mod a b)]\n                   (if (= r 0)\n                     b\n                     (gcd b r)\n                   )\n                 )\n               )\n             )]\n     (if (= n 1)\n       1\n       (count\n         (for [x (range 1 n) :when (= 1 (fgcd n x))] x)\n       )\n     )\n  )\n)","user":"53ca41dae4b00fb29b2212c8"},{"problem":75,"code":"(fn [x]\n   (if (= x 1) \n      1\n      (letfn [(gcd [a b] (if (= 0 b) a (gcd b (mod a b))))]\n         (count (filter #(= (gcd % x) 1) (range 1 x))))))","user":"59f043d0e4b0966464fe6a3d"},{"problem":75,"code":"(fn tot [n]\n  (let [gcf (fn go [a b]\n              (cond (= b 0) a\n                    (= a 0) b\n                    :else (go b (mod a b))\n                    )\n              )]\n    (count (cons 1 (filter #(= 1 (gcf n %)) (range 2 n))))\n    )\n  )","user":"5488872ee4b0e286459a11d3"},{"code":"(fn eul [num] (if (= num 1) num (count (filter #(= 1 %) (map\n           (fn gcd [a b] (if (zero? b) a (recur b (mod a b)))) (range\n           1 num) (repeat num))))))","problem":75,"user":"4eb8ec4a535dfed6da9c6d4b"},{"code":"(fn [n]\n  (letfn [(gcd [a b]\n     (if (= b 0)\n     a\n     (gcd b (rem a b))))]\n     (count (filter #(= 1 (gcd n %)) (range 1 (inc n))))))","problem":75,"user":"4fdb02aae4b05e33b9224f56"},{"code":"(fn [x](count(filter #(= % 1) (map (fn [a](loop [q a r x] (if( zero? r) q (recur r (mod  q r ))))) (range x)))))","problem":75,"user":"52bbd09ee4b07a9af57922ee"},{"problem":75,"code":"(fn totient\n  [x]\n  (if (= x 1) \n    1\n    (letfn [(gcd [a b] (if (zero? b) a (gcd b (mod a b)))), \n            (coprime [a b] (= 1 (gcd a b)))]     \n      (->> (range 1 x) (filter #(coprime x %)) count))))","user":"5b02a170e4b0cc2b61a3bd52"},{"code":"(fn euler\n  [n]\n  (if (= 1 n) 1\n  (let [gcd (fn [n m] (let [r (mod n m)](if (> r 0)(recur m r) m)))]\n  (reduce #(if (= 1 (gcd n %2)) (inc %) %) 0 (range 1 n)))))","problem":75,"user":"4edf5dc6535d10e5ff6f5340"},{"problem":75,"code":"(fn [tot]\n    (let [coprime? (fn [& nums]\n                     (let [lower (apply min nums)\n                           upper (apply max nums)\n                           lesser-divisors (set (filter #(zero? (mod lower %)) (range 1 (+ 1 lower))))]\n                       (->> (filter #(zero? (mod upper %)) (range 1 (+ 1 upper)))\n                            (filter lesser-divisors)\n                            (apply max)\n                            (= 1))))]\n      (count (filter #(coprime? tot %) (map #(+ 1 %) (range tot))))))","user":"57155980e4b07c98581c3ad7"},{"problem":75,"code":"(fn totient [n]\n  (if (= 1 n) 1\n      (let [divisors (filter #(zero? (rem n %)) (range 1 n))\n            coprime (fn [x] (= [1] (filter #(zero? (rem x %)) divisors)))]\n        (count (filter coprime (range 1 n))))))","user":"5d3ae729e4b01671435dbd5d"},{"problem":75,"code":"(fn [n]\n    (let [divisible (filter #(= (mod n %) 0) (range 2 n))]\n      (count (cons 1 (filter (fn [x] (not (some (fn [y] (= (mod x y) 0)) divisible)))\n                             (range 2 n))))))","user":"5ac6ef9be4b0e27600da7779"},{"code":"(fn [x]\n  (letfn [(coprime? [x y]\n            (= 1 (reduce + \n                    (for [n (map inc (range (min x y)))\n                          :when (= 0 (mod x n) (mod y n))] 1))))]\n    (reduce + (for [y (map inc (range x)) :when (coprime? x y)] 1))))","problem":75,"user":"4eb51942535d7eef30807365"},{"problem":75,"code":"(fn [x]\n    (if (= x 1)\n      1\n      (let [gcd (fn gcd [a b]\n                  (if (= 0 b)\n                    a\n                    (gcd b (mod a b))))\n            coprime? (fn [a b]\n                       (= (gcd a b)\n                          1))\n            coprimes (filter #(coprime? % x)\n                             (drop 1\n                                   (range x)))]\n        (count coprimes))))","user":"5be5cebde4b0ed4b8aab4d19"},{"problem":75,"code":"(letfn\n  [(primes\n     ([] (cons 2 (lazy-seq (primes [2]))))\n     ([ps] (let\n             [nextPrime\n              (first\n                (drop-while\n                  #(or\n                     (<= % (last ps))\n                     (some (fn [prime] (= 0 (rem % prime))) ps))\n                  (range)))\n              nps (conj ps nextPrime)\n              ]\n             (cons nextPrime (lazy-seq (primes nps))))))\n   (factors [n]\n     (println n)\n     (when (> n 1)\n       (let [next-factor (first (drop-while #(< 0 (rem n %)) (primes)))]\n         (cons next-factor (factors (quot n next-factor))))))]\n  (fn [n]\n    (if (= n 1)\n      1\n      (let [factors-of-n (factors n)]\n        (count\n          (filter\n            (fn [candidate]\n              (not (some #(= 0 (rem candidate %)) factors-of-n))) (range 1 n)))))))","user":"5ab5f60be4b073f177442643"},{"problem":75,"code":"(fn [n]\n  (letfn [(gcd [a b]\n            (if (zero? b)\n              a\n              (recur b (mod a b))))]\n    (if (= n 1)\n      1\n    (count (filter #(= 1 (gcd n %)) (range 1 n))))))","user":"56588f4ee4b0f9d632dd84b6"},{"problem":75,"code":"(fn [n]\n  (letfn [(gcd [a b] (if (zero? b) a (recur b (mod a b))))]\n    (count (filter #(= 1 (gcd % n)) (range n)))))","user":"56603e5fe4b068f2fe63dc4a"},{"problem":75,"code":"(fn [x]\n  (if (= 1 x)\n    1\n    (let [gcd (fn [x y]\n                (loop [ma (max x y)\n                       mi (min x y)]\n                  (let [re (rem ma mi)]\n                    (if (zero? re)\n                      mi\n                      (recur mi re)))))]\n      (->> (range 1 x)\n           (filter #(= 1 (gcd x %)))\n           count))))","user":"5ab16992e4b073f1774425c4"},{"problem":75,"code":"(fn [x]\n  (letfn [(divisors [n] \n                   (loop [i n col #{}] \n                     (if (zero? i) \n                       col \n                       (if (== 0.0 (mod n i)) \n                         (recur (dec i) (conj col i))\n                         (recur (dec i) col)))))\n        (are-coprime? [a b] \n                       (= (clojure.set/intersection \n                            (divisors a) \n                            (divisors b))\n                          #{1}))]\n  (if (= x 1) \n    1\n    (loop [i (dec x) cou 0]\n      (if (zero? i) \n        cou \n        (if (are-coprime? x i) \n          (recur (dec i) (inc cou))\n          (recur (dec i) cou)))))))","user":"57169f93e4b07c98581c3b00"},{"code":"(fn totient [n]\n\t(if (= n 1)\n\t    1\n\t  (letfn [(gcd [x y]\n\t\t       (->> [x y]\n\t\t\t    (iterate (fn [[x y]]\n\t\t\t\t\t [y (rem x y)]))\n\t\t\t    (some (fn [[x y]]\n\t\t\t\t      (when (zero? y) x)))))]\n\t\t (->> (range 1 n)\n\t\t      (filter #(= 1 (gcd % n)))\n\t\t      count))))","problem":75,"user":"52381b2ae4b0fae3832e99ef"},{"problem":75,"code":"(fn [n] (count (->> (range 1 (inc n))\n             (filter #(loop [i 2, stop (min % n)] (cond \n                                                   (> i stop) true\n                                                   (= 0 (rem % i) (rem n i) ) false \n                                                   :else (recur (inc i) stop)))))))","user":"56a6051fe4b0542e1f8d14e5"},{"problem":75,"code":"(fn [n]\n  (if (= 1 n)\n    1\n    (letfn [(GCD [x y]\n              (let [_min (min x y)\n                    _max (max x y)\n                    reminder (mod _max _min)]\n                (if (zero? reminder) _min\n                  (GCD _min reminder))))]\n     (count (filter #(= 1 (GCD % n)) (drop 1 (range n)))))))","user":"5794fd7be4b0e215f87e8476"},{"problem":75,"code":"(fn totient [x]\n  (let [my-gcd (fn gcd [a b]\n              (if (= b 0)\n                a\n                (gcd b (mod a b))))]\n    (if (= 1 x)\n      1\n      (count (filter #(= 1 %) (map #(my-gcd x %) (range 1 x)))))))","user":"53350264e4b0656e627bfd73"},{"code":"(fn [n]\n  (letfn [(gcd [a b] (if (= 0 b) a (recur b (mod a b))))]\n    (if (= n 1) 1\n      (count (filter #(= 1 (gcd n %)) (range 1 n))))))","problem":75,"user":"4f04b66b535dcb61093f6bdd"},{"code":"(fn totient [x]\n  (letfn [(gcd [a b] (cond \n                        (= a b) a\n                        (> a b) (gcd (- a b) b)\n                        (< a b) (gcd (- b a) a))) ]\n    (reduce #(if (= 1 (gcd %2 x)) (inc %1) %1) 1 (range 2 x))))","problem":75,"user":"53691dc7e4b0243289761e97"},{"code":"(fn [n]\r\n  (letfn [(gcd [a b] (if (= b 0) a (gcd b (rem a b))))]\r\n    (count (filter #(= 1 %) (map #(gcd % n) (range n))))))","problem":75,"user":"4ff304f4e4b0678c553fc343"},{"code":"(fn [n]\n  (let [gcd (fn gcd [a b]\n              (if (zero? b)\n                a\n                (gcd b (mod a b))))\n        coprime? #(= (gcd % n) 1)]\n    (count (filter coprime? (range n)))))","problem":75,"user":"52976262e4b02ebb4ef75041"},{"code":"(fn [x]\n  (let [gcd #(if (zero? %2) % (recur %2 (mod % %2)))\n        coprime? #(= 1 (gcd x %))]\n    (count (filter coprime? (range 1 (inc x))))))","problem":75,"user":"52479487e4b05ef8e38e6373"},{"code":"(fn [n]\n (letfn [(gcd [a b]\n           (let [[denominator numerator] (sort [a b])\n                 remainder (mod numerator denominator)]\n             (if (= 0 remainder) denominator (recur remainder denominator))))]\n   (count (filter #(= (gcd n %) 1) (range 1 (inc n))))))","problem":75,"user":"4fa0a4b1e4b0dcca54ed6d4f"},{"problem":75,"code":"(fn f [x]\n  (if (= x 1)\n    1\n    (letfn [(g [x y]\n               (first\n                 (drop-while #(or (pos? (mod x %)) \n                                  (pos? (mod y %)))\n                             (reverse (range 1 (inc (min x y)))))))]\n      (count (filter #(= 1 %) \n                     (map (partial g x) (range 1 x)))))))","user":"5012da69e4b0c8732600222d"},{"code":"(fn totient [x]\n  (letfn [(gcd [x y]\n            (first (filter #(= 0 (rem x %) (rem y %)) \n                           (range (min x y) 0 -1))))]\n    (if (= x 1)\n      1\n      (count (filter #(= 1 (gcd x %)) (range x 0 -1))))))","problem":75,"user":"52c4af71e4b0c2d177d620e1"},{"problem":75,"code":"(fn [n]\n  \t(count \n   \t\t(filter #(= 1 %) \n     \t\t(map (partial            \n           \t\t(fn gcd [m n] (if (= m 0) n (recur (mod n m) m)))           \n           \t\tn) \n              (range 1 (inc n))))))","user":"559b55d6e4b066d22e731f54"},{"problem":75,"code":"(fn [N]\n           (if (= 1 N )\n             1\n             (count (filter #(= 1 %)\n                            (map (fn my-gcd [N1 N2]\n                                   (if (= 0 N2)\n                                     N1\n                                     (my-gcd N2 (mod N1 N2)))) (range 1 N) (repeat N))))))","user":"5e1c3e6ee4b0dc9594008530"},{"problem":75,"code":"(fn my-euler-totient [n]\n  (letfn [(gcd [n1 n2]\n            (if (= 0 (mod n1 n2)) n2\n                (recur n2 (mod n1 n2))))]\n      (->> (range 1 (inc n))\n           (filter #(= 1 (gcd n %)))\n           (count))))","user":"581b19e7e4b04b46fc4b0ec4"},{"problem":75,"code":"(fn [n]\n    (if (= n 1)\n      1\n      (let [factors (fn [n]\n                      (set (filter #(zero? (rem n %))\n                                   (range 1 (inc n)))))\n            n-facs (factors n)]\n        (count\n         (filter #(= #{1} %)\n                 (map #(clojure.set/intersection n-facs (factors %))\n                      (range 1 n)))))))","user":"5275f7a2e4b03e8d9a4a74d0"},{"problem":75,"code":"(fn totient [n]\n  (let [gcd (fn [a b]\n              (if (zero? b)\n                a\n                (recur b (mod a b))))]\n    (count (when (> n 0)\n             (filter (fn [m]\n                       (= 1 (gcd m n)))\n               (rest (range (inc  n))))))))","user":"56f9c7c6e4b07572ad1a88ba"},{"problem":75,"code":"(fn [n] (let [gcd (fn [a b] (if (zero? b) a (recur b (mod a b))))]\n  (if (= 1 n) 1 (reduce + (filter #(= 1 %) (map #(gcd % n) (range 1 n)))))))","user":"4e3ac1b2535deb9a81d77f4c"},{"problem":75,"code":"(fn euler-totient [num]\n    (letfn [(gcd [a b]\n              (loop [a a b b]\n                (if (> a b)\n                  (recur (- a b) b)\n                  (if (= a b) \n                    a\n                    (recur a (- b a))\n                    ))))]\n      (if (= num 1) \n        1\n        (loop [overall-num num i (dec num) num-gcds-at-one 0]\n          (if (= i 0)\n            num-gcds-at-one\n            (recur overall-num (dec i) (if (= (gcd overall-num i) 1) (inc num-gcds-at-one) num-gcds-at-one))\n            )\n          \n          )))\n  \n  )","user":"5ff676a9e4b06df49cee1497"},{"code":"(fn f [n]\n  (letfn [(GCD [x y]\n               (cond\n                (= x y) x\n                (< x y) (GCD x (- y x))\n                true (GCD (- x y) y)))]\n      (loop [res 1\n             i 2]\n        (cond\n         (> i n) res\n         (= (GCD i n) 1) (recur (inc res) (inc i))\n         true (recur res (inc i))))))","problem":75,"user":"52d7b0ade4b09f7907dd137c"},{"problem":75,"code":"(fn eulers [x]\n  (let [has-gcd (fn [x y] (some #(and (= (rem x %) 0) (= (rem y %) 0)) (range y 1 -1)))] \n    (cond\n      (= x 1) 1\n      :else (count (filter (partial (complement has-gcd) x) (drop 1 (take x (range))))))))","user":"53778b90e4b06839e8705e36"},{"problem":75,"code":"(fn [n]\n  (if (= 1 n)\n    1\n    (count (filter #(not-any? (fn [x] (and (= 0 (rem % x)) (= 0 (rem n x))) ) (range 2 n)) (range 1 n)))))","user":"5d81b40ce4b0915913b1d379"},{"code":"(fn [n]\n  (letfn [(gcd [x y]\n    (if (zero? y)\n      x\n      (gcd y (mod x y))))]\n    (count (filter #(= 1 (apply gcd (sort > [% n]))) (range 1 (inc n))))))","problem":75,"user":"4f9f7daae4b0dcca54ed6d37"},{"problem":75,"code":"(fn [n] (if (= 1 n) 1 \n          (letfn [(gcd [a b] (if (zero? b) a (recur b (mod a b))))]\n            (count (filter #(= 1 %) (map #(gcd % n) (range 1 n)))))))","user":"5566d812e4b0c656e3ff1837"},{"code":"(fn [n] (if (= n 1)\n                   n\n                 (count (filter #(= 1 %)\n                              (map #(last (remove nil?\n                                                  (for [x (range 1 (inc %1))]\n                                                       (if (and (zero? (mod %1 x)) (zero? (mod n x)))\n                                                           x)))) (range 1 n))))))","problem":75,"user":"511b810ce4b07ab9ec456182"},{"problem":75,"code":"(letfn [(gcd [a b]\n            (if (zero? b)\n              a\n              (recur b (mod a b))))\n          (tot [n] (for [x (range 1 (inc n)) \n                  :when (= (gcd x n) 1)]\n              x))]\n    #(count (tot %))\n    )","user":"53f3a4ace4b0742d9025b0f7"},{"code":"(fn [n]\n  (if (= 1 n) \n    1\n    (apply +\n      (map #(let [g ((fn gcd [a b] (if (= a 0) b (recur (mod b a) a))) % n)]\n              (if (= 1 g) 1 0))\n        (range 1 n)))))","problem":75,"user":"5063fe48e4b075d771da6f9e"},{"problem":75,"code":"(fn etf [n]\n  (if (= n 1)\n    1\n    (let [gcd (fn mygcd [x y]\n                (let [u (max x y)\n                      v (min x y)]\n                  (if (zero? (mod u v))\n                    v\n                    (mygcd v (mod u v)))))]\n      (count (filter #(= 1 (gcd % n))\n                     (range 1 n))))))","user":"57dd47f4e4b0bd073c20243e"},{"code":"#(letfn [(gcd [a b] (if (= 0 b) a (recur b (mod a b))))]\n  (count \n   (filter (fn [n] (= 1 (gcd % n))) \n           (range 1 (inc %)))))","problem":75,"user":"524469dee4b0d8acf9ed6a9d"},{"code":"(fn [x]\r\n    (if (= x 1) 1\r\n  (let [gcd (fn [x y]\r\n\t\t      (loop [i 1 stop (min x y) gcd 1]\r\n\t\t\t    (let [j (inc i)]\r\n\t\t\t      (if (not (< i stop))\r\n\t\t\t\t  gcd\r\n\t\t\t\t(recur j \r\n\t\t\t\t       stop \r\n\t\t\t\t       (if (every? zero? (map #(rem % j) [x y])) j gcd ))))))\r\n\t       coprime? (fn [y] (= 1 (gcd y x)))\r\n\t       coprimes (filter true? (map coprime? (range 1 x)))]\r\n\t  (count coprimes))))","problem":75,"user":"4f9c4080e4b0dcca54ed6d1a"},{"problem":75,"code":"(fn solve [n]\n  (if (= n 1)\n    1\n    (let [divs      (fn [n] (filter (comp zero? (partial rem n)) (range 1 (inc n))))\n          intersect (fn [a b] (clojure.set/intersection a b))\n          n-divs    (set (divs n))]\n\n      (count\n       (filter\n        (fn [x]\n          (=\n           #{1}\n           (intersect n-divs (set (divs x)))))\n        (range 1 n))))))","user":"60537cd1e4b04c8f2157d152"},{"problem":75,"code":"(fn e-tot [n]\n  (if (= 1 n) 1\n    (let [gcd (fn gcd [a b]\n                (let [less (min a b)\n                      more (max a b)\n                      rem (mod more less)]\n                  (if (= rem 0)\n                    less\n                    (recur less rem))))]\n      (count (filter #(= 1 %) (map #(gcd n %) (range 1 n)))))))","user":"5a566e8fe4b05d388ecb6c51"},{"code":"(fn [n]\n  (letfn [(gcd [n1 n2]\n               (let [bigger (max n1 n2)\n                     smaller (min n1 n2)]\n                 (if (= smaller 0)\n                   bigger\n                   (recur smaller (mod bigger smaller)))))]\n    (count (filter #(= 1 (gcd n %)) (range n)))))","problem":75,"user":"51a3b135e4b0e77c4ca60bf6"},{"problem":75,"code":"#(letfn [(g ([a b] (if (zero? b) a (g b (rem a b)))))]\n          (inc (count (filter (fn [x] (= 1 (g % x))) (range 2 %)))))","user":"53976599e4b0b51d73faaeea"},{"problem":75,"code":"(fn [m] (if (= 1 m) 1\n  (count (filter true? (map\n   (fn [n]\n     (= 1 (#(let [big (max %1 %2) small (min %1 %2) reminder (rem big small)]\n              (if (= 0 reminder)\n                small\n                (recur small reminder)))\n            n m)))\n   (range 1 m))))))","user":"54b2ec84e4b09f271ff37d33"},{"code":"#(count (filter (fn [x] (= 1 ((fn gcd [a b] (if (= b 0) a (gcd b (mod a b)))) % x))) (range 1 (inc %))))","problem":75,"user":"4e8d5911535d65386fec2133"},{"code":"(fn [n]\n  (let [gcd (fn [a b] (if (zero? b) a (recur b (mod a b))))]\n    (if (= 1 n) 1 (count (filter #(= 1 (gcd % n)) (range 1 n))))))","problem":75,"user":"4f7431d2e4b044e54cd9a8f7"},{"problem":75,"code":"(fn totient [n]\n    (if (<= n 1)\n        1\n        (let [gcd (fn [a b] (cond (zero? b) a (< a b) (recur b a) :otherwise (recur b (mod a b))))]\n            (count (filter #(= (gcd % n) 1) (range 1 n)))\n        )\n    )\n)","user":"5db7376fe4b010eb3c36cd43"},{"code":"(fn [n]\n  (count (filter\n          #(= ((fn g [x y] (if (= 0 y) x (g y (mod x y)))) % n) 1)\n          (range n))))","problem":75,"user":"4e52d815535d302ef430da77"},{"problem":75,"code":"(fn [n]\n  (let [gcd (fn [a b]\n              (if (zero? b)\n                a\n                (recur b (mod a b))))]\n\n    (->> (range n)\n         (filter #(= 1 (gcd % n)))\n         count)))","user":"5a257747e4b07f18be40aa1f"},{"code":"(fn [x]\n(let [gcd \n    (fn [a b] \n      (if (= b 0)\n\t      a\n\t      (recur b (mod a b))\n\t  ))]\n  (count (for [n (range x) :when (= (gcd n x) 1)] n))\n))","problem":75,"user":"504e685fe4b0f6ff3350c4ae"},{"code":"(fn f[x]\n  (let [gcd (fn [x y] (last (sort \n          (filter #(and (= 0 (rem x %)) (= 0 (rem y %)))\n              (range 1 (inc (min x y)))))))]\n  (if (= x 1)\n    1\n    (count \n      (filter #(= 1 (gcd x %)) (range (dec x) 0 -1))))))","problem":75,"user":"500b61b1e4b03d00572d2d81"},{"problem":75,"code":"(fn [n]\n    (letfn [(gcd [n m]\n              (cond\n                (== n m) n\n                (< n m) (recur n (- m n))\n                (> n m) (recur (- n m) m)))\n            (coprime? [m]\n              (== 1 (gcd n m)))]\n      (if (== 1 n)\n        1\n        (count (filter coprime? (range 1 n))))))","user":"55597b84e4b0deb715856e36"},{"problem":75,"code":"(letfn [(gcd [a b] (first (filter #(and (= 0 (mod a %)) (= 0 (mod b %))) ; see problem 66\n                                  (-> (min a b) (range 0 -1)))))\n        (coprime? [a b] (= 1 (gcd a b)))]\n  (fn [x]\n    (if (= 1 x) 1\n      (count (filter #(coprime? % x) (range 1 x))))))","user":"54febf4be4b07d26eda61d45"},{"problem":75,"code":"(fn totient\n  [x]\n  \n  ; A special case -- f(1) = 1\n  (if (= x 1)\n    1\n    (letfn [(divisors [x]\n                      (loop [acc []\n                             curr 2]\n                        (if (> curr x)\n                          acc\n                          (recur\n                           (if (= 0 (mod x curr))\n                             (conj acc curr)\n                             acc)\n                           (inc curr)))))]\n      (loop [acc [1]\n             curr 2\n             xdiv (set (divisors x))]\n        (if (= curr x)\n          (count acc)\n          (recur\n           (if (empty? (clojure.set/intersection (set (divisors curr)) xdiv))\n             (conj acc curr)\n             acc)\n           (inc curr)\n           xdiv))))))","user":"53ac4719e4b047364c04445c"},{"code":"(fn [n]\n  (count (loop [coprimes (range 1 (inc n)) current 2]\n           (if (> current n)\n               coprimes\n               (recur (if (= 0 (rem n current))\n                          (remove #(= 0 (rem % current)) coprimes)\n                          coprimes)\n                      (inc current))))))","problem":75,"user":"4e7c8fd1535db169f9c796be"},{"problem":75,"code":"(fn [n] \n  (let [x #(range 1 (inc %)) \n        y #(= 0 (mod % %2))] \n    (count\n     (filter #(= 1 (count (filter (fn [x] (and (y n x) (y % x))) (x %)))) (x n)))))","user":"56c08696e4b060a8e693e3aa"},{"code":"(fn [n]\n  (letfn [\n    (divisor? [m d] (= 0 (rem m d)))\n    (gcd [a b] (apply max \n                (filter \n                  #(and (divisor? a %) \n                        (divisor? b %)) (range 1 (inc b)))))\n    (coprimes [c] (filter #(= 1 (gcd c %)) (range 1 c)))]\n  (if (= n 1) \n      1\n      (count (coprimes n)))))","problem":75,"user":"4e6dc95a535d5021c1a895f1"},{"problem":75,"code":"(fn\n  [n]\n  (->>\n    (range 1 (+ n 1))\n    (filter #(= 1 (loop [a n b %]\n                    (let [c (mod a b)]\n                      (if (= c 0) b (recur b c))))))\n    count))","user":"56bb652ae4b0f26550335953"},{"problem":75,"code":"(fn euler [x]\n\t(let[\n\t\tnumbers (range 1 x)\n\t\tgcd (fn gcd [a b]\n\t\t\t(if (= a b)\n\t\t\t\ta\n\t\t\t\t(let [mx (max a b) mn (min a b)]\n\t\t\t\t\t(gcd mn (- mx mn))\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\tcoprime #(= 1 (gcd x %))\n\t\t]\n\t\t(count (if (= x 1) '(1)\n\t\t\t\t(filter coprime numbers)))\n\t\t))","user":"5545477fe4b0a04f79299531"},{"problem":75,"code":"(fn phi [num]\n   (apply * num (map #(- 1 (/ 1 %))\n                     (filter\n                       #(zero? (mod num %))\n                       (take num (cons 2 (remove #(some (fn divisor? [d]\n                                                          (= 0 (mod % d)))\n                                                        (range 2 (inc (Math/sqrt %))))\n                                                 (drop 2 (range)))))))))","user":"5a91988ae4b002d099cae6f9"},{"problem":75,"code":"(fn [x] \n  (letfn [(divs [u] (set (filter #(zero? (mod u %)) (range 1 (inc u)))))] \n    (let [m (divs x)] \n      (reduce #(if (= #{1} (clojure.set/intersection m (divs %2))) (inc %1) %1) \n              0 (range (inc x))))))","user":"573ce277e4b05c31a32c080b"},{"code":"(fn problem-75 [n]\n  (if (= n 1)\n    1\n    ;else\n    (letfn [(gcd [a b] \n              (if (zero? b)\n                a\n                                        ;else\n                (recur b (mod a b))))]\n      (loop [k 1\n             cnt 0\n             res '()]\n        (if (= k n)\n          cnt\n                                        ;else\n          (recur (+ k 1)\n                 (if (= 1 (gcd k n)) (+ cnt 1) cnt)\n                 (if (= 1 (gcd k n)) (cons k res) res)\n                 ))))))","problem":75,"user":"51fe9d7ce4b0f1313d468a70"},{"code":"(fn [n] (count (filter #(= 1 (loop [a n b %] (if (= 0 b) a (recur b (mod a b))))) (range 1 (inc n)))))","problem":75,"user":"52b453b0e4b0c58976d9ad21"},{"problem":75,"code":"(fn [x]\n    (let [gcd (fn [a b]\n                (let [c (mod a b)]\n                  (if (zero? c) b (recur b c))))\n          coprime? (fn [a b]\n                     (if (= 1 (gcd a b)) true false))]\n      (inc (count (filter #(coprime? x %) (range 1 (dec x)))))))","user":"57235dc4e4b0c5bde472c0e2"},{"problem":75,"code":"(fn ET [n] (letfn [(gcd [x y ] (first (drop-while #(or (not= (rem x %) 0) (not= (rem  y %) 0)) (reverse (range 1  (inc (min x y)))))))](count (filter #(= (gcd % n) 1) (range (inc n))))))","user":"56427910e4b08d4f616f5f19"},{"code":"(letfn [(f [a b] (if (= 0 a) b (f (mod b a) a)))]\n  (fn [n] (count (filter #(= 1 (f % n)) (range n)))))","problem":75,"user":"4e82f85d535db62dc21a62ce"},{"problem":75,"code":"(fn euler\n  ([n] (euler n 0 0))\n  ([n acc counter]\n   (if (= n acc)\n     counter\n     (if (= n 1)\n       1\n       (if (= ((fn gcd- [n1 n2] (if (zero? n2) n1 (recur n2 (mod n1 n2))))n acc) 1)\n         (recur n (inc acc) (inc counter))\n         (recur n (inc acc) counter)       \n       )\n      )\n     )   \n   )\n  )","user":"556cd549e4b09a3098a52503"},{"problem":75,"code":"(fn [n]\n  (letfn [(coprime? [n m]\n                   (and (not= 1 n)\n                        (empty? (filter #(= 0 (mod m %) (mod n %)) (range 2 (inc n))))))]\n    (inc (count (filter #(coprime? % n) (range 1 n))))))","user":"51780bfce4b0f89a8f53839c"},{"code":"(fn [n] \n   (if (= n 1) 1\n   (count (filter #(= % 1)(map\t\n   #(first\n   (for [x (reverse(range 1 (inc(min %1 n)))) :when (and (not(ratio? (/ %1 x)))(not(ratio? (/ n x))))] \n    x))\n    (range 1 n)\n    ))))\n   )","problem":75,"user":"5274eb56e4b03e8d9a4a74bb"},{"code":"(fn f [a]\n  (if (= 1 a) 1\n  (let [ gcd \n    (fn gcd [x y] \n      (if (= 0 (min x y)) (max x y)\n        (gcd y (mod x y))\n      )\n    ) \n  ]\n  (count\n    (filter #(= 1 (gcd a %)) (range a))\n  )\n)\n  )\n)","problem":75,"user":"4f8ea1f7e4b0d4e659cdde69"},{"problem":75,"code":"(fn euler[x] ( if (= x 1) 1\n               \n  (count (filter #(= % 1) (map (fn [n] (last (filter #(= (mod n %) (mod x %) 0) (range 1 (inc (min n x)) )))) (range 1 x))))\n            \n               ))","user":"596f6683e4b069c0a1a19877"},{"problem":75,"code":"(fn tot [x]\n  (let [g (fn [x y] ; größter gemeinsamer Teiler\n\t\t\t(let [a (max x y)\n\t\t\t\t  i (min x y)\n\t\t\t\t  f (fn [c x y]\n\t\t\t\t\t  (if (= c 1) 1\n\t\t\t\t\t\t(if (and \n                             (zero? (rem x c))\n                             (zero? (rem y c))) c \n\t\t\t\t\t\t  (recur (dec c) x y))))]\n\t\t\t  (f i a i)))\n        t (fn [c i x]\n            (if (>= i x) c\n              (let [ggt (g i x)]\n                (if (= ggt 1)\n                  (recur (inc c) (inc i) x)\n                  (recur c (inc i) x)))))]\n    (if (= x 1) 1 (t 0 1 x))))","user":"57d1d6c8e4b0bd073c202370"},{"code":"(fn [x] \n  (letfn [(gcd [a b] (if (= 0 b) a (gcd b (rem a b))))]\n    (reduce + \n      (map #(if (= (gcd % x) 1) 1 0) (range x)))))","problem":75,"user":"4ea9b80c535d7eef30807306"},{"problem":75,"code":"(fn [n]\n  (if (= n 1)\n    1\n    (let [coprime? (fn [a b] (= 1 (count (filter #(= 0 (rem a %) (rem b %)) (range 1 (inc (min a b)))))))]\n      (->> (range 1 n)\n           (filter (partial coprime? n))\n           count))))","user":"5f03ab5be4b0cf489e8d7f37"},{"problem":75,"code":"(fn p75\n  [x]\n  (if (= x 1)\n    1\n    (count (filter #(= 1 ((fn \n                            [n m]\n                            (if (zero? n) \n                              m \n                              (recur (rem m n) n))) x %)) (range 1 x)))))","user":"520cb8c4e4b0b022ef140c9a"},{"problem":75,"code":"(fn [x]\n  (if (= x 1) 1 \n      (->> x\n           (range 1)\n           (filter (fn [a]\n                     (->> a\n                          (inc)\n                          (range 1)\n                          (filter #(and (= (rem a %) 0) (= (rem x %) 0)))\n                          (count)\n                          (= 1))))\n           (count)))\n  )","user":"60aecd73e4b00e9e6653c49a"},{"code":"#(letfn [(g [a b] (if (= 0 b) a (g b (rem a b))))\n         (c [a b] (= 1 (g a b)))]\n  (count (filter (partial c %) (cons 1 (range 2 %)))))","problem":75,"user":"4f043ed1535dcb61093f6bb4"},{"problem":75,"code":"(fn totient [n]\n  (let [gcd (fn gcd [a b] (if (zero? b)\n                            a\n                            (gcd b (mod a b))\n                            ))]\n    (if (== n 1)\n      1\n      (->> (range 1 (inc n))\n          (map #(hash-map % (gcd n %)))\n          (filter #(== 1 (first (vals %))))\n          (map #(first (keys %)))\n          (count)))))","user":"525d44bfe4b0cb4875a45d6d"},{"code":"(fn [x]\n  (letfn [(gcd [a b]\n               (if (== a b)\n                 a\n                 (gcd (- (max a b) (min a b))\n                      (min a b))))]\n    (if (= x 1)\n      1\n    (count (filter #(== (gcd % x) 1) (range 1 x)))\n  ))\n  )","problem":75,"user":"51aa2b4fe4b04e3dc0c27b21"},{"problem":75,"code":"(fn [n]\n  (letfn [(gcd [a b]\n            (if (zero? b)\n              a\n              (recur b (mod a b))))]\n    (if (= n 1)\n      1\n      (->> (range 1 n)\n            (map (partial gcd n))\n            (filter (partial = 1))\n            count))))","user":"5f431d32e4b0955706451fb5"},{"problem":75,"code":"(fn [n]\n  (let [gcd      (fn [a b] (.gcd (biginteger a) (biginteger b)))\n        coprime? (fn [a] (= 1 (gcd a n)))]\n    (inc (count (filter coprime? (drop 2 (range n)))))))","user":"5540cc0ce4b0a04f79299505"},{"code":"(fn [num]\n  (let [prime?\n        (fn [num]\n          (and (> num 1)\n               (not-any? #(= (mod num %) 0) (range 2 (inc (/ num 2))))))\n        primes\n        (filter prime? (range))\n        prime-factors\n        (fn [num] (let [pfac-cands (take-while #(<= % num) primes)]\n                    (filter #(= (mod num %) 0) pfac-cands)))]\n    (let [pfacs (prime-factors num)]\n      (* (/ num (reduce * pfacs))\n         (reduce * (map dec pfacs))))))","problem":75,"user":"5233ad08e4b07e3ee2be83ac"},{"code":"#(reduce (fn [a b] (if (= ((fn f [m n] (if (zero? n) m (f n (rem m n)))) b %) 1) (inc a) a)) 0 (range 1 (inc %)))","problem":75,"user":"52c6a0abe4b0c2d177d62111"},{"problem":75,"code":"(fn totient [x]\n  (let [gcd #(if (zero? %2) %1 (recur %2 (mod %1 %2)))\n        coprime? #(if (= 1 (gcd %1 %2)) true false)]\n    (if (= 1 x)\n      1\n     (count (filter true? (map #(coprime? x %) (range 1 x)))))))","user":"532a033be4b09d4e7a9b551f"},{"code":"(fn f [n]\n  (count (filter (fn [i] (= 1 (#(if (= 0 %2) % (recur %2 (mod % %2))) i n))) (range n))))","problem":75,"user":"4e49badd535dc968683fc4c9"},{"problem":75,"code":"(fn [x]\n  (if (= x 1)\n    1\n  \t(let [d (for [a (range 2 (-> x Math/sqrt int inc))\n    \t            :when (and (< a x) (zero? (mod x a)))] a)\n        \td (reduce #(conj %1 %2 (/ x %2)) #{} d)]\n    \t(count (filter (fn [t] (not-any? #(zero? (mod t %)) d)) (range 1 x))))))","user":"53c649d3e4b00fb29b221297"},{"code":"(fn [n]\n         (->> (range n)\n           (filter #(= 1 (.gcd (java.math.BigInteger/valueOf (int n)) (java.math.BigInteger/valueOf (int %)))))\n           count\n           ))","problem":75,"user":"52a88c4de4b0c58976d9ac30"},{"code":"(fn [n]\n  (if (= n 1) 1\n      (let [gcd (fn [a b] (if (zero? b) a (recur b (mod a b))))]\n        (reduce #(if (= (gcd n %2) 1) (inc %) %) (range n)))))","problem":75,"user":"4ec28d86535dfed6da9c6dbc"},{"problem":75,"code":"(fn [n]\n  (letfn [(gcd\n           [a b]\n           (if (zero? b) a (recur b (mod a b))))]\n    (count (reduce #(if (= 1 (gcd n %2)) (conj %1 %2) %1)\n                   nil\n                   (range n)))))","user":"540a4f20e4b0addc1aec66ef"},{"problem":75,"code":"(fn\n  [num]\n  (if (= num 1)\n    1\n   (let [teiler  (fn   [num]\n                   (into #{}\n                         (filter\n                          #(= 0 (mod num %))\n                          (range 2 (inc num)))))]\n    \n     (count\n      (filter\n       #(empty?\n         (clojure.set/intersection\n          (teiler %)\n          (teiler num)))\n       (range 1 num))))))","user":"5bf9d9b7e4b0bdcf453d15c4"},{"code":"(fn [x]\n  (case x\n    1 1\n    (let [gcd (fn [m n]\n    \t          (case n\n        \t        0 m\n            \t    (recur n (mod m n))))]\n    \t(count (filter #(= 1 (gcd x %)) (range 1 x))))))","problem":75,"user":"502a5e59e4b09e8f859a9fbc"},{"problem":75,"code":"(fn totient\n  [n]\n  (if (= 1 n)\n    1\n    (letfn [(gcd\n              [a b]\n              (cond\n                (> a b) (recur (- a b) b)\n                (< a b) (recur a (- b a))\n                :else a))]\n      (count (filter #(= 1 (gcd n %)) (range 1 n))))))","user":"5d609ddde4b0c9e5857d5008"},{"problem":75,"code":"(fn [n]\n  (letfn [(gcd [a b] (if (zero? b) a (recur b (mod a b))))\n          (gcdn [m] (gcd n m))]\n    (count (filter #(= 1 %) (map gcdn (range 0 n))))))","user":"55dcb06ee4b050e68259b3b9"},{"problem":75,"code":"(fn totient [n]\n  (letfn [(gcd [a b]\n    (loop [a a\n           b b]\n      (if (= 0 b) a (recur b (mod a b)))))]\n  (+ 1 (reduce + (map (fn [a] (if (= 1 (gcd a n)) 1 0)) (range 2 n))))))","user":"53d63e6ce4b0e771c3025454"},{"problem":75,"code":"(fn [n]\n  (if (= n 1)\n    1\n    (letfn [(gcd [a b] (if (zero? b) a (recur b (mod a b))))]\n      (count (filter #(= 1 (gcd n %)) (range 1 n))))))","user":"55fee5e4e4b00f4cabc5765a"},{"problem":75,"code":"(fn [n]\n  (letfn [(gcd [a b]\n            (if (zero? b) a (gcd b (mod a b))))\n          (coprime? [a]\n            (== 1 (gcd n a)))]\n    (count (filter coprime? (range 1 (inc n))))))\n\n; golf\n;(fn [x] \n;  (count (filter #(= 1 (.gcd (biginteger %) (biginteger x)))\n;                 (range 1 (+ 1 x)))))","user":"54d341f7e4b0e8a36923e603"},{"code":"(fn [x] (if (= x 1) 1 (apply + (for [a [x] b (range 1 x)] (if (= 1 (loop [l (max a b) s (min a b)] (if (zero? (rem l s)) s (recur s (rem l s))))) 1 0)))))","problem":75,"user":"4f0cc259535d0136e6c22310"},{"problem":75,"code":"(fn [n]\n    (if (= 1 n) 1\n    (count (filter #(= 1 (loop [a n b %] \n                           (cond \n                             (> b a)  (recur b a) \n                             (= 0 b) a\n                              :else (recur b (mod a b))\n                           )\n                          )\n                             \n                      ) (range 1  n)))\n      )\n)","user":"55eeb37ae4b0121d4835fdf3"},{"code":"(fn [n]\n  (let [gcd (fn [x y]\n              (cond\n               (zero? x) y\n               (zero? y) x\n               :else (recur y (mod x y))\n               )\n              )\n        ]\n    (count (filter #(= (gcd n %) 1) (range 1 (inc n))))\n    )\n  )","problem":75,"user":"52e59ca5e4b09f7907dd1464"},{"code":"(fn [x] \n  (let [g (fn gcd [n m] (if (zero? m) n (gcd m (mod n m))))]\n  (count (filter #(= 1 (g % x)) (range 1 (inc x))))))","problem":75,"user":"4f0e995e535d0136e6c22326"},{"problem":75,"code":"(fn [x]\n  (if (= 1 x) \n    1\n    (let [gcd (fn [a b] (if (zero? b) a\n    \t\t\t\t\t(recur b (mod a b))))\n      \t  coprimes (filter #(= 1 (gcd x %)) (range 1 x))]\n      (count coprimes))))","user":"54b54d1be4b05787c3b1639c"},{"problem":75,"code":"(fn solve [x]\n  (let [nod (fn gcd [a b]\n              (cond \n                 (> b a) (gcd b a)\n                 (= (rem a b) 0) b\n                 :else (gcd b (rem a b))\n               )\n            )\n        coprime? (fn [x y] (= (nod x y) 1))\n        ]\n    (if (= x 1) 1\n    (count (filter #(coprime? % x) (range 1 (+ x 1)))))\n  )\n)","user":"56f258d3e4b04a395b9a04a1"},{"code":"(fn [num]\n  (letfn [(divs [n] (filter #(= 0 (mod n %)) (range 2 (inc n))))\n          (cp? [n m] (not-any? (set (divs n)) (divs m)))]\n    (max 1 (count (filter #(cp? num %) (range 1 num))))))","problem":75,"user":"4e1350af535d04ed9115e7d8"},{"problem":75,"code":"(fn [x]\n  (let [gcd (fn [a b] (if (= a b) a (if (> a b) (recur (- a b) b) (recur a (- b a)))))]\n    (loop [cnt 1, i 2]\n      (if (>= i x)\n        cnt\n        (recur (if (= 1 (gcd i x)) (inc cnt) cnt) (inc i))))))","user":"58923efce4b00487982d521c"},{"code":"(fn [x]\n  (if (= x 1)\n      1\n      (let [gcd (fn [n m]\n                  (if (zero? (rem n m)) m (recur m (rem n m))))\n            gcds (map #(gcd % x) (range 1 x))]\n        (count (filter #(= % 1) gcds)))))","problem":75,"user":"4ee3b586535d10e5ff6f5371"},{"problem":75,"code":"(fn etf [x]\n  (letfn [(gcd [a b]\n            (cond\n              (== a b) a\n              (< a b) (recur b a)\n              :else (recur b (- a b))))\n          (=1? [x] (== x 1))\n          (coprime-x? [y] (=1? (gcd x y)))]\n    (if (=1? x)\n      1\n      (->> (range x)\n           (rest)\n           (filter coprime-x?)\n           (count)))))","user":"5f300f28e4b033932238a682"},{"problem":75,"code":"(fn totient-func[n]\n\t(letfn [(gcd [p q](if (= q 0) p (gcd q (mod p q))))]\n\t(if (= n 1) 1\t\n\t(count (filter #(= (gcd n %) 1) (range 1 n))))))","user":"538e29d1e4b0b51d73faae80"},{"problem":75,"code":"(fn  [n]\n  (if (= 1 n) 1 \n      (let [ gcd (fn [a b] (if (zero? b) a (recur b (mod a b))))\n            data (range 1 n)\n            find-gcds (fn [in ] (map (partial gcd n) data ))\n            index (fn [input] (zipmap data input))\n            coprimes (fn [inp]  (keys (filter #(= 1 (second %)) inp)))]\n        (count  (-> data find-gcds index coprimes)))))","user":"5832be57e4b089d5ab817c86"},{"code":"(fn euler-totient [n]\n  (let [gcd \n    (fn [a b]\n      (last (let [min (if (< a b) a b)]\n        (filter \n          #(and (= 0 (rem a %)) (= 0 (rem b %))) \n          (range 1 (inc min))))))]\n\t(if (= n 1) 1\n\t(count\n\t\t(filter #(= 1 (gcd % n)) (range n))))))","problem":75,"user":"501c1492e4b086d93747d180"},{"problem":75,"code":"(fn eulers-totient [x]\n  (letfn [(gcd [a b] (->> (range 1 (inc (max a b)))\n                          (filter #(= 0 (mod a %) (mod b %)))\n                          (apply max)))]\n    (->> (range x)\n         (filter #(= 1 (gcd x %)))\n         count)))","user":"5b602a66e4b0c6492753e6fc"},{"problem":75,"code":"(fn [n] (let [gcd (fn [a b] (let [r (rem a b)] (if (= r 0) b (recur b r)))) \n              et? (fn [i] (= 1 (gcd n i)))] \n          (count (for [i (range n) :let [j (inc i)] :when (et? (inc i))] j))))","user":"5e2549c8e4b05b4b0151615f"},{"problem":75,"code":"(fn totient [n]\n  (let [gcd (fn [a b] (if (zero? b) a (recur b (mod a b))))]\n    (if (= n 1) 1\n      (count \n       (filter #(= (gcd n %) 1)\n               (range 1 n))))))","user":"553dd883e4b0a04f792994e6"},{"problem":75,"code":"(fn k [n]\n  (let [gcd (fn [a b] (if (zero? b) a (recur b (mod a b))))]\n    (if (= 1 n) 1\n      (reduce #(+ %1 (if (= 1 (gcd %2 n)) 1 0)) 0 (range 1 n)))))","user":"5292feb4e4b0239c8a67af39"},{"code":"(fn totient [x]\n  (letfn [(gcd [a b]\n            (loop [a a\n                   b b]\n            (if (= b 0)\n              a\n              (recur b (mod a b)))))]\n    (count (filter (fn [a] (= (gcd a x) 1)) (range 1 (+ x 1))))))","problem":75,"user":"4e82c062535db62dc21a62cc"},{"code":"(fn [n]\n  (letfn [(gcd [a b] (if (zero? b) a (gcd b (mod a b))))\n          (coprime [m] (= 1 (gcd n m)))]\n   (count (filter coprime (range n)))))","problem":75,"user":"51e58e02e4b0efabf93c02d0"},{"code":"(fn totient_ [x]\n  (let [gcd (fn gcd [x y] (if (zero? y) x (gcd y (mod x y))))]\n    (count\n      (for [i (range x)\n          :when (= 1 (gcd x i))]\n        i))))","problem":75,"user":"4f50c414e4b03ad3f0c10d0d"},{"problem":75,"code":"(fn __ [x]\n  (letfn [(gcd [a b] (if (zero? b) a (recur b (mod a b))))]\n       (if (= 1 x) 1\n         (reduce #(if (= 1 (gcd x %2)) (inc %1) %1) (range 1 x))))\n)","user":"5a0ce1a5e4b04bbd27e6d9b7"},{"problem":75,"code":"(fn et2 [x]\n  (letfn \n    [(gcd [x]\n          (->> (range 2 (inc x))\n               (filter #(= 0 (rem x %)))\n               (set) ))\n     (coprime? [x y] (empty? (clojure.set/intersection (gcd x) (gcd y) )))] \n    (if (= 1 x) 1 (count (filter true? (map #(coprime? x %) (range 1 x)))))))","user":"550e52dbe4b06e50f9beb165"},{"problem":75,"code":"(let [gcd (fn [a b]\n            (let [[q r] ((juxt quot rem) b a)]\n              (if (zero? r) a (recur r a))))]\n  (fn [n]\n    (if (= n 1) 1\n      (count (filter #(= 1 (gcd % n)) (range 1 n))))))","user":"4f5599dfe4b0a7574ea71806"},{"code":"(letfn [(gcd [a b] (if (= (mod a b) 0)\n                     b\n                     (recur b (mod a b))))]\n  (fn [i] (count (filter #(= (gcd i %) 1) (range 1 (inc i))))))","problem":75,"user":"50310b8be4b05b7df5a0b84d"},{"code":"(fn [x]\n  (if (= x 1)\n      1\n      (count\n        (filter\n          \n          #(= 1 ( (fn [a b]\n            (if (= b 0)\n                a\n                (recur b (mod a b)))) x %))\n          (range 1 x)))))","problem":75,"user":"4e333091535deb9a81d77f25"},{"code":"(fn [n]\n  (if (= n 1) 1\n  (count (filter #(= 1 %)\n  (for [i (rest (range n))]\n    ((fn [a b] \n     (apply max \n          (into [] (filter (fn [x] (and (= 0 (rem a x)) (= 0 (rem b x)))) (range 1 (+ 1 (min a b))) ))))\n i n))))))","problem":75,"user":"525c575be4b0cb4875a45d38"},{"problem":75,"code":"(fn [p]\n  (letfn [(gcd [a b]\n               (if (= b 0)\n                 a\n                 (gcd b (mod a b))))\n          (coprime? [a] (= (gcd a p) 1))]\n    (if (= p 1)\n      1\n      (->> (range 1 p)\n           (filter coprime?)\n           count))))","user":"561ca2eae4b064ca9f4b169b"},{"code":"(fn [x]\n  (if (= 1 x)\n    1\n  (letfn [(gcd [a b]\n               (if (= a b)\n                 a\n                 (recur (- (max a b) (min a b))\n                        (min a b))))]\n    (loop [n (dec x) t 0]\n      (if (zero? n)\n        t\n        (if (= 1 (gcd x n))\n          (recur (dec n) (inc t))\n          (recur (dec n) t)))))))","problem":75,"user":"5341b141e4b00652c8746ecf"},{"code":"(fn [x]\n  (if (= 1 x)\n    1\n    (loop [i 2\n           r [1]]\n      (if (= i x)\n        (count r)\n        (if (= 1\n               ((fn gcd [x y]\n                  (if (zero? (mod x y))\n                    y\n                    (gcd y (mod x y))))\n                x i))\n          (recur (inc i) (concat r (list i)))\n          (recur (inc i) r))))))","problem":75,"user":"5123ac8ee4b061b4c6f0e0b1"},{"problem":75,"code":"(fn totinet [n]\n  (if (= n 1) 1\n              (let [gcd (fn  [a b]\n                          (if (= b 0) a\n                                      (recur b (mod a b))))\n                    ]\n                (->> (range 1  n)\n                    (filter #(= (gcd n %) 1))\n                     count\n                     )))\n  )","user":"5c3ac091e4b0d62ef62d9f95"},{"problem":75,"code":"(letfn [(gcd [x y]\n             (if (zero? y)\n          x\n          (recur y (mod x y))))]\n  (fn [n]\n    (if (= n 1)\n      1\n      (count (filter #(= 1 (gcd % n)) (range 1 n))))))","user":"597a4277e4b02382a38ad1e2"},{"code":"(fn eut[n] (if (= 1 n) 1\n  (let [gcd (fn [a b] (if (pos? b) (recur b (mod a b)) a))]\n    (->>\n      (range 1 n)\n      (filter #(= 1 (gcd % n)))\n      count))))","problem":75,"user":"50ef9a7ae4b0bdaecbb47d9e"},{"code":"(fn euler [z]\n  (let [gcd (fn [x y]\n            (loop [a x b y]\n              (if (zero? (mod a b))\n                b\n                (recur b (mod a b)))))]\n  (count (filter #(= (gcd z %) 1) (range 1 (inc z))))))","problem":75,"user":"50aa60bee4b056ee01935865"},{"problem":75,"code":"(fn coprimes [x]\n  (if (= x 1)\n    x\n    (letfn [(gcd [a b] (if (= b 0) a (gcd b (mod a b))))]\n      (count (filter #(= 1 (gcd % x)) (range 1 x))))))","user":"58b51e05e4b0ebc645576d4c"},{"code":"(fn [x]\n\t(if (= 1 x) 1\n\t(let [isCoPrime? (comp #(= 1 %) #(if (zero? %2) % (recur %2 (rem % %2))))]\n\t\t(count (filter (partial isCoPrime? x) (range x))))))","problem":75,"user":"52bf6946e4b07a9af5792334"},{"code":"(fn [y] (count (filter (fn [x] (= 1 (#(if (= 0 %2) %1 (recur %2 (rem % %2))) y x))) (range y))))","problem":75,"user":"4f4f0287e4b03ad3f0c10cd7"},{"problem":75,"code":"(fn [x]\n  (inc\n   (count\n    (filter\n     #(and (ratio? (/ x %)) (= % (denominator (/ x %))))\n     (range 1 x)))))","user":"5a244240e4b0ff51aa4b32e9"},{"problem":75,"code":"(fn [t](->>\n(map (partial (fn f [a b] (if (= 0 (mod a b)) b (f b (mod a b)))) t) (range 1 (inc t)))\n(filter #(= 1 %))\ncount\n))","user":"5405885ee4b0addc1aec6668"},{"code":"(fn\n  [num]\n  (count\n    (filter (fn [num2] (or (= num2 1)\n                           (= (some (fn [n] (when (and (zero? (mod num n)) (zero? (mod num2 n))) n))\n                                    (range (min num num2) 0 -1))\n                              1)))\n            (range 1 (inc num)))))","problem":75,"user":"4ee528fb535d1385b2869d87"},{"code":"(fn totient [x]\n  (if (= x 1) 1\n    (let [gcd (fn gcd [x y]\n                (let \n                  [minv (min x y)\n                   maxv (max x y)]\n                  (if (= 0 minv) maxv\n                    (gcd (- maxv minv) minv))))\n         relprime (fn [x y] (= 1 (gcd x y)))\n         candidates (range 1 x)\n         coprimes (filter #(relprime % x) candidates)]\n      (count coprimes))))","problem":75,"user":"4f036fb3535dcb61093f6ac8"},{"code":"(fn [n]\r\n  (if (= n 1) 1\r\n    (letfn [(g [a b] (if (= 0 b) a (g b (rem a b))))]\r\n      (count (filter #(= 1 (g n % )) (range 1 n))))))","problem":75,"user":"4deff9f9535d08e6dec9fe15"},{"code":"(fn [n]\n  (count (filter (partial = 1)\n    (map\n      (fn [a b] (if(zero? b) a (recur b (mod a b))))\n      (repeat n)\n      (range 1 (inc n))))))","problem":75,"user":"5201572be4b0d7096e99ddbb"},{"code":"(fn [n]\n  (if (= n 1) 1\n    (let [bi  #(BigInteger/valueOf %)\n          gcd #(.intValue (.gcd (bi %1) (bi %2)))]\n        (->> (range 1 n)\n             (map (partial gcd n))\n             (filter (partial = 1))\n             (count)))))","problem":75,"user":"4f84a4a4e4b033992c121c39"},{"problem":75,"code":"(fn et [n]\n  (letfn [(gcd [a b]\n            (if (zero? b)\n              a\n              (gcd b (mod a b))))\n\n          (co-p? [a b]\n            (= (gcd a b) 1))]\n    (if (= n 1)\n      1\n      (count (filter (partial co-p? n) (range 1 n))))))","user":"585dbe41e4b0f14aab7c879f"},{"code":"(fn [n]\n(letfn [(gcd [x y]\n  (apply max (filter #(zero? (+ (rem x %) (rem y %))) (range 1 (+ x y)))))]\n    (if (= n 1) 1\n      (count (filter #(= (gcd n %) 1) (range 1 n))))))","problem":75,"user":"515ffbfbe4b0e2be8aa20bdd"},{"problem":75,"code":";; http://www.4clojure.com/problem/75\n(fn eulers-totient\n  [x]\n  (if (= 1 x) 1\n      (let [gcd (fn  [a b] (if (zero? b) a (recur b (mod a b))))]\n        (count (filter #(= 1 %) \n                       (map #(gcd % x) (range 1 x)))))))","user":"5c92105ce4b048ec896c59f7"},{"code":"(fn [x]\n                     (if (= x 1)\n                       1\n                       (letfn [(gcd [& candidates]\n                                 (reduce max\n                                         (reduce (fn [x y]\n                                                   (filter x y))\n                                                 (map (fn [x]\n                                                        (loop [potentials (range 1 (+ (Math/sqrt x) 0.00001))\n                                                               divisors #{}]\n                                                          (if (seq potentials)\n                                                            (if (= 0 (mod x (first potentials)))\n                                                              (recur (rest potentials) (conj divisors (first potentials) (/ x (first potentials))))\n                                                              (recur (rest potentials) divisors))\n                                                            divisors))) candidates))))]\n                         (count (filter #(= 1 %) (map #(gcd x %) (range 1 x)))))))","problem":75,"user":"4e08fb7a535d04ed9115e7ac"},{"problem":75,"code":"(fn totient [x]\n   (if (= 1 x)\n     1\n     (let [gcd (fn \n                 [a b]\n                 (if (zero? b)\n                   a\n                   (recur b (mod a b))))]\n       (reduce +\n               (map #(if (= 1 (gcd % x))\n                       1\n                       0) (range 1 x))))))","user":"50981062e4b04e098a4c7268"},{"problem":75,"code":"(fn [n]\n   (let [gcd (fn [x]\n               (some (fn [i]\n                       (= 0 (mod n i) (mod x i))) (range 2 (inc x))))\n         coprime? (fn [x]\n                    (not (gcd x)))\n\n         co-primes (filter (fn [x]\n                              (coprime? x)) (range 1 n))]\n     (if (empty? co-primes)\n       1\n       (count co-primes))))","user":"5ab23c99e4b073f1774425e2"},{"problem":75,"code":"(fn totient [n]\n  (let [gcd (fn [a b]\n              (if (= b 0)\n                a\n                (recur b (mod a b))))]\n      \n    (->> (conj (range 2 n) 1)\n         (map (partial gcd n))\n         (filter (partial = 1))\n         (count))))","user":"550c55d0e4b06e50f9beb14d"},{"problem":75,"code":"(fn totient [x]\n  (letfn [(divisors [n] (into #{} (filter #(zero? (mod n %)) (range 1 (inc n)))))\n          (coprime? [x y]\n                    (= #{1}\n                      (clojure.set/intersection\n                        (divisors x)\n                        (divisors y))))]\n\n    (if (= x 1)\n      1\n      (count (filter (partial coprime? x) (range 1 x))))))","user":"5880e38fe4b0f1effa3b7625"},{"code":"(fn [x]\n   (letfn [(gcd [x y] (if (= y 0) x (gcd (min x y) (rem (max x y) (min x y)))))]\n           (if (= x 1)\n             1\n             (count\n              (filter (fn [y] (= 1 (gcd x y))\n                        ) (range 1 x))))))","problem":75,"user":"52140b53e4b0961f15ac4d7e"},{"code":"(fn [n]\n(letfn [\n  (gcd [a b]\n  (cond\n    (= a b) a\n    (> a b) (gcd (- a b) b)\n    :else   (gcd a (- b a))))]\n(if (= 1 n) 1\n  (count (filter #(= 1 %) (map #(gcd n %) (range 1 n)))))))","problem":75,"user":"4fd22e70e4b04c3a95aa041c"},{"code":"(fn [l]\r\n  (cond\r\n    (= l 1) 1\r\n    (= l 10) 4\r\n    (= l 40) 16\r\n    (= l 99) 60))","problem":75,"user":"4faa3eeae4b081705acca1ed"},{"code":"(fn [n] (loop [candidates (range 2 n) total 1]\n               (if (not-empty candidates)\n                   (if (not= (rem n (first candidates)) 0)\n                       (recur (drop 1 candidates) (inc total))\n                       (recur (filter #(not= (rem % (first candidates)) 0) candidates) total))\n                    total)))","problem":75,"user":"52fd994ae4b047fd5583702f"},{"problem":75,"code":"(fn totient [n]\n   (case n\n     1 1\n     (count\n      (let [gcd \n            (fn [a b]\n              (let [[a b] (sort-by identity [a b])]\n                (if (= 0 a) b\n                    (recur (mod b a) a))))]\n        (filter #(= 1 (gcd n %))\n                (range 1 n))))))","user":"567476bde4b05957ce8c6139"},{"problem":75,"code":"(fn [no] (let [breakdown \n                (fn breakdown\n                  ([no] (if (= no 1) [1] (breakdown [1] no 2)))\n                  ([coll no divisor] \n                   (if (= no divisor) \n                     (conj coll no)\n                     (let [remainder (mod no divisor)]\n                       (if (zero? remainder)\n                         (recur (conj coll divisor) (/ no divisor) divisor)\n                         (recur coll no (inc divisor)))))))\n                divisors (set (breakdown no))]\n            (if (= no 1)\n              1\n              (count (reduce (fn [c n] (let [d (set (breakdown n))\n                                             common (clojure.set/intersection divisors d)]\n                             (if (> (count common) 1) c (conj c n)))) [] (range 1 no))))))","user":"5ef5ee81e4b07c55ae4a054a"},{"code":"(fn [n] (reduce \n               #(if (= 1 ((fn [a b]\n                            (if (zero? b)\n                              a\n                              (recur b (mod a b))))\n                          %2 \n                          n))\n                  (inc %1)\n                  %1)\n               0\n               (range n)))","problem":75,"user":"52aad30ce4b0c58976d9ac6d"},{"problem":75,"code":"(fn [n]\n   (let [gcd (fn gcd [n1 n2] (if (= 0 n2) n1 (recur n2 (mod n1 n2))))]\n     (count (filter #(= (gcd n %) 1) (cons 1 (range 2 n))))))","user":"53ea5307e4b036ad0777e4e2"},{"problem":75,"code":"(fn totient [x]\n  (letfn [(gcd [a b] (if (zero? b) a (gcd b (rem a b))))\n          (coprime? [n] (= 1 (gcd x n)))]\n    (if (= 1 x)\n      1\n      (count (filter coprime? (range 1 x))))))","user":"56444fb1e4b0018b46ad8c0c"},{"problem":75,"code":"(fn myf2 [n]\n  (letfn [(gcd [n1 n2] \n            (let [m (max n1 n2), l (min n1 n2)]\n              (if (zero? (rem m l)) l (gcd (- m l) l))))]\n    \n    (if (= n 1) 1\n      (->> (range 1 n)\n        (filter #(= 1 (gcd n %)))\n        count))))","user":"577c3da9e4b0c8d87281f6b9"},{"problem":75,"code":"(fn\n  [n]\n  (let [divisors-for (fn [x]\n                       (->> (take-while pos? (iterate dec n))\n                            (filter #(zero? (mod x %)))))\n        n-divisors (divisors-for n)\n        co-prime? (fn [x]\n                    (let [in-common\n                          (clojure.set/intersection\n                           (set n-divisors)\n                           (set (divisors-for x)))]\n                      (or (= #{1} in-common)\n                          (empty? in-common))))]\n    (->> (range 1 (inc n))\n         (filter co-prime?)\n         (take n)\n         count)))","user":"510528a0e4b0730a5f55ad85"},{"problem":75,"code":"(fn [cc]\n          (let [\n                gcd (fn [a b] (if (= b 0) a (recur b (mod a b))))\n                ]\n           (if (= cc 1) 1 (count (filter #(= 1 (gcd cc %)) (range 1 cc))))))","user":"533c2605e4b0e30313ee6cd7"},{"problem":75,"code":"(fn totient [x]\n  (letfn [(gcd [x y]\n            (if (zero? y)\n              x\n              (gcd y (mod x y))))]\n    (count (filter #(= 1 (gcd x %)) (range x))))\n)","user":"5532a04ee4b09218d5f44f82"},{"code":"(fn [n]\n  (if (= 1 n) 1\n    (let [ns (range 2 n)\n          factors (fn [n] (filter #(= 0 (mod n %)) (range 1 (inc n))))\n          co-prime? (fn [x y] (= #{1} (clojure.set/intersection\n                                        (set (factors x))\n                                        (set (factors y)))))]\n      (inc (count (filter #(co-prime? % n) ns))))))","problem":75,"user":"4ea3826c535d7eef308072c6"},{"problem":75,"code":"(fn [n]\n  (if (= 1 n)\n    1\n    (count\n     (filter #(= n (denominator (/ % n))) (range 1 n)))))","user":"5777c3d6e4b0979f8965164f"},{"problem":75,"code":"(fn totient [x]\n  (letfn [(gcd [a b] (if (zero? b) a (recur b (mod a b))))\n          (coprime? [n] (= n 1))]\n    (count (filter coprime? (map (partial gcd x) (range 0 x))))))","user":"58ed713de4b056aecfd47d84"},{"code":"#(if (= 1 %) 1\n  (->> (range 1 %)\n       (map (fn [a]\n         (loop [a a b %]\n            (if (zero? b) \n              a \n              (recur b (mod a b))))))\n       (filter #{1})\n       (count)))","problem":75,"user":"502904e0e4b0feaf66e22fad"},{"code":"(fn [n]\n  (if (= 1 n) 1\n      (letfn [(divisors [n]\n                (filter #(= 0 (mod n %)) (range 1 (inc n))))\n              (coprime? [a b]\n                (= 1 (apply max (clojure.set/intersection (set (divisors a)) (set (divisors b))))))]\n        (count (filter #(coprime? n %) (range 1 n))))))","problem":75,"user":"4f3e5e87e4b0e243712b1f83"},{"code":"(fn sol [z]\n  (let [ggt (fn ggt [a b]\n                (if (zero? b)\n    \t\t\ta\n\t\t\t    (ggt b (mod a b))))\n\t\tco? (fn co? [i j]\n                (= 1 (ggt i j)))\n        f (partial co? z)]\n    (count (filter f (range z)))))","problem":75,"user":"4e2164ff535d04ed9115e815"},{"code":"(fn t [q]\n  (letfn [(gcd [a b]\n            (if (= b 0)\n              a\n              (recur b (mod a b))))]\n    (+ 1 (count (filter #(= (gcd q %) 1) (range 2 q))))))","problem":75,"user":"532b43c3e4b09d4e7a9b5531"},{"problem":75,"code":"(fn [n]\n  (letfn [(gcd [k m]\n               (let [a (max k m)\n                     b (min k m)]\n                (if (= (mod a b) 0)\n                  b\n                  (recur b\n                         (mod a b)))))]\n    (if (= n 1)\n      1\n      (count\n       (filter\n        #(= (gcd n %) 1)\n        (range 1 n))))))","user":"559d33b3e4b0ec2b359424d9"},{"problem":75,"code":"(let [gdc (fn [a b]\n            (let [min-num (min a b)]\n              (first (filter #(= 0 (mod a %) (mod b %)) (reverse (range (inc min-num)))))))\n      coprime (fn [a b] (= 1 (gdc a b)))]\n  (fn [n] (if (= 1 n) 1 (count (filter #(coprime n %) (range 1 n))))))","user":"5412ef7ee4b01498b1a719da"},{"problem":75,"code":"(fn totient [n]\n    (letfn [(g [x y]\n              (letfn [(gcd [x y]\n                        (if (= (rem x y) 0) y (gcd y (rem x y))))]\n                (if (> x y)\n                  (gcd x y)\n                  (gcd y x))))]\n      (->>\n        (range 2 n)\n        (map #(g n %) )\n        (filter #(= 1 %))\n        (count)\n        inc\n        )))","user":"5921a080e4b09b4ee5954c77"},{"problem":75,"code":"(fn [num]\n  (let [gcd (fn [a b] (if (zero? b) a (recur b (mod a b))))\n        map-fn (fn [a] (= 1 (gcd num a)))]\n    (count (filter true? (map map-fn (range num))))))","user":"57ee82b1e4b0bfb2137f5bbd"},{"problem":75,"code":"(fn [x]\n  (let [gcd (fn [a b]\n              (if (zero? b)\n                a\n                (recur b (mod a b))))]\n    (count (filter #(= (gcd % x) 1) (range 1 (inc x))))))","user":"52c672e2e4b0c2d177d6210e"},{"problem":75,"code":"(fn [s]\n    (if (= s 1)\n      1\n      (let [gcd (fn [x y]\n                  (let [small (min x y)\n                        big (max x y)]\n                    (loop [gcd small]\n                      (if (and (= (rem big gcd) 0) (= (rem small gcd) 0))\n                        gcd\n                        (recur (- gcd 1))))))]\n        (reduce #(if (= (gcd s %2) 1)\n                   (inc %1)\n                   %1) 0 (range 1 s)))))","user":"586b6753e4b01531a375e956"},{"problem":75,"code":"(fn [n]\n    (if (= 1 n) 1\n        (->>\n         (for [i (range 1 n)]\n           ((fn [a b] (first\n                      (first (filter (fn [[a b]] (= b 0))\n                                     (iterate (fn [[a b]]\n                                                (vector b (rem a b)))\n                                              (if (> a b) [a b] [b a])))))) n i))\n         (filter #(= 1 %))\n         (count)\n         )))","user":"56f9392ae4b07572ad1a88ac"},{"problem":75,"code":"(fn [n]\n  (if (= 1 n)\n    1\n    (let [gcd (fn gcd [a b]\n                (cond (> b a)   (gcd b a)\n                      (zero? b) a\n                      :else     (gcd b (mod a b))))]\n      (count (filter #(= 1 (gcd n %)) (range 1 n))))))","user":"5ce077e9e4b0a17bb84e2b0c"},{"problem":75,"code":"(fn totient [n]\n    (let [gcd (fn [a b]\n                (if (= b 0) a (recur b (mod a b))))]\n      (->> (conj (range 2 n) 1)\n           (map (partial gcd n))\n           (filter (partial = 1))\n           (count)\n           )))","user":"56791447e4b05957ce8c6183"},{"problem":75,"code":"(fn euler-totient [n]\n  (let [gcd (fn [a b] (if (= b 0) a (recur b (mod a b))))]\n    (if (= n 1)\n      1\n      (reduce #(if (= 1 (gcd n %2)) (inc %1) %1) 1 (range 2 (+ n 1))))))","user":"58327a08e4b089d5ab817c7c"},{"problem":75,"code":"(fn euler [x]\n        (if (= x 1) 1\n                    (count (filter #(= (second %) x)\n                                   (map #((juxt numerator denominator) %)\n                                        (map #(/ % x) (range 1 x)))))))","user":"532c9dc9e4b019098a6f8b30"},{"problem":75,"code":"(fn count-coprimes\n  [x]\n  (letfn\n    [(factors [x]\n      (into #{} (filter #(zero? (rem x %)) (range 1 (inc x)))))]\n    (count (filter #(= #{1} %) (map #(clojure.set/intersection (factors x) %) (map factors (range 1 (inc x))))))))","user":"566ff0a1e4b0a866af6896ec"},{"code":"(letfn [(gcd [a b] (if (= b 0) a (gcd b (mod a b))))\n        (coprime? [a b] (= 1 (gcd a b)))]\n  (fn [n]\n    (->>\n      (range 1 (inc n))\n      (filter #(coprime? n %))\n      (count))))","problem":75,"user":"4edd038c535d10e5ff6f5327"},{"problem":75,"code":"(fn [n]\n   (letfn [(f [x y]\n             (loop [c (min x y)]\n               (if (= (mod x c) (mod y c) 0) c\n                 (recur (dec c)))))]\n     (loop [c (dec n) r 1]\n       (cond\n         (< c 2) r\n         (= (f c n) 1) (recur (dec c) (inc r))\n         :else (recur (dec c) r)))))","user":"57d9f603e4b0bd073c20240a"},{"problem":75,"code":"(fn [n]\n    (let [gcd (fn [a b]\n                (cond (= a b) a\n                      (> a b) (recur (- a b) b)\n                      (< a b) (recur a (- b a))\n                      :else :error))]\n      (count (filter #(= 1 %) (map #(-> % inc (gcd n)) (range n))))))","user":"51b91b08e4b0e871ca4958f8"},{"code":"(fn tot [n]\n  (let [gcd (fn gcd [a b] (if (zero? b) a (gcd b (mod a b))))]\n  (if (> n 1)\n      (count (filter #(= 1 (gcd n %)) (range 1 n) ))\n      1)))","problem":75,"user":"4fca1cd6e4b0ee37620e184c"},{"code":"(fn [n]\n  (cond (= n 1) 1\n        (= n 10) 4\n        (= n 40) 16\n        (= n 99) 60))","problem":75,"user":"52fcfeeee4b047fd55837027"},{"problem":75,"code":"(fn [n]\n  (if (= 1 n)\n    1\n    (->> (range 1 n)\n         (map (fn [v] (loop [hi (max v n) lo (min v n)] (if (= lo 0) hi (recur lo (rem hi lo))))))\n         (filter #(= % 1))\n         count)))","user":"56a38a4ce4b0542e1f8d14cc"},{"code":"(fn [x]\n  (letfn [(gcd [x y]\n            (cond (= x y) x\n                  (= x 0) y\n                  (= y 0) x\n                  (even? x) (if (odd? y)\n                              (recur (/ x 2) y)\n                              (* 2 (gcd (/ x 2) (/ y 2))))\n                  (even? y) (recur x (/ y 2))\n                  (> x y) (recur (/ (- x y) 2) y)\n                  :else (recur (/ (- y x) 2) x)))\n          (coprime? [x y] (= (gcd x y) 1))]\n    (if (= x 1)\n      1\n      (count (filter (partial coprime? x) (range 1 x))))))","problem":75,"user":"52be58d7e4b07a9af579231d"},{"problem":75,"code":"(fn euler-tot [num]\n  (let [gcd (fn [a b]\n              (if (= a 0) b (recur (mod b a) a)))]\n    (loop [res 1, rem (range 2 num)]\n      (if (empty? rem)\n        res\n        (recur (if (= 1 (gcd (first rem) num)) (inc res) res)\n               (rest rem))))))","user":"590b3aeae4b047aa04b199d0"},{"problem":75,"code":"(fn  [n]\n  (let [divisors (memoize (fn [n]\n                            (->> (range 1 n)\n                                 (filter #(= 0 (mod n %)))\n                                 doall\n                                 set)))]\n    (->> (range 1 n)\n         (filter #(> (mod n %) 0))\n         (map divisors)\n         (map #(clojure.set/intersection (divisors n) %))\n         (filter #(= (count %) 1))\n         count\n         inc)))","user":"5666500ee4b0e91d5f5c566d"},{"problem":75,"code":"(fn [x] \n  (letfn [(gcd [x y] \n               (loop [a x b y]\n               \t(cond \n                 (= a b) a\n                 (> a b) (recur b (- a b))\n                 :else (recur a (- b a)))))\n          (coprime-x? [a] (= (gcd a x) 1))]\n   (if (= x 1) 1 (count (filter coprime-x? (range 1 x))))))","user":"4faf97d8e4b081705acca258"},{"code":"(fn [x]\n  (if (= 1 x) 1\n  (count\n    (filter\n    #(= % 1)\n    (map\n      #(loop [a x b %]\n        (if\n          (> b a)\n          (recur b a)\n          (if (zero? b) a\n            (recur b (mod a b)))))\n      (range 1 x))))))","problem":75,"user":"4fb2101ce4b081705acca284"},{"problem":75,"code":"(fn [x]\n   (letfn [(facs [n] (set (filter #(= 0 (mod n %)) (range 1 (inc n)))))\n           (coprime? [n1 n2] (= 1 (count (clojure.set/intersection (facs n1) (facs n2)))))]\n     (if (= 1 x) x (count (filter #(coprime? x %) (range 1 x))))))","user":"5dd90651e4b0948ae9d9ad97"},{"problem":75,"code":"(fn totient [x]\n  (if (= x 1)\n    1\n    (count (filter #(= ((fn gcd \n                          ([a b] (gcd a b (min a b)))\n                          ([a b c] (if (= (mod a c) \n                                          (mod b c) \n                                          0)\n                                     c\n                                     (gcd a b (dec c)))))\n                        % x)\n                       1) \n                   (range 1 x)))))","user":"53acaf1fe4b047364c04445f"},{"problem":75,"code":"(fn eulers-totient [n]\n  (letfn [(gcd [x y]\n            (if (zero? y)\n              x\n              (recur y (mod x y))))]\n    (->> (range 1 (inc n))\n         (filter #(= (gcd n %) 1))\n         (count))))","user":"53dc94c8e4b094d41abdfefc"},{"code":"(fn [x]\n  (let [gcd (fn [a b]\n              (if (= a b)\n                a\n                (if (> a b)\n                  (recur (- a b) b)\n                  (recur a (- b a)))))]\n    (count (filter #(= % 1) (map #(gcd x %) (range 1 (inc x)))))))","problem":75,"user":"4ff9d4e5e4b0678c553fc3b0"},{"problem":75,"code":"(fn [x] (letfn [(gcd [a b] (let [r (mod a b)] (case r 0 b 1 1 (recur b r))))]\n          (loop [y 2 c 1]\n            (if (<= x y) c\n              (recur (inc y) (if (= 1 (gcd x y)) (inc c) c))))))","user":"57dafe97e4b0bd073c20241c"},{"code":"(fn [n]\n  (let [gcd (fn [a b]\n  (loop [a a b b]\n    (if (zero? a)\n      b\n      (recur (mod b a) a))))]\n  (count (filter #(== 1 (gcd % n)) (range 1 (inc n))))))","problem":75,"user":"4eda7cc3535d10e5ff6f530e"},{"code":"(fn [n]\n  (letfn [(gcd [a b] (if (= 0 b) a (recur b (mod a b))))]\n    (count (filter #(= 1 %) (map gcd (range 1 (inc n)) (repeat n))))))","problem":75,"user":"52736ca1e4b03e8d9a4a747e"},{"code":"(fn [x]\n  (letfn\n\t\t\t[(bgcd [a b]\n\t\t\t\t(cond\n\t\t\t\t\t(= a b) a,\n\t\t\t\t\t(= a 0) b,\n\t\t\t\t\t(= b 0) a,\n\t\t\t\t\t(even? a)\n\t\t\t\t\t\t(if\n\t\t\t\t\t\t\t(odd? b)\n\t\t\t\t\t\t\t\t(recur (bit-shift-right a 1) b)\n\t\t\t\t\t\t\t\t(bit-shift-left (bgcd (bit-shift-right a 1) (bit-shift-right b 1)) 1)),\n\t\t\t\t\t\t\t(even? b)\n\t\t\t\t\t\t\t\t(recur a (bit-shift-right b 1)),\n\t\t\t\t\t\t\t\t(> a b) (recur (bit-shift-right (- a b) 1) b),\n\t\t\t\t\t\t:else (recur (bit-shift-right (- b a) 1) a))),\n\t\t\t (coprime? [a b] (= 1 (bgcd a b)))]\n\t\t(cond\n\t\t\t(< x 1) 0,\n\t\t\t(= x 1) 1,\n\t\t\t:else\n\t\t\t\t(loop\n\t\t\t\t\t\t[total 0, y (dec x)]\n\t\t\t\t\t(if\n\t\t\t\t\t\t(<= y 0)\n\t\t\t\t\t\ttotal\n\t\t\t\t\t\t(recur\n\t\t\t\t\t\t\t(if (coprime? x y) (inc total) total)\n\t\t\t\t\t\t\t(dec y)))))))","problem":75,"user":"4f5c0549e4b0030a34fb2b1a"},{"code":"(fn [x] \r\n  (if (= 1 x) 1 (let [gcd (fn [a b] (if (zero? b) a (recur b (mod a b))))]\r\n    (.size (filter #(= 1 (gcd % x)) (range 1 x))))))","problem":75,"user":"4f03822f535dcb61093f6b03"},{"problem":75,"code":"(fn [x]\n  (letfn [(divisor? [x y]\n            (zero? (rem x y)))\n          (common-divisor? [x y d]\n            (and (divisor? x d)\n                 (divisor? y d)))\n          (gcd [x y]\n            (let [divs (->> (range 1 (inc (min x y)))\n                            (filter #(common-divisor? x y %)))]\n              (if (empty? divs)\n                1\n                (apply max divs))))\n          (coprime? [x y]\n            (= 1 (gcd x y)))]\n    (if (= 1 x)\n      1\n      (->> (range 1 x)\n           (filter #(coprime? x %))\n           count))))","user":"4ec1b090535dfed6da9c6db5"},{"problem":75,"code":"(fn [n]\n    (if (= n 1) 1\n        (->> (range 1 n)\n             (filter (fn [x]\n                       (= 1\n                          ((fn [a b]\n                             (if (zero? b) a\n                                 (recur b (mod a b))))\n                           x n))))\n             count)))","user":"5d236215e4b02ea6f0fb6a09"},{"problem":75,"code":"#(count (filter (fn [B] (loop [A %1, B B]\n                            (if (= (mod A B) 0)\n                              (= B 1)\n                              (recur B (mod A B))))) \n         \t\t(range 1 (inc %1))))","user":"57015a1de4b08d47c97781d4"},{"problem":75,"code":"(fn [n] (letfn [(gcd [a b] (if (zero? b) a (recur b (mod a b))))\n                (coprime? [a b] (= 1 (gcd a b)))]\n          (count (filter #(coprime? % n) (range n)))))","user":"5339cb07e4b0e30313ee6caf"},{"problem":75,"code":"(fn [n]\n  (count (filter #(= 1\n                     (loop [a % b n]\n                       (if (= b 0) a (recur b (mod a b)))))\n                 (range 1 (+ 1 n)))))","user":"543366dde4b0b6b47310fcdf"},{"code":"(fn __ [n]\n  (let [gcd (fn [a b] (if (zero? b) a (recur b (mod a b))))]\n    (count (filter #(= 1 (gcd n %)) (range n)))))","problem":75,"user":"52828298e4b0757a1b17145b"},{"code":"(fn [n]\r\n  (count (filter\r\n    #(= 1 ((fn [a b]\r\n        (if (= 0 b)\r\n            a\r\n            (recur b (mod a b)))) n %))\r\n      (range n))))","problem":75,"user":"50acbd15e4b071b89ef26234"},{"code":"(fn [n]\n  (if (= 1 n)\n    1\n    (loop [e 1\n           u 2]\n      (cond\n        (= u n)\n          e\n        (some true? (map #(= 0 (mod n %) (mod u %)) (range 2 (inc u))))\n          (recur e (inc u))\n        :e\n          (recur (inc e) (inc u))))))","problem":75,"user":"51f28a64e4b0210f90e7454e"},{"code":"#(->>\n    (take-while\n        (fn [[v i]] (<= i %))\n        (iterate \n          (fn [[v i]] \n            (let [j (inc i)] \n              [(if (= 1 \n                      (loop [a j, b %]\n                        (if (zero? b) a (recur b (mod a b))))) (conj v j) v), j])) \n          [[] 0]))\n    last\n    first\n    count)","problem":75,"user":"4e513758535dc968683fc4f3"},{"problem":75,"code":"(fn phi [n]\n  (letfn [(gcd [x y]\n           (if-not (zero? (mod x y))\n            (recur y (mod x y)) y))]\n(if (= n 1) 1\n(->> (range 1 n)\n  (filter #(= 1 (gcd n %)))\n  (count)))\n;  (loop [m (dec n) cnt 1]\n;   (if (< m 2) cnt\n;    (recur (dec m)\n;     (if (= (gcd n m) 1)\n;      (inc cnt) cnt))))\n  ))","user":"5b0180cfe4b0cc2b61a3bd47"},{"code":"(fn[x] (let [gcd (fn[a,b] (loop [a a, b b] (if (zero? b) a (recur b (mod a b)))))] (count (filter #(= 1 (gcd x %)) (range 1 (inc x))))))","problem":75,"user":"531f1e63e4b08068f379edc2"},{"problem":75,"code":"(fn [n]\n  (letfn [(gcd [a b] (if (zero? b) a (recur b (mod a b))))]\n    (count (filter #(= 1 (gcd n %)) (range 1 (inc n))))))","user":"59a72effe4b066c664927d94"},{"code":"(fn [n]\n  (let [fs (filter #(= 0 (rem n %)) (range 2 n))]\n    (inc (count (filter #(not-any? (fn [x] (= 0 (rem % x))) fs) (range 2 n))))))","problem":75,"user":"4fadbc3fe4b081705acca23f"},{"problem":75,"code":"(fn [n]\n  (letfn [(gcd [n1 n2]\n            (cond\n              (= n1 n2) n1\n              (> n1 n2) (gcd (- n1 n2), n2)\n              :else (gcd n1 (- n2 n1))))]\n    (if (= n 1)\n      1\n      (->> (range 1 (inc n))\n           (filter #(= 1 (gcd n %)))\n           (count)))))","user":"5eb1c786e4b00a66d4a95201"},{"code":"(fn [n]\n  (let [gcd (fn [x y] (.intValue (.gcd (biginteger x) (biginteger y))))\n        coprime? (fn [x] (= (gcd n x) 1))]\n    (count (filter coprime? (range n)))))","problem":75,"user":"51cdd3f0e4b0e42293a2254b"},{"code":"(fn [number]\n  (if (= number 1)\n    1\n    (let [coprime? (fn [first second]\n            (if (= first second)\n              (= 1 first)\n              (if (> first second)\n                (recur (- first second) second)\n                (recur first (- second first)))))]\n      (->> (range 1 number) (filter #(coprime? number %)) count))))","problem":75,"user":"4f294c48e4b0d6649770a023"},{"problem":75,"code":"(fn [n]\n    (if (= 1 n) 1\n      (let [gcd (fn [i1 i2]\n                  (apply max\n                         (filter #(= 0 (mod i1 %) (mod i2 %))\n                                 (range 1 (inc (max i1 i2))))))\n            coprime (fn [i1 i2] (if (= 1 (gcd i1 i2)) (min i1 i2) nil))]\n        (count (filter (partial coprime n) (range 1 n)))\n        )))","user":"559a9a3de4b066d22e731f45"},{"code":"(fn [v]\n  (let [gcd (fn [x y]\n              (loop [a (max x y) b (min x y )]\n                  ( if (= b 0)\n                    a\n                    (recur b (mod  a b ) ))))]\n     (if (= v 1 )\n            1\n       (count  (filter #(= 1 (gcd  % v ))  (range v) )\n    ))))","problem":75,"user":"4ec5bec6535d6d7199dd36b3"},{"code":"(letfn [(gcd\n    [x y]\n    (loop [a x b y]\n        (let [c (rem a b)]\n            (if (= 0 c)\n                b\n                (recur b c)))))\n     \t(coprime?\n    \t[x y]\n    \t(= 1 (gcd x y)))\n\n\t(totient\n    [m]\n    (reduce\n        #(if (coprime? m %2) (inc %1) %1)\n        0 \n        (range 1 m)\n    ))]\n  (fn [x] (if (= x 1)\n            1\n            (totient x))))","problem":75,"user":"4f1c2a3a535d64f603146480"},{"code":"(fn [n] \n  (let [div? #(zero? (mod %1 %2))\n        ds (filter #(div? n %) (range 2 n))]\n    (inc (count (remove (fn [i] (some #(div? i %) ds)) (range 2 n))))))","problem":75,"user":"500aa15ee4b03d00572d2d76"},{"code":"(fn [n]\n  (if (= 1 n) 1\n    (let [fun-dziel (fn [n] (set (filter #(zero? (mod n %)) (range 2 (inc n)))))\n\t        zakres (range 1 n)\n\t        n-dzielniki (fun-dziel n)]\n\t    (count (filter nil? (map #(some % n-dzielniki) (map fun-dziel zakres)))))))","problem":75,"user":"4ee77f15535d93acb0a66868"},{"code":"(fn [x]\n  (let [gcd (fn [a b]\n              (if (zero? b) a\n                (recur b (mod a b))))]\n    (if (= 1 x) 1\n      (count\n       (filter\n        (fn [y] (= 1 (gcd y x)))\n        (range 1 x))))))","problem":75,"user":"51df825de4b01188f062752b"},{"problem":75,"code":"(fn totient [x]\n  (let [gcd\n\n(fn gcd [a b]\n  (let [c (rem a b)]\n    (if (= c 0)\n      b\n      (gcd b c)\n    )\n  )\n)\n        coprime\n(fn coprime [a b]\n  (= 1 (gcd a b))\n)\n        ]\n    (count (filter true? (map (partial coprime x) (range 1 (inc x)))))\n  )\n)","user":"5943abb6e4b060784b3b792b"},{"problem":75,"code":"#(letfn [(gcd [a b] (if (zero? b) a (recur b (mod a b))))\n         (coprime? [a b] (= 1 (gcd a b)))]\n   (->> (range 2 %)\n        (filter (partial coprime? %))\n        count\n        inc))","user":"5f3abcc4e4b004f08c61c52b"},{"problem":75,"code":"(fn [n]\n  (if (= 1 n) 1\n  (let [gcd (fn gcd [x y]\n              (if (zero? y) x\n              \t(gcd y (mod x y))))\n        coprime? #(= 1 (gcd %1 %2))]\n    (->> n\n         range\n         rest\n         (filter (partial coprime? n))\n         count))))","user":"57a0b341e4b0c3d858beb8d4"},{"code":"#(letfn [(gcd [a b] (if (zero? b) a (recur b (rem a b))))\n          (coprime? [a b] (= 1 (gcd a b)))]\n    (if (= 1 %) 1 (count (filter (partial coprime? %) (range 1 %)))))","problem":75,"user":"4e3a9dae535deb9a81d77f4a"},{"problem":75,"code":"(fn [n]\n  (letfn [(euclid\n           [a b]\n           (if (= (rem a b) 0) b\n               (euclid b (rem a b))))\n          (totient\n           [cur counter]\n           (cond (= 1 n) 1\n                 (= cur n) counter\n                 (= 1 (euclid n cur)) (totient (inc cur) (inc counter))\n                 :else (totient (inc cur) counter)))]\n    (totient 1 0)))","user":"58f98231e4b0438e51c2cf4c"},{"problem":75,"code":"(letfn [(gcd [n1 n2]\n  \t\t(let [smaller (min n1 n2)\n        \t\tpotential-divisors (cons smaller (reverse (range 1 (inc (/ smaller 2)))))]\n    \t\t(first (filter #(= 0 (rem n1 %) (rem n2 %)) potential-divisors))))\n        (totient [n] (case n \n                       1 1\n                       (count (filter #{1} (map #(gcd % n) (range 1 n))))\n                       )\n                 )\n        ]\n                 totient\n                 )","user":"6004c750e4b074f607df6645"},{"problem":75,"code":"(fn totient [x]\n  (letfn [(coprime? [a b]\n                    (let [a-divs (set (filter #(zero? (mod a %)) (range 2 (inc a))))\n                          b-divs (set (filter #(zero? (mod b %)) (range 2 (inc b))))]\n                      (empty? (clojure.set/intersection a-divs b-divs))))]                  \n    (if (= x 1)\n      1\n      (+ (count (for [n (range 2 x)\n                   :when (coprime? n x)]\n               n)) 1))))","user":"53791ab7e4b06839e8705e4d"},{"problem":75,"code":"(fn [n]\n  (letfn [(gcd [a r]\n               (cond (< a r) (recur (Math/abs r) (Math/abs a))\n                     (not= 0 (rem a r)) (recur r (rem a r))\n                     :else r))]\n    (loop [x n, acc 0]\n      (if (= x 0)\n        acc\n        (recur (dec x)\n               (if (= (gcd n x) 1)\n                 (inc acc)\n                 acc))))))","user":"59a080e3e4b0871e7608b837"},{"code":"(fn [n]\n  (letfn [(gcd [a b] (if (zero? b) a (gcd b (mod a b))))]\n    (reduce #(if (= 1 (gcd n %2)) (inc %1) %1) 1 (range 2 n))))","problem":75,"user":"52015698e4b0d7096e99ddba"},{"problem":75,"code":"(fn [n]\n         (letfn [(find-divisors [x]\n                   (let [divisors (atom [x])]\n                     (doseq [_x (range 1 x)] (if (== 0 (mod x _x))\n                                               (swap! divisors conj _x)\n                                               ))\n                     @divisors\n                     )\n                   )\n                 (gcd [x y] (let\n                                [x-div (set (find-divisors x))\n                                 y-div (set (find-divisors y))]\n                              (last (into [] (clojure.set/intersection y-div x-div)))\n                              ))]\n           (count (filter #(= 1 (gcd n %)) (range 1 (+ n 1))))))","user":"5da71eaee4b000c986472c15"},{"problem":75,"code":"(fn [x]\n  (let [gcd (fn [a b] \n              (loop [n a\n                     d b]\n                (if (= 0 (rem n d))\n                  d\n                  (recur d (rem n d)))))]\n    (if (= 1 x) \n      x\n      (->> (map #(gcd x %) (range 1 x))\n           (filter #(= 1 %))\n           (count)))))","user":"5574c172e4b05c286339e059"},{"code":"(fn [n]\n   (letfn [(gcd [x y] \n     (cond \n        (= x y) x\n        (< x y) (gcd x (- y x))\n        :else (gcd (- x y) y)))]\n   (count (filter #(= 1 %) (map #(gcd n %) (range 1 (inc n)))))))","problem":75,"user":"4ffa8affe4b0678c553fc3bd"},{"code":"(fn euler [x]\n    (letfn [(gcd [n1 n2]\n                (loop [mn (min n1 n2)]\n                    (if (and (zero? (mod n1 mn)) (zero? (mod n2 mn)))\n                        mn\n                        (recur (dec mn)))))]\n        (if (= 1 x)\n            1\n            (count (filter #(= 1 (gcd % x)) (range 1 x))))))","problem":75,"user":"4f128865535d64f603146428"},{"problem":75,"code":"(fn [n]\n  (cond \n    (= n 1) 1\n    :else\n    (count\n      (filter\n        (fn [m]\n          (= 1\n             (loop [a n b m]\n               (cond\n                 (= b 0) a\n                 :else (recur b (mod a b))))\n             1))\n        (reverse (range  1 n ))))))","user":"53bd7080e4b0d9a98559a6d1"},{"code":"(fn [n] (letfn [(gcd [a b] (loop [r a s b] (if (= s 0) r (recur s (rem r s)))))](if (= n 1) 1 (count (filter #(true? %) (map #(= 1 (gcd % n)) (range 1 n)))))))","problem":75,"user":"510931ede4b0c71f76895663"},{"problem":75,"code":"(fn [n]\n  (let [gcd #(if (zero? %2) % (recur %2 (mod % %2)))]\n    (count \n     (filter \n      #(= 1 (gcd % n))\n      (range n)))))","user":"552a793ee4b0ffed3738f955"},{"code":"(letfn [(gcd [a b] (if (zero? b) a (gcd b (mod a b))))\n         (co-prime? [a b] (= (gcd a b) 1))]\n   (fn [x]\n     (if (= x 1)\n       1\n       (count (filter #(co-prime? x %) (range 1 x))))))","problem":75,"user":"53224d45e4b09d4e7a9b54c0"},{"problem":75,"code":"#(count (filter (fn [x] (= x 1)) (map (fn [a b] (if (zero? b) a (recur b (rem a b)))) (range 1 (inc %)) (cycle [%]))))","user":"57e33f6fe4b0bfb2137f5a96"},{"problem":75,"code":"(fn [x] \n  (count (filter \n          #(= 1 (loop [a x b %] \n                  (case (rem a b) \n                    0 b \n                    (recur b (rem a b))))) \n          (range 1 (+ 1 x)))))","user":"577202d2e4b0979f896515c0"},{"problem":75,"code":"(fn [n] (letfn [(gcd [a b]\n                 (if (= b 0) a\n                     (gcd b (mod a b))))]\n\n         (count (filter #(= 1 %) (map #(gcd % n) (range 1 (inc n)))))))","user":"576b4e6be4b0a07e8fc1812b"},{"code":"(fn [x]\n  (letfn [(gcd [a b] (if (= 0 (rem a b)) b (recur b (rem a b))))]\n    (if (= 1 x)\n      1\n      (->> (range 1 x)\n           (map (partial gcd x))\n           (filter #(= 1 %))\n           (count)))))","problem":75,"user":"4fe8fda4e4b0547ebccb2438"},{"code":"(fn [n] (letfn [(g [a b] (if (= b 0)\r\n                                a\r\n                                (g b (mod a b))))]\r\n  (count (filter #(= (g % n) 1) (range n)))))","problem":75,"user":"4df1ce44535d08e6dec9fe1f"},{"problem":75,"code":"(fn [n]\n  (if (= n 1)\n    1\n    (letfn [(mcd [n1 n2]\n              (let [[s b] (if (>= n1 n2) [n1 n2] [n2 n1])]\n                (loop [mc 1 cands (range 2 s)]\n                  (cond\n                   (empty? cands) mc\n                   (and (zero? (rem b (first cands))) (zero? (rem s (first cands)))) (recur (first cands) (rest cands))\n                   :else (recur mc (rest cands))))))\n            (cp? [n1 n2] (= 1 (mcd n1 n2)))]\n      (count (filter (partial cp? n) (range 1 n))))))","user":"586615e6e4b0f14aab7c8858"},{"problem":75,"code":"(fn\n  [x]\n  (letfn [(gcd [x y]\n            (if (= 0 y)\n              x\n              (recur y (mod x y))))\n          (step [a n]\n            (if (= 1 (gcd x n))\n              (inc a)\n              a))]\n    (if (= x 1)\n      1\n      (reduce step 0 (range x)))))","user":"52dfc89be4b09f7907dd1405"},{"code":"(fn totient [x]\n  (letfn [(gcd [x y]\n            (if (zero? y)\n              x\n              (gcd y (mod x y))))]\n    (if (= x 1)\n      1\n      (count (filter #(= 1 (gcd x %)) (range 1 x))))))","problem":75,"user":"5220bc0fe4b0e6a83c8925a7"},{"code":"(fn [x] (count \n  (filter \n    (fn [c] (= ((fn gcd [a b] (cond (> b a) (gcd b a)\n                (= b 0) a\n                :else (gcd b (mod a b)))) x c) 1)) \n    (range x))))","problem":75,"user":"504e108ce4b078edc5f593b3"},{"code":"(fn [n]\n  (if (= 1 n)\n    1\n    (count\n     (for [x (range 1 n)\n           :when (= 1 (#(if (= 0 %2)\n                          %\n                          (recur %2 (mod % %2)))\n                       n x))]\n       x))))","problem":75,"user":"4e6a412e535d8ccf87e9feb6"},{"code":"(fn [n]\n    (if (= n 1)\n      1\n      (let [gcd (fn [a b]\n                 (some #(when (and (zero? (mod a %))\n                                   (zero? (mod b %)))\n                          %)\n                       (iterate dec (int (/ (max a b) 2)))))]\n        (count (filter #(= 1 (gcd n %)) (range n))))))","problem":75,"user":"4e6a0667535d8ccf87e9fe9e"},{"code":"(fn totient\n  [x]\n  (if (= x 1)\n    1\n    (letfn [(gcd [a b]\n              (if (zero? b)\n                a\n                (recur b (mod a b))))]\n      (->> (map #(gcd x %) (range 1 x))\n           (filter #(= 1 %))\n           count))))","problem":75,"user":"5048202fe4b0ec70b3ef8d9a"},{"problem":75,"code":"#(letfn [(gcd [a b] (if (zero? b) a (recur b (rem a b))))\n         (coprime? [a b] (= 1 (gcd a b)))]\n   (if (= % 1) 1 (count (filter (partial coprime? %) (range 1 %)))))","user":"551ed214e4b08d5046aa8a4d"},{"problem":75,"code":"(fn[n]\n  (letfn [(gcd[a b]\n              (cond\n                (zero? a)\n                b\n                (zero? b)\n                a\n                (>= a b)\n                (recur (- a b) b)\n                (< a b)\n                (recur (- b a) a)))]\n      (count\n       (filter (fn[i]\n                (= (gcd i n) 1)) (range 1 (inc n))))))","user":"55101237e4b06e50f9beb181"},{"problem":75,"code":"(fn [x] \n  (if (= x 1) 1\n    (count (filter (fn [y]\n                     (= 1 (count (filter #(= (mod x %) (mod y %) 0) (range 1 (+ 1 y))))))\n                   (range 1 x)))))","user":"53c38b8ce4b00fb29b22127b"},{"code":"(fn [n]\r\n  (+ 1 \r\n    (count (filter (fn [i] (= (str i '/ n) (str (/ i n)))) (range 2 n)))))","problem":75,"user":"4dce6e41535d5973398f92a2"},{"code":"(fn t [n]\n  (let [gcd (fn gcd [x y] (if (= 0 y) x (gcd y (mod x y))))]\n  (if (= n 1) \n    1\n    (count (filter #(= 1 (gcd % n)) (range 1 n))))))","problem":75,"user":"52379c46e4b0fae3832e99db"},{"problem":75,"code":"(fn [v]\n  (letfn [(gcd     [a b] (if (= a b) a (if (> a b) (recur (- a b) b) (recur a (- b a)))))\n          (coprime [a b] (= (gcd a b) 1))]\n    (if (= 1 v) 1\n      (count (filter (partial coprime v) (range 1 v))))))","user":"537e745ae4b06839e8705ea6"},{"code":"(fn [n]\n  (letfn [(gcd [a b]\n            (if (zero? b)\n                a\n                (gcd b (mod a b))))]\n  (count (filter #(= 1 (gcd % n)) (range 1 (inc n))))))","problem":75,"user":"4e68b46c535d8ccf87e9fe87"},{"problem":75,"code":"(fn [x]\n  (let [gcd (fn [a b] (if (= a b) a (if (> a b) (recur (- a b) b) (recur a (- b a)))))]\n    (count (for [i (range 1 (inc x))\n                 :when (= 1 (gcd i x))]\n             i))))","user":"5918db70e4b09b4ee5954bbb"},{"code":"(fn [n] (count (filter #(= ((fn f [a b] (if (= 0 b) a (f b (rem a b)))) % n) 1) (range n))))","problem":75,"user":"51b90b88e4b050a1176cd6a2"},{"code":"(fn ff  [x ] \n\t\t(let [xx (fn com [x y ] \n\t \t(if (= y 0) x \n\t \t\t(com y (rem x y))))]\n\n\t\t(count (filter #(= 1 (xx x %)) (range  x)  ))))","problem":75,"user":"518644bce4b0da5a5be3baca"},{"code":"(fn [n]\n  (if (= 1 n)\n    1\n    (letfn [(divs [x] (set (filter #(= 0 (rem x %)) (range 1 (inc x)))))\n            (com-divs [a b] (clojure.set/intersection (divs a) (divs b)))\n            (coprime? [a b] (= #{1} (com-divs a b)))\n            (coprimes [x] (filter #(coprime? x %) (range 1 x)))]\n      (count (coprimes n)))))","problem":75,"user":"4fc3a72ae4b081705acca342"},{"code":"(fn t [n]\n  (letfn [(gcd [a b]\n   (loop [c a]\n    (if (= (+ (rem a c) (rem b c)) 0)\n      c\n      (recur (dec c)))))]\n  (count (filter (partial = 1) (map #(gcd n %) (range n))))))","problem":75,"user":"513b43ede4b067e25a345ed3"},{"problem":75,"code":"#(letfn [(g[a b] (if (= b 0) a (recur b (mod a b))))]\n    (count (filter (fn[i] (= i 1)) (map (partial g %) (range 1 (inc %))))))","user":"56824e1be4b0945ebc182a91"},{"code":"#(count (for [x (range %) :when (== (.gcd (bigint x) (bigint %)) 1)] x))","problem":75,"user":"4eb97b2e535dfed6da9c6d54"},{"problem":75,"code":"(fn [x]\n  (let [gcd (fn gcd [a b]\n               (if (zero? b)\n                  a\n                  (gcd b (mod a b))))\n        coprime? (fn [x y]\n                   (= 1 (gcd x y)))]\n    (count (reduce #(if (coprime? %2 x) (conj % %2) %) [] (range 1 (inc x))))))","user":"52f53589e4b05e3f0be25f2c"},{"problem":75,"code":"(fn [n] (count (filter identity (map #((fn f [x y]\n  (if (= (min x y) 1) true\n    (if (= x y) false\n      (f (min x y) (Math/abs (- x y)))))) % n) (range 1 (+ 1 n))))))","user":"53500869e4b084c2834f4ad3"},{"problem":75,"code":"(fn [x]\n   (if (= x 1) 1\n   (letfn [(gcd [a b] (if (= b 0)\n                        a\n                        (gcd b (mod a b))))\n           (coprime [a b] (= (gcd a b) 1))]\n     (loop [y (dec x) acc 0]\n       (cond\n         (= y 0) acc\n         (coprime x y) (recur (dec y) (inc acc))\n         :else (recur (dec y) acc))))))","user":"5d764e52e4b02e6b30c93524"},{"problem":75,"code":"(fn [n] (let [gcdx (fn gcd [x,y]\n                     (if (> x y)\n                       (gcd y x)\n                       (if (= x 0)\n                         y\n                         (gcd (mod y x) x)\n                         )\n                       )\n                     )\n\n               ]\n           (count (filter #(= (gcdx n %) 1) (take n (iterate #(inc %) 1))))\n           )\n   )","user":"54a1d643e4b09f271ff37c50"},{"problem":75,"code":"(fn [n]\n  (letfn [(coprime [x y]\n                   (if (= 0 (rem x y))\n                     (if (= y 1) true false)\n                     (recur y (rem x y))))]\n    (case n\n      1 1\n      (->> (range n)\n           (drop 1)\n           (filter #(coprime n %1))\n           (count)))))","user":"59225498e4b09b4ee5954c8c"},{"problem":75,"code":"(fn euler-totient\n  [x]\n  (let [gcd (fn gcd2 [x y]\n              (loop [a (max x y)\n                     b (min x y)]\n                (let [r (rem a b)]\n                  (if (= r 0)\n                    b\n                    (recur b r )))))]\n    (if (= x 1) 1 (->> (range 1 x)\n                       (filter #(= (gcd % x) 1))\n                       (count)))))","user":"5ed6030de4b016b56eae05db"},{"code":"(fn [n]\n    (letfn [(gcd [a b]\n              (if (zero? b)\n                a\n                (recur b (mod a b))))]\n      (count (filter #(= 1 (gcd n %)) (range 1 (inc n))))))","problem":75,"user":"4f5cc3b8e4b0030a34fb2b2b"},{"code":"(fn [n]\n  (let [nod1 (fn [m] (= 1 (last (filter #(and (= 0 (mod m %)) (= 0 (mod n %))) (range 1 m)))) )\t]\n  (inc (count (filter #(and (nod1 %) (not= 0 (mod n %))) (range 1 n))))  \n  )\n )","problem":75,"user":"51db9e1ee4b0e067a9bbadc9"},{"problem":75,"code":"(fn [arg1]\n(cond\n(and (= arg1 1)) 1\n(and (= arg1 10)) 4\n(and (= arg1 40)) 16\n(and (= arg1 99)) 60\n))","user":"565f2461e4b068f2fe63dc3b"},{"problem":75,"code":"(fn [n]\n(letfn [(g [x y] (if (zero? y) x (recur y (mod x y))))]\n(count (filter #{1} (map #(g n %) (range n))))))","user":"5fd10010e4b07e53c2f3f02a"},{"code":"(fn [x]\n  (letfn [(divisors [n]\n            (reduce (fn [divs d]\n                      (if (zero? (rem n d))\n                        (conj divs d)\n                        divs))\n                    #{}\n                    (range 1 (inc n))))\n          (gcd [x y]\n            (apply max (clojure.set/intersection (divisors x) (divisors y))))\n          (coprime? [x y]\n            (= 1 (gcd x y)))]\n    (if (= x 1)\n      1\n      (count (filter true? (map (partial coprime? x) (range 1 x)))))))","problem":75,"user":"5236b6bce4b05f3be1c7c8fe"},{"code":"( fn [x]\n                             ( if(= 1 x) 1\n                              ( count(filter #(= 1 ( (fn [a b] (loop [a a b b]\n                                                                ( if(zero? b)a\n                                                                  (recur b (mod a b)))\n                                                                \n                                                                ) ) %1 x)) (range 1 x)))))","problem":75,"user":"5225b16de4b0d2f5d1e2c0ed"},{"problem":75,"code":"(fn [s]\n(let [ran (range 2 (/ s 2))]\n(if (= s 1) 1 (count (remove (into #{2} (mapcat (fn [x] (keep (fn [a] (if (and (< (* a x) s) (= (rem s x) 0)) (* a x))) ran)) ran)) (range 2 s))))))","user":"51316a63e4b0431ba07e7feb"},{"problem":75,"code":"(fn et [n]\n  (if (= n 1) 1\n      (letfn [(gcd [x y]\n                (if (<= y 0)\n                  x\n                  (gcd y (mod x y))))]\n        (reduce +\n                (map\n                 #(if (= 1 (gcd n %)) 1 0)\n             (range 1 n))))))","user":"56069006e4b08b23635d3174"},{"problem":75,"code":"(fn [x]\n  (if (= x 1) 1\n  (count(filter\n  #(= #{1} (clojure.set/intersection (set((fn [y]\n(filter (fn [x](zero? (mod y x)))\n(range 1 (inc y))\n)) %))(set((fn [y]\n(filter (fn [x](zero? (mod y x)))\n(range 1 (inc y))\n)) x))))\n\n  (range 1 x)\n  )\n  )))","user":"5951190be4b066ee0a44aea4"},{"problem":75,"code":"(fn totient\n  [n]\n  (if (= 1 n)\n    1\n    (let [gcd\n          (fn gcd\n            [n1 n2]\n            (if (< n1 n2)\n              (gcd n2 n1)\n              (if-not (zero? n2)\n                (gcd n2 (rem n1 n2))\n                n1)))]\n      (->> (range 1 n)\n           (filter #(= 1 (gcd % n)))\n           count))))","user":"5edd05bfe4b0c7845d86b0f3"},{"problem":75,"code":"(fn [n]\n  (let [gcd (fn gcd [a b]\n              (cond\n                (= a b) a\n                (< a b) (gcd a (- b a))\n                (> a b) (gcd (- a b) b)))]\n    (->> (range 1 (inc n))\n         (filter #(= 1 (gcd n %)))\n         (count))))","user":"5f5358b7e4b0a0bc16850a77"},{"code":"(fn [a]\n    (letfn [(gcd [a b] (first\n                        (for [n (reverse (range 1 (+ 1 (min a b)))) :when (= 0 (rem a n) (rem b n))]\n                          n)))\n            (co-p? [a b] (= 1 (gcd a b)))]\n      (count (filter #(co-p? a %) (range 1 (+ 1 a))))))","problem":75,"user":"4ed292ac535d44c135fd68d9"},{"problem":75,"code":"(fn k [n]\n  (if (= 1 n)\n    1\n    (letfn [(coprime? [x_ n_] (empty?\n                              (filter\n                                #(and (= 0 (mod x_ %)) (= 0 (mod n_ %)))\n                                (range 2 (inc x_)))))]\n      (->> (range 1 n)\n           (filter (fn [x] (coprime? x n)))\n           count))))","user":"5657fed1e4b0f9d632dd84ae"},{"problem":75,"code":"#(let [gcd (fn [a b]\n              (if (zero? b)\n                a\n                (recur b (mod a b))))]\n    (->> (range 1 (inc %))\n         (filter (fn [v] (= 1 (gcd v %))))\n\t\t count\t\t\n         )\n    )","user":"5ed8a12fe4b0c7845d86b0d7"},{"code":"(fn\n  [x]\n  (if (== 1 x)\n    1\n    (count\n      (filter\n        #(== 1 ((fn [a b] (if (zero? (rem a b)) b (recur b (rem a b)))) % x))\n        (range 1 x)))))","problem":75,"user":"50ebd63ce4b04edc3377703c"},{"problem":75,"code":"(letfn [(gcd [a b] (if (zero? b) a (gcd b (mod a b))))]\n  \n  (fn [x]\n    (if (= x 1)\n      1\n      (->> (range (dec x) 0 -1)\n           (filter #(= 1 (gcd x %)))\n           count))))","user":"506ba58be4b0eda3100c090b"},{"problem":75,"code":"(fn euler-totient\n  [n]\n  (let [gcd (fn\n              [a b]\n              (loop [c a\n                     d b]\n                (if (zero? d)\n                  c\n                  (recur d (rem c d)))))]\n    (->> (inc n) (range 1) (map #(gcd % n)) (filter #(= % 1)) (count))))","user":"4fc524aae4b081705acca37e"},{"code":"(fn euler-totient [i-input]\r\n    (let [\r\n        divisible (fn [divident] #(zero? (rem divident %)))\r\n        prime-list (reduce\r\n            (fn [current next]\r\n                (if (nil? (some #((divisible next) %) current))\r\n                    (conj current next)\r\n                    current))\r\n            [2]\r\n            (take-last (- i-input 2) (range (inc i-input))))\r\n        are-coprime (fn [x y]\r\n            (not (some #(true? %) (map #(and ((divisible x) %) ((divisible y) %)) prime-list))))\r\n        co-prime ((fn find-coprime\r\n            ([] (find-coprime [] 1))\r\n            ([result i]\r\n                (if (> i i-input)\r\n                    result\r\n                    (find-coprime (if (are-coprime i i-input) (conj result i) result) (inc i))))))\r\n        ]\r\n        (count co-prime)))","problem":75,"user":"4dddf817535d08e6dec9fdd3"},{"problem":75,"code":"(fn [n]\n  (let [gcd (fn [a b]\n      (if\n        (= b 0)\n        a\n        (recur b (rem a b))))]\n    (count\n      (filter\n        #(= % 1)\n        (map #(gcd % n) (range 1 (max n 2)))))))","user":"5a2df4a0e4b09cafd31c7f74"},{"problem":75,"code":"(fn [i]\n  (if (= 1 i) \n    1\n    (letfn [(gcd [a b]\n              (if (zero? b)\n                a\n                (gcd b (mod a b))))]\n      (count (filter #(= (gcd i %) 1) (range 1 i))))))","user":"56a76f36e4b07966d5a8a05b"},{"problem":75,"code":"(fn euler-fun [n]\n  (letfn [(coprime? [x y]\n            (if (= 1 y)\n              true\n              (loop [x x, y y]\n                (if (= 0 (rem x y))\n                  (if (= 1 y) true false)\n                  (recur y (rem x y))))))]\n    (if (<= n 1)\n      1\n      (count (filter #(coprime? n %) (range 1 n))))))","user":"572ec4dde4b0cd1946bd0f8d"},{"problem":75,"code":"(fn\n  [number]\n  (if (= number 1)\n    1\n    (letfn [(divisible-by? [n] #(zero? (mod % n)))]\n     (let [divisors (for [i (range 2 number) :when ((divisible-by? i) number)] i)]\n       (count (reduce #(filter (complement (divisible-by? %2)) %1) (range 1 number) divisors))))))","user":"563a30d7e4b0bfe05bf117f9"},{"code":"#(if (= 1 %) 1  \n(count\n(filter (fn [x] \n          (= 1\n            ((fn gcd [a b]\n              (if (zero? a) b\n                  (if (<= a b) (gcd a (- b a))\n                      (gcd b a)))) x %)))\n(range 1 %))))","problem":75,"user":"4fdd27f3e4b05e33b9224f78"},{"code":"(fn [n] \n  (case n\n  \t1 1\n    2 1\n    ((fn clear [x s] (if (= x n) (inc (count s))\n                           (if (= 0 (rem n x)) \n                           \t\t(clear (inc x) (remove #(= 0 (rem % x)) s))\n                           \t\t(clear (inc x) s)\n                            )\n                       )\n       ) 2 (range 2 n))\n))","problem":75,"user":"526a3412e4b03e8d9a4a721e"},{"problem":75,"code":"#(let [coprime? (fn [x y] (if (zero? y) (= x 1) (recur y (rem x y))))]\n   (if (= % 1) 1\n     (->> (range %)\n          (drop 1)\n          (filter (partial coprime? %))\n          count)))","user":"5a080bdde4b01bb0ae8afde9"},{"code":"(fn tot [n]\n  (letfn [(countf [f lst]\n                  (count (filter f lst)))\n          (gcd [a b]\n               (cond\n                (= 0 (rem a b)) b \n                (= 0 (rem b a)) a \n                :else (gcd b (rem a b))))]\n    (if (= n 1) \n      1\n      (countf #(= 1 (gcd n %1)) (range 1 n)))))","problem":75,"user":"5374adc3e4b06d7f452d9e27"},{"code":"(fn [n]\n    (let [divisors\n          (fn [x] (into #{} (filter\n                            #(zero? (mod x %))\n                            (range 1 (inc x)))))\n          dn (divisors n)]\n      (if (= 1 n)\n        1\n        (count\n         (filter #(> 2 (count %))\n                 (map (fn [x]\n                        (clojure.set/intersection\n                         dn \n                         (divisors x)))\n                      (range 1 n)))))))","problem":75,"user":"4f463dfde4b0d56e7bb92b99"},{"code":"(fn [n]\n    (let [gcd (fn euclid [a b]\n                (if (== b 0)\n                  a\n                  (euclid b (mod a b))))]\n         (->> (+ n 1)\n              (range 1)\n              (map #(gcd n %))\n              (filter #(= 1 %))\n              count)))","problem":75,"user":"4fe8a3bde4b07c9f6fd12c61"},{"code":"(fn totient [x]\n   (if (= x 1) 1\n       (letfn [(gcd [x y]\n                 (if (= 0 (min x y))\n                   (max x y)\n                   (gcd (min x y) (- (max x y) (min x y)))))]\n         (count (filter #(= 1 (gcd x %)) (range 1 x))))))","problem":75,"user":"4e89f46c535d3e98b8023288"},{"code":"(fn eulers [x]\n  (if (= 1 x) \n    1\n    (letfn [(gcd [a b] (last (filter \n                              #(and (zero? (mod a %)) (zero? (mod b %))) \n                              (range 1 (max a b)))))\n            (coprime? [a b] (= 1 (gcd a b)))]\n      (count (filter (partial coprime? x) (range 1 x))))))","problem":75,"user":"50e4f4e9e4b049a987753896"},{"problem":75,"code":"(fn [n]\n  (if (= n 1)\n    1\n    (let [gcd (fn [x y] (if (zero? y) x (recur y (mod x y))))]\n      (count (filter #{1} (map (partial gcd n) (range 1 n)))))))","user":"54ab1b5ae4b09f271ff37cc2"},{"problem":75,"code":"(fn [input]\n  (letfn [(divisor? [n d]\n                    (= (mod n d) 0))\n          (divisors [n]\n                  (map #(first (first %))\n                      (filter #(= true (second (first %)))\n                              (map-indexed #(-> {(inc %1) (divisor? n %2)}) (range 1 (inc n))))))\n          (greatest-common-divisor [a b]\n                  (let [a-divs (set (divisors a))\n                        b-divs (set (divisors b))]\n                    (apply max (clojure.set/intersection a-divs b-divs))))\n          (coprime? [a b]\n                (= 1 (greatest-common-divisor a b)))]\n    (count (filter #(coprime? input %) (range 1 (inc input))))))","user":"57b9fb56e4b0fbc9809a27fa"},{"problem":75,"code":"(fn [n]\n  (let [gcd (fn [a b]\n              (if (= 0 b)\n                a\n                (recur b (mod a b))))]\n    (if (= 1 n)\n      1\n      (->> (map gcd (repeat n) (range 1 n))\n           (filter #{1})\n           count))))","user":"557c6ca6e4b05c286339e0c4"},{"problem":75,"code":"(fn totient [x]\n  (if (= 1 x)\n    1\n    (count (filter #(= 1 ((fn [a b]\n                            (if (= 0 b) a (recur b (mod a b)))) x %))\n                   (range 1 x)))))","user":"561d23e3e4b064ca9f4b16a5"},{"problem":75,"code":"(fn [n]\n    (letfn [(gcd [a b]\n              (let [r (mod a b)]\n                (if (zero? r)\n                  b\n                  (gcd b r))))]\n           (if (= 1 n)\n             1\n             (count (filter #(= 1 (gcd n %)) (range 1 n))))))","user":"5368fedee4b0243289761e93"},{"code":"(fn [x]\n  (count\n   (filter #(= 1 (.gcd (biginteger %) (biginteger x)))\n           (range 1 (inc x)))))","problem":75,"user":"4ebaf790535dfed6da9c6d6e"},{"code":"(fn [x]\n   (let [coprime? (fn [y] (not-any? #(= 0 (rem x %) (rem y %)) (range 2 (inc y))))]\n     (+ 1 (count (filter coprime? (range 2 x))))))","problem":75,"user":"524f213be4b0541d1855b7ff"},{"problem":75,"code":"(fn [n]\n   (letfn [(gdc [a r]\n             (cond (< a r) (recur r a)\n                   (not= 0 (mod a r)) (recur r (mod a r))\n                   :ese r))]\n     (if (= n 1)\n       1\n       (->> (range 1 n)\n            (filter #(= 1 (gdc n %)))\n            (count)))))","user":"567d132ee4b05957ce8c61c3"},{"code":"#(count (letfn [(gcd [x y] (last (filter (fn [a] (= (mod x a) (mod y a) 0)) (range 1 (+ 1 y)))))]\n    (map :val (get (group-by :gcd (map (fn [a] {:gcd (gcd % a)  :val a}) (range 0 (+ 1 %)))) 1))))","problem":75,"user":"5125029de4b0ce9225d2ed3e"},{"problem":75,"code":"(fn [n]\n    (if (= 1 n)\n        1\n        (count (filter (fn [x] (= 1 \n                                  (loop [a_x x\n                                         a_y n]\n                                     (if (> a_x a_y)\n                                         (recur a_y a_x)\n                                         (if (= 0 a_x)\n                                             a_y\n                                             (recur (rem a_y a_x) a_x)))))) (range 1 n)))))","user":"5a34f342e4b0ddc586f153d1"},{"code":"(fn [n] \n  (let [\tgcd (fn gcd [a b] (if (zero? b) a (gcd b (mod a b))))\n        co-prime? (fn [x y] (= 1 (gcd x y)))\n\t\tco-prime-ints (fn [x] (filter #(co-prime? % x) (range 1 (condp = x 1 2 x))))]\n     (count(co-prime-ints n))))","problem":75,"user":"523a9fc9e4b081681ca7adca"},{"code":"(fn totient [num]\n  (letfn [(gcd [& nums]\n            (let [[small big] (sort nums)\n                  m (mod big small)]\n              (if (= 0 m) small (gcd small m))))]\n\n    (loop [n (dec num)\n           count 0]\n      (if (< 1 n)\n        (recur (dec n) (if (= 1 (gcd n num))\n                         (inc count)\n                         count))\n        (inc count)))))","problem":75,"user":"4e3bccb1535deb9a81d77f55"},{"code":"(let [gcd (fn [m n]\n            (condp = m\n              0 n\n              1 1\n              (recur (mod n m) m)))\n      coprime? (fn [n m]\n                 (= (gcd m n) 1))]\n  #(count (filter (partial coprime? %) (range 1 (inc %)))))","problem":75,"user":"4e3bcccd535deb9a81d77f56"},{"code":"(fn totient [n]\n  (letfn [(pow [n k]\n            (loop [acc 1 k k]\n              (if (zero? k)\n                acc\n                (recur (* n acc) (dec k)))))\n          (prime-factors [n]\n            (if (= n 1)\n              []\n              (loop [i 2]\n                (cond\n                 (> (* i i) n) [n]\n                 (zero? (mod n i)) (concat (prime-factors i)\n                                           (prime-factors (/ n i)))\n                 :else (recur (inc i))))))]\n    (let [factors (frequencies (prime-factors n))]\n    (reduce (fn [running [p occ]]\n             (* running (dec p) (pow p (dec occ)))) 1 factors))))","problem":75,"user":"5186134ce4b0da5a5be3bac7"},{"code":"(fn [m]\n  (count (filter \n            #(= 1 (.gcd (bigint %) (bigint m)))\n            (range m))))","problem":75,"user":"4ede361a535d10e5ff6f5332"},{"problem":75,"code":"(fn [n]\n  (if (= n 1) \n    1\n      (letfn [(common-divisor [a b]\n                (let [r (mod a b)]\n                  (if (zero? r)\n                    b\n                    (recur b r))))\n              (comprime [x] (= (common-divisor n x) 1))]\n        (loop [x (dec n) result 0]\n          (if (zero? x)\n            result\n            (recur (dec x) (if (comprime x)\n                             (inc result)\n                             result)))))))","user":"5ebdb3d2e4b00a66d4a95275"},{"code":"#(count (filter (fn [s] (= 1 (let [gcd\n                                   (fn [x y] \n                                              (loop [a (max x y) b (min x y)]\n    (let [r (mod a b)]\n      (if (= r 0)\n        b\n        (recur b r)))\n                                              ))]\n                               (gcd s %)))) (range 1 (inc %))))","problem":75,"user":"52b63875e4b0c58976d9ad41"},{"code":"(fn p75 [x]\r\n  (if (= x 1)\r\n\t\t1\r\n\t \t(let [gcd (fn [& xs]\r\n\t  \t\t\t\t(loop [[b a] (sort xs)]\r\n\t  \t\t\t\t\t(let [r (mod a b)]\r\n\t  \t\t\t\t\t\t(if (= r 0)\r\n\t  \t\t\t\t\t\t\tb\r\n\t  \t\t\t\t\t\t\t(recur [r b])))))\r\n\t        iscoprime #(= (gcd x %) 1)\r\n\t        coprimes (filter iscoprime (range 1 x))]\r\n\t\t\t(count coprimes))))","problem":75,"user":"4f7f0827e4b06e829148e1d5"},{"problem":75,"code":"(fn [n]\n     (letfn [(gcd [a b]\n                (if (or (= b 0) (= a b)) \n                  a\n                  (gcd b (mod a b))))\n             (coprimes? [a b]\n                        (= 1 (gcd a b)))\n             (comprime-list [n]\n                            (filter (partial coprimes? n) (range n)))]\n            (count (comprime-list n))))","user":"4f867b25e4b033992c121c51"},{"problem":75,"code":"(fn [x]\n  (let [co-prime?\n        (fn [a b] (not-any? #(= '(0 0) (list (mod a %) (mod b %))) (range 2 (inc a))))]\n    (count (filter #(co-prime? % x) (range 1 (inc x))))))","user":"536046a9e4b063bf7a5f8fe1"},{"code":"(fn [n]\n    (if (= n 1)\n      1\n      (let [primefactors\n            (fn primefactors\n              ([n] (primefactors n 2 []))\n              ([n trying sofar]\n                 (cond (= trying\n                          n)\n                       (conj sofar n)\n                       (= (rem n trying)\n                          0)\n                       (recur (/ n trying) trying (conj sofar trying))\n                       :else (recur n (inc trying) sofar))))]\n        (* n\n           (reduce * (map #(- 1\n                              (/ 1 %))\n                          (distinct (primefactors n))))))))","problem":75,"user":"4daea889edd6309eace4d15b"},{"problem":75,"code":"(fn totient\n    [x]\n    (let [gcd\n          (fn\n            [x y]\n            (if (zero? y)\n              x\n              (recur y (mod x y))))\n\n          coprime?\n          (fn\n            [x y]\n            (= 1 (gcd x y)))\n\n          integers-below\n          (fn\n            [x]\n            (range 0 x))]\n      (count (filter #(coprime? x %) (integers-below x)))))","user":"5614fa1de4b05f002753dfbe"},{"code":"(fn [n]\n  (if (= n 1) 1\n    (letfn [(gcd [a b]\n              (if (zero? b) a (gcd b (mod a b))))]\n      (count (filter #(= 1 (gcd n %)) (range 1 n))))))","problem":75,"user":"4f2d5f5de4b0d6649770a05a"},{"problem":75,"code":"(fn totient[n] \n  (if (= 1 n) 1 \n    (let [gcd (fn [a b] (if (zero? b) a (recur b (mod a b))))]\n    (count (filter #(= 1 (gcd % n)) (range 1 n))))))","user":"5972fcf6e4b01722bebd4c92"},{"problem":75,"code":"(fn [n]\n  (letfn [(gcd [a b] (if (zero? b) a (recur b (mod a b))))]\n    (if (== n 1)\n      1\n      (count (filter (fn [x] (== (gcd n x) 1)) (range 1 n))))))","user":"570eeca5e4b0b0fb43fd06fb"},{"problem":75,"code":"(fn [x]\n  (let [divisors (fn [x]\n                   (loop [res nil, [hd-x & tl-x] (range 2 x)]\n                     (cond (nil? hd-x) (reverse res)\n                           (= 0 (mod x hd-x)) (recur (cons hd-x res) tl-x)\n                           true (recur res tl-x))))\n        divisible-by-any? (fn [x sq]\n                            (loop [[hd-sq & tl-sq] sq]\n                              (cond (nil? hd-sq) false\n                                    (= 0 (mod x hd-sq)) true\n                                    true (recur tl-sq))))\n        divs-x (divisors x)]\n    (loop [cnt 1 [hd-x & tl-x] (range 2 x)]\n      (cond (nil? hd-x) cnt\n            (divisible-by-any? hd-x divs-x) (recur cnt tl-x)\n            true (recur (+ cnt 1) tl-x)))))","user":"54bbaa8ee4b0ed20f4ff6ec0"},{"code":"(fn [n]\n  (inc (count (filter #(let [k (/ n %)]\n    (and (ratio? k) (= n (numerator k))))\n    (nnext (range n))))))","problem":75,"user":"4e521cef535d302ef430da6d"},{"problem":75,"code":"(let [gcd (fn gcd\n            [a b]\n              (loop [a a b b]\n                (if (= b 0)\n                  a\n                  (recur b (mod a b)))))]\n  (fn totient\n    [n]\n    (count (filter #(= 1 (gcd n %)) (range 1 (inc n))))))","user":"59a24c92e4b066c664927d20"},{"code":"#(letfn [(g [a b] (if (== b 0) a (recur b (mod a b))))\n         (c [a] (if (== 1 (g a %1)) 1 0))] (reduce + (map c (range 0 %1))))","problem":75,"user":"5251d3c1e4b0541d1855b87f"},{"code":"(fn [n]\r\n  (let [gcd (fn [x1 x2]\r\n              (let [n1 (min x1 x2), n2 (max x1 x2)]\r\n                (loop [d 1]\r\n                  (if (= d n1)\r\n                    1\r\n                    (if (and (zero? (rem n1 d)) (zero? (rem n2 (quot n1 d))))\r\n                      (quot n1 d)\r\n                      (recur (inc d)))))))]\r\n    (loop [x (dec n), c 1]\r\n      (if (<= x 1)\r\n        c\r\n        (recur (dec x) (if (= 1 (gcd x n)) \r\n                         (inc c) c))))))","problem":75,"user":"4f359c7ee4b0e243712b1ec4"},{"code":"(fn [x]\n  {:pre [(integer? x) (pos? x)]}\n  (let [coprime? (fn [x y]\n                   (let [factors (fn [n]\n                                   (let [candidates (range 1 (+ 1 n))\n                                         isfact? (fn [f] (not (ratio?\n                                                                (/ n f))))]\n                                     (->> candidates\n                                          (filter isfact?))))]\n        (= 1 (reduce max (clojure.set/intersection\n                     (set (factors x))\n                     (set (factors y)))))))]\n  (if (= 1 x)\n    1\n    (count (filter #(coprime? % x) (range 1 x))))))","problem":75,"user":"4f35e662e4b0e243712b1ec6"},{"code":"(fn [n]\n    (letfn [(coprime [x]\n      (loop [xd x]\n        (if (= 1 xd)\n          true\n          (if (and (= 0 (mod n xd)) (= 0 (mod x xd)))\n            false\n            (recur (dec xd))))))]\n      (count (filter identity (map coprime (range 1 (inc n)))))))","problem":75,"user":"4db2cd84535df7e46ed9b6c6"},{"problem":75,"code":"(fn totient\n  [x]\n  (letfn [(gcd [a b]\n  \t(cond\n    \t(= a b)\n    \ta\n    \t(> a b)\n    \t(recur (- a b) b)\n\n    \t:else\n    \t(recur a (- b a))))]\n    (if (= x 1)\n      1\n    (loop [n 0\n           curr (dec x)]\n      (if (> curr 0)\n      \t(if (= (gcd x curr) 1) \n        \t(recur (inc n) (dec curr))\n            (recur n (dec curr)))\n        n)))))","user":"5ce6f93be4b0a17bb84e2b99"},{"code":"(fn [x]\n  (letfn [(g [a b]\n             (cond\n              (< b a) (g b a)\n              (zero? a) b\n              :else (g (mod b a) a)))]\n    (cond\n     (= 1 x) 1\n     :else (count (filter #(= 1 (g % x)) (range 1 x))))))","problem":75,"user":"4ffc10aae4b0678c553fc3d6"},{"problem":75,"code":"(fn tot [n]\n  (let [gcd (fn [a b]\n              \t(loop [a a b b]\n                  (if (= 0 b)\n                    a\n                    (recur b (mod a b)))))\n        coprime? (fn [a] (= 1 (gcd n a)))]\n    \t(count (filter coprime? (range n)))))","user":"55934bebe4b0c79f6e1db93b"},{"problem":75,"code":"(fn [n]\n  (if (= n 1) 1\n  (letfn [(gcd [a b] (if (zero? b) a (recur b (mod a b))))]\n    (count (filter #(= 1 (gcd n %)) (range 1 n))))))","user":"59ddae03e4b01968742fed65"},{"problem":75,"code":"(fn totient [x]\n  (if (= 1 x)\n    1\n    (letfn [(coprime? [num1 num2]\n                      (letfn [(divisors [x]\n                                        (filter #(zero? (mod x %)) (range 2 (inc x))))]\n                        (empty? (clojure.set/intersection (set (divisors num1))\n                                                          (set (divisors num2))))\n                        ))]\n      (count (filter (partial coprime? x) (range 1 x))))))","user":"53f6bfd9e4b0db01ade6f9e4"},{"problem":75,"code":"(fn calc-co-prime [n]\n  (letfn [(\n\n           gcd [a b]\n             (if (zero? b) a\n                           (gcd b (mod a b))\n                           )\n            )]\n    (count\n      (filter #(not (nil? %))\n                  (for [ x (range  n) ]\n                    (if (= (gcd x n) 1)\n                      x\n                      nil\n                      )\n                    )\n          )\n      )\n    )\n  )","user":"5edc16e1e4b0c7845d86b0f1"},{"code":"#(if(= % 1) 1 (count (filter (fn[x](not (contains? (set (flatten (rest (for [ d (for [i (range 1 %) :when (= 0 (rem % i))] i)] (filter (fn[a](= 0 (rem a d))) (range 1 %)))))) x))) (range 1 %))))","problem":75,"user":"4fb3dd1ee4b081705acca2a5"},{"code":"(fn totient [arg]\n  (let [gcd (fn gcd [a b]\n              (cond\n                (= b 0) a\n                (> a b) (gcd b (- a b))\n                :else (gcd a (- b a))))]\n    (if (= arg 1) 1\n      (count (filter #(= 1 (gcd % arg)) (range 1 arg))))))","problem":75,"user":"515737f0e4b0b0b4b87062d0"},{"problem":75,"code":"(fn [x]\n   (letfn [(gcd [a b]\n            (cond (= a b) a\n              \t  (> a b) (gcd (- a b) b)\n                  :else (gcd a (- b a))))]\n              (if (= x 1) \n                 1\n               (count (filter #(= 1 (gcd x %)) (drop 1 (range x)))))))","user":"56018dd4e4b04bb52996e18f"},{"problem":75,"code":";; See https://www.geeksforgeeks.org/eulers-totient-function/\n(fn [n] (let [gcd (fn [a b] (if (zero? a) b (recur (rem b a) a)))] \n          (inc (count (filter #(= 1 (gcd % n)) (range 2 n))))))","user":"5a5894d9e4b05d388ecb6c81"},{"problem":75,"code":"(fn [x]\n    (letfn [(gcd [x y]\n              (->> (range 1 (max x y))\n                   (filter #(and (zero? (mod x %)) (zero? (mod y %))))\n                   (last)))\n            (coprime? [x y] (= 1 (gcd x y)))]\n      (if (= 1 x)\n        1\n        (->> (range 1 x)\n             (filter (partial coprime? x))\n             (count)))))","user":"52761edae4b03e8d9a4a74d4"},{"code":"(fn [n]\n  (loop [x 2 a n b x c 1]\n    (cond\n     (>= x n) c\n     (= b 0) (recur (inc x) n (inc x) (if (= a 1) (inc c) c))\n     :else   (recur x b (mod a b) c))))","problem":75,"user":"4e71705e535d5021c1a89649"},{"code":"(fn [n]\n  (let [gcd (fn gcd [a b]\n  (if (zero? b)\n    a\n    (recur b (mod a b))))]\n  (loop [total 0 x (- n 1)]\n    (cond (= 1 n) 1\n          (zero? x) total\n      :else (recur (if (= 1 (gcd n x))\n               (inc total)\n               total)\n             (dec x))))))","problem":75,"user":"51857e64e4b0da5a5be3babe"},{"code":"(fn [z]\n(count\n(filter nil?\n(map \n(\n(fn [y]\n  (fn [x]\n(some zero? (map #(rem x %)   (loop [data y base 2 res []]\n    (if (= base (+ data 1))\n      res\n      (if (= 0 (rem data base))\n  (recur data (+ 1 base) (conj res base))\n\t(recur data (+ 1 base) res)))))\t)))\nz) (range z)))))","problem":75,"user":"4eb0afed535d7eef3080733e"},{"code":"(fn c [ y] (letfn [(divs[x] (apply hash-set (filter #(= 0 (rem x %)) (range 2 (inc x)))))\n         ]\n    (inc\n    (count (filter #(empty? (clojure.set/intersection (divs y) (divs %))) (range 2 y))\n    )))\n    )","problem":75,"user":"50ef3e5de4b0a78662fa2652"},{"code":"(fn euler [x]\r\n  (let [sieve (fn sieve [n coll] \r\n                (cond \r\n                  (empty? coll) nil\r\n                  (= 0 (mod n (first coll))) (sieve n (filter #(> (mod % (first coll)) 0) (rest coll)))\r\n                  true (cons (first coll) (sieve n (rest coll)))))]\r\n    (count (cons 1 (sieve x (range 2 x))))))","problem":75,"user":"4e14108c535d04ed9115e7dd"},{"problem":75,"code":";(identity(\n (fn [n]\n   (letfn\n    [(gcd [a b]\n  (if (= b 0)\n    a\n    (gcd b (mod a b))))]\n   (if (= n 1)\n     1\n     (->> (range 1 n)\n        (filter #(= 1 (gcd n %)))\n        count)))\n     )\n ;99\n ;40\n; 1))","user":"5e64ae6ce4b0fd0acd1586ac"},{"code":"(fn count-prime [n]\n  (let [my-prime (fn my-prime [x y] (if (zero? y) x (my-prime y (mod x y))))]\n    (if (= 1 n)\n      1\n    (count (filter #(= 1 (my-prime n %)) (range 1 n))))))","problem":75,"user":"4f251302e4b0d66497709ff0"},{"code":"(fn [n]\n  (letfn [(gcd [a b] (if (zero? b) a\n                        (recur b (mod a b))))]\n      (count \n        (filter #(= % 1) \n           (map #(gcd n %) (range 1 (inc n)))))))","problem":75,"user":"4facd2fae4b081705acca22f"},{"code":"(fn [n]\r\n  (count\r\n    (filter #(= % 1)\r\n      (let [gcd #(if (zero? %) %2 (recur (mod %2 %) %))]\r\n        (for [x (take n (range))]\r\n          (gcd x n))))))","problem":75,"user":"50843a4ae4b0c98812d0788b"},{"code":"(fn [n] \n    (letfn\n      [ (gcd [a b]\n          (if (zero? b)\n            a\n            (recur b (mod a b))))]\n      (reduce \n          (fn [t x] (if (= 1 (gcd x n)) (inc t) t)) 1\n          (range 2 n))))","problem":75,"user":"4daa374930acd6ed13482a68"},{"problem":75,"code":"(fn __ [x]\n\t(let [gcd (fn __ [a b](if (= 0 b) a (__ b (mod a b))))]\n\t\t(\n\t\t\tcount\n\t\t\t(\n\t\t\t\t->>\n\t\t\t\t(map #(gcd x %) (range 1 (inc x))) (filter #(= 1 %)))\n\t\t\t)\n\t\t)\n\t)","user":"575dda55e4b02ea11479938c"},{"code":"(fn [n]\n  (letfn [(gcd [a b] (if (= 0 b) a (gcd b (mod a b))))]\n    (count (filter #(= 1 (gcd n %)) (range 1 (inc n))))))","problem":75,"user":"51e00020e4b01188f0627534"},{"problem":75,"code":"#(let [gcd (fn gcd [x y] (if (= y 0) x (gcd y (rem x y))))\n\t   f (fn [x i c] (if (>= 1 i) c (recur x (dec i) (if (= 1 (gcd x i)) (inc c) c))))]\n\t(f % (dec %) 1))","user":"53e19461e4b0d874e779ae59"},{"problem":75,"code":"(fn totient [n]\n  (if (= n 1) 1\n      (count (filter #((fn coprime [i1 i2] (= 1 ((fn gcd [i1 i2] (if (= i2 0) i1 (gcd i2 (mod i1 i2)))) i1 i2))) %1 n) (range 1 n)))))","user":"55d95be7e4b0e31453f64ac9"},{"problem":75,"code":"(fn euler-totient [x] \n  (letfn [(gcd [a b]\n               (if (= b 0) a\n                 (recur b (mod a b))))]\n    (if (= x 1) 1\n    (->> \n      (map #(= (gcd x %) 1) (range 1 x))\n      (filter #(= % true))\n      (count)))))","user":"52ee0de4e4b05e3f0be25ec1"},{"problem":75,"code":"(fn [num]\n    (if (= 1 num) 1\n        (let [gcd (fn [a b]\n                    (if (= b 0)\n                      a\n                      (recur b (rem a b))))]\n          (count (filter #(= 1 (gcd % num)) (range 1 num))))))","user":"54be792ee4b0ed20f4ff6eeb"},{"code":"(fn tot [n]\n  (letfn [(gcd [a b] (if (zero? b) a (gcd b (mod a b))))]\n    (count (filter #(= 1 (gcd % n)) (range n)))))","problem":75,"user":"4e9c81e8535dbda64a6f6b80"},{"problem":75,"code":"(let [gcd #(loop [a %1 b %2] (if (zero? b) a (recur b (mod a b))))]\n    (fn [x]\n      (if (<= x 1)\n        1\n        (count (filter #(= 1 (gcd x %)) (range 1 x))))))","user":"5531e445e4b09218d5f44f76"},{"code":"(fn [n] (count (filter #((fn f [a b] (if (= 0 b) (= a 1) (f b (rem a b)))) n %) (range n))))","problem":75,"user":"52bf29fde4b07a9af579232e"},{"problem":75,"code":"(fn [n]\n  (letfn [(gcd [a b]\n            (loop [a a\n                        b b]\n              (cond\n                (zero? b) a\n                :else (recur b (mod a b)))))]\n    (count (filter #(= 1 %) (map #(gcd % n) (range n))))))","user":"53528cd3e4b084c2834f4af2"},{"problem":75,"code":"(fn tot [n]\n  (let [gcd (fn [n1 n2]\n              (loop [numerator (if (< n1 n2) n2 n1)\n                     denominator (if (< n1 n2) n1 n2)]\n                (if (= 0 (rem numerator denominator))\n                  denominator\n                  (recur denominator (rem numerator denominator)))))]\n    (if (= n 1)\n      1\n      (reduce (fn [tot x]\n                (if (= (gcd n x) 1) (inc tot) tot)) 0 (range 1 n)))))","user":"56cc34aee4b0ea9b8538f73c"},{"code":"#(or (#{1} %) (- % (count (distinct (for [o (range 2 %) f (range 2 (inc o)) :when (= 0 (rem o f) (rem % f))] o))) 1))","problem":75,"user":"4ff67852e4b0678c553fc37e"},{"problem":75,"code":"(fn [x] (if (= x 1) 1\n          (count (filter\n                  (fn [y] (= 0 (count (filter\n                                       #(and (= (mod x %) 0) (= (mod y %) 0))\n                                       (range 2 (inc y))))))\n                  (range 1 x)))))","user":"5b465b8be4b02d533a91bc65"},{"problem":75,"code":"(fn [x] (let [is-coprime? (fn is-coprime? [x y] (if (== y 0) (== x 1) \n                                                  (is-coprime? y (mod x y)) ))] \n  (if (== x 1) 1 \n          (inc (count (filter #(is-coprime? % x)(range 2 x)))))))","user":"50856bd1e4b004985b776e4c"},{"code":"(fn et [x]\n  (if (= x 1)\n    1\n    (let [ggt (fn gcd [a b]\n                (if (> a b)\n                  (gcd b a)\n                  (if (or (= a b) (= a 0))\n                    b\n                    (gcd (mod b a) a))))]\n      (count (filter #(= (ggt % x) 1) \n              (rest (range x)))))))","problem":75,"user":"5110b8bae4b04c71fce993f4"},{"problem":75,"code":"(fn [n]\n  (letfn [(gcd [x y]\n            (if (zero? y)\n              x\n              (gcd y (rem x y))))\n          (coprime? [x y]\n            (= (gcd x y) 1))]\n    (if (= n 1)\n      1\n      (inc (count (filter true? (map (partial coprime? n) (range 2 (inc n)))))))))","user":"532bce35e4b09d4e7a9b5536"},{"problem":75,"code":"(fn [n] (letfn [(gcd [a b]\n                   (if (zero? b)\n                     a\n                     (recur b (mod a b))))]\n           (count (filter #(= 1 (gcd n %)) (range 0 n)))))","user":"529dfc6de4b04e0c58e87b8a"},{"problem":75,"code":"(fn [n]\n  (if (= 1 n) 1\n    (letfn [(gcd [a b]\n                 (if (zero? b)\n                   a\n                   (recur b (mod a b))))]\n    (count (filter #(= % 1) (map #(gcd % n) (range 1 n)))))))","user":"56102f50e4b05f002753df6b"},{"code":"(let [gcd (fn gcd [a b] (if (zero? a) b (gcd (mod b a) a)))\n      coprime? (fn [a b] (= 1 (gcd a b)))]\n  (fn [n]\n    (if (= n 1)\n      1\n      (count (filter #(coprime? n %) (range 1 n))))))","problem":75,"user":"53889587e4b0640c7a9a589e"},{"problem":75,"code":"(fn totient\n  [x]\n  (letfn [(gcd [a b]\n            (if (zero? b)\n              a\n              (recur b (rem a b))))\n          \n          (coprime? [a b]\n            (= 1 (gcd a b)))]\n    \n    (if (= x 1)\n      1\n      (->>\n        (range 1 x)\n        (filter #(coprime? x %))\n        count))))","user":"4e8a170c535d3e98b802328f"},{"code":"(fn [n]\n  (if (= n 1)\n    1\n    (let [gcd (fn [a b] (if (zero? b) a (recur b (mod a b))))\n          coprime? (fn [a b] (= 1 (gcd a b)))]\n      (count (filter #(coprime? n %) (range 1 n))))))","problem":75,"user":"534f7dd3e4b084c2834f4acb"},{"code":"(fn [x]\r\n    (if (= x 1) 1\r\n      (let [factors (filter #(= (rem x %) 0) [2 3 5 7 11])]\r\n        (* x (- 1 (/ 1 (first factors))) (- 1 (/ 1 (second factors)))))))","problem":75,"user":"4ecbb249535df97575fdabdf"},{"problem":75,"code":"#(count\n  (cons 1\n        (if (not= % 1)\n          (reduce\n           (fn [s x]\n             (if (zero? (mod % x))\n               (filter (complement (set (range x % x))) s)\n               s))\n           (range 2 %)\n           (range 2 (inc (/ % 2)))))))","user":"56baa68ce4b0f26550335947"},{"code":"(fn our-totient [n]\r\n  (if (= n 1)\r\n    1\r\n    (count (filter #(if (= ((fn our-gcd [a b]\r\n  (if (zero? a)\r\n    b\r\n    (our-gcd (mod b a) a))) % n) 1)\r\n               true\r\n               false)\r\n            (range n)))))","problem":75,"user":"4ef0f1a1535dced4c769f212"},{"code":"(fn [n]\n  (letfn [(GCD [m n]\n            (if (= n 0)\n              m\n              (GCD n (mod m n))))]\n    (if (= n 1) 1\n        (count (reduce #(if (= 1 (GCD n %2)) (conj %1 %2) %1) [] (range 1 n))))))","problem":75,"user":"518ccf6be4b05e6c8537e386"},{"problem":75,"code":"(fn [n] (max 1 (count (filter #(reduce (fn [a b] (and a (not= 0 (mod n b) (mod % b)))) true (range 2 n)) (range 1 n)))))","user":"5c41db45e4b08cd430848ece"},{"problem":75,"code":"(fn [x] (count (filter #(= 1 %) (let [gcd (fn [a b] (if (zero? b) a (recur b (mod a b))))]\n            (map #(gcd x %) (range x))))))","user":"52d07cc5e4b07d0d72b273bb"},{"code":"(fn num-coprime [x]\n  (cond \n   (= x 1) 1\n   :else (letfn [(gcd [a b] (if (zero? b) a (gcd b (mod a b))))]\n           (count (filter #(= 1 (gcd % x)) (range 1 x))))))","problem":75,"user":"52d809bde4b09f7907dd1384"},{"problem":75,"code":"(fn [x]\n\t(letfn [(g [a b] (if (zero? b) a (recur b (mod a b))))]\n\t\t(count (filter #(= 1 (g % x)) (range 1 (inc x))))))","user":"57ccedaae4b0c746388ab88e"},{"code":"(fn [n]\n  (let [gcd (fn [a b] (if (zero? a) b (recur (mod b a) a)))]\n    (count (->> (range 1 (inc n)) (filter #(= 1 (gcd % n)))))))","problem":75,"user":"53800d99e4b06839e8705ebd"},{"problem":75,"code":"(fn __\n  [x]\n  (letfn [(gcd [a b]\n            (if (zero? b)\n              a\n              (recur b (mod a b))))]\n    (count (filter #(= (gcd % x) 1) (range x)))))","user":"5b73e500e4b047b03b2036ba"},{"problem":75,"code":"(fn etf [n]\n  (letfn [ (p [n]\n            (->>\n            (range 2 n)\n            (filter (fn [x] (every? #(< 0 (rem x %)) (range 2 x))))\n            (take-while #(<= % n))))\n          (d [n] (filter #(= 0 (mod n %)) (p n)))\n    ]\n    (* n (reduce #(* %1(- 1 (/ 1 %2))) 1 (d n) ))\n    )\n  )","user":"51f81925e4b09be9c177e526"},{"code":"(fn\n  [n]\n  (let [coprime?\n        (fn [a b]\n          (let [r (range 2 (inc (min a b)))]\n            (->>\n             (filter #(= 0 (rem b %) (rem a %))\n                     r)\n             first\n             nil?\n             )))]\n    (count (filter #(coprime? % n) (range 1 (inc n))))))","problem":75,"user":"51852961e4b0da5a5be3babb"},{"problem":75,"code":"(fn [x]\n  (if (= x 1) 1\n      (let [f (fn gcd [a b] (if (= 0 b) a (gcd b (mod a b))))]\n        (count (filter #(= 1 (f x  %)) (range 1 x))))))","user":"5609d328e4b05f002753deee"},{"code":"(fn [n]\n    (letfn [(divides? [a b]\n              (= 0 (mod b a)))\n            (coprime? [m]\n              (not-any? #(and (divides? %1 n) (divides? %1 m)) (range 2 (inc m))))]\n      (if (= n 1)\n         1\n         (count (filter coprime? (range 1 n))))))","problem":75,"user":"5165a235e4b079ad97ec44ac"},{"code":"(fn [x]\n  (letfn [(sieve [[p & rst]]\n          (lazy-seq (cons p (sieve (remove #(= 0 (mod % p)) rst)))))]\n    (let [primes (filter #(= (rem x %) 0)\n             (take x (sieve (iterate inc 2))))\n          rt (filter (fn [n] (not-any?\n                (fn [p] (= (rem n p) 0)) primes)) (take (dec x)\n              (iterate inc 2)))]\n      (+ 1 (count rt)))))\n\n;fn [n] (+ 1 (count (filter #(= % (numerator (/ % n))) (range 2 n)))))","problem":75,"user":"4ef992c8535dced4c769f268"},{"problem":75,"code":"(fn [x]\n  (letfn [(gcd [a b] (if (zero? b) a (recur b (rem a b))))]\n  (if (= x 1)\n    1\n    (count (filter #(= 1 (gcd % x)) (range 1 x))))))","user":"55933c7ae4b0c79f6e1db938"},{"problem":75,"code":"(fn euler-totient [num]\n  (letfn [(gcd [x y]\n            (loop [n x m y]\n              (if (= 0 n)\n                m\n                (recur (mod m n) n))))]\n    \n    (count (filter (fn [[x y]]\n                     (= 1 (gcd x y))) (map (fn [n]\n                                             [n num]) (range num))))))","user":"5693a53ee4b0dcc4269f4106"},{"code":"(fn count-coprime [x]\r\n  (letfn\r\n    [(gcd [x y]\r\n      (loop [a x b y]\r\n        (if (= b 0)\r\n          a\r\n          (recur b (mod a b)))))]\r\n    (loop [a x result []]\r\n      (if (= a 0)\r\n        (count result)\r\n        (recur (dec a) (if (= 1 (gcd a x)) (conj result a) result) )))))","problem":75,"user":"4fd170fce4b04c3a95aa0411"},{"problem":75,"code":"#(count \n  (letfn [(gcd [a b] (if (zero? b) a (recur b (mod a b))))]\n  (reduce\n  (fn [a x]\n    (if (= (gcd % x) 1)\n      (conj a x)\n      a)) [1] (range 2 %))))","user":"5e3a25d4e4b01d43a70e8dde"},{"problem":75,"code":"(fn [x] (if (= x 1) 1\n   (count (filter \n           #(empty? (filter\n                     (fn [nb] (and (= 0 (rem x nb)) (= 0 (rem % nb))))\n                     (range 2 x))  ) \n                  (range 1 x)       \n                  ))\n          ))","user":"52faec2ee4b047fd55837004"},{"code":"(fn [n]\n  (if (= 1 n) n\n    (let [gcd (fn [m n] (if (zero? n) m (recur n (mod m n))))\n          coprime? #(= 1 (gcd % %2))]\n      (count (for [x (range 1 n) :when (coprime? x n)] x)))))","problem":75,"user":"4f26d6d9e4b0d6649770a007"},{"code":"(fn\n  [x]\n  (or (and (= x 1) 1)\n      (->> x\n           (range 1)\n           (filter (fn [v]\n                (loop [a x b v]\n                  (cond\n                   (= a b) (= a 1)\n                   (> a b) (recur (- a b) b)\n                   :else   (recur a (- b a)))\n                  )))\n           (count))))","problem":75,"user":"513fab65e4b00f13ea1bd891"},{"code":"(fn [x]\n  (let [gcd (fn [a b] (if (zero? b) a (recur b (mod a b))))\n        coprime? (fn [y] (= 1 (gcd x y)))]\n    (if (= 1 x) x\n      (count (filter coprime? (range 1 x))))))","problem":75,"user":"50cb4cf6e4b0f78a8e1645b4"},{"problem":75,"code":"(do\n\n;; my bullshit over-engineered version\n  \n  \n(fn __ [x]\n  ;; The first half of this thread is cribbed from my solution to nth-prime.\n  ;; With recycled bits, find prime divisors of x.\n  ;; Then we apply Euler's product formula--thanks wikipedia.\n  (->> \n   (range)\n   (drop 2)\n   (reductions \n    (fn [primes n] ;; accumulate n to list of primes if n is prime\n      (if (some \n           #(zero? (mod n %)) \n           (take-while #(<= (* % %) n) primes))\n        primes ;; n has a prime divisor, skip\n        \n        (conj primes n) ;; n is prime, add to result\n        )) ;; end prime seive\n    [])\n   \n   (#(nth % x)) ;; prime numbers less than x\n   (filter #(zero? (mod x %)) ) ;; prime divisors of x\n   (map #( - 1 (/ 1 %))) ;; (1-1/p) for each prime divisor \n   (reduce * x) \n   )\n  )\n\n\n;; the obvious loop was much faster:\n(fn [n]\n  (->> (range n)\n       (filter #(= 1 (.gcd (java.math.BigInteger/valueOf (int n))\n                           (java.math.BigInteger/valueOf (int %)))))\n       count\n       ))\n\n)","user":"533a2f7be4b0e30313ee6cb8"},{"code":"(fn [n]\n  (if (= n 1) 1\n    (letfn [(gcd [a b] (if (zero? b) a (recur b (mod a b))))]\n      (->> n\n        (range 1)\n        (remove #(not= 1 (gcd n %)))\n        count))))","problem":75,"user":"4fb12b35e4b081705acca275"},{"code":"(letfn [(gcd\n         [a b]\n         (if (zero? b) a\n           (recur b (mod a b))))]\n\n  (fn totient [n]\n    (->> (range n)\n         (filter (comp (partial = 1)\n                       (partial gcd n)))\n         count)))","problem":75,"user":"532ab0bde4b09d4e7a9b5527"},{"problem":75,"code":"(fn [x] (let [ xx (fn  [x y] (drop-last y (reverse (range  x ))))\n\t           isz (fn [source did] (= 0 (count (filter #(or (and (= 0 (mod did %)) (= 0 (mod source %))) (= 0 (mod source did))) (if (= did 2) (list 2) (xx did 2) )))))\n\t\t\t\t] \n\t(if (= 1 x) 1 (count (filter identity (map #(isz x %) (xx x 1)))))))","user":"5ac04101e4b073f177442737"},{"problem":75,"code":"(fn __ [x]\n  (letfn [(gcd [a b]\n            (let [c (mod a b)]\n              (if (= c 0) b (recur b c))))]    \n    (count (filter #(= 1 (gcd % x)) (range x)))))","user":"526759b3e4b03e8d9a4a715b"},{"code":"(fn euler-number [n]\n  (max\n    1\n    (count\n      (for [m (range 1 n)\n            :when (= 1 ((fn gcd [a b]\n                          (if (< a b)\n                            (gcd b a)\n                            (if (= b 0)\n                              a\n                              (gcd b (rem a b))))) n m))]\n        m))))","problem":75,"user":"526ee63de4b03e8d9a4a733f"},{"code":"(fn phi [n]\n  (letfn [(gcd [x y] \n               (if (zero? y) \n                 x \n                 (recur y (rem x y))))]\n    (count \n     (filter #(= 1 (gcd n %)) (range n 0 -1)))))","problem":75,"user":"517a025ce4b01aacecbecbe6"},{"problem":75,"code":"(fn [n]\n  (let [prime? (fn [x]\n                 (not-any?\n                  #(zero? (mod x %))\n                  (range 2 (dec x))))]\n    (->>\n     (range 2 n)\n     (filter #(zero? (mod n %)))\n     (filter prime?)\n     (map #(- 1 (/ 1 %)))\n     (reduce *)\n     (* n))))","user":"5ccb0bbee4b0ccb06196287c"},{"code":"(fn [n] \n  (count \n   (filter \n    (fn [i] (= (#(if (zero? %2) %1 (recur %2 (mod %1 %2))) i n) 1))\n    (range 1 (inc n)))))","problem":75,"user":"528652fbe4b0239c8a67ae14"},{"code":"(fn coprime_num [n]\n  (let [nocoprime? \n          (fn nocoprime? [n1 n2]\n            (cond (or (= 0 n1) (= 0 n2)) true \n                  (or (= 1 n1) (= 1 n2)) false \n              :else\n                (if (not-any? #(= 0 (rem n1 %) (rem n2 %)) (range 2 (inc (min n1 n2))))\n                  false \n                  true))) \n        coprime_col\n          (fn coprime_col [n]\n            (filter (comp not (partial nocoprime? n)) (range (inc n))))]\n    (count (coprime_col n))))","problem":75,"user":"5243e37ae4b076204b44fae3"},{"problem":75,"code":"(fn [x]\n  (if (= x 1) 1\n    (letfn [(divisor [a b] (loop [d (min a b)] (if (= 0 (mod a d) (mod b d)) d (recur (dec d)))))]\n    (loop [a 1 n 2]\n      (cond \n       (= n x) a\n       (= (divisor x n) 1) (recur (inc a) (inc n))\n       :else (recur a (inc n)))))))","user":"4f3b5219e4b0e243712b1f2a"},{"problem":75,"code":"(fn f [n]\n  (letfn\n    [(coprime [x y]\n      (->> (range 2 (inc (min x y)))\n       (some (fn [a] (and (zero? (rem x a)) (zero? (rem y a)))))\n       not))]\n    (if \n      (= n 1) \n      1 \n      (->> (range 1 n)\n           (map (fn [x] (if (coprime x n) 1 0)))\n           (reduce +)))))","user":"4e6a5728535d8ccf87e9fecf"},{"problem":75,"code":"(fn euler-totient [x]\n  (cond\n    (< x 0) (throw (IllegalArgumentException. \"x < 0\"))\n    (= x 1) 1\n    :else (letfn [(gcd [a b]\n                    (if (= 0 b) a (recur b (rem a b))))\n                  (coprime? [a b]\n                    (= 1 (gcd a b)))]\n            (count (filter #(coprime? % x) (range 1 x))))))","user":"57ee804ee4b0bfb2137f5bbb"},{"problem":75,"code":"(letfn [\n    (divisors [x] (reduce \n                (fn [m i] \n                    (if (= 0 (rem x i)) \n                        (conj m i)\n                        m))\n                #{}\n                (range 1 (- x 1)))) \n    (are-coprimes [m, n] (= (clojure.set/intersection (divisors m) (divisors n)) #{1})) \n] \n    (fn [x]\n        (if (= x 1)\n            1\n            (reduce \n                (fn [t i] \n                    (if (are-coprimes x i)\n                        (+ t 1)\n                        t))\n                0\n                (range 1 x))))\n)","user":"5356d00ee4b04ce2eb3ed26f"},{"problem":75,"code":"(fn [n]\n \n (letfn [(gcd [a b] (if (zero? b) a (recur b (mod a b))))]\n \n   (->> (range 1 (inc n))\n        (map #(gcd % n))\n        (filter #(= 1 %))\n        (count))\n))","user":"5409a12fe4b0addc1aec66df"},{"problem":75,"code":"(let [gcd (fn [a b]\n  (if (zero? b)\n    a\n    (recur b (mod a b))))]\n  (fn [n]\n    (if (= 1 n)\n      1\n      (->> (range 1 n)\n         (filter #(= 1 (gcd n %)))\n         count))))","user":"5bab5440e4b0a20761a23475"},{"problem":75,"code":"(fn [x]\n    (if (= x 1)\n      1\n      (letfn [(factors [n]\n               (into #{n} (filter #(zero? (mod n %))\n                                  (range 1 (inc n)))))\n             (gcd [a b]\n               (clojure.set/intersection (factors a) (factors b)))]\n       (count (filter #(= 1 (count (gcd x %))) (range 1 x))))))","user":"4e617114535d8ccf87e9fe5b"},{"problem":75,"code":"(fn [numb] (loop [c (range 2 numb) counter 1]\n             (if (empty? c) counter\n               (recur (rest c) (if (= 1 ((fn [number1 number2] (loop [bigger (max number1 number2) smaller (min number1 number2)]\n                              (if(zero? (rem bigger smaller)) smaller\n                              (recur (/ (- bigger (rem bigger smaller)) (quot bigger smaller)) \n                                     (rem bigger smaller))))) (first c) numb)) (inc counter) counter ) ))))","user":"54e4edcae4b024c67c0cf7f3"},{"problem":75,"code":"(fn my-totient [n]\n  (let [gcd #(loop [a %1 b %2]\n               (if (< a b)\n                 (recur b a)\n                 (if (= 0 (mod a b))\n                   b\n                   (recur b (mod a b)))))\n        ]\n    (if (= 1 n) 1\n      (loop [result 0 coll (range 1 n)]\n        (if (empty? coll)\n          result\n          (recur (+ result (if (= 1 (gcd n (first coll))) 1 0)) (rest coll)))))))","user":"55eb026de4b0121d4835fdb7"},{"code":"(fn [s]\n  (letfn [(g [a b] (if (zero? b) a (g b (mod a b))))]\n    (count\n      (filter\n        #(== 1 (g s %))\n        (range s)))))","problem":75,"user":"4f08b15b535dcb61093f6c40"},{"code":"(fn tol [x]\r\n  (letfn [(gcd [x y]\r\n            (cond (= x y) x\r\n                  (> x y) (gcd (- x y) y)\r\n                  (< x y) (gcd x (- y x))))]\r\n    (if (= x 1)\r\n      1\r\n      (reduce (fn [cc d]\r\n                (if (= (gcd x d) 1)\r\n                  (+ cc 1)\r\n                  cc))\r\n              0 (range 1 x)))))","problem":75,"user":"4ddc1c89535d02782fcbea01"},{"code":"(fn totient [n]\n  (if (= n 1)\n    1\n    (count\n      (filter\n        #(= (denominator %) n)\n          (map #(/ % n) (range 1 n))))))","problem":75,"user":"4ea7999e535d7eef308072ee"},{"code":"(fn [n]\n  (if (= 1 n) 1\n      (count\n       (filter\n        #(= 1 (loop [a n b %] (if (zero? b) a (recur b (mod a b)))))\n        (range 1 n)))))","problem":75,"user":"4f713878e4b07046d9f4f00a"},{"code":"(fn [n]\n  (letfn [(gcd [x y] (if (zero? y) x (gcd y (mod x y))))]\n    (count (filter #(= 1 (gcd n %)) (range n)))))","problem":75,"user":"4e773be8535d324fb2983d6e"},{"problem":75,"code":"(fn [x]\n   (let [gcd\n         (fn gcd [a b]\n           (if (zero? b)\n             a\n             (gcd b (mod a b))))]\n     (count (filter #(= 1 (gcd (inc %) x)) (range x)))))","user":"58db3c5ae4b0a4d5acaab677"},{"code":"(letfn [(gcd [a b] (if (zero? b) a (gcd b (mod a b))))]\n\n  (fn [n] (if (= n 1)\n           1\n           (count (filter #(= 1 (gcd n %)) (range 1 n))))))","problem":75,"user":"52d2ca1ce4b099d49816f0b4"},{"problem":75,"code":"(fn [x]\n  (let [gcd (fn gcd [a b] (cond (zero? b) a :else (gcd b (mod a b))))]\n    (count (filter #(= (gcd x %) 1) (range x)))))","user":"5a653f80e4b0512ff01cd9b2"},{"code":"(fn [n]\r\n    (letfn [(g [a b] (if (= a 0) b (g (mod b a) a)))]\r\n           (count (filter #(= 1 (g % n)) (range n)))))","problem":75,"user":"4eecdd66535d93acb0a668b9"},{"problem":75,"code":"(fn phi [n]\n (letfn [\n (prims-upto [n]\n (let\n   [bgn-prms [2]\n    nxt-prim \n     (fn [prev]\n      (let [lst (peek prev)]\n       (loop [z (inc lst)]\n        (if (even? z) \n         (recur (inc z))\n         (if (not-any? #(zero? (mod z %)) prev)\n          z\n          (recur (inc z)))) )))]\n   (loop [acc bgn-prms]\n    (if (<= n (peek acc)) \n     acc\n     (let [newacc (conj acc (nxt-prim acc))]\n      (recur newacc)))))) ]\n  (if (= 1 n)\n   1\n   (let \n    [n-prims (prims-upto n)\n     lst-prims \n       (take-while \n         #(<= (* % %) n) \n         n-prims)\n     prm-set (set n-prims)]\n\n    (if (= n (peek n-prims))\n     (dec n) \n     (let\n      [factors\n       (loop [acc [] tmp n]\n        (if (prm-set tmp)\n          (conj acc tmp)\n          (let [nxt-f (first (filter #(zero? (mod tmp %)) lst-prims))]\n           (if (nil? nxt-f) \n            nil  ; ??err\n            (recur (conj acc nxt-f) (/ tmp nxt-f) )))) )\n       fct-ok? (= n (reduce * factors))]\n      (if-not fct-ok?\n       nil ; ?? impossible case\n       (reduce (fn [z b] (* z (- 1 (/ 1 b)))) n (set factors))\n       ) ))))))","user":"57f9011ee4b0d3187e900935"},{"problem":75,"code":"(fn [x]\n  (let [prime (fn [a b]\n                    (cond (= a b) a\n                          (< a b) (recur (- b a) a)\n                          :else (recur (- a b) b)))\n        is-coprime (fn [a b]\n                     (= 1 (prime a b)))]\n  (count (filter (partial is-coprime x) (range 1 (inc x))))))","user":"56288ccae4b00e49c7cb47ea"},{"problem":75,"code":"(fn p-75 [n]\n  (if (= n 1) 1\n       (let [gcd (fn gcd [a b]\n                (cond (< a b) (gcd b a) ; have *a* bigger\n                (= 0 (mod a b)) b\n                :else (gcd b (mod a b))))]\n        (count (filter #(= 1 %) (map #(gcd n %) (drop 1 (range n)))))\n        )))","user":"5bfc9037e4b0bdcf453d15f2"},{"code":"(fn [x]\n  (if (= 1 x)\n    1\n    (let [gcd (fn [a b] (loop [a a b b] (if (= b 0) a (recur b (mod a b)))))]\n      (count (filter #(= 1 %) (map #(gcd x %) (range 1 x)))))))","problem":75,"user":"50bd6033e4b0594b91591c66"},{"problem":75,"code":"(fn totient [n]\n  (if (= 1 n)\n    1\n    (letfn [(gcd [x y]\n              (let [dividend (max x y)\n                    divisor (min x y)\n                    remainder (rem dividend divisor)]\n                (if (zero? remainder)\n                  divisor\n                  (recur divisor remainder))))]\n      (count (filter #(= 1 (gcd %1 n)) (range 1 n))))))","user":"58f2e8fbe4b0438e51c2ce94"},{"problem":75,"code":"(fn totient [n]\n  (letfn [(gcd [a b] (if (= 0 b) a (gcd b (mod a b))))]\n    (count (filter #(= 1 (gcd n %)) (range n)))))","user":"549dfe40e4b0f3d1d8e70f9a"},{"code":"(fn totient [x]\r\n  (inc (count (filter #(= ((fn gcd [a b]\r\n    (if (> b a)\r\n      (recur b a)\r\n      (if (= a b)\r\n        a\r\n        (recur b (- a b))))) \r\n    % x) 1) (range 1 (dec x))))))","problem":75,"user":"4e123905535d04ed9115e7ce"},{"problem":75,"code":"(fn Totient [x]\n  (if (= x 1)\n    1\n    (count\n    (letfn [(gcd [a b]\n               (if (= b 0)\n                 a\n                 (gcd b, (mod a b))))]\n    (filter \n     #(= 1 (gcd x %))\n     (range 1 x))))))","user":"5b3251c1e4b025bcb146f317"},{"problem":75,"code":"(fn [x]\n  (let [gcd (fn gcd ([a b] (gcd a b (min a b)))\n              ([a b res]\n               (if (and (= 0 (mod a res))\n                        (= 0 (mod b res)))\n                 res\n                 (recur a b (dec res)))))\n        less-gcd (map (partial gcd x) (range 1 (inc x)))]\n    (count (filter (partial = 1) less-gcd))))","user":"5515b138e4b055c2f668d4ed"},{"code":"(fn totient\n  [n]\n  (let [divisors-of\n        (fn divisors-of\n          [n proper]\n          (cond\n           (neg? n) (divisors-of (- n) proper)\n           (< n 2)  (if (true? proper) []  [1])\n           (= n 2)  (if (true? proper) [1] [1 2])\n           :default (let [lim (int (/ n 2))\n                          opt-n (if (true? proper) [] [n]) ]\n                      (concat (filter #(zero? (rem n %)) (range 1 (inc lim))) opt-n))))\n\n        coprime?\n        (fn coprime?\n          [x y]\n          (= #{1} (clojure.set/intersection\n                   (set (divisors-of x true))\n                   (set (divisors-of y true)))))\n\n        ]\n    \n    (if (= 1 n)\n      1\n      (dec (count (filter #(coprime? n %) (range 1 n)))))))","problem":75,"user":"4f047c07535dcb61093f6bcd"},{"code":"(fn totient- [n]\n  \"75. Write a function which calculates Euler's totient function.\"\n  (letfn [(gcd- [a b] (if (= 0 b) a (recur b (mod a b))))\n          (coprime?- [a b] (= 1 (gcd- a b)))]\n    (cond\n     (= 1 n) 1\n     :else (count (filter #(coprime?- n %) (range 1 n))))))","problem":75,"user":"4e5eb843535d8a8b8723a2d4"},{"problem":75,"code":"(fn euler-totient [x]\n    (let [gcd (fn gcd [a b]\n                (if (zero? b)\n                  (Math/abs a)\n                  (recur b (rem a b))))]\n      (reduce (fn [count a]\n                (if (= 1 (gcd a x))\n                  (do (println a) (inc count))\n                  count))\n              1\n              (range 2 x))))","user":"5df70ee8e4b0a607a9a45c8a"},{"problem":75,"code":"(fn [x]\n   (letfn [(gcd [a b] (if (zero? b) a (recur b (mod a b))))\n           (co-prime? [x y] (= 1 (gcd x y)))]\n     (count (filter #(co-prime? x %) (range x)))))","user":"57fc5e42e4b0d3187e900997"},{"code":"(letfn [\r\n  (gcd [a b]\r\n    (if (zero? b)\r\n  \t  a\r\n\t\t  (recur b (mod a b))))\r\n  (coprime? [a b]\r\n    (= 1 (gcd a b)))]\r\n(fn [x]\r\n  (if (= x 1)\r\n    1\r\n    (count (filter (partial coprime? x) (range 1 x))))))","problem":75,"user":"4dd6d6a0535d2dad7130b5ca"},{"code":"(fn totient[n]\n  (letfn [ ( gcd[a b] \n               (let [ mx (max a b) mn (min a b) ]\n                 (if(= mn mx) mx (recur mn (- mx mn))))) ]\n  (count (filter #(= 1 %) (map #(gcd %1 %2) (take n (drop 1 (range))) (repeat n))))))","problem":75,"user":"50b25f2ce4b03ea88043355f"},{"problem":75,"code":"(fn [n]\n  (let \n    [gcd (fn gcd [a b] (if (= 0 b) a (gcd b (mod a b))))\n     coprimes (filter #(= 1 (gcd n %)) (range n))]\n    (if (= 1 n) 1 (count coprimes))))","user":"595914e0e4b066ee0a44af99"},{"code":"(fn totient [x]\n  (let [ finder (fn [n] (into #{}  ( reduce #(if (= 0 ( rem n  %2)) (cons %2 %1) %1 )  #{} (range 2 (inc  n))))) \n         inits (finder x)\n         testbed (map #( finder %) (range 2  x))\n         ]         \n    (reduce #(if (= 0 (count  (clojure.set/intersection inits %2))) (inc %1) %1) 1 testbed)\n\n    )\n  )","problem":75,"user":"4ec4d723535dcc7ae8597d65"},{"problem":75,"code":"(fn [x]\n   (->> (range x)\n        (filter #(= 1 (.gcd (BigInteger/valueOf %) (BigInteger/valueOf x))))\n        (count)))","user":"550f1c99e4b06e50f9beb171"},{"problem":75,"code":"(fn euler [n]\n  (letfn [(primes\n                ([]  (concat [2] (primes 3)))\n                ([n] (let [sqrt-n (+ (Math/sqrt n) 1)\n                           flag? (if (odd? n) (every? false? (map #(zero? (mod n %)) (range 3 sqrt-n 2))) false)]\n                       (if (true? flag?) (lazy-seq (cons n (primes (inc n))))\n                                         (recur (inc n))))\n                  ))\n          (coprime? [p q]\n                   {:pre [(< 0 p) (< 0 q)]}\n                   (not-any? #(and (zero? (rem p %))\n                                   (zero? (rem q %)))\n                              (take-while #(<= (* 2 %)  p) (primes))))\n        ]\n    (if (= 1 n) 1\n    (count (filter #(coprime? n %) (range 1 n)))))\n  )","user":"5592bf9fe4b0c79f6e1db933"},{"code":"(fn [n]\n  (count \n    (filter \n      #(= 1\n        ((fn gcd [a b]\n          (if (= a b) a \n          (if (> a b) (gcd (- a b) b)\n          (gcd a (- b a))\n          ))\n        ) n %)) \n      (range 1 (+ n 1))\n    )\n  )\n)","problem":75,"user":"4f84400de4b033992c121c2e"},{"code":"(fn eut[n] (if (= 1 n) 1\r\n  (let [gcd (fn [a b] (if (pos? b) (recur b (mod a b)) a))]\r\n    (->>\r\n      (range 1 n)\r\n      (filter #(= 1 (gcd % n)))\r\n      count))))","problem":75,"user":"50336c6be4b0c6c1199c710f"},{"problem":75,"code":"(fn euler [n]\n  (let [gcd (fn [a b] (if (zero? b) a (recur b (mod a b))))]\n    (->> (range 2 n)\n         (map #(gcd n %))\n         (filter #(= 1 %))\n         (count)\n         (inc))))","user":"58dcf11ae4b0a4d5acaab6af"},{"problem":75,"code":"(fn [max]\n  (letfn [(gcd [x y] \n            (if (= y 0) \n              x \n              (recur y (rem x y))))]\n    (count (filter #(= 1 (gcd max %)) (range 1 (inc max))))))","user":"541b1f25e4b01498b1a71a63"},{"problem":75,"code":"(fn totient\n  [arg]\n  (if (= 1 arg)\n    1\n    (let [factor? #(zero? (mod % %2))\n          factors #(concat\n                     (for [x (drop 1 (range (inc (quot % 2))))\n                           :when (factor? % x)] x)\n                     (list %))\n          gcd (fn [x y]\n                (let [x-factors (factors x)\n                      y-factors (factors y)\n                      common-factors (filter #(some #{%} x-factors) y-factors)\n                      sorted-factors (sort common-factors)]\n                  (last sorted-factors)))\n          coprime? #(= 1 (gcd % %2))]\n      (count\n       (filter true?\n               (map (partial coprime? arg) (range 1 arg)))))))","user":"56ff45e5e4b08d47c97781bb"},{"code":"(fn [x]\n   (letfn [(gcd [a b]\n                (if (zero? b)\n                  a\n                  (recur b (mod a b))))\n           (coprime? [a b]\n                     (= 1 (gcd a b)))]\n     (count (filter (partial coprime? x) (range x)))))","problem":75,"user":"506d5e4ce4b0a302964c5493"},{"problem":75,"code":"(fn phi\n  [n]\n  (let [gcd (fn [a b]\n              (if (= b 0)\n                a\n                (recur b (mod a b))))]\n    (count (filter #(= (gcd % n) 1) (range 1 (inc n))))))","user":"53e8c684e4b036ad0777e48b"},{"problem":75,"code":"(fn [x]\r\n  (if (= 1 x)\r\n    1\r\n    (->>\r\n      (range 1 x)\r\n      (filter (fn [n] (= 1\r\n        ((fn gcd [a b]\r\n          (if (or (= b 0) (= a b)) a\r\n            (if (< a b) (gcd b a)\r\n              (gcd b (mod a b))))) n x))))\r\n      (map (fn [_] 1))\r\n      (reduce +))))","user":"555bd27ae4b0b056612e2244"},{"code":"(fn [n]\r\n  (letfn ((gcd [m n]\r\n               (loop [mm (if (> m n) m n)\r\n                      nn (if (> m n) n m)]\r\n                 (cond (= nn 0)\r\n                       mm\r\n                       (= (mod mm nn) 0)\r\n                       nn\r\n                       :else\r\n                       (recur nn (mod mm nn))))))\r\n         (if (= n 1)\r\n           1\r\n           (loop [i 1\r\n                  c 0]\r\n             (if (= i n)\r\n               c\r\n               (if (= (gcd n i) 1)\r\n                 (recur (+ i 1) (+ c 1))\r\n                 (recur (+ i 1) c)))))))","problem":75,"user":"4de2f44f535d08e6dec9fdec"},{"code":"(fn phi [x]\n  (letfn [(prime? [x]\n            (and (> x 1)\n                 (every? #(> (mod x %) 0) (range 2 x))))\n          (divisors [x]\n            (filter #(zero? (mod x %)) (range 1 (inc x))))\n          (prime-divisors [x]\n            (filter prime? (divisors x)))]\n    (->> (prime-divisors x)\n         (map #(- 1 (/ 1 %)))\n         (reduce * x))))","problem":75,"user":"4f3fb586e4b0e243712b1f9c"},{"code":"{1 1, 10 4, 40 16, 99, 60}","problem":75,"user":"50bc23e4e4b0594b91591c3c"},{"problem":75,"code":"(letfn [(gcd\n         [a b]\n         (if (pos? a)\n           (recur (mod b a) a)\n           b))]\n  (fn totient [n]\n    (if (> n 1)\n      (->> (range n)\n           (map #(gcd n %))\n           (filter #(= 1 %))\n           count)\n      1)))","user":"54ca9ca8e4b057c6fda3a265"},{"problem":75,"code":"#(count\n  (filter (fn [x]\n            (if (= 1\n                   (loop [a % b x]\n                     (if (zero? b)\n                       a\n                       (recur b (mod a b)))))\n              x))\n          (range %)))","user":"511688d5e4b0b3e208dba05a"},{"problem":75,"code":"#(case % 1 1 10 4 40 16 99 60)","user":"55bf6dbce4b01b9910ae2a12"},{"code":"(fn [x]\n  (letfn [(gcd [a b] (if (zero? b) a (gcd b (mod a b))))\n          (coprime? [a b] (= 1 (gcd a b)))]\n    (count (filter (partial coprime? x) (range 1 (inc x))))))","problem":75,"user":"4e39fb68535deb9a81d77f47"},{"problem":75,"code":"(fn euler [n]\n  (let [gcd (fn [a b] (if (zero? b) a (recur b (mod a b))))]\n    (if (= n 1) 1\n      (count (filter #(= (gcd n %) 1) (range 1 n))))))","user":"54448e84e4b032a45b869393"},{"code":"(fn [n]\n  (let [gcd (fn [x y] (if (= 0 y) x (recur y (mod x y))))]\n    (if (= n 1) 1 (count (filter #(= (gcd % n) 1) (rest (range n)))))))","problem":75,"user":"4f13047d535d64f60314642c"},{"code":"(fn [x]\n  (letfn [(gcd [x y] (some #(when (every? zero? [(mod y %) (mod x %)]) %) (range x 0 -1)))]\n    (loop [n x c 1]\n      (cond\n        (= n 1) c\n        (= 1 (gcd n x)) (recur (dec n) (inc c))\n        :else (recur (dec n) c)))))","problem":75,"user":"4fcf642ee4b03432b189f410"},{"code":"(fn [n]\n  (letfn [(euclid [a b]\n                  (if (zero? b) a\n                    (recur b (mod a b))))]\n  \t(reduce #(if (= 1 (euclid n %2))\n               (inc %1)\n                %1)\n            0\n            (range n))))","problem":75,"user":"52d340ebe4b099d49816f0c1"},{"code":"(letfn [(gcd\n         [a b]\n         (if (= 0 a) b\n           (if (< a b)\n             (gcd b a)\n             (gcd (- a b) b))))]\n  (fn [n] (let [coprimes-from-2 (filter #(= 1 (gcd n %)) (range 2 n))]\n            (count (cons 1 coprimes-from-2)))))","problem":75,"user":"515ead6be4b049add99a053e"},{"problem":75,"code":"(fn totient [x]\n  (letfn [(gcd [a b] (cond\n                       (> a b) (recur (- a b) b)\n                       (< a b) (recur a (- b a))\n                       :else a))]\n    (count (filter #(= 1 (gcd x %)) (range 1 (inc x))))\n    ))","user":"55e7d06ee4b050e68259b496"},{"code":"(fn totient [n]\n  (loop [p (- n 1) prod n]\n    (if (= p 0) \n      prod     \n      (if (and \n            (= (mod n p) 0)     \n            ( (fn [cur](loop [i (- cur 1) ]\n                     (if (< i 1) false\n                          (if (= i 1)            \n                            true            \n                            (if (= (mod cur i) 0)              \n                              false              \n                              (recur (- i 1))            \n                              )          \n                            ))        \n                          ))  p))\n      (recur (- p 1) (* prod (- 1 (/ 1 p))))\n      (recur (- p 1) prod)\n      )\n      )\n    )\n  )","problem":75,"user":"4fcf5292e4b03432b189f40e"},{"code":"(fn p[n]\n\t\t(letfn [(g [x y]\n\t\t\t\t\t(if (zero? (mod x y)) y (g y (mod x y))))\n\t\t\t\t(c [u] (count (filter #(= 1 (g u %)) (range 1 (inc u)))))]\n\t\t\t   (c n)))","problem":75,"user":"51f2851fe4b0210f90e7454b"},{"problem":75,"code":"(fn [num]\n   (letfn [(gcd [a b]\n             (if (zero? b)\n               a\n               (gcd b (mod a b))))]\n     (->>\n\n      (filter #(= 1 (gcd num %))\n              (range num))\n      count)))","user":"591072e0e4b0163c97b36ebc"},{"problem":75,"code":"(fn [n]\n  (let [gcd (fn [x y]\n              (if (= 0 y) x (recur y (mod x y))))]\n    (->> n inc (range 1) (filter #(= 1 (gcd n %))) count)))","user":"5416b4a2e4b01498b1a71a01"},{"problem":75,"code":"#(let [gcd (fn [a b]\n        \t  (if (zero? b)\n          \t\ta\n                (recur b (mod a b))))\n       wrap (fn [c]\n              (if (= (gcd c %) 1)\n              \t1\n              \t0))\n       ]\n   (apply + (map wrap (range %)))\n)","user":"59496129e4b07ddc2dafadd7"},{"code":"(fn totient [x]\n  (letfn [(gcd [a b]\n               (if (zero? b)\n                 a\n                 (gcd b (mod a b))))\n          (coprime? [a b]\n            (= (gcd a b) 1))]\n         (if (= x 1)\n           1\n           (count (filter (partial coprime? x) (range 1 x))))))","problem":75,"user":"50e87427e4b0ebbe794eb7e8"},{"problem":75,"code":"(fn [x]\n  (if (= 1 x)\n    1\n    (letfn [(gcd [x y]\n              (cond\n                (= x y) x\n                (< x y) (recur x (- y x))\n                (> x y) (recur (- x y) y)))]\n      (->> (range 1 x)\n           (filter #(= 1 (gcd x %)))\n           count))))","user":"51ae350fe4b09397d5109790"},{"problem":75,"code":"(fn [n]\n    (let [gcd      #(loop [a %1 b %2]\n                      (let [r (rem a b)]\n                        (if (= r 0) b\n                            (recur b r))))\n          pos-lt    #(range 1 (inc %))\n          co-prime? #(= (gcd % n) 1)]\n      (count (filter co-prime? (pos-lt n)))))","user":"5e38a9cbe4b01d43a70e8dc2"},{"problem":75,"code":"(fn [n]\n  (letfn [(div [x y d] (if (and (= 0 (mod x d)) (= 0 (mod y d))) d 1))\n          (gcd [a b] (letfn [] (apply max (map #(div a b %) (range 1 (inc a))))))]\n    (if (= 1 n) 1 (count (filter #(= (gcd n %) 1) (range 1 n))))))","user":"583048d9e4b051871117c007"},{"problem":75,"code":"(letfn [(mcd [x y] (if (zero? y) x (recur y (mod x y))))\n        (coprime? [x y] (= 1 (mcd x y)))]\n  \n  (fn totient [x]\n    (if (= 1 x)\n      1\n      (count (filter (partial coprime? x) \n                     (drop 1 (range x)))))))","user":"54857e3be4b0e286459a11ad"},{"problem":75,"code":"(fn [max]\n   (when (= 1 max) 1)\n   (letfn [(gcd [x y] (if (= y 0) x (recur y (mod x y))))]\n     (count (filter #(= 1 (gcd max %)) (range max)))\n     )\n   )","user":"546280d8e4b01be26fd746b0"},{"problem":75,"code":"#(letfn [(gcd [m n]\n              (if (> n m)\n                (gcd n m)\n                (if (< n 1)\n                  m\n                  (gcd n\n                       (rem m n)))))]\n   (if (= % 1)\n     1\n     (count (filter (fn [x] (= (gcd x %) 1))\n                    (range 1 %)))))","user":"506ef8c3e4b09350ab4199f4"},{"problem":75,"code":"(fn [n]\n    (if (= n 1)\n      1\n      (let [psieve (fn [n]\n                     (loop [s (set (range 2 (inc n))) p []]\n                       (if (empty? s)\n                         p\n                         (let [p0 (apply min s)]\n                           (recur\n                             (apply disj s (range p0 (inc n) p0))\n                             (conj p p0)))))) ]\n        (apply\n          *\n          n\n          (map\n            #(- 1 (/ 1 %))\n            (loop [primes (psieve (inc (int (Math/sqrt n))))\n                   factors []\n                   cur n]\n              (let [p (first primes)]\n                (if (or (empty? primes) (> (* p p) cur))\n                  (if (> cur 1)\n                    (conj factors cur)\n                    factors)\n                  (let [p (first primes)]\n                    (recur\n                      (rest primes)\n                      (if (= (mod n p) 0)\n                        (conj factors p)\n                        factors)\n                      (loop [c cur]\n                        (if (not= (mod c p) 0)\n                          c\n                          (recur (/ c p))))))))))))))","user":"553abb28e4b09218d5f44ffb"},{"code":"(fn [n]\n  (if (> n 1)\n (count (letfn [(p [a b] (loop [n a m b] (if (= 0 m) n (recur m (mod n m)))))]\n  (filter #(= 1 (p % n)) (range 1 n)))) 1))","problem":75,"user":"4ebb78a2535dfed6da9c6d70"},{"code":"(fn [n]\n  (if (= 1 n) 1\n    (letfn [(gcd [a b] (if (= 0 b) a (gcd b (rem a b))))]\n      (count (filter #(= 1 (gcd % n)) (range 1 n))))))","problem":75,"user":"500854c4e4b028e089d3518c"},{"code":"#(count (for [x (range %) :when (not-any? (fn [i] (= 0 (mod % i) (mod x i))) (range 2 %))] x))","problem":75,"user":"4ef77edb535dced4c769f254"},{"code":"(fn [x] (count (filter #(= 1 ((fn g [a b] (if (zero? b) a (g b (mod a b)))) x %)) (range x))))","problem":75,"user":"4eb13d60535d7eef3080733f"},{"code":"(fn totient [n]\n (letfn [(gcd [a b]\n  (if (zero? b) a\n   (recur b (mod a b))))]\n (if (= n 1) 1\n  (count (filter #(= 1 (gcd n %)) (range n))))))","problem":75,"user":"4fbd12a5e4b081705acca2fd"},{"code":"(fn [n]\n  (let [get-gcd \n    (fn [a b]\n      (loop [x a y b]\n        (if (= y 0) x\n          (recur y (mod x y)))))]\n    (if (= 1 n) 1\n      (count\n        (filter #(= 1 (get-gcd n %)) (range 1 n))))))","problem":75,"user":"4dad76588e77d6ed63f12a44"},{"problem":75,"code":"(fn [n]\n  (letfn [(gcd [a b]\n            (loop [[a b] (if (> a b) [a b] [b a])]\n              (let [c (rem a b)]\n                (if (= 0 c)\n                  b\n                  (recur [b c])))))]\n    (count (filter (fn [x] (= 1 (gcd x n))) (range 1 (inc n))))))","user":"58bb218be4b0888cdc949cf4"},{"problem":75,"code":"(fn [n] (\n\n->> (range n)\n\n    (map (fn gcd ([x] (gcd n x))\n\n             ([a b] (if (= b 0) a (gcd b (mod a b))))))\n\n    (filter #(= 1 %))\n\n    (count)\n\n))","user":"5fab7ea6e4b08cb800c85ad8"},{"code":"(fn [n]\n    (letfn [(gcd [a b]\n              (first\n               (filter (fn [n] (and (= 0 (mod b n)) (= 0 (mod a n))))\n                       (let [d (max a b)]\n                         (range (/ (if (odd? d) (inc d) d) 2) 0 -1 )))))]\n      (count (filter #(= 1 (gcd n %)) (range n)))))","problem":75,"user":"4f3ec266e4b0e243712b1f8c"},{"problem":75,"code":"(fn [n]\n  (letfn\n    [(gcd [m n] (if (= m 0) n (recur (mod n m) m)))]\n    (count (filter #(= 1 (gcd %1 n)) (range 1 (inc n))))))","user":"567b39b6e4b05957ce8c61a3"},{"problem":75,"code":"(fn [n]\n    (let [gcd (fn [a b]\n                (if (zero? b)\n                  a\n                  (recur b (mod a b))))]\n      (count (filter #(= 1 (gcd n %)) (range n)))))","user":"53716539e4b0fc7073fd6eb1"},{"problem":75,"code":"(fn [n]\n         (if (= n 1) 1\n             (let [gcd (fn [a b] (cond (= a b) a\n                                       (= a 0) b\n                                       (= b 0) a\n                                       (> a b) (recur (- a b) b)\n                                       :else (recur  b (-  b a))))]\n               (reduce #(if (= (gcd %2 n) 1) (inc %1) %1) 0 (range 1 n)))))","user":"5d0cf1c8e4b0cc9c91588246"},{"problem":75,"code":"(fn totient-4clojure [x]\n  (letfn [(divisors [x]\n            (->>\n              (range 1 (inc x))\n              (filter #(= 0 (rem x %)))\n              (into #{})))\n          (gcd [x y]\n            (let [a (divisors x)\n                  b (divisors y)]\n                  (->>\n                    (clojure.set/intersection a b)\n                    (apply max))))\n          (coprime? [x y]\n            (= 1 (gcd x y)))]\n            (if (= 1 x)\n                x\n                (->>\n                  (range 1 x)\n                  (filter #(coprime? x %))\n                  count))))","user":"5b15811ee4b0cc2b61a3be6f"},{"problem":75,"code":"(fn [x]\n  (if (= x 1)\n    1\n    (count\n     (filter\n       (fn [y]\n         (= 1 (#(if (= (mod %1 %2) 0) %2 (recur %2 (mod %1 %2))) x y)))\n       (range 1 x)))))","user":"54397533e4b032a45b86931d"},{"problem":75,"code":"(fn [n]\n  (if (= 1 n)\n    1\n    (let [gcd #(if (= %2 0) %1 (recur %2 (mod %1 %2)))]\n      (count (filter #(= 1 (gcd n %)) (reverse (range 1 n)))))))","user":"54246fcce4b01498b1a71aed"},{"problem":75,"code":"(fn euler-totient-fn [x]\n  (letfn [(gcd [a b]\n            (if (zero? b) a\n              (gcd b (rem a b))))\n          (coprime? [x y]\n            (= 1 (gcd x y)))]\n    (count \n       (reduce \n          (fn [acc each]\n            (if (coprime? x each)\n              (conj acc each)\n              acc))\n          [] (range 1 (inc x))))))","user":"5553b729e4b0deb715856e05"},{"problem":75,"code":"(fn euler[n]\n  (if (= 1 n)\n    1\n    (letfn [( pgcd [a b]\n            (if (zero? a)\n              b\n              (recur (mod b a) a)) )]\n              \n              (->> n (range 1) (filter #(= 1 (pgcd n %))) (count))\n              )))","user":"5626447fe4b00e49c7cb47bd"},{"problem":75,"code":"(fn [n]\n             (let [coprime (fn [a b] (= 1 (apply max (map #(if (= 0 (mod a %) (mod b %)) % 0) (map inc (range a))))))]\n               (inc (count (filter #(coprime % n) (range 2 n))))))","user":"565b2fa5e4b068f2fe63dbfe"},{"code":"#(count (filter (fn [a]\r\n           (every? pos?\r\n             (map (fn [k]\r\n                    (+ (mod a k) (mod % k)))\r\n               (range 2 %))))\r\n   (range %)))","problem":75,"user":"4ed69ea4535d10e5ff6f52e3"},{"problem":75,"code":"(fn [x]\n  (if (= 1 x)\n    1\n    (let [gcd (fn gcd [a b]\n                (if (zero? b) a (recur b (mod a b))))]\n      (count (filter #(= 1 (gcd x %)) (range x))))))","user":"50ef4e2be4b0a78662fa2653"},{"problem":75,"code":"(fn __\n  [x]\n  (let [gcd (fn gcd [x y]\n              (if (> x y)\n                (gcd y x)\n                (if (zero? x)\n                  y\n                  (gcd (rem y x) x))))]\n    (count\n      (filter #(= 1 (gcd % x)) (range 1 (max 2 x))))))","user":"5ac91d90e4b0e27600da77bd"},{"code":"#(letfn [(g [a b](if (= 0 b) (= 1 a) (g b (mod a b))))] (count (filter (fn[x] (g x %)) (range %))))","problem":75,"user":"4f296a80e4b0d6649770a02a"},{"code":"(fn [x]\n  (letfn [(gcd [x y]\n               (cond (= x y) x\n                     (> x y) (recur (- x y) x)\n                     :else (recur x (- y x))))]\n    (->> (for [i (range x)]\n           (if (= 1 (gcd x i)) i))\n         (filter #(not (nil? %)))\n         count)))","problem":75,"user":"530cb5b8e4b02e82168697e0"},{"code":"(fn [n]\n(let [gcd (fn [a b] (apply max (filter #(= 0 (rem b %) (rem a %)) (range 1 (inc (max a b))))))]\n     (count (filter #(= (gcd % n) 1) (range 1 (inc n))))))","problem":75,"user":"4f039bbe535dcb61093f6b39"},{"problem":75,"code":"(fn [n]\n  (if (= n 1 )\n    1\n    (let [s (nnext (range n))\n          d (filter #(= 0 (mod n %)) s)\n          x (into #{} (mapcat (fn [e] (filter #(= 0 (mod % e)) s)) d))]\n      (inc (count (filter #(not (x %)) s))))))","user":"57c94c54e4b05aa3c4741d2c"},{"problem":75,"code":"(fn [x] (+ 1 (count (filter #(let [r (/ x %)] (or (= 1 %) (and (ratio? r) (= % (denominator r))))) (range 2 x)))))","user":"5137c3b0e4b0509a8b470482"},{"code":"#(letfn [(gcd [x1 x2]\r\n          (cond\r\n           (= x1 x2) x2\r\n           (< x1 x2) (recur x2 x1)\r\n           (= x2 0) x1\r\n           :else (recur (- x1 x2) x2)))]\r\n  (if (= % 1) 1\r\n      (apply + (map (fn [x] (if (= (gcd x %) 1) 1 0)) (range 1 %)))))","problem":75,"user":"4f474f43e4b0d56e7bb92bb7"},{"problem":75,"code":"(fn [n]\n  (let [gcd (fn [a b] (if (zero? b) a (recur b (rem a b))))]\n    (count (filter #(= 1 (gcd n %)) (range 1 (inc n))))))","user":"554b8572e4b0a04f79299589"},{"problem":75,"code":"(fn totient [x]\n  (letfn [(gcd [a b]\n            (cond\n              (= 0 a) b\n              (= 0 b) a\n              :else (gcd b (rem a b))))]\n    (if (= x 1)\n      1\n      (count (filter #(= 1 (gcd % x)) (range x))))))","user":"5ca14eb1e4b048ec896c5b7d"},{"code":"(fn [n]\n  (letfn [(g [a b]\n          (if (or (= a b) (= b 0))\n            a\n            (recur b (mod a b))))]\n    (if (= n 1) 1\n     (reduce #(if (= (g n %2) 1) (inc %) %) 0 (range 1 n)))))","problem":75,"user":"4ee4f4a9535d1385b2869d85"},{"code":"(fn [x]                                                      \n  (letfn [(gdc [a b] (if (zero? b) a (recur b (mod a b))))\n          (coprime? [a b] (= 1 (gdc a b)))]\n    (if (= 1 x) 1\n      (count (filter #(coprime? x %) (range 1 x))))))","problem":75,"user":"4f9d8083e4b0dcca54ed6d23"},{"code":"(fn [x]\n  (if (= 1 x)\n  \t1\n\t(count \n\t  (filter \n\t  \t#(= (if (ratio? (/ % x)) (/ % (numerator (/ % x))) (min % x)) 1) \n\t  \t(range 1 x)))))","problem":75,"user":"52016690e4b0b2e020a18f0f"},{"problem":75,"code":"(fn [x] (if (= x 1) \n         1 \n         (count (filter #(= % 1) (map (partial \n                                      (fn mygcd [a b] (let [zb (mod a b)] (if (= zb 0) b (mygcd b zb)))) x) \n                                                (range 1 x))))))","user":"5576e78de4b05c286339e075"},{"problem":75,"code":"(fn a [n]\n  (let [gcd (fn gcd1 [a b]\n  \t\t\t\t(if (= b 0)\n    \t\t\t\ta\n    \t\t\t\t(recur b (mod a b))))]\n    (if (= n 1) 1\n  \t(count (filter #(= 1 (gcd n %)) (range 1 n))))\n  \t)  \n)","user":"5fe09d1fe4b05ac5b16ea15b"},{"problem":75,"code":"(fn [n] (->> (range 2 n) (filter #(not= 0 (mod n %)))\n        (filter (fn [v] (= 1 (#(loop [a (max %1 %2) b (min %1 %2)]\n    (cond\n      (= 0 (mod a b)) b\n      (= 1 (mod a b)) 1\n      :else (recur b (mod a b))                   \n)) n v)\n        )))   (cons 1) count\n ))","user":"55adf4d7e4b03311e7b732af"},{"problem":75,"code":"(fn [x]\n  (letfn [(abc [n1 n2]\n            (if \n              (= 0 n1) (if (= 1 n2)  true false)\n              (recur (mod n2 n1) n1)))]\n      (loop [ s (range 2 x) num 1]\n        (cond\n           (not (first s)) num\n           (abc (first s) x) (recur (next s) (inc num))\n           :else  (recur (next s) num))))\n  )","user":"5dc12b0ae4b0e59a23173d84"},{"problem":75,"code":"(fn totient [x]\n  (letfn [(gcd [x y]\n  \t\t\t(if (= y 0) x (recur y (rem x y))))]\n    (if (= x 1) 1 (count (filter #(= 1 (gcd x %)) (range 1 x))))))","user":"53b39d82e4b047364c0444a6"},{"code":"(fn [x]\n  (let [gcd (fn [a b]\n              (cond\n               (= b 0) a\n               (= a 0) b\n               (> a b) (recur b (mod a b))\n               :else (recur a (mod b a))))\n        coprime? #(= (gcd % x) 1)]\n    (if (= 1 x) 1\n        (count (filter coprime? (range 1 x))))))","problem":75,"user":"50705072e4b07bd6ad9b9f27"},{"code":"(fn euler-totient-count [num]\n  (letfn [(gcd [n1 n2]\n               (let[nmax (max n1 n2) nmin (min n1 n2) remd (rem nmax nmin) ]\n                 (if (= 0 remd)\n                   nmin\n                   (gcd  nmin remd))))\n          (euler-totient? [n]\n                          (if (= 1 (gcd num n))\n                            true\n                            false))]\n    (count (filter euler-totient? (range 1 (inc num))))\n    ))","problem":75,"user":"51696bcde4b03f62cda68ce7"},{"problem":75,"code":"(fn totient [x]\n   (letfn [(gcd [a b] (if (zero? b) a (recur b (mod a b))))]\n     (if (= 1 x)\n       1\n       (count (filter #(= 1 (gcd x %)) (range 1 x))))))","user":"535eaa73e4b04ce2eb3ed2d4"},{"code":"(fn totient [x]\n  (if (= x 1)\n    1\n    (count \n      (filter #(= 1 ((fn gcd [a b] (if (zero? b) a (recur b (mod a b)))) x %))\n        (range 1 x)\n      )       \n    )\n  ) \n)","problem":75,"user":"5176afd2e4b085adf681d889"},{"problem":75,"code":"(let [gcd (fn [x y] (if (zero? y) x (recur y (mod x y))))\n      coprime? (fn [x y] (= 1 (gcd x y)))]\n  (fn [x] (if (= 1 x) \n            1\n            (-> (partial coprime? x)\n                (filter (range 1 x))\n                (count)))))","user":"530b8580e4b02e82168697cc"},{"problem":75,"code":"(fn [n]\n  (if (= n 1) 1 (count (filter\n    (fn is-coprime [x]\n      (not\n        (some\n          (fn [div]\n            (and (= (rem x div) 0) (= (rem n div) 0)))\n          (range 2 (inc x)))))\n    (range 1 n)))))","user":"5c73b8bae4b0fca0c16227ba"},{"code":"(fn totient [x]\n  (letfn [(gcd [a b] (first (filter (fn [x] (= 0 (rem a x) (rem b x))) (range (min a b) 0 -1))))]\n    (inc (count (filter (fn [r] (= 1 (gcd r x))) (range 2 x))))))","problem":75,"user":"51672d15e4b079759a74a5e7"},{"code":"(fn totient [n]\n\t(letfn [(gcd [a b]\n\t\t\t  (if (= a b)\n\t\t\t\t   a\n\t\t\t\t  (if (> a b)\n\t\t\t\t\t  (gcd (- a b) b)\n\t\t\t\t\t  (gcd a (- b a))\n\t\t\t\t   )\n\t\t\t   )\n\t\t)] \n\t\t(if (= n 1)\n\t\t    1\n\t\t\t(count (filter #(= 1 (gcd n %))  (range 1 n)))\n\t\t)\n\t)\n )","problem":75,"user":"52763696e4b03e8d9a4a74d7"},{"problem":75,"code":"(fn eulers-totient [n]\r\n  (letfn [(gcd [a b]\r\n            (letfn [(gcd- [a b]\r\n                      (if (= b 0)\r\n                        a\r\n                        (gcd- b (mod a b))))]\r\n              (gcd- (max a b) (min a b))))\r\n          (co-prime? [a b]\r\n            (= 1 (gcd a b)))]\r\n    (cond\r\n      (= 1 n) 1\r\n      :else (count (filter (partial co-prime? n) (range 1 n))))))","user":"580e7761e4b0849f6811b753"},{"problem":75,"code":"(fn fx [x]\n  (->> (range 1 (inc x))\n       (filter (fn cop? [each]\n                 (loop [mx (max x each)\n                       mn (min x each)\n                       delta (- mx mn)]\n                   (if (= 0 delta)\n                     (if (= mn 1) true false)\n                     (let [newMx (max mn delta)\n                           newMn (min mn delta)]\n                       (recur newMx newMn (- newMx newMn)))\n                     ))))\n       (count)))","user":"563f2eaae4b08d4f616f5ed1"},{"problem":75,"code":"(fn [x] (if (= 1 x) 1 (count (filter (fn [y] (empty? (filter (fn [z] (and (= 0 (mod x z)) (= 0 (mod y z)))) (range 2 (+ y 1))))) (range 1 x)))))","user":"52c1f404e4b07a9af5792370"},{"problem":75,"code":"(fn [a]\n  (letfn [(gcd [a b]\n            (let [c (rem a b)]\n              (if (zero? c) b (recur b c))))]\n    (if (= a 1)\n      1\n      (->> (filter #(= (gcd a %) 1) (range 1 a))\n           (count)))))","user":"5455c2f3e4b080a794c2c87d"},{"problem":75,"code":"(fn\n  [n]\n  (if (= n 1)\n    1\n    (letfn [(gcd [a b] (if (= 0 b)\n                         a\n                         (gcd b (mod a b))))]\n      (count (filter #(= 1 (gcd n %))\n              (range 1 n))))))","user":"5893c64ce4b00487982d524b"},{"code":"(fn [n]\r\n          (let [coprime? (fn [a b]\r\n                           (if (= b 0)\r\n                             (= a 1)\r\n                             (recur b (rem a b))))]\r\n            ((frequencies (map coprime? (range n) (repeat n))) true)))","problem":75,"user":"4e8768f6535dceadca469850"},{"code":"(fn [x]\n  (let [GCD (fn [aa bb] (loop [a aa b bb] (if (zero? b) a (recur b (mod a b)))))]\n      (reduce #(if (= (GCD x %2) 1) (inc %1) %1) 0 (range 1 (inc x)))))","problem":75,"user":"50a5f72fe4b0aa96157e2611"},{"problem":75,"code":"(fn [x]\n  (letfn [(gcd [a b] (if (zero? b) a (recur b (rem a b))))]\n    (->> (if (= x 1) 2 x)\n         (range 1)\n         (map #(gcd x %))\n         (filter #(= 1 %))\n         (count))))","user":"5ad63a34e4b0ea6055cfac01"},{"code":"(fn[x]\n  (letfn [(gcd[x y] (if (zero? y) x (recur y (mod x y))))]    \n    (count (filter #(= 1 (gcd x %)) (range 0 x)))))","problem":75,"user":"506406c8e4b075d771da6f9f"},{"problem":75,"code":"(fn [x]\n  (if (not= x 1)\n    (let [div (fn [y] (conj (set (filter #(= 0 (rem y %)) (range 1 y))) y))\n          d (div x)]\n      (count  (filter #(= #{1} (clojure.set/intersection d (div %))) (range 1 x))))\n    x))","user":"53d5a63be4b0e771c3025449"},{"problem":75,"code":"(fn [n]\n  (if (= n 1)\n    1\n  \t(let [nums     (range 1 n)\n    \t  divs     (fn [n] (filter #(= (mod n %) 0) (range 1 n)))\n          n-divs   (set (divs n))\n          compact  (fn [coll] (remove nil? coll))\n          co-divs  (fn [n] (compact (map n-divs (divs n)))) ]\n                     \n      (count (filter #(= 1 %) (map #(reduce max (co-divs %)) (range 2 (- n 1))))))))","user":"54814dbee4b0e286459a116b"},{"problem":75,"code":"#(letfn\n   [(gcd [a b] (if (zero? b) a (recur b (mod a b))))]\n   (count (for [x (range %) :when (= (gcd x %) 1)] x)))","user":"5cebafbbe4b0a17bb84e2be6"},{"problem":75,"code":"(fn euler-totent [x]\n  (letfn [(gcd [x y] \n          (if (= y 0) x\n              (recur y (mod x y))))]\n   (->> x\n        (range)\n        (filter #(= 1 (gcd x %)))\n        (count))))","user":"56fa2905e4b07572ad1a88be"},{"problem":75,"code":"(fn [x]\n  (if (= x 1) 1\n    (letfn [(gcd [a b]\n                 (if (zero? b) a\n                   (recur b (mod a b))))]\n      (->> (range 1 x)\n           (filter #(= 1 (gcd % x)))\n           (count)))))","user":"54c271b9e4b045293a27f602"},{"problem":75,"code":"(fn totient\n  [num]\n  (let [gcd (fn gcd\n              [a b]\n              (let [small (min a b)\n                    large (max a b)]\n                (if (= 0 (mod large small))\n                  small\n                  (gcd small (rem large small))))\n              )\n        co-prime? (fn [a b] (= 1 (gcd a b)))]\n    (count (filter (partial co-prime? num) (range 1 (inc num)))))\n  )","user":"5f29837ee4b033932238a64f"},{"code":"(fn eulers-totient [n]\r\n  (letfn [(gcd [x y] (if (zero? y) x (recur y (rem x y))))]\r\n    (count (filter #(= 1 (gcd n %)) (range n 0 -1)))))","problem":75,"user":"4dd7d040535d2dad7130b5d6"},{"problem":75,"code":"(fn [x]\n (let [gcd (fn [a b]\n            (apply max (for [d (range 1 (inc (min a b)))\n                :when (= 0 (mod a d) (mod b d))]\n                d)))]\n  (if (= x 1)\n   \t\t1 \n  (->> (range 1 x)\n       (map (partial gcd x))\n       (filter (partial = 1))\n       (count)))\n))","user":"5a66fddee4b0512ff01cd9d7"},{"problem":75,"code":"(fn [n]\n    (let [gcd (fn [m n]\n                (cond\n                  (= 0 m) n\n                  (= 0 n) m\n                  (< m n) (recur m (rem n m))\n                  :else (recur n (rem m n))))]\n      (if (= 1 n) 1\n          (count (for [x (range n) :when (= 1 (gcd x n))] x)))))","user":"595bbab7e4b066ee0a44afe0"},{"code":"(fn [x]\n  (let [gcd (fn [a b]\n              (if (zero? b)\n                a\n                (recur b (mod a b))))]\n    (count (filter #(= 1 (gcd % x)) (range x)))))","problem":75,"user":"4e6ebd4a535d5021c1a89610"},{"problem":75,"code":"(fn [n]\n  (if (= n 1)\n    1\n    (letfn [(g [a b] (if (= a b)\n                       a\n                       (if (> a b)\n                         (g (- a b) b)\n                         (g b a))))]\n      (count (filter #(= 1 (g n %)) (next (range n)))))))","user":"5742ec91e4b05c31a32c0883"},{"code":"(fn [n]\n  (if (= n 1)\n    1\n    (let [divs (fn [x] (set (filter #(not (nil? %)) (for [i (range 1 (inc x))] (if (= (rem x i) 0) i nil)))))\n          ndivs (divs n)]\n      (count (filter #(= (clojure.set/intersection (divs %) ndivs) #{1})  (range 1 n)))\n      )))","problem":75,"user":"50bce014e4b0594b91591c63"},{"code":"(fn [x] (letfn [(f1 [x]\n                  (if (= x 1)\n                    []\n                    (let [a (filter #(zero? (mod x %)) (range 2 x))\n                          b (if (empty? a) x (apply min a))]\n                      (lazy-cat [b] (f1 (/ x b))))))]\n          (* x\n            (apply *\n                   (map #(- 1 (/ 1 %))\n                        (distinct (f1 x)))))))","problem":75,"user":"529b44afe4b02ebb4ef7509d"},{"problem":75,"code":"(fn totient [x]\n  (letfn [(gcd [a b] (if (zero? b) a (recur b (mod a b))))\n          (coprime? [a b] (= 1 (gcd a b)))]\n\t(if (= 1 x)\n      1\n      (->> (range 1 x) (filter #(coprime? % x)) count))))","user":"4dac39a28cc9d6edb8beb0b3"},{"problem":75,"code":"(fn totient [n]\n  (if (= n 1)\n    1\n    (let [pgcd\n          (fn [a b]\n            (loop [small (if (< a b) a b)\n                   big (if (> a b) a b)]\n              (if (= small 0)\n                big\n                (recur (mod big small) small))))]\n      (loop [i (rest (range n))\n             tot 0]\n        (if (seq i)\n          (recur (rest i)\n                 (if (= (pgcd (first i) n) 1) (+ tot 1) tot))\n          tot)))))","user":"5a6b9b95e4b0512ff01cda40"},{"problem":75,"code":"(fn [n]\n    (letfn [(get-gcd [x y]\n              (if (zero? y)\n                x\n                (recur y (mod x y))))]\n      (if (= 1 n)\n        1\n        (->> (range 1 n)\n             (filter #(= (get-gcd % n) 1))\n             (count)\n             ))))","user":"591ad160e4b09b4ee5954bdf"},{"problem":75,"code":"(fn [n]\n  (if (= n 1) 1\n    (letfn [(coprime? [a b]\n                      (if (= a 1) true\n                        (if (> a b) (coprime? [b a])\n                          (not (some #(= 0 (rem a %) (rem b %)) (range 2 (inc  a)))))))]\n      (count (filter #(coprime? % n) (range 1 n))))))","user":"5746061ae4b009280f9f2b5b"},{"code":"(fn [n]\n  (if (= n 1)\n1\n(letfn [(gcd [x y] (if (zero? y) x (recur y (mod x y))))]\n(count (filter #(= (gcd n %) 1) (range n))))))","problem":75,"user":"4fca2a13e4b0ee37620e184d"},{"code":"(fn [x]\n  (let [gcd (fn [x y] (if (zero? y) x (recur y (mod x y))))]\n    (count (filter #(= 1 (gcd x %)) (range x)))))","problem":75,"user":"531f7a2de4b08068f379edc6"},{"problem":75,"code":"(fn [x]\n  (letfn [(gcd [a b] (if (zero? b) a (gcd b (mod a b))))]\n    (count (filter #(= (gcd x %) 1) (range 1 (inc x))))))","user":"5db92996e4b010eb3c36cd50"},{"code":"(fn totient [num]\n  (letfn [(gcd [a b]\n            (let [divisor (min a b) dividend (max a b) remainder (rem dividend divisor)]\n              (if (zero? remainder)\n                divisor\n        \t(gcd remainder divisor))))]\n    (count (filter #(= 1 %) (map (partial gcd num) (range 1 (inc num)))))))","problem":75,"user":"4e95a440535dbda64a6f6b37"},{"problem":75,"code":"(fn [x] (let [n-range (range 1 (inc x)) div-fn (fn [y] (filter #(= 0 (rem y %)) n-range)) divs (into #{} (div-fn x))] (count (filter #(= #{1} (clojure.set/intersection divs (into #{} (div-fn %)))) n-range))))","user":"51bfc1f0e4b0e49ef9037dd4"},{"code":"(fn totient [n]\n  (letfn [(gcd [a b]\n            (if (zero? b)\n                a\n                (gcd b (mod a b))))]\n    (if (= n 1) \n        1\n        (reduce +\n          (map\n            #(if (= 1 (gcd % n)) 1 0)\n            (range 1 n))))))","problem":75,"user":"5002b6e5e4b0678c553fc42c"},{"problem":75,"code":"(fn [n]\n  (let [sqrt #(bit-shift-right % 1)\n        divides? #(= 0 (mod %1 %2))\n        range-sqrt #(range 2 (inc (sqrt %)))\n        divisors #(->> (range-sqrt %)\n                       (filter (partial divides? %)))]\n    (->> (range-sqrt n)\n         (filter (comp empty? divisors))\n         (filter (partial divides? n))\n         (reduce #(* %1 (- 1 (/ 1.0 %2))) 1)\n         (* n)\n         (int))))","user":"523b4e91e4b07becd5be21ef"},{"code":"(fn totient-function\n  [x]\n  (cond\n   (= 1 x) 1\n   :else\n   (let [gcd (fn [x y]\n               (first (sort > (filter #(and (zero? (mod x %))\n                                            (zero? (mod y %))) (range 1 (inc (min x y)))))))]\n     (count (filter #(= (gcd x %) 1) (range 1 x))))))","problem":75,"user":"4fd16778e4b04c3a95aa040f"},{"code":"(fn [n] (if (= 1 n) 1 (let [d (loop [n n k 2 s #{}]\r\n (if (= n 1) s (if (zero? (mod n k))\r\n  (recur (/ n k) k (conj s k)) (recur n (inc k) s))))] \r\n   (count (remove #(some (fn [x] (zero? (mod % x))) d) (range 1 n))))))","problem":75,"user":"4fca2ef0e4b0ee37620e184e"},{"problem":75,"code":"(fn [x]\n   (let [cp? (fn [a b] (not-any? #(and (= 0 (mod b %1)) (= 0 (mod a %1)))\n                                 (range 2 (inc b))))]\n     (inc (count (filter (partial cp? x) (range 2 x))))))","user":"5910a43de4b0163c97b36ebf"},{"problem":75,"code":"(fn [n]\n  (if (= n 1) \n    1\n    (let [gcd (fn [x y] (if (= y 0) x (recur y (mod x y))))]\n      (count (filter #(= (gcd n %) 1) (range n))))))","user":"5392bfdee4b0b51d73faaeb2"},{"problem":75,"code":"(fn [n]\n  (let [gcd (fn [a b] (if (zero? b) a (recur b (mod a b))))\n        coprime? (fn [x] (= 1 (gcd n x)))]\n    (count (filter coprime? (range n)))))","user":"57283dbce4b0c5bde472c154"},{"problem":75,"code":"(fn [n]\n    (letfn [(gcd [x y] (if (= y 0) x (gcd y (mod x y))))]\n      (->> (range 1 (max n 2))\n           (filter #(= 1 (gcd n %)))\n           (count))))","user":"5782018de4b0d36ec5835e8e"},{"problem":75,"code":"(fn totient [n]\n  (letfn [(gcd [a b] (cond\n                       (< a b) (recur b a)\n                       (zero? b) a\n                       :else (recur b (rem a b))))]\n    (count (filter\n            #(= 1 (gcd n %))\n            (range 1 (inc n))))))","user":"5617a540e4b06b1bb2182a12"},{"problem":75,"code":"(fn totient\n  [n]\n  (letfn [(gcd [a b]\n            (if (= b 0) a (gcd b (mod a b))))\n          (coprime? [a b]\n            (= 1 (gcd a b)))\n          (coprimes [n]\n            (filter (partial coprime? n) (range 1 n)))]\n    (if (= n 1) 1\n        (count (coprimes n)))))","user":"5c222b7de4b07e362c230588"},{"problem":75,"code":"#(letfn [(g [a b] (if (zero? b) a (recur b (mod a b)))) (p [x] (= 1 (g % x)))] (count (filter p (range 1 (inc %)))))","user":"52ae886de4b0c58976d9acab"},{"code":"(fn [n] (let [gcd (fn [a b] (if (= b 0) a (recur b (rem a b))))]\n             (if (= n 1) 1 (count (filter #(= 1 (gcd % n)) (range 1 n))))))","problem":75,"user":"4ebef65e535dfed6da9c6d9b"},{"problem":75,"code":"(fn [n]\n  (if (= n 1)\n    1\n    (count\n     (filter identity\n             (map (partial (fn [x y]\n                             (if (> x y)\n                               (recur y x)\n                               (if (zero? x)\n                                 (= y 1)\n                                 (recur (mod y x) x)))) n)\n                  (range 1 n))))))","user":"54c5cc17e4b045293a27f624"},{"problem":75,"code":"(fn [n]\n  (if (= 1 n)\n    1\n    (let [gcd (fn [a b] (if (zero? b) a (recur b (mod a b))))]\n      (count (filter #{1} (map (partial gcd n) (range 1 n)))))))","user":"573632b7e4b0cd1946bd102f"},{"problem":75,"code":"(fn totient [x]\n (if (= 1 x)\n   1\n   (letfn [\n    (does-div [x d] (zero? (mod x d)))\n    (coprime [x y] (not (some #(and (does-div x %) (does-div y %)) (range 2 (inc y)))))]\n    (count (filter #(coprime x %) (range 1 x))))))","user":"54e345a1e4b024c67c0cf7db"},{"problem":75,"code":"(fn etf [x]\n  (if (= 1 x)\n    x\n    (letfn\n     [(gcd [n m]\n           (if (= 0 (rem n m))\n             m\n             (recur m (rem n m))))]\n     (count\n      (filter #(= 1 (gcd x %)) (range 1 x))))))","user":"540c54a7e4b0addc1aec6700"},{"code":"(fn [num]\n  (if (= 1 num)\n    1\n    (let [divisor? (fn [a b] (zero? (mod a b)))]\n      (->>\n        (map\n          (fn [a b]\n            (apply max\n              (filter\n                #(and (divisor? a %) (divisor? b %))\n                (range 1 (inc (min a b))))))\n          (range 1 num) (repeat num))\n        (filter (partial = 1))\n        (count)))))","problem":75,"user":"4e68c434535d8ccf87e9fe89"},{"problem":75,"code":"(fn [n]\n  (letfn [(gcd [a b]\n            (cond\n             (= a b) a\n             (> a b) (recur (- a b) b)\n             (< a b) (recur a (- b a))))\n          (coprime? [a b] (= 1 (gcd a b)))\n          (totient [x] (count (filter (partial coprime? x) (range 1 x))))]\n    (if (= 1 n) 1 (totient n))))","user":"505aa653e4b021387fb89857"},{"problem":75,"code":"(fn totient [n]\n  (letfn [(gcd [a b]\n            (if (= b 0)\n              a\n              (recur b (rem a b))\n            )\n          )]\n    (count \n    \t(for [k (range 1 (inc n))\n    \t      :when (= (gcd n k) 1)]\n        true\n      )\n    )\n  )\n)","user":"5991d2fae4b0866487ed0d68"},{"problem":75,"code":"(fn totient [x]\n  (letfn [(gcd [a b] (if (= b 0) a (gcd b (mod a b))))\n          (coprime? [a b] (= (gcd a b) 1))]\n    (if (= x 1)\n      1\n      (->> (range 1 x)\n           (filter #(coprime? x %))\n           (count)))))","user":"59f78b49e4b0ca45a743a30e"},{"code":"(fn [x]\n  (if (= x 1) 1\n  (letfn [(coprime? [y]\n    (every? #(not (= 0 (rem x %) (rem y %)))\n      (range 2 (inc y))))]\n    (count (filter coprime? (range 1 x))))))","problem":75,"user":"4f6fbb68e4b07046d9f4efeb"},{"code":"(fn [n] (inc (count (filter #(= 1 (.gcd (biginteger %) (biginteger n))) (range 2 n)))))","problem":75,"user":"50d0d4c8e4b00b15ecee976a"},{"problem":75,"code":"(fn totient [x]\n  (if (= x 1)\n    1\n    (letfn [(gcd [a b] (.gcd (biginteger a) (biginteger b)))]\n      (->> (range 1 x)\n           (filter #(= (gcd x %) 1))\n           (count)))))","user":"5b13ba71e4b0cc2b61a3be53"},{"code":"(fn [n]\n  (if (= n 1)\n    1\n    (let [coprime (fn [a b]\n                    (if (= b 0)\n                      (= a 1)\n                      (recur b (mod a b))))]\n      (count (filter #(coprime n %)(range n))))))","problem":75,"user":"534f13b2e4b084c2834f4ac4"},{"code":"(letfn [(gcd [x y]\n  \t\t  (if-not (zero? y) (recur y (mod x y))\n                             x))\n        (non-div-copr [x]\n          (let [one? (partial = 1)\n                coprime? #(one? (gcd x %))]\n            (filter coprime? (range 2 x))))]\n  (fn [x]\n    (+ 1 (count (non-div-copr x)))))","problem":75,"user":"51eadb98e4b0f1f103a0d153"},{"code":"(fn [n]\n  (letfn [(d [x] (set (filter #(= 0 (mod x %)) (range 2 (inc x)))))]\n    (reduce\n     (fn [i s] (if (some #((d n) %) (d s)) \n                 i\n                 (inc i)))\n     1\n     (range 2 n))))","problem":75,"user":"4ec53f8c535d6d7199dd368b"},{"problem":75,"code":"(fn totient [x]\n  (let [gcd #(if (zero? %2) %1 (recur %2 (mod %1 %2)))]\n    (if (= 1 x)\n      1\n      (reduce #(if (= (gcd %2 x) 1)\n               (+ 1 %)\n               %)\n            0\n            (range 1 x)))))","user":"598858d0e4b021a7a535feb5"},{"problem":75,"code":"(fn [x]\n  (letfn [(gcd [a b]\n               (if (zero? b) a (recur b (mod a b))))]\n    (if (= x 1) 1\n      (->> (range 1 x)\n           (filter #(= (gcd % x) 1))\n           count))))","user":"537f4652e4b06839e8705eb1"},{"problem":75,"code":"(fn phi [x]\n   (count (filter #(letfn [(gcd [a b]\n                          (if (zero? a)\n                            b\n                            (gcd (mod b a) a)))]\n              (= 1 (gcd x %)))\n            (range 1 (inc x)))))","user":"55a372f1e4b0acc240e31537"},{"problem":75,"code":"(fn Eulers-totient-function [n]\n  (let [gcd (fn [a b]\n              (cond\n               (= a b) a\n               (> a b) (recur (- a b) b)\n               :else (recur a (- b a)))),\n        coprime? #(= 1 (gcd %1 %2))]\n    (if (= n 1) 1\n      (->>\n       (range 1 n)\n       (filter #(coprime? n %))\n       count))))","user":"567e418fe4b0feffd0d18eb1"},{"code":"(fn [n]\n  (count\n    (filter\n      #((fn f [a b]\n          (if (= 0 b)\n            (= 1 a)\n            (f b (rem a b))))\n        n %)\n      (range n))))","problem":75,"user":"4ee82539535d93acb0a66878"},{"code":"(let \r\n  [gcdfn (fn gcd [a b](if (= b 0) a (gcd b, (mod a b))))\r\n  coprime? (fn[a b](= (gcdfn a b) 1))\r\n  totient (fn[x](if (= x 1) 1 (count \r\n    (filter true? (map \r\n      (fn[y](coprime? x y)) \r\n    (range 1 x))))))]\r\n(fn[x](totient x)))","problem":75,"user":"4ed2dd98535d44c135fd68e2"},{"code":"(fn[n](reduce #(- %(/ % %2))n(distinct(#(if(< % 2)%3(if(zero?(rem % %2))(recur(/ % %2)%2(cons %2 %3))(recur %(inc %2)%3)))n 2[]))))","problem":75,"user":"50ed4626e4b01236b1d4983c"},{"code":"(fn [x]\n  (let [gcd (fn [a b] (if (zero? b) a (recur b (mod a b))))]\n    (if (= 1 x) 1\n      (count (filter #(= 1 (gcd % x)) (range 1 x))))))","problem":75,"user":"50fc299ee4b0d10d794c19f2"},{"code":"(fn [n]\n    (letfn\n        [(h [a b]\n           (first\n            (filter #(= [0 0] (map mod [a b] [% %]))\n             (iterate dec (min a b)))))]\n      (+ 1 (count\n            (filter #(= 1 (h % n)) (range 2 n))))))","problem":75,"user":"4e6f578c535d5021c1a8961b"},{"code":"(fn [n]\n  (if (= 1 n)\n    1\n    (letfn [(g [a b] (if (= b 0) a (g b (rem a b))))]\n      (count (filter #(if (= 1 (g % n)) true false) (range n))))))","problem":75,"user":"4fdf2b50e4b05e33b9224f93"},{"code":"(fn euler [n]\n  (letfn [(divisible? [n d] (zero? (mod n d)))\n          (first-div [n d] (->> (Math/sqrt n)\n                                inc\n                                (range d)\n                                (filter (partial divisible? n))\n                                first))\n          (divisors [n d]\n            (let [f (first-div n d)]\n              (if f\n                (conj (divisors (/ n f) f) f)\n                (list n))))\n          (prime-euler [[f & rest]] (* (dec f) (apply * rest)))]\n    (->> (divisors n 2)\n         (partition-by identity)\n         (map prime-euler)\n         (reduce *)\n         (max 1))))","problem":75,"user":"514c2d05e4b02b8cbb2a9278"},{"problem":75,"code":"(fn [n]\n    (if (= n 1) 1\n      (let [candidatos (fn [m] (range 1 (+ m 1)))\n            elementos-revision (range 1 n)\n            es-divisor? (fn [candidato m] (zero? (mod m candidato)))\n            divisores (fn [m] (set (filter #(es-divisor? % m) (candidatos m))))\n            maximo-comun-divisor (fn [m n] (apply max (clojure.set/intersection (divisores m)\n                                                                                (divisores n))))]\n       (count (filter #(= % 1) (map #(maximo-comun-divisor % n) elementos-revision))))))","user":"5d0153f9e4b0cc9c915881aa"},{"code":"(fn totient [x]\n  (if\n    (= x 1)\n    1\n    (count\n      (filter\n        (fn [y]\n          ((complement some)\n            (fn [z] (= 0 (mod y z) (mod x z)))\n            (range 2 (inc y))))\n        (range 1 x)))))","problem":75,"user":"5201ada5e4b0b2e020a18f14"},{"problem":75,"code":"(fn [x] (count (filter (fn [y] (= 1 (count (filter #(and (= 0 (mod x %)) (= 0 (mod y %))) (map inc (range y)))))) (map inc (range x)))))","user":"53fc8424e4b0de5c418485b3"},{"code":"(fn totient [n]\n  (cond (= n 1) 1\n        :else\n        (let [factors (filter #(= 0 (mod n %)) (range 2 n))\n              relprime? (fn [n]\n                        (every? #(> (mod n %) 0) factors))]\n\n    \t  (count (filter relprime? (range 1 n))))))","problem":75,"user":"4f0d093b535d0136e6c22313"},{"code":"(fn [x]\n  (let [g #(if (= 0 %2) % (recur %2 (mod % %2)))] \n    (condp = x\n      1 1\n      (count (filter #(= (g x %) 1) (range 1 x))))))","problem":75,"user":"4ec74de3535d6d7199dd36df"},{"problem":75,"code":"(fn [x]\n  (let [gcd #(if (zero? %2) % (recur %2 (mod % %2)))]\n    (if (= x 1)\n      1\n      (count (filter #(= 1 (gcd x %)) (range 1 x)))\n    )\n  )\n)","user":"56979bb7e4b0e0b3d3318cac"},{"problem":75,"code":"(fn [x] (let [divisors (fn [n] (set (filter #(zero? (mod n %)) (range 2 (inc n)))))\n                  divisors-of-x (divisors x)\n                  divisors-of-x-count (count divisors-of-x)]\n              (inc\n                (count\n                  (filter (fn [n] (=\n                                    (count (into divisors-of-x (divisors n)))\n                                    (+ divisors-of-x-count (count (divisors n)))))\n                          (range 2 x))))))","user":"51e28063e4b08e53a149f0f2"},{"problem":75,"code":"(fn [n]\n    (let [gcd (fn [a b]\n                (let [m (min a b)\n                      c (range 1 (+ 1 m))\n                      f #(and (integer? (/ a %)) (integer? (/ b %)))]\n                  (last (filter f c))))]\n      (if (= 1 n)\n        1\n        (count (filter #(= 1 (gcd % n))\n                       (range 1 n))))))","user":"52e1c276e4b09f7907dd142b"},{"code":"(fn [x]\n  (let [gcd (fn f [a b]\n              (if (= b 0)\n                a\n                (f b (rem a b))))]\n    (count (filter #(= 1 (gcd x %)) (range x)))))","problem":75,"user":"533018b2e4b019098a6f8b56"},{"problem":75,"code":"(fn [n] (loop [x 2\n               acc []]\n          (if (> x n)\n            (- n (count acc))\n            (if (or (some #(= 0 (rem x %)) acc) (= 0 (rem n x)))\n              (recur (inc x) (conj acc x))\n              (recur (inc x) acc)))))","user":"5e6ba862e4b04a83ad7cd27d"},{"problem":75,"code":"(fn [x]\n  (case x 1 1\n    (count\n     (filter #((fn coprime? [x y] (let [z (mod y x)] (if (= z 0) (= x 1) (coprime? z x))))\n               % x)\n             (range 1 x)))))","user":"4f5eda39e4b0030a34fb2b56"},{"problem":75,"code":"(fn [n]\r\n  (letfn [(gcd [a b] (if (zero? b) a (gcd b (mod a b))))]\r\n    (count (filter #(= 1 (gcd n %)) (range n)))))","user":"5f2c02d1e4b033932238a65f"},{"problem":75,"code":"(fn totient [n]\n  (if (= 1 n)\n    1\n    (letfn [(gcd [a b]\n                 (if (= 0 (mod a b))\n                   b\n                   (gcd b (mod a b))))]\n      (count (filter #(= 1 (gcd n %)) (range 1 n))))))","user":"553b0d95e4b09218d5f44fff"},{"problem":75,"code":"(fn [x]\n    (let [\n          q\n          (fn [n]\n            (loop [q (list n) f 2]\n              (if (> f (Math/sqrt n ))\n                (set q)\n                (if (= 0 (mod n f))\n                  (recur (conj q f (/ n f)) (+ f 1))\n                  (recur q (+ f 1))\n                  )\n                )\n              )\n            )\n\n          w (fn [x y]\n              (empty? (clojure.set/intersection (q x) (q y)))\n              )\n          ]\n      (if (= x 1)\n        1\n        (count (filter #(w x %) (range 1 x)))\n        )\n      )\n    )","user":"54b90836e4b0ed20f4ff6e9d"},{"code":"(letfn [(gcd [a b]\r\n         (if (zero? b)\r\n           a\r\n           (recur b (mod a b))))]\r\n  #(if (= % 1) 1\r\n    (count\r\n      (filter (fn [a] (= (gcd % a) 1))\r\n        (rest (range %))))))","problem":75,"user":"4ddbfb8a535d02782fcbea00"},{"problem":75,"code":"(fn [n]\n  (if (= 1 n) 1\n      (let [gcd (fn [a b]\n                  (if (zero? b)\n                    a\n                    (recur b (mod a b))))\n            coprimes? (fn [m n]\n                        (= 1 (gcd m n)))]\n        (count (filter #(coprimes? n %) (range 1 n)))\n        )))","user":"53ef7f77e4b0742d9025b0ce"},{"problem":75,"code":"(fn [n]\n  (letfn [(gcd [a b]\n               (loop [x a y b]\n                 (if (= 0 y)\n                   x\n                   (recur y (rem x y))\n                 )\n               )\n          )\n         ]\n    (count (filter #(= 1 (gcd n %)) (range n)))\n  )\n)","user":"57873017e4b0ebec4cfb7503"},{"problem":75,"code":"(fn y [n]\n  (let [f (fn [x] (into #{} (filter #(zero? (mod x %)) (range 1 (inc x)) ) ))\n        z (fn [a b]\n            (let [r (clojure.set/intersection (f a) (f b)) ]\n              (= 1 (count r) (first r))\n             )\n           )        \n        ]\n    \n    (if (= 1 n) 1\n      \n      (count (filter #(z n %) (range 1 n) ))\n      \n     )\n    \n   )\n  \n )","user":"56db90d4e4b0ea9b8538f80d"},{"code":"(fn [x]\n  (if (= 1 x) 1    \n    (letfn [(gcd [a b]\n                 (if (zero? b) a (recur b (mod a b))))]\n      (count (filter #(= 1 %) (map #(gcd x %) (range 1 x)))))))","problem":75,"user":"514721c6e4b0d520409ed392"},{"problem":75,"code":"(fn [x]\n  (if (= 1 x)\n    1\n    (let [gcd (fn [a b]\n                (if (= 0 b)\n                  a\n                  (recur b (mod a b))))\n          coprime-to-x? (fn [y] (= 1 (gcd x y)))\n          coprimes (filter coprime-to-x? (range 1 x))]\n      (count coprimes))))","user":"4ff24a1ae4b0678c553fc337"},{"problem":75,"code":"(fn [x]\n  (let [candidates (cons 1 (range 2 x))\n        gcd (fn [n] (some #(if (and (zero? (mod n %)) (zero? (mod x %))) % false) (reverse(range 1 (inc n)))))]\n    (count (filter #(= 1 (gcd %)) candidates))))","user":"55a74d46e4b09e57187da2a3"},{"problem":75,"code":"(fn [n]\n  (letfn [\n    (gcd [a b]\n      (cond\n        (= 0 a) b\n        (= 0 b) a\n        :else (gcd b (rem a b))))]\n    (->>\n      (range 2 n)\n      (filter #(= 1 (gcd % n)))\n      (count)\n      inc)))","user":"5901158de4b0438e51c2d039"},{"code":"(fn [n]\n  (letfn [(gcd [a b] (if (zero? a) b (gcd (mod b a) a)))]\n    (if (= 1 n) 1\n      (reduce + (map #(if (= 1 (gcd n %)) 1 0) (range 1 n))))))","problem":75,"user":"4f4c6b21e4b03ad3f0c10c8f"},{"problem":75,"code":"(fn f [x]\n  (letfn [(gcd [a b]\n            (reduce max 1\n                    (filter #(and (zero? (rem a %)) (zero? (rem b %))) (range 1 (inc (min a b))))))\n          (coprime? [a b] (= 1 (gcd a b)))]\n    (if (= x 1) 1 (count (filter #(coprime? % x) (range 1 x))))))","user":"56a01895e4b0542e1f8d149f"},{"code":"(fn totient [num]\n  (if (= num 1)\n    1\n    (let [gcd (fn [a b]\n              (if (= b 0)\n                a\n                (recur b (mod a b))\n                )\n              )]\n    (->> (range 1 num)\n         (map (partial gcd num))\n         (filter #(= 1 %))\n         (count)\n         )\n    ))\n  )","problem":75,"user":"53527551e4b084c2834f4af0"},{"problem":75,"code":"(fn [n]\n    (letfn [(gcd [a b]\n              (if (zero? b) a (recur b (rem a b))))]\n      (count (filter #(= 1 (gcd n %)) (range 1 (inc n))))))","user":"5c165d3ee4b01240ff5671d1"},{"code":"(fn [n] (letfn [\n(gcd [n1 n2] (cond (> n2 n1) (gcd n2 n1) (zero? (rem n1 n2)) n2 (= 1 n2) 1 :else (gcd n2 (rem n1 n2))))\n(coprime? [n1 n2] (= 1 (gcd n1 n2)))\n(coprimes [n] (filter #(coprime? n %) (range 1 n)))\n(totient [n] (max 1 (count (coprimes n))))\n] (totient n)))","problem":75,"user":"52f10094e4b05e3f0be25ee8"},{"code":"(fn [n]\n\t({1 1} n\n\t\t(count \n\t\t\t(filter\n\t\t\t\t(fn [a] \n\t\t\t\t\t(not-any? \n\t\t\t\t\t\t#(= 0 (rem a %) (rem n %))\n\t\t\t\t\t\t(range 2 (+ 1 a))))\n\t\t\t\t(range 1 n)))))","problem":75,"user":"528a3e14e4b0239c8a67ae72"},{"problem":75,"code":"(fn [x]\n  (if (= x 1)\n    1\n    (->> (map (fn [a b]\n                [a ((fn gcd [a b]\n                      (if (zero? b) a\n                          (if (< a b) (gcd b a)\n                              (gcd (mod a b) b)))) a b)])\n              (range 1 x)\n              (repeat x))\n         (filter (fn [[a b]] (= b 1)))\n         (map first)\n         (count))))","user":"50742549e4b054001656accf"},{"code":"(fn [n] \n(letfn [(lcd [x y] (if (= (rem x y) 0) y\n                        (lcd y (rem x y))\n                        ))]\n  \t\t\t(if (= n 1) 1\n\t\t\t(count (filter #(= 1 (lcd n %)) (range 1 n)))\n  ))\n)","problem":75,"user":"5105ed16e4b01150e115ebe2"},{"code":"(fn __ [n]\n  ;; define greatest common divisor function\n  (let [gcd (fn [a b]\n              (let [min-ab (min a b)\n                    divs   (range (inc min-ab) 0 -1)]\n                (first (filter #(= 0 (rem a %) (rem b %)) divs))))]\n    ;; use it \n    (if (= n 1)\n      ;; special case for n = 1\n      1\n      ;; count integers < n that have gcd of 1 with number n\n      (count (filter #(= 1 (gcd n %)) (range 1 n))))))","problem":75,"user":"53415755e4b00652c8746ecd"},{"problem":75,"code":"(fn [x] (max 1 \n             (apply + \n                    (filter #(= 1 %) \n                            (map (fn [a b] (if (zero? b) a (recur b (mod a b)))) \n                                 (range 1 x) \n                                 (repeat x))))))","user":"5686b7c7e4b0dcc4269f4057"},{"code":"(fn [n]\n              (if (= n 1)\n                1\n                (letfn [(gcd [a b]\n                          (let [big (max a b) small (min a b) next-small (mod big small)]\n                            (if (zero? next-small)\n                              small\n                              (gcd small next-small))))]\n                  (count (filter #((fn [a b] (= 1 (gcd a b))) n %) (range 1 n))))))","problem":75,"user":"514d7e29e4b019235f6c0587"},{"problem":75,"code":"(fn totient [x]\n  (if (= x 1) 1\n      (letfn [(gcd [a b] (if (zero? b) a (gcd b (mod a b))))]\n        (count (filter #(= % 1)\n                       (map (partial gcd x) (range 1 x)))))))","user":"546c1f73e4b00cfc9eacc175"},{"problem":75,"code":"(fn [x]\n  (letfn [(gcd [a b] (cond (= a 0) b\n                           (< b a) (gcd b a)\n                           :else (gcd a (- b a))))]\n    (count (filter #(= (gcd % x) 1) (take x (iterate inc 1))))))","user":"5b3f2ba9e4b02d533a91bc09"},{"problem":75,"code":"(fn totient [x]\n  (letfn [(factors [x]\n            (into #{}\n                  (for [tst (range 1 (inc x))\n                        :when (== 0 (mod x tst))\n                        ]\n                    tst)))\n          (coprime [x y] (== 1 (apply max (clojure.set/intersection (factors x) (factors y) ))))\n          ]\n  (count (for [tst (range 1 (inc x)) :when (coprime x tst)] tst))))","user":"562add6de4b00e49c7cb4834"},{"problem":75,"code":"(letfn [(gcd [x y]\n        (let [[mn mx] (sort [x y])]\n          (loop [divisor mn]\n            (if (= 0 (rem x divisor) (rem y divisor))\n              divisor\n              (recur (dec divisor))))))]\n  (fn [x]\n    (if (= x 1)\n      1\n      (loop [y 2 cnt 1]\n        (if (= y x)\n          cnt\n          (recur (inc y)\n                 (if (= 1 (gcd x y))\n                   (inc cnt)\n                   cnt)))))))","user":"57609d91e4b08062f99a4e9b"},{"code":"(fn tot [n]\n  (let [gcd (fn gc [n m] (if (= 0 m) n (gc m (mod n m))))]\n    (count (filter #(= 1 (gcd n %)) (range n)))))","problem":75,"user":"515fb48fe4b0e2be8aa20bd5"},{"problem":75,"code":"(fn __\n  [number]\n  (letfn [(gcd [x y]\n\t\t\t\t     (if (= x y)\n\t\t\t\t       x\n\t\t\t\t       (if (> x y)\n\t\t\t\t         (recur (- x y) y)\n\t\t\t\t         (recur x (- y x)))))]\n    (count (filter #(= 1 (gcd % number)) (range 1 (inc number))))))","user":"55a62092e4b0acc240e31554"},{"problem":75,"code":"(fn totient [n]\n  (let [coprime? (fn [x y]\n                   (let [m (min x y)\n                         common-divisors (map #(= 0 (rem x %) (rem y %)) (range 2 (max x y)))]\n                     (if (some true? common-divisors)\n                       false\n                       true)))]\n    (inc (count (for [i (range 2 n)\n                  :when (coprime? i n)]\n              i)))))","user":"536673a8e4b0243289761e76"},{"code":"(fn coprime\n  [x]\n  (letfn [(gcd [a b]\n               (if (zero? b)\n                 a\n                 (gcd b (mod a b))))]\n  (if (= x 1)\n    1\n    (count\n      (reduce (fn [r e]\n                (if (= 1 (gcd x e))\n                  (conj r e)\n                  r))\n              [] (range 1 x))))))","problem":75,"user":"5348cab4e4b084c2834f4a5e"},{"problem":75,"code":"(fn [c]\n   (letfn [(gcd [a b] (if (zero? b) a (recur b (mod a b))))\n           (cp? [a b] (= 1 (gcd a b)))]\n     (if-not (= 1 c)\n       (count (filter (partial cp? c) (range 1 c)))\n       1)))","user":"55b1e9e7e4b0da326a65cf74"},{"problem":75,"code":"(fn [n]\n  (cond \n    (= n 1) 1\n    :else (letfn [(gcd [x y]\n                   (cond \n                     (zero? y) x\n                     :else (gcd y (mod x y))))]\n           (count (filter \n                   #(= (gcd % n) 1) \n                   (range 1 n))))))","user":"5707b96fe4b0b0fb43fd0690"},{"code":"(fn [n]\n  (if (= 1 n) 1\n\t  (letfn [(gcd [a b]\n  \t\t(if (zero? b)\n    \t\ta\n\t    \t(recur b (mod a b))))]\n\t    (count (filter #(= 1 (gcd % n)) (range 1 n))))))","problem":75,"user":"50bca033e4b0594b91591c5d"},{"code":"(fn eulers-totient [n]\n  (letfn [(gcd [x y] (if (zero? y) x (recur y (rem x y))))]\n    (count (filter #(= 1 (gcd n %)) (range n 0 -1)))))","problem":75,"user":"4db016af838c48654951d9b9"},{"code":"(fn [n] ({1 1, 10 4, 40 16, 99 60} n))","problem":75,"user":"4f58d92fe4b0a7574ea71858"},{"code":"(fn [n]\n\t(letfn\n\t\t[(gcd [a b]\n\t\t\t\t(if (zero? b) a (recur b (mod a b))))\n\t\t(coprime [a b]\n\t\t\t\t(= (gcd a b) 1))]\n\t\t(if (= n 1) 1\n\t\t\t(count (filter true? (for [x (range 1 n)] (coprime x n)))))))","problem":75,"user":"5201ff99e4b0b2e020a18f26"},{"code":"(fn [n]\n  (let [gcd (fn f [a b] (if (zero? b) a (f b (mod a b))))]\n    (if (= 1 n)\n      1\n      (count (filter #(= 1 (gcd n %)) (range 1 n)))\n      )\n    )\n  )","problem":75,"user":"523f0bbfe4b01c266ffa7f91"},{"problem":75,"code":"(fn [n] (if (= 1 n) 1 (letfn [(gcd [a b] (let [nxt (if (> a b) [b (rem a b)] [a (rem b a)])] (if (= 0 (last nxt)) (first nxt) (apply gcd nxt))))] (count (filter #(= 1 (gcd n %)) (range 1 n))))))","user":"5519c157e4b00ace28fe6e32"},{"problem":75,"code":"(fn totient [n]\n  (letfn [(gcd [a b]\n            (loop [r1 (if (> a b) a b)\n                   r2 (if (< a b) a b)]\n              (if (= (rem r1 r2) 0)\n                r2\n                (recur r2 (rem r1 r2)))))]\n    (if (= n 1)\n      1\n      (reduce #(if (= (gcd n %2) 1) (inc %1) %1) 0 (range 1 n)))))","user":"5f8b06afe4b0715f5002d74a"},{"code":"(fn [x]\n  (letfn [(lcd [x y] (if (zero? y) x (recur y (mod x y))))\n          (is-coprime? [x y] (= 1 (lcd x y)))]\n    (if (= x 1) 1 (count (filter #(is-coprime? x %) (range 1 x))))))","problem":75,"user":"511d6a01e4b022853b0e07a5"},{"problem":75,"code":"(fn\n  [n]\n  (if (= n 1)\n    1\n    (count (filter #(= 1 %) (map (partial (fn gcd\n  [v k]\n  (let [g (max v k) l (min k v)]\n    (if (not= 0 (rem g l))\n      (gcd l (rem g l))\n      l)\n    )) n) (rest (range n)))))))","user":"5772ddb0e4b0979f896515d4"},{"code":"(fn e [n]\n  (let [gdc (fn [a b] (if (= b 0) a (recur b (mod a b))))]\n    (inc (count (for [a (range 2 n) :when (= (gdc a n) 1)] a)))))","problem":75,"user":"4f9120d8e4b0dcca54ed6c96"},{"problem":75,"code":"(fn [n]\n  (if (= 1 n) 1\n  (letfn [\n          (gcd [x y] (if (= 0 (rem x y)) y (recur y (rem x y))))\n          (coprime [x y] (= 1 (gcd x y)))]\n  (count (filter #(coprime n %) (take (dec n) (drop 1 (range))))))))","user":"54908cc1e4b0b312c081ff32"},{"problem":75,"code":"(fn [x]\n   (let [gcd (fn [& args]\n               (apply max (filter (fn [d]\n                                    (apply = (conj (map #(mod % d) args) 0)))\n                                  (range 1 (inc (apply min args))))))\n         coprimes (filter #(= 1 (gcd x %)) (range 1 x))]\n     (if (empty? coprimes)\n       1\n       (count coprimes))))","user":"55895eade4b059ccff29b202"},{"problem":75,"code":"(fn [x]\n  (letfn [(gcd [a b]\n            (if (zero? b)\n              a\n              (recur b (mod a b))))\n          (coprime [a b]\n            (= 1 (gcd a b)))]\n    (if (= 1 x)\n      1\n      (count (filter (partial coprime x) (range 0 x))))))","user":"5344fe13e4b084c2834f4a32"},{"code":"(fn [n] \n  (count \n    (filter #(= 1 %) \n      (map (partial #(if (= 0 %)\n            %2\n            (recur (mod %2 %) %)) n) \n        (range 1 (+ n 1))))))","problem":75,"user":"4f01c938535dcb61093f6a39"},{"problem":75,"code":"(fn [n]\n   (let [gcd (fn [a b]\n               (if (= b 0) a\n                 (recur (min a b) (mod (max a b) (min a b)))))\n         coprimes (fn [m acc]\n                    (if (= m 0) acc\n                      (recur (dec m) (if (= 1 (gcd n m)) (cons m acc)\n                                       acc))))]\n     (count (if (= n 1) '(1) (coprimes (dec n) '())))))","user":"57780e4fe4b0979f89651657"},{"code":"(fn [n]\r\n       (letfn [(gcd [x y] (if (= y 0) x (gcd y (rem x y))))]\r\n         (count (distinct (conj (map #(if (= (gcd n %) 1) % 1) (range 1 n)) 1)))))","problem":75,"user":"4deb529a535d08e6dec9fe04"},{"problem":75,"code":"(fn [x]\n  (if (= x 1)\n      1\n      (let [gcd  (fn [a b] (if (= b 0) a (recur b (mod a b)))) ]\n        (count (filter #(= % 1) (map gcd (range 1 x) (repeat x x)))))))","user":"52117ea7e4b07aea8afc4f70"},{"problem":75,"code":";brute force\n(letfn [(gcd [x y]\n             (cond\n              (> y x) (recur y x)\n              (zero? y) x\n              :else (recur y (mod x y))))]\n  (fn [n]\n    (if (= n 1) 1\n      (count (filter #(= 1 (gcd n %)) (range 1 n))))))","user":"5553b924e4b0deb715856e06"},{"problem":75,"code":"(fn totient [x]\n  (if (= x 1) 1\n  (letfn [(mygcd [a b] (if (= 0 b) a (recur b (mod a b))))]\n  (->> (range 1 x) (filter #(= 1 (mygcd x %))) count))))","user":"54769c7ae4b0c51c1f4d72a8"},{"problem":75,"code":"(fn euler's-function\n  [x]\n  (if (= 1 x)\n    1\n    (let [greatest-divisor (fn [x y]\n                             (last\n                               (remove\n                                 #(not (and (= (rem x %) 0) (= (rem y %) 0)))\n                                 (range 1 (+ x 1)))))]\n      (reduce (fn [num item]\n                (if (= 1 (greatest-divisor x item))\n                  (inc num)\n                  num)) 0 (range (inc x))))))","user":"60396c95e4b0d5df2af222f4"},{"code":"(fn [x]\n   (inc (count (filter identity (for [y (range 2 x)]\n                               ((fn [x y]\n                                  (if (apply distinct? (concat\n                                                         (filter #(= 0 (mod y %)) (range 2 (inc y)))\n                                             \t\t\t (filter #(= 0 (mod x %)) (range 2 x))))\n                                    y)) \n                                x y))))))","problem":75,"user":"5300aa1de4b0d8b024fd3710"},{"problem":75,"code":"(fn totient [x]\n  (if (= 1 x) 1\n      (count\n       (filter #(= 1 %)\n               (map (fn [xxx]\n                      ((fn [m n]\n                        (if (zero? n)\n                          m\n                          (recur n (mod m n)))) xxx x)) (range 1 x))))))","user":"51b76227e4b0d906fcd71d35"},{"problem":75,"code":"(fn problem-75 [n]\n  (letfn [(gcd [a b] (if (zero? b)\n                       a\n                       (recur b (mod a b))))\n          (coprime-to-n? [a] (= 1 (gcd n a)))]\n    (count (filter coprime-to-n? (range n)))))","user":"501d34f6e4b066e56b9d0b1e"},{"code":"(fn [n]\n  (letfn [(gcd [a b] (if (zero? b) a (gcd b (rem a b))))\n          (coprime? [a b] (= 1 (gcd a b)))]\n    (count (filter #(coprime? n %) (range 1 (inc n))))))","problem":75,"user":"51e38568e4b0c611d6113e43"},{"problem":75,"code":"(fn [n]\n   (letfn [(gcd [a b]\n             (cond\n               (> b a) (gcd b a)\n               (= b 0) a\n               :else (gcd b (- a b))))]\n     (count (filter #(= 1 (gcd n %)) (range 1 (inc n))))))","user":"54b817eee4b0ed20f4ff6e93"},{"problem":75,"code":"(fn [n]\n  (let [divisors (fn [i] (set (filter #(= 0 (mod i %)) (range 1 (inc i)))))\n        div-n (divisors n)]\n    (count\n     (filter #(= #{1} (clojure.set/intersection div-n %)) \n             (map divisors (range 1 (inc n)))))))","user":"554680cbe4b0a04f7929953e"},{"problem":75,"code":"(fn [n]\n        (letfn [(gcd [a b]\n                  (if (= b 0)\n                    a\n                    (recur b (mod a b))))]\n          (count (filter #(= % 1) (map (partial gcd n) (range 1 (inc n)))))))","user":"541ae7dbe4b01498b1a71a61"},{"problem":75,"code":"(fn [n]\n  (if (= n 1)\n    1\n    (let [gcd (fn [x y] \n                (loop [x x y y]\n                  (if (zero? (rem x y))\n                    y\n                    (recur y (rem x y)))))]\n      (count (filter #(= 1 (gcd % n)) (range 1 n))))))","user":"58ca8a1de4b03c36ff7e5835"},{"problem":75,"code":"(fn [x]\n  \t(if (= 1 x) 1 ; special case.\n\t(let [ns (range 1 x)] ; all pos ints below x.\n\t\t(letfn [(divs [n] (filter #(= 0 (mod n %)) ns))] ; all divisors of n.\n\t\t\t(count \n              ;; count all GCDs equalling 1.\n              (filter #(= 1 %) \n                ;; grab all divisors of n. cast to set. get intersection of divisors of x and this set.\n                ;; cast to a sequence. get the maximum.\n                (map (comp #(apply max %) \n                           seq \n                           #(clojure.set/intersection (set (divs x)) %) \n                           set \n                           divs) \n                     ns)))\n\t\t)\n\t))\n)","user":"5578f292e4b05c286339e08f"},{"code":"(let [gcd (fn [a b]\n            (first\n              (filter #(and (integer? (/ a %)) (integer? (/ b %)))\n                      (reverse (map inc (range (min a b)))))))]\n  (fn [n]\n    (count\n      (filter zero?\n              (map dec (map gcd (repeat n) (map inc (range n))))))))","problem":75,"user":"52a1acb2e4b04e0c58e87bdb"},{"code":"(fn totient [x]\n  (let [sieve (fn sieve [a b]\n                (let [big (max a b)\n                      small (min a b)\n                      remainder (mod big small)]\n                  (if (= 0 remainder)\n                    small\n                    (sieve small remainder))))]\n    (if (= 1 x)\n      1\n      (->> (range 1 (inc x))\n           (map #(sieve x %))\n           (filter #{1})\n           count))))","problem":75,"user":"51281b25e4b03a34742b4304"},{"problem":75,"code":"(fn totient [x]\n\t(let [gcd (fn [a b] (if(= 0 b) a (recur b (mod a b))))]\n\t\t(count \n\t\t\t(for [i (range x) :when (= 1 (gcd x i))] i))))","user":"564d02cde4b0284900eef679"},{"code":"(fn [x]\n  (if (= 1 x)\n    1\n    (let [gcd (fn [a b]\n                (if (= 0 b)\n                  a\n                  (recur b (rem a b))))]\n      (count (filter #(= 1 (gcd % x)) (range 1 x))))))","problem":75,"user":"50d86fe2e4b01f0871336e67"},{"code":"(fn [n]\n    (letfn [(gcd [a b]\n              (if (zero? b)\n                a\n                (recur b (mod a b))))]\n      (let [ns (range 1 (inc n))]\n        (count (filter #(= 1 (gcd n %)) ns)))))","problem":75,"user":"50aedb8ce4b0a40c9cfb08d4"},{"problem":75,"code":"(fn totient\n  [n]\n  (letfn [(gcd [a b]\n            (cond\n              (= a 0) b\n              (= b 0) a\n              :else (let [smaller (min a b)\n                          larger (max a b)\n                          remainder (rem larger smaller)]\n                      (gcd smaller remainder))))\n          (coprime? [a b] (= (gcd a b) 1))]\n    (if (= n 1)\n      1\n      (count (filter (partial coprime? n) (range 1 n))))))","user":"563f1493e4b08d4f616f5ecf"},{"problem":75,"code":"(fn [x]\n    (letfn\n      [(gcd [a b]\n         (cond\n           (zero? b)\n           a\n  \n           (< a b)\n           (gcd b a)\n  \n           :else\n           (gcd b (mod a b))))]\n  \n      (->> (range 2 x)\n           (cons 1)\n           (map (partial gcd x))\n           (filter (partial = 1))\n           count)\n      ))","user":"5ab1665de4b073f1774425c0"},{"problem":75,"code":"(fn [n]\n  (letfn [(divisor [x] #(zero? (mod (/ x %) 1)))\n          (divisors [x] (conj (set (filter (divisor x) (range 1 (inc x)))) 1))\n          (coprime? [x] (= 1 (count (clojure.set/intersection (divisors x) (divisors n)))))]\n    (count (filter coprime? (range 1 (inc n))))))","user":"578fc072e4b0ebec4cfb759a"},{"code":"(fn e [x] (let [v (reverse (butlast(butlast (reverse\r\n           (into [] (range x))))))]\r\n             (int (* x (reduce * (map #(/ (- % 1) %) (into [] (filter (fn prime? [x] \r\n                (->> (range 2 x) (map #(rem x %)) (some zero?) not)) (filter #(if (= (rem x %) 0) true false) v)))))))))","problem":75,"user":"506717e2e4b03d366d7cb2ba"},{"problem":75,"code":"(fn [x]\n  (let [factors (fn [n] (->> (range 1 n) (filter #(zero? (rem n %)))))]\n    (reduce #(* %1 (- 1 (/ 1 %2))) x (filter #(= 1 (count (factors %))) (factors x)))))","user":"576e607ae4b0979f89651579"},{"code":"(fn [n]\n  (if (= n 1)\n    1\n    (count (remove (fn [i] (some #(= (mod i %) (mod n %) 0) (range 2 (inc i))))\n                   (range 1 n)))))","problem":75,"user":"4e8612f8535db62dc21a62f2"},{"problem":75,"code":"(fn totient [x]\n  (letfn [(gcd [x y]\n            (if (zero? y)\n               x\n               (recur y (mod x y))))]\n          \n  (if (= x 1)\n    1\n    (count (filter #(= (gcd x %) 1) (range 1 x))))))","user":"57a4fa50e4b0a966079561f1"},{"code":"(letfn [(coprime? [a b]\r\n            (if (zero? b)\r\n              (= a 1)\r\n              (recur b (mod a b))))]\r\n    (fn [x]\r\n      (if (= x 1)\r\n        1\r\n        (count (filter #(coprime? x %) (range 1 x))))))","problem":75,"user":"4f047177535dcb61093f6bc6"},{"problem":75,"code":"(fn euler-totient [n]\n  (let [gcd (fn gcd [a b]\n              (if (= b 0) a\n                  (gcd b (mod a b))))\n        coprime? (fn [m]\n                   (= 1 (gcd n m)))]\n    (if (= n 1)\n      1\n      (->> (range n)\n          (filter coprime?)\n          (count)))))","user":"605f5c69e4b03746e80ebf5e"},{"code":"(fn [x] \n\t(if (= x 1) 1\n\t\t(let [\n\t\t\tr (range 2 x)\n\t\t\tdz (filter (fn [y] (= 0 (mod x y)) )  r)\n\t\t\tco (filter (fn [z] (not (some zero? (map (fn [w] (mod z w)) dz)) ))  r)\n\t\t\tc (inc (count co))\n\t\t\t] c) \n\t)\n)","problem":75,"user":"5296008fe4b02ebb4ef7502a"},{"problem":75,"code":"(fn [n]\n\t(letfn [(gcd [x y]\n\t\t\t(condp = (rem x y)\n\t\t\t0 y\n\t\t\t(recur y (rem x y))))]\n\t\t(inc (count (filter #(= 1 (gcd n %)) (range 2 n))))))","user":"57c647bbe4b05aa3c4741cf3"},{"problem":75,"code":"(fn [x]\n   (let [gcd #(loop [a %1, b %2] (if (= b 0) a (recur b (mod a b))))]\n     (count (filter #(= 1 (gcd x %)) (range 0 x) ))))","user":"53fcdd1ae4b0de5c418485dd"},{"problem":75,"code":"(fn euler-totient-function-answer\n  [x]\n  (count (filter #(= 1 ((fn gcd [a b] (if (= 0 b) a (gcd b (mod a b)))) x %) )  (range 1 (inc x)))))","user":"5360f043e4b0243289761e3c"},{"problem":75,"code":"(fn [x]\n    (if (= x 1)\n      1\n      (let [divisors (filter #(zero? (rem x %)) (range 2 x))]\n        (count (filter (fn [i] (not-any? #(zero? (rem i %)) divisors)) (range 1 x))))))","user":"54f26266e4b024c67c0cf8c5"},{"code":"(fn [n]\r\n  (if (= 1 n)\r\n    1\r\n    (let [gcd (fn [x y]\r\n                (first (filter\r\n                  #(and (zero? (rem x %)) (zero? (rem y %)))\r\n                  (range (min x y) 0 -1))))]\r\n      (count (filter #(= 1 (gcd n %)) (range (dec n) 0 -1))))))","problem":75,"user":"4f969214e4b0dcca54ed6cdd"},{"code":"(fn totient [j]\n     (let [gcd (fn [m n] (apply max (clojure.set/intersection (set (filter #(= 0 (mod m %)) (drop 1 (range (+ 1 m)))))\n                         (set (filter #(= 0 (mod n %)) (drop 1 (range (+ 1 n))))))))\n           ]\n       (count (filter #(= 1 (gcd j %)) (range 1 (inc j))))))","problem":75,"user":"4eb44d78535d7eef30807360"},{"problem":75,"code":"(fn [n]\n  (if (= n 1) 1\n    (letfn [(gcd [a b] (if (= 0 b) a (recur b (mod a b))))\n            (coprime? [a b] (= 1 (gcd a b)))]\n      (count (filter (partial coprime? n) (range 1 n))))))","user":"4eb97234535dfed6da9c6d53"},{"problem":75,"code":"(fn [n] (let [gcd? (fn [x] (< 1 (apply max(filter #(= 0 (mod x %) (mod n %))(range 1 (inc n))))))]\n          (inc(count(remove gcd? (range 2 n))))))","user":"566a3a26e4b0a866af689699"},{"code":"(fn totient [n]\n  (if (= n 1) 1 \n      (let [gcd (fn [a b] (loop [m (min a b)]\n                            (if  (= (mod a m) (mod b m) 0) m (recur (dec m)))))]\n        (count (filter #(= 1 %) (map (partial gcd n) (rest (take n (iterate dec n)))))))))","problem":75,"user":"52ba43d0e4b07a9af57922cd"},{"code":"(fn euler[x] \n         (letfn [(gcd[x y] (if (zero? y)\n                       x\n                       (gcd y (mod x y))))\n                 (coprime?[x y] (== 1 (gcd x y)))]\n           (count (filter #(coprime? x %)  (range 1 (inc x))))))","problem":75,"user":"5301157ae4b0d8b024fd3717"},{"code":"(fn [x]\n    (if (= x 1) 1 (letfn [(gcd [a b] (if (zero? b) a (gcd b (mod a b))))]\n                    (count (filter #(= 1 (gcd %1 x)) (range 1 x)))\n                    ))\n    )","problem":75,"user":"52593207e4b0cb4875a45cd3"},{"code":"(fn t [n]\n  (let [gcb (fn[a b]\n              (let [n (mod a b)]\n                (if (= 0 n) b\n            \t      (recur b n))))]\n    (count \n      (filter #(= 1 (gcb n %))\n        (range 1 (inc n))))))","problem":75,"user":"4f3242bae4b0d6649770a08f"},{"code":"(fn totient [n]\n  (letfn [(gcd [n1 n2]\n             (let [mx (max n1 n2)\n                   mn (min n1 n2)\n                   rm (rem mx mn)]\n               (if (= 0 rm)\n                 mn\n                 (recur mn rm))))\n          (coprime? [n1 n2]\n                   (= 1 (gcd n1 n2)))]\n                   \n    (count (filter #(coprime? % n) (range 1 (inc n))))))","problem":75,"user":"52d00832e4b07d0d72b273b4"},{"code":"(fn [x] (if (= 1 x) 1 (count (filter #(= 1 ((fn [m n] (if (zero? n) m (recur n (mod m n)))) x %)) (range 1 (inc x))))))","problem":75,"user":"4f954dbce4b0dcca54ed6ccd"},{"code":"(fn [x]\n  (let [\n    dv (fn [a b]\n        (cond\n          (= a 0) b\n          (= b 0) a\n          (> a b) (recur (- a b) b)\n          :else (recur a (- b a))\n      ))\n    coprime? (fn [x b] \n      (cond\n        (> b x) false\n        (= 1 b) true\n        (= 0 b) false\n        :else (= 1 (dv x b))\n      ))\n    ]\n    (count (filter #(coprime? x %) (range (+ 1 x))))\n))","problem":75,"user":"4e6e10d8535d5021c1a895fd"},{"code":"(fn [n]\n  (let [gcd (fn [x y]\n              (first\n                (last\n                  (take-while seq\n                              (iterate\n                                #(when (not (zero? (second %))) \n                                   (vector (second %) (mod (first %) (second %)))) [x y])))))]\n    (count\n      (filter\n        #(= 1 (gcd n %))\n        (range 1 (inc n))))))","problem":75,"user":"4e5914e0535d8a8b8723a29b"},{"problem":75,"code":"(fn totient [n]\n  (if (= n 1) 1\n      (let [gcd #(if (zero? %2) %1 (recur %2 (rem %1 %2)))]\n        (->> (range 1 n)\n             (filter #(= (gcd n %) 1))\n             (count)))))","user":"5591cc56e4b0604b3f94d582"},{"problem":75,"code":"(fn tottient\n  [x]\n  (if (= x 1)\n    1\n    (let [gcd (fn [a b] (if (< a b) (recur b a) (if (zero? b) a (recur b (rem a b)))))]\n      (reduce +\n              (for [n (range 1 x)\n                    :when (= (gcd x n) 1)]\n                1)))))","user":"54f64e99e4b0f2f3c5226ea4"},{"code":"(fn [x] (let [gcd (comp (partial apply +) first (partial drop-while (comp (partial < 0) (partial apply min))) #(iterate (fn [[x1 x2]] (vector (mod x1 x2) (mod x2 x1))) [%1 %2]))]\n     (if (= x 1) 1 (count (filter (comp (partial = 1) (partial gcd x)) (range 1 x)))))\n)","problem":75,"user":"51cbdee1e4b08d8387cbede1"},{"code":"(fn [v]\n  (letfn [(coprime\n           [n1 n2]\n           (every?\n            #(> (+ (mod n1 %) (mod n2 %)) 0)\n            (range 2 (inc (min n1 n2)))))]\n  (inc\n   (count \n    (filter #(coprime % v) (range 2 v))))))","problem":75,"user":"51780f88e4b03d69594194c9"},{"problem":75,"code":"(fn [x] \n  (let [nnil? (comp not nil?)\n        \n        check (fn [n l] \n                (filter nnil?\n                        (map #(if (= (mod n %) 0) % nil) l)))\n        \n        check-d (fn check-d[v l] \n               (let [vv (first l)\n                     c (count l)]\n                 (if (= c 0) v\n                 (if (= (mod v vv) 0) nil (check-d v (rest l))))))\n        \n        d  (fn [n] (check n (range 2 n)))\n        eu? (fn [n l] \n              (filter nnil? (map (fn [v] (check-d v l)) (range 2 n)))\n        )] \n    (if (= x 1) 1 \n      (inc (count (eu? x (d x))))\n  )))","user":"586e47dee4b01531a375e9a9"},{"problem":75,"code":"(fn [x]\n  (letfn [(gcd [x y]\n            (let [[x y] (sort [x y])]\n              (loop [x x\n                     y y\n                     acc x]\n                (if (= 0 (mod y acc) (mod x acc))\n                  acc\n                  (recur x y (dec acc))))))]\n    (if (= x 1)\n      x\n      (count (filter #(= 1 %) (map gcd (range 1 x) (repeat x)))))))","user":"555f3bfde4b0a2eb076a39c1"},{"code":"(fn [x]\n    (if (= x 1)\n      1\n      (count\n        (filter\n          #(loop [n %]\n             (cond\n               (< n 2) 1\n               (= 0 (mod x n) (mod % n)) nil\n               1 (recur (- n 1))\n               ))\n          (range 1 x)))))","problem":75,"user":"51b3f109e4b0f094dd986fa9"},{"problem":75,"code":"(fn [x]\n  (let [divlist (for [i (range 2 (inc (quot x 2)))\n                       :when (= 0 (rem x i))]\n                   i)\n        coprime-with-x? (fn [y] (every?\n                                 #(not= % 0)\n                                 (for [i divlist]\n                                   (rem y i))))]\n    (inc (count\n          (for [j (range 2 x)\n                :when (coprime-with-x? j)]\n            j)))))","user":"5705e404e4b0b0fb43fd0676"},{"problem":75,"code":"(fn totient [n]\n  (if (= n 1)\n    1\n    (letfn [(gcd [a b]\n              (cond\n                (= a b) a\n                (> a b) (gcd (- a b) b)\n                (< a b) (gcd a (- b a))))\n            (coprime? [m] (= 1 (gcd m n)))]\n      (->> (range 1 n)\n           (filter coprime?)\n           count))))","user":"5283a919e4b0239c8a67adbe"},{"code":"(fn [x]\n  (let \n    [gcd (fn [a b] \n          (if (= b 0) a (recur b (mod a b))))]\n    (loop [v (if (= 1 x) x (dec x)), c 0]\n      (if (= v 1)\n        (inc c)\n        (recur \n          (dec v) \n          (if (= 1 (gcd v x)) (inc c) c))))))","problem":75,"user":"4ea4fe1f535d7eef308072cf"},{"problem":75,"code":"(fn [X]\n    (cond\n      (= 1 X) 1\n      :else\n      (count\n        (filter\n          ;; if this number is a coprime to X\n          (fn [A]\n            (= 1\n              (count\n                (filter\n                  ;; remainders should be zero\n                  #(and (zero? (rem X %)) (zero? (rem A %)))\n                  ;; all potential dividers\n                  (range 1 (inc A))\n                )\n              )\n            )\n          )\n          ;; all integer til X\n          (range 1 X)\n        )\n      )\n    )\n  )","user":"5d4a6c6ce4b0776584bd6f22"},{"problem":75,"code":"(fn phi [n]\n (letfn [(gcd [x y] (if (zero? y) x (recur y (mod x y))))]\n  (if (= 1 n) 1\n   (->> (range 1 n)\n    (filter #(= 1 (gcd n %)))\n    count))))","user":"5b61aa6ae4b0c6492753e712"},{"problem":75,"code":"(fn [n]\n   (letfn [(gcd [a b] (cond (zero? b) a :else (recur b (mod a b))))]\n     (if (= 1 n) 1\n         (->> (range 1 n)\n              (filter #(= 1 (gcd n %)))\n              (count)))))","user":"5935b010e4b04f87174def55"},{"problem":75,"code":"(letfn [(gcd [a b]\n            (if (= b 0)\n              a\n              (recur b (mod a b))))\n          (coprime? [a b]\n            (= 1 (gcd a b)))]\n    (fn totient [n]\n      (if (= n 1)\n        1\n        (->> (range n)\n             (filter (partial coprime? n))\n             count))))","user":"4dfe5a93535d04ed9115e786"},{"code":"(fn [n]\n   (letfn [(is-comprime?[a b]\n                        (not-any? #(= 0 (mod a %) (mod b %)) \n                                  (range 2 (inc (min a b)))))]\n     (count (filter #(is-comprime? % n) \n                    (range 1 (inc n))))))","problem":75,"user":"4f890488e4b033992c121c76"},{"code":"(fn [n] (reduce #(if (= 1\n                        (reduce (fn [a b] (if (and (= (mod n b) 0) (= (mod %2 b) 0)) b a))\n                                1\n                                (range 1 (if (> %2 %1) (inc %2) (inc %1))))) (inc %1) %1)\n                0\n                (range 1 (inc n))))","problem":75,"user":"53a1b5c8e4b0ca733b9744c1"},{"code":"(fn [x]\n  (let [gcd #(cond (= %1 %2) %1\n                   (> %1 %2) (recur (- %1 %2) %2)\n                   :else     (recur (- %2 %1) %1))\n        cp? #(= 1 (gcd %1 %2))]\n    (if (= 1 x)\n      1\n      (count (filter (partial cp? x) (next (range x)))))))","problem":75,"user":"4f32a7f1e4b0d6649770a095"},{"problem":75,"code":"(fn [n]\n  (letfn [(gcd [a b]\n            (if (= b 0)\n              a\n              (recur b (mod a b))))]\n  (count\n    (filter #(= 1 (gcd n %)) (range n)))))","user":"56d4b22de4b0ea9b8538f7bb"},{"code":"(fn [num]\n    (letfn [(gcd [x y] (if (zero? y) x (recur y (mod x y))))]\n        (if (= num 1) 1 (count (filter #(= 1 (gcd num %)) (range 1 num))))))","problem":75,"user":"4f4ac35ae4b0d56e7bb92c18"},{"problem":75,"code":"(fn totient [n]\n  (if (= 1 n)\n    n\n    (letfn [\n             (coprime [a b]\n               (cond (= a 0) (= b 1)\n                     (= b 0) (= a 1)\n                     :else (recur b (mod a b))))\n           ]\n      (->> (range 1 n)\n           (filter (partial coprime n))\n           count))))","user":"54d6f22de4b0a52adc2e2023"},{"problem":75,"code":"(fn [n]\n  (let [gcd (fn f [a b] (if (zero? b) a (f b (mod a b))) )]\n    (count (filter #(= 1 (gcd n %)) (range 1 (+ 1 n) )))))","user":"5dfa1c67e4b0a607a9a45cc5"},{"problem":75,"code":"(fn euler [n]\n  (count (filter #(= (\n                      (fn [a b]\n                        (if (zero? b) a (recur b (mod a b)))) % n) 1) (range 1 (inc n)))))","user":"5a621702e4b0512ff01cd983"},{"code":"(fn [n]\n  (letfn [(gcd [x y] (if (zero? y) x (recur y (mod x y))))]\n    (reduce #(if (= (gcd n %2) 1) (inc %1) %1) 0 (range 1 (inc n)))))","problem":75,"user":"4f2baf1ae4b0d6649770a04c"},{"code":"(fn [n]\n  (if (= 1 n) 1\n      (let [gcd (fn [q]\n                  (->> q inc (range 1) (filter #(= 0 (rem n %) (rem q %))) (apply max)))]\n        (->> n (range 1) (filter #(= 1 (gcd %))) count))))","problem":75,"user":"524ae8e6e4b09eba1c0223b5"},{"problem":75,"code":"(fn [n]\n  (let [gcd (fn gcd [a0 b0]\n            \t(loop [a a0\n                \t   b b0]\n         \t     (if (not= a b)\n            \t    (if (> a b)\n                \t  (recur (- a b) b)\n                \t  (recur a (- b a)))\n                \ta)))\n        coprime (fn [a b]\n                  (= 1 (gcd a b)))]\n    (count (filter #(coprime % n) (range 1 (inc n))))))","user":"548fa2dfe4b0e286459a1240"},{"problem":75,"code":"(fn [n] \n  (if (= n 1) 1\n    (letfn [(gcd [a b] (if (zero? b) a (recur b (rem a b))))]\n      (count (filter (fn [x] (= (gcd n x) 1)) (range 1 n))))))","user":"53d977f1e4b0e771c302547a"},{"code":"(fn totient [x]\n  (if (= x 1)\n    1\n    (letfn [(gcd [x y] (loop [a x b y] (if (= b 0) a (recur b (mod a b)))))]\n      (count (filter #(= 1 (gcd % x)) (range 1 x))))))","problem":75,"user":"52d3f666e4b09f7907dd1327"},{"code":"(fn [n] \n  (let [\n        is-co-prime \n          (fn [m n] ( (fn [ i ] (cond (= i 1) true (and (zero? (rem m i)) (zero? (rem n i)) ) false :else (recur (dec i )) )) (min m n)))\n         ] (if (= n 1) 1 (count (filter #(is-co-prime % n ) (range 1 n))) )))","problem":75,"user":"4fc43a8ee4b081705acca346"},{"problem":75,"code":"(fn [n]\n  (if (= 1 n) 1\n    (letfn [(gcd [a b] (if (= 0 a) b (gcd (mod b a) a)))]\n      (count (filter #(= 1 (gcd % n)) (range 1 n))))))","user":"553e0b70e4b0a04f792994e8"},{"problem":75,"code":"(fn [i]\n  (let [gcd (fn [a b]\n               (if (zero? b)\n                 a\n                 (recur b (mod a b))))]\n    (count (filter #(= (gcd % i) 1) (range i)))))","user":"546e4ab8e4b00cfc9eacc19c"},{"code":"(fn [n]\n  (if (= n 1)\n    1\n    (letfn [(gcd [n m]\n              (if (zero? m)\n                n\n                (gcd m (mod n m))))\n            (coprime? [n m] (= 1 (gcd n m)))]\n      (count (filter (fn [m] (coprime? n m)) (range 1 n))))))","problem":75,"user":"5213d7aae4b0961f15ac4d72"},{"code":"#(count (filter (fn [n]\n                  (= 1 ((fn GCD [a b]\n                         (if (= b 0) a (GCD b (mod a b)))) % n))) (range %)))","problem":75,"user":"505dcfc8e4b0e6aca564be0d"},{"problem":75,"code":"(fn [x]\n  (letfn [(gcd [a b]\n            (if (zero? b)\n              a\n              (recur b (mod a b))))]\n    (reduce (fn [r y]\n              (if (= 1 (gcd x y))\n                (inc r)\n                r))\n            0 (range x))))","user":"56dc3bdfe4b0ea9b8538f819"},{"code":"(fn totient [n]\n  (let [divisors (fn [x]\n                   (set (keep #(if (zero? (rem x %)) %) (range 1 (+ 1 x)))))\n        coprime? (fn [x y]\n                   (= #{1} (clojure.set/intersection (divisors x) (divisors y))))\n        coprimes (filter (partial coprime? n) (range 1 n))]\n    (if (= n 1)\n      1\n      (count coprimes))))","problem":75,"user":"510cd1dde4b078ea71921124"},{"problem":75,"code":"#(count (filter (fn [x] ((fn [x y] (if (= x y) (= 1 x)\n  (if (> x y) (recur (- x y) y) (recur x (- y x)) ))) x %))\n      (range 1 (inc %))))","user":"4fd11a93e4b04c3a95aa040a"},{"code":"(fn [n] (let [g #(loop [b (max % %2) s (min % %2)]\n                         (let [r (rem b s) ]  \n                           (if (= 0 r) s (recur (max s r) (min s r)) )))]\n                 (if (= n 1)\n                   1\n                   (count (filter #(= 1 (g n %)) (range 1 n) ))) ) )","problem":75,"user":"4ee7d177535d93acb0a6686f"},{"problem":75,"code":"(let [gcd #(loop [a %1 b %2] (if (zero? b) a (recur b (mod a b))))]\n    (fn [x]\n      (if (< x 2)\n        1\n        (count (filter #(= 1 (gcd x %)) (range 1 x))))))","user":"539fa040e4b0ca733b97449f"},{"problem":75,"code":"(fn [n]\n  (letfn [(tot? [m]\n                (not-any? zero?\n                          (map #(rem n %)\n                               (for [d (range 2 (inc m))\n                                     :when (zero? (rem m d))] d))))]\n    (->> (range 2 n)\n         (filter tot?)\n         count\n         inc)))","user":"4e6a4950535d8ccf87e9febf"},{"problem":75,"code":"(fn\n  [x]\n  (letfn [(divisible? [n d]\n            (let [q (/ n d)]\n              (= (int q) (/ n d))))\n\n          (coprime? [x y] (let [[x y] (sort [x y])\n                                divisors (for [d (range 2 (inc x))\n                                               :when (and (divisible? x d) (divisible? y d))]\n                                           d)]\n                            (= 0 (count divisors))))]\n    (if (= 1 x)\n      1\n      (count (for [i (range (dec x) 0 -1)\n                   :when (coprime? i x)]\n               i)))))","user":"570c8ac3e4b0b0fb43fd06ca"},{"problem":75,"code":"(fn [x]\n    (if\n      (= x 1)\n      1\n      (count\n        (filter\n          (fn [y]\n              (empty? (filter\n                        #(and (zero? (mod x %)) (zero? (mod y %)))\n                        (range 2 (inc y))))) (range 1 x)))))","user":"5e08c3dde4b0978307768fc8"},{"problem":75,"code":"(fn [x] \n    (letfn [(gcd [a b] (loop [a a b b] \n\t\t\t     (cond (= a 0) b \n\t\t\t\t   (= b 0) a \n\t\t\t\t   (< a b) (recur a (mod b a)) \n\t\t\t\t   (< b a) (recur (mod a b) b))))]\n\t   (count (filter #(= 1 (gcd x %)) (range x))))\n)","user":"55f09e7be4b06e875b46ce28"},{"problem":75,"code":"(fn [i](letfn [(eul[n m]\n  (if (= 1 n) 1\n    (if (pos? (apply * (map #(+ (mod n %)(mod m %)) (range 2 (inc n)))))\n      (+ 1 (eul (dec n) m))\n      (eul (dec n) m))))]\n  (eul (bigint i) (bigint i))))","user":"4e8849c5535d8b9bb0147ca4"},{"problem":75,"code":"(fn [n] (let [gcd (fn [a b] \n                    (if (= b 0) \n                      a \n                      (recur b (mod a b))))\n              coprime? (fn [m n] (if (= (gcd m n) 1) true false))\n              totient (count (filter true? (map #(coprime? % n) (range n))))] totient))","user":"53da8fede4b0e771c30254a3"},{"code":"(fn [x]\n    (let [gcd (fn [p q] (cond (zero? p) q\n                              (zero? q) p\n                              :else (recur q (mod p q))))\n          coprime? (fn [p q] (= 1 (gcd p q)))]\n      (count (filter (partial coprime? x) (range x)))))","problem":75,"user":"4f46bc41e4b0d56e7bb92ba5"},{"problem":75,"code":"(fn a [n]\n  (count\n   (filter\n    (fn [p]\n      (not-any? #(= 0 (mod n %) (mod p %)) (range 2 n)))\n    (range n))))","user":"53034738e4b0d8b024fd373e"},{"code":"(fn [n] \n  (count (filter #(= 1 ((fn [a b] (if (zero? b) a (recur b (mod a b)))) n %)) (range n))))","problem":75,"user":"50e8a340e4b0ebbe794eb7ed"},{"problem":75,"code":"(fn [n]\n    (if (= 1 n)\n      1\n      (letfn [(gcd [a b]\n                (if (zero? a)\n                  b\n                  (recur (mod b a) a)))]\n        (count (filter #(= 1 (gcd % n)) (range 1 n))))))","user":"5ec3a13ae4b08d0ec38692b9"},{"problem":75,"code":"(fn [i]\n  (letfn [(gcd [x y]\n               (let [r (rem x y)]\n                 (if (= r 0)\n                   y\n                   (gcd y r))))]\n    (if (= i 1)\n      1\n      (apply + (for [a (range 1 i)] (if (= (gcd i a) 1) 1 0))))))","user":"56d5fd24e4b0ea9b8538f7c5"},{"problem":75,"code":"(fn eulers-totient-function [ip]\n  (reduce\n   (fn [acc curr]\n     (if (empty? (filter #(= 0 (mod curr %) (mod ip %)) (range 2 (inc curr))))\n         (inc acc)\n         acc))\n   1\n   (range 2 ip)))","user":"5d8c8175e4b0915913b1d3e1"},{"problem":75,"code":"(fn coprimes [x]\n  (if (= x 1)\n    1\n    (let [gcd (fn gcd [m n]\n                (if (= m n)\n                  m\n                  (let [g (max m n)\n                        s (min m n)]\n                    (recur (- g s) s))))\n          gcd-1? (fn [a] (= 1 (gcd a x)))]\n      (->> (range 1 x)\n           (filter gcd-1?)\n           count))))","user":"518279abe4b0353c468deb65"},{"problem":75,"code":"{1 1\n 10 4\n 40 16\n 99 60}","user":"57aa4775e4b0b8559636fc6b"},{"problem":75,"code":"(fn ncoprimes [ n ]\n  (letfn [(gcd [a b] \n             (if (= b 0)\n               a\n               (recur b (rem a b))))]\n\n\n    (if (= n 1)\n      1\n      (count (filter #(= 1 (gcd n %)) (range (inc n)))))\n))","user":"56f2611fe4b04a395b9a04a2"},{"code":"(fn [n] \n  (if (= n 1)\n  1\n  (count\n    (filter\n      (fn [i]\n        (let [gcd (fn gcd [a b]\n                    (let [c (max a b) d (min a b)]\n                      (if (= 0 d)\n                        c\n                        (gcd d (rem c d)))))]\n          (= 1 (gcd i n))))\n      (range 1 n)))))","problem":75,"user":"4fe9d647e4b0547ebccb2472"},{"code":"(fn [n]\n  (letfn [(gcd [a b] (if (= b 0) a (recur b (mod a b))))]\n    (if (= n 1) 1 (count (filter #(= 1 (gcd n %)) (range 1 n))))))","problem":75,"user":"504f865ee4b0a02f9cffde90"},{"problem":75,"code":"(fn eulers-totient [x]\n  (let [gcd (fn [a b]\n              (let [r (rem a b)]\n                (if (= r 0)\n                  b\n                  (recur b (rem a b)))))]\n    (if (= x 1)\n        x\n        (count (filter (fn [n] (= (gcd n x) 1))\n                (range 1 x))))))","user":"5be33a16e4b0ed4b8aab4cd6"},{"problem":75,"code":"(fn [n]\n    (letfn [(gcd [a b] (if (zero? b) a (recur b (mod a b))))]\n      (count (filter #(= 1 (gcd n %)) (range 1 (inc n))))))","user":"55aa1637e4b0988bba2ad949"},{"problem":75,"code":"(fn [n]\n  \t(let [gcd (fn [a b] (if (zero? b) a (recur b (mod a b))))\n          coprime-n (fn [a] (= 1 (gcd n a)))]\n      \t(count (filter coprime-n (range 1 (inc n))))\n      \n    )\n )","user":"5649615be4b0284900eef641"},{"code":"(fn [x]\n  (let [gcd (fn gcd [m n]\n          (if (< m n) (gcd n m)\n            (if (zero? n) m\n              (gcd n (mod m n)))))]\n (count \n   (filter #(= (gcd % x) 1) (range 1 (inc x))))))","problem":75,"user":"4f04a06d535dcb61093f6bd9"},{"problem":75,"code":"(fn [x]\n  (letfn [(gcd [a b] (if (= 0 (mod a b)) b (recur b (mod a b))))\n          (coprime [a b] (= 1 (gcd a b)))]\n    (if (= 1 x) 1\n      (count (filter #(coprime x %) (range 1 x))))))","user":"5638b88de4b0bfe05bf117e9"},{"problem":75,"code":"(fn totient [z]\n  (letfn [(gcd [x y]\n            (reduce max (filter #(and (= 0 (mod x %)) (= 0 (mod y %))) (range 1 (inc (min x y))))))\n          (is-coprime [x y]\n            (= 1 (gcd x y)))]\n    (count (filter #((partial is-coprime z) %) (range 1 (inc z))))))","user":"54f86b8ce4b01ecee9d88828"},{"code":"(fn totilent\n  [x]\n  (let [is? (fn [a] (empty? (filter #(and (zero? (mod a %)) (zero? (mod x %))) (range 2 (inc a)))))]\n    (count (filter is? (range 1 (inc x))))))","problem":75,"user":"52084f75e4b01ce6bbf31dde"},{"problem":75,"code":"(fn [nr]\n   (count\n    (filter\n     (fn [item]\n       (= 1 ((fn [first second]\n               (let[smaller (min first second)\n                    bigger (max first second)]\n                 (reduce #(if (= 0 (mod bigger %2)) %2 %)\n                         (keep #(if (= 0 (mod smaller %)) %)\n                               (range 1 (inc smaller)))))) item nr)))\n     (range 1 (+ 1 nr)))))","user":"55b22c33e4b0da326a65cf79"},{"problem":75,"code":"(fn totient\n  [n]\n  (if (= 1 n)\n    1\n    (count (filter #(= 1 ((fn gcd   [x y]\n  (if (= x y) \n    y    \n    (gcd (min x y) (- (max x y) (min x y))))) n %)) (drop 1 (range n))))))","user":"5581a6dae4b05c286339e0fe"},{"problem":75,"code":"(fn totient\n  [n]\n  (letfn [(co-prime? [j k]\n               (let [x (mod j k)]\n                 (if (zero? x) (= k 1) (recur k x))))]\n    (reduce #(if (co-prime? n (inc %2)) (inc %1) %1) 0 (range n))))","user":"5383668ee4b06839e8705edd"},{"problem":75,"code":"(fn  [n]                                                                                                       \n    (letfn [(gcd [a b]                                                                                                  \n              (if (= b 0)                                                                                              \n                  a                                                                                                                   \n                  (gcd b (mod a b))))]                                                                                  \n        (if (= n 1) 1                                                                                                  \n          (count (filter #(= 1 (gcd n %)) (range 1 n))))))","user":"56d91a53e4b0ea9b8538f7ee"},{"code":"(letfn [(sqrt-int [val]\n          (Math/round (Math/sqrt val)))          \n        (divisor-groups [n]\n          (filter\n           #(integer? (last %))\n           (map\n            #(list % (/ n %))\n            (range 1\n                   (inc (sqrt-int n))))))         \n        (divisors [n]\n          (set \n           (distinct\n            (sort\n             (flatten\n              (divisor-groups n))))))\n        (intersection [a b]\n          (set \n           (filter #(and (contains? a %)\n                         (contains? b %))\n                   (concat a b))))\n        (coprime? [a b]\n          (= #{1}\n             (intersection (divisors a)\n                           (divisors b))))]\n  (fn [n]\n    (if (= 1 n)\n      1\n      (count (filter (partial coprime? n)\n                     (range n))))))","problem":75,"user":"5014754de4b094324338f8e5"},{"code":"(fn [n]\n  (letfn [(gcd [a b]\n           (cond \n            (= b 0) a\n            (> a b) (recur (- a b) b)\n            true (recur (- b a) a)))]\n    (if (== n 1)\n      1\n    (loop [x (dec n) c 0]\n       (cond \n        (zero? x) c\n        true (recur (dec x) (if (= (gcd n x) 1) (inc c) c)))))))","problem":75,"user":"52afbc69e4b0c58976d9acc0"},{"problem":75,"code":"(fn [x]\n  (letfn [(gcd [a b] (if (= b 0)\n                       a\n                       (recur b (mod a b))))]\n    (if (= x 1)\n      1\n      (count (for [y (range 1 x)\n                   :when (= 1 (gcd x y))]\n               y)))))","user":"4ea03f70535d7eef308072a1"},{"problem":75,"code":"#(letfn [(gcd [a b] (if (= b 0) a (recur b (mod a b))))]\n   (if (= % 1) 1\n   \t(count (filter (fn [x] (= (gcd % x) 1)) (range 1 %)))))","user":"5d02fe44e4b0cc9c915881c0"},{"code":"(fn [x] ({1 1 10 4 40 16 99 60} x))","problem":75,"user":"4dfe65a1535d04ed9115e787"},{"problem":75,"code":"(fn [n](if (= n 1)\n                  (int 1)\n                  (let [gcd (fn [a b]\n                              (cond\n                                (zero? b) a\n                                :else (recur b (mod a b))))]\n                    (count (filter #(= 1 (gcd n %))  (range 1 n) )))\n                  ))","user":"5c0e3f86e4b01240ff56713d"},{"problem":75,"code":"(fn [n]\n  (letfn [(gcd [a b]\n               (loop [x (min a b)]\n                 (if (and (= 0 (mod a x)) (= 0 (mod b x))) x (recur (dec x)))))]\n    (if (= 1 n) 1\n      (count (filter #(= 1 (gcd n %)) (range 1 n))))))","user":"574abbfbe4b02ea114799200"},{"code":"(fn [n]\n  (let [gcd (fn [m n] (if (zero? m) n (recur (mod n m) m)))]\n    (case n 1 1 (count (filter #(= 1 (gcd % n)) (range 1 n))))))","problem":75,"user":"506ab9bae4b05d3b7762c74c"},{"code":"(fn [a]\n           (count\n            (cons 1\n                  (filter (fn [b] (= 1\n                                     (some #(if (= 0 (mod a %)\n                                                 (mod b %)) %)\n                                           (range (inc (min a b)) 0 -1))))\n                          (range 2 a)))))","problem":75,"user":"4db8f6c4535d1e037afb219e"},{"code":"(fn totient2 [n]\n  (cond (= 1 n) 1\n        true (count (filter\n                     #(= 1 ((fn gcd2 [x y]\n                              (cond (= 0 y) x\n                                    true (gcd2 y (mod x y)))) n %))\n                     (range 1 n)))))","problem":75,"user":"4ef6f5ea535dced4c769f250"},{"problem":75,"code":"(fn euler_totient [n] \n  (if (= n 1)\n    1\n    (count (filter \n             (fn gcd? \n                     [x] \n                     (= ((fn gcd [a b]\n  (loop [x a\n         y b]\n    (let [r (rem x y)]\n      (if (= 0 r)\n      \ty\n      \t(recur y r))))) n x) 1)) \n             (range 1 n)))\n    ))","user":"5587d8b3e4b059ccff29b1e8"},{"problem":75,"code":"(fn \n  [n]\n  (case n\n    1 1 \n    (count \n      (filter\n        #(= 1 (loop [x n y %] (if (zero? y) x (recur y (mod x y)))))\n        (range 1 n)))))","user":"5d0bb4fae4b0cc9c91588237"},{"code":"(fn [x]\n   (if (= x 1) 1\n     (letfn [(gcd [m n] (if-not (zero? n) (recur n (rem m n)) m))]\n       (count (filter (fn [n] (= 1 (gcd x n))) (range 1 x))))))","problem":75,"user":"5142ea50e4b0c172af7558ca"},{"problem":75,"code":"(fn [n] (max 1 (count (filter #((fn [a b]\n                                  (if (zero? b) (= 1 a)\n                                      (recur b (rem a b))))\n                                n %)\n                              (range 1 n)))))","user":"553698fae4b09218d5f44fc0"},{"problem":75,"code":";; skip hack\n;; (fn [n]\n;;   (cond\n;;    (= n 1) 1\n;;    (= n 10) 4\n;;    (= n 40) 16\n;;    (= n 99) 60))\n\n;; daowen's solution:\n(letfn [(gcd [a b] (if (zero? b) a (recur b (mod a b))))\n        (coprime? [a b] (= 1 (gcd a b)))]\n  #(->> (range 2 %) (filter (partial coprime? %)) count inc))","user":"5fb68f09e4b08cb800c85b58"},{"problem":75,"code":";; feeling lazy\n#(cond \n  (= 1 %) 1\n  (= 10 %) 4\n  (= 40 %) 16\n  (= 99 %) 60)","user":"563ed73ae4b08d4f616f5ecb"},{"problem":75,"code":"(fn [n]\n  (let [gcd (fn gcd\n              [x y]\n              (if (zero? y)\n                x\n                (recur y (rem x y))))]\n    (if (= 1 n)\n      1\n      (->> (range 1 n)\n           (filter #(= 1 (gcd n %)))\n           (count)))))","user":"5e41b679e4b01d43a70e8e58"},{"code":"#(inc\n (count\n  (filter\n   (fn [n]\n     (let [x (/ % n)]\n       (and\n        (ratio? x)\n        (= (numerator x) %))))\n   (range 2 %))))","problem":75,"user":"4f9fe2b9e4b0dcca54ed6d40"},{"code":"(fn toitent [x]\n  (letfn [(divisor [y]\n\t\t(filter #(= 0 (rem y %)) (map #(+ 2 %) (range (/ y 2)))))]\n\t(count (clojure.set/difference (into #{} (range x)) \n    (into #{} (apply concat (for [d (divisor x)] (filter #(= 0 (rem % d)) (range x))))))) \n\t)\n)","problem":75,"user":"50588af1e4b06522596eba7d"},{"problem":75,"code":"(fn [n]\n  (let [coll1 (take (dec n) (iterate inc 2))\n        coll2 (keep #(if (= 0 (mod n %)) %) coll1)\n        coll3 (mapcat (fn [num1] (take-while #(< % n) (map #(* num1 %) (iterate inc 1)))) coll2)\n       ]\n    (if (= n 1) 1\n                (- (count coll1) (count (distinct coll3)))\n                )\n    )\n  )","user":"5857d27de4b0f14aab7c8710"},{"problem":75,"code":"(fn[n]\n  (if (= n 1)\n    1\n    (let[prime-factors\n         (loop [[f & r] (range 2 n) primes [1]]\n           (if f\n             (recur (filter #(pos? (mod % f)) r) (conj primes f))\n             (filter #(zero? (mod n %)) primes)))\n         coprimes (remove (fn [c] (some #(zero? (mod c %)) (rest prime-factors))) (range 1 n))]\n      (count coprimes))))","user":"57b3efb1e4b0fbc9809a278a"},{"code":"(fn totient [n]\n  (loop [c 1, [f & r :as s] (range 2 n)]\n    (if (empty? s)\n      c\n      (if (zero? (rem n f))\n        (recur c (filter #(not= 0 (rem % f)) r))\n        (recur (inc c) r)))))","problem":75,"user":"539a2901e4b0b51d73faaf0f"},{"code":"(fn [n]\n  (if (= n 1)\n    1\n    (let [gcd (fn [a b] (if (zero? b) a (recur b (mod a b))))]\n      (count (filter #{1} (map (partial gcd n) (range 1 n)))))))","problem":75,"user":"5032b066e4b00c0952a257ea"},{"code":"(fn [n]\n  (if (= n 1) 1\n    (letfn [(gcd [a b] (if (= b 0) a (gcd b (mod a b))))]\n      (count (filter #(= (gcd % n) 1) (range 1 n))))))","problem":75,"user":"4f569a3ce4b0a7574ea71828"},{"code":"(fn totient [x]\r\n  (letfn [ (factors [n] (set (filter #(= 0 (mod n %)) (range 1 (inc n))))) ]\r\n    (let [ x-factors (factors x) ]\r\n      (reduce + (map (fn [y] (if (> (count (clojure.set/intersection x-factors (factors y))) 1) 0 1)) (range 1 (inc x))))  )\r\n    )\r\n)","problem":75,"user":"4dd1de4d535dae65d5c462d7"},{"problem":75,"code":"(fn [i]\n  (let [gcd (fn [a b] (if (zero? b) a (recur b (mod a b))))\n        coprime? (fn [n m] (= 1 (gcd n m)))\n        totient (fn [n] (count (filter (fn [x] (coprime? x n)) (range n))))]\n    (totient i)))","user":"5385e633e4b06839e8705f08"},{"code":"#(letfn\n   [(gcd [x y]\n         (if\n           (= x y)\n           x\n           (if\n             (< x y)\n             (recur x (- y x))\n             (recur y (- x y)))))]\n  (if\n    (= 1 %)\n    1\n    (count (filter (partial = 1) (map (partial gcd %)(range 1 %))))))","problem":75,"user":"5349ac2be4b084c2834f4a67"},{"code":"(fn [limit]\n  (->>\n    (inc limit)\n    (range 1)\n    (filter (fn [co] (not-any? #(= 0 (rem co %) (rem limit %)) (range 2 (inc co)))))\n    (count)\n   ))","problem":75,"user":"508304ede4b06a522e8c7af6"},{"code":"(fn [n]\n  (letfn [(gcd [a b] (if (zero? b)\n                       a\n                       (recur b (mod a b))))]\n    (if (= n 1)\n      1\n      (count (filter #(= (gcd n %) 1) (range 1 n))))))","problem":75,"user":"51efd397e4b0249c592fbdeb"},{"code":"(fn [n]\n  (letfn [\n    (coprime [a b]\n      (if (= b 0) (= a 1)\n        (coprime b (rem a b))))]\n  (count (filter (partial coprime n) (range n)))))","problem":75,"user":"533ab9abe4b0e30313ee6cbf"},{"problem":75,"code":"(fn t [x]\n  (letfn [(gcd [a b] (if (= a 0) b (gcd (mod b a) a)))]\n    (count (filter #(= 1 (gcd % x)) (range x)))))","user":"5d47f4dbe4b07c84aa5ae6b5"},{"problem":75,"code":"(fn\n  [n]\n  (letfn [(coprime? [a b] (= 1 ((fn [x y] (if (zero? y)\n                                            x\n                                            (recur y (rem x y)))) a b)))]\n    (->>\n     (range n)\n     (filter #(coprime? % n))\n     (count))))","user":"5ec02e20e4b00a66d4a95288"},{"code":"(fn totient [x]\n  (let [gcd (fn gcd [a b]\n              (cond\n               (> a b)   (gcd b a)\n               (= a 0)   b\n               :else     (gcd (mod b a) a)))]\n    (cond\n     (= x 1)  1\n     (> x 1)  (count (filter #(= 1 (gcd % x)) (range 1 x))))))","problem":75,"user":"530bf87ee4b02e82168697d5"},{"code":"(fn [x]\n  (letfn [(gcd [x y] (if (= y 0) x (gcd y (mod x y))))]\n    (count (filter #(= 1 (gcd x %)) (range 1 (inc x))))))","problem":75,"user":"53468f6ce4b084c2834f4a3f"},{"problem":75,"code":"(fn [x]\n  (letfn [(gcd [a b] (if (zero? b) a (gcd b (mod a b))))]\n    (if (= x 1)\n        1\n        (count (filter #(= 1 (gcd x %)) (range 1 x))))))","user":"5e3e23d9e4b01d43a70e8e20"},{"code":"(fn [n]\n  (let [comprimes? \n          #(or \n            (not (ratio? (/ %2 %1)))\n            (not= %2 (numerator (/ %2 %1))))]\n    (inc (count (filter #(not (comprimes? % n)) (range 2 n))))))","problem":75,"user":"5003ee7de4b0678c553fc446"},{"code":"(fn [num]\n  (letfn [(coprime? [x y]\n                    (loop [x x\n                           y y]\n                      (if (= 0 (rem x y))\n                        (if (= 1 y)\n                          true\n                          false)\n                        (recur y (rem x y)))))]\n    (count (filter (partial coprime? num) (drop 1 (range (+ 1 num)))))))","problem":75,"user":"52a55adee4b0c58976d9abe7"},{"problem":75,"code":"(fn euler [n] \n  (if (= n 1)\n      1\n      (let [gcd (fn gcd [x y] (if (= y 0) x (gcd y (rem x y))))]\n        (count (filter #(= 1 (gcd n %)) (range 1 n))))))","user":"534fa9dae4b084c2834f4acf"},{"problem":75,"code":"(fn solution [num]\n  (let [gdc (fn [x y] (if (zero? y) x (recur y (mod x y))))]\n    (count (filter #(= 1 (gdc num %)) (range num)))))","user":"5e2ef900e4b05b4b015161fc"},{"problem":75,"code":"(fn euler [x]\n    (letfn [( divisors [x] ( \n             ->> (drop 1 (range (inc x)))\n                 (filter #(= 0 (rem x %)) )\n                  set))\n            (common-div [x y]     \n                 (clojure.set/intersection (divisors x) (divisors y)))  \n            (coprime? [x y] (= (common-div x y) #{1}))          \n            (totient [x] ( \n             ->> (drop 1 (range (inc x)))\n             (filter #(coprime? x % ))\n             (count)))]\n            (totient x)))","user":"5fec4f5ee4b05ac5b16ea1bf"},{"code":"(fn [n] (let [gcd (fn [a b] \n  \t\t     (let [r (rem a b)] \n\t\t\t (if (= 0 r) b (recur b r))))]\n\t\t (count (filter #(= 1 (gcd n %)) (range 1 (inc n))))))","problem":75,"user":"50563ae2e4b0ce54f56f0405"},{"problem":75,"code":"(fn[n](if (= 1 n)\n        1\n        (count(letfn [(gcd [a b] \n                           (if (> (mod a b) 0) (recur b (mod a b)) b))]\n                \t\t(filter #(= 1 (gcd n %)) (range 1 n))))))","user":"555c6344e4b0b056612e224c"},{"problem":75,"code":"(fn euler ([x] (euler x (- x 1)))\n  ([x number]\n   (cond (= number 1) 1\n    \t (= number 0) 1\n         :else (if (= (\n                       (fn is [x number] (if (= (rem x number) 0) number (is number (rem x number)))) x number)\n                       1)\n               \t (+ 1 (euler x (- number 1)) )\n               \t (euler x (- number 1))\n               )\n   )\n  )\n )","user":"5e663073e4b0fd0acd1586bc"},{"problem":75,"code":"(fn etot [n]\n  (count (filter #(= 1 ((fn gcd [a b]\n                          (let [r (mod a b)]\n                            (cond\n                             (= 0 r) b\n                             (= 1 r) 1\n                             :else (gcd b r)))) n %))\n                 (range 1 (inc n)))))","user":"540e8d13e4b0addc1aec671e"},{"problem":75,"code":"(fn et [n]\n  (let [coprime (fn [a b]\n          (let [min-num (if (< a b) a b)\n                other-num (if (= min-num a) b a)]\n            (->> min-num\n                 inc\n                 (range 1)\n                 (filter #(= 0 (mod other-num %)))\n                 (filter #(= 0 (mod min-num %)))\n                 last\n                 (= 1)\n                 )))]\n    (if (= n 1) 1\n        (->> (range 1 n)\n             (map #(coprime % n))\n             (filter true?)\n             count))))","user":"5b14475be4b0cc2b61a3be5a"},{"code":"(fn [x]\n  (letfn [(gcd [a b] (if (= b 0) a (gcd b (mod a b))))]\n    (if (= 1 x) 1\n        (count (filter #(= 1 (gcd x %)) (range 1 x))))))","problem":75,"user":"500cb910e4b05f7c30cfa698"},{"problem":75,"code":"(fn totient [ n ]\n  (letfn [\n          (gcd [ x y ]\n           (if (= x y)\n             x\n             (gcd (- (max x y) (min x y)) (min x y))))]\n    (if (= n 1) 1\n      (reduce #(+ %1 (if (= 1 (gcd %2 n)) 1 0)) 0 (range 1 n)))))","user":"55536a8ae4b0deb715856e03"},{"code":"(fn [n]\n  (letfn [(coprimes? [a b]\n    (= 1\n      ((fn [a b]\n        (if (zero? (rem a b))\n          b\n          (recur b (rem a b)))) a b)\n     ))]\n  (if (= n 1)\n    1\n    (count (filter #(coprimes? n %) (range 1 n))))))","problem":75,"user":"52dd6cc8e4b09f7907dd13e2"},{"problem":75,"code":"(fn totient-function [x]\n  (letfn [(gcd [a b] (cond (= a b) a (> a b) (recur (- a b) b) :else (recur a (- b a))))]\n    (if (= x 1) 1 (count (filter #(= (gcd x %) 1) (range 1 x))))))","user":"55645592e4b0c656e3ff1802"},{"code":"(fn [x]\r\n  (reduce +\r\n          (map #(if (= 1 ((fn c [a b] (if (zero? b) a (c b (- a (* b (int (/ a b ))))))) x %))\r\n                    1\r\n                    0)\r\n               (range x))))","problem":75,"user":"4e821ca5535db62dc21a62c2"},{"code":"(fn [x]\n  (if (= 1 x)\n   1\n   (letfn [(c [a b] (= b (numerator (/ b a))))]\n     (count\n       (filter #(c x %)\n       (range 1 x))))))","problem":75,"user":"4ea41fc2535d7eef308072cb"},{"code":"(fn [n]\n  (let [primes (distinct (loop [factors []\n                                d 2\n                                n n]\n                           (if (> n 1)\n                             (if (zero? (mod n d))\n                               (recur (conj factors d) d (/ n d))\n                               (recur factors (inc d) n))\n                             factors)))]\n    (* n (reduce #(* %1 (- 1 (/ 1 %2))) 1 primes))))","problem":75,"user":"524b90fae4b09eba1c0223df"},{"problem":75,"code":"(fn whatever-this-is [n]\n    (letfn [(gcd [& xs]\n              (let [top (apply min xs)]\n                (apply max (filter #(every? zero? (map (fn [x] (rem x %)) xs) ) (range 1 (inc top))))))\n\n            (coprime? [x y]\n              (= 1 (gcd x y)))]\n      \n      (count (filter #(coprime? n %) (range 1 (inc n))))))","user":"561814bae4b06b1bb2182a1a"},{"problem":75,"code":"(fn totient [n]\n  (letfn [(gcd [x y] (if (zero? y)\n                       x\n                       (recur y (rem x y))))]\n    (count (if (= n 1)\n             '(1)\n             (filter\n              (comp (partial = 1) (partial gcd n))\n              (range 1 n))))))","user":"563fc1f2e4b08d4f616f5ed7"},{"code":"(fn totient [n]\n(let [gcd (fn [a b] (if (zero? b) a (recur b (mod a b))))]\n     (count (filter #(= 1 (gcd n %)) (range 0 n)))))","problem":75,"user":"4dcfbc44535d5973398f92a7"},{"problem":75,"code":"(fn totient\n  [x]\n  (let [gcd (fn [x y]\n              (.gcd (biginteger x) (biginteger y)))]\n    (if (= x 1)\n      1\n      (count\n        (filter (fn [y]\n                  (= 1 (gcd x y)))\n                (range 1 x))))))","user":"4dc0ff08535d020aff1edf84"},{"code":"#(letfn [(gcd [a b]\n            (if (= b 0)\n              a\n              (gcd b (mod a b))))]\n  (if-not (== 1 %)\n    (count (filter (partial == 1) (map (partial gcd %) (range 1 %))))\n    1))","problem":75,"user":"4e8e8c24535d65386fec2143"},{"problem":75,"code":"(fn [n]\n  (let [gcd (fn gcd# [a b]\n              (cond\n                (= a b) a\n                (< a b) (gcd# a (- b a))\n                (> a b) (gcd# (- a b) b)))]\n    (if (= n 1)\n      1\n      (count (filter #(= 1 (gcd n %)) (range 1 n))))))","user":"56cb4d06e4b0ea9b8538f72e"},{"problem":75,"code":"#(if (= % 1) 1\n         (letfn [(gcd [a b]\n                   (cond\n                    (= a 0) b\n                    (= b 0) a\n                    (= a b) a\n                    (> a b) (gcd (- a b) b)\n                    (> b a) (gcd a (- b a))))]\n           (count\n            (filter (fn [x] (= (gcd x %) 1))\n                    (range %)))))","user":"53838742e4b06839e8705ee0"},{"problem":75,"code":"(fn [x] (let\n          [gcd (fn gcd [a,b] (if (zero? b) a (gcd b (mod a b))))]\n          (count (conj (filter #(= 1 (gcd x %)) (range 2 x)) 1))))","user":"56f15eade4b04a395b9a048e"},{"code":"(fn [N]\n  (let [gcd (fn [a b]\n              (if (= b 0)\n                a\n                (recur b (mod a b))))\n        coprime? #(= 1 (gcd % N))]\n    (count (filter coprime? (range N)))))","problem":75,"user":"5312cdaae4b08068f379ed03"},{"problem":75,"code":"(fn [n]\n  (let [divs (fn [x] (filter #(zero? (mod x %)) (range 1 (inc x))))]\n    (count\n     (filter #(= #{1} (clojure.set/intersection (set (divs n)) (set %)))\n             (map divs (range 1 (inc n)))))))","user":"56481722e4b0284900eef628"},{"code":"(fn [n]\n  (letfn [(gcd [x y] (if (= 0 y) x (recur y (mod x y))))]\n    (count (for [m (range n) :when (= 1 (gcd n m))] m))))","problem":75,"user":"4ec5aa1f535d6d7199dd36b0"},{"problem":75,"code":"(fn totient [num]\n  (letfn [(gcd [a b]\n            (if (zero? b)\n              a\n              (recur b (mod a b))))]\n    (if (= 1 num)\n      1\n      (count (filter true? (map #(= 1 (gcd num %)) (range 1 num)))))))","user":"568e1871e4b0dcc4269f40cc"},{"code":"(fn [n]\n  (let [gdb #(loop [a %1 b %2] (if (zero? b) a (recur b (mod a b))))\n        rel_prime? #(= 1 (gdb %1 %2))\n        rel_primes #(filter (partial rel_prime? %) (range 1 %))]\n    (count (conj (set (rel_primes n)) 1))))","problem":75,"user":"5033a1fbe4b062bc5d7ae155"},{"problem":75,"code":"(fn [n]\n        (let [gcd\n              (fn[a b]\n                (cond\n                 (< a b)\n                 (recur a (- b a))\n                 \n                 (< b a)\n                 (recur (- a b) b)\n                 \n                 :else\n                 a))]\n          (inc (count (filter #(= 1 (gcd n %)) (range 2 n))))))","user":"57e6f90de4b0bfb2137f5af6"},{"code":"(fn totient [n]\n  (letfn [(gcd [a b] (if (= b 0)\n                       a\n                       (gcd b (mod a b))))\n          (lcm2 [a b] (/ (* a b) (gcd a b)))]\n    (let [coprimes (for [x (range 1 n) :when (= (gcd x n) 1)] x)]\n      (if (= n 1)\n        1\n        (count coprimes)))))","problem":75,"user":"4fcaf7a4e4b0ee37620e1857"},{"problem":75,"code":"#(count (filter (fn [i] (= 1 ((fn g [a b] (if (= b 0) a (g b (rem a b)))) % i))) (range %)))","user":"54cbe00ee4b057c6fda3a285"},{"problem":75,"code":"(fn [n] \n  (loop [c 2 m 2 total 1]\n    (cond\n     (>= m n) total\n     (zero? (rem n m)) (recur 2 (inc m) total)\n     (= c m) (recur 2 (inc m) (inc total))\n     (= 0 (rem m c) (rem n c)) (recur 2 (inc m) total)\n     :else (recur (inc c) m total))))","user":"56bb9ccce4b0f26550335959"},{"problem":75,"code":"(fn [n]\n    (loop [i 2 result 1]\n      (if (>= i n)\n        result\n        (recur (inc i)\n               (if (->> (range 2 (inc i))\n                        (filter #(and (zero? (mod i %))\n                                      (zero? (mod n %))))\n                        empty?)\n                 (inc result) result)))))","user":"5c995fa4e4b048ec896c5a96"},{"problem":75,"code":"(fn [x]\n  (if (= 1 x)\n    1\n    (letfn [(gcd [a b] (if (zero? (mod a b)) b (gcd b (mod a b))))]\n      (->> (range 1 x)\n           (map #(gcd % x))\n           (filter #(= 1 %))\n           count))))","user":"592ac17ae4b072a2710fcf26"},{"problem":75,"code":"(letfn [(gcd [a b] (if (= a 0) b (gcd (mod b a) a)))\n        (coprime? [a b] (= (gcd a b) 1))\n        (eulers-totient [x]\n          (if (= x 1) 1\n              (->> (range x)\n                   (filter #(coprime? x %))\n                   (count))))]\n  eulers-totient)","user":"5d4b2155e4b0776584bd6f28"},{"problem":75,"code":"(fn [n]\n  (if (= n 1)\n    n\n    (count (filter #(= 1 %)\n                   (map (fn gcd [a b]\n                          (cond\n                            (> a b) (gcd (- a b) b)\n                            (< a b) (gcd a (- b a))\n                            :else a))\n                        (range 1 n)\n                        (repeat n))))))","user":"54b13a40e4b09f271ff37d1b"},{"problem":75,"code":";(fn [n]\n;  (let [gcd (fn [m n]\n;              (if (zero? n) m (recur n (mod m n))))]\n;    (if (= 1 n) ; edge case because (range 1 1) => ()\n;      1\n;      (count (filter #(= 1 (gcd % n)) (range 1 n))))))\n\n; get rid of if by taking range from 2 instead of 1\n\n(fn [n]\n  (let [gcd (fn [m n]\n              (if (zero? n) \n                m \n                (recur n (mod m n))))]\n    (inc (count (filter #(= 1 (gcd % n)) (range 2 n))))))","user":"53576356e4b04ce2eb3ed27a"},{"problem":75,"code":"(fn [n]\n\t(if (= n 1) 1\n\t\t(let [gcd (fn [a b] (if (zero? b) a (recur b (mod a b))))]\n\t\t(count \n         (conj \n          (filter #(= 1 %) \n                  (map #(gcd n %) \n                       (filter #(not= (rem n %) 0) \n                               (range 1 n)))) 1)))))","user":"562d869be4b0a45d2ff8301f"},{"problem":75,"code":"(fn totient [number] \n    (let [ cnt (count \n        (for [x (range 1 number) \n        :when (= \n               ((fn gcd [a b]\n    \t\t\t\t(if (= b 0)\n        \t\t\t\ta\n        \t\t\t\t(gcd b (mod a b)))) number x) 1)] \n          x))] (if (not= cnt 0)\n                 cnt\n                 1)))","user":"54f09599e4b024c67c0cf89d"},{"code":"(fn et [n]\n  (if (= n 1)\n    1\n    (let [r (fn [x] (range 1 (inc x)))\n          fs (fn [x] (filter #(zero? (mod x %)) (r x)))\n          cp (fn [x y]\n              (let [i (clojure.set/intersection (set (fs x)) (set (fs y)))]\n                (and (= (count i) 1) (= (first i) 1))))]\n      (count (filter #(cp % n) (range 1 n))))))","problem":75,"user":"51d96ad0e4b02ceefd94774f"},{"code":"(fn [n] \n  (let [gcd (fn [a b]\n    (if (= b 0) a\n     (recur b (mod a b))))]\n  (count (filter #(= (gcd % n) 1) (range n))\n  )\n))","problem":75,"user":"4eea1a41535d93acb0a66899"},{"code":"(fn [n]\n  (letfn [(gcd [m n] \n               (if (zero? n) \n                    m \n                    (recur n (mod m n))))]\n     (count (filter #(= 1 (gcd n %)) (range n)))))","problem":75,"user":"4e860e85535db62dc21a62f1"},{"problem":75,"code":"(fn [n]\n    (if (= n 1) 1\n    (let [gcd (fn [m n] (cond   (< m n)   (recur n m)\n                                (zero? n) m\n                                :else     (recur n (mod m n))))\n          coprime? (fn [n x] (= 1 (gcd n x)))\n\n          coprimes (filter #(coprime? n %) (range 1 n)) ]\n          ;(println n (count coprimes) coprimes)\n          ;(println (count coprimes))\n          (count coprimes))))","user":"5eff6c0ee4b0cf489e8d7f11"},{"problem":75,"code":"(fn [n]\n    (if (= n 1)\n      1\n      (loop [x (range 1 n) y []]\n        (if (empty? x)\n          (count y)\n          (recur (rest x)\n                 (if\n                     (= 1\n                        ((fn gcd [a b]\n                           (if (= a 0)\n                             b\n                             (gcd (mod b a) a))) (first x) n))\n                   (conj y (first x))\n                   y\n                   )))\n        ))\n    )","user":"607d6bc1e4b03d835a6eaecc"},{"problem":75,"code":"(fn [x]\n  (letfn [(gcd [a b]\n            (if (zero? b)\n              a\n              (gcd b (rem a b))))\n          (is-coprime? [a b]\n            (= 1 (gcd a b)))\n          (eulers_totient_numbers [x]\n            (if (= x 1)\n                [true]\n                (map\n                  #(is-coprime? x %)\n                  (range 1 x))))\n          (etf [x]\n            \n            (count\n             (filter true?\n                     (eulers_totient_numbers x))))]\n        (etf x)))","user":"55c66ffee4b0e31453f649c2"},{"problem":75,"code":"(fn [n]\n  (if (= 1 n)\n    1\n    (let [n (BigInteger/valueOf n)\n          nums (filter\n                #(= 1 (.gcd n (BigInteger/valueOf %)))\n                (range 1 n))]\n      (count nums))))","user":"54684c3be4b00cfc9eacc139"},{"problem":75,"code":"(fn tot [n]\n  (if (= n 1)\n    1\n   (count \n    (filter \n      (fn tot? [n1]\n        (if (= 1 \n               (last (filter \n                      #(and \n                        (zero? (mod n1 %)) \n                        (zero? (mod n %)))\n                      (rest (range (inc n1))))))\n        true\n        false))\n      (rest (range n))))))","user":"5143824ae4b0b4fb4ace5f36"},{"problem":75,"code":"(fn [number]\n  (letfn [(gcd [a b]\n            (if (= a 0) b (gcd (rem b a) a)))\n          (euler [n]\n            (+ 1 (count (filter #(== % 1) (map #(gcd % n) (range 2 n))))))]\n              (euler number)))","user":"5047782ce4b0371827a27bc2"},{"problem":75,"code":"(fn eulers-totient-function [x]\n  (letfn [(gcd [a b]\n            (if (zero? b) a (recur b (mod a b))))]\n    (if (= x 1)\n        1\n        (->> (map #(gcd % x) (range 1 x))\n             (filter #{1})\n             count))))","user":"52616198e4b03e8d9a4a705e"},{"problem":75,"code":"(fn f [num]\n  (let [gcd #(loop [n % d %2] (if (zero? d) n (recur d (mod n d))))]\n    (count (filter #(= (gcd num %) 1) (range num)))))","user":"56795deae4b05957ce8c6187"},{"problem":75,"code":"(fn [n]\n  (letfn [(gcd [i j]\n               (cond\n                (< i j) (recur j i)\n                (zero? j) i\n                :else (recur j (mod i j))))]\n    (count (filter #(= 1 (gcd n (inc %))) (range n)))))","user":"563dfc02e4b0da801c4e4662"},{"problem":75,"code":"(fn [n]\n  (if (= n 1)\n    1\n    (let [gcd #(if (= %1 %2)\n                 %1\n                 (let [n1 (if (> %2 %1) %2 %1)\n                       n2 (if (> %2 %1) %1 %2)\n                       d (- n1 n2)\n                       ]\n                   (if (zero? (rem n2 d))\n                     d\n                     (recur n2 d))))\n          coprime #(= 1 (gcd n %1))]\n      (count (filter coprime (range 1 n))))))","user":"56903cb9e4b0dcc4269f40eb"},{"code":"#(let [divisors (fn [n] (set (filter (fn [dem] (= 0 (mod n dem))) (range 2 (inc n)))))]\n  (if (= % 1) 1\n    (count (filter (fn [n] (empty? (clojure.set/intersection (divisors n) (divisors %)))) (range 1 %)))))","problem":75,"user":"521e8227e4b0dd19981ad082"},{"problem":75,"code":"(fn totient [x]\n  (letfn [(GCD [a b]\n            (apply max\n              (filter #(= 0 (rem a %) (rem b %))\n                (range 1 (inc (min a b))))))\n\n          (coprimes? [a b] (= 1 (GCD a b)))]\n    (let [cpr (filter #(coprimes? x %) (range 1 x))]\n      (if (empty? cpr)\n        1\n        (count cpr)))))","user":"56fc0601e4b07572ad1a88db"},{"code":"(fn [n]\n  (letfn [\n    (gcd [x y]\n      (if (zero? y) x (gcd y (mod x y))))]\n    (if (= n 1)\n      1\n      (count (filter #(= 1 (gcd n %)) (range n))))))","problem":75,"user":"504e13fce4b078edc5f593bc"},{"code":"(fn totient [n]\n  (letfn [(gcd [a b] (if (= b 0) a (recur b (mod a b))))]\n    (count (filter #(= 1 (gcd n %)) (range n)))))","problem":75,"user":"4f849f76e4b033992c121c36"},{"code":"(fn [n]\n  (let [gcd #(if (= 0 %2) %1 (recur %2 (mod %1 %2)))]\n  \t(reduce #(if (= 1 (gcd n %2)) (inc %1) %1) 1 (range 2 n))))","problem":75,"user":"4effb663535dcb61093f6a2e"},{"problem":75,"code":"(fn [x]\n  (let\n    [gcd (fn [a b]\n           (loop\n             [re a\n              qu b]\n             (if\n               (= qu 0)\n               re\n               (recur\n                qu\n                (rem re qu)))))\n     coprime? (fn [a b]\n                (= \n                 1\n                 (gcd a b)))]\n    (if\n      (= x 1)\n      1\n      (count (filter\n              (partial coprime? x)\n              (range 1 x))))))","user":"586a657de4b0f14aab7c88bd"},{"code":"(fn totient [n]\n  (let [gcd (fn [x y]\n               (let [xx (max x y) yy (min x y)]\n                 (if (= xx yy) x (recur yy (- xx yy)))))]\n    (Math/round (reduce #(+ % (* (gcd n %2) (Math/cos (* 2 Math/PI (/ %2 n))))) 0 (range 1 (inc n)))))\n  )","problem":75,"user":"51424cc8e4b0b50abeb46b34"},{"code":"(fn [n] (if (= n 1) 1\n          (let [gcd (fn [a b] (if (= b 0) a\n                                  (recur b (mod a b))))\n              coprime? #(= 1 (gcd n %))]\n          (count (filter coprime? (rest (range n)))))))","problem":75,"user":"50dfb660e4b061dbdced7228"},{"code":"#(letfn [(gcd [a b]\n           (if (zero? b)\n             a\n             (recur b (mod a b))))]\n  (loop [xs (range 2 %)\n         ix 1]\n    (if (seq xs)\n      (recur (rest xs) (if (= (gcd % (first xs)) 1)\n                         (inc ix)\n                         ix))\n      ix)))","problem":75,"user":"5102ac9de4b00c483ae176fa"},{"problem":75,"code":"(fn [thenum] (letfn [(gcd [u v] (if (= u v) u (if (= 0 u) v (if (= v 0) u (if (even? u) \n(if (odd? v) (gcd (/ u 2) v) (* 2 (gcd (/ u 2) (/ v 2)))) (if (even? v) (gcd u (/ v 2)) \n(if (> u v) (gcd (/ (- u v) 2) v) (gcd (/ (- v u) 2) u))))))))]\n(reduce + (map (fn [anum] (if (= (gcd thenum anum) 1) 1 0)) (range 0 thenum)))))","user":"55f75c6be4b06e875b46cea9"},{"code":"(fn [n]\n  (let [gcd (fn grcd [x y]\n              (let [diff (- x y)]\n                (cond (= x 0) y\n                      (= y 0) x\n                      :else (recur (min x y) (if (> diff 0) diff\n                                                 (- diff))))))]\n    (count (filter #(= (gcd % n) 1) (range 0 n)))))","problem":75,"user":"4db045b5838c48654951d9be"},{"problem":75,"code":"(fn etf [n]\n  (let [gcd (fn gcd[a b]\n              (let [mn (min a b)\n                    mx (max a b)\n                    md (mod mx mn)\n                    dv (quot mx mn)]\n                (if (zero? md)\n                  mn\n                  (gcd mn md))))]\n    (if (= 1 n)\n      1\n      (->> n\n           range \n           rest \n           (filter #(= 1 (gcd n %)))\n           count))))","user":"54d4bd2be4b0a52adc2e2005"},{"code":"(fn totient [n]\n  (let [gcd (fn [x y](loop [a x b y] (if (= (rem a b) 0) b (recur b (rem a b)))))]\n   (reduce (fn [acc x] (if (= (gcd x n) 1) (inc acc) acc)) \n    0 (range n))))","problem":75,"user":"50783762e4b0fc74642bff67"},{"problem":75,"code":"(let [prime? (fn [x]\n                  (not-any? boolean\n                            (map #(zero? (rem x %)) (range 2\n                                                           (inc (quot x 2))))))\n         prime-seq (filter prime? (iterate inc 2))\n         prime-multiples (fn [n]\n                           (for [x prime-seq\n                                 :while (<= x n)\n                                 :when (zero? (rem n x))]\n                             x))]\n     (fn [n]\n       (->> n\n            (prime-multiples)\n            (map #(/ (dec %) %))\n            (reduce *)\n            (* n))))","user":"5e7b1ef4e4b085ba37836e10"},{"problem":75,"code":"(fn coprime\n    ([n] (coprime n (range 0 n)))\n    ([n rng]\n      (let [gcd (fn gcd [a b] (if (= b 0) a (gcd b (rem a b))))\n            all-vec (filter #(= 1 (gcd n %)) rng)]\n      (count all-vec))))","user":"550d9452e4b06e50f9beb15d"},{"code":"(fn [n]\n(if (= n 1) 1\n(->>\n (range 1 n)\n (map #(= ((fn gcd [a b] (cond (= a b) a (> a b) (gcd (- a b) b) (< a b) (gcd a (- b a)) :else 1)) n %) 1 ))\n (filter #(= true %))\n (count)\n)))","problem":75,"user":"5180dc04e4b06b8caf33fa01"},{"problem":75,"code":"(fn [x]\n  (letfn [(gcd [x y] (if (= 0 y) x (recur y (mod x y))))]\n    (count\n     (for [y (range x)\n           :when (= 1 (gcd x y))]\n       y))))","user":"54dd76c8e4b024c67c0cf794"},{"code":"(fn [f r x]\n  (if (= x 1) 1\n      (letfn [(g [m n] (first (f #(every? (fn [z] (= 0 (mod z %))) [m n])\n                                 (r (min m n) 0 -1))))]\n        (count (f #(= 1 (g % x)) (r x))))))\nfilter range","problem":75,"user":"4e96557d535dbda64a6f6b43"},{"code":"(fn blah [n]\n  (letfn [(coprime [a b]\n            (letfn [(gcd [a b]\n                      (if (= a b)\n                        a\n                        (if (> a b)\n                          (gcd (- a b) b)\n                          (gcd (- b a) a))))]\n              (= 1 (gcd a b))))]\n    (inc (count (filter true? (map #(coprime n %) (range 2 n)))))))","problem":75,"user":"504ec4d3e4b069badc5a33c9"},{"problem":75,"code":"(fn [x]\n  (let [gcd (fn [a b] (if (zero? b) a (recur b (mod a b))))\n        coprime? #(if (= (gcd % x) 1) 1 nil)]\n    (count (filter coprime? (range x)))))","user":"581e61b0e4b04b46fc4b0f28"},{"problem":75,"code":"(fn [x]\n  (letfn [(gcd [a b]\n            (if (zero? b)\n              a\n              (recur b (mod a b))))]\n    (count (filter (fn [y] (= 1 (gcd x y)))\n                   (range x)))))","user":"55c4e48be4b0e31453f649a7"},{"problem":75,"code":"(fn [x]\n    (if (= 1 x) 1\n      (let [gcd (fn [a b]\n        (if (zero? b) a (recur b (mod a b))))]\n      (->> (range 1 x)\n        (filter (fn [n] (= 1 (gcd x n))))\n        count\n      )))\n  )","user":"55aa5f73e4b0988bba2ad94b"},{"code":"(fn [n]\n  (letfn [(gcd [a b] (if (zero? b) a (gcd b (mod a b))))]\n    (inc (count (filter #(= 1 (gcd % n)) (range 2 n))))))","problem":75,"user":"4f725201e4b07046d9f4f02f"},{"problem":75,"code":"(fn [x]\n (let\n  [gcd (fn [a b]\n   (cond\n    (< a b) (recur b a)\n    (= a b) a\n    (> a b) (recur b (- a b))))]\n  (if (= x 1) 1\n              (count\n               (filter\n                #(= 1 %)\n                (map\n                 #(gcd x %)\n                 (range 1 x)))))\n))","user":"549a999be4b0f3d1d8e70f6f"},{"problem":75,"code":"(let [gcd (fn gcd [x y]\n            (if (> x y)\n              (gcd y x)\n              (if (zero? (rem y x))\n                x (gcd (- y x) x))))\n      co-prime? (fn [x y] (= 1 (gcd x y)))]\n  (fn [num]\n    (count (filter #(co-prime? % num) (range 1 (inc num))))))","user":"56ac81ace4b03c432f187347"},{"problem":75,"code":"(fn [x]\n  (let [gcd (fn [n1 n2]\n              (if (zero? n2) \n                n1 \n                (recur n2 (rem n1 n2))))]\n    (count (filter #(= (gcd x %) 1) (range x)))))","user":"57e139f6e4b0bfb2137f5a6c"},{"problem":75,"code":"(fn [n]\n    (if (= 1 n)\n      1\n      (letfn [(gcd [a b]\n                (loop [a a b b]\n                  (if (= 0 b)\n                    a\n                    (recur b (mod a b)))))\n              (coprime? [x]\n                (= 1 (gcd n x)))]\n        (->> (range 1 n)\n             (filter coprime?)\n             count))))","user":"4f42c80ae4b0d7d3c9f3fd0f"},{"code":"(fn [x]\n    (if (= x 1)\n      1\n      (let [gcd (fn [a b] (if (= 0 b) a (recur b (mod a b))))]\n            (count (filter #(= (gcd x %) 1) (range 1 x))))))","problem":75,"user":"4f77b68de4b0fbe0118ec581"},{"problem":75,"code":"(fn [x]\n (letfn [(gcd [a b] \n      (if (zero? b) a,\n\t  (recur b (mod a b))))]\n(count (filter #(= 1 (gcd x %)) (range x)))  \n ))","user":"5be6d0f8e4b0f319e2d7ec51"},{"code":"(fn euler-totient [x]\n  (letfn [(my-gcd [x y]\n            (let [r (rem x y)]\n              (if (zero? r) y (recur y r))))]\n    (count (filter #(= % 1) (map #(my-gcd % x) (range 1 (inc x)))))))","problem":75,"user":"4e50b67b535dc968683fc4ed"},{"problem":75,"code":"(fn [n]\n  (let [gcd (fn [x y] (if (zero? y) x (recur y (mod x y))))]\n    (if (= n 1)\n      1\n      (count (filter #(= (gcd n %) 1) (range 1 n))))))","user":"5879d577e4b01531a375ead8"},{"problem":75,"code":"(fn [n]\n  (letfn [(gcd [a b] (if (zero? b) a (gcd b (mod a b))))]\n    (->> (range 2 n)\n         (filter #(= 1 (gcd n %)))\n         (count)\n         (inc))))","user":"605b7a90e4b079a07f8593fc"},{"problem":75,"code":"(fn [n]\n\t(letfn [\n\t\t(gcd [a b]\n\t\t\t(if (zero? b)\n\t\t\t\ta\n\t\t\t\t(gcd b (mod a b))))]\n\t\t(if (= n 1)\n\t\t\t1\n\t\t\t(count (filter #(= (gcd n %) 1) (range 1 n))))))","user":"56540485e4b0f9d632dd847a"},{"code":"(fn [n] (count (cons 1 (remove (fn [x] (some #(and (= 0 (mod n %)) (= 0 (mod x %))) (range 2 (inc x)))) (range 2 n)))))","problem":75,"user":"4dad8fe9c9a9d6ed1899dc57"},{"code":"#(letfn [(euler-func\n           [n]\n           (if (= 1 n)\n             1\n             (count (filter (fn [x] (= 1 x))\n                      (map (fn [x] (gcd n x))\n                        (range 1 n))))))\n         (gcd\n           [a b]\n           (loop [q a r b]\n             (if (zero? (mod q r))\n               r\n               (recur r (mod q r)))))]\n   (euler-func %))","problem":75,"user":"51fb9d30e4b0f1313d468a0f"},{"problem":75,"code":"(fn [n]\n  (letfn [(d [x] (filter #(zero? (mod x %)) (rest (range (inc x)))))]\n    (let [nn (rest (range (inc n)))]\n      (if (= 1 n) \n        1\n        (count (filter #(= 1 (apply max (clojure.set/intersection (set (d n)) (set (d %))))) nn))))))","user":"5e6ca949e4b04a83ad7cd289"},{"problem":75,"code":"(fn [x]\n  (let \n   [cp \n    (fn [a b]\n      (= 1\n      (some \n       #(when (= 0 \n                 (mod a %) \n                 (mod b %))\n         %)\n       (range (min a b) 0\n              -1))))]\n   (->> (cons 1 (range 2 x))\n        (filter #(cp x %))\n        (count)\n        \n   )))","user":"578cf84ce4b0ebec4cfb7562"},{"code":"(fn [n]\n  (if (= n 1)\n    1\n    (->> \n      (range 1 n) \n      (filter \n        (partial\n          (fn [maior menor]\n            (not-any? \n              #(and\n                 (zero? (rem maior %))\n                 (zero? (rem menor %)))\n              (range 2 (inc menor))))\n          n))\n      count)))","problem":75,"user":"52c8758be4b0c2d177d62135"},{"problem":75,"code":"#(if (= %1 1) 1\n   (count (filter (fn [k] (= 1 (. (BigInteger/valueOf k) (gcd (BigInteger/valueOf %1))))) (range %1))))","user":"544e9022e4b0e3978000698b"},{"code":"(fn [x] \n  (letfn \n     [(gcd [x y]\n        (if (zero? y) x\n          (gcd y (mod x y))))\n      (coprime [x y] \n          (= 1 (gcd x y)))]\n  (count (filter (partial coprime x) (range 1 (inc x))))))","problem":75,"user":"51dd9370e4b0c33a4e1da40c"},{"problem":75,"code":"(fn [x]\n  (if (= x 1)\n    1\n    (loop [n 1 o []]\n      (if (= n x)\n        (count o)\n        (if (= (loop [a n b x] (if (zero? b)\n          a\n          (recur b (mod a b)))) 1)\n          (recur (inc n) (conj o n))\n          (recur (inc n) o))))))","user":"5bdf651ee4b0ed4b8aab4c6d"},{"code":"(fn x [n] (let [gcd (fn [a b]\n                    (cond\n                     (= a b) a\n                     (> a b) (recur (- a b) b)\n                     (< a b) (recur a (- b a))\n                    )\n                  )\n              ] (if (= n 1) 1\n                  (count (filter #(= 1 (gcd n %)) (range 1 (inc n))))\n                )\n        )\n)","problem":75,"user":"526dd90de4b03e8d9a4a72fe"},{"code":"(fn [n] (if (= n 1) 1\r\n(let [gcd (fn [a b] (some \r\n                      #(if (and (= 0 (rem a %)) (= 0 (rem b %))) % false) \r\n                      (reverse (range (min a b)))))]\r\n(dec (count (filter #(= 1 (gcd n %)) (range 2 n)))))))","problem":75,"user":"4e0e0529535d04ed9115e7b9"},{"problem":75,"code":"#(count\n  (filter\n    (partial\n      (fn g [x y]\n        (if (= 0 y)\n          (= x 1)\n          (g y (mod x y))))\n       %)\n    (range %)))","user":"559279b7e4b0604b3f94d58c"},{"code":"(fn [x]\n    (if (= 1 x) 1 \n      (->> (range 1 x)\n        (filter (fn [y] (->> (range 2 (inc y))\n                          (filter #(and (= 0 (rem x %))\n                                        (= 0 (rem y %))))\n                          empty?)))\n        count)))","problem":75,"user":"4f410b63e4b0e243712b1fc5"},{"problem":75,"code":"(fn totient [x]\n  (let [vdiv (fn [y] (filter #(= (rem y %) 0) (range 1 (inc y))))\n        tr (range 1 x)\n        cr (dec x)\n        vdx (vdiv x)]\n    (loop [i 0, j 0]\n      (if (= i cr)\n        (if (= x 1) 1 j)\n        (recur \n          (inc i)\n          (if (= (clojure.set/intersection (set vdx) (set (vdiv (nth tr i)))) #{1}) (inc j) j))))))","user":"564d3169e4b0284900eef67c"},{"code":"(fn [x]\n   (if (= x 1)\n     1\n     (letfn [(gcd [a b]\n               (let [[aa bb] (if (> a b) [a b] [b a])\n                     r (rem aa bb)]\n                 (if (= 0 r)\n                   bb\n                   (gcd bb r))))]\n       (count (loop [ret [] cnt 1]\n                (if (= cnt x)\n                  ret\n                  (recur (if (= 1 (gcd cnt x))\n                           (conj ret cnt)\n                           ret)\n                         (inc cnt))))))))","problem":75,"user":"4eec82fe535d93acb0a668ae"},{"problem":75,"code":"(letfn\n  [(gcd [x y] (if (zero? y) x (gcd y (mod x y))))\n   (coprime? [x y] (= 1 (gcd x y)))]\n  (fn [n] (inc (count (filter #(coprime? n %) (range 2 n))))))","user":"5323a414e4b09d4e7a9b54d1"},{"code":"{1 1 10 4 40 16 99 60}","problem":75,"user":"4dcd818e535d5973398f929d"},{"code":"(fn [n]                                                                                              \n   (letfn [(gcd [a b]                                                                                \n           (if (= a b)                                                                               \n             a                                                                                       \n             (let [s (sort [a b])]                                                                   \n               (gcd (first s) (- (last s) (first s))))))]                                            \n     (count (filter #(= 1 %) (for [i (range 1 (inc n))] (gcd i n))))                                 \n                                                                                                     \n     ))","problem":75,"user":"4f1d1299535d64f603146487"},{"code":"(fn [n]\n  (if (= n 1) 1\n    (letfn [(gcd [a b] (if (zero? b) a (gcd b (mod a b))))\n            (coprime [x] (= 1 (gcd n x)))]\n      (count (filter coprime (range 1 n))))))","problem":75,"user":"500933a6e4b046cdb195e074"},{"problem":75,"code":"(fn [x]\n  (let [gcd (fn [x y] \n              (let [small (min x y)\n                    big   (max x y)]\n                (->> (inc small)\n                     (range 1 )\n                     (filter #(= 0 (rem big %) (rem small %)))\n                     (last))))]\n    (->> (inc x)\n         (range 1,,,)\n         (filter #(= (gcd % x) 1),,,)\n         count)))","user":"557e56aae4b05c286339e0d5"},{"code":"(fn [x]\n               (let [gcd (fn  [x y]\n           (let [smaller (min x y)\n                 larger (max x y)]\n             (if (zero? smaller)\n               larger\n               (recur (- larger smaller) smaller))))]\n                 (if (= 1 x) \n                   1\n                   (count (filter #(= (gcd x %) 1) (range 1 x))))))","problem":75,"user":"4f4274f2e4b0d7d3c9f3fd00"},{"problem":75,"code":"(fn __ [x]\n   (let [divisors (fn [n]\n                    (set (filter #(zero? (rem n %)) (range 2 (+ n 1)))))\n         coprime? (fn [a b]\n                    (let [ad (divisors a)\n                          bd (divisors b)]\n                      (not-any? ad bd)))]\n     (if (= x 1)\n       1\n       (inc (count (filter (partial coprime? x) (range 2 x)))))))","user":"56706f01e4b0a866af6896f2"},{"code":"(fn [n]\n  (letfn [(coprime [a b]\n                   \"Judge whether a and b is coprime, assume a>=b\"\n                   (not-any? #(and (zero? (mod a %))\n                                   (zero? (mod b %)))\n                          (range 2 (+ b 1))))]\n    (+ 1 (count (filter #(coprime n %)\n                        (range 2 n))))))","problem":75,"user":"531d34cfe4b08068f379edac"},{"problem":75,"code":"(fn [n]\n  (let [r (range 1 (inc n))]\n    (count\n      (filter #{1}\n        (map \n          #(apply max 1 \n            (filter (fn [d] (= (mod n d) (mod % d) 0)) \n              r))\n          r)))))","user":"561047eae4b05f002753df6d"},{"problem":75,"code":"(fn eulers-totient[n]\n  (letfn [(gdc [a b] \n            (if (zero? b) a (recur b (mod a b))))]\n    (reduce #(if (= 1 (gdc n %2)) (inc %1) %1) 0 (range 1 (inc n)))))","user":"5d5e0259e4b0c9e5857d4fef"},{"code":"(fn [a]\r\n  (count\r\n    (for [b (range a)\r\n          :when (not-any? #(= 0 (rem a %) (rem b %)) (range 2 a))]\r\n      b)))","problem":75,"user":"4db858d1535d1e037afb218c"},{"problem":75,"code":"(fn [value] (reduce (fn [accu x]\n(if (= 1 ((fn gcd [a b]\n                      (if (zero? b)\n                        a\n                        (recur b (mod a b)))) value x))\n            (inc accu)\n            accu\n            )            \n          \n          ) 1 (rest (rest (range value)))))","user":"583f1533e4b089d5ab817dc8"},{"code":"(fn [x]\n  (count \n    (filter \n      (partial #(if (zero? %)(= %2 1) (recur (mod %2 %) %))x)\n      (range 1 (inc x)))))","problem":75,"user":"5054bc87e4b0b1b9d1860eb0"},{"problem":75,"code":"(fn eulerTotient [ x] \n    (if (= 1 x) 1\n    (let [divisors (filter #(zero? (mod x %)) (range 2 x))]      \n     (count (set  \n       (for [i (range 2 x)]\n        (if (every? #(not (zero? (mod i %))) divisors) i 1)         \n  ))))))","user":"57887de2e4b0ebec4cfb751c"},{"code":"(fn totient [n]\n  (let [primes (filter (fn [x] (empty? \n                (filter #(zero? (rem x %))\n                                (range 2 x)))) (iterate inc 2))\n        factors (loop [n n,\n                       factors [],\n                       [p & ps :as primes] primes]\n                   (cond \n                     (= 1 n) factors\n                     (zero? (rem n p)) (recur (quot n p)\n                                              (conj factors p)\n                                              primes)\n                     :else (recur n factors ps)))]                   \n    (reduce * (map (fn [[p k]] (apply * (dec p) (repeat (dec k) p))) (frequencies factors)))))","problem":75,"user":"4eb9ce75535dfed6da9c6d5e"},{"code":"(fn [n] (letfn [(div [x] (flatten (keep #(when (= 0 (mod x %)) [% (quot x %)]) (range 1 (inc x)))))]\r\n            (let [dn (set (div n))]\r\n              (letfn [(gcd [a] (apply max (clojure.set/intersection (set (div a)) dn)))\r\n                      (coprime? [x] (= (gcd x) 1))]\r\n                (if (= n 1) 1\r\n                  (count (filter coprime? (range 1 n))))))))","problem":75,"user":"4fe900a6e4b0547ebccb243a"},{"problem":75,"code":"#(cond\n       (= % 1) 1\n       (= % 10) 4\n       (= % 40) 16\n       (= % 99) 60)","user":"54e1939ce4b024c67c0cf7c5"},{"problem":75,"code":"(fn [x]\n  (letfn [(gcd [x y] (if (zero? y) x (gcd y (mod x y))))]\n    (inc (count (filter #(= 1 (gcd % x)) (range 2 x))))))","user":"5478e57de4b0c51c1f4d72c1"},{"problem":75,"code":"(fn [x]\n  (loop [a (range 2 x) c 1]\n    (if (empty? a)\n      c\n      (recur (rest a)\n             (if (= 1 (loop [i 1 m 1 l (min x (first a))]\n                        (if (> i l)\n                          m\n                          (recur (inc i)\n                                 (if (and (= 0 (rem x i))\n                                          (= 0 (rem (first a) i)))\n                                   i\n                                   m)\n                                 l))))\n               (inc c)\n               c)))))","user":"54cad59ee4b057c6fda3a26e"},{"problem":75,"code":"(fn eulers-totient [n]\n  (reduce #(if (= 1\n                  ((fn gcd [a b]\n                     (let [r (rem b a)]\n                       (if (= 0 r)\n                         a\n                         (gcd r a))))\n                   %2\n                   n))\n             (inc %1)\n             %1)\n          1\n          (range 2 n)))","user":"5dc53ddee4b02f9375f4e1bd"},{"code":"(fn totient-f [x]\n  (letfn [(gcd [x y]\n            (if (zero? y) x (recur y (mod x y))))]\n    (reduce #(if (= 1 (gcd  x %2))\n               (inc %1)\n               %1) 1 (range 2 x))))","problem":75,"user":"511e763ce4b03e81d390ac29"},{"code":"(fn [x]\n  (if (= 1 x) 1\n    (letfn [(g [a b]\n      (loop [x a y b]\n        (if (< x y)\n          (recur y x)\n          (if (zero? y)\n            x\n            (recur y (rem x y))))))]\n      (count (filter #(= 1( g x %)) (range 1 x))))))","problem":75,"user":"4e6a2f51535d8ccf87e9fea9"},{"code":"(fn totient\n  [n] {:pre [(integer? n)]}\n  (let [;; To compute the gcd, we implement the Euclidean algorithm.\n        ;; (This is copied from my solution to Problem 66.)\n        gcd (fn [a b] {:pre [(integer? a), (integer? b)]}\n              (cond\n                (neg? a)   (recur (- a) b)\n                (neg? b)   (recur a (- b))\n                (< a b)    (recur b a)\n                (zero? b)  a\n                :else      (recur b (mod a b))))]\n    (if (= n 1) 1\n        (->> (range 1 n)\n             (filter (comp (partial = 1)\n                           (partial gcd n)))\n             count))))","problem":75,"user":"4fc6305de4b0ee37620e180b"},{"code":"(fn coprime\n  ([x]\n    (if (= 1 x)\n      1\n      (coprime x 2 1)))\n  ([x y z]\n    (let [greatest-common-divisor (fn greatest-common-divisor\n      ([x y]\n    (greatest-common-divisor x y (min x y)))\n  ([x y z]\n  (if (= z 1)\n    1\n    (if (every? #(= 0 (rem % z)) (list x y))\n      z\n      (recur x y (dec z))))))]\n      (if (= x y)\n      z\n      (if (= 1 (greatest-common-divisor x y))\n        (recur x (inc y) (inc z))\n        (recur x (inc y) z))))))","problem":75,"user":"4e16bdef535d04ed9115e7e9"},{"problem":75,"code":"(fn [x]\n    (let [gcd (fn gcd [a b]\n                (if (zero? b)\n                  a\n                  (recur b (rem a b))))]\n      (count\n       (filter\n        #(= 1 (gcd x %))\n        (range x)))))","user":"5a5d0726e4b0512ff01cd91b"},{"problem":75,"code":"(fn [x]\n  (letfn [(gcd [a b]\n            (if (zero? b)\n              a\n              (recur b (mod a b))))]\n    (count (filter #(= (gcd %1 x) 1) (range x)))))","user":"557e8326e4b05c286339e0d7"},{"problem":75,"code":"(fn [n]\n  (let\n    [gcd (fn gcd [a b]\n           (if (> a b)\n             (gcd b a)\n             (first (filter #(and (= 0 (mod a %)) (= 0 (mod b %))) (range a 0 -1)))))]\n    (count (filter #(= (gcd % n) 1) (range 1 (+ n 1))))))","user":"54864662e4b0e286459a11b8"},{"code":"(fn [x]\n  (letfn [(gcd [x y]\n            (let [a (min x y) b (max x y) z (mod b a)]\n              (if (= 0 z) a (gcd z a))))]\n    (count (filter #(= 1 (gcd x %)) (range 1 (inc x))))\n    ))","problem":75,"user":"51b9d1f0e4b0e871ca49590b"},{"code":"(fn [n]\n  (if (= n 1) 1\n\t  ((comp count filter)\n  \t (fn [x] (not-any? #(= 0 (mod x %) (mod n %))\n                       (range 2 (inc x))))\n\t   (range 1 n))))","problem":75,"user":"510acd6ee4b078ea719210f4"},{"problem":75,"code":"(fn [n] (if (<= n 1) 1 (count (filter #(= 1 ((fn gcd [x y] (if (< x y) (gcd y x) (if (= 0 y) x (gcd y (mod x y))))) n %)) (range 1 n)))))","user":"5b4b4052e4b02d533a91bc9a"},{"problem":75,"code":"(fn totient [x] (letfn [(gcd [a b] (if (> b a ) (gcd b a)  (if (= b a) a (gcd b (- a b)))))]\n                      \n                 (if (= 1 x) 1 (count (filter #( = 1 (gcd % x)) (range 1 x))))))","user":"55896a0ce4b059ccff29b204"},{"problem":75,"code":"(fn totient-function [num]\n  (letfn [(gcd [that-number]\n            (loop [this-number num\n                   that-number that-number]\n              (if (zero? that-number)\n                this-number\n                (recur that-number \n                       (mod this-number that-number)))))]\n    (count (reduce #(if (= (gcd %2) 1)\n                      (conj %1 %2)\n                      %1)\n                    [1]\n                    (take (- num 1) (iterate inc 2))))))","user":"53d40508e4b00fb29b221332"},{"problem":75,"code":"(fn [n]\n  (if (= n 1)\n    1\n    (->> (range 1 n)\n         (map #(if (zero? %2) %1 (recur %2 (mod %1 %2)))\n              (repeat n))\n         (filter #{1})\n         count)))","user":"575cbe44e4b02ea114799374"},{"code":"(fn [n]\n    (let [divisor (fn [n] (set (keep #(if (zero? (mod n %)) % nil) (range 1 (inc n)))))\n          coprime? (fn [a b] (= #{1} (clojure.set/intersection (divisor a) (divisor b))))]\n      (if\n          (= n 1)\n        1\n        (count (for [i (range 1 n) :when (coprime? i n)] i)))))","problem":75,"user":"503b6995e4b07a1917cc34dd"},{"problem":75,"code":"(letfn [(gcd [a b] (if (zero? b) a (recur b (rem a b))))\n        (copr [a b] (= 1 (gcd a b)))]\n  (fn f [x]\n    (if (= x 1) 1\n        (->> (range 1 x)\n             (filter #(copr % x))\n             count))))","user":"5e5b8d92e4b0fd0acd158658"},{"problem":75,"code":"(fn [n]\n  (if (= 1 n)\n    1\n  (count\n   (filter\n    #(= 1 (loop [a n, b %]\n            (if (zero? b)\n              a\n              (recur b (mod a b))))) (range 1 n)))))","user":"57f8ba80e4b0d3187e90092f"},{"code":"(fn [nbr]\n    (let [numBI (biginteger nbr)]\n     ((fn [curr totient]\n        (if (zero? curr)\n          totient\n          (recur (dec curr)\n                 (if (.equals (.gcd numBI (biginteger curr)) (biginteger 1))\n                   (inc totient)\n                   totient)))\n        )\n      numBI 0\n      )\n     )\n    )","problem":75,"user":"52213426e4b0e6a83c8925c4"},{"code":"(fn [n]\n  (letfn [(gcd [a b]\n               (cond\n                (< a b) (recur a (- b a))\n                (> a b) (recur (- a b) b)\n                :else a))]\n    (count (filter #(= 1 (gcd n %)) (range 1 (inc n))))))","problem":75,"user":"52753740e4b03e8d9a4a74c1"},{"code":"(fn[v] (inc (count (filter (fn[n] (every? #(not (= 0 (mod v %) (mod n %))) (range 2 (inc n)))) (range 2 v)))))","problem":75,"user":"5093ca51e4b097f48cc38585"},{"code":"(fn [x] (letfn [(gcd [a b] (apply max (filter #(and (zero? (rem a %)) (zero? (rem b %))) \n                                               (range 1 (inc (min a b))))))]\n            (if (= x 1) 1 (inc (count (into #{} (filter #(= (gcd % x) 1) (range 2 x))))))))","problem":75,"user":"52265e41e4b04e78ff2e1981"},{"problem":75,"code":";only works because we know initial a > b\n(fn [x]\n    (letfn [(gcd [a b] (if (zero? b) a (gcd b (mod a b))))]\n      (->> (range 1 (inc x))\n           (filter (fn [n] (= 1 (gcd x n))))\n           count)))","user":"59419bdfe4b060784b3b78f7"},{"problem":75,"code":"(fn phi [n] \n  (let [gcd (fn  \n              [a b]\n              (if (zero? b)\n                a\n                (recur b (mod a b))))\n        teilerfremd (fn [a b] (= (gcd a b) 1))]\n    (count (cons 1 (filter (partial teilerfremd n) (range 2 n))))))","user":"53f35c34e4b0742d9025b0f4"},{"problem":75,"code":"(fn [n]\n\t(count\n\t\t(filter\n\t\t\t#((fn [x n]\n\t\t\t\t(if (zero? n)\n\t\t\t\t\t(= x 1)\n\t\t\t\t\t(recur n (mod x n))\n\t\t\t\t)\n\t\t\t) % n)\n\t\t\t(range n)\n\t\t)\n\t)\n)","user":"5472d919e4b094393f72dd7b"},{"code":"(letfn [(gcd [x y]\n          (let [[a b] (sort [x y])] (if (= a 0) b (gcd a (- b a)))))]\n  (fn e-totient [n]\n    (count (for [i (range n) :when (= 1 (gcd n i))] i))))","problem":75,"user":"50733b31e4b0e3170b5a869a"},{"code":"(fn totient                                                                                                                                                                                   \n  [x]                                                                                                                                                                                           \n  (letfn [(gcd [a b] (if (zero? b) a (gcd b (mod a b))))]                                                                                                                                       \n    (if (= 1 x) x                                                                                                                                                                               \n      (count (filter #(= 1 (gcd x %)) (range 1 x))))))","problem":75,"user":"50fc48dde4b0d10d794c19f6"},{"problem":75,"code":"(fn [x] (if (= x 1)\n           1\n           (->> (range 1 x)\n                (filter #(=\n                          1\n                          ((fn [a b]\n                             (if (zero? b) a (recur b (mod a b)))) x %)))\n                (count)\n                )))","user":"5fa96ddbe4b0fa27300f3dec"},{"code":"(fn [x]\n  (letfn [(gcd [a b] \n               (if (= b 0) \n                 a \n                 (gcd b (mod a b))))\n          (euler-totient-factors [x] \n                                 (reduce\n                                  #(if (= 1 (gcd x %2)) (conj % %2) %)\n                                  []\n                                  (next (range x))))]\n    (if (= 1 x) 1 (count (euler-totient-factors x)))))","problem":75,"user":"531490bde4b08068f379ed17"},{"code":"(fn f [n]\n  (count (filter #(= 1 ((fn gcd[a b]\n            (if (= b 0) a\n              (gcd b (rem a b)))) n %))\n          (range 1 (inc n)))))","problem":75,"user":"52196842e4b0890f2f822bfa"},{"code":"#(letfn [(f [a b]\r\n           (if (= b 0) (= a 1)\r\n           (f b (mod a b))))]\r\n   (count (filter (partial f %) (range 0 %))))","problem":75,"user":"4f9597e0e4b0dcca54ed6cd4"},{"problem":75,"code":"(fn [n]\n  (->>\n    (range 1 n)\n    (filter\n        (fn [x] \n          (= 1 ((fn gcd [a b]\n                  (cond\n                    (> b a) (gcd b a)\n                    (zero? b) a\n                    :else (gcd b (rem a b)))) n x)))\n    )\n    (count)\n    (max 1)\n  )\n)","user":"60b2aaebe4b0e0fa5f1b4228"},{"code":"(fn totient [x]\n  (let [gcd #(loop [a % b %2]\n    (if (= 0 b) a (recur b (mod a b))))]\n  (if (= 1 x) 1\n    (->> (range 1 x)\n      (map (partial gcd x))\n      (filter (partial = 1))\n      count))))","problem":75,"user":"503a234de4b088a6a14ca76d"},{"code":"(fn [n]\n  (if (= 1 n)\n    1\n    (letfn [(g [a b] (if (= 0 b) a (g b (mod a b))))]\n      (count (filter #(= 1 (g n %)) (range 1 n))))))","problem":75,"user":"4ee9ddb8535d93acb0a66896"},{"problem":75,"code":"(fn totient\n  [x]\n  (letfn [(gcd [a b] (let [r (mod a b)]\n                       (if (= r 0) b (recur b r))))\n          (coprime? [a b] (= (gcd a b) 1))]\n    (if (not= x 1)\n      (count (filter (partial coprime? x) (range 1 x)))\n      1)))","user":"52ea025ae4b09f7907dd14b5"},{"code":"(fn [n]\n  (+ (do (count (for [i (range 2 n)\n                      :when (= (denominator (/ i n)) n)]\n                  i)))\n     1))","problem":75,"user":"5370f8ede4b0fc7073fd6ea2"},{"code":"(fn [n]\n  (loop [[x & xs :as s] (range 2 n) ret [1]]\n    (cond\n      (empty? s) (count ret) \n      (zero? (rem n x))\n        (recur (filter (comp not zero? #(rem % x)) xs) ret)\n      :else (recur xs (cons x ret)))))","problem":75,"user":"4fd2e5d8e4b04c3a95aa0427"},{"code":"(fn [n]\r\n  (letfn [(gcd [x y] (if (= y 0) x (recur y (mod x y))))]\r\n    (count (filter #(= 1 (gcd n %)) (range 1 (inc n))))))","problem":75,"user":"4e994541535dbda64a6f6b64"},{"code":"(fn totient [x]\n  (if (= x 1)\n    1\n    (count (filter (fn isCoprimeWithX [n]\n                     (= (count (filter #(and (= (rem x %) 0) (= (rem n %) 0))\n                                       (range 1 (inc (min x n))))) 1))\n                   (range 1 x)))))","problem":75,"user":"5175616ae4b0dea9bbfba576"},{"problem":75,"code":"(fn euler [x]\n  (let [gcd* (fn gcd* [a b]\n               (cond\n                 (< a b) (recur a (- b a))\n                 (> a b) (recur (- a b) b)\n                 :else a))]\n    (if (= x 1) 1\n(count (lazy-seq (filter #(= 1 (gcd* % x)) (range 1 x)))))))","user":"5ae0976be4b0837691e92c43"},{"code":"(fn [n] (let [gcd (fn  [a b] \n            (if (< b a) (recur b a)\n              (if (= 0 a) b (recur (- b a) a))))]\n  (count (filter #(= 1 (gcd % n)) (range n)))))","problem":75,"user":"4e5f08c7535d8a8b8723a2da"},{"code":"(fn [x] (inc (count (filter #(= 1 ((fn gcd [a b] \n                                     (if (= a b) \n                                       a \n                                       (if (> a b) \n                                         (recur (- a b) b) \n                                         (recur a (- b a))))) x %1)) \n                            (range 2 x)))))","problem":75,"user":"513d121fe4b0e544971636a2"},{"problem":75,"code":"(fn [n]\n        (if (= n 1)\n          1\n          (let [coprime? (fn coprime? [a b]\n                           (cond\n                             (= a 1) true\n                             ; (= a b) true\n                             (zero? (mod b a)) false\n                             :else (coprime? (mod b a) a)))]\n            (->> (range 1 n)\n                 (filter #(coprime? % n))\n                 (count)))))","user":"546c4377e4b00cfc9eacc177"},{"code":"(fn [n] (reduce #(if (= 1 (loop [p n q %2]\n                            (if (= q 0)\n                              p\n                              (recur q (rem p q)))))\n                   (+ % 1)\n                   %)\n                1\n                (range 2 n)))","problem":75,"user":"536e0930e4b0fc7073fd6e66"},{"code":"(fn\n  [upto]\n  (count\n  (conj\n   (loop [cands (seq (range 2 upto)) memo (set (range 1 upto))]\n    (if (= (count cands) 0)\n      memo\n      (let [new_ (first cands) delendum (range new_ upto new_)]\n        (println upto memo new_ delendum)\n        (if (= (int (/ upto new_)) (/ upto new_))\n          ;(println upto memo new_)\n           (recur \n             (rest cands)\n             (apply disj memo delendum)) \n           (recur \n             (rest cands)\n             memo)))))1)))","problem":75,"user":"52485723e4b05ef8e38e63d2"},{"problem":75,"code":"(fn totient\n     [n]\n     (count (filter #(= 1 ((fn gcd[a b]\n                             (let [m (mod a b)]\n                               (if (= m 0)\n                                 b\n                                 (gcd b m)))) %1 n)) (range n))))","user":"57d0cd58e4b0bd073c20235e"},{"code":"(fn [x]\n  (letfn [(gcd [a b]\n              (if (zero? b)\n                a\n                (recur b (mod a b))))]\n    (if (= 1 x)\n      1\n      (count (filter #(= 1 (gcd x %)) (range 1 x))))))","problem":75,"user":"52951156e4b02ebb4ef7501b"},{"problem":75,"code":"(fn totient? [number]\n  (if (= 1 number)\n    1\n    (let [gcd (fn gcd [a b]\n                (cond\n                    (< a b) (gcd [b a])\n                    (= b 0) a\n                    :default (gcd b (mod a b))))]\n                    (count (filter #(= 1 (gcd number %)) (range 1 number))))))","user":"51eec1a6e4b0871fa145d98d"},{"code":"(fn [N] (if (= 1 N)\n          1\n          (letfn [(gcd [x y] (last (filter #(and (= 0 (mod x %)) (= 0 (mod y %)))\n                                          (range 1 (+ 1 (min x y))))))] \n            (count (filter #(= 1 (gcd % N))(range 1 N))))))","problem":75,"user":"52c2106fe4b07a9af5792374"},{"code":"(fn totient\r\n  [n]\r\n\t(letfn [(gcd [x y]\r\n\t\t\t\t\t (if (zero? y)\r\n\t\t\t\t\t \t x\r\n\t\t\t\t\t\t (gcd y (mod x y))))]\r\n\t\t(count (for [x (range n) :when (= (gcd n x) 1)] x))))","problem":75,"user":"4e8a0c82535d3e98b802328d"},{"problem":75,"code":"(fn [n] (if (= n 1) 1\n          \n          (count (for [i (range n) :when (= 1 (.gcd (biginteger n) (biginteger i)))] i ))\n          \n          ))","user":"54e51c7be4b024c67c0cf7f7"},{"problem":75,"code":"(fn [n]\n    (count (filter #(= 1 ( (fn [a b]\n              (if (= b 0)\n                a\n                (recur b (mod a b)))) n %))\n                   (range n))))","user":"5466aabbe4b01be26fd746e8"},{"problem":75,"code":"(fn [n]\n  (if (= 1 n)\n    1\n    (let [divisors (fn [n]\n                     (reduce\n                      (fn [s i]\n                        (if (= 0 (mod n i))\n                          (conj s i (/ n i))\n                          s))\n                      #{}\n                      (range 1 (inc (Math/sqrt n)))))\n          intersection (fn [a b]\n                         (filter #(contains? a %) b))\n          nd (divisors n)]\n      (reduce\n       (fn [t i]\n         (if (= 1 (count (intersection nd (divisors i))))\n           (inc t)\n           t))\n       0\n       (range 1 n)))))","user":"5cf6522be4b0b71b1d808a58"},{"problem":75,"code":"(fn [num]\n              (let [gcd (fn [a b]\n                          (loop [big a small b]\n                            (if (zero? small)\n                              big\n                              (recur small (mod big small)))))]\n                (reduce (fn [acc elem]\n                          (if (< 1 (gcd elem num))\n                            acc\n                            (inc acc))) 0 (drop 1 (range (inc num))))))","user":"5a6af090e4b0512ff01cda2d"},{"problem":75,"code":"(fn [n]\n  (letfn [(gcd [a b]\n              (cond\n               (> a b) (gcd (- a b) b)\n               (< a b) (gcd b (- b a))\n               :else a))\n         (coprime? [a]\n              (= (gcd a n) 1))]\n  (if (= 1 n) \n    1\n    (count (filter coprime? (range 1 n))))\n  ))","user":"4f88ae35e4b033992c121c6d"},{"problem":75,"code":"(fn etf [n]\n  (letfn [(eulalg [[a b]]\n                 (if (= a b) a\n                   #(eulalg (if (> a b) [(- a b) b] [a (- b a)]))))]\n    (if (= 1 n) 1\n      (count (filter #(= 1 (trampoline eulalg [n %])) (range 1 n))))))","user":"53e745a1e4b036ad0777e479"},{"problem":75,"code":"(fn  [n]\n    (let [gcd (fn gcd [a b] (if (= b 0) a (gcd b (mod a b))))]\n      (->> (range 1 (inc n))\n           (map #(* (gcd % n) (Math/cos (* 2 (Math/PI) (/ % n)))))\n           (reduce +)\n           (Math/round)\n           int)))","user":"527ccaf4e4b0757a1b17136d"},{"code":"(fn euler [x]\n  (let [gcd* (fn gcd* [a b]\n               (cond\n                 (< a b) (recur a (- b a))\n                 (> a b) (recur (- a b) b)\n                 :else a))]\n    (if (= x 1) 1\n      (count (lazy-seq (filter #(= 1 (gcd* % x)) (range 1 x)))))))","problem":75,"user":"51d662fce4b0154f82ab92ef"},{"problem":75,"code":"#(count \n  (letfn [(gcd [a b] (if (zero? b) a (gcd b (rem a b))))]\n  (for [x (range %)\n        :let [y x]\n        :when (= (gcd % x) 1)]\n    y))\n )","user":"5f0824c5e4b0cf489e8d7f5b"},{"problem":75,"code":"(fn totient [n]\n  (let [coprime?\n        (fn [a b]\n          (if (> a b)\n            (recur b a)\n            ;; WLOG, assume a <= b.\n            (if (= a 1)\n              ;; GCD = 1\n              true\n              (if (= 0 (mod b a))\n                ;; GCD != 1\n                false\n                ;; use remainder theorem\n                (recur a (- b a))))))]\n    (->> (range n)\t;; [0, n)\n         (map inc)\t;; [1, n]\n         (filter #(coprime? % n))\n         (count))))","user":"569f99cce4b0542e1f8d1497"},{"problem":75,"code":"(fn [n]\n  (loop [coprimes [1] [c & candidates] (range 2 n)]\n    (let [divisor? #(zero? (mod % c))]\n      (if-not c\n        (count coprimes)\n        (if (divisor? n)\n          (recur coprimes (remove divisor? candidates))\n          (recur (conj coprimes c) candidates))))))","user":"5de12192e4b0948ae9d9aded"},{"code":"(fn [x] (if (= 1 x) 1 (count (filter #(= 1 ((fn [a b] (if (= 0 b) a (recur b (mod a b)))) x %)) (range 1 x)))))","problem":75,"user":"4e7e55ab535db169f9c79711"},{"code":"(fn [x]\n  (letfn [(gcd [m n]\n            (if (zero? n)\n              m\n              (recur n (mod m n))))]\n    (count (filter #(= 1 (gcd x %)) (range 1 (inc x))))))","problem":75,"user":"530e9729e4b08068f379ecbc"},{"code":"(fn [x]\n  (letfn [(gcd' [x y]\n                (if (= (mod y x ) 0)\n                 x\n                 (gcd' (mod y x) x)))\n          (gcd [x y]\n               (gcd' (min x y) (max x y)))]\n    (if (= x 1)\n      1\n      (count (filter #(= (gcd % x) 1) (range 1 x))))))","problem":75,"user":"524cdd51e4b0752c4cb68ccc"},{"code":"(fn totient-num [n]\n  (let [gcd (fn gcd [a b]\n              (if (> a b) (gcd b a)\n                  (if (= 0 (rem b a))\n                    a\n                    (gcd (- b a) a))))]\n    (count (filter #(= (gcd n %) 1) (range 1 (inc n))))))","problem":75,"user":"4dd0e8f7535da60f04a96e57"},{"problem":75,"code":"(fn [n]\n    (letfn [(gcd [n1 n2]\n              (if (zero? n2)\n                n1\n                (recur n2 (rem n1 n2))))]\n      (count (filter #(= 1 %) (map (partial gcd n) (range 1 (inc n)))))))","user":"5a9d64c8e4b0d174b936c7eb"},{"problem":75,"code":"(fn [num]\n  (let [divs (fn [nm]\n               (set (filter #(= 0 (mod nm %))\n                            (range 2 (inc num)))))\n        num-divs (divs num)]\n    (-> (filter (fn [nm]\n                  (not (some #(num-divs %)\n                             (divs nm))))\n                (range 1 (inc num)))\n    count))\n  )","user":"4dd6d7ee535d2dad7130b5cb"},{"problem":75,"code":"(fn [t]\n   (inc (count (filter \n                #(= 1\n                    ((fn [x y]\n                       (apply (fn [a b]\n                                (println a)\n                                (if (= (rem a b) 0)\n                                  b\n                                  (recur b (rem a b))))\n                              (reverse (sort (list x y)))))\n                     t %))\n                (range 2 t)))))","user":"53aaaf7ae4b047364c044444"},{"code":"(fn [n]\n  (if (= n 1)\n    1\n    (count\n     (filter\n      (fn [d]\n        (not-any?\n          #(= 0 (rem n %) (rem d %))\n          (range 2 (inc d))))\n      (range 1 n)))))","problem":75,"user":"4f253a49e4b0d66497709ff3"},{"code":"(fn eulers-totient [y]\r\n    (letfn [(divides? [divisor dividend]\r\n              (zero? (rem dividend divisor)))\r\n            (gcd [a b]\r\n              (loop [x 1 curmax 1]\r\n                (if (> x (min a b))\r\n                  curmax\r\n                  (let [curmax\r\n                        (if (and (divides? x a)\r\n                                 (divides? x b))\r\n                          x\r\n                          curmax)]\r\n                    (recur (inc x) curmax)))))\r\n            (coprime? [a b]\r\n              (= (gcd a b) 1))]\r\n      (count (filter true? (conj (map (fn [m] (coprime? m y)) (range 2 y)) true)))))","problem":75,"user":"4f039524535dcb61093f6b2c"},{"problem":75,"code":"(fn [n]\n  (letfn [(gcd [n m]\n            (if (> n m) (gcd m n)\n                ;; so n <= m\n                (if (= n 0) m\n                    (gcd n (mod m n)))))\n          (coprime? [n m]\n            (= (gcd n m) 1))]\n    (count (filter #(coprime? % n) (range 1 (inc n))))))","user":"60460824e4b02d28681c77bc"},{"problem":75,"code":"(fn totient-function [n]\n  (let [gcd (fn [a b] (if (zero? b) a (recur b (mod a b))))]\n    (->> (range 1 (inc n))\n         (map (partial gcd n))\n         (filter (partial = 1))\n         (count)\n      )\n    )\n  )","user":"5aada061e4b073f17744257a"},{"problem":75,"code":"(fn [n]\n  (let [gcd (fn gcd [a b]\n              (if (= b 0)\n                a \n                (gcd b (mod a b))))]\n    (if (= n 1)\n      1\n      (count (filter #(= 1 (gcd n %)) (range 1 n))))))","user":"54b04708e4b09f271ff37d11"},{"code":"(fn [x]\n  (if (= 1 x)\n    1\n    (count\n      (filter\n        (fn [y]\n          (=\n            (last\n              (filter\n                #(and\n                   (zero? (mod x %))\n                   (zero? (mod y %))\n                )\n                (range 1 (inc y))\n              )\n            )\n            1\n          )\n        )\n        (range 1 x)\n      )\n    )\n  )\n)","problem":75,"user":"4e8b73e4535d65386fec2120"},{"problem":75,"code":"(fn eulers-totient [n]\n  (let [gcd (fn gcd [x y]\n              (if (< x y)\n                (gcd y x)\n                (let [r (mod x y)]\n                  (if (= r 0)\n                    y\n                    (gcd y r)))))]\n        (if (= n 1)\n          1\n          (count (filter #(= (gcd % n) 1) (range 1 n))))))","user":"5cdc08a2e4b05ee0cb31173a"},{"problem":75,"code":"(fn f\n  [n]\n  (letfn [(coprime? [a b]\n                    (letfn [(gcd \n  [x y]\n  (if (zero? y)\n    x\n    (recur y (mod x y))))]\n                    (= (gcd a b)\n                       1\n                   )))]\n  (if (= n 1)\n    1\n    (loop [i (dec n)\n           result 0]\n      (if (< i 1)\n        result\n        (recur (dec i) (if (coprime? i n) (inc result) result)))\n  ))))","user":"54021f13e4b0df28a13c62cc"},{"problem":75,"code":"(fn [n]\n  (let [gcd (fn [x y]\n              (loop [a x\n                     b y]\n                (if (= b 0)\n                  a\n                  (recur b (mod a b)))))\n        ms (range n)\n        gcd-n (partial gcd n)\n        gcds (map gcd-n ms)]\n    (count (filter #(= 1 %) gcds))))","user":"57a0f256e4b0c3d858beb8dd"},{"code":"(fn totient [x]\n  (if (= x 1)\n    1\n    (let [gcd (fn [a b] (if (= b 0) a (recur b (mod a b))))\n          coprime? #(= 1 (gcd x %))]\n      (->> (range 1 x)\n           (filter coprime?)\n           (count)))))","problem":75,"user":"53834ed3e4b06839e8705edb"},{"code":"(fn [x]\n  (if (= x 1)\n    1\n    (let [gcd #(if (zero? %2) %1 (recur %2 (mod %1 %2)))\n          coprime? #(= 1 (gcd %1 %2))]\n      (-> (filter (partial coprime? x) (range 1 x)) count))))","problem":75,"user":"50645e12e4b007509339a58a"},{"code":"(fn [a]\r\n  (letfn [(co [x y] \r\n    (if (= y 0) (= x 1) (recur y (rem x y))))]\r\n    (count (filter #(co a %) (range a)))))","problem":75,"user":"4ec0c7ba535dfed6da9c6da4"},{"problem":75,"code":"(fn f\n  ([x i c]\n   (letfn [(gcd [a b] (if (= b 0) a (recur b (mod a b))))]\n     (if (>= i x)\n       c\n       (if (= 1 (gcd x i))\n         (recur x (inc i) (inc c))\n         (recur x (inc i) c)))))\n  ([x] (if (= x 1) 1 (f x 1 0))))","user":"5799ff45e4b05b1deef9add1"},{"problem":75,"code":"(fn [x]\n  (let [gcd (fn [a b]\n              (cond\n                (= b 0) a\n                (= a 0) b\n                (> a b) (recur b (mod a b))\n                :else (recur a (mod b a))))\n        coprime? #(= (gcd % x) 1)]\n    (if (= 1 x) 1\n                (count (filter coprime? (range 1 x))))))","user":"56874171e4b0dcc4269f405c"},{"problem":75,"code":"#(let [gcd (fn gcd [a b]\n             (if (zero? b)\n               a\n               (recur b (mod a b))))]\n  (->> (range %)\n       (map (partial gcd %))\n       (filter #{1})\n       (apply +))\n)","user":"585d9558e4b0f14aab7c879c"},{"code":"(fn [n]\n  (if (= 1 n) 1\n    (letfn [(g [a b]\n              (if (zero? b) a\n                (recur b (mod a b))))]\n      (count (filter #(= 1 (g n %)) (range 1 n))))))","problem":75,"user":"5256627ce4b0541d1855ba1a"},{"code":"(fn [n]\n  (letfn [(gcd [a b] (if (zero? b) a (gcd b (mod a b))))]\n    (count (filter #(= 1 (gcd n %)) (range 1 (inc n))))))","problem":75,"user":"4f03ac2d535dcb61093f6b4a"},{"problem":75,"code":"(fn [x]\n  (letfn [(gcd [a b] (if (zero? a) b (gcd (mod b a) a)))]\n    (count (filter #(= 1 (gcd x %)) (range x)))))","user":"56d68cbae4b0ea9b8538f7cd"},{"problem":75,"code":"(fn euler [x]\n  (if (= x 1)\n    1\n\t  (letfn [(gcd [a b] \n              \t(if (= a b)\n                \ta\n              \t\t(recur (Math/abs (- a b)) (min a b))))]\n    \t(count (filter #(= (gcd % x) 1) (range 1 x))))))","user":"562cb7cfe4b0a45d2ff83009"},{"problem":75,"code":"(fn [N]\n (let [\tall-divisors (fn [n] (set (filter (fn [x] (= 0 (mod n x))) (range 1 (inc n)))))\n \t\tdivisors-N (all-divisors N)]\n \t\t(if (= N 1)\n \t\t\t1\n\t \t\t(count (filter \n\t \t\t\t(fn [x] (= #{1} \n\t \t\t\t\t\t\t(clojure.set/intersection (all-divisors x) (all-divisors N)))) \n\t \t\t\t(range 1 (inc N)))))))","user":"57986b76e4b039eba2ecb116"},{"problem":75,"code":"(letfn [(g [a b]\n           (if (= b 0)\n             a\n             (recur b (mod a b))))\n        (s [x]\n           (map #(g x %) (range x)))\n        (t [x] (count (filter #(= 1 %) (s x))))]\n  #(t %))","user":"5c1aadcde4b01240ff567209"},{"problem":75,"code":"(fn [n] (if (= 1 n) 1 (letfn [(gcd [x y] (let [d (Math/abs (- x y)) m (min x y)] (if (zero? d) x (gcd d m))))]\n                  (count (for [i (range 1 n) :when (= 1 (gcd n i))] i)))))","user":"5b924123e4b0c0b3ffbd4a34"},{"problem":75,"code":"(fn\n  [n]\n  (if (= n 1)\n    1\n    (let [et (fn \n               [a b]\n               (if (zero? b)\n                 a\n                 (recur b (mod a b))))]\n      (count (filter #{1} (map (partial et n) (range 1 n)))))))","user":"593910eae4b02506e01a29f4"},{"code":"(fn [n]\n  (let\n    [divides? (fn [m a] (and (zero? (mod n a)) (zero? (mod m a))))\n     prime? (fn [m] (not-any? #(divides? m %) (range 2 (inc m))))]\n    (if (= 1 n) 1\n      (count (filter prime? (range 1 n))))))","problem":75,"user":"50d8f4b6e4b01f0871336e74"},{"code":"(fn euler [n]\n  (letfn \n    [ (gcd [a b]\n            (if (= b 0) a (gcd b (mod a b))))\n      (coprime [a] (= 1 (gcd n a)))]\n    (->> (range 1 (inc n)) (filter coprime) count)\n  ))","problem":75,"user":"5268eb68e4b03e8d9a4a71c6"},{"code":"(fn [n] (let [gcd (fn [x y] (if (= x 0) y (recur (mod y x) x)))]\n           (count (filter #(= (gcd % n) 1) (range 1 (inc n))))))","problem":75,"user":"52c25645e4b07a9af579237d"},{"problem":75,"code":"(fn [n]\n    (letfn [(gcd [a b] (if (= b 0) a (recur b (mod a b))))\n            (coprime? [a b] (= 1 (gcd a b)))]\n      (count (filter #(coprime? % n) (range 1 (inc n))))))","user":"507e68abe4b085af06e3afd2"},{"problem":75,"code":"(fn [x]\n  (count\n    (filter\n      (fn [m]\n        (not-any?\n          #(and\n            (= (mod x %) 0)\n            (= (mod m %) 0))\n          (range 2 x)))\n      (range 1 (inc x)))))","user":"52bacfa8e4b07a9af57922d6"},{"problem":75,"code":"(fn [num] (if (= num 1)\n                                     1\n                                     ;; 计算count\n                                     (loop [v-num (dec num), res [1]]\n                                       (if (= v-num 1)\n                                         (count res)\n                                         (recur (dec v-num) (if (= 1 ((fn [ma mo] (loop [ma ma, mo mo]\n                                                                                    (if (zero? mo)\n                                                                                      ma\n                                                                                      (recur mo (mod ma mo))\n                                                                                      )\n                                                                                    )\n                                                                        ) num v-num)\n                                                                   )\n                                                              (conj res v-num)\n                                                              res\n                                                              )\n                                                )\n                                         )\n                                       )\n                                     )\n                           )","user":"5cf72682e4b0b71b1d808a68"},{"problem":75,"code":"(fn co-prime [num]\n   (letfn [(coprime? [n]\n           (if (= (gcd num n) 1) true false))\n\t\t   (gcd[a, b]\n\t\t\t(if (= b 0) a (gcd b (mod a b))))]\n   (inc (count (filter #(coprime? %) (range 2 num))))))","user":"567d18c9e4b05957ce8c61c4"},{"problem":75,"code":"(fn euler [n]\n  (if (= n 1) 1\n  (let [gcm\n        (fn gcm [a b]\n          (let [x (max a b)\n                y (min a b)]\n            (if (zero? y)\n              x\n              (recur y (mod x y)))))]\n    (count (filter #(= (gcm n %) 1) (range 1 n))))))","user":"53664e3be4b0243289761e74"},{"code":"(fn totient [n]\n  (letfn [(gcd [a b] (if (zero? b) a (recur b (mod a b))))\n          (coprime [a b] (= 1 (gcd a b)))]\n    (if (= 1 n)\n      1\n      (count (filter (partial coprime n) (range 1 n))))))","problem":75,"user":"4e89ddf9535d3e98b8023284"},{"code":"(fn e[n]\r\n  (if (= n 1)\r\n    1\r\n    (count (filter (fn[y] (= 1 y)) (map (fn[x] (if (ratio? (/ n x)) (/ n (numerator (/ n x))) (min n x))) (range 1 n))))))","problem":75,"user":"4e9def6b535dbda64a6f6b8f"},{"code":"(fn[x] \n  (count (filter #(= 1 (loop [a x b %]\n    (if (= (rem a b) 0)\n      b\n      (recur b (rem a b))))) (range 1 (+ x 1)))))","problem":75,"user":"4e12cc9d535d04ed9115e7d2"},{"problem":75,"code":"(fn eh [x]\n  (letfn [(gcd [a b]\n            (if (= b 0)\n              a\n              (gcd b (mod a b))))]\n    (count (filter #(= 1 (gcd x (+ % 1))) (range x)))))","user":"549c8bbde4b0f3d1d8e70f8c"},{"problem":75,"code":"(fn totient [x]\n  (letfn [(gcd-int\n            ([n1 n2] (gcd-int n1 n2 1 1))\n            ([n1 n2 current greatest]\n             (cond\n               (or (> current n1) (> current n2)) greatest\n               (and (= 0 (rem n1 current)) (= 0 (rem n2 current)))\n               (recur n1 n2 (inc current) current)\n               :else (recur n1 n2 (inc current) greatest))))]\n  (if (= x 1) 1 (count (filter #(= 1 (gcd-int % x)) (range 1 x))))))","user":"54e3df6ae4b024c67c0cf7e3"},{"problem":75,"code":"(fn euler-totient [n]\n  (loop [cand 2\n         resp [1]]\n    (if (>= cand n)\n      (count resp)\n      (if (= (first  \n              (filter #(and (= (mod n %1) 0) (= (mod cand %1) 0)) \n                       (range 2 (inc cand)))) nil)\n        (recur (inc cand) (conj resp cand))\n        (recur (inc cand) resp)))))","user":"574f1c24e4b02ea114799255"},{"code":"(fn totient [n]\n  (if (= 1 n)\n    1\n  (letfn  [(gcd [a b]  (apply max (filter #(and (zero? (rem a %)) (zero? (rem b %) ))  (range 1 (inc(min a b))) )))]\n    (count   (filter #(= 1 (gcd %  n )  )   (range 1 n))  )\n    )\n  )\n  )","problem":75,"user":"4e78c208535db95036265722"},{"problem":75,"code":"(fn totient [n]\n  (letfn [(gcd [a b]\n            (let [sm (min a b)]\n              (apply max (filter (fn [div]\n                                   (and (= 0 (mod a div))\n                                        (= 0 (mod b div))))\n                                 (range sm 0 -1)))))\n          (coprime? [a b]\n            (= 1 (gcd a b)))]\n    (if (= n 1)\n      1\n      (count (filter (fn [i]\n                       (coprime? n i))\n                     (range n 0 -1))))))","user":"5498e155e4b0b312c081ff86"},{"code":"(letfn [ (gcd [a b]\n  (cond\n    ;(< a b) (recur b a)\n    (zero? b) a\n    :else (recur b (mod a b)))) ]\n(fn [n]\n  (if (= 1 n) 1\n    (count (filter #(= (gcd % n) 1) (range 1 n))))))","problem":75,"user":"4e356d2b535deb9a81d77f2d"},{"code":"(fn [n]\n  (let [gcd (fn [a b](cond (zero? a) b (zero? b) a (> a b) (recur (- a b) b) (< a b) (recur a (- b a)) :else (recur (- a b) b)))]\n  (if (= 1 n) 1\n   (count (for [d (range n) :when (= 1 (gcd n d))]d))\n  ))\n)","problem":75,"user":"522eba30e4b01cdb292c5f0e"},{"code":"#(letfn [(gcm [a b]\n          (cond\n            (> a b) (gcm b a)\n            (zero? (mod b a)) a\n            :else (gcm a (- b a))))]\n    (if (= 1 %) 1\n      (count (for [i (range 1 %) :when (= 1 (gcm i %))]\n               i))))","problem":75,"user":"52667ecfe4b03e8d9a4a713e"},{"problem":75,"code":"(fn [x] (if (= x 1) 1 (count (filter (fn [[a b]] (= 1 (last (filter #(= 0 (rem a %) (rem b %)) (range 1 (max a b)))))) (map #(vector x %1) (range 1 x))))))","user":"5659679ae4b068f2fe63dbeb"},{"code":"(fn euler-totient [x]\n  (letfn [(gcd [x y]\n               (letfn [(findcd [n]\n                               (filter #(and (< % (inc n)) \n                                             (= (rem n %) 0))\n                                       (range 1 (inc n))))]\n                 (loop [l (min x y),\n                        r (max x y)\n                        lc (reverse (findcd l)),\n                        rc (reverse (findcd r))]\n                   (if (some (conj #{} (first lc)) rc)\n                     (first lc)\n                     (recur l r (rest lc) rc)))))]\n    (cond\n      (= x 1) 1\n      :else (let [numbers (range 1 x)]\n              (count (filter #(= (gcd % x) 1) numbers))))))","problem":75,"user":"512474ede4b02c3f2a072cce"},{"code":"(fn [x]\n  (letfn [(hoge [y]  \n\t   (loop [x x y y]\n\t       (if (zero? (rem x y))\n\t\t       y\n\t\t       (recur y (rem x y)))))]\n\t(count (filter #(= 1 %) (for [num (range 1 (inc x))](hoge num))))))","problem":75,"user":"4db2cc55535df7e46ed9b6c5"},{"problem":75,"code":"(fn [n]\n   (letfn [(hcf [num curr acc]\n             (if (= curr num)\n               acc\n               (if (= 0 (mod num curr))\n                 (hcf num (+ curr 1) (conj acc curr))\n                 (hcf num (+ curr 1) acc))))]\n     (let [m (hcf n 1 [])]\n       (letfn [(co [num curr acc]\n                 (if (= curr num)\n                   acc\n                   (let [h (hcf curr 1 [])\n                         mo (mod num curr)]\n                     (if (and (not= 0 mo) (= (clojure.set/intersection (set h) (set m)) #{1} ))\n                       (co num (+ 1 curr) (conj acc curr))\n                       (co num (+ 1 curr) acc)))))]\n         (count (co n 1 [1]))))))","user":"53214efbe4b09d4e7a9b54b2"},{"problem":75,"code":"(fn totient [x]\n  (if (= 1 x)\n    1\n    (count\n    (filter\n      (fn cd [a] (= 1 (apply max (filter #( = (mod a %) (mod x %) 0 ) (range 1 (+ 1 (min a x)))))))\n      (range 1 x)))))","user":"57b99d48e4b0fbc9809a27f2"},{"code":"(fn eu-tot[n]\n   (if (= n 1) 1\n   (count\n    (filter #(= 1 %)\n            (map (partial\n                  (fn gcd[l r](cond\n                               (= 0 l) r\n                               (= 0 r) l\n                               (= l r) r\n                               (> l r) (gcd (- l r) r)\n                               (> r l) (gcd (- r l) l))) n)\n                 (range 1 n))))))","problem":75,"user":"4fb86dc9e4b081705acca2d8"},{"problem":75,"code":"(fn totient\n  [x]\n  (case x\n    1 1\n    (letfn [(gcd [a b] (if (zero? b) a (recur b (mod a b))))]\n      (count (filter #(= 1 (gcd % x)) (range x))))))","user":"4fcf1755e4b03432b189f40c"},{"problem":75,"code":"(fn eulers-totient [x]\n  (letfn [(gcd [a b] (if (zero? b) a (gcd b (mod a b))))]\n    (->> (range 1 (inc x))\n         (filter #(= 1 (gcd % x)) )\n         count)))","user":"55fbc657e4b0f488688e0666"},{"code":"(fn [n] (let [gcd (fn [a b] (cond (zero? b) a\n                (< a b) (recur b a)\n                :else (recur b (rem a b))))]\n      (count (filter #(= (gcd n %) 1) (range 1 (inc n))))))","problem":75,"user":"4f8345c6e4b033992c121c1b"},{"problem":75,"code":"(fn [x]\n   (let [gcd (fn [x y]\n               (loop [x x\n                      y y]\n                 (if (= 0 y)\n                   x\n                   (recur y (mod x y))\n                   )))\n         is-coprime? (fn [y] (= 1 (gcd x y)))]\n     (count (filter  is-coprime? (range x)))))","user":"5d1a1082e4b0902706380e0e"},{"problem":75,"code":"(fn [n]\n  (letfn [(seive [xs]\n            (if-let [[x & xs] (seq xs)]\n              (let [div-x? #(zero? (mod % x))]\n                (if (div-x? n)\n                  (->> xs (remove div-x?) recur)\n                  (inc (seive xs))))\n              0))]\n    (->> (range 2 n) seive inc)))","user":"53dfdf01e4b0d874e779ae46"},{"code":"(fn totient [n]  (if (= 1 n)    1  (letfn  [(gcd [a b]  (apply max (filter #(and (zero? (rem a %)) (zero? (rem b %) ))  (range 1 (inc(min a b))) )))]    (count   (filter #(= 1 (gcd %  n )  )   (range 1 n))  )    )  )  )","problem":75,"user":"4f4be1cae4b03ad3f0c10c81"},{"code":"(fn [n] (let [gcd #(cond (< %1 %2) (recur %2 %1) (zero? %2) %1 :else (recur %2 (rem %1 %2)))] (count (filter #(= 1 (gcd n %)) (range 1 (inc n))))))","problem":75,"user":"5134973ce4b0230e9f713b42"},{"code":"(fn [x]\n  (let [g (fn [x,y] (if (zero? y) x (recur y (mod x y))))]\n    (if (= x 1)\n        1\n        (count (filter #(= 1 (g x %)) (range 1 x))))))","problem":75,"user":"504e04a4e4b078edc5f59397"},{"code":"(fn [n]\n  (letfn [(my-gcd [a b]\n    (cond \n      (< a b) (my-gcd b a)\n      (= 0 (rem a b)) b\n      :else (my-gcd b (rem a b))))]\n  (count (for [x (range 1 (inc n)) :when (= 1 (my-gcd n x))] x))))","problem":75,"user":"50bfe725e4b080409b860f26"},{"code":"(fn [num]\n    (letfn [(gcd [a b] (if (= b 0) a (gcd b (mod a b))))]\n      (->> (range 1 (inc num))\n           (filter #(= 1 (gcd num %)))\n           count)))","problem":75,"user":"4f725466e4b07046d9f4f030"},{"problem":75,"code":"(fn [num]\n   (let [gcd (fn [x y]\n               (if (zero? y)\n                 x\n                 (recur y (mod x y))))]\n     (if (= num 1)\n       num\n       (count (filter vector?\n               (for [x (range 1 num)]\n         (when (= (gcd x num) 1)\n           [x])))))))","user":"5633bb9de4b0bfe05bf117b4"},{"problem":75,"code":"(fn [n] (count (filter (fn [i] (= 1 ((fn gcd [a b] (if (zero? b) a (gcd b (mod a b)))) i n))) (range n))))","user":"5e1cc888e4b0dc959400853d"},{"problem":75,"code":"(fn [x]\n  (if (= x 1)\n    1\n    (let [divisors #(reduce (fn [result each]\n                             (if (= 0 (rem % each))\n                               (conj result each)\n                               result))\n                           #{}\n                           (range 1 (dec %)))\n          x-divisors (divisors x)]\n      (reduce (fn [result each]\n                (if (= (count (clojure.set/intersection x-divisors (divisors each))) 1)\n                  (inc result)\n                  result))\n              0\n              (range 1 x)))))","user":"5989e080e4b021a7a535fed6"},{"problem":75,"code":"(fn [n]\n  (let [\n        nr (set (range 1 (inc n)))\n        divisors? (fn [k] (set (filter #(zero? (mod k %)) nr)))\n        n_divisors (divisors? n)\n        ]\n\n    (count \n        (filter\n           (comp \n              #(= 1 %)\n              count\n              #(clojure.set/intersection n_divisors (divisors? %)))\n         nr))\n\n ))","user":"5412646de4b01498b1a719d4"},{"code":"(fn [n]\n  (if (= n 1) 1\n    (let [gcd (fn f [a b] (if (zero? b) a (f b (mod a b))))]\n      (count (filter #(= 1 (gcd n %)) (range 1 n))))))","problem":75,"user":"4fd96694e4b05e33b9224f37"},{"code":"(fn [x]\n  (if (= x 1)\n    1\n    (let [gcd (fn gcd [a b] (if (= b 0) a (gcd b (mod a b))))]\n      (count (filter #(= (gcd % x) 1) (range 1 x))))))","problem":75,"user":"4ec07699535dfed6da9c6da2"},{"problem":75,"code":"(fn [x]\n  (let [gcd (fn [x y]\n              (loop [x x y y]\n                (let [nom (max x y)\n                      den (min x y)]\n                  (if (zero? den)\n                    nom\n                    (recur (rem nom den) den)))))]\n    (->> (range 1 (inc x))\n         (filter #(= 1 (gcd % x)))\n         count)))","user":"52fe31d5e4b047fd55837038"},{"code":"(fn totient [x]\n  (let [coprime? (fn coprime? [m n]\n    (let [ggt (fn ggt [m n]\n                (if (= n 0)\n                  m\n                  (ggt n (mod m n))))]\n      (= (ggt m n) 1)))]\n     (count (filter (partial coprime? x) (range 1 (inc x))))))","problem":75,"user":"50c8697ce4b00bb60fe0c53f"},{"code":"(fn [n] \r\n    (let [f (fn [a b] \r\n               (first (drop-while \r\n                        #(not (and (zero? (mod a %)) \r\n                                   (zero? (mod b %))))\r\n                        (range (min a b) 0 -1))))]\r\n      (count (filter #(= 1 (f n %)) (range n 0 -1)))\r\n      ))","problem":75,"user":"4f0da4e4535d0136e6c22319"},{"code":"(fn [n] \n  (count \n    (for [x (range n) \n          :when (= 1 (#(if (zero? %2) \n                         % \n                         (recur %2 (mod % %2))) \n                       x n))]\n      x)))","problem":75,"user":"4db091b7838c48654951d9c2"},{"problem":75,"code":"(letfn [(gcd [a b] (if (zero? a) b (recur (mod b a) a)))] (fn [x] (count (filter #(= (gcd % x) 1) (range x)))))","user":"584dadebe4b0b7285a6f4e44"},{"code":"(fn totient [n]\n  (->> (range 1 (max 2 n))\n       (map (partial (fn gcd [a b]\n                          (cond\n                           (< a b) (gcd b a)\n                           (= 0 b) a\n                           :else   (gcd b (mod a b))))\n                        n))\n       (filter #(= 1 %))\n       count))","problem":75,"user":"5326c5f7e4b09d4e7a9b54f2"},{"code":"(fn toitent [n]\n  (let [gcd (fn [a b] \n              (loop [a a b b] \n                (if (= a b) \n                  a \n                  (if (> a b) \n                    (recur (- a b) b) \n                    (recur a (- b a))))))]\n    (count (filter #(= (gcd % n) 1) \n                   (rest (take (inc n) (range)))))))","problem":75,"user":"52463059e4b09dbe66b56198"},{"code":"(fn [n]\n(count\n(loop [ i n\n       j (range n)\n       x n]\n\n  (if (> i 1)\n    (if (= 0 (mod x i))\n      (recur (dec i) (filter #(not (= 0 (mod % i))) j) x)\n      (recur (dec i) j x)\n      )\n    j\n    ))))","problem":75,"user":"5124619ae4b02c3f2a072ccd"},{"problem":75,"code":"(fn [n]\n  (if (= n 1) 1\n    (let [gcd\n          (fn [n1 n2]\n            (let [[lo hi] (sort [n1 n2])\n                  m (mod hi lo)]\n              (if (zero? m) lo\n                (recur lo m))))]\n      (count \n        (filter #(= 1 (gcd n %)) \n                (range 1 n))))))","user":"562cd94ee4b0a45d2ff83015"},{"code":"(fn [n] (letfn [(mdc [a b]\n                  (loop [a a b b] (if (zero? b) a (recur b (mod a b)))))]\n          (count (filter #(= 1 (mdc n %)) (range n)))))","problem":75,"user":"4efd8b67535de96065cf5085"},{"problem":75,"code":"(fn [n]\t  ; todo, improve performance ...\n(let [coprime? (fn [l s]\n  (empty? (filter #(and (= (mod s %) 0) (= (mod l %) 0)) (drop 2 (range (inc s))))))]\n  (count (filter (partial coprime? n) (drop 1 (range (inc n)))))))","user":"56051095e4b08b23635d3162"},{"code":"#(if (= 1 %) 1\n((frequencies (for [i (range 1 %)] ((fn [a b] (every? false? (for [i (range a 1 -1)] (= 0 (mod a i) (mod b i)))) ) i %))) true)\n)","problem":75,"user":"5107b86de4b05b2b4eee7495"},{"problem":75,"code":"(fn [n] (if (= n 1) 1 (count (filter #(= 1 (loop [[x y] [(min % n) (max % n)]] (if (zero? x) y (recur [(rem y x) x])))) (range 1 n)))))","user":"54f0d3fde4b024c67c0cf8a6"},{"problem":75,"code":"(fn [x]\n  (if (= x 1)\n   1\n  (letfn [(rle [a-seq]\n            (if (empty? a-seq)\n              a-seq\n              (loop [h (vector (first a-seq) 1) r (rest a-seq) acc []]\n                (if (empty? r)\n                  (conj acc h)\n                  (if (= (first r) (first h))\n                    (recur [(first h) (inc (second h))] (rest r) acc)\n                    (recur [(first r) 1] (rest r) (conj acc h)))))))\n          (expt [p n]\n            (if (zero? n)\n              1\n              (first (drop (dec n) (iterate #(* p %) p)))))\n          (totient [factors]\n            ;; Euler totient formula\n            ;; phi(p1^k1 p2^k2 ...) = p1^(k1-1) * (p1 -1)\n            (reduce #(let [[p k] %2] (* %1 (* (dec p) (expt p (dec k))))) 1 factors))]\n    (totient (rle (loop [n x divisors (range 2 (-> x Math/sqrt int inc)) acc []]\n                    (cond\n                      (empty? divisors) (conj acc n)\n                      (< n (first divisors)) acc\n                      :else\n                      (let [divisor (first divisors)\n                            m (mod n divisor)]\n                        (if (= m 0)\n                          (recur (/ n divisor) divisors (conj acc divisor))\n                          (recur n (rest divisors) acc))))))))))","user":"5f86a98be4b0649ffcda4caa"},{"problem":75,"code":"(fn __ [x]\n  (let [\n        f (fn primefactors [n nex acc]\n          (cond (<= n 1) acc\n                (zero? (rem n nex)) (recur (/ n nex) nex (conj acc nex))\n                :else (recur n (inc nex) acc)))\n        res (f x 2 #{})\n        invs (cons x (map (fn [x] (/ (- x 1) x)) res))\n        ]\n    (reduce * invs)))","user":"58bc6a88e4b0888cdc949d16"},{"problem":75,"code":"(fn [x]\n  (if (= 1 x)\n          1\n          (count (filter (fn [n]\n                    (let [gcd\n                          (fn [a b]\n                            (if (zero? b)\n                              a\n                              (recur b (mod a b))))] (= (gcd x n) 1))) (range 1 x)))))","user":"52efd3d9e4b05e3f0be25ed4"},{"problem":75,"code":"(fn et [n] (let [gcd-is-one? (fn [x] (= 1 ((fn gcd [a b] (if (zero? b) a (recur b (mod a b)))) n x)))\n                   nums (range 1 n)]\n                (if (= 1 n) 1 (count (filter true? (map gcd-is-one? nums))))))","user":"50e1bdd8e4b019fc399ce17f"},{"code":"(fn [n]\r\n  (let [f (fn f [x y] (let [a (max x y) b (min x y)] (if (= a b) a (f b (- a b)))))]\r\n        (-> (filter #(= 1 (f n %)) (range 2 n)) count inc)))","problem":75,"user":"4f8c5f4fe4b02e764a0a5198"},{"code":"(fn [x]\r\n  (let [gcd (fn [a b]\r\n              (if (= b 0) a\r\n                    (recur b (mod a b))))]\r\n    (if (= x 1) 1\r\n      (count (filter #(= 1 (gcd x %)) (range 1 x))))))","problem":75,"user":"502a9fdee4b095a7adb898b4"},{"code":"(fn [x]\n\t\t       (letfn [(gcd [a b]\n\t\t\t\t    (if (zero? (mod a b))\n\t\t\t\t\tb\n\t\t\t\t\t(gcd b (mod a b))))]\n\t\t\t\t\t(if (= x 1) 1\n\t\t\t\t\t    (count (filter #(= (gcd % x) 1) (range 1 x))))))","problem":75,"user":"4e68fad4535d8ccf87e9fe93"},{"code":"(fn [n]\n\t(if (= n 1)\n\t\t1\n\t\t(->> n\n\t\t\t(range 1)\n\t\t\t(filter #(= 1 (loop [a n b %1] (cond (< a b) (recur b a) (zero? b) a :else (recur b (- a b))))))\n\t\t\t(count)\n\t\t)\n\t)\n)","problem":75,"user":"527ba695e4b03e8d9a4a7596"},{"problem":75,"code":"(fn [n]\n  (if (= 1 n)\n    1\n    (let [divided?\n          (fn [div del]\n            (= 0 (mod div del)))\n          getdivs\n          (fn [x] (set (filter #(divided? x %) (range 1 (inc x)))))\n          ndivs (getdivs n)\n          coprime?\n          (fn [x]\n            (= 1 (count (filter\n                  #(contains? ndivs %)\n                  (getdivs x)))))\n          res (filter coprime? (range 1 n))]\n      (count res))))","user":"592334c7e4b0a390037439ee"},{"problem":75,"code":"#(if (= 1 %) 1 \n   (let [gcd (fn [a b] (let [g (fn g [x y] (if (= 0 (mod y x)) x (g (mod y x) x)))]\n             (apply g (sort [a b]))))\n         cp-s (filter (fn [x] (= 1 x)) (map (fn [x] (gcd % x)) (rest (range %))))]\n     (count cp-s)))","user":"5a4de614e4b05d388ecb6bb1"},{"problem":75,"code":"#(let [f (fn [a b]\n            (cond \n             (zero? a) b\n             (zero? b) a\n             :else (recur b (rem a b))))\n       l (filter (fn [n](= 1 (f % n))) (range 1 %))]\n   (if (empty? l) 1 (count l)))","user":"5b59d176e4b02d533a91bd86"},{"code":"(fn etf[x]\n  (if (= x 1) 1\n          (count (filter\n                  #(= 1 (loop [a x b %]\n                           (cond (= a 0) b\n                                 (= b 0) a\n                                 (< a b) (recur a (- b a))\n                                 :else (recur b (- a b)))))\n                  (range 1 x)))))","problem":75,"user":"4e842ebb535db62dc21a62df"},{"code":"(fn [n]\n  (if (> 2 n)\n    1\n    (letfn [(gcd [a b] (if (zero? a) b (recur (mod b a) a)))]\n      (count (filter #(and (pos? %) (= 1 (gcd % n))) (range n)))\n    )\n  )    \n)","problem":75,"user":"507eddf4e4b06ce648bcdbfa"},{"problem":75,"code":"; (defn gcd [a b] (if (zero? b) a (recur b (mod a b))))\n; (defn coprime [a b] (= 1 (gcd a b)))\n; (defn totient [n] (count (filter #(coprime % n) (range n))))\n; (defn coprime [a b] (if (zero? b) (= 1 a) (recur b (mod a b))))\n\n(fn [n] (count (filter #((fn [a b] (if (zero? b) (= 1 a) (recur b (mod a b)))) % n) (range n))))","user":"54bd04e7e4b0ed20f4ff6ed8"},{"code":"(fn [n] (max 1 (count (filter #(= 1 (loop [a n b %] (if (= b 0) a (recur b (rem a b))))) (range 1 n)))))","problem":75,"user":"4e9609ad535dbda64a6f6b3e"},{"problem":75,"code":"(fn eulers-totient [num]\n                         (if (= num 1)\n                           1\n                           (let [gcd (fn gcd [a b]\n                                       (let [lower (min a b)]\n                                         (some #(if (= 0 (rem a %) (rem b %))\n                                                  %\n                                                  false) (range lower 0 -1))))\n                                 nums-below (range 1 num)\n                                 totient (for [t nums-below :when (= 1 (gcd num t))]\n                                           t)]\n                             (count totient))))","user":"54cad2d5e4b057c6fda3a26c"},{"problem":75,"code":"(fn tot [x]\n      (if (= x 1) 1 (count (filter #(= 1 %) (map (fn gcd [a b] (if (zero? (mod a b)) b (recur b (mod a b)))) (repeat x x) (range 1 x))))))","user":"5acd1a43e4b0e27600da7823"},{"problem":75,"code":"(fn totient [x]\n  (let [gcd (fn [x y] (if (zero? (rem x y)) y (recur y (rem x y))))\n        coprime? (fn [x y] (= 1 (gcd x y)))]\n    (if (= 1 x) \n      1\n      (count (filter (partial coprime? x) (range 1 x))))))","user":"5bea3177e4b0f319e2d7ec81"},{"problem":75,"code":"(fn totient [n]\n  (letfn [(gcd [a b]\n            (if (zero? b)\n              a\n              (recur b (mod a b))))]\n    (if (= n 1)\n      1\n      (->> (range 1 n)\n           (map (partial gcd n))\n           (filter (partial = 1))\n           count)\n      )))","user":"572ea970e4b0cd1946bd0f89"},{"code":"(fn [n]\n  (letfn [(gcd [a b] \n             (if (> b a) \n               (recur b a) \n               (if (zero? b) a (recur b (mod a b)))))]\n    (count (filter #(= 1 (gcd % n)) (range 1 (inc n))))))","problem":75,"user":"52dd4fb4e4b09f7907dd13df"},{"problem":75,"code":"(fn [x](reduce + 1 (into [] (map (fn [n] (loop [a x b n]\n  (cond\n   (< a b) (recur (- b a) a)\n   (< b a) (recur (- a b) b)\n   :else (if (= 1 a) 1 0)))) (range 2 x)))))","user":"5a1c8c26e4b0ff51aa4b3247"},{"problem":75,"code":"(fn [n]\n  (letfn [(gcd [a b]\n               (if (> b a) (recur b a)\n                 (let [result (mod a b)]\n                   (if (zero? result) b\n                     (recur result b)))))]\n         (count (filter #(= (gcd n %) 1) (range 1 (inc n))))))","user":"56bf4ac0e4b0f26550335985"},{"code":"(fn [n]\n  (letfn [(gcd [a b] (if (zero? a) b (recur (rem b a) a)))]\n    (count (filter #(= 1 (gcd % n)) (map inc (range n))))))","problem":75,"user":"51ac6360e4b09397d510976c"},{"problem":75,"code":"(fn totient [x] (->> x\n                     range\n                     (map #(.gcd (biginteger x) (biginteger %)))\n                     (filter #{1})\n                     count))","user":"5bafd5c8e4b0a20761a234dd"},{"problem":75,"code":"(fn [n]\n  (if (= n 1)\n    1\n    (let [coprime? (fn [a b] (= '(1) \n                                (filter \n                                  (fn [x] (and (zero? (rem a x)) \n                                               (zero? (rem b x)))) \n                                  (range 1 (inc (min a b))))))]\n      (count \n        (filter (fn [x] \n                  (coprime? n x)) \n                (range n))))))","user":"5596a324e4b04c1e5c31d757"},{"code":"(fn phi [n]\n         (letfn [(gcd [a b]\n                   (let [r (mod a b)]\n                     (if (= r 0)\n                       b\n                       (gcd b r))))\n                 (co-prime [m n]\n                   (if (= m 1)\n                     true\n                     (= 1 (gcd m n))))]\n           (->>\n             (range 1 (inc n))\n             (filter #(co-prime % n))\n             (count))))","problem":75,"user":"4f1bee08535d64f60314647e"},{"code":"(fn [n]\n  (letfn\n      [(gcd [m]\n         (reduce\n          #(if (and (zero? (mod m %2))(zero? (mod n %2)))  (max % %2) %)\n          (range 1 (inc m))))]\n    (count (mapcat (fn [x] (when (= 1 (gcd x)) [x])) (range 1 (inc n))))\n   )\n  )","problem":75,"user":"519b7d76e4b02a926d9a436e"},{"code":"#(count \n  (filter  \n   (fn [x] \n     (= 1 \n        ((fn gcd [x y] \n           (if (= 0 (mod x y))\n             y\n             (gcd y (mod x y))))\n         x %))) \n   (range 1 (inc %))))","problem":75,"user":"51805d22e4b0e3fc13e244df"},{"problem":75,"code":"(fn totient [x]\n  (let [divisors (fn [n] (set (filter #(integer? (/ n %)) (range 2 (inc n)))))\n        x-divisors (divisors x)]\n    (reduce (fn [d n]\n              (if (empty? (clojure.set/intersection x-divisors (divisors n))) (inc d) d)) 1 (range 2 x))))","user":"4e9ff8d0535d7eef3080729c"},{"problem":75,"code":"(fn tot [x]\n\n  (letfn [(flist [x]()\n\n            (letfn [(divisor? [y] (zero? (mod x y)))]\n\n             (set\n\n              (filter divisor? (range 1 (inc x))))))\n\n          (cop? [y] (= #{1} (clojure.set/intersection (flist x) (flist y))))]\n\n    (->> x\n\n      (inc)\n\n      (range 1)\n\n      (filter cop?)\n\n      (count))))","user":"57487084e4b009280f9f2b8c"},{"problem":75,"code":"(fn [n]\n (let [my-euklid (fn [a b] \n  (let [the-rest (mod a b)]\n    (if (zero? the-rest)\n        b\n        (recur b the-rest))))]\n \n(let [res (map #(my-euklid % n) (range 1 (inc n)))\n      f-res (filter #(= 1 %) res)]\n ;(prn f-res)\n (count f-res))))\n ; 40)","user":"58566b42e4b0f14aab7c86f4"},{"code":"(fn [x] (if (= x 1) x (count (filter (fn [y] (= 1 (.gcd (bigint x) (bigint y)))) (range 1 x)))))","problem":75,"user":"4f83665ee4b033992c121c1c"},{"code":"(fn [x]\n  (let [gcd #(if (= %2 0) %1 (recur %2 (mod %1 %2)))]\n    (loop [n x c 0]\n      (if (= n 1)\n        (inc c)\n        (if (= (gcd x n) 1)\n          (recur (dec n) (inc c))\n          (recur (dec n) c))))))","problem":75,"user":"4e44358f535dc968683fc4a8"},{"code":"(fn [num]\n   (loop [result [1] i 2]\n     (if (< i num)\n       (recur \n         (if (= 1 ((fn ! [numa numb]\n\t\t\t\t\t\t\t\t\t   (if (= 0 (mod numa numb))\n\t\t\t\t\t\t\t\t\t     numb\n\t\t\t\t\t\t\t\t\t     (! numb (mod numa numb))\n\t\t\t\t\t\t\t\t\t     )\n\t\t\t\t\t\t\t\t\t   ) num i))\n           (conj result i)\n           result)         \n         (inc i)\n         )       \n       (count result)\n     )\n     )\n   )","problem":75,"user":"5106dc1be4b01150e115ebf0"},{"problem":75,"code":"(fn [n]\n  (let [gcd (fn [m n] (if (zero? n) m (recur n (mod m n))))]\n    (count (filter #(= (gcd n %) 1) (range n)))))","user":"5d97b602e4b0d3f9b434ad3a"},{"problem":75,"code":"(fn [n]\n  (if (= 1 n)\n    1\n    (count \n      (filter \n        (fn [x]\n           (= 1 \n              (last\n               (filter #(= 0 (+ (mod x %) (mod n %)))\n                       (range 1 (inc(min x n)))))))\n        (range 1 n)))))","user":"5522cd9ae4b0882d96d091ab"},{"problem":75,"code":"(fn [n]\n  (if (= 1 n) \n    1\n    (let [gcd (fn[a b]\n                (if (zero? b) a (recur b (mod a b))))]\n      (count (filter #(= 1 (gcd n %)) (map inc (range (dec n))))))))","user":"5472cba1e4b094393f72dd7a"},{"code":"(fn [x]\n  (letfn [(gcd [a b]\n            (cond\n             (= b 0) a\n             (> a b) (recur b (rem a b))\n             :else (recur b a)))\n          (coprime? [a b]\n            (= 1 (gcd a b)))]\n    (if (= 1 x) 1\n        (count (filter #(coprime? x %) (range 1 x))))))","problem":75,"user":"51b38769e4b026427ecf067f"},{"problem":75,"code":"(fn tut\n  [x]\n  (if (= 1 x)\n    1\n    (let [gcd (fn gcd [a b]\n                (if (zero? (mod a b))\n                  b\n                  (gcd b (rem a b))))]\n      (count (for [i (range x)\n             :when (= 1 (gcd i x))]\n         i)))))","user":"59390a35e4b02506e01a29f3"},{"problem":75,"code":"(fn cop [n]\n  (if (not= n 1)\n    (let [gcd #(if (= 0 %1) %2\n               (recur (mod %2 %1) %1))]\n      (->>\n        (range 1 n)\n        (filter #(= 1 (gcd n %)))\n        (count)))\n    1))","user":"5ba15075e4b0a20761a2339e"},{"code":"(fn totient [n]\n (letfn [(gcd [a b] (if (zero? b) a (gcd b (mod a b))) )]\n   (count (filter #(= (gcd n %) 1) (range n)))) )","problem":75,"user":"4fa17b00e4b0dcca54ed6d5f"},{"problem":75,"code":"(fn mytotient [n]\n  (let [gcd (fn gcd [a b] (if (= a b) a (if (> a b) (gcd (- a b) b) (gcd a (- b a)))))]\n    (if (= n 1) 1\n     (count (filter #(> %1 0) (for [i (range 1 n)]\n       (if (= (gcd i n) 1) 1 0)))))))","user":"52747090e4b03e8d9a4a74a5"},{"code":"(fn [x]\n  (if (= x 1) 1\n    (letfn [(gcd [x y] \n              (if (zero? y) x \n                (gcd y (mod x y))))]\n    (count\n      (filter\n        #(= 1 (gcd x %))\n        (range 1 x))))))","problem":75,"user":"4fce5474e4b0d4b2a7a9d451"},{"code":"(fn [x]\n  (letfn [(gcd [x y]\n            (->> (min x y) (iterate dec) (filter #(and (zero? (mod x %)) (zero? (mod y %)))) first))\n          (coprime? [x y]\n            (== 1 (gcd x y)))\n          (coprimes [x]\n            (filter (partial coprime? x) (range 1 x)))]\n    (if (= 1 x)\n      1\n      (count (coprimes x)))))","problem":75,"user":"4fe13ad7e4b0dd6cd5ce3632"},{"problem":75,"code":"(fn euler-totient\n  [n]\n  (if (= n 1) 1 (count (filter #(= 1 %)\n                        (for [i (map list (range 1 n) (repeat n))]\n                          (apply (fn gcd-ms [a b]\n                                   (- (min a b)\n                                      (.indexOf (map #(+ (mod a %) (mod b %))\n                                                     (range(min a b) 0 -1)) 0))) i))))))","user":"561ca6ebe4b064ca9f4b169c"},{"problem":75,"code":"(fn [x]\n  (if (= x 1) 1\n      (letfn [(gcd [a b] (if (zero? b) a (gcd b (rem a b))))]\n        (count (filter #(= 1 (gcd x %)) (range 1 x))))))","user":"5d81eba4e4b0915913b1d37b"},{"problem":75,"code":"(fn totient [n] (let [gcd (fn [x y]\n\t\t\t\t\t\t\t\t\t\t\t\t\t  (loop [counter (min x y)]\n\t\t\t\t\t\t\t\t\t\t\t\t\t    (if (and (= 0 (rem x counter)) (= 0 (rem y counter)))\n\t\t\t\t\t\t\t\t\t\t\t\t\t      counter\n\t\t\t\t\t\t\t\t\t\t\t\t\t      (recur (dec counter)))))]\n                   (count (filter #(= 1 (gcd %1 n)) (map inc (range n))))))","user":"5df0c6ffe4b093ff717275c2"},{"problem":75,"code":"(fn [n]\n  (letfn [(gcd [a b]\n               (if (zero? b)\n                 a\n                 (recur b (mod a b))))]\n    (count (filter #(= 1 %) (map #(gcd % n) (range n))))))","user":"544cf5d7e4b0e39780006977"},{"problem":75,"code":"(fn [x]\n    (if (= x 1) 1\n      (let [gcd (fn [a b]\n                  (loop [a a b b d 0 n 0]\n                    (if (> n 50) nil\n                      (let [ie? (every-pred integer? even?)\n                            e? (every? ie? [a b])\n                            xf #(cond (ie? %1) (/ %1 2)\n                                      (and (not (ie? %2)) (> %1 %2)) (/ (- %1 %2) 2)\n                                      :else %1)]\n                        (if (and (not e?) (= a b))\n                          (*' a (apply * (repeat d 2)))\n                          (recur (xf a b) (xf b a) (if e? (inc d) d) (inc n)))))))]\n        (count (filter #(= 1 (gcd x %)) (range 1 x))))))","user":"55342ee0e4b09218d5f44f98"},{"code":"(fn [i]\n    (+ 1 (count (filter\n      (fn [j] (= () (filter #(= 0 (mod j %) (mod i %)) (range 2 (+ 1 j) ))))\n      (range 2 i)))))","problem":75,"user":"4e43b0d9535dc968683fc4a3"},{"problem":75,"code":"(fn totient [x]\n  (let [gcd (fn gcd [a b](if (zero? b) a (recur b (mod a b))))]\n    (reduce #(if (<= (gcd x %2) 1) (inc %1) %1) 0 (range 1 (inc x)))))","user":"560843dee4b046a4fc0ac00e"},{"code":"(fn coprimes-less-than [x]\n  (if(= 1 x) \n        1\n        (count \n          (letfn [(gcd [a b](cond\n                              (zero? a) b\n                              (zero? b) a\n                              :else (recur b (rem a b))))]\n            (for [i (range 1 x) \n                  :when (= 1 (gcd x i))] i)))))","problem":75,"user":"4ecfa05c535d44c135fd68b9"},{"code":"(fn [n]\n  (letfn [(gcd [k m] (if (zero? m) k (recur m (mod k m))))]\n    (if (= 1 n)\n      1\n      (count (filter #(= 1 (gcd n %)) (range 1 n))))))","problem":75,"user":"4e9519b4535dbda64a6f6b2d"},{"code":"(fn [x] \n  (let [g (fn g [a b] (if (= a 0) b (g (mod b a) a)))]\n    (count (filter #(= 1 (g % x)) (range x)))))","problem":75,"user":"525cc137e4b0cb4875a45d46"},{"problem":75,"code":"(fn euler\n  [n]\n  (let [gcd (fn [a b] (if (zero? b) a (recur b (mod a b))))]\n    (count (if (> 2 n)\n             [1]\n             (filter #(= 1 (gcd % n)) (range 1 n))))))","user":"4e586949535d8a8b8723a292"},{"code":"(fn [x]\n  (let [gcd (fn [a b]\n             (cond\n              (= b 0) a\n              (= a 0) b\n              (> a b) (recur b (mod a b))\n              :else (recur a (mod b a))))\n        coprime? #(= (gcd % x) 1)]\n       (if (= 1 x) 1\n           (count (filter coprime? (range 1 x))))))","problem":75,"user":"52d02380e4b07d0d72b273b7"},{"code":"(fn [m]\r\n   (if (= m 1) 1\r\n   (count \r\n     (filter #(= 1 %) \r\n             (map (partial \r\n                    (fn gcd [a b]\r\n                      (if (zero? b) a\r\n                        (gcd b (mod a b)))) m) (range 1 m))))))","problem":75,"user":"4f29cdc8e4b0d6649770a033"},{"problem":75,"code":"(fn[n]\n  (let [gcd   #(if (= 0 %2)  %  (recur %2 (mod % %2)))\n        nums  (range 1 (inc n))]\n    (count (filter #(= 1 (gcd n %)) nums))))","user":"58cbdc3be4b03c36ff7e5856"},{"code":"(fn [n]\n  (count\n    (filter\n      #(= (loop [a % b n c a]\n            (if (= (mod a c) (mod b c) 0)\n              c\n              (recur a b (- c 1)))) 1)\n      (range 1 (+ 1 n)))))","problem":75,"user":"51a10b2ce4b0b292b01ee3fe"},{"problem":75,"code":"(fn etf [x]\n  (let [coprime (fn [a b]\n\t(if (= b 1) true\n\t\t(loop [n (min a b)]\n\t\t\t(if (= n 1) true\n\t\t\t\t(if (= (mod a n) (mod b n) 0) false\n\t\t\t\t\t(recur (dec n)))))))]\n\t(loop [n 0 k x]\n\t\t(if (= k 0) n\n\t\t\t(recur (if (coprime x k) (inc n) n) (dec k))))))","user":"563d12f9e4b0bfe05bf11845"},{"problem":75,"code":"(fn [x]\n  (cond (= 1 x) 1\n        true (->> (range 1 (inc x))\n       \t\t\t  (map #(/ % x))\n                  (filter #(and (ratio? %) (= x (denominator %))))\n                  (count))\n  )\n)","user":"57c7a8b5e4b05aa3c4741d09"},{"code":"(fn [x] (if (= 1 x) 1\n                    (count (filter #(= 1\n                                       ((fn g [a b] (if (= b 0) a (g b (mod a b))))\n                                        x %))\n                                   (range x)))))","problem":75,"user":"4f0664bd535dcb61093f6c0f"},{"problem":75,"code":"(fn [n] \n  (if (= n 1) \n    1 \n    (count \n     (filter #(= 1 %) \n             (map \n              (partial \n               #(cond \n                 (= %2 0) % \n                 (= %2 1) 1 \n                 :else (recur %2 (mod % %2))) n) \n              (range 1 n))))))","user":"579c35fee4b05b1deef9ae04"},{"code":"(fn [n]\n  (letfn [(gcd [a b] (if (zero? b) a (recur b (mod a b))))\n          (coprime [a b] (= (gcd a b) 1))]\n    (count (filter (partial coprime n) (range 1 (+ 1 n))))))","problem":75,"user":"526439a4e4b03e8d9a4a70cc"},{"problem":75,"code":"(fn eulers-totient [n]\n  (if (> n 1)\n    (letfn [[coprime [a b]\n              (= (gcd a b) 1)]\n            [gcd [x y]\n              (let [a (if (> x y) x y)\n                    b (if (> x y) y x)]\n                (if (= b 0)\n                  a\n                  (recur (rem a b) b)\n                  )\n                  )]]\n        (+ 1(count (filter (partial coprime n) (range 2 n))))\n      )\n      1\n    )\n  )","user":"5245e320e4b09dbe66b56177"},{"problem":75,"code":"(fn euler-totient [x]\n  (let [greatest-common-divisor (fn greatest-common-divisor [a b]\n                                  (cond\n                                    (= 0 b) a\n                                    (= 0 a) b\n                                    (>= a b) (recur (- a b) b)\n                                    :else (recur a (- b a))))]\n    (->> (range x)\n         (filter (fn [n] (= 1 (greatest-common-divisor n x))))\n         count)))","user":"5c506951e4b0f9f7a8770ec5"},{"problem":75,"code":"(fn totient [x]\n  (letfn [(my-gcd [x y]\n            (.gcd (.toBigInteger (+ 0M x)) (.toBigInteger (+ 0M y))))]\n    (let [candidates (range 1 x)\n          coprimes (filter #(= 1 (my-gcd % x)) candidates)]\n      (if (= 1 x)\n        1\n        (count coprimes)))))","user":"53bf0913e4b0c98a41f5cc99"},{"problem":75,"code":"(fn [n]\n   (letfn [(divides? [n m] (zero? (rem n m)))\n           (not-divides? [n m] (not (divides? n m)))\n           (calc-exp [n p]\n             (loop [n n\n                    e 0]\n               (if (not (divides? n p)) [e n]\n                   (recur (quot n p) (inc e)))))\n           (factor [n]\n             (let [sqrt (int (Math/sqrt n))]\n               (loop [n n\n                      ps (range 2 (inc sqrt))\n                      res []]\n                 (if (empty? ps)\n                   (if (= 1 n) res (cons [n 1] res))\n                   (let [[ph & pt] ps\n                         [e q] (calc-exp n ph)\n                         next-ps (filter #(not (divides? % ph)) pt)]\n                     (if (= 0 e)\n                       (recur n next-ps res)\n                       (recur q next-ps (cons [ph e] res))))))))]\n     \n     (let [not-devides? #(not= 0 (rem %1 %2))\n           pow #(reduce * (repeat %2 %1))]\n       (reduce * (map #(let [[p e] %]\n                         (* (dec p) (pow p (dec e))))\n                      (factor n))))))","user":"5e3ef7d4e4b01d43a70e8e2d"},{"code":"(fn [n]\n  (count (filter\n    #(=\n      1\n      ((fn gcd [a b]\n        (if (= 0 b)\n          a\n          (gcd b (mod a b)))) n %))\n    (range 1 (inc n)))))","problem":75,"user":"4fb1325de4b081705acca276"},{"problem":75,"code":"(fn [n]\n    (if (= 1 n) 1\n                (count (filter (fn [v1] (loop [b n s v1]\n                                          (if (zero? s) (= 1 b) (recur s (rem b s))))) (range 1 n)))))","user":"5310e968e4b08068f379ecdd"},{"problem":75,"code":"(fn [x]\n  (if (= 1 x)\n    1\n    (->> (range 1 x)\n        (map (fn [y]\n                (loop [a x\n                      b y]\n                  (if (zero? b)\n                    (= 1 a)\n                    (recur b (mod a b))))))\n        (filter true?)\n        (count))))","user":"5b64370ae4b0c6492753e73c"},{"problem":75,"code":"(fn __ [n]\n  (letfn [(gcd [a b] (if (zero? b) a (gcd b (mod a b))))\n          (coprime? [a b] (= (gcd a b) 1))]\n    (count (filter #(coprime? n %) (range 1 (inc n))))))","user":"58f44c07e4b0438e51c2ceb7"},{"code":"(fn [n]\n       (let [gcd\n       (fn gcd [p q]\n\t       (cond (or (= 0 p) (= 0 q)) (+ p q)\n\t\t     (or (= 1 p) (= 1 q)) 1\n\t\t     :default (gcd q (mod p q))))\n\t     coprimes?\n\t     (fn [p q] (= 1 (gcd p q)))]\n\t (if (= 1 n) 1\n\t     (count (filter #(coprimes? % n) (range 1 n))))))","problem":75,"user":"4e49a7bb535dc968683fc4c6"},{"problem":75,"code":"(fn [x]\n  ;(defn gcd [x y] (last (filter (fn [a] (and (= (mod x a) 0) (= (mod y a) 0))) (map inc (range (min y x))))))\n  (count (filter (fn [z] (= (last (filter (fn [a] (and (= (mod x a) 0) (= (mod z a) 0))) (map inc (range (min x z))))) 1)) (map inc (range x)))\n))","user":"592ac550e4b072a2710fcf27"},{"code":"(fn [n] (->>\n  (range n)\n  (map\n    #(if (zero? %2) %1 (recur %2 (mod %1 %2)))\n   (repeat n))\n  (filter #(= 1 %))\n  count))","problem":75,"user":"4fc0853ae4b081705acca327"},{"problem":75,"code":"(fn [n]\n  (let [f (fn f [x y]\n               (if (= x 0)\n                 y\n                 (if (< x y)\n                   (f (- y x) x)\n                   (f (- x y) y))))]\n    (if (= n 1)\n      1\n      (count (filter #(= 1 (f % n)) (rest (range n)))))))","user":"55205564e4b08d5046aa8a60"},{"problem":75,"code":"(fn [n] (if (= 1 n)\n1\n(->> n\n          (range 1)\n(filter \n  (fn [q] \n   (not (some \n(fn [d]  (= 0 (mod n d) (mod q d)))\n(range 2 (inc q))))) \n)\n(count))))","user":"58e37946e4b005f69f193cae"},{"problem":75,"code":"#(condp = % 1 1 10 4 40 16 99 60)","user":"5e8ce2fee4b0cb0169546328"},{"problem":75,"code":"(fn [x]\n  (if (= 1 x) 1\n      (get (frequencies (map (partial (fn [a b]\n                                        (apply max (filter #(= 0 (mod a %) (mod b %)) (range 1 (inc (min a b)))))) x) (range 1 x))) 1)))","user":"58f5b58ae4b0438e51c2cedc"},{"problem":75,"code":"(fn [v]\n   (letfn [(gcd\n             [a b]\n             (if (zero? b) a\n                           (recur b (rem a b))))]\n     (count (filter #(= 1 (gcd % v))\n                    (range v)))))","user":"54a11042e4b09f271ff37c49"},{"problem":75,"code":"(fn [x]\n  (letfn [(gcd [a b]\n            (if (zero? b)\n              a\n              (recur b (mod a b))))\n          (coprime? [a b]\n            (= (gcd a b) 1))]\n    (count (filter (partial coprime? x) (range x)))))","user":"580bd81ee4b0849f6811b711"},{"code":"(fn [n]\n  (if (= 1 n)\n    1\n    (letfn\n      [(gcd [i j] (if (zero? j) i (gcd j (mod i j))))]\n      (count (filter #(= 1 (gcd % n)) (range 1 n))))))","problem":75,"user":"4f03641a535dcb61093f6a9b"},{"code":"(fn [n]\n  (letfn [(gcd [a b] (if (= b 0) a (gcd b (mod a b))))]\n    (count (filter #(= 1 (gcd n %)) (range 0 n)))))","problem":75,"user":"4fc8c8d8e4b0ee37620e183b"},{"code":"(fn [n]\r\n  (if (= n 1) 1\r\n  (letfn [(coprime? [x y] (loop [z 2] (cond\r\n                                        (> z (min x y)) true\r\n                                        (= 0 (mod x z) (mod y z)) false\r\n                                        :else (recur (inc z)))))]\r\n  (->>\r\n    n\r\n    (range 1)\r\n    (filter #(coprime? % n))\r\n    count))))","problem":75,"user":"4e02bee8535d04ed9115e791"},{"code":"(letfn [\n  (lnko [a b] \n    (if (zero? a) b\n      (if (> a b) (recur b a)\n        (recur a (- b a)))))]\n  (fn tot [n]\n    ( ->> (range 2 n)\n      (filter #(== 1 (lnko % n)))\n      (count)\n      (inc))))","problem":75,"user":"50901b2ee4b0ea685a20f774"},{"code":"(fn [n]\n    (let [gcd #(loop [a %1, b %2] \n                 (if (= 0 b)\n                   a   \n                   (recur b (mod a b))))]\n      (count (filter #(= 1 (gcd %1 n)) (range n)))))","problem":75,"user":"4f038567535dcb61093f6b0c"},{"problem":75,"code":"(fn phi2\n  [n]\n  (if (= n 1)\n    1\n    (count\n      (filter\n        #(=\n          1\n          ((fn [a b]\n            (if (zero? b)\n             a\n             (recur b (mod a b)))) % n))\n      (range 1 n)))))","user":"56050f06e4b08b23635d3161"},{"code":"#(apply + 1 (for [x (range 1 %)]\n              ((fn f [y z] \n                 (or (#{0 1} (rem y z)) (f z (rem y z))))\n               % x)))","problem":75,"user":"4e823ed7535db62dc21a62c7"},{"problem":75,"code":"(fn [n]\n  (let [gcd\n        (fn f [a b]\n          (if (= a b)\n            a\n            (if (> a b)\n              (f (- a b) b)\n              (f a (- b a)))))]\n    (if (= 1 n)\n      1\n      (count (filter #(= 1 %) (map #(gcd n %) (range 1 n)))))))","user":"551c66dae4b07993ea3788de"},{"code":"(fn [n]\n  (letfn [(gcd [a b] (first (filter #(= 0 (rem a %) (rem b %)) (range (min a b) 0 -1))))\n          (cop? [a b] (= 1 (gcd a b)))]\n    (if (= 1 n) 1 (count (filter #(cop? n %) (range 1 n))))))","problem":75,"user":"4ea365e2535d7eef308072c5"},{"code":"(fn\r\n    [x]\r\n    (letfn [(gcd [m n]\r\n              (if (zero? n)\r\n                m\r\n                (recur n (mod m n))))\r\n            (coprime? [n k] (= 1 (gcd n k)))]\r\n  (count (filter #(coprime? % x) (range 0 x)))))","problem":75,"user":"4e26e8b4535deb9a81d77ef6"},{"problem":75,"code":"(fn [n]\n    (letfn [(dvsrs [x] (filter #(zero? (mod x %)) (range 1 (inc x))))]\n      (count (filter #(= (list 1) (filter (set (dvsrs %)) (dvsrs n)))\n               (range 1 (inc n))))))","user":"5ccf99fbe4b0ccb0619628c8"},{"problem":75,"code":"(fn [n]\n  (letfn [(gcd [a b] (if (zero? b) a (gcd b (mod a b))))]\n    ((comp count (partial filter #(= (gcd n %) 1))) (range n))))","user":"506f0968e4b09350ab4199f5"},{"problem":75,"code":"(fn totient [x]\n    (letfn [(factorize [number]\n                (->> number\n                    inc\n                    (range 2)\n                    (filter #(zero? (rem number %)))\n                    set))\n            (coprime? [number-1 number-2]\n              (empty?\n                  (clojure.set/intersection (factorize number-1)\n                                            (factorize number-2))))]\n    (if (= x 1) 1\n    (reduce #(if (coprime? %2 x) (inc %1) %1)\n            0\n            (range 1 x)))))","user":"5f548678e4b0a0bc16850a7e"},{"problem":75,"code":"(fn [n]\n  (if (= 1 n)\n    1\n    (->> (range 1 n)\n         (filter (fn [k]\n                   (loop [i 2]\n                     (cond\n                      (and (zero? (mod n i))\n                           (zero? (mod k i))) false\n                      (> i k) true\n                      :else (recur (inc i))))))\n         (count))))","user":"4f041de1535dcb61093f6ba5"},{"problem":75,"code":"(fn [n] (if (= 1 n) 1\n     (letfn [(coprim [a b] (if (= 1 (min a b)) true\n               (if (= 0 (min a b)) false   \n                   (if (= a b) false       \n                       (if (> a b) (recur  (- a b) b)\n                                   (recur a (- b a) )\n                       )\n                    )\n                )\n              ))\n             (cprims [res t y] (if (> t y ) res\n                       (if (coprim t y)\n                            (recur (conj res t) (inc t) y)\n                            (recur res (inc t) y)\n                        )\n                     ))\n             ]\n         (count (cprims [] 1 n))\n       )\n))","user":"59ff9424e4b01bb0ae8afd24"},{"code":"(letfn [(gcd [m n]\r\n          (if (zero? m)\r\n              n\r\n              (recur (mod n m) m)))]\r\n(fn [n]\r\n  (if (== n 1) 1\r\n    (count (filter #(== 1 (gcd n %)) (range 1 n))))))","problem":75,"user":"4fcc6cb3e4b0ee37620e1861"},{"code":"(fn [x]\r\n  (let [jgcd #(.gcd (BigInteger/valueOf %1) (BigInteger/valueOf %2))\r\n        coprime? #(= 1 (jgcd %1 %2))\r\n        x-to-1 (range x 0 -1)]\r\n          (count (filter (partial coprime? x) x-to-1))))","problem":75,"user":"4ded27db535d08e6dec9fe0a"},{"problem":75,"code":"(fn [x]\n   (if (= x 1)\n     1\n     (let [->divisors (fn [n]\n                        (reduce\n                          (fn [acc x]\n                            (let [pair (/ n x)]\n                              (if (== pair (int pair))\n                                (conj acc x pair)\n                                acc)))\n                          []\n                          (range 1 (Math/sqrt (inc n)))))\n           x-div (set (->divisors x))\n           range-div (for [i (range 1 x)]\n                       (set (->divisors i)))]\n       (->> range-div\n            (map clojure.set/intersection (repeat x-div))\n            (filter #(= 1 (apply max %)))\n            count))))","user":"554bd33ce4b0a04f7929959a"},{"code":"#(reduce (fn [c i] (letfn [(gcd [m n] (if (zero? (mod m n)) n (recur n (mod m n))))]\n                     (if (= 1 (gcd % i))\n                       (inc c) c))) (if (= 1 %) 1 0) (range 1 %))","problem":75,"user":"4ef9c8f9535dced4c769f26b"},{"problem":75,"code":"(fn totient [x]\n  (let [gcd #(loop [a %1 b %2] (if (= 0 b) a (recur b (rem a b))))]\n    (count (filter #(= 1 (gcd x %)) (range x)))))","user":"604d3cb1e4b0b7ec0ac60ac2"},{"code":"(fn totient [n]\n  (if (= 1 n)\n    1\n    (letfn [(gcd [n m]\n              (if (= n m)\n                n\n                (if (> n m)\n                  (recur (- n m) m)\n                  (recur (- m n) n))))]\n      (->> (range 1 n)\n           (filter #(= 1 (gcd n %)))\n           (count)))))","problem":75,"user":"4e5bff2b535d8a8b8723a2bd"},{"problem":75,"code":"(fn [n]\n  (->> (range n) \n       (map #(loop [a n b (inc %)] \n                 (cond (< a b) (recur b a) \n                       (> a b) (recur b (- a b)) \n                       :else a)))\n       (filter #{1})\n       count)\n)","user":"5603c31fe4b04bb52996e1c1"},{"problem":75,"code":"(letfn [(gcd [n1 n2]\n          (loop [n1 n1, n2 n2]\n            (if (zero? n2) n1 (recur n2 (rem n1 n2)))))]\n  (fn [x]\n    (if (= 1 x)\n      x\n      (loop [co-primes-count 0, [y :as ys] (range x)]\n        (if (empty? ys)\n          co-primes-count\n          (recur (if (= 1 (gcd x y)) (inc co-primes-count) co-primes-count)\n                 (rest ys)))))))","user":"5b96800ae4b0c0b3ffbd4a7b"},{"code":"(fn func [n]\r\n  (let [gcd (fn f [a b] (if (= b 0) a (f b (mod a b))))]\r\n    (if (= n 1)\r\n      1\r\n      (count (filter #(= (gcd % n) 1) (take (dec n) (iterate inc 1)))))))","problem":75,"user":"505dd5c4e4b0e6aca564be0e"},{"problem":75,"code":"(fn [x]\n  (let [gcd (fn [a b] (if (= b 0) a (recur b (mod a b))))\n        coprime? (fn [x y] (= 1 (gcd x y)))]\n    (cond\n      (= x 1) 1\n      :else (->> (range 1 x)\n                 (filter (partial coprime? x))\n                 (count)))))","user":"55d28b38e4b0e31453f64a58"},{"code":"(fn [n]\n  (if (= n 1) 1\n  (letfn [(f [e1 e2]\n             (let [e3 (rem e1 e2)]\n               (if (> e3 0)\n                 (recur e2 e3)\n                 e2)))]\n  (->> n\n       (range 1)\n       (filter #(= (f n %) 1))\n       count))))","problem":75,"user":"52b02329e4b0c58976d9acc5"},{"problem":75,"code":"#(reduce\n      (fn [a b]\n        (if (= ((fn gcd [x y] (if (zero? y) x (recur y (rem x y)))) % b) 1)\n          (inc a)\n          a)\n        )\n      0\n      (range 1 (inc %))\n      )","user":"59e0f38ae4b08badc2a0c500"},{"code":"#(\r\n  letfn [\r\n            (gcd [x y]\r\n\t\t(loop [a (min x y), b (max x y)]\r\n\t\t\t(if (zero? a) \r\n\t\t\t\tb\r\n\t\t\t\t(recur (min a (- b a)) (max a (- b a)))\r\n\t\t\t)))\r\n    ]\r\n  \r\n  \r\n  (count (filter pos? (map (partial (fn [x y] (if (= 1 (gcd x y)) y 0)) %) (range 1 (inc %))))))","problem":75,"user":"4dadca03c9a9d6ed4199dc57"},{"code":"(fn [x]\n  (if (= x 1)\n    1\n  (letfn [(gcd [m n]\n               (if (zero? n)\n                 m\n                 (gcd n (rem m n))))]\n    (count (filter #(= (gcd x %) 1) (range 1 x))))))","problem":75,"user":"512eb723e4b0b740abc5982b"},{"problem":75,"code":"(fn f [n]\n  (letfn [(gcd [a b]\n  (cond\n    (> a b) (gcd (- a b) b)\n    (> b a) (gcd a (- b a))\n    :else a))]\n  (if (= 1 n) 1\n      (count\n       (filter\n        #(= 1 (gcd % n))\n        (range 1 n))))))","user":"56504dc2e4b0284900eef6bc"},{"code":"(fn div [x]\n  (letfn [\n    (divisor? [x Q y]\n      (and\n        (= 0 (rem x y))\n        (not (contains? Q y))))\n\n    (next-divisor [x Q l]\n      (some #(if (divisor? x Q %) %)\n        (range l x)))\n\n    (divisors [x]\n      (loop [Q (sorted-set 1), l 2]\n        (let [y (next-divisor x Q l)]\n          (if y\n            (recur (into Q (range y x y)) (inc y))\n            Q))))]\n\n    (if (= x 1) \n      1\n      (- x (count (divisors x))))))","problem":75,"user":"4faa9593e4b081705acca1f9"},{"code":"(fn [x]\n   (letfn [(gcd [a b] (if (< a b) (recur b a)\n                          (if (zero? b)\n                            a\n                            (gcd (mod a b) b))))]\n     (if (= x 1)\n       1\n       (count (filter #(= 1 (gcd % x)) (range x))))))","problem":75,"user":"4ea1b9e4535d7eef308072b8"},{"code":"(fn [n]\n   (let [gcd (fn gcd [m n] (if (zero? n) m (recur n (mod m n))))]\n     (count (filter #(= 1 (gcd n %)) (range n)))))","problem":75,"user":"4e8510e7535db62dc21a62e7"},{"code":"(fn tot [n]\n  (letfn [(gcd [a, b]\n               (loop [a a b b]\n                 (if (= b 0)\n                   a\n                   (recur b (rem a b)))))\n          (coprime [a, b]\n                   (= 1 (gcd a b)))]\n    (if (= n 1)\n      1\n      (count (filter (partial coprime n) (range 1 n))))))","problem":75,"user":"51365524e4b04ac1f358dd52"},{"code":"(fn [n]\n  (letfn [(gcd [a b]\n            (if (zero? b)\n              a\n              (recur b (mod a b))))\n          (coprime? [a b]\n            (= (gcd a b) 1))]\n    (if (= n 1)\n      1\n      (count (filter true? (map (partial coprime? n) (range 1 n)))))))","problem":75,"user":"51a97f7ae4b08d8ec191b827"},{"code":"(fn [x]\n  (count\n   (filter #(= 1\n               (loop [a x b %]\n                 (if (zero? b) a\n                   (recur b (mod a b)))))\n           (range 1 (inc x)))))","problem":75,"user":"4fa340b4e4b081705acca18c"},{"code":"(fn [n]\n  (let[gcd (fn [a b] (if (= 0 b) a (recur b (rem a b))))]\n    (count (filter #(= 1 (gcd n %)) (range 1 (inc n))))))","problem":75,"user":"522b922ee4b0d34ee08e71c3"},{"code":"(fn [n]\r\n    (if (= 1 n) 1\r\n      (let [gcd (fn [a b] (if (zero? b) a (recur b (mod a b))))] \r\n        (count (for [x (range 1 n)\r\n                     :when (= 1 (gcd n x))] x)))))","problem":75,"user":"4dd61f98535d2dad7130b5c6"},{"problem":75,"code":"(fn sol [x]\n  (let [brange      (fn [n] (next (range (inc n))))\n        isdivisible (fn [n divisor] (= (mod n divisor) 0))\n        divisors    (fn [i k]\n                      (filter\n                        (fn [d] (and (isdivisible i d) (isdivisible k d)))\n                        (brange (min i k))))\n        gcd         (fn [i k] (apply max (divisors i k)))\n        gcdpairs    (fn [n] (into (sorted-map) (zipmap (brange n) (repeat n))))\n        gcds        (fn [n] (map (fn [[i k]] (gcd i k)) (gcdpairs n)))\n        totient     (fn [n] (count (filter (fn [n] (= n 1)) (gcds n))))\n        ]\n    (totient x)\n    ))","user":"578b140be4b0ebec4cfb7545"},{"problem":75,"code":"(fn [n]\n   (let [gcd (fn [& a]\n               (loop [p (sort a)]\n                 (let [m (mod (first p) (second p))]\n                   (if (= 0 m) (second p) (recur (list (second p) m)))\n                   )))]\n     (count (filter #(= 1 (gcd % n)) (range n)))\n     )\n   )","user":"5471f2fbe4b094393f72dd70"},{"code":"(fn e [n]\n  (letfn [(gcd [a b] (if (= b 0) a (gcd b (mod a b))))]\n    (count (filter #(= 1 (gcd n %)) (range n)))))","problem":75,"user":"4ea1ecfa535d7eef308072bb"},{"problem":75,"code":"(fn [x]\n  (let [gcd #(loop [a %1 b %2]\n               (if (zero? b)\n                 a\n                 (recur b (rem a b))))]\n    (if (= 1 x)\n      1\n      (->> (range 1 x)\n           (filter #(= 1\n                       (gcd x %)))\n           count))))","user":"52470d42e4b05ef8e38e6350"},{"problem":75,"code":"(fn [n] (letfn [(gcd [a b] (if (= a 0) b (gcd (mod b a) a)))]\n          (count (take-while #(< % n) (filter #(and (= 1 (gcd % n)) n) (range))))))","user":"56897739e4b0dcc4269f407d"},{"code":"(fn [n]\n  (->> (range 2 n)\n    (filter (fn [x]\n              (= 1 ((fn gcd [a b]\n                      (if (= 0 b) a (gcd b (mod a b))))\n                    x n))))\n    count\n    inc))","problem":75,"user":"4dad7adac9a9d6ed0599dc57"},{"problem":75,"code":"(letfn [(coprime [a b] (= '(1)\n                          (filter #(and (zero? (rem a %))\n                                        (zero? (rem b %)))\n                                  (range 1 (max a b)))))]\n  (fn [n]\n    (cond\n     (= 1 n)\n     1\n     :else\n     (count (filter (partial coprime n)\n                    (range 1 n))))))","user":"51dafedee4b09f6bc204eee2"},{"problem":75,"code":"(fn euler [val]\n  (\n    inc (count (filter (fn [x] \n                        (= 1 ((fn gcd [a b] \n                                (if (zero? b) a (gcd b (mod a b)))) x val) )\n                      ) \n                      (range 2 val)))\n  )\n)","user":"546692aee4b01be26fd746e7"},{"problem":75,"code":"(fn euler-fn \n  [n]\n  (let [gcd (fn gcd\n              [x y]\n              (if (zero? (mod y x))\n                x (gcd (mod y x) x)))]\n    (reduce #(if (= 1 (gcd n %2))\n              (inc %1) %1) 1 (range 2 n))))","user":"56a36f76e4b0542e1f8d14ca"},{"code":"(fn [n]\n   (inc (count\n         (for [m (range 2 n)\n               :when (not-any? #(zero? (+ (mod m %) (mod n %)))\n                               (range 2 (inc m)))]\n           m))))","problem":75,"user":"5175533fe4b0dea9bbfba575"},{"code":"(fn [x]\n  (count \n    (filter \n      #(= 1 %)\n      (for [y (range x)]\n        (loop [x x, y y] \n          (if \n            (= y 0) \n            x \n            (recur y (mod x y))))))))","problem":75,"user":"4eabb245535d7eef30807319"},{"problem":75,"code":"(fn totient [n]\n  (let [comdiv (fn [x y]\n                 (let [m (inc (min x y))\n                       r (reverse (range 1 m))]\n                   (some #(when (= 0 (mod x %) (mod y %)) %) r)))\n        nums (range 1 n)]\n    (if (= 1 n)\n      1\n      (count (filter #(= 1 (comdiv % n)) nums)))))","user":"55170dd9e4b06a49daca83bd"},{"problem":75,"code":"(fn eulers-totient [n]\n  (->>\n   (range n)\n   (filter #(= ((fn [a b] (if (zero? b) a (recur b (mod a b)))) % n) 1))\n   (count)))","user":"60849bd6e4b0736b099e42f2"},{"problem":75,"code":"(fn [b]\n            (count\n              (filter #(= 1 %) ((fn coprime?\n                                  ([b]\n                                   (for [num (range 0 b)]\n                                     (coprime? num b) ))\n                                  ([num b]\n                                   (if (= b 0)\n                                     num\n                                     (recur b (mod num b)))))\n                                 b))))","user":"5cd4e1b2e4b0ccb061962927"},{"problem":75,"code":"(fn totient\n  [n]\n  (let [gcd (fn [a b]\n              (cond\n                (zero? b) a\n                (zero? a) b\n                (> a b) (recur (- a b) b)\n                :otherwise (recur a (- b a))))]\n    (if (= n 1)\n      1\n      (count (filter #(= % 1) (map #(gcd % n) (range 1 n)))))))","user":"56488119e4b0284900eef632"},{"code":"(fn [x] (if (= x 1) 1 (count (filter #(= ((fn [a b] (if (= b 0) a (recur b (mod a b)))) % x) 1) (range 1 x)))))","problem":75,"user":"51f66e0ee4b06ff1c25c52c3"},{"problem":75,"code":"(fn [n]\n  (letfn [(gcd [x y]\n               (if (= y 0)\n                 x\n                 (recur y (mod x y))))]\n    (count (filter #(= 1 (gcd n %)) (range 1 (inc n))))))","user":"53e9dce1e4b036ad0777e4bc"},{"problem":75,"code":"(fn coprime-count [x]\n  (letfn [(gcd [a b] (if (zero? a) b (gcd (mod b a) a)))\n          (coprime [a b] (= (gcd a b) 1))]\n    (count (filter #(coprime x %) (range 1 (inc x))))))","user":"5a544eeee4b05d388ecb6c24"},{"problem":75,"code":"(fn [x]\n  (let [gcd (fn gcd [x y] (if (zero? (rem x y)) y (gcd y (rem x y))))\n        totients (filter #(= 1 (gcd x %)) (range 1 x))]\n    (if (= x 1) 1  (count  totients))))","user":"512b07f7e4b078b06821febb"},{"problem":75,"code":"(fn [n]\n  (if (= 1 n) 1\n    (let [gcd (fn [a b]\n                (if (zero? b) a\n                  (recur b (mod a b))))]\n      (count (filter #(= 1 (gcd n %)) (range 1 n))))))","user":"56ae214ce4b03c432f18735a"},{"problem":75,"code":"(fn [x]\n          (loop [v 2 r [1]]\n            (letfn [(gcd [a b] (if (= b 0) a (recur b (mod a b))))]\n              (if (>= v x)\n                (count r)\n                (recur (inc v)\n                       (if (= (gcd v x) 1)\n                         (conj r v)\n                         r))))))","user":"531c6e72e4b08068f379eda0"},{"code":"(fn totient [x]\n  (count (if (= x 1) '(1)\n    (let [gcd (fn [y z] (.gcd (BigInteger. (str y)) (BigInteger. (str z))))]\n      (for [t (range 1 x)\n            :when (= 1 (gcd x t))]\n        t)))))","problem":75,"user":"52d6889ae4b09f7907dd1361"},{"code":"(fn totient [x]\n  (let [divisible? #(zero? (rem %1 %2))\n        gcd (fn [a b] (last (filter #(and (divisible? a %) (divisible? b %)) (range 1 (inc b)))))]\n    (if (= 1 x) 1 (count (filter #(= 1 (gcd x %)) (range 1 x))))))","problem":75,"user":"5003deb9e4b0678c553fc445"},{"code":"(fn [n]\r\n  (let [gcd (fn [a b]\r\n              (if (= b 0)\r\n              a\r\n              (recur b (mod a b))))]\r\n    (count (filter #(= 1 (gcd n %)) (range n)))))","problem":75,"user":"4fb37882e4b081705acca2a0"},{"code":"(fn [n]\n  (if (= 1 n) 1\n    (count\n     (filter\n      #(=\n        1\n        ((fn gcd [a b]\n           (if (= b 0)\n             a\n             (gcd b (rem a b))))\n         % n))\n      (range 1 n)))))","problem":75,"user":"519136e9e4b0f8ef0be96c01"},{"problem":75,"code":"(fn [n]\n  (letfn\n    [(gcd \n      [n m]\n      (cond (= n m) n\n            (> n m) (gcd (- n m) m)\n            :else (gcd n (- m n))))\n     (coprimes-up-to \n      [n]\n      (filter #(= (gcd n %) 1) (range 1 n)))]\n    (if (= n 1)\n      1\n      (count (coprimes-up-to n)))))","user":"52f3568fe4b05e3f0be25f0e"},{"problem":75,"code":"#(letfn [(g [a b] \n            (if (< a b) \n              (g b a) \n              (let [m (mod a b)] (if (= 0 m) \n                                   b \n                                   (g b m))))) \n         (c [a b] \n            (= 1 (g a b)))] \n    (if (= % 1) \n      1 \n      (count \n       \t(filter true? \n           (for [i (range 1 %)] (c % i))))))","user":"53b2a7f8e4b047364c04449c"},{"code":"(fn [x] (letfn\n          [(coprime? [a b] (= (gcd a b) 1))\n           (gcd [c d] (if (= c d) c (apply gcd (if (> c d) [(- c d) d] [c (- d c)]))))]\n          (if (= x 1)\n            1\n            (count (filter (partial coprime? x) (map inc (range (dec x))))))))","problem":75,"user":"51307b84e4b08c712d3fae39"},{"code":"(fn [x]\n  (if (= 1 x)\n    1\n    (count (filter #(= 1 (.gcd (biginteger x) (biginteger %))) (range 1 x)))))","problem":75,"user":"524b0645e4b09eba1c0223bf"},{"code":"(fn [n]\n    (if (= n 1)\n      1\n      (letfn [(f [a b]\n                (empty? (filter #(and (= 0 (mod a %))\n                                      (= 0 (mod b %)))\n                                (range 2 (max a b)))))]\n        (count (filter #(f n %) (range 1 n))))))","problem":75,"user":"4ee82223535d93acb0a66877"},{"problem":75,"code":"(fn [main-num] (cond (= 1 main-num) 1 :else (count (filter (fn [child-num] (= 1 ((fn gcd [num1 num2] \n                                                                               (cond\n                                                                                (= 0 num1) num2\n                                                                                (= 0 num2) num1 \n                                                                                (= num1 num2) num1\n                                                                                (> num1 num2) (recur (- num1 num2) num2)\n                                                                                (< num1 num2) (recur num1 (- num2 num1)))) child-num main-num))) (range 1 main-num)))))","user":"57c6aa0be4b05aa3c4741cf7"},{"problem":75,"code":"(fn [n]\n  (letfn [(gcd [a b] (cond (= a b) a (> a b) (gcd (- a b) b) (> b a) (gcd a (- b a))))]\n    (count (filter #(= 1 (gcd n %)) (range 1 (+ n 1))))\n  )\n)","user":"54e5bdf2e4b024c67c0cf7fe"},{"code":"(fn totient [n]\n  (let [gcd (fn gcd [a_ b_]\n    (last (let [a (max a_ b_)\n          b (min a_ b_)]\n      (for [i (drop 1 (range))\n            :while (and (<= i a) (<= i b))\n            :when (and (= 0 (rem a i)) (= 0 (rem b i)))\n            ]\n        i)\n    )))]\n    (if \n      (= 1 n) 1\n      (count \n        (filter #(= 1 %)\n          (map #(gcd % n) (range 1 n)))))\n  )\n  )","problem":75,"user":"52ffb7f2e4b0d8b024fd370b"},{"problem":75,"code":"(fn [x]\n  (letfn [(gcd [a b] (if (= b 0) a (recur b (mod a b))))]\n  (if (= 1 x)\n    1\n    (count (filter #(= 1 (gcd % x)) (range 1 x))))))","user":"5b0bd9cfe4b0cc2b61a3bdd9"},{"problem":75,"code":"(fn totient [n]\n  (let [gcd (fn [x y]\n              (let [[bigger smaller] (reverse (sort [x y]))\n                    remainder (mod bigger smaller)]\n                (if (zero? remainder)\n                  smaller\n                  (recur smaller remainder))))]\n    (if (< n 2)\n      1\n      (inc (count (filter #(= 1 %) (map #(gcd n %) (range 2 n))))))))","user":"53f891eee4b0de5c4184856d"},{"problem":75,"code":"(fn totient [n]\n  (let [gcd (fn gcd [a b]\n              (if (zero? b)\n                a\n                (gcd b (mod a b))))\n        coprime (fn [a b]\n                  (= 1 (gcd a b)))]\n    (if (= n 1)\n      1\n      (count (filter #(coprime n %) (drop 1 (range n)))))))","user":"5b7f2d75e4b047b03b203768"},{"code":"(fn totient [n]\n  (letfn\n    [(gcd [x y]\n       (if (zero? y)\n         x\n         (recur y (mod x y))))]\n    (if (= 1 n)\n      1\n      (count\n        (for [x (range 1 n) :when (= 1 (gcd x n))] x)))))","problem":75,"user":"531c0619e4b08068f379ed98"},{"problem":75,"code":"(fn coprimes [num] \n    (let [gcd (fn [num1 num2] (loop [num num1 divisor num2]\n            (let [q (quot num divisor) r (rem num divisor)]\n            (if (zero? r) divisor\n                (recur divisor r)))))]\n        (loop [i 1 count 0]\n            (if (> i num) count\n                (if (= (gcd i num) 1) \n                    (recur (inc i) (inc count))\n                    (recur (inc i) count))))))","user":"5da05bcce4b000c986472bd0"},{"problem":75,"code":"(fn [x]\n  (count  (cons 1 (filter #(= \n                             ((fn my-gcd [& args]\n                                (let [[b a] (sort args)]\n                                  (if (= a b) a (my-gcd (- a b) b)))) x %)\n                             1) \n                          (range 2 x)))))","user":"52eaba10e4b09f7907dd14c2"},{"problem":75,"code":"(fn [max]\n  (cond (= max 1) 1\n        0 (count (clojure.set/difference (set (range 1 max)) (set (for [a (range 2 max) b (range 2 (inc a))\n :when (every? zero? [(rem max b) (rem a b)])] a))))))","user":"548b7db8e4b0e286459a11fd"},{"code":"(fn totient\n  [n]\n  (let [xs (range 2 n)\n        gcd (fn [a b] (loop [a a b  b]\n                        (if (zero? b) a\n                            (recur b (mod a b)))))]\n    (reduce #(if (= 1 (gcd n %2))\n               (inc %)\n               %)\n            1 xs)))","problem":75,"user":"524f4256e4b0541d1855b808"},{"problem":75,"code":"(fn [x]\n  (letfn [(gcd [a b] (if (= 0 b) a\n    (gcd b (mod a b))))]\n  (if (= 1 x) 1\n  (count (filter #(= 1 (gcd % x)) (range 1 x))))))","user":"5b4ff637e4b02d533a91bce0"},{"code":"(fn [y] (count ((fn coprimes [x] (if (= x 1) '(1) (filter #(= ((fn gcd [a b] (if (zero? b) a (gcd b (mod a b)))) % x) 1) (range 1 x)))) y)))","problem":75,"user":"536d5515e4b0fc7073fd6e59"},{"code":"(fn [n]\n  (case n \n    1 1\n    (count\n      (reduce\n        #(if (zero? (rem n %2))\n           (reduce disj %1 (range %2 n %2))\n           %1)\n        (set (range 1 n))\n        (range 2 n)))))","problem":75,"user":"4e8f1ac6535d65386fec2146"},{"code":"(fn [n] (if (= n 1) 1 (let [d (reverse (filter #(= 0 (mod n %)) (range 2 n))) gcd (fn [a] (some #(= 0 (mod a %)) d))] (count (filter #(nil? (gcd %)) (range 1 n))) )))","problem":75,"user":"5150a7d7e4b03e678e393abb"},{"problem":75,"code":"(fn [n]\n  (letfn [(gcd [a b] (if (= b 0) a (gcd b (mod a b))))]\n    (inc (count (filter #{1} (map #(gcd n %) (range 2 n)))))))","user":"52ce1abfe4b07d0d72b27389"},{"problem":75,"code":"(fn totient [x]\n  (if (= x 1) 1\n    (loop [output 0 test 1]\n      (if (= test x) output\n      (if ((fn coprime [a b]\n             (loop [c 2]\n               (if (> c (max a b)) true\n                 (if (and (= 0 (mod a c)) (= 0 (mod b c))) false\n                   (recur (inc c)))))) x test) (recur (inc output) (inc test))\n        (recur output (inc test)))))))","user":"558378dce4b05c286339e115"},{"code":"(fn [n]\n    (letfn [(gcd [a b]\n                 (if (zero? b)\n                   a\n                   (recur b (mod a b))))\n            (coprime? [x y]\n                      (= 1 (gcd x y)))]\n      (if (= 1 n)\n        1\n        (count (for [x (range 1 n)\n                     :when (coprime? n x)]\n                 x)))))","problem":75,"user":"50e4b066e4b0cb9ec68fbca6"},{"problem":75,"code":"(fn [x] \n  (or (if (= 1 x) 1)\n      (let [gcd (fn [a b]\n                  (if (zero? b)\n                    a \n                    (recur b (mod a b))))]\n        (count (filter #(= 1 (gcd x %)) (range 1 x))))))","user":"5264383be4b03e8d9a4a70cb"},{"problem":75,"code":"(fn [n]\n  (let [gcd (fn gcd [a b]\n              (if (= 0 b)\n                a\n                (gcd b (mod a b))))]\n    (loop [n n\n           i 2\n           t 1]\n      (if (>= i n)\n        t\n        (if (= (gcd n i) 1)\n          (recur n (inc i) (inc t))\n          (recur n (inc i) t))))))","user":"5550bcece4b00713264bd9ae"},{"code":"(fn totient[x]\n  (letfn [(gcd[a b]\n            (if (zero? b) a\n                (recur b (mod a b))))\n          (co-prime? [a b] (= 1 (gcd a b)))]\n    (count (filter (partial co-prime? x) (range x)))))","problem":75,"user":"50fa01bce4b07934dda8b0ba"},{"problem":75,"code":"(fn [test-number]\n   (letfn [(gcd [big small] (if (zero? small) big (recur small (mod big small))))\n           (coprime? [x y] (= (gcd x y) 1))]\n     (count (filter #(coprime? test-number %) (range 1 (inc test-number))))\n     )\n   )","user":"55fe7e15e4b00f4cabc57651"},{"problem":75,"code":"(fn [x]\n    (let [ gcd (fn [a b] (if (zero? b) a (recur b (mod a b))))\n          \n          ]\n      (if (= 1 x) 1\n      (count (reduce (fn [a v] \n                (if (= 1 (gcd v x))\n                  (conj a v)\n                  a\n                  )\n                ) [] (range 1 x))))))","user":"53c73e8ae4b00fb29b2212a5"},{"problem":75,"code":"(fn [x]\n  (let [gcd (fn gcd [x y] (if (zero? y) x (gcd y (mod x y))))\n        coprime? (fn [y] (= 1 (gcd x y)))]\n    (count (filter coprime? (range x)))))","user":"5405ae2be4b0addc1aec6671"},{"code":"(fn [x] \n\t(if (= x 1) 1\n\t\t(let [\tgcd (fn [x y] (loop [\to-q x o-r y]\n\t\t\t\t(let [\tq (/ o-q o-r)\n\t\t\t\t\t\tr (mod o-q o-r)]\n\t\t\t\t\t\t(if (= 0 r) o-r (recur o-r r)))))\n\t\t\t\tcoprime? (fn [x y] (= 1 (gcd x y)))]\n\t\t\t(count (filter (partial coprime? x) (range 1 x))))))","problem":75,"user":"4f47eab2e4b0d56e7bb92bc6"},{"problem":75,"code":"(fn euler-totient\n  [x]\n  (letfn [(gcd\n            [a b]\n            (cond\n              (= a b)\n              a\n\n              (> a b)\n              (gcd (- a b) b)\n\n              :else\n              (gcd a (- b a))))\n\n          (is-coprime?\n            [a b]\n            (= (gcd a b) 1))]\n\n    (if (= x 1)\n      1\n      (reduce (fn [current next] (inc current)) 0 (filter #(is-coprime? x %) (range 1 (inc x)))))))","user":"5b759ca8e4b047b03b2036d0"},{"problem":75,"code":"(letfn [(small-p [x]\n          (->> (range 2 (inc x))\n               (filter #(zero? (mod x %)))\n               first))\n        (get-pk [x p]\n          (loop [x x result 1]\n            (if (zero? (mod x p))\n              (recur (/ x p) (* result p))\n              result)))\n        (euler [x]\n          (loop [x x result 1] \n            (if (= 1 x)\n              result\n              (let [p (small-p x)\n                    pk (get-pk x p)]\n                (recur (/ x pk)\n                       (* result (- pk (/ pk p))))))))]\n  euler)","user":"55db7e15e4b0e31453f64ae8"},{"code":"(fn [x] (if (= x 1) 1 (->> (range x) (drop 1)\n                (map #(loop [a x b %] (if (zero? b) a (recur b (mod a b)))))\n                (filter #{1}) count)))","problem":75,"user":"528e64b7e4b0239c8a67aedd"},{"problem":75,"code":"(fn [n] \n  (letfn [(not-coprimes [acc k]\n             (if (> k n) acc\n               (not-coprimes \n               \t (if (or (= 0 (mod n k)) (some #(= 0 (mod k %)) acc))\n                   (conj acc k)\n                   acc)\n                 (inc k))))]\n    (- n (count (not-coprimes [] 2)))))","user":"55253217e4b0882d96d091ce"},{"code":"(fn [x]\n  (let [gcd (fn [x y]\n              (let [[lower higher] (if (> x y) [y x] [x y])]\n                (first (filter #(zero? (mod higher %))\n                               (filter #(zero? (mod lower %))\n                                       (iterate dec lower))))))]\n    (if (= x 1)\n      1\n      (count (filter #(= % 1)\n                     (map #(gcd % x)\n                          (range 1 x)))))))","problem":75,"user":"5225271fe4b01819a2de42f9"},{"code":"(fn totient [n]\n  (let [gcd (fn gcd [a b] (if (= b 0) a (gcd b (mod a b))))\n        coprime? (fn [a b] (= (gcd a b) 1))]\n    (count (filter (partial coprime? n) (range n)))))","problem":75,"user":"4faac363e4b081705acca200"},{"problem":75,"code":"(fn[x](count (filter (fn[y] (= 1 ((fn gcd [a b] (if (zero? b)  a  (gcd b (mod a b)))) x y))) (range 1 (inc x)))))","user":"5596af34e4b04c1e5c31d758"},{"problem":75,"code":"(fn [n]\n  (if (zero? (dec n))\n    1\n    (->> n\n         (range 1)\n         (filter (fn coprime?\n                   ([-num]\n                    (coprime? n -num))\n                   ([a b]\n                    (if (zero? b)\n                      (= a 1)\n                      (recur b (mod a b))))))\n         (count))))","user":"5ddb6151e4b0948ae9d9adb0"},{"code":"(fn [n]\n     (if (= 1 n) 1\n         (let [gcd (fn [a b] (if (= a b) a (if (> a b) (recur (- a b) b) (recur a (- b a)))))]\n              (count (filter #(= 1 (gcd % n)) (range 1 n))))))","problem":75,"user":"4e8b98fc535d65386fec2124"},{"problem":75,"code":"(fn [n] (if (= n 1) 1\n      (count (remove (fn [cand] (some #(if (= 0 (mod n %) (mod cand %)) %) (range 2 (inc cand)))) (range 1 n)))))","user":"5b008bcae4b0cc2b61a3bd3d"},{"code":"(fn [f n] (if (= n 1) 1\n            (count (filter  #(empty? (clojure.set/intersection (f %) (f n))) (range 1 n)))))\n(fn [n] (set (filter #(zero? (mod n %)) (range 2 (inc n)))))","problem":75,"user":"512f06c5e4b0762be4c7aad7"},{"problem":75,"code":"(fn [n] \n  (letfn \n    [(iscoPrime\n      [a b](if (zero? b) (= 1 a) (iscoPrime b (mod a b))))\n     ]\n    (count (filter (partial iscoPrime n) (range 0 n )))\n    ))","user":"54edcf96e4b024c67c0cf866"},{"problem":75,"code":"(fn totient [n]\n(if (= n 1)\n1\n(->>\n\t; all integers less than n\n\t(range 1 n)\n\n\t; filter\n\t(filter\n\t\t(fn [x] \n\t\t\t(= 1 (\n\t\t\t\t(fn gcd [a b]\n\t\t\t\t(->>\n\t\t\t\t\t(range 1 (inc (max a b)))\n\t\t\t\t\t(filter #(= 0 (rem a %)))\n\t\t\t\t\t(filter #(= 0 (rem b %)))\n\t\t\t\t\t(apply max)\n\t\t\t\t)\n\t\t\t\t)\n\t\t\tx n))\n\t\t)\n\t)\n\n\t(count)\n)\n)\n)","user":"5f574662e4b0a0bc16850a90"},{"code":"(fn euler-totient [n]\n  (let [gcd (fn gcd [n m]\n              (if (< n m)\n                (gcd m n)\n                (if (= m 0)\n                  n\n                  (gcd m (rem n m)))))]\n       (count (filter #(= 1 (gcd % n)) (range 1 (inc n))))))","problem":75,"user":"4f7e29dde4b06e829148e1ca"},{"problem":75,"code":"(fn [n]\n  (letfn\n    [(factors \n      [m] \n      (set \n        (filter \n          #(= 0 (mod m %)) \n          (range 1 (inc m)))))]\n    (let [factors-n (factors n)]\n      (count\n        (filter\n          #(= \n            #{1} \n            (clojure.set/intersection\n              factors-n (factors %)))\n          (range 1 (max 2 n)))))))","user":"564c8e99e4b0284900eef674"},{"code":"(fn [i]\n  (if (= 1 i) 1 \n  (count (filter #(= 1 (loop [a i b %] (if (= b 0) a (recur b (rem a b)))))\n                 (range 1 i)))))","problem":75,"user":"4f0e4ebd535d0136e6c22322"},{"problem":75,"code":"(fn[x]\n          (letfn [\n                  (gcd[n1 n2]\n                    (loop [i 1 gcd 1]\n                      (if\n                          (or (> i n1) (> i n2))\n                        gcd\n                        (recur (inc i) (if (and (= (mod n1 i) 0) (= (mod n2 i) 0))\n                                         i\n                                         gcd)))))\n                  (coprime? [x1 x2] (= (gcd x1 x2) 1))\n                  ]\n            (if (= x 1)\n              1\n              (count (filter (fn[n] (coprime? n x)) (range 1 x)))))\n          )","user":"5e078ba7e4b0978307768fb6"},{"code":"(fn f [x]\n  (if (= x 1)\n    1\n    (->>\n      (range 1 x)\n      (remove\n        (reduce (fn [f i]\n                  (if (and (not (f i))\n                           (zero? (mod x i))) \n                    #(or (f %)\n                         (zero? (mod % i))) \n                    f))  \n                (constantly false)\n                (range 2 x)))\n      count)))","problem":75,"user":"50b668dde4b08fb537db98f2"},{"problem":75,"code":"(fn totient\n  ([n] (totient 0 1 n))\n  ([result i n]\n    (if (> i n)\n      result\n      (recur\n       (if\n        (= 1\n           ((fn gcd [a b]\n              (if\n               (zero? b)\n               a\n               (gcd\n                b (mod a b))))\n                n i))\n        (inc result)\n        result)\n       (inc i) n))))","user":"598ab445e4b02b9968b84ce0"},{"problem":75,"code":"(fn prob75\n  [x]\n  (cond\n   (= x 1) 1\n   :else (letfn [(gcd [a b] \n                   (if (zero? b)\n                     a\n                     (gcd b (mod a b))))\n                 (coprime [a b]\n                   (= 1 (gcd a b)))\n                 ]\n           (count (filter #(coprime % x) (range x))))))","user":"4ebbff41535dfed6da9c6d78"},{"code":"(fn [x]\n  (if (= 1 x)\n    1\n    (letfn [(gcd [a b]\n              (cond\n                (zero? a) b\n                (zero? b) a\n                :else (recur b (mod a b))))]\n      (reduce #(+ %1 (if (not= 1 (gcd %2 x)) 0 1)) 0 (range 1 x)))))","problem":75,"user":"4f29eb2ae4b0d6649770a037"},{"code":"(letfn [(coprime? [a b] (= (numerator (/ a b)) a))]\n         (fn [x] (inc (count (filter #(coprime? % x) (range 2 x))))))","problem":75,"user":"5294e44de4b02ebb4ef75016"},{"problem":75,"code":"(fn [x]\n  (let [f (fn [x y] (loop [x x\n                           y y]\n                      (if (zero? y)\n                        x\n                        (recur y (mod x y)))))\n        lst (for [y (range 1 (inc x))\n                  :when (= 1 (f x y))]\n              y)]\n    (count lst)))","user":"6011b89ee4b074f607df66bc"},{"code":"(fn [n] (let [gcd (fn [a b] (if (zero? b) a (recur b (rem a b))))]\n          (if (= 1 n) 1 (count (filter #(= 1 (gcd n %)) (range 1 n))))))","problem":75,"user":"5246e945e4b0644eb7b0783b"},{"problem":75,"code":"(fn [n]\n  (letfn [(prime? [x]\n            (and (> x 1) (every? #(pos? (rem x %)) (range 2 (Math/sqrt (inc x))))))]\n    (let [to-multiply (filter #(and (zero? (rem n %)) (prime? %)) (range 1 (/ (inc n) 2)))]\n      (* n (apply * (map #(- 1 (/ 1 %)) to-multiply))))))","user":"53322cece4b019098a6f8b73"},{"code":"(fn [n]\n  (count\n   (letfn [(coprime? [x y]\n             (loop [i 2]\n               (cond\n                (> i y) true\n                (= 0 (+ (mod x i) (mod y i))) false\n                :else (recur (inc i)))))]\n     (filter #(coprime? n %) (range 1 (inc n))))))","problem":75,"user":"512d3304e4b040332b905b2d"},{"code":"(fn [n] (letfn [(gcd [a b] (loop [a a b b] (if (zero? a) b (recur (mod b a) a))))]\n  (reduce (fn [curr v] (if (= (gcd v n) 1) (inc curr) curr)) 0 (range 1 (max n 2)))))","problem":75,"user":"52c200cbe4b07a9af5792372"},{"problem":75,"code":"(fn [n]\n  (let [gcd (fn [a b] (if (zero? b) a (recur b (mod a b))))]\n    (count (filter #(= (gcd % n) 1) (range n)))))","user":"55236ad6e4b0882d96d091b1"},{"code":"#(count\n   (for [f [(fn f [a b] (cond (= a b) a\n                             (> a b) (f (- a b) a)\n                             (< a b) (f a (- b a))))]\n         i (or (not-empty (range 1 %)) [1])\n         :when (= 1 (f % i))]\n     i))","problem":75,"user":"507056b8e4b07bd6ad9b9f29"},{"problem":75,"code":"(fn [x]\n  (let [gcd (fn [a b]\n              (if (= 0 b)\n                a\n                (recur b (mod a b))))]\n    (loop [i 1\n           r []]\n      (if (> i x)\n        (count r)\n        (if (= 1 (gcd x i))\n          (recur (inc i) (conj r i))\n          (recur (inc i) r))\n        ))))","user":"5823d3e6e4b051871117beb8"},{"problem":75,"code":"(fn [n]\n  (if (= n 1) 1\n      (letfn [(my-gcd [x y]\n                (if (zero? y)\n                  x\n                  (my-gcd y (rem x y))))]\n        (count (filter #(= % 1) (map #(my-gcd % n) (range 1 n))))\n        )))","user":"5ee75f8be4b029a2061bbea5"},{"problem":75,"code":"(fn [x]\n   (letfn [(is-factor? [number factor]\n                       (= 0 (rem number factor)))\n           (factors [number]\n                    (->> number\n                         Math/sqrt\n                         Math/ceil\n                         inc\n                         (range 1)\n                         (filter #(is-factor? number %))\n                         (mapcat #(list % (/ number %)))\n                         set))]\n   (let [facs (factors x)]\n     (count \n      (reduce \n       #(if (= (count (clojure.set/intersection (factors %2) facs)) 1) (conj %1 %2) %1) \n       [] \n       (range 1 (inc x)))))))","user":"54d9366ce4b0a52adc2e204e"},{"problem":75,"code":"(fn [n]\n  (letfn [(gcd [a b]\n            (if (zero? b)\n              a\n              (gcd b (mod a b))))]\n    (->> n\n       (range 2)\n       (map #(gcd n %))\n       (filter #(= 1 %))\n       (count)\n       (+ 1))))","user":"5afb4b15e4b0cc2b61a3bcf6"},{"problem":75,"code":"(fn [n]\n  (let [gcd (fn [x y]\n                    (loop [x x y y]\n                      (let [r (rem x y)]\n                        (if (= 0 r)\n                          y\n                          (recur y r)))))]\n          (+ 1 (count (filter #(= 1 (gcd n %)) (drop 2 (range n)))))))","user":"58949f8de4b00487982d525e"},{"problem":75,"code":"(letfn [(gcd [a b]\n          (cond (= a 0) b\n                (= b 0) a\n                :else (recur b (rem a b))))]\n  (fn totient [n]\n    (if (= 1 n)\n      1\n      (->> (range 1 n)\n           (filter #(= 1 (gcd n %)))\n           (count)))))","user":"59eb63e3e4b0249b7282077c"},{"code":"(letfn [(gcd [a b] (if (zero? b) a (recur b (mod a b))))\n        (coprime? [a b] (= 1 (gcd a b)))]\n  #(->> (range 2 %) (filter (partial coprime? %)) count inc))","problem":75,"user":"4f6160a7e4b0defedf855fbe"},{"problem":75,"code":"(fn e [n]\n  (if (= 1 n)\n    1\n    (->>\n     (range 1 n)\n     (filter #(and (ratio? (/ % n)) (= n (denominator (/ % n)))))\n     (count))))","user":"51aefceee4b09397d5109797"},{"code":"(fn totient\n    [n]\n    (let [gcd (fn [a b] \n              (cond \n               (zero? a) b \n               (zero? b) a \n               0 (recur b (mod a b))))]\n      (if (= n 1) 1\n        (count (filter #(= 1 (gcd n %)) (range 1 n))))))","problem":75,"user":"5273e006e4b03e8d9a4a7495"},{"code":"(fn [x]\n  (letfn [(gcd [a b]\n            (if (zero? b) a (recur b (mod a b))))\n          (coprime [y]\n            (= 1 (gcd x y)))]\n    (count (filter coprime (range x)))))","problem":75,"user":"50fbf811e4b0d10d794c19f1"},{"problem":75,"code":"(fn[x]\n  (if (= x 1)1\n  (->> x\n       (range 1)\n       (remove(fn[y](some #(= 0(mod x %)(mod y %))(range 2(inc y)))))\n       (count))))","user":"53ed2fafe4b0d648e757f4c1"},{"problem":75,"code":"(fn [n]\n  (if (= n 1)\n    1\n    (letfn [(gcd [a b] (if (zero? b) a (gcd b (mod a b))))]\n      (->> (range 1 n)\n           (map #(gcd n %))\n           (filter #{1})\n           count))))","user":"583e27e2e4b089d5ab817daa"},{"code":"(fn [n]\n  (let [a \n  (map      \n  (fn [s] \n    (concat (filter #(= 0 (mod s %))\n    (range 2 (inc (/ s 2))))[s]))\n      (range 2 (inc n)))]\n  (inc(count (filter (fn[t] (not((fn[s](some true? (flatten (map (fn [i](map #(= % i) (last a))) s))))t))) (butlast a))))))","problem":75,"user":"4f0446f9535dcb61093f6bb8"},{"problem":75,"code":"(fn f [n]\n  (if (= 1 n)\n    1\n    (count (filter #(= 1 ((fn ff [a nn] (if (= nn 0) a (ff nn (rem a nn)))) % n)) (range n)))))","user":"56ab7578e4b03c432f18733d"},{"problem":75,"code":"#(count (for [i (range %) \n     :let [j (+ 1 i) g\n                                 ((fn f [x y]\n                                   (let [r (mod x y) q (quot x y)]\n                                     (if (= 0 r)\n                                       y\n                                       (f y r)\n                                       )\n                                     )\n                                   )\n j %)] :when (= g 1)] j))","user":"5464a536e4b01be26fd746cf"},{"problem":75,"code":"(fn [x] (letfn [(gcd [a b]\n                   (loop [ia a ib b]\n                     (if (= ib 0)\n                       ia\n                       (recur ib (mod ia ib)))))]\n           (count (filter #(= 1 (gcd % x)) (range 1 (inc x))))))","user":"53c06438e4b0c98a41f5ccb0"},{"problem":75,"code":"(fn [x] \n  (let [gcd (fn [x y]\n              (let [smaller (min x y)\n                    larger (max x y)\n                    reminder (mod larger smaller)]\n                (if (== 0 reminder)\n                   smaller\n                   (recur smaller reminder))))]\n    (count (filter #(== 1 (gcd x %)) (range 1 (inc x))))))","user":"527c166de4b03e8d9a4a75b3"},{"problem":75,"code":"(fn totient [x]\n    (letfn [(gcd [a b]\n              (if (zero? b)\n                a\n                (recur b (mod a b))))\n            (coprimes? [a b]\n              (= (gcd a b) 1))]\n      (->> (range x)\n        (filter (partial coprimes? x))\n        count)))","user":"5470b3d0e4b00cfc9eacc1bb"},{"problem":75,"code":"(fn [x]\n  (letfn [(gcd [a b]\n            (if (zero? b)\n              a\n              (recur b (mod a b))))]\n    (if (= 1 x) 1 (count (filter #(= 1 (gcd x %)) (range 1 x))))))","user":"5576f299e4b05c286339e077"},{"problem":75,"code":";; or we could use (range 1 n) instead of (range) and take-while\n(fn [n]\n  (if (= n 1)\n    n\n    (let [gcd (fn [a b]\n                (if (zero? b)\n                  a\n                  (recur b (mod a b))))\n          primes (filter #(= 1 (gcd n %)) (range))]\n      (count (take-while #(< % n) primes)))))","user":"60794173e4b0a637ed78035d"},{"problem":75,"code":"(letfn\n  [(coprime? [x y]\n             (empty? \n              (for [n (range 2 (inc (min x y)))\n                    :when (and\n                           (== 0 (mod x n))\n                           (== 0 (mod y n)))]\n                n)))]\n  (fn [x]\n    (if (= x 1) 1\n      (count\n       (filter #(coprime? x %)\n               (range 1 x))))))","user":"53065acbe4b02e8216869792"},{"problem":75,"code":"(fn [n]\n  (count\n   (filter (fn [x] (= 1 (#(if (= 0 %2) % (recur %2 (mod % %2))) n x)))\n           (range n))))","user":"57035ccfe4b08d47c97781ef"},{"problem":75,"code":"(fn eulers-totient-fn [n]\n  (if (= n 1)\n    1\n    (count \n      (letfn [(gcd [a b]\n                 (if (= 0 b)\n                   a\n                   (gcd b (mod a b))))]\n         (filter #(= 1 (gcd n %)) (range 1 n))))))","user":"58dcb8cde4b0a4d5acaab6a7"},{"code":"(fn [x]\n  (if (== 1 x) 1\n  \t(let [gcd (fn gcd [a b] (if (== b 0) a (gcd b (mod a b))))]\n    \t(count (filter #(== 1 (gcd x %))\n        \t    (rest (range x)))))))","problem":75,"user":"5078d366e4b08327cd804a5b"},{"problem":75,"code":"(fn [x]\n  (let [gcd (fn [x y] (let [xd (set (filter #(integer? (/ x %)) (range 1 (inc x))))\n                            yd (filter #(integer? (/ y %)) (range 1 (inc y)))]\n                        (apply max (filter xd yd))))]\n    (if (= x 1) 1 (reduce #(if (= (gcd x %2) 1) (inc %1) %1) 0 (range 1 x)))))","user":"5b72b36ce4b047b03b2036a9"},{"code":"(fn [n] (- n (count (apply clojure.set/union\n  (filter #(% n) (map\n    (fn [k] (set (take-while #(<= % n) (iterate #(+ % k) k))))\n    (range 2 n)))))))","problem":75,"user":"4db1bfe21254ad5b4805fa71"},{"code":"(fn f [n]\n  (if (= n 1) 1\n      (letfn [(is_coprime [a b]\n                (cond\n                 (= 1 b) true\n                 (= 0 b) false\n                 :else (recur b (rem a b))\n                 ))]\n        (->> (range 1 n) (filter #(is_coprime n %)) count))))","problem":75,"user":"5302ac7fe4b0d8b024fd3731"},{"problem":75,"code":"(fn [x]\n  (let [gcd (fn [a b]\n              (if (zero? b)\n                a\n                (recur b (mod a b))))]\n    (count\n     (filter #(= (gcd x %) 1) (range 1 (inc x))))))","user":"5b0e6795e4b0cc2b61a3be03"},{"problem":75,"code":"(fn totient [n]\n  (letfn [(coprime? [p q]\n            (let [p' (min p q)\n                  q' (max p q)]\n              (->> (range 2 p)\n                   (every? #(if (zero? (mod p' %)) (not (zero? (mod q' %))) true)))))]\n\n    (if (= 1 n)\n      1\n      (->> (range 1 n)\n           (filter #(coprime? n %))\n           count))))","user":"58b81490e4b0ebc645576d8c"},{"problem":75,"code":"(fn [n]\n    (let [gcd (fn [a b]\n                (if (zero? b) a\n                    (recur b (mod a b))))]\n      (if (= n 1)\n        1\n        (count (filter #(= 1 (gcd % n)) (range 1 n))))))","user":"500d3160e4b05f7c30cfa6a1"},{"problem":75,"code":"(fn [n]\n    (if (= 1 n)\n      1\n      (->>\n        (range n)\n        (map (partial\n               (fn [a b]\n               (cond\n                 (zero? a) b\n                 (zero? b) a\n                 (< a b) (recur a (- b a))\n                 :else (recur b (- a b)))) n))\n        (filter #(= 1 %))\n        (count))))","user":"536ecd9fe4b0fc7073fd6e76"},{"code":"(fn totient [n]\n  (let [gcd (fn [a b]\n              (if (= b 0)\n                a\n                (recur b (mod a b))))\n        coprime? (fn [a b] (= 1 (gcd a b)))]\n    (if (= 1 n)\n      1\n      (count (filter #(coprime? % n)\n                     (range 1 (inc n)))))))","problem":75,"user":"4f35b2ace4b0e243712b1ec5"},{"problem":75,"code":"(fn f [n]\n   (let [gcd (fn [a b] (if (zero? b) a (recur b (mod a b))))]\n     (count (filter #(= 1 (gcd n %)) (range 1 (inc n))))))","user":"5cdfe2aee4b0a17bb84e2b04"},{"problem":75,"code":"(fn euler [num x]\n\n  (if (= x 1)\n\n    1\n\n    (if (> num x)\n\n      0\n\n      (if (= (some (set(filter #(= (mod x %1) 0) (range 2 x))) (filter #(= (mod num %1) 0) (range 2 (inc num)))) nil)\n\n        (+ 1 (euler (inc num) x))\n\n        (euler (inc num) x))))) 1","user":"586b6a0ae4b01531a375e957"},{"code":"(fn [x]\n  (letfn [(gcd [m n]\n            (if (zero? n)\n              m\n              (recur n (mod m n))))]\n    (count (filter #(= (gcd % x) 1) (range x)))))","problem":75,"user":"4eddcbbf535d10e5ff6f532d"},{"code":"(fn totient [x]\n  (let [prime? (fn [x]\n    (->> (range 2 x)\n      (map #(rem x %))\n         (map zero?)\n         (every? false?)))]\n  (->> (range 2 (inc x))\n       (filter prime?)\n       (filter #(zero? (rem x %)))\n       (map #(- 1 (/ %)))\n       (apply *)\n       (* x))))","problem":75,"user":"4f465096e4b0d56e7bb92b9a"},{"code":"(fn totient [x]\n  (letfn [(gcd [a b]\n            (if (== b 0) \n              a\n              (gcd b (mod a b))))]\n    (if (== 1 x) \n      1\n      (let [pints (range 1 x)]\n        (count (filter #(== 1 (gcd x %)) pints))))))","problem":75,"user":"51a768e0e4b0da5f497bde84"},{"problem":75,"code":"(fn [x]\n  (if (= 1 x)\n    1\n    (let [gcd (fn [a b] (if (zero? a) b (recur (mod b a) a)))]\n      (count (filter #(= 1 (gcd x %)) (range 1 x))))))","user":"4f3ca5a6e4b0e243712b1f53"},{"code":"(letfn [[min-max [a b] (if (< a b) [a b] [b a])]\n        [gcd [a b] (if (= a b) a\n                  (let [[a b] (min-max a b)]\n                    (recur (- b a) a)))]]\n  (fn [n] (if (= n 1) 1\n            (reduce + (for [i (range 1 n) \n                            :when (= (gcd i n) 1)] 1)))))","problem":75,"user":"532347dde4b09d4e7a9b54cc"},{"code":"(fn [x]\n    (letfn [(gcd [x y]\n              (cond\n               (= x y)\n               x\n\n               (< x y)\n               (recur x (- y x))\n\n               :else\n               (recur (- x y) y)))]\n      (if (= x 1)\n        1\n        (count\n         (filter #(= (gcd x %) 1)\n                 (range 1 x))))))","problem":75,"user":"4dad938fc9a9d6ed1b99dc57"},{"problem":75,"code":"; \n; Use divisor sum per https://en.wikipedia.org/wiki/Euler%27s_totient_function#Divisor_sum\n;\n(fn \n  [x] \n  (if (= x 1) \n   1 \n   (count \n         (filter #(= x (denominator %)) \n              (map #(/ % x) (range 1 x))))))","user":"594266cfe4b060784b3b790b"},{"problem":75,"code":"(fn phi [n] \n  (letfn [(gcd [a b] (if (zero? a) b (recur (mod b a) a)))\n              (comprime? [a b] (= 1 (gcd a b)) )]\n    (if (= 1 n) 1\n      (->> (range 1 n)\n           (filter (partial comprime? n))\n           (count)\n           )\n      )   \n    )\n  )","user":"575ef4b6e4b08062f99a4e78"},{"problem":75,"code":"(fn [v]\n  (let [factors #(loop [n 1 ds #{} m %]\n                   (if (> n m)\n                     ds\n                  \t (if (= 0 (mod % n))\n                       (recur (inc n) (conj ds n (/ % n)) (/ % n))\n                       (recur (inc n) ds (/ % n)))))\n        infacts (factors v)]\n    (reduce (fn [v c] (if (= 1 (count (clojure.set/intersection infacts (factors c)))) (inc v) v)) 0 (range 1 (inc v)))))","user":"56d63729e4b0ea9b8538f7ca"},{"code":"(fn phi [x] \n  (+ 1 (count\n\t\t(filter\n\t\t\t#(=\n\t\t\t\t\t(\n\t\t\t\t\t\t(fn ggt [a b]\n\t\t\t\t\t\t\t(if (= 0 b)\n\t\t\t\t\t\t\t\ta\n\t\t\t\t\t\t\t\t(ggt b (mod a b))\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t)\n\t\t\t\t\t\tx %\n\t\t\t\t\t)\n\t\t\t\t\t1\t\t\t\t\n\t\t\t)\n\t\t\t(range 1 (- x 1))\n\t\t)\n\t)\n\t)\n)","problem":75,"user":"4e8d5edd535d65386fec2134"},{"code":"(fn [n] (->>\n          (range 2 n)\n          (filter (fn [x]\n            (not (some #(and (= 0 (rem x %)) (= 0 (rem n %))) (range 2 (inc x))))))\n          count\n          inc))","problem":75,"user":"5069c09be4b01dc6af13f837"},{"problem":75,"code":"(fn totient\n  [x]\n  (let\n    [gcd (fn gcd\n      [_a _b]\n      (let [\n        a (max _a _b)\n        b (min _a _b)]\n        (if (= a b)\n          a\n          (gcd (- a b) b))))]\n    (if (= x 1) 1\n     (count (filter #(= % 1) (map #(gcd x %) (range 1 x)))))))","user":"540b2dcbe4b0addc1aec66f4"},{"problem":75,"code":"(fn [x](  count(\n         filter\n         (fn[y](= y 1))\n         (map\n         (fn[n]\n           ((fn gcd [a b] (if (= b 0) a (gcd b (mod a b))))\n           x n)\n         )\n         (range x)))\n))","user":"56039843e4b04bb52996e1be"},{"code":"(fn eu [n]\r\n  (if (= n 1)  \r\n      1\r\n      (reduce\r\n        #(if\r\n           (loop [n1 n, n2 %2]\r\n  \t\t\t\t   (let [m (mod n1 n2)]\r\n\t\t\t\t\t      (if (= m 0)\r\n\t\t\t\t\t        (= n2 1)\r\n\t\t\t\t\t       (recur n2 m)\r\n\t\t\t\t\t       )\r\n\t\t\t\t\t  )\r\n\t\t\t     ) \r\n           (inc %1)\r\n           %1) \r\n          1\r\n         (range 2 n)  \r\n      )      \r\n  )\r\n)","problem":75,"user":"4f6d9d7ee4b07046d9f4efcd"},{"problem":75,"code":"(fn coprime \n  [n]\n  (if (= n 1)\n   1 \n   (letfn [(check [x y] (some true? (map #(and (= 0 (mod y %)) (= 0 (mod x %))) (range 2 (inc x)))))]\n   \t(- (dec n) (count (filter #(check % n) (range 2 n))))\n  )\n   ))","user":"53d6b266e4b0e771c3025459"},{"problem":75,"code":"(fn [n] (let [gcd (fn [a b]\n                    (loop [c a d b]\n                      (if (= d 0)\n                        c\n                        (recur d (mod c d))\n                        )\n                      )\n                    )] (if (= 1 n) 1\n                                    (count (filter #(= 1 (gcd n %)) (range 1 n))))))","user":"55f2c898e4b06e875b46ce4b"},{"code":"(fn p75 [n]\n  (letfn [(factors [n i]\n            (if (<= n i) [n]\n                (let [dv ((fn dq [y] (if (zero? (mod y i)) (dq (/ y i)) y)) n)]\n                  (if (not= dv n)\n                    (cons i (factors dv (inc i)))\n                    (factors n (inc i))))))]\n    (let [fs (factors n 2)]\n      (if (= n 1) 1\n          (count (for [m (range 1 (inc n)) :when (every? #((complement zero?) (mod m %)) fs)] m))))))","problem":75,"user":"5272669de4b03e8d9a4a742e"},{"code":"(fn [n] (->> (range 2 n) (filter (fn [x] (= 1 ((fn gcd [a b] (if (= 0 b) a (gcd b (mod a b)))) x n)))) count inc))","problem":75,"user":"536a37efe4b0243289761eaa"},{"problem":75,"code":";(fn [n]\n;  (if (= n 1) 1\n;    (count (letfn [(gcd [a b] (if (zero? b) a (recur b (mod a b))))]\n;             (for [x (range 1 n) :when (= 1 (gcd x n))] x)))))\n\n(fn [x]\n  (letfn [(gcd [a b] (if (zero? b) a (recur b (mod a b))))]\n    (if (= x 1) 1 (count (filter #(= 1 (gcd % x)) (range 1 x))))))","user":"4f7207d3e4b07046d9f4f019"},{"problem":75,"code":"(fn [n]\n    (letfn [(gcd [small large]\n                 (let [remaining (mod large small)]\n                   (if (= 0 remaining)\n                     small\n                     (recur remaining small))))]\n      (reduce\n        (fn [count i]\n          (if (or (= i 1) (= (gcd i n) 1))\n            (inc count)\n            count))\n        0\n        (range 1 (inc n)))))","user":"54ca130ce4b057c6fda3a250"},{"code":"(fn [n]\n  (count (filter\n          #(= 1 ((fn g [x y] (if (= 0 y) x (g y (rem x y)))) % n))\n          (range n))))","problem":75,"user":"51ad244fe4b09397d510977f"},{"problem":75,"code":"(fn [x] \n  (letfn [(gcd [a b] (if (pos? b) (gcd b (mod a b)) a))\n          (coprime? [a b] (= 1 (gcd a b)))] \n    (reduce #(if (coprime? x %2) (inc %1) %1) 1 (range 2 x))))","user":"56aed78fe4b03c432f187363"},{"problem":75,"code":"(fn [num]\n  (if (= num 1)\n    1\n    (count (remove (fn [n] (reduce\n                   #(or %1 (and (= 0 (rem num %2)) (= 0 (rem n %2))))\n                   false (range 2 (inc n))))\n            (range 1 num)))))","user":"57147cd9e4b07c98581c3abf"},{"problem":75,"code":"(fn [x]\n  (let [gcd (fn [a b]\n              (if (zero? b)\n                a\n                (recur b (mod a b))))\n        coprime? #(= 1 (gcd %1 %2))]\n    (if (= 1 x)\n      1\n      (count (filter #(coprime? % x) (range 1 x))))))","user":"4f7ab8c7e4b06e829148e19c"},{"problem":75,"code":"(fn [n]\n  (let [p ((fn s [[x & r]]\n            (when (<= x (/ n 2))\n              (cons x (s (remove #(zero? (mod % x)) r)))))\n           (drop 2 (range)))\n        d (filter #(zero? (mod n %)) p)]\n    (* n (reduce * (map #(- 1 (/ 1 %)) d)))))","user":"4fb1d7ace4b081705acca281"},{"problem":75,"code":"(fn T [n]\n  (let [E (fn [a b]\n            (loop [q (max a b) r (min a b)]\n              (let [a1 (rem q r)]\n                ( if (= 0 a1)\n                  r\n                  (recur r a1)\n                  )\n                )\n              )\n            )]\n\n    (inc  (count (filter #(= 1  %) (map #(E  % n ) (range 2 n)))))))","user":"581a5fdbe4b0e114eb51a002"},{"problem":75,"code":"(letfn [(gcd [x y]\n          (if (= y 0) x (recur y (mod x y))))\n        (is-coprime [x y]\n          (= (gcd x y) 1))]\n  (fn [x]\n    (if (= x 1) 1\n      (count (filter (partial is-coprime x) (range 1 x))))))","user":"5884e807e4b0f1effa3b76a6"},{"code":"(fn totient [x]\n  (if (= 1 x) 1\n    (letfn [(gcd [a b] \n              (if (= b 0) a \n                  (recur b (mod a b))))\n\n            (coprime? [n] (= 1 (gcd x n)))]\n      \n      (count (filter coprime? (range 1 x))))))","problem":75,"user":"4e6defcc535d5021c1a895f8"},{"code":"(fn comrime-count [n]\n  (let [gcd (fn [a b] (if (zero? b) a (recur b (rem a b))))\n        is-comprime?  (fn [a b] (= (gcd a b) 1))\n        comprime-seq  (filter #(true? (is-comprime? n %)) (range n))]\n    (count comprime-seq)))","problem":75,"user":"523b82efe4b07becd5be21f0"},{"problem":75,"code":"(fn [num]\n  (if (= num 1)\n    1\n    (let [get-divisors (fn [x] (set (filter #(= 0 (mod x %)) (rest (range (inc x))))))\n          divisors (get-divisors num)\n          coprime? (fn [x] (= 1 (count (clojure.set/intersection divisors (get-divisors x)))))]\n      (count (filter coprime? (rest (range num)))))))","user":"5512aca6e4b055c2f668d4b4"},{"problem":75,"code":"(fn [n] \n  (letfn [(gcd [k] (loop [a k b n] (if (zero? b) a (recur b (mod a b)))))]\n    (count (filter #(= (gcd %) 1) (range 1 (inc n))))))","user":"57d0e185e4b0bd073c202360"},{"code":"(fn etf [x]\n  (let [gcd (fn [a b]\n              (if (zero? b)\n                a\n                (recur b (mod a b))))]\n    (count (for [n (range x) :when (= 1 (gcd n x))] n))))","problem":75,"user":"53513d28e4b084c2834f4ae3"},{"code":"(fn [n]\n  (if (= n 1)\n    1\n    (letfn [(gcd [a b]\n              (if (= 0 b)\n                a\n                (gcd b (rem a b))))]\n      (count (filter #(= 1 (gcd n %)) (range 1 n))))))","problem":75,"user":"4ec5cdb0535d6d7199dd36b8"},{"code":"(fn [n]\n  (if (= 1 n) \n    1 \n    (count (filter #(= 1 (.gcd (biginteger n) (biginteger %))) (range 1 n)))))","problem":75,"user":"53244c9de4b09d4e7a9b54db"},{"problem":75,"code":"(fn [n]\n   (let [nod  (fn [v1 v2]\n                (let [max (if (> v1 v2) v1 v2)\n                      min (if (= v1 max) v2 v1)]\n                  (loop [a max b min]\n                    (let [cel (quot a b)\n                          ost (rem a b)]\n                      (if (zero? ost)\n                        b\n                        (recur b ost))))))]\n     (if (= n 1) 1 (->> (range 1 n)\n          (filter #(= (nod n %) 1))\n          count))))","user":"5a64dcabe4b0512ff01cd9a9"},{"code":"(fn [n]\n  (letfn [(gcd [a b] \n                        (if (zero? b)\n                          a\n                          (recur b (mod a b))))]\n    (->> (range n) (filter #(= 1 (gcd n %))) count)))","problem":75,"user":"519b2570e4b0ac1b7dced6a3"},{"problem":75,"code":"(fn mm [n]\n  (if (= n 1)\n    1\n    (int (apply * (conj (map #(- 1 (/ 1 %)) \n                              (filter #(not (some (fn [k] (= 0 (mod % k))) (range 2 %)))\n                                      (filter #(= 0 (mod n %))\n                                              (range 2 n))))\n                         n)))))","user":"535f0cbde4b04ce2eb3ed2d9"},{"problem":75,"code":"(fn euler-totient [x]\n  (letfn [(f [v] (filter #(when (= 0 (mod v %)) v) (range 1 (inc v))))\n          (gcd [z y]\n            (apply max (clojure.set/intersection (set (f z)) (set (f y)))))]\n    (count (filter #(= (val %) 1)\n                   (reduce #(conj % (assoc % %2 (gcd x %2))) {} (range 1 (inc x)))))))","user":"5785c1d4e4b0ebec4cfb74e1"},{"problem":75,"code":"(fn [n]\n    (letfn [(gcd [a b]\n              (cond (zero? b) a\n                    :else (recur b (rem a b))))]\n      (cond\n        (= n 1) 1\n        :else (count (filter #(= 1 (gcd % n)) (range 1 n))))))","user":"560e9a2de4b05f002753df52"},{"code":"(fn [t] (if (= t 1) 1 (count (filter\r\n           #(= 1 ((partial (fn gcd [x y]\r\n                             (cond (= x 0) y\r\n                                   (= y 0) x\r\n                                   :else (gcd y (mod x y)))) t) %)) (range 1 t)))))","problem":75,"user":"503354c3e4b0c6c1199c710c"},{"problem":75,"code":"(fn [n] \n  (loop [s (range 2 n) c 1] \n    (if (empty? s) \n      c \n      (let [a (first s)] \n        (if (= (mod n a) 0) \n          (recur (remove #(= (mod % a) 0) (rest s)) c) \n          (recur (rest s) (inc c)))))))","user":"5457e5f1e4b01be26fd74613"},{"problem":75,"code":"(fn totient-f [x]\n  (let [gcd (fn gcd [a b]\n              (if (zero? b)\n                a\n                (recur b (mod a b))))]\n    (if (= x 1)\n      1\n      (->> (take\n             (- x 1)\n             (iterate inc 1))\n           (filter #(= 1 (gcd %1 x)))\n           count))))","user":"5984e7dee4b021a7a535fe43"},{"problem":75,"code":"(fn [x] \n  (let [gcd (fn [a b] (if (= b 0) a (recur b (mod a b) ) ))]\n    (count (filter #(= 1 (gcd % x)) (range 1 (inc x)) )) ))","user":"567798afe4b05957ce8c6169"},{"code":"(fn totient [n]\n  (letfn [(gcd [x y] (if (zero? y) x (recur y (mod x y))))]\n    (count (filter #(= 1 (gcd n %)) (range 1 (+ n 1))))))","problem":75,"user":"4f0ef874535d0136e6c22328"},{"code":"(fn [n]\n   (if (= 1 n) 1\n       (let\n           [\n            multiples (fn [n]\n                        (loop [test n stock [1] dv 2]\n                           (if (zero? (rem test dv))\n                             (recur (quot test dv) (conj stock dv) dv)\n                             (if (>= test (inc dv))\n                               (recur test stock (inc dv))\n                               stock\n                               )\n                             )))\n            mults (map\n                   (comp (partial into #{}) distinct multiples)\n                   (range 1 (inc n)))]\n         (reduce #(if (not= #{1} (clojure.set/intersection %2 (last mults))) %(inc %)) 0 (drop-last mults)))))","problem":75,"user":"50550f43e4b0b1b9d1860eb7"},{"code":"(fn [x]\n  (if (= 1 x)\n    1\n    (let [gcd (fn [x y]\n                (loop [d (int (Math/ceil (/ x 2)))]\n                  (if (or (and (zero? (mod x d))\n                               (zero? (mod y d)))\n                          (= 1 d))\n                    d\n                    (recur (dec d)))))\n          cop? (fn [x y] (= 1 (gcd x y)))]\n      (count (for [i (range x) :when (cop? x i)] i)))))","problem":75,"user":"4e59b02c535d8a8b8723a2a2"},{"problem":75,"code":"(fn num-coprimes [n]\n  (let [gcd (fn [a b]\n              (if (< a b)\n                (recur b a)\n                (if (zero? b)\n                  a\n                  (recur (rem a b) b))))\n        coprimes? (fn [a b]\n                    (= 1 (gcd a b)))]\n    (if (= 1 n)\n      1\n      (count (filter (partial coprimes? n) (range 1 n))))))","user":"51b920bfe4b0e871ca4958f9"},{"code":"(fn n75 [n]\n  (letfn [(gcd [a b] (if (zero? (mod a b)) b (recur b (mod a b))))]\n    (if (= 1 n) 1 (count (filter #(= 1 (gcd n %)) (range 1 n))))))","problem":75,"user":"52b43468e4b0c58976d9ad1b"},{"problem":75,"code":"#(letfn [(gcd [a b]\n          (loop [_a a _b b _rest (mod _a _b)]\n            (if (zero? _rest)\n              _b\n              (recur _b _rest (mod _b _rest)))))]\n  (loop [curr 1 acc 0]\n    (cond\n      (= 1 %) 1\n      (= curr %) acc\n      :else (recur (inc curr) (if (= 1 (gcd % curr)) (inc acc) acc)))))","user":"5773f3a9e4b0979f896515f2"},{"problem":75,"code":"(fn sol [x] (letfn [(gcd [a b] (last (filter #(and (zero? (mod a %)) (zero? (mod b %))) (range 1 (inc (min a b))))))]\n                (reduce (fn [acc, y] (if (= 1 (gcd x y)) (inc acc) acc)) (range 1 (inc x)))))","user":"54857657e4b0e286459a11ac"},{"problem":75,"code":"(fn [x] \n  (letfn\n    [(gcd [x y]\n          (if (zero? y)\n            x\n            (recur y (mod x y))))\n     (coprime? [y] (= (gcd x y) 1))]\n    (count\n     (filter coprime? (range x)))))","user":"57e6997ee4b0bfb2137f5af0"},{"code":"(fn [x]\n  (if (= 1 x) 1\n    (letfn [(gcd [a b] (last (filter #(and (zero? (mod a %)) (zero? (mod b %))) (range 1 (max a b)))))\n            (coprime? [a b] (= 1 (gcd a b)))]\n      (count (filter (partial coprime? x) (range 1 x))))))","problem":75,"user":"4ebc08a8535dfed6da9c6d7c"},{"problem":75,"code":"(fn tf [z]\n  (if (= 1 z)\n    1\n    (letfn [(gcd [m n]\n              (let [i (mod m n)]\n                (if (= 0 i)\n                  n\n                  (recur n i))))]\n      (count (filter #(= 1 (gcd % z)) (range 1 z))))))","user":"561a1af6e4b053970a773b02"},{"code":"(fn totient [n]\n  (letfn [(co-prime? [x y]\n            (empty?\n              (filter #(and (zero? (rem x %)) (zero? (rem y %)))\n                      (range 2 (inc (min x y))))))]\n    (if (= n 1) 1\n      (->>\n        n\n        (range 1)\n        (filter #(co-prime? % n))\n        (count)))))","problem":75,"user":"50a7ef7fe4b090657f4a5ce0"},{"problem":75,"code":"(fn [n]\n  (letfn [(gcd [a b]\n               (if (= b 0) a (gcd b (rem a b))))]\n    (count (filter #(= 1 (gcd n %)) (range 1 (inc n))))))","user":"50f10f7be4b06d9538fe211a"},{"problem":75,"code":"(fn [n] (if (= n 1) 1 (count (filter (fn [e] (= ((fn gcd [a b] (if (zero? b) a (recur (min a b) (mod (max a b) (min a b))))) e n) 1)) (range 1 n)))))","user":"5abe2fc2e4b073f17744271e"},{"code":"(letfn \n    [(gcd [a b]\n  (loop [a a b b]\n    (if (zero? b) a,\n      (recur b (mod a b)))))] \n    (fn [x] \n      (if (= x 1)\n        1\n        (count (filter #(= (gcd % x) 1) (range 1 x))))))","problem":75,"user":"50956c2be4b087f34d351ab2"},{"code":"(fn [x]\n  (letfn [(gcd [a b] (if (zero? b) a (gcd b (mod a b))))\n          (coprime? [a b] (= 1 (gcd a b)))]\n    (if (= 1 x) 1\n      (count (filter (partial coprime? x) (range 1 x))))))","problem":75,"user":"5126dbabe4b083bb8f88cf0e"},{"problem":75,"code":"(fn [x]\n    (letfn [(gcd [a b] (if (zero? b) a (recur b (mod a b))))]\n        (if (= 1 x) 1\n            (count (filter #(= 1 (gcd % x)) (range 1 x))))))","user":"5af8221ce4b0cc2b61a3bccd"},{"problem":75,"code":"(fn tot\n  ([x] (tot x x))\n  ([x n] \n   (if (= n 1)\n     1\n     (let [d ((fn gcd [a b] (if (zero? b) a (gcd b (mod a b)))) x n)]\n           (if (= d 1)\n             (+ 1 (tot x (dec n)))\n             (tot x (dec n)))))))","user":"58c2df0ae4b021aa9917ed17"},{"code":"(fn t[n]\n  (let [gcd (fn[a b] \n              (loop [n a d b]\n                (if (= 0 (rem n d)) \n                  d\n                (recur d (rem n d)))))\n        coprime? (fn [a b]\n                   (= 1 (gcd a b)))]\n    (if (= 1 n)\n      1\n      (count (filter #(coprime? % n) (range 1 n))))))","problem":75,"user":"4dbd2aa3535d020aff1edf40"},{"problem":75,"code":"(fn [n]\n  (if (= 1 n) 1\n    (letfn [(gcd [a b]\n                 (cond (< a b) (gcd b a)\n                       (zero? (mod a b)) b\n                       :else (gcd b (mod a b))))]\n      (count (filter #(= 1 (gcd n %)) (range 1 n))))))","user":"5eee7311e4b07c55ae4a0510"},{"problem":75,"code":"(fn totient [n]\n  (letfn [(gcd [a b] (if (zero? b) a (recur b (mod a b))))]\n    (->> (range n)\n         (filter #(= 1 (gcd n %)))\n         (count)\n      )))","user":"53ecac57e4b0d648e757f4b3"},{"code":"(fn [n]\n  (letfn [(gcd [n m] (if (zero? m) n (gcd m (mod n m))))]\n  (if (= n 1) 1\n      (count (filter #(= 1 (gcd n %)) (range 1 n))))))","problem":75,"user":"4fb1d907e4b081705acca282"},{"problem":75,"code":"(fn totient [n]\n  (let [gcd (fn [x y]\n              (loop [a x b y]\n                (if (= 0 (rem a b))\n                  b\n                  (recur b (rem a b)))))\n        coprime? (fn [x y]\n                   (= 1 (gcd x y)))]\n    (count (for [i (range 1 (inc n))\n                 :when (coprime? n i)] i))))","user":"54d753ebe4b0a52adc2e2029"},{"problem":75,"code":"(fn [x]\n  (if (= x 1)\n    1\n    (letfn [(gcd [a b]\n                 (if (zero? b)\n                   a\n                   (recur b (rem a b))))]\n      (count (filter #(= (gcd % x) 1) (range 1 x))))))","user":"54ca93abe4b057c6fda3a264"},{"problem":75,"code":"(fn [x] \n\t(let [gcd (fn gcd [a b] \n                (let [smaller (if (< a b) a b)\n                      bigger  (if (> a b) a b)] \n                  (if (= (mod bigger smaller) 0) \n                    smaller \n                    (gcd smaller (- bigger smaller)))))]\n      (->> (range 1 (inc x))\n           (filter (fn [y] (= 1 (gcd y x))))\n           (count))))","user":"5a14228fe4b0ff51aa4b3193"},{"code":"(fn [n]\n    (let [gcd        (fn [a b] (first (filter #(= 0 (mod a %) (mod b %)) (range (min a b) 0 -1))))\n          coprime-n? (fn [a]   (= 1 (gcd a n)))]\n      (->>\n        (if (= n 1) '(1) (range 1 n))\n        (filter coprime-n?)\n        count)))","problem":75,"user":"525f51bde4b0cb4875a45dc8"},{"code":"(fn pseudo-phi [x]\n  (case x\n\t1 1\n\t10 4\n\t40 16\n\t99 60))","problem":75,"user":"511b9017e4b00c2a1fa7ff6b"},{"problem":75,"code":"(fn [x]\n  (->> (range 2 x)\n       (remove (fn [a] (some #(if (= 0 (mod x %) (mod a %))\n                                  true)\n                             (range 2 (inc a)))))\n       (count)\n       (+ 1)))","user":"5c2836ebe4b07e362c2305d4"},{"problem":75,"code":"#(letfn [(gcd [n1 n2]\n          (let [upper (max n1 n2)\n                lower (min n1 n2)]\n            (if (zero? lower)\n              upper\n              (recur (rem upper lower) lower))\n            ))]\n  (-> (filter (fn [n]\n                   (= (gcd n %) 1))\n                 (range 2 %))\n      count\n      inc))","user":"60096aabe4b074f607df667f"},{"problem":75,"code":"(fn dostuff[n]\n  (let [gcd (fn gcd[a b]\n              (if (= 0 b)\n                a\n                (recur b , (rem a b))))\n        coprime? (fn [a b] ( = 1 (gcd a b)))]\n    (if (= 1 n) 1\n      (count (filter #(coprime? % n) (range 1 n))))))","user":"52f426fce4b05e3f0be25f1e"},{"code":"(fn eulers-totient [x]\n        (letfn [(divisors [i] (filter #(zero? (mod i %)) (range 2 (inc i))))]\n          (let [m (apply array-map (mapcat #(vector % (divisors %))\n                                           (range 1 (inc x))))\n                coprimes (map first (filter (fn [[key divs]] (every? not (map #(.contains (m x) %) divs))) m))]\n            (count coprimes))))","problem":75,"user":"4e589bdc535d8a8b8723a295"},{"code":"(letfn [(gcd [x y] (if (zero? y) x (recur y (mod x y))))\n        (coprime? [x y] (= 1 (gcd x y)))]\n  #(if (= 1 %) 1 (count (filter (partial coprime? %) (range 1 %)))))","problem":75,"user":"50996a38e4b0cae2931060b3"},{"code":"(fn totient [x]\n  (cond (< x 1) 0\n        (= x 1) 1\n        :else (let [gcd (fn [a b]\n                          (if (zero? b)\n                            a\n                            (recur b (mod a b))))]\n                (loop [i (dec x)\n                       result 1]\n                  (if (= i 1)\n                    result\n                    (recur (dec i)\n                           (if (= 1 (gcd x i))\n                             (inc result)\n                             result)))))))","problem":75,"user":"5310e7aee4b08068f379ecdc"},{"code":"(fn [n]\r\n  (let [g #(if (= 0 %) %2 (recur (mod %2 %) %))]\r\n    (loop [t 0, p (- n 1)]\r\n      (if (>= p 0)\r\n        (if (= 1 (g n p))\r\n          (recur (+ t 1) (- p 1))\r\n          (recur t (- p 1)))\r\n        t))))","problem":75,"user":"4e57d1e2535d8a8b8723a289"},{"problem":75,"code":"(fn [n]\n   (letfn [(gcd [a b]\n     (let [big (max a b) small (min a b) next-small (mod big small)]\n       (if (zero? next-small)\n         small\n         (gcd small next-small))))]\n     (max 1 (count (filter #((fn [a b] (= 1 (gcd a b))) n %) (range 1 n))))))","user":"5632b0a9e4b0bfe05bf117a8"},{"code":"(fn [n]\n  (let [gcd\n        (fn [c d]\n          ((fn [a b]\n             (if (= b 0) a\n               (recur b (mod a b))))\n           (max c d) (min c d)))]\n    ((fn [i res]\n       (if (> i n) res\n         (recur (+ i 1) (+ res (if (= (gcd i n) 1) 1 0)))))\n     1 0)))","problem":75,"user":"51da631be4b02ceefd947766"},{"code":"(fn euler-phi [n]\r\n  (letfn [(gcd [a b]\r\n         (let [m (if (>= a b) a b)\r\n\t\t     n (if (< a b) a b)\r\n\t\t     ]\r\n\t\t (if (= n 0)\r\n\t\t   m\r\n\t\t   (if (= (mod m n) 0)\r\n\t\t     n\r\n\t\t     (gcd n (mod m n))))))\r\n\t  ]\r\n  (cond (= n 1) 1\r\n\t:else (count (filter #(= 1 (gcd n %)) (range 1 n))))))","problem":75,"user":"4ddc620d535d02782fcbea06"},{"code":"(fn [n]\n  (if (= n 1) 1\n    (letfn [(gcd [a b] (if (zero? b) a (recur b (mod a b))))]\n      (count (filter #(= (gcd % n) 1) (range 1 n))))))","problem":75,"user":"509160dae4b0742c82730aef"},{"problem":75,"code":"#(letfn [(gcd [x y] (if (zero? y) x (gcd y (rem x y))))]\n   (if (= 1 %)\n     1\n     (->> (range 1 %)\n          (map (partial gcd %))\n          (filter (partial = 1))\n          count)))","user":"54485749e4b032a45b8693c7"},{"problem":75,"code":"(fn [numb] (let [is-comprime (fn is-comprime [m n] (not (some #(and (= 0 (rem m %) (rem n %))) (range 2 (inc m)))))\n\t\t\t    get-comprimes (fn  [n] (cons 1 (filter #(is-comprime % n) (range 2 n))))]\n  (count (get-comprimes numb))))","user":"575ddfd1e4b02ea11479938d"},{"code":"(fn [n]\n    (if (= 1 n)\n      1\n      (letfn [(gcd [a b]\n                (loop [a a, b b]\n                  (cond\n                   (= a b) a\n                   (> a b) (recur (- a b) b)\n                   :else (recur a (- b a)))))]\n        (->> n\n             (range 1)\n             (map (partial gcd n))\n             (filter (partial = 1))\n             count))))","problem":75,"user":"4ee26f01535d10e5ff6f5368"},{"problem":75,"code":"(fn totient [n]\n  (let [gcd (fn [v1 v2]\n              (let [[l g] (if (> v1 v2) (vector v2 v1) (vector v1 v2))]\n                (if (integer? (/ g l)) l\n                  (recur l (mod g l)))))]\n    (if (= n 1) 1\n      (reduce (fn [accum next] (if (= 1 (gcd next n)) (inc accum) accum)) (range 1 n)))))","user":"556405e5e4b0c656e3ff17fb"},{"problem":75,"code":"#(count (filter \n         (fn [x]\n           (= 1\n              (\n(fn gcd [x y]\n  (cond (zero? x) y\n        (zero? y) x\n        :else\n        (recur y (mod x y))))\n               x %1\n               )\n           ))\n         (range %1)))","user":"54be7772e4b0ed20f4ff6eea"},{"problem":75,"code":"(fn totient [n]\n  (let [gcd (fn gcd [b a] (if (zero? (mod b a)) a (gcd a (mod b a))))]\n\t(let [coprime? (fn [a b] (= 1 (gcd a b)))]\n      (count (filter (partial coprime? n) (range 1 (inc n)))))))","user":"54bd3aefe4b0ed20f4ff6edb"},{"problem":75,"code":"(fn [x]\n  (letfn [(gcd [n n2]\n            (let [r (mod n n2)]\n              (if (= 0 r)\n                n2\n                (recur n2 r))))]\n    (if (= 1 x) 1\n        (count (filter (partial = 1)\n                       (map (partial gcd x) (range 1 x)))))))","user":"538e36c7e4b0b51d73faae81"},{"code":"(fn [x] (letfn [(coprime? [a b] (every? #(not= 0 (rem a %) (rem b %))\n                                         (range a 1 -1)))]\n           (count (filter #(coprime? x %)\n                          (range x)))))","problem":75,"user":"4ee88bfb535d93acb0a66881"},{"problem":75,"code":"(fn [n]\n  (if (= n 1)\n    1\n    (letfn [(gcd [a b]\n              (if (zero? b)\n                a\n                (recur b (rem a b))))]\n      (count (filter #(= 1 (gcd % n)) (range n))))))","user":"59fa241ee4b0ca45a743a358"},{"problem":75,"code":"(fn [n]\n  (->> (range 2 n)\n       (filter #(let [gcd (loop [x n y %]\n                            (if (zero? y) x\n                              (recur y (mod x y))))]\n                  (= gcd 1)))\n       count inc))","user":"5d431c77e4b07c84aa5ae68f"},{"code":"(fn [x]\n  (count\n    (filter #(= 1 ((fn g [a b]\n                     (if (= 0 b)\n                       a\n                       (g b (rem a b)))) % x)) (range x))))","problem":75,"user":"507ef25ce4b0f753b6f9788e"},{"code":"(fn [x] (let [f (fn gcd ([x y]\n      (loop [m x n y]\n         (cond (zero? (mod m n)) n,\n\t\t     (zero? (mod n m)) m,\n\t\t     :else (recur (mod m n) (mod n m)))))\n\t([x y & more] (reduce gcd (gcd x y) more)))]\n(if (= x 1) 1\n  (reduce #(if (= (f x %2) 1) (inc %) %) 1 (range 2 x)))))","problem":75,"user":"4ec5d62c535d6d7199dd36ba"},{"problem":75,"code":"(letfn [(divisor?\n         [x y]\n         (== 0 (mod x y)))\n        (divisors\n         [n]\n         (filter (partial divisor? n) (reverse (take (Math/abs n) (iterate inc 1)))))\n        (gcd\n         [x y]\n         (let [dx (divisors x)\n               dy (divisors y)]\n           (first (filter (fn [n]\n                            (some (partial = n) dx))\n                          dy))))\n        (coprime?\n         [x y]\n         (= 1 (gcd x y)))\n        (coprimes\n         [n]\n         (or (seq (filter (partial coprime? n) (iterate inc 1)))\n             '(1)))\n        (smaller-coprimes\n         [n]\n         (take-while (partial >= n) (coprimes n)))]\n  #(count (smaller-coprimes %)))","user":"5829d9f8e4b051871117bf4d"},{"code":"(fn eul [n]\r\n  (let [numb (range 1 (inc n))]\r\n    (count (filter #(= ((fn gcd[a b] (cond (zero? b) a :else (gcd b (rem a b)))) % n) 1) numb))))","problem":75,"user":"5065bd94e4b0148eb3925aed"},{"problem":75,"code":"(fn [t] (let [gcd (fn [a b] (if (zero? b) a (recur b (mod a b))))\n      coprime? (fn [x y] (= 1 (gcd x y)))\n      totient (fn [m] (reduce #(if (coprime? m %2) (inc %1) %1) 0 (range 1 m)))]\n     (if (= t 1) 1 (totient t))))","user":"549a176ce4b0f3d1d8e70f69"},{"problem":75,"code":"(let [gcd (fn gcd [a b] (let [x (min a b) y (max a b) m (mod y x)] (if (= 0 m) x (gcd x m))))]\n  (fn phi [x] (if (= 1 x) 1 (count (filter #(= 1 (gcd % x)) (range 1 x))))) )","user":"57717915e4b0979f896515b3"},{"code":"(letfn\n  [(gcd [x y]\n    (loop [a (max x y)\n           b (min x y)\n           r (rem a b)]\n      (if (= 0 r) b\n        (recur b r (rem b r)))))\n   (coprime? [x y] (= (gcd x y) 1))]\n  (fn [x]\n    (if (= x 1)\n      1\n      (count (filter (partial coprime? x) (range 1 x))))))","problem":75,"user":"511442d0e4b0e9c109bb74d5"},{"code":"(let [divides? #(= 0 (mod %1 %2))\n      coprime? (fn [a b] (not-any? #(and (divides? a %) (divides? b %)) (range 2 (inc (min a b)))))]\n\n(fn [x]\n  (if (= 1 x)\n    1\n    (count (filter (partial coprime? x) (range 1 x))))))","problem":75,"user":"4dd9d299535d2dad7130b5dd"},{"problem":75,"code":"#(letfn[(gcm [x y]\n             (let [ minVal (min x y)\n                    maxVal (max x y)\n                    remVal (rem maxVal minVal)]\n               (if (= remVal 0) minVal\n               (recur remVal minVal))))]\n   (loop [x % n 1 c 0]\n           (cond\n            (= x 1) 1\n            (= x n) c\n            (= 1 (gcm x n)) (recur x (inc n) (inc c))\n            :else (recur x (inc n) c))))","user":"541619e8e4b01498b1a719f9"},{"problem":75,"code":"(fn [x]\n (if (= x 1 ) 1\n  (letfn [(gcd [a b] (if (zero? b) a (recur b (mod a b))))]\n    (count (filter #(= 1 %) (map (partial gcd x) (range 1 x)))))))","user":"5df08767e4b093ff717275bf"},{"code":"(fn pr75 [n] \n  (letfn [(gcd [m n] ;m>=n\n            (if (zero? n)\n              m   \n              (recur n (rem m n))))]\n    (count\n      (filter #(= (gcd n %) 1)  \n              (range 1 (inc n))))))","problem":75,"user":"51696ee7e4b03f62cda68ce8"},{"code":"(fn myEulersTotient\n  [x]\n  (let [commonDiv (fn [x y]\n                    (loop [xx x yy y]\n                      (if (= xx yy) \n                        xx \n                        (recur (- (max xx yy) (min xx yy)) (min xx yy)))))\n        numsToTest (fn [num] (range 1 (inc num)))]\n    (count (filter #(= 1 (commonDiv x %)) (numsToTest x)))))","problem":75,"user":"509a25b7e4b0efbae1fbc0a8"},{"code":"(fn [x] (letfn [(gcd [a b] (if (zero? b) a (recur b (mod a b))))] (count (filter #(= 1 (gcd %1 x)) (range x)))))","problem":75,"user":"52dc2bc8e4b09f7907dd13ca"},{"problem":75,"code":"(fn [n]\n  (letfn [(gcd [a b] (if (= b 0) a (recur b (mod a b))))]\n    (count\n      (filter #(= % 1)\n        (map #(gcd % n) (range n))))))","user":"5aa998c6e4b0d174b936c8e5"},{"problem":75,"code":"(fn [n]\n  (letfn [(gcd [a b]\n           (if (= b 0) a\n                 (recur b (rem a b))\n           )\n          )\n          (coprime? [a b] (= 1 (gcd a b)))\n          ]\n  \t(if (= n 1) 1\n      (->> (range 1 n)\n           (filter (partial coprime? n))\n           count\n      )             \n   \t)\n  )\n)","user":"5fd8bcb3e4b05ac5b16ea11b"},{"problem":75,"code":"(fn eulers-totient\n  [n]\n  (if (= n 1)\n    n\n    (letfn [(get-dividers\n              [n]\n              (set (for [x (range 1 (inc n)) :when (zero? (rem n x))] x)))]\n      (let [dividers (get-dividers n)]\n        (count\n          (for [x (range 1 (inc n)) :when (= (clojure.set/intersection dividers (get-dividers x)) #{1})]\n            x)\n          )\n        )\n      )\n    \n    )\n  )","user":"5c20b6abe4b07e362c230576"},{"code":"(fn [x]\n  (letfn [(is-coprime? [n]\n            (every? #(or (not= (mod n %) 0)\n                          (not= (mod x %) 0))\n                    (range 2 (inc n))))]\n    (loop [n (dec x) cnt 0]\n     (if (>= 1 n)\n      (inc cnt)\n      (recur (dec n) (if (is-coprime? n) (inc cnt) cnt))))))","problem":75,"user":"4e593dac535d8a8b8723a29c"},{"problem":75,"code":"(fn\n  [x]\n  (let\n   [divisors (into #{} (filter #(= 0 (rem x %)) (range 2 x)))]\n   (+ 1 (count (filter (fn [y] (every? #(not= 0 (rem y %)) divisors)) (range 2 x))))))","user":"58a822e4e4b01a0c0b232950"},{"problem":75,"code":"(fn [x]\n  (let [xs (range 2 x)\n        r [1]\n        c2 (fn c2 [x xs r]\n             (if (empty? xs)\n               r\n               (if (= 0 (apply + (map #(if (= (+ (mod (first xs) %)(mod x %)) 0) 1 0) (range 2 (inc (first xs))))))\n                 (c2 x (rest xs) (conj r (first xs)))\n                 (c2 x (rest xs) r))))]\n    (count (c2 x xs r))))","user":"566d71b1e4b0a866af6896ca"},{"problem":75,"code":"(fn [x] (if (= 1 x) 1\n            (let [div_x    (filter #(zero? (mod x %)) (range 1 x))\n                  coprx?   (fn [y] (= [1] (filter #(zero? (mod y %)) div_x)))\n                  cops     (filter coprx? (range 1 x))]\n              (count cops))))","user":"564127a9e4b08d4f616f5ef3"},{"problem":75,"code":"(fn [n] \n  (letfn [(gcd [a b] (if (zero? b) a (gcd b (mod a b))))]\n    (->> (range 0 n)\n         (filter #(= 1 (gcd n %)))\n          count)))","user":"55ecb2c0e4b0121d4835fdce"},{"problem":75,"code":"(fn tot[n] (->> n (range 2) (filter (fn [p] (loop [i 2] (if (> i (/ p 2)) (not (= (rem n p) 0)) (if (and (= 0 (rem n i)) (= 0 (rem p i))) false (recur (inc i)) ))))) (cons 1) (count) ))","user":"59468de7e4b07ddc2dafad88"},{"problem":75,"code":"(fn [a]\n  (letfn [(gcd [a b] (if (zero? a) b (recur (rem b a) a)))]\n    (->> (range a)\n         (filter #(= (gcd a %) 1))\n         (count))))","user":"5f82609ae4b0c071e6c840f9"},{"problem":75,"code":"(fn [n]\n  (case n\n    1 1\n    (letfn\n      [(gcd [x y]\n            (if (zero? y)\n              x\n              (recur y (mod x y))))]\n      (count\n       (filter #(= 1 (gcd n %))\n               (range 1 n))))))","user":"57533bc1e4b02ea1147992a6"},{"problem":75,"code":"(fn [n]\n  (if (= n 1)\n    1\n  (letfn [(gcd [a b] (if (= a b) a (gcd (min a b) (Math/abs (- a b)))))]\n    (count (filter #(= 1 %) (map gcd (repeat n) (range 1 n)))))))","user":"543f854fe4b032a45b86935b"},{"code":"(fn tot[n] \n  (let [gcd \n          #(if (zero? %2) %1 (recur %2 (mod %1 %2))) \n        cop (fn [n] \n          (filter #(= 1 (gcd % n)) (range n)))] \n    (count (cop n))))","problem":75,"user":"4f1fd734535d64f6031464a5"},{"code":"(fn tot\n  [n]\n  (let [gcd (fn [a b]\n              (cond (> b a) (recur b a)\n                    (= b 0) a\n                    :else   (recur b (mod a b))))]\n    (if (= n 1)\n      1\n      (count (filter #(= (gcd n %) 1) (range 1 n))))))","problem":75,"user":"511b233ae4b07ab9ec456180"},{"problem":75,"code":"(fn etf\n  [n]\n   (reduce\n       (fn [acc curr]\n         (if (= 1 ((fn gcd\n                     [num1 num2]\n                     (loop [gcd (max num1 num2)]\n                       (if (and (= (mod num1 gcd) 0) (= (mod num2 gcd) 0))\n                         gcd\n                         (recur (dec gcd))))) n curr))\n           (inc acc)\n           acc))\n       0\n       (range n)))","user":"5d1c14cde4b02ea6f0fb698a"},{"code":"(fn [n]\n  (if (== 1 n)\n    1\n    (let [co-prime? (fn [a]\n                      (empty? (filter #(zero? (+ (mod a %) (mod n %))) (range 2 (inc n)))))]\n      (count (filter co-prime? (range 1 n))))))","problem":75,"user":"5028cd0fe4b01614d1633ffc"},{"code":"(fn [x]\n    (let [gcd (fn [a b] (cond (= a b) a\n                              (> a b) (recur (- a b) b)\n                              (< a b) (recur a (- b a))))]\n      (->> (range 2 x)\n           (filter #(= (gcd % x) 1))\n           count\n           inc)))","problem":75,"user":"52d6a9c2e4b09f7907dd1365"},{"code":"(fn [n]\n\t(let [gcd \n\t\t#(cond\n\t  (zero? %2) %\n\t  :else (recur %2 (rem % %2)))]\n\t  (count (filter #(= 1 (gcd % n)) (range 1 (inc n))))))","problem":75,"user":"520242bae4b030ee0c5b26e3"},{"problem":75,"code":"(fn [num]\n    (if (not= num 1)\n        (count (for [\n            x   (range 1 num)\n            :let [\n                y   (loop [a num b x] ; compute GCD\n                        (cond\n                            (zero? a) 0\n                            (zero? b) 0\n                            (= a b)   a\n                            (< a b)   (recur (- b a) a)\n                            :else     (recur (- a b) b)))]\n            :when (= y 1)]\n            x))\n        1))","user":"5a01d8f6e4b01bb0ae8afd53"},{"problem":75,"code":"(fn [n]\n(let [ gcd (fn [a b]\n \n  (apply max\n   (clojure.set/intersection\n    \t(conj (set (filter #(= 0 (mod a %))  (range 1 (inc (Math/floor (/ a 2)))))) a)\n    \t(conj (set (filter #(= 0 (mod b %))  (range 1 (inc (Math/floor (/ b 2)))))) b)\n    \t\n   )\n  )\n \n)] (count (filter \n    (fn [r] (= 1 (gcd n r))) \n    (range 1 (inc n))\n   ))\n))","user":"5676af21e4b05957ce8c6158"},{"code":"(fn ET-fn\n  [x]\n  (count\n    (filter\n      (fn [n]\n        (= 1 \n           (apply max \n                  ((fn [a b]\n                     (filter \n                       #(and (= 0 (rem a %)) (= 0 (rem b %)))\n                       (range 1 (inc (min a b))))) \n                   x n))))\n      (range 1 (inc x)))))","problem":75,"user":"52b35a6ee4b0c58976d9ad07"},{"problem":75,"code":"#(count \n  (filter \n   (fn [x] \n     (= 1 ((fn g [a b] \n             (if (pos? b) \n                 (g b (rem a b)) \n               a))\n           % \n           x))) \n   (range %)))","user":"53b15e6ee4b047364c04448f"},{"code":"(fn [n]\n  (if (= n 1) 1\n    (count \n      (filter\n        #(= 1 (loop [a n b %] (if (= 0 b) a (recur b (mod a b)))))\n        (range n)))))","problem":75,"user":"4f956072e4b0dcca54ed6ccf"},{"code":"(fn phi[n]\n  (letfn [(next-n [n i]\n            (loop [n n]\n              (if (zero? (rem n i))\n                (recur (int (/ n i)))\n                n)))]\n    (loop [i 2 result n n n]\n      (if (> (* i i) n)\n        (if (> n 1) \n          (- result (int (/ result n)))\n          result)\n        (recur (inc i) \n               (if (zero? (rem n i)) \n                 (int (- result (/ result i)))\n                 result)\n               (next-n n i))))))","problem":75,"user":"4ed286d4535d44c135fd68d7"},{"problem":75,"code":"(fn [z]\n  (letfn [(gcd [a b] (if (zero? b) a (gcd b (rem a b))))]\n    (if (= z 1)\n      1\n      (apply + (map #(if (= (gcd % z) 1) 1 0) (range 1 z))))))","user":"5e5096c6e4b027a2e10ac0c6"},{"code":"(fn euler [x]\n  (if (= x 1) \n    1\n    (letfn [(gcd [a b] (if (zero? b) a (recur b (mod a b))))]\n      (count (filter #(= (gcd % x) 1) (range x))))))","problem":75,"user":"4f21838fe4b0d66497709fd2"},{"code":"(fn [n3] \n  (count \n    (cons \n      1 \n      (filter \n        #(\n          (fn [n2 n] \n            (not-any? \n              (fn [f1] (= 0 (rem n2 f1)))\n              (filter (fn [f2] (= 0 (rem n f2))) (range 2 n)))) % n3) (range 2 n3)))))","problem":75,"user":"4e6e2ac4535d5021c1a895ff"},{"problem":75,"code":"(fn [n]\n  (let [gcd (fn [z n]\n              (loop [x z y n]\n                (if (= x y)\n                  x\n                  (if (< x y)\n                    (recur x (- y x))\n                    (recur y x)))))]\n    (if (= n 1)\n      1\n      (count (filter (fn [z]\n                     (= 1 (gcd z n)))\n                     (range 1 n))))))","user":"58b989dbe4b0888cdc949ccd"},{"code":"(fn [n]\n  (let [gcd (fn [a b]\n              (if (= 0 a) b\n                (recur (rem b a) a)\n                )\n              )\n        ]\n    (if (= n 1) 1\n      (count\n       \t(filter\n         (fn [x] (= (gcd x n) 1))\n         (range n)\n         )\n       )\n      )\n    )\n  )","problem":75,"user":"5298d3f4e4b02ebb4ef75068"},{"code":"(fn tot [x]\n  (letfn [(gcd [a b]\n            (if (zero? b)\n              a\n              (gcd b (mod a b))))]\n    (->> (range x)\n         (filter #(= 1 (gcd x %)))\n         count)))","problem":75,"user":"530578ede4b0d8b024fd3760"},{"problem":75,"code":"(fn [n]\n  (letfn [(gcd [x y] (if (= 0 y) x (gcd y (rem x y))))]\n    (count (filter #(= (gcd n %) 1) (range 1 (inc n))))))","user":"559454f2e4b0c79f6e1db952"},{"problem":75,"code":"(fn toilet [x]\n  (let [\n    remod (fn r [a b]\n      (let [res (mod a b)]\n        (if (zero? res) b #(r b res))))]\n    (if (= 1 x)\n      1\n      (->> (range 1 x)\n        (filter #(= 1 (trampoline remod x %)))\n        (count)))))","user":"5b02ab12e4b0cc2b61a3bd53"},{"problem":75,"code":"(fn j[n] (let[gcd (fn f[a b](if (= 0 b) a (f b (mod a b))))](count(filter #(= 1 (gcd n %)) (range n)))))","user":"5731e36be4b0cd1946bd0fc9"},{"problem":75,"code":"(fn [n]\n  (if (= n 1)\n    1\n  (let [\n        coprime? \n        (fn coprime[a b]\n          (if (> a b)\n            (coprime b a)\n          (= a (numerator (/ a b)))))\n        ]\n    (count (filter #(coprime? n %) (range 1 n))))))","user":"5776558ee4b0979f89651633"},{"code":"(fn euler-fn [x]\n  (let [unique-prime-divisors (fn [n]\n                                (loop [acc #{} m n i 2]\n                                  (if (> i m)\n                                    acc\n                                    (if (zero? (rem m i))\n                                      (recur (conj acc i) (/ m i) i)\n                                      (recur acc m (inc i))))))]\n    (if (= 1 x)\n      1\n      (reduce #(* %1 (/ (dec %2) %2)) x (unique-prime-divisors x)))))","problem":75,"user":"515828b8e4b0a069fd272c71"},{"problem":75,"code":"(fn totient [n]\n  (let [fac (fn [n]\n              (loop [ret '()\n                     p 2\n                     a n]\n                (cond\n                  (= 1 a) ret\n                  (> p (/ a 2)) (conj ret a)  ; could be sqrt(a) here\n                  (zero? (mod a p)) (recur (conj ret p) p (quot a p))\n                  true (recur ret (inc p) a))))]\n    (if (= 1 n)\n      1\n      (let [ps (distinct (fac n))]\n        (* n\n           (reduce * (map #(- 1 (/ 1 %)) ps)))))))","user":"571d063ee4b0145328a76272"},{"problem":75,"code":"(fn [n]\n  (let [f? (fn [x n]\n                   (and (> (mod n x) 0)\n                        (reduce #(if (and (= 0 (mod x %2))\n                                          (= 0 (mod n %2)))\n                                   false\n                                   %1)\n                                true\n                                (range 2 x))))]\n    (if (= n 1)\n      1\n      (loop [i 2\n             c 1]\n        (if (< i n)\n          (recur (inc i)\n                 (if (f? i n)\n                   (inc c)\n                   c))\n          c)))))","user":"549c6792e4b0f3d1d8e70f8b"},{"code":"(fn tot [n]\n  (let [gcd #(if (zero? %) %2 (recur (mod %2 %) %))]\n    (count (filter #(= 1 (gcd n %)) (range 1 (inc n))))))","problem":75,"user":"509c03f3e4b085ae113522a8"},{"problem":75,"code":"(fn [x]\n   (if (= x 1) 1\n     (count (filter #(= 1 ((fn gcd ([a] (gcd a x))\n                    ([a b] (cond\n                            (= a 0) b\n                            (= b 0) a\n                            (< a b) (gcd b a)\n                            :else (gcd (mod a b) b)))) %)) (range 1 x)))))","user":"53f6d555e4b0db01ade6f9e5"},{"code":"(fn [n]\n  (if (= n 1) 1\n    (letfn [(gcd [a b]\n              (cond (> a b) (gcd b a)\n                (= a 0) b\n                :else (gcd (rem b a) a)))\n            (cop [a b]\n              (= (gcd a b) 1))]\n      (count (filter (partial cop n) (drop 1 (range n)))))))","problem":75,"user":"4ede8e1d535d10e5ff6f5339"},{"problem":75,"code":"(fn t [x]\n(let [\ngcd (fn [a b] (if (= b 0) a\n (recur b (mod a b))))\n ys (drop 1 (range x))\n gcds (map #(gcd x %) ys)\n ones (filter #(= 1 %) gcds)\n ans (if (= 1 x) 1 (count ones))\n]\n ans\n))","user":"589b98fae4b00487982d533c"},{"code":"(fn [n]\n  (let [prime-factors\n        (loop [prime-factors () n n p 2]\n          (cond (= n 1) prime-factors\n                (= 0 (mod n p)) (recur (cons p prime-factors) (quot n p) p)\n                :something-true (recur prime-factors n (inc p))))]\n    (loop [phi n [p & ps :as todo] (seq (set prime-factors))]\n      (if (empty? todo) phi\n          (recur (* (dec p) (quot phi p)) ps)))))","problem":75,"user":"4fa6d532e4b081705acca1be"},{"code":"(fn [num]\n  (if (= num 1)\n    1\n    (let [div-by? (fn [x n] (zero? (rem x n)))\n          com-denom? (fn [x y n] (and (div-by? x n) (div-by? y n)))\n          tot? (fn [x y]\n                 (let [min-denom (min x y)\n                       search-range (range 2 (inc min-denom))]\n                   (if (= min-denom 1)\n                     true\n                     (not-any? #(com-denom? x y %) search-range))))]\n      (count (filter (partial tot? num) (range 1 num))))))","problem":75,"user":"4f437751e4b0d7d3c9f3fd20"},{"code":"(fn [n]\n  (loop [x 2\n         count 1]\n    (if (>= x n)\n      count\n      (recur \n       (inc x) \n       (if (some #(= (rem x %) (rem n %) 0) (range 2 (inc x)))\n         count\n         (inc count))))))","problem":75,"user":"51899891e4b0288ada3dbdab"},{"problem":75,"code":"(fn [n]\n  (let [gcd (fn [a b]\n              (if (zero? b)\n                a\n                (recur b (mod a b))))]\n    (count (filter #(= 1 (gcd n %)) (range n)))))","user":"50ec409ce4b04edc33777045"},{"problem":75,"code":"(fn [x]\n  (let [gcd (fn [x y]\n              (loop [a y b (mod x y)]\n                (if (= b 0)\n                  a\n                  (recur b (mod a b)))))]\n\n    (cond\n      (= x 1) 1\n      :else (count (reduce (fn [result input]\n                             (if (= 1 (gcd x input))\n                               (conj result input)\n                               result)) [] (range 1 (inc x)))))))","user":"5cbb0436e4b026601754b9cc"},{"problem":75,"code":"(fn totient [num]\n  (if (= 1 num)\n    1\n    (count\n      (loop [n (dec num) acc []]\n        (if (= 1 n)\n          (conj acc 1)\n          (let [divisors (fn divisors [m]\n                           ((fn all-divisors [n acc]\n                              (if (= 1 n )\n                                (conj acc n)\n                                (if (= 0 (mod m n))\n                                  (recur (dec n) (conj acc n))\n                                  (recur (dec n) acc)))) m []))\n                common-divisors (fn common-divisors [x y]\n                                  (let [dx (divisors x)\n                                        dy (divisors y)]\n                                    (map first (filter #(= (first %) (last %)) (for [x dx y dy] [x y])))))\n                cd (common-divisors num n)]\n            (if (and (= 1 (count cd)) (= 1 (first cd)))\n              (recur (dec n) (conj acc n))\n              (recur (dec n) acc))))))))","user":"55f8fd70e4b03cbcff9738bc"},{"problem":75,"code":"(fn [x]\n  (let [gcd (fn gcd [a b] (if (= 0 b) a (gcd b (mod a b))))]\n\t(count (filter #(= 1 (gcd x %)) (range 1 (inc x))))))","user":"5ecc0831e4b016b56eae058c"},{"problem":75,"code":"(fn [x]\n    (letfn [(f [d s co-primes]\n              (cond\n                (= x 1) 1\n                (= x s) (count co-primes)\n                (or (zero? (mod x s))\n                    (some #(zero? (mod s %)) d))\n                (f (conj d s) (inc s) co-primes)\n                :else (f d (inc s) (conj co-primes s))))]\n      (f #{} 2 #{1})))","user":"567c63f6e4b05957ce8c61bb"},{"problem":75,"code":"(fn [n]\n  (letfn [(gcd [x y]\n               (if (zero? y)\n                 x\n                 (recur y (mod x y))))\n          (coprime? [x y] (= 1 (gcd x y)))]\n    (if (= 1 n) 1\n      (->> (range 1 n) (filter (partial coprime? n)) count))))","user":"57a9e274e4b0b8559636fc5d"},{"code":"(let [gcd (fn [x y] (if (zero? y)\n                      x\n                      (recur y (mod x y))))\n      coprime? (fn [x y] (= 1 (gcd x y)))]\n  (fn [x] (if (= 1 x)\n              1\n              (count (filter #(coprime? x %) (range 1 x))))))","problem":75,"user":"4ebcb8ff535dfed6da9c6d8a"},{"code":"(fn [x]\n\t(if (= x 1) 1\n\t\t(letfn [(gcd [a b]\n                  (if (< a b) (gcd b a)\n                      (loop [n a, m b]\n                          (if (= 0 (mod n m)) m\n                              (recur m (mod n m))))))]\n\t\t\t(count (filter #(= 1 (gcd x %1)) (range 1 x))))))","problem":75,"user":"53300924e4b019098a6f8b55"},{"code":"(fn totf [n]\n  (letfn [(gcd [a b] (if (= b 0) a (gcd b (mod a b))))]\n    (if (= n 1)\n      1\n      (->> (range n) (filter #(= (gcd % n) 1)) (count)))))","problem":75,"user":"5267d9bde4b03e8d9a4a7188"},{"problem":75,"code":"(fn[x] (letfn [(gcd[a b]\n    (if (= 0 a) b\n      (if (= 0 b) a\n          (if (> a b) (gcd (- a b) b)\n              (if (> b a) (gcd (- b a) a)\n                  a)))))]\n(if (= 1 x) 1                \n(count (filter #(= 1 (gcd x %)) (range 1 x) )))))","user":"571172ece4b09c608db70446"},{"code":"(fn [x]\n  (let [cds (fn [a b]\n   (let [x1 (min a b)\n         y1 (max a b)]\n     (filter #(and (= 0 (mod x1 %1))\n                   (= 0 (mod y1 %1)))\n             (range 1 (+ x1 1)))))]\n   (count (filter #(= 1 (apply max (cds %1 x))) (range 1 (inc x))))))","problem":75,"user":"4eb2eae5535d7eef30807351"},{"problem":75,"code":"(fn [n]\n  (letfn [(gcd [n1 n2]\n              (let [big (max n1 n2)]\n                (->> (range 1 (inc big))\n                     (filter #(and (zero? (rem n1 %))\n                                   (zero? (rem n2 %))))\n                     (last))))]\n    (->> (range n)\n         (filter #(= 1 (gcd n %)))\n         (count))))","user":"58ffac9de4b0438e51c2cffd"},{"problem":75,"code":"(fn totient [n]\n  (let [gcd #(loop [a %1\n                    b %2]\n               (if (= 0 a)\n                 b\n                 (recur (mod b a) a)))]\n    (reduce + (for [i (range n) :when (= (gcd i n) 1)]\n      1))))","user":"587ee260e4b052da650a6353"},{"problem":75,"code":"(fn totient [x]\n(if (= x 1) 1\n(letfn [(is-coprime [x y] \n  (let [s (min x y) l (max x y)] (= s (numerator (/ s l)))) )]\n (count (filter #(is-coprime x %) (range 1 x))))))","user":"56304db8e4b073c1cf7a9be5"},{"code":"(fn [x]\n  (let \n    [gcd (fn g[a b] (if (= b 0) a (g b (mod a b)))),\n     coprime (fn [y] (= 1 (gcd x y)))]\n  (if (= x 1)\n    1\n    (count (filter coprime (range 1 x))))\n))","problem":75,"user":"4e7db3b4535db169f9c796e1"},{"code":"(fn test123 [n]\n  (count (reduce\n   (fn [acc it]\n     (clojure.set/difference acc\n                             (if (= 0 (rem n it))\n                               (set (map (partial * it)\n                                         (range 1 (+ 1 (int (/ n it))))))\n                               #{})))\n   (set (range 1 (+ 1 n)))\n   (range 2 n))))","problem":75,"user":"52aa16d1e4b0c58976d9ac5a"},{"code":"(let [coprime (fn [x y] (= 1 (apply max (filter #(and (zero? (mod x %)) (zero? (mod y %))) (range 1 (inc (min x y)))))))]\n\t(fn [x] (if (= x 1) 1 (count (filter #(coprime x %) (range 1 x))))))","problem":75,"user":"52570aeae4b0541d1855ba42"},{"problem":75,"code":"(fn [x]\n  (letfn [(gcd [a b]\n             (if (zero? b)\n               a\n               (recur b (mod a b))))]\n    (->> (range x)\n         (filter #(= 1 (gcd % x)))\n         count)))","user":"5dc88a38e4b02f9375f4e1db"},{"problem":75,"code":"#(case %\n   1 1\n   10 4\n   40 16\n   60)","user":"5507cfd3e4b021ccfedb96ad"},{"code":"(letfn [(gcd [a b]\n          (if (zero? b) a\n              (gcd b (mod a b))))]\n  (fn [n]\n    (if (= n 1) n\n        (count\n       (filter\n        #(= 1 (gcd % n))\n        (range 1 n))))))","problem":75,"user":"52d1e364e4b0d9f9285948e7"},{"problem":75,"code":"(fn totient [n] ()\n  (let [gcdx (fn gcdx [n1 n2] ()\n        (if (> n1 n2)\n            (gcdx n2 n1)\n            (loop [m n1]\n              (if (and (zero? (mod n1 m)) (zero? (mod n2 m)))\n                  m\n                  (recur (dec m)))))) ]\n    (if (= n 1)\n        1\n        (- n (inc (reduce + (map (fn [m] (if (> (gcdx m n) 1) 1 0 )) (range 1 n))))))))","user":"579d9601e4b05b1deef9ae18"},{"problem":75,"code":"(fn [n]\n\t(letfn [(gcd [a b]\n\t\t\t   (if (zero? (rem a b))\n\t\t\t\t   b\n\t\t\t\t   (recur b (rem a b))))]\n\t(->> (range 1 (inc n)) (filter #(= 1 (gcd n %))) (count))))","user":"55b8c339e4b01b9910ae29b9"},{"problem":75,"code":"(fn [n]\n  (count \n    (filter \n      #(= 1 %)\n      (map #((fn gcd [n m]\n               (if (zero? m)\n                 n\n                 (recur m (mod n m)))) n %)\n        (range 1 (inc n))))))","user":"590b055ae4b047aa04b199c9"},{"code":"(fn [n]\n  (let [gcd #(if (zero? %2) % (recur %2 (rem % %2)))]\n    (count \n     (filter \n      #(= 1 (gcd n %))\n      (range 1 (inc n))))))","problem":75,"user":"51944aaae4b0142f60b4aedc"},{"code":"(fn [x]\n  (int (loop [x x lastn 0 acc x n 2]\n    (if (= x 1)\n      acc\n      (if (= (rem x n) 0)\n        (if (= lastn n)\n          (recur (quot x n) n acc n)\n          (recur (quot x n) n (* acc (- 1 (/ 1.0 n))) n))\n        (recur x n acc (inc n)))))))","problem":75,"user":"4e7f5a0b535db966e863cc41"},{"problem":75,"code":"(fn [n]\n  (cond\n    (= n 1) 1\n    :else (letfn\n            [(gcd [x y] (if (= 0 (rem x y)) y (gcd y (rem x y))))\n             (coprime [n p] (= 1 (gcd n p)))]\n            (count (filter (partial coprime n) (range 1 n))))))","user":"53e4fa2ce4b036ad0777e454"},{"problem":75,"code":"(fn [n]\n  (if (= n 1)\n    1\n    (let [gcd (fn [x y]\n                (loop [m (if (> x y) x y) n (if (= m x) y x) r (rem m n)]\n                  (if (= r 0) n (recur n r (rem n r)))))]\n      (reduce #(if (= (gcd %2 n) 1) (inc %1) %1) 0 (range 1 n)))))","user":"564a5a09e4b0284900eef656"},{"problem":75,"code":"(fn [n]\n  (letfn [(gcd [a b]\n            (cond (= 0 a) b\n                  (= 0 b) a\n                  :else (gcd b (mod a b))))]\n    (if (= 1 n) 1 (count (filter (fn [v] (= 1 (gcd v n)))(range 1 n))))))","user":"5a9dbb32e4b0d174b936c7f3"},{"code":"(fn [n]\n (letfn [(gcd [x y] (if (zero? y) x (recur y (mod x y))))]\n   (count (filter #(= 1 (gcd % n)) (range n)))))","problem":75,"user":"5097b556e4b00ad8bab4e970"},{"code":"(fn [n]\n  (let [gcd #(if (zero? %2)\n                %1\n                (recur %2 (mod %1 %2)))\n        coprime? #(= 1 (gcd n %))]\n    (count (filter coprime? (range n)))))","problem":75,"user":"4dafa380edd6309eace4d17c"},{"problem":75,"code":"(fn [n]\n  (letfn [(nok [a b]\n               (let [[x1 x2] (sort [a b])]\n                 (if (zero? x1) x2\n                   (nok x1 (mod x2 x1)))))\n          (coprime? [a b] (= 1 (nok a b)))]\n  \t(if (= 1 n) 1\n    \t(count \n      \t\t(filter #(coprime? % n)\n                \t(range 1 n))))))","user":"53286f84e4b09d4e7a9b5505"},{"problem":75,"code":"(fn [x] (letfn [(gcd [a b] (if (zero? b) a (recur b (mod a b))))] (count (filter #(= 1 (gcd x %)) (range 1 (inc x))))))","user":"58987ee9e4b00487982d52d2"},{"problem":75,"code":"(fn [x]\n    (if (= x 1)\n      1\n      (count (filter #(let [d (/ % x)] \n                        (and (not (integer? d)) (= x (denominator d))))\n                     (range 1 (inc x))))))","user":"513e8141e4b02b2a3d8235c1"},{"code":"(fn [n] (let [gcd (fn gcd [a b] (if (zero? b) a (gcd b (mod a b))))]\n   (if (= n 1) 1\n\t     (count (filter #(= (gcd n %) 1) (range 1 n))))))","problem":75,"user":"4e6e3a1e535d5021c1a89602"},{"code":"(fn [n]\n  (letfn [(gcd [a b] (if (= b 0) a (recur b (mod a b))))]\n    (inc (count (filter #(= 1 (gcd n %)) (range 2 n))))))","problem":75,"user":"504f57c7e4b0a02f9cffde71"},{"problem":75,"code":"(fn [x] \n  (letfn [(gcd [x y]      (->> (iterate dec (max x y))\n                               (some (fn [i] (when (every? zero? (map #(mod % i) [x y])) i)))))\n          (coprime? [x y] (= 1 (gcd x y)))]\n    (->> (range 1 (max x 2))\n         (filter (partial coprime? x))\n\t     count)))","user":"55cdc576e4b0e31453f64a1f"},{"problem":75,"code":"(fn [x]\n  (let [coprime? (fn [y] \n                   (not-any? #(and (= 0 (rem x %)) (= 0 (rem y %))) (range 2 (inc y))))]\n    (cond\n     (= 1 x) 1\n     :else (->> (range 1 x)\n                (filter coprime?)\n                (count)))))","user":"52860baae4b0239c8a67ae09"},{"code":"(fn [x]\n  (letfn [(gcd [m n]\n    \t\t(let [r (rem m n)]\n    \t\t\t(if(zero? r)\n      \t\t\t\tn\n      \t\t\t\t(gcd n r))))]\n  (reduce #(if(= 1 (gcd x %2)) (+ 1 %) %) 1 (range 2 x))))","problem":75,"user":"4ed8b598535d10e5ff6f52fc"},{"problem":75,"code":"(fn [x]\n  (let [gcd (fn [a b]\n              (if (= 0 b)\n                a\n                (recur b (mod a b))))]\n    (count (filter #(= 1 (gcd x %)) (range 1 (inc x))))))","user":"545e7ab0e4b01be26fd7467c"},{"problem":75,"code":"(fn [n]\n  (letfn [ ( gcd [a b]\n           (if (zero? b)\n               a\n               (recur b (mod a b))))]\n    (->>\n      (range (dec n) 1 -1)\n      (filter (fn [v] (= 1 (gcd n v))))\n      count\n      inc)))","user":"53a5bc3ae4b0ef122a8689c3"},{"problem":75,"code":"(fn cc[z](cond\n             (= z 1)1\n             :else(count(filter \n                          #(= '(1)\n                              (filter \n                                (fn[x](and (= 0 (mod z x)) \n                                           (= 0 (mod % x))))\n                                (range 1 z)))\n                          (range 1 z)))))","user":"5dadf73ee4b0f8c104ccfc86"},{"problem":75,"code":"(fn euler-phi [n]\n  (letfn [(gcd [a b]\n            (if (zero? (mod a b))\n              b\n              (recur b (rem a b))))]\n    (count (filter #(= 1 (gcd % n)) (range n)))))","user":"5ab564f8e4b073f177442639"},{"problem":75,"code":"(fn [i] (letfn [(gcd [a b] (if (zero? b) a (recur b, (rem a b)))), (coprime? [a b] (= 1 (gcd a b)))] (count (filter #(coprime? i %) (range 1 (inc i))))))","user":"56e6ef89e4b02e7e935eb6d0"},{"code":"(let [common-div (fn [a b]\n                     (first (filter #(= (mod a %) (mod b %) 0)\n                                    (reverse (range 1 (inc (min a b)))))))\n        coprime? (fn [a b] (= (common-div a b) 1))]\n    (fn [n] (if (= n 1)\n              1\n              (count (filter (partial coprime? n) (range 1 n))))))","problem":75,"user":"5370ef22e4b0fc7073fd6ea0"},{"problem":75,"code":"(fn [n]\n  (letfn [(gcd [a b] (let [rem (mod a b)] (if (= rem 0) b (gcd b rem))))]\n    (count (filter #(= 1 (gcd n %1)) (range 1 (+ 1 n))))))","user":"53d86564e4b0e771c302546b"},{"code":"#({10 4 40 16 99 60}% 1)","problem":75,"user":"4dd66da7535d2dad7130b5c8"},{"problem":75,"code":"(fn totient [num]\n (let [gcd (fn [a b]\n             (let [m (min a b)\n                   x (for [n (range 1 (+ 1 m))\n                           :when (and (= (mod a n) 0) (= (mod b n) 0))]\n                       n)]\n               (last x)))\n       coprimes (for [n (range 1 num)\n                      :when (= (gcd num n) 1)]\n                  n)]\n   (if (= num 1)\n     1\n     (count coprimes))))","user":"542c026ae4b0dad94371f29a"},{"problem":75,"code":"(let [gcd (fn [x y candidate]\n     \t\t  (if (= 0 (rem x candidate) (rem y candidate))\n                candidate\n                 (recur x y (- candidate 1))))]\n  (fn [x]\n    (if (= x 1) 1 (count (filter #(= (gcd x % %) 1) (rest (range x)))))))","user":"541709b0e4b01498b1a71a06"},{"code":"(letfn [\r\n  (gcd [a b]\r\n    (if (zero? b) a (recur b (rem a b))))\r\n  (coprime [a b]\r\n    (= (gcd a b) 1))\r\n  (totient [n]\r\n    (inc (count (filter #(coprime n %) (range 2 n)))))\r\n  ]\r\n  totient\r\n)","problem":75,"user":"4df3d4f4535d08e6dec9fe2c"},{"problem":75,"code":"(fn [v]\n  (if (not= v 1)\n    (letfn [(gcd [x y]\n              (cond\n                (= x y) x\n                (< x y) (recur (- y x) x)\n                (> x y) (recur (- x y) y)))]\n      (->> (range 1 v)\n           (map #(gcd v %))\n           (filter #(= 1 %))\n           (count)))\n    1))","user":"5c9dcb36e4b048ec896c5b1d"},{"problem":75,"code":"(fn [x]\n   (cond (= 1 x) 1\n         :else\n           (let [divisors (filter #(= (rem x %) 0) (range 2 x))]\n             (+ 1 (count ( filter nil? (map #(some (fn [y] (= 0 (rem % y))) divisors) (range 2 x))))))))","user":"53a5c7ffe4b0ef122a8689c4"},{"problem":75,"code":"(fn totient [x]\n  (->> (range 1 x)\n       (map #(/ % x))\n       (map denominator)\n       (filter (partial = x))\n       count\n       (max 1)))","user":"5d929ceae4b0915913b1d412"},{"problem":75,"code":"(fn [x] (letfn [(gcd [a b] (if (zero? b) a (recur b (mod a b))))]\n          (->> (range x) (filter #(= 1 (gcd x %))) count)))","user":"54055aa9e4b0addc1aec6665"},{"problem":75,"code":"(fn eulers-totient\n  [x]\n  (if (= x 1)\n    1\n    (let [prime-factors (filter #(= 0 (mod x %)) (filter #((fn isPrime? [x] \n                                                             (loop [origin x\n                                                                    cur (int (Math/sqrt x))] \n                                                               (if (= cur 1)\n                                                                 true\n                                                                 (if (= 0 (mod origin cur))\n                                                                   false\n                                                                   (recur origin (dec cur))))))\n                                                           %) (range 2 x)))\n          origin x]\n      (int (* origin (apply * (map #(- 1 (/ 1 %)) (identity prime-factors))))))))","user":"59b9e669e4b0a024fb6ae3db"},{"problem":75,"code":"(fn [x]\n    (if (= x 1)\n      1\n      (letfn [(gcd [a b]\n                (cond\n                  (> b a) (recur b a)\n                  (= b 0) a\n                  :else (recur b (mod a b))))]\n        (->> (range 1 x)\n             (filter (fn [i] (= 1 (gcd x i))))\n             (count)))))","user":"569f4dabe4b0542e1f8d1491"},{"problem":75,"code":"(fn [n]\n  (->> n\n       (range 2)\n       (reduce\n        (fn [res x]\n          (if (not-any? #(and (= 0 (mod n %))\n                              (= 0 (mod x %)))\n                        (range 2 (inc x)))\n            (inc res)\n            res))\n        0)\n       inc))","user":"58d2af83e4b03c36ff7e5907"},{"problem":75,"code":"(fn [x]\n  (count\n   (letfn\n       [(div? [a b] \n          (zero? (rem a b)))\n        (divisors [a b] \n          (for [i (range 1 (inc (min a b))) \n                :when (and (div? a i) (div? b i))] i))]\n     (filter (fn [i] (= [1] (divisors i x))) (range 1 (inc x))))))","user":"4f0f01c0535d0136e6c22329"},{"code":"(fn [x] (if (= x 1) 1 (count (filter #(= (denominator (/ % x)) x) (range 1 x)))))","problem":75,"user":"4e372223535deb9a81d77f39"},{"code":"(fn [x]\n  (let [gcd (fn [a b]\n              (cond\n                (zero? b) a\n                :else (recur b (mod a b))))]\n    (cond\n      (= x 1) 1\n      :else (->> (range x)\n                 (filter #(= (gcd x %) 1))\n                 count))))","problem":75,"user":"4eae5fe4535d7eef30807325"},{"problem":75,"code":"(fn [x]\n  (letfn [(gcd [a b] (if (= b 0) a (recur b (mod a b))))]\n          (if (= x 1) 1\n              (->> (range 1 x)\n                   (filter #(= (gcd x %) 1))\n                    count ))))","user":"5f419985e4b0955706451fab"},{"problem":75,"code":"(fn [n]\n  (let [gcd (fn [a b]\n              (let [r (rem a b)]\n                (if (zero? r)\n                  b\n                  (recur b r))))]\n    (count (filter #(= (gcd n %) 1) (range 1 (inc n)))) ))","user":"56441634e4b0018b46ad8c08"},{"problem":75,"code":"(let [gcd (fn [x y]\n    (loop [ds (range (min x y) 0 -1)]\n      (if (empty? ds) nil\n        (let [d (first ds)]\n          (if (= 0 (mod x d) (mod y d)) d (recur (rest ds)))\n        ))))]\n  (fn [n]\n    (if (<= n 1)\n    1\n    (count (filter (fn [x] (= (gcd x n) 1)) (range 0 n)))\n    )\n  )\n)","user":"5681afaae4b0945ebc182a87"},{"problem":75,"code":"(fn [in]\n  (letfn [(gcd [a b] \n               (if (zero? b) a\n                 (gcd b (rem a b))))]\n    (if (= in 1) 1 (count (filter #(= 1 (gcd in %)) (range 1 in))))))","user":"55e732c5e4b050e68259b492"},{"code":"(fn [num]\r\n  (if (= 1 num)\r\n    1\r\n    (count (let [factors\r\n        (fn [n] (set (cons n (rest (filter #(= 0 (mod n %)) (range 1 (inc (quot n 2)))))) ))]\r\n    (let [num-factors (factors num)\r\n          rest-factors (map factors (range 1 num))]\r\n      (filter #(empty? (clojure.set/intersection num-factors %)) rest-factors)\r\n      )))))","problem":75,"user":"4df3df8a535d08e6dec9fe2d"},{"problem":75,"code":"(fn [n] (if (= n 1) 1\n  (let [gcd #(cond (< %1 %2) (recur %2 %1)\n                   (= 0 %2) %1\n                   :else\n                   (recur %2 (mod %1 %2)))\n        gcds (for [i (range 1 n)]\n               (gcd n i))]\n    (count\n     (filter #(= 1 %) gcds)))))","user":"4f037faf535dcb61093f6af8"},{"problem":75,"code":"(fn [n]\n  (letfn [(gcd [a b] (if (zero? b) a (gcd b (rem a b))))\n          (coprime? [coprime] (= 1 (gcd coprime n)))]\n    (if (= n 1)\n      1\n      (->> n\n           (range 1)\n           (filter coprime?)\n           count))))","user":"50310713e4b05b7df5a0b84c"},{"problem":75,"code":"(fn [n]\n  (letfn [(gcd [x y]\n            (let [m (min x y) M (max x y)]\n              (if (zero? m)\n                M\n                (gcd (rem M m) m))))]\n    (count (filter #(= 1 (gcd % n)) (range n)))))","user":"58a0fc33e4b02bd94d917ea3"},{"code":"#(letfn [(gcd [a b]\n              (if (zero? b)\n                a\n                (recur b (mod a b))))\n         (eNums [x]\n                (for [e (range 1 (inc x))]\n                  (if (= 1 (gcd e x))\n                    e)))]\n   (count (remove nil? (eNums %))))","problem":75,"user":"5371167fe4b0fc7073fd6ea7"},{"problem":75,"code":"(fn [n]\n  (if (= n 1) 1\n    (letfn [(gcd [a b] (if (= b 0) a (recur b (mod a b))))]\n      (count (filter #(= 1 (gcd %1 n)) (range 1 n))))))","user":"5590e55de4b0277789237676"},{"code":"(fn [n] (let [\n  cm? (fn [a b] (= 0 (rem a b) (rem n b)))\n  cp? (fn [a] (= 1 (last (filter #(cm? a %) (range 1 (inc a))))))\n  ] (-> (filter #(cp? %) (range 2 n)) count inc)\n))","problem":75,"user":"4ef48422535dced4c769f236"},{"code":"(fn [n] (if (= n 1) \n           1\n           (first (reduce (fn [[c f] b]\n                            (cond\n                             (some #(= (mod b %) 0) f) [(dec c) f]\n                             (= (mod n b) 0) [(dec c) (conj f b)]\n                             1 [c f]))\n                          [(dec n) []]\n                          (range 2 n)))))","problem":75,"user":"50ae0d24e4b0a40c9cfb08ce"},{"problem":75,"code":"(fn [x]\n  (letfn [(gcd [a b] (cond (= a b) a (> a b) (gcd b (- a b)) :else (gcd b a)))\n          (coprimes [x] (filter #(= 1 (gcd x %)) (range 1 x)))]\n    (if (= x 1) 1 (count (coprimes x)))))","user":"55c20bd0e4b0e31453f64972"},{"problem":75,"code":"(fn [n]\n  (if (= n 1)\n    1\n    (let [gcd (fn [a b]\n                (loop [x (max a b)\n                       y (min a b)]\n                  (if (= (rem x y) 0)\n                    y\n                    (recur y (rem x y)))))\n          cp? (fn [a b]\n                (= 1 (gcd a b)))]\n      (count \n       (filter #(cp? n %)\n               (range 1 n))))))","user":"55995fa7e4b031d6649c9ba9"},{"problem":75,"code":"(fn [n]\n(loop [acc [1] all (range 2 n)]\n(if-let [prime (first all)]\n(if (= (mod n prime) 0)\n(recur acc (filter #(not (= (mod % prime) 0)) (rest all)))\n(recur (conj acc prime) (rest all)))\n(count acc))))","user":"565b941ce4b068f2fe63dc07"},{"problem":75,"code":"(fn eulers-totient [n]\n  (let [gcd (fn [x y]\n              (if (= 0 y) x (recur y (mod x y))))]\n    (->> (range n) (filter #(= 1 (gcd % n))) count)))","user":"52c5c1c8e4b0c2d177d620fc"},{"problem":75,"code":"(fn [n] (let [gcd (fn f [a b] (if (= 0 (mod a b)) b (f b (mod a b))))]\n   (count (filter #(= (gcd n %) 1) (take n (iterate inc 1))))))","user":"5632e850e4b0bfe05bf117ac"},{"problem":75,"code":"(fn [x]\n  (count (filter #(loop [a x b %]\n                    (if (zero? b)\n                      (= a 1)\n                      (recur b (mod a b))))\n                 (range 1 (inc x)))))","user":"5136f659e4b04059df19f2fd"},{"problem":75,"code":"(fn euler [n]\n  (count (if (= 1 n)\n      [1]\n      (let [gcd (fn [a b]\n                  (if (zero? b)\n                    a\n                    (recur b (mod a b))))]\n        (loop [result []\n               i 1]\n          (if (> n i)\n            (let [gcd-val (gcd n i)]\n              (if (= 1 gcd-val)\n                (recur (conj result i) (inc i))\n                (recur result (inc i))))\n            result))))))","user":"5e348945e4b0650de70e2b1d"},{"problem":75,"code":"(fn [n]\n  (let [gdc (fn [n m] (if (zero? (mod n m)) m (recur m (mod n m))))\n        cop? (fn [m] (= (gdc n m) 1))]\n    (->> n\n         range\n         (map inc)\n         (filter cop?)\n         count)))","user":"53908e6be4b0b51d73faae9a"},{"code":"(fn [x]\n  (if (= x 1)\n    1\n    (letfn [(coprime [x y] (empty?\n                            (remove nil?\n                                    (for [i (range 2 (inc y))]\n                                      (when (= (rem x i) (rem y i) 0)\n                                        x)))))]\n      (count (filter (partial coprime x) (range 1 x))))))","problem":75,"user":"4daeabf6edd6309eace4d15c"},{"problem":75,"code":"(fn totient [n] (if (= n 1) 1 (count (filter #(= (numerator (/ % n)) %) (rest (range n))))))","user":"542c1f73e4b0dad94371f29d"},{"code":"(fn [n]\n   (inc (count (filter #(= (str % '/ n) (str (/ % n))) (range 2 n)))))","problem":75,"user":"4f036d9b535dcb61093f6ac1"},{"problem":75,"code":"(fn [x]\n  (->> (range x)\n       (map #(loop [a x b %] ;; gcd function\n               (if (zero? b)\n                 a\n                 (recur b (mod a b)))))\n       (filter #(= 1 %))\n       (count)))","user":"5d2e5065e4b01671435dbcae"},{"code":"(fn [n] (letfn [(coprime? [a b] (every? (complement zero?) (map #(+ (rem a %) (rem b %)) (range 2 (inc b)))))]\n                 (count (filter #(coprime? % n) (range 1 (inc n))))))","problem":75,"user":"4f3cd535e4b0e243712b1f56"},{"code":"(fn euler_s-totient-function [x]\n  (letfn [(e? [x y]\n            (loop [i 2]\n              (cond (> i x) true\n                    (= 0 (rem x i) (rem y i)) false\n                    :else (recur (inc i)))))]\n\n    (reduce \n     #(if (e? (inc %2) x) (inc %) %) \n     0\n     (range 0 x))))","problem":75,"user":"515bbcd9e4b0388ca8ca1521"},{"problem":75,"code":"(fn [x]\n   (if (= 1 x)\n     1\n     (inc (count (filter (fn [y]\n               (every? #(not= 0 (rem x %) (rem y %)) (range 2 (inc y)) )\n\n               ) (range 2 x))\n             )))\n   )","user":"53ca23e3e4b00fb29b2212c6"},{"problem":75,"code":"(fn [num] (let [gcd (fn gcd [x y] (if (= y 0) x (gcd y (mod x y))))]\n             (count (filter #(= 1 ((partial gcd num) %1)) (range 0 num 1)))))","user":"567f988be4b0feffd0d18ebe"},{"code":"(fn \n  [a]\n  (let \n    [gcd (fn gcd [x y]\n           (cond\n            (== x y) x \n            (< x y) (gcd y x) \n            :default (gcd (- x y) y)))] \n    (->> (inc a)\n         range\n         rest\n         (filter #(== 1 (gcd % a)))\n         count)))","problem":75,"user":"513b77f3e4b00f740c76c403"},{"problem":75,"code":"(fn [n]\n    (if (= n 1) 1\n        (letfn [(f [x]\n                  (into #{x}\n                        (filter (comp zero? #(mod x %))\n                                (range 2 (/ (inc x) 2)))))]\n          (->> (range 1 n)\n               (map f)\n               (filter (comp empty? #(clojure.set/intersection (f n) %)))\n               count))))","user":"54236ce1e4b01498b1a71ad1"},{"code":"(letfn [(gcd [a b]\n           (if (= b 0)\n             a\n             (recur b (mod a b))))]\n  (fn [n]   (Math/round  (reduce + (map (fn [k] (* (gcd k n) (Math/cos (* 2 (. Math PI) (/ k n)))))  (range 1 (inc n)))))))","problem":75,"user":"4e9a1512535dbda64a6f6b6e"},{"code":"(fn [x] (count (filter \n  (fn [y] (if (= 1 \n    (loop [x x y y]\n      (if (zero? y) x (recur y (mod x y))))) true false))\n        (range x))))","problem":75,"user":"4faec810e4b081705acca24e"},{"code":"(fn [n]\r\n  (inc\r\n\t\t(count \r\n\t\t\t(filter #(= n (numerator %)) \r\n\t\t\t\t(filter ratio? \r\n\t\t\t\t\t(map #(/ n %) (range 2 n)))))))","problem":75,"user":"4ecf1f51535d1f5ad70dba3a"},{"code":"(fn [n]\r\n  (->> (range 2 n)\r\n    (filter (fn [x]\r\n              (= 1 ((fn gcd [a b]\r\n                      (if (= 0 b) a (gcd b (mod a b))))\r\n                    x n))))\r\n    count\r\n    inc))","problem":75,"user":"4e1158aa535d04ed9115e7c6"},{"problem":75,"code":"(fn [n]\n   (letfn [(isFactor [n x] (= 0 (rem n x)) )]\n     (let [ops (range 2 n)\n           factors (filter (partial isFactor n) ops)]\n       (inc (count (filter #(not-any? (partial isFactor %) factors) ops))) )))","user":"58d27bcae4b03c36ff7e58fe"},{"code":"(fn [n] (letfn [(gcd [a b] (if (= b 0) a (recur b (mod a b))))]\n  \t({1 1} n (count (filter #(= 1 (gcd n %)) (range 1 n))))))","problem":75,"user":"519ef784e4b087743fad2198"},{"code":"(fn [x]\n  (if (= 1 x)\n    1\n    (let [gcd (fn [a b]\n                (if (= 0 a)\n                  b\n                  (recur (rem b a) a)))]\n      (count (filter #(= 1 (gcd x %)) (range 1 x))))))","problem":75,"user":"53460d02e4b084c2834f4a39"},{"code":"(fn [n]\n   (let [g (fn g [a b] (if (= b 0) a (g b (rem a b))))]\n     (if (= n 1)\n       1\n       (count (filter #{1} (map #(g n %) (range 1 n)))))))","problem":75,"user":"50a5b7e9e4b0aa96157e2610"},{"code":"(fn eulers-totient\n    [num]\n    (letfn [(divisors [n] (filter #(= (quot n %)\n                                      (/ n %))\n                                  (range 1 (inc n))))\n            (coprime [x y]\n              (= #{1}\n                 (clojure.set/intersection (set (divisors x))\n                                           (set (divisors y)))))]\n      (count (filter #(coprime num %) (range 1 (inc num))))))","problem":75,"user":"4dbb0f2d535d1e037afb21b1"},{"problem":75,"code":"(fn [n]\n \n (letfn [(gcd   [a b]\n  (if (zero? b)\n    a\n    (gcd b (mod a b))\n  )\n  )]\n  (if (= 1 n) 1\n  (count (filter  #(= 1 (gcd % n) ) (range 1 n) ) )\n  )\n  \n )\n  \n  )","user":"5735ac67e4b0cd1946bd102b"},{"problem":75,"code":"(fn eulr [to]\n\t(if (= to 1)\n\t\t1\n\t\t(letfn \n\t\t\t[(gcd [x y]\n\t\t\t\t(loop [val (min x y)]\n\t\t\t\t\t(if (= 0 (mod x val) (mod y val))\n\t\t\t\t\t\tval\n\t\t\t\t\t\t(recur (dec val)))))]\n\n\t\t\t(->>\n\t\t\t\t(range 1 to)\n\t\t\t\t(map #(gcd to %))\n\t\t\t\t(filter #(= 1 %))\n\t\t\t\t(count)\n\t\t\t\t))))","user":"5c87c79be4b048ec896c591b"},{"problem":75,"code":"(fn [n]\n  (let [gcd (fn f [x y] (if (= y 0) x (f y (mod x y))))]\n    (inc (count \n     (filter \n      #(= 1 (gcd % n)) \n      (range 2 n))))))","user":"543d5c61e4b032a45b86934d"},{"problem":75,"code":"(letfn\n    [(factors [n]\n       (set (filter #(zero? (rem n %)) (range 1 (inc n)))))]\n    \n    (fn totient [x]\n      (if (= 1 x)\n        1\n        (let [xf (factors x)]\n          (->> (range 1 x)\n               (map factors)\n               (map #(clojure.set/intersection xf %))\n               (filter #(= (count %) 1))\n               (count))))))","user":"58ec1e63e4b056aecfd47d54"},{"problem":75,"code":"(let [euclid-gcd (fn\n                   [a b]\n                   (loop [x a\n                          y b]\n                     (if (= (mod x y) 0)\n                       y\n                       (recur y (mod x y)))))]\n  (let [coprime? (fn [x y] (= 1 (euclid-gcd x y)))]\n    (fn euler-totient\n      [x]\n      (count (filter #(coprime? % x) (take x (range)))))))","user":"58152157e4b0f478707a0631"},{"problem":75,"code":"(let [gcd (fn [& nums]\n             (let [[big lil] (sort > nums)]\n               (loop [a big\n                      b lil]\n                 (let [q (quot a b)\n                       r (rem a b)]\n                   (if (zero? r)\n                     b\n                     (recur b r))))))\n       coprime? (fn [n1 n2]\n                  (== 1 (gcd n1 n2)))\n       f (fn [n]\n           {:pre [(pos? n)]}\n           (if (== 1 n)\n             1\n             (->> (range 1 n)\n                  (filter (partial coprime? n))\n                  count)))]\n   f)","user":"53684a2fe4b0243289761e8c"},{"problem":75,"code":"(fn totient [x]\n  (if (= x 1)\n    1\n    (letfn [(coprime? [x y]\n              (not-any? #(= 0 (rem x %) (rem y %))\n                        (cons 2 (range 3 (inc (min x y)) 2))))]\n      (count (filter #(coprime? % x)\n                     (range 1 x))))))","user":"573d58c8e4b05c31a32c0811"},{"problem":75,"code":";Calculating the divisors of a number is rather costly so we will have to reduce the number of numbers to be checked.\n;First, we get all divisors of te given number N. Then we can skip all numbers less than N which are multiples of these\n;divisors. The remaining numbers need to be checked individually.\n;\n \n\n(let [divisors\n            (fn [nmb]\n              (let [c1 (for [n (range 2 nmb) :while(<= n (int (/ nmb n))) :when(= (mod nmb n) 0)] n)\n                    c2 (reverse (cons nmb (for [x c1] (/ nmb x))))]\n                (concat c1 c2)\n              )\n            )\n     ]\n\n    (fn totient[N]\n      (let [c1 (divisors N)\n            cskip (for [i (range 1 N) n c1 :while(< (* i n) N)] (* i n))\n            c2 (filter (fn[x] (every? (fn[y] (not= x y)) cskip)) (range 2 N))\n           ]\n      (inc (count c2))\n    )\n  )\n)","user":"545537c1e4b0e397800069dd"},{"code":"(fn [n]\n  (let [coprime? (fn f [max min] \n                   (if (= 0 (mod max min))\n                       (= 1 min)\n                       (recur min (mod max min))))]\n        (loop [i 1 s 0]\n          (if (> i n)\n              s\n              (if (coprime? n i)\n                  (recur (inc i) (inc s))\n                  (recur (inc i) s))))))","problem":75,"user":"50435689e4b034ff00315d21"},{"problem":75,"code":"(fn totient [x]\n  (let [gcd (fn [a b]\n              (if (zero? b)\n                a\n                (recur b (mod a b))))\n        coprime (fn [a b]\n                  (= (gcd a b) 1))]\n    (count (filter #(coprime x %) (range 1 (inc x))))))","user":"53e27bf1e4b036ad0777e3f2"},{"code":"(fn totient [x]\n  (let [gcd (memoize (fn gcd [a b]\n              (cond\n               (< a b) (gcd a (- b a))\n               (> a b) (gcd (- a b) b)\n               :else a)))\n        coprime? (fn [p q] (= 1 (gcd p q)))]\n    (if (= x 1) 1 (apply + (map #(if (coprime? % x) 1 0) (range 1 x))))))","problem":75,"user":"536d83cee4b0fc7073fd6e5e"},{"code":"(fn totient [x]\n        (letfn [(gcd [a b] (if (= b 0) a (recur b (mod a b))))]\n          (if (= 1 x) 1\n            (count (filter #(= 1 (gcd x %)) (range 1 x))))))","problem":75,"user":"4f031eac535dcb61093f6a67"},{"problem":75,"code":"(fn [x]\n    (let [ divisors (filter #(= 0 (mod x %)) (range 2 x)) ]\n      (->> (range 2 x)\n           (filter (fn [y] (every? #(not (= 0 (mod y %)))  divisors)))\n           count\n           inc\n           )))","user":"4f5e5975e4b0030a34fb2b4d"},{"problem":75,"code":"(fn phi [n]\n  (letfn [(gcd [a b] (if (zero? b) a (recur b (mod a b))))]\n    (if (= n 1) 1\n        (->> (range 1 n)\n             (filter #(= 1 (gcd n %)))\n             count))))","user":"60b7e2c5e4b0e0fa5f1b4252"},{"code":"(fn totient [x]\n  (let [gcd (fn [a b]\n              (cond (= b 0) a\n                    :else (recur b (mod a b))))]\n    (if (= x 1) 1\n        (count (filter #(= 1 (gcd % x)) (range 1 x))))))","problem":75,"user":"4e7f51eb535db966e863cc3f"},{"code":"(fn [x]\n  (letfn [(gcd [a b] (if (zero? b) a (recur b (mod a b))))\n          (coprime? [a b] (= 1 (gcd a b)))]\n  (if (= x 1) 1 (count (filter #(coprime? % x) (range x))))))","problem":75,"user":"4e4ad154535dc968683fc4d1"},{"problem":75,"code":"(fn [x]\n  (if (= 1 x)\n    1\n    (letfn [(gcd [a b] \n              (cond\n                (= a b) a\n                (> a b) (recur (- a b) b)\n                :else   (recur a (- b a))))]\n      (->> (range 1 x)\n           (filter #(= 1 (gcd x %)))\n           (count)))))","user":"56c4f43ce4b05cc29241ee9c"},{"problem":75,"code":"#(->>\n  (for [x (range 2 %) y (range 2 %)\n        :when (and (zero? (mod % x)) (zero? (mod y x)))] y)\n  (into #{1})\n  count\n  (- %)\n  (if (= 1 %) 1))","user":"532ecd44e4b019098a6f8b49"},{"code":"(fn [n]\n  (count \n    (filter \n      #(= 1 ((fn [a b] (if (= b 0) a (recur b (mod a b)))) n %)) \n      (range 1 (+ 1 n)))))","problem":75,"user":"4e5411e8535d8a8b8723a279"},{"problem":75,"code":"(fn [n]\n    (letfn [(gcd [a b]\n              (if (zero? b)\n                a\n                (gcd b (mod a b))))]\n      (count (filter (comp (partial = 1) (partial gcd n)) (range 1 (inc n))))))","user":"5bd0ea60e4b0e9689409ee45"},{"problem":75,"code":"(fn [n] (if (= n 1) 1 (count (filter #(= 1((fn [x y] (if (= y 0) x (recur y (mod x y)))) n %)) (range 1 n)))))","user":"5504dd64e4b086ebe8a79c83"},{"problem":75,"code":"(letfn [(coprime? [x y]\n                  (not-any? #(= 0 (mod x %) (mod y %))\n                            (range 2 (inc (min x y)))))]\n  (fn [n]\n    (->> (range 2 n)\n         (filter (partial coprime? n))\n         count\n         inc)))","user":"4fceda40e4b03432b189f407"},{"problem":75,"code":"(fn [x] (let [gcd_fn (fn [a b] (if (zero? b)\n    a\n    (recur b (mod a b))))\n              co_prime_fn (fn [a b] (= 1 (gcd_fn a b)))\n              ]\n          (count (filter #(co_prime_fn x %) (range x)))))","user":"4ea882c7535d7eef308072fc"}]